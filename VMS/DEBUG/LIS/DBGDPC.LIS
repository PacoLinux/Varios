
; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DBGDPC 	( ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE),
;	0002			IDENT = '000013') =
;	0003	BEGIN
;	0004	
;	0005	!
;	0006	!			  COPYRIGHT (c) 1977 BY
;	0007	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0008	!
;	0009	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0010	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0011	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0012	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0013	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0014	! TRANSFERRED.
;	0015	!
;	0016	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0017	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0018	! CORPORATION.
;	0019	!
;	0020	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0021	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0022	!
;	0023	
;	0024	!++
;	0025	! FACILITY:	DEBUG (DBG)
;	0026	!
;	0027	! ABSTRACT:
;	0028	!	analyzes PC correlation tables for DEBUG and for symbolic
;	0029	!	traceback.
;	0030	!
;	0031	! ENVIRONMENT:	VAX/VMS, user mode, interrupts disabled.
;	0032	!
;	0033	! AUTHOR:	Carol Peters, CREATION DATE:	16 September 1977
;	0034	!
;	0035	! Version	13
;	0036	!
;	0037	! MODIFIED BY:
;	0038	!		Kevin Pammett, 10-may-1978: Version 13
;	0039	!
;	0040	! 02	05-10-77	CP	SIGNAL errors.
;	0041	! 03	18-11-77	CP	Add diagnostics. Correct swapped arguments
;	0042	!				in call to proc_pc_cmd. Add argument to
;	0043	!				pc_to_line for routine start address.
;	0044	! 04	22-11-77	CP	Change the third argument to pc_to_line
;	0045	!				to be the address of a location that holds
;	0046	!				the exception type.
;	0047	! 05	8-dec-77	KGP	-Changed PC_TO_LINE so that rather than requiring
;	0048	!				 that the DST be 'positioned' for its search
;	0049	!				 thru for PC correlation records, that it instead
;	0050	!				 does this itself.
;	0051	! 06	29-12-77	CP	Add routine get_line_no. Determines 
;	0052	!				whether a trace trap has occurred at the
;	0053	!				beginning of a FORTRAN line number.
;	0054	! 07	4-jan-78	KGP	-Fixed bug in GET_LINE_NO which was that
;	0055	!				 it assumed that pathnames always went

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 1-1
; Digital Equipment Corporation
;
;	0056	!				 thru atleast 1 ROUTINE name.
;	0057	! 08	3-feb-78	KGP	-Changed dbg$pc_to_line so that it can be
;	0058	!				 used to print fortran break/trace/watch
;	0059	!				 points with %line NN.
;	0060	! 09	14-mar-78	KGP	-Changed PC_TO_LINE so that it now handles
;	0061	!				 the delta-PC command "incr line #" OK.
;	0062	! 10	23-mar-78	KGP	-Put code to LOCK the GST around calls
;	0063	!				 to VAL_TO_SYM when we are looking for a
;	0064	!				 base to evaluate %LINEs from.
;	0065	! 11	12-apr-78	KGP	-Changed PC_TO_LINE so that it does NOT
;	0066	!				 signal NOSUCHLIN when it can't find what
;	0067	!				 it was asked to.  This is now done in
;	0068	!				 BUILD_PATH which properly implements the
;	0069	!				 search rules for %LINE
;	0070	!				-PC_TO_LINE now makes sure that the symbol
;	0071	!				 it finds is of type ROUTINE
;	0072	! 12	27-APR-78	DAR	Modified the require and library directives
;	0073	!				for the native build.
;	0074	! 13	10-may-78	KGP	-Changed GET_LINENO do let PC_TO_LINE
;	0075	!				 do most of the work, and so that it now
;	0076	!				 works with the full implementation of
;	0077	!				 FORTRAN stepping.
;	0078	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 2
; Digital Equipment Corporation
;
;	0079	! TABLE OF CONTENTS:
;	0080	!
;	0081	
;	0082	FORWARD ROUTINE
;	0083		dbg$get_lineno,				! tries to match the PC of
;	0084							! a trace trap to a line number
;	0085		dbg$pc_to_line,				! matches a PC to a line number
;	0086		get_next_dpc,				! gets the next PC correlation record
;	0087		proc_pc_cmd;				! processes a string of PC correlation commands
;	0088	
;	0089	!
;	0090	! INCLUDE FILES:
;	0091	!
;	0092	%IF %VARIANT		! True for TEN.
;     L 0093	%THEN
;     U 0094	LIBRARY 'NEW:STARLE';
;     U 0095	
;     U 0096	REQUIRE 'DBGPCT.REQ';
;     U 0097	REQUIRE 'DBGGEN.REQ';
;     U 0098	REQUIRE 'VXSMAC.REQ';
;     U 0099	REQUIRE 'DBGRST.REQ';
;     U 0100	REQUIRE 'DBGMSG.REQ';
;     U 0101	REQUIRE 'SYSSER.REQ';
;     U 0102	%ELSE
;	0103	LIBRARY 'SYS$LIBRARY:STARLET.L32';
;	0104	
;	0105	REQUIRE 'SRC$:DBGPCT.REQ';
;	0117	REQUIRE 'SRC$:DBGGEN.REQ';
;	0367	REQUIRE 'SRC$:VXSMAC.REQ';
;	0407	REQUIRE 'SRC$:DBGRST.REQ';
;	1554	REQUIRE 'LIB$:DBGMSG.REQ';
;	1833	REQUIRE 'SRC$:SYSSER.REQ';
;      R1836	SWITCHES LIST (SOURCE);
;      R1837	
;      R1838	EXTERNAL ROUTINE
;      R1839		dbg$fao_out;				! formats a line and outputs to the terminal
;      R1840	
;      R1841	SWITCHES LIST (NOSOURCE);
;	1886	%FI
;	1887	
;	1888	!
;	1889	! MACROS:
;	1890	!
;	1891	
;	1892	MACRO
;	1893		first_dpc_datum	= 2, 0, 32, 0%,		! passes count and type
;	1894		current_byte	= 0, 0, 8, 1%,		! current top of record
;	1895		next_uns_byte	= 1, 0, 8, 0%,		! byte argument to command
;	1896		next_uns_word	= 1, 0, 16, 0%,		! word argument to command
;	1897		add_one_byte	= 1, 0, 8, 0%,		! increment for top of record
;	1898		add_two_bytes	= 2, 0, 8, 0%,		! ditto
;	1899		add_three_bytes	= 3, 0, 8, 0%;		! ditto
;	1900	
;	1901	!
;	1902	! EQUATED SYMBOLS:

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 2-1
; Digital Equipment Corporation
;
;	1903	!
;	1904	
;	1905	LITERAL
;	1906	
;	1907	! these are temporary
;	1908		dbg$_noinfo	= 0,			! no information on line numbers
;	1909		dbg$_not_a_line	= 2,			! this is not a line number
;	1910	! end of temporary
;	1911	
;	1912		word_delta	= 1,			! delta-PC command of length word
;	1913		byte_temp_incr	= 2,			! increment current line by next byte
;	1914		word_temp_incr	= 3,			! increment current line by next word
;	1915		byte_perm_incr	= 4,			! increment line increment by next byte
;	1916		word_perm_incr	= 5,			! increment line increment by next word
;	1917		incr_to_1	= 6,			! line increment reverts to 1
;	1918	
;	1919		dbg_dpc		= 0,			! debugging aid
;	1920		dbg_dpc1	= 0;			! ditto
;	1921	
;	1922	!
;	1923	! OWN STORAGE:
;	1924	!
;	1925	
;	1926	!
;	1927	! EXTERNAL REFERENCES:
;	1928	!
;	1929	
;	1930	EXTERNAL ROUTINE
;	1931		dbg$get_dst_rec,			! gets a DST record from a DST pointer.
;	1932		dbg$val_to_sym,				! Translate values to symbols.
;	1933		dbg$get_nxt_dst,			! gets next DST record in sequence
;	1934		DBG$POSITON_DST;			! Set up the DST 'next' sequence.
;	1935	external
;	1936							! The RST's MC chain pointer.
;	1937		dbg$gl_mc_ptr : ref MC_RECORD;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 3
; Digital Equipment Corporation
;
;	1938	GLOBAL ROUTINE dbg$get_lineno (pc_value) =
;	1939	!++
;	1940	! Functional description:
;	1941	!	Translate a PC value to the name of its containing routine.
;	1942	!	If the routine is in FORTRAN, see whether the PC corresponds
;	1943	!	precisely to a line number. If it does, return a success code.
;	1944	!
;	1945	! 	In all otherwise cases, return error codes saying either that
;	1946	!	no information about line numbers can be obtained, or that
;	1947	!	the PC does not exactly match a line.
;	1948	!
;	1949	! Calling sequence:
;	1950	!	dbg$get_lineno (pc_value.rv)
;	1951	!
;	1952	! Input parameters:
;	1953	!	pc_value	- the value of the PC at the time of the trace trap.
;	1954	!
;	1955	! Implicit inputs:
;	1956	!	PC_TO_LINE does most of the necessary checking
;	1957	!	on the symbol-to-value correspondence we pick up.
;	1958	!
;	1959	! Output parameters:
;	1960	!	none
;	1961	!
;	1962	! Implicit outputs:
;	1963	!	none
;	1964	!
;	1965	! Routine value:
;	1966	!	ss$_normal	- success, returning a line number.
;	1967	!	dbg$_noinfo	- don't know anything about this PC.
;	1968	!	dbg$_not_a_line	- this PC does not match a line number.
;	1969	!
;	1970	! Side effects:
;	1971	!	none
;	1972	!
;	1973	!--
;	1974	
;	1975	BEGIN
;	1976	
;	1977		LOCAL
;	1978			STATUS,
;	1979			dst_entry	: REF dst_record,	! address of DST record
;	1980			routine_ptr	: REF nt_record,	! address of routine name NT entry
;	1981			module_ptr	: REF nt_record,	! address of module name NT entry
;	1982			exc_type,				! type of exception
;	1983			line_no_1,				! for line number
;	1984			line_no_2;				! for superfluous line number
;	1985	
;	1986		!++
;	1987		! First match the PC to a symbolic name. If this fails, we know
;	1988		! nothing.  Make sure that a global does not come
;	1989		! back from VAL_TO_SYM as that doesn't
;	1990		! position the DST as we want it to, and as a global answer
;	1991		! means that the indicated routine is NOT in the RST so we
;	1992		! wouldn't know about the PC correlation tables.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 3-1
; Digital Equipment Corporation
;
;	1993		!--
;	1994		routine_ptr = 0;
;	1995		DBG$GL_MC_PTR[ MC_GBL_LOCKED ] = TRUE;
;	1996	
;	1997		STATUS = dbg$val_to_sym (.pc_value, routine_ptr, FALSE);
;	1998	
;	1999		DBG$GL_MC_PTR[ MC_GBL_LOCKED ] = FALSE;
;	2000		IF( NOT .STATUS )
;	2001		THEN
;	2002			BEGIN
;	2003	
;	2004	%IF dbg_dpc
;     L 2005	%THEN
;     U 2006			$fao_tt_out ('!/val to sym failed in get_lineno');
;     U 2007	%FI
;	2008	
;	2009			RETURN dbg$_noinfo;
;	2010			END;
;	2011	
;	2012		!++
;	2013		! This symbol has a DST entry because it is not global.   Go and  
;	2014		! get this entry, signaling a severe error on failure,
;	2015		! because this implies that there is something gravely wrong
;	2016		! in DEBUG itself.
;	2017		!--
;	2018		dst_entry = dbg$get_dst_rec (.routine_ptr [nt_dst_ptr]);
;	2019		IF .dst_entry EQL 0
;	2020		THEN
;	2021			BEGIN
;	2022	
;	2023	%IF dbg_dpc
;     L 2024	%THEN
;     U 2025			$fao_tt_out ('DST missing in get_lineno');
;     U 2026	%FI
;	2027			SIGNAL (dbg$_rsterr);
;	2028			! no return
;	2029			RETURN dbg$_noinfo
;	2030			END;
;	2031		!++
;	2032		! Set up the variables and try to do a PC to
;	2033		! line translation.   If this fails, return
;	2034		! an error code indicating that there is no
;	2035		! PC-to-line information.
;	2036		! Otherwise, return a success code. The pc_to_line
;	2037		! routine loads up the line number to be returned.
;	2038		! It also does checking to make sure that the symbol we
;	2039		! found is indeed a ROUTINE, and that the module this
;	2040		! came from is FORTRAN, etc.
;	2041		!--
;	2042		exc_type = lookup_exc;
;	2043		line_no_1 = 0;
;	2044		line_no_2 = .routine_ptr;
;	2045		IF NOT dbg$pc_to_line (
;	2046			pc_value,
;	2047			.dst_entry [dstr_value],

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 3-2
; Digital Equipment Corporation
;
;	2048			exc_type,
;	2049			line_no_1,	! returned value is the %line number found
;	2050			line_no_2)	! returned value is the corresponding PC
;	2051		THEN
;	2052			BEGIN
;	2053	
;	2054	%IF dbg_dpc
;     L 2055	%THEN
;     U 2056			$fao_tt_out ('no info for PC=!XL',.pc_value);
;     U 2057	%FI
;	2058			RETURN(dbg$_noinfo);
;	2059			END
;	2060		ELSE
;	2061			! See if the PC which corresponds to the line number
;	2062			! found to match is the same as the PC we asked
;	2063			! to be looked up.
;	2064	
;	2065			IF( .line_no_2 EQLA .pc_value )
;	2066			THEN
;	2067				BEGIN
;	2068	%IF dbg_dpc
;     L 2069	%THEN
;     U 2070				$fao_tt_out ('this is a line boundary');
;     U 2071	%FI
;	2072				RETURN ss$_normal;
;	2073				END
;	2074			ELSE
;	2075				BEGIN
;	2076	
;	2077	%IF dbg_dpc
;     L 2078	%THEN
;     U 2079				$fao_tt_out ('this is between two lines');
;     U 2080	%FI
;	2081				RETURN dbg$_not_a_line;
;	2082				END;
;	2083	END;


							    .TITLE  DBGDPC
							    .IDENT  \000013\

							    .GLOBL  DBG$_RST_BEGIN, DBG$FAO_OUT, DBG$GET_DST_REC, DBG$VAL_TO_SYM
							    .GLOBL  DBG$GET_NXT_DST, DBG$POSITON_DST, DBG$GL_MC_PTR

							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0C04 00000 	    .ENTRY  DBG$GET_LINENO, Save R2,R10,R11			      ; 1938
		         5A 00000000G  EF  9E 00002 	    MOVAB   DBG$GL_MC_PTR, R10					      ;
		         5B 00000000G  8F  D0 00009 	    MOVL    #DBG$_RST_BEGIN, R11				      ;
		         5E	       10  C2 00010 	    SUBL2   #16, SP						      ;
				  0C   AE  D4 00013 	    CLRL    ROUTINE_PTR						      ; 1994
	   50	         6A	       5B  C1 00016 	    ADDL3   R11, DBG$GL_MC_PTR, R0				      ; 1995
		    03   A0	       04  88 0001A 	    BISB2   #4, 3(R0)						      ;
				       7E  D4 0001E 	    CLRL    -(SP)						      ; 1997
				  10   AE  9F 00020 	    PUSHAB  ROUTINE_PTR						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 3-3
; Digital Equipment Corporation
;
				  04   AC  DD 00023 	    PUSHL   PC_VALUE						      ;
	      00000000G  EF	       03  FB 00026 	    CALLS   #3, DBG$VAL_TO_SYM					      ;
		         51	       50  D0 0002D 	    MOVL    R0, STATUS						      ;
	   50	         6A	       5B  C1 00030 	    ADDL3   R11, DBG$GL_MC_PTR, R0				      ; 1999
		    03   A0	       04  8A 00034 	    BICB2   #4, 3(R0)						      ;
		         51	       51  E9 00038 	    BLBC    STATUS, 3$						      ; 2000
	   50	    0C   AE	       5B  C1 0003B 	    ADDL3   R11, ROUTINE_PTR, R0				      ; 2018
				  04   A0  DD 00040 	    PUSHL   4(R0)						      ;
	      00000000G  EF	       01  FB 00043 	    CALLS   #1, DBG$GET_DST_REC					      ;
		         52	       50  D0 0004A 	    MOVL    R0, DST_ENTRY					      ;
				       0F  12 0004D 	    BNEQ    1$							      ; 2019
			    0002834A   8F  DD 0004F 	    PUSHL   #164682						      ; 2027
	      00000000G  00	       01  FB 00055 	    CALLS   #1, LIB$SIGNAL					      ;
				       2E  11 0005C 	    BRB     3$							      ; 2029
		         6E	       03  7D 0005E 1$:     MOVQ    #3, EXC_TYPE					      ; 2042
		    08   AE	  0C   AE  D0 00061 	    MOVL    ROUTINE_PTR, LINE_NO_2				      ; 2044
				  08   AE  9F 00066 	    PUSHAB  LINE_NO_2						      ; 2045
				  08   AE  9F 00069 	    PUSHAB  LINE_NO_1						      ;
				  08   AE  9F 0006C 	    PUSHAB  EXC_TYPE						      ;
				  03   A2  DD 0006F 	    PUSHL   3(DST_ENTRY)					      ;
				  04   AC  9F 00072 	    PUSHAB  PC_VALUE						      ;
		  0000V  CF	       05  FB 00075 	    CALLS   #5, DBG$PC_TO_LINE					      ;
		         0F	       50  E9 0007A 	    BLBC    R0, 3$						      ;
		    04   AC	  08   AE  D1 0007D 	    CMPL    LINE_NO_2, PC_VALUE					      ; 2065
				       04  12 00082 	    BNEQ    2$							      ;
		         50	       01  D0 00084 	    MOVL    #1, R0						      ; 2072
					   04 00087 	    RET     							      ;
		         50	       02  D0 00088 2$:     MOVL    #2, R0						      ; 2081
					   04 0008B 	    RET     							      ;
				       50  D4 0008C 3$:     CLRL    R0							      ; 1938
					   04 0008E 	    RET     							      ;

; Routine Size:  143 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4
; Digital Equipment Corporation
;
;	2084	GLOBAL ROUTINE dbg$pc_to_line (match_pc_ptr,
;	2085				       routine_address,
;	2086				       excep_type_ptr,
;	2087				       line_no_ptr,
;	2088				       line_no_2_ptr
;	2089				       ) =	! translates PC to line number and vice versa
;	2090	!++
;	2091	! FUNCTIONAL DESCRIPTION:
;	2092	!	This routine matches an absolute PC address to a line number
;	2093	!	in a FORTRAN routine. One of the parameters, match_pc_ptr or 
;	2094	!	line_no_ptr is always non-null. The other is written as a
;	2095	!	result of this routine's processing.
;	2096	!
;	2097	!	Each PC correlation record that exists for a single routine
;	2098	!	is sequentially analyzed until the desired PC or line number
;	2099	!	is seen.
;	2100	
;	2101	!	If a match cannot be made because and end of routine record or
;	2102	!	an invalid record is recognized, then this routine returns
;	2103	!	FALSE.
;	2104	!
;	2105	! FORMAL PARAMETERS:
;	2106	!
;	2107	!	match_pc_ptr	- a pointer to the PC to be matched or zero.
;	2108	!	routine_address	- address of routine that this PC is in.
;	2109	!	excep_type_ptr	- pointer to type of exception, where
;	2110	!				zero, means irrelevant;
;	2111	!			  	one, means trap type exception,
;	2112	!			  	two, means fault or abort type exception,
;	2113	!				three, means like 2, above, only line_no_2_ptr
;	2114	!					contains the correct NT_PTR already so we 
;	2115	!					avoid an unnecessary VAL_TO_SYM.
;	2116	!	line_no_ptr	- a pointer to the line number to be matched
;	2117	!			  or zero
;	2118	!	line_no_2_ptr	- a pointer to a second line number to be filled
;	2119	!			  if necessary. Not present if the matching is
;	2120	!			  from line number to PC.
;	2121	!			- For LOOKUP_EXC type matches, this parameter
;	2122	!			  points to the NT pointer for the symbol we 
;	2123	!			  are looking up lines relative to.  Also for
;	2124	!			  this type of match, the value passed back
;	2125	!			  via this parameter is the PC of the line number
;	2126	!			  passed back in LINE_NO_PTR
;	2127	!
;	2128	! IMPLICIT INPUTS:
;	2129	!
;	2130	!	However whoever came up with 'routine_address', we can get
;	2131	!	back the routine it came from via dbg$val_to_sym
;	2132	!
;	2133	! IMPLICIT OUTPUTS:
;	2134	!
;	2135	!	the routine get_nxt_dst is set up to next return the record after
;	2136	!	the end of routine record or the record after the PC correlation
;	2137	!	record that matched the given parameters.
;	2138	!

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-1
; Digital Equipment Corporation
;
;	2139	! ROUTINE VALUE:
;	2140	! COMPLETION CODES:
;	2141	!
;	2142	!	true, if success; false, if any error or if match cannot
;	2143	!	be made.
;	2144	!
;	2145	! SIDE EFFECTS:
;	2146	!
;	2147	!	The DST is positioned for a GET_NXT_DST sequence.
;	2148	!
;	2149	!--
;	2150	
;	2151		BEGIN
;	2152	
;	2153		MAP
;	2154			match_pc_ptr	: REF VECTOR,
;	2155			excep_type_ptr	: REF VECTOR,
;	2156			line_no_ptr	: REF VECTOR,
;	2157			line_no_2_ptr	: REF VECTOR;
;	2158	
;	2159		LOCAL
;	2160			LOOKUP_FLAG,		! Whether this is a LOOKUP_EXC
;	2161						! type match or not.
;	2162	
;	2163			dst_entry	: REF dst_record,
;	2164			dpc_entry	: REF BLOCK [, BYTE],
;	2165	
;	2166			current_line,
;	2167			new_line,
;	2168			increment,
;	2169			new_increment,
;	2170			start_pc,
;	2171			next_pc,
;	2172			RTN_NT_PTR : REF NT_RECORD,
;	2173			mc_ptr : REF MC_RECORD,
;	2174			report_back;
;	2175	
;	2176		! Normally we return 2 line numbers on a PC-lookup.
;	2177		! For one exception type, we return a line number
;	2178		! and a delta PC.
;	2179	
;	2180		LOOKUP_FLAG = FALSE;
;	2181	
;	2182		! Before we can fetch the DST's PC correlation tables,
;	2183		! we must first 'position' the DST to be pointing to 
;	2184		! the record after the BEGIN_ROUTINE DST record for the
;	2185		! routine we assume the %line <number> referrs to.
;	2186		! Do this by first (re-)deducing what routine this is.
;	2187		! This is not always necessary.
;	2188	
;	2189		IF( .EXCEP_TYPE_PTR[0] EQL LOOKUP_EXC )
;	2190		THEN
;	2191			BEGIN
;	2192	
;	2193			! Make this look like a FAULT_EXC, but save a flag

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-2
; Digital Equipment Corporation
;
;	2194			! to indicate that it really was LOOKUP_EXC type
;	2195			! so that we know what to return in LINE_NO_2_PTR.
;	2196	
;	2197			EXCEP_TYPE_PTR[0] = FAULT_EXC;
;	2198			LOOKUP_FLAG = TRUE;
;	2199	
;	2200			! The given line_no_2_ptr is actually an NT_PTR.
;	2201	
;	2202			RTN_NT_PTR = .line_no_2_ptr[0];
;	2203			END
;	2204		ELSE
;	2205			BEGIN
;	2206			LOCAL
;	2207				STATUS;
;	2208	
;	2209			! Lock the GST before calling val_to_sym because
;	2210			! we don't want a global to come back as the answer.
;	2211	
;	2212			RTN_NT_PTR = 0;
;	2213			DBG$GL_MC_PTR[ MC_GBL_LOCKED ] = TRUE;
;	2214	
;	2215			STATUS = dbg$val_to_sym( .routine_address, rtn_nt_ptr, FALSE );
;	2216	%if dbg_dpc
;     L 2217	%then
;     U 2218			$fao_tt_out('pc_to_line: val_to_sym status = !XL',.status);
;     U 2219	%FI
;	2220			DBG$GL_MC_PTR[ MC_GBL_LOCKED ] = FALSE;
;	2221			IF( NOT .STATUS )
;	2222			THEN
;	2223				RETURN(FALSE);
;	2224			END;
;	2225	%if dbg_dpc
;     L 2226	%then
;     U 2227		$fao_tt_out('pc_to_line: nt_ptr=!XW, type=!XB, dst_ptr=!XL',
;     U 2228			.rtn_nt_ptr,.rtn_nt_ptr[NT_TYPE],.rtn_nt_ptr[NT_DST_PTR]);
;     U 2229	%FI
;	2230		! The symbol we base a %LINE off must be of type routine.
;	2231	
;	2232		IF( .rtn_nt_ptr[ NT_TYPE ] NEQ DSC$K_DTYPE_RTN )
;	2233		then	
;	2234			return(false);
;	2235	
;	2236		! Before we can look at the supposed DST record pointer
;	2237		! associated with this symbol, we must make sure this is 
;	2238		! the case!  For now, this is always the case except for NTs
;	2239		! which are used for global symbols.  The latter NTs use this
;	2240		! DST_PTR field to hold the actual value associated with the
;	2241		! global symbol.
;	2242	
;	2243		IF( (mc_ptr = .RTN_NT_PTR[ NT_UP_SCOPE ]) EQL 0 )
;	2244		THEN
;	2245			RETURN(FALSE);
;	2246	
;	2247		!++
;	2248		! Check on the language. If it's not FORTRAN, just return with

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-3
; Digital Equipment Corporation
;
;	2249		! the appropriate error indicator.
;	2250		!--
;	2251	
;	2252		IF( .mc_ptr [mc_language] NEQ fortran_module )
;	2253		THEN
;	2254			BEGIN
;	2255	%IF dbg_dpc
;     L 2256	%THEN
;     U 2257			$fao_tt_out ('pc_to_line: not a FORTRAN module');
;     U 2258	%FI
;	2259			RETURN(FALSE);
;	2260			END;
;	2261	
;	2262		! Finally, position the DST.
;	2263	
;	2264		IF( DBG$POSITON_DST( .RTN_NT_PTR[ NT_DST_PTR ]) EQL 0 )
;	2265		THEN
;	2266			RETURN(FALSE);
;	2267	
;	2268		!++
;	2269		! Initialize state variables.
;	2270		!--
;	2271		report_back = FALSE;
;	2272		current_line = 0;
;	2273		increment = 1;
;	2274		start_pc = .routine_address;
;	2275	
;	2276	%IF dbg_dpc
;     L 2277	%THEN
;     U 2278		$fao_tt_out ('!/match PC is !XL, routine start is !XL, line number is !SL',
;     U 2279			.match_pc_ptr [0], .start_pc, .line_no_ptr [0]);
;     U 2280	%FI
;	2281	
;	2282		!++
;	2283		! Get the first PC correlation record. If none can be found
;	2284		! within this routine, then return false. When one is found,
;	2285		! load the address of the second byte of the record into a
;	2286		! pointer to the PC correlation data itself.
;	2287		!--
;	2288		IF NOT get_next_dpc (dst_entry)
;	2289		THEN RETURN FALSE
;	2290		ELSE
;	2291			BEGIN
;	2292			dpc_entry = dst_entry [dstr_access];
;	2293	
;	2294	%IF dbg_dpc1
;     L 2295	%THEN
;     U 2296			$fao_tt_out ('!/address of corr. record is !XL', .dst_entry);
;     U 2297			$fao_tt_out ('!/corr. record is !SB !SB !SB !SB !SB !SB !SB !SB !SB !SB',
;     U 2298					.dpc_entry [0, 0, 8, 1], .dpc_entry [1, 0, 8, 1],
;     U 2299					.dpc_entry [2, 0, 8, 1], .dpc_entry [3, 0, 8, 1],
;     U 2300					.dpc_entry [4, 0, 8, 1], .dpc_entry [5, 0, 8, 1],
;     U 2301					.dpc_entry [6, 0, 8, 1], .dpc_entry [7, 0, 8, 1],
;     U 2302					.dpc_entry [8, 0, 8, 1], .dpc_entry [9, 0, 8, 1]);
;     U 2303	%FI

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-4
; Digital Equipment Corporation
;
;	2304	
;	2305			END;
;	2306	
;	2307		!++
;	2308		! Call a routine that processes all PC correlation commands
;	2309		! until a delta-PC command is seen. Then process that
;	2310		! delta-PC command and return to this routine. If the processing
;	2311		! is generally successful, return true, otherwise return false.
;	2312		!--
;	2313		REPEAT
;	2314			BEGIN
;	2315			local
;	2316				last_line_num;
;	2317	
;	2318			last_line_num = .current_line;
;	2319	
;	2320			IF NOT proc_pc_cmd (current_line,
;	2321					    increment,
;	2322					    .start_pc,
;	2323					    next_pc,
;	2324					    dpc_entry,
;	2325					    dst_entry)
;	2326			THEN RETURN FALSE;
;	2327	
;	2328			!++
;	2329			! The newly processed delta-PC command may have given us
;	2330			! the matching PC or line number. According to what we
;	2331			! are searching for (a PC, a line number for a trap, or
;	2332			! a line number for a fault or abort), see whether we
;	2333			! have an answer. Otherwise, loop through proc_pc_cmd
;	2334			! again.
;	2335			!--
;	2336			CASE .excep_type_ptr [0] FROM 0 TO 2 OF
;	2337	
;	2338				SET
;	2339	
;	2340				[not_an_exc]:
;	2341					BEGIN
;	2342	
;	2343					!++
;	2344					! Searching for a PC. If the current
;	2345					! line number is the equivalent of
;	2346					! the line number we were passed, then
;	2347					! return with success and the PC.
;	2348					! If the current line number is greater
;	2349					! than what we were passed, then return
;	2350					! with FALSE and a zero.
;	2351					!--
;	2352					IF .last_line_num EQL .line_no_ptr [0]
;	2353					THEN 
;	2354						BEGIN
;	2355	
;	2356	%IF dbg_dpc
;     L 2357	%THEN
;     U 2358						$fao_tt_out ('!/matching PC is !XL', .start_pc);

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-5
; Digital Equipment Corporation
;
;     U 2359	%FI
;	2360	
;	2361						match_pc_ptr [0] = .start_pc;
;	2362						RETURN TRUE
;	2363						END;
;	2364					IF .last_line_num GTR .line_no_ptr [0]
;	2365					THEN
;	2366						BEGIN
;	2367	
;	2368	%IF dbg_dpc
;     L 2369	%THEN
;     U 2370						$fao_tt_out ('pc_to_line: no such line number');
;     U 2371	%FI
;	2372						match_pc_ptr [0] = 0;
;	2373						RETURN FALSE
;	2374						END;
;	2375					END;
;	2376	
;	2377	
;	2378				[trap_exc]:
;	2379					BEGIN
;	2380	
;	2381					!++
;	2382					! Searching for a line number. The PC
;	2383					! is set to the instruction following
;	2384					! the instruction that caused the trap.
;	2385					! Thus, if the PC we are trying to match
;	2386					! is greater than the PC of the current
;	2387					! line and less than or equal to the
;	2388					! PC of the next line, then the current
;	2389					! line is a reasonable chance for
;	2390					! the line number of the trap.
;	2391					!--
;	2392					IF ((.start_pc LSSA .match_pc_ptr [0]) AND
;	2393						(.match_pc_ptr [0] LEQA .next_pc))
;	2394					THEN report_back = TRUE;
;	2395					END;
;	2396	
;	2397	
;	2398				[fault_exc]:
;	2399					BEGIN
;	2400	
;	2401					!++
;	2402					! Searching for a line number. The PC
;	2403					! is set back to the beginning of the
;	2404					! instruction that caused the fault.
;	2405					! Thus, if the PC we are trying to
;	2406					! match is greater than or equal to the
;	2407					! PC of the current line and less than
;	2408					! the PC of the next line, then the
;	2409					! current line is a reasonable choice
;	2410					! for the line number of the fault.
;	2411					!--
;	2412					IF ((.start_pc LEQA .match_pc_ptr [0]) AND
;	2413						(.match_pc_ptr [0] LSSA .next_pc))

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-6
; Digital Equipment Corporation
;
;	2414					THEN
;	2415						BEGIN
;	2416	
;	2417						!++
;	2418						! WHen doing traceback, only the first
;	2419						! line, that reflects the current
;	2420						! PC, can be the result of a fault. All
;	2421						! others should be looked at as traps.
;	2422						!--
;	2423						excep_type_ptr [0] = trap_exc;
;	2424						report_back = TRUE;
;	2425						END;
;	2426					END;
;	2427	
;	2428				TES;
;	2429	
;	2430			!++
;	2431			! If a match was found, determine exactly which line
;	2432			! numbers to return. This involves scanning forward
;	2433			! in the correlation stream to compute the source line
;	2434			! number that would be assigned for the next delta-PC
;	2435			! command.
;	2436			!--
;	2437			IF .report_back
;	2438			THEN
;	2439				BEGIN
;	2440	
;	2441				LOCAL
;	2442					new_next_pc;
;	2443	%IF dbg_dpc
;     L 2444	%THEN
;     U 2445				$fao_tt_out ('!/current line is !SL, next PC is !XL',
;     U 2446					.current_line, .next_pc);
;     U 2447	%FI
;	2448				new_line = .current_line;
;	2449				new_increment = .increment;
;	2450				new_next_pc = .next_pc;
;	2451	
;	2452				!++
;	2453				! If an error occurs in the PC correlation
;	2454				! records, proc_pc_cmd sets the contents of
;	2455				! new line to zero and returns FALSE. Proc_pc_cmd
;	2456				! also returns FALSE if end of stream occurs
;	2457				! before another delta-PC command is seen. This
;	2458				! is not an error.
;	2459				!--
;	2460				IF NOT proc_pc_cmd (new_line,
;	2461						    new_increment,
;	2462						    .start_pc,
;	2463						    new_next_pc,
;	2464						    dpc_entry,
;	2465						    dst_entry)
;	2466				THEN IF .new_line EQL 0
;	2467				THEN RETURN FALSE;
;	2468	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-7
; Digital Equipment Corporation
;
;	2469				!++
;	2470				! Compute next line number.
;	2471				!--
;	2472				new_line = .new_line + .new_increment;
;	2473				IF (.new_line EQL .current_line + .increment) AND
;	2474					(.match_pc_ptr [0] EQL .next_pc)
;	2475				THEN
;	2476					BEGIN
;	2477	
;	2478					!++
;	2479					! Exact match.
;	2480					!--
;	2481	
;	2482	%IF dbg_dpc
;     L 2483	%THEN
;     U 2484					$fao_tt_out ('!/exact match with line number !SL', .current_line);
;     U 2485					$fao_tt_out ('!/PC to match is !XL, PC of line is !XL',
;     U 2486						.match_pc_ptr [0], .next_pc);
;     U 2487	%FI
;	2488	
;	2489					line_no_2_ptr [0] = 0;
;	2490					END
;	2491				ELSE
;	2492					BEGIN
;	2493	
;	2494					!++
;	2495					! Between two lines.
;	2496					!--
;	2497	
;	2498	%IF dbg_dpc
;     L 2499	%THEN
;     U 2500					$fao_tt_out ('!/between lines !SL and !SL', .current_line, .new_line);
;     U 2501					$fao_tt_out ('!/PC to match is !XL, PC of line is !XL',
;     U 2502						.match_pc_ptr [0], .next_pc);
;     U 2503	%FI
;	2504					line_no_2_ptr [0] = .new_line;
;	2505					END;
;	2506	
;	2507				! For LOOKUP_EXC type matches, return
;	2508				! the PC of the line we matched to.
;	2509	
;	2510				IF( .LOOKUP_FLAG )
;	2511				THEN
;	2512					LINE_NO_2_PTR[0] = .START_PC;
;	2513	
;	2514				! In any case, we have determined which line
;	2515				! number to pass back.
;	2516	
;	2517				line_no_ptr [0] = .last_line_num;
;	2518				RETURN(TRUE)
;	2519				END;
;	2520	
;	2521			!++
;	2522			! Found nothing this round. Increment the current line
;	2523			! and the PC and continue trying.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-8
; Digital Equipment Corporation
;
;	2524			!--
;	2525			current_line = .current_line + .increment;
;	2526			start_pc = .next_pc;
;	2527			END;
;	2528		END;





					 0C3C 0008F 	    .ENTRY  DBG$PC_TO_LINE, Save R2,R3,R4,R5,R10,R11		      ; 2084
		         5A 00000000G  EF  9E 00091 	    MOVAB   DBG$GL_MC_PTR, R10					      ;
		         5B 00000000G  8F  D0 00098 	    MOVL    #DBG$_RST_BEGIN, R11				      ;
		         5E	       24  C2 0009F 	    SUBL2   #36, SP						      ;
				       55  D4 000A2 	    CLRL    LOOKUP_FLAG						      ; 2180
		         03	  0C   BC  D1 000A4 	    CMPL    @EXCEP_TYPE_PTR, #3					      ; 2189
				       0E  12 000A8 	    BNEQ    1$							      ;
		    0C   BC	       02  D0 000AA 	    MOVL    #2, @EXCEP_TYPE_PTR					      ; 2197
		         55	       01  D0 000AE 	    MOVL    #1, LOOKUP_FLAG					      ; 2198
		    20   AE	  14   BC  D0 000B1 	    MOVL    @LINE_NO_2_PTR, RTN_NT_PTR				      ; 2202
				       2B  11 000B6 	    BRB     2$							      ; 2189
				  20   AE  D4 000B8 1$:     CLRL    RTN_NT_PTR						      ; 2212
	   50	         6A	       5B  C1 000BB 	    ADDL3   R11, DBG$GL_MC_PTR, R0				      ; 2213
		    03   A0	       04  88 000BF 	    BISB2   #4, 3(R0)						      ;
				       7E  D4 000C3 	    CLRL    -(SP)						      ; 2215
				  24   AE  9F 000C5 	    PUSHAB  RTN_NT_PTR						      ;
				  08   AC  DD 000C8 	    PUSHL   ROUTINE_ADDRESS					      ;
	      00000000G  EF	       03  FB 000CB 	    CALLS   #3, DBG$VAL_TO_SYM					      ;
		         51	       50  D0 000D2 	    MOVL    R0, STATUS						      ;
	   50	         6A	       5B  C1 000D5 	    ADDL3   R11, DBG$GL_MC_PTR, R0				      ; 2220
		    03   A0	       04  8A 000D9 	    BICB2   #4, 3(R0)						      ;
		         03	       51  E8 000DD 	    BLBS    STATUS, 2$						      ; 2221
				     0110  31 000E0 	    BRW     18$							      ;
	   50	    20   AE	       5B  C1 000E3 2$:     ADDL3   R11, RTN_NT_PTR, R0					      ; 2232
		    BE   8F	  02   A0  91 000E8 	    CMPB    2(R0), #190						      ;
				       7B  12 000ED 	    BNEQ    7$							      ;
		         51	  08   A0  3C 000EF 	    MOVZWL  8(R0), MC_PTR					      ; 2243
				       75  13 000F3 	    BEQL    7$							      ;
00000000G  E1	         03	       03  ED 000F5 	    CMPZV   #3, #3, DBG$_RST_BEGIN+3(MC_PTR), #1		      ; 2252
				       01     000FD									      ;
				       6A  12 000FE 	    BNEQ    7$							      ;
				  04   A0  DD 00100 	    PUSHL   4(R0)						      ; 2264
	      00000000G  EF	       01  FB 00103 	    CALLS   #1, DBG$POSITON_DST					      ;
				       50  D5 0010A 	    TSTL    R0							      ;
				       5C  13 0010C 	    BEQL    7$							      ;
				       54  D4 0010E 	    CLRL    REPORT_BACK						      ; 2271
				  0C   AE  D4 00110 	    CLRL    CURRENT_LINE					      ; 2272
		    10   AE	       01  D0 00113 	    MOVL    #1, INCREMENT					      ; 2273
		         52	  08   AC  D0 00117 	    MOVL    ROUTINE_ADDRESS, START_PC				      ; 2274
				  1C   AE  9F 0011B 	    PUSHAB  DST_ENTRY						      ; 2288
		  0000V  CF	       01  FB 0011E 	    CALLS   #1, GET_NEXT_DPC					      ;
		         44	       50  E9 00123 	    BLBC    R0, 7$						      ;
      18   AE	    1C   AE	       02  C1 00126 	    ADDL3   #2, DST_ENTRY, DPC_ENTRY				      ; 2292
		         53	  0C   AE  D0 0012C 3$:     MOVL    CURRENT_LINE, LAST_LINE_NUM				      ; 2318
				  1C   AE  9F 00130 	    PUSHAB  DST_ENTRY						      ; 2320

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-9
; Digital Equipment Corporation
;
				  1C   AE  9F 00133 	    PUSHAB  DPC_ENTRY						      ;
				  1C   AE  9F 00136 	    PUSHAB  NEXT_PC						      ;
				       52  DD 00139 	    PUSHL   START_PC						      ;
				  20   AE  9F 0013B 	    PUSHAB  INCREMENT						      ;
				  20   AE  9F 0013E 	    PUSHAB  CURRENT_LINE					      ;
		  0000V  CF	       06  FB 00141 	    CALLS   #6, PROC_PC_CMD					      ;
		         21	       50  E9 00146 	    BLBC    R0, 7$						      ;
	   02	         00	  0C   BC  CF 00149 	    CASEL   @EXCEP_TYPE_PTR, #0, #2				      ; 2336
	 002E	       001F	     0006     0014E 4$:     .WORD   5$-4$,-						      ;
								    8$-4$,-						      ;
								    9$-4$						      ;
		    10   BC	       53  D1 00154 5$:     CMPL    LAST_LINE_NUM, @LINE_NO_PTR				      ; 2352
				       07  12 00158 	    BNEQ    6$							      ;
		    04   BC	       52  D0 0015A 	    MOVL    START_PC, @MATCH_PC_PTR				      ; 2361
				     0082  31 0015E 	    BRW     16$							      ; 2362
		    10   BC	       53  D1 00161 6$:     CMPL    LAST_LINE_NUM, @LINE_NO_PTR				      ; 2364
				       29  15 00165 	    BLEQ    11$							      ;
				  04   BC  D4 00167 	    CLRL    @MATCH_PC_PTR					      ; 2372
				     0086  31 0016A 7$:     BRW     18$							      ; 2373
		    04   BC	       52  D1 0016D 8$:     CMPL    START_PC, @MATCH_PC_PTR				      ; 2392
				       1D  1E 00171 	    BGEQU   11$							      ;
		    14   AE	  04   BC  D1 00173 	    CMPL    @MATCH_PC_PTR, NEXT_PC				      ; 2393
				       16  1A 00178 	    BGTRU   11$							      ;
				       11  11 0017A 	    BRB     10$							      ; 2394
		    04   BC	       52  D1 0017C 9$:     CMPL    START_PC, @MATCH_PC_PTR				      ; 2412
				       0E  1A 00180 	    BGTRU   11$							      ;
		    14   AE	  04   BC  D1 00182 	    CMPL    @MATCH_PC_PTR, NEXT_PC				      ; 2413
				       07  1E 00187 	    BGEQU   11$							      ;
		    0C   BC	       01  D0 00189 	    MOVL    #1, @EXCEP_TYPE_PTR					      ; 2423
		         54	       01  D0 0018D 10$:    MOVL    #1, REPORT_BACK					      ; 2424
		         54	       54  E9 00190 11$:    BLBC    REPORT_BACK, 17$					      ; 2437
		         6E	  0C   AE  D0 00193 	    MOVL    CURRENT_LINE, NEW_LINE				      ; 2448
		    04   AE	  10   AE  7D 00197 	    MOVQ    INCREMENT, NEW_INCREMENT				      ; 2449
				  1C   AE  9F 0019C 	    PUSHAB  DST_ENTRY						      ; 2460
				  1C   AE  9F 0019F 	    PUSHAB  DPC_ENTRY						      ;
				  10   AE  9F 001A2 	    PUSHAB  NEW_NEXT_PC						      ;
				       52  DD 001A5 	    PUSHL   START_PC						      ;
				  14   AE  9F 001A7 	    PUSHAB  NEW_INCREMENT					      ;
				  14   AE  9F 001AA 	    PUSHAB  NEW_LINE						      ;
		  0000V  CF	       06  FB 001AD 	    CALLS   #6, PROC_PC_CMD					      ;
		         04	       50  E8 001B2 	    BLBS    R0, 12$						      ;
				       6E  D5 001B5 	    TSTL    NEW_LINE						      ; 2466
				       3A  13 001B7 	    BEQL    18$							      ;
		         6E	  04   AE  C0 001B9 12$:    ADDL2   NEW_INCREMENT, NEW_LINE				      ; 2472
	   50	    0C   AE	  10   AE  C1 001BD 	    ADDL3   INCREMENT, CURRENT_LINE, R0				      ; 2473
		         50	       6E  D1 001C3 	    CMPL    NEW_LINE, R0					      ;
				       0C  12 001C6 	    BNEQ    13$							      ;
		    14   AE	  04   BC  D1 001C8 	    CMPL    @MATCH_PC_PTR, NEXT_PC				      ; 2474
				       05  12 001CD 	    BNEQ    13$							      ;
				  14   BC  D4 001CF 	    CLRL    @LINE_NO_2_PTR					      ; 2489
				       04  11 001D2 	    BRB     14$							      ; 2473
		    14   BC	       6E  D0 001D4 13$:    MOVL    NEW_LINE, @LINE_NO_2_PTR				      ; 2504
		         04	       55  E9 001D8 14$:    BLBC    LOOKUP_FLAG, 15$					      ; 2510
		    14   BC	       52  D0 001DB 	    MOVL    START_PC, @LINE_NO_2_PTR				      ; 2512
		    10   BC	       53  D0 001DF 15$:    MOVL    LAST_LINE_NUM, @LINE_NO_PTR				      ; 2517

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 4-10
; Digital Equipment Corporation
;
		         50	       01  D0 001E3 16$:    MOVL    #1, R0						      ; 2518
					   04 001E6 	    RET     							      ;
		    0C   AE	  10   AE  C0 001E7 17$:    ADDL2   INCREMENT, CURRENT_LINE				      ; 2525
		         52	  14   AE  D0 001EC 	    MOVL    NEXT_PC, START_PC					      ; 2526
				     FF39  31 001F0 	    BRW     3$							      ; 2305
				       50  D4 001F3 18$:    CLRL    R0							      ; 2084
					   04 001F5 	    RET     							      ;

; Routine Size:  359 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 5
; Digital Equipment Corporation
;
;	2529	ROUTINE proc_pc_cmd (line_ptr,
;	2530			     increment_ptr,
;	2531			     start_pc,
;	2532			     next_pc_ptr,
;	2533			     dpc_entry_ptr,
;	2534			     dst_entry_ptr) =	! processes PC correlation commands
;	2535	!++
;	2536	! Functional description:
;	2537	!	This routine processes PC correlation commands until a
;	2538	!	delta-Pc command is seen. The delta-PC command is also processed.
;	2539	!	Then this routine returns with all the contents of the
;	2540	!	parameter pointers updated appropriately.
;	2541	!
;	2542	!	This routine moves from PC record to PC record as necessary. If
;	2543	!	no more records are seen, this routine returns false. If
;	2544	!	an error is seen in a PC correlation record, then this
;	2545	!	routine sets the contents of line_ptr to zero and
;	2546	!	returns false.
;	2547	!
;	2548	! Inputs:
;	2549	!	line_ptr	- pointer to the current line
;	2550	!	increment_ptr	- pointer to the line increment
;	2551	!	start_pc	- PC at start of current line
;	2552	!	next_pc_ptr	- pointer to the PC of the next line
;	2553	!	dpc_entry_ptr	- pointer to address of current PC correlation record
;	2554	!	dst_entry_ptr	- pointer to address of current DST entry
;	2555	!
;	2556	! Implicit inputs:
;	2557	!	the routine get_next_dpc is set up to return the next PC
;	2558	!	correlation record, and false if no more exist for this routine.
;	2559	!
;	2560	! Implicit outputs:
;	2561	!	the contents of the line pointer, the increment pointer, the
;	2562	!	next_pc pointer, dpc_entry, and possible dst_entry are
;	2563	!	updated to new values.
;	2564	!
;	2565	! Routine value:
;	2566	!	TRUE if all goes well, otherwise FALSE.
;	2567	!
;	2568	! Side effects:
;	2569	!	More of the correlation records for this routine are read.
;	2570	!--
;	2571	
;	2572		BEGIN
;	2573	
;	2574		MAP
;	2575			line_ptr	: REF VECTOR,
;	2576			increment_ptr	: REF VECTOR,
;	2577			next_pc_ptr	: REF VECTOR;
;	2578	
;	2579		BIND
;	2580			dst_entry 	= .dst_entry_ptr : REF dst_record,
;	2581			dpc_entry	= .dpc_entry_ptr : REF BLOCK [, BYTE];
;	2582	
;	2583		REPEAT

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 5-1
; Digital Equipment Corporation
;
;	2584			BEGIN
;	2585	
;	2586			!++
;	2587			! See whether the current record is exhausted. If
;	2588			! so, get a new record. If none are available,
;	2589			! return FALSE. Otherwise, set dpc_entry to point to
;	2590			! the address of the third byte of the correlation record.
;	2591			!--
;	2592			IF dpc_entry [current_byte] GTR (.dst_entry [dstr_size]
;	2593				+ dst_entry [dstr_size])
;	2594			THEN
;	2595				BEGIN
;	2596	
;	2597	%IF dbg_dpc1
;     L 2598	%THEN
;     U 2599				$fao_tt_out ('!/getting another dpc record');
;     U 2600	%FI
;	2601	
;	2602				IF NOT get_next_dpc (dst_entry)
;	2603				THEN RETURN FALSE
;	2604				ELSE dpc_entry = dst_entry [dstr_access];
;	2605				END;
;	2606	
;	2607			!++
;	2608			! Now process each command, either PC correlation or
;	2609			! delta-PC one at a time. Once a delta-PC command is
;	2610			! processed, control returns from this routine to its
;	2611			! caller.
;	2612			!--
;	2613	
;	2614	%IF dbg_dpc1
;     L 2615	%THEN
;     U 2616			$fao_tt_out ('!/next byte is !SB, a signed byte, and !UB, an unsigned byte',
;     U 2617				.dpc_entry [0, 0, 8, 1], .dpc_entry [0, 0, 8, 0]);
;     U 2618	%FI
;	2619	
;	2620			CASE .dpc_entry [current_byte] FROM 1 TO 6 OF
;	2621	
;	2622				SET
;	2623	
;	2624				[word_delta]:
;	2625					BEGIN
;	2626	
;	2627					!++
;	2628					! Read the next two bytes as an unsigned
;	2629					! word representing a delta-PC value.
;	2630					! Update the next_pc and update the
;	2631					! dpc_entry address.
;	2632					!--
;	2633	%IF dbg_dpc1
;     L 2634	%THEN
;     U 2635					$fao_tt_out ('!/word_delta record');
;     U 2636	%FI
;	2637	
;	2638					next_pc_ptr [0] = .start_pc + .dpc_entry [next_uns_word];

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 5-2
; Digital Equipment Corporation
;
;	2639					dpc_entry = dpc_entry [add_three_bytes];
;	2640					RETURN TRUE
;	2641					END;
;	2642	
;	2643	
;	2644				[byte_temp_incr]:
;	2645					BEGIN
;	2646	
;	2647					!++
;	2648					! Increase the current line number by
;	2649					! the value contained in the next
;	2650					! unsigned byte.
;	2651					!--
;	2652	
;	2653	%IF dbg_dpc1
;     L 2654	%THEN
;     U 2655					$fao_tt_out ('!/byte line increment coming next');
;     U 2656	%FI
;	2657	
;	2658					line_ptr [0] = .line_ptr [0] + .dpc_entry [next_uns_byte];
;	2659					dpc_entry = dpc_entry [add_two_bytes];
;	2660					END;
;	2661	
;	2662	
;	2663				[word_temp_incr]:
;	2664					BEGIN
;	2665	
;	2666					!++
;	2667					! Increase the current line number by
;	2668					! the value contained in the next
;	2669					! unsigned word.
;	2670					!--
;	2671	%IF dbg_dpc1
;     L 2672	%THEN
;     U 2673					$fao_tt_out ('!/word line increment coming next');
;     U 2674	%FI
;	2675	
;	2676					line_ptr [0] = .line_ptr [0] + .dpc_entry [next_uns_word];
;	2677					dpc_entry = dpc_entry [add_three_bytes];
;	2678					END;
;	2679	
;	2680	
;	2681				[byte_perm_incr]:
;	2682					BEGIN
;	2683	
;	2684					!++
;	2685					! Change the line increment from its
;	2686					! present value to the value contained
;	2687					! in the next unsigned byte.
;	2688					!--
;	2689	
;	2690	%IF dbg_dpc1
;     L 2691	%THEN
;     U 2692					$fao_tt_out ('!/permanent byte line increment coming next');
;     U 2693	%FI

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 5-3
; Digital Equipment Corporation
;
;	2694	
;	2695					increment_ptr [0] = .dpc_entry [next_uns_byte];
;	2696					dpc_entry = dpc_entry [add_two_bytes];
;	2697					END;
;	2698	
;	2699	
;	2700				[word_perm_incr]:
;	2701					BEGIN
;	2702	
;	2703					!++
;	2704					! Change the line increment from its
;	2705					! present value to the value contained
;	2706					! in the next word.
;	2707					!--
;	2708	
;	2709	%IF dbg_dpc1
;     L 2710	%THEN
;     U 2711					$fao_tt_out ('!/permanent word line increment coming next');
;     U 2712	%FI
;	2713	
;	2714					increment_ptr [0] = .dpc_entry [next_uns_word];
;	2715					dpc_entry = dpc_entry [add_three_bytes];
;	2716					END;
;	2717	
;	2718	
;	2719				[incr_to_1]:
;	2720					BEGIN
;	2721	
;	2722					!++
;	2723					! Revert to a line increment of value 1.
;	2724					!--
;	2725	
;	2726	%IF dbg_dpc1
;     L 2727	%THEN
;     U 2728					$fao_tt_out ('!/revert to line increment of 1');
;     U 2729	%FI
;	2730	
;	2731					increment_ptr [0] = 1;
;	2732					dpc_entry = dpc_entry [add_one_byte];
;	2733					END;
;	2734	
;	2735	
;	2736				[OUTRANGE]:
;	2737					BEGIN
;	2738	
;	2739					!++
;	2740					! This is a standard delta_PC command
;	2741					! if the value is less than or equal to
;	2742					! zero. Otherwise it is an error. If okay,
;	2743					! set next_pc value, update the dpc_entry,
;	2744					! and return with success.
;	2745					!--
;	2746					IF .dpc_entry [current_byte] GTR 6
;	2747					THEN
;	2748						BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 5-4
; Digital Equipment Corporation
;
;	2749	
;	2750	%IF dbg_dpc1
;     L 2751	%THEN
;     U 2752						$fao_tt_out ('!/unimplemented delta-PC command');
;     U 2753	%FI
;	2754	
;	2755						SIGNAL (dbg$_invdstrec);
;	2756						RETURN FALSE
;	2757						END;
;	2758	
;	2759	%IF dbg_dpc1
;     L 2760	%THEN
;     U 2761					$fao_tt_out ('!/increment PC value by !SB', - .dpc_entry [current_byte]);
;     U 2762	%FI
;	2763	
;	2764					next_pc_ptr [0] = .start_pc - .dpc_entry [current_byte];
;	2765					dpc_entry = dpc_entry [add_one_byte];
;	2766					RETURN TRUE
;	2767					END;
;	2768	
;	2769				TES;
;	2770	
;	2771			END;
;	2772		END;





					 001C 001F6 PROC_PC_CMD:
							    .WORD   Save R2,R3,R4					      ; 2529
		         53	  14   AC  7D 001F8 	    MOVQ    DPC_ENTRY_PTR, R3					      ; 2572
		         50	  00   B4  9A 001FC 1$:     MOVZBL  @0(R4), R0						      ; 2592
		         50	       64  C0 00200 	    ADDL2   (R4), R0						      ;
		         50	       63  D1 00203 	    CMPL    (R3), R0						      ;
				       0E  15 00206 	    BLEQ    2$							      ;
				       54  DD 00208 	    PUSHL   R4							      ; 2602
		  0000V  CF	       01  FB 0020A 	    CALLS   #1, GET_NEXT_DPC					      ;
		         79	       50  E9 0020F 	    BLBC    R0, 16$						      ;
	   63	         64	       02  C1 00212 	    ADDL3   #2, (R4), (R3)					      ; 2604
		         52	       63  D0 00216 2$:     MOVL    (R3), R2						      ; 2620
	   05	         01	       62  8F 00219 	    CASEB   (R2), #1, #5					      ;
	 0048	       003E	     002D     0021D 3$:     .WORD   5$-3$,-						      ;
	 0066	       005C	     0052     00223		    7$-3$,-						      ;
								    8$-3$,-						      ;
								    9$-3$,-						      ;
								    12$-3$,-						      ;
								    14$-3$						      ;
		         06	       62  91 00229 	    CMPB    (R2), #6						      ; 2746
				       0F  15 0022C 	    BLEQ    4$							      ;
			    0002833A   8F  DD 0022E 	    PUSHL   #164666						      ; 2755
	      00000000G  00	       01  FB 00234 	    CALLS   #1, LIB$SIGNAL					      ;
				       4E  11 0023B 	    BRB     16$							      ; 2756
		         50	       62  98 0023D 4$:     CVTBL   (R2), R0						      ; 2764
      10   BC	    0C   AC	       50  C3 00240 	    SUBL3   R0, START_PC, @NEXT_PC_PTR				      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 5-5
; Digital Equipment Corporation
;
				       63  D6 00246 	    INCL    (R3)						      ; 2765
				       0D  11 00248 	    BRB     6$							      ; 2766
		         50	  01   A2  3C 0024A 5$:     MOVZWL  1(R2), R0						      ; 2638
      10   BC	    0C   AC	       50  C1 0024E 	    ADDL3   R0, START_PC, @NEXT_PC_PTR				      ;
		         63	       03  C0 00254 	    ADDL2   #3, (R3)						      ; 2639
		         50	       01  D0 00257 6$:     MOVL    #1, R0						      ; 2640
					   04 0025A 	    RET     							      ;
		         50	  01   A2  9A 0025B 7$:     MOVZBL  1(R2), R0						      ; 2658
		    04   BC	       50  C0 0025F 	    ADDL2   R0, @LINE_PTR					      ;
				       0F  11 00263 	    BRB     10$							      ; 2659
		         50	  01   A2  3C 00265 8$:     MOVZWL  1(R2), R0						      ; 2676
		    04   BC	       50  C0 00269 	    ADDL2   R0, @LINE_PTR					      ;
				       0F  11 0026D 	    BRB     13$							      ; 2677
		    08   BC	  01   A2  9A 0026F 9$:     MOVZBL  1(R2), @INCREMENT_PTR				      ; 2695
		         63	       02  C0 00274 10$:    ADDL2   #2, (R3)						      ; 2696
				       83  11 00277 11$:    BRB     1$							      ; 2620
		    08   BC	  01   A2  3C 00279 12$:    MOVZWL  1(R2), @INCREMENT_PTR				      ; 2714
		         63	       03  C0 0027E 13$:    ADDL2   #3, (R3)						      ; 2715
				       06  11 00281 	    BRB     15$							      ; 2620
		    08   BC	       01  D0 00283 14$:    MOVL    #1, @INCREMENT_PTR					      ; 2731
				       63  D6 00287 	    INCL    (R3)						      ; 2732
				       EC  11 00289 15$:    BRB     11$							      ; 2581
				       50  D4 0028B 16$:    CLRL    R0							      ; 2529
					   04 0028D 	    RET     							      ;

; Routine Size:  152 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 6
; Digital Equipment Corporation
;
;	2773	ROUTINE get_next_dpc (dst_rec_ptr) =	! gets next PC correlation record
;	2774	!++
;	2775	! Functional description:
;	2776	!	Reads DST records until either no more exist, a routine end
;	2777	!	record is seen, or another PC correlation record is seen. In
;	2778	!	the first two cases, a FALSE return is taken. In the third
;	2779	!	case, the address of the new record and a success return is
;	2780	!	taken.
;	2781	!
;	2782	! Inputs:
;	2783	!	dst_rec_ptr	- pointer for new DST PC correlation record
;	2784	!
;	2785	!
;	2786	! Implicit inputs:
;	2787	!	the routine dbg$get_nxt_dst is set up to return
;	2788	!	each DST record sequentially, and the last record
;	2789	!	that it returned was a PC correlation record.
;	2790	!
;	2791	! Implicit outputs:
;	2792	!	dbg$get_nxt_dst is now set up to return the next record after
;	2793	!	the returned record or the next record after the record that
;	2794	!	caused this routine to fail.
;	2795	!
;	2796	! Routine value:
;	2797	!	true or false
;	2798	!
;	2799	! Side effects:
;	2800	!	none
;	2801	!--
;	2802	
;	2803		BEGIN
;	2804	
;	2805		BIND
;	2806			dst_entry	= .dst_rec_ptr : REF dst_record;
;	2807	
;	2808		LOCAL
;	2809			dst_rec_id;
;	2810	
;	2811		REPEAT
;	2812			BEGIN
;	2813			dst_entry = dbg$get_nxt_dst (dst_rec_id);
;	2814			IF .dst_entry EQL 0
;	2815			THEN RETURN FALSE;
;	2816			IF .dst_entry [dstr_type] EQL dsc$k_dtype_eor
;	2817			THEN RETURN FALSE;
;	2818			IF .dst_entry [dstr_type] EQL dsc$k_dtype_dpc
;	2819			THEN RETURN TRUE;
;	2820			END;
;	2821		END;





					 0004 0028E GET_NEXT_DPC:

; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 6-1
; Digital Equipment Corporation
;
							    .WORD   Save R2						      ; 2773
		         5E	       04  C2 00290 	    SUBL2   #4, SP						      ;
		         52	  04   AC  D0 00293 	    MOVL    DST_REC_PTR, R2					      ; 2803
				       5E  DD 00297 1$:     PUSHL   SP							      ; 2813
	      00000000G  EF	       01  FB 00299 	    CALLS   #1, DBG$GET_NXT_DST					      ;
		         62	       50  D0 002A0 	    MOVL    R0, (R2)						      ;
		         50	       62  D0 002A3 	    MOVL    (R2), R0						      ; 2814
				       12  13 002A6 	    BEQL    2$							      ;
		    BF   8F	  01   A0  91 002A8 	    CMPB    1(R0), #191						      ; 2816
				       0B  13 002AD 	    BEQL    2$							      ;
		    B9   8F	  01   A0  91 002AF 	    CMPB    1(R0), #185						      ; 2818
				       E1  12 002B4 	    BNEQ    1$							      ;
		         50	       01  D0 002B6 	    MOVL    #1, R0						      ; 2819
					   04 002B9 	    RET     							      ;
				       50  D4 002BA 2$:     CLRL    R0							      ; 2773
					   04 002BC 	    RET     							      ;

; Routine Size:  47 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:10:14	DBB3:[DEBUG.SRC]DBGDPC.B32;6					Page 7
; Digital Equipment Corporation
;
;	2822	END
;	2823	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  DBG$CODE       	   701  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]STARLET.L32;1		      2688         7         0       110






;			COMPILER INTERNAL TIMING

;	Phase	    Faults	Cpu-time      Elapsed-time
;	LEXSYN	      494	00:23.8		00:43.6
;	FLOWAN	       24	00:02.0		00:03.1
;	DELAY	       24	00:01.1		00:01.9
;	TNBIND	       35	00:01.1		00:02.2
;	CODE	       45	00:02.3		00:04.1
;	FINAL	       86	00:04.6		00:07.5
;	Total	      708	00:34.9		01:02.4

; Size:		701 code + 0 data bytes
; Run Time:	00:35.4
; Elapsed Time:	01:03.9
; Memory Used:	269 pages
; Compilation Complete
