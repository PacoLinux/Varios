DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   0
TABLE OF CONTENTS   

   (2)      70  DBG$FOR_ADD	Fortran addition routine
   (3)     242  DBG$FOR_SUB	Fortran subtraction routine
   (4)     406  DBG$FOR_MUL	Fortran multiplication routine
   (5)     566  DBG$FOR_DIV	Fortran division routine
   (6)     785  DBG$FOR_NEG	Fortran negation routine
   (7)     858  ARITH_ERROR	Type of numbers not recoginized
   (8)     869  Fortran conversion routines
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   1
000005                                                                                                                           (1)

                                     0000     1 	.TITLE	DBGFORARI
                                     0000     2 	.IDENT	'000005'
                                     0000     3 
                                     0000     4 ;
                                     0000     5 ; COPYRIGHT (C) 1977
                                     0000     6 ; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS 01754
                                     0000     7 ;
                                     0000     8 ; THIS SOFTWARE IS FURNISHED  UNDER A LICENSE FOR USE ONLY ON A SINGLE
                                     0000     9 ; COMPUTER  SYSTEM AND  MAY BE  COPIED ONLY WITH  THE INCLUSION OF THE
                                     0000    10 ; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
                                     0000    11 ; MAY NOT BE PROVIDED OR  OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
                                     0000    12 ; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
                                     0000    13 ; TERMS.  TITLE TO AND  OWNERSHIP OF THE  SOFTWARE  SHALL AT ALL TIMES
                                     0000    14 ; REMAIN IN DEC.
                                     0000    15 ;
                                     0000    16 ; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
                                     0000    17 ; AND SHOULD  NOT BE CONSTRUED  AS A COMMITMENT  BY DIGITAL  EQUIPMENT
                                     0000    18 ; CORPORATION.
                                     0000    19 ;
                                     0000    20 ; DEC ASSUMES  NO  RESPONSIBILITY  FOR  THE USE OR  RELIABILITY OF ITS
                                     0000    21 ; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
                                     0000    22 
                                     0000    23 ;++
                                     0000    24 ;
                                     0000    25 ; FACILITY:  DEBUG
                                     0000    26 ;
                                     0000    27 ; ABSTRACT:
                                     0000    28 ;	arithmetic routines for FORTRAN debugging. Includes integer,
                                     0000    29 ;	single, and double precision add, subtract, multiply, and
                                     0000    30 ;	divide.
                                     0000    31 ;
                                     0000    32 ; ENVIRONMENT:
                                     0000    33 ;	user mode, non-AST.
                                     0000    34 ;
                                     0000    35 ; AUTHOR:  Carol Peters		CREATION DATE:	December 5, 1977
                                     0000    36 ;
                                     0000    37 ; MODIFIED BY:
                                     0000    38 ;		Dale Roedger, 16-May-1978
                                     0000    39 ;
                                     0000    40 ;	REVISION HISTORY
                                     0000    41 ; 01	-		CP	Original. 
                                     0000    42 ; 02	31-MAR-78	DAR	Changed the conversion routines DBG$CNV_F_TO_L
                                     0000    43 ;				and DBG$CNV_D_TO_L to truncate instead of round.
                                     0000    44 ; 03	04-APR-78	KGP	-DBG$CNV_D_TO_L now returns the converted data
                                     0000    45 ;				 with a MOVL instead of a MOVD.
                                     0000    46 ; 04	16-MAY-78	DAR	Exit point "DIV_BY_ZERO" now signals "DIVBYZERO"
                                     0000    47 ;				unstead of "INVCMD".
                                     0000    48 ; 05	19-JUL-78	DAR	DEBUG's PSECT declarations are changed to work
                                     0000    49 ;				with the new linker option /SHARE
                                     0000    50 ;--
                                     0000    51 
                                     0000    52 ;
                                     0000    53 ; INCLUDE FILES:
                                     0000    54 ;
                                     0000    55 
                                     0000    56 ;
                                     0000    57 ; MACROS:
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   2
000005                                                                                                                           (1)

                                     0000    58 ;
                                     0000    59 	$dbgdef			; DEBUG definitions
                                     0000    60 	$dscdef			; SRM data type definitions
                                     0000    61 
                                     0000    62 ;
                                     0000    63 ; EQUATED SYMBOLS:
                                     0000    64 ;
                                     0000    65 
                                     0000    66 ;
                                     0000    67 ; OWN STORAGE:
                                     0000    68 ;
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   3
000005          DBG$FOR_ADD Fortran addition routine                                                                             (2)

                                     0000    70 .SBTTL	DBG$FOR_ADD	Fortran addition routine
                                     0000    71 ;++
                                     0000    72 ;
                                     0000    73 ; FUNCTIONAL DESCRIPTION:
                                     0000    74 ;	Adds two elements from the parse stack. They are elements found
                                     0000    75 ;	at the position indicated by the offset passed as the routine's
                                     0000    76 ;	argument, and the position two stack locations further along.
                                     0000    77 ;	The result is put in the former position.
                                     0000    78 ;
                                     0000    79 ;	The elements are in the parse stack called dbg$gl_seman1.
                                     0000    80 ;	Each element has its type in the corresponding position in the
                                     0000    81 ;	other parse stack, dbg$gl_seman2. The rules for mixed mode
                                     0000    82 ;	arithmetic says that
                                     0000    83 ;
                                     0000    84 ;		integer + integer = integer
                                     0000    85 ;		integer + single_precision = single_precision
                                     0000    86 ;		integer + double_precision = double_precision
                                     0000    87 ;		single_precision + single_precision = single_precision
                                     0000    88 ;		single_precision + double_precision = double_precision
                                     0000    89 ;		double_precision + double_precision = double_precision
                                     0000    90 ;
                                     0000    91 ;	Any other data types cause an error to be signaled.
                                     0000    92 ;
                                     0000    93 ; CALLING SEQUENCE:
                                     0000    94 ;	dbg$for_add (stack_offset.rl)
                                     0000    95 ;
                                     0000    96 ; INPUT PARAMETERS:
                                     0000    97 ;	4(AP)	- offset into the parse stack that is called dbg$gl_seman1.
                                     0000    98 ;
                                     0000    99 ; IMPLICIT INPUTS:
                                     0000   100 ;	the second element to be added is two stack positions farther
                                     0000   101 ;	along than the offset passed.
                                     0000   102 ;
                                     0000   103 ; OUTPUT PARAMETERS:
                                     0000   104 ;	NONE
                                     0000   105 ;
                                     0000   106 ; IMPLICIT OUTPUTS:
                                     0000   107 ;	NONE
                                     0000   108 ;
                                     0000   109 ; ROUTINE VALUE:
                                     0000   110 ;	NONE
                                     0000   111 ;
                                     0000   112 ; SIDE EFFECTS:
                                     0000   113 ;	the sum of the two elements is placed on the stack in the position
                                     0000   114 ;	indicated by the offset passed as an argument. The corresponding
                                     0000   115 ;	data type in dbg$gl_seman2 is updated to reflect the type of
                                     0000   116 ;	the sum.
                                     0000   117 ;
                                     0000   118 ;--
                                     0000   119 
                                 00000000   120 	.PSECT	DBG$CODE BYTE, PIC, SHR, NOWRT, EXE
                                     0000   121 
                               003C' 0000   122 	.ENTRY	dbg$for_add, ^M<R2,R3,R4,R5>
                                     0002   123 
            52         04 AC     D0  0002   124 	MOVL	4(AP),R2		; get offset to first addend
            52            04     C1  0006   125 	ADDL3	#dbg$k_spos_two,R2,R3	; and offset to second addend
                          53         0009       
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   4
000005          DBG$FOR_ADD Fortran addition routine                                                                             (2)

                                     000A   126 
                                     000A   127 ;++
                                     000A   128 ; First handle the case where the first addend is an integer. This
                                     000A   129 ; involves conversions of the first addend if the second addend is
                                     000A   130 ; single or double precision. Integer, single and double precision
                                     000A   131 ; addition is performed, depending on the type of the second addend.
                                     000A   132 ;--
   00000000'EF42          08     D1  000A   133 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R2]	; is first addend integer?
                          03     13  0012   134 	BEQL	10$			; yes
                          0076   31  0014   135 	BRW	not_int_add		; no, branch to check for single precision
                                     0017   136 
                                     0017   137 10$:
   00000000'EF43          08     D1  0017   138 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second addend integer?
                          0E     12  001F   139 	BNEQ	20$			; no, branch to check for single precision
   00000000'EF42 00000000'EF43   C0  0021   140 	ADDL2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; sum parts
                                 04  002E   141 	RET				; and return
                                     002F   142 
                                     002F   143 20$:
   00000000'EF43          0A     D1  002F   144 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second addend single?
                          1F     12  0037   145 	BNEQ	30$			; no, branch to check for double
            54   00000000'EF42   4E  0039   146 	CVTLF	dbg$gl_seman1[R2],R4	; yes, convert first addend to single.
   00000000'EF43          54     41  0041   147 	ADDF3	R4,dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; sum parts
                 00000000'EF42       0049       
   00000000'EF42          0A     D0  004F   148 	MOVL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; set data type to
                                     0057   149 					; single precision for sum
                                 04  0057   150 	RET				; and return successfully.
                                     0058   151 
                                     0058   152 30$:
   00000000'EF43          0B     D1  0058   153 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second addend double?
                          03     13  0060   154 	BEQL	40$			; yes, branch to convert and add
                          0643   31  0062   155 	BRW	arith_error		; no, signal error
                                     0065   156 
                                     0065   157 40$:
            53            02     C6  0065   158 	DIVL2	#2,R3			; divide offsets by two since
                                     0068   159 					; next indexing is quadword.
            54   00000000'EF42   6E  0068   160 	CVTLD	dbg$gl_seman1[R2],R4	; convert first addend to double.
            52            02     C6  0070   161 	DIVL2	#2,R2			; now offset of other operand to
                                     0073   162 					; use quadword indexing.
   00000000'EF43          54     61  0073   163 	ADDD3	R4,dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; sum parts
                 00000000'EF42       007B       
            52            02     C4  0081   164 	MULL2	#2,R2			; convert offset back to longword index.
   00000000'EF42          0B     D0  0084   165 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; set data type to
                                     008C   166 					; double precision for sum
                                 04  008C   167 	RET				; and return successfully.
                                     008D   168 
                                     008D   169 ;++
                                     008D   170 ; The first addend was not integer. Check for single precision. If it is
                                     008D   171 ; single precision, do either single or double precision addition
                                     008D   172 ; depending on the data type of the second addend.
                                     008D   173 ;--
                                     008D   174 not_int_add:
   00000000'EF42          0A     D1  008D   175 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; is first addend single?
                          6E     12  0095   176 	BNEQ	not_sin_add		; no, branch to check for double.
   00000000'EF43          08     D1  0097   177 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second addend integer?
                          17     12  009F   178 	BNEQ	10$			; no, branch to check for single
            54   00000000'EF43   4E  00A1   179 	CVTLF	dbg$gl_seman1[R3],R4	; yes, convert second addend to single.
            54   00000000'EF42   41  00A9   180 	ADDF3	dbg$gl_seman1[R2],R4,dbg$gl_seman1[R2]	; sum parts
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   5
000005          DBG$FOR_ADD Fortran addition routine                                                                             (2)

                 00000000'EF42       00B1       
                                 04  00B7   181 	RET				; and return successfully
                                     00B8   182 
                                     00B8   183 10$:
   00000000'EF43          0A     D1  00B8   184 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second addend single?
                          0E     12  00C0   185 	BNEQ	20$			; no, branch to check for double
   00000000'EF42 00000000'EF43   40  00C2   186 	ADDF2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; sum parts
                                 04  00CF   187 	RET				; and return successfully
                                     00D0   188 
                                     00D0   189 20$:
   00000000'EF43          0B     D1  00D0   190 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second addend double?
                          03     13  00D8   191 	BEQL	30$			; yes, branch to do convert and add
                          05CB   31  00DA   192 	BRW	arith_error		; no, signal error
                                     00DD   193 
                                     00DD   194 30$:
            53            02     C6  00DD   195 	DIVL2	#2,R3			; divide offsets by two since
                                     00E0   196 					; next indexing is quadword.
            54   00000000'EF42   56  00E0   197 	CVTFD	dbg$gl_seman1[R2],R4	; convert first addend to double.
            52            02     C6  00E8   198 	DIVL2	#2,R2			; quadword indexing next.
   00000000'EF43          54     61  00EB   199 	ADDD3	R4,dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; sum parts
                 00000000'EF42       00F3       
            52            02     C4  00F9   200 	MULL2	#2,R2			; convert offset back to longword index.
   00000000'EF42          0B     D0  00FC   201 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; store double data
                                     0104   202 					; type with sum
                                 04  0104   203 	RET				; and return successfully
                                     0105   204 
                                     0105   205 ;++
                                     0105   206 ; The first addend is either double precision or an erroneous type.
                                     0105   207 ; In the former case, convert the second addend to double precision
                                     0105   208 ; if necessary and then do a double precision addition.
                                     0105   209 ;--
                                     0105   210 not_sin_add:
   00000000'EF42          0B     D1  0105   211 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; is first addend double?
                          03     13  010D   212 	BEQL	10$			; yes, branch to check second addend
                          0596   31  010F   213 	BRW	arith_error		; no, signal error
                                     0112   214 
                                     0112   215 10$:
   00000000'EF43          08     D1  0112   216 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second addend integer?
                          14     12  011A   217 	BNEQ	20$			; no, branch to check for single
            54   00000000'EF43   6E  011C   218 	CVTLD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  0124   219 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     60  0127   220 	ADDD2	R4,dbg$gl_seman1[R2]	; sum parts
                                 04  012F   221 	RET				; and return successfully
                                     0130   222 
                                     0130   223 20$:
   00000000'EF43          0A     D1  0130   224 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second addend single?
                          14     12  0138   225 	BNEQ	30$			; no, branch to check for double.
            54   00000000'EF43   56  013A   226 	CVTFD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  0142   227 	DIVL2	#2,R2			; quadword indexing next.
   00000000'EF42          54     60  0145   228 	ADDD2	R4,dbg$gl_seman1[R2]	; sum parts
                                 04  014D   229 	RET				; and return successfully
                                     014E   230 
                                     014E   231 30$:
   00000000'EF43          0B     D1  014E   232 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second addend double?
                          03     13  0156   233 	BEQL	40$			; yes, branch
                          054D   31  0158   234 	BRW	arith_error		; no, signal error
                                     015B   235 
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   6
000005          DBG$FOR_ADD Fortran addition routine                                                                             (2)

                                     015B   236 40$:
            53            02     C6  015B   237 	DIVL2	#2,R3			; divide offsets by two since
            52            02     C6  015E   238 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42 00000000'EF43   60  0161   239 	ADDD2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; sum parts
                                 04  016E   240 	RET				; and return successfully
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   7
000005          DBG$FOR_SUB Fortran subtraction routine                                                                          (3)

                                     016F   242 .SBTTL	DBG$FOR_SUB	Fortran subtraction routine
                                     016F   243 ;++
                                     016F   244 ;
                                     016F   245 ; FUNCTIONAL DESCRIPTION:
                                     016F   246 ;	Subtracts one element from another on the parse stack. They are
                                     016F   247 ;	elements of dbg$gl_seman1. The first operand is at the position
                                     016F   248 ;	indicated by the offset passed as the routine's argument, and
                                     016F   249 ;	the second operand at the position two stack locations further
                                     016F   250 ;	along. The result is put in the former position.
                                     016F   251 ;
                                     016F   252 ;	The elements are in the parse stack dbg$gl_seman1. Each element
                                     016F   253 ;	has its corresponding type in the corresponding position in the
                                     016F   254 ;	other parse stack -- dbg$gl_seman2. Each stack element is a
                                     016F   255 ;	quadword in length.
                                     016F   256 ;
                                     016F   257 ;	The rules for mixed mode arithmetic are the same as listed in
                                     016F   258 ;	the routine dbg$for_add.
                                     016F   259 ;
                                     016F   260 ; CALLING SEQUENCE:
                                     016F   261 ;	dbg$for_sub (stack_offset.rl)
                                     016F   262 ;
                                     016F   263 ; INPUT PARAMETERS:
                                     016F   264 ;	4(AP)	- offset into the parse stack that is called dbg$gl_seman1.
                                     016F   265 ;
                                     016F   266 ; IMPLICIT INPUTS:
                                     016F   267 ;	The subtrahend operand is two stack positions farther along than
                                     016F   268 ;	the offset passed.
                                     016F   269 ;
                                     016F   270 ; OUTPUT PARAMETERS:
                                     016F   271 ;	NONE
                                     016F   272 ;
                                     016F   273 ; IMPLICIT OUTPUTS:
                                     016F   274 ;	NONE
                                     016F   275 ;
                                     016F   276 ; ROUTINE VALUE:
                                     016F   277 ;	NONE
                                     016F   278 ;
                                     016F   279 ; SIDE EFFECTS:
                                     016F   280 ;	The difference between the two elements is placed on the parse
                                     016F   281 ;	stack in the position indicated by the offset passed as an
                                     016F   282 ;	argument. The corresponding data type of the difference is
                                     016F   283 ;	updated in dbg$gl_seman2.
                                     016F   284 ;
                                     016F   285 ;--
                                     016F   286 
                               003C' 016F   287 	.ENTRY	dbg$for_sub, ^M<R2,R3,R4,R5>
                                     0171   288 
            52         04 AC     D0  0171   289 	MOVL	4(AP),R2		; get the offset to first operand
            52            04     C1  0175   290 	ADDL3	#dbg$k_spos_two,R2,R3	; and offset to subtrahend
                          53         0178       
                                     0179   291 
                                     0179   292 ;++
                                     0179   293 ; First handle the case where the first operand is an integer. This
                                     0179   294 ; involves conversions of the first operand if the second operand is
                                     0179   295 ; single or double precision. Integer, single and double precision
                                     0179   296 ; subtraction is performed, depending on the type of the second operand.
                                     0179   297 ;--
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   8
000005          DBG$FOR_SUB Fortran subtraction routine                                                                          (3)

   00000000'EF42          08     D1  0179   298 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R2]	; is first operand integer?
                          03     13  0181   299 	BEQL	10$			; yes
                          0076   31  0183   300 	BRW	not_int_sub		; no, branch to check for single precision
                                     0186   301 
                                     0186   302 10$:
   00000000'EF43          08     D1  0186   303 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          0E     12  018E   304 	BNEQ	20$			; no, branch to check for single precision
   00000000'EF42 00000000'EF43   C2  0190   305 	SUBL2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; subtract
                                 04  019D   306 	RET				; and return
                                     019E   307 
                                     019E   308 20$:
   00000000'EF43          0A     D1  019E   309 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          1F     12  01A6   310 	BNEQ	30$			; no, branch to check for double
            54   00000000'EF42   4E  01A8   311 	CVTLF	dbg$gl_seman1[R2],R4	; yes, convert first operand to single.
            54   00000000'EF43   43  01B0   312 	SUBF3	dbg$gl_seman1[R3],R4,dbg$gl_seman1[R2]	; subtract
                 00000000'EF42       01B8       
   00000000'EF42          0A     D0  01BE   313 	MOVL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; set data type to
                                     01C6   314 					; single precision for difference
                                 04  01C6   315 	RET				; and return successfully.
                                     01C7   316 
                                     01C7   317 30$:
   00000000'EF43          0B     D1  01C7   318 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  01CF   319 	BEQL	40$			; yes, branch to convert and subtract
                          04D4   31  01D1   320 	BRW	arith_error		; no, signal error
                                     01D4   321 
                                     01D4   322 40$:
            53            02     C6  01D4   323 	DIVL2	#2,R3			; divide offsets by two since
                                     01D7   324 					; next indexing is quadword.
            54   00000000'EF42   6E  01D7   325 	CVTLD	dbg$gl_seman1[R2],R4	; convert first operand to double.
            52            02     C6  01DF   326 	DIVL2	#2,R2			; quadword indexing for other operand.
            54   00000000'EF43   63  01E2   327 	SUBD3	dbg$gl_seman1[R3],R4,dbg$gl_seman1[R2]	; subtract
                 00000000'EF42       01EA       
            52            02     C4  01F0   328 	MULL2	#2,R2			; convert index back to longword.
   00000000'EF42          0B     D0  01F3   329 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; set data type to
                                     01FB   330 					; double precision for difference
                                 04  01FB   331 	RET				; and return successfully.
                                     01FC   332 
                                     01FC   333 ;++
                                     01FC   334 ; The first operand was not integer. Check for single precision. If it is
                                     01FC   335 ; single precision, do either single or double precision subtraction
                                     01FC   336 ; depending on the data type of the second operand.
                                     01FC   337 ;--
                                     01FC   338 not_int_sub:
   00000000'EF42          0A     D1  01FC   339 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; is first operand single?
                          6E     12  0204   340 	BNEQ	not_sin_sub		; no, branch to check for double.
   00000000'EF43          08     D1  0206   341 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          17     12  020E   342 	BNEQ	10$			; no, branch to check for single
            54   00000000'EF43   4E  0210   343 	CVTLF	dbg$gl_seman1[R3],R4	; yes, convert second operand to single.
   00000000'EF42          54     43  0218   344 	SUBF3	R4,dbg$gl_seman1[R2],dbg$gl_seman1[R2]	; subtract
                 00000000'EF42       0220       
                                 04  0226   345 	RET				; and return successfully
                                     0227   346 
                                     0227   347 10$:
   00000000'EF43          0A     D1  0227   348 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          0E     12  022F   349 	BNEQ	20$			; no, branch to check for double
   00000000'EF42 00000000'EF43   42  0231   350 	SUBF2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; subtract
                                 04  023E   351 	RET				; and return successfully
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page   9
000005          DBG$FOR_SUB Fortran subtraction routine                                                                          (3)

                                     023F   352 
                                     023F   353 20$:
   00000000'EF43          0B     D1  023F   354 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  0247   355 	BEQL	30$			; yes, branch to do convert and subtract
                          045C   31  0249   356 	BRW	arith_error		; no, signal error
                                     024C   357 
                                     024C   358 30$:
            53            02     C6  024C   359 	DIVL2	#2,R3			; divide offsets by two since
                                     024F   360 					; next indexing is quadword.
            54   00000000'EF42   56  024F   361 	CVTFD	dbg$gl_seman1[R2],R4	; convert first operand to double.
            52            02     C6  0257   362 	DIVL2	#2,R2			; quadword indexing next.
            54   00000000'EF43   63  025A   363 	SUBD3	dbg$gl_seman1[R3],R4,dbg$gl_seman1[R2]	; subtract
                 00000000'EF42       0262       
            52            02     C4  0268   364 	MULL2	#2,R2			; convert index back to longword.
   00000000'EF42          0B     D0  026B   365 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; store double data
                                     0273   366 					; type with difference
                                 04  0273   367 	RET				; and return successfully
                                     0274   368 
                                     0274   369 ;++
                                     0274   370 ; The first operand is either double precision or an erroneous type.
                                     0274   371 ; In the former case, convert the second operand to double precision
                                     0274   372 ; if necessary and then do a double precision subtraction.
                                     0274   373 ;--
                                     0274   374 not_sin_sub:
   00000000'EF42          0B     D1  0274   375 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; is first operand double?
                          03     13  027C   376 	BEQL	10$			; yes, branch to check second operand
                          0427   31  027E   377 	BRW	arith_error		; no, signal error
                                     0281   378 
                                     0281   379 10$:
   00000000'EF43          08     D1  0281   380 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          14     12  0289   381 	BNEQ	20$			; no, branch to check for single
            54   00000000'EF43   6E  028B   382 	CVTLD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  0293   383 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     62  0296   384 	SUBD2	R4,dbg$gl_seman1[R2]	; subtract
                                 04  029E   385 	RET				; and return successfully
                                     029F   386 
                                     029F   387 20$:
   00000000'EF43          0A     D1  029F   388 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          14     12  02A7   389 	BNEQ	30$			; no, branch to check for double.
            54   00000000'EF43   56  02A9   390 	CVTFD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  02B1   391 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     62  02B4   392 	SUBD2	R4,dbg$gl_seman1[R2]	; subtract
                                 04  02BC   393 	RET				; and return successfully
                                     02BD   394 
                                     02BD   395 30$:
   00000000'EF43          0B     D1  02BD   396 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  02C5   397 	BEQL	40$			; yes, branch
                          03DE   31  02C7   398 	BRW	arith_error		; no, signal error
                                     02CA   399 
                                     02CA   400 40$:
            53            02     C6  02CA   401 	DIVL2	#2,R3			; divide offsets by two since
            52            02     C6  02CD   402 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42 00000000'EF43   62  02D0   403 	SUBD2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; subtract
                                 04  02DD   404 	RET				; and return successfully
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  10
000005          DBG$FOR_MUL Fortran multiplication routine                                                                       (4)

                                     02DE   406 .SBTTL	DBG$FOR_MUL	Fortran multiplication routine
                                     02DE   407 ;++
                                     02DE   408 ;
                                     02DE   409 ; FUNCTIONAL DESCRIPTION:
                                     02DE   410 ;	Multiplies two elements on the parse stack. They are elements found
                                     02DE   411 ;	at the position indicated by the offset passed as the routine's
                                     02DE   412 ;	argument, and the position two stack locations further along.
                                     02DE   413 ;	The product is put in the former position.
                                     02DE   414 ;
                                     02DE   415 ;	The elements are in the parse stack called dbg$gl_seman1.
                                     02DE   416 ;	Each element has its type in the corresponding position in the
                                     02DE   417 ;	other parse stack, dbg$gl_seman2. The rules for mixed mode
                                     02DE   418 ;	are the same as listed in dbg$for_add.
                                     02DE   419 ;
                                     02DE   420 ;	Any other data types cause an error to be signaled.
                                     02DE   421 ;
                                     02DE   422 ; CALLING SEQUENCE:
                                     02DE   423 ;	dbg$for_mul (stack_offset.rl)
                                     02DE   424 ;
                                     02DE   425 ; INPUT PARAMETERS:
                                     02DE   426 ;	4(AP)	- offset into the parse stack that is called dbg$gl_seman1.
                                     02DE   427 ;
                                     02DE   428 ; IMPLICIT INPUTS:
                                     02DE   429 ;	the second element to be multiplied is two stack positions farther
                                     02DE   430 ;	along than the offset passed.
                                     02DE   431 ;
                                     02DE   432 ; OUTPUT PARAMETERS:
                                     02DE   433 ;	NONE
                                     02DE   434 ;
                                     02DE   435 ; IMPLICIT OUTPUTS:
                                     02DE   436 ;	NONE
                                     02DE   437 ;
                                     02DE   438 ; ROUTINE VALUE:
                                     02DE   439 ;	NONE
                                     02DE   440 ;
                                     02DE   441 ; SIDE EFFECTS:
                                     02DE   442 ;	the product of the two elements is placed on the stack in the position
                                     02DE   443 ;	indicated by the offset passed as an argument. The corresponding
                                     02DE   444 ;	data type in dbg$gl_seman2 is updated to reflect the type of
                                     02DE   445 ;	the product.
                                     02DE   446 ;
                                     02DE   447 ;--
                                     02DE   448 
                               003C' 02DE   449 	.ENTRY	dbg$for_mul, ^M<R2,R3,R4,R5>
                                     02E0   450 
            52         04 AC     D0  02E0   451 	MOVL	4(AP),R2		; get offset to first operand
            52            04     C1  02E4   452 	ADDL3	#dbg$k_spos_two,R2,R3	; and offset to second operand
                          53         02E7       
                                     02E8   453 
                                     02E8   454 ;++
                                     02E8   455 ; First handle the case where the first operand is an integer. This
                                     02E8   456 ; involves conversions of the first operand if the second operand is
                                     02E8   457 ; single or double precision. Integer, single and double precision
                                     02E8   458 ; multiplication is performed, depending on the type of the second operand.
                                     02E8   459 ;--
   00000000'EF42          08     D1  02E8   460 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2 [R2]	; is first operand integer?
                          03     13  02F0   461 	BEQL	10$			; yes
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  11
000005          DBG$FOR_MUL Fortran multiplication routine                                                                       (4)

                          0076   31  02F2   462 	BRW	not_int_mul		; no, branch to check for single precision
                                     02F5   463 
                                     02F5   464 10$:
   00000000'EF43          08     D1  02F5   465 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          0E     12  02FD   466 	BNEQ	20$			; no, branch to check for single precision
   00000000'EF42 00000000'EF43   C4  02FF   467 	MULL2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; multiply
                                 04  030C   468 	RET				; and return
                                     030D   469 
                                     030D   470 20$:
   00000000'EF43          0A     D1  030D   471 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          1F     12  0315   472 	BNEQ	30$			; no, branch to check for double
            54   00000000'EF42   4E  0317   473 	CVTLF	dbg$gl_seman1[R2],R4	; yes, convert first operand to single.
   00000000'EF43          54     45  031F   474 	MULF3	R4,dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; multiply
                 00000000'EF42       0327       
   00000000'EF42          0A     D0  032D   475 	MOVL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; set data type to
                                     0335   476 					; single precision for product
                                 04  0335   477 	RET				; and return successfully.
                                     0336   478 
                                     0336   479 30$:
   00000000'EF43          0B     D1  0336   480 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  033E   481 	BEQL	40$			; yes, branch to convert and multiply
                          0365   31  0340   482 	BRW	arith_error		; no, signal error
                                     0343   483 
                                     0343   484 40$:
            53            02     C6  0343   485 	DIVL2	#2,R3			; next indexing is quadword.
            54   00000000'EF42   6E  0346   486 	CVTLD	dbg$gl_seman1[R2],R4	; convert first operand to double.
            52            02     C6  034E   487 	DIVL2	#2,R2			; quadword indexing next.
   00000000'EF43          54     65  0351   488 	MULD3	R4,dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; multiply
                 00000000'EF42       0359       
            52            02     C4  035F   489 	MULL2	#2,R2			; convert index back to longword.
   00000000'EF42          0B     D0  0362   490 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; set data type to
                                     036A   491 					; double precision for product
                                 04  036A   492 	RET				; and return successfully.
                                     036B   493 
                                     036B   494 ;++
                                     036B   495 ; The first operand was not integer. Check for single precision. If it is
                                     036B   496 ; single precision, do either single or double precision multiplication
                                     036B   497 ; depending on the data type of the second operand.
                                     036B   498 ;--
                                     036B   499 not_int_mul:
   00000000'EF42          0A     D1  036B   500 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; is first operand single?
                          6E     12  0373   501 	BNEQ	not_sin_mul		; no, branch to check for double.
   00000000'EF43          08     D1  0375   502 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          17     12  037D   503 	BNEQ	10$			; no, branch to check for single
            54   00000000'EF43   4E  037F   504 	CVTLF	dbg$gl_seman1[R3],R4	; yes, convert second operand to single.
            54   00000000'EF42   45  0387   505 	MULF3	dbg$gl_seman1[R2],R4,dbg$gl_seman1[R2]	; multiply
                 00000000'EF42       038F       
                                 04  0395   506 	RET				; and return successfully
                                     0396   507 
                                     0396   508 10$:
   00000000'EF43          0A     D1  0396   509 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          0E     12  039E   510 	BNEQ	20$			; no, branch to check for double
   00000000'EF42 00000000'EF43   44  03A0   511 	MULF2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; multiply
                                 04  03AD   512 	RET				; and return successfully
                                     03AE   513 
                                     03AE   514 20$:
   00000000'EF43          0B     D1  03AE   515 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  12
000005          DBG$FOR_MUL Fortran multiplication routine                                                                       (4)

                          03     13  03B6   516 	BEQL	30$			; yes, branch to do convert and multiply
                          02ED   31  03B8   517 	BRW	arith_error		; no, signal error
                                     03BB   518 
                                     03BB   519 30$:
            54   00000000'EF42   56  03BB   520 	CVTFD	dbg$gl_seman1[R2],R4	; convert first operand to double.
            53            02     C6  03C3   521 	DIVL2	#2,R3			; divide offsets by two since
            52            02     C6  03C6   522 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF43          54     65  03C9   523 	MULD3	R4,dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; multiply
                 00000000'EF42       03D1       
            52            02     C4  03D7   524 	MULL2	#2,R2			; convert index back to longword.
   00000000'EF42          0B     D0  03DA   525 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; store double data
                                     03E2   526 					; type with product
                                 04  03E2   527 	RET				; and return successfully
                                     03E3   528 
                                     03E3   529 ;++
                                     03E3   530 ; The first operand is either double precision or an erroneous type.
                                     03E3   531 ; In the former case, convert the second operand to double precision
                                     03E3   532 ; if necessary and then do a double precision multiplication.
                                     03E3   533 ;--
                                     03E3   534 not_sin_mul:
   00000000'EF42          0B     D1  03E3   535 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; is first operand double?
                          03     13  03EB   536 	BEQL	10$			; yes, branch to check second operand
                          02B8   31  03ED   537 	BRW	arith_error		; no, signal error
                                     03F0   538 
                                     03F0   539 10$:
   00000000'EF43          08     D1  03F0   540 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          14     12  03F8   541 	BNEQ	20$			; no, branch to check for single
            54   00000000'EF43   6E  03FA   542 	CVTLD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  0402   543 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     64  0405   544 	MULD2	R4,dbg$gl_seman1[R2]	; multiply
                                 04  040D   545 	RET				; and return successfully
                                     040E   546 
                                     040E   547 20$:
   00000000'EF43          0A     D1  040E   548 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          14     12  0416   549 	BNEQ	30$			; no, branch to check for double.
            54   00000000'EF43   56  0418   550 	CVTFD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  0420   551 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     64  0423   552 	MULD2	R4,dbg$gl_seman1[R2]	; multiply
                                 04  042B   553 	RET				; and return successfully
                                     042C   554 
                                     042C   555 30$:
   00000000'EF43          0B     D1  042C   556 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  0434   557 	BEQL	40$			; yes, branch
                          026F   31  0436   558 	BRW	arith_error		; no, signal error
                                     0439   559 
                                     0439   560 40$:
            53            02     C6  0439   561 	DIVL2	#2,R3			; divide offsets by two since
            52            02     C6  043C   562 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42 00000000'EF43   64  043F   563 	MULD2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; multiply
                                 04  044C   564 	RET				; and return successfully
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  13
000005          DBG$FOR_DIV Fortran division routine                                                                             (5)

                                     044D   566 .SBTTL	DBG$FOR_DIV	Fortran division routine
                                     044D   567 ;++
                                     044D   568 ;
                                     044D   569 ; FUNCTIONAL DESCRIPTION:
                                     044D   570 ;	Divides two elements on the parse stack. They are elements found
                                     044D   571 ;	at the position indicated by the offset passed as the routine's
                                     044D   572 ;	argument, and the position two stack locations further along.
                                     044D   573 ;	The quotient is put in the former position.
                                     044D   574 ;
                                     044D   575 ;	The elements are in the parse stack called dbg$gl_seman1.
                                     044D   576 ;	Each element has its type in the corresponding position in the
                                     044D   577 ;	other parse stack, dbg$gl_seman2. The rules for mixed mode
                                     044D   578 ;	are the same as listed in dbg$for_add.
                                     044D   579 ;
                                     044D   580 ;	Any other data types cause an error to be signaled.
                                     044D   581 ;
                                     044D   582 ; CALLING SEQUENCE:
                                     044D   583 ;	dbg$for_div (stack_offset.rl)
                                     044D   584 ;
                                     044D   585 ; INPUT PARAMETERS:
                                     044D   586 ;	4(AP)	- offset into the parse stack that is called dbg$gl_seman1.
                                     044D   587 ;
                                     044D   588 ; IMPLICIT INPUTS:
                                     044D   589 ;	the second element to be divided is two stack positions farther
                                     044D   590 ;	along than the offset passed.
                                     044D   591 ;
                                     044D   592 ; OUTPUT PARAMETERS:
                                     044D   593 ;	NONE
                                     044D   594 ;
                                     044D   595 ; IMPLICIT OUTPUTS:
                                     044D   596 ;	NONE
                                     044D   597 ;
                                     044D   598 ; ROUTINE VALUE:
                                     044D   599 ;	NONE
                                     044D   600 ;
                                     044D   601 ; SIDE EFFECTS:
                                     044D   602 ;	the quotient of the two elements is placed on the stack in the position
                                     044D   603 ;	indicated by the offset passed as an argument. The corresponding
                                     044D   604 ;	data type in dbg$gl_seman2 is updated to reflect the type of
                                     044D   605 ;	the quotient.
                                     044D   606 ;
                                     044D   607 ;--
                                     044D   608 
                               003C' 044D   609 	.ENTRY	dbg$for_div, ^M<R2,R3,R4,R5>
                                     044F   610 
            52         04 AC     D0  044F   611 	MOVL	4(AP),R2		; get offset to first operand
            52            04     C1  0453   612 	ADDL3	#dbg$k_spos_two,R2,R3	; and offset to second operand
                          53         0456       
                                     0457   613 
                                     0457   614 ;++
                                     0457   615 ; First handle the case where the first operand is an integer. This
                                     0457   616 ; involves conversions of the first operand if the second operand is
                                     0457   617 ; single or double precision. Integer, single and double precision
                                     0457   618 ; division is performed, depending on the type of the second operand.
                                     0457   619 ;--
   00000000'EF42          08     D1  0457   620 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2 [R2]	; is first operand integer?
                          03     13  045F   621 	BEQL	20$			; yes
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  14
000005          DBG$FOR_DIV Fortran division routine                                                                             (5)

                          009A   31  0461   622 	BRW	not_int_div		; no, branch to check for single precision
                                     0464   623 
                                     0464   624 20$:
   00000000'EF43          08     D1  0464   625 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          1A     12  046C   626 	BNEQ	40$			; no, branch to check for single precision
                 00000000'EF43   D5  046E   627 	TSTL	dbg$gl_seman1[R3]	; is second operand zero?
                          03     12  0475   628 	BNEQ	30$			; no, division okay
                          01AE   31  0477   629 	BRW	div_by_zero		; not permitted, signal error
                                     047A   630 
                                     047A   631 30$:
   00000000'EF42 00000000'EF43   C6  047A   632 	DIVL2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; divide
                                 04  0487   633 	RET				; and return
                                     0488   634 
                                     0488   635 40$:
   00000000'EF43          0A     D1  0488   636 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          2B     12  0490   637 	BNEQ	60$			; no, branch to check for double
                 00000000'EF43   53  0492   638 	TSTF	dbg$gl_seman1[R3]	; is second operand zero?
                          03     12  0499   639 	BNEQ	50$			; no, division okay
                          018A   31  049B   640 	BRW	div_by_zero		; not permitted, signal error
                                     049E   641 
                                     049E   642 50$:
            54   00000000'EF42   4E  049E   643 	CVTLF	dbg$gl_seman1[R2],R4	; yes, convert first operand to single.
            54   00000000'EF43   47  04A6   644 	DIVF3	dbg$gl_seman1[R3],R4,dbg$gl_seman1[R2]	; divide
                 00000000'EF42       04AE       
   00000000'EF42          0A     D0  04B4   645 	MOVL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; set data type to
                                     04BC   646 					; single precision for quotient
                                 04  04BC   647 	RET				; and return successfully.
                                     04BD   648 
                                     04BD   649 60$:
   00000000'EF43          0B     D1  04BD   650 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  04C5   651 	BEQL	80$			; yes, branch to convert and divide
                          01DE   31  04C7   652 	BRW	arith_error		; no, signal error
                                     04CA   653 
                                     04CA   654 80$:
            53            02     C6  04CA   655 	DIVL2	#2,R3			; divide offsets by two because
                                     04CD   656 					; next indexing is quadword.
                                     04CD   657 					; indexing.
                 00000000'EF43   73  04CD   658 	TSTD	dbg$gl_seman1[R3]	; is second operand zero?
                          03     12  04D4   659 	BNEQ	90$			; no, division okay
                          014F   31  04D6   660 	BRW	div_by_zero		; not permitted, signal error
                                     04D9   661 
                                     04D9   662 90$:
            54   00000000'EF42   6E  04D9   663 	CVTLD	dbg$gl_seman1[R2],R4	; convert first operand to double.
            52            02     C6  04E1   664 	DIVL2	#2,R2			; next indexing is quadword.
            54   00000000'EF43   67  04E4   665 	DIVD3	dbg$gl_seman1[R3],R4,dbg$gl_seman1[R2]	; divide
                 00000000'EF42       04EC       
            52            02     C4  04F2   666 	MULL2	#2,R2			; now set R2 up for longword
                                     04F5   667 					; indexing again.
   00000000'EF42          0B     D0  04F5   668 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; set data type to
                                     04FD   669 					; double precision for quotient
                                 04  04FD   670 	RET				; and return successfully.
                                     04FE   671 
                                     04FE   672 ;++
                                     04FE   673 ; The first operand was not integer. Check for single precision. If it is
                                     04FE   674 ; single precision, do either single or double precision division
                                     04FE   675 ; depending on the data type of the second operand.
                                     04FE   676 ;--
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  15
000005          DBG$FOR_DIV Fortran division routine                                                                             (5)

                                     04FE   677 not_int_div:
   00000000'EF42          0A     D1  04FE   678 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; is first operand single?
                          03     13  0506   679 	BEQL	5$			; yes, branch and proceed
                          0092   31  0508   680 	BRW	not_sin_div		; no, branch to check for double.
                                     050B   681 
                                     050B   682 5$:
   00000000'EF43          08     D1  050B   683 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          23     12  0513   684 	BNEQ	20$			; no, branch to check for single
                 00000000'EF43   D5  0515   685 	TSTL	dbg$gl_seman1[R3]	; is second operand zero?
                          03     12  051C   686 	BNEQ	10$			; no, division okay
                          0107   31  051E   687 	BRW	div_by_zero		; not permitted, signal error
                                     0521   688 
                                     0521   689 10$:
            54   00000000'EF43   4E  0521   690 	CVTLF	dbg$gl_seman1[R3],R4	; yes, convert second operand to single.
   00000000'EF42          54     47  0529   691 	DIVF3	R4,dbg$gl_seman1[R2],dbg$gl_seman1[R2]	; divide
                 00000000'EF42       0531       
                                 04  0537   692 	RET				; and return successfully
                                     0538   693 
                                     0538   694 20$:
   00000000'EF43          0A     D1  0538   695 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          1A     12  0540   696 	BNEQ	40$			; no, branch to check for double
                 00000000'EF43   53  0542   697 	TSTF	dbg$gl_seman1[R3]	; is second operand zero?
                          03     12  0549   698 	BNEQ	30$			; no, division okay
                          00DA   31  054B   699 	BRW	div_by_zero		; not permitted, signal error
                                     054E   700 
                                     054E   701 30$:
   00000000'EF42 00000000'EF43   46  054E   702 	DIVF2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; divide
                                 04  055B   703 	RET				; and return successfully
                                     055C   704 
                                     055C   705 40$:
   00000000'EF43          0B     D1  055C   706 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  0564   707 	BEQL	60$			; yes, branch to do convert and divide
                          013F   31  0566   708 	BRW	arith_error		; no, signal error
                                     0569   709 
                                     0569   710 60$:
            53            02     C6  0569   711 	DIVL2	#2,R3			; divide offsets by two since
                                     056C   712 					; next indexing is quadword.
                 00000000'EF43   73  056C   713 	TSTD	dbg$gl_seman1[R3]	; is second operand zero?
                          03     12  0573   714 	BNEQ	70$			; no, division okay
                          00B0   31  0575   715 	BRW	div_by_zero		; not permitted, signal error
                                     0578   716 
                                     0578   717 70$:
            54   00000000'EF42   56  0578   718 	CVTFD	dbg$gl_seman1[R2],R4	; convert first operand to double.
            52            02     C6  0580   719 	DIVL2	#2,R2			; next indexing is quadword
            54   00000000'EF43   67  0583   720 	DIVD3	dbg$gl_seman1[R3],R4,dbg$gl_seman1[R2]	; divide
                 00000000'EF42       058B       
            52            02     C4  0591   721 	MULL2	#2,R2			; multiply offset by two again
                                     0594   722 					; to do longword indexing.
   00000000'EF42          0B     D0  0594   723 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; store double data
                                     059C   724 					; type with quotient
                                 04  059C   725 	RET				; and return successfully
                                     059D   726 
                                     059D   727 ;++
                                     059D   728 ; The first operand is either double precision or an erroneous type.
                                     059D   729 ; In the former case, convert the second operand to double precision
                                     059D   730 ; if necessary and then do a double precision division.
                                     059D   731 ;--
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  16
000005          DBG$FOR_DIV Fortran division routine                                                                             (5)

                                     059D   732 not_sin_div:
   00000000'EF42          0B     D1  059D   733 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; is first operand double?
                          03     13  05A5   734 	BEQL	20$			; yes, branch to check second operand
                          00FE   31  05A7   735 	BRW	arith_error		; no, signal error
                                     05AA   736 
                                     05AA   737 20$:
   00000000'EF43          08     D1  05AA   738 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is second operand integer?
                          1F     12  05B2   739 	BNEQ	40$			; no, branch to check for single
                 00000000'EF43   D5  05B4   740 	TSTL	dbg$gl_seman1[R3]	; is second operand zero?
                          02     12  05BB   741 	BNEQ	30$			; no, division okay
                          69     11  05BD   742 	BRB	div_by_zero		; not permitted, signal error
                                     05BF   743 
                                     05BF   744 30$:
            54   00000000'EF43   6E  05BF   745 	CVTLD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  05C7   746 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     66  05CA   747 	DIVD2	R4,dbg$gl_seman1[R2]	; divide
                                 04  05D2   748 	RET				; and return successfully
                                     05D3   749 
                                     05D3   750 40$:
   00000000'EF43          0A     D1  05D3   751 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is second operand single?
                          1F     12  05DB   752 	BNEQ	60$			; no, branch to check for double.
                 00000000'EF43   53  05DD   753 	TSTF	dbg$gl_seman1[R3]	; is second operand zero?
                          02     12  05E4   754 	BNEQ	50$			; no, division okay
                          40     11  05E6   755 	BRB	div_by_zero		; not permitted, signal error
                                     05E8   756 
                                     05E8   757 50$:
            54   00000000'EF43   56  05E8   758 	CVTFD	dbg$gl_seman1[R3],R4	; yes, convert it to double.
            52            02     C6  05F0   759 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42          54     66  05F3   760 	DIVD2	R4,dbg$gl_seman1[R2]	; divide
                                 04  05FB   761 	RET				; and return successfully
                                     05FC   762 
                                     05FC   763 60$:
   00000000'EF43          0B     D1  05FC   764 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is second operand double?
                          03     13  0604   765 	BEQL	80$			; yes, branch
                          009F   31  0606   766 	BRW	arith_error		; no, signal error
                                     0609   767 
                                     0609   768 80$:
            53            02     C6  0609   769 	DIVL2	#2,R3			; divide offsets by two since
                                     060C   770 					; next indexing is quadword.
                 00000000'EF43   73  060C   771 	TSTD	dbg$gl_seman1[R3]	; is second operand zero?
                          02     12  0613   772 	BNEQ	90$			; no, division okay
                          11     11  0615   773 	BRB	div_by_zero		; not permitted, signal error
                                     0617   774 
                                     0617   775 90$:
            52            02     C6  0617   776 	DIVL2	#2,R2			; next indexing is quadword.
   00000000'EF42 00000000'EF43   66  061A   777 	DIVD2	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; divide
                                 04  0627   778 	RET				; and return successfully
                                     0628   779 
                                     0628   780 
                                     0628   781 div_by_zero:
                 000282F0 8F     DD  0628   782 	PUSHL	#dbg$_divbyzero		; set up for divide by zero message
   00000000'EF            01     FB  062E   783 	CALLS	#01, lib$signal		; and signal warning, with no return.
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  17
000005          DBG$FOR_NEG Fortran negation routine                                                                             (6)

                                     0635   785 .SBTTL	DBG$FOR_NEG	Fortran negation routine
                                     0635   786 ;++
                                     0635   787 ;
                                     0635   788 ; FUNCTIONAL DESCRIPTION:
                                     0635   789 ;	negates a single or double precision value. The value is found
                                     0635   790 ;	one stack position farther along than the offset passed to
                                     0635   791 ;	this routine as an argument. The result is placed in the stack
                                     0635   792 ;	position indicated by the argument offset.
                                     0635   793 ;
                                     0635   794 ;	The data type of the value to be negated is found in the position
                                     0635   795 ;	corresponding to the value on the second parse stack --
                                     0635   796 ;	dbg$gl_seman2.
                                     0635   797 ;
                                     0635   798 ; CALLING SEQUENCE:
                                     0635   799 ;	dbg$for_neg (stack_offset.rl)
                                     0635   800 ;
                                     0635   801 ; INPUT PARAMETERS:
                                     0635   802 ;	4(AP)	- offset into the stack that is called dbg$gl_seman1.
                                     0635   803 ;
                                     0635   804 ; IMPLICIT INPUTS:
                                     0635   805 ;	The value to be negated is one stack position farther along
                                     0635   806 ;	than the offset passed.
                                     0635   807 ;
                                     0635   808 ; OUTPUT PARAMETERS:
                                     0635   809 ;	NONE
                                     0635   810 ;
                                     0635   811 ; IMPLICIT OUTPUTS:
                                     0635   812 ;	NONE
                                     0635   813 ;
                                     0635   814 ; ROUTINE VALUE:
                                     0635   815 ;	NONE
                                     0635   816 ;
                                     0635   817 ; SIDE EFFECTS:
                                     0635   818 ;	The negated value is placed on the stack in the position
                                     0635   819 ;	indicated by the offset passed as an argument. The corresponding
                                     0635   820 ;	data type in dbg$gl_seman2 is updated to reflect the type
                                     0635   821 ;	of the negated value.
                                     0635   822 ;
                                     0635   823 ;--
                                     0635   824 
                               000C' 0635   825 	.ENTRY	dbg$for_neg, ^M<R2,R3>
                                     0637   826 
            52         04 AC     D0  0637   827 	MOVL	4(AP),R2		; get offset to stack position
            52            02     C1  063B   828 	ADDL3	#dbg$k_spos_one,R2,R3	; and offset to value
                          53         063E       
   00000000'EF43          08     D1  063F   829 	CMPL	#dsc$k_dtype_l,dbg$gl_seman2[R3]	; is value integer?
                          16     12  0647   830 	BNEQ	10$			; no, branch and check for single
   00000000'EF42 00000000'EF43   CE  0649   831 	MNEGL	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; negate it
   00000000'EF42          08     D0  0656   832 	MOVL	#dsc$k_dtype_l,dbg$gl_seman2[R2]	; set data type
                                     065E   833 					; in corresponding stack position
                                 04  065E   834 	RET				; and return successfully
                                     065F   835 
                                     065F   836 10$:
   00000000'EF43          0A     D1  065F   837 	CMPL	#dsc$k_dtype_f,dbg$gl_seman2[R3]	; is value single?
                          16     12  0667   838 	BNEQ	20$			; no, branch and check for double
   00000000'EF42 00000000'EF43   52  0669   839 	MNEGF	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; negate it
   00000000'EF42          0A     D0  0676   840 	MOVL	#dsc$k_dtype_f,dbg$gl_seman2[R2]	; set data type
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  18
000005          DBG$FOR_NEG Fortran negation routine                                                                             (6)

                                     067E   841 					; in corresponding stack position
                                     067E   842 					; to single precision.
                                 04  067E   843 	RET				; and return successfully
                                     067F   844 
                                     067F   845 20$:
   00000000'EF43          0B     D1  067F   846 	CMPL	#dsc$k_dtype_d,dbg$gl_seman2[R3]	; is value double?
                          1F     12  0687   847 	BNEQ	arith_error		; no, must be an error
            53            02     C6  0689   848 	DIVL2	#2,R3			; divide offset by two because
            52            02     C6  068C   849 	DIVL2	#2,R2			; the next instruction does quadword
                                     068F   850 					; indexing
   00000000'EF42 00000000'EF43   72  068F   851 	MNEGD	dbg$gl_seman1[R3],dbg$gl_seman1[R2]	; negate it
            52            02     C4  069C   852 	MULL2	#2,R2			; convert index back to longword.
   00000000'EF42          0B     D0  069F   853 	MOVL	#dsc$k_dtype_d,dbg$gl_seman2[R2]	; set data type
                                     06A7   854 					; in corresponding stack position
                                     06A7   855 					; to double precision.
                                 04  06A7   856 	RET				; and return successfully
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  19
000005          ARITH_ERROR Type of numbers not recoginized                                                                      (7)

                                     06A8   858 .SBTTL	ARITH_ERROR	Type of numbers not recoginized
                                     06A8   859 ;++
                                     06A8   860 ; This is the general error return from all the routines in this
                                     06A8   861 ; module.
                                     06A8   862 ;--
                                     06A8   863 
                                     06A8   864 arith_error:
                 00028248 8F     DD  06A8   865 	PUSHL	#dbg$_parseerr		; signal parse error since an
                                     06AE   866 					; invalid data type was seen
   00000000'EF            01     FB  06AE   867 	CALLS	#01, lib$signal		; signal
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  20
000005          Fortran conversion routines                                                                                      (8)

                                     06B5   869 .SBTTL	Fortran conversion routines
                                     06B5   870 ;++
                                     06B5   871 ;	dbg$cnv_l_to_f
                                     06B5   872 ;	dbg$cnv_l_to_d
                                     06B5   873 ;	dbg$cnv_f_to_l
                                     06B5   874 ;	dbg$cnv_f_to_d
                                     06B5   875 ;	dbg$cnv_d_to_l
                                     06B5   876 ;	dbg$cnv_d_to_f
                                     06B5   877 ;
                                     06B5   878 ; FUNCTIONAL DESCRIPTION:
                                     06B5   879 ;	dbg$cnv_l_to_f	- converts integer to single precision
                                     06B5   880 ;	dbg$cnv_l_to_d	- converts integer to double precision
                                     06B5   881 ;	dbg$cnv_f_to_l	- converts single precision to integer
                                     06B5   882 ;	dbg$cnv_f_to_d	- converts single precision to double precision
                                     06B5   883 ;	dbg$cnv_d_to_l	- converts double precision to integer
                                     06B5   884 ;	dbg$cnv_d_to_f	- converts double precision to single precision
                                     06B5   885 ;
                                     06B5   886 ; CALLING SEQUENCE:
                                     06B5   887 ;	dbg$cnv_?_to_? (address.rf)
                                     06B5   888 ;
                                     06B5   889 ; INPUT PARAMETERS:
                                     06B5   890 ;	address	- address of a value
                                     06B5   891 ;
                                     06B5   892 ; IMPLICIT INPUTS:
                                     06B5   893 ;	NONE
                                     06B5   894 ;
                                     06B5   895 ; OUTPUT PARAMETERS:
                                     06B5   896 ;	NONE
                                     06B5   897 ;
                                     06B5   898 ; IMPLICIT OUTPUTS:
                                     06B5   899 ;	The converted value is written into the location where the
                                     06B5   900 ;	unconverted value was previously.
                                     06B5   901 ;
                                     06B5   902 ; ROUTINE VALUE:
                                     06B5   903 ;	NONE
                                     06B5   904 ;
                                     06B5   905 ; SIDE EFFECTS:
                                     06B5   906 ;	NONE
                                     06B5   907 ;
                                     06B5   908 ;--
                                     06B5   909 
                               000C' 06B5   910 	.ENTRY	dbg$cnv_l_to_f, ^M<R2,R3>
                                     06B7   911 
            52         04 BC     4E  06B7   912 	CVTLF	@4(AP),R2		; convert integer to single precision.
         04 BC            52     50  06BB   913 	MOVF	R2,@4(AP)		; return to original address
                                 04  06BF   914 	RET
                                     06C0   915 
                               000C' 06C0   916 	.ENTRY	dbg$cnv_l_to_d, ^M<R2,R3>
                                     06C2   917 
            52         04 BC     6E  06C2   918 	CVTLD	@4(AP),R2		; convert integer to double precision.
         04 BC            52     70  06C6   919 	MOVD	R2,@4(AP)		; return to original address
                                 04  06CA   920 	RET
                                     06CB   921 
                               000C' 06CB   922 	.ENTRY	dbg$cnv_f_to_l, ^M<R2,R3>
                                     06CD   923 
            52         04 BC     4A  06CD   924 	CVTFL	@4(AP),R2		; convert single precision to integer
         04 BC            52     D0  06D1   925 	MOVL	R2,@4(AP)		; return to original address
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  21
000005          Fortran conversion routines                                                                                      (8)

                                 04  06D5   926 	RET
                                     06D6   927 
                               000C' 06D6   928 	.ENTRY	dbg$cnv_f_to_d, ^M<R2,R3>
                                     06D8   929 
            52         04 BC     56  06D8   930 	CVTFD	@4(AP),R2		; convert single to double precision
         04 BC            52     70  06DC   931 	MOVD	R2,@4(AP)		; return to original address
                                 04  06E0   932 	RET
                                     06E1   933 
                               000C' 06E1   934 	.ENTRY	dbg$cnv_d_to_l, ^M<R2,R3>
                                     06E3   935 
            52         04 BC     6A  06E3   936 	CVTDL	@4(AP),R2		; convert double precision to integer
         04 BC            52     D0  06E7   937 	MOVL	R2,@4(AP)		; return to original address
                                 04  06EB   938 	RET
                                     06EC   939 
                               000C' 06EC   940 	.ENTRY	dbg$cnv_d_to_f, ^M<R2,R3>
                                     06EE   941 
            52         04 BC     76  06EE   942 	CVTDF	@4(AP),R2		; convert double to single precision
         04 BC            52     50  06F2   943 	MOVF	R2,@4(AP)		; return to original address
                                 04  06F6   944 	RET
                                     06F7   945 
                                     06F7   946 
                                     06F7   947 .END
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  22
SYMBOL TABLE                                                                                                                     (8)

ARITH_ERROR      000006A8 R     03   DBG$L_NEXT_LINK  00000000            DBG$_BADCSP    = 00028198            
BIT...         = 00000008            DBG$L_USER_AP    00000034            DBG$_BADOPCODE = 00028278            
DBG$B_BPT_INS    00000060            DBG$L_USER_FP    00000038            DBG$_BADSTARTPC= 00028208            
DBG$B_PREV_PRO1  0000005E            DBG$L_USER_PC    00000040            DBG$_BADWATCH  = 000282D8            
DBG$B_PREV_PRO2  0000005F            DBG$L_USER_PSL   00000044            DBG$_BITRANGE  = 000282F8            
DBG$B_USER_OPCO  00000040            DBG$L_USER_R0    00000004            DBG$_BRTOOFAR  = 00028290            
DBG$CNV_D_TO_F   000006EC RG    03   DBG$L_USER_R1    00000008            DBG$_DBGBUG    = 0002800B            
DBG$CNV_D_TO_L   000006E1 RG    03   DBG$L_USER_R10   0000002C            DBG$_DBGERR    = 00028322            
DBG$CNV_F_TO_D   000006D6 RG    03   DBG$L_USER_R11   00000030            DBG$_DBGNULL   = 00028190            
DBG$CNV_F_TO_L   000006CB RG    03   DBG$L_USER_R2    0000000C            DBG$_DBGNULLA  = 000281A0            
DBG$CNV_L_TO_D   000006C0 RG    03   DBG$L_USER_R3    00000010            DBG$_DBGNULLB  = 000281C0            
DBG$CNV_L_TO_F   000006B5 RG    03   DBG$L_USER_R4    00000014            DBG$_DBGNULLC  = 000281C8            
DBG$C_RUNFR_LEN  00000061            DBG$L_USER_R5    00000018            DBG$_DBGNULLD  = 000281D8            
DBG$FOR_ADD      00000000 RG    03   DBG$L_USER_R6    0000001C            DBG$_DBGNULLE  = 00028200            
DBG$FOR_DIV      0000044D RG    03   DBG$L_USER_R7    00000020            DBG$_DBGNULLF  = 00028228            
DBG$FOR_MUL      000002DE RG    03   DBG$L_USER_R8    00000024            DBG$_DBGNULLG  = 00028258            
DBG$FOR_NEG      00000635 RG    03   DBG$L_USER_R9    00000028            DBG$_DBGNULLH  = 00028268            
DBG$FOR_SUB      0000016F RG    03   DBG$L_USER_REGS  00000004            DBG$_DBGNULLI  = 000282E0            
DBG$GL_SEMAN1    ********   X   03   DBG$L_USER_SP    0000003C            DBG$_DEBUGBUG  = 00028352            
DBG$GL_SEMAN2    ********   X   03   DBG$L_WATCHPT    00000056            DBG$_DIVBYZERO = 000282F0            
DBG$K_ALL      = 00000009            DBG$L_WATCHPTEN  0000005A            DBG$_ENDWITHGO = 00028270            
DBG$K_ALL_BREAK= 00000010            DBG$M_AT_BREAK = 00000001            DBG$_EXARANGE  = 000281A8            
DBG$K_ALL_TRACE= 00000012            DBG$M_AT_TRACE = 00000010            DBG$_EXITSTATUS= 0002808B            
DBG$K_ALL_WATCH= 00000011            DBG$M_ENAB_AST = 00000020            DBG$_EXPSTKOVR = 000280D8            
DBG$K_BREAK    = 00000002            DBG$M_IN_A_BPT = 00000040            DBG$_FRERANGE  = 0002832A            
DBG$K_CANCEL   = 00000005            DBG$M_IN_A_WPT = 00000100            DBG$_FRESIZE   = 00028332            
DBG$K_EXAMINE  = 00000006            DBG$M_REAL_WPT = 00000200            DBG$_INITIAL   = 00028013            
DBG$K_LANGUAGE = 00000004            DBG$M_STAR_PROG= 00000002            DBG$_INTEGER   = 00028300            
DBG$K_MODE     = 00000000            DBG$M_STEPPING = 00000008            DBG$_INVARRDSC = 000281B0            
DBG$K_MODULE   = 0000000C            DBG$M_STEP_OVER= 00000400            DBG$_INVCHAR   = 000281B8            
DBG$K_NO_RESET = 00000001            DBG$M_TBIT     = 00000010            DBG$_INVDIM    = 00028240            
DBG$K_OVERRIDE = 00000007            DBG$M_TBIT_OK  = 00000080            DBG$_INVDSTREC = 0002833A            
DBG$K_RESET_PRT= 00000002            DBG$M_TRACE_ALL= 00000004            DBG$_INVNUMBER = 000281D0            
DBG$K_RESIGNAL = 0000000A            DBG$S_AT_BREAK = 00000001            DBG$_INVOPR    = 000280F0            
DBG$K_RUNFR_LEN  00000061            DBG$S_AT_TRACE = 00000001            DBG$_INVPATH   = 000280F8            
DBG$K_SCOPE    = 0000000B            DBG$S_ENAB_AST = 00000001            DBG$_LASTCHANCE= 00028318            
DBG$K_SET_BREAK= 00000003            DBG$S_IN_A_BPT = 00000001            DBG$_LONGDST   = 0002801B            
DBG$K_SPOS_EIGH= 00000010            DBG$S_IN_A_WPT = 00000001            DBG$_MAXDIMSN  = 00028238            
DBG$K_SPOS_FIVE= 0000000A            DBG$S_REAL_WPT = 00000001            DBG$_MODNOTADD = 00028023            
DBG$K_SPOS_FOUR= 00000008            DBG$S_STAR_PROG= 00000001            DBG$_MULTOPR   = 000280D0            
DBG$K_SPOS_NINE= 00000012            DBG$S_STEPPING = 00000001            DBG$_NEEDMORE  = 00028108            
DBG$K_SPOS_ONE = 00000002            DBG$S_STEP_OVER= 00000001            DBG$_NOACCESSR = 000282B8            
DBG$K_SPOS_SEVE= 0000000E            DBG$S_TBIT_OK  = 00000001            DBG$_NOACCESSW = 000282B0            
DBG$K_SPOS_SIX = 0000000C            DBG$S_TRACE_ALL= 00000001            DBG$_NOANGLE   = 000280E0            
DBG$K_SPOS_THRE= 00000006            DBG$V_AT_BREAK = 00000000            DBG$_NOBRANCH  = 00028298            
DBG$K_SPOS_TWO = 00000004            DBG$V_AT_TRACE = 00000004            DBG$_NOBREAKS  = 0002802B            
DBG$K_SPOS_ZERO= 00000000            DBG$V_ENAB_AST = 00000005            DBG$_NOCALLS   = 000281E0            
DBG$K_STELMSIZE= 00000002            DBG$V_IN_A_BPT = 00000006            DBG$_NODECODE  = 000281E8            
DBG$K_STEP     = 0000000F            DBG$V_IN_A_WPT = 00000008            DBG$_NODELIMTR = 000282A0            
DBG$K_TRACE    = 00000001            DBG$V_REAL_WPT = 00000009            DBG$_NOEND     = 000281F8            
DBG$K_TRACEBACK= 0000000D            DBG$V_STAR_PROG= 00000001            DBG$_NOFREE    = 00028342            
DBG$K_TRCE_BRCH= 00000013            DBG$V_STEPPING = 00000003            DBG$_NOGLOBALS = 00028073            
DBG$K_TRCE_CALL= 00000008            DBG$V_STEP_OVER= 0000000A            DBG$_NOINSTRAN = 000281F0            
DBG$K_WATCH    = 0000000E            DBG$V_TBIT     = 00000004            DBG$_NOLABEL   = 000282C8            
DBG$L_BPT_PC     0000004A            DBG$V_TBIT_OK  = 00000007            DBG$_NOLINE    = 000282D0            
DBG$L_CALL_ADDR  00000052            DBG$V_TRACE_ALL= 00000002            DBG$_NOLITERAL = 00028100            
DBG$L_FRAME_PTR  0000004E            DBG$W_RUN_STAT   00000048            DBG$_NOLOCALS  = 0002806B            
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  23
SYMBOL TABLE                                                                                                                     (8)

DBG$_NOOPRND   = 000280E8            DSC$K_DTYPE_BU = 00000002            NOT_SIN_DIV      0000059D R     03   
DBG$_NORMAL    = 00028001            DSC$K_DTYPE_D  = 0000000B            NOT_SIN_MUL      000003E3 R     03   
DBG$_NORSTBLD  = 0002835A            DSC$K_DTYPE_DC = 0000000D            NOT_SIN_SUB      00000274 R     03   
DBG$_NOSUCHBPT = 00028033            DSC$K_DTYPE_DPC= 000000B9            
DBG$_NOSUCHLAB = 00028310            DSC$K_DTYPE_EOM= 000000BD            
DBG$_NOSUCHLAN = 00028210            DSC$K_DTYPE_EOR= 000000BF            
DBG$_NOSUCHLIN = 00028218            DSC$K_DTYPE_F  = 0000000A            
DBG$_NOSUCHMODU= 00028220            DSC$K_DTYPE_FC = 0000000C            
DBG$_NOSUCHTPT = 0002803B            DSC$K_DTYPE_FLD= 000000B7            
DBG$_NOSUCHWPT = 00028043            DSC$K_DTYPE_L  = 00000008            
DBG$_NOSYMBOL  = 00028230            DSC$K_DTYPE_LBL= 000000BA            
DBG$_NOTALLSYM = 0002807B            DSC$K_DTYPE_LU = 00000004            
DBG$_NOTDONE   = 000282C0            DSC$K_DTYPE_MOD= 000000BC            
DBG$_NOTIMPLAN = 00028308            DSC$K_DTYPE_NL = 00000010            
DBG$_NOTRACES  = 0002804B            DSC$K_DTYPE_NLO= 00000011            
DBG$_NOWATCHES = 00028053            DSC$K_DTYPE_NR = 00000012            
DBG$_NOWBPT    = 000284B4            DSC$K_DTYPE_NRO= 00000013            
DBG$_NOWOPCO   = 000284BC            DSC$K_DTYPE_NU = 0000000F            
DBG$_NOWPROT   = 000284C4            DSC$K_DTYPE_NZ = 00000014            
DBG$_NUMOPRNDS = 000282A8            DSC$K_DTYPE_P  = 00000015            
DBG$_NUMTRUNC  = 0002805B            DSC$K_DTYPE_PCT= 000000B8            
DBG$_OPSYNTAX  = 00028288            DSC$K_DTYPE_Q  = 00000009            
DBG$_PARSEERR  = 00028248            DSC$K_DTYPE_QU = 00000005            
DBG$_PARSTKOVR = 00028118            DSC$K_DTYPE_RTN= 000000BE            
DBG$_PATHTLONG = 00028250            DSC$K_DTYPE_SLB= 000000BB            
DBG$_REDEFREG  = 00028260            DSC$K_DTYPE_T  = 0000000E            
DBG$_RESOPCODE = 00028280            DSC$K_DTYPE_V  = 00000001            
DBG$_RSTERR    = 0002834A            DSC$K_DTYPE_W  = 00000007            
DBG$_STEPINTO  = 00028083            DSC$K_DTYPE_WU = 00000003            
DBG$_STGTRUNC  = 00028063            DSC$K_DTYPE_Z  = 00000000            
DBG$_SUBSTRING = 00028110            DSC$K_DTYPE_ZEM= 00000017            
DBG$_SYNTAX    = 000282E8            DSC$K_DTYPE_ZI = 00000016            
DIV_BY_ZERO      00000628 R     03   DSC$K_D_BLN      00000008            
DSC$A_A0         00000010            DSC$K_JI_BLN     0000000C            
DSC$A_FRAME      00000008            DSC$K_J_BLN      00000008            
DSC$A_POINTER    00000004            DSC$K_PI_BLN     0000000C            
DSC$B_AFLAGS     0000000A            DSC$K_P_BLN      00000008            
DSC$B_CLASS      00000003            DSC$K_S_BLN      00000008            
DSC$B_DIMCT      0000000B            DSC$K_Z_BLN      00000008            
DSC$B_DTYPE      00000002            DSC$L_ARSIZE     0000000C            
DSC$C_D_BLN      00000008            DSC$L_M1         00000014            
DSC$C_JI_BLN     0000000C            DSC$L_M2         00000018            
DSC$C_J_BLN      00000008            DSC$S_FL_BOUNDS= 00000001            
DSC$C_PI_BLN     0000000C            DSC$S_FL_COEFF = 00000001            
DSC$C_P_BLN      00000008            DSC$S_FL_COLUMN= 00000001            
DSC$C_S_BLN      00000008            DSC$V_FL_BOUNDS= 00000007            
DSC$C_Z_BLN      00000008            DSC$V_FL_COEFF = 00000006            
DSC$K_CLASS_A  = 00000004            DSC$V_FL_COLUMN= 00000005            
DSC$K_CLASS_D  = 00000002            DSC$W_LENGTH     00000000            
DSC$K_CLASS_J  = 00000007            DSC$W_MAXLEN     00000008            
DSC$K_CLASS_JI = 00000008            GBL...         = 00000000            
DSC$K_CLASS_P  = 00000005            LIB$SIGNAL       ********   X   03   
DSC$K_CLASS_PI = 00000006            NOT_INT_ADD      0000008D R     03   
DSC$K_CLASS_S  = 00000001            NOT_INT_DIV      000004FE R     03   
DSC$K_CLASS_V  = 00000003            NOT_INT_MUL      0000036B R     03   
DSC$K_CLASS_Z  = 00000000            NOT_INT_SUB      000001FC R     03   
DSC$K_DTYPE_B  = 00000006            NOT_SIN_ADD      00000105 R     03   
DBGFORARI                                                        22-AUG-1978 03:58:48   VAX-11 MACRO X0.3-11               Page  24
PROGRAM SECTION SYNOPSIS                                                                                                         (8)



PROGRAM SECTION SYNOPSIS

.  ABS  .        00000000      00     NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT BYTE  
. BLANK .        00000000      01     NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT BYTE  
$ABS$            00000061      02     NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT BYTE  
DBG$CODE         000006F7      03       PIC   USR   CON   REL   LCL   SHR   EXE   RD  NOWRT BYTE  


THERE WERE NO ERRORS OR WARNINGS.
16124. BYTES LEFT IN FREE MEMORY POOL.
3118. BYTES OF RECLAIMED MEMORY.
OBJ$:DBGFORARI,LIS$:DBGFORARI/-SP=LIB$:D/ML,SRC$:DBGFORARI
22 MLB DIR RDS - 426 GETS TO DEFINE 11 MACROS. 35 INTER. FILE WRITES. 
