
; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DBGEXA ( ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE),
;	0002			IDENT = '000077') =
;	0003	BEGIN
;	0004	
;	0005	! Copyright (C) 1977
;	0006	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0007	!
;	0008	! This software is furnished under a license for use only on a
;	0009	! single computer system and may be copied only with the inclusion
;	0010	! of the above copyright notice. This software, or any
;	0011	! other copies thereof, may not be provided or otherwise made
;	0012	! available to any other person except for use on such system
;	0013	! and to one who agrees to these license terms. Title to and
;	0014	! ownership of the software shall at all times remain in DEC.
;	0015	!
;	0016	! The information in this software is subject to change without
;	0017	! notice and should not be construed as a commitment by Digital
;	0018	! Equipment Corporation.
;	0019	!
;	0020	! DEC assumes no responsibility for the use or reliability of
;	0021	! its software on equipment which is not supplied by DEC.
;	0022	!
;	0023	! FACILITY:	DEBUG
;	0024	!
;	0025	!++
;	0026	! FUNCTIONAL DESCRIPTION:
;	0027	!	EXAMINE AND DEPOSIT ROUTINES FOR STARLET DEBUG FACILITY
;	0028	!
;	0029	! Version:	77
;	0030	!
;	0031	! History:
;	0032	!	Author:
;	0033	!		Carol Peters, 21 Jul 1976: Version 01
;	0034	!
;	0035	!	Modified by:
;	0036	!		Dale Roedger, 18 July 1978:	77
;	0037	!
;	0038	! Revision history:
;	0039	!	27	08-03-77	CP	put fixed ASCII strings in FAO control strings
;	0040	!					test for null pointer in ADEPADP
;	0041	!					check for null address before DO-UNTIL loop, load up to look like
;	0042	!					  standard case.
;	0043	!					remove select in AEXAPRE for data length check.
;	0044	!					shorten register table entry length to one longword
;	0045	!					INCR loop in REG_MATCH off by one, add '- 1'.
;	0046	!	28	21-03-77	CP	FIX WAS TO TAKE THE -1 BACK OUT OF
;	0047	!					ABOVE-MENTIONED INCR LOOP.
;	0048	!	28	21-03-77	KGP	ADDED CODE TO OUT_MEM_LOC
;	0049	!					SO THAT DBG$INS_DECODE IS
;	0050	!					CALLED ON /MACHINE TO IMPLEMENT 
;	0051	!					INSTRUCTION DECODING.
;	0052	!
;	0053	!	29	22-MAR-77	KGP	ADDED [MACHINE_RADIX] TO THE
;	0054	!					SELECTONE IN OUTPUT_REGISTER TO
;	0055	!					EFFECTIVELY IGNORE /MACHINE RADIX

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 1-1
; Digital Equipment Corporation
;
;	0056	!					WHEN SOMEONE IS EXAMINING A REGISTER.
;	0057	!					THIS IS A BUG, BUT IT IS BETTER THAN
;	0058	!					BLOWING UP OR PRINTING LINES OF JUNK.
;	0059	!	30	24-MAR-77		-TOOK OUT COUNTED_STRING, AND
;	0060	!					BEGAN CHANGES FOR NEW INPUT/OUTPUT
;	0061	!					MODES, ETC.
;	0062	!	31	25-MAR-77	KGP	-INCORPORATED MACHINE AS AN
;	0063	!					ATTRIBUTE INSTEAD OF A DATA RADIX.
;	0064	!	32	30-MAR-77	KGP	-TOOK OUT INP_, DATA_, AND ADDR_
;	0065	!					SYMBOLS IN FAVOR OF THE NEW MODE_ ONES.
;	0066	!	33	31-MAR-77	KGP	-CHANGED OUTPUT_MEM_LOC AND 
;	0067	!					OUTPUT_REGISTER SO THAT THEY NOW 
;	0068	!					ALLOCATE A LOCAL OUTPUT BUFFER AND
;	0069	!					JUST HAVE THE ROUTINES WHICH THEY
;	0070	!					CALL PUT CHARACTERS INTO IT.  THIS
;	0071	!					SMOOTHS OUT OUTPUT AND REDUCES THE
;	0072	!					NUMBER OF QIOW CALLS.
;	0073	!					-ALSO CHANGED THE ABOVE ROUTINES SO
;	0074	!					THAT WE CAN OUTPUT IN ASCII.
;	0075	!	34	05-apr-77	kgp	-Added calls to DBG$OUT_PUT to
;	0076	!					allow me to take out duplicate code.
;	0077	!					-This version also contains a 2-line
;	0078	!					fix in DBG$ADEPADP to set LAST_LOC
;	0079	!					and LAST_VAL after a DEPosit command.
;	0080	!	35	06-apr-77	kgp	-Took out all the counted strings,
;	0081	!					macros, and code which used to be used
;	0082	!					to decide how to output a value.  
;	0083	!					Now we just call DBG$OUT_VALUE.
;	0084	!	36	08-04-77	CP	Make OUTPUT_MEM_LOC a global
;	0085	!					routine so that it can be called
;	0086	!					from ACOMLIN for the EVALUATE
;	0087	!					command. Make it test a context
;	0088	!					bit to see whether the EXAMINE
;	0089	!					or EVALUATE command is being
;	0090	!					executed. In the latter case, don't
;	0091	!					precede the output value with a
;	0092	!					location colon and tab.
;	0093	!					name of new routine is DBG$OUT_MEM_LOC.
;	0094	!					Change AEXALOC to EXAMINE_CMD.
;	0095	!					Change ADEPADP to DEPOSIT_CMD.
;	0096	!	37	11-04-77	CP	Remove AEXAPRE and place it
;	0097	!					inline in AUQUNAM.
;	0098	!	38	13-04-77	CP	Add routine to output PSL in
;	0099	!					special format. Also, change
;	0100	!					count in register hunting DECR
;	0101	!					loops from REGISTER_COUNT - 2 to
;	0102	!					REGISTER_COUNT - 1.
;	0103	!	39	14-04-77	CP	Initialize variable DBG$GL_BUF_SIZ
;	0104	!					when calling FAO_PUT.
;	0105	!	40	20-04-77	CP	Change VAXDEB.BEG to be named
;	0106	!					DBGGEN.BEG. Also, add DBGPCT.BEG
;	0107	!					for PSECT declarations.
;	0108	!	41	21-04-77	CP	Change MACHINE to INSTRUCTION.
;	0109	!	42	25-04-77	CP	Add a check in EXAMINE_CMD for
;	0110	!					an attempt to examine location

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 1-2
; Digital Equipment Corporation
;
;	0111	!					zero. If this occurs, report
;	0112	!					error on output device and
;	0113	!					return immediately.
;	0114	!	43	29-04-77	CP	Change DEPOSIT_CMD to return
;	0115	!					immediately if an error occurs.
;	0116	!					It should not set PARS_MOR.
;	0117	!					Have EXAMINE_CMD notice whether
;	0118	!					ADD_ARG returns a zero, and
;	0119	!					return immediately if it does.
;	0120	!					Make OUTPUT_REGISTER NOVALUE.
;	0121	!	44	05-05-77	CP	Modify DEPOSIT_CMD to regard the
;	0122	!					second value in the command argument
;	0123	!					list entry as the address of a
;	0124	!					counted string in the case where
;	0125	!					an instruction is being deposited,
;	0126	!					and that instruction was input
;	0127	!					symbolically. After depositing
;	0128	!					the values in the DEPOSIT command,
;	0129	!					display the new contents 
;	0130	!					immediately afterwards.
;	0131	!	45	16-may-77	KGP	-Changed the calls to WRITE_MEM
;	0132	!					 in DEPOSIT_CMD because we changed
;	0133	!					 the calling sequence to accomodate
;	0134	!					 depositing instructions.
;	0135	!	46	17-MAY-77	KGP	-ADDED CODE TO DBG$OUT_MEM_LOC TO CHECK
;	0136	!					 READ ACCESS BEFORE THE EXAMINE SO THAT
;	0137	!					 WE CAN PRODUCE THE NEW ERROR MESSAGE
;	0138	!					 (UNREADABLE_PAGE) WHEN THIS OCCURS.
;	0139	!					-I ALSO TOOK OUT THE CODE WHICH STOPPED
;	0140	!					 YOU FROM EXAMINING 0, AND THERE IS NOT
;	0141	!					 CODE TO CHECK THAT YOU HAVE GIVEN A RANGE
;	0142	!					 OF ASCENDING LOCATIONS ONLY.  BEFORE,
;	0143	!					 Ex 2000:1F00 WAS IGNORED.   THIS MEANS
;	0144	!					 THAT Ex R4:R2, for example, is now
;	0145	!					 flagged as an error too, though.
;	0146	!	47	7-july-77	KGP	-I changed DBG$DEPOSTI_CMD so that
;	0147	!					 'next loc' was updated after deposit
;	0148	!					 just as it would be after examine.
;	0149	!	48	22-07-77	CP	Rewrite routing reg_match to
;	0150	!					use string descriptor format.
;	0151	!	49	07-09-77	CP	Change encoding of Plits and
;	0152	!					routine output_psl to make the
;	0153	!					module PIC. Change the sign
;	0154	!					extension field in the priv_modes
;	0155	!					access in output_psl to zero instead
;	0156	!					of one. Don't know why this ever
;	0157	!					worked.
;	0158	!	50	12-09-77	CP	Change implementation of the
;	0159	!					deposit command so that it expects
;	0160	!					a single destination and a list
;	0161	!					of values to be deposited, where
;	0162	!					each subsequent value goes in
;	0163	!					an incremented destination.
;	0164	!	51	05-10-77	CP	Change calls to error_reprt to
;	0165	!					SIGNALs.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 1-3
; Digital Equipment Corporation
;
;	0166	!	52	12-10-77	CP	Change examine command so that
;	0167	!					it does not use add_arg.
;	0168	!					Add macro to test for register
;	0169	!					presence.
;	0170	!	53	28-10-77	CP	In a deposit to the PSL, set
;	0171	!					next_loc to PSL, since there is
;	0172	!					no next register.
;	0173	!	54	2-nov-77	KGP	-Changed calling sequence to 
;	0174	!					 INS$DECODE in OUT_MEM_LOC()
;	0175	!	55	07-11-77	CP	Change references to registers
;	0176	!					to be based off the current run
;	0177	!					frame. Change all names of context
;	0178	!					bits.
;	0179	!	56	22-11-77	CP	Don't allow deposits of symbolic
;	0180	!					instructions to registers.
;	0181	!	57	01-12-77	CP	In out_mem_loc, call out_sym_val
;	0182	!					instead of out_value. Don't set
;	0183	!					next_loc and last_val in the
;	0184	!					routine out_mem_loc unless value
;	0185	!					is not output by out_typ_val.
;	0186	!	58	08-12-77	CP	Add routine dbg$sym_depos to
;	0187	!					change the contents of an
;	0188	!					address that is bound to a symbol
;	0189	!					in the RST. Change deposit_cmd
;	0190	!					to try to call this routine
;	0191	!					instead of just doing the deposit
;	0192	!					on the basis of modes.
;	0193	!					Convert expressions to be deposited
;	0194	!					according to the data type
;	0195	!					stored in the new longword in
;	0196	!					elements of the command
;	0197	!					argument list.
;	0198	!	59	30-dec-77	KGP	-All global routines are now DBG$
;	0199	!	60	24-FEB-78	DAR	Deposit now signals if there is data
;	0200	!					truncation.
;	0201	!	61	10-mar-78	KGP	-Examine of PSL gives the old 'symbolic'
;	0202	!					 format only if mode is SYMBOLIC.  
;	0203	!					 Otherwise you get it just like any 
;	0204	!					 other register display.
;	0205	!					-A deposit to the PC now 'automatically'
;	0206	!					 clears the FPD bit in the PSL.
;	0207	!	62	31-mar-78	KGP	-SYM_DEPOSIT now does type conversion
;	0208	!					 properly even if the deposit-to address
;	0209	!					 is in the middle of an array.
;	0210	!	63	27-APR-78	DAR	Modified the require and library directives
;	0211	!					for the native build.
;	0212	!	64	18-MAY-78	MCC	Changed all occurrences of 'unwriteable
;	0213	!					page' error msg to dbg$_noaccessw msg
;	0214	!	65	25-may-78	KGP	-Integrated all of the displaying of
;	0215	!					 registers into out_mem_loc so that we
;	0216	!					 no longer need to differentiate the two.
;	0217	!					 Took away output_register and added
;	0218	!					 dbg$out_regname for the use of SSV's
;	0219	!					 dbg$OUT_SYM_VAL
;	0220	!	66	26-may-78	KGP	-Added a parameter to OUT_MEM_LOC

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 1-4
; Digital Equipment Corporation
;
;	0221	!					 which we use to pass on the NT_PTR
;	0222	!					 which corresponds to what we are
;	0223	!					 displaying.
;	0224	!	67	30-may-78	KGP	-Changes to deposit_cmd so that we pass
;	0225	!					 on type info like examines do.
;	0226	!					-DBG$SYM_DEPOS changed to be SYMBOL_DEPOSIT
;	0227	!					 since it does not need to be global
;	0228	!	68	01-jun-78	KGP	-out_mem_loc now knows about EV/LITERAL
;	0229	!					-added new function display_lvts()
;	0230	!	69	05-jun-78	KGP	-deposit_cmd now gives a specific error
;	0231	!					 message for DBG>D/i Rx=..., rather
;	0232	!					 than the misleading INVCMD.
;	0233	!	70	09-jun-78	KGP	-deposit_cmd now knows about the fact that
;	0234	!					 ASCII strings are passed around by
;	0235	!					 address, now, not by value.
;	0236	!	71	12-jun-78	KGP	-deposit_cmd now treats deposits to
;	0237	!					 registers just like those to memory.
;	0238	!					 This is to avoid needless complication.
;	0239	!					-It also knows how to differentiate the
;	0240	!					 user SAYING he was depositing ASCII or
;	0241	!					 INSTRUCTION when in fact he only deposited
;	0242	!					 some scalar expression.  Bug fix.
;	0243	!	72	13-jun-78	KGP	-Bug fix: DBG>D 'abc'=value  is now
;	0244	!					 illegal since 'abc' is an lvalue but
;	0245	!					 causes us too verwrite our own storage.
;	0246	!	73	14-jun-78	KGP	-evaluat_cmd now causes last_val ('\')
;	0247	!					 to be set properly.
;	0248	!					-Deposit now leaves '\' unchanged.
;	0249	!	74	19-jun-78	KGP	-deposit now believes the length of
;	0250	!					 CHARACTER variables, and truncates ascii
;	0251	!					 strings or blank-fills, as does the
;	0252	!					 FORTRAN compiler.
;	0253	!	75	12-JUL-78	DAR	Delete reference to DBG$OUT_TYP_NUM in
;	0254	!					routine dbg$out_mem_loc.
;	0255	!					Also in dbg$evaluat_cmd, if
;	0256	!					[mode_immediate] is true we output
;	0257	!					the address, else preserve dbg$gl_next_loc.
;	0258	!	76	14-JUL-78	DAR	dbg$gl_asci_len holds the length of the
;	0259	!					ascii character string.
;	0260	!	77	18-JUL-78	DAR	DBG$OUT_MEM_LOC becomes OUTPUT_MEM_LOC
;	0261	!					has a parameter that is the type of
;	0262	!					the expression.
;	0263	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 2
; Digital Equipment Corporation
;
;	0264	! TABLE OF CONTENTS
;	0265	!--
;	0266	FORWARD ROUTINE
;	0267		dbg$out_regname,		! Match and symbolize register names
;	0268		dbg$deposit_cmd : NOVALUE,	! ROUTINE TO DEPOSIT A DATUM INTO AN ADDRESS
;	0269		dbg$examine_cmd : NOVALUE,	! ROUTINE TO EXAMINE A location
;	0270		output_mem_loc,			! ROUTINE TO OUTPUT THE CONTENTS OF A MEMORY location
;	0271		dbg$evaluat_cmd : novalue,	! Do the evaluate command.
;	0272		display_lvts : NOVALUE,		! Search LVT and display pathnames
;	0273		dbg$reg_match,			! MATCHES A STRING TO A REGISTER NAME
;	0274		symbol_deposit,			! deposit to a symbol known in RST
;	0275		output_psl : NOVALUE;		! ROUTINE TO OUTPUT PSL IN SPECIAL FORMAT
;	0276	
;	0277	!
;	0278	! Require files:
;	0279	!
;	0280	%IF %VARIANT		! True for TEN.
;     L 0281	%THEN
;     U 0282	LIBRARY 'NEW:LIB';
;     U 0283	
;     U 0284	REQUIRE 'DBGPCT.REQ';
;     U 0285	REQUIRE 'DBGGEN.REQ';
;     U 0286	REQUIRE 'DBGMSG.REQ';
;     U 0287	REQUIRE 'VXSMAC.REQ';
;     U 0288	REQUIRE 'BSTRUC.REQ';
;     U 0289	REQUIRE 'LISTEL.REQ';
;     U 0290	REQUIRE 'SYSLIT.REQ';
;     U 0291	REQUIRE 'DBGRST.REQ';
;     U 0292	REQUIRE 'SYSSER.REQ';
;     U 0293	%ELSE
;	0294	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0295	
;	0296	REQUIRE 'SRC$:DBGPCT.REQ';
;	0308	REQUIRE 'SRC$:DBGGEN.REQ';
;	0558	REQUIRE 'LIB$:DBGMSG.REQ';
;	0837	REQUIRE 'SRC$:VXSMAC.REQ';
;	0877	REQUIRE 'SRC$:BSTRUC.REQ';
;	0928	REQUIRE 'SRC$:LISTEL.REQ';
;	0962	REQUIRE 'SRC$:SYSLIT.REQ';
;	0985	REQUIRE 'SRC$:DBGRST.REQ';
;	2132	REQUIRE 'SRC$:SYSSER.REQ';
;      R2135	SWITCHES LIST (SOURCE);
;      R2136	
;      R2137	EXTERNAL ROUTINE
;      R2138		dbg$fao_out;				! formats a line and outputs to the terminal
;      R2139	
;      R2140	SWITCHES LIST (NOSOURCE);
;	2185	%FI
;	2186	
;	2187	EXTERNAL
;	2188		dbg$gb_loc_type: BYTE,			! TYPE OF END RANGE ARGUMENT
;	2189		dbg$gb_mod_ptr: REF VECTOR [, BYTE],	! POINTER TO MODE LEVEL
;	2190		dbg$cp_out_str : REF VECTOR[,BYTE],	! POINTS INTO CURRENT OUTPUT BUFFER.
;	2191		dbg$gl_context: BITVECTOR,		! CONTEXT BITS WORD
;	2192		dbg$gl_asci_len,			! Holds the length of the char. variable

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 2-1
; Digital Equipment Corporation
;
;	2193		dbg$gl_buf_siz,				! Holds count in output buffer
;	2194		dbg$gl_head_lst,			! HEAD OF LINKED LIST OF EXPRESSIONS
;	2195		dbg$gl_last_loc,			! LAST location DISPLAYED
;	2196		dbg$gl_last_val,			! LAST VALUE DISPLAYED
;	2197		dbg$gl_next_loc,			! NEXT location TO DISPLAY
;	2198		dbg$gl_runframe : REF BLOCK [, BYTE];	! pointer to current run frame
;	2199	
;	2200	EXTERNAL ROUTINE
;	2201		dbg$print_path : NOVALUE,		! print out pathnames
;	2202		dbg$add_nt_2_pv,			! build pathname vectors from NT_PTRs
;	2203		dbg$cnv_d_to_f,				! convert double to single
;	2204		dbg$cnv_d_to_l,				! convert double to integer
;	2205		dbg$cnv_f_to_d,				! convert single to double precision
;	2206		dbg$cnv_f_to_l,				! convert single to integer
;	2207		dbg$cnv_l_to_d,				! convert integer to double
;	2208		dbg$cnv_l_to_f,				! convert integer to single
;	2209		dbg$fao_put : NOVALUE,			! FORMATTED BUFFERED OUTPUT.
;	2210		dbg$ins_decode,				! ROUTINE TO OUTPUT MEMORY AS
;	2211							!  SYMBOLIC INSTRUCTIONS.
;	2212		dbg$ins_encode,				! routine to encode a symbolic instruction
;	2213		dbg$out_put : NOVALUE,			! ACTUALLY DO TERMINAL I/O.
;	2214		dbg$out_num_val,			! outputs numeric value
;	2215		dbg$out_sym_val,			! output symbolic value if possible
;	2216		dbg$out_typ_val,			! outputs typed contents of a location
;	2217		dbg$read_access,			! PROBE for read accessability.
;	2218		dbg$val_to_sat,				! translates a value to a symbol name
;	2219		dbg$get_bounds : NOVALUE,		! Calculate array bounds.
;	2220		dbg$write_mem,				! ROUTINE TO WRITE TO USER'S MEMORY
;	2221		dbg$symbol_valu,			! finds the value bound to a symbol name
;	2222		dbg$get_nxt_lvt;			! Provide access to the LVT
;	2223	
;	2224	LITERAL
;	2225		dbg_exa		= 0,			! for debugging purposes
;	2226		dbg_exa1	= 0,			! ditto
;	2227		dbg_exa2	= 0,			! ditto
;	2228		dbg_exa3	= 0,			! ditto
;	2229		dbg_exa4	= 0,			! for debugging floating point
;	2230		dbg_exa5	= 0,			! typed examine and evaluate
;	2231		dbg_exa6	= 0,			! evaluate /literal
;	2232		dbg_exa7	= 0,			! deposit /ASCII
;	2233		dbg_exa8	= 0;			! evaluate command

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 3
; Digital Equipment Corporation
;
;	2234	!++
;	2235	! register_table HOLDS ONE ENTRY PER REGISTER. EACH ENTRY IS MADE
;	2236	! UP OF ONE LONGWORD. THE FIRST BYTE HOLDS THE CHARACTER COUNT OF
;	2237	! THE REGISTER NAME. THE SECOND THROUGH FOURTH BYTES HOLD THE REGISTER
;	2238	! NAME STRING. A SAMPLE ENTRY FOLLOWS:
;	2239	!
;	2240	!	----------------------------------------------------
;	2241	!	!            !      0     !      R     !     2     !
;	2242	!	!--------------------------------------------------!
;	2243	!--
;	2244	
;	2245	MACRO
;	2246		register_entry (string) =
;     M 2247			%CHARCOUNT (STRING), %ASCII STRING, REP 3 - %CHARCOUNT (STRING) OF BYTE (0)%;
;	2248	
;	2249	BIND
;	2250		register_table = UPLIT BYTE (
;	2251	
;	2252			register_entry ('R0'),
;	2253			register_entry ('R1'),
;	2254			register_entry ('R2'),
;	2255			register_entry ('R3'),
;	2256			register_entry ('R4'),
;	2257			register_entry ('R5'),
;	2258			register_entry ('R6'),
;	2259			register_entry ('R7'),
;	2260			register_entry ('R8'),
;	2261			register_entry ('R9'),
;	2262			register_entry ('R10'),
;	2263			register_entry ('R11'),
;	2264			register_entry ('AP'),
;	2265			register_entry ('FP'),
;	2266			register_entry ('SP'),
;	2267			register_entry ('PC'),
;	2268			register_entry ('PSL')):
;	2269	
;	2270		BLOCK [, LONG];
;	2271	
;	2272	!++
;	2273	! THESE FIELD DEFINITIONS CONTROL ACCESS TO THE REGISTER TABLE
;	2274	!--
;	2275	MACRO
;	2276		REG_NAME	=8, 24, 0%,
;	2277		ctd_reg_name	=0, 24, 0%,
;	2278		REG_CH_CNT	=0, 8, 0%;
;	2279	
;	2280	!++
;	2281	! COMMON ASCII COUNTED STRINGS USED IN FAO CALLS.
;	2282	!--
;	2283	
;	2284	BIND
;	2285		cs_ascii	= UPLIT ( %ASCIC '!AD'),
;	2286		colon_tab_stg	= UPLIT ( %ASCIC ':  ');
;	2287	
;	2288	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 3-1
; Digital Equipment Corporation
;
;	2289	! The following macros translate addresses to register offsets and
;	2290	! vice versa.
;	2291	!--
;	2292		MACRO
;	2293			this_is_reg (location) =
;     M 2294				(((location) GEQA dbg$gl_runframe [dbg$l_user_r0]) AND
;     M 2295					((location) LEQA dbg$gl_runframe [dbg$l_user_psl]))%,
;	2296	
;	2297			reg_offset (location) =
;     M 2298				(location - dbg$gl_runframe [dbg$l_user_regs]) / %UPVAL%;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 4
; Digital Equipment Corporation
;
;	2299	global routine dbg$out_regname(address) =
;	2300	
;	2301	!++
;	2302	! Functional Description
;	2303	!
;	2304	!	Given an address, see if it falls within the current
;	2305	!  runframe in such a way as one could say that this address
;	2306	!  corresponds to one of the general registers.  If this is
;	2307	!  not the case, we return FALSE.  Otherwise we output the
;	2308	!  name of the indicated register and return TRUE.
;	2309	!
;	2310	! Formal Parameters:
;	2311	!
;	2312	!	address	-the address which we are trying to symbolize
;	2313	!
;	2314	! Implicit Inputs:
;	2315	!
;	2316	!	The format and use of the register table
;	2317	!  which is local to this module.
;	2318	!
;	2319	! Return Value
;	2320	!	TRUE or FALSE.  See above.
;	2321	!
;	2322	! Side Effects:
;	2323	!
;	2324	!	We may output a register name to the current output buffer.
;	2325	!
;	2326	!--
;	2327	BEGIN
;	2328		BIND
;	2329			register_vector = dbg$gl_runframe [ DBG$L_USER_REGS ] : VECTOR;
;	2330		LOCAL
;	2331			reg_index;
;	2332	
;	2333		IF( NOT this_is_reg(.address) )
;	2334		then
;	2335			return(false);
;	2336	
;	2337		reg_index = reg_offset(.address);
;	2338	
;	2339		! Check that the address EXACTLY matches one which
;	2340		! we currently bind to a register name.
;	2341	
;	2342		IF( register_vector[.reg_index] NEQA .address )
;	2343		then
;	2344			return(FALSE);
;	2345	
;	2346		! An exact match has been found.
;	2347		! Output the register name and return
;	2348		! a success status.
;	2349	
;	2350		dbg$fao_put( UPLIT( %ASCIC '!AC' ), register_table[.reg_index, ctd_reg_name ]);
;	2351	
;	2352		return(TRUE);
;	2353	END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 4-1
; Digital Equipment Corporation
;


							    .TITLE  DBGEXA
							    .IDENT  \000077\

							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00000 P.AAA:  .BYTE   2							      ;
					      00001 	    .ASCII  \R0\						      ;
					      00003 	    .BYTE   0							      ;
					      00004 	    .BYTE   2							      ;
					      00005 	    .ASCII  \R1\						      ;
					      00007 	    .BYTE   0							      ;
					      00008 	    .BYTE   2							      ;
					      00009 	    .ASCII  \R2\						      ;
					      0000B 	    .BYTE   0							      ;
					      0000C 	    .BYTE   2							      ;
					      0000D 	    .ASCII  \R3\						      ;
					      0000F 	    .BYTE   0							      ;
					      00010 	    .BYTE   2							      ;
					      00011 	    .ASCII  \R4\						      ;
					      00013 	    .BYTE   0							      ;
					      00014 	    .BYTE   2							      ;
					      00015 	    .ASCII  \R5\						      ;
					      00017 	    .BYTE   0							      ;
					      00018 	    .BYTE   2							      ;
					      00019 	    .ASCII  \R6\						      ;
					      0001B 	    .BYTE   0							      ;
					      0001C 	    .BYTE   2							      ;
					      0001D 	    .ASCII  \R7\						      ;
					      0001F 	    .BYTE   0							      ;
					      00020 	    .BYTE   2							      ;
					      00021 	    .ASCII  \R8\						      ;
					      00023 	    .BYTE   0							      ;
					      00024 	    .BYTE   2							      ;
					      00025 	    .ASCII  \R9\						      ;
					      00027 	    .BYTE   0							      ;
					      00028 	    .BYTE   3							      ;
					      00029 	    .ASCII  \R10\						      ;
					      0002C 	    .BYTE   3							      ;
					      0002D 	    .ASCII  \R11\						      ;
					      00030 	    .BYTE   2							      ;
					      00031 	    .ASCII  \AP\						      ;
					      00033 	    .BYTE   0							      ;
					      00034 	    .BYTE   2							      ;
					      00035 	    .ASCII  \FP\						      ;
					      00037 	    .BYTE   0							      ;
					      00038 	    .BYTE   2							      ;
					      00039 	    .ASCII  \SP\						      ;
					      0003B 	    .BYTE   0							      ;
					      0003C 	    .BYTE   2							      ;
					      0003D 	    .ASCII  \PC\						      ;
					      0003F 	    .BYTE   0							      ;
					      00040 	    .BYTE   3							      ;
					      00041 	    .ASCII  \PSL\						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 4-2
; Digital Equipment Corporation
;
					      00044 P.AAB:  .ASCII  <3>\!AD\						      ;
					      00048 P.AAC:  .ASCII  <3>\:  \						      ;
					      0004C P.AAD:  .ASCII  <3>\!AC\						      ;

						    REGISTER_TABLE=	P.AAA
						    CS_ASCII=		P.AAB
						    COLON_TAB_STG=	P.AAC
							    .GLOBL  DBG$_RST_BEGIN, DBG$FAO_OUT, DBG$GB_LOC_TYPE, DBG$GB_MOD_PTR
							    .GLOBL  DBG$CP_OUT_STR, DBG$GL_CONTEXT, DBG$GL_ASCI_LEN
							    .GLOBL  DBG$GL_BUF_SIZ, DBG$GL_HEAD_LST, DBG$GL_LAST_LOC
							    .GLOBL  DBG$GL_LAST_VAL, DBG$GL_NEXT_LOC, DBG$GL_RUNFRAME
							    .GLOBL  DBG$PRINT_PATH, DBG$ADD_NT_2_PV, DBG$CNV_D_TO_F
							    .GLOBL  DBG$CNV_D_TO_L, DBG$CNV_F_TO_D, DBG$CNV_F_TO_L
							    .GLOBL  DBG$CNV_L_TO_D, DBG$CNV_L_TO_F, DBG$FAO_PUT, DBG$INS_DECODE
							    .GLOBL  DBG$INS_ENCODE, DBG$OUT_PUT, DBG$OUT_NUM_VAL, DBG$OUT_SYM_VAL
							    .GLOBL  DBG$OUT_TYP_VAL, DBG$READ_ACCESS, DBG$VAL_TO_SAT
							    .GLOBL  DBG$GET_BOUNDS, DBG$WRITE_MEM, DBG$SYMBOL_VALU
							    .GLOBL  DBG$GET_NXT_LVT
							    .WEAK   ACCESS_CHECK

							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0804 00000 	    .ENTRY  DBG$OUT_REGNAME, Save R2,R11			      ; 2299
		         5B 00000000G  EF  9E 00002 	    MOVAB   DBG$GL_RUNFRAME, R11				      ;
	   51	         6B	       04  C1 00009 	    ADDL3   #4, DBG$GL_RUNFRAME, R1				      ; 2329
		         52	       51  D0 0000D 	    MOVL    R1, R2						      ; 2327
		         51	  04   AC  D1 00010 	    CMPL    ADDRESS, R1						      ; 2333
				       38  1F 00014 	    BLSSU   1$							      ;
	   50	         6B 00000044   8F  C1 00016 	    ADDL3   #68, DBG$GL_RUNFRAME, R0				      ;
		         50	  04   AC  D1 0001E 	    CMPL    ADDRESS, R0						      ;
				       2A  1A 00022 	    BGTRU   1$							      ;
	   50	    04   AC	       51  C3 00024 	    SUBL3   R1, ADDRESS, R0					      ; 2337
		         50	       04  C6 00029 	    DIVL2   #4, REG_INDEX					      ;
		         51	     6240  DE 0002C 	    MOVAL   (R2)[REG_INDEX], R1					      ; 2342
		    04   AC	       51  D1 00030 	    CMPL    R1, ADDRESS						      ;
				       18  12 00034 	    BNEQ    1$							      ;
			    00000000'EF40  DF 00036 	    PUSHAL  REGISTER_TABLE[REG_INDEX]				      ; 2350
			    00000000'  EF  9F 0003D 	    PUSHAB  P.AAD						      ;
	      00000000G  EF	       02  FB 00043 	    CALLS   #2, DBG$FAO_PUT					      ;
		         50	       01  D0 0004A 	    MOVL    #1, R0						      ; 2352
					   04 0004D 	    RET     							      ;
				       50  D4 0004E 1$:     CLRL    R0							      ; 2299
					   04 00050 	    RET     							      ;

; Routine Size:  81 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5
; Digital Equipment Corporation
;
;	2354	GLOBAL ROUTINE dbg$deposit_cmd : NOVALUE =
;	2355	
;	2356	!++
;	2357	! FUNCTIONAL DESCRIPTION:
;	2358	!	The command argument list is made up of entries that are
;	2359	!	each five longwords long.  The first is a forward link to the
;	2360	!	next entry. The second longword in the first entry in the list
;	2361	!	is the address into which some value(s) is (are) to be deposited.
;	2362	!	The third longword is unused, and the fourth (the TYPE1 field)
;	2363	!	applies ONLY to the first deposit in a list.  The second longword
;	2364	!	in the second and subsequent entries are the values to be deposited,
;	2365	!	and their corresponding TYPE1 fields apply only to them.
;	2366	!	The first value goes into the specified location; the second into
;	2367	!	that location plus the current mode_length, etc.
;	2368	!
;	2369	!	For instruction deposits, the increment is the length of each
;	2370	!	subsequent deposited instruction. The second longword contains
;	2371	!	the address of a counted byte stream that is to be translated
;	2372	!	into a binary instruction and then deposited.
;	2373	!
;	2374	! CALLING SEQUENCE:
;	2375	!	dbg$deposit_cmd ()
;	2376	!
;	2377	! INPUTS:
;	2378	!	none
;	2379	!
;	2380	! IMPLICIT INPUTS:
;	2381	!	THE HEAD OF THE LINKED LIST and the current mode
;	2382	!
;	2383	! OUTPUTS:
;	2384	!	none
;	2385	!
;	2386	! IMPLICIT OUTPUTS:
;	2387	!	The values dbg$gl_last_loc, dbg$gl_last_val, and dbg$gl_next_loc
;	2388	!	are set after each deposit is done.
;	2389	!
;	2390	! ROUTINE VALUE:
;	2391	!	NOVALUE
;	2392	!
;	2393	! SIDE EFFECTS:
;	2394	!	THE SPECIFIED ADDRESSES HAVE THEIR VALUES CHANGED.
;	2395	!	If a failure in a write occurs, the routine returns immediately.
;	2396	!--
;	2397	
;	2398	BEGIN
;	2399	
;	2400		LITERAL
;	2401			max_inst_len	= 80;		! maximum number of binary bytes in an instruction
;	2402	
;	2403		LOCAL
;	2404			deposit_nt_ptr : REF NT_RECORD,
;	2405			deposit_loc,
;	2406			pointer,
;	2407			value;				! sign or zero extended value to deposit.
;	2408	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-1
; Digital Equipment Corporation
;
;	2409	
;	2410		BIND
;	2411			register_vector	= dbg$gl_runframe [dbg$l_user_regs] : VECTOR;
;	2412	
;	2413		pointer = .dbg$gl_head_lst;
;	2414		IF (.pointer EQLA 0) OR (.list_elem_flink(.pointer) EQLA 0)
;	2415		THEN
;	2416			BEGIN
;	2417			SIGNAL (dbg$_parseerr);
;	2418			RETURN
;	2419			END;
;	2420	
;	2421		deposit_loc = .list_elem_exp1 (.pointer);
;	2422		deposit_nt_ptr = .list_elem_ntptr (.pointer);
;	2423	
;	2424	%IF dbg_exa OR dbg_exa7
;     L 2425	%THEN
;     U 2426		$fao_tt_out ('depositing to !XL, nt_ptr = !XW',
;     U 2427			.deposit_loc,.deposit_nt_ptr);
;     U 2428	%FI
;	2429		! Guard against an attempt to write into our own
;	2430		! dynamic storage, as in a deposit to 'string'.  The
;	2431		! reason for this is that we allocate temporary storage
;	2432		! for 'string', bind 'string' to a lvalue, but
;	2433		! then fault when trying to delete this temp storage
;	2434		! because the initial count byte (for string) has been
;	2435		! overwritten by the deposit itself.
;	2436	
;	2437		IF( .list_elem_store(.pointer) NEQA 0 )
;	2438		THEN
;	2439			BEGIN
;	2440			LOCAL
;	2441				cs_ptr : ref vector[,byte],
;	2442				lhs_stg_desc : block[8,byte];
;	2443	
;	2444			! The temporary storage we would try to write into
;	2445			! is a counted string.  Build a string descriptor
;	2446			! for this string and produce a message which tells
;	2447			! the user that we don't allow this kind of deposit.
;	2448	
;	2449			cs_ptr = .list_elem_store(.pointer);
;	2450			lhs_stg_desc[DSC$A_POINTER] = cs_ptr[1];
;	2451			lhs_stg_desc[DSC$W_LENGTH] = .cs_ptr[0];
;	2452	
;	2453			SIGNAL( DBG$_SYNTAX, 1, lhs_stg_desc);
;	2454			! no return
;	2455			END;
;	2456	
;	2457		!++
;	2458		! Deposit into a normal memory location, or to
;	2459		! a memory location which correspoinds to where we
;	2460		! are currently storing one of the general registers.
;	2461		!--
;	2462	
;	2463		REPEAT

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-2
; Digital Equipment Corporation
;
;	2464			BEGIN
;	2465			LOCAL
;	2466				instruc_buf: VECTOR [max_inst_len, BYTE];
;	2467		
;	2468			! The next element in the command arg list always
;	2469			! specifies the thing which we are to deposit.
;	2470	
;	2471			pointer = .list_elem_flink (.pointer);
;	2472	
;	2473			! Check for deposits to the PC and force a clear
;	2474			! of the FPD bit in the PSL if this is the case.
;	2475	
;	2476			IF( .DEPOSIT_LOC EQLA DBG$GL_RUNFRAME[ DBG$L_USER_PC ] )
;	2477			THEN
;	2478				BEGIN
;	2479	%if dbg_exa
;     L 2480	%then
;     U 2481				$FAO_TT_OUT('dep to PC, PSL = !XL',
;     U 2482					.DBG$GL_RUNFRAME[ DBG$L_USER_PSL ]);
;     U 2483	%FI
;	2484				dbg$gl_runframe[ dbg$l_user_psl ] = %X'f7ffffff' AND
;	2485							.DBG$GL_RUNFRAME[ DBG$L_USER_PSL ];
;	2486				END;
;	2487			!+
;	2488			! Deposits of INSTRUCTION, ASCII, and 'otherwise' are
;	2489			! each somewhat different.  The INSTRUCTION case is signaled
;	2490			! by instruction mode being on, and the STORE field
;	2491			! of the command arg record being the same as the EXP1
;	2492			! field.  The ASCII case is signaled by the STORE field
;	2493			! of the command arg record being the same as the EXP1
;	2494			! field.  The latter check sees if auxiliary storage
;	2495			! is associated with the arg - which is the case for
;	2496			! ascii and instruction strings because the parser
;	2497			! allocates free storage to hold the quoted string in
;	2498			! each case.
;	2499			!-
;	2500			IF .dbg$gb_mod_ptr[mode_instruc]
;	2501			AND
;	2502			    (.list_elem_store(.pointer) EQLA .list_elem_exp1(.pointer))
;	2503			AND
;	2504			    (.list_elem_store(.pointer) NEQ 0 )
;	2505			THEN
;	2506				BEGIN
;	2507	
;	2508				!++
;	2509				! This is a symbolic instruction to be
;	2510				! deposited. It is currently in the form of
;	2511				! a counted ASCII string that must be translated
;	2512				! into binary form. The call to INS_ENCODE needs
;	2513				! the address into which the instruction is being
;	2514				! deposited in order to resolve branches
;	2515				! correctly.
;	2516				!--
;	2517				IF NOT dbg$ins_encode (.list_elem_exp1(.pointer),
;	2518							instruc_buf, .deposit_loc)

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-3
; Digital Equipment Corporation
;
;	2519				THEN
;	2520					BEGIN
;	2521	
;	2522					!++
;	2523					! This instruction is not valid.
;	2524					!--
;	2525					SIGNAL (dbg$_nodecode);
;	2526					RETURN
;	2527					END;
;	2528				IF NOT dbg$write_mem (.deposit_loc, instruc_buf[1],
;	2529							.instruc_buf[0])
;	2530				THEN
;	2531					BEGIN
;	2532					SIGNAL (dbg$_noaccessw, 1, .deposit_loc);
;	2533					! no return
;	2534					RETURN
;	2535					END;
;	2536	%IF dbg_exa1
;     L 2537	%THEN
;     U 2538				!++
;     U 2539				! For diagnostic purposes only, display the
;     U 2540				! new contents of the memory location on the output
;     U 2541				! device.
;     U 2542				!--
;     U 2543					BEGIN
;     U 2544	
;     U 2545					LOCAL
;     U 2546						out_buffer : VECTOR [max_inst_len, BYTE];
;     U 2547	
;     U 2548					dbg$cp_out_str = out_buffer + 1;
;     U 2549					dbg$gl_buf_siz = 0;
;     U 2550					dbg$fao_put (UPLIT (%ASCIC '!/!_'));
;     U 2551					INCR count FROM 1 TO .instruc_buf [0] DO
;     U 2552							dbg$fao_put (UPLIT (%ASCIC '!XB '), .instruc_buf [.count]);
;     U 2553					dbg$out_put (out_buffer);
;     U 2554					END;
;     U 2555	%FI
;	2556				! The 'next location' pseudo always gets the
;	2557				! address AFTER the instruction we just deposited.
;	2558	
;	2559				dbg$gl_next_loc = .deposit_loc + .instruc_buf [0];
;	2560				END
;	2561			ELSE
;	2562			    !+
;	2563			    ! ASCII deposits are somewhat special because
;	2564			    ! the length of the variable is passed in dbg$gl_asci_len.
;	2565			    ! If auxiliary storage has been allocated for the string
;	2566			    ! then this must be an ascii deposit.
;	2567			    !-
;	2568			    IF (.list_elem_store(.pointer) EQLA .list_elem_exp1(.pointer))
;	2569			    AND
;	2570				(.list_elem_store(.pointer) NEQ 0 )
;	2571			    THEN
;	2572				BEGIN
;	2573				LOCAL

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-4
; Digital Equipment Corporation
;
;	2574							! The # of chars from the given
;	2575					use_size,	! string which we deposit.
;	2576					size,		! The # of chars actually deposited.
;	2577	
;	2578							! The command arg list contains a
;	2579							! pointer to the counted ASCII string.
;	2580					cs_ptr : ref vector[,byte];
;	2581	
;	2582				!+
;	2583				! Pick up a pointer to the counted ASCII
;	2584				! string built by the LEX.
;	2585				!-
;	2586				cs_ptr = .list_elem_exp1(.pointer);
;	2587	%if dbg_exa7
;     L 2588	%then
;     U 2589				$fao_tt_out('dep: nt_ptr=!XW, ascii (!SL) is "!AC".',
;     U 2590					.deposit_nt_ptr,.cs_ptr[0],cs_ptr[0]);
;     U 2591	%FI
;	2592				!+
;	2593				! The number of bytes deposited is the length of
;	2594				! the ascii string if no type information is
;	2595				! available.  Otherwise we see that the type
;	2596				! is ASCII, and use the length provided in
;	2597				! dbg$gl_asci_len.
;	2598				!-
;	2599				use_size = (size = .cs_ptr[0]);
;	2600				IF( .deposit_nt_ptr NEQ 0 )
;	2601				THEN
;	2602					IF( .deposit_nt_ptr[NT_TYPE] EQL DSC$K_DTYPE_T )
;	2603					THEN
;	2604					    size = .dbg$gl_asci_len;
;	2605	%if dbg_exa7
;     L 2606	%then
;     U 2607				$fao_tt_out('string length = !SL, using length = !SL.',
;     U 2608					.cs_ptr[0],.size);
;     U 2609	%FI
;	2610				! Take care of string-length and CHARACTER variable
;	2611				! length discrepancies.
;	2612	
;	2613				IF( .size LSS .cs_ptr[0] )
;	2614				then
;	2615					BEGIN
;	2616	
;	2617					! case: DBG>D short = 'long string'
;	2618					! Not much to do here except warn the user
;	2619					! that we are depositing less than what he
;	2620					! said in the quoted string.
;	2621	
;	2622					SIGNAL(DBG$_STGTRUNC);
;	2623					use_size = .size;
;	2624					END;
;	2625	
;	2626				IF( .size GTR .cs_ptr[0] )
;	2627				THEN
;	2628					BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-5
; Digital Equipment Corporation
;
;	2629	
;	2630					! case: DBG>D long = 'short'
;	2631					! Here we blank-fill the indicated destination
;	2632					! before copying in the given short string.
;	2633					! Fill with any value using write_mem so that
;	2634					! the needed protection check is done.  Then
;	2635					! fill properly with blanks.
;	2636	
;	2637					IF NOT dbg$write_mem (.deposit_loc, cs_ptr[1], .size )
;	2638					THEN
;	2639						SIGNAL (dbg$_noaccessw, 1, .deposit_loc);
;	2640						! no return
;	2641	
;	2642					ch$fill( %C' ', .size, .deposit_loc );
;	2643	
;	2644					! The number of characters actually deposited is
;	2645					! the length of the (sub)string, even though the
;	2646					! given quoted string was not that long.  Having
;	2647					! put in the blanks, now we only re-deposit
;	2648					! the string given in the first place.
;	2649	
;	2650					use_size = .cs_ptr[0];
;	2651					END;
;	2652	
;	2653				! Actually do the deposit.
;	2654	
;	2655				IF NOT dbg$write_mem (.deposit_loc, cs_ptr[1], .use_size )
;	2656				THEN
;	2657					BEGIN
;	2658					SIGNAL (dbg$_noaccessw, 1, .deposit_loc);
;	2659					! no return
;	2660					RETURN
;	2661					END;
;	2662	
;	2663				! Update our idea of the next location.  It is
;	2664				! the byte immediately following the deposited string.
;	2665	
;	2666				dbg$gl_next_loc = .deposit_loc + .size;
;	2667				END
;	2668			    ELSE
;	2669				BEGIN
;	2670				!+
;	2671				! Normal, non-ascii and non-instruction, deposits
;	2672				! to memory locations.  If we get here it is
;	2673				! because this is a numerical deposit.
;	2674				!-
;	2675	%if dbg_exa
;     L 2676	%then
;     U 2677				$fao_tt_out('normal deposit: exp1=!XL, length=!SL.',
;     U 2678					.list_elem_exp1(.pointer),.dbg$gb_mod_ptr[MODE_LENGTH]);
;     U 2679	%FI
;	2680				VALUE = (IF (.LIST_ELEM_EXP1(.POINTER) LSS 0)
;	2681					THEN .(LIST_ELEM_EXP1(.POINTER))<0,.DBG$GB_MOD_PTR[MODE_LENGTH]*8,1>
;	2682					ELSE .(LIST_ELEM_EXP1(.POINTER))<0,.DBG$GB_MOD_PTR[MODE_LENGTH]*8,0>);
;	2683				IF (.VALUE NEQ .LIST_ELEM_EXP1(.POINTER))

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-6
; Digital Equipment Corporation
;
;	2684				THEN
;	2685					BEGIN
;	2686					SIGNAL(DBG$_NUMTRUNC);
;	2687					END;
;	2688				IF NOT symbol_deposit (.deposit_loc,
;	2689						list_elem_exp1(.pointer),
;	2690						.deposit_nt_ptr)
;	2691				THEN
;	2692				    BEGIN
;	2693				    IF NOT dbg$write_mem (.deposit_loc, list_elem_exp1(.pointer),
;	2694							.dbg$gb_mod_ptr[mode_length])
;	2695				    THEN
;	2696					BEGIN
;	2697					SIGNAL (dbg$_noaccessw, 1, .deposit_loc);
;	2698					RETURN
;	2699					END
;	2700				    ELSE
;	2701					BEGIN
;	2702					dbg$gl_next_loc = .deposit_loc + .dbg$gb_mod_ptr[mode_length];
;	2703	
;	2704	%IF dbg_exa1
;     L 2705	%THEN
;     U 2706					$fao_tt_out ('!_!XL', .list_elem_exp1 (.pointer));
;     U 2707	%FI
;	2708	
;	2709					END;
;	2710				    END;
;	2711	
;	2712				! Before looping back to process multiple-operand
;	2713				! deposits, wipe out the 'hint' NT_PTR which corresponds
;	2714				! to the destination symbol, because it is only
;	2715				! to be believed for the first deposit in a list.
;	2716	
;	2717				deposit_nt_ptr = 0;
;	2718				END;
;	2719	
;	2720			!++
;	2721			! Finished with deposit.  Set the value of
;	2722			! the last-value-displayed pseudo.
;	2723			!--
;	2724			dbg$gl_last_loc = .deposit_loc;
;	2725	
;	2726			!++
;	2727			! If there is another value to deposit, then
;	2728			! update to the next destination address.
;	2729			!--
;	2730			IF .list_elem_flink (.pointer) EQLA 0
;	2731			THEN RETURN
;	2732			ELSE deposit_loc = .dbg$gl_next_loc;
;	2733			END;
;	2734	END;





; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-7
; Digital Equipment Corporation
;

					 0FFC 00051 	    .ENTRY  DBG$DEPOSIT_CMD, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 2354
		         5E	  AC   AE  9E 00053 	    MOVAB   -84(SP), SP						      ;
	   50 00000000G  EF	       04  C1 00057 	    ADDL3   #4, DBG$GL_RUNFRAME, R0				      ; 2411
		         56 00000000G  EF  D0 0005F 	    MOVL    DBG$GL_HEAD_LST, POINTER				      ; 2413
				       04  13 00066 	    BEQL    1$							      ; 2414
				       66  D5 00068 	    TSTL    (POINTER)						      ;
				       08  12 0006A 	    BNEQ    2$							      ;
			    00028248   8F  DD 0006C 1$:     PUSHL   #164424						      ; 2417
				       75  11 00072 	    BRB     5$							      ;
		         58	  04   A6  D0 00074 2$:     MOVL    4(POINTER), DEPOSIT_LOC				      ; 2421
		         5A	  10   A6  3C 00078 	    MOVZWL  16(POINTER), DEPOSIT_NT_PTR				      ; 2422
				  14   A6  D5 0007C 	    TSTL    20(POINTER)						      ; 2437
				       1F  13 0007F 	    BEQL    3$							      ;
		         50	  14   A6  D0 00081 	    MOVL    20(POINTER), CS_PTR					      ; 2449
      50   AE	         50	       01  C1 00085 	    ADDL3   #1, CS_PTR, LHS_STG_DESC+4				      ; 2450
		    4C   AE	       60  9B 0008A 	    MOVZBW  (CS_PTR), LHS_STG_DESC				      ; 2451
				  4C   AE  9F 0008E 	    PUSHAB  LHS_STG_DESC					      ; 2453
				       01  DD 00091 	    PUSHL   #1							      ;
			    000282E8   8F  DD 00093 	    PUSHL   #164584						      ;
	      00000000G  00	       03  FB 00099 	    CALLS   #3, LIB$SIGNAL					      ;
		         56	       66  D0 000A0 3$:     MOVL    (POINTER), POINTER					      ; 2471
		         50 00000000G  EF  D0 000A3 	    MOVL    DBG$GL_RUNFRAME, R0					      ; 2476
		         51	  40   A0  9E 000AA 	    MOVAB   64(R0), R1						      ;
		         51	       58  D1 000AE 	    CMPL    DEPOSIT_LOC, R1					      ;
				       04  12 000B1 	    BNEQ    4$							      ;
		    47   A0	       08  8A 000B3 	    BICB2   #8, 71(R0)						      ; 2484
		         53	  04   A6  9E 000B7 4$:     MOVAB   4(POINTER), R3					      ; 2517
		         52 00000000G  EF  D0 000BB 	    MOVL    DBG$GB_MOD_PTR, R2					      ; 2500
		         50	  03   A2  E9 000C2 	    BLBC    3(R2), 8$						      ;
		    04   A6	  14   A6  D1 000C6 	    CMPL    20(POINTER), 4(POINTER)				      ; 2502
				       49  12 000CB 	    BNEQ    8$							      ;
				  14   A6  D5 000CD 	    TSTL    20(POINTER)						      ; 2504
				       44  13 000D0 	    BEQL    8$							      ;
				       58  DD 000D2 	    PUSHL   DEPOSIT_LOC						      ; 2517
				  08   AE  9F 000D4 	    PUSHAB  INSTRUC_BUF						      ;
				       63  DD 000D7 	    PUSHL   (R3)						      ;
	      00000000G  EF	       03  FB 000D9 	    CALLS   #3, DBG$INS_ENCODE					      ;
		         0E	       50  E8 000E0 	    BLBS    R0, 6$						      ;
			    000281E8   8F  DD 000E3 	    PUSHL   #164328						      ; 2525
	      00000000G  00	       01  FB 000E9 5$:     CALLS   #1, LIB$SIGNAL					      ;
					   04 000F0 	    RET     							      ; 2526
		         7E	  04   AE  9A 000F1 6$:     MOVZBL  INSTRUC_BUF, -(SP)					      ; 2528
				  09   AE  9F 000F5 	    PUSHAB  INSTRUC_BUF+1					      ;
				       58  DD 000F8 	    PUSHL   DEPOSIT_LOC						      ;
	      00000000G  EF	       03  FB 000FA 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         03	       50  E8 00101 	    BLBS    R0, 7$						      ;
				     00F5  31 00104 	    BRW     19$							      ;
		         50	  04   AE  9A 00107 7$:     MOVZBL  INSTRUC_BUF, R0					      ; 2559
00000000G  EF	         58	       50  C1 0010B 	    ADDL3   R0, DEPOSIT_LOC, DBG$GL_NEXT_LOC			      ;
				     010D  31 00113 	    BRW     22$							      ; 2500
		         63	  14   A6  D1 00116 8$:     CMPL    20(POINTER), (R3)					      ; 2568
				       03  13 0011A 	    BEQL    10$							      ;
				     0086  31 0011C 9$:     BRW     15$							      ;
				  14   A6  D5 0011F 10$:    TSTL    20(POINTER)						      ; 2570

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-8
; Digital Equipment Corporation
;
				       F8  13 00122 	    BEQL    9$							      ;
		         57	       63  D0 00124 	    MOVL    (R3), CS_PTR					      ; 2586
		         59	       67  9A 00127 	    MOVZBL  (CS_PTR), SIZE					      ; 2599
		         5B	       59  D0 0012A 	    MOVL    SIZE, USE_SIZE					      ;
				       5A  D5 0012D 	    TSTL    DEPOSIT_NT_PTR					      ; 2600
				       10  13 0012F 	    BEQL    11$							      ;
		         0E 00000000G  EA  91 00131 	    CMPB    DBG$_RST_BEGIN+2(DEPOSIT_NT_PTR), #14		      ; 2602
				       07  12 00138 	    BNEQ    11$							      ;
		         59 00000000G  EF  D0 0013A 	    MOVL    DBG$GL_ASCI_LEN, SIZE				      ; 2604
	   67	         08	       00  ED 00141 11$:    CMPZV   #0, #8, (CS_PTR), SIZE				      ; 2613
				       59     00145									      ;
				       10  15 00146 	    BLEQ    12$							      ;
			    00028063   8F  DD 00148 	    PUSHL   #163939						      ; 2622
	      00000000G  00	       01  FB 0014E 	    CALLS   #1, LIB$SIGNAL					      ;
		         5B	       59  D0 00155 	    MOVL    SIZE, USE_SIZE					      ; 2623
	   67	         08	       00  ED 00158 12$:    CMPZV   #0, #8, (CS_PTR), SIZE				      ; 2626
				       59     0015C									      ;
				       2B  18 0015D 	    BGEQ    14$							      ;
				       59  DD 0015F 	    PUSHL   SIZE						      ; 2637
				  01   A7  9F 00161 	    PUSHAB  1(CS_PTR)						      ;
				       58  DD 00164 	    PUSHL   DEPOSIT_LOC						      ;
	      00000000G  EF	       03  FB 00166 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         11	       50  E8 0016D 	    BLBS    R0, 13$						      ;
				       58  DD 00170 	    PUSHL   DEPOSIT_LOC						      ; 2639
				       01  DD 00172 	    PUSHL   #1							      ;
			    000282B0   8F  DD 00174 	    PUSHL   #164528						      ;
	      00000000G  00	       03  FB 0017A 	    CALLS   #3, LIB$SIGNAL					      ;
	   20	         6E	       00  2C 00181 13$:    MOVC5   #0, (SP), #32, SIZE, (DEPOSIT_LOC)			      ; 2642
		         68	       59     00185									      ;
		         5B	       67  9A 00187 	    MOVZBL  (CS_PTR), USE_SIZE					      ; 2650
				       5B  DD 0018A 14$:    PUSHL   USE_SIZE						      ; 2655
				  01   A7  9F 0018C 	    PUSHAB  1(CS_PTR)						      ;
				       58  DD 0018F 	    PUSHL   DEPOSIT_LOC						      ;
	      00000000G  EF	       03  FB 00191 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         61	       50  E9 00198 	    BLBC    R0, 19$						      ;
00000000G  EF	         58	       59  C1 0019B 	    ADDL3   SIZE, DEPOSIT_LOC, DBG$GL_NEXT_LOC			      ; 2666
				       7E  11 001A3 	    BRB     22$							      ; 2568
				       63  D5 001A5 15$:    TSTL    (R3)						      ; 2680
				       0E  18 001A7 	    BGEQ    16$							      ;
		         50	  01   A2  9A 001A9 	    MOVZBL  1(R2), R0						      ; 2681
		         50	       08  C4 001AD 	    MULL2   #8, R0						      ;
	   63	         50	       00  EE 001B0 	    EXTV    #0, R0, (R3), VALUE					      ;
				       6E     001B4									      ;
				       0C  11 001B5 	    BRB     17$							      ; 2680
		         50	  01   A2  9A 001B7 16$:    MOVZBL  1(R2), R0						      ; 2682
		         50	       08  C4 001BB 	    MULL2   #8, R0						      ;
	   63	         50	       00  EF 001BE 	    EXTZV   #0, R0, (R3), VALUE					      ;
				       6E     001C2									      ;
		         63	       6E  D1 001C3 17$:    CMPL    VALUE, (R3)						      ; 2683
				       0D  13 001C6 	    BEQL    18$							      ;
			    0002805B   8F  DD 001C8 	    PUSHL   #163931						      ; 2686
	      00000000G  00	       01  FB 001CE 	    CALLS   #1, LIB$SIGNAL					      ;
				0408   8F  BB 001D5 18$:    PUSHR   #^M<R3,R10>						      ; 2688
				       58  DD 001D9 	    PUSHL   DEPOSIT_LOC						      ;
		  0000V  CF	       03  FB 001DB 	    CALLS   #3, SYMBOL_DEPOSIT					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 5-9
; Digital Equipment Corporation
;
		         3E	       50  E8 001E0 	    BLBS    R0, 21$						      ;
		         50 00000000G  EF  D0 001E3 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 2694
		         7E	  01   A0  9A 001EA 	    MOVZBL  1(R0), -(SP)					      ; 2693
				       53  DD 001EE 	    PUSHL   R3							      ;
				       58  DD 001F0 	    PUSHL   DEPOSIT_LOC						      ;
	      00000000G  EF	       03  FB 001F2 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         12	       50  E8 001F9 	    BLBS    R0, 20$						      ;
				       58  DD 001FC 19$:    PUSHL   DEPOSIT_LOC						      ; 2697
				       01  DD 001FE 	    PUSHL   #1							      ;
			    000282B0   8F  DD 00200 	    PUSHL   #164528						      ;
	      00000000G  00	       03  FB 00206 	    CALLS   #3, LIB$SIGNAL					      ;
					   04 0020D 	    RET     							      ; 2698
		         50 00000000G  EF  D0 0020E 20$:    MOVL    DBG$GB_MOD_PTR, R0					      ; 2702
		         51	  01   A0  9A 00215 	    MOVZBL  1(R0), R1						      ;
00000000G  EF	         58	       51  C1 00219 	    ADDL3   R1, DEPOSIT_LOC, DBG$GL_NEXT_LOC			      ;
				       5A  D4 00221 21$:    CLRL    DEPOSIT_NT_PTR					      ; 2717
	      00000000G  EF	       58  D0 00223 22$:    MOVL    DEPOSIT_LOC, DBG$GL_LAST_LOC			      ; 2724
				       66  D5 0022A 	    TSTL    (POINTER)						      ; 2730
				       0A  13 0022C 	    BEQL    23$							      ;
		         58 00000000G  EF  D0 0022E 	    MOVL    DBG$GL_NEXT_LOC, DEPOSIT_LOC			      ; 2732
				     FE68  31 00235 	    BRW     3$							      ; 2455
					   04 00238 23$:    RET     							      ; 2354

; Routine Size:  488 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 6
; Digital Equipment Corporation
;
;	2735	GLOBAL ROUTINE dbg$examine_cmd : NOVALUE =
;	2736	
;	2737	!++
;	2738	! FUNCTIONAL DESCRIPTION:
;	2739	!	EXAMINES A LIST OF EXPRESSIONS
;	2740	!
;	2741	! INPUTS:
;	2742	!	NONE
;	2743	!
;	2744	! IMPLICIT INPUTS:
;	2745	!	THE ADDRESS OF THE FIRST ELEMENT OF A LIST OF EXPRESSIONS.
;	2746	!	THE LAST EXPRESSION EXAMINED, AND THE NEXT LOGICAL EXPRESSION
;	2747	!	TO EXAMINE.
;	2748	!
;	2749	! OUTPUTS:
;	2750	!	NONE
;	2751	!
;	2752	! IMPLICIT OUTPUTS:
;	2753	!	NEW VALUES FOR LAST AND NEXT location, AND LAST VALUE
;	2754	!
;	2755	! ROUTINE VALUE:
;	2756	!	NOVALUE
;	2757	!
;	2758	! SIDE EFFECTS:
;	2759	!	THE VALUES OF VARIOUS EXPRESSIONS ARE OUTPUT TO THE TERMINAL
;	2760	!	If an error occurs, the routine returns without further
;	2761	!	processing except to output an error message to the output
;	2762	!	device.
;	2763	!--
;	2764	
;	2765		BEGIN
;	2766	
;	2767		LOCAL
;	2768			pointer;
;	2769	
;	2770	%IF dbg_exa
;     L 2771	%THEN
;     U 2772		$fao_tt_out ('examining');
;     U 2773	%FI
;	2774	
;	2775		pointer = .dbg$gl_head_lst;
;	2776		IF .pointer EQLA 0
;	2777		THEN
;	2778			BEGIN
;	2779	
;	2780			!++
;	2781			! No location was specified.  Examine the next location
;	2782			! in sequence, and don't try to pass on any
;	2783			! indication of how to resymbolize the location.
;	2784			!--
;	2785			output_mem_loc(.dbg$gl_next_loc, 0, 0);
;	2786			END
;	2787		ELSE DO
;	2788			BEGIN
;	2789	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 6-1
; Digital Equipment Corporation
;
;	2790			LOCAL
;	2791				last_loc;
;	2792	
;	2793			!++
;	2794			! Pick up the next value which we will try to
;	2795			! display and copy it into last_loc.
;	2796			!--
;	2797			last_loc = .list_elem_exp1 (.pointer);
;	2798	
;	2799			!++
;	2800			! If the end range argument is null, then make it the
;	2801			! same as the start range argument so that only one
;	2802			! location will be displayed.
;	2803			!--
;	2804			IF .list_elem_exp2 (.pointer) EQLA 0
;	2805			THEN list_elem_exp2 (.pointer) = .list_elem_exp1 (.pointer);
;	2806	
;	2807			!++
;	2808			! Check for range reversal.
;	2809			!--
;	2810			IF( .list_elem_exp2(.pointer) LSSA .list_elem_exp1(.pointer) )
;	2811			THEN
;	2812				BEGIN
;	2813				SIGNAL (dbg$_exarange);
;	2814				RETURN
;	2815				END;
;	2816	
;	2817			! Now output each location in the range.
;	2818	
;	2819			WHILE (.last_loc LEQA .list_elem_exp2 (.pointer))
;	2820				DO
;	2821				BEGIN
;	2822				LOCAL
;	2823				    type,
;	2824				    nt_ptr : REF NT_RECORD;
;	2825				!+
;	2826				! The NTPTR field in the command arg list contains
;	2827				! the NT_PTR which the symbols came from in
;	2828				! the first place.  Extract this pointer and pass it
;	2829				! on to OUTPUT_MEM_LOC
;	2830				!-
;	2831				nt_ptr = .list_elem_ntptr(.pointer);
;	2832				IF .nt_ptr NEQ 0
;	2833				THEN
;	2834				    type = .nt_ptr[nt_type]
;	2835				ELSE
;	2836				    type = 0;
;	2837				IF NOT output_mem_loc(.last_loc, .nt_ptr, .type)
;	2838				THEN RETURN;
;	2839				last_loc = .dbg$gl_next_loc;
;	2840				END;
;	2841	
;	2842			END
;	2843		UNTIL (pointer = .list_elem_flink (.pointer)) EQLA 0;
;	2844		END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 6-2
; Digital Equipment Corporation
;





					 080C 00239 	    .ENTRY  DBG$EXAMINE_CMD, Save R2,R3,R11			      ; 2735
		         5B 00000000G  EF  9E 0023B 	    MOVAB   DBG$GL_NEXT_LOC, R11				      ;
		         52 00000000G  EF  D0 00242 	    MOVL    DBG$GL_HEAD_LST, POINTER				      ; 2775
				       0A  12 00249 	    BNEQ    1$							      ; 2776
				       7E  7C 0024B 	    CLRQ    -(SP)						      ; 2785
				       6B  DD 0024D 	    PUSHL   DBG$GL_NEXT_LOC					      ;
		  0000V  CF	       03  FB 0024F 	    CALLS   #3, OUTPUT_MEM_LOC					      ;
					   04 00254 	    RET     							      ; 2776
		         53	  04   A2  D0 00255 1$:     MOVL    4(POINTER), LAST_LOC				      ; 2797
				  08   A2  D5 00259 	    TSTL    8(POINTER)						      ; 2804
				       05  12 0025C 	    BNEQ    2$							      ;
		    08   A2	  04   A2  D0 0025E 	    MOVL    4(POINTER), 8(POINTER)				      ; 2805
		    04   A2	  08   A2  D1 00263 2$:     CMPL    8(POINTER), 4(POINTER)				      ; 2810
				       0E  1E 00268 	    BGEQU   3$							      ;
			    000281A8   8F  DD 0026A 	    PUSHL   #164264						      ; 2813
	      00000000G  00	       01  FB 00270 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 00277 	    RET     							      ; 2814
		    08   A2	       53  D1 00278 3$:     CMPL    LAST_LOC, 8(POINTER)				      ; 2819
				       22  1A 0027C 	    BGTRU   6$							      ;
		         50	  10   A2  3C 0027E 	    MOVZWL  16(POINTER), NT_PTR					      ; 2831
				       09  13 00282 	    BEQL    4$							      ; 2832
		         51 00000000G  E0  9A 00284 	    MOVZBL  DBG$_RST_BEGIN+2(NT_PTR), TYPE			      ; 2834
				       02  11 0028B 	    BRB     5$							      ; 2832
				       51  D4 0028D 4$:     CLRL    TYPE						      ; 2836
				       03  BB 0028F 5$:     PUSHR   #^M<R0,R1>						      ; 2837
				       53  DD 00291 	    PUSHL   LAST_LOC						      ;
		  0000V  CF	       03  FB 00293 	    CALLS   #3, OUTPUT_MEM_LOC					      ;
		         0A	       50  E9 00298 	    BLBC    R0, 7$						      ;
		         53	       6B  D0 0029B 	    MOVL    DBG$GL_NEXT_LOC, LAST_LOC				      ; 2839
				       D8  11 0029E 	    BRB     3$							      ; 2819
		         52	       62  D0 002A0 6$:     MOVL    (POINTER), POINTER					      ; 2843
				       B0  12 002A3 	    BNEQ    1$							      ;
					   04 002A5 7$:     RET     							      ; 2735

; Routine Size:  109 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 7
; Digital Equipment Corporation
;
;	2845	ROUTINE output_mem_loc(location, symbol_nt_ptr, type) =
;	2846	
;	2847	!++
;	2848	! FUNCTIONAL DESCRIPTION:
;	2849	!	Outputs the value of a memory location to the output
;	2850	!	device. If this routine is called as a result of an EXAMINE
;	2851	!	command, the location itself is also displayed, followed by
;	2852	!	a colon and a tab.
;	2853	!
;	2854	!	The appropriate mode settings are used to control the output
;	2855	!	style.
;	2856	!
;	2857	! INPUTS:
;	2858	!	location	- location whose contents are to be displayed.
;	2859	!	symbol_nt_ptr	- The NT_PTR of the symbol where the LOCATION
;	2860	!			  may have originated.
;	2861	!	type		- The type of the expression to be examined.
;	2862	!
;	2863	! IMPLICIT INPUTS:
;	2864	!	dbg$gl_context [dbg$k_examine]	- if this bit is set, the
;	2865	!					  address of the value
;	2866	!					  is also displayed.
;	2867	!	DBG$GL_MOD_PTR			- pointer to the current mode level.
;	2868	!
;	2869	! OUTPUTS:
;	2870	!	True for success, false for failure.
;	2871	!
;	2872	! IMPLICIT OUTPUTS:
;	2873	!	NONE
;	2874	!
;	2875	! ROUTINE VALUE:
;	2876	!	TRUE OR FALSE
;	2877	!
;	2878	! SIDE EFFECTS:
;	2879	!	-An error message is produced if the memory location
;	2880	!	 is not readable.
;	2881	!--
;	2882	
;	2883	BEGIN
;	2884		MAP
;	2885			symbol_nt_ptr : ref NT_RECORD;
;	2886		LOCAL
;	2887			output_buffer : VECTOR[ tty_out_width, BYTE];
;	2888	%IF dbg_exa5
;     L 2889	%THEN
;     U 2890				$fao_tt_out('output_mem_loc: !XL, nt_ptr= !XL, type= !UL',
;     U 2891					.location, .symbol_nt_ptr, .type);
;     U 2892	%FI
;	2893	
;	2894		! Set up to do standard DEBUG I/O.
;	2895	
;	2896		dbg$cp_out_str = output_buffer + 1;
;	2897		dbg$gl_buf_siz = 0;
;	2898		IF .dbg$gl_context [dbg$k_examine]
;	2899		THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 7-1
; Digital Equipment Corporation
;
;	2900			BEGIN
;	2901	
;	2902			!++
;	2903			! Print the address, symbolically or otherwise,
;	2904			! making it come out as LONG regardless of the current
;	2905			! LENGTH mode.  Also pass on the associated NT pointer
;	2906			! since OUT_SYM_VAL appreciates all the help it can get.
;	2907			!--
;	2908			dbg$out_sym_val( .location, long_length, .symbol_nt_ptr );
;	2909			dbg$gl_last_loc = .location;
;	2910			dbg$gb_loc_type = memory_loc;
;	2911			dbg$fao_put ( colon_tab_stg );
;	2912			END;
;	2913	
;	2914		IF ( .location EQLA dbg$gl_runframe[ DBG$L_USER_PSL ] )	! We output the PSL in a special format
;	2915		then
;	2916			BEGIN
;	2917	
;	2918			! The output is either symbolic or numeric.
;	2919	
;	2920			IF( .dbg$gb_mod_ptr[ MODE_SYMBOLS ] )
;	2921			then
;	2922				output_psl(..location, output_buffer )
;	2923			else
;	2924				dbg$out_num_val( ..location, 0, 0 );
;	2925	
;	2926			! Set the 'next location' and 'last value' pseudos.
;	2927	
;	2928			dbg$gl_next_loc = .location + %upval;
;	2929			dbg$gl_last_val = ..location;
;	2930	
;	2931			END
;	2932		ELSE
;	2933	
;	2934		!  HANDLE OUTPUT AS SYMBOLIC INSTRUCTIONS SEPARATELY.
;	2935	
;	2936		IF ( .dbg$gb_mod_ptr[ mode_instruc ] )
;	2937		THEN
;	2938		    IF( (location = dbg$ins_decode( .location, output_buffer )) EQL 0 )
;	2939		    THEN
;	2940			BEGIN
;	2941			SIGNAL (dbg$_nodecode);
;	2942			RETURN(FALSE);
;	2943			END
;	2944		    ELSE
;	2945			dbg$gl_next_loc = .location
;	2946		ELSE	
;	2947			BEGIN
;	2948	
;	2949			! THEN, SPECIAL ATTENTION FOR ASCII OUTPUT.
;	2950	
;	2951			IF ( .dbg$gb_mod_ptr[ mode_ascii ] )
;	2952			THEN
;	2953				BEGIN
;	2954				LOCAL

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 7-2
; Digital Equipment Corporation
;
;	2955					size;
;	2956				!+
;	2957				! SIMPLY OUTPUT THE NUMBER OF CHARACTERS
;	2958				! provided by dbg$gl_asci_len.
;	2959				!-
;	2960				size = .dbg$gl_asci_len;
;	2961				dbg$read_access (.location, .size);
;	2962				dbg$fao_put( cs_ascii, .size, .location );
;	2963				dbg$gl_next_loc = .location + .size;
;	2964				IF .size GTR %UPVAL		! Truncate if necessary to set last_val.
;	2965				THEN
;	2966				    size = %UPVAL;
;	2967				dbg$gl_last_val = 0;
;	2968				dbg$gl_last_val = .(.location) <0,.size * 8>;
;	2969				END
;	2970			ELSE
;	2971				BEGIN
;	2972				dbg$read_access (.location, .dbg$gb_mod_ptr[mode_length]);
;	2973				IF NOT dbg$out_typ_val (.location, .type)
;	2974				THEN
;	2975					BEGIN
;	2976					dbg$out_num_val (..location, 0, 0);
;	2977					dbg$gl_next_loc = .location + .dbg$gb_mod_ptr [mode_length];
;	2978					dbg$gl_last_val = .(.location) <0, .dbg$gb_mod_ptr [mode_length] * 8>;
;	2979					END;
;	2980				END;
;	2981			END;
;	2982	
;	2983		! Write out the string and we're done.
;	2984	
;	2985		dbg$out_put( output_buffer );
;	2986	
;	2987		RETURN(TRUE);
;	2988	END;





					 0FDC 002A6 OUTPUT_MEM_LOC:
							    .WORD   Save R2,R3,R4,R6,R7,R8,R9,R10,R11			      ; 2845
		         56 00000000G  EF  9E 002A8 	    MOVAB   DBG$READ_ACCESS, R6					      ;
		         57 00000000G  EF  9E 002AF 	    MOVAB   DBG$OUT_NUM_VAL, R7					      ;
		         58 00000000G  EF  9E 002B6 	    MOVAB   DBG$GB_MOD_PTR, R8					      ;
		         59 00000000G  EF  9E 002BD 	    MOVAB   DBG$FAO_PUT, R9					      ;
		         5A 00000000G  EF  9E 002C4 	    MOVAB   DBG$GL_LAST_VAL, R10				      ;
		         5B 00000000G  EF  9E 002CB 	    MOVAB   DBG$GL_NEXT_LOC, R11				      ;
		         5E	FF7C   CE  9E 002D2 	    MOVAB   -132(SP), SP					      ;
	      00000000G  EF	  01   AE  9E 002D7 	    MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 2896
			    00000000G  EF  D4 002DF 	    CLRL    DBG$GL_BUF_SIZ					      ; 2897
	   26 00000000G  EF	       06  E1 002E5 	    BBC     #6, DBG$GL_CONTEXT, 1$				      ; 2898
				  08   AC  DD 002ED 	    PUSHL   SYMBOL_NT_PTR					      ; 2908
				       04  DD 002F0 	    PUSHL   #4							      ;
				  04   AC  DD 002F2 	    PUSHL   LOCATION						      ;
	      00000000G  EF	       03  FB 002F5 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 7-3
; Digital Equipment Corporation
;
	      00000000G  EF	  04   AC  D0 002FC 	    MOVL    LOCATION, DBG$GL_LAST_LOC				      ; 2909
			    00000000G  EF  94 00304 	    CLRB    DBG$GB_LOC_TYPE					      ; 2910
			    00000000'  EF  9F 0030A 	    PUSHAB  COLON_TAB_STG					      ; 2845
		         69	       01  FB 00310 	    CALLS   #1, DBG$FAO_PUT					      ; 2911
		         52	       68  D0 00313 1$:     MOVL    DBG$GB_MOD_PTR, R2					      ; 2920
		         53	  04   AC  D0 00316 	    MOVL    LOCATION, R3					      ; 2914
	   50 00000000G  EF 00000044   8F  C1 0031A 	    ADDL3   #68, DBG$GL_RUNFRAME, R0				      ;
		         50	       53  D1 00326 	    CMPL    R3, R0						      ;
				       25  12 00329 	    BNEQ    4$							      ;
		         0E	  02   A2  E9 0032B 	    BLBC    2(R2), 2$						      ; 2920
				       5E  DD 0032F 	    PUSHL   SP							      ; 2922
		         54	       63  D0 00331 	    MOVL    (R3), R4						      ;
				       54  DD 00334 	    PUSHL   R4							      ;
		  0000V  CF	       02  FB 00336 	    CALLS   #2, OUTPUT_PSL					      ;
				       0A  11 0033B 	    BRB     3$							      ; 2920
				       7E  7C 0033D 2$:     CLRQ    -(SP)						      ; 2924
		         54	       63  D0 0033F 	    MOVL    (R3), R4						      ;
				       54  DD 00342 	    PUSHL   R4							      ;
		         67	       03  FB 00344 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   6B	         53	       04  C1 00347 3$:     ADDL3   #4, R3, DBG$GL_NEXT_LOC				      ; 2928
		         6A	       54  D0 0034B 	    MOVL    R4, DBG$GL_LAST_VAL					      ; 2929
				       5D  11 0034E 	    BRB     8$							      ; 2914
		         26	  03   A2  E9 00350 4$:     BLBC    3(R2), 6$						      ; 2936
				4008   8F  BB 00354 	    PUSHR   #^M<R3,SP>						      ; 2938
	      00000000G  EF	       02  FB 00358 	    CALLS   #2, DBG$INS_DECODE					      ;
		    04   AC	       50  D0 0035F 	    MOVL    R0, LOCATION					      ;
				       0F  12 00363 	    BNEQ    5$							      ;
			    000281E8   8F  DD 00365 	    PUSHL   #164328						      ; 2941
	      00000000G  00	       01  FB 0036B 	    CALLS   #1, LIB$SIGNAL					      ;
				       7E  11 00372 	    BRB     11$							      ; 2942
		         6B	  04   AC  D0 00374 5$:     MOVL    LOCATION, DBG$GL_NEXT_LOC				      ; 2945
				       6B  11 00378 	    BRB     10$							      ; 2936
		         31	  04   A2  E9 0037A 6$:     BLBC    4(R2), 9$						      ; 2951
		         54 00000000G  EF  D0 0037E 	    MOVL    DBG$GL_ASCI_LEN, SIZE				      ; 2960
				       18  BB 00385 	    PUSHR   #^M<R3,R4>						      ; 2961
		         66	       02  FB 00387 	    CALLS   #2, DBG$READ_ACCESS					      ;
				       53  DD 0038A 	    PUSHL   R3							      ; 2962
				       54  DD 0038C 	    PUSHL   SIZE						      ;
			    00000000'  EF  9F 0038E 	    PUSHAB  CS_ASCII						      ; 2845
		         69	       03  FB 00394 	    CALLS   #3, DBG$FAO_PUT					      ; 2962
	   6B	         53	       54  C1 00397 	    ADDL3   SIZE, R3, DBG$GL_NEXT_LOC				      ; 2963
		         04	       54  D1 0039B 	    CMPL    SIZE, #4						      ; 2964
				       03  15 0039E 	    BLEQ    7$							      ;
		         54	       04  D0 003A0 	    MOVL    #4, SIZE						      ; 2966
				       6A  D4 003A3 7$:     CLRL    DBG$GL_LAST_VAL					      ; 2967
		         54	       08  C4 003A5 	    MULL2   #8, R4						      ; 2968
	   63	         54	       00  EF 003A8 	    EXTZV   #0, R4, (R3), DBG$GL_LAST_VAL			      ;
				       6A     003AC									      ;
				       36  11 003AD 8$:     BRB     10$							      ; 2951
		         7E	  01   A2  9A 003AF 9$:     MOVZBL  1(R2), -(SP)					      ; 2972
				       53  DD 003B3 	    PUSHL   R3							      ;
		         66	       02  FB 003B5 	    CALLS   #2, DBG$READ_ACCESS					      ;
				  0C   AC  DD 003B8 	    PUSHL   TYPE						      ; 2973
				       53  DD 003BB 	    PUSHL   R3							      ;
	      00000000G  EF	       02  FB 003BD 	    CALLS   #2, DBG$OUT_TYP_VAL					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 7-4
; Digital Equipment Corporation
;
		         1E	       50  E8 003C4 	    BLBS    R0, 10$						      ;
				       7E  7C 003C7 	    CLRQ    -(SP)						      ; 2976
				       63  DD 003C9 	    PUSHL   (R3)						      ;
		         67	       03  FB 003CB 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
		         50	       68  D0 003CE 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 2977
		         51	  01   A0  9A 003D1 	    MOVZBL  1(R0), R1						      ;
	   6B	         53	       51  C1 003D5 	    ADDL3   R1, R3, DBG$GL_NEXT_LOC				      ;
		         50	  01   A0  9A 003D9 	    MOVZBL  1(R0), R0						      ; 2978
		         50	       08  C4 003DD 	    MULL2   #8, R0						      ;
	   63	         50	       00  EF 003E0 	    EXTZV   #0, R0, (R3), DBG$GL_LAST_VAL			      ;
				       6A     003E4									      ;
				       5E  DD 003E5 10$:    PUSHL   SP							      ; 2985
	      00000000G  EF	       01  FB 003E7 	    CALLS   #1, DBG$OUT_PUT					      ;
		         50	       01  D0 003EE 	    MOVL    #1, R0						      ; 2987
					   04 003F1 	    RET     							      ;
				       50  D4 003F2 11$:    CLRL    R0							      ; 2845
					   04 003F4 	    RET     							      ;

; Routine Size:  335 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 8
; Digital Equipment Corporation
;
;	2989	GLOBAL ROUTINE dbg$evaluat_cmd : novalue =
;	2990	!++
;	2991	! Functional description:
;	2992	!
;	2993	!	This routine performs DEBUG's action for the evaluate
;	2994	! command - DEBUG's "desk calculator".  It relies on a common
;	2995	! routine used by examine for most cases - having first extracted
;	2996	! out the only two which are different, instruction and ascii evaluations.
;	2997	!
;	2998	! Implicit Inputs:
;	2999	!
;	3000	!	A global contains a pointer to the so-called 'command arg list'
;	3001	! which this and most commands work from.  For evaluate, each
;	3002	! record of the arg list essentially contains all that  is needed
;	3003	! for one evaluation.
;	3004	!
;	3005	! Routine Value:
;	3006	!	novalue
;	3007	!
;	3008	! Side Effects:
;	3009	!
;	3010	!	Output is produced which corresponds to whatever the
;	3011	! user has asked us to EValuate.
;	3012	!
;	3013	!	A SIGNAL and UNWIND may be produced if some error occurs.
;	3014	!--
;	3015	BEGIN
;	3016		LOCAL
;	3017			pointer,
;	3018			output_buffer : vector[ TTY_OUT_WIDTH, BYTE];
;	3019	
;	3020	%IF dbg_exa8 OR dbg_exa5 OR dbg_exa6
;     L 3021	%THEN
;     U 3022		$fao_tt_out('evaluate command');
;     U 3023	%FI
;	3024		!+
;	3025		! Loop thru the arg list evaluating each expression therein.
;	3026		! If there is nothing in the list, the the bulk of this
;	3027		! routine is not executed.
;	3028		!-
;	3029	
;	3030		pointer = .dbg$gl_head_lst;
;	3031	
;	3032		WHILE .pointer NEQ 0
;	3033			DO
;	3034			BEGIN
;	3035			dbg$cp_out_str = output_buffer + 1;	! Set up to do standard DEBUG I/O.
;	3036			dbg$gl_buf_siz = 0;
;	3037	
;	3038			!+
;	3039			! If auxiliary storage is associated with this command
;	3040			! arg record, then a quoted string must have been given
;	3041			! in some context as part of an evaluate expression.
;	3042			! In the case where ONLY this string was given, we
;	3043			! take evaluate to mean "print out the hex bytes which

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 8-1
; Digital Equipment Corporation
;
;	3044			! correspond to the given string".  
;	3045			!-
;	3046	
;	3047			IF ( (.list_elem_store(.pointer) NEQA 0)
;	3048			AND
;	3049			    (.list_elem_store(.pointer) EQLA .list_elem_exp1(.pointer)) )
;	3050			THEN
;	3051				BEGIN
;	3052				LOCAL
;	3053					size,
;	3054					cs_ptr : ref vector[,byte],
;	3055					out_instruc : vector[tty_out_width,byte];
;	3056	%if dbg_exa8
;     L 3057	%then
;     U 3058				$fao_tt_out('store=!XL',.list_elem_store(.pointer));
;     U 3059	%FI
;	3060				! If the data is in the form of an ascii string
;	3061				! which is supposed to be an instruction, we
;	3062				! must first perform this transformation.
;	3063	
;	3064				IF( .dbg$gb_mod_ptr[MODE_INSTRUC] )
;	3065				THEN
;	3066					begin
;	3067	
;	3068					! Using the current PC, if needed, for
;	3069					! this instruction, cause it to be encoded
;	3070					! from the ASCII form to a counted-byte
;	3071					! (binary) form in a local buffer.
;	3072	
;	3073					IF NOT dbg$ins_encode (.list_elem_store(.pointer),
;	3074								out_instruc,
;	3075								.dbg$gl_runframe[DBG$L_USER_PC] )
;	3076					then
;	3077						! A message should already have
;	3078						! been produced...
;	3079				
;	3080						SIGNAL(DBG$_NODECODE);
;	3081						! no return
;	3082	%if dbg_exa8
;     L 3083	%then
;     U 3084					$fao_tt_out('instruction requires !SB bytes',
;     U 3085						.out_instruc[0]);
;     U 3086	%FI
;	3087					! Transformation complete.  Now the encoded
;	3088					! byte stream is the one which we want to 
;	3089					! print out.
;	3090	
;	3091					cs_ptr = out_instruc;
;	3092					end
;	3093				ELSE
;	3094					! ASCII strings are already in the
;	3095					! counted-byte format.
;	3096	
;	3097					cs_ptr = .list_elem_store(.pointer);
;	3098	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 8-2
; Digital Equipment Corporation
;
;	3099				!+
;	3100				! Loop printing out each byte of the counted
;	3101				! byte stream we were given or we have produced.
;	3102				! We print the bytes out backwards to conform to
;	3103				! how numbers are always printed.  This is also why
;	3104				! we force the radix to HEX - you can't easily
;	3105				! decimalize arbitrary-size values.  We also go
;	3106				! to some trouble to make the HEX output look
;	3107				! like hex - atleast 8 characters and a leading 0.
;	3108				!-
;	3109				!+
;	3110				! As per the usual hex output, we force a
;	3111				! leading 0 if otherwise it would begin with
;	3112				! an alphabetic.  Moreover, for output which
;	3113				! would be less than 8 characters, we force
;	3114				! out some leading 0s to fill it out.
;	3115				!-
;	3116				size = .cs_ptr[0];
;	3117	
;	3118				IF( .size LSS %UPVAL )
;	3119				THEN
;	3120					BEGIN
;	3121	
;	3122					! Force out the right number of '00's.
;	3123	
;	3124					INCR j from 1 to %UPVAL-.size
;	3125						DO
;	3126						dbg$fao_put(uplit(%ascic '00'));
;	3127					END
;	3128				ELSE
;	3129					IF( .cs_ptr[.size] GTRA %X'9F' )
;	3130					THEN
;	3131						dbg$fao_put(uplit(%ascic '0'));
;	3132	
;	3133				! Now print the number out backwards.
;	3134	
;	3135				decr i from .size to 1
;	3136					do
;	3137					dbg$fao_put(uplit(%ASCIC '!XB'),.cs_ptr[.i]);
;	3138	
;	3139				! Write out the string, set the pseudo for
;	3140				! last-value-displayed, and we're done.
;	3141				! Note that we pick up at most 4 bytes
;	3142				! to copy into last_val, that we truncate without
;	3143				! warning, and that we 0-fill if necessary.
;	3144	
;	3145				dbg$out_put( output_buffer );
;	3146				dbg$gl_last_val = 0;
;	3147				IF( .size GTR %upval )
;	3148				then
;	3149					size = %upval;
;	3150				ch$move(.size, cs_ptr[1], dbg$gl_last_val);
;	3151				END
;	3152			ELSE
;	3153			    IF .dbg$gb_mod_ptr[ MODE_FORTRAN ] EQL LITERAL_MODE

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 8-3
; Digital Equipment Corporation
;
;	3154			    THEN
;	3155				BEGIN
;	3156				!+
;	3157				! Call a routine which outputs all literal names
;	3158				! and produces an error message if no literals exist
;	3159				! of this value.
;	3160				! If this routine returns update the "last-value"
;	3161				! symbol "\".
;	3162				!-
;	3163				display_lvts (.list_elem_exp1(.pointer) );
;	3164				dbg$gl_last_val = .list_elem_exp1(.pointer);
;	3165				END
;	3166			    ELSE
;	3167				IF .dbg$gb_mod_ptr[mode_immediate]
;	3168				THEN
;	3169				    BEGIN
;	3170				    dbg$out_num_val (.list_elem_exp1(.pointer), long_length, 0);
;	3171				    dbg$out_put (output_buffer);
;	3172				    dbg$gl_last_val = .list_elem_exp1(.pointer);
;	3173				    END
;	3174				ELSE
;	3175				    !+
;	3176				    ! Other kinds of evaluate can be handled by
;	3177				    ! the routine output_mem_loc.
;	3178				    ! Here though, we must preserve dbg$gl_next_loc.
;	3179				    !-	
;	3180				    BEGIN
;	3181				    LOCAL
;	3182					next_location;
;	3183				    next_location = .dbg$gl_next_loc;
;	3184				    dbg$gl_asci_len = .dbg$gb_mod_ptr[mode_length];
;	3185				    output_mem_loc( list_elem_exp1 (.pointer),
;	3186						.list_elem_ntptr(.pointer),
;	3187						.list_elem_type(.pointer));
;	3188				    dbg$gl_next_loc = next_location;
;	3189				    END;
;	3190	
;	3191			!+
;	3192			! Go back and evaluate anything else in the
;	3193			! command arg list.
;	3194			!-
;	3195			pointer = .list_elem_flink (.pointer);
;	3196			END;
;	3197	
;	3198		RETURN;
;	3199	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00050 P.AAE:  .ASCII  <2>\00\<0>						      ;
					      00054 P.AAF:  .ASCII  <1>\0\<0><0>					      ;
					      00058 P.AAG:  .ASCII  <3>\!XB\						      ;


; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 8-4
; Digital Equipment Corporation
;


							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0FFC 003F5 	    .ENTRY  DBG$EVALUAT_CMD, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 2989
		         57 00000000G  EF  9E 003F7 	    MOVAB   DBG$GL_NEXT_LOC, R7					      ;
		         58 00000000G  EF  9E 003FE 	    MOVAB   DBG$OUT_PUT, R8					      ;
		         59 00000000G  EF  9E 00405 	    MOVAB   DBG$GL_LAST_VAL, R9					      ;
		         5A 00000000G  EF  9E 0040C 	    MOVAB   DBG$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 00413 	    MOVAB   P.AAE, R11						      ;
		         5E	FEF4   CE  9E 0041A 	    MOVAB   -268(SP), SP					      ;
		         56 00000000G  EF  D0 0041F 	    MOVL    DBG$GL_HEAD_LST, POINTER				      ; 3030
				       56  D5 00426 1$:     TSTL    POINTER						      ; 3032
				       01  12 00428 	    BNEQ    2$							      ;
					   04 0042A 	    RET     							      ;
	      00000000G  EF	FF7D   CD  9E 0042B 2$:     MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 3035
			    00000000G  EF  D4 00434 	    CLRL    DBG$GL_BUF_SIZ					      ; 3036
		         52 00000000G  EF  D0 0043A 	    MOVL    DBG$GB_MOD_PTR, R2					      ; 3064
		         51	  14   A6  D0 00441 	    MOVL    20(POINTER), R1					      ; 3047
				       03  12 00445 	    BNEQ    4$							      ;
				     008C  31 00447 3$:     BRW     15$							      ;
		    04   A6	       51  D1 0044A 4$:     CMPL    R1, 4(POINTER)					      ; 3049
				       F7  12 0044E 	    BNEQ    3$							      ;
		         2C	  03   A2  E9 00450 	    BLBC    3(R2), 6$						      ; 3064
		         50 00000000G  EF  D0 00454 	    MOVL    DBG$GL_RUNFRAME, R0					      ; 3075
				  40   A0  DD 0045B 	    PUSHL   64(R0)						      ; 3073
				  08   AE  9F 0045E 	    PUSHAB  OUT_INSTRUC						      ;
				       51  DD 00461 	    PUSHL   R1							      ;
	      00000000G  EF	       03  FB 00463 	    CALLS   #3, DBG$INS_ENCODE					      ;
		         0D	       50  E8 0046A 	    BLBS    R0, 5$						      ;
			    000281E8   8F  DD 0046D 	    PUSHL   #164328						      ; 3080
	      00000000G  00	       01  FB 00473 	    CALLS   #1, LIB$SIGNAL					      ;
		         53	  04   AE  9E 0047A 5$:     MOVAB   OUT_INSTRUC, CS_PTR					      ; 3091
				       03  11 0047E 	    BRB     7$							      ; 3064
		         53	       51  D0 00480 6$:     MOVL    R1, CS_PTR						      ; 3097
		         52	       63  9A 00483 7$:     MOVZBL  (CS_PTR), SIZE					      ; 3116
		         04	       52  D1 00486 	    CMPL    SIZE, #4						      ; 3118
				       13  18 00489 	    BGEQ    10$							      ;
	   54	         04	       52  C3 0048B 	    SUBL3   SIZE, #4, R4					      ; 3124
				       55  D4 0048F 	    CLRL    J							      ;
				       05  11 00491 	    BRB     9$							      ;
				       5B  DD 00493 8$:     PUSHL   R11							      ; 3126
		         6A	       01  FB 00495 	    CALLS   #1, DBG$FAO_PUT					      ;
	   F7	         55	       54  F3 00498 9$:     AOBLEQ  R4, J, 8$						      ; 3124
				       0D  11 0049C 	    BRB     11$							      ; 3118
		    9F   8F	     6243  91 0049E 10$:    CMPB    (SIZE)[CS_PTR], #159				      ; 3129
				       06  1B 004A3 	    BLEQU   11$							      ;
				  04   AB  9F 004A5 	    PUSHAB  P.AAF						      ; 3131
		         6A	       01  FB 004A8 	    CALLS   #1, DBG$FAO_PUT					      ;
	   54	         52	       01  C1 004AB 11$:    ADDL3   #1, SIZE, I						      ; 3135
				       0A  11 004AF 	    BRB     13$							      ;
		         7E	     6443  9A 004B1 12$:    MOVZBL  (I)[CS_PTR], -(SP)					      ; 3137
				  08   AB  9F 004B5 	    PUSHAB  P.AAG						      ;
		         6A	       02  FB 004B8 	    CALLS   #2, DBG$FAO_PUT					      ;
		         F3	       54  F5 004BB 13$:    SOBGTR  I, 12$						      ; 3135

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 8-5
; Digital Equipment Corporation
;
				FF7C   CD  9F 004BE 	    PUSHAB  OUTPUT_BUFFER					      ; 3145
		         68	       01  FB 004C2 	    CALLS   #1, DBG$OUT_PUT					      ;
				       69  D4 004C5 	    CLRL    DBG$GL_LAST_VAL					      ; 3146
		         04	       52  D1 004C7 	    CMPL    SIZE, #4						      ; 3147
				       03  15 004CA 	    BLEQ    14$							      ;
		         52	       04  D0 004CC 	    MOVL    #4, SIZE						      ; 3149
	   69	    01   A3	       52  28 004CF 14$:    MOVC3   SIZE, 1(CS_PTR), DBG$GL_LAST_VAL			      ; 3150
				       4B  11 004D4 	    BRB     19$							      ; 3047
		         03	  07   A2  91 004D6 15$:    CMPB    7(R2), #3						      ; 3153
				       0A  12 004DA 	    BNEQ    16$							      ;
				  04   A6  DD 004DC 	    PUSHL   4(POINTER)						      ; 3163
		  0000V  CF	       01  FB 004DF 	    CALLS   #1, DISPLAY_LVTS					      ;
				       18  11 004E4 	    BRB     17$							      ; 3164
		         1A	  08   A2  E9 004E6 16$:    BLBC    8(R2), 18$						      ; 3167
		         7E	       04  7D 004EA 	    MOVQ    #4, -(SP)						      ; 3170
				  04   A6  DD 004ED 	    PUSHL   4(POINTER)						      ;
	      00000000G  EF	       03  FB 004F0 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
				FF7C   CD  9F 004F7 	    PUSHAB  OUTPUT_BUFFER					      ; 3171
		         68	       01  FB 004FB 	    CALLS   #1, DBG$OUT_PUT					      ;
		         69	  04   A6  D0 004FE 17$:    MOVL    4(POINTER), DBG$GL_LAST_VAL				      ; 3172
				       1D  11 00502 	    BRB     19$							      ; 3167
		         6E	       67  D0 00504 18$:    MOVL    DBG$GL_NEXT_LOC, NEXT_LOCATION			      ; 3183
	      00000000G  EF	  01   A2  9A 00507 	    MOVZBL  1(R2), DBG$GL_ASCI_LEN				      ; 3184
				  0C   A6  DD 0050F 	    PUSHL   12(POINTER)						      ; 3185
		         7E	  10   A6  3C 00512 	    MOVZWL  16(POINTER), -(SP)					      ;
				  04   A6  9F 00516 	    PUSHAB  4(POINTER)						      ;
		  FD88   CF	       03  FB 00519 	    CALLS   #3, OUTPUT_MEM_LOC					      ;
		         67	       6E  9E 0051E 	    MOVAB   NEXT_LOCATION, DBG$GL_NEXT_LOC			      ; 3188
		         56	       66  D0 00521 19$:    MOVL    (POINTER), POINTER					      ; 3195
				     FEFF  31 00524 	    BRW     1$							      ; 3032
					   04 00527 20$:    RET     							      ; 2989

; Routine Size:  307 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 9
; Digital Equipment Corporation
;
;	3200	routine display_lvts( value ) : NOVALUE =
;	3201	
;	3202	!++
;	3203	! Functional Description:
;	3204	!
;	3205	!	Given a value, display the pathnames of all literals
;	3206	! in the LVT which have this value.
;	3207	!
;	3208	! Inputs:
;	3209	!
;	3210	!	value	-The lookup key.
;	3211	!
;	3212	! Implicit Inputs:
;	3213	!
;	3214	!	The initial setup for standard DEBUG I/O has already
;	3215	! been done.  We (re)use this buffer for our output.
;	3216	!
;	3217	! Routine Value:
;	3218	!	NOVALUE - we either do as asked, or SIGNAL our way out.
;	3219	!
;	3220	! Side Effects:
;	3221	!
;	3222	!	Either output is sent to the terminal, or
;	3223	! a SIGNAL is generated and no return is done.
;	3224	!--
;	3225	
;	3226	BEGIN
;	3227		LOCAL
;	3228			output_buffer : ref vector[,byte],
;	3229			lvt_ptr : ref LVT_RECORD,
;	3230			one_found;
;	3231	
;	3232	%if dbg_exa6
;     L 3233	%then
;     U 3234		$fao_tt_out('ev/lit of !XL',.value);
;     U 3235	%FI
;	3236		! Initialize a flag which we use to know whether or not
;	3237		! atleast one match to the given value has been found.
;	3238		! Also save a pointer to current output buffer so that
;	3239		! we can reuse it.
;	3240	
;	3241		one_found = FALSE;
;	3242		output_buffer = .dbg$cp_out_str;
;	3243	
;	3244		! Access to the LVT is via a 'canned' function.  Before
;	3245		! using it, we must signal our intention to do so.
;	3246	
;	3247		dbg$get_nxt_lvt( SL_ACCE_INIT );
;	3248	
;	3249		! Loop thru the LVT sequentially, asking to see
;	3250		! all currently valid records.
;	3251	
;	3252		while( (lvt_ptr = dbg$get_nxt_lvt( SL_ACCE_RECS )) NEQA 0 )
;	3253			DO
;	3254			BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 9-1
; Digital Equipment Corporation
;
;	3255	%if dbg_exa6
;     L 3256	%then
;     U 3257			$fao_tt_out('lvt rec !XL => value !XL',.lvt_ptr,.lvt_ptr[LVT_VALUE]);
;     U 3258	%FI
;	3259			! See if we have found a match.
;	3260	
;	3261			IF( .lvt_ptr[ LVT_VALUE ] EQL .VALUE )
;	3262			THEN
;	3263				BEGIN
;	3264				LOCAL
;	3265					nt_ptr : REF NT_RECORD,
;	3266					path_vec : PATHNAME_VECTOR;
;	3267	
;	3268				! Found a match.  Print out the corresponding
;	3269				! pathname by first building a pathname vector
;	3270				! based on the returned NT_PTR.
;	3271	
;	3272				one_found = TRUE;
;	3273				nt_ptr = .LVT_PTR[ LVT_NT_PTR ];
;	3274	
;	3275				dbg$add_nt_2_pv( .nt_ptr, path_vec);
;	3276				dbg$print_path( path_vec);
;	3277	
;	3278				! Write out the string, reset the global
;	3279				! buffer pointers, and we're done.
;	3280	
;	3281				dbg$out_put( .output_buffer-1 );
;	3282				dbg$cp_out_str = .output_buffer;
;	3283				dbg$gl_buf_siz = 0;
;	3284				END;
;	3285	
;	3286			! Loop back to consider the next LVT record.
;	3287			END;
;	3288	
;	3289		! At this point, the LVT has been completely searched.
;	3290		! If we didn't find any matches to the given value,
;	3291		! we complain.
;	3292	
;	3293		IF( NOT .one_found )
;	3294		then
;	3295			signal( DBG$_NOLITERAL, 1, .value);
;	3296			! no return
;	3297	
;	3298		! Otherwise, we're done.
;	3299	END;





					 0C1C 00528 DISPLAY_LVTS:
							    .WORD   Save R2,R3,R4,R10,R11				      ; 3200
		         5A 00000000G  EF  9E 0052A 	    MOVAB   DBG$CP_OUT_STR, R10					      ;
		         5B 00000000G  EF  9E 00531 	    MOVAB   DBG$GET_NXT_LVT, R11				      ;
		         5E	       2C  C2 00538 	    SUBL2   #44, SP						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 9-2
; Digital Equipment Corporation
;
				       54  D4 0053B 	    CLRL    ONE_FOUND						      ; 3241
		         53	       6A  D0 0053D 	    MOVL    DBG$CP_OUT_STR, OUTPUT_BUFFER			      ; 3242
				       7E  D4 00540 	    CLRL    -(SP)						      ; 3247
		         6B	       01  FB 00542 	    CALLS   #1, DBG$GET_NXT_LVT					      ;
				       01  DD 00545 1$:     PUSHL   #1							      ; 3252
		         6B	       01  FB 00547 	    CALLS   #1, DBG$GET_NXT_LVT					      ;
		         52	       50  D0 0054A 	    MOVL    R0, LVT_PTR						      ;
				       36  13 0054D 	    BEQL    2$							      ;
		    04   AC	  02   A2  D1 0054F 	    CMPL    2(LVT_PTR), VALUE					      ; 3261
				       EF  12 00554 	    BNEQ    1$							      ;
		         54	       01  D0 00556 	    MOVL    #1, ONE_FOUND					      ; 3272
		         50	       62  3C 00559 	    MOVZWL  (LVT_PTR), NT_PTR					      ; 3273
				4001   8F  BB 0055C 	    PUSHR   #^M<R0,SP>						      ; 3275
	      00000000G  EF	       02  FB 00560 	    CALLS   #2, DBG$ADD_NT_2_PV					      ;
				       5E  DD 00567 	    PUSHL   SP							      ; 3276
	      00000000G  EF	       01  FB 00569 	    CALLS   #1, DBG$PRINT_PATH					      ;
				  FF   A3  9F 00570 	    PUSHAB  -1(OUTPUT_BUFFER)					      ; 3281
	      00000000G  EF	       01  FB 00573 	    CALLS   #1, DBG$OUT_PUT					      ;
		         6A	       53  D0 0057A 	    MOVL    OUTPUT_BUFFER, DBG$CP_OUT_STR			      ; 3282
			    00000000G  EF  D4 0057D 	    CLRL    DBG$GL_BUF_SIZ					      ; 3283
				       C0  11 00583 	    BRB     1$							      ; 3252
		         12	       54  E8 00585 2$:     BLBS    ONE_FOUND, 3$					      ; 3293
				  04   AC  DD 00588 	    PUSHL   VALUE						      ; 3295
				       01  DD 0058B 	    PUSHL   #1							      ;
			    00028100   8F  DD 0058D 	    PUSHL   #164096						      ;
	      00000000G  00	       03  FB 00593 	    CALLS   #3, LIB$SIGNAL					      ;
					   04 0059A 3$:     RET     							      ; 3200

; Routine Size:  115 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 10
; Digital Equipment Corporation
;
;	3300	GLOBAL ROUTINE dbg$reg_match (string_desc) =
;	3301	
;	3302	!++
;	3303	! Functional description:
;	3304	!	Compares a string described by the string descriptor passed
;	3305	!	as the routine formal to each of the names of the machine
;	3306	!	registers. If the string matches a register name, return the
;	3307	!	number of the register (0-16, where 16 is the PSL). Otherwise,
;	3308	!	return a -1.
;	3309	!
;	3310	! Calling sequence:
;	3311	!	CALLS #1, dbg$reg_match
;	3312	!
;	3313	! Inputs:
;	3314	!	string_desc	- string descriptor to symbol string
;	3315	!
;	3316	! Implicit inputs:
;	3317	!	the VAX machine register table
;	3318	!
;	3319	! Outputs:
;	3320	!	The number of the register whose name matched the string.
;	3321	!
;	3322	! Implicit outputs:
;	3323	!	none
;	3324	!
;	3325	! Routine value:
;	3326	!	0-16 or -1 (meaning no match)
;	3327	!
;	3328	! Side effects:
;	3329	!	none
;	3330	!--
;	3331	
;	3332		BEGIN
;	3333	
;	3334		MAP
;	3335			string_desc : REF BLOCK [, BYTE];
;	3336	
;	3337		LOCAL
;	3338			index;
;	3339	
;	3340	%IF dbg_exa2
;     L 3341	%THEN
;     U 3342		$fao_tt_out ('!/symbol is "!AD"', .string_desc [dsc$w_length],
;     U 3343				ch$ptr (.string_desc [dsc$a_pointer]));
;     U 3344	%FI
;	3345	
;	3346		index = 0;
;	3347	
;	3348		REPEAT
;	3349			BEGIN
;	3350			IF ch$eql (.string_desc [dsc$w_length], ch$ptr (.string_desc [dsc$a_pointer]),
;	3351					.register_table [.index, reg_ch_cnt],
;	3352					ch$ptr (register_table [.index, reg_name]))
;	3353			THEN RETURN .index
;	3354			ELSE

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 10-1
; Digital Equipment Corporation
;
;	3355				BEGIN
;	3356				index = .index + 1;
;	3357				IF .index GTR register_count - 1
;	3358				THEN RETURN -1
;	3359				END;
;	3360			END;
;	3361		END;





					 003C 0059B 	    .ENTRY  DBG$REG_MATCH, Save R2,R3,R4,R5			      ; 3300
				       54  D4 0059D 	    CLRL    INDEX						      ; 3346
	   55	    04   AC	       04  C1 0059F 	    ADDL3   #4, STRING_DESC, R5					      ; 3350
		         50 00000000'EF44  DE 005A4 1$:     MOVAL   REGISTER_TABLE[INDEX], R0				      ; 3351
		         51	       60  9A 005AC 	    MOVZBL  (R0), R1						      ;
	   00	    00   B5	  04   BC  2D 005AF 	    CMPC5   @STRING_DESC, @0(R5), #0, R1, 1(R0)			      ; 3350
		    01   A0	       51     005B5									      ;
				       04  12 005B8 	    BNEQ    2$							      ;
		         50	       54  D0 005BA 	    MOVL    INDEX, R0						      ; 3353
					   04 005BD 	    RET     							      ;
				       54  D6 005BE 2$:     INCL    INDEX						      ; 3356
		         10	       54  D1 005C0 	    CMPL    INDEX, #16						      ; 3357
				       DF  15 005C3 	    BLEQ    1$							      ;
		         50	       01  CE 005C5 	    MNEGL   #1, R0						      ; 3358
					   04 005C8 	    RET     							      ; 3300

; Routine Size:  46 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11
; Digital Equipment Corporation
;
;	3362	ROUTINE symbol_deposit (deposit_loc, value_ptr, symbol_nt_ptr) =
;	3363	
;	3364	!++
;	3365	! Functional description:
;	3366	!	Tries to convert location to be deposited into a symbolic
;	3367	!	location. If this succeeds, deposits the value in the
;	3368	!	command argument list according to the data type of
;	3369	!	the symbol. Sets next_loc appropriately as well.
;	3370	!
;	3371	!	If the location cannot be bound to a symbol, then the deposit
;	3372	!	is done according to the current mode setting in the routine
;	3373	!	that called this routine - but this is not done in this routine.
;	3374	!
;	3375	! Input parameters:
;	3376	!	deposit_loc	- address into which data is to be deposited.
;	3377	!	value_ptr	- address of data. Can be up to eight bytes long.
;	3378	!	symbol_nt_ptr	-An NT_PTR to the symbol into which we are
;	3379	!			 depositing.  The type which corresponds to this
;	3380	!			 is believed before any type which we might deduce
;	3381	!			 starting with the value that this symbol is bound do.
;	3382	!			 (To get around EQUIVALENCE ambiguities).  This
;	3383	!			 overriding is NOT done for subsequent elements in
;	3384	!			 the deposit list.
;	3385	!
;	3386	! Implicit inputs:
;	3387	!	The symbol table information for each symbol known.
;	3388	!
;	3389	!	The value_ptr is actually a pointer to a sequence of bytes
;	3390	!	in the fixed-format command arg list.  We access the bytes
;	3391	!	by the macros, below, assuming how we know they are
;	3392	!	constructed by the parser.  (e.g. we 'know' that the
;	3393	!	TYPE field is the byte (longword) following the 2-longword
;	3394	!	value field).
;	3395	
;	3396	!
;	3397	! Output parameters:
;	3398	!	none
;	3399	!
;	3400	! Implicit outputs:
;	3401	!	dbg$gl_next_loc is set to the next location to be deposited.
;	3402	!
;	3403	! Routine value:
;	3404	!	TRUE or FALSE. TRUE means that the deposit was done. FALSE
;	3405	!	means that nothing was done, and that the caller routine should
;	3406	!	do the deposit and update next_loc.
;	3407	!
;	3408	! Side effects:
;	3409	!	If the location cannot be written, a SIGNAL is generated,
;	3410	!	and the remaining deposits are not done.
;	3411	!--
;	3412	
;	3413	BEGIN
;	3414		MAP
;	3415			symbol_nt_ptr : ref NT_RECORD;
;	3416		MAP

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-1
; Digital Equipment Corporation
;
;	3417			value_ptr	: REF BLOCK [, BYTE];
;	3418	
;	3419		MACRO
;	3420				! See implicit assumptions, above.
;	3421	
;	3422			single_bit	= 0, 0, 1, 0%,
;	3423			byte_logical	= 0, 0, 8, 0%,
;	3424			word_logical	= 0, 0, 16, 0%,
;	3425			long_logical	= 0, 0, 32, 0%,
;	3426			long_2_logical	= 4, 0, 32, 0%,
;	3427			long_3_logical	= 8, 0, 32, 0%,
;	3428			byte_integer	= 0, 0, 8, 1%,
;	3429			word_integer	= 0, 0, 16, 1%,
;	3430			long_integer	= 0, 0, 32, 1%;
;	3431	
;	3432		LOCAL
;	3433			nt_ptr	: REF nt_record,
;	3434			real_value;
;	3435	
;	3436	%IF dbg_exa4
;     L 3437	%THEN
;     U 3438		$fao_tt_out ('deposit value is !XL, !XL, type is !SL, hint=!XL',
;     U 3439			.value_ptr [long_logical], .value_ptr [long_2_logical],
;     U 3440			.value_ptr [long_3_logical], .symbol_nt_ptr);
;     U 3441	%FI
;	3442	
;	3443		!+
;	3444		! If we were given a valid (non-zero) NT_PTR which supposedly
;	3445		! corresponds to the symbol we are depositing into, then we
;	3446		! try to use the implied info instead of re-deducing the whole
;	3447		! thing value_to_symbol-style.
;	3448		!-
;	3449	
;	3450		IF( (nt_ptr = .symbol_nt_ptr) EQL 0 )
;	3451		then
;	3452			BEGIN
;	3453			LOCAL
;	3454				sat_ptr : ref sat_record;
;	3455	
;	3456			!++
;	3457			! Look up in the RST to find the symbol name
;	3458			! that is closest in value to the address whose
;	3459			! contents is to be changed. If val_to_sat fails, then
;	3460			! no symbol can be found, so return with a false value.
;	3461			!--
;	3462		
;	3463			IF NOT dbg$val_to_sat (.deposit_loc, sat_ptr )
;	3464			THEN RETURN FALSE;
;	3465			
;	3466			! Pick the NT pointer out of the SAT record.
;	3467		
;	3468			nt_ptr = .sat_ptr[ sat_nt_ptr ];
;	3469			END;
;	3470	
;	3471		!++

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-2
; Digital Equipment Corporation
;
;	3472		! Now find the precise value of the symbol name that was returned
;	3473		! by val_to_sat or passed in to us in the first place. I don't
;	3474		! know of and scenario in which this will fail.
;	3475		!--
;	3476	
;	3477	%IF dbg_exa4
;     L 3478	%THEN
;     U 3479		$fao_tt_out ('deposit: using nt_ptr = !XW, type = !SL',
;     U 3480			.nt_ptr,.nt_ptr[NT_TYPE]);
;     U 3481	%FI
;	3482		IF NOT DBG$symbol_valu (.nt_ptr, real_value)
;	3483		THEN RETURN FALSE;
;	3484	
;	3485		! See if the match was exact.  If not, then
;	3486		! see if the address was in the middle of an array.
;	3487	
;	3488		IF .deposit_loc NEQ .real_value
;	3489		THEN
;	3490			begin
;	3491			local
;	3492				bounds : ARRAY_BNDS_DESC,
;	3493				dst_recrd : ref DST_RECORD;
;	3494	
;	3495			! If the symbol was not an array, then we can
;	3496			! do no more.  We find this out by going to the
;	3497			! DST and looking at the access type therein.
;	3498			! Don't go to the DST if the symbol is a global.
;	3499	
;	3500			if( .nt_ptr[ nt_up_scope ] EQL 0 )
;	3501			then
;	3502				! Globals don't have a DST.
;	3503				return(FALSE);
;	3504			dst_recrd = .nt_ptr[ nt_dst_ptr ];
;	3505			IF( .DST_RECRD[ DSTR_ACCES_TYPE ] NEQ ACCS_DESCRIPTOR )
;	3506			THEN
;	3507				! This is not an array.
;	3508				RETURN(FALSE);
;	3509	
;	3510			! The value bound to the symbol is actually the
;	3511			! address of the descriptor.  Let another function
;	3512			! tell us the current bounds of this array.
;	3513	
;	3514			dbg$get_bounds( .real_value, bounds );
;	3515	
;	3516			! GET_BOUNDS does not return if there is something 
;	3517			! wrong with the array or its descriptor.
;	3518	
;	3519			! See if the deposit-to location is within
;	3520			! the array.  Get out if not.
;	3521	
;	3522			if( .deposit_loc LSSA .bounds[ array_address ] )
;	3523			then
;	3524				! Deposit location is before array.
;	3525				return(false);
;	3526	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-3
; Digital Equipment Corporation
;
;	3527			IF( .DEPOSIT_LOC GEQA .bounds[array_address] + .bounds[array_length] )
;	3528			then
;	3529				! Deposit location is after the end of the array.
;	3530				RETURN(FALSE);
;	3531	
;	3532			! Value is within the array so the NT_TYPE field is OK.
;	3533	
;	3534			end;
;	3535	
;	3536	%IF dbg_exa4
;     L 3537	%THEN
;     U 3538		$fao_tt_out ('!/symbol type is !SL', .nt_ptr [nt_type]);
;     U 3539	%FI
;	3540	
;	3541		!++
;	3542		! See whether the location is a type that we know. If so,
;	3543		! go ahead and convert the expression to be deposited and do
;	3544		! a typed deposit. Otherwise, return false.
;	3545		!--
;	3546		IF (.nt_ptr [nt_type] LEQ dsc$k_dtype_z) OR
;	3547			(.nt_ptr [nt_type] GTR dsc$k_dtype_dc)
;	3548		THEN RETURN FALSE;
;	3549	
;	3550	
;	3551		!++
;	3552		! If the symbol to be deposited is of a data type different from
;	3553		! the value to be deposited, do an appropriate conversion.
;	3554		!--
;	3555		CASE .nt_ptr [nt_type] FROM dsc$k_dtype_f	! 10
;	3556					 TO dsc$k_dtype_dc	! 13
;	3557	
;	3558			OF
;	3559			SET
;	3560	
;	3561			[dsc$k_dtype_f, dsc$k_dtype_fc]:	! single precision and complex
;	3562				IF .value_ptr [long_3_logical] EQL dsc$k_dtype_l
;	3563				THEN
;	3564					BEGIN
;	3565	
;	3566	%IF dbg_exa4
;     L 3567	%THEN
;     U 3568					$fao_tt_out ('!/converting integer to floating');
;     U 3569	%FI
;	3570	
;	3571					dbg$cnv_l_to_f (.value_ptr);
;	3572	
;	3573	%IF dbg_exa4
;     L 3574	%THEN
;     U 3575					$fao_tt_out ('!/new value is !XL, !XL',
;     U 3576						.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3577	%FI
;	3578	
;	3579					END
;	3580				ELSE IF .value_ptr [long_3_logical] EQL dsc$k_dtype_d
;	3581				THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-4
; Digital Equipment Corporation
;
;	3582					BEGIN
;	3583	
;	3584	%IF dbg_exa4
;     L 3585	%THEN
;     U 3586					$fao_tt_out ('!/converting double to single precision');
;     U 3587	%FI
;	3588	
;	3589					dbg$cnv_d_to_f (.value_ptr);
;	3590	
;	3591	%IF dbg_exa4
;     L 3592	%THEN
;     U 3593					$fao_tt_out ('!/new value is !XL, !XL',
;     U 3594						.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3595	%FI
;	3596	
;	3597					END;
;	3598	
;	3599	
;	3600			[dsc$k_dtype_d, dsc$k_dtype_dc]:	! double precision and complex
;	3601				IF .value_ptr [long_3_logical] EQL dsc$k_dtype_l
;	3602				THEN
;	3603					BEGIN
;	3604	
;	3605	%IF dbg_exa4
;     L 3606	%THEN
;     U 3607					$fao_tt_out ('!/converting integer to double precision');
;     U 3608	%FI
;	3609	
;	3610					dbg$cnv_l_to_d (.value_ptr);
;	3611	
;	3612	%IF dbg_exa4
;     L 3613	%THEN
;     U 3614					$fao_tt_out ('!/new value is !XL, !XL',
;     U 3615						.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3616	%FI
;	3617	
;	3618					END
;	3619				ELSE IF .value_ptr [long_3_logical] EQL dsc$k_dtype_f
;	3620				THEN
;	3621					BEGIN
;	3622	
;	3623	%IF dbg_exa4
;     L 3624	%THEN
;     U 3625					$fao_tt_out ('!/converting single to double precision');
;     U 3626	%FI
;	3627	
;	3628					dbg$cnv_f_to_d (.value_ptr);
;	3629	
;	3630	%IF dbg_exa4
;     L 3631	%THEN
;     U 3632					$fao_tt_out ('!/new value is !XL, !XL',
;     U 3633						.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3634	%FI
;	3635	
;	3636					END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-5
; Digital Equipment Corporation
;
;	3637	
;	3638	
;	3639			[OUTRANGE]:
;	3640				IF .value_ptr [long_3_logical] EQL dsc$k_dtype_f
;	3641				THEN
;	3642					BEGIN
;	3643	
;	3644	%IF dbg_exa4
;     L 3645	%THEN
;     U 3646					$fao_tt_out ('!/converting single precision to integer');
;     U 3647	%FI
;	3648	
;	3649					dbg$cnv_f_to_l (.value_ptr);
;	3650	
;	3651	%IF dbg_exa4
;     L 3652	%THEN
;     U 3653					$fao_tt_out ('!/new value is !XL, !XL',
;     U 3654						.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3655	%FI
;	3656	
;	3657					END
;	3658				ELSE IF .value_ptr [long_3_logical] EQL dsc$k_dtype_d
;	3659				THEN
;	3660					BEGIN
;	3661	
;	3662	%IF dbg_exa4
;     L 3663	%THEN
;     U 3664					$fao_tt_out ('!/converting double precision to integer');
;     U 3665	%FI
;	3666	
;	3667					dbg$cnv_d_to_l (.value_ptr);
;	3668	
;	3669	%IF dbg_exa4
;     L 3670	%THEN
;     U 3671					$fao_tt_out ('!/new value is !XL, !XL',
;     U 3672						.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3673	%FI
;	3674	
;	3675					END;
;	3676	
;	3677			TES;
;	3678	
;	3679		!++
;	3680		! Figure out how much of this value to be deposited will fit
;	3681		! into the size of the location. If the value is bigger,
;	3682		! convert it to the smaller size.
;	3683		!--
;	3684		CASE .nt_ptr [nt_type] FROM dsc$k_dtype_v	! 1
;	3685					 TO dsc$k_dtype_w	! 7
;	3686			OF
;	3687			SET
;	3688	
;	3689			[dsc$k_dtype_v]:			! single bit
;	3690				value_ptr [long_logical] = .value_ptr [single_bit];
;	3691	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-6
; Digital Equipment Corporation
;
;	3692	
;	3693			[dsc$k_dtype_bu]:			! byte logical
;	3694				value_ptr [long_logical] = .value_ptr [byte_logical];
;	3695	
;	3696	
;	3697			[dsc$k_dtype_wu]:			! word logical
;	3698				value_ptr [long_logical] = .value_ptr [word_logical];
;	3699	
;	3700	
;	3701			[dsc$k_dtype_b]:			! byte integer
;	3702				value_ptr [long_integer] = .value_ptr [byte_integer];
;	3703	
;	3704	
;	3705			[dsc$k_dtype_w]:			! word integer
;	3706				value_ptr [long_integer] = .value_ptr [word_integer];
;	3707	
;	3708	
;	3709			[INRANGE, OUTRANGE]:
;	3710				0;
;	3711	
;	3712			TES;
;	3713	
;	3714		!++
;	3715		! Now actually deposit the value in the deposit location. The
;	3716		! length of the deposit is again determined by the data
;	3717		! type of the symbol.
;	3718		!--
;	3719	
;	3720	%IF dbg_exa4
;     L 3721	%THEN
;     U 3722		$fao_tt_out ('!/value being deposited is !XL, !XL',
;     U 3723			.value_ptr [long_logical], .value_ptr [long_2_logical]);
;     U 3724	%FI
;	3725	
;	3726		IF NOT dbg$write_mem (.deposit_loc, .value_ptr,
;	3727			(CASE .nt_ptr [nt_type] FROM dsc$k_dtype_v
;	3728						  TO dsc$k_dtype_dc
;	3729	
;	3730				OF
;	3731				SET
;	3732	
;	3733				[dsc$k_dtype_v, dsc$k_dtype_bu, dsc$k_dtype_b]:
;	3734					1;
;	3735	
;	3736	
;	3737				[dsc$k_dtype_wu, dsc$k_dtype_w]:
;	3738					2;
;	3739	
;	3740	
;	3741				[dsc$k_dtype_d, dsc$k_dtype_dc]:
;	3742					8;
;	3743	
;	3744	
;	3745				[INRANGE, OUTRANGE]:
;	3746					4;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-7
; Digital Equipment Corporation
;
;	3747	
;	3748				TES))
;	3749		THEN
;	3750			BEGIN
;	3751	
;	3752			!++
;	3753			! If the write fails, signal a fatal error for this command.
;	3754			!--
;	3755			SIGNAL (dbg$_noaccessw, 1, .deposit_loc);
;	3756			RETURN
;	3757			END;
;	3758	
;	3759		!++
;	3760		! Now set the next location to be examined or deposited,
;	3761		! again dependent upon the data type.
;	3762		!--
;	3763		dbg$gl_next_loc = 
;	3764			(CASE .nt_ptr [nt_type] FROM dsc$k_dtype_v
;	3765						  TO dsc$k_dtype_dc
;	3766	
;	3767				OF
;	3768				SET
;	3769	
;	3770				[dsc$k_dtype_v, dsc$k_dtype_bu, dsc$k_dtype_b]:
;	3771					.deposit_loc + 1;
;	3772	
;	3773	
;	3774				[dsc$k_dtype_wu, dsc$k_dtype_w]:
;	3775					.deposit_loc + 2;
;	3776	
;	3777	
;	3778				[dsc$k_dtype_d, dsc$k_dtype_dc]:
;	3779					.deposit_loc + 8;
;	3780	
;	3781	
;	3782				[INRANGE, OUTRANGE]:
;	3783					.deposit_loc + 4;
;	3784	
;	3785				TES);
;	3786	
;	3787		RETURN TRUE
;	3788	END;





					 001C 005C9 SYMBOL_DEPOSIT:
							    .WORD   Save R2,R3,R4					      ; 3362
		         5E	       10  C2 005CB 	    SUBL2   #16, SP						      ;
		         52	  0C   AC  D0 005CE 	    MOVL    SYMBOL_NT_PTR, NT_PTR				      ; 3450
				       14  12 005D2 	    BNEQ    1$							      ;
				  04   AE  9F 005D4 	    PUSHAB  SAT_PTR						      ; 3463
				  04   AC  DD 005D7 	    PUSHL   DEPOSIT_LOC						      ;
	      00000000G  EF	       02  FB 005DA 	    CALLS   #2, DBG$VAL_TO_SAT					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-8
; Digital Equipment Corporation
;
		         32	       50  E9 005E1 	    BLBC    R0, 2$						      ;
		         52	  04   BE  3C 005E4 	    MOVZWL  @SAT_PTR, NT_PTR					      ; 3468
				4004   8F  BB 005E8 1$:     PUSHR   #^M<R2,SP>						      ; 3482
	      00000000G  EF	       02  FB 005EC 	    CALLS   #2, DBG$SYMBOL_VALU					      ;
		         20	       50  E9 005F3 	    BLBC    R0, 2$						      ;
		         54	  04   AC  D0 005F6 	    MOVL    DEPOSIT_LOC, R4					      ; 3488
		         6E	       54  D1 005FA 	    CMPL    R4, REAL_VALUE					      ;
				       38  13 005FD 	    BEQL    4$							      ;
			    00000000G  E2  B5 005FF 	    TSTW    DBG$_RST_BEGIN+8(NT_PTR)				      ; 3500
				       0F  13 00605 	    BEQL    2$							      ;
		         50 00000000G  E2  D0 00607 	    MOVL    DBG$_RST_BEGIN+4(NT_PTR), DST_RECRD			      ; 3504
      02   A0	         02	       00  ED 0060E 	    CMPZV   #0, #2, 2(DST_RECRD), #2				      ; 3505
				       02     00613									      ;
				       03  13 00614 	    BEQL    3$							      ;
				     0161  31 00616 2$:     BRW     32$							      ;
				  08   AE  9F 00619 3$:     PUSHAB  BOUNDS						      ; 3514
				  04   AE  DD 0061C 	    PUSHL   REAL_VALUE						      ;
	      00000000G  EF	       02  FB 0061F 	    CALLS   #2, DBG$GET_BOUNDS					      ;
		    08   AE	       54  D1 00626 	    CMPL    R4, BOUNDS						      ; 3522
				       EA  1F 0062A 	    BLSSU   2$							      ;
	   50	    08   AE	  0C   AE  C1 0062C 	    ADDL3   BOUNDS+4, BOUNDS, R0				      ; 3527
		         50	       54  D1 00632 	    CMPL    R4, R0						      ;
				       DF  1E 00635 	    BGEQU   2$							      ;
		         53 00000000G  E2  9E 00637 4$:     MOVAB   DBG$_RST_BEGIN(NT_PTR), R3				      ; 3546
				  02   A3  95 0063E 	    TSTB    2(R3)						      ;
				       D3  1B 00641 	    BLEQU   2$							      ;
		         0D	  02   A3  91 00643 	    CMPB    2(R3), #13						      ; 3547
				       CD  1A 00647 	    BGTRU   2$							      ;
		         52	  08   AC  D0 00649 	    MOVL    VALUE_PTR, R2					      ; 3640
	   03	         0A	  02   A3  8F 0064D 	    CASEB   2(R3), #10, #3					      ; 3555
	 002A	       004C	     002A     00652 5$:     .WORD   7$-5$,-						      ;
				     004C     00658		    9$-5$,-						      ;
								    7$-5$,-						      ;
								    9$-5$						      ;
		         0A	  08   A2  D1 0065A 	    CMPL    8(R2), #10						      ; 3640
				       0B  12 0065E 	    BNEQ    6$							      ;
				       52  DD 00660 	    PUSHL   R2							      ; 3649
	      00000000G  EF	       01  FB 00662 	    CALLS   #1, DBG$CNV_F_TO_L					      ;
				       53  11 00669 	    BRB     11$							      ; 3640
		         0B	  08   A2  D1 0066B 6$:     CMPL    8(R2), #11						      ; 3658
				       4D  12 0066F 	    BNEQ    11$							      ;
				       52  DD 00671 	    PUSHL   R2							      ; 3667
	      00000000G  EF	       01  FB 00673 	    CALLS   #1, DBG$CNV_D_TO_L					      ;
				       42  11 0067A 	    BRB     11$							      ; 3555
		         08	  08   A2  D1 0067C 7$:     CMPL    8(R2), #8						      ; 3562
				       0B  12 00680 	    BNEQ    8$							      ;
				       52  DD 00682 	    PUSHL   R2							      ; 3571
	      00000000G  EF	       01  FB 00684 	    CALLS   #1, DBG$CNV_L_TO_F					      ;
				       31  11 0068B 	    BRB     11$							      ; 3562
		         0B	  08   A2  D1 0068D 8$:     CMPL    8(R2), #11						      ; 3580
				       2B  12 00691 	    BNEQ    11$							      ;
				       52  DD 00693 	    PUSHL   R2							      ; 3589
	      00000000G  EF	       01  FB 00695 	    CALLS   #1, DBG$CNV_D_TO_F					      ;
				       20  11 0069C 	    BRB     11$							      ; 3555
		         08	  08   A2  D1 0069E 9$:     CMPL    8(R2), #8						      ; 3601

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-9
; Digital Equipment Corporation
;
				       0B  12 006A2 	    BNEQ    10$							      ;
				       52  DD 006A4 	    PUSHL   R2							      ; 3610
	      00000000G  EF	       01  FB 006A6 	    CALLS   #1, DBG$CNV_L_TO_D					      ;
				       0F  11 006AD 	    BRB     11$							      ; 3601
		         0A	  08   A2  D1 006AF 10$:    CMPL    8(R2), #10						      ; 3619
				       09  12 006B3 	    BNEQ    11$							      ;
				       52  DD 006B5 	    PUSHL   R2							      ; 3628
	      00000000G  EF	       01  FB 006B7 	    CALLS   #1, DBG$CNV_F_TO_D					      ;
	   06	         01	  02   A3  8F 006BE 11$:    CASEB   2(R3), #1, #6					      ; 3684
	 001C	       0017	     0010     006C3 12$:    .WORD   13$-12$,-						      ;
	 0021	       0029	     0029     006C9		    14$-12$,-						      ;
				     0026     006CF		    15$-12$,-						      ;
								    18$-12$,-						      ;
								    18$-12$,-						      ;
								    16$-12$,-						      ;
								    17$-12$						      ;
				       19  11 006D1 	    BRB     18$							      ;
	   62	         01	       00  EF 006D3 13$:    EXTZV   #0, #1, (R2), (R2)					      ; 3690
				       62     006D7									      ;
				       12  11 006D8 	    BRB     18$							      ; 3684
		         62	       62  9A 006DA 14$:    MOVZBL  (R2), (R2)						      ; 3694
				       0D  11 006DD 	    BRB     18$							      ; 3684
		         62	       62  3C 006DF 15$:    MOVZWL  (R2), (R2)						      ; 3698
				       08  11 006E2 	    BRB     18$							      ; 3684
		         62	       62  98 006E4 16$:    CVTBL   (R2), (R2)						      ; 3702
				       03  11 006E7 	    BRB     18$							      ; 3684
		         62	       62  32 006E9 17$:    CVTWL   (R2), (R2)						      ; 3706
	   0C	         01	  02   A3  8F 006EC 18$:    CASEB   2(R3), #1, #12					      ; 3727
	 0022	       001E	     001E     006F1 19$:    .WORD   21$-19$,-						      ;
	 001E	       001A	     001A     006F7		    21$-19$,-						      ;
	 001A	       001A	     0022     006FD		    22$-19$,-						      ;
	 001A	       0026	     001A     00703		    20$-19$,-						      ;
				     0026     00709		    20$-19$,-						      ;
								    21$-19$,-						      ;
								    22$-19$,-						      ;
								    20$-19$,-						      ;
								    20$-19$,-						      ;
								    20$-19$,-						      ;
								    23$-19$,-						      ;
								    20$-19$,-						      ;
								    23$-19$						      ;
				       04  DD 0070B 20$:    PUSHL   #4							      ;
				       0A  11 0070D 	    BRB     24$							      ;
				       01  DD 0070F 21$:    PUSHL   #1							      ;
				       06  11 00711 	    BRB     24$							      ;
				       02  DD 00713 22$:    PUSHL   #2							      ;
				       02  11 00715 	    BRB     24$							      ;
				       08  DD 00717 23$:    PUSHL   #8							      ;
				       52  DD 00719 24$:    PUSHL   R2							      ; 3726
				       54  DD 0071B 	    PUSHL   R4							      ;
	      00000000G  EF	       03  FB 0071D 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         13	       50  E8 00724 	    BLBS    R0, 25$						      ;
				       54  DD 00727 	    PUSHL   R4							      ; 3755
				       01  DD 00729 	    PUSHL   #1							      ;
			    000282B0   8F  DD 0072B 	    PUSHL   #164528						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 11-10
; Digital Equipment Corporation
;
	      00000000G  00	       03  FB 00731 	    CALLS   #3, LIB$SIGNAL					      ;
				       40  11 00738 	    BRB     32$							      ; 3756
	   0C	         01	  02   A3  8F 0073A 25$:    CASEB   2(R3), #1, #12					      ; 3764
	 0026	       0020	     0020     0073F 26$:    .WORD   28$-26$,-						      ;
	 0020	       001A	     001A     00745		    28$-26$,-						      ;
	 001A	       001A	     0026     0074B		    29$-26$,-						      ;
	 001A	       002C	     001A     00751		    27$-26$,-						      ;
				     002C     00757		    27$-26$,-						      ;
								    28$-26$,-						      ;
								    29$-26$,-						      ;
								    27$-26$,-						      ;
								    27$-26$,-						      ;
								    27$-26$,-						      ;
								    30$-26$,-						      ;
								    27$-26$,-						      ;
								    30$-26$						      ;
	   50	         54	       04  C1 00759 27$:    ADDL3   #4, R4, R0						      ; 3783
				       10  11 0075D 	    BRB     31$							      ; 3764
	   50	         54	       01  C1 0075F 28$:    ADDL3   #1, R4, R0						      ; 3771
				       0A  11 00763 	    BRB     31$							      ; 3764
	   50	         54	       02  C1 00765 29$:    ADDL3   #2, R4, R0						      ; 3775
				       04  11 00769 	    BRB     31$							      ; 3764
	   50	         54	       08  C1 0076B 30$:    ADDL3   #8, R4, R0						      ; 3779
	      00000000G  EF	       50  D0 0076F 31$:    MOVL    R0, DBG$GL_NEXT_LOC					      ; 3763
		         50	       01  D0 00776 	    MOVL    #1, R0						      ; 3787
					   04 00779 	    RET     							      ;
				       50  D4 0077A 32$:    CLRL    R0							      ; 3362
					   04 0077C 	    RET     							      ;

; Routine Size:  436 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 12
; Digital Equipment Corporation
;
;	3789	ROUTINE output_psl (value, buffer) : NOVALUE =
;	3790	
;	3791	!++
;	3792	! FUNCTIONAL DESCRIPTION:
;	3793	!	Formats and outputs two lines of specially
;	3794	!	formatted data contained in the PSL. The fields shown are
;	3795	!
;	3796	!		CMP	- compatibility mode
;	3797	!		TP	- trace trap pending
;	3798	!		FPD	- first part done
;	3799	!		IS	- interrupt stack
;	3800	!		CURMOD	- current access mode
;	3801	!		PRVMOD	- previous access mode
;	3802	!		IPL	- interrupt priority level
;	3803	!		DV	- decimal overflow trap enable
;	3804	!		FU	- floating underflow trap enable
;	3805	!		IV	- integer overflow trap enable
;	3806	!		T	- trace trap
;	3807	!		N	- condition code
;	3808	!		Z	- condition code
;	3809	!		V	- condition code
;	3810	!		C	- condition code
;	3811	!
;	3812	! CALLING SEQUENCE:
;	3813	!	output_psl ()
;	3814	!
;	3815	! INPUTS:
;	3816	!	value	-The current contents of the PSL
;	3817	!
;	3818	! IMPLICIT INPUTS:
;	3819	!	NONE
;	3820	!
;	3821	! OUTPUTS:
;	3822	!	NONE
;	3823	!
;	3824	! IMPLICIT OUTPUTS:
;	3825	!	NONE
;	3826	!
;	3827	! ROUTINE value:
;	3828	!	NOVALUE
;	3829	!
;	3830	! SIDE EFFECTS:
;	3831	!	Two lines are output to the output device.
;	3832	!--
;	3833	
;	3834	BEGIN
;	3835		MAP
;	3836			value: BLOCK;
;	3837		MACRO
;	3838			position_field	= 0, 8, 1%,
;	3839			size_field	= 8, 8, 1%,
;	3840			mode_field	= 16, 4, 1%,
;	3841			blanks_field	= 20, 4, 1%,
;	3842			width_field	= 24, 8, 1%,
;	3843	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 12-1
; Digital Equipment Corporation
;
;	3844			psl_field (name, position, size, mode, width, leading_blanks) =
;     M 3845				position, size, mode OR (leading_blanks ^ 4), width%;
;	3846	
;	3847		LITERAL
;	3848			decimal		= 0,
;	3849			max_psl_field	= 15;
;	3850	
;	3851		BIND
;	3852			psl_table = UPLIT BYTE (
;	3853	
;	3854			psl_field (CMP, 31, 1, 0, 1, 1),
;	3855			psl_field (TP, 30, 1, 0, 1, 3),
;	3856			psl_field (FPD, 27, 1, 0, 1, 2),
;	3857			psl_field (IS, 26, 1, 0, 1, 3),
;	3858			psl_field (CURMOD, 24, 2, 1, 4, 2),
;	3859			psl_field (PRVMOD, 22, 2, 1, 4, 3),
;	3860			psl_field (IPL, 16, 5, 0, 2, 3),
;	3861			psl_field (DV, 7, 1, 0, 1, 2),
;	3862			psl_field (FU, 6, 1, 0, 1, 2),
;	3863			psl_field (IV, 5, 1, 0, 1, 2),
;	3864			psl_field (T, 4, 1, 0, 1, 1),
;	3865			psl_field (N, 3, 1, 0, 1, 1),
;	3866			psl_field (Z, 2, 1, 0, 1, 1),
;	3867			psl_field (V, 1, 1, 0, 1, 1),
;	3868			psl_field (C, 0, 1, 0, 1, 1))
;	3869	
;	3870			: BLOCK,
;	3871	
;	3872			hex_number	= UPLIT BYTE (%ASCIC '!AD!#XB'),
;	3873			stg_desc	= UPLIT BYTE (%ASCIC '!AD!AD'),
;	3874			blanks		= UPLIT BYTE (%ASCII '    '),
;	3875	
;	3876			priv_modes	= UPLIT BYTE (
;	3877	
;	3878			%ASCII 'KERN',
;	3879			%ASCII 'EXEC',
;	3880			%ASCII 'SUPR',
;	3881			%ASCII 'USER')
;	3882	
;	3883			: VECTOR;
;	3884	
;	3885		! Write out the standard title which describes the PSL fields.
;	3886	
;	3887		dbg$fao_put (UPLIT (%ASCIC '  CMP TP FPD IS CURMOD PRVMOD IPL DV FU IV T N Z V C'));
;	3888		dbg$out_put (.buffer);
;	3889		dbg$cp_out_str = .buffer + 1;
;	3890		dbg$gl_buf_siz = 0;
;	3891		dbg$fao_put (UPLIT (%ASCIC '!_'));
;	3892		INCR count FROM 0 TO max_psl_field - 1 DO
;	3893			IF .psl_table [.count, mode_field] EQL decimal
;	3894			THEN
;	3895				BEGIN
;	3896	%IF dbg_exa3
;     L 3897	%THEN
;     U 3898				$fao_tt_out ('!/!XL', .value [0,

; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 12-2
; Digital Equipment Corporation
;
;     U 3899					.psl_table [.count, position_field],
;     U 3900					.psl_table [.count, size_field], 0]);
;     U 3901	%FI
;	3902				dbg$fao_put (hex_number,
;	3903					.psl_table [.count, blanks_field], blanks,
;	3904					.psl_table [.count, width_field],
;	3905					.value [0, .psl_table [.count, position_field],
;	3906					.psl_table [.count, size_field], 0]);
;	3907				END
;	3908			ELSE
;	3909				BEGIN
;	3910	%IF dbg_exa3
;     L 3911	%THEN
;     U 3912				$fao_tt_out ('!/!XL', .value [0,
;     U 3913					.psl_table [.count, position_field],
;     U 3914					.psl_table [.count, size_field], 0]);
;     U 3915	%FI
;	3916				dbg$fao_put (stg_desc,
;	3917					.psl_table [.count, blanks_field], blanks,
;	3918					.psl_table [.count, width_field],
;	3919					priv_modes [.value [0, .psl_table [.count, position_field],
;	3920						.psl_table [.count, size_field], 0]]);
;	3921				END;
;	3922	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      0005C P.AAH:  .BYTE   31, 1, 16, 1, 30, 1, 48, 1, 27, 1, 32, 1, 26, 1, 48, 1, - ;
								    24, 2, 33, 4, 22, 2, 49, 4, 16, 5, 48, 2, 7, 1, 32, 1, -  ;
								    6, 1, 32, 1, 5, 1, 32, 1, 4, 1, 16, 1, 3, 1, 16, 1, 2, -  ;
								    1, 16, 1, 1, 1, 16, 1, 0, 1, 16, 1			      ;
					      00098 P.AAI:  .ASCII  <7>\!AD!#XB\					      ;
					      000A0 P.AAJ:  .ASCII  <6>\!AD!AD\						      ;
					      000A7	    .BLKB   1
					      000A8 P.AAK:  .ASCII  \    \						      ;
					      000AC P.AAL:  .ASCII  \KERN\						      ;
					      000B0 	    .ASCII  \EXEC\						      ;
					      000B4 	    .ASCII  \SUPR\						      ;
					      000B8 	    .ASCII  \USER\						      ;
					      000BC P.AAM:  .ASCII  \4  CMP TP FPD IS CURMOD PRVMOD IPL DV FU IV T N Z V C-   ;
								    \<0>						      ;
					      000F2 	    .ASCII  <0><0>						      ;
					      000F4 P.AAN:  .ASCII  <2>\!_\<0>						      ;

						    PSL_TABLE=		P.AAH
						    HEX_NUMBER=		P.AAI
						    STG_DESC=		P.AAJ
						    BLANKS=		P.AAK
						    PRIV_MODES=		P.AAL


							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0


; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 12-3
; Digital Equipment Corporation
;
					 0C0C 0077D OUTPUT_PSL:
							    .WORD   Save R2,R3,R10,R11					      ; 3789
		         5A 00000000G  EF  9E 0077F 	    MOVAB   DBG$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 00786 	    MOVAB   BLANKS, R11						      ;
				  14   AB  9F 0078D 	    PUSHAB  P.AAM						      ; 3887
		         6A	       01  FB 00790 	    CALLS   #1, DBG$FAO_PUT					      ;
				  08   AC  DD 00793 	    PUSHL   BUFFER						      ; 3888
	      00000000G  EF	       01  FB 00796 	    CALLS   #1, DBG$OUT_PUT					      ;
00000000G  EF	    08   AC	       01  C1 0079D 	    ADDL3   #1, BUFFER, DBG$CP_OUT_STR				      ; 3889
			    00000000G  EF  D4 007A6 	    CLRL    DBG$GL_BUF_SIZ					      ; 3890
				  4C   AB  9F 007AC 	    PUSHAB  P.AAN						      ; 3891
		         6A	       01  FB 007AF 	    CALLS   #1, DBG$FAO_PUT					      ;
				       53  D4 007B2 	    CLRL    COUNT						      ; 3892
		         52	  B4 AB43  DE 007B4 1$:     MOVAL   PSL_TABLE[COUNT], R2				      ; 3893
		         0F	  02   A2  93 007B9 	    BITB    2(R2), #15						      ;
				       1A  12 007BD 	    BNEQ    2$							      ;
		         50	       62  98 007BF 	    CVTBL   (R2), R0						      ; 3905
      04   AC	    01   A2	       50  EF 007C2 	    EXTZV   R0, 1(R2), VALUE, -(SP)				      ;
				       7E     007C8									      ;
		         7E	  03   A2  98 007C9 	    CVTBL   3(R2), -(SP)					      ; 3902
				       5B  DD 007CD 	    PUSHL   R11							      ; 3789
	   62	         04	       14  EE 007CF 	    EXTV    #20, #4, (R2), -(SP)				      ; 3902
				       7E     007D3									      ;
				  F0   AB  9F 007D4 	    PUSHAB  HEX_NUMBER						      ; 3789
				       1C  11 007D7 	    BRB     3$							      ; 3902
		         51	       62  98 007D9 2$:     CVTBL   (R2), R1						      ; 3919
      04   AC	    01   A2	       51  EF 007DC 	    EXTZV   R1, 1(R2), VALUE, R0				      ;
				       50     007E2									      ;
				  04 AB40  DF 007E3 	    PUSHAL  PRIV_MODES[R0]					      ; 3920
		         7E	  03   A2  98 007E7 	    CVTBL   3(R2), -(SP)					      ; 3916
				       5B  DD 007EB 	    PUSHL   R11							      ; 3789
	   62	         04	       14  EE 007ED 	    EXTV    #20, #4, (R2), -(SP)				      ; 3916
				       7E     007F1									      ;
				  F8   AB  9F 007F2 	    PUSHAB  STG_DESC						      ; 3789
		         6A	       05  FB 007F5 3$:     CALLS   #5, DBG$FAO_PUT					      ; 3916
	   B8	         53	       0E  F3 007F8 	    AOBLEQ  #14, COUNT, 1$					      ; 3892
					   04 007FC 	    RET     							      ; 3789

; Routine Size:  128 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:15:06	DBB3:[DEBUG.SRC]DBGEXA.B32;7					Page 13
; Digital Equipment Corporation
;
;	3923	END
;	3924	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  DBG$PLIT       	   248  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  DBG$CODE       	  2045  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        17         0       224






;			COMPILER INTERNAL TIMING

;	Phase	    Faults	Cpu-time      Elapsed-time
;	LEXSYN	     1061	00:44.2		01:23.4
;	FLOWAN	       86	00:06.4		00:11.2
;	DELAY	       50	00:02.6		00:04.4
;	TNBIND	       77	00:03.9		00:06.6
;	CODE	      117	00:08.0		00:17.5
;	FINAL	      212	00:13.6		00:23.2
;	Total	     1603	01:18.7		02:26.2

; Size:		2045 code + 248 data bytes
; Run Time:	01:19.3
; Elapsed Time:	02:27.1
; Memory Used:	434 pages
; Compilation Complete
