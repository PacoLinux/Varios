
; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DBGMAC ( ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE),
;	0002			IDENT = '000027') =
;	0003	BEGIN
;	0004	
;	0005	!++
;	0006	!
;	0007	! Copyright (C) 1976, 1977
;	0008	! Digital Equipment Corporation,  Maynard, Massachusetts  01754
;	0009	!
;	0010	! This software is furnished under a license for use only on  a
;	0011	! single computer system and may be copied only with the inclu-
;	0012	! sion of the above copyright notice.  This  software,  or  any
;	0013	! other  copies  thereof, may not be provided or otherwise made
;	0014	! available to any other person except for use on  such  system
;	0015	! and  to  one who agrees to these license terms.  Title to and
;	0016	! ownership of the software shall at all times remain in DEC.
;	0017	!
;	0018	! The information in this software is subject to change without
;	0019	! notice and should not be construed as a commitment by Digital
;	0020	! Equipment Corporation.
;	0021	!
;	0022	! DEC assumes no responsibility for the use or  reliability  of
;	0023	! its software on equipment which is not supplied by DEC.
;	0024	!
;	0025	! FACILITY:
;	0026	!	VAX INSTRUCTION DECODER.
;	0027	!
;	0028	! Version:	27
;	0029	!
;	0030	! History:
;	0031	!	Author:
;	0032	!		KEVIN PAMMETT, 2-MAR-77: Version 01
;	0033	!
;	0034	!	Modified by:
;	0035	!		Dale Roedger, 31-May-1978:	27
;	0036	!
;	0037	! Revision history:
;	0038	!	01	21-MAR-77	KGP	-INITIAL ADDITION OF THIS TO DEBUG
;	0039	!	02	24-MAR-77	KGP	-REMOVED 'COUNTED STRING' MACRO, AND
;	0040	!					AND GENERALLY CLEANED UP MODULE FORMAT.
;	0041	!					ALSO ADDED CONV_R_50 TO HERE SO THAT
;	0042	!					WON'T HAVE TO BE GLOBAL.
;	0043	!	03	31-MAR-77	KGP	-MORE CLEANUP OF MODULE.
;	0044	!					CHANGED OUTPUT BUFFER POINTER
;	0045	!					TO BE CALLED DBG$CP_OUT_STR, AND
;	0046	!					TO BE DEFINED IN DBGSTO.B32
;	0047	!	04	04-APR-77	KGP	-MORE CLEANUP, AND CHANGED THE
;	0048	!					REQUIRE TO BE TO *.BEG FOR ALL FILES
;	0049	!					(WE NO LONGER USE *.REQ AT ALL).
;	0050	!	05	05-apr-77	kgp	-Took out routine dbg$fao_put
;	0051	!					because it belongs in DBGSSV.B32
;	0052	!					-Also added calls to the
;	0053	!					 new routine DBG$OUT_VALUE so that any
;	0054	!					 numbers which are 'output' will be 
;	0055	!					 done so in the proper LENGTH and RADIX.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 1-1
; Digital Equipment Corporation
;
;	0056	!	06	06-apr-77	kgp	-Added another parameter to DISPLCAEMENT
;	0057	!					so that it can pass back the byte size
;	0058	!					of a displacement so that FAO can
;	0059	!					print it as it actually is, as opposed
;	0060	!					to always printing it LONGword-extended.
;	0061	!	07	14-04-77	CP	Add variable DBG$GL_BUF_SIZ to
;	0062	!					hold count in output buffer.
;	0063	!	08	20-04-77	CP	Add DBGPCT.BEG for declarations
;	0064	!					of PSECTs. Change VAXDEB.BEG to
;	0065	!					be named DBGGEN.BEG.
;	0066	!	09	29-04-77	CP	Remove routine CONV_R_50 and
;	0067	!					move it to DBGCON. Remove global
;	0068	!					DBG$GL_OPCODE and move to DBGSTO.
;	0069	!	10	05-MAY-77	KGP	-Changed routine DBG$INS_OPERAND so
;	0070	!					 that it knows about (and outputs!) the
;	0071	!					 MARS notion of B^, W^, and D^ before
;	0072	!					 displacements.
;	0073	!					-Also changed the numeric output code
;	0074	!					 for literals and displacements so that a
;	0075	!					 leading 0 is output if the next character
;	0076	!					 is a hex alphabetic.
;	0077	!					-Also removed the global DBG$GL_OPCODE
;	0078	!					 and added another parameter to BRANCH_TYPE,
;	0079	!					 DISPLACEMENT, INS_CONTEXT, and DBG$INS_OPERAND
;	0080	!					 so that we no longer need this as a global.
;	0081	!	11	05-may-77	KGP	-Changed BRANCH_TYPE so that it prints
;	0082	!					 out .+val or .-val for branch operands.
;	0083	!					 (Before it only knew about +).  Also,
;	0084	!					 we now print out the absolute branch
;	0085	!					 operand in the form: (=val)
;	0086	!					 This last 1+ added 90. bytes of code!
;	0087	!	12	18-may-77	KGP	-Version 3x22.  Here we added code to
;	0088	!					 check for READ access just before
;	0089	!					 we access each byte of the supposed
;	0090	!					 instruction.
;	0091	!					-We also scrapped DBG$OUT_OPCODE and
;	0092	!					 put the code in-line in DBG$INS_DECODE.
;	0093	!	13	19-may-77	KGP	-Took the read-access check code,
;	0094	!					 which I had later made into a routine,
;	0095	!					 and put it into DBGSSV.B32
;	0096	!	14	28-JUN-77	KGP	-Added a 2nd parameter to PUT_REG and
;	0097	!					took away the routine PUT_AT_REG to
;	0098	!					make all of this clearer and save some
;	0099	!					code space.  (PUT_REG was called PUTREG)
;	0100	!					-Added conditional compilation for all
;	0101	!					the non-mars stuff which we may print
;	0102	!					out.  Also added the routine which does
;	0103	!					this output, OUT_EXTRA_INFO.
;	0104	!	15	01-july-77	KGP	-Changed the output of operands
;	0105	!					 which use PC-displacement modes
;	0106	!					 since we now support <number> as
;	0107	!					 operands.  See the new conditional compilation
;	0108	!					 literal, DBG_EFFECTIVE.
;	0109	!	16	2-nov-77	KGP	-Added code to special-case CASE
;	0110	!					 instructions so that we can print

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 1-2
; Digital Equipment Corporation
;
;	0111	!					 out the 'data' which follows CASE
;	0112	!					 in the instruction stream, and so that
;	0113	!					 we can find the next instruction properly
;	0114	!					 after CASE.
;	0115	!					-Also made up OUT_BRNCH_OPRND, and added 
;	0116	!					 the OUTPUT_BUFFER parameter to INS$ENCODE
;	0117	!					 (and the corresponding OWN OUT_BUF_PTR)
;	0118	!					 all so that we can handle mulit-line
;	0119	!					 output of instructions.
;	0120	!	17	07-11-77	CP	Change a_longword to 4 and
;	0121	!					a_byte to 1.
;	0122	!	18	8-nov-77	KGP	-Integrated this with sym_to_val.
;	0123	!					 Took out all calls to DBG$OUT_VALUE
;	0124	!	19	4-jan-78	KGP	-Fix in OUT_BRNCH_OPRND as we printed
;	0125	!					 negative branch operands as tho they
;	0126	!					 were positive ones.
;	0127	!	20	06-JAN-78	DAR	Switched order of require files DBGGEN.
;	0128	!					BEG and VAXOPS.BEG so that X_length
;	0129	!					is defined before it is used.
;	0130	!	21	02-MAR-78	DAR	Removed leading CRLF directives in FAO
;	0131	!					control strings.
;	0132	!	22	28-MAR-78	KGP	-THE @# ADDRESSING MODE NOW
;	0133	!					TRIES TO SYMBOLIZE THE OPERAND.
;	0134	!	23	20-apr-78	KGP	-Changed INS_DECODE so that no
;	0135	!					 output buffer is assumed if the
;	0136	!					 OUTPUT_BUFFER parameter to INS_DECODE
;	0137	!					 is given as 0.
;	0138	!	24	03-may-78	KGP	-Modified REQUIRE and LIBRARY directives
;	0139	!					 for the native build.  (a retro-fit)
;	0140	!	25	17-may-78	KGP	-we now put out only the effective
;	0141	!					 operand for branch and CASE operands.
;	0142	!					 This allowed me to delete routines
;	0143	!					 out_brnch_oprnd and out_extra_info
;	0144	!					-Deleted all code to output a leading
;	0145	!					 0 in hex numbers - out_num_val now
;	0146	!					 does this once and for all.
;	0147	!	26	18-may-78	KGP	-Fixed bug in INS_OPERAND - we now
;	0148	!					 set CASE_FLAG only on the 3rd operand.
;	0149	!	27	31-MAY-78	DAR	Removed temporary-buffer for use when
;	0150	!					"output_buffer" is 0 in DBG$INS_DECODE
;	0151	!					this routine now signals errors if the
;	0152	!					parameter is non-zero.
;	0153	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 2
; Digital Equipment Corporation
;
;	0154	! TABLE OF CONTENTS:
;	0155	!
;	0156	FORWARD ROUTINE
;	0157		DBG$INS_DECODE,		! DECODE AN INSTRUCTION.
;	0158		ins_operand,		! PRINT OUT AN OPERAND REFERENCE.
;	0159		DISPLACEMENT,		! ROUTINE TO EXTRACT DISPLACEMENTS FROM INSTRUCTIONS.
;	0160		BRANCH_TYPE,		! DECIDE AND HANDLE BRANCH TYPE addressing.
;	0161		INS_CONTEXT,		! DECIDE WHAT CONTEXT THIS INSTRUCTION IS.
;	0162		PUT_REG : NOVALUE;		! PRINT A REGISTER REFERENCE.
;	0163	
;	0164	!+
;	0165	! Require and Library files:
;	0166	!-
;	0167	
;	0168	%IF %VARIANT		! True for TEN
;     L 0169	%THEN
;     U 0170	LIBRARY 'NEW:STARLE.L32';
;     U 0171	REQUIRE 'DBGPCT.REQ';
;     U 0172	REQUIRE 'DBGGEN.REQ';		! REQUIRE FILE FOR DEBUG FACILITY.
;     U 0173	REQUIRE 'VAXOPS.REQ';		! LITERALS AND MACROS RELATED TO OPCODES
;     U 0174	REQUIRE 'SYSLIT.REQ';		! LITERALS NEEDED TO CALL SYSTEM SERVICES.
;     U 0175	REQUIRE 'VXSMAC.REQ';		! WIDELY-USED STANDARD LITERALS.
;     U 0176	REQUIRE 'SYSSER.REQ';		! the diagnostic facility.
;     U 0177	REQUIRE 'DBGMSG.REQ';		! Error message file
;     U 0178	%ELSE
;	0179	LIBRARY 'SYS$LIBRARY:STARLET.L32';
;	0180	REQUIRE 'SRC$:DBGPCT.REQ';
;	0192	REQUIRE 'SRC$:DBGGEN.REQ';		! REQUIRE FILE FOR DEBUG FACILITY.
;	0442	REQUIRE 'SRC$:VAXOPS.REQ';		! LITERALS AND MACROS RELATED TO OPCODES
;	0630	REQUIRE 'SRC$:SYSLIT.REQ';		! LITERALS NEEDED TO CALL SYSTEM SERVICES.
;	0653	REQUIRE 'SRC$:VXSMAC.REQ';		! WIDELY-USED STANDARD LITERALS.
;	0693	REQUIRE 'SRC$:SYSSER.REQ';		! the diagnostic facility.
;      R0696	SWITCHES LIST (SOURCE);
;      R0697	
;      R0698	EXTERNAL ROUTINE
;      R0699		dbg$fao_out;				! formats a line and outputs to the terminal
;      R0700	
;      R0701	SWITCHES LIST (NOSOURCE);
;	0746	REQUIRE 'LIB$:DBGMSG.REQ';			! Error message file
;	1025	%FI
;	1026	
;	1027	EXTERNAL ROUTINE
;	1028		DBG$CONV_R_50,			! convert from RAD50
;	1029		DBG$FAO_PUT : NOVALUE,		! FORMATTED I/O TO TERMINAL.
;	1030		DBG$OUT_NUM_VAL : NOVALUE,	! Output values as numerics.
;	1031		DBG$OUT_SYM_VAL : NOVALUE,	! Output values as numerics or symbols.
;	1032		DBG$OUT_PUT : NOVALUE,		! Flush the output buffer.
;	1033		DBG$READ_ACCESS;		! Probe for read accessability.
;	1034	
;	1035	EXTERNAL
;	1036		DBG$CP_OUT_STR : REF VECTOR[,BYTE],	! POINTS TO CURRENT OUTPUT BUFFER.
;	1037		DBG$GB_OPINFO : BLOCKVECTOR[ MAXOPCODE, OPTSIZE, BYTE ],
;	1038		DBG$GB_MOD_PTR : REF VECTOR[,BYTE],	! MODE DATA STRUCTURE POINTER.
;	1039		DBG$GL_BUF_SIZ,				! Holds character count of output buffer
;	1040		DBG$GL_LAST_VAL;			! BRANCH INSTRUCTIONS OVERWRITE THIS SO THAT

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 2-1
; Digital Equipment Corporation
;
;	1041							! THE USER CAN "EX \" TO TRACE THRU A BRANCH.
;	1042	
;	1043	!+
;	1044	! EQUATED SYMBOLS:
;	1045	!-
;	1046	
;	1047	LITERAL
;	1048		DBG_MAC		= 0;	! Diagnostics for CASE instructions
;	1049	
;	1050	LITERAL
;	1051		ROUND_BRACKETS	= 0,	! These are all flag parameters to
;	1052		SQUARE_BRACKETS	= 2,	!    the routine 'PUT_REG'.
;	1053		NO_BRACKETS	= 1;
;	1054	
;	1055	MACRO
;	1056		PUTC(C)	= ! PUT 1 CHAR INTO THE OUTPUT BUFFER
;     M 1057			BEGIN
;     M 1058			IF .DBG$CP_OUT_STR NEQ 0
;     M 1059			THEN
;     M 1060			    BEGIN
;     M 1061			    (.DBG$CP_OUT_STR)<0,8> = C;
;     M 1062			    DBG$CP_OUT_STR = .DBG$CP_OUT_STR + 1;
;     M 1063			    DBG$GL_BUF_SIZ = .DBG$GL_BUF_SIZ + 1;
;     M 1064			    END;
;     M 1065			END %;
;	1066	
;	1067	!+
;	1068	! OWN storage.
;	1069	!-
;	1070	
;	1071	OWN
;	1072		CASE_FLAG;		! Allows us to special-case CASE instructions.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 3
; Digital Equipment Corporation
;
;	1073	GLOBAL ROUTINE DBG$INS_DECODE( STREAM_PNTR, OUTPUT_BUFFER ) =
;	1074	
;	1075	!++
;	1076	! 
;	1077	! FUNCTIONAL DESCRIPTION:
;	1078	!	THIS ROUTINE IS THE 'ENTRY POINT' FOR THIS MODULE.
;	1079	!
;	1080	!	THIS ROUTINE EXAMINES A BYTE STREAM THAT IT IS PASSED
;	1081	!	A POINTER TO, AND TRIES TO OUTPUT WHAT INSTRUCTIONS
;	1082	!	THIS CORRESPONDS TO SYMBOLICALLY.
;	1083	!
;	1084	! FORMAL PARAMETERS:
;	1085	!	STREAM_PTNR	- A BYTE POINTER TO THE SUPPOSED INSTRUCTION
;	1086	!			  STREAM.
;	1087	!	OUTPUT_BUFFER	-This is a pointer to the beginning
;	1088	!			 of the current output buffer.
;	1089	!			-If this is 0, no output is done and
;	1090	!			 no errors are signaled from these routines.
;	1091	
;	1092	!
;	1093	! IMPLICIT INPUTS:
;	1094	!	DBG$GB_OPINFO	- DATA VECTOR THAT CONTAINS THE INSTRUCTION
;	1095	!			  MNEMONICS AND RELATED INFORMATION.
;	1096	!	DBG$CP_OUT_STR	- POINTS INTO CURRENT OUTPUT BUFFER.
;	1097	!	DBG$GL_BUF_SIZ	- holds character count in output buffer
;	1098	!
;	1099	! IMPLICIT OUTPUTS:
;	1100	!	None.
;	1101	!
;	1102	! ROUTINE VALUE:
;	1103	!	THIS ROUTINE RETURNS THE ADDRESS OF THE
;	1104	!	BEGINNING OF THE NEXT INSTRUCTION.  
;	1105	!
;	1106	!	If "output_buffer" is zero this routine returns
;	1107	!	FALSE if it fails to decode the instruction.
;	1108	!
;	1109	!
;	1110	! SIDE EFFECTS:
;	1111	!	-An error message is produced if we are unable to
;	1112	!	 read the supposed instruction.
;	1113	!	-THE CURRENT OUTPUT BUFFER POINTER IS INCREMENTED,
;	1114	!	 THE CHARACTER REPRESENTATION OF THE INSTRUCTION
;	1115	!	 HAVING BEEN STUFFED INTO THE BUFFER.
;	1116	!	-The count of the output buffer is also incremented.
;	1117	!--
;	1118	
;	1119		BEGIN
;	1120	
;	1121		MAP
;	1122			STREAM_PNTR : REF VECTOR[,BYTE];
;	1123	
;	1124		LOCAL
;	1125			STREAM_PTR : REF VECTOR[,BYTE],	! POINTS TO THE INSTR STREAM.
;	1126			OPCODE;				! INSTRUCTION OPCODE.
;	1127		BIND

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 3-1
; Digital Equipment Corporation
;
;	1128			STREAM_SIGNED = STREAM_PTR : REF VECTOR[,BYTE,SIGNED];
;	1129	
;	1130		STREAM_PTR = .STREAM_PNTR;
;	1131	
;	1132		CASE_FLAG = 0;			! We have to special-case CASE instructions.
;	1133	
;	1134		IF .OUTPUT_BUFFER EQL 0
;	1135		THEN
;	1136		    DBG$CP_OUT_STR = 0;		! Set output pointer to zero if no output desired
;	1137	
;	1138		DBG$READ_ACCESS (.STREAM_PTR, 1); ! See if we can read the opcode byte.
;	1139	
;	1140		!  PICK UP THE OPCODE AND IT CHECK FOR VALIDITY.
;	1141	
;	1142		OPCODE = .STREAM_PTR[0];
;	1143		IF (.OPCODE GTRU MAXOPCODE) OR (.DBG$GB_OPINFO[.OPCODE, OP_NUMOPS] EQL NOT_AN_OP)
;	1144		THEN		! WE DON'T RECOGNIZE THE OPCODE.
;	1145		    BEGIN
;	1146		    IF .OUTPUT_BUFFER NEQ 0
;	1147		    THEN
;	1148			SIGNAL (DBG$_NOINSTRAN, 1, .STREAM_PTR);
;	1149	
;	1150		    RETURN (FALSE);
;	1151		    END;
;	1152	
;	1153		!+
;	1154		! Bump the instruction pointer up past the opcode,
;	1155		! and output the character sequence which 
;	1156		! corresponds to it.
;	1157		!-
;	1158		STREAM_PTR = .STREAM_PTR + 1;
;	1159	
;	1160		IF .OUTPUT_BUFFER NEQ 0
;	1161		THEN
;	1162		    BEGIN
;	1163		    DBG$CONV_R_50( .DBG$GB_OPINFO[ .OPCODE, OP_NAME], .DBG$CP_OUT_STR );
;	1164		    DBG$CP_OUT_STR = .DBG$CP_OUT_STR + OP_CH_SIZE;
;	1165		    DBG$GL_BUF_SIZ = .DBG$GL_BUF_SIZ + OP_CH_SIZE;
;	1166		    !+
;	1167		    ! MAKE SURE THAT THIS IS AN OPCODE WHICH WE HAVE THE
;	1168		    ! REQUIRED INFORMATION ABOUT.  SO FAR, THIS ONLY MEANS
;	1169		    ! THAT WE HAVE TO KNOW HOW MANY OPERANDS TO EXPECT.
;	1170		    ! Also put out two spaces since some opcodes
;	1171		    ! take up the full OP_CH_SIZE field printed, above.
;	1172		    !-
;	1173		    DBG$FAO_PUT( UPLIT( %ASCIC '  ' ) );
;	1174		    END;
;	1175	
;	1176		! See if this is one of the CASE instructions.
;	1177	
;	1178		IF( .OPCODE EQL OP_CASEB OR .OPCODE EQL OP_CASEW OR .OPCODE EQL OP_CASEL )
;	1179		THEN
;	1180			CASE_FLAG = -1;
;	1181	
;	1182		! LOOP, ENCODING HOW EACH OPERAND IS REFERENCED.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 3-2
; Digital Equipment Corporation
;
;	1183	
;	1184		INCR I FROM 1 TO .DBG$GB_OPINFO[ .OPCODE, OP_NUMOPS]
;	1185			DO
;	1186			BEGIN
;	1187			STREAM_PTR = ins_operand (.STREAM_PTR, .I, .OPCODE );
;	1188	
;	1189			IF( .I NEQ 0 AND .I LSS .DBG$GB_OPINFO[ .OPCODE, OP_NUMOPS] )
;	1190			THEN
;	1191				PUTC(%C',');
;	1192			END;
;	1193	
;	1194		! The reason for special-casing CASE instructions is because
;	1195		! they along are not simply made up of OPCODE followed by a
;	1196		! fixed number of operands.  They are followed by N+1 words
;	1197		! (offsets), where N is the last operand of the instruction.
;	1198		! We can therefore only do this if the operand was
;	1199		! given as a literal.  If this is true, we simply
;	1200		! print out these offsets.
;	1201	
;	1202		IF( .CASE_FLAG GTR 0 )
;	1203		THEN
;	1204			BEGIN
;	1205	
;	1206			! The flag supposedly contains N where it is N+1
;	1207			! words which we are supposed to print out.  
;	1208	
;	1209			BIND
;	1210						! Set up so that we can extract
;	1211						! words from the instruction stream.
;	1212				CASE_OFFSETS = STREAM_PTR : REF VECTOR[,WORD,SIGNED];
;	1213	
;	1214			! Extract and print out the case offsets.
;	1215	
;	1216			INCR I FROM 0 TO .CASE_FLAG
;	1217				DO
;	1218				BEGIN
;	1219	
;	1220				! Make sure we can access the word.  This
;	1221				! routine does not return if no access was
;	1222				! granted.
;	1223	
;	1224				DBG$READ_ACCESS(CASE_OFFSETS[.I], 2);
;	1225	
;	1226	%IF DBG_MAC
;     L 1227	%THEN
;     U 1228				$FAO_TT_OUT('case offset !SL = !XW',.I,.case_offsets[.I]);
;     U 1229	%FI
;	1230				! Output the operand in the same way as
;	1231				! we would a branch operand.  First,
;	1232				! see if we should start a new output buffer.
;	1233	
;	1234				IF( .output_buffer NEQ 0 )
;	1235				THEN
;	1236					BEGIN
;	1237			

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 3-3
; Digital Equipment Corporation
;
;	1238					! Flush the current buffer and set up to start a new one.
;	1239			
;	1240					DBG$OUT_PUT(.output_buffer);
;	1241					DBG$CP_OUT_STR = .output_buffer+1;
;	1242					DBG$GL_BUF_SIZ = 0;
;	1243					DBG$FAO_PUT( UPLIT( %ASCIC '!_!_' ) );
;	1244					dbg$out_sym_val( .stream_ptr + .case_offsets[.i],
;	1245							 LONG_LENGTH,
;	1246							 NO_OVERRIDE
;	1247						        );
;	1248	
;	1249					! For all but the last one, put
;	1250					! a ',' after the operand.
;	1251	
;	1252					IF( .I NEQ .case_flag )
;	1253					then
;	1254						dbg$fao_put( UPLIT( %ASCIC ',') );
;	1255					END;
;	1256				END;
;	1257	
;	1258			! Finally, update the instruction-stream pointer.
;	1259	
;	1260			STREAM_PTR = .STREAM_PTR + ((.CASE_FLAG+1)*2);
;	1261			END;
;	1262	
;	1263		!  RETURN A POINTER TO THE BEGINNING OF THE NEXT INSTRUCTION.
;	1264	
;	1265		RETURN( .STREAM_PTR );
;	1266	END;


							    .TITLE  DBGMAC
							    .IDENT  \000027\

							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00000 P.AAA:  .ASCII  <2>\  \<0>						      ;
					      00004 P.AAB:  .ASCII  <4>\!_!_\<0><0><0>					      ;
					      0000C P.AAC:  .ASCII  <1>\,\<0><0>					      ;

							    .PSECT  DBG$OWN,NOEXE,  PIC,2

					      00000 CASE_FLAG:
							    .BLKB   4

							    .GLOBL  DBG$FAO_OUT, DBG$CONV_R_50, DBG$FAO_PUT, DBG$OUT_NUM_VAL
							    .GLOBL  DBG$OUT_SYM_VAL, DBG$OUT_PUT, DBG$READ_ACCESS
							    .GLOBL  DBG$CP_OUT_STR, DBG$GB_OPINFO, DBG$GB_MOD_PTR
							    .GLOBL  DBG$GL_BUF_SIZ, DBG$GL_LAST_VAL

							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0FFC 00000 	    .ENTRY  DBG$INS_DECODE, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11      ; 1073
		         59 00000000G  EF  9E 00002 	    MOVAB   DBG$GB_OPINFO+4, R9					      ;
		         5A 00000000'  EF  9E 00009 	    MOVAB   CASE_FLAG, R10					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 3-4
; Digital Equipment Corporation
;
		         5B 00000000G  EF  9E 00010 	    MOVAB   DBG$CP_OUT_STR, R11					      ;
		         55	  04   AC  D0 00017 	    MOVL    STREAM_PNTR, STREAM_PTR				      ; 1130
				       6A  D4 0001B 	    CLRL    CASE_FLAG						      ; 1132
		         56	  08   AC  D0 0001D 	    MOVL    OUTPUT_BUFFER, R6					      ; 1134
				       02  12 00021 	    BNEQ    1$							      ;
				       6B  D4 00023 	    CLRL    DBG$CP_OUT_STR					      ; 1136
				       01  DD 00025 1$:     PUSHL   #1							      ; 1138
				       55  DD 00027 	    PUSHL   STREAM_PTR						      ;
	      00000000G  EF	       02  FB 00029 	    CALLS   #2, DBG$READ_ACCESS					      ;
		         53	       65  9A 00030 	    MOVZBL  (STREAM_PTR), OPCODE				      ; 1142
	      000000FC   8F	       53  D1 00033 	    CMPL    OPCODE, #252					      ; 1143
				       10  1A 0003A 	    BGTRU   2$							      ;
	   50	         53	       06  C5 0003C 	    MULL3   #6, OPCODE, R0					      ;
	 6940	         04	       00  EC 00040 	    CMPV    #0, #4, DBG$GB_OPINFO+4[R0], #-1			      ;
			    FFFFFFFF   8F     00045									      ;
				       18  12 0004A 	    BNEQ    4$							      ;
				       56  D5 0004C 2$:     TSTL    R6							      ; 1146
				       11  13 0004E 	    BEQL    3$							      ;
				       55  DD 00050 	    PUSHL   STREAM_PTR						      ; 1148
				       01  DD 00052 	    PUSHL   #1							      ;
			    000281F0   8F  DD 00054 	    PUSHL   #164336						      ;
	      00000000G  00	       03  FB 0005A 	    CALLS   #3, LIB$SIGNAL					      ;
				     00FA  31 00061 3$:     BRW     13$							      ; 1150
				       55  D6 00064 4$:     INCL    STREAM_PTR						      ; 1158
				       58  D4 00066 	    CLRL    R8							      ; 1160
				       56  D5 00068 	    TSTL    R6							      ;
				       2C  13 0006A 	    BEQL    5$							      ;
				       58  D6 0006C 	    INCL    R8							      ;
				       6B  DD 0006E 	    PUSHL   DBG$CP_OUT_STR					      ; 1163
	   50	         53	       06  C5 00070 	    MULL3   #6, OPCODE, R0					      ;
				  FC A940  9F 00074 	    PUSHAB  DBG$GB_OPINFO[R0]					      ;
				       9E  DD 00078 	    PUSHL   @(SP)+						      ;
	      00000000G  EF	       02  FB 0007A 	    CALLS   #2, DBG$CONV_R_50					      ;
		         6B	       06  C0 00081 	    ADDL2   #6, DBG$CP_OUT_STR					      ; 1164
	      00000000G  EF	       06  C0 00084 	    ADDL2   #6, DBG$GL_BUF_SIZ					      ; 1165
			    00000000'  EF  9F 0008B 	    PUSHAB  P.AAA						      ; 1173
	      00000000G  EF	       01  FB 00091 	    CALLS   #1, DBG$FAO_PUT					      ;
	      0000008F   8F	       53  D1 00098 5$:     CMPL    OPCODE, #143					      ; 1178
				       12  13 0009F 	    BEQL    6$							      ;
	      000000AF   8F	       53  D1 000A1 	    CMPL    OPCODE, #175					      ;
				       09  13 000A8 	    BEQL    6$							      ;
	      000000CF   8F	       53  D1 000AA 	    CMPL    OPCODE, #207					      ;
				       03  12 000B1 	    BNEQ    7$							      ;
		         6A	       01  CE 000B3 6$:     MNEGL   #1, CASE_FLAG					      ; 1180
	   52	         53	       06  C5 000B6 7$:     MULL3   #6, OPCODE, R2					      ; 1184
	 6942	         04	       00  EE 000BA 	    EXTV    #0, #4, DBG$GB_OPINFO+4[R2], R7			      ;
				       57     000BF									      ;
				       54  D4 000C0 	    CLRL    I							      ;
				       2A  11 000C2 	    BRB     9$							      ;
				       53  DD 000C4 8$:     PUSHL   OPCODE						      ; 1187
				       54  DD 000C6 	    PUSHL   I							      ;
				       55  DD 000C8 	    PUSHL   STREAM_PTR						      ;
		  0000V  CF	       03  FB 000CA 	    CALLS   #3, INS_OPERAND					      ;
		         55	       50  D0 000CF 	    MOVL    R0, STREAM_PTR					      ;
				       54  D5 000D2 	    TSTL    I							      ; 1189

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 3-5
; Digital Equipment Corporation
;
				       18  13 000D4 	    BEQL    9$							      ;
	 6942	         04	       00  EC 000D6 	    CMPV    #0, #4, DBG$GB_OPINFO+4[R2], I			      ;
				       54     000DB									      ;
				       10  15 000DC 	    BLEQ    9$							      ;
		         50	       6B  D0 000DE 	    MOVL    DBG$CP_OUT_STR, R0					      ; 1191
				       0B  13 000E1 	    BEQL    9$							      ;
		         60	       2C  90 000E3 	    MOVB    #44, (R0)						      ;
				       6B  D6 000E6 	    INCL    DBG$CP_OUT_STR					      ;
			    00000000G  EF  D6 000E8 	    INCL    DBG$GL_BUF_SIZ					      ;
	   D2	         54	       57  F3 000EE 9$:     AOBLEQ  R7, I, 8$						      ; 1184
		         52	       6A  D0 000F2 	    MOVL    CASE_FLAG, R2					      ; 1202
				       63  15 000F5 	    BLEQ    12$							      ;
		         53	       01  CE 000F7 	    MNEGL   #1, I						      ; 1216
				       52  11 000FA 	    BRB     11$							      ;
				       02  DD 000FC 10$:    PUSHL   #2							      ; 1224
				     6543  3F 000FE 	    PUSHAW  (CASE_OFFSETS)[I]					      ;
	      00000000G  EF	       02  FB 00101 	    CALLS   #2, DBG$READ_ACCESS					      ;
		         43	       58  E9 00108 	    BLBC    R8, 11$						      ; 1234
				       56  DD 0010B 	    PUSHL   R6							      ; 1240
	      00000000G  EF	       01  FB 0010D 	    CALLS   #1, DBG$OUT_PUT					      ;
	   6B	         56	       01  C1 00114 	    ADDL3   #1, R6, DBG$CP_OUT_STR				      ; 1241
			    00000000G  EF  D4 00118 	    CLRL    DBG$GL_BUF_SIZ					      ; 1242
			    00000000'  EF  9F 0011E 	    PUSHAB  P.AAB						      ; 1243
	      00000000G  EF	       01  FB 00124 	    CALLS   #1, DBG$FAO_PUT					      ;
		         7E	       04  7D 0012B 	    MOVQ    #4, -(SP)						      ; 1244
		         50	     6543  32 0012E 	    CVTWL   (CASE_OFFSETS)[I], R0				      ;
				     6045  9F 00132 	    PUSHAB  (R0)[CASE_OFFSETS]					      ;
	      00000000G  EF	       03  FB 00135 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;
		         6A	       53  D1 0013C 	    CMPL    I, CASE_FLAG					      ; 1252
				       0D  13 0013F 	    BEQL    11$							      ;
			    00000000'  EF  9F 00141 	    PUSHAB  P.AAC						      ; 1254
	      00000000G  EF	       01  FB 00147 	    CALLS   #1, DBG$FAO_PUT					      ;
	   AA	         53	       52  F3 0014E 11$:    AOBLEQ  R2, I, 10$						      ; 1216
		         50	       6A  D0 00152 	    MOVL    CASE_FLAG, R0					      ; 1260
		         55	  02 A540  3E 00155 	    MOVAW   2(STREAM_PTR)[R0], STREAM_PTR			      ;
		         50	       55  D0 0015A 12$:    MOVL    STREAM_PTR, R0					      ; 1265
					   04 0015D 	    RET     							      ;
				       50  D4 0015E 13$:    CLRL    R0							      ; 1073
					   04 00160 	    RET     							      ;

; Routine Size:  353 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4
; Digital Equipment Corporation
;
;	1267	ROUTINE ins_operand( STREAM_PTR, INDEX, OPCODE ) =
;	1268	
;	1269	!++
;	1270	! FUNCTIONAL DESCRIPTION:
;	1271	!	PRINT OUT A REFERENCE TO AN INSTRUCTION OPERAND.
;	1272	!
;	1273	! WARNING:
;	1274	!	1) THERE IS CODE IN THE 'DEFERRED' MACRO WHICH WILL CEASE
;	1275	!	   TO WORK WHEN/IF WE CHANGE THE REPRESENTATION OF TRUE
;	1276	!	   AND FALSE.
;	1277	!	2) THE LOCAL MACROS, BELOW, CHECK FOR THE INDICATED ADDRESSING
;	1278	!	   MODES ONLY GIVEN THAT THEY APPEAR IN THE CODE WHERE THEY
;	1279	!	   DO - IE, THE CHECKS TAKE ADVANTAGE OF WHAT WE KNOW ABOUT
;	1280	!	   WHICH CASES WE HAVE ALREADY ELIMINATED, ETC.
;	1281	!
;	1282	! FORMAL PARAMETERS:
;	1283	!	STREAM_PTR - A BYTE POINTER TO THE FIRST BYTE OF THE INSTRUCTION
;	1284	!		     STREAM WHICH BEGINS THE REFERENCE TO THIS OPERAND.
;	1285	!		     THIS BYTE IS WHAT WE REFER TO AS THE DOMINANT MODE.
;	1286	!	INDEX	   - ORDINAL OF WHICH OPERAND WE ARE ON.  THIS IS NEEDED TO 
;	1287	!		     DECIDE THE 'CONTEXT' FOR THIS OPERAND IF PC-RELATIVE
;	1288	!		     ADDRESSING MODE IS USED.
;	1289	!	OPCODE		- The opcode we are currently working on.
;	1290	!			 (This parameter has already been validated.)
;	1291	!
;	1292	! IMPLICIT INPUTS:
;	1293	!	None.
;	1294	!
;	1295	! IMPLICIT OUTPUTS:
;	1296	!	THE REFERENCE TO THE CURRENT OPERAND IS STUFFED INTO THE
;	1297	!	CURRENT OUTPUT BUFFER IN MACHINE-LANGUAGE FORMAT.
;	1298	!
;	1299	! ROUTINE VALUE:
;	1300	!	-THE INSTRUCTION-STREAM BYTE POINTER, WHICH WE HAVE
;	1301	!	INCREMENTED TO REFLECT HOW MUCH OF THE INSTRUCTION
;	1302	!	STREAM WE HAVE 'EATEN UP', IS PASSED BACK.  THIS
;	1303	!	POINTER SHOULD POINT TO THE BEGINNING OF EITHER THE
;	1304	!	NEXT INSTRUCTION, OR THE NEXT OPERAND REFERENCE,
;	1305	!	DEPENDING ON HOW MANY OPERANDS THE CURRENT INSTRUCTION HAS.
;	1306	!
;	1307	! SIDE EFFECTS:
;	1308	!	IF WE DON'T EAT UP EXACTLY AS MUCH OF THE INSTRUCTION
;	1309	!	STREAM AS WE SHOULD, THE POINTER WE RETURN TO THE
;	1310	!	SUPPOSED NEXT INSTRUCTION WILL BE WRONG.  THIS 
;	1311	!	WILL CAUSE A COMPLETELY MISLEADING 'INSTRUCTION'
;	1312	!	TO BE OUTPUT ON THE NEXT CALL TO THIS ROUTINE.
;	1313	!--
;	1314		BEGIN
;	1315	
;	1316		! LOCAL MACROS USED TO CHECK FOR THE INDICATED ADDRESSING MODES.
;	1317		! SEE 'WARNING:', ABOVE.
;	1318	
;	1319		MACRO
;	1320			REGISTR(MODE)	! REGISTER MODE ADDRESSING.
;	1321				= (MODE EQL 5) %,

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-1
; Digital Equipment Corporation
;
;	1322			DEFERRED(MODE)  ! THOSE WHICH BEGIN WITH '@' ARE
;	1323					!  9 - @(RN)+,
;	1324					!  B - @BYTE(RN),
;	1325					!  D - @WORD(RN),
;	1326					!  F - @LONG(RN),
;	1327					! OR ANY OF THESE + INDEXING.
;	1328					! THE THING WHICH IS COMMON TO ONLY THESE
;	1329					! MODES IS THAT THEY ALL HAVE THE SIGN
;	1330					! BIT SET AND ARE ODD!
;	1331				= ( MODE LSS 0 AND MODE ) %,
;	1332	
;	1333			AUTODEC(MODE)	! SEE IF MODE IS AUTO DECREMENT.
;	1334					! THIS CHECK IS RIGHT FROM SRM.
;	1335				= (MODE EQL 7) %,
;	1336	
;	1337			AUTOINC(MODE)	! MODE IS AUTO INCREMENT
;	1338					! THIS CHECK DEPENDS UPON THE FACT THAT
;	1339					! WE EXTRACTED THE MODE WITH SIGN EXTENSION,
;	1340					! AND THAT WE HAVE ALREADY ELIMINATED
;	1341					! MANY OF THE OTHER POSSIBILITIES.
;	1342				= (MODE LSS 0) %;
;	1343	
;	1344		MAP
;	1345			STREAM_PTR : REF BLOCK[,BYTE];
;	1346		LOCAL
;	1347			NEW_STR_PTR,	! NEW STREAM POINTER.
;	1348			FLAG,		! INDICATES WHICH TYPE OF DISPLACMENT WE HAVE.
;	1349			DISPL,		! THE ACTUAL DISPLACEMENT.
;	1350			DISP_SIZE,	! THE SIZE, IN BYTES, OF A DISPLACEMENT.
;	1351			DOM_OPRND,	! OPERAND WHICH WE EXTRACT FROM THE
;	1352					!  DOMINANT MODE BYTE.  IT MAY BE RN, 
;	1353					!  RX, OR A LITERAL.  (SRM NOTATION).
;	1354			DOM_MODE;	! THE PRIMARY ADDRESSING MODE COMES FROM
;	1355					!    THIS DOMINANT BYTE AS WELL.
;	1356	
;	1357		! WE HAVE TO CONSIDER THE POSSIBILITY OF
;	1358		! SO-CALLED 'BRANCH TYPE' ADDRESSING FIRST
;	1359		! BEFORE ANYTHING ELSE BECAUSE OTHERWISE YOU CANNOT
;	1360		! DIFFERENTIATE SHORT LITERAL FROM BYTE DISPLACEMENT
;	1361		! BRANCHING.
;	1362	
;	1363		IF( (NEW_STR_PTR = BRANCH_TYPE( .STREAM_PTR, .INDEX, .OPCODE )) NEQ 0 )
;	1364		THEN
;	1365			! SUCCESS!  We're done.
;	1366			RETURN( .NEW_STR_PTR );
;	1367	
;	1368		! See that we can access atleast the opcode.
;	1369	
;	1370		DBG$READ_ACCESS ( .STREAM_PTR, 1 );
;	1371	
;	1372		! EXTRACT THE NEEDED FIELDS FROM THE FIRST BYTE OF
;	1373		!  THE OPERAND SPECIFIER.  WE EXTRACT SOME FIELDS
;	1374		!  WITH SIGN EXTENSION SIMPLY BECAUSE THAT MAKES
;	1375		!  MAKING VARIOUS TESTS MORE CONVENIENT.
;	1376	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-2
; Digital Equipment Corporation
;
;	1377		DOM_MODE = .STREAM_PTR[ AMODE ];
;	1378		DOM_OPRND = .STREAM_PTR[ AREG ];
;	1379	
;	1380		! TAKE SPECIAL ACTION FOR INDEXING MODE.
;	1381	
;	1382		IF( .DOM_MODE EQL INDEXING_MODE )
;	1383		THEN
;	1384			BEGIN
;	1385			! HANDLE INDEXING MODE RECURSIVELY.
;	1386	
;	1387			STREAM_PTR = ins_operand ( STREAM_PTR[ NEXT_FIELD(1) ], .INDEX, .OPCODE );
;	1388	
;	1389			PUT_REG( .DOM_OPRND, SQUARE_BRACKETS );
;	1390			RETURN( .STREAM_PTR );
;	1391			END;
;	1392	
;	1393		! SIMPLE MODES ARE EASIER:
;	1394	
;	1395		! FIRST SEE IF THERE WILL BE A LITERAL OR DISPLACEMENT
;	1396		!  IN THE OPERAND REFERENCE.
;	1397	
;	1398		STREAM_PTR = DISPLACEMENT ( .STREAM_PTR, FLAG, DISPL, DISP_SIZE, .INDEX, .OPCODE );
;	1399	
;	1400		! BEGIN CHECKING FOR THE ADDRESSING MODES WHICH BEGIN
;	1401		! WITH SPECIAL CHARACTERS SINCE WE HAVE TO PRINT THEM
;	1402		! FIRST.  WE TRY TO HANDLE SIMILAR CASES WITH THE SAME
;	1403		! CODE, GETTING THE DIFFERENCES 'OUT OF THE WAY' FIRST.
;	1404	
;	1405		IF( DEFERRED( .DOM_MODE ) )
;	1406		THEN
;	1407			PUTC(%C'@')
;	1408		ELSE
;	1409			IF( AUTODEC( .DOM_MODE ) )
;	1410			THEN
;	1411				PUTC(%C'-');
;	1412	
;	1413		! NEXT WE HAVE TO CONSIDER DISPLACEMENTS OR LITERALS.
;	1414		! WHETHER OR NOT THIS IS THE CASE HAS ALREADY BEEN 
;	1415		! DETERMINED IN THE CALL TO 'DISPLACEMENT', ABOVE.
;	1416	
;	1417		IF( .FLAG )
;	1418		THEN
;	1419			BEGIN
;	1420			! THERE IS A LITERAL, SO PRINT IT.
;	1421			! THE FLAG VALUE RETURNED BY DISPLACEMENT()
;	1422			! DISTINGUISHES WHEN THERE SHOULD BE A '#',
;	1423			! AS OPPOSED TO WHEN THE NUMBER IS ACTUALLY
;	1424			! A DISPLACEMENT OFF A REGISTER.
;	1425	
;	1426			IF( .FLAG GTR 0 )
;	1427			THEN
;	1428				BEGIN
;	1429				PUTC(%C'#');
;	1430	
;	1431				! EXCEPT FOR @# MODE, Make .DOM_OPRND NEQ PC_REG so that

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-3
; Digital Equipment Corporation
;
;	1432				! later only checking that will also tell us
;	1433				! that .FLAG is GTR 0.
;	1434	
;	1435				IF( NOT DEFERRED( .DOM_MODE ) )
;	1436				THEN
;	1437					DOM_OPRND = PC_REG +1;
;	1438	
;	1439				! If this is a case instruction, we store the value
;	1440				! of this 3rd-arg literal operand away for later use.
;	1441	
;	1442				IF( .CASE_FLAG NEQ 0 AND .index EQL 3 )
;	1443				THEN
;	1444					CASE_FLAG = .DISPL;
;	1445				END
;	1446			ELSE
;	1447				BEGIN
;	1448				OWN
;	1449					DISPL_ID : VECTOR[4,BYTE]
;	1450					INITIAL( BYTE( 'B', 'W', '?', 'L') );
;	1451	
;	1452				! Print an indication of the displacement size.
;	1453	
;	1454				IF .DBG$CP_OUT_STR NEQ 0
;	1455				THEN
;	1456				    DBG$FAO_PUT( UPLIT(%ASCIC '!AD^'), 1, DISPL_ID[ .DISP_SIZE -1 ] );
;	1457				END;
;	1458	
;	1459			! Output here is always "displ(reg)", for non-PC 
;	1460			! displacments, and just "effective", otherwise. 
;	1461	
;	1462			IF( .FLAG LSS 0  AND  .DOM_OPRND EQL PC_REG )
;	1463			THEN
;	1464				BEGIN
;	1465	
;	1466				! Pick up the displacement and make
;	1467				! it into an effective address.
;	1468	
;	1469				DISP_SIZE = 4;
;	1470				DISPL = .DISPL + .STREAM_PTR;
;	1471				END;
;	1472	
;	1473			! Output either of the two forms described above.
;	1474	
;	1475			IF( .DOM_OPRND EQL PC_REG )
;	1476			THEN
;	1477				BEGIN
;	1478				IF .DBG$CP_OUT_STR NEQ 0
;	1479				THEN
;	1480				    DBG$OUT_SYM_VAL( .DISPL, LONG_LENGTH, NO_OVERRIDE )
;	1481				END
;	1482			ELSE
;	1483				BEGIN
;	1484	
;	1485				! Literals or real (non-PC) displacement modes.
;	1486	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-4
; Digital Equipment Corporation
;
;	1487				IF .DBG$CP_OUT_STR NEQ 0
;	1488				THEN
;	1489				    DBG$OUT_NUM_VAL ( .DISPL, .DISP_SIZE, NO_OVERRIDE );
;	1490	
;	1491				IF( .FLAG LSS 0 )
;	1492				THEN
;	1493					PUT_REG( .DOM_OPRND, ROUND_BRACKETS );
;	1494				END;
;	1495			END
;	1496		ELSE
;	1497			! NO LITERAL OR DISPLACEMENT -> WE MUST HAVE SOME TYPE OF
;	1498			! REGISTER REFERENCE.  SORT OUT THE FEW CASES AND PRINT THEM.
;	1499	
;	1500			IF( REGISTR( .DOM_MODE ) )
;	1501			THEN
;	1502				PUT_REG( .DOM_OPRND, NO_BRACKETS )
;	1503			ELSE
;	1504				BEGIN
;	1505				PUT_REG( .DOM_OPRND, ROUND_BRACKETS );
;	1506				IF( AUTOINC( .DOM_MODE ) )
;	1507				THEN
;	1508					PUTC(%C'+');
;	1509				END;
;	1510	
;	1511		! RETURN THE NEW BYTE STREAM POINTER.
;	1512	
;	1513		RETURN( .STREAM_PTR );
;	1514		END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00010 P.AAD:  .ASCII  <4>\!AD^\<0><0><0>					      ;

							    .PSECT  DBG$OWN,NOEXE,  PIC,2

					      00004 DISPL_ID:
							    .ASCII  \B\							      ;
					      00005 	    .ASCII  \W\							      ;
					      00006 	    .ASCII  \?\							      ;
					      00007 	    .ASCII  \L\							      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0E3C 00161 INS_OPERAND:
							    .WORD   Save R2,R3,R4,R5,R9,R10,R11				      ; 1267
		         59 00000000'  EF  9E 00163 	    MOVAB   CASE_FLAG, R9					      ;
		         5A 00000000G  EF  9E 0016A 	    MOVAB   DBG$GL_BUF_SIZ, R10					      ;
		         5B 00000000G  EF  9E 00171 	    MOVAB   DBG$CP_OUT_STR, R11					      ;
		         5E	       0C  C2 00178 	    SUBL2   #12, SP						      ;
		         7E	  08   AC  7D 0017B 	    MOVQ    INDEX, -(SP)					      ; 1363
		         52	  04   AC  D0 0017F 	    MOVL    STREAM_PTR, R2					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-5
; Digital Equipment Corporation
;
				       52  DD 00183 	    PUSHL   R2							      ;
		  0000V  CF	       03  FB 00185 	    CALLS   #3, BRANCH_TYPE					      ;
				       50  D5 0018A 	    TSTL    NEW_STR_PTR						      ;
				       01  13 0018C 	    BEQL    1$							      ;
					   04 0018E 	    RET     							      ;
				       01  DD 0018F 1$:     PUSHL   #1							      ; 1370
				       52  DD 00191 	    PUSHL   R2							      ;
	      00000000G  EF	       02  FB 00193 	    CALLS   #2, DBG$READ_ACCESS					      ;
	   62	         04	       04  EE 0019A 	    EXTV    #4, #4, (R2), DOM_MODE				      ; 1377
				       53     0019E									      ;
	   62	         04	       00  EF 0019F 	    EXTZV   #0, #4, (R2), DOM_OPRND				      ; 1378
				       54     001A3									      ;
		         04	       53  D1 001A4 	    CMPL    DOM_MODE, #4					      ; 1382
				       14  12 001A7 	    BNEQ    2$							      ;
		         7E	  08   AC  7D 001A9 	    MOVQ    INDEX, -(SP)					      ; 1387
				  01   A2  9F 001AD 	    PUSHAB  1(R2)						      ;
		    AD   AF	       03  FB 001B0 	    CALLS   #3, INS_OPERAND					      ;
		    04   AC	       50  D0 001B4 	    MOVL    R0, STREAM_PTR					      ;
				       02  DD 001B8 	    PUSHL   #2							      ; 1389
				     00E3  31 001BA 	    BRW     16$							      ;
		         7E	  08   AC  7D 001BD 2$:     MOVQ    INDEX, -(SP)					      ; 1398
				  10   AE  9F 001C1 	    PUSHAB  DISP_SIZE						      ;
				  10   AE  9F 001C4 	    PUSHAB  DISPL						      ;
				  10   AE  9F 001C7 	    PUSHAB  FLAG						      ;
				  04   AC  DD 001CA 	    PUSHL   STREAM_PTR						      ;
		  0000V  CF	       06  FB 001CD 	    CALLS   #6, DISPLACEMENT					      ;
		    04   AC	       50  D0 001D2 	    MOVL    R0, STREAM_PTR					      ;
				       55  D4 001D6 	    CLRL    R5							      ; 1405
				       53  D5 001D8 	    TSTL    DOM_MODE						      ;
				       10  18 001DA 	    BGEQ    3$							      ;
				       55  D6 001DC 	    INCL    R5							      ;
		         0B	       53  E9 001DE 	    BLBC    DOM_MODE, 3$					      ;
		         50	       6B  D0 001E1 	    MOVL    DBG$CP_OUT_STR, R0					      ; 1407
				       17  13 001E4 	    BEQL    5$							      ;
		         60	  40   8F  90 001E6 	    MOVB    #64, (R0)						      ;
				       0D  11 001EA 	    BRB     4$							      ;
		         07	       53  D1 001EC 3$:     CMPL    DOM_MODE, #7					      ; 1409
				       0C  12 001EF 	    BNEQ    5$							      ;
		         50	       6B  D0 001F1 	    MOVL    DBG$CP_OUT_STR, R0					      ; 1411
				       07  13 001F4 	    BEQL    5$							      ;
		         60	       2D  90 001F6 	    MOVB    #45, (R0)						      ;
				       6B  D6 001F9 4$:     INCL    DBG$CP_OUT_STR					      ;
				       6A  D6 001FB 	    INCL    DBG$GL_BUF_SIZ					      ;
		         52	       6E  D0 001FD 5$:     MOVL    FLAG, R2						      ; 1417
		         03	       52  E8 00200 	    BLBS    R2, 6$						      ;
				     0093  31 00203 	    BRW     15$							      ;
		         50	       6B  D0 00206 6$:     MOVL    DBG$CP_OUT_STR, R0					      ; 1429
				       52  D5 00209 	    TSTL    R2							      ; 1426
				       24  15 0020B 	    BLEQ    10$							      ;
				       50  D5 0020D 	    TSTL    R0							      ; 1429
				       07  13 0020F 	    BEQL    7$							      ;
		         60	       23  90 00211 	    MOVB    #35, (R0)						      ;
				       6B  D6 00214 	    INCL    DBG$CP_OUT_STR					      ;
				       6A  D6 00216 	    INCL    DBG$GL_BUF_SIZ					      ;
		         03	       55  E9 00218 7$:     BLBC    R5, 8$						      ; 1435

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-6
; Digital Equipment Corporation
;
		         03	       53  E8 0021B 	    BLBS    DOM_MODE, 9$					      ;
		         54	       10  D0 0021E 8$:     MOVL    #16, DOM_OPRND					      ; 1437
				       69  D5 00221 9$:     TSTL    CASE_FLAG						      ; 1442
				       29  13 00223 	    BEQL    11$							      ;
		         03	  08   AC  D1 00225 	    CMPL    INDEX, #3						      ;
				       23  12 00229 	    BNEQ    11$							      ;
		         69	  04   AE  D0 0022B 	    MOVL    DISPL, CASE_FLAG					      ; 1444
				       1D  11 0022F 	    BRB     11$							      ; 1426
				       50  D5 00231 10$:    TSTL    R0							      ; 1454
				       19  13 00233 	    BEQL    11$							      ;
		         50	  04   A9  9E 00235 	    MOVAB   DISPL_ID, R0					      ; 1456
				  08 BE40  9F 00239 	    PUSHAB  @DISP_SIZE[R0]					      ;
				       6E  D7 0023D 	    DECL    (SP)						      ;
				       01  DD 0023F 	    PUSHL   #1							      ;
			    00000000'  EF  9F 00241 	    PUSHAB  P.AAD						      ;
	      00000000G  EF	       03  FB 00247 	    CALLS   #3, DBG$FAO_PUT					      ;
				       53  D4 0024E 11$:    CLRL    R3							      ; 1462
				       52  D5 00250 	    TSTL    R2							      ;
				       10  18 00252 	    BGEQ    12$							      ;
				       53  D6 00254 	    INCL    R3							      ;
		         0F	       54  D1 00256 	    CMPL    DOM_OPRND, #15					      ;
				       09  12 00259 	    BNEQ    12$							      ;
		    08   AE	       04  D0 0025B 	    MOVL    #4, DISP_SIZE					      ; 1469
		    04   AE	  04   AC  C0 0025F 	    ADDL2   STREAM_PTR, DISPL					      ; 1470
		         50	       6B  D0 00264 12$:    MOVL    DBG$CP_OUT_STR, R0					      ; 1478
		         0F	       54  D1 00267 	    CMPL    DOM_OPRND, #15					      ; 1475
				       13  12 0026A 	    BNEQ    13$							      ;
				       50  D5 0026C 	    TSTL    R0							      ; 1478
				       51  13 0026E 	    BEQL    18$							      ;
		         7E	       04  7D 00270 	    MOVQ    #4, -(SP)						      ; 1480
				  0C   AE  DD 00273 	    PUSHL   DISPL						      ;
	      00000000G  EF	       03  FB 00276 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;
				       42  11 0027D 	    BRB     18$							      ; 1475
				       50  D5 0027F 13$:    TSTL    R0							      ; 1487
				       0F  13 00281 	    BEQL    14$							      ;
				       7E  D4 00283 	    CLRL    -(SP)						      ; 1489
				  0C   AE  DD 00285 	    PUSHL   DISP_SIZE						      ;
				  0C   AE  DD 00288 	    PUSHL   DISPL						      ;
	      00000000G  EF	       03  FB 0028B 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
		         2C	       53  E9 00292 14$:    BLBC    R3, 18$						      ; 1491
				       7E  D4 00295 	    CLRL    -(SP)						      ; 1493
				       07  11 00297 	    BRB     16$							      ;
		         05	       53  D1 00299 15$:    CMPL    DOM_MODE, #5					      ; 1500
				       0B  12 0029C 	    BNEQ    17$							      ;
				       01  DD 0029E 	    PUSHL   #1							      ; 1502
				       54  DD 002A0 16$:    PUSHL   DOM_OPRND						      ;
		  0000V  CF	       02  FB 002A2 	    CALLS   #2, PUT_REG						      ;
				       18  11 002A7 	    BRB     18$							      ; 1500
				       7E  D4 002A9 17$:    CLRL    -(SP)						      ; 1505
				       54  DD 002AB 	    PUSHL   DOM_OPRND						      ;
		  0000V  CF	       02  FB 002AD 	    CALLS   #2, PUT_REG						      ;
		         0C	       55  E9 002B2 	    BLBC    R5, 18$						      ; 1506
		         50	       6B  D0 002B5 	    MOVL    DBG$CP_OUT_STR, R0					      ; 1508
				       07  13 002B8 	    BEQL    18$							      ;
		         60	       2B  90 002BA 	    MOVB    #43, (R0)						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 4-7
; Digital Equipment Corporation
;
				       6B  D6 002BD 	    INCL    DBG$CP_OUT_STR					      ;
				       6A  D6 002BF 	    INCL    DBG$GL_BUF_SIZ					      ;
		         50	  04   AC  D0 002C1 18$:    MOVL    STREAM_PTR, R0					      ; 1513
					   04 002C5 19$:    RET     							      ; 1267

; Routine Size:  357 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 5
; Digital Equipment Corporation
;
;	1515	ROUTINE BRANCH_TYPE( STREAM_PTR, INDEX, OPCODE ) =
;	1516	
;	1517	!++
;	1518	! FUNCTIONAL DESCRIPTION:
;	1519	!	DECIDE IF THE CURRENT OPERAND IS USING BRANCH TYPE
;	1520	!	ADDRESSING.  IF SO, PRINT OUT THE REFERENCE AND
;	1521	!	LOOK AFTER ALL THE DETAILS.  OTHERWISE RETURN 0
;	1522	!	AND LET SOMEONE ELSE HANDLE IT.
;	1523	!
;	1524	! FORMAL PARAMETERS:
;	1525	!	STREAM_PTR	- A POINTER TO THE CURRENT DOMINANT
;	1526	!			  MODE BYTE.
;	1527	!	INDEX		- WHICH OPERAND (ORDINAL) WE'RE WORKING ON.
;	1528	!	OPCODE		-The opcode we are currently working on.
;	1529	!			 (This parameter has already been validated.)
;	1530	!
;	1531	! IMPLICIT INPUTS:
;	1532	!	DBG$GB_OPINFO - THE OPCODE INFORMATION TABLE.
;	1533	!	DBG$CP_OUT_STR - The pointer to the output string, if zero don't output.
;	1534	!
;	1535	! IMPLICIT OUTPUTS:
;	1536	!	IF THE CURRENT OPERAND IS A REFERENCE USING BRANCH TYPE
;	1537	!	ADDRESSING, AND IF DBG$CP_OUT_STR IS NON-ZERO, THIS REFERENCE
;	1538	!	IS PRINTED.  OTHERWISE THE ROUTINE DOES NO OUTPUT WHATSOEVER.
;	1539	!
;	1540	! ROUTINE VALUE:
;	1541	!	0	 - IF THE CURRENT OPERAND IS NOT A BRANCH TYPE 
;	1542	!		(i.e. If the calling routine should continue on
;	1543	!		 further to decode the instruction.)
;	1544	!	non-zero - The address of the next instruction is returned.
;	1545	!
;	1546	! SIDE EFFECTS:
;	1547	!	NONE.
;	1548	!--
;	1549		BEGIN
;	1550		LOCAL
;	1551			N_OPS,		! NUMBER OF OPERANDS FOR CURRENT OPCODE
;	1552			DISP_SIZE,	! SIZE OF BRANCH OPERAND, IN BYTES.
;	1553			DISPL;		! THE ACTUAL BRANCH DISPLACEMENT.
;	1554	
;	1555		! THERE IS NO POINT IN EVEN CONSIDERING BRANCH TYPE
;	1556		! ADDRESSING UNLESS WE'RE ON THE LAST OPERAND FOR
;	1557		! THIS INSTRUCTION.
;	1558	
;	1559		IF( (N_OPS = .DBG$GB_OPINFO[ .OPCODE, OP_NUMOPS ]) NEQ .INDEX)
;	1560		THEN
;	1561			RETURN (0);
;	1562	
;	1563		! FURTHERMORE, SINCE WE REALLY USE THE SAME BITS IN
;	1564		! THE OPINFO TABLE FOR 2 PURPOSES, (NAMELY OP_BR_TYPE
;	1565		! AND OP_CONTEXT( MAXOPRNDS ) ), WE CAN NOT EVEN LOOK
;	1566		! FOR BRANCH INFORMATION UNLESS THIS OPCODE HAS LESS
;	1567		! THAN THE MAXIMUM NUMBER OF OPERANDS.
;	1568	
;	1569		IF( .INDEX EQL MAXOPRNDS )

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 5-1
; Digital Equipment Corporation
;
;	1570		THEN
;	1571			RETURN (0);
;	1572	
;	1573		! NOW WE KNOW WE CAN TAKE THE OP_BR_TYPE FIELD LITERALLY.
;	1574		! IT CONTAINS THE NUMBER OF BYTES USED FOR THE BRANCH
;	1575		! DISPLACEMENT.  0 IN THIS FIELD INDICATES THAT
;	1576		! THIS OPCODE HAS NO BRANCH TYPE OPERANDS.
;	1577	
;	1578		IF( (DISP_SIZE = .DBG$GB_OPINFO[ .OPCODE, OP_BR_TYPE ]) EQL NO_BR )
;	1579		THEN
;	1580			RETURN (0);
;	1581	
;	1582		DBG$READ_ACCESS ( .STREAM_PTR, .DISP_SIZE );	! See if we can read the displacement.
;	1583	
;	1584		!+
;	1585		! SUCCESS!  WE HAVE DISCOVERED A CASE OF BRANCH TYPE ADDRESSING.
;	1586		! HANDLE THIS BY SIMPLY EXTRACTING THE FIELD, (WITH SIGN
;	1587		! EXTENSION AS PER SRM),  PRINTING OUT THE REFERENCE,
;	1588		! AND RETURNING A POINTER TO THE NEXT INSTRUCTION.
;	1589		! WE ALSO UPDATE THE VARIABLE WHICH THE USER ACCESSES AS
;	1590		! '\' - THE LAST VALUE DISPLAYED.  IN THIS CASE WE DEFINE
;	1591		! THE VALUE TO BE WHAT THE BRANCH WOULD BE TO IF IT HAPPENS.
;	1592		!-
;	1593	
;	1594		DISPL = .(.STREAM_PTR)<0,.DISP_SIZE*8,1>;
;	1595		STREAM_PTR = .STREAM_PTR + .DISP_SIZE;
;	1596		DBG$GL_LAST_VAL = .DISPL + .STREAM_PTR;
;	1597	
;	1598		! Put out the branch operand and return a
;	1599		! pointer to the next instruction.
;	1600	
;	1601		IF .DBG$CP_OUT_STR NEQ 0
;	1602		THEN
;	1603		    dbg$out_sym_val( .stream_ptr + .displ, LONG_LENGTH, NO_OVERRIDE);
;	1604	
;	1605		RETURN( .STREAM_PTR );
;	1606		END;





					 0004 002C6 BRANCH_TYPE:
							    .WORD   Save R2						      ; 1515
	   50	    0C   AC	       06  C5 002C8 	    MULL3   #6, OPCODE, R0					      ; 1559
00000000GEF40	         04	       00  EE 002CD 	    EXTV    #0, #4, DBG$GB_OPINFO+4[R0], N_OPS			      ;
				       51     002D6									      ;
		    08   AC	       51  D1 002D7 	    CMPL    N_OPS, INDEX					      ;
				       50  12 002DB 	    BNEQ    2$							      ;
		         06	  08   AC  D1 002DD 	    CMPL    INDEX, #6						      ; 1569
				       4A  13 002E1 	    BEQL    2$							      ;
00000000GEF40	         02	       06  EF 002E3 	    EXTZV   #6, #2, DBG$GB_OPINFO+5[R0], DISP_SIZE		      ; 1578
				       52     002EC									      ;
				       3E  13 002ED 	    BEQL    2$							      ;
				       52  DD 002EF 	    PUSHL   DISP_SIZE						      ; 1582

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 5-2
; Digital Equipment Corporation
;
				  04   AC  DD 002F1 	    PUSHL   STREAM_PTR						      ;
	      00000000G  EF	       02  FB 002F4 	    CALLS   #2, DBG$READ_ACCESS					      ;
	   50	         52	       03  78 002FB 	    ASHL    #3, DISP_SIZE, R0					      ; 1594
      04   BC	         50	       00  EE 002FF 	    EXTV    #0, R0, @STREAM_PTR, DISPL				      ;
				       51     00304									      ;
		    04   AC	       52  C0 00305 	    ADDL2   DISP_SIZE, STREAM_PTR				      ; 1595
00000000G  EF	         51	  04   AC  C1 00309 	    ADDL3   STREAM_PTR, DISPL, DBG$GL_LAST_VAL			      ; 1596
			    00000000G  EF  D5 00312 	    TSTL    DBG$CP_OUT_STR					      ; 1601
				       0E  13 00318 	    BEQL    1$							      ;
		         7E	       04  7D 0031A 	    MOVQ    #4, -(SP)						      ; 1603
				  04 BC41  9F 0031D 	    PUSHAB  @STREAM_PTR[DISPL]					      ;
	      00000000G  EF	       03  FB 00321 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;
		         50	  04   AC  D0 00328 1$:     MOVL    STREAM_PTR, R0					      ; 1605
					   04 0032C 	    RET     							      ;
				       50  D4 0032D 2$:     CLRL    R0							      ; 1515
					   04 0032F 	    RET     							      ;

; Routine Size:  106 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 6
; Digital Equipment Corporation
;
;	1607	ROUTINE PUT_REG( REG, CS_FLAG ) : NOVALUE =
;	1608	
;	1609	!++
;	1610	! FUNCTIONAL DESCRIPTION:
;	1611	!	THIS ROUTINE TAKES 1 PARAMETER WHICH IT ASSUMES IS
;	1612	!	THE NUMBER OF A VAX REGISTER.  IT THEN PRINTS OUT
;	1613	!	'R' FOLLOWED BY THE NUMBER (IN DECIMAL), UNLESS THE
;	1614	!	REGISTER NUMBER IS 'SPECIAL'.  THESE INCLUDE:
;	1615	!
;	1616	!	REGISTER NUMBER		SPECIAL NAME
;	1617	!
;	1618	!		12		   AP
;	1619	!		13		   FP
;	1620	!		14		   SP
;	1621	!		15		   PC
;	1622	!
;	1623	!	An additional parameter is used as a flag to indicate
;	1624	!	whether the register reference should be enclosed in
;	1625	!	round/square brackets or not.
;	1626	!
;	1627	! INPUTS:
;	1628	!	REG - The register number.
;	1629	!	CS_FLAG - A flag to control printing before/after REG.
;	1630	!
;	1631	! IMPLICIT INPUTS:
;	1632	!	DBG$CP_OUT_STR - pointer to output buffer, if zero no output is done.
;	1633	!
;	1634	! OUTPUTS:
;	1635	!	THE REGISTER REFERENCE IS PRINTED.
;	1636	!
;	1637	! IMPLICIT OUTPUTS:
;	1638	!	NONE.
;	1639	!
;	1640	! ROUTINE VALUE:
;	1641	!	NOVALUE
;	1642	!
;	1643	! SIDE EFFECTS:
;	1644	! 	NONE.
;	1645	!--
;	1646		BEGIN
;	1647		LOCAL
;	1648			INDEX;
;	1649		OWN
;	1650			ENCLOSING_CS : VECTOR[4,WORD]	! Enclosing strings for REG.
;	1651				       INITIAL(	WORD(	%ASCIC '(',
;	1652							%ASCIC ')',
;	1653							%ASCIC '[',
;	1654							%ASCIC ']'
;	1655						    )
;	1656					      ),
;	1657	
;	1658			PUT_CS   : VECTOR[4,BYTE]	! FAO formatting string.
;	1659				   INITIAL( %ASCIC '!AC' ),
;	1660	
;	1661			REGNAMES : VECTOR[4,WORD]	! SPECIAL REGISTER NAMES.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 6-1
; Digital Equipment Corporation
;
;	1662				   INITIAL( WORD( 'AP', 'FP', 'SP', 'PC') );
;	1663	
;	1664		IF .DBG$CP_OUT_STR EQL 0
;	1665		THEN
;	1666		    RETURN;				! No output is to be done.
;	1667	
;	1668		!+
;	1669		! If we are to put out any enclosing strings,
;	1670		! then we have been passed the INDEX which we
;	1671		! need to pick this string out of the above
;	1672		! vector.
;	1673		!-
;	1674	
;	1675		IF( (INDEX = .CS_FLAG) NEQ NO_BRACKETS )
;	1676		THEN
;	1677			DBG$FAO_PUT( PUT_CS, ENCLOSING_CS[.INDEX] );
;	1678	
;	1679		! Now print the actual register reference.
;	1680	
;	1681		IF( .REG LSS AP_REG )
;	1682		THEN
;	1683			DBG$FAO_PUT( UPLIT ( %ASCIC 'R!UB' ), .REG )
;	1684		ELSE
;	1685			! The reserved registers have special names which
;	1686			! we extract from the above vector.
;	1687	
;	1688			DBG$FAO_PUT( UPLIT ( %ASCIC '!AD' ), 2, REGNAMES[.REG-12] );
;	1689	
;	1690		! See again if there is any enclosing string.
;	1691	
;	1692		IF( .INDEX NEQ NO_BRACKETS )
;	1693		THEN
;	1694			DBG$FAO_PUT( PUT_CS, ENCLOSING_CS[.INDEX+1] );
;	1695	
;	1696		END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00018 P.AAE:  .ASCII  <4>\R!UB\<0><0><0>					      ;
					      00020 P.AAF:  .ASCII  <3>\!AD\						      ;

							    .PSECT  DBG$OWN,NOEXE,  PIC,2

					      00008 ENCLOSING_CS:
							    .ASCII  <1>\(\						      ;
					      0000A 	    .ASCII  <1>\)\						      ;
					      0000C 	    .ASCII  <1>\[\						      ;
					      0000E 	    .ASCII  <1>\]\						      ;
					      00010 PUT_CS: .ASCII  <3>\!AC\						      ;
					      00014 REGNAMES:
							    .ASCII  \AP\						      ;
					      00016 	    .ASCII  \FP\						      ;
					      00018 	    .ASCII  \SP\						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 6-2
; Digital Equipment Corporation
;
					      0001A 	    .ASCII  \PC\						      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0C04 00330 PUT_REG:.WORD   Save R2,R10,R11					      ; 1607
		         5A 00000000G  EF  9E 00332 	    MOVAB   DBG$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 00339 	    MOVAB   PUT_CS, R11						      ;
			    00000000G  EF  D5 00340 	    TSTL    DBG$CP_OUT_STR					      ; 1664
				       47  13 00346 	    BEQL    4$							      ;
		         52	  08   AC  D0 00348 	    MOVL    CS_FLAG, INDEX					      ; 1675
		         01	       52  D1 0034C 	    CMPL    INDEX, #1						      ;
				       09  13 0034F 	    BEQL    1$							      ;
				  F8 AB42  3F 00351 	    PUSHAW  ENCLOSING_CS[INDEX]					      ; 1677
				       5B  DD 00355 	    PUSHL   R11							      ;
		         6A	       02  FB 00357 	    CALLS   #2, DBG$FAO_PUT					      ;
		         0C	  04   AC  D1 0035A 1$:     CMPL    REG, #12						      ; 1681
				       0E  18 0035E 	    BGEQ    2$							      ;
				  04   AC  DD 00360 	    PUSHL   REG							      ; 1683
			    00000000'  EF  9F 00363 	    PUSHAB  P.AAE						      ;
		         6A	       02  FB 00369 	    CALLS   #2, DBG$FAO_PUT					      ;
				       13  11 0036C 	    BRB     3$							      ; 1681
		         50	  04   AC  D0 0036E 2$:     MOVL    REG, R0						      ; 1688
				  EC AB40  3F 00372 	    PUSHAW  REGNAMES-24[R0]					      ;
				       02  DD 00376 	    PUSHL   #2							      ;
			    00000000'  EF  9F 00378 	    PUSHAB  P.AAF						      ;
		         6A	       03  FB 0037E 	    CALLS   #3, DBG$FAO_PUT					      ;
		         01	       52  D1 00381 3$:     CMPL    INDEX, #1						      ; 1692
				       09  13 00384 	    BEQL    4$							      ;
				  FA AB42  3F 00386 	    PUSHAW  ENCLOSING_CS+2[INDEX]				      ; 1694
				       5B  DD 0038A 	    PUSHL   R11							      ;
		         6A	       02  FB 0038C 	    CALLS   #2, DBG$FAO_PUT					      ;
					   04 0038F 4$:     RET     							      ; 1607

; Routine Size:  96 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 7
; Digital Equipment Corporation
;
;	1697	ROUTINE DISPLACEMENT( STREAM_PTR, FLAG, DISPL, PTR_DISP_SIZE, INDEX, OPCODE ) =
;	1698	
;	1699	!++
;	1700	!  FUNCTIONAL DESCRIPTION:
;	1701	!	DECIDE IF THERE IS A DISPLACEMENT FOR THE CURRENT
;	1702	!	OPERAND OF THE CURRENT INSTRUCTION.  IF THERE IS,
;	1703	!	EXTRACT IT FROM THE INSTRUCTION STREAM AND RETURN AN
;	1704	!	INDICATION OF WHICH CASE WE HAVE DETECTED.
;	1705	!
;	1706	! CALLING SEQUENCE:
;	1707	!	DISPLACEMENT ();
;	1708	!
;	1709	! INPUTS:
;	1710	!	STREAM_PTR	- BYTE POINTER TO THE BEGINNING OF THE
;	1711	!			  CURRENT OPERAND SPECIFIER.
;	1712	!	FLAG		- POINTER TO THE LOCATION WHERE WE SHOULD STUFF
;	1713	!			  ONE OF THE 3 FLAGS GIVEN BELOW IF WE FIND THAT
;	1714	!			  THERE IS A DISPLACEMENT OR LITERAL ASSOCIATED
;	1715	!			  WITH THIS OPERAND REFERENCE.
;	1716	!	DISPL	 	- A POINTER TO THE LONGWORD WHERE WE WILL STUFF THE ACTUAL
;	1717	!			  DISPLACEMENT OR LITERAL IF WE FIND THAT THERE IS ONE.
;	1718	!	PTR_DISP_SIZE	- A pointer to where we can pass back the number
;	1719	!			  of bytes actually needed for the displacement.
;	1720	!			  This is done strictly for the benefit of FAO,
;	1721	!			  which would fill out output fields with 0s
;	1722	!			  otherwise, giving misleading output.
;	1723	!	INDEX		- THE ORDINAL OF WHICH OPERAND WE ARE ON.
;	1724	!	OPCODE		-The opcode we are currently working on.
;	1725	!			 (This parameter has already been validated.)
;	1726	!
;	1727	! OUTPUTS:
;	1728	!	1) A VALUE OF -1, 0, OR 1 IS RETURNED VIA THE LONGWORD
;	1729	!	   POINTER, FLAG.  0 IS RETURNED IF NO DISPLACEMENT IS TO BE
;	1730	!	   ASSOCIATED WITH THIS OPERAND REFERENCE.  OTHERWISE 1 OR -1
;	1731	!	   IS RETURNED TO SEPARATE THE CASES LISTED BELOW.  THIS IS DONE
;	1732	!	   SIMPLY TO ALLOW US TO PRINT '#' BEFORE SOME LITERALS,
;	1733	!	   (E.G. MOVL #1,R0), AND TO INDICATE WHEN WE SHOULD
;	1734	!	   PRINT '(RN)' AFTER THE DISPLACEMENT, ETC.  SINCE WE
;	1735	!	   WERE FORCED TO FIGURE OUT WHICH OF THESE CASES WE
;	1736	!	   WERE DEALING WITH HERE, WE PASS BACK THIS INFORMATION
;	1737	!	   TO AVOID HAVING TO DO IT AGAIN WHEN WE REALLY WANT IT.
;	1738	!
;	1739	!	2) IF THERE IS A DISPLACEMENT, ITS VALUE IS RETURNED
;	1740	!	   VIA THE LONGWORD POINTER, 'DISPL'.  IF THE FLAG WHICH IS
;	1741	!	   RETURNED (SEE ABOVE) IS 0, THE LONGWORD POINTED
;	1742	!	   TO BY 'DISPL' IS UNCHANGED.  IF THE LITERAL WE
;	1743	!	   EXTRACT FROM THE BYTE STREAM WOULD REQUIRE MORE
;	1744	!	   THAN A LONGWORD (E.G. QUAD LITERALS), THEN WE
;	1745	!	   PASS BACK ONLY THE LOWER ORDER LONGWORD VIA
;	1746	!	   'DISPL'.  THIS IS A BUG WHICH WE WILL FIX LATER.
;	1747	!
;	1748	! IMPLICIT OUTPUTS:
;	1749	!	IF TRUNCATION OF QUADWORD LITERALS OCCURS, THIS
;	1750	!	ROUTINE WILL PUT '?' INTO THE OUTPUT STREAM
;	1751	!	TO WARN OF THIS ACTION.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 7-1
; Digital Equipment Corporation
;
;	1752	!
;	1753	! ROUTINE VALUE:
;	1754	!	-THE (NEW) BYTE STREAM POINTER WHICH WILL THEN POINT TO THE
;	1755	!	 BEGINNING OF THE NEXT INSTRUCTION OR OPERAND REFERENCE.
;	1756	!	-FALSE is returned if read access to the instruction is
;	1757	!	 denied.
;	1758	!
;	1759	! SIDE EFFECTS:
;	1760	!	NONE.
;	1761	!--
;	1762		BEGIN
;	1763		MAP
;	1764			PTR_DISP_SIZE	:	REF VECTOR[,LONG],
;	1765			DISPL		:	REF VECTOR[,LONG],
;	1766			FLAG		:	REF VECTOR[,LONG],
;	1767			STREAM_PTR	:	REF BLOCK[,BYTE];
;	1768		LOCAL
;	1769			MODE,		! DOMINANT ADDRESSING MODE.
;	1770			F,		! FLAG VALUE WHICH WE RETURN.
;	1771			DISP_SIZE;	! SIZE, IN BYTES, OF THE DISPLACEMENT.
;	1772	
;	1773		!++
;	1774		!  ASSUME THERE IS NO DISPLACMENT, BUT THEN CHECK
;	1775		!  FOR THE CASES:
;	1776		!
;	1777		!	1) LITERAL MODE - DOMINANT MODE IS 0, 1, 2, OR 3.
;	1778		!
;	1779		!	2) BYTE, WORD, OR LONGWORD, DISPLACEMENT OR DEFERRED
;	1780		!	   DISPLACEMENT MODES.
;	1781		!
;	1782		!	3) MODE 8 WHEN REG IS PC (IE #CONST, INSTEAD OF (PC)+ )
;	1783		!	  OR
;	1784		!	   MODE 9 WHEN REG IS PC (IE @#ADDRESS, INSTEAD OF @(PC)+ )
;	1785		!	
;	1786		!  CASES 1 AND 3 ARE TYPE 1, WHILE CASE 2 IS TYPE -1.
;	1787		!--
;	1788	
;	1789		F = 0;
;	1790		DISP_SIZE = 0;
;	1791	
;	1792		DBG$READ_ACCESS ( .STREAM_PTR, 1 );	! See if we can pick up the mode byte.
;	1793	
;	1794		IF( (MODE = .STREAM_PTR[ DSPL_MODE ]) LSS INDEXING_MODE )
;	1795		THEN
;	1796			BEGIN
;	1797			! CASE 1: LITERAL MODE ADDRESSING
;	1798			!	  THE LITERAL IS A 6-BIT FIELD WHICH MUST BE
;	1799			!	  EXTRACTED WITHOUT SIGN-EXTENSION FROM THE ADDRESSING
;	1800			!	  MODE BYTE.  EXTRACT THIS FIELD, PASS IT BACK, AND
;	1801			!	  SET A FLAG TO INDICATE WHICH CASE WE HAVE FOUND.
;	1802			!	  NOTE THAT THE FLAG VALUE BEING 1 ALSO MEANS THAT
;	1803			!	  WE CAN USE THIS FOR THE DISP_SIZE VALUE THAT WE
;	1804			!	  PASS BACK.
;	1805	
;	1806			DISPL[0] = .STREAM_PTR[ SHORT_LITERAL ];

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 7-2
; Digital Equipment Corporation
;
;	1807			F = 1;
;	1808			END
;	1809		ELSE
;	1810			IF( .MODE GTR AT_PC_REL_MODE )
;	1811			THEN
;	1812				BEGIN
;	1813				! CASE 2: DISPLACEMENT OR DEFERRED DISPLACEMENT MODE.
;	1814				!	  THERE ONLY REMAINS TO DECIDE HOW MUCH OF
;	1815				!	  THE BYTE STREAM TO EXTRACT.  THIS IS DONE
;	1816				!	  SIMPLY BY LOOKING AT WHAT THE 'MODE' FIELD
;	1817				!	  OF THE DOMINANT BYTE IS.  WE HAVE TO
;	1818				!	  DIFFERENTIATE HEX A OR B, C OR D, AND E OR F,
;	1819				!	  SO WE JUST LOOK FOR THE MOST CONVENIENT
;	1820				!	  BITS TO CHECK.  START BY ASSUMING BYTE
;	1821				!	  DISPLACEMENT (HEX A OR B), THEN SORT OUT
;	1822				!	  THE OTHER TWO CASES.
;	1823				F = -1;
;	1824				DISP_SIZE = 1;
;	1825				IF( .STREAM_PTR[ DOM_MOD_FIELD ] LSS 0 )
;	1826					THEN
;	1827					DISP_SIZE = ( IF( .STREAM_PTR[ DOM_MOD_FIELD ] )
;	1828	 					      THEN 4  ! MODE IS HEX E OR F.
;	1829						      ELSE 2  ! MODE IS HEX C OR D.
;	1830						    );
;	1831				END
;	1832			ELSE
;	1833				IF( .STREAM_PTR[ OPERAND_VALUE ] EQL PC_REG 
;	1834				  AND
;	1835				    ( .MODE EQL PC_REL_MODE OR .MODE EQL AT_PC_REL_MODE ) )
;	1836				THEN
;	1837					BEGIN
;	1838					! CASE 3: SPECIAL CASE NOTATION FOR PC MODES.
;	1839					!	  THE ONLY DIFFICULTY IS DECIDING HOW
;	1840					!	  MUCH OF THE BYTE STREAM TO 'EAT UP'.
;	1841					!	  @#ADDRESS ALWAYS HAS LONGWORD CONTEXT,
;	1842					!	  WHILE THE CONTEXT OF #CONST DEPENDS ON
;	1843					!	  THE OPCODE AND THE OPERAND ORDINAL.
;	1844	
;	1845					F = 1;
;	1846					IF( .MODE EQL AT_PC_REL_MODE )
;	1847					THEN
;	1848						DISP_SIZE = 4
;	1849					ELSE
;	1850						DISP_SIZE = INS_CONTEXT( .INDEX, .OPCODE );
;	1851					END;
;	1852	
;	1853		!  AT THIS POINT .DISP_SIZE IS THE NUMBER OF BYTES PAST THE MODE BYTE
;	1854		!  WE HAVE CONSUMED FROM THE INSTRUCTION STREAM, IF ANY.  JUST GO
;	1855		!  AHEAD AND COMSUME THESE BYTES, PASS BACK THE DISPLACEMENT,
;	1856		!  AND RETURN THE NEW INSTRUCTION-STREAM BYTE POINTER.
;	1857	
;	1858		! EVEN IF THERE IS NO DISPLACEMENT, WE HAVE AT LEAST 
;	1859		! CONSUMED THE DOMINANT ADDRESSING MODE BYTE.
;	1860	
;	1861		STREAM_PTR = STREAM_PTR[ NEXT_FIELD(1) ];

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 7-3
; Digital Equipment Corporation
;
;	1862	
;	1863		! Pass back the flag now so that we can re-use
;	1864		!   F as a temporary, below.
;	1865	
;	1866		FLAG[0] = .F;
;	1867	
;	1868		IF( .DISP_SIZE NEQ 0 )
;	1869			THEN
;	1870			BEGIN
;	1871			! CHECK FOR QUADWORD LITERALS BECAUSE ALTHOUGH
;	1872			! WE MUST EXTRACT THEM FROM THE BYTE STREAM, WE
;	1873			! CAN NOT YET HANDLE PASSING THEM BACK.
;	1874			! CLEARLY, THIS IS A BUG.
;	1875	
;	1876			IF( (F = .DISP_SIZE) GTR 4 )
;	1877			THEN
;	1878				BEGIN
;	1879				! ***** TRUNCATION *****
;	1880				F = 4;
;	1881				PUTC(%C'?');
;	1882				END;
;	1883	
;	1884			DBG$READ_ACCESS ( .STREAM_PTR, .F );	! See if we can pick up the literal.
;	1885	
;	1886			! PASS BACK THE LITERAL OR DISPLACEMENT.
;	1887			! NOTE THE SIGN EXTENSION.
;	1888	
;	1889			DISPL[0] = .STREAM_PTR[ 0, 0, .F * BITS_PER_BYTE, 1];
;	1890			END;
;	1891	
;	1892		! Pass back an indication of the number of bytes
;	1893		!  actually consumed for the displacement or literal
;	1894		!  for the benefit of FAO output.
;	1895	
;	1896		PTR_DISP_SIZE[0] = .F;
;	1897		RETURN( STREAM_PTR[ NEXT_FIELD( .DISP_SIZE ) ] );
;	1898	
;	1899		END;





					 0C1C 00390 DISPLACEMENT:
							    .WORD   Save R2,R3,R4,R10,R11				      ; 1697
		         5A 00000000G  EF  9E 00392 	    MOVAB   DBG$READ_ACCESS, R10				      ;
		         5B 00000000G  EF  9E 00399 	    MOVAB   DBG$CP_OUT_STR, R11					      ;
				       53  7C 003A0 	    CLRQ    F							      ; 1789
				       01  DD 003A2 	    PUSHL   #1							      ; 1792
		         52	  04   AC  D0 003A4 	    MOVL    STREAM_PTR, R2					      ;
				       52  DD 003A8 	    PUSHL   R2							      ;
		         6A	       02  FB 003AA 	    CALLS   #2, DBG$READ_ACCESS					      ;
	   62	         04	       04  EF 003AD 	    EXTZV   #4, #4, (R2), MODE					      ; 1794
				       50     003B1									      ;
		         04	       50  D1 003B2 	    CMPL    MODE, #4						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 7-4
; Digital Equipment Corporation
;
				       0B  18 003B5 	    BGEQ    1$							      ;
	   62	         06	       00  EF 003B7 	    EXTZV   #0, #6, (R2), @DISPL				      ; 1806
				  0C   BC     003BB									      ;
		         53	       01  D0 003BD 	    MOVL    #1, F						      ; 1807
				       45  11 003C0 	    BRB     6$							      ; 1794
		         09	       50  D1 003C2 1$:     CMPL    MODE, #9						      ; 1810
				       16  15 003C5 	    BLEQ    2$							      ;
		         53	       01  CE 003C7 	    MNEGL   #1, F						      ; 1823
		         54	       01  D0 003CA 	    MOVL    #1, DISP_SIZE					      ; 1824
	   62	         02	       05  EC 003CD 	    CMPV    #5, #2, (R2), #0					      ; 1825
				       00     003D1									      ;
				       33  18 003D2 	    BGEQ    6$							      ;
	   1E	         62	       05  E0 003D4 	    BBS     #5, (R2), 4$					      ; 1827
		         54	       02  D0 003D8 	    MOVL    #2, DISP_SIZE					      ;
				       2A  11 003DB 	    BRB     6$							      ; 1825
	   62	         04	       00  ED 003DD 2$:     CMPZV   #0, #4, (R2), #15					      ; 1833
				       0F     003E1									      ;
				       23  12 003E2 	    BNEQ    6$							      ;
		         08	       50  D1 003E4 	    CMPL    MODE, #8						      ; 1835
				       05  13 003E7 	    BEQL    3$							      ;
		         09	       50  D1 003E9 	    CMPL    MODE, #9						      ;
				       19  12 003EC 	    BNEQ    6$							      ;
		         53	       01  D0 003EE 3$:     MOVL    #1, F						      ; 1845
		         09	       50  D1 003F1 	    CMPL    MODE, #9						      ; 1846
				       05  12 003F4 	    BNEQ    5$							      ;
		         54	       04  D0 003F6 4$:     MOVL    #4, DISP_SIZE					      ; 1848
				       0C  11 003F9 	    BRB     6$							      ; 1846
		         7E	  14   AC  7D 003FB 5$:     MOVQ    INDEX, -(SP)					      ; 1850
		  0000V  CF	       02  FB 003FF 	    CALLS   #2, INS_CONTEXT					      ;
		         54	       50  D0 00404 	    MOVL    R0, DISP_SIZE					      ;
				  04   AC  D6 00407 6$:     INCL    STREAM_PTR						      ; 1861
		    08   BC	       53  D0 0040A 	    MOVL    F, @FLAG						      ; 1866
				       54  D5 0040E 	    TSTL    DISP_SIZE						      ; 1868
				       2E  13 00410 	    BEQL    8$							      ;
		         53	       54  D0 00412 	    MOVL    DISP_SIZE, F					      ; 1876
		         04	       54  D1 00415 	    CMPL    DISP_SIZE, #4					      ;
				       13  15 00418 	    BLEQ    7$							      ;
		         53	       04  D0 0041A 	    MOVL    #4, F						      ; 1880
		         50	       6B  D0 0041D 	    MOVL    DBG$CP_OUT_STR, R0					      ; 1881
				       0B  13 00420 	    BEQL    7$							      ;
		         60	       3F  90 00422 	    MOVB    #63, (R0)						      ;
				       6B  D6 00425 	    INCL    DBG$CP_OUT_STR					      ;
			    00000000G  EF  D6 00427 	    INCL    DBG$GL_BUF_SIZ					      ;
				       53  DD 0042D 7$:     PUSHL   F							      ; 1884
				  04   AC  DD 0042F 	    PUSHL   STREAM_PTR						      ;
		         6A	       02  FB 00432 	    CALLS   #2, DBG$READ_ACCESS					      ;
	   50	         53	       03  78 00435 	    ASHL    #3, F, R0						      ; 1889
      04   BC	         50	       00  EE 00439 	    EXTV    #0, R0, @STREAM_PTR, @DISPL				      ;
				  0C   BC     0043E									      ;
		    10   BC	       53  D0 00440 8$:     MOVL    F, @PTR_DISP_SIZE					      ; 1896
	   50	    04   AC	       54  C1 00444 	    ADDL3   DISP_SIZE, STREAM_PTR, R0				      ; 1897
					   04 00449 	    RET     							      ; 1697

; Routine Size:  186 bytes

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 7-5
; Digital Equipment Corporation
;



; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 8
; Digital Equipment Corporation
;
;	1900	ROUTINE INS_CONTEXT( INDEX, OPCODE ) =
;	1901	
;	1902	!++
;	1903	! FUNCTIONAL DESCRIPTION:
;	1904	!	THIS ROUTINE DECIDES WHAT CONTEXT APPLIES TO THE GIVEN
;	1905	!	OPERAND FOR A SPECIFIC OPCODE.  IT IS USED BECAUSE WE NEED
;	1906	!	TO KNOW WHETHER A PC-RELATIVE MODE FOR THIS OPERAND WOULD
;	1907	!	REQUIRE A BYTE, WORD, LONGWORD, OR QUADWORD OPERAND.
;	1908	!
;	1909	! INPUTS:
;	1910	!	INDEX - WHICH OPERAND WE'RE DEALING WITH.  THIS NUMBER
;	1911	!		MUST BE 1, 2, ... 6.
;	1912	!	OPCODE	-The opcode we are currently working on.
;	1913	!		 (This parameter has already been validated.)
;	1914	!
;	1915	! IMPLICIT INPUTS:
;	1916	!	None.
;	1917	!
;	1918	! OUTPUTS:
;	1919	!	NONE.
;	1920	!
;	1921	! IMPLICIT OUTPUTS:
;	1922	!	NONE.
;	1923	!
;	1924	! ROUTINE VALUE:
;	1925	!	IF SOME ERROR IS DETECTED, WE RETURN FALSE.  OTHERWISE WE RETURN
;	1926	!	THE NUMBER OF BYTES FROM THE INSTRUCTION STREAM THAT THE CURRENT
;	1927	!	OPERAND REFERENCE SHOULD CONSUME.  THIS NUMBER WILL BE:
;	1928	!
;	1929	!     NUMBER	OP_CONTEXT 	NAME FROM OPI MACRO DEFINITION
;	1930	!   OF BYTES         VALUE
;	1931	!	
;	1932	!	    1	         0		BYT
;	1933	!	    2		 1		WRD
;	1934	!	    4		 2		LNG
;	1935	!	    8		 3		QAD
;	1936	!
;	1937	!   THE VALUE, 0 TO 3, STORED IN THE OP_CONTEXT FIELD IS SIMPLY 
;	1938	!   OUR ENCODING OF 4 VALUES INTO A 2-BIT FIELD.  THE 'NUMBER OF
;	1939	!   BYTES' ENTRY, ABOVE, IS THE NUMBER WE ARE ACTUALLY AFTER.
;	1940	!
;	1941	! SIDE EFFECTS:
;	1942	!	NONE.
;	1943	!--
;	1944		BEGIN
;	1945		!+
;	1946		! CHECK FOR ANY OF THE FOLLOWING ERROR CONDITIONS:
;	1947		!	1) WE DON'T RECOGNIZE THIS OPCODE.
;	1948		!	2) WE DON'T HAVE ENOUGH INFORMATION ABOUT IT.
;	1949		!	   (IE - IT IS RESERVED OR YET TO BE DEFINED).
;	1950		!	3) WE KNOW ABOUT IT, BUT DON'T BELIEVE THAT IT
;	1951		!	   SHOULD HAVE AS MANY OPERANDS AS WHAT
;	1952		!	   'INDEX' IMPLIES.  THIS CHECK IS NECESSARY
;	1953		!	   BECAUSE THE 'NUL' ENTRY IN THE OPINFO
;	1954		!	   DECLARATION MACROS RESULTS IN THE SAME VALUE

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 8-1
; Digital Equipment Corporation
;
;	1955		!	   BEING ENCODED AS THE 'BYT' ONES DO.  SINCE
;	1956		!	   WE CAN CROSS-CHECK FOR THIS ERROR AT THIS
;	1957		!	   POINT (BY LOOKING AT THE OP_NUMOPS ENTRY FOR
;	1958		!	   THIS OPCODE), IT DID NOT SEEM WORTH TAKING UP MORE
;	1959		!	   BITS IN THE OPINFO TABLE TO DIFFERENTIATE 'NUL'
;	1960		!	   AND THE OTHERS.
;	1961		!--
;	1962	
;	1963		IF ( .OPCODE GTRU MAXOPCODE )
;	1964		THEN
;	1965			! ERROR 1, SEE ABOVE.
;	1966			RETURN(FALSE);
;	1967	
;	1968		IF( .DBG$GB_OPINFO[ .OPCODE, OP_NUMOPS ] EQL NOT_AN_OP )
;	1969		THEN
;	1970			! ERROR 2, SEE ABOVE.
;	1971			RETURN(FALSE);
;	1972	
;	1973		IF( ( .DBG$GB_OPINFO[ .OPCODE, OP_NUMOPS ] LSS .INDEX )
;	1974		   OR
;	1975		    ( .INDEX LEQ 0 ) )
;	1976		THEN
;	1977			! ERROR 3, SEE ABOVE.
;	1978			RETURN(FALSE);
;	1979	
;	1980		! NOW IT IS JUST A MATTER OF LOOKING INTO OUR OPINFO TABLE
;	1981		! WHERE WE GET 0, 1, 2, OR 3.  THIS JUST HAPPENS TO BE
;	1982		! THE POWER OF 2 WHICH WE NEED TO CALCULATE THE NUMBER
;	1983		! OF BYTES OCCUPIED BY THE CORRESPONDING OPERAND.
;	1984	
;	1985		RETURN( ( 1 ^ .DBG$GB_OPINFO[.OPCODE, OP_CONTEXT(.INDEX)] ) );
;	1986		END;





					 0004 0044A INS_CONTEXT:
							    .WORD   Save R2						      ; 1900
	      000000FC   8F	  08   AC  D1 0044C 	    CMPL    OPCODE, #252					      ; 1963
				       39  1A 00454 	    BGTRU   1$							      ;
	   50	    08   AC	       06  C5 00456 	    MULL3   #6, OPCODE, R0					      ; 1968
		         52 00000000GEF40  9E 0045B 	    MOVAB   DBG$GB_OPINFO+4[R0], R2				      ;
	   62	         04	       00  EC 00463 	    CMPV    #0, #4, (R2), #-1					      ;
			    FFFFFFFF   8F     00467									      ;
				       21  13 0046C 	    BEQL    1$							      ;
	   62	         04	       00  EC 0046E 	    CMPV    #0, #4, (R2), INDEX					      ; 1973
				  04   AC     00472									      ;
				       19  19 00474 	    BLSS    1$							      ;
				  04   AC  D5 00476 	    TSTL    INDEX						      ; 1975
				       14  15 00479 	    BLEQ    1$							      ;
		         50	  04   AC  D0 0047B 	    MOVL    INDEX, R0						      ; 1985
		         50	       02  C4 0047F 	    MULL2   #2, R0						      ;
		         50	       02  C0 00482 	    ADDL2   #2, R0						      ;
	   62	         02	       50  EF 00485 	    EXTZV   R0, #2, (R2), R1					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 8-2
; Digital Equipment Corporation
;
				       51     00489									      ;
	   50	         01	       51  78 0048A 	    ASHL    R1, #1, R0						      ;
					   04 0048E 	    RET     							      ;
				       50  D4 0048F 1$:     CLRL    R0							      ; 1900
					   04 00491 	    RET     							      ;

; Routine Size:  72 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:25:57	DBB3:[DEBUG.SRC]DBGMAC.B32;6					Page 9
; Digital Equipment Corporation
;
;	1987	END
;	1988	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  DBG$OWN        	    28    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
;  DBG$PLIT       	    36  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  DBG$CODE       	  1170  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]STARLET.L32;1		      2688         3         0       108






;			COMPILER INTERNAL TIMING

;	Phase	    Faults	Cpu-time      Elapsed-time
;	LEXSYN	      380	00:19.1		00:21.4
;	FLOWAN	       24	00:03.0		00:03.0
;	DELAY	       25	00:01.4		00:01.4
;	TNBIND	       58	00:01.7		00:01.7
;	CODE	       45	00:03.5		00:03.5
;	FINAL	      105	00:06.6		00:06.8
;	Total	      637	00:35.4		00:37.9

; Size:		1170 code + 64 data bytes
; Run Time:	00:35.7
; Elapsed Time:	00:38.3
; Memory Used:	249 pages
; Compilation Complete
