
; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DBGSSV ( ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE),
;	0002			IDENT = '000054') =
;	0003	BEGIN
;	0004	
;	0005	! Copyright (C) 1976
;	0006	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0007	!
;	0008	! This software is furnished under a license for use only on a
;	0009	! single computer system and may be copied only with the inclusion
;	0010	! of the above copyright notice. This software, or any
;	0011	! other copies thereof, may not be provided or otherwise made
;	0012	! available to any other person except for use on such system
;	0013	! and to one who agrees to these license terms. Title to and
;	0014	! ownership of the software shall at all times remain in DEC.
;	0015	!
;	0016	! The information in this software is subject to change without
;	0017	! notice and should not be construed as a commitment by Digital
;	0018	! Equipment Corporation.
;	0019	!
;	0020	! DEC assumes no responsibility for the use or reliability of
;	0021	! its software on equipment which is not supplied by DEC.
;	0022	!
;	0023	! FACILITY:	DEBUG
;	0024	!
;	0025	!++
;	0026	! FUNCTIONAL DESCRIPTION:
;	0027	!	CALLS TO STARLET OPERATING SYSTEM I/O SERVICES.  INCLUDE
;	0028	!	ASSIGNMENT AND DEASSIGNMENT OF CHANNELS, READS, WRITES.
;	0029	!
;	0030	! Version:	54
;	0031	!
;	0032	! History:
;	0033	!	Author:
;	0034	!		Carol Peters, 21 Sep 1976: Version 01
;	0035	!
;	0036	!	Modified by:
;	0037	!		Dale Roedger, 18 July 1978:	54
;	0038	!
;	0039	! Revision History:
;	0040	!	06	05-apr-77	kgp	-added routine dbg$fao_put, which
;	0041	!					will be the new basis for terminal 
;	0042	!					output.  this used to be in DBGMAC,
;	0043	!					for purely historical reasons.
;	0044	!	06	05-apr-77	kgp	-added routines DBG$FAO_PUT and
;	0045	!					 DBG$OUT_PUT, and DBG$OUT_VALUE
;	0046	!					 in an effort to begin building a set
;	0047	!					 of common I/O routines for DEBUG.
;	0048	!	07	11-04-77	CP	Delete routines that assign channels
;	0049	!					and read and write. These are now
;	0050	!					done with RMS calls.
;	0051	!	08	14-04-77	CP	Add reference to global
;	0052	!					DBG$GL_BUF_SIZ when calling
;	0053	!					FAOL to format output.
;	0054	!	09	20-04-77	CP	Change VAXDEB.BEG to be named
;	0055	!					DBGGEN.BEG. Also add DBGPCT.BEG

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 1-1
; Digital Equipment Corporation
;
;	0056	!					for PSECT declarations.
;	0057	!	10	19-may-77	KGP	-Added the routine DBG$READ_ACCESS
;	0058	!					 which does a PROBR before we
;	0059	!					 try to access a memory location so that
;	0060	!					 we can produce a better error message
;	0061	!					 than just 'access violation'.
;	0062	!	11	05-10-77	CP	-Change call to error_reprt to SIGNAL.
;	0063	!					 Remove subsequent RETURN FALSE.
;	0064	!	12	06-oct-77	KGP	-Redo out_value, etc. for symbolic output.
;	0065	!	13	24-oct-77	KGP	-Integrated SSV versions 11 and 12 to make
;	0066	!					 this one for 5X08.  This is the val_to_sym
;	0067	!					 integration.
;	0068	!	14	26-oct-77	KGP	-Fixed a bug which was that NT_PTR is passed
;	0069	!					 on as a LONGWORD in DBG$OUT_SYM_VAL 
;	0070	!					 even tho it is supposed to only be a
;	0071	!					 word.  (1 half of it never gets init-
;	0072	!					 ialized.)  Fix was NT_PTR = 0;
;	0073	!					-Made OUT_NUM_VAL into DBG$OUT_NUM_VAL
;	0074	!					 and made it global.
;	0075	!	15	27-oct-77	KGP	-Added the rewritten routine, DBG$SHOW_MODULE
;	0076	!	16	28-oct-77	KGP	-Put code into out_sym_val so that
;	0077	!					 in HEX mode, the +offset (in "symbol+off")
;	0078	!					 gets printed without the leading 0s.
;	0079	!					-Also made up DBG_SSV1, which allows us to
;	0080	!					 print out more info for SHO MODUles for
;	0081	!					 our purposes.  We turn this off for the
;	0082	!					 more user-oriented SHO MODUles.
;	0083	!	17	3-NOV-77	KGP	-Added routine DBG$MODULE_SIZE.  It is
;	0084	!					 used in SHOW_MODULE and in BLD's
;	0085	!					 ADD_MODULE().
;	0086	!					-Also put out more information in the
;	0087	!					 long (DBG_SSV1) version of SHOW_MODULE
;	0088	!	18	7-nov-77	KGP	-Added PRINT_PATH and DBG$SHOW_SCOPE
;	0089	!					 (the latter is from DBGRST.B32) because
;	0090	!					 this consolidates all I/O into SSV
;	0091	!					 (or, at least, removes it from RST)
;	0092	!					-A "*4" FIX IN DBG$MODULE_SIZE.
;	0093	!	19	01-12-77	CP	Add new routine dbg$out_typ_val.
;	0094	!					Outputs typed value according
;	0095	!					to characteristics from a DST
;	0096	!					record. Set next_loc and last_val.
;	0097	!	20	08-12-77	CP	Call for$cnv_out_g for
;	0098	!					floating output instead of 
;	0099	!					for$cnv_out_d or e. Give explicit
;	0100	!					w, d, and scale factors.
;	0101	!					Make out_typ_val a VALUEd routine.
;	0102	!					Thus, if it fails, its caller
;	0103	!					can just call out_num_val.
;	0104	!					Add routine out_typ_num that
;	0105	!					looks at the data type of a value
;	0106	!					in the command argument list and
;	0107	!					outputs the number appropriately.
;	0108	!					This is for evaluate command.
;	0109	!	21	12-dec-77	KGP	-DBG$MODULE_SIZE now takes literals
;	0110	!					 and SATs into account.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 1-2
; Digital Equipment Corporation
;
;	0111	!					 This is a retrofit from SSV Version 19
;	0112	!	22	12-dec-77	KGP	-SHOW_MODULE now prints 'size' in short
;	0113	!					 version, and "symbol+offset" is printed by
;	0114	!					 OUT_SYM_VAL only if offset is less than
;	0115	!					 the literal, RST_MAX_OFFSET.
;	0116	!	23	13-DEC-77	KGP	-DBG$OUT_VALUE is now gone.  OUT_SYM_VAL
;	0117	!					 knows about arrays, and it only applies
;	0118	!					 the 'fake' limit on "symbol+offset"
;	0119	!					 when "symbol" is not bounded.
;	0120	!	24	14-DEC-77	KGP	-Added PUT_BOUNDS and changed OUT_SYM_VAL
;	0121	!					 so that we can symbolize arrays OK.
;	0122	!	25	15-dec-77	KGP	-Changed SHOW$MODULE so that in SSV1=TRUE
;	0123	!					 mode (for DEBUGging) even the fake
;	0124	!					 MC (for globals) is printed.
;	0125	!					-Fixed typo bug in MODULE_SIZE, and
;	0126	!					 added bounds check in OUT_TYP_VAL
;	0127	!	26	28-12-77	CP	For outputting complex numbers,
;	0128	!					surround them in parenthesis, and
;	0129	!					remove the spurious quotes around
;	0130	!					the comma.
;	0131	!	27	30-dec-77	KGP	-New error message NOSYMBOLS, and 
;	0132	!					 changed name of ADD_NT_TO_PV and
;	0133	!					 SYMBOL_VALUE.
;	0134	!	28	3-feb-78	KGP	-OUT_SYM_VAL knows about %line.
;	0135	!					 New routine, PUT_LINE
;	0136	!	29	13-FEB-78	KGP	-Fix in OUT_SYM_VAL so that
;	0137	!					 PUT_LINE is only called with _RTN
;	0138	!					 type symbols.  Nothing else makes sense.
;	0139	!	30	16-FEB-78	KGP	-OUT_SYM_VAL now checks for array
;	0140	!					 descriptors properly.  This upgrade
;	0141	!					 corresponds to the new FORTRAN standard.
;	0142	!	31	20-feb-78	KGP	-PUT_BOUNDS now symbolizes CHARACTER
;	0143	!					 (FORTRAN) string references as well
;	0144	!					 as general array references.
;	0145	!	32	02-MAR-78	DAR	Removed CRLF FAO directives from ascii
;	0146	!					strings.
;	0147	!	33	9-mar-78	KGP	-Changed out_sym_val to NOT put out
;	0148	!					 fortran-specific symbolizations if
;	0149	!					 the SET language is not fortran.
;	0150	!	34	17-mar-78	KGP	-Old error symbol DBG$_NOSYMBOLS is
;	0151	!					 now DBG$_NOLOCALS.
;	0152	!	35	22-mar-78	KGP	-Added DBG$PV_TO_CS, and changed
;	0153	!					 PRINT_PATH to use it.
;	0154	!	36	23-mar-78	KGP	-OUT_SYM_VAL now considers DEFine
;	0155	!					 symbols (for exact matches only).
;	0156	!	37	24-mar-78	KGP	-PUT_LINE now returns immediately
;	0157	!					 is the PC value it gets is exactly
;	0158	!					 equivalent to the routine start address.
;	0159	!	38	03-mar-78	KGP	-The long version of SHOW_MODU now
;	0160	!					 skips the global MC since it is no longer
;	0161	!					 anything like the other MCs.
;	0162	!					-The ordinary SHOW MODU now gives the
;	0163	!					 language name if they are not all the same.
;	0164	!	39	11-apr-78	KGP	-SHOW MODULE now doesn't print junk
;	0165	!					 if the MC has no DST.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 1-3
; Digital Equipment Corporation
;
;	0166	!	40	25-apr-78	KGP	-OUT_TYP_VAL now LOCKs the GST before
;	0167	!					 trying to find the type of the address
;	0168	!					 it wants to display.
;	0169	!	41	27-APR-78	DAR	Modified require and library directives
;	0170	!					for native build.
;	0171	!	42	17-may-78	KGP	-OUT_NUM_VAL now puts a leading 0 in
;	0172	!					 front of hex output which starts 
;	0173	!					 with A-F.  Ditto for the offset
;	0174	!					 value printed in out_sym_val.
;	0175	!	43	24-may-78	KGP	-OUT_TYP_NUM forces the data type
;	0176	!					 to INTEGER when EV /ADDRESS is done
;	0177	!	44	25-may-78	KGP	-OUT_SYM_VAL knows about register names
;	0178	!	45	26-may-78	KGP	-OUT_SYM_VAL accepts a hint at
;	0179	!					 where the symbolization is to come
;	0180	!					 from, instead of insisting on working
;	0181	!					 it all out from scratch.
;	0182	!	46	30-may-78	KGP	-OUT_TYP_VAL now takes the same kind of
;	0183	!					 'hint' (NT_PTR) that out_sym_val does.
;	0184	!	47	01-jun-78	KGP	-PRINT_PATH is now global
;	0185	!	48	02-jun-78	MCC	-Added routine dbg$out_dimensn which builds
;	0186	!					 a string containing bounds of a FORTRAN
;	0187	!					 array. This is used for error reporting
;	0188	!	49	07-jun-78	KGP	-OUT_SYM_VAL doesn't symbolize a register
;	0189	!					 name if the value came from some
;	0190	!					 RST symbol.
;	0191	!	50	14-jun-78	KGP	-SHOW MODULE now gives output in
;	0192	!					 decimal no matter what the radix.
;	0193	!	51	15-jun-78	KGP	-PUT_BOUNDS now knows about
;	0194	!					 arrays of CHARACTER symbolizations.
;	0195	!	52	12-JUL-78	DAR	Deleted routine dbg$out_typ_num, called
;	0196	!					from DBGEXA.B32 for evaluate command.
;	0197	!					DBG$OUT_TYP_VAL was a superset of out_typ_num.
;	0198	!	53	14-JUL-78	DAR	dbg$gl_asci_len holds the length of the
;	0199	!					ascii string to display.
;	0200	!	54	18-JUL-78	DAR	DBG$OUT_TYP_VAL's second parameter is now
;	0201	!					the type of the expression or symbol.
;	0202	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 2
; Digital Equipment Corporation
;
;	0203	! TABLE OF CONTENTS:
;	0204	!
;	0205	FORWARD ROUTINE
;	0206		DBG$PV_TO_CS : NOVALUE,		! Encode a pathvector into a buffer.
;	0207		PUT_LINE,			! Symbolize %line references.
;	0208		PUT_BOUNDS,			! Symbolize an array reference.
;	0209		dbg$fao_put : NOVALUE,		! Stuff output into current output buffer.
;	0210		DBG$MODULE_SIZE,		! Estimate the RST size of a module.
;	0211		DBG$OUT_NUM_VAL : NOVALUE,	! Output of numeric values.
;	0212		DBG$OUT_PUT : NOVALUE,		! ACTUALLY WRITE OUT A LINE TO TTY.
;	0213		DBG$OUT_SYM_VAL : NOVALUE,	! Output values either in numeric
;	0214						! or in symbolic form.
;	0215		dbg$out_typ_val,		! outputs the typed contents of a location.
;	0216		DBG$READ_ACCESS,		! PROBE read accessability.
;	0217		DBG$SHOW_MODULE : NOVALUE,	! List off the module chain.
;	0218		DBG$SHOW_SCOPE : NOVALUE,	! Print out the current CSP.
;	0219		DBG$PRINT_PATH : NOVALUE,	! Print out a symbol pathname
;	0220		DBG$OUT_DIMENSN : NOVALUE;		! Build string of FORTRAN array bounds.
;	0221	
;	0222	!
;	0223	! REQUIRE FILES:
;	0224	!
;	0225	%IF %VARIANT		! True for TEN.
;     L 0226	%THEN
;     U 0227	LIBRARY 'NEW:LIB';
;     U 0228	
;     U 0229	REQUIRE 'DBGPCT.REQ';
;     U 0230	REQUIRE 'DBGGEN.REQ';
;     U 0231	REQUIRE 'VXSMAC.REQ';
;     U 0232	REQUIRE 'DBGMSG.REQ';
;     U 0233	REQUIRE 'SYSLIT.REQ';
;     U 0234	REQUIRE 'DBGRST.REQ';
;     U 0235	REQUIRE 'BSTRUC.REQ';
;     U 0236	REQUIRE 'DLLNAM.REQ';
;     U 0237	REQUIRE 'SYSSER.REQ';
;     U 0238	%ELSE
;	0239	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0240	
;	0241	REQUIRE 'SRC$:DBGPCT.REQ';
;	0253	REQUIRE 'SRC$:DBGGEN.REQ';
;	0503	REQUIRE 'SRC$:VXSMAC.REQ';
;	0543	REQUIRE 'LIB$:DBGMSG.REQ';
;	0822	REQUIRE 'SRC$:SYSLIT.REQ';
;	0845	REQUIRE 'SRC$:DBGRST.REQ';
;	1992	REQUIRE 'SRC$:BSTRUC.REQ';
;	2043	REQUIRE 'SRC$:DLLNAM.REQ';
;	2094	REQUIRE 'SRC$:SYSSER.REQ';
;      R2097	SWITCHES LIST (SOURCE);
;      R2098	
;      R2099	EXTERNAL ROUTINE
;      R2100		dbg$fao_out;				! formats a line and outputs to the terminal
;      R2101	
;      R2102	SWITCHES LIST (NOSOURCE);
;	2147	%FI
;	2148	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 2-1
; Digital Equipment Corporation
;
;	2149	!
;	2150	! EQUATED SYMBOLS:
;	2151	!
;	2152	LITERAL
;	2153		dbg_ssv		= 0,		! for debugging floating point
;	2154		dbg_ssv1	= 0,		! LONG (1) or SHORT (0) version for
;	2155						! what DBG$SHOW_MODULE produces.
;	2156		DBG_SSV2	= 0,		! Output in PUT_BOUNDS
;	2157		DBG_SSV3	= 0,		! Output in PUT_LINE
;	2158		dbg_ssv4	= 0;		! value symbolizations
;	2159	
;	2160	EXTERNAL ROUTINE
;	2161		dbg$out_regname,		! Symbolize register names
;	2162		dbg$language,			! Report on a given language name.
;	2163		dbg$find_val,			! Val_to_sym on DEFine symbols.
;	2164		DBG$PC_TO_LINE,			! FORTRAN PC correlation
;	2165		DBG$GET_BOUNDS : NOVALUE,	! Understand array descriptors.
;	2166		DBG$ADD_NT_2_PV,		! Build pathname vectors.
;	2167		DBG$REPORT_FREE,		! BYTES REMAINING IN FREE STORAGE.
;	2168		DBG$VAL_TO_SYM,			! Translate values to their
;	2169						!  symbolic equivalent.
;	2170		for$cnv_out_g,			! converts floating to ascii string
;	2171		DBG$SYMBOL_VALU,		! convert symbol 
;	2172						! name to value.
;	2173		SYS$FAOL: ADDRESSING_MODE (ABSOLUTE);		! SYSTEM SERVICE TO DO FORMATTED OUTPUT.
;	2174	
;	2175	EXTERNAL
;	2176		dbg$gb_language : byte,			! current SET language encoding.
;	2177		dbg$cp_out_str: VECTOR[, BYTE],		! POINTS INTO CURRENT OUTPUT BUFFER.
;	2178		dbg$gb_mod_ptr: REF VECTOR[, BYTE],	! POINTS TO CURRENT I/O MODE SETTINGS.
;	2179		dbg$gl_asci_len,			! the length of the ascii string to display
;	2180		dbg$gl_buf_siz,				! holds current character count in output buffer
;	2181		dbg$gl_csp_ptr  : ref pathname_vector,	! The current scope position (CSP)
;	2182		dbg$gl_last_val,			! the last value displayed
;	2183		dbg$gl_mc_ptr	: REF MC_RECORD,	! Pointer to the module chain (MC).	
;	2184		dbg$gl_next_loc;			! next location to display
;	2185	
;	2186	MACRO
;	2187		single_bit	= 0, 0, 1, 0%,
;	2188		byte_logical	= 0, 0, 8, 0%,
;	2189		word_logical	= 0, 0, 16, 0%,
;	2190		long_logical	= 0, 0, 32, 0%,
;	2191		long_2_logical	= 4, 0, 32, 0%,
;	2192		long_3_logical	= 8, 0, 32, 0%,
;	2193		byte_integer	= 0, 0, 8, 1%,
;	2194		word_integer	= 0, 0, 16, 1%,
;	2195		long_integer	= 0, 0, 32, 1%;
;	2196		
;	2197	BIND
;	2198		stg_desc_ascii	= UPLIT (%ASCIC '!AS'),
;	2199		comma_space	= UPLIT (%ASCIC ', '),
;	2200		open_parenth	= UPLIT (%ASCIC '('),
;	2201		closed_parenth	= UPLIT (%ASCIC ')'),
;	2202		cs_ascii	= UPLIT (%ASCIC '!AD');
;	2203	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 2-2
; Digital Equipment Corporation
;
;	2204	LITERAL
;	2205		float_buf_len	= 25,
;	2206		real4_buf_len	= 15,
;	2207		real8_buf_len	= 25,
;	2208		real4_fra_dig	= 7,
;	2209		real8_fra_dig	= 16,
;	2210		scale_factor	= 1;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 3
; Digital Equipment Corporation
;
;	2211	GLOBAL ROUTINE dbg$fao_put( STRING, ARGUMENTS ) : NOVALUE =
;	2212	
;	2213	!++
;	2214	! FUNCTIONAL DESCRIPTION
;	2215	!	DO JUST WHAT $FAO DOES, ONLY HERE WE WORK IN
;	2216	!	CO-OPERATION WITH A GLOBAL CHARACTER BUFFER INTO
;	2217	!	WHICH WE ARE ENCODING ARBITRARY LINES OF OUTPUT.
;	2218	!
;	2219	!	All console output done within DEBUG should use this
;	2220	!	routine to build output lines.  The only other 
;	2221	!	I/O call which DEBUG should be making (for the console)
;	2222	!	is to DBG$OUT_PUT, which simply says "put out whatever
;	2223	!	dbg$fao_put built".
;	2224	!
;	2225	! CALLING SEQUENCE:
;	2226	!	dbg$fao_put ();
;	2227	!
;	2228	! INPUTS:
;	2229	!	STRING	  - A COUNTED STRING WHICH CONTAINS THE DIRECTIVES FOR $FAO.
;	2230	!	ARGUMENTS - THE ARGS FOR $FAO.
;	2231	!
;	2232	! IMPLICIT INPUTS:
;	2233	!	dbg$cp_out_str	- POINTER TO WHERE WE ARE IN THE
;	2234	!			CURRENT OUTPUT BUFFER.
;	2235	!	dbg$gl_buf_siz	- count of characters in output buffer.
;	2236	!
;	2237	! OUTPUTS:
;	2238	!	THE $FAO OUTPUT IS PUT INTO THE OUTPUT BUFFER.
;	2239	!
;	2240	! IMPLICIT OUTPUTS:
;	2241	!	THE GLOBAL CHARACTER POINTER IS INCREMENTED SO THAT IT
;	2242	!	POINTS (AS ALWAYS) TO THE NEXT AVAILABLE PLACE IN THE
;	2243	!	OUTPUT BUFFER. The buffer count variable is incremented
;	2244	!	by the size of this string.
;	2245	!
;	2246	! ROUTINE VALUE:
;	2247	!	NONE.
;	2248	!
;	2249	! SIDE EFFECTS:
;	2250	!	NONE.
;	2251	!--
;	2252	
;	2253		BEGIN
;	2254		MAP
;	2255			STRING : REF VECTOR[,BYTE];
;	2256		LOCAL
;	2257			INP_DESC : VECTOR[2],		! INPUT DESC FOR $FAO.
;	2258			OUT_DESC : VECTOR[2],		! OUTPUT DESC FOR $FAO.
;	2259			STR_SIZE : WORD;		! $FAO RETURNS OUTPUT SIZE HERE.
;	2260		!+
;	2261		! BUILD THE DESCRIPTORS THAT $FAO WANTS, ASK IT TO DO
;	2262		! THE ENCODING, COPYING THE OUTPUT INTO OUR GLOBAL
;	2263		! OUTPUT BUFFER, AND FINALLY UPDATE THE GLOBAL POINTER
;	2264		! TO THE NEXT FREE CHARACTER POSITION IN THE BUFFER.
;	2265		!-

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 3-1
; Digital Equipment Corporation
;
;	2266	
;	2267		INP_DESC[0] = .STRING[0];
;	2268		INP_DESC[1] = STRING[1];
;	2269		OUT_DESC [0] = TTY_OUT_WIDTH - 1 - .dbg$gl_buf_siz;
;	2270		OUT_DESC[1] = .dbg$cp_out_str;
;	2271		SYS$FAOL( INP_DESC, STR_SIZE, OUT_DESC, ARGUMENTS );
;	2272		dbg$cp_out_str = .dbg$cp_out_str + .STR_SIZE;
;	2273		dbg$gl_buf_siz = .dbg$gl_buf_siz + .STR_SIZE;
;	2274		END;


							    .TITLE  DBGSSV
							    .IDENT  \000054\

							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00000 P.AAA:  .ASCII  <3>\!AS\						      ;
					      00004 P.AAB:  .ASCII  <2>\, \<0>						      ;
					      00008 P.AAC:  .ASCII  <1>\(\<0><0>					      ;
					      0000C P.AAD:  .ASCII  <1>\)\<0><0>					      ;
					      00010 P.AAE:  .ASCII  <3>\!AD\						      ;

						    STG_DESC_ASCII=	P.AAA
						    COMMA_SPACE=	P.AAB
						    OPEN_PARENTH=	P.AAC
						    CLOSED_PARENTH=	P.AAD
						    CS_ASCII=		P.AAE
							    .GLOBL  DBG$_RST_BEGIN, DBG$FAO_OUT, DBG$OUT_REGNAME, DBG$LANGUAGE
							    .GLOBL  DBG$FIND_VAL, DBG$PC_TO_LINE, DBG$GET_BOUNDS, DBG$ADD_NT_2_PV
							    .GLOBL  DBG$REPORT_FREE, DBG$VAL_TO_SYM, FOR$CNV_OUT_G
							    .GLOBL  DBG$SYMBOL_VALU, SYS$FAOL, DBG$GB_LANGUAGE, DBG$CP_OUT_STR
							    .GLOBL  DBG$GB_MOD_PTR, DBG$GL_ASCI_LEN, DBG$GL_BUF_SIZ
							    .GLOBL  DBG$GL_CSP_PTR, DBG$GL_LAST_VAL, DBG$GL_MC_PTR
							    .GLOBL  DBG$GL_NEXT_LOC
							    .WEAK   ACCESS_CHECK

							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0C00 00000 	    .ENTRY  DBG$FAO_PUT, Save R10,R11				      ; 2211
		         5A 00000000G  EF  9E 00002 	    MOVAB   DBG$GL_BUF_SIZ, R10					      ;
		         5B 00000000G  EF  9E 00009 	    MOVAB   DBG$CP_OUT_STR, R11					      ;
		         5E	       14  C2 00010 	    SUBL2   #20, SP						      ;
		    0C   AE	  04   BC  9A 00013 	    MOVZBL  @STRING, INP_DESC					      ; 2267
      10   AE	    04   AC	       01  C1 00018 	    ADDL3   #1, STRING, INP_DESC+4				      ; 2268
      04   AE 00000083   8F	       6A  C3 0001E 	    SUBL3   DBG$GL_BUF_SIZ, #131, OUT_DESC			      ; 2269
		    08   AE	       6B  D0 00027 	    MOVL    DBG$CP_OUT_STR, OUT_DESC+4				      ; 2270
				  08   AC  9F 0002B 	    PUSHAB  ARGUMENTS						      ; 2271
				  08   AE  9F 0002E 	    PUSHAB  OUT_DESC						      ;
				  08   AE  9F 00031 	    PUSHAB  STR_SIZE						      ;
				  18   AE  9F 00034 	    PUSHAB  INP_DESC						      ;
	      00000000G  9F	       04  FB 00037 	    CALLS   #4, @#SYS$FAOL					      ;
		         50	       6E  3C 0003E 	    MOVZWL  STR_SIZE, R0					      ; 2272
		         6B	       50  C0 00041 	    ADDL2   R0, DBG$CP_OUT_STR					      ;
		         50	       6E  3C 00044 	    MOVZWL  STR_SIZE, R0					      ; 2273
		         6A	       50  C0 00047 	    ADDL2   R0, DBG$GL_BUF_SIZ					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 3-2
; Digital Equipment Corporation
;
					   04 0004A 	    RET     							      ; 2211

; Routine Size:  75 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 4
; Digital Equipment Corporation
;
;	2275	GLOBAL ROUTINE DBG$MODULE_SIZE( MC_PTR ) =
;	2276	
;	2277	!++
;	2278	! Functional Description:
;	2279	!
;	2280	!	Given an MC pointer to a given module,
;	2281	! estimate how many bytes of RST storage would be
;	2282	! required to SET (initialize) this module into the RST.
;	2283	!
;	2284	! Calling Sequence:
;	2285	!
;	2286	!	The routine is simply called to pick up the
;	2287	! returned value.  The reason why it is global is
;	2288	! because it is called in DBG$SHOU_MODULE, of DBGSSV.B32,
;	2289	! and in ADD_MODULE, of DBGBLD.B32.
;	2290	!
;	2291	! Formal Parameters:
;	2292	!
;	2293	!	MC_PTR	-an MC pointer which tells us all we need
;	2294	!		 to know about the indicated module.
;	2295	!
;	2296	! Implicit Inputs:
;	2297	!
;	2298	!	The RST storage we consider is independent of GLOBAL
;	2299	! considerations.  This means that in all likelihood we overestimate.
;	2300	! (We guarantee NOT to underestimate in any case.)
;	2301	!
;	2302	!	How the storage manager works, and how we
;	2303	! use it to allocate all RST storage.
;	2304	!
;	2305	! Implicit Outputs:
;	2306	!
;	2307	!	none.
;	2308	!
;	2309	! Return Value:
;	2310	!
;	2311	!	The number of bytes required to add the module
;	2312	!	to the Runtime Symbol Table data structures.
;	2313	!
;	2314	!--
;	2315	
;	2316	BEGIN
;	2317		MAP
;	2318			MC_PTR : REF MC_RECORD;
;	2319		LOCAL
;	2320			TOTAL_BYTES;
;	2321		MACRO
;	2322					! Macro to calculate the total number of bytes
;	2323					! taken for so-called vector storage (which
;	2324					! is how we allocate NTs, LVTs, and SATs).
;	2325	
;	2326			VEC_STORAGE_FOR( records, size )
;	2327			=
;     M 2328			(
;     M 2329			%upval		! The storage manager's overhead,

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 4-1
; Digital Equipment Corporation
;
;     M 2330			+
;     M 2331					! Rounded up vector storage space
;     M 2332			( (RST_UNITS( records * size )) * %upval )
;     M 2333			)
;     M 2334			%;
;	2335	
;	2336		! Tally up the total number of bytes needed
;	2337		! to add the NTs, LVTs, and SATs for the
;	2338		! indicated module.
;	2339	
;	2340		TOTAL_BYTES = 0;
;	2341	
;	2342		! Although it is not true, we must assume
;	2343		! that NT entries are fixed-size. 
;	2344	
;	2345		TOTAL_BYTES = VEC_STORAGE_FOR( .MC_PTR[ MC_NAMES ], RST_NT_SIZE );
;	2346	
;	2347		! Add on that taken for SATs and LVTs.
;	2348	
;	2349		TOTAL_BYTES = .TOTAL_BYTES
;	2350			    + VEC_STORAGE_FOR( .MC_PTR[ MC_STATICS ], RST_SAT_SIZE )
;	2351			    + VEC_STORAGE_FOR( .MC_PTR[ MC_LITERALS ], RST_LVT_SIZE )
;	2352			    ;
;	2353	
;	2354		! Return the bad news.
;	2355	
;	2356		RETURN(.TOTAL_BYTES);
;	2357	END;





					 0004 0004B 	    .ENTRY  DBG$MODULE_SIZE, Save R2				      ; 2275
				       52  D4 0004D 	    CLRL    TOTAL_BYTES						      ; 2340
	   51	    04   AC 00000000G  8F  C1 0004F 	    ADDL3   #DBG$_RST_BEGIN, MC_PTR, R1				      ; 2345
	   50	    08   A1	       1C  C5 00058 	    MULL3   #28, 8(R1), R0					      ;
		         50	       03  C0 0005D 	    ADDL2   #3, R0						      ;
		         50	       04  C6 00060 	    DIVL2   #4, R0						      ;
	   52	         50	       02  78 00063 	    ASHL    #2, R0, TOTAL_BYTES					      ;
		         52	       04  C0 00067 	    ADDL2   #4, TOTAL_BYTES					      ;
	   50	    31   A1	       0A  C5 0006A 	    MULL3   #10, 49(R1), R0					      ; 2350
		         50	       03  C0 0006F 	    ADDL2   #3, R0						      ;
		         50	       04  C6 00072 	    DIVL2   #4, R0						      ;
		         50	     6240  DE 00075 	    MOVAL   (TOTAL_BYTES)[R0], R0				      ;
	   51	    35   A1	       06  C5 00079 	    MULL3   #6, 53(R1), R1					      ; 2351
		         51	       03  C0 0007E 	    ADDL2   #3, R1						      ;
		         51	       04  C6 00081 	    DIVL2   #4, R1						      ;
		         52	  08 A041  DE 00084 	    MOVAL   8(R0)[R1], TOTAL_BYTES				      ;
		         50	       52  D0 00089 	    MOVL    TOTAL_BYTES, R0					      ; 2356
					   04 0008C 	    RET     							      ; 2275

; Routine Size:  66 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 4-2
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 5
; Digital Equipment Corporation
;
;	2358	GLOBAL ROUTINE DBG$OUT_NUM_VAL ( VALUE, NEW_LENGTH, NEW_RADIX ) : NOVALUE =
;	2359	
;	2360	!++
;	2361	! Functional Description:
;	2362	!	Write out the given value according to the
;	2363	!	current output mode settings.  (By write out,
;	2364	!	we mean 'encode into the output buffer').
;	2365	!	Ignore the [NO]SYMBOLS mode setting to simply
;	2366	!	assure numeric output.
;	2367	!
;	2368	! Calling Sequence:
;	2369	!	DBG$OUT_NUM_VAL ()
;	2370	!
;	2371	! Inputs:
;	2372	!	VALUE - the actual value we are to write out.
;	2373	!	NEW_LENGTH - either 0, or the MODE_LENGTH we should use.
;	2374	!		     (0 => use current LENGTH, non-zero allows
;	2375	!		      it to be overridden.)
;	2376	!		     (The literal, NO_OVERRIDE = 0, is used for this.)
;	2377	!	NEW_RADIX - either 0, or the MODE_RADIX we should use.
;	2378	!
;	2379	! Implicit Inputs:
;	2380	!	dbg$gb_mod_ptr - points to the current mode data structure.
;	2381	!	dbg$cp_out_str - points into the output buffer at the first
;	2382	!			 place in the buffer which is available.
;	2383	!	dbg$gl_buf_siz - holds the current number of characters in
;	2384	!			 the buffer.
;	2385	!
;	2386	! Outputs:
;	2387	!	The (numeric) character representation
;	2388	!	of the value is encoded into the output buffer.
;	2389	!
;	2390	! Implicit Outputs:
;	2391	!	The buffer pointer, dbg$cp_out_str, is incremented.  
;	2392	!	The buffer count, dbg$gl_buf_siz, is incremented.
;	2393	!
;	2394	! Routine Value:
;	2395	!	NOVALUE.
;	2396	!
;	2397	! Side Effects.
;	2398	!	A leading 0 is output before HEX numerics which start with A-F
;	2399	!--
;	2400	BEGIN
;	2401		map
;	2402					! We want to look at the passed-in value
;	2403					! as a byte vector only to see if we may
;	2404					! need to put in a leading 0 for hex output.
;	2405			value : vector[ %UPVAL, byte ];
;	2406		LOCAL
;	2407			USE_LENGTH,	! THE MODE_LENGTH WE ACTUALLY USE.
;	2408			USE_RADIX;	! THE MODE_RADIX WE ACTUALLY USE.
;	2409		OWN
;	2410			format : VECTOR[4,BYTE]	! BUILD FORMAT STRING HERE.
;	2411				 INITIAL( BYTE( %ASCIC '!??' ) );
;	2412	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 5-1
; Digital Equipment Corporation
;
;	2413		! Assume that we are passed an override for
;	2414		! the LENGTH and RADIX, but revert to the
;	2415		! globally-set one if this is untrue.
;	2416	
;	2417		IF( (USE_LENGTH = .NEW_LENGTH) EQL 0 )
;	2418		THEN
;	2419			USE_LENGTH = .dbg$gb_mod_ptr [ MODE_LENGTH ];
;	2420	
;	2421		IF( (USE_RADIX = .NEW_RADIX) EQL 0 )
;	2422		THEN
;	2423			USE_RADIX = .dbg$gb_mod_ptr [ MODE_RADIX ];
;	2424	
;	2425		!+
;	2426		! -Now just build the required 2-character format
;	2427		!  string descriptor, based upon the current
;	2428		!  setting of the mode LENGTH and RADIX.
;	2429		!
;	2430		! -We assume SIGNED, for DECimal output, and
;	2431		!  take LONGword HEXadecimal either when that
;	2432		!  is explicitly the case, or when some unknown
;	2433		!  LENGTH or RADIX is indicated.
;	2434		!-
;	2435	
;	2436		FORMAT[2] = ( SELECTONE .USE_RADIX OF
;	2437				SET
;	2438				[OCTAL_RADIX]:		'O';
;	2439				[DECIMAL_RADIX]:	'S';
;	2440				[OTHERWISE]:		'X';
;	2441				TES
;	2442			    );
;	2443	
;	2444		FORMAT[3] = ( SELECTONE .USE_LENGTH OF
;	2445				SET
;	2446				[BYTE_LENGTH]:	'B';
;	2447				[WORD_LENGTH]:	'W';
;	2448				[OTHERWISE]:	'L';
;	2449				TES
;	2450			    );
;	2451	
;	2452	%IF DBG_SSV
;     L 2453	%THEN
;     U 2454		$FAO_TT_OUT (  'USE RADIX: !UL, USE LENGTH: !UL, FMT= !AC',
;     U 2455			.USE_RADIX, .USE_LENGTH, FORMAT );
;     U 2456		$FAO_TT_OUT ('VALUE IS: !XL', .VALUE);
;     U 2457	%FI
;	2458	
;	2459		! Check for hex output which begins with A-F
;	2460		
;	2461		IF( .use_radix EQL HEX_RADIX )
;	2462		then
;	2463			! Perform the check by extracting the upper BYTE of
;	2464			! what we will later output, comparing that byte with
;	2465			! the max hex number we will print out 'unadorned',
;	2466			! and then inserting a leading 0 if the check fails.
;	2467	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 5-2
; Digital Equipment Corporation
;
;	2468			IF( .value[.use_length-1] GTRA %X'9F' )
;	2469			then
;	2470				dbg$fao_put( UPLIT( %ASCIC '0' ));
;	2471			
;	2472		! Output the value and we're done.
;	2473	
;	2474		dbg$fao_put ( FORMAT, .VALUE );
;	2475	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00014 P.AAF:  .ASCII  <1>\0\<0><0>					      ;

							    .PSECT  DBG$OWN,NOEXE,  PIC,2

					      00000 FORMAT: .ASCII  <3>\!??\						      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0804 0008D 	    .ENTRY  DBG$OUT_NUM_VAL, Save R2,R11			      ; 2358
		         5B 00000000'  EF  9E 0008F 	    MOVAB   FORMAT+2, R11					      ;
		         51	  08   AC  D0 00096 	    MOVL    NEW_LENGTH, USE_LENGTH				      ; 2417
				       0B  12 0009A 	    BNEQ    1$							      ;
		         50 00000000G  EF  D0 0009C 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 2419
		         51	  01   A0  9A 000A3 	    MOVZBL  1(R0), USE_LENGTH					      ;
		         52	  0C   AC  D0 000A7 1$:     MOVL    NEW_RADIX, USE_RADIX				      ; 2421
				       07  12 000AB 	    BNEQ    2$							      ;
		         52 00000000G  FF  9A 000AD 	    MOVZBL  @DBG$GB_MOD_PTR, USE_RADIX				      ; 2423
		         50	       01  CE 000B4 2$:     MNEGL   #1, R0						      ; 2436
		         08	       52  D1 000B7 	    CMPL    USE_RADIX, #8					      ;
				       06  12 000BA 	    BNEQ    3$							      ;
		         50	  4F   8F  9A 000BC 	    MOVZBL  #79, R0						      ;
				       0F  11 000C0 	    BRB     5$							      ;
		         0A	       52  D1 000C2 3$:     CMPL    USE_RADIX, #10					      ;
				       06  12 000C5 	    BNEQ    4$							      ;
		         50	  53   8F  9A 000C7 	    MOVZBL  #83, R0						      ;
				       04  11 000CB 	    BRB     5$							      ;
		         50	  58   8F  9A 000CD 4$:     MOVZBL  #88, R0						      ;
		         6B	       50  90 000D1 5$:     MOVB    R0, FORMAT+2					      ;
		         50	       01  CE 000D4 	    MNEGL   #1, R0						      ; 2444
		         01	       51  D1 000D7 	    CMPL    USE_LENGTH, #1					      ;
				       06  12 000DA 	    BNEQ    6$							      ;
		         50	  42   8F  9A 000DC 	    MOVZBL  #66, R0						      ;
				       0F  11 000E0 	    BRB     8$							      ;
		         02	       51  D1 000E2 6$:     CMPL    USE_LENGTH, #2					      ;
				       06  12 000E5 	    BNEQ    7$							      ;
		         50	  57   8F  9A 000E7 	    MOVZBL  #87, R0						      ;
				       04  11 000EB 	    BRB     8$							      ;
		         50	  4C   8F  9A 000ED 7$:     MOVZBL  #76, R0						      ;
		    01   AB	       50  90 000F1 8$:     MOVB    R0, FORMAT+3					      ;
		         10	       52  D1 000F5 	    CMPL    USE_RADIX, #16					      ; 2461

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 5-3
; Digital Equipment Corporation
;
				       13  12 000F8 	    BNEQ    9$							      ;
		    9F   8F	  03 AC41  91 000FA 	    CMPB    VALUE-1[USE_LENGTH], #159				      ; 2468
				       0B  1B 00100 	    BLEQU   9$							      ;
			    00000000'  EF  9F 00102 	    PUSHAB  P.AAF						      ; 2470
		  FEF3   CF	       01  FB 00108 	    CALLS   #1, DBG$FAO_PUT					      ;
				  04   AC  DD 0010D 9$:     PUSHL   VALUE						      ; 2474
				  FE   AB  9F 00110 	    PUSHAB  FORMAT						      ;
		  FEE8   CF	       02  FB 00113 	    CALLS   #2, DBG$FAO_PUT					      ;
					   04 00118 	    RET     							      ; 2358

; Routine Size:  140 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 6
; Digital Equipment Corporation
;
;	2476	GLOBAL ROUTINE DBG$OUT_PUT ( BUFFER ) : NOVALUE =
;	2477	
;	2478	!++
;	2479	! Functional Description:
;	2480	!	Cause the current output buffer to be actually
;	2481	!	output to the console.
;	2482	!
;	2483	! Calling Sequence:
;	2484	!	DBG$OUT_PUT ()
;	2485	!
;	2486	! Inputs:
;	2487	!	BUFFER - pointer to the beginning of the current output
;	2488	!		buffer.  this is supposed to be a counted
;	2489	!		string except that noone has supplied the count yet.
;	2490	!		ie we expect that the actual string to be printed
;	2491	!		starts in byte BUFFER+1.
;	2492	!
;	2493	! Implicit Inputs:
;	2494	!	dbg$cp_out_str - points into this output buffer at the first
;	2495	!			 place in the buffer which is NOT to be printed.
;	2496	!	dbg$gl_buf_siz - holds count of characters in buffer
;	2497	!
;	2498	! Outputs:
;	2499	!	The string is printed, exactly as it is in the
;	2500	!	buffer - ie, it should contain whatever carriage control 
;	2501	!	you want.
;	2502	!
;	2503	! Implicit Outputs:
;	2504	!	The buffer pointer, dbg$cp_out_str, is set to zero.  This will
;	2505	!	help routines know if they are to use their own buffer or
;	2506	!	if one is already partially built.
;	2507	! ***	I don't think we have ever actually used the above
;	2508	!	'feature', and feel that this routine ought, instead, set
;	2509	!	up for more dbg$fao_put calls on the current buffer when we
;	2510	!	are called to output it.
;	2511	!
;	2512	! Routine Value:
;	2513	!	NOVALUE.
;	2514	!
;	2515	! Side Effects.
;	2516	!	none.
;	2517	!--
;	2518	
;	2519		BEGIN
;	2520		MAP
;	2521			BUFFER : REF VECTOR[,BYTE];	! POINTS TO OUTPUT BUFFER.
;	2522	
;	2523	
;	2524		! Fill in the count, and pass it to QIO.
;	2525	
;	2526		BUFFER [0] = .dbg$gl_buf_siz;
;	2527		$FAO_TT_OUT ( '!AC', .BUFFER );
;	2528		dbg$cp_out_str = 0;
;	2529		END;


; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 6-1
; Digital Equipment Corporation
;


							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00018 P.AAG:  .BYTE   3							      ;
					      00019 	    .ASCII  \!AC\						      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0000 00119 	    .ENTRY  DBG$OUT_PUT, Save nothing				      ; 2476
		    04   BC 00000000G  EF  90 0011B 	    MOVB    DBG$GL_BUF_SIZ, @BUFFER				      ; 2526
				  04   AC  DD 00123 	    PUSHL   BUFFER						      ; 2527
			    00000000'  EF  9F 00126 	    PUSHAB  P.AAG						      ;
	      00000000G  EF	       02  FB 0012C 	    CALLS   #2, DBG$FAO_OUT					      ;
			    00000000G  EF  D4 00133 	    CLRL    DBG$CP_OUT_STR					      ; 2528
					   04 00139 	    RET     							      ; 2476

; Routine Size:  33 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7
; Digital Equipment Corporation
;
;	2530	GLOBAL ROUTINE DBG$OUT_SYM_VAL ( VALUE, NEW_LENGTH, symbol_nt_ptr ) : NOVALUE =
;	2531	
;	2532	!++
;	2533	! Functional Description:
;	2534	!	Write out the given value according to the current
;	2535	!	mode settings - including the current mode setting
;	2536	!	for the [NO]SYMBOLS flag.  (By 'write out', we mean
;	2537	!	'encode into the output buffer').
;	2538	!
;	2539	! Calling Sequence:
;	2540	!	DBG$OUT_SYM_VAL ()
;	2541	!
;	2542	! Inputs:
;	2543	!	VALUE - the actual value we are to write out.
;	2544	!	NEW_LENGTH - either 0, or the MODE_LENGTH we should use.
;	2545	!		     (0 => use current LENGTH, non-zero allows
;	2546	!		      it to be overridden.)
;	2547	!		     (The literal, NO_OVERRIDE = 0, is used for this.)
;	2548	!	symbol_nt_ptr	-Either 0, or the supposed NT_PTR which the
;	2549	!			 VALUE came from in the first place.
;	2550	!
;	2551	! Implicit Inputs:
;	2552	!
;	2553	!	If OUT_SYM_VAL is called, no radix override is desired
;	2554	!	if we have to resort to numeric output.
;	2555	!
;	2556	!	dbg$gb_mod_ptr - points to the current mode data structure.
;	2557	!	dbg$cp_out_str - points into the output buffer at the first
;	2558	!			 place in the buffer which is available.
;	2559	!	dbg$gl_buf_siz - holds the current number of characters in
;	2560	!			 the buffer.
;	2561	!
;	2562	! Outputs:
;	2563	!	The symbolic or numeric (or symbolic+residue) representation
;	2564	!	of the value is encoded into the output buffer.
;	2565	!
;	2566	! Implicit Outputs:
;	2567	!	The buffer pointer, dbg$cp_out_str, is incremented.  
;	2568	!	The buffer count, dbg$gl_buf_siz, is incremented.
;	2569	!
;	2570	! Routine Value:
;	2571	!	NOVALUE.
;	2572	!
;	2573	! Side Effects.
;	2574	!	The VALUE is printed out.
;	2575	!--
;	2576		BEGIN
;	2577		MAP
;	2578			symbol_nt_ptr : ref NT_RECORD;
;	2579		LOCAL
;	2580					! The address of an array descriptor,
;	2581					! if we symbolize an array reference.
;	2582			ARRAY_DESC_ADDR,
;	2583	
;	2584					! A pointer to the name table (NT) entry

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-1
; Digital Equipment Corporation
;
;	2585					! which corresponds to the symbol which we
;	2586					! deal with if we do symbolic output.
;	2587			NT_PTR : REF NT_RECORD,
;	2588	
;	2589					! Used to recover the actual or real value
;	2590					! of the symbol we may base our symbolic
;	2591					! output off.
;	2592			REAL_VALUE,
;	2593	
;	2594					! Symbol path vector used to contain the
;	2595					! whole pathname assocaited with the
;	2596					! symbol pointed to by NT_PTR, above.
;	2597			PATH_VEC : PATHNAME_VECTOR;
;	2598	
;	2599	%IF DBG_SSV4
;     L 2600	%THEN
;     U 2601		$FAO_TT_OUT('out_sym_val=!XL, hint nt_ptr=!XW',.value,.symbol_nt_ptr);
;     U 2602	%FI
;	2603	
;	2604	! First, see if the value is an exact match to a DEFine
;	2605	! type symbol.  Note that these symbols have nothing to do with
;	2606	! the so-called RST and so much be handled specially.
;	2607	
;	2608	IF( .DBG$GB_MOD_PTR[ MODE_SYMBOLS ] )
;	2609	THEN
;	2610		BEGIN
;	2611		LOCAL
;	2612			INDEX;
;	2613	
;	2614		IF( (INDEX = DBG$FIND_VAL(.VALUE,TRUE)) NEQ 0 )
;	2615		THEN
;	2616			BEGIN
;	2617	
;	2618			! Found an exact match.  Print this and
;	2619			! return an OK status.
;	2620	
;	2621			dbg$fao_put(uplit(%ascic '!AD'),.sym_chcount(.index),sym_name(.index));
;	2622			return;
;	2623			end;
;	2624		end;
;	2625	
;	2626	!+
;	2627	! Then, see if the value is an exact match to a register name
;	2628	! symbol.  Note that these symbols have nothing to do with
;	2629	! the so-called RST and so much be handled specially.  Also
;	2630	! note that this symbolization is done whether or not
;	2631	! the MODE is SYMBOLIC, unless the value we are
;	2632	! to symbolize came from some other RST symbol.
;	2633	!-
;	2634	
;	2635	IF( (NOT .dbg$gb_mod_ptr[ MODE_SYMBOLS ] )
;	2636	   OR
;	2637	    (.symbol_nt_ptr EQL 0 )
;	2638	  )
;	2639	THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-2
; Digital Equipment Corporation
;
;	2640		IF( dbg$out_regname(.value) )
;	2641		THEN
;	2642			! An exact match was found and output so we're done.
;	2643	
;	2644			RETURN;
;	2645	
;	2646	!+
;	2647	! Now we try to symbolize based on the RST.  The are two
;	2648	! flavors here, either we have to work things out from
;	2649	! scratch, or someone has passed us a hint of where to
;	2650	! start from.  This is indicated by symbol_nt_ptr.
;	2651	!-
;	2652	
;	2653	ARRAY_DESC_ADDR = 0;
;	2654	nt_ptr = 0;
;	2655	
;	2656	IF( .symbol_nt_ptr EQL 0 )
;	2657	THEN
;	2658		BEGIN
;	2659	
;	2660		! See if we should even attempt symbolic output.
;	2661		
;	2662		IF( .dbg$gb_mod_ptr[ MODE_SYMBOLS ] )
;	2663		THEN
;	2664			! Next, ask VAL_TO_SYM for the NT-pointer which
;	2665			! corresponds to the symbol we should use.
;	2666			! The 'FALSE' says that we don't want LVTs
;	2667			! (literals) to be considered.
;	2668		
;	2669			IF( NOT DBG$VAL_TO_SYM( .VALUE, NT_PTR, FALSE ) )
;	2670			THEN
;	2671				nt_ptr = 0;
;	2672		END
;	2673	ELSE
;	2674		! We graciously accept the given hint.
;	2675	
;	2676		nt_ptr = .symbol_nt_ptr;
;	2677	
;	2678	!+
;	2679	! At this point, nt_ptr either tells us where to start from,
;	2680	! or it being 0 tells us not to bother.  Likewise we don't
;	2681	! bother to symbolize if the MODE says not to.
;	2682	!-
;	2683		
;	2684	%if dbg_ssv4
;     L 2685	%then
;     U 2686		$fao_tt_out('out_sym_val starting with NT_PTR=!XL',.nt_ptr);
;     U 2687	%FI
;	2688	
;	2689	IF( .dbg$gb_mod_ptr[ MODE_SYMBOLS ] )
;	2690	THEN
;	2691		IF( .nt_ptr neq 0 )
;	2692		THEN
;	2693			! Then, to be able and output "symbol+offset",
;	2694			! we must be able to recover the actual value

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-3
; Digital Equipment Corporation
;
;	2695			! of the indicated symbol.
;	2696	
;	2697			IF( DBG$SYMBOL_VALU( .NT_PTR, REAL_VALUE ) )
;	2698			THEN
;	2699				BEGIN
;	2700	
;	2701				! See if the value picked up by DBG$SYMBOL_VALU is
;	2702				! really the address which is bound to the
;	2703				! symbol, or if it is the address of a descriptor.
;	2704				! Note that DST_PTR is invalid for NTs which
;	2705				! were created only for global symbols.
;	2706	
;	2707				IF( .NT_PTR[ NT_UP_SCOPE ] NEQ 0 )
;	2708				THEN
;	2709					BEGIN
;	2710					LOCAL
;	2711						BOUNDS : ARRAY_BNDS_DESC,
;	2712						DST_RECRD : REF DST_RECORD;
;	2713	
;	2714					! Pick up the DST pointer so that we can see
;	2715					! if access is via descriptor.  
;	2716	
;	2717					DST_RECRD = .NT_PTR[ NT_DST_PTR ];
;	2718	
;	2719					IF( .DST_RECRD[ DSTR_ACCES_TYPE ] EQL ACCS_DESCRIPTOR )
;	2720					THEN
;	2721						BEGIN
;	2722	
;	2723						! REAL_VALUE, returned above, is actually
;	2724						! the address of a descriptor.  Modify this
;	2725						! value to be the beginning virtual address
;	2726						! of the array.
;	2727	
;	2728						ARRAY_DESC_ADDR = .REAL_VALUE;
;	2729						DBG$GET_BOUNDS( .ARRAY_DESC_ADDR, BOUNDS );
;	2730						REAL_VALUE = .BOUNDS[ ARRAY_ADDRESS ];
;	2731						END;
;	2732					END;
;	2733	
;	2734				! For unbounded symbols, we don't
;	2735				! allow "symbol+offset" unless "offset"
;	2736				! is less than a maximum value.
;	2737	
;	2738				IF( ((.VALUE - .REAL_VALUE) LSSA RST_MAX_OFFSET )
;	2739				   OR
;	2740				    (.NT_PTR[ NT_IS_BOUNDED ] )
;	2741				  )
;	2742				THEN
;	2743					BEGIN
;	2744	
;	2745					! We have all we need now, so just
;	2746					! encode the characters into the
;	2747					! output stream. To do this we
;	2748					! must first build a pathname vector
;	2749					! to correspond to the NT scope chain we

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-4
; Digital Equipment Corporation
;
;	2750					! implicitly now have.
;	2751	
;	2752					DBG$ADD_NT_2_PV( .NT_PTR, PATH_VEC );
;	2753	
;	2754					! Then we simply print this vector.
;	2755	
;	2756					DBG$PRINT_PATH( PATH_VEC );
;	2757	
;	2758					! Extra symbolization for array references
;	2759					! and %line PCs in FORTRAN only.  Otherwise,
;	2760					! even if it is an array, we still want
;	2761					! "symbol+offset" if the language is not FORTRAN.
;	2762	
;	2763					IF( .DBG$GB_LANGUAGE EQL FORTRAN_LANG )
;	2764					THEN
;	2765						BEGIN
;	2766						IF( .ARRAY_DESC_ADDR NEQ 0 )
;	2767						THEN
;	2768							REAL_VALUE = PUT_BOUNDS( .VALUE, .ARRAY_DESC_ADDR )
;	2769						ELSE
;	2770							! %line NN can only follow a ROUTINE symbol.
;	2771		
;	2772							IF( .NT_PTR[ NT_TYPE ] EQL DSC$K_DTYPE_RTN )
;	2773							THEN
;	2774								REAL_VALUE = PUT_LINE(.NT_PTR,.VALUE,.REAL_VALUE);
;	2775						END;
;	2776	
;	2777					! See if there is any residue - i.e. see if
;	2778					! "symbol", "symbol %line NN ", or "symbol(x,y,z)"
;	2779					! is enough, or if we need to add "+offset".
;	2780	
;	2781					IF( .VALUE EQL .REAL_VALUE )
;	2782					THEN
;	2783						! No residue -> we're done.
;	2784	
;	2785						RETURN;
;	2786	
;	2787					! The residue (offset) should
;	2788					! be printed in numeric form, preceeded
;	2789					! by a '+'.
;	2790	
;	2791					dbg$fao_put(UPLIT(%ASCIC '+'));
;	2792	
;	2793					VALUE = .VALUE-.REAL_VALUE;
;	2794	
;	2795					! We should be able to simply
;	2796					! drop out of this part of the
;	2797					! code and have this done by DBG$OUT_NUM_VAL.
;	2798					! Until FAO can print HEX without the leading
;	2799					! 0s, we must do the following...
;	2800	
;	2801					IF( .dbg$gb_mod_ptr[ MODE_RADIX ] EQL HEX_RADIX )
;	2802					THEN
;	2803						BEGIN
;	2804	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-5
; Digital Equipment Corporation
;
;	2805						! Special cludge to ignore leading 0s,
;	2806						! but to then put excatly 1 leading 0 when
;	2807						! the rest begins with A-F.
;	2808	
;	2809						LOCAL
;	2810							CLUDGE_SIZE;	! # of non-zero digits.
;	2811	
;	2812						! We must always print atleast 1 digit.
;	2813	
;	2814						CLUDGE_SIZE = 1;
;	2815	
;	2816						INCR I FROM 1 TO 7
;	2817							DO
;	2818							IF( .VALUE<.I*4,4,0> NEQ 0 )
;	2819							THEN
;	2820								CLUDGE_SIZE = .I+1;
;	2821	
;	2822						! If what we would print would start
;	2823						! with A-F, insert a leading 0.
;	2824	
;	2825						IF( .value<0,.cludge_size*4,1> GTRA %X'fffffff9' )
;	2826						then
;	2827							dbg$fao_put( uplit( %ASCIC '0' ));
;	2828						dbg$fao_put( UPLIT( %ASCIC '!#XL' ),
;	2829							.CLUDGE_SIZE,.VALUE);
;	2830						RETURN;
;	2831						END;
;	2832					END;
;	2833				END;
;	2834	
;	2835	! At this point, we didn't try to do symbolic output, or
;	2836	! we failed completely at it, or
;	2837	! it went OK but we still have a 'residue'. 
;	2838	! Therefore we still have a value to output before we're done.
;	2839	
;	2840	DBG$OUT_NUM_VAL( .VALUE, .NEW_LENGTH, NO_OVERRIDE );
;	2841	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      0001C P.AAH:  .ASCII  <3>\!AD\						      ;
					      00020 P.AAI:  .ASCII  <1>\+\<0><0>					      ;
					      00024 P.AAJ:  .ASCII  <1>\0\<0><0>					      ;
					      00028 P.AAK:  .ASCII  <4>\!#XL\<0><0><0>					      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0E1C 0013A 	    .ENTRY  DBG$OUT_SYM_VAL, Save R2,R3,R4,R9,R10,R11		      ; 2530
		         59	FEC0   CF  9E 0013C 	    MOVAB   DBG$FAO_PUT, R9					      ;
		         5A 00000000'  EF  9E 00141 	    MOVAB   P.AAH, R10						      ;
		         5B 00000000G  EF  9E 00148 	    MOVAB   DBG$GB_MOD_PTR, R11					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-6
; Digital Equipment Corporation
;
		         5E	       3C  C2 0014F 	    SUBL2   #60, SP						      ;
		         50	       6B  D0 00152 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 2608
		         1C	  02   A0  E9 00155 	    BLBC    2(R0), 1$						      ;
				       01  DD 00159 	    PUSHL   #1							      ; 2614
				  04   AC  DD 0015B 	    PUSHL   VALUE						      ;
	      00000000G  EF	       02  FB 0015E 	    CALLS   #2, DBG$FIND_VAL					      ;
				       50  D5 00165 	    TSTL    INDEX						      ;
				       0C  13 00167 	    BEQL    1$							      ;
				  0D   A0  9F 00169 	    PUSHAB  13(INDEX)						      ; 2621
		         7E	  0C   A0  9A 0016C 	    MOVZBL  12(R0), -(SP)					      ;
				       5A  DD 00170 	    PUSHL   R10							      ;
				     0137  31 00172 	    BRW     16$							      ;
		         50	       6B  D0 00175 1$:     MOVL    DBG$GB_MOD_PTR, R0					      ; 2635
		         05	  02   A0  E9 00178 	    BLBC    2(R0), 2$						      ;
				  0C   AC  D5 0017C 	    TSTL    SYMBOL_NT_PTR					      ; 2637
				       0E  12 0017F 	    BNEQ    3$							      ;
				  04   AC  DD 00181 2$:     PUSHL   VALUE						      ; 2640
	      00000000G  EF	       01  FB 00184 	    CALLS   #1, DBG$OUT_REGNAME					      ;
		         01	       50  E9 0018B 	    BLBC    R0, 3$						      ;
					   04 0018E 	    RET     							      ;
				       54  D4 0018F 3$:     CLRL    ARRAY_DESC_ADDR					      ; 2653
				  04   AE  D4 00191 	    CLRL    NT_PTR						      ; 2654
				  0C   AC  D5 00194 	    TSTL    SYMBOL_NT_PTR					      ; 2656
				       1E  12 00197 	    BNEQ    4$							      ;
		         50	       6B  D0 00199 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 2662
		         1C	  02   A0  E9 0019C 	    BLBC    2(R0), 5$						      ;
				       7E  D4 001A0 	    CLRL    -(SP)						      ; 2669
				  08   AE  9F 001A2 	    PUSHAB  NT_PTR						      ;
				  04   AC  DD 001A5 	    PUSHL   VALUE						      ;
	      00000000G  EF	       03  FB 001A8 	    CALLS   #3, DBG$VAL_TO_SYM					      ;
		         0A	       50  E8 001AF 	    BLBS    R0, 5$						      ;
				  04   AE  D4 001B2 	    CLRL    NT_PTR						      ; 2671
				       05  11 001B5 	    BRB     5$							      ; 2662
		    04   AE	  0C   AC  D0 001B7 4$:     MOVL    SYMBOL_NT_PTR, NT_PTR				      ; 2676
		         50	       6B  D0 001BC 5$:     MOVL    DBG$GB_MOD_PTR, R0					      ; 2689
		         03	  02   A0  E8 001BF 	    BLBS    2(R0), 7$						      ;
				     00EA  31 001C3 6$:     BRW     17$							      ;
		         53	  04   AE  D0 001C6 7$:     MOVL    NT_PTR, R3						      ; 2691
				       F7  13 001CA 	    BEQL    6$							      ;
				4008   8F  BB 001CC 	    PUSHR   #^M<R3,SP>						      ; 2697
	      00000000G  EF	       02  FB 001D0 	    CALLS   #2, DBG$SYMBOL_VALU					      ;
		         E9	       50  E9 001D7 	    BLBC    R0, 6$						      ;
		         52 00000000G  E3  9E 001DA 	    MOVAB   DBG$_RST_BEGIN(R3), R2				      ; 2707
				  08   A2  B5 001E1 	    TSTW    8(R2)						      ;
				       1F  13 001E4 	    BEQL    8$							      ;
		         50	  04   A2  D0 001E6 	    MOVL    4(R2), DST_RECRD					      ; 2717
      02   A0	         02	       00  ED 001EA 	    CMPZV   #0, #2, 2(DST_RECRD), #2				      ; 2719
				       02     001EF									      ;
				       13  12 001F0 	    BNEQ    8$							      ;
		         54	       6E  D0 001F2 	    MOVL    REAL_VALUE, ARRAY_DESC_ADDR				      ; 2728
				  08   AE  9F 001F5 	    PUSHAB  BOUNDS						      ; 2729
				       54  DD 001F8 	    PUSHL   ARRAY_DESC_ADDR					      ;
	      00000000G  EF	       02  FB 001FA 	    CALLS   #2, DBG$GET_BOUNDS					      ;
		         6E	  08   AE  D0 00201 	    MOVL    BOUNDS, REAL_VALUE					      ; 2730
	   50	    04   AC	       6E  C3 00205 8$:     SUBL3   REAL_VALUE, VALUE, R0				      ; 2738

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-7
; Digital Equipment Corporation
;
	      00000100   8F	       50  D1 0020A 	    CMPL    R0, #256						      ;
				       05  1F 00211 	    BLSSU   9$							      ;
	   AB	    03   A2	       07  E1 00213 	    BBC     #7, 3(R2), 6$					      ; 2740
				  10   AE  9F 00218 9$:     PUSHAB  PATH_VEC						      ; 2752
				       53  DD 0021B 	    PUSHL   R3							      ;
	      00000000G  EF	       02  FB 0021D 	    CALLS   #2, DBG$ADD_NT_2_PV					      ;
				  10   AE  9F 00224 	    PUSHAB  PATH_VEC						      ; 2756
		  0000V  CF	       01  FB 00227 	    CALLS   #1, DBG$PRINT_PATH					      ;
		         01 00000000G  EF  91 0022C 	    CMPB    DBG$GB_LANGUAGE, #1					      ; 2763
				       26  12 00233 	    BNEQ    12$							      ;
				       54  D5 00235 	    TSTL    ARRAY_DESC_ADDR					      ; 2766
				       0C  13 00237 	    BEQL    10$							      ;
				       54  DD 00239 	    PUSHL   ARRAY_DESC_ADDR					      ; 2768
				  04   AC  DD 0023B 	    PUSHL   VALUE						      ;
		  0000V  CF	       02  FB 0023E 	    CALLS   #2, PUT_BOUNDS					      ;
				       13  11 00243 	    BRB     11$							      ;
		    BE   8F	  02   A2  91 00245 10$:    CMPB    2(R2), #190						      ; 2772
				       0F  12 0024A 	    BNEQ    12$							      ;
				       6E  DD 0024C 	    PUSHL   REAL_VALUE						      ; 2774
				  04   AC  DD 0024E 	    PUSHL   VALUE						      ;
				       53  DD 00251 	    PUSHL   R3							      ;
		  0000V  CF	       03  FB 00253 	    CALLS   #3, PUT_LINE					      ;
		         6E	       50  D0 00258 11$:    MOVL    R0, REAL_VALUE					      ;
		         6E	  04   AC  D1 0025B 12$:    CMPL    VALUE, REAL_VALUE					      ; 2781
				       5A  13 0025F 	    BEQL    18$							      ;
				  04   AA  9F 00261 	    PUSHAB  P.AAI						      ; 2791
		         69	       01  FB 00264 	    CALLS   #1, DBG$FAO_PUT					      ;
		    04   AC	       6E  C2 00267 	    SUBL2   REAL_VALUE, VALUE					      ; 2793
		         10	  00   BB  91 0026B 	    CMPB    @DBG$GB_MOD_PTR, #16				      ; 2801
				       3F  12 0026F 	    BNEQ    17$							      ;
		         53	       01  D0 00271 	    MOVL    #1, CLUDGE_SIZE					      ; 2814
		         50	       01  D0 00274 	    MOVL    #1, I						      ; 2816
	   51	         50	       02  78 00277 13$:    ASHL    #2, I, R1						      ; 2818
      04   AC	         04	       51  EF 0027B 	    EXTZV   R1, #4, VALUE, R2					      ;
				       52     00280									      ;
				       04  13 00281 	    BEQL    14$							      ;
	   53	         50	       01  C1 00283 	    ADDL3   #1, I, CLUDGE_SIZE					      ; 2820
	   EC	         50	       07  F3 00287 14$:    AOBLEQ  #7, I, 13$						      ; 2816
	   50	         53	       02  78 0028B 	    ASHL    #2, CLUDGE_SIZE, R0					      ; 2825
      04   AC	         50	       00  EE 0028F 	    EXTV    #0, R0, VALUE, R1					      ;
				       51     00294									      ;
	      FFFFFFF9   8F	       51  D1 00295 	    CMPL    R1, #-7						      ;
				       06  1B 0029C 	    BLEQU   15$							      ;
				  08   AA  9F 0029E 	    PUSHAB  P.AAJ						      ; 2827
		         69	       01  FB 002A1 	    CALLS   #1, DBG$FAO_PUT					      ;
				  04   AC  DD 002A4 15$:    PUSHL   VALUE						      ; 2828
				       53  DD 002A7 	    PUSHL   CLUDGE_SIZE						      ;
				  0C   AA  9F 002A9 	    PUSHAB  P.AAK						      ;
		         69	       03  FB 002AC 16$:    CALLS   #3, DBG$FAO_PUT					      ;
					   04 002AF 	    RET     							      ; 2830
				       7E  D4 002B0 17$:    CLRL    -(SP)						      ; 2840
		         7E	  04   AC  7D 002B2 	    MOVQ    VALUE, -(SP)					      ;
		  008D   C9	       03  FB 002B6 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
					   04 002BB 18$:    RET     							      ; 2530


; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 7-8
; Digital Equipment Corporation
;
; Routine Size:  386 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 8
; Digital Equipment Corporation
;
;	2842	ROUTINE PUT_LINE( NT_PTR, PC_IN_RTN, PC_BEGIN_RTN ) =
;	2843	
;	2844	!++
;	2845	! Functional Description:
;	2846	!
;	2847	!	See if we are outputting a FORTRAN %line symbolization,
;	2848	!	and output the %line part of it if this is so.
;	2849	!
;	2850	! Formal Parameters:
;	2851	!
;	2852	!	NT_PTR		-A pointer to the name table record
;	2853	!			 for the symbol we are offsetting from
;	2854	!	PC_IN_RTN	-The PC in the indicated routine,
;	2855	!	PC_BEGIN_RTN	-The PC value at the beginning of the routine.
;	2856	!
;	2857	! Implicit Inputs:
;	2858	!
;	2859	!	The output buffer has been initialized and
;	2860	!	the pathname of the routine we are %LINE-ing from
;	2861	!	has been encoded into it.
;	2862	!
;	2863	! Implicit Outputs:
;	2864	!
;	2865	!	The output buffer is filled in unless this is
;	2866	!	not a %line reference.
;	2867	!
;	2868	! Routine Value:
;	2869	!
;	2870	!	The real PC value of the %line we put out,
;	2871	! OR
;	2872	!	the value of what has been symbolized so far
;	2873	!	if no %line symbolization was done herein.
;	2874	!
;	2875	! Side Effects:
;	2876	!
;	2877	!	The output buffer may be filled in. (see above)
;	2878	!--
;	2879	BEGIN
;	2880		LOCAL
;	2881			line_1,		! The %line number we will put out.
;	2882			line_1_pc,	! The PC value for LINE_1
;	2883			exc_type;
;	2884	
;	2885	%IF DBG_SSV3
;     L 2886	%THEN
;     U 2887		$FAO_TT_OUT('!/put_line: pc in rtn = !XL, rtn begins at !XL',
;     U 2888			.pc_in_rtn,.pc_begin_rtn);
;     U 2889	%FI
;	2890		! If the PC we're at is exactly the same at
;	2891		! the beginning of the routine, then there
;	2892		! is no %LINE symbolization.
;	2893	
;	2894		IF( .PC_IN_RTN EQLA .PC_BEGIN_RTN )
;	2895		THEN
;	2896			RETURN(.PC_BEGIN_RTN);

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 8-1
; Digital Equipment Corporation
;
;	2897	
;	2898		! A DPC routine does most of the work.
;	2899		! We just do the initializations and check
;	2900		! the return status.
;	2901	
;	2902		line_1_pc = .nt_ptr;
;	2903		EXC_TYPE = LOOKUP_EXC;
;	2904	
;	2905		IF( NOT DBG$PC_TO_LINE(	PC_IN_RTN,
;	2906					.pc_begin_rtn,
;	2907					EXC_TYPE,
;	2908					LINE_1,
;	2909					LINE_1_PC
;	2910				      ) )
;	2911		THEN
;	2912			! No %line symbolization is possible.
;	2913	
;	2914			RETURN(.pc_begin_rtn);
;	2915	
;	2916		DBG$FAO_PUT(uplit(%ascic ' %line !UL '), .line_1 );
;	2917	
;	2918	%IF DBG_SSV3
;     L 2919	%THEN
;     U 2920		$fao_tt_out('!/put_line: %line !XL <=> PC !XL',
;     U 2921			.line_1,.line_1_pc);
;     U 2922	%FI
;	2923		! Return the PC value of the %LINE we just
;	2924		! output.
;	2925	
;	2926		RETURN(.LINE_1_PC);
;	2927	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00030 P.AAL:  .ASCII  <11>\ %line !UL \					      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0000 002BC PUT_LINE:
							    .WORD   Save nothing					      ; 2842
		         5E	       0C  C2 002BE 	    SUBL2   #12, SP						      ;
		    0C   AC	  08   AC  D1 002C1 	    CMPL    PC_IN_RTN, PC_BEGIN_RTN				      ; 2894
				       21  13 002C6 	    BEQL    1$							      ;
		    08   AE	  04   AC  D0 002C8 	    MOVL    NT_PTR, LINE_1_PC					      ; 2902
		         6E	       03  D0 002CD 	    MOVL    #3, EXC_TYPE					      ; 2903
				  08   AE  9F 002D0 	    PUSHAB  LINE_1_PC						      ; 2905
				  08   AE  9F 002D3 	    PUSHAB  LINE_1						      ;
				  08   AE  9F 002D6 	    PUSHAB  EXC_TYPE						      ;
				  0C   AC  DD 002D9 	    PUSHL   PC_BEGIN_RTN					      ;
				  08   AC  9F 002DC 	    PUSHAB  PC_IN_RTN						      ;
	      00000000G  EF	       05  FB 002DF 	    CALLS   #5, DBG$PC_TO_LINE					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 8-2
; Digital Equipment Corporation
;
		         05	       50  E8 002E6 	    BLBS    R0, 2$						      ;
		         50	  0C   AC  D0 002E9 1$:     MOVL    PC_BEGIN_RTN, R0					      ; 2914
					   04 002ED 	    RET     							      ;
				  04   AE  DD 002EE 2$:     PUSHL   LINE_1						      ; 2916
			    00000000'  EF  9F 002F1 	    PUSHAB  P.AAL						      ;
		  FD04   CF	       02  FB 002F7 	    CALLS   #2, DBG$FAO_PUT					      ;
		         50	  08   AE  D0 002FC 	    MOVL    LINE_1_PC, R0					      ; 2926
					   04 00300 	    RET     							      ; 2842

; Routine Size:  69 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9
; Digital Equipment Corporation
;
;	2928	ROUTINE PUT_BOUNDS( IN_ARRAY, DESCRIP_BLOCK ) =
;	2929	
;	2930	!++
;	2931	! Functional Description:
;	2932	!
;	2933	!	Put the description of the given array reference
;	2934	!	into the current output buffer in the form "(X1, X2, ... Xn)",
;	2935	!	or symbolize a given CHARACTER [sub-]string reference
;	2936	!	using the form "(begin_position : end_position)".
;	2937	!
;	2938	! Formal Parameters:
;	2939	!	IN_ARRAY	-address, supposedly in the indicated array
;	2940	!			 or CHARACTER string which we are to symbolize.
;	2941	!	DESCRIP_BLOCK	-address of SRM array descriptor. _CLASSes _S 
;	2942	!			 and _A are supported.
;	2943	!
;	2944	! Implicit Inputs:
;	2945	!
;	2946	!	FORTRAN arrays have a max of 7 dimensions.
;	2947	!
;	2948	!	The SRM-defined notion of 'array descriptor' is assumed.
;	2949	!
;	2950	! Implicit Outputs:
;	2951	!
;	2952	!	The output buffer is filled in unless the given IN_ARRAY
;	2953	!	value is before the supposed beginning of the array.
;	2954	!	This should never happen because DBG$VAL_TO_SYM has
;	2955	!	already checked this.  If it does, the 'residue' value
;	2956	!	returned in the IN_ARRAY value given in the first place
;	2957	!	so the effect will be as if this routine had
;	2958	!	not been called.  The same is done if a CHARACTER reference
;	2959	!	is detected which overflows the supposed string.
;	2960	!
;	2961	! Routine Value:
;	2962	!	How many bytes there are left after the array
;	2963	!	reference we printed is taken into consideration.
;	2964	!
;	2965	! Side Effects:
;	2966	!
;	2967	!	The ouptut buffer is filled in. (see above)
;	2968	!--
;	2969	BEGIN
;	2970		MAP
;	2971			DESCRIP_BLOCK : REF BLOCK [,BYTE];
;	2972		LOCAL
;	2973			MAX_DIMENSION,
;	2974			RESIDUE,			! Bytes left over
;	2975			BOUNDS : ARRAY_BNDS_DESC,
;	2976			INDEX : VECTOR[7,LONG],
;	2977			SPAN_BLOCK : REF VECTOR,
;	2978			LB_BLOCK : REF VECTOR;
;	2979		BIND
;	2980					! CHARACTER sub-string references in FORTRAN
;	2981			substring = UPLIT( %ASCIC '(!SL:!SL)' );
;	2982	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9-1
; Digital Equipment Corporation
;
;	2983	%IF DBG_SSV2
;     L 2984	%THEN
;     U 2985		$FAO_TT_OUT('!/put_array: ref is to !XL, desc is at !XL ',
;     U 2986			.IN_ARRAY,.descrip_block);
;     U 2987	%FI
;	2988	
;	2989		! See that we have been given a valid array
;	2990		! descriptor.  This should already have been
;	2991		! checked.  If it fails, there is no return
;	2992		! because a signal is generated.
;	2993	
;	2994		DBG$GET_BOUNDS( .DESCRIP_BLOCK, BOUNDS );
;	2995	
;	2996		! If the given IN_ARRAY address comes before
;	2997		! the beginning of the array, this symbolization could
;	2998		! not possibly work.  If this is the case, simply return
;	2999		! the address where the 'array' does start
;	3000		! and OUT_SYM_VAL will print the residue in a
;	3001		! non-elegant fashion.
;	3002	
;	3003		IF( .IN_ARRAY LSSA .BOUNDS[ ARRAY_ADDRESS ] )
;	3004		THEN
;	3005			RETURN(.bounds[ array_address ]);
;	3006	
;	3007		! Set 'residue' to the number of bytes into the array
;	3008		! that the given reference is to.
;	3009	
;	3010		RESIDUE = .IN_ARRAY - .DESCRIP_BLOCK[ DSC$A_POINTER ];
;	3011	
;	3012		! If this is not really an array reference,
;	3013		! then it must be a _CLASS_S type symbolization.
;	3014		! This corresponds to FORTRAN CHARACTER variables.
;	3015	
;	3016		IF( .DESCRIP_BLOCK[ DSC$B_CLASS ] EQL DSC$K_CLASS_S )
;	3017		THEN
;	3018			BEGIN
;	3019	
;	3020			! Static character string symbolizations look kinda
;	3021			! like array references.  First check that the
;	3022			! reference is actually within the string.
;	3023	
;	3024			IF( NOT .RESIDUE LSS .BOUNDS[ ARRAY_LENGTH ] )
;	3025			THEN
;	3026				! Don't symbolize and cause the calling
;	3027				! routine to output simply "sym + off"
;	3028	
;	3029				RETURN(.BOUNDS[ ARRAY_ADDRESS ]);
;	3030	
;	3031	%if dbg_ssv2
;     L 3032	%then
;     U 3033			$fao_tt_out('class_s element size = !SL.',
;     U 3034				.descrip_block[ DSC$W_LENGTH ]);
;     U 3035	%FI
;	3036			!+
;	3037			! Assume that the reason for symbolization is

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9-2
; Digital Equipment Corporation
;
;	3038			! because of examine, and believe that the number of
;	3039			! characters to be output is in dbg$gl_asci_len.
;	3040			!
;	3041			! The first number we print out is the
;	3042			! beginning character position (starting from 1).
;	3043			! The second number is the final character position.
;	3044			!-
;	3045			dbg$fao_put( substring, .residue+1, .residue+.dbg$gl_asci_len);
;	3046	
;	3047			! Pass back an indication of how many bytes
;	3048			! there would be left given the symbolization
;	3049			! we came up with.  In this case we know
;	3050			! that we have completely symbolized the value
;	3051			! because 'residue' is how far into the CHARACTER
;	3052			! string we are beginning the display.
;	3053		
;	3054			RETURN(.in_array);
;	3055			END;
;	3056	
;	3057		! Class _A type references.
;	3058	
;	3059		! Point to the sequence of longwords which contain
;	3060		! the number of array elements in each dimension, and
;	3061		! the LB-UB bound blocks which give the origin
;	3062		! for the bound for each dimension.
;	3063	
;	3064		SPAN_BLOCK = DESCRIP_BLOCK[ DSC$L_M1 ];
;	3065		MAX_DIMENSION = .DESCRIP_BLOCK[ DSC$B_DIMCT ] -1;
;	3066		LB_BLOCK = SPAN_BLOCK[ .MAX_DIMENSION +1];
;	3067	
;	3068	
;	3069	%IF DBG_SSV2
;     L 3070	%THEN
;     U 3071		$FAO_TT_OUT('!/array begin=!XL, has=!UL dimensions, elem size=!UL.',
;     U 3072			.descrip_block[dsc$a_pointer],.descrip_block[ dsc$b_dimct ],
;     U 3073			.descrip_block[dsc$w_length]);
;     U 3074	
;     U 3075		! Print out the number of elements in each dimension.
;     U 3076	
;     U 3077		$fao_tt_out('!/num elements in each dim = (!UL',.span_block[0]);
;     U 3078		INCR I FROM 1 TO .MAX_DIMENSION
;     U 3079			DO
;     U 3080			$fao_tt_out(',!UL',.span_block[.I]);
;     U 3081		$fao_tt_out(')!/LB of each dimension = (!UL',.LB_BLOCK[0]);
;     U 3082		INCR I FROM 1 TO .MAX_DIMENSION
;     U 3083			DO
;     U 3084			$fao_tt_out(',!UL',.lb_block[2*.I]);
;     U 3085		$FAO_TT_OUT(')');
;     U 3086	%FI
;	3087		! Initialize a vector which has one element for each
;	3088		! of the dimensions we will symbolize, so that each 
;	3089		! INDEX contains the lower-bound value for that
;	3090		! dimension.
;	3091	
;	3092		INCR I FROM 0 TO .MAX_DIMENSION

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9-3
; Digital Equipment Corporation
;
;	3093			DO
;	3094			INDEX[.I] = .LB_BLOCK[.I*2];
;	3095	
;	3096		! Loop 'backwards' thru each dimension, successively
;	3097		! seeing how many (if any) times the number of
;	3098		! elements needed to 'fill' the current dimension
;	3099		! once can be taken from the remaining 'residue'.
;	3100		! This number is the 0-origin subscript which must
;	3101		! have been given to effect the array reference
;	3102		! we are to symbolize.
;	3103	
;	3104		DECR I FROM .MAX_DIMENSION TO 0
;	3105			DO
;	3106			BEGIN
;	3107			LOCAL
;	3108				DIMENSION_SIZE;
;	3109	
;	3110			! Calculate how many bytes it would take to fill
;	3111			! up one of the current dimension.  This is done by
;	3112			! tallying up how much each lower dimension takes.
;	3113			! Calculate the number of ELEMENTS in the subvector,
;	3114			! and then convert this to bytes.
;	3115	
;	3116			DIMENSION_SIZE = 1;	! Multiplicative identity
;	3117			IF( .I NEQ 0 )
;	3118			THEN
;	3119				INCR J FROM 0 TO .I-1
;	3120				DO
;	3121				DIMENSION_SIZE = .DIMENSION_SIZE * .SPAN_BLOCK[.J];
;	3122	 
;	3123			DIMENSION_SIZE = .DIMENSION_SIZE * .DESCRIP_BLOCK[ DSC$W_LENGTH ];
;	3124	%IF DBG_SSV2
;     L 3125	%THEN
;     U 3126			$FAO_TT_OUT('!/residue = !UL, dim(!UL) size = !UL',
;     U 3127				.residue,.i,.dimension_size);
;     U 3128	%FI
;	3129			! Subsume the whole of one sub-dimension.
;	3130	
;	3131			INDEX[.I] = .INDEX[.I] + .RESIDUE/.DIMENSION_SIZE;
;	3132			RESIDUE = .RESIDUE - (.DIMENSION_SIZE * (.RESIDUE/.DIMENSION_SIZE));
;	3133	
;	3134			! Loop back to consider the next lower dimension.
;	3135			END;
;	3136	
;	3137		! At this point the symbolization is complete 
;	3138		! as far as the array reference is concerned.
;	3139		! We simply have to 'print' it out.
;	3140	
;	3141	%IF DBG_SSV2
;     L 3142	%THEN
;     U 3143		$fao_tt_out('complete array symbolization is:');
;     U 3144		INCR I FROM 0 TO .MAX_DIMENSION
;     U 3145			DO
;     U 3146			$fao_tt_out('!_dimension !SL. is !SL.',.i,.index[.i]);
;     U 3147	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9-4
; Digital Equipment Corporation
;
;     U 3148		$fao_tt_out('residue is !SL., type = !SB.',
;     U 3149			.residue,.descrip_block[ DSC$B_DTYPE ]);
;     U 3150	%FI
;	3151		DBG$FAO_PUT(UPLIT(%ASCIC '('));
;	3152		DBG$OUT_NUM_VAL(.INDEX[0],long_length,0);
;	3153		INCR I FROM 1 TO .MAX_DIMENSION
;	3154			DO
;	3155			BEGIN
;	3156			DBG$FAO_PUT(UPLIT(%ASCIC ','));
;	3157			DBG$OUT_NUM_VAL(.INDEX[.I],long_length,0);
;	3158			END;
;	3159		DBG$FAO_PUT(UPLIT(%ASCIC ')'));
;	3160	
;	3161		! Normally any further residue is handled by an outer
;	3162		! routine.  Since we know this is FORTRAN, and
;	3163		! since CHARACTER sub-string designators are specific
;	3164		! to FORTRAN, we deal with this 'residue' here.
;	3165	
;	3166		IF( .descrip_block[ DSC$B_DTYPE ] EQL DSC$K_DTYPE_T )
;	3167		THEN
;	3168			begin
;	3169			dbg$fao_put( substring, .residue+1, .residue+.dbg$gl_asci_len);
;	3170			residue = 0;
;	3171			END;
;	3172	
;	3173		! Pass back an indication of how many bytes
;	3174		! there would be left given the symbolization
;	3175		! we came up with.
;	3176	
;	3177		RETURN(.IN_ARRAY-.RESIDUE);
;	3178	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      0003C P.AAM:  .ASCII  <9>\(!SL:!SL)\<0><0>				      ;
					      00048 P.AAN:  .ASCII  <1>\(\<0><0>					      ;
					      0004C P.AAO:  .ASCII  <1>\,\<0><0>					      ;
					      00050 P.AAP:  .ASCII  <1>\)\<0><0>					      ;

						    SUBSTRING=		P.AAM


							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0C7C 00301 PUT_BOUNDS:
							    .WORD   Save R2,R3,R4,R5,R6,R10,R11				      ; 2928
		         5A	FCF9   CF  9E 00303 	    MOVAB   DBG$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 00308 	    MOVAB   SUBSTRING, R11					      ;
		         5E	       24  C2 0030F 	    SUBL2   #36, SP						      ;
				  1C   AE  9F 00312 	    PUSHAB  BOUNDS						      ; 2994
		         55	  08   AC  D0 00315 	    MOVL    DESCRIP_BLOCK, R5					      ;
				       55  DD 00319 	    PUSHL   R5							      ;
	      00000000G  EF	       02  FB 0031B 	    CALLS   #2, DBG$GET_BOUNDS					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9-5
; Digital Equipment Corporation
;
		         50	  1C   AE  D0 00322 	    MOVL    BOUNDS, R0						      ; 3003
		         50	  04   AC  D1 00326 	    CMPL    IN_ARRAY, R0					      ;
				       01  1E 0032A 	    BGEQU   1$							      ;
					   04 0032C 	    RET     							      ;
	   53	    04   AC	  04   A5  C3 0032D 1$:     SUBL3   4(R5), IN_ARRAY, RESIDUE				      ; 3010
		         01	  03   A5  91 00333 	    CMPB    3(R5), #1						      ; 3016
				       1B  12 00337 	    BNEQ    3$							      ;
		    20   AE	       53  D1 00339 	    CMPL    RESIDUE, BOUNDS+4					      ; 3024
				       01  19 0033D 	    BLSS    2$							      ;
					   04 0033F 	    RET     							      ;
			    00000000GFF43  9F 00340 2$:     PUSHAB  @DBG$GL_ASCI_LEN[RESIDUE]				      ; 3045
				  01   A3  9F 00347 	    PUSHAB  1(RESIDUE)						      ;
				       5B  DD 0034A 	    PUSHL   R11							      ; 2928
		         6A	       03  FB 0034C 	    CALLS   #3, DBG$FAO_PUT					      ; 3045
		         50	  04   AC  D0 0034F 	    MOVL    IN_ARRAY, R0					      ; 3054
					   04 00353 	    RET     							      ;
	   56	         55	       14  C1 00354 3$:     ADDL3   #20, R5, SPAN_BLOCK					      ; 3064
		         54	  0B   A5  9A 00358 	    MOVZBL  11(R5), MAX_DIMENSION				      ; 3065
				       54  D7 0035C 	    DECL    MAX_DIMENSION					      ;
		         52	  04 A644  DE 0035E 	    MOVAL   4(SPAN_BLOCK)[MAX_DIMENSION], LB_BLOCK		      ; 3066
		         50	       01  CE 00363 	    MNEGL   #1, I						      ; 3092
				       09  11 00366 	    BRB     5$							      ;
	   51	         50	       01  78 00368 4$:     ASHL    #1, I, R1						      ; 3094
		       6E40	     6241  D0 0036C 	    MOVL    (LB_BLOCK)[R1], INDEX[I]				      ;
	   F3	         50	       54  F3 00371 5$:     AOBLEQ  MAX_DIMENSION, I, 4$				      ; 3092
	   50	         54	       01  C1 00375 	    ADDL3   #1, MAX_DIMENSION, I				      ; 3104
				       28  11 00379 	    BRB     10$							      ;
		         51	       01  D0 0037B 6$:     MOVL    #1, DIMENSION_SIZE					      ; 3116
				       50  D5 0037E 	    TSTL    I							      ; 3117
				       0D  13 00380 	    BEQL    9$							      ;
		         52	       01  CE 00382 	    MNEGL   #1, J						      ; 3119
				       04  11 00385 	    BRB     8$							      ;
		         51	     6642  C4 00387 7$:     MULL2   (SPAN_BLOCK)[J], DIMENSION_SIZE			      ; 3121
	   F8	         52	       50  F2 0038B 8$:     AOBLSS  I, J, 7$						      ; 3119
		         52	       65  3C 0038F 9$:     MOVZWL  (R5), R2						      ; 3123
		         51	       52  C4 00392 	    MULL2   R2, DIMENSION_SIZE					      ;
	   52	         53	       51  C7 00395 	    DIVL3   DIMENSION_SIZE, RESIDUE, R2				      ; 3131
		       6E40	       52  C0 00399 	    ADDL2   R2, INDEX[I]					      ;
		         51	       52  C4 0039D 	    MULL2   R2, R1						      ; 3132
		         53	       51  C2 003A0 	    SUBL2   R1, RESIDUE						      ;
		         D5	       50  F4 003A3 10$:    SOBGEQ  I, 6$						      ; 3104
				  0C   AB  9F 003A6 	    PUSHAB  P.AAN						      ; 3151
		         6A	       01  FB 003A9 	    CALLS   #1, DBG$FAO_PUT					      ;
		         7E	       04  7D 003AC 	    MOVQ    #4, -(SP)						      ; 3152
				  08   AE  DD 003AF 	    PUSHL   INDEX						      ;
		  008D   CA	       03  FB 003B2 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
				       52  D4 003B7 	    CLRL    I							      ; 3153
				       12  11 003B9 	    BRB     12$							      ;
				  10   AB  9F 003BB 11$:    PUSHAB  P.AAO						      ; 3156
		         6A	       01  FB 003BE 	    CALLS   #1, DBG$FAO_PUT					      ;
		         7E	       04  7D 003C1 	    MOVQ    #4, -(SP)						      ; 3157
				  08 AE42  DD 003C4 	    PUSHL   INDEX[I]						      ;
		  008D   CA	       03  FB 003C8 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   EA	         52	       54  F3 003CD 12$:    AOBLEQ  MAX_DIMENSION, I, 11$				      ; 3153
				  14   AB  9F 003D1 	    PUSHAB  P.AAP						      ; 3159

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 9-6
; Digital Equipment Corporation
;
		         6A	       01  FB 003D4 	    CALLS   #1, DBG$FAO_PUT					      ;
		         0E	  02   A5  91 003D7 	    CMPB    2(R5), #14						      ; 3166
				       11  12 003DB 	    BNEQ    13$							      ;
			    00000000GFF43  9F 003DD 	    PUSHAB  @DBG$GL_ASCI_LEN[RESIDUE]				      ; 3169
				  01   A3  9F 003E4 	    PUSHAB  1(RESIDUE)						      ;
				       5B  DD 003E7 	    PUSHL   R11							      ; 2928
		         6A	       03  FB 003E9 	    CALLS   #3, DBG$FAO_PUT					      ; 3169
				       53  D4 003EC 	    CLRL    RESIDUE						      ; 3170
	   50	    04   AC	       53  C3 003EE 13$:    SUBL3   RESIDUE, IN_ARRAY, R0				      ; 3177
					   04 003F3 14$:    RET     							      ; 2928

; Routine Size:  243 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 10
; Digital Equipment Corporation
;
;	3179	%IF 0
;     L 3180	%THEN
;     U 3181	GLOBAL ROUTINE dbg$out_typ_num (value_ptr) =
;     U 3182	
;     U 3183	!++
;     U 3184	! Functional description:
;     U 3185	!	This routine looks at the data type associated with a number.
;     U 3186	!	If the type is single or double precision, it outputs the value
;     U 3187	!	as a single or double precision number. Otherwise, it returns
;     U 3188	!	false to its caller, who must output it according to current
;     U 3189	!	mode settings.
;     U 3190	!
;     U 3191	! Formal parameters:
;     U 3192	!	value_ptr	- the address of the value.
;     U 3193	!
;     U 3194	! Implicit inputs:
;     U 3195	!	If the value is double precision, the second longword of the
;     U 3196	!	value is in the address following the address passed. The third
;     U 3197	!	longword from the address passed is the data type.  This layout is
;     U 3198	!	what various routines in PAR (the parser and associated action
;     U 3199	!	routines) construct.
;     U 3200	!
;     U 3201	! Implicit outputs:
;     U 3202	!	The value of the number as an ASCII string is written into
;     U 3203	!	the output buffer if the number was a floating number.
;     U 3204	!
;     U 3205	! Routine value:
;     U 3206	!	true if anything was written into the buffer, otherwise false.
;     U 3207	!
;     U 3208	! Side effects:
;     U 3209	!	eventually the value is printed, however, not by this routine.
;     U 3210	!--
;     U 3211	
;     U 3212	BEGIN
;     U 3213		MAP
;     U 3214			value_ptr	: REF VECTOR;
;     U 3215	
;     U 3216		LITERAL
;     U 3217			value		= 0,
;     U 3218			data_type	= 2;
;     U 3219	
;     U 3220		! For EValuate /ADDRess, the type associated with the
;     U 3221		! number is always integer.  The printing of integer
;     U 3222		! numbers must be done according to the current
;     U 3223		! mode - so we let an outer routine handle this since one
;     U 3224		! has been set up to do so in any case.
;     U 3225	
;     U 3226		IF( .dbg$gb_mod_ptr[ MODE_IMMEDIATE ] )
;     U 3227		THEN
;     U 3228			RETURN( FALSE );
;     U 3229	
;     U 3230		IF .value_ptr [data_type] EQL dsc$k_dtype_f
;     U 3231		THEN
;     U 3232			BEGIN
;     U 3233	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 10-1
; Digital Equipment Corporation
;
;     U 3234			LOCAL
;     U 3235				float_buffer	: VECTOR [float_buf_len, BYTE],
;     U 3236				float_stg_desc	: BLOCK [8, BYTE],
;     U 3237				status;
;     U 3238	
;     U 3239			float_stg_desc [dsc$w_length] = real4_buf_len;
;     U 3240			float_stg_desc [dsc$a_pointer] = float_buffer;
;     U 3241			status = for$cnv_out_g (.value_ptr, float_stg_desc, real4_fra_dig, scale_factor);
;     U 3242			IF .status
;     U 3243			THEN
;     U 3244				BEGIN
;     U 3245				dbg$fao_put (stg_desc_ascii, float_stg_desc);
;     U 3246				RETURN TRUE
;     U 3247				END
;     U 3248			ELSE RETURN FALSE;
;     U 3249			END;
;     U 3250	
;     U 3251		IF .value_ptr [data_type] EQL dsc$k_dtype_d
;     U 3252		THEN
;     U 3253			BEGIN
;     U 3254	
;     U 3255			LOCAL
;     U 3256				float_buffer	: VECTOR [float_buf_len, BYTE],
;     U 3257				float_stg_desc	: BLOCK [8, BYTE],
;     U 3258				status;
;     U 3259	
;     U 3260			float_stg_desc [dsc$w_length] = real8_buf_len;
;     U 3261			float_stg_desc [dsc$a_pointer] = float_buffer;
;     U 3262			status = for$cnv_out_g (.value_ptr, float_stg_desc, real8_fra_dig, scale_factor);
;     U 3263			IF .status
;     U 3264			THEN
;     U 3265				BEGIN
;     U 3266				dbg$fao_put (stg_desc_ascii, float_stg_desc);
;     U 3267				RETURN TRUE
;     U 3268				END
;     U 3269			ELSE RETURN FALSE;
;     U 3270			END;
;     U 3271	END;
;     U 3272	%FI

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11
; Digital Equipment Corporation
;
;	3273	GLOBAL ROUTINE dbg$out_typ_val (value_ptr, type) =
;	3274	!++
;	3275	! Functional description:
;	3276	!	This routine outputs the contents of a memory location in the
;	3277	!	format specified by the type field in a symbol's DST record.
;	3278	!
;	3279	!	If the type field cannot be satisfied, this routine returns
;	3280	!	false, and the caller has the responsibility of getting
;	3281	!	the value output by some other method.
;	3282	!
;	3283	! Formal parameters:
;	3284	!	value_ptr	- the address of the symbol
;	3285	!	type		- The symbol's type.
;	3286	!			  If 0 then use the value to try to deduce the type.
;	3287	!
;	3288	! Implicit inputs:
;	3289	!	the DST record and NT record for the symbol bound to the
;	3290	!	address in value_ptr, if such records exist.
;	3291	!
;	3292	! Implicit outputs:
;	3293	!	the value of the symbol is written into the output buffer.
;	3294	!
;	3295	! Routine value:
;	3296	!	true with success, false with failure.
;	3297	!
;	3298	! Side effects:
;	3299	!	eventually, the value is printed, however, not in this routine.
;	3300	!--
;	3301	
;	3302		BEGIN
;	3303		MAP
;	3304			value_ptr	: REF BLOCK [, BYTE];
;	3305	
;	3306		LOCAL
;	3307			case_index,
;	3308			status,
;	3309			float_buffer	: VECTOR [float_buf_len, BYTE],
;	3310			nt_ptr		: REF nt_record,
;	3311			real_value;
;	3312	
;	3313	%IF dbg_ssv
;     L 3314	%THEN
;     U 3315		$fao_tt_out ('out_typ_val: value is !XL!XL, type= !UL',
;     U 3316		.value_ptr[long_2_logical], .value_ptr[long_logical], .type);
;     U 3317	%FI
;	3318		!+
;	3319		! If there was no type supplied then we must try to find the
;	3320		! symbol's type from scratch.
;	3321		!-
;	3322		nt_ptr = 0;
;	3323		case_index = .type;
;	3324		IF .case_index EQL 0
;	3325		THEN
;	3326		    BEGIN
;	3327		    !+

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-1
; Digital Equipment Corporation
;
;	3328		    ! Find the symbol name that is closest in value to the address
;	3329		    ! whose contents is to be output. If dbg$val_to_sym fails
;	3330		    ! just do numeric output.
;	3331		    ! LOCK the GST before calling val_to_sym because a global
;	3332		    ! answer can not give us the type info we need.
;	3333		    !-
;	3334		    dbg$gl_mc_ptr[ mc_gbl_locked ] = TRUE;
;	3335		    status = dbg$val_to_sym (.value_ptr, nt_ptr, FALSE);
;	3336		    dbg$gl_mc_ptr[ mc_gbl_locked ] = FALSE;
;	3337		
;	3338	%IF dbg_ssv
;     L 3339	%THEN
;     U 3340		    $fao_tt_out('out_typ_val: val_to_sym status = !XL',.status);
;     U 3341	%FI
;	3342		
;	3343		    IF not .STATUS
;	3344		    THEN
;	3345			RETURN FALSE;
;	3346	
;	3347	%IF dbg_ssv
;     L 3348	%THEN
;     U 3349		    $fao_tt_out('out_typ_val: using nt_ptr = !XL',.nt_ptr);
;     U 3350	%FI
;	3351		    !+
;	3352		    ! Now find the precise value of the symbol returned above or
;	3353		    ! passed in.  This is due to val_to_syms willingness to send
;	3354		    ! a close match as well as an exact match. If the match is not
;	3355		    ! exact then use the type field of the value passed in.
;	3356		    !-
;	3357		    IF DBG$SYMBOL_VALU (.nt_ptr, real_value)
;	3358		    THEN
;	3359			IF (.VALUE_PTR EQL .REAL_VALUE)
;	3360			OR (.NT_PTR [NT_IS_BOUNDED] )
;	3361			THEN
;	3362			    case_index = .nt_ptr[nt_type];
;	3363	
;	3364		    END;
;	3365		!+
;	3366		! The symbol from the name table in the RST is bound to the
;	3367		! address whose contents is to be displayed. Display it according
;	3368		! to its particular type.
;	3369		!-
;	3370	%IF DBG_SSV
;     L 3371	%THEN
;     U 3372		$FAO_TT_OUT('out_typ_val: type is !UL.',.case_index);
;     U 3373	%FI
;	3374		CASE .case_index FROM 0				! 0
;	3375				 TO dsc$k_dtype_t		! 14
;	3376		OF
;	3377	
;	3378			SET
;	3379	
;	3380			[ 0 ]:					! No type information
;	3381				RETURN FALSE;
;	3382	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-2
; Digital Equipment Corporation
;
;	3383			[dsc$k_dtype_v]:			! single bit
;	3384				BEGIN
;	3385				dbg$out_num_val (.value_ptr [single_bit], long_length, 0);
;	3386				dbg$gl_next_loc = .value_ptr + 1;
;	3387				dbg$gl_last_val = .value_ptr [single_bit];
;	3388				END;
;	3389	
;	3390	
;	3391			[dsc$k_dtype_bu]:			! 8-bit unsigned quantity
;	3392				BEGIN
;	3393				dbg$out_num_val (.value_ptr [byte_logical], long_length, 0);
;	3394				dbg$gl_next_loc = .value_ptr + 1;
;	3395				dbg$gl_last_val = .value_ptr [byte_logical];
;	3396				END;
;	3397	
;	3398	
;	3399			[dsc$k_dtype_wu]:			! 16-bit unsigned quantity
;	3400				BEGIN
;	3401				dbg$out_num_val (.value_ptr [word_logical], long_length, 0);
;	3402				dbg$gl_next_loc = .value_ptr + 2;
;	3403				dbg$gl_last_val = .value_ptr [word_logical];
;	3404				END;
;	3405	
;	3406	
;	3407			[dsc$k_dtype_lu]:			! 32-bit unsigned quantity
;	3408				BEGIN
;	3409				dbg$out_num_val (.value_ptr [long_logical], long_length, 0);
;	3410				dbg$gl_next_loc = .value_ptr + 4;
;	3411				dbg$gl_last_val = .value_ptr [long_logical];
;	3412				END;
;	3413	
;	3414	
;	3415			[dsc$k_dtype_b]:			! 8-bit signed 2's-complement integer
;	3416				BEGIN
;	3417				dbg$out_num_val (.value_ptr [byte_integer], long_length, 0);
;	3418				dbg$gl_next_loc = .value_ptr + 1;
;	3419				dbg$gl_last_val = .value_ptr [byte_integer];
;	3420				END;
;	3421	
;	3422	
;	3423			[dsc$k_dtype_w]:			! 16-bit signed 2's-complement integer
;	3424				BEGIN
;	3425				dbg$out_num_val (.value_ptr [word_integer], long_length, 0);
;	3426				dbg$gl_next_loc = .value_ptr + 2;
;	3427				dbg$gl_last_val = .value_ptr [word_integer];
;	3428				END;
;	3429	
;	3430	
;	3431			[dsc$k_dtype_l]:
;	3432				BEGIN
;	3433				dbg$out_num_val (.value_ptr [long_integer], long_length, 0);
;	3434				dbg$gl_next_loc = .value_ptr + 4;
;	3435				dbg$gl_last_val = .value_ptr [long_integer];
;	3436				END;
;	3437	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-3
; Digital Equipment Corporation
;
;	3438	
;	3439			[dsc$k_dtype_f]:			! 32-bit floating point
;	3440				BEGIN
;	3441	
;	3442				LOCAL
;	3443					float_stg_desc	: BLOCK [8, BYTE],
;	3444					status;
;	3445	
;	3446				float_stg_desc [dsc$w_length] = real4_buf_len;
;	3447				float_stg_desc [dsc$a_pointer] = float_buffer;
;	3448				status = for$cnv_out_g (.value_ptr, float_stg_desc, real4_fra_dig, scale_factor);
;	3449				IF .status
;	3450				THEN dbg$fao_put (stg_desc_ascii, float_stg_desc)
;	3451				ELSE RETURN FALSE;
;	3452				dbg$gl_next_loc = .value_ptr + 4;
;	3453				dbg$gl_last_val = .value_ptr [long_logical];
;	3454				END;
;	3455	
;	3456	
;	3457			[dsc$k_dtype_d]:			! 64-bit floating point
;	3458				BEGIN
;	3459	
;	3460				LOCAL
;	3461					float_stg_desc	: BLOCK [8, BYTE],
;	3462					status;
;	3463	
;	3464				float_stg_desc [dsc$w_length] = real8_buf_len;
;	3465				float_stg_desc [dsc$a_pointer] = float_buffer;
;	3466				status = for$cnv_out_g (.value_ptr, float_stg_desc, real8_fra_dig, scale_factor);
;	3467				IF .status
;	3468				THEN
;	3469					BEGIN
;	3470					dbg$fao_put (stg_desc_ascii, float_stg_desc);
;	3471					dbg$gl_next_loc = .value_ptr + 8;
;	3472					dbg$gl_last_val = .value_ptr [long_logical];
;	3473					END
;	3474				ELSE RETURN FALSE;
;	3475				END;
;	3476	
;	3477	
;	3478			[dsc$k_dtype_fc]:			! single-precision complex quantity
;	3479				BEGIN
;	3480	
;	3481				LOCAL
;	3482					float_stg_desc	: BLOCK [8, BYTE],
;	3483					status;
;	3484	
;	3485				float_stg_desc [dsc$w_length] = real4_buf_len;
;	3486				float_stg_desc [dsc$a_pointer] = float_buffer;
;	3487				status = for$cnv_out_g (value_ptr [long_logical], float_stg_desc,
;	3488						real4_fra_dig, scale_factor);
;	3489				IF .status
;	3490				THEN
;	3491					BEGIN
;	3492					dbg$fao_put (open_parenth);

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-4
; Digital Equipment Corporation
;
;	3493					dbg$fao_put (stg_desc_ascii, float_stg_desc);
;	3494					dbg$fao_put (comma_space);
;	3495					status = for$cnv_out_g (value_ptr [long_2_logical],
;	3496							float_stg_desc, real4_fra_dig, scale_factor);
;	3497					IF .status
;	3498					THEN dbg$fao_put (stg_desc_ascii, float_stg_desc)
;	3499					ELSE dbg$out_num_val (.value_ptr [long_2_logical], long_length, hex_radix);
;	3500					dbg$fao_put (closed_parenth);
;	3501					dbg$gl_next_loc = .value_ptr + 8;
;	3502					dbg$gl_last_val = .value_ptr [long_2_logical];
;	3503					END
;	3504				ELSE RETURN FALSE;
;	3505				END;
;	3506	
;	3507	
;	3508			[dsc$k_dtype_dc]:			! double-precision complex quantity
;	3509				BEGIN
;	3510	
;	3511				LOCAL
;	3512					float_stg_desc	: BLOCK [8, BYTE],
;	3513					status;
;	3514	
;	3515				float_stg_desc [dsc$w_length] = real8_buf_len;
;	3516				float_stg_desc [dsc$a_pointer] = float_buffer;
;	3517				status = for$cnv_out_g (value_ptr [long_logical], float_stg_desc,
;	3518						real8_fra_dig, scale_factor);
;	3519				IF .status
;	3520				THEN
;	3521					BEGIN
;	3522					dbg$fao_put (open_parenth);
;	3523					dbg$fao_put (stg_desc_ascii, float_stg_desc);
;	3524					dbg$fao_put (comma_space);
;	3525					status = for$cnv_out_g (value_ptr [long_3_logical],
;	3526							float_stg_desc, real8_fra_dig, scale_factor);
;	3527					IF .status
;	3528					THEN dbg$fao_put (stg_desc_ascii, float_stg_desc)
;	3529					ELSE dbg$out_num_val (.value_ptr [long_3_logical], long_length, hex_radix);
;	3530					dbg$fao_put (closed_parenth);
;	3531					dbg$gl_next_loc = .value_ptr + 16;
;	3532					dbg$gl_last_val = .value_ptr [long_3_logical];
;	3533					END
;	3534				ELSE RETURN FALSE;
;	3535				END;
;	3536	
;	3537	
;	3538			[dsc$k_dtype_t]:			! ASCII text string
;	3539				BEGIN
;	3540	
;	3541				LOCAL
;	3542					size;
;	3543	
;	3544				dbg$fao_put (cs_ascii, .dbg$gl_asci_len, value_ptr [long_logical]);
;	3545				dbg$gl_next_loc = .value_ptr + .dbg$gl_asci_len;
;	3546				size = .dbg$gl_asci_len;
;	3547				IF .size GTR %UPVAL

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-5
; Digital Equipment Corporation
;
;	3548				THEN
;	3549				    size = %UPVAL;
;	3550				dbg$gl_last_val = .value_ptr <0, .size*8>;
;	3551				END;
;	3552	
;	3553	
;	3554			[INRANGE, OUTRANGE]:			! anything else
;	3555				RETURN FALSE;
;	3556	
;	3557			TES;
;	3558	
;	3559		RETURN TRUE
;	3560		END;





					 0FFC 003F4 	    .ENTRY  DBG$OUT_TYP_VAL, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 3273
		         54 00000000G  8F  D0 003F6 	    MOVL    #DBG$_RST_BEGIN, R4					      ;
		         55 00000000G  EF  9E 003FD 	    MOVAB   DBG$GL_MC_PTR, R5					      ;
		         56 00000000G  EF  9E 00404 	    MOVAB   DBG$GL_ASCI_LEN, R6					      ;
		         57 00000000G  EF  9E 0040B 	    MOVAB   FOR$CNV_OUT_G, R7					      ;
		         58 00000000G  EF  9E 00412 	    MOVAB   DBG$GL_LAST_VAL, R8					      ;
		         59 00000000G  EF  9E 00419 	    MOVAB   DBG$GL_NEXT_LOC, R9					      ;
		         5A	FBDC   CF  9E 00420 	    MOVAB   DBG$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 00425 	    MOVAB   STG_DESC_ASCII, R11					      ;
		         5E	       2C  C2 0042C 	    SUBL2   #44, SP						      ;
				  04   AE  D4 0042F 	    CLRL    NT_PTR						      ; 3322
		         53	  08   AC  D0 00432 	    MOVL    TYPE, CASE_INDEX					      ; 3323
				       4C  12 00436 	    BNEQ    2$							      ; 3324
	   50	         65	       54  C1 00438 	    ADDL3   R4, DBG$GL_MC_PTR, R0				      ; 3334
		    03   A0	       04  88 0043C 	    BISB2   #4, 3(R0)						      ;
				       7E  D4 00440 	    CLRL    -(SP)						      ; 3335
				  08   AE  9F 00442 	    PUSHAB  NT_PTR						      ;
				  04   AC  DD 00445 	    PUSHL   VALUE_PTR						      ;
	      00000000G  EF	       03  FB 00448 	    CALLS   #3, DBG$VAL_TO_SYM					      ;
		         51	       50  D0 0044F 	    MOVL    R0, STATUS						      ;
	   50	         65	       54  C1 00452 	    ADDL3   R4, DBG$GL_MC_PTR, R0				      ; 3336
		    03   A0	       04  8A 00456 	    BICB2   #4, 3(R0)						      ;
		         49	       51  E9 0045A 	    BLBC    STATUS, 4$						      ; 3343
				       5E  DD 0045D 	    PUSHL   SP							      ; 3357
		         52	  08   AE  D0 0045F 	    MOVL    NT_PTR, R2						      ;
				       52  DD 00463 	    PUSHL   R2							      ;
	      00000000G  EF	       02  FB 00465 	    CALLS   #2, DBG$SYMBOL_VALU					      ;
		         15	       50  E9 0046C 	    BLBC    R0, 2$						      ;
		         6E	  04   AC  D1 0046F 	    CMPL    VALUE_PTR, REAL_VALUE				      ; 3359
				       08  13 00473 	    BEQL    1$							      ;
	   07 00000000G  E2	       07  E1 00475 	    BBC     #7, DBG$_RST_BEGIN+3(R2), 2$			      ; 3360
		         53 00000000G  E2  9A 0047D 1$:     MOVZBL  DBG$_RST_BEGIN+2(R2), CASE_INDEX			      ; 3362
	   0E	         00	       53  CF 00484 2$:     CASEL   CASE_INDEX, #0, #14					      ; 3374
	 003C	       0021	     01FA     00488 3$:     .WORD   30$-3$,-						      ;
	 01FA	       0098	     0053     0048E		    5$-3$,-						      ;
	 0098	       0081	     006A     00494		    6$-3$,-						      ;
	 00CD	       00A5	     01FA     0049A		    7$-3$,-						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-6
; Digital Equipment Corporation
;
	 01D2	       0166	     00FD     004A0		    11$-3$,-						      ;
								    30$-3$,-						      ;
								    8$-3$,-						      ;
								    9$-3$,-						      ;
								    11$-3$,-						      ;
								    30$-3$,-						      ;
								    12$-3$,-						      ;
								    14$-3$,-						      ;
								    20$-3$,-						      ;
								    23$-3$,-						      ;
								    27$-3$						      ;
				     01D9  31 004A6 4$:     BRW     30$							      ; 3555
		         7E	       04  7D 004A9 5$:     MOVQ    #4, -(SP)						      ; 3385
      04   BC	         01	       00  EF 004AC 	    EXTZV   #0, #1, @VALUE_PTR, -(SP)				      ;
				       7E     004B1									      ;
		  008D   CA	       03  FB 004B2 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   69	    04   AC	       01  C1 004B7 	    ADDL3   #1, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3386
      04   BC	         01	       00  EF 004BC 	    EXTZV   #0, #1, @VALUE_PTR, DBG$GL_LAST_VAL			      ; 3387
				       68     004C1									      ;
				       5A  11 004C2 	    BRB     10$							      ; 3374
		         7E	       04  7D 004C4 6$:     MOVQ    #4, -(SP)						      ; 3393
		         7E	  04   BC  9A 004C7 	    MOVZBL  @VALUE_PTR, -(SP)					      ;
		  008D   CA	       03  FB 004CB 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   69	    04   AC	       01  C1 004D0 	    ADDL3   #1, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3394
		         68	  04   BC  9A 004D5 	    MOVZBL  @VALUE_PTR, DBG$GL_LAST_VAL				      ; 3395
				       43  11 004D9 	    BRB     10$							      ; 3374
		         7E	       04  7D 004DB 7$:     MOVQ    #4, -(SP)						      ; 3401
		         7E	  04   BC  3C 004DE 	    MOVZWL  @VALUE_PTR, -(SP)					      ;
		  008D   CA	       03  FB 004E2 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   69	    04   AC	       02  C1 004E7 	    ADDL3   #2, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3402
		         68	  04   BC  3C 004EC 	    MOVZWL  @VALUE_PTR, DBG$GL_LAST_VAL				      ; 3403
				       2C  11 004F0 	    BRB     10$							      ; 3374
		         7E	       04  7D 004F2 8$:     MOVQ    #4, -(SP)						      ; 3417
		         7E	  04   BC  98 004F5 	    CVTBL   @VALUE_PTR, -(SP)					      ;
		  008D   CA	       03  FB 004F9 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   69	    04   AC	       01  C1 004FE 	    ADDL3   #1, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3418
		         68	  04   BC  98 00503 	    CVTBL   @VALUE_PTR, DBG$GL_LAST_VAL				      ; 3419
				       79  11 00507 	    BRB     19$							      ; 3374
		         7E	       04  7D 00509 9$:     MOVQ    #4, -(SP)						      ; 3425
		         7E	  04   BC  32 0050C 	    CVTWL   @VALUE_PTR, -(SP)					      ;
		  008D   CA	       03  FB 00510 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
	   69	    04   AC	       02  C1 00515 	    ADDL3   #2, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3426
		         68	  04   BC  32 0051A 	    CVTWL   @VALUE_PTR, DBG$GL_LAST_VAL				      ; 3427
				       62  11 0051E 10$:    BRB     19$							      ; 3374
		         7E	       04  7D 00520 11$:    MOVQ    #4, -(SP)						      ; 3433
				  04   BC  DD 00523 	    PUSHL   @VALUE_PTR						      ;
		  008D   CA	       03  FB 00526 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
				       21  11 0052B 	    BRB     13$							      ; 3434
		    08   AE	       0F  B0 0052D 12$:    MOVW    #15, FLOAT_STG_DESC					      ; 3446
		    0C   AE	  10   AE  9E 00531 	    MOVAB   FLOAT_BUFFER, FLOAT_STG_DESC+4			      ; 3447
				       01  DD 00536 	    PUSHL   #1							      ; 3448
				       07  DD 00538 	    PUSHL   #7							      ;
				  10   AE  9F 0053A 	    PUSHAB  FLOAT_STG_DESC					      ;
				  04   AC  DD 0053D 	    PUSHL   VALUE_PTR						      ;
		         67	       04  FB 00540 	    CALLS   #4, FOR$CNV_OUT_G					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-7
; Digital Equipment Corporation
;
		         25	       50  E9 00543 	    BLBC    STATUS, 15$						      ; 3449
				  08   AE  9F 00546 	    PUSHAB  FLOAT_STG_DESC					      ; 3450
				       5B  DD 00549 	    PUSHL   R11							      ; 3273
		         6A	       02  FB 0054B 	    CALLS   #2, DBG$FAO_PUT					      ; 3450
	   69	    04   AC	       04  C1 0054E 13$:    ADDL3   #4, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3452
				       29  11 00553 	    BRB     18$							      ; 3453
		    08   AE	       19  B0 00555 14$:    MOVW    #25, FLOAT_STG_DESC					      ; 3464
		    0C   AE	  10   AE  9E 00559 	    MOVAB   FLOAT_BUFFER, FLOAT_STG_DESC+4			      ; 3465
				       01  DD 0055E 	    PUSHL   #1							      ; 3466
				       10  DD 00560 	    PUSHL   #16							      ;
				  10   AE  9F 00562 	    PUSHAB  FLOAT_STG_DESC					      ;
				  04   AC  DD 00565 	    PUSHL   VALUE_PTR						      ;
		         67	       04  FB 00568 	    CALLS   #4, FOR$CNV_OUT_G					      ;
		         03	       50  E8 0056B 15$:    BLBS    STATUS, 17$						      ; 3467
				     0111  31 0056E 16$:    BRW     30$							      ;
				  08   AE  9F 00571 17$:    PUSHAB  FLOAT_STG_DESC					      ; 3470
				       5B  DD 00574 	    PUSHL   R11							      ; 3273
		         6A	       02  FB 00576 	    CALLS   #2, DBG$FAO_PUT					      ; 3470
	   69	    04   AC	       08  C1 00579 	    ADDL3   #8, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3471
		         68	  04   BC  D0 0057E 18$:    MOVL    @VALUE_PTR, DBG$GL_LAST_VAL				      ; 3472
				     00F9  31 00582 19$:    BRW     29$							      ; 3467
		    08   AE	       0F  B0 00585 20$:    MOVW    #15, FLOAT_STG_DESC					      ; 3485
		    0C   AE	  10   AE  9E 00589 	    MOVAB   FLOAT_BUFFER, FLOAT_STG_DESC+4			      ; 3486
				       01  DD 0058E 	    PUSHL   #1							      ; 3487
				       07  DD 00590 	    PUSHL   #7							      ;
				  10   AE  9F 00592 	    PUSHAB  FLOAT_STG_DESC					      ;
				  04   AC  DD 00595 	    PUSHL   VALUE_PTR						      ;
		         67	       04  FB 00598 	    CALLS   #4, FOR$CNV_OUT_G					      ;
		         52	       50  D0 0059B 	    MOVL    R0, STATUS						      ;
		         CD	       52  E9 0059E 	    BLBC    STATUS, 16$						      ; 3489
				  08   AB  9F 005A1 	    PUSHAB  OPEN_PARENTH					      ; 3273
		         6A	       01  FB 005A4 	    CALLS   #1, DBG$FAO_PUT					      ; 3492
				  08   AE  9F 005A7 	    PUSHAB  FLOAT_STG_DESC					      ; 3493
				       5B  DD 005AA 	    PUSHL   R11							      ; 3273
		         6A	       02  FB 005AC 	    CALLS   #2, DBG$FAO_PUT					      ; 3493
				  04   AB  9F 005AF 	    PUSHAB  COMMA_SPACE						      ; 3273
		         6A	       01  FB 005B2 	    CALLS   #1, DBG$FAO_PUT					      ; 3494
				       01  DD 005B5 	    PUSHL   #1							      ; 3495
				       07  DD 005B7 	    PUSHL   #7							      ;
				  10   AE  9F 005B9 	    PUSHAB  FLOAT_STG_DESC					      ;
	   53	    04   AC	       04  C1 005BC 	    ADDL3   #4, VALUE_PTR, R3					      ;
				       53  DD 005C1 	    PUSHL   R3							      ;
		         67	       04  FB 005C3 	    CALLS   #4, FOR$CNV_OUT_G					      ;
		         52	       50  D0 005C6 	    MOVL    R0, STATUS						      ;
		         0A	       52  E9 005C9 	    BLBC    STATUS, 21$						      ; 3497
				  08   AE  9F 005CC 	    PUSHAB  FLOAT_STG_DESC					      ; 3498
				       5B  DD 005CF 	    PUSHL   R11							      ; 3273
		         6A	       02  FB 005D1 	    CALLS   #2, DBG$FAO_PUT					      ; 3498
				       0B  11 005D4 	    BRB     22$							      ; 3497
				       10  DD 005D6 21$:    PUSHL   #16							      ; 3499
				       04  DD 005D8 	    PUSHL   #4							      ;
				       63  DD 005DA 	    PUSHL   (R3)						      ;
		  008D   CA	       03  FB 005DC 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
				  0C   AB  9F 005E1 22$:    PUSHAB  CLOSED_PARENTH					      ; 3273
		         6A	       01  FB 005E4 	    CALLS   #1, DBG$FAO_PUT					      ; 3500

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-8
; Digital Equipment Corporation
;
	   69	    04   AC	       08  C1 005E7 	    ADDL3   #8, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3501
				       67  11 005EC 	    BRB     26$							      ; 3502
		    08   AE	       19  B0 005EE 23$:    MOVW    #25, FLOAT_STG_DESC					      ; 3515
		    0C   AE	  10   AE  9E 005F2 	    MOVAB   FLOAT_BUFFER, FLOAT_STG_DESC+4			      ; 3516
				       01  DD 005F7 	    PUSHL   #1							      ; 3517
				       10  DD 005F9 	    PUSHL   #16							      ;
				  10   AE  9F 005FB 	    PUSHAB  FLOAT_STG_DESC					      ;
				  04   AC  DD 005FE 	    PUSHL   VALUE_PTR						      ;
		         67	       04  FB 00601 	    CALLS   #4, FOR$CNV_OUT_G					      ;
		         52	       50  D0 00604 	    MOVL    R0, STATUS						      ;
		         78	       52  E9 00607 	    BLBC    STATUS, 30$						      ; 3519
				  08   AB  9F 0060A 	    PUSHAB  OPEN_PARENTH					      ; 3273
		         6A	       01  FB 0060D 	    CALLS   #1, DBG$FAO_PUT					      ; 3522
				  08   AE  9F 00610 	    PUSHAB  FLOAT_STG_DESC					      ; 3523
				       5B  DD 00613 	    PUSHL   R11							      ; 3273
		         6A	       02  FB 00615 	    CALLS   #2, DBG$FAO_PUT					      ; 3523
				  04   AB  9F 00618 	    PUSHAB  COMMA_SPACE						      ; 3273
		         6A	       01  FB 0061B 	    CALLS   #1, DBG$FAO_PUT					      ; 3524
				       01  DD 0061E 	    PUSHL   #1							      ; 3525
				       10  DD 00620 	    PUSHL   #16							      ;
				  10   AE  9F 00622 	    PUSHAB  FLOAT_STG_DESC					      ;
	   53	    04   AC	       08  C1 00625 	    ADDL3   #8, VALUE_PTR, R3					      ;
				       53  DD 0062A 	    PUSHL   R3							      ;
		         67	       04  FB 0062C 	    CALLS   #4, FOR$CNV_OUT_G					      ;
		         52	       50  D0 0062F 	    MOVL    R0, STATUS						      ;
		         0A	       52  E9 00632 	    BLBC    STATUS, 24$						      ; 3527
				  08   AE  9F 00635 	    PUSHAB  FLOAT_STG_DESC					      ; 3528
				       5B  DD 00638 	    PUSHL   R11							      ; 3273
		         6A	       02  FB 0063A 	    CALLS   #2, DBG$FAO_PUT					      ; 3528
				       0B  11 0063D 	    BRB     25$							      ; 3527
				       10  DD 0063F 24$:    PUSHL   #16							      ; 3529
				       04  DD 00641 	    PUSHL   #4							      ;
				       63  DD 00643 	    PUSHL   (R3)						      ;
		  008D   CA	       03  FB 00645 	    CALLS   #3, DBG$OUT_NUM_VAL					      ;
				  0C   AB  9F 0064A 25$:    PUSHAB  CLOSED_PARENTH					      ; 3273
		         6A	       01  FB 0064D 	    CALLS   #1, DBG$FAO_PUT					      ; 3530
	   69	    04   AC	       10  C1 00650 	    ADDL3   #16, VALUE_PTR, DBG$GL_NEXT_LOC			      ; 3531
		         68	       63  D0 00655 26$:    MOVL    (R3), DBG$GL_LAST_VAL				      ; 3532
				       24  11 00658 	    BRB     29$							      ; 3519
				  04   AC  DD 0065A 27$:    PUSHL   VALUE_PTR						      ; 3544
				       66  DD 0065D 	    PUSHL   DBG$GL_ASCI_LEN					      ;
				  10   AB  9F 0065F 	    PUSHAB  CS_ASCII						      ; 3273
		         6A	       03  FB 00662 	    CALLS   #3, DBG$FAO_PUT					      ; 3544
	   69	    04   AC	       66  C1 00665 	    ADDL3   DBG$GL_ASCI_LEN, VALUE_PTR, DBG$GL_NEXT_LOC		      ; 3545
		         50	       66  D0 0066A 	    MOVL    DBG$GL_ASCI_LEN, SIZE				      ; 3546
		         04	       50  D1 0066D 	    CMPL    SIZE, #4						      ; 3547
				       03  15 00670 	    BLEQ    28$							      ;
		         50	       04  D0 00672 	    MOVL    #4, SIZE						      ; 3549
		         50	       08  C4 00675 28$:    MULL2   #8, R0						      ; 3550
      04   AC	         50	       00  EF 00678 	    EXTZV   #0, R0, VALUE_PTR, DBG$GL_LAST_VAL			      ;
				       68     0067D									      ;
		         50	       01  D0 0067E 29$:    MOVL    #1, R0						      ; 3559
					   04 00681 	    RET     							      ;
				       50  D4 00682 30$:    CLRL    R0							      ; 3273
					   04 00684 	    RET     							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 11-9
; Digital Equipment Corporation
;

; Routine Size:  657 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 12
; Digital Equipment Corporation
;
;	3561	GLOBAL ROUTINE DBG$READ_ACCESS( ADDR, NUM_BYTES ) =
;	3562	
;	3563	!++
;	3564	! Functional Description:
;	3565	!	Check that we have READ access for the number
;	3566	!	of bytes indicated, starting at the given address.
;	3567	!
;	3568	! Calling Sequence:
;	3569	!	DBG$READ_ACCESS ()
;	3570	!
;	3571	! Inputs:
;	3572	!	ADDR		-Byte address where desired data begins.
;	3573	!	NUM_BYTES	-Number of bytes which we want to access.
;	3574	!
;	3575	! Implicit Inputs:
;	3576	!	The PROBER instruction insists on using PSL <prev>, whether
;	3577	!	we want it to or not.  Until/unless DEBUG is changed to be a
;	3578	!	multi-mode tool, we will be OK as we are now.  Then, however,
;	3579	!	we will have to put in substantially more code here to ensure
;	3580	!	that current and previous mode are the same.
;	3581	!
;	3582	! Outputs:
;	3583	!	None.
;	3584	!
;	3585	! Implicit Outputs:
;	3586	!	None.
;	3587	!
;	3588	! Routine Value:
;	3589	!	TRUE - if access will be granted,
;	3590	!	FALSE, otherwise.
;	3591	!
;	3592	! Side Effects:
;	3593	!	None.
;	3594	!
;	3595	!--
;	3596	
;	3597		BEGIN
;	3598		BUILTIN
;	3599			PROBER;	! Check READ accessability.
;	3600	
;	3601		! Note that we must pass PROBER a zero-extended WORD 
;	3602		! address for the LENGTH, and a BYTE address containing
;	3603		! the MODE field for the instruction.
;	3604		! Later, this byte field should be built by extracting
;	3605		! the proper 3 bits from the PSL.
;	3606	
;	3607		IF( PROBER( %REF(0), NUM_BYTES, .ADDR ) )
;	3608		THEN
;	3609			RETURN(TRUE)
;	3610		ELSE
;	3611			! Produce an error message and return a bad status.
;	3612	
;	3613			SIGNAL( dbg$_noaccessr, 1, .addr );
;	3614			! no return
;	3615		END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 12-1
; Digital Equipment Corporation
;





					 0000 00685 	    .ENTRY  DBG$READ_ACCESS, Save nothing			      ; 3561
      04   BC	    08   AC	       00  0C 00687 	    PROBER  #0, NUM_BYTES, @ADDR				      ; 3607
				       04  13 0068D 	    BEQL    1$							      ;
		         50	       01  D0 0068F 	    MOVL    #1, R0						      ; 3609
					   04 00692 	    RET     							      ;
				  04   AC  DD 00693 1$:     PUSHL   ADDR						      ; 3613
				       01  DD 00696 	    PUSHL   #1							      ;
			    000282B8   8F  DD 00698 	    PUSHL   #164536						      ;
	      00000000G  00	       03  FB 0069E 	    CALLS   #3, LIB$SIGNAL					      ;
				       50  D4 006A5 	    CLRL    R0							      ; 3561
					   04 006A7 	    RET     							      ;

; Routine Size:  35 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 13
; Digital Equipment Corporation
;
;	3616	GLOBAL ROUTINE DBG$SHOW_MODULE : NOVALUE =
;	3617	
;	3618	!++
;	3619	! FUNCTIONAL DESCRIPTION:
;	3620	!
;	3621	!	Show which modules from the MC are in the RST.
;	3622	!
;	3623	! FORMAL PARAMETERS:
;	3624	!
;	3625	!	NONE.
;	3626	!
;	3627	! IMPLICIT INPUTS:
;	3628	!
;	3629	!	dbg$gl_mc_ptr	-is assumed to point to the beginning
;	3630	!			 of the MC.
;	3631	!
;	3632	! IMPLICIT OUTPUTS:
;	3633	!
;	3634	!	Numeric output is always in decimal.
;	3635	!
;	3636	! ROUTINE VALUE:
;	3637	! COMPLETION CODES:
;	3638	!
;	3639	!	NOVALUE.
;	3640	!
;	3641	! SIDE EFFECTS:
;	3642	!
;	3643	!	A summary of the current modules which the RST knows
;	3644	!	about is written to DBG$OUTPUT.
;	3645	!
;	3646	!--
;	3647	
;	3648		BEGIN
;	3649		LOCAL
;	3650			lang_change,		! Flag => all languages are the same.
;	3651			lang_name,		! Language encoding for each module.
;	3652	
;	3653						! Buffer to build report in.
;	3654			output_buffer : VECTOR[ TTY_OUT_WIDTH, BYTE ],
;	3655	
;	3656			NUM_MC_ENTRIES,		! How many entries there are in the MC.
;	3657	
;	3658			MC_PTR : REF MC_RECORD;	! Pointer to current MC record.
;	3659	
;	3660		! Set up to do standard DEBUG I/O.
;	3661	
;	3662		dbg$cp_out_str = output_buffer +1;
;	3663		dbg$gl_buf_siz = 0;
;	3664	
;	3665		! Initialize the pointer that we use to
;	3666		! 'chain' thru the module chain.
;	3667	
;	3668		IF( (MC_PTR = .dbg$gl_mc_ptr) EQL 0 )
;	3669		THEN
;	3670			BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 13-1
; Digital Equipment Corporation
;
;	3671			SIGNAL(DBG$_NOLOCALS);
;	3672			RETURN;
;	3673			END;
;	3674	
;	3675		! Just the existence of the MC doesn't mean that
;	3676		! we have anything to report on here - there may
;	3677		! only be the 1 MC record used to 'hang' globals
;	3678		! off.  If this is the case, produce a message
;	3679		! and get out.
;	3680	
;	3681		if( .dbg$GL_MC_PTR[ MC_NEXT ] eql 0 )
;	3682		THEN
;	3683			BEGIN
;	3684			SIGNAL(DBG$_NOLOCALS);
;	3685			RETURN;
;	3686			END;
;	3687	
;	3688		! See if the language which all modules are written
;	3689		! happens to be the same.
;	3690	
;	3691		lang_change = FALSE;
;	3692	
;	3693		IF( (MC_PTR = .MC_PTR[ MC_NEXT ]) NEQ 0 )
;	3694		THEN
;	3695			BEGIN
;	3696	
;	3697			LANG_NAME = .MC_PTR[ MC_LANGUAGE ];
;	3698	
;	3699			! Loop thru the entire MC to see if the language changes.
;	3700	
;	3701			WHILE( (MC_PTR = .MC_PTR[ MC_NEXT ]) NEQ 0 )
;	3702				DO
;	3703				BEGIN
;	3704				IF( .LANG_NAME NEQ .MC_PTR[ MC_LANGUAGE ] )
;	3705				THEN
;	3706					BEGIN
;	3707					LANG_CHANGE = TRUE;
;	3708					EXITLOOP;
;	3709					END;
;	3710				END;
;	3711	
;	3712			! Restore MC_PTR to what it would be if this
;	3713			! loop had not been entered.
;	3714	
;	3715			mc_ptr = .dbg$gl_mc_ptr;
;	3716			end;
;	3717	
;	3718		! Print out the title, and then loop thru the
;	3719		! module chain simply giving the relevant
;	3720		! information for each module which we know about.
;	3721	
;	3722		NUM_MC_ENTRIES = 0;
;	3723	
;	3724		! The format is 'longer' or 'shorter' depending on
;	3725		! the setting of a conditional.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 13-2
; Digital Equipment Corporation
;
;	3726	
;	3727	%IF dbg_ssv1
;     L 3728	%THEN
;     U 3729		! The long version:
;     U 3730	
;     U 3731		dbg$fao_put( UPLIT( %ASCIC
;     U 3732			'module name     symbols    size     language   NTs       LVTs      SATs!/'));
;     U 3733	%ELSE
;	3734		! The short version:
;	3735	
;	3736		dbg$fao_put( UPLIT( %ASCIC 'module name     symbols   '));
;	3737		IF( .LANG_CHANGE )
;	3738		THEN
;	3739			DBG$FAO_PUT( UPLIT( %ASCIC 'language  ' ));
;	3740		dbg$fao_put( uplit( %ascic ' size!/' ));
;	3741	%FI
;	3742		DBG$OUT_PUT(output_buffer);
;	3743	
;	3744		! Don't print out the 'fake' MC record which we 
;	3745		! keep around to 'hang' globals off.
;	3746	
;	3747		WHILE( (MC_PTR = .MC_PTR[ MC_NEXT ]) NEQ 0 )
;	3748			DO
;	3749			BEGIN
;	3750	
;	3751			! Print out the standard information - name and 
;	3752			! whether or not it has been initialized into the RST.
;	3753	
;	3754			NUM_MC_ENTRIES = .NUM_MC_ENTRIES +1;
;	3755			dbg$cp_out_str = output_buffer +1;
;	3756			dbg$gl_buf_siz = 0;
;	3757			dbg$fao_put( UPLIT( %ASCIC '!15AC !3AC       ' ),
;	3758				MC_PTR[ MC_NAME_CS ],
;	3759				(IF( .MC_PTR[ MC_IN_RST ] )
;	3760				THEN
;	3761					UPLIT( %ASCIC 'yes' )
;	3762				ELSE
;	3763					UPLIT( %ASCIC 'no' )
;	3764				) );
;	3765	%if not dbg_ssv1
;     L 3766	%then
;	3767			! Print out each module's language name if they are
;	3768			! not all the same.
;	3769	
;	3770			IF( .LANG_CHANGE )
;	3771			THEN
;	3772				DBG$FAO_PUT( UPLIT( %ASCIC '!10AC' ),DBG$LANGUAGE(.MC_PTR[ MC_LANGUAGE ]));
;	3773	%FI
;	3774	
;	3775			! Output the size, in bytes, which would be needed
;	3776			! in the RST if this module is to be added.
;	3777	
;	3778			dbg$fao_put(UPLIT(%ASCIC '!5SL'),dbg$module_size(.mc_ptr));
;	3779	
;	3780	%IF dbg_ssv1

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 13-3
; Digital Equipment Corporation
;
;     L 3781	%THEN
;     U 3782			! Print out the language the module is written in,
;     U 3783			! and other MC info.
;     U 3784	
;     U 3785			dbg$fao_put( UPLIT( %ASCIC '     !XL   ' ),.MC_PTR[ MC_LANGUAGE ]);
;     U 3786			DBG$OUT_NUM_VAL( .MC_PTR[ MC_NAMES ], LONG_LENGTH, NO_OVERRIDE );
;     U 3787			dbg$fao_put( UPLIT( %ASCIC '  '));
;     U 3788			DBG$OUT_NUM_VAL( .MC_PTR[ MC_LITERALS ], LONG_LENGTH, NO_OVERRIDE );
;     U 3789			dbg$fao_put( UPLIT( %ASCIC '  '));
;     U 3790			DBG$OUT_NUM_VAL( .MC_PTR[ MC_STATICS ], LONG_LENGTH, NO_OVERRIDE );
;     U 3791	%FI
;	3792	
;	3793			! Finally output the buffer.
;	3794	
;	3795			DBG$OUT_PUT(output_buffer);
;	3796			END;
;	3797	
;	3798		! Give final summary information.
;	3799	
;	3800		dbg$cp_out_str = output_buffer +1;
;	3801		dbg$gl_buf_siz = 0;
;	3802		dbg$fao_put( UPLIT( %ASCIC '!/total '));
;	3803		if( (not .lang_change) AND .num_mc_entries NEQ 0 )
;	3804		then
;	3805			dbg$fao_put( uplit( %ascic '!AC '), dbg$language(.lang_name));
;	3806		dbg$fao_put( uplit( %ascic 'modules: !SL.'),.num_mc_entries);
;	3807		dbg$fao_put( UPLIT( %ASCIC '!/remaining size: !SL.'),dbg$report_free());
;	3808		DBG$OUT_PUT(output_buffer);
;	3809	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00054 P.AAQ:  .ASCII  <26>\module name     symbols   \<0>			      ;
					      00070 P.AAR:  .ASCII  <10>\language  \<0>					      ;
					      0007C P.AAS:  .ASCII  <7>\ size!/\					      ;
					      00084 P.AAT:  .ASCII  <17>\!15AC !3AC       \<0><0>			      ;
					      00098 P.AAU:  .ASCII  <3>\yes\						      ;
					      0009C P.AAV:  .ASCII  <2>\no\<0>						      ;
					      000A0 P.AAW:  .ASCII  <5>\!10AC\<0><0>					      ;
					      000A8 P.AAX:  .ASCII  <4>\!5SL\<0><0><0>					      ;
					      000B0 P.AAY:  .ASCII  <8>\!/total \<0><0><0>				      ;
					      000BC P.AAZ:  .ASCII  <4>\!AC \<0><0><0>					      ;
					      000C4 P.ABA:  .ASCII  <13>\modules: !SL.\<0><0>				      ;
					      000D4 P.ABB:  .ASCII  <22>\!/remaining size: !SL.\<0>			      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0FFC 006A8 	    .ENTRY  DBG$SHOW_MODULE, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 3616
		         57 00000000G  EF  9E 006AA 	    MOVAB   DBG$GL_MC_PTR, R7					      ;
		         58 00000000G  EF  9E 006B1 	    MOVAB   DBG$GL_BUF_SIZ, R8					      ;
		         59 00000000G  8F  D0 006B8 	    MOVL    #DBG$_RST_BEGIN, R9					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 13-4
; Digital Equipment Corporation
;
		         5A	F93D   CF  9E 006BF 	    MOVAB   DBG$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 006C4 	    MOVAB   P.AAQ, R11						      ;
		         5E	FF7C   CE  9E 006CB 	    MOVAB   -132(SP), SP					      ;
	      00000000G  EF	  01   AE  9E 006D0 	    MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 3662
				       68  D4 006D8 	    CLRL    DBG$GL_BUF_SIZ					      ; 3663
		         53	       67  D0 006DA 	    MOVL    DBG$GL_MC_PTR, MC_PTR				      ; 3668
				       08  13 006DD 	    BEQL    1$							      ;
	   50	         67	       59  C1 006DF 	    ADDL3   R9, DBG$GL_MC_PTR, R0				      ; 3681
				       60  B5 006E3 	    TSTW    (R0)						      ;
				       0E  12 006E5 	    BNEQ    2$							      ;
			    0002806B   8F  DD 006E7 1$:     PUSHL   #163947						      ; 3684
	      00000000G  00	       01  FB 006ED 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 006F4 	    RET     							      ; 3685
				       55  D4 006F5 2$:     CLRL    LANG_CHANGE						      ; 3691
		         53 00000000G  E3  3C 006F7 	    MOVZWL  DBG$_RST_BEGIN(MC_PTR), MC_PTR			      ; 3693
				       24  13 006FE 	    BEQL    5$							      ;
00000000G  E3	         03	       03  EF 00700 	    EXTZV   #3, #3, DBG$_RST_BEGIN+3(MC_PTR), LANG_NAME		      ; 3697
				       56     00708									      ;
	   50	         53	       59  C1 00709 	    ADDL3   R9, MC_PTR, R0					      ; 3701
		         53	       60  3C 0070D 3$:     MOVZWL  (R0), MC_PTR					      ;
				       0F  13 00710 	    BEQL    4$							      ;
	   50	         53	       59  C1 00712 	    ADDL3   R9, MC_PTR, R0					      ; 3704
      03   A0	         03	       03  ED 00716 	    CMPZV   #3, #3, 3(R0), LANG_NAME				      ;
				       56     0071B									      ;
				       EF  13 0071C 	    BEQL    3$							      ;
		         55	       01  D0 0071E 	    MOVL    #1, LANG_CHANGE					      ; 3707
		         53	       67  D0 00721 4$:     MOVL    DBG$GL_MC_PTR, MC_PTR				      ; 3715
				       54  D4 00724 5$:     CLRL    NUM_MC_ENTRIES					      ; 3722
				       5B  DD 00726 	    PUSHL   R11							      ; 3736
		         6A	       01  FB 00728 	    CALLS   #1, DBG$FAO_PUT					      ;
		         06	       55  E9 0072B 	    BLBC    LANG_CHANGE, 6$					      ; 3737
				  1C   AB  9F 0072E 	    PUSHAB  P.AAR						      ; 3739
		         6A	       01  FB 00731 	    CALLS   #1, DBG$FAO_PUT					      ;
				  28   AB  9F 00734 6$:     PUSHAB  P.AAS						      ; 3740
		         6A	       01  FB 00737 	    CALLS   #1, DBG$FAO_PUT					      ;
				       5E  DD 0073A 	    PUSHL   SP							      ; 3742
		  0119   CA	       01  FB 0073C 	    CALLS   #1, DBG$OUT_PUT					      ;
	   52	         53	       59  C1 00741 	    ADDL3   R9, MC_PTR, R2					      ; 3747
		         53	       62  3C 00745 7$:     MOVZWL  (R2), MC_PTR					      ;
				       59  13 00748 	    BEQL    11$							      ;
				       54  D6 0074A 	    INCL    NUM_MC_ENTRIES					      ; 3754
	      00000000G  EF	  01   AE  9E 0074C 	    MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 3755
				       68  D4 00754 	    CLRL    DBG$GL_BUF_SIZ					      ; 3756
	   52	         53	       59  C1 00756 	    ADDL3   R9, MC_PTR, R2					      ; 3759
	   06	    03   A2	       01  E1 0075A 	    BBC     #1, 3(R2), 8$					      ;
		         50	  44   AB  9E 0075F 	    MOVAB   P.AAU, R0						      ; 3761
				       04  11 00763 	    BRB     9$							      ; 3759
		         50	  48   AB  9E 00765 8$:     MOVAB   P.AAV, R0						      ; 3763
				       50  DD 00769 9$:     PUSHL   R0							      ; 3759
				  0C   A2  9F 0076B 	    PUSHAB  12(R2)						      ; 3758
				  30   AB  9F 0076E 	    PUSHAB  P.AAT						      ; 3757
		         6A	       03  FB 00771 	    CALLS   #3, DBG$FAO_PUT					      ;
		         15	       55  E9 00774 	    BLBC    LANG_CHANGE, 10$					      ; 3770
      03   A2	         03	       03  EF 00777 	    EXTZV   #3, #3, 3(R2), -(SP)				      ; 3772
				       7E     0077C									      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 13-5
; Digital Equipment Corporation
;
	      00000000G  EF	       01  FB 0077D 	    CALLS   #1, DBG$LANGUAGE					      ;
				       50  DD 00784 	    PUSHL   R0							      ;
				  4C   AB  9F 00786 	    PUSHAB  P.AAW						      ;
		         6A	       02  FB 00789 	    CALLS   #2, DBG$FAO_PUT					      ;
				       53  DD 0078C 10$:    PUSHL   MC_PTR						      ; 3778
		    4B   AA	       01  FB 0078E 	    CALLS   #1, DBG$MODULE_SIZE					      ;
				       50  DD 00792 	    PUSHL   R0							      ;
				  54   AB  9F 00794 	    PUSHAB  P.AAX						      ;
		         6A	       02  FB 00797 	    CALLS   #2, DBG$FAO_PUT					      ;
				       5E  DD 0079A 	    PUSHL   SP							      ; 3795
		  0119   CA	       01  FB 0079C 	    CALLS   #1, DBG$OUT_PUT					      ;
				       A2  11 007A1 	    BRB     7$							      ; 3747
	      00000000G  EF	  01   AE  9E 007A3 11$:    MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 3800
				       68  D4 007AB 	    CLRL    DBG$GL_BUF_SIZ					      ; 3801
				  5C   AB  9F 007AD 	    PUSHAB  P.AAY						      ; 3802
		         6A	       01  FB 007B0 	    CALLS   #1, DBG$FAO_PUT					      ;
		         15	       55  E8 007B3 	    BLBS    LANG_CHANGE, 12$					      ; 3803
				       54  D5 007B6 	    TSTL    NUM_MC_ENTRIES					      ;
				       11  13 007B8 	    BEQL    12$							      ;
				       56  DD 007BA 	    PUSHL   LANG_NAME						      ; 3805
	      00000000G  EF	       01  FB 007BC 	    CALLS   #1, DBG$LANGUAGE					      ;
				       50  DD 007C3 	    PUSHL   R0							      ;
				  68   AB  9F 007C5 	    PUSHAB  P.AAZ						      ;
		         6A	       02  FB 007C8 	    CALLS   #2, DBG$FAO_PUT					      ;
				       54  DD 007CB 12$:    PUSHL   NUM_MC_ENTRIES					      ; 3806
				  70   AB  9F 007CD 	    PUSHAB  P.ABA						      ;
		         6A	       02  FB 007D0 	    CALLS   #2, DBG$FAO_PUT					      ;
	      00000000G  EF	       00  FB 007D3 	    CALLS   #0, DBG$REPORT_FREE					      ; 3807
				       50  DD 007DA 	    PUSHL   R0							      ;
				0080   CB  9F 007DC 	    PUSHAB  P.ABB						      ;
		         6A	       02  FB 007E0 	    CALLS   #2, DBG$FAO_PUT					      ;
				       5E  DD 007E3 	    PUSHL   SP							      ; 3808
		  0119   CA	       01  FB 007E5 	    CALLS   #1, DBG$OUT_PUT					      ;
					   04 007EA 	    RET     							      ; 3616

; Routine Size:  323 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 14
; Digital Equipment Corporation
;
;	3810	GLOBAL ROUTINE DBG$SHOW_SCOPE( path_vec_ptr ) : NOVALUE =
;	3811	
;	3812	!++
;	3813	! Functional Description:
;	3814	!
;	3815	!	Print out the current scope position vector (CSP).
;	3816	!
;	3817	! Formal Parameters:
;	3818	!
;	3819	!	none.
;	3820	!
;	3821	! Implicit Inputs:
;	3822	!
;	3823	!	The CSP is a PATHNAME_VECTOR.
;	3824	!
;	3825	! Return Value:
;	3826	!
;	3827	!	NOVALUE
;	3828	!
;	3829	!--
;	3830	
;	3831	BEGIN
;	3832		LOCAL
;	3833				! Build output message here.
;	3834			output_buffer : VECTOR[ TTY_OUT_WIDTH, BYTE ];
;	3835	
;	3836		! Set up to use a new output buffer,
;	3837		! and encode the standard beginning of
;	3838		! the SHOW SCOPE message into it.
;	3839	
;	3840		dbg$cp_out_str = output_buffer + 1;
;	3841		dbg$gl_buf_siz = 0;
;	3842	
;	3843		dbg$fao_put( UPLIT( %ASCIC 'scope: ') );
;	3844	
;	3845		! The actual thing we print out depends
;	3846		! on whether or not there is actually
;	3847		! a CSP just now.
;	3848	
;	3849		IF( .DBG$GL_CSP_PTR NEQ 0 )
;	3850		THEN
;	3851			DBG$PRINT_PATH( .DBG$GL_CSP_PTR )
;	3852		ELSE
;	3853			dbg$fao_put( UPLIT( %ASCIC '<null>' ));
;	3854	
;	3855		! And finally force out the message.
;	3856	
;	3857		DBG$OUT_PUT( output_buffer );
;	3858	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      000EC P.ABC:  .ASCII  <7>\scope: \					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 14-1
; Digital Equipment Corporation
;
					      000F4 P.ABD:  .ASCII  <6>\<null>\<0>					      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0000 007EB 	    .ENTRY  DBG$SHOW_SCOPE, Save nothing			      ; 3810
		         5E	FF7C   CE  9E 007ED 	    MOVAB   -132(SP), SP					      ;
	      00000000G  EF	  01   AE  9E 007F2 	    MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 3840
			    00000000G  EF  D4 007FA 	    CLRL    DBG$GL_BUF_SIZ					      ; 3841
			    00000000'  EF  9F 00800 	    PUSHAB  P.ABC						      ; 3843
		  F7F5   CF	       01  FB 00806 	    CALLS   #1, DBG$FAO_PUT					      ;
		         50 00000000G  EF  D0 0080B 	    MOVL    DBG$GL_CSP_PTR, R0					      ; 3849
				       09  13 00812 	    BEQL    1$							      ;
				       50  DD 00814 	    PUSHL   R0							      ; 3851
		  0000V  CF	       01  FB 00816 	    CALLS   #1, DBG$PRINT_PATH					      ;
				       0B  11 0081B 	    BRB     2$							      ; 3849
			    00000000'  EF  9F 0081D 1$:     PUSHAB  P.ABD						      ; 3853
		  F7D8   CF	       01  FB 00823 	    CALLS   #1, DBG$FAO_PUT					      ;
				       5E  DD 00828 2$:     PUSHL   SP							      ; 3857
		  F8EA   CF	       01  FB 0082A 	    CALLS   #1, DBG$OUT_PUT					      ;
					   04 0082F 	    RET     							      ; 3810

; Routine Size:  69 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 15
; Digital Equipment Corporation
;
;	3859	GLOBAL ROUTINE DBG$PV_TO_CS( PATH_VEC_PTR, OUTPUT_BUF ) : NOVALUE =
;	3860	
;	3861	!++
;	3862	! Functional Description:
;	3863	!
;	3864	!	Encode a pathname vector into a given vector
;	3865	!	so that what we have built is a counted string.
;	3866	!
;	3867	! Formal Parameters:
;	3868	!
;	3869	!	PATH_VEC_PTR	-A pointer to the pathname vector we
;	3870	!			 want encoded.
;	3871	!
;	3872	!	OUTPUT_BUF	-A pointer to where we build the counted string.
;	3873	!
;	3874	! Implicit Inputs:
;	3875	!
;	3876	!	We will encode up to TTY_OUTPUT_WIDTH characters.
;	3877	!	The rest of the pathname vector is ignored.
;	3878	!
;	3879	! Return Value:
;	3880	!
;	3881	!	NOVALUE.
;	3882	!
;	3883	! Side Effects:
;	3884	!
;	3885	!	The pathname is encoded into the given buffer.
;	3886	!
;	3887	!--
;	3888	
;	3889	BEGIN
;	3890		MAP
;	3891			OUTPUT_BUF : REF VECTOR[,BYTE],
;	3892			PATH_VEC_PTR : REF PATHNAME_VECTOR;
;	3893		LOCAL
;	3894			CHAR_COUNT,
;	3895			OUTPUT_PTR : REF VECTOR[,BYTE];
;	3896	
;	3897		! Make sure we are called with valid parameters.
;	3898	
;	3899		IF( .PATH_VEC_PTR EQL 0 OR .OUTPUT_BUF EQL 0 )
;	3900		THEN
;	3901			RETURN;
;	3902	
;	3903		! The size of the counted string we build
;	3904		! starts off as 0.  The first element in the
;	3905		! string starts at the next character.
;	3906	
;	3907		char_count = 0;
;	3908		OUTPUT_PTR = OUTPUT_BUF[1];
;	3909	
;	3910		! Just encode the characters into the
;	3911		! the indicated position in the buffer
;	3912		! until we have exhausted the CS pointers
;	3913		! in the pathname vector.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 15-1
; Digital Equipment Corporation
;
;	3914	
;	3915		INCR I FROM 0 TO MAX_PATH_SIZE
;	3916			DO
;	3917			BEGIN
;	3918			LOCAL
;	3919					! Each element of the pathname vector
;	3920					! is a pointer to a counted string.
;	3921				CS_PTR : CS_POINTER;
;	3922	
;	3923			! Terminate when the path vector ends.
;	3924	
;	3925			IF( (cs_ptr = .PATH_VEC_PTR[.I]) EQL 0 )
;	3926			THEN
;	3927				EXITLOOP;
;	3928	
;	3929			! Output the pathname element
;	3930			! separation character in all
;	3931			! but the first iteration.
;	3932	
;	3933			IF( .I NEQ 0 )
;	3934			THEN
;	3935				begin
;	3936				char_count = .char_count +1;
;	3937				output_ptr[0] = %C'\';
;	3938				output_ptr = .output_ptr + 1;
;	3939				end;
;	3940	
;	3941			! See if we have enough room left for the next
;	3942			! pathname element.
;	3943	
;	3944			if( NOT .char_count + .cs_ptr[0] LSS tty_out_width )
;	3945			then
;	3946				exitloop;
;	3947	
;	3948			ch$move( .cs_ptr[0], cs_ptr[1], .output_ptr );
;	3949			char_count = .char_count +.cs_ptr[0];
;	3950			output_ptr = .output_ptr + .cs_ptr[0];
;	3951			END;
;	3952	
;	3953		! Now make the output buffer a real
;	3954		! counted string.
;	3955	
;	3956		OUTPUT_BUF[0] = .CHAR_COUNT;
;	3957	END;





					 03FC 00830 	    .ENTRY  DBG$PV_TO_CS, Save R2,R3,R4,R5,R6,R7,R8,R9		      ; 3859
				  04   AC  D5 00832 	    TSTL    PATH_VEC_PTR					      ; 3899
				       4A  13 00835 	    BEQL    4$							      ;
				  08   AC  D5 00837 	    TSTL    OUTPUT_BUF						      ;
				       45  13 0083A 	    BEQL    4$							      ;
				       58  D4 0083C 	    CLRL    CHAR_COUNT						      ; 3907

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 15-2
; Digital Equipment Corporation
;
	   59	    08   AC	       01  C1 0083E 	    ADDL3   #1, OUTPUT_BUF, OUTPUT_PTR				      ; 3908
				       57  D4 00843 	    CLRL    I							      ; 3915
		         56	  04 BC47  D0 00845 1$:     MOVL    @PATH_VEC_PTR[I], CS_PTR				      ; 3925
				       31  13 0084A 	    BEQL    3$							      ;
				       57  D5 0084C 	    TSTL    I							      ; 3933
				       06  13 0084E 	    BEQL    2$							      ;
				       58  D6 00850 	    INCL    CHAR_COUNT						      ; 3936
		         89	  5C   8F  90 00852 	    MOVB    #92, (OUTPUT_PTR)+					      ; 3937
		         50	       66  9A 00856 2$:     MOVZBL  (CS_PTR), R0					      ; 3944
		         50	       58  C0 00859 	    ADDL2   CHAR_COUNT, R0					      ;
	      00000084   8F	       50  D1 0085C 	    CMPL    R0, #132						      ;
				       18  18 00863 	    BGEQ    3$							      ;
		         50	       66  9A 00865 	    MOVZBL  (CS_PTR), R0					      ; 3948
	   69	    01   A6	       50  28 00868 	    MOVC3   R0, 1(CS_PTR), (OUTPUT_PTR)				      ;
		         50	       66  9A 0086D 	    MOVZBL  (CS_PTR), R0					      ; 3949
		         58	       50  C0 00870 	    ADDL2   R0, CHAR_COUNT					      ;
		         50	       66  9A 00873 	    MOVZBL  (CS_PTR), R0					      ; 3950
		         59	       50  C0 00876 	    ADDL2   R0, OUTPUT_PTR					      ;
	   C8	         57	       0A  F3 00879 	    AOBLEQ  #10, I, 1$						      ; 3915
		    08   BC	       58  90 0087D 3$:     MOVB    CHAR_COUNT, @OUTPUT_BUF				      ; 3956
					   04 00881 4$:     RET     							      ; 3859

; Routine Size:  82 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 16
; Digital Equipment Corporation
;
;	3958	GLOBAL ROUTINE DBG$PRINT_PATH( PATH_VEC_PTR ) : NOVALUE =
;	3959	
;	3960	!++
;	3961	! Functional Description:
;	3962	!
;	3963	!	Encode a pathname vector into the output stream
;	3964	!
;	3965	! Formal Parameters:
;	3966	!
;	3967	!	PATH_VEC_PTR	-A pointer to the pathname vector we want printed.
;	3968	!
;	3969	! Implicit Inputs:
;	3970	!
;	3971	!	Some exterior routine has done all the setup for
;	3972	!	DEBUG standard I/O.  This routine just does 'puts'.
;	3973	!
;	3974	! Return Value:
;	3975	!
;	3976	!	NOVALUE.
;	3977	!
;	3978	! Side Effects:
;	3979	!
;	3980	!	The pathname is encoded into the current output buffer.
;	3981	!
;	3982	!--
;	3983	
;	3984	BEGIN
;	3985		MAP
;	3986			PATH_VEC_PTR : REF PATHNAME_VECTOR;
;	3987		LOCAL
;	3988			SYM_BUFFER : VECTOR[ TTY_OUT_WIDTH, BYTE];
;	3989	
;	3990		! First encode the characters into our
;	3991		! own buffer - because we have a routine
;	3992		! that already knows how to do this.
;	3993	
;	3994		dbg$pv_to_cs( .path_vec_ptr, sym_buffer );
;	3995	
;	3996		! Then simply output the pathname.
;	3997	
;	3998		dbg$fao_put(UPLIT(%ASCIC '!AC'), sym_buffer );
;	3999	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      000FC P.ABE:  .ASCII  <3>\!AC\						      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0000 00882 	    .ENTRY  DBG$PRINT_PATH, Save nothing			      ; 3958
		         5E	FF7C   CE  9E 00884 	    MOVAB   -132(SP), SP					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 16-1
; Digital Equipment Corporation
;
				       5E  DD 00889 	    PUSHL   SP							      ; 3994
				  04   AC  DD 0088B 	    PUSHL   PATH_VEC_PTR					      ;
		    9E   AF	       02  FB 0088E 	    CALLS   #2, DBG$PV_TO_CS					      ;
				       5E  DD 00892 	    PUSHL   SP							      ; 3998
			    00000000'  EF  9F 00894 	    PUSHAB  P.ABE						      ;
		  F761   CF	       02  FB 0089A 	    CALLS   #2, DBG$FAO_PUT					      ;
					   04 0089F 	    RET     							      ; 3958

; Routine Size:  30 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 17
; Digital Equipment Corporation
;
;	4000	
;	4001	GLOBAL ROUTINE DBG$OUT_DIMENSN( DESCRIP_BLOCK, OUT_BUF ) : NOVALUE =
;	4002	  
;	4003	!++
;	4004	! Functional Description:
;	4005	! 
;	4006	!	Build a string showing valid array bounds for a FORTRAN array.
;	4007	!  
;	4008	! Formal Parameters :
;	4009	!
;	4010	!	DESCRIP_BLOCK		Address of SRM array descriptor (Class A)
;	4011	!
;	4012	!	OUT_BUF			Address of buffer where string is to be built
;	4013	!
;	4014	! Implicit Inputs :
;	4015	!
;	4016	!	Some other routine has done the set up for the output buffer.
;	4017	!
;	4018	! Implicit Outputs :
;	4019	!
;	4020	!	The output buffer is filled.
;	4021	!
;	4022	! Routine Value :
;	4023	!
;	4024	!	NOVALUE
;	4025	!
;	4026	! Side Effects :
;	4027	!
;	4028	!	The output buffer is filled.
;	4029	!
;	4030	!--
;	4031	BEGIN
;	4032		MAP
;	4033			descrip_block : REF BLOCK [,BYTE],
;	4034			out_buf       : REF VECTOR [,BYTE];
;	4035	  
;	4036		LOCAL
;	4037			span_block : REF VECTOR,
;	4038			bounds     : REF VECTOR,
;	4039			bound_lim		,
;	4040			no_dim                 ;
;	4041	  
;	4042	!
;	4043	! Set up for standard DEBUG I/O
;	4044	!
;	4045	 
;	4046	dbg$cp_out_str = .out_buf + 1;
;	4047	dbg$gl_buf_siz = 0 ;
;	4048	 
;	4049	!
;	4050	! set up pointers to longwords containing array bounds and dimension info
;	4051	!
;	4052	 
;	4053	no_dim = .descrip_block [dsc$b_dimct] ;
;	4054	span_block = descrip_block [dsc$l_m1] ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 17-1
; Digital Equipment Corporation
;
;	4055	bounds     = span_block [.no_dim]     ;
;	4056	 
;	4057	!
;	4058	! Build the string...
;	4059	!
;	4060	 
;	4061	bound_lim = (2 * .no_dim) - 1 ;
;	4062	
;	4063	INCR i FROM 0 TO .bound_lim BY 2
;	4064		DO  BEGIN
;	4065		    IF .bounds [.i] NEQ 1
;	4066			THEN dbg$fao_put (UPLIT (%ASCIC '!SL:'), .bounds [.i]) ;
;	4067		    IF .i NEQ .bound_lim - 1
;	4068			THEN dbg$fao_put (UPLIT (%ASCIC '!SL, '), .bounds [.i+1])
;	4069			ELSE dbg$fao_put (UPLIT (%ASCIC '!SL'),  .bounds [.i+1]) ;
;	4070	
;	4071		    END ;
;	4072	 
;	4073	!
;	4074	!	fill in the count
;	4075	!
;	4076		out_buf[0] = .dbg$gl_buf_siz ;
;	4077	END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00100 P.ABF:  .ASCII  <4>\!SL:\<0><0><0>					      ;
					      00108 P.ABG:  .ASCII  <5>\!SL, \<0><0>					      ;
					      00110 P.ABH:  .ASCII  <3>\!SL\						      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0C3C 008A0 	    .ENTRY  DBG$OUT_DIMENSN, Save R2,R3,R4,R5,R10,R11		      ; 4001
		         5A 00000000G  EF  9E 008A2 	    MOVAB   DBG$GL_BUF_SIZ, R10					      ;
		         5B 00000000'  EF  9E 008A9 	    MOVAB   P.ABF, R11						      ;
00000000G  EF	    08   AC	       01  C1 008B0 	    ADDL3   #1, OUT_BUF, DBG$CP_OUT_STR				      ; 4046
				       6A  D4 008B9 	    CLRL    DBG$GL_BUF_SIZ					      ; 4047
		         51	  04   AC  D0 008BB 	    MOVL    DESCRIP_BLOCK, R1					      ; 4053
		         50	  0B   A1  9A 008BF 	    MOVZBL  11(R1), NO_DIM					      ;
		         51	       14  C0 008C3 	    ADDL2   #20, SPAN_BLOCK					      ; 4054
		         53	     6140  DE 008C6 	    MOVAL   (SPAN_BLOCK)[NO_DIM], BOUNDS			      ; 4055
	   54	         50	       01  78 008CA 	    ASHL    #1, NO_DIM, BOUND_LIM				      ; 4061
				       54  D7 008CE 	    DECL    BOUND_LIM						      ;
		         52	       02  CE 008D0 	    MNEGL   #2, I						      ; 4063
				       2E  11 008D3 	    BRB     5$							      ;
		         01	     6342  D1 008D5 1$:     CMPL    (BOUNDS)[I], #1					      ; 4065
				       0A  13 008D9 	    BEQL    2$							      ;
				     6342  DD 008DB 	    PUSHL   (BOUNDS)[I]						      ; 4066
				       5B  DD 008DE 	    PUSHL   R11							      ;
		  F71B   CF	       02  FB 008E0 	    CALLS   #2, DBG$FAO_PUT					      ;
		         55	  FF   A4  9E 008E5 2$:     MOVAB   -1(BOUND_LIM), R5					      ; 4067

; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 17-2
; Digital Equipment Corporation
;
		         55	       52  D1 008E9 	    CMPL    I, R5						      ;
				       09  13 008EC 	    BEQL    3$							      ;
				  04 A342  DD 008EE 	    PUSHL   4(BOUNDS)[I]					      ; 4068
				  08   AB  9F 008F2 	    PUSHAB  P.ABG						      ;
				       07  11 008F5 	    BRB     4$							      ;
				  04 A342  DD 008F7 3$:     PUSHL   4(BOUNDS)[I]					      ; 4069
				  10   AB  9F 008FB 	    PUSHAB  P.ABH						      ;
		  F6FD   CF	       02  FB 008FE 4$:     CALLS   #2, DBG$FAO_PUT					      ;
	   52	         02	       54  F1 00903 5$:     ACBL    BOUND_LIM, #2, I, 1$				      ; 4063
				     FFCC     00907									      ;
		    08   BC	       6A  90 00909 	    MOVB    DBG$GL_BUF_SIZ, @OUT_BUF				      ; 4076
					   04 0090D 	    RET     							      ; 4001

; Routine Size:  110 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:33:26	DBB3:[DEBUG.SRC]DBGSSV.B32;7					Page 18
; Digital Equipment Corporation
;
;	4078	END
;	4079	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  DBG$PLIT       	   276  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  DBG$CODE       	  2318  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  DBG$OWN        	     4    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        23         0       224






;			COMPILER INTERNAL TIMING

;	Phase	    Faults	Cpu-time      Elapsed-time
;	LEXSYN	     1097	00:37.2		00:41.5
;	FLOWAN	      108	00:07.1		00:07.1
;	DELAY	       51	00:03.1		00:03.1
;	TNBIND	      128	00:05.5		00:05.5
;	CODE	      123	00:09.8		00:09.8
;	FINAL	      199	00:13.5		00:13.9
;	Total	     1706	01:16.2		01:20.8

; Size:		2318 code + 280 data bytes
; Run Time:	01:16.8
; Elapsed Time:	01:21.6
; Memory Used:	471 pages
; Compilation Complete
