
; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DBGFOR (	! multi-language lexical routine for DEBUG
;	0002			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE),
;	0003			IDENT = '000025') =
;	0004	BEGIN
;	0005	
;	0006	!
;	0007	!			  COPYRIGHT (c) 1977 BY
;	0008	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0009	!
;	0010	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0011	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0012	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0013	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0014	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0015	! TRANSFERRED.
;	0016	!
;	0017	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0018	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0019	! CORPORATION.
;	0020	!
;	0021	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0022	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0023	!
;	0024	
;	0025	!++
;	0026	! FACILITY:	DEBUG (DBG)
;	0027	!
;	0028	! ABSTRACT:
;	0029	!	This module contains a routine that according to conditional
;	0030	!	compilation declarations, compiles into a MARS or FORTRAN
;	0031	!	scanner.
;	0032	!
;	0033	! ENVIRONMENT:	STARLET, user mode, interrupts disabled.
;	0034	!
;	0035	! Version:	25
;	0036	!
;	0037	! History:
;	0038	!	Author:
;	0039	!		Carol Peters, 25 July 1977
;	0040	!
;	0041	!	Modified by:
;	0042	!		Dale Roedger, 18 May 1978:	25
;	0043	!
;	0044	! 02	04-09-77	CP	Change keyword name list to
;	0045	!				accommodate SCOPE, GLOBAL, etc.
;	0046	!	  			Get the keyword require file from
;	0047	!				[,1327] instead of [,2143].
;	0048	!	  			Add the keyword MODULE. Remove
;	0049	!				keyword READ. Add "." as a legal
;	0050	!	  			component of a symbolic name.
;	0051	! 03	07-09-77	CP	Change the keyword_table to be a single
;	0052	!				plit, with a zero byte marking the end.
;	0053	!				Recode trans_lexeme to dynamically compute
;	0054	!				the address of each entry. This makes the
;	0055	!				module PIC.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 1-1
; Digital Equipment Corporation
;
;	0056	! 04	13-09-77	CP	In collecting numeric input, convert
;	0057	!				lower case hexadecimal letters to upper
;	0058	!				case before writing the characters into
;	0059	!				the input buffer. Get the keyword require
;	0060	!				file from COMKEY instead of BL4KEY.
;	0061	! 05	13-09-77	CP	Delete variable dbg_multi_lang. Name
;	0062	!				the get_a_lexeme routine according to
;	0063	!				the language variable. It is either
;	0064	!				dbg$mar_get_lex, dbg$for_get_lex, or
;	0065	!				dbg$bli_get_lex. In get_a_token, call the
;	0066	!				appropriate lexeme routine through
;	0067	!				the variable dbg$gl_get_lex. Make the
;	0068	!				get_lexeme routines global. Modify
;	0069	!				get_lexeme to handle FORTRAN radix
;	0070	!				encoding ('digits'O and 'digits'X) and
;	0071	!				to convert FORTRAN numbers. Remove routines
;	0072	!				dbg$get_a_token and trans_lexeme and
;	0073	!				put them in the new module dbgsca.b32.
;	0074	!				Add new REQUIRE file declaration for
;	0075	!				chrkey.beg, defines character mappings,
;	0076	!				was in COMKEY.
;	0077	! 06	14-09-77	CP	In lex_typ_tbl, define alpha state as
;	0078	!				all alphabetic characters, including
;	0079	!				alpha/hex characters for all languages.
;	0080	! 07	14-09-77	CP	A leading period in FORTRAN can be the
;	0081	!				beginning if a keyword operator, of a
;	0082	!				number, or a standalone term. Correct code
;	0083	!				to reflect this.
;	0084	! 08	21-09-77	CP	In the processing of FORTRAN numeric
;	0085	!				strings, see whether mode %LABEL or %LINE
;	0086	!				is set, and if so, return an alpha token
;	0087	!				instead of a converted number.
;	0088	! 09	04-10-77	CP	Remove external declaration for error_reprt.
;	0089	!				SIGNAL for invalid characters seen.
;	0090	!				SIGNAL for truncations, correct numeric
;	0091	!				processing.
;	0092	! 10	27-10-77	CP	In the lexical routine, don't read a
;	0093	!				line if the count field is less than
;	0094	!				zero. Also, reduce length remaining when
;	0095	!				an end of line character is seen.
;	0096	! 11	07-11-77	CP	Change a_longword to 4 and a_byte to 1.
;	0097	! 12	23-11-77	CP	If collecting a number, and it is a
;	0098	!				line number of FORTRAN statement number,
;	0099	!				don't allow special radices or
;	0100	!				embedded periods. Return alpha token.
;	0101	! 13	30-11-77	CP	Modify numeric string collection for
;	0102	!				FORTRAN to handle floating and real
;	0103	!				strings.
;	0104	! 14	06-12-77	CP	In FORTRAN number collection, note
;	0105	!				whether string included an explicit
;	0106	!				D exponent field, which indicates double
;	0107	!				precision. Distinguish between single
;	0108	!				and double precision token in return.
;	0109	! 15	28-12-77	CP	Redefine grammar tokens.
;	0110	! 16	05-JAN-78	DAR	Changed require file MARTOK.BEG to COMTER.BEG

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 1-2
; Digital Equipment Corporation
;
;	0111	!				also changed token names to correspond to those
;	0112	!				in COMTER.BEG
;	0113	! 17	24-FEB-78	DAR	Removed "SIGNAL(DBG$_NUMTRUNC)" from the
;	0114	!				numeric_state case in the DBG$xxx_GET_LEX
;	0115	!				routine.  The error is now signaled in DBG$RADX_
;	0116	!				CONVRT.
;	0117	! 18	09-MAR-78	DAR	Modified DBG$FOR_GET_LEX "radix_state" to scan
;	0118	!				ahead for a radix operator when ' is found.
;	0119	!				Also cleaned up DBG$MAR_GET_LEX "radix_state"
;	0120	!				to be more readable.
;	0121	! 19	29-MAR-78	DAR	Removed require file CHRKEY.BEG and put it in
;	0122	!				DBGSTO.B32 as CHRKEY.REQ.  Changed the name of
;	0123	!				"char_type_table" to dbg$char_table.
;	0124	! 20	30-MAR-78	DAR	Removed the "token_table" to DBGSTO.B32 and
;	0125	!				renamed it to dbg$token_table.
;	0126	! 21	13-APR-78	DAR	Made all the require file and library file names
;	0127	!				uppercase.
;	0128	! 22	21-APR-78	DAR	split the lexical source into two modules.
;	0129	! 23	27-APR-78	DAR	Modified the require and library directives
;	0130	!				for the native build.
;	0131	! 24	09-MAY-78	DAR	Alpha state returns alpha_str_token instead of
;	0132	!				"alpha".
;	0133	! 25	18-MAY-78	DAR	Call to DBG$RADX_CONVRT passes address of string
;	0134	!				descriptor instead of string's address.
;	0135	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 2
; Digital Equipment Corporation
;
;	0136	! TABLE OF CONTENTS:
;	0137	!
;	0138	FORWARD ROUTINE
;	0139	
;	0140		dbg$for_get_lex;	! extracts a FORTRAN lexeme from the input buffer
;	0141	
;	0142	!
;	0143	! INCLUDE FILES:
;	0144	!
;	0145	%IF %VARIANT		! True for TEN.
;     L 0146	%THEN
;     U 0147	LIBRARY	'NEW:LIB';
;     U 0148	
;     U 0149	REQUIRE 'DBGPCT.REQ';
;     U 0150	REQUIRE 'VXSMAC.REQ';
;     U 0151	REQUIRE 'DBGGEN.REQ';
;     U 0152	REQUIRE 'COMTER.REQ';			
;     U 0153	REQUIRE 'SCALIT.REQ';
;     U 0154	REQUIRE 'DBGMSG.REQ';
;     U 0155	REQUIRE 'SYSSER.REQ';
;     U 0156	%ELSE
;	0157	LIBRARY	'SYS$LIBRARY:LIB.L32';
;	0158	
;	0159	REQUIRE 'SRC$:DBGPCT.REQ';
;	0171	REQUIRE 'SRC$:VXSMAC.REQ';
;	0211	REQUIRE 'SRC$:DBGGEN.REQ';
;	0461	REQUIRE 'SRC$:COMTER.REQ';			
;	0553	REQUIRE 'SRC$:SCALIT.REQ';
;	0591	REQUIRE 'LIB$:DBGMSG.REQ';
;	0870	REQUIRE 'SRC$:SYSSER.REQ';
;      R0873	SWITCHES LIST (SOURCE);
;      R0874	
;      R0875	EXTERNAL ROUTINE
;      R0876		dbg$fao_out;				! formats a line and outputs to the terminal
;      R0877	
;      R0878	SWITCHES LIST (NOSOURCE);
;	0923	%FI
;	0924	
;	0925	
;	0926	
;	0927	!
;	0928	! MACROS:	NONE
;	0929	
;	0930	!
;	0931	! EQUATED SYMBOLS:
;	0932	!
;	0933	LITERAL
;	0934		dbg_lex		= FALSE,	! for debugging
;	0935		dbg_lex1	= FALSE;	! for debugging
;	0936	
;	0937	
;	0938	!
;	0939	! OWN STORAGE:	NONE
;	0940	
;	0941	!

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 2-1
; Digital Equipment Corporation
;
;	0942	! EXTERNAL REFERENCES:
;	0943	!
;	0944	EXTERNAL ROUTINE
;	0945		dbg$radx_convrt;		! converts ASCII strings to binary numbers
;	0946	
;	0947	EXTERNAL
;	0948		dbg$char_table : VECTOR [, BYTE],	! Character type table
;	0949		dbg$token_table : VECTOR [, BYTE],	! Table of token types.
;	0950		dbg$gb_def_mod : VECTOR [, BYTE],	! mode structure
;	0951		dbg$gb_mod_ptr : REF VECTOR [, BYTE],	! holds current radix
;	0952		dbg$gl_get_lex;				! holds name of get lexeme routine

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 3
; Digital Equipment Corporation
;
;	0953	GLOBAL ROUTINE dbg$for_get_lex (input_stg_desc, lexeme_stg_desc) =
;	0954	
;	0955	!++
;	0956	! Functional description:
;	0957	!	Using the character pointer for the input line, extracts a lexeme
;	0958	!	from the input line. A lexeme is defined as an operator, an
;	0959	!	alphanumeric string, a numeric string, or an
;	0960	!	illegal string. Blanks and comments are absorbed.
;	0961	!	The lexeme is returned in the lexeme buffer in the
;	0962	!	same form as in the input string, except for numeric
;	0963	!	strings, in which case the string is converted to a
;	0964	!	binary number and that is returned in the lexeme buffer.
;	0965	!	A token equivalent of the lexeme is the value of the
;	0966	!	routine.
;	0967	!
;	0968	! Formal parameters:
;	0969	!	input_stg_desc	- string descriptor to the input buffer.
;	0970	!	lexeme_stg_desc	- varying string descriptor to the lexeme buffer
;	0971	!
;	0972	! Implicit inputs:
;	0973	!	DBG$CHAR_TABLE	- a 128 byte VECTOR that maps each ascii character
;	0974	!			  onto a dense list of equivalents.
;	0975	!	DBG$TOKEN_TABLE	- a 21 byte VECTOR that maps each operator onto
;	0976	!			  its token equivalent.
;	0977	!
;	0978	! Outputs:
;	0979	!	input_stg_desc	- the field dsc$a_pointer is updated to point to
;	0980	!			  the next byte to be read in the input stream.
;	0981	!			  This byte is the delimiter of the lexeme found.
;	0982	!			  The field dsc$w_length contains the length of
;	0983	!			  the yet unread input line.
;	0984	!	lexeme_stg_desc	- the field dsc$w_length holds the actual length
;	0985	!			  in bytes of the lexeme found. The lexeme buffer
;	0986	!			  addressed by the field dsc$a_pointer holds the
;	0987	!			  lexeme string or value.
;	0988	!
;	0989	! Implicit outputs:
;	0990	!	The ASCII representation of the lexeme is written into the
;	0991	!	string addressed by the dsc$a_pointer field of lexeme_stg_desc.
;	0992	!
;	0993	! Routine value:
;	0994	!	The type of lexeme found, alpha_str_token, digit_str_token,
;	0995	!	eol_token or "operator"_token.
;	0996	!
;	0997	! Side effects:
;	0998	!	Signal if an input character is invalid,
;	0999	!	or the input string has a negative length.
;	1000	!--
;	1001	
;	1002		BEGIN
;	1003	
;	1004		LITERAL
;	1005			single_prec	= 1,
;	1006			double_prec	= 3,
;	1007			table_offset	= 9,

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 3-1
; Digital Equipment Corporation
;
;	1008			operator_max	= 29;
;	1009	
;	1010		LITERAL
;	1011			max_state_index	= 4,			! index ranges from 0 to 4
;	1012			invalid_state	= 0,			! invalid character seen
;	1013			alpha_state	= 1,			! alphabetic string expected
;	1014			numeric_state	= 2,			! numeric string expected
;	1015			eocommand_state	= 3,			! logical end of line or error seen
;	1016			radix_state	= 4,			! radix setting expected
;	1017			unspec_state	= 5;			! unspecified state, probably special character operator
;	1018	
;	1019		BIND
;	1020			lex_type_tbl	= UPLIT (
;	1021	
;	1022			mask (illegal),
;	1023			mask (alpha, alpha_low, alpha_and_hex, alphalo_and_hex
;     P 1024				, period, percent_sign),
;	1025			mask (numeric),
;	1026			mask (ind_comment, end_of_line),
;	1027			mask (quote)
;	1028	
;	1029			) : VECTOR;
;	1030	
;	1031		BIND
;	1032			lex_state_tbl	= UPLIT BYTE (
;	1033	
;	1034			invalid_state,
;	1035			alpha_state,
;	1036			numeric_state,
;	1037			eocommand_state,
;	1038			radix_state
;	1039	
;	1040			) : VECTOR [, BYTE];
;	1041	
;	1042	
;	1043		MAP
;	1044			input_stg_desc	: REF BLOCK [, BYTE],	! input string descriptor
;	1045			lexeme_stg_desc	: REF BLOCK [, BYTE];	! lexeme string descriptor
;	1046	
;	1047		LOCAL
;	1048			input_ptr,				! character pointer for input
;	1049			lexeme_ptr,				! character pointer for lexeme
;	1050			previous_radix,				! current local radix
;	1051			special_radix,				! special radix setting
;	1052			state_index,				! index into lex_state_tbl
;	1053			state,					! current state of lexical processor
;	1054			char,					! holds a single character
;	1055			count;					! counts characters used
;	1056	
;	1057		LABEL
;	1058			alpha_block;			! label for alpha case in the select
;	1059	
;	1060		!++
;	1061		! See whether there is any input line left. If not, signal
;	1062		! internal error.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 3-2
; Digital Equipment Corporation
;
;	1063		!--
;	1064		IF .input_stg_desc [dsc$w_length] LSS 0
;	1065		THEN SIGNAL (dbg$_parseerr);
;	1066	
;	1067		!++
;	1068		! Make the string pointers into formal BLISS character
;	1069		! pointers.
;	1070		!--
;	1071		input_ptr = ch$ptr (.input_stg_desc [dsc$a_pointer]);
;	1072		lexeme_ptr = ch$ptr (.lexeme_stg_desc [dsc$a_pointer]);
;	1073	
;	1074		!++
;	1075		! Save the radix in case it changes temporarily.
;	1076		!--
;	1077		previous_radix = .dbg$gb_mod_ptr [mode_radix];
;	1078	
;	1079		special_radix = FALSE;
;	1080		count = 0;
;	1081		REPEAT						! skip leading blanks
;	1082			BEGIN
;	1083			char = ch$rchar (.input_ptr);
;	1084			IF .dbg$char_table [.char] NEQ blanks
;	1085			THEN
;	1086				BEGIN
;	1087				input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;
;	1088				EXITLOOP
;	1089				END
;	1090			ELSE
;	1091				BEGIN
;	1092				input_ptr = ch$plus (.input_ptr, 1);
;	1093				count = .count + 1;
;	1094				END;
;	1095			END;
;	1096	
;	1097	%IF dbg_lex
;     L 1098	%THEN
;     U 1099		$fao_tt_out ('character is "!AD"', 1, char);
;     U 1100	%FI
;	1101	
;	1102		!++
;	1103		! Convert the mapping of the first significant character
;	1104		! into a lexical state. This state drives the later CASE
;	1105		! processing.
;	1106		!--
;	1107		state_index = 0;
;	1108		REPEAT
;	1109			BEGIN
;	1110			IF .lex_type_tbl [.state_index] ^ .dbg$char_table [.char] LSS 0
;	1111			THEN
;	1112				BEGIN
;	1113				state = .lex_state_tbl [.state_index];
;	1114				EXITLOOP
;	1115				END
;	1116			ELSE
;	1117				BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 3-3
; Digital Equipment Corporation
;
;	1118				state_index = .state_index + 1;
;	1119				IF .state_index GTR max_state_index
;	1120				THEN
;	1121					BEGIN
;	1122					state = unspec_state;
;	1123					EXITLOOP
;	1124					END;
;	1125				END;
;	1126			END;
;	1127	
;	1128	%IF dbg_lex
;     L 1129	%THEN
;     U 1130		$fao_tt_out ('state is !SL', .state);
;     U 1131	%FI
;	1132	
;	1133		REPEAT CASE .state FROM 0 to max_state_index + 1 OF	! analyze current state
;	1134	
;	1135			SET
;	1136	
;	1137			[invalid_state]:			! if illegal, just signal
;	1138				SIGNAL (dbg$_invchar);

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 4
; Digital Equipment Corporation
;
;	1139			[alpha_state]:				! alphanumeric string
;	1140	alpha_block:		BEGIN
;	1141	
;	1142				!++
;	1143				! If the initial character is
;	1144				! a period, see whether the next character is
;	1145				! an alphabetic. If it is, this must be a logical
;	1146				! operator keyword, so allow the leading dot.
;	1147				! Otherwise, it is a number or a standalone term.
;	1148				!--
;	1149				LOCAL
;	1150					period_present;
;	1151				IF .char EQL asc_period
;	1152				THEN
;	1153					BEGIN
;	1154	
;	1155					LOCAL
;	1156						new_char;
;	1157	
;	1158					new_char = ch$rchar (ch$plus (.input_ptr, 1));
;	1159					IF NOT (oneof (.dbg$char_table [.new_char], alpha, alpha_low,
;     P 1160							alpha_and_hex, alphalo_and_hex))
;	1161					THEN
;	1162						BEGIN
;	1163						IF .dbg$char_table [.new_char] EQL numeric
;	1164						THEN state = numeric_state
;	1165						ELSE state = unspec_state;
;	1166						LEAVE alpha_block;
;	1167						END
;	1168					ELSE period_present = TRUE;
;	1169					END
;	1170				ELSE period_present = FALSE;
;	1171				!++
;	1172				! Now read the input buffer until a non-alpha
;	1173				! and non-numeric
;	1174				! character is encountered. Store each
;	1175				! character found in the buffer for the lexeme
;	1176				! unless the length of that buffer is expended.
;	1177				!--
;	1178	
;	1179				count = 0;
;	1180	
;	1181				DO
;	1182					BEGIN
;	1183					IF (.char GEQU %C'a')
;	1184					THEN char = .char - upper_case_dif;
;	1185					count = .count + 1;
;	1186					IF .count LEQ sym_max_length
;	1187					THEN ch$wchar_a (.char, lexeme_ptr);
;	1188					char = ch$a_rchar (input_ptr);
;	1189					END
;	1190				WHILE	(oneof (.dbg$char_table [.char], alpha, alpha_low, numeric,
;     P 1191							alpha_and_hex, alphalo_and_hex));
;	1192	
;	1193				!++

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 4-1
; Digital Equipment Corporation
;
;	1194				! Now see whether the next character
;	1195				! is a period and the string started with a
;	1196				! period. In this case, store the ending period
;	1197				! also.
;	1198				!--
;	1199				IF .char EQL asc_period AND .period_present
;	1200				THEN
;	1201					BEGIN
;	1202					count = .count + 1;
;	1203					IF .count LEQ sym_max_length
;	1204					THEN ch$wchar (.char, .lexeme_ptr);
;	1205					input_ptr = ch$plus (.input_ptr, 1);
;	1206					END;
;	1207	
;	1208				IF .count GTR sym_max_length
;	1209				THEN
;	1210					BEGIN
;	1211					SIGNAL (dbg$_stgtrunc);
;	1212					lexeme_stg_desc [dsc$w_length] = sym_max_length;
;	1213					END
;	1214				ELSE lexeme_stg_desc [dsc$w_length] = .count;
;	1215				input_stg_desc [dsc$a_pointer] = .input_ptr;
;	1216				input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;
;	1217	
;	1218	%IF dbg_lex
;     L 1219	%THEN
;     U 1220				$fao_tt_out ('string is "!AS"', lexeme_stg_desc);
;     U 1221	%FI
;	1222	
;	1223				RETURN alpha_str_token
;	1224				END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 5
; Digital Equipment Corporation
;
;	1225			[numeric_state]:			! numeric string
;	1226				BEGIN
;	1227	
;	1228				!++
;	1229				! A number can begin with
;	1230				! or contain a decimal point (period). See
;	1231				! whether there is a leading decimal point,
;	1232				! and if so, set a flag indicating that.
;	1233				! This will allow trailing zeroes to be ignored.
;	1234				!--
;	1235	
;	1236				LOCAL
;	1237					period_present,
;	1238					floating_flag;
;	1239	
;	1240				IF .char EQL asc_period
;	1241				THEN period_present = TRUE
;	1242				ELSE period_present = FALSE;
;	1243				floating_flag = 0;
;	1244	
;	1245				!++
;	1246				! Now read the input buffer until a non-numeric
;	1247				! character is encountered. Ignore all leading
;	1248				! zeroes unless a decimal point was present.
;	1249				! Store each character found in the buffer for
;	1250				! the lexeme unless the length of that buffer
;	1251				! is expended.
;	1252				!--
;	1253				count = 0;
;	1254	
;	1255				IF NOT .period_present
;	1256				THEN
;	1257					WHILE (.char EQL %C'0')
;	1258					DO
;	1259						BEGIN
;	1260						count = .count + 1;
;	1261						char = ch$a_rchar (input_ptr);
;	1262						END;
;	1263	
;	1264				!++
;	1265				! If the entire number was zero, put a single
;	1266				! zero in the lexeme buffer and return.
;	1267				!--
;	1268				input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;
;	1269				count = 0;
;	1270				IF .dbg$char_table [.char] NEQ numeric
;	1271					AND .dbg$char_table [.char] NEQ period
;	1272					AND NOT .period_present
;	1273					AND NOT (oneof (.dbg$char_table [.char], alpha_and_hex, alphalo_and_hex))
;	1274				THEN
;	1275					BEGIN
;	1276	
;	1277	%IF dbg_lex
;     L 1278	%THEN
;     U 1279					$fao_tt_out ('returning a zero');

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 5-1
; Digital Equipment Corporation
;
;     U 1280	%FI
;	1281	
;	1282					ch$wchar (0, .lexeme_ptr);
;	1283					lexeme_stg_desc [dsc$w_length] = 1;
;	1284					input_stg_desc [dsc$a_pointer] = .input_ptr;
;	1285					RETURN digit_str_token
;	1286					END;
;	1287	
;	1288				!++
;	1289				! This is the normal store and pick up next
;	1290				! numeric character.
;	1291				!--
;	1292				IF (NOT .period_present) AND (.dbg$char_table [.char] NEQ period)
;	1293				THEN
;	1294					DO
;	1295						BEGIN
;	1296						IF .dbg$char_table[.char] EQL alphalo_and_hex
;	1297						THEN char = .char - upper_case_dif;
;	1298						count = .count + 1;
;	1299						IF .count GTR num_max_length
;	1300						THEN
;	1301							BEGIN
;	1302	
;	1303	%IF dbg_lex
;     L 1304	%THEN
;     U 1305							$fao_tt_out ('numeric overflow');
;     U 1306	%FI
;	1307	
;	1308							ch$move (num_max_length - 1,
;	1309								ch$plus (ch$ptr (.lexeme_stg_desc [dsc$a_pointer]), 1),
;	1310								ch$ptr (.lexeme_stg_desc [dsc$a_pointer]));
;	1311							ch$wchar (.char, .lexeme_ptr-1);
;	1312							END
;	1313						ELSE ch$wchar_a (.char, lexeme_ptr);
;	1314						char = ch$a_rchar (input_ptr);
;	1315	
;	1316	%IF dbg_lex
;     L 1317	%THEN
;     U 1318						$fao_tt_out ('next character is "!AD", type is !SB', 1, char,
;     U 1319								.dbg$char_table [.char]);
;     U 1320	%FI
;	1321	
;	1322						END
;	1323					WHILE (oneof (.dbg$char_table [.char], numeric,
;     P 1324							alpha_and_hex, alphalo_and_hex));
;	1325	
;	1326				!++
;	1327				! FORTRAN may have a decimal point following the
;	1328				! string of digits. Look for the decimal point.
;	1329				! If it is present as the next character, set
;	1330				! the period present flag.
;	1331				!--
;	1332				IF .char EQL asc_period
;	1333				THEN IF NOT .period_present
;	1334				THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 5-2
; Digital Equipment Corporation
;
;	1335					BEGIN
;	1336					period_present = TRUE;
;	1337					DO
;	1338						BEGIN
;	1339						count = .count + 1;
;	1340						IF .count LEQ .lexeme_stg_desc [dsc$w_maxlen]
;	1341						THEN ch$wchar_a (.char, lexeme_ptr);
;	1342						char = ch$a_rchar (input_ptr);
;	1343						END
;	1344					WHILE (.dbg$char_table[.char] EQL numeric);
;	1345					END;
;	1346	
;	1347				!++
;	1348				! Now see if this is a number of the form
;	1349				! 'nnn'X or 'nnn'O, in which case, look for
;	1350				! the closing quote and the radix indicator.
;	1351				!--
;	1352				IF ((.special_radix) AND (NOT .period_present))
;	1353				THEN
;	1354					BEGIN
;	1355	
;	1356					!++
;	1357					! Processing a numeric string that is
;	1358					! enclosed in quotes and followed by a
;	1359					! letter indicating radix. Look for the
;	1360					! closing quote and the radix letter.
;	1361					!--
;	1362					IF .char EQL asc_quote
;	1363					THEN
;	1364					    BEGIN
;	1365					    char = ch$rchar (ch$plus (.input_ptr, 1));
;	1366					    IF .dbg$char_table[.char] EQL alpha_low
;	1367					    THEN char = .char - upper_case_dif;
;	1368					    SELECTONE .char OF
;	1369						SET
;	1370						[%C'O']: dbg$gb_mod_ptr[mode_radix] = octal_radix;
;	1371						[%C'X']: dbg$gb_mod_ptr[mode_radix] = hex_radix;
;	1372						[otherwise]: dbg$gb_mod_ptr[mode_radix] = decimal_radix;
;	1373						TES;
;	1374						input_ptr = ch$plus (.input_ptr, 2);
;	1375						input_stg_desc[dsc$w_length] = .input_stg_desc[dsc$w_length] - 2;
;	1376					    END;
;	1377					END
;	1378				ELSE
;	1379					BEGIN
;	1380	
;	1381					!++
;	1382					! Now allow for a D or E form of floating
;	1383					! number, followed by an optional positive
;	1384					! or negative sign, followed by more digits.
;	1385					!--
;	1386					IF (.char GEQU %C'a')
;	1387					THEN char = .char - upper_case_dif;
;	1388					IF (.char EQL %C'D') OR (.char EQL %C'E')
;	1389					THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 5-3
; Digital Equipment Corporation
;
;	1390						BEGIN
;	1391						IF .char EQL %C'D'
;	1392						THEN floating_flag = double_prec
;	1393						ELSE floating_flag = single_prec;
;	1394	
;	1395	%IF dbg_lex1
;     L 1396	%THEN
;     U 1397						$fao_tt_out ('character is !AD', 1, char);
;     U 1398	%FI
;	1399	
;	1400						ch$wchar_a (.char, lexeme_ptr);
;	1401						count = .count + 1;
;	1402						char = ch$a_rchar (input_ptr);
;	1403						END;
;	1404					IF .period_present AND .floating_flag
;	1405					THEN
;	1406						BEGIN
;	1407						IF (.char EQL %C'+') OR (.char EQL %C'-')
;	1408						THEN
;	1409							BEGIN
;	1410							ch$wchar_a (.char, lexeme_ptr);
;	1411							count = .count + 1;
;	1412							char = ch$a_rchar (input_ptr);
;	1413							END;
;	1414						END;
;	1415					IF .period_present OR .floating_flag
;	1416					THEN	WHILE (.dbg$char_table[.char] EQL numeric)
;	1417						DO
;	1418						BEGIN
;	1419						count = .count + 1;
;	1420						IF .count LEQ .lexeme_stg_desc [dsc$w_maxlen]
;	1421						THEN ch$wchar_a (.char, lexeme_ptr);
;	1422						char = ch$a_rchar (input_ptr);
;	1423						END;
;	1424					END;
;	1425	
;	1426				!++
;	1427				! Convert the number, restore the old radix,
;	1428				! and return the numeric lexeme.
;	1429				!--
;	1430	
;	1431	%IF dbg_lex
;     L 1432	%THEN
;     U 1433				$fao_tt_out ('number is "!AD"', .count,
;     U 1434						.lexeme_stg_desc [dsc$a_pointer]);
;     U 1435	%FI
;	1436	
;	1437				!++
;	1438				! See whether the user has just said %LABEL or
;	1439				! the %LABEL mode is in effect, in which case
;	1440				! a string must be returned instead of the
;	1441				! actual binary number.
;	1442				!--
;	1443	
;	1444				lexeme_stg_desc[dsc$w_length] = .count;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 5-4
; Digital Equipment Corporation
;
;	1445				IF (NOT .period_present) AND (NOT .floating_flag)
;	1446					AND (.dbg$gb_mod_ptr [mode_fortran] NEQ label_mode)
;	1447					AND (.dbg$gb_mod_ptr [mode_fortran] NEQ line_mode)
;	1448				THEN
;	1449					BEGIN
;	1450					.lexeme_stg_desc[dsc$a_pointer] = dbg$radx_convrt (.lexeme_stg_desc);
;	1451					dbg$gb_mod_ptr [mode_radix] = .previous_radix;
;	1452					lexeme_stg_desc [dsc$w_length] = 4;
;	1453	
;	1454	%IF dbg_lex
;     L 1455	%THEN
;     U 1456					$fao_tt_out ('number is !SL', .(.lexeme_stg_desc [dsc$a_pointer]));
;     U 1457	%FI
;	1458	
;	1459					END
;	1460				ELSE
;	1461					BEGIN
;	1462					IF .count GTR .lexeme_stg_desc [dsc$w_maxlen]
;	1463					THEN
;	1464						BEGIN
;	1465						lexeme_stg_desc [dsc$w_length] = .lexeme_stg_desc [dsc$w_maxlen];
;	1466						SIGNAL (dbg$_numtrunc);
;	1467						END;
;	1468					END;
;	1469	
;	1470				input_stg_desc [dsc$a_pointer] = .input_ptr;
;	1471				input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;
;	1472	
;	1473	%IF dbg_lex
;     L 1474	%THEN
;     U 1475				char = ch$rchar (.input_ptr);
;     U 1476				$fao_tt_out ('delimiter is "!AD"', 1, char);
;     U 1477	%FI
;	1478	
;	1479				IF (.dbg$gb_mod_ptr [mode_fortran] EQL label_mode)
;	1480					OR (.dbg$gb_mod_ptr [mode_fortran] EQL line_mode)
;	1481				THEN
;	1482					BEGIN
;	1483					IF .dbg$gb_mod_ptr [mode_radix] NEQ .previous_radix
;	1484					    OR .period_present
;	1485					THEN
;	1486					    BEGIN
;	1487					    SIGNAL (dbg$_invnumber, 1, .lexeme_stg_desc);
;	1488					    RETURN (0);
;	1489					    END;
;	1490					RETURN alpha_str_token;
;	1491					END
;	1492				ELSE	IF .floating_flag EQL double_prec
;	1493					THEN RETURN double_fl_token
;	1494					ELSE	IF .floating_flag OR .period_present
;	1495						THEN RETURN single_fl_token
;	1496						ELSE RETURN digit_str_token
;	1497				END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 6
; Digital Equipment Corporation
;
;	1498			[eocommand_state]:			! logical end of line
;	1499				BEGIN
;	1500	
;	1501				!++
;	1502				! The length of the input line should be set to
;	1503				! zero here. Reduce it one so that it is less than
;	1504				! zero. This will cause an error if this same
;	1505				! input line ever comes back to the lex routine.
;	1506				!--
;	1507				lexeme_stg_desc [dsc$w_length] = 0;
;	1508				input_stg_desc [dsc$a_pointer] = ch$plus (.input_ptr, 1);
;	1509				input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - 1;
;	1510				RETURN eol_token
;	1511				END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 7
; Digital Equipment Corporation
;
;	1512			[radix_state]:				! up arrow, quote, percent sign
;	1513				BEGIN		! FORTRAN handling
;	1514	
;	1515				!++
;	1516				! A quote can occur as the beginning of an
;	1517				! alphabetic string, or as a special character
;	1518				! that begins a numeric string that ends in another
;	1519				! quote and then a radix-indicator letter.
;	1520				! See whether this is a quote followed by a
;	1521				! number. If so, save a state variable, 
;	1522				! and proceed to collect the number.
;	1523				!--
;	1524				LOCAL
;	1525					temp_ptr;
;	1526	
;	1527				temp_ptr = ch$plus(.input_ptr, 1);
;	1528				char = ch$rchar_a(temp_ptr);
;	1529				IF (oneof (.dbg$char_table[.char], numeric, alpha_and_hex,
;     P 1530						alphalo_and_hex))
;	1531				THEN
;	1532					BEGIN
;	1533					DO
;	1534					char = ch$rchar_a(temp_ptr)
;	1535					UNTIL (oneof (.dbg$char_table[.char], quote, end_of_line));
;	1536					IF (.dbg$char_table[.char] EQL quote)
;	1537					THEN
;	1538					    BEGIN
;	1539					    char = ch$rchar(.temp_ptr);
;	1540					    IF (.char GEQU %C'a')
;	1541					    THEN char = .char - upper_case_dif;
;	1542					    IF ((.char EQL %C'O') OR (.char EQL %C'X')
;	1543						OR (.char EQL %C'D'))
;	1544					    THEN state = numeric_state;
;	1545					    END;
;	1546					END;
;	1547				IF (.state EQL numeric_state)
;	1548				THEN
;	1549					BEGIN
;	1550					char = ch$a_rchar(input_ptr);		! update ptr and get first no.
;	1551					input_stg_desc[dsc$a_pointer] = .input_ptr;
;	1552					input_stg_desc[dsc$w_length] = .input_stg_desc[dsc$w_length] - 1;
;	1553					special_radix = TRUE;
;	1554					END
;	1555				ELSE
;	1556					BEGIN
;	1557					char = ch$rchar(.input_ptr);
;	1558					state = unspec_state;
;	1559					END;
;	1560	
;	1561				END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8
; Digital Equipment Corporation
;
;	1562			[unspec_state]:				! special character like operator or illegal
;	1563				BEGIN
;	1564	
;	1565				!++
;	1566				! Most likely, this is a single character
;	1567				! operator. Write its ASCII value into the
;	1568				! lexeme buffer, and return its equivalent
;	1569				! token.
;	1570				!--
;	1571				LOCAL
;	1572					index;
;	1573	
;	1574				index = .dbg$char_table[.char];
;	1575				IF ((.index GEQ table_offset) AND (.index LEQ operator_max))
;	1576				THEN
;	1577					BEGIN
;	1578					ch$wchar (.char, .lexeme_ptr);
;	1579					lexeme_stg_desc[dsc$w_length] = 1;
;	1580					input_stg_desc[dsc$a_pointer] = ch$plus (.input_ptr, 1);
;	1581					input_stg_desc[dsc$w_length] = .input_stg_desc[dsc$w_length] - 1;
;	1582					RETURN .dbg$token_table[.index - table_offset]
;	1583					END;
;	1584	
;	1585				!++
;	1586				! This doesn't seem to be anything about which
;	1587				! we know. SIGNAL invalid character.
;	1588				!--
;	1589				SIGNAL (dbg$_invchar);
;	1590				END;			! loop back to CASE statement.
;	1591	
;	1592			TES;
;	1593	
;	1594		END;					! end of dbg$for_get_lex


							    .TITLE  DBGFOR
							    .IDENT  \000025\

							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00000 P.AAA:  .LONG   -2147483648, 1367345156, 536870912, 100663296, 32768      ;
					      00014 P.AAB:  .BYTE   0, 1, 2, 3, 4					      ;
					      00019	    .BLKB   3

						    LEX_TYPE_TBL=	P.AAA
						    LEX_STATE_TBL=	P.AAB
							    .GLOBL  DBG$FAO_OUT, DBG$RADX_CONVRT, DBG$CHAR_TABLE, DBG$TOKEN_TABLE
							    .GLOBL  DBG$GB_DEF_MOD, DBG$GB_MOD_PTR, DBG$GL_GET_LEX

							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0FFC 00000 	    .ENTRY  DBG$FOR_GET_LEX, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 0953
		         5E	       20  C2 00002 	    SUBL2   #32, SP						      ;
		         57	  04   AC  D0 00005 	    MOVL    INPUT_STG_DESC, R7					      ; 1064
		    04   AE	  04   A7  9E 00009 	    MOVAB   4(R7), 4(SP)					      ; 1071

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8-1
; Digital Equipment Corporation
;
		         58	  04   BE  D0 0000E 	    MOVL    @4(SP), INPUT_PTR					      ;
		         59	  08   AC  D0 00012 	    MOVL    LEXEME_STG_DESC, R9					      ; 1072
		    08   AE	  04   A9  D0 00016 	    MOVL    4(R9), 8(SP)					      ;
		         5B	  08   AE  D0 0001B 	    MOVL    8(SP), LEXEME_PTR					      ;
		    18   AE 00000000G  FF  9A 0001F 	    MOVZBL  @DBG$GB_MOD_PTR, PREVIOUS_RADIX			      ; 1077
				  1C   AE  D4 00027 	    CLRL    SPECIAL_RADIX					      ; 1079
				       5A  D4 0002A 	    CLRL    COUNT						      ; 1080
		         56	       68  9A 0002C 1$:     MOVZBL  (INPUT_PTR), CHAR					      ; 1083
		         04 00000000GEF46  91 0002F 	    CMPB    DBG$CHAR_TABLE[CHAR], #4				      ; 1084
				       05  13 00037 	    BEQL    2$							      ;
		         67	       5A  A2 00039 	    SUBW2   COUNT, (R7)						      ; 1087
				       06  11 0003C 	    BRB     3$							      ; 1088
				       58  D6 0003E 2$:     INCL    INPUT_PTR						      ; 1092
				       5A  D6 00040 	    INCL    COUNT						      ; 1093
				       E8  11 00042 	    BRB     1$							      ; 1080
				       50  D4 00044 3$:     CLRL    STATE_INDEX						      ; 1107
	   51 00000000'EF40 00000000GEF46  78 00046 4$:     ASHL    DBG$CHAR_TABLE[CHAR], LEX_TYPE_TBL[STATE_INDEX], R1       ; 1110
				       0B  18 00054 	    BGEQ    5$							      ;
		    0C   AE 00000000'EF40  9A 00056 	    MOVZBL  LEX_STATE_TBL[STATE_INDEX], STATE			      ; 1113
				       0B  11 0005F 	    BRB     7$							      ; 1114
				       50  D6 00061 5$:     INCL    STATE_INDEX						      ; 1118
		         04	       50  D1 00063 	    CMPL    STATE_INDEX, #4					      ; 1119
				       DE  15 00066 	    BLEQ    4$							      ;
		    0C   AE	       05  D0 00068 6$:     MOVL    #5, STATE						      ; 1122
	   05	         00	  0C   AE  CF 0006C 7$:     CASEL   STATE, #0, #5					      ; 1133
	 00A2	       000F	     03A2     00071 8$:     .WORD   69$-8$,-						      ;
	 037A	       02FD	     02EF     00077		    9$-8$,-						      ;
								    20$-8$,-						      ;
								    61$-8$,-						      ;
								    62$-8$,-						      ;
								    68$-8$						      ;
				     0393  31 0007D 	    BRW     69$							      ; 1138
		         2E	       56  D1 00080 9$:     CMPL    CHAR, #46						      ; 1151
				       28  12 00083 	    BNEQ    11$							      ;
		         50	  01   A8  9A 00085 	    MOVZBL  1(INPUT_PTR), NEW_CHAR				      ; 1158
	   51 51800000   8F 00000000GEF40  78 00089 	    ASHL    DBG$CHAR_TABLE[NEW_CHAR], #1367343104, R1		      ; 1160
				       10  19 00096 	    BLSS    10$							      ; 1159
		         02 00000000GEF40  91 00098 	    CMPB    DBG$CHAR_TABLE[NEW_CHAR], #2			      ; 1163
				       C6  12 000A0 	    BNEQ    6$							      ;
		    0C   AE	       02  D0 000A2 	    MOVL    #2, STATE						      ; 1164
				       C4  11 000A6 	    BRB     7$							      ; 1163
		         51	       01  D0 000A8 10$:    MOVL    #1, PERIOD_PRESENT					      ; 1168
				       02  11 000AB 	    BRB     12$							      ; 1151
				       51  D4 000AD 11$:    CLRL    PERIOD_PRESENT					      ; 1170
				       5A  D4 000AF 12$:    CLRL    COUNT						      ; 1179
	      00000061   8F	       56  D1 000B1 13$:    CMPL    CHAR, #97						      ; 1183
				       03  1F 000B8 	    BLSSU   14$							      ;
		         56	       20  C2 000BA 	    SUBL2   #32, CHAR						      ; 1184
				       5A  D6 000BD 14$:    INCL    COUNT						      ; 1185
		         0F	       5A  D1 000BF 	    CMPL    COUNT, #15						      ; 1186
				       03  14 000C2 	    BGTR    15$							      ;
		         8B	       56  90 000C4 	    MOVB    CHAR, (LEXEME_PTR)+					      ; 1187
				       58  D6 000C7 15$:    INCL    INPUT_PTR						      ; 1188
		         56	       68  9A 000C9 	    MOVZBL  (INPUT_PTR), CHAR					      ;
	   50 71800000   8F 00000000GEF46  78 000CC 	    ASHL    DBG$CHAR_TABLE[CHAR], #1904214016, R0		      ; 1191

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8-2
; Digital Equipment Corporation
;
				       D6  19 000D9 	    BLSS    13$							      ; 1190
		         2E	       56  D1 000DB 	    CMPL    CHAR, #46						      ; 1199
				       0F  12 000DE 	    BNEQ    17$							      ;
		         0C	       51  E9 000E0 	    BLBC    PERIOD_PRESENT, 17$					      ;
				       5A  D6 000E3 	    INCL    COUNT						      ; 1202
		         0F	       5A  D1 000E5 	    CMPL    COUNT, #15						      ; 1203
				       03  14 000E8 	    BGTR    16$							      ;
		         6B	       56  90 000EA 	    MOVB    CHAR, (LEXEME_PTR)					      ; 1204
				       58  D6 000ED 16$:    INCL    INPUT_PTR						      ; 1205
		         0F	       5A  D1 000EF 17$:    CMPL    COUNT, #15						      ; 1208
				       12  15 000F2 	    BLEQ    18$							      ;
			    00028063   8F  DD 000F4 	    PUSHL   #163939						      ; 1211
	      00000000G  00	       01  FB 000FA 	    CALLS   #1, LIB$SIGNAL					      ;
		         69	       0F  B0 00101 	    MOVW    #15, (R9)						      ; 1212
				       03  11 00104 	    BRB     19$							      ; 1208
		         69	       5A  B0 00106 18$:    MOVW    COUNT, (R9)						      ; 1214
		    04   BE	       58  D0 00109 19$:    MOVL    INPUT_PTR, @4(SP)					      ; 1215
		         67	       5A  A2 0010D 	    SUBW2   COUNT, (R7)						      ; 1216
				     022B  31 00110 	    BRW     56$							      ; 1223
		         2E	       56  D1 00113 20$:    CMPL    CHAR, #46						      ; 1240
				       06  12 00116 	    BNEQ    21$							      ;
		    10   AE	       01  D0 00118 	    MOVL    #1, PERIOD_PRESENT					      ; 1241
				       03  11 0011C 	    BRB     22$							      ; 1240
				  10   AE  D4 0011E 21$:    CLRL    PERIOD_PRESENT					      ; 1242
				  14   AE  D4 00121 22$:    CLRL    FLOATING_FLAG					      ; 1243
				       5A  D4 00124 	    CLRL    COUNT						      ; 1253
		         0E	  10   AE  E8 00126 	    BLBS    PERIOD_PRESENT, 24$					      ; 1255
		         30	       56  D1 0012A 23$:    CMPL    CHAR, #48						      ; 1257
				       09  12 0012D 	    BNEQ    24$							      ;
				       5A  D6 0012F 	    INCL    COUNT						      ; 1260
				       58  D6 00131 	    INCL    INPUT_PTR						      ; 1261
		         56	       68  9A 00133 	    MOVZBL  (INPUT_PTR), CHAR					      ;
				       F2  11 00136 	    BRB     23$							      ; 1257
		         67	       5A  A2 00138 24$:    SUBW2   COUNT, (R7)						      ; 1268
				       5A  D4 0013B 	    CLRL    COUNT						      ; 1269
		         50 00000000GEF46  9E 0013D 	    MOVAB   DBG$CHAR_TABLE[CHAR], R0				      ; 1270
		         02	       60  91 00145 	    CMPB    (R0), #2						      ;
				       1F  13 00148 	    BEQL    25$							      ;
		         14	       60  91 0014A 	    CMPB    (R0), #20						      ; 1271
				       1A  13 0014D 	    BEQL    25$							      ;
		         62	  10   AE  E8 0014F 	    BLBS    PERIOD_PRESENT, 30$					      ; 1272
	   51 10800000   8F	       60  78 00153 	    ASHL    (R0), #276824064, R1				      ; 1273
				       0C  19 0015B 	    BLSS    25$							      ;
				       6B  94 0015D 	    CLRB    (LEXEME_PTR)					      ; 1282
		         69	       01  B0 0015F 	    MOVW    #1, (R9)						      ; 1283
		    04   BE	       58  D0 00162 	    MOVL    INPUT_PTR, @4(SP)					      ; 1284
				     01F2  31 00166 	    BRW     60$							      ; 1285
		         48	  10   AE  E8 00169 25$:    BLBS    PERIOD_PRESENT, 30$					      ; 1292
		         14	       60  91 0016D 	    CMPB    (R0), #20						      ;
				       43  13 00170 	    BEQL    30$							      ;
		         6E 00000000GEF46  9E 00172 	    MOVAB   DBG$CHAR_TABLE[CHAR], (SP)				      ; 1296
		         08	  00   BE  91 0017A 26$:    CMPB    @0(SP), #8						      ;
				       03  12 0017E 	    BNEQ    27$							      ;
		         56	       20  C2 00180 	    SUBL2   #32, CHAR						      ; 1297
				       5A  D6 00183 27$:    INCL    COUNT						      ; 1298

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8-3
; Digital Equipment Corporation
;
		         0B	       5A  D1 00185 	    CMPL    COUNT, #11						      ; 1299
				       10  15 00188 	    BLEQ    28$							      ;
	   7E	    08   AE	       01  C1 0018A 	    ADDL3   #1, 8(SP), -(SP)					      ; 1308
      08   BE	         9E	       0A  28 0018F 	    MOVC3   #10, @(SP)+, @8(SP)					      ;
		    FF   AB	       56  90 00194 	    MOVB    CHAR, -1(LEXEME_PTR)				      ; 1311
				       03  11 00198 	    BRB     29$							      ; 1299
		         8B	       56  90 0019A 28$:    MOVB    CHAR, (LEXEME_PTR)+					      ; 1313
				       58  D6 0019D 29$:    INCL    INPUT_PTR						      ; 1314
		         56	       68  9A 0019F 	    MOVZBL  (INPUT_PTR), CHAR					      ;
		         6E 00000000GEF46  9E 001A2 	    MOVAB   DBG$CHAR_TABLE[CHAR], (SP)				      ; 1324
	   50 30800000   8F	  00   BE  78 001AA 	    ASHL    @0(SP), #813694976, R0				      ;
				       C5  19 001B3 	    BLSS    26$							      ; 1323
		         2E	       56  D1 001B5 30$:    CMPL    CHAR, #46						      ; 1332
				       24  12 001B8 	    BNEQ    33$							      ;
		         20	  10   AE  E8 001BA 	    BLBS    PERIOD_PRESENT, 33$					      ; 1333
		    10   AE	       01  D0 001BE 	    MOVL    #1, PERIOD_PRESENT					      ; 1336
				       5A  D6 001C2 31$:    INCL    COUNT						      ; 1339
      08   A9	         10	       00  ED 001C4 	    CMPZV   #0, #16, 8(R9), COUNT				      ; 1340
				       5A     001C9									      ;
				       03  19 001CA 	    BLSS    32$							      ;
		         8B	       56  90 001CC 	    MOVB    CHAR, (LEXEME_PTR)+					      ; 1341
				       58  D6 001CF 32$:    INCL    INPUT_PTR						      ; 1342
		         56	       68  9A 001D1 	    MOVZBL  (INPUT_PTR), CHAR					      ;
		         02 00000000GEF46  91 001D4 	    CMPB    DBG$CHAR_TABLE[CHAR], #2				      ; 1344
				       E4  13 001DC 	    BEQL    31$							      ;
		         4D	  1C   AE  E9 001DE 33$:    BLBC    SPECIAL_RADIX, 39$					      ; 1352
		         49	  10   AE  E8 001E2 	    BLBS    PERIOD_PRESENT, 39$					      ;
		         27	       56  D1 001E6 	    CMPL    CHAR, #39						      ; 1362
				       42  12 001E9 	    BNEQ    38$							      ;
		         56	  01   A8  9A 001EB 	    MOVZBL  1(INPUT_PTR), CHAR					      ; 1365
		         07 00000000GEF46  91 001EF 	    CMPB    DBG$CHAR_TABLE[CHAR], #7				      ; 1366
				       03  12 001F7 	    BNEQ    34$							      ;
		         56	       20  C2 001F9 	    SUBL2   #32, CHAR						      ; 1367
	      0000004F   8F	       56  D1 001FC 34$:    CMPL    CHAR, #79						      ; 1368
				       09  12 00203 	    BNEQ    35$							      ;
	      00000000G  FF	       08  90 00205 	    MOVB    #8, @DBG$GB_MOD_PTR					      ; 1370
				       19  11 0020C 	    BRB     37$							      ; 1368
	      00000058   8F	       56  D1 0020E 35$:    CMPL    CHAR, #88						      ;
				       09  12 00215 	    BNEQ    36$							      ;
	      00000000G  FF	       10  90 00217 	    MOVB    #16, @DBG$GB_MOD_PTR				      ; 1371
				       07  11 0021E 	    BRB     37$							      ; 1368
	      00000000G  FF	       0A  90 00220 36$:    MOVB    #10, @DBG$GB_MOD_PTR				      ; 1372
		         58	       02  C0 00227 37$:    ADDL2   #2, INPUT_PTR					      ; 1374
		         67	       02  A2 0022A 	    SUBW2   #2, (R7)						      ; 1375
				       7D  11 0022D 38$:    BRB     51$							      ; 1352
	      00000061   8F	       56  D1 0022F 39$:    CMPL    CHAR, #97						      ; 1386
				       03  1F 00236 	    BLSSU   40$							      ;
		         56	       20  C2 00238 	    SUBL2   #32, CHAR						      ; 1387
				       50  D4 0023B 40$:    CLRL    R0							      ; 1388
	      00000044   8F	       56  D1 0023D 	    CMPL    CHAR, #68						      ;
				       04  12 00244 	    BNEQ    41$							      ;
				       50  D6 00246 	    INCL    R0							      ;
				       09  11 00248 	    BRB     42$							      ;
	      00000045   8F	       56  D1 0024A 41$:    CMPL    CHAR, #69						      ;
				       17  12 00251 	    BNEQ    45$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8-4
; Digital Equipment Corporation
;
		         06	       50  E9 00253 42$:    BLBC    R0, 43$						      ; 1391
		    14   AE	       03  D0 00256 	    MOVL    #3, FLOATING_FLAG					      ; 1392
				       04  11 0025A 	    BRB     44$							      ; 1391
		    14   AE	       01  D0 0025C 43$:    MOVL    #1, FLOATING_FLAG					      ; 1393
		         8B	       56  90 00260 44$:    MOVB    CHAR, (LEXEME_PTR)+					      ; 1400
				       5A  D6 00263 	    INCL    COUNT						      ; 1401
				       58  D6 00265 	    INCL    INPUT_PTR						      ; 1402
		         56	       68  9A 00267 	    MOVZBL  (INPUT_PTR), CHAR					      ;
		         1C	  10   AE  E9 0026A 45$:    BLBC    PERIOD_PRESENT, 48$					      ; 1404
		         14	  14   AE  E9 0026E 	    BLBC    FLOATING_FLAG, 47$					      ;
		         2B	       56  D1 00272 	    CMPL    CHAR, #43						      ; 1407
				       05  13 00275 	    BEQL    46$							      ;
		         2D	       56  D1 00277 	    CMPL    CHAR, #45						      ;
				       0A  12 0027A 	    BNEQ    47$							      ;
		         8B	       56  90 0027C 46$:    MOVB    CHAR, (LEXEME_PTR)+					      ; 1410
				       5A  D6 0027F 	    INCL    COUNT						      ; 1411
				       58  D6 00281 	    INCL    INPUT_PTR						      ; 1412
		         56	       68  9A 00283 	    MOVZBL  (INPUT_PTR), CHAR					      ;
		         04	  10   AE  E8 00286 47$:    BLBS    PERIOD_PRESENT, 49$					      ; 1415
		         1E	  14   AE  E9 0028A 48$:    BLBC    FLOATING_FLAG, 51$					      ;
		         02 00000000GEF46  91 0028E 49$:    CMPB    DBG$CHAR_TABLE[CHAR], #2				      ; 1416
				       14  12 00296 	    BNEQ    51$							      ;
				       5A  D6 00298 	    INCL    COUNT						      ; 1419
      08   A9	         10	       00  ED 0029A 	    CMPZV   #0, #16, 8(R9), COUNT				      ; 1420
				       5A     0029F									      ;
				       03  19 002A0 	    BLSS    50$							      ;
		         8B	       56  90 002A2 	    MOVB    CHAR, (LEXEME_PTR)+					      ; 1421
				       58  D6 002A5 50$:    INCL    INPUT_PTR						      ; 1422
		         56	       68  9A 002A7 	    MOVZBL  (INPUT_PTR), CHAR					      ;
				       E2  11 002AA 	    BRB     49$							      ; 1416
		         69	       5A  B0 002AC 51$:    MOVW    COUNT, (R9)						      ; 1444
		         38	  10   AE  E8 002AF 	    BLBS    PERIOD_PRESENT, 52$					      ; 1445
		         34	  14   AE  E8 002B3 	    BLBS    FLOATING_FLAG, 52$					      ;
		         50 00000000G  EF  D0 002B7 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 1446
		         01	  07   A0  91 002BE 	    CMPB    7(R0), #1						      ;
				       27  13 002C2 	    BEQL    52$							      ;
		         50 00000000G  EF  D0 002C4 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 1447
		         02	  07   A0  91 002CB 	    CMPB    7(R0), #2						      ;
				       1A  13 002CF 	    BEQL    52$							      ;
				       59  DD 002D1 	    PUSHL   R9							      ; 1450
	      00000000G  EF	       01  FB 002D3 	    CALLS   #1, DBG$RADX_CONVRT					      ;
		    08   BE	       50  D0 002DA 	    MOVL    R0, @8(SP)						      ;
	      00000000G  FF	  18   AE  90 002DE 	    MOVB    PREVIOUS_RADIX, @DBG$GB_MOD_PTR			      ; 1451
		         69	       04  B0 002E6 	    MOVW    #4, (R9)						      ; 1452
				       19  11 002E9 	    BRB     53$							      ; 1445
      08   A9	         10	       00  ED 002EB 52$:    CMPZV   #0, #16, 8(R9), COUNT				      ; 1462
				       5A     002F0									      ;
				       11  18 002F1 	    BGEQ    53$							      ;
		         69	  08   A9  B0 002F3 	    MOVW    8(R9), (R9)						      ; 1465
			    0002805B   8F  DD 002F7 	    PUSHL   #163931						      ; 1466
	      00000000G  00	       01  FB 002FD 	    CALLS   #1, LIB$SIGNAL					      ;
		    04   BE	       58  D0 00304 53$:    MOVL    INPUT_PTR, @4(SP)					      ; 1470
		         67	       5A  A2 00308 	    SUBW2   COUNT, (R7)						      ; 1471
		         50 00000000G  EF  D0 0030B 	    MOVL    DBG$GB_MOD_PTR, R0					      ; 1479
		         01	  07   A0  91 00312 	    CMPB    7(R0), #1						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8-5
; Digital Equipment Corporation
;
				       06  13 00316 	    BEQL    54$							      ;
		         02	  07   A0  91 00318 	    CMPB    7(R0), #2						      ; 1480
				       25  12 0031C 	    BNEQ    57$							      ;
	   60	         08	       00  ED 0031E 54$:    CMPZV   #0, #8, (R0), PREVIOUS_RADIX			      ; 1483
				  18   AE     00322									      ;
				       04  12 00324 	    BNEQ    55$							      ;
		         14	  10   AE  E9 00326 	    BLBC    PERIOD_PRESENT, 56$					      ; 1484
				       59  DD 0032A 55$:    PUSHL   R9							      ; 1487
				       01  DD 0032C 	    PUSHL   #1							      ;
			    000281D0   8F  DD 0032E 	    PUSHL   #164304						      ;
	      00000000G  00	       03  FB 00334 	    CALLS   #3, LIB$SIGNAL					      ;
				     00E5  31 0033B 	    BRW     71$							      ; 1488
		         50	  49   8F  9A 0033E 56$:    MOVZBL  #73, R0						      ; 1490
					   04 00342 	    RET     							      ;
		         03	  14   AE  D1 00343 57$:    CMPL    FLOATING_FLAG, #3					      ; 1492
				       05  12 00347 	    BNEQ    58$							      ;
		         50	  42   8F  9A 00349 	    MOVZBL  #66, R0						      ; 1493
					   04 0034D 	    RET     							      ;
		         04	  14   AE  E8 0034E 58$:    BLBS    FLOATING_FLAG, 59$					      ; 1494
		         05	  10   AE  E9 00352 	    BLBC    PERIOD_PRESENT, 60$					      ;
		         50	  55   8F  9A 00356 59$:    MOVZBL  #85, R0						      ; 1495
					   04 0035A 	    RET     							      ;
		         50	  4B   8F  9A 0035B 60$:    MOVZBL  #75, R0						      ; 1496
					   04 0035F 	    RET     							      ;
				       69  B4 00360 61$:    CLRW    (R9)						      ; 1507
      04   BE	         58	       01  C1 00362 	    ADDL3   #1, INPUT_PTR, @4(SP)				      ; 1508
				       67  B7 00367 	    DECW    (R7)						      ; 1509
		         50	  63   8F  9A 00369 	    MOVZBL  #99, R0						      ; 1510
					   04 0036D 	    RET     							      ;
	   50	         58	       01  C1 0036E 62$:    ADDL3   #1, INPUT_PTR, TEMP_PTR				      ; 1527
		         56	       80  9A 00372 	    MOVZBL  (TEMP_PTR)+, CHAR					      ; 1528
	   51 30800000   8F 00000000GEF46  78 00375 	    ASHL    DBG$CHAR_TABLE[CHAR], #813694976, R1		      ; 1530
				       4A  18 00382 	    BGEQ    66$							      ; 1529
		         56	       80  9A 00384 63$:    MOVZBL  (TEMP_PTR)+, CHAR					      ; 1534
	   51 02008000   8F 00000000GEF46  78 00387 	    ASHL    DBG$CHAR_TABLE[CHAR], #33587200, R1			      ; 1535
				       EE  18 00394 	    BGEQ    63$							      ;
		         10 00000000GEF46  91 00396 	    CMPB    DBG$CHAR_TABLE[CHAR], #16				      ; 1536
				       2E  12 0039E 	    BNEQ    66$							      ;
		         56	       60  9A 003A0 	    MOVZBL  (TEMP_PTR), CHAR					      ; 1539
	      00000061   8F	       56  D1 003A3 	    CMPL    CHAR, #97						      ; 1540
				       03  1F 003AA 	    BLSSU   64$							      ;
		         56	       20  C2 003AC 	    SUBL2   #32, CHAR						      ; 1541
	      0000004F   8F	       56  D1 003AF 64$:    CMPL    CHAR, #79						      ; 1542
				       12  13 003B6 	    BEQL    65$							      ;
	      00000058   8F	       56  D1 003B8 	    CMPL    CHAR, #88						      ;
				       09  13 003BF 	    BEQL    65$							      ;
	      00000044   8F	       56  D1 003C1 	    CMPL    CHAR, #68						      ; 1543
				       04  12 003C8 	    BNEQ    66$							      ;
		    0C   AE	       02  D0 003CA 65$:    MOVL    #2, STATE						      ; 1544
		         02	  0C   AE  D1 003CE 66$:    CMPL    STATE, #2						      ; 1547
				       11  12 003D2 	    BNEQ    67$							      ;
				       58  D6 003D4 	    INCL    INPUT_PTR						      ; 1550
		         56	       68  9A 003D6 	    MOVZBL  (INPUT_PTR), CHAR					      ;
		    04   BE	       58  D0 003D9 	    MOVL    INPUT_PTR, @4(SP)					      ; 1551
				       67  B7 003DD 	    DECW    (R7)						      ; 1552

; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 8-6
; Digital Equipment Corporation
;
		    1C   AE	       01  D0 003DF 	    MOVL    #1, SPECIAL_RADIX					      ; 1553
				       3B  11 003E3 	    BRB     70$							      ; 1547
		         56	       68  9A 003E5 67$:    MOVZBL  (INPUT_PTR), CHAR					      ; 1557
				     FC7D  31 003E8 	    BRW     6$							      ; 1558
		         50 00000000GEF46  9A 003EB 68$:    MOVZBL  DBG$CHAR_TABLE[CHAR], INDEX				      ; 1574
		         09	       50  D1 003F3 	    CMPL    INDEX, #9						      ; 1575
				       1B  19 003F6 	    BLSS    69$							      ;
		         1D	       50  D1 003F8 	    CMPL    INDEX, #29						      ;
				       16  14 003FB 	    BGTR    69$							      ;
		         6B	       56  90 003FD 	    MOVB    CHAR, (LEXEME_PTR)					      ; 1578
		         69	       01  B0 00400 	    MOVW    #1, (R9)						      ; 1579
      04   BE	         58	       01  C1 00403 	    ADDL3   #1, INPUT_PTR, @4(SP)				      ; 1580
				       67  B7 00408 	    DECW    (R7)						      ; 1581
		         50 00000000GEF40  9A 0040A 	    MOVZBL  DBG$TOKEN_TABLE-9[INDEX], R0			      ; 1582
					   04 00412 	    RET     							      ;
			    000281B8   8F  DD 00413 69$:    PUSHL   #164280						      ; 1589
	      00000000G  00	       01  FB 00419 	    CALLS   #1, LIB$SIGNAL					      ;
				     FC49  31 00420 70$:    BRW     7$							      ; 1130
				       50  D4 00423 71$:    CLRL    R0							      ; 0953
					   04 00425 	    RET     							      ;

; Routine Size:  1062 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:36:20	DBB3:[DEBUG.SRC]DBGFOR.B32;5					Page 9
; Digital Equipment Corporation
;
;	1595	END							! End of module
;	1596	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  DBG$PLIT       	    28  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  DBG$CODE       	  1062  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582         6         0       223






;			COMPILER INTERNAL TIMING

;	Phase	    Faults	Cpu-time      Elapsed-time
;	LEXSYN	      900	00:24.0		00:27.9
;	FLOWAN	       23	00:04.7		00:04.7
;	DELAY	       25	00:01.9		00:01.9
;	TNBIND	       29	00:03.0		00:03.0
;	CODE	       48	00:05.8		00:05.8
;	FINAL	      104	00:06.2		00:06.4
;	Total	     1129	00:45.4		00:49.6

; Size:		1062 code + 28 data bytes
; Run Time:	00:45.8
; Elapsed Time:	00:50.1
; Memory Used:	566 pages
; Compilation Complete
