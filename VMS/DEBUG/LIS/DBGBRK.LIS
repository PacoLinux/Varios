
; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DBGBRK ( ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE),
;	0002			IDENT = '000061') =
;	0003	BEGIN
;	0004	
;	0005	! Copyright (C) 1976
;	0006	! Digital Equipment Corporation, Maynard, Massachusetts 01755
;	0007	!
;	0008	! This software is furnished under a license for use only on a
;	0009	! single computer system and may be copied only with the inclusion
;	0010	! of the above copyright notice. This software, or any
;	0011	! other copies thereof, may not be provided or otherwise made
;	0012	! available to any other person except for use on such system
;	0013	! and to one who agrees to these license terms. Title to and
;	0014	! ownership of the software shall at all times remain in DEC.
;	0015	!
;	0016	! The information in this software is subject to change without
;	0017	! notice and should not be construed as a commitment by Digital
;	0018	! Equipment Corporation.
;	0019	!
;	0020	! DEC assumes no responsibility for the use or reliability of
;	0021	! its software on equipment which is not supplied by DEC.
;	0022	!
;	0023	! FACILITY:	DEBUG
;	0024	!
;	0025	!++
;	0026	! FUNCTIONAL DESCRIPTION:
;	0027	!	BREAK ACTION ROUTINES FOR VAX DEBUG FACILITY
;	0028	!
;	0029	! Version:	61
;	0030	!
;	0031	! History:
;	0032	!	Author:
;	0033	!		Carol Peters, 26 Jul 1976: Version 01
;	0034	!
;	0035	!	Modified by:
;	0036	!		Dale Roedger, 06 July 1978:	61
;	0037	!
;	0038	! Revision history:
;	0039	!	24	14-03-77	CP	put fixed character strings in FAO control strings.
;	0040	!					rewrote SHOW_BPTS and SAVE_BPT to be shorter.
;	0041	!					added code to REM_OPCODES to check
;	0042	!					for changed opcode at breakpoint address.
;	0043	!	25	30-03-77	CP	delete routine DBG$ASETBRA. put code directly
;	0044	!					in parser. eliminate all traces of enabling
;	0045	!					and disabling. this removes macros to enable
;	0046	!					or disable a breakpoint, changes switch_break
;	0047	!					to act only if cancel bit is set. also
;	0048	!					simplifies SWITCH_BPT and SAVE_BPT.
;	0049	!					change check for ON_TOKEN in SETBRE
;	0050	!					to check for EXCEPTION_TOKEN.
;	0051	!	26	31-03-77	CP	fix bug in ASETBRE. the EXCEPTION_TOKEN
;	0052	!					is located at SEMSP + 1, not + 2.
;	0053	!					moved ABREACB, ABREACE, and ASETBRE
;	0054	!					into DBGACT because they are language
;	0055	!					dependent.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 1-1
; Digital Equipment Corporation
;
;	0056	!	27	20-04-77	CP	Change VAXDEB.BEG to be named
;	0057	!					DBGGEN.BEG. Also, add DBGPCT.BEG
;	0058	!					for PSECT declarations.
;	0059	!	28	29-04-77	CP	Remove setting of DBG$GB_PARS_MOR
;	0060	!					in SAVE_BPT since it is
;	0061	!					unnecessary.
;	0062	!	29	04-05-77	CP	Rewrite SWITCH_BPT to tell user
;	0063	!					if the user to be switched does
;	0064	!					not exist. Also, modify the
;	0065	!					switch_break macro to have 
;	0066	!					a begin-end block surrounding it
;	0067	!					so that the
;	0068	!					IF THEN clause minus the ELSE
;	0069	!					does not expand strangely according
;	0070	!					to its surroundings.
;	0071	!	30	16-may-77	KGP	-Changed call to WRITE_MEM now that
;	0072	!					 we have redefined the calling
;	0073	!					 sequence for DEPositing Instructions.
;	0074	!	31	23-06-77	CP	When accessing the contents of
;	0075	!					a break location, must check
;	0076	!					read access protection before
;	0077	!					the access. Include call to
;	0078	!					DBG$READ_ACCESS for this check.
;	0079	!	32	29-07-77	CP	Modify SHOW_BPTS and SWITCH_BPT
;	0080	!					to distinguish between tracepoints
;	0081	!					and breakpoints. If the TRACE 
;	0082	!					context bit is set, only show
;	0083	!					or cancel appropriate tracepoints,
;	0084	!					and similarly for breakpoints.
;	0085	!	33	18-aug-77	KGP	-Changed the READ access check in
;	0086	!					DBG$SAVE_BPT to first do a read check,
;	0087	!					and then a write check so that
;	0088	!					we find out about not actually being
;	0089	!					able to write BPTs before it is too late.
;	0090	!	34	10-10-77	CP	Change calls to error_reprt
;	0091	!					to SIGNALs. Change init_break,
;	0092	!					ins_opcodes, and rem_opcodes
;	0093	!					to NOVALUE routines.
;	0094	!	35	27-10-77	CP	In call to read_access, just let
;	0095	!					it SIGNAL on failure.
;	0096	!	36	02-11-77	CP	Remove dbg$gb_bpt_ok.
;	0097	!	37	07-11-77	CP	Change names of context bits.
;	0098	!	38	8-nov-77	KGP	-Change SHO_BPTS to use standard
;	0099	!					 DEBUG I/O, and to announce BRKs/TRACEs
;	0100	!					 symbolically.
;	0101	!	39	22-nov-77	KGP	-Sho Breaks now prints out the BPT
;	0102	!					 action buffer as well as the address.
;	0103	!	40	23-11-77	CP	When setting a breakpoint, adjust
;	0104	!					the location to be after the entry
;	0105	!					mask if it is a FORTRAN routine.
;	0106	!	41	29-11-77	CP	When setting a breakpoint, set
;	0107	!					dbg$gl_last_loc (".") as well.
;	0108	!	42	21-12-77	CP	Add watchpoint functionality.
;	0109	!					Add routine dbg$find_watch.
;	0110	!					Add protection setting to ins_

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 1-2
; Digital Equipment Corporation
;
;	0111	!					and rem_opcodes.
;	0112	!	43	6-jan-77	KGP	-Small change to SHOW_BPTS so that
;	0113	!					 watchpoints tell their length.
;	0114	!	44	02-MAR-78	DAR	Removed extra CRLF directives from FAO
;	0115	!					control strings.
;	0116	!	45	02-mar-78	KGP	-Fixed bug in calculating Watch
;	0117	!					 point range for array elements.
;	0118	!					 New routine  IS_ARRAY_ELEM.
;	0119	!	46	03-mar-78	KGP	-SWITCH_BRK routine now gets the
;	0120	!					 error code right when the watch/
;	0121	!					 trace/break point does not exist.
;	0122	!	47	09-MAR-78	DAR	DBG$REM_OPCODES now has a parameter
;	0123	!					that holds the address of a location
;	0124	!					where the BPT is not to be restored.
;	0125	!	48	23-mar-78	KGP	-SET B on an entry point or routine
;	0126	!					 in any language now gets you the BPT
;	0127	!					 after the entry mask.  SHO B also
;	0128	!					 differentiates how it tells you
;	0129	!					 about the routine/not-routine BPTs.
;	0130	!	49	06-APR-78	DAR	Removed context bit dbg$k_read and
;	0131	!					added routine DBG$CANCEL_BPT.
;	0132	!	50	06-apr-78	KGP	-SHOW_BPTs now knows about /AFTER 
;	0133	!					 and doesn't print spurious blank lines
;	0134	!					 (an old bug)
;	0135	!	51	13-apr-78	KGP	-SWITCH_BPTs has now gone away,
;	0136	!					 (dale added CANCEL_BPT a while ago),
;	0137	!					 and SAVE_BPT now properly picks
;	0138	!					 up the /AFTER count.
;	0139	!	52	18-apr-78	KGP	-SET WAtch now knows about so-called
;	0140	!					 'protected areas' - those which we
;	0141	!					 can't allow a user to WATCH lest we
;	0142	!					 allow DEBUG to cause itself to fault.
;	0143	!	53	20-apr-78	KGP	-When the call to SAVE_BPT is made to
;	0144	!					 set 'internal' breakpoints (/AFTER:0
;	0145	!					 ones for STEP /OVER), then we
;	0146	!					 should not change DBG$GL_LAST_LOC since
;	0147	!					 these breaks should not be seen by the
;	0148	!					 user.
;	0149	!	54	21-apr-78	KGP	-Added range check on the /after count
;	0150	!	55	27-APR-78	DAR	Modified the require and library directives
;	0151	!					for the native build.
;	0152	!	56	04-may-78	KGP	-The /AFTER count is always set to
;	0153	!					 1 for tracepoints.  This is necessary
;	0154	!					 because Breakpoints and Tracepoints
;	0155	!					 share a lot of common handling code.
;	0156	!	57	11-may-78	KGP	-SHOW_BPTS now knows about reporting
;	0157	!					 on opcode traces (for SHOW TRACE)
;	0158	!	58	17-MAY-78	DAR	The signal for watching a protected address
;	0159	!					now excludes P1 space entirely.
;	0160	!	59	19-JUN-78	DAR	Clean up DBG$SHOW_BPTS.
;	0161	!	60	20-JUN-78	DAR	DBG$INS_OPCODES and DBG$REM_OPCODES
;	0162	!					now load the "step over" breakpoint from
;	0163	!					the runframe.
;	0164	!	61	06-JUL-78	DAR	The watchpoint length is now stored as
;	0165	!					the length - 1. The size is the length

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 1-3
; Digital Equipment Corporation
;
;	0166	!					of the "typed" variable or "mode_length"
;	0167	!					bytes.
;	0168	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 2
; Digital Equipment Corporation
;
;	0169	! TABLE OF CONTENTS
;	0170	!--
;	0171	FORWARD ROUTINE
;	0172		dbg$find_bpt,				! ROUTINE TO FIND A BREAKPOINT IN TABLES
;	0173		dbg$find_watch,				! routine to identify a watchpoint
;	0174		dbg$init_break : NOVALUE,		! ROUTINE TO INITIALIZE BREAKPOINT AREA
;	0175		dbg$ins_opcodes : NOVALUE,		! INSERTS AN OPCODE FOR A BPT
;	0176		dbg$rem_opcodes : NOVALUE,		! REMOVES ALL BREAKPOINTED OPCODES FOR BREAKPOINTS
;	0177		dbg$save_bpt : NOVALUE,			! ROUTINE TO SET A BREAKPOINT location
;	0178		dbg$show_bpts : NOVALUE,		! ROUTINE TO SHOW BREAKPOINTS
;	0179		is_array_elem,				! calculate array element bounds.
;	0180							! Compilied out for release 1.
;	0181		dbg$cancel_bpt : NOVALUE;		! Routine to cancel breakpoints,
;	0182							! watchpoints, and tracepoints.
;	0183	
;	0184	!
;	0185	! Require files:
;	0186	!
;	0187	%IF %VARIANT		! True for TEN
;     L 0188	%THEN
;     U 0189	LIBRARY 'NEW:STARLE';
;     U 0190	
;     U 0191	REQUIRE 'DBGPCT.REQ';
;     U 0192	REQUIRE 'DBGGEN.REQ';
;     U 0193	REQUIRE 'VXSMAC.REQ';
;     U 0194	REQUIRE 'DBGMSG.REQ';
;     U 0195	REQUIRE 'SCALIT.REQ';
;     U 0196	REQUIRE 'VXPALT.REQ';
;     U 0197	REQUIRE 'BSTRUC.REQ';
;     U 0198	REQUIRE 'DLLNAM.REQ';
;     U 0199	REQUIRE 'SYSLIT.REQ';
;     U 0200	REQUIRE 'DBGRST.REQ';
;     U 0201	REQUIRE 'SYSSER.REQ';
;     U 0202	%ELSE
;	0203	LIBRARY 'SYS$LIBRARY:STARLET.L32';
;	0204	
;	0205	REQUIRE 'SRC$:DBGPCT.REQ';
;	0217	REQUIRE 'SRC$:DBGGEN.REQ';
;	0467	REQUIRE 'SRC$:VXSMAC.REQ';
;	0507	REQUIRE 'LIB$:DBGMSG.REQ';
;	0786	REQUIRE 'SRC$:SCALIT.REQ';
;	0824	REQUIRE 'SRC$:VXPALT.REQ';
;	0848	REQUIRE 'SRC$:BSTRUC.REQ';
;	0899	REQUIRE 'SRC$:DLLNAM.REQ';
;	0950	REQUIRE 'SRC$:SYSLIT.REQ';
;	0973	REQUIRE 'SRC$:DBGRST.REQ';
;	2120	REQUIRE 'SRC$:SYSSER.REQ';
;      R2123	SWITCHES LIST (SOURCE);
;      R2124	
;      R2125	EXTERNAL ROUTINE
;      R2126		dbg$fao_out;				! formats a line and outputs to the terminal
;      R2127	
;      R2128	SWITCHES LIST (NOSOURCE);
;	2173	%FI
;	2174	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 2-1
; Digital Equipment Corporation
;
;	2175	EXTERNAL ROUTINE
;	2176		dbg$sho_optrace,			! Report on opcode tracing
;	2177		dbg$symbol_valu,			! Evaluate symbols based on NT_PTRs.
;	2178		dbg$fao_put : NOVALUE,			! Standard DEBUG I/O formatter.
;	2179		dbg$freerelease,			! ROUTINE TO RELEASE STORAGE 
;	2180		dbg$freez,				! ROUTINE TO GET AND ZERO A BLOCK OF STORAGE
;	2181		dbg$is_it_entry,			! sees whether an address is bound to
;	2182							! a routine or entry point.
;	2183		dbg$out_put : NOVALUE,			! Standard DEBUG I/O flush.
;	2184		dbg$out_sym_val : NOVALUE,		! output values (symbolically)
;	2185		dbg$out_num_val : NOVALUE,		! output values (as numbers)
;	2186		dbg$read_access,			! checks read access protection
;	2187		dbg$val_to_sat,				! translates an absolute address to a SAT pointer
;	2188		dbg$write_mem;				! ROUTINE TO WRITE TO USER'S MEMORY
;	2189	
;	2190	EXTERNAL
;	2191		dbg$gl_runframe : ref block[,byte],	! Current saved set of regs, etc.
;	2192		dbg$cp_out_str : VECTOR[,BYTE],		! Needed for standard DEBUG I/O
;	2193		dbg$gb_mod_ptr	: REF VECTOR [, BYTE],	! pointer to current mode settings
;	2194		dbg$gl_bpthead,				! HEADER LINK IN BREAKPOINT CHAIN
;	2195		dbg$gl_buf_siz,				!   ditto
;	2196		dbg$gl_context: BITVECTOR,		! CONTEXT DESCRIPTOR WORD
;	2197		dbg$gl_last_loc,			! last location referenced by user
;	2198		dbg$gl_list: VECTOR;			! LINKED LIST FOR EXPRESSIONS
;	2199	
;	2200	BUILTIN
;	2201		INSQUE,
;	2202		REMQUE;
;	2203	
;	2204	LITERAL
;	2205		bytes_per_page	= %X'200';
;	2206	
;	2207	LITERAL
;	2208		dbg_brk		= 0,			! for debugging
;	2209		dbg_brk1	= 0,			! ditto
;	2210		dbg_brk2	= 0;			! for debugging watch

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 3
; Digital Equipment Corporation
;
;	2211	!++
;	2212	! The following diagram is of a breakpoint, tracepoint, or watchpoint
;	2213	! entry. The picture is one word wide and twelve words long.
;	2214	!--
;	2215	!
;	2216	!	!---------------------------------------!
;	2217	!	!					!
;	2218	!	!		right link		!
;	2219	!	!					!
;	2220	!	!---------------------------------------!
;	2221	!	!					!
;	2222	!	!		left link		!
;	2223	!	!					!
;	2224	!	!---------------------------------------!
;	2225	!	!					!
;	2226	!	!	address of ?????-point		!
;	2227	!	!					!
;	2228	!	!---------------------------------------!
;	2229	!	!		after count		!
;	2230	!	!---------------------------------------!
;	2231	!	!	byte count of action buffer	!
;	2232	!	!---------------------------------------!
;	2233	!	!	radix	    !	    length	!
;	2234	!	!---------------------------------------!
;	2235	!	! opcode / protect  ! accs ! type ! rt  !
;	2236	!	!---------------------------------------!
;	2237	!	!					!
;	2238	!	!	action buffer address		!
;	2239	!	!					!
;	2240	!	!---------------------------------------!
;	2241	!
;	2242	! The two counts (byte count and after count) are each 16 bits long.
;	2243	!	The byte count of the action buffer is the number of characters
;	2244	!	in the buffer.
;	2245	!	The after count is the number of times the break/trace/watchpoint
;	2246	!	is to be encountered before halting or reporting.
;	2247	!
;	2248	! The opcode, radix, and length fields are each a byte long.
;	2249	!	The opcode is the opcode at the address of the breakpoint.
;	2250	!	The radix is the radix in which the address was input (not implemented).
;	2251	!	The length is the length of the field to be watched.
;	2252	!
;	2253	! The protection field is actually two four bit fields. They are the
;	2254	!	original protections of the beginning and end bytes of the
;	2255	!	watchpoint.
;	2256	!
;	2257	! The accs, type, and routine fields are each one or two bits long.
;	2258	! Only access and type are implemented.
;	2259	!	The access field tells whether the halt is for write access, read/write
;	2260	!		access, or execute access.
;	2261	!	The type field tells whether the halt is a breakpoint, tracepoint,
;	2262	!		or watchpoint.
;	2263	!	The routine bit indicates that the breakpoint is on a routine name.
;	2264	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 4
; Digital Equipment Corporation
;
;	2265	!++
;	2266	! macros to manipulate breakpoints
;	2267	!--
;	2268	MACRO
;	2269		!++
;	2270		! free_a_breakpt releases the storage for one breakpoint or
;	2271		! tracepoint.
;	2272		!--
;	2273		free_a_breakpt (pointer) =
;     M 2274			BEGIN
;     M 2275	
;     M 2276			!++
;     M 2277			! IF THE BREAKPOINT HAS AN ACTION BUFFER, THEN FREE THE
;     M 2278			! STORAGE FOR THAT BUFFER BEFORE REMOVING THE LINK IN THE
;     M 2279			! BREAKPOINT CHAIN. THE bpt_acnt HOLDS THE LENGTH OF THE ACTION
;     M 2280			! BUFFER IN BYTES NOT INCLUDING THE COUNT BYTE.
;     M 2281			!--
;     M 2282			LOCAL
;     M 2283				dummy_loc;
;     M 2284	
;     M 2285			IF .bpt_aptr (pointer) NEQ 0
;     M 2286			THEN dbg$freerelease (.bpt_aptr (pointer), (.bpt_acnt (pointer) + 1) / %UPVAL + 1);
;     M 2287			IF NOT REMQUE (pointer, dummy_loc)
;     M 2288			THEN dbg$freerelease (pointer, overhead_bpt)
;     M 2289			ELSE
;     M 2290				BEGIN
;     M 2291	%IF dbg_brk
;     M 2292	%THEN
;     M 2293				$fao_tt_out ('link not removed, queue empty');
;     M 2294	%FI
;     M 2295				END;
;     M 2296			END%;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 5
; Digital Equipment Corporation
;
;	2297	GLOBAL ROUTINE dbg$find_bpt (address) =
;	2298	!++
;	2299	! Functional description:
;	2300	!	SEARCHES THE ENTIRE BREAKPOINT TABLE FOR A BREAKPOINT.
;	2301	!	RETURNS A pointer TO THE BREAKPOINT, ZERO IF NONE FOUND.
;	2302	!
;	2303	! Input parameters:
;	2304	!	address		- address OF BREAKPOINT TO FIND
;	2305	!
;	2306	! Implicit inputs:
;	2307	!	dbg$gl_bpthead, THE HEADER LINK IN THE BREAKPOINT CHAIN
;	2308	!
;	2309	! Output parameters:
;	2310	!	address OF BREAKPOINT entry FOR THIS BREAKPOINT, OR ZERO
;	2311	!	IF BREAKPOINT IS NOT FOUND.
;	2312	!
;	2313	! Implicit outputs:
;	2314	!	NONE
;	2315	!
;	2316	! Routine value:
;	2317	!	address OF BREAKPOINT entry OR ZERO
;	2318	!
;	2319	! Side effects:
;	2320	!	NONE
;	2321	!--
;	2322	
;	2323		BEGIN
;	2324	
;	2325		LOCAL
;	2326			entry;
;	2327	
;	2328		entry = .dll_rlink (.dbg$gl_bpthead);
;	2329	
;	2330		!+
;	2331		! Look at each entry in the breakpoint chain except the header link
;	2332		! to see whether the address of the breakpoint matches the address
;	2333		! passed to this routine. If it does, then return the pointer
;	2334		! to the breakpoint entry. Otherwise, exit
;	2335		! the loop when the address of an entry is the address of the
;	2336		! header link.
;	2337		!-
;	2338		WHILE .entry NEQA .dbg$gl_bpthead
;	2339		DO
;	2340			BEGIN
;	2341			IF .address EQLA .bpt_addr (.entry)
;	2342			THEN RETURN .entry
;	2343			ELSE entry = .dll_rlink (.entry);
;	2344			END;
;	2345	
;	2346		!+
;	2347		! NO MATCH. RETURN ZERO
;	2348		!-
;	2349		RETURN 0
;	2350		END;


; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 5-1
; Digital Equipment Corporation
;

							    .TITLE  DBGBRK
							    .IDENT  \000061\

							    .GLOBL  DBG$_RST_BEGIN, DBG$FAO_OUT, DBG$SHO_OPTRACE, DBG$SYMBOL_VALU
							    .GLOBL  DBG$FAO_PUT, DBG$FREERELEASE, DBG$FREEZ, DBG$IS_IT_ENTRY
							    .GLOBL  DBG$OUT_PUT, DBG$OUT_SYM_VAL, DBG$OUT_NUM_VAL
							    .GLOBL  DBG$READ_ACCESS, DBG$VAL_TO_SAT, DBG$WRITE_MEM
							    .GLOBL  DBG$GL_RUNFRAME, DBG$CP_OUT_STR, DBG$GB_MOD_PTR
							    .GLOBL  DBG$GL_BPTHEAD, DBG$GL_BUF_SIZ, DBG$GL_CONTEXT
							    .GLOBL  DBG$GL_LAST_LOC, DBG$GL_LIST
							    .WEAK   ACCESS_CHECK

							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0000 00000 	    .ENTRY  DBG$FIND_BPT, Save nothing				      ; 2297
		         50 00000000G  FF  D0 00002 	    MOVL    @DBG$GL_BPTHEAD, ENTRY				      ; 2328
	      00000000G  EF	       50  D1 00009 1$:     CMPL    ENTRY, DBG$GL_BPTHEAD				      ; 2338
				       0C  13 00010 	    BEQL    2$							      ;
		    08   A0	  04   AC  D1 00012 	    CMPL    ADDRESS, 8(ENTRY)					      ; 2341
				       07  13 00017 	    BEQL    3$							      ;
		         50	       60  D0 00019 	    MOVL    (ENTRY), ENTRY					      ; 2343
				       EB  11 0001C 	    BRB     1$							      ; 2338
				       50  D4 0001E 2$:     CLRL    R0							      ; 2349
					   04 00020 3$:     RET     							      ; 2297

; Routine Size:  33 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 6
; Digital Equipment Corporation
;
;	2351	GLOBAL ROUTINE dbg$find_watch (address, table_entry_ptr) =
;	2352	!++
;	2353	! Functional description:
;	2354	!	Searches the break/trace/watchpoint table for an entry on the
;	2355	!	same page as this address or exactly the same as this address.
;	2356	!	If an exact match is found, then the address of the entry is
;	2357	!	returned to the caller in an output parameter. If a same
;	2358	!	page match is found, then the value TRUE is returned,
;	2359	!	but the output parameter contains an address of zero.
;	2360	!
;	2361	! Input parameters:
;	2362	!	address		- address to be compared against the table entries.
;	2363	!
;	2364	! Implicit inputs:
;	2365	!	dbg$gl_bpthead, the head of the break/trace/watchpoint table.
;	2366	!	We know that the number of bytes in a single VAX page is 200
;	2367	!	hexadecimal, represented by the literal bytes_per_page.
;	2368	!
;	2369	! Output parameters:
;	2370	!	table_entry_ptr	- place in which to return table entry address
;	2371	!
;	2372	! Implicit outputs:
;	2373	!	none
;	2374	!
;	2375	! Routine value:
;	2376	!	true if the address is on the same page as some watchpoint.
;	2377	!	Otherwise, false.
;	2378	!
;	2379	! Side effects:
;	2380	!	none
;	2381	!
;	2382	!--
;	2383	
;	2384		BEGIN
;	2385	
;	2386		MAP
;	2387			table_entry_ptr	: REF VECTOR;
;	2388	
;	2389		LOCAL
;	2390			entry,			! address of current table entry
;	2391			page_number,		! page on which a watchpoint exists
;	2392			page_match;		! boolean variable, says whether
;	2393						! a matching page has been found.
;	2394	
;	2395		!+
;	2396		! Initialize variables. The page number variable holds the 
;	2397		! page containing the address passed as an input variable.
;	2398		!-
;	2399		page_number = .address / bytes_per_page;
;	2400	
;	2401	%IF dbg_brk2
;     L 2402	%THEN
;     U 2403		$fao_tt_out ('address in find_watch is !XL, page is !SL', .address, .page_number);
;     U 2404	%FI
;	2405	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 6-1
; Digital Equipment Corporation
;
;	2406		page_match = FALSE;
;	2407		table_entry_ptr [0] = 0;
;	2408		entry = .dll_rlink (.dbg$gl_bpthead);
;	2409	
;	2410		!+
;	2411		! Look at each entry in the table. If an entry is a watchpoint,
;	2412		! see whether the address passed is exactly the watchpoint
;	2413		! found, or simply an address that shares the page of the watchpoint.
;	2414		! If any match or shared page is found, store the table entry address in
;	2415		! the output parameter and set page_match to true.
;	2416		!-
;	2417		WHILE .entry NEQA .dbg$gl_bpthead
;	2418		DO
;	2419			BEGIN
;	2420			IF .bpt_type (.entry) EQL watch_point
;	2421			THEN
;	2422				BEGIN
;	2423	
;	2424	%IF dbg_brk2
;     L 2425	%THEN
;     U 2426				$fao_tt_out ('found a watchpoint at !XL, page !UL',
;     U 2427					 .bpt_addr (.entry), .bpt_addr (.entry) / bytes_per_page);
;     U 2428	%FI
;	2429	
;	2430				IF (.bpt_addr (.entry) / bytes_per_page) EQL .page_number
;	2431				THEN
;	2432					BEGIN
;	2433					page_match = TRUE;
;	2434					table_entry_ptr [0] = .entry;
;	2435					END;
;	2436				IF (.bpt_addr(.entry) LEQA .address)
;	2437				AND (.address LEQA (.bpt_addr(.entry) + .bpt_leng(.entry)))
;	2438				THEN
;	2439					BEGIN
;	2440	
;	2441	%IF dbg_brk2
;     L 2442	%THEN
;     U 2443					$fao_tt_out ('exact match with a watchpoint !XL',
;     U 2444							.table_entry_ptr[0]);
;     U 2445	%FI
;	2446	
;	2447					RETURN TRUE
;	2448					END;
;	2449				END;
;	2450			entry = .dll_rlink (.entry);
;	2451			END;
;	2452	
;	2453		!+
;	2454		! If any entry caused the page_match flag to be set, return
;	2455		! true, otherwise return false.
;	2456		!-
;	2457		IF .page_match
;	2458		THEN RETURN TRUE
;	2459		ELSE RETURN FALSE;
;	2460	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 6-2
; Digital Equipment Corporation
;
;	2461		END;





					 000C 00021 	    .ENTRY  DBG$FIND_WATCH, Save R2,R3				      ; 2351
	   53	    04   AC 00000200   8F  C7 00023 	    DIVL3   #512, ADDRESS, PAGE_NUMBER				      ; 2399
				       52  D4 0002C 	    CLRL    PAGE_MATCH						      ; 2406
				  08   BC  D4 0002E 	    CLRL    @TABLE_ENTRY_PTR					      ; 2407
		         50 00000000G  FF  D0 00031 	    MOVL    @DBG$GL_BPTHEAD, ENTRY				      ; 2408
	      00000000G  EF	       50  D1 00038 1$:     CMPL    ENTRY, DBG$GL_BPTHEAD				      ; 2417
				       37  13 0003F 	    BEQL    4$							      ;
      12   A0	         02	       01  ED 00041 	    CMPZV   #1, #2, 18(ENTRY), #3				      ; 2420
				       03     00046									      ;
				       2A  12 00047 	    BNEQ    3$							      ;
	   51	    08   A0 00000200   8F  C7 00049 	    DIVL3   #512, 8(ENTRY), R1					      ; 2430
		         53	       51  D1 00052 	    CMPL    R1, PAGE_NUMBER					      ;
				       07  12 00055 	    BNEQ    2$							      ;
		         52	       01  D0 00057 	    MOVL    #1, PAGE_MATCH					      ; 2433
		    08   BC	       50  D0 0005A 	    MOVL    ENTRY, @TABLE_ENTRY_PTR				      ; 2434
		    04   AC	  08   A0  D1 0005E 2$:     CMPL    8(ENTRY), ADDRESS					      ; 2436
				       0E  1A 00063 	    BGTRU   3$							      ;
		         51	  10   A0  9A 00065 	    MOVZBL  16(ENTRY), R1					      ; 2437
		         51	  08   A0  C0 00069 	    ADDL2   8(ENTRY), R1					      ;
		         51	  04   AC  D1 0006D 	    CMPL    ADDRESS, R1						      ;
				       08  1B 00071 	    BLEQU   5$							      ;
		         50	       60  D0 00073 3$:     MOVL    (ENTRY), ENTRY					      ; 2450
				       C0  11 00076 	    BRB     1$							      ; 2417
		         04	       52  E9 00078 4$:     BLBC    PAGE_MATCH, 6$					      ; 2457
		         50	       01  D0 0007B 5$:     MOVL    #1, R0						      ; 2458
					   04 0007E 	    RET     							      ;
				       50  D4 0007F 6$:     CLRL    R0							      ; 2351
					   04 00081 	    RET     							      ;

; Routine Size:  97 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 7
; Digital Equipment Corporation
;
;	2462	GLOBAL ROUTINE dbg$init_break : NOVALUE =
;	2463	!++
;	2464	! Functional description:
;	2465	!	ALLOCATES AND SETS UP THE pointerS IN THE HEADER LINK OF THE
;	2466	!	BREAKPOINT CHAIN.
;	2467	!
;	2468	! Input parameters:
;	2469	!	none
;	2470	!
;	2471	! Implicit inputs:
;	2472	!	dbg$gl_bpthead, THE pointer TO THE HEAD OF THE BREAKPOINT CHAIN
;	2473	!
;	2474	! Output parameters:
;	2475	!	none
;	2476	!
;	2477	! Implicit outputs:
;	2478	!	dbg$gl_bpthead NOW HOLDS AN address
;	2479	!
;	2480	! Routine value:
;	2481	!	novalue
;	2482	!
;	2483	! Side effects:
;	2484	!	THE BREAKPOINT CHAIN HEADER LINK IS INITIALIZED
;	2485	!--
;	2486	
;	2487		BEGIN
;	2488	
;	2489		!+
;	2490		! ALLOCATE A BREAKPOINT entry FOR THE HEADER LINK OF THE BREAKPOINT
;	2491		! CHAIN.
;	2492		!-
;	2493		dbg$gl_bpthead = dbg$freez (2);
;	2494	
;	2495		!+
;	2496		! NOW WRITE THE TWO LINKS, EACH POINTING TO THE address OF THE
;	2497		! FIRST LONGWORD OF THIS entry.
;	2498		!-
;	2499		dll_rlink (.dbg$gl_bpthead) = .dbg$gl_bpthead;
;	2500		dll_llink (.dbg$gl_bpthead) = .dbg$gl_bpthead;
;	2501	
;	2502		END;





					 0800 00082 	    .ENTRY  DBG$INIT_BREAK, Save R11				      ; 2462
		         5B 00000000G  EF  9E 00084 	    MOVAB   DBG$GL_BPTHEAD, R11					      ;
				       02  DD 0008B 	    PUSHL   #2							      ; 2493
	      00000000G  EF	       01  FB 0008D 	    CALLS   #1, DBG$FREEZ					      ;
		         6B	       50  D0 00094 	    MOVL    R0, DBG$GL_BPTHEAD					      ;
		         50	       6B  D0 00097 	    MOVL    DBG$GL_BPTHEAD, R0					      ; 2499
		         60	       50  D0 0009A 	    MOVL    R0, (R0)						      ;
		    04   A0	       50  D0 0009D 	    MOVL    R0, 4(R0)						      ; 2500
					   04 000A1 	    RET     							      ; 2462

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 7-1
; Digital Equipment Corporation
;

; Routine Size:  32 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8
; Digital Equipment Corporation
;
;	2503	GLOBAL ROUTINE dbg$ins_opcodes (user_pc_value) : NOVALUE =
;	2504	!++
;	2505	! Functional description:
;	2506	!	LOOKS FOR A BREAKPOINT IDENTIFIED BY ITS PC VALUE IN
;	2507	!	THE BREAKPOINT TABLE. IF IT EXISTS, THE OPCODE FOUND
;	2508	!	FOR THAT BREAKPOINT IS SUBSTITUTED FOR THE BPT INSTRUCTION
;	2509	!	AT THAT PC.
;	2510	!
;	2511	!	IF THE address PASSED TO THIS ROUTINE IS EQUIVALENT TO
;	2512	!	THE LITERAL all_bpts, THEN ALL OPCODES FOR ALL BREAKPOINTS
;	2513	!	ARE REINSERTED.
;	2514	!
;	2515	!	If the PC value matches a watchpoint (or all_bpts is specified),
;	2516	!	then the original protections of the watchpoints are
;	2517	!	reinstated.
;	2518	!
;	2519	! Input parameters:
;	2520	!	user_pc_value	- VALUE OF USER PC AT TIME OF BPT
;	2521	!
;	2522	! Implicit inputs:
;	2523	!	dbg$gl_bpthead, HEADER LINK IN BREAKPOINT CHAIN.
;	2524	!
;	2525	! Output parameters:
;	2526	!	none
;	2527	!
;	2528	! Implicit outputs:
;	2529	!	none
;	2530	!
;	2531	! Routine value:
;	2532	!	novalue
;	2533	!
;	2534	! Side effects:
;	2535	!	BPT INSTRUCTION REPLACED WITH PC'S ORIGINAL OPCODE
;	2536	!	Watchpoints set with original protection.
;	2537	!--
;	2538	
;	2539		BEGIN
;	2540	
;	2541		LOCAL
;	2542			addr_range	: VECTOR [2],
;	2543			entry;
;	2544	
;	2545		IF .dbg$gl_bpthead EQL 0
;	2546		THEN
;	2547			BEGIN
;	2548			SIGNAL (dbg$_nowopco);
;	2549			RETURN
;	2550			END;
;	2551		IF .user_pc_value EQL all_bpts
;	2552		THEN
;	2553			BEGIN
;	2554	
;	2555	%IF dbg_brk1
;     L 2556	%THEN
;     U 2557			$fao_tt_out ('inserting opcodes for all breakpoints');

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-1
; Digital Equipment Corporation
;
;     U 2558	%FI
;	2559	
;	2560	 		entry = .dll_rlink (.dbg$gl_bpthead);
;	2561	
;	2562			!++
;	2563			! FOR EACH ENTRY IN THE BREAKPOINT CHAIN EXCEPT THE
;	2564			! HEADER LINK, ATTEMPT TO INSERT THE OPCODE. IF ANY
;	2565			! INSERTION FAILS, QUIT. AFTER DOING AN INSERTION,
;	2566			! MOVE TO THE NEXT ENTRY IN THE LINKED CHAIN, AND
;	2567			! ONLY QUIT WHEN THE NEXT ENTRY IS THE HEADER LINK.
;	2568			!--
;	2569			WHILE .entry NEQA .dbg$gl_bpthead
;	2570			DO
;	2571				BEGIN
;	2572	
;	2573				!++
;	2574				! INSERT THE OPCODE FOR EACH BREAKPOINT, GOING
;	2575				! ON TO THE NEXT AFTER THE OPCODE IS INSERTED.
;	2576				! IF THE BREAKPOINT CAN NOT BE REPLACED, signal
;	2577				! an error.
;	2578				!--
;	2579				IF .bpt_accs (.entry) EQL execute_watch
;	2580				THEN
;	2581				    IF NOT dbg$write_mem (.bpt_addr (.entry), bpt_opco(.entry), 1)
;	2582				    THEN
;	2583					BEGIN
;	2584					!++
;	2585					! THE BREAKPOINT REMOVAL AND OPCODE INSERTION
;	2586					! HAS FAILED. PUNT.
;	2587					!--
;	2588					SIGNAL (dbg$_nowopco);
;	2589					RETURN
;	2590					END;
;	2591				IF .bpt_type (.entry) EQL watch_point
;	2592				THEN
;	2593					BEGIN
;	2594					!++
;	2595					! Set the protection of the
;	2596					! watchpoint to its original state. If
;	2597					! the set protection system service fails,
;	2598					! signal fatal error.
;	2599					!--
;	2600					addr_range [0] = .bpt_addr (.entry);
;	2601					addr_range [1] = .bpt_addr (.entry);
;	2602	
;	2603	%IF dbg_brk2
;     L 2604	%THEN
;     U 2605					$fao_tt_out ('setting !XL to protection !SL', 
;     U 2606						.bpt_addr (.entry), .bpt_pro1 (.entry));
;     U 2607	%FI
;	2608	
;	2609					IF NOT $SETPRT (inadr = addr_range, prot = .bpt_pro1 (.entry))
;	2610					THEN
;	2611						BEGIN
;	2612	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-2
; Digital Equipment Corporation
;
;	2613	%IF dbg_brk2
;     L 2614	%THEN
;     U 2615						$fao_tt_out ('failed to set protection on !XL',
;     U 2616							.bpt_addr (.entry));
;     U 2617	%FI
;	2618	
;	2619						SIGNAL (dbg$_nowprot);
;	2620						RETURN
;	2621						END;
;	2622					IF (.bpt_addr(.entry) / bytes_per_page) NEQ
;	2623						((.bpt_addr(.entry) + .bpt_leng(.entry)) / bytes_per_page)
;	2624					THEN
;	2625						BEGIN
;	2626						!++
;	2627						! End of variable being watched is
;	2628						! on another page. Set that protection
;	2629						! also.
;	2630						!--
;	2631						addr_range [0] = .bpt_addr(.entry) + .bpt_leng(.entry);
;	2632						addr_range [1] = .bpt_addr(.entry) + .bpt_leng(.entry);
;	2633	
;	2634	%IF dbg_brk2
;     L 2635	%THEN
;     U 2636						$fao_tt_out ('setting !XL to protection !SL',
;     U 2637							.addr_range [0], .bpt_pro2 (.entry));
;     U 2638	%FI
;	2639	
;	2640						IF NOT $SETPRT (inadr = addr_range, prot = .bpt_pro2 (.entry))
;	2641						THEN
;	2642							BEGIN
;	2643	
;	2644	%IF dbg_brk2
;     L 2645	%THEN
;     U 2646							$fao_tt_out ('failed to set protection on !XL',
;     U 2647								.addr_range [0]);
;     U 2648	%FI
;	2649	
;	2650							SIGNAL (dbg$_nowprot);
;	2651							RETURN
;	2652							END;
;	2653						END;
;	2654					END;
;	2655				entry = .dll_rlink (.entry);
;	2656				END;
;	2657	
;	2658			IF .dbg$gl_runframe[dbg$l_bpt_pc] NEQ 0
;	2659			THEN
;	2660			    IF NOT dbg$write_mem (.dbg$gl_runframe[dbg$l_bpt_pc],
;	2661						  dbg$gl_runframe[dbg$b_bpt_ins], 1)
;	2662			    THEN
;	2663				BEGIN
;	2664				SIGNAL (dbg$_nowopco);
;	2665				RETURN
;	2666				END;
;	2667	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-3
; Digital Equipment Corporation
;
;	2668			!++
;	2669			! ALL OPCODES ARE INSERTED.
;	2670			!--
;	2671			RETURN
;	2672			END;
;	2673	%if 0
;     L 2674	%then
;     U 2675	
;     U 2676		!++
;     U 2677		! NOW HANDLE THE CASE OF A SINGLE OPCODE INSERTION. FIRST SEARCH
;     U 2678		! THE BREAKPOINT CHAIN FOR THE SPECIFIED BREAKPOINT location.
;     U 2679		!--
;     U 2680		ELSE IF (entry = dbg$find_bpt (.user_pc_value)) NEQ 0
;     U 2681		THEN
;     U 2682			BEGIN
;     U 2683			!++
;     U 2684			! THIS IS A SINGLE OPCODE TO INSERT. IF IT IS REALLY THERE,
;     U 2685			! WRITE THE OPCODE.
;     U 2686			!--
;     U 2687	
;     U 2688	%IF dbg_brk1
;     U 2689	%THEN
;     U 2690			$fao_tt_out ('inserting opcode !XB at !XL',
;     U 2691				.bpt_opco (.entry), .bpt_addr (.entry));
;     U 2692	%FI
;     U 2693	
;     U 2694			IF .bpt_accs (.entry) EQL execute_watch
;     U 2695			THEN IF dbg$write_mem (.bpt_addr (.entry), bpt_opco (.entry), 1)
;     U 2696			THEN RETURN
;     U 2697			ELSE
;     U 2698				BEGIN
;     U 2699				!++
;     U 2700				! CANNOT WRITE THE OPCODE. TELL USER.
;     U 2701				!--
;     U 2702				SIGNAL (dbg$_nowopco);
;     U 2703				RETURN
;     U 2704				END;
;     U 2705			END;
;     U 2706	
;     U 2707		!++
;     U 2708		! No such breakpoint. See if this is a watchpoint, or an
;     U 2709		! address on the same page as a watchpoint. If so, reset
;     U 2710		! the protection of that page to its original state.
;     U 2711		!--
;     U 2712		IF NOT dbg$find_watch (.user_pc_value, entry)
;     U 2713		THEN
;     U 2714			BEGIN
;     U 2715			SIGNAL (dbg$_nosuchbpt);
;     U 2716			RETURN
;     U 2717			END;
;     U 2718			
;     U 2719	%fi
;	2720		IF dbg$find_watch (.user_pc_value, entry)
;	2721		THEN
;	2722		BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-4
; Digital Equipment Corporation
;
;	2723		!++
;	2724		! This is a watchpoint or a location on the same
;	2725		! page as a watchpoint. Restore its original
;	2726		! protection. If this fails, signal fatal error.
;	2727		!--
;	2728		addr_range [0] = .bpt_addr (.entry);
;	2729		addr_range [1] = .bpt_addr (.entry);
;	2730	
;	2731	%IF dbg_brk2
;     L 2732	%THEN
;     U 2733		$fao_tt_out ('setting !XL to protection !SL', .bpt_addr (.entry), .bpt_pro1 (.entry));
;     U 2734	%FI
;	2735	
;	2736		IF NOT $SETPRT (inadr = addr_range, prot = .bpt_pro1 (.entry))
;	2737		THEN
;	2738			BEGIN
;	2739	
;	2740	%IF dbg_brk2
;     L 2741	%THEN
;     U 2742			$fao_tt_out ('failed to set protection on !XL', .bpt_addr (.entry));
;     U 2743	%FI
;	2744	
;	2745			SIGNAL (dbg$_nowprot);
;	2746			RETURN
;	2747			END;
;	2748		IF (.bpt_addr(.entry) / bytes_per_page) NEQ
;	2749			((.bpt_addr(.entry) + .bpt_leng(.entry)) / bytes_per_page)
;	2750		THEN
;	2751			BEGIN
;	2752			addr_range [0] =  .bpt_addr(.entry) + .bpt_leng(.entry);
;	2753			addr_range [1] =  .bpt_addr(.entry) + .bpt_leng(.entry);
;	2754	%IF dbg_brk2
;     L 2755	%THEN
;     U 2756			$fao_tt_out ('setting !XL to protection !SL', .addr_range [0], .bpt_pro2 (.entry));
;     U 2757	%FI
;	2758	
;	2759			IF NOT $SETPRT (inadr = addr_range, prot = .bpt_pro2 (.entry))
;	2760			THEN
;	2761				BEGIN
;	2762	
;	2763	%IF dbg_brk2
;     L 2764	%THEN
;     U 2765				$fao_tt_out ('failed to set protection on !XL', .addr_range [0]);
;     U 2766	%FI
;	2767	
;	2768				SIGNAL (dbg$_nowprot);
;	2769				RETURN
;	2770				END;
;	2771			END;
;	2772		END;
;	2773	
;	2774		END;




; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-5
; Digital Equipment Corporation
;
							    .GLOBL  SYS$SETPRT

					 0E1C 000A2 	    .ENTRY  DBG$INS_OPCODES, Save R2,R3,R4,R9,R10,R11		      ; 2503
		         59 00000000G  EF  9E 000A4 	    MOVAB   DBG$WRITE_MEM, R9					      ;
		         5A 00000000G  EF  9E 000AB 	    MOVAB   DBG$GL_BPTHEAD, R10					      ;
		         5B 00000000G  9F  9E 000B2 	    MOVAB   @#SYS$SETPRT, R11					      ;
		         5E	       0C  C2 000B9 	    SUBL2   #12, SP						      ;
				       6A  D5 000BC 	    TSTL    DBG$GL_BPTHEAD					      ; 2545
				       35  13 000BE 	    BEQL    4$							      ;
	      FFFFFFFF   8F	  04   AC  D1 000C0 	    CMPL    USER_PC_VALUE, #-1					      ; 2551
				       03  13 000C8 	    BEQL    1$							      ;
				     00B6  31 000CA 	    BRW     9$							      ;
		         6E	  00   BA  D0 000CD 1$:     MOVL    @DBG$GL_BPTHEAD, ENTRY				      ; 2560
		         52	       6E  D0 000D1 2$:     MOVL    ENTRY, R2						      ; 2569
		         6A	       52  D1 000D4 	    CMPL    R2, DBG$GL_BPTHEAD					      ;
				       03  12 000D7 	    BNEQ    3$							      ;
				     008A  31 000D9 	    BRW     8$							      ;
		         54	  10   A2  9E 000DC 3$:     MOVAB   16(R2), R4						      ; 2579
	   64	         02	       13  ED 000E0 	    CMPZV   #19, #2, (R4), #3					      ;
				       03     000E4									      ;
				       17  12 000E5 	    BNEQ    5$							      ;
				       01  DD 000E7 	    PUSHL   #1							      ; 2581
				  03   A4  9F 000E9 	    PUSHAB  3(R4)						      ;
				  08   A2  DD 000EC 	    PUSHL   8(R2)						      ;
		         69	       03  FB 000EF 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         09	       50  E8 000F2 	    BLBS    R0, 5$						      ;
			    000284BC   8F  DD 000F5 4$:     PUSHL   #165052						      ; 2588
				     00FA  31 000FB 	    BRW     13$							      ;
	   64	         02	       11  ED 000FE 5$:     CMPZV   #17, #2, (R4), #3					      ; 2591
				       03     00102									      ;
				       5B  12 00103 	    BNEQ    7$							      ;
		         53	  08   A2  D0 00105 	    MOVL    8(R2), R3						      ; 2600
		    04   AE	       53  D0 00109 	    MOVL    R3, ADDR_RANGE					      ;
		    08   AE	       53  D0 0010D 	    MOVL    R3, ADDR_RANGE+4					      ; 2601
				       7E  D4 00111 	    CLRL    -(SP)						      ; 2609
      03   A4	         04	       00  EF 00113 	    EXTZV   #0, #4, 3(R4), -(SP)				      ;
				       7E     00118									      ;
				       7E  7C 00119 	    CLRQ    -(SP)						      ;
				  14   AE  9F 0011B 	    PUSHAB  ADDR_RANGE						      ;
		         6B	       05  FB 0011E 	    CALLS   #5, SYS$SETPRT					      ;
		         39	       50  E9 00121 	    BLBC    R0, 6$						      ;
	   51	         53 00000200   8F  C7 00124 	    DIVL3   #512, R3, R1					      ; 2622
		         50	       64  9A 0012C 	    MOVZBL  (R4), R0						      ; 2623
		         50	       53  C0 0012F 	    ADDL2   R3, R0						      ;
		         50 00000200   8F  C6 00132 	    DIVL2   #512, R0						      ;
		         50	       51  D1 00139 	    CMPL    R1, R0						      ; 2622
				       22  13 0013C 	    BEQL    7$							      ;
		         50	       64  9A 0013E 	    MOVZBL  (R4), R0						      ; 2631
      04   AE	         53	       50  C1 00141 	    ADDL3   R0, R3, ADDR_RANGE					      ;
		         50	       64  9A 00146 	    MOVZBL  (R4), R0						      ; 2632
      08   AE	         53	       50  C1 00149 	    ADDL3   R0, R3, ADDR_RANGE+4				      ;
				       7E  D4 0014E 	    CLRL    -(SP)						      ; 2640
	   64	         04	       1C  EF 00150 	    EXTZV   #28, #4, (R4), -(SP)				      ;
				       7E     00154									      ;
				       7E  7C 00155 	    CLRQ    -(SP)						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-6
; Digital Equipment Corporation
;
				  14   AE  9F 00157 	    PUSHAB  ADDR_RANGE						      ;
		         6B	       05  FB 0015A 	    CALLS   #5, SYS$SETPRT					      ;
		         53	       50  E9 0015D 6$:     BLBC    R0, 10$						      ;
		         6E	       62  D0 00160 7$:     MOVL    (R2), ENTRY						      ; 2655
				     FF6B  31 00163 	    BRW     2$							      ; 2569
		         50 00000000G  EF  D0 00166 8$:     MOVL    DBG$GL_RUNFRAME, R0					      ; 2658
				  4A   A0  D5 0016D 	    TSTL    74(R0)						      ;
				       5C  13 00170 	    BEQL    11$							      ;
				       01  DD 00172 	    PUSHL   #1							      ; 2660
				  60   A0  9F 00174 	    PUSHAB  96(R0)						      ; 2661
				  4A   A0  DD 00177 	    PUSHL   74(R0)						      ; 2660
		         69	       03  FB 0017A 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         7F	       50  E8 0017D 	    BLBS    R0, 14$						      ;
				     FF72  31 00180 	    BRW     4$							      ; 2664
				       5E  DD 00183 9$:     PUSHL   SP							      ; 2720
				  04   AC  DD 00185 	    PUSHL   USER_PC_VALUE					      ;
		  FE94   CF	       02  FB 00188 	    CALLS   #2, DBG$FIND_WATCH					      ;
		         6F	       50  E9 0018D 	    BLBC    R0, 14$						      ;
		         50	       6E  D0 00190 	    MOVL    ENTRY, R0						      ; 2728
		         52	  08   A0  D0 00193 	    MOVL    8(R0), R2						      ;
		    04   AE	       52  D0 00197 	    MOVL    R2, ADDR_RANGE					      ;
		    08   AE	       52  D0 0019B 	    MOVL    R2, ADDR_RANGE+4					      ; 2729
				       7E  D4 0019F 	    CLRL    -(SP)						      ; 2736
		         53	  10   A0  9E 001A1 	    MOVAB   16(R0), R3						      ;
      03   A3	         04	       00  EF 001A5 	    EXTZV   #0, #4, 3(R3), -(SP)				      ;
				       7E     001AA									      ;
				       7E  7C 001AB 	    CLRQ    -(SP)						      ;
				  14   AE  9F 001AD 	    PUSHAB  ADDR_RANGE						      ;
		         6B	       05  FB 001B0 	    CALLS   #5, SYS$SETPRT					      ;
		         3C	       50  E9 001B3 10$:    BLBC    R0, 12$						      ;
	   51	         52 00000200   8F  C7 001B6 	    DIVL3   #512, R2, R1					      ; 2748
		         50	       63  9A 001BE 	    MOVZBL  (R3), R0						      ; 2749
		         50	       52  C0 001C1 	    ADDL2   R2, R0						      ;
		         50 00000200   8F  C6 001C4 	    DIVL2   #512, R0						      ;
		         50	       51  D1 001CB 	    CMPL    R1, R0						      ; 2748
				       2F  13 001CE 11$:    BEQL    14$							      ;
		         50	       63  9A 001D0 	    MOVZBL  (R3), R0						      ; 2752
      04   AE	         52	       50  C1 001D3 	    ADDL3   R0, R2, ADDR_RANGE					      ;
		         50	       63  9A 001D8 	    MOVZBL  (R3), R0						      ; 2753
      08   AE	         52	       50  C1 001DB 	    ADDL3   R0, R2, ADDR_RANGE+4				      ;
				       7E  D4 001E0 	    CLRL    -(SP)						      ; 2759
	   63	         04	       1C  EF 001E2 	    EXTZV   #28, #4, (R3), -(SP)				      ;
				       7E     001E6									      ;
				       7E  7C 001E7 	    CLRQ    -(SP)						      ;
				  14   AE  9F 001E9 	    PUSHAB  ADDR_RANGE						      ;
		         6B	       05  FB 001EC 	    CALLS   #5, SYS$SETPRT					      ;
		         0D	       50  E8 001EF 	    BLBS    R0, 14$						      ;
			    000284C4   8F  DD 001F2 12$:    PUSHL   #165060						      ; 2768
	      00000000G  00	       01  FB 001F8 13$:    CALLS   #1, LIB$SIGNAL					      ;
					   04 001FF 14$:    RET     							      ; 2503

; Routine Size:  350 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 8-7
; Digital Equipment Corporation
;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 9
; Digital Equipment Corporation
;
;	2775	GLOBAL ROUTINE dbg$rem_opcodes (addr_of_no_bpt) : NOVALUE =
;	2776	!++
;	2777	! Functional description:
;	2778	!	For each break/tracepoint in the breakpoint table, remove the
;	2779	!	opcode at that address and replace it with a breakpoint
;	2780	!	instruction. For each watchpoint, protec the page as
;	2781	!	requested in the SET WATCH commands.
;	2782	!
;	2783	! Input parameters:
;	2784	!	addr_of_no_bpt	- The PC location where we do not want a BPT stored
;	2785	!			  if there happens to be a break set.  A value of zero
;	2786	!			  indicates replace all breakpointed instructions.
;	2787	!
;	2788	! Implicit inputs:
;	2789	!	dbg$gl_bpthead, header link in breakpoint chain
;	2790	!
;	2791	! Output parameters:
;	2792	!	none
;	2793	!
;	2794	! Implicit outputs:
;	2795	!	none
;	2796	!
;	2797	! Routine value:
;	2798	!	novalue
;	2799	!
;	2800	! Side effects:
;	2801	!	The program is modified as instructed by the user so that DEBUG
;	2802	!	can gain control when desired.
;	2803	!--
;	2804	
;	2805		BEGIN
;	2806	
;	2807		OWN
;	2808			bpt_instr : INITIAL( bpt_instruction );	! dbg$write_mem needs
;	2809								! the address of the data
;	2810								! to be written.
;	2811	
;	2812		LOCAL
;	2813			entry;
;	2814	
;	2815		IF .dbg$gl_bpthead EQL 0
;	2816		THEN
;	2817			BEGIN
;	2818			SIGNAL (dbg$_nowbpt);
;	2819			RETURN
;	2820			END;
;	2821	
;	2822	%IF dbg_brk1
;     L 2823	%THEN
;     U 2824		$fao_tt_out ('removing all breakpointed opcodes');
;     U 2825	%FI
;	2826	
;	2827		IF .dbg$gl_runframe[dbg$l_bpt_pc] NEQ 0
;	2828		THEN
;	2829		    IF NOT dbg$write_mem (.dbg$gl_runframe[dbg$l_bpt_pc], bpt_instr, 1)

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 9-1
; Digital Equipment Corporation
;
;	2830		    THEN
;	2831			BEGIN
;	2832			SIGNAL (dbg$_nowbpt);
;	2833			RETURN
;	2834			END;
;	2835	
;	2836		entry = .dll_rlink (.dbg$gl_bpthead);
;	2837		WHILE .entry NEQA .dbg$gl_bpthead
;	2838		DO
;	2839			BEGIN
;	2840			!++
;	2841			! For each breakpoint and tracepoint, insert a breakpoint
;	2842			! instruction for each opcode. If the opcode at the 
;	2843			! break/tracepoint address is different from the opcode
;	2844			! stored in the table, rewrite the new opcode into the
;	2845			! table. If the opcode cannot be written signal a fatal
;	2846			! error.
;	2847			!--
;	2848			IF .bpt_accs (.entry) EQL execute_watch
;	2849			THEN
;	2850				BEGIN
;	2851	
;	2852				LOCAL
;	2853					bpt_address: REF VECTOR [, BYTE];
;	2854	
;	2855				bpt_address = .bpt_addr (.entry);
;	2856				IF .bpt_opco (.entry) NEQ .bpt_address [0]	! make sure we have
;	2857				THEN bpt_opco (.entry) = .bpt_address [0];	! the current opcode
;	2858	
;	2859	%IF dbg_brk1
;     L 2860	%THEN
;     U 2861				$fao_tt_out ('removing opcode !XB at !XL',
;     U 2862					.bpt_opco (.entry), .bpt_addr (.entry));
;     U 2863	%FI
;	2864	
;	2865				IF (.addr_of_no_bpt NEQ .bpt_address)
;	2866				THEN
;	2867				    IF NOT dbg$write_mem (.bpt_addr(.entry), bpt_instr, 1)
;	2868				    THEN
;	2869					BEGIN
;	2870					!++
;	2871					! THE OPCODE REMOVAL AND BREAKPOINT INSERTION
;	2872					! HAS FAILED. TELL THE USER.
;	2873					!--
;	2874					SIGNAL (dbg$_nowbpt);
;	2875					RETURN
;	2876					END;
;	2877				END
;	2878			ELSE IF .bpt_type (.entry) EQL watch_point
;	2879			THEN
;	2880				BEGIN
;	2881				!++
;	2882				! This is a watchpoint. Set its protection to
;	2883				! disallow read or write (or both) access. If
;	2884				! the protection cannot be set, signal fatal

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 9-2
; Digital Equipment Corporation
;
;	2885				! error.
;	2886				!--
;	2887				LOCAL
;	2888					addr_range	: VECTOR [2];
;	2889	
;	2890				addr_range [0] = .bpt_addr (.entry);
;	2891				addr_range [1] = .bpt_addr (.entry);
;	2892	
;	2893	%IF dbg_brk2
;     L 2894	%THEN
;     U 2895				$fao_tt_out ('setting !XL to protection !SL', .bpt_addr (.entry), prt$c_ur);
;     U 2896	%FI
;	2897	
;	2898				IF NOT $SETPRT (inadr = addr_range, prot = prt$c_ur)
;	2899				THEN
;	2900					BEGIN
;	2901					!++
;	2902					! The protection could not be set. Signal
;	2903					! fatal error.
;	2904					!--
;	2905	
;	2906	%IF dbg_brk2
;     L 2907	%THEN
;     U 2908					$fao_tt_out ('failed to set protection on !XL', .addr_range [0]);
;     U 2909	%FI
;	2910	
;	2911					SIGNAL (dbg$_nowprot);
;	2912					RETURN
;	2913					END;
;	2914	
;	2915				!++
;	2916				! Now calculate whether the end of the range
;	2917				! being watched is on the same or a different page.
;	2918				! If different, set that page's protection too.
;	2919				!--
;	2920				IF (.bpt_addr(.entry) / bytes_per_page) NEQ
;	2921					((.bpt_addr(.entry) + .bpt_leng(.entry)) / bytes_per_page)
;	2922				THEN
;	2923					BEGIN
;	2924					addr_range [0] = .bpt_addr(.entry) + .bpt_leng(.entry);
;	2925					addr_range [1] = .bpt_addr(.entry) + .bpt_leng(.entry);
;	2926	
;	2927	%IF dbg_brk2
;     L 2928	%THEN
;     U 2929					$fao_tt_out ('setting !XL to protection !SL',
;     U 2930						.addr_range [0],
;     U 2931						prt$c_ur);
;     U 2932	%FI
;	2933	
;	2934					IF NOT $SETPRT (inadr = addr_range, prot = prt$c_ur)
;	2935					THEN
;	2936						BEGIN
;	2937						!++
;	2938						! Protection setting failed.
;	2939						! Signal fatal error.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 9-3
; Digital Equipment Corporation
;
;	2940						!--
;	2941	
;	2942	%If dbg_brk2
;     L 2943	%THEN
;     U 2944						$fao_tt_out ('failed to set protection on !XL',
;     U 2945							.addr_range [0]);
;     U 2946	%FI
;	2947	
;	2948						SIGNAL (dbg$_nowprot);
;	2949						RETURN
;	2950						END;
;	2951					END;
;	2952				END;
;	2953			entry = .dll_rlink (.entry);
;	2954			END;
;	2955	
;	2956		!++
;	2957		! ALL BREAKPOINT INSTRUCTIONS ARE INSERTED.
;	2958		!--
;	2959		END;



							    .PSECT  DBG$OWN,NOEXE,  PIC,2

					      00000 BPT_INSTR:
							    .LONG   3							      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0F1C 00200 	    .ENTRY  DBG$REM_OPCODES, Save R2,R3,R4,R8,R9,R10,R11	      ; 2775
		         58 00000000G  9F  9E 00202 	    MOVAB   @#SYS$SETPRT, R8					      ;
		         59 00000000G  EF  9E 00209 	    MOVAB   DBG$WRITE_MEM, R9					      ;
		         5A 00000000'  EF  9E 00210 	    MOVAB   BPT_INSTR, R10					      ;
		         5B 00000000G  EF  9E 00217 	    MOVAB   DBG$GL_BPTHEAD, R11					      ;
		         5E	       08  C2 0021E 	    SUBL2   #8, SP						      ;
				       6B  D5 00221 	    TSTL    DBG$GL_BPTHEAD					      ; 2815
				       4F  13 00223 	    BEQL    5$							      ;
		         50 00000000G  EF  D0 00225 	    MOVL    DBG$GL_RUNFRAME, R0					      ; 2827
				  4A   A0  D5 0022C 	    TSTL    74(R0)						      ;
				       0D  13 0022F 	    BEQL    1$							      ;
				       01  DD 00231 	    PUSHL   #1							      ; 2829
				       5A  DD 00233 	    PUSHL   R10							      ;
				  4A   A0  DD 00235 	    PUSHL   74(R0)						      ;
		         69	       03  FB 00238 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         36	       50  E9 0023B 	    BLBC    R0, 5$						      ;
		         52	  00   BB  D0 0023E 1$:     MOVL    @DBG$GL_BPTHEAD, ENTRY				      ; 2836
		         6B	       52  D1 00242 2$:     CMPL    ENTRY, DBG$GL_BPTHEAD				      ; 2837
				       01  12 00245 	    BNEQ    3$							      ;
					   04 00247 	    RET     							      ;
		         53	  10   A2  9E 00248 3$:     MOVAB   16(ENTRY), R3					      ; 2848
	   63	         02	       13  ED 0024C 	    CMPZV   #19, #2, (R3), #3					      ;
				       03     00250									      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 9-4
; Digital Equipment Corporation
;
				       29  12 00251 	    BNEQ    6$							      ;
		         50	  08   A2  D0 00253 	    MOVL    8(ENTRY), BPT_ADDRESS				      ; 2855
		         60	  03   A3  91 00257 	    CMPB    3(R3), (BPT_ADDRESS)				      ; 2856
				       04  13 0025B 	    BEQL    4$							      ;
		    03   A3	       60  90 0025D 	    MOVB    (BPT_ADDRESS), 3(R3)				      ; 2857
		         50	  04   AC  D1 00261 4$:     CMPL    ADDR_OF_NO_BPT, BPT_ADDRESS				      ; 2865
				       7A  13 00265 	    BEQL    9$							      ;
				       01  DD 00267 	    PUSHL   #1							      ; 2867
				       5A  DD 00269 	    PUSHL   R10							      ;
				  08   A2  DD 0026B 	    PUSHL   8(ENTRY)						      ;
		         69	       03  FB 0026E 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         6D	       50  E8 00271 	    BLBS    R0, 9$						      ;
			    000284B4   8F  DD 00274 5$:     PUSHL   #165044						      ; 2874
				       5D  11 0027A 	    BRB     8$							      ;
	   63	         02	       11  ED 0027C 6$:     CMPZV   #17, #2, (R3), #3					      ; 2878
				       03     00280									      ;
				       5E  12 00281 	    BNEQ    9$							      ;
		         54	  08   A2  D0 00283 	    MOVL    8(ENTRY), R4					      ; 2890
		         6E	       54  D0 00287 	    MOVL    R4, ADDR_RANGE					      ;
		    04   AE	       54  D0 0028A 	    MOVL    R4, ADDR_RANGE+4					      ; 2891
		         7E	       0F  7D 0028E 	    MOVQ    #15, -(SP)						      ; 2898
				       7E  7C 00291 	    CLRQ    -(SP)						      ;
				  10   AE  9F 00293 	    PUSHAB  ADDR_RANGE						      ;
		         68	       05  FB 00296 	    CALLS   #5, SYS$SETPRT					      ;
		         37	       50  E9 00299 	    BLBC    R0, 7$						      ;
	   51	         54 00000200   8F  C7 0029C 	    DIVL3   #512, R4, R1					      ; 2920
		         50	       63  9A 002A4 	    MOVZBL  (R3), R0						      ; 2921
		         50	       54  C0 002A7 	    ADDL2   R4, R0						      ;
		         50 00000200   8F  C6 002AA 	    DIVL2   #512, R0						      ;
		         50	       51  D1 002B1 	    CMPL    R1, R0						      ; 2920
				       2B  13 002B4 	    BEQL    9$							      ;
		         50	       63  9A 002B6 	    MOVZBL  (R3), R0						      ; 2924
	   6E	         54	       50  C1 002B9 	    ADDL3   R0, R4, ADDR_RANGE					      ;
		         50	       63  9A 002BD 	    MOVZBL  (R3), R0						      ; 2925
      04   AE	         54	       50  C1 002C0 	    ADDL3   R0, R4, ADDR_RANGE+4				      ;
		         7E	       0F  7D 002C5 	    MOVQ    #15, -(SP)						      ; 2934
				       7E  7C 002C8 	    CLRQ    -(SP)						      ;
				  10   AE  9F 002CA 	    PUSHAB  ADDR_RANGE						      ;
		         68	       05  FB 002CD 	    CALLS   #5, SYS$SETPRT					      ;
		         0E	       50  E8 002D0 	    BLBS    R0, 9$						      ;
			    000284C4   8F  DD 002D3 7$:     PUSHL   #165060						      ; 2948
	      00000000G  00	       01  FB 002D9 8$:     CALLS   #1, LIB$SIGNAL					      ;
					   04 002E0 	    RET     							      ; 2949
		         52	       62  D0 002E1 9$:     MOVL    (ENTRY), ENTRY					      ; 2953
				     FF5B  31 002E4 	    BRW     2$							      ; 2837
					   04 002E7 10$:    RET     							      ; 2775

; Routine Size:  232 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10
; Digital Equipment Corporation
;
;	2960	GLOBAL ROUTINE dbg$save_bpt (location, action_addr, after_count) : NOVALUE =
;	2961	!++
;	2962	! Functional description:
;	2963	!	STORES THE BREAKPOINT OR TRACEPOINT address, opcode, AND OTHER INFORMATION
;	2964	!	IN THE BREAKPOINT TABLE.  The routine also checks
;	2965	!	that the insertion of BPTs, which we don't actually
;	2966	!	do till much later, will go OK, so that we can complain
;	2967	!	about the error to the user now instead of when
;	2968	!	he tries to start up this program.
;	2969	!
;	2970	!	This routine gets called from perform_cmd when the context bit
;	2971	!	[dbg$k_set_break] was set by the action routine, DBG$break_setup,
;	2972	!	which gets called when someone says "SET B addr".
;	2973	!
;	2974	! Input parameters:
;	2975	!	location	- THE address AT WHICH THE BREAK IS TO OCCUR
;	2976	!	action_addr	- THE address OF THE ACTION BUFFER (for BREAKs)
;	2977	!	after_count	- The /AFTER count (for BREAKs)
;	2978	!			- The size of the watchpoint for "typed" variables.
;	2979	!
;	2980	! Implicit inputs:
;	2981	!	-dbg$gl_bpthead IS THE address OF THE HEADER LINK IN THE
;	2982	!	BREAKPOINT LINKED LIST.
;	2983	!	-A context bit must be set to say which kind of
;	2984	!	 break/trace/watch point we are to SAVE.
;	2985	!
;	2986	! Output parameters:
;	2987	!	NONE
;	2988	!
;	2989	! Implicit outputs:
;	2990	!	NONE
;	2991	!
;	2992	! Routine value:
;	2993	!	NOVALUE
;	2994	!
;	2995	! Side effects:
;	2996	!	-INSERTS A NEW entry IN THE BREAKPOINT TABLE. 
;	2997	!	-Replaces the opcode INSTRUCTION WITH A BPT INSTRUCTION.
;	2998	!	-Causes an error message to be produced if either of the
;	2999	!	 above cannot be done OK.  In this case everything, including
;	3000	!	 protection codes, etc, remains as it was before the
;	3001	!	 call to this routine.
;	3002	!	-Except for the temporary breakpoint (from EXC - see above),
;	3003	!	DEBUG's '.' (dbg$gl_last_loc) gets set to the address on which
;	3004	!	the break/trace/watch point was set.
;	3005	!--
;	3006	
;	3007		BEGIN
;	3008	
;	3009		MAP
;	3010			location : REF VECTOR [, BYTE],
;	3011			action_addr : REF VECTOR [, BYTE];
;	3012	
;	3013		LOCAL
;	3014			adjus_location	: REF VECTOR [, BYTE],	! holds breakpoint's actual location

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-1
; Digital Equipment Corporation
;
;	3015			opcode		: BYTE,			! actual opcode at breakpoint
;	3016			entry,					! address of table entry
;	3017			prev_prot_one : BYTE,			! protection of starting byte
;	3018			prev_prot_two : BYTE,			! protection of ending byte
;	3019			length;					! length of watchpoint in bytes
;	3020	
;	3021	%IF dbg_brk
;     L 3022	%THEN
;     U 3023		$fao_tt_out ('setting break or trace at !XL', .location);
;     U 3024	%FI
;	3025	
;	3026		adjus_location = .location;
;	3027	
;	3028		!+
;	3029		! If the location of the break/tracepoint corresponds exactly to
;	3030		! the name of a routine, then set the actual breakpoint
;	3031		! at the routine's address plus the entry mask offset.
;	3032		!-
;	3033		IF .dbg$gl_context [dbg$k_trace] OR .dbg$gl_context [dbg$k_break]
;	3034		THEN IF dbg$is_it_entry (.adjus_location)
;	3035		THEN adjus_location = .adjus_location + 2;
;	3036	
;	3037		!+
;	3038		! See whether the location is readable. If not, a SIGNAL will
;	3039		! be generated and DEBUG unwound.
;	3040		!-
;	3041		dbg$read_access (.adjus_location, 1);
;	3042	
;	3043		!+
;	3044		! In the case of break/tracepoint, besides being readable now,
;	3045		! the location must also be writable later when we really want
;	3046		! to insert the BPT.  Check this by
;	3047		! writing what we know is there into there.  
;	3048		! (Since write_mem does all the changing and restoring
;	3049		!  of protection, etc).
;	3050		!-
;	3051		IF .dbg$gl_context [dbg$k_break] OR .dbg$gl_context [dbg$k_trace]
;	3052		THEN
;	3053			BEGIN
;	3054			opcode = .adjus_location[0];
;	3055	
;	3056	%IF dbg_brk
;     L 3057	%THEN
;     U 3058			$fao_tt_out('save_bpt: writing !XB into location !XL',
;     U 3059				.opcode,.adjus_location);
;     U 3060	%FI
;	3061	
;	3062			IF NOT dbg$write_mem (.adjus_location, opcode, 1)
;	3063			THEN
;	3064				BEGIN
;	3065				SIGNAL (DBG$_NOACCESSW, 1, .adjus_location);
;	3066				RETURN
;	3067				END;
;	3068			END
;	3069		ELSE

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-2
; Digital Equipment Corporation
;
;	3070			BEGIN
;	3071	
;	3072			!+
;	3073			! Try to set the protection of the watchpoint to
;	3074			! no write. If this fails, punt the
;	3075			! command. In the course of protection setting, calculate
;	3076			! the length of the watchpoint by calling a symbol table
;	3077			! routine. If a symbol name cannot be found, just use the
;	3078			! default length for the number of bytes.
;	3079			!-
;	3080			LOCAL
;	3081				addr_range	: VECTOR [2],		! holds addresses for $SETPRT
;	3082				sat_ptr		: REF sat_record;	! pointer to SAT entry
;	3083	%IF dbg_brk2
;     L 3084	%THEN
;     U 3085			$fao_tt_out ('setting watchpoint at !XL for !XL',
;     U 3086				.adjus_location, .after_count);
;     U 3087	%FI
;	3088			!+
;	3089			! The user is not permitted to set a watchpoint in P1 space
;	3090			!-
;	3091			IF (.adjus_location GEQA P1_SPACE) AND (.adjus_location LSSA SYSTEM_SPACE)
;	3092			THEN
;	3093				SIGNAL (DBG$_BADWATCH, 1, .adjus_location);
;	3094				! no return
;	3095	
;	3096			IF .after_count NEQ 0
;	3097			THEN
;	3098			    BEGIN
;	3099			    length = .after_count - 1;
;	3100			    END
;	3101			ELSE
;	3102			    length = 3;
;	3103	!		    length = .dbg$gb_mod_ptr [mode_length] - 1;
;	3104	
;	3105	%IF dbg_brk2
;     L 3106	%THEN
;     U 3107			$fao_tt_out ('length is !SL bytes, setting !XL to user read-only',
;     U 3108					.length+1, .adjus_location);
;     U 3109	%FI
;	3110	
;	3111			!+
;	3112			! Now set the protection on the starting byte. Save the
;	3113			! old protection in a local variable.
;	3114			!-
;	3115			addr_range [0] = .adjus_location;
;	3116			addr_range [1] = .adjus_location;
;	3117			IF NOT $SETPRT (inadr = addr_range,
;     P 3118					prot = prt$c_ur,
;     P 3119					prvprt = prev_prot_one)
;	3120			THEN
;	3121				BEGIN
;	3122				SIGNAL (DBG$_BADWATCH, 1, .adjus_location);
;	3123				RETURN
;	3124				END;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-3
; Digital Equipment Corporation
;
;	3125			
;	3126	%IF dbg_brk2
;     L 3127	%THEN
;     U 3128			$fao_tt_out ('old protection of start was !SL', .prev_prot_one);
;     U 3129	%FI
;	3130	
;	3131			!+
;	3132			! Now set the protection back to its original state. It
;	3133			! will be protected as requested just before the user
;	3134			! program starts.
;	3135			!-
;	3136			IF NOT $SETPRT (inadr = addr_range, prot = .prev_prot_one)
;	3137			THEN
;	3138				BEGIN
;	3139				SIGNAL (dbg$_nowprot);
;	3140				RETURN
;	3141				END;
;	3142	
;	3143			!+
;	3144			! If the final byte is on a different page, set the
;	3145			! protection of that page also. Save the old protection
;	3146			! in another local variable.
;	3147			!-
;	3148			IF (.adjus_location / bytes_per_page) NEQ
;	3149				((.adjus_location + .length) / bytes_per_page)
;	3150			THEN
;	3151				BEGIN
;	3152				addr_range [0] = .adjus_location + .length;
;	3153				addr_range [1] = .adjus_location + .length;
;	3154				IF NOT $SETPRT (inadr = addr_range,
;     P 3155						prot = prt$c_ur,
;     P 3156						prvprt = prev_prot_two)
;	3157				THEN
;	3158					BEGIN
;	3159					SIGNAL (DBG$_BADWATCH, 1, .adjus_location+.length-1);
;	3160					RETURN
;	3161					END;
;	3162		
;	3163				!+
;	3164				! Now reset protection to its original state.
;	3165				!-
;	3166				IF NOT $SETPRT (inadr = addr_range, prot = .prev_prot_two)
;	3167				THEN
;	3168					BEGIN
;	3169					SIGNAL (dbg$_nowprot);
;	3170					RETURN
;	3171					END;
;	3172				END
;	3173			ELSE prev_prot_two = .prev_prot_one;
;	3174	
;	3175	%IF dbg_brk2
;     L 3176	%THEN
;     U 3177			$fao_tt_out ('old protection of end was !SL', .prev_prot_two);
;     U 3178	%FI
;	3179	

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-4
; Digital Equipment Corporation
;
;	3180			END;
;	3181	
;	3182		!+
;	3183		! See if the break/trace/watchpoint is already set.
;	3184		!-
;	3185		IF (entry = dbg$find_bpt (.adjus_location)) EQL 0
;	3186	
;	3187		!+
;	3188		! IT WASN'T SET. TRY TO INSERT A NEW LINK IN THE BREAKPOINT CHAIN.
;	3189		!-
;	3190		THEN
;	3191			BEGIN
;	3192			entry = dbg$freez (overhead_bpt);
;	3193			INSQUE (.entry, .dbg$gl_bpthead);
;	3194			END;
;	3195	
;	3196		!+
;	3197		! THE NEW LINK IS MADE. NOW STORE THE APPROPRIATE INFORMATION.
;	3198		! THE opcode IS SAVED, THE address OF THE BREAKPOINT OR TRACEPOINT
;	3199		! IS SAVED, AND THE address OF THE ACTION BUFFER IS saved.
;	3200		!-
;	3201		IF .dbg$gl_context [dbg$k_trace]
;	3202		then
;	3203			begin
;	3204			bpt_type (.entry) = trace_point;
;	3205			bpt_aftc(.entry) = 1;
;	3206			end
;	3207		ELSE IF .dbg$gl_context [dbg$k_break]
;	3208		then
;	3209			begin
;	3210	
;	3211			! The type is BREAKpoint, and we initialize
;	3212			! the /AFTER count to what we were passed.
;	3213	
;	3214			bpt_type (.entry) = break_point;
;	3215	%if dbg_brk
;     L 3216	%then
;     U 3217			$fao_tt_out('after_count = !SL',.after_count);
;     U 3218	%FI
;	3219			! Fill in the after count field.  We note that
;	3220			! this field is only 1 word long, and that
;	3221			! it must be positive and signed.  After writing
;	3222			! this field in, we extract it again so that we
;	3223			! can inform the user of a possible number truncation.
;	3224	
;	3225			bpt_aftc(.entry) = .after_count<0,15,0>;
;	3226			
;	3227			IF( .bpt_aftc(.entry) neq .after_count )
;	3228			then
;	3229				signal(dbg$_numtrunc);
;	3230			end
;	3231		ELSE
;	3232			BEGIN
;	3233			bpt_type (.entry) = watch_point;
;	3234			bpt_accs (.entry) = write_watch;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-5
; Digital Equipment Corporation
;
;	3235			bpt_leng (.entry) = .length;
;	3236			bpt_pro1 (.entry) = .prev_prot_one;
;	3237			bpt_pro2 (.entry) = .prev_prot_two;
;	3238			END;
;	3239		IF .bpt_type (.entry) NEQ watch_point
;	3240		THEN
;	3241			BEGIN
;	3242			bpt_accs (.entry) = execute_watch;
;	3243			bpt_opco (.entry) = .adjus_location [opcode_byte];
;	3244			END;
;	3245		bpt_addr (.entry) = .adjus_location;
;	3246		bpt_aptr (.entry) = .action_addr;
;	3247		IF .action_addr NEQA 0
;	3248		THEN bpt_acnt (.entry) = .action_addr [0]
;	3249		ELSE bpt_acnt (.entry) = 0;
;	3250	
;	3251		!+
;	3252		! The DEBUG symbol '.', which corresponds to DBG$GL_LAST_LOC,
;	3253		! is supposed to get set to where a break/trace/watch point
;	3254		! has just been set.
;	3255		!-
;	3256		dbg$gl_last_loc = .adjus_location;
;	3257	
;	3258	END;





					 0E3C 002E8 	    .ENTRY  DBG$SAVE_BPT, Save R2,R3,R4,R5,R9,R10,R11		      ; 2960
		         59 00000000G  9F  9E 002EA 	    MOVAB   @#SYS$SETPRT, R9					      ;
		         5A 00000000G  00  9E 002F1 	    MOVAB   LIB$SIGNAL, R10					      ;
		         5B 00000000G  EF  9E 002F8 	    MOVAB   DBG$GL_CONTEXT, R11					      ;
		         5E	       14  C2 002FF 	    SUBL2   #20, SP						      ;
		         54	  04   AC  D0 00302 	    MOVL    LOCATION, ADJUS_LOCATION				      ; 3026
	   04	         6B	       01  E0 00306 	    BBS     #1, DBG$GL_CONTEXT, 1$				      ; 3033
	   0F	         6B	       02  E1 0030A 	    BBC     #2, DBG$GL_CONTEXT, 2$				      ;
				       54  DD 0030E 1$:     PUSHL   ADJUS_LOCATION					      ; 3034
	      00000000G  EF	       01  FB 00310 	    CALLS   #1, DBG$IS_IT_ENTRY					      ;
		         03	       50  E9 00317 	    BLBC    R0, 2$						      ;
		         54	       02  C0 0031A 	    ADDL2   #2, ADJUS_LOCATION					      ; 3035
				       01  DD 0031D 2$:     PUSHL   #1							      ; 3041
				       54  DD 0031F 	    PUSHL   ADJUS_LOCATION					      ;
	      00000000G  EF	       02  FB 00321 	    CALLS   #2, DBG$READ_ACCESS					      ;
	   04	         6B	       02  E0 00328 	    BBS     #2, DBG$GL_CONTEXT, 3$				      ; 3051
	   25	         6B	       01  E1 0032C 	    BBC     #1, DBG$GL_CONTEXT, 5$				      ;
		    08   AE	       64  90 00330 3$:     MOVB    (ADJUS_LOCATION), OPCODE				      ; 3054
				       01  DD 00334 	    PUSHL   #1							      ; 3062
				  0C   AE  9F 00336 	    PUSHAB  OPCODE						      ;
				       54  DD 00339 	    PUSHL   ADJUS_LOCATION					      ;
	      00000000G  EF	       03  FB 0033B 	    CALLS   #3, DBG$WRITE_MEM					      ;
		         03	       50  E9 00342 	    BLBC    R0, 4$						      ;
				     00C6  31 00345 	    BRW     15$							      ;
				       54  DD 00348 4$:     PUSHL   ADJUS_LOCATION					      ; 3065
				       01  DD 0034A 	    PUSHL   #1							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-6
; Digital Equipment Corporation
;
			    000282B0   8F  DD 0034C 	    PUSHL   #164528						      ;
				     0096  31 00352 	    BRW     11$							      ;
	      40000000   8F	       54  D1 00355 5$:     CMPL    ADJUS_LOCATION, #1073741824				      ; 3091
				       16  1F 0035C 	    BLSSU   6$							      ;
	      80000000   8F	       54  D1 0035E 	    CMPL    ADJUS_LOCATION, #-2147483648			      ;
				       0D  1E 00365 	    BGEQU   6$							      ;
				       54  DD 00367 	    PUSHL   ADJUS_LOCATION					      ; 3093
				       01  DD 00369 	    PUSHL   #1							      ;
			    000282D8   8F  DD 0036B 	    PUSHL   #164568						      ;
		         6A	       03  FB 00371 	    CALLS   #3, LIB$SIGNAL					      ;
				  0C   AC  D5 00374 6$:     TSTL    AFTER_COUNT						      ; 3096
				       07  13 00377 	    BEQL    7$							      ;
	   55	    0C   AC	       01  C3 00379 	    SUBL3   #1, AFTER_COUNT, LENGTH				      ; 3099
				       03  11 0037E 	    BRB     8$							      ; 3096
		         55	       03  D0 00380 7$:     MOVL    #3, LENGTH						      ; 3102
		    0C   AE	       54  D0 00383 8$:     MOVL    ADJUS_LOCATION, ADDR_RANGE				      ; 3115
		    10   AE	       54  D0 00387 	    MOVL    ADJUS_LOCATION, ADDR_RANGE+4			      ; 3116
				  04   AE  9F 0038B 	    PUSHAB  PREV_PROT_ONE					      ; 3119
				       0F  DD 0038E 	    PUSHL   #15							      ;
				       7E  7C 00390 	    CLRQ    -(SP)						      ;
				  1C   AE  9F 00392 	    PUSHAB  ADDR_RANGE						      ;
		         69	       05  FB 00395 	    CALLS   #5, SYS$SETPRT					      ;
		         04	       50  E8 00398 	    BLBS    R0, 9$						      ;
				       54  DD 0039B 	    PUSHL   ADJUS_LOCATION					      ; 3122
				       44  11 0039D 	    BRB     10$							      ;
				       7E  D4 0039F 9$:     CLRL    -(SP)						      ; 3136
		         7E	  08   AE  9A 003A1 	    MOVZBL  PREV_PROT_ONE, -(SP)				      ;
				       7E  7C 003A5 	    CLRQ    -(SP)						      ;
				  1C   AE  9F 003A7 	    PUSHAB  ADDR_RANGE						      ;
		         69	       05  FB 003AA 	    CALLS   #5, SYS$SETPRT					      ;
		         50	       50  E9 003AD 	    BLBC    R0, 13$						      ;
	   51	         54 00000200   8F  C7 003B0 	    DIVL3   #512, ADJUS_LOCATION, R1				      ; 3148
	   52	         54	       55  C1 003B8 	    ADDL3   LENGTH, ADJUS_LOCATION, R2				      ; 3149
	   50	         52 00000200   8F  C7 003BC 	    DIVL3   #512, R2, R0					      ;
		         50	       51  D1 003C4 	    CMPL    R1, R0						      ; 3148
				       41  13 003C7 	    BEQL    14$							      ;
		    0C   AE	       52  D0 003C9 	    MOVL    R2, ADDR_RANGE					      ; 3152
		    10   AE	       52  D0 003CD 	    MOVL    R2, ADDR_RANGE+4					      ; 3153
				       5E  DD 003D1 	    PUSHL   SP							      ; 3156
				       0F  DD 003D3 	    PUSHL   #15							      ;
				       7E  7C 003D5 	    CLRQ    -(SP)						      ;
				  1C   AE  9F 003D7 	    PUSHAB  ADDR_RANGE						      ;
		         69	       05  FB 003DA 	    CALLS   #5, SYS$SETPRT					      ;
		         0F	       50  E8 003DD 	    BLBS    R0, 12$						      ;
				  FF   A2  9F 003E0 	    PUSHAB  -1(R2)						      ; 3159
				       01  DD 003E3 10$:    PUSHL   #1							      ;
			    000282D8   8F  DD 003E5 	    PUSHL   #164568						      ;
		         6A	       03  FB 003EB 11$:    CALLS   #3, LIB$SIGNAL					      ;
					   04 003EE 	    RET     							      ; 3160
				       7E  D4 003EF 12$:    CLRL    -(SP)						      ; 3166
		         7E	  04   AE  9A 003F1 	    MOVZBL  PREV_PROT_TWO, -(SP)				      ;
				       7E  7C 003F5 	    CLRQ    -(SP)						      ;
				  1C   AE  9F 003F7 	    PUSHAB  ADDR_RANGE						      ;
		         69	       05  FB 003FA 	    CALLS   #5, SYS$SETPRT					      ;
		         0E	       50  E8 003FD 	    BLBS    R0, 15$						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-7
; Digital Equipment Corporation
;
			    000284C4   8F  DD 00400 13$:    PUSHL   #165060						      ; 3169
		         6A	       01  FB 00406 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 00409 	    RET     							      ; 3170
		         6E	  04   AE  90 0040A 14$:    MOVB    PREV_PROT_ONE, PREV_PROT_TWO			      ; 3173
				       54  DD 0040E 15$:    PUSHL   ADJUS_LOCATION					      ; 3185
		  FBEB   CF	       01  FB 00410 	    CALLS   #1, DBG$FIND_BPT					      ;
		         52	       50  D0 00415 	    MOVL    R0, ENTRY						      ;
				       13  12 00418 	    BNEQ    16$							      ;
				       06  DD 0041A 	    PUSHL   #6							      ; 3192
	      00000000G  EF	       01  FB 0041C 	    CALLS   #1, DBG$FREEZ					      ;
		         52	       50  D0 00423 	    MOVL    R0, ENTRY						      ;
	      00000000G  FF	       62  0E 00426 	    INSQUE  (ENTRY), @DBG$GL_BPTHEAD				      ; 3193
		         53	  10   A2  9E 0042D 16$:    MOVAB   16(ENTRY), R3					      ; 3204
	   0B	         6B	       01  E1 00431 	    BBC     #1, DBG$GL_CONTEXT, 17$				      ; 3201
	   02	         11	       02  F0 00435 	    INSV    #2, #17, #2, (R3)					      ; 3204
				       63     00439									      ;
		    0C   A2	       01  B0 0043A 	    MOVW    #1, 12(ENTRY)					      ; 3205
				       3F  11 0043E 	    BRB     19$							      ; 3201
	   23	         6B	       02  E1 00440 17$:    BBC     #2, DBG$GL_CONTEXT, 18$				      ; 3207
	   02	         11	       01  F0 00444 	    INSV    #1, #17, #2, (R3)					      ; 3214
				       63     00448									      ;
      0C   AC	         0F	       00  EF 00449 	    EXTZV   #0, #15, AFTER_COUNT, R0				      ; 3225
				       50     0044E									      ;
		    0C   A2	       50  B0 0044F 	    MOVW    R0, 12(ENTRY)					      ;
      0C   A2	         10	       00  EC 00453 	    CMPV    #0, #16, 12(ENTRY), AFTER_COUNT			      ; 3227
				  0C   AC     00458									      ;
				       23  13 0045A 	    BEQL    19$							      ;
			    0002805B   8F  DD 0045C 	    PUSHL   #163931						      ; 3229
		         6A	       01  FB 00462 	    CALLS   #1, LIB$SIGNAL					      ;
				       18  11 00465 	    BRB     19$							      ; 3207
		    02   A3	       06  88 00467 18$:    BISB2   #6, 2(R3)						      ; 3233
	   02	         13	       01  F0 0046B 	    INSV    #1, #19, #2, (R3)					      ; 3234
				       63     0046F									      ;
		         63	       55  90 00470 	    MOVB    LENGTH, (R3)					      ; 3235
	   04	         00	  04   AE  F0 00473 	    INSV    PREV_PROT_ONE, #0, #4, 3(R3)			      ; 3236
				  03   A3     00478									      ;
	   04	         1C	       6E  F0 0047A 	    INSV    PREV_PROT_TWO, #28, #4, (R3)			      ; 3237
				       63     0047E									      ;
	   63	         02	       11  ED 0047F 19$:    CMPZV   #17, #2, (R3), #3					      ; 3239
				       03     00483									      ;
				       08  13 00484 	    BEQL    20$							      ;
		    02   A3	       18  88 00486 	    BISB2   #24, 2(R3)						      ; 3242
		    03   A3	       64  90 0048A 	    MOVB    (ADJUS_LOCATION), 3(R3)				      ; 3243
		    08   A2	       54  D0 0048E 20$:    MOVL    ADJUS_LOCATION, 8(ENTRY)				      ; 3245
		    14   A2	  08   AC  D0 00492 	    MOVL    ACTION_ADDR, 20(ENTRY)				      ; 3246
				       07  13 00497 	    BEQL    21$							      ; 3247
		    0E   A2	  08   BC  9B 00499 	    MOVZBW  @ACTION_ADDR, 14(ENTRY)				      ; 3248
				       03  11 0049E 	    BRB     22$							      ; 3247
				  0E   A2  B4 004A0 21$:    CLRW    14(ENTRY)						      ; 3249
	      00000000G  EF	       54  D0 004A3 22$:    MOVL    ADJUS_LOCATION, DBG$GL_LAST_LOC			      ; 3256
					   04 004AA 	    RET     							      ; 2960

; Routine Size:  451 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 10-8
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 11
; Digital Equipment Corporation
;
;	3259	ROUTINE IS_ARRAY_ELEM( SAT_PTR ) =
;	3260	!++
;	3261	! Functional Description:
;	3262	!
;	3263	!	Given a SAT pointer which corresponds to an area that
;	3264	!	a watchpoint is begin set in, deduce if the WATCH
;	3265	!	is to an array element, and if so, return the length
;	3266	!	in bytes, that are to be watched.  Otherwise return 0
;	3267	!	and let the calling routine figure out what to do.
;	3268	!
;	3269	! Formal Parameters:
;	3270	!
;	3271	!	SAT_PTR	-Pointer to the SAT record which corresponds
;	3272	!		 to the watched area.
;	3273	!
;	3274	! Implicit Inputs:
;	3275	!
;	3276	! Implicit Outputs:
;	3277	!
;	3278	! Outputs:
;	3279	!	0, if this watch is not to an array element,
;	3280	!	LENGTH, in bytes, to watch, otherwise.
;	3281	!
;	3282	! Side Effects:
;	3283	!
;	3284	!	The DST is 'positioned' to the record which
;	3285	!	corresponds to the SAT record.
;	3286	!--
;	3287	
;	3288	BEGIN
;	3289	%IF 0				! THIS ROUTINE NOT USED FOR RELEASE 1
;     L 3290	%THEN
;     U 3291		MAP
;     U 3292			SAT_PTR : ref SAT_RECORD;
;     U 3293		LOCAL
;     U 3294			NT_PTR : ref NT_RECORD,
;     U 3295			descriptor : REF BLOCK[,BYTE],
;     U 3296			dst_recrd : ref dst_record;
;     U 3297	
;     U 3298		! Pick up the NT pointer for the
;     U 3299		! indicated symbol, and check that this
;     U 3300		! is not a global symbol because you can't
;     U 3301		! look at the DST for globals.
;     U 3302	
;     U 3303		NT_PTR = .SAT_PTR[ SAT_NT_PTR ];
;     U 3304	
;     U 3305		IF( .NT_PTR[ NT_UP_SCOPE ] EQL 0 )
;     U 3306		THEN
;     U 3307			! This is a global.
;     U 3308	
;     U 3309			RETURN(0);
;     U 3310	
;     U 3311		! Pick up the value associated with this symbol.
;     U 3312		! If this is really an array, the value is
;     U 3313		! actually the address of the descriptor.

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 11-1
; Digital Equipment Corporation
;
;     U 3314	
;     U 3315		IF( NOT DBG$SYMBOL_VALU( .NT_PTR, DESCRIPTOR ) )
;     U 3316		THEN
;     U 3317			! An invaluable symbol!
;     U 3318	
;     U 3319			RETURN(0);
;     U 3320	
;     U 3321		! Go to the DST to see if the access
;     U 3322		! type for this symbol is via descriptor.
;     U 3323	
;     U 3324		dst_recrd = .nt_ptr[ nt_dst_ptr ];
;     U 3325		if( .dst_recrd[ dstr_acces_type ] NEQ accs_descriptor )
;     U 3326		then
;     U 3327			! This is not an array.
;     U 3328	
;     U 3329			RETURN(0);
;     U 3330	
;     U 3331		! Check that the descriptor is actually for an array.
;     U 3332	
;     U 3333		IF( (.DESCRIPTOR[ DSC$B_CLASS ] NEQ DSC$K_CLASS_A )
;     U 3334		   AND
;     U 3335		    (.descriptor[ dsc$B_class ] NEQ DSC$K_CLASS_S )
;     U 3336		  )
;     U 3337		THEN
;     U 3338	
;     U 3339			RETURN(0);
;     U 3340	
;     U 3341		! Return the element length in bytes.
;     U 3342	
;     U 3343		RETURN( .DESCRIPTOR[ DSC$W_LENGTH ] );
;     U 3344	%FI
;	3345	END;





					 0000 004AB IS_ARRAY_ELEM:
							    .WORD   Save nothing					      ; 3259
				       50  D4 004AD 	    CLRL    R0							      ;
					   04 004AF 	    RET     							      ;

; Routine Size:  5 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 12
; Digital Equipment Corporation
;
;	3346	GLOBAL ROUTINE dbg$show_bpts : NOVALUE =
;	3347	!++
;	3348	! Functional description:
;	3349	!	Displays all user-set BREAK/TRACE/WATCH points, and their
;	3350	!	status, and for SHOW TRACE, reports on any opcode
;	3351	!	tracing which may be in effect.
;	3352	!
;	3353	! Input parameters:
;	3354	!	NONE
;	3355	!
;	3356	! Implicit inputs:
;	3357	!	dbg$gl_bpthead, THE HEADER LINK IN THE BREAKPOINT CHAIN.
;	3358	!
;	3359	! Output parameters:
;	3360	!	NONE
;	3361	!
;	3362	! Implicit outputs:
;	3363	!	NONE
;	3364	!
;	3365	! Routine value:
;	3366	!	NOVALUE
;	3367	!
;	3368	! Side effects:
;	3369	!	Either the report or an error message is issued.
;	3370	!--
;	3371	
;	3372		BEGIN
;	3373	
;	3374		LOCAL
;	3375			output_buffer : VECTOR[ TTY_OUT_WIDTH, BYTE],
;	3376			found_one,
;	3377			entry;
;	3378	
;	3379	%IF dbg_brk1
;     L 3380	%THEN
;     U 3381		$fao_tt_out ('showing breakpoints');
;     U 3382	%FI
;	3383	
;	3384		found_one = FALSE;
;	3385		entry = .dll_rlink (.dbg$gl_bpthead);
;	3386	
;	3387		WHILE .entry NEQA .dbg$gl_bpthead
;	3388		DO
;	3389			BEGIN
;	3390			LOCAL
;	3391				at_pc,
;	3392				ENTRY_CS : CS_POINTER;
;	3393	
;	3394			! Set up to do standard DEBUG I/O
;	3395	
;	3396			dbg$cp_out_str = output_buffer +1;
;	3397			dbg$gl_buf_siz = 0;
;	3398			!+
;	3399			! See if the break or trace point is
;	3400			! on a routine entry point.  If this is true, 

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 12-1
; Digital Equipment Corporation
;
;	3401			! then we must have set the BPT on 2 bytes past
;	3402			! where the routine begins.  In this case
;	3403			! we perpend the message with 'routine ', 
;	3404			! and announce (symbolically or otherwise)
;	3405			! the break_at address 2 less than what it
;	3406			! really is.  This is done so that
;	3407			! what we announce is the same thing you gave to
;	3408			! set the break, and is the same as what you give
;	3409			! to cancel the break.
;	3410			!-
;	3411			entry_cs = uplit(%ascic '');  ! empty string
;	3412			at_pc = .bpt_addr(.entry);
;	3413	
;	3414			IF ( dbg$is_it_entry( .bpt_addr(.entry) -2 ) )
;	3415			THEN
;	3416				BEGIN
;	3417				at_pc = .at_pc -2;
;	3418				entry_cs = uplit(%ascic 'routine ');
;	3419				END;
;	3420	
;	3421			SELECTONE TRUE OF
;	3422			    SET
;	3423	
;	3424			    [.dbg$gl_context[dbg$k_break]]:
;	3425				IF (.bpt_type (.entry) EQL break_point)
;	3426				THEN
;	3427					BEGIN
;	3428					dbg$fao_put( UPLIT( %ASCIC '!ACbreakpoint ' ),.entry_cs);
;	3429	
;	3430					! Report unusual /AFTER counts.
;	3431	
;	3432					IF( .BPT_AFTC(.ENTRY) NEQ 1 )
;	3433					THEN
;	3434						dbg$fao_put( uplit( %ascic '/after:!SW '),.bpt_aftc(.entry));
;	3435					dbg$fao_put( uplit( %ascic 'at '));
;	3436					dbg$out_sym_val( .at_pc, long_length, no_override);
;	3437	
;	3438					! See if there is an action buffer
;	3439	
;	3440					IF( .BPT_ACNT( .entry ) NEQ 0 )
;	3441					THEN
;	3442						dbg$fao_put( UPLIT( %ASCIC ' do (!AC)'),
;	3443							.BPT_APTR(.entry));
;	3444					found_one = TRUE;
;	3445					dbg$out_put (output_buffer);
;	3446					END;
;	3447	
;	3448			    [.dbg$gl_context[dbg$k_trace]]:
;	3449				IF (.bpt_type (.entry) EQL trace_point)
;	3450				THEN
;	3451					BEGIN
;	3452					dbg$fao_put( UPLIT( %ASCIC '!ACtracepoint at ' ),.entry_cs);
;	3453					dbg$out_sym_val( .at_pc, long_length, no_override);
;	3454					found_one = TRUE;
;	3455					dbg$out_put (output_buffer);

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 12-2
; Digital Equipment Corporation
;
;	3456					END;
;	3457	
;	3458			    [.dbg$gl_context[dbg$k_watch]]:
;	3459				IF (.bpt_type (.entry) EQL watch_point)
;	3460				THEN
;	3461					BEGIN
;	3462					dbg$fao_put (UPLIT (%ASCIC 'watchpoint at '));
;	3463					dbg$out_sym_val (.bpt_addr (.entry), long_length, no_override);
;	3464					dbg$fao_put (UPLIT (%ASCIC ' for !UW. bytes.'),.bpt_leng(.entry)+1);
;	3465	!				dbg$out_num_val (.bpt_leng (.entry), no_override, no_override);
;	3466	!				dbg$fao_put (UPLIT (%ASCIC ' bytes.'));
;	3467					found_one = TRUE;
;	3468					dbg$out_put (output_buffer);
;	3469					END;
;	3470			    TES;
;	3471	
;	3472			entry = .dll_rlink (.entry);
;	3473			END;
;	3474		SELECTONE TRUE OF
;	3475		    SET
;	3476	
;	3477		    [.dbg$gl_context[dbg$k_break]]:
;	3478			BEGIN
;	3479			IF NOT .found_one
;	3480			THEN SIGNAL (dbg$_nobreaks);
;	3481			RETURN
;	3482			END;
;	3483	
;	3484		    [.dbg$gl_context[dbg$k_watch]]:
;	3485			BEGIN
;	3486			IF NOT .found_one
;	3487			THEN SIGNAL (dbg$_nowatches);
;	3488			RETURN
;	3489			END;
;	3490	
;	3491		    [.dbg$gl_context[dbg$k_trace]]:
;	3492			BEGIN
;	3493			IF .found_one
;	3494			THEN	dbg$sho_optrace()
;	3495			ELSE
;	3496				IF ( NOT dbg$sho_optrace() )
;	3497				THEN	SIGNAL (dbg$_notraces);
;	3498					! no return
;	3499			RETURN
;	3500			END;
;	3501		    TES;
;	3502		END;



							    .PSECT  DBG$PLIT,NOWRT,  SHR,  PIC,0

					      00000 P.AAA:  .ASCII  <0><0><0><0>					      ;
					      00004 P.AAB:  .ASCII  <8>\routine \<0><0><0>				      ;
					      00010 P.AAC:  .ASCII  <14>\!ACbreakpoint \<0>				      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 12-3
; Digital Equipment Corporation
;
					      00020 P.AAD:  .ASCII  <11>\/after:!SW \					      ;
					      0002C P.AAE:  .ASCII  <3>\at \						      ;
					      00030 P.AAF:  .ASCII  <9>\ do (!AC)\<0><0>				      ;
					      0003C P.AAG:  .ASCII  <17>\!ACtracepoint at \<0><0>			      ;
					      00050 P.AAH:  .ASCII  <14>\watchpoint at \<0>				      ;
					      00060 P.AAI:  .ASCII  <16>\ for !UW. bytes.\<0><0><0>			      ;



							    .PSECT  DBG$CODE,NOWRT,  SHR,  PIC,0

					 0FBC 004B0 	    .ENTRY  DBG$SHOW_BPTS, Save R2,R3,R4,R5,R7,R8,R9,R10,R11	      ; 3346
		         57 00000000G  EF  9E 004B2 	    MOVAB   DBG$SHO_OPTRACE, R7					      ;
		         58 00000000G  EF  9E 004B9 	    MOVAB   DBG$OUT_SYM_VAL, R8					      ;
		         59 00000000G  EF  9E 004C0 	    MOVAB   DBG$FAO_PUT, R9					      ;
		         5A 00000000G  EF  9E 004C7 	    MOVAB   DBG$GL_CONTEXT, R10					      ;
		         5B 00000000'  EF  9E 004CE 	    MOVAB   P.AAA, R11						      ;
		         5E	FF7C   CE  9E 004D5 	    MOVAB   -132(SP), SP					      ;
				       55  D4 004DA 	    CLRL    FOUND_ONE						      ; 3384
		         52 00000000G  FF  D0 004DC 	    MOVL    @DBG$GL_BPTHEAD, ENTRY				      ; 3385
	      00000000G  EF	       52  D1 004E3 1$:     CMPL    ENTRY, DBG$GL_BPTHEAD				      ; 3387
				       03  12 004EA 	    BNEQ    2$							      ;
				     00C2  31 004EC 	    BRW     11$							      ;
	      00000000G  EF	  01   AE  9E 004EF 2$:     MOVAB   OUTPUT_BUFFER+1, DBG$CP_OUT_STR			      ; 3396
			    00000000G  EF  D4 004F7 	    CLRL    DBG$GL_BUF_SIZ					      ; 3397
		         54	       6B  9E 004FD 	    MOVAB   P.AAA, ENTRY_CS					      ; 3411
		         53	  08   A2  D0 00500 	    MOVL    8(ENTRY), AT_PC					      ; 3412
	   7E	    08   A2	       02  C3 00504 	    SUBL3   #2, 8(ENTRY), -(SP)					      ; 3414
	      00000000G  EF	       01  FB 00509 	    CALLS   #1, DBG$IS_IT_ENTRY					      ;
		         07	       50  E9 00510 	    BLBC    R0, 3$						      ;
		         53	       02  C2 00513 	    SUBL2   #2, AT_PC						      ; 3417
		         54	  04   AB  9E 00516 	    MOVAB   P.AAB, ENTRY_CS					      ; 3418
	   3B	         6A	       02  E1 0051A 3$:     BBC     #2, DBG$GL_CONTEXT, 5$				      ; 3421
      12   A2	         02	       01  ED 0051E 	    CMPZV   #1, #2, 18(ENTRY), #1				      ; 3425
				       01     00523									      ;
				       5C  12 00524 	    BNEQ    7$							      ;
				       54  DD 00526 	    PUSHL   ENTRY_CS						      ; 3428
				  10   AB  9F 00528 	    PUSHAB  P.AAC						      ;
		         69	       02  FB 0052B 	    CALLS   #2, DBG$FAO_PUT					      ;
		         01	  0C   A2  B1 0052E 	    CMPW    12(ENTRY), #1					      ; 3432
				       0A  13 00532 	    BEQL    4$							      ;
		         7E	  0C   A2  32 00534 	    CVTWL   12(ENTRY), -(SP)					      ; 3434
				  20   AB  9F 00538 	    PUSHAB  P.AAD						      ;
		         69	       02  FB 0053B 	    CALLS   #2, DBG$FAO_PUT					      ;
				  2C   AB  9F 0053E 4$:     PUSHAB  P.AAE						      ; 3435
		         69	       01  FB 00541 	    CALLS   #1, DBG$FAO_PUT					      ;
		         7E	       04  7D 00544 	    MOVQ    #4, -(SP)						      ; 3436
				       53  DD 00547 	    PUSHL   AT_PC						      ;
		         68	       03  FB 00549 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;
				  0E   A2  B5 0054C 	    TSTW    14(ENTRY)						      ; 3440
				       4E  13 0054F 	    BEQL    9$							      ;
				  14   A2  DD 00551 	    PUSHL   20(ENTRY)						      ; 3442
				  30   AB  9F 00554 	    PUSHAB  P.AAF						      ;
				       43  11 00557 	    BRB     8$							      ;
	   1A	         6A	       01  E1 00559 5$:     BBC     #1, DBG$GL_CONTEXT, 6$				      ; 3421

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 12-4
; Digital Equipment Corporation
;
      12   A2	         02	       01  ED 0055D 	    CMPZV   #1, #2, 18(ENTRY), #2				      ; 3449
				       02     00562									      ;
				       46  12 00563 	    BNEQ    10$							      ;
				       54  DD 00565 	    PUSHL   ENTRY_CS						      ; 3452
				  3C   AB  9F 00567 	    PUSHAB  P.AAG						      ;
		         69	       02  FB 0056A 	    CALLS   #2, DBG$FAO_PUT					      ;
		         7E	       04  7D 0056D 	    MOVQ    #4, -(SP)						      ; 3453
				       53  DD 00570 	    PUSHL   AT_PC						      ;
		         68	       03  FB 00572 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;
				       28  11 00575 	    BRB     9$							      ; 3454
	   2F	    01   AA	       06  E1 00577 6$:     BBC     #6, DBG$GL_CONTEXT+1, 10$				      ; 3421
      12   A2	         02	       01  ED 0057C 	    CMPZV   #1, #2, 18(ENTRY), #3				      ; 3459
				       03     00581									      ;
				       27  12 00582 7$:     BNEQ    10$							      ;
				  50   AB  9F 00584 	    PUSHAB  P.AAH						      ; 3462
		         69	       01  FB 00587 	    CALLS   #1, DBG$FAO_PUT					      ;
		         7E	       04  7D 0058A 	    MOVQ    #4, -(SP)						      ; 3463
				  08   A2  DD 0058D 	    PUSHL   8(ENTRY)						      ;
		         68	       03  FB 00590 	    CALLS   #3, DBG$OUT_SYM_VAL					      ;
		         7E	  10   A2  9A 00593 	    MOVZBL  16(ENTRY), -(SP)					      ; 3464
				       6E  D6 00597 	    INCL    (SP)						      ;
				  60   AB  9F 00599 	    PUSHAB  P.AAI						      ;
		         69	       02  FB 0059C 8$:     CALLS   #2, DBG$FAO_PUT					      ;
		         55	       01  D0 0059F 9$:     MOVL    #1, FOUND_ONE					      ; 3467
				       5E  DD 005A2 	    PUSHL   SP							      ; 3468
	      00000000G  EF	       01  FB 005A4 	    CALLS   #1, DBG$OUT_PUT					      ;
		         52	       62  D0 005AB 10$:    MOVL    (ENTRY), ENTRY					      ; 3472
				     FF32  31 005AE 	    BRW     1$							      ; 3387
	   0B	         6A	       02  E1 005B1 11$:    BBC     #2, DBG$GL_CONTEXT, 12$				      ; 3474
		         36	       55  E8 005B5 	    BLBS    FOUND_ONE, 16$					      ; 3479
			    0002802B   8F  DD 005B8 	    PUSHL   #163883						      ; 3480
				       27  11 005BE 	    BRB     15$							      ;
	   0B	    01   AA	       06  E1 005C0 12$:    BBC     #6, DBG$GL_CONTEXT+1, 13$				      ; 3474
		         26	       55  E8 005C5 	    BLBS    FOUND_ONE, 16$					      ; 3486
			    00028053   8F  DD 005C8 	    PUSHL   #163923						      ; 3487
				       17  11 005CE 	    BRB     15$							      ;
	   1A	         6A	       01  E1 005D0 13$:    BBC     #1, DBG$GL_CONTEXT, 16$				      ; 3474
		         04	       55  E9 005D4 	    BLBC    FOUND_ONE, 14$					      ; 3493
		         67	       00  FB 005D7 	    CALLS   #0, DBG$SHO_OPTRACE					      ; 3494
					   04 005DA 	    RET     							      ; 3493
		         67	       00  FB 005DB 14$:    CALLS   #0, DBG$SHO_OPTRACE					      ; 3496
		         0D	       50  E8 005DE 	    BLBS    R0, 16$						      ;
			    0002804B   8F  DD 005E1 	    PUSHL   #163915						      ; 3497
	      00000000G  00	       01  FB 005E7 15$:    CALLS   #1, LIB$SIGNAL					      ;
					   04 005EE 16$:    RET     							      ; 3346

; Routine Size:  319 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 13
; Digital Equipment Corporation
;
;	3503	GLOBAL ROUTINE dbg$cancel_bpt (break_address) : NOVALUE =
;	3504	!++
;	3505	! Functional description:
;	3506	!	This routine will cancel the break, trace, or watchpoint at the user
;	3507	!	specified address.  It also has the capability of canceling all the
;	3508	!	break, trace, and watchpoints or any one group of them.
;	3509	!
;	3510	!
;	3511	! Input parameters:
;	3512	!	break_address	- The address of the break, trace, or watchpoint to
;	3513	!			  be canceled.
;	3514	!			- This input may be one of four literal values, indicating
;	3515	!			  special operation.
;	3516	!	"all_bpts"	- cancel all breakpoints, tracepoints, and watchpoints.
;	3517	!	"all_break"	_ cancel all breakpoints.
;	3518	!	"all_trace"	- cancel all tracepoints.
;	3519	!	"all_watch"	- cancel all watchpoints.
;	3520	!
;	3521	! Implicit inputs:
;	3522	!	THE LINKED LIST that IS THE BREAKPOINT TABLE, WHICH IS
;	3523	!	POINTED TO BY dbg$gl_bpthead.
;	3524	!
;	3525	! Implicit outputs:
;	3526	!	LINKS IN THE BREAKPOINT CHAIN ARE READJUSTED.
;	3527	!
;	3528	! Routine value:
;	3529	!	NOVALUE
;	3530	!
;	3531	! Side effects:
;	3532	!	ONE OR ALL BREAKPOINTS ARE SWITCHED
;	3533	!--
;	3534	
;	3535		BEGIN
;	3536	
;	3537		LOCAL
;	3538			error_code,	! Holds the potential siganl code.
;	3539			entry,		! HOLDS CURRENT entry
;	3540			next_entry;	! HOLDS STORAGE address OF NEXT entry
;	3541	
;	3542	%IF dbg_brk
;     L 3543	%THEN
;     U 3544		$fao_tt_out ('canceling breakpoints');
;     U 3545	%FI
;	3546		! Calculate the error code we will SIGNAL.
;	3547	
;	3548		error_code = 	(IF .dbg$gl_context [dbg$k_break]
;	3549				THEN dbg$_nosuchbpt
;	3550				ELSE IF .dbg$gl_context [dbg$k_watch]
;	3551				THEN dbg$_nosuchwpt
;	3552				ELSE dbg$_nosuchtpt);
;	3553	
;	3554		entry = .dll_rlink (.dbg$gl_bpthead);	! Pick up the first element
;	3555	
;	3556		!++
;	3557		! Examine each breakpoint in the breakpoint chain. If it matches

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 13-1
; Digital Equipment Corporation
;
;	3558		! the breakpoint (s) specified to be canceled, then cancel it.
;	3559		! Otherwise go on to the next. If the end of the chain is reached,
;	3560		! return. Also return after canceling a single breakpoint if only
;	3561		! that was specified.
;	3562		!--
;	3563		WHILE .entry NEQ .dbg$gl_bpthead
;	3564		DO
;	3565			BEGIN
;	3566			next_entry = .dll_rlink (.entry);
;	3567			IF .break_address EQL .bpt_addr (.entry)
;	3568			THEN
;	3569				BEGIN
;	3570				IF (.dbg$gl_context [dbg$k_break] AND (.bpt_type (.entry) EQL break_point))
;	3571				OR (.dbg$gl_context [dbg$k_trace] AND (.bpt_type (.entry) EQL trace_point))
;	3572				OR (.dbg$gl_context [dbg$k_watch] AND (.bpt_type (.entry) EQL watch_point))
;	3573				THEN
;	3574					BEGIN
;	3575					free_a_breakpt (.entry);
;	3576					RETURN
;	3577					END
;	3578				ELSE
;	3579					BEGIN
;	3580					SIGNAL(.error_code);
;	3581					! no return
;	3582					RETURN
;	3583					END;
;	3584				END
;	3585			ELSE
;	3586				BEGIN
;	3587				SELECTONE .break_address OF
;	3588				SET
;	3589				[all_bpts]:	free_a_breakpt (.entry);
;	3590	
;	3591				[-2]:		IF (.bpt_type (.entry) EQL break_point)
;	3592						THEN free_a_breakpt (.entry);
;	3593	
;	3594				[-3]:		IF (.bpt_type (.entry) EQL trace_point)
;	3595						THEN free_a_breakpt (.entry);
;	3596	
;	3597				[-4]:		IF (.bpt_type (.entry) EQL watch_point)
;	3598						THEN free_a_breakpt (.entry);
;	3599				TES;
;	3600				END;
;	3601			entry = .next_entry;
;	3602			END;
;	3603	
;	3604		IF .break_address LSSU -4
;	3605		THEN  SIGNAL (.error_code);
;	3606	
;	3607		END;






; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 13-2
; Digital Equipment Corporation
;
					 0C3C 005EF 	    .ENTRY  DBG$CANCEL_BPT, Save R2,R3,R4,R5,R10,R11		      ; 3503
		         5A 00000000G  EF  9E 005F1 	    MOVAB   DBG$FREERELEASE, R10				      ;
		         5B 00000000G  EF  9E 005F8 	    MOVAB   DBG$GL_CONTEXT, R11					      ;
	   09	         6B	       02  E1 005FF 	    BBC     #2, DBG$GL_CONTEXT, 1$				      ; 3548
		         54 00028033   8F  D0 00603 	    MOVL    #163891, ERROR_CODE					      ;
				       15  11 0060A 	    BRB     3$							      ;
	   09	    01   AB	       06  E1 0060C 1$:     BBC     #6, DBG$GL_CONTEXT+1, 2$				      ; 3550
		         54 00028043   8F  D0 00611 	    MOVL    #163907, ERROR_CODE					      ;
				       07  11 00618 	    BRB     3$							      ;
		         54 0002803B   8F  D0 0061A 2$:     MOVL    #163899, ERROR_CODE					      ;
		         52 00000000G  FF  D0 00621 3$:     MOVL    @DBG$GL_BPTHEAD, ENTRY				      ; 3554
	      00000000G  EF	       52  D1 00628 4$:     CMPL    ENTRY, DBG$GL_BPTHEAD				      ; 3563
				       03  12 0062F 	    BNEQ    5$							      ;
				     00BF  31 00631 	    BRW     20$							      ;
		         55	       62  D0 00634 5$:     MOVL    (ENTRY), NEXT_ENTRY					      ; 3566
		         53	  04   AC  D0 00637 	    MOVL    BREAK_ADDRESS, R3					      ; 3567
		    08   A2	       53  D1 0063B 	    CMPL    R3, 8(ENTRY)					      ;
				       4D  12 0063F 	    BNEQ    13$							      ;
	   08	         6B	       02  E1 00641 	    BBC     #2, DBG$GL_CONTEXT, 6$				      ; 3570
      12   A2	         02	       01  ED 00645 	    CMPZV   #1, #2, 18(ENTRY), #1				      ;
				       01     0064A									      ;
				       1C  13 0064B 	    BEQL    10$							      ;
	   08	         6B	       01  E1 0064D 6$:     BBC     #1, DBG$GL_CONTEXT, 7$				      ; 3571
      12   A2	         02	       01  ED 00651 	    CMPZV   #1, #2, 18(ENTRY), #2				      ;
				       02     00656									      ;
				       10  13 00657 	    BEQL    10$							      ;
	   03	    01   AB	       06  E0 00659 7$:     BBS     #6, DBG$GL_CONTEXT+1, 9$				      ; 3572
				     009C  31 0065E 8$:     BRW     21$							      ;
      12   A2	         02	       01  ED 00661 9$:     CMPZV   #1, #2, 18(ENTRY), #3				      ;
				       03     00666									      ;
				       F5  12 00667 	    BNEQ    8$							      ;
				  14   A2  D5 00669 10$:    TSTL    20(ENTRY)						      ; 3575
				       12  13 0066C 	    BEQL    11$							      ;
		         50	  0E   A2  3C 0066E 	    MOVZWL  14(ENTRY), R0					      ;
				       50  D6 00672 	    INCL    R0							      ;
		         50	       04  C6 00674 	    DIVL2   #4, R0						      ;
				  01   A0  9F 00677 	    PUSHAB  1(R0)						      ;
				  14   A2  DD 0067A 	    PUSHL   20(ENTRY)						      ;
		         6A	       02  FB 0067D 	    CALLS   #2, DBG$FREERELEASE					      ;
		         50	       62  0F 00680 11$:    REMQUE  (ENTRY), DUMMY_LOC					      ;
				       01  1C 00683 	    BVC     12$							      ;
					   04 00685 	    RET     							      ;
				       06  DD 00686 12$:    PUSHL   #6							      ;
				       52  DD 00688 	    PUSHL   ENTRY						      ;
		         6A	       02  FB 0068A 	    CALLS   #2, DBG$FREERELEASE					      ;
					   04 0068D 	    RET     							      ; 3576
	      FFFFFFFF   8F	       53  D1 0068E 13$:    CMPL    R3, #-1						      ; 3587
				       33  13 00695 	    BEQL    17$							      ;
	      FFFFFFFE   8F	       53  D1 00697 	    CMPL    R3, #-2						      ;
				       08  12 0069E 	    BNEQ    14$							      ;
      12   A2	         02	       01  ED 006A0 	    CMPZV   #1, #2, 18(ENTRY), #1				      ; 3591
				       01     006A5									      ;
				       20  11 006A6 	    BRB     16$							      ;
	      FFFFFFFD   8F	       53  D1 006A8 14$:    CMPL    R3, #-3						      ; 3587
				       08  12 006AF 	    BNEQ    15$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 13-3
; Digital Equipment Corporation
;
      12   A2	         02	       01  ED 006B1 	    CMPZV   #1, #2, 18(ENTRY), #2				      ; 3594
				       02     006B6									      ;
				       0F  11 006B7 	    BRB     16$							      ;
	      FFFFFFFC   8F	       53  D1 006B9 15$:    CMPL    R3, #-4						      ; 3587
				       2B  12 006C0 	    BNEQ    19$							      ;
      12   A2	         02	       01  ED 006C2 	    CMPZV   #1, #2, 18(ENTRY), #3				      ; 3597
				       03     006C7									      ;
				       23  12 006C8 16$:    BNEQ    19$							      ;
				  14   A2  D5 006CA 17$:    TSTL    20(ENTRY)						      ; 3598
				       12  13 006CD 	    BEQL    18$							      ;
		         50	  0E   A2  3C 006CF 	    MOVZWL  14(ENTRY), R0					      ;
				       50  D6 006D3 	    INCL    R0							      ;
		         50	       04  C6 006D5 	    DIVL2   #4, R0						      ;
				  01   A0  9F 006D8 	    PUSHAB  1(R0)						      ;
				  14   A2  DD 006DB 	    PUSHL   20(ENTRY)						      ;
		         6A	       02  FB 006DE 	    CALLS   #2, DBG$FREERELEASE					      ;
		         50	       62  0F 006E1 18$:    REMQUE  (ENTRY), DUMMY_LOC					      ;
				       07  1D 006E4 	    BVS     19$							      ;
				       06  DD 006E6 	    PUSHL   #6							      ;
				       52  DD 006E8 	    PUSHL   ENTRY						      ;
		         6A	       02  FB 006EA 	    CALLS   #2, DBG$FREERELEASE					      ;
		         52	       55  D0 006ED 19$:    MOVL    NEXT_ENTRY, ENTRY					      ; 3601
				     FF35  31 006F0 	    BRW     4$							      ; 3563
	      FFFFFFFC   8F	  04   AC  D1 006F3 20$:    CMPL    BREAK_ADDRESS, #-4					      ; 3604
				       09  1E 006FB 	    BGEQU   22$							      ;
				       54  DD 006FD 21$:    PUSHL   ERROR_CODE						      ; 3605
	      00000000G  00	       01  FB 006FF 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 00706 22$:    RET     							      ; 3503

; Routine Size:  280 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 04:06:18	DBB3:[DEBUG.SRC]DBGBRK.B32;7					Page 14
; Digital Equipment Corporation
;
;	3608	END
;	3609	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  DBG$CODE       	  1799  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  DBG$OWN        	     4    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
;  DBG$PLIT       	   116  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]STARLET.L32;1		      2688         5         0       110






;			COMPILER INTERNAL TIMING

;	Phase	    Faults	Cpu-time      Elapsed-time
;	LEXSYN	      601	00:50.8		01:33.7
;	FLOWAN	       23	00:06.4		00:10.9
;	DELAY	       25	00:02.9		00:05.1
;	TNBIND	       46	00:05.0		00:07.9
;	CODE	       49	00:09.8		00:18.3
;	FINAL	       97	00:12.8		00:20.9
;	Total	      841	01:27.7		02:36.8

; Size:		1799 code + 120 data bytes
; Run Time:	01:28.3
; Elapsed Time:	02:38.1
; Memory Used:	316 pages
; Compilation Complete
