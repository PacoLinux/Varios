!++
!
! UTLDEF.B32 - UTILITY DEFINITION MACROS FOR BLISS PROCESSING
! OF STARLET DEFINITION MACROS.
!
!--

!
! MACROS TO EXTRACT OFFSETS, FIELD WIDTHS, ETC., FROM FIELD EXTRACTION MACROS.
!

MACRO	$BYTEOFFSET (OFFSET, POSITION, WIDTH, SIGN) = OFFSET%;

MACRO	$BITPOSITION (OFFSET, POSITION, WIDTH, SIGN) = POSITION%;

MACRO	$FIELDWIDTH (OFFSET, POSITION, WIDTH, SIGN) = WIDTH%;

MACRO	$EXTENSION (OFFSET, POSITION, WIDTH, SIGN) = SIGN%;

MACRO	$FIELDMASK (OFFSET, POSITION, WIDTH, SIGN) =
	(1^(POSITION+WIDTH) - 1^POSITION)%;

!
! MACRO TO GENERATE EQULST CONSTRUCTS.
!
MACRO
	$EQULST(P,G,I,S)[A]=
	    %NAME(P,GET1ST_ A) =
		%IF NUL2ND_ A
		%THEN (I) + %COUNT*(S)	! ASSUMES I, S ALWAYS GENERATED BY CONVERSION PROGRAM
		%ELSE GET2ND_ A
		%FI %,

	GET1ST_(A,B)=
	     A %,
	GET2ND_(A,B)=
	     B %,	! KNOWN NON-NULL
	NUL2ND_(A,B)=
	     %NULL(B) %;

!		for the BLISS translator which generates BLISS keyword
!		macros from the $name_S macros in this file.
!
! SYSTEM SERVICE MACRO DEFINITIONS
!

!
! ADJUST WORKING SET LIMIT
!
!	PAGCNT	- NUMBER OF PAGES TO ADD TO WORKING SET IF POSITIVE
!		  NUMBER OF PAGES TO SUBTRACT FROM WORKING SET IF NEGATIVE
!	WSETLM	- ADDRESS OF A LONGWORD TO RETURN NEW WORKING SET LIMIT
!



KEYWORDMACRO $ADJWSL(PAGCNT=0,WSETLM=0)=
    (
    EXTERNAL ROUTINE SYS$ADJWSL: ADDRESSING_MODE(ABSOLUTE);
    SYS$ADJWSL(PAGCNT,WSETLM)
    ) %;
!
! ADJUST OUTER MODE STACK POINTER SERVICE
!
!	ACMODE	- ACCESS MODE TO ADJUST STACK POINTER FOR
!	ADJUST	- 16-BIT SIGNED ADJUSTMENT VALUE
!	NEWADR	- ADDRESS OF LONGWORD TO STORE UPDATED VALUE
!




KEYWORDMACRO $ADJSTK(ACMODE=0,ADJUST=0,NEWADR=0)=
    (
    EXTERNAL ROUTINE SYS$ADJSTK: ADDRESSING_MODE(ABSOLUTE);
    SYS$ADJSTK(ACMODE,ADJUST,NEWADR)
    ) %;

!
! ALLOCATE DEVICE
!
!	DEVNAM	- ADDRESS OF DEVICE NAME STRING DESCRIPTOR
!	PHYLEN	- ADDRESS OF WORD TO RECEIVE LENGTH OF PHYSICAL NAME
!	PHYBUF	- ADDRESS OF PHYSICAL NAME BUFFER DESCRIPTOR
!	ACMODE	- ACCESS MODE FOR UCB OF ALLOCATED DEVICE
!



KEYWORDMACRO $ALLOC(DEVNAM=0,PHYLEN=0,PHYBUF=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$ALLOC: ADDRESSING_MODE(ABSOLUTE);
    SYS$ALLOC(DEVNAM,PHYLEN,PHYBUF,ACMODE)
    ) %;
!
! ASSOCIATE COMMON EVENT FLAG CLUSTER
!
!	EFN	- NUMBER OF AN EVENT FLAG IN THE CLUSTER WITH WHICH TO ASSOCIATE
!	NAME	- ADDRESS OF THE TEXT NAME STRING DESCRIPTOR
!	PROT	- PROTECTION INDICATOR FOR THE CLUSTER
!		0 -> DEFAULT, ANY PROCESS IN GROUP
!		1 -> ONLY OWNER'S UIC
!	PERM	- PERMANENT INDICATOR
!		0 -> TEMPORARY
!		1 -> PERMANENT
!




KEYWORDMACRO $ASCEFC(EFN=0,NAME=0,PROT=0,PERM=0)=
    (
    EXTERNAL ROUTINE SYS$ASCEFC: ADDRESSING_MODE(ABSOLUTE);
    SYS$ASCEFC(EFN,NAME,PROT,PERM)
    ) %;

!
! CONVERT BINARY TIME TO ASCII STRING
!
!	TIMLEN  - ADDRESS OF A WORD TO RECEIVE THE NUMBER OF CHARACTERS
!		  INSERTED INTO THE OUTPUT BUFFER
!	TIMBUF	- ADDRESS OF A QUADWORD DESCRIPTOR DESCRIBING THE BUFFER
!		  TO RECEIVE THE CONVERTED TIME
!	TIMADR	- ADDRESS OF THE QUADWORD CONTAINING THE 64-BIT TIME TO BE
!		  CONVERTED TO ASCII
!	CVTFLG	- 0 -> RETURN FULL DATE AND TIME
!		  1 -> RETURN CONVERTED TIME ONLY
!




KEYWORDMACRO $ASCTIM(TIMLEN=0,TIMBUF=0,TIMADR=0,CVTFLG=0)=
    (
    EXTERNAL ROUTINE SYS$ASCTIM: ADDRESSING_MODE(ABSOLUTE);
    SYS$ASCTIM(TIMLEN,TIMBUF,TIMADR,CVTFLG)
    ) %;

!
! ASSIGN I/O CHANNEL
!
!	DEVNAM	- ADDRESS OF DEVICE NAME STRING DESCRIPTOR
!	CHAN	- ADDRESS OF WORD TO RECEIVE CHANNEL NUMBER ASSIGNED
!	ACMODE	- ACCESS MODE FOR CHANNEL'S CCB
!	MBXNAM	- ADDRESS OF OPTIONAL MAILBOX NAME STRING DESCRIPTOR
!



KEYWORDMACRO $ASSIGN(DEVNAM=0,CHAN=0,ACMODE=0,MBXNAM=0)=
    (
    EXTERNAL ROUTINE SYS$ASSIGN: ADDRESSING_MODE(ABSOLUTE);
    SYS$ASSIGN(DEVNAM,CHAN,ACMODE,MBXNAM)
    ) %;

!
! BINTIM - CONVERT ASCII STRING TO BINARY TIME
!
!	TIMBUF	- ADDRESS OF ASCII STRING DESCRIPTOR FOR ASCII TIME STRING
!	TIMADR 	- ADDRESS OF QUADWORD TO RECEIVE 64 BIT BINARY TIME
!




KEYWORDMACRO $BINTIM(TIMBUF=0,TIMADR=0)=
    (
    EXTERNAL ROUTINE SYS$BINTIM: ADDRESSING_MODE(ABSOLUTE);
    SYS$BINTIM(TIMBUF,TIMADR)
    ) %;

!
! BROADCAST MESSAGE
!
! 	MSGBUF	- ADDRESS OF MESSAGE BUFFER DESCRIPTOR
!	DEVNAM	- ADDRESS OF TARGET TERMINAL STRING DESCRIPTOR. ZERO
!		  IMPLIES SEND TO ALL TERMINALS. IF DESCRIPTOR HAS ZERO
!		  LENGTH, THEN SEND TO ALL ALLOCATED TERMINALS.
!




KEYWORDMACRO $BRDCST(MSGBUF=0,DEVNAM=0)=
    (
    EXTERNAL ROUTINE SYS$BRDCST: ADDRESSING_MODE(ABSOLUTE);
    SYS$BRDCST(MSGBUF,DEVNAM)
    ) %;
!++
! MACRO TO GENERATE SYSTEM BUGCHECK
!--

!
! CANCEL I/O ON CHANNEL
!
!	CHAN - CHANNEL ON WHICH ALL I/O WILL BE CANCELED
!




KEYWORDMACRO $CANCEL(CHAN=0)=
    (
    EXTERNAL ROUTINE SYS$CANCEL: ADDRESSING_MODE(ABSOLUTE);
    SYS$CANCEL(CHAN)
    ) %;

!
! CANCEL EXIT HANDLER
!
!	DESBLK - ADDRESS OF PREVIOUSLY DECLARED EXIT HANDLER CONTROL BLOCK
!
!




KEYWORDMACRO $CANEXH(DESBLK=0)=
    (
    EXTERNAL ROUTINE SYS$CANEXH: ADDRESSING_MODE(ABSOLUTE);
    SYS$CANEXH(DESBLK)
    ) %;

!
! CANCEL TIMER REQUEST
!
!	REQIDT	- REQUEST IDENTIFICATION FOR REQUEST TO BE CANCELED
!	ACMODE	- ACCESS MODE OF REQUESTS TO BE CANCELED
!




KEYWORDMACRO $CANTIM(REQIDT=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$CANTIM: ADDRESSING_MODE(ABSOLUTE);
    SYS$CANTIM(REQIDT,ACMODE)
    ) %;

!
! CANCEL WAKEUP
!
!	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO AWAKE
!	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR
!




KEYWORDMACRO $CANWAK(PIDADR=0,PRCNAM=0)=
    (
    EXTERNAL ROUTINE SYS$CANWAK: ADDRESSING_MODE(ABSOLUTE);
    SYS$CANWAK(PIDADR,PRCNAM)
    ) %;
!
! CLEAR EVENT FLAG
!
!	EFN	- EVENT FLAG NUMBER TO BE CLEARED
!




KEYWORDMACRO $CLREF(EFN=0)=
    (
    EXTERNAL ROUTINE SYS$CLREF: ADDRESSING_MODE(ABSOLUTE);
    SYS$CLREF(EFN)
    ) %;

!
! CHANGE TO EXECUTIVE MODE
!
!	ROUTIN	- ADDRESS OF ROUTINE TO BE EXECUTED IN EXECUTIVE MODE
!	ARGLST	- ADDRESS OF ARGUMENT LIST TO BE SUPPLIED TO THE ROUTINE
!




KEYWORDMACRO $CMEXEC(ROUTIN=0,ARGLST=0)=
    (
    EXTERNAL ROUTINE SYS$CMEXEC: ADDRESSING_MODE(ABSOLUTE);
    SYS$CMEXEC(ROUTIN,ARGLST)
    ) %;

!
! CHANGE TO KERNEL MODE
!
!	ROUTIN	- ADDRESS OF ROUTINE TO EXECUTE IN KERNEL MODE
!	ARGLST	- ADDRESS OF ARGUMENT LIST TO BE SUPPLIED TO ROUTINE
!




KEYWORDMACRO $CMKRNL(ROUTIN=0,ARGLST=0)=
    (
    EXTERNAL ROUTINE SYS$CMKRNL: ADDRESSING_MODE(ABSOLUTE);
    SYS$CMKRNL(ROUTIN,ARGLST)
    ) %;

!
! CONTRACT PROGRAM/CONTROL REGION
!
!	PAGCNT	- NUMBER OF PAGES TO BE DELETED FROM END OF REGION
!	RETADR	- ADDRESS OF TWO LONGWORD ARRAY TO RECEIVE VIRTUAL ADDRESSES
!		  OF STARTING AND ENDING PAGE OF DELETED AREA
!	ACMODE	- ACCESS MODE FOR WHICH SERVICE IS PERFORMED
!	REGION	- REGION INDICATOR
!		  0 -> PROGRAM (P0) REGION
!		  1 -> CONTROL (P1) REGION
!




KEYWORDMACRO $CNTREG(PAGCNT=0,RETADR=0,ACMODE=0,REGION=0)=
    (
    EXTERNAL ROUTINE SYS$CNTREG: ADDRESSING_MODE(ABSOLUTE);
    SYS$CNTREG(PAGCNT,RETADR,ACMODE,REGION)
    ) %;

!
! CREATE LOGICAL NAME
!
!	TBLFLG	- LOGICAL NAME TABLE NUMBER
!		 0 -> SYSTEM TABLE
!		 1 -> GROUP TABLE
!		 2 -> PROCESS TABLE
!	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
!	EQLNAM	- ADDRESS OF EQUIVALENCE NAME STRING DESCRIPTOR
!	ACMODE	- ACCESS MODE FOR LOGICAL NAME
!




KEYWORDMACRO $CRELOG(TBLFLG=0,LOGNAM=0,EQLNAM=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$CRELOG: ADDRESSING_MODE(ABSOLUTE);
    SYS$CRELOG(TBLFLG,LOGNAM,EQLNAM,ACMODE)
    ) %;

!
! CREATE MAILBOX AND ASSIGN CHANNEL
!
!	PRMFLG	- PERMANENT FLAG
!		  1 -> CREATE PERMANENT MAILBOX
!		  0 -> CREATE TEMPORARY MAILBOX (DEFAULT)
!	CHAN	- ADDRESS OF WORD TO RECEIVE CHANNEL ASSIGNED
!	MAXMSG	- MAXIMUM MESSAGE SIZE THAT MAY BE RECEIVED BY MAILBOX
!	BUFQUO	- BYTES OF DYNAMIC MEMORY THAT MAY BE USED TO BUFFER
!		  MAILBOX MESSAGES
!	PROMSK	- PROTECTION MASK FOR MAILBOX
!	ACMODE	- ACCESS MODE OF CREATED MAILBOX
!	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR FOR MAILBOX
!




KEYWORDMACRO $CREMBX(PRMFLG=0,CHAN=0,MAXMSG=0,BUFQUO=0,PROMSK=0,ACMODE=0,LOGNAM=0)=
    (
    EXTERNAL ROUTINE SYS$CREMBX: ADDRESSING_MODE(ABSOLUTE);
    SYS$CREMBX(PRMFLG,CHAN,MAXMSG,BUFQUO,PROMSK,ACMODE,LOGNAM)
    ) %;

!
! CREATE PROCESS
!
!	PIDADR	- ADDRESS OF LONGWORD IN WHICH TO RETURN PID OF CREATED
!		  PROCESS.
!	IMAGE	- ADDRESS OF STRING DESCRIPTOR FOR IMAGE NAME.
!	INPUT	- ADDRESS OF STRING DESCRIPTOR FOR INPUT LOGICAL NAME.
!	OUTPUT	- ADDRESS OF STRING DESCRIPTOR FOR OUTPUT LOGICAL NAME.
!	ERROR	- ADDRESS OF STRING DESCRIPTOR FOR ERROR LOGICAL NAME.
!	PRVADR	- ADDRESS OF PRIVILEGE MASK (QUAD WORD).
!	QUOTA	- ADDRESS OF QUOTA LIST.
!	PRCNAM	- ADDRESS OF STRING DESCRIPTOR FOR PROCESS NAME.
!	BASPRI	- BASE PRIORITY (0,31) TO SET FOR NEW PROCESS.
!	UIC	- USER IDENTIFICATION CODE, 0=>SUBPROCESS.
!	MBXUNT	- MAILBOX UNIT FOR TERMINATION MESSAGE.
!	STSFLG	- STATUS AND MODE FLAG BITS.
!		  BIT       MEANING
!		  ---       -------
!		   0	    RESOURCE WAIT DISABLE
!		   1	    SYSTEM SERVICE FAILURE EXCEPTION ENABLE
!		   2        SWAP MODE (1=>DONT SWAP)
!		   3	    ACCOUNTING MESSAGE DISABLE
!		   4	    BATCH PROCESS
!		   5	    MAKE PROCESS HIBERNATE
!		   6	    ALLOW LOGIN WITH AUTHORIZATION FILE CHECK
!		   7        PROCESS IS NETWORK CONNECT OBJECT
!




KEYWORDMACRO $CREPRC(PIDADR=0,IMAGE=0,INPUT=0,OUTPUT=0,ERROR=0,PRVADR=0,QUOTA=0,PRCNAM=0,BASPRI=2,UIC=0,MBXUNT=0,STSFLG=0)=
    (
    EXTERNAL ROUTINE SYS$CREPRC: ADDRESSING_MODE(ABSOLUTE);
    SYS$CREPRC(PIDADR,IMAGE,INPUT,OUTPUT,ERROR,PRVADR,QUOTA,PRCNAM,BASPRI,UIC,MBXUNT,STSFLG)
    ) %;

!
! CREATE VIRTUAL ADDRESS SPACE
!
!	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		  ENDING VIRTUAL ADDRESS OF PAGES TO BE CREATED
!	RETADR	- ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
!		  AND ENDING VIRTUAL ADDRESS OF PAGES ACTUALLY CREATED
!	ACMODE	- ACCESS MODE FOR THE NEW PAGES. (PROT IS R/W FOR ACMODE
!		  AND MORE PRIVILEGED MODES).
!




KEYWORDMACRO $CRETVA(INADR=0,RETADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$CRETVA: ADDRESSING_MODE(ABSOLUTE);
    SYS$CRETVA(INADR,RETADR,ACMODE)
    ) %;

!
! CREATE AND MAP PROCESS OR GLOBAL SECTION
!
!	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		  ENDING ADDRESS INTO WHICH THE SECTION WILL BE MAPPED
!	RETADR	- ADDRESS OF 2-LONGWORD ARRAY INTO WHICH THE ADDRESSES
!		  ACTUALLY MAPPED ARE RETURNED
!	ACMODE	- ACCESS MODE OWNING THE PAGES CREATED
!	FLAGS	- MASK DEFINING SECTION TYPE AND CHARACTERISTICS
!	GSDNAM	- ADDRESS OF DESCRIPTOR FOR THE SECTION NAME
!	IDENT	- ADDRESS OF QUADWORD VERSION IDENTIFICATION
!	RELPAG	- RELATIVE PAGE NUMBER WITHIN THE SECTION OF THE
!		  FIRST PAGE TO BE MAPPED
!	CHAN	- CHANNEL NUMBER ON WHICH FILE HAS BEEN ACCESSED
!	PAGCNT	- NUMBER OF PAGES IN SECTION
!	VBN	- VIRTUAL BLOCK NUMBER OF THE BEGINNING OF THE SECTION
!	PROT	- PROTECTION MASK TO BE APPLIED TO THE SECTION
!	PFC	- PAGE FAULT CLUSTER SIZE
!




KEYWORDMACRO $CRMPSC(INADR=0,RETADR=0,ACMODE=0,FLAGS=0,GSDNAM=0,IDENT=0,RELPAG=0,CHAN=0,PAGCNT=0,VBN=0,PROT=0,PFC=0)=
    (
    EXTERNAL ROUTINE SYS$CRMPSC: ADDRESSING_MODE(ABSOLUTE);
    SYS$CRMPSC(INADR,RETADR,ACMODE,FLAGS,GSDNAM,IDENT,RELPAG,CHAN,PAGCNT,VBN,PROT,PFC)
    ) %;
! DISASSOCIATE COMMON EVENT FLAG CLUSTER
!
!	EFN	- NUMBER OF AN EVENT FLAG IN THE CLUSTER TO BE DISASSOCIATED
!




KEYWORDMACRO $DACEFC(EFN=0)=
    (
    EXTERNAL ROUTINE SYS$DACEFC: ADDRESSING_MODE(ABSOLUTE);
    SYS$DACEFC(EFN)
    ) %;

!
! DEALLOCATE DEVICE
!
!	DEVNAM	- ADDRESS OF DEVICE NAME STRING DESCRIPTOR. ZERO IMPLIES
!		ALL.
!	ACMODE	- ACCESS MODE.
!



KEYWORDMACRO $DALLOC(DEVNAM=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$DALLOC: ADDRESSING_MODE(ABSOLUTE);
    SYS$DALLOC(DEVNAM,ACMODE)
    ) %;
!
! DEASSIGN I/O CHANNEL
!
!	CHAN	- NUMBER OF CHANNEL TO BE DEASSIGNED
!



KEYWORDMACRO $DASSGN(CHAN=0)=
    (
    EXTERNAL ROUTINE SYS$DASSGN: ADDRESSING_MODE(ABSOLUTE);
    SYS$DASSGN(CHAN)
    ) %;
!
! DECLARE AST
!
!	ASTADR	- ENTRY ADDRESS OF AST ROUTINE
!	ASTPRM	- VALUE TO BE PASSED TO AST ROUTINE AS AN ARGUMENT
!	ACMODE	- ACCESS MODE FOR WHICH THE AST IS TO BE DECLARED
!




KEYWORDMACRO $DCLAST(ASTADR=0,ASTPRM=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$DCLAST: ADDRESSING_MODE(ABSOLUTE);
    SYS$DCLAST(ASTADR,ASTPRM,ACMODE)
    ) %;

!
! DECLARE CHANGE MODE OR COMPATIBILITY MODE HANDLER
!
! 	ADDRES	- ADDRESS OF THE HANDLER TO BE DECLARED
!	PRVHND	- ADDRESS OF A LONGWORD TO RECEIVE THE PREVIOUS HANDLER ADDRESS
!	TYPE    - HANDLER TYPE INDICATOR
!		0 = DECLARE CHANGE MODE HANDLER FOR CURRENT MODE
!		1 = DECLARE COMPATIBILITY MODE HANDLER
!




KEYWORDMACRO $DCLCMH(ADDRES=0,PRVHND=0,TYPE=0)=
    (
    EXTERNAL ROUTINE SYS$DCLCMH: ADDRESSING_MODE(ABSOLUTE);
    SYS$DCLCMH(ADDRES,PRVHND,TYPE)
    ) %;

!
! DECLARE EXIT HANDLER
!
!	DESBLK	- ADDRESS OF EXIT CONTROL BLOCK CONTAINING
!		
!		+-------------------------------------------+
!		!              FORWARD LINK                 !
!		+-------------------------------------------+
!		!                  EXIT HANDL. ADDRESS      !
!		+-------------------------------------------+
!		!		0                   !  N    !
!		+-------------------------------------------+
!		!   ADDRESS TO STORE REASON FOR EXIT        !
!		+-------------------------------------------+
!		!  ADDITIONAL			            !
!		!      ARGUMENTS		            !
!		!	   IF			            !
!		!	      ANY			    !
!		+-------------------------------------------+
!




KEYWORDMACRO $DCLEXH(DESBLK=0)=
    (
    EXTERNAL ROUTINE SYS$DCLEXH: ADDRESSING_MODE(ABSOLUTE);
    SYS$DCLEXH(DESBLK)
    ) %;

!
! DELETE LOGICAL NAME
!
!	TBLFLG	- LOGICAL NAME TABLE NUMBER
!		  0 -> SYSTEM, 1 -> GROUP, 2 -> LOCAL
!	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
!		ZERO IMPLIES ALL.
!	ACMODE	- ACCESS MODE OF LOGICAL NAME
!




KEYWORDMACRO $DELLOG(TBLFLG=0,LOGNAM=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$DELLOG: ADDRESSING_MODE(ABSOLUTE);
    SYS$DELLOG(TBLFLG,LOGNAM,ACMODE)
    ) %;

!
! DELETE MAILBOX
!
!	CHAN - CHANNEL ON WHICH MAILBOX IS ASSIGNED
!




KEYWORDMACRO $DELMBX(CHAN=0)=
    (
    EXTERNAL ROUTINE SYS$DELMBX: ADDRESSING_MODE(ABSOLUTE);
    SYS$DELMBX(CHAN)
    ) %;

!
! DELETE PROCESS
!
!	PIDADR   - ADDRESS OF LONGWORD CONTAINING PID OF PROCESS TO
!		 - BE DELETED.
!	PRCNAM   - ADDRESS OF STRING DESCRIPTOR FOR PROCESS NAME OF
!		   PROCESS TO BE DELETED.
!




KEYWORDMACRO $DELPRC(PIDADR=0,PRCNAM=0)=
    (
    EXTERNAL ROUTINE SYS$DELPRC: ADDRESSING_MODE(ABSOLUTE);
    SYS$DELPRC(PIDADR,PRCNAM)
    ) %;

!
! DELETE VIRTUAL ADDRESS SPACE
!
!	INADR	- ADDRESS OF 2 LONGWORD ARRAY CONTAINING STARTING AND
!		  ENDING VIRTUAL ADDRESSES OF PAGES TO DELETE
!	RETADR	- ADDRESS OF 2 LONGWORD ARRAY TO RECEIVE STARTING AND
!		  ENDING ADDRESSES OF PAGES ACTUALLY DELETED
!	ACMODE	- ACCESS MODE FOR WHICH SERVICE IS PERFORMED
!




KEYWORDMACRO $DELTVA(INADR=0,RETADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$DELTVA: ADDRESSING_MODE(ABSOLUTE);
    SYS$DELTVA(INADR,RETADR,ACMODE)
    ) %;

!
! DELETE GLOBAL SECTION
!
!	FLAGS	- MASK INDICATING GLOBAL SECTION CHARACTERISTICS
!	GSDNAM	- ADDRESS OF STRING DESCRIPTOR FOR SECTION NAME STRING
!	IDENT - ADDRESS OF QUADWORD IDENTIFICATION
!




KEYWORDMACRO $DGBLSC(FLAGS=0,GSDNAM=0,IDENT=0)=
    (
    EXTERNAL ROUTINE SYS$DGBLSC: ADDRESSING_MODE(ABSOLUTE);
    SYS$DGBLSC(FLAGS,GSDNAM,IDENT)
    ) %;

!
! DELETE COMMON EVENT FLAG CLUSTER
!
!	NAME	- ADDRESS OF TEXT NAME STRING DESCRIPTOR OF PERMANENT CLUSTER
!




KEYWORDMACRO $DLCEFC(NAME=0)=
    (
    EXTERNAL ROUTINE SYS$DLCEFC: ADDRESSING_MODE(ABSOLUTE);
    SYS$DLCEFC(NAME)
    ) %;

!
! EXIT SYSTEM SERVICE - EXIT CURRENT IMAGE
!
!	CODE	- LONGWORD TO BE SAVED IN PROCESS HEADER AS COMPLETION STATUS
!		  OF CURRENT IMAGE ( DEFAULT IS SS$_NORMAL )
!




KEYWORDMACRO $EXIT(CODE=1)=
    (
    EXTERNAL ROUTINE SYS$EXIT: ADDRESSING_MODE(ABSOLUTE);
    SYS$EXIT(CODE)
    ) %;

!
! EXPAND PROGRAM/CONTROL REGION
!
!	PAGCNT	- NUMBER OF PAGES TO ADD TO END OF SPECIFIED REGION
!	RETADR	- ADDRESS OF 2-LONGWORD ARRAY TO RECEIVE VIRTUAL ADDRESSES
!		  OF STARTING AND ENDING PAGES OF EXPANDED REGION
!	ACMODE	- ACCESS MODE OF THE NEW PAGES
!	REGION	- REGION INDICATOR
!		  0 -> EXPAND PROGRAM (P0) REGION
!		  1 -> EXPAND CONTROL (P1) REGION
!




KEYWORDMACRO $EXPREG(PAGCNT=0,RETADR=0,ACMODE=0,REGION=0)=
    (
    EXTERNAL ROUTINE SYS$EXPREG: ADDRESSING_MODE(ABSOLUTE);
    SYS$EXPREG(PAGCNT,RETADR,ACMODE,REGION)
    ) %;
! FORMATTED ASCII OUTPUT (FAO)
!
!	CTRSTR	- ADDRESS OF STRING DESCRIPTOR FOR ASCII CONTROL STRING
!	OUTLEN	- ADDRESS OF WORD IN WHICH TO STORE OUTPUT STRING LENGTH
!	OUTBUF	- ADDRESS OF OUTPUT BUFFER STRING DESCRIPTOR
!	P1 ... 	- VARIABLE NUMBER OF ARGUMENTS TO FAO
!
!	NOTE ***** THE LAST ARGUMENT IN THE $FAO_S ARGUMENT LIST
!	(END_VARNUM_ARGS) IS THERE ONLY FOR THE "MARBLI" PROGRAM WHICH CONVERTS
!	THIS FILE INTO BLISS MACROS.  IT INDICATES THE END OF A SERVICE
!	WITH A VARIABLE LENGTH ARGUMENT LIST.
!




MACRO $FAO[]=
    (
    EXTERNAL ROUTINE SYS$FAO: ADDRESSING_MODE(ABSOLUTE);
    SYS$FAO(%REMAINING)
    ) %;

!
! FORMATTED ASCII OUTPUT WITH LIST PARAMETER (FAOL)
!
!	CTRSTR	- ADDRESS OF STRING DESCRIPTOR FOR CONTROL STRING
!	OUTLEN	- ADDRESS OF WORD TO RECEIVE OUTPUT STRING LENGTH
!	OUTBUF	- ADDRESS OF OUTPUT BUFFER STRING DESCRIPTOR
!	PRMLST	- ADDRESS OF A LIST OF LONGWORD PARAMETERS 
!




KEYWORDMACRO $FAOL(CTRSTR=0,OUTLEN=0,OUTBUF=0,PRMLST=0)=
    (
    EXTERNAL ROUTINE SYS$FAOL: ADDRESSING_MODE(ABSOLUTE);
    SYS$FAOL(CTRSTR,OUTLEN,OUTBUF,PRMLST)
    ) %;

!
! FORCE EXIT
!
!	PIDADR	- ADDRESS OF THE PID OF PROCESS TO BE FORCED
!	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR FOR FORCED PROCESS
!	CODE	- LONGWORD COMPLETION STATUS FOR EXIT SERVICE
!




KEYWORDMACRO $FORCEX(PIDADR=0,PRCNAM=0,CODE=0)=
    (
    EXTERNAL ROUTINE SYS$FORCEX: ADDRESSING_MODE(ABSOLUTE);
    SYS$FORCEX(PIDADR,PRCNAM,CODE)
    ) %;

!
! GET CHANNEL INFORMATION
!
!	CHAN - CHANNEL NUMBER 
!	PRILEN - ADDRESS TO STORE LENGTH OF PRIMARY DEVICE INFORMATION RETURNED
!	PRIBUF - ADDRESS OF BUFFER DESCRIPTOR FOR PRIMARY DEVICE BUFFER
!	SCDLEN - ADDRESS TO STORE LENGTH OF SECONDARY DEVICE INFORMATION
!	SCDBUF - ADDRESS OF SECONDARY BUFFER DESCRIPTOR
!




KEYWORDMACRO $GETCHN(CHAN=0,PRILEN=0,PRIBUF=0,SCDLEN=0,SCDBUF=0)=
    (
    EXTERNAL ROUTINE SYS$GETCHN: ADDRESSING_MODE(ABSOLUTE);
    SYS$GETCHN(CHAN,PRILEN,PRIBUF,SCDLEN,SCDBUF)
    ) %;

!
! GET DEVICE INFORMATION
!
!	DEVNAM - ADDRESS OF DEVICE NAME DESCRIPTOR
!	PRILEN - ADDRESS OF WORD TO RECEIVE LENGTH OF RETURNED INFORMATION
!	PRIBUF - ADDRESS OF DESCRIPTOR FOR PRIMARY DEVICE INFORMATION BUFFER
!	SCDLEN - ADDRESS OF WORD TO RECEIVE LENGTH OF SECONDARY INFORMATION
!	SCDBUF - ADDRESS OF DESCRIPTOR FOR SECONDARY DEVICE INFORMATION BUFFER
!




KEYWORDMACRO $GETDEV(DEVNAM=0,PRILEN=0,PRIBUF=0,SCDLEN=0,SCDBUF=0)=
    (
    EXTERNAL ROUTINE SYS$GETDEV: ADDRESSING_MODE(ABSOLUTE);
    SYS$GETDEV(DEVNAM,PRILEN,PRIBUF,SCDLEN,SCDBUF)
    ) %;

!
! GET JOB PROCESS INFORMATION
!
!	EFN - EVENT FLAG TO BE SET WHEN INFORMATION IS RETURNED (NOT USED NOW)
!	PIDADR - ADDRESS OF A LONGWORD CONTAINING THE PROCESS ID OF THE PROCESS
!		FOR WHICH INFORMATION IS REQUESTED
!	PRCNAM - ADDRESS OF A STRING DESCRIPTOR FOR THE PROCESS NAME OF THE
!		PROCESS FOR WHICH INFORMATION IS REQUESTED
!	ITMLST - ADDRESS OF A LIST OF ITEM DESCRIPTORS FOR THE INFORMATION
!		REQUESTED
!	IOSB - ADDRESS OF A QUADWORD I/O STATUS BLOCK TO RECEIVE
!		THE FINAL STATUS (NOT USED NOW)
!	ASTADR - ADDRESS OF AN AST ROUTINE TO BE CALLED WHEN INFORMATION IS
!		RETURNED (NOT USED NOW)
!	ASTPRM - ADDRESS OF A 32 BIT AST PARAMETER (NOT USED NOW)
!




KEYWORDMACRO $GETJPI(EFN=0,PIDADR=0,PRCNAM=0,ITMLST=0,IOSB=0,ASTADR=0,ASTPRM=0)=
    (
    EXTERNAL ROUTINE SYS$GETJPI: ADDRESSING_MODE(ABSOLUTE);
    SYS$GETJPI(EFN,PIDADR,PRCNAM,ITMLST,IOSB,ASTADR,ASTPRM)
    ) %;

!
! GET MESSAGE
!
!	MSGID	- IDENTIFICATION OF MESSAGE TO BE RETRIEVED
!	MSGLEN	- ADDRESS OF A WORD TO RECEIVE NUMBER OF BYTES TRANSFERRED
!	BUFADR	- ADDRESS OF BUFFER DESCRIPTOR
!	FLAGS	- FLAG INDICATORS FOR SELECTING TEXT, ID, SEVERITY
!	OUTADR	- ADDRESS OF 4 BYTE OUTPUT ARRAY FOR RETURN INFORMATION
!




KEYWORDMACRO $GETMSG(MSGID=0,MSGLEN=0,BUFADR=0,FLAGS=15,OUTADR=0)=
    (
    EXTERNAL ROUTINE SYS$GETMSG: ADDRESSING_MODE(ABSOLUTE);
    SYS$GETMSG(MSGID,MSGLEN,BUFADR,FLAGS,OUTADR)
    ) %;

!
! GET PAGE TABLE INFORMATION
!
!	INADR - ADDRESS 2 LONGWORDS CONTAINING STARTING AND ENDING VIRTUAL
!		ADDRESS TO OPERATE ON
!	RETADR - ADDRESS OF 2 LONGWORDS INTO WHICH STARTING AND ENDING ADDRESS
!		OF PAGES OPERATED ON IS RETURNED
!	ACMODE - ACCESS MODE AGAINST WHICH OWNERSHIP IS CHECKED
!	MASK - MASK OF PAGE TABLE INFORMATION CONTROL BITS
!	PAGCNT - MINIMUM PAGE COUNT
!




KEYWORDMACRO $GETPTI(INADR=0,RETADR=0,ACMODE=0,MASK=0,PAGCNT=0)=
    (
    EXTERNAL ROUTINE SYS$GETPTI: ADDRESSING_MODE(ABSOLUTE);
    SYS$GETPTI(INADR,RETADR,ACMODE,MASK,PAGCNT)
    ) %;

!
! GET TIME
!
!	TIMADR	- ADDRESS OF A QUADWORD TO RECEIVE 64 BIT TIME
!




KEYWORDMACRO $GETTIM(TIMADR=0)=
    (
    EXTERNAL ROUTINE SYS$GETTIM: ADDRESSING_MODE(ABSOLUTE);
    SYS$GETTIM(TIMADR)
    ) %;

!
! HIBERNATE
!
!	NOTE **** ONLY THE _S FORM IS SUPPLIED
!

KEYWORDMACRO $HIBER()=
    (
    EXTERNAL ROUTINE SYS$HIBER: ADDRESSING_MODE(ABSOLUTE);
    SYS$HIBER()
    ) %;

!
! $INPUT - SHORT FORM FOR QIO AND WAIT WITH READ LOGICAL BLOCK FUNCTION
!
!	CHAN	- CHANNEL ON WHICH I/O IS TO BE PERFORMED
!	LENGTH	- LENGTH OF THE INPUT BUFFER
!	BUFFER	- ADDRESS OF THE INPUT BUFFER
!	IOSB	- ADDRESS OF QUADWORD I/O STATUS BLOCK
!	EFN	- (OPTIONAL) EVENT FLAG TO WAIT ON (DEFAULT IS ZERO)
!


!
! IMGACT SYSTEM SERVICE - IMAGE ACTIVATOR
!
!	NAME - ADDRESS OF DESCRIPTOR FOR FILE NAME STRING
!	DFLNAM  - DESCRIPTOR FOR DEFAULT FILE NAME STRING
!	HDRBUF - ADDRESS OF 512 BYTE BUFFER TO WRITE IN
!




KEYWORDMACRO $IMGACT(NAME=0,DFLNAM=0,HDRBUF=0)=
    (
    EXTERNAL ROUTINE SYS$IMGACT: ADDRESSING_MODE(ABSOLUTE);
    SYS$IMGACT(NAME,DFLNAM,HDRBUF)
    ) %;
!
! LOCK PAGES IN MEMORY
!
!	INADR - ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		ENDING VIRTUAL ADDRESSES OF PAGES TO BE LOCKED
!	RETADR - ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING AND
!		ENDING VIRTUAL ADDRESSES OF PAGES ACTUALLY LOCKED
!	ACMODE - ACCESS MODE TO BE CHECKED AGAINST THE PAGE OWNER
!




KEYWORDMACRO $LCKPAG(INADR=0,RETADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$LCKPAG: ADDRESSING_MODE(ABSOLUTE);
    SYS$LCKPAG(INADR,RETADR,ACMODE)
    ) %;

!
! LOCK PAGES IN WORKING SET
!
!	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		  ENDING VIRTUAL ADDRESSES OF PAGES TO BE LOCKED
!	RETADR	- ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
!		  AND ENDING VIRTUAL ADDRESSES OF PAGES ACTUALLY LOCKED
!	ACMODE  - ACCESS MODE TO BE CHECKED AGAINST THE PAGE OWNER
!



KEYWORDMACRO $LKWSET(INADR=0,RETADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$LKWSET: ADDRESSING_MODE(ABSOLUTE);
    SYS$LKWSET(INADR,RETADR,ACMODE)
    ) %;

!
! MAP GLOBAL SECTION
!
!	INADR - ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND 
!		ENDING VIRTUAL ADDRESSES INTO WHICH THE SECTION WILL BE
!		MAPPED
!	RETADR - ADDRESS OF OPTIONAL 2-LONGWORD ARRAY TO RECEIVE THE
!		 STARTING AND ENDING VAs ACTUALLY MAPPED
!	ACMODE - ACCESS MODE TO BE THE OWNER OF THE CREATED PAGES
!	FLAGS  - MASK DEFINING THE SECTION TYPE AND CHARACTERISTICS
!	GSDNAM - ADDRESS OF THE SECTION NAME DESCRIPTOR
!	IDENT  - ADDRESS OF QUADWORD VERSION IDENTIFICATION
!	RELPAG - RELATIVE PAGE WITHIN SECTION
!




KEYWORDMACRO $MGBLSC(INADR=0,RETADR=0,ACMODE=0,FLAGS=0,GSDNAM=0,IDENT=0,RELPAG=0)=
    (
    EXTERNAL ROUTINE SYS$MGBLSC: ADDRESSING_MODE(ABSOLUTE);
    SYS$MGBLSC(INADR,RETADR,ACMODE,FLAGS,GSDNAM,IDENT,RELPAG)
    ) %;

!
! CONVERT TIME TO NUMERIC
!
! 	TIMBUF	- ADDRESS OF A 7-WORD BUFFER TO RECEIVE NUMERIC TIME
!		  INFORMATION.
!	TIMADR	- ADDRESS OF A QUADWORD CONTAINING THE 64-BIT TIME
!		  (DEFAULT IS CURRENT TIME)
!




KEYWORDMACRO $NUMTIM(TIMBUF=0,TIMADR=0)=
    (
    EXTERNAL ROUTINE SYS$NUMTIM: ADDRESSING_MODE(ABSOLUTE);
    SYS$NUMTIM(TIMBUF,TIMADR)
    ) %;

!
! $OUTPUT - SHORT FORM FOR QIO AND WAIT WITH WRITE VIRTUAL BLOCK
!
!	CHAN	- CHANNEL ON WHICH I/O IS DIRECTED
!	LENGTH	- LENGTH OF THE OUTPUT BUFFER
!	BUFFER	- ADDRESS OF THE OUTPUT BUFFER
!	IOSB	- (OPTIONAL) I/O STATUS BLOCK ADDRESS
!	EFN	- (OPTIONAL) EVENT FLAG NUMBER TO WAIT (DEFAULT IS 0)

!


!
! PURGE WORKING SET
!
!	INADR - ADDRESS OF TWO LONGWORD ARRAY OF STARTING AND ENDING ADDRESS
!




KEYWORDMACRO $PURGWS(INADR=0)=
    (
    EXTERNAL ROUTINE SYS$PURGWS: ADDRESSING_MODE(ABSOLUTE);
    SYS$PURGWS(INADR)
    ) %;

!
! PUT MESSAGE SYSTEM SERVICE
!
!	MSGVEC - ADDRESS OF MESSAGE ARGUMENT VECTOR
!	ACTRTN - ADDRESS OF USER-SUPPLIED ACTION ROUTINE
!	FACNAM - ADDRESS OF FACILITY NAME STRING DESCRIPTOR
!




KEYWORDMACRO $PUTMSG(MSGVEC=0,ACTRTN=0,FACNAM=0)=
    (
    EXTERNAL ROUTINE SYS$PUTMSG: ADDRESSING_MODE(ABSOLUTE);
    SYS$PUTMSG(MSGVEC,ACTRTN,FACNAM)
    ) %;

!
! QIO SYSTEM SERVICE
!
!	EFN	- NUMBER OF EVENT FLAG TO SET ON COMPLETION
!	CHAN	- NUMBER OF CHANNEL ON WHICH I/O IS DIRECTED
!	FUNC	- FUNCTION CODE SPECIFYING ACTION TO BE PERFORMED
!	IOSB	- ADDRESS OF QUADWORD I/O STATUS BLOCK TO RECEIVE FINAL
!		  COMPLETION STATUS INFORMATION
!	ASTADR	- ENTRY POINT ADDRESS OF AST ROUTINE
!	ASTPRM	- AST PARAMETER TO BE PASSED TO AST ROUTINE
!	P1 TO P6 - OPTIONAL DEVICE AND FUNCTION SPECIFIC PARAMETERS
!




KEYWORDMACRO $QIO(EFN=0,CHAN=0,FUNC=0,IOSB=0,ASTADR=0,ASTPRM=0,P1=0,P2=0,P3=0,P4=0,P5=0,P6=0)=
    (
    EXTERNAL ROUTINE SYS$QIO: ADDRESSING_MODE(ABSOLUTE);
    SYS$QIO(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)
    ) %;

!
! QIOW SYSTEM SERVICE
!
!	SEE QIO FOR PARAMETER DESCRIPTION
!




KEYWORDMACRO $QIOW(EFN=0,CHAN=0,FUNC=0,IOSB=0,ASTADR=0,ASTPRM=0,P1=0,P2=0,P3=0,P4=0,P5=0,P6=0)=
    (
    EXTERNAL ROUTINE SYS$QIOW: ADDRESSING_MODE(ABSOLUTE);
    SYS$QIOW(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)
    ) %;

!
! READ EVENT FLAGS
!
!	EFN	- EVENT FLAG NUMBER OF A FLAG IN THE CLUSTER TO BE READ
!	STATE	- ADDRESS OF A LONGWORD IN WHICH CURRENT STATE OF ALL FLAGS
!		  IN THE CLUSTER WILL BE RETURNED
!




KEYWORDMACRO $READEF(EFN=0,STATE=0)=
    (
    EXTERNAL ROUTINE SYS$READEF: ADDRESSING_MODE(ABSOLUTE);
    SYS$READEF(EFN,STATE)
    ) %;

!
! RESUME PROCESS
!
!	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO BE RESUMED
!	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR 
!




KEYWORDMACRO $RESUME(PIDADR=0,PRCNAM=0)=
    (
    EXTERNAL ROUTINE SYS$RESUME: ADDRESSING_MODE(ABSOLUTE);
    SYS$RESUME(PIDADR,PRCNAM)
    ) %;
!
! RUNDOWN PROCESS
!
!	ACMODE - ACCESS MODE TO RUNDOWN.  THIS AND ALL LESS PRIVILEGED
!		 ACCESS MODES ARE RUNDOWN.
!




KEYWORDMACRO $RUNDWN(ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$RUNDWN: ADDRESSING_MODE(ABSOLUTE);
    SYS$RUNDWN(ACMODE)
    ) %;

!
! SCHEDULE WAKEUP
!
!	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO BE AWAKENED
!	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR
!	DAYTIM	- ADDRESS OF QUADWORD CONTAINING TIME TO WAKE
!	REPTIM	- ADDRESS OF QUADWORD CONTAINING RESCHEDULE INTERVAL
!




KEYWORDMACRO $SCHDWK(PIDADR=0,PRCNAM=0,DAYTIM=0,REPTIM=0)=
    (
    EXTERNAL ROUTINE SYS$SCHDWK: ADDRESSING_MODE(ABSOLUTE);
    SYS$SCHDWK(PIDADR,PRCNAM,DAYTIM,REPTIM)
    ) %;

!
! SET AST ENABLE
!
!	ENBFLG	- AST ENABLE INDICATOR
!		  1 -> ENABLE AST'S FOR CALLER AT CURRENT ACCESS MODE
!		  0 -> DISABLE AST'S FOR CALLER AT CURRENT ACCESS MODE
!




KEYWORDMACRO $SETAST(ENBFLG=0)=
    (
    EXTERNAL ROUTINE SYS$SETAST: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETAST(ENBFLG)
    ) %;

!
! SET TIMER
!
!	EFN	- EVENT FLAG TO SET WHEN TIMER EXPIRES
!	DAYTIM	- TIME AT WHICH TIMER WILL EXPIRE
!	ASTADR	- ENTRY POINT OF AST TO CALL WHEN TIMER EXPIRES
!	REQIDT	- REQUEST IDENTIFICATION AND AST ID PARAM
!




KEYWORDMACRO $SETIMR(EFN=0,DAYTIM=0,ASTADR=0,REQIDT=0)=
    (
    EXTERNAL ROUTINE SYS$SETIMR: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETIMR(EFN,DAYTIM,ASTADR,REQIDT)
    ) %;

!
! SET EVENT FLAG
!
!	EFN	- EVENT FLAG NUMBER OF FLAG TO SET
!




KEYWORDMACRO $SETEF(EFN=0)=
    (
    EXTERNAL ROUTINE SYS$SETEF: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETEF(EFN)
    ) %;
!
! SET EXCEPTION VECTOR
!
!	VECTOR	- VECTOR NUMBER
!		  0 -> MODIFY PRIMARY VECTOR
!		  1 -> MODIFY SECONDARY VECTOR
!		  2 -> MODIFY LAST CHANCE HANDLER
!	ADDRES	- EXCEPTION HANDLER ADDRESS ( 0 INDICATES DEASSIGN VECTOR)
!	ACMODE	- ACCESS MODE FOR WHICH VECTOR IS SET
!	PRVHND	- ADDRESS OF LONGWORD TO RECEIVE PREVIOUS HANDLER ADDRESS




KEYWORDMACRO $SETEXV(VECTOR=0,ADDRES=0,ACMODE=0,PRVHND=0)=
    (
    EXTERNAL ROUTINE SYS$SETEXV: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETEXV(VECTOR,ADDRES,ACMODE,PRVHND)
    ) %;
!
! SET PAGE FAULT MONITORING
!
!	PFMFLG - 1 -> turn on monitoring
!		 0 -> turn off monitoring
!




KEYWORDMACRO $SETPFM(PFMFLG=1)=
    (
    EXTERNAL ROUTINE SYS$SETPFM: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETPFM(PFMFLG)
    ) %;

!
! SET POWER RECOVERY AST
!
!	ASTADR = ADDRESS OF AST SERVICE ROUTINE
!	ACMODE = ACCESS MODE OF AST
!




KEYWORDMACRO $SETPRA(ASTADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$SETPRA: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETPRA(ASTADR,ACMODE)
    ) %;

!
! SET PROCESS NAME
!
!	PRCNAM	- ADDRESS OF THE PROCESS NAME STRING DESCRIPTOR
!




KEYWORDMACRO $SETPRN(PRCNAM=0)=
    (
    EXTERNAL ROUTINE SYS$SETPRN: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETPRN(PRCNAM)
    ) %;

!
! SET PRIORITY
!
!	PIDADR	- ADDRESS OF THE PROCESS ID
!	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR
!	PRI	- NEW BASE PRIORITY FOR THE PROCESS
!		  0 - 15 ARE BACKGROUND, 16 - 31 ARE REAL-TIME
!	PRVPRI	- ADDRESS OF LONGWORD TO RECEIVE PREVIOUS BASE PRIORITY
!




KEYWORDMACRO $SETPRI(PIDADR=0,PRCNAM=0,PRI=0,PRVPRI=0)=
    (
    EXTERNAL ROUTINE SYS$SETPRI: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETPRI(PIDADR,PRCNAM,PRI,PRVPRI)
    ) %;

!
! SET PROTECTION ON PAGES
!
!	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		  ENDING VIRTUAL ADDRESSES OF PAGES
!	RETADR	- ADDRESS OF 2-LONGWORD ARRAY IN WHICH STARTING AND ENDING
!		  ADDRESSES OF PAGES WHICH HAD THEIR PROTECTION CHANGED
!		  IS RETURNED
!	ACMODE	- ACCESS MODE OF REQUEST
!	PROT	- NEW PROTECTION
!
!	PRVPRT	- ADDRESS OF A BYTE TO RETURN THE PREVIOUS PROTECTION
!		OF THE LAST PAGE CHANGED.




KEYWORDMACRO $SETPRT(INADR=0,RETADR=0,ACMODE=0,PROT=0,PRVPRT=0)=
    (
    EXTERNAL ROUTINE SYS$SETPRT: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETPRT(INADR,RETADR,ACMODE,PROT,PRVPRT)
    ) %;

!
! SET RESOURCE WAIT MODE
!
!	WATFLG	- WAIT INDICATOR
!		  0 -> WAIT FOR RESOURCES TO BECOME AVAILABLE
!		  1 -> RETURN FAILURE STATUS IMMEDIATELY
!




KEYWORDMACRO $SETRWM(WATFLG=0)=
    (
    EXTERNAL ROUTINE SYS$SETRWM: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETRWM(WATFLG)
    ) %;

!
! SET SYSTEM SERVICE FAILURE MODE
!
!	ENBFLG	- ENABLE INDICATOR
!		  1 -> GENERATE EXCEPTIONS ON SYSTEM SERVICE FAILURES
!		  0 -> DISABLE EXCEPTIONS ON SYSTEM SERVICE FAILURES
!




KEYWORDMACRO $SETSFM(ENBFLG=0)=
    (
    EXTERNAL ROUTINE SYS$SETSFM: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETSFM(ENBFLG)
    ) %;

!
! SET SWAP MODE
!
!	SWPFLG	- SWAP INDICATOR
!		0 -> ALLOW SWAPPING
!		1 -> DO NOT SWAP PROCESS
!




KEYWORDMACRO $SETSWM(SWPFLG=0)=
    (
    EXTERNAL ROUTINE SYS$SETSWM: ADDRESSING_MODE(ABSOLUTE);
    SYS$SETSWM(SWPFLG)
    ) %;
!
! SEND MESSAGE TO ACCOUNTING MANAGER
!
!	MSGBUF - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
!	CHAN - CHANNEL NUMBER FOR MAILBOX TO RECEIVE REPLY
!




KEYWORDMACRO $SNDACC(MSGBUF=0,CHAN=0)=
    (
    EXTERNAL ROUTINE SYS$SNDACC: ADDRESSING_MODE(ABSOLUTE);
    SYS$SNDACC(MSGBUF,CHAN)
    ) %;

!
! SEND MESSAGE TO ERROR LOGGER
!
!	MSGBUG - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
!




KEYWORDMACRO $SNDERR(MSGBUF=0)=
    (
    EXTERNAL ROUTINE SYS$SNDERR: ADDRESSING_MODE(ABSOLUTE);
    SYS$SNDERR(MSGBUF)
    ) %;

!
! SEND MESSAGE TO OPERATOR
!
!	MSGBUF - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
!	CHAN - CHANNEL NUMBER FOR MAILBOX TO RECEIVE REPLY
!




KEYWORDMACRO $SNDOPR(MSGBUF=0,CHAN=0)=
    (
    EXTERNAL ROUTINE SYS$SNDOPR: ADDRESSING_MODE(ABSOLUTE);
    SYS$SNDOPR(MSGBUF,CHAN)
    ) %;

!
! SEND MESSAGE TO SYMBIONT MANAGER
!
!	MSGBUF - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
!	CHAN - CHANNEL NUMBER OF MAILBOX TO RECEIVE THE REPLY
!




KEYWORDMACRO $SNDSMB(MSGBUF=0,CHAN=0)=
    (
    EXTERNAL ROUTINE SYS$SNDSMB: ADDRESSING_MODE(ABSOLUTE);
    SYS$SNDSMB(MSGBUF,CHAN)
    ) %;

!
! SUSPEND PROCESS
!
!	PIDADR	- ADDRESS OF THE PROCESS ID OF PROCESS TO SUSPEND
!	PRCNAM	- ADDRESS OF NAME STRING DESCRIPTOR OF PROCESS TO SUSPEND
!




KEYWORDMACRO $SUSPND(PIDADR=0,PRCNAM=0)=
    (
    EXTERNAL ROUTINE SYS$SUSPND: ADDRESSING_MODE(ABSOLUTE);
    SYS$SUSPND(PIDADR,PRCNAM)
    ) %;
!
! TRANSLATE LOGICAL NAME
!
!	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
!	RSLLEN	- ADDRESS OF WORD TO RECEIVE LENGTH OF RESULTANT
!		  NAME STRING
!	RSLBUF	- ADDRESS OF RESULT STRING BUFFER DESCRIPTOR
!	TABLE	- ADDRESS OF BYTE TO STORE TRANSLATION TABLE NUMBER
!	ACMODE	- ADDRESS OF BYTE TO STORE ASSIGNMENT ACCESS MODE
!	DSBMSK  - TABLE SEARCH DISABLE MASK
!




KEYWORDMACRO $TRNLOG(LOGNAM=0,RSLLEN=0,RSLBUF=0,TABLE=0,ACMODE=0,DSBMSK=0)=
    (
    EXTERNAL ROUTINE SYS$TRNLOG: ADDRESSING_MODE(ABSOLUTE);
    SYS$TRNLOG(LOGNAM,RSLLEN,RSLBUF,TABLE,ACMODE,DSBMSK)
    ) %;

!
! UNLOCK PAGES FROM MEMORY
!
!	INADR - ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		ENDING VIRTUAL ADDRESSES OF PAGES TO BE LOCKED
!	RETADR - ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING AND
!		ENDING VIRTUAL ADDRESSES OF PAGES ACTUALLY LOCKED
!	ACMODE - ACCESS MODE TO BE CHECKED AGAINST THE PAGE OWNER
!




KEYWORDMACRO $ULKPAG(INADR=0,RETADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$ULKPAG: ADDRESSING_MODE(ABSOLUTE);
    SYS$ULKPAG(INADR,RETADR,ACMODE)
    ) %;

!
! UNLOCK PAGES FROM WORKING SET
!
!	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
!		  ENDING VIRTUAL ADDRESS OF PAGES TO BE UNLOCKED
!	RETADR	- ADDRESSES OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
!		  AND ENDING VIRTUAL ADDRESS OF PAGES ACTUALLY UNLOCKED
!	ACMODE	- ACCESS MODE TO CHECK AGAINST THE PAGE OWNER
!



KEYWORDMACRO $ULWSET(INADR=0,RETADR=0,ACMODE=0)=
    (
    EXTERNAL ROUTINE SYS$ULWSET: ADDRESSING_MODE(ABSOLUTE);
    SYS$ULWSET(INADR,RETADR,ACMODE)
    ) %;
!
! UNWIND CALL STACK
!
!	DEPADR	- ADDRESS OF NUMBER OF LOGICAL FRAMES TO UNWIND CALL STACK
!	NEWPC	- CHANGE OF FLOW PC
!




KEYWORDMACRO $UNWIND(DEPADR=0,NEWPC=0)=
    (
    EXTERNAL ROUTINE SYS$UNWIND: ADDRESSING_MODE(ABSOLUTE);
    SYS$UNWIND(DEPADR,NEWPC)
    ) %;
!
! UPDATE SECTION FILE ON DISK
!
!	INADR - ADDRESS OF 2 LONGWORD ARRAY CONTAINING STARTING AND ENDING
!		VIRTUAL ADDRESS OF PAGES TO BE WRITTEN BACK TO SECTION FILE.
!	RETADR - ADDRESS OF 2 LONGWORD ARRAY TO RECEIVE STARTING AND ENDING
!		VIRTUAL ADDRESS OF PAGES ACTUALLY WRITTEN
!	ACMODE - ACCESS MODE ON BEHALF OF WHICH SERVICE IS PERFORMED.
!	UPDFLG - MASK QUALIFYING THE UPDATE REQUEST
!	EFN - NUMBER OF AN EVENT FLAG TO SET WHEN THE SECTION FILE IS UPDATED
!	IOSB - ADDRESS OF A QUADWORD I/O STATUS BLOCK THAT IS TO RECEIVE
!		THE COMPLETION STATUS WHEN THE FILE HAS BEEN UPDATED
!	ASTADR - ADDRESS OF AN AST SERVICE ROUTINE 
!	ASTPRM - AST PARAMETER
!




KEYWORDMACRO $UPDSEC(INADR=0,RETADR=0,ACMODE=0,UPDFLG=0,EFN=0,IOSB=0,ASTADR=0,ASTPRM=0)=
    (
    EXTERNAL ROUTINE SYS$UPDSEC: ADDRESSING_MODE(ABSOLUTE);
    SYS$UPDSEC(INADR,RETADR,ACMODE,UPDFLG,EFN,IOSB,ASTADR,ASTPRM)
    ) %;

!
! WAIT FOR SINGLE EVENT
!
!	EFN	- EVENT FLAG NUMBER OF EVENT TO WAIT FOR
!




KEYWORDMACRO $WAITFR(EFN=0)=
    (
    EXTERNAL ROUTINE SYS$WAITFR: ADDRESSING_MODE(ABSOLUTE);
    SYS$WAITFR(EFN)
    ) %;

!
! WAKE 
!
!	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO BE AWAKENED
!	PRCNAM	- ADDRESS OF PROCESS NAME DESCRIPTOR 
!




KEYWORDMACRO $WAKE(PIDADR=0,PRCNAM=0)=
    (
    EXTERNAL ROUTINE SYS$WAKE: ADDRESSING_MODE(ABSOLUTE);
    SYS$WAKE(PIDADR,PRCNAM)
    ) %;

!
! WAIT FOR LOGICAL AND OF EVENT FLAGS
!
!	EFN	- EVENT FLAG NUMBER OF ANY FLAG WITHIN THE CLUSTER
!	MASK	- 32-BIT MASK IN WHICH BITS SET TO 1 SELECT THE EVENTS
!		  OF INTEREST
!




KEYWORDMACRO $WFLAND(EFN=0,MASK=0)=
    (
    EXTERNAL ROUTINE SYS$WFLAND: ADDRESSING_MODE(ABSOLUTE);
    SYS$WFLAND(EFN,MASK)
    ) %;

!
! WAIT FOR LOGICAL OR OF EVENT FLAGS
!
!	EFN	- EVENT FLAG NUMBER OF ANY FLAG WITHIN THE CLUSTER
!	MASK	- 32-BIT MASK IN WHICH BITS SET TO ONE SELECT EVENTS
!		  OF INTEREST
!




KEYWORDMACRO $WFLOR(EFN=0,MASK=0)=
    (
    EXTERNAL ROUTINE SYS$WFLOR: ADDRESSING_MODE(ABSOLUTE);
    SYS$WFLOR(EFN,MASK)
    ) %;

! RMS32.B32  -  REQUIRE FILE FOR BLISS-32 INTERFACE TO RMS-32
!
!			  COPYRIGHT (c) 1977 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!
!
!

!++
!
! FACILITY:	RMS-32 Interface from BLISS
!
! FUNCTIONAL DESCRIPTION:
!
!	This file is to be used as a REQUIRE FILE in any
!	BLISS-32 program using RMS-32.  Its MACROs permit
!	the BLISS-32 program to allocate and statically initialize
!	the control blocks of interest to RMS-32,
!	to dynamically initialize these control blocks,
!	to access the fields of these control blocks, and to invoke
!	the functions supported by RMS-32.
!
! ENVIRONMENT:  Link (automatically) with STARLET.OLB 
!
! AUTHOR:	Peter A. Belmont,	CREATION DATE:  27-May-77
!
! MODIFIED BY:
!		Peter A. Belmont,	22-Jun-77
!		- added $CLOSE, etc., to $RMS_CLOSE, etc.
!		- revised RMS_OKSTATUS macro
!		- changed "$K_" back to "$C_"
!		- fixed ASYN in $RAB to recognize YES (ASYN=YES)
!
!		Peter A. Belmont,	6-July-77
!		- added the XXX_INIT and XXX_INI macros
!		- which implement dynamic initialization of
!		- control blocks.
!
! DOCUMENTATION:
!
!	RMSMPP.RNO	Mini Project Plan, BLISS RMS Support Project
!	RMSSPC.RNO	Functional Specifications, BLISS RMS Support
!			User Documentation, BLISS RMS-32 Support
!			Maintenance Documentation, BLISS RMS-32 Support
!
!--


!++
!
! $RMS_OFFSET
!
!	User macro.  Takes name of an RMS-32 field as
!	parameter and evaluates to the BYTE offset
!	of that field from the base of the control block.
!
!	Use:
!		OFFSET = $RMS_OFFSET(FAB$L_ABC);
!
!--


MACRO

	$RMS_OFFSET(NAME) = $RMS_OFFSET_1(%REMOVE(NAME)) %,
	$RMS_OFFSET_1 (X) = X %;


!++
!
! STATIC INITIALIZATION MACRO UTILITIES
!
!	Internal macros.  Used by the initialization
!	macros below to assign initial values to
!	the fields of the RMS-32 control blocks.
!
!--

MACRO

!++
!
! $RMS_BITFLD (and its support macros ...)
!
!	Internal macro.  Allows the initialization
!	of a field with the OR of one or more (named) bits.
!
!	$RMS_BITFLD(ALLOC,PREFIX,VALUE) builds an
!	initial value of size ALLOC ( BYTE, WORD,
!	or LONG ), setting the bits whose names
!	are of the form PREFIX//VAL where
!	VAL is either VALUE or one of the elements
!	of VALUE when VALUE is a tuple (i.e., <A,B,C>).
!
!--

	$RMS_BITS(A,B)[]=
	    %NAME(A,B)   $RMS_OR(%REMAINING)   $RMS_BITS(A,%REMAINING) %,

	$RMS_OR[]=
	    OR %,

	$RMS_BITFLD(ALLOC,PREFIX,VALUE)=
	    %IF %NULL(VALUE)
	    %THEN ALLOC(0)
	    %ELSE ALLOC($RMS_BITS(PREFIX,%REMOVE(VALUE)))
	    %FI %,

!++
!
! $RMS_BITFLD_INI
!
!	Internal macro.  Permits the dynamic initialization
!	of a field with the OR of one or more named bits.
!
!	$RMS_BITFLD_INI(BLK,NAME,PREFIX,VALUE) stores
!	into BLK[NAME] the value obtained by OR'ing
!	together the bits whose names are PREFIX//VAL
!	where VAL is either VALUE or is one of the
!	elements of VALUE when VALUE is a tuple.
!
!--

    $RMS_BITFLD_INI(BLK,NAME,PREFIX,VALUE)=
	%IF %NULL(VALUE) %THEN %EXITMACRO %FI
	BLOCK[BLK,%REMOVE(NAME);0,BYTE] =
	$RMS_BITS(PREFIX,%REMOVE(VALUE)) %,



!++
!
! $RMS_CODFLD
!
!	Internal macro.  Allows the initialization
!	of a field with a named value.
!
!	$RMS_CODFLD(ALLOC,PREFIX,VALUE)
!	allocates a value of size ALLOC (BYTE, WORD, or LONG)
!	and initializes it with the value whose name
!	is PREFIX//VALUE.
!
!--

	$RMS_CODFLD(ALLOC,PREFIX,VALUE)=
	    ALLOC(%NAME(PREFIX,%REMOVE(VALUE))) %,




!++
!
! $RMS_CODFLD_INI
!
!	Internal macro.  Allows the dynamic initialization
!	of a field with a named value.
!
!	$RMS_CODFLD_INI(BLK,NAME,PREFIX,VALUE)
!	assigns to BLK[NAME] the value whose name is
!	PREFIX//VALUE
!
!--

	$RMS_CODFLD_INI(BLK,NAME,PREFIX,VALUE)=
	%IF %NULL(VALUE) %THEN %EXITMACRO %FI
	    BLOCK[BLK,%REMOVE(NAME);0,BYTE] =
		(%NAME(PREFIX,%REMOVE(VALUE))) %,



!++
!
! $RMS_VALFLD
!
!	Internal macro.  Permits the initialization
!	of a field with a general value.
!
!	$RMS_VALFLD(ALLOC,VALUE) allocates
!	a field of size ALLOC (BYTE, WORD, or LONG)
!	and initializes it with the (general) value, VALUE.
!
!--

	$RMS_VALFLD(ALLOC,VALUE)=
	    ALLOC(VALUE) %,



!++
!
! $RMS_VALFLD_INI
!
!	Internal macro.  Permits the dynamic initialization
!	of a field with a general value.
!
!	$RMS_VALFLD_INI(BLK,NAME,VALUE) stores the value VALUE
!	the field BLK[NAME].
!
!--

	$RMS_VALFLD_INI(BLK,NAME,VALUE)=
	%IF %NULL(VALUE) %THEN %EXITMACRO %FI
	%IF %IDENTICAL(VALUE,0) %THEN %EXITMACRO %FI
	    BLOCK[BLK,%REMOVE(NAME);0,BYTE] = VALUE %,



!++
!
! $RMS_VALPRO (and support macros ...)
!
!	Internal macro.  Permits the initialization
!	of a protection-word following the RSX-11M
!	and STARLET conventions.
!
!--
	$RMS_VALPR2(RWEDCHAR)[]=
	    AND NOT
	    %IF       %IDENTICAL(RWEDCHAR,'R') %THEN XAB$M_NOREAD
	    %ELSE %IF %IDENTICAL(RWEDCHAR,'W') %THEN XAB$M_NOWRITE
	    %ELSE %IF %IDENTICAL(RWEDCHAR,'E') %THEN XAB$M_NOEXE
	    %ELSE %IF %IDENTICAL(RWEDCHAR,'D') %THEN XAB$M_NODEL
	    %ELSE 0 %ERROR('Illegal value "', RWEDCHAR, '" of parameter PRO')
	    %FI %FI %FI %FI
	    $RMS_VALPR2(%REMAINING) %,

	$RMS_VALPR1(RWEDGROUP)=
	    %B'1111'  $RMS_VALPR2(%EXPLODE(RWEDGROUP)) %,

	$RMS_VALPRO(SYSTEM,OWNER,GROUP,WORLD)=
	    %IF %LENGTH GTR 4
	    %THEN
		WORD(0)
		%ERROR('Illegal value of parameter PRO')
	    %ELSE
		WORD(
		($RMS_VALPR1(SYSTEM)) OR ($RMS_VALPR1(OWNER))^4 OR
		($RMS_VALPR1(GROUP))^8 OR ($RMS_VALPR1(WORLD))^12)
	    %FI %,


!++
!
! $RMS_VALPRO_INI
!
!	Internal macro.  Permits the dynamic initialization
!	of a protection word following the RSX-11M and STARLET
!	convention.
!
!--

	$RMS_VALPRO_INI(BLK,SYSTEM,OWNER,GROUP,WORLD)=
	    %IF %LENGTH GTR 5 %THEN
		%ERROR('Illegal value of parameter PRO')
		%EXITMACRO %FI
	    %IF %LENGTH EQL 1 %THEN %EXITMACRO %FI
	    BLOCK[BLK,XAB$W_PRO;0,BYTE] =
		($RMS_VALPR1(SYSTEM) OR ($RMS_VALPR1(OWNER))^4 OR
		($RMS_VALPR1(GROUP))^8 OR ($RMS_VALPR1(WORLD))^12)
		%,


!++
!
! $RMS_VALUIC
!
!	Internal macro.  Permits the initialization
!	of the two-word item, MEMBER/GROUP
!
!--

	$RMS_VALUIC(GROUP,MEMBER)=
	    %IF %LENGTH NEQ 2
	    %THEN
		REP 2 OF WORD(0)
		%ERROR('Illegal value of parameter UIC')
	    %ELSE
		WORD(MEMBER,GROUP)
	    %FI %,


!++
!
! $RMS_VALUIC_INI
!
!	Internal macro.  Permits the dynamic initialization
!	of the two-word item, MEMBER/GROUP
!
!--

	$RMS_VALUIC_INI(BLK,GROUP,MEMBER)=
	    %IF %LENGTH NEQ 3
	    %THEN %ERROR('Illegal value of parameter UIC')
		%EXITMACRO %FI
	    %IF %IDENTICAL(GROUP,0) AND %IDENTICAL(MEMBER,0)
	    %THEN %EXITMACRO %FI
	    BLOCK[BLK,XAB$L_UIC;0,BYTE]
		= ((MEMBER) OR (GROUP)^16) %,


!++
!
! $RMS_VALRFI
!
!	Internal macro.  Permits the initialization
!	of the three-word RFI field with
!	FILENO, SEQNO, RVN
!
!--

	$RMS_VALRFI(FILENO,SEQNO,RVN)=
	    %IF %LENGTH NEQ 3
	    %THEN
		REP 3 OF WORD(0)
		%ERROR('Illegal value of parameter RFI')
	    %ELSE
		WORD(FILENO,SEQNO,RVN)
	    %FI %,


!++
!
! $RMS_VALRFI_INI
!
!	Internal macro.  Permits the dynamic initialization
!	of the three-word RFI field with FILENO, SEQNO, and RVN.
!
!--

	$RMS_VALRFI_INI(BLK,FILENO,SEQNO,RVN)=
	    %IF %LENGTH NEQ 4
	     %THEN %ERROR('Illegal value of parameter RFI')
		%EXITMACRO %FI
	    %IF %IDENTICAL(FILENO,0) AND
		%IDENTICAL(SEQNO ,0) AND
		%IDENTICAL(RVN   ,0) %THEN %EXITMACRO %FI
	    BLOCK[BLK,XAB$W_RFI0;0,BYTE]= FILENO;
	    BLOCK[BLK,XAB$W_RFI2;0,BYTE]= SEQNO;
	    BLOCK[BLK,XAB$W_RFI4;0,BYTE]= RVN 
	%;

!++
!
! $FAB_DECL
!
!	Used to declare a FAB control block where
!	initialization is not required.
!--

MACRO
	$FAB_DECL = 
	BLOCK[FAB$C_BLN,BYTE]	%;

!++
!
! $FAB
!
!	Used to allocate and statically initialize
!	a FAB control block.
!
!--

KEYWORDMACRO

	$FAB(
		FAC=GET,	SHR,		FNA=0,		FNS=0,
		DNA=0,		DNS=0,		RTV=0,		ORG=SEQ,
		RAT,		FOP,		XAB=0,		MRS=0,
		JNL=0,		MRN=0,		ALQ=0,		DEQ=0,
		BLS=0,		NAM=0,		RFM=VAR,	FSZ=0,
		BKS=0,		CTX=0,		BSZ=8)=

	$FAB_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			FAB$C_BID),	! BID
		$RMS_VALFLD(BYTE,			FAB$C_BLN),	! BLN
		$RMS_VALFLD(WORD,			0),		! IFI
		$RMS_BITFLD(LONG,	FAB$M_,		FOP),		! FOP
		$RMS_VALFLD(LONG,			0),		! STS
		$RMS_VALFLD(LONG,			0),		! STV
		$RMS_VALFLD(LONG,			ALQ),		! ALQ
		$RMS_VALFLD(WORD,			DEQ),		! DEQ
		$RMS_BITFLD(BYTE,	FAB$M_,		FAC),		! FAC
		$RMS_BITFLD(BYTE,	FAB$M_,		SHR),		! SHR
		$RMS_VALFLD(LONG,			CTX),		! CTX
		$RMS_VALFLD(BYTE,			RTV),		! RTV
		$RMS_CODFLD(BYTE,	FAB$C_,		ORG),		! ORG
		$RMS_BITFLD(BYTE,	FAB$M_,		RAT),		! RAT
		$RMS_CODFLD(BYTE,	FAB$C_,		RFM),		! RFM
		$RMS_VALFLD(LONG,			JNL),		! JNL
		$RMS_VALFLD(LONG,			XAB),		! XAB
		$RMS_VALFLD(LONG,			NAM),		! NAM
		$RMS_VALFLD(LONG,			FNA),		! FNA
		$RMS_VALFLD(LONG,			DNA),		! DNA
		$RMS_VALFLD(BYTE,			FNS),		! FNS
		$RMS_VALFLD(BYTE,			DNS),		! DNS
		$RMS_VALFLD(WORD,			MRS),		! MRS
		$RMS_VALFLD(LONG,			MRN),		! MRN
		$RMS_VALFLD(WORD,			BLS),		! BLS
		$RMS_VALFLD(BYTE,			BKS),		! BKS
		$RMS_VALFLD(BYTE,			FSZ),		! FSZ
		$RMS_VALFLD(LONG,			0),		! DEV
		$RMS_VALFLD(LONG,			0),		! SDC
		REP 2 OF $RMS_VALFLD(LONG,		0)		! SPARE
	) %;


!++
!
! $FAB_INIT
!
!	Used to dynamically initialize
!	a FAB control block.
!
!--

KEYWORDMACRO

	$FAB_INIT(

		FAB,

		FAC=GET,	SHR,		FNA,		FNS,
		DNA,		DNS,		RTV,		ORG,
		RAT,		FOP,		XAB,		MRS,
		JNL,		MRN,		ALQ,		DEQ,
		BLS,		NAM,		RFM=VAR,	FSZ,
		BKS,		CTX,		BSZ=8)=

	( LOCAL $RMS_PTR; $RMS_PTR = FAB;
	  CH$FILL(0,FAB$C_BLN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_BID),			FAB$C_BID);	! BID
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_BLN),			FAB$C_BLN);	! BLN
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$W_IFI),			0);		! IFI
		$RMS_BITFLD_INI(.$RMS_PTR,(FAB$L_FOP),	FAB$M_,		FOP);		! FOP
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_STS),			0);		! STS
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_STV),			0);		! STV
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_ALQ),			ALQ);		! ALQ
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$W_DEQ),			DEQ);		! DEQ
		$RMS_BITFLD_INI(.$RMS_PTR,(FAB$B_FAC),	FAB$M_,		FAC);		! FAC
		$RMS_BITFLD_INI(.$RMS_PTR,(FAB$B_SHR),	FAB$M_,		SHR);		! SHR
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_CTX),			CTX);		! CTX
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_RTV),			RTV);		! RTV
		$RMS_CODFLD_INI(.$RMS_PTR,(FAB$B_ORG),	FAB$C_,		ORG);		! ORG
		$RMS_BITFLD_INI(.$RMS_PTR,(FAB$B_RAT),	FAB$M_,		RAT);		! RAT
		$RMS_CODFLD_INI(.$RMS_PTR,(FAB$B_RFM),	FAB$C_,		RFM);		! RFM
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_JNL),			JNL);		! JNL
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_XAB),			XAB);		! XAB
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_NAM),			NAM);		! NAM
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_FNA),			FNA);		! FNA
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_DNA),			DNA);		! DNA
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_FNS),			FNS);		! FNS
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_DNS),			DNS);		! DNS
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$W_MRS),			MRS);		! MRS
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_MRN),			MRN);		! MRN
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$W_BLS),			BLS);		! BLS
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_BKS),			BKS);		! BKS
		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$B_FSZ),			FSZ);		! FSZ
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_DEV),			0);		! DEV
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_SDC),			0);		! SDC
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_SPARE),		0);		! SPARE
!		$RMS_VALFLD_INI(.$RMS_PTR,(FAB$L_SPARE),		0);		! SPARE
	  0 ) %;
!++
!
! $NAM_DECL
!
!	Permits the declaration of the NAM control block
!	where initialization is not required.
!
!--
MACRO
	$NAM_DECL = BLOCK[NAM$C_BLN,BYTE] %;


!++
!
! $NAM
!
!	Macro to allocate and initialize the NAM control block.
!
!--

KEYWORDMACRO

	$NAM(
		RSA=0,		RSS=0,		ESA=0,		ESS=0,
		RLF=0)=

	$NAM_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			NAM$C_BID),	! BID
		$RMS_VALFLD(BYTE,			NAM$C_BLN),	! BLN
		$RMS_VALFLD(BYTE,			RSS),		! RSS
		$RMS_VALFLD(BYTE,			0),		! RSL
		$RMS_VALFLD(LONG,			RSA),		! RSA
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(BYTE,			ESS),		! ESS
		$RMS_VALFLD(BYTE,			0),		! ESL
		$RMS_VALFLD(LONG,			ESA),		! ESA
		$RMS_VALFLD(LONG,			RLF),		! RLF
		REP 8 OF $RMS_VALFLD(WORD,		0),		! DVI
		REP 3 OF $RMS_VALFLD(WORD,		0),		! FID
		REP 3 OF $RMS_VALFLD(WORD,		0),		! DID
		$RMS_VALFLD(LONG,			0),		! WCC
		$RMS_VALFLD(LONG,			0)		! FNB
	) %;



!++
!
! $NAM_INIT
!
!	Used to dynamically initialize
!	a NAM control block.
!
!--

KEYWORDMACRO

	$NAM_INIT( 

		NAM,

		RSA,		RSS,		ESA,		ESS,
		RLF)=

	( LOCAL $RMS_PTR; $RMS_PTR = NAM;
	  CH$FILL(0,NAM$C_BLN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$B_BID),			NAM$C_BID);	! BID
		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$B_BLN),			NAM$C_BLN);	! BLN
		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$B_RSS),			RSS);		! RSS
!		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$B_RSL),			0);		! RSL
		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$L_RSA),			RSA);		! RSA
		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$B_ESS),			ESS);		! ESS
!		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$B_ESL),			0);		! ESL
		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$L_ESA),			ESA);		! ESA
		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$L_RLF),			RLF);		! RLF
!		REP 8 OF $RMS_VALFLD_INI(.$RMS_PTR,(NAM$W_DVI),		0);		! DVI
!		REP 3 OF $RMS_VALFLD_INI(.$RMS_PTR,(NAM$W_FID),		0);		! FID
!		REP 3 OF $RMS_VALFLD_INI(.$RMS_PTR,(NAM$W_DID),		0);		! DID
!		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$L_WCC),			0);		! WCC
!		$RMS_VALFLD_INI(.$RMS_PTR,(NAM$L_FNB),			0);		! FNB
	   0 ) %;


!++
!
! $XABDAT_DECL
!
!	Permits the declaration of the XABDAT control block
!	where initialization is not required.
!
!--

MACRO
	$XABDAT_DECL = BLOCK[XAB$C_DATLEN,BYTE] %;


!++
!
! $XABDAT
!
!	Macro to allocate and initialize the XABDAT control block.
!
!--

KEYWORDMACRO

	$XABDAT(
		NXT=0,	RVN=0,	EDT0=0,	EDT4=0)=

	$XABDAT_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			XAB$C_DAT),	! COD
		$RMS_VALFLD(BYTE,			XAB$C_DATLEN),	! BLN
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(LONG,			NXT),		! NXT
		$RMS_VALFLD(WORD,			RVN),		! RVN
		$RMS_VALFLD(WORD,			0),		! SPARE
		REP 2 OF $RMS_VALFLD(LONG,		0),		! RDT
		REP 2 OF $RMS_VALFLD(LONG,		0),		! CDT
		$RMS_VALFLD(LONG,			EDT0),		! EDT0
		$RMS_VALFLD(LONG,			EDT4)		! EDT4
	) %;


!++
!
! $XABDAT_INIT
!
!	Macro to dynamically initialize the XABDAT control block.
!
!--

KEYWORDMACRO

	$XABDAT_INIT(

		XAB,

		NXT=0,	RVN=0,	EDT0=0,	EDT4=0)=

	( LOCAL $RMS_PTR; $RMS_PTR = XAB;
	  CH$FILL(0,XAB$C_DATLEN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_COD),			XAB$C_DAT);	! COD
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_BLN),			XAB$C_DATLEN);	! BLN
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),		0);		! SPARE
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_NXT),			NXT);		! NXT
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_RVN),			RVN);		! RVN
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),		0);		! SPARE
!		REP 2 OF $RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_RDT),		0);		! RDT
!		REP 2 OF $RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_CDT),		0);		! CDT
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_EDT0),			EDT0);		! EDT0
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_EDT4),			EDT4);		! EDT4
	  0 ) %;


!++
!
! $XABRDT_DECL
!
!	Permits the declaration of the XABRDT control block
!	where initialization is not required.
!
!--

MACRO
	$XABRDT_DECL = BLOCK[XAB$C_RDTLEN,BYTE] %;


!++
!
! $XABRDT
!
!	Macro to allocate and initialize the XABRDT control block.
!
!--

KEYWORDMACRO

	$XABRDT(
		NXT=0,	RVN=0 )=

	$XABRDT_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			XAB$C_RDT),	! COD
		$RMS_VALFLD(BYTE,			XAB$C_RDTLEN),	! BLN
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(LONG,			NXT),		! NXT
		$RMS_VALFLD(WORD,			RVN),		! RVN
		$RMS_VALFLD(WORD,			0),		! SPARE
		REP 2 OF $RMS_VALFLD(LONG,		0)		! RDT
	) %;


!++
!
! $XABRDT_INIT
!
!	Macro to dynamically initialize the XABRDT control block.
!
!--

KEYWORDMACRO

	$XABRDT_INIT(

		XAB,

		NXT=0,	RVN=0 )=

	( LOCAL $RMS_PTR; $RMS_PTR = XAB;
	  CH$FILL(0,XAB$C_RDTLEN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_COD),			XAB$C_RDT);	! COD
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_BLN),			XAB$C_RDTLEN);	! BLN
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),			0);		! SPARE
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_NXT),			NXT);		! NXT
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_RVN),			RVN);		! RVN
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),		0);		! SPARE
!		REP 2 OF $RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_RDT),		0);		! RDT
	  0 ) %;


!++
!
! $XABPRO_DECL
!
!	Permits the declaration of the XABPRO control block
!	where initialization is not required.
!
!--

MACRO
	$XABPRO_DECL = BLOCK[XAB$C_PROLEN,BYTE] %;


!++
!
! $XABPRO
!
!	Macro to allocate and initialize the XABPRO control block.
!
!--

KEYWORDMACRO

	$XABPRO(
		NXT=0,		UIC=<0,0>,	PRO)=

	$XABPRO_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			XAB$C_PRO),	! COD
		$RMS_VALFLD(BYTE,			XAB$C_PROLEN),	! BLN
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(LONG,			NXT),		! NXT
		$RMS_VALPRO(%REMOVE(PRO)),				! PRO
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALUIC(%REMOVE(UIC))				! UIC
	) %;


!++
!
! $XABPRO_INIT
!
!	Macro to dynamically initialize the XABPRO control block.
!
!--

KEYWORDMACRO

	$XABPRO_INIT(

		XAB,

		NXT=0,		UIC=<0,0>,	PRO)=

	( LOCAL $RMS_PTR; $RMS_PTR = XAB;
	  CH$FILL(0,XAB$C_PROLEN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_COD),			XAB$C_PRO);	! COD
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_BLN),			XAB$C_PROLEN);	! BLN
!		$RMS_VALFLD_INI(SPARE);
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_NXT),			NXT);		! NXT
		$RMS_VALPRO_INI(.$RMS_PTR,%REMOVE(PRO));				! PRO
!		$RMS_VALFLD_INI(SPARE);
		$RMS_VALUIC_INI(.$RMS_PTR,%REMOVE(UIC));				! UIC
	  0 ) %;
!++
!
! $XABALL_DECL
!
!	Permits the declaration of the XABALL control block
!	where initialization is not required.
!
!--

MACRO
	$XABALL_DECL = BLOCK[XAB$C_ALLLEN,BYTE] %;


!++
!
! $XABALL
!
!	Macro to allocate and initialize the XABALL control block.
!
!--

KEYWORDMACRO

	$XABALL(
		NXT=0,		VOL=0,		ALN=ANY,	AOP,
		LOC=0,		RFI=<0,0,0>,	ALQ=0)=

	$XABALL_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			XAB$C_ALL),	! COD
		$RMS_VALFLD(BYTE,			XAB$C_ALLLEN),	! BLN
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(LONG,			NXT),		! NXT
		$RMS_BITFLD(BYTE,	XAB$M_,		AOP),		! AOP
		$RMS_CODFLD(BYTE,	XAB$C_,		ALN),		! ALN
		$RMS_VALFLD(WORD,			VOL),		! VOL
		$RMS_VALFLD(LONG,			LOC),		! LOC
		$RMS_VALFLD(LONG,			ALQ),		! ALQ
		$RMS_VALFLD(WORD,			0),		! DEQ
		$RMS_VALFLD(BYTE,			0),		! BKZ
		$RMS_VALFLD(BYTE,			0),		! AID
		$RMS_VALRFI(%REMOVE(RFI)),				! RFI
		$RMS_VALFLD(WORD,			0)		! SPARE
	) %;


!++
!
! $XABALL_INIT
!
!	Macro to dynamically initialize the XABALL control block.
!
!--

KEYWORDMACRO

	$XABALL_INIT(

		XAB,

		NXT=0,		VOL=0,		ALN,	AOP,
		LOC=0,		RFI=<0,0,0>,	ALQ=0)=

	( LOCAL $RMS_PTR; $RMS_PTR = XAB;
	  CH$FILL(0,XAB$C_ALLLEN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_COD),			XAB$C_ALL);	! COD
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_BLN),			XAB$C_ALLLEN);	! BLN
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),		0);		! SPARE
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_NXT),			NXT);		! NXT
		$RMS_BITFLD_INI(.$RMS_PTR,(XAB$B_AOP),	XAB$M_,		AOP);		! AOP
		$RMS_CODFLD_INI(.$RMS_PTR,(XAB$B_ALN),	XAB$C_,		ALN);		! ALN
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_VOL),			VOL);		! VOL
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_LOC),			LOC);		! LOC
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_ALQ),			ALQ);		! ALQ
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_DEQ),			0);		! DEQ
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_BKZ),			0);		! BKZ
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_AID),			0);		! AID
		$RMS_VALRFI_INI(.$RMS_PTR,%REMOVE(RFI));				! RFI
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),		0);		! SPARE
	  0 ) %;


!++
!
! $XABFHC_DECL
!
!	Permits the declaration of the XABFHC control block
!	where initialization is not required.
!
!--

MACRO
	$XABFHC_DECL = BLOCK[XAB$C_FHCLEN,BYTE] %;


!++
!
! $XABFHC
!
!	Macro to allocate and initialize the XABFHC control block.
!
!--

KEYWORDMACRO

	$XABFHC(
		NXT=0)=

	$XABFHC_DECL
	INITIAL(

		$RMS_VALFLD(BYTE,			XAB$C_FHC),	! COD
		$RMS_VALFLD(BYTE,			XAB$C_FHCLEN),	! BLN
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(LONG,			NXT),		! NXT
		REP 9 OF $RMS_VALFLD(LONG,		0)		! REMAINING FIELDS
	) %;


!++
!
! $XABFHC_INIT
!
!	Macro to dynamically initialize the XABFHC control block.
!
!--

KEYWORDMACRO

	$XABFHC_INIT(

		XAB,

		NXT=0)=

	( LOCAL $RMS_PTR; $RMS_PTR = XAB;
	  CH$FILL(0,XAB$C_FHCLEN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_COD),			XAB$C_FHC);	! COD
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$B_BLN),			XAB$C_FHCLEN);	! BLN
!		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$W_SPARE),		0);		! SPARE
		$RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_NXT),			NXT);		! NXT
!		REP 9 OF $RMS_VALFLD_INI(.$RMS_PTR,(XAB$L_SPARE),	0);		! REMAINING FIELDS
	  0 ) %;


!++
!
! $RAB_DECL and $RAB_DECL_ASYN
!
!	Permit the declaration of the RAB control block
!	where initialization is not required.
!
!	Note that a RAB intended for ASYNCHRONOUS I/O
!	differs from one intended for SYNCHRONOUS I/O
!	in some RMS implementations.
!	USE:
!		LOCAL RAB_01 : $RAB_DECL_ASYN;	! for ASYNCHRONOUS I/O
!		LOCAL RAB_02 : $RAB_DECL;	! for SYNCHRONOUS I/O
!		MAP RAB_03 : $RAB_DECL;
!		EXTERNAL RAB_04 : $RAB_DECL_ASYN;
!
!--

MACRO
	$RAB_DECL =
		BLOCK[RAB$C_BLN,BYTE]  %,
	$RAB_DECL_ASYN =
		BLOCK[RAB$C_BLN,BYTE]  %;
!++
!
! $RAB
!
!	Macro to allocate and initialize the RAB control block.
!	To indicate that the RAB may be used for ASYNCHRONOUS I/O,
!	indicate a value for the ASYN keywordparameter as in
!	the example:
!
!	OWN RAB_01 : $RAB ( ASYN=YES , ....);	! ASYNCHRONOUS
!
!--


KEYWORDMACRO

	$RAB(
		RAC=SEQ,	ROP,		UBF=0,		USZ=0,
		RBF=0,		RSZ=0,		BKT=0,		KBF=0,
		PBF=0,		KSZ=0,		PSZ=0,		RHB=0,
		FAB=0,		MBF=0,		MBC=0,		TMO=0,
		CTX=0,		KRF=0,		ASYN=NO)=

	%IF %IDENTICAL(%STRING(ASYN),'YES')
	%THEN $RAB_DECL_ASYN
	%ELSE $RAB_DECL
	%FI
	INITIAL(

		$RMS_VALFLD(BYTE,			RAB$C_BID),	! BID
		$RMS_VALFLD(BYTE,			RAB$C_BLN),	! BLN
		$RMS_VALFLD(WORD,			0),		! ISI
		$RMS_BITFLD(LONG,	RAB$M_,		ROP),		! ROP
		$RMS_VALFLD(LONG,			0),		! STS
		$RMS_VALFLD(LONG,			0),		! STV
		REP 3 OF $RMS_VALFLD(WORD,		0),		! RFA
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_VALFLD(LONG,			CTX),		! CTX
		$RMS_VALFLD(WORD,			0),		! SPARE
		$RMS_CODFLD(BYTE,	RAB$C_,		RAC),		! RAC
		$RMS_VALFLD(BYTE,			TMO),		! TMO
		$RMS_VALFLD(WORD,			USZ),		! USZ
		$RMS_VALFLD(WORD,			RSZ),		! RSZ
		$RMS_VALFLD(LONG,			UBF),		! UBF
		$RMS_VALFLD(LONG,			RBF),		! RBF
		$RMS_VALFLD(LONG,			RHB),		! RHB
		$RMS_VALFLD(LONG,			(KBF)+(PBF)),	! KBF AND PBF
		$RMS_VALFLD(BYTE,			(KSZ)+(PSZ)),	! KSZ AND PSZ
		$RMS_VALFLD(BYTE,			KRF),		! KRF
		$RMS_VALFLD(BYTE,			MBF),		! MBF
		$RMS_VALFLD(BYTE,			MBC),		! MBC
		$RMS_VALFLD(LONG,			BKT),		! BKT
		$RMS_VALFLD(LONG,			FAB),		! FAB
		REP 1 OF $RMS_VALFLD(LONG,		0)		! SPARE
	) %;



!++
!
! $RAB_INIT
!
!	Macro to dynamically initialize the RAB control block.
!

!--


KEYWORDMACRO

	$RAB_INIT(

		RAB,

		RAC,		ROP,		UBF=0,		USZ=0,
		RBF=0,		RSZ=0,		BKT=0,		KBF=0,
		PBF=0,		KSZ=0,		PSZ=0,		RHB=0,
		FAB=0,		MBF=0,		MBC=0,		TMO=0,
		CTX=0,		KRF=0,		ASYN=NO)=

	( LOCAL $RMS_PTR; $RMS_PTR = RAB;
	  CH$FILL(0,RAB$C_BLN,CH$PTR(.$RMS_PTR));

		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_BID),			RAB$C_BID);	! BID
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_BLN),			RAB$C_BLN);	! BLN
!		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$W_ISI),			0);		! ISI
		$RMS_BITFLD_INI(.$RMS_PTR,(RAB$L_ROP),	RAB$M_,		ROP);		! ROP
!		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_STS),			0);		! STS
!		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_STV),			0);		! STV
!		REP 3 OF $RMS_VALFLD_INI(.$RMS_PTR,(RAB$W_RFA),		0);		! RFA
!		REP 1 OF $RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_SPARE),	0);		! SPARE
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_CTX),			CTX);		! CTX
!		REP 1 OF $RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_SPARE),	0);		! SPARE
		$RMS_CODFLD_INI(.$RMS_PTR,(RAB$B_RAC),	RAB$C_,		RAC);		! RAC
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_TMO),			TMO);		! TMO
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$W_USZ),			USZ);		! USZ
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$W_RSZ),			RSZ);		! RSZ
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_UBF),			UBF);		! UBF
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_RBF),			RBF);		! RBF
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_RHB),			RHB);		! RHB
		%IF NOT %IDENTICAL(KBF,0)
		OR  NOT %IDENTICAL(PBF,0) %THEN
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_KBF),			(KBF)+(PBF));	! KBF AND PBF
					%FI
		%IF NOT %IDENTICAL(KSZ,0)
		OR  NOT %IDENTICAL(PSZ,0) %THEN
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_KSZ),			(KSZ)+(PSZ));	! KSZ AND PSZ
					%FI
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_KRF),			KRF);		! KRF
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_MBF),			MBF);		! MBF
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$B_MBC),			MBC);		! MBC
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_BKT),			BKT);		! BKT
		$RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_FAB),			FAB);		! FAB
!		REP 1 OF $RMS_VALFLD_INI(.$RMS_PTR,(RAB$L_SPARE),	0);		! SPARE
	  0 ) %;


!++
!
! RMS-11 Compatibility Macros
!
!	$RMS_INIT
!	$RMS_INITIF
!	$RMS_POOL
!	$RMS_ORG
!
!	All these macros, necessary only in RMS-11, are
!	coded as no-ops here, being executable
!	expressions with value 0.

!
!--

MACRO
	$RMS_INIT(XX) =
		BEGIN
		0
		END %,

	$RMS_INITIF(XX) =
		BEGIN
		0
		END %,

	$RMS_POOL(XX) =
		BEGIN
		0
		END %,

	$RMS_ORG(XX) =
		BEGIN
		0
		END %,

!++
!
! $RMS_OKSTATUS
! $RMS_OK
! $RMS_SUC
!
!	Macros to examine status (STS) values.
!
!	$RMS_OK(sts_val) examines the value sts_val and
!	yields 1 if this is a good status value, 0 otherwise.
!
!	$RMS_SUC(sts_val) examines the value sts_val and
!	yields 1 if this equals RMS$_SUC.
!
!	$RMS_OKSTATUS(addr) extracts the STS field from
!	the RAB or FAB at addr and yields
!	1 if this is a good status value, 0 otherwise.
!
!--

	$RMS_OKSTATUS(XX) =
		(.BLOCK[XX,FAB$L_STS;0,BYTE] AND 1) %,

	$RMS_OK(VAL)=
		(VAL AND 1) %,

	$RMS_SUC(VAL)=
		(EXTERNAL LITERAL RMS$_SUC;VAL EQL RMS$_SUC) %;

!++
!
! FUNCTIONAL CALLS TO RMS-32
!
!	EXAMPLES OF USE:
!
!	status = $RMS_OPEN(FAB=FAB_01);
!	status = $RMS_GET(SUC=SUC_01,RAB=RAB_03);
!
!
!--

KEYWORDMACRO
	$RMS_CLOSE(FAB,ERR)=
	    $RMS_CALL(SYS$CLOSE,FAB,ERR) %,

	$RMS_CONNECT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$CONNECT,RAB,ERR,SUC) %,

	$RMS_CREATE(FAB,ERR)=
	    $RMS_CALL(SYS$CREATE,FAB,ERR) %,

	$RMS_DELETE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$DELETE,RAB,ERR,SUC) %,

	$RMS_DISCONNECT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$DISCONNECT,RAB,ERR,SUC) %,

	$RMS_DISPLAY(FAB,ERR)=
	    $RMS_CALL(SYS$DISPLAY,FAB,ERR) %,

	$RMS_ERASE(FAB,ERR)=
	    $RMS_CALL(SYS$ERASE,FAB,ERR) %,

	$RMS_EXTEND(FAB,ERR)=
	    $RMS_CALL(SYS$EXTEND,FAB,ERR) %,

	$RMS_FIND(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$FIND,RAB,ERR,SUC) %,

	$RMS_FLUSH(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$FLUSH,RAB,ERR,SUC) %,

	$RMS_FREE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$FREE,RAB,ERR,SUC) %,

	$RMS_GET(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$GET,RAB,ERR,SUC) %,

	$RMS_MODIFY(FAB,ERR)=
	    $RMS_CALL(SYS$MODIFY,FAB,ERR) %,

	$RMS_NXTVOL(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$NXTVOL,RAB,ERR,SUC) %,

	$RMS_OPEN(FAB,ERR)=
	    $RMS_CALL(SYS$OPEN,FAB,ERR) %,

	$RMS_PUT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$PUT,RAB,ERR,SUC) %,

	$RMS_PARSE(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$PARSE,FAB,ERR,SUC) %,

	$RMS_READ(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$READ,RAB,ERR,SUC) %,

	$RMS_RELEASE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$RELEASE,RAB,ERR,SUC) %,

	$RMS_REWIND(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$REWIND,RAB,ERR,SUC) %,

	$RMS_SEARCH(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$SEARCH,FAB,ERR,SUC) %,

	$RMS_ENTER(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$ENTER,FAB,ERR,SUC) %,

	$RMS_REMOVE(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$REMOVE,FAB,ERR,SUC) %,

	$RMS_RENAME(OLDFAB,ERR,SUC,NEWFAB)=
	    $RMS_CALL(SYS$RENAME,OLDFAB,ERR,SUC,NEWFAB) %,

	$RMS_SPACE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$SPACE,RAB,ERR,SUC) %,

	$RMS_TRUNCATE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$TRUNCATE,RAB,ERR,SUC) %,

	$RMS_UPDATE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$UPDATE,RAB,ERR,SUC) %,

	$RMS_WAIT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$WAIT,RAB,ERR,SUC) %,

	$RMS_WRITE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$WRITE,RAB,ERR,SUC) %,

	$CLOSE(FAB,ERR)=
	    $RMS_CALL(SYS$CLOSE,FAB,ERR) %,

	$CONNECT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$CONNECT,RAB,ERR,SUC) %,

	$CREATE(FAB,ERR)=
	    $RMS_CALL(SYS$CREATE,FAB,ERR) %,

	$DELETE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$DELETE,RAB,ERR,SUC) %,

	$DISCONNECT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$DISCONNECT,RAB,ERR,SUC) %,

	$DISPLAY(FAB,ERR)=
	    $RMS_CALL(SYS$DISPLAY,FAB,ERR) %,

	$ERASE(FAB,ERR)=
	    $RMS_CALL(SYS$ERASE,FAB,ERR) %,

	$EXTEND(FAB,ERR)=
	    $RMS_CALL(SYS$EXTEND,FAB,ERR) %,

	$FIND(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$FIND,RAB,ERR,SUC) %,

	$FLUSH(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$FLUSH,RAB,ERR,SUC) %,

	$FREE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$FREE,RAB,ERR,SUC) %,

	$GET(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$GET,RAB,ERR,SUC) %,

	$MODIFY(FAB,ERR)=
	    $RMS_CALL(SYS$MODIFY,FAB,ERR) %,

	$NXTVOL(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$NXTVOL,RAB,ERR,SUC) %,

	$OPEN(FAB,ERR)=
	    $RMS_CALL(SYS$OPEN,FAB,ERR) %,

	$PUT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$PUT,RAB,ERR,SUC) %,

	$PARSE(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$PARSE,FAB,ERR,SUC) %,

	$READ(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$READ,RAB,ERR,SUC) %,

	$RELEASE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$RELEASE,RAB,ERR,SUC) %,

	$REWIND(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$REWIND,RAB,ERR,SUC) %,

	$SEARCH(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$SEARCH,FAB,ERR,SUC) %,

	$ENTER(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$ENTER,FAB,ERR,SUC) %,

	$REMOVE(FAB,ERR,SUC)=
	    $RMS_CALL(SYS$REMOVE,FAB,ERR,SUC) %,

	$RENAME(OLDFAB,ERR,SUC,NEWFAB)=
	    $RMS_CALL(SYS$RENAME,OLDFAB,ERR,SUC,NEWFAB) %,

	$SPACE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$SPACE,RAB,ERR,SUC) %,

	$TRUNCATE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$TRUNCATE,RAB,ERR,SUC) %,

	$UPDATE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$UPDATE,RAB,ERR,SUC) %,

	$WAIT(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$WAIT,RAB,ERR,SUC) %,

	$WRITE(RAB,ERR,SUC)=
	    $RMS_CALL(SYS$WRITE,RAB,ERR,SUC) %;


!++
!
! $RMS_CALL
!
!	Internal macro.  Processes the functional calls
!	by counting the parameters, putting them in
!	the right order, and calling RMS-32 as required.
!
!--

MACRO
	$RMS_CALL(ROUT,BLK,ERR,SUC)=
	    BEGIN
	    EXTERNAL ROUTINE ROUT: ADDRESSING_MODE(ABSOLUTE);
	    ROUT(
		BLK
		%IF %NULL(SUC)
		%THEN
		    %IF %NULL(ERR)
		    %THEN
		    %ELSE
			, ERR
		    %FI
		%ELSE
		    %IF %NULL(ERR)
		    %THEN
			, 0 , SUC
		    %ELSE
			, ERR , SUC
		    %FI
		%FI
		)
	    END %;

!++
!
! FIELD DEFINITIONS, NAMED BIT MASKS, AND NAMED VALUES
!
!	Produced automatically by the MDL processor
!	acting on the input file RMSUSR.MDL
!
!--


  
  
  
 ! 
 ! ACCOUNTING AND TERMINATION MESSAGE FORMAT 
 ! THIS IS THE STRUCTURE OF THE MESSAGE SENT TO THE TERMINATION MAILBOX 
 ! AND TO THE JOB CONTROLLER. 
 ! 
 !...$ACCDEF	
  
 MACRO		ACC$W_MSGTYP	= 0,0,16,0%; 		! MESSAGE TYPE CODE 
 MACRO		ACC$W_MSGSIZ	= 2,0,16,0%; 		! LENGTH OF DATA MESSAGE (VALID ONLY IN ACCLOG) 
 MACRO		ACC$L_FINALSTS	= 4,0,32,0%; 		! FINAL EXIT STATUS 
 MACRO		ACC$L_PID	= 8,0,32,0%; 			! PROCESS ID 
 MACRO		ACC$L_JOBID	= 12,0,32,0%; 		! JOB IDENTIFICATION (VALID ONLY IN ACCLOG) 
 MACRO		ACC$Q_TERMTIME	= 16,0,0,0%; 		! TERMINATION TIME (100NS UNITS) 
 LITERAL	ACC$S_TERMTIME	= 8; 
 MACRO		ACC$T_ACCOUNT	= 24,0,0,0%; 		! ACCOUNT NAME STRING (BLANK FILLED) 
 LITERAL	ACC$S_ACCOUNT	= 8; 
 MACRO		ACC$T_USERNAME	= 32,0,0,0%; 		! USER NAME STRING (BLANK FILLED) 
 LITERAL	ACC$S_USERNAME	= 12; 
 					! END OF FIXED AREA 
 MACRO		ACC$L_CPUTIM	= 44,0,32,0%; 		! CPUTIM IN 10MS UNITS 
 					! MARK START PRINT JOB VARIATION 
 MACRO		ACC$L_PAGEFLTS	= 48,0,32,0%; 		! TOTAL PAGE FAULTS 
 MACRO		ACC$L_PGFLPEAK	= 52,0,32,0%; 		! PEAK PAGING FILE USAGE 
 MACRO		ACC$L_WSPEAK	= 56,0,32,0%; 		! PEAK WORKING SET SIZE 
 MACRO		ACC$L_BIOCNT	= 60,0,32,0%; 		! COUNT OF BUFFERED I/O OPERATIONS 
 MACRO		ACC$L_DIOCNT	= 64,0,32,0%; 		! COUNT OF DIRECT I/O OPERATIONS 
 MACRO		ACC$L_VOLUMES	= 68,0,32,0%; 		! COUNT OF VOLUMES MOUNTED 
 MACRO		ACC$Q_LOGIN	= 72,0,0,0%; 		! LOGIN TIME (100NS UNITS) 
 LITERAL	ACC$S_LOGIN	= 8; 
 MACRO		ACC$L_OWNER	= 80,0,32,0%; 		! PID OF SUBPROCESS OWNER 
 LITERAL	ACC$C_TERMLEN	= 84; 
 LITERAL	ACC$K_TERMLEN	= 84; 			! TERMINATION MESSAGE LENGTH 
 				! AND ACCOUNTING RECORD FOR NON BATCH JOBS 
 				! END OF TERMINATION MESSAGE 
 MACRO		ACC$T_JOB_NAME	= 84,0,0,0%; 		! JOB NAME (BLANK FILLED) 
 LITERAL	ACC$S_JOB_NAME	= 8; 
 MACRO		ACC$T_JOB_QUE	= 92,0,0,0%; 		! QUEUE NAME (.ASCIC) 
 LITERAL	ACC$S_JOB_QUE	= 16; 
 LITERAL	ACC$C_JOB_LEN	= 108; 
 LITERAL	ACC$K_JOB_LEN	= 108; 			! LENGTH OF BATCH JOB ACCOUNTING RECORD 
  
 					! POINT AT PRINT JOB VARIABLE AREA 
 MACRO		ACC$L_PAGCNT	= 48,0,32,0%; 		! SYMBIONT PAGE COUNT 
 MACRO		ACC$L_QIOCNT	= 52,0,32,0%; 		! SYMBIONT QIO COUNT 
 MACRO		ACC$L_GETCNT	= 56,0,32,0%; 		! SYMBIONT GET COUNT 
 MACRO		ACC$Q_QUETIME	= 60,0,0,0%; 		! TIME JOB WAS QUEUED 
 LITERAL	ACC$S_QUETIME	= 8; 
 MACRO		ACC$T_PRT_NAME	= 68,0,0,0%; 		! NAME OF PRINT JOB 
 LITERAL	ACC$S_PRT_NAME	= 8; 
 MACRO		ACC$T_PRT_QUE	= 76,0,0,0%; 		! NAME OF PRINT QUEUE 
 LITERAL	ACC$S_PRT_QUE	= 12; 
 LITERAL	ACC$C_PRT_LEN	= 88; 
 LITERAL	ACC$K_PRT_LEN	= 88; 			! LENGTH OF PRINT ACCOUNTING RECORD 
  
 ! 
 ! DEFINE USER ACCOUNTING MESSAGE DATA AREA 
 ! 
 					! POINT AT START OF MESSAGE DEPENDENT AREA 
 MACRO		ACC$T_USER_DATA	= 44,0,0,0%; 	! ALLOW UP TO 132 BYTES OF USER DATA 
 LITERAL	ACC$S_USER_DATA	= 132; 
 LITERAL	ACC$C_INS_LEN	= 176; 
 LITERAL	ACC$K_INS_LEN	= 176; 			! LENGTH OF INSERT MESSAGE 
 ! 
 ! ASSIGN RECORD TYPE CODES FOR RECORDS IN THE ACCOUNT LOG FILE 
 ! 
  
 LITERAL	
 $EQULST (ACC$K_,GBL,1,1 		! PROCESS ACCOUNTING RECORDS 
 	,(PRCTRM,) 				! JOB TERMINATION 
 	,(BATTRM,) 				! BATCH JOB TERMINATION 
 	,(INTTRM,) 				! INTERACTIVE JOB TERMINATION 
 	,(LOGTRM,) 				! LOGIN FAILURE PROCESS TERMINATION 
 	); 
  
 LITERAL	
 $EQULST (ACC$K_,GBL,16,1 		! MISC ACCOUNTING RECORDS 
 	,(PRTJOB,) 				! PRINT JOB ACCOUNTING 
 	,(INSMSG,) 				! INSERTED MESSAGE 
 	); 
  
 ! 
 ! DEFINE ACCOUNTING MANAGER MESSAGE CODES 
 ! 
  
  
 LITERAL	
 $EQULST (ACC$K_,GBL,1,1 		! 
 	,(INSMESG,) 				! INSERT MESSAGE INTO ACCOUNTING FILE 
 	,(NEWFILE,) 				! CREATE A NEW ACCOUNT FILE 
 	,(ENABACC,) 				! ENABLE ACCOUNTING 
 	,(DISAACC,) 				! DISABLE ACCOUNTING 
 	,(ENABSEL,) 				! ENABLE SELECTIVE ACCOUNTING 
 	,(DISASEL,) 				! DISABLE SELECTIVE ACCOUNTING 
 	); 
  

  
 ! ATTRIBUTE LIST DESCRIPTION. THE ATTRIBUTE CONTROL LIST IS USED TO READ AND 
 ! WRITE FILE ATTRIBUTES. IT CONSISTS OF CONCATENATED ATTRIBUTE CONTROL BLOCKS 
 ! TERMINATED BY A SINGLE ZERO LONGWORD. 
 ! 
  
 !...$ATRDEF	
  
 MACRO		ATR$W_SIZE	= 0,0,16,0%; 			! SIZE OF ATTRIBUTE IN BYTES 
 MACRO		ATR$W_TYPE	= 2,0,16,0%; 			! ATTRIBUTE TYPE CODE 
 MACRO		ATR$L_ADDR	= 4,0,32,0%; 				! ADDRESS OF ATTRIBUTE TEXT 
  
 LITERAL	
 $EQULST (ATR$C_,GBL,3,1 				! ATTRIBUTE CODES 
 	,(UCHAR,) 					! 2 BYTE USER FILE CHARACTERISTICS 
 	,(RECATTR,) 					! 32 BYTES RECORD ATTRIBUTES 
 	,(FILNAM,) 					! 6 BYTE RAD-50 FILE NAME 
 	,(FILTYP,) 					! 2 BYTE RAD-50 FILE TYPE 
 	,(FILVER,) 					! 2 BYTE BINARY FILE VERSION 
 	,(EXPDAT,) 					! 7 BYTE ASCII EXPIRATION DATE 
 	,(STATBLK,) 					! 10 BYTE STATISTICS BLOCK 
 	,(HEADER,) 					! 512 BYTE FILE HEADER 
 	,(BLOCKSIZE,) 				! MAGTAPE BLOCK SIZE 
 	,(USERLABEL,) 				! USER FILE LABEL 
 	,(ASCDATES,) 				! REVISION COUNT THRU EXP DATE IN ASCII 
 	,(ALCONTROL,) 				! COMPATIBILITY MODE ALLOCATION DATA 
 	,(ENDLBLAST,) 				! END OF MAGTAPE LABEL PROCESSING AND SUPPLY AST CONTROL BLOCK 
 	,(ASCNAME,) 					! FILE NAME, TYPE & VERSION IN ASCII 
 	,(CREDATE,) 					! 64 BIT CREATION DATE 
 	,(REVDATE,) 					! 64 BIT REVISION DATE 
 	,(EXPDATE,) 					! 64 BIT EXPIRATION DATE 
 	,(BAKDATE,) 					! 64 BIT BACKUP DATE 
 	,(UIC,) 					! 4 BYTE FILE OWNER UIC 
 	,(FPRO,) 					! 2 BYTE FILE PROTECTION 
 	,(RPRO,) 					! 2 BYTE RECORD PROTECTION 
 	,(ACLEVEL,) 					! 2 BYTE FILE ACCESS LEVEL 
 	,(SEMASK,) 					! FILE SECURITY MASK AND LIMIT 
 	,(UIC_RO,) 					! READ ONLY UIC 
 	,(DIRSEQ,) 					! DIRECTORY UPDATE SEQUENCE COUNT 
 	); 
  
 LITERAL	
 $EQULST (ATR$S_,GBL,0,1 				! ATTRIBUTE MAXIMUM LENGTHS 
 	,(UCHAR,1) 					! 1 BYTE USER FILE CHARACTERISTICS 
 	,(RECATTR,32) 				! 32 BYTES RECORD ATTRIBUTES 
 	,(FILNAM,6) 				! 6 BYTE RAD-50 FILE NAME 
 	,(FILTYP,2) 				! 2 BYTE RAD-50 FILE TYPE 
 	,(FILVER,2) 				! 2 BYTE BINARY FILE VERSION 
 	,(EXPDAT,7) 				! 7 BYTE ASCII EXPIRATION DATE 
 	,(STATBLK,10) 				! 10 BYTE STATISTICS BLOCK 
 	,(HEADER,512) 				! 512 BYTE FILE HEADER 
 	,(BLOCKSIZE,2) 				! MAGTAPE BLOCK SIZE 
 	,(USERLABEL,80) 				! USER FILE LABEL 
 	,(ASCDATES,35) 				! REVISION COUNT THRU EXP DATE IN ASCII 
 	,(ALCONTROL,14) 				! COMPATIBILITY MODE ALLOCATION DATA 
 	,(ENDLBLAST,4) 				! END OF MAGTAPE LABEL PROCESSING AND SUPPLY AST CONTROL BLOCK 
 	,(ASCNAME,20) 				! FILE NAME, TYPE & VERSION IN ASCII 
 	,(CREDATE,8) 				! 64 BIT CREATION DATE 
 	,(REVDATE,8) 				! 64 BIT REVISION DATE 
 	,(EXPDATE,8) 				! 64 BIT EXPIRATION DATE 
 	,(BAKDATE,8) 				! 64 BIT BACKUP DATE 
 	,(UIC,4) 					! 4 BYTE FILE OWNER UIC 
 	,(FPRO,2) 					! 2 BYTE FILE PROTECTION 
 	,(RPRO,2) 					! 2 BYTE RECORD PROTECTION 
 	,(ACLEVEL,2) 				! 2 BYTE FILE ACCESS LEVEL 
 	,(SEMASK,8) 				! FILE SECURITY MASK AND LIMIT 
 	,(UIC_RO,4) 				! READ ONLY UIC 
 	,(DIRSEQ,2) 				! DIRECTORY UPDATE SEQUENCE COUNT 
 	); 
  

  
 ! 
 ! CONDITION HANDLING ARGUMENT LIST OFFSETS 
 ! THERE ARE THREE CONDITIONAL HANDLING STRUCTURES: THE PRIMARY ARGUMENT 
 ! LIST, AND THE SIGNAL AND MECHANISM ARRAYS. ALL ARE IDENTIFIED BY THE SAME 
 ! BLOCK PREFIX. 
 ! 
  
 !...$CHFDEF	
  
 							!PRIMARY ARGUMENT LIST 
 MACRO		CHF$L_SIGARGLST	= 4,0,32,0%; 			!ADDRESS OF SIGNAL ARGUMENTS 
 MACRO		CHF$L_MCHARGLST	= 8,0,32,0%; 			!ADDRESS OF MECHANISM ARGUMENTS 
  
 							!SIGNAL ARRAY 
 MACRO		CHF$L_SIG_ARGS	= 0,0,32,0%; 			!NUMBER OF SIGNAL ARGUMENTS 
 MACRO		CHF$L_SIG_NAME	= 4,0,32,0%; 			!SIGNAL NAME 
 MACRO		CHF$L_SIG_ARG1	= 8,0,32,0%; 			!FIRST SIGNAL SPECIFIC ARGUMENT 
  
 							!MECHANISM ARRAY 
 MACRO		CHF$L_MCH_ARGS	= 0,0,32,0%; 			!NUMBER OF MECHANISM ARGUMENTS 
 MACRO		CHF$L_MCH_FRAME	= 4,0,32,0%; 			!ESTABLISHER FRAME ADDRESS 
 MACRO		CHF$L_MCH_DEPTH	= 8,0,32,0%; 			!FRAME DEPTH OF ESTABLISHER 
 MACRO		CHF$L_MCH_SAVR0	= 12,0,32,0%; 			!SAVED REGISTER R0 
 MACRO		CHF$L_MCH_SAVR1	= 16,0,32,0%; 			!SAVED REGISTER R1 
  

  
 !++ 
 ! 
 ! $CLIDEF --- COMMAND LAGUAGE INTERFACE DEFINITIONS 
 ! 
 ! THIS MODULE DEFINES THE OFFSET VALUES FOR THE DATA STRUCTURES 
 ! USED TO COMMUNICATED COMMAND INFORMATION BETWEEN THE CLI AND 
 ! THE UTILITY THAT WAS REQUESTED TO PERFORM THE OPERATION. 
 ! 
 !-- 
 !...$CLIDEF	
  
 			 
 MACRO		CLI$L_INIARGCNT	= 0,0,32,0%; 		! INITIAL ARG COUNT 
 MACRO		CLI$A_PROGXFER	= 4,0,32,0%; 		! PROGRAM TRANSFER VECTOR ADDRESS 
 MACRO		CLI$A_UTILSERV	= 8,0,32,0%; 		! ADDRESS OF CLI UTILITY SERVICE 
 MACRO		CLI$A_IMGHDADR	= 12,0,32,0%; 		! ADDRESS OF IMAGE HEADER 
 MACRO		CLI$A_IMGFILED	= 16,0,32,0%; 		! ADDRESS OF IMAGE FILE DATA 
 MACRO		CLI$L_LINKFLAG	= 20,0,32,0%; 		! LINK FLAG LONGWORD 
 MACRO		CLI$L_CLIFLAG	= 24,0,32,0%; 			! CLI FLAG LONGWORD 
 							! DEFINE CLI FLAGS 
 MACRO		CLI$V_DEBUG	= 24,0,1,0%; 			! DEBUG QUALIFIER SEEN 
 LITERAL	CLI$M_DEBUG	= 1^1 - 1^0; 
 MACRO		CLI$V_DBGTRU	= 24,1,1,0%; 			! DEBUG WAS TRUE 
 LITERAL	CLI$M_DBGTRU	= 1^2 - 1^1; 
 MACRO		CLI$V_VERIFY	= 24,2,1,0%; 			! VERIFY IS ON 
 LITERAL	CLI$M_VERIFY	= 1^3 - 1^2; 
 MACRO		CLI$V_BATCH	= 24,3,1,0%; 			! THIS PROCESS IS A BATCH JOB 
 LITERAL	CLI$M_BATCH	= 1^4 - 1^3; 
 MACRO		CLI$V_INDIRECT	= 24,4,1,0%; 		! INDIRECT LEVEL NOT EQUAL TO ZERO 
 LITERAL	CLI$M_INDIRECT	= 1^5 - 1^4; 
 MACRO		CLI$V_VFYINP	= 24,5,1,0%; 			! UTILITY SHOULD VERFIY INPUT 
 LITERAL	CLI$M_VFYINP	= 1^6 - 1^5; 
 							! ROUND UP TO NEXT BYTE 
 MACRO		CLI$V_TRMVRBLV	= 24,8,2,0%; 		! TERMINAL VERBOSITY LEVEL 
 LITERAL	CLI$M_TRMVRBLV	= 1^10 - 1^8; 
 							! ROUND UP TO NEXT BYTE 
 MACRO		CLI$V_DBGEXCP	= 24,16,1,0%; 			! DEBUGGER CALLED VIA "DEBUG" EXCEPTION 
 LITERAL	CLI$M_DBGEXCP	= 1^17 - 1^16; 
 			
  
 			 
  
 MACRO		CLI$B_RQTYPE	= 0,0,8,0%; 		! TYPE OF REQUEST BEING MADE 
 							! VIELD DEFINITIONS 
 MACRO		CLI$V_SUBTYP	= 0,0,4,0%; 		! SUB TYPE VIELD 
 MACRO		CLI$V_PRITYP	= 0,4,4,0%; 		! PRIMARY TYPYE 
 			
 MACRO		CLI$W_SERVCOD	= 1,0,16,0%; 		! CLI SERVICE CODE 
 MACRO		CLI$B_RQINDX	= 1,0,8,0%; 		! OFFSET FOR VALUE KEYWORD INDEX 
 MACRO		CLI$B_BITNUM	= 1,0,8,0%; 		! BIT TO SET IF REQUEST IS SUCESSFUL 
 MACRO		CLI$B_RQFLGS	= 2,0,8,0%; 		! INPUT FLAGS CONCERNING REQUEST 
 							! FLAGS FOR PARAMETER PARSING 
 MACRO		CLI$V_PARMREQ	= 2,0,1,0%; 			! PARAMATER IS REQUIRED 
 LITERAL	CLI$M_PARMREQ	= 1^1 - 1^0; 
 MACRO		CLI$V_ABSADR	= 2,1,1,0%; 			! ALL ADDRESS ARE ABSOLUTE 
 LITERAL	CLI$M_ABSADR	= 1^2 - 1^1; 
 MACRO		CLI$V_EXPNAM	= 2,2,1,0%; 			! RETURN EXPLICIT NAMES ONLY 
 LITERAL	CLI$M_EXPNAM	= 1^3 - 1^2; 
 			
  
 							! FLAGS FOR VALUE PARSING 
 MACRO		CLI$V_LASTVAL	= 2,0,1,0%; 			! LAST VALUE ALLOWED 
 LITERAL	CLI$M_LASTVAL	= 1^1 - 1^0; 
 MACRO		CLI$V_DUMMY	= 2,1,1,0%; 			! *** SAVE PLACE FOR ABS ADR *** 
 LITERAL	CLI$M_DUMMY	= 1^2 - 1^1; 
 			
  
 MACRO		CLI$B_RQSTAT	= 3,0,8,0%; 		! OUTPUT STATUS FLAGS 
  
 							! STATUS FLAGS FOR PARAMETER PARSING 
 MACRO		CLI$V_PARMPRS	= 3,0,1,0%; 			! PARAMETER IS PRESENT 
 LITERAL	CLI$M_PARMPRS	= 1^1 - 1^0; 
 MACRO		CLI$V_CONCATINP	= 3,1,1,0%; 		! INPUT CONCATONATION EXISTS 
 LITERAL	CLI$M_CONCATINP	= 1^2 - 1^1; 
 MACRO		CLI$V_MOREINP	= 3,2,1,0%; 			! ANOTHER SET OF INPUT PARAMETERS 
 LITERAL	CLI$M_MOREINP	= 1^3 - 1^2; 
 MACRO		CLI$V_PARMDEF	= 3,3,1,0%; 			! PARAMETER WAS DEFAULTED PRESENT 
 LITERAL	CLI$M_PARMDEF	= 1^4 - 1^3; 
 			
 							! FLAGS FROM VALUE PARSING 
 MACRO		CLI$V_MOREVALS	= 3,0,1,0%; 		! UNPROCESSED VALUES REMAIN 
 LITERAL	CLI$M_MOREVALS	= 1^1 - 1^0; 
 MACRO		CLI$V_KEYVALU	= 3,1,1,0%; 			! SUBSEQUENT TOKEN IS VALUE FOR KEY 
 LITERAL	CLI$M_KEYVALU	= 1^2 - 1^1; 
 			
  
 MACRO		CLI$A_ERRACT	= 4,0,32,0%; 		! ADDRESS OF ERROR ACTION ROUTINE 
 MACRO		CLI$Q_RQDESC	= 8,0,0,0%; 		! QUADWORD REQUEST DESCRIPTOR 
 LITERAL	CLI$S_RQDESC	= 8; 
 MACRO		CLI$W_RQSIZE	= 8,0,16,0%; 		! RESULTANT SIZE OF PARAMETER 
 MACRO		CLI$L_RQVALU	= 12,0,32,0%; 		! ACTUAL VALUE IN VALUE CONVERSTION 
 MACRO		CLI$A_RQADDR	= 12,0,32,0%; 		! ADDRESS OF RESULTANT PARAMETER 
 MACRO		CLI$A_PRSACT	= 16,0,32,0%; 		! PARAMETER PRESENT ACTION ROUTINE 
 MACRO		CLI$A_ABSACT	= 20,0,32,0%; 		! PARAMETER ABSENT ACTION ROUTINE 
 MACRO		CLI$A_QUALST	= 24,0,32,0%; 		! ADDRESS OF QUALIFIERS 
  
 LITERAL	CLI$C_REQDESC	= 28; 
 LITERAL	CLI$K_REQDESC	= 28; 				! SIZE OF THE STRUCTURE 
  
 ! 
 ! DEFINE THE PARAMETER QUALIFIER DESCRIPTOR 
 ! 
  
 			 
  
 MACRO		CLI$B_QDBLKSIZ	= 0,0,8,0%; 		! SIZE OF THE FINAL BLOCK 
 MACRO		CLI$B_QDCODE	= 1,0,8,0%; 		! ID CODE FOR THE QUALIFIER 
 MACRO		CLI$B_QDFLGS	= 2,0,8,0%; 		! FLAGS BYTE 
 							! 
 MACRO		CLI$V_ALLOCCUR	= 2,0,1,0%; 		! TAKE ACTION ON ALL OCCURANCES 
 LITERAL	CLI$M_ALLOCCUR	= 1^1 - 1^0; 
 MACRO		CLI$V_QDUSRV	= 2,1,1,0%; 			! USER CONTEX VALUE IS PRESENT 
 LITERAL	CLI$M_QDUSRV	= 1^2 - 1^1; 
 MACRO		CLI$V_QDEXPA	= 2,2,1,0%; 			! TAKE ACTION ON EXPLICIT OCCURANCES 
 LITERAL	CLI$M_QDEXPA	= 1^3 - 1^2; 
 			
 MACRO		CLI$B_QDSTAT	= 3,0,8,0%; 		! QUALIFIER STATUS 
 							! DEFINE QUALIFIER STATUS BITS 
 MACRO		CLI$V_QUALTRU	= 3,0,1,0%; 			! QUALIFIER IS TRUE 
 LITERAL	CLI$M_QUALTRU	= 1^1 - 1^0; 
 MACRO		CLI$V_QUALEXP	= 3,1,1,0%; 			! QUALIFIER EXPLICITLY STATED 
 LITERAL	CLI$M_QUALEXP	= 1^2 - 1^1; 
 			
  
 MACRO		CLI$Q_QDVALDESC	= 4,0,0,0%; 		! QUALIFIER VALUE DESCRIPTOR 
 LITERAL	CLI$S_QDVALDESC	= 8; 
 MACRO		CLI$W_QDVALSIZ	= 4,0,16,0%; 		! SIZE OF VALUE 
 MACRO		CLI$A_QDVALADR	= 8,0,32,0%; 		! ADDRESS OF VALUE STRING 
 MACRO		CLI$A_TRUACT	= 12,0,32,0%; 		! QUALIFIER TRUE ACTION ROUTINE 
 MACRO		CLI$A_FLSACT	= 16,0,32,0%; 		! QUALIFIER FALSE ACTION ROUTINE 
 LITERAL	CLI$C_QUALDEF	= 20; 
 LITERAL	CLI$K_QUALDEF	= 20; 				! SIZE OF FIXED PART OF STRUCTURE 
 LITERAL	CLI$C_QDBITS	= 20; 
 LITERAL	CLI$K_QDBITS	= 20; 				! START OF BIT LISTS(VARIALBLE LENGTH) 
 MACRO		CLI$L_USRVAL	= 20,0,32,0%; 			! OPTION USER VALUE IF PRESENT 
  
 ! 
 ! DEFINE SPACE FOR THE RESULT PARSE WORK AREA 
 ! 
  
 			 
  
 MACRO		CLI$L_WORKAREA	= 0,0,0,0%; 		! ALLOCATE 32 LONG WORDS 
 LITERAL	CLI$S_WORKAREA	= 128; 
 LITERAL	CLI$C_WORKAREA	= 128; 
 LITERAL	CLI$K_WORKAREA	= 128; 			! SIZE OF HEADER 
  
  
 ! 
 ! DEFINE CLI UTILITY REQUEST CODES 
 ! 
 !	CODES ARE 8 BITS, CONSISTING OF 2 4 BIT FIELDS 
 !	THE LEAST 4 BITS ARE SUBFUCTION DEFINITONS 
 !	AND THE MOST SIGNIFICANT 4 BITS ARE REQUEST TYPE 
 ! 
 LITERAL	
 $EQULST (CLI$K_,GBL,0,1 		! DEFINE REQUEST TYPE CODES 
 	,(UTILOPR,) 				! UTILITY OPERATIONS 
 	,(INPSPEC,) 				! REQUEST FOR AN INPUT SPECIFICATION 
 	,(OUTSPEC,) 				! AN OUTPUT FILE SPECIFICATION 
 	,(PARDONE,) 				! PARAMETER DONE REQUEST 
 	,(VALCONV,) 				! REQUEST A VALUE CONVERSION 
 	,(CLISERV,) 				! REQUSET A SERVICE FORM THE CLI 
 	); 
 ! 
 ! DEFINE COMPLETE CODES FOR UTILITY OPERATIONS 
 ! 
 LITERAL	
 $EQULST (CLI$K_,GBL,(CLI$K_UTILOPR^4),1  
 	,(INITPRS,) 				! REQUEST INITIALIZATION OF PARSE 
 	,(GETCMD,) 				! GET COMMAND BUFFER LIMITS 
 	,(GETQUAL,) 				! OPTAIN STATE OF QUALIFIERS 
 	,(GETOPT,) 				! DECODE COMMAND OPTION 
 	); 
  
 ! 
 ! DEFINE COMPLETE CODES FOR INPUT SPECIFICATIONS 
 ! 
 LITERAL	
 $EQULST (CLI$K_,GBL,(CLI$K_INPSPEC^4),1  
 	,(INPUT1,) 				! PRIMARY INPUT 
 	,(INPUT2,) 				! SECONDARY INPUT 
 	,(INPUT3,) 				! THIRD, 
 	,(INPUT4,) 				! ETC,ETC,ETC 
 	); 
 ! 
 ! DEFINE COMPLETE CODES FOR OUTPUT SPECIFICATIONS 
 ! 
 LITERAL	
 $EQULST (CLI$K_,GBL,(CLI$K_OUTSPEC^4),1  
 	,(OUTPUT1,) 				! FIRST OUTPUT 
 	,(OUTPUT2,) 				! SECOND OUTPUT 
 	,(OUTPUT3,) 				! THIRD,- 
 	,(OUTPUT4,) 				! ETC,ETC,ETC 
 	); 
 ! 
 ! DEFINE CODES FOR RESULT PARSE PARAMETER COMPLETION 
 ! 
 LITERAL	
 $EQULST (CLI$K_,GBL,(CLI$K_PARDONE^4),1  
 	,(ENDPRM1,) 				! COMPLETED PARAMETER SET 1 
 	,(ENDPRM2,) 				! COMPLETED PARAMETER SET 2 
 	,(ENDPRM3,) 				! COMPLETED PARAMETER SET 3 
 	,(ENDPRM4,) 				! COMPLETED PARAMETER SET 4 
 	); 
 ! 
 ! DEFINE CODES FOR VALUE CONVERSION REQUESTS 
 ! 
 LITERAL	
 $EQULST (CLI$K_,GBL,(CLI$K_VALCONV^4),1  
 	,(NUMERVAL,) 			! NUMBERIC VALUE 
 	,(ASCIIVAL,) 			! ASCII VALUE 
 	,(KEYWORD,) 				! KEYWORD VALUE 
 	,(KEYVAL,) 				! KEYWORD WITH VALUE 
 	,(FILSPEC,) 				! VALUE IS A FILESPEC 
 	); 

  
 ! 
 ! DEFINE CLI SERVICE REQUEST CODES 
 ! 
  
 !...$CLISERVDEF	
 LITERAL	
 $EQULST (CLI$K_,GBL,1,1 		! DEFINE CLI SERVICE CODES 
 	,(PAUSE,) 				! PAUSE THE IMAGE 
 	,(DEFLOCAL,) 			! DEFINE A SYMBOL IN THE LOCAL TABLE 
 	,(DEFGLOBAL,) 			! DEFINE A SYMBOL IN THE GLOBAL TABLE 
 	); 

 ! 
 ! DEFINE GENERIC CODES FOR VERBS 
 ! 
  
 !...$CLIVERBDEF	
 LITERAL	
 $EQULST (CLI$K_VERB_,GBL,1,1 	! DEFINE VERB QENERIC CODES 
 	,(ALLO,) 				! ALLOCATE 
 	,(ANAL,) 				! ANALIZE 
 	,(ASSI,) 				! ASSIGN 
 	,(BASI,) 				! BASIC 
 	,(BLIS,) 				! BLISS 
 	,(COBO,) 				! COBOL 
 	,(CONT,) 				! CONTINUE 
 	,(COPY,) 				! COPY 
 	,(CREA,) 				! CREATE 
 	,(DATA,) 				! DATA 
 	,(DEAL,) 				! DEALLOCATE 
 	,(DEAS,) 				! DEASSIGN 
 	,(DEBU,) 				! DEBUG 
 	,(DEFI,) 				! DEFINE 
 	,(DELE,) 				! DELETE 
 	,(DEPO,) 				! DEPOSIT 
 	,(DIFF,) 				! DIFFERENCE COMMAND 
 	,(DIRE,) 				! DIRECTORY 
 	,(DISM,) 				! DISMOUNT 
 	,(EDIT,) 				! EDIT 
 	,(EOD,) 				! EOD 
 	,(EXAM,) 				! EXAMINE 
 	,(EXIT,) 				! EXIT 
 	,(FORT,) 				! FORTRAN 
 	,(GOTO,) 				! GOTO 
 	,(HELP,) 				! HELP 
 	,(IF,) 				! IF 
 	,(INIT,) 				! INITIALIZE 
 	,(INQU,) 				! INQUIRE 
 	,(LINK,) 				! LINK 
 	,(LOGO,) 				! LOGOUT 
 	,(MACR,) 				! MACRO 
 	,(MCR,) 				! MCR 
 	,(ON,) 				! ON 
 	,(PRIN,) 				! PRINT 
 	,(RUN,) 				! RUN 
 	,(SET,) 				! SET 
 	,(SHOW,) 				! SHOW 
 	,(STAR,) 				! START 
 	,(STOP,) 				! STOP 
 	,(SUBM,) 				! SUBMIT 
 	,(TYPE,) 				! TYPE 
 	,(MOUN,) 				! MOUNT 
 	,(PATC,) 				! PATCH 
 	,(REPL,) 				! REPLAY 
 	,(UNLO,) 				! UNLOCK 
 	,(APPE,) 				! APPEND COMMAND 
 	,(DUMP,) 				! DUMP 
 	,(PURG,) 				! PURGE 
 	,(RENA,) 				! RENAME 
 	,(CANC,) 				! CANCEL 
 	,(LIBR,) 				! LIBRARY 
 	,(SORT,) 				! SORT 
 	,(REQU,) 				! REQUEST 
 	,(SYNC,) 				! SYNCRONIZE 
 	); 
 LITERAL	
 $EQULST (CLI$K_VERB_,GBL,255,-1 	! DEFINE VERB QENERIC CODES 
 	,(FORE,) 				! FOREIGN COMMAND 
 	); 

  
 !+ 
 ! CARD READER STATUS BITS 
 !- 
  
 !...$CRDEF	
  
 							!CARD READ CHARACTERISTICS DEFINITIONS 
 MACRO		CR$V_TMODE	= 0,0,4,0%; 		! TRANSLATION MODE 
 LITERAL	CR$M_TMODE	= 1^4 - 1^0; 
 						! 
  
 ! 
 ! TRANSLATION MODE DEFINITIONS 
 ! 
  
 LITERAL	
 $EQULST (CR$K_,GBL,0,1 				! 
 	,(T026,0) 				!026 PUNCH CODE TRANSLATION 
 	,(T029,1) 				!029 PUNCH CODE TRANSLATION 
 	); 			! 
  

  
 ! 
 ! DEVICE ADAPTER, CLASS, AND TYPE DEFINITIONS 
 ! 
 !...$DCDEF	
  
 ! 
 ! DEFINE ADAPTER TYPES 
 ! 
 LITERAL	
 $EQULST (AT$_,GBL,0,1 				!DEFINE ADAPTER TYPES 
 	,(MBA,0) 				! MASSBUS ADAPTER 
 	,(UBA,1) 				! UNIBUS ADAPTER 
 	); 
 ! 
 ! DEFINE DEVICE CLASSES 
 ! 
 LITERAL	
 $EQULST (DC$_,GBL,0,1 				!DEFINE DEVICE CLASSES 
 	,(DISK,1) 				! DISK 
 	,(TAPE,2) 				! TAPES 
 	,(SCOM,32) 				! SYNCHRONOUS COMMUNICATIONS DEVICES 
 	,(CARD,65) 				! CARD READER 
 	,(TERM,66) 				! TERMINAL 
 	,(LP,67) 				! LINE PRINTER 
 	,(MAILBOX,160) 			! MAILBOX 
 	); 
  
 ! 
 ! DEFINE DEVICE TYPES 
 ! 
  
 LITERAL	
 $EQULST (DT$_,GBL,0,1 				! 
  
 ! 
 ! DISK DEVICES 
 ! 
  
 	,(RK06,1) 				!RK06 DISK 
 	,(RK07,2) 				!RK07 DISK 
 	,(RP04,3) 				!RP04 DISK 
 	,(RP05,4) 				!RP05 DISK 
 	,(RP06,5) 				!RP06 DISK 
 	,(RM03,6) 				!RM03 DISK 
 	,(RP07,7) 				!RP07 DISK 
 	,(RP07HT,8) 			!RP07 DISK WITH HEAD/TRACK 
  
 ! 
 ! TAPE DEVICES 
 ! 
  
 	,(TE16,1) 				!TE16 MAGTAPE 
 	,(TU45,2) 				!TU45 MAGTAPE 
 	,(TU77,3) 				!TU77 MAGTAPE 
 	); 			! 
 LITERAL	
 $EQULST (DT$_,GBL,0,1 			! **** MATCHES $TTDEF ***** 
 	,(TTYUNKN,0) 				! UNKNOWN TERMINAL 
 	,(VT05,1) 					! VT05 
 	,(LAX,32) 					! LA TYPE TERMINAL 
 	,(LA36,32) 					! LA36 
 	,(VT5X,64) 					! VT5X TYPE 
 	,(VT52,64) 					! VT52 
 	,(VT55,65) 					! VT55 
 	); 			! ****** 
 LITERAL	
 $EQULST (DT$_,GBL,0,1 			 
 	,(XM_ARDA,1) 				! DMC11 AR WITH DA 
 	,(XM_ARFA,2) 				! DMC11 AR WITH FA 
 	,(XM_ALMA,9) 				! DMC11 AL WITH MA 
 	,(XM_ALMD,10) 				! DMC11 AL WITH MA 
 	); 
 LITERAL	
 $EQULST (DT$_,GBL,0,1 			 
 	,(LP11,1) 					! LP11 
 	,(LA11,2) 					! LA11 
 	,(LA180,3) 					! LA180 
 	); 
 LITERAL	
 $EQULST (DT$_,GBL,0,1 			 
 	,(CR11,1) 					! CR11 CARD READER 
 	); 
 LITERAL	
 $EQULST (DT$_,GBL,0,1 			 
 	,(MBX,1) 					! GENERIC MAILBOX 
 	); 
  

  
 ! 
 !  THE FOLLOWING BITS DEFINE THE DEVICE CHARACTERISTICS FOR 
 !  BOTH THE UCBS AND RMS. 
 ! 
 !...$DEVDEF	
 			 
 MACRO		DEV$V_REC	= 0,0,1,0%; 		! DEVICE RECORD ORIENTED 
 LITERAL	DEV$M_REC	= 1^1 - 1^0; 
 MACRO		DEV$V_CCL	= 0,1,1,0%; 		! CARRIAGE CONTROL DEVICE 
 LITERAL	DEV$M_CCL	= 1^2 - 1^1; 
 MACRO		DEV$V_TRM	= 0,2,1,0%; 		! DEVICE IS A TERMINAL 
 LITERAL	DEV$M_TRM	= 1^3 - 1^2; 
 MACRO		DEV$V_DIR	= 0,3,1,0%; 		! DEVICE IS DIRECTORY STRUCTURED 
 LITERAL	DEV$M_DIR	= 1^4 - 1^3; 
 MACRO		DEV$V_SDI	= 0,4,1,0%; 		! DEVICE IS SINGLE DIRECTORY STRUCTURED 
 LITERAL	DEV$M_SDI	= 1^5 - 1^4; 
 MACRO		DEV$V_SQD	= 0,5,1,0%; 		! SEQUENTIAL BLOCK-ORIENTED DEVICE (I.E., MAGTAPE) 
 LITERAL	DEV$M_SQD	= 1^6 - 1^5; 
 MACRO		DEV$V_SPL	= 0,6,1,0%; 		! DEVICE BEING SPOOLED 
 LITERAL	DEV$M_SPL	= 1^7 - 1^6; 
 						! SPARES TO CORRESPOND WITH RSX11M 
 MACRO		DEV$V_NET	= 0,13,1,0%; 		! NETWORK DEVICE 
 LITERAL	DEV$M_NET	= 1^14 - 1^13; 
 MACRO		DEV$V_FOD	= 0,14,1,0%; 		! FILES-ORIENTED DEVICE (I.E., DISK AND MT) 
 LITERAL	DEV$M_FOD	= 1^15 - 1^14; 
 						! SPARE TO CORRESPOND WITH RSX11M 
 MACRO		DEV$V_SHR	= 0,16,1,0%; 		! DEVICE SHAREABLE 
 LITERAL	DEV$M_SHR	= 1^17 - 1^16; 
 MACRO		DEV$V_GEN	= 0,17,1,0%; 		! DEVICE IS A GENERIC DEVICE 
 LITERAL	DEV$M_GEN	= 1^18 - 1^17; 
 MACRO		DEV$V_AVL	= 0,18,1,0%; 		! DEVICE AVAILABLE FOR USE 
 LITERAL	DEV$M_AVL	= 1^19 - 1^18; 
 MACRO		DEV$V_MNT	= 0,19,1,0%; 		! DEVICE IS MOUNTED 
 LITERAL	DEV$M_MNT	= 1^20 - 1^19; 
 MACRO		DEV$V_MBX	= 0,20,1,0%; 		! DEVICE IS A MAILBOX 
 LITERAL	DEV$M_MBX	= 1^21 - 1^20; 
 MACRO		DEV$V_DMT	= 0,21,1,0%; 		! DEVICE MARKED FOR DISMOUNT 
 LITERAL	DEV$M_DMT	= 1^22 - 1^21; 
 MACRO		DEV$V_ELG	= 0,22,1,0%; 		! DEVICE HAS ERROR LOGGING ENABLED 
 LITERAL	DEV$M_ELG	= 1^23 - 1^22; 
 MACRO		DEV$V_ALL	= 0,23,1,0%; 		! DEVICE IS ALLOCATED 
 LITERAL	DEV$M_ALL	= 1^24 - 1^23; 
 MACRO		DEV$V_FOR	= 0,24,1,0%; 		! DEVICE IS MOUNTED FOREIGN (I.E., NON-FILE STRUCTURED) 
 LITERAL	DEV$M_FOR	= 1^25 - 1^24; 
 MACRO		DEV$V_SWL	= 0,25,1,0%; 		! DEVICE IS SOFTWARE WRITE LOCKED 
 LITERAL	DEV$M_SWL	= 1^26 - 1^25; 
 MACRO		DEV$V_IDV	= 0,26,1,0%; 		! DEVICE CAPABLE OF PROVIDING INPUT 
 LITERAL	DEV$M_IDV	= 1^27 - 1^26; 
 MACRO		DEV$V_ODV	= 0,27,1,0%; 		! DEVICE CAPABLE OF PROVIDING OUTPUT 
 LITERAL	DEV$M_ODV	= 1^28 - 1^27; 
 MACRO		DEV$V_RND	= 0,28,1,0%; 		! DEVICE ALLOWS RANDOM ACCESS 
 LITERAL	DEV$M_RND	= 1^29 - 1^28; 
 MACRO		DEV$V_RTM	= 0,29,1,0%; 		! DEVICE IS REALTIME IN NATURE 
 LITERAL	DEV$M_RTM	= 1^30 - 1^29; 
 MACRO		DEV$V_RCK	= 0,30,1,0%; 		! DEVICE HAS READ CHECKING ENABLED 
 LITERAL	DEV$M_RCK	= 1^31 - 1^30; 
 MACRO		DEV$V_WCK	= 0,31,1,0%; 		! DEVICE HAS WRITE CHECKING ENABLED 
 LITERAL	DEV$M_WCK	= 1^32 - 1^31; 
 			

  
 !+ 
 ! DEVICE INFORMATION BLOCK DEFINITIONS 
 !- 
  
 !...$DIBDEF	
  
 MACRO		DIB$L_DEVCHAR	= 0,0,32,0%; 		!DEVICE CHARACTERISTICS 
 MACRO		DIB$B_DEVCLASS	= 4,0,8,0%; 		!DEVICE CLASS 
 MACRO		DIB$B_DEVTYPE	= 5,0,8,0%; 		!DEVICE TYPE 
 MACRO		DIB$W_DEVBUFSIZ	= 6,0,16,0%; 		!DEVICE BUFFER SIZE 
 MACRO		DIB$L_DEVDEPEND	= 8,0,32,0%; 		!DEVICE DEPENDENT INFORMATION 
 MACRO		DIB$W_UNIT	= 12,0,16,0%; 			!DEVICE UNIT NUMBER 
 MACRO		DIB$W_DEVNAMOFF	= 14,0,16,0%; 		!OFFSET TO DEVICE NAME COUNTED STRING 
 MACRO		DIB$L_PID	= 16,0,32,0%; 			!DEVICE OWNER PROCESS IDENTIFICATION 
 MACRO		DIB$L_OWNUIC	= 20,0,32,0%; 		!DEVICE OWNER USER IDENTIFICATION CODE 
 MACRO		DIB$W_VPROT	= 24,0,16,0%; 			!DEVICE PROTECTION MASK 
 MACRO		DIB$W_ERRCNT	= 26,0,16,0%; 		!DEVICE ERROR COUNT 
 MACRO		DIB$L_OPCNT	= 28,0,32,0%; 			!DEVICE OPERATIONS COUNT 
 MACRO		DIB$W_VOLNAMOFF	= 32,0,16,0%; 		!OFFSET TO VOLUME LABEL COUNTED STRING 
 MACRO		DIB$W_RECSIZ	= 34,0,16,0%; 		!BLOCKED RECORD SIZE 
 LITERAL	DIB$C_LENGTH	= 36; 
 LITERAL	DIB$K_LENGTH	= 36; 				!LENGTH OF FIXED PART 
  

  
 ! 
 ! LAYOUT OF THE FILE IDENTIFICATION BLOCK (FIB) 
 ! 
 !...$FIBDEF	
 MACRO		FIB$L_ACCTL	= 0,0,32,0%; 			! ACCESS CONTROL BITS 
 			 
 MACRO		FIB$V_NOWRITE	= 0,0,1,0%; 		! NO OTHER WRITERS 
 LITERAL	FIB$M_NOWRITE	= 1^1 - 1^0; 
 MACRO		FIB$V_DLOCK	= 0,1,1,0%; 		! ENABLE DEACCESS LOCK 
 LITERAL	FIB$M_DLOCK	= 1^2 - 1^1; 
 						! UNUSED 
 MACRO		FIB$V_SPOOL	= 0,4,1,0%; 		! SPOOL FILE ON CLOSE 
 LITERAL	FIB$M_SPOOL	= 1^5 - 1^4; 
 MACRO		FIB$V_WRITECK	= 0,5,1,0%; 		! ENABLE WRITE CHECK 
 LITERAL	FIB$M_WRITECK	= 1^6 - 1^5; 
 MACRO		FIB$V_SEQONLY	= 0,6,1,0%; 		! SEQUENTIAL ONLY ACCESS 
 LITERAL	FIB$M_SEQONLY	= 1^7 - 1^6; 
 						! SPARE 
 MACRO		FIB$V_WRITE	= 0,8,1,0%; 		! WRITE ACCESS 
 LITERAL	FIB$M_WRITE	= 1^9 - 1^8; 
 MACRO		FIB$V_READCK	= 0,9,1,0%; 		! ENABLE READ CHECK 
 LITERAL	FIB$M_READCK	= 1^10 - 1^9; 
 MACRO		FIB$V_NOREAD	= 0,10,1,0%; 		! NO OTHER READERS 
 LITERAL	FIB$M_NOREAD	= 1^11 - 1^10; 
 MACRO		FIB$V_NOTRUNC	= 0,11,1,0%; 		! FILE MAY NOT BE TRUNCATED 
 LITERAL	FIB$M_NOTRUNC	= 1^12 - 1^11; 
 						! SPARE 
 				! THE HIGH 8 BITS CANNOT BE COPIED 
 				! INTO THE ACCESS MODE WORD IN THE WINDOW 
 MACRO		FIB$V_EXECUTE	= 0,16,1,0%; 		! ACCESS FOR EXECUTE (USE EXECUTE PROTECTION) 
 LITERAL	FIB$M_EXECUTE	= 1^17 - 1^16; 
 MACRO		FIB$V_PRSRV_ATR	= 0,17,1,0%; 	! PRESERVE ORIGINAL ATTRIBUTES OF FILE 
 LITERAL	FIB$M_PRSRV_ATR	= 1^18 - 1^17; 
 						! SPARE 
 			
 						! OVERLAPPING BITS USED FOR MAGTAPE 
 				 
 MACRO		FIB$V_REWIND	= 0,3,1,0%; 		! REWIND TAPE 
 LITERAL	FIB$M_REWIND	= 1^4 - 1^3; 
 MACRO		FIB$V_CURPOS	= 0,4,1,0%; 		! CREATE AT CURRENT TAPE POSITION 
 LITERAL	FIB$M_CURPOS	= 1^5 - 1^4; 
 				 
 MACRO		FIB$V_UPDATE	= 0,6,1,0%; 		! UPDATE MODE (POSITION TO START OF FILE) 
 LITERAL	FIB$M_UPDATE	= 1^7 - 1^6; 
 			
 MACRO		FIB$B_WSIZE	= 3,0,8,1%; 	! WINDOW SIZE 
 MACRO		FIB$W_FID	= 4,0,0,0%; 		! FILE ID 
 LITERAL	FIB$S_FID	= 6; 
 MACRO		FIB$W_FID_NUM	= 4,0,16,0%; 	! FILE NUMBER 
 MACRO		FIB$W_FID_SEQ	= 6,0,16,0%; 	! FILE SEQUENCE NUMBER 
 MACRO		FIB$W_FID_RVN	= 8,0,16,0%; 	! RELATIVE VOLUME NUMBER 
 MACRO		FIB$B_FID_RVN	= 8,0,8,0%; 	! SHORT FORM RVN 
 MACRO		FIB$B_FID_NMX	= 9,0,8,0%; 	! EXTENDED FILE NUMBER 
 LITERAL	FIB$C_ACCDATA	= 10; 
 LITERAL	FIB$K_ACCDATA	= 10; 			! ABOVE DATA NECESSARY FOR ACCESS 
 MACRO		FIB$W_DID	= 10,0,0,0%; 		! DIRECTORY ID 
 LITERAL	FIB$S_DID	= 6; 
 MACRO		FIB$W_DID_NUM	= 10,0,16,0%; 	! FILE NUMBER 
 MACRO		FIB$W_DID_SEQ	= 12,0,16,0%; 	! FILE SEQUENCE NUMBER 
 MACRO		FIB$W_DID_RVN	= 14,0,16,0%; 	! RELATIVE VOLUME NUMBER 
 MACRO		FIB$B_DID_RVN	= 14,0,8,0%; 	! SHORT FORM RVN 
 MACRO		FIB$B_DID_NMX	= 15,0,8,0%; 	! EXTENDED FILE NUMBER 
 MACRO		FIB$L_WCC	= 16,0,32,0%; 			! WILD CARD CONTEXT 
 MACRO		FIB$W_NMCTL	= 20,0,16,0%; 		! NAME CONTROL BITS 
 			 
 				 
 MACRO		FIB$V_ALLVER	= 20,3,1,0%; 		! MATCH ALL VERSIONS 
 LITERAL	FIB$M_ALLVER	= 1^4 - 1^3; 
 MACRO		FIB$V_ALLTYP	= 20,4,1,0%; 		! MATCH ALL TYPES 
 LITERAL	FIB$M_ALLTYP	= 1^5 - 1^4; 
 MACRO		FIB$V_ALLNAM	= 20,5,1,0%; 		! MATCH ALL NAMES 
 LITERAL	FIB$M_ALLNAM	= 1^6 - 1^5; 
 				 
 MACRO		FIB$V_WILD	= 20,8,1,0%; 		! WILD CARDS IN FILE NAME 
 LITERAL	FIB$M_WILD	= 1^9 - 1^8; 
 MACRO		FIB$V_NEWVER	= 20,9,1,0%; 		! MAXIMIZE VERSION NUMBER 
 LITERAL	FIB$M_NEWVER	= 1^10 - 1^9; 
 MACRO		FIB$V_SUPERSEDE	= 20,10,1,0%; 	! SUPERSEDE EXISTING FILE 
 LITERAL	FIB$M_SUPERSEDE	= 1^11 - 1^10; 
 MACRO		FIB$V_FINDFID	= 20,11,1,0%; 		! SEARCH FOR FILE ID 
 LITERAL	FIB$M_FINDFID	= 1^12 - 1^11; 
 				 
 MACRO		FIB$V_LOWVER	= 20,14,1,0%; 		! LOWER VERSION OF FILE EXISTS 
 LITERAL	FIB$M_LOWVER	= 1^15 - 1^14; 
 MACRO		FIB$V_HIGHVER	= 20,15,1,0%; 		! HIGHER VERSION OF FILE EXISTS 
 LITERAL	FIB$M_HIGHVER	= 1^16 - 1^15; 
 			
 LITERAL	FIB$C_DIRDATA	= 22; 
 LITERAL	FIB$K_DIRDATA	= 22; 			! ABOVE DATA NECESSARY FOR DIRECTORY OPS 
 						! MARK PARAMETER VARIATION 
 MACRO		FIB$W_EXCTL	= 22,0,16,0%; 		! EXTEND CONTROL 
 			 
 MACRO		FIB$V_ALCON	= 22,0,1,0%; 		! ALLOCATE CONTIGUOUS 
 LITERAL	FIB$M_ALCON	= 1^1 - 1^0; 
 MACRO		FIB$V_ALCONB	= 22,1,1,0%; 		! CONTIGUOUS BEST EFFORT 
 LITERAL	FIB$M_ALCONB	= 1^2 - 1^1; 
 MACRO		FIB$V_FILCON	= 22,2,1,0%; 		! MARK FILE CONTIGUOUS 
 LITERAL	FIB$M_FILCON	= 1^3 - 1^2; 
 MACRO		FIB$V_ALDEF	= 22,3,1,0%; 		! ALLOCATE DEFAULT AMOUNT 
 LITERAL	FIB$M_ALDEF	= 1^4 - 1^3; 
 				 
 MACRO		FIB$V_EXTEND	= 22,7,1,0%; 		! ENABLE EXTENSION 
 LITERAL	FIB$M_EXTEND	= 1^8 - 1^7; 
 MACRO		FIB$V_TRUNC	= 22,8,1,0%; 		! ENABLE TRUNCATION 
 LITERAL	FIB$M_TRUNC	= 1^9 - 1^8; 
 MACRO		FIB$V_NOHDREXT	= 22,9,1,0%; 	! INHIBIT EXTENSION HEADERS 
 LITERAL	FIB$M_NOHDREXT	= 1^10 - 1^9; 
 MACRO		FIB$V_MARKBAD	= 22,10,1,0%; 		! MARK BLOCKS BAD 
 LITERAL	FIB$M_MARKBAD	= 1^11 - 1^10; 
 			
 						! MARK PARAMETER VARIATION 
 MACRO		FIB$L_EXSZ	= 24,0,32,0%; 			! EXTEND SIZE 
 MACRO		FIB$L_EXVBN	= 28,0,32,0%; 			! EXTENSION VBN 
 LITERAL	FIB$C_EXTDATA	= 32; 
 LITERAL	FIB$K_EXTDATA	= 32; 			! ABOVE NECESSARY FOR BASIC FILE EXTENSION 
 MACRO		FIB$B_ALOPTS	= 32,0,8,0%; 		! ALLOCATION OPTIONS 
 			 
 MACRO		FIB$V_EXACT	= 32,0,1,0%; 		! EXACT PLACEMENT REQUIRED 
 LITERAL	FIB$M_EXACT	= 1^1 - 1^0; 
 MACRO		FIB$V_ONCYL	= 32,1,1,0%; 		! PUT ALLOCATION ON ONE CYLINDER 
 LITERAL	FIB$M_ONCYL	= 1^2 - 1^1; 
 			
 MACRO		FIB$B_ALALIGN	= 33,0,8,0%; 		! ALLOCATION ALIGNMENT 
 LITERAL	FIB$C_CYL	= 1; 			! CYLINDER ADDRESS SPECIFIED 
 LITERAL	FIB$C_LBN	= 2; 			! LBN SPECIFIED 
 LITERAL	FIB$C_VBN	= 3; 			! PROXIMATE VBN SPECIFIED 
 LITERAL	FIB$C_RFI	= 4; 			! RELATED FILE ID SPECIFIED 
 MACRO		FIB$W_ALLOC	= 34,0,0,0%; 		! ALLOCATION LOCATION 
 LITERAL	FIB$S_ALLOC	= 10; 
 MACRO		FIB$W_LOC_FID	= 34,0,0,0%; 	! RELATED FILE ID 
 LITERAL	FIB$S_LOC_FID	= 6; 
 MACRO		FIB$W_LOC_NUM	= 34,0,16,0%; 	! RELATED FILE NUMBER 
 MACRO		FIB$W_LOC_SEQ	= 36,0,16,0%; 	! FILE SEQUENCE NUMBER 
 MACRO		FIB$W_LOC_RVN	= 38,0,16,0%; 	! RELATED RVN 
 MACRO		FIB$B_LOC_RVN	= 38,0,8,0%; 	! SHORT FORM RVN 
 MACRO		FIB$B_LOC_NMX	= 39,0,8,0%; 	! EXTENDED FILE NUMBER 
 MACRO		FIB$L_LOC_ADDR	= 40,0,32,0%; 		! LOCATION ADDRESS (VBN, LBN, CYL) 
 LITERAL	FIB$C_ALCDATA	= 44; 
 LITERAL	FIB$K_ALCDATA	= 44; 			! ABOVE DATA NECESSARY FOR PLACEMENT 
 LITERAL	FIB$C_LENGTH	= 44; 
 LITERAL	FIB$K_LENGTH	= 44; 	 
  
 						! START OF ACP CONTROL PARAMETERS 
 MACRO		FIB$W_CNTRLFUNC	= 22,0,16,0%; 		! ACP CONTROL FUNCTION 
 ! DEFINE ACP CONTROL FUNCTION CODES 
 ! 
 LITERAL	
 $EQULST (FIB$C_,GBL,1,1  
 	,(REWINDVOL,) 		! REWIND VOLUME SET 
 	,(POSEND,) 			! POSITION TO END OF VOLUME SET 
 	,(NEXTVOL,) 			! FORCE NEXT VOLUME 
 	,(SPACE,) 			! SPACE MAGNETIC TAPE 
 	,(ILLEGAL,) 			! 
 	,(REWINDFIL,) 		! REWIND FILE 
 	); 
 MACRO		FIB$L_CNTRLVAL	= 24,0,32,0%; 		! ACP CONTROL FUNCTION VALUE PARAMETER 
  
  
 LITERAL	FIB$C_MTALEN	= 28; 
 LITERAL	FIB$K_MTALEN	= 28; 			! LENGTH OF MTAACP DATA 
  

  
 ! 
 ! STRUCTURE OF A FILE ID (FID) 
 ! 
  
 !...$FIDDEF	
  
 MACRO		FID$W_NUM	= 0,0,16,0%; 			! FILE NUMBER 
 MACRO		FID$W_SEQ	= 2,0,16,0%; 			! FILE SEQUENCE NUMBER 
 MACRO		FID$W_RVN	= 4,0,16,0%; 			! RELATIVE VOLUME NUMBER 
 MACRO		FID$B_RVN	= 4,0,8,0%; 		! BYTE FORM OF RVN 
 MACRO		FID$B_NMX	= 5,0,8,0%; 		! FILE NUMBER EXTENSION 
 LITERAL	FID$C_LENGTH	= 6; 
 LITERAL	FID$K_LENGTH	= 6; 	 
  

  
 !+ 
 ! I/O FUNCTION CODE DEFINITIONS 
 !- 
  
 !...$IODEF	
  
 ! 
 ! *** START PHYSICAL I/O FUNCTION CODES *** 
 ! 
  
 LITERAL	
 $EQULST (IO$_,GBL,0,1  
 	,(NOP,0) 				!NO OPERATION 
 	,(UNLOAD,1) 			!UNLOAD DRIVE 
 	,(SEEK,2) 				!SEEK CYLINDER 
 	,(SPACEFILE,2) 			!SPACE FILES 
 	,(RECAL,3) 				!RECALIBRATE DRIVE 
 	,(DRVCLR,4) 			!DRIVE CLEAR 
 	,(RELEASE,5) 			!RELEASE PORT 
 	,(OFFSET,6) 			!OFFSET READ HEADS 
 	,(ERASETAPE,6) 			!ERASE TAPE 
 	,(RETCENTER,7) 			!RETURN TO CENTERLINE 
 	,(PACKACK,8) 			!PACK ACKNOWLEDGE 
 	,(SEARCH,9) 			!SEARCH FOR SECTOR 
 	,(SPACERECORD,9) 			!SPACE RECORDS 
 	,(WRITECHECK,10) 			!WRITE CHECK DATA 
 	,(WRITEPBLK,11) 			!WRITE PHYSICAL BLOCK 
 	,(READPBLK,12) 			!READ PHYSICAL BLOCK 
 	,(WRITEHEAD,13) 			!WRITE HEADER AND DATA 
 	,(READHEAD,14) 			!READ HEADER AND DATA 
 	,(WRITETRACKD,15) 			!WRITE TRACK DATA 
 	,(READTRACKD,16) 			!READ TRACK DATA 
 	,(WRITECHECKH,24) 			!WRITE CHECK HEADER AND DATA 
 	,(READPRESET,25) 			!READIN PRESET 
 	,(STARTSPNDL,25) 			!START SPINDLE 
 	,(SETCHAR,26) 			!SET CHARACTERISTICS 
 	,(SENSECHAR,27) 			!SENSE TAPE CHARACTERISTICS 
 	,(WRITEMARK,28) 			!WRITE TAPE MARK 
 	,(DIAGNOSE,29) 			!DIAGNOSE 
 	,(PHYSICAL,31) 			!HIGHEST PHYSICAL I/O FUNCTION CODE 
 	); 
  
 ! 
 ! *** START LOGICAL I/O FUNCTION CODES *** 
 ! 
  
 LITERAL	
 $EQULST (IO$_,GBL,0,1  
 	,(WRITELBLK,32) 			!WRITE LOGICAL BLOCK 
 	,(READLBLK,33) 			!READ LOGICAL BLOCK 
 	,(REWINDOFF,34) 			!REWIND AND SET OFFLINE 
 	,(SETMODE,35) 			!SET MODE 
 	,(REWIND,36) 			!REWIND TAPE 
 	,(SKIPFILE,37) 			!SKIP FILES 
 	,(SKIPRECORD,38) 			!SKIP RECORDS 
 	,(SENSEMODE,39) 			!SENSE TAPE MODE 
 	,(WRITEOF,40) 			!WRITE END OF FILE 
 	,(LOGICAL,47) 			!HIGHEST LOGICAL I/O FUNCTION CODE 
 	); 
  
 ! 
 ! *** START VIRTUAL I/O FUNCTION CODES 
 ! 
  
 LITERAL	
 $EQULST (IO$_,GBL,0,1  
 	,(WRITEVBLK,48) 			!WRITE VIRTUAL BLOCK 
 	,(READVBLK,49) 			!READ VIRTUAL BLOCK 
 	,(ACCESS,50) 			!ACCESS FILE 
 	,(CREATE,51) 			!CREATE FILE 
 	,(DEACCESS,52) 			!DEACCESS FILE 
 	,(DELETE,53) 			!DELETE FILE 
 	,(MODIFY,54) 			!MODIFY FILE 
 	,(READPROMPT,55) 			!READ TERMINAL WITH PROMPT 
 	,(ACPCONTROL,56) 			!MISCELLANEOUS ACP CONTROL 
 	,(MOUNT,57) 			!MOUNT VOLUME 
 	,(VIRTUAL,63) 			!HIGHEST VIRTUAL I/O FUNCTION 
 	); 
  
 ! 
 ! FUNCTION MODIFIER BIT DEFINITIONS 
 ! 
  
 							! MODIFIER BIT DEFINITIONS 
 MACRO		IO$V_FCODE	= 0,0,6,0%; 		! FUNCTION CODE FIELD 
 LITERAL	IO$M_FCODE	= 1^6 - 1^0; 
 							! RESERVED BITS 
 MACRO		IO$V_INHERLOG	= 0,11,1,0%; 		! INHIBIT ERROR LOGGING 
 LITERAL	IO$M_INHERLOG	= 1^12 - 1^11; 
 MACRO		IO$V_INHSEEK	= 0,12,1,0%; 		! INHIBIT IMPLIED SEEK ON PHYSICAL FUNCTIONS 
 LITERAL	IO$M_INHSEEK	= 1^13 - 1^12; 
 							! RESERVED BIT 
 MACRO		IO$V_DATACHECK	= 0,14,1,0%; 		! WRITE CHECK DATA AFTER TRANSFER 
 LITERAL	IO$M_DATACHECK	= 1^15 - 1^14; 
 MACRO		IO$V_INHRETRY	= 0,15,1,0%; 		! INHIBIT ERROR RETRY 
 LITERAL	IO$M_INHRETRY	= 1^16 - 1^15; 
 			
  
 							!DR DRIVER FUNCTION MODIFIER BITS 
 							! FUNCTION CODE 
 MACRO		IO$V_COMMOD	= 0,6,1,0%; 		! DIAGNOSTIC COMMAND MODIFIER 
 LITERAL	IO$M_COMMOD	= 1^7 - 1^6; 
 			
  
 							!MAGTAPE FUNCTION MODIFIER BITS 
 							! FUNCTION CODE 
 MACRO		IO$V_REVERSE	= 0,6,1,0%; 		! REVERSE OPERATION 
 LITERAL	IO$M_REVERSE	= 1^7 - 1^6; 
 MACRO		IO$V_NOWAIT	= 0,7,1,0%; 		! NO WAIT FOR REWIND TO COMPLETE 
 LITERAL	IO$M_NOWAIT	= 1^8 - 1^7; 
 MACRO		IO$V_INTSKIP	= 0,8,1,0%; 		! INTERNAL SKIP RECORD FUNCTION 
 LITERAL	IO$M_INTSKIP	= 1^9 - 1^8; 
 							! RESERVED BITS 
 MACRO		IO$V_INHEXTGAP	= 0,12,1,0%; 		! INHIBIT EXTENDED INTERRRECORD GAP 
 LITERAL	IO$M_INHEXTGAP	= 1^13 - 1^12; 
 			
 							!ACP FUNCTION MODIFIER BITS 
 							!FUNCTION CODE 
 MACRO		IO$V_ACCESS	= 0,6,1,0%; 		! ACCESS FILE 
 LITERAL	IO$M_ACCESS	= 1^7 - 1^6; 
 MACRO		IO$V_CREATE	= 0,7,1,0%; 		! CREATE FILE 
 LITERAL	IO$M_CREATE	= 1^8 - 1^7; 
 MACRO		IO$V_DELETE	= 0,8,1,0%; 		! DELETE FILE 
 LITERAL	IO$M_DELETE	= 1^9 - 1^8; 
 MACRO		IO$V_MOUNT	= 0,9,1,0%; 		! MOUNT VOLUME 
 LITERAL	IO$M_MOUNT	= 1^10 - 1^9; 
 MACRO		IO$V_DMOUNT	= 0,10,1,0%; 		! DISMOUNT VOLUME 
 LITERAL	IO$M_DMOUNT	= 1^11 - 1^10; 
 			
  
 							!CARD READER MODIFIER BITS 
 							! FUNCTION CODE 
 MACRO		IO$V_BINARY	= 0,6,1,0%; 		! BINARY READ 
 LITERAL	IO$M_BINARY	= 1^7 - 1^6; 
 MACRO		IO$V_PACKED	= 0,7,1,0%; 		! PACKED READ 
 LITERAL	IO$M_PACKED	= 1^8 - 1^7; 
 						! 
  
 							!MAILBOX MODIFIER BITS 
 							!FUNCTION CODE 
 MACRO		IO$V_NOW	= 0,6,1,0%; 			!DO NOT WAIT FOR OPERATION COMPLETE 
 LITERAL	IO$M_NOW	= 1^7 - 1^6; 
 MACRO		IO$V_READATTN	= 0,7,1,0%; 		!REQUEST AST ON WAITING READER 
 LITERAL	IO$M_READATTN	= 1^8 - 1^7; 
 MACRO		IO$V_WRTATTN	= 0,8,1,0%; 		!REQUEST AST ON WAITING WRITER 
 LITERAL	IO$M_WRTATTN	= 1^9 - 1^8; 
 			
  
 							!TERMINAL READ FUNCTION MODIFIERS 
 							!FUNCTION CODE 
 MACRO		IO$V_NOECHO	= 0,6,1,0%; 		!NOECHO 
 LITERAL	IO$M_NOECHO	= 1^7 - 1^6; 
 MACRO		IO$V_TIMED	= 0,7,1,0%; 		!TIMED 
 LITERAL	IO$M_TIMED	= 1^8 - 1^7; 
 MACRO		IO$V_CVTLOW	= 0,8,1,0%; 		!CONVERT LOWER CASE 
 LITERAL	IO$M_CVTLOW	= 1^9 - 1^8; 
 MACRO		IO$V_NOFILTR	= 0,9,1,0%; 		!NO FILTER 
 LITERAL	IO$M_NOFILTR	= 1^10 - 1^9; 
 MACRO		IO$V_DSABLMBX	= 0,10,1,0%; 		!DISABLE MAILBOX 
 LITERAL	IO$M_DSABLMBX	= 1^11 - 1^10; 
 MACRO		IO$V_PURGE	= 0,11,1,0%; 		!PURGE TYPEAHEAD 
 LITERAL	IO$M_PURGE	= 1^12 - 1^11; 
 MACRO		IO$V_TRMNOECHO	= 0,12,1,0%; 		!TERMINATORS ARE NOT ECHOED 
 LITERAL	IO$M_TRMNOECHO	= 1^13 - 1^12; 
 			
  
 							!TERMINAL WRITE FUNCTION MODIFIERS 
 							! FUNCTION CODE 
 MACRO		IO$V_CANCTRLO	= 0,6,1,0%; 		!CANCEL CONTROL O 
 LITERAL	IO$M_CANCTRLO	= 1^7 - 1^6; 
 MACRO		IO$V_ENABLMBX	= 0,7,1,0%; 		!ENABLE MAILBOX 
 LITERAL	IO$M_ENABLMBX	= 1^8 - 1^7; 
 MACRO		IO$V_NOFORMAT	= 0,8,1,0%; 		!DO NOT FORMAT OUTPUT 
 LITERAL	IO$M_NOFORMAT	= 1^9 - 1^8; 
 			
  
 							!TERMINAL SETMODE SUBFUNCTIONS 
 							! RESERVE FUNCTION CODES 
 MACRO		IO$V_CTRLYAST	= 0,7,1,0%; 		!SET CONTROL Y AST 
 LITERAL	IO$M_CTRLYAST	= 1^8 - 1^7; 
 MACRO		IO$V_CTRLCAST	= 0,8,1,0%; 		!SET CONTROL C 
 LITERAL	IO$M_CTRLCAST	= 1^9 - 1^8; 
 MACRO		IO$V_HANGUP	= 0,9,1,0%; 		!SET MODE AND HANG UP LINE 
 LITERAL	IO$M_HANGUP	= 1^10 - 1^9; 
 			
 							! DMC/COMM DRIVER SETMODE SUBFUNCTIONS 
 							! 
 MACRO		IO$V_STARTUP	= 0,6,1,0%; 		! START PROTOCOL 
 LITERAL	IO$M_STARTUP	= 1^7 - 1^6; 
 MACRO		IO$V_SHUTDOWN	= 0,7,1,0%; 		! STOP PROTOCOL 
 LITERAL	IO$M_SHUTDOWN	= 1^8 - 1^7; 
 MACRO		IO$V_ATTNAST	= 0,8,1,0%; 		! ATTENTION AST 
 LITERAL	IO$M_ATTNAST	= 1^9 - 1^8; 
 			
 							! NETWORK WRITE VIRTUAL MODIFIER BITS 
 							! FUNCTION CODE 
 MACRO		IO$V_INTERRUPT	= 0,6,1,0%; 		! INTERRUPT MSG 
 LITERAL	IO$M_INTERRUPT	= 1^7 - 1^6; 
 			
 							! NETWORK ACCESS/DEACCESS MODIFIER BITS 
 							! FUNCTION CODE 
 MACRO		IO$V_ABORT	= 0,8,1,0%; 		! DISCONNECT ABORT/CONNECT REJECT 
 LITERAL	IO$M_ABORT	= 1^9 - 1^8; 
 MACRO		IO$V_SYNCH	= 0,9,1,0%; 		! SYNCHRONOUS DISCONNECT 
 LITERAL	IO$M_SYNCH	= 1^10 - 1^9; 
 			

  
 !+ 
 ! 
 ! Get Job Process Information Data Identifier Definitions 
 ! 
 ! **** NOTE **** 
 ! 
 !	New items must always be added to the END of each item list 
 !	(preceeding the ENDlistname item) so that users will not have 
 !	to relink. 
 !- 
  
  
 !...$JPIDEF	
  
  
 LITERAL	
 $EQULST (JPI$C_,GBL,0,1 				! DEFINE TABLE NUMBERS 
  
 					! STRUCTURE CODES MUST START AT 1 
 	,(ADRTYPE,1) 			! ITEM IS ADDRESS OF DATA 
 	,(CTLTYPE,2) 			! ITEM IS IN CONTROL REGION 
 	,(PCBTYPE,3) 			! ITEM IN PCB 
 	,(PHDTYPE,4) 			! ITEM IN PHD 
 	,(LISTEND,0) 			! DEFINE ITMLST TERMINATOR 
 	); 
  
 LITERAL	
 $EQULST (JPI$_,GBL,JPI$C_PCBTYPE^8,1 		! ITEM IDENTIFIERS FOR PCB 
  
  
 	,(ASTACT,) 	 			! ACCESS MODES WITH ACTIVE ASTS 
 	,(ASTEN,) 	 			! ACCESS MODES WITH ASTS ENABLED 
 	,(PRI,) 	 			! CURRENT PROCESS PRIORITY 
 	,(OWNER,) 	 			! PID OF CREATOR PROCESS 
 	,(UIC,) 	 			! UIC OF PROCESS 
 	,(STS,) 				! PROCESS STATUS 
 	,(STATE,) 				! PROCESS STATE 
 	,(MEM,) 	 			! MEMBER FIELD OF UIC 
 	,(GRP,) 	 			! GROUP FIELD OF UIC 
 	,(PRIB,) 	 			! PROCESS BASE PRIORITY 
 	,(APTCNT,) 	 			! ACTIVE PAGE TABLE COUNT 
 	,(TMBU,) 				! TERMINATION MAILBOX UNIT 
 	,(GPGCNT,) 	 			! GLOBAL PAGE COUNT IN WORKING SET 
 	,(PPGCNT,) 	 			! PROCESS PAGE COUNT IN WORKING SET 
 	,(ASTCNT,) 	 			! AST COUNT REMAINING 
 	,(BIOCNT,) 	 			! BUFFERED I/O COUNT REMAINING 
 	,(BIOLM,) 	 			! BUFFERED I/O LIMIT 
 	,(BYTCNT,) 	 			! BYTE COUNT REMAINING FOR BUFFERED I/O 
 	,(DIOCNT,) 	 			! DIRECT I/O COUNT REMAINING 
 	,(DIOLM,) 	 			! DIRECT I/O COUNT LIMIT 
 	,(FILCNT,) 	 			! COUNT REMAINING OF OPEN FILES 
 	,(TQCNT,) 	 			! COUNT REMAINING OF TIMER QUEUE ENTRIES 
 	,(EFWM,) 				! EVENT FLAG WAIT MASK 
 	,(EFCS,) 				! LOCAL EVENT FLAGS 0-31 
 	,(EFCU,) 				! LOCAL EVENT FLAGS 32-63 
 	,(PID,) 	 			! PROCESS IDENTIFICATION 
 	,(BYTLM,) 	 			! BUFFERED I/0 BYTE COUNT LIMIT 
 	,(PRCCNT,) 	 			! SUBPROCESS COUNT 
 	,(PRCNAM,) 	 			! PROCESS NAME 
 	,(LASTPCB,) 				! MAX INDEX IN PCB TABLE 
 	); 
  
 LITERAL	
 $EQULST (JPI$_,GBL,JPI$C_PHDTYPE^8,1 		! ITEM IDENTIFIERS FOR PHD 
  
 	,(CURPRIV,) 				! CURRENT PROCESS PRIVILEGE MASK 
 	,(WSAUTH,) 	 			! AUTHORIZED WORKING SET SIZE 
 	,(WSQUOTA,) 	 		! QUOTA ON WORKING SET SIZE 
 	,(DFWSCNT,) 	 		! DEFAULT WORKING SET SIZE 
 	,(FREP0VA,) 	 		! FIRST FREE VIRTUAL ADDR. AT END OF P0 SPACE 
 	,(FREP1VA,) 	 		! FIRST FREE ADDR. AT END OF P1 SPACE 
 	,(DFPFC,) 	 			! DEFAULT PAGE FAULT CLUSTER 
 	,(CPUTIM,) 	 			! ACCUMULATED CPU TIME 
 	,(PRCLM,) 	 			! SUBPROCESS QUOTA 
 	,(ASTLM,) 				! AST LIMIT 
 	,(PAGEFLTS,) 			! COUNT OF PAGE FAULTS 
 	,(DIRIO,) 				! PROCESS DIRECT I/O OPERATIONS 
 	,(BUFIO,) 				! PROCESS BUFFERED I/O OPERATIONS 
 	,(CPULIM,) 				! LIMIT ON CPUTIM FOR PROCESS 
 	,(PGFLQUOTA,) 	 		! MAX. VIRTUAL PAGE COUNT 
 	,(FILLM,) 	 			! OPEN FILE LIMIT 
 	,(TQLM,) 	 			! TIMER QUEUE LIMIT 
 	,(WSSIZE,) 				! CURRENT WORKING SET SIZE 
 	,(LASTPHD,) 				! MAX INDEX IN PROCESS HEADER 
 	); 
  
 	 
 LITERAL	
 $EQULST (JPI$_,GBL,JPI$C_CTLTYPE^8,1 		! ITEM IDENTIFIERS FOR CONTROL REGION 
  
 	,(VIRTPEAK,) 			! PEAK VIRTUAL SIZE 
 	,(WSPEAK,) 				! PEAK WORKING SET SIZE 
 	,(USERNAME,) 			! USERNAME STRING 
 	,(ACCOUNT,) 				! ACCOUNT NAME STRING 
 	,(PROCPRIV,) 			! PROCESS PRIVILEGE MASK 
 	,(VOLUMES,) 				! VOLUMES MOUNTED 
 	,(LOGINTIM,) 			! TIME OF LOGIN OR PROCESS CREATION 
 	,(LASTCTL,) 				! MAX INDEX IN CONTROL REGION 
 	); 
  
  
 LITERAL	
 $EQULST (JPI$_,GBL,JPI$C_ADRTYPE^8,1 		! ITEM IDENTIFIERS FOR ADDRESS DATA 
  
 	,(EXCVEC,) 				! ADDRESS OF "EXCEPTION VECTOR" VECTOR 
 	,(FINALEXC,) 			! ADDRESS OF LAST CHANCE EXCEPTION VECTORS 
 	,(LASTADR,) 				! MAX INDEX IN ADDRESS TABLE 
 	); 
  

 !+ 
 ! LINE PRINTER CHARACTERISTICS DEFINITIONS 
 !- 
 !...$LPDEF	
  
 							!LINE PRINTER CHARACTERISTICS 
 MACRO		LP$V_CR	= 0,0,1,0%; 			! CARRIAGE RETURN NEEDED 
 LITERAL	LP$M_CR	= 1^1 - 1^0; 
 MACRO		LP$V_MECHFORM	= 0,1,1,0%; 		! MECHANICAL FORM FEED 
 LITERAL	LP$M_MECHFORM	= 1^2 - 1^1; 
 							! SPARE UNUSED BITS 
 MACRO		LP$V_LOWER	= 0,7,1,0%; 		! PRINTER HAS LOWER CASE 
 LITERAL	LP$M_LOWER	= 1^8 - 1^7; 
 							! SPARE UNUSED BITS 
 MACRO		LP$V_PAGE_L	= 0,24,8,0%; 		! PAGE LENGTH 
 LITERAL	LP$M_PAGE_L	= 1^32 - 1^24; 
 						! 
  
 LITERAL	
 $EQULST (LP$_,GBL,0,1  
 	,(LP11,1) 	 
 	,(LA11,2) 	 
 	,(LA180,3) 	 
 	); 
  

  
 !+ 
 ! 
 ! SYSTEM WIDE MAILBOX MESSAGE TYPES 
 ! 
 !- 
 !...$MSGDEF			! DEFINE SYSTEM MAILBOX MESSAGES 
 LITERAL	
 $EQULST (MSG$_,GBL,1,1 			! DEFINE CODES AS CONSTANTS 
 	,(TRMUNSOLIC,) 			! UNSOLICITED TERMINAL DATA 
 	,(CRUNSOLIC,) 			! UNSOLICTED CARD READER DATA 
 	,(DELPROC,) 				! DELETE PROCESS 
 	,(SNDSMB,) 				! SEND TO SYMBIONT MANAGER 
 	,(DEVOFFLIN,) 			! DEVICE OFFLINE 
 	,(TRMHANGUP,) 			! TERMINAL HANG UP 
 	,(DEVONLIN,) 			! DEVICE ONLINE 
 	,(OPRQST,) 				! OPERATOR REQUEST *** OVERLAPPED CODE *** 
 	,(OPREPLY,) 				! OPERATOR REPLY *** OVERLAPPED CODE *** 
 	); 
 LITERAL	
 $EQULST (MSG$_,GBL,8,1 			! DEFINE SYMBIONT RESPONSE MESSAGES 
 	,(SMBINI,) 				! SYMBIONT HAS INITED 
 	,(SMBDON,) 				! SYMBIONT FINISHED 
 	,(SNDACC,) 				! SEND MESSAGE TO ACCOUNTING MANAGER 
 	,(XM_DATAVL,) 			! DMC UNSOLICITED DATA 
 	,(XM_SHUTDN,) 			! DMC LINE DOWN 
 	,(XM_ATTN,) 				! DMC ATTENTION MESSAGE 
 	); 
 LITERAL	
 $EQULST (MSG$_,GBL,16,1 			! SYMBIONT COMMAND MESSAGES 
 	,(INIOPR,) 				! INITIATE PRINTING A FILE 
 	,(ABOOPR,) 				! ABORT PRINTING A FILE 
 	,(SUSOPR,) 				! PAUSE PRINTING THE FILE 
 	,(RESOPR,) 				! RESUME PRINTING THE FILE 
 	,(DELSMB,) 				! SYMBIONT SHOULD DELETE ITSELF 
 	); 
 LITERAL	
 $EQULST (MSG$_,GBL,32,1 			! 
 	,(SMBRSP,) 				! SYMBIONT MANAGER RESPONSE 
 	,(ACCRSP,) 				! ACCOUNTING MANAGER RESPONSE 
 	); 
 LITERAL	
 $EQULST (MSG$_,GBL,40,1 			! FILE ACP MESSAGES 
 	,(SCANBAD,) 				! SCAN FILE FOR BAD BLOCKS 
 	,(SCANRSP,) 				! RESPONSE FROM FILE SCANNER 
 	); 
 LITERAL	
 $EQULST (MSG$_,GBL,48,1 			! NETWORK ATTENTION CODES 
 	,(ABORT,) 				! PARTNER ABORTED LINK 
 	,(CONFIRM,) 				! CONNECT CONFIRM 
 	,(CONNECT,) 				! INBOUND CONNECT INITIATE 
 	,(DISCON,) 				! PARTNER DISCONNECTED - HANGUP 
 	,(EXIT,) 				! PARTNER EXITED PREMATURELY 
 	,(INTMSG,) 				! INTERRUPT MESSAGE - UNSOLICITED DATA 
 	,(PATHLOST,) 			! NFW - PATH LOST TO PARTNER 
 	,(PROTOCOL,) 			! PROTOCOL ERROR 
 	,(REJECT,) 				! CONNECT REJECT 
 	,(THIRDPARTY,) 			! THIRD PARTY DISCONNECT 
 	,(TIMEOUT,) 				! CONNECT TIMEOUT 
 	); 

  
 !+ 
 ! MAGTAPE STATUS BITS 
 !- 
  
 !...$MTDEF	
  
 							! MAGTAPE DEVICE DEPENDENT DEFINITIONS 
 							! SPARE UNUSED BITS 
 MACRO		MT$V_PARITY	= 0,3,1,0%; 		! PARITY SELECT (0=ODD, 1=EVEN) 
 LITERAL	MT$M_PARITY	= 1^4 - 1^3; 
 MACRO		MT$V_FORMAT	= 0,4,4,0%; 		! RECORDING FORMAT 
 LITERAL	MT$M_FORMAT	= 1^8 - 1^4; 
 MACRO		MT$V_DENSITY	= 0,8,5,0%; 		! RECORDING DENSITY AND METHOD 
 LITERAL	MT$M_DENSITY	= 1^13 - 1^8; 
 							! SPARE UNUSED BITS 
 MACRO		MT$V_BOT	= 0,16,1,0%; 			! AT BEGINNING OF TAPE 
 LITERAL	MT$M_BOT	= 1^17 - 1^16; 
 MACRO		MT$V_EOF	= 0,17,1,0%; 			! AT END OF FILE 
 LITERAL	MT$M_EOF	= 1^18 - 1^17; 
 MACRO		MT$V_EOT	= 0,18,1,0%; 			! AT END OF TAPE 
 LITERAL	MT$M_EOT	= 1^19 - 1^18; 
 MACRO		MT$V_HWL	= 0,19,1,0%; 			! TAPE IS HARDWARE WRITELOCKED 
 LITERAL	MT$M_HWL	= 1^20 - 1^19; 
 MACRO		MT$V_LOST	= 0,20,1,0%; 		! TAPE POSITION LOST 
 LITERAL	MT$M_LOST	= 1^21 - 1^20; 
 			
  
 ! 
 ! RECORDING FORMAT DEFINTIONS 
 ! 
  
 LITERAL	
 $EQULST (MT$K_,GBL,0,1 				! 
 	,(DEFAULT,0) 			! DEFAULT FORMAT 
 	,(NORMAL11,12) 			! PDP-11 NORMAL 
 	,(CORDMP11,13) 			! PDP-11 CORE DUMP 
 	,(NORMAL15,14) 			! PDP-15 NORMAL 
 	); 
  
 ! 
 ! RECORDING DENTITY AND METHOD DEFINITIONS 
 ! 
  
 LITERAL	
 $EQULST (MT$K_,GBL,0,1 				! 
 !		DEFAULT,0		! DEFAULT DENSITY (SAME AS ABOVE) 
 	,(NRZI_800,3) 			! NRZI 800 BPI 
 	,(PE_1600,4) 			! PE 1600 BPI 
 	); 
  

  
  
 !+ 
 ! OPERATOR COMMUNICATIONS MESSAGE TYPES AND VALUES 
 !- 
 !...$OPRDEF	
 LITERAL	
 $EQULST (OPR$_,GBL,1,1 		! OPERATOR MESSAGE TYPES 
 	,(TERMENABL,) 		! ENABLE TERMINAL 
 	,(LOGINIT,) 			! INITIALIZE THE LOG 
 	,(OPRQST,) 			! OPERATOR REQUEST 
 	,(OPREPLY,) 			! OPERATOR REPLY 
 	); 
 						! OPERATOR NAMES 
 MACRO		OPR$V_CENTRAL	= 0,0,1,0%; 	! 
 LITERAL	OPR$M_CENTRAL	= 1^1 - 1^0; 
 MACRO		OPR$V_PRINTER	= 0,1,1,0%;  
 LITERAL	OPR$M_PRINTER	= 1^2 - 1^1; 
 MACRO		OPR$V_TAPES	= 0,2,1,0%;  
 LITERAL	OPR$M_TAPES	= 1^3 - 1^2; 
 MACRO		OPR$V_DISKS	= 0,3,1,0%;  
 LITERAL	OPR$M_DISKS	= 1^4 - 1^3; 
 MACRO		OPR$V_DEVICES	= 0,4,1,0%;  
 LITERAL	OPR$M_DEVICES	= 1^5 - 1^4; 
 MACRO		OPR$V_USER1	= 0,5,12,0%;  
 LITERAL	OPR$M_USER1	= 1^17 - 1^5; 
 MACRO		OPR$V_USER2	= 0,17,1,0%;  
 LITERAL	OPR$M_USER2	= 1^18 - 1^17; 
 MACRO		OPR$V_USER3	= 0,18,1,0%;  
 LITERAL	OPR$M_USER3	= 1^19 - 1^18; 
 MACRO		OPR$V_USER4	= 0,19,1,0%;  
 LITERAL	OPR$M_USER4	= 1^20 - 1^19; 
 MACRO		OPR$V_USER5	= 0,20,1,0%;  
 LITERAL	OPR$M_USER5	= 1^21 - 1^20; 
 MACRO		OPR$V_USER6	= 0,21,1,0%;  
 LITERAL	OPR$M_USER6	= 1^22 - 1^21; 
 MACRO		OPR$V_USER7	= 0,22,1,0%;  
 LITERAL	OPR$M_USER7	= 1^23 - 1^22; 
 MACRO		OPR$V_USER8	= 0,23,1,0%;  
 LITERAL	OPR$M_USER8	= 1^24 - 1^23; 
 MACRO		OPR$V_USER9	= 0,24,1,0%;  
 LITERAL	OPR$M_USER9	= 1^25 - 1^24; 
 MACRO		OPR$V_USER10	= 0,25,1,0%;  
 LITERAL	OPR$M_USER10	= 1^26 - 1^25; 
 MACRO		OPR$V_USER11	= 0,26,1,0%;  
 LITERAL	OPR$M_USER11	= 1^27 - 1^26; 
 MACRO		OPR$V_USER12	= 0,27,1,0%;  
 LITERAL	OPR$M_USER12	= 1^28 - 1^27; 
 			

  
 !+ 
 ! PRINTER/TERMINAL CARRIAGE CONTROL SPECIFIERS 
 !-- 
 !...$PCCDEF	
 MACRO		PCC$W_FORTRAN	= 0,0,16,0%; 		! FORTRAN FIELD 
 MACRO		PCC$B_PREFIX	= 2,0,8,0%; 		! PREFIX FIELD 
 MACRO		PCC$B_POSTFIX	= 3,0,8,0%; 		! POSTFIX FIELD 
 			 
 MACRO		PCC$V_CHAR	= 3,0,5,0%; 		! CHARACTER FIELD 
 LITERAL	PCC$M_CHAR	= 1^5 - 1^0; 
 				 
 MACRO		PCC$V_EIGHTBIT	= 3,6,1,0%; 		! EIGHTBIT CHARACTER SET 
 LITERAL	PCC$M_EIGHTBIT	= 1^7 - 1^6; 
 MACRO		PCC$V_SINGLE	= 3,7,1,0%; 		! SINGLE CHARACTER 
 LITERAL	PCC$M_SINGLE	= 1^8 - 1^7; 
 			
 			 
 MACRO		PCC$V_LINECNT	= 3,0,7,0%; 		! LINE COUNT FOR NEWLINES 
 LITERAL	PCC$M_LINECNT	= 1^7 - 1^0; 
 			
 LITERAL	
 $EQULST (PCC$_,GBL,0,1 				! FORTRAN CONSTANTS 
 	,(FTN_SINGLE,32) 			! SINGLE SPACE 
 	,(FTN_DOUBLE,48) 			! DOUBLE SPACE 
 	,(FTN_PAGE,49) 			! PAGE SPACE 
 	,(FTN_OVRPRT,43) 			! OVER PRINT 
 	,(FTN_PROMPT,36) 			! PROMPT 
 	); 

  
 !+ 
 ! PROCESS QUOTA LIST CODES 
 !- 
 !...$PQLDEF			! PROCESS QUOTA LIST CODE DEFINITIONS 
 LITERAL	
 $EQULST (PQL$_,GBL,0,1  
 	,(LISTEND,) 					!LIST END CODE (MUST BE FIRST) 
 	,(ASTLM,) 					!AST LIMIT 
 	,(BIOLM,) 					!BUFFERED I/O LIMIT 
 	,(BYTLM,) 					!BYTE LIMIT FOR BUFFERED I/O 
 	,(CPULM,) 					!CPU TIME LIMIT 
 	,(DIOLM,) 					!DIRECT I/O LIMIT	 
 	,(FILLM,) 					!OPEN FILE LIMIT 
 	,(PGFLQUOTA,) 				!PAGING FILE QUOTA 
 	,(PRCLM,) 					!SUB-PROCESS LIMIT 
 	,(TQELM,) 					!TIMER QUEUE ENTRY LIMIT 
 	,(WSQUOTA,) 					!WORKING SET QUOTA 
 	,(WSDEFAULT,) 				!WORKING SET DEFAULT 
 	,(LENGTH,) 					!NUMBER OF QUOTAS (MUST BE LAST) 
 	); 

  
 !+ 
 ! PRIVILEGE BIT DEFINITIONS 
 !- 
  
 !...$PRVDEF	
  
 			 
  ! ***** THE FOLLOWING TWO BITS MUST BE ADJACENT 
 MACRO		PRV$V_CMKRNL	= 0,0,1,0%; 		! MAY CHANGE MODE TO KERNEL 
 MACRO		PRV$V_CMEXEC	= 0,1,1,0%;  		! MAY CHANGE MODE TO EXEC 
 ! ***** THE PRECEEDING TWO BITS MUST BE ADJACENT 
 ! ***** THE FOLLOWING TWO BITS MUST BE ADJACENT 
 MACRO		PRV$V_SYSNAM	= 0,2,1,0%;  		! MAY INSERT IN SYSTEM LOGICAL NAME TABLE 
 MACRO		PRV$V_GRPNAM	= 0,3,1,0%;  		! MAY INSERT IN GROUP LOGICAL NAME TABLE 
 ! ***** THE PRECEEDING TWO BITS MUST BE ADJACENT 
 MACRO		PRV$V_ALLSPOOL	= 0,4,1,0%; 	!MAY ALLOCATE SPOOLED DEVICE 
 MACRO		PRV$V_DETACH	= 0,5,1,0%;  		! MAY CREATE DETACHED PROCESSES 
 MACRO		PRV$V_DIAGNOSE	= 0,6,1,0%; 	! MAY DIAGNOSE DEVICES 
 MACRO		PRV$V_LOG_IO	= 0,7,1,0%; 		! MAY DO LOGICAL I/O 
 MACRO		PRV$V_GROUP	= 0,8,1,0%; 		! MAY AFFECT OTHER PROCESSES IN SAME GROUP 
 MACRO		PRV$V_NOACNT	= 0,9,1,0%;  		! MAY SUPPRESS ACCOUNTING MESSAGE 
 MACRO		PRV$V_PRMCEB	= 0,10,1,0%;  		! MAY CREATE PERMANENT COMMON EVENT CLUSTERS 
 MACRO		PRV$V_PRMMBX	= 0,11,1,0%;  		! MAY CREATE PERMANENT MAILBOX 
 MACRO		PRV$V_PSWAPM	= 0,12,1,0%;  		! MAY CHANGE PROCESS SWAP MODE 
 MACRO		PRV$V_SETPRI	= 0,13,1,0%;  		! MAY SET ANY PRIORITY VALUE 
 MACRO		PRV$V_SETPRV	= 0,14,1,0%;  		! MAY SET ANY PRIVILEGE BITS 
 MACRO		PRV$V_TMPMBX	= 0,15,1,0%;  		! MAY CREATE TEMPORARY MAILBOX 
 MACRO		PRV$V_WORLD	= 0,16,1,0%; 		! MAY AFFECT OTHER PROCESSES IN THE WORLD 
 MACRO		PRV$V_MOUNT	= 0,17,1,0%; 		! MAY EXECUTE MOUNT ACP FUNCTIONS 
 MACRO		PRV$V_OPER	= 0,18,1,0%; 		! OPERATOR PRIVILEGE 
 MACRO		PRV$V_EXQUOTA	= 0,19,1,0%; 		! MAY EXCEED QUOTAS 
 MACRO		PRV$V_NETMBX	= 0,20,1,0%; 		! MAY CREATE NETWORK DEVICE 
 MACRO		PRV$V_VOLPRO	= 0,21,1,0%; 		! MAY OVERRIDE VOLUME PROTECTION 
 MACRO		PRV$V_PHY_IO	= 0,22,1,0%; 		! MAY DO PHYSICAL I/O 
 MACRO		PRV$V_BUGCHK	= 0,23,1,0%; 		! MAY MAKE BUG CHECK ERROR LOG ENTRIES 
 MACRO		PRV$V_PRMGBL	= 0,24,1,0%; 		! MAY CREATE PERMANENT GLOBAL SECTIONS 
 MACRO		PRV$V_SYSGBL	= 0,25,1,0%; 		! MAY CREATE SYSTEM WIDE GLOBAL SECTIONS 
 			

  
 ! 
 ! MACROS TO DEFINE SYSTEM SERVICE FAILURE AND STATUS CODES. 
 ! 
 ! 
 !	$STRUCT	SS 
 ! 
 ! THIS STRUCTURE IS NOW CONTAINED IN 'SSMSG.MDL' 
  
  
 !+ 
 ! Define 32-bit VAX-11 error code longword fields 
 ! Changed to agree with Handbook - TNH 26-OCT-77 - CHANGE M 1 to P 1 
 ! Changed to agree with new status value  W. H. Brown 18-NOV-1977 
 !- 
  
 !...$STSDEF	
  
 							! Mark position for defining sub-fields below 
 							! Define top level fields 
  
 MACRO		STS$V_SEVERITY	= 0,0,3,0%; 			! severity code 
 LITERAL	STS$M_SEVERITY	= 1^3 - 1^0; 
 MACRO		STS$V_COND_ID	= 0,3,25,0%; 			! condition id 
 LITERAL	STS$M_COND_ID	= 1^28 - 1^3; 
 MACRO		STS$V_CONTROL	= 0,28,4,0%; 			! control bits 
 LITERAL	STS$M_CONTROL	= 1^32 - 1^28; 
 						! End of top level fields 
  
 							! Position back to beg of structure 
 						! Define sub-fields of condition id 
 MACRO		STS$V_SUCCESS	= 0,0,1,0%; 			! Success 
 LITERAL	STS$M_SUCCESS	= 1^1 - 1^0; 
 								! skip severity field 
 MACRO		STS$V_MSG_NO	= 0,3,13,0%; 			! Message number 
 LITERAL	STS$M_MSG_NO	= 1^16 - 1^3; 
 						! End of message number field 
  
 						! Postion back to beginning of structure 
 						! Define sub-fields of message number and fac. no. 
 							! Skip severity field 
 MACRO		STS$V_CODE	= 0,3,12,0%; 			! code 
 LITERAL	STS$M_CODE	= 1^15 - 1^3; 
 MACRO		STS$V_FAC_SP	= 0,15,1,0%; 		! 1 if facility specific 
 LITERAL	STS$M_FAC_SP	= 1^16 - 1^15; 
 				 
 MACRO		STS$V_CUST_DEF	= 0,27,1,0%; 		! 1 if sub-system is customer (or CSS) defined 
 LITERAL	STS$M_CUST_DEF	= 1^28 - 1^27; 
 MACRO		STS$V_INHIB_MSG	= 0,28,1,0%; 		! 1 if message should not be printed 
 LITERAL	STS$M_INHIB_MSG	= 1^29 - 1^28; 
 							! reserved control bits 
 					! End message number sub-fields 
  
 						! Postion back to beg of structure 
 						! 
 							! Skip message nubmer field 
 MACRO		STS$V_FAC_NO	= 0,16,12,0%; 		! Facility is 12 bits 
 LITERAL	STS$M_FAC_NO	= 1^28 - 1^16; 
 							! Control bits 
 			
  
 !+ 
 ! Define severity codes 
 !- 
  
 LITERAL	STS$K_WARNING	= 0; 			! WARNING 
 LITERAL	STS$K_SUCCESS	= 1; 			! SUCCESSFUL COMPLETION 
 LITERAL	STS$K_ERROR	= 2; 				! ERROR 
 LITERAL	STS$K_INFO	= 3; 				! INFORMATION 
 LITERAL	STS$K_SEVERE	= 4; 			! SEVERE ERROR 
  

  
 ! 
 ! DEFINE TERMINAL SPECIAL SYMBOLS 
 ! 
 !...$TTDEF	
 LITERAL	
 $EQULST (TT$C_,GBL,1,1  
 	,(BAUD_50,) 	
 	,(BAUD_75,) 	
 	,(BAUD_110,) 	
 	,(BAUD_134,) 	
 	,(BAUD_150,) 	
 	,(BAUD_300,) 	
 	,(BAUD_600,) 	
 	,(BAUD_1200,) 	
 	,(BAUD_1800,) 	
 	,(BAUD_2000,) 	
 	,(BAUD_2400,) 	
 	,(BAUD_3600,) 	
 	,(BAUD_4800,) 	
 	,(BAUD_7200,) 	
 	,(BAUD_9600,) 	
 	); 
 LITERAL	
 $EQULST (TT$_,GBL,0,1  
 	,(UNKNOWN,0) 	 
 	,(VT05,1) 	 
 	,(LAX,32) 	 
 	,(LA36,32) 	 
 	,(VT5X,64) 	 
 	,(VT52,64) 	 
 	,(VT55,65) 	 
 	); 
 			 
 MACRO		TT$V_PASSALL	= 0,0,1,0%;  
 LITERAL	TT$M_PASSALL	= 1^1 - 1^0; 
 MACRO		TT$V_NOECHO	= 0,1,1,0%;  
 LITERAL	TT$M_NOECHO	= 1^2 - 1^1; 
 MACRO		TT$V_NOTYPEAHD	= 0,2,1,0%;  
 LITERAL	TT$M_NOTYPEAHD	= 1^3 - 1^2; 
 MACRO		TT$V_ESCAPE	= 0,3,1,0%;  
 LITERAL	TT$M_ESCAPE	= 1^4 - 1^3; 
 MACRO		TT$V_HOSTSYNC	= 0,4,1,0%;  
 LITERAL	TT$M_HOSTSYNC	= 1^5 - 1^4; 
 MACRO		TT$V_TTSYNC	= 0,5,1,0%;  
 LITERAL	TT$M_TTSYNC	= 1^6 - 1^5; 
 MACRO		TT$V_SCRIPT	= 0,6,1,0%;  
 LITERAL	TT$M_SCRIPT	= 1^7 - 1^6; 
 MACRO		TT$V_LOWER	= 0,7,1,0%;  
 LITERAL	TT$M_LOWER	= 1^8 - 1^7; 
 MACRO		TT$V_MECHTAB	= 0,8,1,0%;  
 LITERAL	TT$M_MECHTAB	= 1^9 - 1^8; 
 MACRO		TT$V_WRAP	= 0,9,1,0%;  
 LITERAL	TT$M_WRAP	= 1^10 - 1^9; 
 MACRO		TT$V_CRFILL	= 0,10,1,0%;  
 LITERAL	TT$M_CRFILL	= 1^11 - 1^10; 
 MACRO		TT$V_LFFILL	= 0,11,1,0%;  
 LITERAL	TT$M_LFFILL	= 1^12 - 1^11; 
 MACRO		TT$V_SCOPE	= 0,12,1,0%;  
 LITERAL	TT$M_SCOPE	= 1^13 - 1^12; 
 MACRO		TT$V_REMOTE	= 0,13,1,0%;  
 LITERAL	TT$M_REMOTE	= 1^14 - 1^13; 
 MACRO		TT$V_HOLDSCREEN	= 0,14,1,0%;  
 LITERAL	TT$M_HOLDSCREEN	= 1^15 - 1^14; 
 MACRO		TT$V_EIGHTBIT	= 0,15,1,0%;  
 LITERAL	TT$M_EIGHTBIT	= 1^16 - 1^15; 
 MACRO		TT$V_MBXDSABL	= 0,16,1,0%;  
 LITERAL	TT$M_MBXDSABL	= 1^17 - 1^16; 
 MACRO		TT$V_NOBRDCST	= 0,17,1,0%;  
 LITERAL	TT$M_NOBRDCST	= 1^18 - 1^17; 
 MACRO		TT$V_READSYNC	= 0,18,1,0%;  
 LITERAL	TT$M_READSYNC	= 1^19 - 1^18; 
 				 
 MACRO		TT$V_PAGE	= 0,25,8,0%;  
 LITERAL	TT$M_PAGE	= 1^33 - 1^25; 
 			
 			 
 				 
 MACRO		TT$V_ALTRPAR	= 0,5,1,0%;  
 LITERAL	TT$M_ALTRPAR	= 1^6 - 1^5; 
 MACRO		TT$V_PARITY	= 0,6,1,0%;  
 LITERAL	TT$M_PARITY	= 1^7 - 1^6; 
 MACRO		TT$V_ODD	= 0,7,1,0%;  
 LITERAL	TT$M_ODD	= 1^8 - 1^7; 
 			

  
 !+ 
 ! PROTECTION FIELD DEFINITIONS 
 !- 
  
 !...$PRTDEF	
  
 LITERAL	
 $EQULST (PRT$C_,GBL,0,1  
 	,(NA,  (%B'0000')) 		! NO ACCESS 
 	,(KR,  (%B'0011')) 		! KERNEL READ ONLY 
 	,(KW,  (%B'0010')) 		! KERNEL WRITE 
 	,(ER,  (%B'0111')) 		! EXEC READ ONLY 
 	,(EW,  (%B'0101')) 		! EXEC WRITE 
 	,(SR,  (%B'1011')) 		! SUPER READ ONLY 
 	,(SW,  (%B'1000')) 		! SUPER WRITE 
 	,(UR,  (%B'1111')) 		! USER READ ONLY 
 	,(UW,  (%B'0100')) 		! USER WRITE 
  
 	,(ERKW,(%B'0110')) 		! EXEC READ KERNEL WRITE 
 	,(SRKW,(%B'1010')) 		! SUPER READ KERNEL WRITE 
 	,(SREW,(%B'1001')) 		! SUPER READ EXEC WRITE 
 	,(URKW,(%B'1110')) 		! USER READ KERNEL WRITE 
 	,(UREW,(%B'1101')) 		! USER READ EXEC WRITE 
 	,(URSW,(%B'1100')) 		! USER READ SUPER WRITE 
 	,(RESERVED,1) 		! RESERVED 
 	); 
  

  
  
 !+ 
 !  PROCESSOR REGISTER DEFINITIONS 
 !- 
  
 !...$PRDEF	
  
 LITERAL	
 $EQULST (PR$_,GBL,0,1  
 	,(KSP,0) 					!KERNEL STACK POINTER 
 	,(ESP,1) 					!EXECUTIVE STACK POINTER 
 	,(SSP,2) 					!SUPERVISOR STACK POINTER 
 	,(USP,3) 					!USER STACK POINTER 
 	,(ISP,4) 					!INTERRUPT STACK POINTER 
 	,(P0BR,8) 					!P0 BASE REGISTER 
 	,(P0LR,9) 					!P0 LIMIT REGISTER 
 	,(P1BR,10) 					!P1 BASE REGISTER 
 	,(P1LR,11) 					!P1 LIMIT REGISTER 
 	,(SBR,12) 					!SYSTEM BASE REGISTER 
 	,(SLR,13) 					!SYSTEM LIMIT REGISTER 
 	,(PCBB,16) 					!PROCESS CONTROL BLOCK BASE 
 	,(SCBB,17) 					!SYSTEM CONTROL BLOCK BASE 
 	,(IPL,18) 					!INTERRUPT PRIORITY LEVEL REGISTER 
 	,(ASTLVL,19) 				!AST LEVEL REGISTER 
 	,(SIRR,20) 					!SOFTWARE INTERRUPT REQUEST REGISTER 
 	,(SISR,21) 					!SOFTWARE INTERRUPT SUMMARY REGISTER 
 	,(MAPEN,56) 				!MAPPING ENABLE REGISTER 
 	,(TBIA,57) 					!TRANSLATION BUFFER INVALIDATE ALL 
 	,(TBIS,58) 					!TRANSLATION BUFFER INVALIDATE SINGLE 
 	,(ICCS,+%X'18') 				!INTERVAL CLOCK CONTROL STATUS REGISTER 
 	,(NICR,+%X'19') 				!INTERVAL CLOCK NEXT INTERVAL REGISTER 
 	,(ICR,+%X'1A') 				!INTERVAL CLOCK INTERVAL COUNT REGISTER 
 	,(TODR,+%X'1B') 				!TIME OF DAY REGISTER 
 	,(RXCS,+%X'20') 				!CONSOLE RECEIVER CONTROL STATUS REGISTER 
 	,(RXDB,+%X'21') 				!CONSOLE RECEIVER DATA BUFFER REGISTER 
 	,(TXCS,+%X'22') 				!CONSOLE TRANSMIT CONTROL STATUS REGISTER 
 	,(TXDB,+%X'23') 				!CONSOLE TRANSMIT DATA BUFFER REGISTER 
 	,(ACCS,+%X'28') 				!ACCELERATOR CONTROL STATUS REGISTER 
 	,(ACCR,+%X'29') 				!ACCELERATOR RESERVED 
 	,(WCSA,+%X'2C') 				!WCS ADDRESS REGISTER 
 	,(WCSD,+%X'2D') 				!WCS DATA REGISTER 
 	,(SBIFS,+%X'30') 				!SBI FAULT STATUS REGISTER 
 	,(SBIS,+%X'31') 				!SBI SILO REGISTER 
 	,(SBISC,+%X'32') 				!SBI COMPARATOR REGISTER 
 	,(SBIMT,+%X'33') 				!SBI MAINTENANCE REGISTER 
 	,(SBIER,+%X'34') 				!SBI ERROR REGISTER 
 	,(SBITA,+%X'35') 				!SBI TIMEOUT ADDRESS REGISTER 
 	,(SBIQC,+%X'36') 				!SBI QUADWORD CLEAR REGISTER 
 	,(PME,+%X'3D') 				!PERFORMANCE MONITOR ENABLE 
 	,(SID,+%X'3E') 				!SYSTEM IDENTIFICATION REGISTER 
 	); 

  
  
 !+ 
 ! PROCESSOR STATUS LONGWORD MASK AND FIELD DEFINITIONS 
 !- 
  
 !...$PSLDEF	
  
 						! PSL VIELD DEFINITIONS 
 				 
 MACRO		PSL$V_TBIT	= 0,4,1,0%; 		! TBIT ENABLE 
 LITERAL	PSL$M_TBIT	= 1^5 - 1^4; 
 MACRO		PSL$V_IV	= 0,5,1,0%; 			! INTEGER OVERFLOW 
 LITERAL	PSL$M_IV	= 1^6 - 1^5; 
 MACRO		PSL$V_FU	= 0,6,1,0%; 			! FLOATING UNDEFINED 
 LITERAL	PSL$M_FU	= 1^7 - 1^6; 
 MACRO		PSL$V_DV	= 0,7,1,0%; 			! DIVIDE BY ZERO 
 LITERAL	PSL$M_DV	= 1^8 - 1^7; 
 							! 
 MACRO		PSL$V_IPL	= 0,16,5,0%; 		! INTERRUPT PRIORITY LEVEL 
 LITERAL	PSL$M_IPL	= 1^21 - 1^16; 
 							! 
 MACRO		PSL$V_PRVMOD	= 0,22,2,0%; 		! PREVIOUS PROCESSOR MODE 
 LITERAL	PSL$M_PRVMOD	= 1^24 - 1^22; 
 MACRO		PSL$V_CURMOD	= 0,24,2,0%; 		! CURRENT PROCESSOR MODE 
 LITERAL	PSL$M_CURMOD	= 1^26 - 1^24; 
 MACRO		PSL$V_IS	= 0,26,1,0%; 			! INTERRUPT STACK BIT 
 LITERAL	PSL$M_IS	= 1^27 - 1^26; 
 MACRO		PSL$V_FPD	= 0,27,1,0%; 			! FIRST PART DONE 
 LITERAL	PSL$M_FPD	= 1^28 - 1^27; 
 							! MUST BE ZERO 
 MACRO		PSL$V_TP	= 0,30,1,0%; 			! TRACE TRAP PENDING 
 LITERAL	PSL$M_TP	= 1^31 - 1^30; 
 MACRO		PSL$V_CM	= 0,31,1,0%; 			! COMPATIBILITY MODE BIT AND MASK 
 LITERAL	PSL$M_CM	= 1^32 - 1^31; 
 						! END OF PSL VIELD DEFINITIONS 
 ! 
 ! MODE SYMBOL DEFINITIONS 
 ! 
 LITERAL	
 $EQULST (PSL$C_,GBL,0,1  
 	,(KERNEL,) 					! KERNEL MODE 
 	,(EXEC,) 					! EXEC MODE 
 	,(SUPER,) 					! SUPERVISOR MODE 
 	,(USER,) 					! USER MODE 
 	); 
  
 LITERAL	
 $EQULST (PSL$M_,GBL,0,1  
 	,(SAFBITS,( NOT (PSL$M_TP OR PSL$M_CM OR PSL$M_FPD)^(-16))) 	 
 	); 
  

  
  
 !+ 
 ! PROCESS OR GLOBAL SECTION DEFINITIONS 
 !- 
 !...$SECDEF	
  
 ! 
 ! ***** L_VBN, L_WINDOW, AND B_PFC MUST BE THE SAME OFFSET VALUES AS THE 
 ! ***** EQUIVALENTLY NAMED OFFSETS IN $PFLDEF 
 ! 
 MACRO		SEC$L_GSD	= 0,0,32,0%; 			!GLOBAL SECTION DESCRIPTOR ADDRESS 
 MACRO		SEC$L_CCB	= 0,0,32,0%; 			!CHANNEL CONTROL BLOCK ADDRESS IF PROCESS SECTION 
 MACRO		SEC$W_SECXFL	= 4,0,16,0%; 		!SECTION INDEX FORWARD LINK 
 MACRO		SEC$W_SECXBL	= 6,0,16,0%; 		!SECTION INDEX BACKWARD LINK 
 MACRO		SEC$L_VPXPFC	= 8,0,32,0%; 		!START VIRT PAGE INDEX & PFC 
 						! 
 MACRO		SEC$V_VPX	= 8,0,22,0%; 			! STARTING VIRTUAL PAGE INDEX 
 							! UNUSED 
 MACRO		SEC$V_PFC	= 8,24,8,0%; 			! PAGE FAULT CLUSTER 
 			
 MACRO		SEC$B_PFC	= 11,0,8,0%; 			!PAGE FAULT CLUSTER 
 MACRO		SEC$L_WINDOW	= 12,0,32,0%; 		!WINDOW CONTROL BLOCK 
 MACRO		SEC$L_VBN	= 16,0,32,0%; 			!BASE VIRTUAL BLOCK NUMBER 
 MACRO		SEC$W_FLAGS	= 20,0,16,0%; 			!VARIOUS CONTROL FLAGS 
 			 
 MACRO		SEC$V_GBL	= 20,0,1,0%; 			! GLOBAL SECTION 
 LITERAL	SEC$M_GBL	= 1^1 - 1^0; 
 MACRO		SEC$V_CRF	= 20,1,1,0%; 			! COPY ON REFERENCE 
 LITERAL	SEC$M_CRF	= 1^2 - 1^1; 
 MACRO		SEC$V_DZRO	= 20,2,1,0%; 			! DEMAND ZERO 
 LITERAL	SEC$M_DZRO	= 1^3 - 1^2; 
 MACRO		SEC$V_WRT	= 20,3,1,0%; 			! WRITABLE 
 LITERAL	SEC$M_WRT	= 1^4 - 1^3; 
 							! SPARE 
 MACRO		SEC$V_AMOD	= 20,8,2,0%; 			! ACCESS MODE OF SECTION 
 LITERAL	SEC$M_AMOD	= 1^10 - 1^8; 
 							! SPARE 
 MACRO		SEC$V_PERM	= 20,14,1,0%; 			! PERMANENT SECTION 
 LITERAL	SEC$M_PERM	= 1^15 - 1^14; 
 MACRO		SEC$V_SYSGBL	= 20,15,1,0%; 		! 1 = SYSTEM GLOBAL, 0 = GROUP GLOBAL 
 LITERAL	SEC$M_SYSGBL	= 1^16 - 1^15; 
 			
 MACRO		SEC$B_AMOD	= 21,0,8,0%; 		!ACCESS MODE OF SECTION 
 MACRO		SEC$L_REFCNT	= 24,0,32,0%; 		!COUNT OF PTE'S REFERENCING THIS SECTION 
 MACRO		SEC$L_PAGCNT	= 28,0,32,0%; 		!NO. OF PAGES IN THE SECTION 
 ! 
 ! ***** NOTE THAT NUMBER OF LONG WORDS MUST BE EVEN 
 ! 
 LITERAL	SEC$C_LENGTH	= 32; 
 LITERAL	SEC$K_LENGTH	= 32; 				!SIZE OF PSTE/GSTE 
  
 !+ 
 ! MATCH CONTROL VIELD VALUES 
 !- 
  
 LITERAL	
 $EQULST (SEC$K_,GBL,0,1 			! BASE OF ZERO , INCR 1 
 	,(MATALL,) 					! MATCH ALWAYS, USE GLOBAL SECTION 
 	,(MATEQU,) 					! MATCH IF ISD$L_IDENT EQU GBL ID 
 	,(MATLEQ,) 					! MATCH IF ISD$L_IDENT LEQ GBL ID 
 	); 
  
  

  
 ! 
 ! DEFINE SYMBIONT MANAGER REQUEST CODES 
 ! 
  
 !...$SMRDEF	
  
 LITERAL	
 $EQULST (SMR$K_,GBL,0,1 		! SYMBIONT MANAGER REQUEST CODES 
 	,(INITIAL,) 				! INITIALIZE A QUEUE 
 	,(DELETE,) 				! DELETE THE QUEUE 
 	,(START,) 				! ACTIVATE OR RESUME PRINTING 
 	,(PAUSE,) 				! SUSPEND PRINTING FOR A WHILE 
 	,(MERGE,) 				! MOVE FILES FORM ONE QUEUE INTO ANOTHER 
 	,(REDIRECT,) 			! ASSIGNMENT OF ONE QUEUE TO ANOTHER 
 	,(JUSTIFY,) 				! JUSTIFY PRINT FORMS(IE: ISSUE FF) 
 	,(STOP,) 				! DISABLE FURTHER DE-QUEING 
 	,(ENTER,) 				! ADD A FILE TO A QUEUE 
 	,(CREJOB,) 				! CREATE A PRINT JOB 
 	,(ADDFIL,) 				! ADD A FILE TO EXISTING JOB 
 	,(CLSJOB,) 				! CLOSE OPEN JOB 
 	,(RMVJOB,) 				! REMOVE JOB FROM QUEUE 
 	,(ALTER,) 				! CHANGE A FILES CHARACTERISTICS 
 	,(ABORT,) 				! ABORT CURRENT JOB, START NEXT 
 	,(RELEASE,) 				! RELEASE JOB FROM HOLD LIST 
 	,(DETINIT,) 				! DETACHED JOB HAS INITIATED 
 	,(SYNCJOB,) 				! SYNCRONIZE WITH A BATCH JOB 
 	); 
 ! 
 ! ASSIGN SYMBIONT MANAGER PRINT JOB/RECORD OPTION CODES 
 ! 
 ! 
 LITERAL	
 $EQULST (SMO$K_,GBL,1,1 		! JOB FILE OPTIONS 
 	,(DELETE,) 				! DELETE THE FILE AFTER PRINTING 
 	,(BRSTPAG,) 				! CREATE A BURST PAGE 
 	,(NOBRSTPAG,) 			! INHIBIT BURST PAGE 
 	,(FLAGPAG,) 				! PRINT A FLAG PAGE 
 	,(NOFLAGPAG,) 			! INHIBIT A FLAG PAGE 
 	,(PAGHDR,) 				! PRINT FILENAME AS PAGE HEADER 
 	,(DOUBLE,) 				! DOUBLE SPACE THE LISTING 
 	,(NOFEED,) 				! INHIBIT FORM FEED GENERATION 
 	,(PAGCNT,) 				! SPECIFY PAGE COUNT TO PRINT 
 	,(COPIES,) 				! NUMBER OF COPIES TO PRINT 
 	); 
  
 LITERAL	
 $EQULST (SMO$K_,GBL,32,1 		! OPTIONS FOR CREATE JOB 
 	,(RLSTIM,) 				! TIME TO HOLD UNTIL QUEUEING 
 	,(HOLD,) 				! HOLD THE JOB 
 	,(JOBPRI,) 				! SPECIFY PRINT JOB/DETACHED JOB PRIOITY 
 	,(JOBCOPY,) 				! NUMBER OF COPIES OF ENTIRE JOB 
 	,(FORMTYPE,) 			! FORM TYPE TO USED WHEN PRINTED 
 	,(LOWER,) 				! UPPER/LOWER CASE PRINTER ONLY 
 	,(PARAMS,) 				! SUPPLY JOB PARAMETERS 
 	,(JOBNAME,) 				! SUPPLY A NAME TO THE JOB 
 	,(NOLOWER,) 				! CLEAR LOWER CASE REQUIRED 
 	); 
  
 LITERAL	
 $EQULST (SMO$K_,GBL,64,1 		! OPTIONS FOR INIT OR START A QUEUE 
 	,(CURFORM,) 				! CURRENT FORMS MOUNTED ON DEVICE 
 	,(GENPRT,) 				! ALLOW GENERIC PRINTING 
 	,(NOGENPRT,) 			! DISALLOW GENERIC PRINTING 
 	,(DETJOB,) 				! QUEUE IS FOR DETACHED JOB QUEUING 
 	,(GENDEV,) 				! QUEUE IS GENERIC DEVICE QUEUE 
 	,(NOGENDEV,) 			! NOT A GENERIC DEVICE 
 	,(DEFBRST,) 				! QUEUE HAS BURST PAGE BY DEFAULT 
 	,(NODEFBRST,) 			! NO DEFAULT BURST PAGE 
 	,(DEFFLAG,) 				! QUEUE HAS FLAG PAGE BY DEFAULT 
 	,(NODEFFLAG,) 			! NO DEFAULT FLAG 
 	,(TRMDEV,) 				! DEVICE IS A TERMINAL 
 	,(NOTRMDEV,) 			! DEVICE IS NOT A TERMINAL 
 	,(JOBLIM,) 				! JOB LIMIT FOR BATCH JOBS 
 	,(INIPRI,) 				! JOB INITIAL PRIORITY 
 	,(DISWAP,) 				! DISABLE SWAPING 
 	); 
  
 LITERAL	
 $EQULST (SMO$K_,GBL,96,1 		! OPTIONS FOR RESTART 
 	,(NEXTJOB,) 				! RESTART AT END BEGINNING OF NEXT JOB 
 	,(TOPOFILE,) 			! RESTART JOB AT TOP-OF-FILE 
 	,(SPCCNT,) 				! SPECIFY PAGES TO SPACE OVER 
 	); 
  
 LITERAL	
 $EQULST (SMO$K_,GBL,112,1 		! OPTIONS FOR ABORT 
 	,(REQUEUE,) 				! REQUEUE THE FILE 
 	); 

 ! 
 ! DEFINE SYMBIONT MANAGER QUEUE DATA STRUCTURES 
 ! 
 ! 
 ! 
 ! DEFINE FORMAT FOR RECORDS IN THE QUEUE 
 ! 
 !	EACH RECORD IN THE QUEUE IS 64 BYTES LONG 
 !	THERE ARE 3 TYPES OF RECORDS 
 ! 
 !		1. JOB HEADER FOR BATCH OR PRINT JOBS 
 !		2. PRINT FILE RECORD 
 !		3. BATCH JOB RECORD 
 !	THE LAST 2 HAVE THE SAME LAYOUT 
 ! 
 !...$SYMDEF			! THE RECORD ENVELOP STRUCTURE 
  
 LITERAL	SYM$C_RECSIZE	= 64; 
 LITERAL	SYM$K_RECSIZE	= 64; 				! SIZE OF THE STRUCTURE 
  

  
 ! 
 ! DEFINE FORMAT FOR SYMBIONT MANAGER JOB HEADER RECORD 
 ! 
 !...$SJHDEF	
  
 MACRO		SJH$L_RECLINK	= 0,0,32,0%; 			! LINK TO NEXT RECORD 
 MACRO		SJH$W_JOBSEQ	= 4,0,16,0%; 		! JOB SEQUENCE NUMBER 
 MACRO		SJH$W_QINDEX	= 6,0,16,0%; 		! INDEX TO DEVICE QUEUE FOR THIS JOB 
 MACRO		SJH$L_NEXTJOB	= 8,0,32,0%; 			! LINK TO NEXT PRINT JOB 
 MACRO		SJH$B_FLAGS	= 12,0,8,0%; 			! FLAGS 
 							! RECORD FLAGS 
 MACRO		SJH$V_HOLD	= 12,0,1,0%; 			! JOB IS ON HOLD 
 LITERAL	SJH$M_HOLD	= 1^1 - 1^0; 
 MACRO		SJH$V_LOWER	= 12,1,1,0%; 			! JOB REQUIRES LOWER CASE PRINTER 
 LITERAL	SJH$M_LOWER	= 1^2 - 1^1; 
 MACRO		SJH$V_JOBABORT	= 12,2,1,0%; 		! JOB WAS ABORTED 
 LITERAL	SJH$M_JOBABORT	= 1^3 - 1^2; 
 			
 						! MARK POINT OF OVERLAPPED DEFINITION 
 MACRO		SJH$B_FORMS	= 13,0,8,0%; 			! FORMS TYPE FOR JOB 
 MACRO		SJH$B_COPYCNT	= 14,0,8,0%; 		! NUMBER OF COPIES OF ENTIRE JOB 
 						! POINT BACK FOR BATCH QUEUE SLOT 
 MACRO		SJH$W_MBCHAN	= 13,0,16,0%; 		! RESPONCE MAILBOX CHANNEL 
 MACRO		SJH$B_PRTPRI	= 15,0,8,0%; 		! PRINT PRIORITY FOR JOB 
 MACRO		SJH$L_PROCID	= 16,0,32,0%; 			! PROCESS ID OF OWNER 
 ! ** ADJACENCY OF THE NEXT 2 ITEMS ASSUMED 
 MACRO		SJH$L_UIC	= 20,0,32,0%; 			! UIC OF OWNER OF JOB 
 MACRO		SJH$T_USERNAM	= 24,0,0,0%; 		! NAME OF OWNER 
 LITERAL	SJH$S_USERNAM	= 12; 
 ! ** ADJACENCY OF THE LAST 2 ITEMS ASSUMED 
 MACRO		SJH$Q_ACNTNAM	= 36,0,0,0%; 		! ACCOUNT TO GET CHARGED 
 LITERAL	SJH$S_ACNTNAM	= 8; 
 MACRO		SJH$Q_TIME	= 44,0,0,0%; 			! TIME JOB WAS CREATED 
 LITERAL	SJH$S_TIME	= 8; 
 MACRO		SJH$Q_JOBNAME	= 52,0,0,0%; 		! JOB NAME 
 LITERAL	SJH$S_JOBNAME	= 8; 
 MACRO		SJH$L_PARMBLK	= 60,0,32,0%; 			! PARAMETER BLOCK 
  

  
 ! 
 ! DEFINE FORMAT OF SYMBIONT MANAGER QUEUE RECORD 
 ! 
 !...$SQRDEF	
  
 MACRO		SQR$L_RECLINK	= 0,0,32,0%; 			! LINK TO NEXT RECORD 
 MACRO		SQR$W_JOBSEQ	= 4,0,16,0%; 		! JOB SEQUENCE NUMBER 
 MACRO		SQR$W_RECID	= 6,0,16,0%; 			! ID THIS A RECORD 
 ! 
 ! NOTE:	THE ORDER OF THIS RECORD CAN NOT BE CHANGED WITH OUT EFFECTING 
 !	THE SYMBIONT, AND THE SYMBIONT MANAGER MESSAGE FORMAT 
 ! 
 MACRO		SQR$T_VOLNAM	= 8,0,0,0%; 		! VOLUME NAME UPON WHICH FILE RESIDES 
 LITERAL	SQR$S_VOLNAM	= 16; 
 MACRO		SQR$W_FILNUM	= 24,0,16,0%; 		! FILE NUMBER TO PRINT/EXECUTE 
 MACRO		SQR$W_FILSEQ	= 26,0,16,0%; 		! FILE SEQUENCE NUMBER 
 MACRO		SQR$W_RELVOL	= 28,0,16,0%; 		! FILE RELATIVE VOLUME NUMBER 
 MACRO		SQR$W_DIRNUM	= 30,0,16,0%; 		! DIRECTORY FILE NUMBER 
 MACRO		SQR$W_DIRSEQ	= 32,0,16,0%; 		! DIRECTORY SEQUENCE NUMBER 
 MACRO		SQR$W_DIRVOL	= 34,0,16,0%; 		! DIRECTORY VOLUME INDEX 
 MACRO		SQR$T_FILNAM	= 36,0,0,0%; 		! 19 BYTE FILE NAME AND A COUNT BYTE 
 LITERAL	SQR$S_FILNAM	= 20; 
 MACRO		SQR$B_FLAGS	= 56,0,8,0%; 			! VARIOUS FLAGS 
 							! QUEUE RECORD FLAGS 
 MACRO		SQR$V_DELETE	= 56,0,1,0%; 			! DELETE THE FILE 
 LITERAL	SQR$M_DELETE	= 1^1 - 1^0; 
 MACRO		SQR$V_FLAGPAG	= 56,1,1,0%; 			! PRINT A FLAG PAGE 
 LITERAL	SQR$M_FLAGPAG	= 1^2 - 1^1; 
 MACRO		SQR$V_BRSTPAG	= 56,2,1,0%; 			! PRINT A BURST PAGE 
 LITERAL	SQR$M_BRSTPAG	= 1^3 - 1^2; 
 MACRO		SQR$V_DOUBLE	= 56,3,1,0%; 			! DOUBLE SPACE THE LISTING 
 LITERAL	SQR$M_DOUBLE	= 1^4 - 1^3; 
 MACRO		SQR$V_NOFEED	= 56,4,1,0%; 			! NO IMPLIED FORM FEEDS 
 LITERAL	SQR$M_NOFEED	= 1^5 - 1^4; 
 MACRO		SQR$V_PAGHDR	= 56,5,1,0%; 			! PRINT FILE NAME AS HEADER 
 LITERAL	SQR$M_PAGHDR	= 1^6 - 1^5; 
 			
 MACRO		SQR$B_COPYCNT	= 57,0,8,0%; 		! NUMBER OF COPIES TO PRINTED 
 MACRO		SQR$W_PAGCNT	= 58,0,16,0%; 		! MAXIMUM PAGES TO PRINT 
  

 ! 
 ! DEFINE SYMBIONT QUEUE HEADER RECORD FORMAT 
 ! 
 !...$SQHDEF	
  
 MACRO		SQH$L_FREEREC	= 0,0,32,0%; 			! OFFSET TO FIRST FREE RECORD 
 MACRO		SQH$B_FLAGS	= 4,0,8,0%; 			! STATUS FLAGS 
 MACRO		SQH$B_NUMQUE	= 5,0,8,0%; 		! NUMBER OF ACTIVE QUEUES 
 MACRO		SQH$B_MAXQUE	= 6,0,8,0%; 		! MAXIMUM NUMBER OF QUEUES 
 MACRO		SQH$B_SPARE	= 7,0,8,0%; 			! SPARE BYTE 
 MACRO		SQH$L_FIRSTREC	= 8,0,32,0%; 		! FIRST RECORD 
 MACRO		SQH$L_NEXTREC	= 12,0,32,0%; 			! OFFSET TO NEXT FREE RECORD 
 MACRO		SQH$L_LASTREC	= 16,0,32,0%; 			! OFFSET TO LAST RECORD IN FILE 
 MACRO		SQH$L_OPENJOB	= 20,0,32,0%; 			! LIST OF OPEN PRINT JOBS 
 MACRO		SQH$L_TIMQUE	= 24,0,32,0%; 			! LIST OF JOBS WAITING ON TIME BASES 
 MACRO		SQH$W_QUESEQ	= 28,0,16,0%; 		! QUEUE SEQUENCE NUMBER 
 MACRO		SQH$Q_QUEUE	= 32,0,0,0%; 		! 32 PRIORIT ORDER PRINT QUEUES 
 LITERAL	SQH$S_QUEUE	= 256; 
 LITERAL	SQH$C_SIZE	= 288; 
 LITERAL	SQH$K_SIZE	= 288; 				! SIZE OF THE QUEUE HEADER 
  

  
 ! 
 ! DEFINE FORMAT FOR SYMBIONT MANAGER QUEUE HEADER 
 ! 
 !...$SMQDEF	
  
 MACRO		SMQ$L_CURRENT	= 0,0,32,0%; 			! CURRENTLY PRINTING JOB 
 MACRO		SMQ$L_HOLDLST	= 4,0,32,0%; 			! QUEUE HOLDING LIST 
 MACRO		SMQ$B_FLAGS	= 8,0,8,0%; 		! QUEUE FLAG BYTE 
 							! QUEUE STATUS FLAGS 
 MACRO		SMQ$V_INUSE	= 8,0,1,0%; 			! QUEUE IS IN USE 
 LITERAL	SMQ$M_INUSE	= 1^1 - 1^0; 
 MACRO		SMQ$V_DETJOB	= 8,1,1,0%; 			! QUEUE IS FOR DETACHED JOBS,NOT PRINTER 
 LITERAL	SMQ$M_DETJOB	= 1^2 - 1^1; 
 MACRO		SMQ$V_PAUSED	= 8,2,1,0%; 			! PRINTED IS SUSPENDED 
 LITERAL	SMQ$M_PAUSED	= 1^3 - 1^2; 
 MACRO		SMQ$V_STOPPED	= 8,3,1,0%; 			! QUEUE IS STOPPED 
 LITERAL	SMQ$M_STOPPED	= 1^4 - 1^3; 
 MACRO		SMQ$V_GENDEV	= 8,4,1,0%; 			! QUEUE IS GENERIC 
 LITERAL	SMQ$M_GENDEV	= 1^5 - 1^4; 
 MACRO		SMQ$V_NOGENERIC	= 8,5,1,0%; 		! GENERIC QUEUE PRINTING NOT ALLOWED 
 LITERAL	SMQ$M_NOGENERIC	= 1^6 - 1^5; 
 			
 MACRO		SMQ$B_FORMS	= 9,0,8,0%; 		! FORMS TYPE ON PRINTER AT LAST START 
 MACRO		SMQ$B_JOBCNT	= 9,0,8,0%; 		! JOB COUNT FOR BATCH QUEUES 
 MACRO		SMQ$B_CHAR	= 10,0,8,0%; 			! CHARACTERISTICS 
 							! CHARACTERISTICS FOR DEVICE QUEUES 
 MACRO		SMQ$V_DEFFLAG	= 10,0,1,0%; 			! DEFAULT A FLAG PAGE 
 LITERAL	SMQ$M_DEFFLAG	= 1^1 - 1^0; 
 MACRO		SMQ$V_DEFBRST	= 10,1,1,0%; 			! DEFAULT A BURST PAGE 
 LITERAL	SMQ$M_DEFBRST	= 1^2 - 1^1; 
 MACRO		SMQ$V_TRMDEV	= 10,2,1,0%; 			! QUEUE IS FOR A TERMINAL 
 LITERAL	SMQ$M_TRMDEV	= 1^3 - 1^2; 
 MACRO		SMQ$V_LOWER	= 10,3,1,0%; 			! DEVICE SUPPORTS LOWER CASE PRINTING 
 LITERAL	SMQ$M_LOWER	= 1^4 - 1^3; 
 MACRO		SMQ$V_REDIRECT	= 10,4,1,0%; 		! DEVICE IS CURRENTLY REDIRECTED 
 LITERAL	SMQ$M_REDIRECT	= 1^5 - 1^4; 
 			
 							! CHARACTERISTICS FOR BATCH QUEUES 
 MACRO		SMQ$V_INIPRI	= 10,0,4,0%; 		! INITIAL PRIORITY 
 LITERAL	SMQ$M_INIPRI	= 1^4 - 1^0; 
 MACRO		SMQ$V_NOSWAP	= 10,4,1,0%; 			! DISABLE SWAPING 
 LITERAL	SMQ$M_NOSWAP	= 1^5 - 1^4; 
 			
 MACRO		SMQ$B_JOBLIM	= 11,0,8,0%; 		! JOB LIMIT FOR BATCH QUEUES 
 MACRO		SMQ$L_ASNSCT	= 12,0,32,0%; 			! ADDRESS OF ASSIGNED SYMB CONTROL TBL 
 MACRO		SMQ$T_NAME	= 16,0,0,0%; 		! NAME OF QUEUE 
 LITERAL	SMQ$S_NAME	= 16; 
 LITERAL	SMQ$C_SIZE	= 32; 
 LITERAL	SMQ$K_SIZE	= 32; 				! SIZE OF THIS STRUCTURE 
  

  
 !...$DJIDEF			! DETACHED JOB INITIATE MESSAGE 
  
 MACRO		DJI$W_MSGTYP	= 0,0,16,0%; 		! THE MESSAGE FROM SYMBIONT MANAGER 
 MACRO		DJI$B_FLAGS	= 2,0,8,0%; 			! CONTROL FLAGS 
 MACRO		DJI$L_UIC	= 4,0,32,0%; 			! USERS USER IDENTIFICATION CODE 
 MACRO		DJI$T_USERNAM	= 8,0,0,0%; 		! USERS NAME 
 LITERAL	DJI$S_USERNAM	= 12; 
 MACRO		DJI$T_ACNTNAM	= 20,0,0,0%; 		! ACCOUNT TO RUN JOB 
 LITERAL	DJI$S_ACNTNAM	= 8; 
 MACRO		DJI$T_VOLNAM	= 28,0,0,0%; 		! DISK UPON WHICH RESIDES THE FILE 
 LITERAL	DJI$S_VOLNAM	= 16; 
 MACRO		DJI$W_FILEID	= 44,0,0,0%; 		! THE FILE ID OF THE FILE 
 LITERAL	DJI$S_FILEID	= 6; 
 MACRO		DJI$W_DIRID	= 50,0,0,0%; 		! DIRECTORY ID FOR FILE 
 LITERAL	DJI$S_DIRID	= 6; 
 MACRO		DJI$T_JOBNAME	= 56,0,0,0%; 		! JOB NAME FOR LOG 
 LITERAL	DJI$S_JOBNAME	= 8; 
 MACRO		DJI$T_PARMS	= 64,0,0,0%; 		! COMMAND PARAMETERS 
 LITERAL	DJI$S_PARMS	= 64; 
 LITERAL	DJI$C_SIZE	= 128; 
 LITERAL	DJI$K_SIZE	= 128; 				! SIZE OF THE STRUCTURE 
  

  
 ! 
 ! TPARSE CONTROL BLOCK. THIS BLOCK IS ONE OF THE ARGUMENTS USED TO CALL TPARSE, 
 ! AND BECOMES THE ARGUMENT LIST TO ACTION ROUTINES. 
 ! 
 !...$TPADEF	
 MACRO		TPA$L_COUNT	= 0,0,32,0%; 				! ARGUMENT COUNT (NUMBER OF LONGWORDS) 
 LITERAL	TPA$K_COUNT0	= 8; 				! ZERO LEVEL VALUE IS 8 
 MACRO		TPA$L_OPTIONS	= 4,0,32,0%; 			! OPTIONS LONGWORD 
 			 
 MACRO		TPA$V_BLANKS	= 4,0,1,0%; 			! PROCESS BLANKS AND TABS EXPLICITLY 
 LITERAL	TPA$M_BLANKS	= 1^1 - 1^0; 
 MACRO		TPA$V_ABBREV	= 4,1,1,0%; 			! ALLOW MINIMAL ABBREVIATION 
 LITERAL	TPA$M_ABBREV	= 1^2 - 1^1; 
 MACRO		TPA$V_ABBRFM	= 4,2,1,0%; 			! ALLOW FIRST MATCH ABBREVIATION 
 LITERAL	TPA$M_ABBRFM	= 1^3 - 1^2; 
 				 
 MACRO		TPA$V_AMBIG	= 4,16,1,0%; 			! AMBIGUOUS KEYWORD AT THIS STATE 
 LITERAL	TPA$M_AMBIG	= 1^17 - 1^16; 
 			
 MACRO		TPA$B_MCOUNT	= 7,0,8,0%; 		! MINIMUM ABBREVIATION ON KEYWORDS 
 MACRO		TPA$L_STRINGCNT	= 8,0,32,0%; 			! BYTE COUNT OF STRING BEING PARSED 
 MACRO		TPA$L_STRINGPTR	= 12,0,32,0%; 			! ADDRESS OF STRING BEING PARSED 
 MACRO		TPA$L_TOKENCNT	= 16,0,32,0%; 			! BYTE COUNT OF CURRENT MATCHING TOKEN 
 MACRO		TPA$L_TOKENPTR	= 20,0,32,0%; 			! ADDRESS OF MATCHING TOKEN 
 MACRO		TPA$L_CHAR	= 24,0,32,0%; 				! ASCII CODE OF SINGLE CHARACTER TOKEN 
 MACRO		TPA$L_NUMBER	= 28,0,32,0%; 			! NUMERIC VALUE OF NUMERIC TOKEN 
 MACRO		TPA$L_PARAM	= 32,0,32,0%; 				! PARAMETER LONGWORD FROM STATE TABLE 
 LITERAL	TPA$C_LENGTH0	= 36; 
 LITERAL	TPA$K_LENGTH0	= 36; 				! LENGTH OF ZERO LEVEL PARAMETER BLOCK 

  
 ! 
 ! DEFINITIONS FOR STATUS, CHARACTERISTICS AND ERRORS FOR DMC-11 
 ! 
 !...$XMDEF	
 							! DEVICE DEPENDENT LONGWORD 
 MACRO		XM$V_CHR_MOP	= 0,0,1,0%; 			! MOP MODE 
 LITERAL	XM$M_CHR_MOP	= 1^1 - 1^0; 
 MACRO		XM$V_CHR_LOOPB	= 0,1,1,0%; 			! LOOP BACK 
 LITERAL	XM$M_CHR_LOOPB	= 1^2 - 1^1; 
 MACRO		XM$V_CHR_HDPLX	= 0,2,1,0%; 			! HALF DUPLEX 
 LITERAL	XM$M_CHR_HDPLX	= 1^3 - 1^2; 
 MACRO		XM$V_CHR_SLAVE	= 0,3,1,0%; 			! HALF DUPLEX SLAVE STATION 
 LITERAL	XM$M_CHR_SLAVE	= 1^4 - 1^3; 
 MACRO		XM$V_CHR_MBX	= 0,4,1,0%; 				! MAILBOX IS ENABLED 
 LITERAL	XM$M_CHR_MBX	= 1^5 - 1^4; 
 								! SPARE 
 MACRO		XM$V_STS_DCHK	= 0,8,1,0%; 			! DATA CHECK OCCURED 
 LITERAL	XM$M_STS_DCHK	= 1^9 - 1^8; 
 MACRO		XM$V_STS_TIMO	= 0,9,1,0%; 			! TIMEOUT OCCURED 
 LITERAL	XM$M_STS_TIMO	= 1^10 - 1^9; 
 MACRO		XM$V_STS_ORUN	= 0,10,1,0%; 			! DATA OVER RUN OCCURED 
 LITERAL	XM$M_STS_ORUN	= 1^11 - 1^10; 
 MACRO		XM$V_STS_ACTIVE	= 0,11,1,0%; 			! ACTIVE UNIT 
 LITERAL	XM$M_STS_ACTIVE	= 1^12 - 1^11; 
 								! SPARE 
 MACRO		XM$V_STS_DISC	= 0,14,1,0%; 			! LINE DISCONNECT OCCURED 
 LITERAL	XM$M_STS_DISC	= 1^15 - 1^14; 
 								! SPARE 
 MACRO		XM$V_ERR_FATAL	= 0,16,1,0%; 			! HARDWARE ERROR 
 LITERAL	XM$M_ERR_FATAL	= 1^17 - 1^16; 
 				 
 MACRO		XM$V_ERR_MAINT	= 0,19,1,0%; 			! DDCMP MAINT MESSAGE RECEIVED 
 LITERAL	XM$M_ERR_MAINT	= 1^20 - 1^19; 
 MACRO		XM$V_ERR_LOST	= 0,20,1,0%; 			! DATA LOST BECAUSE OF BUFFER SIZE MISMATCH 
 LITERAL	XM$M_ERR_LOST	= 1^21 - 1^20; 
 								! SPARE 
 MACRO		XM$V_ERR_START	= 0,23,1,0%; 			! DDCMP START MESSAGE RECEIVED 
 LITERAL	XM$M_ERR_START	= 1^24 - 1^23; 
 			

 !	$BEGIN	RMSDEF,025 
 ! 
 !	MODIFIED BY: 
 ! 
 !	L F LAVERDURE,   11-JUL-78  14:52 
 !	E H MARISON,	 19-OCT-77  15:59 
 !	W W CLARK,	 24-OCT-77  ??:?? 
 !	J A KRYCKA,	 11-AUG-78  16:24 
 ! 
 !++ 
 ! 
 ! $RMSDEF MACRO--DEFINE ALL VALID STATUS CODES 
 ! 
 ! 
 ! SUCCESS CODES 
 ! 
 !...$RMSDEF	
  
 			 
 						! MOVE TO BIT 14 OF THE STATUS CODE 
 MACRO		RMS$V_STVSTATUS	= 0,14,1,0%; 	! IF SET IN STATUS CODE INDICATES THAT STV 
 			! CONTAINS A FURTHER STATUS CODE 
 			
  
 LITERAL	
 $EQULST (RMS$_,GBL,0,1  
 	,(SUC,65537) 		! <OPERATION SUCCESSFUL> 
 	,(NORMAL,65537) 		! <OPERATION SUCCESSFUL> 
 	); 
  
 LITERAL	
 $EQULST (RMS$_,GBL,98305,8 	!RMS SPECIFIC MESSAGES 
 			!	(BIT 16 = BIT 15 = 1) 
  
 	,(STALL,) 		!MSG <synchronize with operation completion> 
 		! (NOTE: USER NEVER RECEIVES THIS CODE) 
 	,(PENDING,) 		!MSG <asynchronous operation pending completion> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(OK_DUP,) 		!MSG <record inserted had duplicate key> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(OK_IDX,) 		!MSG <index update error occurred (STV)> 
 		! RECORD HAS BEEN INSERTED, BUT INDEX STRUCTURE 
 		! IS NO LONGER OPTIMAL 
 	,(OK_RLK,) 		!MSG <record locked but read anyway> 
 		! (NOTE: BECAUSE LOCKER SET RLK IN ROP FIELD WHEN RECORD WAS LOCKED) 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(OK_RRV,) 		!MSG <record was inserted successfully in primary> 
 		! BUT IT MAY NOT BE ACCESSIBLE VIA ONE- 
 		! OR-MORE SECONDARY KEYS, AND NOT BY RFA ADDRESSING 
 		! FILE REORGANIZATION RECOMMENDED! 
 	,(KFF,) 		!MSG <known file found> 
 	,(OK_ALK,) 		!MSG <record is already locked> 
 	,(OK_DEL,) 		!MSG <deleted record successfully accessed> 
 	,(OK_RNF,) 		!MSG <nonexistent record successfuly accessed> 
 	,(OK_LIM,) 		!MSG <retrieved record exceeds specified key value> 
 	); 
 LITERAL	
 $EQULST (RMS$_,GBL,0,1 		! SUCCESS CODES PASSED THRU FROM DRIVERS AND ACP 
 			!	(BIT 15 = 0) 
  
 	,(CONTROLC,67153) 		!<terminal input aborted due to CTRL/C> 
 	,(CONTROLO,67081) 		!<terminal output ignored due to CTRL/O> 
 	,(CONTROLY,67089) 		!<terminal input aborted due to CTRL/Y> 
 	,(CREATED,67097) 		!<file was created, not opened> 
 	,(SUPERSEDE,67121) 		!<created file superseded existing version> 
 	); 
 ! 
 !  FAILURE CODES 
 ! 
 !   NOTE: THE "@" SYMBOL MEANS "ADDRESS OF" 
 ! 
 ! 
 !  WARNING CODES 
 ! 
 LITERAL	
 $EQULST (RMS$_,GBL,98712,8 	! WARNING CODES 
 			!	(BIT 16 = BIT 15 = 1, BIT 14 = 0) 
  
 	,(BOF,) 		!MSG <beginning of file detected> 
 	,(RNL,) 		!MSG <record not locked> 
 	,(RTB,) 		!MSG FAOCNT=1,<!UL byte record too big for user's buffer> 
 	,(TMO,) 		!MSG <timeout period expired> 
 	); 
 ! 
 !  ERROR CODES 
 ! 
 LITERAL	
 $EQULST (RMS$_,GBL,98906,8 	! ERROR CODES 
 			!	(BIT 16 = BIT 15 = 1, BIT 14 = 0) 
  
 	,(ACT,) 		!MSG <file activity precludes operation> 
 	,(DEL,) 		!MSG <RFA-accessed record was deleted> 
 	,(TEMP1,) 		!MSG <old message code available for reassignment - was DNF> 
 	,(DNR,) 		!MSG <device not ready or not mounted> 
 	,(EOF,) 		!MSG <end of file> 
 	,(FEX,) 		!MSG <file already exists, not superseded> 
 	,(FLK,) 		!MSG <file is locked by another user> 
 	,(FNF,) 		!MSG <file not found> 
 	,(PRV,) 		!MSG <privilege violation (operating system denies access)> 
 	,(REX,) 		!MSG <record already exists> 
 	,(RLK,) 		!MSG <target record locked by another stream> 
 	,(RNF,) 		!MSG <record not found> 
 !			RECORD NEVER WAS IN FILE, OR HAS BEEN DELETED 
 	,(WLK,) 		!MSG <device is write locked> 
 	,(EXP,) 		!MSG <file expiration date not yet reached> 
 	,(NMF,) 		!MSG <no more files> 
 	,(SUP,) 		!MSG FAOCNT=1,<operation not supported over network, DAP code = !XL> 
 	,(RSA,) 		!MSG <record stream currently active> 
 	); 
 ! 
 !  ERROR CODES (AND STV HAS A SYSTEM ERROR CODE) 
 ! 
 LITERAL	
 $EQULST (RMS$_,GBL,114690,8 	!	(BIT 16 = BIT 15 = BIT 14 = 1) 
 	 
 	,(ACC,) 		!MSG <ACP could not access file> 
 	,(CRE,) 		!MSG <ACP could not create file> 
 	,(DAC,) 		!MSG <ACP file deaccess error during CLOSE> 
 	,(ENT,) 		!MSG <ACP enter function failed> 
 	,(EXT,) 		!MSG <file extend failure> 
 	,(FND,) 		!MSG <ACP FIND function failed> 
 	,(MKD,) 		!MSG <ACP could not mark file for deletion> 
 	,(DPE,) 		!MSG <device positioning error> 
 	,(SPL,) 		!MSG <spool or submit command file failure> 
 	,(DNF,) 		!MSG <directory not found> 
 	); 
 ! 
 !  SEVERE ERROR CODES 
 ! 
 LITERAL	
 $EQULST (RMS$_,GBL,99308,8 	! SEVERE ERRORS 
 			!	(BIT 16 = BIT 15 = 1, BIT 14 = 0) 
  
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(ABO,) 		!MSG <operation aborted> 
 	,(AID,) 		!MSG FAOCNT=1,<bad area ID in XAB at !XL> 
 	,(ALN,) 		!MSG FAOCNT=1,<alignment options error in XAB at !XL> 
 	,(ALQ,) 		!MSG <invalid allocation quantity (negative, or 0 on $EXTEND)> 
 	,(ANI,) 		!MSG <not ANSI "D" format> 
 	,(AOP,) 		!MSG FAOCNT=1,<allocation options error in XAB at !XL> 
 	,(BKS,) 		!MSG <bucket size too large (FAB)> 
 	,(BKZ,) 		!MSG FAOCNT=1,<bucket size too large in XAB at !XL> 
 	,(BLN,) 		!MSG <invalid length for control block (RAB/FAB)> 
 	,(BUG,) 		!MSG <internal RMS error condition detected> 
 	,(BUG_DDI,) 		!MSG <default directory invalid> 
 	,(BUG_DAP,) 		!MSG FAOCNT=1,<internal network error condition detected, DAP code = !X 
 	,(BUG_XX2,) 		!MSG <reserved bug code> 
 	,(BUG_XX3,) 		!MSG <reserved bug code> 
 	,(BUG_XX4,) 		!MSG <reserved bug code> 
 	,(BUG_XX5,) 		!MSG <reserved bug code> 
 	,(BUG_XX6,) 		!MSG <reserved bug code> 
 	,(BUG_XX7,) 		!MSG <reserved bug code> 
 	,(BUG_XX8,) 		!MSG <reserved bug code> 
 	,(BUG_XX9,) 		!MSG <reserved bug code> 
 	,(CAA,) 		!MSG <cannot access argument list> 
 	,(CCR,) 		!MSG <cannot connect RAB> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(CHG,) 		!MSG <$UPDATE attempted to change a key with XAB$M__CHG attribute not set> 
 	,(CHK,) 		!MSG <bucket format check failed> 
 	,(COD,) 		!MSG FAOCNT=1,<invalid or unsupported type field in XAB at !XL> 
 	,(CUR,) 		!MSG <no current record (operation not preceded by $GET/$FIND)> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(DAN,) 		!MSG FAOCNT=1,<data area number invalid in XAB at !XL> 
 	,(DEV,) 		!MSG <bad device, or inappropriate device type> 
 	,(DIR,) 		!MSG <error in directory name> 
 	,(DME,) 		!MSG <dynamic memory exhausted> 
 	,(DNA,) 		!MSG <invalid default file specification string> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(DTP,) 		!MSG FAOCNT=1,<DTP field is invalid in XAB at !XL> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(DUP,) 		!MSG <duplicate key detected, XAB$M_DUP attribute not set> 
 	,(DVI,) 		!MSG <invalid device ID field in NAM block> 
 	,(ESA,) 		!MSG <invalid expanded string address> 
 	,(ESS,) 		!MSG <expanded string area too short> 
 	,(FAB,) 		!MSG <invalid FAB (block identifier not=FAB$C_BID or FAB not writeable)> 
 	,(FAC,) 		!MSG <record operation not permitted by specified file access (FAC)> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(FLG,) 		!MSG FAOCNT=1,<invalid flag-bits combination in XAB at !XL> 
 	,(FNA,) 		!MSG <invalid file name string> 
 	,(FNM,) 		!MSG <error in file name> 
 	,(FSZ,) 		!MSG <fixed control header size field invalid (= 1 for print file)> 
 	,(FOP,) 		!MSG <invalid file options> 
 	,(FUL,) 		!MSG <device/file lacks sufficient space for requested allocation> 
 	,(IAL,) 		!MSG <invalid argument list> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(IAN,) 		!MSG FAOCNT=1,<index area number invalid in XAB at !XL> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(IDX,) 		!MSG <index not initialized> 
 	,(IFI,) 		!MSG <invalid internal file identifier (IFI) value> 
 	,(IMX,) 		!MSG FAOCNT=1,<invalid duplicate XAB at !XL> 
 	,(IOP,) 		!MSG <operation illegal or invalid for file organization or device> 
 	,(IRC,) 		!MSG FAOCNT=1,<illegal record encountered  -  STV = !UL (10)> 
 	,(ISI,) 		!MSG <invalid internal stream identifier (ISI) value> 
 	,(KBF,) 		!MSG <invalid key buffer> 
 	,(KEY,) 		!MSG <invalid key field(key=0/neg)> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(KRF,) 		!MSG <invalid key-of-reference($GET/$FIND)> 
 	,(KSZ,) 		!MSG <key size too large(idx)/not=4(rel)> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(LAN,) 		!MSG FAOCNT=1,<lowest-level-index area number invalid in XAB at !XL> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(LBL,) 		!MSG <tape is not ANSI labeled> 
 	,(LNE,) 		!MSG <logical name error> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(LOC,) 		!MSG FAOCNT=1,<allocation location field invalid in XAB at !XL> 
 	,(MRN,) 		!MSG <invalid max. record number (negative) or rel. key greater than MRN> 
 	,(MRS,) 		!MSG <maximumum record size invalid> 
 	,(NAM,) 		!MSG <NAM block invalid or not writeable> 
 	,(NEF,) 		!MSG <not positioned to EOF on $PUT (sequential files only)> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(NID,) 		!MSG <cannot allocate internal index descriptor> 
 	,(NOD,) 		!MSG <node name error> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(NPK,) 		!MSG <indexed file-no primary key defined> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(ORD,) 		!MSG FAOCNT=1,<XABs not in correct order at !XL> 
 	,(ORG,) 		!MSG <invalid file organization value> 
 	,(PBF,) 		!MSG <invalid prompt buffer> 
 	,(PLG,) 		!MSG <error in file's prologue (reconstruct file)> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(POS,) 		!MSG FAOCNT=1,<invalid key position (greater than MRS) in XAB at !XL> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(PRM,) 		!MSG FAOCNT=1,<bad file date field retrieved from XAB at !XL> 
 	,(QUO,) 		!MSG <quoted string error> 
 	,(RAB,) 		!MSG <invalid RAB (block identifier not=RAB$C_BID or RAB not writeable)> 
 	,(RAC,) 		!MSG <illegal record access mode> 
 	,(RAT,) 		!MSG <illegal record attributes> 
 	,(RBF,) 		!MSG <invalid record buffer> 
 	,(RFA,) 		!MSG <invalid record's file address (RFA=0)> 
 	,(RFM,) 		!MSG <invalid record format> 
 	,(RHB,) 		!MSG <invalid record header buffer > 
 	,(RLF,) 		!MSG <invalid related NAM block> 
 	,(ROP,) 		!MSG <invalid record options> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(RRV,) 		!MSG <invalid RRV record encountered> 
 	,(TEMP2,) 		!MSG <old message code available for reassignment - was RSA> 
 	,(RSS,) 		!MSG <invalid resultant string size> 
 	,(RST,) 		!MSG <invalid resultant string address> 
 	,(RSZ,) 		!MSG <bad record size (RSZ greater than MRS, or not=MRS if fixed length rec 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(SEQ,) 		!MSG <primary key out of sequence (RAB$M_SEQ attribute set)> 
 	,(SHR,) 		!MSG <file sharing (SHR) field invalid for file> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(SIZ,) 		!MSG FAOCNT=1,<key size field invalid in XAB at !XL> 
 	,(SQO,) 		!MSG <operation not sequential> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(STK,) 		!MSG <stack too big for save area> 
 	,(SYN,) 		!MSG <file specification syntax error> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(TRE,) 		!MSG <index tree error> 
 	,(TYP,) 		!MSG <error in file type> 
 	,(UBF,) 		!MSG <invalid user buffer> 
 	,(USZ,) 		!MSG <invalid user buffer size> 
 	,(VER,) 		!MSG <error in version number> 
 		! (NEXT CODE CURRENTLY UNUSED) 
 	,(VOL,) 		!MSG FAOCNT=1,<invalid volume number in XAB at !XL> 
 	,(XAB,) 		!MSG FAOCNT=1,<not a valid XAB at !XL (bad length or not writeable)> 
 	,(ESL,) 		!MSG <invalid expanded string length (= 0)> 
 	,(WSF,) 		!MSG <working set full (cannot lock buffers in working set)> 
 	,(ENV,) 		!MSG <support for organization or feature not included in build of this RMS 
 	,(PLV,) 		!MSG <unsupported prologue version> 
 	,(MBC,) 		!MSG <multi-buffer count invalid (negative value)> 
 	,(RSL,) 		!MSG <invalid resultant string length> 
 	,(WLD,) 		!MSG <invalid wildcard operation> 
 	,(NET,) 		!MSG FAOCNT=1,<network operation failed at target node, DAP code = !XL> 
 	,(IBF,) 		!MSG FAOCNT=1,<illegal bucket format  -  STV = !UL (10)> 
 	); 
 ! 
 !  SEVERE ERRORS (AND STV ALSO CONTAINS AN ERROR CODE) 
 ! 
 LITERAL	
 $EQULST (RMS$_,GBL,114892,8 	!	(BIT 16 = BIT 15 = BIT 14 = 1) 
  
 	,(ATR,) 		!MSG <attribute read error> 
 	,(ATW,) 		!MSG <attribute write error> 
 	,(CCF,) 		!MSG <cannot close file> 
 	,(CDA,) 		!MSG <cannot deliver AST> 
 	,(CHN,) 		!MSG <channel assignment failed> 
 	,(RER,) 		!MSG <file read error> 
 	,(RMV,) 		!MSG <ACP remove function failed> 
 	,(RPL,) 		!MSG <error while reading prologue> 
 	,(SYS,) 		!MSG <system (QIO) directive error> 
 	,(WER,) 		!MSG <file write error> 
 	,(WPL,) 		!MSG <error while writing prologue> 
 	,(IFA,) 		!MSG <illegal file attributes (corrupt file header)> 
 	,(WBE,) 		!MSG <error on write behind> 
 	); 
 ! 
 ! 
 !  THE FOLLOWING STATUS CODES ARE USED BY OTHER RMS'S BUT NOT CURRENTLY 
 !  BY RMS32 
 ! 
 !	AST	<INVALID(I.E. SYNCH) OPERATION AT AST LEVEL> 
 !	BPA	<PRIVATE POOL ADDRESS NOT MULTIPLE OF "4"> 
 !	BPS	<PRIVATE POOL SIZE NOT MULTIPLE OF "4"> 
 !	BSZ	<BAD BYTE SIZE> 
 !	CEF	<CAN'T "ERASE" FILE(STV=SYS ERR CODE)> 
 !	CGJ	<CAN'T GET JFN FOR FILE> 
 !	CLS	<RSTS/E CLOSE FUNCTION FAILED(STV=SYS ERR CODE)> 
 !	COF	<CAN'T OPEN FILE> 
 !	DLK	<DEADLOCK CONDITION DETECTED> 
 !	FID	<INVALID FILE ID> 
 !	INI	<$INIT MACRO NEVER ISSUED> 
 !	JFN	<BAD JFN VALUE> 
 !	LBY	<LOGICAL CHANNEL BUSY> 
 !	LCH	<LOGICAL CHANNEL NUMBER TOO LARGE> 
 !	LEX	<LOGICAL EXTEND ERROR - PRIOR EXTEND STILL VALID> 
 !	MAP	<BUFFER MAPPING ERROR> 
 !	OPN	<RSTS/E OPEN FUNCTION FAILED(STV=SYS ERR CODE)> 
 !	PEF	<POSITION TO EOF ERROR> 
 !	XCL	<FILE MUST BE OPEN'D FOR EXCL.ACCESS> 
 ! 
 ! END RMS STATUS CODE DEFINITIONS 
 ! 
 ! MACROS TO DEFINE SYSTEM SERVICE FAILURE AND STATUS CODES. 
 ! 
 ! 
  
 !+ 
 ! SYSTEM STATUS FAILURE CODES 
 !- 
 !...$SSDEF	
  
 ! 
 !	SEVERE ERRORS 
 ! 
  
 LITERAL	
 $EQULST (SS$_,GBL,12,8  
 	,(ACCVIO,) 				!MSG FAOCNT=4,<access violation, reason mask=!XB, virtual address=!XL, 
 	,(BADPARAM,) 			!MSG <bad parameter value> 
 	,(EXQUOTA,) 				!MSG <exceeded quota> 
 	,(NOPRIV,) 				!MSG <no privilege for attempted operation> 
 ! MAKE THE ABOVE ERRORS FALL INTO SHORT LITERALS 
 	,(ABORT,) 				!MSG <abort> 
 	,(BADATTRIB,) 			!MSG <bad attribute control list> 
 	,(BADESCAPE,) 			!MSG <syntax error in escape sequence> 
 	,(BADIMGHDR,) 			!MSG <bad image header> 
 	,(CHANINTLK,) 			!MSG <channel usage interlocked> 
 	,(CTRLERR,) 				!MSG <fatal controller error> 
 	,(DATACHECK,) 			!MSG <write check error> 
 	,(DEVFOREIGN,) 			!MSG <device is mounted foreign> 
 	,(DEVMOUNT,) 			!MSG <device is already mounted> 
 	,(DEVNOTMBX,) 			!MSG <device is not a mailbox> 
 	,(DEVNOTMOUNT,) 			!MSG <device is not mounted> 
 	,(DEVOFFLINE,) 			!MSG <device is not in configuration> 
 	,(DRVERR,) 				!MSG <fatal drive error> 
 	,(DUPLNAM,) 				!MSG <duplicate process name> 
 	,(FILACCERR,) 			!MSG <magnetic tape file access is nonblank> 
 	,(FILALRACC,) 			!MSG <file already accessed on channel> 
 	,(FILNOTACC,) 			!MSG <file not accessed on channel> 
 	,(FILNOTEXP,) 			!MSG <file is not expired> 
 	,(FORMAT,) 				!MSG <invalid media format> 
 	,(GPTFULL,) 				!MSG <global page table is full> 
 	,(GSDFULL,) 				!MSG <global section descriptor table is full> 
 	,(LCKPAGFUL,) 			!MSG <no more pages may be locked in memory> 
 	,(ILLBLKNUM,) 			!MSG <illegal logical block number> 
 	,(ILLCNTRFUNC,) 			!MSG <illegal ACP control function> 
 	,(ILLEFC,) 				!MSG <illegal event flag cluster> 
 	,(ILLIOFUNC,) 			!MSG <illegal I/O function code> 
 	,(ILLPAGCNT,) 			!MSG <illegal page count parameter> 
 	,(ILLSER,) 				!MSG <illegal service call number> 
 	,(INCVOLLABEL,) 			!MSG <incorrect volume label> 
 	,(INSFARG,) 				!MSG <insufficient call arguments> 
 	,(INSFWSL,) 				!MSG <insufficient working set limit> 
 	,(INSFMEM,) 				!MSG <insufficient dynamic memory> 
 	,(INSFRAME,) 			!MSG <insufficient call frames to unwind> 
 	,(IVADDR,) 				!MSG <invalid media address> 
 	,(IVCHAN,) 				!MSG <invalid I/O channel> 
 	,(IVDEVNAM,) 			!MSG <invalid device name> 
 	,(IVGSDNAM,) 			!MSG <invalid global section name> 
 	,(IVLOGNAM,) 			!MSG <invalid logical name> 
 	,(IVLOGTAB,) 			!MSG <invalid logical name table number> 
 	,(IVQUOTAL,) 			!MSG <invalid quota list> 
 	,(IVSECFLG,) 			!MSG <invalid process/global section flags> 
 	,(IVSSRQ,) 				!MSG <invalid system service request> 
 	,(IVSTSFLG,) 			!MSG <invalid status flag> 
 	,(IVTIME,) 				!MSG <invalid time> 
 	,(LENVIO,) 				!MSG <address space length violation> 
 	,(LKWSETFUL,) 			!MSG <locked portion of working set is full> 
 	,(MBTOOSML,) 			!MSG <mailbox is too small for request> 
 	,(MEDOFL,) 				!MSG <medium is offline> 
 	,(NODATA,) 				!MSG <mailbox is empty> 
 	,(NOIOCHAN,) 			!MSG <no I/O channel available> 
 	,(NOLOGNAM,) 			!MSG <no logical name match> 
 	,(NONEXDRV,) 			!MSG <nonexistent drive> 
 	,(NOTFILEDEV,) 			!MSG <device is not file structured> 
 	,(NOTINTBLSZ,) 			!MSG <block size is greater than 2048> 
 	,(NOTLABELMT,) 			!MSG <tape is not labeled> 
 	,(NOTSQDEV,) 			!MSG <not a sequential device> 
 	,(PAGOWNVIO,) 			!MSG <page owner violation> 
 	,(PARITY,) 				!MSG <parity error> 
 	,(PARTESCAPE,) 			!MSG <partial escape> 
 	,(PFMBSY,) 				!MSG <page fault monitor is in use> 
 	,(PSTFULL,) 				!MSG <process section table is full> 
 	,(RESULTOVF,) 			!MSG <resultant string overflow> 
 	,(SECTBLFUL,) 			!MSG <section table (process/global) is full> 
 	,(TAPEPOSLOST,) 			!MSG <magnetic tape position lost> 
 	,(TIMEOUT,) 				!MSG <device timeout> 
 	,(UNASEFC,) 				!MSG <unassociated event flag cluster> 
 	,(UNSAFE,) 				!MSG <drive unsafe> 
 	,(VASFULL,) 				!MSG <virtual address space is full> 
 	,(VECINUSE,) 			!MSG <AST vector already enabled> 
 	,(VOLINV,) 				!MSG <volume is invalid> 
 	,(WRITLCK,) 				!MSG <write lock error> 
 ! ***** MOVE THE FOLLOWING INTO ALPHABETIC ORDER WHEN CONVENIENT 
 	,(NOTAPEOP,) 			!MSG <no tape operator> 
 	,(IVCHNLSEC,) 			!MSG <invalid channel for create and map section> 
 	,(NOMBX,) 				!MSG <no associated mailbox for inbound connects> 
 	,(NOLINKS,) 				!MSG <no slots in logical link vector> 
 	,(NOSOLICIT,) 			!MSG <interrupt message not solicited> 
 	,(NOSUCHNODE,) 			!MSG <specified node does not exist> 
 	,(REJECT,) 				!MSG <network connect rejected> 
 	,(TOOMUCHDATA,) 			!MSG <too much optional or interrupt message data> 
 	,(BUGCHECK,) 			!MSG <internal consistency failure> 
 	,(FILNOTCNTG,) 			!MSG <file is not contiguous as required> 
 	,(BADSTACK,) 			!MSG <bad stack encountered during exception dispatch> 
 	,(MCHECK,) 				!MSG FAOCNT=2,<detected hardware error, PC=!XL, PSL=!XL> 
 	,(DEVACTIVE,) 			!MSG <device is active> 
 	,(HANGUP,) 				!MSG <data set hang-up> 
 	,(OPINCOMPL,) 			!MSG <operation is incomplete> 
 	,(ILLSEQOP,) 			!MSG <illegal sequential operation> 
 	,(IVSECIDCTL,) 			!MSG <invalid section identification match control> 
 	,(NOTNETDEV,) 			!MSG <not a network communication device> 
 	,(IVPROTECT,) 			!MSG <invalid page protection code> 
 	,(ACPVAFUL,) 			!MSG <MTAACP's virtual address space is full> 
 	,(MTLBLLONG,) 			!MSG <magnetic tape volume label can be no more than six characters> 
 	,(BUFBYTALI,) 			!MSG <device does not support byte-aligned transfers> 
 	,(NOAQB,) 				!MSG <ACP queue header not found> 
 	,(WRONGACP,) 			!MSG <wrong ACP for device> 
 	); 
  
 ! 
 ! NOTE THE FOLLOWING NAMES ARE HARDWARE EXCEPTION CODES THAT START AT 1028 
 ! 
  
 LITERAL	
 $EQULST (SS$_,GBL,1028,8  
 	,(PLHLDR,) 				!MSG <reserved for future use> 
 	,(ASTFLT,) 				!MSG FAOCNT=6,<AST fault, SP=!XL, param=!XL, PC=!XL, PSL=!XL, target P 
 	,(BREAK,) 				!MSG FAOCNT=2,<breakpoint fault at PC=!XL, PSL=!XL> 
 	,(CMODSUPR,) 			!MSG FAOCNT=3,<change mode to supervisor trap, code=!XL, PC=!XL, PSL= 
 	,(CMODUSER,) 			!MSG FAOCNT=3,<change mode to user trap, code=!XL, PC=!XL, PSL=!XL> 
 	,(COMPAT,) 				!MSG FAOCNT=3,<compatibility mode fault (code !UB) at PC=!XL, PSL=!XL> 
 	,(OPCCUS,) 				!MSG FAOCNT=2,<opcode reserved to customer fault at PC=!XL, PSL=!XL> 
 	,(OPCDEC,) 				!MSG FAOCNT=2,<opcode reserved to DIGITAL fault at PC=!XL, PSL=!XL> 
 	,(PAGRDERR,) 			!MSG FAOCNT=4,<page read error, reason mask=!XB, virtual address=!XL, 
 	,(RADRMOD,) 				!MSG FAOCNT=2,<reserved addressing fault at PC=!XL, PSL=!XL> 
 	,(ROPRAND,) 				!MSG FAOCNT=2,<reserved operand fault at PC=!XL, PSL=!XL> 
 	,(SSFAIL,) 				!MSG FAOCNT=3,<system service failure exception, status=!XL, PC=!XL, P 
 	,(TBIT,) 				!MSG FAOCNT=2,<T-bit pending trap at PC=!XL, PSL=!XL> 
 	,(DEBUG,) 				!MSG FAOCNT=2,<command interpreter debugger signal at PC=!XL, PSL=!XL> 
 ! 
 ! THE FOLLOWING CODES MUST BE IN ORDER SINCE THEY ARE CALCULATED 
 ! 
 	,(ARTRES,) 				!MSG FAOCNT=2,<reserved arithmetic trap at PC=!XL, PSL=!XL> 
 	,(INTOVF,) 				!MSG FAOCNT=2,<arithmetic trap, integer overflow at PC=!XL, PSL=!XL> 
 	,(INTDIV,) 				!MSG FAOCNT=2,<arithmetic trap, integer divide by zero at PC=!XL, PSL= 
 	,(FLTOVF,) 				!MSG FAOCNT=2,<arithmetic trap, floating overflow at PC=!XL, PSL=!XL> 
 	,(FLTDIV,) 				!MSG FAOCNT=2,<arithmetic trap, floating/decimal divide by zero at PC= 
 	,(FLTUND,) 				!MSG FAOCNT=2,<arithmetic trap, floating underflow at PC=!XL, PSL=!XL> 
 	,(DECOVF,) 				!MSG FAOCNT=2,<arithmetic trap, decimal overflow at PC=!XL, PSL=!XL> 
 	,(SUBRNG,) 				!MSG FAOCNT=2,<arithmetic trap, subscript out of range at PC=!XL, PSL= 
 ! 
 ! THE ABOVE CODES MUST BE IN ORDER SINCE THEY ARE CALCULATED 
 ! 
 ! 
 ! START NEXT SET OF HARDWARE EXCEPTION CODES AT 1412 
 ! 
 	); 
  
 ! 
 !	WARNING CODES 
 ! 
  
 LITERAL	
 $EQULST (SS$_,GBL,2048,8  
 	,(ACCONFLICT,) 			!MSG <file access conflict> 
 	,(BADCHKSUM,) 			!MSG <bad file header checksum> 
 	,(BADFILEHDR,) 			!MSG <bad file header> 
 	,(BADFILENAME,) 			!MSG <bad file name syntax> 
 	,(BADFILEVER,) 			!MSG <bad file version number> 
 	,(BADIRECTORY,) 			!MSG <bad directory file format> 
 	,(CANCEL,) 				!MSG <I/O operation canceled> 
 	,(DATAOVERUN,) 			!MSG <data overrun> 
 	,(DEVALLOC,) 			!MSG <device already allocated to another user> 
 	,(DEVASSIGN,) 			!MSG <device has channels assigned> 
 	,(DEVICEFULL,) 			!MSG <device full - allocation failure> 
 	,(DEVNOTALLOC,) 			!MSG <device not allocated> 
 	,(DIRFULL,) 				!MSG <directory is full> 
 	,(DUPFILENAME,) 			!MSG <duplicate file name> 
 	,(ENDOFFILE,) 			!MSG <end of file> 
 	,(ENDOFTAPE,) 			!MSG <end of tape> 
 	,(EXTIDXFILE,) 			!MSG <***** obsolete - delete when convenient> 
 	,(FCPREADERR,) 			!MSG <file processor read error> 
 	,(FCPREWNDERR,) 			!MSG <file processor rewind error> 
 	,(FCPSPACERR,) 			!MSG <file processor space error> 
 	,(FCPWRITERR,) 			!MSG <file processor write error> 
 	,(FILELOCKED,) 			!MSG <file is deaccess locked> 
 	,(FILENUMCHK,) 			!MSG <file identification number check> 
 	,(FILESEQCHK,) 			!MSG <file identification sequence number check> 
 	,(FILESTRUCT,) 			!MSG <unsupported file structure level> 
 	,(HEADERFULL,) 			!MSG <file header is full> 
 	,(IDXFILEFULL,) 			!MSG <index file is full> 
 	,(MBFULL,) 				!MSG <mailbox is full> 
 	,(NOHOMEBLK,) 			!MSG <Files-11 home block not found on volume> 
 	,(NONEXPR,) 				!MSG <nonexistent process> 
 	,(NONLOCAL,) 			!MSG <device is not a local device> 
 	,(NOHANDLER,) 			!MSG <no condition handler found> 
 	,(NOSIGNAL,) 			!MSG <no signal currently active> 
 	,(NOSUCHDEV,) 			!MSG <no such device available> 
 	,(NOSUCHFILE,) 			!MSG <no such file> 
 	,(RESIGNAL,) 			!MSG <resignal condition to next handler> 
 	,(UNWIND,) 				!MSG <unwind currently in progress> 
 	,(UNWINDING,) 			!MSG <unwind already in progress> 
 ! ***** MOVE THE FOLLOWING INTO ALPHABETIC ORDER WHEN CONVENIENT 
 	,(NOMOREFILES,) 			!MSG <no more files> 
 	,(BEGOFFILE,) 			!MSG <beginning of file> 
 	,(BLOCKCNTERR,) 			!MSG <block count error> 
 	,(MUSTCLOSEFL,) 			!MSG <must close file> 
 	,(WAITUSRLBL,) 			!MSG <waiting for user labels> 
 	,(ILLUSRLBLRD,) 			!MSG <illegal read of user labels> 
 	,(ILLUSRLBLWT,) 			!MSG <illegal write of user labels> 
 	,(ILLLBLAST,) 			!MSG <illegal user label AST control block address> 
 	,(ENDOFUSRLBL,) 			!MSG <end of user labels> 
 	,(NOSUCHSEC,) 			!MSG <no such (global) section> 
 	,(CLIFRCEXT,) 			!MSG <CLI forced exit> 
 	,(FCPREPSTN,) 			!MSG <file processor reposition error> 
 	,(TOOMANYVER,) 			!MSG <too many higher file versions> 
 	); 
  
 ! 
 ! SUCCESS CODES 
 ! ***** DO NOT MIX EXPLICITLY DEFINED CODES WITH INCREMENTAL ASSIGNMENTS 
 ! 
  
 LITERAL	
 $EQULST (SS$_,GBL,1537,8  
 	,(BUFFEROVF,) 			!MSG <output buffer overflow> 
 	,(CONTROLO,) 			!MSG <output completed under CTRL/O> 
 	,(CONTROLY,) 			!MSG <operation completed under CTRL/Y> 
 	,(CREATED,) 				!MSG <file did not exist - was created> 
 	,(MSGNOTFND,) 			!MSG <message not in system message file> 
 	,(NOTRAN,) 				!MSG <no string translation performed> 
 	,(SUPERSEDE,) 			!MSG <logical name superseded> 
 	,(WASECC,) 				!MSG <successful transfer! no data check> 
 ! ***** MOVE THE FOLLOWING INTO ALPHABETIC ORDER WHEN CONVENIENT 
 	,(DEVALRALLOC,) 			!MSG <device already allocated to this job> 
 	,(REMOTE,) 				!MSG <assignment completed on remote node> 
 	,(CONTROLC,) 			!MSG <operation completed under CTRL/C> 
 	,(NOTMODIFIED,) 			!MSG <no pages in the section were modified> 
 	); 
  
 LITERAL	
 $EQULST (SS$_,GBL,0,1  
 	,(CONTINUE,1) 			!<continue execution at point of condition> 
 	,(NORMAL,1) 			!MSG <normal successful completion> 
 	,(WASCLR,1) 			!<previous state was clear> 
 	,(WASSET,9) 			!<previous state was set> 
 	); 

 ! 
 ! Macros to define shared VAX/VMS message codes. 
 ! 
  
 ! These message codes should not be used directly by a facility since 
 ! they do not contain a subsystem (i.e., facility) identifier or a 
 ! severity code.  Use the following formula to calculate actual facility 
 ! message codes. 
  
 !	facility message code = common message code + 
 !				facility id * 65536 + 
 !				severity code 
  
 !...$SHRDEF	
  
 LITERAL	
 $EQULST (SHR$_,GBL,4096,8  
 	,(APPENDEDB,) 		!MSG IDENT=APPENDED,FAOCNT=3,<!AS appended to !AS (!UL block!%S)> 
 	,(APPENDEDR,) 		!MSG IDENT=APPENDED,FAOCNT=3,<!AS appended to !AS (!UL record!%S)> 
 	,(BADBYTE,) 			!MSG IDENT=BADDATA,FAOCNT=2,<invalid data (!XB) at !XL> 
 	,(BADFIELD,) 		!MSG FAOCNT=2,<!AS field invalid at !XL> 
 	,(BADLONG,) 			!MSG IDENT=BADDATA,FAOCNT=2,<invalid data (!XL) at !XL> 
 	,(BADWORD,) 			!MSG IDENT=BADDATA,FAOCNT=2,<invalid data (!XW) at !XL> 
 	,(BEGIN,) 			!MSG FAOCNT=1,<!AS beginning> 
 	,(BEGIND,) 			!MSG IDENT=BEGIN,FAOCNT=2,<!AS beginning at !%D> 
 	,(BEGINT,) 			!MSG IDENT=BEGIN,FAOCNT=2,<!AS beginning at !%T> 
 	,(CLICB,) 			!MSG FAOCNT=1,<CLI control block at !XL> 
 	,(CLOSEIN,) 			!MSG FAOCNT=1,<error closing !AS as input> 
 	,(CLOSEOUT,) 		!MSG FAOCNT=1,<error closing !AS as output> 
 	,(COPIEDB,) 			!MSG IDENT=COPIED,FAOCNT=3,<!AS copied to !AS (!UL block!%S)> 
 	,(COPIEDR,) 			!MSG IDENT=COPIED,FAOCNT=3,<!AS copied to !AS (!UL record!%S)> 
 	,(CREATED,) 			!MSG FAOCNT=1,<!AS created> 
 	,(ENDED,) 			!MSG FAOCNT=1,<!AS ended> 
 	,(ENDEDD,) 			!MSG IDENT=ENDED,FAOCNT=2,<!AS ended at !%D> 
 	,(ENDEDT,) 			!MSG IDENT=ENDED,FAOCNT=2,<!AS ended at !%T> 
 	,(NEWFILES,) 		!MSG FAOCNT=1,<!UL file!%S created> 
 	,(OPENIN,) 			!MSG FAOCNT=1,<error opening !AS as input> 
 	,(OPENOUT,) 			!MSG FAOCNT=1,<error opening !AS as output> 
 	,(OVERLAY,) 			!MSG FAOCNT=1,<!AS being overwritten> 
 	,(READERR,) 			!MSG FAOCNT=1,<error reading !AS> 
 	,(REPLACED,) 		!MSG FAOCNT=1,<!AS being replaced> 
 	,(WILDCONCAT,) 		!MSG IDENT=CONCAT,FAOCNT=0,<wildcard specification cannot be concate 
 	,(WILDOUTVER,) 		!MSG FAOCNT=0,<wildcard version required for output file> 
 	,(WRITEERR,) 		!MSG FAOCNT=1,<error writing !AS> 
 	,(ABEND,) 			!MSG IDENT=ABORT,FAOCNT=1,<!AS aborted> 
 	,(ABENDD,) 			!MSG IDENT=ABORT,FAOCNT=2,<!AS aborted at !%D> 
 	,(ABENDT,) 			!MSG IDENT=ABORT,FAOCNT=2,<!AS aborted at !%T> 
 	,(SYSERRORPC,) 		!MSG IDENT=SYSERROR,FAOCNT=2,<!AS system service error at PC !XL> 
 	,(SYNTAX,) 			!MSG FAOCNT=1,<error parsing '!AS'> 
 	,(NOVALUE,) 			!MSG FAOCNT=1,<'!AS' keyword requires a value> 
 	,(BADKEY,) 			!MSG FAOCNT=1,<'!AS' is an invalid keyword> 
 	,(BADVALUE,) 		!MSG FAOCNT=1,<'!AS' is an invalid keyword value> 
 	,(BADDELIM,) 		!MSG FAOCNT=1,<invalid delimiter following '!AS'> 
 	,(BADLOGIC,) 		!MSG FAOCNT=0,<internal logic error detected> 
 	,(NOWILD,) 			!MSG FAOCNT=0,<no wildcard permitted> 
 	,(TEXT,) 			!MSG FAOCNT=1,<!AS> 
 	,(IDXCONCAT,) 		!MSG IDENT=CONCAT,FAOCNT=0,<indexed file cannot be concatenated> 
 	,(RELCONCAT,) 		!MSG IDENT=CONCAT,FAOCNT=0,<relative file cannot be concatenated> 
 	,(HIGHVER,) 			!MSG FAOCNT=1,<higher version of !AS already exists> 
 	,(BADLOGICPC,) 		!MSG IDENT=BADLOGIC,FAOCNT=1,<internal logic error detected at PC !X 
 	,(ATPC,) 			!MSG FAOCNT=1,<at PC !XL> 
 	,(BADCOPIES,) 		!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid number of copies> 
 	,(BADFORM,) 			!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid form type> 
 	,(BADJOBID,) 		!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid job identifier> 
 	,(BADJOBNAME,) 		!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid job name> 
 	,(BADPRTY,) 			!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid priority> 
 	,(BADQNAME,) 		!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid queue name> 
 	,(BADTIME,) 			!MSG IDENT=BADVALUE,FAOCNT=1,<'!AS' is an invalid time specification> 
 	,(NOQUEUE,) 			!MSG FAOCNT=1,<!AS queue does not exist> 
 	,(NOJOBID,) 			!MSG IDENT=NOJOB,FAOCNT=1,<job !UW not found in !AS queue> 
 	,(NOJOBNAME,) 		!MSG IDENT=NOJOB,FAOCNT=1,<job !AS not found in !AS queue> 
 	,(SYSERROR,) 		!MSG FAOCNT=0,<system service error> 
 	,(NOTCOPIED,) 		!MSG FAOCNT=1,<!AS not copied> 
 	,(NOTCMPLT,) 		!MSG FAOCNT=1,<!AS not completely copied> 
 	,(RMSERROR,) 		!MSG FAOCNT=0,<RMS service error> 
 	,(UNXPCTSTS,) 		!MSG FAOCNT=1,<unexpected status detected. Expected '!AS'. Found:> 
 	,(HASHCONCAT,) 		!MSG IDENT=CONCAT,FAOCNT=0,<hashed file cannot be concatenated> 
 	,(INCOMPAT,) 		!MSG FAOCNT=2,<!AS (input) and !AS (output) have incompatible attribut 
 	,(VALERR,) 			!MSG <specified value is out of legal range> 
 	,(FILNOTDEL,) 		!MSG FAOCNT=1,<error deleting !AS> 
 	,(CONFDEL,) 			!MSG FAOCNT=1,<!/!AS, delete? (Y or N):> 
 	,(DELETED,) 			!MSG FAOCNT=1,<!AS deleted> 
 	,(DELVER,) 			!MSG <explicit version number or wild card required> 
 	,(PURGEVER,) 		!MSG <version numbers not permitted> 
 	,(CLOSEDEL,) 		!MSG FAOCNT=1,<error closing !AS> 
 	,(DIRTOOBUS,) 		!MSG <directory is presently too active to be purged> 
 	,(NOFILPURG,) 		!MSG FAOCNT=1,<no files purged for !AS> 
 	,(FILNOTPUR,) 		!MSG FAOCNT=2,<error deleting !AS!SW> 
 	,(SEARCHFAIL,) 		!MSG FAOCNT=1,<error searching for !AS> 
 	,(DELINTERR,) 		!MSG <internal error in DELETE/PURGE utility> 
 	,(PARSEFAIL,) 		!MSG FAOCNT=1,<error parsing !AS> 
 	,(FILPURGED,) 		!MSG FAOCNT=2,<!AS!SW deleted> 
 	); 

 !	$BEGIN	RMSUSR,013 
 ! 
 !	RMS USER STRUCTURE DEFINITIONS 
 ! 
 !	MODIFIED BY: 
 ! 
 !	L F LAVERDURE,   14-JUL-78  9:24 
 !	E H MARISON,	 19-APR-78  16:20 
 !	E H MARISON,	 26-APR-78  13:08 
 !	W KOENIG,	 16-JUN-78, ADDED DCT BIT IN KEY XAB 
 ! 
 !	FILE ACCESS BLOCK (FAB) DEFINITIONS 
 ! 
 ! 
 !...$FABDEF	
  
 !+++++***** 
 !   THE FIELDS THRU CTX MUST NOT BE MODIFIED DUE TO 
 !   COMMONALITY BETWEEN FAB/RAB/XAB 
 MACRO		FAB$B_BID	= 0,0,8,0%; 		! BLOCK ID 
 LITERAL	FAB$C_BID	= 3; 		! CODE FOR FAB 
 MACRO		FAB$B_BLN	= 1,0,8,0%; 		! BLOCK LEN 
 MACRO		FAB$W_IFI	= 2,0,16,0%; 		! INTERNAL FILE INDEX 
 			 
 						! MOVE TO BIT 6 
 MACRO		FAB$V_PPF_RAT	= 2,6,8,0%; 	! RAT VALUE FOR PROCESS-PERMANENT FILES 
 LITERAL	FAB$M_PPF_RAT	= 1^14 - 1^6; 
 MACRO		FAB$V_PPF_IND	= 2,14,1,0%; 		! INDRECT ACCESS TO PROCESS-PERMANENT FILE 
 LITERAL	FAB$M_PPF_IND	= 1^15 - 1^14; 
 			! (I.E., RESTRICTED OPERATIONS) 
 			
 MACRO		FAB$L_FOP	= 4,0,32,0%; 		! FILE OPTIONS 
 			 
 						! RESERVED FOR ASY (NOT IMPLEMENTED) 
 MACRO		FAB$V_MXV	= 4,1,1,0%; 		! MAXIMIZE VERSION NUMBER 
 LITERAL	FAB$M_MXV	= 1^2 - 1^1; 
 MACRO		FAB$V_SUP	= 4,2,1,0%; 		! SUPERSEDE EXISTING FILE 
 LITERAL	FAB$M_SUP	= 1^3 - 1^2; 
 MACRO		FAB$V_TMP	= 4,3,1,0%; 		! CREATE TEMPORARY FILE 
 LITERAL	FAB$M_TMP	= 1^4 - 1^3; 
 MACRO		FAB$V_TMD	= 4,4,1,0%; 		! CREATE TEMP FILE MARKED FOR DELETE 
 LITERAL	FAB$M_TMD	= 1^5 - 1^4; 
 MACRO		FAB$V_DFW	= 4,5,1,0%; 		! DEFERRED WRITE (REL AND IDX) 
 LITERAL	FAB$M_DFW	= 1^6 - 1^5; 
 MACRO		FAB$V_SQO	= 4,6,1,0%; 		! SEQUENTIAL ACCESS ONLY 
 LITERAL	FAB$M_SQO	= 1^7 - 1^6; 
 MACRO		FAB$V_RWO	= 4,7,1,0%; 		! REWIND MT ON OPEN 
 LITERAL	FAB$M_RWO	= 1^8 - 1^7; 
 MACRO		FAB$V_POS	= 4,8,1,0%; 		! USE NEXT MAGTAPE POSITION 
 LITERAL	FAB$M_POS	= 1^9 - 1^8; 
 MACRO		FAB$V_WCK	= 4,9,1,0%; 		! WRITE CHECKING 
 LITERAL	FAB$M_WCK	= 1^10 - 1^9; 
 MACRO		FAB$V_NEF	= 4,10,1,0%; 		! INHIBIT END OF FILE POSITIONING 
 LITERAL	FAB$M_NEF	= 1^11 - 1^10; 
 MACRO		FAB$V_RWC	= 4,11,1,0%; 		! REWIND MT ON CLOSE 
 LITERAL	FAB$M_RWC	= 1^12 - 1^11; 
 MACRO		FAB$V_DMO	= 4,12,1,0%; 		! DISMOUNT MT ON CLOSE (NOT IMPLEMENTED) 
 LITERAL	FAB$M_DMO	= 1^13 - 1^12; 
 MACRO		FAB$V_SPL	= 4,13,1,0%; 		! SPOOL FILE ON CLOSE 
 LITERAL	FAB$M_SPL	= 1^14 - 1^13; 
 MACRO		FAB$V_SCF	= 4,14,1,0%; 		! SUBMIT COMMAND FILE ON CLOSE 
 LITERAL	FAB$M_SCF	= 1^15 - 1^14; 
 MACRO		FAB$V_DLT	= 4,15,1,0%; 		! DELETE SUB-OPTION 
 LITERAL	FAB$M_DLT	= 1^16 - 1^15; 
 MACRO		FAB$V_NFS	= 4,16,1,0%; 		! NON-FILE STRUCTURED OPERATION 
 LITERAL	FAB$M_NFS	= 1^17 - 1^16; 
 MACRO		FAB$V_UFO	= 4,17,1,0%; 		! USER FILE OPEN - NO RMS OPERATIONS 
 LITERAL	FAB$M_UFO	= 1^18 - 1^17; 
 MACRO		FAB$V_PPF	= 4,18,1,0%; 		! PROCESS PERMANENT FILE (PIO SEGMENT) 
 LITERAL	FAB$M_PPF	= 1^19 - 1^18; 
 MACRO		FAB$V_INP	= 4,19,1,0%; 		! PROCESS-PERMANENT FILE IS 'INPUT' 
 LITERAL	FAB$M_INP	= 1^20 - 1^19; 
 MACRO		FAB$V_CTG	= 4,20,1,0%; 		! CONTIGUOUS EXTENSION 
 LITERAL	FAB$M_CTG	= 1^21 - 1^20; 
 MACRO		FAB$V_CBT	= 4,21,1,0%; 		! CONTIGUOUS BEST TRY 
 LITERAL	FAB$M_CBT	= 1^22 - 1^21; 
 MACRO		FAB$V_JNL	= 4,22,1,0%; 		! EXPLICIT LOGGING (NOT IMPLEMENTED) 
 LITERAL	FAB$M_JNL	= 1^23 - 1^22; 
 MACRO		FAB$V_RCK	= 4,23,1,0%; 		! READ CHECKING 
 LITERAL	FAB$M_RCK	= 1^24 - 1^23; 
 MACRO		FAB$V_NAM	= 4,24,1,0%; 		! USE NAME BLOCK DVI, DID, AND/OR FID FIELDS FOR OPEN 
 LITERAL	FAB$M_NAM	= 1^25 - 1^24; 
 MACRO		FAB$V_CIF	= 4,25,1,0%; 		! CREATE IF NON-EXISTENT 
 LITERAL	FAB$M_CIF	= 1^26 - 1^25; 
 MACRO		FAB$V_UFM	= 4,26,1,0%; 		! USER FILE OPEN MODE (USER IF 1, SUPER IF 0) 
 LITERAL	FAB$M_UFM	= 1^27 - 1^26; 
 			!  ENABLE ONLY IF ESC AND (UFO OR NFS) ARE ALSO ON 
 			!  (NOTE: THIS BIT MUST IMMEDIATELY PRECEDE ESC) 
 MACRO		FAB$V_ESC	= 4,27,1,0%; 		! 'ESCAPE' TO NON-STANDARD FUNCTION ($MODIFY) 
 LITERAL	FAB$M_ESC	= 1^28 - 1^27; 
 MACRO		FAB$V_TEF	= 4,28,1,0%; 		! TRUNCATE AT EOF ON CLOSE (WRITE-ACCESSED SEQ. DISK FILE ONLY) 
 LITERAL	FAB$M_TEF	= 1^29 - 1^28; 
 MACRO		FAB$V_OFP	= 4,29,1,0%; 		! OUTPUT FILE PARSE (ONLY NAME TYPE STICKY) 
 LITERAL	FAB$M_OFP	= 1^30 - 1^29; 
 MACRO		FAB$V_KFO	= 4,30,1,0%; 		! KNOWN FILE OPEN (IMAGE ACTIVATOR ONLY RELEASE 1) 
 LITERAL	FAB$M_KFO	= 1^31 - 1^30; 
 			
 MACRO		FAB$L_STS	= 8,0,32,0%; 		! STATUS 
 MACRO		FAB$L_STV	= 12,0,32,0%; 		! STATUS VALUE 
 MACRO		FAB$L_ALQ	= 16,0,32,0%; 		! ALLOCATION QUANTITY 
 MACRO		FAB$W_DEQ	= 20,0,16,0%; 		! DEFAULT ALLOCATION QUANTITY 
 MACRO		FAB$B_FAC	= 22,0,8,0%; 		! FILE ACCESS 
 			 
 MACRO		FAB$V_PUT	= 22,0,1,0%; 		! PUT ACCESS 
 LITERAL	FAB$M_PUT	= 1^1 - 1^0; 
 MACRO		FAB$V_GET	= 22,1,1,0%; 		! GET ACCESS 
 LITERAL	FAB$M_GET	= 1^2 - 1^1; 
 MACRO		FAB$V_DEL	= 22,2,1,0%; 		! DELETE ACCESS 
 LITERAL	FAB$M_DEL	= 1^3 - 1^2; 
 MACRO		FAB$V_UPD	= 22,3,1,0%; 		! UPDATE ACCESS 
 LITERAL	FAB$M_UPD	= 1^4 - 1^3; 
 MACRO		FAB$V_TRN	= 22,4,1,0%; 		! TRUNCATE ACCESS 
 LITERAL	FAB$M_TRN	= 1^5 - 1^4; 
 MACRO		FAB$V_BIO	= 22,5,1,0%; 		! BLOCK I/O ACCESS 
 LITERAL	FAB$M_BIO	= 1^6 - 1^5; 
 MACRO		FAB$V_BRO	= 22,6,1,0%; 		! BLOCK AND RECORD I/O ACCESS 
 LITERAL	FAB$M_BRO	= 1^7 - 1^6; 
 MACRO		FAB$V_EXE	= 22,7,1,0%; 		! EXECUTE ACCESS (CALLER MUST BE EXEC OR KERNEL MODE, 
 LITERAL	FAB$M_EXE	= 1^8 - 1^7; 
 			!  UFO MUST ALSO BE SET) 
 			
 MACRO		FAB$B_SHR	= 23,0,8,0%; 		! FILE SHARING 
 			 
 MACRO		FAB$V_SHRPUT	= 23,0,1,0%; 	! PUT ACCESS 
 LITERAL	FAB$M_SHRPUT	= 1^1 - 1^0; 
 MACRO		FAB$V_SHRGET	= 23,1,1,0%; 	! GET ACCESS 
 LITERAL	FAB$M_SHRGET	= 1^2 - 1^1; 
 MACRO		FAB$V_SHRDEL	= 23,2,1,0%; 	! DELETE ACCESS 
 LITERAL	FAB$M_SHRDEL	= 1^3 - 1^2; 
 MACRO		FAB$V_SHRUPD	= 23,3,1,0%; 	! UPDATE ACCESS 
 LITERAL	FAB$M_SHRUPD	= 1^4 - 1^3; 
 MACRO		FAB$V_MSE	= 23,4,1,0%; 		! MULTI-STREAM CONNECTS ENABLED 
 LITERAL	FAB$M_MSE	= 1^5 - 1^4; 
 MACRO		FAB$V_NIL	= 23,5,1,0%; 		! NO SHARING 
 LITERAL	FAB$M_NIL	= 1^6 - 1^5; 
 MACRO		FAB$V_UPI	= 23,6,1,0%; 		! USER PROVIDED INTERLOCKING (ALLOWS MULTIPLE 
 LITERAL	FAB$M_UPI	= 1^7 - 1^6; 
 			!  WRITERS TO SEQ. FILES) 
 			
 MACRO		FAB$L_CTX	= 24,0,32,0%; 		! USER CONTEXT 
 !-----***** 
 MACRO		FAB$B_RTV	= 28,0,8,1%; 	! RETRIEVAL WINDOW SIZE 
 MACRO		FAB$B_ORG	= 29,0,8,0%; 		! FILE ORGANIZATION 
 			 
 				 
 MACRO		FAB$V_ORG	= 29,4,4,0%;  
 			
 LITERAL	FAB$C_SEQ	= 0; 		! SEQUENTIAL 
 LITERAL	FAB$C_REL	= 16; 		! RELATIVE 
 LITERAL	FAB$C_IDX	= 32; 		! INDEXED 
 LITERAL	FAB$C_HSH	= 48; 		! HASHED 
 MACRO		FAB$B_RAT	= 30,0,8,0%; 		! RECORD FORMAT 
 			 
 MACRO		FAB$V_FTN	= 30,0,1,0%; 		! FORTRAN CARRIAGE-CTL 
 LITERAL	FAB$M_FTN	= 1^1 - 1^0; 
 MACRO		FAB$V_CR	= 30,1,1,0%; 		! LF-RECORD-CR CARRIAGE CTL 
 LITERAL	FAB$M_CR	= 1^2 - 1^1; 
 MACRO		FAB$V_PRN	= 30,2,1,0%; 		! PRINT-FILE CARRIAGE CTL 
 LITERAL	FAB$M_PRN	= 1^3 - 1^2; 
 MACRO		FAB$V_BLK	= 30,3,1,0%; 		! RECORDS DON'T CROSS BLOCK BOUNDARIES 
 LITERAL	FAB$M_BLK	= 1^4 - 1^3; 
 			
 MACRO		FAB$B_RFM	= 31,0,8,0%; 		! RECORD FORMAT 
 LITERAL	FAB$C_RFM_DFLT	= 2; 		! VAR LEN IS DEFAULT 
 LITERAL	FAB$C_UDF	= 0; 		! UNDEFINED 
 LITERAL	FAB$C_FIX	= 1; 		! FIXED LENGTH RECORDS 
 LITERAL	FAB$C_VAR	= 2; 		! VARIABLE LENGTH RECORDS 
 LITERAL	FAB$C_VFC	= 3; 		! VARIABLE FIXED CONTROL 
 LITERAL	FAB$C_MAXRFM	= 3; 		! MAXIMUM RFM SUPPORTED 
 MACRO		FAB$L_JNL	= 32,0,32,0%; 		! LCB ADDRESS 
 MACRO		FAB$L_XAB	= 36,0,32,0%; 		! XAB ADDRESS 
 MACRO		FAB$L_NAM	= 40,0,32,0%; 		! NAM BLOCK ADDRESS 
 MACRO		FAB$L_FNA	= 44,0,32,0%; 		! FILE NAME STRING ADDRESS 
 MACRO		FAB$L_DNA	= 48,0,32,0%; 		! DEFAULT FILE NAME STRING ADDR 
 MACRO		FAB$B_FNS	= 52,0,8,0%; 		! FILE NAME STRING SIZE 
 MACRO		FAB$B_DNS	= 53,0,8,0%; 		! DEFAULT NAME STRING SIZE 
 MACRO		FAB$W_MRS	= 54,0,16,0%; 		! MAXIMUM RECORD SIZE 
 MACRO		FAB$L_MRN	= 56,0,32,0%; 		! MAXIMUM RECORD NUMBER 
 MACRO		FAB$W_BLS	= 60,0,16,0%; 		! BLOCKSIZE FOR TAPE 
 MACRO		FAB$B_BKS	= 62,0,8,0%; 		! BUCKET SIZE 
 MACRO		FAB$B_FSZ	= 63,0,8,0%; 		! FIXED HEADER SIZE 
 MACRO		FAB$L_DEV	= 64,0,32,0%; 		! DEVICE CHARACTERISTICS 
 MACRO		FAB$L_SDC	= 68,0,32,0%; 		! SPOOLING DEVICE CHARACTERISTICS 
 LITERAL	FAB$C_BLN	= 80; 
 LITERAL	FAB$K_BLN	= 80; 			! LENGTH OF FAB 

  
 ! 
 !	 RECORD ACCESS BLOCK (RAB) DEFINITIONS 
 ! 
 !  THERE IS ONE RAB PER CONNECTED STREAM 
 !  IT IS USED FOR ALL COMMUNICATIONS BETWEEN THE USER 
 !  AND RMS CONCERNING OPERATIONS ON THE STREAM 
 ! 
 !...$RABDEF	
  
 !+++++***** 
 !  THE FIELDS THRU CTX CANNOT BE CHANGED DUE TO COMMONALITY 
 !  WITH THE FAB 
 ! 
 MACRO		RAB$B_BID	= 0,0,8,0%; 		! BLOCK ID 
 LITERAL	RAB$C_BID	= 1; 		! CODE FOR RAB 
 MACRO		RAB$B_BLN	= 1,0,8,0%; 		! BLOCK LENGTH 
 MACRO		RAB$W_ISI	= 2,0,16,0%; 		! INTERNAL STREAM INDEX 
 			! (IFI IN FAB) 
 			 
 						! MOVE TO BIT 6 
 MACRO		RAB$V_PPF_RAT	= 2,6,8,0%; 	! RAT VALUE FOR PROCESS-PERMANENT FILES 
 LITERAL	RAB$M_PPF_RAT	= 1^14 - 1^6; 
 MACRO		RAB$V_PPF_IND	= 2,14,1,0%; 	! INDIRECT ACCESS TO PROCESS-PERMANENT FILE 
 LITERAL	RAB$M_PPF_IND	= 1^15 - 1^14; 
 			! (I.E., RESTRICTED OPERATIONS) 
 			
 MACRO		RAB$L_ROP	= 4,0,32,0%; 		! RECORD OPTIONS 
 			 
 			! THE FOLLOWING BITS MAY BE 
 			! INPUT TO VARIOUS RAB-RELATED 
 			! OPERATIONS 
 			! 
 MACRO		RAB$V_ASY	= 4,0,1,0%; 		! ASYNCHRONOUS OPERATIONS 
 LITERAL	RAB$M_ASY	= 1^1 - 1^0; 
 MACRO		RAB$V_TPT	= 4,1,1,0%; 		! TRUNCATE PUT  -  ALLOW SEQUENTIAL PUT NOT AT 
 LITERAL	RAB$M_TPT	= 1^2 - 1^1; 
 			!   EOF, THUS TRUNCATING FILE (SEQ. ORG ONLY) 
 						! (SPARE) 
 MACRO		RAB$V_UIF	= 4,4,1,0%; 		! UPDATE IF EXISTENT 
 LITERAL	RAB$M_UIF	= 1^5 - 1^4; 
 MACRO		RAB$V_MAS	= 4,5,1,0%; 		! MASS-INSERT MODE 
 LITERAL	RAB$M_MAS	= 1^6 - 1^5; 
 MACRO		RAB$V_FDL	= 4,6,1,0%; 		! FAST RECORD DELETION 
 LITERAL	RAB$M_FDL	= 1^7 - 1^6; 
 MACRO		RAB$V_HSH	= 4,7,1,0%; 		! USE HASH CODE IN BKT 
 LITERAL	RAB$M_HSH	= 1^8 - 1^7; 
 			! 
 MACRO		RAB$V_EOF	= 4,8,1,0%; 		! CONNECT TO EOF 
 LITERAL	RAB$M_EOF	= 1^9 - 1^8; 
 MACRO		RAB$V_RAH	= 4,9,1,0%; 		! READ AHEAD 
 LITERAL	RAB$M_RAH	= 1^10 - 1^9; 
 MACRO		RAB$V_WBH	= 4,10,1,0%; 		! WRITE BEHIND 
 LITERAL	RAB$M_WBH	= 1^11 - 1^10; 
 MACRO		RAB$V_BIO	= 4,11,1,0%; 		! CONNECT FOR BIO ONLY 
 LITERAL	RAB$M_BIO	= 1^12 - 1^11; 
 						! (1 SPARE) 
 MACRO		RAB$V_LOA	= 4,13,1,0%; 		! USE BUCKET FILL PERCENTAGE 
 LITERAL	RAB$M_LOA	= 1^14 - 1^13; 
 MACRO		RAB$V_LIM	= 4,14,1,0%; 		! COMPARE FOR KEY LIMIT REACHED ON $GET/$FIND SEQ. (IDX ONLY) 
 LITERAL	RAB$M_LIM	= 1^15 - 1^14; 
 						! (1 SPARE) 
 			! 
 			! THE FOLLOWING BITS ARE INPUT TO 
 			! $FIND OR $GET 
 			! (SEPARATE BYTE) 
 			! 
 MACRO		RAB$V_LOC	= 4,16,1,0%; 		! USE LOCATE MODE 
 LITERAL	RAB$M_LOC	= 1^17 - 1^16; 
 MACRO		RAB$V_WAT	= 4,17,1,0%; 		! WAIT IF RECORD NOT AVAILABLE 
 LITERAL	RAB$M_WAT	= 1^18 - 1^17; 
 			! (NOT IN RELEASE 1) 
 MACRO		RAB$V_ULK	= 4,18,1,0%; 		! MANUAL UNLOCKING 
 LITERAL	RAB$M_ULK	= 1^19 - 1^18; 
 MACRO		RAB$V_RLK	= 4,19,1,0%; 		! ALLOW READERS FOR THIS LOCKED RECORD 
 LITERAL	RAB$M_RLK	= 1^20 - 1^19; 
 MACRO		RAB$V_NLK	= 4,20,1,0%; 		! DO NOT LOCK RECORD 
 LITERAL	RAB$M_NLK	= 1^21 - 1^20; 
 MACRO		RAB$V_KGE	= 4,21,1,0%; 		! KEY > OR = 
 LITERAL	RAB$M_KGE	= 1^22 - 1^21; 
 MACRO		RAB$V_KGT	= 4,22,1,0%; 		! KEY GREATER THAN 
 LITERAL	RAB$M_KGT	= 1^23 - 1^22; 
 MACRO		RAB$V_NXR	= 4,23,1,0%; 		! GET NON-EXISTENT RECORD 
 LITERAL	RAB$M_NXR	= 1^24 - 1^23; 
 			! 
 			!  THE FOLLOWING BITS ARE TERMINAL QUALIFIERS ONLY 
 			!  (SEPARATE BYTE) 
 			! 
 MACRO		RAB$V_RNE	= 4,24,1,0%; 		! READ NO ECHO 
 LITERAL	RAB$M_RNE	= 1^25 - 1^24; 
 MACRO		RAB$V_TMO	= 4,25,1,0%; 		! USE TIME-OUT PERIOD 
 LITERAL	RAB$M_TMO	= 1^26 - 1^25; 
 MACRO		RAB$V_CVT	= 4,26,1,0%; 		! CONVERT TO UPPER CASE 
 LITERAL	RAB$M_CVT	= 1^27 - 1^26; 
 MACRO		RAB$V_RNF	= 4,27,1,0%; 		! READ NO FILTER 
 LITERAL	RAB$M_RNF	= 1^28 - 1^27; 
 						! SPARE (FOR DSABLMBX IF EVER SUPPORTED) 
 MACRO		RAB$V_PTA	= 4,29,1,0%; 		! PURGE TYPE AHEAD 
 LITERAL	RAB$M_PTA	= 1^30 - 1^29; 
 MACRO		RAB$V_PMT	= 4,30,1,0%; 		! USE PROMPT BUFFER 
 LITERAL	RAB$M_PMT	= 1^31 - 1^30; 
 MACRO		RAB$V_CCO	= 4,31,1,0%; 		! CANCEL CONTROL O ON OUTPUT 
 LITERAL	RAB$M_CCO	= 1^32 - 1^31; 
 			
 MACRO		RAB$B_ROP1	= 5,0,8,0%; 	! VARIOUS OPTIONS 
 MACRO		RAB$B_ROP2	= 6,0,8,0%; 	! GET/FIND OPTIONS 
 MACRO		RAB$B_ROP3	= 7,0,8,0%; 	! TERMINAL READ OPTIONS 
 ! 
 MACRO		RAB$L_STS	= 8,0,32,0%; 		! STATUS 
 MACRO		RAB$L_STV	= 12,0,32,0%; 		! STATUS VALUE 
 MACRO		RAB$W_RFA	= 16,0,0,0%; 	! RECORD'S FILE ADDRESS 
 LITERAL	RAB$S_RFA	= 6; 
 MACRO		RAB$L_RFA0	= 16,0,32,0%;  
 MACRO		RAB$W_RFA4	= 20,0,16,0%;  
 			!  TO THE RFA FIELD TO BE A MOVE QUAD, OVERWRITING 
 			!  THIS RESERVED WORD) 
 MACRO		RAB$L_CTX	= 24,0,32,0%; 		! USER CONTEXT 
 !-----***** 
 MACRO		RAB$B_RAC	= 30,0,8,0%; 		! RECORD ACCESS 
 LITERAL	RAB$C_SEQ	= 0; 		! SEQUENTIAL ACCESS 
 LITERAL	RAB$C_KEY	= 1; 		! KEYED ACCESS 
 LITERAL	RAB$C_RFA	= 2; 		! RFA ACCESS 
 MACRO		RAB$B_TMO	= 31,0,8,0%; 		! TIME-OUT PERIOD 
 MACRO		RAB$W_USZ	= 32,0,16,0%; 		! USER BUFFER SIZE 
 MACRO		RAB$W_RSZ	= 34,0,16,0%; 		! RECORD BUFFER SIZE 
 MACRO		RAB$L_UBF	= 36,0,32,0%; 		! USER BUFFER ADDRESS 
 MACRO		RAB$L_RBF	= 40,0,32,0%; 		! RECORD BUFFER ADDRESS 
 MACRO		RAB$L_RHB	= 44,0,32,0%; 		! RECORD HEADER BUFFER ADDR 
 MACRO		RAB$L_KBF	= 48,0,32,0%; 		! KEY BUFFER ADDRESS 
 MACRO		RAB$L_PBF	= 48,0,32,0%; 	! PROMPT BUFFER ADDR 
 MACRO		RAB$B_KSZ	= 52,0,8,0%; 		! KEY BUFFER SIZE 
 MACRO		RAB$B_PSZ	= 52,0,8,0%; 	! PROMPT BUFFER SIZE 
 MACRO		RAB$B_KRF	= 53,0,8,0%; 		! KEY OF REFERENCE 
 MACRO		RAB$B_MBF	= 54,0,8,1%; 	! MULTI-BUFFER COUNT 
 MACRO		RAB$B_MBC	= 55,0,8,0%; 		! MULTI-BLOCK  COUNT 
 MACRO		RAB$L_BKT	= 56,0,32,0%; 		! BUCKET HASH CODE, VBN, OR RRN 
 MACRO		RAB$L_DCT	= 56,0,32,0%; 	! DUPLICATES COUNT ON KEY ACCESSED ON ALTERNATE KEY 
 MACRO		RAB$L_FAB	= 60,0,32,0%; 		! RELATED FAB FOR CONNECT 
 LITERAL	RAB$C_BLN	= 68; 
 LITERAL	RAB$K_BLN	= 68; 			! LENGTH OF RAB 

  
 ! 
 !	 NAME BLOCK FIELD DEFINITIONS 
 ! 
 !  THE NAM BLOCK IS USED TO COMMUNICATE OPTIONAL 
 !  FILENAME-RELATED INFORMATION 
 ! 
 !...$NAMDEF	
  
 MACRO		NAM$B_BID	= 0,0,8,0%; 		! BLOCK ID 
 LITERAL	NAM$C_BID	= 2; 		! CODE FOR NAM BLOCK 
 MACRO		NAM$B_BLN	= 1,0,8,0%; 		! BLOCK LENGTH 
 !+++++++++++++++++++++++ 
 !  THE FOLLOWING 3 FIELDS MUST NOT BE REARRANGED RELATIVE TO EACH OTHER 
 ! 
 MACRO		NAM$B_RSS	= 2,0,8,0%; 		! RESULTANT STRING AREA SIZE 
 LITERAL	NAM$C_MAXRSS	= 128; 		! MAXIMUM RESULTANT NAME STRING SIZE (NETWORK) 
 LITERAL	NAM$C_MAXRSSLCL	= 96; 		!MAXIMUM RESULTANT NAME STRING SIZE (LOCAL) 
 			!	DEV (15+1) 
 			!	DIR (60) 
 			!	NAME,TYPE,VERSION (9+3+6+2) 
 MACRO		NAM$B_RSL	= 3,0,8,0%; 		! RESULTANT STRING LENGTH 
 MACRO		NAM$L_RSA	= 4,0,32,0%; 		! RESULTANT STRING AREA ADDRESS 
 !----------------------- 
 !+++++++++++++++++++++++ 
 !  THE FOLLOWING 3 FIELDS MUST NOT BE REARRANGED RELATIVE TO EACH OTHER 
 ! 
 MACRO		NAM$B_ESS	= 10,0,8,0%; 		! ESPANDED STRING AREA SIZE 
 MACRO		NAM$B_ESL	= 11,0,8,0%; 		! EXPANDED STRING LENGTH 
 MACRO		NAM$L_ESA	= 12,0,32,0%; 		! EXPANDED STRING AREA ADDRESS 
 !----------------------- 
 MACRO		NAM$L_RLF	= 16,0,32,0%; 		! RELATED FILE NAM BLOCK ADDR 
 MACRO		NAM$T_DVI	= 20,0,0,0%; 	! DEVICE ID 
 LITERAL	NAM$S_DVI	= 16; 
 LITERAL	NAM$C_DVI	= 16; 		! LENGTH OF DVI FIELD 
 !+++++***** 
 !  THE LOCATION OF THE FOLLOWING FIELDS MUST NOT 
 !  BE CHANGED DUE TO THEIR COMMONALITY WITH THE FIB 
 MACRO		NAM$W_FID	= 36,0,0,0%; 	! FILE ID 
 LITERAL	NAM$S_FID	= 6; 
 MACRO		NAM$W_FID_NUM	= 36,0,16,0%; 	! FILE NUMBER 
 MACRO		NAM$W_FID_SEQ	= 38,0,16,0%; 	! SEQUENCE NUMBER 
 MACRO		NAM$W_FID_RVN	= 40,0,16,0%; 	! RELATIVE VOLUME NUMBER 
 MACRO		NAM$W_DID	= 42,0,0,0%; 	! DIRECTORY ID 
 LITERAL	NAM$S_DID	= 6; 
 MACRO		NAM$W_DID_NUM	= 42,0,16,0%; 	! FILE NUMBER 
 MACRO		NAM$W_DID_SEQ	= 44,0,16,0%; 	! SEQUENCE NUMBER 
 MACRO		NAM$W_DID_RVN	= 46,0,16,0%; 	! RELATIVE VOLUME NUMBER 
 MACRO		NAM$L_WCC	= 48,0,32,0%; 		! WILD CARD CONTEXT 
 MACRO		NAM$L_FNB	= 52,0,32,0%; 		! FILE NAME STATUS BITS 
 			 
 MACRO		NAM$V_EXP_VER	= 52,0,1,0%; 	! VERSION WAS EXPLICIT 
 LITERAL	NAM$M_EXP_VER	= 1^1 - 1^0; 
 MACRO		NAM$V_EXP_TYPE	= 52,1,1,0%; 	! TYPE WAS EXPLICIT 
 LITERAL	NAM$M_EXP_TYPE	= 1^2 - 1^1; 
 MACRO		NAM$V_EXP_NAME	= 52,2,1,0%; 	! NAME WAS EXPLICIT 
 LITERAL	NAM$M_EXP_NAME	= 1^3 - 1^2; 
 MACRO		NAM$V_WILD_VER	= 52,3,1,0%; 	! VERSION CONTAINED A WILD CARD 
 LITERAL	NAM$M_WILD_VER	= 1^4 - 1^3; 
 MACRO		NAM$V_WILD_TYPE	= 52,4,1,0%; 	! TYPE CONTAINED A WILD CARD 
 LITERAL	NAM$M_WILD_TYPE	= 1^5 - 1^4; 
 MACRO		NAM$V_WILD_NAME	= 52,5,1,0%; 	! NAME CONTAINED A WILD CARD 
 LITERAL	NAM$M_WILD_NAME	= 1^6 - 1^5; 
 MACRO		NAM$V_EXP_DIR	= 52,6,1,0%; 	! DIRECTORY WAS EXPLICIT 
 LITERAL	NAM$M_EXP_DIR	= 1^7 - 1^6; 
 MACRO		NAM$V_EXP_DEV	= 52,7,1,0%; 	! DEVICE WAS EXPLICIT 
 LITERAL	NAM$M_EXP_DEV	= 1^8 - 1^7; 
 MACRO		NAM$V_WILDCARD	= 52,8,1,0%; 	! FILENAME STRING INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILDCARD	= 1^9 - 1^8; 
 			! (INCLUSIVE OR OF OTHER WILD CARD BITS) 
 						! (SPARES) 
 MACRO		NAM$V_LOWVER	= 52,14,1,0%; 	! LOWER NUMBERED VERSION(S) OF FILE EXIST(S) 
 LITERAL	NAM$M_LOWVER	= 1^15 - 1^14; 
 MACRO		NAM$V_HIGHVER	= 52,15,1,0%; 	! HIGHER 		" 
 LITERAL	NAM$M_HIGHVER	= 1^16 - 1^15; 
 			! 
 MACRO		NAM$V_PPF	= 52,16,1,0%; 		! PROCESS-PERMANENT FILE REFERENCED INDIRECTLY 
 LITERAL	NAM$M_PPF	= 1^17 - 1^16; 
 MACRO		NAM$V_NODE	= 52,17,1,0%; 		! FILENAME SPECIFICATION INCLUDED A NODENAME 
 LITERAL	NAM$M_NODE	= 1^18 - 1^17; 
 MACRO		NAM$V_QUOTED	= 52,18,1,0%; 	! FILENAME SPEC INCLUDED A QUOTED STRING 
 LITERAL	NAM$M_QUOTED	= 1^19 - 1^18; 
 MACRO		NAM$V_GRP_MBR	= 52,19,1,0%; 	! DIRECTORY SPEC WAS OF GROUP-MEMBER FORMAT 
 LITERAL	NAM$M_GRP_MBR	= 1^20 - 1^19; 
 MACRO		NAM$V_WILD_DIR	= 52,20,1,0%; 	! DIRECTORY SPEC INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_DIR	= 1^21 - 1^20; 
 MACRO		NAM$V_DIR_LVLS	= 52,21,3,0%; 	! NUMBER OF DIRECTORY LEVELS (0=UFD ONLY) 
 LITERAL	NAM$M_DIR_LVLS	= 1^24 - 1^21; 
 			
 			 
 						! SEPARATE BYTE FOR WILD CARD DIRECTORY FLAGS 
 MACRO		NAM$V_WILD_UFD	= 52,24,1,0%; 	! UFD INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_UFD	= 1^25 - 1^24; 
 MACRO		NAM$V_WILD_SFD1	= 52,25,1,0%; 	! SFD1 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD1	= 1^26 - 1^25; 
 MACRO		NAM$V_WILD_SFD2	= 52,26,1,0%; 	! SFD2 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD2	= 1^27 - 1^26; 
 MACRO		NAM$V_WILD_SFD3	= 52,27,1,0%; 	! SFD3 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD3	= 1^28 - 1^27; 
 MACRO		NAM$V_WILD_SFD4	= 52,28,1,0%; 	! SFD4 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD4	= 1^29 - 1^28; 
 MACRO		NAM$V_WILD_SFD5	= 52,29,1,0%; 	! SFD5 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD5	= 1^30 - 1^29; 
 MACRO		NAM$V_WILD_SFD6	= 52,30,1,0%; 	! SFD6 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD6	= 1^31 - 1^30; 
 MACRO		NAM$V_WILD_SFD7	= 52,31,1,0%; 	! SFD7 INCLUDED A WILD CARD 
 LITERAL	NAM$M_WILD_SFD7	= 1^32 - 1^31; 
 			
 			 
 						! ALTERNATE DEFINITIONS FOR WILD_UFD AND WILD_SFD1 
 MACRO		NAM$V_WILD_GRP	= 52,24,1,0%; 	! GROUP CONTAINED A WILD CARD 
 LITERAL	NAM$M_WILD_GRP	= 1^25 - 1^24; 
 MACRO		NAM$V_WILD_MBR	= 52,25,1,0%; 	! MEMBER CONTAINED A WILD CARD 
 LITERAL	NAM$M_WILD_MBR	= 1^26 - 1^25; 
 			
 !-----***** 
 LITERAL	NAM$C_BLN	= 56; 
 LITERAL	NAM$K_BLN	= 56; 			! NAME BLOCK LENGTH 
 ! 
 !  THE FOLLOWING FIELDS CONSTITUTE A LONGER NAME BLOCK THAT IS 
 !  SUITABLE FOR USE WITH WILD CARD DIRECTORY OPERATIONS 
 ! 
 MACRO		NAM$L_DWC	= 56,0,0,0%; 		! DIRECTORY WILD CARD CONTEXT 
 LITERAL	NAM$S_DWC	= 24; 
 MACRO		NAM$B_CURLVL	= 56,0,8,0%; 		! CURRENT LEVEL 
 MACRO		NAM$W_PRV_DID	= 58,0,0,0%; 	! PREVIOUS LEVEL DID 
 LITERAL	NAM$S_PRV_DID	= 6; 
 MACRO		NAM$L_DIRWCC1	= 64,0,32,0%; 		! MFD DIRECTORY CONTEXT 
 MACRO		NAM$L_DIRWCC2	= 68,0,32,0%; 	! UFD DIRECTORY CONTEXT 
 MACRO		NAM$L_DIRWCC3	= 72,0,32,0%; 	! SFD1 DIRECTORY CONTEXT 
 MACRO		NAM$L_DIRWCC4	= 76,0,32,0%; 	! SFD2 DIRECTORY CONTEXT 
 LITERAL	NAM$C_BLN_DIRWC	= 80; 
 LITERAL	NAM$K_BLN_DIRWC	= 80; 	 

  
 ! 
 !	 DEFINITIONS FOR ALL XABS 
 !		$XABDEF 
 ! 
 ! 
 !...$XABDEF	
 ! 
 !  THE FIRST FOUR FIELDS ARE SHARED IN COMMON BETWEEN ALL XABS 
 !  AND HENCE ARE DEFINED ONLY ONCE 
 !  (THE ONLY EXCEPTION IS THAT THE SPARE WORD MAY BE USED BY SOME XABS) 
 ! 
 MACRO		XAB$B_COD	= 0,0,8,0%; 		! XAB ID CODE 
 MACRO		XAB$B_BLN	= 1,0,8,0%; 		! BLOCK LENGTH 
 MACRO		XAB$L_NXT	= 4,0,32,0%; 		! XAB CHAIN LINK 
 					!UP TILL NOW COMMON AMONG ALL XABS 
 			!WITH POSSIBLE EXCEPTION OF SPARE FIELD 
 MACRO		XAB$W_RVN	= 8,0,16,0%;  
 MACRO		XAB$Q_RDT	= 12,0,0,1%;  
 LITERAL	XAB$S_RDT	= 8; 
 MACRO		XAB$L_RDT0	= 12,0,32,0%;  
 MACRO		XAB$L_RDT4	= 16,0,32,1%;  
 			!COMMON AMONG DAT AND RDT XABS 
 					!BACK TO END OF TOTAL COMMONALITY 
 MACRO		XAB$B_BKZ	= 22,0,8,0%; 		!COMMON TO FHC AND ALQ XABS 

 !++ 
 !	FILE HEADER CHARACTERISTICS XAB DEFINITIONS 
 !		$XABFHCDEF 
 ! 
 !+++++***** 
 !...$XABFHCDEF	 
 !  THE FIELDS OF THIS XAB CANNOT BE REARRANGED SINCE 
 !  THEY CORRESPOND TO AN ON-DISK STRUCTURE 
 ! 
 LITERAL	XAB$C_FHC	= 29; 		! XABFHC ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 MACRO		XAB$B_RFO	= 8,0,8,0%; 		! RECORD FORMAT AND FILE ORG 
 MACRO		XAB$B_ATR	= 9,0,8,0%; 		! RECORD ATTRIBUTES 
 MACRO		XAB$W_LRL	= 10,0,16,0%; 		! LONGEST RECORD'S LENGTH 
 MACRO		XAB$L_HBK	= 12,0,32,0%; 		! HI VBN ALLOCATED 
 			! (N.B. REVERSED ON DISK!) 
 MACRO		XAB$W_HBK0	= 12,0,16,0%;  
 MACRO		XAB$W_HBK2	= 14,0,16,0%;  
 MACRO		XAB$L_EBK	= 16,0,32,0%; 		! EOF VBN 
 			! (N.B. REVERSED ON DISK) 
 MACRO		XAB$W_EBK0	= 16,0,16,0%;  
 MACRO		XAB$W_EBK2	= 18,0,16,0%;  
 MACRO		XAB$W_FFB	= 20,0,16,0%; 		! FIRST FREE BYTE IN EOF BLOCK 
 			! DEFINED ABOVE IN $XABDEF, SINCE IT IS SHARED 
 			! BY THE ALL XAB) 
 MACRO		XAB$B_HSZ	= 23,0,8,0%; 		! HEADER SIZE FOR VFC 
 MACRO		XAB$W_MRZ	= 24,0,16,0%; 		! MAX RECORD SIZE 
 MACRO		XAB$W_DXQ	= 26,0,16,0%; 		! DEFAULT EXTEND QUANTITY 
 !-----***** 
 MACRO		XAB$L_SBN	= 40,0,32,0%; 		! STARTING LBN IF CONTIGUOUS 
 LITERAL	XAB$C_FHCLEN	= 44; 
 LITERAL	XAB$K_FHCLEN	= 44; 		! LENGTH OF XABFHC 

 !-- 
 !++ 
 ! 
 !	ALLOCATION XAB DEFINITIONS 
 !		$XABALLDEF 
 !...$XABALLDEF	 
 ! 
 ! 
 !+++++***** 
 !  THE FIELDS THRU BKZ CANNOT BE REARRANGED DUE TO 
 !  THEIR COMMONALITY WITH FAB 
 LITERAL	XAB$C_ALL	= 20; 		! XABALL ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 MACRO		XAB$B_AOP	= 8,0,8,0%; 		! ALLOCATION OPTIONS 
 			 
 MACRO		XAB$V_HRD	= 8,0,1,0%; 		! FAIL IF REQUESTED ALIGNMENT IMPOSSIBLE 
 LITERAL	XAB$M_HRD	= 1^1 - 1^0; 
 MACRO		XAB$V_ONC	= 8,1,1,0%; 		! LOCATE ALLOCATED SPACE WITHIN A CYLINDER 
 LITERAL	XAB$M_ONC	= 1^2 - 1^1; 
 						! (SPARES) 
 MACRO		XAB$V_CBT	= 8,5,1,0%; 		! CONTIGUOUS ALLLOCATION, BEST TRY 
 LITERAL	XAB$M_CBT	= 1^6 - 1^5; 
 						! SPARE 
 MACRO		XAB$V_CTG	= 8,7,1,0%; 		! CONTIGUOUS ALLOCATION 
 LITERAL	XAB$M_CTG	= 1^8 - 1^7; 
 			
 MACRO		XAB$B_ALN	= 9,0,8,0%; 		! ALIGNMENT TYPE 
 LITERAL	XAB$C_ANY	= 0; 		! ANY ALLOCATION O.K. 
 LITERAL	XAB$C_CYL	= 1; 		! CYLINDER BOUNDARY 
 LITERAL	XAB$C_LBN	= 2; 		! ALLOCATE AT SPECIFIED LBN 
 LITERAL	XAB$C_VBN	= 3; 		! ALLOCATE NEAR SPECIFIED VBN 
 LITERAL	XAB$C_RFI	= 4; 		! ALLOCATE NEAR RELATED FILE 
 MACRO		XAB$W_VOL	= 10,0,16,0%; 		! RELATIVE VOLUME NO. FOR ALLOCATION 
 			! (NOT APPLICABLE IF ALN = VBN OR RFI) 
 MACRO		XAB$L_LOC	= 12,0,32,0%; 		! ALLOCATION LOCATION 
 MACRO		XAB$L_ALQ	= 16,0,32,0%; 		! ALLOCATION QUANTITY 
 MACRO		XAB$W_DEQ	= 20,0,16,0%; 		! DEFAULT ALLOCATION QUANTITY 
 			! DEFINED ABOVE IN $XABDEF,SINCE IT IS SHARED BY THE FHC 
 			! XAB AND HAS THE SAME OFFSET, OF COURSE) 
 !-----***** 
 MACRO		XAB$B_AID	= 23,0,8,0%; 		! AREA ID NUMBER 
 MACRO		XAB$W_RFI	= 24,0,0,0%; 	! RELATED FILE ID 
 LITERAL	XAB$S_RFI	= 6; 
 MACRO		XAB$W_RFI0	= 24,0,16,0%; 	! FILE NUMBER 
 MACRO		XAB$W_RFI2	= 26,0,16,0%; 	! SEQ NUMBER 
 MACRO		XAB$W_RFI4	= 28,0,16,0%; 	! REV NUMBER 
 LITERAL	XAB$C_ALLLEN	= 32; 
 LITERAL	XAB$K_ALLLEN	= 32; 		! LENGTH OF XABALL 

 !-- 
 !++ 
 ! 
 !	DATE/TIME XAB DEFINITIONS 
 !		$XABDATDEF 
 !...$XABDATDEF	 
 ! 
 LITERAL	XAB$C_DAT	= 18; 		! XABDAT ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 MACRO		XAB$Q_CDT	= 20,0,0,1%; 	! CREATION DATE & TIME 
 LITERAL	XAB$S_CDT	= 8; 
 MACRO		XAB$L_CDT0	= 20,0,32,0%;  
 MACRO		XAB$L_CDT4	= 24,0,32,1%;  
 MACRO		XAB$Q_EDT	= 28,0,0,1%; 	! EXPIRATION DATE & TIME 
 LITERAL	XAB$S_EDT	= 8; 
 MACRO		XAB$L_EDT0	= 28,0,32,0%;  
 MACRO		XAB$L_EDT4	= 32,0,32,1%;  
 LITERAL	XAB$C_DATLEN	= 36; 
 LITERAL	XAB$K_DATLEN	= 36; 		! LENGTH OF XABDAT 

 !-- 
 !++ 
 ! 
 !	REVISION DATE/TIME XAB DEFINITIONS 
 !		$XABRDTDEF 
 !...$XABRDTDEF	 
 LITERAL	XAB$C_RDT	= 30; 		! XABRDT ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 LITERAL	XAB$C_RDTLEN	= 20; 
 LITERAL	XAB$K_RDTLEN	= 20; 		! LENGTH OF RDT XAB 

 !-- 
 !++ 
 ! 
 !	PROTECTION XAB FIELD DEFINITIONS 
 !		$XABPRODEF 
 ! 
 !...$XABPRODEF	 
 ! 
 LITERAL	XAB$C_PRO	= 19; 		! XABPRO ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 MACRO		XAB$W_PRO	= 8,0,16,0%; 		! PROTECTION MASK 
 			 
 MACRO		XAB$V_SYS	= 8,0,4,0%; 		! SYSTEM 
 MACRO		XAB$V_OWN	= 8,4,4,0%; 		! OWNER 
 MACRO		XAB$V_GRP	= 8,8,4,0%; 		! GROUP 
 MACRO		XAB$V_WLD	= 8,12,4,0%; 		! WORLD 
 			
 			 
 MACRO		XAB$V_NOREAD	= 8,0,1,0%; 	! DENY READ ACCESS 
 LITERAL	XAB$M_NOREAD	= 1^1 - 1^0; 
 MACRO		XAB$V_NOWRITE	= 8,1,1,0%; 	! DENY WRITE ACCESS 
 LITERAL	XAB$M_NOWRITE	= 1^2 - 1^1; 
 MACRO		XAB$V_NOEXE	= 8,2,1,0%; 		! DENY EXECUTION ACCESS 
 LITERAL	XAB$M_NOEXE	= 1^3 - 1^2; 
 MACRO		XAB$V_NODEL	= 8,3,1,0%; 		! DENY DELETE ACCESS 
 LITERAL	XAB$M_NODEL	= 1^4 - 1^3; 
 			
 MACRO		XAB$L_UIC	= 12,0,32,0%; 		! UIC CODE 
 MACRO		XAB$W_MBM	= 12,0,16,0%; 	! MEMBER CODE 
 MACRO		XAB$W_GRP	= 14,0,16,0%; 	! GROUP CODE 
 LITERAL	XAB$C_PROLEN	= 16; 
 LITERAL	XAB$K_PROLEN	= 16; 		! XABPRO LENGTH 

 !-- 
 !++ 
 ! 
 !	TERMINAL CONTROL XAB FIELD DEFINITIONS 
 !		$XABTRMDEF 
 ! 
 ! 
 !...$XABTRMDEF	 
 ! 
 LITERAL	XAB$C_TRM	= 31; 		!XABTRM ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 MACRO		XAB$L_AST_ADDR	= 8,0,32,0%; 	!AST ADDRESS 
 MACRO		XAB$L_AST_PARM	= 12,0,32,0%; 	!AST PARAMETER 
 MACRO		XAB$W_MBX_CHAN	= 16,0,16,0%; 	!ASSOCIATED MAILBOX CHANNEL NUMBER 
 MACRO		XAB$B_FLAGS	= 18,0,8,0%;  
 			 
 MACRO		XAB$V_DSABL_AST	= 18,0,1,0%; 	!DISABLE AST 
 LITERAL	XAB$M_DSABL_AST	= 1^1 - 1^0; 
 			
 LITERAL	XAB$C_TRMLEN	= 24; 
 LITERAL	XAB$K_TRMLEN	= 24; 		!LENGTH OF XAB OF TYPE TERMINAL CONTROL 

 !-- 
 !++ 
 ! 
 !	SUMMARY XAB FIELD DEFINITIONS 
 !		$XABSUMDEF 
 ! 
 !...$XABSUMDEF	 
 ! 
 LITERAL	XAB$C_SUM	= 20; 		! XABSUM ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 MACRO		XAB$B_NOA	= 8,0,8,0%; 		! NUMBER OF DEFINED AREAS FOR INDEX FILE 
 MACRO		XAB$B_NOK	= 9,0,8,0%; 		! NUMBER OF DEFINED KEYS FOR INDEX FILE 
 MACRO		XAB$W_PVN	= 10,0,16,0%; 		! PROLOGUE VERSION NUMBER (RELATIVE AND INDEX FILES) 
 LITERAL	XAB$C_SUMLEN	= 12; 
 LITERAL	XAB$K_SUMLEN	= 12; 		! XABSUM LENGTH 

 !-- 
 !++ 
 ! 
 !	KEY DEFINITION XAB FIELD DEFINITIONS 
 !		$XABKEYDEF 
 ! 
 !...$XABKEYDEF	 
 ! 
 LITERAL	XAB$C_KEY	= 21; 		! XABKEY ID CODE 
 			!THESE 4 FIELDS ARE COMMON TO ALL XABS AND 
 			!HAVE BEEN DEFINED BY $XABDEF 
 ! 
 ! THE FIELD LAYOUT OF THE KEY XAB IS SUCH THAT IT MATCHS AS 
 ! CLOSELY AS POSSIBLE THE LAYOUT OF A KEY DECRIPTOR IN THE 
 ! INDEX FILE PROLOGUE. THIS IS SO THE CONTENTS MAY BE MOVED 
 ! BETWEEN THE TWO STRUCTURES AS EFFICIENTLY AS POSSIBLE. 
 ! 
 MACRO		XAB$B_IAN	= 8,0,8,0%; 		! INDEX LEVEL AREA NUMBER 
 MACRO		XAB$B_LAN	= 9,0,8,0%; 		! LOWEST INDEX LEVEL AREA NUMBER 
 MACRO		XAB$B_DAN	= 10,0,8,0%; 		! DATA LEVEL AREA NUMBER 
 MACRO		XAB$B_LVL	= 11,0,8,0%; 		! LEVEL OF ROOT BUCKET 
 MACRO		XAB$B_IBS	= 12,0,8,0%; 		! SIZE OF INDEX BUCKETS IN VIRTUAL BLOCKS 
 MACRO		XAB$B_DBS	= 13,0,8,0%; 		! SIZE OF DATA BUCKETS IN VIRTUAL BLOCKS 
 MACRO		XAB$L_RVB	= 14,0,32,0%; 		! ROOT BUCKET START VBN 
 MACRO		XAB$B_FLG	= 18,0,8,0%; 		! KEY OPTION FLAGS 
 			 
 MACRO		XAB$V_DUP	= 18,0,1,0%; 		! DUPLICATE KEY VALUES ALLOWED 
 LITERAL	XAB$M_DUP	= 1^1 - 1^0; 
 MACRO		XAB$V_CHG	= 18,1,1,0%; 		! ALT KEY ONLY --KEY FIELD MAY CHANGE ON UPDATE 
 LITERAL	XAB$M_CHG	= 1^2 - 1^1; 
 MACRO		XAB$V_NUL	= 18,2,1,0%; 		! ALT KEY ONLY --NULL KEY VALUE ENABLE 
 LITERAL	XAB$M_NUL	= 1^3 - 1^2; 
 				 
 MACRO		XAB$V_INI	= 18,4,1,0%; 		! INTERNAL FLAG INDICATING THAT INDEX 
 LITERAL	XAB$M_INI	= 1^5 - 1^4; 
 			! HAS NOT BEEN INITIALIZED 
 MACRO		XAB$V_DCT	= 18,5,1,0%; 		! SET TO INDICATE THAT THE USER WANTS TO MAINTAIN 
 LITERAL	XAB$M_DCT	= 1^6 - 1^5; 
 			! A DUPLICATES COUNT 
 			
  
 					! PRIMARY KEY ONLY FLAGS 
 						! SPACE OVER DUP 
 MACRO		XAB$V_NRF	= 18,1,1,0%; 		! NO RFA/RRV IN RECORDS (SINGLE KEY ONLY) 
 LITERAL	XAB$M_NRF	= 1^2 - 1^1; 
 MACRO		XAB$V_PRG	= 18,2,1,0%; 		! DELETED RECORDS AND RRV'S MAY BE PURGED 
 LITERAL	XAB$M_PRG	= 1^3 - 1^2; 
 			
  
 MACRO		XAB$B_DTP	= 19,0,8,0%; 		! KEY FIELD DATA TYPE 
 LITERAL	XAB$C_STG	= 0; 		! STRING 
 LITERAL	XAB$C_IN2	= 1; 		! SIGNED 15 BIT INTEGER (2 BYTES) 
 LITERAL	XAB$C_BN2	= 2; 		! 2 BYTE BINARY 
 LITERAL	XAB$C_IN4	= 3; 		! SIGNED 31 BIT INTEGER (4 BYTES) 
 LITERAL	XAB$C_BN4	= 4; 		! 4 BYTE BINARY 
 LITERAL	XAB$C_PAC	= 5; 		! PACKED DECIMAL (1-16 BYTES) 
 MACRO		XAB$B_NSG	= 20,0,8,0%; 		! NUMBER OF KEY SEGMENTS 
 MACRO		XAB$B_NUL	= 21,0,8,0%; 		! NUL KEY CHARACTER 
 MACRO		XAB$B_TKS	= 22,0,8,0%; 		! TOTAL KEY FIELD SIZE (BYTES) 
 MACRO		XAB$B_REF	= 23,0,8,0%; 		! KEY OF REFERENCE (0=PRIM KEY, 
 			! 1-254 = ALTERNATE KEYS) 
 MACRO		XAB$W_MRL	= 24,0,16,0%; 		! MINIMUN RECORD LENGTH TO CONTAIN KEY FIELD 
 MACRO		XAB$W_IFL	= 26,0,16,0%; 		! INDEX BUCKET FILL SIZE (BYTES) 
 MACRO		XAB$W_DFL	= 28,0,16,0%; 		! DATA BUCKET FIL SIZE (BYTES) 
 MACRO		XAB$W_POS	= 30,0,0,0%; 	! KEY FIELD RECORD OFFSET POSITIONS 
 LITERAL	XAB$S_POS	= 16; 
 MACRO		XAB$W_POS0	= 30,0,16,0%; 	! SEGMENT 0 
 MACRO		XAB$W_POS1	= 32,0,16,0%; 	! SEGMENT 1 
 MACRO		XAB$W_POS2	= 34,0,16,0%; 	! SEGMENT 2 
 MACRO		XAB$W_POS3	= 36,0,16,0%; 	! SEGMENT 3 
 MACRO		XAB$W_POS4	= 38,0,16,0%; 	! SEGMENT 4 
 MACRO		XAB$W_POS5	= 40,0,16,0%; 	! SEGMENT 5 
 MACRO		XAB$W_POS6	= 42,0,16,0%; 	! SEGMENT 6 
 MACRO		XAB$W_POS7	= 44,0,16,0%; 	! SEGMENT 7 
 MACRO		XAB$B_SIZ	= 46,0,0,0%; 	! KEY FIELD SEGMENT SIZES 
 LITERAL	XAB$S_SIZ	= 8; 
 MACRO		XAB$B_SIZ0	= 46,0,8,0%; 	! SEGMENT 0 
 MACRO		XAB$B_SIZ1	= 47,0,8,0%; 	! SEGMENT 1 
 MACRO		XAB$B_SIZ2	= 48,0,8,0%; 	! SEGMENT 2 
 MACRO		XAB$B_SIZ3	= 49,0,8,0%; 	! SEGMENT 3 
 MACRO		XAB$B_SIZ4	= 50,0,8,0%; 	! SEGMENT 4 
 MACRO		XAB$B_SIZ5	= 51,0,8,0%; 	! SEGMENT 5 
 MACRO		XAB$B_SIZ6	= 52,0,8,0%; 	! SEGMENT 6 
 MACRO		XAB$B_SIZ7	= 53,0,8,0%; 	! SEGMENT 7 
 ! 
 ! THE POSITIONS OF THE ABOVE FIELDS ARE DICTATED BY THE KEY DESCRIPTOR 
 ! RECORD LAYOUT IN THE INDEX FILE PROLOGUE. 
 ! 
 MACRO		XAB$L_KNM	= 56,0,32,0%; 		! POINTER TO 32 CHARACTER KEY NAME BUFFER 
 MACRO		XAB$L_DVB	= 60,0,32,0%; 		! FIRST DATA BUCKET START VBN 
 LITERAL	XAB$C_KEYLEN	= 64; 
 LITERAL	XAB$K_KEYLEN	= 64; 		! XABKEY LENGTH 
 !-- 
 !++ 

  
 ! 
 !		RMS ESCAPE DEFINITIONS 
 ! 
 !  THE FOLLOWING VALUES IDENTIFY VARIOUS REQUESTS FOR NON-STANDARD RMS 
 !  FUNCTIONS.  THEY ARE CURRENTLY INPUT TO THE $MODIFY FUNCTION IN THE 
 !  CTX FIELD OF THE FAB ONLY IF THE ESC BIT IS SET IN FOP.  INCORRECT 
 !  USE OF THESE CAPABILTIES COULD CAUSE RMS TO FAIL, HENCE GREAT CAUTION 
 !  SHOULD BE EXERCISED IN THEIR USE. 
 ! 
 !...$RMEDEF	
  
 LITERAL	RME$C_SETRFM	= 1; 		! CHANGE RFM, MRS, AND FSZ (IF VFC) IN IFAB ONLY 

 ! REQUIRE file defining all VAX SRM symbols. 
 ! File: SRMDEF.MDL! Version 0, edit 11, TNH, 7-Dec-77 
 ! Edit History: 
 ! 0-8	- Added PSW structure and more stack frame fields.  TNH 8-Oct-77 
 ! 0-9	- Added SF$ (stack frame) structure.  TNH 9-Oct-77 
 ! 0-10	- Remove DSC$W_MAXLEN, add DSC$A_FRAME, remove SRM$ stack defns. TNH 6-De 
 !	  Also add mask fields for PSW, saved PSW. 
 !	  Change SF$L_SAVE_REGN to SF$L_SAVE_REGS. 
 ! 0-11	- Add lengths for all descriptors.  TNH 7-Dec-77 
 ! 0-12	- Restored DSC$W_MAXLEN, added debugger data types.  ACG 10-Mar-78 
  
 ! VAX Procedure Calling symbols. 
 ! These symbols are taken from Appendix C of the VAX-11 
 ! System Reference Manual which is under ECO control. No 
 ! additions to this file cannot be made without first getting 
 ! formal ECO approval to Appendix C of the SRM. 
 ! No symbols should be removed or changed without careful 
 ! evaluation of the effects of such changes on existing software. 
 ! In case of disagreement, SRM Appendix C takes precedence 
 ! over this file. 
 ! These symbols are taken from Appendix C rev 4, 30 Mar-77 
  
  
 !...$DSCDEF		! prefix DSC$_ 
  
 ! a formal ECO approved to Appendix C of the SRM. 
  
 ! Define Procedure argument data types 
  
 !   C.9  ARGUMENT DATA TYPES 
  
 !   The following encoding is used for atomic data elements: 
  
 !         Mnemonic    Code    Description 
  
 LITERAL	DSC$K_DTYPE_Z	= 0; 		! Unspecified.   The  calling   program   has 
 			! specified   no   data   type!   the  called 
 			! procedure should assume the argument is  of 
 			! the correct type. 
  
 LITERAL	DSC$K_DTYPE_V	= 1; 		    ! Bit.   Ordinarily  a   bit   string!    see 
 			! discussion of descriptors. 
  
 LITERAL	DSC$K_DTYPE_BU	= 2; 		! Byte Logical.  8-bit unsigned quantity. 
  
 LITERAL	DSC$K_DTYPE_WU	= 3; 		! Word Logical.  16-bit unsigned quantity. 
  
 LITERAL	DSC$K_DTYPE_LU	= 4; 		! Longword    Logical.     32-bit    unsigned 
 			! quantity. 
  
 LITERAL	DSC$K_DTYPE_QU	= 5; 		! Quadword    Logical.     64-bit    unsigned 
 			! quantity. 
  
 LITERAL	DSC$K_DTYPE_B	= 6; 		! Byte Integer.  8-bit signed  2's-complement 
 			! integer. 
  
 LITERAL	DSC$K_DTYPE_W	= 7; 			! Word Integer.  16-bit signed 2's-complement 
 			! integer. 
  
 LITERAL	DSC$K_DTYPE_L	= 8; 		! Longword    Integer.       32-bit signed 
 			! 2's-complement integer. 
  
 LITERAL	DSC$K_DTYPE_Q	= 9; 		! Quadword    Integer.      64-bit     signed 
 			! 2's-complement integer. 
  
 LITERAL	DSC$K_DTYPE_F	= 10; 		! Single-precision Floating.   32-bit  VAX-11 
 			! floating point. 
  
 LITERAL	DSC$K_DTYPE_D	= 11; 		! Double-precision Floating.   64-bit  VAX-11 
 			! floating point. 
  
 LITERAL	DSC$K_DTYPE_FC	= 12; 		! Complex.  Ordered pair of  single-precision 
 			! floating quantities, representing a complex 
 			! number.   The  lower   addressed   quantity 
 			! represents   the   real  part,  the  higher 
 			! addressed represents the imaginary part. 
  
 LITERAL	DSC$K_DTYPE_DC	= 13; 		! Double-precision Complex.  Ordered pair  of 
 			! double-precision floating point quantities, 
 			! representing a complex number.   The  lower 
 			! addressed   quantity  represents  the  real 
 			! part, the higher addressed  represents  the 
 			! imaginary part. 
  
 !  The following string  types  are  ordinarily  described  by  a  string 
 !  descriptor.  The data type codes below occur in those descriptors: 
  
 LITERAL	DSC$K_DTYPE_T	= 14; 		! ASCII text string.   A  sequence  of  8-bit 
                         !     ASCII characters. 
  
 LITERAL	DSC$K_DTYPE_NU	= 15; 		! Numeric string, unsigned. 
  
 LITERAL	DSC$K_DTYPE_NL	= 16; 		! Numeric string, left separate sign. 
  
 LITERAL	DSC$K_DTYPE_NLO	= 17; 		! Numeric string, left overpunched sign. 
  
 LITERAL	DSC$K_DTYPE_NR	= 18; 		  ! Numeric string, right separate sign. 
  
 LITERAL	DSC$K_DTYPE_NRO	= 19; 		! Numeric string, right overpunched sign. 
  
 LITERAL	DSC$K_DTYPE_NZ	= 20; 		! Numeric string, zoned sign. 
  
 LITERAL	DSC$K_DTYPE_P	= 21; 		   ! Packed decimal string. 
  
 LITERAL	DSC$K_DTYPE_ZI	= 22; 		! Sequence of instructions. 
  
 LITERAL	DSC$K_DTYPE_ZEM	= 23; 		! Procedure entry mask. 
  
 ! The following descriptor types are used to identify data types in 
 ! object module and debugger symbol tables. 
  
 LITERAL	DSC$K_DTYPE_FLD	= 183; 		! BLISS FIELD name. 
  
 LITERAL	DSC$K_DTYPE_PCT	= 184; 		! PSECT information. 
  
 LITERAL	DSC$K_DTYPE_DPC	= 185; 		! PC correlation table for FORTRAN IV+ 
  
 LITERAL	DSC$K_DTYPE_LBL	= 186; 		! LITERAL or LABEL 
  
 LITERAL	DSC$K_DTYPE_SLB	= 187; 		! Label in non-assembly language modules 
  
 LITERAL	DSC$K_DTYPE_MOD	= 188; 		! Beginning of new module 
  
 LITERAL	DSC$K_DTYPE_EOM	= 189; 		! End of module 
  
 LITERAL	DSC$K_DTYPE_RTN	= 190; 		! Beginning of new routine 
  
 LITERAL	DSC$K_DTYPE_EOR	= 191; 		! End of routine 
  
 !   The following type codes are RESERVED for future use: 
  
  
 !                     24-182  RESERVED to DEC 
 !                     192-255  RESERVED to CSS and customers 
 	! C.10  ARGUMENT DESCRIPTORS 
  
 	! A uniform descriptor mechanism is defined for use  by  all  procedures 
 	! which  conform  to this standard.  Descriptors are uniformly typed and 
 	! the mechanism is extensible.  As new varieties  of  descriptor  become 
 	! necessary, they will be added to this catalogue. 
  
  
  
 	! C.10.1  Descriptor Prototype 
  
 	! Each class of descriptor consists of  at  least  2  longwords  in  the 
 	! following format: 
  
 	!      +-------+-------+---------------+ 
 	!      | CLASS | DTYPE |    LENGTH     |  :Descriptor 
 	!      +-------+-------+---------------+ 
 	!      |            POINTER            | 
 	!      +-------------------------------+ 
  
 	!      DSC$W_LENGTH   A one-word field specific to the descriptor 
 	!      <0,15:0>       class!  typically a 16-bit (unsigned) length. 
 	! 
 	!      DSC$B_DTYPE    A one-byte atomic data type code (see C.9) 
 	!      <0,23:16> 
 	! 
 	!      DSC$B_CLASS    A one-byte descriptor class code (see below) 
 	!      <0,31:24> 
 	! 
 	!      DSC$A_POINTER  A longword pointing to the first byte of the 
 	!      <1,31:0>       data element described. 
  
 	! Note that the descriptor can be placed in a pair of registers  with  a 
 	! MOVQ  instruction and then the length and address used directly.  This 
 	! gives a word length, so the class and type are placed as bytes in  the 
 	! rest  of that longword.  Class 0 is unspecified and hence no more than 
 	! the above information can be assumed. 
  
 	! Define the descriptor class codes! 
  
 LITERAL	DSC$K_CLASS_Z	= 0; 		! Unspecified 
 LITERAL	DSC$K_CLASS_S	= 1; 		! Scalar, String Descriptor 
 LITERAL	DSC$K_CLASS_D	= 2; 		! Dynamic String Descriptor 
 LITERAL	DSC$K_CLASS_V	= 3; 		! Varying String Descriptor 
 LITERAL	DSC$K_CLASS_A	= 4; 		! Array Descriptor (see C.10.5) 
 LITERAL	DSC$K_CLASS_P	= 5; 		! Procedure Descriptor 
 LITERAL	DSC$K_CLASS_PI	= 6; 		! Procedure Incarnation Descriptor 
 LITERAL	DSC$K_CLASS_J	= 7; 		! Label Descriptor 
 LITERAL	DSC$K_CLASS_JI	= 8; 		! Label Incarnation Descriptor 
  
 	! Descriptor classes 9-191 are RESERVED to DEC.  Classes 192 
 	! through 255 are RESERVED to CSS and customers. 
  
 !    C.10.5  Array Descriptor (DSC$K_CLASS_A) 
  
 !  An array descriptor consists of 3 contiguous blocks. The first block 
 !  contains  the  descriptor  prototype  information and is part of every 
 !  array descriptor.  The second and third blocks are optional.   If  the 
 !  third block is present then so is the second. 
  
 !   A complete array descriptor has the form: 
  
 !       +-------+-------+---------------+ 
 !       |   4   | DTYPE |    LENGTH     |  :Descriptor 
 !       +-------+-------+---------------+ 
 !       |            POINTER            | 
 !       +-------+-------+---------------+ 
 !       | DIMCT | AFLAGS|   Reserved    |          Block 1 - Prototype 
 !       +-------+-------+---------------+ 
 !       |            ARSIZE             | 
 !       +-------------------------------+ 
 ! 
 !       +-------------------------------+ 
 !       |              A0               | 
 !       +-------------------------------+ 
 !       |              M1               | 
 !       +-------------------------------+ 
 !       |              ...              |          Block 2 - Multipliers 
 !       +-------------------------------+ 
 !       |            M(n-1)             | 
 !       +-------------------------------+ 
 !       |              Mn               | 
 !       +-------------------------------+ 
 ! 
 !       +-------------------------------+ 
 !       |              L1               | 
 !       +-------------------------------+ 
 !       |              U1               | 
 !       +-------------------------------+ 
 !       |              ...              |          Block 3 - Bounds 
 !       +-------------------------------+ 
 !       |              Ln               | 
 !       +-------------------------------+ 
 !       |              Un               | 
 !       +-------------------------------+ 
 ! 
 ! 
 	!Define descriptor fields: 
  
 MACRO		DSC$W_LENGTH	= 0,0,16,0%; 	! A one-word field specifiec to the descriptor class! 
 			! typically a 16-bit (unsigned) length. 
  
 MACRO		DSC$B_DTYPE	= 2,0,8,0%; 	! A one-byte atomic data type code (see C.9) 
 			! Symbols used in this filed have form: DSC$K_DTYPE_t 
 			! where t is the data type mnemonic from above 
 			! and agrees with methodology manual. 
  
 MACRO		DSC$B_CLASS	= 3,0,8,0%; 	! A one-byte descriptor class code (see above). 
 			! Symbols used in this field have form: DSC$K_CLASS_f 
 			! where f is the argument form mnemonic from above 
 			! and agrees with the methodology manual. 
  
 MACRO		DSC$A_POINTER	= 4,0,32,0%; 	! A longword pointing to the first byte of the data 
 			! element described. 
  
 LITERAL	DSC$C_Z_BLN	= 8; 
 LITERAL	DSC$K_Z_BLN	= 8; 			! Block length in bytes for Z class desc. 
 LITERAL	DSC$C_S_BLN	= 8; 
 LITERAL	DSC$K_S_BLN	= 8; 			! Block length in bytes for S class descr. 
 LITERAL	DSC$C_D_BLN	= 8; 
 LITERAL	DSC$K_D_BLN	= 8; 			! Block length in bytes for D class descr. 
 LITERAL	DSC$C_P_BLN	= 8; 
 LITERAL	DSC$K_P_BLN	= 8; 			! Block length in bytes for P class descr. 
 LITERAL	DSC$C_J_BLN	= 8; 
 LITERAL	DSC$K_J_BLN	= 8; 			! Block length in bytes for J class descr. 
  
 !+ 
 ! End of common definitions for all descriptors. 
 !- 
  
 					! Mark end of common part 
  
 !+ 
 ! Varying type descriptor definitions 
 !- 
  
 MACRO		DSC$W_MAXLEN	= 8,0,16,0%; 	! An unsigned word specifying the 
 			! maximum length of the data item 
 			! (i.e., the space allocated) 
  
  
 !+ 
 ! Array Descriptor definitions 
 !- 
  
 					! go back to end of common descriptor definitions 
 MACRO		DSC$B_AFLAGS	= 10,0,8,0%; 	! Array flag bits. 
  
 			 
 						! reserved to Digital 
 MACRO		DSC$V_FL_COLUMN	= 10,5,1,0%; 	! If set, the elements of the array are 
 				! stored by columns (FORTRAN)>  Otherwise 
 				! the elements are stored by rows. 
  
 MACRO		DSC$V_FL_COEFF	= 10,6,1,0%; 	! If set, the multiplicative coefficients in 
 				! Block 2 are present. 
  
 MACRO		DSC$V_FL_BOUNDS	= 10,7,1,0%; 	! If set, the bounds information in Block 3 
 				! is present. 
 			
  
 MACRO		DSC$B_DIMCT	= 11,0,8,0%; 	! Number of dimensions 
  
 MACRO		DSC$L_ARSIZE	= 12,0,32,0%; 	! Total size of array (in bytes unless DTYPE is 
 			! EQUL DSC$K_DTYPE_V or DSC$K_DTYPE_P). 
  
 MACRO		DSC$A_A0	= 16,0,32,0%; 		! Address of element A(0,0,...,0). This 
 			! need not be within the actual array! it 
 			! is the same as DSC$A_POINTER for 0-origin 
 				! arrays. 
  
 MACRO		DSC$L_M1	= 20,0,32,0%; 		! Addressing coefficient M1 = U1-L1+1 
 MACRO		DSC$L_M2	= 24,0,32,0%; 		! Addressing coefficient M2 = U2-L2+1 
  
 !+ 
 ! Procedure Incarnation descriptor (DSC$K_CLASS_PI) and 
 ! Label Incarnation descriptor (DSC$K_CLASS_JI). 
 !- 
  
 					! go back to end of common descriptor definitions. 
 MACRO		DSC$A_FRAME	= 8,0,32,0%; 	! Address of frame 
  
 LITERAL	DSC$C_PI_BLN	= 12; 
 LITERAL	DSC$K_PI_BLN	= 12; 		! Block length in bytes for PI class descr. 
 LITERAL	DSC$C_JI_BLN	= 12; 
 LITERAL	DSC$K_JI_BLN	= 12; 			! block length in bytes for JI class descr. 
  
  
  
 	! end Descriptor definitions 
  
  
  
  
 !+ 
 ! Define SRM Hardware symbols 
 !- 
  
 !...$SRMDEF	
  
 LITERAL	SRM$K_INT_OVF_T	= 1; 			! Integer overflow trap code 
 LITERAL	SRM$K_INT_DIV_T	= 2; 			! Integer divide by zero trap code 
 LITERAL	SRM$K_FLT_OVF_T	= 3; 			! Floating overflow trap code 
 LITERAL	SRM$K_FLT_DIV_T	= 4; 			! Floating/decimal Divide by zero trap code 
 LITERAL	SRM$K_FLT_UND_T	= 5; 			! Floating Underflow trap code 
 LITERAL	SRM$K_DEC_OVF_T	= 6; 			! Decimal string overflow trap code 
 LITERAL	SRM$K_SUB_RNG_T	= 7; 			! Subscript range trap 
  
  
 		! End of SRM$ symbols 
  
  
  
  
 !+ 
 ! Define PSW bits (STARDEF.MDL has PSL bits) 
 !- 
  
 !...$PSWDEF	
  
 			 
 MACRO		PSW$V_C	= 0,0,1,0%; 	! carry 
 LITERAL	PSW$M_C	= 1^1 - 1^0; 
 MACRO		PSW$V_V	= 0,1,1,0%; 	! overflow 
 LITERAL	PSW$M_V	= 1^2 - 1^1; 
 MACRO		PSW$V_Z	= 0,2,1,0%; 	! zero 
 LITERAL	PSW$M_Z	= 1^3 - 1^2; 
 MACRO		PSW$V_N	= 0,3,1,0%; 	! negative 
 LITERAL	PSW$M_N	= 1^4 - 1^3; 
 MACRO		PSW$V_TBIT	= 0,4,1,0%; 	! trace trap enable 
 LITERAL	PSW$M_TBIT	= 1^5 - 1^4; 
 MACRO		PSW$V_IV	= 0,5,1,0%; 	! integer overflow enable 
 LITERAL	PSW$M_IV	= 1^6 - 1^5; 
 MACRO		PSW$V_FU	= 0,6,1,0%; 	! floating underflow enable 
 LITERAL	PSW$M_FU	= 1^7 - 1^6; 
 MACRO		PSW$V_DV	= 0,7,1,0%; 	! decimal overflow enable 
 LITERAL	PSW$M_DV	= 1^8 - 1^7; 
 			
 		! End of PSW$ symbols 
  
  
  
  
  
 !+ 
 ! Define stack frame offsets as a separate structure SF$ 
 !- 
  
 !...$SFDEF	
  
 MACRO		SF$A_HANDLER	= 0,0,32,0%; 		! Adr. of handler or 0 if no handler 
 MACRO		SF$W_SAVE_PSW	= 4,0,16,0%; 		! saved PSW 
 			 
 MACRO		SF$V_C	= 4,0,1,0%; 	! carry 
 LITERAL	SF$M_C	= 1^1 - 1^0; 
 MACRO		SF$V_V	= 4,1,1,0%; 	! overflow 
 LITERAL	SF$M_V	= 1^2 - 1^1; 
 MACRO		SF$V_Z	= 4,2,1,0%; 	! zero 
 LITERAL	SF$M_Z	= 1^3 - 1^2; 
 MACRO		SF$V_N	= 4,3,1,0%; 	! negative 
 LITERAL	SF$M_N	= 1^4 - 1^3; 
 MACRO		SF$V_TBIT	= 4,4,1,0%; 	! trace trap enable 
 LITERAL	SF$M_TBIT	= 1^5 - 1^4; 
 MACRO		SF$V_IV	= 4,5,1,0%; 	! integer overflow enable 
 LITERAL	SF$M_IV	= 1^6 - 1^5; 
 MACRO		SF$V_FU	= 4,6,1,0%; 	! floating underflow enable 
 LITERAL	SF$M_FU	= 1^7 - 1^6; 
 MACRO		SF$V_DV	= 4,7,1,0%; 	! decimal overflow enable 
 LITERAL	SF$M_DV	= 1^8 - 1^7; 
 			
 MACRO		SF$W_SAVE_MASK	= 6,0,16,0%; 		! saved register mask plus flags 
 						! define each field 
 MACRO		SF$V_SAVE_MASK	= 6,0,12,0%; 	! register save mask 
 						! MBZ 
 MACRO		SF$V_CALLS	= 6,13,1,0%; 		! 1 if CALLS 
 MACRO		SF$V_STACKOFFS	= 6,14,2,0%; 	! SP offset 
 			
 MACRO		SF$L_SAVE_AP	= 8,0,32,0%; 		! saved AP 
 MACRO		SF$L_SAVE_FP	= 12,0,32,0%; 		! saved FP 
 MACRO		SF$L_SAVE_PC	= 16,0,32,0%; 		! saved PC 
 MACRO		SF$L_SAVE_REGS	= 20,0,32,0%; 		! first register saved is saved here 
  
 		! End of SF$ symbols 
 !+ 
 ! OPERATOR COMMUNICATIONS MESSAGE TYPES AND VALUES 
 !- 
 !...$OPCDEF	
  
 MACRO		OPC$B_MS_TYPE	= 0,0,8,0%; 		! MESSAGE TYPE 
 MACRO		OPC$B_MS_TARGET	= 1,0,8,0%; 		! MESSAGE TARGET 
 MACRO		OPC$B_MS_ENAB	= 1,0,8,0%; 		! MESSAGE ENABLES 
 MACRO		OPC$W_MS_STATUS	= 2,0,16,0%; 		! MESSAGE STATUS 
 MACRO		OPC$L_MS_RPLYID	= 4,0,32,0%; 		! REPLY ID 
 MACRO		OPC$L_MS_MASK	= 4,0,32,0%; 		! MESSAGE MASK 
 MACRO		OPC$L_MS_RQSTID	= 4,0,32,0%; 		! REQUEST ID 
 MACRO		OPC$L_MS_TEXT	= 8,0,32,0%; 		! MESSAGE TEXT 
 MACRO		OPC$W_MS_OUNIT	= 8,0,16,0%; 		! OPERATOR UNIT NUMBER 
 MACRO		OPC$T_MS_ONAME	= 10,0,8,0%; 		! OPERATOR NAME 
 MACRO		OPC$L_MS_OTEXT	= 26,0,0,0%; 		! OPERATOR TEXT 
 LITERAL	OPC$S_MS_OTEXT	= 128; 
 MACRO		OPC$L_MS_MAXSZ	= 154,0,32,0%; 		! MESSAGE MAX SIZE 
  
 LITERAL	
 $EQULST (OPC$_,GBL,1,1 			! OPERATOR MESSAGE TYPES 
 	,(RQ_TERME,) 			! ENABLE TERMINAL 
 	,(RQ_LOGI,) 				! INITIALIZE THE LOG 
 	,(RQ_RQST,) 				! OPERATOR REQUEST 
 	,(RQ_REPLY,) 			! OPERATOR REPLY 
 	,(RQ_CANCEL,) 			! CANCEL REQUEST 
 	,(RQ_STATUS,) 			! REQUEST OPERATOR STATUS 
 	); 
 							! OPERATOR NAMES 
 MACRO		OPC$V_NM_CENTRL	= 154,0,1,0%; 		! 
 LITERAL	OPC$M_NM_CENTRL	= 1^1 - 1^0; 
 MACRO		OPC$V_NM_PRINT	= 154,1,1,0%;  
 LITERAL	OPC$M_NM_PRINT	= 1^2 - 1^1; 
 MACRO		OPC$V_NM_TAPES	= 154,2,1,0%;  
 LITERAL	OPC$M_NM_TAPES	= 1^3 - 1^2; 
 MACRO		OPC$V_NM_DISKS	= 154,3,1,0%;  
 LITERAL	OPC$M_NM_DISKS	= 1^4 - 1^3; 
 MACRO		OPC$V_NM_DEVICE	= 154,4,1,0%;  
 LITERAL	OPC$M_NM_DEVICE	= 1^5 - 1^4; 
 MACRO		OPC$V_NM_CARDS	= 154,5,1,0%;  
 LITERAL	OPC$M_NM_CARDS	= 1^6 - 1^5; 
 MACRO		OPC$V_NM_NTWORK	= 154,6,1,0%;  
 LITERAL	OPC$M_NM_NTWORK	= 1^7 - 1^6; 
 				 
 MACRO		OPC$V_NM_OPER1	= 154,12,1,0%;  
 LITERAL	OPC$M_NM_OPER1	= 1^13 - 1^12; 
 MACRO		OPC$V_NM_OPER2	= 154,13,1,0%;  
 LITERAL	OPC$M_NM_OPER2	= 1^14 - 1^13; 
 MACRO		OPC$V_NM_OPER3	= 154,14,1,0%;  
 LITERAL	OPC$M_NM_OPER3	= 1^15 - 1^14; 
 MACRO		OPC$V_NM_OPER4	= 154,15,1,0%;  
 LITERAL	OPC$M_NM_OPER4	= 1^16 - 1^15; 
 MACRO		OPC$V_NM_OPER5	= 154,16,1,0%;  
 LITERAL	OPC$M_NM_OPER5	= 1^17 - 1^16; 
 MACRO		OPC$V_NM_OPER6	= 154,17,1,0%;  
 LITERAL	OPC$M_NM_OPER6	= 1^18 - 1^17; 
 MACRO		OPC$V_NM_OPER7	= 154,18,1,0%;  
 LITERAL	OPC$M_NM_OPER7	= 1^19 - 1^18; 
 MACRO		OPC$V_NM_OPER8	= 154,19,1,0%;  
 LITERAL	OPC$M_NM_OPER8	= 1^20 - 1^19; 
 MACRO		OPC$V_NM_OPER9	= 154,20,1,0%;  
 LITERAL	OPC$M_NM_OPER9	= 1^21 - 1^20; 
 MACRO		OPC$V_NM_OPER10	= 154,21,1,0%;  
 LITERAL	OPC$M_NM_OPER10	= 1^22 - 1^21; 
 MACRO		OPC$V_NM_OPER11	= 154,22,1,0%;  
 LITERAL	OPC$M_NM_OPER11	= 1^23 - 1^22; 
 MACRO		OPC$V_NM_OPER12	= 154,23,1,0%;  
 LITERAL	OPC$M_NM_OPER12	= 1^24 - 1^23; 
 			
 LITERAL	
 $EQULST (OPC$_,GBL,0,1 			! 
 	,(TERMENAB,360449) 			! MSG <terminal enabled> 
 	,(LOGINIT,360457) 			! MSG <logfile initialized> 
 	,(TERMDSBL,360465) 			! MSG <terminal disabled> 
 	,(RQSTABORT,360476) 		! MSG <request aborted> 
 	,(RQSTPEND,360481) 			! MSG <request pending> 
 	,(RQSTCMPLTE,360489) 		! MSG <request complete> 
 	,(LOGFAIL,360500) 			! MSG <failed to initialize logfile> 
 	,(TERMFAIL,360508) 			! MSG <failed to enable terminal> 
 	,(NOSUCHRQST,360516) 		! MSG <no such request> 
 	,(DEVOFFLINE,360524) 		! MSG <device is offline> 
 	,(DEVONLINE,360532) 	 	! MSG <device online> 
 	,(NOCLI,360540) 			! MSG <no command interpreter> 
 	,(NOPERATOR,360545) 		! MSG <no operator coverage> 
 	,(UNKNOPR,360556) 			! MSG <unknown operator> 
 	,(DEVNOTERM,360564) 	 	! MSG <illegal source operator device> 
 	,(ILLRQST,360572) 			! MSG <illegal operator request> 
 	,(RQSTCAN,360580) 			! MSG <request was canceled> 
 	,(OPRNOTIF,360585) 			! MSG FAOCNT=1,<operator notified, waiting.. !%T> 
 	,(OPREPLY,360593) 			! MSG FAOCNT=2,<!AD> 
 	,(LOGTIME,360601) 			! MSG <logfile time stamp> 
 	,(LOGCLOS,360612) 			! MSG <logfile closed> 
 	); 

  
 ! 
 ! THIS FILE DEFINES THE ERROR MESSAGES FOR THE RSX AME 
 ! 
 !...$RSXMSGDEF			! SUBSYSTEM = 6 
 LITERAL	
 $EQULST (RSX$_,GBL,427584,8 		! EXIT WITH STATUS 
 	,(EXITSTATUS,) 		! MSG <RSX-11M exit with status> 
 	,(VERIFYCMD,) 		! MSG FAOCNT=2, <  MCR!AD> 
 	); 
 LITERAL	
 $EQULST (RSX$_,GBL,426786,8 		! WARNING CODES 
 	,(NOSUCHDEV,) 		! MSG FAOCNT=4, <TKB-assigned device not found, !AD!UW:, lun=!UB> 
 	,(PMD,) 			! MSG FAOCNT=2, <post-mortem dump, !AD> 
 	,(NOPMD,) 			! MSG FAOCNT=2, <post-mortem dump failure, !AD> 
 	); 
 LITERAL	
 $EQULST (RSX$_,GBL,425988,8 		! ERROR STATUS CODES 
 	,(RESERVED,) 		! MSG <compatibility mode reserved instruction> 
 	,(BREAK,) 			! MSG <compatibility mode breakpoint trap> 
 	,(IOT,) 			! MSG <compatibility mode IOT> 
 	,(NONRSXEMT,) 		! MSG <non-RSX-11M  EMT execution> 
 	,(TRAP,) 			! MSG <compatibility mode TRAP execution> 
 	,(ILLINST,) 			! MSG <compatibility mode illegal instruction> 
 	,(ODDADDR,) 			! MSG <compatibility mode odd address> 
 	,(TBIT,) 			! MSG <compatibility mode T-bit> 
 	,(ACCVIO,) 			! MSG <compatibility mode access violation> 
 	,(BADSTACK,) 		! MSG <invalid compatibility mode stack pointer> 
 	,(INSFDYNMEM,) 		! MSG <insufficient virtual address space> 
 	,(EXTERNABRT,) 		! MSG <external abort> 
 	,(NOTSKIMG,) 		! MSG FAOCNT=2, <file is not RSX-11M task image, !AD> 
 	,(BADLIBREF,) 		! MSG FAOCNT=2, <invalid library/common reference, !AD> 
 	,(LIBNOTFND,) 		! MSG FAOCNT=2, <open failure on library/common file, !AD> 
 	,(LOADERROR,) 		! MSG FAOCNT=2, <image load error, !AD> 
 	,(IMAGETERM,) 		! MSG FAOCNT=2, <'!AC' terminated, !%D> 
 	,(REGMSG,) 			! MSG FAOCNT=3, <	!AC = !OW !XW> 
 	,(NOCOMM,) 			! MSG <unable to initialize process mailbox or common efn's> 
 	); 

