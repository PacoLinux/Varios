
; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 1
;
;	0001	MODULE WITURN (
;	0002			LANGUAGE (BLISS32),
;	0003			IDENT = 'B0008'
;	0004			) =
;	0005	BEGIN
;	0006	
;	0007	!
;	0008	! Copyright (c) 1977
;	0009	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0010	!
;	0011	! This software is furnished  under a license for use only on a single
;	0012	! computer  system and  may be  copied only with  the inclusion of the
;	0013	! above copyright notice.  This software, or any other copies thereof,
;	0014	! may not be provided or  otherwise made available to any other person
;	0015	! except for use on such system and to one who agrees to these license
;	0016	! terms.  Title to and  ownership of the  software  shall at all times
;	0017	! remain in DEC.
;	0018	!
;	0019	! The information in this software is subject to change without notice
;	0020	! and should  not be construed  as a commitment  by Digital  Equipment
;	0021	! Corporation.
;	0022	!
;	0023	! DEC assumes  no  responsibility  for  the use or  reliability of its
;	0024	! software on equipment which is not supplied by DEC.
;	0025	
;	0026	!++
;	0027	!
;	0028	! FACILITY:  F11ACP Structure Level 2
;	0029	!
;	0030	! ABSTRACT:
;	0031	!
;	0032	!	This module generates a window mapping the desired VBN from
;	0033	!	the supplied file header.
;	0034	!
;	0035	! ENVIRONMENT:
;	0036	!
;	0037	!	STARLET operating system, including privileged system services
;	0038	!	and internal exec routines.
;	0039	!
;	0040	!--
;	0041	!
;	0042	!
;	0043	! AUTHOR:  Andrew C. Goldstein,	CREATION DATE:  7-Dec-1976  14:38
;	0044	!
;	0045	! REVISION HISTORY:
;	0046	!
;	0047	!   Andrew C. Goldstein, 17-Mar-1977  16:53
;	0048	!   X0002 - Add system interlock while turning window
;	0049	!
;	0050	!   Andrew C. Goldstein, 26-Apr-1977  11:36
;	0051	!   X0003 - Move code to locked down PSECT
;	0052	!
;	0053	!   Andrew C. Goldstein, 21-Jul-1977  15:17
;	0054	!   X0004 - Add multi-header code
;	0055	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 1-1
;
;	0056	!   Andrew C. Goldstein, 18-Oct-1977  11:29
;	0057	!   X0005 - Remove interlocks for use in MOUNT
;	0058	!
;	0059	!   Andrew C. Goldstein, 21-Nov-1977  16:43
;	0060	!   X0006 - Modify for structure level 2
;	0061	!
;	0062	!   Andrew C. Goldstein, 9-Jan-1978  17:25
;	0063	!   B0007 - Fix edge condition of VBN 0 on first header
;	0064	!
;	0065	!   Andrew C. Goldstein, 4-May-78  21:36
;	0066	!   B0008 - Build window in private buffer
;	0067	!
;	0068	!**
;	0069	
;	0070	
;	0071	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0072	REQUIRE 'SRC$:FCPDEF.B32';
;	0421	
;	0422	
;	0423	!
;	0424	! Lock the code into the working set since this routine runs at raised IPL.
;	0425	!
;	0426	
;	0427	LOCK_CODE;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2
;
;	0428	GLOBAL ROUTINE TURN_WINDOW (WINDOW, HEADER, DESIRED_VBN, START_VBN) =
;	0429	
;	0430	!++
;	0431	!
;	0432	! FUNCTIONAL DESCRIPTION:
;	0433	!
;	0434	!	This routine scans the map area of the supplied file header
;	0435	!	and builds retrieval pointers in the window until
;	0436	!	(1) the entire header has been scanned, or
;	0437	!	(2) the first retrieval pointer in the window maps the desired VBN
;	0438	!
;	0439	! CALLING SEQUENCE:
;	0440	!	TURN_WINDOW (ARG1, ARG2, ARG3, ARG4)
;	0441	!
;	0442	! INPUT PARAMETERS:
;	0443	!	ARG1: address of window block or 0 if to be created
;	0444	!	ARG2: address of file header
;	0445	!	ARG3: desired VBN
;	0446	!	ARG4: starting VBN of file header
;	0447	!
;	0448	! IMPLICIT INPUTS:
;	0449	!	NONE
;	0450	!
;	0451	! OUTPUT PARAMETERS:
;	0452	!	updated window
;	0453	!
;	0454	! IMPLICIT OUTPUTS:
;	0455	!	NONE
;	0456	!
;	0457	! ROUTINE VALUE:
;	0458	!	address of created window
;	0459	!	or 1 if none created
;	0460	!
;	0461	! SIDE EFFECTS:
;	0462	!	NONE
;	0463	!
;	0464	!--
;	0465	
;	0466	BEGIN
;	0467	
;	0468	MAP
;	0469		WINDOW		: REF BBLOCK,	! pointer to window
;	0470		HEADER		: REF BBLOCK;	! pointer to file header
;	0471	
;	0472	LINKAGE
;	0473		L_MAP_POINTER	= JSB :
;	0474				  GLOBAL (COUNT = 6, LBN = 7, MAP_POINTER = 8);
;	0475	
;	0476	GLOBAL REGISTER
;	0477		COUNT		= 6,		! retrieval pointer count
;	0478		LBN		= 7,		! retrieval pointer start LBN
;	0479		MAP_POINTER	= 8 : REF BBLOCK; ! pointer to scan header map area
;	0480	
;	0481	LABEL
;	0482		MAP_BUILD;			! loop to build window map

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2-1
;
;	0483	
;	0484	LOCAL
;	0485		WINDOW_BUFFER	: BBLOCK [MAX_WINDOW*6], ! buffer in which to build window
;	0486		POINTER_COUNT,			! count of pointers in window
;	0487		WINDOW_SIZE,			! size of window in pointers
;	0488		BASE_VBN,			! starting VBN in window
;	0489		VBN,				! VBN in scanning window
;	0490		W_POINTER	: REF BBLOCK,	! pointer to scan window
;	0491		NEW_WINDOW	: REF BBLOCK;	! address of newly allocated window
;	0492	
;	0493	MACRO
;	0494		WINDOW_MAP	= (.WINDOW+WCB$C_MAP)%;	!start of window map area
;	0495	
;	0496	EXTERNAL
;	0497		PMS$GL_TURN	: ADDRESSING_MODE (ABSOLUTE);
;	0498						! system count of window turns
;	0499	
;	0500	EXTERNAL ROUTINE
;	0501		ALLOCATE;			! allocate system dynamic memory
;	0502	
;	0503	EXTERNAL ROUTINE
;	0504		GET_MAP_POINTER	: L_MAP_POINTER; ! get value of next header map pointer
;	0505	
;	0506	! If we are being called with an existing window, copy it into the buffer
;	0507	! and pick up the window parameters. Otherwise, set up for creating a
;	0508	! maximal size window.
;	0509	!
;	0510	
;	0511	IF .WINDOW NEQ 0
;	0512	THEN
;	0513	    BEGIN
;	0514	    WINDOW_SIZE = (.WINDOW[WCB$W_SIZE] - WCB$C_LENGTH) / 6;
;	0515	    POINTER_COUNT = .WINDOW[WCB$W_NMAP];
;	0516	    BASE_VBN = .WINDOW[WCB$L_STVBN];
;	0517	    CH$MOVE (.POINTER_COUNT*6, WINDOW_MAP, WINDOW_BUFFER);
;	0518	    END
;	0519	ELSE
;	0520	    BEGIN
;	0521	    BASE_VBN = -1;
;	0522	    WINDOW_SIZE = MAX_WINDOW;
;	0523	    END;
;	0524	
;	0525	! Scan the window looking for the starting VBN of the header. If it is
;	0526	! contained within the window, truncate the window so that it maps exactly
;	0527	! up to the start of the header. If the starting VBN is not contained in the
;	0528	! window, the entire window must be discarded. However, if the desired VBN
;	0529	! precedes the header start VBN, we do nothing since the window is already
;	0530	! best effort.
;	0531	!
;	0532	
;	0533	PMS$GL_TURN = .PMS$GL_TURN + 1;			! count the operation
;	0534	W_POINTER = WINDOW_BUFFER;			! point to first retrieval pointer
;	0535	VBN = .BASE_VBN;				! get starting VBN of window
;	0536	
;	0537	IF .START_VBN LEQU .VBN

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2-2
;
;	0538	OR
;	0539	    BEGIN
;	0540	    INCR J FROM 1 TO .POINTER_COUNT
;	0541	    DO
;	0542		BEGIN
;	0543		VBN = .VBN + .W_POINTER[WCB$W_COUNT];	! VBN at end of this pointer
;	0544		W_POINTER = .W_POINTER + 6;
;	0545		IF .START_VBN EQL .VBN
;	0546		THEN
;	0547		    BEGIN
;	0548		    POINTER_COUNT = .J;		! truncate the window
;	0549		    EXITLOOP 0;
;	0550		    END;
;	0551		END
;	0552	    END
;	0553	
;	0554	THEN						! header VBN is not in window
;	0555	    BEGIN
;	0556	    IF .DESIRED_VBN LSSU .START_VBN
;	0557	    AND .START_VBN GTRU 1
;	0558	    THEN
;	0559		RETURN 1				! leave it alone
;	0560	    ELSE
;	0561		BEGIN
;	0562		POINTER_COUNT = 0;			! flush the window
;	0563		BASE_VBN = .START_VBN;
;	0564		W_POINTER = WINDOW_BUFFER;			! point to first pointer
;	0565		END;
;	0566	    END;
;	0567	
;	0568	! The window is now suitably initialized. Set up necessary pointers.
;	0569	! Now scan the map area, extracting retrieval pointers.
;	0570	!
;	0571	
;	0572	MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;	! point to map area
;	0573	
;	0574	MAP_BUILD: BEGIN
;	0575	UNTIL .MAP_POINTER GEQA .HEADER + (.HEADER[FH2$B_MPOFFSET] + .HEADER[FH2$B_MAP_INUSE]) * 2
;	0576	DO
;	0577	    BEGIN
;	0578	
;	0579	    GET_MAP_POINTER ();
;	0580	
;	0581	! Build new retrieval pointers, using as many as needed to run out the
;	0582	! count. If the window is full, shuffle the entries up by one. If this
;	0583	! would cause the pointer mapping the  desired VBN to fall off the top,
;	0584	! we are done.
;	0585	!
;	0586	
;	0587	    IF .COUNT NEQ 0
;	0588	    THEN
;	0589		WHILE 1 DO
;	0590		BEGIN
;	0591		IF .POINTER_COUNT GEQU .WINDOW_SIZE
;	0592		THEN

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2-3
;
;	0593		    BEGIN
;	0594		    IF .BASE_VBN + .WINDOW_BUFFER[WCB$W_COUNT] GTRU .DESIRED_VBN
;	0595		    THEN LEAVE MAP_BUILD;
;	0596	
;	0597		    POINTER_COUNT = .POINTER_COUNT - 1;
;	0598		    BASE_VBN = .BASE_VBN + .WINDOW_BUFFER[WCB$W_COUNT];
;	0599		    CH$MOVE (.POINTER_COUNT*6, WINDOW_BUFFER+6, WINDOW_BUFFER);
;	0600		    W_POINTER = .W_POINTER - 6;
;	0601		    END;
;	0602	
;	0603	! Finally build the pointer and count it.
;	0604	!
;	0605	
;	0606		W_POINTER[WCB$W_COUNT] = MINU (.COUNT, 65535);
;	0607		W_POINTER[WCB$L_LBN] = .LBN;
;	0608		W_POINTER = .W_POINTER + 6;
;	0609		POINTER_COUNT = .POINTER_COUNT + 1;
;	0610		LBN = .LBN + 65535;
;	0611		COUNT = .COUNT - MINU (.COUNT, 65535);
;	0612		IF .COUNT EQL 0 THEN EXITLOOP;
;	0613		END;
;	0614	
;	0615	    END;					! end of header scan loop
;	0616	END;						! end of block MAP_BUILD
;	0617	
;	0618	! Having built a new window in the buffer, update the real one. If none exists,
;	0619	! create one as big as needed. Then interlock the system data base and copy
;	0620	! the buffer into the window.
;	0621	!
;	0622	
;	0623	NEW_WINDOW = .WINDOW;
;	0624	IF .NEW_WINDOW EQL 0
;	0625	THEN
;	0626	    NEW_WINDOW = ALLOCATE ((MAXU (.POINTER_COUNT, MIN_WINDOW)) * 6 + WCB$C_LENGTH, WCB_TYPE);
;	0627	
;	0628	SET_IPL (IPL$_SYNCH);
;	0629	NEW_WINDOW[WCB$W_NMAP] = .POINTER_COUNT;
;	0630	NEW_WINDOW[WCB$L_STVBN] = .BASE_VBN;
;	0631	CH$MOVE (.POINTER_COUNT*6, WINDOW_BUFFER, .NEW_WINDOW+WCB$C_MAP);
;	0632	SET_IPL (0);					! unlock the data base
;	0633	
;	0634	IF .WINDOW EQL 0
;	0635	THEN RETURN .NEW_WINDOW
;	0636	ELSE RETURN 1;
;	0637	
;	0638	END;						! end of routine TURN_WINDOW


							    .TITLE  WITURN
							    .IDENT  \B0008\

							    .EXTRN  PMS$GL_TURN, ALLOCATE, GET_MAP_POINTER

							    .PSECT  $LOCKEDC1$,NOWRT,2


; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2-4
;
					 0FFC 00000 	    .ENTRY  TURN_WINDOW, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11	      ; 0428
		         5E 	FE10   CE  9E 00002 	    MOVAB   -496(SP), SP					      ;
		         5A 	  04   AC  D0 00007 	    MOVL    WINDOW, R10						      ; 0511
				       21  13 0000B 	    BEQL    1$							      ;
		         50 	  08   AA  3C 0000D 	    MOVZWL  8(R10), R0						      ; 0514
		         50 	       24  C2 00011 	    SUBL2   #36, R0						      ;
      0C   AE	         50 	       06  C7 00014 	    DIVL3   #6, R0, WINDOW_SIZE					      ;
		         6E 	  16   AA  3C 00019 	    MOVZWL  22(R10), POINTER_COUNT				      ; 0515
		    08   AE	  20   AA  D0 0001D 	    MOVL    32(R10), BASE_VBN					      ; 0516
	   50 	         6E 	       06  C5 00022 	    MULL3   #6, POINTER_COUNT, R0				      ; 0517
      10   AE	    24   AA	       50  28 00026 	    MOVC3   R0, 36(R10), WINDOW_BUFFER				      ;
				       09  11 0002C 	    BRB     2$							      ; 0511
		    08   AE	       01  CE 0002E 1$:     MNEGL   #1, BASE_VBN					      ; 0521
		    0C   AE	  50   8F  9A 00032 	    MOVZBL  #80, WINDOW_SIZE					      ; 0522
			    00000000G  9F  D6 00037 2$:     INCL    @#PMS$GL_TURN					      ; 0533
		    04   AE	  10   AE  9E 0003D 	    MOVAB   WINDOW_BUFFER, W_POINTER				      ; 0534
		         51 	  08   AE  D0 00042 	    MOVL    BASE_VBN, VBN					      ; 0535
		         50 	  10   AC  D0 00046 	    MOVL    START_VBN, R0					      ; 0537
		         51 	       50  D1 0004A 	    CMPL    R0, VBN						      ;
				       20  1B 0004D 	    BLEQU   5$							      ;
		         53 	       6E  D0 0004F 	    MOVL    POINTER_COUNT, R3					      ; 0540
				       52  D4 00052 	    CLRL    J							      ;
				       15  11 00054 	    BRB     4$							      ;
		         54 	  04   BE  3C 00056 3$:     MOVZWL  @W_POINTER, R4					      ; 0543
		         51 	       54  C0 0005A 	    ADDL2   R4, VBN						      ;
		    04   AE	       06  C0 0005D 	    ADDL2   #6, W_POINTER					      ; 0544
		         51 	       50  D1 00061 	    CMPL    R0, VBN						      ; 0545
				       05  12 00064 	    BNEQ    4$							      ;
		         6E 	       52  D0 00066 	    MOVL    J, POINTER_COUNT					      ; 0548
				       1D  11 00069 	    BRB     7$							      ; 0549
	   E7 	         52 	       53  F3 0006B 4$:     AOBLEQ  R3, J, 3$						      ; 0540
		         50 	  0C   AC  D1 0006F 5$:     CMPL    DESIRED_VBN, R0					      ; 0556
				       08  1E 00073 	    BGEQU   6$							      ;
		         01 	       50  D1 00075 	    CMPL    R0, #1						      ; 0557
				       03  1B 00078 	    BLEQU   6$							      ;
				     00CD  31 0007A 	    BRW     15$							      ;
				       6E  D4 0007D 6$:     CLRL    POINTER_COUNT					      ; 0562
		    08   AE	       50  D0 0007F 	    MOVL    R0, BASE_VBN					      ; 0563
		    04   AE	  10   AE  9E 00083 	    MOVAB   WINDOW_BUFFER, W_POINTER				      ; 0564
		         59 	  08   AC  D0 00088 7$:     MOVL    HEADER, R9						      ; 0572
		         5B 	  01   A9  9A 0008C 	    MOVZBL  1(R9), R11						      ;
		         58 	     694B  3E 00090 	    MOVAW   (R9)[R11], MAP_POINTER				      ;
		         50 	  3A   A9  9A 00094 8$:     MOVZBL  58(R9), R0						      ; 0575
		         50 	       5B  C0 00098 	    ADDL2   R11, R0						      ;
		         50 	     6940  3E 0009B 	    MOVAW   (R9)[R0], R0					      ;
		         50 	       58  D1 0009F 	    CMPL    MAP_POINTER, R0					      ;
				       64  1E 000A2 	    BGEQU   12$							      ;
				     0000G 30 000A4 	    BSBW    GET_MAP_POINTER					      ; 0579
				       56  D5 000A7 	    TSTL    COUNT						      ; 0587
				       E9  13 000A9 	    BEQL    8$							      ;
		    0C   AE	       6E  D1 000AB 9$:     CMPL    POINTER_COUNT, WINDOW_SIZE				      ; 0591
				       26  1F 000AF 	    BLSSU   10$							      ;
		         50 	  10   AE  3C 000B1 	    MOVZWL  WINDOW_BUFFER, R0					      ; 0594
		         50 	  08   AE  C0 000B5 	    ADDL2   BASE_VBN, R0					      ;
		    0C   AC	       50  D1 000B9 	    CMPL    R0, DESIRED_VBN					      ;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2-5
;
				       49  1A 000BD 	    BGTRU   12$							      ;
				       6E  D7 000BF 	    DECL    POINTER_COUNT					      ; 0597
		         50 	  10   AE  3C 000C1 	    MOVZWL  WINDOW_BUFFER, R0					      ; 0598
		    08   AE	       50  C0 000C5 	    ADDL2   R0, BASE_VBN					      ;
	   50 	         6E 	       06  C5 000C9 	    MULL3   #6, POINTER_COUNT, R0				      ; 0599
      10   AE	    16   AE	       50  28 000CD 	    MOVC3   R0, WINDOW_BUFFER+6, WINDOW_BUFFER			      ;
		    04   AE	       06  C2 000D3 	    SUBL2   #6, W_POINTER					      ; 0600
		         50 	       56  D0 000D7 10$:    MOVL    COUNT, R0						      ; 0606
	      0000FFFF   8F	       50  D1 000DA 	    CMPL    R0, #65535						      ;
				       05  1B 000E1 	    BLEQU   11$							      ;
		         50 	FFFF   8F  3C 000E3 	    MOVZWL  #65535, R0						      ;
		    04   BE	       50  B0 000E8 11$:    MOVW    R0, @W_POINTER					      ;
	   51 	    04   AE	       02  C1 000EC 	    ADDL3   #2, W_POINTER, R1					      ; 0607
		         61 	       57  D0 000F1 	    MOVL    LBN, (R1)						      ;
		    04   AE	       06  C0 000F4 	    ADDL2   #6, W_POINTER					      ; 0608
				       6E  D6 000F8 	    INCL    POINTER_COUNT					      ; 0609
		         57 0000FFFF   E7  9E 000FA 	    MOVAB   65535(R7), LBN					      ; 0610
		         56 	       50  C2 00101 	    SUBL2   R0, COUNT						      ; 0611
				       A5  12 00104 	    BNEQ    9$							      ; 0612
				       8C  11 00106 	    BRB     8$							      ;
		         56 	       5A  D0 00108 12$:    MOVL    R10, NEW_WINDOW					      ; 0623
				       1C  12 0010B 	    BNEQ    14$							      ; 0624
				       01  DD 0010D 	    PUSHL   #1							      ; 0626
		         50 	  04   AE  D0 0010F 	    MOVL    POINTER_COUNT, R0					      ;
		         01 	       50  D1 00113 	    CMPL    R0, #1						      ;
				       03  1E 00116 	    BGEQU   13$							      ;
		         50 	       01  D0 00118 	    MOVL    #1, R0						      ;
		         50 	       06  C4 0011B 13$:    MULL2   #6, R0						      ;
				  24   A0  9F 0011E 	    PUSHAB  36(R0)						      ;
		  0000G  CF	       02  FB 00121 	    CALLS   #2, ALLOCATE					      ;
		         56 	       50  D0 00126 	    MOVL    R0, NEW_WINDOW					      ;
		         12 	       07  DA 00129 14$:    MTPR    #7, #18						      ; 0628
		    16   A6	       6E  B0 0012C 	    MOVW    POINTER_COUNT, 22(NEW_WINDOW)			      ; 0629
		    20   A6	  08   AE  D0 00130 	    MOVL    BASE_VBN, 32(NEW_WINDOW)				      ; 0630
	   50 	         6E 	       06  C5 00135 	    MULL3   #6, POINTER_COUNT, R0				      ; 0631
      24   A6	    10   AE	       50  28 00139 	    MOVC3   R0, WINDOW_BUFFER, 36(NEW_WINDOW)			      ;
		         12 	       00  DA 0013F 	    MTPR    #0, #18						      ; 0632
				       5A  D5 00142 	    TSTL    R10							      ; 0634
				       04  12 00144 	    BNEQ    15$							      ;
		         50 	       56  D0 00146 	    MOVL    NEW_WINDOW, R0					      ; 0635
					   04 00149 	    RET     							      ;
		         50 	       01  D0 0014A 15$:    MOVL    #1, R0						      ; 0636
					   04 0014D 	    RET     							      ; 0428

; Routine Size:  334 bytes


;	0639	
;	0640	END
;	0641	ELUDOM






; Bliss-32 10.1-416	Monday 21-AUG-1978 23:23:13	DBB3:[F11B.SRC]WITURN.B32;11					Page 2-6
;

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  $LOCKEDC1$     	   334  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        17         0       231





; Size:		334 code + 0 data bytes
; Run Time:	00:09.1
; Elapsed Time:	00:19.7
; Memory Used:	316 pages
; Compilation Complete
