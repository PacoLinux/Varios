
; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 1
;
;	0001	MODULE CREHDR (
;	0002			LANGUAGE (BLISS32),
;	0003			IDENT = 'B0008'
;	0004			) =
;	0005	BEGIN
;	0006	
;	0007	!
;	0008	! Copyright (c) 1977
;	0009	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0010	!
;	0011	! This software is furnished  under a license for use only on a single
;	0012	! computer  system and  may be  copied only with  the inclusion of the
;	0013	! above copyright notice.  This software, or any other copies thereof,
;	0014	! may not be provided or  otherwise made available to any other person
;	0015	! except for use on such system and to one who agrees to these license
;	0016	! terms.  Title to and  ownership of the  software  shall at all times
;	0017	! remain in DEC.
;	0018	!
;	0019	! The information in this software is subject to change without notice
;	0020	! and should  not be construed  as a commitment  by Digital  Equipment
;	0021	! Corporation.
;	0022	!
;	0023	! DEC assumes  no  responsibility  for  the use or  reliability of its
;	0024	! software on equipment which is not supplied by DEC.
;	0025	
;	0026	!++
;	0027	!
;	0028	! FACILITY:  F11ACP Structure Level 2
;	0029	!
;	0030	! ABSTRACT:
;	0031	!
;	0032	!	This routine creates a new file ID by allocating a file number from the
;	0033	!	index file bitmap. It returns an empty file header, verified for use.
;	0034	!
;	0035	! ENVIRONMENT:
;	0036	!
;	0037	!	STARLET operating system, including privileged system services
;	0038	!	and internal exec routines.
;	0039	!
;	0040	!--
;	0041	!
;	0042	!
;	0043	! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  28-Mar-1977  13:49
;	0044	!
;	0045	! REVISION HISTORY:
;	0046	!
;	0047	!   Andrew C. Goldstein, 4-Apr-1977  16:41
;	0048	!   X0002 - Rename UPDATE_IBVBN for external use
;	0049	!
;	0050	!   Andrew C. Goldstein, 14-Apr-1977  13:53
;	0051	!   X0003 - Add index file extension logic
;	0052	!
;	0053	!   Andrew C. Goldstein, 12-Dec-1977  14:47
;	0054	!   X0004 - Rename from CREATE_FID, add header creation logic
;	0055	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 1-1
;
;	0056	!   Andrew C. Goldstein, 13-Dec-1977  15:45
;	0057	!   X0005 - Add header block error recovery
;	0058	!
;	0059	!   Andrew C. Goldstein, 20-Dec-1977  18:46
;	0060	!   X0006 - Modify for structure level 2
;	0061	!
;	0062	!   Andrew C. Goldstein, 2-Feb-1978  21:20
;	0063	!   B0007 - Handle index file EOF recovery from MOUNT
;	0064	!
;	0065	!   Andrew C. Goldstein, 17-Feb-1978  14:58
;	0066	!   B0008 - Use new bug check
;	0067	!
;	0068	!**
;	0069	
;	0070	
;	0071	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0072	REQUIRE 'SRC$:FCPDEF.B32';
;	0421	
;	0422	
;	0423	FORWARD ROUTINE
;	0424		CREATE_HEADER,			! create file ID and header
;	0425		UPDATE_IBVBN	: NOVALUE,	! update index bitmap scan start
;	0426		BUMP_IDXEOF,			! increment index file EOF
;	0427		READ_NEW_HEADER,		! read new file header block
;	0428		HANDLER;			! local condition handler

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2
;
;	0429	GLOBAL ROUTINE CREATE_HEADER =
;	0430	
;	0431	!++
;	0432	!
;	0433	! FUNCTIONAL DESCRIPTION:
;	0434	!
;	0435	!	This routine creates a new file ID by searching the volume's index
;	0436	!	file bitmap for the first free file number. It also checks that a header
;	0437	!	for the file number is present in the index file. It reads the old
;	0438	!	header and establishes the file sequence number for the new one.
;	0439	!
;	0440	! CALLING SEQUENCE:
;	0441	!	CREATE_HEADER ()
;	0442	!
;	0443	! INPUT PARAMETERS:
;	0444	!	NONE
;	0445	!
;	0446	! IMPLICIT INPUTS:
;	0447	!	CURRENT_VCB: address of volume's VCB
;	0448	!
;	0449	! OUTPUT PARAMETERS:
;	0450	!	NONE
;	0451	!
;	0452	! IMPLICIT OUTPUTS:
;	0453	!	NONE
;	0454	!
;	0455	! ROUTINE VALUE:
;	0456	!	address of buffer containing new header
;	0457	!
;	0458	! SIDE EFFECTS:
;	0459	!	VCB and index file bitmap altered, header block read
;	0460	!
;	0461	!--
;	0462	
;	0463	BEGIN
;	0464	
;	0465	LOCAL
;	0466		VCB		: REF BBLOCK,	! local copy of VCB address
;	0467		VBN,				! relative block number in bitmap
;	0468		BUFFER		: REF BITVECTOR, ! address of index file bitmap buffer
;	0469		ADDRESS		: REF BITVECTOR, ! address of byte in buffer
;	0470		BITPOS,				! bit positon of free bit within byte
;	0471		FILE_NUMBER,			! file number allocated
;	0472		IDX_FCB		: REF BBLOCK,	! FCB of index file
;	0473		NO_READ,			! flag to not read old file header
;	0474		LBN,				! LBN of new file header
;	0475		HEADER		: REF BBLOCK,	! address of header buffer
;	0476		FILE_ID		: BBLOCK [FID$C_LENGTH], ! new file ID of header
;	0477		STATUS,				! value of CHECK_HEADER call
;	0478		SAVE_STATUS;			! save I/O status during CHECK_HEADER call
;	0479	
;	0480	EXTERNAL
;	0481		CURRENT_VCB	: REF BBLOCK,	! VCB of volume
;	0482		NEW_FID,			! pending file ID
;	0483		HEADER_LBN,			! LBN of created file header

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2-1
;
;	0484		USER_STATUS	: VECTOR;	! I/O status block of user
;	0485	
;	0486	EXTERNAL ROUTINE
;	0487		READ_BLOCK,			! read block from disk
;	0488		WRITE_BLOCK,			! write block to disk
;	0489		EXTEND_INDEX,			! extend the index file
;	0490		MAP_VBN,			! map virtual to logical block
;	0491		READ_HEADER,			! read file header
;	0492		CHECKSUM,			! compute file header checksum
;	0493		WRITE_HEADER,			! write current file header
;	0494		RESET_LBN,			! change backing LBN of buffer
;	0495		INVALIDATE,			! invalidate a buffer
;	0496		CREATE_BLOCK,			! materialize a block buffer
;	0497		CHECK_HEADER2;			! verify file header
;	0498	
;	0499	
;	0500	! The outer loop performs retries if blocks in the index file are bad or
;	0501	! are valid file headers. A block containing a valid file header is never
;	0502	! used to create a new file; it is simply left marked in use for recovery.
;	0503	! Bad header blocks are simply left marked in use in the index file bitmap;
;	0504	! they will show up in a verify but are otherwise harmless.
;	0505	!
;	0506	
;	0507	VCB = .CURRENT_VCB;
;	0508	WHILE 1 DO
;	0509	    BEGIN
;	0510	
;	0511	! We scan the index file bitmap for the first free (zero) bit. This is done
;	0512	! by starting with the block recorded in the VCB and looking at each block
;	0513	! with a character scan.
;	0514	!
;	0515	
;	0516	    VBN = .VCB[VCB$B_IBMAPVBN];
;	0517	
;	0518	    IF
;	0519		BEGIN
;	0520		UNTIL .VBN GEQ .VCB[VCB$B_IBMAPSIZE] DO
;	0521		    BEGIN
;	0522		    BUFFER = READ_BLOCK (.VBN + .VCB[VCB$L_IBMAPLBN], 1, INDEX_TYPE);
;	0523		    IF NOT CH$FAIL (ADDRESS = CH$FIND_NOT_CH (512, .BUFFER, 255))
;	0524		    THEN EXITLOOP 0;
;	0525		    VBN = .VBN + 1;
;	0526		    END
;	0527		END
;	0528	
;	0529	! If we fall through the loop, the entire bitmap is full.
;	0530	!
;	0531	
;	0532		THEN ERR_EXIT (SS$_IDXFILEFULL);
;	0533	
;	0534	! Having found a byte containing a zero bit, scan for the bit.
;	0535	!
;	0536	
;	0537	    FFC (%REF (0), %REF (8), .ADDRESS, BITPOS);
;	0538	

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2-2
;
;	0539	! Compute the file number and check it against the maximum files allowed
;	0540	! on the volume. Also check if the corresponding file header is present in
;	0541	! the index file. If not, extend the index file and re-read the bitmap
;	0542	! block, which may have been kicked out in the process.
;	0543	!
;	0544	
;	0545	    FILE_NUMBER = .VBN*4096 + (.ADDRESS-.BUFFER)*8 + .BITPOS + 1;
;	0546	
;	0547	    IF .FILE_NUMBER GTR .VCB[VCB$L_MAXFILES]
;	0548	    THEN ERR_EXIT (SS$_IDXFILEFULL);
;	0549	
;	0550	    IDX_FCB = .VCB[VCB$L_FCBFL];
;	0551	    IF .FILE_NUMBER + .VCB[VCB$B_IBMAPSIZE] + .VCB[VCB$W_CLUSTER]*4
;	0552		GTR .IDX_FCB[FCB$L_FILESIZE]
;	0553	    THEN
;	0554		BEGIN
;	0555		ADDRESS = .ADDRESS - .BUFFER;
;	0556		EXTEND_INDEX (.FILE_NUMBER);
;	0557		BUFFER = READ_BLOCK (.VBN + .VCB[VCB$L_IBMAPLBN], 1, INDEX_TYPE);
;	0558		ADDRESS = .ADDRESS + .BUFFER;
;	0559		END;
;	0560	
;	0561	! All is in order. Set the bit and rewrite the block. Also update the
;	0562	! scan point in the VCB for the next create. Note that if the file number was
;	0563	! from the last bit in the block, we will start the scan at the next block to
;	0564	! avoid wasting a read.
;	0565	!
;	0566	
;	0567	    ADDRESS[.BITPOS] = 1;
;	0568	    WRITE_BLOCK (.BUFFER);
;	0569	
;	0570	    IF .FILE_NUMBER<0,12> EQL 0
;	0571	    THEN VBN = .VBN + 1;
;	0572	    KERNEL_CALL (UPDATE_IBVBN, .VBN);
;	0573	    NEW_FID = .FILE_NUMBER;		! record file ID for cleanup
;	0574	
;	0575	! Now get the header block. If the header is beyond the current EOF of the
;	0576	! index file, we do not read a block but simply materialize one in memory.
;	0577	! We also update the EOF in the index file FCB; every 20th update we also
;	0578	! update the EOF in the index file header.
;	0579	!
;	0580	
;	0581	    VBN = .FILE_NUMBER + .VCB[VCB$B_IBMAPSIZE] + .VCB[VCB$W_CLUSTER]*4;
;	0582	    IDX_FCB = .VCB[VCB$L_FCBFL];
;	0583	    LBN = MAP_VBN (.VBN, .IDX_FCB[FCB$L_WLFL]);
;	0584	    IF .LBN EQL -1 THEN BUG_CHECK (HDRNOTMAP, FATAL, 'Allocated file header not mapped');
;	0585	
;	0586	    NO_READ =  .VBN GTRU .IDX_FCB[FCB$L_EFBLK];
;	0587	    IF .NO_READ
;	0588	    OR .VCB[VCB$B_EOFDELTA] GTRU 20
;	0589	    THEN
;	0590		BEGIN
;	0591		IF KERNEL_CALL (BUMP_IDXEOF, .VBN)
;	0592		THEN
;	0593		    BEGIN

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2-3
;
;	0594		    HEADER = READ_HEADER (0, .IDX_FCB);
;	0595		    BBLOCK [HEADER[FH2$W_RECATTR], FAT$L_EFBLK] = ROT (.IDX_FCB[FCB$L_EFBLK]+1, 16);
;	0596		    BBLOCK [HEADER[FH2$W_RECATTR], FAT$W_FFBYTE] = 0;
;	0597		    CHECKSUM (.HEADER);
;	0598		    WRITE_HEADER ();
;	0599		    RESET_LBN (.HEADER, .VCB[VCB$L_IXHDR2LBN]);
;	0600		    WRITE_BLOCK (.HEADER);
;	0601		    INVALIDATE (.HEADER);
;	0602		    END;
;	0603		END;
;	0604	
;	0605	    IF .NO_READ
;	0606	    THEN
;	0607		HEADER = CREATE_BLOCK (.LBN, 1, HEADER_TYPE)
;	0608	
;	0609	! Else if the new header is within the index file EOF, read it.
;	0610	! Then check the block read for resemblence to a file header.
;	0611	!
;	0612	
;	0613	    ELSE
;	0614		HEADER = READ_NEW_HEADER (.LBN);
;	0615	
;	0616	    IF .HEADER NEQ 0
;	0617	    THEN
;	0618		BEGIN
;	0619		FILE_ID[FID$W_NUM] = .FILE_NUMBER<0,16>;
;	0620		FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_FID_SEQ];
;	0621		FILE_ID[FID$W_RVN] = .FILE_NUMBER<16,16>;
;	0622		SAVE_STATUS = .USER_STATUS[0];
;	0623		STATUS = CHECK_HEADER2 (.HEADER, FILE_ID);
;	0624		USER_STATUS[0] = .SAVE_STATUS; ! restore status, bashed by CHECK_HEADER
;	0625	
;	0626	! Make the final checks that the block is acceptable as a file header. We do
;	0627	! not use valid file headers. Also, we skip file numbers with the low 16 bits
;	0628	! all zero to avoid confusing the old FCS-11.
;	0629	!
;	0630	
;	0631		IF .FILE_ID[FID$W_NUM] EQL 0
;	0632		THEN
;	0633		    WRITE_BLOCK (.HEADER)
;	0634		ELSE
;	0635		    IF NOT .STATUS
;	0636		    THEN EXITLOOP;
;	0637		END;
;	0638	    END;				! end of file number allocation loop
;	0639	
;	0640	HEADER_LBN = .LBN;			! record LBN of new header
;	0641	
;	0642	IF .STATUS EQL 0
;	0643	THEN FILE_ID[FID$W_SEQ] = 0;
;	0644	FILE_ID[FID$W_SEQ] = .FILE_ID[FID$W_SEQ] + 1;
;	0645	CH$MOVE (FID$C_LENGTH, FILE_ID, HEADER[FH2$W_FID]);
;	0646	
;	0647	RETURN .HEADER;
;	0648	

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2-4
;
;	0649	END;					! end of routine CREATE_HEADER


							    .TITLE  CREHDR
							    .IDENT  \B0008\

							    .PSECT  $LOCKEDC2$,NOWRT,2

				  FEFF  0000  00000 P.AAA:  .WORD   0, -257						      ;
					0000* 00004 	    .WORD   <BUG$_HDRNOTMAP!4>					      ;
					      00006	    .BLKB   2

							    .EXTRN  CURRENT_VCB, NEW_FID, HEADER_LBN, USER_STATUS
							    .EXTRN  READ_BLOCK, WRITE_BLOCK, EXTEND_INDEX, MAP_VBN
							    .EXTRN  READ_HEADER, CHECKSUM, WRITE_HEADER, RESET_LBN
							    .EXTRN  INVALIDATE, CREATE_BLOCK, CHECK_HEADER2, SYS$CMKRNL
							    .EXTRN  BUG$_HDRNOTMAP

							    .PSECT  $CODE$,NOWRT,2

					 0FFC 00000 	    .ENTRY  CREATE_HEADER, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11       ; 0429
		         5E 	       18  C2 00002 	    SUBL2   #24, SP						      ;
		         52 	0000G  CF  D0 00005 	    MOVL    CURRENT_VCB, VCB					      ; 0507
		         5A 	  38   A2  9E 0000A 	    MOVAB   56(R2), R10						      ; 0520
		         53 	  3A   A2  9A 0000E 1$:     MOVZBL  58(VCB), VBN					      ; 0516
	   6A 	         08 	       00  ED 00012 2$:     CMPZV   #0, #8, (R10), VBN					      ; 0520
				       53     00016									      ;
				       40  15 00017 	    BLEQ    5$							      ;
				       03  DD 00019 	    PUSHL   #3							      ; 0522
				       01  DD 0001B 	    PUSHL   #1							      ;
				  30 B243  9F 0001D 	    PUSHAB  @48(VCB)[VBN]					      ;
		  0000G  CF	       03  FB 00021 	    CALLS   #3, READ_BLOCK					      ;
		         58 	       50  D0 00026 	    MOVL    R0, BUFFER						      ;
	   68 	  0200   8F	  FF   8F  3B 00029 	    SKPC    #255, #512, (BUFFER)				      ; 0523
				       02  12 00030 	    BNEQ    3$							      ;
				       51  D4 00032 	    CLRL    R1							      ;
		         59 	       51  D0 00034 3$:     MOVL    R1, ADDRESS						      ;
				       04  12 00037 	    BNEQ    4$							      ;
				       53  D6 00039 	    INCL    VBN							      ; 0525
				       D5  11 0003B 	    BRB     2$							      ; 0520
	   69 	         08 	       00  EB 0003D 4$:     FFC     #0, #8, (ADDRESS), BITPOS				      ; 0537
				       5B     00041									      ;
	   51 	         53 	       0C  78 00042 	    ASHL    #12, VBN, R1					      ; 0545
	   50 	         59 	       58  C3 00046 	    SUBL3   BUFFER, ADDRESS, R0					      ;
		         50 	     6140  7E 0004A 	    MOVAQ   (R1)[R0], R0					      ;
		         55 	  01 AB40  9E 0004E 	    MOVAB   1(BITPOS)[R0], FILE_NUMBER				      ;
		    44   A2	       55  D1 00053 	    CMPL    FILE_NUMBER, 68(VCB)				      ; 0547
				       07  15 00057 	    BLEQ    6$							      ;
				08D0   8F  BF 00059 5$:     CHMU    #2256						      ; 0548
				     0165  31 0005D 	    BRW     19$							      ;
		         54 	       62  D0 00060 6$:     MOVL    (VCB), IDX_FCB					      ; 0550
		         5A 	  38   A2  9E 00063 	    MOVAB   56(R2), R10						      ; 0551
		         50 	       6A  9A 00067 	    MOVZBL  (R10), R0						      ;
	   51 	         55 	       50  C1 0006A 	    ADDL3   R0, FILE_NUMBER, R1					      ;
		         50 	  3C   A2  3C 0006E 	    MOVZWL  60(VCB), R0						      ;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2-5
;
		         57 	     6140  DE 00072 	    MOVAL   (R1)[R0], R7					      ;
		    34   A4	       57  D1 00076 	    CMPL    R7, 52(IDX_FCB)					      ; 0552
				       1D  15 0007A 	    BLEQ    7$							      ;
		         59 	       58  C2 0007C 	    SUBL2   BUFFER, ADDRESS					      ; 0555
				       55  DD 0007F 	    PUSHL   FILE_NUMBER						      ; 0556
		  0000G  CF	       01  FB 00081 	    CALLS   #1, EXTEND_INDEX					      ;
				       03  DD 00086 	    PUSHL   #3							      ; 0557
				       01  DD 00088 	    PUSHL   #1							      ;
				  30 B243  9F 0008A 	    PUSHAB  @48(VCB)[VBN]					      ;
		  0000G  CF	       03  FB 0008E 	    CALLS   #3, READ_BLOCK					      ;
		         58 	       50  D0 00093 	    MOVL    R0, BUFFER						      ;
		         59 	       58  C0 00096 	    ADDL2   BUFFER, ADDRESS					      ; 0558
	   00 	         69 	       5B  E2 00099 7$:     BBSS    BITPOS, (ADDRESS), 8$				      ; 0567
				       58  DD 0009D 8$:     PUSHL   BUFFER						      ; 0568
		  0000G  CF	       01  FB 0009F 	    CALLS   #1, WRITE_BLOCK					      ;
		  0FFF   8F	       55  B3 000A4 	    BITW    FILE_NUMBER, #4095					      ; 0570
				       02  12 000A9 	    BNEQ    9$							      ;
				       53  D6 000AB 	    INCL    VBN							      ; 0571
				       53  DD 000AD 9$:     PUSHL   VBN							      ; 0572
				       01  DD 000AF 	    PUSHL   #1							      ;
				       5E  DD 000B1 	    PUSHL   SP							      ;
				0000V  CF  9F 000B3 	    PUSHAB  UPDATE_IBVBN					      ;
	      00000000G  9F	       04  FB 000B7 	    CALLS   #4, @#SYS$CMKRNL					      ;
		  0000G  CF	       55  D0 000BE 	    MOVL    FILE_NUMBER, NEW_FID				      ; 0573
		         53 	       57  D0 000C3 	    MOVL    R7, VBN						      ; 0581
		         54 	       62  D0 000C6 	    MOVL    (VCB), IDX_FCB					      ; 0582
				  10   A4  DD 000C9 	    PUSHL   16(IDX_FCB)						      ; 0583
				       53  DD 000CC 	    PUSHL   VBN							      ;
		  0000G  CF	       02  FB 000CE 	    CALLS   #2, MAP_VBN						      ;
		    0C   AE	       50  D0 000D3 	    MOVL    R0, LBN						      ;
	      FFFFFFFF   8F	  0C   AE  D1 000D7 	    CMPL    LBN, #-1						      ; 0584
				       05  12 000DF 	    BNEQ    10$							      ;
		  0000'  CF	       00  FB 000E1 	    CALLS   #0, P.AAA						      ;
				       50  D4 000E6 10$:    CLRL    R0							      ; 0586
		    40   A4	       53  D1 000E8 	    CMPL    VBN, 64(IDX_FCB)					      ;
				       02  1B 000EC 	    BLEQU   11$							      ;
				       50  D6 000EE 	    INCL    R0							      ;
		    04   AE	       50  D0 000F0 11$:    MOVL    R0, NO_READ						      ;
		         06 	  04   AE  E8 000F4 	    BLBS    NO_READ, 12$					      ; 0587
		         14 	  4E   A2  91 000F8 	    CMPB    78(VCB), #20					      ; 0588
				       51  1B 000FC 	    BLEQU   13$							      ;
				       53  DD 000FE 12$:    PUSHL   VBN							      ; 0591
				       01  DD 00100 	    PUSHL   #1							      ;
				       5E  DD 00102 	    PUSHL   SP							      ;
				0000V  CF  9F 00104 	    PUSHAB  BUMP_IDXEOF						      ;
	      00000000G  9F	       04  FB 00108 	    CALLS   #4, @#SYS$CMKRNL					      ;
		         3D 	       50  E9 0010F 	    BLBC    R0, 13$						      ;
				       54  DD 00112 	    PUSHL   IDX_FCB						      ; 0594
				       7E  D4 00114 	    CLRL    -(SP)						      ;
		  0000G  CF	       02  FB 00116 	    CALLS   #2, READ_HEADER					      ;
		         56 	       50  D0 0011B 	    MOVL    R0, HEADER						      ;
	   50 	    40   A4	       01  C1 0011E 	    ADDL3   #1, 64(IDX_FCB), R0					      ; 0595
      1C   A6	         50 	       10  9C 00123 	    ROTL    #16, R0, 28(HEADER)					      ;
				  20   A6  B4 00128 	    CLRW    32(HEADER)						      ; 0596
				       56  DD 0012B 	    PUSHL   HEADER						      ; 0597

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 2-6
;
		  0000G  CF	       01  FB 0012D 	    CALLS   #1, CHECKSUM					      ;
		  0000G  CF	       00  FB 00132 	    CALLS   #0, WRITE_HEADER					      ; 0598
				  2C   A2  DD 00137 	    PUSHL   44(VCB)						      ; 0599
				       56  DD 0013A 	    PUSHL   HEADER						      ;
		  0000G  CF	       02  FB 0013C 	    CALLS   #2, RESET_LBN					      ;
				       56  DD 00141 	    PUSHL   HEADER						      ; 0600
		  0000G  CF	       01  FB 00143 	    CALLS   #1, WRITE_BLOCK					      ;
				       56  DD 00148 	    PUSHL   HEADER						      ; 0601
		  0000G  CF	       01  FB 0014A 	    CALLS   #1, INVALIDATE					      ;
		         0D 	  04   AE  E9 0014F 13$:    BLBC    NO_READ, 14$					      ; 0605
		         7E 	       01  7D 00153 	    MOVQ    #1, -(SP)						      ; 0607
				  14   AE  DD 00156 	    PUSHL   LBN							      ;
		  0000G  CF	       03  FB 00159 	    CALLS   #3, CREATE_BLOCK					      ;
				       08  11 0015E 	    BRB     15$							      ;
				  0C   AE  DD 00160 14$:    PUSHL   LBN							      ; 0614
		  0000V  CF	       01  FB 00163 	    CALLS   #1, READ_NEW_HEADER					      ;
		         56 	       50  D0 00168 15$:    MOVL    R0, HEADER						      ;
				       36  13 0016B 	    BEQL    16$							      ; 0616
		    10   AE	       55  B0 0016D 	    MOVW    FILE_NUMBER, FILE_ID				      ; 0619
		    12   AE	  0A   A6  B0 00171 	    MOVW    10(HEADER), FILE_ID+2				      ; 0620
	   55 	         10 	       10  EF 00176 	    EXTZV   #16, #16, FILE_NUMBER, R0				      ; 0621
				       50     0017A									      ;
		    14   AE	       50  B0 0017B 	    MOVW    R0, FILE_ID+4					      ;
		         6E 	0000G  CF  D0 0017F 	    MOVL    USER_STATUS, SAVE_STATUS				      ; 0622
				  10   AE  9F 00184 	    PUSHAB  FILE_ID						      ; 0623
				       56  DD 00187 	    PUSHL   HEADER						      ;
		  0000G  CF	       02  FB 00189 	    CALLS   #2, CHECK_HEADER2					      ;
		    08   AE	       50  D0 0018E 	    MOVL    R0, STATUS						      ;
		  0000G  CF	       6E  D0 00192 	    MOVL    SAVE_STATUS, USER_STATUS				      ; 0624
				  10   AE  B5 00197 	    TSTW    FILE_ID						      ; 0631
				       0A  12 0019A 	    BNEQ    17$							      ;
				       56  DD 0019C 	    PUSHL   HEADER						      ; 0633
		  0000G  CF	       01  FB 0019E 	    CALLS   #1, WRITE_BLOCK					      ;
				     FE68  31 001A3 16$:    BRW     1$							      ; 0631
		         F9 	  08   AE  E8 001A6 17$:    BLBS    STATUS, 16$						      ; 0635
		  0000G  CF	  0C   AE  D0 001AA 	    MOVL    LBN, HEADER_LBN					      ; 0640
				  08   AE  D5 001B0 	    TSTL    STATUS						      ; 0642
				       03  12 001B3 	    BNEQ    18$							      ;
				  12   AE  B4 001B5 	    CLRW    FILE_ID+2						      ; 0643
				  12   AE  B6 001B8 18$:    INCW    FILE_ID+2						      ; 0644
      08   A6	    10   AE	       06  28 001BB 	    MOVC3   #6, FILE_ID, 8(HEADER)				      ; 0645
		         50 	       56  D0 001C1 	    MOVL    HEADER, R0						      ; 0647
					   04 001C4 	    RET     							      ;
				       50  D4 001C5 19$:    CLRL    R0							      ; 0429
					   04 001C7 	    RET     							      ;

; Routine Size:  456 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 3
;
;	0650	GLOBAL ROUTINE UPDATE_IBVBN (VBN) : NOVALUE =
;	0651	
;	0652	!++
;	0653	!
;	0654	! FUNCTIONAL DESCRIPTION:
;	0655	!
;	0656	!	This routine writes back the starting VBN for the index file bitmap
;	0657	!	scan into the vcb. This routine must be called in kernel mode.
;	0658	!
;	0659	! CALLING SEQUENCE:
;	0660	!	UPDATE_VBN (ARG1)
;	0661	!
;	0662	! INPUT PARAMETERS:
;	0663	!	ARG1: new start VBN
;	0664	!
;	0665	! IMPLICIT INPUTS:
;	0666	!	CURRENT_VCB: VCB of volume
;	0667	!
;	0668	! OUTPUT PARAMETERS:
;	0669	!	NONE
;	0670	!
;	0671	! IMPLICIT OUTPUTS:
;	0672	!	NONE
;	0673	!
;	0674	! ROUTINE VALUE:
;	0675	!	NONE
;	0676	!
;	0677	! SIDE EFFECTS:
;	0678	!	VBN written into VCB
;	0679	!
;	0680	!--
;	0681	
;	0682	BEGIN
;	0683	
;	0684	EXTERNAL
;	0685		CURRENT_VCB	: REF BBLOCK;	! VCB of volume
;	0686	
;	0687	CURRENT_VCB[VCB$B_IBMAPVBN] = .VBN;
;	0688	
;	0689	END;					! end of routine UPDATE_VBN





					 0000 001C8 	    .ENTRY  UPDATE_IBVBN, Save nothing				      ; 0650
		         50 	0000G  CF  D0 001CA 	    MOVL    CURRENT_VCB, R0					      ; 0687
		    3A   A0	  04   AC  90 001CF 	    MOVB    VBN, 58(R0)						      ;
					   04 001D4 	    RET     							      ; 0650

; Routine Size:  13 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 4
;
;	0690	GLOBAL ROUTINE BUMP_IDXEOF (VBN) =
;	0691	
;	0692	!++
;	0693	!
;	0694	! FUNCTIONAL DESCRIPTION:
;	0695	!
;	0696	!	This routine sets the end of file mark for the index file to
;	0697	!	the given VBN and counts the update.
;	0698	!
;	0699	! CALLING SEQUENCE:
;	0700	!	BUMP_IDXEOF (ARG1)
;	0701	!
;	0702	! INPUT PARAMETERS:
;	0703	!	ARG1: new end of file VBN
;	0704	!
;	0705	! IMPLICIT INPUTS:
;	0706	!	CURRENT_VCB: VCB of volume
;	0707	!
;	0708	! OUTPUT PARAMETERS:
;	0709	!	NONE
;	0710	!
;	0711	! IMPLICIT OUTPUTS:
;	0712	!	NONE
;	0713	!
;	0714	! ROUTINE VALUE:
;	0715	!	1 if index file header should be updated
;	0716	!	0 if not
;	0717	!
;	0718	! SIDE EFFECTS:
;	0719	!	VBN written into VCB
;	0720	!
;	0721	!--
;	0722	
;	0723	BEGIN
;	0724	
;	0725	LOCAL
;	0726		IDX_FCB		: REF BBLOCK;	! FCB of index file
;	0727	
;	0728	EXTERNAL
;	0729		CURRENT_VCB	: REF BBLOCK;	! VCB of volume
;	0730	
;	0731	
;	0732	! Store the EOF into the index file FCB. Also bump the change count in the
;	0733	! VCB. If it exceeds 20, clear it and return true, calling for an update.
;	0734	!
;	0735	
;	0736	IDX_FCB = .CURRENT_VCB[VCB$L_FCBFL];
;	0737	IF .VBN GTRU .IDX_FCB[FCB$L_EFBLK]
;	0738	THEN IDX_FCB[FCB$L_EFBLK] = .VBN;
;	0739	CURRENT_VCB[VCB$B_EOFDELTA] = .CURRENT_VCB[VCB$B_EOFDELTA] + 1;
;	0740	
;	0741	IF .CURRENT_VCB[VCB$B_EOFDELTA] GTRU 20
;	0742	THEN
;	0743	    BEGIN
;	0744	    CURRENT_VCB[VCB$B_EOFDELTA] = 0;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 4-1
;
;	0745	    RETURN 1;
;	0746	    END
;	0747	ELSE
;	0748	    RETURN 0;
;	0749	
;	0750	END;					! end of routine BUMP_IDXEOF





					 0000 001D5 	    .ENTRY  BUMP_IDXEOF, Save nothing				      ; 0690
		         50 	0000G  CF  D0 001D7 	    MOVL    CURRENT_VCB, R0					      ; 0736
		         51 	       60  D0 001DC 	    MOVL    (R0), IDX_FCB					      ;
		    40   A1	  04   AC  D1 001DF 	    CMPL    VBN, 64(IDX_FCB)					      ; 0737
				       05  1B 001E4 	    BLEQU   1$							      ;
		    40   A1	  04   AC  D0 001E6 	    MOVL    VBN, 64(IDX_FCB)					      ; 0738
				  4E   A0  96 001EB 1$:     INCB    78(R0)						      ; 0739
		         14 	  4E   A0  91 001EE 	    CMPB    78(R0), #20						      ; 0741
				       07  1B 001F2 	    BLEQU   2$							      ;
				  4E   A0  94 001F4 	    CLRB    78(R0)						      ; 0744
		         50 	       01  D0 001F7 	    MOVL    #1, R0						      ; 0745
					   04 001FA 	    RET     							      ;
				       50  D4 001FB 2$:     CLRL    R0							      ; 0690
					   04 001FD 	    RET     							      ;

; Routine Size:  41 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 5
;
;	0751	ROUTINE READ_NEW_HEADER (LBN) =
;	0752	
;	0753	!++
;	0754	!
;	0755	! FUNCTIONAL DESCRIPTION:
;	0756	!
;	0757	!	This routine reads the block about to be used for a new file header.
;	0758	!	It uses a local condition handler to fix up errors.
;	0759	!
;	0760	!
;	0761	! CALLING SEQUENCE:
;	0762	!	READ_NEW_HEADER (ARG1)
;	0763	!
;	0764	! INPUT PARAMETERS:
;	0765	!	ARG1: LBN of block to read
;	0766	!
;	0767	! IMPLICIT INPUTS:
;	0768	!	NONE
;	0769	!
;	0770	! OUTPUT PARAMETERS:
;	0771	!	NONE
;	0772	!
;	0773	! IMPLICIT OUTPUTS:
;	0774	!	NONE
;	0775	!
;	0776	! ROUTINE VALUE:
;	0777	!	address of buffer containing block or 0 if bad
;	0778	!
;	0779	! SIDE EFFECTS:
;	0780	!	block read and/or written
;	0781	!
;	0782	!--
;	0783	
;	0784	BEGIN
;	0785	
;	0786	LOCAL
;	0787		HEADER		: REF BBLOCK;	! address of block read
;	0788	
;	0789	EXTERNAL ROUTINE
;	0790		READ_BLOCK,			! read a block
;	0791		WRITE_BLOCK,			! write a block
;	0792		INVALIDATE,			! invalidate a buffer
;	0793		CREATE_BLOCK;			! create a new block buffer
;	0794	
;	0795	! Under control of the condition handler, we read the block. If the read
;	0796	! fails, we attempt to rewrite the block and then read it again. If either
;	0797	! of the latter fails, we return failure.
;	0798	!
;	0799	
;	0800	ENABLE HANDLER;
;	0801	
;	0802	HEADER = READ_BLOCK (.LBN, 1, HEADER_TYPE);
;	0803	
;	0804	IF .HEADER EQL 0
;	0805	THEN

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 5-1
;
;	0806	    BEGIN
;	0807	    HEADER = CREATE_BLOCK (.LBN, 1, HEADER_TYPE);
;	0808	    WRITE_BLOCK (.HEADER);
;	0809	    INVALIDATE (.HEADER);
;	0810	    HEADER = READ_BLOCK (.LBN, 1, HEADER_TYPE);
;	0811	    END;
;	0812	
;	0813	RETURN .HEADER;
;	0814	
;	0815	END;					! end of routine READ_NEW_HEADER





					 0004 001FE READ_NEW_HEADER:
							    .WORD   Save R2						      ; 0751
		         6D 0000003F   EF  DE 00200 	    MOVAL   2$, (FP)						      ; 0784
		         7E 	       01  7D 00207 	    MOVQ    #1, -(SP)						      ; 0802
				  04   AC  DD 0020A 	    PUSHL   LBN							      ;
		  0000G  CF	       03  FB 0020D 	    CALLS   #3, READ_BLOCK					      ;
		         52 	       50  D0 00212 	    MOVL    R0, HEADER						      ;
				       2A  12 00215 	    BNEQ    1$							      ; 0804
		         7E 	       01  7D 00217 	    MOVQ    #1, -(SP)						      ; 0807
				  04   AC  DD 0021A 	    PUSHL   LBN							      ;
		  0000G  CF	       03  FB 0021D 	    CALLS   #3, CREATE_BLOCK					      ;
		         52 	       50  D0 00222 	    MOVL    R0, HEADER						      ;
				       52  DD 00225 	    PUSHL   HEADER						      ; 0808
		  0000G  CF	       01  FB 00227 	    CALLS   #1, WRITE_BLOCK					      ;
				       52  DD 0022C 	    PUSHL   HEADER						      ; 0809
		  0000G  CF	       01  FB 0022E 	    CALLS   #1, INVALIDATE					      ;
		         7E 	       01  7D 00233 	    MOVQ    #1, -(SP)						      ; 0810
				  04   AC  DD 00236 	    PUSHL   LBN							      ;
		  0000G  CF	       03  FB 00239 	    CALLS   #3, READ_BLOCK					      ;
		         52 	       50  D0 0023E 	    MOVL    R0, HEADER						      ;
		         50 	       52  D0 00241 1$:     MOVL    HEADER, R0						      ; 0813
					   04 00244 	    RET     							      ; 0751
					 0000 00245 2$:     .WORD   Save nothing					      ; 0784
				       7E  D4 00247 	    CLRL    -(SP)						      ;
				       5E  DD 00249 	    PUSHL   SP							      ;
		         7E 	  04   AC  7D 0024B 	    MOVQ    4(AP), -(SP)					      ;
		  0000V  CF	       03  FB 0024F 	    CALLS   #3, HANDLER						      ;
					   04 00254 	    RET     							      ;

; Routine Size:  87 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 6
;
;	0816	ROUTINE HANDLER (SIGNAL, MECHANISM) =
;	0817	
;	0818	!++
;	0819	!
;	0820	! FUNCTIONAL DESCRIPTION:
;	0821	!
;	0822	!	This routine is the condition handler for the initial header read.
;	0823	!	On a read error, it unwinds and causes the read call to return 0
;	0824	!	to the caller (the establisher frame). On write errors which are
;	0825	!	not hard drive errors, it unwinds and causes the establisher to
;	0826	!	return 0 to its caller (the CREATE_HEADER routine).
;	0827	!
;	0828	! CALLING SEQUENCE:
;	0829	!	HANDLER (ARG1, ARG2)
;	0830	!
;	0831	! INPUT PARAMETERS:
;	0832	!	ARG1: address of signal array
;	0833	!	ARG2: address of mechanism array
;	0834	!
;	0835	! IMPLICIT INPUTS:
;	0836	!	NONE
;	0837	!
;	0838	! OUTPUT PARAMETERS:
;	0839	!	NONE
;	0840	!
;	0841	! IMPLICIT OUTPUTS:
;	0842	!	NONE
;	0843	!
;	0844	! ROUTINE VALUE:
;	0845	!	SS$_RESIGNAL or none if unwind
;	0846	!
;	0847	! SIDE EFFECTS:
;	0848	!	NONE
;	0849	!
;	0850	!--
;	0851	
;	0852	
;	0853	BEGIN
;	0854	
;	0855	MAP
;	0856		SIGNAL		: REF BBLOCK,	! signal arg array
;	0857		MECHANISM	: REF BBLOCK;	! mechanism arg array
;	0858	
;	0859	EXTERNAL
;	0860		IO_STATUS	: VECTOR;	! I/O status block of last operation
;	0861	
;	0862	
;	0863	! If the condition is change mode to user (error exit) and the status is
;	0864	! read error, zero the return R0 and unwind to the the establisher. On
;	0865	! most write errors, zero the return R0 and unwind to the caller.
;	0866	! Otherwise, just resignal the condition.
;	0867	!
;	0868	
;	0869	IF .SIGNAL[CHF$L_SIG_NAME] EQL SS$_CMODUSER
;	0870	THEN

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 6-1
;
;	0871	    BEGIN
;	0872	    MECHANISM[CHF$L_MCH_SAVR0] = 0;
;	0873	
;	0874	    IF .SIGNAL[CHF$L_SIG_ARG1] EQL SS$_FCPREADERR
;	0875	    THEN
;	0876		$UNWIND (DEPADR = MECHANISM[CHF$L_MCH_DEPTH])
;	0877	    ELSE IF .SIGNAL[CHF$L_SIG_ARG1] EQL SS$_FCPWRITERR
;	0878	    AND (.IO_STATUS<0,16> EQL SS$_PARITY
;	0879		OR .IO_STATUS<0,16> EQL SS$_DATACHECK)
;	0880	    THEN
;	0881		$UNWIND ();
;	0882	    END;
;	0883	
;	0884	RETURN SS$_RESIGNAL;			! status is irrelevant if unwinding
;	0885	
;	0886	END;					! end of routine HANDLER



							    .EXTRN  IO_STATUS, SYS$UNWIND

					 0000 00255 HANDLER:.WORD   Save nothing					      ; 0816
		         50 	  04   AC  D0 00257 	    MOVL    SIGNAL, R0						      ; 0869
	      00000424   8F	  04   A0  D1 0025B 	    CMPL    4(R0), #1060					      ;
				       3D  12 00263 	    BNEQ    4$							      ;
		         51 	  08   AC  D0 00265 	    MOVL    MECHANISM, R1					      ; 0872
				  0C   A1  D4 00269 	    CLRL    12(R1)						      ;
	      00000888   8F	  08   A0  D1 0026C 	    CMPL    8(R0), #2184					      ; 0874
				       07  12 00274 	    BNEQ    1$							      ;
				       7E  D4 00276 	    CLRL    -(SP)						      ; 0876
				  08   A1  9F 00278 	    PUSHAB  8(R1)						      ;
				       1E  11 0027B 	    BRB     3$							      ;
	      000008A0   8F	  08   A0  D1 0027D 1$:     CMPL    8(R0), #2208					      ; 0877
				       1B  12 00285 	    BNEQ    4$							      ;
		  01F4   8F	0000G  CF  B1 00287 	    CMPW    IO_STATUS, #500					      ; 0878
				       09  13 0028E 	    BEQL    2$							      ;
		  005C   8F	0000G  CF  B1 00290 	    CMPW    IO_STATUS, #92					      ; 0879
				       09  12 00297 	    BNEQ    4$							      ;
				       7E  7C 00299 2$:     CLRQ    -(SP)						      ; 0881
	      00000000G  9F	       02  FB 0029B 3$:     CALLS   #2, @#SYS$UNWIND					      ;
		         50 	0918   8F  3C 002A2 4$:     MOVZWL  #2328, R0						      ; 0884
					   04 002A7 	    RET     							      ; 0816

; Routine Size:  83 bytes


;	0887	
;	0888	END
;	0889	ELUDOM







; Bliss-32 10.1-416	Monday 21-AUG-1978 23:10:29	DBB3:[F11B.SRC]CREHDR.B32;6					Page 6-2
;
;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  $LOCKEDC2$     	     8  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $CODE$         	   680  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        39         0       251





; Size:		680 code + 8 data bytes
; Run Time:	00:14.8
; Elapsed Time:	00:35.7
; Memory Used:	386 pages
; Compilation Complete
