GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 1


      1						.TITLE	GETCML
      2						.IDENT	/01/
      3					;
      4					; COPYRIGHT (C) 1976
      5					; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER  A LICENSE FOR USE ONLY  ON  A
      8					; SINGLE COMPUTER SYSTEM AND MAY BE  COPIED ONLY WITH  THE INCLU-
      9					; SION OF  THE  ABOVE  COPYRIGHT NOTICE.  THIS SOFTWARE,  OR  ANY
     10					; OTHER COPIES THEREOF, MAY NOT BE  PROVIDED  OR  OTHERWISE  MADE
     11					; AVAILABLE TO ANY OTHER PERSON EXCEPT  FOR  USE  ON  SUCH SYSTEM
     12					; AND TO  ONE WHO AGREES  TO  THESE LICENSE  TERMS.  TITLE TO AND
     13					; OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DEC.
     14					;
     15					; THE INFORMATION IN THIS SOFTWARE  IS  SUBJECT TO CHANGE WITHOUT
     16					; NOTICE AND SHOULD NOT BE CONSTRUED  AS  A COMMITMENT BY DIGITAL
     17					; EQUIPMENT CORPORATION.
     18					;
     19					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     20					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     21					;
     22					; VERSION 01
     23					;
     24					; K. D. MORSE 1-AUG-76
     25					;
     26					; MACRO LIBRARY CALLS
     27					;
     28						.MCALL GCML$,GCMLB$,CSI$1,CSI$2,CSI$,CSI$SW,CSI$ND
     29						.MCALL OPEN$R,OPEN$W,FDAT$R,CLOSE$,DELET$,PRINT$,GET$,PUT$
     30						.MCALL WAIT$,READ$,WRITE$
     31					;+
     32					;**-GETCML-GET LINE FROM COMMAND INPUT FILE
     33					;
     34					; THIS ROUTINE CALLS THE SYSTEM LIBRARY ROUTINE GCML$ TO READ THE NEXT RECORD
     35					; FROM THE COMMAND INPUT FILE.  IF COMMANDS ARE INITIATED FROM A TERMINAL,
     36					; THE USER IS PROMPTED WITH THE SUPPLIED STRING.  IF THE LINE CONTAINS
     37					; A LEADING ";", THEN IT IS TREATED AS A COMMENT AND ANOTHER LINE IS READ.
     38					;
     39					; INPUTS:
     40					;
     41					;	2(R5) IS THE ADDRESS FOR THE COMMAND LINE
     42					;	4(R5) IS THE ADDRESS FOR THE LENGTH OF THE RETURNED COMMAND LINE
     43					;	6(R5) IS THE ADDRESS FOR THE PROMPT
     44					;	10(R5) IS THE ADDRESS FOR THE LENGTH OF THE PROMPT
     45					;	12(R5) IS THE ADDRESS FOR THE SUCCESS/ERROR CODE
     46					;
     47					; OUTPUTS:
     48					;
     49					;	@2(R5) CONTAINS THE COMMAND LINE
     50					;	@12(R5) CONTAINS EITHER THE LENGTH OF THE COMMAND LINE OR
     51					;	       A CODE INDICATING THE FOLLOWING:
     52					;
     53					;			 >0 = SUCCESS
     54					;			 0 = EOF
     55					;			-1 = I/O ERROR
     56					;			-2 = UNABLE TO OPEN FILE
     57					;			-3 = INDIRECT FILE SYNTAX ERROR
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 1-1


     58					;			-4 = INDIRECT FILES TOO DEEPLY NESTED
     59					;-
     60	000000	012775 	000001 	000012 	GETCML:: MOV	#1,@12(R5)	;ASSUME SUCCESS
     61	000006					GCML$	#GCLBLK,6(R5),@10(R5)	;GET COMMAND LINE
     62	000032	103414 				BCS	20$		;ERROR IN COMMAND FETCH
     63	000034	016001 	000146 			MOV	G.CMLD(R0),R1	;GET LENGTH OF COMMAND LINE
     64	000040	003757 				BLE	GETCML		;LENGTH=0, PROMPT FOR NEW LINE
     65	000042	016002 	000150 			MOV	G.CMLD+2(R0),R2 ;GET ADDR OF COMMAND LINE
     66	000046	010175 	000004 			MOV	R1,@4(R5)	;SET UP LENGTH
     67	000052	016503 	000002 			MOV	2(R5),R3	;GET ADDR OF RETURN COMMAND LINE
     68	000056	112223 			10$:	MOVB	(R2)+,(R3)+	;MOVE IN COMMAND LINE
     69	000060	077102 				SOB	R1,10$		;LOOP UNTIL ALL OF LENGTH IS MOVED
     70	000062	000434 				BR	100$		;RETURN
     71					;
     72					; ERROR OR EOF
     73					;
     74					; SET LENGTH AS INDICATOR OF ERROR TYPE (OR EOF)
     75					;
     76	000064	116001 	000140 		20$:	MOVB	G.ERR(R0),R1	;MOVE IN ERROR CODE FROM GCML$
     77	000070	012775 	177777 	000012 		MOV	#-1,@12(R5)	;SET ERROR CODE
     78	000076	122701 	177777 			CMPB	#GE.IOR,R1	;IS IT AN I/O ERROR?
     79	000102	001424 				BEQ	100$		;YES, RETURN
     80	000104	005375 	000012 			DEC	@12(R5)		;NO, DECREMENT LENGTH WHICH IS ERR CODE
     81	000110	122701 	177776 			CMPB	#GE.OPR,R1	;IS IT UNABLE TO OPEN FILE ERROR?
     82	000114	001417 				BEQ	100$		;YES, RETURN
     83	000116	005375 	000012 			DEC	@12(R5)		;NO, DECREMENT ERROR CODE
     84	000122	122701 	177775 			CMPB	#GE.BIF,R1	;IS IT INDIRECT FILE SYNTAX ERROR?
     85	000126	001412 				BEQ	100$		;YES, RETURN
     86	000130	005375 	000012 			DEC	@12(R5)		;NO, DECREMENT ERROR CODE
     87	000134	122701 	177774 			CMPB	#GE.MDE,R1	;IS IT TOO DEEPLY NESTED IN INDIRECTS?
     88	000140	001405 				BEQ	100$		;YES, RETURN
     89	000142	122701 	177766 			CMPB	#GE.EOF,R1	;IS IT EOF?
     90	000146	001002 				BNE	100$		;GOT UNKNOWN ERROR, RETURN
     91	000150	005075 	000012 			CLR	@12(R5)		;RETURN ZERO AS LENGTH TO INDICATE EOF
     92	000154	000207 			100$:	RETURN			;RETURN
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 2


     94					;+
     95					;**-SYNTX-COMMAND LINE SYNTAX ANALYZER
     96					;
     97					; THIS ROUTINE ANALYZES THE SYNTAX OF A COMMAND LINE VIA THE SYSTEM LIBRARY
     98					; ROUTINE CSI$1.  IT COMPRESSES THE COMMAND LINE, REMOVING EXTRANEOUS BLANKS,
     99					; NULLS, TABS, AND RUBOUTS.  THE ROUTINE RETURNS THE COMPRESSED LINE,
    100					; TERMINATED BY A NULL, AND THE COMPRESSED LINE'S LENGTH.  IF AN ERROR IS
    101					; DETECTED IN THE LINE, THE PART OF THE LINE IN ERROR IS RETURNED INSTEAD
    102					; OF THE WHOLE LINE.  THE LENGTH OF THIS PART IS NEGATED AND RETURNED
    103					; INSTEAD OF THE TOTAL LENGTH.
    104					;
    105					; INPUTS:
    106					;
    107					;	2(R5) IS THE ADDRESS OF THE COMMAND LINE
    108					;	4(R5) IS THE ADDRESS OF THE LENGTH OF THE COMMAND LINE
    109					;	6(R5) IS THE ADDRESS OF THE SUCCESS/ERROR CODE
    110					;
    111					; OUTPUTS:
    112					;
    113					;	IF SYNTACTICALLY CORRECT:
    114					;
    115					;		@2(R5) CONTAINS THE COMPRESSED COMMAND LINE
    116					;		@4(R5) CONTAINS THE LENGTH OF THE COMPRESSED COMMAND LINE
    117					;
    118					;	IF SYNTACTICALLY INCORRECT:
    119					;
    120					;		@2(R5) CONTAINS THE PART OF THE LINE IN ERROR
    121					;		@4(R5) CONTAINS THE LENGTH OF THE PART IN ERROR
    122					;		@6(R5) CONTAINS THE SUCCESS/ERROR CODE
    123					;			>0 = SUCCESS
    124					;			<0 = SYNTAX ERROR
    125					;-
    126	000156	012775 	000001 	000006 	SYNTX:: MOV	#1,@6(R5)	;ASSUME SUCCESS
    127	000164	016504 	000002 			MOV	2(R5),R4	;GET ADDR OF COMMAND LINE
    128	000170					CSI$1	#CSIBLK,R4,@4(R5) ;ANALYZE SYNTAX
    129	000212	103013 				BCC	20$		;LINE SYNTAX OK, BRANCH
    130	000214	016002 	000016 			MOV	C.FILD(R0),R2	;GET LENGTH OF ERROR PART
    131	000220	016003 	000020 			MOV	C.FILD+2(R0),R3 ;GET ADDR OF ERROR PART
    132	000224	010275 	000004 			MOV	R2,@4(R5)	;STORE LENGTH OF ERROR PART
    133	000230	005475 	000006 			NEG	@6(R5)		;INDICATE ERROR
    134	000234	112324 			10$:	MOVB	(R3)+,(R4)+	;MOVE COMPRESSED LINE TO RETURNED LINE
    135	000236	077202 				SOB	R2,10$		;LOOP TO MOVE ALL OF COMPRESSED LINE
    136	000240	000407 				BR	30$		;GO CLEAR THE FOLLOWING BYTE
    137	000242	016075 	000002 	000004 	20$:	MOV	C.CMLD(R0),@4(R5) ;GET LENGTH OF COMPRESSED COMMAND LINE
    138	000250	016004 	000004 			MOV	C.CMLD+2(R0),R4 ;GET ADDRESS OF COMPRESSED COMMAND LINE
    139	000254	067504 	000004 			ADD	@4(R5),R4	;COMPUTE ADDRESS OF BYTE PAST LAST CHAR.
    140	000260	105024 			30$:	CLRB	(R4)+		;MOVE NULL TO END COMMAND LINE
    141	000262	000207 			100$:	RETURN			;RETURN
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 3


    143					;+
    144					; **-SCANI/SCANO-SCAN FOR INPUT/OUTPUT FILE SPECIFICATION
    145					;
    146					; THIS ROUTINE SCANS A COMMAND LINE FOR THE NEXT INPUT OR OUTPUT FILE
    147					; SPECIFICATION VIA THE SYSTEM LIBRARY ROUTINE CSI$2.  THE ROUTINES BLDSWT
    148					; AND SYNTX MUST HAVE BEEN PREVIOUSLY CALLED TO SET UP THE SWITCH TABLE
    149					; AND TO DO THE SYNTAX ANALYSIS.  THE SCAN ROUTINE RETURNS THE REQUESTED
    150					; INPUT/OUTPUT SPECIFICATION PLUS ITS LENGTH AND AN INDICATOR IF A
    151					; SWITCH WAS SET.  A DEFAULT FILENAME AND TYPE OR JUST THE TYPE MAY BE
    152					; SPECIFIED WHERE THE TYPE CONSISTS OF A PERIOD AND THREE ASCII LETTERS.
    153					; AN ERROR IN THE LINE IS INDICATED BY RETURNING A NEGATIVE FILE
    154					; SPECIFICATION LENGTH.
    155					;
    156					; INPUTS:
    157					;
    158					;	2(R5) IS THE ADDRESS OF THE COMMAND LINE
    159					;	4(R5) IS THE ADDRESS OF THE LENGTH OF THE COMMAND LINE
    160					;	6(R5) IS THE ADDRESS FOR THE SWITCH INDICATOR
    161					;	10(R5) IS THE ADDRESS FOR THE FILE SPECIFICATION
    162					;	12(R5) IS THE ADDRESS FOR THE LENGTH OF THE FILE SPECIFICATION
    163					;	14(R5) IS THE ADDRESS OF A DEFAULT FILENAME/TYPE
    164					;	16(R5) IS THE ADDRESS OF THE LENGTH OF THE DEFAULT FILENAME/TYPE
    165					;	20(R5) IS THE ADDRESS OF THE SUCCESS/ERROR CODE
    166					;
    167					; OUTPUTS:
    168					;
    169					;	@2(R5) CONTAINS THE COMMAND LINE
    170					;	@4(R5) CONTAINS THE LENGTH OF THE COMMAND LINE
    171					;	@6(R5) CONTAINS THE SWITCH INDICATOR
    172					;		BITS 0-4 INDICATE SWITCHES THAT ARE SET
    173					;			(BIT 0=1 INDICATES SWITCH 1 WAS SET, ETC.)
    174					;	@10(R5) CONTAINS THE FILE SPECIFICATION
    175					;	@20(R5) INDICATES THE FOLLOWING:
    176					;		>0 = LENGTH OF VALID FILE SPECIFICATION
    177					;		-1 = SWITCH ERROR
    178					;		-2 = NO FILENAME OR DEFAULT FILENAME SPECIFIED
    179					;		-3 = NO FILE TYPE OR DEFAULT TYPE SPECIFIED
    180					;		-4 = ASTERISK INCLUDED AS PART OF FILENAME
    181					;
    182					;
    183					;
    184					;  MODIFICATIONS:
    185					;
    186					; NO		DATE		PROGRAMMER		PURPOSE
    187					; --		----		----------		-------
    188					;
    189					; 01		16-NOV-76	K.D. MORSE		INCLUDE ANY LENGTH
    190					;							DEFAULT FILE TYPE.
    191					; 02		16-NOV-76	K.D. MORSE		READ NEW SWITCH
    192					;							VALUE TABLE FORMAT.
    193					;
    194					;
    195					;-
    196	000264	112767 	000001 	000000G	SCANI::	MOVB	#CS.INP,CSIBLK+C.TYPR ;SET TYPE TO INPUT FILE
    197	000272	000403 				BR	CONT		;BRANCH TO AVOID RESETTING TYPE TO OUTPUT
    198	000274	112767 	000002 	000000G	SCANO::	MOVB	#CS.OUT,CSIBLK+C.TYPR ;SET TYPE TO OUTPUT FILE
    199	000302	012775 	000001 	000020 	CONT:	MOV	#1,@20(R5)	;SET SUCCESS CODE
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 3-1


    200	000310	005075 	000012 			CLR	@12(R5)		;INITIALIZE FILE SPECIFICATION LENGTH
    201	000314	005075 	000006 			CLR	@6(R5)		;INITIALIZE SWITCH/ERROR CODE STORAGE
    202	000320	012700 	000000G			MOV	#SWTVAL,R0	;INITIALIZE SWITCH VALUES
    203	000324	105720 			5$:	TSTB	(R0)+		;IS THERE A VALUE TYPE SPECIFIED?
    204	000326	001410 				BEQ	7$		;NO, BRANCH
    205	000330	112002 				MOVB	(R0)+,R2	;YES, FIND NUMBER OF BYTES TO CLEAR
    206	000332	012003 				MOV	(R0)+,R3	;GET ADDRESS OF BYTES TO CLEAR
    207	000334	105023 			6$:	CLRB	(R3)+		;CLEAR A BYTE
    208	000336	077202 				SOB	R2,6$		;CONTINUE FOR THIS SWITCH VALUE
    209	000340	005710 				TST	(R0)		;++02 MORE THAN ONE VALUE FOR THIS SWITCH?
    210	000342	001370 				BNE	5$		;++02 YES, GO CLEAR IT
    211	000344	005720 				TST	(R0)+		;++02 NO, LOOK FOR NEXT SWITCH
    212	000346	000766 				BR	5$		;CHECK FOR ANOTHER SWITCH VALUE
    213	000350	012700 	000000G		7$:	MOV	#CSIBLK,R0	;GET ADDRESS OF CONTROL BLOCK
    214	000354	016560 	000002 	000004 		MOV	2(R5),C.CMLD+2(R0) ;GET ADDRESS OF COMMAND LINE
    215	000362	017560 	000004 	000002 		MOV	@4(R5),C.CMLD(R0) ;GET LENGTH OF COMMAND LINE
    216	000370					CSI$2	R0,,#SWTBL	;GET FILENAME
    217	000402	103560 				BCS	90$		;SWITCH ERROR
    218	000404	116002 	000001 			MOVB	C.STAT(R0),R2	;GET STATUS BYTE
    219					;
    220					; BUILD FILE SPECIFICATION TO BE RETURNED
    221					;
    222					; GET DEVICE
    223					;
    224	000410	016502 	000010 		10$:	MOV	10(R5),R2	;GET ADDRESS FOR FILE SPECIFICATION
    225	000414	016003 	000010 			MOV	C.DEVD+2(R0),R3	;GET DEVICE NAME ADDRESS
    226	000420	016004 	000006 			MOV	C.DEVD(R0),R4	;GET DEVICE NAME LENGTH
    227	000424	003004 				BGT	18$		;BRANCH IF ZERO LENGTH
    228	000426	012703 	000000G			MOV	#DEFDEV,R3	;GET DEFAULT DEVICE ADDRESS
    229	000432	012704 	000002 			MOV	#2,R4		;SET LENGTH OF DEFAULT DEVICE
    230	000436	060475 	000012 		18$:	ADD	R4,@12(R5)	;ADD DEVICE LENGTH TO FILE SPEC. LENGTH
    231	000442	112322 			15$:	MOVB	(R3)+,(R2)+	;MOVE DEVICE INTO FILE SPECIFICATION PARAMETER
    232	000444	077402 				SOB	R4,15$		;LOOP UNTIL ALL OF LENGTH IS MOVED
    233	000446	112722 	000000G			MOVB	#COL,(R2)+	;MOVE IN A COLON
    234	000452	005275 	000012 			INC	@12(R5)		;ADD ONE TO SPEC. LENGTH FOR COLON
    235					;
    236					; GET DIRECTORY
    237					;
    238	000456	016004 	000012 		20$:	MOV	C.DIRD(R0),R4	;GET LENGTH OF DIRECTORY
    239	000462	001406 				BEQ	30$		;ZERO LENGTH, NO DIRECTORY SPECIFIED
    240	000464	060475 	000012 			ADD	R4,@12(R5)	;ADD DIRECTORY LENGTH TO FILE SPEC. LENGTH
    241	000470	016003 	000014 			MOV	C.DIRD+2(R0),R3	;GET ADDRESS OF DIRECTORY
    242	000474	112322 			25$:	MOVB	(R3)+,(R2)+	;MOVE DIRECTORY TO FILE SPECIFICATION
    243	000476	077402 				SOB	R4,25$		;LOOP UNTIL ALL OF LENGTH IS MOVED
    244					;
    245					; GET FILENAME
    246					;
    247	000500	016004 	000016 		30$:	MOV	C.FILD(R0),R4	;GET LENGTH OF FILENAME
    248	000504	001470 				BEQ	75$		;ZERO LENGTH, NO FILENAME
    249	000506	060475 	000012 			ADD	R4,@12(R5)	;ADD FILENAME LENGTH TO FILE SPEC. LENGTH
    250	000512	016003 	000020 			MOV	C.FILD+2(R0),R3	;GET ADDRESS OF FILENAME
    251	000516	005001 				CLR	R1		;INITIALIZE INDICATOR TO NO FILE TYPE
    252					;
    253					; CHECK EACH CHARACTER FOR SEMICOLON OR PERIOD.
    254					; PERIOD SETS A FLAG THAT TYPE WAS SPECIFIED, I.E. R1=1.
    255					; SEMICOLON CAUSES A CHECK THAT TYPE WAS SPECIFIED.  IF IT WAS NOT,
    256					; THEN THE DEFAULT TYPE, IF SPECIFIED, IS INSERTED BEFORE THE VERSION.
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 3-2


    257					;
    258	000520	121327 	000000G			CMPB	(R3),#PER	;IS THERE ONLY A FILE TYPE, NO NAME?
    259	000524	001460 				BEQ	75$		;YES, CHECK IF CAN USE A DEFAULT NAME
    260	000526	121327 	000000G			CMPB	(R3),#SEMI	;IS THERE ONLY A VERSION, NO NAME?
    261	000532	001455 				BEQ	75$		;YES, CHECK FOR DEFAULT TYPE
    262	000534	121327 	000000G		35$:	CMPB	(R3),#PER	;IS CHARACTER A PERIOD?
    263	000540	001002 				BNE	40$		;NO, DON'T CHANGE INDICATOR
    264	000542	012701 	000001 			MOV	#1,R1		;SET INDICATOR--TYPE WAS FOUND
    265	000546	121327 	000000G		40$:	CMPB	(R3),#AST	;LOOK FOR ASTERISK IN FILENAME
    266	000552	001511 				BEQ	94$		;FOUND ONE, ERROR
    267	000554	121327 	000000G			CMPB	(R3),#SEMI	;IS VERSION SPECIFIED?
    268	000560	001402 				BEQ	50$		;IF SO, BRANCH TO CHECK FOR NO TYPE
    269	000562	112322 			45$:	MOVB	(R3)+,(R2)+	;MOVE IN FILENAME VALUE
    270	000564	077415 				SOB	R4,35$		;LOOP UNTIL ALL OF LENGTH IS MOVED
    271					;
    272					; CHECK WHETHER OR NOT TO MOVE IN DEFAULT TYPE
    273					;
    274	000566	005701 			50$:	TST	R1		;WAS AN EXPLICIT TYPE SPECIFIED?
    275	000570	001021 				BNE	60$		;YES, BRANCH
    276	000572	010446 				MOV	R4,-(SP)	;++01 SAVE NUMBER OF CHARS LEFT TO MOVE
    277	000574	017504 	000016 			MOV	@16(R5),R4	;++01 GET DEFAULT LENGTH
    278	000600	001471 				BEQ	93$		;NO DEFAULT SPECIFIED, BRANCH
    279	000602	016501 	000014 			MOV	14(R5),R1	;++01 POINT TO DEFAULT FILENAME
    280	000606	122721 	000000G		51$:	CMPB	#PER,(R1)+	;++01 IS THIS THE TYPE?
    281	000612	001402 				BEQ	52$		;++01 YES, GO MOVE IT IN
    282	000614	077404 				SOB	R4,51$		;++01 KEEP LOOKING FOR TYPE
    283	000616	000462 				BR	93$		;++01 NO DEFAULT LENGTH, ERROR
    284	000620	005301 			52$:	DEC	R1		;++01 POINT TO PERIOD
    285	000622	060475 	000012 			ADD	R4,@12(R5)	;++01 INCREMENT LENGTH OF FILE SPECIFICATION
    286	000626	112122 			55$:	MOVB	(R1)+,(R2)+	;MOVE IN DEFAULT TYPE
    287	000630	077402 				SOB	R4,55$		;LOOP TO MOVE IN DEFAULT TYPE
    288	000632	012604 				MOV	(SP)+,R4	;RESET COUNT OF REMAINING FILENAME CHARS.
    289	000634	005704 			60$:	TST	R4		;IS THERE MORE FILENAME TO MOVE?
    290	000636	001351 				BNE	45$		;YES, BRANCH
    291					;
    292					; CHECK FOR A SWITCH
    293					;
    294	000640	005775 	000006 		73$:	TST	@6(R5)		;CHECK IF ERROR OCCURRED
    295	000644	001403 				BEQ	74$		;NO ERROR, BRANCH
    296	000646	017575 	000006 	000020 		MOV	@6(R5),@20(R5) 	;SET LENGTH TO ERROR SWITCH
    297	000654	105022 			74$:	CLRB	(R2)+		;INSERT NULL ON END OF FILE SPECIFICATION
    298	000656	016075 	000024 	000006 		MOV	C.MKW1(R0),@6(R5) ;SET SWITCH VALUE
    299	000664	000447 				BR	100$		;RETURN
    300					;
    301					; FILENAME NOT SPECIFIED.  INSERT DEFAULT FILENAME INTO SPECIFICATION.
    302					;
    303	000666	017501 	000016 		75$:	MOV	@16(R5),R1	;IS DEFAULT SPECIFIED?
    304	000672	001430 				BEQ	92$		;NO, ERROR
    305	000674	016503 	000014 			MOV	14(R5),R3	;GET DEFAULT FILENAME ADDRESS
    306	000700	122713 	000000G			CMPB	#PER,(R3)	;WAS ONLY TYPE WAS SPECIFIED?
    307	000704	001423 				BEQ	92$		;YES, CHECK FOR SPECIFIED TYPE
    308	000706	060175 	000012 			ADD	R1,@12(R5)	;NO, MOVE IN DEFAULT LENGTH
    309	000712	122713 	000000G		80$:	CMPB	#PER,(R3)	;FINISHED MOVING DEFAULT FILENAME?
    310	000716	001402 				BEQ	85$		;YES, BRANCH TO CHECK FOR TYPE
    311	000720	112322 				MOVB	(R3)+,(R2)+	;MOVE IN DEFAULT FILENAME
    312	000722	077105 				SOB	R1,80$		;LOOP TILL OF ALL NAME IS MOVED
    313	000724	160175 	000012 		85$:	SUB	R1,@12(R5)	;SUBTRACT OFF LENGTH OF DEFAULT TYPE
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 3-3


    314	000730	016003 	000020 		86$:	MOV	C.FILD+2(R0),R3	;REPLACE ADDRESS OF FILENAME TYPE
    315	000734	005001 				CLR	R1		;SET INDICATOR THAT TYPE IS NOT SPECIFIED
    316	000736	005704 				TST	R4		;IS THERE MORE FILENAME TO MOVE?
    317	000740	003275 				BGT	35$		;YES, GO MOVE INTO RETURNED FILE SPECIFICATION
    318	000742	000711 				BR	50$		;NO, CHECK FOR DEFAULT TYPE
    319					;
    320					;
    321					;	ERROR CODES
    322					;
    323					;
    324	000744	012775 	177777 	000020 	90$:	MOV	#-1,@20(R5)	;SWITCH ERROR
    325	000752	000414 				BR	100$		;RETURN
    326	000754	012775 	177776 	000006 	92$:	MOV	#-2,@6(R5)	;NEITHER FILENAME NOR DEFAULT SPECIFIED
    327	000762	000762 				BR	86$		;CHECK FOR TYPE
    328	000764	012604 			93$:	MOV	(SP)+,R4	;++01 RESTOR NUMBER OF CHARS. LEFT TO MOVE
    329	000766	012775 	177775 	000006 		MOV	#-3,@6(R5)	;NEITHER FILE TYPE NOR DEFAULT SPECIFIED
    330	000774	000717 				BR	60$		;CHECK FOR SWITCHES
    331	000776	012775 	177774 	000020 	94$:	MOV	#-4,@20(R5)	;ASTERISK FOUND IN FILENAME
    332	001004	000207 			100$:	RETURN			;RETURN
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 4


    334					;+
    335					;**-BLDSWT-BUILD SWITCH TABLE
    336					;
    337					; THIS ROUTINE BUILDS A SWITCH TABLE AND A SWITCH VALUE TABLE IN A FORMAT
    338					; ACCEPTABLE TO THE CSI$ ROUTINES.  A MAXIMUM OF TEN SWITCHES MAY BE
    339					; SPECIFIED IN A ONE-DIMENSIONAL BYTE ARRAY.  EACH SWITCH ENTRY CONSISTS
    340					; OF THE FOLLOWING BYTES.  THE FIRST TWO BYTES ARE THE ASCII LETTERS OF
    341					; THE SWITCH.  THE NEXT BYTE SPECIFIES THE NUMBER OF SWITCH VALUES.
    342					; FOR EACH SWITCH VALUE THERE ARE TWO DECRIPTOR BYTES.  THE FIRST SPECIFIES
    343					; THE TYPE OF SWITCH VALUE EXPECTED: A=ASCII, O=OCTAL, D=DECIMAL.  THE
    344					; SECOND BYTE IS THE LENGTH OF THE SWITCH VALUE (IN BYTES).
    345					;  (NOTE:  NUMERICAL VALUES SHOULD BE TWO BYTES LONG.)
    346					; THE CORRESPONDING MASK VALUE ARE AS FOLLOWS:  BIT 0 INDICATES THE FIRST
    347					; SWITCH OF THE TABLE, BIT 1 INDICATES THE SECOND SWITCH, ETC.  NEGATED
    348					; SWITCHES ARE NOT ALLOWED.  IF AN INVALID NUMBER OF SWITCHES IS SPECIFIED
    349					; THE VALUE IS RETURNED IN THE FIRST BYTE OF THE SWITCH ARRAY AND BLDSWT
    350					; RETURNS WITHOUT BUILDING A SWITCH TABLE.
    351					;
    352					; INPUTS:
    353					;
    354					;	2(R5) IS THE ADDRESS OF THE NUMBER OF SWITCHES SPECIFIED
    355					;	4(R5) IS THE ADDRESS OF THE ARRAY OF SWITCH ENTRIES
    356					;	6(R5) IS THE ADDRESS OF THE SUCCESS/ERROR CODE
    357					;	10(R5)-... ARE ADDRESSES FOR WHERE SWITCH VALUES WILL BE PLACED AS
    358					;		THEY ARE SCANNED IN A COMMAND LINE
    359					;
    360					; OUTPUTS:
    361					;
    362					;	IF ERROR OCCURS:
    363					;
    364					;		@6(R5) CONTAINS ONE OF THE FOLLOWING CODES:
    365					;			>0 = SUCCESS CODE
    366					;			-1 = ILLEGAL TYPE OF SWITCH VALUE
    367					;			-2 = ZERO LENGTH FOR SWITCH VALUE
    368					;			-3 = ILLEGAL NUMBER OF SWITCHES SPECIFIED
    369					;
    370					;		@2(R5) CONTAINS ONE OF THE FOLLOWING BASED ON THE ABOVE CODES:
    371					;			CODE=-1, THE ILLEGAL SWITCH TYPE
    372					;			CODE=-2, THE ILLEGAL SWITCH VALUE LENGTH
    373					;			CODE=-3, THE ILLEGAL NUMBER OF SWITCHES
    374					;
    375					;	IF NO ERROR OCCURS:
    376					;
    377					;		SWTBL CONTAINS A TABLE OF SWITCHES USABLE BY CSI$2.
    378					;		SWTVAL CONTAINS A SWITCH VALUE TABLE WITH THE APPROPRIATE
    379					;		       ENTRIES SET IN SWTBL.
    380					;
    381					;
    382					;
    383					;  MODIFICATIONS:
    384					;
    385					; NO		DATE		PROGRAMMER		PURPOSE
    386					; --		----		----------		-------
    387					;
    388					; 01		16-NOV-76	K.D. MORSE		TAKE MULTIPLE SWITCH VALUES
    389					; 02		15-FEB-77	K.D. MORSE		FIX DECIMAL VALUE BUG.
    390					;
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 4-1


    391					;
    392					;
    393					;-
    394	001006	012775 	000001 	000006 	BLDSWT:: MOV	#1,@6(R5)	;ASSUME SUCCESS CODE
    395	001014	027527 	000002 	000012 		CMP	@2(R5),#12	;CHECK FOR TOO MANY SWITCHES SPECIFIED
    396	001022	003073 				BGT	90$		;BRANCH ON TOO MANY
    397	001024	012767 	000000G	000022G		MOV	#SWTBL,CSIBLK+C.SWAD ;SET CONTROL BLOCK SWITCH TABLE ADDRESS
    398	001032	012702 	000000G			MOV	#SWTBL,R2	;GET ADDRESS OF SWITCH TABLE
    399	001036	017500 	000002 			MOV	@2(R5),R0	;GET NUMBER OF SWITCHES
    400	001042	003463 				BLE	90$		;ERROR, NO SWITCHES SPECIFIED
    401	001044	012704 	000000G			MOV	#SWTVAL,R4	;GET ADDRESS OF SWITCH VALUE TABLE
    402	001050	010503 				MOV	R5,R3		;GET ADDRESS OF PARAMETER LIST
    403	001052	062703 	000010 			ADD	#10,R3		;INCREMENT ADDRESS TO SWITCH VALUES
    404	001056	016501 	000004 			MOV	4(R5),R1	;GET ADDRESS OF SWITCHES
    405	001062	012767 	000001 	000000G		MOV	#1,MSKVAL	;INITIALIZE MASK VALUE
    406	001070	112122 			10$:	MOVB	(R1)+,(R2)+	;MOVE IN SWITCH NAME (FIRST CHARACTER)
    407	001072	112122 				MOVB	(R1)+,(R2)+	;MOVE IN SWITCH NAME (SECOND CHARACTER)
    408	001074	016722 	000000G			MOV	MSKVAL,(R2)+	;MOVE IN SWITCH MASK
    409	001100	005022 				CLR	(R2)+		;CLEAR ADDRESS OF WORD TO BE MASKED
    410	001102	010046 				MOV	R0,-(SP)	;++01 SAVE NUMBER OF SWITCHES
    411	001104	112100 				MOVB	(R1)+,R0	;++01 IS THERE A VALUE FOR THIS SWITCH?
    412	001106	001432 				BEQ	80$		;NO VALUE, DO NEXT SWITCH
    413	001110	010422 			30$:	MOV	R4,(R2)+	;SET SWITCH VALUE TABLE ADDR. IN SWITCH ENTRY
    414	001112	121127 	000101 		35$:	CMPB	(R1),#101	;IS THIS AN A?
    415	001116	001411 				BEQ	40$		;YES, GO SET ASCII TYPE OF VALUE
    416	001120	121127 	000104 			CMPB	(R1),#104	;IS THIS A D?
    417	001124	001411 				BEQ	50$		;YES, GO SET DECIMAL TYPE OF VALUE
    418	001126	121127 	000117 			CMPB	(R1),#117	;IS THIS AN O?
    419	001132	001033 				BNE	91$		;NO, THEN ERROR
    420	001134	112724 	000002 			MOVB	#2,(R4)+	;SET TYPE TO OCTAL
    421	001140	000405 				BR	60$		;TYPE SET, GO CHECK LENGTH
    422	001142	112724 	000001 		40$:	MOVB	#1,(R4)+	;SET TYPE TO ASCII
    423	001146	000402 				BR	60$		;TYPE SET, GO CHECK LENGTH
    424	001150	112724 	000003 		50$:	MOVB	#3,(R4)+	;++02 SET TYPE TO DECIMAL
    425	001154	105721 			60$:	TSTB	(R1)+		;INCREMENT POINTER
    426	001156	112124 				MOVB	(R1)+,(R4)+	;SET LENGTH
    427	001160	003426 				BLE	92$		;ERROR, ILLEGAL LENGTH
    428	001162	012324 				MOV	(R3)+,(R4)+	;SET LOCATION
    429	001164	077026 				SOB	R0,35$		;++01 REPEAT FOR EACH SWITCH VALUE
    430	001166	005024 				CLR	(R4)+		;CLEAR WORD TO END SWITCH VALUE TABLE
    431	001170	005014 				CLR	(R4)		;CLEAR POSSIBLE LEFT OVER ENTRY
    432	001172	000401 				BR	85$		;++01 GO CLEAN STACK
    433	001174	005022 			80$:	CLR	(R2)+		;++01 CLEAR ADDRESS OF SWITCH VALUE TABLE
    434	001176	012600 			85$:	MOV	(SP)+,R0	;++01 CLEAN STACK
    435	001200	006367 	000000G			ASL	MSKVAL		;INCREMENT SWITCH MASK
    436	001204	077047 				SOB	R0,10$		;LOOP UNTIL ALL SWITCHES BUILT INTO TABLE
    437	001206	005012 				CLR	(R2)		;CLEAR WORD AFTER TABLE
    438	001210	000421 				BR	100$		;RETURN
    439					;
    440					; ERROR CODES
    441					;
    442	001212	012775 	177775 	000006 	90$:	MOV	#-3,@6(R5)	;SET ERROR CODE FOR ILLEGAL # OF SWITCHES
    443	001220	000415 				BR	100$		;RETURN
    444	001222	012775 	177777 	000006 	91$:	MOV	#-1,@6(R5)	;ILLEGAL TYPE OF SWITCH VALUE
    445	001230	111175 	000002 			MOVB	(R1),@2(R5)	;RETURN TYPE AS FIRST BYTE
    446	001234	000406 				BR	94$		;++01 RETURN
    447	001236	012775 	177776 	000006 	92$:	MOV	#-2,@6(R5)	;SET ERROR CODE FOR SWITCH VALUE BUT TYPE SET
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 4-2


    448	001244	116175 	177777 	000002 		MOVB	-1(R1),@2(R5)	;RETURN LENGTH AS FIRST BYTE
    449	001252	005726 			94$:	TST	(SP)+		;++01 CLEAN STACK
    450	001254	000207 			100$:	RETURN			;RETURN
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 5


    452					;+
    453					;**-GETVER-GET VERSION
    454					;
    455					; THIS ROUTINE FINDS THE VERSION OF THE FILE OPENED VIA OPNFIL ON THE
    456					; USER-SUPPLIED LUN.  THIS VERSION NUMBER IS DECREMENTED BY ONE IF
    457					; THE PREVIOUS VERSION IS REQUESTED.  IT IS THEN CONVERTED TO AN ASCII
    458					; STRING.  AN ERROR CODE IS RETURNED IF THE VERSION WOULD BE LESS THAN
    459					; OR EQUAL TO ZERO.
    460					;
    461					; INPUTS:
    462					;
    463					;	2(R5) IS THE ADDRESS OF THE LUN
    464					;	4(R5) IS THE ADDRESS OF THE RETURNED VERSION NUMBER
    465					;	6(R5) IS THE ADDRESS OF THE LENGTH OF THE RETURNED VERSION NUMBER
    466					;	10(R5) IS THE ADDRESS OF THE INDICATOR FOR THE TYPE OF VERSION
    467					;		0 = CURRENT VERSION
    468					;	       -1 = PREVIOUS VERSION
    469					;	12(R5) IS THE ADDRESS OF THE SUCCESS/ERROR CODE
    470					;
    471					; OUTPUTS:
    472					;
    473					;	@4(R5) IS THE ASCII VALUE OF THE VERSION REQUESTED
    474					;	@6(R5) IS THE LENGTH OF THE ASCII VERSION
    475					;	@12(R5) IS ONE OF THE FOLLOWING:
    476					;		>0 = ERROR, FILE HAS NO PREVIOUS VERSION
    477					;		<0 = SUCCESS
    478					;
    479					;-
    480	001256	012775 	000001 	000012 	GETVER:: MOV	#1,@12(R5)	;ASSUME SUCCESS
    481	001264	004767 	000000G			CALL	LUNFDB		;GET THE FDB ADDRESS FOR THIS LUN
    482	001270	062700 	000000G			ADD	#F.FNB,R0	;GET FILENAME BLOCK ADDRESS
    483	001274	016001 	000000G			MOV	N.FVER(R0),R1	;GET VERSION NUMBER OF FILE OPEN ON THIS LUN
    484	001300	067501 	000010 			ADD	@10(R5),R1	;COMPUTE VERSION NUMBER DESIRED
    485	001304	003412 				BLE	90$		;ERROR, NO PREVIOUS NUMBER
    486	001306	016500 	000004 			MOV	4(R5),R0	;GET RETURN ADDRESS FOR ASCII VERSION
    487	001312	005002 				CLR	R2		;INDICATE SUPPRESS ZEROS
    488	001314	004767 	000000G			CALL	$CBVER		;CONVERT BINARY TO ASCII
    489	001320	166500 	000004 			SUB	4(R5),R0	;GET LENGTH OF ASCII STRING
    490	001324	010075 	000006 			MOV	R0,@6(R5)	;RETURN ASCII STRING LENGTH
    491	001330	000402 				BR	100$		;RETURN
    492					;
    493					; ERROR CODES
    494					;
    495	001332	005475 	000012 		90$:	NEG	@12(R5)	;ERROR, NO PREVIOUS FILE VERSION
    496	001336	000207 			100$:	RETURN			;RETURN
    497		000001 				.END
GETCML	MACRO M1110  22-AUG-78 02:22  PAGE 5-1
SYMBOL TABLE

AST   = ****** GX	C.DIRD= 000012   	GE.BIF= 177775   	G.ERR = 000140   	SWTVAL= ****** GX
BLDSWT  001006RG 	C.DSDS= 000006   	GE.CLO= 000004   	G.ISIZ= 000020   	SYNTX   000156RG
COL   = ****** GX	C.FILD= 000016   	GE.COM= 000001   	G.MODE= 000141   	S.FDB = 000140
CONT    000302R  	C.MKW1= 000024   	GE.CON= 000020   	G.PSDS= 000142   	S.FNAM= 000006
CSIBLK= ****** GX	C.MKW2= 000026   	GE.EOF= 177766   	G.SIZE= 000224   	S.FNB = 000036
CS.DIF= 000002   	C.SIZE= 000054   	GE.IND= 000002   	LUNFDB= ****** GX	S.FNBW= 000017
CS.DVF= 000004   	C.STAT= 000001   	GE.IOR= 177777   	MSKVAL= ****** GX	S.FNTY= 000004
CS.EQU= 000040   	C.SWAD= 000022   	GE.LC = 000010   	N.FVER= ****** GX	S.FTYP= 000002
CS.INP= 000001   	C.TYPR= 000000   	GE.MDE= 177774   	PAR$$$= 000000   	S.NFEN= 000020
CS.MOR= 000020   	DEFDEV= ****** GX	GE.OPR= 177776   	PER   = ****** GX	$CBVER= ****** GX
CS.NMF= 000001   	F.FNB = ****** GX	GE.RBG= 177730   	SCANI   000264RG 	.CSI1 = ****** G
CS.OUT= 000002   	GCLBLK= ****** GX	GE.SIZ= 000040   	SCANO   000274RG 	.CSI2 = ****** G
CS.WLD= 000010   	GETCML  000000RG 	G.CMLD= 000146   	SEMI  = ****** GX	.GCML1= ****** G
C.CMLD= 000002   	GETVER  001256RG 	G.DPRM= 000160   	SWTBL = ****** GX	...TPC= 000140
C.DEVD= 000006

. ABS.	000000	   000
      	001340	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  5275 WORDS  ( 21 PAGES)
DYNAMIC MEMORY:  5940 WORDS  ( 22 PAGES)
ELAPSED TIME:  00:00:16
OBJ$:GETCML.OBI,LIS$:GETCML.LST/-SP=SRC$:GETCML.MAC
