DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36
TABLE OF CONTENTS

    23-   30	READ A BLOCK SYNCHRONOUSLY
    24-  130	READ A BLOCK ASYNCHRONOUSLY
    25-  198	READ A BLOCK ASYNCHRONOUSLY FROM OUTPUT
    26-  232	WRITE A BLOCK TO THE OUTPUT DEVICE
    27-  339	BUFFER CHECK ROUTINE
    28-  373	WAIT ROUTINES
    29-  451	WAIT ON DISK READ AND CHECK FOR ERRORS
    30-  486	WAIT ON DISK OUTPUT READ AND CHECK FOR ERRORS
    31-  522	WAIT ON TAPE READ AND CHECK FOR ERRORS
    32-  606	QIO CHECK ROUTINE
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 3


      1	000000					$BEGIN	DSCIO,0024,<BASIC I/O FUNCTIONS FOR DSC>
						.TITLE	DSCIO	X0024 - BASIC I/O FUNCTIONS FOR DSC
						.IDENT	"X0024"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  1-NOV-76  11:14
     25					; GEORGE RITTENBURG APR-14-77 MODIFIED FOR VFY/CMP FOR DISK TO/FROM TAPE
     26
     27
     28						.MCALL	QIOW$S,QIO$S,WTSE$S,CLEF$S
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 4
READ A BLOCK SYNCHRONOUSLY

     30						.SBTTL	READ A BLOCK SYNCHRONOUSLY
     31
     32					;+
     33					;
     34					; *** - $RDW1B	READ 1 512 BYTE BLOCK AND WAIT FOR COMPLETION
     35					;
     36					; THIS ROUTINE READS A 512 BYTE BLOCK FROM THE INPUT DEVICE AND RETURNS
     37					; WHEN THE TRANSFER HAS COMPLETED.
     38					;
     39					; INPUTS:
     40					;
     41					;	R2, R3 = HIGH AND LOW LBN
     42					;	R4 =	BUFFER CONTROL BLOCK ADDRESS
     43					;
     44					; OUTPUTS:
     45					;
     46					;	I/O STATUS IN BUFFER CONTROL BLOCK
     47					;	R1 =	BYTE COUNT TRANSFERRED
     48					;	R5 =	BUFFER ADDRESS
     49					;	CC - C	CLEAR IF NO ERRORS
     50					;		SET IF ERROR
     51					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
     52					;
     53					;
     54					; *** - $RDWAT	READ A BLOCK AND WAIT FOR COMPLETION
     55					;
     56					; THIS ALTERNATE ENTRY POINT ALLOWS A BLOCK OF ARBITRARY SIZE TO BE
     57					; READ. INPUTS AND OUTPUTS ARE THE SAME AS FOR $RDW1B PLUS:
     58					;
     59					; INPUTS:
     60					;
     61					;	R1 = BYTE COUNT TO READ
     62					;
     63					;
     64					; *** - $RDWTA	READ AND WAIT WITH ALTERNATE BUFFER
     65					;
     66					; THIS ROUTINE READS A BLOCK OF THE INDICATED SIZE INTO THE INDICATED
     67					; BUFFER. INPUTS AND OUTPUTS ARE THE SAME AS FOR $RDWAT PLUS:
     68					;
     69					; INPUTS:
     70					;
     71					;	R5 = BUFFER ADDRESS
     72					;
     73					;
     74					; *** - $RDWLN	READ A BLOCK FROM THE SPECIFIED LUN
     75					;
     76					; THIS ROUTINE READS A 512 BYTE BLOCK FROM THE DEVICE ASSIGNED TO THE
     77					; SPECIFIED LUN INTO THE SPECIFIED BUFFER. INPUTS AND OUTPUTS
     78					; ARE THE SAME AS FOR $RDW1B PLUS:
     79					;
     80					; INPUTS:
     81					;
     82					;	R0 = LUN
     83					;
     84					;-
     85
     86	000000				$RDWLN::
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 4-1
READ A BLOCK SYNCHRONOUSLY

     87	000000					PUSH R0				; SAVE LUN
     88	000002					LET R1 := #512.			; SET BYTE COUNT
     89	000006					LET R5 := R4 + #B.SIZ		; USE BUFFER FOLLOWING BCB
     90	000014					GOTO RDCOM
     91
     92	000016				$RDW1B::
     93	000016					LET R1 := #512.			; GET DEFAULT BYTE COUNT
     94
     95	000022				$RDWAT::
     96	000022					LET R5 := R4 + #B.SIZ		; DEFAULT BUFFER FOLLOWS BCB
     97
     98	000030				$RDWTA::
     99	000030					IF #KY.NIP SET.IN $FLAG1
    100	000040					  IF #KY.TAP SET.IN $OFLAG AND R1 HI 80.
    101	000056						GOTO RDCOMY
    102	000060					  ELSE
    103	000062						GOTO RDCOMX
    104	000064					  END
    105	000064					END
    106	000064					IF #KY.TAP SET.IN $IFLAG AND R1 HI #80.
    107	000102						GOTO RDCOMY
    108	000104					END
    109	000104				RDCOMX:
    110	000104					PUSH #INLUN			; DEFAULT TO INPUT LUN
    111	000110				RDCOM:	$CALL $BUFCK <,,,,R4>		; CHECK IF BUFFER AVAILABLE
    112	000114					POP R0				; R0 = LUN
    113	000116					QIOW$S	#IO.RLB,R0,#EFN,,R4,,<R5,R1,,R2,R3>
    114	000160					LET B.STAT(R4) := #1		; MARK DATA IN BUFFER
    115	000166					ON.ERROR THEN LET (R4) := @#$DSW ; RETURN DIRECTIVE ERROR
    116	000174					REPEAT				; MAKE SURE TRANSFER IS REALLY COMPLETE
    117	000174					  IFB (R4) NE #0 LEAVE LOOP
    118	000200					  WTSE$S #EFN			; ELSE WAS ANOTHER COMPLETION
    119	000212					  CLEF$S #EFN			; SO TRY AGAIN
    120	000224					END LOOP
    121	000226					IFB (R4) EQ #IE.EOT THEN LET (R4) := #1 ; IGNORE EOT ON INPUT
    122	000240					LET R1 := 2(R4)			; RETURN BYTE COUNT TRANSFERRED
    123	000244					RETURN (R4)			; RETURN I/O STATUS
    124	000252				RDCOMY:
    125	000252					$CALL $READA
    126	000256					$CALL  $WAITI
    127	000262					LET R1 := 2(R4)
    128	000266					RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 5
READ A BLOCK ASYNCHRONOUSLY

    130						.SBTTL	READ A BLOCK ASYNCHRONOUSLY
    131
    132					;+
    133					;
    134					; *** - $READ	READ A BLOCK FROM THE INPUT DEVICE
    135					;
    136					; THIS ROUTINE INITIATES A READ OPERATION FROM THE INPUT DEVICE.
    137					;
    138					; INPUTS:
    139					;
    140					;	R1 = BYTE COUNT
    141					;	R2, R3 = HIGH AND LOW LBN
    142					;	R4 = BUFFER CONTROL BLOCK
    143					;
    144					; OUTPUTS:
    145					;
    146					;	R5 = BUFFER ADDRESS
    147					;	CC - C	CLEAR IF NO ERRORS
    148					;		SET IF DIRECTIVE ERROR
    149					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    150					;
    151					;
    152					; *** - $READA	READ A BLOCK WITH ALTERNATE I/O BUFFER
    153					;
    154					; THIS ROUTINE INITIATES A READ OPERATION WITH AN ALTERNATE I/O BUFFER.
    155					; INPUTS AND OUTPUTS ARE THE SAME AS FOR $READ PLUS:
    156					;
    157					; INPUTS:
    158					;
    159					;	R5 = BUFFER ADDRESS
    160					;
    161					;
    162					; *** - $LINKI	LINK BUFFER CONTROL BLOCK
    163					;
    164					; THIS ENTRY POINT LINKS THE INDICATED BUFFER CONTROL BLOCK ONTO
    165					; THE INPUT WAIT LIST.
    166					;
    167					; INPUTS:
    168					;
    169					;	R4 = BCB ADDRESS
    170					;
    171					; OUTPUTS:
    172					;
    173					;	BUFFER LINKED UP
    174					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    175					;
    176					;-
    177
    178	000270				$READ::
    179	000270					LET R5 := R4 + #B.SIZ		; DEFAULT BUFFER ADDRESS
    180
    181	000276				$READA::
    182	000276					$CALL $BUFCK <,,,,R4>		; CHECK THAT BUFFER IS AVAILABLE
    183	000302					QIO$S	#IO.RLB,#INLUN,#EFN,,R4,,<R5,R1,,R2,R3>
    184	000346					ON.ERROR
    185	000350					  LET (R4) := @#$DSW
    186	000354					ELSE
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 5-1
READ A BLOCK ASYNCHRONOUSLY

    187	000356					  LET B.STAT(R4) := #3		; MARK READ IN PROGRESS
    188	000364				$LINKI::
    189	000364					  LET R0 := #$IWAIT-B.LINK	; GET HEAD OF WAIT LIST
    190	000370					  WHILE B.LINK(R0) NE #0
    191	000376					    LET R0 := B.LINK(R0)	; SEARCH FOR LAST ENTRY
    192	000402					  END LOOP
    193	000404					  LET B.LINK(R0) := R4		; LINK BCB ONTO CHAIN
    194	000410					  LET B.LINK(R4) := #0
    195	000414					END
    196	000414					RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 6
READ A BLOCK ASYNCHRONOUSLY FROM OUTPUT

    198						.SBTTL	READ A BLOCK ASYNCHRONOUSLY FROM OUTPUT
    199
    200					;+
    201					;
    202					; *** - $READO	READ A BLOCK FROM THE OUTPUT DEVICE
    203					;
    204					; THIS ROUTINE INITIATES A READ OPERATION FROM THE INPUT DEVICE.
    205					;
    206					; INPUTS:
    207					;
    208					;	R1 = BYTE COUNT
    209					;	R2, R3 = HIGH AND LOW LBN
    210					;	R4 = BUFFER CONTROL BLOCK
    211					;	R5 = BUFFER ADDRESS
    212					;
    213					; OUTPUTS:
    214					;
    215					;	CC - C	CLEAR IF NO ERRORS
    216					;		SET IF DIRECTIVE ERROR
    217					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    218					;
    219					;-
    220
    221	000416				$READO::
    222	000416					$CALL $BUFCK <,,,,R4>		; CHECK THAT BUFFER IS AVAILABLE
    223	000422					QIO$S	#IO.RLB,#OUTLUN,#EFN,,R4,,<R5,R1,,R2,R3>
    224	000466					ON.ERROR
    225	000470					  LET (R4) := @#$DSW
    226	000474					ELSE
    227	000476					  LET B.STAT(R4) := #3		; MARK READ IN PROGRESS
    228	000504					  GOTO $LINKO			; LINK ONTO OUTPUT WAIT LIST
    229	000506					END
    230	000506					RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 7
WRITE A BLOCK TO THE OUTPUT DEVICE

    232						.SBTTL	WRITE A BLOCK TO THE OUTPUT DEVICE
    233
    234					;+
    235					;
    236					; *** - $WRI1B	WRITE 1 BLOCK TO THE OUTPUT DEVICE
    237					;
    238					; THIS ROUTINE INITIATES A 1 BLOCK WRITE.
    239					;
    240					; INPUTS:
    241					;
    242					;	R2, R3 = HIGH AND LOW LBN
    243					;	R4 = BUFFER CONTROL BLOCK
    244					;
    245					; OUTPUTS:
    246					;
    247					;	R1 = BYTE COUNT (512)
    248					;	R5 = BUFFER ADDRESS
    249					;	CC - C	CLEAR IF NO ERRORS
    250					;		SET IF DIRECTIVE ERROR
    251					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    252					;
    253					;
    254					; *** - $WRITE	WRITE A BLOCK
    255					;
    256					; THIS ROUTINE INITIATES A WRITE OPERATION TO THE OUTPUT DEVICE.
    257					; INPUTS AND OUTPUTS ARE AS ABOVE, PLUS:
    258					;
    259					; INPUTS:
    260					;
    261					;	R1 = BYTE COUNT
    262					;
    263					;
    264					; *** - $WRITA	WRITE ALTERNATE BUFFER
    265					;
    266					; THIS ROUTINE INITIATES A WRITE OPERATION USING THE ALTERNATE
    267					; BUFFER ADDRESS SPECIFIED. INPUTS AND OUTPUTS ARE AS ABOVE, PLUS:
    268					;
    269					; INPUTS:
    270					;
    271					;	R5 = BUFFER ADDRESS
    272					;
    273					;
    274					; *** - $WEOF	WRITE END OF FILE MARK ON TAPE
    275					;
    276					; THIS ROUTINE WRITES AN END OF FILE MARK ON THE OUTPUT TAPE.
    277					;
    278					; INPUTS:
    279					;
    280					;	R4 = BUFFER CONTROL BLOCK
    281					;
    282					; OUTPUTS:
    283					;
    284					;	CC - C	CLEAR IF NO ERRORS
    285					;		SET IF DIRECTIVE ERROR
    286					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    287					;
    288					;
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 7-1
WRITE A BLOCK TO THE OUTPUT DEVICE

    289					; *** - $LINKO	LINK BUFFER CONTROL BLOCK
    290					;
    291					; THIS ENTRY POINT LINKS THE INDICATED BUFFER CONTROL BLOCK ONTO
    292					; THE OUTPUT WAIT LIST.
    293					;
    294					; INPUTS:
    295					;
    296					;	R4 = BCB ADDRESS
    297					;
    298					; OUTPUTS:
    299					;
    300					;	BUFFER LINKED UP
    301					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    302					;
    303					;-
    304
    305	000510				$WEOF::
    306	000510					QIO$S	#IO.EOF,#OUTLUN,#EFN,,R4
    307	000554					GOTO LINKB
    308
    309	000556				$WRI1B::
    310	000556					LET R1 := #512.			; DEFAULT BYTE COUNT
    311
    312	000562				$WRITE::
    313	000562					LET R5 := R4 + #B.SIZ		; DEFAULT BUFFER ADDRESS
    314
    315	000570				$WRITA::
    316					;
    317					; IF OUTPUT IS MAGTAPE, COUNT THE BLOCK. IF IT IS AT END OF TAPE,
    318					; DO A REEL SWITCH BEFORE WRITING THE BLOCK, UNLESS THIS IS A LABEL.
    319					;
    320	000570					IF #KY.TAP SET.IN $OFLAG
    321	000600					  IF #KY.EOT SET.IN $OFLAG AND R1 GT #80. THEN $CALL $SWITO
    322	000622					  LET $BLCNT := $BLCNT + #1	; BUMP BLOCK COUNT
    323	000626					END
    324	000626					QIO$S	#IO.WLB,#OUTLUN,#EFN,,R4,,<R5,R1,,R2,R3>
    325	000672				LINKB:	ON.ERROR
    326	000674					  LET (R4) := @#$DSW
    327	000700					ELSE
    328	000702					  LET B.STAT(R4) := B.STAT(R4) + #2 ; MARK TRANSFER IN PROGRESS
    329	000710				$LINKO::
    330	000710					  LET R0 := #$OWAIT-B.LINK	; GET HEAD OF WAIT LIST
    331	000714					  WHILE B.LINK(R0) NE #0
    332	000722					    LET R0 := B.LINK(R0)	; SEARCH FOR LAST ENTRY
    333	000726					  END LOOP
    334	000730					  LET B.LINK(R0) := R4		; LINK BCB ONTO CHAIN
    335	000734					  LET B.LINK(R4) := #0
    336	000740					END
    337	000740					RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 8
BUFFER CHECK ROUTINE

    339						.SBTTL	BUFFER CHECK ROUTINE
    340
    341					;+
    342					;
    343					; *** - $BUFCK	CHECK IF BUFFER IS AVAILABLE
    344					;
    345					; THIS ROUTINE MAKES SURE THAT A PARTICULAR BUFFER IS AVAILABLE
    346					; TO BE READ INTO. IF A WRITE IS IN PROGRESS, IT WAITS FOR COMPLETION.
    347					;
    348					; INPUTS:
    349					;
    350					;	R4 = BUFFER CONTROL BLOCK ADDRESS
    351					;
    352					; OUTPUTS:
    353					;
    354					;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
    355					;
    356					;-
    357
    358	000742				$BUFCK::
    359	000742					LET R0 := B.STAT(R4)		; CHECK THE BUFFER STATUS
    360	000746					IF RESULT IS NE			; IF BUFFER BUSY
    361	000750					  IF R0 EQ #2			; CHECK FOR WRITE IN PROGRESS
    362	000756					    $CALL $WAITO <,,,,R4>	; WAIT IT OUT
    363	000762					    ON.ERROR
    364	000764						LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
    365	000772						ERROR ER.IOR	;SEND ERROR MESSAGE
    366	000774					    END
    367	000774					  ELSE
    368	000776					    FATAL <INCONSISTENT USE OF I/O BUFFER>
    369	001000					  END
    370	001000					END
    371	001000					RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 9
WAIT ROUTINES

    373						.SBTTL	WAIT ROUTINES
    374
    375					;+
    376					;
    377					; *** - $WAITI	WAIT FOR INPUT
    378					;
    379					; THIS ROUTINE WAITS FOR COMPLETION ON THE INDICATED BUFFER CONTROL
    380					; BLOCK. IT ALSO CHECKS COMPLETION ON ALL READS PRECEDING AND RETURNS
    381					; ANY ERRORS.
    382					;
    383					; INPUTS:
    384					;
    385					;	R4 = BUFFER CONTROL BLOCK TO WAIT ON
    386					;
    387					; OUTPUTS:
    388					;
    389					;	CC - C	CLEAR IF NO ERRORS
    390					;		SET IF ANY I/O ERROR OCCURRED
    391					;	R0 = LAST BCB WAITED ON (THE ONE WITH ERROR, IF ANY)
    392					;	OTHER REGISTERS PRESERVED
    393					;
    394					; *** - $WAITO	WAIT FOR OUTPUT
    395					;
    396					; THIS ROUTINE WAITS FOR COMPLETION ON THE SPECIFIED OUTPUT TRANSFER.
    397					; INPUTS AND OUTPUTS ARE THE SAME AS ABOVE.
    398					;
    399					;-
    400
    401	001002				$WAITI::
    402	001002					LET R0 := #$IWAIT		; INPUT WAIT LIST
    403	001006					GOTO WCOM
    404
    405	001010				$WAITO::
    406	001010					LET R0 := #$OWAIT		; OUTPUT WAIT LIST
    407
    408	001014				WCOM:	PUSH R5				; SAVE R5
    409	001016					PUSH R0				; SAVE LIST HEAD
    410	001020					LET R0 := (R0)			; POINT TO FIRST BCB
    411	001022					REPEAT
    412	001022					  REPEAT
    413	001022					    IFB (R0) NE #0 LEAVE LOOP
    414	001026					    WTSE$S #EFN
    415	001040					    CLEF$S #EFN
    416	001052					  END LOOP
    417	001054					  LET B.STAT(R0) := B.STAT(R0) - #2 ; MARK TRANSFER COMPLETED
    418	001062					  LET @(SP) := B.LINK(R0)	; UNLINK COMPLETED BCB
    419	001070				RETRY:	  IFB (R0) LT #0
    420	001074					    IFB (R0) EQ #IE.EOT		; CHECK FOR END OF TAPE CONDITION
    421	001102					      LET (R0) :B= #1		; IGNORE IT, BUT FLAG FOR OUTPUT TAPE
    422	001106					      IF (SP) EQ #$OWAIT AND #KY.TAP SET.IN $OFLAG
    423	001124						LET $OFLAG := $OFLAG SET.BY #KY.EOT
    424	001132					      END
    425	001132					    ELSE
    426	001134						IF #KY.NIP SET.IN $FLAG1
    427	001144						   LET R5 := $OFLAG
    428	001150						ELSE
    429	001152						   LET R5 := $IFLAG
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 9-1
WAIT ROUTINES

    430	001156						END
    431	001156					      IFB (R0) EQ #IE.EOF AND (SP) EQ #$IWAIT AND #KY.TAP SET.IN R5
    432	001200						IF #KY.EOT SET.IN $IFLAG LEAVE LOOP ; DON'T RECURSE REEL SWITCH
    433	001210						LET $IFLAG := $IFLAG SET.BY #KY.EOT
    434	001216						$CALL $SWITI		; SWITCH REELS ON EOF
    435	001222						IFB (R0) LT #0 LEAVE LOOP ; OUT IF ERROR
    436	001226					      ELSE
    437	001230						LEAVE LOOP
    438	001232					      END
    439	001232					    END
    440	001232					  END
    441	001232					  IF R0 EQ R4 LEAVE LOOP
    442	001236					  LET R0 := B.LINK(R0)		; LINK TO NEXT BCB
    443	001242					  IF RESULT IS EQ
    444	001244					    FATAL <BCB NOT IN LIST>
    445	001246					  END
    446	001246					END LOOP
    447	001250	005726 				TST (SP)+			; CLEAN THE STACK
    448	001252					POP R5				; RESTORE R5
    449	001254					RETURN (R0)
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 10
WAIT ON DISK READ AND CHECK FOR ERRORS

    451						.SBTTL	WAIT ON DISK READ AND CHECK FOR ERRORS
    452
    453					;+
    454					;
    455					; *** - $DWCK	WAIT AND CHECK FOR ERRORS
    456					;
    457					; THIS ROUTINE WAITS FOR A DISK READ OPERATION TO COMPLETE ON AN I/O
    458					; BUFFER AND CHECKS FOR I/O ERRORS. IF AN ERROR OCCURRS, A MESSAGE
    459					; IS PRINTED.
    460					;
    461					; INPUTS:
    462					;
    463					;	R4 = FINAL BUFFER CONTROL BLOCK TO WAIT FOR
    464					;	     (MUST BE ADDRESS OF PRIMARY BCB OF DATA BUFFER)
    465					;
    466					; OUTPUTS:
    467					;
    468					;	CC - C	CLEAR IF DATA TRANSFERRED
    469					;		SET IF THIS WAS A DUMMY TRANSFER
    470					;	R4 PRESERVED
    471					;	ALL OTHER REGISTERS CLOBBERED
    472					;
    473					;-
    474
    475	001262				$DWCK::
    476	001262					REPEAT				; LOOP FOR ALL ERRORS
    477	001262					  $CALL $WAITI <,,,,R4>		; WAIT ON BUFFER
    478	001266					  ON.ERROR
    479	001270					    ERRP ER.RDA			; PRINT MESSAGE ON ERROR
    480	001272					    LET B.SIZ+P.FLAGS(R4) := B.SIZ+P.FLAGS(R4) SET.BY #PF.ERR
    481	001300					  END
    482	001300					  IF R0 EQ R4 LEAVE LOOP
    483	001304					END LOOP
    484	001306					RETURN NOERROR
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 11
WAIT ON DISK OUTPUT READ AND CHECK FOR ERRORS

    486						.SBTTL	WAIT ON DISK OUTPUT READ AND CHECK FOR ERRORS
    487
    488					;+
    489					;
    490					; *** - $DWCKO	WAIT AND CHECK FOR ERRORS
    491					;
    492					; THIS ROUTINE WAITS FOR A DISK READ OPERATION TO COMPLETE ON AN I/O
    493					; BUFFER AND CHECKS FOR I/O ERRORS. IF AN ERROR OCCURRS, A MESSAGE
    494					; IS PRINTED.
    495					;
    496					; INPUTS:
    497					;
    498					;	R4 = FINAL BUFFER CONTROL BLOCK TO WAIT FOR
    499					;	     (MUST BE ADDRESS OF PRIMARY BCB OF DATA BUFFER)
    500					;
    501					; OUTPUTS:
    502					;
    503					;	CC - C	CLEAR IF DATA TRANSFERRED
    504					;		SET IF THIS WAS A DUMMY TRANSFER
    505					;	R4 PRESERVED
    506					;	ALL OTHER REGISTERS CLOBBERED
    507					;
    508					;-
    509
    510	001312				$DWCKO::
    511	001312					REPEAT				; LOOP FOR ALL ERRORS
    512	001312					  $CALL $WAITO <,,,,R4>		; WAIT ON BUFFER
    513	001316					  ON.ERROR
    514	001320					    LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
    515	001326					    ERRP ER.RDO			; PRINT MESSAGE ON ERROR
    516	001330					    LET B.SIZ+P.FLAGS(R4) := B.SIZ+P.FLAGS(R4) SET.BY #PF.ERR
    517	001336					  END
    518	001336					  IF R0 EQ R4 LEAVE LOOP
    519	001342					END LOOP
    520	001344					RETURN NOERROR
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 12
WAIT ON TAPE READ AND CHECK FOR ERRORS

    522						.SBTTL	WAIT ON TAPE READ AND CHECK FOR ERRORS
    523
    524					;+
    525					;
    526					; *** - $TWCK	WAIT AND CHECK FOR ERRORS
    527					;
    528					; THIS ROUTINE WAITS FOR A TAPE READ OPERATION TO COMPLETE ON AN I/O
    529					; BUFFER AND CHECKS FOR I/O ERRORS. IF AN ERROR OCCURRS, A MESSAGE
    530					; IS PRINTED.
    531					;
    532					; INPUTS:
    533					;
    534					;	R4 = FINAL BUFFER CONTROL BLOCK TO WAIT FOR
    535					;	     (MUST BE ADDRESS OF PRIMARY BCB OF DATA BUFFER)
    536					;
    537					; OUTPUTS:
    538					;
    539					;	CC - C	CLEAR IF DATA TRANSFERRED
    540					;		SET IF THIS WAS A DUMMY TRANSFER
    541					;	R4 PRESERVED
    542					;	ALL OTHER REGISTERS CLOBBERED
    543					;
    544					;-
    545
    546	001350				$TWCKO:	:
    547	001350				$TWCK::
    548	001350					REPEAT				; LOOP FOR ALL ERRORS
    549	001350					  $CALL $WAITI <,,,,R4>		; WAIT ON BUFFER
    550	001354					  ON.ERROR
    551	001356					    IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
    552	001376					        ERROR ER.RDA
    553	001400					    ELSE
    554	001402						    ERRP ER.RDA			; PRINT MESSAGE ON ERROR
    555	001404					    END
    556	001404					    IFB (R4) EQ #IE.EOF
    557	001412						IF #KY.NIP OFF.IN $FLAG1
    558	001422							RETURN ERROR
    559	001426						ELSE
    560	001430							ERRP ER.IOR
    561	001432							RETURN
    562	001434						END
    563	001434					    END
    564	001434					  END
    565	001434					  IF R0 EQ R4 LEAVE LOOP
    566	001440					END LOOP
    567	001442					LET R5 := R4 + #B.SIZ		; POINT TO BUFFER
    568	001450					IF P.CNT(R5) EQ #0 THEN RETURN NOERROR
    569	001462					LET R0 := P.FLAG(R5) OFF.BY #PF.ERR
    570	001472					IF R0 NE #PF.DAT
    571	001500					  IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
    572	001520						ERROR  ER.NDA
    573	001522					ELSE
    574	001524						  ERRP ER.NDA
    575	001526					  END
    576	001526					ELSE
    577	001530					  IF P.FID(R5) NE $FID OR P.FID+2(R5) NE $FID+2 OR P.FID+4(R5) NE $FID+4
    578	001560					    IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 12-1
WAIT ON TAPE READ AND CHECK FOR ERRORS

    579	001600						ERROR ER.FID
    580	001602					    ELSE
    581	001604						    ERRP ER.FID
    582	001606					    END
    583	001606					  ELSE
    584	001610					    IF P.VBN(R5) NE $TVBN OR P.VBN+2(R5) NE $TVBN+2
    585	001630					      IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
    586	001650						ERROR ER.VBN
    587	001652					      ELSE
    588	001654						      ERRP ER.VBN
    589	001656					      END
    590	001656					    ELSE
    591	001660					      LET R1 := P.CNT(R5) + #511. ; GET BYTE COUNT
    592	001670	105001 				      CLRB R1
    593	001672	000301 				      SWAB R1
    594	001674	006201 				      ASR R1			; CONVERT TO BLOCK COUNT
    595	001676					      LET $TVBN := $TVBN + R1	; UPDATE VBN
    596	001702					      LET $TVBN+2 := $TVBN+2 + CARRY
    597	001706					      LET $VBN := $TVBN		; CORRECT RUNNING VBN
    598	001714					      LET $VBN+2 := $TVBN+2	; FOR TRUNCATION
    599	001722					      IF #PF.ERR SET.IN P.FLAG(R5) THEN ERRP ER.BDA
    600	001734					      RETURN NOERROR
    601	001740					    END
    602	001740					  END
    603	001740					END
    604	001740					RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 13
QIO CHECK ROUTINE

    606						.SBTTL	QIO CHECK ROUTINE
    607
    608					;+
    609					;
    610					; *** - $INCK	CHECK SUCCESSFUL COMPLETION OF INPUT QIOW
    611					;
    612					; *** - $OUTCK	CHECK SUCCESSFUL COMPLETION OF OUTPUT QIOW
    613					;
    614					; THESE ROUTINES TEST FOR SUCCESSFUL COMPLETION OF A QIO AND WAIT
    615					; OPERATION. IF EITHER A DIRECTIVE ERROR OR AN I/O ERROR OCCURRED,
    616					; THEY TAKE AN ERROR EXIT.
    617					;
    618					; INPUTS:
    619					;
    620					;	R4 = ADDRESS OF I/O STATUS BLOCK
    621					;	CC - C	SET OR CLEARED BY PRECEDING DIRECTIVE
    622					;	DIRECTIVE STATUS IN $DSW
    623					;
    624					; OUTPUTS:
    625					;
    626					;	ALL REGISTERS PRESERVED
    627					;
    628					;-
    629
    630	001742				$INCK::
    631	001742					ON.ERROR THEN ERROR ER.DIR	; CHECK FOR DIRECTIVE ERROR
    632	001746					REPEAT
    633	001746					  IFB (R4) NE #0 LEAVE LOOP	; WAIT FOR REAL COMPLETION
    634	001752					  WTSE$S #EFN			; TRY AGAIN
    635	001764					  CLEF$S #EFN
    636	001776					END LOOP
    637	002000					IFB (R4) EQ #IE.EOT THEN LET (R4) := #1 ; IGNORE EOT
    638	002012					IFB (R4) LT #0 THEN ERROR ER.IIR ; CHECK FOR I/O ERROR
    639	002020					RETURN				; RETURN IF ALL OK
    640
    641	002022				$OUTCK::
    642	002022					ON.ERROR THEN ERROR ER.DIR	; CHECK FOR DIRECTIVE ERROR
    643	002026					REPEAT
    644	002026					  IFB (R4) NE #0 LEAVE LOOP	; WAIT FOR REAL COMPLETION
    645	002032					  WTSE$S #EFN			; TRY AGAIN
    646	002044					  CLEF$S #EFN
    647	002056					END LOOP
    648	002060					IFB (R4) LT #0	; CHECK FOR I/O ERROR
    649	002064					   LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
    650	002072					   ERROR ER.IOR		; SEND ERROR MESSAGE
    651	002074					END
    652	002074					RETURN				; RETURN IF ALL OK
    653
    654
    655						; THE FOLLOWING SUB-ROUTINE IS CALLED TO SPACE BLOCKS ON TAPE
    656						;INPUTS
    657						;R1= LUN NO.
    658						; R4 = ADDRESS OF STATUS BLOCK
    659						; R5 = NO. BLOCKS TO SPACE- + = FWD. -- MINUS = BACK
    660
    661	002076				$SPACB:: QIOW$S #IO.SPB,R1,#EFN,,R4,,<R5>
    662	002140					 RETURN
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 13-1
QIO CHECK ROUTINE

    663
    664
    665
    666						;THE FOLLOWING ROUTINE IS CALLED TO SPACE OVER TAPE MARKS (EOF MARKS)
    667						;INPUTS
    668						; R1 = LUN NO.
    669						; R4 = ADDRESS OF STATUS BLOCK
    670						; R5 = NO. EOF'S T0 SPACE OVER-POS. = FWD;NEG = BACK
    671	002142				$SPACF:: QIOW$S #IO.SPF,R1,#EFN,,R4,,<R5>
    672	002204					 RETURN
    673
    674						;THE FOLLOWING ROUTINE IS CALLED TO REWIND A TAPE
    675						; INPUTS
    676						; R1 = LUN NO.  ;R4 = ADDRESS OF STATUS BLOCK
    677	002206				$RWND::  QIOW$S #IO.RWD,R1,#EFN,,R4
    678	002250					  RETURN
    679
    680
    681						; THE FOLLOWING ROUTINE IS CALLED TO REWIND AND UNLOAD A TAPE
    682						; INPUTS SAME AS FOR $RWND
    683
    684	002252				$RWNDU::	QIOW$S #IO.RWU,R1,#EFN,,R4
    685	002314						RETURN
    686
    687
    688		000001 				.END
DSCIO	X0024 - BASIC I/O FUNCT	MACRO M1110  21-AUG-78 20:36  PAGE 13-2
SYMBOL TABLE

B.LINK= ****** GX	IO.RWU= ****** GX	L34     001246R  	PF.DAT= ****** GX	$OWAIT= ****** GX
B.SIZ = ****** GX	IO.SPB= ****** GX	L35     001300R  	PF.ERR= ****** GX	$O$   = 000000
B.STAT= ****** GX	IO.SPF= ****** GX	L36     001336R  	P.CNT = ****** GX	$R    = 177777
B0      000174R  	IO.WLB= ****** GX	L37     001434R  	P.FID = ****** GX	$RDWAT  000022RG
B1      000370R  	KY.CMP= ****** GX	L4      000174R  	P.FLAG= ****** GX	$RDWLN  000000RG
B10     001746R  	KY.EOT= ****** GX	L40     001376R  	P.VBN = ****** GX	$RDWTA  000030RG
B11     002026R  	KY.NIP= ****** GX	L41     001402R  	RDCOM   000110R  	$RDW1B  000016RG
B2      000714R  	KY.TAP= ****** GX	L42     001404R  	RDCOMX  000104R  	$READ   000270RG
B3      001022R  	KY.VFY= ****** GX	L43     001434R  	RDCOMY  000252R  	$READA  000276RG
B4      001022R  	LBLS0 = 000075   	L44     001430R  	RETRY   001070R  	$READO  000416RG
B5      001262R  	LBLS1 = 000075   	L45     001434R  	TYPS0 = 000000   	$RWND   002206RG
B6      001312R  	LBLS2 = 000067   	L46     001462R  	TYPS1 = 000000   	$RWNDU  002252RG
B7      001350R  	LBLS3 = 000070   	L47     001530R  	TYPS2 = 000000   	$SPACB  002076RG
EFN   = ****** GX	LBLS4 = 000065   	L5      000240R  	TYPS3 = 000000   	$SPACF  002142RG
ER.BDA= ****** GX	LINKB   000672R  	L50     001520R  	TYPS4 = 000000   	$SUPMC= 000043
ER.DIR= ****** GX	L0      000064R  	L51     001524R  	WCOM    001014R  	$SV$  = 000000
ER.FID= ****** GX	L1      000062R  	L52     001526R  	$BLCNT= ****** GX	$SWITI= ****** GX
ER.IIR= ****** GX	L10     000404R  	L53     001740R  	$BUFCK  000742RG 	$SWITO= ****** GX
ER.IOR= ****** GX	L11     000476R  	L54     001560R  	$DIDDO= 000000   	$T    = 000076
ER.NDA= ****** GX	L12     000506R  	L55     001610R  	$DSW  = ****** GX	$TVBN = ****** GX
ER.RDA= ****** GX	L13     000626R  	L56     001600R  	$DWCK   001262RG 	$TWCK   001350RG
ER.RDO= ****** GX	L14     000622R  	L57     001604R  	$DWCKO  001312RG 	$TWCKO  001350RG
ER.VBN= ****** GX	L15     000702R  	L6      000356R  	$EF$  = 000000   	$T1   = 000000
E0      000226R  	L16     000740R  	L60     001606R  	$E$   = 000001   	$T2   = 000075
E1      000404R  	L17     000730R  	L61     001740R  	$FID  = ****** GX	$VBN  = ****** GX
E10     002000R  	L2      000064R  	L62     001630R  	$FLAG1= ****** GX	$WAITI  001002RG
E11     002060R  	L20     001000R  	L63     001660R  	$IFLAG= ****** GX	$WAITO  001010RG
E2      000730R  	L21     000776R  	L64     001650R  	$INCK   001742RG 	$WEOF   000510RG
E3      001250R  	L22     000774R  	L65     001654R  	$IWAIT= ****** GX	$WRITA  000570RG
E4      001054R  	L23     001000R  	L66     001656R  	$I$   = 000001   	$WRITE  000562RG
E5      001306R  	L24     001232R  	L67     001740R  	$K$   = 000011   	$WRI1B  000556RG
E6      001344R  	L25     001134R  	L7      000414R  	$K$L  = 000011   	$XXX$ = 000001
E7      001442R  	L26     001132R  	L70     001734R  	$K$T  = 000005   	$Y$   = 000000
IE.EOF= ****** GX	L27     001232R  	L71     001746R  	$L    = 000012   	$Z$   = 000000
IE.EOT= ****** GX	L3      000104R  	L72     002012R  	$LINKI  000364RG 	$$S   = 000000
IIII  = 177777   	L30     001152R  	L73     002020R  	$LINKO  000710RG 	$$T   = 000074
INLUN = ****** GX	L31     001156R  	L74     002026R  	$L$   = 000000   	$$TT  = 000075
IO.EOF= ****** GX	L32     001230R  	L75     002074R  	$OFLAG= ****** GX	$$$ARG= 000002
IO.RLB= ****** GX	L33     001232R  	OUTLUN= ****** GX	$OUTCK  002022RG 	.$T   = 000005
IO.RWD= ****** GX

. ABS.	000000	   000
      	002316	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  13040 WORDS  ( 51 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:04:58
EXE$:DSCIO,LIS$:DSCIO/-SP=SRC$:SMAC/PA:1,DSCPRE,DSCIO
