DSCBT	X0003 - INITIALIZE STOR	MACRO M1110  21-AUG-78 20:29  PAGE 3


      1	000000					$BEGIN	DSCBT,0003,<INITIALIZE STORAGE BITMAP>
						.TITLE	DSCBT	X0003 - INITIALIZE STORAGE BITMAP
						.IDENT	"X0003"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  11-AUG-76  4:32
     25					; ALTERED DEC 15,1976 BY G.RITTENBURG
DSCBT	X0003 - INITIALIZE STOR	MACRO M1110  21-AUG-78 20:29  PAGE 4


     27					;+
     28					;
     29					; THIS ROUTINE INITIALIZES THE CONTENTS OF THE OUTPUT DISK'S
     30					; STORAGE BITMAP FILE. FUNCTIONALLY, IT SETS ALL BITS TO 1 (FREE)
     31					; AND THEN ALLOCATES ALL OF THE REGIONS LISTED IN THE ALLOCATION
     32					; TABLE, AS WELL AS CLEARING THE DEAD SPACE AT THE END OF THE LAST
     33					; BITMAP BLOCK.
     34					;
     35					; INPUTS:
     36					;
     37					;	OUTLUN ASSIGNED TO DISK
     38					;	DATA IN ALLOCATION TABLE
     39					;
     40					; OUTPUTS:
     41					;
     42					;	STORAGE MAP FILE WRITTEN TO DISK
     43					;
     44					;-
     45
     46	000000				$DSCBT::
     47					;
     48					; FIRST MAKE UP AN ALLOCATION POINTER FOR THE NON-EXISTENT BLOCKS
     49					; FROM THE END OF THE VOLUME UP TO THE NEXT STORAGE MAP BLOCK
     50					; BOUNDARY.
     51					;
     52	000000					$CALL $DDIV <$CLF,$VOLSZ+2,$VOLSZ> ; REDUCE VOLUME SIZE BY CLF
     53	000020					$CALL $DDIV <#4096.,R1,R2>	; R0 = # CLUSTERS IN LAST BLOCK
     54	000030					LET R1 := #4096. - R0		; NUMBER OF NONEXISTENT CLUSTERS
     55	000036					$CALL $MUL <$CLF,R1>		; NUMBER OF BLOCKS
     56	000046					LET R2 :=  $BADP
     57	000052					WHILE R2 LO #$VOLND
     58	000060					  LET (R2)+ := #0
     59	000062					END LOOP
     60	000064					LET (R2)+ := R1			;THE PRECEDING 4 LINES INSERTED 12/15/76
     61	000066					LET (R2)+ := R0
     62	000070					LET (R2)+ := $VOLSZ		; (STARTING LBN)
     63	000074					LET (R2)+ := $VOLSZ+2
     64					;
     65					; NOW INITIALIZE THE STORAGE CONTROL BLOCK.
     66					;
     67	000100					LET R0 := #.SMBUF		; POINT TO STORAGE MAP BUFFER
     68	000104	012720 	001001 			MOV  #1001,(R0)+		; FIRST WORD GETS STRUCT LEVEL AND VERSION.
     69	000110	016720 	000000G			MOV  $CLF,(R0)+
     70	000114	016720 	000000G			MOV  $CW3,(R0)+
     71	000120	016720 	000000G			MOV  $CW2,(R0)+
     72	000124	012701 	000001 			MOV  #1,R1
     73	000130	005767 	000000G			TST  $CW2
     74	000134	001014 				BNE  20$
     75	000136	026727 	000000G	000756 		CMP  $CW3,#494.			; CHECK FOR FLOPPY
     76	000144	001002 				BNE  10$
     77	000146	012701 	000004 			MOV  #4,R1
     78	000152	026727 	000000G	024000 	10$:	CMP  $CW3,#10240.		; CHECK FOR RL01
     79	000160	001002 				BNE  20$
     80	000162	012701 	000002 			MOV  #2,R1
     81	000166	010120 			20$:	MOV  R1,(R0)+			; BLOCKING FACTOR.
     82	000170	005020 				CLR  (R0)+
     83	000172	016720 	000000G			MOV  $SECT,(R0)+
DSCBT	X0003 - INITIALIZE STOR	MACRO M1110  21-AUG-78 20:29  PAGE 4-1


     84	000176	005020 				CLR  (R0)+
     85	000200	016720 	000000G			MOV  $TRAK,(R0)+
     86	000204	005020 				CLR  (R0)+
     87	000206	016720 	000000G			MOV  $CYL,(R0)+
     88	000212	005020 				CLR  (R0)+
     89	000214	005010 				CLR  (R0)			; CLEAR VOLUME STATUS.
     90	000216					WHILE R0 LO #.SMBUF+512.
     91	000224					  LET (R0)+ := #0		; CLEAR REST OF BUFFER
     92	000226					END LOOP
     93	000230					LET .SMVBN := #0		; THIS BLOCK PRECEDES REAL MAP
     94	000234					LET .SMFLG := .SMFLG + #1	; MARK BUFFER DIRTY
     95										; WILL BE FLUSHED BELOW
     96					;
     97					; NOW FIND THE ENTRIES IN THE ALLOCATION TABLE IN ORDER BY LBN.
     98					; MARK OFF EACH ENTRY IN THE STORAGE MAP BUFFER. WHEN WE PASS THE
     99					; END OF THE BUFFER, FLUSH IT AND RE-INIT TO ALL ONES.
    100					;
    101	000240					LET $LBN := #0			; START WITH BLOCK 0
    102	000244					LET $LBN+2 := #0
    103	000250					$CALL NXB			; INIT BUFFER FIRST
    104	000254					REPEAT				; LOOP FOR ALL TABLE ENTRIES
    105	000254					  LET R1 := #-1			; HIGHEST LBN
    106	000260					  LET R2 := R1
    107	000262					  FOR.ABS R5 := #$BOOTB+4 TO #$VOLND+12. BY #8.
    108						    				; SEARCH FOR NEXT AREA
    109	000266					    IF -4(R5) NE #0 OR -2(R5) NE #0 ; IGNORE NULL AREAS
    110	000302					      DCOMP 2(R5),(R5), $LBN+2,$LBN
    111	000316					      IF RESULT IS HIS		; LOOK FOR BLOCKS GREATER THAN CURRENT
    112	000320						DCOMP 2(R5),(R5), R1,R2	; AND LESS THAN LOWEST SO FAR
    113	000330						IF RESULT IS LO
    114	000332						  LET R1 := 2(R5)	; SET NEW LOWEST
    115	000336						  LET R2 := (R5)
    116	000340						  LET R3 := R5		; MARK THE SPOT
    117	000342						END
    118	000342					      END
    119	000342					    END
    120	000342					  END LOOP
    121	000354					  IF R1 EQ #-1 AND R2 EQ R1 LEAVE LOOP ; DONE THEM ALL
    122	000366					  LET $LBN := R2 + #01		; SAVE LBN FOR NEXT ENTRY
    123	000400					  LET $LBN+2 := R1 + CARRY
    124					;
    125					; FOUND NEXT GROUP OF BLOCKS. COMPUTE NUMBER OF BITS TO CLEAR
    126					; AND THE BITMAP LOCATION WHERE THEY START.
    127					;
    128	000410					  $CALL $DDIV <$CLF,-2(R3),-4(R3)> ; REDUCE BY CLUSTER FACTOR
    129	000430					  IF R0 NE #0
    130	000434					    FATAL <ALLOCATION TABLE CONTAINS PARTIAL CLUSTER>
    131	000436					  END
    132	000436					  PUSH R1,R2			; SAVE COUNT
    133	000442					  $CALL $DDIV <$CLF,2(R3),(R3)>	; REDUCE LBN BY CLUSTER FACTOR
    134	000460					  $CALL $DDIV <#4096.,R1,R2>	; COMPUTE MAP BLOCK
    135	000470					  LET R2 := R2 + #1		; MAKE REAL VBN
    136	000472					  IF R2 LO .SMVBN		; IF BEFORE WHERE WE ARE
    137	000500					    FATAL <TABLE SCAN IS SICK>
    138	000502					  END
    139	000502					  WHILE .SMVBN LO R2		; IF PAST CURRENT BUFFER
    140	000510					    $CALL NXB			; GO TO NEXT BLOCK
DSCBT	X0003 - INITIALIZE STOR	MACRO M1110  21-AUG-78 20:29  PAGE 4-2


    141	000514					  END LOOP
    142					;
    143					; CORRECT MAP BLOCK IS NOW IN BUFFER. MARK OFF BITS.
    144					;
    145	000516					  BEGIN MARKS
    146	000516					    $CALL $DIV <R0,#16.>	; COMPUTE WORD NUMBER IN BLOCK
    147	000526					    LET R0 := R0 L.SHIFT 1 + #.SMBUF ; WORD ADDRESS
    148	000534					    LET R1 := R1 + #1
    149	000536					    LET R2 := #0
    150	000540	000261 				    SEC
    151	000542					    THRU R1
    152	000542					      LET R2 := R2 L.ROTATE 1	; POSITION TO INITIAL BIT
    153	000544					    END LOOP
    154	000550					    REPEAT			; LOOP FOR BLOCKS
    155	000550					      REPEAT			; LOOP FOR WORDS
    156	000550						REPEAT			; LOOP FOR BITS
    157	000550						  LET (R0) := (R0) OFF.BY R2 ; CLEAR A BIT
    158	000552						  LET (SP) := (SP) - #01 ; COUNT THE BIT
    159	000556						  LET 2(SP) := 2(SP) - CARRY
    160	000562						  IF (SP) EQ #0 AND 2(SP) EQ #0 LEAVE MARKS
    161	000574						  LET R2 := R2 L.ROTATE 1 ; AND ADVANCE
    162	000576						UNTIL RESULT IS CS
    163	000600						LET R2 := #1		; RE-INIT BIT
    164	000604	005720 					TST (R0)+		; NEXT WORD
    165	000606					      UNTIL R0 HIS #.SMBUF+512.	; UNTIL END OF BUFFER
    166	000614					      $CALL NXB			; MOVE TO NEXT BLOCK
    167	000620					      LET R0 := #.SMBUF		; POINT TO START OF BUFFER
    168	000624					    END LOOP
    169	000626					  END MARKS			; DONE MARKING THIS CLUSTER
    170	000626	022626 				  CMP (SP)+,(SP)+		; CLEAN THE STACK
    171	000630					END LOOP
    172	000632					LET R4 := $OUDEV		; GET DEVICE TABLE ENTRY
    173	000636					WHILE .SMVBN LO V.SBSZ(R4)	; ZERO OUT REMAINING BLOCKS
    174	000646					  $CALL NXB			; IN THE STORAGE MAP FILE
    175	000652					  LET R0 := #.SMBUF		; THAT ARE THERE DUE TO
    176	000656					  THRU R1 := #256.		; CLUSTER ROUND UP
    177	000662					    LET (R0)+ := #0
    178	000664					  END LOOP
    179	000670					END LOOP
    180	000672					$CALL .SMRVB <,,,#0,R4>		; FLUSH LAST BUFFER
    181	000702					RETURN
DSCBT	X0003 - INITIALIZE STOR	MACRO M1110  21-AUG-78 20:29  PAGE 5


    183					;+
    184					;
    185					; SUBROUTINE TO FLUSH THE BUFFER AND INIT FOR THE NEXT BLOCK.
    186					;
    187					; R3 & R5 CLOBBERED
    188					;
    189					;-
    190
    191	000704				NXB:	$CALL .SMRVB <,,,#0,$OUDEV>	; FLUSH THE BUFFER
    192	000720					LET R3 := #.SMBUF
    193	000724					THRU R5 := #256.
    194	000730					  LET (R3)+ := #-1		; RE-INIT TO ONES
    195	000734					END LOOP
    196	000740					LET .SMFLG := .SMFLG + #1	; MARK DIRTY
    197	000744					LET .SMVBN := .SMVBN + #1	; AND BUMP TO NEXT BLOCK
    198	000750					RETURN
    199
    200
    201
    202		000001 				.END
DSCBT	X0003 - INITIALIZE STOR	MACRO M1110  21-AUG-78 20:29  PAGE 5-1
SYMBOL TABLE

A3    = 000005   	E14     000740R  	L2      000302R  	$CYL  = ****** GX	$SUPMC= 000043
B0      000052R  	E2      000632R  	L3      000342R  	$DDIV = ****** GX	$SV$  = 000000
B1      000216R  	E3      000354R  	L4      000342R  	$DIDDO= 000000   	$T    = 000016
B10     000550R  	E4      000516R  	L5      000342R  	$DIV  = ****** GX	$TRAK = ****** GX
B11     000550R  	E5      000626R  	L6      000366R  	$DSCBT  000000RG 	$T1   = 000006
B12     000636R  	E6      000550R  	L7      000436R  	$EF$  = 000000   	$T2   = 000014
B13     000662R  	E7      000626R  	MARKS = 000005   	$E$   = 000001   	$VOLND= ****** GX
B14     000730R  	IIII  = 177777   	NXB     000704R  	$I$   = 000001   	$VOLSZ= ****** GX
B2      000254R  	LBLS0 = 000014   	TYPS0 = 000006   	$K$   = 000005   	$XXX$ = 000001
B3      000266R  	LBLS1 = 000012   	TYPS1 = 000001   	$K$L  = 000002   	$Y$   = 000000
B4      000502R  	LBLS2 = 000013   	TYPS2 = 000006   	$K$T  = 000005   	$Z$   = 000000
B5      000516R  	LBLS3 = 000014   	TYPS3 = 000000   	$L    = 000015   	$$S   = 000001
B6      000542R  	LBLS4 = 000013   	TYPS4 = 000000   	$LBN  = ****** GX	$$T   = 000015
B7      000550R  	LBLS5 = 000012   	TYPS5 = 000000   	$L$   = 000000   	$$TT  = 000012
E0      000064R  	L0      000064R  	V.SBSZ= ****** GX	$MUL  = ****** GX	.SMBUF= ****** GX
E1      000230R  	L1      000230R  	$BADP = ****** GX	$OUDEV= ****** GX	.SMFLG= ****** GX
E10     000614R  	L10     000502R  	$BOOTB= ****** GX	$O$   = 000000   	.SMRVB= ****** GX
E11     000600R  	L11     000516R  	$CLF  = ****** GX	$R    = 177777   	.SMVBN= ****** GX
E12     000672R  	L12     000574R  	$CW2  = ****** GX	$SECT = ****** GX	.$T   = 000005
E13     000670R  	L15     000672R  	$CW3  = ****** GX

. ABS.	000000	   000
      	000752	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  11655 WORDS  ( 46 PAGES)
DYNAMIC MEMORY:  13332 WORDS  ( 51 PAGES)
ELAPSED TIME:  00:02:11
EXE$:DSCBT,LIS$:DSCBT/-SP=SRC$:SMAC/PA:1,DSCPRE,DSCBT
