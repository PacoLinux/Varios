DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 3


      1	000000					$BEGIN	DSC,0030,<DISK SAVE AND COMPRESS MAIN PROGRAM>
						.TITLE	DSC	X0030 - DISK SAVE AND COMPRESS MAIN PROGRAM
						.IDENT	"X0030"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  1-NOV-76  22:44
     25					; G.RITTENBURG 11-MAR-77	001  MISSING LINE INSERTED
     26					; G.RITTENBURG  5-APR-77  	UPDATED FOR CMP/VFY DISK TO/FROM TAPE
     27
     28
     29						.MCALL	ALUN$S
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 4


     31					;
     32					; THIS IS THE MAIN PROGRAM OF DSC. IT INITIALIZES ITSELF, ACQUIRES
     33					; A COMMAND, AND PROCESSES IT.
     34					;
     35					; FIRST INITIALIZE DSC BY ZEROING THE ENTIRE IMPURE AREA.
     36					;
     37
     38	000000				$DSC::
     39	000000					LET R0 := #$ZERO		; START OF AREA TO ZERO
     40	000004					THRU R1 := #<$ENDZ-$ZERO>/2	; WORD COUNT
     41	000010					  LET (R0)+ := #0
     42	000012					END LOOP
     43	000016					LET $STAK := SP			; SAVE THE STACK POINTER
     44
     45					;
     46					; NOW ACQUIRE AND PARSE A COMMAND LINE. IF END OF CONSOLE INPUT
     47					; IS REACHED, THE PARSER ROUTINE WILL EXIT RATHER THAN RETURN.
     48					;
     49	000022					$CALL $DSCPR
     50
     51					;
     52					; ESTABLISH WHETHER THE INPUT AND OUTPUT ARE DISK OR TAPE, AND SET
     53					; UP THE FUNCTION DISPATCH TABLES ACCORDINGLY.
     54					;
     55	000026					LET R0 := #$INTAB		; INPUT DISPATCH TABLE
     56	000032					IF #KY.TAP SET.IN $IFLAG
     57	000042					  LET R2 := #$INTAP		; TAPE INPUT
     58	000046					ELSE
     59	000050					  LET R2 := #$INDSK		; DISK INPUT
     60	000054					END
     61	000054					THRU R1 := #$INTBL		; TABLE WORD COUNT
     62	000060					  LET (R0)+ := (R2)+		; COPY VECTORS INTO TABLE
     63	000062					END LOOP
     64
     65	000066					LET R0 := #$OUTAB		; OUTPUT DISPATCH TABLE
     66	000072					IF #KY.TAP SET.IN $OFLAG
     67	000102					  LET R2 := #$OUTAP		; TAPE OUTPUT
     68	000106					ELSE
     69	000110					  LET R2 := #$OUDSK		; DISK OUTPUT
     70	000114					END
     71	000114					THRU R1 := #$OUTBL		; TABLE WORD COUNT
     72	000120					  LET (R0)+ := (R2)+		; COPY VECTORS INTO TABLE
     73	000122					END LOOP
     74
     75					;
     76					; DO INPUT AND OUTPUT INITIALIZATION. IN THIS PROCESS, WE READ THE
     77					; VOLUME SUMMARY (OF THE FIRST UNIT IF THIS IS A VOLUME SET).
     78					;
     79	000126					$CALL $ALUNI <#$IVTAB>		; ASSIGN LUN TO FIRST DEVICE
     80	000136					$CALL @$INITI			; INIT INPUT DEVICE
     81	000142					$CALL @$RDSUM			; READ DEVICE SUMMARY
     82
     83					;
     84					; RECORD THE NUMBER OF VOLUMES BEING PROCESSED.
     85					; IF THE INPUT IS A DISK VOLUME SET WHICH IS TO BE MERGED, THEN ALL
     86					; THE UNITS MUST BE ON LINE. THE SAME HOLDS IF THE INPUT IS
     87					; A MERGED VOLUME SET AND THE OUTPUT IS DISK.
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 4-1


     88					;
     89	000146					IF #KY.MRG SET.IN $OFLAG
     90	000156					  LET $NVOL := $B2DAT+S.NVOL	; SAVE NUMBER OF VOLUMES
     91	000164					END
     92	000164					LET R0 := $NVOL
     93	000170					IF R0 EQ #0 THEN LET R0 := #1
     94	000200					IF #KY.DSK SET.IN $IFLAG
     95	000210					  IF $IVNUM HI R0 THEN ERROR ER.TMI ; TOO MANY DISKS
     96	000220					  IF $IVNUM LO R0 THEN ERROR ER.TFI ; TOO FEW DISKS
     97	000230					END
     98	000230					IF #KY.DSK SET.IN $OFLAG
     99	000240					  IF $OVNUM HI R0 THEN ERROR ER.TMO ; TOO MANY DISKS
    100	000250					  IF $OVNUM LO R0 THEN ERROR ER.TFO ; TOO FEW DISKS
    101	000260					END
    102					;
    103					; CHECK FOR COMPARE ONLY OPERATION
    104					;
    105	000260					IF #KY.CMP SET.IN $OFLAG THEN JUMPTO COMP
    106
    107					;
    108					; NOW INIT THE FIRST OUTPUT DEVICE AND WRITE OUT THE VOLUME SUMMARY.
    109					; THEN COPY THE INDEX FILE DATA.
    110					;
    111	000274					$CALL $ALUNO <#$OVTAB>		; ASSIGN LUN TO FIRST DEVICE
    112	000304					$CALL @$INITO			; INIT OUTPUT DEVICE
    113	000310					$CALL @$WTSUM			; AND WRITE THE SUMMARY TO IT
    114
    115	000314					LET R2 := #0			; INIT PSEUDO BLOCK NUMBER
    116	000316					LET R3 := #0			; FOR INDEX FILE DATA
    117	000320					REPEAT
    118	000320					  $CALL @$RDIXF <,,R2,R3,#$B2HD> ; READ INDEX FILE DATA
    119	000330					  ON.ERROR LEAVE LOOP		; RETURNS ERROR WHEN DONE
    120	000332					  $CALL @$WTIXF <,,R2,R3,R4>	; WRITE INDEX FILE DATA
    121	000336					END LOOP
    122	000340					LET $IHHD+B.STAT := #0		; INVALIDATE FILE HEADER
    123	000344					LET $OHHD+B.STAT := #0
    124
    125					;
    126					; NOW, IF MERGE MODE IS IN EFFECT, COPY THE VOLUME SUMMARIES AND
    127					; INDEX FILE HEADER AND DATA FOR ALL OF THE VOLUMES IN THE SET.
    128					;
    129	000350					PUSH #2				; KEEP COUNT ON STACK
    130	000354					WHILE (SP) LOS $NVOL		; NOTE FIRST VOLUME IS DONE
    131	000362					  IF #KY.DSK SET.IN $IFLAG	; IF INPUT IS DISK
    132	000372					    LET R0 := $INDEV + #V.SIZ	; POINT TO NEXT UNIT
    133	000402					    $CALL $ALUNI <R0>		; ASSIGN LUN TO IT
    134	000406					  END
    135	000406					  IF #KY.DSK SET.IN $OFLAG	; IF OUTPUT IS DISK
    136	000416					    LET R0 := $OUDEV + #V.SIZ	; POINT TO NEXT UNIT
    137	000426					    $CALL $ALUNO <R0>		; ASSIGN LUN TO IT
    138	000432					  END
    139
    140	000432					  $CALL @$RDSUM			; READ VOLUME SUMMARY
    141	000436					  $CALL @$WTSUM			; AND WRITE IT
    142	000442					  LET R2 := #0			; INIT START "BLOCK NUMBER"
    143	000444					  LET R3 := #0
    144	000446					  REPEAT
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 4-2


    145	000446					    $CALL @$RDIXF <,,R2,R3>	; READ INDEX FILE DATA
    146	000452					    ON.ERROR LEAVE LOOP		; RETURNS ERROR WHEN DONE
    147	000454					    $CALL @$WTIXF <,,R2,R3>	; WRITE INDEX FILE DATA
    148	000460					  END LOOP
    149	000462					  LET $IHHD+B.STAT := #0	; INVALIDATE FILE HEADER
    150	000466					  LET $OHHD+B.STAT := #0
    151	000472					  LET (SP) := (SP) + 1		;  001 THIS LINE WAS MISSING
    152	000476					END LOOP			; LOOP FOR ALL UNITS
    153	000500	005726 				TST (SP)+			; CLEAN THE STACK
    154
    155					;
    156					; WE ARE NOW READY TO COPY THE FILE DATA. IF MERGE MODE, THIS IS
    157					; DONE ONE VOLUME AT A TIME (IN ORDER BY RVN). IN EACH VOLUME,
    158					; WE FIND ONE ACTIVE FILE HEADER AT A TIME. THE FILE IS CREATED ON
    159					; THE OUTPUT DEVICE, AND THEN THE DATA BLOCKS ARE COPIED. IF
    160					; MERGE MODE IS ON, THEN EXTENSION HEADERS OF THE FILE ARE COPIED
    161					; TO THE OUTPUT DEVICE, FOLLOWED BY THE DATA OF THE FILE SEGMENT THAT
    162					; THEY REPRESENT. IF MERGE MODE IS OFF, THEN EVERY HEADER IS CONSIDERED
    163					; TO BE A SEPARATE FILE.
    164					;
    165	000502					IF $NVOL HI #0			; IF WE ARE DOING MULTI-VOLUME
    166	000510					  LET $RVN := #1		; START WITH 1
    167	000516					ELSE
    168	000520					  LET $RVN := #0		; OTHERWISE IT IS 0
    169	000524					END
    170	000524					LET $FID := #3			; FIRST FILE ON EACH VOL IS MFD
    171	000532					REPEAT				; LOOP FOR FILES ON VOLUME
    172	000532				FIND:	  $CALL @$FIND			; FIND NEXT FILE HEADER
    173	000536					  ON.ERROR LEAVE LOOP		; EXIT LOOP WHEN DONE
    174	000540					  $CALL @$ALLOC			; ALLOCATE FILE ON OUTPUT VOLUME
    175	000544					  LET $VBN := #1		; INIT VBN TO 1
    176	000552					  LET $VBN+2 := #0
    177	000556					  REPEAT			; LOOP FOR ALL FILE SEGMENTS
    178					;
    179					; ENTRY POINT TO RESUME COPY AFTER VERIFY PREVIOUS REEL.
    180					;
    181	000556				COPY1::
    182	000556					    DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
    183	000574					    IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
    184	000576					    REPEAT			; LOOP FOR BLOCKS IN FILE
    185	000576					      DCOMP $VBN+2,$VBN, $IHVBN+2,$IHVBN
    186	000614					      IF RESULT IS HI LEAVE LOOP ; DONE ALL BLOCKS IN FILE
    187	000616					      $CALL @$RDDAT <,#BLKF,,,#$B1HD> ; START ONE READ
    188	000632					      $CALL @$RDDAT <,#BLKF,,,#$B2HD> ; START OTHER READ
    189	000646					      $CALL @$WATCK <,,,,#$B1HD> ; WAIT FOR FIRST COMPLETION
    190	000656					      ON.ERROR THEN $CALL RESYNC
    191	000664					      LET B.STAT(R4) := #0	; INVALIDATE THE BUFFER
    192	000670					      $CALL @$WTDAT <,,,,R4>	; AND WRITE IT
    193	000674					      ON.ERROR THEN $CALL RESYN1
    194	000702					      $CALL @$WATCK <,,,,#$B2HD> ; WAIT FOR SECOND COMPLETION
    195	000712					      ON.ERROR THEN $CALL RESYNC
    196	000720					      LET B.STAT(R4) := #0	; INVALIDATE THE BUFFER
    197	000724					      $CALL @$WTDAT <,,,,R4>	; AND WRITE IT
    198	000730					      ON.ERROR THEN $CALL RESYN1
    199	000736					    END LOOP			; LOOP FOR BLOCKS IN FILE SEGMENT
    200	000740					    DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
    201	000756					    IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 4-3


    202	000760					    $CALL @$RDEXH		; READ EXTENSION HEADER
    203	000764					    ON.ERROR THEN $CALL RESYN1
    204	000772					    $CALL @$WTEXH		; WRITE EXTENSION HEADER
    205	000776					    ON.ERROR
    206	001000					      LET $IHHD+B.STAT := #0	; INVALIDATE FILE HEADERS
    207	001004					      LET $OHHD+B.STAT := #0
    208	001010					      GOTO FIND
    209	001012					    END
    210	001012					  END LOOP			; LOOP FOR EXTENSION HEADERS
    211	001014					  LET $IHHD+B.STAT := #0	; INVALIDATE FILE HEADERS
    212	001020					  LET $OHHD+B.STAT := #0
    213	001024					END LOOP			; LOOP FOR FILES
    214					;
    215					; ALL DONE. FINISH INPUT AND OUTPUT AND GO TO THE TOP FOR
    216					; ANOTHER COMMAND.
    217					;
    218	001026				END:	$CALL @$FINI <#0>		; FINISH INPUT
    219	001036					$CALL @$FINO <#0>		; FINISH OUTPUT
    220					;
    221					; CHECK IF A VERIFY PASS IS REQUESTED
    222					;
    223	001046					IF #KY.VER SET.IN $OFLAG
    224	001056					  IF #KY.VFY OFF.IN $FLAG1
    225	001066					    ERRP ER.VFY			; SIGNAL START VERIFY
    226	001070					    LET $FLAG1 := $FLAG1 SET.BY #KY.VFY	;INDICATE
    227						    				;VERIFY IN PROGRESS
    228	001076					    LET SP := $STAK		;RESET SP
    229	001102					    GOTO COMP			;START VERIFY
    230	001104					  END
    231	001104					END
    232	001104					LET SP := $STAK			;RESET SP
    233	001110					JUMPTO $DSC
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 5


    235					;
    236					; WE GET HERE TO DO A VERIFY PASS.
    237					; NOTE THAT THIS CODE IS NOT GENERAL! IT WORKS FOR DISK TO DISK, DISK TO TAPE,
    238					; OR TAPE TO DISK,SINGLE DISK VOLUME ONLY.
    239
    240					;  IF THIS IS A COMPARE ONLY OPERATION,POSITION I.P.AND O.P. VOLUMES
    241					;
    242
    243	001114				COMP::	LET $B2HD+B.STAT := #0		; DISCARD BUFFERS LEFT BY $RDSUM
    244	001120					LET $RVN := #0			;SET $RVN TO ZERO
    245	001124					LET $B1HD+B.STAT := #0
    246	001130					LET $IHHD+B.STAT := #0
    247	001134					LET $IXHD+B.STAT := #0
    248	001140					LET $OHHD+B.STAT := #0
    249	001144					IF #KY.TAP SET.IN $OFLAG	;YES = TAPE OUTPUT
    250	001154					  LET $OXHD+B.STAT := #0
    251	001160					  LET $FLAG1 := $FLAG1 SET.BY #KY.NIP ;FLAG O.P.
    252	001166					  $CALL $ALUNI  <#$OVTAB>	;ASGN INLUN TO O.P.
    253	001176					  $CALL $TRDSO			;INITIALIZE O.P.
    254	001202					  LET R2 := #0
    255	001204					  LET R3 := #0
    256	001206					  LET $B2HD+B.STAT := #0	;RELEASE BUFFR
    257	001212					  REPEAT
    258	001212					    $CALL $TRDID <,,R2,R3,#$B2HD> ;SPACE PAST HOME &BOOT BLKS & IFBM
    259	001222					    ON.ERROR LEAVE LOOP
    260	001224					    LET B.STAT(R4) := #0
    261	001230					  END LOOP
    262	001232					  LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP ;RESET FOR I.P.
    263	001240					ELSE
    264	001242					  IF #KY.CMP SET.IN $OFLAG	;IF COMPARE FCN
    265	001252					    $CALL $DRDSO		;INIT O.P. DISK
    266	001256					  END
    267	001256					END
    268	001256					$CALL $ALUNI <#$IVTAB>		;ASSIGN INLUN TO I.P.
    269	001266					$CALL $ALUNO <#$OVTAB>		; AND OUTLUN TO OUTPUT
    270	001276					LET $B2HD+B.STAT := #0
    271	001302					LET $IHHD+B.STAT := #0
    272	001306					LET $B1HD+B.STAT := #0
    273	001312					LET $IXHD+B.STAT := #0
    274	001316					IF #KY.TAP SET.IN $IFLAG
    275						  				;INIT. AND READ SUMMARY BLK FROM I.P. TAPE
    276	001326					  IF #KY.VFY SET.IN $FLAG1	;IF VERIFY
    277	001336					    $CALL $TINI
    278	001342					    $CALL $TRDSU
    279	001346					  END
    280						  				;NOW READ HOME,BOOT,AND IFBM BLKS
    281	001346					  LET R2 := #0
    282	001350					  LET R3 := #0
    283	001352					  LET $B2HD+B.STAT := #0	;RELEASE BUFFER
    284	001356					  REPEAT
    285	001356					    $CALL $TRDID <,,R2,R3,#$B2HD>
    286	001366					    ON.ERROR LEAVE LOOP
    287	001370					    LET B.STAT(R4) := #0
    288	001374					  END LOOP
    289	001376					ELSE
    290	001400					  LET $B2HD+B.STAT := #0
    291	001404					  IF #KY.CMP SET.IN $OFLAG	;IF COMPARE FCN
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 5-1


    292	001414					    $CALL $DRDSU		; INIT I.P. DISK
    293	001420					  END
    294	001420					END
    295	001420					LET $IHHD+B.STAT := #0		;RELEASE HEADER BUFFER
    296	001424					LET $B2HD+B.STAT := #0		; DISCARD SUMMARY DATA ONLY
    297
    298					;
    299					; THE VERIFY OPERATION IS VERY SIMILAR TO THE COPY OPERATION. WE FIND
    300					; A FILE ON THE INPUT DISK, AND THEN READ THE CORRESPONDING FILE HEADER
    301					; FROM THE OUTPUT DISK. THEN WE READ DATA BLOCKS FROM EACH FILE INTO
    302					; EACH OF THE BUFFERS AND COMPARE THEM.
    303					;
    304	001430				VFY:
    305	001430					IF #KY.TAP SET.IN $FLAG1	;IF TAPE INPUT
    306	001440					  LET $FID := #4		;INTIALIZE FILE NO. = 4
    307	001446					ELSE
    308	001450					  LET $FID := #3		;INIT FILE NO. = 3
    309	001456					END
    310	001456					LET $RVN := #0
    311	001462				CONT:
    312	001462					$CALL @$FIND			; FIND NEXT FILE HEADER
    313	001466					ON.ERROR
    314	001470					  IF #KY.TAP OFF.IN $OFLAG	;IF TAPE O.P.
    315	001500				ENDVFY:	    LET SP := $STAK		;RESET SP
    316	001504					    JUMPTO $DSC			;END OF I.P. AND O.P.  LAST VFY PASS
    317	001510					  END
    318	001510					END
    319	001510					LET $B2HD+B.STAT := #0		; DISCARD HEADER
    320	001514					LET $B1HD+B.STAT := #0		; DISCARD ATTRIBUTE BLOCK
    321	001520					$CALL @$FINDO  <,,#0,$FID>	; READ OUTPUT FILE HDR
    322	001534					ON.ERROR THEN GOTO ENDVFY
    323	001540					IF #KY.TAP SET.IN $IFLAG	;IF DISK O.P.
    324	001550					  $CALL $FILSZ  <,,,,,#$OHBF>
    325	001560					  LET $OHVBN := R1
    326	001564					  LET $OHVBN+2 := R0
    327	001570					END
    328	001570					LET $VBN := #1			;INIT STARTING VBN
    329	001576					LET $VBN+2 := #0
    330	001602					LET $TVBN := $VBN
    331	001610					LET $TVBN+2 := $VBN+2
    332	001616					LET $WVBN := #1
    333	001624					LET $WVBN+2 := #0
    334	001630					LET $TFID := $FID		;SAVE FID
    335	001636					LET $TFID+2 := $FID+2
    336	001644					LET $TFID+4 := $FID+4
    337	001652					LET $THVBN := $IHVBN		;SAVE IHVBN
    338	001660					LET $THVBN+2 := $IHVBN+2
    339	001666					LET $TFSIZ := $FISIZ		;SAVE FISIZ
    340	001674					LET $TFSIZ+2 := $FISIZ+2
    341	001702					REPEAT				; LOOP FOR ALL FILE SEGMENTS
    342						  				;ENTRY POINT TO RESUME VERIFY CURRENT REEL
    343	001702				COMP1::
    344	001702					  DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
    345	001720					  IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
    346	001722					  REPEAT			; LOOP FOR BLOCKS IN FILE
    347	001722					    LET R1 := $IHVBN - $VBN	; COMPUTE BLOCKS TO GO
    348	001732					    LET R0 := $IHVBN+2 - CARRY - $VBN+2
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 5-2


    349	001744					    IF RESULT IS MI LEAVE LOOP
    350	001746					    LET R1 := R1 + #01
    351	001752					    LET R0 := R0 + CARRY
    352	001754					    IF RESULT IS NE OR R1 HI #4
    353	001764					      LET R1 := #BLKF		; LIMIT TO BLOCKING FACTOR
    354	001770					    END
    355	001770					    LET $B1HD+B.STAT := #0	;RELEASE BUFFER
    356	001774					    LET $B2HD+B.STAT := #0
    357	002000					    PUSH R1			; SAVE BLOCKS COUNT
    358	002002					    $CALL @$RDDAT <,R1,,,#$B1HD> ; READ DATA FROM INPUT
    359	002012					    $CALL  @$WATCK  <,,,,#$B1HD> ; WAIT FOR COMPLETION
    360	002022					    $CALL  @$RDATO <,(SP),,,#$B2HD> ;READ O.P. DATA
    361	002034					    LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
    362	002042					    LET R0 := $OUDEV
    363	002046					    ALUN$S #INLUN,(R0),2(R0)
    364	002066					    $CALL @$WATO <,,,,#$B2HD>
    365	002076					    LET $TVBN := $WVBN		;SAVE NEW VBN
    366	002104					    LET $TVBN+2 := $WVBN+2
    367	002112					    LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP
    368	002120					    LET R0 := $INDEV
    369	002124					    ALUN$S #INLUN,(R0),2(R0)
    370	002144					    POP R0			; GET BLOCK COUNT
    371	002146	000300 				    SWAB R0			; TURN INTO WORD COUNT
    372	002150					    LET R1 := #$B1DAT		; POINT TO DATA
    373	002154					    LET R2 := #$B2DAT
    374	002160					    THRU R0
    375	002160					      IF (R1)+ NE (R2)+		; COMPARE DATA
    376	002164						ERRP ER.VER		; VERIFICATION ERROR
    377	002166						LEAVE LOOP
    378	002170					      END
    379	002170					    END LOOP
    380	002174					    LET R0 := #$BUF1		; POINT TO MAIN BUFFERS
    381	002200					    LET R1 := #$BUF2
    382	002204					    THRU R2 := #B.SIZ*BLKF/2
    383	002210					      LET -(R0) := #0		; CLEAN OUT ALL CONTROL BLOCKS
    384	002212					      LET -(R1) := #0
    385	002214					    END LOOP
    386	002220					  END LOOP			; LOOP FOR BLOCKS IN FILE.
    387	002222					  IF #KY.MRG OFF.IN $OFLAG THEN LEAVE LOOP ;END OF EXTENT NMG MODE
    388	002234					  DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
    389	002252					  IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
    390	002254					  $CALL @$RDEXH			; READ EXTENSION HEADER
    391	002260					  ON.ERROR LEAVE LOOP
    392	002262					  LET $B2HD+B.STAT := #0	; DISCARD HEADER
    393	002266					END LOOP			; LOOP FOR EXTENSION HEADERS
    394	002270				CONT2:
    395	002270					LET $IHHD+B.STAT := #0		; INVALIDATE HEADER BUFFERS
    396	002274					LET $OHHD+B.STAT := #0
    397	002300					LET $B1HD+B.STAT := #0		; RELEASE BUF1 0 LGTH FILE
    398	002304					LET $B2HD+B.STAT := #0		; RELEASE BUF2 0 LGTH FILE
    399	002310					JUMPTO CONT			; LOOP FOR ALL FILES
    400
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 6


    402					;+
    403					;
    404					; *** - RESYNC	RESYNCHRONIZE TAPE INPUT
    405					;
    406					; THIS ROUTINE IS CALLED WHEN THE INPUT TAPE IS OUT OF SYNC FROM WHERE
    407					; WE THINK IT SHOULD BE. IT RETURNS IF WE JUST HAVE THE WRONG DATA
    408					; BLOCK OF THE FILE. IF THINGS ARE REALLY BAD (I.E., WRONG BLOCK TYPE)
    409					; IT TRANSFERS TO THE START OF THE FIND OPERATION FOR THE NEXT FILE.
    410					; NOTE THAT THIS ROUTINE MUST BE EXECUTED EXACTLY ONE CALL AWAY FROM
    411					; THE MAIN COPY LOOP.
    412					;
    413					; INPUTS:
    414					;
    415					;	R4 = BCB ADDRESS OF LAST TAPE BLOCK READ
    416					;
    417					;-
    418
    419	002314				RESYNC:
    420	002314					IFB (R4) EQ #IE.EOF GOTO EOF
    421	002322					LET R5 := R4 + #B.SIZ		; POINT TO DATA BUFFER
    422	002330					IF P.FLAG(R5) EQ #PF.DAT	; IF WE HAVE DATA
    423	002340					  IF P.FID(R5) EQ $FID AND P.FID+2(R5) EQ $FID+2 AND P.FID+4(R5) EQ $FID+4
    424						    				; AND FILE ID IS RIGHT
    425	002370					    LET R1 := P.CNT(R5) + #511.	; GET BYTE COUNT
    426	002400	105001 				    CLRB R1
    427	002402	000301 				    SWAB R1			; TURN INTO BLOCK COUNT
    428	002404	006201 				    ASR R1
    429	002406					    LET $VBN := P.VBN(R5) + R1	; RESET VBN
    430	002420					    LET $VBN+2 := P.VBN+2(R5) + CARRY
    431	002432					    LET $TVBN := $VBN
    432	002440					    LET $TVBN+2 := $VBN+2
    433	002446					    RETURN			; AND PROCEED
    434	002450					  END
    435	002450					END
    436					;
    437					; ALTERNATE ENTRY FOR WHEN IT IS ALREADY CLEAR THAT WE ARE REALLY LOST.
    438					;
    439	002450				RESYN1::
    440	002450					LET $B1HD+B.STAT := #0		; INVALIDATE THE BUFFERS
    441	002454					LET $B2HD+B.STAT := #0
    442	002460					LET $IHHD+B.STAT := #0		; AS WELL AS THE HEADERS
    443	002464					LET $OHHD+B.STAT := #0
    444	002470					IFB (R4) EQ #IE.EOF GOTO EOF	; OUT IF END OF FILE
    445	002476	005726 				TST (SP)+			; THROW AWAY RETURN
    446	002500					IF #KY.TAP SET.IN $IFLAG	; ONLY IF INPUT IS TAPE
    447	002510					  ERRP ER.FSY			; PRINT MESSAGE
    448	002512					  LET R5 := #-1			; SET UP TO BACKSPACE 1 BLOCK
    449	002516					  WHILE $IWAIT NE #0		; WAIT FOR COMPLETION
    450	002524					    $CALL $WAITI <,,,,#$IWAIT>	; OF OUTSTANDING I/O
    451	002534					    LET R5 := R5 + #-1		; AND COUNT IT
    452	002540					  END LOOP
    453	002542					  $CALL $SPACB  <,#INLUN,,,R4,R5>
    454	002552					  IFB (R4) EQ #IE.EOF		; IF WE BANGED INTO EOF
    455	002560					    $CALL $SPACF  <,#INLUN,,,R4,#1>
    456	002574					  END
    457	002574					END
    458	002574					LET $IFLAG := $IFLAG SET.BY #KY.LOS ; OBSERVE THAT WE ARE LOST
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 6-1


    459	002602					JUMPTO FIND			; AND START LOOKING FOR A NEW FILE
    460					;
    461					; TO HERE IF WE HIT EOF ON THE INPUT TAPE
    462					;
    463	002606	005726 			EOF:	TST (SP)+			; THROW AWAY RETURN
    464	002610					JUMPTO END			; AND QUIT
    465
    466
    467
    468		000000'				.END	$DSC
DSC	X0030 - DISK SAVE AND C	MACRO M1110  21-AUG-78 19:52  PAGE 6-2
SYMBOL TABLE

A3    = 000002   	E3      000340R  	L35     001400R  	$DIDDO= 000000   	$OUTBL= ****** GX
BLKF  = ****** GX	E4      000500R  	L36     001346R  	$DRDSO= ****** GX	$OVNUM= ****** GX
B.SIZ = ****** GX	E5      000462R  	L37     001420R  	$DRDSU= ****** GX	$OVTAB= ****** GX
B.STAT= ****** GX	E6      001026R  	L4      000164R  	$DSC    000000RG 	$OXHD = ****** GX
B0      000010R  	E7      001014R  	L40     001420R  	$DSCPR= ****** GX	$O$   = 000000
B1      000060R  	FIND    000532R  	L41     001450R  	$EF$  = 000000   	$R    = 177777
B10     000576R  	IE.EOF= ****** GX	L42     001456R  	$ENDZ = ****** GX	$RDATO= ****** GX
B11     001212R  	IIII  = 177777   	L43     001510R  	$E$   = 000001   	$RDDAT= ****** GX
B12     001356R  	INLUN = ****** GX	L44     001510R  	$FID  = ****** GX	$RDEXH= ****** GX
B13     001702R  	KY.CMP= ****** GX	L45     001540R  	$FILSZ= ****** GX	$RDIXF= ****** GX
B14     001722R  	KY.DSK= ****** GX	L46     001570R  	$FIND = ****** GX	$RDSUM= ****** GX
B15     002160R  	KY.LOS= ****** GX	L47     001764R  	$FINDO= ****** GX	$RVN  = ****** GX
B16     002210R  	KY.MRG= ****** GX	L5      000200R  	$FINI = ****** GX	$SPACB= ****** GX
B17     002516R  	KY.NIP= ****** GX	L50     001770R  	$FINO = ****** GX	$SPACF= ****** GX
B2      000120R  	KY.TAP= ****** GX	L51     002170R  	$FISIZ= ****** GX	$STAK = ****** GX
B3      000320R  	KY.VER= ****** GX	L52     002234R  	$FLAG1= ****** GX	$SUPMC= 000043
B4      000354R  	KY.VFY= ****** GX	L53     002450R  	$IFLAG= ****** GX	$SV$  = 000000
B5      000446R  	LBLS0 = 000055   	L54     002450R  	$IHHD = ****** GX	$T    = 000060
B6      000532R  	LBLS1 = 000057   	L55     002574R  	$IHVBN= ****** GX	$TFID = ****** GX
B7      000556R  	LBLS2 = 000017   	L56     002542R  	$INDEV= ****** GX	$TFSIZ= ****** GX
COMP    001114RG 	LBLS3 = 000051   	L57     002574R  	$INDSK= ****** GX	$THVBN= ****** GX
COMP1   001702RG 	L0      000050R  	L6      000230R  	$INITI= ****** GX	$TINI = ****** GX
CONT    001462R  	L1      000054R  	L7      000220R  	$INITO= ****** GX	$TRDID= ****** GX
CONT2   002270R  	L10     000230R  	PF.DAT= ****** GX	$INTAB= ****** GX	$TRDSO= ****** GX
COPY1   000556RG 	L11     000260R  	P.CNT = ****** GX	$INTAP= ****** GX	$TRDSU= ****** GX
END     001026R  	L12     000250R  	P.FID = ****** GX	$INTBL= ****** GX	$TVBN = ****** GX
ENDVFY  001500R  	L13     000260R  	P.FLAG= ****** GX	$IVNUM= ****** GX	$T1   = 000000
EOF     002606R  	L14     000274R  	P.VBN = ****** GX	$IVTAB= ****** GX	$T2   = 000055
ER.FSY= ****** GX	L15     000500R  	RESYNC  002314R  	$IWAIT= ****** GX	$VBN  = ****** GX
ER.TFI= ****** GX	L16     000406R  	RESYN1  002450RG 	$IXHD = ****** GX	$WAITI= ****** GX
ER.TFO= ****** GX	L17     000432R  	S.NVOL= ****** GX	$I$   = 000001   	$WATCK= ****** GX
ER.TMI= ****** GX	L2      000110R  	TYPS0 = 000000   	$K$   = 000013   	$WATO = ****** GX
ER.TMO= ****** GX	L20     000520R  	TYPS1 = 000000   	$K$L  = 000013   	$WTDAT= ****** GX
ER.VER= ****** GX	L21     000524R  	TYPS2 = 000001   	$K$T  = 000005   	$WTEXH= ****** GX
ER.VFY= ****** GX	L22     000664R  	TYPS3 = 000000   	$L    = 000020   	$WTIXF= ****** GX
E0      000016R  	L23     000702R  	VFY     001430R  	$L$   = 000000   	$WTSUM= ****** GX
E1      000066R  	L24     000720R  	V.SIZ = ****** GX	$NVOL = ****** GX	$WVBN = ****** GX
E10     000740R  	L25     000736R  	$ALLOC= ****** GX	$OFLAG= ****** GX	$XXX$ = 000001
E11     001232R  	L26     000772R  	$ALUNI= ****** GX	$OHBF = ****** GX	$Y$   = 000000
E12     001376R  	L27     001012R  	$ALUNO= ****** GX	$OHHD = ****** GX	$ZERO = ****** GX
E13     002270R  	L3      000114R  	$BUF1 = ****** GX	$OHVBN= ****** GX	$Z$   = 000000
E14     002222R  	L30     001104R  	$BUF2 = ****** GX	$OUDEV= ****** GX	$$S   = 000000
E15     002174R  	L31     001104R  	$B1DAT= ****** GX	$OUDSK= ****** GX	$$T   = 000056
E16     002220R  	L32     001242R  	$B1HD = ****** GX	$OUTAB= ****** GX	$$TT  = 000055
E17     002542R  	L33     001256R  	$B2DAT= ****** GX	$OUTAP= ****** GX	.$T   = 000006
E2      000126R  	L34     001256R  	$B2HD = ****** GX

. ABS.	000000	   000
      	002614	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  12648 WORDS  ( 50 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:06:30
EXE$:DSC,LIS$:DSC/-SP=SRC$:SMAC/PA:1,DSCPRE,DSC
