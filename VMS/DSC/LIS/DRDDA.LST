DRDDA	X0010 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:09  PAGE 3


      1	000000					$BEGIN	DRDDA,0010,<READ DATA FROM DISK FILE>
						.TITLE	DRDDA	X0010 - READ DATA FROM DISK FILE
						.IDENT	"X0010"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  12-AUG-76  20:14
DRDDA	X0010 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:09  PAGE 4


     26					;+
     27					;
     28					; *** - $DRDDA	READ DATA FROM DISK FILE
     29					;
     30					; THIS ROUTINE READS THE INDICATED DATA BLOCKS FROM THE INPUT DISK
     31					; FILE INTO THE INDICATED DATA BUFFER. VIRTUAL BLOCKS ARE MAPPED
     32					; TO LOGICAL BLOCKS USING THE INPUT FILE HEADER AND LOGICAL TRANSFERS
     33					; ARE INITIATED AS NECESSARY. NOTE THAT A BLOCK COUNT CAUSES A DUMMY
     34					; TRANSFER OF ZERO LENGTH.
     35					;
     36					; INPUTS:
     37					;
     38					;	R1 = BLOCK COUNT TO READ
     39					;	$VBN = HIGH AND LOW STARTING VBN
     40					;	R4 = INPUT BUFFER DESCRIPTOR
     41					;
     42					; OUTPUTS:
     43					;
     44					;	R4 = BUFFER DESCRIPTOR ADDRESS
     45					;	$VBN UPDATED TO NEXT BLOCK
     46					;	BUFFER PREAMBLE INITIALIZED
     47					;	TRANSFER INTO BUFFER INITIATED
     48					;	OTHER REGISTERS CLOBBERED
     49					;
     50					;-
     51
     52	000000				$DRDDA::
     53	000000					$CALL $BUFCK <,,,,R4>		; WAIT FOR BUFFER
     54	000004					LET B.SIZ+P.VBN(R4) := $VBN	; SET UP STARTING VBN
     55	000012					LET B.SIZ+P.VBN+2(R4) := $VBN+2	; IN PREAMBLE
     56	000020					LET B.SIZ+P.CNT(R4) := #0	; INIT BYTE COUNT TO 0
     57	000024					LET B.SIZ+P.FLAG(R4) := #PF.DAT	; SET DATA BLOCK FLAG
     58	000032					PUSH R1				; SAVE BLOCK COUNT
     59	000034					PUSH R4,R4			; SAVE DESCRIPTOR ADDRESS
     60	000040					LET (SP) := (SP) + #B.SIZ+P.SIZ	; BUILD START ADDRESS
     61	000044					REPEAT
     62	000044					  LET R5 := #$IHBF		; MAP USING INPUT FILE HEADER
     63	000050					  LET R3 := $VBN - H.VBN(R5)	; GET CURRENT VBN, ADJUSTED
     64	000060					  LET R2 := $VBN+2 - CARRY - H.VBN+2(R5) ; BY BASE VBN
     65	000072					  IF 4(SP) EQ #0 GOTO EXIT	; IF NULL TRANSFER
     66	000100					  $CALL $MPVBN <,,R2,R3,,R5>	; MAP TO LOGICAL
     67	000104					  ON.ERROR GOTO EXIT
     68	000106					  IF R0 NE #0 OR R1 HI 4(SP)	; IF MORE BLOCKS MAPPED
     69	000120					    LET R0 := #0		; THAN DESIRED,
     70	000122					    LET R1 := 4(SP)		; REDUCE TO DESIRED NUMBER
     71	000126					  END
     72	000126					  LET $VBN := $VBN + R1		; BUMP VBN TO NEXT SEGMENT
     73	000132					  LET $VBN+2 := $VBN+2 + CARRY
     74	000136					  LET 4(SP) := 4(SP) - R1	; DECREMENT BLOCK COUNT
     75	000142					  $CALL $MUL <#512.,R1>		; COMPUTE BYTE COUNT
     76	000152					  POP R5			; GET CURRENT BUFFER ADDR
     77	000154					  LET R0 := (SP)		; GET MAIN BCB
     78	000156					  LET B.SIZ+P.CNT(R0) := B.SIZ+P.CNT(R0) + R1 ; ADD COUNT
     79	000162					  IF 2(SP) NE #0		; IF TRANSFER IS NOT COMPLETE
     80	000170					    LET R4 := R4 - #B.SIZ	; BACK UP TO ANOTHER BCB
     81	000174					    $CALL $READA <,R1,R2,R3,R4,R5> ; START THE READ
     82	000200					    LET R5 := R5 + R1		; UPDATE BUFFER ADDRESS
DRDDA	X0010 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:09  PAGE 4-1


     83	000202					    PUSH R5			; AND SAVE FOR NEXT READ
     84	000204					  ELSE				; IF THIS IS THE LAST
     85	000206					    $CALL $READA <,R1,R2,R3,(SP)+,R5> ; READ WITH MAIN BCB
     86	000214					    LEAVE LOOP
     87	000216					  END
     88	000216					END LOOP
     89	000220	005726 				TST (SP)+			; CLEAN THE STACK
     90	000222					RETURN
     91					;
     92					; TO HERE IF THIS IS A DUMMY TRANSFER OR IF THE LAST EXTENT
     93					; FAILED TO MAP.
     94					;
     95	000224	005726 			EXIT:	TST (SP)+			; DISCARD BUFFER POINTER
     96	000226					POP R4				; GET ORIGINAL BCB
     97	000230					LET B.IOST(R4) := #1		; FAKE A SUCCESSFUL COMPLETION
     98	000236					LET B.STAT(R4) := #3		; HOLDING DATA
     99	000244					$CALL $LINKI <,,,,R4>		; LINK ONTO WAIT LIST
    100	000250	005726 				TST (SP)+			; CLEAN THE STACK
    101	000252					RETURN
    102
    103
    104
    105		000001 				.END
DRDDA	X0010 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:09  PAGE 4-2
SYMBOL TABLE

B.IOST= ****** GX	L0      000120R  	TYPS2 = 000000   	$L    = 000001   	$T1   = 000005
B.SIZ = ****** GX	L1      000126R  	$BUFCK= ****** GX	$LINKI= ****** GX	$T2   = 000000
B.STAT= ****** GX	L2      000206R  	$DIDDO= 000000   	$L$   = 000000   	$VBN  = ****** GX
B0      000044R  	L3      000216R  	$DRDDA  000000RG 	$MPVBN= ****** GX	$XXX$ = 000001
EXIT    000224R  	PF.DAT= ****** GX	$EF$  = 000000   	$MUL  = ****** GX	$Y$   = 000000
E0      000220R  	P.CNT = ****** GX	$E$   = 000001   	$O$   = 000000   	$Z$   = 000000
H.VBN = ****** GX	P.FLAG= ****** GX	$IHBF = ****** GX	$R    = 177777   	$$S   = 000000
IIII  = 177777   	P.SIZ = ****** GX	$I$   = 000001   	$READA= ****** GX	$$T   = 000000
LBLS0 = 000000   	P.VBN = ****** GX	$K$   = 000000   	$SUPMC= 000043   	$$TT  = 000001
LBLS1 = 000003   	TYPS0 = 000005   	$K$L  = 000000   	$SV$  = 000000   	.$T   = 000005
LBLS2 = 000001   	TYPS1 = 000000   	$K$T  = 000005   	$T    = 000004

. ABS.	000000	   000
      	000254	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  11364 WORDS  ( 45 PAGES)
DYNAMIC MEMORY:  12276 WORDS  ( 47 PAGES)
ELAPSED TIME:  00:01:01
EXE$:DRDDA,LIS$:DRDDA/-SP=SRC$:SMAC/PA:1,DSCPRE,DRDDA
