DRDDO	X0001 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:10  PAGE 3


      1	000000					$BEGIN	DRDDO,0001,<READ DATA FROM OUTPUT DISK FILE>
						.TITLE	DRDDO	X0001 - READ DATA FROM OUTPUT DISK FILE
						.IDENT	"X0001"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  28-OCT-76  22:05
DRDDO	X0001 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:10  PAGE 4


     26					;+
     27					;
     28					; *** - $DRDDO	READ DATA FROM OUTPUT DISK FILE
     29					;
     30					; THIS ROUTINE READS THE INDICATED DATA BLOCKS FROM THE OUTPUT DISK
     31					; FILE INTO THE INDICATED DATA BUFFER. VIRTUAL BLOCKS ARE MAPPED
     32					; TO LOGICAL BLOCKS USING THE OUTPUT FILE HEADER AND LOGICAL TRANSFERS
     33					; ARE INITIATED AS NECESSARY. NOTE THAT A BLOCK COUNT CAUSES A DUMMY
     34					; TRANSFER OF ZERO LENGTH.
     35					;
     36					; INPUTS:
     37					;
     38					;	R1 = BLOCK COUNT TO READ
     39					;	$WVBN = HIGH AND LOW STARTING VBN
     40					;	R4 = INPUT BUFFER DESCRIPTOR
     41					;
     42					; OUTPUTS:
     43					;
     44					;	R4 = BUFFER DESCRIPTOR ADDRESS
     45					;	$WVBN UPDATED TO NEXT BLOCK
     46					;	BUFFER PREAMBLE INITIALIZED
     47					;	TRANSFER INTO BUFFER INITIATED
     48					;	OTHER REGISTERS CLOBBERED
     49					;
     50					;-
     51
     52	000000				$DRDDO::
     53	000000					$CALL $BUFCK <,,,,R4>		; WAIT FOR BUFFER
     54	000004					LET B.SIZ+P.VBN(R4) := $WVBN	; SET UP STARTING VBN
     55	000012					LET B.SIZ+P.VBN+2(R4) := $WVBN+2 ; IN PREAMBLE
     56	000020					LET B.SIZ+P.CNT(R4) := #0	; INIT BYTE COUNT TO 0
     57	000024					LET B.SIZ+P.FLAG(R4) := #PF.DAT	; SET DATA BLOCK FLAG
     58	000032					PUSH R1				; SAVE BLOCK COUNT
     59	000034					PUSH R4,R4			; SAVE DESCRIPTOR ADDRESS
     60	000040					LET (SP) := (SP) + #B.SIZ+P.SIZ	; BUILD START ADDRESS
     61	000044					REPEAT
     62	000044				MAP:	  LET R5 := #$OHBF		; MAP USING OUTPUT FILE HEADER
     63	000050					  LET R3 := $WVBN - H.VBN(R5)	; GET CURRENT VBN, ADJUSTED
     64	000060					  LET R2 := $WVBN+2 - CARRY - H.VBN+2(R5) ; BY BASE VBN
     65	000072					  IF 4(SP) EQ #0 GOTO EXIT	; IF NULL TRANSFER
     66	000100					  $CALL $MPVBN <,,R2,R3,,R5>	; MAP TO LOGICAL
     67	000104					  ON.ERROR
     68	000106					    $CALL $FILSZ <,,,,R5>	; COMPUTE SIZE OF THIS HEADER
     69	000114					    LET H.VBN(R5) := H.VBN(R5) + R1 ; UPDATE START VBN
     70	000120					    LET H.VBN+2(R5) := H.VBN+2(R5) + CARRY + R0
     71	000130					    LET R4 := #$OHHD		; GET HEADER BUFFER HEADER
     72	000134					    LET B.STAT(R4) := #0	; RELEASE THE BUFFER
     73	000140					    $CALL $RDNXO <,,,,R4,R5>	; TRY TO READ EXTENSION HEADER
     74	000144					    ON.NOERROR GOTO MAP		; PROCEED
     75	000146	005726 				    TST (SP)+			; DISCARD BUFFER POINTER
     76	000150					    POP R4			; GET ORIGINAL BCB
     77	000152					    LET B.IOST(R4) := #1	; FAKE A SUCCESSFUL COMPLETION
     78	000160					    LET B.STAT(R4) := #3	; READ IN PROGRESS
     79	000166					    $CALL $LINKO <,,,,R4>	; LINK ONTO WAIT LIST
     80	000172	005726 				    TST (SP)+			; CLEAN THE STACK
     81	000174					    ERRP ER.MPO			; PRINT MESSAGE
     82	000176					    RETURN
DRDDO	X0001 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:10  PAGE 4-1


     83	000200					  END
     84	000200					  IF R0 NE #0 OR R1 HI 4(SP)	; IF MORE BLOCKS MAPPED
     85	000212					    LET R0 := #0		; THAN DESIRED,
     86	000214					    LET R1 := 4(SP)		; REDUCE TO DESIRED NUMBER
     87	000220					  END
     88	000220					  LET $WVBN := $WVBN + R1	; BUMP VBN TO NEXT SEGMENT
     89	000224					  LET $WVBN+2 := $WVBN+2 + CARRY
     90	000230					  LET 4(SP) := 4(SP) - R1	; DECREMENT BLOCK COUNT
     91	000234					  $CALL $MUL <#512.,R1>		; COMPUTE BYTE COUNT
     92	000244					  POP R5			; GET CURRENT BUFFER ADDR
     93	000246					  IF 2(SP) NE #0		; IF TRANSFER IS NOT COMPLETE
     94	000254					    LET R4 := R4 - #B.SIZ	; BACK UP TO ANOTHER BCB
     95	000260					    $CALL $READO <,R1,R2,R3,R4,R5> ; START THE READ
     96	000264					    LET R5 := R5 + R1		; UPDATE BUFFER ADDRESS
     97	000266					    PUSH R5			; AND SAVE FOR NEXT READ
     98	000270					  ELSE				; IF THIS IS THE LAST
     99	000272					    $CALL $READO <,R1,R2,R3,(SP)+,R5> ; READ WITH MAIN BCB
    100	000300					    LEAVE LOOP
    101	000302					  END
    102	000302					END LOOP
    103	000304	005726 				TST (SP)+			; CLEAN THE STACK
    104	000306					RETURN
    105					;
    106					; TO HERE IF THIS IS A DUMMY TRANSFER OR IF THE LAST EXTENT
    107					; FAILED TO MAP.
    108					;
    109	000310	005726 			EXIT:	TST (SP)+			; DISCARD BUFFER POINTER
    110	000312					POP R4				; GET ORIGINAL BCB
    111	000314					LET B.IOST(R4) := #1		; FAKE A SUCCESSFUL COMPLETION
    112	000322					LET B.STAT(R4) := #3		; HOLDING DATA
    113	000330					$CALL $LINKI <,,,,R4>		; LINK ONTO WAIT LIST
    114	000334	005726 				TST (SP)+			; CLEAN THE STACK
    115	000336					RETURN
    116
    117
    118
    119		000001 				.END
DRDDO	X0001 - READ DATA FROM 	MACRO M1110  21-AUG-78 20:10  PAGE 4-2
SYMBOL TABLE

B.IOST= ****** GX	L1      000212R  	TYPS2 = 000000   	$LINKI= ****** GX	$SV$  = 000000
B.SIZ = ****** GX	L2      000220R  	$BUFCK= ****** GX	$LINKO= ****** GX	$T    = 000005
B.STAT= ****** GX	L3      000272R  	$DIDDO= 000000   	$L$   = 000000   	$T1   = 000005
B0      000044R  	L4      000302R  	$DRDDO  000000RG 	$MPVBN= ****** GX	$T2   = 000000
ER.MPO= ****** GX	MAP     000044R  	$EF$  = 000000   	$MUL  = ****** GX	$WVBN = ****** GX
EXIT    000310R  	PF.DAT= ****** GX	$E$   = 000001   	$OHBF = ****** GX	$XXX$ = 000001
E0      000304R  	P.CNT = ****** GX	$FILSZ= ****** GX	$OHHD = ****** GX	$Y$   = 000000
H.VBN = ****** GX	P.FLAG= ****** GX	$I$   = 000001   	$O$   = 000000   	$Z$   = 000000
IIII  = 177777   	P.SIZ = ****** GX	$K$   = 000000   	$R    = 177777   	$$S   = 000000
LBLS0 = 000000   	P.VBN = ****** GX	$K$L  = 000000   	$RDNXO= ****** GX	$$T   = 000001
LBLS1 = 000004   	TYPS0 = 000005   	$K$T  = 000005   	$READO= ****** GX	$$TT  = 000002
LBLS2 = 000002   	TYPS1 = 000000   	$L    = 000001   	$SUPMC= 000043   	.$T   = 000005
L0      000200R

. ABS.	000000	   000
      	000340	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  11414 WORDS  ( 45 PAGES)
DYNAMIC MEMORY:  12276 WORDS  ( 47 PAGES)
ELAPSED TIME:  00:01:19
EXE$:DRDDO,LIS$:DRDDO/-SP=SRC$:SMAC/PA:1,DSCPRE,DRDDO
