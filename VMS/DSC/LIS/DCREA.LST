DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 3


      1	000000					$BEGIN	DCREA,0020,<CREATE FILE ON DISK>
						.TITLE	DCREA	X0020 - CREATE FILE ON DISK
						.IDENT	"X0020"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  20-AUG-76  14:30
     25					;
     26					;
     27
     28						.MCALL	FHDL2$
     29	000000					FHDL2$				; DEFINE FILE HEADER OFFSETS (ODS-2)
DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 4


     31					;+
     32					;
     33					; *** - $DCREA	CREATE FILE ON DISK
     34					;
     35					; THIS ROUTINE ALLOCATES SPACE ON THE OUTPUT DISK AND INITIALIZES THE
     36					; HEADER FOR THE INDICATED FILE.
     37					;
     38					; INPUTS:
     39					;
     40					;	OUTLUN ASSIGNED TO DISK
     41					;	OUTPUT DEVICE TABLE ENTRY
     42					;	ATTRIBUTE BLOCK IN $BUF1
     43					;	FILE HEADER IN $BUF2
     44					;
     45					; OUTPUTS:
     46					;
     47					;	CC - C	CLEAR IF ALL OK
     48					;		SET IF ERROR
     49					;	FILE HEADER IN $OHBF
     50					;	BIT TURNED ON IN INDEX FILE BITMAP
     51					;	HEADER WRITTEN TO DISK
     52					;	STORAGE BITMAP ALTERED
     53					;
     54					;
     55					; *** - $DEXTD	EXTEND DISK FILE
     56					;
     57					; THIS ROUTINE EXTENDS THE DISK FILE BEING WRITTEN BY THE AMOUNT
     58					; MAPPED BY THE NEW HEADER, AND CREATES A NEW EXTENSION HEADER IF
     59					; NECESSARY.
     60					; **** - NOTE! THIS ROUTINE DOES NOT WORK FOR MULTI-VOLUME FILES!
     61
     62					;
     63					; INPUTS:
     64					;
     65					;	OUTLUN ASSIGNED TO DISK
     66					;	OUTPUT DEVICE TABLE ENTRY
     67					;	FILE EXTENSION HEADER IN $BUF2
     68					;	CURRENT FILE HEADER IN $OHBF
     69					;
     70					; OUTPUTS:
     71					;
     72					;	CC - C	CLEAR IF ALL OK
     73					;		SET IF ERROR
     74					;	UPDATED FILE HEADER IN $OHBF
     75					;	HEADER(S) WRITTEN TO DISK
     76					;	STORAGE BITMAP ALTERED
     77					;
     78					;-
     79
     80	000000				$DEXTD::
     81	000000					$CALL $FILSZ <,,,,,#$B2DAT>  	; COMPUTE ADDITIONAL SIZE **5-10-77
     82	000010					LET $ALSIZ := R1		; AND SAVE
     83	000014					LET $ALSIZ+2 := R0
     84	000020					LET R0 := $CURAL SET.BY $CURAL+2 ; SEE IF EXISTS SPACE
     85	000030					IF RESULT IS NE
     86	000032					  PUSH  #EX.AC1			; IF YES, SAVE CONTIG INDIC ON STACK.
     87	000036					ELSE
DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 4-1


     88	000040					  PUSH  #0			; SAVE NON CONTIG INDIC ON STACK.
     89	000044					END
     90	000044					LET $SWFLG := #0		; NO SWAP
     91	000050					LET $EXFLG := #1		; EXTENSION EXISTS
     92	000056					JUMPTO ALC1
     93
     94	000062				$DCREA::
     95	000062					$CALL $BUFCK <,,,,#$OHHD>	; GET FILE HEADER BUFFER
     96	000072					LET B.STAT(R4) := #1		; MARK IT BUSY
     97	000100					LET R5 := #$OHBF
     98	000104					LET $OHBF+H.VBN := #0		; INIT HEADER VBN
     99	000110					LET $OHBF+H.VBN+2 := #0
    100	000114					LET R0 := R5
    101	000116					LET R1 := #$B2DAT		; POINT TO INCOMING HEADER  **5-10-77
    102	000122					THRU R2 := #256.
    103	000126					  LET (R0)+ := (R1)+		; COPY HEADER TO BUFFER
    104	000130					END LOOP
    105	000134					LET $CURAL := #0		; INIT HOLDOVER ALLOCATION
    106	000140					LET $CURAL+2 := #0
    107	000144					IFB $B1DAT+A$FLG EQ #0 AND $B1DAT+A$FOP NE #0 ; IF CONTIGUOUS
    108	000160					  PUSH  #EX.AC1			; IF YES, SAVE CONTIG INDIC ON STACK.
    109	000164					  LET H.UCHA(R5) :B= H.UCHA(R5) SET.BY #UC.CON ; MARK THE HEADER
    110	000172					  LET R0 := $B1DAT+A$ALQ+2	;GET FILE SIZE FROM ATTRIBUTES
    111	000176					  LET R1 := $B1DAT+A$ALQ	; TO ALLOCATE ALL AT ONCE
    112	000202					ELSE				; IF NON-CONTIGUOUS
    113	000204					  PUSH  #0			; SAVE NON CONTIG INDIC ON STACK.
    114	000210					  LET H.UCHA(R5) :B= H.UCHA(R5) OFF.BY #UC.CON ; MARK THE HEADER
    115	000216					  $CALL $FILSZ <,,,,,#$B2DAT>	; ALLOCATE ONLY CURRENT HEADER'S WORTH
    116	000226					END
    117	000226					LET $ALSIZ := R1		; SAVE BLOCK COUNT
    118	000232					LET $ALSIZ+2 := R0
    119	000236					IF #KY.NBO OFF.IN $OFLAG	; IF THIS IS A BOOTABLE VOLUME
    120	000246					  BEGIN CMPBO
    121	000246					    $CALL $MPVBN <,,#0,#1,,#$B2DAT> ; FIND STARTING LBN OF FILE
    122	000266					    DCOMP $BOLBN+2,$BOLBN, R2,R3 ; SEE IF FILE CONTAINS BOOT LBN
    123	000300					    IF RESULT IS HIS
    124	000302					      LET R3 := R3 - $BOLBN	; COMPUTE OFFSET INTO FILE
    125	000306					      LET R2 := R2 - CARRY - $BOLBN+2
    126	000314	005402 				      NEG R2
    127	000316	005403 				      NEG R3
    128	000320	005602 				      SBC R2
    129	000322					      DCOMP R2,R3, R0,R1	; CHECK AGAINST END
    130	000330					      IF RESULT IS LO		; IF THE FIRST EXTENT OF THIS FILE
    131	000332						LET R3 := R3 + #01	; MAPS THE BOOT IMAGE, COMPUTE
    132	000336						LET R2 := R2 + CARRY	; THE BOOT FILE VBN
    133	000340						LEAVE CMPBO
    134	000342					      END
    135	000342					    END
    136	000342					    LET R2 := #0		; ZERO MEANS NOT MAPPED
    137	000344					    LET R3 := #0
    138	000346					  END CMPBO
    139	000346					  LET $BOVBN := R3		; SAVE THE RESULT
    140	000352					  LET $BOVBN+2 := R2
    141	000356					END
    142	000356					LET $B1HD+B.STAT := #0		; RELEASE $BUF1
    143	000362					LET $SWFLG := #0		; INDICATE NO SWAP
    144	000366					LET $EXFLG := #0		; AND NO EXTENSION HEADER
DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 4-2


    145	000372					PUSH #0				; STARTING SEGMENT NUMBER = 0
    146
    147	000376				ALCOM:	$CALL $ZMAP <,,,,,#$OHBF>	; CLEAN OUT THE MAP AREA
    148	000406					LET H.FSEG(R5) :B= (SP)+	; SET SEGMENT NUMBER
    149	000412					LET H.EFNU(R5) := #0		; EXTENSION FILE NUMBER.
    150	000416					LET H.EFSQ(R5) := #0		; EXTENSION SEQ NUMBER.
    151	000422					LET H.ERVN(R5) := #0		; EXT REL VOLUME NUMBER.
    152					;
    153					; NOW TURN ON THE HEADER'S BIT IN THE INDEX FILE BITMAP
    154					;
    155	000426					LET R4 := $OUDEV		; GET DEVICE TABLE ENTRY
    156	000432					LET R0 := $OHBF+H.FNUM
    157	000436					LET $FNU := R0			; SAVE FILE NUMBER FOR MESSAGES
    158	000442					LET R0 := R0 - #1		; GET FILE NUMBER LESS 1
    159	000444					$CALL $DIV <R0,#4096.>		; COMPUTE BLOCK NUMBER
    160	000454					PUSH R1				; SAVE BIT NUMBER
    161	000456					IF R0 HIS V.IBSZ(R4)		; IF OUT OF BOUNDS
    162	000464	005726 				  TST (SP)+			; CLEAN STACK
    163	000466					  ERRP ER.OFN			; PRINT MESSAGE
    164	000470					  RETURN			; AND QUIT ON THIS FILE
    165	000472					END
    166	000472					LET R3 := V.IBLB(R4) + R0	; COMPUTE LBN
    167	000500					LET R2 := #0 + CARRY
    168	000504					$CALL $RDWLN <#OUTLUN,,R2,R3,#$B1HD> ; READ MAP BLOCK
    169	000520					POP R0				; GET BIT NUMBER OF FILE
    170	000522					$CALL $DIV <R0,#8.>		; COMPUTE BYTE & BIT
    171	000532					LET R0 := R0 + R5		; BUFFER ADDRESS
    172	000534					LET (R0) :B= (R0) SET.BY $BIT(R1) ; TURN IT ON
    173	000540					LET B.STAT(R4) := #0		; RELEASE THE BUFFER
    174	000544					$CALL $WRI1B <,,R2,R3,R4>	; AND REWRITE THE BLOCK
    175	000550					$CALL $WAITO <,,,,R4>		; WAIT FOR COMPLETION
    176	000554					ON.ERROR THEN ERROR ER.WXB
    177					;
    178					; NOW ALLOCATE SPACE AND BUILD RETRIEVAL POINTERS
    179					;
    180	000560				ALC1:	$CALL $BUFCK <,,,,#$B1HD>	; GET I/O BUFFER
    181	000570					THRU R0 := #1024.
    182	000574					  LET (R4)+ := #0		; ZERO BUFFER FOR USE BY
    183	000576					END LOOP			; ALLOCATER
    184	000602					LET  .SMCTL  :B=  (SP)+		; SET CONTIG/NONCONTIG FOR ALLOCATOR.
    185	000606					LET R4 := $OUDEV		; OUPUT DEVICE TABLE ENTRY
    186	000612					LET R3 := V.FLBN(R4)		; GET STARTING POINT FOR SCAN
    187	000616					$CALL .SMRVB <,,,R3,R4>		; GET BITMAP BLOCK
    188	000622					REPEAT
    189	000622					  LET R0 := $ALSIZ SET.BY $ALSIZ+2 SET.BY $CURAL SET.BY $CURAL+2
    190	000642					  IF RESULT IS EQ LEAVE LOOP
    191	000644					  LET R5 := #$CURAL		; LOOK AT PREVIOUS ALLOCATION
    192	000650					  LET R1 := (R5)+
    193	000652					  LET R0 := (R5)+
    194	000654					  LET R3 := (R5)+
    195	000656					  LET R2 := (R5)+
    196	000660					  PUSH R0
    197	000662	050126 				  BIS R1,(SP)+
    198	000664					  IF RESULT IS EQ		; IF NONE ALLOCATED
    199	000666					    $CALL .SMALC <$ALSIZ+2,$ALSIZ,,,R4>	; GET SOME BLOCKS
    200	000702					    ON.ERROR THEN ERROR ER.DFU	; DEVICE FULL
    201	000706					  END
DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 4-3


    202	000706					  DCOMP R0,R1, $ALSIZ+2,$ALSIZ	; IF MORE ALLOCATED THAN NEEDED
    203	000720					  IF RESULT IS HIS
    204	000722					    LET $ALSIZ := #0		; SAY IT'S DONE
    205	000726					    LET $ALSIZ+2 := #0
    206	000732					  ELSE
    207	000734					    LET $ALSIZ := $ALSIZ - R1	; DEDUCT FROM SPACE NEEDED
    208	000740					    LET $ALSIZ+2 := $ALSIZ+2 - CARRY - R0
    209	000750					  END
    210	000750					  $CALL $BLDRP <R0,R1,R2,R3,,#$OHBF> ; BUILD MAP POINTERS
    211	000760					  LET R5 := #$CURAL
    212	000764					  LET (R5)+ := R1		; SAVE REMAINDER FOR EXTENSION
    213	000766					  LET (R5)+ := R0		; HEADER TO COME LATER
    214	000770					  LET (R5)+ := R3
    215	000772					  LET (R5)+ := R2
    216	000774					  ON.ERROR			; IF HEADER FULL
    217	000776					    $CALL .SMRVB <,,,#0,R4>	; FLUSH MAP BUFFER
    218	001006					    LET $B1HD+B.STAT := #0  	; INVALIDATE BITMAP BUFFER
    219	001012					    IF $EXFLG NE #0 GOTO EXTHD	; SWITCH TO EXTENSION HEADER
    220	001020					    IFB .SMCTL NE #0		; IF CONTIGUOUS
    221	001026					      LEAVE LOOP
    222	001030					    ELSE			; IF NON-CONTIGUOUS
    223	001032					      ERRP ER.HFU		; WE LOSE
    224	001034					      $CALL $WRHDR <,,,,#$OHHD>	; WRITE THE HEADER
    225	001044					      LET $OHHD+B.STAT := #0	; INVALIDATE HEADER
    226	001050					      LET $B2HD+B.STAT := #0	; INVALIDATE BUFFER
    227	001054					      RETURN ERROR		; MUST FLUSH THIS FILE
    228	001060					    END
    229	001060					  END
    230	001060					END LOOP
    231					;
    232					; THIS FILE HEADER IS COMPLETE
    233					;
    234	001062					IFB .SMCTL EQ #0		; IF THIS WAS A NON-CONTIGUOUS
    235	001070					  LET V.FLBN(R4) := .SMVBN	; ALLOCATION, SAVE NEW MAP VBN
    236	001076					END
    237	001076					$CALL .SMRVB <,,,#0,R4>		; FLUSH MAP BUFFER
    238	001106					$CALL $WRHDR <,,,,#$OHHD>	; WRITE THE HEADER
    239	001116					IF $SWFLG NE #0			; IF WE SWAPPED HEADERS
    240	001124					  LET R0 := #$B2DAT		; SWAP THEM BACK
    241	001130					  THRU R1 := #256.
    242	001134					    LET R2 := (R5)
    243	001136					    LET (R5)+ := (R0)
    244	001140					    LET (R0)+ := R2
    245	001142					  END LOOP
    246	001146					END
    247	001146					IF $EXFLG NE #0			; IF WE DID NOT USE AN EXTENSION HEADER
    248	001154					  $CALL $DLHDR <,,,,#$B2HD,#$B2DAT> ; DELETE IT
    249	001170					END
    250	001170					LET $B1HD+B.STAT := #0	; INVALIDATE BOTH BUFFERS
    251	001174					LET $B2HD+B.STAT := #0
    252	001200					PUSH $BOVBN			; SEE IF WE FOUND THE BOOT LBN
    253	001204	056726 	000002G			BIS $BOVBN+2,(SP)+		; IN THIS FILE
    254	001210					IF RESULT IS NE
    255	001212					  $CALL $RDWLN <#OUTLUN,,#0,#0,#$B1HD> ; READ BOOT BLOCK
    256	001236					  $CALL $MPVBN <,,$BOVBN+2,$BOVBN,,#$OHBF> ; FIND NEW LBN
    257	001256					  LET $BUF1+4 := R2		; STORE IN BOOT BLOCK
    258	001262					  LET $BUF1+6 := R3
DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 4-4


    259	001266					  LET B.STAT(R4) := #0		; RELEASE BUFFER AFTER I/O
    260	001272					  $CALL $WRI1B <,,#0,#0,#$B1HD>	; AND REWRITE IT
    261	001312					END
    262	001312					RETURN NOERROR
    263					;
    264					; WE GET HERE IF THERE IS AN EXTENSION HEADER AND THE CURRENT HEADER IS
    265					; FULL. WE WRITE THE FULL HEADER AND THEN SWAP IT FOR THE EXTENSION
    266					; HEADER AND CONTINUE THE ALLOCATION IN IT.
    267					;
    268	001316				EXTHD:	LET  R0  :=  #$OHBF		; ADDR OF HEADER TO R0.
    269	001322					LET -(SP) :B= H.FSEG(R0)	; SAVE SEGMENT NUMBER
    270	001326					LET (SP) := (SP) + #1		; BUMPED BY 1
    271	001330					LET H.EFNU(R0) := $B2DAT+H.FNUM	; FILL IN FILE NUMBER
    272	001336					LET H.EFSQ(R0) := $B2DAT+H.FSEQ	; AND SEQUENCE NUMBER
    273	001344					$CALL $WRHDR <,,,,#$OHHD>	; WRITE THE HEADER
    274	001354					LET R0 := #$B2DAT		; POINT TO NEW HEADER
    275	001360					THRU R1 := #256.
    276	001364					  LET R2 := (R5)		; SWAP OLD AND NEW HEADERS
    277	001366					  LET (R5)+ := (R0)		; IN THEIR BUFFERS
    278	001370					  LET (R0)+ := R2
    279	001372					END LOOP
    280	001376					LET $EXFLG := #0		; NO MORE EXTENSION
    281	001402					LET $SWFLG := #1		; SWAP HAS OCCURRED
    282	001410					JUMPTO ALCOM			; PROCEED WITH ALLOCATION
    283
    284
    285
    286		000001 				.END
DCREA	X0020 - CREATE FILE ON 	MACRO M1110  21-AUG-78 20:00  PAGE 4-5
SYMBOL TABLE

ALCOM   000376R  	H.EFSQ= 000020   	LBLS0 = 000005   	TYPS2 = 000000   	$L    = 000006
ALC1    000560R  	H.ERVN= 000022   	LBLS1 = 000004   	TYPS3 = 000000   	$L$   = 000000
A$ALQ = ****** GX	H.FCHA= 000064   	LBLS2 = 000017   	UC.CON= 000200   	$MPVBN= ****** GX
A$FLG = ****** GX	H.FLEV= 000006   	LBLS3 = 000006   	UC.DLK= 000100   	$OFLAG= ****** GX
A$FOP = ****** GX	H.FNUM= 000010   	L0      000040R  	V.FLBN= ****** GX	$OHBF = ****** GX
A3    = 000001   	H.FOWN= 000074   	L1      000044R  	V.IBLB= ****** GX	$OHHD = ****** GX
B.STAT= ****** GX	H.FPRO= 000100   	L10     000560R  	V.IBSZ= ****** GX	$OUDEV= ****** GX
B0      000126R  	H.FRVN= 000014   	L11     000706R  	$ALSIZ= ****** GX	$O$   = 000000
B1      000246R  	H.FSEG= 000004   	L12     000706R  	$BIT  = ****** GX	$R    = 177777
B2      000574R  	H.FSEQ= 000012   	L13     000734R  	$BLDRP= ****** GX	$RDWLN= ****** GX
B3      000622R  	H.IDOF= 000000   	L14     000750R  	$BOLBN= ****** GX	$SUPMC= 000043
B4      001134R  	H.MPOF= 000001   	L15     001060R  	$BOVBN= ****** GX	$SWFLG= ****** GX
B5      001364R  	H.PRIV= 000073   	L16     001032R  	$BUFCK= ****** GX	$T    = 000024
CMPBO = 000001   	H.PROG= 000074   	L17     001060R  	$BUF1 = ****** GX	$T1   = 000006
ER.DFU= ****** GX	H.PROJ= 000076   	L2      000204R  	$B1DAT= ****** GX	$T2   = 000005
ER.HFU= ****** GX	H.RPRO= 000102   	L20     001076R  	$B1HD = ****** GX	$WAITO= ****** GX
ER.OFN= ****** GX	H.RSOF= 000003   	L21     001146R  	$B2DAT= ****** GX	$WRHDR= ****** GX
ER.WXB= ****** GX	H.SCHA= 000065   	L22     001170R  	$B2HD = ****** GX	$WRI1B= ****** GX
EXTHD   001316R  	H.SEMK= 000104   	L23     001312R  	$CURAL= ****** GX	$XXX$ = 000001
EX.AC1= ****** GX	H.SMMX= 000110   	L3      000226R  	$DCREA  000062RG 	$Y$   = 000000
E0      000134R  	H.UCHA= 000064   	L4      000356R  	$DEXTD  000000RG 	$ZMAP = ****** GX
E1      000346R  	H.UFAT= 000024   	L5      000342R  	$DIDDO= 000000   	$Z$   = 000000
E2      000602R  	H.USE = 000072   	L6      000342R  	$DIV  = ****** GX	$$S   = 000000
E3      001062R  	H.VBN = ****** GX	L7      000472R  	$DLHDR= ****** GX	$$T   = 000012
E4      001146R  	IIII  = 177777   	OUTLUN= ****** GX	$EF$  = 000000   	$$TT  = 000016
E5      001376R  	I.BKDT= 000052   	SC.BAD= 000100   	$EXFLG= ****** GX	.SMALC= ****** GX
FP.DEL= 000010   	I.CRDT= 000022   	SC.DIR= 000040   	$E$   = 000001   	.SMCTL= ****** GX
FP.EXE= 000004   	I.EXDT= 000042   	SC.MDL= 000200   	$FILSZ= ****** GX	.SMRVB= ****** GX
FP.RDV= 000001   	I.FNAM= 000000   	S.HDHD= 000114   	$FNU  = ****** GX	.SMVBN= ****** GX
FP.WRV= 000002   	I.RVDT= 000032   	S.IDHD= 000202   	$I$   = 000001   	.$T   = 000005
H.ACOF= 000002   	I.RVNO= 000020   	S.MPHD= 000000   	$K$   = 000003   	...GBL= 000000
H.CKSM= 000776   	I.ULAB= 000062   	TYPS0 = 000006   	$K$L  = 000003   	...TPC= 000000
H.EFNU= 000016   	KY.NBO= ****** GX	TYPS1 = 000006   	$K$T  = 000005

. ABS.	000000	   000
      	001414	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  13249 WORDS  ( 52 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:03:28
EXE$:DCREA,LIS$:DCREA/-SP=SRC$:SMAC/PA:1,DSCPRE,DCREA
