DWTDA	X0007 - WRITE DATA TO D	MACRO M1110  21-AUG-78 20:45  PAGE 3


      1	000000					$BEGIN	DWTDA,0007,<WRITE DATA TO DISK FILE>
						.TITLE	DWTDA	X0007 - WRITE DATA TO DISK FILE
						.IDENT	"X0007"
      2
      3					;
      4					; COPYRIGHT (C) 1976 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  19-AUG-76  19:10
DWTDA	X0007 - WRITE DATA TO D	MACRO M1110  21-AUG-78 20:45  PAGE 4


     26					;+
     27					;
     28					; *** - $DWTDA	WRITE DATA TO DISK FILE
     29					;
     30					; THIS ROUTINE WRITES THE INDICATED DATA BLOCKS TO THE OUTPUT DISK
     31					; FILE FROM THE INDICATED DATA BUFFER. VIRTUAL BLOCKS ARE MAPPED
     32					; TO LOGICAL BLOCKS USING THE OUTPUT FILE HEADER AND LOGICAL TRANSFERS
     33					; ARE INITIATED AS NECESSARY. IF THE BUFFER'S BYTE COUNT IS ZERO, NO
     34					; TRANSFER IS MADE.
     35					;
     36					; INPUTS:
     37					;
     38					;	R4 = INPUT BUFFER DESCRIPTOR
     39					;
     40					; OUTPUTS:
     41					;
     42					;	CC - C	CLEAR IF ALL OK
     43					;		SET IF TRANSFER NOT ALL MAPPED
     44					;	R4 = BUFFER DESCRIPTOR ADDRESS
     45					;	TRANSFER FROM BUFFER INITIATED
     46					;	OTHER REGISTERS CLOBBERED
     47					;
     48					;-
     49
     50	000000				$DWTDA::
     51	000000					LET R0 := R4
     52	000002					THRU R1 := #B.SIZ*3/2		; CLEAN OUT SPARE BCB'S
     53	000006					  LET -(R0) := #0
     54	000010					END LOOP
     55	000014					LET B.STAT(R4) := #0		; RELEASE BUFFER AFTER WRITE
     56	000020					LET $WVBN := B.SIZ+P.VBN(R4)	; GET START VBN OF TRANSFER
     57	000026					LET $WVBN+2 := B.SIZ+P.VBN+2(R4)
     58	000034					LET R0 := B.SIZ+P.CNT(R4) + #511. ; GET BYTE COUNT, ROUNDED UP
     59	000044	105000 				CLRB R0				; CONVERT TO BLOCK COUNT
     60	000046	000300 				SWAB R0
     61	000050	006200 				ASR R0
     62	000052					PUSH R0				; SAVE BLOCK COUNT
     63	000054					IF RESULT IS EQ GOTO EXIT	; NO TRANSFER IF ZERO
     64	000056					PUSH R4,R4			; SAVE DESCRIPTOR ADDRESS
     65	000062					LET (SP) := (SP) + #B.SIZ+P.SIZ	; BUILD START ADDRESS
     66	000066					REPEAT
     67	000066				MAP:	  LET R5 := #$OHBF		; MAP USING OUTPUT FILE HEADER
     68	000072					  LET R3 := $WVBN - H.VBN(R5)	; GET CURRENT VBN, ADJUSTED
     69	000102					  LET R2 := $WVBN+2 - CARRY - H.VBN+2(R5) ; BY BASE VBN
     70	000114					  $CALL $MPVBN <,,R2,R3,,R5>	; MAP TO LOGICAL
     71	000120					  ON.ERROR
     72	000122					    $CALL $FILSZ <,,,,R5>	; COMPUTE SIZE OF THIS HEADER
     73	000130					    LET H.VBN(R5) := H.VBN(R5) + R1 ; UPDATE START VBN
     74	000134					    LET H.VBN+2(R5) := H.VBN+2(R5) + CARRY + R0
     75	000144					    LET R4 := #$OHHD		; GET HEADER BUFFER HEADER
     76	000150					    LET B.STAT(R4) := #0	; RELEASE THE BUFFER
     77	000154					    $CALL $RDNXO <,,,,R4,R5>	; TRY TO READ EXTENSION HEADER
     78	000160					    ON.NOERROR GOTO MAP		; PROCEED
     79	000162	005726 				    TST (SP)+			; DISCARD BUFFER POINTER
     80	000164					    POP R4			; GET ORIGINAL BCB
     81	000166					    LET B.IOST(R4) := #1	; FAKE A SUCCESSFUL COMPLETION
     82	000174					    LET B.STAT(R4) := #2	; WRITE IN PROGRESS
DWTDA	X0007 - WRITE DATA TO D	MACRO M1110  21-AUG-78 20:45  PAGE 4-1


     83	000202					    $CALL $LINKO <,,,,R4>	; LINK ONTO WAIT LIST
     84	000206	005726 				    TST (SP)+			; CLEAN THE STACK
     85	000210					    ERRP ER.MPO			; PRINT MESSAGE
     86	000212					    RETURN
     87	000214					  END
     88	000214					  IF R0 NE #0 OR R1 HI 4(SP)	; IF MORE BLOCKS MAPPED
     89	000226					    LET R0 := #0		; THAN DESIRED,
     90	000230					    LET R1 := 4(SP)		; REDUCE TO DESIRED NUMBER
     91	000234					  END
     92	000234					  LET $WVBN := $WVBN + R1	; BUMP VBN TO NEXT SEGMENT
     93	000240					  LET $WVBN+2 := $WVBN+2 + CARRY
     94	000244					  LET 4(SP) := 4(SP) - R1	; DECREMENT BLOCK COUNT
     95	000250					  $CALL $MUL <#512.,R1>		; COMPUTE BYTE COUNT
     96	000260					  POP R5			; GET CURRENT BUFFER ADDR
     97	000262					  LET R0 := (SP)		; GET MAIN BCB
     98	000264					  IF 2(SP) NE #0		; IF TRANSFER IS NOT COMPLETE
     99	000272					    LET R4 := R4 - #B.SIZ	; BACK UP TO ANOTHER BCB
    100	000276					    $CALL $WRITA <,R1,R2,R3,R4,R5> ; START THE WRITE
    101	000302					    LET R5 := R5 + R1		; UPDATE BUFFER ADDRESS
    102	000304					    PUSH R5			; AND SAVE FOR NEXT WRITE
    103	000306					  ELSE				; IF THIS IS THE LAST
    104	000310					    $CALL $WRITA <,R1,R2,R3,(SP)+,R5> ; WRITE WITH MAIN BCB
    105	000316					    LEAVE LOOP
    106	000320					  END
    107	000320					END LOOP
    108	000322	005726 			EXIT:	TST (SP)+			; CLEAN THE STACK
    109	000324					RETURN
    110
    111
    112
    113		000001 				.END
DWTDA	X0007 - WRITE DATA TO D	MACRO M1110  21-AUG-78 20:45  PAGE 4-2
SYMBOL TABLE

A3    = 000001   	LBLS0 = 000001   	TYPS0 = 000005   	$L    = 000002   	$T    = 000005
B.IOST= ****** GX	LBLS1 = 000004   	TYPS1 = 000000   	$LINKO= ****** GX	$T1   = 000005
B.SIZ = ****** GX	LBLS2 = 000002   	TYPS2 = 000000   	$L$   = 000000   	$T2   = 000001
B.STAT= ****** GX	L0      000214R  	$DIDDO= 000000   	$MPVBN= ****** GX	$WRITA= ****** GX
B0      000006R  	L1      000226R  	$DWTDA  000000RG 	$MUL  = ****** GX	$WVBN = ****** GX
B1      000066R  	L2      000234R  	$EF$  = 000000   	$OHBF = ****** GX	$XXX$ = 000001
ER.MPO= ****** GX	L3      000310R  	$E$   = 000001   	$OHHD = ****** GX	$Y$   = 000000
EXIT    000322R  	L4      000320R  	$FILSZ= ****** GX	$O$   = 000000   	$Z$   = 000000
E0      000014R  	MAP     000066R  	$I$   = 000001   	$R    = 177777   	$$S   = 000000
E1      000322R  	P.CNT = ****** GX	$K$   = 000001   	$RDNXO= ****** GX	$$T   = 000001
H.VBN = ****** GX	P.SIZ = ****** GX	$K$L  = 000001   	$SUPMC= 000043   	$$TT  = 000002
IIII  = 177777   	P.VBN = ****** GX	$K$T  = 000005   	$SV$  = 000000   	.$T   = 000006

. ABS.	000000	   000
      	000326	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  11414 WORDS  ( 45 PAGES)
DYNAMIC MEMORY:  12276 WORDS  ( 47 PAGES)
ELAPSED TIME:  00:01:23
EXE$:DWTDA,LIS$:DWTDA/-SP=SRC$:SMAC/PA:1,DSCPRE,DWTDA
