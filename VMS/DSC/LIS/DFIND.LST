DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 3


      1	000000					$BEGIN	DFIND,0022,<READ NEXT FILE HEADER FROM DISK>
						.TITLE	DFIND	X0022 - READ NEXT FILE HEADER FROM DISK
						.IDENT	"X0022"
      2
      3					;
      4					; COPYRIGHT (C) 1977 BY DIGITAL EQUIPMENT CORPORATION,
      5					; MAYNARD, MASSACHUSETTS
      6					;
      7					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
      8					; SINGLE  COMPUTER  SYSTEM AND MAY BE COPIED ONLY WITH THE IN-
      9					; CLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR
     10					; ANY  OTHER  COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
     11					; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR  USE  ON  SUCH
     12					; SYSTEM  AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE
     13					; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
     14					; IN DIGITAL.
     15					;
     16					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITH-
     17					; OUT  NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
     18					; DIGITAL EQUIPMENT CORPORATION.
     19					;
     20					; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY  FOR
     21					; THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT WHICH IS
     22					; NOT SUPPLIED BY DIGITAL.
     23					;
     24					; ANDREW C. GOLDSTEIN  1-NOV-76  22:48
     25					;
     26					;
     27
     28
     29						.MCALL	FHDL2$
     30	000000					FHDL2$			; DEFINE FILE HEADER FORMAT
DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 4


     32					;+
     33					;
     34					; *** - $DFIND	READ NEXT FILE HEADER FOM DISK
     35					;
     36					; THIS ROUTINE FINDS THE NEXT VALID FILE HEADER OF THE INPUT
     37					; DISK AND READS IT INTO THE HEADER BUFFER. IT ALSO FORMATS THE
     38					; FILE ATTRIBUTE BLOCK AND COPIES THE HEADER INTO THE I/O BUFFER
     39					; FOR OUTPUT.
     40					;
     41					; INPUTS:
     42					;
     43					;	$FID CONTAINS LAST FILE ID PROCESSED
     44					;	INLUN ASSIGNED TO INPUT DISK
     45					;	INDEX FILE HEADER IN $IXBF
     46					;
     47					; OUTPUTS:
     48					;
     49					;	CC - C	CLEAR IF HEADER READ
     50					;		SET IF NO MORE FILES ON THIS VOLUME
     51					;	$FID CONTAINS FILE ID OF NEW HEADER
     52					;	FILE HEADER IN $IHBF
     53					;	ATTRIBUTE BLOCK IN $BUF1
     54					;	HEADER BLOCK IN $BUF2
     55					;
     56					;-
     57
     58	000000				$DFIND::
     59					;
     60					; FIRST WE SCAN THE INDEX FILE BITMAP TO FIND THE NEXT ACTIVE FILE
     61					; HEADER.
     62					;
     63	000000					BEGIN SCAN
     64	000000					  REPEAT
     65	000000					    $CALL $SWID <,$RVN>		; SWITCH TO CURRENT DISK
     66	000010					    LET R5 := $INDEV		; POINT TO DEVICE TABLE ENTRY
     67	000014					    LET $RVN := V.RVN(R5)	; GET CORRECT RVN FROM TABLE
     68	000022					    LET R0 := $FID		; GET CURRENT FILE NUMBER PLUS 1
     69						    				; FOR NEXT, MINUS 1 FOR BITMAP OFFSET
     70	000026					    IF RESULT IS EQ THEN RETURN ERROR ; WRAPPED AROUND - OUT
     71	000034					    $CALL $DIV <R0,#4096.>	; 4096 BITS PER BLOCK
     72	000044					    IF R0 HIS V.IBSZ(R5)	; IF NO MORE FILES HERE
     73	000052					      LET $FID := #3		; RESET FILE NUMBER
     74	000060					      LET $RVN := $RVN + #1	; BUMP TO NEXT VOLUME
     75	000064					      IF $RVN HI $NVOL THEN RETURN ERROR ; THAT'S ALL, FOLKS!
     76	000100					      GOTO $DFIND		; RESTART THE SCAN
     77	000102					    END
     78	000102					    PUSH R1			; SAVE BIT # IN BLOCK
     79	000104					    LET R3 := V.IBLB(R5) + R0	; COMPUTE LBN
     80	000112					    LET R2 := V.IBLB+2(R5) + CARRY
     81	000120					    $CALL $RDW1B <,,R2,R3,#$IHHD> ; READ A BITMAP BLOCK
     82	000130					    ON.ERROR THEN ERROR ER.IXB
     83	000134					    LET B.STAT(R4) := #0	; INVALIDATE BUFFER NOW
     84
     85	000140					    $CALL $DIV <(SP)+,#8.>	; COMPUTE BYTE NUMBER
     86	000152					    LET R4 := #0
     87	000154					    LET R4 :B= R4 SET.BY $BIT(R1) ; GET CORRESPONDING BIT
     88	000160					    IF #1 SET.IN R0
DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 4-1


     89	000166	000304 				      SWAB R4			; SET TO HIGH BYTE
     90	000170					    END
     91	000170					    LET R0 := R0 OFF.BY #1 + R5	; MAKE WORD ADDRESS
     92	000176					    LET R3 := $FID		; KEEP TRACK OF FILE NUMBER
     93	000202					    REPEAT			; LOOP ON WORDS
     94	000202					      REPEAT			; LOOP ON BITS
     95	000202						LET R3 := R3 + #1	; BUMP TO NEXT FILE NUMBER
     96	000204						IF R4 SET.IN (R0) LEAVE SCAN ; FOUND ACTIVE HEADER
     97	000210						LET R4 := R4 L.ROTATE 1	; NEXT BIT
     98	000212					      UNTIL RESULT IS CS	; LOOP FOR BITS
     99	000214	005720 				      TST (R0)+			; BUMP TO NEXT WORD
    100	000216					      LET R4 := #1		; INIT STARTING BIT
    101	000222					    UNTIL R0 HIS #$IHBF+512.	; UNTIL END OF BLOCK
    102	000230					    LET $FID := R3		; NONE IN THIS BLOCK
    103	000234					  END LOOP			; GO BACK TO TRY THE NEXT
    104	000236					END SCAN
    105					;
    106					; FOUND AN ACTIVE FILE NUMBER - GO TRY TO READ THE HEADER
    107					;
    108	000236					LET $FID := R3			; STORE THE FILE NUMBER
    109	000242					$CALL $RDHDR <,,#0,R3>
    110	000252					ON.ERROR GOTO $DFIND		; IF IT FAILED, TRY THE NEXT
    111	000254					LET $FID+2 := H.FSEQ(R5)	; FILL IN FILE SEQ NUMBER
    112					;
    113					; IF MERGE MODE IS ON, WE WANT ONLY PRIMARY FILE HEADERS
    114					;
    115	000262					IF #KY.MRG SET.IN $OFLAG
    116	000272					  IFB H.FSEG(R5) NE #0		; IF THIS IS AN EXTENSION HEADER
    117	000300					    LET B.STAT(R4) := #0	; DISCARD THE BUFFER
    118	000304					    GOTO $DFIND			; AND RETRY
    119	000306					  END
    120	000306					END
    121										; FALL INTO ATTRIBUTE CODE
DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 5


    123					;+
    124					;
    125					; *** - $MAKAT	BUILD ATTRIBUTES FOR FILE HEADER
    126					;
    127					; THIS ENTRY POINT BUILDS AS ATTRIBUTE BLOCK FOR THE FILE HEADER
    128					; JUST READ. IT ALSO COPIES THE HEADER INTO $BUF2 FOR LATER OUTPUT.
    129					;
    130					; INPUTS:
    131					;
    132					;	HEADER IF $IHBF
    133					;
    134					; OUTPUTS:
    135					;
    136					;	ATTRIBUTE BLOCK WITH PREAMBLE IN $BUF1
    137					;	HEADER WITH PREAMBLE IN $BUF2
    138					;
    139					;-
    140
    141	000306				$MAKAT::
    142	000306					$CALL $BUFCK <,,,,#$B1HD>	; GET BUFFER #1
    143	000316					LET B.STAT(R4) := #1		; MARK BUFFER BUSY
    144	000324					$CALL $BUFCK <,,,,#$B2HD>	; OBTAIN 2ND BUFFER
    145	000334					LET R5 := #$BUF1		; POINT TO BUFFER
    146	000340					LET (R5)+ := #2048.		; BYTE COUNT OF BLOCK
    147	000344					LET (R5)+ := #PF.ATR		; FLAG FOR ATTRIBUTE BLOCK
    148	000350					LET (R5)+ := #0			; VBN
    149	000352					LET (R5)+ := #0
    150	000354					LET (R5)+ := $FID		; FILE ID
    151	000360					LET (R5)+ := $FID+2
    152	000364					LET (R5)+ := $FID+4
    153	000370					LET (R5)+ := #0			; SPARE WORD
    154	000372					LET (R5)+ := #"BA		; ASCII IDENTIFICATION
    155	000376					LET (R5)+ := #"CK
    156	000402					LET (R5)+ := #"UP
    157	000406					LET (R5)+ := #1			; ATTRIBUTE VERSION NUMBER
    158	000412					LET R3 := $INDEV		; INPUT DEVICE TABLE
    159	000416	005725 				TST (R5)+			; SKIP NAME COUNT WORD
    160	000420					LET R0 := R5			; COPY POINTER
    161	000422					LET (R0)+ := V.DVNM(R3)		; DEVICE NAME
    162	000426					$CALL $CBOMG <R0,V.DVUN(R3),#0>	; UNIT NUMBER
    163	000442					LET (R0)+ :B= #':		; DEVICE ENDS WITH ":"
    164	000446					LET (R0)+ :B= #'[		; DIRECTORY STARTS WITH [
    165	000452					$CALL	$CBOMG	<R0,$IHBF+H.PROJ,#0>	; CONVERT THE GROUP NUMBER.
    166	000466					LET (R0)+ :B= #54			; INSERT A COMMA.
    167	000472					$CALL	$CBOMG	<R0,$IHBF+H.PROG,#0>	; CONVERT THE MEMBER NUMBER.
    168	000506					LET (R0)+ :B= #']			; DIRECTORY ENDS WITH ]
    169	000512					LET R3 := #0
    170	000514					LET R3 :B= R3 SET.BY $IHBF+H.IDOF ; FIND HEADER IDENT AREA
    171	000520					LET R3 := R3 L.SHIFT 1 + #$IHBF+I.FNAM ; FILE NAME
    172					;
    173					; COPY FILE NAME, TYPE AND VERSION.
    174					;
    175	000526					WHILEB	(R3)  NE  #40		; LOOP UNTIL FIRST BLANK.
    176	000534					  LET  (R0)+  :B=  (R3)+	; COPY ONE BYTE.
    177	000536					END	LOOP
    178	000540					LET R1 := R0 - R5		; COMPUTE FILENAME BYTE COUNT
    179	000544					LET -(R5) := R1
DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 5-1


    180	000546					THRU R4 := #80. - (R5)
    181	000554					  LET (R0)+ :B= #0		; CLEAN OUT REST OF FILE NAME
    182	000556					END LOOP
    183
    184	000562					LET R2 := R0			; SWITCH POINTERS AGAIN
    185	000564					$CALL $FILSZ <,,,,,#$IHBF>	; COMPUTE FILE SIZE
    186	000574					LET (R2)+ := R1
    187	000576					LET (R2)+ := R0
    188	000600					LET R1 :B= $IHBF+H.UFAT+F.RTYP	; GET RECORD TYPE
    189	000604					LET R0 := R1 R.SHIFT 4 OFF.BY #^C17 ; EXTRACT FILE ORG
    190	000622					LET (R2)+ :B= R0
    191	000624					LET (R2)+ :B= $IHBF+H.UFAT+F.RATT ; RECORD ATTRIBUTES
    192	000630					LET R1 := R1 OFF.BY #^C17	; EXTRACT RECORD FORMAT
    193	000634					LET (R2)+ :B= R1
    194	000636					LET (R2)+ :B= $IHBF+H.UFAT+F.HDSZ ; CONTROL AREA SIZE
    195	000642					LET (R2)+ :B= $IHBF+H.UFAT+F.BKSZ ; BUCKET SIZE
    196	000646					LET R1 :B= H.FSEG(R5)		; GET EXTENSION SEGMENT NUMBER
    197	000652					LET R1 := R1 SET.BY H.EFNU(R5)	; AND EXT FILE NUMBER
    198	000656					IF RESULT IS NE AND #KY.MRG OFF.IN $OFLAG
    199	000670					  LET (R2)+ :B= #200		; SET MULTI-SEGMENT FLAG
    200										; AND MARK NON-CONTIGUOUS
    201	000674					  LET $IHBF+H.UCHA :B= $IHBF+H.UCHA OFF.BY #UC.CON
    202	000702					ELSE
    203	000704					  LET (R2)+ :B= #0
    204	000706					END
    205	000706					LET (R2)+ := $IHBF+H.UFAT+F.LMRN ; MAX RECORD NUMBER
    206	000712					LET (R2)+ := $IHBF+H.UFAT+F.HMRN
    207	000716					LET (R2)+ := $IHBF+H.UFAT+F.RSIZ ; RECORD SIZE
    208	000722					LET (R2) := #0			; SET CONTIGUOUS FLAG
    209	000724					IFB #UC.CON SET.IN $IHBF+H.UCHA THEN LET (R2) := #1
    210	000740	005722 				TST (R2)+
    211
    212	000742					LET R0 := #0
    213	000744					LET R0 :B= R0 SET.BY $IHBF+H.IDOF ; FIND IDENT AREA AGAIN
    214	000750					LET R0 := R0 L.SHIFT 1 + #$IHBF+I.CRDT ; CREATION DATE
    215	000756					THRU  R1  :=  #<4*4>		; 4 DATES, 4 WORDS EACH.
    216	000762	012022 				  MOV  (R0)+,(R2)+
    217	000764					END  <LOOP>
    218	000770					LET  R1  :=  R2			; POINT R1 INTO ATTRIB BLOCK.
    219	000772					LET (R1)+  :=  $IHBF+H.PROG	; OWNER PROGRAMMER.
    220	000776					LET (R1)+ := $IHBF+H.PROJ	; OWNER PROJECT
    221	001002					LET R0 := $IHBF+H.FPRO		; GET FILE PROTECTION
    222	001006					THRU R3 := #4			; BREAK IT UP INTO FIELDS
    223	001012					  LET R2 := #0
    224	001014					  THRU R4 := #4
    225	001020	006000 				    ROR R0			; PICK OFF 4 BIT FIELD
    226	001022	006002 				    ROR R2
    227	001024					  END LOOP
    228	001030	000302 				  SWAB R2
    229	001032					  LET R2 := R2 R.SHIFT 4
    230	001042					  LET (R1)+ :B= R2
    231	001044					END LOOP
    232	001050					THRU R0 := #<A$ID2-A$WLD-1>/2
    233	001054					  LET (R1)+ := #0		; ZERO REST OF BLOCK
    234	001056					END LOOP
    235	001062					LET (R1)+ := #"PU		; PUT IN TRAILER IDENTIFIER
    236	001066					LET (R1)+ := #"KC
DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 5-2


    237	001072					LET (R1)+ := #"AB
    238					;
    239					; NOW READ ANY EXTENSION HEADERS TO COMPUTE THE TOTAL FILE
    240					; SIZE.
    241					;
    242	001076					IF #KY.MRG SET.IN $OFLAG	; IF MERGE MODE IS ON
    243	001106					  PUSH $INDEV			; SAVE INPUT DEVICE ASSIGNMENT
    244	001112					  REPEAT
    245	001112					    $CALL $RDNXH <,,,,#$B2HD,R5> ; READ EXTENSION HEADER
    246	001122					    ON.ERROR LEAVE LOOP		; IF ANY
    247	001124					    $CALL $FILSZ <,,,,,R5>	; COMPUTE NUMBER OF BLOCKS MAPPED
    248	001130					    LET $B1DAT+A$ALQ := $B1DAT+A$ALQ + R1  ;ACCUMULATE FILE SIZE
    249	001134					    LET $B1DAT+A$ALQ+2 := $B1DAT+A$ALQ+2 + CARRY + R0
    250	001144					    LET B.STAT(R4) := #0	; DISCARD THE BUFFER
    251	001150					  END LOOP
    252	001152					  $CALL $SWID1 <(SP)+>		; RESTORE INPUT DEVICE ASSIGNMENT
    253	001160					END
    254	001160					LET B.STAT(R4) := #0		; DISCARD THE BUFFER
    255
    256	001164					$CALL $CKSM1 <,#A$CD/2,,,,#$B1DAT> ; COMPUTE CHECKSUM
    257					;
    258					; FINALLY, FORMAT THE BLOCK PREAMBLE FOR THE HEADER BLOCK
    259					; AND COPY IT INTO THE I/O BUFFER
    260					;
    261	001200					LET B.STAT(R4) := #1		; MARK BUSY
    262	001206					LET R0 := #$BUF2		; POINT TO BLOCK PREAMBLE
    263	001212					LET R1 := #$BUF1		; COPY ATTRIBUTE BLOCK PREAMBLE
    264	001216					THRU R2 := #P.SIZ/2		; SINCE THEY ARE ALMOST IDENTICAL
    265	001222					  LET (R0)+ := (R1)+
    266	001224					END LOOP
    267	001230					LET P.FLAG-P.SIZ(R0) := #PF.HDR	; EXCEPT FOR THE FLAGS
    268	001236					LET P.CNT-P.SIZ(R0) := #512.	; AND THE COUNT
    269	001244					LET R1 := #$IHBF		; POINT TO INPUT HEADER BUFFER
    270	001250					THRU R2 := #256.
    271	001254					  LET (R0)+ := (R1)+		; COPY THE HEADER
    272	001256					END LOOP
    273	001262					LET (R1)+ := #0			; INIT BASE VBN FOR MAPPING
    274	001264					LET (R1)+ := #0
    275	001266					LET $FISIZ := $B1DAT+A$ALQ	; SET TOTAL FILE SIZE
    276	001274					LET $FISIZ+2 := $B1DAT+A$ALQ+2
    277	001302					$CALL $FILSZ <,,,,,#$B2DAT>	; COMPUTE FILE HEADER SIZE
    278	001312					LET $IHVBN := R1		; AND SAVE
    279	001316					LET $IHVBN+2 := R0
    280	001322					RETURN NOERROR
    281		000001 				.END
DFIND	X0022 - READ NEXT FILE 	MACRO M1110  21-AUG-78 20:04  PAGE 5-3
SYMBOL TABLE

A$ALQ = ****** GX	FP.RDV= 000001   	IIII  = 177777   	SC.MDL= 000200   	$IHBF = ****** GX
A$CD  = ****** GX	FP.WRV= 000002   	I.BKDT= 000052   	S.HDHD= 000114   	$IHHD = ****** GX
A$ID2 = ****** GX	F.BKSZ= ****** GX	I.CRDT= 000022   	S.IDHD= 000202   	$IHVBN= ****** GX
A$WLD = ****** GX	F.HDSZ= ****** GX	I.EXDT= 000042   	S.MPHD= 000000   	$INDEV= ****** GX
A3    = 000002   	F.HMRN= ****** GX	I.FNAM= 000000   	TYPS0 = 000006   	$I$   = 000001
B.STAT= ****** GX	F.LMRN= ****** GX	I.RVDT= 000032   	TYPS1 = 000005   	$K$   = 000012
B0      000000R  	F.RATT= ****** GX	I.RVNO= 000020   	TYPS2 = 000000   	$K$L  = 000012
B1      000000R  	F.RSIZ= ****** GX	I.ULAB= 000062   	TYPS3 = 000000   	$K$T  = 000005
B10     001020R  	F.RTYP= ****** GX	KY.MRG= ****** GX	TYPS4 = 000000   	$L    = 000015
B11     001054R  	H.ACOF= 000002   	LBLS0 = 000014   	UC.CON= 000200   	$L$   = 000000
B12     001112R  	H.CKSM= 000776   	LBLS1 = 000012   	UC.DLK= 000100   	$MAKAT  000306RG
B13     001222R  	H.EFNU= 000016   	LBLS2 = 000016   	V.DVNM= ****** GX	$NVOL = ****** GX
B14     001254R  	H.EFSQ= 000020   	LBLS3 = 000005   	V.DVUN= ****** GX	$OFLAG= ****** GX
B2      000202R  	H.ERVN= 000022   	LBLS4 = 000005   	V.IBLB= ****** GX	$O$   = 000000
B3      000202R  	H.FCHA= 000064   	L0      000034R  	V.IBSZ= ****** GX	$R    = 177777
B4      000526R  	H.FLEV= 000006   	L1      000102R  	V.RVN = ****** GX	$RDHDR= ****** GX
B5      000554R  	H.FNUM= 000010   	L10     000306R  	$BIT  = ****** GX	$RDNXH= ****** GX
B6      000762R  	H.FOWN= 000074   	L11     000540R  	$BUFCK= ****** GX	$RDW1B= ****** GX
B7      001012R  	H.FPRO= 000100   	L12     000704R  	$BUF1 = ****** GX	$RVN  = ****** GX
ER.IXB= ****** GX	H.FRVN= 000014   	L13     000706R  	$BUF2 = ****** GX	$SUPMC= 000043
E0      000236R  	H.FSEG= 000004   	L14     000740R  	$B1DAT= ****** GX	$SWID = ****** GX
E1      000236R  	H.FSEQ= 000012   	L15     001160R  	$B1HD = ****** GX	$SWID1= ****** GX
E10     001030R  	H.IDOF= 000000   	L2      000100R  	$B2DAT= ****** GX	$T    = 000016
E11     001062R  	H.MPOF= 000001   	L3      000134R  	$B2HD = ****** GX	$T1   = 000006
E12     001152R  	H.PRIV= 000073   	L4      000170R  	$CBOMG= ****** GX	$T2   = 000014
E13     001230R  	H.PROG= 000074   	L7      000306R  	$CKSM1= ****** GX	$XXX$ = 000001
E14     001262R  	H.PROJ= 000076   	PF.ATR= ****** GX	$DFIND  000000RG 	$Y$   = 000000
E2      000230R  	H.RPRO= 000102   	PF.HDR= ****** GX	$DIDDO= 000000   	$Z$   = 000000
E3      000214R  	H.RSOF= 000003   	P.CNT = ****** GX	$DIV  = ****** GX	$$S   = 000000
E4      000540R  	H.SCHA= 000065   	P.FLAG= ****** GX	$EF$  = 000000   	$$T   = 000014
E5      000562R  	H.SEMK= 000104   	P.SIZ = ****** GX	$E$   = 000001   	$$TT  = 000016
E6      000770R  	H.SMMX= 000110   	SCAN  = 000000   	$FID  = ****** GX	.$T   = 000006
E7      001050R  	H.UCHA= 000064   	SC.BAD= 000100   	$FILSZ= ****** GX	...GBL= 000000
FP.DEL= 000010   	H.UFAT= 000024   	SC.DIR= 000040   	$FISIZ= ****** GX	...TPC= 000000
FP.EXE= 000004   	H.USE = 000072

. ABS.	000000	   000
      	001326	   001
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  13270 WORDS  ( 52 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:04:20
EXE$:DFIND,LIS$:DFIND/-SP=SRC$:SMAC/PA:1,DSCPRE,DFIND
