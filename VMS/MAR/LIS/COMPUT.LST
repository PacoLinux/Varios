COMPUT	MACRO M1110  21-AUG-78 21:51
TABLE OF CONTENTS

    32-    2	NUMERICAL COMPUTATIONS
    33-   94	DECLR	DECIMAL CONVERSION ROUTINE (LEFT TO RIGHT)
    34-  140	MULTIPLY TWO 32 BIT INTEGERS TO PRODUCE A 32 BIT UNSIGNED RESULT
    35-  189	DIVIDE	TWO INTEGERS TO PRODUCE A 32 BIT DIVIDEND
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 32


      1					.TITLE	COMPUT
      2					.SBTTL		NUMERICAL COMPUTATIONS
      3	000000				.PSECT	ARITH
      4					;
      5					;
      6					;		NUMERICAL COMPUTATIONS
      7					;
      8					;
      9
     10	000000				P.ADD::						; ADD TOP TWO ELEMENTS ON STACK
     11	000000					CALL	.GEN,<#L.ADD>			; ADD
     12	000010	004767 	000272 		X.ADD::	JSR	PC,.LPOP			; LOAD R0,R1 AND R2,R3
     13	000014	060002 				ADD	R0,R2				; ADD <R1-R0> TO <R3-R2>
     14	000016	005503 				ADC	R3				;
     15	000020	060103 				ADD	R1,R3				;
     16	000022				X.SAME::
     17	000022				P.SAME::
     18	000022					RETURN					; RETURN DOES "LPUSH"
     19
     20	000024				P.AND::						; LOGICAL AND
     21	000024					CALL	.GEN,<#L.AND>
     22	000034	004767 	000246 		X.AND::	JSR	PC,.LPOP			; LOAD R0,R1 AND R2,R3
     23	000040	005100 				COM	R0
     24	000042	005101 				COM	R1
     25	000044	040002 				BIC	R0,R2
     26	000046	040103 				BIC	R1,R3
     27	000050					RETURN					; RETURN DOES "LPUSH"
     28
     29	000052				P.ASH::						; SHIFT ARITHMETICALLY
     30	000052					CALL	.GEN,<#L.ASH>
     31	000062				X.ASH::	LPOP	R0,R1				; GET SHIFT COUNT
     32	000076					LPOP	R3,R2				; GET DATA TO BE SHIFTED
     33	000112	005701 				TST	R1				; FIND OUT SIGN OF SHIFT COUNT
     34	000114	100403 				BMI	5$				; SKIP IF NEGATIVE
     35	000116	042700 	177740 			BIC	#177740,R0			; SHIFT COUNT MODULO +32
     36	000122	000402 				BR	10$				; SKIP
     37	000124	052700 	177740 		5$:	BIS	#177740,R0			; SHIFT COUNT MODULO -32
     38	000130	073200 			10$:	ASHC	R0,R2
     39	000132					LPUSH	R3,R2
     40	000146					RETURN
     41
     42	000150				P.NEG::						; NEGATE
     43	000150					CALL	.GEN,<#L.NEG>
     44	000160	004767 	000136 		X.NEG::	JSR	PC,.LPOP1			; LOAD R2,R3
     45	000164	005402 				NEG	R2
     46	000166	005503 				ADC	R3
     47	000170	005403 				NEG	R3
     48	000172					RETURN					; RETURN DOES "LPUSH"
     49
     50	000174				P.NOT::						; LOGICAL COMPLEMENT
     51	000174					CALL	.GEN,<#L.COM>
     52	000204	004767 	000112 		X.NOT::	JSR	PC,.LPOP1			; LOAD R2,R3
     53	000210	005102 				COM	R2
     54	000212	005103 				COM	R3
     55	000214					RETURN					; RETURN DOES "LPUSH"
     56
     57	000216				P.OR::						; LOGICAL OR
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 32-1
NUMERICAL COMPUTATIONS

     58	000216					CALL	.GEN,<#L.OR>
     59	000226	004767 	000054 		X.OR::	JSR	PC,.LPOP			; LOAD R0,R1 AND R2,R3
     60	000232	050002 				BIS	R0,R2
     61	000234	050103 				BIS	R1,R3
     62	000236					RETURN					; RETURN DOES "LPUSH"
     63
     64	000240				P.SUB::						; SUBTRACT
     65	000240					CALL	.GEN,<#L.SUB>
     66	000250	004767 	000032 		X.SUB::	JSR	PC,.LPOP			; SUBTRAHEND TO <R1,R0>
     67	000254	160002 				SUB	R0,R2				; SUBTRACT LOWER 16 BITS
     68	000256	005603 				SBC	R3				;
     69	000260	160103 				SUB	R1,R3				; SUBTRACT UPPER 16 BITS
     70	000262					RETURN					; RETURN DOES "LPUSH"
     71
     72	000264				P.XOR::						; EXCLUSIVE OR
     73	000264					CALL	.GEN,<#L.EOR>
     74	000274	004767 	000006 		X.XOR::	JSR	PC,.LPOP			; LOAD R0,R1 AND R2,R3
     75	000300	074002 				XOR	R0,R2
     76	000302	074103 				XOR	R1,R3
     77	000304					RETURN					; RETURN DOES "LPUSH"
     78
     79
     80	000306				.LPOP::	LPOP	R0,R1				; LOAD R0 AND R1
     81	000322				.LPOP1:	LPOP	R2,R3				; LOAD R2 AND R3
     82	000336	004736 				JSR	PC,@(SP)+			; CO-ROUTINE RETURN
     83	000340					LPUSH	R2,R3				; SAVE RESULT
     84	000354	000207 				RTS	PC				; FINAL RETURN
     85
     86	000356				.GEN::						; R0 HAS OBJECT COMMAND
     87	000356					IF OBJPTR HI #OBJWRN THEN
     88	000366					    CALL WRTOBJ
     89	000372					END
     90	000372					LET OBJBYT	:B= R0
     91	000376					CALL OUTOBJ				; OUTPUT BYTE
     92	000402					RETURN
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 33
DECLR	DECIMAL CONVERSION ROUTINE (LEFT TO RIGHT)

     94					.SBTTL	DECLR	DECIMAL CONVERSION ROUTINE (LEFT TO RIGHT)
     95					;
     96					; THE NUMBER TO OUTPUT IS ON TOP OF THE STACK (V1STACK,V2STACK),
     97					; R3 POINTS TO THE OUTPUT BUFFER FOR THE CHARACTERS
     98					;
     99
    100	000404				PROCEDURE	DECLR				; OUTPUT ZERO-SUPPRESSED
    101
    102	000404					PUSH	R1,R2				; SAVE R1, R2
    103	000410					PUSH	R3				; SAVE STARTING POINTER
    104	000412					LPOP		EXPOP1,EXPOP2		; GET NUMBER
    105	000432					REPEAT THRU R2	:= #10.			; DO 5 DIVISIONS
    106	000436					    LPUSH	EXPOP1,EXPOP2		; PUSH VALUE
    107	000456					    LPUSH	#10.,#0			; MULTIPLIER
    108	000476					    LPUSH	EXPOP1,EXPOP2		; VALUE
    109	000516					    LPUSH	#10.,#0			; DIVISOR
    110	000536					    PUSH	R2,R3			; SAVE POINTER
    111	000542					    CALL X.DIV				; DIVIDE BY 10
    112	000546					    LET EXPOP1	:= V1STACK(R4)		; SAVE QUOTIENT
    113	000554					    LET EXPOP2	:= V2STACK(R4)
    114	000562					    CALL	X.MUL			; MULTIPLY BY 10
    115	000566					    CALL 	X.SUB			; CALCULATE REMAINDER
    116	000572					    LPOP	R0,R1			; GET REMAINDER
    117	000606					    POP		R3,R2			; RESTORE POINTER
    118	000612					    PUSH	R0			; SAVE CHARACTER
    119	000614					END
    120	000616					LET R1		:= 0			; NON-ZERO DIGIT FLAG
    121	000620					REPEAT THRU R0	:= #10.			; TEN DIGITS MAX
    122	000624					    POP		R2			; GET DIGIT OFF STACK
    123	000626					    LET R2	:= R2 SET.BY R1		; OR IN FLAGS
    124	000630					    IF R2 IS NE THEN			; PRINT IT
    125	000634						LET R1	:= #^O10000		; SET FLAG BIT
    126	000640						LET R2	:= R2 + #'0		; CONVERT TO ASCII
    127	000644						LET (R3)+ :B= R2		; STORE CHAR
    128	000646					    END
    129	000646					END
    130	000650					IF R3 EQ (SP)+ THEN			; ANY CHARS?
    131	000654					    LET (R3)+	:B= #'0			; NO, IT WAS ZERO
    132	000660					END
    133	000660					POP R2,R1				; RESTORE R2, R1
    134	000664				ENDPROCEDURE	DECLR
    135
    136
    137
    138
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 34
MULTIPLY TWO 32 BIT INTEGERS TO PRODUCE A 32 BIT UNSIGNED RESU

    140					.SBTTL	MULTIPLY TWO 32 BIT INTEGERS TO PRODUCE A 32 BIT UNSIGNED RESULT
    141	000000				.PSECT	MULDIV
    142					;++
    143					;
    144					; THE TWO ITEMS ON TOP OF THE "V2-V1" STACK ARE MULTIPLIED TOGETHER AND
    145					; THE RESULT IS REPLACED ON THE TOP OF THAT STACK.  A 48-BIT PRODUCT IS
    146					; CALCULATED SO THAT OVERFLOW OUT OF 32-BITS CAN BE DETERMINED.  STATUS
    147					; IS RETURNED IN "VAL3" WHICH IS ZERO IF NO OVERFLOW OCCURED AND NON-ZERO
    148					; IF OVERFLOW OCCURED.
    149					;
    150					;--
    151
    152	000000				P.MUL::
    153	000000					CALL .GEN,<#L.MUL>
    154	000010				X.MUL::				; DOUBLE PRECISION MULTIPLY
    155	000010					LPOP	VAL1,VAL2		; POP MULTIPLIER
    156	000030					LPOP	TEMP0,TEMP1		; AND MULTIPLICAND
    157	000050	004767 	000022 			JSR	PC,MULTIP		; CALL WORK ROUTINE
    158	000054					LPUSH	VAL1,VAL2		; STACK RESULT
    159	000074	000207 				RTS	PC
    160
    161	000076				MULTIP:	SAVAL				; SAVE R0 - R5
    162	000102	016703 	000000G			MOV	TEMP0,R3		; LOAD MULTIPLICAND INTO R2 - R3
    163	000106	016702 	000000G			MOV	TEMP1,R2		;
    164	000112	006704 				SXT	R4			; CREATING 48 BIT PRODUCT
    165	000114	016701 	000000G			MOV	VAL1,R1			; LOAD MULTIPLIER INTO R0 - R1
    166	000120	016700 	000000G			MOV	VAL2,R0			;
    167	000124	012705 	000040 			MOV	#32.,R5			; LOAD LOOP COUNT
    168	000130	005067 	000000G			CLR	VAL1			; INITIALIZE RESULT
    169	000134	005067 	000000G			CLR	VAL2			;
    170	000140	005067 	000000G			CLR	VAL3			;
    171	000144	032701 	000001 		10$:	BIT	#1,R1			; IS LOWEST BIT OF MULTIPLIER SET
    172	000150	001414 				BEQ	20$			; SKIP IF CLEAR
    173	000152	060367 	000000G			ADD	R3,VAL1			; ADD MULTIPLIER <15 - 0>
    174	000156	005567 	000000G			ADC	VAL2			; ADD IN CARRY, IF ANY
    175	000162	005567 	000000G			ADC	VAL3			;
    176	000166	060267 	000000G			ADD	R2,VAL2			; ADD MULTIPLIER <31 - 16>
    177	000172	005567 	000000G			ADC	VAL3			; ADD IN CARRY
    178	000176	060467 	000000G			ADD	R4,VAL3			; ADD MULTIPLIER <47 - 32>
    179	000202	073027 	177777 		20$:	ASHC	#-1,R0			; RIGHT SHIFT MULTIPLIER
    180	000206	001404 				BEQ	25$			; EXIT IF MULTIPLIER NOW ZERO
    181	000210	073227 	000001 			ASHC	#1,R2			; LEFT SHIFT MULTIPLICAND
    182	000214	006104 				ROL	R4			;
    183	000216	077526 				SOB	R5,10$			; LOOP 31 TIMES
    184	000220	005767 	000000G		25$:	TST	VAL3			; ARE BITS <47 - 32> ZERO
    185	000224	001402 				BEQ	30$			; EXIT IF NO OVERFLOW
    186	000226	005167 	000000G			COM	VAL3			; -1 IS OKAY TOO
    187	000232	000207 			30$:	RTS	PC			;
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 35
DIVIDE	TWO INTEGERS TO PRODUCE A 32 BIT DIVIDEND

    189					.SBTTL	DIVIDE	TWO INTEGERS TO PRODUCE A 32 BIT DIVIDEND
    190
    191
    192					;	BLISS CALLING SEQUENCE
    193					;		VALUE = INTDIV(OPND1,OPND2,RESLT)
    194					;
    195					;		OPND1	ADDRESS OF OPERAND ONE (I4)
    196					;		OPND2	ADDRESS OF OPERAND TWO (I4)
    197					;		RESLT	ADDRESS OF RESULT (I4)
    198					;		VALUE	0 - OVERFLOW OR ZERODIVIDE OCCURRED
    199					;			1 - GOOD VALUE
    200					;
    201					;	ALGORITHM
    202					;		THE ALGORITHM IS THAT USED BY THE KA-10 HARDWARE
    203					;		DIVIDE.  THE COMMENTING REFLECTS INTERNAL REGISTERS.
    204					;		IT IS SUGGESTED THAT THE READER REFER TO THE -10
    205					;		ASSEMBLY LANGUAGE MANUAL IN READING THIS CODE.
    206					;
    207
    208	000234				P.DIV::				; DOUBLE PRECISION DIVIDE
    209	000234					CALL .GEN,<#L.DIV>
    210	000244				X.DIV::
    211	000244					LPOP	VAL1,VAL2		; POP DIVIDEND
    212	000264					LPOP	TEMP0,TEMP1		; AND DIVISOR
    213	000304	004767 	000022 			JSR	PC,DIVIDE		; CALL WORKING ROUTINE
    214	000310					LPUSH	VAL1,VAL2		; STACK RESULT
    215	000330	000207 				RTS	PC			; REAL RETURN
    216
    217	000332				DIVIDE:	SAVAL				; SAVE R0 - R5
    218	000336					LET	R5	:= TEMP0	; GET DIVISOR
    219	000342					LET	R4	:= TEMP1	;
    220	000346					LET	R1	:= #VAL1	; POINT TO DIVIDEND
    221	000352	005002 				CLR	R2			; CLEAR "AR"
    222	000354	005003 				CLR	R3
    223	000356	005704 				TST	R4
    224	000360	006746 				SXT	-(SP)			; NEGATIVE DIVIDEND FLAG
    225	000362	002003 				BGE	6$
    226	000364	005404 				NEG	R4			; NEGATE "MQ"
    227	000366	005405 				NEG	R5
    228	000370	005604 				SBC	R4
    229	000372	006305 			6$:	ASL	R5			; PRE-SHIFT "AR" AND "MQ"
    230	000374	006104 				ROL	R4
    231	000376	006103 				ROL	R3
    232	000400	012700 	000040 			MOV	#32.,R0			; SET UP LOOP COUNT
    233	000404	005046 				CLR	-(SP)			; SET FIRST TEST CONDITION
    234	000406	066116 	000002 		1$:	ADD	2(R1),(SP)		; TEST IF SIGN OF DIVISOR AND
    235	000412	100415 				BMI	2$			; LAST QUOTIENT BIT SAME
    236	000414	161103 				SUB	(R1),R3			; SUBTRACT DIVISOR FROM "AR"
    237	000416	005602 				SBC	R2
    238	000420	166102 	000002 			SUB	2(R1),R2
    239	000424	002414 				BLT	3$			; IF NEGATIVE, ALL OK
    240	000426	022700 	000040 			CMP	#32.,R0			; IF NOT FIRST ITER, ALL OK
    241	000432	001011 				BNE	3$			; (N = 0)
    242	000434	022626 				CMP	(SP)+,(SP)+		; FIX STACK
    243	000436	012767 	000001 	000000G		MOV	#1,VAL3			; SET DIVIDE BY ZERO EXCEPTION
    244	000444	000430 				BR	9$
    245	000446	061103 			2$:	ADD	(R1),R3			; ADD DIVISOR TO "AR"
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 35-1
DIVIDE	TWO INTEGERS TO PRODUCE A 32 BIT DIVIDEND

    246	000450	005502 				ADC	R2
    247	000452	066102 	000002 			ADD	2(R1),R2
    248	000456	006716 			3$:	SXT	(SP)			; DETERMINE QUOTIENT BIT = NOT(SIGN)
    249	000460	062716 	000001 			ADD	#1,(SP)			; (SP) = QUOTIENT BIT; C = NOT(SP)
    250	000464	006016 				ROR	(SP)			; ROTATE Q-BIT INTO C, C INTO (SP)
    251	000466	006105 				ROL	R5			; ROTATE Q-BIT INTO "MQ"
    252	000470	006104 				ROL	R4
    253	000472	006103 				ROL	R3
    254	000474	006102 				ROL	R2
    255	000476	077035 				SOB	R0,1$			; LOOP 31 TIMES
    256	000500	005726 				TST	(SP)+			; REMOVE TEMP
    257	000502	042716 	077777 			BIC	#077777,(SP)		; MAKE SURE NO CARRY INTO SIGN
    258	000506	066126 	000002 			ADD	2(R1),(SP)+		; XOR NEGATIVE DIVIDEND AND
    259	000512	100003 				BPL	8$			; DIVISOR SIGN - IF DIFFERENT,
    260	000514	005404 				NEG	R4			; NEGATE QUOTIENT
    261	000516	005405 				NEG	R5
    262	000520	005604 				SBC	R4
    263	000522	005067 	000000G		8$:	CLR	VAL3			; CLEAR "DIVIDE BY ZERO" FLAG
    264	000526				9$:	LET	VAL1	:= R5		; SET RESULT
    265	000532					LET	VAL2	:= R4
    266	000536	000207 				RTS	PC			; RETURN TO CO-ROUTINE FIRST
    267
    268
    269		000001 			.END
COMPUT	MACRO M1110  21-AUG-78 21:51  PAGE 35-2
SYMBOL TABLE

A3    = 000000   	L.MUL = ****** GX	P.ASH   000052RG    002	S.DF  = 100000   	X.NEG   000160RG    002
BLNK  = 000040   	L.NEG = ****** GX	P.DIV   000234RG    003	S.EPT = 000100   	X.NOT   000204RG    002
B0      000436R     002	L.OR  = ****** GX	P.MUL   000000RG    003	S.EXTN= 010000   	X.OR    000226RG    002
B1      000624R     002	L.SUB = ****** GX	P.NEG   000150RG    002	S.GLOB= 020000   	X.SAME  000022RG    002
COMMA = 000054   	L0      000372R     002	P.NOT   000174RG    002	S.LOCL= 001000   	X.SUB   000250RG    002
CR    = 000015   	L1      000646R     002	P.OR    000216RG    002	S.ODBG= 000040   	X.XOR   000274RG    002
DECLR   000404RG    002	L2      000660R     002	P.SAME  000022RG    002	S.REF = 000400   	$DIDDO= 000000
DIVIDE  000332R     003	MULTIP  000076R     003	P.SUB   000240RG    002	S.TKMS= 000377   	$E$   = 000001
EXPOP1= ****** GX	M.ARGC= 000014   	P.XOR   000264RG    002	S.WEAK= 040000   	$F$   = 000000
EXPOP2= ****** GX	M.ARGS= 000016   	RGTANG= 000076   	TAB   = 000011   	$I$   = 000001
E0      000616R     002	M.END = 000012   	RTNVAL=%000000   	TEMP0 = ****** GX	$L    = 000002
E1      000650R     002	M.GETL= 000004   	R6    =%000006   	TEMP1 = ****** GX	$LL   = 000000
FF    = 000014   	M.IFLV= 000006   	R7    =%000007   	TYPS0 = 000000   	$L$   = 000000
IIII  = 177777   	M.IFVL= 000010   	SEMI  = 000073   	TYPS1 = 000000   	$O$   = 000000
LBLS0 = 000002   	M.LINK= 000000   	SPACE = 000040   	VAL1  = ****** GX	$R    = 177777
LBLS1 = 000001   	M.NXTL= 000002   	SYMCHR= 000012   	VAL2  = ****** GX	$T    = 000003
LF    = 000012   	OBJBYT= ****** GX	SYMFLA= 000002   	VAL3  = ****** GX	$T1   = 000000
LFTANG= 000074   	OBJPTR= ****** GX	SYMLEN= 000011   	V1STAC= ****** GX	$T2   = 000002
LOWCAS= 000140   	OBJWRN= ****** GX	SYMLIN= 000000   	V2STAC= ****** GX	$Y$   = 000000
LPTLEN= 000074   	OUTOBJ= ****** GX	SYMMAX= 000017   	WRTOBJ= ****** GX	$Z$   = 000000
L.ADD = ****** GX	PSECCH= 000020   	SYMSEG= 000010   	X.ADD   000010RG    002	.GEN    000356RG    002
L.AND = ****** GX	PSECOP= 000016   	SYMVL1= 000004   	X.AND   000034RG    002	.LPOP   000306RG    002
L.ASH = ****** GX	PSECV1= 000012   	SYMVL2= 000006   	X.ASH   000062RG    002	.LPOP1  000322R     002
L.COM = ****** GX	PSECV2= 000014   	S.ABS = 004000   	X.DIV   000244RG    003	.SAVAL= ****** GX
L.DIV = ****** GX	P.ADD   000000RG    002	S.ASN = 000200   	X.MUL   000010RG    003	.$T   = 000001
L.EOR = ****** GX	P.AND   000024RG    002	S.DBG = 002000

. ABS.	000000	   000
      	000000	   001
ARITH 	000666	   002
MULDIV	000540	   003
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  11772 WORDS  ( 46 PAGES)
DYNAMIC MEMORY:  13332 WORDS  ( 51 PAGES)
ELAPSED TIME:  00:01:16
OBJ$:COMPUT,LIS$:COMPUT/-SP=SRC$:MD,COMMON,COMPUT
