ACTSTA	MACRO M1110  21-AUG-78 22:31
TABLE OF CONTENTS

    32-    8	MACHINE STATEMENTS
    33-   41	OPCODE GENERATION
    34-   79	OPERAND GENERATION
    35-  159	ASSIGNMENT STATEMENTS
    37-  235	DATA GENERATION DIRECTIVES
    38-  281	DATA ARGUMENT STORAGE ROUTINES
    39-  335	REPEATED AND SINGLE DATA GENERATION ROUTINE
    41-  416	BLOCK ALLOCATION DIRECTIVES
    42-  473	LABEL DEFINITION ROUTINE
    43-  512	ENTRY POINT DEFINITION ROUTINES
    43-  536	.VECTOR/.MASK DIRECTIVE ROUTINES
    43-  555	.TRANSFER DIRECTIVE
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 32


      1					.TITLE	ACTSTA
      2	000000				.PSECT	ACTSTA
      3					.GLOBL	MINST1,	OPRAND,	ASSHD1,	ASSHD2,	ASSHD3,	ASSGN1
      4					.GLOBL	BYTE,	WORD,	LONG,	ADDRES,	STOADR,	DATARG,	DALST1
      5					.GLOBL	DALST2,	QUDSTR,	DATNUL,	BLKBYT,	BLKWRD,	BLKLNG,	BLKQUD
      6					.GLOBL	BSTAT1,	BSTAT2,	LBL1,	LBL2,	ENTRY1,	VECTR0,	VECTR1
      7		000010 			FP.REL	= 10			; ABSOLUTE/RELOCATABLE FLAG BIT IN PSECT HEADER
      8					.SBTTL	MACHINE STATEMENTS
      9					;
     10					;
     11					;			MACHINE STATEMENTS
     12					;
     13					;
     14					; THIS IS THE HEART OF THE MARS ASSEMBLER.  THESE ROUTINES HANDLE MACHINE
     15					; INSTRUCTIONS WHICH APPEAR AS SPECIAL BLOCKS IN THE SYMBOL TABLE.  THE
     16					; 'SYMSEG' BYTE IS THE NUMBER OF OPERANDS THE INSTRUCTION NEEDS.  FOLLOWING
     17					; THE SYMBOLS NAME IS A LIST OF PAIRS OF WORDS DESCRIBING THE OPERANDS.
     18					; THE FIRST BYTE IN EACH PAIR GIVES THE SIZE OF THE OPERAND IN BYTES.
     19					; THE SECOND BYTE CONTAINS FLAGS DESCRIBING THE OPERAND, AND THE SECOND
     20					; WORD CONTAINS A BIT MASK DESCRIBING THE **ILLEGAL** ADDRESSING MODES
     21					; ASSOCIATED WITH THE OPERAND.  FOR EXAMPLE, ALMOST ALL MODES ARE ILLEGAL
     22					; FOR A BRANCH DESTINATION, WHILE ALL MODES ARE LEGAL FOR A GENERAL SOURCE
     23					; OPERAND.
     24					;
     25					;
     26					; VARIABLE DEFINITIONS:
     27					;
     28					;
     29					; IN THE SYMBOL TABLE THE FOLLOWING BITS ARE DEFINED IN THE
     30					; FLAGS BYTE IN EACH OPERAND DESCRIPTOR (SEE ABOVE.)
     31					;
     32
     33
     34	000000				STAT1::				; STATEMENT = MACHINE_STAT
     35	000000					IF MOPNUM IS GT THEN
     36	000006					    CALL ERORPT,#NTENFO			; NOT ENOUGH OPERANDS SUPPLIED
     37	000016					END
     38	000016					RETURN
     39
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 33
OPCODE GENERATION

     41					.SBTTL	OPCODE GENERATION
     42
     43	000020				MINST1:				; MACHINE_INST = DOPCODE
     44
     45	000020					LET R0		:= VAL1			; POINT TO SYMBOL BLOCK FOR INSTRUCTION
     46	000024					OUT #I.OP,SYMVL1(R0)
     47	000040					INCRPC		#1
     48	000052					IF #^O177400 SET.IN SYMVL1(R0) THEN
     49	000062					    INCRPC	#1			; UPDATE PC FOR 2 BYTE OPCODE
     50	000074					END
     51	000074					LET MOPNUM	:B= SYMSEG(R0)		; OPERAND COUNT
     52	000102					LET R1		:B= SYMLEN(R0) +1 R.SHIFT 1 L.SHIFT 1 ; ROUND LENGTH
     53	000114					LET R0		:= R0 + #SYMCHRS + R1	; POINT TO OPERAND LIST
     54	000122					LET MOPPTR	:= R0			; SAVE POINTER TO MODE BITS
     55
     56	000126				MOPEXI:						; OPCODE/OPERAND EXIT
     57	000126					LET OPSIZE	:B= @MOPPTR OFF.BY #^C^O17 ; SIZE OF THIS OPERAND
     58	000142					LET EVALEXPR	:= TRUE			; GENERATE CODE TO EVALUATE EXPRESSION
     59	000150					LET OPSIZE+1	:B= 0			; CLEAR OPTIMIZE FLAG BYTE
     60	000154					IFB OPSIZE EQ #8. THEN			; CHECK DATA SIZE FOR FLOATING POINT
     61	000164					    LET FLTWDC	:= #2			; DOUBLE PRECISION
     62	000172					ELSE
     63	000174					    LET FLTWDC	:= #1			; SINGLE PRECISION
     64	000202					END
     65	000202					IF FRMPTR HI #FRMWRN THEN CALL WRTFRM	; FLUSH BUFFER IF NEAR END
     66	000216					LET IREG	:= 0
     67	000222					LET IMODE	:= 0
     68	000226					LET COMPEXPR	:= TRUE			; ASSUME WE KNOW EXPRESSION
     69	000234					LET PRMSEG	:= PSTNUM		; START WITH CURRENT PSECT
     70	000242					LET EXPOPT	:= TRUE			; ASSUME EXPRESSION OPTIMIZATION
     71	000250					LET EXPPTR	:= FRMPTR		; WHERE EXPRESSION STARTS
     72	000256					LET EXPEND	:= FRMPTR		; ASSUME NO EXPR
     73	000264					LET ABSEXPR	:= 0			; ASSUME ABSOLUTE EXPR
     74	000270	016767 	000000G	000000G		MOV	PC1,XPC1			; SAVE THE PC IN CASE TOO
     75	000276	016767 	000000G	000000G		MOV	PC2,XPC2			; MANY OPERANDS
     76	000304					RETURN
     77
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 34
OPERAND GENERATION

     79					.SBTTL	OPERAND GENERATION
     80
     81	000306				OPRAND::			; OPERANDS = REF
     82									; OPERANDS = OPERANDS DCOMMA REF
     83	000306					IF MOPNUM IS LE THEN
     84	000314					    CALL ERORPX,#TMNYRF			; TOO MANY OPERANDS
     85	000324	016767 	000000G	000000G		    MOV	XPC1,PC1			; RESTORE PC
     86	000332	016767 	000000G	000000G		    MOV	XPC2,PC2			; TO PRE-OPERAND VALUE
     87	000340					    JUMPTO  MOPEXI			; EXIT!!!
     88	000344					END;IF
     89	000344					LET R0		:B= @MOPPTR		; GET MODE MASK
     90	000350					LET R0		:= R0 OFF.BY #^C160	; MASK OFF SIZE AND FLAGS
     91	000354					LET R0		:= R0 SHIFT #-3		; GET INDEX TO "MODTAB"
     92	000360					LET R1		:B= VAL1		; GET MODE OF OPERAND
     93	000364					LET R2		:B= #1 SHIFT R1		; MOVE BIT TO MODE POSITION
     94	000372					IF R2 SET.IN MODTAB(R0) THEN
     95	000400					    CALL ERORPX,#ILLMOD			; ILLEGAL ADDRESSING MODE
     96	000410					    LET R0	:= 0			; ARG DESCRIPTOR OF ZERO
     97	000412					ELSE
     98	000414					    LET R0	:B= @MOPPTR		; PICK UP ARG DESC.
     99	000420					END;IF
    100	000420					LET MOPPTR	:= MOPPTR +1		; POINT TO NEXT DESCRIPTOR
    101	000424					LET MOPNUM	:= MOPNUM -1		; ONE LESS OPERAND
    102	000430					IF RESULT IS EQ AND ERRPTX NE #LINEBF THEN ; LAST OPERAND?
    103	000442					    LET OPSIZE	:= OPSIZE SET.BY #^O20000 ; MARK LAST OPERAND
    104	000450					END
    105	000450					IF COMPEXPR IS FALSE THEN		; CAN'T OPTIMIZE
    106	000456					    LET EXPOPT	:= FALSE
    107	000462					END
    108	000462					IF EXPOPT IS TRUE THEN			; CAN OPTIMIZE!
    109	000470					    CALL OPTEXP				; OPTIMIZE EXPRESSION
    110	000474					    LET OPSIZE	:= OPSIZE + #^O10000	; MARK OPTIMIZATION
    111	000502					END
    112	000502					IFB R0 EQ #BB ORB R0 EQ #BW THEN	; BRANCH DEST!
    113	000516					    IFB R0 EQ #BW THEN			; WORD DISPLACEMENT IS TW0 BYTES
    114	000524						INCRPC	#1			; UPDATE PC
    115	000536					    END
    116	000536					    IF VAL2 NE #15. THEN
    117	000546						CALL ERORPX,#ILLBRN		; ILLEGAL BRANCH DESTINATION
    118	000556					    ELSE
    119	000560						IF MODE EQ #M.D8 THEN		; CORRECT THE BRANCH SIZE
    120	000570						    DECRPC	#1
    121	000602						ELSE
    122	000604						    IF MODE EQ #M.D16 THEN
    123	000614							DECRPC	#2
    124	000626						    ELSE
    125	000630							DECRPC	#4
    126	000642						    END
    127	000642						END
    128	000642						IF EXPOPT IS FALSE THEN		; NOT OPTIMIZED
    129	000650						    LET EXPOP1	:= 0		; ASSUME GLOBAL
    130	000654						    LET EXPOP2	:= 0
    131	000660						    LET R0	:= EXPPTR	; POINT TO EXPR
    132	000664						    LET R1	:= EXPEND - R0	; LENGTH OF EXPR
    133	000672						    IF R0 IS NE AND R1 EQ #4 THEN ; SYMBOL REFERENCE?
    134	000704							LET R1	:= (R0)		; GET COMMAND
    135	000706	000301 						SWAB R1			; GET HIGH BYTE
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 34-1
OPERAND GENERATION

    136	000710							IFB R1 EQ #I.STKS THEN	; SYMBOL REFERENCE?
    137	000716							    LET EXPOP1	:= 2(R0) ; YES
    138	000724							    LET EXPOP2	:= PSTNUM ; MUST BE IN SAME PSECT
    139	000732							    LET 2(R0)	:= 0	; MARK AS SPECIAL RESOLUTION
    140	000736							END
    141	000736						    END
    142	000736						END
    143	000736						OUT #I.BDST,<OPSIZE,EXPOP1,EXPOP2> ; OUTPUT BRANCH DEST
    144	000762					    END
    145	000762					ELSE					; REFERENCE
    146	000764					    IF EXPOPT IS TRUE THEN		; VALUE KNOWN?
    147	000772						OUT #I.REF,<VAL1,VAL2,OPSIZE,EXPOP1,EXPOP2>
    148	001026					    ELSE
    149	001030						OUT #I.REF,<VAL1,VAL2,OPSIZE>	; UNKNOWN VALUE
    150	001054					    END;IF
    151	001054					    IFB OPSIZE EQ #8. ANDB VAL1 EQ #M.IMM THEN ; QUAD IMMEDIATE
    152	001074						OUT #I.STIL,<VAL3,VAL4>
    153	001114					    END;IF
    154	001114					END;IF
    155	001114					LET RDXPTR	:= #DNUMBER		; RESET RADIX
    156	001122					CALL MOPEXI				; RE-INIT FOR NEXT OPERAND
    157	001126					RETURN					;
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 35
ASSIGNMENT STATEMENTS

    159					.SBTTL	ASSIGNMENT STATEMENTS
    160					;
    161					; ASSIGNMENT STATEMENTS ASSIGN A COMPILE-TIME EXPRESSION TO A
    162					; VARIABLE.  BECAUSE THE ASSEMBLER MUST KNOW WHAT THE VALUE
    163					; OF THE EXPRESSION IS ON THE FIRST PASS, FORWARD REFERENCES
    164					; ARE NOT ALLOWED.
    165					;
    166					;
    167
    168	001130				ASSHD3::			; ASSIGN_HEAD = DPC
    169	001130					LET R0	:= #-1				; MARK AS PC AUGMENTATION
    170	001134					GOTO ASSHD
    171
    172	001136				ASSHD2::			; ASSIGN_HEAD = ID DEQ DEQ
    173	001136					LET R0		:= V1STACK-4(R4)	; POINT TO ID
    174	001142					LET SYMFLAG(R0) := SYMFLAG(R0) SET.BY #S.GLOBL
    175	001150					GOTO ASSHD				; MARK AS GLOBAL
    176
    177	001152				ASSHD1::			; ASSIGN_HEAD = ID DEQ
    178	001152					LET R0		:= V1STACK-2(R4)	; POINT TO ID
    179	001156				ASSHD:	LET ASNPTR	:= R0			; SAVE PTR TO ID
    180	001162					LET PRMSEG	:= 0			; ALLOW ANY PSECT FOR RESULT
    181	001166					LET EVALEXPR	:= FALSE		; DON'T OUTPUT EXPRESSION
    182	001172					LET COMPEXPR	:= TRUE			; ASSUME COMPILE-TIME EXPR
    183	001200					LET OPRND	:= TRUE			; IN OPERAND FIELD
    184	001206					LET ABSEXPR	:= 0			; ASSUME ABSOLUTE EXPR
    185	001212					LET FLTWDC	:= #1			; SINGLE PRECISION
    186	001220					LET OPSIZE	:= #4			; MAXIMUM LENGTH IS 4 BYTES
    187	001226					RETURN
    188
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 36
ASSIGNMENT STATEMENTS

    190	001230				ASSGN1::			; ASSIGNMENT = ASSIGN_HEAD EXPR DEOL
    191	001230					LET R1		:= ASNPTR		; POINT TO ID
    192	001234					IF COMPEXPR IS FALSE THEN		; COMPILE TIME EXPR?
    193	001242					    CALL ERORPT,#ILASEX			; COMPLEX EXPRESSION NOT ALLOWED
    194	001252					END;IF
    195	001252					IF R1 EQ #-1 THEN			; ASSIGNMENT INVOLVES 'PC'
    196	001260					    CALL	SETPC			; RECORD HIGH WATER MARK
    197	001264					    LET VAL2	:= V2STACK-2(R4)	; EXPR MSB
    198	001272					    LET VAL1	:= V1STACK-2(R4) - PC1	; SUBTRACT PSEUDO-PC
    199	001306	005667 	000000G			    SBC	VAL2
    200	001312					    LET VAL2	:= VAL2 - PC2		; COMPLETE THE SUBTRACTION
    201	001320					    OUT	#I.AUGPC,<VAL1,VAL2>		; AUGMENT PC
    202	001340					    LET PC1	:= V1STACK-2(R4)	; SET NEW PC
    203	001346					    LET PC2	:= V2STACK-2(R4)	;
    204	001354					    CALL	SETPC			; CHECK PC
    205	001360					ELSE
    206	001362					    IF #S.EXTN SET.IN SYMFLAG(R1) THEN	; SYMBOL DECLARED EXTERNAL?
    207	001372						CALL ERORPT,#SYMEXT		;
    208	001402					    END;IF
    209	001402					    IF #S.DF SET.IN SYMFLAG(R1) AND #S.ASN OFF.IN SYMFLAG(R1) THEN
    210	001422						CALL ERORPT,#MULTDF		; MULTIPLE DEFINITION
    211	001432					    END;IF
    212	001432					    LET SYMSEG(R1)	:B= PRMSEG	; DEFINE IN EXPR PSECT
    213	001440					    LET SYMFLAG(R1)	:= SYMFLAG(R1) OFF.BY #S.ABS ; CLEAR ABSOLUTE FLAG
    214	001446					    IF ABSEXPR IS EQ THEN		; ABSOLUTE EXPR?
    215	001454						LET SYMFLAG(R1) := SYMFLAG(R1) SET.BY #S.ABS ; YES, MARK AS ABSOLUTE
    216	001462						LET SYMSEG(R1)	:B= 0		; ABSOLUTE PSECT
    217	001466					    END
    218	001466					    IF EN.DBG+SYMVL2 IS NE AND #S.LOCL OFF.IN SYMFLAG(R1) THEN
    219	001504						LET SYMFLAG(R1) := SYMFLAG(R1) SET.BY #S.DBG ; DEBUGGER SHOULD KNOW ABOUT SYMBOL
    220	001512					    END
    221	001512					    LET SYMVL1(R1)	:= V1STACK-2(R4) ; SET THE NEW VALUE
    222	001520					    LET SYMVL2(R1)	:= V2STACK-2(R4)
    223	001526					    LET SYMFLAG(R1) := SYMFLAG(R1) SET.BY #S.DF+S.ASN ; DEFINE SYMBOL
    224	001534					    LET R0	:= 0			; ASSUME RELOCATABLE
    225	001536					    IF #S.ABS SET.IN SYMFLAG(R1) THEN	; SCALAR VALUE?
    226	001546						LET R0	:= R0 +1		; MAKE FLAG NON-ZERO
    227	001550					    END;IF
    228	001550					    OUT #I.ASN,<R1,SYMSEG(R1),SYMVL1(R1),SYMVL2(R1),R0>
    229	001600					END
    230	001600					LET EVALEXPR	:= TRUE			; OUTPUT EXPRESSION EVALUATIONS
    231	001606					OUT	#I.PRIL,<V1STACK-2(R4),V2STACK-2(R4)> ; PRINT EXPRESSION
    232	001626					RETURN
    233
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 37
DATA GENERATION DIRECTIVES

    235					.SBTTL	DATA GENERATION DIRECTIVES
    236					;
    237					; THESE ROUTINES HANDLE THE SEMANTICS FOR DATA GENERATION
    238					;
    239	001630				BYTE::				; DATA_TYPE = KBYTE
    240	001630					LET DATPTR	:= #0			; INDEX FOR DATA COMMAND
    241	001634					LET OPSIZE	:= #1			; ONE BYTE MAXIMUM
    242	001642					GOTO		DATEXI
    243
    244	001644				WORD::				; DATA_TYPE = KWORD
    245	001644					LET DATPTR	:= #1			; INDEX FOR DATA COMMAND
    246	001652					LET OPSIZE	:= #2			; TWO BYTES MAXIMUM
    247	001660					GOTO		DATEXI
    248
    249	001662				LONG::				; DATA_TYPE = KLONG
    250	001662					LET DATPTR	:= #2			; INDEX FOR DATA COMMAND
    251	001670					LET OPSIZE	:= #4			; FOUR BYTES MAXIMUM
    252	001676					GOTO		DATEXI
    253
    254	001700				QUAD::				; QUAD_HEAD = KQUAD
    255	001700					LET DATPTR	:= #3			; INDEX FOR DATA COMMAND
    256	001706					LET OPSIZE	:= #8.			; EIGHT BYTES MAXIMUM
    257
    258
    259	001714				DATEXI:	LET EVALEXPR	:= TRUE			; EVALUATE EXPRESSIONS
    260	001722					LET FLTWDC	:= #1			; SINGLE PRECISION
    261
    262	001730				DATEND:	IF FRMPTR HI #FRMWRN THEN CALL WRTFRM	; FLUSH BUFFER IF NEAR END
    263	001744					LET DATRPT	:= FALSE		; NOT A REPEAT YET
    264	001750					LET ABSEXPR	:= 0			; ASSUME ABSOLUTE EXPR
    265	001754					LET PRMSEG	:= 0			; ABSOLUTE SEG
    266	001760					LET EXPOPT	:= TRUE			; ASSUME OPTIMIZABLE
    267	001766					LET EXPPTR	:= FRMPTR		; POINT TO EXPR START
    268	001774					LET EXPEND	:= FRMPTR		; ASSUME NO EXPR
    269	002002					RETURN					; RETURN TO CALLER
    270
    271	002004				DATARG::			; DATA_LIST = EXPR
    272									; DATA_LIST = DATA_LIST DCOMMA EXPR
    273	002004					IF ABSEXPR IS NE THEN LET EXPOPT := FALSE ; CAN'T OPTIMIZE
    274
    275					; THIS ALLOWS EVALUATION OF "REPEAT COUNT"
    276	002016					LET ABSEXPR	:= 0			; ASSUME ABSOLUTE EXPR
    277	002022					LET PRMSEG	:= 0			; ABSOLUTE PSECT
    278	002026					LET DATRPT	:= FALSE		; NO REPEAT COUNT YET
    279	002032					RETURN
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 38
DATA ARGUMENT STORAGE ROUTINES

    281					.SBTTL	DATA ARGUMENT STORAGE ROUTINES
    282
    283	002034				DALST2::			; DATA_ARGS = DATA_LIST DSQOPN EXPR DSQCLS
    284	002034					LET DATRPT	:= TRUE			; THIS IS A REPEATED DATA GENERATION
    285	002042				DALST1::			; DATA_ARGS = DATA_LIST
    286	002042					CASE DATPTR				; CALL ONE OF THREE ROUTINES
    287	002054	002072'				    .WORD DT.BYT			; STORE BYTE
    288	002056	002104'				    .WORD DT.WRD			; STORE WORD
    289	002060	002116'				    .WORD DT.LNG			; STORE LONGWORD
    290	002062					END;C
    291	002070					RETURN					;
    292
    293
    294	002072				DT.BYT:						; BYTE
    295	002072					CALL	DATGEN,<#I.STSB>
    296	002102					RETURN
    297
    298	002104				DT.WRD:						; WORD
    299	002104					CALL	DATGEN,<#I.STSW>
    300	002114					RETURN
    301
    302	002116				DT.LNG:						; LONG WORD
    303	002116					CALL	DATGEN,<#I.STOL>
    304	002126					RETURN
    305
    306	002130				QUDSTR::			; DATA_STAT = QUAD_HEAD PRIMITIVE
    307	002130					IF ABSEXPR IS NE THEN LET EXPOPT := FALSE ; CAN'T OPTIMIZE REL. SYMBOLS
    308	002142					CALL	DATGEN,<#I.STOL>		; OUTPUT LOWER 32 BITS
    309	002152					OUT	#I.STIL,<VAL3,VAL4>		; OUTPUT UPPER 32 BITS
    310	002172					RETURN
    311
    312
    313	002174				DATNUL::			; DATA_STAT = DATA_TYPE <NULL>
    314
    315	002174					IF DATPTR IS EQ THEN			; ".BYTE" DIRECTIVE ?
    316	002202					    LET R0	:= #I.STIB*256.+6	; CMD IS: STORE IMMEDIATE BYTE
    317	002206					ELSE
    318	002210					    IF DATPTR EQ #1 THEN		; ".WORD" DIRECTIVE ?
    319	002220						LET R0	:= #I.STIW*256.+6	; CMD IS: STORE IMMEDIATE WORD
    320	002224					    ELSE				; ".LONG" DIRECTIVE ASSUMED
    321	002226						LET R0	:= #I.STIL*256.+6	; CMD IS: STORE IMMEDIATE LONG
    322	002232					    END
    323	002232					END;IF
    324	002232	005046 				CLR	-(SP)				; OUTPUT 2 ZERO WORDS
    325	002234	005046 				CLR	-(SP)				;
    326	002236	010046 				MOV	R0,-(SP)			; PUSH COMMAND ONTO STACK
    327	002240					CALL	OUTFRAME			; OUTPUT COMMAND TO INTERMEDIATE BUFFER
    328	002244					IF DATPTR EQ #3 THEN			; ".QUAD" DIRECTIVE ?
    329	002254					    OUT #I.STIL,<#0,#0>			; STORE UPPER 32 BITS
    330	002274					END;IF
    331	002274					INCRPC OPSIZE				; UPDATE LOCATION COUNTER
    332	002306					CALL DATEND				; CLEAN UP EOL FUNCTIONS
    333	002312					RETURN					;
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 39
REPEATED AND SINGLE DATA GENERATION ROUTINE

    335					.SBTTL	REPEATED AND SINGLE DATA GENERATION ROUTINE
    336					;
    337					; PROCEDURE TO OUTPUT DATA (REPEATED OR NOT)
    338					;
    339
    340	002314				DATGEN:					; GENERATE DATA
    341
    342	002314					IF DATRPT IS TRUE THEN			; THIS IS A REPEAT TYPE!
    343	002322					    IF ABSEXPR IS NE OR V2STACK-2(R4) IS NE THEN
    344	002336						CALL ERORPT,#ILRPCT		; ILLEGAL REPEAT COUNT
    345	002346						LET R2		:= 0		; NO REPEATING
    346	002350						LET V1STACK-2(R4) := 0
    347	002354						LET V2STACK-2(R4) := 0
    348	002360					    ELSE
    349	002362						LET R2		:= V1STACK-2(R4) ; GET REPEAT COUNT
    350	002366					    END
    351	002366					    CASE DATPTR				; GENERATE CORRECT REPEAT
    352	002400	002444'					DTA.BYT				; BYTE
    353	002402	002456'					DTA.WRD				; WORD
    354	002404	002470'					DTA.LNG				; LONG
    355	002406					    END
    356	002414					ELSE
    357	002416					    CALL DTGEN1
    358	002422					END
    359	002422					LET R2		:= R2 SHIFT DATPTR	; GET TOTAL DATA SIZE
    360	002426					INCRPC		R2			; INCREMENT PC
    361	002436					CALL	DATEND				; CLEAN UP EOL FLAGS
    362	002442					RETURN					;
    363
    364
    365	002444				DTA.BYT:					; REPEATED BYTE
    366	002444					OUT	#I.STRB
    367	002454					RETURN
    368
    369	002456				DTA.WRD:					; REPEATED WORD
    370	002456					OUT	#I.STRW
    371	002466					RETURN
    372
    373	002470				DTA.LNG:					; REPEATED LONG
    374	002470					OUT	#I.STRL
    375	002500					RETURN
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 40
REPEATED AND SINGLE DATA GENERATION ROUTINE

    377	002502				DTGEN1:					; OUTPUT SINGLE ELEMENT
    378
    379	002502					IF EXPOPT IS TRUE THEN			; OPTIMIZE EXPR?
    380	002510					    CALL OPTEXP				; RESET POINTER
    381	002514					    IF DATPTR IS EQ THEN		; BYTE?
    382	002522						OUT #I.STIB,<V1STACK(R4),V2STACK(R4)> ; STORE IMM. BYTE
    383	002542					    ELSE
    384	002544						IF DATPTR EQ #1 THEN		; WORD?
    385	002554						    OUT #I.STIW,<V1STACK(R4),V2STACK(R4)> ; STORE IMM. WORD
    386	002574						ELSE
    387	002576						    OUT #I.STIL,<V1STACK(R4),V2STACK(R4)> ; STORE IMM. LONG
    388	002616						END;IF
    389	002616					    END;IF
    390	002616					ELSE
    391	002620	000300 				    SWAB R0				; MOVE COMMAND TO UPPER BYTE
    392	002622					    LET R0	:= R0 SET.BY #2		; STORE LENGTH OF COMMAND
    393	002626					    PUSH R0				; STACK COMMAND
    394	002630					    CALL OUTFRAME			; OUTPUT COMMAND TO INTERMEDIATE BUFFER
    395	002634					END;IF
    396	002634					    LET R2	:= #1			; ONE DATA ELEMENT
    397	002640					RETURN					;
    398
    399
    400
    401	002642				ADDRES::			; ADDR_TYPE = KADDRESS
    402	002642					CALL	DATEND				; INITIALIZE DATA FLAGS
    403	002646					RETURN					;
    404
    405
    406	002650				STOADR::			; ADDR_LIST = EXPR ! ADDR_LIST DCOMMA EXPR
    407	002650					IF ABSEXPR IS EQ THEN			; CAN EXPRESSION BE OPTIMIZED?
    408	002656					    CALL OPTEXP				; ERASE EXPRESSION
    409	002662					    OUT	#I.STKL,<V1STACK(R4),V2STACK(R4)> ; STACK VALUE
    410	002702					END;IF
    411	002702					OUT #I.SPID				; STORE POS. IND. DATA REF.
    412	002712					INCRPC	#4				; COUNT SIZE OF ADDRESS
    413	002724					CALL	DATEND				; SET FLAGS FOR NEXT ADDR.
    414	002730					RETURN					;
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 41
BLOCK ALLOCATION DIRECTIVES

    416					.SBTTL	BLOCK ALLOCATION DIRECTIVES
    417					;
    418					; BLOCK DIRECTIVES
    419					;
    420
    421	002732				BLKBYT::			; BLOCK_TYPE = KBLKB
    422	002732					LET VAL1	:= #0			; ONE BYTE PER BLOCK
    423	002736					GOTO	BEXI				; TAKE COMMON EXIT
    424
    425	002740				BLKWRD::			; BLOCK_TYPE = KBLKW
    426	002740					LET VAL1	:= #1			; TWO BYTES PER BLOCK
    427	002746					GOTO	BEXI				; TAKE COMMON EXIT
    428
    429	002750				BLKLNG::			; BLOCK_TYPE = KBLKL
    430									; BLOCK_TYPE = KBLKA
    431									; BLOCK_TYPE = KBLKF
    432	002750					LET VAL1	:= #2			; FOUR BYTE PER BLOCK
    433	002756					GOTO	BEXI				; TAKE COMMON EXIT
    434
    435	002760				BLKQUD::			; BLOCK_TYPE = KBLKQ
    436									; BLOCK_TYPE = KBLKD
    437	002760					LET VAL1	:= #3			; 8 BYTES PER BLOCK
    438
    439	002766				BEXI:						; COMMON EXIT
    440	002766					LET COMPEXPT	:= TRUE			; ASSUME NICE EXPR
    441	002774					LET EVALEXPR	:= FALSE		; DON'T OUTPUT EXPR
    442	003000					LET ABSEXPR	:= 0			; LOOK FOR ABS EXPR
    443	003004					RETURN					; AND CONTINUE PARSE
    444
    445
    446	003006				BSTAT1::			; BLOCK_STAT = BLOCK_TYPE
    447	003006					LET R1		:= #1			; DEFAULT IS 1 (LSB)
    448	003012					LET R0		:= 0			; (MSB)
    449	003014					LET R2		:= V1STACK(R4)		; SHIFT COUNT
    450	003020					GOTO BLOCK
    451
    452	003022				BSTAT2::			; BLOCK_STAT = BLOCK_TYPE EXPR
    453	003022					CALL		SETPC			; RECORD HIGH WATER MARK
    454	003026					LET R1		:= V1STACK(R4)		; GET EXPR (LSB)
    455	003032					LET R0		:= V2STACK(R4)		; (MSB)
    456	003036					LET R2		:= V1STACK-2(R4)	; SHIFT COUNT
    457	003042				BLOCK:	IF ABSEXPR IS NE THEN
    458	003050					    CALL ERORPT,#ILASEX			; COMPLEX EXPRESSION NOT ALLOWED
    459	003060					    LET R0	:= 0
    460	003062					    LET R1	:= 0			; RETURN RESULT OF ZERO
    461	003064					    LET R2	:= 0
    462	003066					END
    463	003066	073002 				ASHC		R2,R0			; <R0><R1> HAS PC OFFSET
    464	003070					OUT		#I.AUGPC,<R1,R0>	; AUGMENT PC
    465	003104					LET PC1		:= PC1 + R1		; UPDATE PC (LSB)
    466	003110	005567 	000000G			ADC		PC2			; WITH CARRY
    467	003114					LET PC2		:= PC2 + R0		; (MSB)
    468	003120					OUT #I.PRIL,<PC1,PC2>			; PRINT PC IN LISTING
    469	003140					LET EVALEXPR	:= TRUE			; EVALUATE EXPRESSIONS
    470	003146					RETURN
    471
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 42
LABEL DEFINITION ROUTINE

    473					.SBTTL	LABEL DEFINITION ROUTINE
    474					;++
    475					;
    476					; THESE ROUTINES DEFINE SYMBOLS AS LABELS.
    477					;
    478					;--
    479	003150				LBL1::				; LABEL = ID DCOLON
    480	003150					LET R2		:= V1STACK-2(R4)	; POINT TO SYMBOL BLOCK
    481	003154				LBLX:
    482	003154					IF #S.LOCL OFF.IN SYMFLAG(R2) AND EN.LSB+SYMVL2 IS EQ THEN ; LOCAL SYMBOL?
    483	003172					    LET LSB	:= LSB + #1		; IF NOT, THIS IS NEW LSB
    484	003176					END;IF
    485	003176					IF EN.DBG+SYMVL2 IS NE AND #S.LOCL OFF.IN SYMFLAG(R2) THEN
    486	003214					    LET SYMFLAG(R2) := SYMFLAG(R2) SET.BY #S.DBG ; TELL DEBUGGER
    487	003222					END;IF
    488	003222					IF #S.DF SET.IN SYMFLAG(R2) THEN
    489	003232					    CALL ERORPT,#MULTDF			; MULTIPLE DEFINITION OF LABEL
    490	003242					END;IF
    491	003242					IF #S.EXTN SET.IN SYMFLAG(R2) THEN	; IS LABEL DECLARED AS EXTERNAL?
    492	003252					    CALL ERORPT,#SYMEXT			;
    493	003262					END;IF
    494	003262					LET SYMVL1(R2)	:= PC1			; FILL IN VALUE
    495	003270					LET SYMVL2(R2)	:= PC2			;
    496	003276					LET SYMSEG(R2)	:B= PSTNUM		; SET PSECT NUMBER
    497	003304					LET SYMFLAG(R2) := SYMFLAG(R2) SET.BY #S.DF ; MARK AS HAVING VALUE
    498	003312					LET R1		:= PSECTP		; POINT TO PSECT
    499	003316					IF #FP.REL OFF.IN PSECOP(R1) THEN	; ABSOLUTE PSECT?
    500	003326					    LET SYMFLAG(R2) := SYMFLAG(R2) SET.BY #S.ABS ; MAKE ABSOLUTE
    501	003334					END;IF
    502	003334					LET SYMFLAG(R1)	:= SYMFLAG(R1) SET.BY #S.REF ; PSECT HAS BEEN REFERENCED
    503	003342					OUT #I.LGLAB,R2				; OUTPUT COMMAND TO PASS-2
    504	003354					RETURN
    505
    506
    507	003356				LBL2::				; LABEL = ID DCOLON DCOLON
    508	003356					LET R2		:= V1STACK-4(R4)	; POINT TO SYMBOL BLOCK
    509	003362					LET SYMFLAG(R2) := SYMFLAG(R2) SET.BY #S.GLOBL
    510	003370					GOTO LBLX				; MARK AS GLOBAL SYMBOL
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 43
ENTRY POINT DEFINITION ROUTINES

    512					.SBTTL	ENTRY POINT DEFINITION ROUTINES
    513					;
    514	003372				ENTRY1::			; DIRECTIVE = KENTRY ID DCOMMA EXPR
    515	003372					LET R2		:= V1STACK-4(R4)	; POINT TO SYMBOL BLOCK
    516	003376					GOTO	ENTRY				; AND PROCESS LABEL
    517
    518	003400				ENTRY2::			; DIRECTIVE = KENTRY ID EXPR
    519	003400					LET R2		:= V1STACK-2(R4)	; POINT TO SYMBOL BLOCK
    520	003404				ENTRY:
    521	003404					LET SYMFLAG(R2) := SYMFLAG(R2) SET.BY #S.EPT+S.GLOBL
    522											; MARK AS GLOBAL ENTRY POINT
    523	003412					CALL LBLX				; DEFINE LABEL
    524	003416					OUT #I.EPT,<R2,V1STACK(R4),V2STACK(R4)>	; PROCESS EPT ON PASS 2
    525
    526	003440				EPTVTR:					; ENTRY/VECTOR COMMON EXIT
    527	003440					IF ABSEXP IS EQ AND #30003 SET.IN V1STACK(R4) THEN
    528											; BITS 13, 12, 1, 0 ARE ILLEGAL
    529	003456					    CALL ERORLN,#RESMSK			; ILLEGAL ENTRY POINT MASK
    530	003466					END
    531	003466				VTREX:	OUT #I.STSW				; STORE WORD OF EXPRESSION
    532	003476					INCRPC	#2				; WORD WRITTEN TO IMAGE
    533	003510					RETURN					; AND EXIT
    534
    535
    536					.SBTTL	.VECTOR/.MASK DIRECTIVE ROUTINES
    537
    538	003512				VECTR0::			; DIRECTIVE = KVECTOR ID
    539	003512					OUT	#I.STKEPT,V1STACK(R4)		; STACK ENTRY POINT MASK
    540	003526					GOTO	VTREX				; EXIT
    541
    542	003530				VECTR2::			; DIRECTIVE = KVECTOR ID EXPR
    543
    544	003530					LET R1	:= V1STACK-2(R4)		; POINT TO SYMBOL
    545	003534					GOTO	VECTOR				; COMMON POINT
    546
    547	003536				VECTR1::			; DIRECTIVE = KVECTOR ID DCOMMA EXPR
    548
    549	003536					LET R1	:= V1STACK-4(R4)		; POINT TO SYMBOL
    550
    551	003542				VECTOR:	OUT	#I.STKEPT,R1			; STACK ENTRY POINT
    552	003554					OUT	#I.OR				; OR WITH EXPR ON STACK
    553	003564					GOTO	EPTVTR				; COMMON EXIT POINT
    554
    555					.SBTTL	.TRANSFER DIRECTIVE
    556
    557	003566				XFER::					;DIRECTIVE = KXFER ID
    558	003566					OUT	#I.RDEF,V1STACK(R4)		; EMIT REDEF INFORMATION
    559	003602					RETURN
    560
    561		000001 			.END
ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 43-1
SYMBOL TABLE

ABSEXP= ****** GX	EXPPTR= ****** GX	L13     000516R     002	L75     003262R     002	SYMVL1= 000004
ADDRES  002642RG    002	FF    = 000014   	L14     000764R     002	L76     003334R     002	SYMVL2= 000006
ASNPTR= ****** GX	FLTWDC= ****** GX	L15     000536R     002	L77     003466R     002	S.ABS = 004000
ASSGN1  001230RG    002	FP.REL= 000010   	L16     000560R     002	MINST1  000020RG    002	S.ASN = 000200
ASSHD   001156R     002	FRMPTR= ****** GX	L17     000762R     002	MODE  = ****** GX	S.DBG = 002000
ASSHD1  001152RG    002	FRMWRN= ****** GX	L2      000174R     002	MODTAB= ****** GX	S.DF  = 100000
ASSHD2  001136RG    002	IIII  = 177777   	L20     000604R     002	MOPEXI  000126R     002	S.EPT = 000100
ASSHD3  001130RG    002	ILASEX= ****** GX	L21     000642R     002	MOPNUM= ****** GX	S.EXTN= 010000
BB    = ****** GX	ILLBRN= ****** GX	L22     000630R     002	MOPPTR= ****** GX	S.GLOB= 020000
BEXI    002766R     002	ILLMOD= ****** GX	L23     000642R     002	MULTDF= ****** GX	S.LOCL= 001000
BLKBYT  002732RG    002	ILRPCT= ****** GX	L24     000736R     002	M.ARGC= 000014   	S.ODBG= 000040
BLKLNG  002750RG    002	IMODE = ****** GX	L25     000736R     002	M.ARGS= 000016   	S.REF = 000400
BLKQUD  002760RG    002	IREG  = ****** GX	L26     000736R     002	M.D16 = ****** GX	S.TKMS= 000377
BLKWRD  002740RG    002	I.ASN = ****** GX	L27     001114R     002	M.D8  = ****** GX	S.WEAK= 040000
BLNK  = 000040   	I.AUGP= ****** GX	L3      000202R     002	M.END = 000012   	TAB   = 000011
BLOCK   003042R     002	I.BDST= ****** GX	L30     001030R     002	M.GETL= 000004   	TMNYRF= ****** GX
BSTAT1  003006RG    002	I.EPT = ****** GX	L31     001054R     002	M.IFLV= 000006   	TYPS0 = 000000
BSTAT2  003022RG    002	I.LGLA= ****** GX	L32     001114R     002	M.IFVL= 000010   	TYPS1 = 000000
BW    = ****** GX	I.OP  = ****** GX	L33     001252R     002	M.IMM = ****** GX	TYPS2 = 000000
BYTE    001630RG    002	I.OR  = ****** GX	L34     001362R     002	M.LINK= 000000   	TYPS3 = 000000
CNT   = 000004   	I.PRIL= ****** GX	L35     001600R     002	M.NXTL= 000002   	TYPS4 = 000000
COMMA = 000054   	I.RDEF= ****** GX	L36     001402R     002	NTENFO= ****** GX	VAL1  = ****** GX
COMPEX= ****** GX	I.REF = ****** GX	L37     001432R     002	OPRAND  000306RG    002	VAL2  = ****** GX
CR    = 000015   	I.SPID= ****** GX	L4      000216R     002	OPRND = ****** GX	VAL3  = ****** GX
DALST1  002042RG    002	I.STIB= ****** GX	L40     001466R     002	OPSIZE= ****** GX	VAL4  = ****** GX
DALST2  002034RG    002	I.STIL= ****** GX	L41     001512R     002	OPTEXP= ****** GX	VECTOR  003542R     002
DATARG  002004RG    002	I.STIW= ****** GX	L42     001550R     002	OUTFRA= ****** GX	VECTR0  003512RG    002
DATEND  001730R     002	I.STKE= ****** GX	L43     001744R     002	PC1   = ****** GX	VECTR1  003536RG    002
DATEXI  001714R     002	I.STKL= ****** GX	L44     002016R     002	PC2   = ****** GX	VECTR2  003530RG    002
DATGEN  002314R     002	I.STKS= ****** GX	L45     002062R     002	PRMSEG= ****** GX	VTREX   003466R     002
DATNUL  002174RG    002	I.STOL= ****** GX	L46     002142R     002	PSECCH= 000020   	V1STAC= ****** GX
DATPTR= ****** GX	I.STRB= ****** GX	L47     002210R     002	PSECOP= 000016   	V2STAC= ****** GX
DATRPT= ****** GX	I.STRL= ****** GX	L5      000344R     002	PSECTP= ****** GX	WORD    001644RG    002
DNUMBE= ****** GX	I.STRW= ****** GX	L50     002232R     002	PSECV1= 000012   	WRTFRM= ****** GX
DTA.BY  002444R     002	I.STSB= ****** GX	L51     002226R     002	PSECV2= 000014   	XFER    003566RG    002
DTA.LN  002470R     002	I.STSW= ****** GX	L52     002232R     002	PSTNUM= ****** GX	XPC1  = ****** GX
DTA.WR  002456R     002	LBLS0 = 000077   	L53     002274R     002	QUAD    001700RG    002	XPC2  = ****** GX
DTGEN1  002502R     002	LBLS1 = 000064   	L54     002416R     002	QUDSTR  002130RG    002	$DIDDO= 000000
DT.BYT  002072R     002	LBLS2 = 000066   	L55     002336R     002	RDXPTR= ****** GX	$E$   = 000001
DT.LNG  002116R     002	LBLS3 = 000025   	L56     002362R     002	RESMSK= ****** GX	$F$   = 000000
DT.WRD  002104R     002	LBLS4 = 000026   	L57     002366R     002	RGTANG= 000076   	$I$   = 000001
ENTRY   003404R     002	LBLX    003154R     002	L6      000414R     002	RTNVAL=%000000   	$L    = 000000
ENTRY1  003372RG    002	LBL1    003150RG    002	L60     002406R     002	R6    =%000006   	$LL   = 000000
ENTRY2  003400RG    002	LBL2    003356RG    002	L61     002422R     002	R7    =%000007   	$L$   = 000000
EN.DBG= ****** GX	LF    = 000012   	L62     002620R     002	SEMI  = 000073   	$O$   = 000000
EN.LSB= ****** GX	LFTANG= 000074   	L63     002544R     002	SETPC = ****** GX	$R    = 177777
EPTVTR  003440R     002	LINEBF= ****** GX	L64     002616R     002	SPACE = 000040   	$SV$  = 000000
ERORLN= ****** GX	LONG    001662RG    002	L65     002576R     002	STAT1   000000RG    002	$T    = 000100
ERORPT= ****** GX	LOWCAS= 000140   	L66     002616R     002	STOADR  002650RG    002	$T1   = 000000
ERORPX= ****** GX	LPTLEN= 000074   	L67     002634R     002	SYMCHR= 000012   	$T2   = 000077
ERRPTX= ****** GX	LSB   = ****** GX	L7      000420R     002	SYMEXT= ****** GX	$Y$   = 000000
EVALEX= ****** GX	L0      000016R     002	L70     002702R     002	SYMFLA= 000002   	$Z$   = 000000
EXPEND= ****** GX	L1      000074R     002	L71     003066R     002	SYMLEN= 000011   	$$S   = 000000
EXPOPT= ****** GX	L10     000450R     002	L72     003176R     002	SYMLIN= 000000   	$$T   = 000055
EXPOP1= ****** GX	L11     000462R     002	L73     003222R     002	SYMMAX= 000017   	$$TT  = 000056
EXPOP2= ****** GX	L12     000502R     002	L74     003242R     002	SYMSEG= 000010   	.$T   = 000001

ACTSTA	MACRO M1110  21-AUG-78 22:31  PAGE 43-2
SYMBOL TABLE

. ABS.	000000	   000
      	000000	   001
ACTSTA	003604	   002
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  12619 WORDS  ( 50 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:05:58
OBJ$:ACTSTA,LIS$:ACTSTA/-SP=SRC$:MD,COMMON,ACTSTA
