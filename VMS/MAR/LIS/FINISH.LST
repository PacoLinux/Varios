FINISH	MACRO M1110  21-AUG-78 22:55
TABLE OF CONTENTS

    32-    3	ALPHAB	ALPHABETIZE SYMBOL TABLE
    33-  122	FINISH	OUTPUT TRACEBACK, DEBUGGER INFO. AND PRINT SYMBOL TABLE
    33-  142	.	OUTPUT MODULE HEADER AND ROUTINE NAMES AS TRACEBACK RECORD
    34-  183	.	OUTPUT LABELS AND REFERENCED SYMBOLS (DEBUG RECORD)
    34-  223	.	OUTPUT PSECT NAMES AND END OF MODULE (TRACEBACK RECORD)
    35-  237	.	PRINT SYMBOL TABLE IN ALPHABETICAL ORDER
    36-  290	.	PRINT PSECT SYNOPSIS
    37-  319	.	PRINT ERROR SUMMARY
    38-  395	.	PRINT MEMORY STATISTICS AND COMMAND LINE
    39-  435	DBGNAM	OUTPUT DEBUG NAME TO OBJECT FILE
    39-  455	DBGSYM	OUTPUT SYMBOL VALUE IN DEBUG RECORD
    39-  468	DBGPSCT	OUTPUT PSECT RECORDS TO DEBUG RECORD
    40-  488	SYMPRT	PRINT SYMBOL INFORMATION
    41-  542	PSCPRT	PRINT PSECT OPTIONS AND ALIGNMENT
    42-  592	PMATCH	MATCHES BIT VALUE WITH NAME
    43-  625	LINIT	INITIALIZE LISTING LINE TO BLANKS
    43-  641	MSG	COPY MESSAGE TO LISTING BUFFER
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 32


      1						.TITLE	FINISH
      2	000000					.PSECT	FINISH
      3						.SBTTL	ALPHAB	ALPHABETIZE SYMBOL TABLE
      4					;
      5					; THIS FILE CONTAINS THE ROUTINES CALLED AT THE END OF A MARS ASSEMBLY
      6					; WHICH PRINT THE SYMBOL TABLE, ERRORS, PSECT SYNOPSIS, ETC.
      7					;
      8					; THE PROCEDURE BELOW ALPHABETIZES THE SYMBOLS IN A SYMBOL TABLE.  ON
      9					; ENTRY, R4 CONTAINS THE HASH TABLE SIZE, AND R5 POINTS TO THE START OF
     10					; THE HASH TABLE.  ON EXIT, "FRST" POINTS TO THE LINKED LIST OF SYMBOLS.
     11					;
     12
     13	000000				ALPHAB::				;ALPHABETIZE TABLE
     14
     15					;
     16					; THE FIRST STEP IS TO REMOVE ALL EMPTY SUBLIST LISTHEADS FROM THE TABLE
     17					;
     18
     19	000000	010503 				MOV	R5,R3			;COPY ADDRESS OF TABLE
     20	000002	010302 				MOV	R3,R2			;
     21	000004	005722 			10$:	TST	(R2)+			;SUBLIST EMPTY?
     22	000006	001402 				BEQ	20$			;IF EQ YES
     23	000010	016223 	177776 			MOV	-2(R2),(R3)+		;MOVE LISTHEAD ENTRY
     24	000014	077405 			20$:	SOB	R4,10$			;ANY MORE LISTHEADS TO SCAN?
     25	000016	005067 	000000G			CLR	FRST			;ASSUME NO ENTRIES
     26	000022	160503 				SUB	R5,R3			;CALCULATE SIZE OF TABLE IN BYTES
     27	000024	001466 				BEQ	EXIT			;IF EQ EXIT
     28
     29					;
     30					; THE SECOND STEP IS TO SORT THE SUBLISTS SUCH THAT THE FIRST SYMBOL IN EACH SUBLIST
     31					; IS LESS THAN THE FIRST SYMBOL OF THE SUCCEEDING SUBLIST
     32					;
     33
     34	000026				SORT:					;
     35	000026	060503 				ADD	R5,R3			;CALCULATE ENDING ADDRESS OF TABLE
     36	000030	010346 				MOV	R3,-(SP)		;SAVE ENDING ADDRESS OF TABLE
     37	000032	010546 				MOV	R5,-(SP)		;SAVE ADDRESS OF LISTHEAD TABLE
     38	000034	012504 			10$:	MOV	(R5)+,R4		;GET ADDRESS OF NEXT SYMBOL
     39	000036	020566 	000002 			CMP	R5,2(SP)		;ANY MORE LISTHEADS IN TABLE?
     40	000042	001412 				BEQ	MERGE			;IF EQ NO
     41	000044	011503 				MOV	(R5),R3			;GET ADDRESS OF NEXT SYMBOL
     42	000046					CALL	CMPSYM			;COMPARE SYMBOLS
     43	000052	101770 				BLOS	10$			;IF LOS SYMBOLS IN CORRECT ORDER
     44	000054	010415 				MOV	R4,(R5)			;INVERT LISTHEAD  ENTRIES
     45	000056	010345 				MOV	R3,-(R5)		;
     46	000060	020516 				CMP	R5,(SP)			;AT FRONT OF LISTHEAD TABLE?
     47	000062	001764 				BEQ	10$			;IF EQ YES
     48	000064	005745 				TST	-(R5)			;BACKUP ONE TABLE ENTRY
     49	000066	000762 				BR	10$			;
     50
     51					;
     52					; THE LAST STEP IS TO MERGE THE SUBLISTS INTO ONE MASTER SORTED LIST
     53					;
     54
     55	000070				MERGE:					;
     56	000070	012704 	000000G			MOV	#FRST,R4		;POINT TO MERGE LISTHEAD
     57	000074	012605 				MOV	(SP)+,R5		;GET ADDRESS OF LISTHEAD TABLE
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 32-1
ALPHAB	ALPHABETIZE SYMBOL TABLE

     58	000076	012503 			10$:	MOV	(R5)+,R3		;GET ADDRESS OF NEXT SYMBOL
     59	000100	001434 				BEQ	60$			;IF EQ NO MORE THIS SUBLIST
     60	000102	032763 	001000 	000002 		BIT	#S.LOCL,SYMFLAGS(R3)	;LOCAL SYMBOL?
     61	000110	001002 				BNE	20$			;IF NE YES
     62	000112	010314 				MOV	R3,(R4)			;LINK NEW SYMBOL TO OLD LAST
     63	000114	010304 				MOV	R3,R4			;SET ADDRESS OF NEW LAST
     64	000116	011345 			20$:	MOV	(R3),-(R5)		;REMOVE SYMBOL FROM LIST
     65	000120	001001 				BNE	30$			;IF NE MORE IN LIST
     66	000122	005725 				TST	(R5)+			;ADVANCE LISTHEAD POINTER
     67	000124	020516 			30$:	CMP	R5,(SP)			;ANY MORE SUBLISTS TO CONSIDER?
     68	000126	001423 				BEQ	70$			;IF EQ NO
     69	000130	010446 				MOV	R4,-(SP)		;
     70	000132	010546 				MOV	R5,-(SP)		;
     71	000134	012504 			40$:	MOV	(R5)+,R4		;GET ADDRESS OF FIRST SUBLIST ENTRY
     72	000136	020566 	000004 			CMP	R5,4(SP)		;ANY MORE SUBLISTS TO CONSIDER?
     73	000142	001410 				BEQ	50$			;IF EQ NO
     74	000144	011503 				MOV	(R5),R3			;GET ADDRESS OF FIRST SUBLIST ENTRY
     75	000146					CALL	CMPSYM			;COMPARE SYMBOLS
     76	000152	101404 				BLOS	50$			;IF LOS SUBLISTS ALREADY IN CORRECT ORDER
     77	000154	010415 				MOV	R4,(R5)			;SWAP SUBLISTS
     78	000156	010365 	177776 			MOV	R3,-2(R5)		;
     79	000162	000764 				BR	40$			;
     80	000164	012605 			50$:	MOV	(SP)+,R5		;RESTORE MERGE PARAMETERS
     81	000166	012604 				MOV	(SP)+,R4		;
     82	000170	000742 				BR	10$			;
     83	000172	020516 			60$:	CMP	R5,(SP)			;ANY MORE SUBLISTS TO CONSIDER?
     84	000174	001340 				BNE	10$			;IF NE YES
     85	000176	005726 			70$:	TST	(SP)+			;CLEAN STACK
     86	000200	005014 				CLR	(R4)			;CLEAR FORWARD LINK IN LAST ENTRY
     87	000202				EXIT:	RETURN				;
     88
     89					;
     90					; COMPARE SYMBOLS
     91					;
     92					; INPUTS:
     93					;
     94					;	R4 = ADDRESS OF CURRENT SYMBOL.
     95					;	R3 = ADDRESS OF NEXT SYMBOL.
     96					;
     97					; OUTPUTS:
     98					;
     99					;	CONDITION CODES SET ON COMPARISON OF CURRENT VERSUS NEXT SYMBOL
    100					;
    101
    102	000204				CMPSYM:					;
    103	000204	012701 	000011 			MOV	#SYMLEN,R1		;GET OFFSET TO SYMBOL LENGTH
    104	000210	010402 				MOV	R4,R2			;COPY ADDRESS OF CURRENT SYMBOL
    105	000212	060102 				ADD	R1,R2			;POINT TO SYMBOL LENGTH
    106	000214	060301 				ADD	R3,R1			;POINT TO SYMBOL LENGTH OF NEXT SYMBOL
    107	000216	112100 				MOVB	(R1)+,R0		;ASSUME NEXT SYMBOL IS SHORTER
    108	000220	120022 				CMPB	R0,(R2)+		;NEXT SYMBOL SHORTER?
    109	000222	101402 				BLOS	10$			;IF LOS YES
    110	000224	116200 	177777 			MOVB	-1(R2),R0		;GET LENGTH OF CURRENT SYMBOL
    111	000230	005400 			10$:	NEG	R0			;NEGATE LENGTH OF SHORTER SYMBOL
    112	000232	062700 	000017 			ADD	#15.,R0			;COMPUTE COMPLEMENT BASE 15.
    113	000236	072027 	000002 			ASH	#2,R0			;MULTIPLY BY 4
    114	000242	060007 				ADD	R0,PC			;DISPATCH INTO COMPARE VECTOR
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 32-2
ALPHAB	ALPHABETIZE SYMBOL TABLE

    115		000017 				.REPT	15.
    116						CMPB	(R2)+,(R1)+		;COMPARE SYMBOLS
    117						BNE	20$			;IF NE NO MATCH
    118						.ENDR
    119	000340	126463 	000011 	000011 		CMPB	SYMLEN(R4),SYMLEN(R3)	;CURRENT SYMBOL SHORTER?
    120	000346				20$:	RETURN				;
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 33
FINISH	OUTPUT TRACEBACK, DEBUGGER INFO. AND PRINT SYMBOL TABLE

    122					.SBTTL	FINISH	OUTPUT TRACEBACK, DEBUGGER INFO. AND PRINT SYMBOL TABLE
    123					;
    124					; DEBUGGER DEFINITIONS
    125					;
    126		000270 				DB.PSEC	=	184.			; PSECT NAME (1+11+N - ENTRY LENGTH)
    127		000272 				DB.LBL	=	186.			; SYMBOL NAME (1+7+N)
    128		000274 				DB.MNAM	=	188.			; MODULE NAME (1+7+N)
    129		000275 				DB.MEND	=	189.			; MODULE END (1+1)
    130		000276 				DB.ROUT	=	190.			; ROUTINE NAME (1+7+N)
    131		000000 				DS.LIT	=	0			; LITERAL DATA
    132		000001 				DS.ADDR	=	1			; RELOCATABLE DATA
    133		000014 				DL.PSEC	=	12.			; CONSTANT LENGTH OF PSECT ENTRY
    134		000010 				DL.LBL	=	8.			; CONSTANT LENGTH OF SYMBOL ENTRY
    135		000010 				DL.NAM	=	8.			; CONSTANT LENGTH OF MODULE ENTRY
    136		000002 				DL.END	=	2			; LENGTH OF END MODULE ENTRY
    137		000010 				DL.ROUT	=	8.			; CONSTANT LENGTH OF ROUTINE ENTRY
    138
    139	000350				FINISH::	;(DBG)
    140
    141
    142					.SBTTL	.	OUTPUT MODULE HEADER AND ROUTINE NAMES AS TRACEBACK RECORD
    143
    144	000350					IF EN.TBK+SYMVL2 IS EQ THEN
    145	000356						JUMPTO PRSYMT
    146	000362					END;IF
    147	000362					LET RECTYP	:= #OB.TRC		; TRACEBACK RECORD
    148	000370					CALL WRTOBJ				; WRITE OUT LAST TIR RECORD
    149	000374					LET R1		:= TITLEP		; POINT TO MODULE NAME
    150	000400					IF RESULT IS NE THEN			; USER SUPPLIED TITLE
    151	000402					    LET R1	:= R1 + #SYMLEN		; POINT TO LENGTH OF NAME
    152	000406					ELSE
    153	000410					    LET R1	:= #XTITLE		; ADDRESS OF DEFAULT NAME
    154	000414					END;IF
    155	000414					LET R0		:B= (R1)		; GET LENGTH OF TITLE
    156	000416					LET R0		:= R0 + #DL.NAM-1	; ENTRY OVERHEAD
    157	000422					CALL	STOIM				; STORE LENGTH
    158	000426					CALL	STOIM	<#DB.MNAM>		; MODULE NAME TYPE
    159	000436					LET R0		:= #0			; STRUCTURE LEVEL AND "MACRO"
    160	000440					REPEAT THRU R2	:= #5			; OUTPUT FIVE BYTES
    161	000444					    CALL STOIM				;
    162	000450					END;R
    163	000452					LET R2		:B= (R1)+		; GET LOOP COUNT
    164	000454					CALL	STOIM	R2			; OUTPUT LENGTH OF MODULE NAME
    165	000462					REPEAT THRU R2
    166	000462					    LET R0	:B= (R1)+		; GET CHARACTER
    167	000464					    CALL STOIM				; WRITE OUT NAME
    168	000470					END;R
    169	000472					LET  R1		:= IDENTB		; POINT TO LIST OF SYMBOLS
    170	000476					WHILE R1 IS NE				; SEARCH ENTIRE TABLE
    171	000502					    IF #S.EPT SET.IN SYMFLAG(R1) THEN	; ENTRY POINT?
    172	000512						LET R0	:B= SYMLEN(R1)		; ROUTINE NAME LENGTH
    173	000516						LET R0	:= R0 + #DL.LBL-1	; PLUS OVERHEAD
    174	000522						CALL STOIM			; STORE LENGTH OF FRAME
    175	000526						CALL STOIM <#DB.ROUT>		; ROUTINE NAME
    176	000536						CALL STOIM <#0>			; ZERO BYTE
    177	000546						CALL DBGSYM			; OUTPUT ROUTINE'S ADDRESS
    178	000552						CALL DBGNAM <#SYMCHRS>		; OUTPUT ROUTINE'S NAME
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 33-1
.	OUTPUT MODULE HEADER AND ROUTINE NAMES AS TRACEBACK RECORD

    179	000562					    END;IF
    180	000562					    LET R1	:= (R1)			; POINT TO NEXT SYMBOL
    181	000564					END;W
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 34
.	OUTPUT LABELS AND REFERENCED SYMBOLS (DEBUG RECORD)

    183					.SBTTL	.	OUTPUT LABELS AND REFERENCED SYMBOLS (DEBUG RECORD)
    184
    185
    186	000566					LET RECTYP	:= #OB.DBG		; DEBUGGER RECORD TYPE
    187	000574					CALL WRTOBJ				; WRITE OUT TRACEBACK RECORD
    188	000600					LET R1		:= IDENTB		; POINT TO SYMBOL LIST
    189	000604					WHILE R1 IS NE				; ONCE PER SYMBOL
    190	000610					    LET R2	:= SYMFLAG(R1)		; GET SYMBOL'S FLAGS
    191	000614					    IF #S.DBG SET.IN R2 AND #S.DF SET.IN R2 THEN
    192											; DEBUG ATTRIBUTE AND DEFINED
    193	000630					      IF #S.REF SET.IN R2 OR #S.ABS OFF.IN R2 THEN
    194											; REFERENCED OR RELOCATABLE
    195	000644						LET SYMFLAG(R1) := SYMFLAG(R1) SET.BY #S.ODBG
    196											; SET DEBUG-OUTPUT FLAG
    197	000652						IF #S.EPT OFF.IN R2 THEN	; NOT A ROUTINE NAME
    198	000660						    LET R0 :B= SYMLEN(R1)	; GET LENGTH OF SYMBOL
    199	000664						    LET R0 := R0 + #DL.LBL-1	; PLUS OVERHEAD
    200	000670						    CALL STOIM			; STORE LENGTH
    201	000674						    CALL STOIM <#DB.LBL>	; ASSUME A LABEL
    202	000704						    IF #S.ABS OFF.IN R2 THEN	; RELOCATABLE?
    203	000712							CALL STOIM <#DS.ADDR>	; YES
    204	000722							CALL DBGSYM		;
    205	000726						    ELSE
    206	000730							CALL STOIM <#DS.LIT>	; LITERAL DATA
    207	000740							CALL STOIM <SYMVL1(R1)>	; OUTPUT VALUE
    208	000750							LET R0	:B= SYMVL1+1(R1) ;
    209	000754							CALL STOIM
    210	000760							CALL STOIM <SYMVL2(R1)>	;
    211	000770							LET R0	:B= SYMVL2+1(R1) ;
    212	000774							CALL STOIM
    213	001000						    END;IF
    214	001000						    CALL DBGNAM <#SYMCHRS>	; OUTPUT NAME
    215	001010						END;IF
    216	001010					      END;IF
    217	001010					    END;IF
    218	001010					    LET R1		:= (R1)		; POINT TO NEXT NAME
    219	001012					END;W
    220	001016					LET RECTYP	:= #OB.TRC		; TRACEBACK RECORD TYPE
    221	001024					CALL WRTOBJ				; WRITE OUT LAST DEBUGGER RECORD
    222
    223					.SBTTL	.	OUTPUT PSECT NAMES AND END OF MODULE (TRACEBACK RECORD)
    224
    225	001030					LET R1		:= #BLNKP		; BLANK PSECT
    226	001034					CALL DBGPSCT				; OUTPUT BLANK PSECT (TRACEBACK)
    227	001040					LET R1		:= PSECTN		; POINT TO PSECT LIST
    228	001044					WHILE R1 IS NE				; ONCE PER PSECT
    229	001050					    CALL DBGPSCT			; OUTPUT TRACEBACK PSECT RECORDS
    230	001054					    LET R1	:= (R1)			; POINT TO NEXT NAME
    231	001056					END;W
    232
    233	001060					CALL STOIM <#1>				; STORE LENGTH
    234	001070					CALL STOIM <#DB.MEND>			; MODULE END
    235	001100				PRSYMT:	CALL WRTOBJ				; WRITE OUT TRACEBACK RECORD
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 35
.	PRINT SYMBOL TABLE IN ALPHABETICAL ORDER

    237					.SBTTL	.	PRINT SYMBOL TABLE IN ALPHABETICAL ORDER
    238
    239
    240	001104					LET LISTLV	:= #1			; FORCE PRINTING
    241	001112					LET R3	:= #SYHDR			; POINT TO MESSAGE
    242	001116					LET R2	:= #SBTLB1			; SUBTITLE BUFFER
    243	001122					REPEAT					; COPY "SYMBOL TABLE"
    244	001122					    LET (R2)+ :B= (R3)+			; INTO SBTTL BUFFER
    245	001124					UNTILB (R3) IS EQ			; "ASCIZ" STRING
    246	001130					LET R3		:= #SBTLB1+63. - R2	; GET NO. OF BYTES LEFT
    247	001136					REPEAT THRU R3				; BLANK FILL REST OF LINE
    248	001136					    LET (R2)+	:B= #SPACE		;
    249	001142					END;R
    250	001144					LET FRST	:= IDENTB		; GET POINTER
    251	001152					LET R4	:= 0				; RESET STACK PTR
    252	001154					WHILE FRST IS NE			; ONCE PER PAGE
    253	001162					    CALL HEADER				; SKIP TO NEW PAGE
    254	001166					    LET R1	:= #LPTLEN-3		; LINES PER PAGE
    255	001172					    LET R2	:= FRST			; POINT TO SYMBOL
    256	001176					    WHILE R2 IS NE AND R1 IS GT		; SKIP DOWN LIST
    257	001206						LET R2	:= (R2)			; POINT TO NEXT SYMBOL
    258	001210						LET R1	:= R1 -1		; COUNT IT
    259	001212					    END
    260	001214					    LET V1NEXT	:= R2			; SAVE SECOND COLUMN PTR
    261	001220					    LET R1	:= #LPTLEN-3		; LINES PER PAGE
    262	001224					    WHILE R2 IS NE AND R1 IS GT
    263	001234						LET R2	:= (R2)			; POINT TO NEXT NAME
    264	001236						LET R1	:= R1 -1		; COUNT IT
    265	001240					    END
    266	001242					    LET V2NEXT	:= R2			; POINT TO THIRD COLUMN
    267	001246					    REPEAT THRU R5 := #LPTLEN-3		; ONCE PER LINE
    268	001252						CALL LINIT			; INITIALIZE LINE
    269	001256						LET R2	:= FRST			; POINT TO FIRST COLUMN
    270	001262						IF R2 IS NE THEN		; ANY LEFT?
    271	001266						    LET FRST	:= (R2)		; POINT TO NEXT
    272	001272						    CALL SYMPRT			; PRINT SYMBOL INFO
    273	001276						END
    274	001276						LET R2	:= V1NEXT		; SECOND COLUMN
    275	001302						IF R2 IS NE THEN
    276	001306						    LET V1NEXT	:= (R2)		; POINT TO NEXT
    277	001312						    CALL SYMPRT			; PRINT SYMBOL INFO
    278	001316						END
    279	001316						LET R2	:= V2NEXT		; THIRD COLUMN
    280	001322						IF R2 IS NE THEN		; IF ANY
    281	001326						    LET V2NEXT	:= (R2)		; POINT TO NEXT
    282	001332						    CALL SYMPRT			; PRINT SYMBOL INFO
    283	001336						END
    284	001336						LET LINELN	:= R3 - #LINEBF	; LENGTH OF LINE
    285	001350						IF R3 HI #LSTLND THEN CALL WRTLST ; WRITE OUT LINE
    286	001362					    END
    287	001364					    LET FRST	:= V2NEXT		; RESET FOR NEXT PAGE
    288	001372					END
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 36
.	PRINT PSECT SYNOPSIS

    290					.SBTTL	.	PRINT PSECT SYNOPSIS
    291
    292
    293	001376					LET R3		:= #PSYNOP		; POINT TO MESSAGE
    294	001402					LET R2		:= #SBTLB1		; SUBTITLE BUFFER
    295	001406					WHILEB (R3) IS NE			; COPY MESSAGE
    296	001412					    LET (R2)+ :B= (R3)+			; INTO SUBTITLE BUFFER
    297	001414					END
    298	001416					LET SBTTLN	:= R2 - #SBTLB1		; MESSAGE LENGTH
    299	001430					LET LINELN	:= #LSTLND-LINEBF	; NULL LINE LENGTH
    300	001436					CALL WRTLST				; SKIP TWO LINES
    301	001442					LET LINELN	:= #LSTLND-LINEBF
    302	001450					CALL WRTLST
    303	001454					CALL LINIT				; INITIALIZE LINE
    304	001460					CALL MSG	<#PSYNOP>		; "PSECT SYNOPSIS"
    305	001470					LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH
    306	001502					CALL WRTLST				; WRITE OUT LINE
    307	001506					LET LINELN	:= #LSTLND-LINEBF	; SKIP A LINE
    308	001514					CALL WRTLST
    309	001520					LET R2		:= #MAIN		; POINT TO FIRST PSECT
    310	001524					CALL PSCPRT				; TELL ABOUT IT
    311	001530					LET R2		:= #BLNKP		; POINT TO BLANK PSECT
    312	001534					CALL PSCPRT				; OUTPUT INFO
    313	001540					LET R2		:= PSECTN		; POINT TO PSECTS
    314	001544					WHILE R2 IS NE				; ONCE PER PSECT
    315	001550					    CALL PSCPRT				; PRINT PSECT INFO
    316	001554					    LET R2	:= (R2)			; POINT TO NEXT PSECT
    317	001556					END
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 37
.	PRINT ERROR SUMMARY

    319					.SBTTL	.	PRINT ERROR SUMMARY
    320
    321
    322	001560					LET LINELN	:= #LSTLND-LINEBF	; NULL LINE
    323	001566					CALL WRTLST
    324	001572					LET LINELN	:= #LSTLND-LINEBF	; NULL LINE
    325	001600					CALL WRTLST				; PRINT IT
    326	001604					IF ERRCT IS EQ AND WARNCT IS EQ THEN	; NO ERRORS OR WARNINGS !
    327	001620					    CALL LINIT				; BLANK FILL LINE SET R3
    328	001624					    CALL MSG <#NOERR>			; NO ERRORS
    329	001634					    LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH
    330	001646					    CALL WRTLST				; AND WRITE IT TO LISTING
    331	001652					    JUMPTO ERRORX			; EXIT
    332	001656					END
    333						; EXECUTE IF ERRORS OR WARNINGS
    334	001656					LET R1	:= 0				; TRAILING PTR
    335	001660					LET R2	:= ERRLST			; POINTER TO ERROR LIST
    336	001664					WHILE R2 IS NE				; REVERSE ERROR LINE NUMBERS
    337	001670					    LET R3	:= (R2)			; SAVE PTR TO NEXT
    338	001672					    LET (R2)	:= R1			; HE POINTS TO PREVIOUS
    339	001674					    LET R1	:= R2			; UPDATE TRAILING PTR
    340	001676					    LET R2	:= R3			; POINT TO NEXT GUY
    341	001700					END
    342	001702					CALL LINIT				; BLANK FILL LINE SET R3
    343	001706					LET ERRLST	:= R1			; POINT TO REVERSED LIST
    344	001712					CALL MSG <#ERRL1>			; "THERE WERE "
    345	001722					IF ERRCT IS NE THEN			; ERRORS ?
    346	001730					    LPUSH	ERRCT,#0		; PUSH ERROR COUNT
    347	001750					    CALL DECLR				; PRINT NUMBER OF ERRORS
    348	001754					    CALL MSG <#ERRERR>			; " ERRORS"
    349	001764					    IF WARNCT IS NE THEN		; WARNINGS TOO ?
    350	001772						CALL MSG <#ERRAND>		; " AND "
    351	002002					    END
    352	002002				        END
    353	002002					IF WARNCT IS NE THEN			; WARNINGS ?
    354	002010					    LPUSH	WARNCT,#0		; PUSH WARNING COUNT
    355	002030					    CALL DECLR				; PRINT NUMBER OF WARNINGS
    356	002034					    CALL MSG <#ERRWRN>			; " WARNINGS"
    357	002044					END
    358	002044					CALL MSG <#ERRL2>			; ", ON LINES:"
    359	002054					LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH
    360	002066					CALL WRTTTY				; SEND LINE TO TERMINAL
    361	002072					CALL WRTLST				; PRINT LINE IN LISTING
    362	002076					LET R2	:= ERRLST			; POINT TO ERROR LIST
    363	002102					CALL LINIT				; INITIALIZE LINE BUFFER
    364	002106					LET R1	:= R3				; COPY LINE POINTER
    365	002110					WHILE R2 IS NE				; PRINT ERRORS
    366	002114					    IF R3 LOS #LSTLND+60. THEN		; ROOM FOR ONE MORE? (12 CHRS MAX)
    367	002122						LPUSH 2(R2),#0			; PUSH LINE NUMBER
    368	002142						CALL DECLR			; OUTPUT LINE NUMBER (5 CHRS MAX)
    369	002146						LET R3	:= R1 + #6		; MOVE TO PAGE NUMBER FIELD
    370	002154						LET R1	:= R3			; COPY LINE POINTER
    371	002156						LET (R3)+	:B= #'(		; LEFT PARENTHESIS
    372	002162						LPUSH 4(R2),#0			; PUSH PAGE NUMBER
    373	002202						CALL DECLR			; OUTPUT PAGE NUMBER (3 CHRS MAX)
    374	002206						LET (R3)+	:B= #')		; RIGHT PARENTHESIS
    375	002212						LET R3	:= R1 + #6		; MOVE TO NEXT LINE NO. FIELD
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 37-1
.	PRINT ERROR SUMMARY

    376	002220						LET R1	:= R3			; COPY LINE POINTER
    377	002222						LET R2	:= (R2)			; POINT TO NEXT ERROR
    378	002224					    ELSE
    379	002226						LET LINELN := R3 - #LINEBF	; SET LINE LENGTH
    380	002240						CALL WRTTTY			; TYPE LINE OUT
    381	002244						CALL WRTLST			; WRITE OUT LINE
    382	002250						CALL LINIT			; INITIALIZE LINE
    383	002254						LET R1	:= R3			; COPY LINE POINTER
    384	002256					    END;IF
    385	002256					END;W
    386	002260					LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH
    387	002272					CALL WRTTTY				; TYPE LAST LINE
    388	002276					CALL WRTLST				; WRITE OUT LAST LINE
    389	002302					CALL LINIT				; INITIALIZE LINE
    390	002306					LET LINELN	:= #LSTLND-LINEBF	; NULL LINE
    391	002314					CALL WRTTTY				; WRITE TO TTY
    392	002320					CALL WRTLST				; WRITE TO LISTING
    393	002324				ERRORX:						; EXIT POINT FOR ROUTINE
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 38
.	PRINT MEMORY STATISTICS AND COMMAND LINE

    395					.SBTTL	.	PRINT MEMORY STATISTICS AND COMMAND LINE
    396
    397
    398	002324					CALL LINIT				; INITIALIZE LINE
    399	002330					LET R0		:= FRIEND - FREEPT	; BYTES IN FREE CORE POOL
    400	002340					LPUSH		R0,#0			; PUSH FOR PRINTING
    401	002356					CALL DECLR				; PRINT DECIMAL NUMBER
    402	002362					CALL MSG	<#FREPOL>		; " BYTES IN FREE MEMORY POOL"
    403	002372					LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH
    404	002404					CALL WRTLST				; WRITE TO LISTING
    405	002410					IF CORLST IS NE THEN			; RECLAIMED HOLES OF MEMORY?
    406	002416					    CALL LINIT				; INITIALIZE LINE
    407	002422					    LET R0	:= 0			; START WITH ZERO
    408	002424					    LET R1	:= CORLST		; POINT TO LIST OF HOLES
    409	002430					    WHILE R1 IS NE			; ONCE PER HOLE
    410	002434						LET R0	:= R0 + 2(R1)		; ADD SIZE OF HOLE
    411	002440						LET R1	:= (R1)			; SKIP TO NEXT HOLE
    412	002442					    END
    413	002444					    LPUSH	R0,#0			; TOTAL RECLAIMED BYTES
    414	002462					    CALL DECLR				; PRINT AS DECIMAL NO.
    415	002466					    CALL MSG	<#FREHOL>		; "BYTES OF RECLAIMED HOLES"
    416	002476					    LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH
    417	002510					    CALL WRTLST				; PRINT LINE IN LISTING
    418	002514					END;IF
    419					;
    420					; PRINT USER'S COMMAND LINE
    421					;
    422	002514					CALL LINIT				; INITIALIZE LINE
    423	002520					LET R2		:= CMLINE		; POINT TO COMMAND LINE DESCR.
    424	002524					LET R0		:= (R2)+		; GET LENGTH OF LINE
    425	002526					LET R1		:= (R2)			; GET ADDRESS OF COMMAND LINE
    426	002530					REPEAT THRU R0				; COPY TO BUFFER
    427	002530					    LET (R3)+ :B= (R1)+			; COPY COMMAND LINE
    428	002532					END;R
    429	002534					LET LINELN	:= R3 - #LINEBF		; SET LINE LENGTH FOR OUTPUT ROUTS
    430	002546					IF ERRCT IS NE OR WARNCT IS NE THEN	; ERRORS OR WARNINGS?
    431	002562					    CALL WRTTTY				; YES, TELL USER WHICH COMMAND
    432	002566					END
    433	002566	000167 	000000G			JMP	WRTLST				; WRITE TO LISTING AND RETURN
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 39
DBGNAM	OUTPUT DEBUG NAME TO OBJECT FILE

    435					.SBTTL	DBGNAM	OUTPUT DEBUG NAME TO OBJECT FILE
    436					;
    437					; R0 = OFFSET TO NAME
    438					; R1 = ADDRESS OF SYMBOL BLOCK
    439					;
    440
    441	002572				DBGNAM::	;(DBG)
    442	002572					PUSH	R0				; SAVE OFFSET TO NAME
    443	002574					LET R3	:= R1 + #SYMLEN			; POINT TO LENGTH BYTE
    444	002602					LET R2	:B= (R3)+			; GET LENGTH
    445	002604					CALL STOIM R2				; STORE LENGTH
    446	002612					POP	R0				; GET OFFSET TO NAME
    447	002614					LET R3	:= R1 + R0			; POINT TO SYMBOL NAME
    448	002620					REPEAT THRU R2				; ONCE PER CHAR
    449	002620					    LET R0	:B= (R3)+		; GET NEXT CHAR
    450	002622					    CALL STOIM				; STORE CHAR
    451	002626					END;R
    452	002630					RETURN
    453
    454
    455					.SBTTL	DBGSYM	OUTPUT SYMBOL VALUE IN DEBUG RECORD
    456
    457	002632				DBGSYM:
    458	002632					GEN STPBL			; RELOCATE TO SYMBOL
    459	002642					DATA SYMSEG(R1)			; SEGMENT NUMBER
    460	002654					LET R3	:= R1 + #SYMVL1 	; POINT TO VALUE
    461	002662					REPEAT THRU R0 := #4		; OUTPUT VALUE
    462	002666					    DATA (R3)+
    463	002676					END;R
    464	002700					GEN STOL			; STORE LONGWORD
    465	002710					RETURN
    466
    467
    468					.SBTTL	DBGPSCT	OUTPUT PSECT RECORDS TO DEBUG RECORD
    469
    470	002712				DBGPSCT:
    471	002712					LET R0	:B= SYMLEN(R1)		; GET LENGTH OF NAME
    472	002716					LET R0	:= R0 + #DL.PSEC-1	; ADD OVERHEAD
    473	002722					CALL STOIM			; STORE LENGTH
    474	002726					CALL STOIM <#DB.PSEC>		; PSECT
    475	002736					CALL STOIM <#0>			; MBZ
    476	002746					GEN  STPBB			; STACK PSECT BASE BYTE OFFSET
    477	002756					DATA SYMSEG(R1)			; PSECT NUMBER
    478	002770					DATA #0				; OFFSET OF ZERO
    479	003000					GEN  STOL			; STORE LONGWORD ADDRESS OF PSECT
    480	003010					CALL DBGNAM <#PSECCH>		; OUTPUT PSECT NAME
    481	003020					CALL STOIM  <SYMVL1(R1)>	; OUTPUT FIRST BYTE OF LENGTH
    482	003030					LET  R0	:B= SYMVL1+1(R1)	; GET SECOND BYTE
    483	003034					CALL STOIM			; OUTPUT SECOND BYTE
    484	003040					CALL STOIM  <SYMVL2(R1)>	; OUTPUT THIRD BYTE OF LENGTH
    485	003050					LET  R0	:B= SYMVL2+1(R1)	; GET LAST BYTE OF LENGTH
    486	003054	000167 	000000G			JMP	STOIM			; OUTPUT FOURTH BYTE AND RETURN
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 40
SYMPRT	PRINT SYMBOL INFORMATION

    488					.SBTTL	SYMPRT	PRINT SYMBOL INFORMATION
    489					;
    490					; SYMPRT -- PRINTS NAME, VALUE, FLAGS, AND PSECT FOR SYMBOL POINTED
    491					; TO BY R2.  R3 IS THE OUTPUT POINTER.
    492					;
    493					;
    494
    495	003060				SYMPRT::	;(DBG)
    496	003060					PUSH	R3				; SAVE OUTPUT POINTER
    497	003062					LET R0		:B= SYMLEN(R2)		; LENGTH OF NAME
    498	003066					LET R1		:= R2 + #SYMCHRS	; POINT TO NAME
    499	003074					REPEAT THRU R0				; ONCE PER CHAR
    500	003074					    LET (R3)+	:B= (R1)+		; COPY NAME
    501	003076					END
    502	003100					LET R3		:= (SP) + #15.		; END OF NAME
    503	003106					IF #S.ASN SET.IN SYMFLAG(R2) THEN	; ASSIGNED SYMBOL?
    504	003116					    LET (R3)+	:B= #'=			; YES
    505	003122					ELSE
    506	003124					    LET (R3)+	:B= #^O40		; NO
    507	003130					END
    508	003130					LET R3		:= R3 + #9.		; MAKE ROOM FOR VALUE
    509	003134					LET LSTLPT	:= R3			; POINT TO OUTPUT SPOT
    510	003140					PUSH R3					; SAVE R3
    511	003142					IF #S.DF OFF.IN SYMFLAG(R2) THEN	; SYMBOL DEFINED?
    512	003152					    REPEAT THRU R0 := #8.		; NO!
    513	003156						LET -(R3) :B= #'*		; VALUE IS STARS
    514	003162					    END
    515	003164					ELSE
    516	003166					    LPUSH	SYMVL1(R2),SYMVL2(R2)	; PUSH REAL VALUE
    517	003206					    FORMAT	#4			; PRINT 4 BYTES WORTH
    518	003216					END
    519	003216					POP R3					; RESTORE R3
    520	003220					LET R1		:= SYMFLAG(R2)		; GET SYMBOL'S FLAGS
    521	003224					IF #S.WEAK SET.IN R1 THEN LET 0(R3) :B= #'W  ; WEAK
    522	003240					IF #S.ABS OFF.IN R1 AND #S.DF SET.IN R1 THEN ; RELOCATABLE
    523	003254					    LET 1(R3) :B= #'R
    524	003262					END;IF
    525	003262					IF #S.GLOBL SET.IN R1 THEN LET 2(R3) :B= #'G ; GLOBAL
    526	003276					IF #S.EXTN SET.IN R1 THEN LET 3(R3) :B= #'X  ; EXTERNAL
    527	003312					IF #S.ODBG SET.IN R1 THEN LET 4(R3) :B= #'D  ; MARK AS DEBUG SYMBOL
    528	003326					IF #S.DF+S.GLOBL+S.EXTN OFF.IN R1 THEN	; SYMBOL NOT DEFINED OR EXTERNAL
    529	003334					    LET 5(R3)	:B= #'U			; MARK AS UNDEFINED
    530	003342					END;IF
    531	003342					LET R3		:= R3 + #9.		; MOVE TO PSECT SPOT
    532	003346					LET LSTLPT	:= R3			; SET OUTPUT POINTER
    533	003352					IF #S.ABS OFF.IN R1 THEN		; RELOCATABLE?
    534	003360					    LET R0	:B= SYMSEG(R2)		; GET SEG #
    535	003364					    LPUSH	R0,#0			; PUSH IT
    536	003402					    FORMAT	#1			; OUTPUT A BYTE
    537	003412					END
    538	003412					POP R3					; RESTORE R3
    539	003414					LET R3		:= R3 + #37.		; MOVE TO NEXT FIELD
    540	003420					RETURN
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 41
PSCPRT	PRINT PSECT OPTIONS AND ALIGNMENT

    542					.SBTTL	PSCPRT	PRINT PSECT OPTIONS AND ALIGNMENT
    543					;
    544					; PROCEDURE TO PRINT PSECT INFORMATION
    545					; R2 = ADDRESS OF NAME BOLCK
    546					;
    547
    548	003422				PSCPRT::	;(DBG)
    549	003422					CALL LINIT				; INITIALIZE LINE
    550	003426					PUSH R3					; SAVE R3
    551	003430					LET R1		:= R2 + #SYMLEN		; POINT TO LENGTH
    552	003436					LET R0		:B= (R1)+		; PICK UP LENGTH
    553	003440					LET R1		:= R1 + #6		; NAME IS 3 WORDS DOWN
    554	003444					REPEAT THRU R0				; ONCE PER CHAR
    555	003444					    LET (R3)+	:B= (R1)+		; COPY NAME
    556	003446					END
    557	003450					LET R3		:= (SP)+ + #15.+10.	; TAB TO ALLOC COLUMN
    558	003456					LET LSTLPT	:= R3			; SAVE OUTPUT POINTER
    559	003462					PUSH R3					; SAVE R3
    560	003464					LPUSH SYMVL1(R2),SYMVL2(R2)		; PUSH VALUE
    561	003504					FORMAT #4				; PRINT LONGWORD
    562	003514					LET R3		:= (SP)+ + #8.		; TAB TO NUMBER COLUMN
    563	003522					LET LSTLPT	:= R3			; SAVE OUTPUT POINTER
    564	003526					PUSH R3					; SAVE R3
    565	003530					LET R0		:B= SYMSEG(R2)		; GET PSECT NUMBER
    566	003534					LPUSH R0,#0				; PUSH IT
    567	003552					FORMAT #1				; PRINT A BYTE
    568	003562					LET R3		:= (SP)+ + #5.		; RESTORE OUTPUT PTR
    569					;
    570					; PRINT PSECT OPTIONS AND ALIGNMENT
    571					;
    572	003570					LET VAL1	:= PSECOP(R2) OFF.BY #S.DF ; GET FLAGS
    573	003604					LET VAL2	:= #1			; FIRST BIT TO CHECK
    574	003612					REPEAT THRU R1 := #9.			; ONCE PER BIT
    575	003616					    CALL PMATCH				; SCAN FOR THE OPTION
    576	003622					    LET VAL2	:= VAL2 + VAL2		; NEXT BIT
    577	003630					END
    578
    579	003632					PUSH R3					; SAVE FOR CHECK
    580	003634					LET VAL2	:= PSECOP(R2) OFF.BY #140777 ; KILL FLAG BITS
    581	003650					LET VAL1	:= VAL2			; POSITIVE POLARITY
    582	003656					CALL  PMATCH				; PRINT ALIGNMENT
    583	003662					IF (SP)+ EQ R3 THEN			; NOT FOUND!
    584	003666					    LET R0	:= VAL1 SHIFT #-9.	; GET VALUE
    585	003676					    LPUSH R0,#0				; STACK NUMBER
    586	003714					    CALL DECLR				; PRINT NUMBER
    587	003720					END
    588
    589	003720					LET LINELN	:= R3 - #LINEBF		; SET LINE WIDTH
    590	003732	000167 	000000G			JMP	WRTLST				; WRITE TO LISTING AND RETURN
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 42
PMATCH	MATCHES BIT VALUE WITH NAME

    592					.SBTTL	PMATCH	MATCHES BIT VALUE WITH NAME
    593					;
    594					; PROCEDURE PMATCH -- SCANS PSECT OPTION LIST FOR MATCH OF VALUE IN
    595					;			VAL2.  POLARITY IS DETERMINED BY CONTENTS OF VAL1
    596					;
    597
    598	003736				PMATCH::	;(DBG)
    599
    600	003736					PUSH R4					; SAVE R4
    601	003740					LET R0		:= VAL2			; GET BITS
    602	003744					IF R0 OFF.IN VAL1 AND R0 IS NE THEN	; NEGATIVE POLARITY?
    603	003756	005100 				    COM R0				; YES, USE COMPLEMENT
    604	003760					END
    605	003760					LET R4		:= #PS.OPT		; POINT TO FIRST OPTION
    606	003764					WHILE R4 IS NE				; ONCE PER OPTION
    607	003770					    IF R0 EQ SYMVL1(R4) THEN		; MATCH?
    608	003776						LET R4	:= R4 + #SYMLEN		; POINT TO OPTION LENGTH
    609	004002						LET R0	:B= (R4)+		; GET LENGTH OF NAME
    610	004004						PUSH R3				; SAVE OUTPUT PTR
    611	004006						IF R0 LE #3 THEN LET R3 := R3 + #2 ; RIGHT JUSTIFY
    612	004020						REPEAT THRU R0			; ONCE PER CHAR
    613	004020						    LET (R3)+ :B= (R4)+		; COPY CHARS
    614	004022						END
    615	004024						LET R3	:= (SP)+ + #6.		; TAB TO NEXT COLUMN
    616	004032						LET R4	:= 0			; STOP SEARCHING
    617	004034					    ELSE
    618	004036						LET R4	:= (R4)			; SKIP TO NEXT OPTION
    619	004040					    END
    620	004040					END
    621	004042					POP  R4					; RESTORE R4
    622	004044					RETURN
    623
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 43
LINIT	INITIALIZE LISTING LINE TO BLANKS

    625					.SBTTL	LINIT	INITIALIZE LISTING LINE TO BLANKS
    626					;
    627					; PROCEDURE TO INITIALIZE LISTING LINE
    628					;
    629
    630
    631	004046				LINIT::					;
    632	004046	012700 	000000G			MOV	#LSTLND,R0		;GET STARTING ADDRESS OF LINE BUFFER
    633	004052	010003 				MOV	R0,R3			;COPY STARTING ADDRESS OF LINE BUFFER
    634	004054	012720 	020040 		10$:	MOV	#"  ,(R0)+		;FILL LINE BUFFER WITH BLANKS
    635	004060	022700 	000204G			CMP	#LSTLND+132.,R0		;ANY MORE WORDS TO FILL?
    636	004064	101373 				BHI	10$			;IF HI YES
    637	004066					RETURN				;
    638
    639
    640
    641					.SBTTL	MSG	COPY MESSAGE TO LISTING BUFFER
    642					;
    643					; PROCEDURE TO PRINT MESSAGE.  POINTER TO ASCIZ STRING IS IN R0. R3
    644					; IS OUTPUT POINTER
    645					;
    646
    647	004070				MSG:					;
    648	004070	112023 				MOVB	(R0)+,(R3)+		;INSERT CHARACTER IN BUFFER
    649	004072	001376 				BNE	MSG			;IF NE MOVE ANOTHER CHARACTER
    650	004074	005303 				DEC	R3			;BACKUP BUFFER POINTER
    651	004076					RETURN				;
    652
    653
    654					;
    655					; MESSAGE TEXTS
    656					;
    657
    658	000000				.PSECT	FINMSG,D
    659
    660						.NLIST	BEX
    661
    662	000000	   123 	   131 	   115 	SYHDR:	.ASCIZ	/SYMBOL TABLE/
    663	000015	   120 	   122 	   117 	PSYNOP:	.ASCIZ	/PROGRAM SECTION SYNOPSIS/
    664	000046	   124 	   110 	   105 	NOERR:	.ASCIZ	/THERE WERE NO ERRORS OR WARNINGS./
    665	000110	   124 	   110 	   105 	ERRL1:	.ASCIZ	/THERE WERE /
    666	000124	   040 	   105 	   122 	ERRERR:	.ASCIZ	/ ERRORS/
    667	000134	   040 	   101 	   116 	ERRAND:	.ASCIZ	/ AND /
    668	000142	   040 	   127 	   101 	ERRWRN:	.ASCIZ	/ WARNINGS/
    669	000154	   054 	   040 	   117 	ERRL2:	.ASCIZ	/, ON LINES:/
    670	000170	   056 	   040 	   102 	FREPOL:	.ASCIZ	/. BYTES LEFT IN FREE MEMORY POOL./
    671	000232	   056 	   040 	   102 	FREHOL:	.ASCIZ	/. BYTES OF RECLAIMED MEMORY./
    672
    673						.EVEN
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 44
MSG	COPY MESSAGE TO LISTING BUFFER

    675	000000				.PSECT	PSECDT	D
    676					;
    677					; PSECT OPTIONS.  COMPLEMENTED OPTIONS ARE MARKED WITH COMPLEMENTED
    678					; VALUES.
    679					;
    680		000000 				INSYMP = 0				; START OF LIST
    681
    682	000000					INSYM	PIC,	001			; POSITION INDEPENDENT
    683	000016					INSYM	NOPIC,	<^C1>			; NOT PIC
    684	000036					INSYM	LIB,	002			; UNIVERSAL
    685	000054					INSYM	USR,	<^C2>			; USER (NOT UNIVERSAL)
    686	000072					INSYM	OVR,	004			; OVERLAID
    687	000110					INSYM	CON,	<^C4>			; CONCATENATED
    688	000126					INSYM	REL,	010			; RELOCATABLE
    689	000144					INSYM	ABS,	<^C10>			; ABSOLUTE
    690	000162					INSYM	GBL,	020			; GLOBAL
    691	000200					INSYM	LCL,	<^C20>			; LOCAL
    692	000216					INSYM	SHR,	040			; SHAREABLE
    693	000234					INSYM	NOSHR,	<^C40>			; NOT SHAREABLE
    694	000254					INSYM	EXE,	100			; EXECUTABLE
    695	000272					INSYM	NOEXE,	<^C100>			; NOT EXECUTEABLE
    696	000312					INSYM	RD,	200			; READABLE
    697	000326					INSYM	NORD,	<^C200>			; NO READ
    698	000344					INSYM	WRT,	400			; WRITEABLE
    699	000362					INSYM	NOWRT,	<^C400>			; NO WRITE
    700	000402					INSYM	BYTE,	0000			; BYTE ALIGNMENT
    701	000420					INSYM	WORD,	1000			; WORD ALIGNMENT
    702	000436					INSYM	LONG,	2000			; LONGWORD ALIGNMENT
    703	000454					INSYM	QUAD,	3000			; QUAD ALIGNMENT
    704	000472				PS.OPT:	INSYM	PAGE,	11000			; PAGE ALIGNMENT
    705
    706		000001 			.END
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 44-1
SYMBOL TABLE

ALPHAB  000000RG    002	ERRLST= ****** GX	LINELN= ****** GX	L60     004042R     002	SYMVL1= 000004
A3    = 000000   	ERRL1   000110R     003	LINIT   004046RG    002	L61     004036R     002	SYMVL2= 000006
BLNK  = 000040   	ERRL2   000154R     003	LISTLV= ****** GX	L62     004020R     002	S.ABS = 004000
BLNKP = ****** GX	ERRORX  002324R     002	LOWCAS= 000140   	L63     004040R     002	S.ASN = 000200
B0      000444R     002	ERRWRN  000142R     003	LPTLEN= 000074   	L7      000644R     002	S.DBG = 002000
B1      000462R     002	EXIT    000202R     002	LSTLND= ****** GX	MAIN  = ****** GX	S.DF  = 100000
B10     001176R     002	E0      000452R     002	LSTLPT= ****** GX	MERGE   000070R     002	S.EPT = 000100
B11     001224R     002	E1      000472R     002	L0      000362R     002	MSG     004070R     002	S.EXTN= 010000
B12     001252R     002	E10     001214R     002	L1      000410R     002	M.ARGC= 000014   	S.GLOB= 020000
B13     001406R     002	E11     001242R     002	L10     001010R     002	M.ARGS= 000016   	S.LOCL= 001000
B14     001544R     002	E12     001364R     002	L11     001010R     002	M.END = 000012   	S.ODBG= 000040
B15     001664R     002	E13     001416R     002	L12     000730R     002	M.GETL= 000004   	S.REF = 000400
B16     002110R     002	E14     001560R     002	L13     001000R     002	M.IFLV= 000006   	S.TKMS= 000377
B17     002430R     002	E15     001702R     002	L14     001060R     002	M.IFVL= 000010   	S.WEAK= 040000
B2      000476R     002	E16     002260R     002	L16     001376R     002	M.LINK= 000000   	TAB   = 000011
B20     002530R     002	E17     002444R     002	L17     001214R     002	M.NXTL= 000002   	TITLEP= ****** GX
B21     002620R     002	E2      000566R     002	L2      000414R     002	NOERR   000046R     003	TYPS0 = 000000
B22     002666R     002	E20     002534R     002	L20     001242R     002	OBJBYT= ****** GX	TYPS1 = 000001
B23     003074R     002	E21     002630R     002	L21     001276R     002	OB.DBG= ****** GX	TYPS2 = 000000
B24     003156R     002	E22     002700R     002	L22     001316R     002	OB.TRC= ****** GX	TYPS3 = 000006
B25     003444R     002	E23     003100R     002	L23     001336R     002	OUTOBJ= ****** GX	TYPS4 = 000000
B26     003616R     002	E24     003164R     002	L24     001362R     002	PMATCH  003736RG    002	TYPS5 = 000000
B27     003764R     002	E25     003450R     002	L25     001416R     002	PRSYMT  001100R     002	VAL1  = ****** GX
B3      000604R     002	E26     003632R     002	L26     001560R     002	PSCPRT  003422RG    002	VAL2  = ****** GX
B30     004020R     002	E27     004042R     002	L27     001656R     002	PSECCH= 000020   	V1NEXT= ****** GX
B4      001044R     002	E3      001016R     002	L3      000566R     002	PSECOP= 000016   	V1STAC= ****** GX
B5      001122R     002	E30     004024R     002	L30     001702R     002	PSECTN= ****** GX	V2NEXT= ****** GX
B6      001136R     002	E4      001060R     002	L31     002002R     002	PSECV1= 000012   	V2STAC= ****** GX
B7      001154R     002	E5      001130R     002	L32     002002R     002	PSECV2= 000014   	WARNCT= ****** GX
CMLINE= ****** GX	E6      001144R     002	L33     002044R     002	PSYNOP  000015R     003	WRTLST= ****** GX
CMPSYM  000204R     002	E7      001376R     002	L34     002260R     002	PS.OPT  000472R     004	WRTOBJ= ****** GX
COMMA = 000054   	FF    = 000014   	L35     002226R     002	RECTYP= ****** GX	WRTTTY= ****** GX
CORLST= ****** GX	FINISH  000350RG    002	L36     002256R     002	RGTANG= 000076   	XTITLE= ****** GX
CR    = 000015   	FREEPT= ****** GX	L37     002514R     002	RTNVAL=%000000   	$DIDDO= 000000
DBGNAM  002572RG    002	FREHOL  000232R     003	L4      000562R     002	R6    =%000006   	$E$   = 000001
DBGPSC  002712R     002	FREPOL  000170R     003	L40     002444R     002	R7    =%000007   	$F$   = 000000
DBGSYM  002632R     002	FRIEND= ****** GX	L41     002562R     002	SBTLB1= ****** GX	$I$   = 000001
DB.LBL= 000272   	FRST  = ****** GX	L42     002566R     002	SBTTLN= ****** GX	$L    = 000031
DB.MEN= 000275   	HEADER= ****** GX	L43     003124R     002	SEMI  = 000073   	$LL   = 000026
DB.MNA= 000274   	IDENTB= ****** GX	L44     003130R     002	SORT    000026R     002	$L$   = 000000
DB.PSE= 000270   	IIII  = 177777   	L45     003166R     002	SPACE = 000040   	$O$   = 000000
DB.ROU= 000276   	INSYMC= 000004   	L46     003216R     002	STOIM = ****** GX	$R    = 177777
DECLR = ****** GX	INSYMP= 000472R     004	L47     003240R     002	STOL  = ****** GX	$SV$  = 000000
DL.END= 000002   	INSYTM= 000472R     004	L5      001016R     002	STPBB = ****** GX	$T    = 000064
DL.LBL= 000010   	LBLS0 = 000060   	L50     003262R     002	STPBL = ****** GX	$T1   = 000001
DL.NAM= 000010   	LBLS1 = 000027   	L51     003276R     002	SYHDR   000000R     003	$T2   = 000027
DL.PSE= 000014   	LBLS2 = 000063   	L52     003312R     002	SYMCHR= 000012   	$Y$   = 000000
DL.ROU= 000010   	LBLS3 = 000030   	L53     003326R     002	SYMFLA= 000002   	$Z$   = 000000
DS.ADD= 000001   	LBLS4 = 000011   	L54     003342R     002	SYMLEN= 000011   	$$S   = 000000
DS.LIT= 000000   	LBLS5 = 000013   	L55     003412R     002	SYMLIN= 000000   	$$T   = 000060
EN.TBK= ****** GX	LF    = 000012   	L56     003720R     002	SYMMAX= 000017   	$$TT  = 000042
ERRAND  000134R     003	LFORM = ****** GX	L57     003760R     002	SYMPRT  003060RG    002	.GEN  = ****** GX
ERRCT = ****** GX	LFTANG= 000074   	L6      001010R     002	SYMSEG= 000010   	.$T   = 000001
ERRERR  000124R     003	LINEBF= ****** GX

. ABS.	000000	   000
      	000000	   001
FINISH	MACRO M1110  21-AUG-78 22:55  PAGE 44-2
SYMBOL TABLE

FINISH	004100	   002
FINMSG	000270	   003
PSECDT	000510	   004
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  12910 WORDS  ( 51 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:06:11
OBJ$:FINISH,LIS$:FINISH/-SP=SRC$:MD,COMMON,FINISH
