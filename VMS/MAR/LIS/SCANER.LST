SCANER	MACRO M1110  21-AUG-78 21:59
TABLE OF CONTENTS

    32-    2	**********  SCANNING ROUTINES  **********
    32-   10	SYMBOL		LOOK UP SYMBOL
    33-   94	SYMNUM		"A - F" CAN START SYMBOL OR NUMBER
    33-  105	XSYMBL		NEXT CHARACTER CAN BE '^'
    33-  129	NUMBER		ACCUMULATE NUMBER
    34-  139	DNUMBER		ACCUMULATE DECIMAL NUMBER
    35-  224	BINNUM		BINARY NUMBER ROUTINE
    35-  232	OCTNUM		OCTAL NUMBER ROUTINE
    35-  240	HEXNUM		HEXIDECIMAL NUMBER ROUTINE
    36-  247	PNUMBER		ACCUMULATE NUMBER - RADIX 2**N
    37-  299	SYMSCN		SCAN FOR SYMBOL NAME
    38-  321	GETSYM		ACCUMULATE SYMBOL BLOCK
    39-  379	REGIS		SCAN FOR REGISTER NAME
    40-  449	XUPARROW	ROUTINE TO CHECK CHARACTER AFTER '^'
    40-  473	XPOUND		POUND SIGN DETECTED
    41-  490	FINDSYM		LOOKUP SYMBOL IN SYMBOL TABLE
    42-  541	USER SYMBOL TABLE SEARCH AND INSERT ROUTINES
    43-  606	TUCK		INSERT SYMBOL INTO TABLE
    44-  661	**********  MACRO, REPEAT, AND IF SCANNERS  **********
    44-  662	BDYSCN		SCAN MACRO BODY
    45-  790	ARGSCN		SCAN MACRO ARGUMENT
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 32


      1					.TITLE	SCANER
      2					.SBTTL	**********  SCANNING ROUTINES  **********
      3					.GLOBL	SYMBOL,	XSYMBL,	NUMBER,	DNUMBE,	BINNUM,	OCTNUM,	HEXNUM,	PNUMBE
      4					.GLOBL	SYMSCN,	GETSYM,	REGIS,	XUPARR,	XPOUND,	FINDSY,	BDYSCN,	ARGSCN
      5	000000				.PSECT	SCANER
      6					;
      7					; THESE ROUTINES ARE CALLED BY "TOKEN" WHEN THE ENTRY IN "CHRTAB"
      8					; CORRESPONDING TO THE CHARACTER JUST PICKED UP BY "GETCHR" IS EVEN.
      9					;
     10					.SBTTL	SYMBOL		LOOK UP SYMBOL
     11					;
     12					;
     13					;	SYMBOL -- SCAN NEXT SYMBOL
     14					;
     15					; A SYMBOL BLOCK IS BUILT AT THE BEGINNING OF FREE STORAGE, AND THE
     16					; FINDSYM ROUTINE IS CALLED TO LOCATE THE SYMBOL BLOCK IN THE SYMBOL
     17					; TABLE.  IF THE SYMBOL IS NOT DEFINED IT IS ENTERED INTO THE SYMBOL
     18					; TABLE.  IF IT IS DEFINED, ITS TOKEN TYPE IS RETURNED IN R0 AND A
     19					; POINTER TO THE SYMBOL BLOCK IS RETURNED IN VAL1.
     20					;
     21					;
     22					;
     23					; LOOK FOR SYMBOL IN APPROPRIATE TABLE.  IF WE ARE IN OPERAND FIELD,
     24					; LOOK ONLY FOR A REGISTER OR USER DEFINED SYMBOL.  IF IN OPCODE FIELD,
     25					; WE MIGHT FIND EITHER A MACHINE INSTRUCTION OR A MACRO.
     26					;
     27					;--
     28	000000				SYMBOL:
     29
     30	000000				SAVRG						; SAVE R1 - R3
     31	000004				PUSH	R4					; SAVE R4 TOO
     32	000006				CALL GETSYM					; ACCUMULATE SYMBOL
     33	000012				PUSH	R2					; SAVE HASH VALUE
     34
     35	000014				IF BOL IS TRUE THEN				; POSSIBLY BEGINNING OF LINE?
     36	000022				    SPNOR					; SKIP OVER SPACES
     37	000026				    IF CHAR EQ #': THEN				; LABEL FOUND!
     38	000036					CALL CHKREG				; RETURN TOKEN TYPE IN R0
     39	000042				    ELSE
     40	000044					LET BOL	:= FALSE			; NO MORE LABELS!
     41	000050					IF CHAR EQ #'= THEN			; ASSIGNMENT?
     42	000060					    CALL CHKREG				; RETURN TOKEN TYPE IN R0
     43	000064					    IF R0 EQ #ID THEN LET OPRND := TRUE	; NOW IN OPERAND FIELD
     44	000100					ELSE
     45	000102					    GOTO OPRCHK				; IT MIGHT BE MACRO!
     46	000104					END
     47	000104				    END
     48	000104				ELSE
     49	000106				OPRCHK:
     50	000106				    IF OPRND IS TRUE THEN			; IN OPERAND FIELD!
     51	000114					CALL CHKREG				; RETURN TOKEN TYPE IN R0
     52	000120				    ELSE
     53	000122					LET INSERT	:= FALSE		; DON'T INSERT SYMBOL
     54	000126					LET R2		:= (SP) + #MACNAM	; LOOK IN MACRO NAME TABLE
     55	000134					CALL FINDSYM				; LOOK FOR IT
     56	000140					IF R2 IS EQ THEN			; NOT FOUND
     57	000144					    LET R2	:= (SP) + #HASHP	; LOOK IN OPCODE/DIRECTIVE TABLE
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 32-1
SYMBOL		LOOK UP SYMBOL

     58	000152					    CALL FINDSYM			; LOOK UP SYMBOL
     59	000156					    IF R2 IS EQ THEN			; NOT FOUND?!?
     60	000162						CALL	IMCALL			; IMPLICIT .MCALL
     61	000166					    ELSE
     62	000170						LET R0	:= SYMFLAGS(R2) OFF.BY #^CS.TKMSK ; SYMBOL TYPE
     63	000200						LET OPRND := TRUE		; NOW IN OPERAND FIELD
     64	000206					    END
     65	000206					ELSE
     66	000210					    LET R0	:= #MACTXT		; IT'S A MACRO!!!
     67	000214					END
     68	000214				    END
     69	000214				END
     70	000214				LET VAL1	:= R2				; POINT TO SYMBOL BLOCK
     71	000220				LET VAL2	:= 0
     72
     73	000224				POP	R2					; POP HASH VALUE OFF STACK
     74	000226				POP	R4					; RESTORE R4
     75	000230				RETURN						; RESTORE R3 - R1
     76
     77					;++
     78					;  THIS ROUTINE CHECKS TO SEE IF THE SYMBOL PICKED UP BY "GETSYM" IS A REGISTER
     79					;  NAME, AND, IF NOT, THEN SEARCHES FOR IT IN THE USER'S SYMBOL TABLE.  IF
     80					;  THE SYMBOL IS NOT IN THE USER'S SYMBOL TABLE IT IS INSERTED, IN ANY CASE
     81					;  THE TOKEN VALUE IS EITHER "#ID" OR "#RRREG".
     82					;--
     83
     84	000232				CHKREG:
     85	000232					CALL REGIS				; SEE IF SYMBOL IS A REG. NAME
     86	000236					IF R0 IS EQ THEN			; IF REGISTER EXIT
     87	000242	016602 	000002 			    MOV	2(SP),R2			; GET HASH TABLE OFFSET
     88	000246					    CALL INSUST				; INSERT SYMBOL IN USER SYMBOL TABLE
     89	000252					    LET R0	:= #ID			; RESULT ALWAYS ID.
     90	000256					END
     91	000256					RETURN					;
     92
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 33
SYMNUM		"A - F" CAN START SYMBOL OR NUMBER

     94					.SBTTL	SYMNUM		"A - F" CAN START SYMBOL OR NUMBER
     95					;+
     96					; SYMNUM - CHECK IF SYMBOL OR NUMBER
     97					;-
     98
     99	000260				SYMNUM::				;
    100	000260	022767 	001040'	000000G		CMP	#HEXNUM,RDXPTR		;RADIX POINTER SPECIFIY HEX?
    101	000266	001435 				BEQ	NUMBER			;IF EQ YES
    102	000270	122767 	000102 	000000G		CMPB	#'B,CHAR		;COULD SYMBOL BE A "B^"?
    103	000276	001240 				BNE	SYMBOL			;IF NE NO
    104
    105					.SBTTL	XSYMBL		NEXT CHARACTER CAN BE '^'
    106					;++
    107					;
    108					; CHECK IF NEXT SYMBOL IS A "^". IF YES THEN THIS IS A WIDTH
    109					; INDICATOR.
    110					;
    111					;--
    112	000300				XSYMBL:	;(DBG)
    113
    114	000300					IF NEXTCH EQ #'^ THEN			; NEXT CHAR A '^'?
    115	000310					    LET R1	:= #UPTAB		; POINT TO CHAR TABLE
    116	000314					    LET R0	:= CHAR			; GET CURRENT CHAR
    117	000320					    REPEAT				; ONCE PER TABLE ENTRY
    118	000320						IFB R0 EQ (R1) THEN		; MATCH CHAR?
    119	000324						    CALL GETCHR			; SCAN OVER THE CHAR
    120	000330						    CALL GETCHR			; SCAN OVER '^'
    121	000334						    LET R0 := R1 - #UPTAB L.SHIFT 1 + #UPTOK ; GET VALUE
    122	000350						    LET R0 := (R0)		; PICK UP TOKEN VALUE
    123	000352						    RETURN			; AND EXIT
    124	000354						END
    125	000354					    UNTILB (R1)+ IS EQ			; TILL END OF TABLE
    126	000360					END
    127	000360	000607 				BR	SYMBOL				; CALL SYMBOL AND RETURN
    128
    129					.SBTTL	NUMBER		ACCUMULATE NUMBER
    130					;++
    131					;
    132					; THIS ROUTINE CALLS THE ROUTINE POINTED TO BY "RDXPTR".  THE POINTER
    133					; IS LOADED BY ONE OF THE RADIX MODIFYING ROUTINES CALLED BY "XUPARROW".
    134					;
    135					;--
    136	000362				NUMBER:
    137	000362	000177 	000000G			JMP	@RDXPTR				; GO GET NUMBER AND RETURN
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 34
DNUMBER		ACCUMULATE DECIMAL NUMBER

    139					.SBTTL	DNUMBER		ACCUMULATE DECIMAL NUMBER
    140					;
    141					;	DNUMBER -- ACCUMULATE DECIMAL NUMBER
    142					;
    143					; FIRST DIGIT IS IN CHAR.  RESULT RETURNED IN VAL1,VAL2,VAL3,VAL4.
    144					; TOKEN TYPE (DINTEGER) RETURNED IN R0.
    145					;
    146	000366				PROCEDURE	DNUMBER
    147
    148	000366				SAVRG						; SAVE R1 - R3
    149	000372				LET R2		:= #VAL4+2			; SET POINTER PAST BLK
    150	000376				LET -(R2)	:= #0				; ZERO BITS <63 - 48>
    151	000400				LET -(R2)	:= #0				; ZERO BITS <47 - 32>
    152	000402				LET -(R2)	:= #0				; ZERO BITS <31 - 16>
    153	000404				LET -(R2)	:= CHAR			; STORE FIRST DIGIT
    154	000410				LET (R2)	:= (R2) - #'0			; CONVERT TO BINARY
    155
    156	000414				REPEAT
    157	000414				    CALL GETCHR					; GET NEXT DIGIT
    158	000420				    LET R0	:= R0 - #'0			; CONVERT CHAR TO BINARY
    159	000424				    IF R0 GE #0 AND R0 LE #9. THEN		; DIGIT IN RANGE?
    160	000436					PUSH	R0				; YES, SAVE BINARY VALUE
    161	000440	005046 				CLR	-(SP)				; START LOOP WITH 0
    162	000442					LET R2	:= #VAL1			; START R2 AT VALUE 1
    163	000446					REPEAT THRU R3 := #4			; LOOP FOUR TIMES
    164	000452	011200 				    MOV	(R2),R0				; LOAD PRESENT VALUE
    165	000454	005046 				    CLR	-(SP)				; STORE FLAG ON STACK
    166	000456	006300 				    ASL	R0				; GET BIT 15 INTO "C"
    167	000460	005516 				    ADC	(SP)				; PUT FLAG ON STACK
    168	000462	006000 				    ROR	R0				; RESTORE MULTIPLICAND
    169	000464	070027 	000012 			    MUL	#10.,R0				; MULTIPLY BY TEN
    170	000470	010112 				    MOV	R1,(R2)				; SAVE LOWER PRODUCT
    171	000472	005726 				    TST	(SP)+				; CHECK SIGN FLAG
    172	000474	001402 				    BEQ	1$				; SKIP IF FLAG ZERO
    173	000476	062700 	000005 			    ADD	#5,R0				; ADD CONSTANT TO UPPER
    174	000502	062622 				1$: ADD	(SP)+,(R2)+			; ADD CARRY FROM LAST TIME
    175	000504					    PUSH R0				; SAVE CARRY FOR NEXT TIME
    176	000506					END
    177	000510					POP	R0				; GET LAST CARRY OFF STK
    178	000512	012702 	000000G			MOV	#VAL1,R2			; LOAD ADDRESS OF "VAL1"
    179	000516	062622 				ADD	(SP)+,(R2)+			; ADD IN NEW CHARACTER
    180	000520	005522 				ADC	(R2)+				; PROPAGATE CARRY
    181	000522	005522 				ADC	(R2)+				;
    182	000524	005522 				ADC	(R2)+				;
    183	000526				    ELSE					; NUMBER OUT OF RANGE
    184	000530					LEAVE					; SO WE'RE FINISHED
    185	000532				    END
    186	000532				END
    187
    188	000534				LET R0		:= #DINTEGER			; RESULT IS INTEGER
    189	000540				IF CHAR EQ #'$ THEN				; POSSIBLY LOCAL LABEL?
    190	000550				    PUSH	R4
    191	000552				    CALL GETCHR					; SCAN PAST $
    192	000556				    LET R1	:= FREEPT			; IF SO, LOOK IN SYMBOL TABLE
    193	000562				    LET OFREE	:= R1				; BUILD SYMBOL BLOCK
    194	000566				    REPEAT THRU R0 := #SYMCHRS/2		; ZERO OUT SYMBOL HEADER
    195	000572					LET (R1)+ := 0
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 34-1
DNUMBER		ACCUMULATE DECIMAL NUMBER

    196	000574				    END
    197	000576				    LET R0	:= FREEPT			; POINT TO SYMBOL BLOCK
    198	000602				    LET SYMSEG(R0) :B= PSTNUM			; SAVE PSECT NUMBER
    199	000610				    LET SYMLEN(R0) :B= #4			; LENGTH OF NAME
    200	000616				    LET SYMFLAGS(R0) := SYMFLAGS(R0) SET.BY #S.LOCL ; MARK AS LOCAL SYMBOL
    201	000624				    LET (R1)+	:= LSB				; FIRST WORD OF NAME IS LSB
    202	000630				    LET (R1)+	:= VAL1				; SECOND IS VALUE OF NUMBER
    203	000634				    LET R2	:= VAL1 + LSB L.SHIFT 1 OFF.BY #^O177700 ; GET OFFSET INTO HASH TABLE
    204	000652				    LET VAL1	:= R0				; POINT TO SYMBOL BLOCK
    205	000656				    LET R3	:= R1				; POINT PAST SYMBOL BLOCK
    206	000660				    LET R1	:= #4				; NUMBER OF CHARS IN NAME
    207	000664				    CALL INSUST					; INSERT SYMBOL IN USER SYMBOL TABLE
    208	000670				    SPNOR					; SKIP OVER SPACES IN LINE
    209	000674				    IF CHAR EQ #'= THEN LET OPRND := TRUE	; ASSIGNMENT OF LOCAL SYMBOL
    210	000712				    LET R0	:= #ID				; TOKEN TYPE IS ID
    211	000716				    LET VAL1	:= R2				; VALUE IS PTR TO SYMBOL
    212	000722				    LET VAL2	:= 0
    213	000726				    POP	R4
    214	000730				ELSE
    215	000732				    IF CHAR EQ #'. THEN
    216	000742					CALL GETCHR				; SCAN PAST .
    217	000746					LET R0	:= #DINTEGER			; NUMBER STAYS DECIMAL
    218	000752				    END
    219	000752				END
    220
    221	000752				ENDPROCEDURE	DNUMBER
    222
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 35
BINNUM		BINARY NUMBER ROUTINE

    224					.SBTTL	BINNUM		BINARY NUMBER ROUTINE
    225
    226	000754				BINNUM::
    227	000754					SAVRG				; SAVE R1 - R3
    228	000760					CALL	PNUMBER <#0,#0,#1,#'1>
    229	001004					RETURN				; RETURN RESTORES REGISTERS
    230
    231
    232					.SBTTL	OCTNUM		OCTAL NUMBER ROUTINE
    233
    234	001006				OCTNUM::
    235	001006					SAVRG				; SAVE R1 - R3
    236	001012					CALL	PNUMBER <#0,#0,#3,#'7>
    237	001036					RETURN				; RETURN RESTORES REGISTERS
    238
    239
    240					.SBTTL	HEXNUM		HEXIDECIMAL NUMBER ROUTINE
    241
    242	001040				HEXNUM::
    243	001040					SAVRG				; SAVE R1 - R3
    244	001044					CALL	PNUMBER <#0,#0,#4,#'F>
    245	001070					RETURN				; RETURN RESTORES REGISTERS
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 36
PNUMBER		ACCUMULATE NUMBER - RADIX 2**N

    247					.SBTTL	PNUMBER		ACCUMULATE NUMBER - RADIX 2**N
    248					;
    249					;
    250					;	PNUMBER -- ACCUMULATE NUMBER OF EVEN RADIX
    251					;
    252					; CALLING PARAMETERS:
    253					;	R1 - 0
    254					;	R2 - LOG(2) OF RADIX
    255					;	R3 - UPPER CHARACTER BOUND
    256					;
    257					; RESULT RETURNED IN VAL1,VAL2,VAL3,VAL4 WITH TOKEN TYPE IN R0.
    258					;
    259	001072				PROCEDURE	PNUMBER
    260
    261	001072				LET VAL1	:= 0				; INITIALIZE RESULT
    262	001076				LET VAL2	:= 0
    263	001102				LET VAL3	:= 0
    264	001106				LET VAL4	:= 0
    265
    266	001112				REPEAT
    267	001112				    LET R0	:= CHAR				; GET NEXT DIGIT
    268	001116				    IF R0 LT #'0 OR R0 GT R3 THEN
    269	001130					LEAVE					; DIGIT OUT OF RANGE
    270	001132				    END
    271	001132				    IF R0 GT #'9 AND R0 LT #'A THEN
    272	001146					LEAVE					; ILLEGAL HEX CHAR.
    273	001150				    ELSE
    274	001152					IF R0 GE #'A THEN			; HEX ALPHA CHARACTER
    275	001160					    LET R0 := R0 - #7			; DIFF BETWEEN 9 AND A
    276	001164					END
    277	001164				    END
    278
    279	001164				    LET R0	:= R0 - #'0			; CONVERT DIGIT TO BINARY
    280	001170				    PUSH	R2				; SAVE SHIFT COUNT
    281	001172				10$:
    282	001172	006367 	000000G		    ASL		VAL1				; MULTIPLY BY TWO
    283	001176	006167 	000000G		    ROL		VAL2
    284	001202	006167 	000000G		    ROL		VAL3
    285	001206	006167 	000000G		    ROL		VAL4
    286	001212	077211 			    SOB		R2,10$
    287	001214				    POP		R2				; RESTORE SHIFT COUNT
    288	001216				    LET VAL1	:= VAL1 + R0			; ADD NEW DIGIT
    289	001222	005567 	000000G		    ADC		VAL2				; PLUS CARRY
    290	001226	005567 	000000G		    ADC		VAL3
    291	001232	005567 	000000G		    ADC		VAL4
    292	001236				    CALL GETCHR					; GET NEXT CHARACTER
    293	001242				END
    294
    295	001244				LET R0		:= #DINTEGER			; RESULT IS INTEGER TOKEN
    296
    297	001250				ENDPROCEDURE	PNUMBER
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 37
SYMSCN		SCAN FOR SYMBOL NAME

    299					.SBTTL	SYMSCN		SCAN FOR SYMBOL NAME
    300					;++
    301					;
    302					; THIS ROUTINE IS CALLED BY SEVERAL DIRECTIVES TO SCAN A
    303					; NAME FROM THE INPUT LINE.  LEADING SPACES AND TABS ARE
    304					; IGNORED.  THE REGISTERS ARE TRASHED.  (IN FACT, THEY ARE
    305					; SET UP BY THE GETSYM ROUTINE)  IF NO SYMBOL WAS FOUND, R3
    306					; IS SET TO ZERO.
    307					;
    308					;--
    309	001252				SYMSCN:
    310	001252					SPNOR				;IGNORE LEADING BLANKS
    311	001256	016000 	000000G			MOV	CHRTAB(R0),R0		;GET CHARACTER "TOKEN"
    312	001262	022700 	000000'			CMP	#SYMBOL,R0		;SYMBOL?
    313	001266	001410 				BEQ	GETSYM			;IF EQ YES
    314	001270	022700 	000300'			CMP	#XSYMBL,R0		;SYMBOL OR NUMBER?
    315	001274	001405 				BEQ	GETSYM			;IF EQ YES
    316	001276	022700 	000260'			CMP	#SYMNUM,R0		;SYMBOL OR NUMBER?
    317	001302	001402 				BEQ	GETSYM			;IF EQ YES
    318	001304	005003 				CLR	R3			;INDICATE NOT FOUND
    319	001306					RETURN				;
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 38
GETSYM		ACCUMULATE SYMBOL BLOCK

    321					.SBTTL	GETSYM		ACCUMULATE SYMBOL BLOCK
    322					;++
    323					; THIS PROCEDURE SCANS THE INPUT STREAM AND BUILDS A SYMBOL BLOCK
    324					; AT THE END OF FREE STORAGE.  THE REGISTERS ARE SET UP FOR THE
    325					; FINDSYM ROUTINE.  SINCE THIS ROUTINE PRESERVES NO REGISTERS, IT
    326					; IS UP TO THE CALLER TO SAVE IMPORTANT REGISTERS.
    327					; RETURN PARAMETERS:
    328					; R1 = LENGTH OF SYMBOL IN BYTES.
    329					; R2 = HASH VALUE FOR SYMBOL ACCUMULATED.
    330					; R3 = POINTER TO WORD AFTER SYMBOL BLOCK
    331					;--
    332	001310				GETSYM:
    333
    334	001310					CALL		SYMFUL			; CHECK FOR SYMBOL TABLE OVERFLOW
    335	001314					LET R1		:= FREEPT		; START OF FREE STORAGE
    336	001320					LET OFREE	:= R1			; OLD VALUE OF FREEPT
    337	001324					LET VAL1	:= R1			; RESULT POINTER
    338	001330	010100 				MOV	R1,R0			;COPY ADDRESS OF FREE STORAGE
    339		000005 				.REPT	SYMCHRS/2
    340						CLR	(R1)+			;CLEAR SYMBOL STORAGE
    341						.ENDR
    342	001344					LET SYMSEG(R0)	:B= PSTNUM		; FILL IN PSECT NUMBER
    343	001352					LET R3		:= R1			; POINT PAST HEADER
    344	001354					LET (R1)+	:B= CHAR		; STORE FIRST CHAR
    345	001360					REPEAT					; ACCUMULATE REST OF SYMBOL
    346	001360					    LET CHAR	:= MCASCI		; CHAR WILL BE -1
    347											; IF NOT .ASCIX IN MACRO
    348											; OR 0 IF TRUE TO GET
    349											; ALL CHARACTERS
    350	001366					    CALL GETCHR				; GET NEXT CHAR
    351	001372					    LET R0	:= R0 L.SHIFT 1		; WORD TABLE CONVERSION
    352	001374					    LET R0	:= CHRTAB(R0)		; GET "TOKEN" FOR CHARACTER
    353	001400					    IF R0 EQ #SYMBOL OR R0 EQ #NUMBER OR R0 EQ #XSYMBL OR R0 EQ #SYMNUM THEN
    354	001430						LET (R1)+ :B= CHAR		; STORE CHARACTER IN NAME
    355	001434					    ELSE
    356	001436						LEAVE				; END OF SYMBOL FOUND
    357	001440					    END
    358	001440					END
    359	001442					LET R1		:= R1 - R3		; GET SYMBOL LENGTH
    360	001444					IF R1 GT #SYMMAX THEN			; IS SYMBOL TOO LONG?
    361	001452					    LET R1	:= #SYMMAX		; TRUNCATE SYMBOL
    362	001456					    IF MCLVL IS EQ THEN			; NOT IN MACRO DEFINITION
    363	001464						OUT #I.WRN,<#ILSYLN,LINEPT>	; SYMBOL EXCEEDS MAX LENGTH
    364	001504					    END;IF
    365	001504					END;IF
    366	001504					LET -(R3)	:B= R1			; PUT LENGTH INTO HEADER
    367	001506	112302 				MOVB	(R3)+,R2		;RETREIVE LENGTH OF SYMBOL
    368	001510	010100 				MOV	R1,R0			;SET LOOP COUNT
    369	001512	112304 			10$:	MOVB	(R3)+,R4		;GET NEXT SYMBOL CHARACTER
    370	001514	060402 				ADD	R4,R2			;ACCUMULATE HASH INDEX
    371	001516	077003 				SOB	R0,10$			;ANY MORE CHARACTERS TO ADD IN?
    372	001520	042702 	177700 			BIC	#^C<77>,R2		;CLEAR ALL BUT INDEX TO HASH TABLE
    373	001524	006302 				ASL	R2			;CONVERT TO WORD INDEX
    374	001526					IF #1 SET.IN R3 THEN			; RETURN PTR. PAST SYM BLK
    375	001534					    LET (R3)+	:B= 0			; ALIGN TO WORD BOUND
    376	001536					END
    377	001536					RETURN
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 39
REGIS		SCAN FOR REGISTER NAME

    379					.SBTTL	REGIS		SCAN FOR REGISTER NAME
    380					;++
    381					;
    382					; RATHER THAN TAKE TIME LOOKING IN A SPECIAL SYMBOL TABLE, THIS ROUTINE
    383					; USES A BRUTE FORCE METHOD TO DETERMINE IF A SYMBOL IS A REGISTER NAME.
    384					; THE NAME IS ENCODED IN A SYMBOL BLOCK BY THE 'SYMBOL' ROUTINE.  THIS
    385					; MAY SEEM INEFFICIENT, BUT ANY SINGLE PATH THROUGH THIS ROUTINE IS
    386					; SHORT, AND SINCE MANY IF NOT MOST OPERANDS ARE LIKELY TO BE REGISTER
    387					; NAMES, THIS ROUTINE SHOULD SPEED THINGS UP.
    388					;
    389					;--
    390	001540				REGIS:
    391
    392	001540				PUSH	R1
    393	001542				LET R2	:= VAL1					; POINT TO SYMBOL BLOCK
    394	001546				LET R1	:= SYMCHRS(R2)				; GET FIRST 2 CHARS
    395	001552				LET R0	:= #RRREG				; REGISTER TOKEN TYPE
    396
    397	001556				IFB SYMLEN(R2) EQ #2 THEN			; 2 CHARACTER NAME?
    398	001566	000301 			    SWAB R1					; CONVERT FOR CHECK
    399	001570				    IF R1 GE #"0R AND R1 LE #"9R THEN		; EASY REGISTER?
    400	001604					LET R2	:B= SYMCHRS+1(R2) - #'0		; GET REGISTER NUMBER
    401	001614				    ELSE
    402	001616	000301 				SWAB R1					; CONVERT BACK
    403	001620					IF R1 EQ #"AP THEN			; ARGUMENT POINTER
    404	001626					    LET R2 := #12.
    405	001632					ELSE
    406	001634					    IF R1 EQ #"SP THEN			; STACK POINTER
    407	001642						LET R2 := #14.
    408	001646					    ELSE
    409	001650						IF R1 EQ #"PC THEN		; PROGRAM COUNTER
    410	001656						    LET R2 := #15.
    411	001662						ELSE
    412	001664						    IF R1 EQ #"FP THEN		; FRAME POINTER
    413	001672							LET R2 := #13.
    414	001676						    ELSE
    415	001700							LET R0 := #DMASK	; ENTRY MASK?
    416	001704							IF R1 EQ #"IV THEN	; INTEGER OVERFLOW
    417	001712							    LET R2 := #14.	; BIT 14
    418	001716							ELSE
    419	001720							    IF R1 EQ #"DV THEN	; DECIMAL OVERFLOW
    420	001726								LET R2 := #15.	; BIT 15
    421	001732							    ELSE
    422	001734								LET R0 := 0		; NOT A REGISTER
    423	001736							    END
    424	001736							END
    425	001736						    END
    426	001736						END
    427	001736					    END
    428	001736					END
    429	001736				    END
    430	001736				ELSE
    431	001740				    IFB SYMLEN(R2) EQ #3 AND R1 EQ #"R1 THEN
    432	001756					LET R2 :B= SYMCHRS+2(R2) - #'0		; CONVRT 3RD CHAR TO BIN
    433	001766					IF RESULT IS GE AND R2 LOS #2 THEN	; NUMBER IN RANGE
    434	001776					    LET R2 := R2 + #10.			; CONVERT TO REG NUMBER
    435	002002					ELSE
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 39-1
REGIS		SCAN FOR REGISTER NAME

    436	002004					    LET R0 := 0				; NOT REGISTER
    437	002006					END
    438	002006				    ELSE
    439	002010					IFB SYMLEN(R2) EQ #1 AND R1 EQ #'. THEN
    440	002026					    LET R0	:= #DPC			; CURRENT PC (DOT)
    441	002032					ELSE
    442	002034					    LET R0	:= 0			; NOT REGISTER
    443	002036					END
    444	002036				    END
    445	002036				END
    446	002036				POP	R1					; RESTORE R1
    447	002040				RETURN
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 40
XUPARROW	ROUTINE TO CHECK CHARACTER AFTER '^'

    449					.SBTTL	XUPARROW	ROUTINE TO CHECK CHARACTER AFTER '^'
    450					;++
    451					;
    452					; THIS ROUTINE LOADS "R0" WITH THE TOKEN TYPE CORRESPONDING TO THE
    453					; CHARACTER FOLLOWING THE '^'.  IF THE CHARACTER IS NOT IN THE TABLE
    454					; "CHRERR" IS CALLED, WHICH JUMPS BACK TO "TOKEN".
    455					;
    456					;--
    457	002042				XUPARROW:
    458
    459	002042					CALL GETCHR				; PICK UP NEXT CHARACTER
    460	002046					LET R1 := #CTAB				; POINT TO CHARACTER TABLE
    461	002052					REPEAT
    462	002052					    IFB R0 EQ (R1) THEN			; DOES CHARACTER MATCH?
    463	002056						CALL GETCHR			; YES, GET FIRST REAL CHAR.
    464	002062						LET R0 := R1 - #CTAB L.SHIFT 1 + #RTAB ; POINT TO TOKEN TYPE
    465	002076						LET R0 := (R0)			; GET TOKEN TYPE
    466	002100						RETURN
    467	002102					    END;IF
    468	002102					UNTILB (R1)+ IS EQ
    469	002106					JUMPTO CHRERR				; SIGNAL ERROR
    470					;	RETURN
    471
    472
    473					.SBTTL	XPOUND		POUND SIGN DETECTED
    474					;++
    475					;
    476					; THIS ROUTINE LOADS "RDXPTR" BASED ON THE OPCODE TYPE FOUND IN "MOPPTR"
    477					;
    478					;--
    479	002112				XPOUND:						; CHECK FOR FLOATING POINT OPERAND TYPE
    480
    481	002112					IFB @MOPPTR IS LT THEN			; FLOATING ARG?
    482	002120					    LET RDXPTR	:= #FLTPNT		; YES
    483	002126					ELSE
    484	002130					    LET RDXPTR	:= #DNUMBER		; ELSE DECIMAL
    485	002136					END
    486	002136					CALL GETCHR				; READ NEXT CHAR
    487	002142					LET R0		:= #DPOUND		; TOKEN VALUE
    488	002146					RETURN					;
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 41
FINDSYM		LOOKUP SYMBOL IN SYMBOL TABLE

    490					.SBTTL	FINDSYM		LOOKUP SYMBOL IN SYMBOL TABLE
    491					;++
    492					; CALLING PARAMETERS:
    493					;
    494					;	R1 = LENGTH OF NAME
    495					;	R2 = POINTER TO HASH TABLE ENTRY
    496					;	R3 = POINTER PAST END OF SYMBOL BLOCK
    497					;	VAL1 = POINTER TO START OF SYMBOL BLOCK
    498					;	INSERT = TRUE IF SYMBOL SHOULD BE INSERTED INTO TABLE
    499					;
    500					; RETURNED PARAMETERS:
    501					;
    502					;	R2 = POINTER TO SYMBOL BLOCK OR 0 IF NOT FOUND
    503					; 	SYMLNK = POINTER TO PREVIOUS LINK IN CHAIN
    504					;--
    505
    506	002150				FINDPSECT::					; ENTRY POINT FOR FINDING PSECTS
    507	002150	012700 	000020 			MOV	#PSECCH,R0			; OFFSET TO PSECT NAME IN BLOCK
    508	002154	000402 				BR	FINDCOM				; GO TO LOOKUP ROUTINE
    509	002156				FINDSYM::					; ENTRY POINT FOR FINDING SYMBOL
    510	002156	012700 	000012 			MOV	#SYMCHRS,R0			; OFFSET TO SYMBOL NAME IN BLOCK
    511	002162				FINDCOM:
    512	002162	010546 				MOV	R5,-(SP)		;SAVE REGISTER
    513	002164	016704 	000000G			MOV	VAL1,R4			;GET ADDRESS OF NEW SYMBOL
    514	002170	010346 				MOV	R3,-(SP)		;SAVE REGISTERS
    515	002172	010146 				MOV	R1,-(SP)		;
    516	002174	010267 	000000G		10$:	MOV	R2,SYMLNK		;SAVE ADDRESS OF PREVIOUS SYMBOL
    517	002200	011202 				MOV	(R2),R2			;GET ADDRESS OF NEXT SYMBOL
    518	002202	001442 				BEQ	20$			;IF EQ END OF LIST
    519	002204	121662 	000011 			CMPB	(SP),SYMLEN(R2)		;SYMBOLS HAVE SAME LENGTH?
    520	002210	001371 				BNE	10$			;IF NE NO
    521	002212	111605 				MOVB	(SP),R5			;GET SYMBOL LENGTH
    522	002214	010201 				MOV	R2,R1			;COPY ADDRESS OF NEXT SYMBOL
    523	002216	010403 				MOV	R4,R3			;COPY ADDRESS OF NEW SYMBOL
    524	002220	060001 				ADD	R0,R1			;POINT TO NEXT SYMBOL NAME
    525	002222	060003 				ADD	R0,R3			;POINT TO NEW SYMBOL NAME
    526	002224	005205 				INC	R5			;ROUND LENGTH OF SYMBOL TO EVEN NUMBER
    527	002226	042705 	000001 			BIC	#1,R5			;TRUNCATE RESIDUE
    528	002232	005405 				NEG	R5			;NEGATE ROUNDED LENGTH
    529	002234	062705 	000020 			ADD	#16.,R5			;COMPUTE COMPLEMENT BASE 16.
    530	002240	006305 				ASL	R5			;COMPUTE DISPATCH OFFSET
    531	002242	060507 				ADD	R5,PC			;DISPATCH TO PROPER STARTING PLACE
    532		000010 				.REPT	8.
    533						CMP	(R3)+,(R1)+		;COMPARE SYMBOLS
    534						BNE	10$			;IF NE NO MATCH
    535						.ENDR
    536	002304	012601 				MOV	(SP)+,R1		;RESTORE REGISTERS
    537	002306	000526 				BR	FOUND			;EXIT VIA FOUND SYMBOL EXIT
    538	002310	012601 			20$:	MOV	(SP)+,R1		;RESTORE REGISTERS
    539	002312	000502 				BR	NOTFND			;EXIT VIA NOT FOUND SYMBOL EXIT
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 42
USER SYMBOL TABLE SEARCH AND INSERT ROUTINES

    541					.SBTTL			USER SYMBOL TABLE SEARCH AND INSERT ROUTINES
    542					;++
    543					; CALLING PARAMETERS:
    544					;
    545					;	R1 = LENGTH OF NAME
    546					;	R2 = OFFSET INTO USER HASH TABLE
    547					;	R3 = POINTER PAST END OF SYMBOL BLOCK
    548					;	VAL1 = POINTER TO START OF SYMBOL BLOCK
    549					;
    550					; RETURNED PARAMETERS:
    551					;
    552					;	R2 = POINTER TO SYMBOL BLOCK OR 0 IF NOT FOUND
    553					; 	SYMLNK = POINTER TO PREVIOUS LINK IN CHAIN
    554					;--
    555
    556						.ENABL	LSB
    557	002314				INSUST::				;INSERT IN USER SYMBOL TABLE
    558	002314	010667 	000000G			MOV	SP,INSERT		;SET INSERT FLAG TRUE
    559	002320	000402 				BR	10$			;
    560	002322				SRCUST::				;SEARCH USER SYMBOL TABLE
    561	002322	005067 	000000G			CLR	INSERT			;SET INSERT FLAG FALSE
    562	002326	062702 	000000G		10$:	ADD	#IDENTB,R2		;POINT TO PROPER HASH BUCKET
    563	002332	010546 				MOV	R5,-(SP)		;SAVE REGISTER
    564	002334	016704 	000000G			MOV	VAL1,R4			;GET ADDRESS OF NEW SYMBOL
    565	002340	010346 				MOV	R3,-(SP)		;SAVE REGISTER
    566	002342	010267 	000000G		20$:	MOV	R2,SYMLNK		;SAVE ADDRESS OF PREVIOUS SYMBOL
    567	002346	011202 				MOV	(R2),R2			;GET ADDRESS OF NEXT SYMBOL
    568	002350	001463 				BEQ	NOTFND			;IF EQ END OF LIST
    569	002352	012700 	000012 			MOV	#SYMCHRS,R0		;GET OFFSET TO SYMBOL NAME
    570	002356	010403 				MOV	R4,R3			;COPY ADDRESS OF NEW SYMBOL
    571	002360	060003 				ADD	R0,R3			;POINT TO SYMBOL NAME
    572	002362	060200 				ADD	R2,R0			;POINT TO SYMBOL NAME
    573	002364	110105 				MOVB	R1,R5			;ASSUME NEW SYMBOL HAS SHORTER LENGTH
    574	002366	120562 	000011 			CMPB	R5,SYMLEN(R2)		;NEW SYMBOL HAVE SHORTER LENGTH?
    575	002372	101402 				BLOS	30$			;IF LOS YES
    576	002374	116205 	000011 			MOVB	SYMLEN(R2),R5		;GET LENGTH OF CURRENT SYMBOL
    577	002400	005405 			30$:	NEG	R5			;NEGATE LENGTH OF SYMBOL
    578	002402	062705 	000017 			ADD	#15.,R5			;COMPUTE COMPLEMENT BASE 15.
    579	002406	072527 	000002 			ASH	#2,R5			;MULTIPLY BE 4
    580	002412	060507 				ADD	R5,PC			;DISPATCH TO PROPER ROUTINE
    581		000017 				.REPT	15.
    582						CMPB	(R3)+,(R0)+		;COMPARE SYMBOLS
    583						BNE	40$			;IF NE NO MATCH
    584						.ENDR
    585	002510	120162 	000011 			CMPB	R1,SYMLEN(R2)		;NEW SYMBOL SHORTER?
    586	002514	101312 			40$:	BHI	20$			;IF HI CONTINUE SEARCH
    587	002516	001422 				BEQ	FOUND			;IF EQ SYMBOL MATCH
    588	002520	012603 			NOTFND:	MOV	(SP)+,R3		;SYMBOL NOT FOUND
    589	002522	012605 				MOV	(SP)+,R5		;
    590	002524	005002 				CLR	R2			;ASSUME INSERT IS NOT SPECIFIED
    591	002526	005767 	000000G			TST	INSERT			;INSERT SYMBOL IN TABLE?
    592	002532	001413 				BEQ	50$			;IF EQ NO
    593	002534					CALL	TUCK			;ALLOCATE SPACE FOR SYMBOL
    594	002540	016702 	000000G			MOV	SYMLNK,R2		;RETRIEVE ADDRESS OF SYMBOL TO INSERT AFTER
    595	002544	011277 	000000G			MOV	(R2),@VAL1		;SET LINK TO NEXT SYMBOL
    596	002550	016712 	000000G			MOV	VAL1,(R2)		;SET LINK TO NEW SYMBOL
    597	002554	010367 	000000G			MOV	R3,FREEPT		;ALLOCATE SYMBOL BLOCK
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 42-1
USER SYMBOL TABLE SEARCH AND INSERT ROUTINES

    598	002560	011202 				MOV	(R2),R2			;GET ADDRESS OF SYMBOL BLOCK
    599	002562				50$:	RETURN				;
    600	002564	012603 			FOUND:	MOV	(SP)+,R3		;
    601	002566	012605 				MOV	(SP)+,R5		;
    602	002570	052762 	000400 	000002 		BIS	#S.REF,SYMFLAG(R2)	;SET SYMBOL REFERENCED FLAG
    603	002576					RETURN				;
    604						.DSABL	LSB
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 43
TUCK		INSERT SYMBOL INTO TABLE

    606					.SBTTL	TUCK		INSERT SYMBOL INTO TABLE
    607					;++
    608					;
    609					; THIS PROCEDURE IS CALLED BY FINDSYM WHEN IT WANTS TO ALLOCATE A NEW
    610					; SYMBOL BLOCK.  THIS ROUTINE SCANS THE 'CORLST' LIST OF AVAILABLE
    611					; BLOCKS OF STORAGE TO FIND A HOLE IN WHICH IT CAN PUT THE SYMBOL.
    612					; THE SYMBOL IS THEN MOVED INTO THE HOLE, AND THE HOLE IS MADE
    613					; SMALLER.  IF NO HOLE LARGE ENOUGH IS FOUND, THE SYMBOL IS SIMPLY
    614					; ALLOCATED AT THE END OF CORE.
    615					;
    616					;--
    617	002600				TUCK:
    618
    619	002600				    LET R1		:= CORLST		; POINT TO FREE CORE LIST
    620	002604				    IF RESULT IS NE THEN			; FIND HOLE BIG ENOUGH
    621	002606					LET R0		:= R3 - FREEPT		; LENGTH OF SYMBOL
    622	002614					LET VAL2	:= #CORLST		; SAVE ADDRESS OF LIST HEAD
    623	002622					REPEAT					; ONCE PER HOLE
    624	002622					    IF 2(R1) HIS R0 THEN		; HOLE BIG ENOUGH?
    625	002630						PUSH	R2,R0			; SAVE REGISTERS
    626	002634						LET R0	:= 2(R1) + R1		; FIND UPPER LIMIT OF THIS HOLE
    627	002642						LET R2	:= INPUTP		; POINTER TO MACRO BODY
    628	002646						REPEAT			; THRU ALL MACRO LEVELS BEING EXPANDED
    629	002646						    IF M.NXTL(R2) HIS R1 AND M.NXTL(R2) LOS R0 THEN
    630	002662							GOTO NOTUCK		; EXIT IF NEXT LINE IN HOLE
    631	002664						    END
    632	002664						    LET R2	:= M.LINK(R2)	; CHECK NEXT LEVEL
    633	002670						UNTIL R2 EQ M.LINK(R2)		; REACHED LAST MACRO LEVEL
    634	002676						POP	R0,R2
    635	002702						LET R3	:= R1			; GET ADDRESS OF HOLE
    636	002704						LET 2(R1) := 2(R1) - R0		; CHANGE LENGTH OF HOLE
    637	002710						IF 2(R1) LE #2 THEN		; IS HOLE TOTALLY CONSUMED?
    638	002720						    LET @VAL2 := (R1)		; REMOVE BLOCK FROM CHAIN
    639	002724						ELSE				; MAKE HOLE SMALLER
    640	002726						    LET R1   := R1 + R0		; POINT TO UNUSED PART
    641	002730						    LET @VAL2 := R1		; UPDATE PREVIOUS POINTER
    642	002734						    LET (R1)+ := (R3)		; COPY FORWARD LINK
    643	002736						    LET (R1) := 2(R3)		; STORE NEW HOLE LENGTH
    644	002742						END
    645	002742						LET VAL1	:= R3		; SAVE ADDRESS OF SYMBOL BLOCK
    646	002746						LET R1	:= FREEPT		; POINT TO NAME
    647	002752						REPEAT THRU R0 := R0 R.SHIFT 1	; ONCE PER WORD IN SYMBOL
    648	002754						    LET (R3)+ := (R1)+		; COPY SYMBOL BLOCK
    649	002756						END
    650	002760						LET R3	:= FREEPT		; DON'T ALLOCATE NEW BLOCK
    651	002764						GOTO TUCKX			; EXIT ROUTINE
    652	002766				NOTUCK:		POP	R0,R2			; RESTORE REGISTER
    653	002772					    END
    654	002772					    LET VAL2	:= R1			; SAVE ADDRESS OF THIS BLOCK
    655	002776					    LET R1	:= (R1)			; POINT TO NEXT FREE BLOCK
    656	003000					UNTIL R1 IS EQ				; UNTIL END OF CHAIN
    657	003004				    END;IF
    658	003004				TUCKX:						; EXIT POINT
    659	003004				    RETURN					;
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 44
**********  MACRO, REPEAT, AND IF SCANNERS  **********

    661					.SBTTL	**********  MACRO, REPEAT, AND IF SCANNERS  **********
    662					.SBTTL	BDYSCN		SCAN MACRO BODY
    663
    664		000377 				MCARG == ^O377				; MACRO ARG MARKER
    665					;++
    666					;
    667					;
    668					; 'BDYSCN' COPIES THE TEXT OF THE MACRO INTO CORE REPLACING EACH
    669					; FORMAL ARGUMENT BY A SPECIAL MARK CONSISTING OF 'MCARG' FOLLOWED
    670					; BY THE NUMBER OF THE ARGUMENT.
    671					;
    672					; NOTE:  "LINEPT" IS POINTING TWO CHARACTERS AHEAD OF THE CHARACTER IN "CHAR".
    673					;
    674					;--
    675
    676	003006				BDYSCN:						; SCAN MACRO BODY, STORE TEXT INTO MEMORY
    677
    678	003006					LET MCLVL	:= #1			; FIRST MACRO DEF LEVEL
    679	003014					LET MCTXT	:= FREEPT		; POINT TO START OF MACRO TEXT
    680	003022					LET MCTXTL	:= FREEPT		; POINT TO START OF NEW LINE
    681	003030				BDYREP:						; REPEAT ONCE PER LINE
    682	003030					    LET MCASCI	:= #-1			; FLAG FOR GETSYM TO NOT GET ALL CHRS
    683	003036					    LET CHAR	:B= LINEBF		; GET ACTUAL FIRST CHARACTER
    684											; IN CASE IT WAS A ";"
    685	003044					    IF CHAR GE #'A+40 THEN
    686	003054						 LET CHAR :B= CHAR OFF.BY #^O40	; CONVERT LOWER TO UPPER
    687	003062					    END
    688	003062					    LET CONTLN	:= FALSE		; PROHIBIT LINE CONTINUATION
    689	003066					    LET MCTXTP	:= MCTXTL + #2		; RESERVE ROOM FOR LENGTH
    690	003102					    IF LS.MD+SYMVL2 IS EQ THEN		; LIST MACRO DEF?
    691	003110						OUT #I.FLAG,<#0,#LISTIT>	; NO!
    692	003130					    END
    693	003130					    LET MCINPE	:= #LINEBF+1 + LINELN	; POINT TO LINE'S END
    694	003144					    LET ENDMCH	:= TRUE			; CHECK IMPORTANT KEYWORDS
    695	003152					    REPEAT				; ONCE PER CHAR/WORD
    696	003152						IF LINEPT HI MCINPE THEN JUMPTO BDYEND	; REAL END OF LINE
    697	003166						LET R0	:= CHAR L.SHIFT 1	; CONVERT FOR WORD TABLE
    698	003174						LET R0	:= CHRTAB(R0)		; GET "TOKEN" FOR CHARACTER
    699	003200						IF R0 EQ #SYMBOL OR R0 EQ #XSYMBL OR R0 EQ #SYMNUM THEN
    700	003222						    LET MCINP := LINEPT - #2	; SAVE PTR TO SYMBOL NAME
    701	003236						    PUSH	FREEPT		; SAVE CORE POINTER
    702	003242						    LET FREEPT := MCTXTP +1 OFF.BY #1 ; ROUND UP
    703	003262						    CALL GETSYM			; ACCUMULATE SYMBOL NAME
    704	003266						    POP FREEPT			; RESTORE POINTER
    705	003272						    PUSH R1			; SAVE R1
    706	003274						    IF CHAR EQ #CR OR LINEPT HIS MCINPE THEN
    707	003314							LET R0	:= 0		; ALWAYS CHECK LAST WORD
    708	003316						    ELSE
    709	003320							LET R1 := LINEPT - #2	; POINT TO SYMBOL DELIMITER
    710	003330							REPEAT			; SCAN AHEAD PAST BLANKS
    711	003330							    LET R0 :B= (R1) L.SHIFT 1 ; SHIFT FOR WORD TABLE
    712	003334							    IF CHRTAB(R0) IS NE THEN LEAVE ; EXIT IF BLANK
    713	003342							    LET R1 := R1 +1	; POINT TO NEXT CHARACTER
    714	003344							END;R
    715	003346							LET R0	:B= (R1)	; GET NON-BLANK CHAR
    716	003350						    END;IF
    717	003350						    POP	R1
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 44-1
BDYSCN		SCAN MACRO BODY

    718	003352						    IF R0 NE #': THEN		; SYMBOL A LABEL?
    719	003360							IF ENDMCH IS TRUE	; CHECKING KEYWORDS?
    720	003366							    LET ENDMCH := FALSE	; NOT ANY LONGER
    721	003372							    LET MCSPLP := #SPLDIR ; POINT TO NAMES
    722	003400							    LET R2 := #MCSPLP	; POINT TO SPECIAL DIRECTIVES
    723	003404							    LET INSERT := FALSE	; DON'T ADD NEW SYMBOLS
    724	003410							    CALL FINDSYM	; LOOK FOR SPECIAL NAME
    725	003414							    IF R2 IS NE THEN	; IT WAS DIRECTIVE!
    726	003420								CALL @SYMVL1(R2) ; PROCESS THE DIRECTIVE
    727	003424								IF MCLVL IS LE THEN ; LAST .ENDM ?
    728	003432								    GOTO BDYEND	; EXIT BDYSCN
    729	003434								ELSE		;
    730	003436								    GOTO BDYSC1	; CONTINUE IF NOT
    731	003440								END		;
    732	003440							    END
    733	003440							END
    734	003440						    ELSE			; IT IS A LABEL
    735	003442							LET ENDMCH := TRUE	; ALLOW SEARCHING FOR DIRECTIVES
    736	003450						    END
    737	003450						    LET R2	:= #MCARGP	; POINT TO ARGUMENT NAMES
    738	003454						    LET INSERT	:= FALSE	; DON'T ADD NEW SYMBOL
    739	003460						    CALL FINDSYM		; CHECK IF IT IS AN ARG
    740	003464						    IF R2 IS NE THEN		; IT IS ARGUMENT
    741	003470							LET R0 := MCTXTP	; POINT TO OUTPUT LINE
    742	003474							IFB -1(R0) EQ #'' THEN	; CATENATION?
    743	003504							    LET R0 := R0 -1	; YES! BACK UP OVER '
    744	003506							END
    745	003506							LET (R0)+ :B= #MCARG	; MARK MACRO ARG
    746	003512							LET (R0)+ :B= SYMVL1(R2) ; FILL IN ARGUMENT NUMBER
    747	003516							LET MCTXTP := R0	; RESTORE OUTPUT POINTER
    748	003522							IF CHAR EQ #'' THEN	; CATENATION?
    749	003532							    CALL GETCHR		; YES! SKIP OVER '
    750	003536							END
    751	003536						    ELSE
    752	003540				BDYSC1:			LET R1	:= MCINP	; ELSE COPY SYMBOL NAME
    753	003544							LET R2	:= MCTXTP	; TO MACRO TEXT
    754	003550							REPEAT THRU R0 := LINEPT - #2 - R1 ; SYMBOL LENGTH
    755	003562							    IFB (R1) NE #MCARG	; ARGUMENT MARKER?
    756	003570								LET (R2)+ :B= (R1)+	; COPY CHAR
    757	003572							    ELSE
    758	003574								LET R1 := R1 +1	; SKIP MARKER
    759	003576							    END
    760	003576							END;R
    761	003600							LET MCTXTP	:= R2	; NEW OUTPUT POINTER
    762	003604						    END;IF
    763	003604						ELSE
    764	003606						    IF CHAR NE #MCARG THEN	; BE CAREFUL!
    765	003616							LET @MCTXTP :B= CHAR	; COPY CHARACTER TO TEXT
    766	003624							LET MCTXTP := MCTXTP +1	; BUMP POINTER
    767	003630						    END;IF
    768	003630						    LET CHAR	:= 0		; RETURN ALL CHARS
    769	003634						    CALL GETCHR			; GET NEXT CHAR
    770	003640						END;IF
    771	003640					    END;R
    772	003644				BDYEND:	    LET @MCTXTP :B= 0			; ZERO END OF LINE
    773	003650					    LET R1	:= MCTXTP		; POINT TO END
    774	003654					    LET R0	:= MCTXTL		; POINT TO LINE START
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 44-2
BDYSCN		SCAN MACRO BODY

    775	003660					    LET (R0)	:= R1 - R0		; FILL IN LINE'S LENGTH
    776	003664					    LET MCTXTL	:= R1 +1 OFF.BY #1	; POINT TO NEW LINE
    777	003702					    LET FREEPT	:= MCTXTL		; ALLOCATE MACRO TEXT
    778	003710					    IF MCLVL IS GT THEN			; STILL IN MACRO BODY?
    779	003716						LET R1	:= R1 + #132.		; ANY ROOM LEFT?
    780	003722						IF R1 HIS FRIEND THEN JUMPTO DIE ; NO, SYMBOL TABLE FULL
    781	003734						LET CHAR	:= #CR		; FORCE READING OF NEW LINE
    782	003742						CALL GETCHR			; READ CHARACTER/LINE
    783	003746						JUMPTO BDYREP			; CONTINUE TO SCAN MACRO BODY
    784	003752					    END;IF
    785	003752					LET @MCTXTL	:= 0			; SIGNAL END OF MACRO DEF.
    786	003756					LET FREEPT	:= MCTXTL + #2		; ALLOCATE DEFINITION TERMINATOR
    787	003772					LET MCASCI	:= #-1			; RESET FLAG FOR GETSYM
    788	004000					RETURN					;
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 45
ARGSCN		SCAN MACRO ARGUMENT

    790					.SBTTL	ARGSCN		SCAN MACRO ARGUMENT
    791					;++
    792					;
    793					; THIS ROUTINE SCANS THE NEXT MACRO ARGUMENT.  UPON EXIT, 'MCTXTL'
    794					; POINTS TO THE ARGUMENT DESCRIPTOR WHICH CONSISTS OF A WORD COUNT
    795					; (BYTES) FOLLOWED BY THE ARGUMENT ITSELF.  IF THE COUNT IS ZERO,
    796					; NO ARGUMENT WAS SPECIFIED (IE. IT WAS BLANK.)
    797					;
    798					; DURING THIS ROUTINE R1 IS A POINTER TO THE ARGUMENT BLOCK
    799					;
    800					;--
    801
    802	004002				PROCEDURE	ARGSCN
    803
    804	004002					LET KEYPTR	:= 0			; ASSUME NO KEYWORDS
    805	004006					CALL SYMFUL				; CHECK FOR ROOM
    806	004012					PUSH R1
    807	004014					LET R1		:= FREEPT		; POINT TO WHERE TO BUILD ARG
    808	004020					LET MCTXTL	:= R1			; START OF LINE
    809	004024					LET (R1)+	:= 0			; ASSUME BLANK ARG
    810	004026					SPNOR					; SKIP BLANKS
    811	004032					IF CHAR EQ #CR THEN			; END OF LINE
    812	004042					    JUMPTO	ARGSCX			; EXIT WITH NULL ARGUMENT
    813	004046					END;IF
    814					;	IF CHAR EQ #COMMA AND IFSTAT IS FALSE THEN ; NOT "IF" STATEMENT ARG.
    815	004046					IF CHAR EQ #COMMA THEN			;
    816	004056					    IF IFSTAT IS FALSE THEN		; NOT IN "IF" STATEMENT
    817	004064					    CALL GETCHR				; SKIP COMMA
    818	004070					    SPNOR				; SKIP BLANKS TOO
    819	004074					    END;IF
    820	004074					    JUMPTO	ARGSCX			; EXIT WITH NULL ARGUMENT
    821	004100					END;IF
    822					;
    823					; PICK UP FORMAL ARGUMENT NAME IF KEYWORD MACRO DEFINITION OR MACRO CALL.
    824					; LOAD ADDRESS OF FORMAL ARGUMENT BLOCK INTO  "KEYPTR", IF FOUND.  OTHERWISE
    825					; TREAT AS A POSITIONAL ARGUMENT.
    826					;
    827	004100					LET R0		:= CHAR L.SHIFT 1	; PREPARE FOR TABLE
    828	004106					LET R0		:= CHRTAB(R0)		; GET "TOKEN" FOR CHARACTER
    829	004112					IF R0 EQ #SYMBOL OR R0 EQ #XSYMBL OR R0 EQ #SYMNUM THEN
    830											; CAN IT BE A SYMBOL?
    831	004134					    IF KEYMAC IS NE THEN		; KEYWORD MACRO?
    832	004142						PUSH	R1,R2,R3,R4		; SAVE REGS
    833	004152						PUSH CHAR,NEXTCH,LINEPT,CONTLN	; SAVE INPUT CONTEXT
    834	004172						LET CONTLN	:= FALSE	; NO CONTINUED LINES
    835	004176						CALL GETSYM			; ACCUMULATE FIRST NAME
    836	004202						LET R2	:= #KEYMAC		; LOOK AMONG KEYWORDS
    837	004206						LET INSERT	:= FALSE	; DON'T ADD ANY
    838	004212						CALL FINDSYM			; MATCH KEYWORD
    839	004216						SPNOR				; SKIP BLANKS AFTER NAME
    840	004222						POP	CONTLN			; RESTORE LINE CONTINUATION FLAG
    841	004226						IF R2 IS NE AND CHAR EQ #'= THEN ; IT'S A KEYWORD!!!
    842	004242						    LET SP	:= SP + #6.	; THROW-AWAY INPUT CONTEXT
    843	004246						    LET KEYPTR	:= R2		; POINT TO KEYWORD
    844	004252						    CALL GETCHR			; READ NEXT CHAR
    845	004256						    SPNOR			; SKIP BLANKS AFTER EQUAL SIGN
    846	004262						ELSE
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 45-1
ARGSCN		SCAN MACRO ARGUMENT

    847	004264						    POP LINEPT,NEXTCH,CHAR	; RESTORE INPUT CONTEXT
    848	004300						END;IF
    849	004300						POP	R4,R3,R2,R1		; RESTORE REGS
    850	004310					    END;IF
    851	004310					END;IF
    852					;
    853					; NOW LOOK FOR SPECIAL CHARACTERS THAT CAN START MACRO ARGUMENTS.
    854					;
    855					; IS CHARACTER "\"
    856	004310					IF CHAR EQ #'\ THEN			; SPECIAL SYMBOL?
    857	004320					    CALL GETCHR				; SKIP OVER '\'
    858	004324					    PUSH R2,R3,R1,R4			; SAVE REGS
    859	004334					    CALL SYMSCN				; SCAN FOR SYMBOL
    860	004340					    IF R3 IS NE THEN			; IF ONE WAS FOUND
    861	004344						LET DATRPT	:= FREEPT	; SAVE PTR TO BLOCK
    862	004352						CALL SRCUST			; SEARCH USER SYMBOL TABLE
    863	004356						IF R2 IS EQ THEN LET R2 := DATRPT ; NOT FOUND
    864	004366						POP	R4,R1			; RESTORE R4 FOR PUSH
    865	004372						LPUSH	SYMVL1(R2),SYMVL2(R2)	; PUSH IT'S VALUE
    866	004412						IF SYMVL2(R2) IS LT THEN	; IS VALUE NEGATIVE?
    867	004420						    CALL X.NEG			; NEGATE VALUE (R2,R3 USED)
    868	004424						    LET (R1)+	:B= #'-		; OUTPUT NEGATIVE SIGN
    869	004430						END;IF
    870	004430						LET R3		:= R1		; POINTER  USED BY "DECLR"
    871	004432						CALL DECLR			; OUTPUT DECIMAL NUMBER
    872	004436						LET R1		:= R3		; UPDATE POINTER
    873	004440						POP	R3,R2			; RESTORE OTHER REGS
    874	004444					    ELSE
    875	004446						POP	R4,R1,R3,R2		; JUST RESTORE REGS
    876	004456					    END;IF
    877	004456					    LET R0	:= CHAR			; PICK UP CHAR
    878	004462					    JUMPTO	ARGEX			; AND DON'T TREAT SPECIAL
    879	004466					END;IF
    880					;
    881					; IS CHARACTER "<"
    882					;
    883	004466					IF CHAR EQ #LFTANG THEN			; '<'?
    884	004476					    PUSH R2
    885	004500					    LET R2	:= 0			; NESTING LEVEL COUNT
    886	004502					    LET LCLIM	:= #500.		; DON'T CONVERT TO UPPER CASE
    887	004510					    REPEAT				; PICK UP ARGUMENT INSIDE "<>"
    888	004510						LET CHAR	:= 0		; RETURN ALL CHARACTERS
    889	004514						CALL GETCHR			; GET NEXT CHARACTER OF ARGUMENT
    890	004520						LET (R1)+	:B= R0		; STORE CHARACTER IN ARG BLOCK
    891	004522						IF R0 EQ #LFTANG THEN		; IS CHARACTER ANOTHER "<"?
    892	004530						    LET R2	:= R2 +1	; INC. NESTING LEVEL
    893	004532						ELSE				;
    894	004534						    IF R0 EQ #RGTANG THEN	; IS CHARACTER ">"?
    895	004542							LET R2	:= R2 -1	; DEC. NESTING LEVEL
    896	004544							IF RESULT IS LT THEN	; ARGUMENT TERMINATED?
    897	004546							    LET R1 := R1 -1	; DON'T STORE LAST ">"
    898	004550							END;IF
    899	004550						    END;IF			;
    900	004550						END;IF				;
    901	004550						IF R1 HIS FRIEND THEN JUMPTO DIE ; OUT OF ROOM
    902	004562					    UNTIL R2 IS LT OR R0 EQ #CR		; END OF ARG. OR EOL
    903	004574					    LET LCLIM	:= #LOWCASE		; RESTORE LOWER CASE LIMIT
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 45-2
ARGSCN		SCAN MACRO ARGUMENT

    904	004602					    IF R0 EQ #CR THEN			; EOL?
    905	004610						CALL ERORLN,#UNTERM		; UNTERMINATED ARGUMENT
    906	004620					    ELSE				;
    907	004622						CALL GETCHR			; SKIP TERMINATOR
    908	004626					    END;IF
    909	004626					    POP R2
    910	004630					ELSE
    911					;
    912					; IS CHARACTER "^"
    913					;
    914	004632					    IF CHAR EQ #'^ THEN			; SPECIAL DELIMITERS
    915	004642						CALL GETCHR			; GET DELIMITER
    916	004646						IF R0 NE #CR THEN		; CAN'T BE CR
    917	004654						    PUSH R2			; SAVE R2
    918	004656						    LET R2	:= R0		; SAVE DELIMITER
    919	004660						    LET LCLIM	:= #500.	; DON'T CONVERT LOWER CASE ALPHAS
    920	004666						    REPEAT			; SCAN UNTIL DELIMITER
    921	004666							LET CHAR := 0		; READ EVERYTHING
    922	004672							CALL GETCHR		; GET NEXT CHAR
    923	004676							LET (R1)+ :B= R0	; STORE IT
    924	004700						      IF R1 HIS FRIEND THEN JUMPTO DIE ; OUT OF ROOM
    925	004712						    UNTIL R0 EQ R2 OR R0 EQ #CR	; UNTIL END OF ARG
    926	004724						    LET LCLIM	:= #LOWCASE	; RESTORE LOWER CASE LIMIT
    927	004732						    IF R0 EQ #CR THEN		; CR?
    928	004740							CALL ERORLN,#UNTERM	; UNTERMINATED ARGUMENT
    929	004750						    ELSE
    930	004752							CALL GETCHR		; SKIP OVER TERMINATOR
    931	004756						    END;IF
    932	004756						    POP R2			; STORE R2
    933	004760						    LET R1	:= R1 -1	; DON'T COUNT DELIMITER
    934	004762						END;IF
    935	004762					    ELSE
    936					;
    937					; NOTHING SPECIAL MUST BE A SYMBOLIC ARGUMENT, PICK IT UP.
    938					;
    939	004764						REPEAT				; COPY ARG UNTIL BLANKS OR COMMA
    940	004764						    LET (R1)+ :B= CHAR		; STORE CHAR
    941	004770						    IF R1 HIS FRIEND THEN JUMPTO DIE ; OUT OF ROOM
    942	005002						    CALL GETCHR			; GET NEXT CHAR
    943	005006				ARGEX:		    IF R0 EQ #RGTANG AND IRPSTAT IS TRUE THEN
    944	005022							LET R0	:= 0		; TERMINATION CASE FOR "IRP"
    945	005024						    END;IF
    946	005024						    LET R0 := R0 L.SHIFT 1	; SHIFT FOR WORD TABLE
    947	005026					        UNTIL CHRTAB(R0) IS EQ OR CHAR EQ #COMMA OR CHAR EQ #CR
    948	005054					    END;IF
    949	005054					END;IF
    950
    951	005054					SPNOR					; SKIP BLANKS
    952	005060					IF CHAR EQ #COMMA AND IFSTAT IS FALSE THEN ; END WITH COMMA?
    953	005076					    CALL GETCHR				; YES, SKIP OVER IT
    954	005102					    SPNOR				; SKIP BLANKS AND TABS
    955	005106					END;IF
    956	005106				ARGSCX:	LET @MCTXTL	:= R1 - FREEPT - #2	; SAVE LENGTH OF ARG
    957	005126					LET FREEPT	:= R1 +1 OFF.BY #1	; ROUND UP POINTER
    958	005144					CALL SYMFUL				; OUT OF ROOM?
    959	005150					POP R1
    960
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 45-3
ARGSCN		SCAN MACRO ARGUMENT

    961	005152				ENDPROCEDURE	ARGSCN
    962
    963					;++
    964					;
    965					; THIS ROUTINE IS CALLED INDIRECTLY BY BDYSCN WHEN THERE IS A
    966					; .ASCII, .ASCIZ, OR .ASCIC DIRECTIVE WITHIN A MACRO DEFINITION.
    967					; THIS ROUTINE CLEARS THE LOCATION MCASCI WHICH IS INITIALLY SET
    968					; TO -1.  THIS HAS THE EFFECT OF FORCING GETSYM TO READ ALL CHARACTERS
    969					; AND THUS PASS SEMICOLONS WITHIN .ASCIX DIRECTIVES WITHIN A
    970					; MACRO DEFINITION.
    971					;
    972					;--
    973
    974	005154	005067 	000000G		SETMAS::CLR	MCASCI			;FORCE GETSYM TO READ ALL CHARACTERS
    975	005160					RETURN
    976
    977		000001 			.END
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 45-4
SYMBOL TABLE

ARGEX   005006R     002	E2      000510R     002	L104    003130R     002	L170    004752R     002	L76     002664R     002
ARGSCN  004002RG    002	E3      000576R     002	L105    003166R     002	L171    004756R     002	MACNAM= ****** GX
ARGSCX  005106R     002	E4      001244R     002	L106    003222R     002	L172    005054R     002	MACTXT= ****** GX
A3    = 000000   	E5      001442R     002	L107    003606R     002	L173    005002R     002	MCARG = 000377 G
BDYEND  003644R     002	E6      002106R     002	L11     000210R     002	L174    005024R     002	MCARGP= ****** GX
BDYREP  003030R     002	E7      003004R     002	L110    003314R     002	L175    005054R     002	MCASCI= ****** GX
BDYSCN  003006RG    002	FF    = 000014   	L111    003320R     002	L177    005106R     002	MCINP = ****** GX
BDYSC1  003540R     002	FINDCO  002162R     002	L112    003350R     002	L2      000104R     002	MCINPE= ****** GX
BINNUM  000754RG    002	FINDPS  002150RG    002	L113    003442R     002	L21     000530R     002	MCLVL = ****** GX
BLNK  = 000040   	FINDSY  002156RG    002	L114    003440R     002	L22     000532R     002	MCSPLP= ****** GX
BOL   = ****** GX	FLTPNT= ****** GX	L115    003440R     002	L23     000732R     002	MCTXT = ****** GX
B0      000320R     002	FOUND   002564R     002	L116    003436R     002	L24     000712R     002	MCTXTL= ****** GX
B1      000414R     002	FREEPT= ****** GX	L117    003440R     002	L25     000752R     002	MCTXTP= ****** GX
B10     002646R     002	FRIEND= ****** GX	L12     000170R     002	L26     000752R     002	MOPPTR= ****** GX
B11     002754R     002	GETCHR= ****** GX	L120    003450R     002	L27     001130R     002	M.ARGC= 000014
B12     003152R     002	GETSYM  001310RG    002	L121    003540R     002	L3      000102R     002	M.ARGS= 000016
B13     003330R     002	HASHP = ****** GX	L122    003506R     002	L30     001132R     002	M.END = 000012
B14     003562R     002	HEXNUM  001040RG    002	L123    003536R     002	L31     001152R     002	M.GETL= 000004
B15     004510R     002	ID    = ****** GX	L124    003604R     002	L32     001164R     002	M.IFLV= 000006
B16     004666R     002	IDENTB= ****** GX	L125    003574R     002	L33     001164R     002	M.IFVL= 000010
B17     004764R     002	IFSTAT= ****** GX	L126    003576R     002	L34     001430R     002	M.LINK= 000000
B2      000452R     002	IIII  = 177777   	L127    003640R     002	L35     001436R     002	M.NXTL= 000002
B3      000572R     002	ILSYLN= ****** GX	L13     000206R     002	L36     001440R     002	NEXTCH= ****** GX
B4      001112R     002	IMCALL= ****** GX	L130    003630R     002	L37     001504R     002	NOTFND  002520R     002
B5      001360R     002	INPUTP= ****** GX	L131    003752R     002	L4      000100R     002	NOTUCK  002766R     002
B6      002052R     002	INSERT= ****** GX	L132    003734R     002	L40     001504R     002	NUMBER  000362RG    002
B7      002622R     002	INSUST  002314RG    002	L133    004046R     002	L41     001536R     002	OCTNUM  001006RG    002
CHAR  = ****** GX	IRPSTA= ****** GX	L134    004100R     002	L42     001740R     002	OFREE = ****** GX
CHKREG  000232R     002	I.FLAG= ****** GX	L135    004074R     002	L43     001616R     002	OPRCHK  000106R     002
CHRERR= ****** GX	I.WRN = ****** GX	L136    004134R     002	L44     001736R     002	OPRND = ****** GX
CHRTAB= ****** GX	KEYMAC= ****** GX	L137    004310R     002	L45     001634R     002	OUTFRA= ****** GX
CNT   = 000006   	KEYPTR= ****** GX	L14     000214R     002	L46     001736R     002	OUTWRN= ****** GX
COMMA = 000054   	LBLS0 = 000177   	L140    004310R     002	L47     001650R     002	PNUMBE  001072RG    002
CONTLN= ****** GX	LBLS1 = 000172   	L141    004264R     002	L5      000104R     002	PSECCH= 000020
CORLST= ****** GX	LBLS2 = 000176   	L142    004300R     002	L50     001736R     002	PSECOP= 000016
CR    = 000015   	LBLS3 = 000176   	L143    004466R     002	L51     001664R     002	PSECV1= 000012
CTAB  = ****** GX	LBLS4 = 000167   	L144    004446R     002	L52     001736R     002	PSECV2= 000014
DATRPT= ****** GX	LBLS5 = 000117   	L145    004366R     002	L53     001700R     002	PSTNUM= ****** GX
DECLR = ****** GX	LBLS6 = 000056   	L146    004430R     002	L54     001736R     002	RDXPTR= ****** GX
DIE   = ****** GX	LBLS7 = 000060   	L147    004456R     002	L55     001720R     002	REGIS   001540RG    002
DINTEG= ****** GX	LCLIM = ****** GX	L15     000256R     002	L56     001736R     002	RGTANG= 000076
DMASK = ****** GX	LF    = 000012   	L150    004632R     002	L57     001734R     002	RRREG = ****** GX
DNUMBE  000366RG    002	LFTANG= 000074   	L151    004534R     002	L6      000214R     002	RTAB  = ****** GX
DPC   = ****** GX	LINEBF= ****** GX	L152    004550R     002	L60     001736R     002	RTNVAL=%000000
DPOUND= ****** GX	LINELN= ****** GX	L153    004550R     002	L61     002036R     002	R6    =%000006
ENDMCH= ****** GX	LINEPT= ****** GX	L154    004550R     002	L62     002010R     002	R7    =%000007
ERORLN= ****** GX	LISTIT= ****** GX	L155    004562R     002	L63     002004R     002	SEMI  = 000073
E0      000360R     002	LOWCAS= 000140   	L156    004574R     002	L64     002006R     002	SETMAS  005154RG    002
E1      000534R     002	LPTLEN= 000074   	L16     000360R     002	L65     002036R     002	SKIPSP= ****** GX
E10     002676R     002	LSB   = ****** GX	L160    004622R     002	L66     002034R     002	SPACE = 000040
E11     002760R     002	LS.MD = ****** GX	L161    004626R     002	L67     002036R     002	SPLDIR= ****** GX
E12     003644R     002	L0      000106R     002	L162    005054R     002	L7      000122R     002	SRCUST  002322RG    002
E13     003346R     002	L1      000044R     002	L163    004764R     002	L70     002102R     002	SYMBOL  000000RG    002
E14     003600R     002	L10     000214R     002	L164    004762R     002	L72     002130R     002	SYMCHR= 000012
E15     004574R     002	L100    002726R     002	L165    004712R     002	L73     002136R     002	SYMFLA= 000002
E16     004724R     002	L101    002742R     002	L166    004724R     002	L74     003004R     002	SYMFUL= ****** GX
E17     005054R     002	L103    003062R     002	L17     000354R     002	L75     002772R     002	SYMLEN= 000011
SCANER	MACRO M1110  21-AUG-78 21:59  PAGE 45-5
SYMBOL TABLE

SYMLIN= 000000   	S.EXTN= 010000   	TYPS3 = 000000   	V2STAC= ****** GX	$O$   = 000000
SYMLNK= ****** GX	S.GLOB= 020000   	TYPS4 = 000000   	XPOUND  002112RG    002	$R    = 177777
SYMMAX= 000017   	S.LOCL= 001000   	TYPS5 = 000000   	XSYMBL  000300RG    002	$SV$  = 000001
SYMNUM  000260RG    002	S.ODBG= 000040   	TYPS6 = 000000   	XUPARR  002042RG    002	$T    = 000200
SYMSCN  001252RG    002	S.REF = 000400   	TYPS7 = 000000   	X.NEG = ****** GX	$T1   = 000000
SYMSEG= 000010   	S.TKMS= 000377   	UNTERM= ****** GX	$DIDDO= 000000   	$T2   = 000177
SYMVL1= 000004   	S.WEAK= 040000   	UPTAB = ****** GX	$E$   = 000001   	$Y$   = 000000
SYMVL2= 000006   	TAB   = 000011   	UPTOK = ****** GX	$F$   = 000000   	$Z$   = 000000
S.ABS = 004000   	TUCK    002600R     002	VAL1  = ****** GX	$I$   = 000001   	$$S   = 000000
S.ASN = 000200   	TUCKX   003004R     002	VAL2  = ****** GX	$K$   = 000013   	$$T   = 000176
S.DBG = 002000   	TYPS0 = 000000   	VAL3  = ****** GX	$L    = 000020   	$$TT  = 000176
S.DF  = 100000   	TYPS1 = 000000   	VAL4  = ****** GX	$LL   = 000017   	.SAVRG= ****** GX
S.EPT = 000100   	TYPS2 = 000000   	V1STAC= ****** GX	$L$   = 000000   	.$T   = 000001

. ABS.	000000	   000
      	000000	   001
SCANER	005162	   002
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  13119 WORDS  ( 52 PAGES)
DYNAMIC MEMORY:  14388 WORDS  ( 55 PAGES)
ELAPSED TIME:  00:10:57
OBJ$:SCANER,LIS$:SCANER/-SP=SRC$:MD,COMMON,SCANER
