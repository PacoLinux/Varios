ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37
TABLE OF CONTENTS

    32-    8	CHARACTER DATA GENERATING DIRECTIVES
    34-  119	PACKED DECIMAL STRING ROUTINE
    35-  210	PC ALIGNMENT DIRECTIVES
    36-  231	ALIGNMENT DIRECTIVE
    38-  306	PAGE DIRECTIVE
    38-  314	ERROR/PRINT/WARN DIRECTIVES
    39-  373	ARGUMENT TYPE ROUTINES
    39-  374	NTHD1 - NTHD2	NTYPE-HEAD ROUTINES
    39-  407	NTYPE1 - NTYPE2	NTYPE ACTION ROUTINES
    40-  435	NARG	NUMBER OF POSITIONAL ARGUMENTS IN MACRO CALL
    40-  466	NCHR	COUNT CHARACTERS IN ARGUMENT
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 32


      1					.TITLE	ACTCHR	CHARACTER STRING ROUTINES
      2	000000				.PSECT	ACTCHR
      3
      4					.GLOBL	ASCIC,	ASCII,	ASCIZ,	CHRNUL,	CHRARG,	CHARHD
      5					.GLOBL	PACKED,	EVEN,	ODD,	ALIGN,	ALIGN1,	ALIGN2
      6					.GLOBL	PAGE,	PRINT,	WARN,	ERROR,	ERROR1,	ERROR2
      7					.GLOBL	NTYPE1,	NTYPE2,	NARG,	NCHR,	NTHD1,	NTHD2
      8					.SBTTL	CHARACTER DATA GENERATING DIRECTIVES
      9
     10	000000				ASCIC::				; CHAR_HEAD = KASCIC
     11
     12	000000					LET DATPTR	:= #ASCIC		; ASCIC DATA TYPE
     13	000006					LET ASCCNT	:= 0			; START COUNT AT ZERO
     14	000012					OUT #I.STKL,<#0,#0>			; STACK ZERO
     15	000032					OUT #I.STSB				; STORE BYTE IN LISTING
     16	000042					INCRPC	#1				; SAVE BYTE FOR LENGTH
     17	000054					GOTO ASCCOM				; PICK UP FIRST CHARACTER OF STRING
     18
     19
     20	000056				ASCII::				; CHAR_HEAD = KASCII
     21
     22	000056					LET DATPTR	:= #ASCII		; ASCII DATA TYPE
     23	000064					GOTO ASCCOM				; PICK UP FIRST CHARACTER OF STRING
     24
     25
     26	000066				ASCIZ::				; CHAR_HEAD = KASCIZ
     27
     28	000066					LET DATPTR	:= #ASCIZ		; ASCIZ DATA TYPE
     29	000074				ASCCOM:	LET LCLIM	:= #500.		; PREVENT UPPER CASE CONVERSION
     30	000102					LET CHAR	:= 0			; RETURN ALL CHARACTERS
     31	000106					LET LINEPT	:= LINEPT -1		; BACK UP TO PICK UP DELIMITER
     32	000112					LET R0		:= LINEPT -1		; POINT TO DELIMITER
     33	000120					LET NEXTCH	:B= (R0)		; LOAD DELIMITER INTO "NEXTCH"
     34	000124					CALL GETCHR				; READ DELIMITER AGAIN
     35	000130					LET LCLIM	:= #LOWCASE		; RESET LOWER CASE LIMIT
     36	000136					GOTO GCHARS				; START SCANNING STRING
     37
     38
     39	000140				CHRNUL::			; CHAR_ARGS = DANGOPN DANGCLS
     40									; CHAR_ARGS = CHAR_ARGS DANGOPN DANGCLS
     41
     42	000140					OUT #I.STIB,<#0,#0>			; NULL CHARACTER
     43	000160					INCRPC	#1				; ONE BYTE
     44	000172					LET ASCCNT	:= ASCCNT +1		; COUNT CHARACTER
     45	000176					GOTO GCHARS				; CONTINUE SCANNING STRING
     46
     47
     48	000200				CHRARG::			; CHAR_ARGS = DANGOPN EXPR DANGCLS
     49									; CHAR_ARGS = CHAR_ARGS DANGOPN EXPR DANGCLS
     50
     51	000200					IF ABSEXPR IS NE THEN LET EXPOPT := FALSE ; CAN'T OPTIMIZE
     52	000212					IF EXPOPT IS TRUE THEN			; CAN OPTIMIZE!
     53	000220					    CALL OPTEXP				; RESET POINTERS
     54	000224					    OUT #I.STIB,<V1STACK-2(R4),#0>	; STORE IMM. BYTE
     55	000244					ELSE
     56	000246					    OUT #I.STSB				; STORE SIGNED BYTE
     57	000256					END
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 32-1
CHARACTER DATA GENERATING DIRECTIVES

     58	000256					INCRPC	#1				; COUNT THE BYTE
     59	000270					LET ASCCNT	:= ASCCNT +1		; COUNT CHARACTER
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 33
CHARACTER DATA GENERATING DIRECTIVES

     61	000274				GCHARS:					; SCAN STRING ARG
     62	000274					LET EVALEXPR	:= TRUE			; EVALUATE EXPRESSIONS
     63	000302					LET LCLIM	:= #500.		; PREVENT UPPER CASE CONVERSION
     64	000310					SPNOR					; IGNORE BLANKS
     65	000314					IF CHAR NE #CR AND CHAR NE #LFTANG THEN	; (<) STRING PRESENT?
     66	000334					    LET DATRPT	:= CHAR			; SAVE STRING DELIMITER
     67	000342					    REPEAT				; SCAN STRING
     68	000342						LET CHAR := 0			; READ ALL CHARS
     69	000346						CALL GETCHR			; GET NEXT CHAR
     70	000352						IF R0 EQ DATRPT THEN		; END OF STRING?
     71	000360						    CALL GETCHR			; SCAN PAST DELIMITER
     72	000364						    LEAVE			; AND EXIT
     73	000366						END
     74	000366						IF R0 EQ #CR THEN		; EOL?
     75	000374						    CALL ERORLN,#UNTERM		; UNTERMINATED ARGUMENT
     76	000404						    LEAVE			; EXIT LOOP
     77	000406						END
     78	000406						CALL STRASC			; STORE CHARACTER JUST READ
     79	000412					    END;R				; GET ANOTHER CHAR
     80	000414					END;IF
     81	000414					LET LCLIM	:= #LOWCASE		; RESET LOWER CASE LIMIT
     82	000422					LET EXPOPT	:= TRUE			; ASSUME EXPR OPTIMIZABLE
     83	000430					LET EXPPTR	:= FRMPTR		; SET UP POINTERS
     84	000436					LET EXPEND	:= FRMPTR
     85	000444					LET ABSEXPR	:= 0			; ASSUME ABSOLUTE EXPR
     86	000450					LET PRMSEG	:= 0			; IN ABSOLUTE SEG
     87	000454					IF CHAR NE #CR AND CHAR NE #LFTANG THEN	; STRING NOT TERMINATED YET
     88	000474					    GOTO GCHARS				; LOOP
     89	000476					END;IF					;
     90	000476					RETURN					;
     91
     92	000500				STRASC:					; STORE CHARACTER IN R0
     93	000500					OUT		#I.STIB,<R0,#0>		; STORE IMMEDIATE BYTE
     94	000516					INCRPC		#1			; COUNT THE BYTE
     95	000530					LET ASCCNT	:= ASCCNT +1		; COUNT THIS CHARACTER
     96	000534					RETURN
     97
     98									; CHAR_STAT = CHAR_HEAD
     99	000536				CHARHD::			; CHAR_STAT = CHAR_HEAD CHAR_ARGS
    100	000536					IF DATPTR EQ #ASCIZ THEN		; .ASCIZ DIRECTIVE?
    101	000546					    OUT		#I.STIB,<#0,#0>		; YES, FINISH WITH ZERO
    102	000566					    INCRPC	#1			; COUNT THE BYTE
    103	000600					ELSE
    104	000602					    IF DATPTR EQ #ASCIC THEN		; ASCIC DIRECTIVE?
    105	000612						LET R0	:= ASCCNT +1		; COPY STRING LENGTH + ONE
    106	000620						DECRPC	R0			; BACK UP PC FOR LISTING
    107	000630	005400 					NEG	R0			; GET TWO'S COMPLEMENT OF LENGTH
    108	000632						OUT #I.FLAG,<#-1,#MEBLST>	; INSURE SHORT STRINGS LIST
    109	000652						OUT #I.AUGPC,<R0,#-1>		; BACK UP PC TO LENGTH BYTE
    110	000670						OUT #I.FNEWL			; FORCE NEW LINE IN LISTING
    111	000700						OUT #I.STIB,<ASCCNT,#0>		; STORE STRING LENGTH
    112	000720						OUT #I.AUGPC,<ASCCNT,#0>	; RESTORE PC TO PROPER PLACE
    113	000740	005400 					NEG	R0			; GET POSITIVE COUNT AGAIN
    114	000742						INCRPC	R0			; RESTORE PC FOR LISTING
    115	000752					    END
    116	000752					END
    117	000752					RETURN
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 34
PACKED DECIMAL STRING ROUTINE

    119					.SBTTL	PACKED DECIMAL STRING ROUTINE
    120					;
    121					; THIS ROUTINE PICKS UP A DECIMAL STRING, STORES IT IN "PACDAT"
    122					; (A TEMPORARY BUFFER) AND THEN STORES THE PACKED DECIMAL STRING INTO THE
    123					; OBJECT CODE.  THE OPTIONAL SYMBOL IS EQUATED TO THE NUMBER OF DIGITS,
    124					; AND IS TREATED AS AN EQUATED, NON-GLOBAL SYMBOL.
    125					;
    126	000754				PACKED::			; DIRECTIVE = KPACKED
    127	000754					SAVRG					; SAVE R1 - R3
    128	000760					SPNOR					; SKIP LEADING BLANKS
    129	000764					LET R1 		:= #PACDAT		; TEMPORARY BUFFER POINTER
    130	000770					LET R2		:= 0			; START DIGIT COUNT AT ZERO
    131	000772					LET R0		:= CHAR			; COPY FIRST CHARACTER
    132	000776					IF R0 EQ #'- THEN			; DETERMINE SIGN OF STRING
    133	001004					    LET R3 	:= #13.			; NEGATIVE SIGN IS 13 (D)
    134	001010					    CALL GETCHR				; PICK UP FIRST DIGIT
    135	001014					ELSE
    136	001016					    IF R0 EQ #'+ THEN			; PLUS SIGN?
    137	001024						CALL GETCHR			; PICK UP FIRST DIGIT
    138	001030					    END
    139	001030					    LET R3 	:= #12.			; PLUS SIGN IS 12 (C)
    140	001034					END
    141	001034					WHILE R0 NE #COMMA AND R0 NE #CR	; NOT END OF NUMBER
    142	001050					    LET R0 	:= R0 L.SHIFT		; MAKE CHAR INDEX TO WORD TABLE
    143	001052					    IF CHRTAB(R0) EQ #NUMBER THEN	; DIGIT?
    144	001062						IF R2 GE #31. THEN		; 31 DIGITS MAXIMUM
    145	001070						    CALL ERORLN,#PACERR		; NOT DECIMAL STRING
    146	001100						    GOTO PAKERR			; SKIP TO COMMA
    147	001102						END
    148	001102						LET R2	:= R2 +1		; COUNT THIS DIGIT
    149	001104						LET (R1)  :B= CHAR		; STORE ASCII DIGIT
    150	001110						LET (R1)+ :B= (R1)+ OFF.BY #360	; CONVERT TO BINARY DECIMAL
    151	001114						CALL GETCHR			; READ NEXT DIGIT
    152	001120					    ELSE
    153	001122						SPNOR				; SKIP SPACES AFTER NUMBER
    154	001126						LET R0	:= CHAR			; COPY NON-BLANK INTO R0
    155	001132						IF R0 NE #COMMA AND R0 NE #CR THEN ; NOT "EOL"
    156	001146						    CALL ERORLN,#DIRERR		; PACKED DIRECTIVE ERROR
    157	001156				PAKERR:		    REPEAT			; SKIP CHARACTERS UNTIL TERMINATOR
    158	001156							CALL GETCHR		; READ CHARACTER
    159	001162						    UNTIL R0 EQ #CR OR R0 EQ #COMMA ; TERMINATOR?
    160	001176						END;IF
    161	001176					    END;IF
    162	001176					END;W
    163	001200					IF R2 IS EQ THEN			; NULL STRING
    164	001204					    LET (R1)+	:B= 0			; STORE DEFAULT ZERO IN BUFFER
    165	001206					    LET R2	:= R2 +1		; TREAT AS LENGTH ONE
    166	001210					END;IF
    167	001210					LET (R1)+	:B= R3			; STORE SIGN AT END OF STRING
    168	001212					IF R0 EQ #COMMA THEN			; THERE SHOULD BE A SYMBOL
    169	001220					    PUSH R2				; SAVE STRING LENGTH
    170	001222					    CALL GETCHR				; SKIP OVER COMMA
    171	001226					    SPNOR				; SKIP OVER BLANKS
    172	001232					    IF CHRTAB(R0) EQ #NUMBER THEN	; LOCAL LABEL?
    173	001242						CALL DNUMBER			; GET LOCAL LABEL
    174	001246						IF R0 NE #ID THEN		; NOT LABEL
    175	001254						    CALL ERORLN,#DIRERR		; PACKED DIRECTIVE ERROR
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 34-1
PACKED DECIMAL STRING ROUTINE

    176	001264						    GOTO NONAME			; EXIT
    177	001266						END
    178	001266						LET R2	:= VAL1			; GET BLOCK ADDRESS
    179	001272						GOTO NAMCOM			; GO SET FLAGS
    180	001274					    ELSE
    181	001276						CALL SYMSCN			; GET SYMBOL
    182	001302						IF R3 IS EQ THEN		; NO SYMBOL FOUND
    183	001306						    LET CHAR := #CR		; SKIP TO NEXT LINE
    184	001314						    CALL ERORLN,#DIRERR		; PACKED DIRECTIVE ERROR
    185	001324						    GOTO NONAME			; EXIT
    186	001326						END
    187	001326					    END;IF
    188	001326					    CALL INSUST				; INSERT SYMBOL IN USER TABLE
    189	001332				NAMCOM:	    LET SYMFLAG(R2) := SYMFLAG(R2) SET.BY #S.DF+S.ASN ; ASSIGNMENT & DEF.
    190	001340					    LET SYMVL1(R2)  := (SP)		; STORE LENGTH INTO VAL1
    191	001344				NONAME:	    POP R2				; PICK UP STRING LENGTH
    192	001346					END;IF
    193	001346					LET R0		:= R2 + #2 R.SHIFT	; ROUND NIBBLES INTO BYTES
    194	001356					INCRPC	R0				; UPDATE PC ON PASS1
    195	001366					LET R1		:= #PACDAT		; POINT TO START OF STRING
    196	001372					IF #1 OFF.IN R2 THEN			; STRING EVEN NUMBER OF DIGITS?
    197	001400					    LET R0	:B= (R1)+		; GET FIRST DIGIT UPPER NIBBLE 0
    198	001402					    OUT #I.STIB,<R0,#0>			; STORE FIRST BYTE
    199	001420					    LET R2	:= R2 -1		; DECREMENT COUNTER
    200	001422					END;IF
    201	001422					WHILE R2 IS GT				; MORE DIGITS TO PACK?
    202	001426					    LET R0	:B= (R1)+		; GET DIGIT N FIRST
    203	001430					    LET R0	:= R0 SHIFT #4		; MOVE TO UPPER NIBBLE
    204	001434					    LET R0	:B= R0 SET.BY (R1)+	; DIGIT N+1 OR SIGN IN LOWER NIBBLE
    205	001436					    LET R2	:= R2 - #2		; TWO DIGITS GONE
    206	001442					    OUT #I.STIB,<R0,#0>			; OUTPUT TWO DIGITS
    207	001460					END;W
    208	001462					RETURN					; RESTORES R1 - R3
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 35
PC ALIGNMENT DIRECTIVES

    210					.SBTTL	PC ALIGNMENT DIRECTIVES
    211
    212
    213	001464				EVEN::				; DIRECTIVE = KEVEN
    214	001464					IF #1 SET.IN PC1 THEN			; IS PC ODD?
    215	001474					    CALL ODDEVEN			; ADD ONE TO PC
    216	001500					END
    217	001500					RETURN
    218
    219	001502				ODD::				; DIRECTIVE = KODD
    220	001502					IF #1 OFF.IN PC1 THEN			; IS PC EVEN?
    221	001512					    CALL ODDEVEN			; ADD ONE TO PC
    222	001516					END
    223	001516					RETURN
    224
    225
    226	001520				ODDEVEN:				; ADD ONE TO THE PC
    227	001520					OUT	#I.AUGPC,<#1,#0>		; OUTPUT AUGMENT COMMAND
    228	001540					INCRPC	#1				; COUNT THE BYTE ON PASS 1
    229	001552					RETURN					;
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 36
ALIGNMENT DIRECTIVE

    231					.SBTTL	ALIGNMENT DIRECTIVE
    232
    233	001554				ALIGN:				; ALIGN_HEAD = KALIGN
    234	001554					LET EVALEXPR	:= FALSE		; DON'T OUTPUT EXPR
    235	001560					LET ABSEXPR	:= 0			; ASSUME ABSOLUTE
    236	001564					LET EXPOPT	:= TRUE			; ASSUME NICE
    237	001572					SPNOR					; IGNORE SPACES
    238	001576					IF CHRTAB(R0) EQ #NUMBER THEN		; NUMBER?
    239	001606					    CALL DNUMBER			; GET IT
    240	001612					    LET R0	:= #1 SHIFT VAL1	; GET 2 ** (VAL1)
    241	001622					ELSE
    242	001624					    CALL SYMSCN				; SCAN SYMBOL
    243	001630					    IF R3 IS EQ THEN			; NOT FOUND?
    244	001634						CALL ERORLN,#INVALN		; INVALID ALIGNMENT FACTOR
    245	001644						LET R0		:= 0		; ASSUME BYTE ALIGNMENT
    246	001646					    ELSE
    247	001650						LET PSECTO := #PS.OPT		; POINT TO OPTION NAMES
    248	001656						LET R2	:= #PSECTO		; POINT TO PSECT OPTIONS
    249	001662						LET INSERT := FALSE		; DON'T ADD NEW  ONES
    250	001666						CALL FINDSYM			; LOOK FOR OPTION
    251	001672						IF R2 IS EQ OR #^O777 SET.IN SYMVL1(R2) THEN
    252	001706						    CALL ERORLN,#INVALN		; INVALID ALIGNMENT FACTOR
    253	001716						    LET R0	:= 0		; ASSUME BYTE ALIGNMENT
    254	001720						ELSE
    255	001722						    LET R1	:= SYMVL1(R2) OFF.BY #40000
    256											; GET EXPONENT VALUE FOR KEYWORD
    257	001732						    LET R1	:= R1 SHIFT #-9. ; RIGHT JUSTIFY EXPONENT
    258	001736						    LET R0	:= #1 SHIFT R1	; CALCULATE ALIGNMENT FACTOR
    259	001744						END;IF
    260	001744					    END;IF
    261	001744					END;IF
    262	001744					LET EXPOP1	:= R0			; LOAD ALIGNMENT FACTOR
    263	001750					LET EXPOP2	:= 0			; UPPER 16 BITS ALWAYS ZERO
    264	001754					LET R0		:= PSECTP		; POINT TO PSECT
    265	001760					LET R1		:= PSECOP(R0) OFF.BY #140777 ; PICK UP ALIGNMENT
    266	001770					LET R1		:= R1 SHIFT #-9.	; RIGHT JUSTIFY EXPONENT
    267	001774					LET R0		:= #1 SHIFT R1		; CALCULATE PSECT ALIGNMENT
    268	002002					IF R0 LO EXPOP1 THEN			; ALIGNMENT TOO BIG?
    269	002010					    LET EXPOP1	:= R0			; ALIGN ON PSECT SIZE
    270	002014					    CALL ERORLN,#ALNTBG			; ALIGNMENT TOO BIG
    271	002024					END
    272	002024					RETURN					; GET EXPRESSIONS
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 37
ALIGNMENT DIRECTIVE

    274	002026				ALIGN1:				; DIRECTIVE = ALIGN_HEAD
    275	002026					LET DATRPT	:= FALSE		; NO FILL EXPR
    276	002032					GOTO ALIGNP				; CONTINUE
    277
    278	002034				ALIGN2:				; DIRECTIVE = ALIGN_HEAD EXPR
    279									; DIRECTIVE = ALIGN_HEAD DCOMMA EXPR
    280	002034					LET DATRPT	:= TRUE			; WE HAVE FILL EXPR
    281	002042				ALIGNP:	IF ABSEXPR IS NE THEN			; NOT SCALAR EXPRESSION?
    282	002050					    CALL ERORPT,#ILASEX			; COMPLEX EXPRESSION NOT ALLOWED
    283	002060					END
    284	002060					LET R2		:= EXPOP1		; ALIGNMENT FACTOR
    285	002064					IF RESULT IS NE THEN			; ALIGNMENT FACTOR NON-ZERO
    286	002066					    LET R3	:= R2			; COPY FACTOR
    287	002070					    LET R2	:= R2 - #1		; NEED MASK OF BITS TO SAVE
    288	002072	005102 				    COM	R2				; CREATE MASK
    289	002074	016701 	000000G			    MOV	PC1,R1				; COPY LOWER 16 BITS OF PC
    290	002100	040201 				    BIC	R2,R1				; LEAVE LOW ORDER BITS ONLY
    291	002102	001445 				    BEQ	ALIGNX				; EXIT IF ALREADY ALIGNED
    292	002104					    LET R3	:= R3 - R1		; CALCULATE ACTUAL AUGMENTATION
    293	002106					    PUSH R3				; SAVE AUGMENTATION
    294	002110					    IF DATRPT IS FALSE THEN		; FILL EXPRESSION?
    295	002116						OUT #I.AUGPC,<R3,#0>		; NO FILL, JUST INC PC
    296	002134					    ELSE
    297	002136						OUT #I.STKL,<V1STACK(R4),V2STACK(R4)> ; STACK FILL EXPRESSION
    298	002156						OUT #I.STKL,<R3,#0>		; STACK REPEAT COUNT
    299	002174						OUT #I.STRB			; STORE REPEATED BYTE
    300	002204					    END
    301	002204					    POP R3				; PICK UP AUGMENTATION
    302	002206					    INCRPC R3				; ADD R3 TO PC1 AND PC2
    303	002216					END
    304	002216				ALIGNX:	RETURN					; EXIT
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 38
PAGE DIRECTIVE

    306					.SBTTL	PAGE DIRECTIVE
    307
    308	002220				PAGE:				; DIRECTIVE = KPAGE
    309	002220					OUT #I.FLAG,<#-1,#LPTCT>		; FORCE NEW PAGE
    310	002240					OUT #I.FLAG,<#0,#LISTIT>		; DON'T LIST LINE
    311	002260					RETURN					; THAT WAS EASY
    312
    313
    314					.SBTTL	ERROR/PRINT/WARN DIRECTIVES
    315					;
    316					; THESE ROUTINES CAUSE MESSAGES TO BE PRINTED ON THE USER'S TERMINAL
    317					; DURING THE SECOND PASS.
    318					;
    319
    320	002262				WARN:				; ERROR_HEAD = KWARN
    321	002262					LET VAL1	:= #USRGEN		; USER GENERATED MESSAGE
    322	002270					LET VAL2	:= #I.WRN		; WARNING CODE
    323	002276	000414 				BR	EPWCOM
    324
    325	002300				ERROR:				; ERROR_HEAD = KERROR
    326	002300					LET VAL1	:= #USRGEN		; USER GENERATED MESSAGE
    327	002306					LET VAL2	:= #I.ERR		; ERROR CODE
    328	002314	000405 				BR	EPWCOM
    329
    330	002316				PRINT:				; ERROR_HEAD = KPRINT
    331	002316					LET VAL1	:= 0			; JUST PRINT ON TTY
    332	002322					LET VAL2	:= #I.PRT		; PRINT CODE
    333	002330				EPWCOM:	LET EVALEXPR	:= FALSE		; DON'T EVALUATE EXPR
    334	002334	016700 	000000G			MOV	INPUTP,R0		;GET POINTER TO INPUT LINE
    335	002340	026027 	000004 	000000G		CMP	M.GETL(R0),#MACLIN	;READING MACRO SOURCE?
    336	002346	001034 				BNE	40$			;IF NE NO--DON'T NEED TO OUTPUT LINE
    337	002350	016700 	000000G			MOV	LINELN,R0		;  TO INT. FILE....GET LINE LENGTH
    338	002354	010001 				MOV	R0,R1			;COPY IT
    339	002356	066701 	000000G			ADD	FRMPTR,R1		;FIGURE WHERE LINE WILL GO
    340	002362	020127 	177770G			CMP	R1,#FRMPTR-10		;ROOM FOR LINE IN INT. BUFFER?
    341	002366	103402 				BLO	10$			;IF LO YES
    342	002370					CALL	WRTFRM			;NO--WRITE BUFFER TO FILE
    343	002374	062700 	000002 		10$:	ADD	#2,R0			;ROUND UP TO EVEN # CHARS
    344	002400	042700 	000001 			BIC	#1,R0			; ...
    345	002404	016702 	000000G			MOV	FRMPTR,R2		;POINT INTO INT BUFFER
    346	002410	112722 	177777 			MOVB	#-1,(R2)+		;SIGNAL SPECIAL LINE
    347	002414	112722 	000000G			MOVB	#I.MACL,(R2)+		;READ MACRO LINE COMMAND
    348	002420	010022 				MOV	R0,(R2)+		;STORE LENGTH OF LINE
    349	002422	012701 	000000G			MOV	#LINEBF,R1		;POINT TO LINE
    350	002426	006200 				ASR	R0			;CONVERT TO NUMBER OF WORDS TO COPY
    351	002430	012122 			20$:	MOV	(R1)+,(R2)+		;COPY LINE A WORD AT A TIME
    352	002432	077002 				SOB	R0,20$			;...
    353	002434	010267 	000000G			MOV	R2,FRMPTR		;UPDATE FRAME POINTER
    354	002440				40$:	RETURN
    355
    356	002442				ERROR2:				; DIRECTIVE = ERROR_HEAD EXPR
    357	002442					OUT #I.PRIL,<V1STACK(R4),V2STACK(R4)>	; PRINT EXPRESSION VALUE
    358	002462					LET EVALEXPR	:= TRUE			; EVALUATE FUTURE EXPR'S
    359	002470					LET R2		:= V1STACK-2(R4)	; PICK UP MESSAGE POINTER
    360	002474					LET R0		:= V2STACK-2(R4)	; PICK UP INTERMEDIATE CODE
    361	002500					GOTO ERROR3				; EXIT
    362
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 38-1
ERROR/PRINT/WARN DIRECTIVES

    363	002502				ERROR1:				; DIRECTIVE = ERROR_HEAD
    364	002502					LET R2		:= V1STACK(R4)		; PICK UP MESSAGE PTR
    365	002506					LET R0		:= V2STACK(R4)		; PICK UP INTERMEDIATE CODE
    366	002512				ERROR3:	PUSH LINEPT,R2				; STACK LINE-PTR, MSG-PTR
    367	002520	000300 				SWAB R0					; MOVE COMMAND TO UPPER BYTE
    368	002522	052700 	000006 			BIS  #6,R0				; OR IN LENGTH OF STACK FRAME
    369	002526					PUSH R0					; STACK COMMAND - LENGTH WORD
    370	002530					CALL	OUTFRA				; OUTPUT TO INTERMEDIATE FILE
    371	002534					RETURN					;
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 39
ARGUMENT TYPE ROUTINES

    373					.SBTTL	ARGUMENT TYPE ROUTINES
    374					.SBTTL	NTHD1 - NTHD2	NTYPE-HEAD ROUTINES
    375					;++
    376					;
    377					; THESE ROUTINES SAVE THE ADDRESS OF THE IDENTIFIER AND PREPARE THE INTERNAL
    378					; FLAGS FOR SCANNING AN OPERAND.
    379					;
    380					;--
    381
    382	002536				NTHD2:				; NTYPE_HEAD = KNTYPE ID
    383	002536					LET NTYPTR	:= V1STACK(R4)		; POINT TO IDENTIFIER
    384	002544					GOTO	NTYPHD				; BRANCH TO COMMON POINT
    385
    386	002546				NTHD1:				; NTYPE_HEAD = KNTYPE ID DCOMMA
    387	002546					LET NTYPTR	:= V1STACK-2(R4)	; POINT TO IDENTIFIER
    388	002554				NTYPHD:						; START OF COMMON CODE
    389	002554					LET REG		:= 0			; ZERO OUT VARS
    390	002560					LET MODE	:= 0
    391	002564					LET EVALEXPR	:= FALSE		; DON'T EVALUATE EXPR
    392	002570					LET OPSIZE	:= #^B10000		; ARGUMENT MODE
    393	002576					LET XPC1	:= PC1			; SAVE PC
    394	002604					LET XPC2	:= PC2
    395	002612					IF FRMPTR HI #FRMWRN THEN CALL WRTFRM	; FLUSH BUFFER IF NEAR END
    396	002626					LET FLTWDC	:= #1			; SINGLE PRECISION FLOAT
    397	002634					LET IREG	:= 0
    398	002640					LET IMODE	:= 0
    399	002644					LET COMPEXPR	:= TRUE			; WE KNOW EXPRESSION
    400	002652					LET ABSEXPR	:= 0			; ABSOLUTE EXPRESSION
    401	002656					LET PRMSEG	:= PSTNUM		; START NEXT LINE IN CURRENT PSECT
    402	002664					LET EXPOPT	:= TRUE			; OPTIMIZE
    403	002672					LET EXPPTR	:= FRMPTR		; START OF EXPRESSION
    404	002700					LET EXPEND	:= FRMPTR		; NO EXPRESSION
    405	002706					RETURN
    406
    407					.SBTTL	NTYPE1 - NTYPE2	NTYPE ACTION ROUTINES
    408					;++
    409					;
    410					; THESE ROUTINES PERFORM THE ACTUAL ASSIGNMENT OF THE "MODE-REGISTER" TO THE
    411					; IDENTIFIER POINTED TO IN "NTYPTR".
    412					;
    413					;--
    414
    415	002710				NTYPE1:				; DIRECTIVE = NTYPE_HEAD
    416	002710					CALL ERORLN,#DIRERR			; DIRECTIVE SYNTAX ERROR
    417	002720					LET VAL1	:= 0			; NO REF, ASSUME 0
    418	002724					LET VAL2	:= 0
    419	002730				NTYPE2:				; DIRECTIVE = NTYPE_HEAD REF
    420	002730					LET PC1		:= XPC1			; RESTORE PC
    421	002736					LET PC2		:= XPC2		;
    422	002744					LET R0		:= VAL1 SHIFT #4 SET.BY VAL2 ; MODE PART OF REF
    423	002760					LET R2		:= NTYPTR		; POINT TO IDENTIFIER
    424	002764					LET SYMVL1(R2)	:= R0			; STORE RESULT
    425	002770					LET SYMVL2(R2)	:= 0			;
    426	002774					LET SYMSEG(R2)	:B= 0			; ABSOLUTE PSECT
    427	003000					IF #S.DF SET.IN SYMFLAG(R2) AND #S.ASN OFF.IN SYMFLAG(R2) THEN
    428	003020					    CALL ERORPT,#MULTDF			; MULTIPLE DEFINITION!
    429	003030					END;IF
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 39-1
NTYPE1 - NTYPE2	NTYPE ACTION ROUTINES

    430	003030					LET SYMFLAG(R2)	:= SYMFLAG(R2) SET.BY #S.DF+S.ABS+S.ASN
    431	003036					OUT #I.ASN,<R2,SYMSEG(R2),SYMVL1(R2),SYMVL2(R2),#1>
    432	003070					OUT #I.PRIL,<SYMVL1(R2),SYMVL2(R2)>	; PRINT VALUE ON PASS 2
    433	003110					RETURN
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 40
NARG	NUMBER OF POSITIONAL ARGUMENTS IN MACRO CALL

    435					.SBTTL	NARG	NUMBER OF POSITIONAL ARGUMENTS IN MACRO CALL
    436					;++
    437					;
    438					; THIS ROUTINE PICKS UP THE NUMBER OF POSITIONAL ARGUMENTS IN THE CURRENT
    439					; MACRO CALL AND ASSIGNS IT TO THE SYMBOL SPECIFIED.  THE ROUTINE MAKES A
    440					; CALL TO "SYMSCN" TO GET THE SYMBOL, AND THIS ROUTINE WILL FAIL IF THERE
    441					; IS NO SYMBOL OR IF WE ARE NOT IN A MACRO OR, IF THE SYMBOL IS ALREADY
    442					; DEFINED AS A LABEL.
    443					;
    444					;--
    445
    446	003112				NARG:				; DIRECTIVE = KNARG
    447	003112					CALL SYMSCN				; SCAN SYMBOL NAME
    448	003116					IF R3 IS EQ THEN			; NAME THERE?
    449	003122					    CALL ERORLN,#DIRERR			; SYNTAX ERROR
    450	003132					    RETURN
    451	003134					END
    452	003134					CALL INSUST				; INSERT SYMBOL IN USER TABLE
    453	003140					LET R1		:= INPUTP		; POINT TO INPUT BLOCK
    454	003144					IF M.GETL(R1) NE #MACLIN THEN		; MACRO TYPE BODY?
    455	003154					    CALL ERORPT,#NTINMC			; NOT IN MACRO BODY
    456	003164					END;IF
    457	003164					LET SYMVL1(R2)	:= M.ARGC(R1)		; VALUE IS ARG COUNT
    458	003172					LET SYMVL2(R2)	:= 0			;
    459	003176					IF #S.DF SET.IN SYMFLAG(R2) AND #S.ASN OFF.IN SYMFLAG(R2) THEN
    460	003216					    CALL ERORPT,#MULTDF			; MULTIPLE DEFINITION!
    461	003226					END;IF
    462	003226					LET SYMFLAG(R2)	:= SYMFLAG(R2) SET.BY #S.DF+S.ABS+S.ASN
    463	003234					OUT #I.ASN,<R2,SYMSEG(R2),SYMVL1(R2),SYMVL2(R2),#1> ; ASSIGNMENT COMMAND
    464	003266					OUT #I.PRIL,<SYMVL1(R2),SYMVL2(R2)>	; PRINT VALUE
    465	003306					RETURN					;
    466					.SBTTL	NCHR	COUNT CHARACTERS IN ARGUMENT
    467					;++
    468					;
    469					; THIS ROUTINE COUNTS THE NUMBER OF CHARACTERS IN THE SPECIFIED ARGUMENT
    470					; AND ASSIGNS IT TO THE IDENTIFIER SUPPLIED.
    471					;
    472					;--
    473
    474	003310				NCHR:				; DIRECTIVE = KNCHR ID
    475	003310					PUSH FREEPT				; DON'T ALLOCATE ANY ARG
    476	003314					SPNOR					; IGNORE BLANKS
    477	003320					IF CHAR EQ #COMMA THEN			; COMMA?
    478	003330					    CALL GETCHR				; YES, SKIP OVER IT
    479	003334					END
    480	003334					LET DATRPT	:= FALSE		; NOT IRP
    481	003340					CALL ARGSCN				; SCAN ARGUMENT
    482	003344					POP FREEPT				; RESTORE CORE POINTER
    483	003350					LET R2		:= V1STACK(R4)		; POINT TO ARG
    484	003354					LET SYMVL1(R2)	:= @MCTXTL		; LENGTH OF ARG
    485	003362					LET SYMVL2(R2)	:= 0			;
    486	003366					IF #S.DF SET.IN SYMFLAG(R2) AND #S.ASN OFF.IN SYMFLAG(R2) THEN
    487	003406					    CALL ERORPT,#MULTDF			; MULTIPLE DEFINITION!
    488	003416					END;IF
    489	003416					LET SYMFLAG(R2)	:= SYMFLAG(R2) SET.BY #S.DF+S.ABS+S.ASN
    490	003424					OUT #I.ASN,<R2,SYMSEG(R2),SYMVL1(R2),SYMVL2(R2),#1> ; ASSIGNMENT COMMAND
    491	003456					OUT #I.PRIL,<SYMVL1(R2),SYMVL2(R2)>	; PRINT VALUE
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 40-1
NCHR	COUNT CHARACTERS IN ARGUMENT

    492	003476					RETURN
    493
    494
    495		000001 			.END
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 40-2
SYMBOL TABLE

ABSEXP= ****** GX	FREEPT= ****** GX	L17     001102R     002	NAMCOM  001332R     002	SYMVL1= 000004
ALIGN   001554RG    002	FRMPTR= ****** GX	L2      000256R     002	NARG    003112RG    002	SYMVL2= 000006
ALIGNP  002042R     002	FRMWRN= ****** GX	L20     001176R     002	NCHR    003310RG    002	S.ABS = 004000
ALIGNX  002216R     002	GCHARS  000274R     002	L21     001176R     002	NEXTCH= ****** GX	S.ASN = 000200
ALIGN1  002026RG    002	GETCHR= ****** GX	L22     001176R     002	NONAME  001344R     002	S.DBG = 002000
ALIGN2  002034RG    002	ID    = ****** GX	L24     001210R     002	NTHD1   002546RG    002	S.DF  = 100000
ALNTBG= ****** GX	IIII  = 177777   	L25     001346R     002	NTHD2   002536RG    002	S.EPT = 000100
ARGSCN= ****** GX	ILASEX= ****** GX	L26     001276R     002	NTINMC= ****** GX	S.EXTN= 010000
ASCCNT= ****** GX	IMODE = ****** GX	L27     001266R     002	NTYPE1  002710RG    002	S.GLOB= 020000
ASCCOM  000074R     002	INPUTP= ****** GX	L3      000414R     002	NTYPE2  002730RG    002	S.LOCL= 001000
ASCIC   000000RG    002	INSERT= ****** GX	L30     001326R     002	NTYPHD  002554R     002	S.ODBG= 000040
ASCII   000056RG    002	INSUST= ****** GX	L31     001326R     002	NTYPTR= ****** GX	S.REF = 000400
ASCIZ   000066RG    002	INVALN= ****** GX	L32     001422R     002	NUMBER= ****** GX	S.TKMS= 000377
BLNK  = 000040   	IREG  = ****** GX	L33     001462R     002	ODD     001502RG    002	S.WEAK= 040000
B0      000342R     002	I.ASN = ****** GX	L34     001500R     002	ODDEVE  001520R     002	TAB   = 000011
B1      001034R     002	I.AUGP= ****** GX	L35     001516R     002	OPSIZE= ****** GX	TYPS0 = 000000
B2      001156R     002	I.ERR = ****** GX	L36     001624R     002	OPTEXP= ****** GX	TYPS1 = 000000
B3      001422R     002	I.FLAG= ****** GX	L37     001744R     002	OUTFRA= ****** GX	TYPS2 = 000000
CHAR  = ****** GX	I.FNEW= ****** GX	L4      000366R     002	PACDAT= ****** GX	TYPS3 = 000000
CHARHD  000536RG    002	I.MACL= ****** GX	L40     001650R     002	PACERR= ****** GX	TYPS4 = 000000
CHRARG  000200RG    002	I.PRIL= ****** GX	L41     001744R     002	PACKED  000754RG    002	TYPS5 = 000000
CHRNUL  000140RG    002	I.PRT = ****** GX	L42     001706R     002	PAGE    002220RG    002	UNTERM= ****** GX
CHRTAB= ****** GX	I.STIB= ****** GX	L43     001722R     002	PAKERR  001156R     002	USRGEN= ****** GX
CNT   = 000006   	I.STKL= ****** GX	L44     001744R     002	PC1   = ****** GX	VAL1  = ****** GX
COMMA = 000054   	I.STRB= ****** GX	L45     002024R     002	PC2   = ****** GX	VAL2  = ****** GX
COMPEX= ****** GX	I.STSB= ****** GX	L46     002060R     002	PRINT   002316RG    002	V1STAC= ****** GX
CR    = 000015   	I.WRN = ****** GX	L47     002216R     002	PRMSEG= ****** GX	V2STAC= ****** GX
DATPTR= ****** GX	LBLS0 = 000060   	L5      000406R     002	PSECCH= 000020   	WARN    002262RG    002
DATRPT= ****** GX	LBLS1 = 000051   	L50     002136R     002	PSECOP= 000016   	WRTFRM= ****** GX
DIRERR= ****** GX	LBLS2 = 000044   	L51     002204R     002	PSECTO= ****** GX	XPC1  = ****** GX
DNUMBE= ****** GX	LBLS3 = 000043   	L52     002626R     002	PSECTP= ****** GX	XPC2  = ****** GX
EPWCOM  002330R     002	LBLS4 = 000023   	L53     003030R     002	PSECV1= 000012   	$DIDDO= 000000
ERORLN= ****** GX	LBLS5 = 000023   	L54     003134R     002	PSECV2= 000014   	$E$   = 000001
ERORPT= ****** GX	LCLIM = ****** GX	L55     003164R     002	PSTNUM= ****** GX	$F$   = 000000
ERROR   002300RG    002	LF    = 000012   	L56     003226R     002	PS.OPT= ****** GX	$I$   = 000001
ERROR1  002502RG    002	LFTANG= 000074   	L57     003334R     002	REG   = ****** GX	$L    = 000004
ERROR2  002442RG    002	LINEBF= ****** GX	L6      000476R     002	RGTANG= 000076   	$LL   = 000002
ERROR3  002512R     002	LINELN= ****** GX	L60     003416R     002	RTNVAL=%000000   	$L$   = 000000
EVALEX= ****** GX	LINEPT= ****** GX	L7      000602R     002	R6    =%000006   	$O$   = 000000
EVEN    001464RG    002	LISTIT= ****** GX	MACLIN= ****** GX	R7    =%000007   	$R    = 177777
EXPEND= ****** GX	LOWCAS= 000140   	MCTXTL= ****** GX	SEMI  = 000073   	$SV$  = 000000
EXPOPT= ****** GX	LPTCT = ****** GX	MEBLST= ****** GX	SKIPSP= ****** GX	$T    = 000061
EXPOP1= ****** GX	LPTLEN= 000074   	MODE  = ****** GX	SPACE = 000040   	$T1   = 000000
EXPOP2= ****** GX	L0      000212R     002	MULTDF= ****** GX	STRASC  000500R     002	$T2   = 000060
EXPPTR= ****** GX	L1      000246R     002	M.ARGC= 000014   	SYMCHR= 000012   	$Y$   = 000000
E0      000414R     002	L10     000752R     002	M.ARGS= 000016   	SYMFLA= 000002   	$Z$   = 000000
E1      001200R     002	L11     000752R     002	M.END = 000012   	SYMLEN= 000011   	$$S   = 000000
E2      001176R     002	L12     001016R     002	M.GETL= 000004   	SYMLIN= 000000   	$$T   = 000052
E3      001462R     002	L13     001034R     002	M.IFLV= 000006   	SYMMAX= 000017   	$$TT  = 000043
FF    = 000014   	L14     001030R     002	M.IFVL= 000010   	SYMSCN= ****** GX	.SAVRG= ****** GX
FINDSY= ****** GX	L15     001200R     002	M.LINK= 000000   	SYMSEG= 000010   	.$T   = 000001
FLTWDC= ****** GX	L16     001122R     002	M.NXTL= 000002

. ABS.	000000	   000
      	000000	   001
ACTCHR	003500	   002
ERRORS DETECTED:  0
ACTCHR	CHARACTER STRING ROUTIN	MACRO M1110  21-AUG-78 22:37  PAGE 40-3
SYMBOL TABLE


VIRTUAL MEMORY USED:  12431 WORDS  ( 49 PAGES)
DYNAMIC MEMORY:  13332 WORDS  ( 51 PAGES)
ELAPSED TIME:  00:04:43
OBJ$:ACTCHR,LIS$:ACTCHR/-SP=SRC$:MD,COMMON,ACTCHR
