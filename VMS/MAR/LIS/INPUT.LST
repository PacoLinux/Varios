INPUT	MACRO M1110  21-AUG-78 22:10
TABLE OF CONTENTS

    32-    3	GETCHR	ROUTINE TO READ NEXT CHARACTER FROM FILE
    33-   63	MACLIN		EXPAND MACRO TEXT LINE
    34-  155	RPTLIN		REPEAT DRIVER
    34-  175	IRPLIN		IRP DRIVER
    35-  201	IRPCLN		IRPC DRIVER
    35-  227	NEWBLK		ROUTINE TO BUILD NEW INPUT BLOCK
    36-  249	MEXIT		MACRO EXIT ROUTINE
    37-  273	STATEMENTS	END-OF-LINE CLEANUP
    38-  293	STAT4		SWITCH INPUT TO MACRO TEXT
    39-  330	GETARGS		ACCUMULATE REAL MACRO ARGS
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 32


      1					.TITLE INPUT
      2	000000				.PSECT	INPUT
      3					.SBTTL	GETCHR	ROUTINE TO READ NEXT CHARACTER FROM FILE
      4					;
      5					;	GETCHR -- GET NEXT CHARACTER FROM SOURCE LINE BUFFER
      6					;
      7					; IF A COMMENT OR END OF LINE IS DETECTED, A NEW SOURCE LINE IS READ.
      8					; CHARACTER IS RETURNED IN CHAR AND IN R0.
      9					;
     10
     11						.LIST	MEB
     12	000000				GETCHR::
     13
     14	000000				    WHILEB CHAR EQ #CR				; READ NEW LINE?
	000000	126727 	000000G	000015 									CMPB CHAR,#CR
	000006	001036 											BNE L0
     15	000010					LET CHAR	:= #BLNK		; PREVENT LOOPING ON THIS CR
	000010	012767 	000040 	000000G									MOV #BLNK,CHAR
     16	000016					CALL SYMFUL				; OUT OF ROOM?
	000016	004767 	000000G										JSR PC,SYMFUL
     17	000022					LET R0		:= INPUTP		; POINT TO INPUT BLOCK
	000022	016700 	000000G										MOV INPUTP,R0
     18	000026					LET CONTLN	:= TRUE			; ALLOW LINE CONTINUATION
	000026	012767 	177777 	000000G									MOV #-1,CONTLN
     19	000034					CALL @M.GETL(R0)			; CALL INPUT ROUTINE
	000034	004770 	000004 										JSR PC,@M.GETL(R0)
     20	000040					LET R0		:= INPUTP		; POINT TO INPUT BLOCK
	000040	016700 	000000G										MOV INPUTP,R0
     21	000044					IF M.GETL(R0) EQ #GETLIN THEN		; READING SOURCE FILE?
	000044	026027 	000004 	000000G									CMP M.GETL(R0),#GETLIN
	000052	001006 											BNE L1
     22	000054					    OUT	#I.NEWL,LINENM			; SIGNAL NEW LINE
	000054	016746 	000000G			MOV LINENM,-(SP)				; PUSH DATA ONTO STACK
	000060	012746 	000000C			MOV	#I.NEWL*256.+CNT,-(SP)		; ENCODE ACTION-LENGTH
	000064	004767 	000000G			JSR	PC,OUTFRA
     23	000070					END;IF
     24	000070					LET NEXTCH	:B= LINEBF		; GET FIRST CHAR IN BUFFER
	000070	116767 	000000G	000000G									MOVB LINEBF,NEXTCH
     25	000076					LET LINEPT	:= LINEPT +1		; POINT TO NEXT CHAR
	000076	005267 	000000G										INC LINEPT
     26	000102				    END;W					; INPUT ROUTINE MAY RETURN "CR"
	000102	000736 											BR B0
     27
     28	000104					LET R0		:= NEXTCH		; GET CURRENT CHAR
	000104	016700 	000000G										MOV NEXTCH,R0
     29	000110					LET NEXTCH	:B= @LINEPT		; PICK UP NEXT CHAR
	000110	117767 	000000G	000000G									MOVB @LINEPT,NEXTCH
     30	000116					LET LINEPT	:= LINEPT +1		; POINT TO NEXT CHAR
	000116	005267 	000000G										INC LINEPT
     31	000122					IF R0 EQ #SEMI AND CHAR IS NE THEN	; COMMENT AND NOT SPECIAL
	000122	020027 	000073 										CMP R0,#SEMI
	000126	001005 											BNE L2
	000130	005767 	000000G										TST CHAR
	000134	001402 											BEQ L2
     32	000136					    LET R0 := #CR			; THEN CALL IT EOL
	000136	012700 	000015 										MOV #CR,R0
     33	000142					END
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 32-1
GETCHR	ROUTINE TO READ NEXT CHARACTER FROM FILE

     34	000142					IF R0 HIS LCLIM THEN			; IS CHARACTER LOWER CASE?
	000142	020067 	000000G										CMP R0,LCLIM
	000146	103402 											BLO L3
     35	000150					    LET R0 := R0 OFF.BY #^O40		; CONVERT TO UPPER CASE
	000150	042700 	000040 										BIC #^O40,R0
     36	000154					END
     37	000154					LET CHAR	:= R0			; SAVE CURRENT CHAR
	000154	010067 	000000G										MOV R0,CHAR
     38	000160					IF R0 EQ #'- AND CONTLN IS TRUE THEN	; LINE CONTINUATION?
	000160	020027 	000055 										CMP R0,#'-
	000164	001100 											BNE L4
	000166	005767 	000000G										TST CONTLN
	000172	001475 											BEQ L4
     39	000174					    PUSH CHAR,NEXTCH,LINEPT		; SAVE CURRENT STATE
	000174	016746 	000000G										MOV CHAR,-(SP)
	000200	016746 	000000G										MOV NEXTCH,-(SP)
	000204	016746 	000000G										MOV LINEPT,-(SP)
     40	000210					    LET CONTLN	:= FALSE		; DON'T RECURSE ON LINES THAT
	000210	005067 	000000G										CLR CONTLN
     41											; HAVE ALL "-".
     42	000214					    LET CHAR	:= #BLNK		; IGNORE CURRENT CHAR
	000214	012767 	000040 	000000G									MOV #BLNK,CHAR
     43	000222					    WHILE CHAR EQ #BLNK OR CHAR EQ #TAB ; SKIP OVER TABS AND BLANKS
	000222	026727 	000000G	000040 									CMP CHAR,#BLNK
	000230	001404 											BEQ L5
	000232	026727 	000000G	000011 									CMP CHAR,#TAB
	000240	001003 											BNE L6
     44	000242						CALL GETCHR			; RECURSIVE CALL TO GET NON-BLANK
	000242	004767 	177532 										JSR PC,GETCHR
     45	000246					    END
	000246	000765 											BR B1
     46	000250					    IF CHAR EQ #CR THEN			; IS THIS EOL?
	000250	026727 	000000G	000015 									CMP CHAR,#CR
	000256	001030 											BNE L7
     47	000260						LET SP	:= SP + #6		; CONTEXT NOT NEEDED
	000260	062706 	000006 										ADD #6,SP
     48	000264						CALL GETCHR			; READ NEXT LINE
	000264	004767 	177510 										JSR PC,GETCHR
     49	000270						OUT	#I.CHKL			; INSURE ALIGN OF CONTINUED LINES
	000270	012746 	000000C			MOV	#I.CHKL*256.+CNT,-(SP)		; ENCODE ACTION-LENGTH
	000274	004767 	000000G			JSR	PC,OUTFRA
     50	000300						WHILE R0 EQ #CR OR R0 EQ #FF OR R0 EQ #SEMI ; NULL LINE ?
	000300	020027 	000015 										CMP R0,#CR
	000304	001406 											BEQ L10
	000306	020027 	000014 										CMP R0,#FF
	000312	001403 											BEQ L10
	000314	020027 	000073 										CMP R0,#SEMI
	000320	001006 											BNE L11
     51	000322						    LET CHAR := #CR		; TREAT AS EOL
	000322	012767 	000015 	000000G									MOV #CR,CHAR
     52	000330						    CALL GETCHR			; READ NEXT LINE
	000330	004767 	177444 										JSR PC,GETCHR
     53	000334						END
	000334	000761 											BR B2
     54	000336					    ELSE				; NOT REALLY CONTINUED LINE!!!!
	000336	000410 											BR L12
     55	000340						POP LINEPT,NEXTCH,CHAR		; RESTORE STATE
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 32-2
GETCHR	ROUTINE TO READ NEXT CHARACTER FROM FILE

	000340	012667 	000000G										MOV (SP)+,LINEPT
	000344	012667 	000000G										MOV (SP)+,NEXTCH
	000350	012667 	000000G										MOV (SP)+,CHAR
     56	000354						LET R0	:= CHAR			; PICK UP CHAR
	000354	016700 	000000G										MOV CHAR,R0
     57	000360					    END
     58	000360					    LET CONTLN	:= TRUE			; RESTORE CONTINUED LINE FLAG
	000360	012767 	177777 	000000G									MOV #-1,CONTLN
     59	000366					END;IF
     60	000366					RETURN					;
	000366	000207 											RTS PC
     61						.NLIST	MEB
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 33
MACLIN		EXPAND MACRO TEXT LINE

     63					.SBTTL	MACLIN		EXPAND MACRO TEXT LINE
     64					;++
     65					;
     66					; 'MACLIN' IS A LINE INPUT ROUTINE WHICH EXPANDS A MACRO LINE
     67					; AND PLACES IT IN 'LINEBF'.  WHEN ARGUMENTS ARE FOUND IN THE
     68					; LINE, THE MACRO ARGUMENT BLOCK IS INSPECTED, AND THE ARGUMENT
     69					; IS COPIED INTO THE LINE.  THIS ROUTINE POPS THE INPUT POINTER
     70					; WHEN THE END OF THE MACRO TEXT IS REACHED.
     71					;
     72					;--
     73	000370				MACLIN::
     74
     75	000370					SAVRG					; SAVE R1 - R3
     76	000374					PUSH	R4
     77	000376					LET R1		:= INPUTP		; POINT TO INPUT BLOCK
     78	000402					LET R2		:= M.NXTL(R1)		; POINT TO NEXT LINE
     79	000406					LET R3		:= (R2)+		; GET LINE'S LENGTH
     80	000410					IF R3 IS NE THEN			; REALLY A LINE?
     81	000414					    LET R4	:= #LINEBF		; OUTPUT POINTER
     82	000420					    LET LINEPT	:= R4			; RESET INPUT POINTER
     83	000424					    LET R3	:= R3 - #2		; MINUS CHAR COUNT
     84	000430					    WHILE R3 IS GT			; ONCE PER CHAR
     85	000434						LET R3	:=  R3 -1		; COUNT NEXT CHAR
     86	000436						LET R0	:B= (R2)		; READ NEXT CHAR
     87	000440						IFB R0 EQ #MCARG THEN		; IS IT AN ARGUMENT?
     88	000446						    LET R2 :=  R2 +1		; SKIP OVER MARKER
     89	000450						    LET R0 :B= (R2)+		; GET ARGUMENT NUMBER
     90	000452							LET R3	:= R3 -1	; MINUS MARKER
     91	000454							PUSH R2
     92	000456							LET R2 := R0 L.SHIFT 1 + #M.ARGS-2 + R1
     93	000470							IF (R2) IS NE THEN	; NULL ARG?
     94	000474							    LET R2 := R2 + (R2)	; POINT TO ARG DESCRIPTOR
     95	000476							    LET R0 := (R2)+	; NO
     96	000500							ELSE
     97	000502							    LET R0 := 0		; YES
     98	000504							END
     99	000504							IF R0 IS NE THEN	; REALLY NULL?
    100	000510							    REPEAT THRU R0	; COPY ARG INTO OUTPUT
    101	000510								LET (R4) :B= (R2)+
    102	000512								IF R4 LO #LINEBN THEN LET R4 := R4 +1
    103	000522							    END
    104	000524							END
    105	000524							POP R2
    106	000526						ELSE
    107	000530						    IFB (R2) IS NE THEN		; ZERO?
    108	000534							LET (R4) :B= (R2)+	; COPY CHAR
    109	000536							IF R4 LO #LINEBN THEN LET R4 := R4 +1
    110	000546						    END
    111	000546						END
    112	000546					    END
    113	000550					    IF R4 HIS #LINEBN THEN		; TOO BIG?
    114	000556						OUT #I.ERR,<#LNTLNG,#LINEBF>	; LINE TOO LONG
    115	000576					    END
    116	000576					    LET (R4)+	:B= #CR			; END LINE WITH CR
    117	000602					    LET (R4)	:B= 0			; ZERO NEXT BYTE TOO
    118	000604					    LET R4	:= R4 - #<LINEBF+1>	; CALCULATE LENGTH OF LINE (NO "CR")
    119	000610					    LET LINELN	:= R4			; SAVE LENGTH OF LINE
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 33-1
MACLIN		EXPAND MACRO TEXT LINE

    120	000614					    LET R2	:= M.NXTL(R1)		; POINT TO THIS LINE
    121	000620					    LET R2	:= R2 + (R2)		; POINT TO NEXT LINE
    122	000622					    LET M.NXTL(R1) := R2 +1 OFF.BY #1	; SAVE PTR TO NEXT LINE
    123	000640					    OUT		#I.CHKL			; SKIP AHEAD 1 LINE
    124	000650					    LET R0	:= R4 + FRMPTR		; FIND WHERE LINE ENDS IN BUFFER
    125	000656					    IF R0 HIS #FRMPTR-10 THEN		; DOES LINE FIT IN BUFFER?
    126											; OVRHD FOR LINE IS 6 BYTES MAX
    127	000664						CALL WRTFRM			; WRITE OUT BUFFER IF NOT
    128	000670					    END
    129	000670					    LET R4	:= R4 + #2 OFF.BY #1	; ROUND LINE LENGTH UP (WITH "CR")
    130	000700					    LET R3	:= FRMPTR		; POINT INTO BUFFER
    131	000704					    LET (R3)+	:B= #-1			; SIGNAL SPECIAL LINE
    132	000710					    LET (R3)+	:B= #I.MACL		; THIS IS A MACRO LINE
    133	000714					    IF LS.ME+SYMVL2 IS NE OR LS.MEB+SYMVL2 IS NE OR LISTLV IS GT THEN
    134											; IS THIS LINE TO BE LISTED
    135	000736						LET (R3)+ := R4			; FILL IN REAL LENGTH
    136	000740						LET R1	  := #LINEBF		; POINT TO LINE BUFFER
    137	000744						LET R4	  := R4 R.SHIFT		; NUMBER OF WORDS TO TRANSFER
    138	000746						REPEAT THRU R4			; COPY LINE INTO BUFFER
    139	000746						    LET (R3)+ := (R1)+		; COPY 2 CHARS AT A TIME
    140	000750						END;R
    141	000752					    ELSE
    142	000754						LET (R3)+ := 0			; ZERO LENGTH LINE
    143	000756					    END;IF
    144	000756					    LET FRMPTR	:= R3			; RESTORE POINTER
    145	000762					ELSE
    146	000764					    IF IFLVL IS NE THEN			; IF LEVEL IN MACRO SHOULD BE 0
    147	000772						OUT #I.WRN,<#UNTCND,LINEPT>	; UNTERMINATED CONDITIONAL
    148	001012					    END
    149	001012					    CALL POPINP				; POP BACK 1 LEVEL
    150	001016					END
    151	001016					LET ERRPTX	:= #LINEBF		; RESET ERROR POINTER
    152	001024					POP	R4
    153	001026					RETURN					;
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 34
RPTLIN		REPEAT DRIVER

    155					.SBTTL	RPTLIN		REPEAT DRIVER
    156					;++
    157					;
    158					; ROUTINE TO CALL REPEAT RANGE N TIMES
    159					;
    160					;--
    161	001030				RPTLIN::
    162
    163	001030					SAVRG					; SAVE R1 - R3
    164	001034					LET R2		:= INPUTP		; GET INPUT POINTER
    165	001040					IF M.ARGC(R2) IS LE THEN		; ALL DONE?
    166	001046					    CALL POPINP				; POP INPUT CONTEXT
    167	001052					ELSE
    168	001054					    LET R3	:= FRIEND - #M.ARGS+2	; ALLOCATE INPUT BLOCK
    169	001064					    CALL NEWBLK				; BUILD NEW INPUT BLOCK
    170	001070					    CALL MACLIN				; READ IN NEW LINE
    171	001074					END;IF
    172	001074					RETURN					;
    173
    174
    175					.SBTTL	IRPLIN		IRP DRIVER
    176					;++
    177					;
    178					;
    179					;--
    180	001076				IRPLIN::
    181
    182	001076					SAVRG					; SAVE R1 - R3
    183	001102					LET R2		:= INPUTP		; GET INPUT POINTER
    184	001106					IF M.ARGC(R2) IS LE THEN		; NO ARGUMENTS LEFT?
    185	001114					    CALL POPINP				; POP INPUT CONTEXT
    186	001120					ELSE
    187	001122					    LET R3	:= FRIEND - #M.ARGS+2	; ALLOCATE INPUT BLOCK
    188	001132					    CALL NEWBLK				; BUILD NEW INPUT BLOCK
    189	001136					    LET R1		:= M.ARGS(R2)	; POINT TO ARG
    190	001142					    LET R0		:= (R1)+	; PICK UP ARG
    191	001144					    LET M.ARGS(R2)	:= R1		; RESET POINTER
    192	001150					    IF R0 IS EQ THEN			; NULL ARG?
    193	001154						LET M.ARGS(R3)	:= R1		; YES
    194	001160					    ELSE
    195	001162						LET M.ARGS(R3)	:= R0 - R3 - #M.ARGS ; SET OFFSET TO ARG
    196	001200					    END;IF
    197	001200					    CALL MACLIN				; READ IN NEW LINE
    198	001204					END;IF
    199	001204					RETURN					;
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 35
IRPCLN		IRPC DRIVER

    201					.SBTTL	IRPCLN		IRPC DRIVER
    202					;++
    203					;
    204					; PROCEDURE TO CALL IRPC MACRO WITH DIFFERENT CHARACTER EACH TIME.
    205					;
    206					;--
    207	001206				IRPCLN::
    208
    209	001206					SAVRG					; SAVE R1 - R3
    210	001212					LET R2		:= INPUTP		; GET INPUT POINTER
    211	001216					IF M.ARGC(R2) IS LE THEN		; DONE?
    212	001224					    CALL POPINP				; POP INPUT CONTEXT
    213	001230					ELSE
    214	001232					    LET R3	:= FRIEND - #M.ARGS+6	; MAKE INPUT BLOCK (+3 WORD ARG)
    215	001242					    CALL NEWBLK				; BUILD NEW INPUT BLOCK
    216	001246					    LET R1		:= M.ARGS(R2)	; POINT TO ARG
    217	001252					    LET R0		:B= (R1)+	; GET NEXT CHAR
    218	001254					    LET M.ARGS(R2)	:= R1		; RESTORE POINTER
    219	001260					    LET M.ARGS(R3)	:= #2		; OFFSET TO ARGUMENT
    220	001266					    LET M.ARGS+2(R3)	:= #1		; ARGUMENT IS ONE BYTE LONG
    221	001274					    LET M.ARGS+4(R3)	:= R0		; STORE CHARACTER ARGUMENT
    222	001300					    CALL MACLIN				; READ IN FIRST LINE
    223	001304					END;IF
    224	001304					RETURN					;
    225
    226
    227					.SBTTL	NEWBLK		ROUTINE TO BUILD NEW INPUT BLOCK
    228					;++
    229					;
    230					; R3 HAS THE NEW VALUE OF "FRIEND" IT MUST BE GREATER THAN "FREEPT"
    231					;
    232					;--
    233	001306				NEWBLK:
    234	001306					IF R3 LOS FREEPT THEN JUMPTO DIE ; NOT ENOUGH ROOM FOR NEW INPUT BLOCK
    235	001320					LET M.ARGC(R2)	:= M.ARGC(R2) -1 ; COUNT ARGUMENT
    236	001324					LET M.LINK(R3)	:= R2		; SET UP LINK
    237	001330					LET M.NXTL(R3)	:= M.NXTL(R2)	; POINT TO TEXT
    238	001336					LET M.GETL(R3)	:= #MACLIN	; MACRO TYPE INPUT
    239	001344					LET M.IFLV(R3)	:= IFLVL	; SAVE IF LEVEL
    240	001352					LET M.IFVL(R3)	:= IFVAL	; SAVE IF VALUE
    241	001360					LET M.END(R3)	:= FRIEND	; HIGH CORE PTR
    242	001366					LET M.ARGC(R3)	:= #1		; ONE ARG
    243	001374					LET IFLVL	:= 0		; NO IFS
    244	001400					LET IFVAL	:= 0		; NO VALUES
    245	001404					LET INPUTP	:= R3		; SWITCH INPUT
    246	001410					LET FRIEND	:= R3		; ALLOCATE BLOCK
    247	001414					RETURN				;
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 36
MEXIT		MACRO EXIT ROUTINE

    249					.SBTTL	MEXIT		MACRO EXIT ROUTINE
    250					;++
    251					; MEXIT -- EXIT FROM ONE LEVEL OF MACRO NESTING.
    252					;--
    253
    254	001416				MEXIT::				; DIRECTIVE = KMEXIT
    255	001416					CALL	POPINP				; POP INPUT CONTEXT BLOCK
    256	001422					LET R0		:= M.GETL(R0)		; GET ADDR OF THIS INPUT ROUTINE
    257	001426					IF R0 EQ #RPTLIN OR R0 EQ #IRPLIN OR R0 EQ #IRPCLN THEN
    258	001450					    CALL POPINP				; POP ONCE MORE IF "REPEAT-TYPE"
    259	001454					END;IF
    260	001454					RETURN					;
    261
    262
    263	001456				POPINP:				; POP INPUT CONTEXT BLOCK
    264	001456					LET R1		:= INPUTP		; POINT TO CURRENT INPUT SPECS
    265	001462					LET FRIEND	:= M.END(R1)		; DEALLOCATE BLOCK
    266	001470					LET R0		:= M.LINK(R1)		; POP INPUT POINTER
    267	001474					LET IFVAL	:= M.IFVL(R1)		; RESET IF VALUES
    268	001502					LET IFLVL	:= M.IFLV(R1)		; IF LEVEL
    269	001510					LET INPUTP	:= R0
    270	001514					LET CHAR	:= #CR			; FORCE READING OF NEW LINE
    271	001522					RETURN
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 37
STATEMENTS	END-OF-LINE CLEANUP

    273					.SBTTL	STATEMENTS	END-OF-LINE CLEANUP
    274					;
    275					;
    276					; AFTER EACH STATEMENT THE FLAGS 'BOL' AND 'OPRND' NEED TO BE RESET
    277					; SO THAT IDENTIFIERS WILL BE ENTERED IN THE CORRECT TABLES.
    278					;
    279					;
    280	001524				MTXT1::				; MARS_TEXT = STATEMENT DDEOL
    281	001524				MTXT2::				; MARS_TEXT = MARS_TEXT STATEMENT DDEOL
    282	001524				MTXT3::				; MARS_TEXT = DDEOL
    283	001524				MTXT4::				; MARS_TEXT = MARS_TEXT DDEOL
    284	001524					OUT #I.CHKL				; ALIGN LISTING AND SOURCE
    285	001534					LET BOL		:= TRUE			; AT BEGINNING OF LINE
    286	001542					LET OPRND	:= FALSE		; NOT IN OPERAND FIELD
    287	001546					LET IFSTAT	:= FALSE		; NOT IF
    288	001552					LET IRPSTAT	:= FALSE		; NOT IRP
    289	001556					LET EVALEXPR	:= TRUE			; EVALUATE EXPRESSIONS
    290	001564					LET RDXPTR	:= #DNUMBER		; RESET NUMERIC RADIX
    291	001572					RETURN
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 38
STAT4		SWITCH INPUT TO MACRO TEXT

    293					.SBTTL	STAT4		SWITCH INPUT TO MACRO TEXT
    294					;
    295					; THIS SEMANTIC ROUTINE SWITCHES THE POINTER TO THE CURRENT INPUT
    296					; BLOCK ('INPUTP') TO POINT TO THE MACRO BEING EXPANDED.  THIS
    297					; CAUSES THE 'GETCHR' ROUTINE TO READ NEW LINES OF INPUT FROM THE
    298					; MACRO EXPANDER ('MACLIN').
    299					;
    300
    301	001574				STAT4::				; STATEMENT = MACTXT
    302	001574					IF LS.MC+SYMVL2 IS EQ THEN		; LIST MACRO CALL?
    303	001602					    OUT #I.FLAG,<#0,#LISTIT>		; NO!
    304	001622					END
    305	001622					LET R2		:= V1STACK(R4)		; POINT TO MACRO NAME BLOCK
    306	001626					LET MCNAM	:= R2			; SAVE NAME POINTER
    307	001632					IF SYMVL1(R2) IS EQ THEN		; NULL MACRO?
    308	001640					    LET CHAR	:= #CR			; READ NEW LINE
    309	001646					    RETURN				; AND TAKE FAST EXIT
    310	001650					END
    311	001650					LET R0		:B= SYMLEN(R2)		; LENGTH OF NAME
    312	001654					LET R0		:= R0 +1 OFF.BY #1 + #SYMCHRS + R2 ; POINT PAST NAME
    313	001670					LET KEYMAC	:= (R0)			; POINT TO KEYWORD NAMES
    314	001674					IF KEYMAC EQ SYMVL1(R2) THEN LET KEYMAC := 0 ; NO ARGS
    315	001710					CALL GETARGS				; SCAN REAL ARGUMENTS
    316	001714					LET KEYMAC	:= 0			; NO MORE KEYWORDS
    317	001720					LET R1		:= FRIEND		; POINT TO END OF FREE CORE
    318	001724					LET M.END(R3)	:= R1			; SAVE POINTER IN BLOCK
    319	001730					LET R2		:= FREEPT		; POINT PAST ARGUMENTS
    320	001734					REPEAT THRU R0	:= R2 - R3 R.SHIFT 1	; SLIDE ARGUMENTS DOWN
    321	001742					    LET -(R1)	:= -(R2)
    322	001744					END
    323	001746					LET INPUTP	:= R1			; POINT TO NEW INPUT BLOCK
    324	001752					LET FRIEND	:= R1			; ALLOCATE BLOCK
    325	001756					LET FREEPT	:= R3			; DEALLOCATE OLD BLOCK
    326	001762					LET CHAR	:= #CR			; FORCE READING OF NEW LINE
    327	001770					RETURN
    328
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 39
GETARGS		ACCUMULATE REAL MACRO ARGS

    330					.SBTTL	GETARGS		ACCUMULATE REAL MACRO ARGS
    331					;
    332					;
    333					; THIS ROUTINE BUILDS A MACRO ARGUMENT BLOCK AT THE END OF FREE
    334					; CORE.  THIS BLOCK IS DESCRIBED ABOVE WHERE THE OFFSETS ARE
    335					; DEFINED.  THE ARGUMENT BLOCK IS ALLOCATED AT THE END OF FREE
    336					; CORE, AND UPON EXIT R3 WILL POINT TO THE START OF THE BLOCK,
    337					; AND AS USUAL, 'FREEPT' POINTS PAST THE END.
    338					;
    339
    340	001772				PROCEDURE	GETARGS				; GET MACRO ARGUMENTS
    341
    342	001772					CALL SYMFUL				; CHECK FOR ROOM
    343	001776					LET R2		:= MCNAM		; POINT TO MACRO NAME BLOCK
    344	002002					LET R3		:= FREEPT		; POINT TO FREE CORE
    345	002006					LET M.LINK(R3)	:= INPUTP		; POINT TO PREVIOUS INPUT BLOCK
    346	002014					LET M.NXTL(R3)	:= SYMVL1(R2)		; POINT TO FIRST LINE
    347	002022					LET M.GETL(R3)	:= #MACLIN		; MACRO LINE EXPANDER
    348	002030					LET M.IFLV(R3)	:= IFLVL		; IF LEVEL
    349	002036					LET IFLVL	:= 0			; NO IFS
    350	002042					LET M.IFVL(R3)	:= IFVAL		; IF VALUES
    351	002050					LET IFVAL	:= 0			; NO VALUES
    352	002054					LET R0		:B= SYMSEG(R2)		; GET # OF FORMAL ARGS
    353	002060					LET MCARGC	:= R0			; SAVE COUNT
    354	002064					LET M.ARGC(R3)	:= R0			; SET COUNT IN BLOCK
    355	002070					LET R2		:= #M.ARGS + R3		; POINT TO ARG OFFSET LIST
    356	002076					LET FREEPT	:= R2			; ALLOCATE BLOCK HEADER
    357	002102					IF R0 IS NE THEN			; ANY ARGUMENTS?
    358	002106					    PUSH R2
    359	002110					    REPEAT THRU R0			; ZERO OUT OFFSETS
    360	002110						LET (R2)+ := 0
    361	002112					    END
    362	002114					    LET FREEPT	:= R2			; ALLOCATE OFFSET LIST
    363	002120					    POP R2				; POINT BACK TO START
    364	002122					    SPNOR				; IGNORE BLANKS
    365	002126					    REPEAT				; OBTAIN OFFSETS TO ARGS
    366	002126						LET DATRPT	:= FALSE	; NOT IRP
    367	002132						IF CHAR EQ #CR AND #100000 OFF.IN M.ARGC(R3) THEN ; END?
    368	002152						    LET R0 := MCNAM		; POINT TO MACRO NAME
    369	002156						    LET R0 :B= SYMSEG(R0)	; GET # OF ARGS
    370	002162						    LET R0 := R0 - MCARGC SET.BY #100000 ; COUNT OF ARGS
    371	002172						    LET M.ARGC(R3) := R0	; SAVE IN BLOCK
    372	002176						END
    373	002176						CALL ARGSCN			; GET NEXT ARGUMENT
    374	002202						LET R0		:= KEYPTR	; KEYWORD ARG?
    375	002206						IF RESULT IS NE THEN
    376	002210						    LET R0	:= SYMVL1(R0) L.SHIFT 1 + #M.ARGS-2 + R3
    377	002224						    LET R1	:= MCTXTL - R0	; OFFSET TO ARG
    378	002232						    LET (R0)	:= R1		; FILL IN OFFSET
    379	002234						ELSE
    380	002236						IF @MCTXTL IS EQ THEN		; NULL ARG?
    381	002244						    PUSH	R2,R3		; YES, SAVE REGS
    382	002250						    LET R0	:= MCNAM	; POINT TO MACRO NAME
    383	002254						    LET R1	:B= SYMSEG(R0)	; GET ARG COUNT
    384	002260						    LET R1	:= R1 - MCARGC	; GET ARG # - 1
    385	002264						    LET R2	:= #1 SHIFT R1	; SHIFT A BIT
    386	002272						    IF R2 SET.IN SYMVL2(R0) THEN ; CREATED SYMBOL?
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 39-1
GETARGS		ACCUMULATE REAL MACRO ARGS

    387	002300							LET R3	:= MCTXTL	; POINT TO ARG LOC
    388	002304							LET (R3)+ := 0		; SKIP OVER COUNT
    389	002306							LPUSH CRSYM,#0		; PUSH CREATED SYM NUM
    390	002326							LET CRSYM := CRSYM +1	; INCREMENT SYM NUM
    391	002332							CALL DECLR		; OUTPUT IN DECIMAL
    392	002336							LET (R3)+ :B= #'$	; FOLLOWED BY A '$'
    393	002342							LET @MCTXTL := R3 - FREEPT ; SET LENGTH
    394	002354							LET FREEPT := R3 +1 OFF.BY #1	; ALLOCATE ARG
    395	002372						    END
    396	002372						    POP R3,R2			; RESTORE REGS
    397	002376						END
    398	002376						IF @MCTXTL IS EQ THEN		; STILL NULL ARG?
    399	002404						    LET FREEPT := MCTXTL	; YES! DEALLOCATE ZERO COUNT
    400	002412						    LET R2	:= R2 + #2	; BUMP POINTER
    401	002416						ELSE
    402	002420						    LET R0	:= MCTXTL - R2	; OFFSET TO ARG
    403	002426						    LET (R2)+	:= R0		; FILL IN OFFSET
    404	002430						END
    405	002430						LET MCARGC	:= MCARGC -1	; COUNT THIS ARG
    406	002434						END
    407	002434					    UNTIL MCARGC IS LE			; FIND ALL ARGS
    408	002442					    LET M.ARGC(R3) := M.ARGC(R3) OFF.BY #100000 ; CLEAR MARKER
    409	002450					END
    410
    411					;
    412					; FILL IN DEFAULT ARGUMENTS
    413					;
    414	002450					LET R2		:= MCNAM		; POINT TO MACRO NAME
    415	002454					LET R0		:B= SYMSEG(R2)		; GET NUMBER OF ARGS
    416	002460					LET R2		:= #M.ARGS + R3	; POINT TO ARG OFFSETS
    417	002466					LET MCARGC	:= #1			; FIRST ARG
    418	002474					IF R0 IS NE AND KEYMAC IS NE THEN	; ANY DEFAULTS?
    419	002506					    REPEAT THRU R0			; ONCE PER ARG
    420	002506						PUSH R0				; SAVE COUNT
    421	002510						IF (R2)+ IS EQ THEN		; NULL ARG?
    422	002514						    LET R1	:= KEYMAC	; POINT TO KEYWORDS
    423	002520						    WHILE R1 IS NE		; ONCE PER KEYWORD
    424	002524							IF SYMVL1(R1) EQ MCARGC THEN ; THIS THE ARG?
    425	002534							    LET R1 := SYMVL2(R1) ; POINT TO DEFAULT ARG
    426	002540							    IF R1 IS NE THEN	; IF DEFAULT WAS SPECIFIED
    427	002544								PUSH R3,R2	; SAVE REGS
    428	002550								LET R2 := (R1)+	; GET LENGTH OF ARG
    429	002552								LET R3 := FREEPT ; WHERE ARG GOES
    430	002556								LET (R3)+ := R2	; FILL IN THE LENGTH
    431	002560								IF R2 IS NE THEN ; IF DEFAULT NOT NULL
    432	002564								    REPEAT THRU R2 ; ONCE PER ARG CHAR
    433	002564									LET (R3)+ :B= (R1)+ ; COPY DEFAULT
    434	002566								    END
    435	002570								END
    436	002570								LET R1	:= 0	; STOP LOOPING
    437	002572								POP R2		; RESTORE REGS
    438	002574								LET R2 := R2 - #2 ; BACK UP POINTER
    439	002600								LET R0 := FREEPT - R2 ; OFFSET TO ARG
    440	002606								LET (R2)+ := R0	; FILL IN OFFSET
    441	002610								LET FREEPT := R3 +1 OFF.BY #1 ; ALLOCATE ARG (ROUNDED)
    442	002626								POP R3		; RESTORE POINTER
    443	002630							    END
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 39-2
GETARGS		ACCUMULATE REAL MACRO ARGS

    444	002630							ELSE
    445	002632							    LET R1 := (R1)
    446	002634							END
    447	002634						    END
    448	002636						END
    449	002636					    LET MCARGC	:= MCARGC +1		; COUNT THE ARG
    450	002642					    POP R0				; RESTORE COUNT
    451	002644					    END
    452	002646					END;IF
    453	002646				ENDPROCEDURE GETARGS
    454
    455		000001 			.END
INPUT	MACRO M1110  21-AUG-78 22:10  PAGE 39-3
SYMBOL TABLE

ARGSCN= ****** GX	IFSTAT= ****** GX	L16     000502R     002	L71     002634R     002	SYMVL1= 000004
A3    = 000002   	IFVAL = ****** GX	L17     000504R     002	MACLIN  000370RG    002	SYMVL2= 000006
BLNK  = 000040   	IIII  = 177777   	L2      000142R     002	MCARG = ****** GX	S.ABS = 004000
BOL   = ****** GX	INPUTP= ****** GX	L20     000524R     002	MCARGC= ****** GX	S.ASN = 000200
B0      000000R     002	IRPCLN  001206RG    002	L21     000522R     002	MCNAM = ****** GX	S.DBG = 002000
B1      000222R     002	IRPLIN  001076RG    002	L22     000546R     002	MCTXTL= ****** GX	S.DF  = 100000
B10     002126R     002	IRPSTA= ****** GX	L23     000546R     002	MEXIT   001416RG    002	S.EPT = 000100
B11     002506R     002	I.CHKL= ****** GX	L24     000546R     002	MTXT1   001524RG    002	S.EXTN= 010000
B12     002520R     002	I.ERR = ****** GX	L25     000576R     002	MTXT2   001524RG    002	S.GLOB= 020000
B13     002564R     002	I.FLAG= ****** GX	L26     000670R     002	MTXT3   001524RG    002	S.LOCL= 001000
B2      000300R     002	I.MACL= ****** GX	L27     000736R     002	MTXT4   001524RG    002	S.ODBG= 000040
B3      000430R     002	I.NEWL= ****** GX	L3      000154R     002	M.ARGC= 000014   	S.REF = 000400
B4      000510R     002	I.WRN = ****** GX	L30     000754R     002	M.ARGS= 000016   	S.TKMS= 000377
B5      000746R     002	KEYMAC= ****** GX	L31     000756R     002	M.END = 000012   	S.WEAK= 040000
B6      001742R     002	KEYPTR= ****** GX	L32     001016R     002	M.GETL= 000004   	TAB   = 000011
B7      002110R     002	LBLS0 = 000063   	L33     001012R     002	M.IFLV= 000006   	TYPS0 = 000000
CHAR  = ****** GX	LBLS1 = 000011   	L34     001054R     002	M.IFVL= 000010   	TYPS1 = 000006
CNT   = 000006   	LBLS10= 000013   	L35     001074R     002	M.LINK= 000000   	TYPS10= 000006
COMMA = 000054   	LBLS2 = 000064   	L36     001122R     002	M.NXTL= 000002   	TYPS2 = 000000
CONTLN= ****** GX	LBLS3 = 000065   	L37     001204R     002	NEWBLK  001306R     002	TYPS3 = 000000
CR    = 000015   	LBLS4 = 000012   	L4      000366R     002	NEXTCH= ****** GX	TYPS4 = 000001
CRSYM = ****** GX	LBLS5 = 000071   	L40     001162R     002	OPRND = ****** GX	TYPS5 = 000000
DATRPT= ****** GX	LBLS6 = 000067   	L41     001200R     002	OUTERR= ****** GX	TYPS6 = 000000
DECLR = ****** GX	LBLS7 = 000070   	L42     001232R     002	OUTFRA= ****** GX	TYPS7 = 000000
DIE   = ****** GX	LCLIM = ****** GX	L43     001304R     002	OUTWRN= ****** GX	UNTCND= ****** GX
DNUMBE= ****** GX	LF    = 000012   	L44     001320R     002	POPINP  001456R     002	V1STAC= ****** GX
ERRPTX= ****** GX	LFTANG= 000074   	L45     001450R     002	PSECCH= 000020   	V2STAC= ****** GX
EVALEX= ****** GX	LINEBF= ****** GX	L46     001454R     002	PSECOP= 000016   	WRTFRM= ****** GX
E0      000104R     002	LINEBN= ****** GX	L47     001622R     002	PSECV1= 000012   	$DIDDO= 000000
E1      000250R     002	LINELN= ****** GX	L5      000242R     002	PSECV2= 000014   	$E$   = 000001
E10     002442R     002	LINENM= ****** GX	L50     001650R     002	RDXPTR= ****** GX	$F$   = 000000
E11     002646R     002	LINEPT= ****** GX	L51     001710R     002	RGTANG= 000076   	$I$   = 000001
E12     002636R     002	LISTIT= ****** GX	L52     002450R     002	RPTLIN  001030RG    002	$L    = 000014
E13     002570R     002	LISTLV= ****** GX	L53     002176R     002	RTNVAL=%000000   	$LL   = 000010
E2      000336R     002	LNTLNG= ****** GX	L54     002236R     002	R6    =%000006   	$L$   = 000000
E3      000550R     002	LOWCAS= 000140   	L55     002434R     002	R7    =%000007   	$O$   = 000000
E4      000524R     002	LPTLEN= 000074   	L56     002376R     002	SEMI  = 000073   	$R    = 177777
E5      000752R     002	LS.MC = ****** GX	L57     002372R     002	SKIPSP= ****** GX	$SV$  = 000000
E6      001746R     002	LS.ME = ****** GX	L6      000250R     002	SPACE = 000040   	$T    = 000072
E7      002114R     002	LS.MEB= ****** GX	L60     002420R     002	STAT4   001574RG    002	$T1   = 000000
FF    = 000014   	L0      000104R     002	L61     002430R     002	SYMCHR= 000012   	$T2   = 000063
FREEPT= ****** GX	L1      000070R     002	L63     002646R     002	SYMFLA= 000002   	$Y$   = 177773
FRIEND= ****** GX	L10     000322R     002	L64     002636R     002	SYMFUL= ****** GX	$Z$   = 000000
FRMPTR= ****** GX	L11     000336R     002	L65     002636R     002	SYMLEN= 000011   	$$S   = 000000
GETARG  001772RG    002	L12     000360R     002	L66     002632R     002	SYMLIN= 000000   	$$T   = 000065
GETCHR  000000RG    002	L13     000764R     002	L67     002630R     002	SYMMAX= 000017   	$$TT  = 000046
GETLIN= ****** GX	L14     000550R     002	L7      000340R     002	SYMSEG= 000010   	.SAVRG= ****** GX
IFLVL = ****** GX	L15     000530R     002	L70     002570R     002

. ABS.	000000	   000
      	000000	   001
INPUT 	002650	   002
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  12448 WORDS  ( 49 PAGES)
DYNAMIC MEMORY:  13332 WORDS  ( 51 PAGES)
ELAPSED TIME:  00:07:42
OBJ$:INPUT,LIS$:INPUT/-SP=SRC$:MD,COMMON,INPUT
