ACTPRI	MACRO M1110  21-AUG-78 22:22
TABLE OF CONTENTS

    32-    2	**********  SEMANTIC ROUTINES  **********
    33-   23	PRIMARIES
    35-  134	ENTRY POINT MASK
    36-  178	RADIX CONTROL
    37-  207	SPECIAL OPERATORS (SIMILAR TO RADIX CONTROL)
    38-  247	EXPRESSIONS
    39-  305	OPERATORS
    40-  345	SYMBOL ATTRIBUTE DIRECTIVES - .GLOBL .DEBUG .WEAK .EXTRN
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 32


      1					.TITLE ACTPRI
      2					.SBTTL	**********  SEMANTIC ROUTINES  **********
      3					.GLOBL	PRMUN,	PRMSYM,	PRMINT,	PRMBRK,	PRMRDX,	PRMPC
      4					.GLOBL	RGLST1,	REGLST,	MASK,	MASKX,	MASKNL
      5					.GLOBL	RDXBIN,	RDXDEC,	RDXOCT,	RDXHEX,	NUMFLT,	NUMASC
      6					.GLOBL	EXPBIN,	OPPLUS,	OPMINU,	OPMUL,	OPDIV,	OPAND
      7					.GLOBL	OPOR,	OPXOR,	OPASH,	OPCOM,	OPNEG,	OPSAME
      8					.GLOBL	GLOBAL,	DEBUG,	WEAK,	EXTRN,	IDLIST
      9		000010 			FP.REL	= 10
     10					;
     11					;
     12					;		MARS ACTION ROUTINES
     13					;
     14					; THESE ARE THE SEMANTIC ROUTINES CALLED DURING PASS 1 BY THE
     15					; PARSER.  THE ACTIONS CONSIST MAINLY OF SETTING UP THE INTERMEDIATE
     16					; FILE FOR PROCESSING BY PASS 2.  THE ROUTINE NAMES ARE DETERMINED
     17					; BY THE ACTION LABELS SPECIFIED IN THE GRAMMAR, AND EACH ROUTINE
     18					; IS CALLED WITH A 'JSR PC,ROUTINE.'  THE PRODUCTION ASSOCIATED WITH
     19					; EACH ROUTINE IS INCLUDED AS A COMMENT TO AID IN DEBUGGING.
     20					;
     21	000000				.PSECT ACTPRI
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 33
PRIMARIES

     23					.SBTTL	PRIMARIES
     24					;
     25					; PRIMITIVES ARE THE BASIC UNITS OF EXPRESSIONS.  PRIMITIVES ARE ALSO
     26					; USED IN REFS WHEN AN EXPRESSION IS CALLED FOR.
     27					;
     28	000000				PRMUN:				; PRIMARY = OPUNARY PRIMARY
     29	000000					LET R0	:= R4				; COPY STACK POINTER
     30	000002					LPUSH V1STACK(R0),V2STACK(R0)		; PUSH PRIMARY'S VALUE
     31	000022					LET R0		:= R0 - #2		; POINT TO ROUTINE POINTER
     32	000026					IF V1STACK(R0) EQ #X.NEG AND RDXPTR EQ #FLTPNT THEN
     33											; FLOATING NEGATE?
     34	000046					    IF EVALEXPR IS TRUE THEN		; EVALUATING EXPR?
     35	000054						OUT #I.STKL,<#100000,#0>	; SIGN BIT
     36	000074					    END
     37	000074					    LET V2STACK(R0)	:= #I.XOR	; CALL XOR ROUTINE
     38	000102					    LET V1STACK(R0)	:= #X.XOR	; AND XOR EVALUATOR
     39	000110					    LPUSH #100000,#0			; PUSH SIGN BIT
     40	000130					END
     41	000130					IF EVALEXPR IS TRUE			; EVALUATE ON PASS 2?
     42	000136					    PUSH V2STACK(R0)			; PUSH  ACTION CODE ONTO STACK
     43	000142	000316 				    SWAB (SP)				; MOVE  ACTION TO UPPER BYTE
     44	000144					    LET (SP)	:= (SP) SET.BY #2	; OR IN LENGTH OF FRAME
     45	000150					    CALL OUTFRAME			; WRITE COMMAND TO INTERMEDIATE BUFFER
     46	000154					    LET EXPEND	:= FRMPTR		; SAVE END OF EXPRESSION
     47	000162					END
     48	000162					CALL	@V1STACK(R0)			; CALL OPERATOR
     49	000166					LPOP	VAL1,VAL2			; POP RESULTS
     50	000206					RETURN
     51
     52	000210				PRMSYM:				; PRIMARY = ID
     53	000210					LET R0 := VAL1				; PICK UP ADDRESS OF SYMBOL BLK.
     54	000214					IF #S.DF OFF.IN SYMFLAG(R0) THEN	; IS SYMBOL NOT DEFINED YET?
     55	000224					    LET COMPEXPR := FALSE		; VALUE NOT KNOWN YET
     56	000230					END
     57	000230					IF #S.GLOB+S.EXTN SET.IN SYMFLAG(R0) AND #S.DF+S.LOCL OFF.IN SYMFLAG(R0) THEN
     58											; EXTERNAL OR GLOBAL SYMBOL NOT YET DEFINED
     59	000250					    IF EVALEXPR IS TRUE THEN
     60	000256						OUT #I.STKG,R0			; STACK GLOBAL
     61	000270						LET EXPEND	:= FRMPTR	; SAVE END OF EXPRESSION
     62	000276					    END
     63	000276					ELSE
     64	000300					    IF #S.DF!S.REF OFF.IN SYMFLAG(R0) THEN ; CAN SYMBOL BE DELETED?
     65	000310						IF EVALEXPR IS FALSE AND @SYMLNK EQ R0 THEN
     66											; SYMBOL USED AS ASSEMBLY FLAG
     67	000324						    LET @SYMLNK := (R0)		; DELETE SYMBOL
     68	000330						    LET R1	:B= SYMLEN(R0)	; GET LENGTH OF NAME
     69	000334						    LET R1	:= R1 + #SYMCHRS+1 OFF.BY #1 + R0
     70											; GET ADDRESS AFTER SYMBOL BLOCK
     71	000346						    IF R1 EQ FREEPT THEN LET FREEPT := R0 ; ERASE SYMBOL
     72	000360						END
     73	000360					    END
     74	000360					    IFB SYMSEG(R0) NE PRMSEG AND #S.ABS OFF.IN SYMFLAG(R0) THEN
     75	000400						IF PRMSEG IS NE THEN		; REALLY DIFFERENT PSECT?
     76	000406						    LET COMPEXPR := FALSE	; IS BAD EXPRESSION
     77	000412						END
     78	000412					    END
     79	000412					    IF EVALEXPR IS TRUE THEN
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 33-1
PRIMARIES

     80	000420						OUT #I.STKS,R0			; STACK SYMBOL
     81	000432						LET EXPEND	:= FRMPTR	; SAVE END OF EXPRESSION
     82	000440					    END
     83	000440					    LET VAL1	:= SYMVL1(R0)		; GET VALUE OF SYMBOL
     84	000446					    LET VAL2	:= SYMVL2(R0)
     85	000454					END
     86	000454					IF #S.ABS OFF.IN SYMFLAG(R0) OR COMPEXPR IS FALSE THEN
     87	000472					    LET ABSEXPR	:= ABSEXPR +1		; NOT ABSOLUTE EXPR
     88	000476					    IF PRMSEG IS EQ THEN		; IF NO SEG YET,
     89	000504						LET PRMSEG	:B= SYMSEG(R0)	; USE SYMBOL'S SEG
     90	000512					    END
     91	000512					END
     92	000512					RETURN
     93
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 34
PRIMARIES

     95	000514				PRMINT:				; PRIMARY = DINTEGER
     96	000514					IF EVALEXPR IS TRUE THEN
     97	000522					OUT #I.STKL,<VAL1,VAL2>
     98	000542					LET EXPEND	:= FRMPTR		; SAVE END OF EXPRESSION
     99	000550					END
    100	000550					RETURN
    101
    102
    103	000552				PRMBRK:				; PRIMARY = DANGOPN EXPR DANGCLS
    104	000552					LET R0		:= R4 - #2		; POINT TO EXPR
    105	000560					LET VAL1	:= V1STACK(R0)		; GET ITS VALUE
    106	000566					LET VAL2	:= V2STACK(R0)
    107	000574					RETURN
    108
    109	000576				PRMRDX:				; PRIMARY = RADIX_CONTROL PRIMARY
    110	000576					LET RDXPTR	:= V1STACK-2(R4)	; RESET PREVIOUS RADIX
    111	000604					RETURN
    112
    113	000606				PRMPC:				; PRIMARY = DPC
    114	000606					IF EVALEXPR IS TRUE THEN
    115	000614					    OUT #I.STKPC			; STACK PC
    116	000624					    LET EXPEND	:= FRMPTR		; SAVE END OF EXPRESSION
    117	000632					END
    118	000632					LET VAL1	:= PC1			; VALUE IS CURRENT PC
    119	000640					LET VAL2	:= PC2
    120	000646					LET R0		:= PSECTP		; POINT TO PSECTION
    121	000652					IF #FP.REL SET.IN PSECOP(R0) THEN	; RELOCATABLE SECTION?
    122	000662					    LET ABSEXPR	:= ABSEXPR +1		; NOT ABSOLUTE EXPR
    123	000666					    IF PRMSEG IS EQ THEN		; ANY PSECT YET?
    124	000674						LET PRMSEG	:= PSTNUM	; NO, USE CURRENT SEG
    125	000702					    ELSE
    126	000704						IF PRMSEG NE PSTNUM THEN	; CROSS PSECT REFS?
    127	000714						    LET COMPEXPR := FALSE	; YES! IS BAD EXPRESSION!
    128	000720						END
    129	000720					    END
    130	000720					END
    131	000720					RETURN
    132
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 35
ENTRY POINT MASK

    134					.SBTTL	ENTRY POINT MASK
    135					;
    136					; ENTRY POINT MASKS
    137					;
    138
    139	000722				RGLST1:				; REGLIS = MASK_ITEM
    140	000722					LET EMASK	:= 0			; CLEAR MASK
    141	000726				REGLST:				; REGLIS = REGLIS MASKITEM
    142										; REGLIS = REGLIS DCOMMA MASK_ITEM
    143	000726					LET R0	:= #1 SHIFT V1STACK(R4) 	; GET MASK BIT
    144	000736					LET EMASK	:= EMASK SET.BY R0	; FILL IN MASK
    145	000742					RETURN					; AND EXIT
    146
    147	000744				MASK:				; REGISTER_MASK = DUPM DANGOPN REGLIS DANGCLS
    148	000744					LET VAL1	:= EMASK
    149	000752					LET VAL2	:= 0
    150	000756					IF EVALEXPR IS TRUE THEN		; OUTPUT EXPRESSION?
    151	000764					    OUT	#I.STKL,<EMASK,#0>
    152	001004					    LET EXPEND	:= FRMPTR		; SAVE END OF EXPRESSION
    153	001012					END
    154	001012					RETURN
    155
    156
    157	001014				MASKX:				; REGISTER_MASK = DUPM MASK_ITEM
    158	001014					LET R0		:= #1 SHIFT V1STACK(R4)	; GET MASK BIT
    159	001024					LET VAL1	:= R0			; SAVE VALUE
    160	001030					LET VAL2	:= 0
    161	001034					IF EVALEXPR IS TRUE THEN		; OUTPUT EXPRESSION?
    162	001042					    OUT #I.STKL,<R0,#0>			; STACK VALUE
    163	001060					    LET EXPEND	:= FRMPTR		; END OF EXPRESSION
    164	001066					END
    165	001066					RETURN
    166
    167
    168	001070				MASKNL:				; REGISTER_MASK = DUPM DANGOPN DANGCLS
    169	001070					LET VAL1	:= 0			; NULL LIST
    170	001074					LET VAL2	:= 0
    171	001100					IF EVALEXPR IS TRUE THEN		; OUTPUT EXPRESSION?
    172	001106					    OUT #I.STKL,<#0,#0>			; VALUE IS ZERO
    173	001126					    LET EXPEND	:= FRMPTR		; END OF EXPRESSION
    174	001134					END
    175	001134					RETURN
    176
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 36
RADIX CONTROL

    178					.SBTTL	RADIX CONTROL
    179					;++
    180					;
    181					; THE DEFAULT RADIX IS CHANGED BY ^R WHERE R IS A SINGLE CHARACTER
    182					; REPRESENTING THE RADIX NAME. IE. B - BINARY; O - OCTAL; X - HEXADECIMAL;
    183					; AND D - DECIMAL.
    184					;
    185					;--
    186
    187	001136				RDXBIN:				; RADIX_CONTROL = DUPB
    188	001136					LET VAL1	:= RDXPTR		; REMEMBER CURRENT RADIX
    189	001144					LET RDXPTR	:= #BINNUM		; NUMBERS ARE BINARY
    190	001152					RETURN
    191
    192	001154				RDXDEC:				; RADIX_CONTROL = DUPD
    193	001154					LET VAL1	:= RDXPTR		; SAVE CURRENT RADIX
    194	001162					LET RDXPTR	:= #DNUMBER		; SET DECIMAL RADIX
    195	001170					RETURN
    196
    197	001172				RDXOCT:				; RADIX_CONTROL = DUPO
    198	001172					LET VAL1	:= RDXPTR		; SAVE CURRENT RADIX
    199	001200					LET RDXPTR	:= #OCTNUM		; SET OCTAL RADIX
    200	001206					RETURN
    201
    202	001210				RDXHEX:				; RADIX_CONTROL = DUPX
    203	001210					LET VAL1	:= RDXPTR		; SAVE CURRENT RADIX
    204	001216					LET RDXPTR	:= #HEXNUM		; SET HEXIDECIMAL RADIX
    205	001224					RETURN
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 37
SPECIAL OPERATORS (SIMILAR TO RADIX CONTROL)

    207					.SBTTL	SPECIAL OPERATORS (SIMILAR TO RADIX CONTROL)
    208
    209	001226				NUMFLT:				; SPECIAL_OPERATOR = DUPF
    210	001226					SPNOR					; IGNORE BLANKS
    211	001232					CALL	FLTPNT				; GET FLOATING POINT NUMBER
    212	001236					JUMPTO PRMINT				; TREAT AS INTEGER
    213
    214
    215	001242				NUMASC:				; SPECIAL_OPERATOR = DUPA
    216	001242					SPNOR					; IGNORE BLANKS
    217	001246					PUSH	LCLIM				; SAVE LOWER CASE LIMIT
    218	001252	012767 	000400 	000000G		MOV	#400,LCLIM			; ALLOW LOWER CASE
    219	001260	016702 	000000G			MOV	CHAR,R2				; SAVE DELIMITER
    220	001264	012703 	000002G			MOV	#VAL4+2,R3			; POINT TO VALUE WORDS
    221	001270	005043 				CLR	-(R3)				; ZERO VALUE
    222	001272	005043 				CLR	-(R3)				;
    223	001274	005043 				CLR	-(R3)				;
    224	001276	005043 				CLR	-(R3)				; LEAVE PTR AT "VAL1"
    225	001300	020227 	000015 			CMP	R2,#CR				; DELIMITER EOL ?
    226	001304	001417 				BEQ	30$				; GOTO ERROR STATEMENT
    227	001306	116701 	000000G			MOVB	OPSIZE,R1			; MAXIMUM NUMBER OF CHARS
    228	001312	005067 	000000G		10$:	CLR	CHAR				; RETURN ALL CHARACTERS
    229	001316	004767 	000000G			JSR	PC,GETCHR			; GET NEXT CHARACTER
    230	001322	020002 				CMP	R0,R2				; DELIMITER ?
    231	001324	001414 				BEQ	35$				; EXIT IF DELIMITER
    232	001326	020027 	000015 			CMP	R0,#CR				; EOL ?
    233	001332	001404 				BEQ	30$				; ERROR EXIT
    234	001334	005301 				DEC	R1				; COUNT CHARACTER
    235	001336	002401 				BLT	20$				; SKIP IF TOO MANY CHARS
    236	001340	110023 				MOVB	R0,(R3)+			; SAVE CHARACTER
    237	001342	000763 			20$:	BR	10$				; GET NEXT CHARACTER
    238	001344				30$:	CALL ERORPT,#UNTERM			; UNTERMINATED ARGUMENT
    239	001354	000402 				BR	40$				; GO TO EXIT
    240	001356	004767 	000000G		35$:	JSR	PC,GETCHR			; SKIP OVER DELIMITER
    241	001362	005701 			40$:	TST	R1				; TOO MANY CHARACTERS?
    242	001364	002010 				BGE	50$				; SKIP IF OKAY
    243	001366					OUT  #I.WRN,<#DTATRU,ERRPT>		; DATA TRUNCATION ERROR
    244	001406				50$:	POP	LCLIM				; RESTORE LOWER CASE LIMIT
    245	001412	000167 	177076 			JMP	PRMINT				; TREAT AS INTEGER
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 38
EXPRESSIONS

    247					.SBTTL	EXPRESSIONS
    248					;
    249					;			EXPRESSIONS
    250					;
    251					; MARS RECOGNIZES DIFFERENT TYPES OF EXPRESSIONS.  THESE ROUTINES PROCESS
    252					; COMPILE-TIME EXPRESSIONS.  THE RESULT OF SUCH AN EXPRESSION IS A LONG-
    253					; WORD WHICH WILL BE KNOWN BY PASS2 (OR AT LINK TIME IF THE EXPRESSION
    254					; INVOLVES GLOBALS OR EXTERNALS.)  THE MOST COMMON USAGE OF THIS TYPE
    255					; OF EXPRESSIONS IS IN OPERANDS.  ANOTHER TYPE OF EXPRESSION IS FOUND
    256					; IN THE ASSIGNMENT STATEMENT WHERE AN EXPRESSION GENERATES CODE TO
    257					; EVALUATE THE EXPRESSION AT RUN TIME.
    258					;
    259					; THE 'PRIMITIVE' ROUTINES SET FLAGS DESCRIBING THE EXPRESSION.  THESE
    260					; FLAGS MUST BE INITIALIZED BY THE EXPRESSION CALLER IF THEY ARE TO
    261					; BE USED.
    262					;
    263					;	COMPEXPR -- 'FALSE' IF EXPRESSION VALUE IS NOT KNOWN YET.
    264					;	EVALEXPR -- 'TRUE' CAUSES EVALUATION TO OCCUR ON PASS 2.
    265					;	ABSEXPR --  'ZERO' INDICATES THAT EXPRESSION IS ABSOLUTE (SCALAR).
    266					;
    267					;
    268
    269	001416				EXPBIN:				; EXPR = EXPR OPBINARY PRIMARY
    270	001416					LET R0		:= R4			; COPY STACK POINTER
    271	001420					LPUSH V1STACK-4(R0),V2STACK-4(R0)	; PUSH LEFT OPERAND
    272	001440					LPUSH V1STACK(R0),V2STACK(R0)		; PUSH RIGHT OPERAND
    273	001460					IF EVALEXPR IS TRUE			; EVALUATE ON PASS 2?
    274	001466					    PUSH V2STACK-2(R0)			; YES, PUSH COMMAND ONTO STACK
    275	001472	000316 				    SWAB (SP)				; MOVE COMMAND TO HIGH BYTE
    276	001474					    LET (SP)	:= (SP) SET.BY #2	; STORE LENGTH  OF COMMAND
    277	001500					    CALL OUTFRAME			; OUTPUT COMMAND TO INTERMEDIATE BUFFER
    278	001504					    LET EXPEND	:= FRMPTR		; SAVE END OF EXPRESSION
    279	001512					END;IF
    280	001512					IF V1STACK-2(R0) IS NE THEN		; WAS ROUTINE SUPPLIED?
    281	001520					    IF V1STACK-2(R0) EQ #X.SUB AND ABSEXPR GT #1 AND COMPEXPR IS TRUE THEN
    282	001546						LET ABSEXPR := ABSEXPR - #2	; RESULT ABSOLUTE
    283	001554					    END
    284	001554					    LET VAL3	:= 0			; INITIALIZE EXPRESSION OVERFLOW
    285	001560					    LET OUTRET	:= V1STACK-2(R0)	; SAVE OPERATION ADDRESS
    286	001566					    CALL  @OUTRET			; CALL OPERATION ROUTINE
    287	001572					    IF VAL3 IS NE AND ABSEXPR IS EQ THEN ; EXPRESSION ERROR ?
    288	001606						IF OUTRET EQ #X.DIV THEN	; DIVIDE ERROR ?
    289	001616						    LET R0 := #DIVERR		; MESSAGE INDEX
    290	001622						ELSE
    291	001624						    LET R0 := #EXPOVR		; EXPRESSION OVERFLOW
    292	001630						END
    293	001630						OUT #I.WRN,<R0,ERRPT>		; OUTPUT MESSAGE
    294	001646					    END
    295	001646					ELSE
    296	001650					    LPUSH	#0,#0
    297	001670					END
    298	001670					LPOP		VAL1,VAL2		; POP RESULT
    299	001710					IF ABSEXPR GT #1 THEN			; SEVERAL RELATIVE REFS?
    300	001720					    LET ABSEXPR := #1			; CALL IT JUST 1
    301	001726					END
    302	001726					RETURN
    303
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 39
OPERATORS

    305					.SBTTL	OPERATORS
    306					;
    307					;
    308					;		OPERATOR SEMANTICS
    309					;
    310					; THESE OPERATOR ROUTINES SIMPLY SET POINTERS WHICH ARE CHECKED AT
    311					; A HIGHER LEVEL (EXPBIN.)  VAL1 IS SET TO CONTAIN THE POINTER TO
    312					; THE NUMERICAL EVALUATION ROUTINE FOR THE OPERATION, AND VAL2 IS
    313					; SET TO THE INTERMEDIATE COMMAND TO PERFORM THE OPERATION.  THE
    314					; MACRO 'OP' BELOW MAKES THIS EASY!
    315					;
    316					.MACRO	OP	OPR				; OPERATION NAME
    317						LET VAL1	:= #X.'OPR		; POINT TO ROUTINE
    318						LET VAL2	:= #I.'OPR		; SAVE COMMAND
    319						RETURN					; RETURN TO CALLER
    320					.ENDM	OP
    321
    322
    323	001730				OPPLUS:		OP	ADD	; OPBINARY = DDPLUS
    324
    325	001746				OPMINUS:	OP	SUB	; OPBINARY = DDMINUS
    326
    327	001764				OPMUL:		OP	MUL	; OPBINARY = DDTIMES
    328
    329	002002				OPDIV:		OP	DIV	; OPBINARY = DDDIV
    330
    331	002020				OPAND:		OP	AND	; OPBINARY = DDAND
    332
    333	002036				OPOR:		OP	OR	; OPBINARY = DDOR
    334
    335	002054				OPXOR:		OP	XOR	; OPBINARY = DDXOR
    336
    337	002072				OPASH:		OP	ASH	; OPBINARY = DDASH
    338
    339	002110				OPCOM:		OP	NOT	; OPUNARY = DDUPC
    340
    341	002126				OPNEG:		OP	NEG	; OPUNARY = DDMINUS
    342
    343	002144				OPSAME:		OP	SAME	; OPUNARY = DDPLUS
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 40
SYMBOL ATTRIBUTE DIRECTIVES - .GLOBL .DEBUG .WEAK .EXTRN

    345					.SBTTL	SYMBOL ATTRIBUTE DIRECTIVES - .GLOBL .DEBUG .WEAK .EXTRN
    346					;++
    347					;
    348					; THESE ROUTINES SET SYMBOL ATTRIBUTE FLAGS IN "TEMP0" IN RESPONSE TO
    349					; THE DIRECTIVE OF THE SAME NAME.  THE GRAMMAR WILL THEN REDUCE EACH
    350					; IDENTIFIER IN THE LIST TO "ID_LIST" AND CALL "IDLIST" WHICH SETS THE
    351					; VALUE IN "TEMP0" INTO "SYMFLAG" OF THE SYMBOL BLOCK.
    352					;
    353					;--
    354
    355	002162				GLOBAL:					; ID_LIST_HEAD = KGLOBL
    356	002162	012767 	020000 	000000G		MOV	#S.GLOBL,TEMP0		; SET GLOBAL FLAG
    357	002170	000207 				RTS	PC			;
    358
    359	002172				DEBUG:					; ID_LIST_HEAD = KDEBUG
    360	002172	012767 	002400 	000000G		MOV	#S.DBG+S.REF,TEMP0	; SET DEBUG AND REFERENCE FLAGS
    361	002200	000207 				RTS	PC			;
    362
    363	002202				WEAK:					; ID_LIST_HEAD = KWEAK
    364	002202	012767 	060000 	000000G		MOV	#S.WEAK+S.GLOBL,TEMP0	; SET WEAK AND GLOBAL FLAGS
    365	002210	000207 				RTS	PC			;
    366
    367	002212				EXTRN:					; ID_LIST_HEAD = KEXTRN
    368	002212	012767 	010000 	000000G		MOV	#S.EXTN,TEMP0		; SET EXTERNAL FLAG
    369	002220	000207 				RTS	PC			;
    370
    371	002222				IDLIST:				; ID_LIST = ID
    372										; ID_LIST = ID_LIST DCOMMA ID
    373	002222	016401 	000000G			MOV	V1STACK(R4),R1		; GET ADDRESS OF SYMBOL BLOCK
    374	002226	032767 	010000 	000000G		BIT	#S.EXTN,TEMP0		; IS THIS ".EXTRN"?
    375	002234	001410 				BEQ	10$			; SKIP IF NOT
    376	002236	032761 	100000 	000002 		BIT	#S.DF,SYMFLAG(R1)	; IS SYMBOL DEFINED YET?
    377	002244	001404 				BEQ	10$			; SKIP IF NOT
    378	002246					CALL	ERORPT,#SYMDEF		; SYMBOL IS DEFINED NOT EXTERNAL!!
    379	002256	056761 	000000G	000002 	10$:	BIS	TEMP0,SYMFLAG(R1)	; SET ATTRIBUTE BITS IN SYMBOL FLAG
    380	002264	000207 				RTS	PC			;
    381
    382		000001 			.END
ACTPRI	MACRO M1110  21-AUG-78 22:22  PAGE 40-1
SYMBOL TABLE

ABSEXP= ****** GX	I.SUB = ****** GX	L6      000454R     002	PSECTP= ****** GX	TYPS0 = 000000
BINNUM= ****** GX	I.WRN = ****** GX	L7      000360R     002	PSECV1= 000012   	TYPS1 = 000000
BLNK  = 000040   	I.XOR = ****** GX	MASK    000744RG    002	PSECV2= 000014   	TYPS2 = 000000
CHAR  = ****** GX	LBLS0 = 000040   	MASKNL  001070RG    002	PSTNUM= ****** GX	TYPS3 = 000000
CNT   = 000006   	LBLS1 = 000034   	MASKX   001014RG    002	RDXBIN  001136RG    002	UNTERM= ****** GX
COMMA = 000054   	LBLS2 = 000036   	M.ARGC= 000014   	RDXDEC  001154RG    002	VAL1  = ****** GX
COMPEX= ****** GX	LBLS3 = 000011   	M.ARGS= 000016   	RDXHEX  001210RG    002	VAL2  = ****** GX
CR    = 000015   	LCLIM = ****** GX	M.END = 000012   	RDXOCT  001172RG    002	VAL3  = ****** GX
DEBUG   002172RG    002	LF    = 000012   	M.GETL= 000004   	RDXPTR= ****** GX	VAL4  = ****** GX
DIVERR= ****** GX	LFTANG= 000074   	M.IFLV= 000006   	REGLST  000726RG    002	V1STAC= ****** GX
DNUMBE= ****** GX	LOWCAS= 000140   	M.IFVL= 000010   	RGLST1  000722RG    002	V2STAC= ****** GX
DTATRU= ****** GX	LPTLEN= 000074   	M.LINK= 000000   	RGTANG= 000076   	WEAK    002202RG    002
EMASK = ****** GX	L0      000130R     002	M.NXTL= 000002   	RTNVAL=%000000   	X.ADD = ****** GX
ERORPT= ****** GX	L1      000074R     002	NUMASC  001242RG    002	R6    =%000006   	X.AND = ****** GX
ERRPT = ****** GX	L10     000360R     002	NUMFLT  001226RG    002	R7    =%000007   	X.ASH = ****** GX
EVALEX= ****** GX	L11     000360R     002	OCTNUM= ****** GX	SEMI  = 000073   	X.DIV = ****** GX
EXPBIN  001416RG    002	L12     000412R     002	OPAND   002020RG    002	SKIPSP= ****** GX	X.MUL = ****** GX
EXPEND= ****** GX	L13     000412R     002	OPASH   002072RG    002	SPACE = 000040   	X.NEG = ****** GX
EXPOVR= ****** GX	L14     000440R     002	OPCOM   002110RG    002	SYMCHR= 000012   	X.NOT = ****** GX
EXTRN   002212RG    002	L15     000472R     002	OPDIV   002002RG    002	SYMDEF= ****** GX	X.OR  = ****** GX
FF    = 000014   	L16     000512R     002	OPMINU  001746RG    002	SYMFLA= 000002   	X.SAME= ****** GX
FLTPNT= ****** GX	L17     000512R     002	OPMUL   001764RG    002	SYMLEN= 000011   	X.SUB = ****** GX
FP.REL= 000010   	L2      000162R     002	OPNEG   002126RG    002	SYMLIN= 000000   	X.XOR = ****** GX
FREEPT= ****** GX	L20     000550R     002	OPOR    002036RG    002	SYMLNK= ****** GX	$DIDDO= 000000
FRMPTR= ****** GX	L21     000632R     002	OPPLUS  001730RG    002	SYMMAX= 000017   	$E$   = 000001
GETCHR= ****** GX	L22     000720R     002	OPSAME  002144RG    002	SYMSEG= 000010   	$F$   = 000000
GLOBAL  002162RG    002	L23     000704R     002	OPSIZE= ****** GX	SYMVL1= 000004   	$I$   = 000001
HEXNUM= ****** GX	L24     000720R     002	OPXOR   002054RG    002	SYMVL2= 000006   	$L    = 000000
IDLIST  002222RG    002	L25     000720R     002	OUTFRA= ****** GX	S.ABS = 004000   	$LL   = 000000
IIII  = 177777   	L26     001012R     002	OUTRET= ****** GX	S.ASN = 000200   	$L$   = 000000
I.ADD = ****** GX	L27     001066R     002	OUTWRN= ****** GX	S.DBG = 002000   	$O$   = 000000
I.AND = ****** GX	L3      000230R     002	PC1   = ****** GX	S.DF  = 100000   	$R    = 177777
I.ASH = ****** GX	L30     001134R     002	PC2   = ****** GX	S.EPT = 000100   	$SV$  = 000000
I.DIV = ****** GX	L31     001512R     002	PRMBRK  000552RG    002	S.EXTN= 010000   	$T    = 000041
I.MUL = ****** GX	L32     001650R     002	PRMINT  000514RG    002	S.GLOB= 020000   	$T1   = 000000
I.NEG = ****** GX	L33     001554R     002	PRMPC   000606RG    002	S.LOCL= 001000   	$T2   = 000040
I.NOT = ****** GX	L34     001646R     002	PRMRDX  000576RG    002	S.ODBG= 000040   	$Y$   = 000000
I.OR  = ****** GX	L35     001624R     002	PRMSEG= ****** GX	S.REF = 000400   	$Z$   = 000000
I.SAME= ****** GX	L36     001630R     002	PRMSYM  000210RG    002	S.TKMS= 000377   	$$S   = 000000
I.STKG= ****** GX	L37     001670R     002	PRMUN   000000RG    002	S.WEAK= 040000   	$$T   = 000015
I.STKL= ****** GX	L4      000300R     002	PSECCH= 000020   	TAB   = 000011   	$$TT  = 000016
I.STKP= ****** GX	L40     001726R     002	PSECOP= 000016   	TEMP0 = ****** GX	.$T   = 000001
I.STKS= ****** GX	L5      000276R     002

. ABS.	000000	   000
      	000000	   001
ACTPRI	002266	   002
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  12395 WORDS  ( 49 PAGES)
DYNAMIC MEMORY:  13332 WORDS  ( 51 PAGES)
ELAPSED TIME:  00:03:58
OBJ$:ACTPRI,LIS$:ACTPRI/-SP=SRC$:MD,COMMON,ACTPRI
