RPTIRP	MACRO M1110  21-AUG-78 22:48
TABLE OF CONTENTS

    32-   13	REPT	REPEAT DIRECTIVES
    33-   55	.IRP	INDEFINITE REPEAT DIRECTIVE
    36-  215	.IRPC	INDEFINITE CHARACTER REPEAT DIRECTIVE
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 26


      1						.IDENT	\X03.11\
      2					;
      3					; COPYRIGHT (C) 1977, 1978
      4					; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASSACHUSETTS 01754
      5					;
      6					; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ON A SINGLE
      7					; COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION OF THE
      8					; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
      9					; MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
     10					; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
     11					; TERMS.  TITLE TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES
     12					; REMAIN IN DEC.
     13					;
     14					; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
     15					; AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT
     16					; CORPORATION.
     17					;
     18					; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
     19					; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
     20					;
     21
     22					;++
     23					; FACILITY:	VAX-11 MACRO OBJECT MODULE LIBRARY "MAR.OLB"
     24					;
     25					; ABSTRACT:	THIS MODULE IS PART OF THE VAX-11 MACRO ASSEMBLER, ITS DESCRIPTION
     26					;		IS ON THE FOLLOWING PAGE.
     27					;
     28					;
     29					; ENVIRNOMENT:	VAX-11 MACRO RUNS ON ANY VAX-11 WITH COMPATIBILITY MODE, UNDER
     30					;		THE CME (COMPATIBILITY MODE EMULATOR) OF VAX/VMS OR ON A PDP-11
     31					;		WITH EXTENDED INSTRUCTIONS UNDER RSX-11/M.
     32					;
     33					; AUTHOR:	STEVE POULSEN, CREATION DATE:  22-JUL-76
     34					;		DALE A. ROEDGER, 10-JAN-77 - 19-DEC-77
     35					;		DAVE N. CUTLER
     36					;		BENN L. SCHREIBER
     37					;
     38					; MODIFIED BY:
     39					;
     40					;--
     41					.IF NDF $DATA$
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 32


      1					.TITLE	RPTIRP
      2					;++
      3					;
      4					; REPEAT TYPE DIRECTIVES (.REPT, .IRPC, .IRP) ARE HANDLED LIKE
      5					; MACROS.  THE BODY OF THE REPEAT RANGE IS SCANNED AND MOVED TO
      6					; THE END OF FREE CORE.  THE INPUT STREAM IS THEN SWITCHED TO
      7					; A ROUTINE WHICH TREATS THE ROUTINE AS A MACRO CALLED SEVERAL
      8					; TIMES.  THE REPEAT BODIES ARE STACKED AT THE END OF CORE SO
      9					; THAT THEY CAN BE NESTED AND DEALLOCATED WHEN COMPLETED.
     10					;
     11					;--
     12	000000				.PSECT	ACTRPT
     13					.SBTTL	REPT	REPEAT DIRECTIVES
     14
     15	000000				REPTHD::			; REPT_HEAD = KREPT
     16	000000					LET EVALEXPR	:= FALSE		; JUST EVALUATE EXPR
     17	000004					RETURN
     18
     19	000006				REPT::				; DIRECTIVE = REPT_HEAD EXPR
     20	000006					PUSH CORLST				; SAVE CORE POINTER
     21	000012					LET CORLST	:= 0			; PREVENT SYMBOL MOVEMENT
     22	000016					LET EVALEXPR	:= TRUE			; RESET EVAL FLAG
     23	000024					PUSH R4					; SAVE STACK POINTER
     24	000026					LET MCARGC	:= 0			; NO MACRO ARGS
     25	000032					LET MCARGP	:= 0
     26	000036					CALL BDYSCN				; SCAN MACRO BODY
     27	000042					LET R1		:= FRIEND		; POINT TO END OF CORE
     28	000046					PUSH R1					; SAVE THAT POINTER
     29	000050					LET R2		:= MCTXTL + #2		; POINT PAST BODY
     30	000060					REPEAT THRU R0	:= R2 - MCTXT R.SHIFT 1	; SLIDE DOWN BODY
     31	000070					    LET -(R1)	:= -(R2)
     32	000072					END
     33	000074					LET FREEPT	:= R2			; DEALLOCATE OLD BODY
     34	000100					POP R3,R4				; OLD FRIEND, STACK PTR
     35	000104					LET R1		:= R1 - #M.ARGS+2	; ALLOCATE INPUT BLOCK
     36	000110					LET FRIEND	:= R1
     37	000114					CALL	SYMFUL				; CHECK FOR ROOM
     38	000120					LET M.LINK(R1)	:= INPUTP		; POINT TO CURRENT BLOCK
     39	000126					LET INPUTP	:= R1			; RESET TO US
     40	000132					LET M.NXTL(R1)	:= R1 + #M.ARGS+2	; POINT TO TEXT
     41	000144					LET M.GETL(R1)	:= #RPTLIN		; INPUT HANDLER
     42	000152					LET M.IFLV(R1)	:= IFLVL		; IF LEVEL
     43	000160					LET IFLVL	:= 0			; NO IFS
     44	000164					LET M.IFVL(R1)	:= IFVAL		; IF VALUES
     45	000172					LET IFVAL	:= 0			; NO VALUES
     46	000176					LET M.END(R1)	:= R3			; POINTER PAST BODY
     47	000202					LET M.ARGC(R1)	:= V1STACK(R4)		; REPEAT COUNT
     48	000210					LET M.ARGS(R1)	:= M.NXTL(R1)		; INPUT POINTER RESET
     49	000216					IF V1STACK(R4) IS LE OR V2STACK(R4) IS NE THEN ; BAD COUNT?
     50	000232					    LET @M.NXTL(R1)	:= 0		; MAKE REPT BODY NULL
     51	000236					END
     52	000236					POP	CORLST				; RESTORE CORE POINTER
     53	000242					RETURN					; WITH INPUT SWITCHED TO US
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 33
.IRP	INDEFINITE REPEAT DIRECTIVE

     55					.SBTTL	.IRP	INDEFINITE REPEAT DIRECTIVE
     56	000000				.PSECT	ACTIRP
     57					;++
     58					;
     59					; THIS MODULE CONTAINS THE CODE WHICH SETS UP INDEFINITE REPEAT LOOPS.
     60					; AN INDEFINITE REPEAT IS ESSENTIALLY A MACRO DEFINITION WHICH CALLS
     61					; ITSELF ONCE PER ARG SPECIFIED IN THE .IRP LINE.  THIS LINE CONTAINS
     62					; BOTH FORMAL AND REAL ARGUMENTS FOR THE MACRO.  THE WAY THAT .IRP
     63					; WORKS IS FIRST, THE FORMAL ARGUMENT NAME IS SCANNED AND REMEMBERED.
     64					; NEXT, THE REAL ARGUMENTS ARE SCANNED AND PLACED IN HIGH CORE.  NEXT,
     65					; THE BODY OF THE REPEAT LOOP IS SCANNED AS IF IT WERE A MACRO DEF WITH
     66					; ONE ARGUMENT (THE FORMAL PARAMETER).  FINALLY, THE INPUT STREAM
     67					; IS PASSED THROUGH A CONTROL ROUTINE WHICH RESETS INPUT TO COME FROM
     68					; THE MACRO ONCE FOR EACH ARGUMENT.  THIS ROUTINE (RPTLIN) "CALLS"
     69					; THE .IRP MACRO ONCE PER ARGUMENT UPDATING THE SINGLE ARGUMENT EACH
     70					; TIME.  ONCE ALL OF THE INITIALIZATION AND OTHER CRAP IS FINISHED,
     71					; THE .IRP LOOP SIMPLY LOOKS LIKE A MACRO, EXCEPT THAT ONCE WE ARE
     72					; DONE WITH THE MACRO, ITS BODY IS DEALLOCATED.  (THAT'S WHY THE MACRO
     73					; TEXT IS MOVED TO HIGH CORE.  IF IT WERE IN LOW CORE, SYMBOL DEFINITIONS
     74					; COULD PREVENT TOTAL DEALLOCATION OF THE BODY.)
     75					;
     76					;--
     77
     78	000000				IRP::				; DIRECTIVE = KIRP
     79	000000					PUSH	CORLST				; SAVE CORE POINTER
     80	000004					LET CORLST	:= 0			; DON'T ALLOW SYMBOLS TO MOVE
     81	000010					IF LS.MD+SYMVL2 IS EQ THEN			; LISTING MACRO DEFS?
     82	000016					    OUT #I.FLAG,<#0,#LISTIT>		; STOP LISTING
     83	000036					END
     84	000036					PUSH R4					; SAVE STACK PTR
     85	000040					CALL SYMSCN				; GET ARGUMENT NAME
     86	000044					IF R3 IS EQ THEN			; NO ARG?
     87	000050					    CALL ERORLN,#MCRGER			; NO ARGUMENT FOR ".IRP"
     88	000060					    POP R4
     89	000062					    POP CORLST				; RESTORE CORE POINTER
     90	000066					    RETURN
     91	000070					END
     92	000070					LET R2		:= #MCARGP		; POINT TO ARG LIST
     93	000074					LET (R2)	:= 0			; WHICH IS EMPTY
     94	000076					LET INSERT	:= TRUE			; ADD NEW NAME
     95	000104					CALL FINDSYM				; GET NAME
     96	000110					POP R4					; RESTORE R4
     97	000112					LET MCNAM	:= R2			; SAVE FORMAL ARG NAME PTR
     98	000116					LET SYMVL1(R2)	:= FREEPT		; SAVE PTR TO FREE STORAGE
     99	000124					LET SYMVL2(R2)	:= FRIEND		; SAME WITH HIGH PTR
    100	000132					LET SYMSEG(R2)	:B= 0			; NO ARGS YET
    101	000136					SPNOR
    102	000142					IF CHAR EQ #COMMA THEN			; COMMA?
    103	000152					    CALL GETCHR				; SKIP OVER IT
    104	000156					    SPNOR
    105	000162					END
    106	000162					IF CHAR EQ #LFTANG THEN			; <?
    107	000172					    CALL GETCHR				; SKIP OVER IT
    108	000176					    LET EXPOP1	:= TRUE			; MARK AS FOUND
    109	000204					ELSE
    110	000206					    LET EXPOP1	:= FALSE		; NOT FOUND
    111	000212					END
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 33-1
.IRP	INDEFINITE REPEAT DIRECTIVE

    112	000212					PUSH FREEPT				; SAVE FREE CORE PTR
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 34
.IRP	INDEFINITE REPEAT DIRECTIVE

    114					;
    115					; SCAN REAL ARGUMENTS, PLACING THEM IN HIGH CORE.  A LIST OF POINTERS
    116					; TO THE ARGUMENTS IS BUILT IN LOW CORE.
    117					;
    118	000216					REPEAT					; ONCE PER ARG
    119	000216					    IF CHAR EQ #RGTANG THEN		; >?
    120	000226						CALL GETCHR			; SKIP OVER IT
    121	000232						SPNOR				; IGNORE JUNK
    122	000236						IF CHAR EQ #CR THEN		; CR?
    123	000246						    LEAVE
    124	000250						ELSE
    125	000252						    CALL ERORLN,#DIRERR		; DIRECTIVE SYNTAX ERROR
    126	000262						END
    127	000262					    END
    128	000262					    LET IRPSTAT	:= TRUE			; THIS IS AN IRP
    129	000270					    CALL ARGSCN				; SCAN NEXT ARG
    130	000274					    LET IRPSTAT := FALSE		; NOT AN IRP
    131	000300					    LET R2	:= MCNAM		; POINT TO FORMAL ARG
    132	000304					    IF @MCTXTL IS EQ THEN		; NULL ARG?
    133	000312						IF CHAR EQ #CR THEN		; DONE?
    134	000322						    IF EXPOP1 IS TRUE THEN	; MISSING >?
    135	000330							CALL ERORLN,#DIRERR	; DIRECTIVE SYNTAX ERROR
    136	000340						    END
    137	000340						    LEAVE			; DONE SCANNING
    138	000342						END
    139	000342					    END
    140	000342						LET R3	:= SYMVL2(R2)		; POINT TO LAST TEXT LINE
    141	000346						LET R1	:= FREEPT		; POINT PAST ARG
    142	000352						REPEAT THRU R0 := @MCTXTL +1 R.SHIFT 1 +1
    143	000364						    LET -(R3) := -(R1)		; MOVE ARG TO HIGH CORE
    144	000366						END
    145	000370						LET SYMVL2(R2)	:= R3		; RESET HIGH POINTER
    146	000374					    LET R0	:= SYMVL1(R2)		; GET ARG PTR PTR
    147	000400					    LET (R0)+	:= R3			; POINT TO ARG
    148	000402					    LET SYMVL1(R2)	:= R0		; RESET POINTER
    149	000406					    LET FREEPT	:= R0			; DEALLOCATE LOW ARG
    150	000412					    LET SYMSEG(R2)	:= SYMSEG(R2) +1 ; COUNT THE ARG
    151	000416					END
    152					;
    153					; MOVE ARGUMENT POINTERS TO HIGH CORE JUST BELOW THE REAL ARGUMENTS.
    154					;
    155	000422					LET R3	:= SYMVL2(R2)			; PTR PAST END OF ARG PTRS
    156	000426					LET R1	:= SYMVL1(R2)			; HIGH ARGS PTR
    157	000432					LET R0	:B= SYMSEG(R2)			; ARGUMENT COUNTER
    158	000436					IF R0 IS GT THEN			; IF ANY ARGS...
    159	000442					    REPEAT THRU R0
    160	000442						LET -(R3) := -(R1)		; COPY ARG POINTERS
    161	000444					    END
    162	000446					END
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 35
.IRP	INDEFINITE REPEAT DIRECTIVE

    164					;
    165					; ALLOCATE INPUT BLOCK TO CALL MACRO WE CREATED
    166					;
    167	000446					PUSH R3					; SAVE PTR
    168	000450					LET -(R3)	:= (SP)+		; POINT TO FIRST ARG
    169	000452					LET R3		:= R3 - #M.ARGS		; ALLOCATE INPUT BLOCK
    170	000456					CALL	SYMFUL				; CHECK FOR ROOM
    171	000462					LET R0		:= INPUTP		; POINT TO CURRENT INPUT BLOCK
    172	000466					LET M.LINK(R3)	:= R0			; LINK TO NEXT BLOCK
    173
    174	000472					LET M.GETL(R3)	:= #IRPLIN		; POINT TO INPUT CONTEXT TRAP
    175	000500					LET M.IFLV(R3)	:= IFLVL		; IF LEVEL
    176	000506					LET IFLVL	:= 0			; NO IFS
    177	000512					LET M.IFVL(R3)	:= IFVAL		; IF VALUE
    178	000520					LET IFVAL	:= 0			; NO VALUES
    179	000524					LET M.END(R3)	:= FRIEND		; POINT TO END OF BLOCK
    180	000532					LET FRIEND	:= R3			; ALLOCATE INPUT BLOCK
    181	000536					LET R0		:B= SYMSEG(R2)		; GET ARG COUNT
    182	000542					LET M.ARGC(R3)	:= R0			; SAVE COUNT
    183	000546					LET SYMVL2(R2)	:= R3			; SAVE POINTER TO US
    184					;
    185					; SCAN REPEAT TEXT BODY
    186					;
    187	000552					LET FREEPT	:= (SP)			; RESTORE FREE CORE PTR
    188	000556					LET CHAR	:= #CR			; FORCE READING OF NEW LINE
    189	000564					CALL GETCHR				; READ THE LINE
    190	000570					LET SYMVL1(R2)	:= #1			; THIS IS ARG 1
    191	000576					CALL BDYSCN				; SCAN MACRO BODY
    192					;
    193					; MOVE BODY OF TEXT TO HIGH CORE
    194					;
    195	000602					POP FREEPT				; RESTORE FREE CORE PTR
    196	000606					LET R2	:= MCTXTL + #2			; POINT PAST LAST LINE
    197	000616					LET R1	:= MCTXT			; STARTING LINE
    198	000622					LET R3	:= MCNAM			; POINT TO ARG NAME
    199	000626					LET R3	:= SYMVL2(R3)			; WHERE TEXT GOES
    200	000632					REPEAT THRU R0	:= R2 - R1 R.SHIFT 1
    201	000640					    LET -(R3) 	:= -(R2)		; SLIDE TEXT TO HIGH CORE
    202	000642					END
    203	000644					LET FRIEND	:= R3			; ALLOCATE TEXT
    204	000650					LET R2		:= MCNAM		; POINT TO ARG
    205	000654					LET R3		:= SYMVL2(R2)		; POINT TO PREVIOUS INPUT BLOCK
    206	000660					LET R0		:= INPUTP		; POINT TO CURRENT INPUT BLOCK
    207	000664					LET M.NXTL(R3)	:= FRIEND		; POINT TO TEXT OF MACRO
    208	000672					LET INPUTP	:= R3			; MAKE UT CURRENT INPUT BLOCK
    209	000676					LET FREEPT	:= MCARGP		; DEALLOCATE FORMAL ARG NAME BLOCK
    210	000704					LET MCARGP	:= 0			; BUG THE POINTER
    211	000710					POP	CORLST				; RESTORE CORE POINTER
    212	000714					RETURN					; AND EXIT
    213
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 36
.IRPC	INDEFINITE CHARACTER REPEAT DIRECTIVE

    215					.SBTTL	.IRPC	INDEFINITE CHARACTER REPEAT DIRECTIVE
    216	000000				.PSECT	ACTIRC
    217					;++
    218					;
    219					; THE IRPC ROUTINE FIRST SCANS THE FORMAL ARGUMENT.  THEN
    220					; THE REAL ARGUMENT IS SCANNED AND MOVED TO HIGH MEMORY.  THE BODY
    221					; OF THE REPEAT LOOP IS TREATED LIKE A MACRO BODY AND IS SCANNED
    222					; BY THE 'BDYSCN' ROUTINE.  THE RESULTING TEXT IS THEN MOVED TO
    223					; HIGH CORE.  FINALLY AN INPUT BLOCK IS CREATED TO CALL THE MACRO
    224					; ONCE PER CHARACTER IN THE REAL ARGUMENT.  WHEN THE LOOP IS FINISHED,
    225					; THE ARGUMENT AND BODY OF THE TEXT IS DEALLOCATED.
    226					;
    227					;--
    228
    229	000000				IRPC::				; DIRECTIVE = KIRPC
    230	000000					PUSH	CORLST				; SAVE CORE POINTER
    231	000004					LET CORLST	:= 0			; PREVENT SYMBOL MOVEMENT
    232	000010					IF LS.MD+SYMVL2 IS EQ THEN		; LIST MACRO DEF?
    233	000016					    OUT #I.FLAG,<#0,#LISTIT>		; NO
    234	000036					END
    235	000036					PUSH R4					; SAVE R4
    236	000040					CALL SYMSCN				; SCAN FORMAL ARG
    237	000044					IF R3 IS EQ THEN			; NO ARG?
    238	000050					    CALL ERORLN,#MCRGER			; MISSING ARGUMENT
    239	000060					    POP R4
    240	000062					    POP CORLST				; RESTORE CORE POINTER
    241	000066					    RETURN
    242	000070					END
    243	000070					LET R2		:= #MCARGP		; POINT TO ARG LIST
    244	000074					LET (R2)	:= 0			; WHICH IS EMPTY
    245	000076					LET INSERT	:= TRUE			; ADD NEW ARG
    246	000104					CALL FINDSYM				; LOOK UP SYMBOL
    247	000110					POP	R4				; RESTORE R4
    248	000112					LET SYMVL1(R2)	:= #1			; FIRST ARGUMENT
    249					;
    250					; PICK UP REAL ARGUMENT
    251					;
    252	000120					SPNOR					; IGNORE BLANKS
    253	000124					IF CHAR EQ #COMMA THEN			; COMMA?
    254	000134					    CALL GETCHR				; YES, SKIP OVER IT
    255	000140					END
    256	000140					LET DATRPT	:= FALSE		; NOT IRP
    257	000144					CALL ARGSCN				; SCAN THE REAL ARG
    258	000150					IF CHAR NE #CR THEN			; EOL?
    259	000160					    CALL ERORLN,#DIRERR			; DIRECTIVE SYNTAX ERROR
    260	000170					END
    261	000170					LET R3		:= FRIEND		; POINT TO HIGH CORE
    262	000174					LET R1		:= FREEPT		; POINT PAST ARG
    263	000200					REPEAT THRU R0	:= @MCTXTL +1 R.SHIFT 1 +1
    264	000212					    LET -(R3)	:= -(R1)		; COPY ARGUMENT
    265	000214					END
    266	000216					PUSH	FRIEND				; SAVE PTR TO ARG
    267	000222					LET FRIEND	:= R3			; ALLOCATE ARG
    268	000226					LET FREEPT	:= R1			; DEALLOCATE OLD COPY
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 37
.IRPC	INDEFINITE CHARACTER REPEAT DIRECTIVE

    270					;
    271					; SCAN MACRO BODY
    272					;
    273	000232					LET MCARGC	:= #1			; ONLY 1 ARG
    274	000240					LET CHAR	:= #CR			; FORCE READING
    275	000246					CALL GETCHR				; OF NEW LINE
    276	000252					CALL BDYSCN				; SCAN MACRO BODY
    277					;
    278					; MOVE MACRO BODY TO HIGH CORE
    279					;
    280	000256					LET R2		:= MCTXTL + #2		; POINT PAST LAST LINE
    281	000266					LET R1		:= MCTXT		; STARTING LINE
    282	000272					LET R3		:= FRIEND		; HIGH CORE POINTER
    283	000276					REPEAT THRU R0	:= R2 - R1 R.SHIFT 1
    284	000304					    LET -(R3)	:= -(R2)		; SLIDE BODY TO HIGH CORE
    285	000306					END
    286					;
    287					; ALLOCATE INPUT BLOCK
    288					;
    289	000310					PUSH R3					; SAVE TEXT POINTER
    290	000312					CALL	SYMFUL				; CHECK FOR ROOM
    291	000316					LET R0		:= FRIEND		; POINT TO ARG
    292	000322					LET -(SP)	:= (R0)+		; PUSH LENGTH
    293	000324					LET -(R3)	:= R0			; POINT TO DATA
    294	000326					LET R3		:= R3 - #M.ARGS		; CREATE INPUT BLOCK
    295	000332					LET FRIEND	:= R3			; ALLOCATE IT
    296	000336					LET M.LINK(R3)	:= INPUTP		; ESTABLISH LINK
    297	000344					LET INPUTP	:= R3			; MAKE US INPUT BLOCK
    298	000350					LET M.ARGC(R3)	:= (SP)+		; ARGUMENT LENGTH
    299	000354					LET M.NXTL(R3)	:= (SP)+		; POINTER TO TEXT
    300	000360					LET M.GETL(R3)	:= #IRPCLN		; "NEXT LINE" ROUTINE
    301	000366					LET M.IFLV(R3)	:= IFLVL		; IF LEVEL
    302	000374					LET IFLVL	:= 0			; NO IFS
    303	000400					LET M.IFVL(R3)	:= IFVAL		; IF VALUE
    304	000406					LET IFVAL	:= 0			; NO VALUES
    305	000412					LET M.END(R3)	:= (SP)+		; DEALLOCATION POINTER
    306	000416					LET FREEPT	:= MCARGP		; DEALLOCATE FORMAL ARG
    307	000424					POP	CORLST				; RESTORE CORE POINTER
    308	000430					RETURN					; AND PROCESS IRPC
    309
    310		000001 			.END
RPTIRP	MACRO M1110  21-AUG-78 22:48  PAGE 37-1
SYMBOL TABLE

ARGSCN= ****** GX	FREEPT= ****** GX	L14     000340R     003	PSECV2= 000014   	S.ODBG= 000040
A3    = 000000   	FRIEND= ****** GX	L15     000446R     003	REPT    000006RG    002	S.REF = 000400
BDYSCN= ****** GX	GETCHR= ****** GX	L16     000036R     004	REPTHD  000000RG    002	S.TKMS= 000377
BLNK  = 000040   	IFLVL = ****** GX	L17     000070R     004	RGTANG= 000076   	S.WEAK= 040000
B0      000070R     002	IFVAL = ****** GX	L2      000036R     003	RPTLIN= ****** GX	TAB   = 000011
B1      000216R     003	IIII  = 177777   	L20     000140R     004	RTNVAL=%000000   	TYPS0 = 000006
B2      000364R     003	INPUTP= ****** GX	L21     000170R     004	R6    =%000006   	TYPS1 = 000006
B3      000442R     003	INSERT= ****** GX	L3      000070R     003	R7    =%000007   	TYPS2 = 000000
B4      000640R     003	IRP     000000RG    003	L4      000162R     003	SEMI  = 000073   	TYPS3 = 000000
B5      000212R     004	IRPC    000000RG    004	L5      000206R     003	SKIPSP= ****** GX	V1STAC= ****** GX
B6      000304R     004	IRPCLN= ****** GX	L6      000212R     003	SPACE = 000040   	V2STAC= ****** GX
CHAR  = ****** GX	IRPLIN= ****** GX	L7      000262R     003	SYMCHR= 000012   	$DIDDO= 000000
CNT   = 000006   	IRPSTA= ****** GX	MCARGC= ****** GX	SYMFLA= 000002   	$E$   = 000001
COMMA = 000054   	I.FLAG= ****** GX	MCARGP= ****** GX	SYMFUL= ****** GX	$F$   = 000000
CORLST= ****** GX	LBLS0 = 000006   	MCNAM = ****** GX	SYMLEN= 000011   	$I$   = 000001
CR    = 000015   	LBLS1 = 000003   	MCRGER= ****** GX	SYMLIN= 000000   	$L    = 000007
DATRPT= ****** GX	LBLS2 = 000013   	MCTXT = ****** GX	SYMMAX= 000017   	$LL   = 000005
DIRERR= ****** GX	LBLS3 = 000014   	MCTXTL= ****** GX	SYMSCN= ****** GX	$L$   = 000000
ERORLN= ****** GX	LF    = 000012   	M.ARGC= 000014   	SYMSEG= 000010   	$O$   = 000000
EVALEX= ****** GX	LFTANG= 000074   	M.ARGS= 000016   	SYMVL1= 000004   	$R    = 177777
EXPOP1= ****** GX	LISTIT= ****** GX	M.END = 000012   	SYMVL2= 000006   	$SV$  = 000000
E0      000074R     002	LOWCAS= 000140   	M.GETL= 000004   	S.ABS = 004000   	$T    = 000022
E1      000422R     003	LPTLEN= 000074   	M.IFLV= 000006   	S.ASN = 000200   	$T1   = 000006
E2      000370R     003	LS.MD = ****** GX	M.IFVL= 000010   	S.DBG = 002000   	$T2   = 000006
E3      000446R     003	L0      000232R     002	M.LINK= 000000   	S.DF  = 100000   	$Y$   = 000000
E4      000644R     003	L1      000236R     002	M.NXTL= 000002   	S.EPT = 000100   	$Z$   = 000000
E5      000216R     004	L10     000252R     003	OUTFRA= ****** GX	S.EXTN= 010000   	$$T   = 000000
E6      000310R     004	L11     000262R     003	PSECCH= 000020   	S.GLOB= 020000   	$$TT  = 000001
FF    = 000014   	L12     000342R     003	PSECOP= 000016   	S.LOCL= 001000   	.$T   = 000001
FINDSY= ****** GX	L13     000342R     003	PSECV1= 000012

. ABS.	000000	   000
      	000000	   001
ACTRPT	000244	   002
ACTIRP	000716	   003
ACTIRC	000432	   004
ERRORS DETECTED:  0

VIRTUAL MEMORY USED:  12056 WORDS  ( 48 PAGES)
DYNAMIC MEMORY:  13332 WORDS  ( 51 PAGES)
ELAPSED TIME:  00:03:26
OBJ$:RPTIRP,LIS$:RPTIRP/-SP=SRC$:MD,COMMON,RPTIRP
