
; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 1
;
;	0001	MODULE RDBLOK (
;	0002			LANGUAGE (BLISS32),
;	0003			IDENT = 'A0029A'
;	0004			) =
;	0005	BEGIN
;	0006	
;	0007	!
;	0008	! Copyright (c) 1977
;	0009	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0010	!
;	0011	! This software is furnished  under a license for use only on a single
;	0012	! computer  system and  may be  copied only with  the inclusion of the
;	0013	! above copyright notice.  This software, or any other copies thereof,
;	0014	! may not be provided or  otherwise made available to any other person
;	0015	! except for use on such system and to one who agrees to these license
;	0016	! terms.  Title to and  ownership of the  software  shall at all times
;	0017	! remain in DEC.
;	0018	!
;	0019	! The information in this software is subject to change without notice
;	0020	! and should  not be construed  as a commitment  by Digital  Equipment
;	0021	! Corporation.
;	0022	!
;	0023	! DEC assumes  no  responsibility  for  the use or  reliability of its
;	0024	! software on equipment which is not supplied by DEC.
;	0025	
;	0026	!++
;	0027	!
;	0028	! FACILITY:  F11ACP Structure Level 2
;	0029	!
;	0030	! ABSTRACT:
;	0031	!
;	0032	!	This module contains routines for basic block I/O, as well
;	0033	!	as the buffer management mechanism.
;	0034	!
;	0035	! ENVIRONMENT:
;	0036	!
;	0037	!	STARLET operating system, including privileged system services
;	0038	!	and internal exec routines.
;	0039	!
;	0040	!--
;	0041	!
;	0042	!
;	0043	! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  13-Dec-1976  22:48
;	0044	!
;	0045	! REVISION HISTORY:
;	0046	!
;	0047	!   Andrew C. Goldstein, 16-Feb-1977  15:06
;	0048	!   X0002 - Modify for condition handling
;	0049	!
;	0050	!   Andrew C. Goldstein, 23-Feb-1977  16:06
;	0051	!   X0003 - Add storage map rewrite logic
;	0052	!
;	0053	!   Andrew C. Goldstein, 25-Feb-1977  16:07
;	0054	!   X0004 - Add buffer flush routine
;	0055	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 1-1
;
;	0056	!   Andrew C. Goldstein, 16-Mar-1977  14:25
;	0057	!   X0005 - Add separate checksum routine
;	0058	!
;	0059	!   Andrew C. Goldstein, 21-Mar-1977  19:14
;	0060	!   X0006 - Add invalidate buffer routine
;	0061	!
;	0062	!   Andrew C. Goldstein, 5-Apr-1977  14:16
;	0063	!   X0007 - Add routine CREATE_BLOCK
;	0064	!
;	0065	!   Andrew C. Goldstein, 7-Apr-1977  14:33
;	0066	!   X0008 - Clean file header dirty flag after write
;	0067	!
;	0068	!   Andrew C. Goldstein, 12-Apr-1977  22:51
;	0069	!   X0009 - Rewrite for buffer pool manager
;	0070	!
;	0071	!   Andrew C. Goldstein, 19-Apr-1977  13:11
;	0072	!   X0010 - Add RESET_LBN routine
;	0073	!
;	0074	!   Andrew C. Goldstein, 20-Apr-1977  10:43
;	0075	!   X0011 - Add file ID logic and FLUSH_FID routine
;	0076	!
;	0077	!   Andrew C. Goldstein, 25-Apr-1977  18:32
;	0078	!   X0012 - Move CHECKSUM routine to CHKHDR
;	0079	!
;	0080	!   Andrew C. Goldstein, 26-Apr-1977  16:36
;	0081	!   X0013 - Move buffers to locked down PSECT
;	0082	!
;	0083	!   Andrew C. Goldstein, 9-May-1977  14:02
;	0084	!   X0014 - Add DIRPUT (equated to WRITE_BLOCK)
;	0085	!
;	0086	!   Andrew C. Goldstein, 9-May-1977  16:54
;	0087	!   X0015 - Make 0 FID match all in FLUSH_FID
;	0088	!
;	0089	!   Andrew C. Goldstein, 17-May-1977  14:48
;	0090	!   X0016 - Add 6th parameter to QIO calls
;	0091	!
;	0092	!   Andrew C. Goldstein, 19-Aug-1977  14:24
;	0093	!   X0017 - Increase number of directory buffers
;	0094	!
;	0095	!   Andrew C. Goldstein, 26-Aug-1977  10:43
;	0096	!   X0018 - Add performance metering
;	0097	!
;	0098	!   Andrew C. Goldstein, 12-Dec-1977  14:06
;	0099	!   X0019 - file ID interface changes, put bitmap buffer first in array
;	0100	!
;	0101	!   Andrew C. Goldstein, 14-Dec-1977  15:30
;	0102	!   X0020 - Modify for structure level 2
;	0103	!
;	0104	!   Andrew C. Goldstein, 27-Dec-1977  15:57
;	0105	!   X0021 - Invalidate special map and directory buffer data on error
;	0106	!
;	0107	!   Andrew C. Goldstein, 17-Feb-1978  14:46
;	0108	!   X0022 - Use new bug check
;	0109	!
;	0110	!   Andrew C. Goldstein, 7-Mar-1978  21:10

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 1-2
;
;	0111	!   X0023 - Implement first level write error handling
;	0112	!
;	0113	!   Andrew C. Goldstein, 25-APR-78  13:48
;	0114	!   X0024 - Add multi-block read support
;	0115	!
;	0116	!   Andrew C. Goldstein, 2-May-78  10:55
;	0117	!   A0025 - Differentiate write lock from general write errors
;	0118	!
;	0119	!   Andrew C. Goldstein, 3-May-78  15:34
;	0120	!   A0026 - Limit multi-block read size to 32 blocks
;	0121	!
;	0122	!   Andrew C. Goldstein, 9-May-78  23:56
;	0123	!   A0027 - Add dynamic creation of buffer pool
;	0124	!
;	0125	!   Andrew C. Goldstein, 22-May-78  20:42
;	0126	!   A0028 - Add data file support
;	0127	!
;	0128	!   Andrew C. Goldstein, 4-Aug-78  9:44
;	0129	!   A0029 - Enable use of ACP$GB_MAXREAD
;	0130	!
;	0131	!**
;	0132	
;	0133	
;	0134	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0135	REQUIRE 'SRC$:FCPDEF.B32';
;	0454	
;	0455	
;	0456	FORWARD ROUTINE
;	0457		INIT_POOL	: NOVALUE,	! initialize the buffer pool
;	0458		FIND_BUFFER,			! find an appropriate I/O buffer
;	0459		READ_BLOCK,			! read a block
;	0460		RESET_LBN	: NOVALUE,	! assign new LBN to a buffer
;	0461		WRITE_BLOCK	: NOVALUE,	! write a block
;	0462		CREATE_BLOCK,			! fabricate a buffer
;	0463		MARK_DIRTY	: NOVALUE,	! mark buffer for write-back
;	0464		INVALIDATE	: NOVALUE,	! invalidate a buffer
;	0465		WRITE_HEADER	: NOVALUE,	! write file header
;	0466		FLUSH_BUFFERS	: NOVALUE,	! flush all dirty buffers
;	0467		FLUSH_FID	: NOVALUE;	! flush a file from the pool

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 2
;
;	0468	!++
;	0469	!
;	0470	! Buffer pool data base.
;	0471	!
;	0472	! The root of the buffer data base is the pool vector which is used to index
;	0473	! a block type into the buffer pool used for that type. The buffer pools are
;	0474	! managed by 3 vectors, indexed by the pool code. The first vector contains
;	0475	! the buffer index of the first buffer assigned to each pool. The second
;	0476	! vector contains the number of buffers in each pool. The third vector 
;	0477	! contains the listheads for the LRU list of each pool.
;	0478	! 
;	0479	! The buffers themselves are a block vector. Each buffer is identified by
;	0480	! its address to the outside world, and internally by its vector index
;	0481	! (the two are interchangeable in the obvious manner.) Associated with the
;	0482	! buffers are status vectors: the UCB address of the currently resident
;	0483	! block (0 if none), the LBN of the currently resident block, the LRU list
;	0484	! entry, the file ID to which the block belongs, and the dirty bit.
;	0485	!
;	0486	!--
;	0487	
;	0488	
;	0489	! Define the layout of the buffer pool. The pool descriptors are filled in
;	0490	! by the pool initialization code. Note that each pool must consist of one
;	0491	! virtually contiguous area. Note also that the storage map buffers are
;	0492	! allocated first. This causes the buffer sweep at the end of each operation
;	0493	! to write out the storage map blocks first, resulting in maximum safety.
;	0494	!
;	0495	
;	0496	LITERAL
;	0497		POOL_COUNT	= 3;		! number of pools
;	0498	
;	0499	MACRO
;	0500		LRU_FLINK	= 0,0,32,0%,	! LRU entry forward link
;	0501		LRU_BLINK	= 4,0,32,0%;	! LRU entry back link
;	0502	
;	0503	! Buffer pool vector
;	0504	!
;	0505	
;	0506	BIND
;	0507		POOL_TABLE	= UPLIT BYTE (	1,	! file headers
;	0508						0,	! storage map
;	0509						2,	! directories
;	0510						1,	! index file blocks
;	0511						2	! random data blocks
;	0512				) : VECTOR [,BYTE];
;	0513	
;	0514	! Base index of each buffer pool
;	0515	!
;	0516	
;	0517	OWN
;	0518		POOL_BASE	: VECTOR [POOL_COUNT, BYTE];
;	0519	
;	0520	! Number of buffers in each pool
;	0521	!
;	0522	

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 2-1
;
;	0523	OWN
;	0524		POOL_SIZE	: VECTOR [POOL_COUNT, BYTE];
;	0525	
;	0526	! LRU list head for each pool
;	0527	!
;	0528	
;	0529	OWN
;	0530		POOL_LRU	: BLOCKVECTOR [POOL_COUNT, 8, BYTE];
;	0531	
;	0532	! Pointers to buffer descriptor vectors. The vectors are dynamically allocated
;	0533	! at initialization time.
;	0534	!
;	0535	
;	0536	OWN
;	0537		BUFFER_LRU	: REF BLOCKVECTOR [, 8, BYTE],
;	0538		BUFFER_FID	: REF VECTOR,
;	0539		BUFFER_LBN	: REF VECTOR,
;	0540		BUFFER_UCB	: REF VECTOR,
;	0541		BUFFER_DIRTY	: REF BITVECTOR;
;	0542	
;	0543	! Pointer to the I/O buffers.
;	0544	!
;	0545	
;	0546	STRUCTURE
;	0547		BUFVECTOR [I; N] =
;	0548		[N*512]
;	0549		(BUFVECTOR + I*512)<0, 32>;
;	0550	
;	0551	OWN
;	0552		BUFFERS		: REF BUFVECTOR,
;	0553		BUFFER_COUNT;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 3
;
;	0554	GLOBAL ROUTINE INIT_POOL : NOVALUE =
;	0555	
;	0556	!++
;	0557	!
;	0558	! FUNCTIONAL DESCRIPTION:
;	0559	!
;	0560	!	This routine initializes the buffer pool. It creates sufficient
;	0561	!	virtual space for the desired size buffer pool and sets up the
;	0562	!	descriptors.
;	0563	!
;	0564	! CALLING SEQUENCE:
;	0565	!	INIT_POOL ()
;	0566	!
;	0567	! INPUT PARAMETERS:
;	0568	!	NONE
;	0569	!
;	0570	! IMPLICIT INPUTS:
;	0571	!	pool descriptor vectors
;	0572	!	ACP$GW_MAPCACHE: number of bitmap buffers to allocate
;	0573	!	ACP$GW_HDRCACHE: number of header buffers to allocate
;	0574	!	ACP$GW_DIRCACHE: number of directory buffers to allocate
;	0575	!
;	0576	! OUTPUT PARAMETERS:
;	0577	!	NONE
;	0578	!
;	0579	! IMPLICIT OUTPUTS:
;	0580	!	NONE
;	0581	!
;	0582	! ROUTINE VALUE:
;	0583	!	NONE
;	0584	!
;	0585	! SIDE EFFECTS:
;	0586	!	pool initialized
;	0587	!
;	0588	!--
;	0589	
;	0590	BEGIN
;	0591	
;	0592	LITERAL
;	0593		EXEC_MODE	= 1;		! code for EXEC access mode
;	0594	
;	0595	LOCAL
;	0596		MAP_COUNT,			! number of map buffers
;	0597		HDR_COUNT,			! number of header buffers
;	0598		DIR_COUNT,			! number of directory buffers
;	0599		BUFFER_SIZE,			! number of buffers in pool
;	0600		SIZE_NEEDED,			! total virtual space needed
;	0601		PAGE_COUNT,			! space actually obtained
;	0602		SPACE_DESC	: VECTOR [2];	! descriptor of retun from $EXPREG
;	0603	
;	0604	EXTERNAL
;	0605		ACP$GW_MAPCACHE	: WORD ADDRESSING_MODE (ABSOLUTE),
;	0606						! number of map buffers to use
;	0607		ACP$GW_HDRCACHE	: WORD ADDRESSING_MODE (ABSOLUTE),
;	0608						! number of header buffers to use

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 3-1
;
;	0609		ACP$GW_DIRCACHE	: WORD ADDRESSING_MODE (ABSOLUTE);
;	0610						! number of directory buffers to use
;	0611	
;	0612	! Compute the total virtual space needed and create it. The space needed is
;	0613	! the total number of buffers plus the descriptor space - 161 bits per buffer.
;	0614	!
;	0615	
;	0616	MAP_COUNT = MAXU (1, .ACP$GW_MAPCACHE);
;	0617	HDR_COUNT = MAXU (1, .ACP$GW_HDRCACHE);
;	0618	DIR_COUNT = MAXU (2, .ACP$GW_DIRCACHE);
;	0619	BUFFER_SIZE = .MAP_COUNT + .HDR_COUNT + .DIR_COUNT;
;	0620	SIZE_NEEDED = .BUFFER_SIZE + (.BUFFER_SIZE*161 + 4095) / 4096;
;	0621	
;	0622	$EXPREG (PAGCNT = .SIZE_NEEDED, ACMODE = EXEC_MODE, RETADR = SPACE_DESC);
;	0623	
;	0624	! Compute the space we actually got and make sure it is at least the minimum.
;	0625	! If it is less then we asked for, divide it up in the ratio 1:1:6.
;	0626	!
;	0627	
;	0628	PAGE_COUNT = (.SPACE_DESC[1] - .SPACE_DESC[0]) / 512 + 1;
;	0629	IF .PAGE_COUNT LSSU 5
;	0630	THEN $EXIT (CODE = SS$_INSFMEM);
;	0631	
;	0632	IF .PAGE_COUNT LSSU .SIZE_NEEDED
;	0633	THEN
;	0634	    BEGIN
;	0635	    BUFFER_SIZE = (.PAGE_COUNT*4096) / 4257;
;	0636	    MAP_COUNT = HDR_COUNT = .BUFFER_SIZE / 8;
;	0637	    DIR_COUNT = .BUFFER_SIZE - (.MAP_COUNT + .HDR_COUNT);
;	0638	    END;
;	0639	
;	0640	! Allocate and set up the pointers for the buffer descriptors and the buffers
;	0641	! themselves.
;	0642	!
;	0643	
;	0644	BUFFER_LRU = .SPACE_DESC[0];
;	0645	BUFFER_FID = .BUFFER_LRU + .BUFFER_SIZE*8;
;	0646	BUFFER_LBN = .BUFFER_FID + .BUFFER_SIZE*4;
;	0647	BUFFER_UCB = .BUFFER_LBN + .BUFFER_SIZE*4;
;	0648	BUFFER_DIRTY = .BUFFER_UCB + .BUFFER_SIZE*4;
;	0649	BUFFERS = .BUFFER_DIRTY + (.BUFFER_SIZE+7)/8 + 511 AND NOT 511;
;	0650	
;	0651	POOL_SIZE[0] = .MAP_COUNT;
;	0652	POOL_SIZE[1] = .HDR_COUNT;
;	0653	POOL_SIZE[2] = .DIR_COUNT;
;	0654	POOL_BASE[0] = 0;
;	0655	POOL_BASE[1] = .MAP_COUNT;
;	0656	POOL_BASE[2] = .MAP_COUNT + .HDR_COUNT;
;	0657	BUFFER_COUNT = .BUFFER_SIZE;
;	0658	
;	0659	! Loop for all pools. First init the LRU list head to be empty. Then loop
;	0660	! for all buffers in each pool, linking each buffer into the pool LRU listhead.
;	0661	!
;	0662	
;	0663	INCR POOL FROM 0 TO POOL_COUNT-1 DO

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 3-2
;
;	0664	    BEGIN
;	0665	    POOL_LRU[.POOL, LRU_FLINK] = POOL_LRU[.POOL, LRU_FLINK];
;	0666	    POOL_LRU[.POOL, LRU_BLINK] = POOL_LRU[.POOL, LRU_FLINK];
;	0667	
;	0668	    INCR I FROM 0 TO .POOL_SIZE[.POOL]-1 DO
;	0669		INSQUE (BUFFER_LRU[.POOL_BASE[.POOL]+.I, LRU_FLINK],
;	0670			.POOL_LRU[.POOL, LRU_BLINK]);
;	0671	    END;
;	0672	
;	0673	END;					! end of routine INIT_POOL


							    .TITLE  RDBLOK
							    .IDENT  \A0029A\

							    .PSECT  $CODE$,NOWRT,2

			  02  01  02  00  01  00000 P.AAA:  .BYTE   1, 0, 2, 1, 2					      ;
					      00005	    .BLKB   3

							    .PSECT  $LOCKEDD1$,NOEXE,2

					      00000 POOL_BASE:
							    .BLKB   3
					      00003	    .BLKB   1
					      00004 POOL_SIZE:
							    .BLKB   3
					      00007	    .BLKB   1
					      00008 POOL_LRU:
							    .BLKB   24
					      00020 BUFFER_LRU:
							    .BLKB   4
					      00024 BUFFER_FID:
							    .BLKB   4
					      00028 BUFFER_LBN:
							    .BLKB   4
					      0002C BUFFER_UCB:
							    .BLKB   4
					      00030 BUFFER_DIRTY:
							    .BLKB   4
					      00034 BUFFERS:.BLKB   4
					      00038 BUFFER_COUNT:
							    .BLKB   4

						    POOL_TABLE=		P.AAA
							    .EXTRN  ACP$GW_MAPCACHE, ACP$GW_HDRCACHE, ACP$GW_DIRCACHE
							    .EXTRN  SYS$EXPREG, SYS$EXIT

							    .PSECT  $CODE$,NOWRT,2

					 03FC 00008 	    .ENTRY  INIT_POOL, Save R2,R3,R4,R5,R6,R7,R8,R9		      ; 0554
		         59 	0000'  CF  9E 0000A 	    MOVAB   BUFFER_LRU, R9					      ;
		         5E 	       08  C2 0000F 	    SUBL2   #8, SP						      ;
		         50 00000000G  9F  3C 00012 	    MOVZWL  @#ACP$GW_MAPCACHE, R0				      ; 0616
		         01 	       50  B1 00019 	    CMPW    R0, #1						      ;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 3-3
;
				       03  1E 0001C 	    BGEQU   1$							      ;
		         50 	       01  D0 0001E 	    MOVL    #1, R0						      ;
		         55 	       50  D0 00021 1$:     MOVL    R0, MAP_COUNT					      ;
		         50 00000000G  9F  3C 00024 	    MOVZWL  @#ACP$GW_HDRCACHE, R0				      ; 0617
		         01 	       50  B1 0002B 	    CMPW    R0, #1						      ;
				       03  1E 0002E 	    BGEQU   2$							      ;
		         50 	       01  D0 00030 	    MOVL    #1, R0						      ;
		         56 	       50  D0 00033 2$:     MOVL    R0, HDR_COUNT					      ;
		         50 00000000G  9F  3C 00036 	    MOVZWL  @#ACP$GW_DIRCACHE, R0				      ; 0618
		         02 	       50  B1 0003D 	    CMPW    R0, #2						      ;
				       03  1E 00040 	    BGEQU   3$							      ;
		         50 	       02  D0 00042 	    MOVL    #2, R0						      ;
		         58 	       50  D0 00045 3$:     MOVL    R0, DIR_COUNT					      ;
	   57 	         55 	       56  C1 00048 	    ADDL3   HDR_COUNT, MAP_COUNT, R7				      ; 0619
	   52 	         57 	       58  C1 0004C 	    ADDL3   DIR_COUNT, R7, BUFFER_SIZE				      ;
	   50 	         52 000000A1   8F  C5 00050 	    MULL3   #161, BUFFER_SIZE, R0				      ; 0620
		         50 	0FFF   C0  9E 00058 	    MOVAB   4095(R0), R0					      ;
		         50 00001000   8F  C6 0005D 	    DIVL2   #4096, R0						      ;
	   54 	         50 	       52  C1 00064 	    ADDL3   BUFFER_SIZE, R0, SIZE_NEEDED			      ;
		         7E 	       01  7D 00068 	    MOVQ    #1, -(SP)						      ; 0622
				  08   AE  9F 0006B 	    PUSHAB  SPACE_DESC						      ;
				       54  DD 0006E 	    PUSHL   SIZE_NEEDED						      ;
	      00000000G  9F	       04  FB 00070 	    CALLS   #4, @#SYS$EXPREG					      ;
	   50 	    04   AE	       6E  C3 00077 	    SUBL3   SPACE_DESC, SPACE_DESC+4, R0			      ; 0628
		         50 00000200   8F  C6 0007C 	    DIVL2   #512, R0						      ;
		         53 	  01   A0  9E 00083 	    MOVAB   1(R0), PAGE_COUNT					      ;
		         05 	       53  D1 00087 	    CMPL    PAGE_COUNT, #5					      ; 0629
				       0C  1E 0008A 	    BGEQU   4$							      ;
		         7E 	0124   8F  3C 0008C 	    MOVZWL  #292, -(SP)						      ; 0630
	      00000000G  9F	       01  FB 00091 	    CALLS   #1, @#SYS$EXIT					      ;
		         54 	       53  D1 00098 4$:     CMPL    PAGE_COUNT, SIZE_NEEDED				      ; 0632
				       1B  1E 0009B 	    BGEQU   5$							      ;
	   53 	         53 	       0C  78 0009D 	    ASHL    #12, R3, R3						      ; 0635
	   52 	         53 000010A1   8F  C7 000A1 	    DIVL3   #4257, R3, BUFFER_SIZE				      ;
	   56 	         52 	       08  C7 000A9 	    DIVL3   #8, BUFFER_SIZE, HDR_COUNT				      ; 0636
		         55 	       56  D0 000AD 	    MOVL    HDR_COUNT, MAP_COUNT				      ;
	   57 	         55 	       56  C1 000B0 	    ADDL3   HDR_COUNT, MAP_COUNT, R7				      ; 0637
	   58 	         52 	       57  C3 000B4 	    SUBL3   R7, BUFFER_SIZE, DIR_COUNT				      ;
		         69 	       6E  D0 000B8 5$:     MOVL    SPACE_DESC, BUFFER_LRU				      ; 0644
		    04   A9	  00 B942  7E 000BB 	    MOVAQ   @BUFFER_LRU[BUFFER_SIZE], BUFFER_FID		      ; 0645
		    08   A9	  04 B942  DE 000C1 	    MOVAL   @BUFFER_FID[BUFFER_SIZE], BUFFER_LBN		      ; 0646
		    0C   A9	  08 B942  DE 000C7 	    MOVAL   @BUFFER_LBN[BUFFER_SIZE], BUFFER_UCB		      ; 0647
		    10   A9	  0C B942  DE 000CD 	    MOVAL   @BUFFER_UCB[BUFFER_SIZE], BUFFER_DIRTY		      ; 0648
		         50 	  07   A2  9E 000D3 	    MOVAB   7(R2), R0						      ; 0649
		         50 	       08  C6 000D7 	    DIVL2   #8, R0						      ;
		         50 	  10   A9  C0 000DA 	    ADDL2   BUFFER_DIRTY, R0					      ;
		         50 	01FF   C0  9E 000DE 	    MOVAB   511(R0), R0						      ;
      14   A9	         50 000001FF   8F  CB 000E3 	    BICL3   #511, R0, BUFFERS					      ;
		    E4   A9	       55  90 000EC 	    MOVB    MAP_COUNT, POOL_SIZE				      ; 0651
		    E5   A9	       56  90 000F0 	    MOVB    HDR_COUNT, POOL_SIZE+1				      ; 0652
		    E6   A9	       58  90 000F4 	    MOVB    DIR_COUNT, POOL_SIZE+2				      ; 0653
				  E0   A9  94 000F8 	    CLRB    POOL_BASE						      ; 0654
		    E1   A9	       55  90 000FB 	    MOVB    MAP_COUNT, POOL_BASE+1				      ; 0655
		    E2   A9	       57  90 000FF 	    MOVB    R7, POOL_BASE+2					      ; 0656
		    18   A9	       52  D0 00103 	    MOVL    BUFFER_SIZE, BUFFER_COUNT				      ; 0657

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 3-4
;
				       50  D4 00107 	    CLRL    POOL						      ; 0663
		         51 	  E8 A940  7E 00109 6$:     MOVAQ   POOL_LRU[POOL], R1					      ; 0665
		         61 	       51  D0 0010E 	    MOVL    R1, (R1)						      ;
				  EC A940  7F 00111 	    PUSHAQ  POOL_LRU+4[POOL]					      ; 0666
		         9E 	       51  D0 00115 	    MOVL    R1, @(SP)+						      ;
		         52 	  E4 A940  9A 00118 	    MOVZBL  POOL_SIZE[POOL], R2					      ; 0668
		         51 	       01  CE 0011D 	    MNEGL   #1, I						      ;
				       16  11 00120 	    BRB     8$							      ;
		         54 	  E0 A940  9A 00122 7$:     MOVZBL  POOL_BASE[POOL], R4					      ; 0669
		         54 	       51  C0 00127 	    ADDL2   I, R4						      ;
				  EC A940  7F 0012A 	    PUSHAQ  POOL_LRU+4[POOL]					      ; 0670
		         53 	       9E  D0 0012E 	    MOVL    @(SP)+, R3						      ;
				  00 B944  7F 00131 	    PUSHAQ  @BUFFER_LRU[R4]					      ; 0669
		         63 	       9E  0E 00135 	    INSQUE  @(SP)+, (R3)					      ;
	   E6 	         51 	       52  F2 00138 8$:     AOBLSS  R2, I, 7$						      ; 0668
	   C9 	         50 	       02  F3 0013C 	    AOBLEQ  #2, POOL, 6$					      ; 0663
					   04 00140 	    RET     							      ; 0554

; Routine Size:  313 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 4
;
;	0674	ROUTINE FIND_BUFFER (LBN, TYPE, COUNT, FOUND_COUNT) =
;	0675	
;	0676	!++
;	0677	!
;	0678	! FUNCTIONAL DESCRIPTION:
;	0679	!
;	0680	!	This routine searches for a buffer suitable for the indicated
;	0681	!	block(s). It looks first for a buffer containing that block; failing
;	0682	!	that, it finds free buffers or frees them.
;	0683	!
;	0684	! CALLING SEQUENCE:
;	0685	!	FIND_BUFFER (ARG1, ARG2, ARG3, ARG4)
;	0686	!
;	0687	! INPUT PARAMETERS:
;	0688	!	ARG1: LBN of first desired block
;	0689	!	ARG2: type code of buffer
;	0690	!	ARG3: length of buffer desired in blocks
;	0691	!
;	0692	! IMPLICIT INPUTS:
;	0693	!	CURRENT_UCB: UCB of device in use
;	0694	!	DIR_FCB: FCB of directory file
;	0695	!
;	0696	! OUTPUT PARAMETERS:
;	0697	!	ARG4: number of blocks of buffer reserved
;	0698	!
;	0699	! IMPLICIT OUTPUTS:
;	0700	!	BUFFER_LBN: (of returned buffer(s)) LBN of block
;	0701	!	BUFFER_UCB: (of returned buffer(s)) CURRENT_UCB if block was resident,
;	0702	!		zero if new buffer
;	0703	!
;	0704	! ROUTINE VALUE:
;	0705	!	index of first buffer found
;	0706	!
;	0707	! SIDE EFFECTS:
;	0708	!	LRU list relinked, buffers may be written
;	0709	!
;	0710	!--
;	0711	
;	0712	BEGIN
;	0713	
;	0714	LOCAL
;	0715		I,				! index of found buffer
;	0716		N,				! number of found buffers
;	0717		POOL,				! index of pool to use
;	0718		NEXT_LBN,			! next higher LBN in pool
;	0719		LRU_ENTRY	: REF BLOCK;	! pointer to buffer LRU entry
;	0720	
;	0721	EXTERNAL
;	0722		CURRENT_UCB	: REF BBLOCK,	! UCB of current device
;	0723		CURRENT_VCB	: REF BBLOCK,	! VCB of current device
;	0724		CURRENT_FIB	: REF BBLOCK,	! address of FIB of current operation
;	0725		PMS_TOT_CACHE,			! cumulative count of buffer cache hits
;	0726		DIR_FCB		: REF BBLOCK,	! directory FCB
;	0727		ACP$GB_MAXREAD	: BYTE ADDRESSING_MODE (ABSOLUTE);
;	0728						! maximum number of blocks to read

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 4-1
;
;	0729	
;	0730	
;	0731	! First search the indicated buffer pool for a buffer containing the
;	0732	! desired LBN and UCB. Also track the LBN of the next highest block in the
;	0733	! cache. Note that we assume that block type classes are
;	0734	! nonintersecting sets, and thus avoid having the same block show up in
;	0735	! multiple pools by good behavior in the file system.
;	0736	!
;	0737	
;	0738	POOL = .POOL_TABLE[.TYPE];
;	0739	NEXT_LBN = -1;
;	0740	
;	0741	I = (
;	0742	    INCR J FROM .POOL_BASE[.POOL] TO .POOL_BASE[.POOL] + .POOL_SIZE[.POOL] - 1
;	0743	    DO
;	0744	    IF .BUFFER_UCB[.J] EQL .CURRENT_UCB
;	0745	    THEN
;	0746		BEGIN
;	0747		IF  .BUFFER_LBN[.J] GEQU .LBN
;	0748		AND .BUFFER_LBN[.J] LSSU .NEXT_LBN
;	0749		THEN NEXT_LBN = .BUFFER_LBN[.J];
;	0750	
;	0751		IF .BUFFER_LBN[.J] EQL .LBN
;	0752		THEN EXITLOOP .J
;	0753		END
;	0754	    );
;	0755	
;	0756	! If we found a block, pull the buffer out of the LRU and count a cache hit.
;	0757	! Link the buffer onto the end of the LRU list to indicate recent use.
;	0758	! On a cache hit, we always return exactly one block.
;	0759	!
;	0760	
;	0761	IF .I NEQ -1
;	0762	THEN
;	0763	    BEGIN
;	0764	    REMQUE (BUFFER_LRU[.I, LRU_FLINK], LRU_ENTRY);
;	0765	    INSQUE (.LRU_ENTRY, .POOL_LRU[.POOL, LRU_BLINK]);
;	0766	    PMS_TOT_CACHE = .PMS_TOT_CACHE + 1;
;	0767	    .FOUND_COUNT = 1;
;	0768	    END
;	0769	
;	0770	! Get the first buffer on the LRU. If multiple buffers are requested,
;	0771	! grab additional buffers in ascending memory order until we hit the end of the
;	0772	! pool. Stop if we hit a block that is already in the cache (recorded by
;	0773	! NEXT_LBN). If we still need more, get them in descending memory order. Then
;	0774	! loop for all found buffers, relinking them onto the LRU in ascending
;	0775	! order and writing them if they are dirty.
;	0776	!
;	0777	
;	0778	ELSE
;	0779	    BEGIN
;	0780	    I = (.POOL_LRU[.POOL, LRU_FLINK] - BUFFER_LRU[0, LRU_FLINK]) / 8;
;	0781	
;	0782	    N = .COUNT;
;	0783	    IF .N GTRU .ACP$GB_MAXREAD

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 4-2
;
;	0784	    THEN N = .ACP$GB_MAXREAD;
;	0785	    IF .NEXT_LBN - .LBN LEQU .N
;	0786	    THEN N = .NEXT_LBN - .LBN;
;	0787	
;	0788	    IF .POOL_SIZE[.POOL] + .POOL_BASE[.POOL] - .I LSS .N
;	0789	    THEN
;	0790		BEGIN
;	0791		IF .POOL_SIZE[.POOL] LEQ .N
;	0792		THEN
;	0793		    BEGIN
;	0794		    I = .POOL_BASE[.POOL];
;	0795		    N = .POOL_SIZE[.POOL];
;	0796		    END
;	0797		ELSE
;	0798		    I = .POOL_SIZE[.POOL] + .POOL_BASE[.POOL] - .N;
;	0799		END;
;	0800	    .FOUND_COUNT = .N;
;	0801	
;	0802	    INCR J FROM 0 TO .N-1
;	0803	    DO
;	0804		BEGIN
;	0805		REMQUE (BUFFER_LRU[.I+.J, LRU_FLINK], LRU_ENTRY);
;	0806		INSQUE (.LRU_ENTRY, .POOL_LRU[.POOL, LRU_BLINK]);
;	0807	
;	0808		IF .BUFFER_DIRTY[.I+.J]
;	0809		THEN WRITE_BLOCK (BUFFERS[.I+.J]);
;	0810	
;	0811		BUFFER_UCB[.I+.J] = 0;
;	0812		BUFFER_LBN[.I+.J] = .LBN + .J;
;	0813	
;	0814		CASE .TYPE FROM 0 TO 4 OF
;	0815		SET
;	0816		[INDEX_TYPE, HEADER_TYPE]:  BUFFER_FID[.I+.J] = 1;
;	0817		[BITMAP_TYPE]:		    BUFFER_FID[.I+.J] = 2;
;	0818		[DIRECTORY_TYPE]:	    BEGIN
;	0819					    BUFFER_FID[.I+.J] = .DIR_FCB[FCB$W_FID_NUM];
;	0820					    IF .CURRENT_VCB[VCB$V_EXTFID]
;	0821					    THEN (BUFFER_FID[.I+.J])<16,8> = .DIR_FCB[FCB$B_FID_NMX];
;	0822					    END;
;	0823		[DATA_TYPE]:		    BEGIN
;	0824					    BUFFER_FID[.I+.J] = .CURRENT_FIB[FIB$W_FID_NUM];
;	0825					    IF .CURRENT_VCB[VCB$V_EXTFID]
;	0826					    THEN (BUFFER_FID[.I+.J])<16,8> = .CURRENT_FIB[FIB$B_FID_NMX];
;	0827					    END;
;	0828		[OUTRANGE]:	(BUG_CHECK (BADBUFTYP, FATAL, 'Bad ACP buffer type code'); 0);
;	0829		TES;
;	0830		END;
;	0831	    END;
;	0832	
;	0833	RETURN .I;
;	0834	
;	0835	END;					! end of routine FIND_BUFFER




; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 4-3
;
							    .PSECT  $LOCKEDC2$,NOWRT,2

				  FEFF  0000  00000 P.AAB:  .WORD   0, -257						      ;
					0000* 00004 	    .WORD   <BUG$_BADBUFTYP!4>					      ;
					      00006	    .BLKB   2

							    .EXTRN  CURRENT_UCB, CURRENT_VCB, CURRENT_FIB, PMS_TOT_CACHE
							    .EXTRN  DIR_FCB, ACP$GB_MAXREAD, BUG$_BADBUFTYP

							    .PSECT  $CODE$,NOWRT,2

					 01FC 00141 FIND_BUFFER:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8				      ; 0674
		         58 	0000'  CF  9E 00143 	    MOVAB   BUFFER_FID, R8					      ;
		         50 	FEB4   CF  9E 00148 	    MOVAB   POOL_TABLE, R0					      ;
		         53 	  08 BC40  9A 0014D 	    MOVZBL  @TYPE[R0], POOL					      ; 0738
		         51 	       01  CE 00152 	    MNEGL   #1, NEXT_LBN					      ; 0739
		         52 	  DC A843  9A 00155 	    MOVZBL  POOL_BASE[POOL], R2					      ; 0742
		         54 	  E0 A843  9A 0015A 	    MOVZBL  POOL_SIZE[POOL], R4					      ;
	   56 	         52 	       54  C1 0015F 	    ADDL3   R4, R2, R6						      ;
		         50 	  FF   A2  9E 00163 	    MOVAB   -1(R2), J						      ;
				       27  11 00167 	    BRB     3$							      ;
		  0000G  CF	  08 B840  D1 00169 1$:     CMPL    @BUFFER_UCB[J], CURRENT_UCB				      ; 0744
				       1E  12 00170 	    BNEQ    3$							      ;
		         55 	  04 B840  D0 00172 	    MOVL    @BUFFER_LBN[J], R5					      ; 0747
		    04   AC	       55  D1 00177 	    CMPL    R5, LBN						      ;
				       08  1F 0017B 	    BLSSU   2$							      ;
		         51 	       55  D1 0017D 	    CMPL    R5, NEXT_LBN					      ; 0748
				       03  1E 00180 	    BGEQU   2$							      ;
		         51 	       55  D0 00182 	    MOVL    R5, NEXT_LBN					      ; 0749
		    04   AC	       55  D1 00185 2$:     CMPL    R5, LBN						      ; 0751
				       05  12 00189 	    BNEQ    3$							      ;
		         56 	       50  D0 0018B 	    MOVL    J, I						      ; 0752
				       07  11 0018E 	    BRB     4$							      ;
	   D5 	         50 	       56  F2 00190 3$:     AOBLSS  R6, J, 1$						      ; 0742
		         56 	       01  CE 00194 	    MNEGL   #1, I						      ; 0741
	      FFFFFFFF   8F	       56  D1 00197 4$:     CMPL    I, #-1						      ; 0761
				       1C  13 0019E 	    BEQL    5$							      ;
				  FC B846  7F 001A0 	    PUSHAQ  @BUFFER_LRU[I]					      ; 0764
		         57 	       9E  0F 001A4 	    REMQUE  @(SP)+, LRU_ENTRY					      ;
				  E8 A843  7F 001A7 	    PUSHAQ  POOL_LRU+4[POOL]					      ; 0765
		         50 	       9E  D0 001AB 	    MOVL    @(SP)+, R0						      ;
		         60 	       67  0E 001AE 	    INSQUE  (LRU_ENTRY), (R0)					      ;
				0000G  CF  D6 001B1 	    INCL    PMS_TOT_CACHE					      ; 0766
		    10   BC	       01  D0 001B5 	    MOVL    #1, @FOUND_COUNT					      ; 0767
				     00F9  31 001B9 	    BRW     20$							      ; 0761
				  E4 A843  7F 001BC 5$:     PUSHAQ  POOL_LRU[POOL]					      ; 0780
	   50 	         9E 	  FC   A8  C3 001C0 	    SUBL3   BUFFER_LRU, @(SP)+, R0				      ;
	   56 	         50 	       08  C7 001C5 	    DIVL3   #8, R0, I						      ;
		         50 	  0C   AC  D0 001C9 	    MOVL    COUNT, N						      ; 0782
		         55 00000000G  9F  9A 001CD 	    MOVZBL  @#ACP$GB_MAXREAD, R5				      ; 0783
		         55 	       50  D1 001D4 	    CMPL    N, R5						      ;
				       03  1B 001D7 	    BLEQU   6$							      ;
		         50 	       55  D0 001D9 	    MOVL    R5, N						      ; 0784
		         51 	  04   AC  C2 001DC 6$:     SUBL2   LBN, R1						      ; 0785

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 4-4
;
		         50 	       51  D1 001E0 	    CMPL    R1, N						      ;
				       03  1A 001E3 	    BGTRU   7$							      ;
		         50 	       51  D0 001E5 	    MOVL    R1, N						      ; 0786
	   51 	         54 	       52  C1 001E8 7$:     ADDL3   R2, R4, R1						      ; 0788
	   55 	         51 	       56  C3 001EC 	    SUBL3   I, R1, R5						      ;
		         50 	       55  D1 001F0 	    CMPL    R5, N						      ;
				       11  18 001F3 	    BGEQ    9$							      ;
		         50 	       54  D1 001F5 	    CMPL    R4, N						      ; 0791
				       08  14 001F8 	    BGTR    8$							      ;
		         56 	       52  D0 001FA 	    MOVL    R2, I						      ; 0794
		         50 	       54  D0 001FD 	    MOVL    R4, N						      ; 0795
				       04  11 00200 	    BRB     9$							      ; 0791
	   56 	         51 	       50  C3 00202 8$:     SUBL3   N, R1, I						      ; 0798
		    10   BC	       50  D0 00206 9$:     MOVL    N, @FOUND_COUNT					      ; 0800
		         54 	       50  D0 0020A 	    MOVL    N, R4						      ; 0802
		         55 	       01  CE 0020D 	    MNEGL   #1, J						      ;
				       79  11 00210 	    BRB     16$							      ;
	   50 	         56 	       55  C1 00212 10$:    ADDL3   J, I, R0						      ; 0805
				  FC B840  7F 00216 	    PUSHAQ  @BUFFER_LRU[R0]					      ;
		         57 	       9E  0F 0021A 	    REMQUE  @(SP)+, LRU_ENTRY					      ;
				  E8 A843  7F 0021D 	    PUSHAQ  POOL_LRU+4[POOL]					      ; 0806
		         50 	       9E  D0 00221 	    MOVL    @(SP)+, R0						      ;
		         60 	       67  0E 00224 	    INSQUE  (LRU_ENTRY), (R0)					      ;
	   52 	         56 	       55  C1 00227 	    ADDL3   J, I, R2						      ; 0808
	   0D 	    0C   B8	       52  E1 0022B 	    BBC     R2, @BUFFER_DIRTY, 11$				      ;
	   50 	         52 	       09  78 00230 	    ASHL    #9, R2, R0						      ; 0809
				  10 B840  9F 00234 	    PUSHAB  @BUFFERS[R0]					      ;
		  0000V  CF	       01  FB 00238 	    CALLS   #1, WRITE_BLOCK					      ;
				  08 B842  D4 0023D 11$:    CLRL    @BUFFER_UCB[R2]					      ; 0811
		    04 B842	  04 BC45  9E 00241 	    MOVAB   @LBN[J], @BUFFER_LBN[R2]				      ; 0812
	   04 	         00 	  08   AC  CF 00248 	    CASEL   TYPE, #0, #4					      ; 0814
	 001F 	       0018 	     0011     0024D 12$:    .WORD   13$-12$,-						      ;
		       0040 	     0011     00253		    14$-12$,-						      ;
								    15$-12$,-						      ;
								    13$-12$,-						      ;
								    17$-12$						      ;
		  0000'  CF	       00  FB 00257 	    CALLS   #0, P.AAB						      ; 0828
				       4E  11 0025C 	    BRB     18$							      ; 0814
		    00 B842	       01  D0 0025E 13$:    MOVL    #1, @BUFFER_FID[R2]					      ; 0816
				       47  11 00263 	    BRB     18$							      ; 0814
		    00 B842	       02  D0 00265 14$:    MOVL    #2, @BUFFER_FID[R2]					      ; 0817
				       40  11 0026A 	    BRB     18$							      ; 0814
		         50 	0000G  CF  D0 0026C 15$:    MOVL    DIR_FCB, R0						      ; 0819
		    00 B842	  20   A0  3C 00271 	    MOVZWL  32(R0), @BUFFER_FID[R2]				      ;
		         51 	0000G  CF  D0 00277 	    MOVL    CURRENT_VCB, R1					      ; 0820
	   2B 	    0B   A1	       05  E1 0027C 	    BBC     #5, 11(R1), 18$					      ;
				  00 B842  DF 00281 	    PUSHAL  @BUFFER_FID[R2]					      ; 0821
	   08 	         10 	  25   A0  F0 00285 	    INSV    37(R0), #16, #8, @(SP)+				      ;
				       9E     0028A									      ;
				       1F  11 0028B 16$:    BRB     18$							      ; 0814
		         50 	0000G  CF  D0 0028D 17$:    MOVL    CURRENT_FIB, R0					      ; 0824
		    00 B842	  04   A0  3C 00292 	    MOVZWL  4(R0), @BUFFER_FID[R2]				      ;
		         51 	0000G  CF  D0 00298 	    MOVL    CURRENT_VCB, R1					      ; 0825
	   0A 	    0B   A1	       05  E1 0029D 	    BBC     #5, 11(R1), 18$					      ;
				  00 B842  DF 002A2 	    PUSHAL  @BUFFER_FID[R2]					      ; 0826

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 4-5
;
	   08 	         10 	  09   A0  F0 002A6 	    INSV    9(R0), #16, #8, @(SP)+				      ;
				       9E     002AB									      ;
	   02 	         55 	       54  F2 002AC 18$:    AOBLSS  R4, J, 19$						      ; 0802
				       03  11 002B0 	    BRB     20$							      ;
				     FF5D  31 002B2 19$:    BRW     10$							      ;
		         50 	       56  D0 002B5 20$:    MOVL    I, R0						      ; 0833
					   04 002B8 	    RET     							      ; 0674

; Routine Size:  376 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 5
;
;	0836	GLOBAL ROUTINE READ_BLOCK (LBN, COUNT, TYPE) =
;	0837	
;	0838	!++
;	0839	!
;	0840	! FUNCTIONAL DESCRIPTION:
;	0841	!
;	0842	!	This routine reads the desired block(s) from the disk.
;	0843	!	Blocks are categorized by type to aid buffer management.
;	0844	!	Note that the caller assumes only one block is ever read; multiple
;	0845	!	blocks read ahead are acquired through cache hits on subsequent calls.
;	0846	!
;	0847	! CALLING SEQUENCE:
;	0848	!	READ_BLOCK (ARG1, ARG2, ARG3)
;	0849	!
;	0850	! INPUT PARAMETERS:
;	0851	!	ARG1: LBN of block(s)
;	0852	!	ARG2: number of blocks to read
;	0853	!	ARG3: block type code
;	0854	!
;	0855	! IMPLICIT INPUTS:
;	0856	!	CURRENT_UCB contains address of UCB in process
;	0857	!
;	0858	! OUTPUT PARAMETERS:
;	0859	!	NONE
;	0860	!
;	0861	! IMPLICIT OUTPUTS:
;	0862	!	IO_STATUS receives status of I/O transfer
;	0863	!
;	0864	! ROUTINE VALUE:
;	0865	!	address of buffer containing block
;	0866	!
;	0867	! SIDE EFFECTS:
;	0868	!	BLOCK READ
;	0869	!
;	0870	!--
;	0871	
;	0872	BEGIN
;	0873	
;	0874	LOCAL
;	0875		I,				! index of buffer used
;	0876		STATUS,				! QIO service status
;	0877		FOUND_COUNT;			! count of buffers gotten
;	0878	
;	0879	EXTERNAL
;	0880		PMS_TOT_READ,			! cumulative count of disk reads
;	0881		CLEANUP_FLAGS	: BITVECTOR,	! cleanup action flags
;	0882		DIR_VBN,			! current VBN in directory buffer
;	0883		BITMAP_VBN,			! current VBN in storage map buffer
;	0884		IO_CHANNEL,			! channel number for all I/O
;	0885		CURRENT_UCB,			! UCB of device in process
;	0886		IO_STATUS	: VECTOR;	! common I/O status block
;	0887	
;	0888	
;	0889	! Find a suitable block buffer. If it does not already contain the block,
;	0890	! read it.

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 5-1
;
;	0891	!
;	0892	
;	0893	I = FIND_BUFFER (.LBN, .TYPE, .COUNT, FOUND_COUNT);
;	0894	
;	0895	IF .BUFFER_UCB[.I] EQL 0
;	0896	THEN
;	0897	    BEGIN
;	0898	    PMS_TOT_READ = .PMS_TOT_READ + 1;
;	0899	    STATUS = $QIOW (
;     P 0900			EFN   = EFN,
;     P 0901			CHAN  = .IO_CHANNEL,
;     P 0902			FUNC  = IO$_READLBLK,
;     P 0903			IOSB  = IO_STATUS,
;     P 0904			P1    = BUFFERS[.I],
;     P 0905			P2    = .FOUND_COUNT*512,
;     P 0906			P3    = .LBN
;     P 0907			);
;	0908	    IF NOT .STATUS THEN IO_STATUS = .STATUS;
;	0909	    IF NOT .IO_STATUS
;	0910	    THEN
;	0911		BEGIN
;	0912		INCR J FROM 0 TO .FOUND_COUNT-1
;	0913		DO
;	0914		    INVALIDATE (BUFFERS[.I+.J]);
;	0915		DIR_VBN = 0;
;	0916		BITMAP_VBN = 0;
;	0917		ERR_EXIT (SS$_FCPREADERR);
;	0918		END;
;	0919	    INCR J FROM 0 TO .FOUND_COUNT - 1
;	0920	    DO
;	0921		BUFFER_UCB[.I+.J] = .CURRENT_UCB;
;	0922	    END;
;	0923	
;	0924	RETURN BUFFERS[.I];
;	0925	
;	0926	END;					! end of routine READ_BLOCK



							    .EXTRN  PMS_TOT_READ, CLEANUP_FLAGS, DIR_VBN, BITMAP_VBN
							    .EXTRN  IO_CHANNEL, IO_STATUS, SYS$QIOW

					 003C 002B9 	    .ENTRY  READ_BLOCK, Save R2,R3,R4,R5			      ; 0836
		         55 	0000G  CF  9E 002BB 	    MOVAB   IO_STATUS, R5					      ;
		         54 	0000'  CF  9E 002C0 	    MOVAB   BUFFERS, R4						      ;
		         5E 	       04  C2 002C5 	    SUBL2   #4, SP						      ;
				       5E  DD 002C8 	    PUSHL   SP							      ; 0893
				  08   AC  DD 002CA 	    PUSHL   COUNT						      ;
				  0C   AC  DD 002CD 	    PUSHL   TYPE						      ;
				  04   AC  DD 002D0 	    PUSHL   LBN							      ;
		  FE69   CF	       04  FB 002D3 	    CALLS   #4, FIND_BUFFER					      ;
		         53 	       50  D0 002D8 	    MOVL    R0, I						      ;
				  F8 B443  D5 002DB 	    TSTL    @BUFFER_UCB[I]					      ; 0895
				       6E  12 002DF 	    BNEQ    7$							      ;
				0000G  CF  D6 002E1 	    INCL    PMS_TOT_READ					      ; 0898

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 5-2
;
				       7E  7C 002E5 	    CLRQ    -(SP)						      ; 0907
				       7E  D4 002E7 	    CLRL    -(SP)						      ;
				  04   AC  DD 002E9 	    PUSHL   LBN							      ;
	   7E 	    10   AE	       09  78 002EC 	    ASHL    #9, FOUND_COUNT, -(SP)				      ;
	   50 	         53 	       09  78 002F1 	    ASHL    #9, I, R0						      ;
				  00 B440  9F 002F5 	    PUSHAB  @BUFFERS[R0]					      ;
				       7E  7C 002F9 	    CLRQ    -(SP)						      ;
				       55  DD 002FB 	    PUSHL   R5							      ;
				       21  DD 002FD 	    PUSHL   #33							      ;
				0000G  CF  DD 002FF 	    PUSHL   IO_CHANNEL						      ;
				       01  DD 00303 	    PUSHL   #1							      ;
	      00000000G  9F	       0C  FB 00305 	    CALLS   #12, @#SYS$QIOW					      ;
		         03 	       50  E8 0030C 	    BLBS    STATUS, 1$						      ; 0908
		         65 	       50  D0 0030F 	    MOVL    STATUS, IO_STATUS					      ;
		         26 	       65  E8 00312 1$:     BLBS    IO_STATUS, 4$					      ; 0909
		         52 	       01  CE 00315 	    MNEGL   #1, J						      ; 0912
				       11  11 00318 	    BRB     3$							      ;
	   50 	         53 	       52  C1 0031A 2$:     ADDL3   J, I, R0						      ; 0914
	   50 	         50 	       09  78 0031E 	    ASHL    #9, R0, R0						      ;
				  00 B440  9F 00322 	    PUSHAB  @BUFFERS[R0]					      ;
		  0000V  CF	       01  FB 00326 	    CALLS   #1, INVALIDATE					      ;
	   EB 	         52 	       6E  F2 0032B 3$:     AOBLSS  FOUND_COUNT, J, 2$					      ; 0912
				0000G  CF  D4 0032F 	    CLRL    DIR_VBN						      ; 0915
				0000G  CF  D4 00333 	    CLRL    BITMAP_VBN						      ; 0916
				0888   8F  BF 00337 	    CHMU    #2184						      ; 0917
		         51 	       01  CE 0033B 4$:     MNEGL   #1, J						      ; 0919
				       0B  11 0033E 	    BRB     6$							      ;
	   50 	         53 	       51  C1 00340 5$:     ADDL3   J, I, R0						      ; 0921
		    F8 B440	0000G  CF  D0 00344 	    MOVL    CURRENT_UCB, @BUFFER_UCB[R0]			      ;
	   F1 	         51 	       6E  F2 0034B 6$:     AOBLSS  FOUND_COUNT, J, 5$					      ; 0919
	   50 	         53 	       09  78 0034F 7$:     ASHL    #9, I, R0						      ; 0924
		         50 	       64  C0 00353 	    ADDL2   BUFFERS, R0						      ;
					   04 00356 	    RET     							      ; 0836

; Routine Size:  158 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 6
;
;	0927	GLOBAL ROUTINE RESET_LBN (BUFFER, LBN) : NOVALUE =
;	0928	
;	0929	!++
;	0930	!
;	0931	! FUNCTIONAL DESCRIPTION:
;	0932	!
;	0933	!	This routine changes the resident LBN of the indicated block.
;	0934	!
;	0935	! CALLING SEQUENCE:
;	0936	!	RESET_LBN (ARG1, ARG2)
;	0937	!
;	0938	! INPUT PARAMETERS:
;	0939	!	ARG1: address of block buffer
;	0940	!	ARG2: new LBN
;	0941	!
;	0942	! IMPLICIT INPUTS:
;	0943	!	buffer descriptor arrays
;	0944	!
;	0945	! OUTPUT PARAMETERS:
;	0946	!	NONE
;	0947	!
;	0948	! IMPLICIT OUTPUTS:
;	0949	!	NONE
;	0950	!
;	0951	! ROUTINE VALUE:
;	0952	!	NONE
;	0953	!
;	0954	! SIDE EFFECTS:
;	0955	!	backing LBN for buffer altered
;	0956	!
;	0957	!--
;	0958	
;	0959	BEGIN
;	0960	
;	0961	LOCAL
;	0962		I;				! index of buffer
;	0963	
;	0964	
;	0965	! Compute the buffer index from the buffer address supplied. Set the
;	0966	! buffer dirty bit and store the new LBN.
;	0967	!
;	0968	
;	0969	IF .BUFFER LSSU BUFFERS[0] OR .BUFFER GEQU BUFFERS[.BUFFER_COUNT]
;	0970	THEN BUG_CHECK (BADBUFADR, FATAL, 'ACP buffer address out of range of buffer pool');
;	0971	
;	0972	I = (.BUFFER - BUFFERS[0]) / 512;
;	0973	BUFFER_DIRTY[.I] = 1;
;	0974	
;	0975	BUFFER_LBN[.I] = .LBN;
;	0976	
;	0977	END;					! end of routine RESET_LBN



							    .PSECT  $LOCKEDC2$,NOWRT,2

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 6-1
;

				  FEFF  0000  00008 P.AAC:  .WORD   0, -257						      ;
					0000* 0000C 	    .WORD   <BUG$_BADBUFADR!4>					      ;
					      0000E	    .BLKB   2

							    .EXTRN  BUG$_BADBUFADR

							    .PSECT  $CODE$,NOWRT,2

					 0004 00357 	    .ENTRY  RESET_LBN, Save R2					      ; 0927
		         52 	0000'  CF  9E 00359 	    MOVAB   BUFFERS, R2						      ;
		         62 	  04   AC  D1 0035E 	    CMPL    BUFFER, BUFFERS					      ; 0969
				       0E  1F 00362 	    BLSSU   1$							      ;
	   50 	    04   A2	       09  78 00364 	    ASHL    #9, BUFFER_COUNT, R0				      ;
		         50 	       62  C0 00369 	    ADDL2   BUFFERS, R0						      ;
		         50 	  04   AC  D1 0036C 	    CMPL    BUFFER, R0						      ;
				       05  1F 00370 	    BLSSU   2$							      ;
		  0000'  CF	       00  FB 00372 1$:     CALLS   #0, P.AAC						      ; 0970
	   50 	    04   AC	       62  C3 00377 2$:     SUBL3   BUFFERS, BUFFER, R0					      ; 0972
		         50 00000200   8F  C6 0037C 	    DIVL2   #512, I						      ;
	   00 	    FC   B2	       50  E2 00383 	    BBSS    I, @BUFFER_DIRTY, 3$				      ; 0973
		    F4 B240	  08   AC  D0 00388 3$:     MOVL    LBN, @BUFFER_LBN[I]					      ; 0975
					   04 0038E 	    RET     							      ; 0927

; Routine Size:  56 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 7
;
;	0978	GLOBAL ROUTINE WRITE_BLOCK (BUFFER) : NOVALUE =
;	0979	
;	0980	!++
;	0981	!
;	0982	! FUNCTIONAL DESCRIPTION:
;	0983	!
;	0984	!	This routine writes the indicated block back to the disk.
;	0985	!
;	0986	! CALLING SEQUENCE:
;	0987	!	WRITE_BLOCK (ARG1)
;	0988	!
;	0989	! INPUT PARAMETERS:
;	0990	!	ARG1: address of block buffer
;	0991	!
;	0992	! IMPLICIT INPUTS:
;	0993	!	BUFFER DESCRIPTOR ARRAYS
;	0994	!
;	0995	! OUTPUT PARAMETERS:
;	0996	!	NONE
;	0997	!
;	0998	! IMPLICIT OUTPUTS:
;	0999	!	NONE
;	1000	!
;	1001	! ROUTINE VALUE:
;	1002	!	NONE
;	1003	!
;	1004	! SIDE EFFECTS:
;	1005	!	block written
;	1006	!
;	1007	!--
;	1008	
;	1009	BEGIN
;	1010	
;	1011	LOCAL
;	1012		STATUS,				! service status of QIO call
;	1013		I;				! index of buffer
;	1014	
;	1015	EXTERNAL
;	1016		PMS_TOT_WRITE,			! cumulative count of disk writes
;	1017		CURRENT_UCB	: REF BBLOCK,	! UCB of volume in process
;	1018		DIR_VBN,			! current VBN in directory buffer
;	1019		BITMAP_VBN,			! current VBN in storage map buffer
;	1020		UNREC_COUNT,			! unrecorded but allocated blocks
;	1021		NEW_FID,			! unrecorded new file ID
;	1022		IO_CHANNEL,			! channel number for all I/O
;	1023		IO_STATUS	: VECTOR,	! status block for all I/O
;	1024		CLEANUP_FLAGS	: BITVECTOR,	! cleanup action flags
;	1025		CONTEXT_SAVE	: BITVECTOR,	! context save area
;	1026		CONTEXT_START;			! start of reentrant context area
;	1027	
;	1028	
;	1029	! Compute the buffer index from the buffer address supplied. Clear the
;	1030	! buffer dirty bit and make sure the buffer ucb address corresponds to the
;	1031	! current UCB.
;	1032	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 7-1
;
;	1033	
;	1034	IF .BUFFER LSSU BUFFERS[0] OR .BUFFER GEQU BUFFERS[.BUFFER_COUNT]
;	1035	THEN BUG_CHECK (BADBUFADR, FATAL, 'ACP buffer address out of range of buffer pool');
;	1036	
;	1037	I = (.BUFFER - BUFFERS[0]) / 512;
;	1038	BUFFER_DIRTY[.I] = 0;
;	1039	
;	1040	IF .BUFFER_UCB[.I] NEQ .CURRENT_UCB
;	1041	    THEN BUG_CHECK (WRTINVBUF, FATAL, 'ACP attempted to write an invalid buffer');
;	1042	
;	1043	PMS_TOT_WRITE = .PMS_TOT_WRITE + 1;
;	1044	STATUS = $QIOW (
;     P 1045			EFN  = EFN,
;     P 1046			CHAN = .IO_CHANNEL,
;     P 1047			FUNC = IO$_WRITELBLK,
;     P 1048			IOSB = IO_STATUS,
;     P 1049			P1   = BUFFERS[.I],
;     P 1050			P2   = 512,
;     P 1051			P3   = .BUFFER_LBN[.I]
;     P 1052			);
;	1053	
;	1054	! If an I/O error occurrs, we must take special error handling. The first level
;	1055	! handling currently implemented works for simple errors such as a write
;	1056	! locked disk. It will not correctly unwind if successful writes have already
;	1057	! occurred. We flush the cache of all buffers containing blocks from the current
;	1058	! volume, and disable those portions of the cleanup that attempt to alter the
;	1059	! disk.
;	1060	!
;	1061	
;	1062	IF NOT .STATUS THEN IO_STATUS = .STATUS;
;	1063	IF NOT .IO_STATUS
;	1064	THEN
;	1065	    BEGIN
;	1066	    DIR_VBN = 0;
;	1067	    BITMAP_VBN = 0;
;	1068	    NEW_FID = 0;
;	1069	    UNREC_COUNT = 0;
;	1070	    CLEANUP_FLAGS = .CLEANUP_FLAGS AND NOT CLF_M_WRITEDISK;
;	1071	    CLEANUP_FLAGS[CLF_FIXFCB] = 1;
;	1072	    IF .CONTEXT_SAVE NEQ 0
;	1073	    THEN
;	1074		BEGIN
;	1075		(CONTEXT_SAVE - CONTEXT_START + UNREC_COUNT) = 0;
;	1076		CONTEXT_SAVE = .CONTEXT_SAVE AND NOT CLF_M_WRITEDISK;
;	1077		CONTEXT_SAVE[CLF_FIXFCB] = 1;
;	1078		END;
;	1079	    CH$FILL (0, (.BUFFER_COUNT+7)/8, BUFFER_DIRTY[0]);
;	1080	    FLUSH_FID (0);
;	1081	    IF .IO_STATUS<0,16> EQL SS$_WRITLCK
;	1082	    THEN ERR_EXIT (.IO_STATUS<0,16>)
;	1083	    ELSE ERR_EXIT (SS$_FCPWRITERR);
;	1084	    END;
;	1085	
;	1086	END;					! end of routine WRITE_BLOCK


; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 7-2
;


							    .PSECT  $LOCKEDC2$,NOWRT,2

				  FEFF  0000  00010 P.AAD:  .WORD   0, -257						      ;
					0000* 00014 	    .WORD   <BUG$_BADBUFADR!4>					      ;
					      00016	    .BLKB   2
				  FEFF  0000  00018 P.AAE:  .WORD   0, -257						      ;
					0000* 0001C 	    .WORD   <BUG$_WRTINVBUF!4>					      ;
					      0001E	    .BLKB   2

							    .EXTRN  PMS_TOT_WRITE, UNREC_COUNT, NEW_FID, CONTEXT_SAVE
							    .EXTRN  CONTEXT_START, BUG$_WRTINVBUF

							    .PSECT  $CODE$,NOWRT,2

					 01FC 0038F 	    .ENTRY  WRITE_BLOCK, Save R2,R3,R4,R5,R6,R7,R8		      ; 0978
		         58 	0000G  CF  9E 00391 	    MOVAB   CONTEXT_SAVE, R8					      ;
		         57 	0000G  CF  9E 00396 	    MOVAB   IO_STATUS, R7					      ;
		         56 	0000'  CF  9E 0039B 	    MOVAB   BUFFERS, R6						      ;
		         66 	  04   AC  D1 003A0 	    CMPL    BUFFER, BUFFERS					      ; 1034
				       0E  1F 003A4 	    BLSSU   1$							      ;
	   50 	    04   A6	       09  78 003A6 	    ASHL    #9, BUFFER_COUNT, R0				      ;
		         50 	       66  C0 003AB 	    ADDL2   BUFFERS, R0						      ;
		         50 	  04   AC  D1 003AE 	    CMPL    BUFFER, R0						      ;
				       05  1F 003B2 	    BLSSU   2$							      ;
		  0000'  CF	       00  FB 003B4 1$:     CALLS   #0, P.AAD						      ; 1035
	   50 	    04   AC	       66  C3 003B9 2$:     SUBL3   BUFFERS, BUFFER, R0					      ; 1037
	   52 	         50 00000200   8F  C7 003BE 	    DIVL3   #512, R0, I						      ;
	   00 	    FC   B6	       52  E5 003C6 	    BBCC    I, @BUFFER_DIRTY, 3$				      ; 1038
		  0000G  CF	  F8 B642  D1 003CB 3$:     CMPL    @BUFFER_UCB[I], CURRENT_UCB				      ; 1040
				       05  13 003D2 	    BEQL    4$							      ;
		  0000'  CF	       00  FB 003D4 	    CALLS   #0, P.AAE						      ; 1041
				0000G  CF  D6 003D9 4$:     INCL    PMS_TOT_WRITE					      ; 1043
				       7E  7C 003DD 	    CLRQ    -(SP)						      ; 1052
				       7E  D4 003DF 	    CLRL    -(SP)						      ;
				  F4 B642  DD 003E1 	    PUSHL   @BUFFER_LBN[I]					      ;
		         7E 	0200   8F  3C 003E5 	    MOVZWL  #512, -(SP)						      ;
	   50 	         52 	       09  78 003EA 	    ASHL    #9, I, R0						      ;
				  00 B640  9F 003EE 	    PUSHAB  @BUFFERS[R0]					      ;
				       7E  7C 003F2 	    CLRQ    -(SP)						      ;
				       57  DD 003F4 	    PUSHL   R7							      ;
				       20  DD 003F6 	    PUSHL   #32							      ;
				0000G  CF  DD 003F8 	    PUSHL   IO_CHANNEL						      ;
				       01  DD 003FC 	    PUSHL   #1							      ;
	      00000000G  9F	       0C  FB 003FE 	    CALLS   #12, @#SYS$QIOW					      ;
		         03 	       50  E8 00405 	    BLBS    STATUS, 5$						      ; 1062
		         67 	       50  D0 00408 	    MOVL    STATUS, IO_STATUS					      ;
		         56 	       67  E8 0040B 5$:     BLBS    IO_STATUS, 8$					      ; 1063
				0000G  CF  D4 0040E 	    CLRL    DIR_VBN						      ; 1066
				0000G  CF  D4 00412 	    CLRL    BITMAP_VBN						      ; 1067
				0000G  CF  D4 00416 	    CLRL    NEW_FID						      ; 1068
				0000G  CF  D4 0041A 	    CLRL    UNREC_COUNT						      ; 1069
		  0000G  CF 10FC0020   8F  CA 0041E 	    BICL2   #284950560, CLEANUP_FLAGS				      ; 1070
		  0000G  CF	       02  88 00427 	    BISB2   #2, CLEANUP_FLAGS					      ; 1071

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 7-3
;
				       68  D5 0042C 	    TSTL    CONTEXT_SAVE					      ; 1072
				       10  13 0042E 	    BEQL    6$							      ;
			    00000000*  EF  D4 00430 	    CLRL    <<CONTEXT_SAVE-CONTEXT_START>+UNREC_COUNT>		      ; 1075
		         68 10FC0020   8F  CA 00436 	    BICL2   #284950560, CONTEXT_SAVE				      ; 1076
		         68 	       02  88 0043D 	    BISB2   #2, CONTEXT_SAVE					      ; 1077
	   50 	    04   A6	       07  C1 00440 6$:     ADDL3   #7, BUFFER_COUNT, R0				      ; 1079
		         50 	       08  C6 00445 	    DIVL2   #8, R0						      ;
	   00 	         6E 	       00  2C 00448 	    MOVC5   #0, (SP), #0, R0, @BUFFER_DIRTY			      ;
		    FC   B6	       50     0044C									      ;
				       7E  D4 0044F 	    CLRL    -(SP)						      ; 1080
		  0000V  CF	       01  FB 00451 	    CALLS   #1, FLUSH_FID					      ;
		  025C   8F	       67  B1 00456 	    CMPW    IO_STATUS, #604					      ; 1081
				       03  12 0045B 	    BNEQ    7$							      ;
				       67  BF 0045D 	    CHMU    IO_STATUS						      ; 1082
					   04 0045F 	    RET     							      ; 1081
				08A0   8F  BF 00460 7$:     CHMU    #2208						      ; 1083
					   04 00464 8$:     RET     							      ; 0978

; Routine Size:  214 bytes


;	1087	
;	1088	
;	1089	!++
;	1090	!
;	1091	!	The routine DIRPUT is equivalent to WRITE_BLOCK
;	1092	!
;	1093	!--
;	1094	
;	1095	GLOBAL BIND ROUTINE
;	1096		DIRPUT		= WRITE_BLOCK;	! write a directory record

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 8
;
;	1097	GLOBAL ROUTINE CREATE_BLOCK (LBN, COUNT, TYPE, COUNT_FOUND) =
;	1098	
;	1099	!++
;	1100	!
;	1101	! FUNCTIONAL DESCRIPTION:
;	1102	!
;	1103	!	This routine fabricates block buffer(s) containing the designated
;	1104	!	block(s). The type code is as for READ_BLOCK and determines the buffer
;	1105	!	pool to be used.
;	1106	!
;	1107	! CALLING SEQUENCE:
;	1108	!	CREATE_BLOCK (ARG1, ARG2, ARG3, ARG4)
;	1109	!
;	1110	! INPUT PARAMETERS:
;	1111	!	ARG1: LBN to be assigned to block
;	1112	!	ARG2: number of blocks to reserve in buffer
;	1113	!	ARG3: block type code
;	1114	!
;	1115	! IMPLICIT INPUTS:
;	1116	!	CURRENT_UCB: UCB address of device in process
;	1117	!
;	1118	! OUTPUT PARAMETERS:
;	1119	!	ARG4: number of buffers found (optional)
;	1120	!
;	1121	! IMPLICIT OUTPUTS:
;	1122	!	NONE
;	1123	!
;	1124	! ROUTINE VALUE:
;	1125	!	address of buffer
;	1126	!
;	1127	! SIDE EFFECTS:
;	1128	!	buffer zeroed and recorded as a block read
;	1129	!
;	1130	!--
;	1131	
;	1132	BEGIN
;	1133	
;	1134	LOCAL
;	1135		I,				! index of buffer to use
;	1136		FOUND_COUNT;			! number of buffers gotten
;	1137	
;	1138	EXTERNAL
;	1139		CURRENT_UCB	: REF BBLOCK;	! address of device UCB
;	1140	
;	1141	
;	1142	! Find an available buffer. Mark it resident and dirty and fill it with
;	1143	! zeroes.
;	1144	!
;	1145	
;	1146	I = FIND_BUFFER (.LBN, .TYPE, .COUNT, FOUND_COUNT);
;	1147	INCR J FROM 0 TO .FOUND_COUNT - 1
;	1148	DO
;	1149	    BEGIN
;	1150	    BUFFER_UCB[.I+.J] = .CURRENT_UCB;
;	1151	    CH$FILL (0, 512, BUFFERS[.I+.J]);

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 8-1
;
;	1152	    BUFFER_DIRTY[.I+.J] = 1;
;	1153	    END;
;	1154	
;	1155	IF ACTUALCOUNT GEQU 4
;	1156	THEN .COUNT_FOUND = .FOUND_COUNT;
;	1157	RETURN BUFFERS[.I];
;	1158	
;	1159	END;					! end of routine CREATE_BLOCK



						    DIRPUT==		WRITE_BLOCK


					 01FC 00465 	    .ENTRY  CREATE_BLOCK, Save R2,R3,R4,R5,R6,R7,R8		      ; 1097
		         5E 	       04  C2 00467 	    SUBL2   #4, SP						      ;
				       5E  DD 0046A 	    PUSHL   SP							      ; 1146
				  08   AC  DD 0046C 	    PUSHL   COUNT						      ;
				  0C   AC  DD 0046F 	    PUSHL   TYPE						      ;
				  04   AC  DD 00472 	    PUSHL   LBN							      ;
		  FCC7   CF	       04  FB 00475 	    CALLS   #4, FIND_BUFFER					      ;
		         58 	       50  D0 0047A 	    MOVL    R0, I						      ;
		         57 	       01  CE 0047D 	    MNEGL   #1, J						      ; 1147
				       21  11 00480 	    BRB     2$							      ;
	   56 	         58 	       57  C1 00482 1$:     ADDL3   J, I, R6						      ; 1150
		  0000'DF46	0000G  CF  D0 00486 	    MOVL    CURRENT_UCB, @BUFFER_UCB[R6]			      ;
	   50 	         56 	       09  78 0048E 	    ASHL    #9, R6, R0						      ; 1151
	   00 	         6E 	       00  2C 00492 	    MOVC5   #0, (SP), #0, #512, @BUFFERS[R0]			      ;
		  0000'DF40	0200   8F     00496									      ;
	   00 	  0000'  DF	       56  E2 0049D 	    BBSS    R6, @BUFFER_DIRTY, 2$				      ; 1152
	   DB 	         57 	       6E  F2 004A3 2$:     AOBLSS  FOUND_COUNT, J, 1$					      ; 1147
		         04 	       6C  91 004A7 	    CMPB    (AP), #4						      ; 1155
				       04  1F 004AA 	    BLSSU   3$							      ;
		    10   BC	       6E  D0 004AC 	    MOVL    FOUND_COUNT, @COUNT_FOUND				      ; 1156
	   50 	         58 	       09  78 004B0 3$:     ASHL    #9, I, R0						      ; 1157
		         50 	0000'  CF  C0 004B4 	    ADDL2   BUFFERS, R0						      ;
					   04 004B9 	    RET     							      ; 1097

; Routine Size:  85 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 9
;
;	1160	GLOBAL ROUTINE MARK_DIRTY (BUFFER) : NOVALUE =
;	1161	
;	1162	!++
;	1163	!
;	1164	! FUNCTIONAL DESCRIPTION:
;	1165	!
;	1166	!	This routine marks the indicated buffer for write-back.
;	1167	!
;	1168	! CALLING SEQUENCE:
;	1169	!	MARK_DIRTY (ARG1)
;	1170	!
;	1171	! INPUT PARAMETERS:
;	1172	!	ARG1: address of block buffer
;	1173	!
;	1174	! IMPLICIT INPUTS:
;	1175	!	NONE
;	1176	!
;	1177	! OUTPUT PARAMETERS:
;	1178	!	NONE
;	1179	!
;	1180	! IMPLICIT OUTPUTS:
;	1181	!	NONE
;	1182	!
;	1183	! ROUTINE VALUE:
;	1184	!	NONE
;	1185	!
;	1186	! SIDE EFFECTS:
;	1187	!	buffer marked for write-back
;	1188	!
;	1189	!--
;	1190	
;	1191	BEGIN
;	1192	
;	1193	LOCAL
;	1194		I;				! index of buffer
;	1195	
;	1196	
;	1197	IF .BUFFER LSSU BUFFERS[0] OR .BUFFER GEQU BUFFERS[.BUFFER_COUNT]
;	1198	THEN BUG_CHECK (BADBUFADR, FATAL, 'ACP buffer address out of range of buffer pool');
;	1199	
;	1200	I = (.BUFFER - BUFFERS[0]) / 512;
;	1201	
;	1202	BUFFER_DIRTY[.I] = 1;
;	1203	
;	1204	END;					! end of routine MARK_DIRTY



							    .PSECT  $LOCKEDC2$,NOWRT,2

				  FEFF  0000  00020 P.AAF:  .WORD   0, -257						      ;
					0000* 00024 	    .WORD   <BUG$_BADBUFADR!4>					      ;
					      00026	    .BLKB   2



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 9-1
;

							    .PSECT  $CODE$,NOWRT,2

					 0004 004BA 	    .ENTRY  MARK_DIRTY, Save R2					      ; 1160
		         52 	0000'  CF  9E 004BC 	    MOVAB   BUFFERS, R2						      ;
		         62 	  04   AC  D1 004C1 	    CMPL    BUFFER, BUFFERS					      ; 1197
				       0E  1F 004C5 	    BLSSU   1$							      ;
	   50 	    04   A2	       09  78 004C7 	    ASHL    #9, BUFFER_COUNT, R0				      ;
		         50 	       62  C0 004CC 	    ADDL2   BUFFERS, R0						      ;
		         50 	  04   AC  D1 004CF 	    CMPL    BUFFER, R0						      ;
				       05  1F 004D3 	    BLSSU   2$							      ;
		  0000'  CF	       00  FB 004D5 1$:     CALLS   #0, P.AAF						      ; 1198
	   50 	    04   AC	       62  C3 004DA 2$:     SUBL3   BUFFERS, BUFFER, R0					      ; 1200
		         50 00000200   8F  C6 004DF 	    DIVL2   #512, I						      ;
	   00 	    FC   B2	       50  E2 004E6 	    BBSS    I, @BUFFER_DIRTY, 3$				      ; 1202
					   04 004EB 3$:     RET     							      ; 1160

; Routine Size:  50 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 10
;
;	1205	GLOBAL ROUTINE INVALIDATE (BUFFER) : NOVALUE =
;	1206	
;	1207	!++
;	1208	!
;	1209	! FUNCTIONAL DESCRIPTION:
;	1210	!
;	1211	!	This routine invalidates the indicated buffer.
;	1212	!
;	1213	! CALLING SEQUENCE:
;	1214	!	INVALIDATE (ARG1)
;	1215	!
;	1216	! INPUT PARAMETERS:
;	1217	!	ARG1: address of block buffer
;	1218	!
;	1219	! IMPLICIT INPUTS:
;	1220	!	NONE
;	1221	!
;	1222	! OUTPUT PARAMETERS:
;	1223	!	NONE
;	1224	!
;	1225	! IMPLICIT OUTPUTS:
;	1226	!	NONE
;	1227	!
;	1228	! ROUTINE VALUE:
;	1229	!	NONE
;	1230	!
;	1231	! SIDE EFFECTS:
;	1232	!	buffer contents forgotten
;	1233	!
;	1234	!--
;	1235	
;	1236	BEGIN
;	1237	
;	1238	LOCAL
;	1239		I,				! index of buffer
;	1240		POOL,				! index of pool
;	1241		LRU_ENTRY;			! address of LRU list entry
;	1242	
;	1243	
;	1244	! A buffer is invalidated by zeroing its associated UCB address and
;	1245	! clearing the dirty bit. Also, we relink the buffer onto the front of the
;	1246	! buffer LRU to encourage its re-use.
;	1247	!
;	1248	
;	1249	IF .BUFFER LSSU BUFFERS[0] OR .BUFFER GEQU BUFFERS[.BUFFER_COUNT]
;	1250	THEN BUG_CHECK (BADBUFADR, FATAL, 'ACP buffer address out of range of buffer pool');
;	1251	
;	1252	I = (.BUFFER - BUFFERS[0]) / 512;
;	1253	POOL = (
;	1254	    INCR J FROM 0 TO POOL_COUNT-1 DO
;	1255	    IF .I LSS .POOL_BASE[.J] + .POOL_SIZE[.J]
;	1256	    THEN EXITLOOP .J
;	1257	    );
;	1258	
;	1259	BUFFER_UCB[.I] = 0;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 10-1
;
;	1260	BUFFER_DIRTY[.I] = 0;
;	1261	
;	1262	REMQUE (BUFFER_LRU[.I, LRU_FLINK], LRU_ENTRY);
;	1263	INSQUE (.LRU_ENTRY, POOL_LRU[.POOL, LRU_FLINK]);
;	1264	
;	1265	END;					! end of routine INVALIDATE



							    .PSECT  $LOCKEDC2$,NOWRT,2

				  FEFF  0000  00028 P.AAG:  .WORD   0, -257						      ;
					0000* 0002C 	    .WORD   <BUG$_BADBUFADR!4>					      ;
					      0002E	    .BLKB   2



							    .PSECT  $CODE$,NOWRT,2

					 001C 004EC 	    .ENTRY  INVALIDATE, Save R2,R3,R4				      ; 1205
		         54 	0000'  CF  9E 004EE 	    MOVAB   BUFFERS, R4						      ;
		         64 	  04   AC  D1 004F3 	    CMPL    BUFFER, BUFFERS					      ; 1249
				       0E  1F 004F7 	    BLSSU   1$							      ;
	   50 	    04   A4	       09  78 004F9 	    ASHL    #9, BUFFER_COUNT, R0				      ;
		         50 	       64  C0 004FE 	    ADDL2   BUFFERS, R0						      ;
		         50 	  04   AC  D1 00501 	    CMPL    BUFFER, R0						      ;
				       05  1F 00505 	    BLSSU   2$							      ;
		  0000'  CF	       00  FB 00507 1$:     CALLS   #0, P.AAG						      ; 1250
	   50 	    04   AC	       64  C3 0050C 2$:     SUBL3   BUFFERS, BUFFER, R0					      ; 1252
	   52 	         50 00000200   8F  C7 00511 	    DIVL3   #512, R0, I						      ;
				       50  D4 00519 	    CLRL    J							      ; 1254
		         51 	  CC A440  9A 0051B 3$:     MOVZBL  POOL_BASE[J], R1					      ; 1255
		         53 	  D0 A440  9A 00520 	    MOVZBL  POOL_SIZE[J], R3					      ;
		         51 	       53  C0 00525 	    ADDL2   R3, R1						      ;
		         51 	       52  D1 00528 	    CMPL    I, R1						      ;
				       07  19 0052B 	    BLSS    4$							      ;
	   EA 	         50 	       02  F3 0052D 	    AOBLEQ  #2, J, 3$						      ; 1254
		         50 	       01  CE 00531 	    MNEGL   #1, POOL						      ; 1253
				  F8 B442  D4 00534 4$:     CLRL    @BUFFER_UCB[I]					      ; 1259
	   00 	    FC   B4	       52  E5 00538 	    BBCC    I, @BUFFER_DIRTY, 5$				      ; 1260
				  EC B442  7F 0053D 5$:     PUSHAQ  @BUFFER_LRU[I]					      ; 1262
		         51 	       9E  0F 00541 	    REMQUE  @(SP)+, LRU_ENTRY					      ;
				  D4 A440  7F 00544 	    PUSHAQ  POOL_LRU[POOL]					      ; 1263
		         9E 	       61  0E 00548 	    INSQUE  (LRU_ENTRY), @(SP)+					      ;
					   04 0054B 	    RET     							      ; 1205

; Routine Size:  96 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 11
;
;	1266	GLOBAL ROUTINE WRITE_HEADER : NOVALUE  =
;	1267	
;	1268	!++
;	1269	!
;	1270	! FUNCTIONAL DESCRIPTION:
;	1271	!
;	1272	!	This routine writes out the currently resident file header.
;	1273	!
;	1274	! CALLING SEQUENCE:
;	1275	!	WRITE_HEADER ()
;	1276	!
;	1277	! INPUT PARAMETERS:
;	1278	!	NONE
;	1279	!
;	1280	! IMPLICIT INPUTS:
;	1281	!	FILE_HEADER: address of current file header
;	1282	!
;	1283	! OUTPUT PARAMETERS:
;	1284	!	NONE
;	1285	!
;	1286	! IMPLICIT OUTPUTS:
;	1287	!	IO_STATUS: status of I/O transfer
;	1288	!
;	1289	! ROUTINE VALUE:
;	1290	!	NONE
;	1291	!
;	1292	! SIDE EFFECTS:
;	1293	!	checksum checked, header written
;	1294	!
;	1295	!--
;	1296	
;	1297	BEGIN
;	1298	
;	1299	EXTERNAL
;	1300		FILE_HEADER	: REF BBLOCK;	! address of last file header read
;	1301	
;	1302	EXTERNAL ROUTINE
;	1303		CHECKSUM;			! compute file header checksum
;	1304	
;	1305	
;	1306	! The checksum of the header should be good, since all routines that modify
;	1307	! the header bless it with a new checksum when they are finished. Check the
;	1308	! checksum and write the header.
;	1309	!
;	1310	
;	1311	IF NOT CHECKSUM (.FILE_HEADER)
;	1312	THEN BUG_CHECK (WRTINVHDR, FATAL, 'ACP attempted to write an invalid file header');
;	1313	
;	1314	WRITE_BLOCK (.FILE_HEADER);
;	1315	
;	1316	END;					! end of routine WRITE_HEADER



							    .PSECT  $LOCKEDC2$,NOWRT,2

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 11-1
;

				  FEFF  0000  00030 P.AAH:  .WORD   0, -257						      ;
					0000* 00034 	    .WORD   <BUG$_WRTINVHDR!4>					      ;
					      00036	    .BLKB   2

							    .EXTRN  FILE_HEADER, CHECKSUM, BUG$_WRTINVHDR

							    .PSECT  $CODE$,NOWRT,2

					 0000 0054C 	    .ENTRY  WRITE_HEADER, Save nothing				      ; 1266
				0000G  CF  DD 0054E 	    PUSHL   FILE_HEADER						      ; 1311
		  0000G  CF	       01  FB 00552 	    CALLS   #1, CHECKSUM					      ;
		         05 	       50  E8 00557 	    BLBS    R0, 1$						      ;
		  0000'  CF	       00  FB 0055A 	    CALLS   #0, P.AAH						      ; 1312
				0000G  CF  DD 0055F 1$:     PUSHL   FILE_HEADER						      ; 1314
		  FE27   CF	       01  FB 00563 	    CALLS   #1, WRITE_BLOCK					      ;
					   04 00568 	    RET     							      ; 1266

; Routine Size:  29 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 12
;
;	1317	GLOBAL ROUTINE FLUSH_BUFFERS : NOVALUE =
;	1318	
;	1319	!++
;	1320	!
;	1321	! FUNCTIONAL DESCRIPTION:
;	1322	!
;	1323	!	This routine writes all buffers which were modified back to the
;	1324	!	disk from whence they came.
;	1325	!
;	1326	! CALLING SEQUENCE:
;	1327	!	FLUSH_BUFFERS[0] ()
;	1328	!
;	1329	! INPUT PARAMETERS:
;	1330	!	NONE
;	1331	!
;	1332	! IMPLICIT INPUTS:
;	1333	!	all own storage of this module
;	1334	!
;	1335	! OUTPUT PARAMETERS:
;	1336	!	NONE
;	1337	!
;	1338	! IMPLICIT OUTPUTS:
;	1339	!	NONE
;	1340	!
;	1341	! ROUTINE VALUE:
;	1342	!	NONE
;	1343	!
;	1344	! SIDE EFFECTS:
;	1345	!	dirty buffers written.
;	1346	!
;	1347	!--
;	1348	
;	1349	BEGIN
;	1350	
;	1351	
;	1352	! We simply scan the dirty bit vector and write all buffers marked dirty.
;	1353	!
;	1354	
;	1355	INCR I FROM 0 TO .BUFFER_COUNT-1 DO
;	1356	    IF .BUFFER_DIRTY[.I]
;	1357	    THEN WRITE_BLOCK (BUFFERS[.I]);
;	1358	
;	1359	END;					! end of routine FLUSH_BUFFERS[0]





					 000C 00569 	    .ENTRY  FLUSH_BUFFERS, Save R2,R3				      ; 1317
		         53 	0000'  CF  D0 0056B 	    MOVL    BUFFER_COUNT, R3					      ; 1355
		         52 	       01  CE 00570 	    MNEGL   #1, I						      ;
				       14  11 00573 	    BRB     2$							      ;
	   0E 	  0000'  DF	       52  E1 00575 1$:     BBC     I, @BUFFER_DIRTY, 2$				      ; 1356
	   50 	         52 	       09  78 0057B 	    ASHL    #9, I, R0						      ; 1357
				0000'DF40  9F 0057F 	    PUSHAB  @BUFFERS[R0]					      ;

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 12-1
;
		  FE06   CF	       01  FB 00584 	    CALLS   #1, WRITE_BLOCK					      ;
	   E8 	         52 	       53  F2 00589 2$:     AOBLSS  R3, I, 1$						      ; 1355
					   04 0058D 	    RET     							      ; 1317

; Routine Size:  37 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 13
;
;	1360	GLOBAL ROUTINE FLUSH_FID (FID) : NOVALUE =
;	1361	
;	1362	!++
;	1363	!
;	1364	! FUNCTIONAL DESCRIPTION:
;	1365	!
;	1366	!	This routine removes from the buffer cache all blocks contained
;	1367	!	within the specified file. Dirty buffers are written.
;	1368	!
;	1369	! CALLING SEQUENCE:
;	1370	!	FLUSH_FID (ARG1)
;	1371	!
;	1372	! INPUT PARAMETERS:
;	1373	!	ARG1: file ID of file to flush
;	1374	!	      0 to match all
;	1375	!
;	1376	! IMPLICIT INPUTS:
;	1377	!	all own storage of this module
;	1378	!	CURRENT_UCB: UCB of current device
;	1379	!
;	1380	! OUTPUT PARAMETERS:
;	1381	!	NONE
;	1382	!
;	1383	! IMPLICIT OUTPUTS:
;	1384	!	NONE
;	1385	!
;	1386	! ROUTINE VALUE:
;	1387	!	NONE
;	1388	!
;	1389	! SIDE EFFECTS:
;	1390	!	dirty buffers written, appropriate buffers invalidated
;	1391	!
;	1392	!--
;	1393	
;	1394	BEGIN
;	1395	
;	1396	MAP
;	1397		FID		: REF BBLOCK;	! file ID arg
;	1398	LOCAL
;	1399		I;				! index to buffers
;	1400	
;	1401	EXTERNAL
;	1402		CURRENT_UCB	: REF BBLOCK,	! address of device UCB
;	1403		CURRENT_VCB	: REF BBLOCK;	! address of current VCB
;	1404	
;	1405	
;	1406	! We scan the UCB and FID vectors looking for matches. Buffers that match
;	1407	! are written if dirty and then invalidated.
;	1408	!
;	1409	
;	1410	INCR I FROM 0 TO .BUFFER_COUNT-1 DO
;	1411	    BEGIN
;	1412	    IF .BUFFER_UCB[.I] EQL .CURRENT_UCB
;	1413	    AND (.FID EQL 0
;	1414		OR  (.(BUFFER_FID[.I])<0,16> EQL .FID[FID$W_NUM]

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 13-1
;
;	1415		    AND (IF .CURRENT_VCB[VCB$V_EXTFID]
;	1416			THEN .(BUFFER_FID[.I])<16,8> EQL .FID[FID$B_NMX]
;	1417			ELSE 1
;	1418			)
;	1419		    )
;	1420		)
;	1421	    THEN
;	1422		BEGIN
;	1423		IF .BUFFER_DIRTY[.I]
;	1424		THEN WRITE_BLOCK (BUFFERS[.I]);
;	1425		INVALIDATE (BUFFERS[.I]);
;	1426		END;
;	1427	    END;
;	1428	
;	1429	END;					! end of routine FLUSH_FID





					 001C 0058E 	    .ENTRY  FLUSH_FID, Save R2,R3,R4				      ; 1360
		         54 	0000'  CF  9E 00590 	    MOVAB   BUFFER_FID, R4					      ;
		         53 	  14   A4  D0 00595 	    MOVL    BUFFER_COUNT, R3					      ; 1410
		         52 	       01  CE 00599 	    MNEGL   #1, I						      ;
				       50  11 0059C 	    BRB     4$							      ;
		  0000G  CF	  08 B442  D1 0059E 1$:     CMPL    @BUFFER_UCB[I], CURRENT_UCB				      ; 1412
				       47  12 005A5 	    BNEQ    4$							      ;
		         51 	  04   AC  D0 005A7 	    MOVL    FID, R1						      ; 1413
				       22  13 005AB 	    BEQL    2$							      ;
				  00 B442  DF 005AD 	    PUSHAL  @BUFFER_FID[I]					      ; 1414
		         61 	       9E  B1 005B1 	    CMPW    @(SP)+, (R1)					      ;
				       38  12 005B4 	    BNEQ    4$							      ;
		         50 	0000G  CF  D0 005B6 	    MOVL    CURRENT_VCB, R0					      ; 1415
	   0F 	    0B   A0	       05  E1 005BB 	    BBC     #5, 11(R0), 2$					      ;
		         50 	  05   A1  9A 005C0 	    MOVZBL  5(R1), R0						      ; 1416
				  00 B442  DF 005C4 	    PUSHAL  @BUFFER_FID[I]					      ;
	   9E 	         08 	       10  ED 005C8 	    CMPZV   #16, #8, @(SP)+, R0					      ;
				       50     005CC									      ;
				       1F  12 005CD 	    BNEQ    4$							      ;
	   0D 	    0C   B4	       52  E1 005CF 2$:     BBC     I, @BUFFER_DIRTY, 3$				      ; 1423
	   50 	         52 	       09  78 005D4 	    ASHL    #9, I, R0						      ; 1424
				  10 B440  9F 005D8 	    PUSHAB  @BUFFERS[R0]					      ;
		  FDAE   CF	       01  FB 005DC 	    CALLS   #1, WRITE_BLOCK					      ;
	   50 	         52 	       09  78 005E1 3$:     ASHL    #9, I, R0						      ; 1425
				  10 B440  9F 005E5 	    PUSHAB  @BUFFERS[R0]					      ;
		  FEFE   CF	       01  FB 005E9 	    CALLS   #1, INVALIDATE					      ;
	   AC 	         52 	       53  F2 005EE 4$:     AOBLSS  R3, I, 1$						      ; 1410
					   04 005F2 	    RET     							      ; 1360

; Routine Size:  101 bytes


;	1430	
;	1431	END
;	1432	ELUDOM

; Bliss-32 10.1-416	Monday 21-AUG-1978 23:02:06	DBB3:[F11A.SRC]RDBLOK.B32;34					Page 13-2
;






;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  $CODE$         	  1523  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $LOCKEDD1$     	    60    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $LOCKEDC2$     	    56  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        17         0       237





; Size:		1515 code + 124 data bytes
; Run Time:	00:27.5
; Elapsed Time:	00:56.0
; Memory Used:	340 pages
; Compilation Complete
