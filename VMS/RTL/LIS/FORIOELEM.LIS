FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   0
TABLE OF CONTENTS   

   (2)     100  DECLARATIONS
   (3)     100  CALL-BY-VALUE ENTRY POINT DESCRIPTIONS
   (4)     100  CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS
   (7)     100  FOR$IO_T_DS	- Transmit string element by descri
   (9)     100  FOR$IO_T_V_DS - Transmit string element then po
   (11)    100  FOR$IO_X_DA	- Transmit entire array by descript
   (13)    100  ERR_HANDLER	- Exception handler for errors
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   1
2-27                                                                                                                             (1)

                                     0000   100 	.TITLE	FOR$IO_ELEM	; FORTRAN I/O element transmission
                                     0000   200 	.IDENT	/2-27/		; File: FORIOELEM.MAR
                                     0000   300 
                                     0000   400 ;
                                     0000   500 ; Copyright (C) 1977
                                     0000   600 ; Digital Equipment Corporation, Maynard, Massachusetts 01754
                                     0000   700 ;
                                     0000   800 ; This software is furnished under a license for use only on a single
                                     0000   900 ; computer  system  and  may be copied only with the inclusion of the
                                     0000  1000 ; above copyright notice. This software, or any other copies thereof,
                                     0000  1100 ; may not be provided or otherwise made available to any other person
                                     0000  1200 ; except for use on such system and to one who agree to these license 
                                     0000  1300 ; terms.  Title to  and  ownership of the software shall at all times 
                                     0000  1400 ; remain in DEC.
                                     0000  1500 ;
                                     0000  1600 ; The information in the software is subject to change without notice
                                     0000  1700 ; and should  not  be construed  as a commitment by Digital Equipment 
                                     0000  1800 ; Corporation.
                                     0000  1900 ;
                                     0000  2000 ; DEC assumes  no  responsibility  for the use or  reliability of its
                                     0000  2100 ; software on equipment which is not supplied by DEC.
                                     0000  2200 ;
                                     0000  2300 ;
                                     0000  2400 ;++
                                     0000  2500 ; FACILITY: FORTRAN Support Library - user callable
                                     0000  2600 ;
                                     0000  2700 ; ABSTRACT:
                                     0000  2800 ;
                                     0000  2900 ;	This module implements all of the FORTRAN I/O list element
                                     0000  3000 ;	transmits calls made for each of the elements in a
                                     0000  3100 ;	READ/WRITE/DECODE/ENCODE  (TYPE, ACCEPT, and PRINT)
                                     0000  3200 ;	statements at the user program interface level of
                                     0000  3300 ;	abstraction (UPI = 1st level). See FOR$IO_BEG
                                     0000  3400 ;	and FOR$IO_END modules for I/O statement initialization
                                     0000  3500 ;	and termination, respectively.
                                     0000  3600 ;
                                     0000  3700 ; ENVIRONMENT: User access mode; mixture of AST level or not
                                     0000  3800 ;
                                     0000  3900 ; AUTHOR:	Thomas N. Hastings, CREATION DATE: 02-Mar-77
                                     0000  4000 ;
                                     0000  4100 ; MODIFIED BY:
                                     0000  4200 ;
                                     0000  4300 ; 	Thomas N. Hastings, 02-Mar-77  : VERSION 01
                                     0000  4400 ; 01	-  original
                                     0000  4500 ; 11	- change to use SRM data type symbols for data types
                                     0000  4600 ; 15	- pass enable args as an array (access violation)
                                     0000  4700 ;
                                     0000  4800 ;	VERSION 02
                                     0000  4900 ; 01	- Convert to using MARS.	R. Schaefer	18-Aug-77
                                     0000  5000 ; 2-10	- Add unformatted array at  one time TNH
                                     0000  5100 ; 2-12	- UNWIND action is to pop current LUB/ISB/RAB 9-SEP-77 TNH
                                     0000  5200 ; 2-14	- fix bug in array as a whole TNH 15-SEP-77
                                     0000  5300 ; 2-15	- same TNH 16-sep-77
                                     0000  5400 ; 2-16	- make END= work.  Push UNWIND action by ref.  TNH 4-Oct-77
                                     0000  5500 ; 2-17	- have complex transmitters flag real vs. imag part for
                                     0000  5600 ;	  list-directed I/O UDFs.
                                     0000  5700 ; 2-18	- change flags for 17 to 0 and 1 instead of 1 and 2.  JMT 16-Nov-77
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   2
2-27                                                                                                                             (1)

                                     0000  5800 ; 2-20	- New code to do unformatted XMIT here instead of
                                     0000  5900 ;	  UDF level.  JMT 4-Mar-78
                                     0000  6000 ; 2-21	- A small improvement suggested by Rich Grove.  JMT 7-Mar-78
                                     0000  6100 ; 2-22	- UPI level routines now must save R11 and load it
                                     0000  6200 ;	  from OTS$$A_CUR_LUB!  Only one control block pointer now!
                                     0000  6300 ;	  JMT 8-Apr-78
                                     0000  6400 ; 2-23	- Remove FORDEF from the Macros.  DGP 5-May-78
                                     0000  6410 ; 2-24	- PIC dispatch tables.  TNH 7-June-78
                                     0000  6420 ; 2-26	- Use shorter reference to PIC tables.  TNH 13-June-78
                                     0000  6500 ;--
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   3
2-27            DECLARATIONS                                                                                                     (2)

                                     0000   100 	.SBTTL	DECLARATIONS
                                     0000   200 
                                     0000   300 ;
                                     0000   400 ; INCLUDE FILES:
                                     0000   500 ;
                                     0000   600 ;	FISB.MAR	- ISB offset definitions
                                     0000   700 ;	FLUB.MAR	- LUB offset definitions
                                     0000   800 
                                     0000   900 ;
                                     0000  1000 ; EXTERNAL SYMBOLS:
                                     0000  1100 ;
                                     0000  1150 	.DSABL	GBL			; Force declaration of all externals
                                     0000  1200 	.EXTRN	OTS$$A_CUR_LUB		; Currently active I/O unit
                                     0000  1300 	.EXTRN	FOR$$AA_UDF_PR1		; User data formatters
                                     0000  1310 					; Contain word PIC dispatch entries.
                                     0000  1400 	.EXTRN	FOR$$ERR_ENDHND		; Common I/OERR=/END= error handler
                                     0000  1500 ;
                                     0000  1600 ; MACROS:
                                     0000  1700 ;
                                     0000  1800 	$SFDEF				; Stack frame offsets defined
                                     0000  1900 	$DSCDEF				; Descriptor symbols
                                     0000  2000 	$LUBDEF				; LUB definitions
                                     0000  2100 	$ISBDEF				; ISB definitions
                                     0000  2200 	$FORPAR				; inter-module definitions
                                     0000  2300 ;
                                     0000  2400 ; PSECT DECLARATIONS:
                                     0000  2500 ;
                                 00000000  2600 	.PSECT	FOR$CODE PIC,SHR,LONG,EXE,NOWRT
                                     0000  2700 ;
                                     0000  2800 ; EQUATED SYMBOLS:
                                     0000  2900 ;
                                     0000  3000 
                           00000004  0000  3100 	elem_val = 4		; offset of item value
                           00000004  0000  3200 	elem_adr = 4		; offset of item address or descriptor address
                           00000004  0000  3300 	sig_args = 4		; offset of signal args for handler
                           0000000C  0000  3400 	item_addr = 12		; offset of address in UDF arg list
                           00000010  0000  3500 	cpx_flag = 16		; offset of COMPLEX flag in UDF arg list
                                     0000  3600 
                                     0000  3700 ;
                                     0000  3800 ; OWN STORAGE:
                                     0000  3900 ;
                                     0000  4000 
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   4
2-27            CALL-BY-VALUE ENTRY POINT DESCRIPTIONS                                                                           (3)

                                     0000   100 	.SBTTL	CALL-BY-VALUE ENTRY POINT DESCRIPTIONS
                                     0000   200 
                                     0000   300 ;+
                                     0000   400 ; The following routine header serves for all of the
                                     0000   500 ; call-by-value entry points.
                                     0000   600 ;-
                                     0000   700 
                                     0000   800 ;++
                                     0000   900 ; ABSTRACT:
                                     0000  1000 ;
                                     0000  1100 ;	Transmit (WRITE) a single data type element from
                                     0000  1200 ;	the user I/O list to the output buffer by
                                     0000  1300 ;	calling the appropriate user data formatter
                                     0000  1400 ;	(UDF) routine for the current I/O statement.
                                     0000  1500 ;
                                     0000  1600 ; FORMAL PARAMETERS:
                                     0000  1700 ;
                                     0000  1800 ;	ELEM_VAL.rx.v		element by-value
                                     0000  1900 ;
                                     0000  2000 ; IMPLICIT INPUTS:
                                     0000  2100 ;
                                     0000  2200 ;	OTS$$A_CUR_LUB		Adr. of current logical
                                     0000  2300 ;				unit block (LUB). Used to setup
                                     0000  2400 ;				ISB base to get current I/O
                                     0000  2500 ;				statement type code.
                                     0000  2600 ;	ISB$B_STTM_TYPE		I/O statement type code - index
                                     0000  2700 ;				to dispatch table entry.
                                     0000  2800 ;	FOR$$AA_UDF_PR1		Array of user data formatters (UDF
                                     0000  2900 ;				level of abstraction.)
                                     0000  3000 ;
                                     0000  3100 ; IMPLICIT OUTPUTS:
                                     0000  3200 ;
                                     0000  3300 ;	NONE
                                     0000  3400 ;
                                     0000  3500 ; SIDE EFFECTS:
                                     0000  3600 ;
                                     0000  3700 ;	If an error occurs, it is  SIGNALed unless an ERR=
                                     0000  3800 ;	transfer parameter was specified when the I/O statement
                                     0000  3900 ;	initialization call was made (see module FOR$IO_BEG,
                                     0000  4000 ;	entry points: FOR${READ,WRITE}_{SF,SO,SU,DF,DO,DU,SL} or
                                     0000  4100 ;	FOR${DECODE,ENCODE}_{MF,MO}), in which case control
                                     0000  4200 ;	is transferred to the specified address (after stack unwind.)
                                     0000  4300 ;--
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   5
2-27            CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS                                                                       (4)

                                     0000   100 	.SBTTL	CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS
                                     0000   200 
                                     0000   300 ;+
                                     0000   400 ; The following routine header serves for all of the
                                     0000   500 ; call-by-reference entry points.
                                     0000   600 ;-
                                     0000   700 
                                     0000   800 ;++
                                     0000   900 ; ABSTRACT:
                                     0000  1000 ;
                                     0000  1100 ;	Transmit (READ or WRITE) a single data type element from
                                     0000  1200 ;	the user I/O list to the output buffer by
                                     0000  1300 ;	calling the appropriate user data formatter
                                     0000  1400 ;	(UDF) routine for the current I/O statement.
                                     0000  1500 ;
                                     0000  1600 ; FORMAL PARAMETERS:
                                     0000  1700 ;
                                     0000  1800 ;	ELEM_ADR.xx.r		element by-reference
                                     0000  1900 ;
                                     0000  2000 ; IMPLICIT INPUTS:
                                     0000  2100 ;
                                     0000  2200 ;	OTS$$A_CUR_LUB		Adr. of current logical
                                     0000  2300 ;				unit block (LUB). Used to setup
                                     0000  2400 ;				ISB base to get current I/O
                                     0000  2500 ;				statement type code.
                                     0000  2600 ;	ISB$B_STTM_TYPE		I/O statement type code - index
                                     0000  2700 ;				to dispatch table entry.
                                     0000  2800 ;	FOR$$AA_UDF_PR1		Array of user data formatters (UDF
                                     0000  2900 ;				level of abstraction.)
                                     0000  3000 ;
                                     0000  3100 ; IMPLICIT OUTPUTS:
                                     0000  3200 ;
                                     0000  3300 ;	NONE
                                     0000  3400 ;
                                     0000  3500 ; SIDE EFFECTS:
                                     0000  3600 ;
                                     0000  3700 ;	If an error occurs, it is  SIGNALed unless an ERR=
                                     0000  3800 ;	transfer parameter was specified when the I/O statement
                                     0000  3900 ;	initialization call was made (see module FOR$IO_BEG,
                                     0000  4000 ;	entry points: FOR${READ,WRITE}_{SF,SO,SU,DF,DO,DU,SL} or
                                     0000  4100 ;	FOR${DECODE,ENCODE}_{MF,MO}), in which case control
                                     0000  4200 ;	is transferred to the specified address (after stack ???.)
                                     0000  4300 ;--
                                     0000  4400 
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   6
2-27            CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS                                                                       (5)

                               0800' 0000   100 	.ENTRY	FOR$IO_B_V, ^M<R11>	; BYTE/LOGICAL*1 by-value
                       04 AC     DF  0002   200 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  0005   300 	BRB	IO_B_COM		; common code for BYTE
                                     0007   400 
                               0800' 0007   500 	.ENTRY	FOR$IO_B_R, ^M<R11>	; BYTE/LOGICAL*1 by-reference
                       04 AC     DD  0009   600 	PUSHL	elem_adr(AP)		; push address of value
                                     000C   700 
                                     000C   800 IO_B_COM:
                          01     DD  000C   900 	PUSHL	#1			; size for BYTE data type
                          06     DD  000E  1000 	PUSHL	#DSC$K_DTYPE_B		; data-type code for BYTE
                          22     11  0010  1100 	BRB	COM_IO_ELEM		; common code for all data-types
                                     0012  1200 
                                     0012  1300 
                                     0012  1400 
                               0800' 0012  1500 	.ENTRY	FOR$IO_W_V, ^M<R11>	; INTEGER*2 by-value
                       04 AC     DF  0014  1600 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  0017  1700 	BRB	IO_W_COM		; common code for INTEGER*2
                                     0019  1800 
                               0800' 0019  1900 	.ENTRY	FOR$IO_W_R, ^M<R11>	; INTEGER*2 by-reference
                       04 AC     DD  001B  2000 	PUSHL	elem_adr(AP)		; push address of value
                                     001E  2100 
                                     001E  2200 IO_W_COM:
                          02     DD  001E  2300 	PUSHL	#2			; size for INTEGER*2 data type
                          07     DD  0020  2400 	PUSHL	#DSC$K_DTYPE_W		; data-type code for INTEGER*2
                          10     11  0022  2500 	BRB	COM_IO_ELEM		; common code for all data-types
                                     0024  2600 
                                     0024  2700 
                                     0024  2800 
                               0800' 0024  2900 	.ENTRY	FOR$IO_L_V, ^M<R11>	; INTEGER*4 by-value
                       04 AC     DF  0026  3000 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  0029  3100 	BRB	IO_L_COM		; common code for INTEGER*4
                                     002B  3200 
                               0800' 002B  3300 	.ENTRY	FOR$IO_L_R, ^M<R11>	; INTEGER*4 by-reference
                       04 AC     DD  002D  3400 	PUSHL	elem_adr(AP)		; push address of value
                                     0030  3500 
                                     0030  3600 IO_L_COM:
                          04     DD  0030  3700 	PUSHL	#4			; size for INTEGER*4 data type
                          08     DD  0032  3800 	PUSHL	#DSC$K_DTYPE_L		; data-type code for INTEGER*4
                                     0034  3900 
                                     0034  4000 COM_IO_ELEM:
            5B   00000000'EF     D0  0034  4100 	MOVL	L^OTS$$A_CUR_LUB, R11	; R11 -> Current Control Block
         FC AB            09     E1  003B  4200 	BBC	#LUB$V_UNFORMAT, LUB$L_UNIT_STAT(R11), CALL1
                          77         003F       
                                     0040  4300 					; can't optimize if formatted
            50         B8 AB     D0  0040  4400 	MOVL	ISB$A_BUF_PTR(R11), R0	; R0 -> record buffer
         04 AE            50     C1  0044  4500 	ADDL3	R0, 4(SP), R1		; R1 = prototype record buffer pointer
                          51         0048       
         BC AB            51     D1  0049  4600 	CMPL	R1, ISB$A_BUF_END(R11)	; overflows buffer?
                          68     1A  004D  4700 	BGTRU	CALL1			; branch if yes
            2D         A5 AB     E9  004F  4800 	BLBC	ISB$B_STTM_TYPE(R11), RU
                                     0053  4900 					; dispatch to read/write code
                                     0053  5000 
                                     0053  5100 ; write unformatted.  Move users data into the record buffer
                                     0053  5200 ;
            01         04 AE     CF  0053  5300 	CASEL	4(SP), #1, #8		; dispatch on element size
                          08         0057       
                               0010' 0058  5400 10$:	.WORD	WBYTE - 10$
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   7
2-27            CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS                                                                       (5)

                               0016' 005A  5500 	.WORD	WWORD - 10$
                               0000  005C  5600 	.WORD
                               001C' 005E  5700 	.WORD	WLONG - 10$
                               0000  0060  5800 	.WORD
                               0000  0062  5900 	.WORD
                               0000  0064  6000 	.WORD
                               0022' 0066  6100 	.WORD	WQUAD - 10$
                                     0068  6200 
            80         08 BE     90  0068  6300 WBYTE:	MOVB	@8(SP), (R0)+
                          3D     11  006C  6400 	BRB	COM
            80         08 BE     B0  006E  6500 WWORD:	MOVW	@8(SP), (R0)+
                          37     11  0072  6600 	BRB	COM
            80         08 BE     D0  0074  6700 WLONG:	MOVL	@8(SP), (R0)+
                          31     11  0078  6800 	BRB	COM
            80         08 BE     7D  007A  6900 WQUAD:	MOVQ	@8(SP), (R0)+
                          2B     11  007E  7000 	BRB	COM
                                     0080  7100 
                                     0080  7200 ; read unformatted. Move data from record buffer to users element
                                     0080  7300 ;
            01         04 AE     CF  0080  7400 RU:	CASEL	4(SP), #1, #8		; dispatch on element size
                          08         0084       
                               0010' 0085  7500 10$:	.WORD	RBYTE - 10$
                               0016' 0087  7600 	.WORD	RWORD - 10$
                               0000  0089  7700 	.WORD
                               001C' 008B  7800 	.WORD	RLONG - 10$
                               0000  008D  7900 	.WORD
                               0000  008F  8000 	.WORD
                               0000  0091  8100 	.WORD
                               0022' 0093  8200 	.WORD	RQUAD - 10$
                                     0095  8300 
         08 BE            80     90  0095  8400 RBYTE:	MOVB	(R0)+, @8(SP)
                          10     11  0099  8500 	BRB	COM
         08 BE            80     B0  009B  8600 RWORD:	MOVW	(R0)+, @8(SP)
                          0A     11  009F  8700 	BRB	COM
         08 BE            80     D0  00A1  8800 RLONG:	MOVL	(R0)+, @8(SP)
                          04     11  00A5  8900 	BRB	COM
         08 BE            80     7D  00A7  9000 RQUAD:	MOVQ	(R0)+, @8(SP)
                                     00AB  9100 COM:
         B8 AB            50     D0  00AB  9200 	MOVL	R0, ISB$A_BUF_PTR(R11)	; store the updated pointer
                                 04  00AF  9300 	RET
                                     00B0  9400 
                                     00B0  9500 ; come here if checks for the optimization indicate the UDF must be called.
                                     00B0  9600 ;
            5B   00000000'EF     D0  00B0  9700 CALLUDF:MOVL	L^OTS$$A_CUR_LUB, R11	; R11 = Current Control Block pointer
            50         A5 AB     9A  00B7  9800 CALL1:	MOVZBL	ISB$B_STTM_TYPE(R11), R0
                                     00BB  9900 					; R0 = I/O statement type
            50       0000'CF40   32  00BB 10000 	CVTWL	W^FOR$$AA_UDF_PR1[R0], R0
                                     00C1 10010 					; R0 = signed offset relative to beginning
                                     00C1 10020 					; of FOR$$AA_UDF_PR1.
            6D       0239'CF     DE  00C1 10100 	MOVAL	W^ERR_HANDLER, (FP)	; set up handler
       0000'CF40          03     FB  00C6 10200 	CALLS	#3, W^FOR$$AA_UDF_PR1[R0]	; call the UDF level routine.
                                 04  00CC 10300 	RET				;  and return to the user
                                     00CD 10400 
                                     00CD 10500 
                               0800' 00CD 10600 	.ENTRY	FOR$IO_WU_V, ^M<R11>	; LOGICAL*2 by-value
                       04 AC     DF  00CF 10700 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  00D2 10800 	BRB	IO_WU_COM		; common code for LOGICAL*2
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   8
2-27            CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS                                                                       (5)

                                     00D4 10900 
                               0800' 00D4 11000 	.ENTRY	FOR$IO_WU_R, ^M<R11>	; LOGICAL*2 by-reference
                       04 AC     DD  00D6 11100 	PUSHL	elem_adr(AP)		; push address of value
                                     00D9 11200 
                                     00D9 11300 IO_WU_COM:
                          02     DD  00D9 11400 	PUSHL	#2			; size for LOGICAL*2 data type
                          03     DD  00DB 11500 	PUSHL	#DSC$K_DTYPE_WU		; data-type code for LOGICAL*2
                          FF54   31  00DD 11600 	BRW	COM_IO_ELEM		; common code for all data-types
                                     00E0 11700 
                                     00E0 11800 
                                     00E0 11900 
                               0800' 00E0 12000 	.ENTRY	FOR$IO_LU_V, ^M<R11>	; LOGICAL*4 by-value
                       04 AC     DF  00E2 12100 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  00E5 12200 	BRB	IO_LU_COM		; common code for LOGICAL*4
                                     00E7 12300 
                               0800' 00E7 12400 	.ENTRY	FOR$IO_LU_R, ^M<R11>	; LOGICAL*4 by-reference
                       04 AC     DD  00E9 12500 	PUSHL	elem_adr(AP)		; push address of value
                                     00EC 12600 
                                     00EC 12700 IO_LU_COM:
                          04     DD  00EC 12800 	PUSHL	#4			; size for LOGICAL*4 data type
                          04     DD  00EE 12900 	PUSHL	#DSC$K_DTYPE_LU		; data-type code for LOGICAL*4
                          FF41   31  00F0 13000 	BRW	COM_IO_ELEM		; common code for all data-types
                                     00F3 13100 
                                     00F3 13200 
                                     00F3 13300 
                               0800' 00F3 13400 	.ENTRY	FOR$IO_F_V, ^M<R11>	; REAL*4 by-value
                       04 AC     DF  00F5 13500 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  00F8 13600 	BRB	IO_F_COM		; common code for REAL*4
                                     00FA 13700 
                               0800' 00FA 13800 	.ENTRY	FOR$IO_F_R, ^M<R11>	; REAL*4 by-reference
                       04 AC     DD  00FC 13900 	PUSHL	elem_adr(AP)		; push address of value
                                     00FF 14000 
                                     00FF 14100 IO_F_COM:
                          04     DD  00FF 14200 	PUSHL	#4			; size for REAL*4 data type
                          0A     DD  0101 14300 	PUSHL	#DSC$K_DTYPE_F		; data-type code for REAL*4
                          FF2E   31  0103 14400 	BRW	COM_IO_ELEM		; common code for all data-types
                                     0106 14500 
                                     0106 14600 
                                     0106 14700 
                               0800' 0106 14800 	.ENTRY	FOR$IO_D_V, ^M<R11>	; REAL*8 by-value
                       04 AC     DF  0108 14900 	PUSHAL	elem_val(AP)		; push address of value
                          05     11  010B 15000 	BRB	IO_D_COM		; common code for REAL*8
                                     010D 15100 
                               0800' 010D 15200 	.ENTRY	FOR$IO_D_R, ^M<R11>	; REAL*8 by-reference
                       04 AC     DD  010F 15300 	PUSHL	elem_adr(AP)		; push address of value
                                     0112 15400 
                                     0112 15500 IO_D_COM:
                          08     DD  0112 15600 	PUSHL	#8			; size for REAL*8 data type
                          0B     DD  0114 15700 	PUSHL	#DSC$K_DTYPE_D		; data-type code for REAL*8
                          FF1B   31  0116 15800 	BRW	COM_IO_ELEM		; common code for all data-types
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page   9
2-27            CALL-BY-REFERENCE ENTRY POINT DESCRIPTIONS                                                                       (6)

                               0804' 0119   100 	.ENTRY	FOR$IO_FC_V, ^M<R2,R11>
            5C         04 AC     DE  011B   200 	MOVAL	elem_val(AP), AP	; get address of value
                          06     11  011F   300 	BRB	IO_FC_COM
                                     0121   400 
                               0804' 0121   500 	.ENTRY	FOR$IO_FC_R, ^M<R2,R11>
            5C         04 AC     D0  0123   600 	MOVL	elem_adr(AP), AP	; get address of value
                                     0127   700 
                                     0127   800 IO_FC_COM:
            6D       0239'CF     DE  0127   900 	MOVAL	W^ERR_HANDLER, (FP)	; setup END=/ERR= handlre
            5B   00000000'EF     D0  012C  1000 	MOVL	L^OTS$$A_CUR_LUB, R11	; R11 -> Current Control Block
            50         A5 AB     9A  0133  1100 	MOVZBL	ISB$B_STTM_TYPE(R11),R0	; get statement type for dispatch
            52       0000'CF40   32  0137  1200 	CVTWL	W^FOR$$AA_UDF_PR1[R0], R2	; R2 = word displacement to UDF routine
                          00     DD  013D  1300 	PUSHL	#0			; flag real part of value
                          5C     DD  013F  1400 	PUSHL	AP			; push address of real part
                          04     DD  0141  1500 	PUSHL	#4			; push size
                          0A     DD  0143  1600 	PUSHL	#DSC$K_DTYPE_F		; push type code of floating
                          04     DD  0145  1700 	PUSHL	#4			; four args to UDF
       0000'CF42          6E     FA  0147  1800 	CALLG	(SP), W^FOR$$AA_UDF_PR1[R2]	; process real part
                                     014D  1900 
                       10 AE     D6  014D  2000 	INCL	cpx_flag(SP)		; flag imaginary part
         0C AE         04 AC     DE  0150  2100 	MOVAL	4(AP), item_addr(SP)	; address of imaginary part
       0000'CF42          6E     FA  0155  2200 	CALLG	(SP), W^FOR$$AA_UDF_PR1[R2]
                                 04  015B  2300 	RET
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  10
2-27            FOR$IO_T_DS - Transmit string element by descri                                                                  (7)

                                     015C   100 	.SBTTL	FOR$IO_T_DS	- Transmit string element by descriptor
                                     015C   200 
                                     015C   300 ;++
                                     015C   400 ; ABSTRACT:
                                     015C   500 ;
                                     015C   600 ;	Transmit (READ or WRITE) a single character string from
                                     015C   700 ;	the user I/O list to the output buffer or from
                                     015C   800 ;	the input buffer to the user I/O list by
                                     015C   900 ;	calling the appropriate user data formatter
                                     015C  1000 ;	(UDF) routine for the current I/O statement.
                                     015C  1100 ;
                                     015C  1200 ; FORMAL PARAMETERS:
                                     015C  1300 ;
                                     015C  1400 ;	ELEM_ADR.xt.ds		element by-descriptor (static)
                                     015C  1500 ;
                                     015C  1600 ; IMPLICIT INPUTS:
                                     015C  1700 ;
                                     015C  1800 ;	OTS$$A_CUR_LUB		Adr. of current logical
                                     015C  1900 ;				unit block (LUB). Used to setup
                                     015C  2000 ;				ISB base to get current I/O
                                     015C  2100 ;				statement type code.
                                     015C  2200 ;	ISB$B_STTM_TYPE		I/O statement type code - index
                                     015C  2300 ;				to dispatch table entry.
                                     015C  2400 ;	FOR$$A_UDF_PR1		Array of user data formatters (UDF
                                     015C  2500 ;				level of abstraction.)
                                     015C  2600 ;
                                     015C  2700 ; IMPLICIT OUTPUTS:
                                     015C  2800 ;
                                     015C  2900 ;	NONE
                                     015C  3000 ;
                                     015C  3100 ; SIDE EFFECTS:
                                     015C  3200 ;
                                     015C  3300 ;	If an error occurs, it is  SIGNALed unless an ERR=
                                     015C  3400 ;	transfer parameter was specified when the I/O statement
                                     015C  3500 ;	initialization call was made (see module FOR$IO_BEG,
                                     015C  3600 ;	entry points: FOR${READ,WRITE}_{SF,SO,SU,DF,DO,DU,SL} or
                                     015C  3700 ;	FOR${DECODE,ENCODE}_{MF,MO}), in which case control
                                     015C  3800 ;	is transferred to the specified address (after stack unwound.)
                                     015C  3900 
                                     015C  4000 
                                     015C  4100 
                                     015C  4200 
                               0800' 015C  4300 	.ENTRY	FOR$IO_T_DS, ^M<R11>
            50         04 BC     7D  015E  4400 	MOVQ	@elem_adr(AP), R0	; get descriptor into R0'R1
                          51     DD  0162  4500 	PUSHL	R1			; push address
            7E            50     3C  0164  4600 	MOVZWL	R0, -(SP)		; push length
                          0E     DD  0167  4700 	PUSHL	#DSC$K_DTYPE_T		; push string data-type
                          FF44   31  0169  4800 	BRW	CALLUDF			; call the UDF
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  11
2-27            FOR$IO_T_V_DS - Transmit string element then po                                                                  (9)

                                     016C   100 	.SBTTL	FOR$IO_T_V_DS - Transmit string element then pop off stack  
                                     016C   200 
                                     016C   300 ;++
                                     016C   400 ; FUNCTIONAL DESCRIPTION:
                                     016C   500 ;
                                     016C   600 ;	Transmit (READ or WRITE) s single character string from
                                     016C   700 ;	the user I/O list to the output buffer or from 
                                     016C   800 ;	the inpout buffer to the user I/O list by
                                     016C   900 ;	calling the appropriate user data formatter (UDF)
                                     016C  1000 ;	routine for the current I/O statement.
                                     016C  1100 ;	This routine is identical to FOR$IO_T_DS except that
                                     016C  1200 ;	the string passed is popped off the stack as part of the
                                     016C  1300 ;	return to the user program.  As such it is a non-standard
                                     016C  1400 ;	procedure.  It is really passing the string by value
                                     016C  1500 ;	and is used by the comiler to pass the result of a temporary
                                     016C  1600 ;	string expression computed on the stack.
                                     016C  1700 ;
                                     016C  1800 ; CALLING SEQUENCE:
                                     016C  1900 ;
                                     016C  2000 ;	CALL FOR$IO_T_V_DS (elem_adr.xt.ds)
                                     016C  2100 ;
                                     016C  2200 ; INPUT PARAMETERS:
                                     016C  2300 ;	NONE
                                     016C  2400 ;
                                     016C  2500 ; IMPLICIT INPUTS:
                                     016C  2600 ;	NONE
                                     016C  2700 ;
                                     016C  2800 ; OUTPUT PARAMETERS:
                                     016C  2900 ;	NONE
                                     016C  3000 ;
                                     016C  3100 ; IMPLICIT OUTPUTS:
                                     016C  3200 ;	NONE
                                     016C  3300 ;
                                     016C  3400 ; COMPLETION CODES:
                                     016C  3500 ;	NONE
                                     016C  3600 ;
                                     016C  3700 ; SIDE EFFECTS:
                                     016C  3800 ;
                                     016C  3900 ;	If an error occurs, it is SIGNALed unless an ERR=
                                     016C  4000 ;	transfer parameter was specified when the I/O statement
                                     016C  4100 ;	initialization call was made (see module FOR$IO_BEG,
                                     016C  4200 ;	entry points: FOR${DECODE,ENCODE}_MF,MO}), in which case control
                                     016C  4300 ;	is transferred to the specified address (after stack unwound).
                                     016C  4400 ;--
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  12
2-27            FOR$IO_T_V_DS - Transmit string element then po                                                                 (10)

                               4800' 016C   100 	.ENTRY	FOR$IO_T_V_DS, ^M<IV, R11>
                                     016E   200 					; enable integer overflow
            6D       0239'CF     DE  016E   300 	MOVAL	W^ERR_HANDLER, (FP)	; setup ERR=/END= handler
            5B   00000000'EF     D0  0173   400 	MOVL	L^OTS$$A_CUR_LUB, R11	; R11 -> Current Control Block
            50         04 BC     7D  017A   500 	MOVQ	@elem_adr(AP), R0	; R0/R1 = string descriptor (len, adr)
                          51     DD  017E   600 	PUSHL	R1			; arg3 = adr. of string
            7E            50     3C  0180   700 	MOVZWL	R0, -(SP)		; arg2 = length of string
                          0E     DD  0183   800 	PUSHL	#DSC$K_DTYPE_T		; arg1 = data type code of string (text)
            50         A5 AB     9A  0185   900 	MOVZBL	ISB$B_STTM_TYPE(R11),R0	; get statement type for dispatch
            50       0000'CF40   32  0189  1000 	CVTWL	W^FOR$$AA_UDF_PR1[R0], R0	; R0 = word displacement to UDF routine
       0000'CF40          03     FB  018F  1100 	CALLS	#3, W^FOR$$AA_UDF_PR1[R0]	; process the element
            50         10 AD     D0  0195  1200 	MOVL	SF$L_SAVE_PC(FP), R0	; R0 = user PC saved on call
         10 AD         A3'AF     DE  0199  1300 	MOVAL	B^10$, SF$L_SAVE_PC(FP)	; set return PC to label in this routine
            51         04 BC     3C  019E  1400 	MOVZWL	@elem_adr(AP), R1	; R1 = length of string to be popped
                                 04  01A2  1500 	RET				; return to label 10$
                                     01A3  1600 
                                     01A3  1700 ;+
                                     01A3  1800 ; Here on RET to pop off string from stack and go back to user
                                     01A3  1900 ;-
                                     01A3  2000 
            5E            51     C0  01A3  2100 10$:	ADDL	R1, SP			; adjust SP by length of string
                          60     17  01A6  2200 	JMP	(R0)			; now return to caller
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  13
2-27            FOR$IO_X_DA - Transmit entire array by descript                                                                 (11)

                                     01A8   100 	.SBTTL	FOR$IO_X_DA	- Transmit entire array by descriptor
                                     01A8   200 
                                     01A8   300 ;++
                                     01A8   400 ; ABSTRACT:
                                     01A8   500 ;
                                     01A8   600 ;	Transmit (READ or WRITE) a single data type element from
                                     01A8   700 ;	the user I/O list to the output buffer by
                                     01A8   800 ;	calling the appropriate user data formatter
                                     01A8   900 ;	(UDF) routine for the current I/O statement.
                                     01A8  1000 ;
                                     01A8  1100 ; FORMAL PARAMETERS:
                                     01A8  1200 ;
                                     01A8  1300 ;	ARRAY_DESC_ADR.xx.da	Adr. of array descriptor
                                     01A8  1400 ;				Data type code in descriptor
                                     01A8  1500 ;
                                     01A8  1600 ; IMPLICIT INPUTS:
                                     01A8  1700 ;
                                     01A8  1800 ;	OTS$$A_CUR_LUB		Adr. of current logical
                                     01A8  1900 ;				unit block (LUB). Used to setup
                                     01A8  2000 ;				ISB base to get current I/O
                                     01A8  2100 ;				statement type code.
                                     01A8  2200 ;	ISB$B_STTM_TYPE		I/O statement type code - index
                                     01A8  2300 ;				to dispatch table entry.
                                     01A8  2400 ;	FOR$$AA_UDF_PR1		Array of user data formatters (UDF
                                     01A8  2500 ;				level of abstraction.)
                                     01A8  2600 ;
                                     01A8  2700 ; IMPLICIT OUTPUTS:
                                     01A8  2800 ;
                                     01A8  2900 ;	NONE
                                     01A8  3000 ;
                                     01A8  3100 ; SIDE EFFECTS:
                                     01A8  3200 ;
                                     01A8  3300 ;	If an error occurs, it is  SIGNALed unless an ERR=
                                     01A8  3400 ;	transfer parameter was specified when the I/O statement
                                     01A8  3500 ;	initialization call was made (see module FOR$IO_BEG,
                                     01A8  3600 ;	entry points: FOR${READ,WRITE}_{SF,SO,SU,DF,DO,DU,SL} or
                                     01A8  3700 ;	FOR${DECODE,ENCODE}_{MF,MO}), in which case control
                                     01A8  3800 ;	is transferred to the specified address (after stack unwound.)
                                     01A8  3900 ;--
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  14
2-27            FOR$IO_X_DA - Transmit entire array by descript                                                                 (12)

                               081C' 01A8   100 	.ENTRY	FOR$IO_X_DA, ^M<R2,R3,R4,R11>
            6D       0239'CF     DE  01AA   200 	MOVAL	W^ERR_HANDLER, (FP)	; setup ERR=/END= handler
            5B   00000000'EF     D0  01AF   300 	MOVL	L^OTS$$A_CUR_LUB, R11	; R11 -> Current Control Block
            50         A5 AB     9A  01B6   400 	MOVZBL	ISB$B_STTM_TYPE(R11),R0	; get statement type for dispatch
            52       0000'CF40   32  01BA   500 	CVTWL	W^FOR$$AA_UDF_PR1[R0], R2	; R2 = word displacement to UDF routine
            50         04 AC     D0  01C0   600 	MOVL	elem_adr(AP), R0	; get ptr to descriptor
            54         04 A0     D0  01C4   700 	MOVL	DSC$A_POINTER(R0), R4	; get base address
                                 E0  01C8   800 	BBS	#LUB$V_UNFORMAT,-	; is this unformatted?
         FC AB            09         01C9   900 		LUB$L_UNIT_STAT(R11), 20$
                          2C         01CC       
                                     01CD  1000 					; if yes, go transfer the whole array
            54         0C A0     C1  01CD  1100 	ADDL3	DSC$L_ARSIZE(R0), R4, AP	; get high address+1
                          5C         01D1       
            53            60     3C  01D2  1200 	MOVZWL	DSC$W_LENGTH(R0), R3	; get element length
         02 A0            0C     91  01D5  1300 	CMPB	#DSC$K_DTYPE_FC, DSC$B_DTYPE(R0)	; COMPLEX*8 array?
                          2E     13  01D9  1400 	BEQL	100$			; process COMPLEX specially
                          7E     D4  01DB  1500 	CLRL	-(SP)			; amake space for elem addr
                          53     DD  01DD  1600 	PUSHL	R3			; push element size
            7E         02 A0     9A  01DF  1700 	MOVZBL	DSC$B_DTYPE(R0), -(SP)	; push data-type code
                          03     DD  01E3  1800 	PUSHL	#3			; 3 arguments to UDF
                                     01E5  1900 10$:					; element loop point
            5C            54     D1  01E5  2000 	CMPL	R4, AP			; end of array yet?
                          4E     1E  01E8  2100 	BGEQU	200$			; yes
         0C AE            64     DE  01EA  2200 	MOVAL	(R4), item_addr(SP)	; set element address
       0000'CF42          6E     FA  01EE  2300 	CALLG	(SP), W^FOR$$AA_UDF_PR1[R2]	; call UDF routine
            54            53     C0  01F4  2400 	ADDL2	R3, R4			; add length, point to next element
                          EC     11  01F7  2500 	BRB	10$			; loop back
                                     01F9  2600 
                                     01F9  2700 ;+
                                     01F9  2800 ; Here to transmit an entire unformatted array as a single unit
                                     01F9  2900 ;-
                                     01F9  3000 
                          54     DD  01F9  3100 20$:	PUSHL	R4			; adr. of first byt of array
                       0C A0     DD  01FB  3200 	PUSHL	DSC$L_ARSIZE(R0)	; array size in bytes
            7E         02 A0     9A  01FE  3300 	MOVZBL	DSC$B_DTYPE(R0), -(SP)	; data type of array elements
       0000'CF42          03     FB  0202  3400 	CALLS	#3, W^FOR$$AA_UDF_PR1[R2]	; call UDF routine
                                 04  0208  3500 	RET				; return to user program
                                     0209  3600 
                                     0209  3700 ;+
                                     0209  3800 ; Here to handle complex data type.  Make two calls per element in array.
                                     0209  3900 ; Indicate which half by fourth actual parameter
                                     0209  4000 ;-
                                     0209  4100 
                                     0209  4200 100$:					; COMPLEX is handled as 2 floatings
                          7E     7C  0209  4300 	CLRQ	-(SP)			; make space for flag and address
                          04     DD  020B  4400 	PUSHL	#4			; push floating elem size
                          0A     DD  020D  4500 	PUSHL	#DSC$K_DTYPE_F		; push floating type code
                          04     DD  020F  4600 	PUSHL	#4			; 4 arguments to UDF routine
                                     0211  4700 
                                     0211  4800 110$:					; loop
            5C            54     D1  0211  4900 	CMPL	R4, AP			; end of array yet?
                          22     1E  0214  5000 	BGEQU	200$			; yes
                       10 AE     D4  0216  5100 	CLRL	cpx_flag(SP)		; flag real part
         0C AE            54     D0  0219  5200 	MOVL	R4, item_addr(SP)	; push real part address
       0000'CF42          6E     FA  021D  5300 	CALLG	(SP), W^FOR$$AA_UDF_PR1[R2]	; process real part
                       10 AE     D6  0223  5400 	INCL	cpx_flag(SP)		; mark imag part
         0C AE         04 A4     DE  0226  5500 	MOVAL	4(R4), item_addr(SP)	; push imag part address
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  15
2-27            FOR$IO_X_DA - Transmit entire array by descript                                                                 (12)

   00000000'EF42          6E     FA  022B  5600 	CALLG	(SP), FOR$$AA_UDF_PR1[R2]	; process imag part
            54            53     C0  0233  5700 	ADDL2	R3, R4			; add length
                          D9     11  0236  5800 	BRB	110$			; loop back
                                     0238  5900 
                                 04  0238  6000 200$:	RET
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  16
2-27            ERR_HANDLER - Exception handler for errors                                                                      (13)

                                     0239   100 	.SBTTL	ERR_HANDLER	- Exception handler for errors
                                     0239   200 
                                     0239   300 ;++
                                     0239   400 ; ABSTRACT:
                                     0239   500 ;
                                     0239   600 ;	ERR_HANDLER accepts a signal and calls the ERR= and END=
                                     0239   700 ;	error condition handler as if it were the CHF condition
                                     0239   800 ;	facility itself.  It passes along to FOR$$END_ERRHND
                                     0239   900 ;	the ERR= and END= user addresses saved in the ISB at the
                                     0239  1000 ;	beginning of the I/O statement.
                                     0239  1100 ;
                                     0239  1200 ; FORMAL PARAMETERS:
                                     0239  1300 ;
                                     0239  1400 ;	NONE
                                     0239  1500 ;
                                     0239  1600 ; IMPLICIT INPUTS:
                                     0239  1700 ;
                                     0239  1800 ;	OTS$$A_CUR_LUB		Adr. of current logical unit block
                                     0239  1900 ;	ISB$A_ERR_EQUAL		Adr. in user program to transfer to on errors or 0
                                     0239  2000 ;	ISB$A_END_EQUAL		Adr. in user program to transfer to on EOF or 0
                                     0239  2100 ;
                                     0239  2200 ; IMPLICIT OUTPUTS:
                                     0239  2300 ;
                                     0239  2400 ;	NONE
                                     0239  2500 ;
                                     0239  2600 ; FUNCTION VALUE:
                                     0239  2700 ;
                                     0239  2800 ;	SS$_RESIGNAL to cause a resignal to occur (no END= or ERR=)
                                     0239  2900 ;	to give user handler and OTS default handler a chance at error.
                                     0239  3000 ;	However, if an ERR= or END= transfer is to be done, the function value is ignored
                                     0239  3100 ;	by the condition handling facility because UNWIND has been called.
                                     0239  3200 ;
                                     0239  3300 ; SIDE EFFECTS:
                                     0239  3400 ;
                                     0239  3500 ;	If an ERR= or an END= transfer is to take place back to the user,
                                     0239  3600 ;	SYS$$UNWIND has been called to casue the condition handling facility
                                     0239  3700 ;	to unwind the stack when this error handler returns.
                                     0239  3800 ;--
                                     0239  3900 
                                     0239  4000 
                                     0239  4100 ERR_HANDLER:
                               0000  0239  4200 	.WORD	0			; no registers need saving
            50   00000000'EF     D0  023B  4300 	MOVL	L^OTS$$A_CUR_LUB, R0	; R0 -> Current Control Block
                          00     DD  0242  4400 	PUSHL	#FOR$K_UNWINDPOP	; make a long containing FOR$K_UNWINDPOP
                                     0244  4500 					; to indicate UNWIND action is to pop LUB/ISB/RAB.
                          00     DD  0244  4600 	PUSHL	#0			; make a 0 by reference
                          5E     DD  0246  4700 	PUSHL	SP			; point to the 0 - incremental depth =
                                     0248  4800 					; no. of frames between user and establisher.
                       B0 A0     DF  0248  4900 	PUSHAL	ISB$A_END_EQUAL(R0)	; push END= address
                       AC A0     DF  024B  5000 	PUSHAL	ISB$A_ERR_EQUAL(R0)	; push ERR= address
            7E         10 AE     DE  024E  5100 	MOVAL	16(SP), -(SP)		; Indicate UNWIND action is to
                                     0252  5200 					; pop current LUB/ISB/RAB on error
                          04     DD  0252  5300 	PUSHL	#4			; 4 ENABLE args
                          5E     DD  0254  5400 	PUSHL	SP			; push address of ENABLE args
            7E         04 AC     7D  0256  5500 	MOVQ	sig_args(AP), -(SP)	; copy down the signal arg and
                                     025A  5600 					; mechanism arg ptrs from the caller
   00000000'EF            03     FB  025A  5700 	CALLS	#3, L^FOR$$ERR_ENDHND	; call the real handler
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  17
2-27            ERR_HANDLER - Exception handler for errors                                                                      (13)

                                 04  0261  5800 	RET
                                     0262  5900 
                                     0262  6000 	.END				; end of module FOR$IO_ELEM.MAR
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  18
SYMBOL TABLE                                                                                                                    (13)

BIT...         = 00000006            DSC$K_DTYPE_W  = 00000007            FOR$K_STTM_RSF = 00000000            
CALL1            000000B7 R     03   DSC$K_DTYPE_WU = 00000003            FOR$K_STTM_RSL = 00000008            
CALLUDF          000000B0 R     03   DSC$K_DTYPE_Z  = 00000000            FOR$K_STTM_RSU = 00000002            
COM              000000AB R     03   DSC$K_DTYPE_ZEM= 00000017            FOR$K_STTM_WDF = 00000005            
COM_IO_ELEM      00000034 R     03   DSC$K_DTYPE_ZI = 00000016            FOR$K_STTM_WDU = 00000007            
CPX_FLAG       = 00000010            DSC$K_D_BLN      00000008            FOR$K_STTM_WMF = 0000000B            
DSC$A_A0         00000010            DSC$K_JI_BLN     0000000C            FOR$K_STTM_WSF = 00000001            
DSC$A_FRAME      00000008            DSC$K_J_BLN      00000008            FOR$K_STTM_WSL = 00000009            
DSC$A_POINTER    00000004            DSC$K_PI_BLN     0000000C            FOR$K_STTM_WSU = 00000003            
DSC$B_AFLAGS     0000000A            DSC$K_P_BLN      00000008            FOR$K_UNWINDNOP= 00000001            
DSC$B_CLASS      00000003            DSC$K_S_BLN      00000008            FOR$K_UNWINDPOP= 00000000            
DSC$B_DIMCT      0000000B            DSC$K_Z_BLN      00000008            FOR$K_UNWINDRET= 00000002            
DSC$B_DTYPE      00000002            DSC$L_ARSIZE     0000000C            FOR$K_USR_BUF  = 00000002            
DSC$C_D_BLN      00000008            DSC$L_M1         00000014            FOR$K_WRITE    = 00000008            
DSC$C_JI_BLN     0000000C            DSC$L_M2         00000018            FOR$L_SIG_ACNT   00000000            
DSC$C_J_BLN      00000008            DSC$S_FL_BOUNDS= 00000001            FOR$L_SIG_FCNT   00000008            
DSC$C_PI_BLN     0000000C            DSC$S_FL_COEFF = 00000001            FOR$L_SIG_LUN    0000000C            
DSC$C_P_BLN      00000008            DSC$S_FL_COLUMN= 00000001            FOR$L_SIG_NAME   00000004            
DSC$C_S_BLN      00000008            DSC$V_FL_BOUNDS= 00000007            FOR$L_SIG_PC     00000020            
DSC$C_Z_BLN      00000008            DSC$V_FL_COEFF = 00000006            FOR$L_SIG_PSL    00000024            
DSC$K_CLASS_A  = 00000004            DSC$V_FL_COLUMN= 00000005            FOR$L_SIG_STS    00000018            
DSC$K_CLASS_D  = 00000002            DSC$W_LENGTH     00000000            FOR$L_SIG_STV    0000001C            
DSC$K_CLASS_J  = 00000007            DSC$W_MAXLEN     00000008            FOR$L_SIG_UPC    00000014            
DSC$K_CLASS_JI = 00000008            ELEM_ADR       = 00000004            GBL...         = 00000000            
DSC$K_CLASS_P  = 00000005            ELEM_VAL       = 00000004            IO_B_COM         0000000C R     03   
DSC$K_CLASS_PI = 00000006            ERR_HANDLER      00000239 R     03   IO_D_COM         00000112 R     03   
DSC$K_CLASS_S  = 00000001            FOR$$AA_UDF_PR1  ********   X   01   IO_FC_COM        00000127 R     03   
DSC$K_CLASS_V  = 00000003            FOR$$ERR_ENDHND  ********   X   01   IO_F_COM         000000FF R     03   
DSC$K_CLASS_Z  = 00000000            FOR$A_SIG_RNS    00000010            IO_LU_COM        000000EC R     03   
DSC$K_DTYPE_B  = 00000006            FOR$IO_B_R       00000007 RG    03   IO_L_COM         00000030 R     03   
DSC$K_DTYPE_BU = 00000002            FOR$IO_B_V       00000000 RG    03   IO_WU_COM        000000D9 R     03   
DSC$K_DTYPE_D  = 0000000B            FOR$IO_D_R       0000010D RG    03   IO_W_COM         0000001E R     03   
DSC$K_DTYPE_DC = 0000000D            FOR$IO_D_V       00000106 RG    03   ISB$A_BUF_BEG    FFFFFFC4            
DSC$K_DTYPE_DPC= 000000B9            FOR$IO_FC_R      00000121 RG    03   ISB$A_BUF_END    FFFFFFBC            
DSC$K_DTYPE_EOM= 000000BD            FOR$IO_FC_V      00000119 RG    03   ISB$A_BUF_HIGH   FFFFFFC8            
DSC$K_DTYPE_EOR= 000000BF            FOR$IO_F_R       000000FA RG    03   ISB$A_BUF_PTR    FFFFFFB8            
DSC$K_DTYPE_F  = 0000000A            FOR$IO_F_V       000000F3 RG    03   ISB$A_END_EQUAL  FFFFFFB0            
DSC$K_DTYPE_FC = 0000000C            FOR$IO_LU_R      000000E7 RG    03   ISB$A_ERR_EQUAL  FFFFFFAC            
DSC$K_DTYPE_FLD= 000000B7            FOR$IO_LU_V      000000E0 RG    03   ISB$A_FMT_BEG    FFFFFFB4            
DSC$K_DTYPE_L  = 00000008            FOR$IO_L_R       0000002B RG    03   ISB$A_FMT_PTR    FFFFFFC0            
DSC$K_DTYPE_LBL= 000000BA            FOR$IO_L_V       00000024 RG    03   ISB$A_PUSH_LUB   FFFFFFA8            
DSC$K_DTYPE_LU = 00000004            FOR$IO_T_DS      0000015C RG    03   ISB$B_ERR_NO     FFFFFFA4            
DSC$K_DTYPE_MOD= 000000BC            FOR$IO_T_V_DS    0000016C RG    03   ISB$B_FMT_CODE   FFFFFFD3            
DSC$K_DTYPE_NL = 00000010            FOR$IO_WU_R      000000D4 RG    03   ISB$B_FMT_D      FFFFFFCF            
DSC$K_DTYPE_NLO= 00000011            FOR$IO_WU_V      000000CD RG    03   ISB$B_FMT_DEP    FFFFFFD6            
DSC$K_DTYPE_NR = 00000012            FOR$IO_W_R       00000019 RG    03   ISB$B_FMT_E      FFFFFFD0            
DSC$K_DTYPE_NRO= 00000013            FOR$IO_W_V       00000012 RG    03   ISB$B_FMT_P      FFFFFFCC            
DSC$K_DTYPE_NU = 0000000F            FOR$IO_X_DA      000001A8 RG    03   ISB$B_LIS_CTYPE  FFFFFFD3            
DSC$K_DTYPE_NZ = 00000014            FOR$K_CONTROL_Z= 0000001A            ISB$B_STTM_STAT  FFFFFFD7            
DSC$K_DTYPE_P  = 00000015            FOR$K_ERR_PREFX= 00000018            ISB$B_STTM_TYPE  FFFFFFA5            
DSC$K_DTYPE_PCT= 000000B8            FOR$K_FMT_ADR  = 00000001            ISB$C_NEG_BLN    FFFFFF84            
DSC$K_DTYPE_Q  = 00000009            FOR$K_LIST_DIR = 00000006            ISB$C_NEG_LUB    FFFFFFD8            
DSC$K_DTYPE_QU = 00000005            FOR$K_OBJ_FMT  = 00000007            ISB$K_ISB_LEN  = 00000054            
DSC$K_DTYPE_RTN= 000000BE            FOR$K_REC_NO   = 00000000            ISB$K_NEG_BLN    FFFFFF84            
DSC$K_DTYPE_SLB= 000000BB            FOR$K_STTM_RDF = 00000004            ISB$K_NEG_LUB    FFFFFFD8            
DSC$K_DTYPE_T  = 0000000E            FOR$K_STTM_RDU = 00000006            ISB$L_CONSBLOCK  FFFFFFC4            
DSC$K_DTYPE_V  = 00000001            FOR$K_STTM_RMF = 0000000A            ISB$L_LIS_CON0   FFFFFFC4            
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  19
SYMBOL TABLE                                                                                                                    (13)

ISB$L_LIS_CON1   FFFFFFC8            MTH__WRONUMARG = 00000050            
ISB$V_DE_ENCODE= 00000004            OTS$$A_CUR_LUB   ********   X   01   
ISB$V_DOLLAR   = 00000000            RBYTE            00000095 R     03   
ISB$V_FMT_REPRE= 00000007            RLONG            000000A1 R     03   
ISB$V_LAST_REC = 00000003            RQUAD            000000A7 R     03   
ISB$V_LIS_HEAP = 00000005            RU               00000080 R     03   
ISB$V_SLASH    = 00000002            RWORD            0000009B R     03   
ISB$V_USER_ELEM= 00000001            SF$A_HANDLER     00000000            
ISB$W_FMT_LEN    FFFFFFA6            SF$L_SAVE_AP     00000008            
ISB$W_FMT_REP    FFFFFFD1            SF$L_SAVE_FP     0000000C            
ISB$W_FMT_REVER  FFFFFFD4            SF$L_SAVE_PC     00000010            
ISB$W_FMT_STKP   FFFFFF84            SF$L_SAVE_REGS   00000014            
ISB$W_FMT_STKR   FFFFFF94            SF$M_C         = 00000001            
ISB$W_FMT_W      FFFFFFCD            SF$M_DV        = 00000080            
ISB$W_LIS_REP    FFFFFFD1            SF$M_FU        = 00000040            
ITEM_ADDR      = 0000000C            SF$M_IV        = 00000020            
LUB$A_ASSOC_VAR  FFFFFFDC            SF$M_N         = 00000008            
LUB$A_FAB        FFFFFFE8            SF$M_TBIT      = 00000010            
LUB$A_RBUF_ADR   FFFFFFEC            SF$M_V         = 00000002            
LUB$A_RSN        FFFFFFF8            SF$M_Z         = 00000004            
LUB$B_LUN        FFFFFFF6            SF$S_C         = 00000001            
LUB$B_RSL        FFFFFFF7            SF$S_CALLS     = 00000001            
LUB$C_NEG_BLN    FFFFFFD8            SF$S_DV        = 00000001            
LUB$K_LUB_LEN  = 00000028            SF$S_FU        = 00000001            
LUB$K_NEG_BLN    FFFFFFD8            SF$S_IV        = 00000001            
LUB$L_LOG_RECNO  FFFFFFE0            SF$S_N         = 00000001            
LUB$L_REC_MAX    FFFFFFE4            SF$S_SAVE_MASK = 0000000C            
LUB$L_UNIT_STAT  FFFFFFFC            SF$S_STACKOFFS = 00000002            
LUB$V_APPEND   = 0000000D            SF$S_TBIT      = 00000001            
LUB$V_ASS_VAR_L= 0000000C            SF$S_V         = 00000001            
LUB$V_DELETE   = 00000006            SF$S_Z         = 00000001            
LUB$V_DIRECT   = 00000004            SF$V_C         = 00000000            
LUB$V_ENDFILOPN= 00000011            SF$V_CALLS     = 0000000D            
LUB$V_FIXED    = 0000000A            SF$V_DV        = 00000007            
LUB$V_FORMATTED= 00000008            SF$V_FU        = 00000006            
LUB$V_IO_ACTIVE= 00000001            SF$V_IV        = 00000005            
LUB$V_NOTSEQORG= 0000000E            SF$V_N         = 00000003            
LUB$V_OLD_FILE = 00000003            SF$V_SAVE_MASK = 00000000            
LUB$V_OPENED   = 00000000            SF$V_STACKOFFS = 0000000E            
LUB$V_PRINT    = 00000007            SF$V_TBIT      = 00000004            
LUB$V_READ_ONLY= 00000002            SF$V_V         = 00000001            
LUB$V_SCRATCH  = 00000005            SF$V_Z         = 00000002            
LUB$V_SEGMENTED= 0000000B            SF$W_SAVE_MASK   00000006            
LUB$V_UNFORMAT = 00000009            SF$W_SAVE_PSW    00000004            
LUB$V_USEROPEN = 0000000F            SIG_ARGS       = 00000004            
LUB$V_VIRT_RSN = 00000010            WBYTE            00000068 R     03   
LUB$W_DID        FFFFFFF0            WLONG            00000074 R     03   
LUB$W_IFI        FFFFFFD8            WQUAD            0000007A R     03   
LUB$W_RBUF_SIZE  FFFFFFDA            WWORD            0000006E R     03   
MTH$K_ERR_PREFX= 00000016            
MTH__FLOOVEMAT = 00000058            
MTH__FLOUNDMAT = 00000059            
MTH__INVARG    = 00000051            
MTH__LOGZERNEG = 00000053            
MTH__SINSIGLOS = 00000057            
MTH__SQUROONEG = 00000054            
MTH__UNDEXP    = 00000052            
FOR$IO_ELEM     ; FORTRAN I/O element transmission               21-AUG-1978 18:55:41   VAX-11 MACRO X0.3-11               Page  20
PROGRAM SECTION SYNOPSIS                                                                                                        (13)



PROGRAM SECTION SYNOPSIS

.  ABS  .        00000000      00     NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT BYTE  
. BLANK .        00000000      01     NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT BYTE  
$ABS$            FFFFFFFC      02     NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT BYTE  
FOR$CODE         00000262      03       PIC   USR   CON   REL   LCL   SHR   EXE   RD  NOWRT LONG  


THERE WERE NO ERRORS OR WARNINGS.
18084. BYTES LEFT IN FREE MEMORY POOL.
2454. BYTES OF RECLAIMED MEMORY.
OBJ$:FORIOELEM,LIS$:FORIOELEM/-SP=LIB$:S/ML,SRC$:P,FORIOELEM
7 MLB DIR RDS - 459 GETS TO DEFINE 12 MACROS. 28 INTER. FILE WRITES. 
