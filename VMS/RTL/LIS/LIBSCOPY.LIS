LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   0
TABLE OF CONTENTS   

   (2)     100  HISTORY		; Detailed Current Edit History
   (3)     100  DECLARATIONS
   (5)     100  LIB$SGET1_DD - Routines to allocate dynamic str
   (6)     100  LIB$SFREE1_DD - Routines to deallocate string a
   (7)     100  LIB$SFREEN_DD - Routines to deallocate string a
   (9)     100  LIB$SCOPY_DXDX - Copy any class string to any c
   (11)    100  LIB$SCOPY_R_DX - Copy any class string to any c
   (15)    100  LIB$SCOPY_DXDD - Copy any class string to dynam
   (17)    100  LIB$$SCOPY_RDD6 - Internal JSB routine to copy 
   (21)    100  ALLOC_N_COPY_R5 - Allocate, set dst descr., and
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   1
0-33                                                                                                                             (1)

                                     0000   100 	.TITLE	LIB$SCOPY		; Library copy strings 
                                     0000   200 	.IDENT	/0-33/			; File: LIBSCOPY.MAR
                                     0000   300 
                                     0000   400 ;
                                     0000   500 ; Copyright (C) 1977
                                     0000   600 ; Digital Equipment Corporation, Maynard, Massachusetts 01754
                                     0000   700 ;
                                     0000   800 ; This software is furnished under a license for use only on a single
                                     0000   900 ; computer  system  and  may be copied only with the inclusion of the
                                     0000  1000 ; above copyright notice. This software, or any other copies thereof,
                                     0000  1100 ; may not be provided or otherwise made available to any other person
                                     0000  1200 ; except for use on such system and to one who agree to these license 
                                     0000  1300 ; terms.  Title to  and  ownership of the software shall at all times 
                                     0000  1400 ; remain in DEC.
                                     0000  1500 ;
                                     0000  1600 ; The information in the software is subject to change without notice
                                     0000  1700 ; and should  not  be construed  as a commitment by Digital Equipment 
                                     0000  1800 ; Corporation.
                                     0000  1900 ;
                                     0000  2000 ; DEC assumes  no  responsibility  for the use or  reliability of its
                                     0000  2100 ; software on equipment which is not supplied by DEC.
                                     0000  2200 ;
                                     0000  2300 ;
                                     0000  2400 ; FACILITY: GENERAL UTILITY LIBRARY
                                     0000  2500 ;++
                                     0000  2600 ; ABSTRACT:
                                     0000  2700 ;
                                     0000  2800 ;	Procedures to copy strings of different classes.
                                     0000  2900 ;	Provides a way for procedures written in different languages
                                     0000  3000 ;	to return strings to callers of arbitrary language.
                                     0000  3100 ;
                                     0000  3200 ;--
                                     0000  3300 ;
                                     0000  3400 ; VERSION: 0
                                     0000  3500 ;
                                     0000  3600 ; HISTORY:
                                     0000  3700 ;
                                     0000  3800 ; AUTHOR:
                                     0000  3900 ;	Thomas N. Hastings, 8-Oct-77: Version 0
                                     0000  4000 ;
                                     0000  4100 ; MODIFIED BY:
                                     0000  4200 ;
                                     0000  4300 ;
                                     0000  4400 ; 0-11	- Fix typo in PIC case table.  DGP 29-Jun-78
                                     0000  4500 ;
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   2
0-33            HISTORY  ; Detailed Current Edit History                                                                         (2)

                                     0000   100 	.SBTTL	HISTORY		; Detailed Current Edit History
                                     0000   200 
                                     0000   300 
                                     0000   400 ; Edit History for Version 0
                                     0000   500 ;
                                     0000   600 
                                     0000   700 ; 0-9	- Pass by-reference.  TNH 19-DEC-77
                                     0000   800 ; 0-10	- Change order of arguments to conform to manual.  JMT 5-Mar-78
                                     0000   900 ; 0-12	- Change JSB entry point names to DX6.  TNH 5-July-78
                                     0000  1000 ; 0-14	- Add dynamic descriptors.  TNH 5-July-78
                                     0000  1100 ; 0-28	- Remove entry points not in manual.  TNH 1-Aug-78
                                     0000  1110 ; 0-29	- Make REMQUE be PIC.  TNH 2-Aug-78
                                     0000  1120 ; 0-31	- And INSQUE be PIC.  TNH 2-Aug-78
                                     0000  1220 ; 0-32	- Compute effective adr before REMQUE to be PIC.  TNH 2-Aug-78
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   3
0-33            DECLARATIONS                                                                                                     (3)

                                     0000   100 	.SBTTL	DECLARATIONS
                                     0000   200 					; to VAX-11 error code and SIGNAL_STOP
                                     0000   300 
                                     0000   400 ;
                                     0000   500 ; INCLUDE FILES:
                                     0000   600 ;
                                     0000   700 	$DSCDEF				; Descriptor symbols
                                     0000   800 	$SSDEF				; SS$_... symbols
                                     0000   900 ;
                                     0000  1000 ; EXTERNAL SYMBOLS:
                                     0000  1100 ;
                                     0000  1200 	.DSABL	GBL			; Disable automatic globals for undefined
                                     0000  1300 	.EXTRN	LIB$_INVSTRDES		; error code - INVALID STRING DESCRIPTOR 
                                     0000  1400 	.EXTRN	LIB$_STRTRU		; success code - STRING TRUNCATED
                                     0000  1500 	.EXTRN	LIB$GET_VM		; allocate virtual memory
                                     0000  1600 	.EXTRN	LIB$FREE_VM		; free virtual memory
                                     0000  1700 	.EXTRN	SYS$EXPREG		; system service to expand region
                                     0000  1800 
                                     0000  1900 ;
                                     0000  2000 ; MACROS:
                                     0000  2100 ;
                                     0000  2200 
                                     0000  2300 ; EQUATED SYMBOLS:
                                     0000  2400 ;
                                     0000  2500 
                                     0000  2600 ;+
                                     0000  2700 ; Define Dynamic String control block (DSB) (pointed to by descriptor)
                                     0000  2800 ; Actually the descriptor (DSC$A_POINTER) points to where the string
                                     0000  2900 ; is stored in the control block and the header is before that (negative offset).
                                     0000  3000 ;-
                                     0000  3100 
                           FFFFFFFE  0000  3200 DSB$W_ALLOC_LEN = -2	; offset to word containint allocated length.
                                     0000  3300 			; actually no. of bytes following which is also
                                     0000  3400 			; max. size of string that can be held in the control block
                                     0000  3500 			; In other words this count does not include
                                     0000  3600 			; the space taken up by itself.
                           00000002  0000  3700 DSB$K_HED_LEN = 2	; No. of bytes in the control block header.
                                     0000  3800 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   4
0-33            DECLARATIONS                                                                                                     (4)

                           00000002  0000   100 K_RESIDUE = 4 - DSB$K_HED_LEN		; no. of extra bytes that can be
                                     0000   200 					; in string because next header doesn't
                                     0000   300 					; take up entire longword.
                                     0000   400 					; (ie. residue is no. extra bytes
                                     0000   500 					; beyond n*K_ALLOC_QUANTA in string area).
                           00000003  0000   600 K_ALLOC_POWER = 3			; Power of 2 of alocation unit (8)
                                     0000   700 	;MAINTENANCE NOTE: Some advantage is taken in the code that the
                                     0000   800 	; size of the Q header is the same as the quanta.  Thus no shifting
                                     0000   900 	; is needed in order to perform INSQUE and REMQUE, only adding offsets.
                           00000008  0000  1000 K_ALLOC_QUANTA = 1 @ K_ALLOC_POWER	; No. of bytes in allocation quanta
                                     0000  1100 
                           0000001E  0000  1200 K_NO_FAST_QS = 30	; No. of fast Qs, one Q for each allocation quanta
                                     0000  1300 			; with current parameter settings, string area
                                     0000  1400 			; sizes are 10, 18, 26, ..., 242
                           00000001  0000  1800 K_NO_PAGES_EXP = 1	; No. of pages to expand program region 
                                     0000  1900 			; whena fast Q is exhausted.
                                     0000  2000 			; The entire expansion is added to that single queue
                                     0000  2100 			; as a series of blocks of the same size.
                                     0000  2200 
                           000000EA  0000  2300 K_MAX_SIZ_STR = <<K_NO_FAST_QS-1>*K_ALLOC_QUANTA>+K_RESIDUE
                                     0000  2400 			; Max. size of string which can fit in fast Qs.
                                     0000  2450 			; Don't count first Q which is always empty
                                     0000  2500 ;
                                     0000  2600 ; OWN STORAGE:
                                     0000  2700 ;
                                 00000000  2800 	.PSECT	LIB$DATA PIC,USR,CON,REL,LCL,NOSHR,NOEXE,RD,WRT,LONG
                                     0000  2900 
                           000000F0  0000  3000 Q_HED:	.BLKB	K_NO_FAST_QS*8		; Q headers - long word aligned!!
                                     00F0  3100 					; 8 bytes each for INSQUE, REMQUE
                                     00F0  3200 					; 0th Q always empty
                                     00F0  3300 					; 1st Q alloc str area = 8 + residue
                                     00F0  3400 					; nth Q alloc str area =
                                     00F0  3500 					;    n*K_ALLOC_QUANTA + K_RESIDUE
                                     00F0  3600 
                                     00F0  3700 FIRST_TIME:				; 1 bit flag, set to 1 after first call
                           000000F1  00F0  3800 	.BLKB	1			; Used to initialize Qs first time.
                                     00F1  3900 
                                     00F1  4000 ;
                                     00F1  4100 ; PSECT DECLARATIONS:
                                     00F1  4200 ;
                                 00000000  4300 	.PSECT	LIB$CODE PIC,USR,CON,REL,LCL,SHR,EXE,RD,NOWRT,LONG
                                     0000  4400 ;
                                     0000  4500 ; REGISTER USAGE:
                                     0000  4600 ;
                                     0000  4700 ;	R0<15:0> length of source string to be copied
                                     0000  4800 ;	R1	adr. of source string
                                     0000  4900 ;	R2	adr. of destination string descriptor
                                     0000  5000 ;	R3	adr. of new destination control block string area (=adr to copy string to)
                                     0000  5100 ;		That is, the control block header has a negative offset form R3
                                     0000  5200 ;		Also used as counter by LIB$SFREEN
                                     0000  5300 ;	R4	scratch used by ALLOC_N_COPY_R5 routine
                                     0000  5400 ;		Also used as step address by LIB$SFREEN.
                                     0000  5500 ;	R5	no. of bytes to actually copy (set to 0 for SGET calls)
                                     0000  5600 ;	R6	adr. of string area in old destination control block or 0
                                     0000  5700 ;		(control block header is negative offset).
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   5
0-33            LIB$SGET1_DD - Routines to allocate dynamic str                                                                  (5)

                                     0000   100 	.SBTTL	LIB$SGET1_DD - Routines to allocate dynamic string space
                                     0000   200 
                                     0000   300 ;++
                                     0000   400 ; FUNCTIONAL DESCRIPTION:
                                     0000   500 ;
                                     0000   600 ;	Allocate dynamic string space to dynamic descriptor.
                                     0000   700 ;	Deallocate any space it may have had.  This procedure
                                     0000   800 ;	is the same as LIB$SCOPY_DXDX, except that no string is copied.
                                     0000   900 ;
                                     0000  1000 ; CALLING SEQUENCE:
                                     0000  1100 ;
                                     0000  1200 ;	Ret_status = LIB$SGET1_DD (no_bytes.rw.r, str.wt.dd)
                                     0000  1300 ;		JSB LIB$SGET1_DD_R6
                                     0000  1400 ;
                                     0000  1500 ; INPUT PARAMETERS (JSB entry only):
                                     0000  1600 ;
                                     0000  1700 ;	R0<15:0> = No. of bytes to allocate
                                     0000  1800 ;	R1 = Adr. of destination string descriptor (dynamic)
                                     0000  1900 ;
                                     0000  2000 ; IMPLICIT INPUTS:
                                     0000  2100 ;
                                     0000  2200 ;	None
                                     0000  2300 ;
                                     0000  2400 ; OUTPUT PARAMTERS:
                                     0000  2500 ;
                                     0000  2600 ;	R0 = COMPLETION STATUS
                                     0000  2700 ;
                                     0000  2800 ; IMPLICIT OUTPUTS:
                                     0000  2900 ;
                                     0000  3000 ;	None
                                     0000  3100 ;
                                     0000  3200 ; COMPLETION STATUS:
                                     0000  3300 ;
                                     0000  3400 ;	SS$_NORMAL
                                     0000  3500 ;	LIB$_INSVIRMEM	INSUFFICIENT VIRTUAL MEMORY
                                     0000  3600 ;
                                     0000  3700 ; SIDE EFFECTS:
                                     0000  3800 ;
                                     0000  3900 ;	See LIB$SCOPY_DXDX.
                                     0000  4000 ;--
                                     0000  4100 
                               007C' 0000  4200 	.ENTRY LIB$SGET1_DD, ^M<R2, R3, R4, R5, R6>
            50         04 BC     B0  0002  4300 	MOVW	@4(AP), R0		; R0 = number of bytes to allocate
            51         08 AC     D0  0006  4400 	MOVL	8(AP), R1		; R1 = adr. of dynamic descriptor
                          01     10  000A  4500 	BSBB	LIB$SGET1_DD_R6		; allocate space
                                 04  000C  4600 	RET				; return
                                     000D  4700 
                                     000D  4800 LIB$SGET1_DD_R6::			; JSB entry point
            52            51     D0  000D  4900 	MOVL	R1, R2			; R2 = adr. of dynamic descriptor
                                     0010  5000 					; to be allocated
                          55     D4  0010  5100 	CLRL	R5			; R5 = no. of chars to copy (none)
                          0097   31  0012  5200 	BRW	SGET1			; join SCOPY at secondary entry point
                                     0015  5300 					; RSB to caller.
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   6
0-33            LIB$SFREE1_DD - Routines to deallocate string a                                                                  (6)

                                     0015   100 	.SBTTL	LIB$SFREE1_DD - Routines to deallocate string area for 1 dynamic string
                                     0015   200 
                                     0015   300 ;++
                                     0015   400 ; FUNCTIONAL DESCRIPTION:
                                     0015   500 ;
                                     0015   600 ;	Deallocate 1 dynamic string.
                                     0015   700 ;
                                     0015   800 ; CALLING SEQUENCE:
                                     0015   900 ;
                                     0015  1000 ;	Ret_status = LIB$SFREE1_DD (string.wt.dd)
                                     0015  1100 ;		JSB LIB$SFREE1_DD6
                                     0015  1200 ;
                                     0015  1300 ; INPUT PARAMETERS (JSB entry point):
                                     0015  1400 ;
                                     0015  1500 ;	R0 = Adr. of destination string descriptor
                                     0015  1600 ;
                                     0015  1700 ; IMPLICIT INPUTS:
                                     0015  1800 ;
                                     0015  1900 ;	None
                                     0015  2000 ;
                                     0015  2100 ; OUTPUT PARAMTERS:
                                     0015  2200 ;
                                     0015  2300 ;	R0 = COMPLETION STATUS
                                     0015  2400 ;
                                     0015  2500 ; IMPLICIT OUTPUTS:
                                     0015  2600 ;
                                     0015  2700 ;	None
                                     0015  2800 ;
                                     0015  2900 ; COMPLETION STATUS:
                                     0015  3000 ;
                                     0015  3100 ;	SS$_NORMAL		success
                                     0015  3200 ;	LIB$_INSVIRMEM		INSUFFICIENT FIRTUAL MEMORY (severe)
                                     0015  3300 ;
                                     0015  3400 ; SIDE EFFECTS:
                                     0015  3500 ;
                                     0015  3600 ;	See LIB$SCOPY_R_DX.
                                     0015  3700 ;--
                                     0015  3800 
                               007C' 0015  3900 	.ENTRY LIB$SFREE1_DD, ^M<R2, R3, R4, R5, R6>
            50         04 AC     D0  0017  4000 	MOVL	4(AP), R0		; R0 = adr. of descriptor to free
                          01     10  001B  4100 	BSBB	LIB$SFREE1_DD6		; go deallocate space
                                 04  001D  4200 	RET				; return
                                     001E  4300 
                                     001E  4400 LIB$SFREE1_DD6::			; JSB entry point
            56         04 A0     D0  001E  4500 	MOVL	DSC$A_POINTER(R0), R6	; R6 = Adr. of string area to free
                          11     13  0022  4600 	BEQL	10$			; return if none allocated
                       04 A0     D4  0024  4700 	CLRL	DSC$A_POINTER(R0)	; indicate descriptor has no more space allocated
       00EA 8F         FE A6     B1  0027  4800 	CMPW	DSB$W_ALLOC_LEN(R6), -	; is this a small area?
                                     002D  4900 		#K_MAX_SIZ_STR		; or a big area?
                          03     1A  002D  5000 	BGTRU	5$			; branch if large
                          00C4   31  002F  5100 	BRW	FREE_SMALL_DST		; small - free, then RSB to caller
                          009C   31  0032  5200 5$:		BRW	FREE_BIG_DST		; large - free, then RSB to caller
                                     0035  5300 
            50            01     D0  0035  5400 10$:	MOVL	#SS$_NORMAL, R0		; R0 = success
                                 05  0038  5500 	RSB				; return
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   7
0-33            LIB$SFREEN_DD - Routines to deallocate string a                                                                  (7)

                                     0039   100 	.SBTTL	LIB$SFREEN_DD - Routines to deallocate string area for N dynamic strings
                                     0039   200 
                                     0039   300 ;++
                                     0039   400 ; FUNCTIONAL DESCRIPTION:
                                     0039   500 ;
                                     0039   600 ;	Deallocated 1 dynamic string.
                                     0039   700 ;
                                     0039   800 ; CALLING SEQUENCE:
                                     0039   900 ;
                                     0039  1000 ;	Ret_status = LIB$SFREEN_DD (no_descr.rl.r, string.wt.dd)
                                     0039  1100 ;
                                     0039  1200 ; INPUT PARAMETERS (JSB entry point):
                                     0039  1300 ;
                                     0039  1400 ;	R0 = No. of descriptors to deallocate
                                     0039  1500 ;	R1 = Adr. of destination string descriptor
                                     0039  1600 ;
                                     0039  1700 ; IMPLICIT INPUTS:
                                     0039  1800 ;
                                     0039  1900 ;	None
                                     0039  2000 ;
                                     0039  2100 ; OUTPUT PARAMTERS:
                                     0039  2200 ;
                                     0039  2300 ;	R0 = COMPLETION STATUS
                                     0039  2400 ;
                                     0039  2500 ; IMPLICIT OUTPUTS:
                                     0039  2600 ;
                                     0039  2700 ;	None
                                     0039  2800 ;
                                     0039  2900 ; COMPLETION STATUS:
                                     0039  3000 ;
                                     0039  3100 ;	SS$_NORMAL		success
                                     0039  3200 ;
                                     0039  3300 ; SIDE EFFECTS:
                                     0039  3400 ;
                                     0039  3500 ;	See LIB$SCOPY_R_DX.
                                     0039  3600 ;--
                                     0039  3700 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   8
0-33            LIB$SFREEN_DD - Routines to deallocate string a                                                                  (8)

                               007C' 0039   100 	.ENTRY LIB$SFREEN_DD, ^M<R2, R3, R4, R5, R6>
            50         04 BC     D0  003B   200 	MOVL	@4(AP), R0		; R0 = No. of strings to deallocate
            51         08 AC     D0  003F   300 	MOVL	8(AP), R1		; R1 = adr. of 1st descriptor to free
                          01     10  0043   400 	BSBB	LIB$SFREEN_DD6		; go deallocate space
                                 04  0045   500 	RET				; return
                                     0046   600 
                                     0046   700 LIB$SFREEN_DD6::
            53            50     D0  0046   800 	MOVL	R0, R3			; R3 = # of descriptors to go
                          0E     13  0049   900 	BEQL	10$			; return if none to do
            54            51     D0  004B  1000 	MOVL	R1, R4			; R4 = adr. of next descriptor
                                     004E  1100 
                                     004E  1200 ;+
                                     004E  1300 ; Loop to free up each descriptor
                                     004E  1400 ;-
                                     004E  1500 
            50            54     D0  004E  1600 5$:	MOVL	R4, R0			; R0 = Adr. of descriptor to free
                          CB     10  0051  1700 	BSBB	LIB$SFREE1_DD6		; go free one string
                                     0053  1800 					; Note: SFREE1_DD6 does not use R4, R5
            54            08     C0  0053  1900 	ADDL	#8, R4			; step to next descriptor
            F5            53     F5  0056  2000 	SOBGTR	R3, 5$			; loop till done
                                     0059  2100 
            50            01     D0  0059  2200 10$:	MOVL	#SS$_NORMAL, R0		; R0 = success
                                 05  005C  2300 	RSB				; return
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page   9
0-33            LIB$SCOPY_DXDX - Copy any class string to any c                                                                  (9)

                                     005D   100 	.SBTTL	LIB$SCOPY_DXDX - Copy any class string to any class string
                                     005D   200 ;++
                                     005D   300 ; FUNCTIONAL DESCRIPTION:
                                     005D   400 ; 
                                     005D   500 ;	LIB$SCOPY_DXDX copies a source  string  of  any
                                     005D   600 ;	class  to  a  destination  string of any class.  Depending on the
                                     005D   700 ;	contents of the class  field  (DSC$B_CLASS)  of  the  destination
                                     005D   800 ;	descriptor the following actions take place:
                                     005D   900 ; 
                                     005D  1000 ;	        DSC$B_CLASS      Action.
                                     005D  1100 ; 
                                     005D  1200 ;	        DSC$K_CLASS_S,Z  Copy source string  and  space  fill  if
                                     005D  1300 ;	                         needed or truncate on right.
                                     005D  1400 ; 
                                     005D  1500 ;	        DSC$K_CLASS_V    Copy source  string  and  source  length
                                     005D  1600 ;	                         field   (DSC$W_LENGTH)   to  destination
                                     005D  1700 ;	                         descriptor.   Do  not   exceed   maximum
                                     005D  1800 ;	                         length  (DSC$W_MAXLEN)  specified in the
                                     005D  1900 ;	                         destination descriptor.
                                     005D  2000 ; 
                                     005D  2100 ;	        DSC$K_CLASS_D    Call LIB$SCOPY_DXDD.
                                     005D  2200 ; 
                                     005D  2300 ;	        This routine or its equivalent is used  by  higher  level
                                     005D  2400 ;	        languages to write formal parameter strings.
                                     005D  2500 ; 
                                     005D  2600 ; CALLING SEQUENCE:
                                     005D  2700 ; 
                                     005D  2800 ;	Ret_status = LIB$SCOPY_DXDX (src_str.rt.dx, dst_str.wt.dx)
                                     005D  2900 ;		JSB	LIB$SCOPY_DXDX6 (src_str.rt.dx, dst_str.wt.dx)
                                     005D  3000 ; 
                                     005D  3100 ; INPUT PARAMETERS:
                                     005D  3200 ; 
                           00000004  005D  3300 	SRC_STR = 4	; Adr. of source string descriptor
                                     005D  3400 ;	     src_str  is the address  of  the  source  string  descriptor
                                     005D  3500 ;	             describing  the  length and address of the string to
                                     005D  3600 ;	             be copied.  The descriptor class may be  unspecified
                                     005D  3700 ;	             (z),  static  (s),  varying  (v),  or  dynamic  (d),
                                     005D  3800 ;	             although it is not checked.
                                     005D  3900 ; 
                           00000008  005D  4000 	DST_STR = 8	; Adr. of destination string descriptor
                                     005D  4100 ;	     dst_str is the address of the destination string descriptor.
                                     005D  4200 ;	             The  class  field (DSC$B_CLASS) is used to determine
                                     005D  4300 ;	             the appropriate action.
                                     005D  4400 ; 
                                     005D  4500 ; OUTPUT PARAMETERS:
                                     005D  4600 ; 
                                     005D  4700 ;	     dst_str is the address of the destination string descriptor.
                                     005D  4800 ;	             Depending   on   its   class   field,   the   length
                                     005D  4900 ;	             (DSC$W_LENGTH) or both the length  and  the  address
                                     005D  5000 ;	             (DSC$A_POINTER) fields may be modified.
                                     005D  5100 ; 
                                     005D  5200 ; IMPLICIT OUTPUTS:
                                     005D  5300 ; 
                                     005D  5400 ;	None.
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  10
0-33            LIB$SCOPY_DXDX - Copy any class string to any c                                                                 (10)

                                     005D   100 ; 
                                     005D   200 ; COMPLETION STATUS:
                                     005D   300 ; 
                                     005D   400 ;   Success codes:
                                     005D   500 ;	SS$_NORMAL if source string fit in static, varying or dynamic destination string
                                     005D   600 ;	or space allocated successfully (dynamic only).
                                     005D   700 ;	LIB$_STRTRU (STRING TRUNCATED) if source string was truncated
                                     005D   800 ;	in order to fit in static or varying string.
                                     005D   900 ;   Error codes:
                                     005D  1000 ;	LIB$_INSVIRMEM  ('INSUFFICIENT  VIRTUAL MEMORY') if the destination string
                                     005D  1100 ;	and there was not 
                                     005D  1200 ;	enough virtual memory  from  the  operating  system;   otherwise,
                                     005D  1300 ;	string space may be allocated if the space already alocated
                                     005D  1400 ;	to the destination string is not sufficient.
                                     005D  1500 ;	LIB$_INVSTRDES (INVALID STRING DESCRIPTOR) 
                                     005D  1600 ;	if the destination string descritpor is not one of
                                     005D  1700 ;	the standardized ones as indicated by its DSC$CLASS field.
                                     005D  1800 ;
                                     005D  1900 ; SIDE EFFECTS:
                                     005D  2000 ;
                                     005D  2100 ;	None.
                                     005D  2200 ;--
                                     005D  2300 
                                     005D  2400 
                                     005D  2500 
                               407C' 005D  2600 	.ENTRY	LIB$SCOPY_DXDX, ^M<IV, R2, R3, R4, R5, R6>		; entry point and entry mask
                                     005F  2700 					; enable integer overflow
                                     005F  2800 
            50         04 BC     7D  005F  2900 	MOVQ	@SRC_STR(AP), R0	; R0<15:0> = len, R1 = adr. of src 
            52         08 AC     D0  0063  3000 	MOVL	DST_STR(AP), R2		; R2 = Adr. of dest. str descr.
                          16     10  0067  3100 	BSBB	LIB$SCOPY_R_DX6		; call JSB routine to copy source to dest.
                                 04  0069  3200 	RET				; return to caller
                                     006A  3300 
                                     006A  3400 LIB$SCOPY_DXDX6::			; JSB entry point
            52            51     D0  006A  3500 	MOVL	R1, R2			; R2 = adr. of dst. desc.
            50            60     7D  006D  3600 	MOVQ	(R0), R0		; R0<15:0> = len, R1 = adr. of src
                          0D     11  0070  3700 	BRB	LIB$SCOPY_R_DX6		; call SCOPY and return with RSB
                                     0072  3800 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  11
0-33            LIB$SCOPY_R_DX - Copy any class string to any c                                                                 (11)

                                     0072   100 	.SBTTL	LIB$SCOPY_R_DX - Copy any class string to any class string
                                     0072   200 
                                     0072   300 ;++
                                     0072   400 
                                     0072   500 ;++
                                     0072   600 ; FUNCTIONAL DESCRIPTION:
                                     0072   700 ; 
                                     0072   800 ;	LIB$SCOPY_R_DX is similar to LIB$SCOPY_DXDX.
                                     0072   900 ;	The only difference is that they accept the source string as two
                                     0072  1000 ;	separate arguments instead of as a descriptor.  They are provided
                                     0072  1100 ;	expressly for the purpose of making it easy for a procedure to return
                                     0072  1200 ;	a string to its caller by descriptor, even though the procedure
                                     0072  1300 ;	may not have the source string represented using a descriptor.
                                     0072  1400 ;	Thus the source string is passed by reference with a character
                                     0072  1500 ;	count instead of by-descriptor.
                                     0072  1600 ;	LIB$SCOPY_R_DX copies a source  string  of  any
                                     0072  1700 ;	class  to  a  destination  string of any class.  Depending on the
                                     0072  1800 ;	contents of the class  field  (DSC$B_CLASS)  of  the  destination
                                     0072  1900 ;	descriptor the following actions take place:
                                     0072  2000 ; 
                                     0072  2100 ;	        DSC$B_CLASS      Action.
                                     0072  2200 ; 
                                     0072  2300 ;	        DSC$K_CLASS_S,Z  Copy source string  and  space  fill  if
                                     0072  2400 ;	                         needed or truncate on right.
                                     0072  2500 ; 
                                     0072  2600 ;	        DSC$K_CLASS_V    Copy source  string  and  source  length
                                     0072  2700 ;	                         field   (DSC$W_LENGTH)   to  destination
                                     0072  2800 ;	                         descriptor.   Do  not   exceed   maximum
                                     0072  2900 ;	                         length  (DSC$W_MAXLEN)  specified in the
                                     0072  3000 ;	                         destination descriptor.
                                     0072  3100 ; 
                                     0072  3200 ;	        DSC$K_CLASS_D    Call LIB$SCOPY_R_DD.
                                     0072  3300 ; 
                                     0072  3400 ;	        This routine or its equivalent is used  by  higher  level
                                     0072  3500 ;	        languages to write formal parameter strings.
                                     0072  3600 ; 
                                     0072  3700 ; CALLING SEQUENCE:
                                     0072  3800 ; 
                                     0072  3900 ;	comp_code = LIB$SCOPY_R_DX (src_str_len.rw.r, src_str_adr.rt.r,
                                     0072  4000 ;					dst_str.wt.dx)
                                     0072  4100 ;		JSB LIB$SCOPY_R_DX6 (src_str_len.rw.v, src_str_adr.rt.r,
                                     0072  4200 ;					dst_str.wt.dx)
                                     0072  4300 ; 
                                     0072  4400 ; INPUT PARAMETERS:
                                     0072  4500 ; 
                           00000004  0072  4600 	SRC_STR_LEN = 4			; Length of source string 
                                     0072  4700 ;	    src_str_len is the address of a word containing the length of the 
                                     0072  4800 ;			source string to be copied
                           00000008  0072  4900 	SRC_STR_ADR = 8			; Adr. of source string
                                     0072  5000 ;	     src_str_adr  is the address  of  the  source  string  to
                                     0072  5100 ;	             be copied.  
                           0000000C  0072  5200 	DST_STR = 12			; Adr. of destination string descriptor
                                     0072  5300 ;	     dst_str is the address of the destination string descriptor.
                                     0072  5400 ;	             The  class  field (DSC$B_CLASS) is used to determine
                                     0072  5500 ;	             the appropriate action.
                                     0072  5600 ; 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  12
0-33            LIB$SCOPY_R_DX - Copy any class string to any c                                                                 (12)

                                     0072   100 ; OUTPUT PARAMETERS:
                                     0072   200 ; 
                                     0072   300 ;	     dst_str is the address of the destination string descriptor.
                                     0072   400 ;	             Depending   on   its   class   field,   the   length
                                     0072   500 ;	             (DSC$W_LENGTH) or both the length  and  the  address
                                     0072   600 ;	             (DSC$A_POINTER) fields may be modified.
                                     0072   700 ; 
                                     0072   800 ; IMPLICIT OUTPUTS:
                                     0072   900 ; 
                                     0072  1000 ;	None.
                                     0072  1100 ; 
                                     0072  1200 ; COMPLETION STATUS:
                                     0072  1300 ; 
                                     0072  1400 ;   Success codes:
                                     0072  1500 ;	SS$_NORMAL if source string fit in static, varying or dynamic destination string
                                     0072  1600 ;	or space allocated successfully (dynamic only).
                                     0072  1700 ;	LIB$_STRTRU (STRING TRUNCATED) if source string was truncated
                                     0072  1800 ;	in order to fit in static or varying string.
                                     0072  1900 ;   Error codes:
                                     0072  2000 ;	LIB$_INSVIRMEM  ('INSUFFICIENT  VIRTUAL MEMORY') if the destination string
                                     0072  2100 ;	and there was not 
                                     0072  2200 ;	enough virtual memory  from  the  operating  system;   otherwise,
                                     0072  2300 ;	string space may be allocated if the space already alocated
                                     0072  2400 ;	to the destination string is not sufficient.
                                     0072  2500 ;	LIB$_INVSTRDES (INVALID STRING DESCRIPTOR) 
                                     0072  2600 ;	if the destination string descritpor is not one of
                                     0072  2700 ;	the standardized ones as indicated by its DSC$CLASS field.
                                     0072  2800 ;
                                     0072  2900 ; SIDE EFFECTS:
                                     0072  3000 ;
                                     0072  3100 ;	None.
                                     0072  3200 ;--
                                     0072  3300 
                                     0072  3400 
                                     0072  3500 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  13
0-33            LIB$SCOPY_R_DX - Copy any class string to any c                                                                 (13)

                               407C' 0072   100 	.ENTRY	LIB$SCOPY_R_DX, ^M<IV, R2, R3, R4, R5, R6>		; entry point and entry mask
                                     0074   200 					; enable integer overflow
                                     0074   300 
            50         04 BC     B0  0074   400 	MOVW	@SRC_STR_LEN(AP), R0	; R0<15:0> = src str len
            51         08 AC     7D  0078   500 	MOVQ	SRC_STR_ADR(AP), R1	; R1 = src str adr
                                     007C   600 					; R2 = adr of dest str descr.
                          01     10  007C   700 	BSBB	LIB$SCOPY_R_DX6		; call JSB routine to do copy
                                 04  007E   800 	RET
                                     007F   900 
                                     007F  1000 
                                     007F  1100 LIB$SCOPY_R_DX6::			; source string by adr + count
                                     007F  1200 
                                     007F  1300 
                                     007F  1400 ;+
                                     007F  1500 ; Dispatch on class code of destination descriptor
                                     007F  1600 ;-
                                     007F  1700 
            00         03 A2     8F  007F  1800 	CASEB	DSC$B_CLASS(R2), #DSC$K_CLASS_Z, #DSC$K_CLASS_V
                          03         0083       
                               0010' 0084  1900 10$:	.WORD	Z_TYPE-10$		; unspecified - space fill
                               0010' 0086  2000 	.WORD	S_TYPE-10$		; static class - space fill
                               0025' 0088  2100 	.WORD	LIB$$SCOPY_RDD6-10$	; dynamic - allocate if necessary
                               0008' 008A  2200 	.WORD	V_TYPE-10$		; Varying
                                     008C  2300 					; OUTRANGE here
                                     008C  2400 
                                     008C  2500 V_TYPE:					; varying - not implemented yet
                                     008C  2600 					; Other values in descriptor here too
            50   00000000'8F     D0  008C  2700 	MOVL	#LIB$_INVSTRDES, R0	; R0 = VAX-11 error code 
                                     0093  2800 					; (INVALID STRING DESCRIPTOR)
                                 05  0093  2900 	RSB				; return with error status
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  14
0-33            LIB$SCOPY_R_DX - Copy any class string to any c                                                                 (14)

                                     0094   100 ;+
                                     0094   200 ; Unspecified descriptor or static descriptor
                                     0094   300 ; Copy string and fill with trailing spaces if necessary
                                     0094   400 ;-
                                     0094   500 
                                     0094   600 Z_TYPE:					; unspecified descriptor (0)
                                     0094   700 S_TYPE:					; fixed length
                          50     2C  0094   800 	MOVC5	R0, -			; source length
            20            61         0096   900 		(R1), -			; source adr.
         04 B2            62         0098       
                                     009B  1000 		#^A' ', -		; fill is space
                                     009B  1100 		DSC$W_LENGTH(R2), -	; dest. length
                                     009B  1200 		@DSC$A_POINTER(R2)	; dest. adr.
                          04     1A  009B  1300 	BGTRU	10$			; compare source length with dest. 
            50            01     D0  009D  1400 	MOVL	#SS$_NORMAL, R0		; R0 = source equal to or less than dest.
                                 05  00A0  1500 	RSB				; return
                                     00A1  1600 
            50   00000000'8F     D0  00A1  1700 10$:	MOVL	#LIB$_STRTRU, R0	; R0 = STRING TRUNCATED
                                     00A8  1800 					; success code
                                 05  00A8  1900 	RSB				; return
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  15
0-33            LIB$SCOPY_DXDD - Copy any class string to dynam                                                                 (15)

                                     00A9   100 	.SBTTL	LIB$SCOPY_DXDD - Copy any class string to dynamic class string
                                     00A9   200 ;++
                                     00A9   300 ; FUNCTIONAL DESCRIPTION:
                                     00A9   400 ; 
                                     00A9   500 ;	LIB$SCOPY_DXDD copies a source  string  of  any
                                     00A9   600 ;	class  to  a  destination  string of  dynamic class.
                                     00A9   700 ;
                                     00A9   800 ; CALLING SEQUENCE:
                                     00A9   900 ;
                                     00A9  1000 ;	Ret_status = LIB$SCOPY_DXDD (src_str.rt.dx, dst_str.wt.dd)
                                     00A9  1100 ;		JSB	LIB$SCOPY_DXDD6 (src_str.rt.dx, dst_str.wt.dd)
                                     00A9  1200 ; 
                                     00A9  1300 ; INPUT PARAMETERS:
                                     00A9  1400 ; 
                           00000004  00A9  1500 	SRC_STR = 4	; Adr. of source string descriptor
                                     00A9  1600 ;	     src_str  is the address  of  the  source  string  descriptor
                                     00A9  1700 ;	             describing  the  length and address of the string to
                                     00A9  1800 ;	             be copied.  The descriptor class may be  unspecified
                                     00A9  1900 ;	             (z),  static  (s),  varying  (v),  or  dynamic  (d),
                                     00A9  2000 ;	             although it is not checked.
                                     00A9  2100 ; 
                           00000008  00A9  2200 	DST_STR = 8	; Adr. of destination string descriptor
                                     00A9  2300 ;	     dst_str is the address of the destination string descriptor.
                                     00A9  2400 ;		     The class is assumed to be dynamic.
                                     00A9  2500 ; 
                                     00A9  2600 ; OUTPUT PARAMETERS:
                                     00A9  2700 ; 
                                     00A9  2800 ;	     dst_str is the address of the destination string descriptor.
                                     00A9  2900 ;	             The length (DSC$W_LENGTH) or both the length  and  the  address
                                     00A9  3000 ;	             (DSC$A_POINTER) fields may be modified.
                                     00A9  3100 ; 
                                     00A9  3200 ; IMPLICIT OUTPUTS:
                                     00A9  3300 ; 
                                     00A9  3400 ;	None.
                                     00A9  3500 ; 
                                     00A9  3600 ; COMPLETION STATUS:
                                     00A9  3700 ; 
                                     00A9  3800 ;   Success codes:
                                     00A9  3900 ;	SS$_NORMAL if source string fit in dynamic destination string
                                     00A9  4000 ;	or space allocated successfully.
                                     00A9  4100 ;   Error codes:
                                     00A9  4200 ;	LIB$_INSVIRMEM  ('INSUFFICIENT  VIRTUAL MEMORY') if the destination string
                                     00A9  4300 ;	require storage to be allocated and there was not 
                                     00A9  4400 ;	enough virtual memory  from  the  operating  system;   otherwise,
                                     00A9  4500 ;	string space may be allocated if the space already alocated
                                     00A9  4600 ;	to the destination string is not sufficient.
                                     00A9  4700 ;
                                     00A9  4800 ; SIDE EFFECTS:
                                     00A9  4900 ;
                                     00A9  5000 ;	Allocates dynamic string memory which is heap storage.
                                     00A9  5100 ;--
                                     00A9  5200 
                                     00A9  5300 
                                     00A9  5400 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  16
0-33            LIB$SCOPY_DXDD - Copy any class string to dynam                                                                 (16)

                                     00A9    10 ;+
                                     00A9    20 ;*********************************************************************
                                     00A9    30 ; NOT IMPLEMENTED BECAUSE NOT IN RELEASE 1.0 MANUAL
                                     00A9    40 ;*********************************************************************
                                     00A9   100 ;	.ENTRY	LIB$SCOPY_DXDD, ^M<IV, R2, R3, R4, R5, R6>		; entry point and entry mask
                                     00A9   200 ;					; enable integer overflow
                                     00A9   300 ;
                                     00A9   400 ;	MOVQ	@SRC_STR(AP), R0	; R0<15:0> = len of src str
                                     00A9   500 ;					; R1 = Adr. of dest. str descr.
                                     00A9   600 ;	MOVL	DST_STR(AP), R2		; R2 = adr. of dst descriptor
                                     00A9   700 ;	BSBB	LIB$SCOPY_R_DD6		; call JSB routine to copy source to dest.
                                     00A9   800 ;	RET				; return to caller
                                     00A9   900 ;
                                     00A9  1000 ;LIB$SCOPY_DXDD6::
                                     00A9  1100 ;	MOVL	R1, R2			; R2 = adr. of dst. desc.
                                     00A9  1200 ;	MOVQ	(R0), R0		; R0<15:0> = len, R1 = adr. of src
                                     00A9  1300 ;	BRB	LIB$SCOPY_DXDD6		; call SCOPY and return with RSB
                                     00A9  1400 ;
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  17
0-33            LIB$$SCOPY_RDD6 - Internal JSB routine to copy                                                                  (17)

                                     00A9   100 	.SBTTL	LIB$$SCOPY_RDD6 - Internal JSB routine to copy any class string to dynamic c
                                     00A9   200 ;++
                                     00A9   300 ; FUNCTIONAL DESCRIPTION:
                                     00A9   400 ; 
                                     00A9   500 ;	LIB$$SCOPY_RDD6 copies a source  string  passed by-reference
                                     00A9   600 ;	class  to  a  destination  string of  dynamic class.
                                     00A9   700 ;
                                     00A9   800 ; CALLING SEQUENCE:
                                     00A9   900 ;
                                     00A9  1100 ;		JSB	LIB$$SCOPY_RDD6 (src_str.rt.dx, dst_str.wt.dd)
                                     00A9  1200 ; 
                                     00A9  1300 ; INPUT PARAMETERS:
                                     00A9  1400 ; 
                           00000004  00A9  1500 	SRC_STR_LEN = 4	; Adr. of word containing source string length
                                     00A9  1600 ; 
                           00000008  00A9  1700 	SRC_STR_ADR = 8	; Adr. of source string
                           0000000C  00A9  1800 	DST_STR = 12	; Adr. of destination string descriptor
                                     00A9  1900 ;		     The class is assumed to be dynamic.
                                     00A9  2000 ; 
                                     00A9  2100 ; OUTPUT PARAMETERS:
                                     00A9  2200 ; 
                                     00A9  2300 ;	     dst_str is the address of the destination string descriptor.
                                     00A9  2400 ;	             The length (DSC$W_LENGTH) or both the length  and  the  address
                                     00A9  2500 ;	             (DSC$A_POINTER) fields may be modified.
                                     00A9  2600 ; 
                                     00A9  2700 ; IMPLICIT OUTPUTS:
                                     00A9  2800 ; 
                                     00A9  2900 ;	None.
                                     00A9  3000 ; 
                                     00A9  3100 ; COMPLETION STATUS:
                                     00A9  3200 ; 
                                     00A9  3300 ;   Success codes:
                                     00A9  3400 ;	SS$_NORMAL if source string fit in dynamic destination string
                                     00A9  3500 ;	or space allocated successfully.
                                     00A9  3600 ;   Error codes:
                                     00A9  3700 ;	LIB$_INSVIRMEM  ('INSUFFICIENT  VIRTUAL MEMORY') if the destination string
                                     00A9  3800 ;	require storage to be allocated and there was not 
                                     00A9  3900 ;	enough virtual memory  from  the  operating  system;   otherwise,
                                     00A9  4000 ;	string space may be allocated if the space already alocated
                                     00A9  4100 ;	to the destination string is not sufficient.
                                     00A9  4200 ;
                                     00A9  4300 ; SIDE EFFECTS:
                                     00A9  4400 ;
                                     00A9  4500 ;	Allocates dynamic string memory which is heap storage.
                                     00A9  4600 ;--
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  18
0-33            LIB$$SCOPY_RDD6 - Internal JSB routine to copy                                                                  (18)

                                     00A9   100 ;+
                                     00A9   200 ; Description of string allocation algorithm
                                     00A9   300 ;
                                     00A9   400 ; The following steps are carefully ordered so that ASTs can occur
                                     00A9   500 ; at any time and re-enter this module.  The string areas will never
                                     00A9   600 ; become corrupted.  Only if the user attempts to access the same string at
                                     00A9   700 ; AST and non-AST levels may he get an incomplete string, but that's
                                     00A9   800 ; his bug (the data base is still maintained intact).
                                     00A9   900 ;
                                     00A9  1000 ; If dst doesn't have any space yet --------------> |    |
                                     00A9  1100 ; If dst has more than K_MAX_SIZ_STR bytes --> !    !    !
                                     00A9  1200 ; If src will fit in dst ---------------> !    !    !    !
                                     00A9  1300 ; Allocate enough for src 	     !Q,VM!    !Q,VM!Q,VM!
                                     00A9  1400 ; Set size in control block	     ! x  !    ! x  ! x  !
                                     00A9  1500 ; store dst len in dst descr.        ! x  ! x  ! x  ! x  !
                                     00A9  1600 ; copy string			     ! x  ! x  ! x  ! x  !
                                     00A9  1700 ; store adr. of new str in dst descr.! x  !    ! x  ! x  !
                                     00A9  1800 ; return old dst to free storage     ! Q  !    ! VM !    !
                                     00A9  1900 ;
                                     00A9  2000 ; where Q means use fast Q mechanism, and VM means use LIB$GET_VM/LIB$FREE_VM
                                     00A9  2100 ;
                                     00A9  2200 ; REGISTER USAGE:
                                     00A9  2300 ;
                                     00A9  2400 ;	R0<15:0> length of source string to be copied
                                     00A9  2500 ;	R1	adr. of source string
                                     00A9  2600 ;	R2	adr. of destination string descriptor
                                     00A9  2700 ;	R3	adr. of new destination control block string area (=adr to copy string to)
                                     00A9  2800 ;		That is, the control block header has a negative offset form R3
                                     00A9  2900 ;		Also used as counter by LIB$SFREEN
                                     00A9  3000 ;	R4	scratch used by ALLOC_N_COPY_R5 routine
                                     00A9  3100 ;		Also used as step address by LIB$SFREEN.
                                     00A9  3200 ;	R5	no. of bytes to actually copy (set to 0 for SGET calls)
                                     00A9  3300 ;	R6	adr. of string area in old destination control block or 0
                                     00A9  3400 ;		(control block header is negative offset)
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  19
0-33            LIB$$SCOPY_RDD6 - Internal JSB routine to copy                                                                  (19)

                                     00A9    10 ;+
                                     00A9    20 ;*************************************************************
                                     00A9    30 ; Not global because not in release 1.0 manual.
                                     00A9    40 ;
                                     00A9   100 ;	.ENTRY	LIB$SCOPY_R_DD, ^M<IV, R2, R3, R4, R5, R6>		; entry point and entry mask
                                     00A9   200 ;					; enable integer overflow
                                     00A9   300 ;
                                     00A9   400 ;	MOVW	@SRC_STR_LEN(AP), R0	; R0<15:0> = src str len
                                     00A9   500 ;	MOVQ	SRC_STR_ADR(AP), R1	; R1 = src str adr
                                     00A9   600 ;					; R2 = adr of dest str descr.
                                     00A9   700 ;	BSBB	LIB$SCOPY_R_DD6		; call JSB routine to do copy
                                     00A9   800 ;	RET
                                     00A9   810 ;*****************************************************************
                                     00A9   820 ;-
                                     00A9   900 
                                     00A9  1000 LIB$$SCOPY_RDD6::			; source string by adr + count
            55            50     B0  00A9  1100 	MOVW	R0, R5			; R5 = no. of characters to copy
                                     00AC  1200 SGET1:					; enter here to get without copy, R5 = 0
            56         04 A2     D0  00AC  1300 	MOVL	DSC$A_POINTER(R2), R6	; R6 = adr. of old dest. string area
                          54     13  00B0  1400 	BEQL	ALLOC_N_COPY_R5		; branch if dst has not been allocated yet
                                     00B2  1500 					; and RSB to caller.
       00EA 8F         FE A6     B1  00B2  1600 	CMPW	DSB$W_ALLOC_LEN(R6), -	; is  old dest. string area small enough
                                     00B8  1700 		#K_MAX_SIZ_STR		; to be in fast Q?
                          12     1A  00B8  1800 	BGTRU	BIG_OLD_DST		; branch if too big for fast Qs
         FE A6            50     B1  00BA  1900 	CMPW	R0, DSB$W_ALLOC_LEN(R6)	; will src fit in old dst area?
                          31     1A  00BE  2000 	BGTRU	SRC_WONT_FIT		; branch if src won't fit
            62            50     B0  00C0  2100 	MOVW	R0, DSC$W_LENGTH(R2)	; fits, set dst len in dst descr.
            61            55     28  00C3  2200 	MOVC3	R5, (R1), -		; copy src string to dst area
                       04 B2         00C6       
                                     00C8  2300 		@DSC$A_POINTER(R2)	; (or NOP if R5=0 from SGET1)
            50            01     D0  00C8  2400 	MOVL	#SS$_NORMAL, R0		; indicate success
                                 05  00CB  2500 	RSB				; return, R1:R4 from MOVC3
                                     00CC  2600 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  20
0-33            LIB$$SCOPY_RDD6 - Internal JSB routine to copy                                                                  (20)

                                     00CC   100 ;+
                                     00CC   200 ; Here if old dst area is too big to be handled by fast Q algorithm.
                                     00CC   300 ; Allocate area, set dst descriptor, and copy.
                                     00CC   400 ; Then deallocate old destination area using slower alogrithm.
                                     00CC   500 ; Note: always allocate and deallocate if old area not in Q, so
                                     00CC   600 ; never attempt to reuse old (big) area for a new (small) string
                                     00CC   700 ; which might waste a lot of space for a long time.
                                     00CC   800 ;-
                                     00CC   900 
                                     00CC  1000 BIG_OLD_DST:				; here if old dst is bigger than Q sizes
                          38     10  00CC  1100 	BSBB	ALLOC_N_COPY_R5		; allocate area, set dst descr. and copy
            1F            50     E9  00CE  1200 	BLBC	R0, RSB1		; return, if error
                                     00D1  1300 FREE_BIG_DST:				; enter here from LIB$SFREE1
                                     00D1  1400 					; (R3:R4 not used)
                          51     DD  00D1  1500 	PUSHL	R1			; save R1 (last adr+1 of source)
            56            02     C3  00D3  1600 	SUBL3	#DSB$K_HED_LEN, R6, -	; 2nd arg = adr. of header of  area
                                     00D6       
                          7E         00D6  1700 		-(SP)			;
            50         FE A6     3C  00D7  1800 	MOVZWL	DSB$W_ALLOC_LEN(R6), R0 ; R0 = size of area not counting
                                     00DB  1900 					; control block header
            50            02     C1  00DB  2000 	ADDL3	#DSB$K_HED_LEN, R0, -	; 1st arg = total size of area
                                     00DE       
                          7E         00DE  2100 		-(SP)			; including control block header
                       04 AE     DF  00DF  2200 	PUSHAL	4(SP)			; adr of 2nd arg
                       04 AE     DF  00E2  2300 	PUSHAL	4(SP)			; adr of 1st arg
       0000'CF            02     FB  00E5  2400 	CALLS	#2, W^LIB$FREE_VM	; deallocate old area
                                     00EA  2500 					; R0 = return status
            5E            08     C0  00EA  2600 	ADDL	#8, SP			; clean up stack
            51            8E     D0  00ED  2700 	MOVL	(SP)+, R1		; restore R1
                                 05  00F0  2800 RSB1:	RSB				; return, R1:R4 from MOVC3
                                     00F1  2900 
                                     00F1  3000 ;+
                                     00F1  3100 ; Here if src is greater than dst area but dst small enough to be in Qs
                                     00F1  3200 ; Allocate area, set dst descriptor, and copy.
                                     00F1  3300 ; Then deallocate old destination area using fast Q algorithm.
                                     00F1  3400 ; Deallocate after copy so that works with ASTs enabled.
                                     00F1  3500 ;-
                                     00F1  3600 
                                     00F1  3700 SRC_WONT_FIT:
                          13     10  00F1  3800 	BSBB	ALLOC_N_COPY_R5		; allocate area, set dst descr. and copy
            0F            50     E9  00F3  3900 	BLBC	R0, RSB2		; return, if error
                                     00F6  4000 FREE_SMALL_DST:				; enter here from LIB$SFREE1
                                     00F6  4100 					; (R3:R4 not used)
            55         FE A6     3C  00F6  4200 	MOVZWL	DSB$W_ALLOC_LEN(R6), R5	; R5 = size of old allocated area
                                     00FA  4300 					; not counting control block header
                          66     0E  00FA  4400 	INSQUE	(R6), -
                 FFFFFFFE'EF45       00FC  4500 		Q_HED-K_RESIDUE[R5]	; insert at front of proper Q
            50            01     D0  0102  4600 	MOVL	#SS$_NORMAL, R0		; R0 = success
                                 05  0105  4700 RSB2:	RSB				; return, R1:R4 from MOVC3
                                     0106  4800 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  21
0-33            ALLOC_N_COPY_R5 - Allocate, set dst descr., and                                                                 (21)

                                     0106   100 	.SBTTL	ALLOC_N_COPY_R5 - Allocate, set dst descr., and copy
                                     0106   200 
                                     0106   300 ;+
                                     0106   400 ; Inputs:
                                     0106   500 ;
                                     0106   600 ;	R0 = size of source string to copy (not counting header)
                                     0106   700 ;	R1 = contains adr of src string
                                     0106   800 ;	R2 = adr. of dst descrpitor
                                     0106   900 ;	R5 = No. of bytes to copy (can be different from R0 if from SGET1)
                                     0106  1000 ;
                                     0106  1100 ; Output:
                                     0106  1200 ;
                                     0106  1300 ;	R0 = success or failure completion status (SS$_ or LIB$_)
                                     0106  1400 ;	R1:R5 from MOVC3
                                     0106  1500 ;
                                     0106  1600 ; Does not use R6
                                     0106  1700 ;-
                                     0106  1800 
                                     0106  1900 ALLOC_N_COPY_R5:			; Local JSB routine
       00EA 8F            50     B1  0106  2000 	CMPW	R0, #K_MAX_SIZ_STR	; can this size fit fast Qs?
                          48     1A  010B  2100 	BGTRU	GET_VM_LARGE		; branch, if too big
   000000F0'EF            00     E3  010D  2200 	BBCS	#0, FIRST_TIME, 10$	; is this the first time ever?
                          27         0114       
                                     0115  2300 5$:					; jump back here after init. Qs
                          05     A1  0115  2400 	ADDW3	#<K_ALLOC_QUANTA - K_RESIDUE - 1>, - 
            54            50         0117  2500 		R0, R4			; R4 = max. size-1 including header
                 FFFF0007 8F     CA  0119  2600 	BICL	#<<^XFFFF0000>+<K_ALLOC_QUANTA-1>>, -
                          54         011F  2700 		R4			; truncate and clear R4<lh>
                                     0120  2800 					; R4 = n*K_ALLOC_QUANTA, N = 0,1,2...
            53   00000000'EF44   9E  0120  2850 	MOVAB	Q_HED[R4], R3		; R3 = adr. of proper Q header
            53            93     0F  0128  2900 	REMQUE	@(R3)+, R3		; R3 = adr. of allocated area
                                     012B  2950 					; remove from front of proper Q
                          5A     1D  012B  3000 	BVS	GET_VM_SMALL		; branch if this Q empty
            62            50     B0  012D  3100 	MOVW	R0, DSC$W_LENGTH(R2)	; store actual string length
                                     0130  3200 					; in dst. descriptor
         04 A2            53     D0  0130  3300 	MOVL	R3, DSC$A_POINTER(R2)	; store adr. of allocated control block
                                     0134  3400 					; in dst. descriptor
            61            55     28  0134  3500 	MOVC3	R5, (R1), (R3)		; copy string (or NOP if R5 = 0 from SGET1)
                          63         0137       
            50            01     D0  0138  3600 	MOVL	#SS$_NORMAL, R0		; R0 = success
                                 05  013B  3700 	RSB				; return, R1:R5 set from MOVC3
                                     013C  3800 
                                     013C  3900 ;+
                                     013C  4000 ; Here to make empty Q's the first time
                                     013C  4100 ;-
                                     013C  4200 
            53   00000000'EF     7E  013C  4300 10$:	MOVAQ	Q_HED, R3		; R3 = adr. for first Q
            54            1E     D0  0143  4400 	MOVL	#K_NO_FAST_QS, R4	; R4 = no. of Q's
                                     0146  4500 
                                     0146  4600 ;+
                                     0146  4700 ; Loop to init each Q header to point to itself
                                     0146  4800 ;-
                                     0146  4900 
            63            53     D0  0146  5000 20$:	MOVL	R3, (R3)		; make empty Q forward link
         04 A3            53     D0  0149  5100 	MOVL	R3, 4(R3)		; make empty Q backward link
            53            08     C0  014D  5200 	ADDL	#8, R3			; step to next Q header
            F3            54     F5  0150  5300 	SOBGTR	R4, 20$			; loop until done
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  22
0-33            ALLOC_N_COPY_R5 - Allocate, set dst descr., and                                                                 (21)

                          C0     11  0153  5400 	BRB	5$			; go back and continue
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  23
0-33            ALLOC_N_COPY_R5 - Allocate, set dst descr., and                                                                 (22)

                                     0155  5600 ;+
                                     0155  5700 ; Here to allocate storage for a big string using slower algorithm
                                     0155  5800 ; Only allocate one string of this size.
                                     0155  5900 ;-
                                     0155  6000 
                                     0155  6100 GET_VM_LARGE:
            50            02     A1  0155  6200 	ADDW3	#DSB$K_HED_LEN, R0, R4	; R4<15:0> = total # bytes to allocate 
                          54         0158       
                                     0159  6300 					; including header
            5E            04     C2  0159  6400 	SUBL	#4, SP			; make local variable to receive 2nd arg
                          13     BB  015C  6500 	PUSHR	#<^M<R0, R1, R4>>	; save R0, R1, make call-by-ref R4
            7E         0C AE     DE  015E  6600 	MOVAL	12(SP), -(SP)		; 2nd arg = adr. of longword to receive
                                     0162  6700 					; adr of allocated area
            7E         0C AE     DE  0162  6800 	MOVAL	12(SP), -(SP)		; 1st arg = adr of longword containing # bytes
       0000'CF            02     FB  0166  6900 	CALLS	#2, W^LIB$GET_VM		; allocate virtual memory
            15            50     E9  016B  7000 	BLBC	R0, 10$			; branch if error
                          1B     BA  016E  7100 	POPR	#<^M<R0, R1, R3, R4>>	; R0 = src length
                                     0170  7200 					; R1 = src adr
                                     0170  7300 					; R3 = total bytes allocated (including header)
                                     0170  7400 					; R4 = adr. of allocated area
            53            02     A3  0170  7500 	SUBW3	#DSB$K_HED_LEN, R3, -	; store length of string in header
                                     0173       
                          84         0173  7600 		(R4)+			; R3 = adr. of string in control block
         04 A2            54     D0  0174  7700 	MOVL	R4, DSC$A_POINTER(R2)	; set dst descriptor to allocated area
            62            50     B0  0178  7800 	MOVW	R0, DSC$W_LENGTH(R2)	; set dst desc. to new length
            61            55     28  017B  7900 	MOVC3	R5, (R1), (R4)		; copy string
                          64         017E       
            50            01     D0  017F  8000 	MOVL	#SS$_NORMAL, R0		; R0 = success
                                 05  0182  8100 	RSB				; return, R1:R5 set from MOVC3
                                     0183  8200 
                                     0183  8300 ;+
                                     0183  8400 ; Here on error from LIB$GET_VM
                                     0183  8500 ;-
                                     0183  8600 
            5E            10     C0  0183  8700 10$:	ADDL	#16, SP			; cleanup stack
                                 05  0186  8800 	RSB				; return, R0 = error status
                                     0187  8900 
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  24
0-33            ALLOC_N_COPY_R5 - Allocate, set dst descr., and                                                                 (23)

                                     0187   100 ;+
                                     0187   200 ; Here to allocate storage for small strings because Q was empty
                                     0187   300 ; Allocate a whole page of strings of this size
                                     0187   400 ; Use a different pool than LIB$GET_VM since small Qs are never
                                     0187   500 ; returned to LIB$FREE_VM.  This should reduce long term fragmentation.
                                     0187   600 ; R0 = no. of bytes for string
                                     0187   700 ; R2 = adr. of destination string descriptor.
                                     0187   800 ; R4 = truncated n*K_ALLOC_QUANTA, n = 0, 1, 2, ...
                                     0187   900 ;-
                                     0187  1000 
                                     0187  1100 GET_VM_SMALL:
                          54     D5  0187  1200 	TSTL	R4			; is this Q 0?
                          03     12  0189  1300 	BNEQ	5$			; branch if not
            54            08     D0  018B  1400 	MOVL	#K_ALLOC_QUANTA, R4	; set to min size so room for Q links
                                     018E  1500 					; (8 bytes) when deallocated.
            7E            50     7D  018E  1600 5$:	MOVQ	R0, -(SP)		; save R0, R1 - clobberred on system call
                                     0191  1700 					; but also free up for use here
            5E            08     C2  0191  1800 	SUBL	#8, SP			; make 2 longword array for $EXPREG
                                     0194  1900 	.LIST				; show calling sequence
                                     0194  2000 	$EXPREG_S PAGCNT=#K_NO_PAGES_EXP, RETADR=8(SP)
                          00     DD  0194       		PUSHL	#0
                          00     DD  0196       		PUSHL	#0
                                     0198       		$PUSHADR 8(SP),CONTEXT=Q
                                     0198       		.IF	IDN,0,8(SP)
                                     0198       		PUSHL	#0
                                     0198       		.IFF
                       08 AE     7F  0198       		PUSHAQ	8(SP)
                                     019B       		.ENDC
                                     019B       	
                          01     DD  019B       		PUSHL	#K_NO_PAGES_EXP
   00000000'GF            04     FB  019D       		CALLS	#4,G^SYS$EXPREG
                                     01A4       	
            49            50     E9  01A4  2100 	BLBC	R0, 30$			; branch if error
            53            8E     D0  01A7  2200 	MOVL	(SP)+, R3		; R3 = virt adr. of first page
            53            04     C0  01AA  2300 	ADDL	#<K_RESIDUE+DSB$K_HED_LEN>, R3	; R3 = adr. of first control block
                                     01AD  2400 					; (just past DCB header)
                                     01AD  2500 					; adjusted so queue links will be
                                     01AD  2600 					; longword aligned (just after header).
            54            04     C0  01AD  2700 	ADDL	#<DSB$K_HED_LEN+K_RESIDUE>, R4
                                     01B0  2800 					; R4 = total # bytes allocated
                                     01B0  2900 					; including header = n*K_ALLOC_QUANTA +
                                     01B0  3000 					; DSB$K_HED_LEN+K_RESIDUE, n=1, 2, ...
            54            02     A3  01B0  3100 	SUBW3	#DSB$K_HED_LEN, R4, -	; no. of bytes for string area (rounded up)
                       FE A3         01B3       
                                     01B5  3200 		DSB$W_ALLOC_LEN(R3)	; stored in control block header
         04 A2            53     D0  01B5  3300 	MOVL	R3, DSC$A_POINTER(R2)	; Store adr. of string area in dst descr.
            53            54     C1  01B9  3400 	ADDL3	R4, R3, R0		; R0 = adr. of string area in
                          50         01BC       
                                     01BD  3500 					; next control block
                 00000200 8F     C1  01BD  3600 	ADDL3	#<K_NO_PAGES_EXP*512>, -
            51            53         01C3  3700 		R3, R1			; R1 = first adr. not allocated
                                     01C5  3800 					; ie. first adr. to get access violation
            51            54     C2  01C5  3900 	SUBL	R4, R1			; R1 = adr. of last control block that can
                                     01C8  4000 					; be inserted in Q
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  25
0-33            ALLOC_N_COPY_R5 - Allocate, set dst descr., and                                                                 (24)

                                     01C8  3900 ;+
                                     01C8  4000 ; Loop to insert remaining unused control blocks in proper Q
                                     01C8  4050 ; R0 = adr. of string area in each control block, R4 = step size
                                     01C8  4075 ; R1 =  address  of last control block that can be inserted
                                     01C8  4100 ;-
                                     01C8  4200 
            51            50     D1  01C8  4250 10$:	CMPL	R0, R1			; match last block?
                          12     1A  01CB  4275 	BGTRU	20$			; branch if if one beyond.
   FFFFFFFC'EF44          60     0E  01CD  4300 	INSQUE	(R0), Q_HED-DSB$K_HED_LEN-K_RESIDUE[R4]
                                     01D5  4400 					; insert next control block in Q
            54            02     A3  01D5  4500 	SUBW3	#DSB$K_HED_LEN, R4, -	; string area length
                       FE A0         01D8       
                                     01DA  4600 		 DSB$W_ALLOC_LEN(R0)	; to control block
            50            54     C0  01DA  4700 	ADDL	R4, R0			; R0 = adr. of next string area
                                     01DD  4800 					; in next control block
                          E9     11  01DD  5000 	BRB	10$			; loop back
                                     01DF  5050 
                                     01DF  5054 ;+
                                     01DF  5058 ; Here when done loop
                                     01DF  5062 ;-
                                     01DF  5075 
            5E            04     C0  01DF  5100 20$:	ADDL	#4, SP			; remove 1 longword
            50            8E     7D  01E2  5200 	MOVQ	(SP)+, R0		; R0 = requested string len
                                     01E5  5300 					; R1 = adr. of source
            62            50     B0  01E5  5400 	MOVW	R0, DSC$W_LENGTH(R2)	; store new length in dst descr.
            61            55     28  01E8  5500 	MOVC3	R5, (R1), (R3)		; copy string
                          63         01EB       
            50            01     D0  01EC  5600 	MOVL	#SS$_NORMAL, R0		; R0 = success
                                 05  01EF  5700 	RSB				; return, R1:R5 from MOVC3
                                     01F0  5800 
                                     01F0  5900 ;+
                                     01F0  6000 ; Here on error return from SYS$EXPREG.
                                     01F0  6100 ;-
                                     01F0  6200 
            5E            10     C0  01F0  6300 30$:	ADDL	#16, SP			; cleanup stack
                                 05  01F3  6400 	RSB				; return, R0 = error status
                                     01F4  6500 
                                     01F4  6600 	.END
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  26
SYMBOL TABLE                                                                                                                    (24)

ALLOC_N_COPY_R5  00000106 R     04   DSC$K_DTYPE_WU = 00000003            MTH__SQUROONEG = 00000054            
BIG_OLD_DST      000000CC R     04   DSC$K_DTYPE_Z  = 00000000            MTH__UNDEXP    = 00000052            
BIT...         = 00000000            DSC$K_DTYPE_ZEM= 00000017            MTH__WRONUMARG = 00000050            
DSB$K_HED_LEN  = 00000002            DSC$K_DTYPE_ZI = 00000016            Q_HED            00000000 R     03   
DSB$W_ALLOC_LEN= FFFFFFFE            DSC$K_D_BLN      00000008            RSB1             000000F0 R     04   
DSC$A_A0         00000010            DSC$K_JI_BLN     0000000C            RSB2             00000105 R     04   
DSC$A_FRAME      00000008            DSC$K_J_BLN      00000008            SGET1            000000AC R     04   
DSC$A_POINTER    00000004            DSC$K_PI_BLN     0000000C            SRC_STR        = 00000004            
DSC$B_AFLAGS     0000000A            DSC$K_P_BLN      00000008            SRC_STR_ADR    = 00000008            
DSC$B_CLASS      00000003            DSC$K_S_BLN      00000008            SRC_STR_LEN    = 00000004            
DSC$B_DIMCT      0000000B            DSC$K_Z_BLN      00000008            SRC_WONT_FIT     000000F1 R     04   
DSC$B_DTYPE      00000002            DSC$L_ARSIZE     0000000C            SS$_ABORT      = 0000002C            
DSC$C_D_BLN      00000008            DSC$L_M1         00000014            SS$_ACCONFLICT = 00000800            
DSC$C_JI_BLN     0000000C            DSC$L_M2         00000018            SS$_ACCVIO     = 0000000C            
DSC$C_J_BLN      00000008            DSC$S_FL_BOUNDS= 00000001            SS$_ACPVAFUL   = 000002FC            
DSC$C_PI_BLN     0000000C            DSC$S_FL_COEFF = 00000001            SS$_ARTRES     = 00000474            
DSC$C_P_BLN      00000008            DSC$S_FL_COLUMN= 00000001            SS$_ASTFLT     = 0000040C            
DSC$C_S_BLN      00000008            DSC$V_FL_BOUNDS= 00000007            SS$_BADATTRIB  = 00000034            
DSC$C_Z_BLN      00000008            DSC$V_FL_COEFF = 00000006            SS$_BADCHKSUM  = 00000808            
DSC$K_CLASS_A  = 00000004            DSC$V_FL_COLUMN= 00000005            SS$_BADESCAPE  = 0000003C            
DSC$K_CLASS_D  = 00000002            DSC$W_LENGTH     00000000            SS$_BADFILEHDR = 00000810            
DSC$K_CLASS_J  = 00000007            DSC$W_MAXLEN     00000008            SS$_BADFILENAME= 00000818            
DSC$K_CLASS_JI = 00000008            DST_STR        = 0000000C            SS$_BADFILEVER = 00000820            
DSC$K_CLASS_P  = 00000005            FIRST_TIME       000000F0 R     03   SS$_BADIMGHDR  = 00000044            
DSC$K_CLASS_PI = 00000006            FOR$K_ERR_PREFX= 00000018            SS$_BADIRECTORY= 00000828            
DSC$K_CLASS_S  = 00000001            FREE_BIG_DST     000000D1 R     04   SS$_BADPARAM   = 00000014            
DSC$K_CLASS_V  = 00000003            FREE_SMALL_DST   000000F6 R     04   SS$_BADSTACK   = 000002B4            
DSC$K_CLASS_Z  = 00000000            GBL...         = 00000000            SS$_BEGOFFILE  = 00000938            
DSC$K_DTYPE_B  = 00000006            GET_VM_LARGE     00000155 R     04   SS$_BLOCKCNTERR= 00000940            
DSC$K_DTYPE_BU = 00000002            GET_VM_SMALL     00000187 R     04   SS$_BREAK      = 00000414            
DSC$K_DTYPE_D  = 0000000B            K_ALLOC_POWER  = 00000003            SS$_BUFBYTALI  = 0000030C            
DSC$K_DTYPE_DC = 0000000D            K_ALLOC_QUANTA = 00000008            SS$_BUFFEROVF  = 00000601            
DSC$K_DTYPE_DPC= 000000B9            K_MAX_SIZ_STR  = 000000EA            SS$_BUGCHECK   = 000002A4            
DSC$K_DTYPE_EOM= 000000BD            K_NO_FAST_QS   = 0000001E            SS$_CANCEL     = 00000830            
DSC$K_DTYPE_EOR= 000000BF            K_NO_PAGES_EXP = 00000001            SS$_CHANINTLK  = 0000004C            
DSC$K_DTYPE_F  = 0000000A            K_RESIDUE      = 00000002            SS$_CLIFRCEXT  = 00000980            
DSC$K_DTYPE_FC = 0000000C            LIB$$SCOPY_RDD6  000000A9 RG    04   SS$_CMODSUPR   = 0000041C            
DSC$K_DTYPE_FLD= 000000B7            LIB$FREE_VM      ********   X   01   SS$_CMODUSER   = 00000424            
DSC$K_DTYPE_L  = 00000008            LIB$GET_VM       ********   X   01   SS$_COMPAT     = 0000042C            
DSC$K_DTYPE_LBL= 000000BA            LIB$SCOPY_DXDX   0000005D RG    04   SS$_CONTINUE   = 00000001            
DSC$K_DTYPE_LU = 00000004            LIB$SCOPY_DXDX6  0000006A RG    04   SS$_CONTROLC   = 00000651            
DSC$K_DTYPE_MOD= 000000BC            LIB$SCOPY_R_DX   00000072 RG    04   SS$_CONTROLO   = 00000609            
DSC$K_DTYPE_NL = 00000010            LIB$SCOPY_R_DX6  0000007F RG    04   SS$_CONTROLY   = 00000611            
DSC$K_DTYPE_NLO= 00000011            LIB$SFREE1_DD    00000015 RG    04   SS$_CREATED    = 00000619            
DSC$K_DTYPE_NR = 00000012            LIB$SFREE1_DD6   0000001E RG    04   SS$_CTRLERR    = 00000054            
DSC$K_DTYPE_NRO= 00000013            LIB$SFREEN_DD    00000039 RG    04   SS$_DATACHECK  = 0000005C            
DSC$K_DTYPE_NU = 0000000F            LIB$SFREEN_DD6   00000046 RG    04   SS$_DATAOVERUN = 00000838            
DSC$K_DTYPE_NZ = 00000014            LIB$SGET1_DD     00000000 RG    04   SS$_DEBUG      = 0000046C            
DSC$K_DTYPE_P  = 00000015            LIB$SGET1_DD_R6  0000000D RG    04   SS$_DECOVF     = 000004A4            
DSC$K_DTYPE_PCT= 000000B8            LIB$_INVSTRDES   ********   X   01   SS$_DEVACTIVE  = 000002C4            
DSC$K_DTYPE_Q  = 00000009            LIB$_STRTRU      ********   X   01   SS$_DEVALLOC   = 00000840            
DSC$K_DTYPE_QU = 00000005            MTH$K_ERR_PREFX= 00000016            SS$_DEVALRALLOC= 00000641            
DSC$K_DTYPE_RTN= 000000BE            MTH__FLOOVEMAT = 00000058            SS$_DEVASSIGN  = 00000848            
DSC$K_DTYPE_SLB= 000000BB            MTH__FLOUNDMAT = 00000059            SS$_DEVFOREIGN = 00000064            
DSC$K_DTYPE_T  = 0000000E            MTH__INVARG    = 00000051            SS$_DEVICEFULL = 00000850            
DSC$K_DTYPE_V  = 00000001            MTH__LOGZERNEG = 00000053            SS$_DEVMOUNT   = 0000006C            
DSC$K_DTYPE_W  = 00000007            MTH__SINSIGLOS = 00000057            SS$_DEVNOTALLOC= 00000858            
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  27
SYMBOL TABLE                                                                                                                    (24)

SS$_DEVNOTMBX  = 00000074            SS$_IVLOGNAM   = 00000154            SS$_RADRMOD    = 0000044C            
SS$_DEVNOTMOUNT= 0000007C            SS$_IVLOGTAB   = 0000015C            SS$_REJECT     = 00000294            
SS$_DEVOFFLINE = 00000084            SS$_IVPROTECT  = 000002F4            SS$_REMOTE     = 00000649            
SS$_DIRFULL    = 00000860            SS$_IVQUOTAL   = 00000164            SS$_RESIGNAL   = 00000918            
SS$_DRVERR     = 0000008C            SS$_IVSECFLG   = 0000016C            SS$_RESULTOVF  = 00000214            
SS$_DUPFILENAME= 00000868            SS$_IVSECIDCTL = 000002E4            SS$_ROPRAND    = 00000454            
SS$_DUPLNAM    = 00000094            SS$_IVSSRQ     = 00000174            SS$_SECTBLFUL  = 0000021C            
SS$_ENDOFFILE  = 00000870            SS$_IVSTSFLG   = 0000017C            SS$_SSFAIL     = 0000045C            
SS$_ENDOFTAPE  = 00000878            SS$_IVTIME     = 00000184            SS$_SUBRNG     = 000004AC            
SS$_ENDOFUSRLBL= 00000970            SS$_LCKPAGFUL  = 000000D4            SS$_SUPERSEDE  = 00000631            
SS$_EXQUOTA    = 0000001C            SS$_LENVIO     = 0000018C            SS$_TAPEPOSLOST= 00000224            
SS$_EXTIDXFILE = 00000880            SS$_LKWSETFUL  = 00000194            SS$_TBIT       = 00000464            
SS$_FCPREADERR = 00000888            SS$_MBFULL     = 000008D8            SS$_TIMEOUT    = 0000022C            
SS$_FCPREPSTN  = 00000988            SS$_MBTOOSML   = 0000019C            SS$_TOOMANYVER = 00000990            
SS$_FCPREWNDERR= 00000890            SS$_MCHECK     = 000002BC            SS$_TOOMUCHDATA= 0000029C            
SS$_FCPSPACERR = 00000898            SS$_MEDOFL     = 000001A4            SS$_UNASEFC    = 00000234            
SS$_FCPWRITERR = 000008A0            SS$_MSGNOTFND  = 00000621            SS$_UNSAFE     = 0000023C            
SS$_FILACCERR  = 0000009C            SS$_MTLBLLONG  = 00000304            SS$_UNWIND     = 00000920            
SS$_FILALRACC  = 000000A4            SS$_MUSTCLOSEFL= 00000948            SS$_UNWINDING  = 00000928            
SS$_FILELOCKED = 000008A8            SS$_NOAQB      = 00000314            SS$_VASFULL    = 00000244            
SS$_FILENUMCHK = 000008B0            SS$_NODATA     = 000001AC            SS$_VECINUSE   = 0000024C            
SS$_FILESEQCHK = 000008B8            SS$_NOHANDLER  = 000008F8            SS$_VOLINV     = 00000254            
SS$_FILESTRUCT = 000008C0            SS$_NOHOMEBLK  = 000008E0            SS$_WAITUSRLBL = 00000950            
SS$_FILNOTACC  = 000000AC            SS$_NOIOCHAN   = 000001B4            SS$_WASCLR     = 00000001            
SS$_FILNOTCNTG = 000002AC            SS$_NOLINKS    = 0000027C            SS$_WASECC     = 00000639            
SS$_FILNOTEXP  = 000000B4            SS$_NOLOGNAM   = 000001BC            SS$_WASSET     = 00000009            
SS$_FLTDIV     = 00000494            SS$_NOMBX      = 00000274            SS$_WRITLCK    = 0000025C            
SS$_FLTOVF     = 0000048C            SS$_NOMOREFILES= 00000930            SS$_WRONGACP   = 0000031C            
SS$_FLTUND     = 0000049C            SS$_NONEXDRV   = 000001C4            SYS$EXPREG       ********   X   01   
SS$_FORMAT     = 000000BC            SS$_NONEXPR    = 000008E8            S_TYPE           00000094 R     04   
SS$_GPTFULL    = 000000C4            SS$_NONLOCAL   = 000008F0            V_TYPE           0000008C R     04   
SS$_GSDFULL    = 000000CC            SS$_NOPRIV     = 00000024            Z_TYPE           00000094 R     04   
SS$_HANGUP     = 000002CC            SS$_NORMAL     = 00000001            
SS$_HEADERFULL = 000008C8            SS$_NOSIGNAL   = 00000900            
SS$_IDXFILEFULL= 000008D0            SS$_NOSOLICIT  = 00000284            
SS$_ILLBLKNUM  = 000000DC            SS$_NOSUCHDEV  = 00000908            
SS$_ILLCNTRFUNC= 000000E4            SS$_NOSUCHFILE = 00000910            
SS$_ILLEFC     = 000000EC            SS$_NOSUCHNODE = 0000028C            
SS$_ILLIOFUNC  = 000000F4            SS$_NOSUCHSEC  = 00000978            
SS$_ILLLBLAST  = 00000968            SS$_NOTAPEOP   = 00000264            
SS$_ILLPAGCNT  = 000000FC            SS$_NOTFILEDEV = 000001CC            
SS$_ILLSEQOP   = 000002DC            SS$_NOTINTBLSZ = 000001D4            
SS$_ILLSER     = 00000104            SS$_NOTLABELMT = 000001DC            
SS$_ILLUSRLBLRD= 00000958            SS$_NOTMODIFIED= 00000659            
SS$_ILLUSRLBLWT= 00000960            SS$_NOTNETDEV  = 000002EC            
SS$_INCVOLLABEL= 0000010C            SS$_NOTRAN     = 00000629            
SS$_INSFARG    = 00000114            SS$_NOTSQDEV   = 000001E4            
SS$_INSFMEM    = 00000124            SS$_OPCCUS     = 00000434            
SS$_INSFRAME   = 0000012C            SS$_OPCDEC     = 0000043C            
SS$_INSFWSL    = 0000011C            SS$_OPINCOMPL  = 000002D4            
SS$_INTDIV     = 00000484            SS$_PAGOWNVIO  = 000001EC            
SS$_INTOVF     = 0000047C            SS$_PAGRDERR   = 00000444            
SS$_IVADDR     = 00000134            SS$_PARITY     = 000001F4            
SS$_IVCHAN     = 0000013C            SS$_PARTESCAPE = 000001FC            
SS$_IVCHNLSEC  = 0000026C            SS$_PFMBSY     = 00000204            
SS$_IVDEVNAM   = 00000144            SS$_PLHLDR     = 00000404            
SS$_IVGSDNAM   = 0000014C            SS$_PSTFULL    = 0000020C            
LIB$SCOPY       ; Library copy strings                           21-AUG-1978 18:59:21   VAX-11 MACRO X0.3-11               Page  28
PROGRAM SECTION SYNOPSIS                                                                                                        (24)



PROGRAM SECTION SYNOPSIS

.  ABS  .        00000000      00     NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT BYTE  
. BLANK .        00000000      01     NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT BYTE  
$ABS$            0000001C      02     NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT BYTE  
LIB$DATA         000000F1      03       PIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT LONG  
LIB$CODE         000001F4      04       PIC   USR   CON   REL   LCL   SHR   EXE   RD  NOWRT LONG  


THERE WERE NO ERRORS OR WARNINGS.
16136. BYTES LEFT IN FREE MEMORY POOL.
2738. BYTES OF RECLAIMED MEMORY.
OBJ$:LIBSCOPY,LIS$:LIBSCOPY/-SP=LIB$:S/ML,SRC$:P,LIBSCOPY
10 MLB DIR RDS - 452 GETS TO DEFINE 13 MACROS. 35 INTER. FILE WRITES. 
