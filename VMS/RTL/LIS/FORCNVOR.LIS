FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   0
TABLE OF CONTENTS   

   (1)      70  HISTORY		; Detailed Current Edit History
   (2)      84  DECLARATIONS
   (3)     135  FOR$CNV_OUT_E		; E-Format output Conversion Rou
   (4)     184  FOR$CNV_OUT_D		; D-Format Conversion Routine
   (5)     220  FOR$CNV_OUT_F		; F-Format Conversion Routine
   (6)     263  FOR$CNV_OUT_G		; G-Format Conversion Routine
   (7)     315  CONV_INT_FRAC		; Generate integer part.
   (11)    475  FRACTION_SUBR		; Generate fraction digits
   (12)    516  EXP_FORM		; Number of significant digits
   (12)    542  INIT_C_SIZE		; Number of characters to output
   (13)    570  ASCII_OUT		; Output ASCII string
   (16)    711  ERROR			; No room in output string
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   1
02-9                                                                                                                             (1)

                                     0000     1 	.TITLE FOR$CNV_OUT	; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES
                                     0000     2 				; (FOR$CNV_OUT_D, FOR$CNV_OUT_E,
                                     0000     3 				; FOR$CNV_OUT_G)
                                     0000     4 
                                     0000     5 	.IDENT	/02-9/		; FILE: OUTCNVOR.MAR
                                     0000     6 ;++
                                     0000     7 ; FACILITY: FORTRAN support library
                                     0000     8 ;
                                     0000     9 ; ABSTRACT:
                                     0000    10 ;
                                     0000    11 ; Procedures to perform Fortran Dw.d, Ew.d, Gw.d, and Fw.d formatted
                                     0000    12 ; output conversion including optional nP scaling.
                                     0000    13 ; The formatted output is returned using a fixed length string
                                     0000    14 ; descriptor passed as a parameter.
                                     0000    15 ;
                                     0000    16 ; ENVIRONMENT: Any access mode -- normally user mode.
                                     0000    17 ;
                                     0000    18 ;--
                                     0000    19 ;
                                     0000    20 ; AUTHOR:	Tryggve Fossum
                                     0000    21 ; CREATION DATE: 16-MAY-78
                                     0000    22 ;
                                     0000    23 ; MODIFICATIONS:
                                     0000    24 	.SBTTL	HISTORY		; Detailed Current Edit History
                                     0000    25 
                                     0000    26 ; Edit history for version 02 of FCNVOR.
                                     0000    27 ;
                                     0000    28 ; The main advantage of version 02 over version 01, is
                                     0000    29 ; that it produces accurate digits to any desired length.
                                     0000    30 ; For large numbers, there is a speed improvement as well.
                                     0000    31 ;
                                     0000    32 ; 02-5	- Fix scale and negative nos.  TRG 5-Jun-78
                                     0000    33 ; 02-6  - Clear scale factor on zero.  TRG 5-Jun-78
                                     0000    34 ; 02-7  - Fix restart under G-format.  TRG 6-Jun-78
                                     0000    35 ; 02-8  - Fix problem with erroneous round.  TRG 12-JUN-78
                                     0000    36 ; 02-9  - Improve code-flow and comments. TRG 12-Jun-78
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   2
02-9            DECLARATIONS                                                                                                     (2)

                                     0000    38 	.SBTTL	DECLARATIONS
                                     0000    39 
                                     0000    40 ; EXTERNAL SYMBOLS:
                                     0000    41 ;
                                     0000    42 	.DSABL	GBL
                                     0000    43 	.EXTRN	FOR$_OUTCONERR
                                     0000    44 
                                     0000    45 ;
                                     0000    46 ;  EQUATED SYMBOLS:
                                     0000    47 ;
                                     0000    48 	
                           00000FFC  0000    49 	REGMASK = ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
                                     0000    50 ;  OFFSETS FROM FP:
                           FFFFFFFC  0000    51 	EXP_LETTER = -4		; exponent letter
                           FFFFFFF8  0000    52 	SCALE = EXP_LETTER-4	; scale factor
                           FFFFFFF4  0000    53 	INTL3= SCALE-4		; highest longword for integer
                           FFFFFFF0  0000    54 	INTL2= INTL3-4		; next longword for integer
                           FFFFFFEE  0000    55 	SEPARATE = INTL2-2	; address of temporary 9-digit ASCII string
                           FFFFFFEC  0000    56 	INTL1= INTL2-4		; next longword for integer
                           FFFFFFE8  0000    57 	INTL0= INTL1-4		; lowest longword for integer
                           FFFFFFE8  0000    58 	PACKED = INTL0		; address of 9-digit packed BCD string
                           FFFFFFB8  0000    59 	FRAME= -72		; limit for scratch area on stack
                           FFFFFFB8  0000    60 	MINUS = FRAME		; save address of minus-sign here
                                     0000    61 
                                     0000    62 
                                     0000    63 ;
                                     0000    64 ;  PSECT DECLARATIONS:
                                     0000    65 ;
                                 00000000    66 	.PSECT	FOR$CODE	PIC, SHR, LONG, EXE, NOWRT
                                     0000    67 
                                     0000    68 ;
                                     0000    69 ;  REGISTER USAGE:
                                     0000    70 ;	R0-R3 are used by Decimal and Character string instructions.
                                     0000    71 ;	R4= Inclusive 'OR' of digits in outputstring, for -0 test.
                                     0000    72 ;	R5 = Address for output string
                                     0000    73 ;	R6 = Exponent (decimal)
                                     0000    74 ;	R7 = Number of significant digits in output string
                                     0000    75 ;	R8 = Offset from FP to lowest nonzero fraction longword
                                     0000    76 ;	R9 = Number of longwords in integer portion
                                     0000    77 ;	R10 = Character string length
                                     0000    78 ;	R11= Scale-factor, later used for PL (= # of digits left of .).
                                     0000    79 
                                     0000    80 ;
                                     0000    81 ;  ABBREVIATIONS:
                                     0000    82 ;	PL= Number of digits left of decimal point
                                     0000    83 ;	R = Number of digits to be produced for output string
                                     0000    84 ;	ZL= Number of leading zeroes
                                     0000    85 ;	D = Number of digits in fraction
                                     0000    86 ;	W = Characters allocated for output string
                                     0000    87 ;	P = Scale factor
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   3
02-9            FOR$CNV_OUT_E  ; E-Format output Conversion Rou                                                                  (3)

                                     0000    89 	.SBTTL	FOR$CNV_OUT_E		; E-Format output Conversion Routine
                                     0000    90 
                                     0000    91 
                                     0000    92 ;++
                                     0000    93 ; FUNCTIONAL DESCRIPTION:
                                     0000    94 ;
                                     0000    95 ;	Algorithmic steps:
                                     0000    96 ;	1. Store scale-factor on stack (default is 0)
                                     0000    97 ;	2. Allocate a scratch area on stack, and insert 0s
                                     0000    98 ;	   in the portion that will be used to store integer
                                     0000    99 ;	   and fraction portions of floating number.
                                     0000   100 ;	3. Use scale factor and digits in fraction to determine
                                     0000   101 ;	   number of digits to be generated.
                                     0000   102 ;	4. Multiply the mantissa of the floating point number
                                     0000   103 ;	   by the exponent, set the hidden bit, and store the
                                     0000   104 ;	   result as a binary fixed point number on the stack.
                                     0000   105 ;	5. Treat the integer portion of the binary number as a
                                     0000   106 ;	   4-digit number with radix 2**32, and use repeated
                                     0000   107 ;	   division to convert it to a 5-digit number with
                                     0000   108 ;	   radix 10**9.
                                     0000   109 ;	6. On each of the five digits, use the CVTLP-instruction
                                     0000   110 ;	   to convert the digit to a 9-digit decimal string.
                                     0000   111 ;	7. Convert the packed decimal string to ASCII, and output
                                     0000   112 ;	   the concatenated results.
                                     0000   113 ;	8. Treat the fraction part of the above binary number as a
                                     0000   114 ;	   fraction with radix 2**32, and convert it to radix 10**9
                                     0000   115 ;	   by repeated multiplication by 10**9. Using the CVTLP-
                                     0000   116 ;	   instruction, convert each such digit to decimal, and output
                                     0000   117 ;	   the result.
                                     0000   118 ;	9. If more fraction digits are needed, repeat step 8.
                                     0000   119 ;	10.After reaching end of string, compare first discarded digit
                                     0000   120 ;	   with 5 to determine rounding. Go backward through the output-
                                     0000   121 ;	   string, propagating carry as far as necessary. If it
                                     0000   122 ;	   propagates to the end, replace number with 100000...00,
                                     0000   123 ;	   and increment exponent.
                                     0000   124 ;	11.Finally, convert exponent value to decimal, and output.
                                     0000   125 ; CALLING SEQUENCE:
                                     0000   126 ;
                                     0000   127 ;	Fits.wlc.v = FOR$CNV_OUT_E (value.rd.r, out_str.wt.ds,
                                     0000   128 ;		digits_in_frac.rlu.v [,scale_factor.rl.v]
                                     0000   129 ; INPUT PARAMETERS:
                                     0000   130 ;
                           00000004  0000   131 	value = 4			; double precision value
                           00000008  0000   132 	out_str = 8			; output string descriptor
                           0000000C  0000   133 	digits_in_frac = 12		; digits in fraction (D)
                           00000010  0000   134 	scale_factor = 16		; signed scale factor
                                     0000   135 ;
                                     0000   136 ;--
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   4
02-9            FOR$CNV_OUT_D  ; D-Format Conversion Routine                                                                     (4)

                                     0000   138 	.SBTTL	FOR$CNV_OUT_D		; D-Format Conversion Routine
                                     0000   139 
                                     0000   140 
                                     0000   141 ;++
                                     0000   142 ; FUNCTIONAL DESCRIPTION:
                                     0000   143 ;
                                     0000   144 ;	After storing Exponent letter 'D' on stack, this routine 
                                     0000   145 ;	joins the E-Format routine.
                                     0000   146 ;
                                     0000   147 ;--
                               0FFC' 0000   148 	.ENTRY	FOR$CNV_OUT_D, REGMASK
            7E         44 8F     9A  0002   149 	MOVZBL	#^A/D/, -(SP)		; Store exponent letter
                          06     11  0006   150 	BRB	D_OR_E_OUT_CONV		; Join E-routine
                                     0008   151 
                                     0008   152 
                                     0008   153 
                               0FFC' 0008   154 	.ENTRY	FOR$CNV_OUT_E, REGMASK
                                     000A   155 
            7E         45 8F     9A  000A   156 	MOVZBL	#^A/E/,-(SP)		; Store exponent letter
                                     000E   157 D_OR_E_OUT_CONV:
            5E         B8 AD     DE  000E   158 	MOVAL	FRAME(FP), SP		; Set up stack
                          00DD   30  0012   159 	BSBW	CONV_INT_FRAC		; Get first block of digits
                          0256   30  0015   160 	BSBW	EXP_FORM		; Determine R (number of digits)
            5A            04     C0  0018   161 	ADDL	#4,R10			; Add room for exponent
                          027E   30  001B   162 	BSBW	ASCII_OUT		; Output ASCII string
                          05     12  001E   163 	BNEQ	15$			; Skip if no carry propagate
            60            31     90  0020   164 	MOVB	#^A/1/, (R0)		; Write 100...00
                          56     D6  0023   165 	INCL	R6			; Increment exponent
            85         FC AD     90  0025   166 15$:	MOVB	EXP_LETTER(FP), (R5)+	; Write exponent letter (D or E)
                                     0029   167 E_EXPONENT:
            56         F8 AD     C2  0029   168 	SUBL	SCALE(FP),R6		; Allow for scale factor in exponent
            02            56     F9  002D   169 	CVTLP	R6, #2, PACKED(FP)	; Convert exponent to decimal
                       E8 AD         0030       
            63            02     08  0032   170 	CVTPS	#2, (R3), #2, (R5)	; Make it Leading separate
            65            02         0035       
            50            01     D0  0037   171 RET:	MOVL	#1, R0			; Set function value for success
                                 04  003A   172 	RET				; Return to User
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   5
02-9            FOR$CNV_OUT_F  ; F-Format Conversion Routine                                                                     (5)

                                     003B   174 	.SBTTL	FOR$CNV_OUT_F		; F-Format Conversion Routine
                                     003B   175 
                                     003B   176 ;++
                                     003B   177 ; FUNCTIONAL DESCRIPTION:
                                     003B   178 ;
                                     003B   179 ;	Algorithmic steps:
                                     003B   180 ;	Steps 1 thru 9 are basically the same as for the E-Format
                                     003B   181 ;	Routine. The basic difference lies in the way one determines
                                     003B   182 ;	the number of digits to the left of the decimal point.
                                     003B   183 ;	In step 10, if the carry propagates all the way to the end,
                                     003B   184 ;	we replace the leading 9 with 10 instead if there is room. If not,
                                     003B   185 ;	there is an error, and the string is replaced with asterisks.
                                     003B   186 ;	There is of course no exponent to be output, so we skip step 11.
                                     003B   187 ;
                                     003B   188 ;--
                               0FFC' 003B   189 	.ENTRY	FOR$CNV_OUT_F, REGMASK
            5E         B8 AD     DE  003D   190 	MOVAL	FRAME(FP), SP		; Set up scratch area on stack
                          00AE   30  0041   191 	BSBW	CONV_INT_FRAC		; Convert first 9 digits
         0C AC            56     C1  0044   192 	ADDL3	R6, digits_in_frac(AP), R7
                          57         0048       
                                     0049   193 					; Exponent + fraction digits
            57         F8 AD     C0  0049   194 	ADDL2	SCALE(FP), R7		; Add in the scale factor
                          0238   30  004D   195 	BSBW	INIT_C_SIZE		; Figure out needed string size
         F8 AD            56     C1  0050   196 	ADDL3	R6,SCALE(FP),R11	; Initialize R11 to PL(digits left of .)
                          5B         0054       
                          0244   30  0055   197 	BSBW	ASCII_OUT		; Convert and output string
                          DD     12  0058   198 	BNEQ	RET			; Skip if no carry propagate
                                     005A   199 CARRY_PROP:
            54         08 BC     7D  005A   200 	MOVQ	@out_str(AP), R4	; R4 gets string size,
                                     005E   201 					; and R5 gets string address
            55            50     D1  005E   202 15$:	CMPL	R0, R5			; Is this the last chance ?
                          03     14  0061   203 	BGTR	20$			; No, keep trying
                          02F9   31  0063   204 17$:	BRW	ERROR			; Yes, fill with asterisks
            70            2E     91  0066   205 20$:	CMPB	#^A/./, -(R0)		; Get next character
                          F3     13  0069   206 	BEQL	15$			; Keep looking if decimal point
            60            00     E0  006B   207 	BBS	#0, (R0), 25$		; Branch if minus-sign
                          05         006E       
            60            31     90  006F   208 	MOVB	#^A/1/, (R0)		; Replace space or 0 by 1
                          C3     11  0072   209 	BRB	RET
            60            31     90  0074   210 25$:	MOVB	#^A/1/, (R0)		; Replace minus by a 1
            55            50     D1  0077   211 	CMPL	R0, R5			; Compare with low limit
                          E7     15  007A   212 	BLEQ	17$			; Error if less than
            70            2D     90  007C   213 	MOVB	#^A/-/, -(R0)		; Write minus sign
                          B6     11  007F   214 	BRB	RET			; Finished, so exit
                                     0081   215 
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   6
02-9            FOR$CNV_OUT_G  ; G-Format Conversion Routine                                                                     (6)

                                     0081   217 	.SBTTL	FOR$CNV_OUT_G		; G-Format Conversion Routine
                                     0081   218 
                                     0081   219 ;++
                                     0081   220 ; FUNCTIONAL DESCRIPTION:
                                     0081   221 ;
                                     0081   222 ;	Algorithmic steps:
                                     0081   223 ;	The number is output in F-format if it is >= 0.1 and
                                     0081   224 ;	the exponent is less than the number of fraction bits.
                                     0081   225 ;	Otherwise, E-format is used.
                                     0081   226 ;	Since the rounding can cause a change from one format
                                     0081   227 ;	to another, an extra check has to be inserted at the end.
                                     0081   228 ;++
                               0FFC' 0081   229 	.ENTRY	FOR$CNV_OUT_G, REGMASK
            5E         B8 AD     DE  0083   230 	MOVAL	FRAME(FP), SP		; Set up scratch area on stack
                          69     10  0087   231 	BSBB	CONV_INT_FRAC		; Get first few digits
         0C AC            56     D1  0089   232 	CMPL	R6, digits_in_frac(AP)	; Compare exponent with D
                          26     15  008D   233 	BLEQ	20$			; Use F-format if less than
                          01DC   30  008F   234 15$:	BSBW	EXP_FORM		; Calculate number of digits (R)
            5A            04     C0  0092   235 	ADDL	#4,R10			; Leave room for exponent
                          0204   30  0095   236 	BSBW	ASCII_OUT		; Output string
                          14     12  0098   237 	BNEQ	17$			; Skip if no carry propagation
            56         FF 8F     91  009A   238 	CMPB	#<0-1>, R6		; Is the rounded value 0.1 ?
                          09     12  009E   239 	BNEQ	16$			; Just finish up if not
                          50     10  00A0   240 	BSBB	CONV_INT_FRAC		; Start over again
         0C AC            01     C3  00A2   241 	SUBL3	#1,digits_in_frac(AP),R7
                          57         00A6       
                                     00A7   242 					; Compensate for negative exp
                          1F     11  00A7   243 	BRB	23$			; Join F-format routine
            60            31     90  00A9   244 16$:	MOVB	#^A/1/, (R0)		; Keep E-format
                          56     D6  00AC   245 	INCL	R6			; Increment exponent
            85         45 8F     90  00AE   246 17$:	MOVB	#^A/E/, (R5)+		; Write exponent
                          FF74   31  00B2   247 	BRW	E_EXPONENT		; Finished
                          56     D5  00B5   248 20$:	TSTL	R6			; Compare exponent with -1
                          D6     19  00B7   249 	BLSS	15$			; Do E-format after all
                       04 BC     73  00B9   250 	TSTD	@value(AP)		; Is argument 0 ?
                          D1     13  00BC   251 	BEQL	15$			; If so, do E-format
            57         0C AC     D0  00BE   252 22$:	MOVL	digits_in_frac(AP), R7	; Initialize # of digits
                          01C3   30  00C2   253 	BSBW	INIT_C_SIZE		; Find initial string size
            5B            56     D0  00C5   254 	MOVL	R6, R11			; PL is exponent
            54         08 BC     7D  00C8   255 23$:	MOVQ	@out_str(AP), R4	; R4 gets string size,
                                     00CC   256 					; and R5 gets string address
            54            04     A2  00CC   257 	SUBW	#4,R4			; Make room for 4 spaces
                          01CE   30  00CF   258 	BSBW	ASCII_OUT_1		; Output string
                          10     12  00D2   259 	BNEQ	25$			; Skip if no carry propagate
         0C AC            56     D1  00D4   260 	CMPL	R6, digits_in_frac(AP)	; Need to change to E-format ?
                          14     13  00D8   261 	BEQL	30$			; Yes- do E-format
            85   20202020 8F     D0  00DA   262 	MOVL	#^X20202020, (R5)+	; Write last 4 spaces
                          FF76   31  00E1   263 	BRW	CARRY_PROP		; Join F-format
            85   20202020 8F     D0  00E4   264 25$:	MOVL	#^X20202020, (R5)+	; Write 4 spaces
                          FF49   31  00EB   265 	BRW	RET
                          02     10  00EE   266 30$:	BSBB	CONV_INT_FRAC		; Start over again
                          9D     11  00F0   267 	BRB	15$			; Do E-format this time
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   7
02-9            CONV_INT_FRAC  ; Generate integer part.                                                                          (7)

                                     00F2   269 	.SBTTL	CONV_INT_FRAC		; Generate integer part.
                                     00F2   270 ;++
                                     00F2   271 ; This local subroutine is called by all the format routines.
                                     00F2   272 ; It loads the floating point number on the stack, and generates the
                                     00F2   273 ; first decimal digits.
                                     00F2   274 ; Expects:
                                     00F2   275 ;	SP must have been set up to allow scratch area on stack.
                                     00F2   276 ;	FP must equal original stack pointer.
                                     00F2   277 ;
                                     00F2   278 ; Returns:
                                     00F2   279 ;	R0 = # of non-zero decimal digits in current string of 9
                                     00F2   280 ;	R1 = address of first digit in current string
                                     00F2   281 ;	R6 = exponent
                                     00F2   282 ;	R8 = pointer to non-zero fraction longword (if no integer part)
                                     00F2   283 ;	R9 = number of integer longwords used
                                     00F2   284 ;
                                     00F2   285 ; First routine to load integer and fraction portion of floating point number
                                     00F2   286 ; on to the stack.
                                     00F2   287 ;--
                                     00F2   288 
                                     00F2   289 CONV_INT_FRAC:
                                     00F2   290 
                       F8 AD     D4  00F2   291 	CLRL	SCALE(FP)		; Scale factor
            04            6C     91  00F5   292 	CMPB	(AP),#<scale_factor/4>	; Test for scale factor
                          05     19  00F8   293 	BLSS	10$			; Skip if none
         F8 AD         10 AC     D0  00FA   294 	MOVL	scale_factor(AP),SCALE(FP)	; Load it
            6E            00     2C  00FF   295 10$:	MOVC5	#0,(SP), #0, #40, <INTL0-24>(FP)
            28            00         0102       
                       D0 AD         0104       
                                     0106   296 					; Clear block for floating number
            50         04 BC     70  0106   297 	MOVD	@value(AP), R0		; Get double argument
                          59     D4  010A   298 	CLRL	R9			; Initialize integer long count
            08            07     EF  010C   299 	EXTZV	#7,#8,R0,R2		; Extract exponent field from double
            52            50         010F       
                          4C     13  0111   300 	BEQL	CVTZERO			; Already done if zero
            52   00000080 8F     C3  0113   301 	SUBL3	#128,R2,R3		; Adjust for 8 bits used by exponent
                          53         011A       
            51            10     9C  011B   302 	ROTL	#16,R1,R1		; Put it in correct order
                          51         011E       
            53            51     F0  011F   303 	INSV	R1,R3,#32,<INTL0-7>(FP)	; Low part of fraction
         E1 AD            20         0122       
            50            10     9C  0125   304 	ROTL	#16,R0,R1		; Put high part in correct order
                          51         0128       
            51   00800000 8F     C8  0129   305 	BISL	#^X800000,R1		; Set hidden bit
            53            51     F0  0130   306 	INSV	R1,R3,#24,<INTL0-3>(FP)	; Store upper part
         E5 AD            18         0133       
                                     0136   307 
                                     0136   308 ;We now have stored integer and fraction part on the stack.
                                     0136   309 ; 
                                     0136   310 
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   8
02-9            CONV_INT_FRAC  ; Generate integer part.                                                                          (8)

                                     0136   312 ;++
                                     0136   313 ;Routine to calculate starting point for EDIV-routine to 
                                     0136   314 ;generate the digits in the integer portion.
                                     0136   315 ;
                                     0136   316 ;Expects:
                                     0136   317 ; R2=exponent(biased)
                                     0136   318 ; R3=unbiased exponent
                                     0136   319 ; R9=0
                                     0136   320 ;
                                     0136   321 ;Returns:
                                     0136   322 ; R9=Number of integer longwords used (0-4)
                                     0136   323 ; R6=exponent
                                     0136   324 ;--
                          53     D5  0136   325 	TSTL	R3			; Test for positive exponent
                          3C     15  0138   326 	BLEQ	CVT_FRAC		; No integer part
            52   00000098 8F     C2  013A   327 	SUBL	#<128+24>,R2		; Subtract upper limit
                          09     15  0141   328 	BLEQ	3$			; Skip if less than 30
            52         FB 8F     78  0143   329 	ASHL	#<0-5>,R2,R9		; Store longword count in R9
                          59         0147       
            59         FC 8F     8A  0148   330 	BICB2	#^O374,R9		; Clear high bits
            56         BC AD     DE  014C   331 3$:	MOVAL	<FRAME+4>(FP), R6	; Set up pointer integer digits
            58            59     D0  0150   332 	MOVL	R9, R8			; Use R8 as counter
            00            58     8F  0153   333 	CASEB	R8,#0,#3		; Branch on exp<6:5>
                          03         0156       
                               0075' 0157   334 5$:	.WORD	INT0-5$			; Just one longword
                               002D' 0159   335 	.WORD	INT_LOOP-5$		; Two longwords
                               002D' 015B   336 	.WORD	INT_LOOP-5$		; Three longwords
                               0022' 015D   337 	.WORD	INT3-5$			; Four longwords
                                     015F   338 
                                     015F   339 ; Enter here if number to be output is 0.
                                     015F   340 ; Flow for non-zero numbers continue on next page.
                                     015F   341 CVTZERO:
                          56     D4  015F   342 	CLRL	R6			; Make exponent 0
                       F8 AD     D4  0161   343 	CLRL	SCALE(FP)		; Do not want scale factor
            58            05     D0  0164   344 	MOVL	#5, R8			; Fake out fraction pointer
            6E            00     2C  0167   345 	MOVC5	#0,(SP),#^A/0/,#9,<INTL2-1>(FP)
            09            30         016A       
                       EF AD         016C       
                                     016E   346 					; Make string of zeroes
            51         EF AD     DE  016E   347 	MOVAL	<INTL2-1>(FP),R1	; Starting address
            50            09     D0  0172   348 	MOVL	#9,R0			; Count of digits in current string
                                 05  0175   349 	RSB
                                     0176   350 CVT_FRAC:
                          0085   31  0176   351 	BRW	CVT_FRACTION		; No integer digits, convert fraction
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page   9
02-9            CONV_INT_FRAC  ; Generate integer part.                                                                          (9)

                                     0179   353 ;++
                                     0179   354 ; This routine changes the integer portion from a 4 digit number
                                     0179   355 ; with radix 2**32, to a 5 digit number with radix 10**9. This is
                                     0179   356 ; done by repeated division of the number by 10**9, the division
                                     0179   357 ; taking place in binary
                                     0179   358 ;
                                     0179   359 ; Uses R0,R1,R2,R3,R4 for scratch.
                                     0179   360 ; Returns number of integer longwords in R9.
                                     0179   361 ;--
                                     0179   362 
                                     0179   363 INT3:
                          51     D4  0179   364 	CLRL	R1			; High part of dividend
            54         F4 AD     DE  017B   365 	MOVAL	INTL3(FP), R4		; Use R4 as address pointer
            50            64     D0  017F   366 	MOVL	(R4),R0			; Low part of dividend
                          08     11  0182   367 	BRB	INT3_2
                                     0184   368 INT_LOOP:
            54         E8 AD48   DE  0184   369 	MOVAL	INTL0(FP)[R8], R4	; Get address pointer
            50            64     7D  0189   370 	MOVQ	(R4), R0		; Get first quadword of dividend
            50   3B9ACA00 8F     7B  018C   371 INT3_2:	EDIV	#^D1000000000,R0,(R4),R1
            51            64         0193       
            55            58     D0  0195   372 	MOVL	R8, R5			; Use R5 as a loop counter
            51   1DCD6500 8F     C3  0198   373 3$:	SUBL3	#^D500000000,R1,R3	; Is this dividend too large ?
                          53         019F       
                          15     19  01A0   374 	BLSS	4$			; Skip adjustment if not
            52            74     D0  01A2   375 	MOVL	-(R4), R2		; Low part of dividend
            52   3B9ACA00 8F     7B  01A5   376 	EDIV	#^D1000000000,R2,(R4),R1
            51            64         01AC       
                                     01AE   377 					; Divide by 10**9
            64   80000000 8F     C8  01AE   378 	BISL	#^X80000000,(R4)	; Set high bit
                          0C     11  01B5   379 	BRB	5$
            50            74     D0  01B7   380 4$:	MOVL	-(R4), R0		; Get low part of dividend
            50   3B9ACA00 8F     7B  01BA   381 	EDIV	#^D1000000000,R0,(R4),R1
            51            64         01C1       
                                     01C3   382 					; Divide and store result in (R4)
            D2            55     F5  01C3   383 5$:	SOBGTR	R5, 3$			; Loop back
            86            51     D0  01C6   384 	MOVL	R1, (R6)+		; Store result on stack
            B8            58     F5  01C9   385 	SOBGTR	R8, INT_LOOP		; Loop back if not done
                                     01CC   386 INT0:
            50         E8 AD     7D  01CC   387 	MOVQ	INTL0(FP),R0		; Low part of next dividend
            50   3B9ACA00 8F     7B  01D0   388 	EDIV	#^D1000000000,R0,4(R6),(R6)+
            86         04 A6         01D7       
                          02     13  01DA   389 	BEQL	10$			; Branch if high longword is 0
                          59     D6  01DC   390 	INCL	R9			; Convert one more longword
                                     01DE   391 
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  10
02-9            CONV_INT_FRAC  ; Generate integer part.                                                                         (10)

                                     01DE   393 ;++
                                     01DE   394 ; Now convert the leading integer longword to an ASCII string.
                                     01DE   395 ; Return number of integer digits in R6 (exponent),
                                     01DE   396 ; number of non-zero digits in current string in R0,
                                     01DE   397 ; and address of first non-zero digit in R1.
                                     01DE   398 ;
                                     01DE   399 ;--
            09         BC AD49   F9  01DE   400 10$:	CVTLP	<FRAME+4>(FP)[R9], #9, PACKED(FP)
                       E8 AD         01E3       
                                     01E5   401 					; Convert longword to 9 packed decimal
            63            09     08  01E5   402 	CVTPS	#9, (R3), #9, SEPARATE(FP)
         EE AD            09         01E8       
                                     01EB   403 					; Convert it leading separate
            09            30     3B  01EB   404 	SKPC	#^A/0/, #9, 1(R3)	; Look for first non-zero digit
                       01 A3         01EE       
                          04     12  01F0   405 	BNEQ	20$			; Loop back if zero string
                          59     D7  01F2   406 	DECL	R9
                          E8     18  01F4   407 	BGEQ	10$			; Try again if more longwords
            56            6949   7E  01F6   408 20$:	MOVAQ	(R9)[R9], R6		; Multiply R9 by 9
            56            50     C0  01FA   409 	ADDL2	R0,R6			; Add in current digits
                                 05  01FD   410 	RSB				; Return with R0,R1,R6,R9 set up
                                     01FE   411 
                                     01FE   412 ;++
                                     01FE   413 ; Enter here if there are no integer digits.
                                     01FE   414 ; Convert longwords from fraction until a non-zero one is found.
                                     01FE   415 ;--
                                     01FE   416 CVT_FRACTION:
                                     01FE   417 
            56            09     CE  01FE   418 	MNEGL	#9,R6			; Initialize exponent to -9
                          12     10  0201   419 5$:	BSB	FRACT_OFFSET		; Get first 9 fraction digits
                          07     12  0203   420 	BNEQ	10$			; Branch if non-zero
            56            09     C2  0205   421 7$:	SUBL	#9, R6			; Decrement exponent
                          1C     10  0208   422 	BSB	FRACT_DIGITS		; Get more digits
                          F9     13  020A   423 	BEQL	7$			; Keep trying if 0
            09            30     3B  020C   424 10$:	SKPC	#^A/0/, #9, 1(R3)	; Look for first non-zero digit
                       01 A3         020F       
            56            50     C0  0211   425 	ADDL	R0,R6			; Add number of such to exponent
                                 05  0214   426 	RSB
                                     0215   427 
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  11
02-9            FRACTION_SUBR  ; Generate fraction digits                                                                       (11)

                                     0215   429 	.SBTTL	FRACTION_SUBR		; Generate fraction digits
                                     0215   430 
                                     0215   431 ;++
                                     0215   432 ; Routine to generate next 9 decimal digits from fraction part.
                                     0215   433 ;--
                                     0215   434 
                                     0215   435 FRACT_OFFSET:
                                     0215   436 ; Enter here if R8 has not been set up.
                          58     D4  0215   437 	CLRL	R8			; Initialize offset
                       D0 AD48   D5  0217   438 10$:	TSTL	<INTL3-36>(FP)[R8]	; Test longwords in fraction
                          09     12  021B   439 	BNEQ	FRACT_DIGITS		; Exit if non-zero
            01            05     9D  021D   440 	ACBB	#5, #1, R8, 10$		; Loop back if <= limit
            FFF4          58         0220       
            58            05     D0  0223   441 	MOVL	#5, R8			; No fraction digits
                                     0226   442 ; Expects:
                                     0226   443 ;	R8 = offset to lowest non-zero longword in fraction.
                                     0226   444 ;
                                     0226   445 
                                     0226   446 FRACT_DIGITS:
                                     0226   447 ; Enter here if R8 indexes to first non-zero fraction longword.
            52            58     D0  0226   448 	MOVL	R8, R2			; Get pointer to lowest longword
                          51     D4  0229   449 	CLRL	R1
            53         D0 AD42   DE  022B   450 	MOVAL	<INTL3-36>(FP)[R2], R3	; Initialize address pointer
            50            63     D0  0230   451 5$:	MOVL	(R3), R0		; Get part of fraction
                          1E     15  0233   452 	BLEQ	20$			; Special test if negative
            50   3B9ACA00 8F     7A  0235   453 	EMUL	#^D1000000000,R0,R1,R0
            50            51         023C       
                                     023E   454 					; Extended multiply next longword
            83            50     D0  023E   455 10$:	MOVL	R0, (R3)+		; Store result
            01            05     9D  0241   456 12$:	ACBB	#5, #1, R2, 5$		; Increment pointer and loop
            FFE9          52         0244       
            09            51     F9  0247   457 	CVTLP	R1, #9, PACKED(FP)
                       E8 AD         024A       
            63            09     08  024C   458 	CVTPS	#9, (R3), #9, SEPARATE(FP)
         EE AD            09         024F       
                                     0252   459 					; Convert to leading separate string
                                 05  0252   460 	RSB
                          12     13  0253   461 20$:	BEQL	30$			; Don't multiply if 0
            50   3B9ACA00 8F     7A  0255   462 	EMUL	#^D1000000000,R0,R1,R0	; Multiply by 10**9
            50            51         025C       
            51   3B9ACA00 8F     C0  025E   463 	ADDL	#^D1000000000,R1	; Compensate for negative multiplier
                          D7     11  0265   464 	BRB	10$
            83            51     D0  0267   465 30$:	MOVL	R1,(R3)+		; Previous addend
                          51     D4  026A   466 	CLRL	R1
                          D3     11  026C   467 	BRB	12$
                                     026E   468 
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  12
02-9            EXP_FORM  ; Number of significant digits                                                                        (12)

                                     026E   470 	.SBTTL	EXP_FORM		; Number of significant digits
                                     026E   471 ;++
                                     026E   472 ; Routine to determine R, the number of digits to be generated.
                                     026E   473 ; Gets called when output is done in exponential format.
                                     026E   474 ; Exits to INIT_C_SIZE-subroutine
                                     026E   475 ;
                                     026E   476 ; ALgorithm:
                                     026E   477 ;	If scale factor > 0 then R=max(scale factor+1,digits in fraction) else
                                     026E   478 ;				 R=scale factor+digits in fraction (P+D)
                                     026E   479 ;
                                     026E   480 ; Outputs:
                                     026E   481 ;	R7 = number of significant digits to be generated
                                     026E   482 ;	R11 = Scale factor
                                     026E   483 ;--
                                     026E   484 EXP_FORM:
            5B         F8 AD     D0  026E   485 	MOVL	SCALE(FP), R11		; Get scale factor
                          0F     15  0272   486 	BLEQ	2$			; Jump if negative
         0C AC            01     C1  0274   487 	ADDL3	#1, digits_in_frac(AP), R7
                          57         0278       
                                     0279   488 					; R7 gets D+1
            5B            57     D1  0279   489 	CMPL	R7,R11			; Compare with scale factor
                          0A     18  027C   490 	BGEQ	3$
            57            5B     D0  027E   491 	MOVL	R11,R7			; Load R7 with scale factor
                          05     11  0281   492 	BRB	3$
         0C AC            5B     C1  0283   493 2$:	ADDL3	R11, digits_in_frac(AP), R7
                          57         0287       
                                     0288   494 					; Add negative scale to D
                                     0288   495 3$:
                                     0288   496 	.SBTTL	INIT_C_SIZE		; Number of characters to output
                                     0288   497 
                                     0288   498 ;++
                                     0288   499 ; Routine to calculate number of digits needed.
                                     0288   500 ;
                                     0288   501 ; Algorithm:
                                     0288   502 ;	If R < 0 then R = 0 and no rounding up is allowed.
                                     0288   503 ;	C = R + 1
                                     0288   504 ;	If number is negative, then C = C + 1
                                     0288   505 ;	Return
                                     0288   506 ; Expects:
                                     0288   507 ;	R1 = address of first significant byte in ASCII string
                                     0288   508 ;	R7 = number of significant decimal digits to be generated
                                     0288   509 ; Output:
                                     0288   510 ;	R10 = C =  Number of characters to be output
                                     0288   511 ;--
                                     0288   512 
                                     0288   513 INIT_C_SIZE:
                          57     D5  0288   514 	TSTL	R7			;  Test character count
                          04     18  028A   515 	BGEQ	1$			;  Skip if OK
                          57     D4  028C   516 	CLRL	R7			;  Otherwise clear it
                          61     94  028E   517 	CLRB	(R1)			;  Make sure there is no rounding
            57            01     C1  0290   518 1$:	ADDL3	#1,R7,R10		;  Allow room for decimal point
                          5A         0293       
         04 BC            0F     E1  0294   519 	BBC	#15,@value(AP), 2$	;  Branch if non-negative
                          02         0298       
                          5A     D6  0299   520 	INCL	R10			;  Otherwise make room for minus sign
                                 05  029B   521 2$:	RSB
                                     029C   522 
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  13
02-9            ASCII_OUT  ; Output ASCII string                                                                                (13)

                                     029C   524 	.SBTTL	ASCII_OUT		; Output ASCII string
                                     029C   525 
                                     029C   526 ;++
                                     029C   527 ; Routine to output ASCII string.
                                     029C   528 ; Algorithm:
                                     029C   529 ;	1.Load R4 and R5 with length and address of output string.
                                     029C   530 ;	2.If PL=0 then (ZL = 0 and PL = P + E for F-format
                                     029C   531 ;				    = P for D,E,G-format)
                                     029C   532 ;		else (ZL = D - R and PL = 0)
                                     029C   533 ;	3.C = C + ZL
                                     029C   534 ;	4.S = W - C
                                     029C   535 ;	5.If S > 0 then do step 8
                                     029C   536 ;	6.If S = 0 then do step 9
                                     029C   537 ;	7.If S < 0 then error
                                     029C   538 ;	8.IF PL = 0 then (PL = PL + 1, ZL = ZL + 1, S = S - 1)
                                     029C   539 ;		  else (fill in S many leading blanks)
                                     029C   540 ;	9.If value of source is < 0, then (output minus-sign and save
                                     029C   541 ;		 address of minus sign, in case of - 0)
                                     029C   542 ;	 Now output leading zeroes and decimal point:
                                     029C   543 ;	10. If PL = 0 then output "."
                                     029C   544 ;	11. ZL = ZL - 1. If ZL > 0 then (output "0" do step 10.)
                                     029C   545 ;	Now output significant digits:
                                     029C   546 ;	12. R = R - 1
                                     029C   547 ;	    If R < 0 then do step 15.
                                     029C   548 ;	    PL = PL - 1
                                     029C   549 ;	    If PL = 0 then output "."
                                     029C   550 ;	13. Write next digit in output string.
                                     029C   551 ;	14. If there are no more digits left in current 9 digit string,
                                     029C   552 ;	    then generate string of nine more digits.
                                     029C   553 ;	    else repeat step 12.
                                     029C   554 ;	15. If first discarded digit is > 4 then start rounding process.
                                     029C   555 ;					    else check for -0.
                                     029C   556 ;	16. Continue rounding until we find digit less than 9, or
                                     029C   557 ;	    reach end of string. In first case return with Z-bit clear,
                                     029C   558 ;	    else return with Z-bit set.
                                     029C   559 ; Expects:
                                     029C   560 ;	R0 = # of digits left in current 9-digit string
                                     029C   561 ;	R1 = address of first significant digit in current string
                                     029C   562 ;	R2 and R3 are used for scratch.
                                     029C   563 ;	R4 = W or W-4
                                     029C   564 ;	R6 = exponent (unchanged and unused)
                                     029C   565 ;	R7 = R
                                     029C   566 ;	R10 = C
                                     029C   567 ;	R11 = initial value of PL
                                     029C   568 ; Returns:
                                     029C   569 ;	R5 = Address of last output digit + 1
                                     029C   570 ;	Z-bit = 0 if rounding did not cause a carry propagation
                                     029C   571 ;		1 if rounding caused carry propagation
                                     029C   572 ;--
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  14
02-9            ASCII_OUT  ; Output ASCII string                                                                                (14)

                                     029C   574 ASCII_OUT:
            54         08 BC     7D  029C   575 	MOVQ	@out_str(AP),R4		; Load string length in R4,
                                     02A0   576 					; and string address in R5
                                     02A0   577 ASCII_OUT_1:
                                     02A0   578 ; enter here if R4 and R5 have already been set up (G-format)
            54            54     32  02A0   579 	CVTWL	R4,R4			; Sign extend byte count
                          52     D4  02A3   580 	CLRL	R2			; Assume ZL = 0 (number of lead 0's)
                          5B     D5  02A5   581 	TSTL	R11			; Test PL
                          07     14  02A7   582 	BGTR	3$			; Branch if PL > 0, so ZL = 0
                          5B     D4  02A9   583 	CLRL	R11			; Otherwise PL = 0
         0C AC            57     C3  02AB   584 	SUBL3	R7, digits_in_frac(AP), R2
                          52         02AF       
            5A            52     C0  02B0   585 3$:	ADDL	R2,R10
            54            5A     C3  02B3   586 	SUBL3	R10,R4,R10		; R10  is number of spare spaces
                          5A         02B6       
                          05     14  02B7   587 	BGTR	30$			; Branch if greater than 0
                          15     13  02B9   588 	BEQL	5$			; Exact fit
                          00A1   31  02BB   589 	BRW	ERROR			; No fit, error
                          5B     D5  02BE   590 30$:	TSTL	R11			; Test PL
                          08     12  02C0   591 	BNEQ	4$			; Branch if greater than 0
                          5B     D6  02C2   592 	INCL	R11			; Allow one space for leading 0 to
                                     02C4   593 					;  left of decimal point.
                          52     D6  02C4   594 	INCL	R2			; One more leading 0
                          5A     D7  02C6   595 	DECL	R10			; Decrease by one spare space
                          06     13  02C8   596 	BEQL	5$
            85            20     90  02CA   597 4$:	MOVB	#^A/ /,(R5)+		; Leading spaces
            FA            5A     F5  02CD   598 	SOBGTR	R10,4$			; Subtract from space count
         04 BC            0F     E1  02D0   599 5$:	BBC	#15,@value(AP), LEAD_ZERO_OUT
                          07         02D4       
                                     02D5   600 					; Test sign bit of double floating
         B8 AD            55     D0  02D5   601 	MOVL	R5, MINUS(FP)		; Save address of '-' in case of -0
            85            2D     90  02D9   602 	MOVB	#^A/-/, (R5)+		; Store minus sign
                                     02DC   603 ;
                                     02DC   604 ; Now output leading zeroes and decimal point.
                                     02DC   605 ;
                                     02DC   606 LEAD_ZERO_OUT:
                          5B     D5  02DC   607 	TSTL	R11			; Test PL (digits left of .)
                          03     12  02DE   608 	BNEQ	2$
            85            2E     90  02E0   609 1$:	MOVB	#^A/./,(R5)+		; Output 0
                          52     D7  02E3   610 2$:	DECL	R2			; Leading 0's
                          09     19  02E5   611 	BLSS	OUTPUT_DIGITS		; Output real digits
            85            30     90  02E7   612 	MOVB	#^A/0/, (R5)+		; Output 0
                          5B     D7  02EA   613 	DECL	R11			; Decrement PL
                          F5     12  02EC   614 	BNEQ	2$			; Not time for decimal point
                          F0     11  02EE   615 	BRB	1$			; Time for decimal point
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  15
02-9            ASCII_OUT  ; Output ASCII string                                                                                (15)

                                     02F0   617 OUTPUT_DIGITS:
                          54     D4  02F0   618 	CLRL	R4			; Use it as flag for non-zero string
            5A            55     D0  02F2   619 	MOVL	R5,R10			; Save address of leading byte
                          57     D7  02F5   620 DLOOP:	DECL	R7			; Decrement digit count
                          38     19  02F7   621 	BLSS	31$			; Exit if finished
            54            61     88  02F9   622 	BISB2	(R1),R4			; 'OR' bytes together
            85            81     90  02FC   623 	MOVB	(R1)+,(R5)+		; Write digit in output string
                          5B     D7  02FF   624 	DECL	R11			; Decrement PL
                          03     12  0301   625 	BNEQ	10$			; Branch if positive
            85            2E     90  0303   626 	MOVB	#^A/./, (R5)+		; Write decimal point
            EC            50     F5  0306   627 10$:	SOBGTR	R0, DLOOP		; Keep looping till you run out
                          59     D5  0309   628 	TSTL	R9			; Integer portion ?
                          1A     19  030B   629 	BLSS	20$			; No-we are doing the fraction
                          59     D7  030D   630 	DECL	R9			; Decrement integer word count
                          1B     19  030F   631 	BLSS	30$			; Now start fraction part
            09         BC AD49   F9  0311   632 	CVTLP	<FRAME+4>(FP)[R9], #9, PACKED(FP)
                       E8 AD         0316       
                                     0318   633 					; Convert longword to 9 packed decimal
            63            09     08  0318   634 	CVTPS	#9, (R3), #9, SEPARATE(FP)
         EE AD            09         031B       
                                     031E   635 					; Convert it leading separate
            53            01     C1  031E   636 15$:	ADDL3	#1,R3,R1		; Address of current string
                          51         0321       
            50            09     D0  0322   637 	MOVL	#9, R0			; Set count to 9 digits
                          CE     11  0325   638 	BRB	DLOOP			; Loop back
                          FEFC   30  0327   639 20$:	BSBW	FRACT_DIGITS		; Get 9 fraction digits
                          F2     11  032A   640 	BRB	15$
                          FEE6   30  032C   641 30$:	BSBW	FRACT_OFFSET		; Get offset and fraction digits
                          ED     11  032F   642 	BRB	15$
            61            35     91  0331   643 31$:	CMPB	#^A/5/, (R1)		; Does rounding cause a carry?
                          11     15  0334   644 	BLEQ	33$			; Yes, go propagate carry
            54            0F     93  0336   645 	BITB	#^XF, R4		; Test 'OR' of digits
                          23     12  0339   646 	BNEQ	OUT1			; Branch if string is non-zero
         04 BC            0F     E1  033B   647 	BBC	#15,@value(AP),32$	; Branch if non-negative source
                          04         033F       
         B8 BD            20     90  0340   648 	MOVB	#^A/ /,@MINUS(FP)	; Replace 'minus' with 'space'
                          54     D6  0344   649 32$:	INCL	R4			; Clear PSL Z-bit
                                 05  0346   650 	RSB				; Return with Z-bit clear
            50            55     D0  0347   651 33$:	MOVL	R5,R0			; Current output address
            70            39     91  034A   652 35$:	CMPB	#^A/9/, -(R0)		; Is this another 9 ?
                          09     12  034D   653 	BNEQ	50$			; Exit if not
            60            30     90  034F   654 	MOVB	#^A/0/, (R0)		; Keep on propagating
            5A            50     D1  0352   655 40$:	CMPL	R0,R10			; Check for address of lead digit
                          F3     12  0355   656 	BNEQ	35$			; Keep on propagating the carry
                                 05  0357   657 	RSB				; This is it, increment exponent
                                     0358   658 					; or take other action on return
            60            04     E1  0358   659 50$:	BBC	#4, (R0), 35$		; Branch back if decimal point
                          EE         035B       
                                     035C   660 					; (only possible code with bit 4 clear)
                          60     96  035C   661 	INCB	(R0)			; Propagate no further
                                 05  035E   662 OUT1:	RSB				; Return with Z-bit clear
                                     035F   663 					; or set depending on carry
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  16
02-9            ERROR   ; No room in output string                                                                              (16)

                                     035F   665 	.SBTTL	ERROR			; No room in output string
                                     035F   666 ;++
                                     035F   667 ; Enter here if output string is too small.
                                     035F   668 ; Fill output string with asterisks.
                                     035F   669 ; Returns to User.
                                     035F   670 ;--
                                     035F   671 
                                     035F   672 ERROR:
            50         08 BC     7D  035F   673 	MOVQ	@out_str(AP), R0	; Get string address in R1
            6E            00     2C  0363   674 	MOVC5	#0,(SP),#^A/*/,R0,(R1)	;  ill output string with asterisks
            50            2A         0366       
                          61         0368       
            50   00000000'8F     D0  0369   675 	MOVL	#FOR$_OUTCONERR,R0	; Load error count
                                 04  0370   676 	RET				; Not to local caller
                                     0371   677 	.END
FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  17
SYMBOL TABLE                                                                                                                    (16)

ASCII_OUT        0000029C R     02   
ASCII_OUT_1      000002A0 R     02   
CARRY_PROP       0000005A R     02   
CONV_INT_FRAC    000000F2 R     02   
CVTZERO          0000015F R     02   
CVT_FRAC         00000176 R     02   
CVT_FRACTION     000001FE R     02   
DIGITS_IN_FRAC = 0000000C            
DLOOP            000002F5 R     02   
D_OR_E_OUT_CONV  0000000E R     02   
ERROR            0000035F R     02   
EXP_FORM         0000026E R     02   
EXP_LETTER     = FFFFFFFC            
E_EXPONENT       00000029 R     02   
FOR$CNV_OUT_D    00000000 RG    02   
FOR$CNV_OUT_E    00000008 RG    02   
FOR$CNV_OUT_F    0000003B RG    02   
FOR$CNV_OUT_G    00000081 RG    02   
FOR$K_ERR_PREFX= 00000018            
FOR$_OUTCONERR   ********   X   01   
FRACT_DIGITS     00000226 R     02   
FRACT_OFFSET     00000215 R     02   
FRAME          = FFFFFFB8            
INIT_C_SIZE      00000288 R     02   
INT0             000001CC R     02   
INT3             00000179 R     02   
INT3_2           0000018C R     02   
INTL0          = FFFFFFE8            
INTL1          = FFFFFFEC            
INTL2          = FFFFFFF0            
INTL3          = FFFFFFF4            
INT_LOOP         00000184 R     02   
LEAD_ZERO_OUT    000002DC R     02   
MINUS          = FFFFFFB8            
MTH$K_ERR_PREFX= 00000016            
MTH__FLOOVEMAT = 00000058            
MTH__FLOUNDMAT = 00000059            
MTH__INVARG    = 00000051            
MTH__LOGZERNEG = 00000053            
MTH__SINSIGLOS = 00000057            
MTH__SQUROONEG = 00000054            
MTH__UNDEXP    = 00000052            
MTH__WRONUMARG = 00000050            
OUT1             0000035E R     02   
OUTPUT_DIGITS    000002F0 R     02   
OUT_STR        = 00000008            
PACKED         = FFFFFFE8            
REGMASK        = 00000FFC            
RET              00000037 R     02   
SCALE          = FFFFFFF8            
SCALE_FACTOR   = 00000010            
SEPARATE       = FFFFFFEE            
VALUE          = 00000004            


PROGRAM SECTION SYNOPSIS

FOR$CNV_OUT     ; FORTRAN FLOATING OUTPUT CONVERSION ROUTINES    21-AUG-1978 18:54:25   VAX-11 MACRO X0.3-11               Page  18
PROGRAM SECTION SYNOPSIS                                                                                                        (16)

.  ABS  .        00000000      00     NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT BYTE  
. BLANK .        00000000      01     NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT BYTE  
FOR$CODE         00000371      02       PIC   USR   CON   REL   LCL   SHR   EXE   RD  NOWRT LONG  


THERE WERE NO ERRORS OR WARNINGS.
26550. BYTES LEFT IN FREE MEMORY POOL.
OBJ$:FORCNVOR,LIS$:FORCNVOR/-SP=LIB$:S/ML,SRC$:P,FORCNVOR
0 MLB DIR RDS - 0 GETS TO DEFINE 0 MACROS. 9 INTER. FILE WRITES. 
