FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   0
TABLE OF CONTENTS   

   (2)      96  HISTORY		; Detailed Current Edit History
   (3)     109  DECLARATIONS
   (4)     193  FOR$CNV_IN_DEFG		; {D,E,F,G} format input conve
   (12)    684  RGET	- get next character
   (13)    702  MUL5_R5	- multiply FAC by 5
   (14)    724  DIV10_R5	- divide FAC by 10
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   1
01-11                                                                                                                            (1)

                                     0000     1 	.TITLE	FOR$FCNVIR	; FORTRAN REAL INPUT CONVERSION ROUTINE
                                     0000     2 	.IDENT	/01-11/		; File: FORCNVIR.MAR
                                     0000     3 
                                     0000     4 ;
                                     0000     5 ; Copyright (C) 1977
                                     0000     6 ; Digital Equipment Corporation, Maynard, Massachusetts 01754
                                     0000     7 ;
                                     0000     8 ; This software is furnished under a license for use only on a single
                                     0000     9 ; computer  system  and  may be copied only with the inclusion of the
                                     0000    10 ; above copyright notice. This software, or any other copies thereof,
                                     0000    11 ; may not be provided or otherwise made available to any other person
                                     0000    12 ; except for use on such system and to one who agree to these license 
                                     0000    13 ; terms.  Title to  and  ownership of the software shall at all times 
                                     0000    14 ; remain in DEC.
                                     0000    15 ;
                                     0000    16 ; The information in the software is subject to change without notice
                                     0000    17 ; and should  not  be construed  as a commitment by Digital Equipment 
                                     0000    18 ; Corporation.
                                     0000    19 ;
                                     0000    20 ; DEC assumes  no  responsibility  for the use or  reliability of its
                                     0000    21 ; software on equipment which is not supplied by DEC.
                                     0000    22 ;
                                     0000    23 ;
                                     0000    24 ; FACILITY: MATH LIBRARY
                                     0000    25 ;++
                                     0000    26 ; ABSTRACT:
                                     0000    27 ;
                                     0000    28 ; Procedures to perform Fortran Dw.d, Ew.d, Fw.d, and Gw.d formatted
                                     0000    29 ; input conversion including nP scaling. FOR$CNV_IN_DEFGis an input conversion routi
                                     0000    30 ; which takes a fixed length string descriptor and performs the data conversion
                                     0000    31 ; editing and transmission according to the input format specified also
                                     0000    32 ; by its arguments. The result returned is a double precision value
                                     0000    33 ; passed as a parameter.
                                     0000    34 ;
                                     0000    35 ;--
                                     0000    36 ;
                                     0000    37 ; VERSION: 01
                                     0000    38 ;
                                     0000    39 ; HISTORY:
                                     0000    40 ;
                                     0000    41 ; AUTHOR:
                                     0000    42 ;	Peter Yuo, 25-Apr-77: Version 01
                                     0000    43 ;
                                     0000    44 ; MODIFIED BY:
                                     0000    45 ;
                                     0000    46 ; 01-4	Peter Yuo, 3-Jun-77
                                     0000    47 ;
                                     0000    48 ;
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   2
01-11           HISTORY  ; Detailed Current Edit History                                                                         (2)

                                     0000    50 	.SBTTL	HISTORY		; Detailed Current Edit History
                                     0000    51 
                                     0000    52 
                                     0000    53 ; Edit History for Version 01 of FOR$FCNVIR
                                     0000    54 ;
                                     0000    55 ; 01-4	Add code to handle optional scale factor and digits in fraction
                                     0000    56 ; 01-5  Fix bug in scale factor introduced in 01-4. Also shorten code
                                     0000    57 ; 01-7	Fix bug in calculating S if there is a scale_factor
                                     0000    58 ; 01-8	Fix bug in calculating S. If exponent field exists in input
                                     0000    59 ;	P factor should be ignored.
                                     0000    60 ; 01-9	Fixed bug in calculating S in order to take care of oveflow happened.
                                     0000    61 ; 01-10	Change order of parameters to conform to standard.  JMT 15-Feb-78
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   3
01-11           DECLARATIONS                                                                                                     (3)

                                     0000    63 	.SBTTL	DECLARATIONS
                                     0000    64 
                                     0000    65 ;
                                     0000    66 ; INCLUDE FILES:
                                     0000    67 ;
                                     0000    68 
                                     0000    69 ;
                                     0000    70 ; EXTERNAL SYMBOLS:
                                     0000    71 ;
                                     0000    72 	.DSABL	GBL
                                     0000    73 	.EXTRN	FOR$_INPCONERR
                                     0000    74 	.EXTRN	SS$_NORMAL
                                     0000    75 
                                     0000    76 ;
                                     0000    77 ; MACROS:
                                     0000    78 ;
                                     0000    79 
                                     0000    80 ;
                                     0000    81 ; PSECT DECLARATIONS:
                                     0000    82 ;
                                     0000    83 
                                 00000000    84 	.PSECT	FOR$CODE	PIC, SHR, LONG, EXE, NOWRT
                                     0000    85 
                                     0000    86 ;
                                     0000    87 ; EQUATED SYMBOLS:
                                     0000    88 ;
                                     0000    89 
                                     0000    90 
                           000001FC  0000    91 	REGMASK		= ^M<R2, R3, R4, R5, R6, R7, R8>
                                     0000    92 					; register save mask
                                     0000    93 					; Note: integer overflow not enabled
                                     0000    94 
                                     0000    95 ;+
                                     0000    96 ; The following symbols are used to indicate the bit position of the flag
                                     0000    97 ; register.
                                     0000    98 ;-
                                     0000    99 
                           00000000  0000   100 	V_NEGATIVE	= 0		; flag bit: 1 if negative sign
                           00000001  0000   101 	V_DEC_POINT	= 1		; flag bit: 1 if decimal point is seen
                           00000002  0000   102 	M_DEC_POINT	= ^X02		; mask for V_DEC_POINT
                           00000002  0000   103 	V_NEG_DECEXP	= 2		; flag bit: 1 if exponent has negative sign
                           00000004  0000   104 	M_NEG_DECEXP	= ^X04		; mask for V_NEG_DEXEXP
                           00000003  0000   105 	V_DECEXP	= 3		; flag bit: 1 if exponent field exist
                           00000008  0000   106 	M_DECEXP	= ^X08		; mask for V_DECEXP
                                     0000   107 
                                     0000   108 ;+
                                     0000   109 ; Constants
                                     0000   110 ;-
                                     0000   111 
                           0CCCCCCC  0000   112 	L_2P31_DIV_10	= 214748364	; (2**31)/10
                           00000CCC  0000   113 	L_2P15_DIV_10	= 3276		; (2**15)/10
                                     0000   114 
                                     0000   115 ; REGISTER USAGE:
                                     0000   116 ;
                                     0000   117 ; Before scaling:
                                     0000   118 ;	R0 - W and then #CHAR_REMAINING, # of remaining bytes in input string
                                     0000   119 ;	     (not counting the current one)
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   4
01-11           DECLARATIONS                                                                                                     (3)

                                     0000   120 ;	R1 - POINTER_TO_INPUT, address of next available byte (not counting the
                                     0000   121 ;	     current one)
                                     0000   122 ;	R2 - DECIMAL_EXPONENT integer value after D or E
                                     0000   123 ;	R3 - ASCII(current_char) - ASCII("0")
                                     0000   124 ;	R4/R5 - FAC, 64 bit floating accumulator
                                     0000   125 ;	R6 - flag register
                                     0000   126 ;	R7 - D or the number of digits after decimal point if decimal point occurs
                                     0000   127 ;	R8 - number of digits read after integer overflow happened
                                     0000   128 ;
                                     0000   129 ; After scaling:
                                     0000   130 ;	R0 - S, DECIMAL_EXPONENT + scale_factor - (if decimal_point is found then
                                     0000   131 ;	 number of digits after decimal point else digits_in_fract(AP))
                                     0000   132 ;	R1 - BINARY_EXPONENT
                                     0000   133 ;	R2 - scratch
                                     0000   134 ;	R3 - extra-precision
                                     0000   135 ;	R4/R5 - FAC
                                     0000   136 ;	R6 - flag register
                                     0000   137 ;
                                     0000   138 ;
                                     0000   139 ;
                                     0000   140 ; ABBREVIATION USED:
                                     0000   141 ;
                                     0000   142 ;	W - width of the input string
                                     0000   143 ;	D - fraction size
                                     0000   144 ;	FAC - 64 bit floating accumulator
                                     0000   145 ;
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   5
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (4)

                                     0000   147 	.SBTTL	FOR$CNV_IN_DEFG		; {D,E,F,G} format input conversion routine
                                     0000   148 
                                     0000   149 ;++
                                     0000   150 ; FUNCTIONAL DESCRIPTION:
                                     0000   151 ;
                                     0000   152 ;    Algorithmic steps:
                                     0000   153 ;	1. Initialization
                                     0000   154 ;	2. Scan for first non-blank character.
                                     0000   155 ;	   The current character can be:
                                     0000   156 ;	   case 1) "+"
                                     0000   157 ;		increase pointer, go to step 3
                                     0000   158 ;	   case 2) "-"
                                     0000   159 ;		increase pointer, go to step 3
                                     0000   160 ;	   case 3) digit
                                     0000   161 ;		go to step 3
                                     0000   162 ;	   case 4) "."
                                     0000   163 ;		increase pointer, go to step 4
                                     0000   164 ;	   case 5) run out of string
                                     0000   165 ;		go to SCALE
                                     0000   166 ;	   case 6) others
                                     0000   167 ;		ERROR
                                     0000   168 ;	3. Collect integer digits, treat blanks as zeroes, until a non-digit
                                     0000   169 ;	   is encounted.
                                     0000   170 ;	   The current character can be:
                                     0000   171 ;	   case 1) "+"
                                     0000   172 ;		increment pointer, go to step 5.0
                                     0000   173 ;	   case 2) "-"
                                     0000   174 ;		increment pointer, go to step 5.0
                                     0000   175 ;	   case 3) "D"
                                     0000   176 ;		increment pointer, go to step 5.1
                                     0000   177 ;	   case 4) "E"
                                     0000   178 ;		increment pointer, go to step 5.1
                                     0000   179 ;	   case 5) "."
                                     0000   180 ;		increment pointer, go to step 4
                                     0000   181 ;	   case 6) others
                                     0000   182 ;		ERROR
                                     0000   183 ;	4. Collect fraction digits, treat blanks as zeroes, until a non-digit
                                     0000   184 ;	   is encounted. Count how many digits after decimal pointer.
                                     0000   185 ;	   The current character can be:
                                     0000   186 ;	   case 1) "+"
                                     0000   187 ;		increment pointer, go to step 5.0
                                     0000   188 ;	   case 2) "-"
                                     0000   189 ;		increment pointer, go to step 5.0
                                     0000   190 ;	   case 3) "D"
                                     0000   191 ;		increment pointer, go to step 5.1
                                     0000   192 ;	   case 4) "E"
                                     0000   193 ;		increment pointer, go to step 5.1
                                     0000   194 ;	   case 5) run out of string
                                     0000   195 ;		go to SCALE
                                     0000   196 ;	   case 6) others
                                     0000   197 ;		ERROR
                                     0000   198 ;	5.0 Scan for first non-blank character.
                                     0000   199 ;	   The current character can be:
                                     0000   200 ;	    case 1) digit
                                     0000   201 ;		go to step 6
                                     0000   202 ;	   case 2) run out of string
                                     0000   203 ;		go to SCALE
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   6
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (4)

                                     0000   204 ;	   case 3) others
                                     0000   205 ;		ERROR
                                     0000   206 ;	5.1 Scan for first non-blank character.
                                     0000   207 ;	   The current character can be:
                                     0000   208 ;	   case 1) "+"
                                     0000   209 ;		increment pointer, go to step 6.
                                     0000   210 ;	   case 2) "-"
                                     0000   211 ;		increment pointer, go to step 6.
                                     0000   212 ;	   case 3) digit
                                     0000   213 ;		go to step 6
                                     0000   214 ;	   case 4) run out of string
                                     0000   215 ;		go to SCALE
                                     0000   216 ;	   case 5) others
                                     0000   217 ;		ERROR
                                     0000   218 ;	6. Collect exponent digits, treat blanks as zeroes.
                                     0000   219 ;	   case 1) run out of string
                                     0000   220 ;		go to SCALE
                                     0000   221 ;	   case 2) others
                                     0000   222 ;		ERROR
                                     0000   223 ;	SCALE:
                                     0000   224 ;	7. If FAC contains zero, no scaling is necessary.
                                     0000   225 ;	   RETURN
                                     0000   226 ;	8. Initialize BINARY_EXPONENT to 276(octal), (excess 200(octal) + 63 - 1)
                                     0000   227 ;	   [ 63 is the number of signifcant digits in FAC (not including the sign)
                                     0000   228 ;	     1 is the hidden most significant bit]
                                     0000   229 ;	   BINARY_EXPONENT will later be modified each time FAC is scaled up or
                                     0000   230 ;	   down. Finally, BINARY_EXPONENT will be used to insert into exponent
                                     0000   231 ;	   field of the real number.
                                     0000   232 ;	9. Decide the number of places th scale up or down:
                                     0000   233 ;	   S = DECIMAL_EXPONENT - scale_factor - (if decimal pointer is found then
                                     0000   234 ;	   # of digits after decimal point else D)
                                     0000   235 ;	   [ if S = 0, then just do normalization,
                                     0000   236 ;	     if S > 0, then scale FAC up,
                                     0000   237 ;	     if S < 0, then scale FAC down.
                                     0000   238 ;	10. Scale FAC up:
                                     0000   239 ;	    If S > 38 then ERROR.
                                     0000   240 ;	L1: if S > 0, then
                                     0000   241 ;	    begin
                                     0000   242 ;	    L2: multiply FAC by 2;
                                     0000   243 ;		compare FAC1 with 429,496,729 and decide if the number is FAC
                                     0000   244 ;		is too big to multiply by 5;
                                     0000   245 ;		if yes, shift FAC right by 1 place and go back to L2;
                                     0000   246 ;		multiply FAC by 5;
                                     0000   247 ;		S = S - 1;
                                     0000   248 ;		go to L1;
                                     0000   249 ;	    end;
                                     0000   250 ;	12. Normalization and scale down. (S >= 0)
                                     0000   251 ;	    [ Actually, in order to prevent loss of accuracy on divide while
                                     0000   252 ;	    normalizing FAC, we continue the division process through the
                                     0000   253 ;	    nomalization to ensure maximun accuracy]
                                     0000   254 ;	13. Make FAC into floating form and return.
                                     0000   255 ;
                                     0000   256 ;	ERROR: a value of +0.0 is returned.
                                     0000   257 ;
                                     0000   258 ; CALLING SEQUENCE:
                                     0000   259 ;
                                     0000   260 ;	Fits.wlc.v = FOR$CNV_IN_DEFG (in_str.rt.ds, value.wd.r [, digits_in_fract.rlu.v
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   7
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (4)

                                     0000   261 ;		     [, scale_factor.rl.v]])
                                     0000   262 ;
                                     0000   263 ;
                                     0000   264 ; INPUT PARAMETERS:
                                     0000   265 ;
                           00000004  0000   266 	in_str	= 4			; input string descriptor, in_str.rt.ds
                           0000000C  0000   267 	digits_in_fract	= 12		; digits in fraction(D),
                                     0000   268 					; digits_in_fraction.rlu.v
                           00000010  0000   269 	scale_factor	= 16		; (optional) signed scale factor(P)
                                     0000   270 					; scale_factor.rl.v
                                     0000   271 ;
                                     0000   272 ; IMPLICIT INPUTS:
                                     0000   273 ;	NONE
                                     0000   274 ;
                                     0000   275 ; OUTPUT PARAMETERS:
                                     0000   276 ;
                           00000008  0000   277 	value	= 8			; double precision value, value.wd.r
                                     0000   278 ;
                                     0000   279 ; IMPLICIT OUTPUTS:
                                     0000   280 ;	NONE
                                     0000   281 ;
                                     0000   282 ; COMPLETION CODES:
                                     0000   283 ;
                                     0000   284 ;	FOR$_INPCONERR - error if illegal character in input string value parameter receiv
                                     0000   285 ;	    an undefined floating operand.
                                     0000   286 ;	SS$_NORMAL - success
                                     0000   287 ;
                                     0000   288 ; SIDE EFFECTS:
                                     0000   289 ;	NONE
                                     0000   290 ;
                                     0000   291 ;--
                                     0000   292 
                                     0000   293 
                                     0000   294 
                               01FC' 0000   295 	.ENTRY	FOR$CNV_IN_DEFG, REGMASK
                                     0002   296 					; entry for FOR$CNV_IN_DEFG
                                     0002   297 					; Note: integer overflow not enabled since
                                     0002   298 					; we are checking it
                                     0002   299 
                                     0002   300 ;+
                                     0002   301 ; Initialization
                                     0002   302 ;-
                                     0002   303 
            50         04 BC     7D  0002   304 	MOVQ	@in_str(AP), R0		; R0 = width of the input string
                                     0006   305 					; R1 = address of the input string
                          52     D4  0006   306 	CLRL	R2			; R2 = DECIMAL_EXPONENT = 0
                          54     7C  0008   307 	CLRQ	R4			; R4/R5 = FAC = 0
                          56     D4  000A   308 	CLRL	R6			; clear flag register
            57            07     D0  000C   309 	MOVL	#7, R7			; R7 = default digits_in_fract
            03            6C     91  000F   310 	CMPB	(AP), #<digits_in_fract/4>
                                     0012   311 					; is the optional digits_in_fract present
                          04     1F  0012   312 	BLSSU	10$			; branch if none
            57         0C AC     D0  0014   313 	MOVL	digits_in_fract(AP), R7	; R7 = fraction size
                          58     D4  0018   314 10$:	CLRL	R8			; clear number of digits read after
                                     001A   315 					; overflow to zero
                                     001A   316 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   8
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (5)

                                     001A   318 ;+
                                     001A   319 ; Scan for first non-blank character. If there is no non-blank character, return
                                     001A   320 ; a zero. Otherwise, depending on what current character is, different actions
                                     001A   321 ; will be taken.
                                     001A   322 ;-
                                     001A   323 
            50            20     3B  001A   324 	SKPC	#^A/ /, R0, (R1)	; skip blanks
                          61         001D       
                                     001E   325 					; R0 = #CHAR_REMAINING
                                     001E   326 					; R1 = POINTER_TO_INPUT
                                     001E   327 					; Z bit is set if R0 = 0
                          03     14  001E   328 	BGTR	30$			; branch to 30$ to continue
                          00CC   31  0020   329 	BRW	SCALE			; branch to SCALE if run out of input
                                     0023   330 					; string, return with R4/R5 = 0
            53            61     9A  0023   331 30$:	MOVZBL	(R1), R3		; R3 = ASCII(current_char)
                                     0026   332 					; R1 = pointer to next available char
            2D            53     91  0026   333 	CMPB	R3, #^A/-/		; is current char a "-" sign?
                          04     12  0029   334 	BNEQ	40$			; branch if not
            56            00     E3  002B   335 	BBCS	#V_NEGATIVE, R6, READ_IN_NEXT
                          0F         002E       
                                     002F   336 					; set negative flag and branch to
                                     002F   337 					; read in next char
            2B            53     91  002F   338 40$:	CMPB	R3, #^A/+/		; is current char a "+" sign?
                          0A     13  0032   339 	BEQL	READ_IN_NEXT		; yes, branch to read in next char
            2E            53     91  0034   340 	CMPB	R3, #^A/./		; is current char a "."?
                          09     12  0037   341 	BNEQ	DIGIT_LOOP		; no, branch to check if it is a digit
            56            02     88  0039   342 	BISB	#M_DEC_POINT, R6	; set decimal point encounted flag
                          57     D4  003C   343 	CLRL	R7			; decimal point encounted, D spec will
                                     003E   344 					; have no effect
                                     003E   345 
                                     003E   346 ;+
                                     003E   347 ; Skip over "+", "-", or "."
                                     003E   348 ;-
                                     003E   349 
                                     003E   350 READ_IN_NEXT:
                          50     D7  003E   351 	DECL	R0			; R0 = #CHAR_REMAINING
                          51     D6  0040   352 	INCL	R1			; R1 = POINTER_TO_INPUT
                                     0042   353 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page   9
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (6)

                                     0042   355 ;+
                                     0042   356 ; Loop to collect integer and (/or) fraction digits, treat blanks as zeroes,
                                     0042   357 ; until a non-digit is encounted.
                                     0042   358 ;-
                                     0042   359 
                                     0042   360 DIGIT_LOOP:
                          50     D7  0042   361 	DECL	R0			; decrement #CHAR_REMAINING
                          03     18  0044   362 	BGEQ	10$			; branch to CHECK_DIGIT to continue
                          00A6   31  0046   363 	BRW	SCALE			; no more input char, branch to SCALE
                          016C   30  0049   364 10$:	BSBW	RGET			; get next char (convert blank into zero)
                                     004C   365 CHECK_DIGIT:
            53            30     C2  004C   366 	SUBL	#^A/0/, R3		; R3 = ASCII(current_char) - ASCII("0")
            09            53     D1  004F   367 	CMPL	R3, #9			; check if current char is a digit
                          22     1A  0052   368 	BGTRU	NOT_DIGIT		; branch if it is a digit
   0CCCCCCC 8F            55     D1  0054   369 	CMPL	R5, #L_2P31_DIV_10	; compare HP(FAC) (higher part of FAC) with
                                     005B   370 					; (2**31)/10 (2,147,483,648 [=2**31 =
                                     005B   371 					; the largest number in longword] divided
                                     005B   372 					; by 10) to see if it is too big to
                                     005B   373 					; multiply by 10
                          04     1B  005B   374 	BLEQU	10$			; branch if HP(FAC) =< (2**31)/10
                          58     D6  005D   375 	INCL	R8			; this is an integer overflow, log it
                                     005F   376 					; and continue as though overflow didn't
                                     005F   377 					; happened. FAC will stay the same value,
                                     005F   378 					; but it will be used to scale FAC later
                          0D     11  005F   379 	BRB	2$			; continue on
                          0160   30  0061   380 10$:	BSBW	MUL5_R5			; do multiply by 10 by first multiply FAC by
                                     0064   381 					; 5, and
            54            01     79  0064   382 	ASHQ	#1, R4, R4		; then multiply it by 2
                          54         0067       
            54            53     C0  0068   383 	ADDL	R3, R4			; add in new digit to LP(FAC)
            55            00     D8  006B   384 	ADWC	#0, R5			; propogate carry to HP(FAC)
            56            01     E1  006E   385 2$:	BBC	#V_DEC_POINT, R6, DIGIT_LOOP
                          D0         0071       
                                     0072   386 					; check if decimal point has been encounted
                                     0072   387 					; , branch back to read more char if not
                          57     D6  0072   388 	INCL	R7			; increment fraction size by 1 and then
                          CC     11  0074   389 	BRB	DIGIT_LOOP		; branch back to read in more char
                                     0076   390 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  10
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (7)

                                     0076   392 ;+
                                     0076   393 ; A non-digit has found. Check if it is "+", "-", "D", "E" (or "d", "e"??) and
                                     0076   394 ; take different action. Otherwise it is an error.
                                     0076   395 ;-
                                     0076   396 
                                     0076   397 NOT_DIGIT:
   FFFFFFFE 8F            53     D1  0076   398 	CMPL	R3, #<^A/./-^A/0/>	; check if current char is a "."
                          1E     13  007D   399 	BEQL	DECIMAL_POINT		; branch to DECIMAL_POINT if yes
   FFFFFFFB 8F            53     D1  007F   400 	CMPL	R3, #<^A/+/-^A/0/>	; "+"?
                          1D     13  0086   401 	BEQL	EXPONX			; branch to EXPONX to proces exponent
   FFFFFFFD 8F            53     D1  0088   402 	CMPL	R3, #<^A/-/-^A/0/>	; "-"?
                          14     13  008F   403 	BEQL	EXPONX			; branch to EXPONX to process exponent
            14            53     D1  0091   404 	CMPL	R3, #<^A/D/-^A/0/>	; "D"?
                          13     13  0094   405 	BEQL	EXPON			; branch to EXPON to process exponent
            15            53     D1  0096   406 	CMPL	R3, #<^A/E/-^A/0/>	; "E"?
                          0E     13  0099   407 	BEQL	EXPON			; branch to EXPON to process exponent
                                     009B   408 ;	CMPL	R3, #^A/d/-^A/0/>	; "d"?
                                     009B   409 ;	BEQL	EXPON			; branch to EXPON to process exponet
                                     009B   410 ;	CMPL	R3, #^A/e/-^A/0/>	; "e"?
                                     009B   411 ;	BEQL	EXPON			; branch to EXPON to process exponent
                          60     11  009B   412 	BRB	ERROR			; branch to ERROR if it is a illegal char
                                     009D   413 
                                     009D   414 ;+
                                     009D   415 ; Decimal point has been found
                                     009D   416 ;-
                                     009D   417 
                                     009D   418 DECIMAL_POINT:
            56            01     E2  009D   419 	BBSS	#V_DEC_POINT, R6, ERROR	; branch to ERROR if decimal point has
                          5C         00A0       
                                     00A1   420 					; already been encounted
                          57     D4  00A1   421 	CLRL	R7			; decimal point encounted, D spec will
                                     00A3   422 					; have no effect
                          9D     11  00A3   423 	BRB	DIGIT_LOOP		; branch back to DIGIT_LOOP to get
                                     00A5   424 					; more char
                                     00A5   425 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  11
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (8)

                                     00A5   427 ;+
                                     00A5   428 ; Loop to collect digits, store the accumulated DECIMAL_EXPONENT in R2
                                     00A5   429 ;-
                                     00A5   430 
                          50     D6  00A5   431 EXPONX:	INCL	R0			; to rescan "+" or "-", increment
                                     00A7   432 					; #CHAR_REMAINING by 1
                          51     D7  00A7   433 	DECL	R1			; back up POINTER_TO_INPUT by 1
                          52     D4  00A9   434 EXPON:	CLRL	R2			; initialize DECIMAL_EXPONENT to 0
                                     00AB   435 EXP_LOOP0:
            50            20     3B  00AB   436 	SKPC	#^A/ /, R0, (R1)	; skip blanks
                          61         00AE       
                          34     15  00AF   437 	BLEQ	EXP_DONE		; branch to DONE if end of string
            53            61     9A  00B1   438 	MOVZBL	(R1), R3		; R3 = current char
            2B            53     D1  00B4   439 	CMPL	R3, #^A/+/		; "+"?
                          08     13  00B7   440 	BEQL	EXP_SIGN		; yes, get next char to skip sign
            2D            53     D1  00B9   441 	CMPL	R3, #^A/-/		; "-"?
                          07     12  00BC   442 	BNEQ	EXP_LOOP		; no, go check digit
            56            04     88  00BE   443 	BISB	#M_NEG_DECEXP, R6	; set negative DECIMAL_EXPONENT flag
                                     00C1   444 EXP_SIGN:
                          50     D7  00C1   445 	DECL	R0			; R0 = #CHAR_REMAINING
                          51     D6  00C3   446 	INCL	R1			; R1 = POINTER_TO_INPUT
                                     00C5   447 EXP_LOOP:
                          50     D7  00C5   448 	DECL	R0			; R0 = #CHAR_REMAINING
                          1C     19  00C7   449 	BLSS	EXP_DONE		; branch to DONE, if no more char left
                          00EC   30  00C9   450 	BSBW	RGET			; get next char (convert blank to zero)
            53            30     C2  00CC   451 	SUBL	#^A/0/, R3		; R3 = ASCII(current_char) - ASCII("0")
            09            53     D1  00CF   452 	CMPL	R3, #9			; check if current char is a digit
                          29     1A  00D2   453 	BGTRU	ERROR			; branch to ERROR if not
   00000CCC 8F            52     D1  00D4   454 	CMPL	R2, #L_2P15_DIV_10	; compare R2 with (2**15)/10
                          20     1E  00DB   455 	BGEQU	ERROR			; branch to ERROR if DECIMAL_EXPONENT is too
                                     00DD   456 					; big to hold in a word
            52            0A     C4  00DD   457 	MULL	#10, R2			; DECIMAL_EXPONENT = DECIMAL_EXPONENT * 10
            52            53     C0  00E0   458 	ADDL	R3, R2			; DECIMAL_EXPONENT = DECIMAL_EXPONENT * 10
                                     00E3   459 					; + new_digit
                          E0     11  00E3   460 	BRB	EXP_LOOP		; branch to get more char
                                     00E5   461 	
                                     00E5   462 EXP_DONE:
            56            02     E1  00E5   463 	BBC	#V_NEG_DECEXP, R6, 1$	; branch if negative DECIMAL_EXPONENT flag
                          03         00E8       
                                     00E9   464 					; is not set
            52            52     CE  00E9   465 	MNEGL	R2, R2			; negative DECIMAL_EXPONENT
            56            08     88  00EC   466 1$:	BISB	#M_DECEXP, R6		; indicates exponent field exist
                                     00EF   467 
                                     00EF   468 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  12
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                  (9)

                                     00EF   470 ;+
                                     00EF   471 ; Done collecting input characters for digits and/or exponent
                                     00EF   472 ; If FAC=0, no scaling is necessary, just store 0.0 and return.
                                     00EF   473 ;-
                                     00EF   474 
                                     00EF   475 SCALE:
                          54     D5  00EF   476 	TSTL	R4			; compare HP(FAC) with 0
                          15     12  00F1   477 	BNEQ	INIT_BINEXP		; branch if HP(FAC) not equal to 0
                          55     D5  00F3   478 	TSTL	R5			; compare LP(FAC) with 0
                          11     12  00F5   479 	BNEQ	INIT_BINEXP		; branch LP(FAC) not equal to 0
                       08 BC     7C  00F7   480 	CLRQ	@value(AP)		; @value(AP) = 0
                          00B0   31  00FA   481 	BRW	FOR$CNV_IN_EXIT		; success return
                                     00FD   482 
                                     00FD   483 ;+
                                     00FD   484 ; ERROR return
                                     00FD   485 ;-
                                     00FD   486 
                       08 BC     7C  00FD   487 ERROR:	CLRQ	@value(AP)		; @value(AP) = 0
            50   00000000'8F     D0  0100   488 	MOVL	#FOR$_INPCONERR, R0	; R0 = error return code
                                 04  0107   489 	RET				; error return
                                     0108   490 ;+
                                     0108   491 ; Initialize BINARY_EXPONENT to 276(Octal) [excess 200(octal) + 63 1 1, 63
                                     0108   492 ; is the number of significant digits in FAC (not including the sign)
                                     0108   493 ; 1 is for the hidden most significant bit]
                                     0108   494 ; BINARY_EXPONENT will later be modified each time FAC is scaled up
                                     0108   495 ; or down. Finally, BINARY_EXPONENT will be used to insert into exponent field
                                     0108   496 ; of the real number.
                                     0108   497 ;-
                                     0108   498 
                                     0108   499 INIT_BINEXP:
            51       00BE 8F     3C  0108   500 	MOVZWL	#^O276, R1		; R1 = BINARY_EXPONENT = 276(octal)
                                     010D   501 
                                     010D   502 ;+
                                     010D   503 ; Decide the number of places to scale up or down.
                                     010D   504 ; S = DECIMAL_EXPONENT - scale_factor(AP) - (if decimal point is
                                     010D   505 ;	found then number_of_digits_after_decimal_point else D)
                                     010D   506 ; if S > 0 then scale FAC up
                                     010D   507 ; if S < 0 then scale it down
                                     010D   508 ; if S = 0 then no scaling is necessary
                                     010D   509 ;-
                                     010D   510 
            50            52     D0  010D   511 	MOVL	R2, R0			; R0 = DECIMAL_EXPONENT
            04            6C     91  0110   512 	CMPB	(AP), #<scale_factor/4>	; is optional scale_factor present
                          08     1F  0113   513 	BLSSU	10$			; branch if none$
            56            03     E0  0115   514 	BBS	#V_DECEXP, R6, 10$	; exponent field exists, P factor
                          04         0118       
                                     0119   515 					; ignored
            50         10 AC     C2  0119   516 	SUBL	scale_factor(AP), R0	; R0 = DECIMAL_EXPONENT - scale_factor(AP)
            50            57     C2  011D   517 10$:	SUBL	R7, R0			; R0 = S  = DECIMAL_EXPONENT -
                                     0120   518 					; [scale_factor (AP)] - (if decimal point is
                                     0120   519 					; found then number_of_digits_after
                                     0120   520 					; _decimal_point else D)
                                     0120   521 
            50            58     C0  0120   522 	ADDL	R8, R0			; adjust S if overflow happened
                                     0123   523 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  13
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                 (10)

                                     0123   525 ;+
                                     0123   526 ; Scale FAC up, (R0 = S > 0)
                                     0123   527 ;-
                                     0123   528 
            26            50     D1  0123   529 	CMPL	R0, #38			; compare S with 38, (the floating datum is
                                     0126   530 					; within 0.29*10**-38 and 1.7*10**38
                          D5     14  0126   531 	BGTR	ERROR			; branch if out of range
                          50     D5  0128   532 L1:	TSTL	R0			; test for S
                          19     15  012A   533 	BLEQ	NORMAL0			; S =< 0, branch to do normalization
                          51     D6  012C   534 L2:	INCL	R1			; multiply FAC by 2 
   19999999 8F            55     D1  012E   535 	CMPL	R5, #429496729		; see if FAC is too big to multiply by 5
                          07     1A  0135   536 	BGTRU	1$			; branch if yes
                          008A   30  0137   537 	BSBW	MUL5_R5			; multiply FAC by 5
                          50     D7  013A   538 	DECL	R0			; S = S - 1
                          EA     11  013C   539 	BRB	L1			; go back to L1
            54         FF 8F     79  013E   540 1$:	ASHQ	#-1, R4, R4		; divide FAC by 2
                          54         0142       
                          E7     11  0143   541 	BRB	L2			; and go back to L2 to multiply FAC by 2
                                     0145   542 					; so the magnitude of FAC doesn't change
                                     0145   543 
                                     0145   544 
                                     0145   545 ;+
                                     0145   546 ; Normalization and scale down, (R0 = S =< 0)
                                     0145   547 ; [Actually, in order to prevent loss of accuracy on divide while normalization
                                     0145   548 ; FAC, we continue the division process through the normalization to ensure
                                     0145   549 ; maximun accuracy]
                                     0145   550 ;-
                                     0145   551 
                                     0145   552 NORMAL0:
                          53     D4  0145   553 	CLRL	R3			; set extra-precision to zero to begin with
            55            1E     E0  0147   554 NORMAL:	BBS	#30, R5, SCALE_DOWN	; check 30th bit of HP(FAC) (next to sign bit)
                          22         014A       
                                     014B   555 					; and see if FAC is normalized
            54            01     79  014B   556 	ASHQ	#1, R4, R4		; shift FAC left 1 bit
                          54         014E       
            53   50000000 8F     D1  014F   557 	CMPL	#^X50000000, R3		; highest 4 bit of R3 contains extra-precision
                                     0156   558 					; 5 is the mid-point for rounding
                          07     1A  0156   559 	BGTRU	1$			; branch if below 5
            53   B0000000 8F     C0  0158   560 	ADDL	#^XB0000000, R3		; do rounding if above or equal to 5
            54            00     D8  015F   561 1$:	ADWC	#0, R4			; add carry to R4 if there is any
            55            00     D8  0162   562 	ADWC	#0, R5			; propogate carry to R5
            53            01     78  0165   563 	ASHL	#1, R3, R3		; shift extra_prec left by 1
                          53         0168       
                          51     D7  0169   564 	DECL	R1			; reduce the BINARY_EXPONENT by 1 so the
                                     016B   565 					; magnitude of FAC will not be changed
                          DA     11  016B   566 	BRB	NORMAL			; do normalization again
                                     016D   567 
                                     016D   568 
                                     016D   569 SCALE_DOWN:
                          50     D6  016D   570 	INCL	R0			; S = S + 1, and see if S > 0
                          04     14  016F   571 	BGTR	FLOAT			; branch if yes. i.e. both normalization
                                     0171   572 					; and scaling is done
                          69     10  0171   573 	BSBB	DIV10_R5		; otherwise divide FAC by 10
                          D2     11  0173   574 	BRB	NORMAL			; go back to normalize
                                     0175   575 
                                     0175   576 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  14
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                 (11)

                                     0175   578 ;+
                                     0175   579 ; Make FAC into floating form:
                                     0175   580 ; Step 1: BINARY_EXPONENT = BINARY_EXPONENT@24
                                     0175   581 ;	  Shift BINARY_EXPONENT left 24 places, so the leftmost bit of BINARY_EXPONENT
                                     0175   582 ;	  will be at size position (31 st position).  BINARY_EXPONENT
                                     0175   583 ;	  will occupy 31-24 bit positions.
                                     0175   584 ; Step 2: FAC = FAC@-7
                                     0175   585 ;	  Shift FAC right 7 (!!!) places, so the most significant bit of
                                     0175   586 ;	  FAC will be at 24th position.
                                     0175   587 ; [Remember BINARY_EXPONENT has initial value of 276(octal) = 200(octal)+63-1 (!!!)]
                                     0175   588 ; Step 3: FAC = FAC + BINARY_EXPONENT
                                     0175   589 ;	  Add FAC and BINARY_EXPONENT together.  The most significant bit of FAC
                                     0175   590 ;	  will add to 24th bit of BINARY_EXPONENT.  Thus offset the effect of
                                     0175   591 ;	  subtract's 1 from initial value of BINARY_EXPONENT.
                                     0175   592 ; Step 4: FAC = FAC @ - 1
                                     0175   593 ;	  Shift FAC right one position, allowing room for sign and insert it.
                                     0175   594 ; Step 5: HP (FAC) = ROTATE (HP(FAC),-16)
                                     0175   595 ;	  Finally, rotate HP(FAC) right 16 positions in order to make FAC
                                     0175   596 ;	  into correct floating form. (i.e. Lower half of HP(FAC) will get
                                     0175   597 ;	shifted into upper half of the longword.)
                                     0175   598 ; NOTE: HP(FAC) and LP(FAC) will get swapped at return through argument.
                                     0175   599 ; Why? - When working on FAC, FAC was treated as a double longword. After
                                     0175   600 ; FLOAT, FAC is converted into floating form. The most significant bits are
                                     0175   601 ; in lower half of the double precision floating form.
                                     0175   602 ;
                                     0175   603 ;-
                                     0175   604 
            51            17     78  0175   605 FLOAT:	ASHL	#23, R1, R1		; shift BINARY_EXPONENT left by 23 places
                          51         0178       
            54            06     E1  0179   606 	BBC	#6, R4, 10$		; check bit 6 of R4 for rounding purpose
                          0A         017C       
            54   00000080 8F     C0  017D   607 	ADDL	#^X80, R4		; do rounding right now
            55            00     D8  0184   608 	ADWC	#0, R5			; propogate carray to R5 if any
            54         F9 8F     79  0187   609 10$:	ASHQ	#-7, R4, R4		; shift FAC right 7 places
                          54         018B       
            55            51     C0  018C   610 	ADDL	R1, R5			; put BINARY_EXPONENT in R5
                          24     1D  018F   611 	BVS	ERROR1			; overflow would happen if the hidden most
                                     0191   612 					; significant bit bump the binary exponent 
            56            00     E1  0191   613 	BBC	#V_NEGATIVE, R6, 20$	; branch if FAC is positive
                          04         0194       
            55            1F     E3  0195   614 	BBCS	#31, R5, 20$		; insert sign bit to 1
                          00         0198       
            55         F0 8F     9C  0199   615 20$:	ROTL	#-16, R5, R5		; rotate R5 to shift exponent field into lower
                          55         019D       
                                     019E   616 					; half of R5, and
            54         F0 8F     9C  019E   617 	ROTL	#-16, R4, R4		; rotate R4 to swap lower half of R4 and
                          54         01A2       
                                     01A3   618 					; upper half of R4 in order to make R4/R5
                                     01A3   619 					; in correct double floating form (in reversed
                                     01A3   620 					; order)
            52         08 AC     D0  01A3   621 	MOVL	value(AP), R2		; R2 = reference to argument
            82            55     D0  01A7   622 	MOVL	R5, (R2)+		; put LP of the floating result in argument
            62            54     D0  01AA   623 	MOVL	R4, (R2)		; put HP of the floating result in argument
                                     01AD   624 
                                     01AD   625 
                                     01AD   626 ;
                                     01AD   627 ; Success exit
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  15
01-11           FOR$CNV_IN_DEFG  ; {D,E,F,G} format input conve                                                                 (11)

                                     01AD   628 ;
                                     01AD   629 
                                     01AD   630 FOR$CNV_IN_EXIT:
            50   00000000'8F     D0  01AD   631 	MOVL	#SS$_NORMAL, R0		; R0 = success return code
                                 04  01B4   632 	RET				; return result in @value (AP)
                                     01B5   633 
                                     01B5   634 ERROR1:
                          FF45   31  01B5   635 	BRW	ERROR			; error return
                                     01B8   636 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  16
01-11           RGET - get next character                                                                                       (12)

                                     01B8   638 	.SBTTL	RGET	- get next character
                                     01B8   639 
                                     01B8   640 ;+
                                     01B8   641 ; Subroutine RGET
                                     01B8   642 ;	input:
                                     01B8   643 ;	R1 - address of current char
                                     01B8   644 ;	output:
                                     01B8   645 ;	R3 - current char, with blank being converted into zero
                                     01B8   646 ;	R1 - POINTER_TO_INPUT
                                     01B8   647 ;-
                                     01B8   648 
            53            81     9A  01B8   649 RGET:	MOVZBL	(R1)+,R3		; get current char and adjust POINTER_TO_INPUT
            20            53     D1  01BB   650 	CMPL	R3, #^A/ /		; compare current char with blank
                          03     12  01BE   651 	BNEQ	1$			; branch if not blank
            53            30     D0  01C0   652 	MOVL	#^A/0/, R3		; convert blank into zero
                                 05  01C3   653 1$:	RSB
                                     01C4   654 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  17
01-11           MUL5_R5 - multiply FAC by 5                                                                                     (13)

                                     01C4   656 	.SBTTL	MUL5_R5	- multiply FAC by 5
                                     01C4   657 
                                     01C4   658 ;+
                                     01C4   659 ; Subroutine MUL5_R5
                                     01C4   660 ;	input:
                                     01C4   661 ;	R4/R5 - FAC
                                     01C4   662 ;	output:
                                     01C4   663 ;	R4/R5 - FAC*5
                                     01C4   664 ;-
                                     01C4   665 
                                     01C4   666 MUL5_R5:
            7E            54     7D  01C4   667 	MOVQ	R4,-(SP)		; save FAC on stack
            54            01     79  01C7   668 	ASHQ	#1, R4, R4		; R4/R5 = FAC*2
                          54         01CA       
                          E8     1D  01CB   669 	BVS	ERROR1			; branch if overflow
            54            01     79  01CD   670 	ASHQ	#1, R4, R4		; R4/R5 = FAC*4
                          54         01D0       
                          E2     1D  01D1   671 	BVS	ERROR1			; branch if overflow
            54            8E     C0  01D3   672 	ADDL	(SP)+, R4		; R4 = R4 + LP(FAC)
            55            8E     D8  01D6   673 	ADWC	(SP)+, R5		; R5 = R5 + HP (FAC) + carry
                          DA     1D  01D9   674 	BVS	ERROR1			; branch if overflow
                                 05  01DB   675 	RSB				; return with R4/R5 = FAC*5
                                     01DC   676 
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  18
01-11           DIV10_R5 - divide FAC by 10                                                                                     (14)

                                     01DC   678 	.SBTTL	DIV10_R5	- divide FAC by 10
                                     01DC   679 
                                     01DC   680 ;+
                                     01DC   681 ; Subroutine DIV10_R5
                                     01DC   682 ;
                                     01DC   683 ;	divide FAC by 10, FAC = ( HP(FAC), LP(FAC) ) = ( R5, R4 )
                                     01DC   684 ;
                                     01DC   685 ; input:
                                     01DC   686 ;	R4/R5 - FAC
                                     01DC   687 ; output:
                                     01DC   688 ;	R4/R5 - FAC divided by 10
                                     01DC   689 ;	R3 - extra_precision
                                     01DC   690 ; Registers used:
                                     01DC   691 ;	R4/R5 - FAC
                                     01DC   692 ;	R2/R3 - scratch used in EDIV and then R3 = extra_precision
                                     01DC   693 ;-
                                     01DC   694 
                                     01DC   695 DIV10_R5:
            53            00     D0  01DC   696 	MOVL	#0, R3			; R3 = 0
            52            55     D0  01DF   697 	MOVL	R5, R2			; R2 = HP(FAC)
            52            0A     7B  01E2   698 	EDIV	#10, R2, R5, R3		; divide R2/R3 (0,HP(FAC)) by 10
            53            55         01E5       
                                     01E7   699 					; R5 = Q1
                                     01E7   700 					; R3 = REM1
            52            54     D0  01E7   701 	MOVL	R4, R2			; R2 = LP(FAC)
            52            14     7B  01EA   702 	EDIV	#20, R2, R4, R2		; divide R2/R3 (REM1,LP(FAC)) by 20
            52            54         01ED       
                                     01EF   703 					; R4 = Q2
                                     01EF   704 					; R2 = REM2
            53            00     D0  01EF   705 	MOVL	#0, R3			; R3 = 0
            52            0A     7B  01F2   706 	EDIV	#10, R2, R2, R3		; divide R2/R3 (0,REM2) by 10
            53            52         01F5       
                                     01F7   707 					; R2 = Q3
                                     01F7   708 					; R3 = REM3 = extra_prec
            54            01     78  01F7   709 	ASHL	#1, R4, R4		; R4 = 2*Q2
                          54         01FA       
            54            52     C0  01FB   710 	ADDL	R2, R4			; R4 = 2*Q2 + Q3
            53            1C     78  01FE   711 	ASHL	#28, R3, R3		; shift R3 left 28 bits
                          53         0201       
                                 05  0202   712 	RSB				; return with R5 = Q1,
                                     0203   713 					; R4 = 2*Q2 + Q3
                                     0203   714 					; R3 = extra_precision
                                     0203   715  
                                     0203   716 	.END
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  19
SYMBOL TABLE                                                                                                                    (14)

CHECK_DIGIT      0000004C R     02   
DECIMAL_POINT    0000009D R     02   
DIGITS_IN_FRACT= 0000000C            
DIGIT_LOOP       00000042 R     02   
DIV10_R5         000001DC R     02   
ERROR            000000FD R     02   
ERROR1           000001B5 R     02   
EXPON            000000A9 R     02   
EXPONX           000000A5 R     02   
EXP_DONE         000000E5 R     02   
EXP_LOOP         000000C5 R     02   
EXP_LOOP0        000000AB R     02   
EXP_SIGN         000000C1 R     02   
FLOAT            00000175 R     02   
FOR$CNV_IN_DEFG  00000000 RG    02   
FOR$CNV_IN_EXIT  000001AD R     02   
FOR$K_ERR_PREFX= 00000018            
FOR$_INPCONERR   ********   X   01   
INIT_BINEXP      00000108 R     02   
IN_STR         = 00000004            
L1               00000128 R     02   
L2               0000012C R     02   
L_2P15_DIV_10  = 00000CCC            
L_2P31_DIV_10  = 0CCCCCCC            
MTH$K_ERR_PREFX= 00000016            
MTH__FLOOVEMAT = 00000058            
MTH__FLOUNDMAT = 00000059            
MTH__INVARG    = 00000051            
MTH__LOGZERNEG = 00000053            
MTH__SINSIGLOS = 00000057            
MTH__SQUROONEG = 00000054            
MTH__UNDEXP    = 00000052            
MTH__WRONUMARG = 00000050            
MUL5_R5          000001C4 R     02   
M_DECEXP       = 00000008            
M_DEC_POINT    = 00000002            
M_NEG_DECEXP   = 00000004            
NORMAL           00000147 R     02   
NORMAL0          00000145 R     02   
NOT_DIGIT        00000076 R     02   
READ_IN_NEXT     0000003E R     02   
REGMASK        = 000001FC            
RGET             000001B8 R     02   
SCALE            000000EF R     02   
SCALE_DOWN       0000016D R     02   
SCALE_FACTOR   = 00000010            
SS$_NORMAL       ********   X   01   
VALUE          = 00000008            
V_DECEXP       = 00000003            
V_DEC_POINT    = 00000001            
V_NEGATIVE     = 00000000            
V_NEG_DECEXP   = 00000002            


PROGRAM SECTION SYNOPSIS

.  ABS  .        00000000      00     NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT BYTE  
FOR$FCNVIR      ; FORTRAN REAL INPUT CONVERSION ROUTINE          21-AUG-1978 18:54:04   VAX-11 MACRO X0.3-11               Page  20
PROGRAM SECTION SYNOPSIS                                                                                                        (14)

. BLANK .        00000000      01     NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT BYTE  
FOR$CODE         00000203      02       PIC   USR   CON   REL   LCL   SHR   EXE   RD  NOWRT LONG  


THERE WERE NO ERRORS OR WARNINGS.
27084. BYTES LEFT IN FREE MEMORY POOL.
OBJ$:FORCNVIR,LIS$:FORCNVIR/-SP=LIB$:S/ML,SRC$:P,FORCNVIR
0 MLB DIR RDS - 0 GETS TO DEFINE 0 MACROS. 7 INTER. FILE WRITES. 
