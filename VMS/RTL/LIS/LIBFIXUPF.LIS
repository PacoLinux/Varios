LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   0
TABLE OF CONTENTS   

   (2)     100  HISTORY		; Detailed Current Edit History
   (4)     100  DECLARATIONS
   (5)     100  LIB$FIXUP_FLT - fixup floating reserved operand
   (7)     100  NEXT_OPERAND - Get next operand and check for f
   (8)     100  GET_REGS Get contents and addresses of all save
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   1
0-24                                                                                                                             (1)

                                     0000   100 	.TITLE LIB$FIXUP_FLT		; LIBRARY fixup floating/double resrv. op.
                                     0000   200 	.IDENT	/0-24/			; File: LIBFIXUPF.MAR
                                     0000   300 
                                     0000   400 ;
                                     0000   500 ; Copyright (C) 1977
                                     0000   600 ; Digital Equipment Corporation, Maynard, Massachusetts 01754
                                     0000   700 ;
                                     0000   800 ; This software is furnished under a license for use only on a single
                                     0000   900 ; computer  system  and  may be copied only with the inclusion of the
                                     0000  1000 ; above copyright notice. This software, or any other copies thereof,
                                     0000  1100 ; may not be provided or otherwise made available to any other person
                                     0000  1200 ; except for use on such system and to one who agree to these license 
                                     0000  1300 ; terms.  Title to  and  ownership of the software shall at all times 
                                     0000  1400 ; remain in DEC.
                                     0000  1500 ;
                                     0000  1600 ; The information in the software is subject to change without notice
                                     0000  1700 ; and should  not  be construed  as a commitment by Digital Equipment 
                                     0000  1800 ; Corporation.
                                     0000  1900 ;
                                     0000  2000 ; DEC assumes  no  responsibility  for the use or  reliability of its
                                     0000  2100 ; software on equipment which is not supplied by DEC.
                                     0000  2200 ;
                                     0000  2300 ;
                                     0000  2400 ; FACILITY: GENERAL UTILITY PROCEDURE LIBRARY
                                     0000  2500 ;++
                                     0000  2600 ; ABSTRACT:
                                     0000  2700 ;
                                     0000  2800 ;	LIB$FIXUP_FLT fixes up reserved floating/double operands
                                     0000  2900 ;	when a reserved operand fault occurs, so that the insturction
                                     0000  3000 ;	can be continued.  It is designed to be a handler or called from
                                     0000  3100 ;	a handler.
                                     0000  3200 ;
                                     0000  3300 ;--
                                     0000  3400 ;
                                     0000  3500 ; VERSION: 0
                                     0000  3600 ;
                                     0000  3700 ; HISTORY:
                                     0000  3800 ;
                                     0000  3900 ; AUTHOR:
                                     0000  4000 ;	Thomas N. Hastings, 6-Aug-77: Version 0
                                     0000  4100 ;
                                     0000  4200 ; MODIFIED BY:
                                     0000  4300 ;
                                     0000  4400 ;
                                     0000  4500 ;
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   2
0-24            HISTORY  ; Detailed Current Edit History                                                                         (2)

                                     0000   100 	.SBTTL	HISTORY		; Detailed Current Edit History
                                     0000   200 
                                     0000   300 
                                     0000   400 ; Edit History for Version 0
                                     0000   500 ;
                                     0000   600 ; 0-1	- original
                                     0000   700 ; 0-23	- Fix EMOD stack bug.  Also code bums.  TNH 13-Feb-78
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   3
0-24            HISTORY  ; Detailed Current Edit History                                                                         (3)

                                     0000   600 ; 0-21	- Remove $SSDEF.  TNH 14-Nov-77
                                     0000   700 ; 0-22	- Change SF$L_SAVE_REGN to SF$L_SAVE_REGS.  TNH 6-Dec-77
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   4
0-24            DECLARATIONS                                                                                                     (4)

                                     0000   100 	.SBTTL	DECLARATIONS
                                     0000   200 ;
                                     0000   300 ; INCLUDE FILES:
                                     0000   400 ;
                                     0000   600 	$SFDEF				; hardware symbols for stack frame
                                     0000   700 	$CHFDEF				; condition handling symbols
                                     0000   750 	$STSDEF				; VAX-11 error code defns
                                     0000   800 
                                     0000   900 ;
                                     0000  1000 ; OWN STORAGE:
                                     0000  1100 ;	NONE
                                     0000  1200 ;
                                     0000  1300 ;
                                     0000  1400 ; EXTERNALS
                                     0000  1500 ;
                                     0000  1600 
                                     0000  1650 	.DSABL	GBL			; Declare all EXTRNs explicitly
                                     0000  1700 	.EXTRN	SYS$CALL_HANDL		; System entry vector +4=saved PC 
                                     0000  1800                                 	; on exception or CALL LIB$SIGNAL/STOR
                                     0000  1900 	.EXTRN	SS$_NORMAL		; Normal success completion
                                     0000  1950 	.EXTRN	SS$_ACCVIO		; Access violation
                                     0000  2000 	.EXTRN	SS$_RESIGNAL		; RESIGNAL error status
                                     0000  2050 	.EXTRN	SS$_ROPRAND		; RESERVED OPERNAD error code
                                     0000  2100 	.EXTRN	LIB$_BADSTA		; BAD STACK error status
                                     0000  2200 	.EXTRN	LIB$_PUSSTAOVE		; PUSH_DOWN STACK OVERFLOW error status
                                     0000  2300 
                                     0000  2400 ;					
                                     0000  2500 ; MACROS				
                                     0000  2600 ;
                                     0000  2700 ;	NONE				
                                     0000  2800 ;
                                     0000  2900 ; PSECT DECLARATIONS:
                                     0000  3000 ;
                                 00000000  3100 	.PSECT	LIB$CODE	PIC,SHR,LONG,EXE,NOWRT
                                     0000  3200 ;
                                     0000  3300 ; EQUATED SYMBOLS:			
                                     0000  3400 ;
                           00000000  0000  3500 	R0_OFF	 = 0*4			; R0 register offset in register image
                           00000004  0000  3600 	R1_OFF	 = 1*4			; R1 register offset
                           00000030  0000  3700 	AP_OFF	 = 12*4			; AP register offset
                           00000034  0000  3800 	FP_OFF	 = 13*4			; FP register offset
                           00000038  0000  3900 	SP_OFF	 = 14*4			; SP register offset
                           0000003C  0000  4000 	PC_OFF	 = 15*4			; PC register offset
                           00000040  0000  4100 	PSL_OFF	 = 16*4			; PSL offset 
                                     0000  4200 
                           00000044  0000  4300 	K_SAV_IMAGE_SIZ = 4*17		; size of each image vector
                           FFFFFFBC  0000  4400 	REG_IMAGE = -K_SAV_IMAGE_SIZ	; FP offset for image vector of registers
                           FFFFFF78  0000  4500 	ADR_IMAGE = -<K_SAV_IMAGE_SIZ>*2 ; FP offset for image vector of addresses
                                     0000  4600 					; where registers have been saved in stack
                           FFFFFFFC  0000  4700 	IMAGE_PSL = -4			; FP offset of PSL image
                           FFFFFFF8  0000  4800 	IMAGE_PC = -8			; FP offset of PC image
                                     0000  4900 
                                     0000  5000 
                                     0000  5100 ; The following opcodes can have floating/double reserved opcodes:
                                     0000  5200 ; The routine assumes that the reserved operand can occur on the first
                                     0000  5300 ; or the second operand.  It depends on the fact that the first operand
                                     0000  5400 ; will have the reserved operand if the second operand cannot (e.g. the
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   5
0-24            DECLARATIONS                                                                                                     (4)

                                     0000  5500 ; second is a destination or an integer source).
                                     0000  5600 
                           00000040  0000  5700 	ADDF2	= ^X40		        ; ADDF2 opcode - lowest float
                           00000056  0000  5800 	CVTFD	= ^X56		        ; CVTFD opcode - highest float
                           00000060  0000  5900 	ADDD2	= ^X60		        ; ADD2 opcode - lowest double
                           00000076  0000  6000 	CVTDF	= ^X76		        ; CVTDF opcode - highest double
                                     0000  6100 
                                     0000  6200 ; Special processing of the following opcodes:
                                     0000  6300 
                           00000054  0000  6400 	EMODF	= ^X54		        ; EMODF opcode - 1st or 3rd operand
                           0000004F  0000  6500 	ACBF	= ^X4F		        ; ACBF opcode - 1st, 2nd, or 3rd operand
                           00000055  0000  6600 	POLYF	= ^X55			; POLYF opcode - 1st only (2nd operand can be
                                     0000  6700 					; reserved, but it is an integer).
                                     0000  6800 
                                     0000  6900 ; Define field in floating/double data type to test for reserved operand.
                                     0000  7000 ; Test is for 9-bit field to be equal to ^X100
                                     0000  7100 
                           00000009  0000  7200 	S_MZERO = 9			; size = sign bit + exponent
                           00000007  0000  7300 	V_MZERO = 7			; position
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   6
0-24            LIB$FIXUP_FLT - fixup floating reserved operand                                                                  (5)

                                     0000   100 	.SBTTL LIB$FIXUP_FLT - fixup floating reserved operand
                                     0000   200 
                                     0000   300 ;++
                                     0000   400 ; FUNCTIONAL DESCRIPTION:
                                     0000   500 ;
                                     0000   600 ;	LIB$FIXUP_FLT finds the reserved operand of any floating or double
                                     0000   700 ;	instruction after a reserved operand fault has occured and changes it
                                     0000   800 ;	from -0.0 to new-operand, if present, else +0.0.
                                     0000   900 ;	Note: for reliability, new_operand should always be double floating
                                     0000  1000 ;	even when only floating overflow are expected.  In FORTRAN
                                     0000  1100 ;	this can be done by specifying D in the constant expression:
                                     0000  1200 ;
                                     0000  1300 ;	... = LIB$FIXPU_FLT (SIG_VECTOR, MCH_VECTOR, 1.0D0)
                                     0000  1400 ;
                                     0000  1500 ;	It is designed to be a handler itself, called from a handler or from
                                     0000  1600 ;	any procedure called by a handler.  Therefore, if the signaled
                                     0000  1700 ;	condition is not SS$_ROPRAND, the error code 
                                     0000  1725 ;	SS$_RESIGNAL is returned as a completion code.
                                     0000  1750 ;
                                     0000  1800 ;	If the reserved operand is not a floating or double, an error
                                     0000  1900 ;	condition is returned.  If the stack is bad, an error condition is returned.
                                     0000  2000 ;	The instruction stream is interpreted in order to find the reserved operand.
                                     0000  2100 ;	The stack is prechecked to see if there is enough room.  If not,
                                     0000  2200 ;	an error condition is returned, rather than having another exception generated.
                                     0000  2300 ;	Note: this routine needs 17+17+2+5+10=51 longwords of stack.
                                     0000  2400 ;
                                     0000  2500 ;
                                     0000  2600 ; CALLING SEQUENCE:
                                     0000  2700 ;
                                     0000  2800 ;	status.wlc.v = LIB$FIXUP_FLT(sig_args_adr.rlu.r, mch_args_adr.wlu.r
                                     0000  2900 ;	               [, new_operand.rd.r])
                                     0000  3000 ; INPUT PARAMETERS:
                                     0000  3100 ;
                           00000004  0000  3200 	SIG_ARGS_ADR = 4		; adr. of signal args vector
                           00000008  0000  3300 	MCH_ARGS_ADR = 8		; adr of mechanism args vector
                           0000000C  0000  3400 	NEW_OPERAND = 12		; Optional adr of double 
                                     0000  3500 ;					; new operand to replace the reserved operand.
                                     0000  3600 ;					
                                     0000  3700 ; IMPLICIT INPUTS:
                                     0000  3800 ;
                                     0000  3900 ;	The stack back to the handler
                                     0000  4000 ;	The instruction which faulted
                                     0000  4100 ;
                                     0000  4200 ; OUTPUT PARAMETERS:
                                     0000  4300 ;
                                     0000  4400 ;	NONE
                                     0000  4500 ;
                                     0000  4600 ; IMPLICIT OUTPUTS:
                                     0000  4700 ;
                                     0000  4800 ;	The floating or double reserved operand is changed to new_operand
                                     0000  4900 ;
                                     0000  5000 ; COMPLETION CODES:
                                     0000  5100 ;
                                     0000  5200 ;   Success:
                                     0000  5300 ;	SS$_NORMAL			normal success, opernad fixed up (=SS$_CONTINUE)
                                     0000  5400 ;					so that if LIB$FIXUP_FLT is established as a
                                     0000  5500 ;					handler all by itself, execution will continue
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   7
0-24            LIB$FIXUP_FLT - fixup floating reserved operand                                                                  (5)

                                     0000  5550 ;					without any message being printed(signaled).
                                     0000  5600 ;  Error:
                                     0000  5700 ;	LIB$_BADSTA			BAD STACK, the stack linkage has been
                                     0000  5800 ;					corrupted since the time of the reserved 
                                     0000  5900 ;					operand exception.
                                     0000  6000 ;	SS$_ROPRAND			RESERVED OPERAND FAULT/ABORT
                                     0000  6100 ;					if not floating point instruction
                                     0000  6200 ;	LIB$_PUSSTAOVE			PUSH-DOWN STACK OVERFLOW if not
                                     0000  6300 ;					enough stack space to perform computation
                                     0000  6400 ;	SS$_RESIGNAL			the signaled condition in 
                                     0000  6425 ;					SIG_ARGS_ADR[CHF$L_SIG_NAME]
                                     0000  6500 ;					was not SS$_ROPRAND.
                                     0000  6600 ;--
                                     0000  6700 
                                     0000  6800 
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   8
0-24            LIB$FIXUP_FLT - fixup floating reserved operand                                                                  (6)

                                     0000   100 ;+
                                     0000   200 ; Registers used:
                                     0000   300 ;
                                     0000   400 ;	R0 =	scratch
                                     0000   500 ;	R1 =	size of operand (1,4 OR 8) as determined by the opcode
                                     0000   600 ;	R2<7:0> = opcode 
                                     0000   700 ;	R3 =	context index or 0
                                     0000   800 ;	R4 =	OA1 (operand address) of bits 31:0
                                     0000   900 ;	R5 =	OA2 (operand address) of bits 63:32 which may not be
                                     0000  1000 ;		OA1+4 since registers not necessarily saved contiguously.
                                     0000  1100 ;	R6 = 	register number of operand specifier
                                     0000  1200 ;-
                                     0000  1300 
                               0FFC' 0000  1400 	.ENTRY LIB$FIXUP_FLT, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
                                     0002  1500 					; save all registers so that all will be 
                                     0002  1600 					; found in stack during back scan.
                                     0002  1700 					; disable IV (content index multiply)
            50         04 AC     D0  0002  1800 	MOVL	SIG_ARGS_ADR(AP), R0	; R0 = adr. of signal arg list array
            19            03     ED  0006  1900 	CMPZV	#STS$V_COND_ID, -	; position of message identification
                       04 A0         0009       
                                     000B  1925 		#STS$S_COND_ID, -	; size of id
                                     000B  1937 		CHF$L_SIG_NAME(R0), -	; compare 29-bit VAX-11 signal code
                 00000000'8F         000B  2000 		#<SS$_ROPRAND@-STS$V_COND_ID> ; with reserved operand code
                          65     12  0010  2100 	BNEQ	RESIGNAL		; branch if not reserved operand code
            5E       FF78 CE     9E  0012  2200 	MOVAB	-<K_SAV_IMAGE_SIZ>*2(SP), SP ; allocate two local vectors:
                                     0017  2300 					; REG_IMAGE - image of registers at time of exception
                                     0017  2400 					; ADR_IMAGE - image of address where regs are
                                     0017  2500 					; saved in stack in case they need fixup.
       0094 8F            00     0D  0017  2600 	PROBEW	#0, #<K_SAV_IMAGE_SIZ>*2+12, -12(SP) ;stack ok to use include two
                       F4 AE         001C       
                                     001E  2700 					; LOCAL arrays and 2 BSB and 1 PUSHL
                          62     13  001E  2800 	BEQL	STACK_OVF		; branch if stack not big enough
                          0163   30  0020  2900 	BSBW	GET_REGS		; setup the two image vectors in local storage
                                     0023  3000 					; do not return here if error, instead RET with
                                     0023  3100 					; error completion status
                                     0023  3200 
                                     0023  3300 ;+
                                     0023  3400 ; get opcode, determine if floating, double or neither 
                                     0023  3500 ;-
                                     0023  3600 
                          0146   30  0023  3700 	BSBW	NEXT_BYTE		; R0 = sign extended opcode byte
            51            04     D0  0026  3800 	MOVL	#4, R1			; assume floating, R1 = size of operand
         40 8F            50     91  0029  3900 	CMPB	R0, #ADDF2		; compare with ADDF2(lowest numbered float opcode)
                          42     1F  002D  4000 	BLSSU	ROPRAND			; branch if not floating (or double)
         56 8F            50     91  002F  4100 	CMPB	R0, #CVTFD		; compare with CVTFD(highest numbered float opcode)
                          0F     1B  0033  4200 	BLEQU	10$			; branch if floating
                                     0035  4300 
            51            08     D0  0035  4400 	MOVL	#8, R1			; not floating, assumes double
         60 8F            50     91  0038  4500 	CMPB	R0, #ADDD2		; compare with ADDD2 (lowest numbered double operand)
                          33     1F  003C  4600 	BLSSU	ROPRAND			; branch if not double (or floating)
         76 8F            50     91  003E  4700 	CMPB	R0, #CVTDF		; compare with CVTDF (highest numbered double operand) 
                          2D     1A  0042  4800 	BGTRU	ROPRAND			; branch if not double (or floating)
            50         E0 8F     8B  0044  4900 10$:	BICB3	#^XE0, R0, R2		; R2 = low 5 bits of opcode as float and
                          52         0048       
                                     0049  5000 					; double are the same
                                     0049  5100 ;+
                                     0049  5200 ; get first operand and see if -0.0
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page   9
0-24            LIB$FIXUP_FLT - fixup floating reserved operand                                                                  (6)

                                     0049  5300 ;-
                                     0049  5400 
                          78     10  0049  5500 	BSBB	NEXT_OPERAND		; R0 = true if next operand is  reserved float
            3C            50     E8  004B  5600 	BLBS	R0, FIXUP		; branch if found reserved operand
                                     004E  5700 
                                     004E  5800 ;+
                                     004E  5900 ; First operand was not a reserved floating or double operand.
                                     004E  6000 ; get second operand  - if EMOD{F,D} skip 2nd operand and get third
                                     004E  6100 ; if POLY{F,D} do not get second opernad, all done - must be in table
                                     004E  6200 ;-
                                     004E  6300 
            15            52     91  004E  6400 	CMPB	R2, #POLYF&^X1F		; is opcode POLYF or POLYD?
                          1E     13  0051  6500 	BEQL	ROPRAND			; branch if yes (reserved operand
                                     0053  6600 					; must be 2nd op > 32 or in table).
            14            52     91  0053  6700 	CMPB	R2, #EMODF&^X1F		; is opcode EMODF or EMODD?
                          0A     12  0056  6800 	BNEQ	20$			; branch if not EMOD
                          51     DD  0058  6900 	PUSHL	R1			; save size of operand (4 or 8) from opcode
            51            01     D0  005A  7000 	MOVL	#1, R1			; change operand size to 1 for EMOD 2nd operand
                          64     10  005D  7100 	BSBB	NEXT_OPERAND		; get EMOD 2nd operand which is a byte
            51            8E     D0  005F  7200 	MOVL	(SP)+, R1		; restore size of operand (4 or 8)
                          5F     10  0062  7300 20$:	BSBB	NEXT_OPERAND		; get next operand
            23            50     E8  0064  7400 	BLBS	R0, FIXUP		; branch if found reserved operand
                                     0067  7500 
                                     0067  7600 ;+
                                     0067  7700 ; Get third operand only if ACB - else error
                                     0067  7800 ;-
                                     0067  7900 
            0F            52     91  0067  8000 	CMPB	R2, #ACBF&^X1F		; is opcode ACBF or ACBD
                          05     12  006A  8100 	BNEQ	ROPRAND			; branch if not ACB
                          55     10  006C  8200 	BSBB	NEXT_OPERAND		; get third ACB operand
            19            50     E8  006E  8300 	BLBS	R0, FIXUP		; branch if reserved operand floating
                                     0071  8400 
                                     0071  8500 ;+
                                     0071  8600 ; Here if a reserved operand other then floating or double
                                     0071  8700 ;-
                                     0071  8800 
                                     0071  8900 ROPRAND:
            50       0000'8F     3C  0071  9000 	MOVZWL	#SS$_ROPRAND, R0	; R0 = system reserved operand code		
                                 04  0076  9100 	RET				; error return
                                     0077  9200 
                                     0077  9300 ;+
                                     0077  9400 ; Here if not SS$_ROPERAND being signaled, ust return SS$_RESIGNAL
                                     0077  9500 ; so fi LIB$FIXUP_FLT had been established as a handler, it will just resignal
                                     0077  9600 ; since it cannot do anything if not SS$_ROPERAND.
                                     0077  9700 ;-
                                     0077  9800 
                                     0077  9900 RESIGNAL:
            50       0000'8F     3C  0077 10000 	MOVZWL	#SS$_RESIGNAL, R0	; R0 = RESIGNAL error completion code
                                 04  007C 10100 	RET				; error return
                                     007D 10200 
                                     007D 10300 ;+
                                     007D 10400 ; Here if access violation detected by PROBE
                                     007D 10500 ;
                                     007D 10600 
                                     007D 10700 ACCESS_VIO:
            50         00'8F     9A  007D 10800 	MOVZBL	#SS$_ACCVIO, R0		; R0 = system access violation code
                                 04  0081 10900 	RET				; error return
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  10
0-24            LIB$FIXUP_FLT - fixup floating reserved operand                                                                  (6)

                                     0082 11000 
                                     0082 11100 ;+
                                     0082 11200 ; Here if stack not big enough - since already an exception in progress 
                                     0082 11300 ; Return error condition
                                     0082 11400 ;-
                                     0082 11500 
                                     0082 11600 STACK_OVF:
            50   00000000'8F     D0  0082 11700 	MOVL	#LIB$_PUSSTAOVE, R0	; R0=library error code
                                 04  0089 11800 	RET				; error return
                                     008A 11900 ;+
                                     008A 12000 ; Fixup reserved floating double operand
                                     008A 12100 ; If in a register modify where saved in stack (2 places if double)
                                     008A 12200 ;-
                                     008A 12300 
            04            00     0D  008A 12400 FIXUP:	PROBEW	#0, #4, (R4)		; is first half of operand writeable?
                          64         008D       
                          ED     13  008E 12500 	BEQL	ACCESS_VIO		; branch if can't write
                          52     7C  0090 12600 	CLRQ	R2			; R2/R3 = default fixup (store 0)
            03            6C     91  0092 12700 	CMPB	(AP), #<NEW_OPERAND/4>	; did caller supply adr. of new_operand?
                          17     1F  0095 12800 	BLSSU	10$			; branch if not
            50         0C AC     D0  0097 12900 	MOVL	NEW_OPERAND(AP), R0	; R0 = adr. of new opernad
                          11     13  009B 13000 	BEQL	10$			; branch if adr. is 0 (2nd form of opt. arg.)
                                     009D 13100 	
            52            60     7D  009D 13200 	MOVQ	(R0), R2		; R2/R3 = user supplied new operand
            09            07     ED  00A0 13300 	CMPZV	#V_MZERO, #S_MZERO, -	; is operand floating reserved?
                                     00A3       
   00000100 8F            60         00A3 13310 		(R0), #^X100
                          03     13  00A9 13400 	BEQL	10$			; yes, don't touch as a floating point op
            52            60     70  00AB 13500 	MOVD	(R0), R2		; R2/R3 = double operand, clean up dirty 0
                                     00AE 13600 					; user mistake of not passing double
            64            52     D0  00AE 13700 10$:	MOVL	R2, (R4)		; Fixup first half
            08            51     D1  00B1 13800 	CMPL	R1, #8			; compare operand size
                          09     12  00B4 13900 	BNEQ	20$			; branch if not double
            04            00     0D  00B6 14000 	PROBEW	#0, #4, (R5)		; is second half of operand writeable
                          65         00B9       
                          C1     13  00BA 14100 	BEQL	ACCESS_VIO		; branch if not
            65            53     D0  00BC 14200 	MOVL	R3, (R5)		; copy second half
            50            00'    D0  00BF 14300 20$:	MOVL	S^#SS$_NORMAL, R0 	; R0 = success
                                 04  00C2 14600 	RET				; return R0 = completion status
                                     00C3 14700 
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  11
0-24            NEXT_OPERAND - Get next operand and check for f                                                                  (7)

                                     00C3   100 	.SBTTL NEXT_OPERAND - Get next operand and check for floating opcode
                                     00C3   200 ;++
                                     00C3   300 ; FUNCTIONAL DESCRIPTION:
                                     00C3   400 ;
                                     00C3   500 ;	NEXT_OPERAND interprets the instruction stream and
                                     00C3   600 ;	gets the next operand. It returns 1 in R0
                                     00C3   700 ;	if operand is floating or double reserved operand, else 0.
                                     00C3   800 ;
                                     00C3   900 ; CALLING SEQUENCE
                                     00C3  1000 ;
                                     00C3  1100 ;	JSB	NEXT_OPERAND
                                     00C3  1200 ;
                                     00C3  1300 ; INPUT PARAMETERS:
                                     00C3  1400 ;
                                     00C3  1500 ;	R1 = size of operand (1,4,or8)
                                     00C3  1600 ;
                                     00C3  1700 ; IMPLICIT INPUTS:
                                     00C3  1800 ;
                                     00C3  1900 ;	REG_IMAGE(FP)			; The image of the registers including PC
                                     00C3  2000 ;	instruction stream
                                     00C3  2100 ;
                                     00C3  2200 ; OUTPUT PARAMETERS:
                                     00C3  2300 ;
                                     00C3  2400 ;	R4 = OA1 (operand address of bits 31:0 of operand)
                                     00C3  2500 ;	R5 = OA2 (operand address of bits 63:32 of operand) if R1 = 8
                                     00C3  2600 ;
                                     00C3  2700 ; IMPLICIT OUTPUT:
                                     00C3  2800 ;
                                     00C3  2900 ;	Saved image of PC is updated as operand specific is interpreted
                                     00C3  3000 ;
                                     00C3  3100 ; COMPLETION STATUS
                                     00C3  3200 ;
                                     00C3  3300 ;	R0 = 1 if operand is floating or double reserved operand, else 0
                                     00C3  3400 ;
                                     00C3  3500 ; SIDE EFFECTS:
                                     00C3  3600 ;
                                     00C3  3700 ;	NONE - uses registers R0:R6 - see LIB$FIXUP_FLT for register usage
                                     00C3  3800 ;--
                                     00C3  3900 
                                     00C3  4000 NEXT_OPERAND:
                          53     D4  00C3  4100 	CLRL	R3			; R3 = initial context index register
                                     00C5  4150 
                                     00C5  4200 ;+
                                     00C5  4300 ; Loop to get operand specifier - loop back here (once) if operand specifier is inde
                                     00C5  4400 ;-
                                     00C5  4450 
                                     00C5  4500 LOOP_OP:
                          00A4   30  00C5  4600 	BSBW	NEXT_BYTE		; R0 = next I-stream byte (sign extended)
            04            00     EF  00C8  4700 	EXTZV	#0, #4, R0, R6		; R6 = register field
            56            50         00CB       
            04            04     EF  00CD  4800 	EXTZV	#4, #4, R0, R0		; R0 = operand specifier 7:4
            50            50         00D0       
            04            50     8F  00D2  4900 	CASEB	R0, #4, #15-4		; dispatch on operand specifier code
                          0B         00D5       
                                     00D6  5000 					; literal 0-3 falls through
                               001A' 00D6  5100 10$:	.WORD	INDEXED-10$		; 4
                               0022' 00D8  5200 	.WORD	REG-10$			; 5
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  12
0-24            NEXT_OPERAND - Get next operand and check for f                                                                  (7)

                               0030' 00DA  5300 	.WORD	REG_DEF-10$		; 6
                               0037' 00DC  5400 	.WORD	AUTO_DECR-10$		; 7
                               003E' 00DE  5500 	.WORD	AUTO_INCR-10$		; 8
                               004A' 00E0  5600 	.WORD	AUTO_INCR_DEF-10$	; 9
                               0059' 00E2  5700 	.WORD	BYTE_DISPL-10$		; 10
                               005D' 00E4  5800 	.WORD	BYTE_DISPL_DEF-10$	; 11
                               0061' 00E6  5900 	.WORD	WORD_DISPL-10$		; 12
                               0065' 00E8  6000 	.WORD	WORD_DISPL_DEF-10$	; 13
                               0069' 00EA  6100 	.WORD	LONG_DISPL-10$		; 14
                               0073' 00EC  6200 	.WORD	LONG_DISPL_DEF-10$	; 15
                                     00EE  6300 
                                     00EE  6400 ;+
                                     00EE  6500 ; Literal - can't be reserved, just return failure
                                     00EE  6600 ;-
                                     00EE  6700 
                          79     11  00EE  6800 	BRB	NOT_RESRV		; return - not reserved operand
                                     00F0  6900 
                                     00F0  7000 ;+
                                     00F0  7100 ; Indexed - save context index and loop back
                                     00F0  7200 ;
                                     00F0  7300 
                                     00F0  7400 INDEXED:
            51         BC AD46   C5  00F0  7500 	MULL3	REG_IMAGE(FP)[R6], R1,- ; R3 = context index
                                     00F5       
                          53         00F5  7600 	R3
                          CD     11  00F6  7700 	BRB	LOOP_OP			; go back and get next specifier
                                     00F8  7800 
                                     00F8  7900 ;+
                                     00F8  8000 ; Register
                                     00F8  8100 ;-
                                     00F8  8200 
            54       FF78 CD46   D0  00F8  8300 REG:	MOVL	ADR_IMAGE(FP)[R6], R4	; R4 = OA1 = adr where Rn  saved in stack
            55       FF7C CD46   D0  00FE  8400 	MOVL	ADR_IMAGE+4(FP)[R6], R5	; R5 = OA2 = adr where Rn+1 saved in stack
                          55     11  0104  8500 	BRB	CHK_OP_RSB		; check operand for reserved and RSB
                                     0106  8600 
                                     0106  8700 ;+
                                     0106  8800 ; Register Deferred
                                     0106  8900 ;-
                                     0106  9000 
                                     0106  9100 REG_DEF:
            54         BC AD46   D0  0106  9200 	MOVL	REG_IMAGE(FP)[R6], R4 	; R4 = OA = contents of Rn
                          47     11  010B  9300 	BRB	SET_OA2			; set OA2, check op and RSB
                                     010D  9400 
                                     010D  9500 ;+
                                     010D  9600 ; Auto Decrement
                                     010D  9700 ;-
                                     010D  9800 
                                     010D  9900 AUTO_DECR:
         BC AD46          51     C2  010D 10000 	SUBL	R1, REG_IMAGE(FP)[R6]	; decrement Rn by operand size
                          F2     11  0112 10100 	BRB	REG_DEF			; go do register deferred
                                     0114 10200 
                                     0114 10300 ;+
                                     0114 10400 ; Auto Increment
                                     0114 10500 ;-
                                     0114 10600 
                                     0114 10700 AUTO_INCR:
            54         BC AD46   D0  0114 10800 	MOVL	REG_IMAGE(FP)[R6], R4	; R4 = OA = contents of Rn
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  13
0-24            NEXT_OPERAND - Get next operand and check for f                                                                  (7)

         BC AD46          51     C0  0119 10900 	ADDL	R1, REG_IMAGE(FP)[R6]	; increment Rn by operand size
                          34     11  011E 11000 	BRB	SET_OA2			; set OA2, check op and RSB
                                     0120 11100 
                                     0120 11200 ;+
                                     0120 11300 ; Auto Increment Deferred
                                     0120 11400 ;-
                                     0120 11500 
                                     0120 11600 AUTO_INCR_DEF:
            54         BC AD46   D0  0120 11700 	MOVL	REG_IMAGE(FP)[R6], R4	; R4 = contents of Rn
            54            64     D0  0125 11800 	MOVL	(R4), R4 		; R4 = OA
         BC AD46          04     C0  0128 11900 	ADDL	#4, REG_IMAGE(FP)[R6]	; increment Rn by 4 (size of address)
                          25     11  012D 12000 	BRB	SET_OA2			; set OA2, check op, and RSB
                                     012F 12100 
                                     012F 12200 ;+
                                     012F 12300 ; Byte Displacement
                                     012F 12400 ;-
                                     012F 12500 
                                     012F 12600 BYTE_DISPL:
                          3B     10  012F 12700 	BSBB	NEXT_BYTE		; R0 = next I-stream byte
                          0E     11  0131 12800 	BRB	DISPL			; add to PC
                                     0133 12900 
                                     0133 13000 ;+
                                     0133 13100 ; Byte Displacement Deferred
                                     0133 13200 ;-
                                     0133 13300 
                                     0133 13400 BYTE_DISPL_DEF:
                          37     10  0133 13500 	BSBB	NEXT_BYTE 		; R0 = next I-stream byte
                          14     11  0135 13600 	BRB	DISPL_DEF 		; add to PC and defer
                                     0137 13700 
                                     0137 13800 ;+
                                     0137 13900 ; Word Displacement
                                     0137 14000 ;-
                                     0137 14100 
                                     0137 14200 WORD_DISPL:
                          3B     10  0137 14300 	BSBB	NEXT_WORD 		; R0 = next I-stream word
                          06     11  0139 14400 	BRB	DISPL			; add to PC 
                                     013B 14500 
                                     013B 14600 ;+
                                     013B 14700 ; Word Displacement Deferred
                                     013B 14800 ;-
                                     013B 14900 
                                     013B 15000 WORD_DISPL_DEF:
                          37     10  013B 15100 	BSBB	NEXT_WORD 		; R0 = next I-stream word
                          0C     11  013D 15200 	BRB	DISPL_DEF 		; add to PC and defer
                                     013F 15300 
                                     013F 15400 ;+
                                     013F 15500 ; Long displacement
                                     013F 15600 ;-
                                     013F 15700 
                                     013F 15800 LONG_DISPL:
                          3C     10  013F 15900 	BSBB	NEXT_LONG 		; R0 = next I-stream longword
         BC AD46          50     C1  0141 16000 DISPL:	ADDL3	R0, REG_IMAGE(FP)[R6], R4	; R4 = OA = (Rn) + displacement
                          54         0146       
                          0B     11  0147 16100 	BRB	SET_OA2			; set OA2, check OP, and RSB
                                     0149 16200 
                                     0149 16300 ;+
                                     0149 16400 ; Long Displacement deferred
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  14
0-24            NEXT_OPERAND - Get next operand and check for f                                                                  (7)

                                     0149 16500 ;-
                                     0149 16600 
                                     0149 16700 LONG_DISPL_DEF:
                          32     10  0149 16800 	BSBB	NEXT_LONG 		; R0 = Next I-stream longword
                                     014B 16900 DISPL_DEF:				; here for displacement deferred
         BC AD46          50     C1  014B 17000 	ADDL3	R0, REG_IMAGE(FP)[R6], R4 	; R4 = (Rn) + displacement
                          54         0150       
            54            64     D0  0151 17100 	MOVL	(R4), R4		; R4 = OA = (OA) (do defer)
                                     0154 17200 
                                     0154 17300 ;+
                                     0154 17400 ; add context index or 0
                                     0154 17500 ; Set OA2 (operand address 2)from OA+4 since
                                     0154 17600 ; operand is in memory not a register and therefore is contiguous
                                     0154 17700 ;-
                                     0154 17800 
                                     0154 17900 SET_OA2:
            54            53     C0  0154 18000 	ADDL	R3, R4			; R4 = OA + context index or 0
            04            54     C1  0157 18100 	ADDL3	R4, #4, R5		; R5 = OA2 = OA + 4
                          55         015A       
                                     015B 18200 
                                     015B 18300 ;+
                                     015B 18400 ; check for reserved operand
                                     015B 18500 ;-
                                     015B 18600 
                                     015B 18700 CHK_OP_RSB:
            50            01     D0  015B 18800 	MOVL	#1, R0			; R0 = success
            09            07     ED  015E 18810 	CMPZV	#V_MZERO, #S_MZERO, -	; is operand floating reserved?
                                     0161       
   00000100 8F            64         0161 18820 		(R4), #^X100
                          02     13  0167 19000 	BEQL	NEXT_OPERANDX		; branch if reserved op
                                     0169 19100 NOT_RESRV:
                          50     D4  0169 19200 	CLRL	R0			; R0 = failure
                                     016B 19300 NEXT_OPERANDX:
                                 05  016B 19400 	RSB				; return R0 indicating success or failure
                                     016C 19500 
                                     016C 19600 
                                     016C 19700 
                                     016C 19800 ;+
                                     016C 19900 ; routines to get next byte, word, or long from I-stream and sign extend
                                     016C 20000 ;-
                                     016C 20100 
                                     016C 20200 NEXT_BYTE:
            50         F8 BD     98  016C 20300 	CVTBL	@IMAGE_PC(FP), R0	; R0 = next byte
                       F8 AD     D6  0170 20400 	INCL	IMAGE_PC(FP)		; update PC
                                 05  0173 20500 	RSB				; return
                                     0174 20600 
                                     0174 20700 NEXT_WORD:
            50         F8 BD     32  0174 20800 	CVTWL	@IMAGE_PC(FP), R0	; R0 = next word
         F8 AD            02     C0  0178 20900 	ADDL	#2, IMAGE_PC(FP)	; update PC
                                 05  017C 21000 	RSB				; return
                                     017D 21100 
                                     017D 21200 NEXT_LONG:
            50         F8 BD     D0  017D 21300 	MOVL	@IMAGE_PC(FP), R0	; R0 = next longword
         F8 AD            04     C0  0181 21400 	ADDL	#4, IMAGE_PC(FP)	; update PC
                                 05  0185 21500 	RSB				; return
                                     0186 21600 
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  15
0-24            GET_REGS Get contents and addresses of all save                                                                  (8)

                                     0186   100 	.SBTTL GET_REGS Get contents and addresses of all save registers in stack
                                     0186   200 ;++
                                     0186   300 ; FUNCTIONAL DESCRIPTION:
                                     0186   400 ;
                                     0186   500 ;	GET_REGS scans the stack and finds all registers saved
                                     0186   600 ;	in call frames back to the signal facility. Thus it
                                     0186   700 ;	makes an image of the registers at the time of the
                                     0186   800 ;	exception or CALL LIB$SIGNAL/STOP. Because a double
                                     0186   900 ;	operand may be saved in two different places, an image
                                     0186  1000 ;	array of addresses where the registers are saved is also created.
                                     0186  1100 ;	Note: GET_REGS assumes:
                                     0186  1200 ;	caller has saved R2:R11 in frame using its entry mask so all registers
                                     0186  1300 ;	are in memory somewhere. Stack scan is defensive against bad stacks.
                                     0186  1400 ;	Note: to reconstruct contents of SP at time of exception or call LIB$SIGNAL,
                                     0186  1500 ;	Use of the fact that the signal args list is pushed on stack first is made.
                                     0186  1600 ;	That is SP is = adr of last signal arg/ +4. Also depends on saved PC being
                                     0186  1700 ;	SYS$CALL_HANDL+4.
                                     0186  1800 ;
                                     0186  1900 ; CALLING SEQUENCE:
                                     0186  2000 ;
                                     0186  2100 ;	JSB	GET_REGS
                                     0186  2200 ;
                                     0186  2300 ; INPUT PARAMETERS:
                                     0186  2400 ;
                                     0186  2500 ;	NONE
                                     0186  2600 ;
                                     0186  2700 ; IMPLICIT INPUTS:
                                     0186  2800 ;
                                     0186  2900 ;	SIG_ARGS_ADR.(AP)		; Adr. of array of signal args
                                     0186  3000 ;	MCH_ARGS_ADR.(AP)		; Adr. of array of mechanism args
                                     0186  3100 ;
                                     0186  3200 ; OUTPUT PARAMETERS:
                                     0186  3300 ;
                                     0186  3400 ;	NONE
                                     0186  3500 ;
                                     0186  3600 ; IMPLICIT OUTPUTS:
                                     0186  3700 ;
                                     0186  3800 ;	REG_IMAGE(FP)			; set reg image array R0:PC/PSL
                                     0186  3900 ;	ADR_IMAGE(FP)			; Set adr where reg saved R0:PC/PSL
                                     0186  4000 ;					; except adr. where SP SAVED = 0, since not saved.
                                     0186  4100 ;
                                     0186  4200 ; COMPLETION CODES:
                                     0186  4300 ;
                                     0186  4400 ;	NONE JSB
                                     0186  4500 ;
                                     0186  4600 ; SIDE EFFECTS:
                                     0186  4700 ;
                                     0186  4800 ;	If error, RET with error code
                                     0186  4900 ;--
                                     0186  5000 
                                     0186  5100 ;+
                                     0186  5200 ; Registers used:
                                     0186  5300 ;
                                     0186  5400 ;	R0 = scratch
                                     0186  5500 ;	R1 = pointer to register image array (REG_IMAGE)
                                     0186  5600 ;	R2 = stack frame pointer
                                     0186  5700 ;	R3 = Adr. of register save area in frame
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  16
0-24            GET_REGS Get contents and addresses of all save                                                                  (8)

                                     0186  5800 ;	R4 = Loop count
                                     0186  5900 ;	R5 = pointer to address image array (ADR_IMAGE)
                                     0186  5950 ;	R6 = register save mask
                                     0186  6000 ;-
                                     0186  6100 
                                     0186  6200 GET_REGS: 				; get register image
                                     0186  6300 
                                     0186  6400 ;+
                                     0186  6500 ; Setup loop to scan back through stack
                                     0186  6600 ;-
                                     0186  6700 
            51         BC AD     DE  0186  6800 	MOVAL	REG_IMAGE(FP), R1	; R1 = Adr. reg image vector
            52            5D     D0  018A  6900 	MOVL	FP, R2			; R2 = Adr. of current frame
                                     018D  7000 					; where all callers register saved
            01            10     78  018D  7100 	ASHL	#16, #1, R4		; R4 = max loop count = 65K
                          54         0190       
            55       FF78 CD     DE  0191  7200 	MOVAL	ADR_IMAGE(FP), R5	; R5 = adr. of array of address where
                                     0196  7300 					; registers are saved.
                                     0196  7400 ;+
                                     0196  7500 ; Loop to scan call stack back to signal exception
                                     0196  7600 ;-
                                     0196  7700 
            14            52     C1  0196  7800 LOOP:	ADDL3	R2, #SF$L_SAVE_REGS, - ; stack frame adr + offset to first reg saved in 
                                     0199       
                          53         0199  7900 		R3			; R3 = adr. of first saved reg.
                          50     D4  019A  8000 	CLRL	R0			; R0 = first possible register # saved
            0C            00     EF  019C  8050 	EXTZV	#SF$V_SAVE_MASK, -	; position of save mask
            56         06 A2         019F       
                                     01A2  8060 		#SF$S_SAVE_MASK, -	; size of save mask
                                     01A2  8070 		SF$W_SAVE_MASK(R2), R6	; R6 = register save mask
                                     01A2  8100 
                                     01A2  8200 ;+
                                     01A2  8300 ; loop to copy saved registers R0:R11 from one call stack frame
                                     01A2  8400 ; to register image array also set address of register image array.
                                     01A2  8500 ;-
                                     01A2  8600 
            0C            50     EA  01A2  8700 LOOP1:	FFS	R0, #12, - 		; find next register in saved bit mask
                                     01A5       
            50            56         01A5  8800 		R6, R0			; R0 = register number of next saved reg.
                                     01A7  8900 
                          12     13  01A7  9000 	BEQL	10$			; branch if finished 12-bit reg mask
            04            00     0D  01A9  9100 	PROBEW	#0, #4, (R3)		; check if stack still writeable
                          63         01AC       
                          24     13  01AD  9200 	BEQL	BAD_STACK1		; branch if stack bad
            6540          53     D0  01AF  9300 	MOVL	R3, (R5)[R0]		; store address of where Rn saved
            6140          83     D0  01B3  9400 	MOVL	(R3)+, (R1)[R0]	        ; copy saved Rn to image + Rn
            56            50     E4  01B7  9450 	BBSC	R0, R6, LOOP1		; clear bit n for Rn, get next bit
                          E7         01BA       
                                     01BB  9600 
                                     01BB  9700 ;+
                                     01BB  9800 ; check if frame just saved is that of call to handler from signal or exception
                                     01BB  9900 ;-
                                     01BB 10000 
                       10 A2     D1  01BB 10100 10$:	CMPL	SF$L_SAVE_PC(R2), -	; saved PC the one from call to handler?
                 00000004'8F         01BE 10200 		#SYS$CALL_HANDL+4	; absolute system vector adr
                          16     13  01C3 10300 	BEQL	END_SCAN		; branch if yes
                                     01C5 10400 
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  17
0-24            GET_REGS Get contents and addresses of all save                                                                  (8)

                                     01C5 10500 ;+
                                     01C5 10600 ; step (cautiously) to previous frame
                                     01C5 10700 ;-
                                     01C5 10800 
                          00     0D  01C5 10900 	PROBEW	#0, #SF$L_SAVE_REGS,-	; check if fixed part of previous frame ok
         0C B2            14         01C7 11000 		@SF$L_SAVE_FP(R2)	;
                          07     13  01CA 11100 	BEQL	BAD_STACK1		; branch if frame not writeable
            52         0C A2     D0  01CC 11200 	MOVL	SF$L_SAVE_FP(R2), R2	; R2 = adr. of previous frame
            C3            54     F5  01D0 11300 	SOBGTR	R4, LOOP		; go back if haven't scanned too many frames
                                     01D3 11400 
                                     01D3 11500 ;+
                                     01D3 11600 ; here if bad stack - return LIB$_BADSTA to caller of LIB$FLT_FIXUP
                                     01D3 11700 ;-
                                     01D3 11800 
                                     01D3 11900 BAD_STACK1:
            50   00000000'8F     D0  01D3 12000 	MOVL	#LIB$_BADSTA, R0	; R0 = BAD STACK completion code
                                 04  01DA 12100 	RET				; return to caller of LIB$FIXUP_FLT
                                     01DB 12200 					; not JSB caller of GET_REGS
                                     01DB 12300 
                                     01DB 12400 ;+
                                     01DB 12500 ; Here when scanned all frames back to call to handler
                                     01DB 12600 ; Copy R0:R1 from mechanism vector. Set AP,FP,SP,PC,PSL
                                     01DB 12700 ; Also set address where each of these registers is saved
                                     01DB 12800 ;-
                                     01DB 12900 
                                     01DB 13000 END_SCAN:
            50         08 AC     D0  01DB 13100 	MOVL	MCH_ARGS_ADR(AP), R0	; R0 = adr. of signal mechanism arglist
                                     01DF 13200 
            65         0C A0     DE  01DF 13300 	MOVAL	CHF$L_MCH_SAVR0(R0), -	; adr. where R0 saved
                                     01E3 13400 		R0_OFF(R5)		; to vector of addresses
         04 A5         10 A0     DE  01E3 13500 	MOVAL	CHF$L_MCH_SAVR1(R0), -	; adr. where R1 saved
                                     01E8 13600 		R1_OFF(R5)		; to image address vector
            61         0C A0     7D  01E8 13700 	MOVQ	CHF$L_MCH_SAVR0(R0), -	; saved R0/R1
                                     01EC 13800 		R0_OFF(R1)		; to register image vector
            51            30     C0  01EC 13900 	ADDL	#AP_OFF, R1		; R1 = adr. in image vector of aP/FP
            55            30     C0  01EF 14000 	ADDL	#AP_OFF, R5		; R5 = adr. in image address vector of AP/FP
                       08 A2     DE  01F2 14100 	MOVAL	SF$L_SAVE_AP(R2), -	; adr of saved AP
                          85         01F5 14200 		(R5)+			; to image address vector
                       0C A2     DE  01F6 14300 	MOVAL	SF$L_SAVE_FP(R2), -	; adr of saved FP
                          85         01F9 14400 		(R5)+			; to image address vector
                       08 A2     7D  01FA 14500 	MOVQ	SF$L_SAVE_AP(R2), -	; saved AP/FP
                          81         01FD 14600 		(R1)+			; to image register vector
            50         04 BC     9A  01FE 14700 	MOVZBL	@SIG_ARGS_ADR(AP), R0	; R0 = # of signal args
                       04 BC40   DE  0202 14800 	MOVAL	@SIG_ARGS_ADR(AP)[R0],- ;
                          50         0206 14900 		R0			; R0 = adr of last signal arg
            50            04     C0  0207 15000 	ADDL	#4, R0			; R0 = SP at time of exception or call LIB$SIGNAL
                                     020A 15100 					; NOTE: this a spec from LIB$SIGNAL and
                                     020A 15200 					; exception processing of operating system!!!
                          85     D4  020A 15300 	CLRL	(R5)+			; SP not saved anywhere so set IMAGE _ADR TO 0
            81            50     D0  020C 15400 	MOVL	R0, (R1)+		; set image SP
            81            70     7D  020F 15500 	MOVQ	-(R0), (R1)+ 		; copy PC/PSL to image (always last
                                     0212 15600 					; 2 signal arguments)
            85            80     DE  0212 15700 	MOVAL	(R0)+, (R5)+		; set adr. where PC saved
            85            80     DE  0215 15800 	MOVAL	(R0)+, (R5)+ 		; set adr. where PSL saved
                                 05  0218 15900 	RSB				; return (to LIB$FIXUP_FLT)
                                     0219 16000 
                                     0219 16100 	.END				; end of LIB$FIXUP_FLT
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  18
SYMBOL TABLE                                                                                                                     (8)

ACBF           = 0000004F            NEW_OPERAND    = 0000000C            SS$_ACCVIO       ********   X   01   
ACCESS_VIO       0000007D R     03   NEXT_BYTE        0000016C R     03   SS$_NORMAL       ********   X   01   
ADDD2          = 00000060            NEXT_LONG        0000017D R     03   SS$_RESIGNAL     ********   X   01   
ADDF2          = 00000040            NEXT_OPERAND     000000C3 R     03   SS$_ROPRAND      ********   X   01   
ADR_IMAGE      = FFFFFF78            NEXT_OPERANDX    0000016B R     03   STACK_OVF        00000082 R     03   
AP_OFF         = 00000030            NEXT_WORD        00000174 R     03   STS$K_ERROR    = 00000002            
AUTO_DECR        0000010D R     03   NOT_RESRV        00000169 R     03   STS$K_INFO     = 00000003            
AUTO_INCR        00000114 R     03   PC_OFF         = 0000003C            STS$K_SEVERE   = 00000004            
AUTO_INCR_DEF    00000120 R     03   POLYF          = 00000055            STS$K_SUCCESS  = 00000001            
BAD_STACK1       000001D3 R     03   PSL_OFF        = 00000040            STS$K_WARNING  = 00000000            
BIT...         = 00000020            R0_OFF         = 00000000            STS$M_CODE     = 00007FF8            
BYTE_DISPL       0000012F R     03   R1_OFF         = 00000004            STS$M_COND_ID  = 0FFFFFF8            
BYTE_DISPL_DEF   00000133 R     03   REG              000000F8 R     03   STS$M_CONTROL  = F0000000            
CHF$L_MCHARGLST  00000008            REG_DEF          00000106 R     03   STS$M_CUST_DEF = 08000000            
CHF$L_MCH_ARGS   00000000            REG_IMAGE      = FFFFFFBC            STS$M_FAC_NO   = 0FFF0000            
CHF$L_MCH_DEPTH  00000008            RESIGNAL         00000077 R     03   STS$M_FAC_SP   = 00008000            
CHF$L_MCH_FRAME  00000004            ROPRAND          00000071 R     03   STS$M_INHIB_MSG= 10000000            
CHF$L_MCH_SAVR0  0000000C            SET_OA2          00000154 R     03   STS$M_MSG_NO   = 0000FFF8            
CHF$L_MCH_SAVR1  00000010            SF$A_HANDLER     00000000            STS$M_SEVERITY = 00000007            
CHF$L_SIGARGLST  00000004            SF$L_SAVE_AP     00000008            STS$M_SUCCESS  = 00000001            
CHF$L_SIG_ARG1   00000008            SF$L_SAVE_FP     0000000C            STS$S_CODE     = 0000000C            
CHF$L_SIG_ARGS   00000000            SF$L_SAVE_PC     00000010            STS$S_COND_ID  = 00000019            
CHF$L_SIG_NAME   00000004            SF$L_SAVE_REGS   00000014            STS$S_CONTROL  = 00000004            
CHK_OP_RSB       0000015B R     03   SF$M_C         = 00000001            STS$S_CUST_DEF = 00000001            
CVTDF          = 00000076            SF$M_DV        = 00000080            STS$S_FAC_NO   = 0000000C            
CVTFD          = 00000056            SF$M_FU        = 00000040            STS$S_FAC_SP   = 00000001            
DISPL            00000141 R     03   SF$M_IV        = 00000020            STS$S_INHIB_MSG= 00000001            
DISPL_DEF        0000014B R     03   SF$M_N         = 00000008            STS$S_MSG_NO   = 0000000D            
EMODF          = 00000054            SF$M_TBIT      = 00000010            STS$S_SEVERITY = 00000003            
END_SCAN         000001DB R     03   SF$M_V         = 00000002            STS$S_SUCCESS  = 00000001            
FIXUP            0000008A R     03   SF$M_Z         = 00000004            STS$V_CODE     = 00000003            
FOR$K_ERR_PREFX= 00000018            SF$S_C         = 00000001            STS$V_COND_ID  = 00000003            
FP_OFF         = 00000034            SF$S_CALLS     = 00000001            STS$V_CONTROL  = 0000001C            
GBL...         = 00000000            SF$S_DV        = 00000001            STS$V_CUST_DEF = 0000001B            
GET_REGS         00000186 R     03   SF$S_FU        = 00000001            STS$V_FAC_NO   = 00000010            
IMAGE_PC       = FFFFFFF8            SF$S_IV        = 00000001            STS$V_FAC_SP   = 0000000F            
IMAGE_PSL      = FFFFFFFC            SF$S_N         = 00000001            STS$V_INHIB_MSG= 0000001C            
INDEXED          000000F0 R     03   SF$S_SAVE_MASK = 0000000C            STS$V_MSG_NO   = 00000003            
K_SAV_IMAGE_SIZ= 00000044            SF$S_STACKOFFS = 00000002            STS$V_SEVERITY = 00000000            
LIB$FIXUP_FLT    00000000 RG    03   SF$S_TBIT      = 00000001            STS$V_SUCCESS  = 00000000            
LIB$_BADSTA      ********   X   01   SF$S_V         = 00000001            SYS$CALL_HANDL   ********   X   01   
LIB$_PUSSTAOVE   ********   X   01   SF$S_Z         = 00000001            S_MZERO        = 00000009            
LONG_DISPL       0000013F R     03   SF$V_C         = 00000000            V_MZERO        = 00000007            
LONG_DISPL_DEF   00000149 R     03   SF$V_CALLS     = 0000000D            WORD_DISPL       00000137 R     03   
LOOP             00000196 R     03   SF$V_DV        = 00000007            WORD_DISPL_DEF   0000013B R     03   
LOOP1            000001A2 R     03   SF$V_FU        = 00000006            
LOOP_OP          000000C5 R     03   SF$V_IV        = 00000005            
MCH_ARGS_ADR   = 00000008            SF$V_N         = 00000003            
MTH$K_ERR_PREFX= 00000016            SF$V_SAVE_MASK = 00000000            
MTH__FLOOVEMAT = 00000058            SF$V_STACKOFFS = 0000000E            
MTH__FLOUNDMAT = 00000059            SF$V_TBIT      = 00000004            
MTH__INVARG    = 00000051            SF$V_V         = 00000001            
MTH__LOGZERNEG = 00000053            SF$V_Z         = 00000002            
MTH__SINSIGLOS = 00000057            SF$W_SAVE_MASK   00000006            
MTH__SQUROONEG = 00000054            SF$W_SAVE_PSW    00000004            
MTH__UNDEXP    = 00000052            SIG_ARGS_ADR   = 00000004            
MTH__WRONUMARG = 00000050            SP_OFF         = 00000038            
LIB$FIXUP_FLT   ; LIBRARY fixup floating/double resrv. op.       21-AUG-1978 18:57:49   VAX-11 MACRO X0.3-11               Page  19
PROGRAM SECTION SYNOPSIS                                                                                                         (8)



PROGRAM SECTION SYNOPSIS

.  ABS  .        00000000      00     NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT BYTE  
. BLANK .        00000000      01     NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT BYTE  
$ABS$            00000018      02     NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT BYTE  
LIB$CODE         00000219      03       PIC   USR   CON   REL   LCL   SHR   EXE   RD  NOWRT LONG  


THERE WERE NO ERRORS OR WARNINGS.
23530. BYTES LEFT IN FREE MEMORY POOL.
8. BYTES OF RECLAIMED MEMORY.
OBJ$:LIBFIXUPF,LIS$:LIBFIXUPF/-SP=LIB$:S/ML,SRC$:P,LIBFIXUPF
8 MLB DIR RDS - 170 GETS TO DEFINE 10 MACROS. 17 INTER. FILE WRITES. 
