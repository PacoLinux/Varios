
; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 1
;
;00100  0001	MODULE FOR$$ERROR (	! Internal FORTRAN error handling module
;00200  0002		IDENT = '0-56'	! File: FERROR.B32
;00300  0003			) =
;00400  0004	BEGIN
;00500  0005	
;00600  0006	!
;00700  0007	!			  COPYRIGHT (c) 1977 BY
;00800  0008	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;00900  0009	!
;01000  0010	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;01100  0011	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;01200  0012	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;01300  0013	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;01400  0014	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;01500  0015	! TRANSFERRED.
;01600  0016	!
;01700  0017	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;01800  0018	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;01900  0019	! CORPORATION.
;02000  0020	!
;02100  0021	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;02200  0022	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;02300  0023	!
;02400  0024	
;02500  0025	!++
;02600  0026	! FACILITY:  FORTRAN support library
;02700  0027	!
;02800  0028	! ABSTRACT:
;02900  0029	!
;03000  0030	!	This module contains the error handlers needed by
;03100  0031	!	the common OTS for handling FORTRAN errors.  In particular
;03200  0032	!	there is a handler for errors in OPEN/CLOSE where ERR=
;03300  0033	!	means error return to caller rather than a transfer.
;03400  0034	!	A second handler (FOR$$ERR_END_HND is provided
;03500  0035	!	for I/O statements where the optional ERR= and END=
;03600  0036	!	constructs require a transfer of control to the
;03700  0037	!	user program rather than an an error return.
;03800  0038	!	An argument specifies the cleanup to be performed if UNWIND occurs.
;03900  0039	!
;04000  0040	! ENVIRONMENT:  User mode, AST level or not or mixed.
;04100  0041	!		Note: this module is both shared (with no entry vectors) and non-shared
;04200  0042	!		if FORTRAN compatibility routines call.
;04300  0043	!
;04400  0044	! AUTHOR: Thomas N. Hastings, CREATION DATE: 03-Jun-77
;04500  0045	!
;04600  0046	! MODIFIED BY:
;04700  0047	!
;04800  0048	! 	Thomas N. Hastings, 03-Jun-77: VERSION 01
;04900  0049	! 01	-  original
;05000  0050	! 1-5	-  added unwind cleanup TNH
;05100  0051	! 0-15	- Set user PC and print (for debugging) TNH 24-SEP-77
;05200  0052	! 0-16	- Don't look at STS$V_SUBSYS_SP bit.  TNH 6-Oct-77
;05300  0053	! 0-28	- Fix truncation error to LIB$K_VERSION.  TNH 14-Oct-77
;05400  0054	! 0-29	- Use better STSDEF  symbols.  TNH 15-Oct-77
;05500  0055	! 0-30	- Make 2nd arg to FOR$$ERR_OPECLO optioonal.  TNH 15-Oct-77

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 1-1
;
;05600  0056	! 0-31	- Resignal all but FOR$_ signals.  TNH 19-Oct-77
;05700  0057	! 0-33	- MAKE END= WORK.  TNH 19-OCT-77
;05800  0058	! 0-34	- Fix bug with optional OPEN array.  JMT 24-Oct-77
;05900  0059	! 0-35	- Mask out severity.  TNH 27-Oct-77
;06000  0060	! 0-36	- Use FOR$K_abcmno36yz as E36TERNAL LITERALs.  TNH 27-Oct-77
;06100  0061	! 0-39	- Print resultant name string if it's there (TEMPORARY CODE!!)  JMT 22-Nov-77
;06200  0062	! 0-40	- Add temporary code to second handler.  TNH 01-Dec-77
;06300  0063	! 0-41	- Use FOR$$SIG_FATINT.  TNH 01-Dec-77
;06400  0064	! 0-42	- Add new UNWIND condition: UNWINDRET.  JMT 3-Dec-77
;06500  0065	! 0-43	- Change LIB$ external references to addressing_mode (general).
;06600  0066	!	- JMT 8-Dec-77
;06700  0067	! 0-44	- Use FOR$$FREE_VM.  TNH 16-Dec-77
;06800  0068	! 0-45	- Use LUB bit VIRT_RSN to determine if RSN is in virtual memory.
;06900  0069	!	  JMT 18-Dec-77
;07000  0070	! 0-46	- Comment out some debugging stuff.  JMT 17-Jan-78
;07100  0071	! 0-47	- Global register CCB.  JMT 8-Apr-78
;07200  0072	! 0-48	- Change to STARLET library. DGP 20-Apr-78
;07300  0073	! 0-49	- Change REQUIRE files for VAX system build.  DGP 28-Apr-78
;07400  0074	! 0-50	- Change STARLET to RTLSTARLE to avoid conflicts.  DGP 1-May-78
;07500  0075	! 0-51	- Use JSB linkage.  TNH 22-MAY-78
;07600  0076	! 0-52	- Remove check for SS$_SFAIL.  TNH 5-July-78
;07700  0077	! 0-53	- Remove %REF to get around BLISS bug.  TNH 15-July-78
;07800  0078	! 0-54	- Declare SYS$UNWIND EXTERNAL and don't use SETUNWIND (NEWBLISS bug).  TNH 2-Aug-78
;07900  0079	! 0-55	- Call FOR$$CB_GET instead of referencing OTS$$A_CUR_LUB.  TNH 2-Aug-78
;08000  0080	! 0-56	- Make all EXTERNAL references GENERAL.  TNH 3-Aug-78
;08100  0081	!--

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 2
;
;00100  0082	!
;00200  0083	! LINKAGES:
;00300  0084	!
;00400  0085	REQUIRE 'RTLIN:FLNK';		! define all linkages
; %PRINT:	File: FLNK.B32; Version 1, edit 12, TNH 2-Aug-78
;00500  0307	
;00600  0308	!
;00700  0309	! TABLE OF CONTENTS:
;00800  0310	!
;00900  0311	
;01000  0312	FORWARD ROUTINE
;01100  0313		FOR$$ERR_OPECLO,	! Error handler for OPEN/CLOSE
;01200  0314		FOR$$ERR_ENDHND,	! ERR=/END= handler for I/O statements
;01300  0315		CLEANUP_LUB: NOVALUE;	! Perform appropriate LUB cleanup if UNWIND.
;01400  0316	
;01500  0317	BUILTIN
;01600  0318		CALLG;			! Pass entire arg list along
;01700  0319	
;01800  0320	!
;01900  0321	! INCLUDE FILES:
;02000  0322	!
;02100  0323	
;02200  0324		REQUIRE 'RTLML:FERR';		! FORTRAN error number definitions
; %PRINT:	Filename: FERR.MDL! Version 0, edit 36, TNH 19-June-78
;02300  0442		REQUIRE	'RTLML:FLUB';		! LUB offset definitions
; %PRINT:	File: FLUB.MDL which produces FLUB.B32! Version 0, edit 30, TNH, 17-June-78
;02400  0610		REQUIRE 'RTLIN:FMAC';		! FORTRAN macros
; %PRINT:	Filename: FMAC.B32; Version 1, edit 29, TNH, 7-JUN-78
; %PRINT:	 REQUIRE FILE: LPSECT.B32, VERSION 01-5, TNH, 27-Jun-78
;02500  0790		REQUIRE 'RTLIN:FOPN';		!  OPEN/CLOSE parameter values
; %PRINT:	Filename: FOPN.B32; version 0, edit 22, TNH, 30-May-78
;02600  0929		REQUIRE 'RTLML:FPAR';		! FORTRAN inter-module parameters
; %PRINT:	File: FPAR.MDL! version 0, edit 11, TNH, 30-May-78
;02700  1031		REQUIRE 'RTLIN:ODBG';		! OTS debugging macros
; %PRINT:	Filename: NODBG.B32; Version 0, edit 20, JMT, 17-Jan-78
;02800  1107		LIBRARY 'RTLSTARLE';	! STARLET library for macros and symbols
;02900  1108	!
;03000  1109	! MACROS:
;03100  1110	!
;03200  1111	!	NONE
;03300  1112	!
;03400  1113	! EQUATED SYMBOLS:
;03500  1114	!
;03600  1115	!	NONE
;03700  1116	!
;03800  1117	! PSECT DECLARATIONS:
;03900  1118	!
;04000  1119	
;04100  1120		DECLARE_PSECTS (FOR);	! declare PSECTs for FOR$ facility
;04200  1121	
;04300  1122	!
;04400  1123	! OWN STORAGE:
;04500  1124	!
;04600  1125	!	NONE
;04700  1126	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 2-1
;
;04800  1127	! EXTERNAL REFERENCES:
;04900  1128	!
;05000  1129	
;05100  1130	!+
;05200  1131	! MAINTENANCE NOTE:  Since this module is called by FORTRAN compatibility
;05300  1132	! routines which are un-shared and the entry points are not vectored,
;05400  1133	! a separate copy of this module is linked with the user program when
;05500  1134	! the user calls a FORTRAN compatibility routine.  In order to prevent
;05600  1135	! data truncation errors from the linker, all external references are
;05700  1136	! of addressing mode general (rather than word displacement) even for
;05800  1137	! the same PSECT.
;05900  1138	!-
;06000  1139	
;06100  1140	EXTERNAL ROUTINE
;06200  1141		FOR$$CB_GET: JSB_CB_GET NOVALUE ADDRESSING_MODE (GENERAL),	! Get current LUB/ISB/RAB
;06300  1142							! Note: this non-shared routine is loaded if
;06400  1143							! compatibility routines call, so can't reference
;06500  1144							! OTS$$A_CUR_LUB directly.
;06600  1145		FOR$$CB_POP: JSB_CB_POP NOVALUE ADDRESSING_MODE (GENERAL),	! Pop current LUB/ISB/RAB
;06700  1146		FOR$$CB_RET: JSB_CB_RET NOVALUE ADDRESSING_MODE (GENERAL),	! Return current LUB/ISB/RAB
;06800  1147						! as specified by CCB.
;06900  1148		FOR$$FREE_VM: NOVALUE ADDRESSING_MODE (GENERAL),		! free dynamic memory
;07000  1149						! SIGNAL_STOP if error
;07100  1150		FOR$$SIG_FATINT: NOVALUE ADDRESSING_MODE (GENERAL),	! SIGNAL_STOP OTS$_FATINTERR 
;07200  1151						! (FATAL INTERNAL ERROR IN RUN-TIME LIBRARY)
;07300  1152						! Free VM without signalling
;07400  1153		LIB$SIG_TO_RET: ADDRESSING_MODE (GENERAL),	! convert a SIGNAL to error return
;07500  1154						! to caller of establisher with R0 set to signal value.
;07600  1155		SYS$UNWIND: ADDRESSING_MODE (GENERAL);	! System service to unwind stack
;07700  1156	
;07800  1157	EXTERNAL LITERAL
;07900  1158		FOR$_ENDDURREA: UNSIGNED (%BPVAL);	! Condition value = (24'END-OF-FILE DURING READ')

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 3
;
;00100  1159	GLOBAL ROUTINE FOR$$ERR_OPECLO (	! Error condition handler for OPEN/CLOSE
;00200  1160		SIG_ARGS_ADR,			! Adr. of SIGNAL args
;00300  1161		MCH_ARGS_ADR,			! Adr. of mechanism args
;00400  1162		ENB_ARGS_ADR)			! Adr.  of ENABLE declared args
;00500  1163		=				! Condition handlers always have values
;00600  1164	
;00700  1165	!++
;00800  1166	! FUNCTIONAL DESCRIPTION:
;00900  1167	!
;01000  1168	!	FOR$$ERR_OPECLO is an error conditon handler established by
;01100  1169	!	the OPEN and CLOSE statement procedures.  If the user specified
;01200  1170	!	an ERR= keyword parameter, the handler unwinds the stack after
;01300  1171	!	storing the signaled error condition in the saved image of R0.
;01400  1172	!	Otherwise, FOR$$ERR_OPECLO just resignals by simply returning
;01500  1173	!	SS$_RESIGNAL (to CHF).
;01600  1174	!	If and when an UNWIND occurs, the ENABLE arg UNWIND_ACT_ADR
;01700  1175	!	specifies whether the LUB/ISB/RAB is to be pop, returned, or no-opped.
;01800  1176	!	It is not popped if it had not yet been pushed as indicated
;01900  1177	!	by the ENABLE arg UNWIND_ACT_ADR.
;02000  1178	!
;02100  1179	! FORMAL PARAMETERS:
;02200  1180	!
;02300  1181	!	SIG-ARG-ADR		
;02400  1182	!	SIG_ARGS_ADR.rl.ra	Adr. of Signal arg list
;02500  1183	!	MCH_ARGS_ADR.rl.ra	Adr. of mechanism arg list
;02600  1184	!	ENB_ARGS_ADR.rl.ra	Adr. of ENABLE arg list which contains:
;02700  1185	!	    ENABLE_COUNT.rbu.v	No. of longword following in ENABLE arg list
;02800  1186	!	    UNWIND_ACT_ADR.rl.r	Adr. of longword containing UNWIND action code.
;02900  1187	!				Any of FOR$K_UNWINDNOP, FOR$K_UNWINDPOP,
;03000  1188	!				FOR$K_UNWINDRET.
;03100  1189	!	    [OPECLO_ADR.rlu.ra] Optional adr. of cannonical array of OPEN or CLOSE keyword
;03200  1190	!				parameters after the encoded user parameter
;03300  1191	!				list has been scanned and expanded into it.
;03400  1192	!				Symbolic offsets into ENB_ARGS_ADR[1,OPEN$K_name] are of the
;03500  1193	!				form OPEN$K_name as defined in FOPN.B32 REQUIRE file.
;03600  1194	!				If ommitted, assume no ERR= (DEFINE FILE, REWIND, etc)
;03700  1195	!
;03800  1196	! IMPLICIT INPUTS:
;03900  1197	!
;04000  1198	!	OTS$$A_CUR_LUB		Adr. of current LUB/ISB/RAB or 0
;04100  1199	!				Note: obtained by calling FOR$$CB_GETrather than directly.
;04200  1200	!
;04300  1201	! IMPLICIT OUTPUTS:
;04400  1202	!
;04500  1203	!	SIG_ARGS_ADR[SIG$_USER_PC]	Set to user call PC to RTL
;04600  1204	!
;04700  1205	! COMPLETION CODES:
;04800  1206	!
;04900  1207	!	SS$_RESIGNAL if no ERR= was specified
;05000  1208	!	SS$_NORMAL if ERR= was specified (ignored by CHF on UNWIND)
;05100  1209	!
;05200  1210	! SIDE EFFECTS:
;05300  1211	!
;05400  1212	!	If the user has specified ERR=, the stack is unwound to the
;05500  1213	!	caller of the establisher (i.e., the user program) with the save image

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 3-1
;
;05600  1214	!	of R0 set to the error status.
;05700  1215	!	If no ERR= was specified,the error conditon is resignaled.
;05800  1216	!	If UNWIND call, the current LUB/ISB/RAB may be popped or returned.
;05900  1217	!--
;06000  1218	
;06100  1219	    BEGIN
;06200  1220	    BUILTIN
;06300  1221		AP;				! needed to pass entire argument list along TO LIB$SIG_TO_RET
;06400  1222	    LITERAL				! Define ENABLE arglist offsets
;06500  1223		ENABLE_COUNT = 0,		! Offset in ENB_ARGS_ADR of no. of enable args following
;06600  1224		UNWIND_ACT_ADR = 1,		! Adr. of longword containing
;06700  1225						! UNWIND action code.
;06800  1226		OPECLO_ADR = 2;			! Adr. of OPEN/CLOSE cannonical array
;06900  1227	    MAP
;07000  1228		SIG_ARGS_ADR: REF BLOCK[, BYTE],	! SIGNAL args
;07100  1229		MCH_ARGS_ADR: REF BLOCK[, BYTE],	! mechanism args
;07200  1230		ENB_ARGS_ADR: REF VECTOR[OPECLO_ADR, LONG]; !ENABLE args list array
;07300  1231	    LOCAL
;07400  1232		EST_FP: REF BLOCK[,BYTE],		! Establisher's FP
;07500  1233		OPECLO_ARRAY: REF VECTOR[OPEN$K_KEY_MAX+1, LONG]; ! OPEN/CLOSE cannonical array
;07600  1234	
;07700  1235	    !+
;07800  1236	    ! If this is unwind condition, perform cleanup. since
;07900  1237	    ! Perform LUB cleanup indicated by EBABLE arg UNWIND_ACT_ADR
;08000  1238	    ! (set by the establisher).
;08100  1239	    !-
;08200  1240	
;08300  1241	    IF .BLOCK[SIG_ARGS_ADR[CHF$L_SIG_NAME], STS$V_COND_ID; , BYTE] EQL (SS$_UNWIND ^-3)
;08400  1242	    THEN 
;08500  1243		BEGIN
;08600  1244		CLEANUP_LUB (..ENB_ARGS_ADR[UNWIND_ACT_ADR]);
;08700  1245		RETURN SS$_NORMAL;
;08800  1246		END;
;08900  1247	
;09000  1248	    !+
;09100  1249	    ! Check if this is a FORTRAN specific error begin signaled (FOR$_xxx).
;09200  1250	    ! If it is, check for ERR= supplied by user and set user PC.
;09300  1251	    ! Else if this is any other system signaled error, just resignal.  It must
;09400  1252	    ! be an error in OTS such as an access violation.
;09500  1253	    !-
;09600  1254	
;09700  1255	    IF .BLOCK[SIG_ARGS_ADR[CHF$L_SIG_NAME], STS$V_FAC_NO; , BYTE] EQL FOR$K_FAC_NO
;09800  1256	    THEN
;09900  1257	
;10000  1258		!+
;10100  1259		! This is a FORTRAN specific error begin signaled.
;10200  1260		! Check if user provided ERR= keyword or not.  If yes, convert signal to
;10300  1261		! a return to the caller of the establisher with condition value in R0.
;10400  1262		! If caller omitted OPECLO_ADR entry in ENB_ARGS_ADR, treat as if no ERR=.
;10500  1263		!-
;10600  1264	
;10700  1265		BEGIN
;10800  1266		OPECLO_ARRAY = .ENB_ARGS_ADR[OPECLO_ADR];
;10900  1267		IF .ENB_ARGS_ADR[ENABLE_COUNT] GEQU OPECLO_ADR AND .OPECLO_ARRAY[OPEN$K_ERR]
;11000  1268		THEN

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 3-2
;
;11100  1269		    BEGIN
;11200  1270		    IF NOT CALLG (.AP, LIB$SIG_TO_RET)
;11300  1271		    THEN
;11400  1272			FOR$$SIG_FATINT ()
;11500  1273		    END
;11600  1274	
;11700  1275		ELSE
;11800  1276	
;11900  1277		    !+
;12000  1278		    ! No ERR=, so set user call PC saved in stack frame of establisher and RESIGNAL
;12100  1279		    !-
;12200  1280	
;12300  1281		    BEGIN
;12400  1282		    EST_FP = .MCH_ARGS_ADR[CHF$L_MCH_FRAME];
;12500  1283		    SIG_ARGS_ADR[FOR$L_SIG_UPC] = .EST_FP[SF$L_SAVE_PC];
;12600  1284	
;12700  1285		    !+
;12800  1286		    ! Print if debugging \\\\\
;12900  1287		    !-
;13000  1288	
;13100  1289		    PRINT_DEC (FOR$$ERR_OPECLO,
;13200P 1290		    	' RUN-TIME LIBRARY version = V0.', LIB$K_VERSION,
;13300P 1291		    	' FORTRAN error # = ', .BLOCK[SIG_ARGS_ADR[FOR$L_SIG_NAME], STS$V_CODE; , BYTE],
;13400P 1292		    	' for unit = ', .SIG_ARGS_ADR[FOR$L_SIG_LUN]);
;13500  1293	
;13600  1294	!	    !+
;13700  1295	!	    ! \\\ If string descriptor for resultant name string is present,
;13800  1296	!	    ! print the string. \\\
;13900  1297	!	    !-
;14000  1298	!
;14100  1299	!	    IF .SIG_ARGS_ADR[FOR$A_SIG_RNS] NEQA 0
;14200  1300	!	    THEN
;14300  1301	!		LIB$PUT_OUTPUT (.SIG_ARGS_ADR[FOR$A_SIG_RNS]);
;14400  1302	
;14500  1303		    PRINT_HEX (FOR$$ERR_OPECLO,
;14600P 1304		    	' user PC = ', .SIG_ARGS_ADR[FOR$L_SIG_UPC],
;14700P 1305		    	' RMS {FAB,RAB}$L_STS = ', .SIG_ARGS_ADR[FOR$L_SIG_STS],
;14800P 1306		    	' RMS {FAB,RAB}$L_STV = ', .SIG_ARGS_ADR[FOR$L_SIG_STV]);
;14900  1307		    END;			! End no ERR=
;15000  1308		END;			! End of FORTRAN specific error signaling
;15100  1309	
;15200  1310	    !+
;15300  1311	    ! Return resignal condition (ignored if SYS$UNWIND called).
;15400  1312	    !-
;15500  1313	
;15600  1314	    RETURN SS$_RESIGNAL
;15700  1315	    END;    ! End of FOR$$ERR_OPECLO handler


							    .TITLE  FOR$$ERROR
							    .IDENT  \0-56\

							    .EXTRN  FOR$$CB_GET, FOR$$CB_POP, FOR$$CB_RET, FOR$$FREE_VM
							    .EXTRN  FOR$$SIG_FATINT, LIB$SIG_TO_RET, SYS$UNWIND, FOR$_ENDDURREA


; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 3-3
;
							    .PSECT  FOR$CODE,NOWRT,  SHR,  PIC,2

					 0004 00000 	    .ENTRY  FOR$$ERR_OPECLO, Save R2				      ; 1159
		         52 	  04   AC  D0 00002 	    MOVL    SIG_ARGS_ADR, R2					      ; 1241
      04   A2	         19 	       03  ED 00006 	    CMPZV   #3, #25, 4(R2), #292				      ;
			    00000124   8F     0000B									      ;
				       10  12 00010 	    BNEQ    1$							      ;
		         50 	  0C   AC  D0 00012 	    MOVL    ENB_ARGS_ADR, R0					      ; 1244
				  04   B0  DD 00016 	    PUSHL   @4(R0)						      ;
		  0000V  CF	       01  FB 00019 	    CALLS   #1, CLEANUP_LUB					      ;
		         50 	       01  D0 0001E 	    MOVL    #1, R0						      ; 1245
					   04 00021 	    RET     							      ;
      06   A2	         0C 	       00  ED 00022 1$:     CMPZV   #0, #12, 6(R2), #24					      ; 1255
				       18     00027									      ;
				       31  12 00028 	    BNEQ    3$							      ;
		         50 	  0C   AC  D0 0002A 	    MOVL    ENB_ARGS_ADR, R0					      ; 1266
		         51 	  08   A0  D0 0002E 	    MOVL    8(R0), OPECLO_ARRAY					      ;
		         02 	       60  D1 00032 	    CMPL    (R0), #2						      ; 1267
				       17  1F 00035 	    BLSSU   2$							      ;
		         13 	  0C   A1  E9 00037 	    BLBC    12(OPECLO_ARRAY), 2$				      ;
	      00000000G  00	       6C  FA 0003B 	    CALLG   (AP), LIB$SIG_TO_RET				      ; 1270
		         16 	       50  E8 00042 	    BLBS    R0, 3$						      ;
	      00000000G  00	       00  FB 00045 	    CALLS   #0, FOR$$SIG_FATINT					      ; 1272
				       0D  11 0004C 	    BRB     3$							      ; 1267
		         50 	  08   AC  D0 0004E 2$:     MOVL    MCH_ARGS_ADR, R0					      ; 1282
		         50 	  04   A0  D0 00052 	    MOVL    4(R0), EST_FP					      ;
		    14   A2	  10   A0  D0 00056 	    MOVL    16(EST_FP), 20(R2)					      ; 1283
		         50 	0918   8F  3C 0005B 3$:     MOVZWL  #2328, R0						      ; 1314
					   04 00060 	    RET     							      ; 1159

; Routine Size:  97 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 4
;
;00100  1316	GLOBAL ROUTINE FOR$$ERR_ENDHND (	! FORTRAN I/O statement ERR=/END= error condition handler
;00200  1317		SIG_ARGS_ADR,			! Adr. of signal arg list
;00300  1318		MCH_ARGS_ADR,		! Adr. of mechanism arg list
;00400  1319		ENB_ARGS_ADR)		! Adr. of ENABLE arg list
;00500  1320		=			! Return status for a condition handler
;00600  1321	
;00700  1322	!++
;00800  1323	! FUNCTIONAL DESCRIPTION:
;00900  1324	!
;01000  1325	!	FOR$$ERR_ENDHND is an error condition handler established
;01100  1326	!	by each I/O statement which has an  ERR= and END= error transfer
;01200  1327	!	mechanism (as an option of the user program).
;01300  1328	!
;01400  1329	!	If the signaled condition is FOR$_ENDDURREA (24='END-OF_FILE DURING READ')
;01500  1330	!	and an END= has been specified by the user in his I/O statement
;01600  1331	!	(.END_EQL_ADR NEQ 0), the handler unwinds to the user specified address (by calling
;01700  1332	!	SYS$UNWIND with depth equal to CHF$L_MCH_DEPTH + ..INCR_DEPTH_ADR + 1)
;01800  1333	!	and new_PC equal to ..END_EQL_ADR.
;01900  1334	!	Otherwise, if an ERR= had been specified by the user in his I/O statement
;02000  1335	!	(ERR_EQUL NEQ 0), the handler unwinds to the user specified address
;02100  1336	!	by calling SYS$UNWIND with depth equal to CHF$L_MCH_DEPTH + ..INCR_DEPTH_ADR + 1
;02200  1337	!	and new_PC equal to ..ERR_EQL_ADR.
;02300  1338	!
;02400  1339	!	If neither of the above cases holds, the error is resignaled
;02500  1340	!	so that a user handler or the OTS default handler will get invoked.
;02600  1341	!	If UNWIND occurs, the appropriate cleanup takes place,
;02700  1342	!	as indicated by the establisher in the ENABLE arg UNWIND_ACT_ADR.
;02800  1343	!	If FOR$K_UNWINDPOP is indicated, the current LUB/ISB/RAB is popped.
;02900  1344	!	If FOR$K_UNWINDRET is indicated, the LUB/ISB/RAB is returned and the
;03000  1345	!	file closed.
;03100  1346	!	Otherwise (FOR$K_UNWINDNOP) nothing is done.
;03200  1347	!
;03300  1348	! FORMAL PARAMETERS:
;03400  1349	!
;03500  1350	!	SIG_ARGS_ADR.ml.ra	Adr. of signal arg list
;03600  1351	!	MCH_ARGS_ADR.ml.ra	Adr. of mechanism arg list
;03700  1352	!	ENB_ARGS_ADR.ml.ra	Adr. of ENABLE arg list which contains:
;03800  1353	!	    UNWIND_ACT_ADR.rl.r	Adr. of longword contining UNWIND action code.
;03900  1354	!				Any of FOR$K_UNWINDNOP, FOR$K_UNWINDPOP,
;04000  1355	!				FOR$K_UNWINDRET.
;04100  1356	!	    ERR_EQL_ADR.ra.r	Adr. of longword containing Adr. of the user address 
;04200  1357	!				to be transferred to or 0 on any error condition
;04300  1358	!	    END_EQL_ADR.ra.r	Adr of longword containing Adr. of the user address 
;04400  1359	!				to be transferred to or 0 on end-of-file
;04500  1360	!	    INCR_DEPTH_ADR.rl.r	Adr. of longword containing Incremental no. of frames between the establisher
;04600  1361	!				and the users program (usually 0 or 1).
;04700  1362	! Note:	All parameters to a condition handler must be addresses of values in BLISS if used in an ENABLE.	
;04800  1363	!
;04900  1364	! IMPLICIT INPUTS:
;05000  1365	!
;05100  1366	!	OTS$$A_CUR_LUB		Adr. of current LUB/ISB/RAB or 0
;05200  1367	!				Note: obtained by calling FOR$$CB_GET rather than directly.
;05300  1368	!
;05400  1369	! IMPLICIT OUTPUTS:
;05500  1370	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 4-1
;
;05600  1371	!	SIG_ARGS_ADR[SIG$_USER_PC]	Set to user call PC to RTL
;05700  1372	!
;05800  1373	! COMPLETION CODES:
;05900  1374	!
;06000  1375	!	SS$_RESIGNAL if no ERR= or END= was specified by user, so that
;06100  1376	!	a user handler or the default OTS handler will get a chance.
;06200  1377	!	SS$_NORMAL if unwind called (although ignored if unwind called)
;06300  1378	!
;06400  1379	! SIDE EFFECTS:
;06500  1380	!
;06600  1381	!	If END= and EOF OR ERR= was specified, the stack is unwound
;06700  1382	!	to user and new_PC is set from ..END_EQL_ADR or .ERR_EQL_ADR.
;06800  1383	!	If unwind, the current LUB/ISB/RAB may be popped or returned.
;06900  1384	!--
;07000  1385	
;07100  1386	    BEGIN
;07200  1387	    LOCAL
;07300  1388		EST_FP: REF BLOCK[,BYTE];	! Establisher's FP
;07400  1389	    LITERAL				! Declare offsets in ENABLE VECTOR arg list
;07500  1390		UNWIND_ACT_ADR = 1,		! UNWIND action code
;07600  1391		ERR_EQL_ADR = 2,		! ERR= adr or 0
;07700  1392		END_EQL_ADR = 3,		! END= adr or 0
;07800  1393		INCR_DEPTH_ADR = 4;		! incremental depth
;07900  1394	    MAP
;08000  1395		SIG_ARGS_ADR: REF BLOCK[, BYTE], ! SIGNAL arg list
;08100  1396		MCH_ARGS_ADR: REF BLOCK[, BYTE], ! mechanism arg list
;08200  1397		ENB_ARGS_ADR: REF VECTOR[INCR_DEPTH_ADR+1, LONG]; ! ENABLE arg list
;08300  1398	
;08400  1399	    INPUT_FORMALS (FOR$$ERR_ENDHND,
;08500P 1400		'.SIG_ARGS_ADR', .SIG_ARGS_ADR,
;08600P 1401		'.MCH_ARGS_ADR', .MCH_ARGS_ADR,
;08700P 1402		'.ENB_ARGS_ADR', .ENB_ARGS_ADR,
;08800P 1403		'..ENB_ARGS_ADR[ERR_EQL_ADR]', ..ENB_ARGS_ADR[ERR_EQL_ADR],
;08900P 1404		'..ENB_ARGS_ADR[END_EQL_ADR]', ..ENB_ARGS_ADR[END_EQL_ADR],
;09000P 1405		'..ENB_ARGS_ADR[INCR_DEPTH_ADR]', ..ENB_ARGS_ADR[INCR_DEPTH_ADR]);
;09100  1406	
;09200  1407	    !+
;09300  1408	    ! Check for unwinding since handler gets called when it does an unwind.
;09400  1409	    ! If unwind, perform cleanup indicated by ENABLE arg UNWIND_ACT_ADR.
;09500  1410	    ! Then return to the unwinder to keep unwinding (return value ignored).
;09600  1411	    !-
;09700  1412	
;09800  1413	    IF .BLOCK[SIG_ARGS_ADR[CHF$L_SIG_NAME], STS$V_COND_ID; , BYTE] EQL (SS$_UNWIND ^-3)
;09900  1414	    THEN
;10000  1415		BEGIN
;10100  1416		CLEANUP_LUB (..ENB_ARGS_ADR[UNWIND_ACT_ADR]);
;10200  1417		RETURN SS$_NORMAL;
;10300  1418		END;
;10400  1419	
;10500  1420	    !+
;10600  1421	    ! Check if this is a FORTRAN specific error (FOR$_xxx).
;10700  1422	    ! If yes, check for END= or ERR=.
;10800  1423	    ! Else if this is any other system signaled error, just resignal.  It must
;10900  1424	    ! be an error in OTS such as an access violation.
;11000  1425	    !-

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 4-2
;
;11100  1426	
;11200  1427	    IF .BLOCK[SIG_ARGS_ADR[CHF$L_SIG_NAME], STS$V_FAC_NO; , BYTE] EQL FOR$K_FAC_NO
;11300  1428	    THEN
;11400  1429	
;11500  1430	
;11600  1431		!+
;11700  1432		! This is a FORTRAN specific error being signaled. Check for END= and ERR=.
;11800  1433		! If this is end-of-file (during read)
;11900  1434		! Unwind to the user with the new_pc being .END_ADR.
;12000  1435		!-
;12100  1436	
;12200  1437		BEGIN
;12300  1438		IF ..ENB_ARGS_ADR[END_EQL_ADR] NEQA 0 AND .SIG_ARGS_ADR[CHF$L_SIG_NAME] EQL FOR$_ENDDURREA
;12400  1439		THEN
;12500  1440		    BEGIN
;12600  1441		    LOCAL T;
;12700  1442		    T = .MCH_ARGS_ADR[CHF$L_MCH_DEPTH] + ..ENB_ARGS_ADR[INCR_DEPTH_ADR] + 1;
;12800  1443		    IF SYS$UNWIND (T, ..ENB_ARGS_ADR[END_EQL_ADR])
;12900  1444		    THEN
;13000  1445		    	RETURN SS$_NORMAL
;13100  1446		    ELSE
;13200  1447			FOR$$SIG_FATINT ()
;13300  1448		    END;
;13400  1449	
;13500  1450		!+
;13600  1451		! If this is an error, and ERR= was specified by the user,
;13700  1452		! Unwind to the user with the new-pc being .ERR_ADR.
;13800  1453		!-
;13900  1454	
;14000  1455		IF ..ENB_ARGS_ADR[ERR_EQL_ADR] NEQA 0
;14100  1456		THEN
;14200  1457		    BEGIN
;14300  1458		    LOCAL T;
;14400  1459		    T = .MCH_ARGS_ADR[CHF$L_MCH_DEPTH] + ..ENB_ARGS_ADR[INCR_DEPTH_ADR] + 1;
;14500  1460		    IF SYS$UNWIND (T, ..ENB_ARGS_ADR[ERR_EQL_ADR])
;14600  1461		    THEN
;14700  1462		    	RETURN SS$_NORMAL
;14800  1463		    ELSE
;14900  1464			FOR$$SIG_FATINT ()
;15000  1465		    END;
;15100  1466	
;15200  1467		!+
;15300  1468		! If neither END= nor ERR= specified by user.
;15400  1469		! Scan back from frame of establisher to frame of routine to called by user.
;15500  1470		! Set user CALL PC to library in SIGNAL arg list.
;15600  1471		! Just indicate to the condition handling facility to resignal the condition
;15700  1472		! so that a user supplied handler or the OTS default handler will get a chance to handle.
;15800  1473		!-
;15900  1474	
;16000  1475		EST_FP = .MCH_ARGS_ADR[CHF$L_MCH_FRAME];
;16100  1476		DECR I FROM ..ENB_ARGS_ADR[INCR_DEPTH_ADR] TO 1 DO
;16200  1477		    EST_FP = .EST_FP[SF$L_SAVE_FP];
;16300  1478	
;16400  1479		SIG_ARGS_ADR[FOR$L_SIG_UPC] = .EST_FP[SF$L_SAVE_PC];
;16500  1480	

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 4-3
;
;16600  1481		!+
;16700  1482		! Print error being SIGNALed, if debugging \\\\\
;16800  1483		!-
;16900  1484	
;17000  1485		PRINT_DEC (FOR$$ERR_ENDHND,
;17100P 1486		    ' RUN-TIME LIBRARY version = V0.', LIB$K_VERSION,
;17200P 1487		    ' FORTRAN error # = ', .BLOCK[SIG_ARGS_ADR[FOR$L_SIG_NAME], STS$V_CODE; , BYTE],
;17300P 1488		    ' for unit = ', .SIG_ARGS_ADR[FOR$L_SIG_LUN]);
;17400  1489	
;17500  1490	!	!+
;17600  1491	!	! \\\ If string descriptor for resultant name string is present,
;17700  1492	!	! print the string. \\\
;17800  1493	!	!-
;17900  1494	!
;18000  1495	!	IF .SIG_ARGS_ADR[FOR$A_SIG_RNS] NEQA 0
;18100  1496	!	THEN
;18200  1497	!	    LIB$PUT_OUTPUT (.SIG_ARGS_ADR[FOR$A_SIG_RNS]);
;18300  1498	
;18400  1499		PRINT_HEX (FOR$$ERR_ENDHND,
;18500P 1500		    ' user PC = ', .SIG_ARGS_ADR[FOR$L_SIG_UPC],
;18600P 1501		    ' RMS {FAB,RAB}$L_STS = ', .SIG_ARGS_ADR[FOR$L_SIG_STS],
;18700P 1502		    ' RMS {FAB,RAB}$L_STV = ', .SIG_ARGS_ADR[FOR$L_SIG_STV]);
;18800  1503		END;			! End of FORTRAN specific error signaling
;18900  1504	
;19000  1505	    RETURN SS$_RESIGNAL
;19100  1506	    END;			!End of FOR$$ERR_ENDHND





					 003C 00061 	    .ENTRY  FOR$$ERR_ENDHND, Save R2,R3,R4,R5			      ; 1316
		         55 00000000G  00  9E 00063 	    MOVAB   FOR$$SIG_FATINT, R5					      ;
		         54 00000000G  00  9E 0006A 	    MOVAB   SYS$UNWIND, R4					      ;
		         5E 	       08  C2 00071 	    SUBL2   #8, SP						      ;
		         53 	  04   AC  D0 00074 	    MOVL    SIG_ARGS_ADR, R3					      ; 1413
      04   A3	         19 	       03  ED 00078 	    CMPZV   #3, #25, 4(R3), #292				      ;
			    00000124   8F     0007D									      ;
				       0E  12 00082 	    BNEQ    1$							      ;
		         50 	  0C   AC  D0 00084 	    MOVL    ENB_ARGS_ADR, R0					      ; 1416
				  04   B0  DD 00088 	    PUSHL   @4(R0)						      ;
		  0000V  CF	       01  FB 0008B 	    CALLS   #1, CLEANUP_LUB					      ;
				       58  11 00090 	    BRB     3$							      ; 1417
      06   A3	         0C 	       00  ED 00092 1$:     CMPZV   #0, #12, 6(R3), #24					      ; 1427
				       18     00097									      ;
				       72  12 00098 	    BNEQ    8$							      ;
		         52 	  0C   AC  D0 0009A 	    MOVL    ENB_ARGS_ADR, R2					      ; 1438
				  0C   B2  D5 0009E 	    TSTL    @12(R2)						      ;
				       28  13 000A1 	    BEQL    2$							      ;
	      00000000G  8F	  04   A3  D1 000A3 	    CMPL    4(R3), #FOR$_ENDDURREA				      ;
				       1E  12 000AB 	    BNEQ    2$							      ;
		         50 	  08   AC  D0 000AD 	    MOVL    MCH_ARGS_ADR, R0					      ; 1442
	   50 	    08   A0	  10   B2  C1 000B1 	    ADDL3   @16(R2), 8(R0), R0					      ;
		    04   AE	  01   A0  9E 000B7 	    MOVAB   1(R0), T						      ;
				  0C   B2  DD 000BC 	    PUSHL   @12(R2)						      ; 1443

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 4-4
;
				  08   AE  9F 000BF 	    PUSHAB  T							      ;
		         64 	       02  FB 000C2 	    CALLS   #2, SYS$UNWIND					      ;
		         22 	       50  E8 000C5 	    BLBS    R0, 3$						      ;
		         65 	       00  FB 000C8 	    CALLS   #0, FOR$$SIG_FATINT					      ; 1447
				  08   B2  D5 000CB 2$:     TSTL    @8(R2)						      ; 1455
				       21  13 000CE 	    BEQL    5$							      ;
		         50 	  08   AC  D0 000D0 	    MOVL    MCH_ARGS_ADR, R0					      ; 1459
	   50 	    08   A0	  10   B2  C1 000D4 	    ADDL3   @16(R2), 8(R0), R0					      ;
		         6E 	  01   A0  9E 000DA 	    MOVAB   1(R0), T						      ;
				  08   B2  DD 000DE 	    PUSHL   @8(R2)						      ; 1460
				  04   AE  9F 000E1 	    PUSHAB  T							      ;
		         64 	       02  FB 000E4 	    CALLS   #2, SYS$UNWIND					      ;
		         04 	       50  E9 000E7 	    BLBC    R0, 4$						      ;
		         50 	       01  D0 000EA 3$:     MOVL    #1, R0						      ; 1462
					   04 000ED 	    RET     							      ;
		         65 	       00  FB 000EE 4$:     CALLS   #0, FOR$$SIG_FATINT					      ; 1464
		         50 	  08   AC  D0 000F1 5$:     MOVL    MCH_ARGS_ADR, R0					      ; 1475
		         50 	  04   A0  D0 000F5 	    MOVL    4(R0), EST_FP					      ;
	   51 	    10   B2	       01  C1 000F9 	    ADDL3   #1, @16(R2), I					      ; 1476
				       04  11 000FE 	    BRB     7$							      ;
		         50 	  0C   A0  D0 00100 6$:     MOVL    12(EST_FP), EST_FP					      ; 1477
		         F9 	       51  F5 00104 7$:     SOBGTR  I, 6$						      ; 1476
		    14   A3	  10   A0  D0 00107 	    MOVL    16(EST_FP), 20(R3)					      ; 1479
		         50 	0918   8F  3C 0010C 8$:     MOVZWL  #2328, R0						      ; 1505
					   04 00111 	    RET     							      ; 1316

; Routine Size:  177 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 5
;
;00100  1507	ROUTINE CLEANUP_LUB (
;00200  1508	    ACTION)
;00300  1509	    :NOVALUE =
;00400  1510	
;00500  1511	!++
;00600  1512	! FUNCTIONAL DESCRIPTION:
;00700  1513	!
;00800  1514	!	Perform the UNWIND action indicated by ACTION on the current LUB.
;00900  1515	!
;01000  1516	! FORMAL PARAMETERS:
;01100  1517	!
;01200  1518	!	ACTION.rlu.v		FOR$K_UNWINDNOP, FOR$K_UNWINDPOP, or FOR$K_UNWINDRET.
;01300  1519	!
;01400  1520	!--
;01500  1521	
;01600  1522	
;01700  1523	    BEGIN
;01800  1524	
;01900  1525	    GLOBAL REGISTER
;02000  1526		CCB = 11: REF BLOCK[, BYTE];
;02100  1527	
;02200  1528	    CASE .ACTION FROM FOR$K_UNWINDPOP TO FOR$K_UNWINDRET OF
;02300  1529		SET
;02400  1530	
;02500  1531		!+
;02600  1532		! If the UNWIND action is to pop the LUB/ISB/RAB, call CB_POP to do
;02700  1533		! the work.
;02800  1534		!-
;02900  1535	
;03000  1536	    [FOR$K_UNWINDPOP]:
;03100  1537		BEGIN
;03200  1538		FOR$$CB_GET ();		! CCB set to adr. of current /LUB/ISB/RAB
;03300  1539		FOR$$CB_POP ();
;03400  1540		END;
;03500  1541	
;03600  1542		!+
;03700  1543		! If the UNWIND action is NOP, do nothing.
;03800  1544		!-
;03900  1545	
;04000  1546	    [FOR$K_UNWINDNOP]:
;04100  1547		;
;04200  1548	
;04300  1549		!+
;04400  1550		! If the UNWIND action is RET, then try to $CLOSE the file associated
;04500  1551		! with this LUB/ISB/RAB.  Deallocate any dynamic storage associated
;04600  1552		! with this LUB.  Return the LUB/ISB/RAB to free storage.
;04700  1553	
;04800  1554	    [FOR$K_UNWINDRET]:
;04900  1555		BEGIN
;05000  1556	
;05100  1557		FOR$$CB_GET ();		! Set CCB to adr. of current LUB/ISB/RAB
;05200  1558	
;05300  1559		!+
;05400  1560		! See if file is RMS opened.
;05500  1561		!-

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 5-1
;
;05600  1562	
;05700  1563		IF .CCB[LUB$W_IFI] NEQ 0
;05800  1564		THEN
;05900  1565		    BEGIN
;06000  1566		    LOCAL
;06100  1567			FAB_BLOCK: BLOCK[FAB$C_BLN, BYTE];
;06200  1568	
;06300  1569		    CH$FILL (0, FAB$C_BLN, FAB_BLOCK);
;06400  1570		    FAB_BLOCK[FAB$B_BID] = FAB$C_BID;
;06500  1571		    FAB_BLOCK[FAB$B_BLN] = FAB$C_BLN;
;06600  1572		    FAB_BLOCK[FAB$W_IFI] = .CCB[LUB$W_IFI];
;06700  1573		    $CLOSE (FAB = FAB_BLOCK);
;06800  1574		    END;
;06900  1575	
;07000  1576		!+
;07100  1577		! Deallocate dynamic storage (record buffer, name string) for the file.
;07200  1578		! SIGNAL_STOP OTS$_FATINTERR (FATAL INTERNAL ERROR IN RUN-TIM LIBRARY) if error.
;07300  1579		!-
;07400  1580	
;07500  1581		IF .CCB[LUB$A_RBUF_ADR] NEQA 0
;07600  1582		THEN
;07700  1583		    FOR$$FREE_VM (.CCB[LUB$W_RBUF_SIZE], .CCB[LUB$A_RBUF_ADR]);
;07800  1584	
;07900  1585		IF .CCB[LUB$V_VIRT_RSN]
;08000  1586		THEN
;08100  1587		    FOR$$FREE_VM (.CCB[LUB$B_RSL], .CCB[LUB$A_RSN]);
;08200  1588	
;08300  1589		!+
;08400  1590		! Free the LUN!
;08500  1591		!-
;08600  1592	
;08700  1593		FOR$$CB_RET ();
;08800  1594		END;
;08900  1595	
;09000  1596		TES;
;09100  1597	    END;



							    .EXTRN  SYS$CLOSE

					 08FC 00112 CLEANUP_LUB:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R11				      ; 1507
		         57 00000000G  00  9E 00114 	    MOVAB   FOR$$CB_GET, R7					      ;
		         56 00000000G  00  9E 0011B 	    MOVAB   FOR$$FREE_VM, R6					      ;
		         5E 	  B0   AE  9E 00122 	    MOVAB   -80(SP), SP						      ;
	   02 	         00 	  04   AC  CF 00126 	    CASEL   ACTION, #0, #2					      ; 1528
	 000F 	       0054 	     0006     0012B 1$:     .WORD   2$-1$,-						      ;
								    7$-1$,-						      ;
								    3$-1$						      ;
				       67  16 00131 2$:     JSB     FOR$$CB_GET						      ; 1538
			    00000000G  00  16 00133 	    JSB     FOR$$CB_POP						      ; 1539
					   04 00139 	    RET     							      ; 1528
				       67  16 0013A 3$:     JSB     FOR$$CB_GET						      ; 1557
				  D8   AB  B5 0013C 	    TSTW    -40(CCB)						      ; 1563

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00	DBB3:[RTL.SRC]FERROR.B32;10					Page 5-2
;
				       1B  13 0013F 	    BEQL    4$							      ;
	   00 	         6E 	       00  2C 00141 	    MOVC5   #0, (SP), #0, #80, FAB_BLOCK			      ; 1569
		         6E 	0050   8F     00145									      ;
		         6E 	5003   8F  B0 00149 	    MOVW    #20483, FAB_BLOCK					      ; 1570
		    02   AE	  D8   AB  B0 0014E 	    MOVW    -40(CCB), FAB_BLOCK+2				      ; 1572
				       5E  DD 00153 	    PUSHL   SP							      ; 1573
	      00000000G  9F	       01  FB 00155 	    CALLS   #1, @#SYS$CLOSE					      ;
				  EC   AB  D5 0015C 4$:     TSTL    -20(CCB)						      ; 1581
				       0A  13 0015F 	    BEQL    5$							      ;
				  EC   AB  DD 00161 	    PUSHL   -20(CCB)						      ; 1583
		         7E 	  DA   AB  3C 00164 	    MOVZWL  -38(CCB), -(SP)					      ;
		         66 	       02  FB 00168 	    CALLS   #2, FOR$$FREE_VM					      ;
		         0A 	  FE   AB  E9 0016B 5$:     BLBC    -2(CCB), 6$						      ; 1585
				  F8   AB  DD 0016F 	    PUSHL   -8(CCB)						      ; 1587
		         7E 	  F7   AB  9A 00172 	    MOVZBL  -9(CCB), -(SP)					      ;
		         66 	       02  FB 00176 	    CALLS   #2, FOR$$FREE_VM					      ;
			    00000000G  00  16 00179 6$:     JSB     FOR$$CB_RET						      ; 1593
					   04 0017F 7$:     RET     							      ; 1507

; Routine Size:  110 bytes


;09200  1598	
;09300  1599	END				!End of module
;09400  1600	ELUDOM






;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  FOR$CODE       	   384  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]STARLET.L32;1		      2688        18         0       121





; Size:		384 code + 0 data bytes
; Run Time:	00:14.8
; Elapsed Time:	00:42.8
; Memory Used:	192 pages

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:16:00									Page 5-3
;
; Compilation Complete
