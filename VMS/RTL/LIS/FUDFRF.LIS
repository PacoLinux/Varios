
; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 1
;
;00100  0001	MODULE FOR$$UDF_RF (	! FORTRAN Read Formatted UDF
;00200  0002		IDENT = '01-14'	! File: FUDFRF.B32
;00300  0003		) =
;00400  0004	BEGIN
;00500  0005	
;00600  0006	!
;00700  0007	! COPYRIGHT (C) 1977
;00800  0008	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS 01754
;00900  0009	!
;01000  0010	! THIS SOFTWARE IS FURNISHED  UNDER A LICENSE FOR USE ONLY ON A SINGLE
;01100  0011	! COMPUTER  SYSTEM AND  MAY BE  COPIED ONLY WITH  THE INCLUSION OF THE
;01200  0012	! ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
;01300  0013	! MAY NOT BE PROVIDED OR  OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
;01400  0014	! EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
;01500  0015	! TERMS.  TITLE TO AND  OWNERSHIP OF THE  SOFTWARE  SHALL AT ALL TIMES
;01600  0016	! REMAIN IN DEC.
;01700  0017	!
;01800  0018	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
;01900  0019	! AND SHOULD  NOT BE CONSTRUED  AS A COMMITMENT  BY DIGITAL  EQUIPMENT
;02000  0020	! CORPORATION.
;02100  0021	!
;02200  0022	! DEC ASSUMES  NO  RESPONSIBILITY  FOR  THE USE OR  RELIABILITY OF ITS
;02300  0023	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;02400  0024	
;02500  0025	!++
;02600  0026	! FACILITY:  FORTRAN Support Library - not user callable
;02700  0027	!
;02800  0028	! ABSTRACT:
;02900  0029	!
;03000  0030	!	This module implements FORTRAN Read Formatted I/O
;03100  0031	!	statements (sequential access - S, direct access - D,
;03200  0032	!	DECODE - M) at the User data Formatter level of
;03300  0033	!	abstraction (UDF level is 2nd level). This module
;03400  0034	!	calls the Read/write independent format
;03500  0035	!	interpreter (FOR$INTERP) to decode the compiled format
;03600  0036	!	statement. This module calls the appropriate read record
;03700  0037	!	routine at the record handling level of abstraction (REC
;03800  0038	!	level is 3rd level) to read a record.
;03900  0039	!
;04000  0040	! ENVIRONMENT:  User access mode; reentrant AST level or not.
;04100  0041	!
;04200  0042	! AUTHOR:  Thomas N. Hastings;	 CREATION DATE: 20-Feb-77
;04300  0043	!
;04400  0044	! MODIFIED BY:
;04500  0045	!	Donald G. Petersen, 11-Jan-78: Version 1-1
;04600  0046	! 0-1	-  original
;04700  0047	! 0-6	- internal F4P review - reduced use of CH$ by introducing MAXP, LSSP macros,
;04800  0048	!	reduced size of SELECT, added debuging macros, and MAP ELEM_ADR: REF VECTOR.
;04900  0049	! 0-16	- use SRMDEF for string descriptor symbols
;05000  0050	! 0-17	- use SRMDEF symbols for FORTRAN data types
;05100  0051	! 0-18	- edited FUDFWF version 17 to make FUDFRF verson 18
;05200  0052	! 0-29	- Removed parameters to record level routines JMT 17-OCT-77
;05300  0053	! 0-30	- Fixed L format conversion bug JMT 18-OCT-77
;05400  0054	! 0-31	- Check for direct access when EOF, SLS.  JMT 22-Oct-77
;05500  0055	! 0-32	- Use FOR$K_abcmnoxyz as EXTERNAL LITERALs.  TNH 27-Oct-77

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 1-1
;
;05600  0056	! 0-33	- Catch strings passed as floating.  TNH 28-Oct-77
;05700  0057	! 0-34	- Fix nHcccc bug (now blank pads strings).  JMT 16-Nov-77
;05800  0058	! 0-35	- Use FERR.  TNH 16-Dec-77
;05900  0059	! 0-36	- If T format goes too far, just set to end of record.  JMT 10-Jan-78
;06000  0060	! 1-01	 - New version using action tables instead of CASE and SELECT,
;06100  0061	!		   DGP 11-Jan-78
;06200  0062	! 1-02	- Fix Q format (ECO).  Store truncated bits if non-integer.  JMT 18-Jan-78
;06300  0063	! 1-03	- Change order of parameters in call to CNV_IN_DEFG to conform
;06400  0064	!	  to standard.  JMT 15-Feb-78
;06500  0065	! 1-04	- Global register CCB.  JMT 9-Apr-78
;06600  0066	! 1-05	- Change to STARLET library.  DGP 20-Apr-78
;06700  0067	! 1-06	- Change REQUIRE files for VAX system build.  DGP 28-Apr-78
;06800  0068	! 1-07	- Change STARLET to RTLSTARLE to avoid conflicts.  DGP 1-May-78
;06900  0069	! 01-08	- Use JSB linkage.  TNH 22-May-78
;07000  0070	! 01-09	- Call DO_READ if at end-of-list and end-of-format.  TNH 31-May-78
;07100  0071	! 01-11	- Only look at 7-bits of format code.  TNH 6-June-78
;07200  0072	! 01-12	- PIC dispatch tables.  TNH 6-June-78
;07300  0073	! 01-13	- Use ADR_VECTOR macro for PIC vector.  TNH 7-June-78
;07400  0074	! 01-14	- Make no element statement work with lookahead.  TNH 16-Aug-78
;07500  0075	!--

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 2
;
;00100  0076	!
;00200  0077	! LINKAGES:
;00300  0078	!
;00400  0079	REQUIRE 'RTLIN:FLNK';		! define all linkages
; %PRINT:	File: FLNK.B32; Version 1, edit 12, TNH 2-Aug-78
;00500  0301	
;00600  0302	!
;00700  0303	! TABLE OF CONTENTS:
;00800  0304	!
;00900  0305	
;01000  0306	FORWARD ROUTINE
;01100  0307		FOR$$UDF_RF0: JSB_UDF0 NOVALUE,	! initialization
;01200  0308		FOR$$UDF_RF1: CALL_CCB NOVALUE,	! format one user I/O list element
;01300  0309		FOR$$UDF_RF9: JSB_UDF9 NOVALUE,	! end of user I/O list - finish
;01400  0310		DO_READ: JSB_DO_READ NOVALUE;	! do per-record formatting and read
;01500  0311	
;01600  0312	!
;01700  0313	! INCLUDE FILES:
;01800  0314	!
;01900  0315		REQUIRE 'RTLML:FERR';		! FORTRAN error number definitions
; %PRINT:	Filename: FERR.MDL! Version 0, edit 36, TNH 19-June-78
;02000  0433		REQUIRE 'RTLIN:FFMT';		! Format statement codes
; %PRINT:	Filename: FFMT.B32 ; Version 1, edit 11, TNH,  6-June-78
;02100  0533		REQUIRE 'RTLML:FISB';		! I/O statement block (ISB) offsets 
; %PRINT:	File: FISB.MDL which produces FISB.B32! Version 1, EDIT 16, DGP 02-Jun-78
;02200  0742		REQUIRE 'RTLML:FLUB';		! Only needed to get LUB length!
; %PRINT:	File: FLUB.MDL which produces FLUB.B32! Version 0, edit 30, TNH, 17-June-78
;02300  0910		REQUIRE 'RTLIN:FMAC';		! Macros
; %PRINT:	Filename: FMAC.B32; Version 1, edit 29, TNH, 7-JUN-78
; %PRINT:	 REQUIRE FILE: LPSECT.B32, VERSION 01-5, TNH, 27-Jun-78
;02400  1090					! type codes
;02500  1091		REQUIRE 'RTLIN:ODBG';		! OTS debugging macros
; %PRINT:	Filename: NODBG.B32; Version 0, edit 20, JMT, 17-Jan-78
;02600  1167		LIBRARY	'RTLSTARLE';	! STARLET library for macros and symbols
;02700  1168	
;02800  1169	!
;02900  1170	! MACROS:
;03000  1171	!
;03100  1172	!	CH_WRITE_A (CS_POINTER_ADR.ma.r) = character;  ! Write character
;03200  1173	!				! in string to memory, then advance pointer
;03300  1174	
;03400  1175	
;03500  1176	    MACRO
;03600  1177		RF_EOLST = 0,7,1,0%,	! Check for end of user I/O list
;03700  1178		RF_CHECKW = 0,6,1,0%,	! Check for w positions left
;03800  1179		RF_SHORT = 0,5,1,0%,	! Check for short string
;03900  1180		!	    0,4,1,0%	  spare
;04000  1181		RF_DISPAT = 0,0,4,0%;	! CASE index for dispatch
;04100  1182		
;04200  1183	    MACRO		! Attribute packing macro for attribute table
;04300  1184		A(E, W, S, NDX) = (E^7 + W^6 + S^5 + NDX)%;
;04400  1185	
;04500  1186	!
;04600  1187	! EQUATED SYMBOLS:
;04700  1188	!

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 2-1
;
;04800  1189	
;04900  1190	
;05000  1191	!
;05100  1192	! PSECT DECLARATIONS:
;05200  1193	!
;05300  1194	
;05400  1195		DECLARE_PSECTS (FOR);	! declare PSECTs for FOR$ facility
;05500  1196	
;05600  1197	!
;05700  1198	! OWN STORAGE:
;05800  1199	!
;05900  1200	    BIND
;06000  1201		RF_ACT =	! Action table for UDF_RF1, UDF_RF9 format codes
;06100  1202	
;06200  1203	!+
;06300  1204	! The format codes are structured as follows:
;06400  1205	! 0 - do nothing
;06500  1206	! 1 - call intermediate record processing routine
;06600  1207	! 2 - do nothing
;06700  1208	! 3 - check for tab past end of buffer
;06800  1209	! 4 - do nothing
;06900  1210	! 5 - copy Hollerith
;07000  1211	! 6 - return no. of character positions remaining
;07100  1212	! 7 - copy alpha strings
;07200  1213	! 8 - all integer format processing
;07300  1214	! 9 - all floating format
;07400  1215	!-
;07500  1216	
;07600  1217	UPLIT BYTE(	! This table is identical to the WF1 action table
;07700  1218	
;07800  1219	!	  E C S	  EOLST - End of I/O list
;07900  1220	!	  O H H	  CHECKW - Set up descriptor; check field width
;08000  1221	!	  L E O	  SHORT - Check for short input field
;08100  1222	!	  S C R
;08200  1223	!	  T K T
;08300  1224	!	    W		 dec	 hex
;08400  1225		A(0,0,0, 0),	! ER	= 0,	! 00	! format syntax error
;08500  1226		A(0,0,0, 0),	! LP	= 1,	! 01	! ( - format reversion point
;08600  1227		A(0,0,0, 0),	! NLP	= 2,	! 02	! n( - left paran of repeat group
;08700  1228		A(0,0,0, 0),	! )	= 3,	! 03	! ) - right paren of repeat group
;08800  1229					! MAINTENANCE NOTE: the above should not be seen by this module,
;08900  1230					! except look ahead in FOR$$UDF_RF9
;09000  1231		A(1,0,0, 1),	! EOF	= 4,	! 04	! ) - End of format
;09100  1232		A(0,0,0, 1),	! SLS	= 5,	! 05	! / - Record separator
;09200  1233		A(0,0,0, 2),	! DLR	= 6,	! 06	! $ - Dollar sign: terminal I/O
;09300  1234		A(1,0,0, 0),	! CLN	= 7,	! 07	! : - Colon: terminate if end of list
;09400  1235		0,0,0,0,	! UNUSED  8:11
;09500  1236		A(0,0,0, 0),	! _P	= 12,	! 0C	! sP - signed scale factor
;09600  1237		A(0,0,0, 3),	! _T	= 13,	! 0D	! Tn - Tab Set
;09700  1238		A(0,1,0, 4),	! _X	= 14,	! 0E	! nX - Skip n columns
;09800  1239		A(0,1,0, 5),	! _H	= 15,	! 0F	! nHcccc - Hollerith
;09900  1240		0,0,0,0,	! UNUSED  16:19
;10000  1241		A(1,0,0, 6),	! _Q	= 20,	! 14	! Q
;10100  1242		A(1,1,0, 7),	! _A	= 21,	! 15	! nAw - Alpha numeric
;10200  1243		A(1,1,1, 8),	! _L	= 22,	! 16	! nLw - Logical

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 2-2
;
;10300  1244		A(1,1,1, 8),	! _O	= 23,	! 17	! nOw - Octal
;10400  1245		A(1,1,1, 8),	! _I	= 24,	! 18	! nIw - Integer
;10500  1246		A(1,1,1, 8),	! _Z	= 25,	! 19	! nZw - Hexadecimal
;10600  1247		0,0,0,0,	! UNUSED  26:29
;10700  1248		A(1,1,1, 9),	! _F	= 30,	! 1E	! nFw.d - Fixed format
;10800  1249		A(1,1,1, 9),	! _E	= 31,	! 1F	! nEw.d - Scientific notation format
;10900  1250		A(1,1,1, 9),	! _G	= 32,	! 20	! nGw.d - General format
;11000  1251		A(1,1,1, 9)	! _D	= 33,	! 21	! nDw.d - Double Precision format
;11100  1252	    ): VECTOR[30,BYTE];
;11200  1253	!
;11300  1254	! EXTERNAL REFERENCES:
;11400  1255	!
;11500  1256	
;11600  1257	EXTERNAL 
;11700  1258		FOR$$AA_REC_PR0: ADR_VECTOR,	! PIC array of record processor
;11800  1259						! procedure-initializations in REC
;11900  1260						! level of abstraction. Indexed by
;12000  1261						! I/O statement type (ISB$B_STTM_TYPE)
;12100  1262		FOR$$AA_REC_PR1: ADR_VECTOR,	! PIC array of record processor procedures
;12200  1263						! Read a record in REC level of
;12300  1264						! abstraction. Indexed by I/O statement
;12400  1265						! type (ISB$B_STTM_TYPE)
;12500  1266		FOR$$AA_REC_PR9: ADR_VECTOR;	! PIC array of record processor procedures
;12600  1267						! Read last record in REC level of
;12700  1268						! abstraction. Indexed by I/O
;12800  1269						! statement type (ISB$B_STTM_TYPE)
;12900  1270	
;13000  1271	EXTERNAL ROUTINE
;13100  1272		FOR$CNV_IN_DEFG,		! FORTRAN D,E,F,G input conversion
;13200  1273		FOR$CNV_IN_L,			! FORTRAN L input conversion
;13300  1274		FOR$CNV_IN_O,			! FORTRAN O input conversion
;13400  1275		FOR$CNV_IN_I,			! FORTRAN I input conversion
;13500  1276		FOR$CNV_IN_Z,			! FORTRAN Z input conversion
;13600  1277		FOR$$FMT_INTRP0: JSB_FMT0 NOVALUE,! initialize format interpreter
;13700  1278		FOR$$FMT_INTRP1: CALL_CCB,	! get next data format code
;13800  1279						! or input-output format code
;13900  1280		FOR$$SIGNAL_STO: NOVALUE,	! convert FORTRAN err # to
;14000  1281						! VAX error # and SIGNAL_STOP
;14100  1282		LIB$CVTDF: ADDRESSING_MODE (GENERAL); ! convert Double to Floating
;14200  1283						! return status if FALSE if overflow
;14300  1284	
;14400  1285	    !+
;14500  1286	    ! Define PIC input conversion dispatch tables (to shorten code).
;14600  1287	    ! Use OWN rather than PSECT, because BLISS won't allow reference
;14700  1288	    ! in BIND table = UPLIT (... - table) to symbol being defined.
;14800  1289	    !-
;14900  1290	
;15000  1291	    DISPATCH_PSECTS (FOR);		! Declare OWN PSECTs to be in code PSECTs.
;15100  1292						! so can use short offsets to reach.
;15200  1293	
;15300  1294	    OWN AA_IN_FIX: VECTOR [4, WORD, SIGNED] INITIAL (WORD (
;15400  1295		FOR$CNV_IN_L - AA_IN_FIX,	! L input conversion
;15500  1296		FOR$CNV_IN_O - AA_IN_FIX,	! O input conversion
;15600  1297		FOR$CNV_IN_I - AA_IN_FIX,	! I input conversion
;15700  1298		FOR$CNV_IN_Z - AA_IN_FIX));	! Z input conversion

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 2-3
;
;15800  1299	
;15900  1300	    DECLARE_PSECTS (FOR);		! change PSECTs back to way they were.
;16000  1301	

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 3
;
;00100  1302	GLOBAL ROUTINE FOR$$UDF_RF0 (	! Read formatted UDF initialization
;00200  1303		FORMAT_ADR)		! Adr. of compiled format byte array
;00300  1304		: JSB_UDF0 NOVALUE =
;00400  1305	
;00500  1306	!++
;00600  1307	! FUNCTIONAL DESCRIPTION:
;00700  1308	!
;00800  1309	! Initialize read Formatted User data formatter (UDF)
;00900  1310	!
;01000  1311	! CALLING SEQUENCE:
;01100  1312	!
;01200  1313	!	JSB FOR$$UDF_RF0 (R2=FORMAT_ADR.rbu.ra)
;01300  1314	!
;01400  1315	! FORMAL PARAMETERS:
;01500  1316	!
;01600  1317	!	FORMAT_ADR.rbu.ra	Adr. of compiled format byte array
;01700  1318	!
;01800  1319	! IMPLICIT INPUTS:
;01900  1320	!
;02000  1321	!	CCB			Pointer to current logical unit block
;02100  1322	!
;02200  1323	!	ISB$B_STTM_TYPE		I/O statement type code - set by
;02300  1324	!				each I/O statement initialization
;02400  1325	!
;02500  1326	! IMPLICIT OUTPUTS:
;02600  1327	!
;02700  1328	!	ISB$A_BUF_BEG		Adr. of first byte of input data buffer
;02800  1329	!	ISB$A_BUF_PTR		Adr. of next byte of input
;02900  1330	!				data buffer
;03000  1331	!	ISB$A_BUF_HIGH		Adr. of high water byte in input buffer on this
;03100  1332	!				I/O statement
;03200  1333	!	ISB$A_BUF_END		Adr. +1 of last char position allocated
;03300  1334	!				to input buffer
;03400  1335	!
;03500  1336	! ROUTINE VALUE:
;03600  1337	! COMPLETION CODES:
;03700  1338	!
;03800  1339	!	NONE
;03900  1340	!
;04000  1341	! SIDE EFFECTS:
;04100  1342	!
;04200  1343	!	NONE
;04300  1344	!
;04400  1345	!--
;04500  1346	
;04600  1347	
;04700  1348	    BEGIN
;04800  1349	
;04900  1350	    EXTERNAL REGISTER
;05000  1351		CCB: REF BLOCK[, BYTE];
;05100  1352	
;05200  1353	    !+
;05300  1354	    ! Print input formals and implicit inputs if debugging
;05400  1355	    !-
;05500  1356	

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 3-1
;
;05600  1357	    INPUT_FORMALS (FOR$$UDF_RF0, '.FORMAT_ADR', .FORMAT_ADR);
;05700  1358	    IMPLICIT_INPUTS (FOR$$UDF_RF0, 'OTS$$A_CUR_LUB', .OTS$$A_CUR_LUB, '.CCB[ISB$B_STTM_TYPE]', .CCB[ISB$B_STTM_TYPE]
;05800  1359	
;05900  1360	    !+
;06000  1361	    ! Initialize Record processing level of abstraction.
;06100  1362	    ! Set pointer to current (ISB$A_BUF_PTR)  and last+1
;06200  1363	    ! (ISB$A_BUF_END) character position for user data in
;06300  1364	    ! input buffer
;06400  1365	    !-
;06500  1366	
;06600  1367	    JSB_REC0 (FOR$$AA_REC_PR0 + .FOR$$AA_REC_PR0[.CCB[ISB$B_STTM_TYPE]]);
;06700  1368	
;06800  1369	    !+
;06900  1370	    ! Initialize character pointer to first position for user
;07000  1371	    ! data in input buffer - needed only for T AND $ formats
;07100  1372	    !-
;07200  1373	
;07300  1374	    CCB[ISB$A_BUF_BEG] = .CCB[ISB$A_BUF_PTR];
;07400  1375	
;07500  1376	    !+
;07600  1377	    ! Initialize Format interpreter
;07700  1378	    !-
;07800  1379	
;07900  1380	    FOR$$FMT_INTRP0 (.FORMAT_ADR);
;08000  1381	
;08100  1382	    !+
;08200  1383	    ! Initialize character pointer to highest position written in
;08300  1384	    ! user data buffer for this record.  T format may position to 
;08400  1385	    ! the left.
;08500  1386	    !-
;08600  1387	
;08700  1388	    CCB[ISB$A_BUF_HIGH] = .CCB[ISB$A_BUF_PTR];
;08800  1389	
;08900  1390	    !+
;09000  1391	    ! All other ISB locations and flags have already been 
;09100  1392	    ! initialized to 0 or a specified value by the I/O statement
;09200  1393	    ! initialization for this I/O statement.
;09300  1394	    !-
;09400  1395	
;09500  1396	    !+
;09600  1397	    ! Print function value, output formals, and implicit outputs, if debugging
;09700  1398	    !-
;09800  1399	
;09900  1400	    FUNCTION_VALUE (FOR$$UDF_RF0);
;10000  1401	    OUTPUT_FORMALS (FOR$$UDF_RF0);
;10100  1402	    IMPLICIT_OUTPUT  (FOR$$UDF_RF0, '.CCB[ISB$A_BUF_BEG]', .CCB[ISB$A_BUF_BEG],
;10200P 1403		'.CCB[ISB$A_BUF_PTR]', .CCB[ISB$A_BUF_PTR], '.CCB[ISB$A_BUF_HIGH]', .CCB[ISB$A_BUF_HIGH],
;10300P 1404		'.CCB[ISB$A_BUF_END]', .CCB[ISB$A_BUF_END]);
;10400  1405	    RETURN;
;10500  1406	    END;		! End of FOR$$UDF_RF0 routine


							    .TITLE  FOR$$UDF_RF
							    .IDENT  \01-14\


; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 3-2
;
							    .PSECT  FOR$CODE,NOWRT,  SHR,  PIC,2

  00  00  00  80  02  01  81  00  00  00  00  00000 P.AAA:  .BYTE   0, 0, 0, 0, -127, 1, 2, -128, 0, 0, 0, 0, 0, 3, 68, 69, - ;
  C7  86  00  00  00  00  45  44  03  00  00  0000B		    0, 0, 0, 0, -122, -57, -24, -24, -24, -24, 0, 0, 0, 0, -  ;
  E9  E9  E9  00  00  00  00  E8  E8  E8  E8  00016		    -23, -23, -23, -23					      ;
					  E9  00021									      ;
					      00022	    .BLKB   2
		      0000* 0000* 0000* 0000* 00024 AA_IN_FIX:
							    .WORD   <FOR$CNV_IN_L-AA_IN_FIX>, <FOR$CNV_IN_O-AA_IN_FIX>, -     ;
								    <FOR$CNV_IN_I-AA_IN_FIX>, <FOR$CNV_IN_Z-AA_IN_FIX>	      ;

						    RF_ACT=		P.AAA
							    .EXTRN  FOR$$AA_REC_PR0, FOR$$AA_REC_PR1, FOR$$AA_REC_PR9
							    .EXTRN  FOR$CNV_IN_DEFG, FOR$CNV_IN_L, FOR$CNV_IN_O, FOR$CNV_IN_I
							    .EXTRN  FOR$CNV_IN_Z, FOR$$FMT_INTRP0, FOR$$FMT_INTRP1
							    .EXTRN  FOR$$SIGNAL_STO, LIB$CVTDF

		         50 	  A5   AB  9A 0002C FOR$$UDF_RF0::
							    MOVZBL  -91(CCB), R0					      ; 1367
		         50 	0000GCF40  32 00030 	    CVTWL   FOR$$AA_REC_PR0[R0], R0				      ;
				0000GCF40  16 00036 	    JSB     FOR$$AA_REC_PR0[R0]					      ;
		    C4   AB	  B8   AB  D0 0003B 	    MOVL    -72(CCB), -60(CCB)					      ; 1374
				     0000G 30 00040 	    BSBW    FOR$$FMT_INTRP0					      ; 1380
		    C8   AB	  B8   AB  D0 00043 	    MOVL    -72(CCB), -56(CCB)					      ; 1388
					   05 00048 	    RSB     							      ; 1302

; Routine Size:  29 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 4
;
;00100  1407	GLOBAL ROUTINE FOR$$UDF_RF1 (	! Format one user input element
;00200  1408		ELEM_TYPE,		! Type code of user I/O list element
;00300  1409		ELEM_SIZE,		! No. of addressable units in element
;00400  1410		ELEM_ADR)		! Adr. of element
;00500  1411		: CALL_CCB NOVALUE =
;00600  1412	
;00700  1413	!++
;00800  1414	! FUNCTIONAL DESCRIPTION:
;00900  1415	!
;01000  1416	!	FOR$$UDF_RF1  extracts the next field (W characters fromkt
;01100  1417	!	format statement, or up to next comma in input buffer, or end of
;01200  1418	!	input buffer, whichever occurs first) from the input buffer and
;01300  1419	!	converts it according to the type specified by the format
;01400  1420	!	statement and the size specified by the data type of the user
;01500  1421	!	I/O list element.
;01600  1422	!	FOR$UDF_RF1 and the format interpreter
;01700  1423	!	(FOR$$FMT_INTRP1) interpret all format codes until the
;01800  1424	!	first I/O list element transmitting format code is
;01900  1425	!	encountered.
;02000  1426	!
;02100  1427	!	FOR$$UDF_RF1 is also called when the user I/O list
;02200  1428	!	has no more elements. This is indicated with .ELEM_SIZE=0
;02300  1429	!	FOR$$UDF_RF1 and FOR$$FMT_INTRP1 interpret all format
;02400  1430	!	codes up to the first data formatting one, :,
;02500  1431	!	or end of format.
;02600  1432	!
;02700  1433	! CALLING SEQUENCE:
;02800  1434	!
;02900  1435	!	CALL FOR$$UDF_RF1 (elem_type.rlu.v, elem_size.rlu.v, elem_adr.wx.r)
;03000  1436	!
;03100  1437	! FORMAL PARAMETERS:
;03200  1438	!
;03300  1439	!	ELEM_TYPE.rlu.v		Type code of user I/O list
;03400  1440	!				element. Form: ELEM_TYPE_x
;03500  1441	!				x = B,W,L,WU,LU,F,D,FC or T.
;03600  1442	!	ELEM_SIZE.rlu.v		Size of user I/O list element
;03700  1443	!				in addressable machine units (VAX, bytes)
;03800  1444	!				If 0, this is end of I/O list call.
;03900  1445	!	ELEM_ADR.wx.r		Adr. of user I/O list element
;04000  1446	!				x = b, w, l, wu, lu, f, d, fc or t.
;04100  1447	!
;04200  1448	! IMPLICIT INPUTS:
;04300  1449	!
;04400  1450	!	CCB			Pointer to current logical unit block
;04500  1451	!	ISB$B_STTM_TYPE		I/O statement type code - set by each
;04600  1452	!				I/O statement initialization
;04700  1453	!
;04800  1454	!	 The following ISB locations are set only by previous calls to
;04900  1455	!	 FOR$$UDF_RF{0,1}, i.e., are effectively OWN.
;05000  1456	!
;05100  1457	!	ISB$A_BUF_BEG		Pointer to first char. position in
;05200  1458	!				user data part of input buffer
;05300  1459	!	ISB$A_BUF_PTR		Pointer to next char. position
;05400  1460	!				in user data part of input buffer
;05500  1461	!	ISB$A_BUF_HIGH		Pointer to highest char. position

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 4-1
;
;05600  1462	!				written so far on any T format code
;05700  1463	!	ISB$A_BUF_END		Pointer to last+1 char. position
;05800  1464	!				in user data part of input buffer
;05900  1465	!	ISB$V_DOLLAR		Dollar sign seen in format for this
;06000  1466	!				record, if 1. Change carriage
;06100  1467	!				control SP (space) to $, + to Null (0).
;06200  1468	!	The following ISB locations are set by the format interpreter
;06300  1469	!	 (FOR$$FMT_INTRP1) which this module calls:
;06400  1470	!
;06500  1471	!	ISB$A_FMT_PTR		Pointer to next char. position
;06600  1472	!				in user data part of input buffer
;06700  1473	!				Used only in H format.
;06800  1474	!	ISB$W_FMT_W		Field width (w)
;06900  1475	!	ISB$B_FMT_D		No. of fraction digits (d)
;07000  1476	!	ISB$B_FMT_E		No. of exponent characters (e)
;07100  1477	!	ISB$B_FMT_P		Signed scale factor (p)
;07200  1478	!
;07300  1479	! IMPLICIT OUTPUTS:
;07400  1480	!
;07500  1481	!	ISB$A_FMT_PTR		Pointer to next char. position
;07600  1482	!				in compiled format character string
;07700  1483	!				Changed only for H format.
;07800  1484	!
;07900  1485	!	 The following ISB locations are set only by previous calls
;08000  1486	!	 to FOR$$UDF_RF{0,1}, i.e., are effectively OWN.
;08100  1487	!
;08200  1488	!	ISB$A_BUF_PTR		Pointer to next char. position
;08300  1489	!				in user data part of input buffer
;08400  1490	!	ISB$V_DOLLAR		Dollar sign seen in format for this
;08500  1491	!				record, if 1. Change carriage
;08600  1492	!				control SP to $, + to Null.
;08700  1493	!	ISB$B_ERR_NO		FOR$_IN_CONERR (43='INPUT CONVERSION ERROR') -
;08800  1494	!				overflowed field is filled with *'s.
;08900  1495	!				FOR$FORVARMIS (61='FORMAT/VARIABLE-TYPE MISMATCH')
;09000  1496	!
;09100  1497	! FUNCTIONAL VALUE:
;09200  1498	!
;09300  1499	!	NONE
;09400  1500	!
;09500  1501	! SIDE EFFECTS:
;09600  1502	!
;09700  1503	!	SIGNAL_STOPs FOR$_MORONEREC if try to read more than one
;09800  1504	!	record from a direct access file because of format reversion or slash.
;09900  1505	!--

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5
;
;00100  1506	    BEGIN
;00200  1507	
;00300  1508	    EXTERNAL REGISTER
;00400  1509		CCB: REF BLOCK[, BYTE];
;00500  1510	
;00600  1511	    MAP
;00700  1512		ELEM_ADR: REF VECTOR;	! element is call-by-reference
;00800  1513	    LOCAL
;00900  1514		ACT:BLOCK[1,LONG],	! Action table entry for format code
;01000  1515		BUFPTR,		! Input buffer pointer from ISB
;01100  1516		FMT_W,		! Input field width from ISB
;01200  1517		FMT_CODE,	! Compressed format code returned
;01300  1518			! from format interpreter (FOR$$FMT_INTRP)
;01400  1519		DSC: BLOCK[8, BYTE];	! Static string desciptor for
;01500  1520			! output field
;01600  1521	
;01700  1522	    !+
;01800  1523	    ! Print input formals and implicit inputs if debugging
;01900  1524	    !-
;02000  1525	
;02100  1526	    INPUT_FORMALS (FOR$$UDF_RF1, '.ELEM_TYPE', .ELEM_TYPE, '.ELEM_SIZE', .ELEM_SIZE, '.ELEM_ADR', .ELEM_ADR,
;02200P 1527		'.ELEM_ADR[0] (ref)', (IF .ELEM_ADR NEQ 0 THEN .ELEM_ADR[0] ELSE 0));
;02300  1528	    IMPLICIT_INPUTS (FOR$$UDF_RF1, '.OTS$$A_CUR_LUB', .OTS$$A_CUR_LUB,
;02400P 1529		'.CCB[ISB$B_STTM_TYPE]', .CCB[ISB$B_STTM_TYPE], '.CCB[ISB$A_BUF_BEG]', .CCB[ISB$A_BUF_BEG],
;02500P 1530		'.CCB[ISB$A_BUF_PTR]', .CCB[ISB$A_BUF_PTR],
;02600P 1531		'.CCB[ISB$A_BUF_END]', .CCB[ISB$A_BUF_END], '.CCB[ISB$V_DOLLAR]', .CCB[ISB$V_DOLLAR]);
;02700  1532	
;02800  1533	    !+
;02900  1534	    ! Perform loop beginning with a call to the format
;03000  1535	    ! interpreter and continue processing until we get
;03100  1536	    ! a format code for transmitting the user I/O list data
;03200  1537	    ! element (i.e., Q,A,L,O,Z,I,F,E,G,D) in which case perform
;03300  1538	    ! the output conversion and return to the user program.
;03400  1539	    ! For other formats which do output without reference to
;03500  1540	    ! the user I/O list, perform output formatting and continue
;03600  1541	    ! loop (i.e., EOF, /, $, :, T, X, H)
;03700  1542	    !-
;03800  1543	
;03900  1544	    WHILE 1 DO
;04000  1545	
;04100  1546		!+
;04200  1547		! Get next format code requiring output interpretation:
;04300  1548		!    1. If repeating an explicit format code, the code
;04400  1549		!       is simply obtained from the FMT_CODE field of the ISB.
;04500  1550		!
;04600  1551		!    2. In other cases it is necessary to call FOR$$FMT_INTRP1
;04700  1552		!
;04800  1553		! Dispatch on format code and select appropriate actions.
;04900  1554		!-
;05000  1555	
;05100  1556		BEGIN
;05200  1557		IF .CCB[ISB$W_FMT_REP] GTR 1 AND .CCB[ISB$B_FMT_CODE] LSSU _DA
;05300  1558		THEN
;05400  1559		    BEGIN
;05500  1560		    FMT_CODE = .CCB[ISB$B_FMT_CODE];

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-1
;
;05600  1561		    CCB[ISB$W_FMT_REP] = .CCB[ISB$W_FMT_REP] - 1;
;05700  1562		    END
;05800  1563		ELSE
;05900  1564		    FMT_CODE = FOR$$FMT_INTRP1(.ELEM_SIZE);
;06000  1565	
;06100  1566		ACT = .RF_ACT[.FMT_CODE];
;06200  1567	
;06300  1568		!+
;06400  1569		! End of I/O list check:
;06500  1570		! Bad format, End of format, :, all data format codes
;06600  1571		! (Q,A,L,O,Z,I,F,E,G,D)
;06700  1572		! If end of I/O list (.ELEM_SIZE = 0) then do per-record
;06800  1573		! formatting and write last record (PR9) of I/O
;06900  1574		! statement and EXITLOOP which returns.
;07000  1575		!-
;07100  1576	
;07200  1577		IF .ACT[RF_EOLST] AND .ELEM_SIZE EQL 0
;07300  1578		THEN
;07400  1579		    BEGIN
;07500  1580		    DO_READ (FOR$$AA_REC_PR9 + .FOR$$AA_REC_PR9[.CCB[ISB$B_STTM_TYPE]]);
;07600  1581		    EXITLOOP;
;07700  1582		    END;
;07800  1583		
;07900  1584		!+
;08000  1585		! All data generating format codes (A,L,O,Z,I
;08100  1586		! F,E,G,D, except Q plus X and H):
;08200  1587		! Setup string descriptor to field of width W. 
;08300  1588		! (ISB$W_FMT_W) and next char position
;08400  1589		! for output (ISB$A_BUF_PTR) in
;08500  1590		! output buffer. Check for field extending beyond
;08600  1591		! end of buffer and set DSC[DSC$W_LENGTH] in
;08700  1592		! string descriptor to no. of characters which remain
;08800  1593		! in input buffer if would run off the end.
;08900  1594		!-
;09000  1595	
;09100  1596		IF .ACT[RF_CHECKW]
;09200  1597		THEN
;09300  1598		    BEGIN
;09400  1599		    DSC[DSC$W_LENGTH] = .CCB[ISB$W_FMT_W];
;09500  1600		    DSC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
;09600  1601		    DSC[DSC$B_CLASS] = DSC$K_CLASS_S;
;09700  1602		    DSC[DSC$A_POINTER] = .CCB[ISB$A_BUF_PTR];
;09800  1603		    CCB[ISB$A_BUF_PTR] = CH$PLUS (.CCB[ISB$A_BUF_PTR], .CCB[ISB$W_FMT_W]);
;09900  1604		    IF .CCB[ISB$A_BUF_PTR] GTRP .CCB[ISB$A_BUF_END]
;10000  1605		    THEN
;10100  1606		        BEGIN	! Field would extend beyond end of buffer - reset
;10200  1607		        DSC[DSC$W_LENGTH] = CH$DIFF (.CCB[ISB$A_BUF_END], .DSC[DSC$A_POINTER]);
;10300  1608		        CCB[ISB$A_BUF_PTR] = .CCB[ISB$A_BUF_END];
;10400  1609		        END
;10500  1610		    END;	!End X,H,A,L,O,Z,I,F,E,G,D string descr. setup
;10600  1611	
;10700  1612		!+
;10800  1613		! Short input field check, i.e., a field terminated
;10900  1614		! by an explicit comma in the data earlier
;11000  1615		! than the width of field specified by the format statement.

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-2
;
;11100  1616		! If a short field, reduce to include up to but not including
;11200  1617		! the comma, but advance character pointer (ISB$A_BUF_PTR)
;11300  1618		! beyond the comma, so it will not be found on next element.
;11400  1619		! A zero length field is treated as a string of spaces.
;11500  1620		!-
;11600  1621		
;11700  1622		IF .ACT[RF_SHORT]
;11800  1623		THEN
;11900  1624		    BEGIN
;12000  1625		    LOCAL P;	! temporary character pointer
;12100  1626		    P = CH$FIND_CH (.DSC[DSC$W_LENGTH], .DSC[DSC$A_POINTER], %C',');
;12200  1627		    IF .P NEQ 0
;12300  1628		    THEN
;12400  1629			BEGIN
;12500  1630			DSC[DSC$W_LENGTH] = CH$DIFF (.P, .DSC[DSC$A_POINTER]);
;12600  1631			CCB[ISB$A_BUF_PTR] = CH$PLUS (.P, 1);
;12700  1632			END;
;12800  1633		    END;		! End of short field check
;12900  1634		
;13000  1635		CASE .ACT[RF_DISPAT] FROM 0 TO 9 OF
;13100  1636		    SET
;13200  1637		[0]:
;13300  1638		
;13400  1639		    !+
;13500  1640		    ! Colon:  Only get here if not end of user I/O list,
;13600  1641		    ! so keep on looking for a data transmitting format code.
;13700  1642		    !-
;13800  1643	
;13900  1644		    ;	! do nothing
;14000  1645		
;14100  1646		[1]:
;14200  1647		
;14300  1648		    !+
;14400  1649		    ! End of format or / format code seen:
;14500  1650		    ! if direct access file, SIGNAL_STOPs MORONREC, else call
;14600  1651		    ! intermediate record processing routine (PR1).
;14700  1652		    ! Initialize all input buffer pointer for next record
;14800  1653		    ! in this I/O statement, e.g., ISB$A_BUF_{BEG,PTR,END}
;14900  1654		    ! and ISB$V_DOLLAR = 0.
;15000  1655		    !-
;15100  1656		
;15200  1657		    BEGIN
;15300  1658		    IF .CCB[LUB$V_DIRECT] 
;15400  1659		    THEN
;15500  1660			FOR$$SIGNAL_STO (FOR$K_MORONEREC);
;15600  1661		    DO_READ (FOR$$AA_REC_PR1 + .FOR$$AA_REC_PR1[.CCB[ISB$B_STTM_TYPE]]);
;15700  1662		    END;
;15800  1663		
;15900  1664		
;16000  1665		[2]:
;16100  1666		    !+
;16200  1667		    ! Dollar sign: Do nothing for read.  $ only affects write
;16300  1668		    !-
;16400  1669		
;16500  1670		    ;	! do nothing

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-3
;
;16600  1671		
;16700  1672		[3]:
;16800  1673		
;16900  1674		    !+
;17000  1675		    ! Tn : set position to (beginning + n) - 1 (n in
;17100  1676		    ! ISB$W_FMT_W)
;17200  1677		    ! Check for request past end of data buffer
;17300  1678		    ! If yes, set to end 
;17400  1679		    !-
;17500  1680		
;17600  1681		    BEGIN
;17700  1682		    CCB[ISB$A_BUF_PTR] = CH$PLUS (.CCB[ISB$A_BUF_BEG], .CCB[ISB$W_FMT_W] - 1);
;17800  1683		    IF .CCB[ISB$A_BUF_PTR] GTRP .CCB[ISB$A_BUF_END]
;17900  1684		    THEN
;18000  1685			CCB[ISB$A_BUF_PTR] = .CCB[ISB$A_BUF_END];
;18100  1686		
;18200  1687		    END;	! End of T input
;18300  1688		
;18400  1689		
;18500  1690		
;18600  1691		[4]:
;18700  1692	
;18800  1693		    !+
;18900  1694		    ! nX: skip n spaces (n in DSC$W_LENGTH) by doing nothing
;19000  1695		    !-
;19100  1696		
;19200  1697		    ;	! do nothing
;19300  1698		
;19400  1699		[5]:
;19500  1700		
;19600  1701		    !+
;19700  1702		    ! nHccccc: Holerith - copy n (DSC$W_LENGTH) chars
;19800  1703		    ! from input buffer to format array. Update format
;19900  1704		    ! character pointer (ISB$A_FMT_PTR).  Format array is
;20000  1705		    ! blank padded if data in array is shorter than format.
;20100  1706		    !-
;20200  1707		
;20300  1708		    CCB[ISB$A_FMT_PTR] =
;20400  1709		        CH$COPY (.DSC[DSC$W_LENGTH], .DSC[DSC$A_POINTER], %C' ',
;20500  1710		    .CCB[ISB$W_FMT_W], .CCB[ISB$A_FMT_PTR]);
;20600  1711		
;20700  1712		[6]:
;20800  1713		
;20900  1714		    !+
;21000  1715		    ! Q format -  return no. of character positions remaining
;21100  1716		    ! in input buffer (ie., in record) as an integer.
;21200  1717		    ! Size of integer depends on size of user I/O list element data type.
;21300  1718		    ! If user element type is not integer, SIGNAL and store
;21400  1719		    ! into low order 32 bits.
;21500  1720		    ! Then exit loop and return to user program
;21600  1721		    !-
;21700  1722		
;21800  1723		    BEGIN
;21900  1724		    IF .ELEM_TYPE LSSU DSC$K_DTYPE_BU OR .ELEM_TYPE GTRU DSC$K_DTYPE_Q
;22000  1725		    THEN

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-4
;
;22100  1726		        CCB[ISB$B_ERR_NO] = FOR$K_FORVARMIS;
;22200  1727		    	(.ELEM_ADR)<0,MINU(4,.ELEM_SIZE)*%BPUNIT,0> = CH$DIFF (.CCB[ISB$A_BUF_END], .CCB[ISB$A_BUF_PTR]);
;22300  1728		    	EXITLOOP;
;22400  1729		    	END;		! End of Q input
;22500  1730		
;22600  1731		[7]:
;22700  1732		
;22800  1733		    !+
;22900  1734		    ! nAw.d and nA formats: Copy string from input field to user data element.
;23000  1735		    ! Copy right-most 1, 2, 4, or 8 characters (depending on data type)
;23100  1736		    ! or copy entire string and add trailing spaces.
;23200  1737		    !-
;23300  1738		
;23400  1739		    BEGIN
;23500  1740		    IF .ELEM_SIZE LSSU .DSC[DSC$W_LENGTH]
;23600  1741		    THEN
;23700  1742		
;23800  1743		        !+
;23900  1744		        ! User data element is smaller than format specified field.
;24000  1745		        ! Copy rightmost 1, 2, 4, or 8 characters depending on data type.
;24100  1746		        !-
;24200  1747		
;24300  1748		        CH$MOVE (.ELEM_SIZE, .DSC[DSC$A_POINTER] + (.DSC[DSC$W_LENGTH] - .ELEM_SIZE),
;24400  1749		    	CH$PTR(.ELEM_ADR))
;24500  1750		    ELSE
;24600  1751		
;24700  1752		        !+
;24800  1753		        ! Data element is greater or equal to the field.
;24900  1754		        ! Copy entire string left justified and fill trailing spaces.
;25000  1755		        !-
;25100  1756		
;25200  1757		        CH$COPY (.DSC[DSC$W_LENGTH], .DSC[DSC$A_POINTER], %C' ', .ELEM_SIZE, CH$PTR (.ELEM_ADR));
;25300  1758		
;25400  1759		    EXITLOOP;
;25500  1760		    END;
;25600  1761		
;25700  1762		
;25800  1763		
;25900  1764		[8]:
;26000  1765		    !+
;26100  1766		    ! All integer formats (L,O,I,Z) output:
;26200  1767		    ! 1) Check data type. If user I/o list element is not integer (B,W,L,WU,LU),
;26300  1768		    ! SIGNAL FOR$_FORVARMIS (61='FORMAT VARIABLE-TYPE MISMATCH').
;26400  1769		    ! Then store as if L.
;26500  1770		    !-
;26600  1771		
;26700  1772		    BEGIN
;26800  1773		    LOCAL
;26900  1774		        S,		! No. of addressable units in
;27000  1775		    		! user I/O list element.
;27100  1776		        V;		! longword value returned from conversion rout.
;27200  1777		    IF .ELEM_TYPE GEQU DSC$K_DTYPE_Q
;27300  1778		    THEN
;27400  1779		        BEGIN
;27500  1780		    	    CCB[ISB$B_ERR_NO] = FOR$K_FORVARMIS;

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-5
;
;27600  1781		        S = %UPVAL;
;27700  1782		        END
;27800  1783		    ELSE
;27900  1784		        S = .ELEM_SIZE;
;28000  1785		
;28100  1786		    !+
;28200  1787		    ! 2) Call appropriate library conversion routine
;28300  1788		    ! Sign extend (I,L) or zero-extend (O,Z) result (V).
;28400  1789		    ! If value could not fit, SIGNAL FOR$_IN_CONERR
;28500  1790		    ! (64='INPUT CONVERSION ERROR' - low order bits stored correctly.
;28600  1791		    !-
;28700  1792		
;28800  1793		    IF NOT
;28900  1794		        (AA_IN_FIX + .AA_IN_FIX[.FMT_CODE - _L]) (DSC, V)
;29000  1795		    THEN
;29100  1796		        CCB[ISB$B_ERR_NO] = FOR$K_INPCONERR;
;29200  1797	
;29300  1798		    !+
;29400  1799		    ! Store value in proper size depending on data type
;29500  1800		    ! If user I/O element is not integer/logical data type, treat as INTEGER*4 (L).
;29600  1801		    ! If the value is too big to fit (sign extension (I,L) or
;29700  1802		    ! zero-extension (O,Z) doesn't match)
;29800  1803		    ! SIGNAL FOR$_IN_CONERR (64='INPUT CONVERSION ERROR')
;29900  1804		    ! and leave correct low order part stored.
;30000  1805		    !-
;30100  1806	
;30200  1807		    (.ELEM_ADR)<0, .S*%BPUNIT, 0> = .V;
;30300  1808		    IF .V NEQU (CASE .FMT_CODE FROM _L TO _Z OF
;30400  1809		    	SET
;30500  1810		    	[_L,_I]: .V<0, .S*%BPUNIT, 1>;
;30600  1811		    	[_O,_Z]: .V<0, .S*%BPUNIT, 0>;
;30700  1812		    	TES)
;30800  1813		    THEN
;30900  1814		        CCB[ISB$B_ERR_NO] = FOR$K_INPCONERR;
;31000  1815		    EXITLOOP;
;31100  1816		    END;	    ! End of L,O,I,Z input
;31200  1817		
;31300  1818		
;31400  1819		[9]:
;31500  1820		
;31600  1821		    !+
;31700  1822		    ! All Floating formats (F,E,G,D) input:
;31800  1823		    !-
;31900  1824		
;32000  1825		    BEGIN
;32100  1826		    LOCAL
;32200  1827		        D_VALUE: VECTOR[2];		! Double precision floating poiNt
;32300  1828		
;32400  1829		
;32500  1830		
;32600  1831		    !+
;32700  1832		    !  Call the appropriate conversion routine
;32800  1833		    ! If the value did not fit in field, SIGNAL FOR$_INPCONERR
;32900  1834		    ! (INPUT CONVERSION ERROR) 
;33000  1835		    !

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-6
;
;33100  1836	
;33200  1837		    IF NOT FOR$CNV_IN_DEFG (DSC, D_VALUE, .CCB[ISB$B_FMT_D], .CCB[ISB$B_FMT_P])
;33300  1838		    THEN
;33400  1839		        CCB[ISB$B_ERR_NO] = FOR$K_INPCONERR;
;33500  1840		
;33600  1841		    !+
;33700  1842		    ! Store the floating value
;33800  1843		    !-
;33900  1844	
;34000  1845		    CASE .ELEM_TYPE FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
;34100  1846		        SET
;34200  1847		    [DSC$K_DTYPE_F]:
;34300  1848		    
;34400  1849			!+
;34500  1850			! If user I/O element is of type REAL (floating)
;34600  1851			! convert from double to floating and check for overflow
;34700  1852			!-
;34800  1853	
;34900  1854			BEGIN
;35000  1855			IF NOT LIB$CVTDF (D_VALUE, D_VALUE)
;35100  1856			THEN
;35200  1857		            CCB[ISB$B_ERR_NO] = FOR$K_INPCONERR;
;35300  1858			ELEM_ADR[0] = .D_VALUE[0];
;35400  1859			END;	! End of floating
;35500  1860	
;35600  1861		    [DSC$K_DTYPE_D]:
;35700  1862	
;35800  1863			!+
;35900  1864			! Double - copy double floating
;36000  1865			!-
;36100  1866	
;36200  1867			BEGIN
;36300  1868			ELEM_ADR[0] = .D_VALUE[0];
;36400  1869			ELEM_ADR[1] = .D_VALUE[1];
;36500  1870			END;
;36600  1871	
;36700  1872		    [OUTRANGE]:
;36800  1873	
;36900  1874			!+
;37000  1875			! If user I/O element is of type integer or logical,
;37100  1876			! SIGNAL FOR$K_FORVARMIS
;37200  1877			! Store only the proper no. of low order addressable machine units
;37300  1878			! of the floating point value in the user element.
;37400  1879			!-
;37500  1880	
;37600  1881			BEGIN
;37700  1882			CCB[ISB$B_ERR_NO] = FOR$K_FORVARMIS;
;37800  1883			(.ELEM_ADR)<0,.ELEM_SIZE*%BPUNIT,1> = .D_VALUE;
;37900  1884			END;	! End of other cases
;38000  1885		       TES;
;38100  1886		    
;38200  1887		    !+
;38300  1888		    ! Exit loop and return to user program
;38400  1889		    !-
;38500  1890		

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-7
;
;38600  1891		    EXITLOOP;
;38700  1892		    END;	! End of F,E,G,D output
;38800  1893		
;38900  1894		
;39000  1895		TES;	! End of CASE (entire loop)
;39100  1896		END;		! End of processing
;39200  1897		
;39300  1898	    !+
;39400  1899	    ! Print function value, output formals, and implicit outputs, if debugging.
;39500  1900	    !-
;39600  1901		
;39700  1902	    FUNCTION_VALUE (FOR$$UDF_RF1);
;39800  1903	    OUTPUT_FORMALS (FOR$$UDF_RF1);
;39900  1904	    IMPLICIT_OUTPUT (FOR$$UDF_RF1, '.CCB[ISB$A_FMT_PTR]', .CCB[ISB$A_FMT_PTR],
;40000P 1905		'.CCB[ISB$A_BUF_PTR]', .CCB[ISB$A_BUF_PTR],
;40100P 1906		'.CCB[ISB$A_BUF_HIGH]', .CCB[ISB$A_BUF_HIGH], '.CCB[ISB$V_DOLLAR]', .CCB[ISB$V_DOLLAR]);
;40200  1907	    RETURN;		! Return from FOR$$UDF_RF1 routine
;40300  1908	    END;		! End of FOR$$UDF_RF1





					 01FC 00049 	    .ENTRY  FOR$$UDF_RF1, Save R2,R3,R4,R5,R6,R7,R8		      ; 1407
		         5E 	       14  C2 0004B 	    SUBL2   #20, SP						      ;
		         01 	  D1   AB  B1 0004E 1$:     CMPW    -47(CCB), #1					      ; 1557
				       0F  15 00052 	    BLEQ    2$							      ;
		         29 	  D3   AB  91 00054 	    CMPB    -45(CCB), #41					      ;
				       09  1E 00058 	    BGEQU   2$							      ;
		         56 	  D3   AB  9A 0005A 	    MOVZBL  -45(CCB), FMT_CODE					      ; 1560
				  D1   AB  B7 0005E 	    DECW    -47(CCB)						      ; 1561
				       0B  11 00061 	    BRB     3$							      ; 1557
				  08   AC  DD 00063 2$:     PUSHL   ELEM_SIZE						      ; 1564
		  0000G  CF	       01  FB 00066 	    CALLS   #1, FOR$$FMT_INTRP1					      ;
		         56 	       50  D0 0006B 	    MOVL    R0, FMT_CODE					      ;
		         57 	  8E AF46  9A 0006E 3$:     MOVZBL  RF_ACT[FMT_CODE], ACT				      ; 1566
	   19 	         57 	       07  E1 00073 	    BBC     #7, ACT, 4$						      ; 1577
				  08   AC  D5 00077 	    TSTL    ELEM_SIZE						      ;
				       14  12 0007A 	    BNEQ    4$							      ;
		         50 	  A5   AB  9A 0007C 	    MOVZBL  -91(CCB), R0					      ; 1580
		         50 	0000GCF40  32 00080 	    CVTWL   FOR$$AA_REC_PR9[R0], R0				      ;
		         50 	0000GCF40  9E 00086 	    MOVAB   FOR$$AA_REC_PR9[R0], R0				      ;
				     0000V 30 0008C 	    BSBW    DO_READ						      ;
					   04 0008F 	    RET     							      ; 1581
	   2B 	         57 	       06  E1 00090 4$:     BBC     #6, ACT, 5$						      ; 1596
		    0C   AE	  CD   AB  B0 00094 	    MOVW    -51(CCB), DSC					      ; 1599
		    0E   AE	010E   8F  B0 00099 	    MOVW    #270, DSC+2						      ; 1600
		    10   AE	  B8   AB  D0 0009F 	    MOVL    -72(CCB), DSC+4					      ; 1602
		         50 	  CD   AB  3C 000A4 	    MOVZWL  -51(CCB), R0					      ; 1603
		    B8   AB	       50  C0 000A8 	    ADDL2   R0, -72(CCB)					      ;
		    BC   AB	  B8   AB  D1 000AC 	    CMPL    -72(CCB), -68(CCB)					      ; 1604
				       0C  1B 000B1 	    BLEQU   5$							      ;
      0C   AE	    BC   AB	  10   AE  A3 000B3 	    SUBW3   DSC+4, -68(CCB), DSC				      ; 1607
		    B8   AB	  BC   AB  D0 000BA 	    MOVL    -68(CCB), -72(CCB)					      ; 1608
	   1A 	         57 	       05  E1 000BF 5$:     BBC     #5, ACT, 7$						      ; 1622

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-8
;
      10   BE	    0C   AE	       2C  3A 000C3 	    LOCC    #44, DSC, @DSC+4					      ; 1626
				       02  12 000C9 	    BNEQ    6$							      ;
				       51  D4 000CB 	    CLRL    R1							      ;
		         50 	       51  D0 000CD 6$:     MOVL    R1, P						      ;
				       0B  13 000D0 	    BEQL    7$							      ; 1627
      0C   AE	         50 	  10   AE  A3 000D2 	    SUBW3   DSC+4, P, DSC					      ; 1630
		    B8   AB	  01   A0  9E 000D8 	    MOVAB   1(R0), -72(CCB)					      ; 1631
	   57 	         04 	       00  EF 000DD 7$:     EXTZV   #0, #4, ACT, R8					      ; 1635
				       58     000E1									      ;
	   09 	         00 	       58  CF 000E2 	    CASEL   R8, #0, #9						      ;
	 FF68 	       0016 	     FF68     000E6 8$:     .WORD   1$-8$,-						      ;
	 0052 	       FF68 	     0037     000EC		    9$-8$,-						      ;
	 00B4 	       008F 	     0063     000F2		    1$-8$,-						      ;
				     0110     000F8		    11$-8$,-						      ;
								    1$-8$,-						      ;
								    12$-8$,-						      ;
								    14$-8$,-						      ;
								    18$-8$,-						      ;
								    20$-8$,-						      ;
								    28$-8$						      ;
				       4A  11 000FA 	    BRB     13$							      ;
	   07 	    FC   AB	       04  E1 000FC 9$:     BBC     #4, -4(CCB), 10$					      ; 1658
				       1B  DD 00101 	    PUSHL   #27							      ; 1660
		  0000G  CF	       01  FB 00103 	    CALLS   #1, FOR$$SIGNAL_STO					      ;
		         50 	  A5   AB  9A 00108 10$:    MOVZBL  -91(CCB), R0					      ; 1661
		         50 	0000GCF40  32 0010C 	    CVTWL   FOR$$AA_REC_PR1[R0], R0				      ;
		         50 	0000GCF40  9E 00112 	    MOVAB   FOR$$AA_REC_PR1[R0], R0				      ;
				     0000V 30 00118 	    BSBW    DO_READ						      ;
				       29  11 0011B 	    BRB     13$							      ; 1635
		         50 	  CD   AB  3C 0011D 11$:    MOVZWL  -51(CCB), R0					      ; 1682
		         50 	  C4   AB  C0 00121 	    ADDL2   -60(CCB), R0					      ;
		    B8   AB	  FF   A0  9E 00125 	    MOVAB   -1(R0), -72(CCB)					      ;
		    BC   AB	  B8   AB  D1 0012A 	    CMPL    -72(CCB), -68(CCB)					      ; 1683
				       15  1B 0012F 	    BLEQU   13$							      ;
		    B8   AB	  BC   AB  D0 00131 	    MOVL    -68(CCB), -72(CCB)					      ; 1685
				       0E  11 00136 	    BRB     13$							      ; 1635
	   20 	    10   BE	  0C   AE  2C 00138 12$:    MOVC5   DSC, @DSC+4, #32, -51(CCB), @-64(CCB)		      ; 1709
		    C0   BB	  CD   AB     0013E									      ;
		    C0   AB	       53  D0 00142 	    MOVL    R3, -64(CCB)					      ;
				     FF05  31 00146 13$:    BRW     1$							      ; 1635
		         02 	  04   AC  D1 00149 14$:    CMPL    ELEM_TYPE, #2					      ; 1724
				       06  1F 0014D 	    BLSSU   15$							      ;
		         09 	  04   AC  D1 0014F 	    CMPL    ELEM_TYPE, #9					      ;
				       04  1B 00153 	    BLEQU   16$							      ;
		    A4   AB	       3D  90 00155 15$:    MOVB    #61, -92(CCB)					      ; 1726
		         50 	  08   AC  D0 00159 16$:    MOVL    ELEM_SIZE, R0					      ; 1727
		         04 	       50  D1 0015D 	    CMPL    R0, #4						      ;
				       03  1B 00160 	    BLEQU   17$							      ;
		         50 	       04  D0 00162 	    MOVL    #4, R0						      ;
		         50 	       08  C4 00165 17$:    MULL2   #8, R0						      ;
	   51 	    BC   AB	  B8   AB  C3 00168 	    SUBL3   -72(CCB), -68(CCB), R1				      ;
	   50 	         00 	       51  F0 0016E 	    INSV    R1, #0, R0, @ELEM_ADR				      ;
				  0C   BC     00172									      ;
					   04 00174 	    RET     							      ; 1728
      0C   AE	         10 	       00  ED 00175 18$:    CMPZV   #0, #16, DSC, ELEM_SIZE				      ; 1740

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-9
;
				  08   AC     0017A									      ;
				       11  1B 0017C 	    BLEQU   19$							      ;
		         50 	  0C   AE  3C 0017E 	    MOVZWL  DSC, R0						      ; 1748
		         50 	  08   AC  C2 00182 	    SUBL2   ELEM_SIZE, R0					      ;
      0C   BC	    10 BE40	  08   AC  28 00186 	    MOVC3   ELEM_SIZE, @DSC+4[R0], @ELEM_ADR			      ;
					   04 0018E 	    RET     							      ; 1740
	   20 	    10   BE	  0C   AE  2C 0018F 19$:    MOVC5   DSC, @DSC+4, #32, ELEM_SIZE, @ELEM_ADR		      ; 1757
		    0C   BC	  08   AC     00195									      ;
					   04 00199 	    RET     							      ; 1759
		         09 	  04   AC  D1 0019A 20$:    CMPL    ELEM_TYPE, #9					      ; 1777
				       09  1F 0019E 	    BLSSU   21$							      ;
		    A4   AB	       3D  90 001A0 	    MOVB    #61, -92(CCB)					      ; 1780
		         52 	       04  D0 001A4 	    MOVL    #4, S						      ; 1781
				       04  11 001A7 	    BRB     22$							      ; 1777
		         52 	  08   AC  D0 001A9 21$:    MOVL    ELEM_SIZE, S					      ; 1784
		         50 	FE46 CF46  32 001AD 22$:    CVTWL   AA_IN_FIX-44[FMT_CODE], R0				      ; 1794
				       5E  DD 001B3 	    PUSHL   SP							      ;
				  10   AE  9F 001B5 	    PUSHAB  DSC							      ;
		  FE66 CF40	       02  FB 001B8 	    CALLS   #2, AA_IN_FIX[R0]					      ;
		         05 	       50  E8 001BE 	    BLBS    R0, 23$						      ;
		    A4   AB	  40   8F  90 001C1 	    MOVB    #64, -92(CCB)					      ; 1796
	   50 	         52 	       03  78 001C6 23$:    ASHL    #3, S, R0						      ; 1807
	   50 	         00 	       6E  F0 001CA 	    INSV    V, #0, R0, @ELEM_ADR				      ;
				  0C   BC     001CE									      ;
	   03 	         16 	       56  CF 001D0 	    CASEL   FMT_CODE, #22, #3					      ; 1808
	 0008 	       000F 	     0008     001D4 24$:    .WORD   25$-24$,-						      ;
				     000F     001DA		    26$-24$,-						      ;
								    25$-24$,-						      ;
								    26$-24$						      ;
	   6E 	         50 	       00  EE 001DC 25$:    EXTV    #0, R0, V, R1					      ; 1810
				       51     001E0									      ;
				       05  11 001E1 	    BRB     27$							      ; 1808
	   6E 	         50 	       00  EF 001E3 26$:    EXTZV   #0, R0, V, R1					      ; 1811
				       51     001E7									      ;
		         50 	       51  D0 001E8 27$:    MOVL    R1, R0						      ; 1808
		         50 	       6E  D1 001EB 	    CMPL    V, R0						      ;
				       5C  13 001EE 	    BEQL    34$							      ;
		    A4   AB	  40   8F  90 001F0 	    MOVB    #64, -92(CCB)					      ; 1814
					   04 001F5 	    RET     							      ; 1815
		         7E 	  CC   AB  98 001F6 28$:    CVTBL   -52(CCB), -(SP)					      ; 1837
		         7E 	  CF   AB  9A 001FA 	    MOVZBL  -49(CCB), -(SP)					      ;
				  0C   AE  9F 001FE 	    PUSHAB  D_VALUE						      ;
				  18   AE  9F 00201 	    PUSHAB  DSC							      ;
		  0000G  CF	       04  FB 00204 	    CALLS   #4, FOR$CNV_IN_DEFG					      ;
		         05 	       50  E8 00209 	    BLBS    R0, 29$						      ;
		    A4   AB	  40   8F  90 0020C 	    MOVB    #64, -92(CCB)					      ; 1839
		         52 	  0C   AC  D0 00211 29$:    MOVL    ELEM_ADR, R2					      ; 1883
	   01 	         0A 	  04   AC  CF 00215 	    CASEL   ELEM_TYPE, #10, #1					      ; 1845
		       002E 	     0014     0021A 30$:    .WORD   31$-30$,-						      ;
								    33$-30$						      ;
		    A4   AB	       3D  90 0021E 	    MOVB    #61, -92(CCB)					      ; 1882
	   50 	    08   AC	       03  78 00222 	    ASHL    #3, ELEM_SIZE, R0					      ; 1883
	   50 	         00 	  04   AE  F0 00227 	    INSV    D_VALUE, #0, R0, (R2)				      ;
				       62     0022C									      ;
					   04 0022D 	    RET     							      ; 1845

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 5-10
;
				  04   AE  9F 0022E 31$:    PUSHAB  D_VALUE						      ; 1855
				  08   AE  9F 00231 	    PUSHAB  D_VALUE						      ;
	      00000000G  00	       02  FB 00234 	    CALLS   #2, LIB$CVTDF					      ;
		         05 	       50  E8 0023B 	    BLBS    R0, 32$						      ;
		    A4   AB	  40   8F  90 0023E 	    MOVB    #64, -92(CCB)					      ; 1857
		         62 	  04   AE  D0 00243 32$:    MOVL    D_VALUE, (R2)					      ; 1858
					   04 00247 	    RET     							      ; 1845
		         62 	  04   AE  7D 00248 33$:    MOVQ    D_VALUE, (R2)					      ; 1868
					   04 0024C 34$:    RET     							      ; 1407

; Routine Size:  516 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 6
;
;00100  1909	ROUTINE DO_READ (		! read formatted record and do per-record proc.
;00200  1910		FOR$$REC_xn)		! adr. or record processing routine
;00300  1911		: JSB_DO_READ NOVALUE =
;00400  1912		
;00500  1913	!+
;00600  1914	! FUNCTIONAL DESCRIPTION:
;00700  1915	!
;00800  1916	!	DO_READ is a local routine which inputs the next record by calling the appropriate
;00900  1917	!	record processing routine depending on the statement type
;01000  1918	!	(ISB$BSTTM_TYPE) and formal parameter FOR$$REC_xn which 
;01100  1919	!	is either (1) FOR$$REC_x1 if this is not the last record
;01200  1920	!	of the I/o statement or (2) FOR$$REC_x9 if the is the last
;01300  1921	!	record of the I/O statement, i.e., this is the end of I/O list call.
;01400  1922	!	Then is performs any per-record initialization.
;01500  1923	!	Note: DO_READ is called directly from FOR$$UDF_RF9 if
;01600  1924	!	next format byte is an end-of-format one, thus saving
;01700  1925	!	2 expensive calls to FOR$$UDF_RF1 and FOR$$FMTIN1.  Thus
;01800  1926	!	DO_READ has all processing needed to read a record.
;01900  1927	!
;02000  1928	! CALLING SEQUENCE:
;02100  1929	!
;02200  1930	!	JSB DO_READ (R0=for$$rec_xn.s.ar)
;02300  1931	!
;02400  1932	! FORMAL PARAMETERS:
;02500  1933	!
;02600  1934	!	FOR$$REC_xn.s.ar	Adr. of record processing routine (NOT PIC)
;02700  1935	!
;02800  1936	! IMPLICIT INPUTS:
;02900  1937	!
;03000  1938	!	OTS$$A_CUR_LUB		Pointer to current logical unit block
;03100  1939	!				(LUB). Used to setup base pointer ISB
;03200  1940	!				to current I/O statement block
;03300  1941	!
;03400  1942	! IMPLICIT OUTPUTS:
;03500  1943	!
;03600  1944	! The following locations are set only by previous calls
;03700  1945	! to FOR$$UDF_RF{0,1}, i.e., are effectively OWN for this module.
;03800  1946	!
;03900  1947	!	ISB$A_BUF_PTR		Pointer: Set to beginning of input record
;04000  1948	!	ISB$A_BUF_PTR		Pointer: set to beginning of input record
;04100  1949	!	ISB$A_BUF_HIGH		Pointer: set to beginning of input recordn
;04200  1950	!	ISB$A_BUF_END		Pointer: set to last char+1 of input record
;04300  1951	!--
;04400  1952		
;04500  1953	    BEGIN
;04600  1954		
;04700  1955	    EXTERNAL REGISTER
;04800  1956		CCB: REF BLOCK[, BYTE];
;04900  1957	
;05000  1958	    !+
;05100  1959	    ! Input record.
;05200  1960	    ! Return with new beginning and end pointers
;05300  1961	    ! to next user data buffer to be processed as input.
;05400  1962	    !-
;05500  1963		

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 6-1
;
;05600  1964	    JSB_REC1 (.FOR$$REC_xn);
;05700  1965		
;05800  1966	    !+
;05900  1967	    ! Initialize beginning and highest pointer (T format) 
;06000  1968	    ! to the first character position in the input record buffer
;06100  1969	    !-
;06200  1970		
;06300  1971	    CCB[ISB$A_BUF_BEG] = .CCB[ISB$A_BUF_PTR];
;06400  1972	    CCB[ISB$A_BUF_HIGH] = .CCB[ISB$A_BUF_PTR];
;06500  1973	    RETURN;	! Return from DO_READ routine
;06600  1974	    END;	! End of DO_READ routine





				       60  16 0024D DO_READ:JSB     (FOR$$REC_XN)					      ; 1964
		    C4   AB	  B8   AB  D0 0024F 	    MOVL    -72(CCB), -60(CCB)					      ; 1971
		    C8   AB	  B8   AB  D0 00254 	    MOVL    -72(CCB), -56(CCB)					      ; 1972
					   05 00259 	    RSB     							      ; 1909

; Routine Size:  13 bytes



; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 7
;
;00100  1975	GLOBAL ROUTINE FOR$$UDF_RF9  ! Formatted input - end of I/O list call
;00200  1976	    	: JSB_UDF9 NOVALUE =
;00300  1977	
;00400  1978	
;00500  1979	!++
;00600  1980	! FUNCTIONAL DESCRIPTION:
;00700  1981	!
;00800  1982	!	FOR$$UDF_RF9 performs end of I/O list input formatting.
;00900  1983	!	All format codes are processed until a data transmitting
;01000  1984	!	format code is encountered (or colon) or end of format.
;01100  1985	!
;01200  1986	! CALLING SEQUENCE:
;01300  1987	!
;01400  1988	!	JSB FOR$$UDF_RF9 ()
;01500  1989	!
;01600  1990	! FORMAL PARAMETERS:
;01700  1991	!
;01800  1992	!	NONE
;01900  1993	!
;02000  1994	! IMPLICIT INPUTS:
;02100  1995	!
;02200  1996	!	See FOR$$UDF_RF1
;02300  1997	!
;02400  1998	!
;02500  1999	! IMPLICIT OUTPUTS:
;02600  2000	!
;02700  2001	!	See FOR$$UDF_RF1
;02800  2002	!
;02900  2003	! FUNCTION VALUE:
;03000  2004	!
;03100  2005	!	NONE
;03200  2006	!
;03300  2007	! SIDE EFFECTS:
;03400  2008	!
;03500  2009	!	See FOR$$UDF_RF1
;03600  2010	!--
;03700  2011	
;03800  2012	    BEGIN
;03900  2013	
;04000  2014	    EXTERNAL REGISTER
;04100  2015		CCB: REF BLOCK[, BYTE];
;04200  2016	
;04300  2017	    LOCAL
;04400  2018		X: BLOCK[1,BYTE];
;04500  2019	
;04600  2020	    !+
;04700  2021	    ! Check if next format byte is end-of-format.  If yes,
;04800  2022	    ! just do terminal read processing by calling DO_READ directly
;04900  2023	    ! thereby avoiding 2 CALLs (FOR$$UDFRF1 and FOR$$INTRP1) which
;05000  2024	    ! are slow because save lots of registers.
;05100  2025	    !-
;05200  2026	
;05300  2027	    X = .RF_ACT[.BLOCK[(.CCB[ISB$A_FMT_PTR]), V_FMT_CODE; , BYTE]];
;05400  2028	    IF .X[RF_EOLST]
;05500  2029	    THEN

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 7-1
;
;05600  2030		DO_READ (FOR$$AA_REC_PR9 + .FOR$$AA_REC_PR9[.CCB[ISB$B_STTM_TYPE]])
;05700  2031	    ELSE
;05800  2032	
;05900  2033		!+
;06000  2034		! Call data transmit entry point with element size of 0 as
;06100  2035		! a flag. Return as soon as a data transmitting format code,
;06200  2036		! colon, or End of Format code is encountered.
;06300  2037		!-
;06400  2038		
;06500  2039		FOR$$UDF_RF1 (0, 0, 0);
;06600  2040	    RETURN;
;06700  2041	    END;	! End of FOR$$UDF_RF9 Routine





      C0   BB	         07 	       00  EF 0025A FOR$$UDF_RF9::
							    EXTZV   #0, #7, @-64(CCB), R0				      ; 2027
				       50     0025F									      ;
		         50 	FD9B CF40  9A 00260 	    MOVZBL  RF_ACT[R0], X					      ;
	   13 	         50 	       07  E1 00266 	    BBC     #7, X, 1$						      ; 2028
		         50 	  A5   AB  9A 0026A 	    MOVZBL  -91(CCB), R0					      ; 2030
		         50 	0000GCF40  32 0026E 	    CVTWL   FOR$$AA_REC_PR9[R0], R0				      ;
		         50 	0000GCF40  9E 00274 	    MOVAB   FOR$$AA_REC_PR9[R0], R0				      ;
				       D1  10 0027A 	    BSBB    DO_READ						      ;
					   05 0027C 	    RSB     							      ; 2028
				       7E  7C 0027D 1$:     CLRQ    -(SP)						      ; 2039
				       7E  D4 0027F 	    CLRL    -(SP)						      ;
		  FDC3   CF	       03  FB 00281 	    CALLS   #3, FOR$$UDF_RF1					      ;
					   05 00286 	    RSB     							      ; 1975

; Routine Size:  45 bytes


;06800  2042	
;06900  2043	
;07000  2044	END		! End of FOR$$UDF_RF Module
;07100  2045	ELUDOM






;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  FOR$CODE       	   647  NOWRT,  RD ,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)




;				LIBRARY STATISTICS

; Bliss-32 10.1-416	Monday 21-AUG-1978 19:25:17	DBB3:[RTL.SRC]FUDFRF.B32;14					Page 7-2
;
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]STARLET.L32;1		      2688        10         0       111





; Size:		603 code + 44 data bytes
; Run Time:	00:25.4
; Elapsed Time:	01:05.9
; Memory Used:	293 pages
; Compilation Complete
