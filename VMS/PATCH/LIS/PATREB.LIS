
; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATREB (	!
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.07'
;	0007			) =
;	0008	BEGIN
;	0009	
;	0010	! COPYRIGHT (c) 1977
;	0011	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0012	!
;	0013	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0014	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0015	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0016	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0017	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0018	! TRANSFERRED.
;	0019	!
;	0020	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0021	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0022	! CORPORATION.
;	0023	!
;	0024	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0025	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0026	!
;	0027	
;	0028	!++
;	0029	! FACILITY:	PATCH
;	0030	!
;	0031	! ABSTRACT:	RST routines used primarily to rebuild RST data structures.
;	0032	!
;	0033	!
;	0034	! ENVIRONMENT:	This module runs on VAX under VAX/VMS, user mode, non-AST level.
;	0035	!
;	0036	! Author:	Kevin Pammett, August 12, 1977.
;	0037	!
;	0038	! Version:	X01.07
;	0039	!
;	0040	! MODIFCATIONS:
;	0041	!
;	0042	!  NO	DATE		PROGRAMMER		PURPOSE
;	0043	!  --	----		----------		-------
;	0044	!
;	0045	!  00	22-DEC-77	K.D. MORSE		ADAPT VERSION 36 FOR PATCH.
;	0046	!  01	24-JAN-78	K.D. MORSE		ADD ERROR MSG PAT$_MODNOTADD (37).
;	0047	!  02	28-JAN-78	K.D. MORSE		SET_MODULE NOW WORKS FROM
;	0048	!						THE COMMAND ARGUMENT LIST
;	0049	!						OR FROM AN MC POINTER. (38)
;	0050	!						SET_MODULE AND CANC_MODULE
;	0051	!						UNDERSTAND /ALL. (39)
;	0052	!						THE SAT/LVT ACCESSING LOGIC WAS
;	0053	!						ADDED TO THE SORT FOR
;	0054	!						PERFORMANCE IMPROVEMENT. (40)
;	0055	!  03	04-APR-78	K.D. MORSE		NO CHANGES FOR 41.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 1-1
; Digital Equipment Corporation
;
;	0056	!  04	18-APR-78	K.D. MORSE		CHANGE NXT_SAT_LVT TO
;	0057	!						GET_NXT_SAT_LVT AND MADE ACCESS
;	0058	!						TO IT INCLUDE THE RECORD SIZE. 42
;	0059	!						PUT IN SET AND CANCEL /ALL MODU. 43
;	0060	!  05	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0061	!  06	18-MAY-78	K.D. MORSE		CANCEL MODULE ALSO NOT CAUSES
;	0062	!						SCOPE TO BE CANCELLED IF BOTH
;	0063	!						ARE THE SAME. (44)
;	0064	!						NO CHANGES FOR VERS 45.
;	0065	!  07	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0066	!
;	0067	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 2
; Digital Equipment Corporation
;
;	0068	!
;	0069	! TABLE OF CONTENTS:
;	0070	!
;	0071	
;	0072	FORWARD ROUTINE
;	0073		PAT$GET_NXT_SAT,					! Provide access to the SAT
;	0074		PAT$GET_NXT_LVT,					! Provide access to the LVT
;	0075		GET_NXT_SAT_LVT,						! Parameterized access to SAT/LVT.
;	0076		PAT$SET_MODULE : NOVALUE,				! Add a <module list> to the RST.
;	0077		PAT$CANC_MODULE : NOVALUE,				! Delete a <module list> from the RST.
;	0078		PAT$SORT_SA_LVT : NOVALUE,				! Sort the LVT or SAT vector.
;	0079		DELE_SAT_LVT,						! Mark SAT or LVT records for deletion.
;	0080		EMPTY_SAT_LVT : NOVALUE,				! Remove the SAT/LVT portion of a
;	0081									!  module from the RST.
;	0082		UNLINK_NT_RECS : NOVALUE;				! Remove NTs from hash chains.
;	0083	
;	0084	!
;	0085	! INCLUDE FILES:
;	0086	!
;	0087	
;	0088	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0089	REQUIRE 'SRC$:PATPCT.REQ';
;	0105	REQUIRE 'LIB$:PATMSG.REQ';
;	0263	REQUIRE 'SRC$:VXSMAC.REQ';
;	0303	REQUIRE 'SRC$:BSTRUC.REQ';
;	0354	REQUIRE 'SRC$:LISTEL.REQ';
;	0373	REQUIRE 'SRC$:PATGEN.REQ';
;	0552	REQUIRE 'SRC$:PATRST.REQ';
;	1610	REQUIRE 'SRC$:SYSSER.REQ';
;      R1618	SWITCHES LIST (SOURCE);
;      R1619	
;      R1620	EXTERNAL ROUTINE
;      R1621		PAT$fao_out;		! formats a line and outputs to the terminal
;      R1622	
;      R1623	SWITCHES LIST (NOSOURCE);
;	1668	
;	1669	!
;	1670	! MACROS:
;	1671	!
;	1672	
;	1673	!
;	1674	! EQUATED SYMBOLS:
;	1675	!
;	1676	
;	1677	!
;	1678	! EXTERNAL REFERENCES:
;	1679	!
;	1680	
;	1681	EXTERNAL
;	1682		PAT$GL_CONTEXT : BITVECTOR,				! CONTEXT QUALIFIER BITS (/ALL)
;	1683		PAT$GL_RST_BEGN,					! ADDRESS OF START OF RST
;	1684		PAT$GL_CSP_PTR : REF PATHNAME_VECTOR,			! Pointer to the current SCOPE
;	1685		PAT$GL_MC_PTR	: REF MC_RECORD,			! Pointer to the Module Chain (MC).
;	1686		PAT$GL_HEAD_LST;					! pointer to expression arg list.
;	1687	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 2-1
; Digital Equipment Corporation
;
;	1688	
;	1689	EXTERNAL ROUTINE
;	1690		PAT$ADD_MODULE,						! Add a module's symbols to the RST.
;	1691		PAT$VS_FREE : NOVALUE,					! Release vector storage.
;	1692		PAT$SAVE_SCOPE;						! CANC MODU may imply CANC SCOPE

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 3
; Digital Equipment Corporation
;
;	1693	GLOBAL ROUTINE PAT$GET_NXT_SAT( ACCESS_FLAG) =
;	1694	BEGIN
;	1695	RETURN( GET_NXT_SAT_LVT( .ACCESS_FLAG, RST_SAT_SIZE ));
;	1696	END;


							    .TITLE  PATREB
							    .IDENT  \X01.07\

							    .GLOBL  PAT$GL_RST_BEGN, PAT$FAO_OUT, PAT$GL_CONTEXT, PAT$GL_CSP_PTR
							    .GLOBL  PAT$GL_MC_PTR, PAT$GL_HEAD_LST, PAT$ADD_MODULE
							    .GLOBL  PAT$VS_FREE, PAT$SAVE_SCOPE
							    .WEAK   ACCESS_CHECK

							    .PSECT  _PAT$CODE,NOWRT,2

					 0000 00000 	    .ENTRY  PAT$GET_NXT_SAT, Save nothing			      ; 1693
				       0A  DD 00002 	    PUSHL   #10							      ; 1695
				  04   AC  DD 00004 	    PUSHL   ACCESS_FLAG						      ;
	      00000000V  EF	       02  FB 00007 	    CALLS   #2, GET_NXT_SAT_LVT					      ;
					   04 0000E 	    RET     							      ; 1693

; Routine Size:  15 bytes


;	1697	
;	1698	
;	1699	GLOBAL ROUTINE PAT$GET_NXT_LVT( ACCESS_FLAG ) =
;	1700	BEGIN
;	1701	RETURN( GET_NXT_SAT_LVT( .ACCESS_FLAG, RST_LVT_SIZE ));
;	1702	END;





					 0000 0000F 	    .ENTRY  PAT$GET_NXT_LVT, Save nothing			      ; 1699
				       06  DD 00011 	    PUSHL   #6							      ; 1701
				  04   AC  DD 00013 	    PUSHL   ACCESS_FLAG						      ;
	      00000000V  EF	       02  FB 00016 	    CALLS   #2, GET_NXT_SAT_LVT					      ;
					   04 0001D 	    RET     							      ; 1699

; Routine Size:  15 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 4
; Digital Equipment Corporation
;
;	1703	ROUTINE GET_NXT_SAT_LVT( ACCESS_FLAG, RECORD_SIZE ) =
;	1704	
;	1705	!++
;	1706	! Functional Description:
;	1707	!
;	1708	!	Provide access to the RST SAT or LVT structures.
;	1709	!	i.e. Allow sequential access to the SAT/LVT via 
;	1710	!	successive calls to this 'mapping' routine
;	1711	!	so that the accessor has no built-in notion of
;	1712	!	just how this sequential access is achieved.
;	1713	!
;	1714	! Formal Parameters:
;	1715	!
;	1716	!	access_flag -	One of three (3) possible values which indicate
;	1717	!			what type of access this is.
;	1718	!			SA_ACCE_INIT	- Initialize the OWN pointers for further
;	1719	!					  access.
;	1720	!			SA_ACCE_RECS	- Return the next record in the structure.
;	1721	!			SA_ACCE_FREE	- Return the next record marked for deletion
;	1722	!					  that is not in a module about to be deleted.
;	1723	!	record_size -	The number of bytes in the record structure being accessed.
;	1724	!
;	1725	! Implicit Inputs:
;	1726	!
;	1727	!	This routine defines how the SAT and LVT are accessed
;	1728	!	sequentially.  This definition must correspond to the one
;	1729	!	that is also 'built-in' in the routine DBG$SORT_SA_LVT.
;	1730	!	The latter does not use this routine's defintion because
;	1731	!	of the performance penality we pay to do it.  (all the CALLSes)
;	1732	!
;	1733	!	Some other routines also access the SAT/LVT 'on their own',
;	1734	!	but they restrict themselves to only looking at one storage vector's
;	1735	!	contribution to the SAT/LVT.
;	1736	!
;	1737	!	The MC storage descriptors for all MCs marked MC_IN_RST
;	1738	!	(this includes the one for globals) must be consistent.
;	1739	!
;	1740	! Implicit Outputs:
;	1741	!
;	1742	!	none.
;	1743	!
;	1744	! Routine Value:
;	1745	!
;	1746	!	0, when there are no more SAT or LVT records given the
;	1747	!	   indicated ending criteria,
;	1748	!	Otherwise, a pointer to the appropriate record.
;	1749	!
;	1750	!	On the _INIT call, this routine returns the number of
;	1751	!	bytes in the SAT/LVT record which the _INIT
;	1752	!	was done for.
;	1753	!
;	1754	! Side Effects:
;	1755	!
;	1756	!	The SAT or LVT is accessed sequentially.
;	1757	!	OWN storage is initialized and used.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 4-1
; Digital Equipment Corporation
;
;	1758	!--
;	1759	
;	1760	BEGIN
;	1761	
;	1762	LABEL
;	1763		NEXT_MC_LOOP;
;	1764	
;	1765	
;	1766	OWN
;	1767		LAST_PTR : REF SAT_RECORD,				! Pointer to the record we returned on
;	1768									!  the previous call to this routine.
;	1769		MC_PTR : REF MC_RECORD;					! Module that LAST_PTR was in.
;	1770	
;	1771	LOCAL
;	1772		STORE_DESC : REF VECT_STORE_DESC,			! Pointer to the storage descriptor for the
;	1773									!  type of storage we are currently looking at.
;	1774		CURRENT,						! We keep two pointers to the SAT or LVT
;	1775									! record currently under consideration.
;	1776									! One, 'current', is NOT a SAT_POINTER because
;	1777									! such longword pointers aren't easily comparable
;	1778									! to the NT-pointers we get from storage descriptors.
;	1779		CURRENT_SAT_PTR : REF SAT_RECORD;			! The other, 'current_sat_ptr' is a real SAT
;	1780									! pointer which always corresponds to 'current'.
;	1781	
;	1782	!++
;	1783	! Initialization mode processing is simple and contained.  We simply set up a
;	1784	! new context.
;	1785	!--
;	1786	IF (.access_flag EQL SL_ACCE_INIT)
;	1787	THEN
;	1788		BEGIN
;	1789		!++
;	1790		! Set up so that the next call will find the
;	1791		! first LVT or SAT record given the access criterion.
;	1792		!--
;	1793		MC_PTR = .PAT$GL_MC_PTR;
;	1794		LAST_PTR = 0;
;	1795		RETURN(.RECORD_SIZE);					! Return the record size so that we can
;	1796									! localize this knowledge to this routine.
;	1797		END;
;	1798	
;	1799	!++
;	1800	! Iterate to set 'current' and 'current_sat_ptr' to point to 
;	1801	! the next record we want to consider.
;	1802	!--
;	1803	REPEAT
;	1804	    NEXT_MC_LOOP:
;	1805		BEGIN
;	1806		!++
;	1807		! Once we run off the end of the module chain
;	1808		! there is no more of any kind of storage.
;	1809		!--		
;	1810		IF (.MC_PTR EQL 0) AND (.LAST_PTR EQL 0)
;	1811		THEN
;	1812			RETURN(0);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 4-2
; Digital Equipment Corporation
;
;	1813	
;	1814		!++
;	1815		! See if this module is a possible candidate.
;	1816		!--
;	1817		IF .MC_PTR[MC_IN_RST]
;	1818		THEN
;	1819			BEGIN
;	1820			!++
;	1821			! The _FREE access type asks that we look only at
;	1822			! MCs which are both _IN_RST and NOT _DYING.
;	1823			IF (.access_flag EQL SL_ACCE_FREE)
;	1824			THEN
;	1825				IF .MC_PTR[MC_IS_DYING]
;	1826				THEN
;	1827					BEGIN
;	1828					!++
;	1829					! This module is soon to be deleted
;	1830					! so there is no _FREE storage therein.
;	1831					! Skip over this module completely.
;	1832					!--
;	1833					MC_PTR = .MC_PTR [MC_NEXT];
;	1834					LEAVE NEXT_MC_LOOP;
;	1835					END;
;	1836	
;	1837			!++
;	1838			! See if this module has any of the kind
;	1839			! of storage we are looking for.
;	1840			!--
;	1841			STORE_DESC = (IF (.RECORD_SIZE EQL RST_SAT_SIZE)
;	1842				      THEN MC_PTR [MC_SAT_STORAGE]
;	1843				      ELSE MC_PTR[MC_LVT_STORAGE]);
;	1844	
;	1845			!++
;	1846			! No storage is allocated if the 'begin' field is null.
;	1847			!--
;	1848			IF (.STORE_DESC [STOR_BEGIN_RST] NEQ 0)
;	1849			THEN
;	1850				BEGIN
;	1851				!++
;	1852				! Found the right place to look.  Point
;	1853				! to the next record within this module.
;	1854				!--
;	1855				IF (.LAST_PTR EQL 0)
;	1856				THEN
;	1857					!++
;	1858					! First time thru we start at the beginning
;	1859					!--
;	1860					CURRENT = .STORE_DESC [STOR_BEGIN_RST]
;	1861				ELSE
;	1862					!++
;	1863	
;	1864					! Subsequent times thru we assume that
;	1865					! the records are contiguous and fixed-size.
;	1866					!--
;	1867					CURRENT = .LAST_PTR + .RECORD_SIZE;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 4-3
; Digital Equipment Corporation
;
;	1868	
;	1869				!++
;	1870				! The 'current' pointer must be within range and it
;	1871				! must point to a record we are interested in, given
;	1872				! the access criteria. Loop thru the storage for this
;	1873				! module as long as there are still some to look at.
;	1874				!--
;	1875				IF (
;	1876				(WHILE( .CURRENT LSSA .STORE_DESC [STOR_MARKER] )
;	1877					DO
;	1878					BEGIN
;	1879					!++
;	1880					! Initialize the SAT_POINTER which
;	1881					! corresponds to 'current'.
;	1882					!--
;	1883					CURRENT_SAT_PTR = .CURRENT + .PAT$GL_RST_BEGN;
;	1884	
;	1885					!++
;	1886					! As long as we are in range, we can imply skip
;	1887					! along successive records until we get one
;	1888					! which satisfies the given access criteria.
;	1889					!--
;	1890					IF (.access_flag EQL SL_ACCE_RECS) 
;	1891					THEN
;	1892						BEGIN
;	1893						!++
;	1894						! Skip records which are marked
;	1895						! for deletion.  Anything else is OK.
;	1896						!--
;	1897						IF (.CURRENT_SAT_PTR [SAT_NT_PTR] NEQ 1)
;	1898						THEN
;	1899							EXITLOOP(TRUE);
;	1900						END
;	1901					ELSE
;	1902	
;	1903						BEGIN
;	1904						!++
;	1905						! The _FREE mode asks only for deleted
;	1906						! records in NOT _DYING modules.
;	1907						!--
;	1908						IF (.CURRENT_SAT_PTR [SAT_NT_PTR] EQL 1)
;	1909						THEN
;	1910							EXITLOOP(TRUE);
;	1911						END;
;	1912	
;	1913					!++
;	1914					! Skip along to the next record.
;	1915					!--
;	1916					CURRENT = .CURRENT + .RECORD_SIZE;
;	1917					END
;	1918				) EQL TRUE
;	1919				   )
;	1920				THEN
;	1921					!++
;	1922					! We have found a valid record in the current module.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 4-4
; Digital Equipment Corporation
;
;	1923					!--
;	1924					EXITLOOP;
;	1925	
;	1926				!++
;	1927				! If we fall out of the above loop, there were no records
;	1928				! in the current module which satsified the access
;	1929				! criteria. Set up so that when we look at the next
;	1930				! module we will begin at the first record.
;	1931				!--
;	1932				LAST_PTR = 0;
;	1933				END;
;	1934	
;	1935			!++
;	1936			! There is none of the kind of storage we are looking for so
;	1937			! loop back to consider the next module.
;	1938			!--
;	1939			END;
;	1940	
;	1941		!++
;	1942		! The current module is not in the RST so loop back to consider the next one.
;	1943		!--
;	1944		MC_PTR = .MC_PTR [MC_NEXT];
;	1945		END;
;	1946	
;	1947	!++
;	1948	! Pass back the desired pointer having first stored it away in our OWN storage
;	1949	! so that we can pick it up on the next call.
;	1950	!--
;	1951	LAST_PTR = .CURRENT;
;	1952	RETURN(.CURRENT_SAT_PTR);
;	1953	END;



							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 LAST_PTR:
							    .BLKB   4
					      00004 MC_PTR: .BLKB   4



							    .PSECT  _PAT$CODE,NOWRT,2

					 087C 0001E GET_NXT_SAT_LVT:
							    .WORD   Save R2,R3,R4,R5,R6,R11				      ; 1703
		         5B 00000000'  EF  9E 00020 	    MOVAB   LAST_PTR, R11					      ;
		         56	  04   AC  D0 00027 	    MOVL    ACCESS_FLAG, R6					      ; 1786
				       0F  12 0002B 	    BNEQ    1$							      ;
		    04   AB 00000000G  EF  D0 0002D 	    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 1793
				       6B  D4 00035 	    CLRL    LAST_PTR						      ; 1794
		         50	  08   AC  D0 00037 	    MOVL    RECORD_SIZE, R0					      ; 1795
					   04 0003B 	    RET     							      ;
		         54 00000000G  EF  D0 0003C 1$:     MOVL    PAT$GL_RST_BEGN, R4					      ; 1817
		         51	  04   AB  D0 00043 2$:     MOVL    MC_PTR, R1						      ; 1810

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 4-5
; Digital Equipment Corporation
;
				       04  12 00047 	    BNEQ    3$							      ;
				       6B  D5 00049 	    TSTL    LAST_PTR						      ;
				       7B  13 0004B 	    BEQL    16$							      ;
		         51	       54  C0 0004D 3$:     ADDL2   R4, R1						      ; 1817
	   66	    03   A1	       01  E1 00050 	    BBC     #1, 3(R1), 14$					      ;
		         03	       56  D1 00055 	    CMPL    R6, #3						      ; 1823
				       05  12 00058 	    BNEQ    4$							      ;
	   5C	    03   A1	       06  E0 0005A 	    BBS     #6, 3(R1), 14$					      ; 1825
	   51	    04   AB	       54  C1 0005F 4$:     ADDL3   R4, MC_PTR, R1					      ; 1842
		         0A	  08   AC  D1 00064 	    CMPL    RECORD_SIZE, #10					      ; 1841
				       06  12 00068 	    BNEQ    5$							      ;
	   52	         51	       23  C1 0006A 	    ADDL3   #35, R1, STORE_DESC					      ; 1842
				       04  11 0006E 	    BRB     6$							      ; 1841
	   52	         51	       2A  C1 00070 5$:     ADDL3   #42, R1, STORE_DESC					      ; 1843
				  01   A2  B5 00074 6$:     TSTW    1(STORE_DESC)					      ; 1848
				       42  13 00077 	    BEQL    14$							      ;
		         50	       6B  D0 00079 	    MOVL    LAST_PTR, R0					      ; 1855
				       06  12 0007C 	    BNEQ    7$							      ;
		         53	  01   A2  3C 0007E 	    MOVZWL  1(STORE_DESC), CURRENT				      ; 1860
				       05  11 00082 	    BRB     8$							      ; 1855
	   53	         50	  08   AC  C1 00084 7$:     ADDL3   RECORD_SIZE, R0, CURRENT				      ; 1867
      05   A2	         10	       00  ED 00089 8$:     CMPZV   #0, #16, 5(STORE_DESC), CURRENT			      ; 1876
				       53     0008E									      ;
				       20  1B 0008F 	    BLEQU   12$							      ;
	   55	         53	       54  C1 00091 	    ADDL3   R4, CURRENT, CURRENT_SAT_PTR			      ; 1883
		         01	       56  D1 00095 	    CMPL    R6, #1						      ; 1890
				       07  12 00098 	    BNEQ    9$							      ;
		         01	       65  B1 0009A 	    CMPW    (CURRENT_SAT_PTR), #1				      ; 1897
				       0C  13 0009D 	    BEQL    11$							      ;
				       05  11 0009F 	    BRB     10$							      ; 1899
		         01	       65  B1 000A1 9$:     CMPW    (CURRENT_SAT_PTR), #1				      ; 1908
				       05  12 000A4 	    BNEQ    11$							      ;
		         50	       01  D0 000A6 10$:    MOVL    #1, R0						      ; 1910
				       09  11 000A9 	    BRB     13$							      ;
		         53	  08   AC  C0 000AB 11$:    ADDL2   RECORD_SIZE, CURRENT				      ; 1916
				       D8  11 000AF 	    BRB     8$							      ; 1876
		         50	       01  CE 000B1 12$:    MNEGL   #1, R0						      ;
		         01	       50  D1 000B4 13$:    CMPL    R0, #1						      ; 1875
				       08  13 000B7 	    BEQL    15$							      ;
				       6B  D4 000B9 	    CLRL    LAST_PTR						      ; 1932
		    04   AB	       61  3C 000BB 14$:    MOVZWL  (R1), MC_PTR					      ; 1944
				       82  11 000BF 	    BRB     2$							      ; 1797
		         6B	       53  D0 000C1 15$:    MOVL    CURRENT, LAST_PTR					      ; 1951
		         50	       55  D0 000C4 	    MOVL    CURRENT_SAT_PTR, R0					      ; 1952
					   04 000C7 	    RET     							      ;
				       50  D4 000C8 16$:    CLRL    R0							      ; 1703
					   04 000CA 	    RET     							      ;

; Routine Size:  173 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 5
; Digital Equipment Corporation
;
;	1954	GLOBAL ROUTINE PAT$SET_MODULE (MODULE_TO_SET) : NOVALUE =
;	1955	
;	1956	!++
;	1957	! Functional Description:
;	1958	!
;	1959	!	Add the symbols for a given list of modules, or /ALL modules to the RST.
;	1960	!
;	1961	! Formal Parameters:
;	1962	!
;	1963	!	MODULE_TO_SET	-an MC pointer to the module we are
;	1964	!			 to add, or 0 => use the command
;	1965	!			 argument list or do SET /ALL.
;	1966	!
;	1967	!
;	1968	! Implicit Inputs:
;	1969	!
;	1970	!	The expression list contains MC_PTRs to the indicated modules.
;	1971	!	If "SET MODULE /ALL" was specified, then the Module Chain points to
;	1972	!	all the modules to set.
;	1973	!
;	1974	! Implicit Outputs:
;	1975	!
;	1976	!	The modules are added.
;	1977	!
;	1978	! Return Value:
;	1979	!
;	1980	!	NOVALUE - This routine SIGNALs out if an error occurs.
;	1981	!
;	1982	! Side Effects:
;	1983	!
;	1984	!	The symbols for the indicated modules get added to the RST.  If they
;	1985	!	 are already there,  PATCH merely returns.
;	1986	!	If an error occurs, a SIGNAL and UNWIND are performed.
;	1987	!--
;	1988	
;	1989	BEGIN
;	1990	
;	1991	LOCAL
;	1992		DO_SAT_SORT,						! Flags to control sorting.
;	1993		DO_LVT_SORT,
;	1994		POINTER,						! Used to scan the arg list.
;	1995		MC_CHAIN : REF MC_RECORD,				! POINTER TO CURRENT MODULE CHAIN ENTRY
;	1996		MC_PTR : REF MC_RECORD,					! Each arg is an MC pointer.
;	1997		STORE_DESC : REF VECT_STORE_DESC;			! We look at the storage descriptor
;	1998									! associated with a module after we
;	1999									! try to add it to see if SAT or LVT
;	2000									! storage was allocated.
;	2001	
;	2002	!++
;	2003	! Assume that we won't have to (re)sort the LVT and SAT - an added module doesn't
;	2004	! necessarily add anything to the LVT or SAT.
;	2005	!--
;	2006	DO_SAT_SORT = FALSE;
;	2007	DO_LVT_SORT = FALSE;
;	2008	MC_CHAIN = 0;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 5-1
; Digital Equipment Corporation
;
;	2009	
;	2010	!++
;	2011	! If we were given a specific module_to_set, then we just assume that that is
;	2012	! the MC_PTR we want.  Otherwise either DBG$GL_HEAD_LST points to an arg
;	2013	! list of MC_PTRs, or it is 0, which means that we are to try to set ALL modules.
;	2014	!--
;	2015	IF (.MODULE_TO_SET EQL 0)
;	2016	THEN
;	2017		IF ((POINTER = .PAT$GL_HEAD_LST) EQL 0)
;	2018		THEN
;	2019			MC_PTR = MC_CHAIN = .PAT$GL_MC_PTR;
;	2020	
;	2021	!++
;	2022	! Loop thru the arg list or module chain trying to add the indicated modules to
;	2023	! the RST.  Note that we skip over the MC reserved for globals if the MC chain
;	2024	! is being used.
;	2025	
;	2026	!--
;	2027	REPEAT
;	2028		BEGIN
;	2029		!++
;	2030		! PICK UP A POINTER TO THE MODULE TO BE SET.
;	2031		!--
;	2032		IF (.MC_CHAIN NEQ 0)
;	2033		THEN
;	2034			BEGIN
;	2035			!++
;	2036			! THE NEXT MODULE COMES FROM THE MODULE CHAIN.  CHECK FOR END
;	2037			! OF THE CHAIN.  This also skips the MC for globals.
;	2038			!--
;	2039			IF ((MC_PTR = .MC_PTR[MC_NEXT]) EQL 0)
;	2040			THEN
;	2041				EXITLOOP;
;	2042			END
;	2043		ELSE
;	2044			!++
;	2045			! THE NEXT MODULE IS EITHER ONE SPECIFICALLY REQUESTED OR
;	2046			! COMES FROM THE COMMAND ARGUMENT LIST.
;	2047			!--
;	2048			IF ((MC_PTR = .MODULE_TO_SET) EQL 0)
;	2049			THEN
;	2050				!++
;	2051				! EACH ARGUMENT IS A POINTER TO THE MC RECORD FOR
;	2052				! THE MODULE TO BE SET.
;	2053				!--
;	2054				MC_PTR = .LIST_ELEM_EXP1(.POINTER);
;	2055	
;	2056		!++
;	2057		! NOW CHECK THAT THE MODULE IS NOT ALREADY IN THE RST.
;	2058		!--
;	2059		IF ( NOT .MC_PTR[MC_IN_RST])
;	2060		THEN
;	2061			BEGIN
;	2062			!++
;	2063			! Simply add the module the same way that the RST init

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 5-2
; Digital Equipment Corporation
;
;	2064			! procedure would.
;	2065			!--
;	2066			IF (PAT$ADD_MODULE( .MC_PTR ))
;	2067			THEN
;	2068				BEGIN
;	2069				!++
;	2070				! Note that the module has been added, and see
;	2071				! if any LVT and/or SAT storage was allocated
;	2072				! for it to avoid an unnecessary SORT later on.
;	2073				!--
;	2074				MC_PTR [MC_IN_RST] = TRUE;
;	2075				MC_PTR [MC_IS_DYING] = FALSE;
;	2076				STORE_DESC = MC_PTR [MC_SAT_STORAGE];
;	2077				IF (.STORE_DESC [STOR_BEGIN_RST] NEQ 0)
;	2078				THEN
;	2079					DO_SAT_SORT = TRUE;
;	2080				STORE_DESC = MC_PTR [MC_LVT_STORAGE];
;	2081				IF (.STORE_DESC [STOR_BEGIN_RST] NEQ 0)
;	2082				THEN
;	2083					DO_LVT_SORT = TRUE;
;	2084				END
;	2085			ELSE
;	2086				!++
;	2087				! IF A LIST OF MODULES IS BEING SET, THIS MESSAGE MUST
;	2088				! BE INFORMATIONAL BECAUSE A "RETURN" MUST BE EXECUTED
;	2089				! FROM HERE TO DO THE POST-MODULE "SET" CLEANUP.
;	2090				! OTHERWISE A SIGNAL CAN BE PERFORMED HERE AND OUT OF
;	2091				! THE "SET SCOPE" COMMAND AS WELL.  BY SUBTRACTING
;	2092				! ONE FROM THE INFORMATION ERROR CODE, PATCH CREATES
;	2093				! A WARNING CODE.
;	2094				!--
;	2095				IF (.MODULE_TO_SET NEQ 0)
;	2096				THEN
;	2097					SIGNAL(PAT$_MODNOTADD-1, 1, MC_PTR[MC_NAME_CS])
;	2098				ELSE
;	2099					SIGNAL(PAT$_MODNOTADD, 1, MC_PTR[MC_NAME_CS]);
;	2100			END;
;	2101	
;	2102		!++
;	2103		! Go back and look at the next arg if there is one.
;	2104		!--
;	2105		IF (.MODULE_TO_SET NEQ 0)
;	2106		THEN
;	2107			!++
;	2108			! THERE IS NEVER A NEXT ONE IF ONLY ONE WAS SPECIFIED.
;	2109			!--
;	2110			EXITLOOP;
;	2111			
;	2112		!++
;	2113		! A NEXT ONE MUST COME FROM THE MC CHAIN OR THE ARG LIST.
;	2114		!--
;	2115		IF (.MC_CHAIN EQL 0)
;	2116		THEN
;	2117			IF ((POINTER = .LIST_ELEM_FLINK(.POINTER)) EQL 0)
;	2118			THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 5-3
; Digital Equipment Corporation
;
;	2119				EXITLOOP;
;	2120		END;
;	2121	
;	2122	!++
;	2123	! If any SAT/LVT storage was allocated, then corresponding records have been
;	2124	! added so we have to re-sort the structure.
;	2125	!--
;	2126	IF (.DO_SAT_SORT)
;	2127	THEN
;	2128		PAT$SORT_SA_LVT( PAT$GET_NXT_SAT );
;	2129	IF (.DO_LVT_SORT)
;	2130	THEN
;	2131		PAT$SORT_SA_LVT( PAT$GET_NXT_LVT );
;	2132	
;	2133	END;





					 0DFC 000CB 	    .ENTRY  PAT$SET_MODULE, Save R2,R3,R4,R5,R6,R7,R8,R10,R11	      ; 1954
		         5A 00000000V  EF  9E 000CD 	    MOVAB   PAT$SORT_SA_LVT, R10				      ;
		         5B 00000000G  EF  9E 000D4 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
				       57  7C 000DB 	    CLRQ    DO_SAT_SORT						      ; 2006
				       55  D4 000DD 	    CLRL    MC_CHAIN						      ; 2008
		         56	  04   AC  D0 000DF 	    MOVL    MODULE_TO_SET, R6					      ; 2015
				       13  12 000E3 	    BNEQ    1$							      ;
		         54 00000000G  EF  D0 000E5 	    MOVL    PAT$GL_HEAD_LST, POINTER				      ; 2017
				       0A  12 000EC 	    BNEQ    1$							      ;
		         55 00000000G  EF  D0 000EE 	    MOVL    PAT$GL_MC_PTR, MC_CHAIN				      ; 2019
		         52	       55  D0 000F5 	    MOVL    MC_CHAIN, MC_PTR					      ;
				       55  D5 000F8 1$:     TSTL    MC_CHAIN						      ; 2032
				       0B  13 000FA 	    BEQL    2$							      ;
	   50	         52	       6B  C1 000FC 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2039
		         52	       60  3C 00100 	    MOVZWL  (R0), MC_PTR					      ;
				       0B  12 00103 	    BNEQ    3$							      ;
				       7C  11 00105 	    BRB     10$							      ; 2041
		         52	       56  D0 00107 2$:     MOVL    R6, MC_PTR						      ; 2048
				       04  12 0010A 	    BNEQ    3$							      ;
		         52	  04   A4  D0 0010C 	    MOVL    4(POINTER), MC_PTR					      ; 2054
	   50	         52	       6B  C1 00110 3$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2059
	   5A	    03   A0	       01  E0 00114 	    BBS     #1, 3(R0), 8$					      ;
				       52  DD 00119 	    PUSHL   MC_PTR						      ; 2066
	      00000000G  EF	       01  FB 0011B 	    CALLS   #1, PAT$ADD_MODULE					      ;
		         27	       50  E9 00122 	    BLBC    R0, 5$						      ;
	   50	         52	       6B  C1 00125 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2074
		    03   A0	       02  88 00129 	    BISB2   #2, 3(R0)						      ;
		    03   A0	  40   8F  8A 0012D 	    BICB2   #64, 3(R0)						      ; 2075
	   53	         50	       23  C1 00132 	    ADDL3   #35, R0, STORE_DESC					      ; 2076
				  01   A3  B5 00136 	    TSTW    1(STORE_DESC)					      ; 2077
				       03  13 00139 	    BEQL    4$							      ;
		         57	       01  D0 0013B 	    MOVL    #1, DO_SAT_SORT					      ; 2079
	   53	         50	       2A  C1 0013E 4$:     ADDL3   #42, R0, STORE_DESC					      ; 2080
				  01   A3  B5 00142 	    TSTW    1(STORE_DESC)					      ; 2081
				       2C  13 00145 	    BEQL    8$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 5-4
; Digital Equipment Corporation
;
		         58	       01  D0 00147 	    MOVL    #1, DO_LVT_SORT					      ; 2083
				       27  11 0014A 	    BRB     8$							      ; 2066
	   50	         52	       6B  C1 0014C 5$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2097
				       56  D5 00150 	    TSTL    R6							      ; 2095
				       0D  13 00152 	    BEQL    6$							      ;
				  0C   A0  9F 00154 	    PUSHAB  12(R0)						      ; 2097
				       01  DD 00157 	    PUSHL   #1							      ;
			    006D800A   8F  DD 00159 	    PUSHL   #7176202						      ;
				       0B  11 0015F 	    BRB     7$							      ;
				  0C   A0  9F 00161 6$:     PUSHAB  12(R0)						      ; 2099
				       01  DD 00164 	    PUSHL   #1							      ;
			    006D800B   8F  DD 00166 	    PUSHL   #7176203						      ;
	      00000000G  00	       03  FB 0016C 7$:     CALLS   #3, LIB$SIGNAL					      ;
				       56  D5 00173 8$:     TSTL    R6							      ; 2105
				       0C  12 00175 	    BNEQ    10$							      ;
				       55  D5 00177 	    TSTL    MC_CHAIN						      ; 2115
				       03  12 00179 	    BNEQ    9$							      ;
		         54	       64  D0 0017B 	    MOVL    (POINTER), POINTER					      ; 2117
				       03  13 0017E 9$:     BEQL    10$							      ;
				     FF75  31 00180 	    BRW     1$							      ;
		         07	       57  E9 00183 10$:    BLBC    DO_SAT_SORT, 11$					      ; 2126
				FE76   CF  9F 00186 	    PUSHAB  PAT$GET_NXT_SAT					      ; 2128
		         6A	       01  FB 0018A 	    CALLS   #1, PAT$SORT_SA_LVT					      ;
		         07	       58  E9 0018D 11$:    BLBC    DO_LVT_SORT, 12$					      ; 2129
				FE7B   CF  9F 00190 	    PUSHAB  PAT$GET_NXT_LVT					      ; 2131
		         6A	       01  FB 00194 	    CALLS   #1, PAT$SORT_SA_LVT					      ;
					   04 00197 12$:    RET     							      ; 1954

; Routine Size:  205 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 6
; Digital Equipment Corporation
;
;	2134	GLOBAL ROUTINE PAT$CANC_MODULE : NOVALUE =
;	2135	
;	2136	!++
;	2137	! Functional Description:
;	2138	!
;	2139	!	Delete the symbols for a given list of module names from the RST,
;	2140	!	or delete /ALL modules.  If the SCOPE is set to a module that is to be
;	2141	!	cancelled, then the SCOPE is also cancelled.
;	2142	!
;	2143	! Implicit Inputs:
;	2144	!
;	2145	!	Context bit if /ALL was specified or not.
;	2146	!	The expression list contains MC_PTRs to the indicated modules.
;	2147	!
;	2148	! Implicit Outputs:
;	2149	!
;	2150	!	none.
;	2151	!
;	2152	! Return Value:
;	2153	!
;	2154	!	NOVALUE
;	2155	!
;	2156	! Side Effects:
;	2157	!
;	2158	!	The symbols for the indicated modules are deleted from the RST.
;	2159	!	If the symbols are not set, PATCH merely returns.  If an error occurs,
;	2160	!	then a SIGNAL and UNWIND are performed.
;	2161	!--
;	2162	
;	2163	BEGIN
;	2164	
;	2165	LOCAL
;	2166		MC_CHAIN : REF MC_RECORD,				! Pointer to scan module chain
;	2167		POINTER,						! Used to scan the arg list.
;	2168		SHRINK_LVT,						! Number of LVT records freed up.
;	2169		SHRINK_SAT,						! Number of SAT records freed up.
;	2170		MC_PTR : REF MC_RECORD;
;	2171	
;	2172	!++
;	2173	! If the module names come from the command argument list, then check the
;	2174	! consistency of the list.  Otherwise, initialize in preparation for the
;	2175	! "CANCEL MODULE /ALL" command.
;	2176	!--
;	2177	MC_CHAIN = 0;
;	2178	IF ((POINTER = .PAT$GL_HEAD_LST) EQL 0)
;	2179	THEN
;	2180		MC_PTR = MC_CHAIN = .PAT$GL_MC_PTR;
;	2181	
;	2182	!++
;	2183	! To avoid having to shrink the SAT or LVT when unnecessary, initialize
;	2184	! the flags (actually, counts) which indicate whether or not any records have
;	2185	! been removed from the corresponding data structures.
;	2186	!--
;	2187	SHRINK_LVT = 0;
;	2188	SHRINK_SAT = 0;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 6-1
; Digital Equipment Corporation
;
;	2189	
;	2190	!++
;	2191	! Loop thru the arg list trying to delete the indicated modules from the RST.
;	2192	!--
;	2193	REPEAT
;	2194		BEGIN
;	2195		IF (.MC_CHAIN NEQ 0)
;	2196		THEN
;	2197			BEGIN
;	2198			!++
;	2199			! The next module name comes from the module chain.  Check
;	2200			! for the end of the chain.
;	2201			!--
;	2202			IF ((MC_PTR = .MC_PTR[MC_NEXT]) EQL 0)
;	2203			THEN
;	2204				EXITLOOP;
;	2205			END
;	2206		ELSE
;	2207			!++
;	2208			! The next module name comes from the command argument list.
;	2209			! Each argument is a pointer to the MC record for the module
;	2210			! to be deleted.
;	2211			!--
;	2212			MC_PTR = .LIST_ELEM_EXP1(.POINTER);
;	2213	
;	2214		!++
;	2215		! Don't try to delete one which is not already there,
;	2216		! and don't complain if we are asked to.
;	2217		!--
;	2218		IF (.MC_PTR [MC_IN_RST])
;	2219		THEN
;	2220			BEGIN
;	2221			!++
;	2222			! Zero out all LVT or SAT records which correspond
;	2223			! to NT records which we are about to release.
;	2224			!--
;	2225			SHRINK_SAT = .SHRINK_SAT +
;	2226				DELE_SAT_LVT( MC_PTR [MC_NT_STORAGE], PAT$GET_NXT_SAT );
;	2227			SHRINK_LVT = .SHRINK_LVT +
;	2228				DELE_SAT_LVT( MC_PTR [MC_NT_STORAGE], PAT$GET_NXT_LVT );
;	2229	
;	2230	
;	2231			!++
;	2232			! If we have just cancelled a module into which the current
;	2233			! SCOPE is pointing, we cancel that scope so as th let the
;	2234			! user know it is useless.
;	2235			!--
;	2236			IF (.PAT$GL_CSP_PTR NEQA 0)
;	2237			THEN
;	2238				BEGIN
;	2239				LOCAL
;	2240					CS_PTR : CS_POINTER;
;	2241	
;	2242				!++
;	2243				! Pick up the first entry in the CSP pathname vector

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 6-2
; Digital Equipment Corporation
;
;	2244				! since that is the module name and is all we have
;	2245				! to look at to see if the CSP "points into" the
;	2246				! module we have just cancelled.
;	2247				!--
;	2248				CS_PTR = .PAT$GL_CSP_PTR[0];
;	2249				IF (CH$EQL(.CS_PTR[0], CS_PTR[1], .MC_PTR[MC_NAME_CS],
;	2250					MC_PTR[MC_NAME_ADDR]))
;	2251				THEN
;	2252					PAT$SAVE_SCOPE(FALSE);		! Cancel the SCOPE
;	2253				END;
;	2254			!++
;	2255			! Note that the module is about to be cancelled.  We can't turn
;	2256			! off MC_IN_RST yet because the access functions still use that
;	2257			! flag and there are still valid records in the storage
;	2258			! associated with this module.
;	2259			!--
;	2260			MC_PTR [MC_IS_DYING] = TRUE;
;	2261	
;	2262			!++
;	2263			! Unlink all NT records for this module from the hash chains
;	2264			! they are currently in, and release the vector storage taken
;	2265			! by them.
;	2266			!--
;	2267			UNLINK_NT_RECS( .MC_PTR );
;	2268			PAT$VS_FREE( MC_PTR [MC_NT_STORAGE] );
;	2269			END;
;	2270		!++
;	2271		! Check if there is another module name.
;	2272		!--
;	2273		IF (.MC_CHAIN EQL 0)
;	2274		THEN
;	2275			IF ((POINTER = .LIST_ELEM_FLINK(.POINTER)) EQL 0)
;	2276			THEN
;	2277				EXITLOOP;
;	2278		END;
;	2279	
;	2280	!++
;	2281	! For each module to be cancelled, we still have associated SAT/LVT storage
;	2282	! which probably contains records that correspond to other modules.  We must
;	2283	! move these to safer ground and then actually free up the storage.
;	2284	!--
;	2285	IF (.SHRINK_SAT NEQ 0)
;	2286	THEN
;	2287		EMPTY_SAT_LVT( PAT$GET_NXT_SAT );
;	2288	IF (.SHRINK_LVT NEQ 0)
;	2289	THEN
;	2290		EMPTY_SAT_LVT( PAT$GET_NXT_LVT );
;	2291	
;	2292	!++
;	2293	! All modules previously _DYING are now dead.
;	2294	!--
;	2295	MC_PTR = .PAT$GL_MC_PTR;
;	2296	WHILE( (MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0 )
;	2297		DO
;	2298		BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 6-3
; Digital Equipment Corporation
;
;	2299		IF (.MC_PTR [MC_IS_DYING])
;	2300		THEN
;	2301		!++
;	2302			! Once _IN_RST is FALSE almost no other flags are believed.
;	2303			!--
;	2304			MC_PTR [MC_IN_RST] = FALSE;
;	2305		END;
;	2306	END;





					 0FFC 00198 	    .ENTRY  PAT$CANC_MODULE, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 2134
		         59 00000000G  EF  9E 0019A 	    MOVAB   PAT$GL_MC_PTR, R9					      ;
		         5A	FE5B   CF  9E 001A1 	    MOVAB   PAT$GET_NXT_SAT, R10				      ;
		         5B 00000000G  EF  9E 001A6 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
				       56  D4 001AD 	    CLRL    MC_CHAIN						      ; 2177
		         55 00000000G  EF  D0 001AF 	    MOVL    PAT$GL_HEAD_LST, POINTER				      ; 2178
				       06  12 001B6 	    BNEQ    1$							      ;
		         56	       69  D0 001B8 	    MOVL    PAT$GL_MC_PTR, MC_CHAIN				      ; 2180
		         54	       56  D0 001BB 	    MOVL    MC_CHAIN, MC_PTR					      ;
				       57  7C 001BE 1$:     CLRQ    SHRINK_LVT						      ; 2187
				       56  D5 001C0 2$:     TSTL    MC_CHAIN						      ; 2195
				       0C  13 001C2 	    BEQL    3$							      ;
	   50	         54	       6B  C1 001C4 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2202
		         54	       60  3C 001C8 	    MOVZWL  (R0), MC_PTR					      ;
				       07  12 001CB 	    BNEQ    4$							      ;
				     0086  31 001CD 	    BRW     8$							      ; 2204
		         54	  04   A5  D0 001D0 3$:     MOVL    4(POINTER), MC_PTR					      ; 2212
	   50	         54	       6B  C1 001D4 4$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2218
	   6D	    03   A0	       01  E1 001D8 	    BBC     #1, 3(R0), 6$					      ;
				       5A  DD 001DD 	    PUSHL   R10							      ; 2226
				  1C   A0  9F 001DF 	    PUSHAB  28(R0)						      ;
	      00000000V  EF	       02  FB 001E2 	    CALLS   #2, DELE_SAT_LVT					      ;
		         58	       50  C0 001E9 	    ADDL2   R0, SHRINK_SAT					      ; 2225
				  0F   AA  9F 001EC 	    PUSHAB  PAT$GET_NXT_LVT					      ; 2228
	   50	         54	       6B  C1 001EF 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ;
				  1C   A0  9F 001F3 	    PUSHAB  28(R0)						      ;
	      00000000V  EF	       02  FB 001F6 	    CALLS   #2, DELE_SAT_LVT					      ;
		         57	       50  C0 001FD 	    ADDL2   R0, SHRINK_LVT					      ; 2227
		         50 00000000G  EF  D0 00200 	    MOVL    PAT$GL_CSP_PTR, R0					      ; 2236
				       21  13 00207 	    BEQL    5$							      ;
		         51	       60  D0 00209 	    MOVL    (R0), CS_PTR					      ; 2248
		         53	       61  9A 0020C 	    MOVZBL  (CS_PTR), R3					      ; 2249
	   50	         54	       6B  C1 0020F 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ;
		         52	  0C   A0  9A 00213 	    MOVZBL  12(R0), R2						      ;
	   00	    01   A1	       53  2D 00217 	    CMPC5   R3, 1(CS_PTR), #0, R2, 13(R0)			      ;
		    0D   A0	       52     0021C									      ;
				       09  12 0021F 	    BNEQ    5$							      ;
				       7E  D4 00221 	    CLRL    -(SP)						      ; 2252
	      00000000G  EF	       01  FB 00223 	    CALLS   #1, PAT$SAVE_SCOPE					      ;
	   50	         54	       6B  C1 0022A 5$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2260
		    03   A0	  40   8F  88 0022E 	    BISB2   #64, 3(R0)						      ;
				       54  DD 00233 	    PUSHL   MC_PTR						      ; 2267

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 6-4
; Digital Equipment Corporation
;
	      00000000V  EF	       01  FB 00235 	    CALLS   #1, UNLINK_NT_RECS					      ;
	   50	         54	       6B  C1 0023C 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2268
				  1C   A0  9F 00240 	    PUSHAB  28(R0)						      ;
	      00000000G  EF	       01  FB 00243 	    CALLS   #1, PAT$VS_FREE					      ;
				       56  D5 0024A 6$:     TSTL    MC_CHAIN						      ; 2273
				       03  12 0024C 	    BNEQ    7$							      ;
		         55	       65  D0 0024E 	    MOVL    (POINTER), POINTER					      ; 2275
				       03  13 00251 7$:     BEQL    8$							      ;
				     FF6A  31 00253 	    BRW     2$							      ;
				       58  D5 00256 8$:     TSTL    SHRINK_SAT						      ; 2285
				       09  13 00258 	    BEQL    9$							      ;
				       5A  DD 0025A 	    PUSHL   R10							      ; 2287
	      00000000V  EF	       01  FB 0025C 	    CALLS   #1, EMPTY_SAT_LVT					      ;
				       57  D5 00263 9$:     TSTL    SHRINK_LVT						      ; 2288
				       0A  13 00265 	    BEQL    10$							      ;
				  0F   AA  9F 00267 	    PUSHAB  PAT$GET_NXT_LVT					      ; 2290
	      00000000V  EF	       01  FB 0026A 	    CALLS   #1, EMPTY_SAT_LVT					      ;
		         54	       69  D0 00271 10$:    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 2295
	   50	         54	       6B  C1 00274 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2296
		         54	       60  3C 00278 11$:    MOVZWL  (R0), MC_PTR					      ;
				       0F  13 0027B 	    BEQL    12$							      ;
	   50	         54	       6B  C1 0027D 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2299
	   F2	    03   A0	       06  E1 00281 	    BBC     #6, 3(R0), 11$					      ;
		    03   A0	       02  8A 00286 	    BICB2   #2, 3(R0)						      ; 2304
				       EC  11 0028A 	    BRB     11$							      ; 2296
					   04 0028C 12$:    RET     							      ; 2134

; Routine Size:  245 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 7
; Digital Equipment Corporation
;
;	2307	ROUTINE UNLINK_NT_RECS( MC_PTR ) : NOVALUE =
;	2308	
;	2309	!++
;	2310	! Functional Description:
;	2311	!
;	2312	!	Remove all NT records for the module indicated  by MC_PTR from the
;	2313	!	hash chains they are in.  This is done in preparation for removing the
;	2314	!	indicated module from the RST completely.
;	2315	!
;	2316	! Formal Parameters:
;	2317	!
;	2318	!	MC_PTR	-An RST pointer to the MC entry for
;	2319	!		 the module we are to unlink NTs for.
;	2320	!
;	2321	! Implicit Inputs:
;	2322	!
;	2323	!	The NT records for the indicated module are all in contiguous storage
;	2324	!	(the so-called "vector storage" for that module), and one can
;	2325	!	'go thru' this vector and pick out the NT records given the data therein.
;	2326	!	(Now we use RST_NT_OVERHEAD and the count byte for the associated symbol
;	2327	!	name - but any 'contained' method will do).
;	2328	!
;	2329	! Implicit Outputs:
;	2330	!
;	2331	!	All existing hash chains are correctly re-linked,
;	2332	!	bypassing all NTs for the indicated module.
;	2333	!
;	2334	! Return Value:
;	2335	!
;	2336	!	NOVALUE - we make no checks on the given data.
;	2337	!--
;	2338	
;	2339	BEGIN
;	2340	
;	2341	MAP
;	2342		MC_PTR : REF MC_RECORD;
;	2343	
;	2344	LOCAL
;	2345		NT_PTR : REF NT_RECORD,					! Pointer we use to go thru the storage
;	2346									! vector of NT records.
;	2347		NT_VEC_DESC : REF VECT_STORE_DESC;			! We use the MC-contained descriptor of
;	2348									! the vector storage for the indicated NTs.
;	2349	
;	2350	!++
;	2351	! Pick up the vector storage descriptor for the  indicated NT records.
;	2352	!--
;	2353	NT_VEC_DESC = MC_PTR [MC_NT_STORAGE];
;	2354	
;	2355	!++
;	2356	! The first NT record begins in the first byte of the storage vector, and
;	2357	! the storage 'marker' field has been set to the first byte of unallocated
;	2358	! storage.
;	2359	!--
;	2360	NT_PTR = .NT_VEC_DESC [STOR_BEGIN_RST];
;	2361	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 7-1
; Digital Equipment Corporation
;
;	2362	!++
;	2363	! Go thru the storage vector sequentially.
;	2364	!--
;	2365	WHILE( .NT_PTR LSSA .NT_VEC_DESC [STOR_MARKER] )
;	2366		DO
;	2367		BEGIN
;	2368		LOCAL
;	2369			BACKWARD_NT : REF NT_RECORD,
;	2370			FORWARD_NT  : REF NT_RECORD;
;	2371	
;	2372		!++
;	2373		! Pick up the two links (forward and backward) which indicate where in
;	2374		! the hash chain this NT record is.
;	2375		!--
;	2376		BACKWARD_NT = .NT_PTR [NT_BACKWARD];
;	2377		FORWARD_NT = .NT_PTR [NT_FORWARD];
;	2378	
;	2379		!++
;	2380		! Unlink the NT record from its hash chain, i.e. Make the forward
;	2381		! pointer of our back NT record point to the one after us.  Note that
;	2382		! if our back pointer points back to the hash chain, then we are
;	2383		! actually overwriting the RST pointer in that hash chain entry (as we
;	2384		! want to).  This is why NT_FORWARD must be the first 2 bytes of an NT record.
;	2385		!--
;	2386		BACKWARD_NT [NT_FORWARD] = .FORWARD_NT;
;	2387	
;	2388		!++
;	2389		! If we are not at the end of the hash chain, we must connect up the
;	2390		! hole we are making by unlinking this NT record.
;	2391		!--
;	2392		IF (.FORWARD_NT NEQ 0)
;	2393		THEN
;	2394			FORWARD_NT [NT_BACKWARD] = .BACKWARD_NT;
;	2395	
;	2396		!++
;	2397		! Find the next NT record in the vector by adding the overhead bytes
;	2398		! (fixed) for each record to the count bytes for the name.
;	2399		!--
;	2400		NT_PTR = .NT_PTR + RST_NT_OVERHEAD + .NT_PTR [NT_NAME_CS];
;	2401		END;
;	2402	
;	2403	!++
;	2404	! All NT records are successfully unlinked.
;	2405	!--
;	2406	END;





					 001C 0028D UNLINK_NT_RECS:
							    .WORD   Save R2,R3,R4					      ; 2307
		         53 00000000G  EF  D0 0028F 	    MOVL    PAT$GL_RST_BEGN, R3					      ; 2353
	   50	    04   AC	       53  C1 00296 	    ADDL3   R3, MC_PTR, R0					      ;
	   54	         50	       1C  C1 0029B 	    ADDL3   #28, R0, NT_VEC_DESC				      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 7-2
; Digital Equipment Corporation
;
		         50	  01   A4  3C 0029F 	    MOVZWL  1(NT_VEC_DESC), NT_PTR				      ; 2360
      05   A4	         10	       00  ED 002A3 1$:     CMPZV   #0, #16, 5(NT_VEC_DESC), NT_PTR			      ; 2365
				       50     002A8									      ;
				       2C  1B 002A9 	    BLEQU   3$							      ;
				  0A A340  9F 002AB 	    PUSHAB  10(R3)[NT_PTR]					      ; 2376
		         52	       9E  3C 002AF 	    MOVZWL  @(SP)+, BACKWARD_NT					      ;
				     6340  9F 002B2 	    PUSHAB  (R3)[NT_PTR]					      ; 2377
		         51	       9E  3C 002B5 	    MOVZWL  @(SP)+, FORWARD_NT					      ;
				     6342  9F 002B8 	    PUSHAB  (R3)[BACKWARD_NT]					      ; 2386
		         9E	       51  B0 002BB 	    MOVW    FORWARD_NT, @(SP)+					      ;
				       51  D5 002BE 	    TSTL    FORWARD_NT						      ; 2392
				       07  13 002C0 	    BEQL    2$							      ;
				  0A A341  9F 002C2 	    PUSHAB  10(R3)[FORWARD_NT]					      ; 2394
		         9E	       52  B0 002C6 	    MOVW    BACKWARD_NT, @(SP)+					      ;
		         52	  0C A340  9A 002C9 2$:     MOVZBL  12(R3)[NT_PTR], R2					      ; 2400
		         52	       50  C0 002CE 	    ADDL2   NT_PTR, R2						      ;
	   50	         52	       0D  C1 002D1 	    ADDL3   #13, R2, NT_PTR					      ;
				       CC  11 002D5 	    BRB     1$							      ; 2365
					   04 002D7 3$:     RET     							      ; 2307

; Routine Size:  75 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 8
; Digital Equipment Corporation
;
;	2407	ROUTINE EMPTY_SAT_LVT( access_function ) : NOVALUE =
;	2408	
;	2409	!++
;	2410	! Functional Description:
;	2411	!
;	2412	!	Empty out the storage associated with SAT/LVT records
;	2413	!	for all modules in the MC marked MC_IS_DYING,
;	2414	!	(there may be some records therein which belong to another module)
;	2415	!	by moving any valid records therein to storage
;	2416	!	associated with a module that is not being deleted.
;	2417	!	Then release the _DYING storage since the associated modules
;	2418	!	are to be deleted from the RST.
;	2419	!
;	2420	! Formal Parameters:
;	2421	!
;	2422	!	access_function	-The address of the function we should call
;	2423	!			 to access the indicated SAT/LVT structure.
;	2424	!
;	2425	! Implicit Inputs: (assumptions)
;	2426	!
;	2427	!	The SAT_RECORD structure is appropriate for moving SAT/LVT
;	2428	!	records around - i.e. SATs are larger than LVTs - as
;	2429	!	long as we use the record_size value returned by the
;	2430	!	SL_ACCE_INIT call instead of the one associated with
;	2431	!	the SAT record itself.
;	2432	!
;	2433	! Implicit Outputs:
;	2434	!
;	2435	!	The indicated structure is left in the state that LOOKUP_SAT
;	2436	!	and LOOKUP_LVT assume they are in.
;	2437	!
;	2438	! Routine Value:
;	2439	!
;	2440	!	NOVALUE
;	2441	!
;	2442	! Side Effects:
;	2443	!
;	2444	!	The SAT/LVT records marked for deletion are overwritten
;	2445	!	by valid records; all SAT/LVT storage associated with
;	2446	!	MC_IS_DYING modules is released.
;	2447	!--
;	2448	
;	2449	BEGIN
;	2450	
;	2451	LOCAL
;	2452		RECORD_SIZE,						! The number of bytes in each record.
;	2453		!++
;	2454		! Declare a pointer which is suitable for use as a REF SAT_RECORD as
;	2455		! well as a REF LVT_RECORD. This pointer is used to sequentially go thru
;	2456		! vector storage to pick up non-deleted records. We keep two pointers
;	2457		! to the SAT or LVT record currently under consideration.  One, 'current',
;	2458		! is NOT a SAT_POINTER because longword pointers are not easily
;	2459		! comparable to the NT-pointers we get from storage descriptors.  The
;	2460		! other is a   'real' SAT_POINTER which always corresponds to 'current'.
;	2461		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 8-1
; Digital Equipment Corporation
;
;	2462		CURRENT,
;	2463		CURRENT_SAT_PTR : REF SAT_RECORD,
;	2464		NEXT_FREE : REF SAT_RECORD,				! Corresponding to 'current' is a pointer which indicated
;	2465									! where the next free SAT/LVT record is.
;	2466		STORE_DESC : REF VECT_STORE_DESC,			! We look at the vector storage which is allocated
;	2467									! for SAT/LVTs for each _DYING module.
;	2468	
;	2469		END_MARKER,						! Maintain a pointer into the vector storage which
;	2470									! says where the last+1 record associated
;	2471									! with a given module starts.
;	2472		MC_PTR : REF MC_RECORD,					! We scan the MC to pick out all _DYING modules.
;	2473		MOVED_COUNT;						! Tally up how many records we move.
;	2474	
;	2475	!++
;	2476	! Set up to access the structure in the mode which we get told of FREE records
;	2477	! only, so that we can deduce where to store the still-used ones we have to remove
;	2478	! from the _DYING storage.  While we're at it pick up the size of the indicated
;	2479	! fixed-size records.
;	2480	!--
;	2481	RECORD_SIZE = (.access_function)(SL_ACCE_INIT);
;	2482	
;	2483	!++
;	2484	! Scan the module chain to pick up all modules marked as _DYING.  They are the
;	2485	! ones that we have to clean-up and release storage for. We purposely don't ever
;	2486	! look at the MC record allocated to globals since it never _IS_DYING.
;	2487	!--
;	2488	MC_PTR = .PAT$GL_MC_PTR;
;	2489	WHILE( (MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0 )
;	2490	DO
;	2491		BEGIN
;	2492		!++
;	2493		! We only consider _DYING modules.  The _DYING flag is meaningless if
;	2494		! the module is not _IN_RST.
;	2495		!--
;	2496		IF (.MC_PTR [MC_IN_RST] AND .MC_PTR [MC_IS_DYING])
;	2497		THEN
;	2498			BEGIN
;	2499			!++
;	2500			! For each module we have to look at the vector storage
;	2501			! which corresponds to the records we are to clean up.
;	2502			!--
;	2503			STORE_DESC = (IF (.access_function EQL PAT$GET_NXT_SAT)
;	2504				      THEN MC_PTR [MC_SAT_STORAGE]
;	2505				      ELSE MC_PTR [MC_LVT_STORAGE]);
;	2506	
;	2507			!++
;	2508			! The records that we want to move are those within the
;	2509			! bounds defined by the _DYING module that are not
;	2510			! already marked for deletion.  We go thru this storage
;	2511			! using and comparing RST-pointers, and build a corresponding
;	2512			! SAT-pointer when we want to use it.
;	2513			!--
;	2514			END_MARKER = .STORE_DESC [STOR_MARKER];
;	2515			IF ((CURRENT = .STORE_DESC [STOR_BEGIN_RST]) EQL 0)
;	2516			THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 8-2
; Digital Equipment Corporation
;
;	2517				!++
;	2518				! No vector storage is allocated for this module
;	2519				! for this kind of storage.  Simply fake having
;	2520				! come to the end of the storage.
;	2521				!--
;	2522				CURRENT = .END_MARKER;
;	2523			WHILE( .CURRENT LSSA .END_MARKER )
;	2524				DO
;	2525				BEGIN
;	2526				!++
;	2527				! Construct a SAT pointer to correspond to the
;	2528				! current place in the storage vector.
;	2529				!--
;	2530				CURRENT_SAT_PTR = .CURRENT + .PAT$GL_RST_BEGN;
;	2531	
;	2532				!++
;	2533				! We only want to deal with records not marked for
;	2534				! deletion.
;	2535				!--
;	2536				IF (.CURRENT_SAT_PTR [SAT_NT_PTR] NEQ 1)
;	2537				THEN
;	2538					BEGIN
;	2539					!++
;	2540					! See if there is some place to put this record.
;	2541					!--
;	2542					IF ((NEXT_FREE = (.access_function)(SL_ACCE_FREE)) EQL 0)
;	2543					THEN
;	2544						BEGIN
;	2545						!++
;	2546						! This should never happen because the
;	2547						! storage for a given module should be 
;	2548						! big enough to contain all SATs/LVTs for
;	2549						! that module.  If this is the number of
;	2550						! records marked for deletion, any real
;	2551						! records left herein should correspond to
;	2552						! outside records now marked for deletion.
;	2553						!--
;	2554						$FAO_TT_OUT('!/empty free storage error');
;	2555						RETURN;
;	2556						END;
;	2557	
;	2558					!++
;	2559					! Move the valid record to a safe place.
;	2560					!--
;	2561					CH$MOVE( .record_size, .CURRENT_SAT_PTR, .NEXT_FREE );
;	2562					END;
;	2563	
;	2564				!++
;	2565				! Go back to look at the next record in the
;	2566				! current vector storage.
;	2567				!--
;	2568				CURRENT = .CURRENT + .RECORD_SIZE;
;	2569				END;
;	2570	
;	2571			!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 8-3
; Digital Equipment Corporation
;
;	2572			! All records are now moved to a safe place so we 
;	2573			! can free up the associated vector storage.
;	2574			!--
;	2575			PAT$VS_FREE( .STORE_DESC );
;	2576			END;						! Go back to consider the next _DYING module.
;	2577		END;							! Go back and consider the next module in the chain.
;	2578	
;	2579	!++
;	2580	! All SAT/LVT storage has been freed up - we still have to leave what's left in
;	2581	! order so that the accessing functions can use them.  (LOOKUP_SAT/LVT)
;	2582	! PAT$SORT_SA_LVT believes MC_IN_RST which is at this point untrue, but since
;	2583	! the associated storage descriptor has been zeroed out, the accessing function
;	2584	! will work OK.
;	2585	!--
;	2586	PAT$SORT_SA_LVT( .access_function );
;	2587	
;	2588	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .BYTE   26							      ;
					      00001 	    .ASCII  \!/empty free storage error\			      ;
					      0001B	    .BLKB   1



							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 002D8 EMPTY_SAT_LVT:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11		      ; 2407
		         5E	       04  C2 002DA 	    SUBL2   #4, SP						      ;
				       7E  D4 002DD 	    CLRL    -(SP)						      ; 2481
		    04   BC	       01  FB 002DF 	    CALLS   #1, @ACCESS_FUNCTION				      ;
		         59	       50  D0 002E3 	    MOVL    R0, RECORD_SIZE					      ;
		         58 00000000G  EF  D0 002E6 	    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 2488
	   50	         58 00000000G  EF  C1 002ED 1$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2489
		         58	       60  3C 002F5 	    MOVZWL  (R0), MC_PTR					      ;
				       76  13 002F8 	    BEQL    8$							      ;
	   50	         58 00000000G  EF  C1 002FA 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2496
	   E6	    03   A0	       01  E1 00302 	    BBC     #1, 3(R0), 1$					      ;
	   E1	    03   A0	       06  E1 00307 	    BBC     #6, 3(R0), 1$					      ;
		         51	FCF0   CF  9E 0030C 	    MOVAB   PAT$GET_NXT_SAT, R1					      ; 2503
		         51	  04   AC  D1 00311 	    CMPL    ACCESS_FUNCTION, R1					      ;
				       06  12 00315 	    BNEQ    2$							      ;
	   56	         50	       23  C1 00317 	    ADDL3   #35, R0, STORE_DESC					      ; 2504
				       04  11 0031B 	    BRB     3$							      ; 2503
	   56	         50	       2A  C1 0031D 2$:     ADDL3   #42, R0, STORE_DESC					      ; 2505
		         6E	  05   A6  3C 00321 3$:     MOVZWL  5(STORE_DESC), END_MARKER				      ; 2514
		         57	  01   A6  3C 00325 	    MOVZWL  1(STORE_DESC), CURRENT				      ; 2515
				       03  12 00329 	    BNEQ    4$							      ;
		         57	       6E  D0 0032B 	    MOVL    END_MARKER, CURRENT					      ; 2522
		         6E	       57  D1 0032E 4$:     CMPL    CURRENT, END_MARKER					      ; 2523
				       31  1E 00331 	    BGEQU   7$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 8-4
; Digital Equipment Corporation
;
	   5A	         57 00000000G  EF  C1 00333 	    ADDL3   PAT$GL_RST_BEGN, CURRENT, CURRENT_SAT_PTR		      ; 2530
		         01	       6A  B1 0033B 	    CMPW    (CURRENT_SAT_PTR), #1				      ; 2536
				       1F  13 0033E 	    BEQL    6$							      ;
				       03  DD 00340 	    PUSHL   #3							      ; 2542
		    04   BC	       01  FB 00342 	    CALLS   #1, @ACCESS_FUNCTION				      ;
		         5B	       50  D0 00346 	    MOVL    R0, NEXT_FREE					      ;
				       10  12 00349 	    BNEQ    5$							      ;
				       7E  D4 0034B 	    CLRL    -(SP)						      ; 2554
			    00000000'  EF  9F 0034D 	    PUSHAB  P.AAA						      ;
	      00000000G  EF	       02  FB 00353 	    CALLS   #2, PAT$FAO_OUT					      ;
					   04 0035A 	    RET     							      ; 2555
	   6B	         6A	       59  28 0035B 5$:     MOVC3   RECORD_SIZE, (CURRENT_SAT_PTR), (NEXT_FREE)		      ; 2561
		         57	       59  C0 0035F 6$:     ADDL2   RECORD_SIZE, CURRENT				      ; 2568
				       CA  11 00362 	    BRB     4$							      ; 2523
				       56  DD 00364 7$:     PUSHL   STORE_DESC						      ; 2575
	      00000000G  EF	       01  FB 00366 	    CALLS   #1, PAT$VS_FREE					      ;
				     FF7D  31 0036D 	    BRW     1$							      ; 2489
				  04   AC  DD 00370 8$:     PUSHL   ACCESS_FUNCTION					      ; 2586
	      00000000V  EF	       01  FB 00373 	    CALLS   #1, PAT$SORT_SA_LVT					      ;
					   04 0037A 	    RET     							      ; 2407

; Routine Size:  163 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9
; Digital Equipment Corporation
;
;	2589	GLOBAL ROUTINE PAT$SORT_SA_LVT( ACCESS_FUNCTION ) : NOVALUE =
;	2590	
;	2591	!++
;	2592	! Functional Description:
;	2593	!
;	2594	!	This routine is an unspeakably inefficient, (shell) sort
;	2595	!	suitable to sort either the LVT or the SAT into ascending order.
;	2596	!	It is necessary because access to the LVT or SAT assumes that
;	2597	!	it has been done.
;	2598	!
;	2599	! Formal Parameters:
;	2600	!
;	2601	!	ACCESS_FUNCTION -The function which must be called to
;	2602	!			 gain sequential access to the SAT or LVT.
;	2603	!
;	2604	! Implicit Inputs: (assumptions)
;	2605	!
;	2606	!	SATs/LVTs are accessed via longword pointers, vector
;	2607	!	storage descriptors contain RST-pointers, and CH$MOVE
;	2608	!	works with the same kind of pointer as SAT_POINTER does.
;	2609	!
;	2610	!	The SAT_RECORD structure is appropriate for either type of
;	2611	!	vector providing that we only use the _NT_PTR and _LB fields.
;	2612	!
;	2613	!	A temporary SAT record is large enough to contain an LVT record.
;	2614	!
;	2615	!	The sort is on the _LB field, which corresponds to the _VALUE
;	2616	!	field in LVT records.  The comparison is UNSIGNED.
;	2617	!
;	2618	! Implicit Outputs:
;	2619	!
;	2620	!	None.
;	2621	!
;	2622	! Routine Value:
;	2623	!
;	2624	!	NOVALUE
;	2625	!
;	2626	! Side Effects:
;	2627	!
;	2628	!	The SAT/LVT vector is sorted into ascending order.
;	2629	!
;	2630	!	This routine knows the difference between RST pointers and 'real'
;	2631	!	pointers.  (The former are stored in VECT_STORE_DESCS and the latter
;	2632	!	are used to reference SAT/LVT structures.)
;	2633	!--
;	2634	
;	2635	BEGIN
;	2636	
;	2637	LABEL
;	2638		INIT_LOOP,
;	2639		SORT_LOOP;
;	2640	
;	2641	LOCAL
;	2642		MC_PTR : REF MC_RECORD,					! Current module pointer
;	2643		STORE_DESC : REF VECT_STORE_DESC,			! Storage within the current module

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9-1
; Digital Equipment Corporation
;
;	2644		NXT_MC_PTR : REF MC_RECORD,				! Pointer to next module
;	2645		NXT_STORE_DESC : REF VECT_STORE_DESC,			! Storage within the next module
;	2646		SAT_FLAG,						! 1=SAT, 0=LVT SORT
;	2647		ELEMENT_SIZE,						! The number of bytes in a SAT/LVT record.
;	2648		REC_PTR : REF SAT_RECORD;				! Declare a pointer which is suitable for use as
;	2649									! a REF SAT_RECORD as well as a REF LVT_RECORD.
;	2650									! This pointer is used to sequentially go thru
;	2651									! the indicated vector to do the sort.
;	2652	
;	2653	!++
;	2654	! The (shell) sort works by going thru the vector sequentially, considering
;	2655	! each element, finding the minimum of those which are left, and swapping
;	2656	! this minimum with the current one if such a minimum can be found.
;	2657	!
;	2658	! REC_PTR points to the record currently under consideration.
;	2659	! MIN_PTR points to the smallest one of those left.
;	2660	! TMP_PTR is used to deduce what MIN_PTR should be.
;	2661	!
;	2662	! Set up to begin accessing the LVT or SAT.
;	2663	!--
;	2664	ELEMENT_SIZE = (.ACCESS_FUNCTION)( SL_ACCE_INIT );
;	2665	SAT_FLAG = .ACCESS_FUNCTION EQL PAT$GET_NXT_SAT;
;	2666	MC_PTR = .PAT$GL_MC_PTR;
;	2667	REPEAT
;	2668	    INIT_LOOP:
;	2669		BEGIN
;	2670		!++
;	2671		!  Check for the end of the module chain.
;	2672		!--
;	2673		IF (.MC_PTR EQL 0)
;	2674		THEN
;	2675			!++
;	2676			! The SAT/LVT structure is completely empty.  This is not a
;	2677			! sort error.
;	2678			!--
;	2679			RETURN(TRUE);
;	2680	
;	2681		!++
;	2682		! The current module is to be ignored if the user has not brought it
;	2683		! into the RST.
;	2684		!--
;	2685		IF NOT .MC_PTR[MC_IN_RST]
;	2686		THEN
;	2687			BEGIN
;	2688			MC_PTR = .MC_PTR[MC_NEXT];
;	2689			LEAVE INIT_LOOP;
;	2690			END;
;	2691	
;	2692		!++
;	2693		! Check if this module has any of the kind of storage sought.
;	2694		! No storage is allocated if the "BEGIN" field is null.
;	2695		!--
;	2696		STORE_DESC = (IF .SAT_FLAG
;	2697			      THEN MC_PTR[MC_SAT_STORAGE]
;	2698			      ELSE MC_PTR[MC_LVT_STORAGE]);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9-2
; Digital Equipment Corporation
;
;	2699		IF (.STORE_DESC[STOR_BEGIN_RST] EQL 0)
;	2700		THEN
;	2701			BEGIN
;	2702			MC_PTR = .MC_PTR[MC_NEXT];
;	2703			LEAVE INIT_LOOP;
;	2704			END;
;	2705	
;	2706		!++
;	2707		! The first SAT/LVT record has been found.  Discontinue looping.
;	2708		!--
;	2709		REC_PTR = .STORE_DESC[STOR_BEGIN_RST] + .PAT$GL_RST_BEGN;
;	2710		EXITLOOP;
;	2711		END;
;	2712	!++
;	2713	! There is at least one record in the logical SAT/LVT structure.  Now loop
;	2714	! to actually do the sort.
;	2715	!--
;	2716	REPEAT
;	2717		BEGIN
;	2718		LABEL
;	2719			MIN_LOOP;
;	2720		LOCAL
;	2721			NXT_STORE : REF VECT_STORE_DESC,
;	2722			TMP_STORE : REF VECT_STORE_DESC,
;	2723			FIRST_FLAG,
;	2724			NXT_MC_PTR : REF MC_RECORD,
;	2725			TMP_MC_PTR : REF MC_RECORD,
;	2726			MIN_PTR	: REF SAT_RECORD,
;	2727			NXT_PTR,
;	2728			TMP_PTR;
;	2729		TMP_PTR = .REC_PTR - .PAT$GL_RST_BEGN;
;	2730		MIN_PTR = .REC_PTR;
;	2731		!++
;	2732		! Find the minimum of those left.
;	2733		!--
;	2734		FIRST_FLAG = TRUE;
;	2735		TMP_MC_PTR = .MC_PTR;
;	2736		TMP_STORE = .STORE_DESC;
;	2737	
;	2738		REPEAT
;	2739		    MIN_LOOP:
;	2740			BEGIN
;	2741			LOCAL
;	2742				TMP_SAT_PTR : REF SAT_RECORD;
;	2743	
;	2744			IF (.TMP_PTR EQL 0)
;	2745			THEN
;	2746				BEGIN
;	2747				!++
;	2748				! The next record must come from the next module in
;	2749				! the chain.
;	2750				!--
;	2751				IF ((TMP_MC_PTR = .TMP_MC_PTR[MC_NEXT]) EQL 0)
;	2752				THEN
;	2753					EXITLOOP;			! No more for min search

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9-3
; Digital Equipment Corporation
;
;	2754				IF NOT .TMP_MC_PTR[MC_IN_RST]
;	2755				THEN
;	2756					LEAVE MIN_LOOP;
;	2757	
;	2758				!++
;	2759				! Check if this module has any of the kind of storage
;	2760				! sought.  No storage is allocated if the "BEGIN" field
;	2761				! is null.
;	2762				!--
;	2763				TMP_STORE = (IF .SAT_FLAG
;	2764					     THEN TMP_MC_PTR[MC_SAT_STORAGE]
;	2765					     ELSE TMP_MC_PTR[MC_LVT_STORAGE]);
;	2766				IF (.TMP_STORE[STOR_BEGIN_RST] EQL 0)
;	2767				THEN
;	2768					LEAVE MIN_LOOP;
;	2769				TMP_PTR = .TMP_STORE[STOR_BEGIN_RST];
;	2770				IF .FIRST_FLAG
;	2771				THEN
;	2772					BEGIN
;	2773					NXT_PTR = 0;
;	2774					NXT_STORE = .TMP_STORE;
;	2775					NXT_MC_PTR = .TMP_MC_PTR;
;	2776					END
;	2777				END
;	2778			ELSE
;	2779				IF NOT ((TMP_PTR = .TMP_PTR + .ELEMENT_SIZE) LSSA
;	2780					(.TMP_STORE[STOR_MARKER]))
;	2781				THEN
;	2782					BEGIN
;	2783					TMP_PTR = 0;
;	2784					LEAVE MIN_LOOP;
;	2785					END
;	2786				ELSE
;	2787					IF .FIRST_FLAG
;	2788					THEN
;	2789						NXT_PTR = .TMP_PTR;
;	2790				!++
;	2791				! Check if a new minimum has been found.
;	2792				!--
;	2793				TMP_SAT_PTR = .TMP_PTR + .PAT$GL_RST_BEGN;
;	2794				IF (.TMP_SAT_PTR[SAT_LB] LSSA .MIN_PTR[SAT_LB])
;	2795				THEN
;	2796					MIN_PTR = .TMP_SAT_PTR;	! A NEW MINIMUM WAS FOUND
;	2797				FIRST_FLAG = FALSE;
;	2798				END;					! End of MIN_LOOP
;	2799			!++
;	2800			! If no "NEXT" pointer was found above, there were no more
;	2801			! records to search.
;	2802			!--
;	2803			IF .FIRST_FLAG
;	2804			THEN
;	2805				EXITLOOP;
;	2806	
;	2807		!++
;	2808		! If the minimum has not changed, having started out as the current

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9-4
; Digital Equipment Corporation
;
;	2809		! one, then we do nothing except go on to the next element in the
;	2810		! vector.  Otherwise we swap the minimum with the current so that we
;	2811		! can then go on to the next anyway.
;	2812		!--
;	2813		IF (.MIN_PTR NEQ .REC_PTR)
;	2814		THEN
;	2815			BEGIN
;	2816			LOCAL
;	2817				TMP_RECORD : SAT_RECORD;
;	2818	
;	2819			!++
;	2820			! Swap the old current one with the new minimum.
;	2821			!--
;	2822			CH$MOVE( .ELEMENT_SIZE, .REC_PTR, TMP_RECORD );
;	2823			CH$MOVE( .ELEMENT_SIZE, .MIN_PTR, .REC_PTR );
;	2824			CH$MOVE( .ELEMENT_SIZE, TMP_RECORD, .MIN_PTR );
;	2825			END;
;	2826	
;	2827		!++
;	2828		! Update the "CURRENT" record by effectively going back to the first
;	2829		! "NEXT" record found above.
;	2830		!--
;	2831		IF ((REC_PTR = .NXT_PTR) EQL 0)
;	2832		THEN
;	2833			BEGIN
;	2834			MC_PTR = .NXT_MC_PTR;
;	2835			STORE_DESC = .NXT_STORE;
;	2836			REC_PTR = .STORE_DESC[STOR_BEGIN_RST];
;	2837			END;
;	2838		REC_PTR = .REC_PTR + .PAT$GL_RST_BEGN;
;	2839		END;							! End of outer loop
;	2840	
;	2841	!++
;	2842	! At this point the vector is sorted into ascending order.
;	2843	!--
;	2844	RETURN(TRUE);
;	2845	END;





					 0FFC 0037B 	    .ENTRY  PAT$SORT_SA_LVT, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 2589
		         5E	       1C  C2 0037D 	    SUBL2   #28, SP						      ;
				       7E  D4 00380 	    CLRL    -(SP)						      ; 2664
		    04   BC	       01  FB 00382 	    CALLS   #1, @ACCESS_FUNCTION				      ;
		         6E	       50  D0 00386 	    MOVL    R0, ELEMENT_SIZE					      ;
		         51	FC73   CF  9E 00389 	    MOVAB   PAT$GET_NXT_SAT, R1					      ; 2665
				       50  D4 0038E 	    CLRL    R0							      ;
		         51	  04   AC  D1 00390 	    CMPL    ACCESS_FUNCTION, R1					      ;
				       02  12 00394 	    BNEQ    1$							      ;
				       50  D6 00396 	    INCL    R0							      ;
		    0C   AE	       50  D0 00398 1$:     MOVL    R0, SAT_FLAG					      ;
		         56 00000000G  EF  D0 0039C 	    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 2666
		         57 00000000G  EF  D0 003A3 	    MOVL    PAT$GL_RST_BEGN, R7					      ; 2685

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9-5
; Digital Equipment Corporation
;
				       56  D5 003AA 2$:     TSTL    MC_PTR						      ; 2673
				       01  12 003AC 	    BNEQ    3$							      ;
					   04 003AE 	    RET     							      ;
	   18	    03 A746	       01  E1 003AF 3$:     BBC     #1, 3(R7)[MC_PTR], 6$				      ; 2685
		         07	  0C   AE  E9 003B5 	    BLBC    SAT_FLAG, 4$					      ; 2696
		         59	  23 A746  9E 003B9 	    MOVAB   35(R7)[MC_PTR], STORE_DESC				      ; 2697
				       05  11 003BE 	    BRB     5$							      ; 2696
		         59	  2A A746  9E 003C0 4$:     MOVAB   42(R7)[MC_PTR], STORE_DESC				      ; 2698
				  01   A9  B5 003C5 5$:     TSTW    1(STORE_DESC)					      ; 2699
				       03  13 003C8 	    BEQL    6$							      ;
				     009C  31 003CA 	    BRW     17$							      ;
				     6746  9F 003CD 6$:     PUSHAB  (R7)[MC_PTR]					      ; 2702
		         56	       9E  3C 003D0 	    MOVZWL  @(SP)+, MC_PTR					      ;
				       D5  11 003D3 	    BRB     2$							      ; 2703
	   53	         5A	       57  C3 003D5 7$:     SUBL3   R7, REC_PTR, TMP_PTR				      ; 2729
		         58	       5A  D0 003D9 	    MOVL    REC_PTR, MIN_PTR					      ; 2730
		         54	       01  D0 003DC 	    MOVL    #1, FIRST_FLAG					      ; 2734
		         50	       56  D0 003DF 	    MOVL    MC_PTR, TMP_MC_PTR					      ; 2735
		         51	       59  D0 003E2 	    MOVL    STORE_DESC, TMP_STORE				      ; 2736
				       53  D5 003E5 8$:     TSTL    TMP_PTR						      ; 2744
				       36  12 003E7 	    BNEQ    11$							      ;
				     6740  9F 003E9 	    PUSHAB  (R7)[TMP_MC_PTR]					      ; 2751
		         50	       9E  3C 003EC 	    MOVZWL  @(SP)+, TMP_MC_PTR					      ;
				       55  13 003EF 	    BEQL    15$							      ;
	   EE	    03 A740	       01  E1 003F1 	    BBC     #1, 3(R7)[TMP_MC_PTR], 8$				      ; 2754
		         07	  0C   AE  E9 003F7 	    BLBC    SAT_FLAG, 9$					      ; 2763
		         51	  23 A740  9E 003FB 	    MOVAB   35(R7)[TMP_MC_PTR], TMP_STORE			      ; 2764
				       05  11 00400 	    BRB     10$							      ; 2763
		         51	  2A A740  9E 00402 9$:     MOVAB   42(R7)[TMP_MC_PTR], TMP_STORE			      ; 2765
				  01   A1  B5 00407 10$:    TSTW    1(TMP_STORE)					      ; 2766
				       D9  13 0040A 	    BEQL    8$							      ;
		         53	  01   A1  3C 0040C 	    MOVZWL  1(TMP_STORE), TMP_PTR				      ; 2769
		         21	       54  E9 00410 	    BLBC    FIRST_FLAG, 13$					      ; 2770
				       5B  D4 00413 	    CLRL    NXT_PTR						      ; 2773
		    04   AE	       51  D0 00415 	    MOVL    TMP_STORE, NXT_STORE				      ; 2774
		    08   AE	       50  D0 00419 	    MOVL    TMP_MC_PTR, NXT_MC_PTR				      ; 2775
				       15  11 0041D 	    BRB     13$							      ; 2744
		         53	       6E  C0 0041F 11$:    ADDL2   ELEMENT_SIZE, TMP_PTR				      ; 2779
      05   A1	         10	       00  ED 00422 	    CMPZV   #0, #16, 5(TMP_STORE), TMP_PTR			      ;
				       53     00427									      ;
				       04  1A 00428 	    BGTRU   12$							      ;
				       53  D4 0042A 	    CLRL    TMP_PTR						      ; 2783
				       B7  11 0042C 	    BRB     8$							      ; 2784
		         03	       54  E9 0042E 12$:    BLBC    FIRST_FLAG, 13$					      ; 2787
		         5B	       53  D0 00431 	    MOVL    TMP_PTR, NXT_PTR					      ; 2789
	   52	         53	       57  C1 00434 13$:    ADDL3   R7, TMP_PTR, TMP_SAT_PTR				      ; 2793
		    02   A8	  02   A2  D1 00438 	    CMPL    2(TMP_SAT_PTR), 2(MIN_PTR)				      ; 2794
				       03  1E 0043D 	    BGEQU   14$							      ;
		         58	       52  D0 0043F 	    MOVL    TMP_SAT_PTR, MIN_PTR				      ; 2796
				       54  D4 00442 14$:    CLRL    FIRST_FLAG						      ; 2797
				       9F  11 00444 	    BRB     8$							      ; 2736
		         2A	       54  E8 00446 15$:    BLBS    FIRST_FLAG, 19$					      ; 2803
		         5A	       58  D1 00449 	    CMPL    MIN_PTR, REC_PTR					      ; 2813
				       0E  13 0044C 	    BEQL    16$							      ;
      10   AE	         6A	       6E  28 0044E 	    MOVC3   ELEMENT_SIZE, (REC_PTR), TMP_RECORD			      ; 2822

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 9-6
; Digital Equipment Corporation
;
	   6A	         68	       6E  28 00453 	    MOVC3   ELEMENT_SIZE, (MIN_PTR), (REC_PTR)			      ; 2823
	   68	    10   AE	       6E  28 00457 	    MOVC3   ELEMENT_SIZE, TMP_RECORD, (MIN_PTR)			      ; 2824
		         5A	       5B  D0 0045C 16$:    MOVL    NXT_PTR, REC_PTR					      ; 2831
				       0C  12 0045F 	    BNEQ    18$							      ;
		         56	  08   AE  D0 00461 	    MOVL    NXT_MC_PTR, MC_PTR					      ; 2834
		         59	  04   AE  D0 00465 	    MOVL    NXT_STORE, STORE_DESC				      ; 2835
		         5A	  01   A9  3C 00469 17$:    MOVZWL  1(STORE_DESC), REC_PTR				      ; 2836
		         5A	       57  C0 0046D 18$:    ADDL2   R7, REC_PTR						      ; 2838
				     FF62  31 00470 	    BRW     7$							      ; 2711
					   04 00473 19$:    RET     							      ; 2589

; Routine Size:  249 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 10
; Digital Equipment Corporation
;
;	2846	ROUTINE DELE_SAT_LVT( STORE_DESC_ADDR, ACCESS_FUNCTION ) =
;	2847	
;	2848	!++
;	2849	! Functional Description:
;	2850	!
;	2851	!	This routine deletes records from the LVT or SAT
;	2852	!	vector it is given a pointer to (VEC_PTR).  The
;	2853	!	records that are deleted are those that correspond
;	2854	!	(point) to an indicated module (STORE_DESC_ADDR).
;	2855	!	The correspondence is discovered by seeing if the
;	2856	!	NT_PTR in a given LVT/SAT record lies within the
;	2857	!	RST storage for the NTs for the indicated module.
;	2858	!	This is faster than actually following the scope
;	2859	!	chains of the pointed-to NT records to see if 
;	2860	!	they belong to the indicated module.
;	2861	!
;	2862	! Formal Parameters:
;	2863	!
;	2864	!	STORE_DESC_ADDR	-The address of the storage vector descriptor
;	2865	!			 which completely describes the NT storage
;	2866	!			 for the indicated module.
;	2867	!	ACCESS_FUNCTION	-The name of the function to call to 
;	2868	!			 access the indicated structure.
;	2869	!
;	2870	! Implicit Inputs: (assumptions)
;	2871	!
;	2872	!	We assume that direct comparisons of RST pointers
;	2873	!	is valid.  (i.e. that "begin < ptr < end" is a valid
;	2874	!	test of whether 'ptr' RST-points to somewhere inbetween
;	2875	!	where 'begin' and 'end' RST-point.
;	2876	!
;	2877	! Implicit Outputs:
;	2878	!
;	2879	!	None.
;	2880	!
;	2881	! Routine Value:
;	2882	!
;	2883	!	The number of records which are marked for deletion
;	2884	!	in the indicated structure.
;	2885	!
;	2886	! Side Effects:
;	2887	!
;	2888	!	Records are 'deleted' from the SAT/LVT vector.
;	2889	!	Really, this only means that the indicated records
;	2890	!	are marked with their NT_PTR = 1.  More processing
;	2891	!	of this structure is necessary before it is usable,
;	2892	!	but it is better to do this processing only once
;	2893	!	if several modules are to be deleted from the RST.
;	2894	!--
;	2895	
;	2896	BEGIN
;	2897	
;	2898	MAP
;	2899		STORE_DESC_ADDR : REF VECT_STORE_DESC;			! Storage descriptor for the NTs.
;	2900	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 10-1
; Digital Equipment Corporation
;
;	2901	LOCAL
;	2902		GLOBALS : REF VECT_STORE_DESC,				! We pick up a storage descriptor for GLOBALS.
;	2903		DELETE_COUNT,						! Tally up how many records we delete.
;	2904		REC_PTR : REF SAT_RECORD,				! Declare a pointer which is suitable for use as
;	2905									! a REF SAT_RECORD as well as a REF LVT_RECORD.
;	2906									! This pointer is used to sequentially go thru
;	2907									! the indicated vector.
;	2908		NT_BEGINS : REF NT_RECORD,				! NT storage RST limits.
;	2909		NT_ENDS   : REF NT_RECORD,
;	2910		GL_NTS_BEGIN : REF NT_RECORD,
;	2911		GL_NTS_END   : REF NT_RECORD;
;	2912	
;	2913	!++
;	2914	! We tally up the number of records which we mark
;	2915	! for deletion so that we can return this value.
;	2916	!--
;	2917	DELETE_COUNT = 0;
;	2918	
;	2919	!++
;	2920	! Pick up the RST limit pointers of where the associated NT records exist,
;	2921	! and where the  global NT records exist.
;	2922	!--
;	2923	GLOBALS = PAT$GL_MC_PTR [MC_NT_STORAGE];
;	2924	NT_BEGINS = .STORE_DESC_ADDR [STOR_BEGIN_RST];
;	2925	NT_ENDS = .STORE_DESC_ADDR [STOR_END_RST];
;	2926	GL_NTS_BEGIN = .GLOBALS [STOR_BEGIN_RST];
;	2927	GL_NTS_END = .GLOBALS [STOR_END_RST];
;	2928	
;	2929	!++
;	2930	! Go thru the structure sequentially checking for records to mark as deleted.
;	2931	!--
;	2932	(.ACCESS_FUNCTION)( SL_ACCE_INIT );
;	2933	WHILE( (REC_PTR = (.ACCESS_FUNCTION)( SL_ACCE_RECS )) NEQ 0 )
;	2934	DO
;	2935		BEGIN
;	2936		!++
;	2937		! Delete the record if it points to an NT record
;	2938		! in the storage for the indicated module.
;	2939		!--
;	2940		IF (.REC_PTR [SAT_NT_PTR] GEQA .NT_BEGINS) AND 
;	2941		   (.REC_PTR [SAT_NT_PTR] LSSA .NT_ENDS)
;	2942		THEN
;	2943			BEGIN
;	2944			!++
;	2945			! Actually, we can only mark it for deletion because it is much
;	2946			! more efficient to compress the entire structure only once.
;	2947			!--
;	2948			DELETE_COUNT = .DELETE_COUNT +1;
;	2949			REC_PTR [SAT_NT_PTR] = 1;
;	2950			END
;	2951		ELSE
;	2952		!++
;	2953		! If that didn't detect something to delete, we must also see if we are
;	2954		! deleting global literals since they must go away too.
;	2955		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 10-2
; Digital Equipment Corporation
;
;	2956		IF (.ACCESS_FUNCTION EQL PAT$GET_NXT_LVT)
;	2957		THEN
;	2958			IF (.REC_PTR [SAT_NT_PTR] GEQA .GL_NTS_BEGIN) AND
;	2959			    (.REC_PTR [SAT_NT_PTR] LSSA .GL_NTS_END)
;	2960			THEN
;	2961				BEGIN
;	2962				DELETE_COUNT = .DELETE_COUNT +1;
;	2963				REC_PTR [SAT_NT_PTR] = 1;
;	2964				END;
;	2965			END;						! Loop back to consider the next record.
;	2966	
;	2967	!++
;	2968	
;	2969	! Return the number of records which we  have marked for deletion.
;	2970	!--
;	2971	RETURN(.DELETE_COUNT);
;	2972	END;





					 00FC 00474 DELE_SAT_LVT:
							    .WORD   Save R2,R3,R4,R5,R6,R7				      ; 2846
				       53  D4 00476 	    CLRL    DELETE_COUNT					      ; 2917
	   50 00000000G  EF 00000000G  EF  C1 00478 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R0			      ; 2923
	   51	         50	       1C  C1 00484 	    ADDL3   #28, R0, GLOBALS					      ;
		         50	  04   AC  D0 00488 	    MOVL    STORE_DESC_ADDR, R0					      ; 2924
		         57	  01   A0  3C 0048C 	    MOVZWL  1(R0), NT_BEGINS					      ;
		         54	  03   A0  3C 00490 	    MOVZWL  3(R0), NT_ENDS					      ; 2925
		         55	  01   A1  3C 00494 	    MOVZWL  1(GLOBALS), GL_NTS_BEGIN				      ; 2926
		         56	  03   A1  3C 00498 	    MOVZWL  3(GLOBALS), GL_NTS_END				      ; 2927
				       7E  D4 0049C 	    CLRL    -(SP)						      ; 2932
		    08   BC	       01  FB 0049E 	    CALLS   #1, @ACCESS_FUNCTION				      ;
				       01  DD 004A2 1$:     PUSHL   #1							      ; 2933
		    08   BC	       01  FB 004A4 	    CALLS   #1, @ACCESS_FUNCTION				      ;
		         52	       50  D0 004A8 	    MOVL    R0, REC_PTR						      ;
				       2E  13 004AB 	    BEQL    4$							      ;
	   62	         10	       00  ED 004AD 	    CMPZV   #0, #16, (REC_PTR), NT_BEGINS			      ; 2940
				       57     004B1									      ;
				       07  1F 004B2 	    BLSSU   2$							      ;
	   62	         10	       00  ED 004B4 	    CMPZV   #0, #16, (REC_PTR), NT_ENDS				      ; 2941
				       54     004B8									      ;
				       19  1F 004B9 	    BLSSU   3$							      ;
		         50	FB50   CF  9E 004BB 2$:     MOVAB   PAT$GET_NXT_LVT, R0					      ; 2956
		         50	  08   AC  D1 004C0 	    CMPL    ACCESS_FUNCTION, R0					      ;
				       DC  12 004C4 	    BNEQ    1$							      ;
	   62	         10	       00  ED 004C6 	    CMPZV   #0, #16, (REC_PTR), GL_NTS_BEGIN			      ; 2958
				       55     004CA									      ;
				       D5  1F 004CB 	    BLSSU   1$							      ;
	   62	         10	       00  ED 004CD 	    CMPZV   #0, #16, (REC_PTR), GL_NTS_END			      ; 2959
				       56     004D1									      ;
				       CE  1E 004D2 	    BGEQU   1$							      ;
				       53  D6 004D4 3$:     INCL    DELETE_COUNT					      ; 2962
		         62	       01  B0 004D6 	    MOVW    #1, (REC_PTR)					      ; 2963

; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 10-3
; Digital Equipment Corporation
;
				       C7  11 004D9 	    BRB     1$							      ; 2933
		         50	       53  D0 004DB 4$:     MOVL    DELETE_COUNT, R0					      ; 2971
					   04 004DE 	    RET     							      ; 2846

; Routine Size:  107 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:35:40	DBB3:[PATCH.SRC]PATREB.B32;2					Page 11
; Digital Equipment Corporation
;
;	2973	END								! End of module
;	2974	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$CODE      	  1247  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$OWN       	     8    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	    28  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582         3         0       222





; Size:		1247 code + 36 data bytes
; Run Time:	00:47.7
; Elapsed Time:	01:38.7
; Memory Used:	372 pages
; Compilation Complete
