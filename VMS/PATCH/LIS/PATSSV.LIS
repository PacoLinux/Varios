
; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATSSV (
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.16') =
;	0007	BEGIN
;	0008	
;	0009	! Copyright (C) 1976,1977
;	0010	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0011	!
;	0012	! This software is furnished under a license for use only on a
;	0013	! single computer system and may be copied only with the inclusion
;	0014	! of the above copyright notice. This software, or any
;	0015	! other copies thereof, may not be provided or otherwise made
;	0016	! available to any other person except for use on such system
;	0017	! and to one who agrees to these license terms. Title to and
;	0018	! ownership of the software shall at all times remain in DEC.
;	0019	!
;	0020	! The information in this software is subject to change without
;	0021	! notice and should not be construed as a commitment by Digital
;	0022	! Equipment Corporation.
;	0023	!
;	0024	! DEC assumes no responsibility for the use or reliability of
;	0025	! its software on equipment which is not supplied by DEC.
;	0026	!
;	0027	! FACILITY:	PATCH
;	0028	!
;	0029	!++
;	0030	! FUNCTIONAL DESCRIPTION:
;	0031	!
;	0032	!	CALLS TO STARLET OPERATING SYSTEM I/O SERVICES.  INCLUDE
;	0033	!	ASSIGNMENT AND DEASSIGNMENT OF CHANNELS, READS, WRITES.
;	0034	!
;	0035	! Version:	X01.16
;	0036	!
;	0037	! History:
;	0038	!	Author:
;	0039	!		Carol Peters, 21 Sep 1976: Version 01
;	0040	!
;	0041	!	Modified by:
;	0042	!		Kevin Pammett, 15-dec-77: Version 25
;	0043	!
;	0044	! Revision History:
;	0045	!
;	0046	! NO	DATE		PROGRAMMER		PURPOSE
;	0047	! --	----		----------		-------
;	0048	!
;	0049	! 00	20-DEC-77	K.D. MORSE		ADAPT VERSION 25 FOR PATCH.
;	0050	!  01	27-DEC-77	K.D. MORSE		CHANGE PAT$OUT_TYP_VAL CALLS TO
;	0051	!						FOR$CVT ... TO CALL PAT$GET_VALUE.
;	0052	!  02	2-JAN-78	K.D. MORSE		ADD CHECKS FOR IMAGE WITH NO SYMBOLS.
;	0053	!  03	4-JAN-78	K.D. MORSE		FOR OUTPUTTING COMPLEX NUMBERS,
;	0054	!						SURROUND THEM IN PARENTHESIS, AND
;	0055	!						REMOVE THE SPURIOUS QUOTES

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 1-1
; Digital Equipment Corporation
;
;	0056	!						AROUND THE COMMA. (26)
;	0057	!						NO CHANGES FOR 27.
;	0058	!  04	28-FEB-78	K.D. MORSE		NO CHANGES FOR 28-29.
;	0059	!  05	02-MAR-78	K.D. MORSE		NO CHANGES FOR 30-31.
;	0060	!  06	17-MAR-78	K.D. MORSE		ADD CODE TO OUTPUT A LEADING 0
;	0061	!						FOR NEGATIVE HEX NUMBERS TO
;	0062	!						PAT$OUT_NUM_VAL.  THE CODE WAS
;	0063	!						TO DO THIS IN PAT$INS_DECODE
;	0064	!						WAS INCORRECT AND THERFORE REMOVED.
;	0065	!  07	24-MAR-78	K.D. MORSE		NO CHANGES FOR VERS 32-34.
;	0066	!  08	30-MAR-78	K.D. MORSE		ADD "PC-RELATIVE" ARRAYS.
;	0067	!  09	07-APR-78	K.D. MORSE		ADD PAT$PV_TO_CS, AND CHANGE
;	0068	!						PAT$PRINT_PATH TO USE IT (35).
;	0069	!						OUT_SYM_VAL NOW CONSIDERS
;	0070	!						DEFINE SYMBOLS (FOR EXACT
;	0071	!						MATCHES ONLY) (36).
;	0072	!						NO CHANGES FOR 37.
;	0073	!  10	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0074	!  11	17-MAY-78	K.D. MORSE		SHOW_MODU NOW SKIPS THE GLOBAL
;	0075	!						MC. (38)
;	0076	!						SHOW_MODU PRINTS ERROR MESSAGE
;	0077	!						IF THERE IS NO DST. (39)
;	0078	!  12	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 40-41.
;	0079	!  13	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0080	!  14	27-JUN-78	K.D. MORSE		ADD LEADING ZEROS FOR HEX
;	0081	!						OUTPUT IN OUT_SYM_VAL. (42)
;	0082	!  15	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 43-48.
;	0083	!  16	29-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 49.
;	0084	!						SHOW MODULE NOW PRINTS
;	0085	!						ALL NUMBERS AS DECIMAL (50).
;	0086	!						NO CHANGES FOR VERS 51.
;	0087	!
;	0088	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 2
; Digital Equipment Corporation
;
;	0089	!
;	0090	! TABLE OF CONTENTS:
;	0091	!
;	0092	
;	0093	FORWARD ROUTINE
;	0094		PAT$PV_TO_CS : NOVALUE,					! Encode a pathvector into a buffer.
;	0095		PAT$FAO_PUT : NOVALUE,					! Stuff output into current output buffer.
;	0096		PAT$MODULE_SIZE,					! Estimate the RST size of a module.
;	0097		PAT$OUT_NUM_VAL : NOVALUE,				! Output of numeric values.
;	0098		PAT$OUT_PUT : NOVALUE,					! Actually write out a line to tty
;	0099		PAT$OUT_SYM_VAL : NOVALUE,				! Output values either in numeric
;	0100									! or in symbolic form.
;	0101		PAT$SHOW_MODULE : NOVALUE,				! List off the module chain.
;	0102		PAT$SHOW_SCOPE : NOVALUE,				! Print out the current CSP.
;	0103		PAT$PRINT_PATH : NOVALUE;				! Print out a symbol pathname
;	0104	
;	0105	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0106	REQUIRE 'SRC$:VXSMAC.REQ';
;	0146	REQUIRE 'LIB$:PATMSG.REQ';
;	0304	REQUIRE 'SRC$:PATPCT.REQ';
;	0320	REQUIRE 'SRC$:PATGEN.REQ';
;	0499	REQUIRE 'SRC$:SYSLIT.REQ';
;	0534	REQUIRE 'SRC$:SYSSER.REQ';
;      R0542	SWITCHES LIST (SOURCE);
;      R0543	
;      R0544	EXTERNAL ROUTINE
;      R0545		PAT$fao_out;		! formats a line and outputs to the terminal
;      R0546	
;      R0547	SWITCHES LIST (NOSOURCE);
;	0592	REQUIRE 'SRC$:PATRST.REQ';
;	1650	REQUIRE 'SRC$:BSTRUC.REQ';
;	1701	REQUIRE 'SRC$:DLLNAM.REQ';
;	1734	REQUIRE 'SRC$:PREFIX.REQ';
;	1917	REQUIRE 'SRC$:PATPRE.REQ';
;	2057	
;	2058	EXTERNAL ROUTINE
;	2059		PAT$FIND_VAL,						! VAL_TO_SYM on define symbols
;	2060		PAT$GET_BOUNDS : NOVALUE,				! Understand array descriptors
;	2061		PAT$GET_VALUE : NOVALUE,				! Takes unmapped address and returns contents of it
;	2062		PAT$ADD_NT_T_PV,					! Built pathname vectors
;	2063		PAT$REPORT_FREE,					! Bytes remaining in free storage
;	2064		PAT$VAL_TO_SYM,						! Translate values to their
;	2065									! symbolic equivalent
;	2066		PAT$SYMBOL_VALU,
;	2067		SYS$FAOL: ADDRESSING_MODE (ABSOLUTE);			! System service to do formatted output
;	2068	
;	2069	EXTERNAL
;	2070		PAT$GL_SYMTBPTR,					! Pointer to default symbol table
;	2071		PAT$GL_OLDLABLS,					! Pointer to old labels symbol table
;	2072		PAT$GL_SYMHEAD,						! Pointer to user-defined symbol table
;	2073		PAT$GB_SYMBOLS,						! Indicator if image has symbols
;	2074		PAT$CP_OUT_STR: REF VECTOR[, BYTE],			! Points into current output buffer
;	2075		PAT$GB_MOD_PTR: REF VECTOR[, BYTE],			! Points to current I/O mode settings
;	2076		PAT$GL_BUF_SIZ,						! Holds current character count in output buffer
;	2077		PAT$GL_CSP_PTR  : ref pathname_vector,			! The current scope position (CSP)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 2-1
; Digital Equipment Corporation
;
;	2078		PAT$GL_LAST_VAL,					! The last value displayed
;	2079		PAT$GL_MC_PTR	: REF MC_RECORD,			! Pointer to the module chain (MC).	
;	2080		PAT$GL_NEXT_LOC;					! Next location to display

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 3
; Digital Equipment Corporation
;
;	2081	GLOBAL ROUTINE PAT$FAO_PUT( STRING, ARGUMENTS ) : NOVALUE =
;	2082	
;	2083	!++
;	2084	! FUNCTIONAL DESCRIPTION:
;	2085	!
;	2086	!	Do just what $FAO does, only here we work in co-operation with a
;	2087	!	global character buffer into which we are encoding arbitrary lines
;	2088	!	of output.
;	2089	!
;	2090	!	All console output done within PATCH should use this routine to build
;	2091	!	output lines.  The only other I/O call which PATCH should be making
;	2092	!	(for the console) is to PAT$OUT_PUT, which simply says "put out whatever
;	2093	!	PAT$FAL_PUT built".
;	2094	!
;	2095	! CALLING SEQUENCE:
;	2096	!
;	2097	!	PAT$FAO_PUT ();
;	2098	!
;	2099	! INPUTS:
;	2100	!
;	2101	!	STRING	  - A counted string which contains the directives for $FAO.
;	2102	!	ARGUMENTS - The arguments for $FAO.
;	2103	!
;	2104	! IMPLICIT INPUTS:
;	2105	!
;	2106	!	PAT$CP_OUT_STR	- Pointer to where we are in the current output buffer.
;	2107	!	PAT$GL_BUF_SIZ	- Count of characters in output buffer.
;	2108	!
;	2109	! OUTPUTS:
;	2110	!
;	2111	!	The $FAO output is put into the output buffer.
;	2112	!
;	2113	! IMPLICIT OUTPUTS:
;	2114	!
;	2115	!	The global character pointer is incremented so that it points
;	2116	!	(as always) to the next available place in the output buffer.
;	2117	!	The buffer count variable is incremented by the size of this string.
;	2118	!
;	2119	! ROUTINE VALUE:
;	2120	!
;	2121	!	none
;	2122	!
;	2123	! SIDE EFFECTS:
;	2124	!
;	2125	!	none
;	2126	!--
;	2127	
;	2128	BEGIN
;	2129	MAP
;	2130		STRING : REF VECTOR[,BYTE];
;	2131	LOCAL
;	2132		INP_DESC : VECTOR[2],					! Input desc for $FAO
;	2133		OUT_DESC : VECTOR[2],					! Output desc for $FAO
;	2134		STR_SIZE : WORD;					! $FAO returns output size here
;	2135	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 3-1
; Digital Equipment Corporation
;
;	2136	!++
;	2137	! Build the descriptors that $FAO wants, ask it to do the encoding,
;	2138	! copying the output into our global output buffer, and finally update the
;	2139	! global pointer to the next free character position in the buffer.
;	2140	!-
;	2141	INP_DESC[0] = .STRING[0];
;	2142	INP_DESC[1] = STRING[1];
;	2143	OUT_DESC [0] = TTY_OUT_WIDTH - 1 - .PAT$GL_BUF_SIZ;
;	2144	OUT_DESC[1] = .PAT$CP_OUT_STR;
;	2145	SYS$FAOL( INP_DESC, STR_SIZE, OUT_DESC, ARGUMENTS );
;	2146	PAT$CP_OUT_STR = .PAT$CP_OUT_STR + .STR_SIZE;
;	2147	PAT$GL_BUF_SIZ = .PAT$GL_BUF_SIZ + .STR_SIZE;
;	2148	END;


							    .TITLE  PATSSV
							    .IDENT  \X01.16\

						    ISE$C_SIZE==	20
						    TXT$C_SIZE==	4
						    PAL$C_SIZE==	16
						    ASD$C_SIZE==	9
						    FWR$C_SIZE==	24
							    .GLOBL  PAT$FAO_OUT, PAT$GL_RST_BEGN, PAT$FIND_VAL, PAT$GET_BOUNDS
							    .GLOBL  PAT$GET_VALUE, PAT$ADD_NT_T_PV, PAT$REPORT_FREE
							    .GLOBL  PAT$VAL_TO_SYM, PAT$SYMBOL_VALU, SYS$FAOL, PAT$GL_SYMTBPTR
							    .GLOBL  PAT$GL_OLDLABLS, PAT$GL_SYMHEAD, PAT$GB_SYMBOLS
							    .GLOBL  PAT$CP_OUT_STR, PAT$GB_MOD_PTR, PAT$GL_BUF_SIZ
							    .GLOBL  PAT$GL_CSP_PTR, PAT$GL_LAST_VAL, PAT$GL_MC_PTR
							    .GLOBL  PAT$GL_NEXT_LOC
							    .WEAK   ACCESS_CHECK

							    .PSECT  _PAT$CODE,NOWRT,2

					 0C00 00000 	    .ENTRY  PAT$FAO_PUT, Save R10,R11				      ; 2081
		         5A 00000000G  EF  9E 00002 	    MOVAB   PAT$GL_BUF_SIZ, R10					      ;
		         5B 00000000G  EF  9E 00009 	    MOVAB   PAT$CP_OUT_STR, R11					      ;
		         5E	       14  C2 00010 	    SUBL2   #20, SP						      ;
		    0C   AE	  04   BC  9A 00013 	    MOVZBL  @STRING, INP_DESC					      ; 2141
      10   AE	    04   AC	       01  C1 00018 	    ADDL3   #1, STRING, INP_DESC+4				      ; 2142
      04   AE 00000083   8F	       6A  C3 0001E 	    SUBL3   PAT$GL_BUF_SIZ, #131, OUT_DESC			      ; 2143
		    08   AE	       6B  D0 00027 	    MOVL    PAT$CP_OUT_STR, OUT_DESC+4				      ; 2144
				  08   AC  9F 0002B 	    PUSHAB  ARGUMENTS						      ; 2145
				  08   AE  9F 0002E 	    PUSHAB  OUT_DESC						      ;
				  08   AE  9F 00031 	    PUSHAB  STR_SIZE						      ;
				  18   AE  9F 00034 	    PUSHAB  INP_DESC						      ;
	      00000000G  9F	       04  FB 00037 	    CALLS   #4, @#SYS$FAOL					      ;
		         50	       6E  3C 0003E 	    MOVZWL  STR_SIZE, R0					      ; 2146
		         6B	       50  C0 00041 	    ADDL2   R0, PAT$CP_OUT_STR					      ;
		         50	       6E  3C 00044 	    MOVZWL  STR_SIZE, R0					      ; 2147
		         6A	       50  C0 00047 	    ADDL2   R0, PAT$GL_BUF_SIZ					      ;
					   04 0004A 	    RET     							      ; 2081

; Routine Size:  75 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 3-2
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 4
; Digital Equipment Corporation
;
;	2149	GLOBAL ROUTINE PAT$MODULE_SIZE( MC_PTR ) =
;	2150	
;	2151	!++
;	2152	! Functional Description:
;	2153	!
;	2154	!	Given an MC pointer to a given module, estimate how many bytes of RST
;	2155	!	storage would be required to SET (initialize) this module into the RST.
;	2156	!
;	2157	! Calling Sequence:
;	2158	!
;	2159	!	The routine is simply called to pick up the returned value.  The reason
;	2160	!	why it is global is because it is called in PAT$SHOW_MODULE, of
;	2161	!	PATSSV.B32, and in ADD_MODULE, of PATBLD.B32.
;	2162	!
;	2163	! Formal Parameters:
;	2164	!
;	2165	!	MC_PTR	-An MC pointer which tells us all we need
;	2166	!		 to know about the indicated module.
;	2167	!
;	2168	! Implicit Inputs:
;	2169	!
;	2170	!	The RST storage we consider is independent of GLOBAL
;	2171	!	considerations.  This means that in all likelihood we overestimate.
;	2172	!	(We guarantee NOT to underestimate in any case.)
;	2173	!
;	2174	!	How the storage manager works, and how we
;	2175	!	use it to allocate all RST storage.
;	2176	!
;	2177	! Implicit Outputs:
;	2178	!
;	2179	!	none.
;	2180	!
;	2181	! Return Value:
;	2182	!
;	2183	!	The number of bytes required to add the module
;	2184	!	to the Runtime Symbol Table data structures.
;	2185	!
;	2186	!--
;	2187	
;	2188	BEGIN
;	2189	
;	2190	MAP
;	2191		MC_PTR : REF MC_RECORD;
;	2192	
;	2193	LOCAL
;	2194		TOTAL_BYTES;
;	2195	
;	2196	!++
;	2197	! Macro to calculate the total number of bytes
;	2198	! taken for so-called vector storage (which
;	2199	! is how we allocate NTs, LVTs, and SATs).
;	2200	!--
;	2201	MACRO
;	2202	
;	2203		VEC_STORAGE_FOR( RECORDS, SIZE ) = (%UPVAL + 		! The storage manager's overhead,

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 4-1
; Digital Equipment Corporation
;
;     M 2204						( (RST_UNITS( RECORDS * SIZE )) * %UPVAL ))%; ! Rounded up vector storage space
;	2205	
;	2206	!++
;	2207	! Tally up the total number of bytes needed to add the NTs, LVTs, and
;	2208	! SATs for the indicated module.  First initialize counter.
;	2209	!--
;	2210	TOTAL_BYTES = 0;
;	2211	
;	2212	!++
;	2213	! Although it is not true, we must assume that NT entries are fixed-size. 
;	2214	!--
;	2215	TOTAL_BYTES = VEC_STORAGE_FOR( .MC_PTR [MC_NAMES], RST_NT_SIZE );
;	2216	
;	2217	!++
;	2218	! Add on that taken for SATs and LVTs.
;	2219	!--
;	2220	TOTAL_BYTES = .TOTAL_BYTES
;	2221		    + VEC_STORAGE_FOR( .MC_PTR [MC_STATICS], RST_SAT_SIZE )
;	2222		    + VEC_STORAGE_FOR( .MC_PTR [MC_LITERALS], RST_LVT_SIZE );
;	2223	
;	2224	!++
;	2225	! Return the size.
;	2226	!--
;	2227	RETURN(.TOTAL_BYTES);
;	2228	END;





					 0004 0004B 	    .ENTRY  PAT$MODULE_SIZE, Save R2				      ; 2149
				       52  D4 0004D 	    CLRL    TOTAL_BYTES						      ; 2210
	   51	    04   AC 00000000G  EF  C1 0004F 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R1				      ; 2215
	   50	    08   A1	       1C  C5 00058 	    MULL3   #28, 8(R1), R0					      ;
		         50	       03  C0 0005D 	    ADDL2   #3, R0						      ;
		         50	       04  C6 00060 	    DIVL2   #4, R0						      ;
	   52	         50	       02  78 00063 	    ASHL    #2, R0, TOTAL_BYTES					      ;
		         52	       04  C0 00067 	    ADDL2   #4, TOTAL_BYTES					      ;
	   50	    31   A1	       0A  C5 0006A 	    MULL3   #10, 49(R1), R0					      ; 2221
		         50	       03  C0 0006F 	    ADDL2   #3, R0						      ;
		         50	       04  C6 00072 	    DIVL2   #4, R0						      ;
		         50	     6240  DE 00075 	    MOVAL   (TOTAL_BYTES)[R0], R0				      ;
	   51	    35   A1	       06  C5 00079 	    MULL3   #6, 53(R1), R1					      ; 2222
		         51	       03  C0 0007E 	    ADDL2   #3, R1						      ;
		         51	       04  C6 00081 	    DIVL2   #4, R1						      ;
		         52	  08 A041  DE 00084 	    MOVAL   8(R0)[R1], TOTAL_BYTES				      ;
		         50	       52  D0 00089 	    MOVL    TOTAL_BYTES, R0					      ; 2227
					   04 0008C 	    RET     							      ; 2149

; Routine Size:  66 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 5
; Digital Equipment Corporation
;
;	2229	GLOBAL ROUTINE PAT$OUT_NUM_VAL ( VALUE, NEW_LENGTH, NEW_RADIX, ZERO_FILL) : NOVALUE =
;	2230	
;	2231	!++
;	2232	! Functional Description:
;	2233	!
;	2234	!	Format the given value according to the current output mode settings.
;	2235	!	The formatted value is inserted into the output buffer described by
;	2236	!	PAT$CP_OUT_STR and PAT$GL_BUF_SIZ.  If the value is formatted in
;	2237	!	hexadecimal and negative and ZERO_FILL is TRUE, then a leading zero
;	2238	!	is output.
;	2239	!
;	2240	! Calling Sequence:
;	2241	!
;	2242	!	PAT$OUT_NUM_VAL (VALUE, NEW_LENGTH, NEW_RADIX, ZERO_FILL)
;	2243	!
;	2244	! Inputs:
;	2245	!
;	2246	!	VALUE - The actual value we are to write out.
;	2247	!	NEW_LENGTH - Either 0, or the MODE_LENGTH we should use.
;	2248	!		     (0 => use current LENGTH, non-zero allows
;	2249	!		      it to be overridden.)
;	2250	!		     (The literal, NO_OVERRIDE = 0, is used for this.)
;	2251	!	NEW_RADIX - Either 0, or the MODE_RADIX we should use.
;	2252	!	ZERO_FILL - Indicator if leading zero should be output
;	2253	!			(TRUE = yes, FALSE = no)
;	2254	!
;	2255	! Implicit Inputs:
;	2256	!
;	2257	!	PAT$GB_MOD_PTR - points to the current mode data structure.
;	2258	!	PAT$CP_OUT_STR - points into the output buffer at the first
;	2259	!			 place in the buffer which is available.
;	2260	!	PAT$GL_BUF_SIZ - holds the current number of characters in
;	2261	!			 the buffer.
;	2262	!
;	2263	! Outputs:
;	2264	!
;	2265	!	The (numeric) character representation
;	2266	!	of the value is encoded into the output buffer.
;	2267	!
;	2268	! Implicit Outputs:
;	2269	!
;	2270	!	The buffer pointer, PAT$CP_OUT_STR, is incremented.  
;	2271	!	The buffer count, PAT$GL_BUF_SIZ, is incremented.
;	2272	!
;	2273	! Routine Value:
;	2274	!
;	2275	!	NOVALUE.
;	2276	!
;	2277	! Side Effects.
;	2278	!
;	2279	!	Negative hex numbers may be preceded by a leading 0.
;	2280	!--
;	2281	
;	2282	BEGIN
;	2283	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 5-1
; Digital Equipment Corporation
;
;	2284	LOCAL
;	2285		USE_LENGTH,						! The MODE_LENGTH we actually use
;	2286		USE_RADIX;						! The MODE_RADIX we actually use
;	2287	
;	2288	OWN
;	2289		FORMAT : VECTOR[4,BYTE]					! Build format string here
;	2290				 INITIAL( BYTE( %ASCIC '!??' ) );
;	2291	
;	2292	!++
;	2293	! Assume that we are passed an override for the LENGTH and RADIX,
;	2294	! but revert to the globally-set one if this is untrue.
;	2295	!--
;	2296	IF ((USE_LENGTH = .NEW_LENGTH) EQL 0)
;	2297	THEN
;	2298		USE_LENGTH = .PAT$GB_MOD_PTR  [MODE_LENGTH];
;	2299	IF ((USE_RADIX = .NEW_RADIX) EQL 0)
;	2300	THEN
;	2301		USE_RADIX = .PAT$GB_MOD_PTR  [MODE_RADIX];
;	2302	
;	2303	!++
;	2304	! Now just build the required 2-character format string descriptor,
;	2305	! based upon the current setting of the mode length and radix.
;	2306	!
;	2307	! We assume signed, for decimal output, and take longword hexadecimal either
;	2308	! when that is explicitly the case, or when some unknown length or radix is indicated.
;	2309	!--
;	2310	FORMAT[2] = ( SELECTONE .USE_RADIX OF
;	2311			SET
;	2312			[OCTAL_RADIX]:		'O';
;	2313			[DECIMAL_RADIX]:	'S';
;	2314			[OTHERWISE]:		'X';
;	2315			TES
;	2316		    );
;	2317	
;	2318	FORMAT[3] = ( SELECTONE .USE_LENGTH OF
;	2319			SET
;	2320			[BYTE_LENGTH]:	'B';
;	2321			[WORD_LENGTH]:	'W';
;	2322			[OTHERWISE]:	'L';
;	2323			TES
;	2324		    );
;	2325	
;	2326	!++
;	2327	! Now check if the output radix is hexadecimal and if a leading zero is needed.
;	2328	! This is required to make PATCH output acceptable as input.  Hexadecimal
;	2329	! numbers require the leading character to be a numeric.
;	2330	!--
;	2331	IF (.FORMAT[2] EQLU 'X') AND (.ZERO_FILL) AND
;	2332	   (.(VALUE)<0, .USE_LENGTH*8, 1> GTRA %X'9FFFFFFF')
;	2333	THEN
;	2334		BEGIN
;	2335		PAT$CP_OUT_STR[0] = '0';
;	2336		PAT$CP_OUT_STR = .PAT$CP_OUT_STR + 1;
;	2337		PAT$GL_BUF_SIZ = .PAT$GL_BUF_SIZ + 1;
;	2338		END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 5-2
; Digital Equipment Corporation
;
;	2339	
;	2340	PAT$FAO_PUT ( FORMAT, .VALUE );
;	2341	
;	2342	END;



							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 FORMAT: .ASCII  <3>\!??\						      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0804 0008D 	    .ENTRY  PAT$OUT_NUM_VAL, Save R2,R11			      ; 2229
		         5B 00000000'  EF  9E 0008F 	    MOVAB   FORMAT+2, R11					      ;
		         50	  08   AC  D0 00096 	    MOVL    NEW_LENGTH, USE_LENGTH				      ; 2296
				       0B  12 0009A 	    BNEQ    1$							      ;
		         51 00000000G  EF  D0 0009C 	    MOVL    PAT$GB_MOD_PTR, R1					      ; 2298
		         50	  01   A1  9A 000A3 	    MOVZBL  1(R1), USE_LENGTH					      ;
		         51	  0C   AC  D0 000A7 1$:     MOVL    NEW_RADIX, USE_RADIX				      ; 2299
				       07  12 000AB 	    BNEQ    2$							      ;
		         51 00000000G  FF  9A 000AD 	    MOVZBL  @PAT$GB_MOD_PTR, USE_RADIX				      ; 2301
		         52	       01  CE 000B4 2$:     MNEGL   #1, R2						      ; 2310
		         08	       51  D1 000B7 	    CMPL    USE_RADIX, #8					      ;
				       06  12 000BA 	    BNEQ    3$							      ;
		         52	  4F   8F  9A 000BC 	    MOVZBL  #79, R2						      ;
				       0F  11 000C0 	    BRB     5$							      ;
		         0A	       51  D1 000C2 3$:     CMPL    USE_RADIX, #10					      ;
				       06  12 000C5 	    BNEQ    4$							      ;
		         52	  53   8F  9A 000C7 	    MOVZBL  #83, R2						      ;
				       04  11 000CB 	    BRB     5$							      ;
		         52	  58   8F  9A 000CD 4$:     MOVZBL  #88, R2						      ;
		         6B	       52  90 000D1 5$:     MOVB    R2, FORMAT+2					      ;
		         51	       01  CE 000D4 	    MNEGL   #1, R1						      ; 2318
		         01	       50  D1 000D7 	    CMPL    USE_LENGTH, #1					      ;
				       06  12 000DA 	    BNEQ    6$							      ;
		         51	  42   8F  9A 000DC 	    MOVZBL  #66, R1						      ;
				       0F  11 000E0 	    BRB     8$							      ;
		         02	       50  D1 000E2 6$:     CMPL    USE_LENGTH, #2					      ;
				       06  12 000E5 	    BNEQ    7$							      ;
		         51	  57   8F  9A 000E7 	    MOVZBL  #87, R1						      ;
				       04  11 000EB 	    BRB     8$							      ;
		         51	  4C   8F  9A 000ED 7$:     MOVZBL  #76, R1						      ;
		    01   AB	       51  90 000F1 8$:     MOVB    R1, FORMAT+3					      ;
		    58   8F	       6B  91 000F5 	    CMPB    FORMAT+2, #88					      ; 2331
				       29  12 000F9 	    BNEQ    9$							      ;
		         25	  10   AC  E9 000FB 	    BLBC    ZERO_FILL, 9$					      ;
		         50	       08  C4 000FF 	    MULL2   #8, R0						      ; 2332
      04   AC	         50	       00  EE 00102 	    EXTV    #0, R0, VALUE, R1					      ;
				       51     00107									      ;
	      9FFFFFFF   8F	       51  D1 00108 	    CMPL    R1, #-1610612737					      ;
				       13  1B 0010F 	    BLEQU   9$							      ;
	      00000000G  FF	       30  90 00111 	    MOVB    #48, @PAT$CP_OUT_STR				      ; 2335

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 5-3
; Digital Equipment Corporation
;
			    00000000G  EF  D6 00118 	    INCL    PAT$CP_OUT_STR					      ; 2336
			    00000000G  EF  D6 0011E 	    INCL    PAT$GL_BUF_SIZ					      ; 2337
				  04   AC  DD 00124 9$:     PUSHL   VALUE						      ; 2340
				  FE   AB  9F 00127 	    PUSHAB  FORMAT						      ;
		  FED1   CF	       02  FB 0012A 	    CALLS   #2, PAT$FAO_PUT					      ;
					   04 0012F 	    RET     							      ; 2229

; Routine Size:  163 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 6
; Digital Equipment Corporation
;
;	2343	GLOBAL ROUTINE PAT$OUT_PUT ( BUFFER ) : NOVALUE =
;	2344	
;	2345	!++
;	2346	! Functional Description:
;	2347	!
;	2348	!	Cause the current output buffer to be actually
;	2349	!	output to the console.
;	2350	!
;	2351	! Calling Sequence:
;	2352	!
;	2353	!	PAT$OUT_PUT ()
;	2354	!
;	2355	! Inputs:
;	2356	!
;	2357	!	BUFFER - Pointer to the beginning of the current output
;	2358	!		buffer.  this is supposed to be a counted
;	2359	!		string except that noone has supplied the count yet.
;	2360	!		ie we expect that the actual string to be printed
;	2361	!		starts in byte BUFFER+1.
;	2362	!
;	2363	! Implicit Inputs:
;	2364	!
;	2365	!	PAT$CP_OUT_STR - Points into this output buffer at the first
;	2366	!			 place in the buffer which is NOT to be printed.
;	2367	!	PAT$GL_BUF_SIZ - Holds count of characters in buffer
;	2368	!
;	2369	! Outputs:
;	2370	!
;	2371	!	The string is printed, exactly as it is in the
;	2372	!	buffer - ie, it should contain whatever carriage control 
;	2373	!	you want.
;	2374	!
;	2375	! Implicit Outputs:
;	2376	!
;	2377	!	The buffer pointer, PAT$CP_OUT_STR, is set to zero.  This will
;	2378	!	help routines know if they are to use their own buffer or
;	2379	!	if one is already partially built.
;	2380	! ***	I don't think we have ever actually used the above
;	2381	!	'feature', and feel that this routine ought, instead, set
;	2382	!	up for more PAT$FAO_PUT calls on the current buffer when we
;	2383	!	are called to output it.
;	2384	!
;	2385	! Routine Value:
;	2386	!
;	2387	!	NOVALUE.
;	2388	!
;	2389	! Side Effects:
;	2390	!
;	2391	!	none.
;	2392	!--
;	2393	
;	2394	BEGIN
;	2395	
;	2396	MAP
;	2397		BUFFER : REF VECTOR[,BYTE];				! Points to output buffer

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 6-1
; Digital Equipment Corporation
;
;	2398	
;	2399	!++
;	2400	! Fill in the count, and pass it to QIO.
;	2401	!--
;	2402	BUFFER [0] = .PAT$GL_BUF_SIZ;
;	2403	$FAO_TT_OUT ( '!AC', .BUFFER );
;	2404	PAT$CP_OUT_STR = 0;
;	2405	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .BYTE   3							      ;
					      00001 	    .ASCII  \!AC\						      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0000 00130 	    .ENTRY  PAT$OUT_PUT, Save nothing				      ; 2343
		    04   BC 00000000G  EF  90 00132 	    MOVB    PAT$GL_BUF_SIZ, @BUFFER				      ; 2402
				  04   AC  DD 0013A 	    PUSHL   BUFFER						      ; 2403
			    00000000'  EF  9F 0013D 	    PUSHAB  P.AAA						      ;
	      00000000G  EF	       02  FB 00143 	    CALLS   #2, PAT$FAO_OUT					      ;
			    00000000G  EF  D4 0014A 	    CLRL    PAT$CP_OUT_STR					      ; 2404
					   04 00150 	    RET     							      ; 2343

; Routine Size:  33 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7
; Digital Equipment Corporation
;
;	2406	GLOBAL ROUTINE PAT$OUT_SYM_VAL ( VALUE, NEW_LENGTH, NEW_RADIX ) : NOVALUE =
;	2407	
;	2408	!++
;	2409	! Functional Description:
;	2410	!
;	2411	!	Write out the given value according to the current
;	2412	!	mode settings - including the current mode setting
;	2413	!	for the [NO]SYMBOLS flag.  (By 'write out', we mean
;	2414	!	'encode into the output buffer').
;	2415	!
;	2416	! Calling Sequence:
;	2417	!
;	2418	!	PAT$OUT_SYM_VAL ()
;	2419	!
;	2420	! Inputs:
;	2421	!
;	2422	!	VALUE - The actual value we are to write out.
;	2423	!	NEW_LENGTH - Either 0, or the MODE_LENGTH we should use.
;	2424	!		     (0 => use current LENGTH, non-zero allows
;	2425	!		      it to be overridden.)
;	2426	!		     (The literal, NO_OVERRIDE = 0, is used for this.)
;	2427	!	NEW_RADIX - Either 0, or the MODE_RADIX we should use.
;	2428	!
;	2429	! Implicit Inputs:
;	2430	!
;	2431	!	PAT$GB_MOD_PTR - Points to the current mode data structure.
;	2432	!	PAT$CP_OUT_STR - Points into the output buffer at the first
;	2433	!			 place in the buffer which is available.
;	2434	!	PAT$GL_BUF_SIZ - Holds the current number of characters in
;	2435	!			 the buffer.
;	2436	!
;	2437	! Outputs:
;	2438	!
;	2439	!	The symbolic or numeric (or symbolic+residue) representation
;	2440	!	of the value is encoded into the output buffer.
;	2441	!
;	2442	! Implicit Outputs:
;	2443	!
;	2444	!	The buffer pointer, PAT$CP_OUT_STR, is incremented.  
;	2445	!	The buffer count, PAT$GL_BUF_SIZ, is incremented.
;	2446	!
;	2447	! Routine Value:
;	2448	!
;	2449	!	NOVALUE.
;	2450	!
;	2451	! Side Effects.
;	2452	!	The VALUE is printed out.
;	2453	!--
;	2454	
;	2455	BEGIN
;	2456	
;	2457	LOCAL
;	2458			ARRAY_DESC_ADDR,				! The address of an array descriptor,
;	2459									! if we symbolize an array reference.
;	2460			NT_PTR : REF NT_RECORD,				! A pointer to the name table (NT) entry

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-1
; Digital Equipment Corporation
;
;	2461									! which corresponds to the symbol which we
;	2462									! deal with if we do symbolic output.
;	2463			REAL_VALUE,					! Used to recover the actual or real value
;	2464									! of the symbol we may base our symbolic
;	2465									! output off.
;	2466			PATH_VEC : PATHNAME_VECTOR;			! Symbol path vector used to contain the
;	2467									! whole pathname assocaited with the
;	2468									! symbol pointed to by NT_PTR, above.
;	2469	
;	2470	!++
;	2471	! First, see if the value is an exact match to a DEFine type symbol.  Note that
;	2472	! these symbols have nothing to do with the so-called RST and so much be handled
;	2473	! specially.  First look in the current label symbol table, then in the old
;	2474	! label table, and lastly in the user-defined symbol table.
;	2475	!--
;	2476	IF (.PAT$GB_MOD_PTR[MODE_SYMBOLS])
;	2477	THEN
;	2478		BEGIN
;	2479		LOCAL
;	2480			TEMP_SYMTB,
;	2481			INDEX;
;	2482	
;	2483		INDEX = PAT$FIND_VAL(.VALUE,TRUE);
;	2484		IF (.INDEX EQL 0)
;	2485		THEN
;	2486			BEGIN
;	2487			TEMP_SYMTB = .PAT$GL_SYMTBPTR;			! Remember current label table
;	2488			PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;		! Use old labels symbol table
;	2489			INDEX = PAT$FIND_VAL(.VALUE,TRUE);
;	2490			IF (.INDEX EQL 0)
;	2491			THEN
;	2492				BEGIN
;	2493				PAT$GL_SYMTBPTR = .PAT$GL_SYMHEAD;	! Use user-defined symbol table
;	2494				INDEX = PAT$FIND_VAL(.VALUE,TRUE);
;	2495				END;
;	2496			PAT$GL_SYMTBPTR = .TEMP_SYMTB;			! Restor current label table
;	2497			END;
;	2498		IF (.INDEX NEQ 0)
;	2499		THEN
;	2500			BEGIN
;	2501			!++
;	2502			! Found an exact match.  Print this and return an OK status.
;	2503			!--
;	2504			PAT$FAO_PUT(UPLIT(%ASCIC '!AD'),.SYM_CHCOUNT(.INDEX),SYM_NAME(.INDEX));
;	2505			RETURN;
;	2506			END;
;	2507		END;
;	2508	!++
;	2509	! Even though PAT$VAL_TO_SYM 'initializes' NT_PTR when we pass on its address,
;	2510	! we must still initialize it to zero because otherwise the top half of the
;	2511	! longword never gets cleared.  (PAT$VAL_TO_SYM thinks, and rightly so,
;	2512	! that NT_PTRs are only 2 bytes long, the problem is that BLISS doesn't realize
;	2513	! this when it passes .NT_PTR on as an actual parameter later on.)
;	2514	!--
;	2515	NT_PTR = 0;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-2
; Digital Equipment Corporation
;
;	2516	ARRAY_DESC_ADDR = 0;
;	2517	
;	2518	!++
;	2519	! First, see if we should even attempt symbolic output.
;	2520	!--
;	2521	IF (.PAT$GB_MOD_PTR [MODE_SYMBOLS]) AND (.PAT$GB_SYMBOLS)
;	2522	THEN
;	2523		!++
;	2524		! Next, ask VAL_TO_SYM for the NT-pointer which
;	2525		! corresponds to the symbol we should use.
;	2526		! The 'FALSE' says that we don't want LVTs
;	2527		! (literals) to be considered.
;	2528		!--
;	2529		IF (PAT$VAL_TO_SYM( .VALUE, NT_PTR, FALSE))
;	2530		THEN
;	2531			!++
;	2532			! Then, to be able and output "symbol+offset",
;	2533			! we must be able to recover the actual value
;	2534			! of the indicated symbol.
;	2535			!--
;	2536			IF (PAT$SYMBOL_VALU( .NT_PTR, REAL_VALUE))
;	2537			THEN
;	2538				BEGIN
;	2539				!++
;	2540				! See if the value picked up by PAT$SYMBOL_VALU is
;	2541				! really the address which is bound to the
;	2542				! symbol, or if it is the address of a descriptor.
;	2543				! Note that DST_PTR is invalid for NTs which
;	2544				! were created only for global symbols.
;	2545				!--
;	2546				IF (.NT_PTR [NT_UP_SCOPE] NEQ 0)
;	2547				THEN
;	2548					BEGIN
;	2549					LOCAL
;	2550						BOUNDS : ARRAY_BNDS_DESC,
;	2551						DST_RECRD : REF DST_RECORD;
;	2552	
;	2553					!++
;	2554					! Pick up the DST pointer so that we can see
;	2555					! if access is via descriptor.  
;	2556					!--
;	2557					DST_RECRD = .NT_PTR [NT_DST_PTR];
;	2558					IF (.DST_RECRD [DSTR_ACCES_TYPE] EQL ACCS_DESCRIPTOR) AND
;	2559					   ( ( (.DST_RECRD[DSTR_ACCES_BASD] EQL ACCS_BASDIR) AND
;	2560					       (.DST_RECRD[DSTR_ACCES_BREG] EQL 15) ) OR
;	2561					     ( (.DST_RECRD[DSTR_ACCES_BASD] EQL 0) AND
;	2562					       (.DST_RECRD[DSTR_ACCES_BREG] EQL 0) ) )
;	2563					THEN
;	2564						BEGIN
;	2565						!++
;	2566						! REAL_VALUE, returned above, is actually
;	2567						! the address of a descriptor.  Modify this
;	2568						! value to be the beginning virtual address
;	2569						! of the array.
;	2570						!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-3
; Digital Equipment Corporation
;
;	2571						ARRAY_DESC_ADDR = .REAL_VALUE;
;	2572						PAT$GET_BOUNDS( .ARRAY_DESC_ADDR, BOUNDS);
;	2573						REAL_VALUE = .BOUNDS [ARRAY_ADDRESS];
;	2574						END;
;	2575					END;
;	2576	
;	2577				!++
;	2578				! For unbounded symbols, we don't
;	2579				! allow "symbol+offset" unless "offset"
;	2580				! is less than a maximum value.
;	2581				!--
;	2582				IF (((.VALUE - .REAL_VALUE) LSSA RST_MAX_OFFSET)
;	2583				   OR (.NT_PTR [NT_IS_BOUNDED]))
;	2584				THEN
;	2585					BEGIN
;	2586					!++
;	2587					! We have all we need now, so just
;	2588					! encode the characters into the
;	2589					! output stream. To do this we
;	2590					! must first build a pathname vector
;	2591					! to correspond to the NT scope chain we
;	2592					! implicitly now have.
;	2593					!--
;	2594					PAT$ADD_NT_T_PV( .NT_PTR, PATH_VEC );
;	2595	
;	2596					!++
;	2597					! Then we simply print this vector.
;	2598					!--
;	2599					PAT$PRINT_PATH( PATH_VEC );
;	2600	
;	2601					!++
;	2602					! See if there is any residue - i.e. see if
;	2603					! "symbol[(...)]" is sufficient, or if we must
;	2604					! output "symbol[(...)]+offset".
;	2605					!--
;	2606					IF (.VALUE EQL .REAL_VALUE)
;	2607					THEN
;	2608						RETURN;			! No residue -> we're done.
;	2609	
;	2610					!++
;	2611					! The residue (offset) should
;	2612					! be printed in numeric form, preceeded
;	2613					! by a '+'.
;	2614					!--
;	2615					PAT$FAO_PUT(UPLIT(%ASCIC '+'));
;	2616					VALUE = .VALUE-.REAL_VALUE;
;	2617	
;	2618					!++
;	2619					! We should be able to simply
;	2620					! drop out of this part of the
;	2621					! code and have this done by PAT$OUT_NUM_VAL.
;	2622					! Until FAO can print HEX without the leading
;	2623					! 0s, we must do the following...
;	2624					!--
;	2625					IF (.PAT$GB_MOD_PTR [MODE_RADIX] EQL HEX_RADIX)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-4
; Digital Equipment Corporation
;
;	2626					THEN
;	2627						BEGIN
;	2628						!++
;	2629						! Special cludge to ignore leading 0s.
;	2630						! But to then put exactly 1 leading 0
;	2631						! when the rest begins with A-F.
;	2632						!--
;	2633						LOCAL
;	2634							CLUDGE_SIZE;	! # of non-zero digits.
;	2635	
;	2636						!++
;	2637						! We must always print at least 1 digit.
;	2638						!--
;	2639						CLUDGE_SIZE = 1;
;	2640						INCR I FROM 1 TO 7
;	2641							DO
;	2642							IF (.VALUE<.I*4,4,0> NEQ 0)
;	2643							THEN
;	2644								CLUDGE_SIZE = .I+1;
;	2645	
;	2646						IF (.VALUE<0,.CLUDGE_SIZE*4,1> GTRA %X'FFFFFFF9')
;	2647						THEN
;	2648							PAT$FAO_PUT(UPLIT(%ASCIC'0'));
;	2649						PAT$FAO_PUT( UPLIT( %ASCIC '!#XL' ),
;	2650							.CLUDGE_SIZE,.VALUE);
;	2651						RETURN;
;	2652						END;
;	2653					END;
;	2654				END;
;	2655	
;	2656	!++
;	2657	! We didn't try to do symbolic output, or we failed completely at it, or
;	2658	! it went OK but we still have a 'residue'  value to output.
;	2659	!--
;	2660	PAT$OUT_NUM_VAL( .VALUE, .NEW_LENGTH, .NEW_RADIX, TRUE);
;	2661	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00004 P.AAB:  .ASCII  <3>\!AD\						      ;
					      00008 P.AAC:  .ASCII  <1>\+\<0><0>					      ;
					      0000C P.AAD:  .ASCII  <1>\0\<0><0>					      ;
					      00010 P.AAE:  .ASCII  <4>\!#XL\<0><0><0>					      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0FCC 00151 	    .ENTRY  PAT$OUT_SYM_VAL, Save R2,R3,R6,R7,R8,R9,R10,R11	      ; 2406
		         56 00000000G  EF  9E 00153 	    MOVAB   PAT$GL_RST_BEGN, R6					      ;
		         57 00000000G  EF  9E 0015A 	    MOVAB   PAT$GB_MOD_PTR, R7					      ;
		         58 00000000G  EF  9E 00161 	    MOVAB   PAT$FIND_VAL, R8					      ;
		         59	FE94   CF  9E 00168 	    MOVAB   PAT$FAO_PUT, R9					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-5
; Digital Equipment Corporation
;
		         5A 00000000'  EF  9E 0016D 	    MOVAB   P.AAB, R10						      ;
		         5B 00000000G  EF  9E 00174 	    MOVAB   PAT$GL_SYMTBPTR, R11				      ;
		         5E	       3C  C2 0017B 	    SUBL2   #60, SP						      ;
		         50	       67  D0 0017E 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2476
		         4C	  02   A0  E9 00181 	    BLBC    2(R0), 3$						      ;
				       01  DD 00185 	    PUSHL   #1							      ; 2483
				  04   AC  DD 00187 	    PUSHL   VALUE						      ;
		         68	       02  FB 0018A 	    CALLS   #2, PAT$FIND_VAL					      ;
		         52	       50  D0 0018D 	    MOVL    R0, INDEX						      ;
				       2C  12 00190 	    BNEQ    2$							      ; 2484
		         53	       6B  D0 00192 	    MOVL    PAT$GL_SYMTBPTR, TEMP_SYMTB				      ; 2487
		         6B 00000000G  EF  D0 00195 	    MOVL    PAT$GL_OLDLABLS, PAT$GL_SYMTBPTR			      ; 2488
				       01  DD 0019C 	    PUSHL   #1							      ; 2489
				  04   AC  DD 0019E 	    PUSHL   VALUE						      ;
		         68	       02  FB 001A1 	    CALLS   #2, PAT$FIND_VAL					      ;
		         52	       50  D0 001A4 	    MOVL    R0, INDEX						      ;
				       12  12 001A7 	    BNEQ    1$							      ; 2490
		         6B 00000000G  EF  D0 001A9 	    MOVL    PAT$GL_SYMHEAD, PAT$GL_SYMTBPTR			      ; 2493
				       01  DD 001B0 	    PUSHL   #1							      ; 2494
				  04   AC  DD 001B2 	    PUSHL   VALUE						      ;
		         68	       02  FB 001B5 	    CALLS   #2, PAT$FIND_VAL					      ;
		         52	       50  D0 001B8 	    MOVL    R0, INDEX						      ;
		         6B	       53  D0 001BB 1$:     MOVL    TEMP_SYMTB, PAT$GL_SYMTBPTR				      ; 2496
				       52  D5 001BE 2$:     TSTL    INDEX						      ; 2498
				       0F  13 001C0 	    BEQL    3$							      ;
				  0D   A2  9F 001C2 	    PUSHAB  13(INDEX)						      ; 2504
		         50	       52  D0 001C5 	    MOVL    INDEX, R0						      ;
		         7E	  0C   A0  9A 001C8 	    MOVZBL  12(R0), -(SP)					      ;
				       5A  DD 001CC 	    PUSHL   R10							      ;
				     00FE  31 001CE 	    BRW     13$							      ;
				  04   AE  D4 001D1 3$:     CLRL    NT_PTR						      ; 2515
				       52  D4 001D4 	    CLRL    ARRAY_DESC_ADDR					      ; 2516
		         50	       67  D0 001D6 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2521
		         03	  02   A0  E8 001D9 	    BLBS    2(R0), 5$						      ;
				     00F3  31 001DD 4$:     BRW     14$							      ;
		         F6 00000000G  EF  E9 001E0 5$:     BLBC    PAT$GB_SYMBOLS, 4$					      ;
				       7E  D4 001E7 	    CLRL    -(SP)						      ; 2529
				  08   AE  9F 001E9 	    PUSHAB  NT_PTR						      ;
				  04   AC  DD 001EC 	    PUSHL   VALUE						      ;
	      00000000G  EF	       03  FB 001EF 	    CALLS   #3, PAT$VAL_TO_SYM					      ;
		         E4	       50  E9 001F6 	    BLBC    R0, 4$						      ;
				       5E  DD 001F9 	    PUSHL   SP							      ; 2536
		         53	  08   AE  D0 001FB 	    MOVL    NT_PTR, R3						      ;
				       53  DD 001FF 	    PUSHL   R3							      ;
	      00000000G  EF	       02  FB 00201 	    CALLS   #2, PAT$SYMBOL_VALU					      ;
		         D2	       50  E9 00208 	    BLBC    R0, 4$						      ;
	   50	         53	       66  C1 0020B 	    ADDL3   PAT$GL_RST_BEGN, R3, R0				      ; 2546
				  08   A0  B5 0020F 	    TSTW    8(R0)						      ;
				       3A  13 00212 	    BEQL    8$							      ;
		         50	  04   A0  D0 00214 	    MOVL    4(R0), DST_RECRD					      ; 2557
		         50	       02  C0 00218 	    ADDL2   #2, R0						      ; 2558
	   60	         02	       00  ED 0021B 	    CMPZV   #0, #2, (R0), #2					      ;
				       02     0021F									      ;
				       2C  12 00220 	    BNEQ    8$							      ;
	   60	         02	       02  ED 00222 	    CMPZV   #2, #2, (R0), #2					      ; 2559

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-6
; Digital Equipment Corporation
;
				       02     00226									      ;
				       07  12 00227 	    BNEQ    6$							      ;
	   60	         04	       04  ED 00229 	    CMPZV   #4, #4, (R0), #15					      ; 2560
				       0F     0022D									      ;
				       0B  13 0022E 	    BEQL    7$							      ;
		         0C	       60  93 00230 6$:     BITB    (R0), #12						      ; 2561
				       19  12 00233 	    BNEQ    8$							      ;
		    F0   8F	       60  93 00235 	    BITB    (R0), #240						      ; 2562
				       13  12 00239 	    BNEQ    8$							      ;
		         52	       6E  D0 0023B 7$:     MOVL    REAL_VALUE, ARRAY_DESC_ADDR				      ; 2571
				  08   AE  9F 0023E 	    PUSHAB  BOUNDS						      ; 2572
				       52  DD 00241 	    PUSHL   ARRAY_DESC_ADDR					      ;
	      00000000G  EF	       02  FB 00243 	    CALLS   #2, PAT$GET_BOUNDS					      ;
		         6E	  08   AE  D0 0024A 	    MOVL    BOUNDS, REAL_VALUE					      ; 2573
		         52	       6E  D0 0024E 8$:     MOVL    REAL_VALUE, R2					      ; 2582
	   50	    04   AC	       52  C3 00251 	    SUBL3   R2, VALUE, R0					      ;
	      00000100   8F	       50  D1 00256 	    CMPL    R0, #256						      ;
				       09  1F 0025D 	    BLSSU   9$							      ;
	   50	         53	       66  C1 0025F 	    ADDL3   PAT$GL_RST_BEGN, R3, R0				      ; 2583
	   6B	    03   A0	       07  E1 00263 	    BBC     #7, 3(R0), 14$					      ;
				  10   AE  9F 00268 9$:     PUSHAB  PATH_VEC						      ; 2594
				       53  DD 0026B 	    PUSHL   R3							      ;
	      00000000G  EF	       02  FB 0026D 	    CALLS   #2, PAT$ADD_NT_T_PV					      ;
				  10   AE  9F 00274 	    PUSHAB  PATH_VEC						      ; 2599
	      00000000V  EF	       01  FB 00277 	    CALLS   #1, PAT$PRINT_PATH					      ;
		         52	  04   AC  D1 0027E 	    CMPL    VALUE, R2						      ; 2606
				       5D  13 00282 	    BEQL    15$							      ;
				  04   AA  9F 00284 	    PUSHAB  P.AAC						      ; 2615
		         69	       01  FB 00287 	    CALLS   #1, PAT$FAO_PUT					      ;
		    04   AC	       52  C2 0028A 	    SUBL2   R2, VALUE						      ; 2616
		         10	  00   B7  91 0028E 	    CMPB    @PAT$GB_MOD_PTR, #16				      ; 2625
				       3F  12 00292 	    BNEQ    14$							      ;
		         53	       01  D0 00294 	    MOVL    #1, CLUDGE_SIZE					      ; 2639
		         50	       01  D0 00297 	    MOVL    #1, I						      ; 2640
	   51	         50	       02  78 0029A 10$:    ASHL    #2, I, R1						      ; 2642
      04   AC	         04	       51  EF 0029E 	    EXTZV   R1, #4, VALUE, R2					      ;
				       52     002A3									      ;
				       04  13 002A4 	    BEQL    11$							      ;
	   53	         50	       01  C1 002A6 	    ADDL3   #1, I, CLUDGE_SIZE					      ; 2644
	   EC	         50	       07  F3 002AA 11$:    AOBLEQ  #7, I, 10$						      ; 2640
	   50	         53	       02  78 002AE 	    ASHL    #2, CLUDGE_SIZE, R0					      ; 2646
      04   AC	         50	       00  EE 002B2 	    EXTV    #0, R0, VALUE, R1					      ;
				       51     002B7									      ;
	      FFFFFFF9   8F	       51  D1 002B8 	    CMPL    R1, #-7						      ;
				       06  1B 002BF 	    BLEQU   12$							      ;
				  08   AA  9F 002C1 	    PUSHAB  P.AAD						      ; 2648
		         69	       01  FB 002C4 	    CALLS   #1, PAT$FAO_PUT					      ;
				  04   AC  DD 002C7 12$:    PUSHL   VALUE						      ; 2649
				       53  DD 002CA 	    PUSHL   CLUDGE_SIZE						      ;
				  0C   AA  9F 002CC 	    PUSHAB  P.AAE						      ;
		         69	       03  FB 002CF 13$:    CALLS   #3, PAT$FAO_PUT					      ;
					   04 002D2 	    RET     							      ; 2651
				       01  DD 002D3 14$:    PUSHL   #1							      ; 2660
		         7E	  08   AC  7D 002D5 	    MOVQ    NEW_LENGTH, -(SP)					      ;
				  04   AC  DD 002D9 	    PUSHL   VALUE						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 7-7
; Digital Equipment Corporation
;
		  008D   C9	       04  FB 002DC 	    CALLS   #4, PAT$OUT_NUM_VAL					      ;
					   04 002E1 15$:    RET     							      ; 2406

; Routine Size:  401 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 8
; Digital Equipment Corporation
;
;	2662	GLOBAL ROUTINE PAT$SHOW_MODULE : NOVALUE =
;	2663	
;	2664	!++
;	2665	! FUNCTIONAL DESCRIPTION:
;	2666	!
;	2667	!	Show which modules from the MC are in the RST.
;	2668	!
;	2669	! FORMAL PARAMETERS:
;	2670	!
;	2671	!	NONE.
;	2672	!
;	2673	! IMPLICIT INPUTS:
;	2674	!
;	2675	!	PAT$GL_MC_PTR	-I s assumed to point to the beginning
;	2676	!			  of the MC.
;	2677	!
;	2678	! IMPLICIT OUTPUTS:
;	2679	!
;	2680	!	NONE
;	2681	!
;	2682	! COMPLETION CODES:
;	2683	!
;	2684	!	NOVALUE.
;	2685	!
;	2686	! SIDE EFFECTS:
;	2687	!
;	2688	!	A summary of the current modules which the RST knows
;	2689	!	about is written to the console.
;	2690	!
;	2691	!--
;	2692	
;	2693	BEGIN
;	2694	LOCAL
;	2695		OUTPUT_BUFFER : VECTOR [TTY_OUT_WIDTH, BYTE],		! Buffer to build report in.
;	2696		NUM_MC_ENTRIES,						! How many entries there are in the MC.
;	2697		MC_PTR : REF MC_RECORD;					! Pointer to current MC record.
;	2698	
;	2699	!++
;	2700	! Set up to do standard PATCH I/O.
;	2701	!--
;	2702	PAT$CP_OUT_STR = OUTPUT_BUFFER +1;
;	2703	PAT$GL_BUF_SIZ = 0;
;	2704	
;	2705	!++
;	2706	! Initialize the pointer that we use to 'chain' thru the module chain.
;	2707	!--
;	2708	IF ((MC_PTR = .PAT$GL_MC_PTR[MC_NEXT]) EQL 0)
;	2709	THEN
;	2710		BEGIN
;	2711		SIGNAL(PAT$_NOLCL+MSG$K_INFO);
;	2712		RETURN;
;	2713		END;
;	2714	
;	2715	!++
;	2716	! Print out the title, and then loop thru the module chain simply giving the

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 8-1
; Digital Equipment Corporation
;
;	2717	! relevant information for each module which we know about.
;	2718	!--
;	2719	NUM_MC_ENTRIES = 0;
;	2720	PAT$FAO_PUT( UPLIT (%ASCIC 'module name  symbols  size!/'));
;	2721	PAT$OUT_PUT(OUTPUT_BUFFER);
;	2722	DO
;	2723		BEGIN
;	2724		!++
;	2725		! Print out the standard information - name and 
;	2726		! whether or not it has been initialized into the RST.
;	2727		!--
;	2728		NUM_MC_ENTRIES = .NUM_MC_ENTRIES +1;
;	2729		PAT$CP_OUT_STR = OUTPUT_BUFFER +1;
;	2730		PAT$GL_BUF_SIZ = 0;
;	2731		PAT$FAO_PUT( UPLIT( %ASCIC '!15AC !3AC   ' ), MC_PTR [MC_NAME_CS],
;	2732			     (IF (.MC_PTR [MC_IN_RST]) THEN UPLIT( %ASCIC 'yes' )
;	2733						       ELSE UPLIT( %ASCIC 'no' )));
;	2734		
;	2735		!++
;	2736		! We have to call a routine to output the size
;	2737		! so that it comes out in the right RADIX.
;	2738		!--
;	2739		PAT$FAO_PUT(UPLIT(%ASCIC'!UL.'),PAT$MODULE_SIZE(.MC_PTR));
;	2740		PAT$OUT_PUT(OUTPUT_BUFFER);			! Finally output the buffer.
;	2741		END
;	2742	WHILE ((MC_PTR = .MC_PTR[MC_NEXT]) NEQ 0);
;	2743	
;	2744	!++
;	2745	! Give final summary information.
;	2746	!--
;	2747	PAT$CP_OUT_STR = OUTPUT_BUFFER +1;
;	2748	PAT$GL_BUF_SIZ = 0;
;	2749	PAT$FAO_PUT( UPLIT( %ASCIC '!/total modules:  !UL.'), .NUM_MC_ENTRIES);
;	2750	PAT$FAO_PUT( UPLIT( %ASCIC '!/remaining size: !UL.'), PAT$REPORT_FREE());
;	2751	PAT$OUT_PUT(OUTPUT_BUFFER);
;	2752	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00018 P.AAF:  .ASCII  <28>\module name  symbols  size!/\<0><0><0>		      ;
					      00038 P.AAG:  .ASCII  <13>\!15AC !3AC   \<0><0>				      ;
					      00048 P.AAH:  .ASCII  <3>\yes\						      ;
					      0004C P.AAI:  .ASCII  <2>\no\<0>						      ;
					      00050 P.AAJ:  .ASCII  <4>\!UL.\<0><0><0>					      ;
					      00058 P.AAK:  .ASCII  <22>\!/total modules:  !UL.\<0>			      ;
					      00070 P.AAL:  .ASCII  <22>\!/remaining size: !UL.\<0>			      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0F8C 002E2 	    .ENTRY  PAT$SHOW_MODULE, Save R2,R3,R7,R8,R9,R10,R11	      ; 2662
		         57 00000000G  EF  9E 002E4 	    MOVAB   PAT$CP_OUT_STR, R7					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 8-2
; Digital Equipment Corporation
;
		         58 00000000G  EF  9E 002EB 	    MOVAB   PAT$GL_RST_BEGN, R8					      ;
		         59 00000000G  EF  9E 002F2 	    MOVAB   PAT$GL_BUF_SIZ, R9					      ;
		         5A 00000000'  EF  9E 002F9 	    MOVAB   P.AAF, R10						      ;
		         5B	FCFC   CF  9E 00300 	    MOVAB   PAT$FAO_PUT, R11					      ;
		         5E	FF7C   CE  9E 00305 	    MOVAB   -132(SP), SP					      ;
		         67	  01   AE  9E 0030A 	    MOVAB   OUTPUT_BUFFER+1, PAT$CP_OUT_STR			      ; 2702
				       69  D4 0030E 	    CLRL    PAT$GL_BUF_SIZ					      ; 2703
	   50 00000000G  EF	       68  C1 00310 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R0			      ; 2708
		         52	       60  3C 00318 	    MOVZWL  (R0), MC_PTR					      ;
				       0E  12 0031B 	    BNEQ    1$							      ;
			    006D81FB   8F  DD 0031D 	    PUSHL   #7176699						      ; 2711
	      00000000G  00	       01  FB 00323 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 0032A 	    RET     							      ; 2712
				       53  D4 0032B 1$:     CLRL    NUM_MC_ENTRIES					      ; 2719
				       5A  DD 0032D 	    PUSHL   R10							      ; 2720
		         6B	       01  FB 0032F 	    CALLS   #1, PAT$FAO_PUT					      ;
				       5E  DD 00332 	    PUSHL   SP							      ; 2721
		  0130   CB	       01  FB 00334 	    CALLS   #1, PAT$OUT_PUT					      ;
				       53  D6 00339 2$:     INCL    NUM_MC_ENTRIES					      ; 2728
		         67	  01   AE  9E 0033B 	    MOVAB   OUTPUT_BUFFER+1, PAT$CP_OUT_STR			      ; 2729
				       69  D4 0033F 	    CLRL    PAT$GL_BUF_SIZ					      ; 2730
	   50	         52	       68  C1 00341 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2732
	   06	    03   A0	       01  E1 00345 	    BBC     #1, 3(R0), 3$					      ;
		         51	  30   AA  9E 0034A 	    MOVAB   P.AAH, R1						      ;
				       04  11 0034E 	    BRB     4$							      ;
		         51	  34   AA  9E 00350 3$:     MOVAB   P.AAI, R1						      ; 2733
				       51  DD 00354 4$:     PUSHL   R1							      ; 2732
				  0C   A0  9F 00356 	    PUSHAB  12(R0)						      ; 2731
				  20   AA  9F 00359 	    PUSHAB  P.AAG						      ;
		         6B	       03  FB 0035C 	    CALLS   #3, PAT$FAO_PUT					      ;
				       52  DD 0035F 	    PUSHL   MC_PTR						      ; 2739
		    4B   AB	       01  FB 00361 	    CALLS   #1, PAT$MODULE_SIZE					      ;
				       50  DD 00365 	    PUSHL   R0							      ;
				  38   AA  9F 00367 	    PUSHAB  P.AAJ						      ;
		         6B	       02  FB 0036A 	    CALLS   #2, PAT$FAO_PUT					      ;
				       5E  DD 0036D 	    PUSHL   SP							      ; 2740
		  0130   CB	       01  FB 0036F 	    CALLS   #1, PAT$OUT_PUT					      ;
	   50	         52	       68  C1 00374 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2742
		         52	       60  3C 00378 	    MOVZWL  (R0), MC_PTR					      ;
				       BC  12 0037B 	    BNEQ    2$							      ;
		         67	  01   AE  9E 0037D 	    MOVAB   OUTPUT_BUFFER+1, PAT$CP_OUT_STR			      ; 2747
				       69  D4 00381 	    CLRL    PAT$GL_BUF_SIZ					      ; 2748
				       53  DD 00383 	    PUSHL   NUM_MC_ENTRIES					      ; 2749
				  40   AA  9F 00385 	    PUSHAB  P.AAK						      ;
		         6B	       02  FB 00388 	    CALLS   #2, PAT$FAO_PUT					      ;
	      00000000G  EF	       00  FB 0038B 	    CALLS   #0, PAT$REPORT_FREE					      ; 2750
				       50  DD 00392 	    PUSHL   R0							      ;
				  58   AA  9F 00394 	    PUSHAB  P.AAL						      ;
		         6B	       02  FB 00397 	    CALLS   #2, PAT$FAO_PUT					      ;
				       5E  DD 0039A 	    PUSHL   SP							      ; 2751
		  0130   CB	       01  FB 0039C 	    CALLS   #1, PAT$OUT_PUT					      ;
					   04 003A1 	    RET     							      ; 2662

; Routine Size:  192 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 8-3
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 9
; Digital Equipment Corporation
;
;	2753	GLOBAL ROUTINE PAT$SHOW_SCOPE( PATH_VEC_PTR ) : NOVALUE =
;	2754	
;	2755	!++
;	2756	! Functional Description:
;	2757	!
;	2758	!	Print out the current scope position vector (CSP).
;	2759	!
;	2760	! Formal Parameters:
;	2761	!
;	2762	!	none.
;	2763	!
;	2764	! Implicit Inputs:
;	2765	!
;	2766	!	The CSP is a PATHNAME_VECTOR.
;	2767	!
;	2768	! Return Value:
;	2769	!
;	2770	!	NOVALUE
;	2771	!
;	2772	!--
;	2773	
;	2774	BEGIN
;	2775	
;	2776	LOCAL
;	2777		OUTPUT_BUFFER : VECTOR [TTY_OUT_WIDTH, BYTE];		! Build output message here.
;	2778	
;	2779	!++
;	2780	! Set up to use a new output buffer, and encode the standard beginning of
;	2781	! the SHOW SCOPE message into it.
;	2782	!--
;	2783	PAT$CP_OUT_STR = OUTPUT_BUFFER + 1;
;	2784	PAT$GL_BUF_SIZ = 0;
;	2785	
;	2786	PAT$FAO_PUT( UPLIT( %ASCIC 'scope: ') );
;	2787	
;	2788	!++
;	2789	! The actual thing we print out depends on whether or not there is actually
;	2790	! a CSP just now.
;	2791	!--
;	2792	IF (.PAT$GL_CSP_PTR NEQ 0)
;	2793	THEN
;	2794		PAT$PRINT_PATH( .PAT$GL_CSP_PTR )
;	2795	ELSE
;	2796		PAT$FAO_PUT( UPLIT( %ASCIC '<null>' ));
;	2797	
;	2798	!++
;	2799	! And finally force out the message.
;	2800	!--
;	2801	PAT$OUT_PUT( OUTPUT_BUFFER );
;	2802	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0


; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 9-1
; Digital Equipment Corporation
;
					      00088 P.AAM:  .ASCII  <7>\scope: \					      ;
					      00090 P.AAN:  .ASCII  <6>\<null>\<0>					      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0800 003A2 	    .ENTRY  PAT$SHOW_SCOPE, Save R11				      ; 2753
		         5B	FC58   CF  9E 003A4 	    MOVAB   PAT$FAO_PUT, R11					      ;
		         5E	FF7C   CE  9E 003A9 	    MOVAB   -132(SP), SP					      ;
	      00000000G  EF	  01   AE  9E 003AE 	    MOVAB   OUTPUT_BUFFER+1, PAT$CP_OUT_STR			      ; 2783
			    00000000G  EF  D4 003B6 	    CLRL    PAT$GL_BUF_SIZ					      ; 2784
			    00000000'  EF  9F 003BC 	    PUSHAB  P.AAM						      ; 2786
		         6B	       01  FB 003C2 	    CALLS   #1, PAT$FAO_PUT					      ;
		         50 00000000G  EF  D0 003C5 	    MOVL    PAT$GL_CSP_PTR, R0					      ; 2792
				       0B  13 003CC 	    BEQL    1$							      ;
				       50  DD 003CE 	    PUSHL   R0							      ; 2794
	      00000000V  EF	       01  FB 003D0 	    CALLS   #1, PAT$PRINT_PATH					      ;
				       09  11 003D7 	    BRB     2$							      ; 2792
			    00000000'  EF  9F 003D9 1$:     PUSHAB  P.AAN						      ; 2796
		         6B	       01  FB 003DF 	    CALLS   #1, PAT$FAO_PUT					      ;
				       5E  DD 003E2 2$:     PUSHL   SP							      ; 2801
		  0130   CB	       01  FB 003E4 	    CALLS   #1, PAT$OUT_PUT					      ;
					   04 003E9 	    RET     							      ; 2753

; Routine Size:  72 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 10
; Digital Equipment Corporation
;
;	2803	GLOBAL ROUTINE PAT$PV_TO_CS( PATH_VEC_PTR, OUTPUT_BUF ) : NOVALUE =
;	2804	
;	2805	!++
;	2806	! Functional Description:
;	2807	!
;	2808	!	Encode a pathname vector into a given vector
;	2809	!	so that what we have built is a counted string.
;	2810	!
;	2811	! Formal Parameters:
;	2812	!
;	2813	!	PATH_VEC_PTR	-A pointer to the pathname vector we
;	2814	!			 want encoded.
;	2815	!
;	2816	!	OUTPUT_BUF	-A pointer to where we build the counted string.
;	2817	!
;	2818	! Implicit Inputs:
;	2819	!
;	2820	!	We will encode up to TTY_OUTPUT_WIDTH characters.
;	2821	!	The rest of the pathname vector is ignored.
;	2822	!
;	2823	! Return Value:
;	2824	!
;	2825	!	NOVALUE.
;	2826	!
;	2827	! Side Effects:
;	2828	!
;	2829	!	The pathname is encoded into the given buffer.
;	2830	!
;	2831	!--
;	2832	
;	2833	BEGIN
;	2834	
;	2835	MAP
;	2836		OUTPUT_BUF : REF VECTOR[,BYTE],
;	2837		PATH_VEC_PTR : REF PATHNAME_VECTOR;
;	2838	
;	2839	LOCAL
;	2840		CHAR_COUNT,
;	2841		OUTPUT_PTR : REF VECTOR[,BYTE];
;	2842	
;	2843	!++
;	2844	! Make sure we are called with valid parameters.
;	2845	!--
;	2846	IF (.PATH_VEC_PTR EQL 0) OR (.OUTPUT_BUF EQL 0)
;	2847	THEN
;	2848		RETURN;
;	2849	
;	2850	!++
;	2851	! The size of the counted string we build starts off as 0.  The first element
;	2852	! in the string starts at the next character.
;	2853	!--
;	2854	CHAR_COUNT = 0;
;	2855	OUTPUT_PTR = OUTPUT_BUF[1];
;	2856	
;	2857	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 10-1
; Digital Equipment Corporation
;
;	2858	! Just encode the characters into the indicated position in the buffer until we
;	2859	! have exhausted the CS pointers in the pathname vector.
;	2860	!--
;	2861	INCR I FROM 0 TO MAX_PATH_SIZE
;	2862		DO
;	2863		BEGIN
;	2864		LOCAL
;	2865			CS_PTR : CS_POINTER;				! Each element of the pathname vector
;	2866									! is a pointer to a counted string.
;	2867	
;	2868		!++
;	2869		! Terminate when the path vector ends.
;	2870		!--
;	2871		IF ((CS_PTR = .PATH_VEC_PTR[.I]) EQL 0)
;	2872		THEN
;	2873			EXITLOOP;
;	2874	
;	2875		!++
;	2876		! Output the pathname element separation character in all but the first
;	2877		! iteration.
;	2878		!--
;	2879		IF (.I NEQ 0)
;	2880		THEN
;	2881			BEGIN
;	2882			CHAR_COUNT = .CHAR_COUNT +1;
;	2883			OUTPUT_PTR[0] = %C'\';
;	2884			OUTPUT_PTR = .OUTPUT_PTR + 1;
;	2885			END;
;	2886	
;	2887		!++
;	2888		! See if we have enough room left for the next pathname element.
;	2889		!--
;	2890		IF (NOT .CHAR_COUNT + .CS_PTR[0] LSS TTY_OUT_WIDTH)
;	2891		THEN
;	2892			EXITLOOP;
;	2893		CH$MOVE( .CS_PTR[0], CS_PTR[1], .OUTPUT_PTR );
;	2894		CHAR_COUNT = .CHAR_COUNT +.CS_PTR[0];
;	2895		OUTPUT_PTR = .OUTPUT_PTR + .CS_PTR[0];
;	2896		END;
;	2897	
;	2898	!++
;	2899	! Now make the output buffer a real counted string.
;	2900	!--
;	2901	OUTPUT_BUF[0] = .CHAR_COUNT;
;	2902	END;





					 03FC 003EA 	    .ENTRY  PAT$PV_TO_CS, Save R2,R3,R4,R5,R6,R7,R8,R9		      ; 2803
				  04   AC  D5 003EC 	    TSTL    PATH_VEC_PTR					      ; 2846
				       4A  13 003EF 	    BEQL    4$							      ;
				  08   AC  D5 003F1 	    TSTL    OUTPUT_BUF						      ;
				       45  13 003F4 	    BEQL    4$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 10-2
; Digital Equipment Corporation
;
				       58  D4 003F6 	    CLRL    CHAR_COUNT						      ; 2854
	   59	    08   AC	       01  C1 003F8 	    ADDL3   #1, OUTPUT_BUF, OUTPUT_PTR				      ; 2855
				       57  D4 003FD 	    CLRL    I							      ; 2861
		         56	  04 BC47  D0 003FF 1$:     MOVL    @PATH_VEC_PTR[I], CS_PTR				      ; 2871
				       31  13 00404 	    BEQL    3$							      ;
				       57  D5 00406 	    TSTL    I							      ; 2879
				       06  13 00408 	    BEQL    2$							      ;
				       58  D6 0040A 	    INCL    CHAR_COUNT						      ; 2882
		         89	  5C   8F  90 0040C 	    MOVB    #92, (OUTPUT_PTR)+					      ; 2883
		         50	       66  9A 00410 2$:     MOVZBL  (CS_PTR), R0					      ; 2890
		         50	       58  C0 00413 	    ADDL2   CHAR_COUNT, R0					      ;
	      00000084   8F	       50  D1 00416 	    CMPL    R0, #132						      ;
				       18  18 0041D 	    BGEQ    3$							      ;
		         50	       66  9A 0041F 	    MOVZBL  (CS_PTR), R0					      ; 2893
	   69	    01   A6	       50  28 00422 	    MOVC3   R0, 1(CS_PTR), (OUTPUT_PTR)				      ;
		         50	       66  9A 00427 	    MOVZBL  (CS_PTR), R0					      ; 2894
		         58	       50  C0 0042A 	    ADDL2   R0, CHAR_COUNT					      ;
		         50	       66  9A 0042D 	    MOVZBL  (CS_PTR), R0					      ; 2895
		         59	       50  C0 00430 	    ADDL2   R0, OUTPUT_PTR					      ;
	   C8	         57	       0A  F3 00433 	    AOBLEQ  #10, I, 1$						      ; 2861
		    08   BC	       58  90 00437 3$:     MOVB    CHAR_COUNT, @OUTPUT_BUF				      ; 2901
					   04 0043B 4$:     RET     							      ; 2803

; Routine Size:  82 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 11
; Digital Equipment Corporation
;
;	2903	GLOBAL ROUTINE PAT$PRINT_PATH( PATH_VEC_PTR ) : NOVALUE =
;	2904	
;	2905	!++
;	2906	! Functional Description:
;	2907	!
;	2908	!	Encode a pathname vector into the output stream
;	2909	!
;	2910	! Formal Parameters:
;	2911	!
;	2912	!	PATH_VEC_PTR	-A pointer to the pathname vector we want printed.
;	2913	!
;	2914	! Implicit Inputs:
;	2915	!
;	2916	!	Some exterior routine has done all the setup for
;	2917	!	PATCH standard I/O.  This routine just does 'puts'.
;	2918	!
;	2919	! Return Value:
;	2920	!
;	2921	!	NOVALUE.
;	2922	!
;	2923	! Side Effects:
;	2924	!
;	2925	!	The pathname is encoded into the current output buffer.
;	2926	!
;	2927	!--
;	2928	
;	2929	BEGIN
;	2930	MAP
;	2931		PATH_VEC_PTR : REF PATHNAME_VECTOR;
;	2932	
;	2933	LOCAL
;	2934		SYM_BUFFER : VECTOR[ TTY_OUT_WIDTH, BYTE];
;	2935	
;	2936	!++
;	2937	! First encode the characters into our own buffer - because we have a routine
;	2938	! that already knows how to do this.
;	2939	!--
;	2940	PAT$PV_TO_CS( .PATH_VEC_PTR, SYM_BUFFER );
;	2941	
;	2942	!++
;	2943	! Then simply output the pathname.
;	2944	!--
;	2945	PAT$FAO_PUT(UPLIT(%ASCIC '!AC'), SYM_BUFFER );
;	2946	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00098 P.AAO:  .ASCII  <3>\!AC\						      ;



							    .PSECT  _PAT$CODE,NOWRT,2


; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 11-1
; Digital Equipment Corporation
;
					 0000 0043C 	    .ENTRY  PAT$PRINT_PATH, Save nothing			      ; 2903
		         5E	FF7C   CE  9E 0043E 	    MOVAB   -132(SP), SP					      ;
				       5E  DD 00443 	    PUSHL   SP							      ; 2940
				  04   AC  DD 00445 	    PUSHL   PATH_VEC_PTR					      ;
		    9E   AF	       02  FB 00448 	    CALLS   #2, PAT$PV_TO_CS					      ;
				       5E  DD 0044C 	    PUSHL   SP							      ; 2945
			    00000000'  EF  9F 0044E 	    PUSHAB  P.AAO						      ;
		  FBA7   CF	       02  FB 00454 	    CALLS   #2, PAT$FAO_PUT					      ;
					   04 00459 	    RET     							      ; 2903

; Routine Size:  30 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:39:35	DBB3:[PATCH.SRC]PATSSV.B32;14					Page 12
; Digital Equipment Corporation
;
;	2947	END
;	2948	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$CODE      	  1114  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$OWN       	     4    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	   156  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582         3         0       222





; Size:		1114 code + 160 data bytes
; Run Time:	00:46.1
; Elapsed Time:	01:32.5
; Memory Used:	392 pages
; Compilation Complete
