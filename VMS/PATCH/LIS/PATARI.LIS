
; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATARI (
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.11') =
;	0007	BEGIN
;	0008	
;	0009	!
;	0010	! COPYRIGHT (c) 1977,1978
;	0011	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0012	!
;	0013	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0014	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0015	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0016	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0017	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0018	! TRANSFERRED.
;	0019	!
;	0020	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0021	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0022	! CORPORATION.
;	0023	!
;	0024	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0025	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0026	!
;	0027	
;	0028	!++
;	0029	! FACILITY:	PATCH
;	0030	!
;	0031	! ABSTRACT:
;	0032	!
;	0033	!	processes names, displays expressions, and writes into memory.
;	0034	!
;	0035	! ENVIRONMENT:	STARLET, user mode, interrupts disabled. non-AST level.
;	0036	!
;	0037	! Version:	X01.11
;	0038	!
;	0039	! History:
;	0040	!	Author:
;	0041	!		Carol Peters, 26 Oct 1976: Version 00
;	0042	!
;	0043	!
;	0044	! MODIFICATIONS:
;	0045	!
;	0046	!  NO	DATE		PROGRAMMER		PURPOSE
;	0047	!  --	----		----------		-------
;	0048	!
;	0049	!  00	19-OCT-77	K.D. MORSE		ADAPT VERSION 32 FOR PATCH.
;	0050	!  01	31-OCT-77	K.D. MORSE		ADD PAT$GET_VALUE.
;	0051	!  02	4-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 33-36.
;	0052	!						WHEN A VALUE IS LOADED ONTO THE
;	0053	!						PARSE STACK, ALSO LOAD THE TYPE (37).
;	0054	!						NO CHANGES FOR VERS 38-39.
;	0055	!  03	24-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 40-42.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 1-1
; Digital Equipment Corporation
;
;	0056	!  04	22-MAR-78	K.D. MORSE		TAKE TYPES OFF THE STACK.
;	0057	!  05	07-APR-78	K.D. MORSE		NO CHANGES FOR VERS 43-45.
;	0058	!  06	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0059	!  07	12-MAY-78	K.D. MORSE		NO CHANGES FOR 46-47.
;	0060	!  08	18-MAY-78	K.D. MORSE		NO CHANGES FOR 48.
;	0061	!  09	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0062	!  10	19-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 49.
;	0063	!  11	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 50-53.
;	0064	!
;	0065	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 2
; Digital Equipment Corporation
;
;	0066	FORWARD ROUTINE
;	0067		PAT$TRANS_NAME : NOVALUE,				! Transforms a string into a value
;	0068		PAT$MAP_ADDR : NOVALUE,					! Computes mapped address and maps image sections
;	0069		PAT$UNMAP_ADDR : NOVALUE,				! Computes unmapped address
;	0070		PAT$GET_VALUE : NOVALUE,				! Gets a stream of bytes from the image
;	0071		PAT$WRITE_MEM;						! Writes data into memory
;	0072	
;	0073	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0074	REQUIRE 'SRC$:PATRST.REQ';
;	1132	REQUIRE 'SRC$:PATPCT.REQ';
;	1148	REQUIRE 'SRC$:PATGEN.REQ';
;	1327	REQUIRE 'SRC$:BSTRUC.REQ';
;	1378	REQUIRE 'SRC$:DLLNAM.REQ';
;	1411	REQUIRE 'SRC$:VXSMAC.REQ';
;	1451	REQUIRE 'SRC$:PATTER.REQ';
;	1531	REQUIRE 'LIB$:PATMSG.REQ';
;	1689	REQUIRE 'SRC$:SYSSER.REQ';
;      R1697	SWITCHES LIST (SOURCE);
;      R1698	
;      R1699	EXTERNAL ROUTINE
;      R1700		PAT$fao_out;		! formats a line and outputs to the terminal
;      R1701	
;      R1702	SWITCHES LIST (NOSOURCE);
;	1747	REQUIRE 'SRC$:PREFIX.REQ';
;	1930	REQUIRE 'SRC$:PATPRE.REQ';
;	2070	
;	2071	EXTERNAL ROUTINE
;	2072		PAT$CREMAP,						! Create and maps image sections
;	2073		PAT$FIND_SYM;						! Matches a name with a symbol
;	2074	
;	2075	EXTERNAL
;	2076		PAT$GL_NEWVBNMX,					! Max VBN in new image used for image sections
;	2077		PAT$GL_IMGBLKS,						! Number of blocks in new image
;	2078		PAT$GL_ISELHD,						! Listhead for image section table
;	2079		PAT$GB_MOD_PTR: REF VECTOR [, BYTE],			! Pointer to current modes
;	2080		PAT$GB_LOC_TYPE: BYTE,					! Type of last location examined
;	2081		PAT$GL_LAST_LOC,					! Current location
;	2082		PAT$GL_LAST_VAL,					! Current value
;	2083		PAT$GL_SEMAN1: VECTOR,					! First semantic stack, holds tokens
;	2084		PAT$GL_SEMAN2: VECTOR;					! Second semantic stack, holds string pointers

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 3
; Digital Equipment Corporation
;
;	2085	GLOBAL ROUTINE PAT$TRANS_NAME (SEMSP, LEXEME_STG_DESC) : NOVALUE =
;	2086	
;	2087	!++
;	2088	! Functional description:
;	2089	!
;	2090	!	Transforms the simplest element of a PATCH expression
;	2091	!	into a binary value. Tokens expected are ALPHA_STR_TOKEN,
;	2092	!	DIGIT_STR_TOKEN, and the tokens for current location,
;	2093	!	last value displayed, next location, and previous location.
;	2094	!
;	2095	!	A name token is represented as a length count and a buffer
;	2096	!	address in the string descriptor. A number token is represented as
;	2097	!	a length count and a 32-bit or 64-bit precision number in
;	2098	!	the buffer address.
;	2099	!
;	2100	! Calling sequence:
;	2101	!
;	2102	!	CALLS #2, PAT$TRANS_NAME
;	2103	!
;	2104	! Inputs:
;	2105	!
;	2106	!	SEMSP		- offset in parse stack that holds the
;	2107	!			  current token.
;	2108	!	LEXEME_STG_DESC	- string descriptor to number or name
;	2109	!
;	2110	! Implicit inputs:
;	2111	!
;	2112	!	current mode, last value, current location, next location
;	2113	!
;	2114	! Outputs:
;	2115	!
;	2116	!	none
;	2117	!
;	2118	! Implicit outputs:
;	2119	!
;	2120	!	pushes a value onto the stack in the place of the token found
;	2121	!
;	2122	! Routine value:
;	2123	!
;	2124	!	novalue
;	2125	!
;	2126	! Side effects:
;	2127	!
;	2128	!	none
;	2129	!--
;	2130	
;	2131	BEGIN
;	2132	
;	2133	MAP
;	2134		LEXEME_STG_DESC : REF BLOCK [, BYTE];
;	2135	
;	2136	
;	2137	PAT$GL_SEMAN1 [.SEMSP] = (SELECTONE .PAT$GL_SEMAN1 [.SEMSP] OF
;	2138	
;	2139		SET

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 3-1
; Digital Equipment Corporation
;
;	2140	
;	2141		[DIGIT_STR_TOKEN]:
;	2142			BEGIN
;	2143			.(.LEXEME_STG_DESC [DSC$A_POINTER])
;	2144			END;
;	2145	
;	2146		[PERIOD_TOKEN]:
;	2147			BEGIN
;	2148			.PAT$GL_LAST_LOC
;	2149			END;
;	2150	
;	2151		[UP_ARROW_TOKEN]:
;	2152			BEGIN
;	2153			.PAT$GL_LAST_LOC - .PAT$GB_MOD_PTR [MODE_LENGTH]
;	2154			END;
;	2155	
;	2156		[BACKSLASH_TOKEN]:
;	2157			BEGIN
;	2158			.PAT$GL_LAST_VAL
;	2159			END;
;	2160	
;	2161		[ALPHA_STR_TOKEN]:
;	2162			BEGIN
;	2163			LOCAL
;	2164				INDEX;
;	2165			INDEX = PAT$FIND_SYM (.LEXEME_STG_DESC);
;	2166			IF (.INDEX NEQ 0)
;	2167			THEN
;	2168				BEGIN
;	2169				.SYM_VALUE (.INDEX)
;	2170				END
;	2171			ELSE SIGNAL (PAT$_NOSUCHSYM)
;	2172			END;
;	2173	
;	2174		[OTHERWISE]:
;	2175			SIGNAL (PAT$_PARSEERR);
;	2176	
;	2177		TES);
;	2178	
;	2179	END;


							    .TITLE  PATARI
							    .IDENT  \X01.11\

						    ISE$C_SIZE==	20
						    TXT$C_SIZE==	4
						    PAL$C_SIZE==	16
						    ASD$C_SIZE==	9
						    FWR$C_SIZE==	24
							    .GLOBL  PAT$GL_RST_BEGN, PAT$FAO_OUT, PAT$CREMAP, PAT$FIND_SYM
							    .GLOBL  PAT$GL_NEWVBNMX, PAT$GL_IMGBLKS, PAT$GL_ISELHD
							    .GLOBL  PAT$GB_MOD_PTR, PAT$GB_LOC_TYPE, PAT$GL_LAST_LOC
							    .GLOBL  PAT$GL_LAST_VAL, PAT$GL_SEMAN1, PAT$GL_SEMAN2
							    .WEAK   ACCESS_CHECK

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 3-2
; Digital Equipment Corporation
;

							    .PSECT  _PAT$CODE,NOWRT,2

					 0C1C 00000 	    .ENTRY  PAT$TRANS_NAME, Save R2,R3,R4,R10,R11		      ; 2085
		         5A 00000000G  EF  9E 00002 	    MOVAB   PAT$GL_SEMAN1, R10					      ;
		         5B 00000000G  EF  9E 00009 	    MOVAB   PAT$GL_LAST_LOC, R11				      ;
		         52	  04   AC  D0 00010 	    MOVL    SEMSP, R2						      ; 2137
		         54	     6A42  D0 00014 	    MOVL    PAT$GL_SEMAN1[R2], R4				      ;
		         53	       01  CE 00018 	    MNEGL   #1, R3						      ;
	      00000048   8F	       54  D1 0001B 	    CMPL    R4, #72						      ;
				       0A  12 00022 	    BNEQ    1$							      ;
		         50	  08   AC  D0 00024 	    MOVL    LEXEME_STG_DESC, R0					      ; 2143
		         53	  04   B0  D0 00028 	    MOVL    @4(R0), R3						      ; 2137
				       6B  11 0002C 	    BRB     9$							      ;
	      0000004B   8F	       54  D1 0002E 1$:     CMPL    R4, #75						      ;
				       05  12 00035 	    BNEQ    2$							      ;
		         53	       6B  D0 00037 	    MOVL    PAT$GL_LAST_LOC, R3					      ;
				       5D  11 0003A 	    BRB     9$							      ;
	      00000053   8F	       54  D1 0003C 2$:     CMPL    R4, #83						      ;
				       11  12 00043 	    BNEQ    3$							      ;
		         50 00000000G  EF  D0 00045 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2153
		         50	  01   A0  9A 0004C 	    MOVZBL  1(R0), R0						      ; 2152
	   50	         6B	       50  C3 00050 	    SUBL3   R0, PAT$GL_LAST_LOC, R0				      ;
				       40  11 00054 	    BRB     8$							      ; 2137
		         3E	       54  D1 00056 3$:     CMPL    R4, #62						      ;
				       09  12 00059 	    BNEQ    4$							      ;
		         53 00000000G  EF  D0 0005B 	    MOVL    PAT$GL_LAST_VAL, R3					      ;
				       35  11 00062 	    BRB     9$							      ;
	      00000047   8F	       54  D1 00064 4$:     CMPL    R4, #71						      ;
				       1C  12 0006B 	    BNEQ    6$							      ;
				  08   AC  DD 0006D 	    PUSHL   LEXEME_STG_DESC					      ; 2165
	      00000000G  EF	       01  FB 00070 	    CALLS   #1, PAT$FIND_SYM					      ;
				       50  D5 00077 	    TSTL    INDEX						      ; 2166
				       06  13 00079 	    BEQL    5$							      ;
		         50	  08   A0  D0 0007B 	    MOVL    8(INDEX), R0					      ;
				       15  11 0007F 	    BRB     8$							      ;
			    006D8068   8F  DD 00081 5$:     PUSHL   #7176296						      ; 2171
				       06  11 00087 	    BRB     7$							      ;
			    006D812A   8F  DD 00089 6$:     PUSHL   #7176490						      ; 2175
	      00000000G  00	       01  FB 0008F 7$:     CALLS   #1, LIB$SIGNAL					      ;
		         53	       50  D0 00096 8$:     MOVL    R0, R3						      ; 2137
		       6A42	       53  D0 00099 9$:     MOVL    R3, PAT$GL_SEMAN1[R2]				      ;
					   04 0009D 	    RET     							      ; 2085

; Routine Size:  158 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 4
; Digital Equipment Corporation
;
;	2180	GLOBAL ROUTINE PAT$MAP_ADDR (UNMAPPED_ADDR, MAPPED_ADDR_PTR, ISE_ADDR_PTR) : NOVALUE =
;	2181	
;	2182	!++
;	2183	! FUNCTIONAL DESCRIPTION:
;	2184	!
;	2185	!	Determines the mapped address given an unmapped address in the image.
;	2186	!	The input parameter is the unmapped address and the output parameters
;	2187	!	are the mapped address and image section entry address.
;	2188	!
;	2189	!	First, the image section table is searched to find out if the address
;	2190	!	to be mapped is in the image.  If not, then an error message is produced
;	2191	!	and the appropriate action is taken by the error routine (control
;	2192	!	returns for next command or to CLI).  Then the image section is mapped
;	2193	!	into memory if it is not already there.  This may also produce an
;	2194	!	error message similar to the above.  Then the mapped address is
;	2195	!	computed and returned.
;	2196	!
;	2197	!	Then the mapped address is computed and returned.
;	2198	!
;	2199	! CALLING SEQUENCE:
;	2200	!
;	2201	!	PAT$MAP_ADDR ()
;	2202	!
;	2203	! INPUTS:
;	2204	!
;	2205	!	UNMAPPED_ADDR	- The unmapped address within the image
;	2206	!	MAPPED_ADDR_PTR	- Place to store the corresponding mapped address
;	2207	!	ISE_ADDR_PTR	- Place to store the corresponding image section entry address
;	2208	!
;	2209	! IMPLICIT INPUTS:
;	2210	!
;	2211	!	The image section table must have been set up.
;	2212	!
;	2213	! OUTPUTS:
;	2214	!
;	2215	!	MAPPED_ADDR_PTR	- The corresponding mapped address
;	2216	!	ISE_ADDR_PTR	- The corresponding image section entry address
;	2217	!
;	2218	! IMPLICIT OUTPUTS:
;	2219	!
;	2220	!	NONE
;	2221	!
;	2222	! ROUTINE VALUE:
;	2223	!
;	2224	!	NONE
;	2225	!
;	2226	! SIDE EFFECTS:
;	2227	!
;	2228	!	The image section is mapped into memory if it was not before.
;	2229	!
;	2230	!--
;	2231	
;	2232	BEGIN
;	2233	
;	2234	MAP

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 4-1
; Digital Equipment Corporation
;
;	2235		ISE_ADDR_PTR : REF VECTOR,				! Address of corresponding image section table entry
;	2236		MAPPED_ADDR_PTR : REF VECTOR;				! Mapped address returned
;	2237	
;	2238	
;	2239	LOCAL
;	2240		CURRENT_ISE: REF BLOCK[,BYTE];				! Current image section entry during search
;	2241	
;	2242	!++
;	2243	! Initialize for search through image section table to find the image
;	2244	! section containing the unmapped virtual address.
;	2245	!--
;	2246	ISE_ADDR_PTR[0]=0;						! Initialize to none
;	2247	CURRENT_ISE=.PAT$GL_ISELHD;					! Set listhead of image section table
;	2248	
;	2249	!++
;	2250	! Search through the image section table to find the image section which
;	2251	! contains the unmapped virtual address.  Stop when the table runs out or the
;	2252	! iamge section is found.
;	2253	!--
;	2254	WHILE (.CURRENT_ISE NEQA 0)
;	2255	DO
;	2256		BEGIN
;	2257		IF (.UNMAPPED_ADDR GEQA .CURRENT_ISE[ISE$L_IMGVST]) AND
;	2258		   (.UNMAPPED_ADDR LEQA .CURRENT_ISE[ISE$L_IMGVEND])
;	2259		THEN
;	2260			BEGIN
;	2261			ISE_ADDR_PTR[0]=.CURRENT_ISE;			! Found starting image section
;	2262			EXITLOOP;
;	2263			END;
;	2264		CURRENT_ISE=.CURRENT_ISE[ISE$L_NXTISE];			! Set to next ISE in list
;	2265		END;
;	2266	
;	2267	!++
;	2268	! Check that the address was within the image section.
;	2269	!--
;	2270	IF (.ISE_ADDR_PTR[0] EQLA 0)
;	2271	THEN
;	2272		SIGNAL(PAT$_NSADDR,1,.UNMAPPED_ADDR);			! Starting address is not within image, report error
;	2273	
;	2274	!++
;	2275	! Check that the image section is mapped.  If not, map it.  If it cannot
;	2276	! be mapped, an error message is produced and this command is aborted with
;	2277	! a possible image exit.
;	2278	!--
;	2279	IF (.CURRENT_ISE[ISE$L_MAPVEND] EQL 0)				! Is image section not mapped?
;	2280	THEN
;	2281		PAT$CREMAP(.ISE_ADDR_PTR[0]);				! Yes, then map the image section
;	2282	
;	2283	!++
;	2284	! Now compute the corresponding mapped address.
;	2285	!--
;	2286	MAPPED_ADDR_PTR[0] = .CURRENT_ISE[ISE$L_MAPVST] + (.UNMAPPED_ADDR - .CURRENT_ISE[ISE$L_IMGVST]);
;	2287	RETURN
;	2288	END;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 4-2
; Digital Equipment Corporation
;




					 0004 0009E 	    .ENTRY  PAT$MAP_ADDR, Save R2				      ; 2180
				  0C   BC  D4 000A0 	    CLRL    @ISE_ADDR_PTR					      ; 2246
		         52 00000000G  EF  D0 000A3 	    MOVL    PAT$GL_ISELHD, CURRENT_ISE				      ; 2247
				       52  D5 000AA 1$:     TSTL    CURRENT_ISE						      ; 2254
				       19  13 000AC 	    BEQL    3$							      ;
		    04   A2	  04   AC  D1 000AE 	    CMPL    UNMAPPED_ADDR, 4(CURRENT_ISE)			      ; 2257
				       0D  1F 000B3 	    BLSSU   2$							      ;
		    08   A2	  04   AC  D1 000B5 	    CMPL    UNMAPPED_ADDR, 8(CURRENT_ISE)			      ; 2258
				       06  1A 000BA 	    BGTRU   2$							      ;
		    0C   BC	       52  D0 000BC 	    MOVL    CURRENT_ISE, @ISE_ADDR_PTR				      ; 2261
				       05  11 000C0 	    BRB     3$							      ; 2262
		         52	       62  D0 000C2 2$:     MOVL    (CURRENT_ISE), CURRENT_ISE				      ; 2264
				       E3  11 000C5 	    BRB     1$							      ; 2254
				  0C   BC  D5 000C7 3$:     TSTL    @ISE_ADDR_PTR					      ; 2270
				       12  12 000CA 	    BNEQ    4$							      ;
				  04   AC  DD 000CC 	    PUSHL   UNMAPPED_ADDR					      ; 2272
				       01  DD 000CF 	    PUSHL   #1							      ;
			    006D8112   8F  DD 000D1 	    PUSHL   #7176466						      ;
	      00000000G  00	       03  FB 000D7 	    CALLS   #3, LIB$SIGNAL					      ;
				  10   A2  D5 000DE 4$:     TSTL    16(CURRENT_ISE)					      ; 2279
				       0A  12 000E1 	    BNEQ    5$							      ;
				  0C   BC  DD 000E3 	    PUSHL   @ISE_ADDR_PTR					      ; 2281
	      00000000G  EF	       01  FB 000E6 	    CALLS   #1, PAT$CREMAP					      ;
	   50	    04   AC	  04   A2  C3 000ED 5$:     SUBL3   4(CURRENT_ISE), UNMAPPED_ADDR, R0			      ; 2286
      08   BC	         50	  0C   A2  C1 000F3 	    ADDL3   12(CURRENT_ISE), R0, @MAPPED_ADDR_PTR		      ;
					   04 000F9 	    RET     							      ; 2180

; Routine Size:  92 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 5
; Digital Equipment Corporation
;
;	2289	GLOBAL ROUTINE PAT$UNMAP_ADDR (UNMAP_ADDR_PTR, MAPPED_ADDR, ISE_ADDR_PTR) : NOVALUE =
;	2290	
;	2291	!++
;	2292	! FUNCTIONAL DESCRIPTION:
;	2293	!
;	2294	!	Determines the unmapped address given a mapped address in the image.
;	2295	!	The input parameter is the mapped address and the output parameters
;	2296	!	are the unmapped address and the image section table entry address.
;	2297	!
;	2298	!	First, the image section table is searched to find out if the address
;	2299	!	to be unmapped is in the image.  If not, then an error message is
;	2300	!	produced and the apporpriate action is taken by the error routine
;	2301	!	(control returns for next command or to CLI).
;	2302	!
;	2303	!	Then the unmapped address is computed and returned.
;	2304	!
;	2305	!	If everything was successful, the routine returns TRUE.
;	2306	!
;	2307	! CALLING SEQUENCE:
;	2308	!
;	2309	!	PAT$UNMAP_ADDR ()
;	2310	!
;	2311	! INPUTS:
;	2312	!
;	2313	!	UNMAP_ADDR_PTR	- Place to store the corresponding unmapped address
;	2314	!	MAPPED_ADDR	- The mapped address
;	2315	!	ISE_ADDR_PTR	- Place to store the corresponding image section entry address
;	2316	!
;	2317	! IMPLICIT INPUTS:
;	2318	!
;	2319	!	The image section table must have been set up.
;	2320	!
;	2321	! OUTPUTS:
;	2322	!
;	2323	!	UNMAP_ADDR_PTR	- The corresponding unmapped address
;	2324	!	ISE_ADDR_PTR	- The corresponding image section entry address
;	2325	!
;	2326	! IMPLICIT OUTPUTS:
;	2327	!
;	2328	!	none
;	2329	!
;	2330	! ROUTINE VALUE:
;	2331	!
;	2332	!	none
;	2333	!
;	2334	! SIDE EFFECTS:
;	2335	!
;	2336	!	none
;	2337	!
;	2338	!--
;	2339	
;	2340	BEGIN
;	2341	
;	2342	MAP
;	2343		UNMAP_ADDR_PTR	: REF VECTOR,				! Unmapped address to find

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 5-1
; Digital Equipment Corporation
;
;	2344		ISE_ADDR_PTR : REF VECTOR;				! Address of corresponding image section table entry
;	2345	
;	2346	LOCAL
;	2347		CURRENT_ISE: REF BLOCK[,BYTE];				! Current image section entry during search
;	2348	
;	2349	!++
;	2350	! Initialize for search through image section table to find the image
;	2351	! section containing the mapped virtual address.
;	2352	!--
;	2353	ISE_ADDR_PTR[0]=0;						! Initialize to none
;	2354	CURRENT_ISE=.PAT$GL_ISELHD;					! Set listhead of image section table
;	2355	
;	2356	!++
;	2357	! Search through the image section table to find the image section which
;	2358	! contains the mapped virtual address.  Stop when the table runs out or the
;	2359	! image section is found.
;	2360	!--
;	2361	WHILE (.CURRENT_ISE NEQA 0)
;	2362	DO
;	2363		BEGIN
;	2364		IF (.MAPPED_ADDR GEQA .CURRENT_ISE[ISE$L_MAPVST]) AND
;	2365		   (.MAPPED_ADDR LEQA .CURRENT_ISE[ISE$L_MAPVEND])
;	2366		THEN
;	2367			BEGIN
;	2368			ISE_ADDR_PTR[0]=.CURRENT_ISE;			! Found strarting image section
;	2369			EXITLOOP;
;	2370			END;
;	2371		CURRENT_ISE=.CURRENT_ISE[ISE$L_NXTISE];			! Set to next ISE in list
;	2372		END;
;	2373	
;	2374	!++
;	2375	! Check that the address was within the image section.
;	2376	!--
;	2377	IF (.ISE_ADDR_PTR[0] EQLA 0)
;	2378	THEN
;	2379		SIGNAL(PAT$_PATERR);					! Starting address is not within image, report error
;	2380	
;	2381	!++
;	2382	! Now compute the corresponding unmapped address.
;	2383	!--
;	2384	UNMAP_ADDR_PTR[0] = .CURRENT_ISE[ISE$L_IMGVST] + (.MAPPED_ADDR - .CURRENT_ISE[ISE$L_MAPVST]);
;	2385	RETURN
;	2386	END;





					 0004 000FA 	    .ENTRY  PAT$UNMAP_ADDR, Save R2				      ; 2289
				  0C   BC  D4 000FC 	    CLRL    @ISE_ADDR_PTR					      ; 2353
		         52 00000000G  EF  D0 000FF 	    MOVL    PAT$GL_ISELHD, CURRENT_ISE				      ; 2354
				       52  D5 00106 1$:     TSTL    CURRENT_ISE						      ; 2361
				       19  13 00108 	    BEQL    3$							      ;
		    0C   A2	  08   AC  D1 0010A 	    CMPL    MAPPED_ADDR, 12(CURRENT_ISE)			      ; 2364
				       0D  1F 0010F 	    BLSSU   2$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 5-2
; Digital Equipment Corporation
;
		    10   A2	  08   AC  D1 00111 	    CMPL    MAPPED_ADDR, 16(CURRENT_ISE)			      ; 2365
				       06  1A 00116 	    BGTRU   2$							      ;
		    0C   BC	       52  D0 00118 	    MOVL    CURRENT_ISE, @ISE_ADDR_PTR				      ; 2368
				       05  11 0011C 	    BRB     3$							      ; 2369
		         52	       62  D0 0011E 2$:     MOVL    (CURRENT_ISE), CURRENT_ISE				      ; 2371
				       E3  11 00121 	    BRB     1$							      ; 2361
				  0C   BC  D5 00123 3$:     TSTL    @ISE_ADDR_PTR					      ; 2377
				       0D  12 00126 	    BNEQ    4$							      ;
			    006D8132   8F  DD 00128 	    PUSHL   #7176498						      ; 2379
	      00000000G  00	       01  FB 0012E 	    CALLS   #1, LIB$SIGNAL					      ;
	   50	    08   AC	  0C   A2  C3 00135 4$:     SUBL3   12(CURRENT_ISE), MAPPED_ADDR, R0			      ; 2384
      04   BC	         50	  04   A2  C1 0013B 	    ADDL3   4(CURRENT_ISE), R0, @UNMAP_ADDR_PTR			      ;
					   04 00141 	    RET     							      ; 2289

; Routine Size:  72 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 6
; Digital Equipment Corporation
;
;	2387	GLOBAL ROUTINE PAT$GET_VALUE (UNMAPPED_ADDR, NUM_OF_BYTES, RETURN_ADDR_PTR) : NOVALUE =
;	2388	
;	2389	!++
;	2390	! FUNCTIONAL DESCRIPTION:
;	2391	!
;	2392	!	This routine takes an unmapped address and a count of bytes and
;	2393	!	returns the values of the stream described.
;	2394	!
;	2395	!	First, the starting and ending addresses of the stream are mapped.
;	2396	!	Then the number of bytes within the starting image section are moved
;	2397	!	into the return storage area.  If the stream was entirely within one
;	2398	!	image section, the routine is finished and returns.  If the ending
;	2399	!	image section is different from the starting image section, then the
;	2400	!	unmapped address of the next byte to be found is mapped to produce a
;	2401	!	new starting image section and mapped address.  The process repeats
;	2402	!	starting with a computation of the number of bytes within this image
;	2403	!	section.
;	2404	!
;	2405	!	If the stream is not entirely within the image, then the appropriate
;	2406	!	error message is produced and this patch command is ended.
;	2407	!
;	2408	! CALLING SEQUENCE:
;	2409	!
;	2410	!	PAT$GET_VALUE ()
;	2411	!
;	2412	! INPUTS:
;	2413	!
;	2414	!	UNMAPPED_ADDR	- The unmapped address for the byte stream
;	2415	!	NUM_OF_BYTES	- The number of bytes to be found in the stream
;	2416	!	RETURN_ADDR_PTR - Pointer to return storage area
;	2417	!
;	2418	! IMPLICIT INPUTS:
;	2419	!
;	2420	!	The image section table must have been set up.
;	2421	!
;	2422	! OUTPUTS:
;	2423	!
;	2424	!	none
;	2425	!
;	2426	! IMPLICIT OUTPUTS:
;	2427	!
;	2428	!	The returned storage area contains the desired values.
;	2429	!
;	2430	! ROUTINE VALUE:
;	2431	!
;	2432	!	none
;	2433	!
;	2434	! SIDE EFFECTS:
;	2435	!
;	2436	!	The image section is mapped if it was not before.
;	2437	!
;	2438	!--
;	2439	
;	2440	BEGIN
;	2441	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 6-1
; Digital Equipment Corporation
;
;	2442	MAP
;	2443		RETURN_ADDR_PTR : REF VECTOR[,BYTE];			! Address of return storage area for byte stream
;	2444	
;	2445	LOCAL
;	2446		LENGTH,							! Remaining length of byte stream to move
;	2447		PARTIAL_LENGTH,						! Number of bytes within starting image section to move
;	2448		VALUE_BUFFER,						! Holds address of return value buffer
;	2449		ST_MAPPED_ADDR: REF VECTOR[,BYTE],			! Starting mapped address of remaining byte stream
;	2450		END_MAPPED_ADDR,					! Ending mapped address of byte stream
;	2451		START_ISE: REF BLOCK[,BYTE],				! Starting image section for remaining byte stream
;	2452		END_ISE: REF BLOCK[,BYTE];				! Ending image section for remaining byte stream
;	2453	
;	2454	!++
;	2455	! Initialize number of bytes left to move.  Find the starting and ending
;	2456	! mapped addresses and image sections.
;	2457	!--
;	2458	LENGTH=.NUM_OF_BYTES;
;	2459	VALUE_BUFFER=.RETURN_ADDR_PTR;
;	2460	PAT$MAP_ADDR(.UNMAPPED_ADDR, ST_MAPPED_ADDR, START_ISE);
;	2461	PAT$MAP_ADDR(.UNMAPPED_ADDR+.NUM_OF_BYTES-1, END_MAPPED_ADDR, END_ISE);
;	2462	
;	2463	!++
;	2464	! This loop moves the bytes into the return storage area.  It only takes
;	2465	! values from the starting image section.  If the byte stream is in more than
;	2466	! one image section, a partial length is moved in, a new starting image section
;	2467	! is found, and then the next partial length is moved into the return buffer.
;	2468	! This is repeated until all the byte stream requested is moved.
;	2469	!--
;	2470	REPEAT
;	2471		BEGIN
;	2472	
;	2473		!++
;	2474		! Find the number of bytes within the starting image section.
;	2475		!--
;	2476		IF (.START_ISE EQLA .END_ISE)
;	2477		THEN
;	2478			PARTIAL_LENGTH=.LENGTH
;	2479		ELSE
;	2480			PARTIAL_LENGTH=.START_ISE[ISE$L_MAPVEND] - .ST_MAPPED_ADDR
;	2481					- .NUM_OF_BYTES + .LENGTH +1;
;	2482	
;	2483		!++
;	2484		! Move in the partial byte stream found in the starting image section.
;	2485		! Also update the remaining length to be moved.
;	2486		!--
;	2487		LENGTH=.LENGTH - .PARTIAL_LENGTH;
;	2488		VALUE_BUFFER=CH$MOVE(.PARTIAL_LENGTH, .ST_MAPPED_ADDR, .VALUE_BUFFER);
;	2489	
;	2490		!++
;	2491		! Now check if all of the desired stream has been found.  If not, find
;	2492		! a new starting image section and repeat the process.
;	2493		!--
;	2494		IF (.LENGTH EQL 0)
;	2495		THEN
;	2496			RETURN;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 6-2
; Digital Equipment Corporation
;
;	2497		PAT$MAP_ADDR(.UNMAPPED_ADDR+.NUM_OF_BYTES-.LENGTH, ST_MAPPED_ADDR, START_ISE);
;	2498	
;	2499	
;	2500	END;								! End of loop to move byte stream
;	2501	END;								! End of PAT$GET_VALUE





					 0BFC 00142 	    .ENTRY  PAT$GET_VALUE, Save R2,R3,R4,R5,R6,R7,R8,R9,R11	      ; 2387
		         5B	FF56   CF  9E 00144 	    MOVAB   PAT$MAP_ADDR, R11					      ;
		         5E	       10  C2 00149 	    SUBL2   #16, SP						      ;
		         57	  08   AC  D0 0014C 	    MOVL    NUM_OF_BYTES, LENGTH				      ; 2458
		         59	  0C   AC  D0 00150 	    MOVL    RETURN_ADDR_PTR, VALUE_BUFFER			      ; 2459
				  0C   AE  9F 00154 	    PUSHAB  START_ISE						      ; 2460
				  0C   AE  9F 00157 	    PUSHAB  ST_MAPPED_ADDR					      ;
				  04   AC  DD 0015A 	    PUSHL   UNMAPPED_ADDR					      ;
		         6B	       03  FB 0015D 	    CALLS   #3, PAT$MAP_ADDR					      ;
				  04   AE  9F 00160 	    PUSHAB  END_ISE						      ; 2461
				  04   AE  9F 00163 	    PUSHAB  END_MAPPED_ADDR					      ;
	   56	    04   AC	  08   AC  C1 00166 	    ADDL3   NUM_OF_BYTES, UNMAPPED_ADDR, R6			      ;
				  FF   A6  9F 0016C 	    PUSHAB  -1(R6)						      ;
		         6B	       03  FB 0016F 1$:     CALLS   #3, PAT$MAP_ADDR					      ;
		         50	  0C   AE  D0 00172 	    MOVL    START_ISE, R0					      ; 2476
		    04   AE	       50  D1 00176 	    CMPL    R0, END_ISE						      ;
				       05  12 0017A 	    BNEQ    2$							      ;
		         58	       57  D0 0017C 	    MOVL    LENGTH, PARTIAL_LENGTH				      ; 2478
				       0F  11 0017F 	    BRB     3$							      ; 2476
	   50	    10   A0	  08   AE  C3 00181 2$:     SUBL3   ST_MAPPED_ADDR, 16(R0), R0				      ; 2480
		         50	  08   AC  C2 00187 	    SUBL2   NUM_OF_BYTES, R0					      ; 2481
		         58	  01 A740  9E 0018B 	    MOVAB   1(LENGTH)[R0], PARTIAL_LENGTH			      ;
		         57	       58  C2 00190 3$:     SUBL2   PARTIAL_LENGTH, LENGTH				      ; 2487
	   69	    08   BE	       58  28 00193 	    MOVC3   PARTIAL_LENGTH, @ST_MAPPED_ADDR, (VALUE_BUFFER)	      ; 2488
		         59	       53  D0 00198 	    MOVL    R3, VALUE_BUFFER					      ;
				       57  D5 0019B 	    TSTL    LENGTH						      ; 2494
				       0C  13 0019D 	    BEQL    4$							      ;
				  0C   AE  9F 0019F 	    PUSHAB  START_ISE						      ; 2497
				  0C   AE  9F 001A2 	    PUSHAB  ST_MAPPED_ADDR					      ;
	   7E	         56	       57  C3 001A5 	    SUBL3   LENGTH, R6, -(SP)					      ;
				       C4  11 001A9 	    BRB     1$							      ;
					   04 001AB 4$:     RET     							      ; 2387

; Routine Size:  106 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 7
; Digital Equipment Corporation
;
;	2502	GLOBAL ROUTINE PAT$WRITE_MEM (DEST_UNMAP_ADDR, SRC_ADDRESS, LENGTH) =
;	2503	
;	2504	!++
;	2505	! FUNCTIONAL DESCRIPTION:
;	2506	!
;	2507	!	Writes a sequence of values (bytes) to memory in
;	2508	!	the user program.  The mapped destination address, image section
;	2509	!	entry, source, and number of bytes to write are all passed as parameters.
;	2510	!
;	2511	!
;	2512	!	First, the image section table is searched to find out if the
;	2513	!	addresses to be modified are in the image.  If not, then an error
;	2514	!	message is produced and the appropriate action is taken by the
;	2515	!	error routine (control returns for next command or to CLI).  Then,
;	2516	!	the image section is mapped into memory if it is not already there.
;	2517	!	This may also produce an error message similar to the above.
;	2518	!
;	2519	!	Once the starting address is mapped, the routine writes out as much
;	2520	!	of the sequence contained in that image section.  If some of the
;	2521	!	sequence is in another section, the routine sets up new parameters and
;	2522	!	calls itself recursively to write the remaining bytes.
;	2523	!
;	2524	!	If everything was successful, the routine returns TRUE.
;	2525	!
;	2526	! CALLING SEQUENCE:
;	2527	!
;	2528	!	PAT$WRITE_MEM ()
;	2529	!
;	2530	! INPUTS:
;	2531	!
;	2532	!	DEST_UNMAP_ADDR	- The address of the location to be changed
;	2533	!	START_ISE	- The address of the image section descriptor for
;	2534	!			  the first address to be written
;	2535	!	SRC_ADDRESS	- The address of where the bytes are stored.
;	2536	!	LENGTH		- The number of bytes to be written.
;	2537	!
;	2538	! IMPLICIT INPUTS:
;	2539	!
;	2540	!	The image section table must be set up.
;	2541	!
;	2542	! OUTPUTS:
;	2543	!
;	2544	!	TRUE or an error message and unwind/exit.
;	2545	!
;	2546	! IMPLICIT OUTPUTS:
;	2547	!
;	2548	!	none
;	2549	!
;	2550	! ROUTINE VALUE:
;	2551	!
;	2552	!	TRUE
;	2553	!
;	2554	! SIDE EFFECTS:
;	2555	!
;	2556	!	The value is written to memory.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 7-1
; Digital Equipment Corporation
;
;	2557	!
;	2558	!--
;	2559	
;	2560	BEGIN
;	2561	
;	2562	MAP
;	2563		DEST_UNMAP_ADDR	: REF VECTOR[,BYTE],
;	2564		SRC_ADDRESS	: REF VECTOR[,BYTE];
;	2565	
;	2566	LOCAL
;	2567		START_ISE: REF BLOCK[,BYTE],				! Image section table entry for starting address
;	2568		START_ISD: REF BLOCK[,BYTE],				! Image section descriptor for starting address
;	2569		END_ISE,						! Image section table entry for ending address
;	2570		END_MAPPED_ADDR,					! Mapped ending address to be altered
;	2571		END_UNMAP_ADDR,						! Unmapped ending address to be altered
;	2572		DEST_MAPPED_ADR: REF VECTOR[,BYTE],			! Unmapped starting address to be altered
;	2573		PARTIAL_LENGTH;						! Length to write into starting image section
;	2574	
;	2575	!++
;	2576	! Initialize for search through image section table to find the image
;	2577	! sections containing the starting and ending virtual addresses to be altered.
;	2578	!--
;	2579	PAT$MAP_ADDR(.DEST_UNMAP_ADDR, DEST_MAPPED_ADR, START_ISE);	! Find unmapped starting address
;	2580	END_UNMAP_ADDR=.DEST_UNMAP_ADDR + .LENGTH - 1;			! Get last address to be written
;	2581	
;	2582	!++
;	2583	! Find the mapped ending address to be altered.  This will map the image
;	2584	! section if it is not already mapped.
;	2585	!--
;	2586	PAT$MAP_ADDR(.END_UNMAP_ADDR, END_MAPPED_ADDR, END_ISE);	! Map the ending address
;	2587	
;	2588	!++
;	2589	! Check that both addresses were within image sections.
;	2590	!--
;	2591	IF (.START_ISE EQLA 0)
;	2592	THEN
;	2593		SIGNAL(PAT$_NSADDR,1,.DEST_UNMAP_ADDR);			! Starting address is not within image, report error
;	2594	IF (.END_ISE EQLA 0)
;	2595	THEN
;	2596		SIGNAL(PAT$_NSADDR,1,.END_UNMAP_ADDR);			! Ending address is not within image, report error
;	2597	
;	2598	!++
;	2599	! Now check if all of addresses to be altered are within the same image
;	2600	! section.  If not, then set the length to be altered in this image section.
;	2601	!--
;	2602	IF (.START_ISE NEQA .END_ISE)
;	2603	THEN
;	2604		PARTIAL_LENGTH=.START_ISE[ISE$L_MAPVEND] - .DEST_MAPPED_ADR + 1
;	2605	ELSE
;	2606		PARTIAL_LENGTH=.LENGTH;
;	2607	
;	2608	!++
;	2609	! Move the new values into this image section.
;	2610	!--
;	2611	CH$MOVE(.PARTIAL_LENGTH,SRC_ADDRESS[0],DEST_MAPPED_ADR[0]);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 7-2
; Digital Equipment Corporation
;
;	2612	
;	2613	!++
;	2614	! Check if the image section was demand zero pages.  If so, change the image
;	2615	! section descriptor to be a process private type.  The virtual block number is
;	2616	! set to zero and must be changed when the new image is written out.  The image
;	2617	! identification is set to zero.  The image section descriptor size is
;	2618	! incremented to include the additional VBN and ident fields.
;	2619	!--
;	2620	START_ISD=.START_ISE + ISE$C_SIZE;				! Get address of image section descriptor
;	2621	IF .START_ISD[ISD$V_DZRO]					! Check if was dmzro
;	2622	THEN
;	2623		BEGIN
;	2624		START_ISD[ISD$V_DZRO]=FALSE;				! Set no longer demand zero
;	2625		START_ISD[ISD$L_VBN]=.PAT$GL_NEWVBNMX;			! Record unknown VBN
;	2626		START_ISD[ISD$L_IDENT]=0;				! Set ident to zero
;	2627		START_ISD[ISD$W_SIZE]=.START_ISD[ISD$W_SIZE] + A_QUADWORD; ! Increment image section descriptor size
;	2628		PAT$GL_NEWVBNMX = .PAT$GL_NEWVBNMX + .START_ISD[ISD$W_PAGCNT] - 1; ! Increment max VBN in new image file
;	2629		PAT$GL_IMGBLKS = .PAT$GL_IMGBLKS + .START_ISD[ISD$W_PAGCNT]; ! Increment for number of new blocks in image
;	2630		END;
;	2631	
;	2632	!++
;	2633	! Check if this was a global section.  If so, warn that only the local
;	2634	! version is being patched.
;	2635	!--
;	2636	IF .START_ISD[ISD$V_GBL]
;	2637	THEN
;	2638		SIGNAL(PAT$_GBLWARN);					! Only warn of possible problem
;	2639	
;	2640	!++
;	2641	! Check if all the values were changed.  If not, then recursively call
;	2642	! this routine with new parameters.
;	2643	!--
;	2644	IF (.LENGTH EQL .PARTIAL_LENGTH)
;	2645	THEN
;	2646		RETURN TRUE
;	2647	ELSE
;	2648		BEGIN
;	2649		PAT$WRITE_MEM(DEST_UNMAP_ADDR[.PARTIAL_LENGTH],
;	2650				SRC_ADDRESS[.PARTIAL_LENGTH],
;	2651				.LENGTH-.PARTIAL_LENGTH);
;	2652		RETURN TRUE;
;	2653		END;
;	2654	
;	2655	END;





					 0EFC 001AC 	    .ENTRY  PAT$WRITE_MEM, Save R2,R3,R4,R5,R6,R7,R9,R10,R11	      ; 2502
		         59	FEEC   CF  9E 001AE 	    MOVAB   PAT$MAP_ADDR, R9					      ;
		         5A 00000000G  EF  9E 001B3 	    MOVAB   PAT$GL_NEWVBNMX, R10				      ;
		         5B 00000000G  00  9E 001BA 	    MOVAB   LIB$SIGNAL, R11					      ;
		         5E	       10  C2 001C1 	    SUBL2   #16, SP						      ;
				  0C   AE  9F 001C4 	    PUSHAB  START_ISE						      ; 2579

; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 7-3
; Digital Equipment Corporation
;
				  0C   AE  9F 001C7 	    PUSHAB  DEST_MAPPED_ADR					      ;
				  04   AC  DD 001CA 	    PUSHL   DEST_UNMAP_ADDR					      ;
		         69	       03  FB 001CD 	    CALLS   #3, PAT$MAP_ADDR					      ;
	   50	    04   AC	  0C   AC  C1 001D0 	    ADDL3   LENGTH, DEST_UNMAP_ADDR, R0				      ; 2580
	   53	         50	       01  C3 001D6 	    SUBL3   #1, R0, END_UNMAP_ADDR				      ;
				  04   AE  9F 001DA 	    PUSHAB  END_ISE						      ; 2586
				  04   AE  9F 001DD 	    PUSHAB  END_MAPPED_ADDR					      ;
				       53  DD 001E0 	    PUSHL   END_UNMAP_ADDR					      ;
		         69	       03  FB 001E2 	    CALLS   #3, PAT$MAP_ADDR					      ;
		         57	  0C   AE  D0 001E5 	    MOVL    START_ISE, R7					      ; 2591
				       0E  12 001E9 	    BNEQ    1$							      ;
				  04   AC  DD 001EB 	    PUSHL   DEST_UNMAP_ADDR					      ; 2593
				       01  DD 001EE 	    PUSHL   #1							      ;
			    006D8112   8F  DD 001F0 	    PUSHL   #7176466						      ;
		         6B	       03  FB 001F6 	    CALLS   #3, LIB$SIGNAL					      ;
		         52	  04   AE  D0 001F9 1$:     MOVL    END_ISE, R2						      ; 2594
				       0D  12 001FD 	    BNEQ    2$							      ;
				       53  DD 001FF 	    PUSHL   END_UNMAP_ADDR					      ; 2596
				       01  DD 00201 	    PUSHL   #1							      ;
			    006D8112   8F  DD 00203 	    PUSHL   #7176466						      ;
		         6B	       03  FB 00209 	    CALLS   #3, LIB$SIGNAL					      ;
		         52	       57  D1 0020C 2$:     CMPL    R7, R2						      ; 2602
				       0C  13 0020F 	    BEQL    3$							      ;
	   50	    10   A7	  08   AE  C3 00211 	    SUBL3   DEST_MAPPED_ADR, 16(R7), R0				      ; 2604
	   56	         50	       01  C1 00217 	    ADDL3   #1, R0, PARTIAL_LENGTH				      ;
				       04  11 0021B 	    BRB     4$							      ; 2602
		         56	  0C   AC  D0 0021D 3$:     MOVL    LENGTH, PARTIAL_LENGTH				      ; 2606
      08   BE	    08   BC	       56  28 00221 4$:     MOVC3   PARTIAL_LENGTH, @SRC_ADDRESS, @DEST_MAPPED_ADR	      ; 2611
	   50	         57	       14  C1 00227 	    ADDL3   #20, R7, START_ISD					      ; 2620
	   24	    08   A0	       02  E1 0022B 	    BBC     #2, 8(START_ISD), 5$				      ; 2621
		    08   A0	       04  8A 00230 	    BICB2   #4, 8(START_ISD)					      ; 2624
		    0C   A0	       6A  D0 00234 	    MOVL    PAT$GL_NEWVBNMX, 12(START_ISD)			      ; 2625
				  10   A0  D4 00238 	    CLRL    16(START_ISD)					      ; 2626
		         60	       08  A0 0023B 	    ADDW2   #8, (START_ISD)					      ; 2627
		         51	  02   A0  3C 0023E 	    MOVZWL  2(START_ISD), R1					      ; 2628
		         51	       6A  C0 00242 	    ADDL2   PAT$GL_NEWVBNMX, R1					      ;
	   6A	         51	       01  C3 00245 	    SUBL3   #1, R1, PAT$GL_NEWVBNMX				      ;
		         51	  02   A0  3C 00249 	    MOVZWL  2(START_ISD), R1					      ; 2629
	      00000000G  EF	       51  C0 0024D 	    ADDL2   R1, PAT$GL_IMGBLKS					      ;
		         09	  08   A0  E9 00254 5$:     BLBC    8(START_ISD), 6$					      ; 2636
			    006D8050   8F  DD 00258 	    PUSHL   #7176272						      ; 2638
		         6B	       01  FB 0025E 	    CALLS   #1, LIB$SIGNAL					      ;
		         56	  0C   AC  D1 00261 6$:     CMPL    LENGTH, PARTIAL_LENGTH				      ; 2644
				       12  13 00265 	    BEQL    7$							      ;
	   7E	    0C   AC	       56  C3 00267 	    SUBL3   PARTIAL_LENGTH, LENGTH, -(SP)			      ; 2651
				  08 BC46  9F 0026C 	    PUSHAB  @SRC_ADDRESS[PARTIAL_LENGTH]			      ; 2650
				  04 BC46  9F 00270 	    PUSHAB  @DEST_UNMAP_ADDR[PARTIAL_LENGTH]			      ; 2649
		  010E   C9	       03  FB 00274 	    CALLS   #3, PAT$WRITE_MEM					      ;
		         50	       01  D0 00279 7$:     MOVL    #1, R0						      ; 2652
					   04 0027C 	    RET     							      ; 2502

; Routine Size:  209 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:09:12	DBB3:[PATCH.SRC]PATARI.B32;15					Page 8
; Digital Equipment Corporation
;
;	2656	END
;	2657	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$CODE      	   637  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        10         0       224





; Size:		637 code + 0 data bytes
; Run Time:	00:38.7
; Elapsed Time:	00:59.2
; Memory Used:	365 pages
; Compilation Complete
