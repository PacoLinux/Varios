
; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATMAC (
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.15') =
;	0007	BEGIN
;	0008	
;	0009	!++
;	0010	!
;	0011	! Copyright (C) 1976, 1977
;	0012	! Digital Equipment Corporation,  Maynard, Massachusetts  01754
;	0013	!
;	0014	! This software is furnished under a license for use only on  a
;	0015	! single computer system and may be copied only with the inclu-
;	0016	! sion of the above copyright notice.  This  software,  or  any
;	0017	! other  copies  thereof, may not be provided or otherwise made
;	0018	! available to any other person except for use on  such  system
;	0019	! and  to  one who agrees to these license terms.  Title to and
;	0020	! ownership of the software shall at all times remain in DEC.
;	0021	!
;	0022	! The information in this software is subject to change without
;	0023	! notice and should not be construed as a commitment by Digital
;	0024	! Equipment Corporation.
;	0025	!
;	0026	! DEC assumes no responsibility for the use or  reliability  of
;	0027	! its software on equipment which is not supplied by DEC.
;	0028	!
;	0029	! FACILITY:	PATCH
;	0030	
;	0031	!
;	0032	! FUNCTIONAL DESCRIPTION:	VAX INSTRUCTION DECODER.
;	0033	!
;	0034	! Version:	X01.15
;	0035	!
;	0036	! AUTHOR:	KEVIN PAMMETT, 2-MAR-77: Version 00
;	0037	!
;	0038	! Revision history:
;	0039	!
;	0040	!  NO	DATE		PROGRAMMER		PURPOSE
;	0041	!  --	----		----------		-------
;	0042	!
;	0043	!  00	20-OCT-77	K.D. MORSE		ADAPT VERSION 15 FOR PATCH
;	0044	!  01	31-OCT-77	K.D. MORSE		ADAPT FOR MAPPED ADDRESSES.
;	0045	!  02	12-DEC-77	K.D. MORSE		CHANGE BRANCH DISPLACEMENT
;	0046	!						FROM ".+X" TO "BR  Y"
;	0047	!  03	28-DEC-77	K.D. MORSE		REPLACE PAT$OUT_VALUE CALLS. (18)
;	0048	!  04	5-JAN-78	K.D. MORSE		ADD CODE TO SPECIAL-CASE CASE
;	0049	!						INSTRUCTIONS TO PRINT OUT THE
;	0050	!						'DATA' FOLLOWING THE CASE
;	0051	!						INSTRUCTION STREAM.  ALSO TO
;	0052	!						ENABLE COMPUTING THE NEXT
;	0053	!						INSTRUCTION ADDRESS. (16)
;	0054	!						ADD OUT_BRNCH_OPRND. (16)
;	0055	!						CHANGE PAT$INS_DECODE ARGS TO

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 1-1
; Digital Equipment Corporation
;
;	0056	!						ENABLE MULTI-LINE OUTPUT. (16)
;	0057	!						NO CHANGES FOR 17.
;	0058	!  05	24-JAN-78	K.D. MORSE		NO CHANGES FOR 19-20.
;	0059	!  06	31-JAN-78	K.D. MORSE		CHANGED MODULE SO THAT IT WILL
;	0060	!						UNDERSTAND INSTRUCTIONS NOT AT
;	0061	!						THE PC BUT IN A BUFFER, I.E.,
;	0062	!						STREAM_PTR IS NOT NECESSARILY
;	0063	!						EQUAL TO INS_PC.  INS_PC IS NEW
;	0064	!						PARAMETER.
;	0065	!  07	17-MAR-78	K.D. MORSE		MOVE CODE TO OUTPUT A LEADING
;	0066	!						0 FOR HEX NUMBERS TO PATSSV\
;	0067	!						PAT$OUT_NUM_VAL.  THIS SHOULD
;	0068	!						FIX THE DISPLAY OF NEGATIVE
;	0069	!						DISPLACEMENTS WHEN SYMBOLIC
;	0070	!						OUTPUT IS ENABLED.
;	0071	!  08	24-MAR-78	K.D. MORSE		NO CHANGES FOR VERS 21.
;	0072	!  09	07-APR-78	K.D. MORSE		THE @# ADDRESSING MODE NOW TRIES
;	0073	!						TO SYMBOLIZE THE OPERAND. (22)
;	0074	!  10	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0075	!  11	28-APR-78	K.D. MORSE		ADD ASSEMBLER DIRECTIVE OUTPUT
;	0076	!						BY CHECKING ASD TABLE, CHK_ASD_TBL.
;	0077	!  12	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 23.
;	0078	!  13	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0079	!  14	21-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 23-24.
;	0080	!						NOW PUT OUT ONLY EFFECTIVE
;	0081	!						OPERAND FOR BRANCH AND CASE
;	0082	!						OPERANDS.  DELETE ROUTINE
;	0083	!						OUT_BRNCH_OPRND. (25)
;	0084	!						FIX CASE BUG--SET CASE_FLAG
;	0085	!						ONLY ON 3RD OPERAND. (26)
;	0086	!  15	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 27.
;	0087	!
;	0088	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 2
; Digital Equipment Corporation
;
;	0089	!
;	0090	! TABLE OF CONTENTS
;	0091	!
;	0092	FORWARD ROUTINE
;	0093		PAT$INS_DECODE,						! Decode an instruction
;	0094		INS_OPERAND,						! Print out an operand reference
;	0095		DISPLACEMENT,						! Extract displacements from instructions
;	0096		BRANCH_TYPE,						! Decide and handle branch type addressing
;	0097		INS_CONTEXT,						! Decide what context this instruction is
;	0098		PUT_REG : NOVALUE,					! Print a register reference
;	0099		CHK_ASD_TBL;						! Searches ASD table for specific PC
;	0100	
;	0101	LIBRARY 'SYS$LIBRARY:STARLET.L32';
;	0102	REQUIRE 'SRC$:PATPCT.REQ';
;	0118	REQUIRE 'SRC$:VAXOPS.REQ';					! Literals and macros related to opcodes
;	0280	REQUIRE 'SRC$:SYSLIT.REQ';					! Literals needed to call system services
;	0315	REQUIRE 'SRC$:VXSMAC.REQ';					! Widely-used standard literals
;	0355	REQUIRE 'SRC$:PATGEN.REQ';
;	0534	REQUIRE 'SRC$:VAXERR.REQ';					! Error codes
;	0620	REQUIRE 'SRC$:PREFIX.REQ';					! Structure macros
;	0803	REQUIRE 'SRC$:PATPRE.REQ';					! ASD structure definition
;	0943	
;	0944	EXTERNAL ROUTINE
;	0945		PAT$GET_VALUE : NOVALUE,				! Gets value from image byte stream
;	0946		PAT$MAP_ADDR : NOVALUE,					! Maps an image address
;	0947		PAT$CONV_R_50,						! Convert from RAD50
;	0948		PAT$FAO_PUT : NOVALUE,					! Formatted I/O to terminal
;	0949		PAT$OUT_NUM_VAL : NOVALUE,				! Output values as numbers
;	0950		PAT$OUT_SYM_VAL : NOVALUE,				! Output values as numerics or symbols
;	0951		PAT$OUT_PUT : NOVALUE;					! Flush the output buffer
;	0952	
;	0953	EXTERNAL
;	0954		PAT$CP_OUT_STR : REF VECTOR[,BYTE],			! Points to current output buffer
;	0955		PAT$GB_OPINFO : BLOCKVECTOR[ MAXOPCODE, OPTSIZE, BYTE ],
;	0956		PAT$GB_MOD_PTR : REF VECTOR[,BYTE],			! Mode data structure pointer
;	0957		PAT$GL_BUF_SIZ,						! Holds character count of output buffer
;	0958		PAT$GL_LAST_VAL;					! Branch instructions overwrite this so that
;	0959									! the user can "EX \" to trace thru a branch

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 3
; Digital Equipment Corporation
;
;	0960	!
;	0961	! Literals used only in this module
;	0962	!
;	0963	
;	0964	LITERAL
;	0965		ROUND_BRACKETS	= 0,					! These are all flag parameters to
;	0966		SQUARE_BRACKETS	= 2,					!  the routine 'PUT_REG'.
;	0967		NO_BRACKETS	= 1;
;	0968	
;	0969	MACRO
;	0970		PUTC(C)	= 						! Put 1 char into the output buffer
;     M 0971			BEGIN
;     M 0972			(.PAT$CP_OUT_STR)<0,8> = C;
;     M 0973			PAT$CP_OUT_STR = .PAT$CP_OUT_STR + 1;
;     M 0974			PAT$GL_BUF_SIZ = .PAT$GL_BUF_SIZ + 1;
;     M 0975			END %;
;	0976	
;	0977	!++
;	0978	! OWN STORAGE
;	0979	!--
;	0980	OWN
;	0981		CASE_FLAG,						! Flag to special-case CASE instructions
;	0982		MAP_FLAG;						! Flag whether or not to map the stream address

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4
; Digital Equipment Corporation
;
;	0983	GLOBAL ROUTINE PAT$INS_DECODE( STREAM_PNTR, OUTPUT_BUFFER, INS_PC, ASM_DIR_TBL ) =
;	0984	
;	0985	!++
;	0986	! 
;	0987	! FUNCTIONAL DESCRIPTION:
;	0988	!
;	0989	!	This routine is the entry point for this module.
;	0990	!
;	0991	!	This routine examines a byte stream that it is passed a pointer to, and
;	0992	!	tries to output what instructions this corresponds to symbolically.
;	0993	!
;	0994	! CALLING SEQUENCE:
;	0995	!
;	0996	!	PAT$INS_DECODE ();
;	0997	!
;	0998	! INPUTS:
;	0999	!
;	1000	!	STREAM_PNTR	- A byte pointer to the supposed instruction
;	1001	!			  stream (unmapped address or buffer address).
;	1002	!	OUTPUT_BUFFER	- This is a pointer to the beginning of the
;	1003	!			  current output buffer.
;	1004	!	INS_PC		- PC for which instruction is encoded
;	1005	!	ASM_DIR_TBL	- Address of assembler directive table descriptor
;	1006	!
;	1007	! IMPLICIT INPUTS:
;	1008	!
;	1009	!	PAT$GB_OPINFO	- Data vector that contains the instruction
;	1010	!			  mneonics and related information.
;	1011	!	PAT$CP_OUT_STR	- Points into current output buffer.
;	1012	!	PAT$GL_BUF_SIZ	- Holds character count in output buffer.
;	1013	!
;	1014	! OUTPUTS:
;	1015	!
;	1016	!	none.
;	1017	!
;	1018	! IMPLICIT OUTPUTS:
;	1019	!
;	1020	!	none.
;	1021	!
;	1022	! ROUTINE VALUE:
;	1023	!
;	1024	!	This routine returns a pointer to the beginning of the next instruction.
;	1025	!	In case there is a need to differentiate some other reasons for
;	1026	!	returning, the returned values are actually macros:
;	1027	!
;	1028	!	DETECTED:			RETURNED:
;	1029	!
;	1030	!	-UNKNOWN INSTRUCTION		INS_UNKNOWN
;	1031	!	-RESERVED INSTRUCTION		INS_RESERVED
;	1032	!	-CAN'T READ INSTRUCTION		INS_UNREADABLE
;	1033	!
;	1034	! SIDE EFFECTS:
;	1035	!
;	1036	!	The current output buffer pointer is incremented, the character
;	1037	!	representation of the instruction having been stuffed into the buffer.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4-1
; Digital Equipment Corporation
;
;	1038	!	The count of the output buffer is also incremented.
;	1039	!--
;	1040	
;	1041	BEGIN
;	1042	
;	1043	MACRO								! Local macros -- see 'routine value' above
;	1044		INS_UNREADABLE	= 0 %,
;	1045		INS_UNKNOWN	= 0 %,
;	1046		INS_RESERVED	= 0 %;
;	1047	
;	1048	MAP
;	1049		INS_PC : REF VECTOR[,LONG],				! Effect a REF LONGWORD, so can update to next PC
;	1050		STREAM_PNTR : REF VECTOR[,BYTE];
;	1051	
;	1052	LOCAL
;	1053		ASD_TBL_PTR: REF BLOCK[,BYTE],				! Points to the ASD entry matching PC
;	1054		STREAM_PTR: REF BLOCK[,BYTE],				! Points to the unmapped instr stream
;	1055		MAP_STREAM_PTR : REF VECTOR[,BYTE],			! Points to the mapped instr stream
;	1056		ISE_ADDR,						! Address of ISE
;	1057		OPCODE,							! INstruction opcode
;	1058		OPRNDS;							! Number of operands for instruction
;	1059	
;	1060	!++
;	1061	! Determine if the instruction stream is at the PC it was encoded for or if
;	1062	! it is in a buffer.  Then set a MAP_FLAG indicating whether or not to map
;	1063	! STREAM_PTR in order to access the byte stream.
;	1064	!--
;	1065	IF (.INS_PC[0] EQLA .STREAM_PNTR)
;	1066	THEN
;	1067		MAP_FLAG = TRUE
;	1068	ELSE
;	1069		MAP_FLAG = FALSE;
;	1070	
;	1071	!++
;	1072	! Use an OWN copy of the formal, STREAM_PNTR, because the compiler does not
;	1073	! do this automatically, and because this module writes into this variable.
;	1074	!--
;	1075	STREAM_PTR = .STREAM_PNTR;
;	1076	IF .MAP_FLAG							! Is instruction at PC?
;	1077	THEN
;	1078		PAT$MAP_ADDR(.STREAM_PTR, MAP_STREAM_PTR, ISE_ADDR)	! Yes, get mapped address
;	1079	ELSE
;	1080		MAP_STREAM_PTR = .STREAM_PNTR;				! No, use buffer address
;	1081	
;	1082	!++
;	1083	! Set up to special-case CASE instructions.
;	1084	!--
;	1085	CASE_FLAG = 0;
;	1086	
;	1087	!++
;	1088	! Check if the PC to be output is known to contain an assembler directive.
;	1089	! If so, then CHK_ASD_TBL finds the appropriate "OPCODE" to offset into the
;	1090	! OPINFO table and also the pointer into the ASD table.
;	1091	!--
;	1092	IF ((OPCODE = CHK_ASD_TBL(.INS_PC[0], ASD_TBL_PTR, .ASM_DIR_TBL)) EQL FALSE)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4-2
; Digital Equipment Corporation
;
;	1093	THEN
;	1094		BEGIN
;	1095		!++
;	1096		! The instruction is not an assembler directive.  Therefore, pick up
;	1097		! the opcode and check it for validity.  Then increment the instruction
;	1098		! pointers past the opcode.
;	1099		! NOTE:  A MAPPED ADDRESS MAY BE DOTTED ONLY IF IT IS DOTTED TO ACQUIRE 
;	1100		! ONE AND ONLY ONE BYTE.
;	1101		!--
;	1102		IF( (OPCODE = .MAP_STREAM_PTR[0]) LSS 0  OR  (.OPCODE GTR (MAXOPCODE-NUM_ASM_DIR)) )
;	1103		THEN
;	1104			RETURN(INS_UNKNOWN);				! Unrecognized opcode
;	1105		STREAM_PTR = .STREAM_PTR + 1;
;	1106		INS_PC[0] = .INS_PC[0] + 1;
;	1107		END;
;	1108	
;	1109	!++
;	1110	! Output the character sequence which corresponds to the opcode.
;	1111	!--
;	1112	PAT$CONV_R_50( .PAT$GB_OPINFO[ .OPCODE, OP_NAME], .PAT$CP_OUT_STR );
;	1113	PAT$CP_OUT_STR = .PAT$CP_OUT_STR + OP_CH_SIZE;
;	1114	PAT$GL_BUF_SIZ = .PAT$GL_BUF_SIZ + OP_CH_SIZE;
;	1115	
;	1116	!++
;	1117	! Make sure that this is a recognized opcode, i.e., the number of expected
;	1118	! operands is known.  Also put out two spaces since some opcodes take up the
;	1119	! full OP_CH_SIZE field printed, above.
;	1120	!--
;	1121	PAT$FAO_PUT( UPLIT( %ASCIC '  ' ) );
;	1122	IF( .PAT$GB_OPINFO[ .OPCODE, OP_NUMOPS] EQL NOT_AN_OP )
;	1123	THEN
;	1124		!++
;	1125		! The opcode is reserved, so not enough is known about it to go any further.
;	1126		!--
;	1127		RETURN(INS_RESERVED);
;	1128	
;	1129	!++
;	1130	! Check if this is a case instruction.
;	1131	!--
;	1132	IF (.OPCODE EQL OP_CASEB) OR (.OPCODE EQL OP_CASEW) OR (.OPCODE EQL OP_CASEL)
;	1133	THEN
;	1134		CASE_FLAG = -1;
;	1135	
;	1136	!++
;	1137	! Loop, encoding how each operand is referenced.
;	1138	!--
;	1139	IF ((OPRNDS = .PAT$GB_OPINFO[.OPCODE, OP_NUMOPS]) EQL ASM_DIR_OP)
;	1140	THEN
;	1141		OPRNDS = .ASD_TBL_PTR[ASD$B_NUM_OPRND];
;	1142	INCR I FROM 1 TO .OPRNDS
;	1143	DO
;	1144		BEGIN
;	1145		IF( (STREAM_PTR = INS_OPERAND( .STREAM_PTR, .I, .OPCODE, INS_PC[0] )) EQL 0 )
;	1146		THEN
;	1147			RETURN(INS_UNREADABLE);				! Decoding failure - probably do to accessability.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4-3
; Digital Equipment Corporation
;
;	1148		IF (.I NEQ 0) AND (.I LSS .OPRNDS)
;	1149		THEN
;	1150			PUTC(',');
;	1151		END;
;	1152	
;	1153	
;	1154	!++
;	1155	! CASE instructions are special-cased as they do not follow the syntax of
;	1156	! other instructions, namely an opcode followed by a fixed number of operands.
;	1157	! They are followed by N+1 words (offsets), where N is the last operand of the
;	1158	! instruction.  Therefore this case can only be handled if the operand was
;	1159	! given as a literal.  If this is TRUE, the offsets are printed.
;	1160	!--
;	1161	IF (.CASE_FLAG GTR 0)
;	1162	THEN
;	1163		BEGIN
;	1164		!++
;	1165		! The flag supposedly contains N+1.  There are N+1 offsets to print.
;	1166		!--
;	1167		LOCAL
;	1168			CASE_OFFSET : SIGNED WORD;			! Buffer to hold offsets
;	1169	
;	1170		!++
;	1171		! Loop, getting each offset and printing one offset per line.
;	1172		! Update the instruction-stream pointer after each offset.
;	1173		!--
;	1174		IF (.CASE_FLAG GTR 0)
;	1175		THEN
;	1176			INCR I FROM 1 TO .CASE_FLAG
;	1177			DO
;	1178			BEGIN
;	1179			IF .MAP_FLAG					! Is instruction at PC?
;	1180			THEN
;	1181				PAT$GET_VALUE (.STREAM_PTR, A_WORD, CASE_OFFSET) ! Yes, map address
;	1182			ELSE
;	1183				CASE_OFFSET = .STREAM_PTR[0,0,16,1];	! No, take offset from buffer
;	1184			PAT$OUT_PUT(.OUTPUT_BUFFER);
;	1185			PAT$CP_OUT_STR = .OUTPUT_BUFFER + 1;
;	1186			PAT$GL_BUF_SIZ = 0;
;	1187			PAT$FAO_PUT(UPLIT (%ASCIC '!_!_'));
;	1188			PAT$OUT_SYM_VAL(.INS_PC[0] + .CASE_OFFSET, A_WORD, NO_OVERRIDE);
;	1189			STREAM_PTR = .STREAM_PTR + A_WORD;
;	1190			END;
;	1191		END;
;	1192	
;	1193	!++
;	1194	! Return a pointer to the beginning of the next instruction.
;	1195	!--
;	1196	RETURN(.STREAM_PTR);
;	1197	END;


							    .TITLE  PATMAC
							    .IDENT  \X01.15\


; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4-4
; Digital Equipment Corporation
;
							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .ASCII  <2>\  \<0>						      ;
					      00004 P.AAB:  .ASCII  <4>\!_!_\<0><0><0>					      ;

							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 CASE_FLAG:
							    .BLKB   4
					      00004 MAP_FLAG:
							    .BLKB   4

						    ISE$C_SIZE==	20
						    TXT$C_SIZE==	4
						    PAL$C_SIZE==	16
						    ASD$C_SIZE==	9
						    FWR$C_SIZE==	24
							    .GLOBL  PAT$GET_VALUE, PAT$MAP_ADDR, PAT$CONV_R_50, PAT$FAO_PUT
							    .GLOBL  PAT$OUT_NUM_VAL, PAT$OUT_SYM_VAL, PAT$OUT_PUT
							    .GLOBL  PAT$CP_OUT_STR, PAT$GB_OPINFO, PAT$GB_MOD_PTR
							    .GLOBL  PAT$GL_BUF_SIZ, PAT$GL_LAST_VAL

							    .PSECT  _PAT$CODE,NOWRT,2

					 0FBC 00000 	    .ENTRY  PAT$INS_DECODE, Save R2,R3,R4,R5,R7,R8,R9,R10,R11	      ; 0983
		         57 00000000G  EF  9E 00002 	    MOVAB   PAT$FAO_PUT, R7					      ;
		         58 00000000G  EF  9E 00009 	    MOVAB   PAT$GL_BUF_SIZ, R8					      ;
		         59 00000000G  EF  9E 00010 	    MOVAB   PAT$GB_OPINFO+4, R9					      ;
		         5A 00000000G  EF  9E 00017 	    MOVAB   PAT$CP_OUT_STR, R10					      ;
		         5B 00000000'  EF  9E 0001E 	    MOVAB   MAP_FLAG, R11					      ;
		         5E	       10  C2 00025 	    SUBL2   #16, SP						      ;
		    04   AC	  0C   BC  D1 00028 	    CMPL    @INS_PC, STREAM_PNTR				      ; 1065
				       05  12 0002D 	    BNEQ    1$							      ;
		         6B	       01  D0 0002F 	    MOVL    #1, MAP_FLAG					      ; 1067
				       02  11 00032 	    BRB     2$							      ; 1065
				       6B  D4 00034 1$:     CLRL    MAP_FLAG						      ; 1069
		         55	  04   AC  D0 00036 2$:     MOVL    STREAM_PNTR, STREAM_PTR				      ; 1075
		         11	       6B  E9 0003A 	    BLBC    MAP_FLAG, 3$					      ; 1076
				  0C   AE  9F 0003D 	    PUSHAB  ISE_ADDR						      ; 1078
				  0C   AE  9F 00040 	    PUSHAB  MAP_STREAM_PTR					      ;
				       55  DD 00043 	    PUSHL   STREAM_PTR						      ;
	      00000000G  EF	       03  FB 00045 	    CALLS   #3, PAT$MAP_ADDR					      ;
				       05  11 0004C 	    BRB     4$							      ; 1076
		    08   AE	  04   AC  D0 0004E 3$:     MOVL    STREAM_PNTR, MAP_STREAM_PTR				      ; 1080
				  FC   AB  D4 00053 4$:     CLRL    CASE_FLAG						      ; 1085
				  10   AC  DD 00056 	    PUSHL   ASM_DIR_TBL						      ; 1092
				  08   AE  9F 00059 	    PUSHAB  ASD_TBL_PTR						      ;
				  0C   BC  DD 0005C 	    PUSHL   @INS_PC						      ;
	      00000000V  EF	       03  FB 0005F 	    CALLS   #3, CHK_ASD_TBL					      ;
		         53	       50  D0 00066 	    MOVL    R0, OPCODE						      ;
				       19  12 00069 	    BNEQ    7$							      ;
		         53	  08   BE  9A 0006B 	    MOVZBL  @MAP_STREAM_PTR, OPCODE				      ; 1102
				       53  D5 0006F 	    TSTL    OPCODE						      ;
				       03  18 00071 	    BGEQ    6$							      ;
				     0101  31 00073 5$:     BRW     18$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4-5
; Digital Equipment Corporation
;
	      000000FC   8F	       53  D1 00076 6$:     CMPL    OPCODE, #252					      ;
				       F4  14 0007D 	    BGTR    5$							      ;
				       55  D6 0007F 	    INCL    STREAM_PTR						      ; 1105
				  0C   BC  D6 00081 	    INCL    @INS_PC						      ; 1106
				       6A  DD 00084 7$:     PUSHL   PAT$CP_OUT_STR					      ; 1112
	   52	         53	       06  C5 00086 	    MULL3   #6, OPCODE, R2					      ;
				  FC A942  9F 0008A 	    PUSHAB  PAT$GB_OPINFO[R2]					      ;
				       9E  DD 0008E 	    PUSHL   @(SP)+						      ;
	      00000000G  EF	       02  FB 00090 	    CALLS   #2, PAT$CONV_R_50					      ;
		         6A	       06  C0 00097 	    ADDL2   #6, PAT$CP_OUT_STR					      ; 1113
		         68	       06  C0 0009A 	    ADDL2   #6, PAT$GL_BUF_SIZ					      ; 1114
			    00000000'  EF  9F 0009D 	    PUSHAB  P.AAA						      ; 1121
		         67	       01  FB 000A3 	    CALLS   #1, PAT$FAO_PUT					      ;
	 6942	         04	       00  EC 000A6 	    CMPV    #0, #4, PAT$GB_OPINFO+4[R2], #-1			      ; 1122
			    FFFFFFFF   8F     000AB									      ;
				       C1  13 000B0 	    BEQL    5$							      ;
	      0000008F   8F	       53  D1 000B2 	    CMPL    OPCODE, #143					      ; 1132
				       12  13 000B9 	    BEQL    8$							      ;
	      000000AF   8F	       53  D1 000BB 	    CMPL    OPCODE, #175					      ;
				       09  13 000C2 	    BEQL    8$							      ;
	      000000CF   8F	       53  D1 000C4 	    CMPL    OPCODE, #207					      ;
				       04  12 000CB 	    BNEQ    9$							      ;
		    FC   AB	       01  CE 000CD 8$:     MNEGL   #1, CASE_FLAG					      ; 1134
	 6942	         04	       00  EE 000D1 9$:     EXTV    #0, #4, PAT$GB_OPINFO+4[R2], OPRNDS			      ; 1139
				       54     000D6									      ;
	      FFFFFFFE   8F	       54  D1 000D7 	    CMPL    OPRNDS, #-2						      ;
				       08  12 000DE 	    BNEQ    10$							      ;
		         50	  04   AE  D0 000E0 	    MOVL    ASD_TBL_PTR, R0					      ; 1141
		         54	  08   A0  9A 000E4 	    MOVZBL  8(R0), OPRNDS					      ;
				       52  D4 000E8 10$:    CLRL    I							      ; 1142
				       24  11 000EA 	    BRB     12$							      ;
				  0C   AC  DD 000EC 11$:    PUSHL   INS_PC						      ; 1145
				       0C  BB 000EF 	    PUSHR   #^M<R2,R3>						      ;
				       55  DD 000F1 	    PUSHL   STREAM_PTR						      ;
	      00000000V  EF	       04  FB 000F3 	    CALLS   #4, INS_OPERAND					      ;
		         55	       50  D0 000FA 	    MOVL    R0, STREAM_PTR					      ;
				       78  13 000FD 	    BEQL    18$							      ;
				       52  D5 000FF 	    TSTL    I							      ; 1148
				       0D  13 00101 	    BEQL    12$							      ;
		         54	       52  D1 00103 	    CMPL    I, OPRNDS						      ;
				       08  18 00106 	    BGEQ    12$							      ;
		    00   BA	       2C  90 00108 	    MOVB    #44, @PAT$CP_OUT_STR				      ; 1150
				       6A  D6 0010C 	    INCL    PAT$CP_OUT_STR					      ;
				       68  D6 0010E 	    INCL    PAT$GL_BUF_SIZ					      ;
	   D8	         52	       54  F3 00110 12$:    AOBLEQ  OPRNDS, I, 11$					      ; 1142
		         53	  FC   AB  D0 00114 	    MOVL    CASE_FLAG, R3					      ; 1161
				       50  D4 00118 	    CLRL    R0							      ;
				       53  D5 0011A 	    TSTL    R3							      ;
				       55  15 0011C 	    BLEQ    17$							      ;
				       50  D6 0011E 	    INCL    R0							      ;
		         50	       50  E9 00120 	    BLBC    R0, 17$						      ; 1174
	   54	    08   AC	       01  C1 00123 	    ADDL3   #1, OUTPUT_BUFFER, R4				      ; 1185
				       52  D4 00128 	    CLRL    I							      ; 1176
				       43  11 0012A 	    BRB     16$							      ;
		         0F	       6B  E9 0012C 13$:    BLBC    MAP_FLAG, 14$					      ; 1179

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 4-6
; Digital Equipment Corporation
;
				       5E  DD 0012F 	    PUSHL   SP							      ; 1181
				       02  DD 00131 	    PUSHL   #2							      ;
				       55  DD 00133 	    PUSHL   STREAM_PTR						      ;
	      00000000G  EF	       03  FB 00135 	    CALLS   #3, PAT$GET_VALUE					      ;
				       03  11 0013C 	    BRB     15$							      ; 1179
		         6E	       65  B0 0013E 14$:    MOVW    (STREAM_PTR), CASE_OFFSET				      ; 1183
				  08   AC  DD 00141 15$:    PUSHL   OUTPUT_BUFFER					      ; 1184
	      00000000G  EF	       01  FB 00144 	    CALLS   #1, PAT$OUT_PUT					      ;
		         6A	       54  D0 0014B 	    MOVL    R4, PAT$CP_OUT_STR					      ; 1185
				       68  D4 0014E 	    CLRL    PAT$GL_BUF_SIZ					      ; 1186
			    00000000'  EF  9F 00150 	    PUSHAB  P.AAB						      ; 1187
		         67	       01  FB 00156 	    CALLS   #1, PAT$FAO_PUT					      ;
		         7E	       02  7D 00159 	    MOVQ    #2, -(SP)						      ; 1188
		         50	  08   AE  32 0015C 	    CVTWL   CASE_OFFSET, R0					      ;
	   7E	    0C   BC	       50  C1 00160 	    ADDL3   R0, @INS_PC, -(SP)					      ;
	      00000000G  EF	       03  FB 00165 	    CALLS   #3, PAT$OUT_SYM_VAL					      ;
		         55	       02  C0 0016C 	    ADDL2   #2, STREAM_PTR					      ; 1189
	   B9	         52	       53  F3 0016F 16$:    AOBLEQ  R3, I, 13$						      ; 1176
		         50	       55  D0 00173 17$:    MOVL    STREAM_PTR, R0					      ; 1196
					   04 00176 	    RET     							      ;
				       50  D4 00177 18$:    CLRL    R0							      ; 0983
					   04 00179 	    RET     							      ;

; Routine Size:  378 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5
; Digital Equipment Corporation
;
;	1198	ROUTINE INS_OPERAND( STREAM_PTR, INDEX, OPCODE, INS_PC ) =
;	1199	
;	1200	!++
;	1201	! FUNCTIONAL DESCRIPTION:
;	1202	!
;	1203	!	Print out an instruction operand.
;	1204	!
;	1205	! WARNING:
;	1206	!
;	1207	!	1) There is code in the 'DEFERRED' macro which will cease
;	1208	!	   to work when/if the representation of TRUE and FALSE are changed.
;	1209	!	2) The local macros, below, check for the indicated addressing
;	1210	!	   modes only given that they appear in the code where they
;	1211	!	   do - i.e., the checks take advantage of what is known about
;	1212	!	   which cases already have been eliminated, etc.
;	1213	!
;	1214	! CALLING SEQUENCE:
;	1215	!
;	1216	!	INS_OPERAND (STREAM_PTR, INDEX, OPCODE);
;	1217	!
;	1218	! INPUTS:
;	1219	!
;	1220	!	STREAM_PTR	- A byte pointer to the first byte of the instruction stream
;	1221	!			  which begins this operand.  This byte is the dominant
;	1222	!			  mode.  This is an unmapped address.
;	1223	!	INDEX 		- Ordinal of which operand to decode.  This is needed to
;	1224	!			  decide the 'CONTEXT' for this operand if PC-relative
;	1225	!			  addressing mode is used.
;	1226	!	OPCODE		- The opcode of instruction being decoded.
;	1227	!			  (This parameter has already been validated.)
;	1228	!	INS_PC		- PC for which this instruction was encoded
;	1229	!
;	1230	! IMPLICIT INPUTS:
;	1231	!
;	1232	!	MAP_FLAG - TRUE if STREAM_PTR is an unmapped address (the PC),
;	1233	!		   FALSE if STREAM_PTR is a temporary buffer address.
;	1234	
;	1235	!
;	1236	! OUTPUTS:
;	1237	!
;	1238	!	The current operand is written into the current output buffer in
;	1239	!	machine-language format.
;	1240	!
;	1241	! IMPLICIT OUTPUTS:
;	1242	!
;	1243	!	none
;	1244	!
;	1245	! ROUTINE VALUE:
;	1246	!
;	1247	!	-The instruction-stream byte pointer, incremented to reflect the number
;	1248	!	of bytes used for this operand.  THis pointer should point to the
;	1249	!	beginning of either the next instruction, or the next operand,
;	1250	!	depending on how many operands the current instruction has.
;	1251	!	-If the operand cannot be decoded, FALSE is returned.
;	1252	!

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-1
; Digital Equipment Corporation
;
;	1253	! SIDE EFFECTS:
;	1254	!
;	1255	!	If the instruction pointer is updated incorrectly, then the supposed
;	1256	!	next instruction will be wrong.  This will cause a completely misleading
;	1257	!	'instruction' to be output on the next call to this routine.
;	1258	!--
;	1259	
;	1260	BEGIN
;	1261	
;	1262	!++
;	1263	! Local macros used to check for the indicated addressing modes.
;	1264	! See 'WARNING:', above.
;	1265	!--
;	1266	MACRO
;	1267		REGISTR(MODE) = (MODE EQL 5) %,				! Register mode addressing
;	1268		DEFERRED(MODE) = ( MODE LSS 0 AND MODE ) %,		! Those which begin with '@' are
;	1269									!  9 - @(RN)+,
;	1270									!  B - @BYTE(RN),
;	1271									!  D - @WORD(RN),
;	1272									!  F - @LONG(RN),
;	1273									! or any of these + indexing
;	1274									! The thing which is common to only these
;	1275									! modes is that they all have the sign
;	1276									! bit set and are odd!
;	1277		AUTODEC(MODE) = (MODE EQL 7) %,				! See if mode is auto decrement.
;	1278		AUTOINC(MODE) = (MODE LSS 0) %;				! mode is auto increment
;	1279									! This check depends upon the fact that
;	1280									! the mode was extracted with sign extension,
;	1281									! and that many of the other possibilities
;	1282									! were already eliminated.
;	1283	
;	1284	MAP
;	1285		INS_PC : REF VECTOR[,LONG],				! Effect a REF LONG, enabling an update of the PC
;	1286		STREAM_PTR : REF BLOCK[,BYTE];
;	1287	
;	1288	LOCAL
;	1289		STREAM_VALUE : BLOCK[4,BYTE],				! Values from instruction stream
;	1290		NEW_STR_PTR,						! New stream pointer
;	1291		FLAG,							! Indicates the type of displacement
;	1292		DISPL,							! The actual displacement
;	1293		DISP_SIZE,						! The size, in bytes, of a displacement
;	1294		DOM_OPRND,						! Operand extracted from the
;	1295									!  dominant mode byte.  It may be Rn,
;	1296									!  Rx, or a literal (SRM notation).
;	1297		DOM_MODE;						! The primary addressing mode comes from
;	1298									!  this dominant byte as well.
;	1299	
;	1300	!++
;	1301	! Consider the possibility of so-called 'branch type' addressing first before
;	1302	! anything else, because otherwise short literals cannot be differentiated
;	1303	! from byte displacement branches.
;	1304	!--
;	1305	IF( (NEW_STR_PTR = BRANCH_TYPE( .STREAM_PTR, .INDEX, .OPCODE, INS_PC[0] )) NEQ 0 )
;	1306	THEN
;	1307		RETURN( .NEW_STR_PTR );					! Success, return new stream pointer

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-2
; Digital Equipment Corporation
;
;	1308	
;	1309	!++
;	1310	! Extract the needed fields from the first byte of the operand specifier.
;	1311	! Extract some fields with sign extension because that makes various tests
;	1312	! more convenient.
;	1313	!--
;	1314	IF .MAP_FLAG							! Is the instruction at PC?
;	1315	THEN
;	1316		PAT$GET_VALUE(.STREAM_PTR, A_BYTE, STREAM_VALUE)	! Yes, map address
;	1317	ELSE
;	1318		STREAM_VALUE = .STREAM_PTR[0, 0, (A_BYTE * BITS_PER_BYTE), 0]; ! No, get value from buffer
;	1319	DOM_MODE = .STREAM_VALUE[ AMODE ];
;	1320	DOM_OPRND = .STREAM_VALUE[ AREG ];
;	1321	
;	1322	!++
;	1323	! Take special action for indexing mode.
;	1324	!--
;	1325	IF( .DOM_MODE EQL INDEXING_MODE )
;	1326	THEN
;	1327		BEGIN
;	1328		!++
;	1329		! Handle indexing mode recursively.
;	1330		!--
;	1331		INS_PC[0] = .INS_PC[0] + 1;
;	1332		IF( (STREAM_PTR = INS_OPERAND( STREAM_PTR[ NEXT_FIELD(1) ], .INDEX, .OPCODE, INS_PC[0] )) EQL 0 )
;	1333		THEN
;	1334			RETURN(FALSE);					! Read access failure
;	1335		PUT_REG( .DOM_OPRND, SQUARE_BRACKETS );
;	1336		RETURN( .STREAM_PTR );
;	1337		END;
;	1338	
;	1339	!++
;	1340	! Simple modes are easier:
;	1341	!
;	1342	! First see if there will be a literal or displacement in the operand reference.
;	1343	!--
;	1344	IF( (STREAM_PTR = DISPLACEMENT( .STREAM_PTR, FLAG, DISPL, DISP_SIZE, .INDEX, .OPCODE, INS_PC[0] )) EQL 0 )
;	1345	THEN
;	1346		RETURN(FALSE);						! Read access failure
;	1347	
;	1348	!++
;	1349	! Begin checking for the addressing modes which begin with special characters
;	1350	! that have to be printed first.  An attempt is made to handle different cases
;	1351	! first.
;	1352	!--
;	1353	IF (DEFERRED(.DOM_MODE))
;	1354	THEN
;	1355		PUTC('@')
;	1356	ELSE
;	1357		IF (AUTODEC(.DOM_MODE))
;	1358		THEN
;	1359			PUTC('-');
;	1360	
;	1361	!++
;	1362	! Next consider displacements or literals.  Whether or not this is the case

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-3
; Digital Equipment Corporation
;
;	1363	! has already been determined in the call to 'DISPLACEMENT', above.
;	1364	!--
;	1365	IF (.FLAG)
;	1366	THEN
;	1367		BEGIN
;	1368		!++
;	1369		! There is a literal, so print it.  The flag value returned by routine
;	1370		! DISPLACEMENT distinguishes when there should be a '#' as opposed to
;	1371		! when the number is actually a displacement off a register.
;	1372		!--
;	1373		IF (.FLAG GTR 0)
;	1374		THEN
;	1375			BEGIN
;	1376			PUTC('#');
;	1377	
;	1378			!++
;	1379			! Except for @# mode, make .DOM_OPRND NEQ PC_REG so that later
;	1380			! only checking that will also tell us that .FLAG is GTR 0.
;	1381			!--
;	1382			IF (NOT DEFERRED (.DOM_MODE))
;	1383			THEN
;	1384				DOM_OPRND = PC_REG +1;
;	1385			IF (.CASE_FLAG NEQ 0) AND (.INDEX EQL 3)
;	1386			THEN
;	1387				CASE_FLAG = .DISPL + 1;
;	1388			END
;	1389		ELSE
;	1390			BEGIN
;	1391			OWN
;	1392				DISPL_ID : VECTOR[4,BYTE]
;	1393				INITIAL( BYTE( 'B', 'W', '?', 'L') );
;	1394	
;	1395			!++
;	1396			! Print an indication of the displacement size.
;	1397			!--
;	1398			PAT$FAO_PUT( UPLIT( %ASCIC '!AD^' ), 1, DISPL_ID[ .DISP_SIZE -1 ] );
;	1399			END;
;	1400	
;	1401		!++
;	1402		! If the register is the PC, then the absolute address is output.
;	1403		!--
;	1404		IF (.FLAG LSS 0) AND (.DOM_OPRND EQL PC_REG)
;	1405		THEN
;	1406			BEGIN
;	1407			!++
;	1408			! Pick up the displacement and make it into an effective address.
;	1409			!--
;	1410			DISP_SIZE = A_LONGWORD;
;	1411			DISPL = .DISPL + .INS_PC[0];
;	1412			END;
;	1413	
;	1414	
;	1415		!++
;	1416		! Output here is the same as non-EFFECTIVE unless the (REG) is PC.
;	1417		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-4
; Digital Equipment Corporation
;
;	1418		IF( .DOM_OPRND EQL PC_REG )
;	1419		THEN
;	1420			PAT$OUT_SYM_VAL( .DISPL, LONG_LENGTH, NO_OVERRIDE )
;	1421		ELSE
;	1422			BEGIN
;	1423			!++
;	1424			! Literals or real (non-PC) displacement modes.
;	1425			!--
;	1426			PAT$OUT_NUM_VAL(.DISPL, .DISP_SIZE, NO_OVERRIDE, TRUE);
;	1427			IF( .FLAG LSS 0 )
;	1428			THEN
;	1429				PUT_REG( .DOM_OPRND, ROUND_BRACKETS );
;	1430			END;
;	1431		END
;	1432	ELSE
;	1433		!++
;	1434		! No literal or displacement therefore the operand must be a type of
;	1435		! register reference.  Sort out the few cases and print them.
;	1436		!--
;	1437		IF (REGISTR(.DOM_MODE))
;	1438		THEN
;	1439			PUT_REG( .DOM_OPRND, NO_BRACKETS )
;	1440		ELSE
;	1441			BEGIN
;	1442			PUT_REG( .DOM_OPRND, ROUND_BRACKETS );
;	1443			IF( AUTOINC( .DOM_MODE ) )
;	1444			THEN
;	1445				PUTC('+');
;	1446			END;
;	1447	RETURN(.STREAM_PTR);						! Return the new byte stream pointer
;	1448	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      0000C P.AAC:  .ASCII  <4>\!AD^\<0><0><0>					      ;

							    .PSECT  _PAT$OWN,NOEXE,2

					      00008 DISPL_ID:
							    .ASCII  \B\							      ;
					      00009 	    .ASCII  \W\							      ;
					      0000A 	    .ASCII  \?\							      ;
					      0000B 	    .ASCII  \L\							      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0F7C 0017A INS_OPERAND:
							    .WORD   Save R2,R3,R4,R5,R6,R8,R9,R10,R11			      ; 1198
		         58 00000000V  EF  9E 0017C 	    MOVAB   PUT_REG, R8						      ;
		         59 00000000G  EF  9E 00183 	    MOVAB   PAT$GL_BUF_SIZ, R9					      ;
		         5A 00000000'  EF  9E 0018A 	    MOVAB   CASE_FLAG, R10					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-5
; Digital Equipment Corporation
;
		         5B 00000000G  EF  9E 00191 	    MOVAB   PAT$CP_OUT_STR, R11					      ;
		         5E	       10  C2 00198 	    SUBL2   #16, SP						      ;
		         54	  10   AC  D0 0019B 	    MOVL    INS_PC, R4						      ; 1305
				       54  DD 0019F 	    PUSHL   R4							      ;
		         7E	  08   AC  7D 001A1 	    MOVQ    INDEX, -(SP)					      ;
				  04   AC  DD 001A5 	    PUSHL   STREAM_PTR						      ;
	      00000000V  EF	       04  FB 001A8 	    CALLS   #4, BRANCH_TYPE					      ;
				       50  D5 001AF 	    TSTL    NEW_STR_PTR						      ;
				       01  13 001B1 	    BEQL    1$							      ;
					   04 001B3 	    RET     							      ;
		         11	  04   AA  E9 001B4 1$:     BLBC    MAP_FLAG, 2$					      ; 1314
				  0C   AE  9F 001B8 	    PUSHAB  STREAM_VALUE					      ; 1316
				       01  DD 001BB 	    PUSHL   #1							      ;
				  04   AC  DD 001BD 	    PUSHL   STREAM_PTR						      ;
	      00000000G  EF	       03  FB 001C0 	    CALLS   #3, PAT$GET_VALUE					      ;
				       05  11 001C7 	    BRB     3$							      ; 1314
		    0C   AE	  04   BC  9A 001C9 2$:     MOVZBL  @STREAM_PTR, STREAM_VALUE				      ; 1318
      0C   AE	         04	       04  EE 001CE 3$:     EXTV    #4, #4, STREAM_VALUE, DOM_MODE			      ; 1319
				       53     001D3									      ;
      0C   AE	         04	       00  EF 001D4 	    EXTZV   #0, #4, STREAM_VALUE, DOM_OPRND			      ; 1320
				       55     001D9									      ;
		         04	       53  D1 001DA 	    CMPL    DOM_MODE, #4					      ; 1325
				       1C  12 001DD 	    BNEQ    4$							      ;
				       64  D6 001DF 	    INCL    (R4)						      ; 1331
				       54  DD 001E1 	    PUSHL   R4							      ; 1332
		         7E	  08   AC  7D 001E3 	    MOVQ    INDEX, -(SP)					      ;
	   7E	    04   AC	       01  C1 001E7 	    ADDL3   #1, STREAM_PTR, -(SP)				      ;
		    8A   AF	       04  FB 001EC 	    CALLS   #4, INS_OPERAND					      ;
		    04   AC	       50  D0 001F0 	    MOVL    R0, STREAM_PTR					      ;
				       22  13 001F4 	    BEQL    5$							      ;
				       02  DD 001F6 	    PUSHL   #2							      ; 1335
				     00CC  31 001F8 	    BRW     17$							      ;
				       54  DD 001FB 4$:     PUSHL   R4							      ; 1344
		         7E	  08   AC  7D 001FD 	    MOVQ    INDEX, -(SP)					      ;
				  14   AE  9F 00201 	    PUSHAB  DISP_SIZE						      ;
				  14   AE  9F 00204 	    PUSHAB  DISPL						      ;
				  14   AE  9F 00207 	    PUSHAB  FLAG						      ;
				  04   AC  DD 0020A 	    PUSHL   STREAM_PTR						      ;
	      00000000V  EF	       07  FB 0020D 	    CALLS   #7, DISPLACEMENT					      ;
		    04   AC	       50  D0 00214 	    MOVL    R0, STREAM_PTR					      ;
				       03  12 00218 5$:     BNEQ    6$							      ;
				     00C8  31 0021A 	    BRW     20$							      ;
				       56  D4 0021D 6$:     CLRL    R6							      ; 1353
				       53  D5 0021F 	    TSTL    DOM_MODE						      ;
				       0C  18 00221 	    BGEQ    7$							      ;
				       56  D6 00223 	    INCL    R6							      ;
		         07	       53  E9 00225 	    BLBC    DOM_MODE, 7$					      ;
		    00   BB	  40   8F  90 00228 	    MOVB    #64, @PAT$CP_OUT_STR				      ; 1355
				       09  11 0022D 	    BRB     8$							      ;
		         07	       53  D1 0022F 7$:     CMPL    DOM_MODE, #7					      ; 1357
				       08  12 00232 	    BNEQ    9$							      ;
		    00   BB	       2D  90 00234 	    MOVB    #45, @PAT$CP_OUT_STR				      ; 1359
				       6B  D6 00238 8$:     INCL    PAT$CP_OUT_STR					      ;
				       69  D6 0023A 	    INCL    PAT$GL_BUF_SIZ					      ;
		         52	       6E  D0 0023C 9$:     MOVL    FLAG, R2						      ; 1365

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-6
; Digital Equipment Corporation
;
		         7E	       52  E9 0023F 	    BLBC    R2, 16$						      ;
				       22  15 00242 	    BLEQ    12$							      ; 1373
		    00   BB	       23  90 00244 	    MOVB    #35, @PAT$CP_OUT_STR				      ; 1376
				       6B  D6 00248 	    INCL    PAT$CP_OUT_STR					      ;
				       69  D6 0024A 	    INCL    PAT$GL_BUF_SIZ					      ;
		         03	       56  E9 0024C 	    BLBC    R6, 10$						      ; 1382
		         03	       53  E8 0024F 	    BLBS    DOM_MODE, 11$					      ;
		         55	       10  D0 00252 10$:    MOVL    #16, DOM_OPRND					      ; 1384
				       6A  D5 00255 11$:    TSTL    CASE_FLAG						      ; 1385
				       26  13 00257 	    BEQL    13$							      ;
		         03	  08   AC  D1 00259 	    CMPL    INDEX, #3						      ;
				       20  12 0025D 	    BNEQ    13$							      ;
	   6A	    04   AE	       01  C1 0025F 	    ADDL3   #1, DISPL, CASE_FLAG				      ; 1387
				       19  11 00264 	    BRB     13$							      ; 1373
		         50	  08   AA  9E 00266 12$:    MOVAB   DISPL_ID, R0					      ; 1398
				  08 BE40  9F 0026A 	    PUSHAB  @DISP_SIZE[R0]					      ;
				       6E  D7 0026E 	    DECL    (SP)						      ;
				       01  DD 00270 	    PUSHL   #1							      ;
			    00000000'  EF  9F 00272 	    PUSHAB  P.AAC						      ;
	      00000000G  EF	       03  FB 00278 	    CALLS   #3, PAT$FAO_PUT					      ;
				       53  D4 0027F 13$:    CLRL    R3							      ; 1404
				       52  D5 00281 	    TSTL    R2							      ;
				       0F  18 00283 	    BGEQ    14$							      ;
				       53  D6 00285 	    INCL    R3							      ;
		         0F	       55  D1 00287 	    CMPL    DOM_OPRND, #15					      ;
				       08  12 0028A 	    BNEQ    14$							      ;
		    08   AE	       04  D0 0028C 	    MOVL    #4, DISP_SIZE					      ; 1410
		    04   AE	       64  C0 00290 	    ADDL2   (R4), DISPL						      ; 1411
		         0F	       55  D1 00294 14$:    CMPL    DOM_OPRND, #15					      ; 1418
				       0F  12 00297 	    BNEQ    15$							      ;
		         7E	       04  7D 00299 	    MOVQ    #4, -(SP)						      ; 1420
				  0C   AE  DD 0029C 	    PUSHL   DISPL						      ;
	      00000000G  EF	       03  FB 0029F 	    CALLS   #3, PAT$OUT_SYM_VAL					      ;
				       38  11 002A6 	    BRB     19$							      ; 1418
				       01  DD 002A8 15$:    PUSHL   #1							      ; 1426
				       7E  D4 002AA 	    CLRL    -(SP)						      ;
				  10   AE  DD 002AC 	    PUSHL   DISP_SIZE						      ;
				  10   AE  DD 002AF 	    PUSHL   DISPL						      ;
	      00000000G  EF	       04  FB 002B2 	    CALLS   #4, PAT$OUT_NUM_VAL					      ;
		         24	       53  E9 002B9 	    BLBC    R3, 19$						      ; 1427
				       7E  D4 002BC 	    CLRL    -(SP)						      ; 1429
				       07  11 002BE 	    BRB     17$							      ;
		         05	       53  D1 002C0 16$:    CMPL    DOM_MODE, #5					      ; 1437
				       09  12 002C3 	    BNEQ    18$							      ;
				       01  DD 002C5 	    PUSHL   #1							      ; 1439
				       55  DD 002C7 17$:    PUSHL   DOM_OPRND						      ;
		         68	       02  FB 002C9 	    CALLS   #2, PUT_REG						      ;
				       12  11 002CC 	    BRB     19$							      ; 1437
				       7E  D4 002CE 18$:    CLRL    -(SP)						      ; 1442
				       55  DD 002D0 	    PUSHL   DOM_OPRND						      ;
		         68	       02  FB 002D2 	    CALLS   #2, PUT_REG						      ;
		         08	       56  E9 002D5 	    BLBC    R6, 19$						      ; 1443
		    00   BB	       2B  90 002D8 	    MOVB    #43, @PAT$CP_OUT_STR				      ; 1445
				       6B  D6 002DC 	    INCL    PAT$CP_OUT_STR					      ;
				       69  D6 002DE 	    INCL    PAT$GL_BUF_SIZ					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 5-7
; Digital Equipment Corporation
;
		         50	  04   AC  D0 002E0 19$:    MOVL    STREAM_PTR, R0					      ; 1447
					   04 002E4 	    RET     							      ;
				       50  D4 002E5 20$:    CLRL    R0							      ; 1198
					   04 002E7 21$:    RET     							      ;

; Routine Size:  366 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 6
; Digital Equipment Corporation
;
;	1449	ROUTINE BRANCH_TYPE( STREAM_PTR, INDEX, OPCODE, INS_PC ) =
;	1450	
;	1451	!++
;	1452	! FUNCTIONAL DESCRIPTION:
;	1453	!
;	1454	!	DECIDE IF THE CURRENT OPERAND IS USING BRANCH TYPE
;	1455	!	ADDRESSING.  IF SO, PRINT OUT THE REFERENCE AND
;	1456	!	LOOK AFTER ALL THE DETAILS.  OTHERWISE RETURN FALSE.
;	1457	!
;	1458	! CALLING SEQUENCE:
;	1459	!
;	1460	!	BRANCH_TYPE ();
;	1461	!
;	1462	! INPUTS:
;	1463	!
;	1464	!	STREAM_PTR	- AN UNMAPPED POINTER TO THE CURRENT DOMINANT
;	1465	!			  MODE BYTE.
;	1466	!	INDEX		- WHICH OPERAND (ORDINAL) BEING DECODED.
;	1467	!	OPCODE		-THE OPCODE OF INSTRUCTION BEING DECODED.
;	1468	!			 (This parameter has already been validated.)
;	1469	!	INS_PC		- THE PC FOR WHICH THE INSTRUCTION WAS ENCODED
;	1470	!
;	1471	! IMPLICIT INPUTS:
;	1472	!
;	1473	!	PAT$GB_OPINFO - THE OPCODE INFORMATION TABLE.
;	1474	!
;	1475	! OUTPUTS:
;	1476	!
;	1477	!	IF THE CURRENT OPERAND IS A REFERENCE USING BRANCH TYPE
;	1478	!	ADDRESSING, THIS REFERENCE IS PRINTED.  OTHERWISE THE
;	1479	!	ROUTINE DOES NO OUTPUT.
;	1480	!
;	1481	! IMPLICIT OUTPUTS:
;	1482	!
;	1483	!	MAP_FLAG - TRUE IF STREAM_PTR IS EQUAL TO PC,
;	1484	!		   FALSE IF STREAM_PTR IS A BUFFER.
;	1485	
;	1486	!
;	1487	! ROUTINE VALUE:
;	1488	!
;	1489	!	FALSE - IF THE CURRENT OPERAND IS NOT A BRANCH TYPE 
;	1490	!		(i.e. If the calling routine should continue on
;	1491	!		 further to decode the instruction.)
;	1492	!	TRUE - non-zero, THE ADDRESS OF THE NEXT INSTRUCTION IS RETURNED.
;	1493	!
;	1494	! SIDE EFFECTS:
;	1495	!
;	1496	!	NONE.
;	1497	!--
;	1498	
;	1499	BEGIN
;	1500	
;	1501	MAP
;	1502		INS_PC : REF VECTOR[,LONG],
;	1503		STREAM_PTR : REF BLOCK[,BYTE];

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 6-1
; Digital Equipment Corporation
;
;	1504	
;	1505	LOCAL
;	1506		N_OPS,							! NUMBER OF OPERANDS FOR CURRENT OPCODE
;	1507		DISP_SIZE,						! SIZE OF BRANCH OPERAND, IN BYTES.
;	1508		DISPL,							! THE ACTUAL BRANCH DISPLACEMENT.
;	1509		STREAM_VALUE;						! VALUE OF BYTE STREAM FOR INSTRUCTION
;	1510	
;	1511	!++
;	1512	! THERE IS NO POINT IN EVEN CONSIDERING BRANCH TYPE ADDRESSING UNLESS THIS IS
;	1513	! THE LAST OPERAND FOR THIS INSTRUCTION.
;	1514	!--
;	1515	IF ((N_OPS = .PAT$GB_OPINFO[ .OPCODE, OP_NUMOPS ]) NEQ .INDEX) AND
;	1516	   (.PAT$GB_OPINFO[.OPCODE, OP_NUMOPS] NEQ ASM_DIR_OP)
;	1517	
;	1518	THEN
;	1519		RETURN(FALSE);
;	1520	
;	1521	!++
;	1522	! FURTHERMORE, SINCE THE SAME BITS IN THE OPINFO TABLEARE USED FOR TWO
;	1523	! PURPOSES, (NAMELY OP_BR_TYPE AND OP_CONTEXT( MAXOPRNDS ) ), DO NOT
;	1524	! LOOK FOR BRANCH INFORMATION UNLESS THIS OPCODE HAS LESS THAN THE MAXIMUM
;	1525	! NUMBER OF OPERANDS.
;	1526	!--
;	1527	IF (.INDEX EQL MAXOPRNDS) AND (.PAT$GB_OPINFO[.OPCODE, OP_NUMOPS] NEQ ASM_DIR_OP)
;	1528	
;	1529	THEN
;	1530		RETURN(FALSE);
;	1531	
;	1532	!++
;	1533	! USE THE OP_BR_TYPE FIELD LITERALLY.  IT CONTAINS THE NUMBER OF BYTES USED FOR
;	1534	! THE BRANCH DISPLACEMENT.  0 IN THIS FIELD INDICATES THAT THIS OPCODE HAS NO
;	1535	! BRANCH TYPE OPERANDS.
;	1536	!--
;	1537	IF( (DISP_SIZE = .PAT$GB_OPINFO[ .OPCODE, OP_BR_TYPE ]) EQL NO_BR )
;	1538	THEN
;	1539		RETURN(FALSE);
;	1540	
;	1541	!++
;	1542	! SUCCESS -- THIS IS A CASE OF BRANCH TYPE ADDRESSING. HANDLE THIS
;	1543	! BY EXTRACTING THE FIELD, (WITH SIGN EXTENSION AS PER SRM),  PRINTING
;	1544	! OUT THE REFERENCE, AND RETURNING A POINTER TO THE NEXT INSTRUCTION.  ALSO
;	1545	! UPDATE THE VARIABLE WHICH THE USER ACCESSES AS '\' - THE LAST VALUE DISPLAYED.
;	1546	! IN THIS CASE IT IS DEFINED AS THE VALUE TO BE THE BRANCH ADDRESS.
;	1547	!--
;	1548	IF .MAP_FLAG							! IS THE INSTRUCTION AT THE PC?
;	1549	THEN
;	1550		PAT$GET_VALUE(.STREAM_PTR, .DISP_SIZE, STREAM_VALUE)	! YES, MAP ADDRESS
;	1551	ELSE
;	1552		STREAM_VALUE = .STREAM_PTR[0, 0, .DISP_SIZE*BITS_PER_BYTE, 1]; ! NO, GET VALUE FROM BUFFER
;	1553	IF (.PAT$GB_OPINFO[.OPCODE, OP_NUMOPS] NEQ ASM_DIR_OP)
;	1554	THEN
;	1555		DISPL = .STREAM_VALUE<0,.DISP_SIZE*BITS_PER_BYTE,1>
;	1556	ELSE
;	1557		DISPL = .STREAM_VALUE<0,.DISP_SIZE*BITS_PER_BYTE,0>;
;	1558	STREAM_PTR = .STREAM_PTR + .DISP_SIZE;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 6-2
; Digital Equipment Corporation
;
;	1559	INS_PC[0] = .INS_PC[0] + .DISP_SIZE;
;	1560	PAT$GL_LAST_VAL = .DISPL + .INS_PC[0];
;	1561	
;	1562	!++
;	1563	! Put out the absolute branch operand.
;	1564	!--
;	1565	IF (.PAT$GB_OPINFO[.OPCODE, OP_NUMOPS] NEQ ASM_DIR_OP)
;	1566	THEN
;	1567		DISPL = .DISPL + .INS_PC[0];
;	1568	PAT$OUT_SYM_VAL(.DISPL, LONG_LENGTH, NO_OVERRIDE);
;	1569	RETURN( .STREAM_PTR );
;	1570	END;





					 000C 002E8 BRANCH_TYPE:
							    .WORD   Save R2,R3						      ; 1449
		         5E	       04  C2 002EA 	    SUBL2   #4, SP						      ;
	   50	    0C   AC	       06  C5 002ED 	    MULL3   #6, OPCODE, R0					      ; 1515
		         53 00000000GEF40  9E 002F2 	    MOVAB   PAT$GB_OPINFO+4[R0], R3				      ;
	   63	         04	       00  EE 002FA 	    EXTV    #0, #4, (R3), N_OPS					      ;
				       50     002FE									      ;
		    08   AC	       50  D1 002FF 	    CMPL    N_OPS, INDEX					      ;
				       0B  13 00303 	    BEQL    1$							      ;
	   63	         04	       00  EC 00305 	    CMPV    #0, #4, (R3), #-2					      ; 1516
			    FFFFFFFE   8F     00309									      ;
				       0F  12 0030E 	    BNEQ    2$							      ;
		         06	  08   AC  D1 00310 1$:     CMPL    INDEX, #6						      ; 1527
				       0B  12 00314 	    BNEQ    3$							      ;
	   63	         04	       00  EC 00316 	    CMPV    #0, #4, (R3), #-2					      ;
			    FFFFFFFE   8F     0031A									      ;
				       74  12 0031F 2$:     BNEQ    9$							      ;
	   63	         04	       0C  EF 00321 3$:     EXTZV   #12, #4, (R3), DISP_SIZE				      ; 1537
				       52     00325									      ;
				       6D  13 00326 	    BEQL    9$							      ;
		         10 00000000'  EF  E9 00328 	    BLBC    MAP_FLAG, 4$					      ; 1548
				4004   8F  BB 0032F 	    PUSHR   #^M<R2,SP>						      ; 1550
				  04   AC  DD 00333 	    PUSHL   STREAM_PTR						      ;
	      00000000G  EF	       03  FB 00336 	    CALLS   #3, PAT$GET_VALUE					      ;
				       0A  11 0033D 	    BRB     5$							      ; 1548
	   50	         52	       03  78 0033F 4$:     ASHL    #3, DISP_SIZE, R0					      ; 1552
      04   BC	         50	       00  EE 00343 	    EXTV    #0, R0, @STREAM_PTR, STREAM_VALUE			      ;
				       6E     00348									      ;
	   50	         52	       03  78 00349 5$:     ASHL    #3, DISP_SIZE, R0					      ; 1555
	   63	         04	       00  EC 0034D 	    CMPV    #0, #4, (R3), #-2					      ; 1553
			    FFFFFFFE   8F     00351									      ;
				       07  13 00356 	    BEQL    6$							      ;
	   6E	         50	       00  EE 00358 	    EXTV    #0, R0, STREAM_VALUE, DISPL				      ; 1555
				       51     0035C									      ;
				       05  11 0035D 	    BRB     7$							      ; 1553
	   6E	         50	       00  EF 0035F 6$:     EXTZV   #0, R0, STREAM_VALUE, DISPL				      ; 1557
				       51     00363									      ;
		    04   AC	       52  C0 00364 7$:     ADDL2   DISP_SIZE, STREAM_PTR				      ; 1558

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 6-3
; Digital Equipment Corporation
;
		    10   BC	       52  C0 00368 	    ADDL2   DISP_SIZE, @INS_PC					      ; 1559
00000000G  EF	         51	  10   BC  C1 0036C 	    ADDL3   @INS_PC, DISPL, PAT$GL_LAST_VAL			      ; 1560
	   63	         04	       00  EC 00375 	    CMPV    #0, #4, (R3), #-2					      ; 1565
			    FFFFFFFE   8F     00379									      ;
				       04  13 0037E 	    BEQL    8$							      ;
		         51	  10   BC  C0 00380 	    ADDL2   @INS_PC, DISPL					      ; 1567
		         7E	       04  7D 00384 8$:     MOVQ    #4, -(SP)						      ; 1568
				       51  DD 00387 	    PUSHL   DISPL						      ;
	      00000000G  EF	       03  FB 00389 	    CALLS   #3, PAT$OUT_SYM_VAL					      ;
		         50	  04   AC  D0 00390 	    MOVL    STREAM_PTR, R0					      ; 1569
					   04 00394 	    RET     							      ;
				       50  D4 00395 9$:     CLRL    R0							      ; 1449
					   04 00397 	    RET     							      ;

; Routine Size:  176 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 7
; Digital Equipment Corporation
;
;	1571	ROUTINE PUT_REG( REG, CS_FLAG ) : NOVALUE =
;	1572	
;	1573	!++
;	1574	! FUNCTIONAL DESCRIPTION:
;	1575	!
;	1576	!	THIS ROUTINE TAKES ONE PARAMETER WHICH IT ASSUMES IS
;	1577	!	THE NUMBER OF A VAX REGISTER.  IT THEN PRINTS OUT
;	1578	!	'R' FOLLOWED BY THE NUMBER (IN DECIMAL), UNLESS THE
;	1579	!	REGISTER NUMBER IS 'SPECIAL'.  THE SPECIAL REGISTERS INCLUDE:
;	1580	!
;	1581	!	REGISTER NUMBER		SPECIAL NAME
;	1582	!
;	1583	!		12		   AP
;	1584	!		13		   FP
;	1585	!		14		   SP
;	1586	!		15		   PC
;	1587	!
;	1588	!	An additional parameter is used as a flag to indicate
;	1589	!	whether the register reference should be enclosed in
;	1590	!	round/square brackets or not.
;	1591	!
;	1592	! INPUTS:
;	1593	!
;	1594	!	REG - The register number.
;	1595	!	CS_FLAG - A flag to control printing before/after REG.
;	1596	!
;	1597	! IMPLICIT INPUTS:
;	1598	!
;	1599	!	NONE.
;	1600	!
;	1601	! OUTPUTS:
;	1602	!
;	1603	!	THE REGISTER REFERENCE IS PRINTED.
;	1604	!
;	1605	! IMPLICIT OUTPUTS:
;	1606	!
;	1607	!	NONE.
;	1608	!
;	1609	! ROUTINE VALUE:
;	1610	!
;	1611	!	NOVALUE
;	1612	!
;	1613	! SIDE EFFECTS:
;	1614	!
;	1615	! 	NONE.
;	1616	!--
;	1617	
;	1618	BEGIN
;	1619	
;	1620	LOCAL
;	1621		INDEX;
;	1622	
;	1623	OWN
;	1624		ENCLOSING_CS : VECTOR[4,WORD]				! Enclosing strings for REG.
;	1625			       INITIAL(	WORD(	%ASCIC '(',

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 7-1
; Digital Equipment Corporation
;
;	1626						%ASCIC ')',
;	1627						%ASCIC '[',
;	1628						%ASCIC ']')),
;	1629		PUT_CS   : VECTOR[4,BYTE]				! FAO formatting string.
;	1630			   INITIAL( %ASCIC '!AC' ),
;	1631		REGNAMES : VECTOR[4,WORD]				! SPECIAL REGISTER NAMES.
;	1632			   INITIAL( WORD( 'AP', 'FP', 'SP', 'PC') );
;	1633	
;	1634	!++
;	1635	! IF ANY ENCLOSING STRINGS SHOULD BE OUTPUT, THEN CS_FLAG PROVIDED
;	1636	! AN INDEX INTO THE VECTOR OF STRINGS.
;	1637	!--
;	1638	IF( (INDEX = .CS_FLAG) NEQ NO_BRACKETS )
;	1639	THEN
;	1640		PAT$FAO_PUT( PUT_CS, ENCLOSING_CS[.INDEX] );
;	1641	
;	1642	!++
;	1643	! Now print the actual register reference.
;	1644	!--
;	1645	IF( .REG LSS AP_REG )
;	1646	THEN
;	1647		PAT$FAO_PUT( UPLIT ( %ASCIC 'R!UB' ), .REG )
;	1648	ELSE
;	1649		!++
;	1650		! The reserved registers have special names which
;	1651		! are extracted from the above vector.
;	1652		!--
;	1653		PAT$FAO_PUT( UPLIT ( %ASCIC '!AD' ), 2, REGNAMES[.REG-12] );
;	1654	
;	1655	!++
;	1656	! Check for any enclosing string, right parentheses or bracket.
;	1657	!--
;	1658	IF( .INDEX NEQ NO_BRACKETS )
;	1659	THEN
;	1660		PAT$FAO_PUT( PUT_CS, ENCLOSING_CS[.INDEX+1] );
;	1661	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00014 P.AAD:  .ASCII  <4>\R!UB\<0><0><0>					      ;
					      0001C P.AAE:  .ASCII  <3>\!AD\						      ;

							    .PSECT  _PAT$OWN,NOEXE,2

					      0000C ENCLOSING_CS:
							    .ASCII  <1>\(\						      ;
					      0000E 	    .ASCII  <1>\)\						      ;
					      00010 	    .ASCII  <1>\[\						      ;
					      00012 	    .ASCII  <1>\]\						      ;
					      00014 PUT_CS: .ASCII  <3>\!AC\						      ;
					      00018 REGNAMES:
							    .ASCII  \AP\						      ;
					      0001A 	    .ASCII  \FP\						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 7-2
; Digital Equipment Corporation
;
					      0001C 	    .ASCII  \SP\						      ;
					      0001E 	    .ASCII  \PC\						      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 0C04 00398 PUT_REG:.WORD   Save R2,R10,R11					      ; 1571
		         5A 00000000G  EF  9E 0039A 	    MOVAB   PAT$FAO_PUT, R10					      ;
		         5B 00000000'  EF  9E 003A1 	    MOVAB   PUT_CS, R11						      ;
		         52	  08   AC  D0 003A8 	    MOVL    CS_FLAG, INDEX					      ; 1638
		         01	       52  D1 003AC 	    CMPL    INDEX, #1						      ;
				       09  13 003AF 	    BEQL    1$							      ;
				  F8 AB42  3F 003B1 	    PUSHAW  ENCLOSING_CS[INDEX]					      ; 1640
				       5B  DD 003B5 	    PUSHL   R11							      ;
		         6A	       02  FB 003B7 	    CALLS   #2, PAT$FAO_PUT					      ;
		         0C	  04   AC  D1 003BA 1$:     CMPL    REG, #12						      ; 1645
				       0E  18 003BE 	    BGEQ    2$							      ;
				  04   AC  DD 003C0 	    PUSHL   REG							      ; 1647
			    00000000'  EF  9F 003C3 	    PUSHAB  P.AAD						      ;
		         6A	       02  FB 003C9 	    CALLS   #2, PAT$FAO_PUT					      ;
				       13  11 003CC 	    BRB     3$							      ; 1645
		         50	  04   AC  D0 003CE 2$:     MOVL    REG, R0						      ; 1653
				  EC AB40  3F 003D2 	    PUSHAW  REGNAMES-24[R0]					      ;
				       02  DD 003D6 	    PUSHL   #2							      ;
			    00000000'  EF  9F 003D8 	    PUSHAB  P.AAE						      ;
		         6A	       03  FB 003DE 	    CALLS   #3, PAT$FAO_PUT					      ;
		         01	       52  D1 003E1 3$:     CMPL    INDEX, #1						      ; 1658
				       09  13 003E4 	    BEQL    4$							      ;
				  FA AB42  3F 003E6 	    PUSHAW  ENCLOSING_CS+2[INDEX]				      ; 1660
				       5B  DD 003EA 	    PUSHL   R11							      ;
		         6A	       02  FB 003EC 	    CALLS   #2, PAT$FAO_PUT					      ;
					   04 003EF 4$:     RET     							      ; 1571

; Routine Size:  88 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 8
; Digital Equipment Corporation
;
;	1662	ROUTINE DISPLACEMENT( STREAM_PTR, FLAG, DISPL, PTR_DISP_SIZE, INDEX, OPCODE, INS_PC ) =
;	1663	
;	1664	!++
;	1665	!  FUNCTIONAL DESCRIPTION:
;	1666	!
;	1667	!	DECIDE IF THERE IS A DISPLACEMENT FOR THE CURRENT
;	1668	!	OPERAND OF THE CURRENT INSTRUCTION.  IF THERE IS,
;	1669	!	EXTRACT IT FROM THE INSTRUCTION STREAM AND RETURN AN
;	1670	!	INDICATION OF THE CASE DETECTED.
;	1671	!
;	1672	! CALLING SEQUENCE:
;	1673	!
;	1674	!	DISPLACEMENT ();
;	1675	!
;	1676	! INPUTS:
;	1677	!
;	1678	!	STREAM_PTR	- POINTER TO THE BEGINNING OF THE CURRENT OPERAND SPECIFIER.
;	1679	!	FLAG		- POINTER TO THE RETURN LOCATION FOR ONE OF THE 3 FLAGS
;	1680	!			  IF THERE IS A DISPLACEMENT OR LITERAL ASSOCIATED
;	1681	!			  WITH THIS OPERAND REFERENCE.
;	1682	!	DISPL	 	- A POINTER TO THE RETURN LONGWORD FOR THE ACTUAL
;	1683	!			  DISPLACEMENT OR LITERAL.
;	1684	!	PTR_DISP_SIZE	- ADDRESS TO CONTAIN RETURNED VALUE OF NUMBER
;	1685	!			  OF BYTES ACTUALLY NEEDED FOR THE DISPLACEMENT.
;	1686	!			  This is done strictly for the benefit of FAO,
;	1687	!			  which would fill out output fields with 0s
;	1688	!			  otherwise, giving misleading output.
;	1689	!	INDEX		- THE ORDINAL OF THE OPERAND BEING DECODED.
;	1690	!	OPCODE		-  THE OPCODE OF THE INSTRUCTION BEING DECODED.
;	1691	!			 (This parameter has already been validated.)
;	1692	!	INS_PC		- THE PC FOR WHICH THE INSTRUCTION WAS ENCODED.
;	1693	!
;	1694	! OUTPUTS:
;	1695	!
;	1696	!	1) A VALUE OF -1, 0, OR 1 IS RETURNED VIA THE LONGWORD
;	1697	!	   POINTER, FLAG.  0 IS RETURNED IF NO DISPLACEMENT IS TO BE
;	1698	!	   ASSOCIATED WITH THIS OPERAND REFERENCE.  OTHERWISE 1 OR -1
;	1699	!	   IS RETURNED TO SEPARATE THE CASES LISTED BELOW.  THIS PROVIDES A WAY
;	1700	!	   TO PRINT '#' BEFORE SOME LITERALS, (E.G. MOVL #1,R0), AND TO INDICATE
;	1701	!	   WHEN TO PRINT '(RN)' AFTER THE DISPLACEMENT, ETC.  THIS INFORMATION
;	1702	!	  IS RETURNED TO PRECLUDE TESTING FOR IT AGAIN.
;	1703	!
;	1704	!	2) IF THERE IS A DISPLACEMENT, ITS VALUE IS RETURNED
;	1705	!	   VIA THE LONGWORD POINTER, 'DISPL'.  IF THE FLAG WHICH IS
;	1706	!	   RETURNED (SEE ABOVE) IS 0, THE LONGWORD POINTED
;	1707	!	   TO BY 'DISPL' IS UNCHANGED.  IF THE LITERAL
;	1708	!	   EXTRACTED FROM THE BYTE STREAM WOULD REQUIRE MORE
;	1709	!	   THAN A LONGWORD (E.G. QUAD LITERALS), THEN
;	1710	!	   ONLY THE LOWER ORDER LONGWORD IS RETURNED VIA
;	1711	!	   'DISPL'.  QUADWORD LITERALS ARE NOT SUPPORTED.
;	1712	!
;	1713	! IMPLICIT OUTPUTS:
;	1714	!
;	1715	!	IF TRUNCATION OF QUADWORD LITERALS OCCURS, THIS
;	1716	!	ROUTINE WILL PUT '?' INTO THE OUTPUT STREAM

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 8-1
; Digital Equipment Corporation
;
;	1717	!	TO WARN OF THIS ACTION.
;	1718	!
;	1719	! ROUTINE VALUE:
;	1720	!
;	1721	!	-THE (NEW) BYTE STREAM POINTER WHICH WILL THEN POINT TO THE
;	1722	!	 BEGINNING OF THE NEXT INSTRUCTION OR OPERAND REFERENCE.
;	1723	!
;	1724	! SIDE EFFECTS:
;	1725	!
;	1726	!	NONE.
;	1727	!--
;	1728	
;	1729	BEGIN
;	1730	
;	1731	MAP
;	1732		INS_PC		:	REF VECTOR[,LONG],
;	1733		PTR_DISP_SIZE	:	REF VECTOR[,LONG],
;	1734		DISPL		:	REF VECTOR[,LONG],
;	1735		FLAG		:	REF VECTOR[,LONG],
;	1736		STREAM_PTR	:	REF BLOCK[,BYTE];
;	1737	
;	1738	LOCAL
;	1739		MAP_STREAM_PTR : REF BLOCK[,BYTE],			! MAPPED ADDRESS OF BYTE STREAM
;	1740		STREAM_VALUE : BLOCK[4,BYTE],				! VALUES FROM BYTE STREAM
;	1741		MODE,							! DOMINANT ADDRESSING MODE
;	1742		F,							! FLAG VALUE RETURNED
;	1743		DISP_SIZE;						! SIZE, IN BYTES, OF THE DISPLACEMENT
;	1744	
;	1745	!++
;	1746	!  ASSUME THERE IS NO DISPLACMENT, BUT THEN CHECK FOR THE CASES:
;	1747	!
;	1748	!	1) LITERAL MODE - DOMINANT MODE IS 0, 1, 2, OR 3.
;	1749	!
;	1750	!	2) BYTE, WORD, OR LONGWORD, DISPLACEMENT OR DEFERRED
;	1751	!	   DISPLACEMENT MODES.
;	1752	!
;	1753	!	3) MODE 8 WHEN REG IS PC (IE #CONST, INSTEAD OF (PC)+ )
;	1754	!	  OR
;	1755	!	   MODE 9 WHEN REG IS PC (IE @#ADDRESS, INSTEAD OF @(PC)+ )
;	1756	!	
;	1757	!  CASES 1 AND 3 ARE TYPE 1, WHILE CASE 2 IS TYPE -1.
;	1758	!--
;	1759	F = 0;
;	1760	DISP_SIZE = 0;
;	1761	IF .MAP_FLAG							! IS INSTRUCTION AT PC?
;	1762	THEN
;	1763		PAT$GET_VALUE(.STREAM_PTR, A_BYTE, STREAM_VALUE)	! YES, MAP ADDRESS
;	1764	ELSE
;	1765		STREAM_VALUE = .STREAM_PTR[0, 0, (A_BYTE * BITS_PER_BYTE), 0]; ! NO, GET VALUE FROM BUFFER
;	1766	IF( (MODE = .STREAM_VALUE[ DSPL_MODE ]) LSS INDEXING_MODE )
;	1767	THEN
;	1768		BEGIN
;	1769		!++
;	1770		! CASE 1: LITERAL MODE ADDRESSING
;	1771		!	  THE LITERAL IS A 6-BIT FIELD WHICH MUST BE EXTRACTED WITHOUT

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 8-2
; Digital Equipment Corporation
;
;	1772		!	  SIGN-EXTENSION FROM THE ADDRESSING MODE BYTE.  EXTRACT THIS
;	1773		!	  FIELD, PASS IT BACK, AND SET A FLAG TO INDICATE WHICH CASE
;	1774		!	  WAS FOUND.  NOTE THAT THE FLAG VALUE BEING 1 ALSO MEANS THAT
;	1775		!	  IT CAN BE USED FOR THE DISP_SIZE VALUE RETURNED.
;	1776		!--
;	1777		DISPL[0] = .STREAM_VALUE[SHORT_LITERAL];
;	1778		F = 1;
;	1779		END
;	1780	ELSE
;	1781		IF( .MODE GTR AT_PC_REL_MODE )
;	1782		THEN
;	1783			BEGIN
;	1784			!++
;	1785			! CASE 2: DISPLACEMENT OR DEFERRED DISPLACEMENT MODE.  THERE
;	1786			!	  ONLY REMAINS TO DECIDE HOW MUCH OF THE BYTE STREAM TO
;	1787			!	  EXTRACT.  THIS IS DONE SIMPLY BY LOOKING AT WHAT THE
;	1788			!	  'MODE' FIELD OF THE DOMINANT BYTE IS.  TO
;	1789			!	  DIFFERENTIATE HEX A OR B, C OR D, AND E OR F,
;	1790			!	  SO JUST LOOK FOR THE MOST CONVENIENT BITS TO CHECK.
;	1791			!	  START BY ASSUMING BYTE DISPLACEMENT (HEX A OR B), THEN
;	1792			!	  SORT OUT THE OTHER TWO CASES.
;	1793			!--
;	1794			F = -1;
;	1795			DISP_SIZE = A_BYTE;
;	1796			IF( .STREAM_VALUE[ DOM_MOD_FIELD ] LSS 0 )
;	1797			THEN
;	1798				DISP_SIZE = (IF (.STREAM_VALUE[DOM_MOD_FIELD])
;	1799					      THEN A_LONGWORD		! MODE IS HEX E OR F.
;	1800					      ELSE A_WORD);		! MODE IS HEX C OR D.
;	1801			END
;	1802		ELSE
;	1803			IF ((.STREAM_VALUE[OPERAND_VALUE] EQL PC_REG) AND
;	1804			   (.MODE EQL PC_REL_MODE OR .MODE EQL AT_PC_REL_MODE))
;	1805			THEN
;	1806				BEGIN
;	1807				!++
;	1808				! CASE 3: SPECIAL CASE NOTATION FOR PC MODES.
;	1809				!	  THE ONLY DIFFICULTY IS DECIDING HOW
;	1810				!	  MUCH OF THE BYTE STREAM TO 'EAT UP'.
;	1811				!	  @#ADDRESS ALWAYS HAS LONGWORD CONTEXT,
;	1812				!	  WHILE THE CONTEXT OF #CONST DEPENDS ON
;	1813				!	  THE OPCODE AND THE OPERAND ORDINAL.
;	1814				F = 1;
;	1815				IF( .MODE EQL AT_PC_REL_MODE )
;	1816				THEN
;	1817					DISP_SIZE = A_LONGWORD
;	1818				ELSE
;	1819					DISP_SIZE = INS_CONTEXT( .INDEX, .OPCODE );
;	1820				END;
;	1821	!++
;	1822	! AT THIS POINT .DISP_SIZE IS THE NUMBER OF BYTES PAST THE MODE BYTE
;	1823	! CONSUMED FROM THE INSTRUCTION STREAM, IF ANY.  JUST GO AHEAD AND CONSUME THESE
;	1824	! BYTES, PASS BACK THE DISPLACEMENT, AND RETURN THE NEW INSTRUCTION-STREAM BYTE
;	1825	! POINTER.  EVEN IF THERE IS NO DISPLACEMENT, AT LEAST THE DOMINANT ADDRESSING
;	1826	! MODE BYTE WAS CONSUMED.  THE NEXT COMMAND INCREMENTS THE STREAM_PTR

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 8-3
; Digital Equipment Corporation
;
;	1827	! ADDRESS BY ONE.
;	1828	!--
;	1829	STREAM_PTR = STREAM_PTR[NEXT_FIELD(1)];
;	1830	INS_PC[0] = .INS_PC[0] + 1;
;	1831	
;	1832	!++
;	1833	! Pass back the flag now so that F can be re-used as a temporary, below.
;	1834	!--
;	1835	FLAG[0] = .F;
;	1836	IF( .DISP_SIZE NEQ 0 )
;	1837	THEN
;	1838		BEGIN
;	1839		!++
;	1840		! CHECK FOR QUADWORD LITERALS.  QUADWORD LITERALS ARE NOT SUPPORTED.
;	1841		!--
;	1842		IF( (F = .DISP_SIZE) GTR A_LONGWORD )
;	1843		THEN
;	1844			BEGIN
;	1845			F = A_LONGWORD;					! ***** TRUNCATION *****
;	1846			PUTC('?');
;	1847			END;
;	1848	
;	1849		!++
;	1850		! PASS BACK THE LITERAL OR DISPLACEMENT.  NOTE THE SIGN EXTENSION.
;	1851		!--
;	1852		IF .MAP_FLAG						! IS INSTRUCTION AT PC?
;	1853		THEN
;	1854			PAT$GET_VALUE(.STREAM_PTR, .F, STREAM_VALUE)	! YES, MAP ADDRESS
;	1855		ELSE
;	1856			STREAM_VALUE = .STREAM_PTR[0, 0, (.F * BITS_PER_BYTE), 0];		! NO, GET VALUE FROM BUFFER
;	1857		DISPL[0] = .STREAM_VALUE[ 0, 0, .F * BITS_PER_BYTE, 1];
;	1858		END;
;	1859	
;	1860	!++
;	1861	! Pass back an indication of the number of bytes actually consumed for the
;	1862	! displacement or literal for the benefit of FAO output.
;	1863	!--
;	1864	PTR_DISP_SIZE[0] = .F;
;	1865	INS_PC[0] = .INS_PC[0] + .DISP_SIZE;
;	1866	RETURN( STREAM_PTR[ NEXT_FIELD( .DISP_SIZE ) ] );
;	1867	END;





					 0C0C 003F0 DISPLACEMENT:
							    .WORD   Save R2,R3,R10,R11					      ; 1662
		         5A 00000000'  EF  9E 003F2 	    MOVAB   MAP_FLAG, R10					      ;
		         5B 00000000G  EF  9E 003F9 	    MOVAB   PAT$GET_VALUE, R11					      ;
		         5E	       04  C2 00400 	    SUBL2   #4, SP						      ;
				       52  7C 00403 	    CLRQ    F							      ; 1759
		         0C	       6A  E9 00405 	    BLBC    MAP_FLAG, 1$					      ; 1761
				       5E  DD 00408 	    PUSHL   SP							      ; 1763
				       01  DD 0040A 	    PUSHL   #1							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 8-4
; Digital Equipment Corporation
;
				  04   AC  DD 0040C 	    PUSHL   STREAM_PTR						      ;
		         6B	       03  FB 0040F 	    CALLS   #3, PAT$GET_VALUE					      ;
				       04  11 00412 	    BRB     2$							      ; 1761
		         6E	  04   BC  9A 00414 1$:     MOVZBL  @STREAM_PTR, STREAM_VALUE				      ; 1765
	   6E	         04	       04  EF 00418 2$:     EXTZV   #4, #4, STREAM_VALUE, MODE				      ; 1766
				       50     0041C									      ;
		         04	       50  D1 0041D 	    CMPL    MODE, #4						      ;
				       0B  18 00420 	    BGEQ    3$							      ;
	   6E	         06	       00  EF 00422 	    EXTZV   #0, #6, STREAM_VALUE, @DISPL			      ; 1777
				  0C   BC     00426									      ;
		         52	       01  D0 00428 	    MOVL    #1, F						      ; 1778
				       47  11 0042B 	    BRB     8$							      ; 1766
		         09	       50  D1 0042D 3$:     CMPL    MODE, #9						      ; 1781
				       16  15 00430 	    BLEQ    4$							      ;
		         52	       01  CE 00432 	    MNEGL   #1, F						      ; 1794
		         53	       01  D0 00435 	    MOVL    #1, DISP_SIZE					      ; 1795
	   6E	         02	       05  EC 00438 	    CMPV    #5, #2, STREAM_VALUE, #0				      ; 1796
				       00     0043C									      ;
				       35  18 0043D 	    BGEQ    8$							      ;
	   1E	         6E	       05  E0 0043F 	    BBS     #5, STREAM_VALUE, 6$				      ; 1798
		         53	       02  D0 00443 	    MOVL    #2, DISP_SIZE					      ;
				       2C  11 00446 	    BRB     8$							      ; 1796
	   6E	         04	       00  ED 00448 4$:     CMPZV   #0, #4, STREAM_VALUE, #15				      ; 1803
				       0F     0044C									      ;
				       25  12 0044D 	    BNEQ    8$							      ;
		         08	       50  D1 0044F 	    CMPL    MODE, #8						      ; 1804
				       05  13 00452 	    BEQL    5$							      ;
		         09	       50  D1 00454 	    CMPL    MODE, #9						      ;
				       1B  12 00457 	    BNEQ    8$							      ;
		         52	       01  D0 00459 5$:     MOVL    #1, F						      ; 1814
		         09	       50  D1 0045C 	    CMPL    MODE, #9						      ; 1815
				       05  12 0045F 	    BNEQ    7$							      ;
		         53	       04  D0 00461 6$:     MOVL    #4, DISP_SIZE					      ; 1817
				       0E  11 00464 	    BRB     8$							      ; 1815
		         7E	  14   AC  7D 00466 7$:     MOVQ    INDEX, -(SP)					      ; 1819
	      00000000V  EF	       02  FB 0046A 	    CALLS   #2, INS_CONTEXT					      ;
		         53	       50  D0 00471 	    MOVL    R0, DISP_SIZE					      ;
				  04   AC  D6 00474 8$:     INCL    STREAM_PTR						      ; 1829
				  1C   BC  D6 00477 	    INCL    @INS_PC						      ; 1830
		    08   BC	       52  D0 0047A 	    MOVL    F, @FLAG						      ; 1835
				       53  D5 0047E 	    TSTL    DISP_SIZE						      ; 1836
				       41  13 00480 	    BEQL    12$							      ;
		         52	       53  D0 00482 	    MOVL    DISP_SIZE, F					      ; 1842
		         04	       53  D1 00485 	    CMPL    DISP_SIZE, #4					      ;
				       16  15 00488 	    BLEQ    9$							      ;
		         52	       04  D0 0048A 	    MOVL    #4, F						      ; 1845
	      00000000G  FF	       3F  90 0048D 	    MOVB    #63, @PAT$CP_OUT_STR				      ; 1846
			    00000000G  EF  D6 00494 	    INCL    PAT$CP_OUT_STR					      ;
			    00000000G  EF  D6 0049A 	    INCL    PAT$GL_BUF_SIZ					      ;
		         0C	       6A  E9 004A0 9$:     BLBC    MAP_FLAG, 10$					      ; 1852
				4004   8F  BB 004A3 	    PUSHR   #^M<R2,SP>						      ; 1854
				  04   AC  DD 004A7 	    PUSHL   STREAM_PTR						      ;
		         6B	       03  FB 004AA 	    CALLS   #3, PAT$GET_VALUE					      ;
				       0A  11 004AD 	    BRB     11$							      ; 1852
	   50	         52	       03  78 004AF 10$:    ASHL    #3, F, R0						      ; 1856

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 8-5
; Digital Equipment Corporation
;
      04   BC	         50	       00  EF 004B3 	    EXTZV   #0, R0, @STREAM_PTR, STREAM_VALUE			      ;
				       6E     004B8									      ;
	   50	         52	       03  78 004B9 11$:    ASHL    #3, F, R0						      ; 1857
	   6E	         50	       00  EE 004BD 	    EXTV    #0, R0, STREAM_VALUE, @DISPL			      ;
				  0C   BC     004C1									      ;
		    10   BC	       52  D0 004C3 12$:    MOVL    F, @PTR_DISP_SIZE					      ; 1864
		    1C   BC	       53  C0 004C7 	    ADDL2   DISP_SIZE, @INS_PC					      ; 1865
	   50	    04   AC	       53  C1 004CB 	    ADDL3   DISP_SIZE, STREAM_PTR, R0				      ; 1866
					   04 004D0 	    RET     							      ; 1662

; Routine Size:  225 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 9
; Digital Equipment Corporation
;
;	1868	ROUTINE INS_CONTEXT( INDEX, OPCODE ) =
;	1869	
;	1870	!++
;	1871	! FUNCTIONAL DESCRIPTION:
;	1872	!
;	1873	!	THIS ROUTINE DECIDES WHAT CONTEXT APPLIES TO THE GIVEN
;	1874	!	OPERAND FOR A SPECIFIC OPCODE.  IT IS USED TO DETERMINE
;	1875	!	WHETHER A PC-RELATIVE MODE FOR THIS OPERAND WOULD
;	1876	!	REQUIRE A BYTE, WORD, LONGWORD, OR QUADWORD OPERAND.
;	1877	!
;	1878	! CALLING SEQUENCE:
;	1879	!
;	1880	!	INS_CONTEXT ();
;	1881	!
;	1882	! INPUTS:
;	1883	!
;	1884	!	INDEX - OPERAND IS BEING DECODED.  THIS NUMBER
;	1885	!		MUST BE 1, 2, ... 6.
;	1886	!	OPCODE	-THE OPCODE OF THE INSTRUCTION BEING DECODED.
;	1887	!		 (This parameter has already been validated.)
;	1888	!
;	1889	! IMPLICIT INPUTS:
;	1890	!
;	1891	!	None.
;	1892	!
;	1893	! OUTPUTS:
;	1894	!
;	1895	!	NONE.
;	1896	!
;	1897	! IMPLICIT OUTPUTS:
;	1898	!
;	1899	!	NONE.
;	1900	!
;	1901	! ROUTINE VALUE:
;	1902	!
;	1903	!	IF SOME ERROR IS DETECTED, RETURN FALSE.  OTHERWISE RETURN
;	1904	!	THE NUMBER OF BYTES FROM THE INSTRUCTION STREAM THAT THE CURRENT
;	1905	!	OPERAND REFERENCE SHOULD CONSUME.  THIS NUMBER WILL BE:
;	1906	!
;	1907	!     NUMBER	OP_CONTEXT 	NAME FROM OPI MACRO DEFINITION
;	1908	!   OF BYTES         VALUE
;	1909	!	
;	1910	!	    1	         0		BYT
;	1911	!	    2		 1		WRD
;	1912	!	    4		 2		LNG
;	1913	!	    8		 3		QAD
;	1914	!
;	1915	!   THE VALUE, 0 TO 3, STORED IN THE OP_CONTEXT FIELD IS SIMPLY 
;	1916	!   OUR ENCODING OF 4 VALUES INTO A 2-BIT FIELD.  THE 'NUMBER OF
;	1917	!   BYTES' ENTRY, ABOVE, IS THE NUMBER BEING SOUGHT.
;	1918	!
;	1919	! SIDE EFFECTS:
;	1920	!
;	1921	!	NONE.
;	1922	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 9-1
; Digital Equipment Corporation
;
;	1923	
;	1924	BEGIN
;	1925	!++
;	1926	! CHECK FOR ANY OF THE FOLLOWING ERROR CONDITIONS:
;	1927	!	1) UNRECOGNIZED OPCODE.
;	1928	!	2) INSUFFICIENT INFORMATION ABOUT IT.
;	1929	!	   (IE - IT IS RESERVED OR YET TO BE DEFINED).
;	1930	!	3)  CONFLICTING INFORMATION ABOUT NUMBER OF OPERANDS FOR OPCODE.
;	1931	!	   THIS CHECK IS NECESSARY BECAUSE THE 'NUL' ENTRY IN THE OPINFO
;	1932	!	   MACROS RESULTS IN THE SAME VALUE BEING ENCODED AS THE 'BYT' ONES DO.
;	1933	!	   THIS ERROR CAN BE CAUGHT AT THIS POINT (BY LOOKING AT THE OP_NUMOPS ENTRY FOR
;	1934	!	   THIS OPCODE), IT DID NOT SEEM WORTH TAKING UP MORE BITS IN THE OPINFO
;	1935	!	   TABLE TO DIFFERENTIATE 'NUL' AND THE OTHERS.
;	1936	!--
;	1937	IF (.OPCODE LSS 0 OR .OPCODE GTR MAXOPCODE)			! ERROR 1, SEE ABOVE.
;	1938	THEN
;	1939		RETURN(FALSE);
;	1940	IF (.PAT$GB_OPINFO[.OPCODE, OP_NUMOPS] EQL NOT_AN_OP)		! ERROR 2, SEE ABOVE.
;	1941	THEN
;	1942		RETURN(FALSE);
;	1943	IF ((.PAT$GB_OPINFO[.OPCODE, OP_NUMOPS] LSS .INDEX) OR
;	1944	   (.INDEX LEQ 0))						! ERROR 3, SEE ABOVE.
;	1945	THEN
;	1946		RETURN(FALSE);
;	1947	
;	1948	!++
;	1949	! NOW IT IS JUST A MATTER OF LOOKING INTO OUR OPINFO TABLE TO REQUIRE 0, 1, 2,
;	1950	! OR 3.  THIS JUST HAPPENS TO BE THE POWER OF 2 WHICH NEEDED TO CALCULATE THE
;	1951	! NUMBER OF BYTES OCCUPIED BY THE CORRESPONDING OPERAND.
;	1952	!--
;	1953	RETURN (( 1 ^ .PAT$GB_OPINFO[.OPCODE, OP_CONTEXT(.INDEX)]));
;	1954	END;





					 0004 004D1 INS_CONTEXT:
							    .WORD   Save R2						      ; 1868
		         50	  08   AC  D0 004D3 	    MOVL    OPCODE, R0						      ; 1937
				       40  19 004D7 	    BLSS    1$							      ;
	      000000FF   8F	       50  D1 004D9 	    CMPL    R0, #255						      ;
				       37  14 004E0 	    BGTR    1$							      ;
		         50	       06  C4 004E2 	    MULL2   #6, R0						      ; 1940
		         52 00000000GEF40  9E 004E5 	    MOVAB   PAT$GB_OPINFO+4[R0], R2				      ;
	   62	         04	       00  EC 004ED 	    CMPV    #0, #4, (R2), #-1					      ;
			    FFFFFFFF   8F     004F1									      ;
				       21  13 004F6 	    BEQL    1$							      ;
	   62	         04	       00  EC 004F8 	    CMPV    #0, #4, (R2), INDEX					      ; 1943
				  04   AC     004FC									      ;
				       19  19 004FE 	    BLSS    1$							      ;
				  04   AC  D5 00500 	    TSTL    INDEX						      ; 1944
				       14  15 00503 	    BLEQ    1$							      ;
		         50	  04   AC  D0 00505 	    MOVL    INDEX, R0						      ; 1953
		         50	       02  C4 00509 	    MULL2   #2, R0						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 9-2
; Digital Equipment Corporation
;
		         50	       02  C0 0050C 	    ADDL2   #2, R0						      ;
	   62	         02	       50  EF 0050F 	    EXTZV   R0, #2, (R2), R1					      ;
				       51     00513									      ;
	   50	         01	       51  78 00514 	    ASHL    R1, #1, R0						      ;
					   04 00518 	    RET     							      ;
				       50  D4 00519 1$:     CLRL    R0							      ; 1868
					   04 0051B 	    RET     							      ;

; Routine Size:  75 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 10
; Digital Equipment Corporation
;
;	1955	ROUTINE CHK_ASD_TBL( INS_PC, ASD_ENTRY_PTR, ASM_DIR_TBL ) =
;	1956	
;	1957	!++
;	1958	! FUNCTIONAL DESCRIPTION:
;	1959	!
;	1960	! This routine determines if the PC to be decoded is a known assembler
;	1961	! directive.  If there is no assembler directive correlation table or the flag
;	1962	! specifies not to check it, then FALSE is returned.  Otherwise, the table is
;	1963	! searched to see if it contains the given PC.  If not FALSE is returned.  If
;	1964	! the PC is within the table, then the offset into the OPINFO table to the
;	1965	! directive is returned.  Also, in this case, a pointer into the assembler
;	1966	! directive table is returned.
;	1967	!
;	1968	! CALLING SEQUENCE:
;	1969	!
;	1970	!	CHK_ASD_TBL( INS_PC, ASD_ENTRY_PTR, ASM_DIR_TBL )
;	1971	!
;	1972	! INPUTS:
;	1973	!
;	1974	!	INS_PC - the PC to search the ASD table for
;	1975	!	ASD_ENTRY_PTR - location to place ASD table pointer if found
;	1976	!	ASM_DIR_TBL - flag indicating whether or not to search ASD table,
;	1977	!			FALSE = do not search, TRUE = search
;	1978	!
;	1979	! IMPLICIT INPUTS:
;	1980	!
;	1981	!	The ASD table must have been initialized.
;	1982	!
;	1983	! OUTPUTS:
;	1984	!
;	1985	!	The pointer into the ASD table is set to 0 or the appropriate entry.
;	1986	!
;	1987	! IMPLICIT OUTPUTS:
;	1988	!
;	1989	!	NONE.
;	1990	!
;	1991	! ROUTINE VALUE:
;	1992	!
;	1993	!	The returned value is either:
;	1994	!
;	1995	!		FALSE, if the PC is not in the table or there was no ASD table.
;	1996	!		otherwise, it is the "OPCODE" offset into the OPINFO table.
;	1997	!
;	1998	! SIDE EFFECTS:
;	1999	!
;	2000	!	NONE.
;	2001	!
;	2002	!--
;	2003	
;	2004	BEGIN
;	2005	
;	2006	MAP
;	2007		ASM_DIR_TBL : REF BLOCK[,BYTE],				! Descriptor for assembler directive table
;	2008		ASD_ENTRY_PTR : REF VECTOR[,LONG];			! Pointer to set if PC is found in ASD table
;	2009	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 10-1
; Digital Equipment Corporation
;
;	2010	LOCAL
;	2011		OPINFO_PTR : REF BLOCK[,BYTE],				! Local pointer into OPINFO table from ASD entry
;	2012		ASD_SIZE,						! Remaining length of ASD table to search
;	2013		ASD_PTR : REF BLOCK[,BYTE];				! Local pointer into ASD table for search
;	2014	
;	2015	!++
;	2016	! Check if an ASD table was built.  If not, this means that there was
;	2017	! no assembler directive in the instructions just deposited.
;	2018	!--
;	2019	IF (.ASM_DIR_TBL EQL 0)
;	2020	THEN
;	2021		RETURN(FALSE);
;	2022	IF ((ASD_PTR = .ASM_DIR_TBL[DSC$A_POINTER]) EQL 0)
;	2023	THEN
;	2024		RETURN(FALSE);
;	2025	
;	2026	!++
;	2027	! Loop, searching the assembler directive table, ASD, for the PC provided.
;	2028	! If it is located, then set the ASD_ENTRY_PTR pointer and return the opcode
;	2029	! offset into the OPINFO table.  If this routine falls out of the loop, then
;	2030	! the PC was not in the table and FALSE is returned.
;	2031	!--
;	2032	ASD_SIZE = .ASM_DIR_TBL[DSC$W_LENGTH];
;	2033	ASD_ENTRY_PTR[0] = 0;
;	2034	WHILE .ASD_SIZE GEQ ASD$C_SIZE
;	2035	DO
;	2036		BEGIN
;	2037		IF (.INS_PC EQL .ASD_PTR[ASD$L_PC])
;	2038		THEN
;	2039			BEGIN
;	2040			!++
;	2041			! PC was found in the ASD table.  Set up return values.
;	2042			!--
;	2043			ASD_ENTRY_PTR[0] = .ASD_PTR;
;	2044			OPINFO_PTR = .ASD_PTR[ASD$L_OPINFO];
;	2045			RETURN (  IF (.OPINFO_PTR[OP_BR_TYPE] EQL BR_BY)
;	2046				  THEN  (MAXOPCODE - 2)
;	2047				  ELSE  IF (.OPINFO_PTR[OP_BR_TYPE] EQL BR_WD)
;	2048					THEN (MAXOPCODE - 1)
;	2049					ELSE (MAXOPCODE));
;	2050			END
;	2051		ELSE
;	2052			BEGIN
;	2053			!++
;	2054			! PC is not equal to this entry.  Update to next entry in table.
;	2055			!--
;	2056			ASD_SIZE = .ASD_SIZE - ASD$C_SIZE;
;	2057			ASD_PTR = CH$PTR (.ASD_PTR, ASD$C_SIZE);
;	2058			END;
;	2059		END;
;	2060	
;	2061	!++
;	2062	! PC was not in the table.  Return FALSE (indicating not found) .
;	2063	!--
;	2064	RETURN(FALSE);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 10-2
; Digital Equipment Corporation
;
;	2065	END;





					 000C 0051C CHK_ASD_TBL:
							    .WORD   Save R2,R3						      ; 1955
		         50	  0C   AC  D0 0051E 	    MOVL    ASM_DIR_TBL, R0					      ; 2019
				       46  13 00522 	    BEQL    5$							      ;
		         52	  04   A0  D0 00524 	    MOVL    4(R0), ASD_PTR					      ; 2022
				       40  13 00528 	    BEQL    5$							      ;
		         53	       60  3C 0052A 	    MOVZWL  (R0), ASD_SIZE					      ; 2032
				  08   BC  D4 0052D 	    CLRL    @ASD_ENTRY_PTR					      ; 2033
		         09	       53  D1 00530 1$:     CMPL    ASD_SIZE, #9					      ; 2034
				       35  19 00533 	    BLSS    5$							      ;
		         62	  04   AC  D1 00535 	    CMPL    INS_PC, (ASD_PTR)					      ; 2037
				       27  12 00539 	    BNEQ    4$							      ;
		    08   BC	       52  D0 0053B 	    MOVL    ASD_PTR, @ASD_ENTRY_PTR				      ; 2043
		         51	  04   A2  D0 0053F 	    MOVL    4(ASD_PTR), OPINFO_PTR				      ; 2044
      05   A1	         04	       04  ED 00543 	    CMPZV   #4, #4, 5(OPINFO_PTR), #1				      ; 2045
				       01     00548									      ;
				       05  12 00549 	    BNEQ    2$							      ;
		         50	  FD   8F  9A 0054B 	    MOVZBL  #253, R0						      ;
					   04 0054F 	    RET     							      ;
      05   A1	         04	       04  ED 00550 2$:     CMPZV   #4, #4, 5(OPINFO_PTR), #2				      ; 2047
				       02     00555									      ;
				       05  12 00556 	    BNEQ    3$							      ;
		         50	  FE   8F  9A 00558 	    MOVZBL  #254, R0						      ;
					   04 0055C 	    RET     							      ;
		         50	  FF   8F  9A 0055D 3$:     MOVZBL  #255, R0						      ;
					   04 00561 	    RET     							      ; 2045
		         53	       09  C2 00562 4$:     SUBL2   #9, ASD_SIZE					      ; 2056
		         52	       09  C0 00565 	    ADDL2   #9, ASD_PTR						      ; 2057
				       C6  11 00568 	    BRB     1$							      ; 2034
				       50  D4 0056A 5$:     CLRL    R0							      ; 1955
					   04 0056C 	    RET     							      ;

; Routine Size:  81 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:23:33	DBB3:[PATCH.SRC]PATMAC.B32;16					Page 11
; Digital Equipment Corporation
;
;	2066	END
;	2067	ELUDOM






;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$OWN       	    32    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	    32  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  _PAT$CODE      	  1389  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]STARLET.L32;1		      2688         2         0       108





; Size:		1389 code + 64 data bytes
; Run Time:	00:40.5
; Elapsed Time:	01:08.5
; Memory Used:	246 pages
; Compilation Complete
