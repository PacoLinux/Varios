
; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATRST (
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.13'
;	0007			) =
;	0008	BEGIN
;	0009	
;	0010	! COPYRIGHT (c) 1977
;	0011	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0012	!
;	0013	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0014	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0015	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0016	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0017	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0018	! TRANSFERRED.
;	0019	!
;	0020	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0021	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0022	! CORPORATION.
;	0023	!
;	0024	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0025	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0026	!
;	0027	
;	0028	!++
;	0029	! FACILITY:	PATCH
;	0030	!
;	0031	! ABSTRACT:	Use the Runtime Symbol Table (RST) data structures.
;	0032	!
;	0033	!
;	0034	! ENVIRONMENT:	This module runs on VAX under VAX/VMS, user mode, non-AST level.
;	0035	!
;	0036	! Author:	Kevin Pammett, August 18, 1977.
;	0037	!
;	0038	! Version:  X01.13
;	0039	!
;	0040	! MODIFICATIONS:
;	0041	!
;	0042	!  NO	DATE		PROGRAMMER		PURPOSE
;	0043	!  --	----		----------		-------
;	0044	!
;	0045	!  00	21-DEC-77	K.D. MORSE		ADAPT VERSION 30 FOR PATCH.
;	0046	!  01	4-JAN-78	K.D. MORSE		MAKE PAT$DST_VALUE DISTINGUISH
;	0047	!						BETWEEN WHAT IT CAN'T EVALUATE
;	0048	!						BECAUSE OF ERROR AND BECAUSE THE
;	0049	!						GIVEN CONTEXT (REGISTER SET) IS
;	0050	!						INAPPROPRIATE. (31)
;	0051	!  02	24-JAN-78	K.D. MORSE		NO CHANGES FOR 32.
;	0052	!  03	02-MAR-78	K.D. MORSE		NO CHANGES FOR 33.
;	0053	!  04	24-MAR-78	K.D. MORSE		NO CHANGES FOR 34.
;	0054	!  05	28-MAR-78	K.D. MORSE		PAT$DST_VALUE NOW ACCEPTS
;	0055	!						DESCRIPTORS WHOSE _ACCESS

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 1-1
; Digital Equipment Corporation
;
;	0056	!						FIELD = 2 FOR THE PC;  THESE
;	0057	!						ARE FIXED-POSITION DESCS. (35)
;	0058	!  06	30-MAR-78	K.D. MORSE		ADD RETURN STATUS CODE OF 3
;	0059	!						TO INDICATE ARRAY DESCRIPTORS
;	0060	!						FROM PAT$SYM_TO_VALU AND
;	0061	!						PAT$SYMBOL_VALU.  THIS IS SO
;	0062	!						THAT PAT$SYM_TO_VAL CAN
;	0063	!						ALWAYS RETURN THE ADDRESS BOUND
;	0064	!						TO A SYMBOL.
;	0065	!  07	06-APR-78	K.D. MORSE		LOOKUP_SYM NOW HANDLES SPECIAL
;	0066	!						EFFORT IN FINDING GLOBALS. (36)
;	0067	!						ROUTINES LOOKUP_GBL AND
;	0068	!						GBL_VAL_TO_SAT ADDED. (36)
;	0069	!						NEW MC_GBL FIELD 'LOCKED'.  IT 
;	0070	!						MEANS THAT THE LOOKUP RTNS ARE
;	0071	!						NOT TO CONSULT THE GST. (37)
;	0072	!						NO MORE ACCS_DESCRIPTOR'S THAT
;	0073	!						POINT TO DESCRIPTORS IN THE USER'S
;	0074	!						IMAGE FROM FORTRAN. (38)
;	0075	!  08	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0076	!  09	17-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 39-40.
;	0077	!  10	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 41.
;	0078	!  11	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0079	!  12	15-JUN-78	K.D. MORSE		PAT$SYM_TO_VALU RETURNS 0 OR 2
;	0080	!						FOR FAILURE. CHANGE CHECK IN
;	0081	!						PAT$SYM_TO_VAL TO TEST FOR LOW BIT.
;	0082	!  13	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 42-43.
;	0083	!
;	0084	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 2
; Digital Equipment Corporation
;
;	0085	!
;	0086	! TABLE OF CONTENTS:
;	0087	!
;	0088	
;	0089	FORWARD ROUTINE
;	0090		PAT$ADD_NT_T_PV,					! Build a pathanme vector by 
;	0091									! following an NT scope chain.
;	0092		PAT$LOOKUP_SYM,						! Find all occurrences of a given
;	0093									! symbol in the RST data base.
;	0094		LOOKUP_GBL,						! Find all occurrences of a given
;	0095									! global symbol in the GST.
;	0096		GBL_VAL_TO_SAT,						! Translate VALUE to a global symbol.
;	0097		PAT$GET_NXT_DUP,					! Scan along hash chains.
;	0098		PAT$SYM_TO_VAL,						! LOOK UP A FULLY QUALIFIED SYMBOL.
;	0099		PAT$SYM_TO_VALU,					! Return more info than sym_to_val,
;	0100									! but otherwise do the same thing.
;	0101		CONCAT_PATHS : NOVALUE,					! Concatenate two pathname vectors together.
;	0102		PAT$NT_HASH_FCN,					! Hashing function for calculating
;	0103									! dispersal of NT entries.
;	0104		PATH_MATCH,						! Match a pathname to the implied
;	0105									! path associated with an NT record.
;	0106		PAT$VAL_TO_SYM,						! Translate values to PATCH-time symbols.
;	0107		LOOKUP_LVT,						! Search the LVT.
;	0108		VAL_TO_SAT,						! Search the SAT.
;	0109		PAT$SYMBOL_VALU,					! Associate symbols with corresponding values.
;	0110		PAT$DST_VALUE,						! Deduce the value associated with a DST
;	0111		STD_SYM_EVAL;						! Evaluate dynamic symbols which use
;	0112									! a standard encoding for how to do
;	0113									! this evaluation.
;	0114	
;	0115	!
;	0116	! INCLUDE FILES:
;	0117	!
;	0118	
;	0119	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0120	REQUIRE 'SRC$:PATPCT.REQ';
;	0136	REQUIRE 'SRC$:SYSSER.REQ';
;      R0144	SWITCHES LIST (SOURCE);
;      R0145	
;      R0146	EXTERNAL ROUTINE
;      R0147		PAT$fao_out;		! formats a line and outputs to the terminal
;      R0148	
;      R0149	SWITCHES LIST (NOSOURCE);
;	0194	REQUIRE 'SRC$:VXSMAC.REQ';
;	0234	REQUIRE 'SRC$:PATGEN.REQ';
;	0413	REQUIRE 'SRC$:PATRST.REQ';
;	1471	REQUIRE 'LIB$:PATMSG.REQ';
;	1629	
;	1630	!
;	1631	! MACROS:
;	1632	!
;	1633	
;	1634	!
;	1635	! EQUATED SYMBOLS:
;	1636	!

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 2-1
; Digital Equipment Corporation
;
;	1637	
;	1638	
;	1639	!
;	1640	! OWN STORAGE:
;	1641	!
;	1642	
;	1643	!
;	1644	! EXTERNAL REFERENCES:
;	1645	!
;	1646	
;	1647	EXTERNAL
;	1648		PAT$GL_MC_PTR	: REF MC_RECORD,			! Pointer to the Module Chain (MC).
;	1649		PAT$GL_NT_HASH	: REF RST_POINTER,			! Pointer to the name table (NT) hash vector.
;	1650		PAT$GB_MOD_PTR : REF VECTOR[,BYTE],
;	1651		PAT$GL_CSP_PTR : REF PATHNAME_VECTOR;
;	1652	
;	1653	EXTERNAL ROUTINE
;	1654		PAT$GET_NXT_SAT,					! Provide access to the SAT
;	1655		PAT$GET_NXT_LVT,					! Provide access to the LVT
;	1656		PAT$GET_NXT_GST,					! Scan the global symbol table.
;	1657		PAT$GET_DST_REC,					! Make a certain DST record available.
;	1658		PAT$MAP_ADDR;						! Map program address
;	1659	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 3
; Digital Equipment Corporation
;
;	1660	GLOBAL ROUTINE PAT$ADD_NT_T_PV( NT_PTR, PV_PTR ) =
;	1661	
;	1662	!++
;	1663	! Functional Description:
;	1664	!
;	1665	!	Recur down thru an NT scope chain to build a pathname vector to
;	1666	!	correspond to the pathname implied by the scope chain.
;	1667	!
;	1668	! Formal Parameters:
;	1669	!
;	1670	!  NT_PTR	-a pointer to the NT record where
;	1671	!		 the symbol name is contained.  This is where the
;	1672	!		 so-called 'scope chain' begins, if you consider such
;	1673	!		 a pathname to go right to left.
;	1674	!  PV_PTR	-a pointer to somewhere in the pathname vector we are
;	1675	!		 building.  Specifically, this points to where we should
;	1676	!		 store a pointer to the first part (MODULE)
;	1677	!		 of the pathname.
;	1678	!
;	1679	! Implicit Inputs:
;	1680	!
;	1681	!	NT scope chains end either when the NT type is MODULE, or when the
;	1682	!	UP_SCOPE pointer is 0.  (The latter is what we do for NT records which
;	1683	!	come in to PATCH as global of DEFine symbols).
;	1684	!
;	1685	!	Scope chains, as built by simply chaining thru NT records,
;	1686	!	are 'reverse pathnames', as defined by PATHNAME_VECTOR.  This
;	1687	!	is why this routine is recursive - we must recur down to
;	1688	!	the end of the NT chain before we can begin returning
;	1689	!	and filling in the pathname vector.
;	1690	!
;	1691	! Implicit Outputs:
;	1692	!
;	1693	!	None.
;	1694	!
;	1695	! Return Value:
;	1696	!
;	1697	!	The address (supposedly within the pathname vector)
;	1698	!	of where the next cs_pointer should be stored.
;	1699	!
;	1700	! Side Effects:
;	1701	!
;	1702	!	This routine will blow up if the NT chain implies a
;	1703	!	pathname that is longer than is expected by the
;	1704	!	PATHNAME_VECTOR declaration.
;	1705	!
;	1706	!--
;	1707	BEGIN
;	1708	
;	1709	MAP
;	1710		NT_PTR : REF NT_RECORD,
;	1711		PV_PTR : REF PATHNAME_VECTOR;
;	1712	
;	1713	!++
;	1714	! There's not much we can do till we've reached the end of the NT scope chain.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 3-1
; Digital Equipment Corporation
;
;	1715	!--
;	1716	IF (.NT_PTR[NT_TYPE] NEQ DSC$K_DTYPE_MOD) AND (.NT_PTR[NT_UP_SCOPE] NEQ 0) 
;	1717	THEN
;	1718		PV_PTR = PAT$ADD_NT_T_PV( .NT_PTR[NT_UP_SCOPE], .PV_PTR );
;	1719	
;	1720	!++
;	1721	! The recursive call has modified our idea of where in the pathvector we
;	1722	! should put the name pointer of the current pathname element.  Once MODULE has
;	1723	! been reached, though, backing up (and out) is straightforward.
;	1724	!--
;	1725	PV_PTR[0] = NT_PTR[NT_NAME_CS];
;	1726	
;	1727	!++
;	1728	! The next element's CS pointer goes in the next higher pathname vector element.
;	1729	! Since we do not recur on the last time around (i.e. after the last ROUTINE
;	1730	! name was inserted), and since we must guarantee to end the pathname vector
;	1731	! with a 0 cs pointer, we zero each potential 'next' entry here to ensure this.
;	1732	! This is the point where damage will be done if/when someone gives a pathname
;	1733	! that is too long, since the recursion does not 'count' how many times it fills
;	1734	! in a PATHNAME_VECTOR entry.
;	1735	!--
;	1736	PV_PTR[1] = 0;
;	1737	RETURN( PV_PTR[1] );
;	1738	END;


							    .TITLE  PATRST
							    .IDENT  \X01.13\

							    .GLOBL  PAT$FAO_OUT, PAT$GL_RST_BEGN, PAT$GL_MC_PTR, PAT$GL_NT_HASH
							    .GLOBL  PAT$GB_MOD_PTR, PAT$GL_CSP_PTR, PAT$GET_NXT_SAT
							    .GLOBL  PAT$GET_NXT_LVT, PAT$GET_NXT_GST, PAT$GET_DST_REC
							    .GLOBL  PAT$MAP_ADDR

							    .PSECT  _PAT$CODE,NOWRT,2

					 0800 00000 	    .ENTRY  PAT$ADD_NT_T_PV, Save R11				      ; 1660
		         5B 00000000G  EF  9E 00002 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
	   50	    04   AC	       6B  C1 00009 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R0				      ; 1716
		    BC   8F	  02   A0  91 0000E 	    CMPB    2(R0), #188						      ;
				       14  13 00013 	    BEQL    1$							      ;
				  08   A0  B5 00015 	    TSTW    8(R0)						      ;
				       0F  13 00018 	    BEQL    1$							      ;
				  08   AC  DD 0001A 	    PUSHL   PV_PTR						      ; 1718
		         7E	  08   A0  3C 0001D 	    MOVZWL  8(R0), -(SP)					      ;
		    DB   AF	       02  FB 00021 	    CALLS   #2, PAT$ADD_NT_T_PV					      ;
		    08   AC	       50  D0 00025 	    MOVL    R0, PV_PTR						      ;
		         50	  08   AC  D0 00029 1$:     MOVL    PV_PTR, R0						      ; 1725
	   51	    04   AC	       6B  C1 0002D 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R1				      ;
	   80	         51	       0C  C1 00032 	    ADDL3   #12, R1, (R0)+					      ;
				       60  D4 00036 	    CLRL    (R0)						      ; 1736
					   04 00038 	    RET     							      ; 1660

; Routine Size:  57 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 3-2
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 4
; Digital Equipment Corporation
;
;	1739	GLOBAL ROUTINE PAT$LOOKUP_SYM( SYM_CS ) =
;	1740	
;	1741	!++
;	1742	! Functional Description:
;	1743	!
;	1744	!	Look for a given symbol (NOT symbol pathname, only the symbol name
;	1745	!	itself) in the RST's name table (NT) always, and in the GST, sometimes.
;	1746	!	The latter happens when the MC_GBL_LOCKED field is FALSE.
;	1747	!
;	1748	!	Since there may be several such pathnames, this routine actually passes
;	1749	!	back a pointer to a so-called duplication chain.  This chain must be
;	1750	!	whatever GET_NXT_DUP requires to 'track down' successive duplicates.
;	1751	!
;	1752	! Formal Parameters:
;	1753	!
;	1754	!	SYM_CS		-a counted string pointer to the symbol we are
;	1755	!			 to look for in the NT.
;	1756	!
;	1757	! Implicit Inputs:
;	1758	!
;	1759	!	none.
;	1760	!
;	1761	! Implicit Outputs:
;	1762	!
;	1763	!	none.
;	1764	!
;	1765	! Return Value:
;	1766	!
;	1767	!
;	1768	!	FALSE, when there is no NT or GST entry for 'sym_cs',
;	1769	!	an NT-pointer to (a portion of) the hash chain which
;	1770	!	begins with an NT record which has 'sym_cs' as its symbol,
;	1771	!	otherwise.  If a global is found to match, its 'fake' NT record begins
;	1772	!	the hash chain.
;	1773	!
;	1774	! Side Effects:
;	1775	!
;	1776	!	The GST may be searched linearly until the end or until SYM_CS is found.
;	1777	!--
;	1778	
;	1779	BEGIN
;	1780	
;	1781	MAP
;	1782		SYM_CS : CS_POINTER;					! A pointer to the symbol we are to look for.
;	1783	
;	1784	LOCAL
;	1785		GST_RECRD : REF GST_RECORD,				! Pointer to the global symbol table record
;	1786		NT_HASH,						! Hash code for the given symbol.
;	1787		NT_PTR	: REF NT_RECORD;				! Pointer we go thru the NT with.
;	1788	
;	1789	!++
;	1790	! Access to the NT is via hashing.  If there is no pointer in the hash vector
;	1791	! we get to, then no symbols exist that hash to the same value as the symbol
;	1792	! we are looking up.  Otherwise we follow the hash chain and pass back a pointer
;	1793	! to the first symbol we find which matches 'sym_cs'.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 4-1
; Digital Equipment Corporation
;
;	1794	!--
;	1795	NT_HASH = PAT$NT_HASH_FCN( .SYM_CS );
;	1796	
;	1797	!++
;	1798	! First see if a global symbol can be found by the given name in the GST.
;	1799	!--
;	1800	IF ((GST_RECRD = LOOKUP_GBL(.SYM_CS)) NEQ 0) AND
;	1801	    ((NT_PTR = .PAT$GL_MC_PTR[ MC_GBL_NT_PTR ]) NEQ 0)
;	1802	THEN
;	1803		BEGIN
;	1804		LOCAL
;	1805			global_type,
;	1806			NAME_CS : CS_POINTER;
;	1807	
;	1808		!++
;	1809		! Found a global symbol.  Fill in the fake NT record for this global
;	1810		! so that the rest of the sym_to_val routines don't have to worry about
;	1811		! the special casing for globals.  The symbol name is in a different
;	1812		! place depending on which type of GSD this is.  Pick up a pointer
;	1813		! to this name, and record the GSD type.
;	1814		!--
;	1815		IF (.GST_RECRD[GST_ENTRY_TYPE] EQL GST_GLOBAL_DEFN)
;	1816		THEN
;	1817			BEGIN
;	1818			NAME_CS = GST_RECRD[GST_G_NAME_CS];
;	1819			GLOBAL_TYPE = DSC$K_DTYPE_GBL;
;	1820			END
;	1821		ELSE
;	1822			BEGIN
;	1823			NAME_CS = GST_RECRD[GST_E_NAME_CS];
;	1824			GLOBAL_TYPE = DSC$K_DTYPE_ENT;
;	1825			END;
;	1826	
;	1827		!++
;	1828		! Move the relevant fields into the NT record already reserved and
;	1829		! pointer to by a field in the global MC record.
;	1830		!--
;	1831		CH$MOVE( .NAME_CS[0]+1, NAME_CS[0], NT_PTR[NT_NAME_CS]);
;	1832		NT_PTR[NT_TYPE] = .GLOBAL_TYPE;
;	1833		NT_PTR[NT_IS_GLOBAL] = TRUE;
;	1834		NT_PTR[NT_UP_SCOPE] = 0;
;	1835		NT_PTR[NT_GBL_VALUE] = .GST_RECRD[GST_VALUE];
;	1836	
;	1837		!++
;	1838		! Make this NT point forward to the hash chain in the RST for symbols
;	1839		! which hash to this same value.  Whether or not there are any such
;	1840		! symbols, we have still built a duplication chain.  We carefully don't
;	1841		! change the existing hash chain so that nothing in the RST is actually
;	1842		! changed by the addition of this new fake NT for the found global symbol.
;	1843		!--
;	1844		NT_PTR[NT_FORWARD] = .PAT$GL_NT_HASH[.NT_HASH];
;	1845	
;	1846		!++
;	1847		! The duplication chain has been built.
;	1848		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 4-2
; Digital Equipment Corporation
;
;	1849		RETURN(.NT_PTR);
;	1850		END;
;	1851	
;	1852	!++
;	1853	! Access to the NT is via hashing.  If there is no pointer in the hash vector we
;	1854	! get to, then no symbols exist that hash to the same value as the symbol we are
;	1855	! looking up.  Otherwise we follow the hash chain and pass back a pointer to the
;	1856	! first symbol we find which matches 'sym_cs'.
;	1857	!--
;	1858	IF ((NT_PTR = .PAT$GL_NT_HASH[.NT_HASH]) EQL 0)
;	1859	THEN
;	1860		!++
;	1861		! If there is no hash chain, then there is no 'sym_cs' in the
;	1862		! RST data base.
;	1863		!--
;	1864		RETURN(FALSE);
;	1865	
;	1866	!++
;	1867	! There does exist a hash chain for the given symbol. If a match does exist,
;	1868	! it must be in this chain, so we simply follow along it and compare the symbol
;	1869	! names found therein for the first match.
;	1870	!--
;	1871	DO
;	1872		BEGIN
;	1873		!++
;	1874		! We are only interested in this entry if the symbol names actually do match.
;	1875		!--
;	1876		IF (CH$EQL(.SYM_CS[0],SYM_CS[1],.NT_PTR[NT_NAME_CS],NT_PTR[NT_NAME_ADDR]))
;	1877		THEN
;	1878			BEGIN
;	1879			!++
;	1880			! This is the place in the chain that we want to pass back a pointer to.
;	1881			!--
;	1882			RETURN(.NT_PTR);
;	1883			END;
;	1884	
;	1885		!++
;	1886		! Otherwise just skip along the chain. The hash chain ends when the
;	1887		! NT_FORWARD pointer is 0.
;	1888		!--
;	1889		END
;	1890	WHILE( (NT_PTR = .NT_PTR[NT_FORWARD]) NEQ 0 );
;	1891	
;	1892	!++
;	1893	! If we fall out of the above loop, we ran off the end of the hash chain
;	1894	! without finding a match to the symbol we were looking for.
;	1895	!--
;	1896	RETURN(FALSE);
;	1897	END;





					 0FFC 00039 	    .ENTRY  PAT$LOOKUP_SYM, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11      ; 1739

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 4-3
; Digital Equipment Corporation
;
		         5B 00000000G  EF  9E 0003B 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
				  04   AC  DD 00042 	    PUSHL   SYM_CS						      ; 1795
	      00000000V  EF	       01  FB 00045 	    CALLS   #1, PAT$NT_HASH_FCN					      ;
		         58	       50  D0 0004C 	    MOVL    R0, NT_HASH						      ;
				  04   AC  DD 0004F 	    PUSHL   SYM_CS						      ; 1800
	      00000000V  EF	       01  FB 00052 	    CALLS   #1, LOOKUP_GBL					      ;
		         57	       50  D0 00059 	    MOVL    R0, GST_RECRD					      ;
				       4D  13 0005C 	    BEQL    3$							      ;
	   50 00000000G  EF	       6B  C1 0005E 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R0			      ; 1801
		         59	  04   A0  3C 00066 	    MOVZWL  4(R0), NT_PTR					      ;
				       3F  13 0006A 	    BEQL    3$							      ;
		         01	       67  91 0006C 	    CMPB    (GST_RECRD), #1					      ; 1815
				       0A  12 0006F 	    BNEQ    1$							      ;
	   50	         57	       09  C1 00071 	    ADDL3   #9, GST_RECRD, NAME_CS				      ; 1818
		         5A	  C1   8F  9A 00075 	    MOVZBL  #193, GLOBAL_TYPE					      ; 1819
				       08  11 00079 	    BRB     2$							      ; 1815
	   50	         57	       0B  C1 0007B 1$:     ADDL3   #11, GST_RECRD, NAME_CS				      ; 1823
		         5A	  C0   8F  9A 0007F 	    MOVZBL  #192, GLOBAL_TYPE					      ; 1824
		         51	       60  9A 00083 2$:     MOVZBL  (NAME_CS), R1					      ; 1831
				       51  D6 00086 	    INCL    R1							      ;
	   56	         59	       6B  C1 00088 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R6				      ;
      0C   A6	         60	       51  28 0008C 	    MOVC3   R1, (NAME_CS), 12(R6)				      ;
		    02   A6	       5A  90 00091 	    MOVB    GLOBAL_TYPE, 2(R6)					      ; 1832
		    03   A6	       01  88 00095 	    BISB2   #1, 3(R6)						      ; 1833
				  08   A6  B4 00099 	    CLRW    8(R6)						      ; 1834
		    04   A6	  05   A7  D0 0009C 	    MOVL    5(GST_RECRD), 4(R6)					      ; 1835
		         66 00000000GFF48  B0 000A1 	    MOVW    @PAT$GL_NT_HASH[NT_HASH], (R6)			      ; 1844
				       24  11 000A9 	    BRB     5$							      ; 1849
		         59 00000000GFF48  3C 000AB 3$:     MOVZWL  @PAT$GL_NT_HASH[NT_HASH], NT_PTR			      ; 1858
				       23  13 000B3 	    BEQL    7$							      ;
	   54	    04   AC	       01  C1 000B5 	    ADDL3   #1, SYM_CS, R4					      ; 1876
		         51	  04   BC  9A 000BA 4$:     MOVZBL  @SYM_CS, R1						      ;
	   56	         59	       6B  C1 000BE 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R6				      ;
		         50	  0C   A6  9A 000C2 	    MOVZBL  12(R6), R0						      ;
	   00	         64	       51  2D 000C6 	    CMPC5   R1, (R4), #0, R0, 13(R6)				      ;
		    0D   A6	       50     000CA									      ;
				       04  12 000CD 	    BNEQ    6$							      ;
		         50	       59  D0 000CF 5$:     MOVL    NT_PTR, R0						      ; 1882
					   04 000D2 	    RET     							      ;
		         59	       66  3C 000D3 6$:     MOVZWL  (R6), NT_PTR					      ; 1890
				       E2  12 000D6 	    BNEQ    4$							      ;
				       50  D4 000D8 7$:     CLRL    R0							      ; 1739
					   04 000DA 	    RET     							      ;

; Routine Size:  162 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 5
; Digital Equipment Corporation
;
;	1898	ROUTINE LOOKUP_GBL( SYM_CS ) =
;	1899	
;	1900	!++
;	1901	! Functional Description:
;	1902	!
;	1903	!	Look for a given symbol (NOT symbol pathname, only the
;	1904	!	symbol name itself) in the Global symbol table (GST).
;	1905	!
;	1906	! Formal Parameters:
;	1907	!
;	1908	!	SYM_CS		-a counted string pointer to the symbol we are
;	1909	!			 to look for in the GST.
;	1910	!
;	1911	! Implicit Inputs:
;	1912	!
;	1913	!
;	1914	!	We don't consult the GST if MC_GBL_LOCKED is TRUE.
;	1915	!
;	1916	!	GET_NXT_GST is all set up to allow us to
;	1917	!	read thru the (mapped) GST sequentially.
;	1918	!
;	1919	! Implicit Outputs:
;	1920	!	none.
;	1921	!
;	1922	! Return Value:
;	1923	!
;	1924	!	0, when no GST entry for 'sym_cs' can be found,
;	1925	!	a pointer to the GST record for
;	1926	!	the found symbol, otherwise.
;	1927	!
;	1928	! Side Effects:
;	1929	!
;	1930	!	The GST may be searched sequentially until either
;	1931	!	the end is encounered, or the symbol is found.
;	1932	!--
;	1933	
;	1934	BEGIN
;	1935	
;	1936	MAP
;	1937		SYM_CS : CS_POINTER;
;	1938	
;	1939	LOCAL
;	1940		GST_RECRD : REF GST_RECORD;				! Pointer to where a fetched GST record lives.
;	1941	
;	1942	!++
;	1943	! Don't even look in the GST if it is locked.  This happens either because the
;	1944	! caller specifically does not want a global, or because the caller is using the
;	1945	! 'cache' NT and SAT records for globals, and doesn't want them overwritten.
;	1946	!--
;	1947	IF (.PAT$GL_MC_PTR[MC_GBL_LOCKED])
;	1948	THEN
;	1949		RETURN(0);
;	1950	
;	1951	!++
;	1952	! Process the GST records sequentially, giving up if some error occurs.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 5-1
; Digital Equipment Corporation
;
;	1953	! First, do an INIT so that subsequent GETs return record pointers starting
;	1954	! from the beginning.
;	1955	!--
;	1956	PAT$GET_NXT_GST(1);
;	1957	
;	1958	!++
;	1959	! PAT$GET_NXT_GST returns 0 when there are no more GST records to process.
;	1960	! Otherwise it returns a pointer to each successive GST record.
;	1961	!--
;	1962	WHILE ((GST_RECRD = PAT$GET_NXT_GST(0)) NEQ 0)
;	1963	DO
;	1964		BEGIN
;	1965		!++
;	1966		! We process each record depending on its GST type.
;	1967		!--
;	1968		CASE .GST_RECRD[GST_ENTRY_TYPE] FROM GST_LOWEST TO GST_HIGHEST OF
;	1969		    SET
;	1970	
;	1971		    [ GST_GLOBAL_DEFN ]:				! Definition of a global symbol.
;	1972			BEGIN
;	1973			!++
;	1974			! Check for string match of given and indicated symbols.
;	1975			!--
;	1976			IF (CH$EQL(.SYM_CS[0], SYM_CS[1], .GST_RECRD[GST_G_NAME_CS],
;	1977					GST_RECRD[GST_G_NAME_ADDR]))
;	1978			THEN
;	1979				!++
;	1980				! Found the right record, and we know there are no more
;	1981				! (because these are globals).
;	1982				!--
;	1983				EXITLOOP;
;	1984			END;
;	1985	
;	1986		    [ GST_ENTRY_DEFN ]:					! Definition of a entry point.
;	1987			BEGIN
;	1988			!++
;	1989			! Check for string match of given and indicated symbols.
;	1990			!--
;	1991			IF (CH$EQL(.SYM_CS[0], SYM_CS[1], .GST_RECRD[GST_E_NAME_CS],
;	1992					GST_RECRD[GST_E_NAME_ADDR]))
;	1993			THEN
;	1994				!++
;	1995				! Found the right record, and we know there are no more
;	1996				! (because these are globals).
;	1997				!--
;	1998				EXITLOOP;
;	1999			END;
;	2000	
;	2001		    [INRANGE, OUTRANGE]:				! Error.
;	2002			BEGIN
;	2003			RETURN(0);
;	2004			END;
;	2005	
;	2006		    TES;
;	2007	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 5-2
; Digital Equipment Corporation
;
;	2008		!++
;	2009		! Go back and process the next record.
;	2010		!--
;	2011		END;
;	2012	
;	2013	!++
;	2014	! If the above WHILE exits, then either we encountered the normal end of GST
;	2015	! processing, or we found the symbol match.  Pass back the address of the given
;	2016	! symbol's record, of 0, the failure code.
;	2017	!--
;	2018	RETURN(.GST_RECRD);
;	2019	END;





					 081C 000DB LOOKUP_GBL:
							    .WORD   Save R2,R3,R4,R11					      ; 1898
		         5B 00000000G  EF  9E 000DD 	    MOVAB   PAT$GET_NXT_GST, R11				      ;
	   50 00000000G  EF 00000000G  EF  C1 000E4 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R0			      ; 1947
	   49	    03   A0	       02  E0 000F0 	    BBS     #2, 3(R0), 7$					      ;
				       01  DD 000F5 	    PUSHL   #1							      ; 1956
		         6B	       01  FB 000F7 	    CALLS   #1, PAT$GET_NXT_GST					      ;
				       7E  D4 000FA 1$:     CLRL    -(SP)						      ; 1962
		         6B	       01  FB 000FC 	    CALLS   #1, PAT$GET_NXT_GST					      ;
		         54	       50  D0 000FF 	    MOVL    R0, GST_RECRD					      ;
				       36  13 00102 	    BEQL    6$							      ;
	   02	         01	       64  8F 00104 	    CASEB   (GST_RECRD), #1, #2					      ; 1968
	 0036	       001D	     0008     00108 2$:     .WORD   3$-2$,-						      ;
								    4$-2$,-						      ;
								    7$-2$						      ;
				       2E  11 0010E 	    BRB     7$							      ; 2003
		         50	  04   AC  D0 00110 3$:     MOVL    SYM_CS, R0						      ; 1976
		         52	       60  9A 00114 	    MOVZBL  (R0), R2						      ;
		         51	  09   A4  9A 00117 	    MOVZBL  9(GST_RECRD), R1					      ;
	   00	    01   A0	       52  2D 0011B 	    CMPC5   R2, 1(R0), #0, R1, 10(GST_RECRD)			      ;
		    0A   A4	       51     00120									      ;
				       13  11 00123 	    BRB     5$							      ;
		         50	  04   AC  D0 00125 4$:     MOVL    SYM_CS, R0						      ; 1991
		         52	       60  9A 00129 	    MOVZBL  (R0), R2						      ;
		         51	  0B   A4  9A 0012C 	    MOVZBL  11(GST_RECRD), R1					      ;
	   00	    01   A0	       52  2D 00130 	    CMPC5   R2, 1(R0), #0, R1, 12(GST_RECRD)			      ;
		    0C   A4	       51     00135									      ;
				       C0  12 00138 5$:     BNEQ    1$							      ;
		         50	       54  D0 0013A 6$:     MOVL    GST_RECRD, R0					      ; 2018
					   04 0013D 	    RET     							      ;
				       50  D4 0013E 7$:     CLRL    R0							      ; 1898
					   04 00140 	    RET     							      ;

; Routine Size:  102 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 6
; Digital Equipment Corporation
;
;	2020	ROUTINE GBL_VAL_TO_SAT( VALUE ) =
;	2021	
;	2022	!++
;	2023	! Functional Description:
;	2024	!
;	2025	!	Search the GST for the closest global symbol match
;	2026	!	to the given value.  If found, build a temporary SAT
;	2027	!	and NT entry for this symbol so that the rest
;	2028	!	of the RST manipulating routine do not have to
;	2029	!	special-case globals.
;	2030	!
;	2031	! Formal Parameters:
;	2032	!
;	2033	!	VALUE	-The key value to match to Global symbol.
;	2034	!
;	2035	! Implicit Inputs:
;	2036	!
;	2037	!	We don't consult the GST if MC_GBL_LOCKED.
;	2038	!	This happens because we normally want 
;	2039	!	to let VAL_TO_SYM consult globals, but to we need 
;	2040	!	to override this when PC_RULE calls it.
;	2041	!
;	2042	!	GET_NXT_GST is all set up to all us to
;	2043	!	read thru the (mapped) GST sequentially.
;	2044	!
;	2045	!	The first MC record is reserved for manipulating
;	2046	!	globals.  As such, it has two fields which permanently
;	2047	!	point to the 'fake' NT and SAT records which get
;	2048	!	filled by this routine (and others).
;	2049	!
;	2050	! Implicit Outputs:
;	2051	!
;	2052	!	If a match is found, the MC_GBL NT and SAT records
;	2053	!	are filled in so that they are usable just like
;	2054	!	other NT/SAT pairs are.
;	2055	!
;	2056	! Return Value:
;	2057	!
;	2058	!	FALSE, when no candidate is found,
;	2059	!	a pointer to the SAT record for
;	2060	!	the found symbol, otherwise.
;	2061	!
;	2062	! Side Effects:
;	2063	!
;	2064	!	The GST may be searched sequentially until either
;	2065	!	the end is encountered, or an exact match is found.
;	2066	!--
;	2067	
;	2068	BEGIN
;	2069	
;	2070	LOCAL
;	2071		GLOBAL_TYPE,
;	2072		NAME_CS : CS_POINTER,
;	2073		GST_RECRD : REF GST_RECORD,				! Pointer to where a fetched GST record lives.
;	2074		GBL_SAT_PTR : REF SAT_RECORD,				! Pointers to the SAT and NT records we build.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 6-1
; Digital Equipment Corporation
;
;	2075		GBL_NT_PTR : REF NT_RECORD,
;	2076		BEST_MATCH : REF GST_RECORD;				! Pointer to so-far 'best' match found.
;	2077	
;	2078	!++
;	2079	! If we find a match candidate, we will use the GLOBAL temporary SAT and NT
;	2080	! records to pass on the needed info.  If no space has been reserved for these
;	2081	! records, we must give up now.  Moreover, if this space is currently in use
;	2082	! (for SYM_TO_VAL) then again we must give up.
;	2083	!--
;	2084	IF (.PAT$GL_MC_PTR[MC_GBL_LOCKED])
;	2085	THEN
;	2086		RETURN(0);
;	2087	IF ((GBL_SAT_PTR = .PAT$GL_MC_PTR[MC_GBL_SAT_PTR]) EQL 0)
;	2088	THEN
;	2089		RETURN(0);
;	2090	IF ((GBL_NT_PTR = .PAT$GL_MC_PTR[MC_GBL_NT_PTR]) EQL 0)
;	2091	THEN
;	2092		RETURN(0);
;	2093	
;	2094	!++
;	2095	! Process the GST records sequentially, giving up if some error occurs.
;	2096	! First, do an INIT so that subsequent GETs return record pointers starting from
;	2097	! the beginning.
;	2098	!--
;	2099	PAT$GET_NXT_GST(1);
;	2100	BEST_MATCH = 0;
;	2101	
;	2102	!++
;	2103	! PAT$GET_NXT_GST returns 0 when there are no more GST records to process.
;	2104	!--
;	2105	WHILE ((GST_RECRD = PAT$GET_NXT_GST(0)) NEQ 0)
;	2106	DO
;	2107		BEGIN
;	2108		!++
;	2109		! We process each record depending on its GST type.
;	2110		!--
;	2111		CASE .GST_RECRD[GST_ENTRY_TYPE] FROM GST_LOWEST TO GST_HIGHEST OF
;	2112		    SET
;	2113	
;	2114		    [ GST_GLOBAL_DEFN ,					! Definition of a global symbol.
;	2115		      GST_ENTRY_DEFN ]:					! Definition of global ENTRY points.
;	2116			BEGIN
;	2117			!++
;	2118			! Note that the only two types we support can be handled
;	2119			! together because the GST_VALUE field is in the same place in
;	2120			! both records.  First check for an exact match because then
;	2121			! we can abandon any further looking.
;	2122			!--
;	2123			IF (.VALUE EQLA .GST_RECRD[GST_VALUE])
;	2124			THEN
;	2125				BEGIN
;	2126				BEST_MATCH = .GST_RECRD;
;	2127				EXITLOOP;
;	2128				END;
;	2129	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 6-2
; Digital Equipment Corporation
;
;	2130			!++
;	2131			! Inexact matches are still better than nothing.
;	2132			!--
;	2133			IF (.VALUE GTRA .GST_RECRD[GST_VALUE])
;	2134			THEN
;	2135				!++
;	2136				! A match.  See if we already have one.
;	2137				!--
;	2138				IF (.BEST_MATCH EQL 0)
;	2139				THEN
;	2140					!++
;	2141					! Any one is better than none.
;	2142					!--
;	2143					BEST_MATCH = .GST_RECRD
;	2144				ELSE
;	2145					!++
;	2146					! Take the new one only if this symbol
;	2147					! is closer than the previous best one.
;	2148					!--
;	2149					IF (.BEST_MATCH[GST_VALUE] LSSA .GST_RECRD[GST_VALUE])
;	2150					THEN
;	2151						BEST_MATCH = .GST_RECRD;
;	2152			END;
;	2153	
;	2154		    [INRANGE, OUTRANGE]:				! Error.
;	2155			BEGIN
;	2156			RETURN(FALSE);
;	2157			END;
;	2158	
;	2159		    TES;
;	2160	
;	2161		!++
;	2162		! Go back and process the next record.
;	2163		!--
;	2164		END;
;	2165	
;	2166	!++
;	2167	! If the above WHILE exits, then we encountered the normal end of GST processing.
;	2168	! If we didn't find any possible match, return failure status.
;	2169	!--
;	2170	IF (.BEST_MATCH EQL 0)
;	2171	THEN
;	2172		RETURN(0);
;	2173	
;	2174	!++
;	2175	! Success - a candidate has been found.  Fill in the required SAT and NT
;	2176	! records, and pass back a pointer to the former.  These records have already
;	2177	! been (permanently) allocated space - they are pointed to by fields in the
;	2178	! global MC record.
;	2179	!--
;	2180	GBL_SAT_PTR[SAT_LB] = .BEST_MATCH[GST_VALUE];
;	2181	GBL_SAT_PTR[SAT_UB] = 0;
;	2182	GBL_SAT_PTR[SAT_NT_PTR] = .GBL_NT_PTR;
;	2183	
;	2184	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 6-3
; Digital Equipment Corporation
;
;	2185	! The symbol name is in a different place depending on which type of GSD this
;	2186	! is.  Pick up a pointer to this name, and record the GSD type.
;	2187	!--
;	2188	IF (.BEST_MATCH[GST_ENTRY_TYPE] EQL GST_GLOBAL_DEFN)
;	2189	THEN
;	2190		BEGIN
;	2191		NAME_CS = BEST_MATCH[GST_G_NAME_CS];
;	2192		GLOBAL_TYPE = DSC$K_DTYPE_GBL;
;	2193		END
;	2194	ELSE
;	2195		BEGIN
;	2196		NAME_CS = BEST_MATCH[GST_E_NAME_CS];
;	2197		GLOBAL_TYPE = DSC$K_DTYPE_ENT;
;	2198		END;
;	2199	CH$MOVE( .NAME_CS[0]+1, NAME_CS[0], GBL_NT_PTR[NT_NAME_CS]);
;	2200	GBL_NT_PTR[NT_TYPE] = .GLOBAL_TYPE;
;	2201	GBL_NT_PTR[NT_IS_GLOBAL] = TRUE;
;	2202	GBL_NT_PTR[NT_GBL_VALUE] = .BEST_MATCH[GST_VALUE];
;	2203	GBL_NT_PTR[NT_FORWARD] = 0;
;	2204	GBL_NT_PTR[NT_UP_SCOPE] = 0;
;	2205	RETURN(.GBL_SAT_PTR);
;	2206	END;





					 0FFC 00141 GBL_VAL_TO_SAT:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11		      ; 2020
		         5A 00000000G  EF  9E 00143 	    MOVAB   PAT$GL_RST_BEGN, R10				      ;
		         5B 00000000G  EF  9E 0014A 	    MOVAB   PAT$GET_NXT_GST, R11				      ;
	   50 00000000G  EF	       6A  C1 00151 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R0			      ; 2084
	   27	    03   A0	       02  E0 00159 	    BBS     #2, 3(R0), 3$					      ;
		         59	  35   A0  D0 0015E 	    MOVL    53(R0), GBL_SAT_PTR					      ; 2087
				       48  13 00162 	    BEQL    8$							      ;
		         56	  04   A0  3C 00164 	    MOVZWL  4(R0), GBL_NT_PTR					      ; 2090
				       42  13 00168 	    BEQL    8$							      ;
				       01  DD 0016A 	    PUSHL   #1							      ; 2099
		         6B	       01  FB 0016C 	    CALLS   #1, PAT$GET_NXT_GST					      ;
				       57  D4 0016F 	    CLRL    BEST_MATCH						      ; 2100
				       7E  D4 00171 1$:     CLRL    -(SP)						      ; 2105
		         6B	       01  FB 00173 	    CALLS   #1, PAT$GET_NXT_GST					      ;
		         52	       50  D0 00176 	    MOVL    R0, GST_RECRD					      ;
				       2F  13 00179 	    BEQL    7$							      ;
	   02	         01	       62  8F 0017B 	    CASEB   (GST_RECRD), #1, #2					      ; 2111
	 0074	       0008	     0008     0017F 2$:     .WORD   4$-2$,-						      ;
								    4$-2$,-						      ;
								    11$-2$						      ;
				       6C  11 00185 3$:     BRB     11$							      ; 2156
		    05   A2	  04   AC  D1 00187 4$:     CMPL    VALUE, 5(GST_RECRD)					      ; 2123
				       05  12 0018C 	    BNEQ    5$							      ;
		         57	       52  D0 0018E 	    MOVL    GST_RECRD, BEST_MATCH				      ; 2126
				       17  11 00191 	    BRB     7$							      ; 2127
		    05   A2	  04   AC  D1 00193 5$:     CMPL    VALUE, 5(GST_RECRD)					      ; 2133
				       D7  1B 00198 	    BLEQU   1$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 6-4
; Digital Equipment Corporation
;
				       57  D5 0019A 	    TSTL    BEST_MATCH						      ; 2138
				       07  13 0019C 	    BEQL    6$							      ;
		    05   A2	  05   A7  D1 0019E 	    CMPL    5(BEST_MATCH), 5(GST_RECRD)				      ; 2149
				       CC  1E 001A3 	    BGEQU   1$							      ;
		         57	       52  D0 001A5 6$:     MOVL    GST_RECRD, BEST_MATCH				      ; 2151
				       C7  11 001A8 	    BRB     1$							      ; 2133
				       57  D5 001AA 7$:     TSTL    BEST_MATCH						      ; 2170
				       45  13 001AC 8$:     BEQL    11$							      ;
		    02   A9	  05   A7  D0 001AE 	    MOVL    5(BEST_MATCH), 2(GBL_SAT_PTR)			      ; 2180
				  06   A9  D4 001B3 	    CLRL    6(GBL_SAT_PTR)					      ; 2181
		         69	       56  B0 001B6 	    MOVW    GBL_NT_PTR, (GBL_SAT_PTR)				      ; 2182
		         01	       67  91 001B9 	    CMPB    (BEST_MATCH), #1					      ; 2188
				       0A  12 001BC 	    BNEQ    9$							      ;
	   50	         57	       09  C1 001BE 	    ADDL3   #9, BEST_MATCH, NAME_CS				      ; 2191
		         58	  C1   8F  9A 001C2 	    MOVZBL  #193, GLOBAL_TYPE					      ; 2192
				       08  11 001C6 	    BRB     10$							      ; 2188
	   50	         57	       0B  C1 001C8 9$:     ADDL3   #11, BEST_MATCH, NAME_CS				      ; 2196
		         58	  C0   8F  9A 001CC 	    MOVZBL  #192, GLOBAL_TYPE					      ; 2197
		         51	       60  9A 001D0 10$:    MOVZBL  (NAME_CS), R1					      ; 2199
				       51  D6 001D3 	    INCL    R1							      ;
		         56	       6A  C0 001D5 	    ADDL2   PAT$GL_RST_BEGN, R6					      ;
      0C   A6	         60	       51  28 001D8 	    MOVC3   R1, (NAME_CS), 12(R6)				      ;
		    02   A6	       58  90 001DD 	    MOVB    GLOBAL_TYPE, 2(R6)					      ; 2200
		    03   A6	       01  88 001E1 	    BISB2   #1, 3(R6)						      ; 2201
		    04   A6	  05   A7  D0 001E5 	    MOVL    5(BEST_MATCH), 4(R6)				      ; 2202
				       66  B4 001EA 	    CLRW    (R6)						      ; 2203
				  08   A6  B4 001EC 	    CLRW    8(R6)						      ; 2204
		         50	       59  D0 001EF 	    MOVL    GBL_SAT_PTR, R0					      ; 2205
					   04 001F2 	    RET     							      ;
				       50  D4 001F3 11$:    CLRL    R0							      ; 2020
					   04 001F5 	    RET     							      ;

; Routine Size:  181 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 7
; Digital Equipment Corporation
;
;	2207	GLOBAL ROUTINE PAT$SYM_TO_VAL( PATH_VEC_PTR, VALUE_PTR ) =
;	2208	
;	2209	!++
;	2210	! Functional Description:
;	2211	!
;	2212	!	Use the RST/GST data base to translate a given symbol pathname to its
;	2213	!	corresponding value.
;	2214	!
;	2215	!	This routine is quite similar PAT$SYM_TO_VALU, except that it is called
;	2216	!	when ONLY the value is required.  As this builds in less knowledge of
;	2217	!	the RST and its data structures, this routine should be called whenever
;	2218	!	possible.
;	2219	!
;	2220	! Formal Parameters:
;	2221	!
;	2222	!  PATH_VEC_PTR	-a pointer to the pathname vector from a PATCH command
;	2223	!
;	2224	!  VALUE_PTR	-The location to hold the returned address bound to the
;	2225	!		 symbol pathname.
;	2226	!
;	2227	! Implicit Inputs:
;	2228	!
;	2229	!	The value to be passed back is a longword.
;	2230	!
;	2231	! Implicit Outputs:
;	2232	!
;	2233	!	None.
;	2234	!
;	2235	! Return Value:
;	2236	!	
;	2237	!	TRUE, if symbol was located successfully.
;	2238	!	FALSE, otherwise.
;	2239	!
;	2240	! Side Effects:
;	2241	!
;	2242	!	The bound address is written into the return location.
;	2243	!
;	2244	!--
;	2245	
;	2246	BEGIN
;	2247	
;	2248	MAP
;	2249		PATH_VEC_PTR : REF PATHNAME_VECTOR,
;	2250		VALUE_PTR : REF VECTOR[,LONG];
;	2251	
;	2252	LOCAL
;	2253		STATUS,							! INDICATOR FOR NO SYMBOL (0), ADDR OF SYMBOL (1), ADDR OF ARRAY DESC (3)
;	2254		DSC_PTR : REF BLOCK[,BYTE],				! Array descriptor address
;	2255		VALU_DESC : VALU_DESCRIPTOR;				! Local value descriptor
;	2256	
;	2257	!++
;	2258	! PAT$SYM_TO_VALU does all the work of searching the symbol table.  It returns
;	2259	! either the address bound to the symbol (STATUS = 1), the address of a
;	2260	! descriptor for an array (STATUS = 3), or an indication that the symbol was not
;	2261	! found (STATUS = 0 OR 2).

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 7-1
; Digital Equipment Corporation
;
;	2262	!--
;	2263	IF (STATUS =  PAT$SYM_TO_VALU(.PATH_VEC_PTR, VALU_DESC))
;	2264	THEN
;	2265		BEGIN
;	2266		!++
;	2267		! Now determine if the value returned is the address bound to
;	2268		! the symbol or the address of an array descriptor.
;	2269		!--
;	2270		IF (.STATUS EQL 1)
;	2271		THEN
;	2272			VALUE_PTR[0] = .VALU_DESC[VALU_VALUE]
;	2273		ELSE
;	2274			BEGIN
;	2275			!++
;	2276			! This must be an array descriptor.  Return the address bound
;	2277			! to the symbol not the address of the descriptor.
;	2278			!--
;	2279			DSC_PTR = .VALU_DESC[VALU_VALUE];
;	2280			VALUE_PTR[0] = .DSC_PTR[DSC$A_POINTER];
;	2281			END;
;	2282		RETURN(TRUE);
;	2283		END
;	2284	ELSE
;	2285		!++
;	2286		! Failure. There is really nothing further we can do.
;	2287		!--
;	2288		RETURN(FALSE);
;	2289	END;





					 0000 001F6 	    .ENTRY  PAT$SYM_TO_VAL, Save nothing			      ; 2207
		         5E	       08  C2 001F8 	    SUBL2   #8, SP						      ;
				       5E  DD 001FB 	    PUSHL   SP							      ; 2263
				  04   AC  DD 001FD 	    PUSHL   PATH_VEC_PTR					      ;
	      00000000V  EF	       02  FB 00200 	    CALLS   #2, PAT$SYM_TO_VALU					      ;
		         19	       50  E9 00207 	    BLBC    STATUS, 3$						      ;
		         01	       50  D1 0020A 	    CMPL    STATUS, #1						      ; 2270
				       07  12 0020D 	    BNEQ    1$							      ;
		    08   BC	  02   AE  D0 0020F 	    MOVL    VALU_DESC+2, @VALUE_PTR				      ; 2272
				       09  11 00214 	    BRB     2$							      ; 2270
		         50	  02   AE  D0 00216 1$:     MOVL    VALU_DESC+2, DSC_PTR				      ; 2279
		    08   BC	  04   A0  D0 0021A 	    MOVL    4(DSC_PTR), @VALUE_PTR				      ; 2280
		         50	       01  D0 0021F 2$:     MOVL    #1, R0						      ; 2282
					   04 00222 	    RET     							      ;
				       50  D4 00223 3$:     CLRL    R0							      ; 2207
					   04 00225 	    RET     							      ;

; Routine Size:  48 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8
; Digital Equipment Corporation
;
;	2290	GLOBAL ROUTINE PAT$SYM_TO_VALU( PATH_VEC_PTR, VALUE_DESC_ADDR ) =
;	2291	
;	2292	!++
;	2293	! Functional Description:
;	2294	!
;	2295	!	Use the RST/GST data base to translate a given
;	2296	!	symbol pathname to its corresponding value.
;	2297	!	Build and return a so-called 'value descriptor'
;	2298	!	which corresponds to this found value.  It is
;	2299	!	within this routine that the notion of "search rules"
;	2300	!	is implemented.
;	2301	!
;	2302	! Formal Parameters:
;	2303	!
;	2304	!  PATH_VEC_PTR	-a pointer to the pathname vector which the user
;	2305	!		 input as the symbol name.  This can be a simple
;	2306	!		 "name", a compound "rout\rout1 ...\name",
;	2307	!		 or a fully-qualified "module\...\name".
;	2308	!
;	2309	!  VALUE_DESC_ADDR	-The address of a value descriptor which
;	2310	!			 we are to 'fill in' with the one which
;	2311	!			 corresponds to the value we find associated
;	2312	!			 with the given symbol.
;	2313	!
;	2314	! Implicit Inputs:
;	2315	!
;	2316	!	The value to be passed back is a longword, or at least,
;	2317	!	the current definition of VALU_DESCRIPTOR facilitates
;	2318	!	passing around the value we find.
;	2319	!
;	2320	!	The current state of the MODE data structure
;	2321	!	is used, along with the built-in relationship between the
;	2322	!	setting of these bits and the implied search rules, to
;	2323	!	pick out which is the correct match from the RST.
;	2324	!
;	2325	!
;	2326	! Implicit Outputs:
;	2327	!
;	2328	!	Whatever is implied by the current definition of VALU_DESCRIPTOR.
;	2329	!
;	2330	! Return Value:
;	2331	!	
;	2332	!	TRUE, if the symbol is found successfully and
;	2333	!		 the returned value is the address bound to the symbol,
;	2334	!	3, if the symbol is found successfully and
;	2335	!		 the returned value is the address of descriptor for an array,
;	2336	!	FALSE or 2, otherwise.
;	2337	!
;	2338	! Side Effects:
;	2339	!
;	2340	!	none.
;	2341	!--
;	2342	
;	2343	BEGIN
;	2344	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8-1
; Digital Equipment Corporation
;
;	2345	MAP
;	2346		PATH_VEC_PTR : REF PATHNAME_VECTOR,
;	2347		VALUE_DESC_ADDR : REF VALU_DESCRIPTOR;
;	2348	
;	2349	LOCAL
;	2350		TEMP_PATH_VEC : PATHNAME_VECTOR,			! We use a local pathname vector to concat-
;	2351									! enate various other partial pathname
;	2352									! vectors into.
;	2353		CHAIN_PTR : REF NT_RECORD,				! A pointer to the hash chain which contains
;	2354									! all occurrences of the symbol which ends
;	2355									! the pathname pointed to by PATH_VEC_PTR.
;	2356		NT_PTR : REF NT_RECORD;					! We extract each RST-pointer from the
;	2357									! hash chain and use the local NT_PTR
;	2358									! to contain the entry.
;	2359	
;	2360	LOCAL
;	2361		INDEX;							! Index of symbol in path vector.
;	2362	
;	2363	!++
;	2364	! See that the path vector has at least one entry, and that the RST has been initialized.
;	2365	!--
;	2366	IF .path_vec_ptr EQL 0
;	2367	THEN
;	2368		RETURN FALSE;
;	2369	IF (.PATH_VEC_PTR[0] EQL 0) OR (.PAT$GL_MC_PTR EQL 0)
;	2370	THEN
;	2371		RETURN(FALSE);
;	2372	
;	2373	!++
;	2374	! The symbol is the last entry in the given pathname. 
;	2375	! Pick up what index this is into the pathname vector.
;	2376	!--
;	2377	INDEX = 0;
;	2378	
;	2379	REPEAT
;	2380		BEGIN
;	2381		IF (.PATH_VEC_PTR[.INDEX+1] EQL 0)
;	2382		THEN
;	2383			EXITLOOP;					! INDEX points to the symbol name.
;	2384		IF ((INDEX = .INDEX +1) GEQ MAX_PATH_SIZE)
;	2385		THEN
;	2386			RETURN(FALSE);
;	2387		END;
;	2388	
;	2389	!++
;	2390	! Discover all occurrences of the given symbol in the RST data base.  If some
;	2391	! error occurs, we must give up.  This is because we consider not finding any
;	2392	! symbols an error.
;	2393	!--
;	2394	IF ((CHAIN_PTR = PAT$LOOKUP_SYM( .PATH_VEC_PTR[.INDEX] )) EQL 0)
;	2395	THEN
;	2396		RETURN(FALSE);						! We can find no such symbol.
;	2397	
;	2398	!++
;	2399	! First, before we bother with all the search rules, see if the symbol happens

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8-2
; Digital Equipment Corporation
;
;	2400	! to be unique.  To do this, setup to scan the duplication chain.  Grab the
;	2401	! first one, and  accept it as long as there is no second one, and as long as
;	2402	! we were given only a symbol name.
;	2403	!--
;	2404	IF (.INDEX EQL 0)
;	2405	THEN
;	2406		BEGIN
;	2407		!++
;	2408		! We have only a symbol name.  Check for uniqueness.
;	2409		!--
;	2410		PAT$GET_NXT_DUP( 1, .CHAIN_PTR );
;	2411	
;	2412		IF ((NT_PTR = PAT$GET_NXT_DUP(0)) EQL 0)
;	2413		THEN
;	2414			RETURN(FALSE);					! There is not even one.
;	2415	
;	2416		IF (PAT$GET_NXT_DUP(0) EQL 0)
;	2417		THEN
;	2418			BEGIN
;	2419			!++
;	2420			! The symbol is unique.  Return a corresponding
;	2421			! value descriptor and status code.
;	2422			!--
;	2423			VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
;	2424			RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
;	2425			END;
;	2426		END;
;	2427	
;	2428	!++
;	2429	! We have all the duplicates, and there are  more than 1 of them.  Now see
;	2430	! if one of them matches the given pathname.  Note that we have to apply each
;	2431	! search rule, in order, to ALL of the duplicates before we can go on to the next
;	2432	! search rule. (As opposed to applying all search rules to each consecutive 
;	2433	! secutive duplicate - which sounds tempting but doesn't work).
;	2434	!
;	2435	! If GLOBAL or DEFine symbols are acceptable first, we can just try to match
;	2436	! up the two pathnames  directly.
;	2437	!--
;	2438	IF (.PAT$GB_MOD_PTR[MODE_GLOBALS])
;	2439	THEN
;	2440		BEGIN
;	2441		!++
;	2442		! Set up to scan the hash chain, and loop along
;	2443		! it until we have considered all duplicates.
;	2444		!--
;	2445		PAT$GET_NXT_DUP( 1, .CHAIN_PTR);
;	2446		WHILE( (NT_PTR = PAT$GET_NXT_DUP(0)) NEQ 0 )
;	2447			DO
;	2448			BEGIN
;	2449			IF (PATH_MATCH( .PATH_VEC_PTR, .NT_PTR))
;	2450			THEN
;	2451				BEGIN
;	2452				!++
;	2453				! Return a value descriptor and status code.
;	2454				!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8-3
; Digital Equipment Corporation
;
;	2455				VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
;	2456				RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
;	2457				END;
;	2458	
;	2459			END;						! Loop back and try the next duplicate.
;	2460		END;							! It is not a GLOBAL.
;	2461	!++
;	2462	! Next, unless asked not to, we try qualifying the given pathname with the one
;	2463	! that corresponds to  the user-set current scope position (CSP) vector.
;	2464	! Note that we can't make this check if the CSP is null because this is
;	2465	! equivalent to allowing a GLOBAL to satisfy the match which we can't allow
;	2466	! at this point.
;	2467	!--
;	2468	IF (.PAT$GB_MOD_PTR[MODE_SCOPE] AND .PAT$GL_CSP_PTR NEQ 0)
;	2469	THEN
;	2470		BEGIN
;	2471		!++
;	2472		! Set up to scan the hash chain, and loop along
;	2473		! it until we have considered all duplicates.
;	2474		!--
;	2475		PAT$GET_NXT_DUP( 1, .CHAIN_PTR);
;	2476		WHILE( (NT_PTR = PAT$GET_NXT_DUP(0)) NEQ 0 )
;	2477			DO
;	2478			BEGIN
;	2479			!++
;	2480			! First, build the new pathname by perpending the CSP.
;	2481			!--
;	2482			CONCAT_PATHS( TEMP_PATH_VEC, .PAT$GL_CSP_PTR, .PATH_VEC_PTR );
;	2483			IF (PATH_MATCH( TEMP_PATH_VEC, .NT_PTR))
;	2484			THEN
;	2485				BEGIN
;	2486				!++
;	2487				! Return a value descriptor and status code.
;	2488				!--
;	2489				VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
;	2490				RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
;	2491				END;
;	2492	
;	2493			END;						! Go back and try the next duplicate.
;	2494		END;							! You can't find it via CSP.
;	2495	
;	2496	!++
;	2497	! Next, if we haven't already considered globals, now's the time.
;	2498	!--
;	2499	IF (NOT .PAT$GB_MOD_PTR[MODE_GLOBALS])
;	2500	THEN
;	2501		BEGIN
;	2502		!++
;	2503		! Set up to scan the hash chain, and loop along it until we have
;	2504		! considered all duplicates.
;	2505		!--
;	2506		PAT$GET_NXT_DUP( 1, .CHAIN_PTR);
;	2507		WHILE( (NT_PTR = PAT$GET_NXT_DUP(0)) NEQ 0 )
;	2508			DO
;	2509			BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8-4
; Digital Equipment Corporation
;
;	2510			IF (PATH_MATCH( .PATH_VEC_PTR, .NT_PTR))
;	2511			THEN
;	2512				BEGIN
;	2513				!++
;	2514				! Return a value descriptor and status code.
;	2515				!--
;	2516				VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
;	2517				RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
;	2518				END;
;	2519			END;						! Go back and try the next duplicate.
;	2520		END;							! It is not a GLOBAL.
;	2521	!++
;	2522	! We applied all the search rules to all the duplicates and none was the one
;	2523	! we were looking for.
;	2524	!--
;	2525	RETURN(FALSE);
;	2526	END;





					 0F1C 00226 	    .ENTRY  PAT$SYM_TO_VALU, Save R2,R3,R4,R8,R9,R10,R11	      ; 2290
		         58 00000000G  EF  9E 00228 	    MOVAB   PAT$GL_CSP_PTR, R8					      ;
		         59 00000000V  EF  9E 0022F 	    MOVAB   PATH_MATCH, R9					      ;
		         5A 00000000G  EF  9E 00236 	    MOVAB   PAT$GB_MOD_PTR, R10					      ;
		         5B 00000000V  EF  9E 0023D 	    MOVAB   PAT$GET_NXT_DUP, R11				      ;
		         5E	       2C  C2 00244 	    SUBL2   #44, SP						      ;
		         53	  04   AC  D0 00247 	    MOVL    PATH_VEC_PTR, R3					      ; 2366
				       1B  13 0024B 	    BEQL    2$							      ;
				       63  D5 0024D 	    TSTL    (R3)						      ; 2369
				       17  13 0024F 	    BEQL    2$							      ;
			    00000000G  EF  D5 00251 	    TSTL    PAT$GL_MC_PTR					      ;
				       0F  13 00257 	    BEQL    2$							      ;
				       52  D4 00259 	    CLRL    INDEX						      ; 2377
				  04 A342  D5 0025B 1$:     TSTL    4(R3)[INDEX]					      ; 2381
				       0A  13 0025F 	    BEQL    3$							      ;
				       52  D6 00261 	    INCL    INDEX						      ; 2384
		         0A	       52  D1 00263 	    CMPL    INDEX, #10						      ;
				       F3  19 00266 	    BLSS    1$							      ;
				     00BB  31 00268 2$:     BRW     11$							      ; 2386
				     6342  DD 0026B 3$:     PUSHL   (R3)[INDEX]						      ; 2394
		  FDC6   CF	       01  FB 0026E 	    CALLS   #1, PAT$LOOKUP_SYM					      ;
		         54	       50  D0 00273 	    MOVL    R0, CHAIN_PTR					      ;
				       F0  13 00276 	    BEQL    2$							      ;
				       52  D5 00278 	    TSTL    INDEX						      ; 2404
				       1A  12 0027A 	    BNEQ    4$							      ;
				       54  DD 0027C 	    PUSHL   CHAIN_PTR						      ; 2410
				       01  DD 0027E 	    PUSHL   #1							      ;
		         6B	       02  FB 00280 	    CALLS   #2, PAT$GET_NXT_DUP					      ;
				       7E  D4 00283 	    CLRL    -(SP)						      ; 2412
		         6B	       01  FB 00285 	    CALLS   #1, PAT$GET_NXT_DUP					      ;
		         52	       50  D0 00288 	    MOVL    R0, NT_PTR						      ;
				       DB  13 0028B 	    BEQL    2$							      ;
				       7E  D4 0028D 	    CLRL    -(SP)						      ; 2416

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8-5
; Digital Equipment Corporation
;
		         6B	       01  FB 0028F 	    CALLS   #1, PAT$GET_NXT_DUP					      ;
				       50  D5 00292 	    TSTL    R0							      ;
				       7D  13 00294 	    BEQL    10$							      ;
		         50	       6A  D0 00296 4$:     MOVL    PAT$GB_MOD_PTR, R0					      ; 2438
		         1D	  06   A0  E9 00299 	    BLBC    6(R0), 6$						      ;
				       54  DD 0029D 	    PUSHL   CHAIN_PTR						      ; 2445
				       01  DD 0029F 	    PUSHL   #1							      ;
		         6B	       02  FB 002A1 	    CALLS   #2, PAT$GET_NXT_DUP					      ;
				       7E  D4 002A4 5$:     CLRL    -(SP)						      ; 2446
		         6B	       01  FB 002A6 	    CALLS   #1, PAT$GET_NXT_DUP					      ;
		         52	       50  D0 002A9 	    MOVL    R0, NT_PTR						      ;
				       0C  13 002AC 	    BEQL    6$							      ;
				       52  DD 002AE 	    PUSHL   NT_PTR						      ; 2449
				       53  DD 002B0 	    PUSHL   R3							      ;
		         69	       02  FB 002B2 	    CALLS   #2, PATH_MATCH					      ;
		         EC	       50  E9 002B5 	    BLBC    R0, 5$						      ;
				       59  11 002B8 	    BRB     10$							      ; 2455
		         50	       6A  D0 002BA 6$:     MOVL    PAT$GB_MOD_PTR, R0					      ; 2468
		         30	  05   A0  E9 002BD 	    BLBC    5(R0), 8$						      ;
				       68  D5 002C1 	    TSTL    PAT$GL_CSP_PTR					      ;
				       2C  13 002C3 	    BEQL    8$							      ;
				       54  DD 002C5 	    PUSHL   CHAIN_PTR						      ; 2475
				       01  DD 002C7 	    PUSHL   #1							      ;
		         6B	       02  FB 002C9 	    CALLS   #2, PAT$GET_NXT_DUP					      ;
				       7E  D4 002CC 7$:     CLRL    -(SP)						      ; 2476
		         6B	       01  FB 002CE 	    CALLS   #1, PAT$GET_NXT_DUP					      ;
		         52	       50  D0 002D1 	    MOVL    R0, NT_PTR						      ;
				       1B  13 002D4 	    BEQL    8$							      ;
				       53  DD 002D6 	    PUSHL   R3							      ; 2482
				       68  DD 002D8 	    PUSHL   PAT$GL_CSP_PTR					      ;
				  08   AE  9F 002DA 	    PUSHAB  TEMP_PATH_VEC					      ;
	      00000000V  EF	       03  FB 002DD 	    CALLS   #3, CONCAT_PATHS					      ;
				       52  DD 002E4 	    PUSHL   NT_PTR						      ; 2483
				  04   AE  9F 002E6 	    PUSHAB  TEMP_PATH_VEC					      ;
		         69	       02  FB 002E9 	    CALLS   #2, PATH_MATCH					      ;
		         DD	       50  E9 002EC 	    BLBC    R0, 7$						      ;
				       22  11 002EF 	    BRB     10$							      ; 2489
		         50	       6A  D0 002F1 8$:     MOVL    PAT$GB_MOD_PTR, R0					      ; 2499
		         2E	  06   A0  E8 002F4 	    BLBS    6(R0), 11$						      ;
				       54  DD 002F8 	    PUSHL   CHAIN_PTR						      ; 2506
				       01  DD 002FA 	    PUSHL   #1							      ;
		         6B	       02  FB 002FC 	    CALLS   #2, PAT$GET_NXT_DUP					      ;
				       7E  D4 002FF 9$:     CLRL    -(SP)						      ; 2507
		         6B	       01  FB 00301 	    CALLS   #1, PAT$GET_NXT_DUP					      ;
		         52	       50  D0 00304 	    MOVL    R0, NT_PTR						      ;
				       1D  13 00307 	    BEQL    11$							      ;
				       52  DD 00309 	    PUSHL   NT_PTR						      ; 2510
				       53  DD 0030B 	    PUSHL   R3							      ;
		         69	       02  FB 0030D 	    CALLS   #2, PATH_MATCH					      ;
		         EC	       50  E9 00310 	    BLBC    R0, 9$						      ;
		    08   BC	       52  B0 00313 10$:    MOVW    NT_PTR, @VALUE_DESC_ADDR				      ; 2516
	   7E	    08   AC	       02  C1 00317 	    ADDL3   #2, VALUE_DESC_ADDR, -(SP)				      ; 2517
				       52  DD 0031C 	    PUSHL   NT_PTR						      ;
	      00000000V  EF	       02  FB 0031E 	    CALLS   #2, PAT$SYMBOL_VALU					      ;
					   04 00325 	    RET     							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 8-6
; Digital Equipment Corporation
;
				       50  D4 00326 11$:    CLRL    R0							      ; 2290
					   04 00328 	    RET     							      ;

; Routine Size:  259 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 9
; Digital Equipment Corporation
;
;	2527	GLOBAL ROUTINE PAT$GET_NXT_DUP( INIT_FLAG, NEW_CHAIN ) =
;	2528	
;	2529	!++
;	2530	! Functional Description:
;	2531	!
;	2532	!	Facilitate going along hash chains (or whatever
;	2533	!	it is that symbol duplicates are stored in) when we only
;	2534	!	want to look at symbols which match a given symbol.
;	2535	!
;	2536	! Formal Parameters:
;	2537	!
;	2538	!	INIT_FLAG	0 => we are in the middle of a chain so
;	2539	!			 pass back the next NT and ignore NEW_CHAIN.
;	2540	!			 (so that we don't have to always pass 2 parameters)
;	2541	!			1 => this is a real init.  NEW_CHAIN marks the 
;	2542	!			 beginning of the new chain we want to look at.
;	2543	!			-The returned value is undefined for INIT_FLAG==1
;	2544	!			 type calls.  NEW_CHAIN is not defined, otherwise.
;	2545	!	NEW_CHAIN	-a pointer to a chain of forward-linked
;	2546	!			 NT records which all hash to the same value.
;	2547	!			 When an init is done, (INIT_FLAG == 1), the
;	2548	!			 first element on the new chain
;	2549	!			 is assumed to be the one that we henceforth
;	2550	!			 want to 'key' off.
;	2551	!
;	2552	! Implicit Inputs:
;	2553	!
;	2554	!	-The way that one 'chains' along hash chains.
;	2555	!
;	2556	!	-The first element in the chain when INIT==1 is the
;	2557	!	 'key' element for that chain.  The symbol name therein
;	2558	!	 defines what subsequent elements on the chain
;	2559	!	 may be returned by PAT$GET_NXT_DUP(0) calls.
;	2560	!
;	2561	! Implicit Outputs:
;	2562	!	none.
;	2563	!
;	2564	! Return Value:
;	2565	!
;	2566	!	0 - when there are no more NTs on the chain,
;	2567	!	an NT_PTR to the next one, otherwise.
;	2568	!
;	2569	! Side effects:
;	2570	!
;	2571	!	OWN storage for IN_CHAIN and BEGIN_CHAIN get altered.
;	2572	!--
;	2573	
;	2574	BEGIN
;	2575	
;	2576	OWN
;	2577		IN_CHAIN : REF NT_RECORD,				! Keep a static pointer to where we are in
;	2578									! the current hash chain.
;	2579		BEGIN_CHAIN    : REF NT_RECORD;				! If we are somewhere valid in the current
;	2580									! chain, then we also need a static pointer to 
;	2581									! what was the first element on this chain as

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 9-1
; Digital Equipment Corporation
;
;	2582									! this is the one we get the chain symbol name from.
;	2583	
;	2584	!++
;	2585	! See if this call marks the beginning of a new hash chain.
;	2586	!--
;	2587	IF (.INIT_FLAG)
;	2588	THEN
;	2589		BEGIN
;	2590		!++
;	2591		! Set up to be looking at a new chain.
;	2592		!--
;	2593		BEGIN_CHAIN = .NEW_CHAIN;
;	2594		IN_CHAIN = .NEW_CHAIN;
;	2595	
;	2596		!++
;	2597		! We don't define any return value for this type of call.
;	2598		!--
;	2599		RETURN;
;	2600		END;
;	2601	
;	2602	!++
;	2603	! Skip along the chain until the next NT record of interest is found.  We may
;	2604	! already be at the end because of previous calls.
;	2605	!--
;	2606	IF (.IN_CHAIN EQL 0)
;	2607	THEN
;	2608		RETURN(0);
;	2609	
;	2610	!++
;	2611	! Otherwise scan the chain.
;	2612	!--
;	2613	DO
;	2614		BEGIN
;	2615		!++
;	2616		! Simply check that the symbol names match.
;	2617		!--
;	2618		IF (CH$EQL( .IN_CHAIN[NT_NAME_CS], IN_CHAIN[NT_NAME_ADDR],
;	2619		   .BEGIN_CHAIN[NT_NAME_CS], BEGIN_CHAIN[NT_NAME_ADDR])
;	2620		  )
;	2621		THEN
;	2622			BEGIN
;	2623			LOCAL
;	2624				MATCH_NT : REF NT_RECORD;
;	2625	
;	2626			MATCH_NT = .IN_CHAIN;
;	2627			IN_CHAIN = .IN_CHAIN[NT_FORWARD];
;	2628			RETURN(.MATCH_NT);
;	2629			END;
;	2630		END
;	2631	
;	2632	WHILE( (IN_CHAIN = .IN_CHAIN[NT_FORWARD]) NEQ 0 );
;	2633	!++
;	2634	! There are no more in the chain to consider.
;	2635	!--
;	2636	RETURN(0);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 9-2
; Digital Equipment Corporation
;
;	2637	END;



							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 IN_CHAIN:
							    .BLKB   4
					      00004 BEGIN_CHAIN:
							    .BLKB   4



							    .PSECT  _PAT$CODE,NOWRT,2

					 087C 00329 	    .ENTRY  PAT$GET_NXT_DUP, Save R2,R3,R4,R5,R6,R11		      ; 2527
		         5B 00000000'  EF  9E 0032B 	    MOVAB   IN_CHAIN, R11					      ;
		         0B	  04   AC  E9 00332 	    BLBC    INIT_FLAG, 1$					      ; 2587
		    04   AB	  08   AC  D0 00336 	    MOVL    NEW_CHAIN, BEGIN_CHAIN				      ; 2593
		         6B	  08   AC  D0 0033B 	    MOVL    NEW_CHAIN, IN_CHAIN					      ; 2594
				       36  11 0033F 	    BRB     4$							      ; 2599
				       6B  D5 00341 1$:     TSTL    IN_CHAIN						      ; 2606
				       32  13 00343 	    BEQL    4$							      ;
		         56 00000000G  EF  D0 00345 	    MOVL    PAT$GL_RST_BEGN, R6					      ; 2618
	   55	    04   AB	       56  C1 0034C 	    ADDL3   R6, BEGIN_CHAIN, R5					      ; 2619
	   54	         6B	       56  C1 00351 2$:     ADDL3   R6, IN_CHAIN, R4					      ; 2618
		         51	  0C   A4  9A 00355 	    MOVZBL  12(R4), R1						      ;
		         50	  0C   A5  9A 00359 	    MOVZBL  12(R5), R0						      ; 2619
	   00	    0D   A4	       51  2D 0035D 	    CMPC5   R1, 13(R4), #0, R0, 13(R5)				      ; 2618
		    0D   A5	       50     00362									      ;
				       07  12 00365 	    BNEQ    3$							      ;
		         50	       6B  D0 00367 	    MOVL    IN_CHAIN, MATCH_NT					      ; 2626
		         6B	       64  3C 0036A 	    MOVZWL  (R4), IN_CHAIN					      ; 2627
					   04 0036D 	    RET     							      ; 2628
	   50	         6B	       56  C1 0036E 3$:     ADDL3   R6, IN_CHAIN, R0					      ; 2632
		         6B	       60  3C 00372 	    MOVZWL  (R0), IN_CHAIN					      ;
				       DA  12 00375 	    BNEQ    2$							      ;
				       50  D4 00377 4$:     CLRL    R0							      ; 2527
					   04 00379 	    RET     							      ;

; Routine Size:  81 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 10
; Digital Equipment Corporation
;
;	2638	ROUTINE CONCAT_PATHS( DESTINATION, PV_1, PV_2 ) : NOVALUE =
;	2639	
;	2640	!++
;	2641	! Functional Description:
;	2642	!
;	2643	!	Concatenate two PATHNAME_VECTORS together and place
;	2644	!	the resultant vector in the indicated location.
;	2645	!	If the PV_1 vector is the same as the DESTINATION
;	2646	!	vector, then this routine is equivalent to routine
;	2647	!	which just 'tacks' one vector onto the end of another.
;	2648	!
;	2649	! Formal Parameters:
;	2650	!
;	2651	!  DESTINATION		-a pointer to where the concatenation
;	2652	!			 of the PV_1 and PV_2 vectors should be
;	2653	!			 be stored.
;	2654	!  PV_1			-a pointer to the first source vector.  If PV_1[0]
;	2655	!			 is 0, the PV_1 vector is considered empty.
;	2656	!  PV_2			-a pointer to the second source vector.  If PV_2[0]
;	2657	!			 is 0, the PV_2 vector is considered empty.
;	2658	!
;	2659	! Implicit Inputs:
;	2660	!
;	2661	!	None, other than the assumptions made about PATHNAME_VECTORS,
;	2662	!	namely their characteristics, given via the 'canned' declaration,
;	2663	!	and the fact that they must end with a 0 entry.
;	2664	!
;	2665	! Implicit Outputs:
;	2666	!
;	2667	!	None.
;	2668	!
;	2669	! Routine Value:
;	2670	!
;	2671	!	NOVALUE
;	2672	!
;	2673	! Side Effects:
;	2674	!
;	2675	!	The two vectors are concatenated.
;	2676	!--
;	2677	
;	2678	BEGIN
;	2679	
;	2680	MAP
;	2681		DESTINATION : REF PATHNAME_VECTOR,			! All three input parameters are pointers to
;	2682									! pathname vectors.
;	2683		PV_1	    : REF PATHNAME_VECTOR,
;	2684		PV_2	    : REF PATHNAME_VECTOR;
;	2685	
;	2686	LOCAL
;	2687		I_2,							! Index used for PV_2 vector.
;	2688		INDEX;							! Used to index thru the destination vector.
;	2689	
;	2690	!++
;	2691	! Initialize an index into the destination and source pathname vectors.
;	2692	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 10-1
; Digital Equipment Corporation
;
;	2693	INDEX = 0;
;	2694	I_2 = 0;
;	2695	
;	2696	!++
;	2697	! If we were actually given the first vector, copy each element from it into
;	2698	! the destination vector.  We do not consider a 0-pointer vector to be an error;
;	2699	! it just means that that vector doesn't contribute anything to the result.
;	2700	!--
;	2701	IF (PV_1[0] NEQ 0)
;	2702	THEN
;	2703		!++
;	2704		! Copy each element, making sure not to overflow.
;	2705		!--
;	2706		WHILE( .INDEX LSS MAX_PATH_SIZE )
;	2707			DO
;	2708			IF ((DESTINATION[.INDEX] = .PV_1[.INDEX]) EQL 0)
;	2709			THEN
;	2710				!++
;	2711				! The first 0 element => the end.
;	2712				!--
;	2713				EXITLOOP
;	2714			ELSE
;	2715				INDEX = .INDEX + 1;
;	2716	!++
;	2717	! Then add on the second vector, again making sure that we were actually given
;	2718	! something.  Note that we don't have to check overflow of the PV_2 vector
;	2719	! because no matter how long it is, we will overflow the destination vector
;	2720	! before we overflow it.
;	2721	!--
;	2722	IF (PV_2[0] NEQ 0)
;	2723	THEN
;	2724		WHILE( .INDEX LSS MAX_PATH_SIZE )
;	2725			DO
;	2726			IF ((DESTINATION[.INDEX] = .PV_2[.I_2]) EQL 0)
;	2727			THEN
;	2728				!++
;	2729				! This is the only correct way to return from this routine.
;	2730				!--
;	2731				RETURN
;	2732			ELSE
;	2733				BEGIN
;	2734				I_2 = .I_2 +1;
;	2735				INDEX = .INDEX +1;
;	2736				END;
;	2737	
;	2738	!++
;	2739	! If we don't return in the above loop, then it is because we were about
;	2740	! to overflow the destination vector.  We take care of this by effectively wiping
;	2741	! out the vector we have built.
;	2742	!--
;	2743	DESTINATION[0] = 0;
;	2744	RETURN;
;	2745	END;



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 10-2
; Digital Equipment Corporation
;



					 0000 0037A CONCAT_PATHS:
							    .WORD   Save nothing					      ; 2638
				       50  7C 0037C 	    CLRQ    INDEX						      ; 2693
				  08   AC  D5 0037E 	    TSTL    PV_1						      ; 2701
				       12  13 00381 	    BEQL    2$							      ;
		         0A	       50  D1 00383 1$:     CMPL    INDEX, #10						      ; 2706
				       0D  18 00386 	    BGEQ    2$							      ;
		    04 BC40	  08 BC40  D0 00388 	    MOVL    @PV_1[INDEX], @DESTINATION[INDEX]			      ; 2708
				       04  13 0038F 	    BEQL    2$							      ;
				       50  D6 00391 	    INCL    INDEX						      ; 2715
				       EE  11 00393 	    BRB     1$							      ; 2706
				  0C   AC  D5 00395 2$:     TSTL    PV_2						      ; 2722
				       14  13 00398 	    BEQL    4$							      ;
		         0A	       50  D1 0039A 3$:     CMPL    INDEX, #10						      ; 2724
				       0F  18 0039D 	    BGEQ    4$							      ;
		    04 BC40	  0C BC41  D0 0039F 	    MOVL    @PV_2[I_2], @DESTINATION[INDEX]			      ; 2726
				       09  13 003A6 	    BEQL    5$							      ;
				       51  D6 003A8 	    INCL    I_2							      ; 2734
				       50  D6 003AA 	    INCL    INDEX						      ; 2735
				       EC  11 003AC 	    BRB     3$							      ; 2724
				  04   BC  D4 003AE 4$:     CLRL    @DESTINATION					      ; 2743
					   04 003B1 5$:     RET     							      ; 2638

; Routine Size:  56 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 11
; Digital Equipment Corporation
;
;	2746	GLOBAL ROUTINE PAT$NT_HASH_FCN( NAME_CS ) =
;	2747	
;	2748	!++
;	2749	! Functional Description:
;	2750	!
;	2751	!	Calculate what we call the 'hash' code associated
;	2752	!	with a given symbol name (counted string).
;	2753	!	This function localizes the dispersal that we
;	2754	!	use to distribute symbol NT-records into so-called
;	2755	!	NT-chains.  Currently this works by simply adding
;	2756	!	up the characters which make up the symbol name,
;	2757	!	adding in the count as well, and then truncating
;	2758	!	the resultant value to one byte so that we can
;	2759	!	then use this byte to index into the NT Hash Vector
;	2760	!	that then gives us the pointer to the NT chain for
;	2761	!	all symbols that 'hash' to this same byte index.
;	2762	!
;	2763	! Formal Parameters:
;	2764	!
;	2765	!	NAME_CS	-the address of a counted string that
;	2766	!		 is the symbol name we are to 'hash'.
;	2767	!
;	2768	! Implicit Inputs:
;	2769	!
;	2770	!	The hash index is supposed to be 1 byte long.
;	2771	!	(See the literal, NT_HASH_SIZE).
;	2772	!
;	2773	! Implicit Outputs:
;	2774	!
;	2775	!	None.
;	2776	!
;	2777	! Routine Value:
;	2778	!
;	2779	!	The 1-byte hash index, guaranteed not to exceed
;	2780	!	the range you can reach with an unsigned byte.
;	2781	!
;	2782	! Side Effects:
;	2783	!
;	2784	!	None.
;	2785	!--
;	2786	
;	2787	BEGIN
;	2788	
;	2789	MAP
;	2790		NAME_CS : CS_POINTER;
;	2791	
;	2792	LOCAL
;	2793		TALLY;
;	2794	
;	2795	!++
;	2796	! We simply add up the characters in the supposed name, including the count.
;	2797	!--
;	2798	DECR I FROM (TALLY = .NAME_CS[0]) TO 1
;	2799		DO
;	2800		TALLY = .TALLY + .NAME_CS[.I];

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 11-1
; Digital Equipment Corporation
;
;	2801		!++
;	2802	! The hash value is later used as a byte index into the NT hash table.
;	2803	!--
;	2804	RETURN( .TALLY<0,8,0> );
;	2805	END;





					 0004 003B2 	    .ENTRY  PAT$NT_HASH_FCN, Save R2				      ; 2746
		         51	  04   BC  9A 003B4 	    MOVZBL  @NAME_CS, TALLY					      ; 2798
	   50	         51	       01  C1 003B8 	    ADDL3   #1, TALLY, I					      ;
				       08  11 003BC 	    BRB     2$							      ;
		         52	  04 BC40  9A 003BE 1$:     MOVZBL  @NAME_CS[I], R2					      ; 2800
		         51	       52  C0 003C3 	    ADDL2   R2, TALLY						      ;
		         F5	       50  F5 003C6 2$:     SOBGTR  I, 1$						      ; 2798
		         50	       51  9A 003C9 	    MOVZBL  TALLY, R0						      ; 2804
					   04 003CC 	    RET     							      ; 2746

; Routine Size:  27 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 12
; Digital Equipment Corporation
;
;	2806	ROUTINE PATH_MATCH( PATH_VEC_PTR, NT_PTR ) =
;	2807	
;	2808	!++
;	2809	! Functional Description:
;	2810	!
;	2811	!	See if the NT record we are passed a pointer to
;	2812	!	has the same implicit path name as the one 
;	2813	!	specified in the PATHNAME_VECTOR we are also
;	2814	!	passed a pointer to.
;	2815	!
;	2816	! Formal Parameters:
;	2817	!
;	2818	!  PATH_VEC_PTR		-A pointer to the pathname vector which holds
;	2819	!			 the path name of the symbol we are to match
;	2820	!			 with the one implied by the NT scope chain.
;	2821	!  NT_PTR		-A pointer to the NT record which begins a so-called
;	2822	!			 scope chain.  
;	2823	!
;	2824	! Implicit Inputs:
;	2825	!
;	2826	!	-Pathname vectors end with a 0 element; NT scope chains
;	2827	!	 end when PAT$ADD_NT_T_PV says they do.
;	2828	!	-If the 'top' NT entry in an NT chain IS_GLOBAL,
;	2829	!	 then we assume that a pathname consisting only
;	2830	!	 of that global name is sufficient to 'match' the
;	2831	!	 implicit NT pathname.  This means that PATH_MATCH
;	2832	!	 had better not be called with the user-given pathname
;	2833	!	 (ie nothing has been perpended to it) unless
;	2834	!	 a global answer is acceptable.
;	2835	!
;	2836	! Implicit Outputs:
;	2837	!
;	2838	!	None.
;	2839	!
;	2840	! Return Value:
;	2841	!	
;	2842	!	TRUE, if the paths match,
;	2843	!	FALSE, otherwise.
;	2844	!
;	2845	! Side Effects:
;	2846	!
;	2847	!	None.
;	2848	!--
;	2849	
;	2850	BEGIN
;	2851	
;	2852	MAP
;	2853		PATH_VEC_PTR : REF PATHNAME_VECTOR,
;	2854		NT_PTR : REF NT_RECORD;
;	2855	
;	2856	LOCAL
;	2857		CS_SRC : CS_POINTER,
;	2858		CS_DST : CS_POINTER,
;	2859		PATH_VEC : PATHNAME_VECTOR;
;	2860	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 12-1
; Digital Equipment Corporation
;
;	2861	!++
;	2862	! Since we want to compare to pathnames which  have a radically different data
;	2863	! structure representation, the simplest thing to do is to convert one of the
;	2864	! two different things into the same kind of thing as the other is.  Then
;	2865	! comparing them is easy. In our case it is easiest to build a real 
;	2866	! PATHNAME_VECTOR to correspond to the one implied by the NT scope chain.
;	2867	!--
;	2868	PAT$ADD_NT_T_PV( .NT_PTR, PATH_VEC );
;	2869	
;	2870	!++
;	2871	! Now just look thru the two vectors making sure that the CS pointers therein
;	2872	! point to identical strings.  Note that we do the comparison up to and
;	2873	! including the symbol name which ends the path, since although we know these
;	2874	! symbols hash to the same value we don't know that they are identical.
;	2875	! Also note that even if we go thru the following loop mathing OK up to and
;	2876	! including the MAX_PATH_SIZE'th time, this is still NOT a valid match since
;	2877	! we must get a 0 entry to end the pathvectors properly.  This is why we say
;	2878	! that falling out of this loop implies failure.
;	2879	!--
;	2880	INCR I FROM 0 TO MAX_PATH_SIZE
;	2881		DO
;	2882		BEGIN
;	2883		!++
;	2884		! Extract the CS pointers from the pathname vectors and make sure
;	2885		! that one of them is not 0 unless the other one is.  If the two paths
;	2886		! are to match,  they must end at the same time, otherwise the paths
;	2887		! do not match because one is longer than the other.
;	2888		!--
;	2889		CS_SRC = .PATH_VEC_PTR[.I]; 
;	2890		CS_DST = .PATH_VEC[.I];
;	2891		IF (.CS_SRC EQL 0) AND (.CS_DST EQL 0)
;	2892		THEN
;	2893			RETURN(TRUE);					! This is one of two places that a match can be detected.
;	2894	
;	2895		IF (.CS_SRC EQL 0) OR (.CS_DST EQL 0)
;	2896		THEN
;	2897			EXITLOOP;					! The pathnames don't match because
;	2898									! one of them is too short.
;	2899	
;	2900		!++
;	2901		! Now it is safe to actually compare the element strings.
;	2902		!--
;	2903		IF (NOT CH$EQL( .CS_SRC[0], CS_SRC[1], .CS_DST[0], CS_DST[1]))
;	2904		THEN
;	2905			EXITLOOP;					! Mismatch because two elements are not the same.
;	2906			END;						! Corresponding pathname elements match.  Go back
;	2907									! and check successive elements.
;	2908	
;	2909	!++
;	2910	! If we fall out of the above loop, then the pathnames did not match.
;	2911	! As well as a straightforward pathvector match, we must also implement a 
;	2912	! special match for when the user asks for a global symbol which happens
;	2913	! to be a global from a module we have locals for.  The reason for the special
;	2914	! case here is because (only) this type of global has a real pathname -
;	2915	! namely "mod\glob_name".  While we support the user giving such names, we must

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 12-2
; Digital Equipment Corporation
;
;	2916	! also allow him to say simply "glob_name" as well.  To check this, first see
;	2917	! that the two symbol names are identical.  Then make sure that this is all
;	2918	! of the user-given pathname, and that the corresponding NT record _IS_GLOBAL
;	2919	! and is not MODULE.
;	2920	!--
;	2921	CS_SRC = .PATH_VEC_PTR[0]; 
;	2922	IF (NOT CH$EQL( .CS_SRC[0], CS_SRC[1], .NT_PTR[NT_NAME_CS], NT_PTR[NT_NAME_ADDR]))
;	2923	THEN
;	2924		BEGIN
;	2925	
;	2926		RETURN(FALSE);						! Mismatch because two elements are not the same.
;	2927		END;
;	2928	
;	2929	IF (.PATH_VEC_PTR[1] EQL 0 AND .NT_PTR[NT_IS_GLOBAL]) 
;	2930	THEN
;	2931		!++
;	2932		! Don't get fooled by the MC_IS_GLOBAL MC record. No module names have
;	2933		! values, so can never be PATH_MATCHed.
;	2934		!--
;	2935		IF (.NT_PTR[NT_TYPE] NEQ DSC$K_DTYPE_MOD)
;	2936		THEN
;	2937			BEGIN
;	2938	
;	2939				RETURN(TRUE);				! This is the second of 2 places were a match can be detected.
;	2940			END;
;	2941	
;	2942	RETURN(FALSE);							! The two pathnames do not match.
;	2943	END;





					 00FC 003CD PATH_MATCH:
							    .WORD   Save R2,R3,R4,R5,R6,R7				      ; 2806
		         5E	       2C  C2 003CF 	    SUBL2   #44, SP						      ;
				       5E  DD 003D2 	    PUSHL   SP							      ; 2868
				  08   AC  DD 003D4 	    PUSHL   NT_PTR						      ;
		  FC24   CF	       02  FB 003D7 	    CALLS   #2, PAT$ADD_NT_T_PV					      ;
		         57	  04   AC  D0 003DC 	    MOVL    PATH_VEC_PTR, R7					      ; 2889
				       54  D4 003E0 	    CLRL    I							      ; 2880
		         56	     6744  D0 003E2 1$:     MOVL    (R7)[I], CS_SRC					      ; 2889
		         55	     6E44  D0 003E6 	    MOVL    PATH_VEC[I], CS_DST					      ; 2890
				       50  D4 003EA 	    CLRL    R0							      ; 2891
				       56  D5 003EC 	    TSTL    CS_SRC						      ;
				       06  12 003EE 	    BNEQ    2$							      ;
				       50  D6 003F0 	    INCL    R0							      ;
				       55  D5 003F2 	    TSTL    CS_DST						      ;
				       48  13 003F4 	    BEQL    4$							      ;
		         18	       50  E8 003F6 2$:     BLBS    R0, 3$						      ; 2895
				       55  D5 003F9 	    TSTL    CS_DST						      ;
				       14  13 003FB 	    BEQL    3$							      ;
		         51	       66  9A 003FD 	    MOVZBL  (CS_SRC), R1					      ; 2903
		         50	       65  9A 00400 	    MOVZBL  (CS_DST), R0					      ;
	   00	    01   A6	       51  2D 00403 	    CMPC5   R1, 1(CS_SRC), #0, R0, 1(CS_DST)			      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 12-3
; Digital Equipment Corporation
;
		    01   A5	       50     00408									      ;
				       04  12 0040B 	    BNEQ    3$							      ;
	   D1	         54	       0A  F3 0040D 	    AOBLEQ  #10, I, 1$						      ; 2880
		         56	       67  D0 00411 3$:     MOVL    (R7), CS_SRC					      ; 2921
		         51	       66  9A 00414 	    MOVZBL  (CS_SRC), R1					      ; 2922
	   54	    08   AC 00000000G  EF  C1 00417 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R4				      ;
		         50	  0C   A4  9A 00420 	    MOVZBL  12(R4), R0						      ;
	   00	    01   A6	       51  2D 00424 	    CMPC5   R1, 1(CS_SRC), #0, R0, 13(R4)			      ;
		    0D   A4	       50     00429									      ;
				       14  12 0042C 	    BNEQ    5$							      ;
				  04   A7  D5 0042E 	    TSTL    4(R7)						      ; 2929
				       0F  12 00431 	    BNEQ    5$							      ;
		         0B	  03   A4  E9 00433 	    BLBC    3(R4), 5$						      ;
		    BC   8F	  02   A4  91 00437 	    CMPB    2(R4), #188						      ; 2935
				       04  13 0043C 	    BEQL    5$							      ;
		         50	       01  D0 0043E 4$:     MOVL    #1, R0						      ; 2939
					   04 00441 	    RET     							      ;
				       50  D4 00442 5$:     CLRL    R0							      ; 2806
					   04 00444 	    RET     							      ;

; Routine Size:  120 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 13
; Digital Equipment Corporation
;
;	2944	GLOBAL ROUTINE PAT$VAL_TO_SYM( VALUE, NT_PTR_ADDR, LVT_FLAG ) =
;	2945	
;	2946	!++
;	2947	! Functional Description:
;	2948	!
;	2949	!	Implement the search algorithm which PATCH uses to
;	2950	!	correspond values with symbols.
;	2951	!
;	2952	! Formal Parameters:
;	2953	!
;	2954	!	VALUE		-The key we use in the lookup.
;	2955	!	NT_PTR_ADDR	-A pointer to where we should copy back
;	2956	!			 the NT_POINTER to the record we find
;	2957	!			 to correspond to the value.  The
;	2958	!			 contents of this location are not changed
;	2959	!			 if no such correspondence is discovered.
;	2960	!	LVT_FLAG	-Whether or not we should even try for a
;	2961	!			 match in the literal value table (LVT).
;	2962	!			 (We always lookup in the SAT first).
;	2963	! Warning:
;	2964	!	
;	2965	!	We return an NT pointer via NT_PTR_ADDR.
;	2966	!	As long as this returned value is NOT a longword,
;	2967	!	due to BLISS's inability to use the REF NT_RECORD
;	2968	!	ONLY as an NT pointer, (i.e. BLISS assumes that 
;	2969	!	REFs are longwords), a caller of this routine should
;	2970	!	initialize the NT_PTR to 0 before expecting this
;	2971	!	routine to pass back the value.  This routine
;	2972	!	can not pass back a longword because we won't know that
;	2973	!	the address we were passed is not a real NT_PTR
;	2974	!	field - ie, the 2-bytes that it should be...
;	2975	!
;	2976	! Implicit Inputs:
;	2977	!
;	2978	!	None.
;	2979	!
;	2980	! Implicit Outputs:
;	2981	!
;	2982	!	The RESULT parameter via NT_PTR_ADDR.
;	2983	!	(see above.)
;	2984	!
;	2985	! Routine Value:
;	2986	!
;	2987	!	TRUE, if a match is found,
;	2988	!	FALSE, otherwise.
;	2989	!
;	2990	! Side Effects:
;	2991	!
;	2992	!
;	2993	!	The SAT (and LVT) table(s) is/are searched.
;	2994	!--
;	2995	
;	2996	BEGIN
;	2997	
;	2998	MAP

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 13-1
; Digital Equipment Corporation
;
;	2999		NT_PTR_ADDR : REF RST_POINTER;				! The NT pointer we return is an RST-pointer.
;	3000	
;	3001	LOCAL
;	3002		SAT_PTR : REF SAT_RECORD;
;	3003	
;	3004	IF (VAL_TO_SAT(.VALUE, SAT_PTR))
;	3005	THEN
;	3006		BEGIN
;	3007		!++
;	3008		! Make up for the fact that we are supposed to return an NT pointer,
;	3009		! not the SAT pointer that VAL_TO_SAT gave us.
;	3010		!--
;	3011		NT_PTR_ADDR[0] = .SAT_PTR[SAT_NT_PTR];
;	3012		RETURN(TRUE);
;	3013		END;
;	3014	
;	3015	RETURN(	IF (.LVT_FLAG)
;	3016		THEN
;	3017			LOOKUP_LVT( .VALUE, .NT_PTR_ADDR )
;	3018		ELSE
;	3019			FALSE);
;	3020	END;





					 0000 00445 	    .ENTRY  PAT$VAL_TO_SYM, Save nothing			      ; 2944
		         5E	       04  C2 00447 	    SUBL2   #4, SP						      ;
				       5E  DD 0044A 	    PUSHL   SP							      ; 3004
				  04   AC  DD 0044C 	    PUSHL   VALUE						      ;
	      00000000V  EF	       02  FB 0044F 	    CALLS   #2, VAL_TO_SAT					      ;
		         09	       50  E9 00456 	    BLBC    R0, 1$						      ;
		    08   BC	  00   BE  B0 00459 	    MOVW    @SAT_PTR, @NT_PTR_ADDR				      ; 3011
		         50	       01  D0 0045E 	    MOVL    #1, R0						      ; 3012
					   04 00461 	    RET     							      ;
		         0C	  0C   AC  E9 00462 1$:     BLBC    LVT_FLAG, 2$					      ; 3015
		         7E	  04   AC  7D 00466 	    MOVQ    VALUE, -(SP)					      ; 3017
	      00000000V  EF	       02  FB 0046A 	    CALLS   #2, LOOKUP_LVT					      ;
					   04 00471 	    RET     							      ; 3015
				       50  D4 00472 2$:     CLRL    R0							      ;
					   04 00474 	    RET     							      ; 2944

; Routine Size:  48 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14
; Digital Equipment Corporation
;
;	3021	ROUTINE VAL_TO_SAT( VALUE, SAT_PTR_ADDR ) =
;	3022	
;	3023	!++
;	3024	! Functional Description:
;	3025	!
;	3026	!	Search the Static Address Table (SAT) for the best 
;	3027	!	match to the given value.
;	3028	!
;	3029	! Formal Parameters:
;	3030	!
;	3031	!	VALUE		-The key we use in the lookup.
;	3032	!	SAT_PTR_ADDR	-A pointer to where we should copy back
;	3033	!			 the SAT_POINTER to the record we find
;	3034	!			 to correspond to the value.  The
;	3035	!			 contents of this location are not changed
;	3036	!			 if no such correspondence is discovered.
;	3037	!
;	3038	! Implicit Inputs:
;	3039	!
;	3040	!	The way we define a 'match' in the SAT is
;	3041	!	determined solely in this routine.
;	3042	!
;	3043	! Implicit Outputs:
;	3044	!
;	3045	!	The RESULT parameter, via SAT_PTR_ADDR, also
;	3046	!	indicates the corresponding NT record
;	3047	!	(via SAT_NT_PTR).
;	3048	!
;	3049	! Routine Value:
;	3050	!
;	3051	!	TRUE, if a match is found,
;	3052	!	FALSE, otherwise.
;	3053	!
;	3054	! Side Effects:
;	3055	!
;	3056	!	The SAT is searched.
;	3057	!--
;	3058	
;	3059	BEGIN
;	3060	
;	3061	MAP
;	3062		SAT_PTR_ADDR : REF VECTOR;				! The SAT pointer we stuff back is a longword.
;	3063	
;	3064	LABEL
;	3065		SEARCH_SAT;
;	3066	
;	3067	LOCAL
;	3068		CURRENT_NT  : REF NT_RECORD,				! When we look at each record of the SAT_VECTOR,
;	3069									! we apply the proper structure.
;	3070		CURRENT_SAT : REF SAT_RECORD,
;	3071		NEXT_SAT : REF SAT_RECORD,
;	3072		BEST_SAT : REF SAT_RECORD;				! When we look at each record of the SAT_VECTOR,
;	3073									! we apply the proper structure.
;	3074									! same time - the 'current' one, and
;	3075									! the previous, or so-far 'best', one.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14-1
; Digital Equipment Corporation
;
;	3076	
;	3077	!++
;	3078	! There starts out being no 'previous' or  best match.  There is also no initial
;	3079	! notion of 'current' sat - we made it different from 'best' to begin with
;	3080	! solely for the diagnostic printout, below.
;	3081	!--
;	3082	BEST_SAT = 0;
;	3083	
;	3084	!++
;	3085	! Set up to begin the sequential pass of the SAT.
;	3086	!--
;	3087	PAT$GET_NXT_SAT( SL_ACCE_INIT );
;	3088	
;	3089	!++
;	3090	! Linearly search the SAT looking for an exact match. SAT access type is _RECS
;	3091	! because we want to quit  when the access-mapping routine recognizes that
;	3092	! even though there may be more potential records in the SAT, there are no more
;	3093	! ones currently in use.
;	3094	!--
;	3095	WHILE( (NEXT_SAT = PAT$GET_NXT_SAT( SL_ACCE_RECS )) NEQ 0 )
;	3096		DO
;	3097	
;	3098	    SEARCH_SAT:
;	3099		BEGIN
;	3100	
;	3101		!++
;	3102		! Update our idea of the current SAT to consider.
;	3103		!--
;	3104		CURRENT_SAT = .NEXT_SAT;
;	3105		CURRENT_NT = .CURRENT_SAT[SAT_NT_PTR];
;	3106	
;	3107		IF (.CURRENT_SAT[SAT_LB] EQL .VALUE)
;	3108		THEN
;	3109			BEGIN
;	3110			!++		
;	3111			! We define a match to be 'best' if it is an exact one.  Even
;	3112			! better, though, is an exact match which is NOT to a p-sect symbol.
;	3113			!--
;	3114			IF (.BEST_SAT EQL 0)
;	3115			THEN
;	3116				BEGIN
;	3117				!++
;	3118				! Since there were no previous candidates, we take
;	3119				! the current one as best.
;	3120				!--
;	3121				BEST_SAT = .CURRENT_SAT;
;	3122				END
;	3123			ELSE
;	3124				BEGIN
;	3125				!++
;	3126				! See if the former 'best' match was exact.
;	3127				!--
;	3128				IF (.BEST_SAT[SAT_LB] NEQ .VALUE)
;	3129				THEN
;	3130					!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14-2
; Digital Equipment Corporation
;
;	3131					! The newer and exact match is preferable to a 
;	3132					! previous non-exact one no matter what.
;	3133					!--
;	3134					BEST_SAT = .CURRENT_SAT
;	3135				ELSE
;	3136					!++
;	3137					! Since there was a previous exact match, 
;	3138					! and there now is a current exact match,
;	3139					! we choose the one which is not a p-sect
;	3140					! (even if we end up with one which was a
;	3141					!  match only because its UB is 0).
;	3142					!--
;	3143					IF (.CURRENT_NT[NT_TYPE] NEQ DSC$K_DTYPE_PCT)
;	3144					THEN
;	3145						BEST_SAT = .CURRENT_SAT;
;	3146				END;
;	3147	
;	3148			!++
;	3149			! At this point there is nothing further to do
;	3150			! until we see if there are any more candidates.
;	3151			!--
;	3152			LEAVE SEARCH_SAT;
;	3153			END;
;	3154	
;	3155		!++
;	3156		! Now try for a non-exact match.
;	3157		!--
;	3158		IF (.CURRENT_SAT[SAT_LB] GTRA .VALUE)
;	3159		THEN
;	3160			!++
;	3161			! Once we get past the value we were
;	3162			! searching for, we know there will be
;	3163			! no other candidates because the SAT
;	3164			! is sorted.
;	3165			!--
;	3166			EXITLOOP;
;	3167	
;	3168		!++
;	3169		! At this point, we know that the CURRENT lower bound! value is strictly
;	3170		! less than VALUE.  Now we are! concerned about the corresponding upper
;	3171		! bound value. Normally this UB value is the address which is the
;	3172		! upper extent to which the corresponding symbol is bound.  Some symbols
;	3173		! don't come with this info, though, so we handle these cases separately.
;	3174		!--
;	3175		IF (.CURRENT_SAT[SAT_UB] NEQ 0)
;	3176		THEN
;	3177			BEGIN
;	3178			!++
;	3179			! Since we have the UB information, we simply see if the
;	3180			! CURRENT symbol spans the given VALUE.
;	3181			!--
;	3182			IF (.CURRENT_SAT[SAT_UB] LSSA .VALUE)
;	3183			THEN
;	3184				LEAVE SEARCH_SAT;			! This datum ends too soon.
;	3185	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14-3
; Digital Equipment Corporation
;
;	3186			!++
;	3187			! VALUE falls within this symbol's extent. If we already have
;	3188			! a match but havn't accepted it as final, then its UB must
;	3189			! be 0, or its type is  P-sect.  In either case, this new one
;	3190			! is better because its UB is not 0.
;	3191			!--
;	3192			BEST_SAT = .CURRENT_SAT;
;	3193	
;	3194			!++
;	3195			! If the best one now is of type P-sect, we  should still
;	3196			! look further.
;	3197			!--
;	3198			IF (.CURRENT_NT[NT_TYPE] NEQ DSC$K_DTYPE_PCT)
;	3199			THEN
;	3200				!++
;	3201				! This is the first non-P-sect match so we'll take it
;	3202				! without any further checks.  This is where we might
;	3203				! get into trouble later because there may still be a
;	3204				! more appropriate match if we were to take SCOPE into
;	3205				! account.
;	3206				!--
;	3207				EXITLOOP;
;	3208					
;	3209			!++
;	3210			! There is nothing further to consider when we know the UB value.
;	3211			!  At this point we want to loop back and perhaps find a
;	3212			! better match.
;	3213			!--
;	3214			END
;	3215		ELSE
;	3216			BEGIN
;	3217			!++
;	3218			! We must consider it to be a match when the upper bound is 0
;	3219			! because we don't know that it isn't a match.
;	3220			! It is certainly not a good match, though, so we throw it
;	3221			! away unless we don't have anything better.
;	3222			!--
;	3223			IF (.BEST_SAT EQL 0)
;	3224			THEN
;	3225				BEST_SAT = .CURRENT_SAT
;	3226			ELSE
;	3227				IF (.BEST_SAT[SAT_UB] EQL 0)
;	3228				THEN
;	3229					BEST_SAT = .CURRENT_SAT
;	3230				ELSE
;	3231					!++
;	3232					! BEST must be p-sect
;	3233					!--
;	3234					IF (.CURRENT_NT[NT_TYPE] NEQ DSC$K_DTYPE_PCT)
;	3235					THEN
;	3236						BEST_SAT = .CURRENT_SAT;
;	3237			END;
;	3238	
;	3239		END;							! Loop back and try again with the next  SAT record.
;	3240	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14-4
; Digital Equipment Corporation
;
;	3241	!++
;	3242	! If we fall out of the above loop, then there are no more candidates from the
;	3243	! RST to consider.  See if the answer we got was good enough, or if we should
;	3244	! consult the GST.
;	3245	!--
;	3246	IF (.BEST_SAT EQL 0)
;	3247	THEN
;	3248		!++
;	3249		! Any global is better than nothing.
;	3250		!--
;	3251		BEST_SAT = GBL_VAL_TO_SAT(.VALUE)
;	3252	ELSE
;	3253		!++
;	3254		! Don't even try for a global if we already got
;	3255		! an exact match from the RST.
;	3256		!--
;	3257		IF (NOT .VALUE EQLA .BEST_SAT[SAT_LB])
;	3258		THEN
;	3259			BEGIN
;	3260			LOCAL
;	3261				BEST_NT : REF NT_RECORD;
;	3262	
;	3263			!++
;	3264			! Check for a better match.
;	3265			!--
;	3266			BEST_NT = .BEST_SAT[SAT_NT_PTR];
;	3267			IF ((.BEST_SAT[SAT_UB] EQL 0) OR
;	3268			    (.BEST_NT[NT_TYPE] EQL DSC$K_DTYPE_PCT))
;	3269			THEN
;	3270				IF ((CURRENT_SAT = GBL_VAL_TO_SAT(.VALUE)) NEQ 0)
;	3271				THEN
;	3272					!++
;	3273					! The global match is better if it is closer.
;	3274					!--
;	3275					IF (.CURRENT_SAT[SAT_LB] GTRA .BEST_SAT[SAT_LB])
;	3276					THEN
;	3277						BEST_SAT = .CURRENT_SAT;
;	3278			END;
;	3279	
;	3280	!++
;	3281	! Now see how we've done.
;	3282	!--
;	3283	IF (.BEST_SAT NEQ 0)
;	3284	THEN
;	3285		BEGIN
;	3286		!++
;	3287		! Pass back the NT-pointer to the match and return a success status.
;	3288		!--
;	3289		SAT_PTR_ADDR[0] = .BEST_SAT;
;	3290		RETURN(TRUE);
;	3291		END;
;	3292	
;	3293	!++
;	3294	! No 'match' was found - return the standard failure status.
;	3295	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14-5
; Digital Equipment Corporation
;
;	3296	RETURN(FALSE);
;	3297	END;





					 0E7C 00475 VAL_TO_SAT:
							    .WORD   Save R2,R3,R4,R5,R6,R9,R10,R11			      ; 3021
		         59 00000000G  EF  9E 00477 	    MOVAB   PAT$GET_NXT_SAT, R9					      ;
		         5A	FCBF   CF  9E 0047E 	    MOVAB   GBL_VAL_TO_SAT, R10					      ;
		         5B 00000000G  EF  9E 00483 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
				       53  D4 0048A 	    CLRL    BEST_SAT						      ; 3082
				       7E  D4 0048C 	    CLRL    -(SP)						      ; 3087
		         69	       01  FB 0048E 	    CALLS   #1, PAT$GET_NXT_SAT					      ;
		         54	  04   AC  D0 00491 	    MOVL    VALUE, R4						      ; 3107
				       01  DD 00495 1$:     PUSHL   #1							      ; 3095
		         69	       01  FB 00497 	    CALLS   #1, PAT$GET_NXT_SAT					      ;
		         56	       50  D0 0049A 	    MOVL    R0, NEXT_SAT					      ;
				       52  13 0049D 	    BEQL    6$							      ;
		         52	       56  D0 0049F 	    MOVL    NEXT_SAT, CURRENT_SAT				      ; 3104
		         55	       62  3C 004A2 	    MOVZWL  (CURRENT_SAT), CURRENT_NT				      ; 3105
		         54	  02   A2  D1 004A5 	    CMPL    2(CURRENT_SAT), R4					      ; 3107
				       0C  12 004A9 	    BNEQ    2$							      ;
				       53  D5 004AB 	    TSTL    BEST_SAT						      ; 3114
				       3D  13 004AD 	    BEQL    5$							      ;
		         54	  02   A3  D1 004AF 	    CMPL    2(BEST_SAT), R4					      ; 3128
				       2C  13 004B3 	    BEQL    4$							      ;
				       35  11 004B5 	    BRB     5$							      ; 3134
		         54	  02   A2  D1 004B7 2$:     CMPL    2(CURRENT_SAT), R4					      ; 3158
				       34  1A 004BB 	    BGTRU   6$							      ;
				  06   A2  D5 004BD 	    TSTL    6(CURRENT_SAT)					      ; 3175
				       16  13 004C0 	    BEQL    3$							      ;
		         54	  06   A2  D1 004C2 	    CMPL    6(CURRENT_SAT), R4					      ; 3182
				       CD  1F 004C6 	    BLSSU   1$							      ;
		         53	       52  D0 004C8 	    MOVL    CURRENT_SAT, BEST_SAT				      ; 3192
	   50	         55	       6B  C1 004CB 	    ADDL3   PAT$GL_RST_BEGN, CURRENT_NT, R0			      ; 3198
		    B8   8F	  02   A0  91 004CF 	    CMPB    2(R0), #184						      ;
				       BF  13 004D4 	    BEQL    1$							      ;
				       19  11 004D6 	    BRB     6$							      ; 3207
				       53  D5 004D8 3$:     TSTL    BEST_SAT						      ; 3223
				       10  13 004DA 	    BEQL    5$							      ;
				  06   A3  D5 004DC 	    TSTL    6(BEST_SAT)						      ; 3227
				       0B  13 004DF 	    BEQL    5$							      ;
	   50	         55	       6B  C1 004E1 4$:     ADDL3   PAT$GL_RST_BEGN, CURRENT_NT, R0			      ; 3234
		    B8   8F	  02   A0  91 004E5 	    CMPB    2(R0), #184						      ;
				       A9  13 004EA 	    BEQL    1$							      ;
		         53	       52  D0 004EC 5$:     MOVL    CURRENT_SAT, BEST_SAT				      ; 3236
				       A4  11 004EF 	    BRB     1$							      ; 3095
				       53  D5 004F1 6$:     TSTL    BEST_SAT						      ; 3246
				       0A  12 004F3 	    BNEQ    7$							      ;
				       54  DD 004F5 	    PUSHL   R4							      ; 3251
		         6A	       01  FB 004F7 	    CALLS   #1, GBL_VAL_TO_SAT					      ;
		         53	       50  D0 004FA 	    MOVL    R0, BEST_SAT					      ;
				       2C  11 004FD 	    BRB     9$							      ; 3246

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 14-6
; Digital Equipment Corporation
;
		    02   A3	       54  D1 004FF 7$:     CMPL    R4, 2(BEST_SAT)					      ; 3257
				       26  13 00503 	    BEQL    9$							      ;
		         50	       63  3C 00505 	    MOVZWL  (BEST_SAT), BEST_NT					      ; 3266
				  06   A3  D5 00508 	    TSTL    6(BEST_SAT)						      ; 3267
				       0A  13 0050B 	    BEQL    8$							      ;
		         50	       6B  C0 0050D 	    ADDL2   PAT$GL_RST_BEGN, R0					      ; 3268
		    B8   8F	  02   A0  91 00510 	    CMPB    2(R0), #184						      ;
				       14  12 00515 	    BNEQ    9$							      ;
				       54  DD 00517 8$:     PUSHL   R4							      ; 3270
		         6A	       01  FB 00519 	    CALLS   #1, GBL_VAL_TO_SAT					      ;
		         52	       50  D0 0051C 	    MOVL    R0, CURRENT_SAT					      ;
				       0A  13 0051F 	    BEQL    9$							      ;
		    02   A3	  02   A2  D1 00521 	    CMPL    2(CURRENT_SAT), 2(BEST_SAT)				      ; 3275
				       03  1B 00526 	    BLEQU   9$							      ;
		         53	       52  D0 00528 	    MOVL    CURRENT_SAT, BEST_SAT				      ; 3277
				       53  D5 0052B 9$:     TSTL    BEST_SAT						      ; 3283
				       08  13 0052D 	    BEQL    10$							      ;
		    08   BC	       53  D0 0052F 	    MOVL    BEST_SAT, @SAT_PTR_ADDR				      ; 3289
		         50	       01  D0 00533 	    MOVL    #1, R0						      ; 3290
					   04 00536 	    RET     							      ;
				       50  D4 00537 10$:    CLRL    R0							      ; 3296
					   04 00539 	    RET     							      ; 3021

; Routine Size:  197 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 15
; Digital Equipment Corporation
;
;	3298	ROUTINE LOOKUP_LVT( VALUE, NT_PTR_ADDR ) =
;	3299	
;	3300	!++
;	3301	! Functional Description:
;	3302	!
;	3303	!	Search the literal value table (LVT) for a match
;	3304	!	to the given value.
;	3305	!
;	3306	! Formal Parameters:
;	3307	!
;	3308	!	VALUE		-The key we use in the lookup.
;	3309	!	NT_PTR_ADDR	-A pointer to where we should copy back
;	3310	!			 the NT_POINTER to the record we find
;	3311	!			 to correspond to the value.  The
;	3312	!			 contents of this location are not changed
;	3313	!			 if no such correspondence is discovered.
;	3314	!
;	3315	! Warning:
;	3316	!	
;	3317	!	We return an NT pointer via NT_PTR_ADDR.
;	3318	!	As long as this returned value is NOT a longword,
;	3319	!	due to BLISS's inability to use the REF NT_RECORD
;	3320	!	ONLY as an NT pointer, (i.e. BLISS assumes that 
;	3321	!	REFs are longwords), a caller of this routine should
;	3322	!	initialize the NT_PTR to 0 before expecting this
;	3323	!	routine to pass back the value.  This routine
;	3324	!	can not pass back a longword because we won't know that
;	3325	!	the address we were passed is not a real NT_PTR
;	3326	!	field - ie, the 2-bytes that it should be...
;	3327	!
;	3328	! Implicit Inputs:
;	3329	!
;	3330	!	The way we define a 'match' in the LVT which is 
;	3331	!	simply that the given value must be exactly the
;	3332	!	same as the corresponding one from the LVT.  The
;	3333	!	first one found is always the one passed back.
;	3334	!
;	3335	! Implicit Outputs:
;	3336	!
;	3337	!	The RESULT parameter via NT_PTR_ADDR.
;	3338	!	(see above.)
;	3339	!
;	3340	! Routine Value:
;	3341	!
;	3342	!	TRUE, if a match is found,
;	3343	!	FALSE, otherwise.
;	3344	!
;	3345	! Side Effects:
;	3346	!
;	3347	!	The LVT is searched.
;	3348	!--
;	3349	
;	3350	BEGIN
;	3351	
;	3352	MAP

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 15-1
; Digital Equipment Corporation
;
;	3353		NT_PTR_ADDR : REF RST_POINTER;
;	3354	
;	3355	LOCAL
;	3356		LVT_PTR : REF LVT_RECORD;				! When we look at each record of the LVT_VECTOR,
;	3357									! we apply the proper structure.
;	3358	
;	3359	!++
;	3360	! Set up to begin the sequential pass of the LVT.
;	3361	!--
;	3362	PAT$GET_NXT_LVT( SL_ACCE_INIT );
;	3363	
;	3364	!++
;	3365	! Linearly search the LVT looking for an exact match. LVT access type is _RECS
;	3366	! because we want to quit  when the access-mapping routine recognizes that
;	3367	! even though there may be more potential records in the LVT, there are no more
;	3368	! ones currently in use.
;	3369	!--
;	3370	WHILE ((LVT_PTR = PAT$GET_NXT_LVT( SL_ACCE_RECS )) NEQ 0)
;	3371		DO
;	3372		BEGIN
;	3373	
;	3374		IF (.LVT_PTR[LVT_VALUE] EQL .VALUE)
;	3375		THEN
;	3376			BEGIN
;	3377			!++
;	3378			! This is the only place we can find a match and return an OK status.
;	3379			!--
;	3380			NT_PTR_ADDR[0] = .LVT_PTR[LVT_NT_PTR];
;	3381			RETURN(TRUE);
;	3382			END;
;	3383	
;	3384		!++
;	3385		! Loop back and try again with the next  LVT record.
;	3386		!--
;	3387		END;
;	3388	
;	3389	!++
;	3390	! If we fall out of the above loop, no match can be found.
;	3391	!--
;	3392	RETURN(FALSE);
;	3393	END;





					 0804 0053A LOOKUP_LVT:
							    .WORD   Save R2,R11						      ; 3298
		         5B 00000000G  EF  9E 0053C 	    MOVAB   PAT$GET_NXT_LVT, R11				      ;
				       7E  D4 00543 	    CLRL    -(SP)						      ; 3362
		         6B	       01  FB 00545 	    CALLS   #1, PAT$GET_NXT_LVT					      ;
				       01  DD 00548 1$:     PUSHL   #1							      ; 3370
		         6B	       01  FB 0054A 	    CALLS   #1, PAT$GET_NXT_LVT					      ;
		         52	       50  D0 0054D 	    MOVL    R0, LVT_PTR						      ;
				       0F  13 00550 	    BEQL    2$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 15-2
; Digital Equipment Corporation
;
		    04   AC	  02   A2  D1 00552 	    CMPL    2(LVT_PTR), VALUE					      ; 3374
				       EF  12 00557 	    BNEQ    1$							      ;
		    08   BC	       62  B0 00559 	    MOVW    (LVT_PTR), @NT_PTR_ADDR				      ; 3380
		         50	       01  D0 0055D 	    MOVL    #1, R0						      ; 3381
					   04 00560 	    RET     							      ;
				       50  D4 00561 2$:     CLRL    R0							      ; 3392
					   04 00563 	    RET     							      ; 3298

; Routine Size:  42 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 16
; Digital Equipment Corporation
;
;	3394	GLOBAL ROUTINE PAT$SYMBOL_VALU( NT_PTR, VALUE_PTR ) =
;	3395	
;	3396	!++
;	3397	! Functional Description:
;	3398	!
;	3399	!	-Look up the value associated with a given
;	3400	!	 NT record.
;	3401	!	-Note that we refer to 'value' associated with a symbol
;	3402	!	 but really mean 'address', since that is as far as RST
;	3403	!	 manipulation handles symbol-value correlation.
;	3404	!
;	3405	! Formal Parameters:
;	3406	!
;	3407	!	NT_PTR		-a pointer to the NT_RECORD that corresponds
;	3408	!			 to the symbol we want the value of.
;	3409	!	VALUE_PTR	-where we are to copy the value back to.
;	3410	!
;	3411	! Implicit Inputs:
;	3412	!
;	3413	!	-We can call PAT$DST_VALUE with a DST_REC_ID.
;	3414	!	 (in BLD's ADD_NT we call it with a DST_RECRD pointer).
;	3415	!
;	3416	!	-The value bound to a symbol can be passed
;	3417	!	 back in a longword.
;	3418	!	-NT records marked NT_IS_GLOBAL may be 1 of 2 types:
;	3419	!	   1) one which was first a normal NT record but
;	3420	!		which was later marked NT_IS_GLOBAL.  In this case
;	3421	!		there IS scope info, and we pick up the value
;	3422	!		from the DST.
;	3423	!	   2) a fake NT record which was created from a GST
;	3424	!		record.  In this case the 'value' field is stored
;	3425	!		in the NT_DST_PTR field of the NT record.
;	3426	!
;	3427	! Implicit Outputs:
;	3428	!
;	3429	!	None.
;	3430	!
;	3431	! Routine Value:
;	3432	!
;	3433	!	TRUE, if the symbol is found successfully and
;	3434	!		 the returned value is the address bound to the symbol,
;	3435	!	3, if the symbol is found successfully and the value returned is the
;	3436	!		 address of an array descriptor for the symbol,
;	3437	!	FALSE or 2, otherwise.
;	3438	!
;	3439	! Side Effects:
;	3440	!
;	3441	!	The value gets passed back.
;	3442	!--
;	3443	
;	3444	BEGIN
;	3445	
;	3446	MAP
;	3447		NT_PTR    : REF NT_RECORD,
;	3448		VALUE_PTR : REF VECTOR[,LONG];

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 16-1
; Digital Equipment Corporation
;
;	3449	
;	3450	!++
;	3451	! If this NT record corresponds only to a GLOBAL symbol, there is no associated
;	3452	! DST record.  In this case we use the DST pointer space from the NT record
;	3453	! to contain the value associated with the global symbol.
;	3454	!--
;	3455	IF (.NT_PTR[NT_IS_GLOBAL] AND .NT_PTR[NT_UP_SCOPE] EQL 0)
;	3456	THEN
;	3457		BEGIN
;	3458		VALUE_PTR[0] = .NT_PTR[NT_GBL_VALUE];
;	3459	
;	3460		RETURN(TRUE);
;	3461		END;
;	3462	
;	3463	!++
;	3464	! We localize all DST understanding to yet another routine.
;	3465	!--
;	3466	RETURN( PAT$DST_VALUE( .NT_PTR[NT_DST_PTR], .VALUE_PTR));
;	3467	END;





					 0000 00564 	    .ENTRY  PAT$SYMBOL_VALU, Save nothing			      ; 3394
	   50	    04   AC 00000000G  EF  C1 00566 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R0				      ; 3455
		         0E	  03   A0  E9 0056F 	    BLBC    3(R0), 1$						      ;
				  08   A0  B5 00573 	    TSTW    8(R0)						      ;
				       09  12 00576 	    BNEQ    1$							      ;
		    08   BC	  04   A0  D0 00578 	    MOVL    4(R0), @VALUE_PTR					      ; 3458
		         50	       01  D0 0057D 	    MOVL    #1, R0						      ; 3460
					   04 00580 	    RET     							      ;
				  08   AC  DD 00581 1$:     PUSHL   VALUE_PTR						      ; 3466
				  04   A0  DD 00584 	    PUSHL   4(R0)						      ;
	      00000000V  EF	       02  FB 00587 	    CALLS   #2, PAT$DST_VALUE					      ;
					   04 0058E 	    RET     							      ; 3394

; Routine Size:  43 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 17
; Digital Equipment Corporation
;
;	3468	GLOBAL ROUTINE PAT$DST_VALUE( DST_REC_ID, VALUE_PTR ) =
;	3469	
;	3470	!++
;	3471	! Functional Description:
;	3472	!
;	3473	!	-Look up the value associated with a given
;	3474	!	 DST record.
;	3475	!	-Note that we refer to 'value' associated with a symbol
;	3476	!	 but really mean 'address', since that is as far as RST
;	3477	!	 manipulation handles symbol-value correlation.
;	3478	!	 Normally this 'address' is the virtual address which is
;	3479	!	 bound to the symbol.  If the symbol is associated with
;	3480	!	 a descriptor, though, it is the address of the descriptor
;	3481	!	 which is returned for this symbol.
;	3482	!
;	3483	! Formal Parameters:
;	3484	!
;	3485	!	DST_REC_ID	-a pointer to the DST RECORD that corresponds
;	3486	!			 to the symbol we want the value of.
;	3487	!			-this may also be the DBGINT-defined DST record ID
;	3488	!			 which it assigns to each DST record it processes.
;	3489	!			 ***** see implicit inputs below.
;	3490	!	VALUE_PTR	-where we are to copy the value back to.
;	3491	!
;	3492	! Implicit Inputs:
;	3493	!
;	3494	!	The concept of a DST_REC_ID vs a DST_RECRD pointer
;	3495	!	is merged by this routine.  i.e. we don't consider
;	3496	!	these two things to be different even though everything
;	3497	!	else in PATCH does not preclude this.  If the
;	3498	!	DST interface routine is changed so that these two things
;	3499	!	are no longer the same, we must change calls to this routine
;	3500	!	to be consistent.  So far this routine is called 
;	3501	!	by PAT$SYMBOL_VALU and ADD_NT only.
;	3502	!
;	3503	!	-The value bound to a symbol can be passed
;	3504	!	 back in a longword.
;	3505	!
;	3506	! Implicit Outputs:
;	3507	!
;	3508	!	None.
;	3509	!
;	3510	! Routine Value:
;	3511	!
;	3512	!	TRUE, if the symbol is found successfully and the value returned is the
;	3513	!		 address bound to the symbol,
;	3514	!	3, if the symbol is found successfully and the value returned is the
;	3515	!		 address of an array descriptor for the symbol,
;	3516	!	FALSE or 2, otherwise.
;	3517	!
;	3518	! Side Effects:
;	3519	!
;	3520	!	The value gets returned.
;	3521	!
;	3522	!	The DST is 'read' in such a way as to ensure that 

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 17-1
; Digital Equipment Corporation
;
;	3523	!	if any PAT$GET_NXT_DST sequence is in progress it
;	3524	!	is NOT disturbed by this call.
;	3525	!--
;	3526	
;	3527	BEGIN
;	3528	
;	3529	MAP
;	3530		VALUE_PTR : REF VECTOR[,LONG];
;	3531	
;	3532	LOCAL
;	3533		STATUS,							! RETURNED STATUS CODE
;	3534		MAPPED_ADR : REF BLOCK[,BYTE],				! Mapped descriptor address
;	3535		ISE_ADR,						! Image Section Address
;	3536		VALUE,							! Used to accumulate the symbol's value.
;	3537		ACCESS,							! The access field from the DST record.
;	3538		DST_RECRD : REF DST_RECORD;
;	3539	
;	3540	!++
;	3541	! Fetch the indicated DST record.
;	3542	!--
;	3543	STATUS = TRUE;						! ASSUME EVERYTHING WORKS
;	3544	IF ((DST_RECRD = PAT$GET_DST_REC( .DST_REC_ID )) EQL 0)
;	3545	THEN
;	3546		!++
;	3547		! The supposed record does not exist.  An error message should already
;	3548		! have been produced.
;	3549		!--		
;	3550		RETURN(FALSE);
;	3551	
;	3552	!++
;	3553	! How we pick up the value depends on what class of DST record this is.
;	3554	!--
;	3555	IF (.DST_RECRD[DSTR_TYPE] EQL DSC$K_DTYPE_Z)
;	3556	THEN
;	3557		BEGIN
;	3558		!++
;	3559		! BLISS Type Zero records have a format which is different from
;	3560		! standard DST records.
;	3561		!--
;	3562		BIND
;	3563			BLZ_RECRD = DST_RECRD : REF BLZ_RECORD;
;	3564	
;	3565		!++
;	3566		! We can't make any sense out of these records (yet) unless
;	3567		!	1) no optional type into was given
;	3568		!	   (i.e. we only get the standard 3 bytes)
;	3569		!	2) the structure attribute is 0
;	3570		!	3) the sub-type is within the range we currently support.
;	3571		!	   (i.e. only FORMALs and SYMBOLs are OK)
;	3572		!
;	3573		! We have already implicitly checked the first two of these because we
;	3574		! wouldn't have entered the symbol into the NT had this check
;	3575		! not succeeded.
;	3576		!--
;	3577	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 17-2
; Digital Equipment Corporation
;
;	3578		!++
;	3579		! Pick up the value of this symbol.
;	3580		!--
;	3581		STATUS = STD_SYM_EVAL(VALUE, .BLZ_RECRD[BLZ_ACCESS], .BLZ_RECRD[BLZ_VALUE]);
;	3582	
;	3583		!++
;	3584		! End of special handling for type ZERO variables.
;	3585		!--
;	3586		END
;	3587	ELSE
;	3588		!++
;	3589		! Class 1 is the so-called SRM 'standard' types.
;	3590		!--
;	3591		IF (.DST_RECRD[DSTR_TYPE] LEQ DST_TYP_HIGHEST)
;	3592		THEN
;	3593			BEGIN
;	3594			IF (.DST_RECRD[DSTR_ACCES_TYPE] EQL ACCS_DESCRIPTOR)
;	3595			THEN
;	3596				BEGIN
;	3597				!++
;	3598				! Ignore dynamically-located array descriptors.  This
;	3599				! means that only the so-called "PC" relative ones are
;	3600				! supported.
;	3601				!--
;	3602				IF (.DST_RECRD[DSTR_ACCES_BASD] NEQ 2) OR
;	3603				   (.DST_RECRD[DSTR_ACCES_BREG] NEQ 15)
;	3604				THEN
;	3605					RETURN(FALSE);
;	3606	
;	3607				!++
;	3608				! The descriptor is in the DST record itself.
;	3609				! The notion of PC is as though the 'DST' PC
;	3610				! were just used to 'pick up' the _VALUE field,
;	3611				! which gives how far from there to displace
;	3612				! to find the actual array descriptor.
;	3613				! For the routine PAT$SYM_TO_VAL, the status
;	3614				! code returned must indicate that this value is
;	3615				! an array descriptor address.
;	3616				!--
;	3617				VALUE = .DST_RECRD[DSTR_VALUE];
;	3618				VALUE = .VALUE + DST_RECRD[DSTR_VALUE] + %UPVAL;
;	3619				STATUS = 3;
;	3620				END
;	3621			ELSE
;	3622				!++
;	3623				! For standard types, we simply apply the corresponding
;	3624				! standard algorithm.  The various TYPEs will be used
;	3625				! mainly to sort out what we do with the value
;	3626				! after the algorithm tells us how to get it, but
;	3627				! this is handled outside of this routine.
;	3628				!--
;	3629				STATUS = STD_SYM_EVAL(VALUE, .DST_RECRD[DSTR_ACCESS], .DST_RECRD[DSTR_VALUE]);
;	3630			END
;	3631		ELSE
;	3632			BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 17-3
; Digital Equipment Corporation
;
;	3633			!++
;	3634			! Class 2 is 'the rest'.  We expect them to be from the standard
;	3635			! DSTR_TYPEs class.
;	3636			!--
;	3637			CASE .DST_RECRD[DSTR_TYPE] FROM DST_DST_LOWEST TO DST_DST_HIGHEST OF
;	3638			    SET
;	3639		
;	3640			    [DSC$K_DTYPE_FLD]:	! Bliss fields.
;	3641	
;	3642				BEGIN
;	3643				$FAO_TT_OUT('!/FLD not supported');
;	3644				RETURN(FALSE);
;	3645				END;
;	3646	
;	3647			    [DSC$K_DTYPE_PCT,
;	3648			     DSC$K_DTYPE_LBL,
;	3649			     dsc$k_dtype_slb,
;	3650			     DSC$K_DTYPE_RTN]:	! These ones have values.
;	3651	
;	3652				VALUE = .DST_RECRD[DSTR_VALUE];
;	3653	
;	3654			    [INRANGE,OUTRANGE]:	! Probably an error.
;	3655	
;	3656				RETURN(FALSE);
;	3657	
;	3658			    TES;
;	3659	
;	3660			END;
;	3661	
;	3662	!++
;	3663	! At this point, the value has been obtained or a RETURN has been done.
;	3664	! We simply pass back this value and return a good status code.
;	3665	!--
;	3666	VALUE_PTR[0] = .VALUE;
;	3667	RETURN(.STATUS);
;	3668	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .BYTE   19							      ;
					      00001 	    .ASCII  \!/FLD not supported\				      ;



							    .PSECT  _PAT$CODE,NOWRT,2

					 000C 0058F 	    .ENTRY  PAT$DST_VALUE, Save R2,R3				      ; 3468
		         5E	       04  C2 00591 	    SUBL2   #4, SP						      ;
		         53	       01  D0 00594 	    MOVL    #1, STATUS						      ; 3543
				  04   AC  DD 00597 	    PUSHL   DST_REC_ID						      ; 3544
	      00000000G  EF	       01  FB 0059A 	    CALLS   #1, PAT$GET_DST_REC					      ;
		         52	       50  D0 005A1 	    MOVL    R0, DST_RECRD					      ;
				       7D  13 005A4 	    BEQL    7$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 17-4
; Digital Equipment Corporation
;
				  01   A2  95 005A6 	    TSTB    1(DST_RECRD)					      ; 3555
				       09  12 005A9 	    BNEQ    1$							      ;
				  06   A2  DD 005AB 	    PUSHL   6(DST_RECRD)					      ; 3581
		         7E	  04   A2  9A 005AE 	    MOVZBL  4(DST_RECRD), -(SP)					      ;
				       37  11 005B2 	    BRB     3$							      ;
		         17	  01   A2  91 005B4 1$:     CMPB    1(DST_RECRD), #23					      ; 3591
				       40  1A 005B8 	    BGTRU   4$							      ;
		         50	  03   A2  9E 005BA 	    MOVAB   3(DST_RECRD), R0					      ; 3617
      02   A2	         02	       00  ED 005BE 	    CMPZV   #0, #2, 2(DST_RECRD), #2				      ; 3594
				       02     005C3									      ;
				       1F  12 005C4 	    BNEQ    2$							      ;
      02   A2	         02	       02  ED 005C6 	    CMPZV   #2, #2, 2(DST_RECRD), #2				      ; 3602
				       02     005CB									      ;
				       63  12 005CC 	    BNEQ    10$							      ;
      02   A2	         04	       04  ED 005CE 	    CMPZV   #4, #4, 2(DST_RECRD), #15				      ; 3603
				       0F     005D3									      ;
				       5B  12 005D4 	    BNEQ    10$							      ;
		         6E	       60  D0 005D6 	    MOVL    (R0), VALUE						      ; 3617
		         50	       6E  C0 005D9 	    ADDL2   VALUE, R0						      ; 3618
	   6E	         50	       04  C1 005DC 	    ADDL3   #4, R0, VALUE					      ;
		         53	       03  D0 005E0 	    MOVL    #3, STATUS						      ; 3619
				       44  11 005E3 	    BRB     9$							      ; 3594
				       60  DD 005E5 2$:     PUSHL   (R0)						      ; 3629
		         7E	  02   A2  98 005E7 	    CVTBL   2(DST_RECRD), -(SP)					      ;
				  08   AE  9F 005EB 3$:     PUSHAB  VALUE						      ;
	      00000000V  EF	       03  FB 005EE 	    CALLS   #3, STD_SYM_EVAL					      ;
		         53	       50  D0 005F5 	    MOVL    R0, STATUS						      ;
				       2F  11 005F8 	    BRB     9$							      ; 3591
	   08	    B7   8F	  01   A2  8F 005FA 4$:     CASEB   1(DST_RECRD), #183, #8				      ; 3637
	 0031	       0025	     0014     00600 5$:     .WORD   6$-5$,-						      ;
	 0031	       0025	     0025     00606		    8$-5$,-						      ;
	 0031	       0025	     0031     0060C		    10$-5$,-						      ;
								    8$-5$,-						      ;
								    8$-5$,-						      ;
								    10$-5$,-						      ;
								    10$-5$,-						      ;
								    8$-5$,-						      ;
								    10$-5$						      ;
				       1D  11 00612 	    BRB     10$							      ; 3656
				       7E  D4 00614 6$:     CLRL    -(SP)						      ; 3643
			    00000000'  EF  9F 00616 	    PUSHAB  P.AAA						      ;
	      00000000G  EF	       02  FB 0061C 	    CALLS   #2, PAT$FAO_OUT					      ;
				       0C  11 00623 7$:     BRB     10$							      ; 3644
		         6E	  03   A2  D0 00625 8$:     MOVL    3(DST_RECRD), VALUE					      ; 3652
		    08   BC	       6E  D0 00629 9$:     MOVL    VALUE, @VALUE_PTR					      ; 3666
		         50	       53  D0 0062D 	    MOVL    STATUS, R0						      ; 3667
					   04 00630 	    RET     							      ;
				       50  D4 00631 10$:    CLRL    R0							      ; 3468
					   04 00633 	    RET     							      ;

; Routine Size:  165 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 18
; Digital Equipment Corporation
;
;	3669	ROUTINE STD_SYM_EVAL( PASS_BACK_ADDR, ACCESS, IN_VALUE ) =
;	3670	
;	3671	!++
;	3672	! Functional Description:
;	3673	!
;	3674	!	Implement the algorithm which comes up with
;	3675	!	a symbol's value given the so-called ACCESS
;	3676	!	and IN_VALUE fields taken from (various places within)
;	3677	!	the DST record for a symbol which uses
;	3678	!	'standard encoding'.
;	3679	!
;	3680	!	See CP0021.MEM, pgs 9-10 for this algorithm.
;	3681	!
;	3682	! Formal Parameters:
;	3683	!
;	3684	!	PASS_BACK_ADDR	-The address of where we stuff back the value	-LT
;	3685	!			 the algorithm determines.
;	3686	!	ACCESS		-The 1-byte field which encodes the
;	3687	!			 3-element fields described in CP0021.MEM
;	3688	!			 for so-called 'standard encoding'.
;	3689	!	IN_VALUE	-The value field which may be used in
;	3690	!			 conjunction with ACCESS.
;	3691	!
;	3692	! Implicit Inputs:
;	3693	!
;	3694	!	That the value bound to a symbol can be passed
;	3695	!	back in a longword.
;	3696	!
;	3697	! Implicit Outputs:
;	3698	!
;	3699	!	The value which is currently associated with the symbol which
;	3700	!	presumably corresponds to the ACCESS and IN_VALUE fields given,
;	3701	!	is passed back.
;	3702	!
;	3703	! Routine Value:
;	3704	!
;	3705	!	TRUE, if all goes OK and the value gets passed back.
;	3706	!	NOT TRUE, otherwise.  In this case we distinguish two possibilities:
;	3707	!			0 => a real error - the symbol could not be evaluated.
;	3708	!		and	2 => a soft error - the evaluation failed because of an
;	3709	!						inappropriate context.
;	3710	!
;	3711	! Side Effects:
;	3712	!
;	3713	!	The value which is currently associated with
;	3714	!	the symbol which presumably corresponds to
;	3715	!	the ACCESS and IN_VALUE fields given.
;	3716	!--
;	3717	
;	3718	BEGIN
;	3719	
;	3720	MAP
;	3721		PASS_BACK_ADDR : REF VECTOR;				! THE VALUE WE PASS BACK IS A LONGWORD
;	3722	
;	3723	LOCAL

; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 18-1
; Digital Equipment Corporation
;
;	3724		RET_VALUE;						! We accumulate the value we return.
;	3725	
;	3726	!++
;	3727	! ******* THIS ROUTINE MUST BE WRITTEN WHEN BLISS VARIABLES ARE ADDED. *******
;	3728	!--
;	3729	RET_VALUE = .IN_VALUE;
;	3730	IF (.ACCESS<2,1,0>)						! If "indirect" set
;	3731	THEN
;	3732	! ******** WARNING:  Don't know if going indirect is to a mapped or
;	3733	!			non-mapped address.  Therfore return error for now.
;	3734	!	RET_VALUE = .(.RET_VALUE);
;	3735		RETURN(2);
;	3736	PASS_BACK_ADDR[0] = .RET_VALUE;
;	3737	RETURN(TRUE);
;	3738	END;





					 0000 00634 STD_SYM_EVAL:
							    .WORD   Save nothing					      ; 3669
		         50	  0C   AC  D0 00636 	    MOVL    IN_VALUE, RET_VALUE					      ; 3729
	   04	    08   AC	       02  E1 0063A 	    BBC     #2, ACCESS, 1$					      ; 3730
		         50	       02  D0 0063F 	    MOVL    #2, R0						      ; 3735
					   04 00642 	    RET     							      ;
		    04   BC	       50  D0 00643 1$:     MOVL    RET_VALUE, @PASS_BACK_ADDR				      ; 3736
		         50	       01  D0 00647 	    MOVL    #1, R0						      ; 3737
					   04 0064A 	    RET     							      ; 3669

; Routine Size:  23 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:37:44	DBB3:[PATCH.SRC]PATRST.B32;10					Page 19
; Digital Equipment Corporation
;
;	3739	END								! End of module
;	3740	ELUDOM






;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$CODE      	  1611  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$OWN       	     8    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	    20  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        11         0       225





; Size:		1611 code + 28 data bytes
; Run Time:	00:58.6
; Elapsed Time:	01:48.8
; Memory Used:	362 pages
; Compilation Complete
