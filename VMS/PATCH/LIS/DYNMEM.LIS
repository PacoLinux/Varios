
; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE DYNMEM (%IF %VARIANT EQL 1
;     L 0002			%THEN
;	0003				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE,
;	0004						NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT='X01.06') =
;	0007	
;	0008	BEGIN
;	0009	!
;	0010	!
;	0011	! Copyright (C) 1976,1977,1978
;	0012	! Digital Equipment Corporation,  Maynard, Massachusetts  01754
;	0013	!
;	0014	! This software is furnished under a license for use only on  a
;	0015	! single computer system and may be copied only with the inclu-
;	0016	! sion of the above copyright notice.  This  software,  or  any
;	0017	! other  copies  thereof, may not be provided or otherwise made
;	0018	! available to any other person except for use on  such  system
;	0019	! and  to  one who agrees to these license terms.  Title to and
;	0020	! ownership of the software shall at all times remain in DEC.
;	0021	!
;	0022	! The information in this software is subject to change without
;	0023	! notice and should not be construed as a commitment by Digital
;	0024	! Equipment Corporation.
;	0025	!
;	0026	! DEC assumes no responsibility for the use or  reliability  of
;	0027	! its software on equipment which is not supplied by DEC.
;	0028	!
;	0029	!
;	0030	!
;	0031	!
;	0032	!
;	0033	!++
;	0034	!
;	0035	! MODULE: DYNMEM
;	0036	!
;	0037	! FACILITY: PATCH
;	0038	!
;	0039	! ABSTRACT:  DYNAMIC MEMORY ALLOCATION AND DEALLOCATION
;	0040	!
;	0041	! HISTORY:
;	0042	!
;	0043	!	VERSION: X01.00
;	0044	!
;	0045	!	AUTHOR: T.J. PORTER 14-JAN-77
;	0046	!
;	0047	!	MODIFICATIONS:
;	0048	!
;	0049	! NO.	DATE		PROGRAMMER	PURPOSE
;	0050	! ---	----		----------	-------
;	0051	! 001	19-SEP-77	T.J. PORTER	REMEMBER THE HIGHEST ADDRESS ALLOCATED
;	0052	! 002	12-OCT-77	K.D. MORSE	ADAPT TO PATCH
;	0053	! 003	19-OCT-77	K.D. MORSE	ADD REQUIRE FILE VXSMAC.REQ
;	0054	! 004	18-NOV-77	K.D. MORSE	ADD REQUIRE FILE PATPCT.REQ
;	0055	! 005	25-APR-78	K.D. MORSE	CONVERT TO NATIVE COMPILER.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 1-1
; Digital Equipment Corporation
;
;	0056	! 006	13-JUN-78	K.D. MORSE	ADD FAO COUNTS TO SIGNALS.
;	0057	!
;	0058	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 2
; Digital Equipment Corporation
;
;	0059	!++
;	0060	!
;	0061	! FUNCTIONAL DESCRIPTION:
;	0062	!
;	0063	!	This module contains all the dynamic memory allocation
;	0064	!	and de-allocation logic for patch.  A singly
;	0065	!	linked list of free blocks of memory is maintained
;	0066	!	(listhead is pat$gl_memlhd) and memory is allocated
;	0067	!	by first fit.  Should there be no available memory block
;	0068	!	of required size, the allocation routine expands
;	0069	!	the program region by the number of pages equal to 
;	0070	!	PAT$K_MEMEXP, links this on the end of the free
;	0071	!	list and allocates the required memory from that new
;	0072	!	block.  The free memory list is therefore initialized
;	0073	!	on first allocation call.  Memory is always allocated
;	0074	!	in eight byte quanta, with a maximum of PAT$K_MEMEXP*512
;	0075	!	bytes.  Deallocation effects compaction whenever possible.
;	0076	!
;	0077	! CALLING SEQUENCES:
;	0078	!	PAT$ALLOBLK(BLOCKSIZE,BLOCKADDR)
;	0079	!	PAT$DEALBLK(BLOCKSIZE,BLOCKADDR)
;	0080	!		where:
;	0081	!		  BLOCKSIZE = number of bytes to be (de)allocated.
;	0082	!		  BLOCKADDR = address of cell for the address of
;	0083	!		              the block allocated or to be deallocated.
;	0084	! ERROR CONDITIONS:
;	0085	!
;	0086	!	1.  BLOCKSIZE < OR = 0 OR > PAT$K_MEMEXP*512 (CODE = 0,10)
;	0087	!
;	0088	!	2.  Failure to expand the program region issues a message
;	0089	!	    that memory is full and the linker aborts.
;	0090	!
;	0091	!	3.  Any part of a block to be deallocated is:
;	0092	!		(I) Within a free block (code = 2,13)
;	0093	!		(II) Beyond top of program region (code = 11)
;	0094	!		(III) Lower than than lowest block ever allocated (code = 12)
;	0095	!
;	0096	!	In cases 1 and 3 a fatal ("bug") message is issued and
;	0097	!		the patch terminates.
;	0098	!
;	0099	!--
;	0100	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 3
; Digital Equipment Corporation
;
;	0101	!
;	0102	! INCLUDE FILES:
;	0103	!
;	0104	
;	0105	LIBRARY 'SYS$LIBRARY:LIB.L32';				! Defines system structures and services
;	0106	REQUIRE 'SRC$:PREFIX.REQ';				! Defines useful macros
;	0289	REQUIRE 'LIB$:PATMSG.REQ';				! Define error codes
;	0447	REQUIRE 'SRC$:VXSMAC.REQ';				! Define TRUE and FALSE
;	0487	REQUIRE 'SRC$:PATPCT.REQ';				! Define PSECTS
;	0503	
;	0504	!
;	0505	! TABLE OF CONTENTS:
;	0506	!
;	0507	
;	0508	FORWARD ROUTINE
;	0509		PAT$ALLOBLK : NOVALUE,				! Allocation driver
;	0510		ALLOCATE,					! Allocation routine
;	0511		PAT$DEALBLK : NOVALUE,				! Deallocation driver
;	0512		DEALLOCATE;					! Deallocation routine
;	0513	
;	0514	!
;	0515	! EXTERNAL DATA
;	0516	!
;	0517	
;	0518	EXTERNAL
;	0519		PAT$GL_ISVADDR : VECTOR[,LONG],			! Contains starting and ending virtual addrs of last piece mapped
;	0520		PAT$GL_ERRCODE,					! Global error code
;	0521		PAT$GL_MEMLHD : VECTOR[,LONG],			! Free memory listhead
;	0522		PAT$GL_MINADDR;					! Lowest address ever allocated
;	0523	
;	0524	!
;	0525	! EQUATED SYMBOLS
;	0526	!
;	0527	
;	0528	EXTERNAL LITERAL
;	0529		PAT$K_MEMEXP,					! # of pages to extend program region
;	0530		PAT$K_MAXBLKSIZ;				! Maximum allocation size
;	0531	
;	0532	!
;	0533	! OWN STORAGE
;	0534	!
;	0535	
;	0536	OWN
;	0537		ERRORCODE : BYTE,				! Error code for failure message
;	0538		NEWBLOCK : REF VECTOR[2],			! Current block pointer
;	0539		NEXTBLOCK : REF VECTOR[2],			! Next block pointer
;	0540		LASTBLOCK : REF VECTOR[2];			! Previous block pointer

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 4
; Digital Equipment Corporation
;
;	0541	GLOBAL ROUTINE PAT$ALLOBLK(SIZE,BLOCKADDR):NOVALUE =
;	0542	!++
;	0543	!	Allocate a block from the free memory list.
;	0544	!--
;	0545	
;	0546	BEGIN
;	0547	
;	0548	LOCAL
;	0549		BLOCKSIZE;
;	0550	
;	0551	!++
;	0552	! Initialize local error code.
;	0553	!--
;	0554	ERRORCODE = 0;						! Initialize error code
;	0555	
;	0556	!++
;	0557	! Set size of block to allocate (round up to 8 bytes).
;	0558	!--
;	0559	BLOCKSIZE = (.SIZE + 7) AND ( NOT 7);			! Round up to multiple of 8 bytes
;	0560	
;	0561	!++
;	0562	! Now check for zero size block then allocate it.
;	0563	!--
;	0564	IF (.BLOCKSIZE EQL 0)					! Check legal block
;	0565	OR		 					! Size was requested
;	0566		.BLOCKSIZE GTRU PAT$K_MAXBLKSIZ
;	0567	OR NOT ( ERRORCODE = .ERRORCODE + 1;			! Set new error code
;	0568		ALLOCATE (.BLOCKSIZE, .BLOCKADDR))		! Go allocate
;	0569	THEN
;	0570		SIGNAL(PAT$_MEMBUG,1,.BLOCKSIZE,.BLOCKADDR,.ERRORCODE); ! Print error message and TERMINATE IF FAILURE
;	0571	RETURN;							! Otherwise return
;	0572	END;							! Of PAT$ALLOBLK routine


							    .TITLE  DYNMEM
							    .IDENT  \X01.06\

							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 ERRORCODE:
							    .BLKB   1
					      00001	    .BLKB   3
					      00004 NEWBLOCK:
							    .BLKB   4
					      00008 NEXTBLOCK:
							    .BLKB   4
					      0000C LASTBLOCK:
							    .BLKB   4

							    .GLOBL  PAT$GL_ISVADDR, PAT$GL_ERRCODE, PAT$GL_MEMLHD
							    .GLOBL  PAT$GL_MINADDR, PAT$K_MEMEXP, PAT$K_MAXBLKSIZ

							    .PSECT  _PAT$CODE,NOWRT,2

					 0804 00000 	    .ENTRY  PAT$ALLOBLK, Save R2,R11				      ; 0541

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 4-1
; Digital Equipment Corporation
;
		         5B 00000000'  EF  9E 00002 	    MOVAB   ERRORCODE, R11					      ;
				       6B  94 00009 	    CLRB    ERRORCODE						      ; 0554
	   50	    04   AC	       07  C1 0000B 	    ADDL3   #7, SIZE, R0					      ; 0559
	   52	         50	       07  CB 00010 	    BICL3   #7, R0, BLOCKSIZE					      ;
				       1A  13 00014 	    BEQL    1$							      ; 0564
	      00000000G  8F	       52  D1 00016 	    CMPL    BLOCKSIZE, #PAT$K_MAXBLKSIZ				      ; 0566
				       11  1A 0001D 	    BGTRU   1$							      ;
				       6B  96 0001F 	    INCB    ERRORCODE						      ; 0567
				  08   AC  DD 00021 	    PUSHL   BLOCKADDR						      ; 0568
				       52  DD 00024 	    PUSHL   BLOCKSIZE						      ;
	      00000000V  EF	       02  FB 00026 	    CALLS   #2, ALLOCATE					      ;
		         17	       50  E8 0002D 	    BLBS    R0, 2$						      ;
		         7E	       6B  9A 00030 1$:     MOVZBL  ERRORCODE, -(SP)					      ; 0570
				  08   AC  DD 00033 	    PUSHL   BLOCKADDR						      ;
				       52  DD 00036 	    PUSHL   BLOCKSIZE						      ;
				       01  DD 00038 	    PUSHL   #1							      ;
			    006D81B4   8F  DD 0003A 	    PUSHL   #7176628						      ;
	      00000000G  00	       05  FB 00040 	    CALLS   #5, LIB$SIGNAL					      ;
					   04 00047 2$:     RET     							      ; 0541

; Routine Size:  72 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 5
; Digital Equipment Corporation
;
;	0573	ROUTINE ALLOCATE (SIZE,ADDRESS) =
;	0574	!++
;	0575	!	Routine to do actual allocation and program
;	0576	!	region expansion
;	0577	!--
;	0578	
;	0579	BEGIN
;	0580	
;	0581	LASTBLOCK = PAT$GL_MEMLHD[0];				! Initially at top of free list
;	0582	
;	0583	!++
;	0584	! Check down free list for first block of equal or larger size.
;	0585	!--
;	0586	WHILE (NEWBLOCK = .LASTBLOCK[0])NEQ 0 DO		! Follow down free list
;	0587		BEGIN
;	0588		IF (.NEWBLOCK[1] EQL .SIZE)			! Look for suitable free block
;	0589		THEN BEGIN					! Exact size match
;	0590			LASTBLOCK[0] = .NEWBLOCK[0];		! so last points where this one pointed
;	0591			IF (.ADDRESS = NEWBLOCK[0]) LSSU .PAT$GL_MINADDR ! Now record lowest
;	0592			THEN PAT$GL_MINADDR = NEWBLOCK[0];	! Allocated address
;	0593			RETURN TRUE;				! And we are done
;	0594			END
;	0595		ELSE IF (.NEWBLOCK[1] GTRU .SIZE)			! Or one larger than requested
;	0596		THEN BEGIN
;	0597			NEXTBLOCK = NEWBLOCK[0]+.SIZE; 		! In which case there is a new
;	0598			NEXTBLOCK[0] = .NEWBLOCK[0];
;	0599			NEXTBLOCK[1] = .NEWBLOCK[1]-.SIZE; 	! Next block (the part remain-
;	0600			LASTBLOCK[0] = NEXTBLOCK[0];		! ing) after taking requested block off
;	0601			IF (.ADDRESS = NEWBLOCK[0]) LSSU .PAT$GL_MINADDR ! Now record lowest
;	0602			THEN PAT$GL_MINADDR = NEWBLOCK[0];	! Allocated address
;	0603			RETURN TRUE;				! And we are done
;	0604		     END
;	0605		ELSE LASTBLOCK = NEWBLOCK[0];			! When not suitable this block becomes previous block
;	0606		END;						! Of while loop
;	0607	
;	0608	!++
;	0609	!	At this point we have reached the end of the free
;	0610	!	memory list without finding a block of required size.
;	0611	!	Thus, we expand the address space and attempt to
;	0612	!	allocate from additional virtual memory.
;	0613	!--
;	0614	IF PAT$GL_ERRCODE=$EXPREG(PAGCNT=PAT$K_MEMEXP
;     P 0615				, RETADR=PAT$GL_ISVADDR)
;	0616								! Successfully expanded program region
;	0617	THEN BEGIN						! Deallocate new space to end of
;	0618		IF NOT DEALLOCATE(PAT$K_MAXBLKSIZ,.PAT$GL_ISVADDR[0],LASTBLOCK[0])
;	0619			THEN RETURN FALSE;
;	0620		IF NOT ALLOCATE(.SIZE,.ADDRESS)			! Free list then allocate from it
;	0621			THEN RETURN FALSE;
;	0622		RETURN TRUE;
;	0623	     END
;	0624								! Failure to expand program region
;	0625	ELSE SIGNAL(PAT$_EXPREG,1,.PAT$GL_ERRCODE);		! Is fatal
;	0626	END;							! Of allocate routine


; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 5-1
; Digital Equipment Corporation
;


							    .GLOBL  SYS$EXPREG

					 0F0C 00048 ALLOCATE:
							    .WORD   Save R2,R3,R8,R9,R10,R11				      ; 0573
		         58 00000000G  EF  9E 0004A 	    MOVAB   PAT$GL_ERRCODE, R8					      ;
		         59 00000000G  EF  9E 00051 	    MOVAB   PAT$GL_ISVADDR, R9					      ;
		         5A 00000000G  EF  9E 00058 	    MOVAB   PAT$GL_MINADDR, R10					      ;
		         5B 00000000'  EF  9E 0005F 	    MOVAB   LASTBLOCK, R11					      ;
		         6B 00000000G  EF  9E 00066 	    MOVAB   PAT$GL_MEMLHD, LASTBLOCK				      ; 0581
		         53	  04   AC  D0 0006D 	    MOVL    SIZE, R3						      ; 0588
		         52	       6B  D0 00071 1$:     MOVL    LASTBLOCK, R2					      ; 0586
		    F8   AB	       62  D0 00074 	    MOVL    (R2), NEWBLOCK					      ;
				       3D  13 00078 	    BEQL    5$							      ;
		         51	  F8   AB  D0 0007A 	    MOVL    NEWBLOCK, R1					      ; 0588
		         53	  04   A1  D1 0007E 	    CMPL    4(R1), R3						      ;
				       05  12 00082 	    BNEQ    2$							      ;
		         62	       61  D0 00084 	    MOVL    (R1), (R2)						      ; 0590
				       1B  11 00087 	    BRB     3$							      ; 0591
		         53	  04   A1  D1 00089 2$:     CMPL    4(R1), R3						      ; 0595
				       23  1B 0008D 	    BLEQU   4$							      ;
      FC   AB	         51	       53  C1 0008F 	    ADDL3   R3, R1, NEXTBLOCK					      ; 0597
		         50	  FC   AB  D0 00094 	    MOVL    NEXTBLOCK, R0					      ; 0598
		         60	       61  D0 00098 	    MOVL    (R1), (R0)						      ;
      04   A0	    04   A1	       53  C3 0009B 	    SUBL3   R3, 4(R1), 4(R0)					      ; 0599
		         62	       50  D0 000A1 	    MOVL    R0, (R2)						      ; 0600
		    08   BC	       51  D0 000A4 3$:     MOVL    R1, @ADDRESS					      ; 0601
		         6A	       51  D1 000A8 	    CMPL    R1, PAT$GL_MINADDR					      ;
				       42  1E 000AB 	    BGEQU   6$							      ;
		         6A	       51  D0 000AD 	    MOVL    R1, PAT$GL_MINADDR					      ; 0602
				       3D  11 000B0 	    BRB     6$							      ; 0603
		         6B	       51  D0 000B2 4$:     MOVL    R1, LASTBLOCK					      ; 0605
				       BA  11 000B5 	    BRB     1$							      ; 0586
				       7E  7C 000B7 5$:     CLRQ    -(SP)						      ; 0615
				       59  DD 000B9 	    PUSHL   R9							      ;
			    00000000G  8F  DD 000BB 	    PUSHL   #PAT$K_MEMEXP					      ;
	      00000000G  9F	       04  FB 000C1 	    CALLS   #4, @#SYS$EXPREG					      ;
		         68	       50  D0 000C8 	    MOVL    R0, PAT$GL_ERRCODE					      ; 0614
		         25	       50  E9 000CB 	    BLBC    R0, 7$						      ;
				       6B  DD 000CE 	    PUSHL   LASTBLOCK						      ; 0618
				       69  DD 000D0 	    PUSHL   PAT$GL_ISVADDR					      ;
			    00000000G  8F  DD 000D2 	    PUSHL   #PAT$K_MAXBLKSIZ					      ;
	      00000000V  EF	       03  FB 000D8 	    CALLS   #3, DEALLOCATE					      ;
		         22	       50  E9 000DF 	    BLBC    R0, 8$						      ;
				  08   AC  DD 000E2 	    PUSHL   ADDRESS						      ; 0620
				       53  DD 000E5 	    PUSHL   R3							      ;
		  FF5C   CF	       02  FB 000E7 	    CALLS   #2, ALLOCATE					      ;
		         15	       50  E9 000EC 	    BLBC    R0, 8$						      ;
		         50	       01  D0 000EF 6$:     MOVL    #1, R0						      ; 0622
					   04 000F2 	    RET     							      ;
				       68  DD 000F3 7$:     PUSHL   PAT$GL_ERRCODE					      ; 0625
				       01  DD 000F5 	    PUSHL   #1							      ;
			    006D8184   8F  DD 000F7 	    PUSHL   #7176580						      ;
	      00000000G  00	       03  FB 000FD 	    CALLS   #3, LIB$SIGNAL					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 5-2
; Digital Equipment Corporation
;
				       50  D4 00104 8$:     CLRL    R0							      ; 0573
					   04 00106 	    RET     							      ;

; Routine Size:  191 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 6
; Digital Equipment Corporation
;
;	0627	GLOBAL ROUTINE PAT$DEALBLK(SIZE,BLOCKADDR):NOVALUE =
;	0628	!++
;	0629	!	Routine to deallocate a block to the free
;	0630	!	memory list after checking its size
;	0631	!--
;	0632	
;	0633	BEGIN
;	0634	
;	0635	LOCAL
;	0636		BLOCKSIZE;
;	0637	
;	0638	!++
;	0639	! Initialize error code to deallocate routine.
;	0640	!--
;	0641	ERRORCODE = 10;						! Initialize error code
;	0642	
;	0643	!++
;	0644	! Round up the block size to the nearest quadword.
;	0645	!--
;	0646	BLOCKSIZE = (.SIZE + 7) AND ( NOT 7);			! Round up to a multiple of 8 bytes
;	0647	
;	0648	!++
;	0649	! Now search for place in free list to insert block.
;	0650	!--
;	0651	IF (.BLOCKSIZE EQL 0)					! Check block size is
;	0652	OR
;	0653	(.BLOCKSIZE GTRU PAT$K_MAXBLKSIZ)				! Legal and that it lies
;	0654	OR (ERRORCODE = .ERRORCODE + 1;				!
;	0655	(.BLOCKADDR + .BLOCKSIZE) ) GTRU CONTROL_REGION		! Completely within program region
;	0656									! and if not...
;	0657	OR (ERRORCODE = .ERRORCODE + 1;				! Issue fatal error message
;	0658	.BLOCKADDR LSSU .PAT$GL_MINADDR)			! Also if below minimum allocated address
;	0659	OR NOT DEALLOCATE(.BLOCKSIZE,.BLOCKADDR,PAT$GL_MEMLHD)	! Attempt deallocation
;	0660	THEN SIGNAL(PAT$_MEMBUG,1,.BLOCKSIZE,.BLOCKADDR,.ERRORCODE); ! Issuing fatal error if failure
;	0661	
;	0662	RETURN;							! Otherwise just return
;	0663	END;





					 0804 00107 	    .ENTRY  PAT$DEALBLK, Save R2,R11				      ; 0627
		         5B 00000000'  EF  9E 00109 	    MOVAB   ERRORCODE, R11					      ;
		         6B	       0A  90 00110 	    MOVB    #10, ERRORCODE					      ; 0641
	   50	    04   AC	       07  C1 00113 	    ADDL3   #7, SIZE, R0					      ; 0646
	   52	         50	       07  CB 00118 	    BICL3   #7, R0, BLOCKSIZE					      ;
				       3A  13 0011C 	    BEQL    1$							      ; 0651
	      00000000G  8F	       52  D1 0011E 	    CMPL    BLOCKSIZE, #PAT$K_MAXBLKSIZ				      ; 0653
				       31  1A 00125 	    BGTRU   1$							      ;
				       6B  96 00127 	    INCB    ERRORCODE						      ; 0654
	   50	    08   AC	       52  C1 00129 	    ADDL3   BLOCKSIZE, BLOCKADDR, R0				      ; 0655
	      40000000   8F	       50  D1 0012E 	    CMPL    R0, #1073741824					      ;
				       21  1A 00135 	    BGTRU   1$							      ;
				       6B  96 00137 	    INCB    ERRORCODE						      ; 0657

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 6-1
; Digital Equipment Corporation
;
	      00000000G  EF	  08   AC  D1 00139 	    CMPL    BLOCKADDR, PAT$GL_MINADDR				      ; 0658
				       15  1F 00141 	    BLSSU   1$							      ;
			    00000000G  EF  9F 00143 	    PUSHAB  PAT$GL_MEMLHD					      ; 0659
				  08   AC  DD 00149 	    PUSHL   BLOCKADDR						      ;
				       52  DD 0014C 	    PUSHL   BLOCKSIZE						      ;
	      00000000V  EF	       03  FB 0014E 	    CALLS   #3, DEALLOCATE					      ;
		         17	       50  E8 00155 	    BLBS    R0, 2$						      ;
		         7E	       6B  9A 00158 1$:     MOVZBL  ERRORCODE, -(SP)					      ; 0660
				  08   AC  DD 0015B 	    PUSHL   BLOCKADDR						      ;
				       52  DD 0015E 	    PUSHL   BLOCKSIZE						      ;
				       01  DD 00160 	    PUSHL   #1							      ;
			    006D81B4   8F  DD 00162 	    PUSHL   #7176628						      ;
	      00000000G  00	       05  FB 00168 	    CALLS   #5, LIB$SIGNAL					      ;
					   04 0016F 2$:     RET     							      ; 0627

; Routine Size:  105 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 7
; Digital Equipment Corporation
;
;	0664	ROUTINE DEALLOCATE(SIZE,ADDRESS,LISTHEAD) =
;	0665	!++
;	0666	!	Routine to put a block onto a list of free blocks,
;	0667	!	with maximal compaction
;	0668	!--
;	0669	
;	0670	BEGIN
;	0671	!++
;	0672	! Initialize search down the free list.
;	0673	!--
;	0674	LASTBLOCK = .LISTHEAD;					! Previous block initially the listhead
;	0675	NEWBLOCK = .ADDRESS;					! Current block is to be inserted
;	0676	
;	0677	!++
;	0678	! Now search the list for the place to insert the free block.
;	0679	!--
;	0680	WHILE (NEXTBLOCK = .LASTBLOCK[0])NEQ 0 DO		! Follow down free list till
;	0681	BEGIN							! The end, or till we reach
;	0682	IF NEWBLOCK[0] LEQU NEXTBLOCK[0]
;	0683	THEN
;	0684		BEGIN						! The position for insertion.
;	0685		IF NEWBLOCK[0]+.SIZE EQL NEXTBLOCK[0]
;	0686		THEN
;	0687			BEGIN					! Here we compact with next block
;	0688			NEWBLOCK[0] = .NEXTBLOCK[0];
;	0689			NEWBLOCK[1] = .NEXTBLOCK[1]+.SIZE;
;	0690			END
;	0691		ELSE
;	0692			BEGIN
;	0693			IF NEWBLOCK[0] + .SIZE GTRU NEXTBLOCK[0] ! If the block to deallocate
;	0694			THEN (ERRORCODE = .ERRORCODE + 1;	! Extends into next free block
;	0695				RETURN FALSE);			! And return failure
;	0696			NEWBLOCK[0] = NEXTBLOCK[0];		! Else set pointer and size since no
;	0697			NEWBLOCK[1] = .SIZE;			! Forward compaction needed
;	0698			END;
;	0699		IF NEWBLOCK[0] EQL LASTBLOCK[0]+.LASTBLOCK[1]
;	0700		THEN
;	0701			BEGIN					! Here we compact with previous
;	0702			LASTBLOCK[0] = .NEWBLOCK[0];		! Block
;	0703			LASTBLOCK[1] = .NEWBLOCK[1]+.LASTBLOCK[1];
;	0704			END
;	0705		ELSE							! No backward compaction but...
;	0706			BEGIN						! Must check that block to
;	0707			IF NEWBLOCK[0] LSSU LASTBLOCK[0] + .LASTBLOCK[1]
;	0708								! Deallocate is not partially in
;	0709				THEN (ERRORCODE = .ERRORCODE + 1; ! Previous hole -- failure if so
;	0710				     RETURN FALSE);
;	0711			LASTBLOCK[0] = NEWBLOCK[0];		! If ok previous points to new one.
;	0712			END;					! And we are done compacting
;	0713		RETURN TRUE;					! So return success.
;	0714		END
;	0715	ELSE
;	0716		LASTBLOCK = NEXTBLOCK[0];			! Not there yet so last block is one just tested
;	0717	END;							! Of while loop
;	0718	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 7-1
; Digital Equipment Corporation
;
;	0719	!++
;	0720	! The block to deallocate is beyond last hole
;	0721	!--
;	0722	IF NEWBLOCK[0] LSSU LASTBLOCK[0] + .LASTBLOCK[1]	! But if it starts within
;	0723	THEN (ERRORCODE = .ERRORCODE + 1;			! The last hole - fail it
;	0724			RETURN FALSE)
;	0725	ELSE
;	0726		BEGIN						! Otherwise check for compaction
;	0727		IF NEWBLOCK[0] EQL LASTBLOCK[0] + .LASTBLOCK[1]	! With last hole
;	0728		THEN LASTBLOCK[1] = .LASTBLOCK[1] + .SIZE	! And add in size if required
;	0729		ELSE
;	0730			BEGIN					! Otherwise just
;	0731			NEWBLOCK[0] = 0;			! Put on end of free list.
;	0732			NEWBLOCK[1] =.SIZE;
;	0733			LASTBLOCK[0] = NEWBLOCK[0];
;	0734			END;					! And all done
;	0735		RETURN TRUE;					! So return success
;	0736		END;
;	0737	END;							! Of routine





					 080C 00170 DEALLOCATE:
							    .WORD   Save R2,R3,R11					      ; 0664
		         5B 00000000'  EF  9E 00172 	    MOVAB   LASTBLOCK, R11					      ;
		         6B	  0C   AC  D0 00179 	    MOVL    LISTHEAD, LASTBLOCK					      ; 0674
		    F8   AB	  08   AC  D0 0017D 	    MOVL    ADDRESS, NEWBLOCK					      ; 0675
		         51	  F8   AB  D0 00182 	    MOVL    NEWBLOCK, R1					      ; 0682
		         50	       6B  D0 00186 1$:     MOVL    LASTBLOCK, R0					      ; 0680
		    FC   AB	       60  D0 00189 	    MOVL    (R0), NEXTBLOCK					      ;
				       4C  13 0018D 	    BEQL    6$							      ;
		         52	  FC   AB  D0 0018F 	    MOVL    NEXTBLOCK, R2					      ; 0682
		         52	       51  D1 00193 	    CMPL    R1, R2						      ;
				       3E  1A 00196 	    BGTRU   5$							      ;
	   53	         51	  04   AC  C1 00198 	    ADDL3   SIZE, R1, R3					      ; 0685
		         52	       53  D1 0019D 	    CMPL    R3, R2						      ;
				       0C  12 001A0 	    BNEQ    2$							      ;
		         61	       62  D0 001A2 	    MOVL    (R2), (R1)						      ; 0688
      04   A1	    04   A2	  04   AC  C1 001A5 	    ADDL3   SIZE, 4(R2), 4(R1)					      ; 0689
				       0D  11 001AC 	    BRB     3$							      ; 0685
		         52	       53  D1 001AE 2$:     CMPL    R3, R2						      ; 0693
				       35  1A 001B1 	    BGTRU   7$							      ;
		         61	       52  D0 001B3 	    MOVL    R2, (R1)						      ; 0696
		    04   A1	  04   AC  D0 001B6 	    MOVL    SIZE, 4(R1)						      ; 0697
	   52	         50	  04   A0  C1 001BB 3$:     ADDL3   4(R0), R0, R2					      ; 0699
		         52	       51  D1 001C0 	    CMPL    R1, R2						      ;
				       0A  12 001C3 	    BNEQ    4$							      ;
		         60	       61  D0 001C5 	    MOVL    (R1), (R0)						      ; 0702
		    04   A0	  04   A1  C0 001C8 	    ADDL2   4(R1), 4(R0)					      ; 0703
				       34  11 001CD 	    BRB     11$							      ; 0699
		         52	       51  D1 001CF 4$:     CMPL    R1, R2						      ; 0707
				       2C  1E 001D2 	    BGEQU   10$							      ;
				       12  11 001D4 	    BRB     7$							      ; 0709

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49	DBB3:[PATCH.SRC]DYNMEM.B32;7					Page 7-2
; Digital Equipment Corporation
;
		         6B	       52  D0 001D6 5$:     MOVL    R2, LASTBLOCK					      ; 0716
				       AB  11 001D9 	    BRB     1$							      ; 0680
		         50	       6B  D0 001DB 6$:     MOVL    LASTBLOCK, R0					      ; 0722
	   52	         50	  04   A0  C1 001DE 	    ADDL3   4(R0), R0, R2					      ;
		         52	       51  D1 001E3 	    CMPL    R1, R2						      ;
				       05  1E 001E6 	    BGEQU   8$							      ;
				  F4   AB  96 001E8 7$:     INCB    ERRORCODE						      ; 0723
				       1A  11 001EB 	    BRB     12$							      ; 0724
		         52	       51  D1 001ED 8$:     CMPL    R1, R2						      ; 0727
				       07  12 001F0 	    BNEQ    9$							      ;
		    04   A0	  04   AC  C0 001F2 	    ADDL2   SIZE, 4(R0)						      ; 0728
				       0A  11 001F7 	    BRB     11$							      ; 0727
				       61  D4 001F9 9$:     CLRL    (R1)						      ; 0731
		    04   A1	  04   AC  D0 001FB 	    MOVL    SIZE, 4(R1)						      ; 0732
		         60	       51  D0 00200 10$:    MOVL    R1, (R0)						      ; 0733
		         50	       01  D0 00203 11$:    MOVL    #1, R0						      ; 0735
					   04 00206 	    RET     							      ;
				       50  D4 00207 12$:    CLRL    R0							      ; 0664
					   04 00209 	    RET     							      ;

; Routine Size:  154 bytes


;	0738	END ELUDOM						! Of module




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$OWN       	    16    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$CODE      	   522  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582         4         0       224





; Size:		522 code + 16 data bytes
; Run Time:	00:22.2
; Elapsed Time:	00:36.6

; Bliss-32 7.352	Saturday 22-AUG-1978 03:00:49									Page 7-3
; Digital Equipment Corporation
;
; Memory Used:	325 pages
; Compilation Complete
