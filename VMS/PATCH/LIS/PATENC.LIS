
; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATENC (
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.16'
;	0007		      ) =
;	0008	BEGIN
;	0009	
;	0010	!++
;	0011	! Copyright (C) 1977,1978
;	0012	! Digital Equipment Corporation,  Maynard, Massachusetts  01754
;	0013	!
;	0014	! This software is furnished under a license for use only on  a
;	0015	! single computer system and may be copied only with the inclu-
;	0016	! sion of the above copyright notice.  This  software,  or  any
;	0017	! other  copies  thereof, may not be provided or otherwise made
;	0018	! available to any other person except for use on  such  system
;	0019	! and  to  one who agrees to these license terms.  Title to and
;	0020	! ownership of the software shall at all times remain in DEC.
;	0021	!
;	0022	! The information in this software is subject to change without
;	0023	! notice and should not be construed as a commitment by Digital
;	0024	! Equipment Corporation.
;	0025	!
;	0026	! DEC assumes no responsibility for the use or  reliability  of
;	0027	! its software on equipment which is not supplied by DEC.
;	0028	!
;	0029	!--
;	0030	
;	0031	!++
;	0032	! FACILITY:	PATCH
;	0033	!	VAX INSTRUCTION ENCODER.
;	0034	!
;	0035	! Version:	X01.16
;	0036	!
;	0037	! History:
;	0038	!	Author:
;	0039	!		Kevin Pammett, April 1977: Version 01
;	0040	!
;	0041	!
;	0042	! MODIFICATIONS:
;	0043	!
;	0044	!  NO	DATE		PROGRAMMER		PURPOSE
;	0045	!  --	----		----------		-------
;	0046	!
;	0047	!  00	20-OCT-77	K.D. MORSE		ADAPT VERSION 7 FOR PATCH
;	0048	!  01	9-DEC-77	K.D. MORSE		ADD SUBSTUTION FOR
;	0049	!						BRANCH INSTRUCTIONS.
;	0050	!  02	4-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 8-9.
;	0051	!						FIX BUG IN LOST SIGN BIT, I.E.,
;	0052	!						CHANGE GTR 63 TO GTRU 63. (10)
;	0053	!						NO CHANGES FOR VERS 11-12.
;	0054	!  03	24-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 13.
;	0055	!  04	16-MAR-78	K.D. MORSE		ALLOW SUBSTITUTION FOR

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 1-1
; Digital Equipment Corporation
;
;	0056	!						DISPLACEMENT AND DEFERRED
;	0057	!						DISPLACEMENT ADDRESSING.
;	0058	!  05	18-APR-78	K.D. MORSE		CHANGE LITERAL_TOKEN TO
;	0059	!						ABS_LIT_TOKEN TO AVOID CONFLICT
;	0060	!						WITH /LITERAL QUALIFIER IN GRAMMER.
;	0061	!  06	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0062	!  07	26-APR-78	K.D. MORSE		ADD CODE TO HANDLE ASSEMBLER
;	0063	!						DIRECTIVES: .BYTE, .WORD, .LONG.
;	0064	!  08	27-APR-78	K.D. MORSE		ADD ASSEMBLER DIRECTIVE TABLE SO THAT
;	0065	!						PATCH CAN OUTPUT ASSEMBLER
;	0066	!						DIRECTIVES CORRECTLY.
;	0067	!  09	02-MAY-78	K.D. MORSE		CHANGE CALLS TO PAT$GET_A_TOKEN
;	0068	!						TO CALL NEW ROUTINE MAR_GET_LEX.
;	0069	!  10	02-MAY-78	K.D. MORSE		ADD EXPRESSION HANDLER, GET_OPERAND.
;	0070	!						ALSO ADD ROUTINES ADD_LEX_T_OPRND
;	0071	!						AND PAT$REDUCE_INS.
;	0072	!  11	16-MAY-78	K.D. MORSE		ADD MORE SPECIFIC ERROR CODES (14).
;	0073	!  12	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 15-16.
;	0074	!  13	19-MAY-78	K.D. MORSE		ADD FORWARD REFERENCES TO
;	0075	!						UNDEFINED SYMBOLS.
;	0076	!  14	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0077	!  15	19-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 17-19.
;	0078	!  16	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 20-22.
;	0079	!
;	0080	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 2
; Digital Equipment Corporation
;
;	0081	FORWARD ROUTINE
;	0082		PAT$INS_ENCODE,						! Encode an instruction
;	0083		GET_NEXT_TOKEN,						! Extract next token from input stream.
;	0084		GET_LABEL : NOVALUE,					! Extracts a label from instruction string if one exists
;	0085		GET_OPCODE,						! Extract opcode from instruction string.
;	0086		GET_OPERAND,						! Acquires a lexical operand
;	0087		ENC_OPERAND,						! Encode an operand reference.
;	0088		ASSUME_AT_PC,						! Temporary 'look ahead' routine
;	0089									!  to implement <operand> ::= <number>
;	0090		INST_OUTPUT,						! Output bytes of instruction.
;	0091		OPCODE_MATCH,						! Find opcode in OPINFO table.
;	0092		MAR_GET_LEX,						! Gets a MARS lexeme
;	0093		ADD_LEX_T_OPRND : NOVALUE,				! Annexes a lexical string onto an operand string
;	0094		PAT$REDUCE_INS : NOVALUE,				! Reduces expressions and symbols in instructions for command output
;	0095		PAT$RESOLVE_INS : NOVALUE;				! Resolves forward references for command
;	0096	
;	0097	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0098	REQUIRE 'SRC$:SYSLIT.REQ';
;	0133	REQUIRE 'SRC$:VXSMAC.REQ';
;	0173	REQUIRE 'SRC$:PATGEN.REQ';
;	0352	REQUIRE 'SRC$:PATPCT.REQ';
;	0368	REQUIRE 'SRC$:PATTER.REQ';
;	0448	REQUIRE 'SRC$:PATTOK.REQ';
;	0494	REQUIRE 'SRC$:VAXOPS.REQ';					! Literals and macros related to opcodes
;	0656	REQUIRE 'LIB$:PATMSG.REQ';					! PATCH error reporting
;	0814	REQUIRE 'SRC$:SYSSER.REQ';					! Macros for diagnostic output.
;      R0822	SWITCHES LIST (SOURCE);
;      R0823	
;      R0824	EXTERNAL ROUTINE
;      R0825		PAT$fao_out;		! formats a line and outputs to the terminal
;      R0826	
;      R0827	SWITCHES LIST (NOSOURCE);
;	0872	REQUIRE 'SRC$:PREFIX.REQ';					! Define structure macro
;	1055	REQUIRE 'SRC$:PATPRE.REQ';					! Defines ASD structure
;	1195	REQUIRE 'SRC$:BSTRUC.REQ';
;	1246	REQUIRE 'SRC$:DLLNAM.REQ';
;	1279	
;	1280	EXTERNAL ROUTINE
;	1281		PAT$BUILD_PATH,						! Builds a path name structure
;	1282		PAT$DEFINE_SYM,						! Defines a user symbol
;	1283		PAT$FILL_BUF : NOVALUE,					! Routine to allocate and fill a buffer
;	1284		PAT$FIND_SYM,						! Find symbol in a doubly-linked symbol table
;	1285		PAT$FIND_VAL,						! Find value for symbol in a doubly-linked symbol table
;	1286		PAT$FREERELEASE : NOVALUE,				! Deallocates free storage
;	1287		PAT$FREEZ,						! Allocates and zeros some free storage
;	1288		PAT$SUBST_INS,						! Routine to create branch instruction substitutes
;	1289		PAT$CONV_R_50 : NOVALUE,
;	1290		SYS$FAOL : ADDRESSING_MODE(ABSOLUTE),			! System service to do formatted output
;	1291		PAT$FAO_PUT : NOVALUE,					! Formatted ASCII output
;	1292		PAT$MAR_GET_LEX,					! Lexical scanner
;	1293		PAT$OUT_PUT : NOVALUE,					! Actually write out lines to tty
;	1294		PAT$REG_MATCH;						! See if a char string is a reference
;	1295									!   to a register.
;	1296	
;	1297	EXTERNAL

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 2-1
; Digital Equipment Corporation
;
;	1298		PAT$GL_SYMTBPTR,					! Pointer to current symbol table listhead entry
;	1299		PAT$GL_OLDLABLS,					! Pointer to old label table listhead entry
;	1300		PAT$GL_TEMP_BUF : BLOCK[,BYTE],				! Temporary instruction buffer
;	1301		PAT$GL_BR_DISPL,					! Branch displacement that did not fit
;	1302		PAT$GL_CONTEXT : BITVECTOR,				! Context bits for PATCH commands
;	1303		PAT$GL_ERRCODE,						! Error code
;	1304		PAT$CP_OUT_STR : REF VECTOR[,BYTE],			! Points into output string
;	1305		PAT$GB_MOD_PTR : REF VECTOR[,BYTE],
;	1306		PAT$GB_OPINFO : BLOCKVECTOR[ MAXOPCODE, OPTSIZE, BYTE ],
;	1307		PAT$GL_BUF_SIZ,						! Data vector that describes opcodes
;	1308		PAT$GL_FWRLHD;						! Forward reference table listhead
;	1309	
;	1310	OWN
;	1311		BYTES_IN_OPRND;						! Number of encoded bytes in current operand
;	1312	
;	1313	LITERAL
;	1314		PAT$K_BR_RANGE = 2,					! Error code for branch displacement out of range
;	1315		MAX_REG		= 15,					! Maximum number of registers - 1
;	1316		MAX_BUF_SIZ	= 512,					! Maximum buffer size for pathname and operand string
;	1317	
;	1318	!++
;	1319	! Return values for routine GET_OPERAND.
;	1320	!--
;	1321		OPR_FOUND = 1,						! Operand found and successfully reduced
;	1322		NO_MORE_OPR = 0,					! No more operands
;	1323		OPR_ERROR = 2,						! Expression reduction error found in operand
;	1324		OPR_FORW_REF = 3,					! Forward reference inside operand
;	1325	
;	1326	!++
;	1327	! Bit masks for operand length indicators:  B^,W^,L^, and [.
;	1328	! Note that the masks for B^, W^ and L^ are also the number of bytes
;	1329	! to be included in the operand by these indicators.  [ always indicates
;	1330	! context indexed and always donates one additional byte.
;	1331	!--
;	1332	B_HAT_MASK = 1,							! B^ mask
;	1333	W_HAT_MASK = 2,							! W^ mask
;	1334	L_HAT_MASK = 4,							! L^ mask
;	1335	CONT_INDX_MASK = 8;						! Context indexed mask

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3
; Digital Equipment Corporation
;
;	1336	GLOBAL ROUTINE PAT$INS_ENCODE( INST_CS, OUT_BYTE_STREAM, OUT_PC, ASM_DIR_TBL, BUFFER_DSC ) =
;	1337	
;	1338	!++
;	1339	! 
;	1340	! FUNCTIONAL DESCRIPTION:
;	1341	!
;	1342	!	This routine examines an ascii stream which it is passed a pointer to,
;	1343	!	and tries to come up with the instruction byte stream this would
;	1344	!	correspond to.
;	1345	!
;	1346	! CALLING SEQUENCE:
;	1347	!
;	1348	!	PAT$INS_ENCODE ();
;	1349	!
;	1350	! INPUTS:
;	1351	!
;	1352	!	INST_CS		- A pointer to the counted string which
;	1353	!			the user input as the supposed intsruction.
;	1354	!
;	1355	!	OUT_BYTE_STREAM	- The address of where to put the
;	1356	!			  counted instruction stream genereated.
;	1357	!	OUT_PC		- The PC (memory address) where the instruction
;	1358	!			  will eventually reside.  This is used only for
;	1359	!			  PC-relative address calculations.
;	1360	!	ASM_DIR_TBL	- Address of descriptor for assembler directive table.
;	1361	!	BUFFER_DSC	- String descriptor for current encoded instruction buffer.
;	1362	!
;	1363	! IMPLICIT INPUTS:
;	1364	!
;	1365	!	PAT$GB_OPINFO	- Data vector which contains the instruction
;	1366	!			  mnemonics and related information.
;	1367	!
;	1368	! OUTPUTS:
;	1369	!
;	1370	!	The counted instruction (byte) stream is put in the byte vector
;	1371	!	pointed to by the input parameter.
;	1372	!
;	1373	! IMPLICIT OUTPUTS:
;	1374	!
;	1375	!	NONE.
;	1376	!
;	1377	! ROUTINE VALUE:
;	1378	!
;	1379	!	TRUE or FALSE, depending on whether the encoding
;	1380	!	'worked' or not.
;	1381	!
;	1382	! SIDE EFFECTS:
;	1383	!
;	1384	!	None.
;	1385	!
;	1386	!--
;	1387	
;	1388	BEGIN
;	1389	
;	1390	MAP

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-1
; Digital Equipment Corporation
;
;	1391		OUT_BYTE_STREAM : REF VECTOR[,BYTE],
;	1392		INST_CS : REF VECTOR[,BYTE],
;	1393		ASM_DIR_TBL : REF BLOCK[,BYTE],
;	1394		BUFFER_DSC : REF BLOCK[,BYTE];
;	1395	
;	1396	LOCAL
;	1397		COUNT,							! Count of bytes in encoded operand
;	1398		OPR_FLAG,						! Flag if operand found valid
;	1399		ASD_TBL_ENTRY : BLOCK[ASD$C_SIZE, BYTE],		! One entry in assembler directive table
;	1400		TOKEN,							! Next token from instruction
;	1401		ACT_NUM_OPRNDS,						! Actual number of operands processed
;	1402		PC_START,						! PC of start of instruction
;	1403		INSTR_STRING : VECTOR[NO_OF_INP_CHARS,BYTE],		! We make our own copy of the instruction
;	1404									! string so we don't have to worry about
;	1405									! overwriting parts of it.
;	1406		INST_STG_DESC : BLOCK [8, BYTE],			! Instruction string descriptor
;	1407		OPINFO_PTR : REF BLOCK[ OPTSIZE, BYTE],			! Pointer into the OPINFO table
;	1408		OUT_BYTE_PTR : REF VECTOR[,BYTE],			! This pointer contains the address
;	1409									!  of where each successive byte of 
;	1410									!  instruction is to be placed.
;	1411		BRANCH_SIZE,
;	1412		OPRNDS,							! Number of operands to expect.
;	1413		OPRND_STG_DESC : BLOCK[12,BYTE],			! String descriptor for next operand
;	1414		OPRND_BUF : VECTOR[MAX_BUF_SIZ,BYTE],			! Buffer to hold next operand
;	1415		OPCODE_NAME : REF VECTOR[,BYTE];			! Pointer to ascii opcode name of instruction
;	1416	
;	1417	LITERAL
;	1418		JMP_OPCODE = %X'17',					! JMP instruction opcode
;	1419		JSB_OPCODE = %X'16';					! JSB instruction opcode
;	1420	
;	1421	!++
;	1422	! Remember starting PC for instruction in case substitution is required.
;	1423	!--
;	1424	PC_START = .OUT_PC;
;	1425	
;	1426	!++
;	1427	! Copy the instruction string into a local area so that it won't be overwritten.
;	1428	! Then put a terminator at the end of it as this will make recognizing the EOS
;	1429	! easier for the scanner.  Also initialize the pointer to the return buffer.
;	1430	!--
;	1431	CH$MOVE( .INST_CS[0] +1, INST_CS[0], INSTR_STRING );
;	1432	INSTR_STRING [.INSTR_STRING [0] + 1] = 0;
;	1433	INSTR_STRING [0] = .INSTR_STRING [0] + 1;
;	1434	INST_STG_DESC [DSC$W_LENGTH] = .INSTR_STRING [0];
;	1435	INST_STG_DESC [DSC$A_POINTER] = INSTR_STRING [1];
;	1436	OUT_BYTE_PTR = OUT_BYTE_STREAM[1];
;	1437	
;	1438	!++
;	1439	! Check if there is a label on the instruction.  If so, GET_LABEL removes it
;	1440	! and enters it into the definition table.
;	1441	!--
;	1442	GET_LABEL(INST_STG_DESC, .OUT_PC, TRUE);
;	1443	
;	1444	!++
;	1445	! Extract the opcode mnemonic from the instruction string and encode the

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-2
; Digital Equipment Corporation
;
;	1446	! corresponding opcode into the output byte stream.  Pass the address of the
;	1447	! local, OPINFO_PTR, so that GET_OPCODE can initialize this.  This is done in
;	1448	! this way because it is GET_OPCODE who looks up the opcode (and hence finds
;	1449	! the OPINFO record), but it is here that the other OPINFO information is
;	1450	! needed.  GET_OPCODE does not return if the opcode is unrecognized.
;	1451	!--
;	1452	OPCODE_NAME = GET_OPCODE( INST_STG_DESC, .OUT_BYTE_PTR, OPINFO_PTR);
;	1453	
;	1454	!++
;	1455	! GET_OPCODE has stuffed the opcode into the instruction stream (for all MACRO
;	1456	! instructions but not assembler directives).  Update the pointer so that
;	1457	! further code will go into successive bytes.
;	1458	!--
;	1459	IF (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)
;	1460	THEN
;	1461		BEGIN
;	1462		OUT_BYTE_PTR = .OUT_BYTE_PTR + 1;
;	1463		OUT_PC = .OUT_PC +1;
;	1464	
;	1465		!++
;	1466		! The instruction-stream counted-string pointer now points to the
;	1467		! beginning of the operand reference string, if there is one.  This must
;	1468		! be the case unless this opcode has no operands.
;	1469		!--
;	1470		OPRNDS = .OPINFO_PTR [ OP_NUMOPS ];
;	1471		END
;	1472	ELSE
;	1473		!++
;	1474		! Set a large number of operands as it is unknown how many operands
;	1475		! an assembler directive may have.  Also set up an entry in the
;	1476		! assembler directive table.  This is for PATCH verification output to
;	1477		! the journal file.
;	1478		!--
;	1479		BEGIN
;	1480		OPRNDS = MAXOPRNDS - 1;
;	1481		ASD_TBL_ENTRY[ASD$L_PC] = .OUT_PC;
;	1482		ASD_TBL_ENTRY[ASD$L_OPINFO] = .OPINFO_PTR;
;	1483		ASD_TBL_ENTRY[ASD$B_NUM_OPRND] = 0;
;	1484		END;
;	1485	
;	1486	!++
;	1487	! Loop trying to extract each operand reference.
;	1488	!--
;	1489	ACT_NUM_OPRNDS = 1;
;	1490	WHILE .ACT_NUM_OPRNDS LEQ .OPRNDS
;	1491		DO
;	1492		BEGIN
;	1493		!++
;	1494		! Decide what type of branching the following routine will be allowed
;	1495		! to use, if any.  This is done now as the OPINFO information is
;	1496		! available.   For the same reason, the PC-relative context information
;	1497		! is passed.  Start by assuming the usual case.
;	1498		! All assembler directive operands are handled as a special case.
;	1499		! The number of bytes to be encoded is the OP_BR_TYPE value.
;	1500		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-3
; Digital Equipment Corporation
;
;	1501		BRANCH_SIZE = NO_BR;
;	1502		IF (.ACT_NUM_OPRNDS EQL .OPRNDS) OR (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
;	1503		THEN
;	1504			!++
;	1505			! Branching can only be considered for the last operand of an
;	1506			! instruction which has less than the maximum number of
;	1507			! operands.  This assumption was made in constructing the
;	1508			! data structure (OPINFO) from which encoding (and decoding)
;	1509			! works.  See PATINS.B32 for more information.
;	1510			!--
;	1511			IF (.ACT_NUM_OPRNDS LSS MAXOPRNDS) OR (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
;	1512			THEN
;	1513				BRANCH_SIZE = .OPINFO_PTR[OP_BR_TYPE];
;	1514	
;	1515		!++
;	1516		! Preprocess the operand, evaluating all expressions and symbols.
;	1517		!--
;	1518		OPRND_STG_DESC[DSC$W_LENGTH] = 0;
;	1519		OPRND_STG_DESC[DSC$A_POINTER] = OPRND_BUF;
;	1520		OPRND_STG_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
;	1521		IF NOT (OPR_FLAG = GET_OPERAND( INST_STG_DESC, OPRND_STG_DESC, TRUE))
;	1522		THEN
;	1523			BEGIN
;	1524			IF (.OPR_FLAG EQLU OPR_ERROR)
;	1525			THEN
;	1526				RETURN(FALSE);				! Invalid expression
;	1527			IF (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
;	1528			THEN
;	1529				EXITLOOP				! An assembler directive has indeterminate # of operands
;	1530			ELSE
;	1531				BEGIN
;	1532				SIGNAL(PAT$_INSOPRND+MSG$K_INFO);
;	1533				RETURN(FALSE);				! Insufficient operands
;	1534				END;
;	1535			END;
;	1536	
;	1537		!++
;	1538		! Check for forward referenced symbol.  If this is the case,
;	1539		! update the pointers past this operand and create an entry
;	1540		! in the ForWard Reference table for this operand.
;	1541		!--
;	1542		IF (.OPR_FLAG EQLU OPR_FORW_REF)
;	1543		THEN
;	1544			BEGIN
;	1545			LOCAL
;	1546				POINTER : REF BLOCK[,BYTE];
;	1547			POINTER = PAT$FREEZ((FWR$C_SIZE + A_LONGWORD -1)/A_LONGWORD);
;	1548			POINTER[FWR$L_FLINK] = .PAT$GL_FWRLHD;
;	1549			PAT$GL_FWRLHD = .POINTER;
;	1550			POINTER[FWR$L_PC] = .OUT_PC;
;	1551			POINTER[FWR$B_BUFOFF] = .BUFFER_DSC[DSC$W_LENGTH] +
;	1552						.OUT_BYTE_PTR - OUT_BYTE_STREAM[1];
;	1553			POINTER[FWR$W_OPRNDLNG] = .OPRND_STG_DESC[DSC$W_LENGTH];
;	1554			POINTER[FWR$A_OPRNDADR] = INST_CS[1] +
;	1555						(.OPRND_STG_DESC[DSC$A_POINTER] - INSTR_STRING[1]);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-4
; Digital Equipment Corporation
;
;	1556			POINTER[FWR$A_OPINFO] = .OPINFO_PTR;
;	1557			COUNT = 0;
;	1558			IF ((COUNT = .BYTES_IN_OPRND AND CONT_INDX_MASK) NEQ 0)
;	1559			THEN
;	1560				BEGIN
;	1561				COUNT = 1;
;	1562				BYTES_IN_OPRND = .BYTES_IN_OPRND - CONT_INDX_MASK;
;	1563				END;
;	1564			IF ((.OUT_BYTE_STREAM[1] EQL JMP_OPCODE) OR
;	1565			   (.OUT_BYTE_STREAM[1] EQL JSB_OPCODE))
;	1566			THEN
;	1567				BYTES_IN_OPRND = L_HAT_MASK;
;	1568			IF (.BRANCH_SIZE NEQ NO_BR)
;	1569			THEN
;	1570				COUNT = .BRANCH_SIZE
;	1571			ELSE
;	1572				COUNT = .COUNT + .BYTES_IN_OPRND + 1;
;	1573			POINTER[FWR$B_NUMBYTES] = .COUNT;
;	1574			POINTER[FWR$B_NTHOPRND] = .ACT_NUM_OPRNDS;
;	1575			OUT_PC = .OUT_PC + .COUNT;
;	1576			OUT_BYTE_PTR = .OUT_BYTE_PTR + .COUNT;
;	1577			OPRND_STG_DESC[DSC$W_LENGTH] = 0;
;	1578			END
;	1579		ELSE
;	1580			!++
;	1581			! Extract and encode one operand reference.  Give up if this fails.
;	1582			!--
;	1583			BEGIN
;	1584			IF NOT (PAT$GL_ERRCODE = ENC_OPERAND( OPRND_STG_DESC, OUT_BYTE_PTR,
;	1585					    1 ^ .OPINFO_PTR[ OP_CONTEXT(.ACT_NUM_OPRNDS) ],
;	1586					    .BRANCH_SIZE,  OUT_PC, .OPINFO_PTR))
;	1587			THEN
;	1588				BEGIN
;	1589				!++
;	1590				! "Operand Syntax" error.  If instruction substution is enabled,
;	1591				! then attempt to substitute other instructions for this branch
;	1592				! instruction.
;	1593				!--
;	1594				IF (.PAT$GL_ERRCODE EQL PAT$K_BR_RANGE) AND
;	1595				   (.PAT$GL_CONTEXT[INST_SUBST]) AND
;	1596				   (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)	! Don't substitute for assembler directives
;	1597				THEN
;	1598					BEGIN
;	1599					OUT_BYTE_STREAM[0] = .OUT_BYTE_PTR - OUT_BYTE_STREAM[1];
;	1600					PAT$SUBST_INS(.OUT_BYTE_STREAM, .PC_START);
;	1601					END;
;	1602				RETURN(FALSE);
;	1603				END;
;	1604			END;
;	1605	
;	1606		!++
;	1607		! Check that the operand was completely used. If not, error.
;	1608		!--
;	1609		IF (.OPRND_STG_DESC[DSC$W_LENGTH] NEQ 0)
;	1610		THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-5
; Digital Equipment Corporation
;
;	1611			RETURN(FALSE);
;	1612	
;	1613		ACT_NUM_OPRNDS = .ACT_NUM_OPRNDS + 1;
;	1614		END;
;	1615	
;	1616	!++
;	1617	! Check that there are not any extra operands.
;	1618	!--
;	1619	OPRND_STG_DESC[DSC$W_LENGTH] = 0;
;	1620	OPRND_STG_DESC[DSC$A_POINTER] = OPRND_BUF;
;	1621	OPRND_STG_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
;	1622	IF GET_OPERAND( INST_STG_DESC, OPRND_STG_DESC, TRUE)
;	1623	THEN
;	1624		BEGIN
;	1625		SIGNAL(PAT$_NUMOPRNDS+MSG$K_INFO, 2, .OPCODE_NAME, .OPRNDS); ! Too many operands
;	1626		RETURN(FALSE);
;	1627		END;
;	1628	
;	1629	!++
;	1630	! Calculate the number of bytes in the 'instruction' stream and copy this value
;	1631	! into the 0th byte of the output vector.  This makes it now a counted byte stream.
;	1632	!--
;	1633	OUT_BYTE_STREAM[0] = .OUT_BYTE_PTR - OUT_BYTE_STREAM[1];
;	1634	
;	1635	!++
;	1636	! Now if this was an assembler directive.  Compute the number of operands it
;	1637	! had and enter that into the assembler directive entry.  Then add this entry
;	1638	! to the assembler directive table.
;	1639	!--
;	1640	ACT_NUM_OPRNDS = .ACT_NUM_OPRNDS - 1;
;	1641	IF (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
;	1642	THEN
;	1643		BEGIN
;	1644		ASD_TBL_ENTRY[ASD$B_NUM_OPRND] = .ACT_NUM_OPRNDS;
;	1645		PAT$FILL_BUF(.ASM_DIR_TBL, ASD_TBL_ENTRY, ASD$C_SIZE);
;	1646		END;
;	1647	
;	1648	!++
;	1649	! This is the only place where this routine returns the OK completion status.
;	1650	! If some error was encountered, then a message was signaled and an
;	1651	! UNWIND or RETURN(FALSE) occurred.  The only exception is branch of
;	1652	! out of range.  In this case instruction substitution has been attempted.
;	1653	!--
;	1654	RETURN(TRUE);
;	1655	END;


							    .TITLE  PATENC
							    .IDENT  \X01.16\

							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 BYTES_IN_OPRND:
							    .BLKB   4


; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-6
; Digital Equipment Corporation
;
						    ISE$C_SIZE==	20
						    TXT$C_SIZE==	4
						    PAL$C_SIZE==	16
						    ASD$C_SIZE==	9
						    FWR$C_SIZE==	24
							    .GLOBL  PAT$FAO_OUT, PAT$BUILD_PATH, PAT$DEFINE_SYM, PAT$FILL_BUF
							    .GLOBL  PAT$FIND_SYM, PAT$FIND_VAL, PAT$FREERELEASE, PAT$FREEZ
							    .GLOBL  PAT$SUBST_INS, PAT$CONV_R_50, SYS$FAOL, PAT$FAO_PUT
							    .GLOBL  PAT$MAR_GET_LEX, PAT$OUT_PUT, PAT$REG_MATCH, PAT$GL_SYMTBPTR
							    .GLOBL  PAT$GL_OLDLABLS, PAT$GL_TEMP_BUF, PAT$GL_BR_DISPL
							    .GLOBL  PAT$GL_CONTEXT, PAT$GL_ERRCODE, PAT$CP_OUT_STR
							    .GLOBL  PAT$GB_MOD_PTR, PAT$GB_OPINFO, PAT$GL_BUF_SIZ
							    .GLOBL  PAT$GL_FWRLHD
							    .WEAK   ACCESS_CHECK

							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 00000 	    .ENTRY  PAT$INS_ENCODE, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11      ; 1336
		         5E	FD54   CE  9E 00002 	    MOVAB   -684(SP), SP					      ;
		         5B	  0C   AC  D0 00007 	    MOVL    OUT_PC, PC_START					      ; 1424
		         50	  04   BC  9A 0000B 	    MOVZBL  @INST_CS, R0					      ; 1431
				       50  D6 0000F 	    INCL    R0							      ;
    FF70   CD	    04   BC	       50  28 00011 	    MOVC3   R0, @INST_CS, INSTR_STRING				      ;
		         50	FF70   CD  9E 00018 	    MOVAB   INSTR_STRING, R0					      ; 1432
		         51	FF70   CD  9A 0001D 	    MOVZBL  INSTR_STRING, R1					      ;
		         50	       51  C0 00022 	    ADDL2   R1, R0						      ;
				  01   A0  94 00025 	    CLRB    1(R0)						      ;
				FF70   CD  96 00028 	    INCB    INSTR_STRING					      ; 1433
		  FF68   CD	FF70   CD  9B 0002C 	    MOVZBW  INSTR_STRING, INST_STG_DESC				      ; 1434
		  FF6C   CD	FF71   CD  9E 00033 	    MOVAB   INSTR_STRING+1, INST_STG_DESC+4			      ; 1435
	   56	    08   AC	       01  C1 0003A 	    ADDL3   #1, OUT_BYTE_STREAM, R6				      ; 1436
		         6E	       56  D0 0003F 	    MOVL    R6, OUT_BYTE_PTR					      ;
				       01  DD 00042 	    PUSHL   #1							      ; 1442
				  0C   AC  DD 00044 	    PUSHL   OUT_PC						      ;
				FF68   CD  9F 00047 	    PUSHAB  INST_STG_DESC					      ;
	      00000000V  EF	       03  FB 0004B 	    CALLS   #3, GET_LABEL					      ;
				  04   AE  9F 00052 	    PUSHAB  OPINFO_PTR						      ; 1452
				  04   AE  DD 00055 	    PUSHL   OUT_BYTE_PTR					      ;
				FF68   CD  9F 00058 	    PUSHAB  INST_STG_DESC					      ;
	      00000000V  EF	       03  FB 0005C 	    CALLS   #3, GET_OPCODE					      ;
		         5A	       50  D0 00063 	    MOVL    R0, OPCODE_NAME					      ;
		         55	  04   AE  D0 00066 	    MOVL    OPINFO_PTR, R5					      ; 1459
		         53	  04   A5  9E 0006A 	    MOVAB   4(R5), R3						      ;
	   63	         04	       00  EC 0006E 	    CMPV    #0, #4, (R3), #-2					      ;
			    FFFFFFFE   8F     00072									      ;
				       0C  13 00077 	    BEQL    1$							      ;
				       6E  D6 00079 	    INCL    OUT_BYTE_PTR					      ; 1462
				  0C   AC  D6 0007B 	    INCL    OUT_PC						      ; 1463
	   63	         04	       00  EE 0007E 	    EXTV    #0, #4, (R3), OPRNDS				      ; 1470
				       58     00082									      ;
				       0F  11 00083 	    BRB     2$							      ; 1459
		         58	       05  D0 00085 1$:     MOVL    #5, OPRNDS						      ; 1480
		    F4   AD	  0C   AC  D0 00088 	    MOVL    OUT_PC, ASD_TBL_ENTRY				      ; 1481
		    F8   AD	       55  D0 0008D 	    MOVL    R5, ASD_TBL_ENTRY+4					      ; 1482
				  FC   AD  94 00091 	    CLRB    ASD_TBL_ENTRY+8					      ; 1483

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-7
; Digital Equipment Corporation
;
		         54	       01  D0 00094 2$:     MOVL    #1, ACT_NUM_OPRNDS					      ; 1489
		         58	       54  D1 00097 3$:     CMPL    ACT_NUM_OPRNDS, OPRNDS				      ; 1490
				       03  15 0009A 	    BLEQ    5$							      ;
				     017B  31 0009C 4$:     BRW     19$							      ;
				       57  D4 0009F 5$:     CLRL    BRANCH_SIZE						      ; 1501
		         58	       54  D1 000A1 	    CMPL    ACT_NUM_OPRNDS, OPRNDS				      ; 1502
				       0B  13 000A4 	    BEQL    6$							      ;
	   63	         04	       00  EC 000A6 	    CMPV    #0, #4, (R3), #-2					      ;
			    FFFFFFFE   8F     000AA									      ;
				       15  12 000AF 	    BNEQ    8$							      ;
		         06	       54  D1 000B1 6$:     CMPL    ACT_NUM_OPRNDS, #6					      ; 1511
				       0B  19 000B4 	    BLSS    7$							      ;
	   63	         04	       00  EC 000B6 	    CMPV    #0, #4, (R3), #-2					      ;
			    FFFFFFFE   8F     000BA									      ;
				       05  12 000BF 	    BNEQ    8$							      ;
	   63	         04	       0C  EF 000C1 7$:     EXTZV   #12, #4, (R3), BRANCH_SIZE				      ; 1513
				       57     000C5									      ;
				FF5C   CD  B4 000C6 8$:     CLRW    OPRND_STG_DESC					      ; 1518
		  FF60   CD	  08   AE  9E 000CA 	    MOVAB   OPRND_BUF, OPRND_STG_DESC+4				      ; 1519
		  FF64   CD	0200   8F  B0 000D0 	    MOVW    #512, OPRND_STG_DESC+8				      ; 1520
				       01  DD 000D7 	    PUSHL   #1							      ; 1521
				FF5C   CD  9F 000D9 	    PUSHAB  OPRND_STG_DESC					      ;
				FF68   CD  9F 000DD 	    PUSHAB  INST_STG_DESC					      ;
	      00000000V  EF	       03  FB 000E1 	    CALLS   #3, GET_OPERAND					      ;
		         59	       50  D0 000E8 	    MOVL    R0, OPR_FLAG					      ;
		         20	       59  E8 000EB 	    BLBS    OPR_FLAG, 10$					      ;
		         02	       59  D1 000EE 	    CMPL    OPR_FLAG, #2					      ; 1524
				       18  13 000F1 	    BEQL    9$							      ;
	   63	         04	       00  EC 000F3 	    CMPV    #0, #4, (R3), #-2					      ; 1527
			    FFFFFFFE   8F     000F7									      ;
				       9E  13 000FC 	    BEQL    4$							      ;
			    006D82B3   8F  DD 000FE 	    PUSHL   #7176883						      ; 1532
	      00000000G  00	       01  FB 00104 	    CALLS   #1, LIB$SIGNAL					      ;
				     016F  31 0010B 9$:     BRW     23$							      ; 1533
		         03	       59  D1 0010E 10$:    CMPL    OPR_FLAG, #3					      ; 1542
				       03  13 00111 	    BEQL    11$							      ;
				     009B  31 00113 	    BRW     17$							      ;
				       06  DD 00116 11$:    PUSHL   #6							      ; 1547
	      00000000G  EF	       01  FB 00118 	    CALLS   #1, PAT$FREEZ					      ;
		         60 00000000G  EF  D0 0011F 	    MOVL    PAT$GL_FWRLHD, (POINTER)				      ; 1548
	      00000000G  EF	       50  D0 00126 	    MOVL    POINTER, PAT$GL_FWRLHD				      ; 1549
		    04   A0	  0C   AC  D0 0012D 	    MOVL    OUT_PC, 4(POINTER)					      ; 1550
		         51	  14   BC  3C 00132 	    MOVZWL  @BUFFER_DSC, R1					      ; 1551
		         51	       6E  C0 00136 	    ADDL2   OUT_BYTE_PTR, R1					      ;
      14   A0	         51	       56  C3 00139 	    SUBL3   R6, R1, 20(POINTER)					      ; 1552
		    08   A0	FF5C   CD  B0 0013E 	    MOVW    OPRND_STG_DESC, 8(POINTER)				      ; 1553
		         51	FF71   CD  9E 00144 	    MOVAB   INSTR_STRING+1, R1					      ; 1555
	   51	  FF60   CD	       51  C3 00149 	    SUBL3   R1, OPRND_STG_DESC+4, R1				      ;
		         51	  04   AC  C0 0014F 	    ADDL2   INST_CS, R1						      ; 1554
      0C   A0	         51	       01  C1 00153 	    ADDL3   #1, R1, 12(POINTER)					      ;
		    10   A0	       55  D0 00158 	    MOVL    R5, 16(POINTER)					      ; 1556
				       52  D4 0015C 	    CLRL    COUNT						      ; 1557
	   52 00000000'  EF FFFFFFF7   8F  CB 0015E 	    BICL3   #-9, BYTES_IN_OPRND, COUNT				      ; 1558
				       0A  13 0016A 	    BEQL    12$							      ;
		         52	       01  D0 0016C 	    MOVL    #1, COUNT						      ; 1561

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-8
; Digital Equipment Corporation
;
	      00000000'  EF	       08  C2 0016F 	    SUBL2   #8, BYTES_IN_OPRND					      ; 1562
		         17	       66  91 00176 12$:    CMPB    (R6), #23						      ; 1564
				       05  13 00179 	    BEQL    13$							      ;
		         16	       66  91 0017B 	    CMPB    (R6), #22						      ; 1565
				       07  12 0017E 	    BNEQ    14$							      ;
	      00000000'  EF	       04  D0 00180 13$:    MOVL    #4, BYTES_IN_OPRND					      ; 1567
				       57  D5 00187 14$:    TSTL    BRANCH_SIZE						      ; 1568
				       05  13 00189 	    BEQL    15$							      ;
		         52	       57  D0 0018B 	    MOVL    BRANCH_SIZE, COUNT					      ; 1570
				       0C  11 0018E 	    BRB     16$							      ; 1568
	   51	         52 00000000'  EF  C1 00190 15$:    ADDL3   BYTES_IN_OPRND, COUNT, R1				      ; 1572
	   52	         51	       01  C1 00198 	    ADDL3   #1, R1, COUNT					      ;
		    0A   A0	       52  90 0019C 16$:    MOVB    COUNT, 10(POINTER)					      ; 1573
		    0B   A0	       54  90 001A0 	    MOVB    ACT_NUM_OPRNDS, 11(POINTER)				      ; 1574
		    0C   AC	       52  C0 001A4 	    ADDL2   COUNT, OUT_PC					      ; 1575
		         6E	       52  C0 001A8 	    ADDL2   COUNT, OUT_BYTE_PTR					      ; 1576
				FF5C   CD  B4 001AB 	    CLRW    OPRND_STG_DESC					      ; 1577
				       5E  11 001AF 	    BRB     18$							      ; 1542
				       55  DD 001B1 17$:    PUSHL   R5							      ; 1584
				  0C   AC  9F 001B3 	    PUSHAB  OUT_PC						      ;
				       57  DD 001B6 	    PUSHL   BRANCH_SIZE						      ;
	   50	         54	       01  78 001B8 	    ASHL    #1, ACT_NUM_OPRNDS, R0				      ; 1585
		         50	       02  C0 001BC 	    ADDL2   #2, R0						      ;
	   63	         02	       50  EF 001BF 	    EXTZV   R0, #2, (R3), R1					      ;
				       51     001C3									      ;
	   7E	         01	       51  78 001C4 	    ASHL    R1, #1, -(SP)					      ;
				  10   AE  9F 001C8 	    PUSHAB  OUT_BYTE_PTR					      ; 1584
				FF5C   CD  9F 001CB 	    PUSHAB  OPRND_STG_DESC					      ;
	      00000000V  EF	       06  FB 001CF 	    CALLS   #6, ENC_OPERAND					      ;
	      00000000G  EF	       50  D0 001D6 	    MOVL    R0, PAT$GL_ERRCODE					      ;
		         2F	       50  E8 001DD 	    BLBS    R0, 18$						      ;
		         02 00000000G  EF  D1 001E0 	    CMPL    PAT$GL_ERRCODE, #2					      ; 1594
				       69  12 001E7 	    BNEQ    20$							      ;
	   61 00000000G  EF	       04  E1 001E9 	    BBC     #4, PAT$GL_CONTEXT+2, 20$				      ; 1595
	   63	         04	       00  EC 001F1 	    CMPV    #0, #4, (R3), #-2					      ; 1596
			    FFFFFFFE   8F     001F5									      ;
				       56  13 001FA 	    BEQL    20$							      ;
      08   BC	         6E	       56  83 001FC 	    SUBB3   R6, OUT_BYTE_PTR, @OUT_BYTE_STREAM			      ; 1599
				       5B  DD 00201 	    PUSHL   PC_START						      ; 1600
				  08   AC  DD 00203 	    PUSHL   OUT_BYTE_STREAM					      ;
	      00000000G  EF	       02  FB 00206 	    CALLS   #2, PAT$SUBST_INS					      ;
				       6E  11 0020D 	    BRB     23$							      ; 1602
				FF5C   CD  B5 0020F 18$:    TSTW    OPRND_STG_DESC					      ; 1609
				       68  12 00213 	    BNEQ    23$							      ;
				       54  D6 00215 	    INCL    ACT_NUM_OPRNDS					      ; 1613
				     FE7D  31 00217 	    BRW     3$							      ; 1490
				FF5C   CD  B4 0021A 19$:    CLRW    OPRND_STG_DESC					      ; 1619
		  FF60   CD	  08   AE  9E 0021E 	    MOVAB   OPRND_BUF, OPRND_STG_DESC+4				      ; 1620
		  FF64   CD	0200   8F  B0 00224 	    MOVW    #512, OPRND_STG_DESC+8				      ; 1621
				       01  DD 0022B 	    PUSHL   #1							      ; 1622
				FF5C   CD  9F 0022D 	    PUSHAB  OPRND_STG_DESC					      ;
				FF68   CD  9F 00231 	    PUSHAB  INST_STG_DESC					      ;
	      00000000V  EF	       03  FB 00235 	    CALLS   #3, GET_OPERAND					      ;
		         15	       50  E9 0023C 	    BLBC    R0, 21$						      ;
				       58  DD 0023F 	    PUSHL   OPRNDS						      ; 1625

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 3-9
; Digital Equipment Corporation
;
				       5A  DD 00241 	    PUSHL   OPCODE_NAME						      ;
				       02  DD 00243 	    PUSHL   #2							      ;
			    006D8263   8F  DD 00245 	    PUSHL   #7176803						      ;
	      00000000G  00	       04  FB 0024B 	    CALLS   #4, LIB$SIGNAL					      ;
				       29  11 00252 20$:    BRB     23$							      ; 1626
      08   BC	         6E	       56  83 00254 21$:    SUBB3   R6, OUT_BYTE_PTR, @OUT_BYTE_STREAM			      ; 1633
				       54  D7 00259 	    DECL    ACT_NUM_OPRNDS					      ; 1640
	   63	         04	       00  EC 0025B 	    CMPV    #0, #4, (R3), #-2					      ; 1641
			    FFFFFFFE   8F     0025F									      ;
				       13  12 00264 	    BNEQ    22$							      ;
		    FC   AD	       54  90 00266 	    MOVB    ACT_NUM_OPRNDS, ASD_TBL_ENTRY+8			      ; 1644
				       09  DD 0026A 	    PUSHL   #9							      ; 1645
				  F4   AD  9F 0026C 	    PUSHAB  ASD_TBL_ENTRY					      ;
				  10   AC  DD 0026F 	    PUSHL   ASM_DIR_TBL						      ;
	      00000000G  EF	       03  FB 00272 	    CALLS   #3, PAT$FILL_BUF					      ;
		         50	       01  D0 00279 22$:    MOVL    #1, R0						      ; 1654
					   04 0027C 	    RET     							      ;
				       50  D4 0027D 23$:    CLRL    R0							      ; 1336
					   04 0027F 	    RET     							      ;

; Routine Size:  640 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4
; Digital Equipment Corporation
;
;	1656	ROUTINE GET_NEXT_TOKEN ( INST_STG_DESC, LEX_BUFFER ) =
;	1657	
;	1658	!++
;	1659	! Functional Description:
;	1660	!
;	1661	!	Scan the input stream and extract the next token from it.  This routine
;	1662	!	is similar to the one that the parser uses - it is just that this one
;	1663	!	does a little more, and is a little more selective about what it accepts.
;	1664	!
;	1665	! Calling Sequence:
;	1666	!
;	1667	!	GET_NEXT_TOKEN (INST_STG_DESC, LEX_BUFFER)
;	1668	!
;	1669	! Inputs:
;	1670	!
;	1671	!	INST_CS_PTR	-Contains the address of the current instruction
;	1672	!			 counted-string pointer.  We pick up and update
;	1673	!			 this pointer via this address.
;	1674	!	LEX_BUFFER	-A pointer to where we can pass back a value
;	1675	!			 which is associated with whatever token we
;	1676	!			 discover.  If this value is 0, we don't
;	1677	!			 try to pass back anything.
;	1678	!
;	1679	! Implicit Inputs:
;	1680	!
;	1681	!	PAT$GL_MOD_PTR	- is used by the radix convert routine
;	1682	!			  to convert numeric input.
;	1683	!
;	1684	! Outputs:
;	1685	!
;	1686	!	None.
;	1687	!
;	1688	! Implicit Outputs:
;	1689	!
;	1690	!	Via LEX_BUFFER, we pass back:
;	1691	!			-a counted byte stream in LEX_BUFFER if the token
;	1692	!			 is LONG_VAL_TOKEN, WORD_VAL_TOKEN, ABS_LIT_TOKEN,
;	1693	!			 or BYTE_VAL_TOKEN.  Even though only <count> bytes
;	1694	!			 of this value are valid as far as operand size is
;	1695	!			 concerned, the value is written out as a (sign-extended)
;	1696	!			 longword so that we can do arithmetic on it and worry
;	1697	!			 about the size only when we want to extract it again.
;	1698	!			-a REGister number in a 1-byte field of LEX_BUFFER
;	1699	!			 for REGISTER_TOKEN, INDEXING_TOKEN, or AT_REG_TOKEN.
;	1700	!			-A 5-byte sequence for BRANCH_TOKEN.  The first byte
;	1701	!			 of this is 1 => PC-relative type, or 0 => absolute
;	1702	!			 type.  The remaining 4 bytes are the
;	1703	!			 longword representation of the branch operand.
;	1704	!
;	1705	! Return Value:
;	1706	!
;	1707	!	The literal that stands for the token type we have
;	1708	!	extracted.  This is either one of those mentioned
;	1709	!	above, or it is BAD_TOKEN.
;	1710	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-1
; Digital Equipment Corporation
;
;	1711	
;	1712	BEGIN
;	1713	
;	1714	MAP
;	1715		INST_STG_DESC : REF BLOCK [, BYTE],
;	1716		LEX_BUFFER : REF VECTOR[,BYTE];
;	1717	
;	1718	LOCAL
;	1719		LEX_STG_DESC : BLOCK [12, BYTE],			! Lexeme string descriptor
;	1720		TOKEN_BUFFER : VECTOR[ CHS_PER_LEXEME+1, BYTE ],
;	1721		GARBAGE : VECTOR[ CHS_PER_LEXEME, BYTE ],
;	1722		INST_CS : REF VECTOR[,BYTE],
;	1723		REG_NUM,
;	1724		MODE,
;	1725		RETURN_PTR,
;	1726		TOKEN_TYPE : BYTE;					! The returned value.
;	1727	
;	1728	MACRO
;	1729		PASS_BACK( BYTES, VALUE ) =				! Used to pass back the indicated
;     M 1730			(.RETURN_PTR)<0,BYTES*BITS_PER_BYTE> = VALUE %;	! number of bytes, if requested.
;	1731	
;	1732	!++
;	1733	! If a value is associated with the token extracted, this value is returned via
;	1734	! the pointer, LEX_BUFFER.  If, however, this pointer is 0, then the caller does
;	1735	! not want such information.  To avoid having to check this several times, then,
;	1736	! a local pointer, RETURN_PTR, is used to point either to where the user wants
;	1737	! the value, or to some local garbage location.
;	1738	!--
;	1739	IF ((RETURN_PTR = .LEX_BUFFER) EQL 0)
;	1740	THEN
;	1741		RETURN_PTR = GARBAGE;
;	1742	
;	1743	!++
;	1744	! Pick up the current instruction counted-string pointer.
;	1745	!--
;	1746	LEX_STG_DESC [DSC$W_LENGTH] = 0;
;	1747	LEX_STG_DESC [DSC$A_POINTER] = TOKEN_BUFFER;
;	1748	LEX_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME + 1;
;	1749	
;	1750	!++
;	1751	! Extract the next token and take the appropriate action.
;	1752	!--
;	1753	TOKEN_TYPE = MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC);
;	1754	
;	1755	!++
;	1756	! Sometimes a keyword token is returned when the user
;	1757	! really input a symbolic name of some sort.
;	1758	!--
;	1759	IF (.TOKEN_TYPE GTR 0) AND (.TOKEN_TYPE LEQ KEYWORD_RANGE)
;	1760	THEN
;	1761		TOKEN_TYPE = ALPHA_STR_TOKEN;
;	1762	TOKEN_TYPE = ( SELECTONE .TOKEN_TYPE OF
;	1763	
;	1764		SET
;	1765	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-2
; Digital Equipment Corporation
;
;	1766		[HASH_TOKEN]:	! '#'
;	1767			!++
;	1768			! Extract the literal and pass it back.
;	1769			!--
;	1770			IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ DIGIT_STR_TOKEN)
;	1771			THEN
;	1772				BAD_TOKEN
;	1773			ELSE
;	1774				BEGIN
;	1775				PASS_BACK (LONG_LENGTH, .(.LEX_STG_DESC [DSC$A_POINTER]));
;	1776				ABS_LIT_TOKEN
;	1777				END;
;	1778	
;	1779	
;	1780		[AT_SIGN_TOKEN,	! '@', For @#const, @(reg), and @displ(reg)
;	1781		 PLUS_TOKEN,	! '+', for (reg)+
;	1782		 MINUS_TOKEN,	! '-', For -(sp) Etc.
;	1783		 COMMA_TOKEN,	! ',', For arg1, arg2, Etc.
;	1784		 EOL_TOKEN ]:	!  LF, Terminates the command line.
;	1785			!++
;	1786			! Just return the token type directly.
;	1787			!--
;	1788			.TOKEN_TYPE;
;	1789	
;	1790	
;	1791		[DIGIT_STR_TOKEN,		! For branch operands where we interpret
;	1792						! the operand as an absolute address.
;	1793		 PERIOD_TOKEN]:			! We also handle operands of the
;	1794						! form '.' <sign> <number>, where
;	1795						! <sign> must be '+' or '-'.
;	1796	
;	1797			BEGIN
;	1798			LOCAL
;	1799				BR_FLAG,NUMBER;
;	1800	
;	1801			!++
;	1802			! In this case we build a token string consisting of a flag byte
;	1803			! followed by the branch operand in a longword.  Assume
;	1804			! PC-relative type branching.
;	1805			!--
;	1806			BR_FLAG = 1;
;	1807	
;	1808			!++
;	1809			! Handling the more-difficult syntax requires more work.
;	1810			!--
;	1811			IF (.TOKEN_TYPE EQL PERIOD_TOKEN)
;	1812			THEN
;	1813				BEGIN
;	1814				BR_FLAG = 0;
;	1815				TOKEN_BUFFER[0] = (
;	1816					IF ((TOKEN_TYPE = MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC)
;	1817							   ) EQL PLUS_TOKEN)
;	1818					THEN
;	1819						'+'
;	1820					ELSE

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-3
; Digital Equipment Corporation
;
;	1821						IF (.TOKEN_TYPE EQL MINUS_TOKEN )
;	1822						THEN
;	1823							'-'
;	1824						ELSE
;	1825							RETURN(BAD_TOKEN)
;	1826					);
;	1827	
;	1828				!++
;	1829				! After the <sign>, a <number> is expected.
;	1830				!--
;	1831				LEX_STG_DESC [DSC$A_POINTER] = TOKEN_BUFFER [1];
;	1832				IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ DIGIT_STR_TOKEN)
;	1833				THEN
;	1834					RETURN(BAD_TOKEN);
;	1835				END;
;	1836	
;	1837			!++
;	1838			! Pass back the flag and operand.
;	1839			!--
;	1840			NUMBER = .(.LEX_STG_DESC [DSC$A_POINTER]);
;	1841			IF (.TOKEN_BUFFER [0] EQL '-')
;	1842			THEN
;	1843				NUMBER = - .NUMBER;
;	1844			PASS_BACK(BYTE_LENGTH, .BR_FLAG);
;	1845			RETURN_PTR = .RETURN_PTR + BYTE_LENGTH;
;	1846			PASS_BACK(LONG_LENGTH, .number);
;	1847			BRANCH_TOKEN					! Pass back the token type
;	1848			END;
;	1849	
;	1850	
;	1851		[ALPHA_STR_TOKEN]:		! For now, this must be a register reference,
;	1852						! or a displacement indicator ("B", "W", or "L").
;	1853			BEGIN
;	1854			LOCAL
;	1855				LEXEME_PTR,
;	1856				CHAR;
;	1857	
;	1858			LEXEME_PTR = CH$PTR (.LEX_STG_DESC [DSC$A_POINTER]);
;	1859			CHAR = CH$RCHAR (.LEXEME_PTR);
;	1860			IF ((REG_NUM = PAT$REG_MATCH(LEX_STG_DESC)) GEQ 0)
;	1861			THEN
;	1862				BEGIN
;	1863				PASS_BACK(BYTE_LENGTH, .REG_NUM);	! Return the number of this register.
;	1864				IF (.REG_NUM LEQ MAX_REG)
;	1865				THEN
;	1866					REGISTER_TOKEN			! Valid register number
;	1867				ELSE
;	1868					BAD_TOKEN			! Invalid register number
;	1869				END
;	1870			ELSE IF (.LEX_STG_DESC [DSC$W_LENGTH] NEQ 1)
;	1871			THEN
;	1872				BAD_TOKEN	     		! Error.  The string must be only 1 CHARacter long.
;	1873			ELSE IF (.CHAR NEQ 'B') AND (.CHAR NEQ 'W') AND (.CHAR NEQ 'L')
;	1874			THEN
;	1875				!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-4
; Digital Equipment Corporation
;
;	1876				! The string must be one of the valid
;	1877				! displacement CHARacters only.
;	1878				!--
;	1879				BAD_TOKEN
;	1880	
;	1881	
;	1882			ELSE IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ UP_ARROW_TOKEN)
;	1883			THEN
;	1884				!++
;	1885				! <Size> must be followed by '^' to produce <size indicator>.
;	1886				!--
;	1887				BAD_TOKEN
;	1888			ELSE
;	1889				!++
;	1890				! Extract the following number and pass it back.
;	1891				! \This is where we would like to switch grammars
;	1892				!  to take advantage of what PATCH already
;	1893				!  knows about expression evaluation\.
;	1894				!--
;	1895				BEGIN
;	1896				IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ DIGIT_STR_TOKEN)
;	1897				THEN
;	1898					!++
;	1899					! The following token must be <number>.
;	1900					!--
;	1901					BAD_TOKEN
;	1902				ELSE
;	1903					BEGIN
;	1904					!++
;	1905					! See what displacement mode was requested.
;	1906					!--
;	1907					MODE = 0;
;	1908					IF (.CHAR EQL 'B')
;	1909					THEN
;	1910						MODE = BYTE_LENGTH;
;	1911					IF (.CHAR EQL 'W')
;	1912					THEN
;	1913						MODE = WORD_LENGTH;
;	1914					IF (.CHAR EQL 'L')
;	1915					THEN
;	1916						MODE = LONG_LENGTH;
;	1917					IF (.MODE EQL 0)
;	1918					THEN
;	1919						RETURN(BAD_TOKEN);
;	1920	
;	1921					!++
;	1922					! Return the number as a counted byte stream.
;	1923					! The <number> part of it is passed back as a
;	1924					! sign-extended longword so that it can be
;	1925					! checked for truncation.
;	1926					!--
;	1927					PASS_BACK(BYTE_LENGTH, .MODE);
;	1928					RETURN_PTR = .RETURN_PTR + BYTE_LENGTH;
;	1929					PASS_BACK(LONG_LENGTH, .(.LEX_STG_DESC [DSC$A_POINTER]));
;	1930					VAL_TOKEN + .MODE		! Return the token type.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-5
; Digital Equipment Corporation
;
;	1931					END
;	1932				END
;	1933			END;
;	1934	
;	1935	
;	1936		[OP_PAREN_TOKEN,		! ( reg ), ETC.
;	1937		 LSQUARE_TOKEN]:		! [ reg ], for INDEXing mode.
;	1938			!++
;	1939			! This case looks for an 'at register' reference or an indexing
;	1940			! mode indicator.  The reason why they are lumped together is
;	1941			! simply due their similarity.  The two tokens are in no
;	1942			! other way related.  The REGister number is passed back in the
;	1943			! 1st byte of LEX_BUFFER.
;	1944			!--
;	1945			IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ ALPHA_STR_TOKEN)
;	1946			THEN
;	1947				BAD_TOKEN				! No parens or brackets around register
;	1948			ELSE
;	1949			IF ((REG_NUM = PAT$REG_MATCH(LEX_STG_DESC)) LSS 0)
;	1950			THEN
;	1951				BAD_TOKEN				! Invalid register name
;	1952			ELSE
;	1953				!++
;	1954				! Make sure that the register is not PSL
;	1955				!--
;	1956				IF (.REG_NUM GTR MAX_REG)
;	1957				THEN
;	1958					BAD_TOKEN
;	1959				ELSE
;	1960					BEGIN
;	1961					!++
;	1962					! The next token must be a closing parenthesis
;	1963					! or square bracket.  If it is not, error.
;	1964					!--	
;	1965					IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC)
;	1966					    NEQ ( IF (.TOKEN_TYPE EQL OP_PAREN_TOKEN)
;	1967						  THEN
;	1968							CL_PAREN_TOKEN
;	1969						  ELSE
;	1970							RSQUARE_TOKEN
;	1971					        ))
;	1972					THEN
;	1973						BAD_TOKEN
;	1974					ELSE
;	1975						BEGIN
;	1976						!++
;	1977						! The operand was complete.  Return the
;	1978						! number and token type.
;	1979						!--
;	1980						PASS_BACK(BYTE_LENGTH, .REG_NUM);
;	1981		
;	1982						IF (.TOKEN_TYPE EQL OP_PAREN_TOKEN)
;	1983						THEN
;	1984							AT_REG_TOKEN
;	1985						ELSE

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-6
; Digital Equipment Corporation
;
;	1986							!++
;	1987							! You can't index off the PC
;	1988							!--	
;	1989							IF (.REG_NUM EQL PC_REG)
;	1990							THEN
;	1991								BAD_TOKEN
;	1992							ELSE
;	1993								INDEXING_TOKEN
;	1994						END
;	1995					END;
;	1996		
;	1997	
;	1998		[OTHERWISE]:			! ERROR.
;	1999						! Unrecognized token.  Terminate the encoding.
;	2000			BAD_TOKEN;
;	2001	
;	2002		TES);
;	2003	
;	2004	!++
;	2005	! Update the counted string pointer which is being maintained elsewhere.
;	2006	! The returned value is whatever was arrived at in the above CASE statement.
;	2007	!--
;	2008	RETURN (.TOKEN_TYPE);
;	2009	END;





					 0CFC 00280 GET_NEXT_TOKEN:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R10,R11			      ; 1656
		         5A 00000000G  EF  9E 00282 	    MOVAB   PAT$REG_MATCH, R10					      ;
		         5B 00000000V  EF  9E 00289 	    MOVAB   MAR_GET_LEX, R11					      ;
		         5E	       38  C2 00290 	    SUBL2   #56, SP						      ;
		         55	  08   AC  D0 00293 	    MOVL    LEX_BUFFER, RETURN_PTR				      ; 1739
				       03  12 00297 	    BNEQ    1$							      ;
		         55	       6E  9E 00299 	    MOVAB   GARBAGE, RETURN_PTR					      ; 1741
				  2C   AE  B4 0029C 1$:     CLRW    LEX_STG_DESC					      ; 1746
		    30   AE	  14   AE  9E 0029F 	    MOVAB   TOKEN_BUFFER, LEX_STG_DESC+4			      ; 1747
		    34   AE	       15  B0 002A4 	    MOVW    #21, LEX_STG_DESC+8					      ; 1748
				  2C   AE  9F 002A8 	    PUSHAB  LEX_STG_DESC					      ; 1753
		         56	  04   AC  D0 002AB 	    MOVL    INST_STG_DESC, R6					      ;
				       56  DD 002AF 	    PUSHL   R6							      ;
		         6B	       02  FB 002B1 	    CALLS   #2, MAR_GET_LEX					      ;
		         52	       50  90 002B4 	    MOVB    R0, TOKEN_TYPE					      ;
				       52  95 002B7 	    TSTB    TOKEN_TYPE						      ; 1759
				       09  1B 002B9 	    BLEQU   2$							      ;
		         31	       52  91 002BB 	    CMPB    TOKEN_TYPE, #49					      ;
				       04  1A 002BE 	    BGTRU   2$							      ;
		         52	  47   8F  90 002C0 	    MOVB    #71, TOKEN_TYPE					      ; 1761
		         57	       01  CE 002C4 2$:     MNEGL   #1, R7						      ; 1762
		    43   8F	       52  91 002C7 	    CMPB    TOKEN_TYPE, #67					      ;
				       1F  12 002CB 	    BNEQ    4$							      ;
				  2C   AE  9F 002CD 	    PUSHAB  LEX_STG_DESC					      ; 1770
				       56  DD 002D0 	    PUSHL   R6							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-7
; Digital Equipment Corporation
;
		         6B	       02  FB 002D2 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000048   8F	       50  D1 002D5 	    CMPL    R0, #72						      ;
				       03  13 002DC 	    BEQL    3$							      ;
				     01A3  31 002DE 	    BRW     31$							      ;
		         65	  30   BE  D0 002E1 3$:     MOVL    @LEX_STG_DESC+4, (RETURN_PTR)			      ; 1775
		         50	  F8   8F  9A 002E5 	    MOVZBL  #248, R0						      ; 1770
				     01A2  31 002E9 	    BRW     33$							      ; 1762
		         3D	       52  91 002EC 4$:     CMPB    TOKEN_TYPE, #61					      ;
				       18  13 002EF 	    BEQL    5$							      ;
		    41   8F	       52  91 002F1 	    CMPB    TOKEN_TYPE, #65					      ;
				       12  13 002F5 	    BEQL    5$							      ;
		    46   8F	       52  91 002F7 	    CMPB    TOKEN_TYPE, #70					      ;
				       0C  13 002FB 	    BEQL    5$							      ;
		    4C   8F	       52  91 002FD 	    CMPB    TOKEN_TYPE, #76					      ;
				       06  13 00301 	    BEQL    5$							      ;
		    63   8F	       52  91 00303 	    CMPB    TOKEN_TYPE, #99					      ;
				       05  12 00307 	    BNEQ    6$							      ;
		         57	       52  9A 00309 5$:     MOVZBL  TOKEN_TYPE, R7					      ;
				       6D  11 0030C 	    BRB     13$							      ;
		    48   8F	       52  91 0030E 6$:     CMPB    TOKEN_TYPE, #72					      ;
				       06  13 00312 	    BEQL    7$							      ;
		    4B   8F	       52  91 00314 	    CMPB    TOKEN_TYPE, #75					      ;
				       64  12 00318 	    BNEQ    14$							      ;
		         53	       01  D0 0031A 7$:     MOVL    #1, BR_FLAG						      ; 1806
		    4B   8F	       52  91 0031D 	    CMPB    TOKEN_TYPE, #75					      ; 1811
				       41  12 00321 	    BNEQ    11$							      ;
				       53  D4 00323 	    CLRL    BR_FLAG						      ; 1814
				  2C   AE  9F 00325 	    PUSHAB  LEX_STG_DESC					      ; 1816
				       56  DD 00328 	    PUSHL   R6							      ;
		         6B	       02  FB 0032A 	    CALLS   #2, MAR_GET_LEX					      ;
		         52	       50  90 0032D 	    MOVB    R0, TOKEN_TYPE					      ;
	      0000004C   8F	       50  D1 00330 	    CMPL    R0, #76						      ;
				       05  12 00337 	    BNEQ    8$							      ;
		         50	       2B  D0 00339 	    MOVL    #43, R0						      ; 1815
				       09  11 0033C 	    BRB     9$							      ;
		    46   8F	       52  91 0033E 8$:     CMPB    TOKEN_TYPE, #70					      ; 1821
				       1B  12 00342 	    BNEQ    10$							      ;
		         50	       2D  D0 00344 	    MOVL    #45, R0						      ;
		    14   AE	       50  90 00347 9$:     MOVB    R0, TOKEN_BUFFER					      ; 1815
		    30   AE	  15   AE  9E 0034B 	    MOVAB   TOKEN_BUFFER+1, LEX_STG_DESC+4			      ; 1831
				  2C   AE  9F 00350 	    PUSHAB  LEX_STG_DESC					      ; 1832
				       56  DD 00353 	    PUSHL   R6							      ;
		         6B	       02  FB 00355 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000048   8F	       50  D1 00358 	    CMPL    R0, #72						      ;
				       03  13 0035F 10$:    BEQL    11$							      ;
				     00B0  31 00361 	    BRW     22$							      ;
		         50	  30   BE  D0 00364 11$:    MOVL    @LEX_STG_DESC+4, NUMBER				      ; 1840
		         2D	  14   AE  91 00368 	    CMPB    TOKEN_BUFFER, #45					      ; 1841
				       03  12 0036C 	    BNEQ    12$							      ;
		         50	       50  CE 0036E 	    MNEGL   NUMBER, NUMBER					      ; 1843
		         85	       53  90 00371 12$:    MOVB    BR_FLAG, (RETURN_PTR)+				      ; 1844
		         65	       50  D0 00374 	    MOVL    NUMBER, (RETURN_PTR)				      ; 1846
		         57	  F4   8F  9A 00377 	    MOVZBL  #244, R7						      ; 1762
				     0119  31 0037B 13$:    BRW     35$							      ;
		    47   8F	       52  91 0037E 14$:    CMPB    TOKEN_TYPE, #71					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-8
; Digital Equipment Corporation
;
				       03  13 00382 	    BEQL    15$							      ;
				     00A0  31 00384 	    BRW     25$							      ;
		         50	  30   AE  D0 00387 15$:    MOVL    LEX_STG_DESC+4, LEXEME_PTR				      ; 1858
		         53	       60  9A 0038B 	    MOVZBL  (LEXEME_PTR), CHAR					      ; 1859
				  2C   AE  9F 0038E 	    PUSHAB  LEX_STG_DESC					      ; 1860
		         6A	       01  FB 00391 	    CALLS   #1, PAT$REG_MATCH					      ;
		         54	       50  D0 00394 	    MOVL    R0, REG_NUM						      ;
				       0E  19 00397 	    BLSS    16$							      ;
		         65	       54  90 00399 	    MOVB    REG_NUM, (RETURN_PTR)				      ; 1863
		         0F	       54  D1 0039C 	    CMPL    REG_NUM, #15					      ; 1864
				       47  14 0039F 	    BGTR    18$							      ;
		         50	  F7   8F  9A 003A1 	    MOVZBL  #247, R0						      ;
				       7E  11 003A5 	    BRB     24$							      ;
		         01	  2C   AE  B1 003A7 16$:    CMPW    LEX_STG_DESC, #1					      ; 1870
				       3B  12 003AB 	    BNEQ    18$							      ;
	      00000042   8F	       53  D1 003AD 	    CMPL    CHAR, #66						      ; 1873
				       12  13 003B4 	    BEQL    17$							      ;
	      00000057   8F	       53  D1 003B6 	    CMPL    CHAR, #87						      ;
				       09  13 003BD 	    BEQL    17$							      ;
	      0000004C   8F	       53  D1 003BF 	    CMPL    CHAR, #76						      ;
				       7A  12 003C6 	    BNEQ    27$							      ;
				  2C   AE  9F 003C8 17$:    PUSHAB  LEX_STG_DESC					      ; 1882
				       56  DD 003CB 	    PUSHL   R6							      ;
		         6B	       02  FB 003CD 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000053   8F	       50  D1 003D0 	    CMPL    R0, #83						      ;
				       69  12 003D7 	    BNEQ    27$							      ;
				  2C   AE  9F 003D9 	    PUSHAB  LEX_STG_DESC					      ; 1896
				       56  DD 003DC 	    PUSHL   R6							      ;
		         6B	       02  FB 003DE 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000048   8F	       50  D1 003E1 	    CMPL    R0, #72						      ;
				       58  12 003E8 18$:    BNEQ    27$							      ;
				       50  D4 003EA 	    CLRL    MODE						      ; 1907
	      00000042   8F	       53  D1 003EC 	    CMPL    CHAR, #66						      ; 1908
				       03  12 003F3 	    BNEQ    19$							      ;
		         50	       01  D0 003F5 	    MOVL    #1, MODE						      ; 1910
	      00000057   8F	       53  D1 003F8 19$:    CMPL    CHAR, #87						      ; 1911
				       03  12 003FF 	    BNEQ    20$							      ;
		         50	       02  D0 00401 	    MOVL    #2, MODE						      ; 1913
	      0000004C   8F	       53  D1 00404 20$:    CMPL    CHAR, #76						      ; 1914
				       03  12 0040B 	    BNEQ    21$							      ;
		         50	       04  D0 0040D 	    MOVL    #4, MODE						      ; 1916
				       50  D5 00410 21$:    TSTL    MODE						      ; 1917
				       05  12 00412 	    BNEQ    23$							      ;
		         50	  F9   8F  9A 00414 22$:    MOVZBL  #249, R0						      ; 1919
					   04 00418 	    RET     							      ;
		         85	       50  90 00419 23$:    MOVB    MODE, (RETURN_PTR)+					      ; 1927
		         65	  30   BE  D0 0041C 	    MOVL    @LEX_STG_DESC+4, (RETURN_PTR)			      ; 1929
		         50	00F1   C0  9E 00420 	    MOVAB   241(R0), R0						      ; 1930
				       67  11 00425 24$:    BRB     33$							      ; 1762
		    45   8F	       52  91 00427 25$:    CMPB    TOKEN_TYPE, #69					      ;
				       06  13 0042B 	    BEQL    26$							      ;
		    49   8F	       52  91 0042D 	    CMPB    TOKEN_TYPE, #73					      ;
				       60  12 00431 	    BNEQ    34$							      ;
				  2C   AE  9F 00433 26$:    PUSHAB  LEX_STG_DESC					      ; 1945
				       56  DD 00436 	    PUSHL   R6							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 4-9
; Digital Equipment Corporation
;
		         6B	       02  FB 00438 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000047   8F	       50  D1 0043B 	    CMPL    R0, #71						      ;
				       40  12 00442 27$:    BNEQ    31$							      ;
				  2C   AE  9F 00444 	    PUSHAB  LEX_STG_DESC					      ; 1949
		         6A	       01  FB 00447 	    CALLS   #1, PAT$REG_MATCH					      ;
		         54	       50  D0 0044A 	    MOVL    R0, REG_NUM						      ;
				       35  19 0044D 	    BLSS    31$							      ;
		         0F	       54  D1 0044F 	    CMPL    REG_NUM, #15					      ; 1956
				       30  14 00452 	    BGTR    31$							      ;
				  2C   AE  9F 00454 	    PUSHAB  LEX_STG_DESC					      ; 1965
				       56  DD 00457 	    PUSHL   R6							      ;
		         6B	       02  FB 00459 	    CALLS   #2, MAR_GET_LEX					      ;
		    49   8F	       52  91 0045C 	    CMPB    TOKEN_TYPE, #73					      ; 1966
				       05  12 00460 	    BNEQ    28$							      ;
		         51	       3F  D0 00462 	    MOVL    #63, R1						      ;
				       04  11 00465 	    BRB     29$							      ;
		         51	  50   8F  9A 00467 28$:    MOVZBL  #80, R1						      ;
		         51	       50  D1 0046B 29$:    CMPL    R0, R1						      ; 1965
				       14  12 0046E 	    BNEQ    31$							      ;
		         65	       54  90 00470 	    MOVB    REG_NUM, (RETURN_PTR)				      ; 1980
		    49   8F	       52  91 00473 	    CMPB    TOKEN_TYPE, #73					      ; 1982
				       06  12 00477 	    BNEQ    30$							      ;
		         50	  F6   8F  9A 00479 	    MOVZBL  #246, R0						      ;
				       0F  11 0047D 	    BRB     33$							      ;
		         0F	       54  D1 0047F 30$:    CMPL    REG_NUM, #15					      ; 1989
				       06  12 00482 	    BNEQ    32$							      ;
		         50	  F9   8F  9A 00484 31$:    MOVZBL  #249, R0						      ;
				       04  11 00488 	    BRB     33$							      ;
		         50	  F0   8F  9A 0048A 32$:    MOVZBL  #240, R0						      ;
		         57	       50  D0 0048E 33$:    MOVL    R0, R7						      ; 1762
				       04  11 00491 	    BRB     35$							      ;
		         57	  F9   8F  9A 00493 34$:    MOVZBL  #249, R7						      ;
		         52	       57  90 00497 35$:    MOVB    R7, TOKEN_TYPE					      ;
		         50	       52  9A 0049A 	    MOVZBL  TOKEN_TYPE, R0					      ; 2008
					   04 0049D 	    RET     							      ; 1656

; Routine Size:  542 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 5
; Digital Equipment Corporation
;
;	2010	ROUTINE GET_LABEL ( INST_STG_DESC, OUT_PC, DEFINE_FLAG ) : NOVALUE =
;	2011	
;	2012	!++
;	2013	! Functional Description:
;	2014	!
;	2015	!	Scan the supposed instruction string to see if it has a label.
;	2016	!	If there is a label, then extract it and the following colon and
;	2017	!	update the instruction string descriptor, INST_STG_DESC.  Then
;	2018	!	enter the label as an user defined symbol with a value equal to the
;	2019	!	current PC.
;	2020	!
;	2021	! Calling Sequence:
;	2022	!
;	2023	!	GET_LABEL (INST_STG_DESC, OUT_PC, DEFINE_FLAG)
;	2024	!
;	2025	! Inputs:
;	2026	!
;	2027	!	INST_STG_DESC	-A pointer to the counted string which contains
;	2028	!			 the instruction string we are working on.
;	2029	!	OUT_PC		-PC at which the instruction will reside
;	2030	!	DEFINE_FLAG	-Indicator if the label should be entered into the
;	2031	!			 user's symbol table. TRUE=enter it; FALSE=don't enter it
;	2032	!
;	2033	! Implicit Inputs:
;	2034	!
;	2035	!	none
;	2036	!
;	2037	! Outputs:
;	2038	!
;	2039	!	none
;	2040	!
;	2041	! Implicit Outputs:
;	2042	!
;	2043	!	The instruction string descriptor is updated to exclude the label and
;	2044	!	colon.  The symbol is entered into the user defined symbol table.
;	2045	!
;	2046	! Returned Value:
;	2047	!
;	2048	!	none
;	2049	!
;	2050	!--
;	2051	
;	2052	BEGIN
;	2053	
;	2054	MAP
;	2055		INST_STG_DESC : REF BLOCK [, BYTE];
;	2056	
;	2057	LOCAL
;	2058		CHAR,							! Next character in instruction string
;	2059		TOKEN_TYPE,						! Type of token found
;	2060		INS_PTR : REF VECTOR[,BYTE],				! Pointer to first byte of instruction
;	2061		INS_DESC : BLOCK[8,BYTE],				! Local copy of instruction string descriptor
;	2062		LABEL_DESC : BLOCK [12, BYTE],				! String descriptor for current token
;	2063		LABEL_BUF : VECTOR[ CHS_PER_LEXEME, BYTE];		! Buffer to hold label string
;	2064	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 5-1
; Digital Equipment Corporation
;
;	2065	!++
;	2066	! Initialize the local instruction string descriptor.  This routine uses
;	2067	! its own copy in case there is no label on the instruction.  Also initialize
;	2068	! the label string descriptor.
;	2069	!--
;	2070	INS_DESC [DSC$W_LENGTH] = .INST_STG_DESC[DSC$W_LENGTH];
;	2071	INS_DESC [DSC$A_POINTER] = .INST_STG_DESC[DSC$A_POINTER];
;	2072	LABEL_DESC [DSC$W_LENGTH] = 0;
;	2073	LABEL_DESC [DSC$A_POINTER] = LABEL_BUF;
;	2074	LABEL_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	2075	TOKEN_TYPE = MAR_GET_LEX(INS_DESC, LABEL_DESC);
;	2076	IF ((.TOKEN_TYPE NEQ ALPHA_STR_TOKEN) AND (.TOKEN_TYPE NEQ DIGIT_STR_TOKEN))
;	2077	THEN
;	2078		RETURN;							! No label
;	2079	INS_PTR = CH$PTR(.INS_DESC[DSC$A_POINTER], 0);
;	2080	DO
;	2081		CHAR = CH$RCHAR_A(INS_PTR)
;	2082	UNTIL ((.CHAR NEQU ' ') AND (.CHAR NEQU '	'));
;	2083	IF (.CHAR NEQU ':')
;	2084	THEN
;	2085		RETURN;							! No label
;	2086	
;	2087	!++
;	2088	! Now update the return instruction descriptor.
;	2089	!--
;	2090	INST_STG_DESC[DSC$W_LENGTH] = .INST_STG_DESC[DSC$W_LENGTH] - (.INS_PTR - .INST_STG_DESC[DSC$A_POINTER]);
;	2091	INST_STG_DESC[DSC$A_POINTER] = .INS_PTR;
;	2092	
;	2093	!++
;	2094	! Now define the label as an user symbol with a value of the current PC.
;	2095	!--
;	2096	PAT$DEFINE_SYM(LABEL_DESC, .OUT_PC, FALSE);
;	2097	RETURN;
;	2098	END;





					 0004 0049E GET_LABEL:
							    .WORD   Save R2						      ; 2010
		         5E	       28  C2 004A0 	    SUBL2   #40, SP						      ;
		         52	  04   AC  D0 004A3 	    MOVL    INST_STG_DESC, R2					      ; 2070
		    20   AE	       62  B0 004A7 	    MOVW    (R2), INS_DESC					      ;
		    24   AE	  04   A2  D0 004AB 	    MOVL    4(R2), INS_DESC+4					      ; 2071
				  14   AE  B4 004B0 	    CLRW    LABEL_DESC						      ; 2072
		    18   AE	       6E  9E 004B3 	    MOVAB   LABEL_BUF, LABEL_DESC+4				      ; 2073
		    1C   AE	       14  B0 004B7 	    MOVW    #20, LABEL_DESC+8					      ; 2074
				  14   AE  9F 004BB 	    PUSHAB  LABEL_DESC						      ; 2075
				  24   AE  9F 004BE 	    PUSHAB  INS_DESC						      ;
	      00000000V  EF	       02  FB 004C1 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000047   8F	       50  D1 004C8 	    CMPL    TOKEN_TYPE, #71					      ; 2076
				       09  13 004CF 	    BEQL    1$							      ;
	      00000048   8F	       50  D1 004D1 	    CMPL    TOKEN_TYPE, #72					      ;
				       31  12 004D8 	    BNEQ    3$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 5-2
; Digital Equipment Corporation
;
		         51	  24   AE  D0 004DA 1$:     MOVL    INS_DESC+4, INS_PTR					      ; 2079
		         50	       81  9A 004DE 2$:     MOVZBL  (INS_PTR)+, CHAR					      ; 2081
		         20	       50  D1 004E1 	    CMPL    CHAR, #32						      ; 2082
				       F8  13 004E4 	    BEQL    2$							      ;
		         09	       50  D1 004E6 	    CMPL    CHAR, #9						      ;
				       F3  13 004E9 	    BEQL    2$							      ;
		         3A	       50  D1 004EB 	    CMPL    CHAR, #58						      ; 2083
				       1B  12 004EE 	    BNEQ    3$							      ;
	   50	    04   A2	       51  C3 004F0 	    SUBL3   INS_PTR, 4(R2), R0					      ; 2090
		         62	       50  A0 004F5 	    ADDW2   R0, (R2)						      ;
		    04   A2	       51  D0 004F8 	    MOVL    INS_PTR, 4(R2)					      ; 2091
				       7E  D4 004FC 	    CLRL    -(SP)						      ; 2096
				  08   AC  DD 004FE 	    PUSHL   OUT_PC						      ;
				  1C   AE  9F 00501 	    PUSHAB  LABEL_DESC						      ;
	      00000000G  EF	       03  FB 00504 	    CALLS   #3, PAT$DEFINE_SYM					      ;
					   04 0050B 3$:     RET     							      ; 2010

; Routine Size:  110 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 6
; Digital Equipment Corporation
;
;	2099	ROUTINE GET_OPCODE ( INST_STG_DESC, OUT_BYTE_PTR, OPINFO_PTR ) =
;	2100	
;	2101	!++
;	2102	! Functional Description:
;	2103	!
;	2104	!	Scan the supposed instruction string to extract the opcode from it.  
;	2105	!
;	2106	! Calling Sequence:
;	2107	!
;	2108	!	GET_OPCODE (INST_STG_DESC, OUT_BYTE_PTR, OPINFO_PTR)
;	2109	!
;	2110	! Inputs:
;	2111	!
;	2112	!	INST_STG_DESC	-A pointer to the counted string which contains
;	2113	!			 the instruction string we are working on.
;	2114	!	OUT_BYTE_PTR	-The address of where we should stuff the
;	2115	!			 opcode if we find a valid one.
;	2116	!	OPINFO_PTR	-A pointer to where we should stuff the address
;	2117	!			 of the OPINFO record which we find as a match
;	2118	!			 to the opcode we extract from the instruction string.
;	2119	!
;	2120	! Implicit Inputs:
;	2121	!
;	2122	!	The OPINFO data structure which is described in PATINS.B32
;	2123	!
;	2124	! Outputs:
;	2125	!
;	2126	!	None other than via the parameters given above.
;	2127	!
;	2128	! Implicit Outputs:
;	2129	!
;	2130	!	None.
;	2131	!
;	2132	! Returned Value:
;	2133	!
;	2134	!	A pointer to a counted string (built by this routine) which is the
;	2135	!	name of the opcode.  If the opcode is invalid, an error message is
;	2136	!	SIGNALed and there is no return.
;	2137	!--
;	2138	
;	2139	BEGIN
;	2140	
;	2141	MAP
;	2142		OPINFO_PTR : REF VECTOR[,LONG],				! Pointer into the OPINFO table
;	2143		OUT_BYTE_PTR : REF VECTOR[,BYTE],
;	2144		INST_STG_DESC : REF BLOCK [, BYTE];
;	2145	
;	2146	!  The following BIND works, but causes the compiler
;	2147	! to croak from time to time.  Once this
;	2148	! works ok, put back in the '!' lines,
;	2149	! and remove the lines flagged '*** Temporary'.
;	2150	!	BIND
;	2151	!		OPINFO_RECORD = (.OPINFO_PTR) : REF BLOCK[ OPTSIZE,BYTE ];
;	2152	
;	2153	OWN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 6-1
; Digital Equipment Corporation
;
;	2154		OPCODE_NAME : VECTOR[8,BYTE];				! Buffer to hold opcode string
;	2155	LOCAL
;	2156		OPINFO_RECORD : REF BLOCK[ OPTSIZE,BYTE];		! *** Temporary
;	2157	
;	2158	LOCAL
;	2159		TOKEN_TYPE,
;	2160		OPCODE,							! Numeric Opcode.
;	2161		OPCO_STG_DESC : BLOCK [12, BYTE],
;	2162		USER_OPCODE : VECTOR[ CHS_PER_LEXEME, BYTE];
;	2163	
;	2164	!++
;	2165	! Make sure that the first token is a potential opcode.
;	2166	!--
;	2167	OPCO_STG_DESC [DSC$W_LENGTH] = 0;
;	2168	OPCO_STG_DESC [DSC$A_POINTER] = USER_OPCODE;
;	2169	OPCO_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	2170	IF ((TOKEN_TYPE = MAR_GET_LEX(.INST_STG_DESC, OPCO_STG_DESC)) NEQ ALPHA_STR_TOKEN)
;	2171	THEN
;	2172		IF (.TOKEN_TYPE GTR KEYWORD_RANGE)
;	2173		THEN
;	2174			SIGNAL(PAT$_BADOPCODE+MSG$K_WARN, 2, .OPCO_STG_DESC[DSC$W_LENGTH],
;	2175				.OPCO_STG_DESC[DSC$A_POINTER]);	! No return
;	2176	
;	2177	!++
;	2178	! Look in the opcode table for a match to this string.
;	2179	!--
;	2180	IF ((OPCODE = OPCODE_MATCH( OPCO_STG_DESC, .OPINFO_PTR)) LSS 0)
;	2181	THEN
;	2182		SIGNAL(PAT$_BADOPCODE+MSG$K_WARN, 2, .OPCO_STG_DESC[DSC$W_LENGTH], .OPCO_STG_DESC[DSC$A_POINTER]); ! No return
;	2183	
;	2184	!++
;	2185	! Found it.  Put the opcode byte into the instruction stream being built, unless
;	2186	! there is insufficient information to continue.  This only happens when the
;	2187	! opcode is reserved, because PATCH does not know how many operands to expect.
;	2188	! If this is an assembler directive, then don't try to put an opcode into
;	2189	! the byte stream.  Just return successfully.
;	2190	!--
;	2191	OPINFO_RECORD = ..OPINFO_PTR;					!  *** Temporary
;	2192	IF (.OPINFO_RECORD[OP_NUMOPS] EQL NOT_AN_OP)
;	2193	THEN
;	2194		SIGNAL(PAT$_RESOPCODE+MSG$K_WARN, 2, .OPCO_STG_DESC[DSC$W_LENGTH], .OPCO_STG_DESC[DSC$A_POINTER]); ! No return
;	2195	IF (.OPINFO_RECORD[OP_NUMOPS] NEQ ASM_DIR_OP)
;	2196	THEN
;	2197		OUT_BYTE_PTR[0] = .OPCODE;
;	2198	
;	2199	!++
;	2200	! Build a counted string which contains the name of the opcode for possible
;	2201	! use later in error reporting.  Return a pointer to this string as the
;	2202	! result of this routine.
;	2203	!--
;	2204	CH$MOVE(.OPCO_STG_DESC[DSC$W_LENGTH], .OPCO_STG_DESC[DSC$A_POINTER],
;	2205			OPCODE_NAME[1]);
;	2206	OPCODE_NAME[0] = .OPCO_STG_DESC[DSC$W_LENGTH];
;	2207	RETURN(.OPCODE_NAME);
;	2208	END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 6-2
; Digital Equipment Corporation
;



							    .PSECT  _PAT$OWN,NOEXE,2

					      00004 OPCODE_NAME:
							    .BLKB   8



							    .PSECT  _PAT$CODE,NOWRT,2

					 0C3C 0050C GET_OPCODE:
							    .WORD   Save R2,R3,R4,R5,R10,R11				      ; 2099
		         5A 00000000'  EF  9E 0050E 	    MOVAB   OPCODE_NAME, R10					      ;
		         5B 00000000G  00  9E 00515 	    MOVAB   LIB$SIGNAL, R11					      ;
		         5E	       20  C2 0051C 	    SUBL2   #32, SP						      ;
				  14   AE  B4 0051F 	    CLRW    OPCO_STG_DESC					      ; 2167
		    18   AE	       6E  9E 00522 	    MOVAB   USER_OPCODE, OPCO_STG_DESC+4			      ; 2168
		    1C   AE	       14  B0 00526 	    MOVW    #20, OPCO_STG_DESC+8				      ; 2169
				  14   AE  9F 0052A 	    PUSHAB  OPCO_STG_DESC					      ; 2170
				  04   AC  DD 0052D 	    PUSHL   INST_STG_DESC					      ;
	      00000000V  EF	       02  FB 00530 	    CALLS   #2, MAR_GET_LEX					      ;
	      00000047   8F	       50  D1 00537 	    CMPL    TOKEN_TYPE, #71					      ;
				       17  13 0053E 	    BEQL    1$							      ;
		         31	       50  D1 00540 	    CMPL    TOKEN_TYPE, #49					      ; 2172
				       12  15 00543 	    BLEQ    1$							      ;
				  18   AE  DD 00545 	    PUSHL   OPCO_STG_DESC+4					      ; 2174
		         7E	  18   AE  3C 00548 	    MOVZWL  OPCO_STG_DESC, -(SP)				      ;
				       02  DD 0054C 	    PUSHL   #2							      ;
			    006D8238   8F  DD 0054E 	    PUSHL   #7176760						      ;
		         6B	       04  FB 00554 	    CALLS   #4, LIB$SIGNAL					      ;
				  0C   AC  DD 00557 1$:     PUSHL   OPINFO_PTR						      ; 2180
				  18   AE  9F 0055A 	    PUSHAB  OPCO_STG_DESC					      ;
	      00000000V  EF	       02  FB 0055D 	    CALLS   #2, OPCODE_MATCH					      ;
		         53	       50  D0 00564 	    MOVL    R0, OPCODE						      ;
				       12  18 00567 	    BGEQ    2$							      ;
				  18   AE  DD 00569 	    PUSHL   OPCO_STG_DESC+4					      ; 2182
		         7E	  18   AE  3C 0056C 	    MOVZWL  OPCO_STG_DESC, -(SP)				      ;
				       02  DD 00570 	    PUSHL   #2							      ;
			    006D8238   8F  DD 00572 	    PUSHL   #7176760						      ;
		         6B	       04  FB 00578 	    CALLS   #4, LIB$SIGNAL					      ;
		         52	  0C   BC  D0 0057B 2$:     MOVL    @OPINFO_PTR, OPINFO_RECORD				      ; 2191
      04   A2	         04	       00  EC 0057F 	    CMPV    #0, #4, 4(OPINFO_RECORD), #-1			      ; 2192
			    FFFFFFFF   8F     00584									      ;
				       12  12 00589 	    BNEQ    3$							      ;
				  18   AE  DD 0058B 	    PUSHL   OPCO_STG_DESC+4					      ; 2194
		         7E	  18   AE  3C 0058E 	    MOVZWL  OPCO_STG_DESC, -(SP)				      ;
				       02  DD 00592 	    PUSHL   #2							      ;
			    006D8240   8F  DD 00594 	    PUSHL   #7176768						      ;
		         6B	       04  FB 0059A 	    CALLS   #4, LIB$SIGNAL					      ;
      04   A2	         04	       00  EC 0059D 3$:     CMPV    #0, #4, 4(OPINFO_RECORD), #-2			      ; 2195
			    FFFFFFFE   8F     005A2									      ;
				       04  13 005A7 	    BEQL    4$							      ;
		    08   BC	       53  90 005A9 	    MOVB    OPCODE, @OUT_BYTE_PTR				      ; 2197

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 6-3
; Digital Equipment Corporation
;
      01   AA	    18   BE	  14   AE  28 005AD 4$:     MOVC3   OPCO_STG_DESC, @OPCO_STG_DESC+4, OPCODE_NAME+1	      ; 2204
		         6A	  14   AE  90 005B4 	    MOVB    OPCO_STG_DESC, OPCODE_NAME				      ; 2206
		         50	       6A  D0 005B8 	    MOVL    OPCODE_NAME, R0					      ; 2207
					   04 005BB 	    RET     							      ; 2099

; Routine Size:  176 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7
; Digital Equipment Corporation
;
;	2209	ROUTINE GET_OPERAND ( INS_STG_DESC, OPRND_STG_DESC, USER_SYM_FLAG ) =
;	2210	
;	2211	!++
;	2212	! Functional Description:
;	2213	!
;	2214	!	This routine scans the input stream and extracts the next operand from
;	2215	!	it.  During this scan, all expressions and symbolic names are evaluated.
;	2216	!	The resultant "operand" string is placed in the buffer pointed to by
;	2217	!	OPRND_STG_DESC.  This string can then be encoded by ENC_OPERAND into
;	2218	!	a binary operand for the instruction.
;	2219	!
;	2220	! Calling Sequence:
;	2221	!
;	2222	!	GET_OPERAND (INS_STG_DESC, OPRND_STG_DESC, USER_SYM_FLAG)
;	2223	!
;	2224	! Inputs:
;	2225	!
;	2226	!	INS_STG_DESC	- Address of string descriptor for remaining operands of
;	2227	!			  instruction being encoded.
;	2228	!	OPRND_STG_DESC	- Address of string descriptor for buffer into which the
;	2229	!			  "pre-processed" operand string will be placed
;	2230	!	USER_SYM_FLAG - Indicator whether or not to reduce user-defined symbols.
;	2231	!			This feature is for command file output.
;	2232	!				(TRUE=reduce, FALSE=don't reduce)
;	2233	!
;	2234	! Implicit Inputs:
;	2235	!
;	2236	!	PAT$GL_MOD_PTR	- is used by the radix convert routine
;	2237	!			  to convert numeric input.
;	2238	!
;	2239	! Outputs:
;	2240	!
;	2241	!	None.
;	2242	!
;	2243	! Implicit Outputs:
;	2244	!
;	2245	!	OPRND_STG_DESC[DSC$W_LENGTH] will be set to the length of the operand.
;	2246	!	The buffer pointed to by OPRND_STG_DESC[DSC$A_POINTER] will contain the
;	2247	!	ASCII operand string.
;	2248	!
;	2249	! Return Value:
;	2250	!
;	2251	!	OPR_FOUND (1)	- if an operand is found.
;	2252	!	NO_MORE_OPR (0)	- if there are no more operands.
;	2253	!	OPR_ERROR (2)	- if there was an error in the operand.
;	2254	!	OPR_FORW_REF (3)- if there was a forward reference to a symbol
;	2255	!
;	2256	! Side Effects:
;	2257	!
;	2258	!	All errors in expressions or undefined symbols are SIGNALed, causing
;	2259	!	an INFORMATIONAL message to be printed.  Then an error code is returned
;	2260	!	so that the routine that called PAT$INS_ENCODE will output the
;	2261	!	instruction that could not be encoded.
;	2262	!
;	2263	!	Also, PAT$CP_OUT_STR and PAT$GL_BUF_SIZ are destroyed.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-1
; Digital Equipment Corporation
;
;	2264	!
;	2265	!--
;	2266	
;	2267	BEGIN
;	2268	
;	2269	MAP
;	2270		INS_STG_DESC : REF BLOCK [,BYTE],			! String descriptor for remaining operands
;	2271		OPRND_STG_DESC : REF BLOCK[,BYTE];			! String descriptor for returned operand
;	2272	
;	2273	LABEL
;	2274		DIGIT_CODE,						! Digit string token code
;	2275		OPERATOR_CODE,						! Operator handling code
;	2276		RANGLE_CODE,						! Right angle bracket handling code
;	2277		ALPHA_CODE,						! Alpha_str_token handling code
;	2278		GET_PATHNAME;						! Code to get a pathname
;	2279	
;	2280	BIND
;	2281		EXP_STG = UPLIT BYTE (%ASCIC '^X!XL');			! FAO control string to convert binary numbers to ASCII
;	2282	
;	2283	MACRO
;	2284		EXP$L_VALUE = 0, 0, 32, 0%,				! EXP$L_VALUE (expression value stacked)
;	2285		EXP$B_OPERATOR = 0, 32, 8, 1%;				! EXP$B_OPERATOR (token_type for stacked operator)
;	2286	
;	2287	LITERAL
;	2288		EXP$C_SIZE = 5,						! Length of one expression stack entry
;	2289		EXPR_STK_SIZ = EXP$C_SIZE * 20,				! Allow 20 entries on expression stack
;	2290		NEGATION_TOKEN = -1;					! Token value for unary '-'
;	2291	
;	2292	LOCAL
;	2293		INS_START_PTR : REF VECTOR[,BYTE],			! Pointer to first byte of this operand
;	2294		FLAG,							! Flag to exit operator select loop
;	2295		CUR_VALUE,						! Current numeric value found
;	2296		CUR_OPERATOR,						! Current operator to process
;	2297		NUMBER_FLAG,						! Flag set if operand contained a numeric value
;	2298		PREV_TOKEN,						! Previous token_type value
;	2299		TOKEN_TYPE,						! Encoded type of token found by PAT$MAR_GET_LEX
;	2300		LEX_STG_DESC : BLOCK[12,BYTE],				! String descriptor for current lexeme
;	2301		STACK_PTR : REF BLOCK[,BYTE],				! Pointer to next free position on expression stack
;	2302		EXPR_STACK : BLOCK[EXPR_STK_SIZ,BYTE],			! Expression stack (grows from low address to high address)
;	2303		LEX_BUF : VECTOR[CHS_PER_LEXEME,BYTE];			! Buffer to hold ascii lexeme string
;	2304	
;	2305	!++
;	2306	! First check that there is more input in the remaining operand string.
;	2307	!--
;	2308	IF (.INS_STG_DESC[DSC$W_LENGTH] EQL 0)
;	2309	THEN
;	2310		RETURN(NO_MORE_OPR);
;	2311	
;	2312	!++
;	2313	! Initialize local variables before starting lexical scan.
;	2314	!--
;	2315	CUR_VALUE = 0;
;	2316	CUR_OPERATOR = 0;
;	2317	NUMBER_FLAG = FALSE;
;	2318	TOKEN_TYPE = 0;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-2
; Digital Equipment Corporation
;
;	2319	STACK_PTR = CH$PTR(EXPR_STACK, 0);
;	2320	INS_START_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER], 0);
;	2321	BYTES_IN_OPRND = 0;						! Initialize to no bytes
;	2322	
;	2323	!++
;	2324	! Zero the buffer which will hold the return operand.
;	2325	!--
;	2326	ZEROCOR (.OPRND_STG_DESC[DSC$A_POINTER], (.OPRND_STG_DESC[DSC$W_MAXLEN]/4));
;	2327	
;	2328	!++
;	2329	! Now enter a loop to process the operand.  There are two ways out of this loop.
;	2330	! The first is by SIGNALing an error.  The second is by encountering a comma or
;	2331	! end of line.  Some tokens may be passed directly into the operand string and
;	2332	! others indicate expressions or symbols.  There is no check in this routine
;	2333	! of the validity of the resultant operand string.
;	2334	!--
;	2335	REPEAT
;	2336		BEGIN
;	2337		!++
;	2338		! Get the next token.  The process this token based on its
;	2339		! encoded token_type.
;	2340		!--
;	2341		LEX_STG_DESC[DSC$W_LENGTH] = 0;
;	2342		LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
;	2343		LEX_STG_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	2344		PREV_TOKEN = .TOKEN_TYPE;
;	2345		TOKEN_TYPE = MAR_GET_LEX(.INS_STG_DESC, LEX_STG_DESC);
;	2346		SELECTONE .TOKEN_TYPE OF
;	2347	
;	2348			SET
;	2349	
;	2350		[CL_PAREN_TOKEN,				! ')' as in (reg)
;	2351		 RSQUARE_TOKEN,					! ']' as in [reg]
;	2352		 HASH_TOKEN,					! '#' as in #literal
;	2353		 UP_ARROW_TOKEN,				! '^' as in B^,W^,...
;	2354		 PERIOD_TOKEN]:					! '.' as in .+offset, .-offset
;	2355			BEGIN
;	2356			!++
;	2357			! All of these tokens are passed directly into the resultant
;	2358			! operand string.
;	2359			!--
;	2360			ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2361			END;
;	2362	
;	2363	
;	2364		[OP_PAREN_TOKEN,				! '(' as in (reg)
;	2365		 LSQUARE_TOKEN]:				! '[' as in [reg]
;	2366			BEGIN
;	2367			!++
;	2368			! These tokens signify the end of an expression, if there is
;	2369			! one.  The expression and the token should be passed through.
;	2370			!--
;	2371			IF (.NUMBER_FLAG)
;	2372			THEN
;	2373				BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-3
; Digital Equipment Corporation
;
;	2374				!++
;	2375				! Output the literal to the operand string.  The case
;	2376				! here is number(reg) or number[reg].
;	2377				!--
;	2378				IF (.STACK_PTR NEQU EXPR_STACK)
;	2379				THEN
;	2380					BEGIN
;	2381					SIGNAL(PAT$_NOANGLE+MSG$K_INFO); ! Invalid expression - no closing ">"
;	2382					RETURN(OPR_ERROR);
;	2383					END;
;	2384				PAT$GL_BUF_SIZ = 0;
;	2385				PAT$CP_OUT_STR = CH$PTR(.OPRND_STG_DESC[DSC$A_POINTER],
;	2386							.OPRND_STG_DESC[DSC$W_LENGTH]);
;	2387				PAT$FAO_PUT(EXP_STG, .CUR_VALUE);
;	2388				OPRND_STG_DESC[DSC$W_LENGTH] = .OPRND_STG_DESC[DSC$W_LENGTH] + .PAT$GL_BUF_SIZ;
;	2389				NUMBER_FLAG = FALSE;			! Reset literal flag
;	2390				CUR_VALUE = 0;
;	2391				END;
;	2392	
;	2393			!++
;	2394			! Now pass through the '(' or the '['.
;	2395			!--
;	2396			ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2397			IF (.TOKEN_TYPE EQLU LSQUARE_TOKEN)
;	2398			THEN
;	2399				BYTES_IN_OPRND = .BYTES_IN_OPRND OR CONT_INDX_MASK;
;	2400			END;
;	2401	
;	2402	
;	2403		[AT_SIGN_TOKEN,					! '@' shift operator or @(reg)
;	2404		 PLUS_TOKEN,					! '+' addition operator of (reg)+
;	2405		 MINUS_TOKEN,					! '+' subtraction operator of -(reg)
;	2406		 SLASH_TOKEN,					! '/' division operator
;	2407		 ASTERISK_TOKEN]:				! '*' multiplication operator
;	2408		   OPERATOR_CODE:
;	2409			BEGIN
;	2410			!++
;	2411			! All operators are handled here.  Later additions should be the
;	2412			! ampersand (&) for logical AND and exclamation point (!) for
;	2413			! logical OR.  These are not currently passed through the
;	2414			! lexical scanner.
;	2415			!--
;	2416			IF (.TOKEN_TYPE EQLU AT_SIGN_TOKEN) AND (.PREV_TOKEN EQL 0)
;	2417			THEN
;	2418				BEGIN
;	2419				!++
;	2420				! There is no previous token therefore this must the
;	2421				! @(reg) case.  Just pass the operator through to the
;	2422				! resultant operand string.
;	2423				!--
;	2424				ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2425				LEAVE OPERATOR_CODE;
;	2426				END;
;	2427	
;	2428			IF ((.TOKEN_TYPE EQLU PLUS_TOKEN) OR (.TOKEN_TYPE EQLU MINUS_TOKEN)) AND

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-4
; Digital Equipment Corporation
;
;	2429			   (.PREV_TOKEN EQLU PERIOD_TOKEN)
;	2430			THEN
;	2431				BEGIN
;	2432				!++
;	2433				! This is the case of .+offset or .-offset; pass through
;	2434				! the operator to the resultant string.
;	2435				!--
;	2436				ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2437				LEAVE OPERATOR_CODE;
;	2438				END;
;	2439	
;	2440			IF (.TOKEN_TYPE EQLU PLUS_TOKEN) AND (.PREV_TOKEN EQLU CL_PAREN_TOKEN)
;	2441			THEN
;	2442				BEGIN
;	2443				!++
;	2444				! This is the case (reg)+.  Pass through the operator.
;	2445				!--
;	2446				ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2447				LEAVE OPERATOR_CODE;
;	2448				END;
;	2449	
;	2450			IF (.TOKEN_TYPE EQLU MINUS_TOKEN)
;	2451			THEN
;	2452				BEGIN
;	2453				!++
;	2454				! Check for the case -(reg).
;	2455				!--
;	2456				LOCAL
;	2457					NEXT_CHAR : BYTE,		! Next character from operand stream
;	2458					INS_PTR : REF VECTOR[,BYTE];	! Pointer to next character in operand stream
;	2459	
;	2460				!++
;	2461				! Find the next character in the operand stream that is
;	2462				! not a space or a tab.  This to check if the next
;	2463				! character is a '('.
;	2464				!--
;	2465				INS_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER],0);
;	2466				DO
;	2467					NEXT_CHAR = CH$RCHAR(.INS_PTR)
;	2468				UNTIL ((.NEXT_CHAR NEQU ' ') AND (.NEXT_CHAR NEQU '	'));
;	2469				IF (.NEXT_CHAR EQLU '(')
;	2470				THEN
;	2471					BEGIN
;	2472					!++
;	2473					! This was a case of -(reg).  Pass through the '-'.
;	2474					!--
;	2475					ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2476					LEAVE OPERATOR_CODE;
;	2477					END;
;	2478				END;
;	2479	
;	2480			!++
;	2481			! There should never be two successive operators unless the
;	2482			! second is the unary negation operator.  If the second is the
;	2483			! negation operator, then stack it and the current value.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-5
; Digital Equipment Corporation
;
;	2484			! Then set the current operator to be negation_token.
;	2485			!--
;	2486			IF (.CUR_OPERATOR NEQ 0)
;	2487			THEN
;	2488				IF (.TOKEN_TYPE NEQU MINUS_TOKEN)
;	2489				THEN
;	2490					BEGIN
;	2491					SIGNAL(PAT$_MULTOPR+MSG$K_INFO); ! Two sequential operators found
;	2492					RETURN(OPR_ERROR);
;	2493					END
;	2494				ELSE
;	2495					BEGIN
;	2496					IF ((.STACK_PTR + EXP$C_SIZE) GTRU (EXPR_STACK + EXPR_STK_SIZ))
;	2497					THEN
;	2498						BEGIN
;	2499						SIGNAL(PAT$_EXPSTKOVR+MSG$K_INFO); ! Stack overflow
;	2500						RETURN(OPR_ERROR);
;	2501						END;
;	2502	
;	2503					!++
;	2504					! Stack the current operator and value.
;	2505					!--
;	2506					STACK_PTR[EXP$L_VALUE] = .CUR_VALUE;
;	2507					STACK_PTR[EXP$B_OPERATOR] = .CUR_OPERATOR;
;	2508					STACK_PTR = CH$PTR(.STACK_PTR, EXP$C_SIZE);
;	2509					CUR_VALUE = 0;
;	2510					CUR_OPERATOR = NEGATION_TOKEN;
;	2511					LEAVE OPERATOR_CODE;
;	2512					END;
;	2513	
;	2514			!++
;	2515			! Set the new current operator and go get the next token.
;	2516			!--
;	2517			CUR_OPERATOR = .TOKEN_TYPE;
;	2518			END;
;	2519	
;	2520	
;	2521		[LANGLE_TOKEN]:					! '<' encloses expression
;	2522			BEGIN
;	2523			!++
;	2524			! Check for expression stack overflow.
;	2525			!--
;	2526			IF ((.STACK_PTR + EXP$C_SIZE) GTRU (EXPR_STACK + EXPR_STK_SIZ))
;	2527			THEN
;	2528				BEGIN
;	2529				SIGNAL(PAT$_EXPSTKOVR+MSG$K_INFO);	! Stack overflow
;	2530				RETURN(OPR_ERROR);
;	2531				END;
;	2532	
;	2533			!++
;	2534			! Put new entry on expression stack.  Then reset the pointer
;	2535			! to the next unused entry.  Push the current operator if there
;	2536			! is one, otherwise push a '<' as the operator.
;	2537			!--
;	2538			STACK_PTR[EXP$L_VALUE] = .CUR_VALUE;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-6
; Digital Equipment Corporation
;
;	2539			STACK_PTR[EXP$B_OPERATOR] = (IF (.CUR_OPERATOR NEQ 0)
;	2540						     THEN
;	2541							    .CUR_OPERATOR
;	2542						     ELSE
;	2543							    .TOKEN_TYPE);
;	2544			STACK_PTR = CH$PTR(.STACK_PTR, EXP$C_SIZE);
;	2545			CUR_VALUE = 0;
;	2546			CUR_OPERATOR = 0;
;	2547			END;
;	2548	
;	2549	
;	2550		[RANGLE_TOKEN]:					! '>' encloses expression
;	2551		   RANGLE_CODE:
;	2552			BEGIN
;	2553			!++
;	2554			! The right angle bracket causes one entry to be taken off the
;	2555			! expression stack.  This entry always immediately precedes the
;	2556			! next free entry pointed to by STACK_PTR.  When an entry is
;	2557			! removed, the current value and the stacked value must be
;	2558			! combined using the stacked operator.  If the operator is a
;	2559			! left angle bracket, then there were two consecutive left
;	2560			! angle brackets in the expression and there is no stacked value
;	2561			! to be combined.
;	2562			!--
;	2563			IF (.STACK_PTR EQLU EXPR_STACK)			! Check for stack underflow
;	2564			THEN
;	2565				BEGIN
;	2566				SIGNAL(PAT$_NOANGLE+MSG$K_INFO);	! Stack underflow
;	2567				RETURN(OPR_ERROR);
;	2568				END;
;	2569			IF (.CUR_OPERATOR NEQU 0) OR (.PREV_TOKEN EQLU LANGLE_TOKEN) ! Check for missing operand
;	2570			THEN
;	2571				BEGIN
;	2572				SIGNAL(PAT$_NOOPRND+MSG$K_INFO);	! Missing operand (got operator>)
;	2573				RETURN(OPR_ERROR);
;	2574				END;
;	2575			STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE);	! Point to last entry
;	2576			DO
;	2577			BEGIN
;	2578			FLAG = TRUE;
;	2579			SELECTONE .STACK_PTR[EXP$B_OPERATOR] OF
;	2580				SET
;	2581			[PLUS_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] + .CUR_VALUE;
;	2582			[MINUS_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] - .CUR_VALUE;
;	2583			[ASTERISK_TOKEN]:	CUR_VALUE = .STACK_PTR[EXP$L_VALUE] * .CUR_VALUE;
;	2584			[SLASH_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] / .CUR_VALUE;
;	2585	 		[AT_SIGN_TOKEN]:	CUR_VALUE = .STACK_PTR[EXP$L_VALUE] ^ .CUR_VALUE;
;	2586			[LANGLE_TOKEN]:		0;			! No operation to perform
;	2587	! * FUTURE *	[AMPERSAND_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] + .CUR_VALUE;
;	2588	! * FUTURE *	[EXCLAM_PT_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] + .CUR_VALUE;
;	2589			[NEGATION_TOKEN]:		BEGIN
;	2590							FLAG = FALSE;
;	2591							CUR_VALUE = -.CUR_VALUE;
;	2592							IF (.STACK_PTR NEQU EXPR_STACK) ! Check for stack underflow
;	2593							THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-7
; Digital Equipment Corporation
;
;	2594								STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE); ! Point to last entry
;	2595							END;
;	2596			[OTHERWISE]:			BEGIN
;	2597							SIGNAL(PAT$_INVOPR+MSG$K_INFO); ! Unrecognized operand
;	2598							RETURN(OPR_ERROR);
;	2599							END;
;	2600				TES;
;	2601			END
;	2602			UNTIL (.FLAG);
;	2603	
;	2604			CUR_OPERATOR = 0;
;	2605			NUMBER_FLAG = TRUE;
;	2606			END;
;	2607	
;	2608	
;	2609		[DIGIT_STR_TOKEN]:				! numeric string
;	2610			BEGIN
;	2611			IF (.CUR_OPERATOR EQL 0)
;	2612			THEN
;	2613				CUR_VALUE = .(.LEX_STG_DESC[DSC$A_POINTER])
;	2614			ELSE
;	2615				DO
;	2616				BEGIN
;	2617				FLAG = TRUE;
;	2618				IF (.CUR_OPERATOR EQL NEGATION_TOKEN)
;	2619				THEN
;	2620					CUR_VALUE = .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2621				SELECTONE .CUR_OPERATOR OF
;	2622					SET
;	2623				[PLUS_TOKEN]:	CUR_VALUE = .CUR_VALUE + .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2624				[MINUS_TOKEN]:	CUR_VALUE = .CUR_VALUE - .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2625				[ASTERISK_TOKEN]: CUR_VALUE = .CUR_VALUE * .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2626				[SLASH_TOKEN]:	CUR_VALUE = .CUR_VALUE / .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2627				[AT_SIGN_TOKEN]: CUR_VALUE = .CUR_VALUE ^ .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2628				[LANGLE_TOKEN]:		0;		! No operation to perform
;	2629	! * FUTURE *		[AMPERSAND_TOKEN]: CUR_VALUE = .CUR_VALUE AND .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2630	! * FUTURE *		[EXCLAM_PT__TOKEN]: CUR_VALUE = .CUR_VALUE OR .(.LEX_STG_DESC[DSC$A_POINTER]);
;	2631				[NEGATION_TOKEN]:	BEGIN
;	2632							FLAG = FALSE;
;	2633							CUR_VALUE = -.CUR_VALUE;
;	2634							IF (.STACK_PTR NEQU EXPR_STACK) ! Check for stack underflow
;	2635							THEN
;	2636								BEGIN
;	2637								STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE); ! Point to last entry
;	2638								CUR_OPERATOR = .STACK_PTR[EXP$B_OPERATOR];
;	2639								.LEX_STG_DESC[DSC$A_POINTER] = .CUR_VALUE;
;	2640								CUR_VALUE = .STACK_PTR[EXP$L_VALUE];
;	2641								END;
;	2642							END;
;	2643				[OTHERWISE]:	BEGIN
;	2644						SIGNAL(PAT$_INVOPR+MSG$K_INFO); ! Unrecognized operand
;	2645						RETURN(OPR_ERROR);
;	2646						END;
;	2647					TES;
;	2648				END

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-8
; Digital Equipment Corporation
;
;	2649				UNTIL (.FLAG);
;	2650			CUR_OPERATOR = 0;
;	2651			NUMBER_FLAG = TRUE;
;	2652			END;
;	2653	
;	2654	
;	2655		[EOL_TOKEN,
;	2656		 COMMA_TOKEN]:					! End of operand string
;	2657			BEGIN
;	2658			!++
;	2659			! Either of these tokens signals the end of the operand string.
;	2660			! Check if there is a numeric value to be written to the
;	2661			! resultant string.  Check for expressions left on the stack.
;	2662			!--
;	2663			IF (.NUMBER_FLAG)
;	2664			THEN
;	2665				BEGIN
;	2666				!++
;	2667				! Output the current value as an ASCII string.
;	2668				!--
;	2669				PAT$GL_BUF_SIZ = 0;
;	2670				PAT$CP_OUT_STR = CH$PTR(.OPRND_STG_DESC[DSC$A_POINTER],
;	2671							.OPRND_STG_DESC[DSC$W_LENGTH]);
;	2672				PAT$FAO_PUT(EXP_STG, .CUR_VALUE);
;	2673				OPRND_STG_DESC[DSC$W_LENGTH] = .OPRND_STG_DESC[DSC$W_LENGTH] + .PAT$GL_BUF_SIZ;
;	2674				END;
;	2675	
;	2676			!++
;	2677			! Check that there is not a missing operand, i.e., there exists
;	2678			! a current operator.
;	2679			!--
;	2680			IF (.CUR_OPERATOR NEQ 0)
;	2681			THEN
;	2682				BEGIN
;	2683				SIGNAL(PAT$_NOOPRND+MSG$K_INFO);	! Missing operand (got operator>)
;	2684				RETURN(OPR_ERROR);
;	2685				END;
;	2686	
;	2687			!++
;	2688			! Check that there was nothing left on the expression stack.
;	2689			!--
;	2690			IF (.STACK_PTR NEQU EXPR_STACK)
;	2691			THEN
;	2692				BEGIN
;	2693				SIGNAL(PAT$_NOANGLE+MSG$K_INFO);	! Expression stack not empty
;	2694				RETURN(OPR_ERROR);
;	2695				END;
;	2696			IF (.OPRND_STG_DESC[DSC$W_LENGTH] EQL 0)
;	2697			THEN
;	2698				RETURN(NO_MORE_OPR)				! Got , or EOL_TOKEN and no operand
;	2699			ELSE
;	2700				RETURN(OPR_FOUND);
;	2701			END;
;	2702	
;	2703	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-9
; Digital Equipment Corporation
;
;	2704		[ALPHA_STR_TOKEN]:				! Register, L^,B^,... or symbolic name
;	2705		   ALPHA_CODE:
;	2706			BEGIN
;	2707			!++
;	2708			! First check if the string is a register.  If so then pass
;	2709			! it through.
;	2710			!--
;	2711			LOCAL
;	2712				STATUS,					! Return status from symbol definition
;	2713				SYMBOL_BUF : VECTOR[MAX_BUF_SIZ,BYTE],	! Buffer to hold all of pathname
;	2714				SYMBOL_DESC : BLOCK[12,BYTE],		! String descriptor for pathname
;	2715				NEXT_CHAR : BYTE,			! Next ASCII character in input stream
;	2716				INS_PTR : REF VECTOR[,BYTE],		! Pointer to next character in input stream
;	2717				REG_NUM,				! Number of register found
;	2718				LEXEME_PTR,				! Pointer to ASCII lexeme
;	2719				TEMP_VALUE,				! Value of pathname
;	2720				CHAR : BYTE;				! First ASCII character in lexeme
;	2721	
;	2722			IF ((REG_NUM = PAT$REG_MATCH(LEX_STG_DESC)) GEQ 0) AND
;	2723			    (.REG_NUM LEQ MAX_REG)
;	2724			THEN
;	2725				BEGIN
;	2726				!++
;	2727				! Found a register.  Pass it through.
;	2728				!--
;	2729				ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
;	2730				LEAVE ALPHA_CODE;
;	2731				END;
;	2732	
;	2733			!++
;	2734			! It was not a register.  Check if it is one of the following
;	2735			! directives:  L^, W^, B^, I^, or S^.  If so, pass the token
;	2736			! through.
;	2737			!--
;	2738			LEXEME_PTR = CH$PTR(.LEX_STG_DESC[DSC$A_POINTER], 0);
;	2739			CHAR = CH$RCHAR(.LEXEME_PTR);
;	2740			IF (.LEX_STG_DESC[DSC$W_LENGTH] EQL 1)
;	2741			THEN
;	2742				IF (.CHAR EQLU 'B') OR
;	2743				   (.CHAR EQLU 'W') OR
;	2744				   (.CHAR EQLU 'L') OR
;	2745				   (.CHAR EQLU 'I') OR
;	2746				   (.CHAR EQLU 'S')
;	2747				THEN
;	2748					BEGIN
;	2749					INS_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER], 0);
;	2750					NEXT_CHAR = CH$RCHAR(.INS_PTR);
;	2751					IF (.NEXT_CHAR EQLU '^')
;	2752					THEN
;	2753						BEGIN
;	2754						LEX_BUF[1] = '^';
;	2755						LEX_STG_DESC[DSC$W_LENGTH] = .LEX_STG_DESC[DSC$W_LENGTH] + 1;
;	2756						INS_STG_DESC[DSC$W_LENGTH] = .INS_STG_DESC[DSC$W_LENGTH] - 1;
;	2757						INS_STG_DESC[DSC$A_POINTER] = .INS_STG_DESC[DSC$A_POINTER] + 1;
;	2758						ADD_LEX_T_OPRND(LEX_STG_DESC, .OPRND_STG_DESC);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-10
; Digital Equipment Corporation
;
;	2759						IF (.CHAR EQLU 'B')
;	2760						THEN
;	2761							BYTES_IN_OPRND = .BYTES_IN_OPRND OR B_HAT_MASK;
;	2762						IF (.CHAR EQLU 'W')
;	2763						THEN
;	2764							BYTES_IN_OPRND = .BYTES_IN_OPRND OR W_HAT_MASK;
;	2765						IF (.CHAR EQLU 'L')
;	2766						THEN
;	2767							BYTES_IN_OPRND = .BYTES_IN_OPRND OR L_HAT_MASK;
;	2768						LEAVE ALPHA_CODE;
;	2769						END;
;	2770					END;
;	2771	
;	2772			!++
;	2773			! The alpha string must be a symbolic name.
;	2774			! Add the current token to the path name by calling PAT$BUILD_PATH.
;	2775			! Also build an ascii string of the pathname using ADD_LEX_T_OPRND
;	2776			! in case the symbol turns out to be undefined.  This will be
;	2777			! used for forward branching in patch area.
;	2778			!--
;	2779			SYMBOL_DESC[DSC$W_LENGTH] = 0;
;	2780			SYMBOL_DESC[DSC$A_POINTER] = SYMBOL_BUF;
;	2781			SYMBOL_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
;	2782			ADD_LEX_T_OPRND(LEX_STG_DESC, SYMBOL_DESC);
;	2783			IF NOT PAT$BUILD_PATH(LEX_STG_DESC, 0, FALSE)
;	2784			THEN
;	2785				SIGNAL(PAT$_NOFREE)			! Insufficient free memory
;	2786			ELSE
;	2787			   GET_PATHNAME:
;	2788				BEGIN
;	2789				!++
;	2790				! Now loop to get the rest of the pathname (if any).
;	2791				!--
;	2792				REPEAT
;	2793				BEGIN
;	2794				INS_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER], 0);
;	2795				DO
;	2796					NEXT_CHAR = CH$RCHAR(.INS_PTR)
;	2797				UNTIL ((.NEXT_CHAR NEQU ' ') AND (.NEXT_CHAR NEQU '	'));
;	2798				IF (.NEXT_CHAR NEQU '\')
;	2799				THEN
;	2800					LEAVE GET_PATHNAME
;	2801				ELSE
;	2802					BEGIN
;	2803					!++
;	2804					! Found a backslash.  There must be another
;	2805					! piece of the pathname.
;	2806					!--
;	2807					LOCAL
;	2808						TEMP_TOKEN;		! Temporary token type
;	2809	
;	2810					!++
;	2811					! Now PATCH should be able to get the next two
;	2812					! tokens (BACK_SLASH_TOKEN and ALPHA_STR_TOKEN).
;	2813					! Any other token types are errors.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-11
; Digital Equipment Corporation
;
;	2814					!--
;	2815					LEX_STG_DESC[DSC$W_LENGTH] = 0;
;	2816					LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
;	2817					LEX_STG_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	2818					IF (TEMP_TOKEN = MAR_GET_LEX( .INS_STG_DESC, LEX_STG_DESC)) NEQU BACKSLASH_TOKEN
;	2819					THEN
;	2820						BEGIN
;	2821			! ******** THIS NEEDS AN OPERAND!!!!!!!! WHICH ONE?
;	2822						SIGNAL(PAT$_INVPATH+MSG$K_INFO); ! Invalid pathname
;	2823						RETURN(OPR_ERROR);
;	2824						END;
;	2825					ADD_LEX_T_OPRND(LEX_STG_DESC, SYMBOL_DESC);
;	2826					LEX_STG_DESC[DSC$W_LENGTH] = 0;
;	2827					LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
;	2828					LEX_STG_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	2829					IF (TEMP_TOKEN = MAR_GET_LEX(.INS_STG_DESC, LEX_STG_DESC)) NEQU ALPHA_STR_TOKEN
;	2830					THEN
;	2831						BEGIN
;	2832			! ******** THIS NEEDS AN OPERAND!!!!!!!! WHICH ONE?
;	2833						SIGNAL(PAT$_INVPATH+MSG$K_INFO); ! Invalid pathname
;	2834						RETURN(OPR_ERROR);
;	2835			! ******** THIS NEEDS AN OPERAND!!!!!!!! WHICH ONE?
;	2836						END;
;	2837					IF NOT PAT$BUILD_PATH(LEX_STG_DESC, 0, FALSE)
;	2838					THEN
;	2839						SIGNAL(PAT$_NOFREE);	! Insufficient free memory
;	2840					ADD_LEX_T_OPRND(LEX_STG_DESC, SYMBOL_DESC);
;	2841					END;
;	2842				END;
;	2843				END;
;	2844	
;	2845			!++
;	2846			! Now the complete pathname has been acquired.  Try to
;	2847			! convert it into a numerical value.  First search the current
;	2848			! symbol table for a label.  Then search the old label symbol
;	2849			! table.  Lastly, if the symbol is not defined then
;	2850			! PAT$BUILD_PATH returns FALSE.
;	2851			!--
;	2852			STATUS = PAT$FIND_SYM(SYMBOL_DESC);
;	2853			IF (.STATUS EQLA 0)
;	2854			THEN
;	2855				BEGIN
;	2856				!++
;	2857				! Remember the current symbol table but force
;	2858				! PAT$FIND_SYM to use the old contents label table.
;	2859				!--
;	2860				LOCAL
;	2861					TEMP_SYMTB_PTR;
;	2862				TEMP_SYMTB_PTR = .PAT$GL_SYMTBPTR;
;	2863				PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;
;	2864				STATUS = PAT$FIND_SYM(SYMBOL_DESC);
;	2865				PAT$GL_SYMTBPTR = .TEMP_SYMTB_PTR;
;	2866				END;
;	2867			IF (.STATUS NEQA 0)
;	2868			THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-12
; Digital Equipment Corporation
;
;	2869				BEGIN
;	2870				!++
;	2871				! Symbol was defined as a label.  Get the value and
;	2872				! then change STATUS from the table entry address to
;	2873				! a code which would be returned by PAT$BUILD_PATH.
;	2874				!--
;	2875				TEMP_VALUE = .SYM_VALUE(.STATUS);
;	2876				STATUS = PAT$K_USER_DEF;
;	2877				END
;	2878			ELSE
;	2879				STATUS = PAT$BUILD_PATH(0, TEMP_VALUE, FALSE);
;	2880			IF (NOT .STATUS) OR				! If undefined symbol or
;	2881			   ((.STATUS EQLU PAT$K_USER_DEF) AND (NOT .USER_SYM_FLAG)) ! symbol is user-defined and not to be reduced
;	2882			THEN
;	2883				BEGIN
;	2884				!++
;	2885				! Either the symbol was undefined and assumed to be a
;	2886				! forward reference or it is a user-defined symbol and
;	2887				! this is a reduction for command file output and thus
;	2888				! the symbol is not to be reduced.  In the case of a
;	2889				! forward reference, the symbol will be defined later
;	2890				! in the current PATCH command.  Since PATCH cannot
;	2891				! handle the operand now, set the operand string
;	2892				! descriptor to point to the un-reduced ascii string
;	2893				! in the instruction buffer.
;	2894				!--
;	2895				DO
;	2896					BEGIN
;	2897					!++
;	2898					! This loop finds the end of the operand.
;	2899					!--
;	2900					LEX_STG_DESC[DSC$W_LENGTH] = 0;
;	2901					LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
;	2902					TOKEN_TYPE = MAR_GET_LEX(.INS_STG_DESC, LEX_STG_DESC);
;	2903					IF (.TOKEN_TYPE EQLU LSQUARE_TOKEN)
;	2904					THEN
;	2905						BYTES_IN_OPRND = .BYTES_IN_OPRND OR CONT_INDX_MASK;
;	2906					END
;	2907				UNTIL ((.TOKEN_TYPE EQL EOL_TOKEN) OR (.TOKEN_TYPE EQL COMMA_TOKEN));
;	2908				OPRND_STG_DESC[DSC$W_LENGTH] = .INS_STG_DESC[DSC$A_POINTER]
;	2909							- .INS_START_PTR;
;	2910				OPRND_STG_DESC[DSC$A_POINTER] = CH$PTR(.INS_START_PTR, 0);
;	2911				RETURN(OPR_FORW_REF);
;	2912				END;
;	2913			!++
;	2914			! Now that a value has been found, process it as if a
;	2915			! DIGIT_STR_TOKEN had been found.
;	2916			!--
;	2917			IF (.CUR_OPERATOR EQL 0)
;	2918			THEN
;	2919				CUR_VALUE = .TEMP_VALUE
;	2920			ELSE
;	2921				DO
;	2922				BEGIN
;	2923				FLAG = TRUE;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-13
; Digital Equipment Corporation
;
;	2924				IF (.CUR_OPERATOR EQL NEGATION_TOKEN)
;	2925				THEN
;	2926					CUR_VALUE = .TEMP_VALUE;
;	2927				SELECTONE .CUR_OPERATOR OF
;	2928					SET
;	2929				[PLUS_TOKEN]:	CUR_VALUE = .CUR_VALUE + .TEMP_VALUE;
;	2930				[MINUS_TOKEN]:	CUR_VALUE = .CUR_VALUE - .TEMP_VALUE;
;	2931				[ASTERISK_TOKEN]: CUR_VALUE = .CUR_VALUE * .TEMP_VALUE;
;	2932				[SLASH_TOKEN]:	CUR_VALUE = .CUR_VALUE / .TEMP_VALUE;
;	2933				[AT_SIGN_TOKEN]: CUR_VALUE = .CUR_VALUE ^ .TEMP_VALUE;
;	2934				[LANGLE_TOKEN]:		0;		! No operation to perform
;	2935	! * FUTURE *		[AMPERSAND_TOKEN]: CUR_VALUE = .CUR_VALUE AND .TEMP_VALUE;
;	2936	! * FUTURE *		[EXCLAM_PT__TOKEN]: CUR_VALUE = .CUR_VALUE OR .TEMP_VALUE;
;	2937				[NEGATION_TOKEN]:	BEGIN
;	2938							FLAG = FALSE;
;	2939							CUR_VALUE = -.CUR_VALUE;
;	2940							IF (.STACK_PTR NEQU EXPR_STACK) ! Check for stack underflow
;	2941							THEN
;	2942								BEGIN
;	2943								STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE); ! Point to last entry
;	2944								CUR_OPERATOR = .STACK_PTR[EXP$B_OPERATOR];
;	2945								TEMP_VALUE = .CUR_VALUE;
;	2946								CUR_VALUE = .STACK_PTR[EXP$L_VALUE];
;	2947								END;
;	2948							END;
;	2949				[OTHERWISE]:	BEGIN
;	2950						SIGNAL(PAT$_INVOPR+MSG$K_INFO); ! Unrecognized operand
;	2951						RETURN(OPR_ERROR);
;	2952						END;
;	2953					TES;
;	2954				END
;	2955				UNTIL (.FLAG);
;	2956			CUR_OPERATOR = 0;
;	2957			NUMBER_FLAG = TRUE;
;	2958			END;
;	2959	
;	2960	
;	2961		[OTHERWISE]:					! Illegal token type
;	2962			BEGIN
;	2963			SIGNAL(PAT$_INVOPR+MSG$K_INFO);		! Unrecognized operand
;	2964			RETURN(OPR_ERROR);
;	2965			END;
;	2966	
;	2967			TES;
;	2968		END;							! End of REPEAT loop
;	2969	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .ASCII  <5>\^X!XL\						      ;
					      00006	    .BLKB   2

						    EXP_STG=		P.AAA

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-14
; Digital Equipment Corporation
;


							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 005BC GET_OPERAND:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11		      ; 2209
		         5E	FD5C   CE  9E 005BE 	    MOVAB   -676(SP), SP					      ;
		         5B	  04   AC  D0 005C3 	    MOVL    INS_STG_DESC, R11					      ; 2308
				       6B  B5 005C7 	    TSTW    (R11)						      ;
				       03  12 005C9 	    BNEQ    1$							      ;
				     0662  31 005CB 	    BRW     97$							      ;
				       57  7C 005CE 1$:     CLRQ    CUR_VALUE						      ; 2315
				  04   AE  D4 005D0 	    CLRL    NUMBER_FLAG						      ; 2317
				       59  D4 005D3 	    CLRL    TOKEN_TYPE						      ; 2318
		         5A	  90   AD  9E 005D5 	    MOVAB   EXPR_STACK, STACK_PTR				      ; 2319
		         6E	  04   AB  9E 005D9 	    MOVAB   4(R11), (SP)					      ; 2320
		    0C   AE	  00   BE  D0 005DD 	    MOVL    @0(SP), INS_START_PTR				      ;
			    00000000'  EF  D4 005E2 	    CLRL    BYTES_IN_OPRND					      ; 2321
		         56	  08   AC  D0 005E8 	    MOVL    OPRND_STG_DESC, R6					      ; 2326
		         50	  08   A6  3C 005EC 	    MOVZWL  8(R6), R0						      ;
		         50	       04  C6 005F0 	    DIVL2   #4, R0						      ;
		         50	       04  C4 005F3 	    MULL2   #4, R0						      ;
	   00	         6E	       00  2C 005F6 	    MOVC5   #0, (SP), #0, R0, @4(R6)				      ;
		    04   B6	       50     005FA									      ;
				  F4   AD  B4 005FD 2$:     CLRW    LEX_STG_DESC					      ; 2341
		    F8   AD	FF7C   CD  9E 00600 	    MOVAB   LEX_BUF, LEX_STG_DESC+4				      ; 2342
		    FC   AD	       14  B0 00606 	    MOVW    #20, LEX_STG_DESC+8					      ; 2343
		    08   AE	       59  D0 0060A 	    MOVL    TOKEN_TYPE, PREV_TOKEN				      ; 2344
				  F4   AD  9F 0060E 	    PUSHAB  LEX_STG_DESC					      ; 2345
				       5B  DD 00611 	    PUSHL   R11							      ;
	      00000000V  EF	       02  FB 00613 	    CALLS   #2, MAR_GET_LEX					      ;
		         59	       50  D0 0061A 	    MOVL    R0, TOKEN_TYPE					      ;
		         3F	       59  D1 0061D 	    CMPL    TOKEN_TYPE, #63					      ; 2346
				       22  13 00620 	    BEQL    3$							      ;
	      00000043   8F	       59  D1 00622 	    CMPL    TOKEN_TYPE, #67					      ;
				       19  13 00629 	    BEQL    3$							      ;
	      0000004B   8F	       59  D1 0062B 	    CMPL    TOKEN_TYPE, #75					      ;
				       10  13 00632 	    BEQL    3$							      ;
	      00000050   8F	       59  D1 00634 	    CMPL    TOKEN_TYPE, #80					      ;
				       07  13 0063B 	    BEQL    3$							      ;
	      00000053   8F	       59  D1 0063D 	    CMPL    TOKEN_TYPE, #83					      ;
				       03  12 00644 3$:     BNEQ    4$							      ;
				     032D  31 00646 	    BRW     65$							      ;
	      00000045   8F	       59  D1 00649 4$:     CMPL    TOKEN_TYPE, #69					      ;
				       09  13 00650 	    BEQL    5$							      ;
	      00000049   8F	       59  D1 00652 	    CMPL    TOKEN_TYPE, #73					      ;
				       62  12 00659 	    BNEQ    10$							      ;
		         3F	  04   AE  E9 0065B 5$:     BLBC    NUMBER_FLAG, 8$					      ; 2371
		         50	  90   AD  9E 0065F 	    MOVAB   EXPR_STACK, R0					      ; 2378
		         50	       5A  D1 00663 	    CMPL    STACK_PTR, R0					      ;
				       09  13 00666 	    BEQL    7$							      ;
			    006D821B   8F  DD 00668 6$:     PUSHL   #7176731						      ; 2381
				     05B4  31 0066E 	    BRW     96$							      ;
			    00000000G  EF  D4 00671 7$:     CLRL    PAT$GL_BUF_SIZ					      ; 2384
		         50	       66  3C 00677 	    MOVZWL  (R6), R0						      ; 2386

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-15
; Digital Equipment Corporation
;
00000000G  EF	    04   A6	       50  C1 0067A 	    ADDL3   R0, 4(R6), PAT$CP_OUT_STR				      ;
				       57  DD 00683 	    PUSHL   CUR_VALUE						      ; 2387
			    00000000'  EF  9F 00685 	    PUSHAB  EXP_STG						      ; 2209
	      00000000G  EF	       02  FB 0068B 	    CALLS   #2, PAT$FAO_PUT					      ; 2387
		         66 00000000G  EF  A0 00692 	    ADDW2   PAT$GL_BUF_SIZ, (R6)				      ; 2388
				  04   AE  D4 00699 	    CLRL    NUMBER_FLAG						      ; 2389
				       57  D4 0069C 	    CLRL    CUR_VALUE						      ; 2390
				       56  DD 0069E 8$:     PUSHL   R6							      ; 2396
				  F4   AD  9F 006A0 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000V  EF	       02  FB 006A3 	    CALLS   #2, ADD_LEX_T_OPRND					      ;
	      00000045   8F	       59  D1 006AA 	    CMPL    TOKEN_TYPE, #69					      ; 2397
				       07  12 006B1 	    BNEQ    9$							      ;
	      00000000'  EF	       08  88 006B3 	    BISB2   #8, BYTES_IN_OPRND					      ; 2399
				     FF40  31 006BA 9$:     BRW     2$							      ; 2346
		         3C	       59  D1 006BD 10$:    CMPL    TOKEN_TYPE, #60					      ;
				       05  19 006C0 	    BLSS    11$							      ;
		         3D	       59  D1 006C2 	    CMPL    TOKEN_TYPE, #61					      ;
				       1E  15 006C5 	    BLEQ    12$							      ;
	      00000046   8F	       59  D1 006C7 11$:    CMPL    TOKEN_TYPE, #70					      ;
				       15  13 006CE 	    BEQL    12$							      ;
	      0000004C   8F	       59  D1 006D0 	    CMPL    TOKEN_TYPE, #76					      ;
				       0C  13 006D7 	    BEQL    12$							      ;
	      00000052   8F	       59  D1 006D9 	    CMPL    TOKEN_TYPE, #82					      ;
				       03  13 006E0 	    BEQL    12$							      ;
				     0090  31 006E2 	    BRW     23$							      ;
		         3D	       59  D1 006E5 12$:    CMPL    TOKEN_TYPE, #61					      ; 2416
				       05  12 006E8 	    BNEQ    13$							      ;
				  08   AE  D5 006EA 	    TSTL    PREV_TOKEN						      ;
				       48  13 006ED 	    BEQL    19$							      ;
				       52  D4 006EF 13$:    CLRL    R2							      ; 2428
	      0000004C   8F	       59  D1 006F1 	    CMPL    TOKEN_TYPE, #76					      ;
				       04  12 006F8 	    BNEQ    14$							      ;
				       52  D6 006FA 	    INCL    R2							      ;
				       09  11 006FC 	    BRB     15$							      ;
	      00000046   8F	       59  D1 006FE 14$:    CMPL    TOKEN_TYPE, #70					      ;
				       0A  12 00705 	    BNEQ    16$							      ;
	      0000004B   8F	  08   AE  D1 00707 15$:    CMPL    PREV_TOKEN, #75					      ; 2429
				       26  13 0070F 	    BEQL    19$							      ;
		         06	       52  E9 00711 16$:    BLBC    R2, 17$						      ; 2440
		         3F	  08   AE  D1 00714 	    CMPL    PREV_TOKEN, #63					      ;
				       1D  13 00718 	    BEQL    19$							      ;
	      00000046   8F	       59  D1 0071A 17$:    CMPL    TOKEN_TYPE, #70					      ; 2450
				       19  12 00721 	    BNEQ    20$							      ;
		         51	  00   BE  D0 00723 	    MOVL    @0(SP), INS_PTR					      ; 2465
		         50	       61  90 00727 18$:    MOVB    (INS_PTR), NEXT_CHAR				      ; 2467
		         20	       50  91 0072A 	    CMPB    NEXT_CHAR, #32					      ; 2468
				       F8  13 0072D 	    BEQL    18$							      ;
		         09	       50  91 0072F 	    CMPB    NEXT_CHAR, #9					      ;
				       F3  13 00732 	    BEQL    18$							      ;
		         28	       50  91 00734 	    CMPB    NEXT_CHAR, #40					      ; 2469
				       03  12 00737 19$:    BNEQ    20$							      ;
				     023A  31 00739 	    BRW     65$							      ;
				       58  D5 0073C 20$:    TSTL    CUR_OPERATOR					      ; 2486
				       30  13 0073E 	    BEQL    22$							      ;
	      00000046   8F	       59  D1 00740 	    CMPL    TOKEN_TYPE, #70					      ; 2488

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-16
; Digital Equipment Corporation
;
				       08  13 00747 	    BEQL    21$							      ;
			    006D820B   8F  DD 00749 	    PUSHL   #7176715						      ; 2491
				       40  11 0074F 	    BRB     25$							      ;
	   51	         5A	       05  C1 00751 21$:    ADDL3   #5, STACK_PTR, R1					      ; 2496
		         50	  F4   AD  9E 00755 	    MOVAB   EXPR_STACK+100, R0					      ;
		         50	       51  D1 00759 	    CMPL    R1, R0						      ;
				       2D  1A 0075C 	    BGTRU   24$							      ;
		         6A	       57  D0 0075E 	    MOVL    CUR_VALUE, (STACK_PTR)				      ; 2506
	   08	         20	       58  F0 00761 	    INSV    CUR_OPERATOR, #32, #8, (STACK_PTR)+			      ; 2507
				       8A     00765									      ;
		         5A	       04  C0 00766 	    ADDL2   #4, STACK_PTR					      ; 2508
				       57  D4 00769 	    CLRL    CUR_VALUE						      ; 2509
		         58	       01  CE 0076B 	    MNEGL   #1, CUR_OPERATOR					      ; 2510
				       3C  11 0076E 	    BRB     29$							      ; 2511
		         58	       59  D0 00770 22$:    MOVL    TOKEN_TYPE, CUR_OPERATOR				      ; 2517
				       37  11 00773 	    BRB     29$							      ; 2346
	      00000044   8F	       59  D1 00775 23$:    CMPL    TOKEN_TYPE, #68					      ;
				       31  12 0077C 	    BNEQ    30$							      ;
	   51	         5A	       05  C1 0077E 	    ADDL3   #5, STACK_PTR, R1					      ; 2526
		         50	  F4   AD  9E 00782 	    MOVAB   EXPR_STACK+100, R0					      ;
		         50	       51  D1 00786 	    CMPL    R1, R0						      ;
				       08  1B 00789 	    BLEQU   26$							      ;
			    006D8213   8F  DD 0078B 24$:    PUSHL   #7176723						      ; 2529
				       48  11 00791 25$:    BRB     34$							      ;
		         6A	       57  D0 00793 26$:    MOVL    CUR_VALUE, (STACK_PTR)				      ; 2538
				       58  D5 00796 	    TSTL    CUR_OPERATOR					      ; 2539
				       05  13 00798 	    BEQL    27$							      ;
		         50	       58  D0 0079A 	    MOVL    CUR_OPERATOR, R0					      ;
				       03  11 0079D 	    BRB     28$							      ;
		         50	       59  D0 0079F 27$:    MOVL    TOKEN_TYPE, R0					      ;
	   08	         20	       50  F0 007A2 28$:    INSV    R0, #32, #8, (STACK_PTR)+				      ;
				       8A     007A6									      ;
		         5A	       04  C0 007A7 	    ADDL2   #4, STACK_PTR					      ; 2544
				       57  7C 007AA 	    CLRQ    CUR_VALUE						      ; 2545
				     FE4E  31 007AC 29$:    BRW     2$							      ; 2346
	      0000004F   8F	       59  D1 007AF 30$:    CMPL    TOKEN_TYPE, #79					      ;
				       03  13 007B6 	    BEQL    31$							      ;
				     009A  31 007B8 	    BRW     44$							      ;
		         50	  90   AD  9E 007BB 31$:    MOVAB   EXPR_STACK, R0					      ; 2563
		         50	       5A  D1 007BF 	    CMPL    STACK_PTR, R0					      ;
				       03  12 007C2 	    BNEQ    32$							      ;
				     FEA1  31 007C4 	    BRW     6$							      ;
				       58  D5 007C7 32$:    TSTL    CUR_OPERATOR					      ; 2569
				       0A  12 007C9 	    BNEQ    33$							      ;
	      00000044   8F	  08   AE  D1 007CB 	    CMPL    PREV_TOKEN, #68					      ;
				       09  12 007D3 	    BNEQ    35$							      ;
			    006D8223   8F  DD 007D5 33$:    PUSHL   #7176739						      ; 2572
				     0447  31 007DB 34$:    BRW     96$							      ;
		         5A	       05  C2 007DE 35$:    SUBL2   #5, STACK_PTR					      ; 2575
		         55	       01  D0 007E1 36$:    MOVL    #1, FLAG						      ; 2578
	   6A	         08	       20  EE 007E4 	    EXTV    #32, #8, (STACK_PTR), R0				      ; 2579
				       50     007E8									      ;
	      0000004C   8F	       50  D1 007E9 	    CMPL    R0, #76						      ;
				       05  12 007F0 	    BNEQ    37$							      ;
		         57	       6A  C0 007F2 	    ADDL2   (STACK_PTR), CUR_VALUE				      ; 2581

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-17
; Digital Equipment Corporation
;
				       59  11 007F5 	    BRB     43$							      ; 2579
	      00000046   8F	       50  D1 007F7 37$:    CMPL    R0, #70						      ;
				       06  12 007FE 	    BNEQ    38$							      ;
	   57	         6A	       57  C3 00800 	    SUBL3   CUR_VALUE, (STACK_PTR), CUR_VALUE			      ; 2582
				       4A  11 00804 	    BRB     43$							      ; 2579
		         3C	       50  D1 00806 38$:    CMPL    R0, #60						      ;
				       05  12 00809 	    BNEQ    39$							      ;
		         57	       6A  C4 0080B 	    MULL2   (STACK_PTR), CUR_VALUE				      ; 2583
				       40  11 0080E 	    BRB     43$							      ; 2579
	      00000052   8F	       50  D1 00810 39$:    CMPL    R0, #82						      ;
				       06  12 00817 	    BNEQ    40$							      ;
	   57	         6A	       57  C7 00819 	    DIVL3   CUR_VALUE, (STACK_PTR), CUR_VALUE			      ; 2584
				       31  11 0081D 	    BRB     43$							      ; 2579
		         3D	       50  D1 0081F 40$:    CMPL    R0, #61						      ;
				       06  12 00822 	    BNEQ    41$							      ;
	   57	         6A	       57  78 00824 	    ASHL    CUR_VALUE, (STACK_PTR), CUR_VALUE			      ; 2585
				       26  11 00828 	    BRB     43$							      ; 2579
	      00000044   8F	       50  D1 0082A 41$:    CMPL    R0, #68						      ;
				       1D  13 00831 	    BEQL    43$							      ;
	      FFFFFFFF   8F	       50  D1 00833 	    CMPL    R0, #-1						      ;
				       03  13 0083A 	    BEQL    42$							      ;
				     03E0  31 0083C 	    BRW     95$							      ;
				       55  D4 0083F 42$:    CLRL    FLAG						      ; 2590
		         57	       57  CE 00841 	    MNEGL   CUR_VALUE, CUR_VALUE				      ; 2591
		         51	  90   AD  9E 00844 	    MOVAB   EXPR_STACK, R1					      ; 2592
		         51	       5A  D1 00848 	    CMPL    STACK_PTR, R1					      ;
				       03  13 0084B 	    BEQL    43$							      ;
		         5A	       05  C2 0084D 	    SUBL2   #5, STACK_PTR					      ; 2594
		         8E	       55  E9 00850 43$:    BLBC    FLAG, 36$						      ; 2602
				       14  11 00853 	    BRB     46$							      ; 2604
	      00000048   8F	       59  D1 00855 44$:    CMPL    TOKEN_TYPE, #72					      ; 2346
				       03  13 0085C 	    BEQL    45$							      ;
				     009A  31 0085E 	    BRW     57$							      ;
				       58  D5 00861 45$:    TSTL    CUR_OPERATOR					      ; 2611
				       07  12 00863 	    BNEQ    47$							      ;
		         57	  F8   BD  D0 00865 	    MOVL    @LEX_STG_DESC+4, CUR_VALUE				      ; 2613
				     03AA  31 00869 46$:    BRW     94$							      ; 2611
		         55	       01  D0 0086C 47$:    MOVL    #1, FLAG						      ; 2617
	      FFFFFFFF   8F	       58  D1 0086F 	    CMPL    CUR_OPERATOR, #-1					      ; 2618
				       04  12 00876 	    BNEQ    48$							      ;
		         57	  F8   BD  D0 00878 	    MOVL    @LEX_STG_DESC+4, CUR_VALUE				      ; 2620
	      0000004C   8F	       58  D1 0087C 48$:    CMPL    CUR_OPERATOR, #76					      ; 2621
				       06  12 00883 	    BNEQ    49$							      ;
		         57	  F8   BD  C0 00885 	    ADDL2   @LEX_STG_DESC+4, CUR_VALUE				      ; 2623
				       67  11 00889 	    BRB     55$							      ; 2621
	      00000046   8F	       58  D1 0088B 49$:    CMPL    CUR_OPERATOR, #70					      ;
				       06  12 00892 	    BNEQ    50$							      ;
		         57	  F8   BD  C2 00894 	    SUBL2   @LEX_STG_DESC+4, CUR_VALUE				      ; 2624
				       58  11 00898 	    BRB     55$							      ; 2621
		         3C	       58  D1 0089A 50$:    CMPL    CUR_OPERATOR, #60					      ;
				       06  12 0089D 	    BNEQ    51$							      ;
		         57	  F8   BD  C4 0089F 	    MULL2   @LEX_STG_DESC+4, CUR_VALUE				      ; 2625
				       4D  11 008A3 	    BRB     55$							      ; 2621
	      00000052   8F	       58  D1 008A5 51$:    CMPL    CUR_OPERATOR, #82					      ;
				       06  12 008AC 	    BNEQ    52$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-18
; Digital Equipment Corporation
;
		         57	  F8   BD  C6 008AE 	    DIVL2   @LEX_STG_DESC+4, CUR_VALUE				      ; 2626
				       3E  11 008B2 	    BRB     55$							      ; 2621
		         3D	       58  D1 008B4 52$:    CMPL    CUR_OPERATOR, #61					      ;
				       07  12 008B7 	    BNEQ    53$							      ;
	   57	         57	  F8   BD  78 008B9 	    ASHL    @LEX_STG_DESC+4, CUR_VALUE, CUR_VALUE		      ; 2627
				       32  11 008BE 	    BRB     55$							      ; 2621
	      00000044   8F	       58  D1 008C0 53$:    CMPL    CUR_OPERATOR, #68					      ;
				       29  13 008C7 	    BEQL    55$							      ;
	      FFFFFFFF   8F	       58  D1 008C9 	    CMPL    CUR_OPERATOR, #-1					      ;
				       03  13 008D0 	    BEQL    54$							      ;
				     034A  31 008D2 	    BRW     95$							      ;
				       55  D4 008D5 54$:    CLRL    FLAG						      ; 2632
		         57	       57  CE 008D7 	    MNEGL   CUR_VALUE, CUR_VALUE				      ; 2633
		         50	  90   AD  9E 008DA 	    MOVAB   EXPR_STACK, R0					      ; 2634
		         50	       5A  D1 008DE 	    CMPL    STACK_PTR, R0					      ;
				       0F  13 008E1 	    BEQL    55$							      ;
		         5A	       04  C2 008E3 	    SUBL2   #4, STACK_PTR					      ; 2637
	   7A	         08	       20  EE 008E6 	    EXTV    #32, #8, -(STACK_PTR), CUR_OPERATOR			      ; 2638
				       58     008EA									      ;
		    F8   BD	       57  D0 008EB 	    MOVL    CUR_VALUE, @LEX_STG_DESC+4				      ; 2639
		         57	       6A  D0 008EF 	    MOVL    (STACK_PTR), CUR_VALUE				      ; 2640
		         03	       55  E9 008F2 55$:    BLBC    FLAG, 56$						      ; 2649
				     031E  31 008F5 	    BRW     94$							      ;
				     FF71  31 008F8 56$:    BRW     47$							      ;
	      00000041   8F	       59  D1 008FB 57$:    CMPL    TOKEN_TYPE, #65					      ; 2346
				       09  13 00902 	    BEQL    58$							      ;
	      00000063   8F	       59  D1 00904 	    CMPL    TOKEN_TYPE, #99					      ;
				       4A  12 0090B 	    BNEQ    63$							      ;
		         28	  04   AE  E9 0090D 58$:    BLBC    NUMBER_FLAG, 59$					      ; 2663
			    00000000G  EF  D4 00911 	    CLRL    PAT$GL_BUF_SIZ					      ; 2669
		         50	       66  3C 00917 	    MOVZWL  (R6), R0						      ; 2671
00000000G  EF	    04   A6	       50  C1 0091A 	    ADDL3   R0, 4(R6), PAT$CP_OUT_STR				      ;
				       57  DD 00923 	    PUSHL   CUR_VALUE						      ; 2672
			    00000000'  EF  9F 00925 	    PUSHAB  EXP_STG						      ; 2209
	      00000000G  EF	       02  FB 0092B 	    CALLS   #2, PAT$FAO_PUT					      ; 2672
		         66 00000000G  EF  A0 00932 	    ADDW2   PAT$GL_BUF_SIZ, (R6)				      ; 2673
				       58  D5 00939 59$:    TSTL    CUR_OPERATOR					      ; 2680
				       03  13 0093B 	    BEQL    60$							      ;
				     FE95  31 0093D 	    BRW     33$							      ;
		         50	  90   AD  9E 00940 60$:    MOVAB   EXPR_STACK, R0					      ; 2690
		         50	       5A  D1 00944 	    CMPL    STACK_PTR, R0					      ;
				       03  13 00947 	    BEQL    61$							      ;
				     FD1C  31 00949 	    BRW     6$							      ;
				       66  B5 0094C 61$:    TSTW    (R6)						      ; 2696
				       03  12 0094E 	    BNEQ    62$							      ;
				     02DD  31 00950 	    BRW     97$							      ;
		         50	       01  D0 00953 62$:    MOVL    #1, R0						      ; 2700
					   04 00956 	    RET     							      ;
	      00000047   8F	       59  D1 00957 63$:    CMPL    TOKEN_TYPE, #71					      ; 2346
				       03  13 0095E 	    BEQL    64$							      ;
				     02BC  31 00960 	    BRW     95$							      ;
				  F4   AD  9F 00963 64$:    PUSHAB  LEX_STG_DESC					      ; 2722
	      00000000G  EF	       01  FB 00966 	    CALLS   #1, PAT$REG_MATCH					      ;
				       50  D5 0096D 	    TSTL    REG_NUM						      ;
				       13  19 0096F 	    BLSS    66$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-19
; Digital Equipment Corporation
;
		         0F	       50  D1 00971 	    CMPL    REG_NUM, #15					      ; 2723
				       0E  14 00974 	    BGTR    66$							      ;
				       56  DD 00976 65$:    PUSHL   R6							      ; 2729
				  F4   AD  9F 00978 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000V  EF	       02  FB 0097B 	    CALLS   #2, ADD_LEX_T_OPRND					      ;
				       79  11 00982 	    BRB     70$							      ; 2730
		         50	  F8   AD  D0 00984 66$:    MOVL    LEX_STG_DESC+4, LEXEME_PTR				      ; 2738
		         52	       60  90 00988 	    MOVB    (LEXEME_PTR), CHAR					      ; 2739
		         01	  F4   AD  B1 0098B 	    CMPW    LEX_STG_DESC, #1					      ; 2740
				       6F  12 0098F 	    BNEQ    71$							      ;
		    42   8F	       52  91 00991 	    CMPB    CHAR, #66						      ; 2742
				       18  13 00995 	    BEQL    67$							      ;
		    57   8F	       52  91 00997 	    CMPB    CHAR, #87						      ; 2743
				       12  13 0099B 	    BEQL    67$							      ;
		    4C   8F	       52  91 0099D 	    CMPB    CHAR, #76						      ; 2744
				       0C  13 009A1 	    BEQL    67$							      ;
		    49   8F	       52  91 009A3 	    CMPB    CHAR, #73						      ; 2745
				       06  13 009A7 	    BEQL    67$							      ;
		    53   8F	       52  91 009A9 	    CMPB    CHAR, #83						      ; 2746
				       51  12 009AD 	    BNEQ    71$							      ;
		         54	  00   BE  D0 009AF 67$:    MOVL    @0(SP), INS_PTR					      ; 2749
		         53	       64  90 009B3 	    MOVB    (INS_PTR), NEXT_CHAR				      ; 2750
		    5E   8F	       53  91 009B6 	    CMPB    NEXT_CHAR, #94					      ; 2751
				       44  12 009BA 	    BNEQ    71$							      ;
		  FF7D   CD	  5E   8F  90 009BC 	    MOVB    #94, LEX_BUF+1					      ; 2754
				  F4   AD  B6 009C2 	    INCW    LEX_STG_DESC					      ; 2755
				       6B  B7 009C5 	    DECW    (R11)						      ; 2756
				  00   BE  D6 009C7 	    INCL    @0(SP)						      ; 2757
				       56  DD 009CA 	    PUSHL   R6							      ; 2758
				  F4   AD  9F 009CC 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000V  EF	       02  FB 009CF 	    CALLS   #2, ADD_LEX_T_OPRND					      ;
		    42   8F	       52  91 009D6 	    CMPB    CHAR, #66						      ; 2759
				       07  12 009DA 	    BNEQ    68$							      ;
	      00000000'  EF	       01  88 009DC 	    BISB2   #1, BYTES_IN_OPRND					      ; 2761
		    57   8F	       52  91 009E3 68$:    CMPB    CHAR, #87						      ; 2762
				       07  12 009E7 	    BNEQ    69$							      ;
	      00000000'  EF	       02  88 009E9 	    BISB2   #2, BYTES_IN_OPRND					      ; 2764
		    4C   8F	       52  91 009F0 69$:    CMPB    CHAR, #76						      ; 2765
				       07  12 009F4 	    BNEQ    70$							      ;
	      00000000'  EF	       04  88 009F6 	    BISB2   #4, BYTES_IN_OPRND					      ; 2767
				     FBFD  31 009FD 70$:    BRW     2$							      ; 2768
				  14   AE  B4 00A00 71$:    CLRW    SYMBOL_DESC						      ; 2779
		    18   AE	  20   AE  9E 00A03 	    MOVAB   SYMBOL_BUF, SYMBOL_DESC+4				      ; 2780
		    1C   AE	0200   8F  B0 00A08 	    MOVW    #512, SYMBOL_DESC+8					      ; 2781
				  14   AE  9F 00A0E 	    PUSHAB  SYMBOL_DESC						      ; 2782
				  F4   AD  9F 00A11 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000V  EF	       02  FB 00A14 	    CALLS   #2, ADD_LEX_T_OPRND					      ;
				       7E  7C 00A1B 	    CLRQ    -(SP)						      ; 2783
				  F4   AD  9F 00A1D 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000G  EF	       03  FB 00A20 	    CALLS   #3, PAT$BUILD_PATH					      ;
		         10	       50  E8 00A27 	    BLBS    R0, 73$						      ;
			    006D80FA   8F  DD 00A2A 	    PUSHL   #7176442						      ; 2785
	      00000000G  00	       01  FB 00A30 	    CALLS   #1, LIB$SIGNAL					      ;
				     009F  31 00A37 72$:    BRW     78$							      ; 2783
		         54	  00   BE  D0 00A3A 73$:    MOVL    @0(SP), INS_PTR					      ; 2794

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-20
; Digital Equipment Corporation
;
		         53	       64  90 00A3E 74$:    MOVB    (INS_PTR), NEXT_CHAR				      ; 2796
		         20	       53  91 00A41 	    CMPB    NEXT_CHAR, #32					      ; 2797
				       F8  13 00A44 	    BEQL    74$							      ;
		         09	       53  91 00A46 	    CMPB    NEXT_CHAR, #9					      ;
				       F3  13 00A49 	    BEQL    74$							      ;
		    5C   8F	       53  91 00A4B 	    CMPB    NEXT_CHAR, #92					      ; 2798
				       E6  12 00A4F 	    BNEQ    72$							      ;
				  F4   AD  B4 00A51 	    CLRW    LEX_STG_DESC					      ; 2815
		    F8   AD	FF7C   CD  9E 00A54 	    MOVAB   LEX_BUF, LEX_STG_DESC+4				      ; 2816
		    FC   AD	       14  B0 00A5A 	    MOVW    #20, LEX_STG_DESC+8					      ; 2817
				  F4   AD  9F 00A5E 	    PUSHAB  LEX_STG_DESC					      ; 2818
				       5B  DD 00A61 	    PUSHL   R11							      ;
	      00000000V  EF	       02  FB 00A63 	    CALLS   #2, MAR_GET_LEX					      ;
		         52	       50  D0 00A6A 	    MOVL    R0, TEMP_TOKEN					      ;
		         3E	       52  D1 00A6D 	    CMPL    TEMP_TOKEN, #62					      ;
				       32  12 00A70 	    BNEQ    75$							      ;
				  14   AE  9F 00A72 	    PUSHAB  SYMBOL_DESC						      ; 2825
				  F4   AD  9F 00A75 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000V  EF	       02  FB 00A78 	    CALLS   #2, ADD_LEX_T_OPRND					      ;
				  F4   AD  B4 00A7F 	    CLRW    LEX_STG_DESC					      ; 2826
		    F8   AD	FF7C   CD  9E 00A82 	    MOVAB   LEX_BUF, LEX_STG_DESC+4				      ; 2827
		    FC   AD	       14  B0 00A88 	    MOVW    #20, LEX_STG_DESC+8					      ; 2828
				  F4   AD  9F 00A8C 	    PUSHAB  LEX_STG_DESC					      ; 2829
				       5B  DD 00A8F 	    PUSHL   R11							      ;
	      00000000V  EF	       02  FB 00A91 	    CALLS   #2, MAR_GET_LEX					      ;
		         52	       50  D0 00A98 	    MOVL    R0, TEMP_TOKEN					      ;
	      00000047   8F	       52  D1 00A9B 	    CMPL    TEMP_TOKEN, #71					      ;
				       09  13 00AA2 	    BEQL    76$							      ;
			    006D8233   8F  DD 00AA4 75$:    PUSHL   #7176755						      ; 2833
				     0178  31 00AAA 	    BRW     96$							      ;
				       7E  7C 00AAD 76$:    CLRQ    -(SP)						      ; 2837
				  F4   AD  9F 00AAF 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000G  EF	       03  FB 00AB2 	    CALLS   #3, PAT$BUILD_PATH					      ;
		         0D	       50  E8 00AB9 	    BLBS    R0, 77$						      ;
			    006D80FA   8F  DD 00ABC 	    PUSHL   #7176442						      ; 2839
	      00000000G  00	       01  FB 00AC2 	    CALLS   #1, LIB$SIGNAL					      ;
				  14   AE  9F 00AC9 77$:    PUSHAB  SYMBOL_DESC						      ; 2840
				  F4   AD  9F 00ACC 	    PUSHAB  LEX_STG_DESC					      ;
	      00000000V  EF	       02  FB 00ACF 	    CALLS   #2, ADD_LEX_T_OPRND					      ;
				     FF61  31 00AD6 	    BRW     73$							      ; 2788
				  14   AE  9F 00AD9 78$:    PUSHAB  SYMBOL_DESC						      ; 2852
	      00000000G  EF	       01  FB 00ADC 	    CALLS   #1, PAT$FIND_SYM					      ;
		         52	       50  D0 00AE3 	    MOVL    R0, STATUS						      ;
				       26  12 00AE6 	    BNEQ    79$							      ; 2853
		         54 00000000G  EF  D0 00AE8 	    MOVL    PAT$GL_SYMTBPTR, TEMP_SYMTB_PTR			      ; 2862
	      00000000G  EF 00000000G  EF  D0 00AEF 	    MOVL    PAT$GL_OLDLABLS, PAT$GL_SYMTBPTR			      ; 2863
				  14   AE  9F 00AFA 	    PUSHAB  SYMBOL_DESC						      ; 2864
	      00000000G  EF	       01  FB 00AFD 	    CALLS   #1, PAT$FIND_SYM					      ;
		         52	       50  D0 00B04 	    MOVL    R0, STATUS						      ;
	      00000000G  EF	       54  D0 00B07 	    MOVL    TEMP_SYMTB_PTR, PAT$GL_SYMTBPTR			      ; 2865
				       52  D5 00B0E 79$:    TSTL    STATUS						      ; 2867
				       0A  13 00B10 	    BEQL    80$							      ;
		    10   AE	  08   A2  D0 00B12 	    MOVL    8(STATUS), TEMP_VALUE				      ; 2875
		         52	       03  D0 00B17 	    MOVL    #3, STATUS						      ; 2876
				       11  11 00B1A 	    BRB     81$							      ; 2867

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-21
; Digital Equipment Corporation
;
				       7E  D4 00B1C 80$:    CLRL    -(SP)						      ; 2879
				  14   AE  9F 00B1E 	    PUSHAB  TEMP_VALUE						      ;
				       7E  D4 00B21 	    CLRL    -(SP)						      ;
	      00000000G  EF	       03  FB 00B23 	    CALLS   #3, PAT$BUILD_PATH					      ;
		         52	       50  D0 00B2A 	    MOVL    R0, STATUS						      ;
		         09	       52  E9 00B2D 81$:    BLBC    STATUS, 82$						      ; 2880
		         03	       52  D1 00B30 	    CMPL    STATUS, #3						      ; 2881
				       4D  12 00B33 	    BNEQ    85$							      ;
		         49	  0C   AC  E8 00B35 	    BLBS    USER_SYM_FLAG, 85$					      ;
				  F4   AD  B4 00B39 82$:    CLRW    LEX_STG_DESC					      ; 2900
		    F8   AD	FF7C   CD  9E 00B3C 	    MOVAB   LEX_BUF, LEX_STG_DESC+4				      ; 2901
				  F4   AD  9F 00B42 	    PUSHAB  LEX_STG_DESC					      ; 2902
				       5B  DD 00B45 	    PUSHL   R11							      ;
	      00000000V  EF	       02  FB 00B47 	    CALLS   #2, MAR_GET_LEX					      ;
		         59	       50  D0 00B4E 	    MOVL    R0, TOKEN_TYPE					      ;
	      00000045   8F	       59  D1 00B51 	    CMPL    TOKEN_TYPE, #69					      ; 2903
				       07  12 00B58 	    BNEQ    83$							      ;
	      00000000'  EF	       08  88 00B5A 	    BISB2   #8, BYTES_IN_OPRND					      ; 2905
	      00000063   8F	       59  D1 00B61 83$:    CMPL    TOKEN_TYPE, #99					      ; 2907
				       09  13 00B68 	    BEQL    84$							      ;
	      00000041   8F	       59  D1 00B6A 	    CMPL    TOKEN_TYPE, #65					      ;
				       C6  12 00B71 	    BNEQ    82$							      ;
	   66	    00   BE	  0C   AE  A3 00B73 84$:    SUBW3   INS_START_PTR, @0(SP), (R6)				      ; 2909
		    04   A6	  0C   AE  D0 00B79 	    MOVL    INS_START_PTR, 4(R6)				      ; 2910
		         50	       03  D0 00B7E 	    MOVL    #3, R0						      ; 2911
					   04 00B81 	    RET     							      ;
				       58  D5 00B82 85$:    TSTL    CUR_OPERATOR					      ; 2917
				       07  12 00B84 	    BNEQ    86$							      ;
		         57	  10   AE  D0 00B86 	    MOVL    TEMP_VALUE, CUR_VALUE				      ; 2919
				     0089  31 00B8A 	    BRW     94$							      ; 2917
		         55	       01  D0 00B8D 86$:    MOVL    #1, FLAG						      ; 2923
	      FFFFFFFF   8F	       58  D1 00B90 	    CMPL    CUR_OPERATOR, #-1					      ; 2924
				       04  12 00B97 	    BNEQ    87$							      ;
		         57	  10   AE  D0 00B99 	    MOVL    TEMP_VALUE, CUR_VALUE				      ; 2926
	      0000004C   8F	       58  D1 00B9D 87$:    CMPL    CUR_OPERATOR, #76					      ; 2927
				       06  12 00BA4 	    BNEQ    88$							      ;
		         57	  10   AE  C0 00BA6 	    ADDL2   TEMP_VALUE, CUR_VALUE				      ; 2929
				       64  11 00BAA 	    BRB     93$							      ; 2927
	      00000046   8F	       58  D1 00BAC 88$:    CMPL    CUR_OPERATOR, #70					      ;
				       06  12 00BB3 	    BNEQ    89$							      ;
		         57	  10   AE  C2 00BB5 	    SUBL2   TEMP_VALUE, CUR_VALUE				      ; 2930
				       55  11 00BB9 	    BRB     93$							      ; 2927
		         3C	       58  D1 00BBB 89$:    CMPL    CUR_OPERATOR, #60					      ;
				       06  12 00BBE 	    BNEQ    90$							      ;
		         57	  10   AE  C4 00BC0 	    MULL2   TEMP_VALUE, CUR_VALUE				      ; 2931
				       4A  11 00BC4 	    BRB     93$							      ; 2927
	      00000052   8F	       58  D1 00BC6 90$:    CMPL    CUR_OPERATOR, #82					      ;
				       06  12 00BCD 	    BNEQ    91$							      ;
		         57	  10   AE  C6 00BCF 	    DIVL2   TEMP_VALUE, CUR_VALUE				      ; 2932
				       3B  11 00BD3 	    BRB     93$							      ; 2927
		         3D	       58  D1 00BD5 91$:    CMPL    CUR_OPERATOR, #61					      ;
				       07  12 00BD8 	    BNEQ    92$							      ;
	   57	         57	  10   AE  78 00BDA 	    ASHL    TEMP_VALUE, CUR_VALUE, CUR_VALUE			      ; 2933
				       2F  11 00BDF 	    BRB     93$							      ; 2927
	      00000044   8F	       58  D1 00BE1 92$:    CMPL    CUR_OPERATOR, #68					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 7-22
; Digital Equipment Corporation
;
				       26  13 00BE8 	    BEQL    93$							      ;
	      FFFFFFFF   8F	       58  D1 00BEA 	    CMPL    CUR_OPERATOR, #-1					      ;
				       2C  12 00BF1 	    BNEQ    95$							      ;
				       55  D4 00BF3 	    CLRL    FLAG						      ; 2938
		         57	       57  CE 00BF5 	    MNEGL   CUR_VALUE, CUR_VALUE				      ; 2939
		         50	  90   AD  9E 00BF8 	    MOVAB   EXPR_STACK, R0					      ; 2940
		         50	       5A  D1 00BFC 	    CMPL    STACK_PTR, R0					      ;
				       0F  13 00BFF 	    BEQL    93$							      ;
		         5A	       04  C2 00C01 	    SUBL2   #4, STACK_PTR					      ; 2943
	   7A	         08	       20  EE 00C04 	    EXTV    #32, #8, -(STACK_PTR), CUR_OPERATOR			      ; 2944
				       58     00C08									      ;
		    10   AE	       57  D0 00C09 	    MOVL    CUR_VALUE, TEMP_VALUE				      ; 2945
		         57	       6A  D0 00C0D 	    MOVL    (STACK_PTR), CUR_VALUE				      ; 2946
		         03	       55  E8 00C10 93$:    BLBS    FLAG, 94$						      ; 2955
				     FF77  31 00C13 	    BRW     86$							      ;
				       58  D4 00C16 94$:    CLRL    CUR_OPERATOR					      ; 2956
		    04   AE	       01  D0 00C18 	    MOVL    #1, NUMBER_FLAG					      ; 2957
				     F9DE  31 00C1C 	    BRW     2$							      ; 2346
			    006D822B   8F  DD 00C1F 95$:    PUSHL   #7176747						      ; 2963
	      00000000G  00	       01  FB 00C25 96$:    CALLS   #1, LIB$SIGNAL					      ;
		         50	       02  D0 00C2C 	    MOVL    #2, R0						      ; 2964
					   04 00C2F 	    RET     							      ;
				       50  D4 00C30 97$:    CLRL    R0							      ; 2209
					   04 00C32 	    RET     							      ;

; Routine Size:  1655 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8
; Digital Equipment Corporation
;
;	2970	ROUTINE ENC_OPERAND ( INST_STG_DESC, OUT_BYTE_STREAM, PC_REL_CONTEXT, BRANCH_SIZE, OUT_PC_PTR, OPINFO_PTR ) =
;	2971	
;	2972	!++
;	2973	! Functional Description:
;	2974	!
;	2975	!	Scan (parse, whatever) the string that supposedly
;	2976	!	represents one operand reference, and come up
;	2977	!	with the machine code representation for it. 
;	2978	!
;	2979	! Inputs:
;	2980	!
;	2981	!	INST_STG_DESC	-A pointer to the counted string that
;	2982	!			 contains the operand reference.
;	2983	!	OUT_BYTE_STREAM	-A pointer to the output byte stream pointer
;	2984	!			 that is being maintained by the routine
;	2985	!			 we are called by.
;	2986	!	PC_REL_CONTEXT	-The number of bytes that we should encode
;	2987	!			 into the output byte stream to correspond to
;	2988	!			 a PC-relative (literal) operand.  
;	2989	!	BRANCH_SIZE	-The number of  bytes that we should allow
;	2990	!			 if the current operand tries to use branch
;	2991	!			 type addressing.  0 => do not allow branch operands.
;	2992	!	OUT_PC_PTR	-A pointer to the pointer that we maintain that
;	2993	!			 indicates where the next byte of instruction we
;	2994	!			 generate will go.  This is used to calculate
;	2995	!			 PC-displacement values.
;	2996	!
;	2997	! Implicit Inputs:
;	2998	!
;	2999	!	None.
;	3000	!
;	3001	! Outputs:
;	3002	!
;	3003	!	The bytes that correspond to the operand reference are
;	3004	!	stuffed into the vector pointed to by the pointer
;	3005	!	contained in the location pointed to by OUT_BYTE_STREAM.
;	3006	!	This pointer is also updated so that it points to the
;	3007	!	next vacant byte position.
;	3008	!
;	3009	! Routine Value:
;	3010	!
;	3011	!	TRUE - If successfully encoded.
;	3012	!	PAT$K_BR_RANGE - If branch offset exceeds range allowed for instruction.
;	3013	!	SIGNALs if an error is found and returns FALSE for the caller to
;	3014	!	output the instruction.
;	3015	!
;	3016	! Side Effects:
;	3017	!
;	3018	!	None.
;	3019	!--
;	3020	
;	3021	BEGIN
;	3022	MAP
;	3023		!++
;	3024		! The reason why the following 2 are REFs to LONGs instead of to BYTEs

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-1
; Digital Equipment Corporation
;
;	3025		! is because they are actually REF REF VECTOR[,BYTE], which we can only
;	3026		! achieve (so far!?) via a REF LONG.  Even this only works because LONG
;	3027		! happens to be the size of a REF BYTE (or of any REF, for that matter).
;	3028		!--
;	3029		OPINFO_PTR : REF BLOCK[OPTSIZE, BYTE],
;	3030		OUT_PC_PTR : REF VECTOR[,LONG],
;	3031		OUT_BYTE_STREAM : REF VECTOR[,LONG],
;	3032		INST_STG_DESC : REF BLOCK [, BYTE];
;	3033	
;	3034	LOCAL
;	3035		TOKEN_STRING : VECTOR[ CHS_PER_LEXEME, BYTE],
;	3036		LEXEME_BUFFER : VECTOR[ CHS_PER_LEXEME, BYTE],
;	3037		lexeme_stg_desc : BLOCK [12, BYTE],
;	3038		OUT_BYTE_PTR : REF VECTOR[,BYTE],
;	3039		TOKEN_TYPE : BYTE,
;	3040		AT_FLAG,
;	3041		MODE;
;	3042	
;	3043	BIND
;	3044		TOKEN_LONG = TOKEN_STRING : VECTOR[,LONG];
;	3045	
;	3046	MACRO
;	3047		!++
;	3048		! This macro is used to call the routine to check for indexing and
;	3049		! actually output the bytes of 'instruction' into the instruction
;	3050		! stream.  The reason why we use this macro is because it inserts the
;	3051		! first 2 parameters for us, (we may later use GLOBALs for this),
;	3052		! and because we may later have to make the control string parameter a
;	3053		! counted string if we find that 4 characters (a longword) are not enough.
;	3054		!--
;	3055		OUT_CODE ( CTRL_STRING ) =
;     M 3056			BEGIN
;     M 3057			IF (NOT INST_OUTPUT (	.OUT_BYTE_STREAM,
;     M 3058						.OUT_PC_PTR,
;     M 3059						.INST_STG_DESC,
;     M 3060						CTRL_STRING,
;     M 3061						%REMAINING
;     M 3062					    ) )
;     M 3063			THEN
;     M 3064				RETURN FALSE;
;     M 3065			END
;     M 3066			%,
;	3067	
;	3068		!++
;	3069		! How we usually make up the dominant mode addressing byte.
;	3070		!--
;	3071		MAKE_A_MODE ( DMODE ) =
;     M 3072			( (DMODE ^ 4) OR .TOKEN_STRING[0])
;     M 3073			%,
;	3074	
;	3075		!++
;	3076		! This macro creates the dominant mode for PC addressing.
;	3077		!--
;	3078		MAKE_PC_MODE ( DMODE ) =
;     M 3079			( (DMODE ^4) OR PC_REG )

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-2
; Digital Equipment Corporation
;
;     M 3080			%;
;	3081	
;	3082	!++
;	3083	! Fetch the first token from the instruction string, and take action depending
;	3084	! on it.  If the first token is an 'at' sign, simply set a flag for later
;	3085	! reference, extract the next token, and continue on.
;	3086	!--
;	3087	AT_FLAG = FALSE;
;	3088	OUT_BYTE_PTR = .OUT_BYTE_STREAM[0];
;	3089	IF ((TOKEN_TYPE = GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_STRING)) EQL AT_SIGN_TOKEN)
;	3090	THEN
;	3091		BEGIN
;	3092		AT_FLAG = TRUE;
;	3093		TOKEN_TYPE = GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_STRING);
;	3094		END;
;	3095	
;	3096	!++
;	3097	! Enforce branch-type syntax only when a branch operand
;	3098	! is expected, and vice versa.
;	3099	!--
;	3100	IF (.TOKEN_TYPE NEQ BRANCH_TOKEN)
;	3101	THEN
;	3102		IF (.BRANCH_SIZE NEQ 0)
;	3103		THEN
;	3104			BEGIN
;	3105			SIGNAL(PAT$_NOBRANCH+MSG$K_INFO);		! "Branch Operand Expected" error.
;	3106			RETURN(FALSE);
;	3107			END;
;	3108	
;	3109	SELECTONE .TOKEN_TYPE OF
;	3110		SET
;	3111	
;	3112		[REGISTER_TOKEN]:
;	3113	
;	3114			!++
;	3115			! The operand is Rn, where 'n' was returned in the TOKEN_STRING.
;	3116			! Output the proper addressing mode byte, and increment the 
;	3117			! instruction stream pointer.  Note that indexing is not allowed
;	3118			! to follow REGISTER. Neither is the old MACRO11 notion of @Rx.
;	3119			!--
;	3120			BEGIN
;	3121			IF .AT_FLAG
;	3122			THEN
;	3123				BEGIN
;	3124				SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);	! "@Rx not equivalent to (Rx)" error.
;	3125				RETURN(FALSE);
;	3126				END
;	3127			ELSE
;	3128				OUT_CODE ( 'NB', (REGISTER_AMODE^4) OR .TOKEN_STRING[0] );
;	3129			END;
;	3130	
;	3131		[ABS_LIT_TOKEN]:
;	3132			!++
;	3133			! This is either 'short literal', 'PC-Relative Literal', or
;	3134			! Absolute addressing, depending on whether the string began

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-3
; Digital Equipment Corporation
;
;	3135			! with '@' or not, and on the number of bits needed to encode
;	3136			! the number.
;	3137			!--
;	3138			IF .AT_FLAG
;	3139			THEN
;	3140				!++
;	3141				! Absolute addressing is actually a PC-relative
;	3142				! mode with longword context.  Note that this
;	3143				! one may be followed by [ Rx ], which means
;	3144				! that we have indexing.
;	3145				!--
;	3146				OUT_CODE( 'YBD',
;     P 3147					  MAKE_PC_MODE(AT_PC_REL_MODE),
;     P 3148					  A_LONGWORD,
;     P 3149					  TOKEN_STRING)
;	3150			ELSE
;	3151				!++
;	3152				! This is an immediate operand.  If it will fit into 6
;	3153				! bits, generate 'short literal' addressing, otherwise
;	3154				! generate a PC-relative (immediate) mode.
;	3155				!--	
;	3156				IF (.TOKEN_LONG[0] GTRU 63)
;	3157				THEN
;	3158					BEGIN
;	3159					!++
;	3160					! The literal is too big for a 6-bit field.
;	3161					! Therefore use a PC-relative mode and insert
;	3162					! the literal into the instruction stream.
;	3163					! Unfortunately, the number of bits to use is
;	3164					! NOT a function of how large the literal is,
;	3165					! instead this is dictated by the so-called
;	3166					! 'context' of this instruction.
;	3167					!--
;	3168					IF (.PC_REL_CONTEXT GTR A_LONGWORD)
;	3169					THEN
;	3170						BEGIN
;	3171						!++
;	3172						! QUADword literals not supported.
;	3173						! GET_NEXT_TOKEN (i.e. PAT$RADX_CONVRT)
;	3174						! would have to be changed to insert 8
;	3175						! bytes into TOKEN_STRING.
;	3176						!--
;	3177						SIGNAL (PAT$_NOTDONE+MSG$K_INFO);
;	3178						RETURN(FALSE);
;	3179						END;
;	3180		
;	3181					!++
;	3182					! See if truncation will occur by checking
;	3183					! on whether the longword which the number is
;	3184					! taken from is different from the number as
;	3185					! extracted by the hardware - ie, with sign extension.
;	3186					!--
;	3187					IF (.TOKEN_LONG[0] NEQ
;	3188					    .(TOKEN_STRING[0])<0,.PC_REL_CONTEXT*BITS_PER_BYTE, 1>)
;	3189					THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-4
; Digital Equipment Corporation
;
;	3190						! The following code may be eliminated 
;	3191						! when RADX_CONVRT takes the length into
;	3192						! account.  For now a further check is
;	3193						! made to see if the bits discarded 
;	3194						! simply weren't given.
;	3195						!--
;	3196						INCR I FROM .PC_REL_CONTEXT TO LONG_LENGTH -1
;	3197							DO
;	3198							IF (.TOKEN_STRING[.I] NEQ 0)
;	3199							THEN
;	3200								BEGIN
;	3201								SIGNAL (PAT$_NUMTRUNC);
;	3202								EXITLOOP;
;	3203								END;
;	3204	
;	3205					!++
;	3206					! SRM says that #constant[Rx] is
;	3207					! supported, however, to be like MARS,
;	3208					! PATCH generates an error for it.
;	3209					!--
;	3210					OUT_CODE( 'NBD',
;     P 3211						  MAKE_PC_MODE( PC_REL_MODE ),
;     P 3212						  .PC_REL_CONTEXT,
;     P 3213						  TOKEN_STRING)
;	3214					END
;	3215				ELSE
;	3216					!++
;	3217					! Short literals have to fit in 6 bits.
;	3218					! They also can not be indexed.
;	3219					!--
;	3220					OUT_CODE( 'NB', MAKE_A_MODE( SHORT_LIT_AMODE ) );
;	3221	
;	3222	
;	3223		[BRANCH_TOKEN]:			! For branch type operand addressing,
;	3224						! and for assumed PC-displacement addressing.
;	3225			BEGIN
;	3226			BIND
;	3227				ACTUAL_OPRND = TOKEN_STRING[1] : VECTOR[,LONG];
;	3228	
;	3229			!++
;	3230			! Check the flag passed in byte 0 of the token string.  A zero
;	3231			! here means that the associated number is a branch operand
;	3232			! exactly what is to be placed in the instruction.  A 1 here
;	3233			! means that the number must be made into a PC-relative offset
;	3234			! - ie, it is absolute, and that it may or may not be a branch
;	3235			! operand.
;	3236			!--
;	3237			IF (.TOKEN_STRING[0]) AND (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)
;	3238			THEN
;	3239				BEGIN
;	3240				!++
;	3241				! To calculate the PC-relative value, start with a
;	3242				! pointer to where the actual operand will be placed,
;	3243				! add in the length of the operand because that will
;	3244				! be the VAX PC after it has been used to

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-5
; Digital Equipment Corporation
;
;	3245				! pick up the operand, and then subtract
;	3246				! from that the absolute (virtual) destination.
;	3247				! This gives the number of bytes which have to be
;	3248				! added to the PC to get the address of the destination
;	3249				!--
;	3250				ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] - (.OUT_PC_PTR[0] + .BRANCH_SIZE);
;	3251				IF (.BRANCH_SIZE EQL 0)
;	3252				THEN
;	3253					!++
;	3254					! If BRANCH_SIZE is not the right size
;	3255					! (of displacement) to add, assume and use
;	3256					! LONGWORD displacement. Take into consideration
;	3257					! the fact that there will be a 1-byte MODE
;	3258					! field before the displacement, and perhaps
;	3259					! also a 1-byte index field, as well as the
;	3260					! displacement itself.
;	3261					!--
;	3262					ACTUAL_OPRND[0] = .ACTUAL_OPRND[0]
;	3263							- (A_LONGWORD + A_BYTE +
;	3264								ASSUME_AT_PC(.INST_STG_DESC));
;	3265			END;
;	3266	
;	3267			!++
;	3268			! Check for branch overflow - the user trying to branch further
;	3269			! than the instruction can 'reach'.  First, check this is a branch.
;	3270			!--
;	3271			IF (.BRANCH_SIZE NEQ 0)
;	3272			THEN
;	3273				BEGIN
;	3274				!++
;	3275				! Overflow happens when all bits in the unused part of
;	3276				! the LONG which we are using to contain the branch
;	3277				! operand are not the same as the 'sign' bit of the
;	3278				! branch operand.  We find this out by extracting the
;	3279				! branch operand as the hardware would (ie, with sign
;	3280				! extension), and then comparing to see if this is the
;	3281				! same as what we have calculated.
;	3282				! For assembler directives, there is no such thing as
;	3283				! the "sign bit".  Therefore the test is made with a
;	3284				! zero extend extraction.
;	3285				!--	
;	3286				IF (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)
;	3287				THEN
;	3288					BEGIN
;	3289					IF (.ACTUAL_OPRND[0] NEQ
;	3290						 .(ACTUAL_OPRND)<0,.BRANCH_SIZE*BITS_PER_BYTE, 1>)
;	3291					THEN
;	3292						!++
;	3293						! "Branching Out-of-Range" error.
;	3294						!--
;	3295						BEGIN
;	3296						PAT$GL_BR_DISPL = .ACTUAL_OPRND[0];
;	3297						OUT_CODE('ND', .BRANCH_SIZE, ACTUAL_OPRND[0]);
;	3298						RETURN(PAT$K_BR_RANGE);
;	3299						END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-6
; Digital Equipment Corporation
;
;	3300					END
;	3301				ELSE
;	3302					BEGIN
;	3303					IF (.ACTUAL_OPRND[0] NEQ
;	3304						 .(ACTUAL_OPRND)<0,.BRANCH_SIZE*BITS_PER_BYTE, 0>)
;	3305					THEN
;	3306						SIGNAL(PAT$_NUMTRUNC);
;	3307					END;
;	3308		
;	3309				!++
;	3310				! Branch operand is OK.  Output
;	3311				! the code and don't allow indexing.
;	3312				!--
;	3313				OUT_CODE('ND', .BRANCH_SIZE, ACTUAL_OPRND[0]);
;	3314				END
;	3315			ELSE
;	3316				BEGIN
;	3317				!++
;	3318				! PC-displacement operands are similar at this point
;	3319				! except that indexing must be allowed and longword
;	3320				! (deferred) displacement.  This code is the same as
;	3321				! that at the end of case [BYTE_VAL_TOKEN], etc, below;
;	3322				! PATCH relys on the compiler to combine the code rather
;	3323				! than putting it into a special-purpose routine.
;	3324				!--
;	3325				LEXEME_BUFFER[0] = PC_REG;
;	3326				TOKEN_STRING[0] = A_LONGWORD;
;	3327				MODE = DISP_LONG_AMODE;
;	3328				IF .AT_FLAG
;	3329				THEN
;	3330					MODE = .MODE +1;
;	3331	
;	3332				!++
;	3333				! Pass back the single mode byte followed by the counted
;	3334				! byte stream calculated.  Indexing is allowed in all cases.
;	3335				!--
;	3336				OUT_CODE( 'YBC',
;     P 3337					  ((.MODE^4) OR .LEXEME_BUFFER[0]),
;     P 3338					  TOKEN_STRING);
;	3339				END;
;	3340			END;
;	3341		
;	3342	
;	3343		[MINUS_TOKEN]:
;	3344			BEGIN
;	3345			!++
;	3346			! This must be auto decrement, '-(Rn)', or
;	3347			! auto decrement indexed, '-(Rn)[Rx]'.
;	3348			!--
;	3349			IF (GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_STRING) NEQ AT_REG_TOKEN)
;	3350			THEN
;	3351				BEGIN
;	3352				SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);	! (Rn) required for auto-decrement
;	3353				RETURN(FALSE);
;	3354				END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-7
; Digital Equipment Corporation
;
;	3355	
;	3356			!++
;	3357			! Check for indexing and output the instruction.
;	3358			!--
;	3359			IF .AT_FLAG 
;	3360			THEN
;	3361				BEGIN
;	3362				!++
;	3363				! "Deferred Auto Decrement Not Allowed" error.
;	3364				!--
;	3365				SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);
;	3366				RETURN(FALSE);
;	3367				END
;	3368			ELSE
;	3369				OUT_CODE('YB', MAKE_A_MODE(AUTO_DEC_AMODE));
;	3370			END;
;	3371	
;	3372	
;	3373		[AT_REG_TOKEN]:
;	3374			BEGIN
;	3375	
;	3376			LOCAL
;	3377				INPUT_PTR,
;	3378				CHAR;
;	3379	
;	3380			!++
;	3381			! This form is either register deferred, '(reg)', auto increment,
;	3382			! '(reg)+', auto increment deferred, '@(reg)+', or any one of
;	3383			! these plus indexing.
;	3384			!--
;	3385			MODE = REG_DEF_AMODE;
;	3386	
;	3387			!++
;	3388			! A following '+' indicates one of the auto inc modes.
;	3389			!--
;	3390			INPUT_PTR = .INST_STG_DESC [dsc$a_pointer];
;	3391			CHAR = CH$RCHAR (.INPUT_PTR);
;	3392			IF (.CHAR EQL '+')
;	3393			THEN
;	3394				BEGIN
;	3395				!++
;	3396				! Update the counted-string pointer,
;	3397				! and decide which auto inc mode we have.
;	3398				!--
;	3399				MODE = AUTO_INC_AMODE;
;	3400				IF .AT_FLAG
;	3401				THEN
;	3402					MODE = .MODE +1;
;	3403					! MODE = AUTO_INC_DEF_AMODE;  ! Generates longer code.
;	3404				INST_STG_DESC [dsc$a_pointer] = CH$PLUS (.INPUT_PTR, 1);
;	3405				INST_STG_DESC [DSC$W_LENGTH] = .INST_STG_DESC [DSC$W_LENGTH] - 1;
;	3406				END
;	3407			ELSE
;	3408				IF .AT_FLAG
;	3409				THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-8
; Digital Equipment Corporation
;
;	3410					BEGIN
;	3411					SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);! "@(Rn) Not Supported" error.
;	3412					RETURN(FALSE);
;	3413					END;
;	3414	
;	3415			!++
;	3416			! In all cases PATCH allows indexing.
;	3417			!--
;	3418			OUT_CODE( 'YB', MAKE_A_MODE( .MODE ) );
;	3419			END;
;	3420	
;	3421		[BYTE_VAL_TOKEN,
;	3422		 WORD_VAL_TOKEN,
;	3423		 LONG_VAL_TOKEN]:
;	3424			BEGIN
;	3425			BIND
;	3426				ACTUAL_OPRND = TOKEN_STRING[1] : VECTOR[,LONG];
;	3427			LOCAL
;	3428				INDEXING;
;	3429			
;	3430			!++
;	3431			! Displacement or Deferred Displacement addressing.
;	3432			!
;	3433			! Here PATCH must 'look ahead' to see if an actual register to
;	3434			! displace off has been given.  If not, assume "(PC)" and 
;	3435			! treat the displacement as a virtual address, calculating what
;	3436			! real displacement must be used given that the PC is the same
;	3437			! as the address into which the instruction is being deposited.
;	3438			!--
;	3439			IF ((INDEXING = ASSUME_AT_PC(.INST_STG_DESC)) GEQ 0)
;	3440			THEN
;	3441				BEGIN
;	3442				!++
;	3443				! Ok to assume PC-displacement mode.  This means that
;	3444				! the given displacement is the virtual address to be
;	3445				! reached, so this field must be converted to a real
;	3446				! displacement.  To do this PATCH calculates what the PC
;	3447				! will be after it has been used to pick up the
;	3448				! displacement to find out how much this displacement
;	3449				! must be.   The INDEXING value returned above indicates
;	3450				! how many bytes will be output due to indexed addressing.
;	3451				!--
;	3452				ACTUAL_OPRND[0] = .ACTUAL_OPRND[0]
;	3453						- (.OUT_PC_PTR[0] + .TOKEN_STRING[0] + A_BYTE + .INDEXING);
;	3454	
;	3455				!++
;	3456				! Also fake the user having said "(PC)"
;	3457				! by filling in LEXEME_BUFFER with the
;	3458				! right AT_REGister name.
;	3459				!--
;	3460				LEXEME_BUFFER[0] = PC_REG;
;	3461	
;	3462				!++
;	3463				! Check for trying to branch too far.  Here, the check
;	3464				! must be ensuring that the unused bits in the LONG

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-9
; Digital Equipment Corporation
;
;	3465				! version of ACTUAL_OPRND are the same as the sign bit
;	3466				! of the actual displacement part of ACTUAL_OPRND.
;	3467				!--
;	3468				REPEAT
;	3469					BEGIN
;	3470					IF (.ACTUAL_OPRND[0] NEQ
;	3471					    .(ACTUAL_OPRND)<0,.TOKEN_STRING[0]*BITS_PER_BYTE, 1>)
;	3472					THEN
;	3473						IF (.PAT$GL_CONTEXT[INST_SUBST]) AND
;	3474						   (.TOKEN_STRING[0] LSS LONG_LENGTH)
;	3475						THEN
;	3476							BEGIN
;	3477							ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] + .TOKEN_STRING[0];
;	3478							IF (.TOKEN_TYPE EQL BYTE_VAL_TOKEN)
;	3479							THEN
;	3480								BEGIN
;	3481								TOKEN_STRING[0] = WORD_LENGTH;
;	3482								TOKEN_TYPE = WORD_VAL_TOKEN;
;	3483								END
;	3484							ELSE
;	3485								BEGIN
;	3486								TOKEN_STRING[0] = LONG_LENGTH;
;	3487								TOKEN_TYPE = LONG_VAL_TOKEN;
;	3488								END;
;	3489							ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] - .TOKEN_STRING[0];
;	3490							END
;	3491						ELSE
;	3492							BEGIN
;	3493							SIGNAL(PAT$_BRTOOFAR+MSG$K_INFO, 1, .ACTUAL_OPRND[0]);
;	3494							EXITLOOP;
;	3495							END
;	3496					ELSE
;	3497						EXITLOOP;
;	3498					END;
;	3499				END
;	3500			ELSE
;	3501				BEGIN
;	3502				!++
;	3503				! Check that the displacement is followed
;	3504				! by a register reference in parenthesis.
;	3505				!--
;	3506				IF (GET_NEXT_TOKEN(.INST_STG_DESC, LEXEME_BUFFER) NEQ AT_REG_TOKEN)
;	3507				THEN
;	3508					BEGIN
;	3509					SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO); ! "Must Displace off a Reg" error.
;	3510					RETURN(FALSE);
;	3511					END;
;	3512	
;	3513				!++
;	3514				! Check for displacement truncation and produce a
;	3515				! message if this will occur.  Here the check is based
;	3516				! on the sign bit of the actual displacement, as done
;	3517				! to check this above.  Here, however, check whether or
;	3518				! not the upper bits of the given displacement are all
;	3519				! 0, and 'forgive' if this is true.  This nonsense is

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-10
; Digital Equipment Corporation
;
;	3520				! necessary to avoid complaining when one says
;	3521				! "B^95(reg)".  Here the 95 is taken as a negative
;	3522				! number rather than assuming a large positive one was
;	3523				! intended.
;	3524				!--	
;	3525				IF (.ACTUAL_OPRND[0] NEQ
;	3526				    .(ACTUAL_OPRND)<0,.TOKEN_STRING[0]*BITS_PER_BYTE, 1 >)
;	3527				THEN
;	3528					!++
;	3529					! When RADX_CONVRT is changed to take size into
;	3530					! account (ie, to complain if the number is too
;	3531					! big), just produce a message at this point.
;	3532					! For now, however, ignore it if the unused
;	3533					! bytes are all zero.
;	3534					!--	
;	3535					BEGIN
;	3536		
;	3537					BIND
;	3538						ACTUAL_BYTES = ACTUAL_OPRND[0] : VECTOR[,BYTE];
;	3539		
;	3540					INCR I FROM .TOKEN_STRING[0] TO LONG_LENGTH -1
;	3541						DO
;	3542						IF(.ACTUAL_BYTES[.I] NEQ 0)
;	3543						THEN
;	3544							BEGIN
;	3545							REPEAT
;	3546								BEGIN
;	3547								IF (.ACTUAL_OPRND[0] NEQ
;	3548								    .(ACTUAL_OPRND)<0,.TOKEN_STRING[0]*BITS_PER_BYTE, 1>)
;	3549								THEN
;	3550									IF (.PAT$GL_CONTEXT[INST_SUBST]) AND
;	3551									   (.TOKEN_STRING[0] LSS LONG_LENGTH)
;	3552									THEN
;	3553										BEGIN
;	3554										ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] + .TOKEN_STRING[0];
;	3555										IF (.TOKEN_TYPE EQL BYTE_VAL_TOKEN)
;	3556										THEN
;	3557											BEGIN
;	3558											TOKEN_STRING[0] = WORD_LENGTH;
;	3559											TOKEN_TYPE = WORD_VAL_TOKEN;
;	3560											END
;	3561										ELSE
;	3562											BEGIN
;	3563											TOKEN_STRING[0] = LONG_LENGTH;
;	3564											TOKEN_TYPE = LONG_VAL_TOKEN;
;	3565											END;
;	3566										ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] - .TOKEN_STRING[0];
;	3567										END
;	3568									ELSE
;	3569										BEGIN
;	3570										SIGNAL(PAT$_BRTOOFAR+MSG$K_INFO, 1, .ACTUAL_OPRND[0]);
;	3571										EXITLOOP;
;	3572										END
;	3573								ELSE
;	3574									EXITLOOP;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-11
; Digital Equipment Corporation
;
;	3575								END;
;	3576							EXITLOOP;
;	3577							END;
;	3578					END;
;	3579				END;
;	3580			!++
;	3581			! Now calculate the right mode to use.  The following code is
;	3582			! extremely instruction-set dependent, and relies on the
;	3583			! relative values of the various displacement modes.
;	3584			! Essentially just start out with the lowest mode and keep
;	3585			! incrementing the mode.  This code is shorter but relies
;	3586			! on the relationship of the modes.
;	3587			!--
;	3588			MODE = DISP_BYTE_AMODE;
;	3589			IF (.TOKEN_TYPE GTR BYTE_VAL_TOKEN)
;	3590			THEN
;	3591				MODE = .MODE +2;
;	3592			IF (.TOKEN_TYPE GTR WORD_VAL_TOKEN)
;	3593			THEN
;	3594				MODE = .MODE +2;
;	3595			IF .AT_FLAG
;	3596			THEN
;	3597				MODE = .MODE +1;
;	3598	
;	3599			!++
;	3600			! Return the single mode byte followed by the counted byte
;	3601			! stream passed.  Indexing is allowed in all cases.
;	3602			!--
;	3603			OUT_CODE( 'YBC',
;     P 3604				  ((.MODE^4) OR .LEXEME_BUFFER[0]),
;     P 3605				  TOKEN_STRING);
;	3606			END;
;	3607	
;	3608		[OTHERWISE]:			! Error.
;	3609	
;	3610			BEGIN
;	3611			SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);		! "Operand Syntax" error.
;	3612			RETURN(FALSE);
;	3613			END;
;	3614	
;	3615		TES;
;	3616	
;	3617	!++
;	3618	! Return a pointer to the counted string which contains the rest of the operand
;	3619	! reference.
;	3620	!--
;	3621	RETURN TRUE
;	3622	END;





					 0FFC 00C33 ENC_OPERAND:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11		      ; 2970

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-12
; Digital Equipment Corporation
;
		         58 00000000V  EF  9E 00C35 	    MOVAB   ASSUME_AT_PC, R8					      ;
		         59	F640   CF  9E 00C3C 	    MOVAB   GET_NEXT_TOKEN, R9					      ;
		         5A 00000000G  00  9E 00C41 	    MOVAB   LIB$SIGNAL, R10					      ;
		         5B 00000000V  EF  9E 00C48 	    MOVAB   INST_OUTPUT, R11					      ;
		         5E	       34  C2 00C4F 	    SUBL2   #52, SP						      ;
				       57  D4 00C52 	    CLRL    AT_FLAG						      ; 3087
		         56	  08   AC  D0 00C54 	    MOVL    OUT_BYTE_STREAM, R6					      ; 3088
		         50	       66  D0 00C58 	    MOVL    (R6), OUT_BYTE_PTR					      ;
				  20   AE  9F 00C5B 	    PUSHAB  TOKEN_STRING					      ; 3089
		         53	  04   AC  D0 00C5E 	    MOVL    INST_STG_DESC, R3					      ;
				       53  DD 00C62 	    PUSHL   R3							      ;
		         69	       02  FB 00C64 	    CALLS   #2, GET_NEXT_TOKEN					      ;
		         55	       50  90 00C67 	    MOVB    R0, TOKEN_TYPE					      ;
		         3D	       50  D1 00C6A 	    CMPL    R0, #61						      ;
				       0E  12 00C6D 	    BNEQ    1$							      ;
		         57	       01  D0 00C6F 	    MOVL    #1, AT_FLAG						      ; 3092
				  20   AE  9F 00C72 	    PUSHAB  TOKEN_STRING					      ; 3093
				       53  DD 00C75 	    PUSHL   R3							      ;
		         69	       02  FB 00C77 	    CALLS   #2, GET_NEXT_TOKEN					      ;
		         55	       50  90 00C7A 	    MOVB    R0, TOKEN_TYPE					      ;
		    F4   8F	       55  91 00C7D 1$:     CMPB    TOKEN_TYPE, #244					      ; 3100
				       0D  13 00C81 	    BEQL    2$							      ;
				  10   AC  D5 00C83 	    TSTL    BRANCH_SIZE						      ; 3102
				       08  13 00C86 	    BEQL    2$							      ;
			    006D825B   8F  DD 00C88 	    PUSHL   #7176795						      ; 3105
				       55  11 00C8E 	    BRB     8$							      ;
		    F7   8F	       55  91 00C90 2$:     CMPB    TOKEN_TYPE, #247					      ; 3109
				       23  12 00C94 	    BNEQ    6$							      ;
		         03	       57  E9 00C96 	    BLBC    AT_FLAG, 3$						      ; 3121
				     030B  31 00C99 	    BRW     54$							      ;
		         50	  20   AE  9A 00C9C 3$:     MOVZBL  TOKEN_STRING, R0					      ; 3128
	   7E	         50 00000050   8F  C9 00CA0 	    BISL3   #80, R0, -(SP)					      ;
		         7E	424E   8F  3C 00CA8 4$:     MOVZWL  #16974, -(SP)					      ;
				       53  DD 00CAD 5$:     PUSHL   R3							      ;
				  14   AC  DD 00CAF 	    PUSHL   OUT_PC_PTR						      ;
				       56  DD 00CB2 	    PUSHL   R6							      ;
		         6B	       05  FB 00CB4 	    CALLS   #5, INST_OUTPUT					      ;
				       76  11 00CB7 	    BRB     14$							      ;
		    F8   8F	       55  91 00CB9 6$:     CMPB    TOKEN_TYPE, #248					      ; 3109
				       7A  12 00CBD 	    BNEQ    16$							      ;
		         11	       57  E9 00CBF 	    BLBC    AT_FLAG, 7$						      ; 3138
				  20   AE  9F 00CC2 	    PUSHAB  TOKEN_STRING					      ; 3149
				       04  DD 00CC5 	    PUSHL   #4							      ;
		         7E	  9F   8F  9A 00CC7 	    MOVZBL  #159, -(SP)						      ;
			    00444259   8F  DD 00CCB 	    PUSHL   #4473433						      ;
				       52  11 00CD1 	    BRB     13$							      ;
		         3F	  20   AE  D1 00CD3 7$:     CMPL    TOKEN_LONG, #63					      ; 3156
				       59  1B 00CD7 	    BLEQU   15$							      ;
		         04	  0C   AC  D1 00CD9 	    CMPL    PC_REL_CONTEXT, #4					      ; 3168
				       09  15 00CDD 	    BLEQ    9$							      ;
			    006D826B   8F  DD 00CDF 	    PUSHL   #7176811						      ; 3177
				     02C5  31 00CE5 8$:     BRW     55$							      ;
	   50	    0C   AC	       03  78 00CE8 9$:     ASHL    #3, PC_REL_CONTEXT, R0				      ; 3188
      20   AE	         50	       00  EE 00CED 	    EXTV    #0, R0, TOKEN_STRING, R1				      ;
				       51     00CF2									      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-13
; Digital Equipment Corporation
;
		         51	  20   AE  D1 00CF3 	    CMPL    TOKEN_LONG, R1					      ; 3187
				       1C  13 00CF7 	    BEQL    12$							      ;
	   52	    0C   AC	       01  C3 00CF9 	    SUBL3   #1, PC_REL_CONTEXT, I				      ; 3196
				       11  11 00CFE 	    BRB     11$							      ;
				  20 AE42  95 00D00 10$:    TSTB    TOKEN_STRING[I]					      ; 3198
				       0B  13 00D04 	    BEQL    11$							      ;
			    006D8023   8F  DD 00D06 	    PUSHL   #7176227						      ; 3201
		         6A	       01  FB 00D0C 	    CALLS   #1, LIB$SIGNAL					      ;
				       04  11 00D0F 	    BRB     12$							      ; 3202
	   EB	         52	       03  F3 00D11 11$:    AOBLEQ  #3, I, 10$						      ; 3196
				  20   AE  9F 00D15 12$:    PUSHAB  TOKEN_STRING					      ; 3213
				  0C   AC  DD 00D18 	    PUSHL   PC_REL_CONTEXT					      ;
		         7E	  8F   8F  9A 00D1B 	    MOVZBL  #143, -(SP)						      ;
			    0044424E   8F  DD 00D1F 	    PUSHL   #4473422						      ;
				       53  DD 00D25 13$:    PUSHL   R3							      ;
				  14   AC  DD 00D27 	    PUSHL   OUT_PC_PTR						      ;
				       56  DD 00D2A 	    PUSHL   R6							      ;
		         6B	       07  FB 00D2C 	    CALLS   #7, INST_OUTPUT					      ;
				     0270  31 00D2F 14$:    BRW     53$							      ;
		         7E	  20   AE  9A 00D32 15$:    MOVZBL  TOKEN_STRING, -(SP)					      ; 3220
				     FF6F  31 00D36 	    BRW     4$							      ;
		    F4   8F	       55  91 00D39 16$:    CMPB    TOKEN_TYPE, #244					      ; 3109
				       03  13 00D3D 	    BEQL    17$							      ;
				     00AF  31 00D3F 	    BRW     23$							      ;
		         2E	  20   AE  E9 00D42 17$:    BLBC    TOKEN_STRING, 18$					      ; 3237
		         50	  18   AC  D0 00D46 	    MOVL    OPINFO_PTR, R0					      ;
      04   A0	         04	       00  EC 00D4A 	    CMPV    #0, #4, 4(R0), #-2					      ;
			    FFFFFFFE   8F     00D4F									      ;
				       1E  13 00D54 	    BEQL    18$							      ;
	   50	    14   BC	  10   AC  C1 00D56 	    ADDL3   BRANCH_SIZE, @OUT_PC_PTR, R0			      ; 3250
		    21   AE	       50  C2 00D5C 	    SUBL2   R0, ACTUAL_OPRND					      ;
				  10   AC  D5 00D60 	    TSTL    BRANCH_SIZE						      ; 3251
				       0F  12 00D63 	    BNEQ    18$							      ;
				       53  DD 00D65 	    PUSHL   R3							      ; 3264
		         68	       01  FB 00D67 	    CALLS   #1, ASSUME_AT_PC					      ;
	   50	    21   AE	       50  C3 00D6A 	    SUBL3   R0, ACTUAL_OPRND, R0				      ; 3263
      21   AE	         50	       05  C3 00D6F 	    SUBL3   #5, R0, ACTUAL_OPRND				      ;
		         52	  10   AC  D0 00D74 18$:    MOVL    BRANCH_SIZE, R2					      ; 3271
				       69  13 00D78 	    BEQL    22$							      ;
	   54	         52	       03  78 00D7A 	    ASHL    #3, R2, R4						      ; 3290
		         51	  21   AE  D0 00D7E 	    MOVL    ACTUAL_OPRND, R1					      ; 3289
		         50	  18   AC  D0 00D82 	    MOVL    OPINFO_PTR, R0					      ; 3286
      04   A0	         04	       00  EC 00D86 	    CMPV    #0, #4, 4(R0), #-2					      ;
			    FFFFFFFE   8F     00D8B									      ;
				       30  13 00D90 	    BEQL    20$							      ;
      21   AE	         54	       00  EE 00D92 	    EXTV    #0, R4, ACTUAL_OPRND, R0				      ; 3290
				       50     00D97									      ;
		         50	       51  D1 00D98 	    CMPL    R1, R0						      ; 3289
				       39  13 00D9B 	    BEQL    21$							      ;
	      00000000G  EF	       51  D0 00D9D 	    MOVL    R1, PAT$GL_BR_DISPL					      ; 3296
				  21   AE  9F 00DA4 	    PUSHAB  ACTUAL_OPRND					      ; 3297
				       52  DD 00DA7 	    PUSHL   R2							      ;
		         7E	444E   8F  3C 00DA9 	    MOVZWL  #17486, -(SP)					      ;
				       53  DD 00DAE 	    PUSHL   R3							      ;
				  14   AC  DD 00DB0 	    PUSHL   OUT_PC_PTR						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-14
; Digital Equipment Corporation
;
				       56  DD 00DB3 	    PUSHL   R6							      ;
		         6B	       06  FB 00DB5 	    CALLS   #6, INST_OUTPUT					      ;
		         03	       50  E8 00DB8 	    BLBS    R0, 19$						      ;
				     01F8  31 00DBB 	    BRW     57$							      ;
		         50	       02  D0 00DBE 19$:    MOVL    #2, R0						      ; 3298
					   04 00DC1 	    RET     							      ;
      21   AE	         54	       00  EF 00DC2 20$:    EXTZV   #0, R4, ACTUAL_OPRND, R0				      ; 3304
				       50     00DC7									      ;
		         50	       51  D1 00DC8 	    CMPL    R1, R0						      ; 3303
				       09  13 00DCB 	    BEQL    21$							      ;
			    006D8023   8F  DD 00DCD 	    PUSHL   #7176227						      ; 3306
		         6A	       01  FB 00DD3 	    CALLS   #1, LIB$SIGNAL					      ;
				  21   AE  9F 00DD6 21$:    PUSHAB  ACTUAL_OPRND					      ; 3313
				       52  DD 00DD9 	    PUSHL   R2							      ;
		         7E	444E   8F  3C 00DDB 	    MOVZWL  #17486, -(SP)					      ;
				     01B5  31 00DE0 	    BRW     52$							      ;
		    0C   AE	       0F  90 00DE3 22$:    MOVB    #15, LEXEME_BUFFER					      ; 3325
		    20   AE	       04  90 00DE7 	    MOVB    #4, TOKEN_STRING					      ; 3326
		         52	       0E  D0 00DEB 	    MOVL    #14, MODE						      ; 3327
				     018D  31 00DEE 	    BRW     50$							      ; 3328
		    46   8F	       55  91 00DF1 23$:    CMPB    TOKEN_TYPE, #70					      ; 3109
				       22  12 00DF5 	    BNEQ    24$							      ;
				  20   AE  9F 00DF7 	    PUSHAB  TOKEN_STRING					      ; 3349
				       53  DD 00DFA 	    PUSHL   R3							      ;
		         69	       02  FB 00DFC 	    CALLS   #2, GET_NEXT_TOKEN					      ;
	      000000F6   8F	       50  D1 00DFF 	    CMPL    R0, #246						      ;
				       61  12 00E06 	    BNEQ    32$							      ;
		         34	       57  E8 00E08 	    BLBS    AT_FLAG, 26$					      ; 3359
		         50	  20   AE  9A 00E0B 	    MOVZBL  TOKEN_STRING, R0					      ; 3369
	   7E	         50 00000070   8F  C9 00E0F 	    BISL3   #112, R0, -(SP)					      ;
				       38  11 00E17 	    BRB     29$							      ;
		    F6   8F	       55  91 00E19 24$:    CMPB    TOKEN_TYPE, #246					      ; 3109
				       3A  12 00E1D 	    BNEQ    30$							      ;
		         52	       06  D0 00E1F 	    MOVL    #6, MODE						      ; 3385
		         51	  04   A3  D0 00E22 	    MOVL    4(R3), INPUT_PTR					      ; 3390
		         50	       61  9A 00E26 	    MOVZBL  (INPUT_PTR), CHAR					      ; 3391
		         2B	       50  D1 00E29 	    CMPL    CHAR, #43						      ; 3392
				       11  12 00E2C 	    BNEQ    26$							      ;
		         52	       08  D0 00E2E 	    MOVL    #8, MODE						      ; 3399
		         02	       57  E9 00E31 	    BLBC    AT_FLAG, 25$					      ; 3400
				       52  D6 00E34 	    INCL    MODE						      ; 3402
      04   A3	         51	       01  C1 00E36 25$:    ADDL3   #1, INPUT_PTR, 4(R3)				      ; 3404
				       63  B7 00E3B 	    DECW    (R3)						      ; 3405
				       06  11 00E3D 	    BRB     28$							      ; 3392
		         03	       57  E9 00E3F 26$:    BLBC    AT_FLAG, 28$					      ; 3408
				     0162  31 00E42 27$:    BRW     54$							      ;
	   50	         52	       04  78 00E45 28$:    ASHL    #4, MODE, R0					      ; 3418
		         51	  20   AE  9A 00E49 	    MOVZBL  TOKEN_STRING, R1					      ;
	   7E	         50	       51  C9 00E4D 	    BISL3   R1, R0, -(SP)					      ;
		         7E	4259   8F  3C 00E51 29$:    MOVZWL  #16985, -(SP)					      ;
				     FE54  31 00E56 	    BRW     5$							      ;
		    F2   8F	       55  91 00E59 30$:    CMPB    TOKEN_TYPE, #242					      ; 3109
				       06  1F 00E5D 	    BLSSU   31$							      ;
		    F3   8F	       55  91 00E5F 	    CMPB    TOKEN_TYPE, #243					      ;
				       06  1B 00E63 	    BLEQU   33$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-15
; Digital Equipment Corporation
;
		    F5   8F	       55  91 00E65 31$:    CMPB    TOKEN_TYPE, #245					      ;
				       D7  12 00E69 32$:    BNEQ    27$							      ;
				       53  DD 00E6B 33$:    PUSHL   R3							      ; 3439
		         68	       01  FB 00E6D 	    CALLS   #1, ASSUME_AT_PC					      ;
		         51	       50  D0 00E70 	    MOVL    R0, INDEXING					      ;
				       62  19 00E73 	    BLSS    37$							      ;
		         50	  20   AE  9A 00E75 	    MOVZBL  TOKEN_STRING, R0					      ; 3453
		         50	  14   BC  C0 00E79 	    ADDL2   @OUT_PC_PTR, R0					      ;
		         50	       51  C0 00E7D 	    ADDL2   INDEXING, R0					      ;
	   50	    21   AE	       50  C3 00E80 	    SUBL3   R0, ACTUAL_OPRND, R0				      ;
      21   AE	         50	       01  C3 00E85 	    SUBL3   #1, R0, ACTUAL_OPRND				      ;
		    0C   AE	       0F  90 00E8A 	    MOVB    #15, LEXEME_BUFFER					      ; 3460
		         50	  20   AE  9A 00E8E 34$:    MOVZBL  TOKEN_STRING, R0					      ; 3471
		         50	       08  C4 00E92 	    MULL2   #8, R0						      ;
      21   AE	         50	       00  EE 00E95 	    EXTV    #0, R0, ACTUAL_OPRND, R1				      ;
				       51     00E9A									      ;
		         51	  21   AE  D1 00E9B 	    CMPL    ACTUAL_OPRND, R1					      ; 3470
				       7C  13 00E9F 	    BEQL    41$							      ;
	   76 00000000G  EF	       04  E1 00EA1 	    BBC     #4, PAT$GL_CONTEXT+2, 42$				      ; 3473
		         04	  20   AE  91 00EA9 	    CMPB    TOKEN_STRING, #4					      ; 3474
				       7C  1E 00EAD 	    BGEQU   43$							      ;
		         50	  20   AE  9A 00EAF 	    MOVZBL  TOKEN_STRING, R0					      ; 3477
		    21   AE	       50  C0 00EB3 	    ADDL2   R0, ACTUAL_OPRND					      ;
		    F2   8F	       55  91 00EB7 	    CMPB    TOKEN_TYPE, #242					      ; 3478
				       09  12 00EBB 	    BNEQ    35$							      ;
		    20   AE	       02  90 00EBD 	    MOVB    #2, TOKEN_STRING					      ; 3481
		         55	       0D  8E 00EC1 	    MNEGB   #13, TOKEN_TYPE					      ; 3482
				       07  11 00EC4 	    BRB     36$							      ; 3478
		    20   AE	       04  90 00EC6 35$:    MOVB    #4, TOKEN_STRING					      ; 3486
		         55	       0B  8E 00ECA 	    MNEGB   #11, TOKEN_TYPE					      ; 3487
		         50	  20   AE  9A 00ECD 36$:    MOVZBL  TOKEN_STRING, R0					      ; 3489
		    21   AE	       50  C2 00ED1 	    SUBL2   R0, ACTUAL_OPRND					      ;
				       B7  11 00ED5 	    BRB     34$							      ; 3473
				  0C   AE  9F 00ED7 37$:    PUSHAB  LEXEME_BUFFER					      ; 3506
				       53  DD 00EDA 	    PUSHL   R3							      ;
		         69	       02  FB 00EDC 	    CALLS   #2, GET_NEXT_TOKEN					      ;
	      000000F6   8F	       50  D1 00EDF 	    CMPL    R0, #246						      ;
				       03  13 00EE6 	    BEQL    38$							      ;
				     00BC  31 00EE8 	    BRW     54$							      ;
		         50	  20   AE  9A 00EEB 38$:    MOVZBL  TOKEN_STRING, R0					      ; 3526
		         50	       08  C4 00EEF 	    MULL2   #8, R0						      ;
      21   AE	         50	       00  EE 00EF2 	    EXTV    #0, R0, ACTUAL_OPRND, R1				      ;
				       51     00EF7									      ;
		         51	  21   AE  D1 00EF8 	    CMPL    ACTUAL_OPRND, R1					      ; 3525
				       6B  13 00EFC 	    BEQL    48$							      ;
		         54	  20   AE  9A 00EFE 	    MOVZBL  TOKEN_STRING, I					      ; 3540
				       54  D7 00F02 	    DECL    I							      ;
				       5F  11 00F04 	    BRB     47$							      ;
				  21 AE44  95 00F06 39$:    TSTB    ACTUAL_BYTES[I]					      ; 3542
				       59  13 00F0A 	    BEQL    47$							      ;
		         50	  20   AE  9A 00F0C 40$:    MOVZBL  TOKEN_STRING, R0					      ; 3548
		         50	       08  C4 00F10 	    MULL2   #8, R0						      ;
      21   AE	         50	       00  EE 00F13 	    EXTV    #0, R0, ACTUAL_OPRND, R1				      ;
				       51     00F18									      ;
		         51	  21   AE  D1 00F19 	    CMPL    ACTUAL_OPRND, R1					      ; 3547

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 8-16
; Digital Equipment Corporation
;
				       4A  13 00F1D 41$:    BEQL    48$							      ;
	   2E 00000000G  EF	       04  E1 00F1F 42$:    BBC     #4, PAT$GL_CONTEXT+2, 46$				      ; 3550
		         04	  20   AE  91 00F27 	    CMPB    TOKEN_STRING, #4					      ; 3551
				       28  1E 00F2B 43$:    BGEQU   46$							      ;
		         50	  20   AE  9A 00F2D 	    MOVZBL  TOKEN_STRING, R0					      ; 3554
		    21   AE	       50  C0 00F31 	    ADDL2   R0, ACTUAL_OPRND					      ;
		    F2   8F	       55  91 00F35 	    CMPB    TOKEN_TYPE, #242					      ; 3555
				       09  12 00F39 	    BNEQ    44$							      ;
		    20   AE	       02  90 00F3B 	    MOVB    #2, TOKEN_STRING					      ; 3558
		         55	       0D  8E 00F3F 	    MNEGB   #13, TOKEN_TYPE					      ; 3559
				       07  11 00F42 	    BRB     45$							      ; 3555
		    20   AE	       04  90 00F44 44$:    MOVB    #4, TOKEN_STRING					      ; 3563
		         55	       0B  8E 00F48 	    MNEGB   #11, TOKEN_TYPE					      ; 3564
		         50	  20   AE  9A 00F4B 45$:    MOVZBL  TOKEN_STRING, R0					      ; 3566
		    21   AE	       50  C2 00F4F 	    SUBL2   R0, ACTUAL_OPRND					      ;
				       B7  11 00F53 	    BRB     40$							      ; 3550
				  21   AE  DD 00F55 46$:    PUSHL   ACTUAL_OPRND					      ; 3570
				       01  DD 00F58 	    PUSHL   #1							      ;
			    006D8253   8F  DD 00F5A 	    PUSHL   #7176787						      ;
		         6A	       03  FB 00F60 	    CALLS   #3, LIB$SIGNAL					      ;
				       04  11 00F63 	    BRB     48$							      ; 3571
	   9D	         54	       03  F3 00F65 47$:    AOBLEQ  #3, I, 39$						      ; 3540
		         52	       0A  D0 00F69 48$:    MOVL    #10, MODE						      ; 3588
		    F2   8F	       55  91 00F6C 	    CMPB    TOKEN_TYPE, #242					      ; 3589
				       03  1B 00F70 	    BLEQU   49$							      ;
		         52	       02  C0 00F72 	    ADDL2   #2, MODE						      ; 3591
		    F3   8F	       55  91 00F75 49$:    CMPB    TOKEN_TYPE, #243					      ; 3592
				       03  1B 00F79 	    BLEQU   50$							      ;
		         52	       02  C0 00F7B 	    ADDL2   #2, MODE						      ; 3594
		         02	       57  E9 00F7E 50$:    BLBC    AT_FLAG, 51$					      ; 3595
				       52  D6 00F81 	    INCL    MODE						      ; 3597
				  20   AE  9F 00F83 51$:    PUSHAB  TOKEN_STRING					      ; 3605
	   50	         52	       04  78 00F86 	    ASHL    #4, MODE, R0					      ;
		         51	  10   AE  9A 00F8A 	    MOVZBL  LEXEME_BUFFER, R1					      ;
	   7E	         50	       51  C9 00F8E 	    BISL3   R1, R0, -(SP)					      ;
			    00434259   8F  DD 00F92 	    PUSHL   #4407897						      ;
				       53  DD 00F98 52$:    PUSHL   R3							      ;
				  14   AC  DD 00F9A 	    PUSHL   OUT_PC_PTR						      ;
				       56  DD 00F9D 	    PUSHL   R6							      ;
		         6B	       06  FB 00F9F 	    CALLS   #6, INST_OUTPUT					      ;
		         0D	       50  E8 00FA2 53$:    BLBS    R0, 56$						      ;
				       0F  11 00FA5 	    BRB     57$							      ;
			    006D824B   8F  DD 00FA7 54$:    PUSHL   #7176779						      ; 3611
		         6A	       01  FB 00FAD 55$:    CALLS   #1, LIB$SIGNAL					      ;
				       04  11 00FB0 	    BRB     57$							      ; 3612
		         50	       01  D0 00FB2 56$:    MOVL    #1, R0						      ; 3621
					   04 00FB5 	    RET     							      ;
				       50  D4 00FB6 57$:    CLRL    R0							      ; 2970
					   04 00FB8 	    RET     							      ;

; Routine Size:  902 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 9
; Digital Equipment Corporation
;
;	3623	ROUTINE ASSUME_AT_PC( INST_STG_DESC ) =
;	3624	
;	3625	!++
;	3626	! Functional Description:
;	3627	!
;	3628	! This temporary routine is called when PATCH has read the <size> ^ <number>
;	3629	! part of an <operand reference> to decide whether the person has left out the
;	3630	! "(pc)".  This decision is made by looking ahead way to see if what follows
;	3631	! could be legal assuming that he meant "(PC)".  In this case the only
;	3632	! possibilities are that he wants indexing, or that this is the end of
;	3633	! the operand reference.
;	3634	!
;	3635	! Inputs:
;	3636	!
;	3637	!	INST_STG_DESC	- String descriptor to what is left
;	3638	!		 of the operand reference after the displacement
;	3639	!		 or virtual address has been extracted.
;	3640	!
;	3641	! Returned Value:
;	3642	!
;	3643	!	0 or 1, if "(PC)" can be assumed,
;	3644	!	-1, otherwise.  (DO_NOT_ASSUME)
;	3645	!
;	3646	!	0 => no indexing byte will be output, 
;	3647	!	1 => one byte will be output for [ Rx ].
;	3648	!
;	3649	!	In no case is any part of the instruction string changed.
;	3650	!	This routine has no side effects whatsoever.
;	3651	!--
;	3652	
;	3653	BEGIN
;	3654	
;	3655	MAP
;	3656		INST_STG_DESC : REF BLOCK [, BYTE];
;	3657	
;	3658	LOCAL
;	3659		INPUT_PTR : REF VECTOR[,BYTE];
;	3660	
;	3661	MACRO
;	3662			DO_NOT_ASSUME = -1 %;				! Value returned if unable to make PC assumption
;	3663	
;	3664	!++
;	3665	! PATCH must believe the count part of the counted string and not overrun it.
;	3666	! This should not be a problem, though, because the string ends with a null
;	3667	! byte.  Also detect whether the reason for returning OK-to-assume-"(PC)" is
;	3668	! because the operand is going to include indexing or not.  Do this based on the
;	3669	! presence or absence of '['.
;	3670	!--
;	3671	IF (.INST_STG_DESC[DSC$W_LENGTH] EQL 0)
;	3672	THEN
;	3673		RETURN(FALSE);
;	3674	INPUT_PTR = CH$PTR (.INST_STG_DESC [DSC$A_POINTER]);
;	3675	IF (.INPUT_PTR[0] EQL ASC_SQ_OPN_BRAK)
;	3676	THEN
;	3677		RETURN(TRUE)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 9-1
; Digital Equipment Corporation
;
;	3678	ELSE
;	3679		RETURN(DO_NOT_ASSUME);
;	3680	END;





					 0000 00FB9 ASSUME_AT_PC:
							    .WORD   Save nothing					      ; 3623
		         50	  04   AC  D0 00FBB 	    MOVL    INST_STG_DESC, R0					      ; 3671
				       60  B5 00FBF 	    TSTW    (R0)						      ;
				       12  13 00FC1 	    BEQL    2$							      ;
		         50	  04   A0  D0 00FC3 	    MOVL    4(R0), INPUT_PTR					      ; 3674
		    5B   8F	       60  91 00FC7 	    CMPB    (INPUT_PTR), #91					      ; 3675
				       04  12 00FCB 	    BNEQ    1$							      ;
		         50	       01  D0 00FCD 	    MOVL    #1, R0						      ; 3677
					   04 00FD0 	    RET     							      ;
		         50	       01  CE 00FD1 1$:     MNEGL   #1, R0						      ; 3679
					   04 00FD4 	    RET     							      ;
				       50  D4 00FD5 2$:     CLRL    R0							      ; 3623
					   04 00FD7 	    RET     							      ;

; Routine Size:  31 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 10
; Digital Equipment Corporation
;
;	3681	ROUTINE INST_OUTPUT (	OUT_BYTE_STREAM,
;	3682				OUT_PC_PTR,
;	3683				INST_STG_DESC,
;	3684				CTRL_STRING,
;	3685				ARG0,
;	3686				ARG1,
;	3687				ARG2
;	3688			    ) =
;	3689	!++
;	3690	! Functional Description:
;	3691	!
;	3692	!	This routine serves two purposes.
;	3693	!	1) It checks whether an indexed operand reference
;	3694	!	   has been made, and outputs the proper mode byte
;	3695	!	   if it has.
;	3696	!	2) It takes care of all other instruction byte
;	3697	!	   output as well - not that this routine computes
;	3698	!	   any of this - it just localizes such output.
;	3699	!
;	3700	! Calling Sequence:
;	3701	!
;	3702	!	INST_OUTPUT ()
;	3703	!
;	3704	! Inputs:
;	3705	!
;	3706	!	OUT_BYTE_STREAM	-The address of a pointer to where
;	3707	!			 we are in the output stream.  The address
;	3708	!			 is passed here so that we can both
;	3709	!			 use and update this pointer.
;	3710	!	OUT_PC_PTR	-The address of a pointer to where we
;	3711	!			 will eventually be stuffing the encoded
;	3712	!			 instruction in memory.  We both read
;	3713	!			 and write (update) this pointer.
;	3714	!	INST_CS_PTR	-The address of a pointer to the counted
;	3715	!			 string which describes where we are at
;	3716	!			 in operand encoding.  Again, a pointer is
;	3717	!			 passed here so that we may update the cs-pointer.
;	3718	!	CTRL_STRING	-A 4-character 'string' (a longword) which effectively
;	3719	!			 controls the action taken by this routine.  The first
;	3720	!			 (0th) character should be 'Y' or 'N', and is taken to
;	3721	!			 indicate whether we should allow indexing
;	3722	!			 for the current operand reference or not.
;	3723	!			 The next 2 or 3 characters must be 1 of 'B', 'C', or 'D',
;	3724	!			 and are used to indicate how the remaining parameters
;	3725	!			 should be interpreted.  See below.
;	3726	!			 The last of these characters must be 0 (null) to
;	3727	!			 indicate when the routine should stop.
;	3728	!	ARG?		-These args are interpretted differently depending
;	3729	!			 on the 'control string'.  See above and below.
;	3730	!
;	3731	! Implicit Inputs:
;	3732	!
;	3733	!	None.
;	3734	!
;	3735	! Outputs:

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 10-1
; Digital Equipment Corporation
;
;	3736	!
;	3737	!	None.
;	3738	!
;	3739	! Implicit Outputs:
;	3740	!
;	3741	!	The instruction bytes are copied into the output vector.
;	3742	!
;	3743	! Routine Value:
;	3744	!
;	3745	!	TRUE - if all went OK,
;	3746	!	FALSE otherwise.  The only thing that can go wrong
;	3747	!	is that we are prepared to allow indexing, see that the
;	3748	!	indexing reference is started, ('[' is encountered),
;	3749	!	but then don't get a proper completion of this token.
;	3750	!--
;	3751	
;	3752	BEGIN
;	3753	
;	3754	MAP
;	3755		!++
;	3756		! The reason why the following 3 are REFs to LONGs instead of to BYTEs
;	3757		! is because they are actually REF REF VECTOR[,BYTE], which we can only
;	3758		! achieve (so far!?) via a REF LONG.
;	3759		!--
;	3760		OUT_PC_PTR  : REF VECTOR[,LONG],
;	3761		INST_STG_DESC : REF BLOCK [, BYTE],
;	3762		OUT_BYTE_STREAM : REF VECTOR[,LONG];
;	3763	
;	3764	LOCAL
;	3765		CTRL_PTR : REF VECTOR[,BYTE],				! Examine the control string.
;	3766		OUT_BYTE_PTR : REF VECTOR[,BYTE],			! Pass back instruction bytes.
;	3767		ARG_PTR : REF VECTOR[,LONG],				! Used to pick up ARGx.
;	3768		TOKEN_BUFFER : VECTOR[ CHS_PER_LEXEME, BYTE],
;	3769		TOKEN_STG_DESC : BLOCK [12, BYTE];
;	3770	
;	3771	!++
;	3772	! Set up the various pointers.  The ARG_PTR is used to access each successive
;	3773	! ARGx actual parameter.  Since this routine loops thru them, it can't use the
;	3774	! formal parameter's name.
;	3775	!--
;	3776	ARG_PTR = ARG0;
;	3777	
;	3778	!++
;	3779	! CTRL_PTR points to the individual characters passed in the actual parameter,
;	3780	! 'CTRL_STRING'.  Note that this is actually a literal, because the characters
;	3781	! are contained within the parameter.
;	3782	!--
;	3783	CTRL_PTR = CTRL_STRING;
;	3784	
;	3785	!++
;	3786	! OUT_BYTE_PTR points to the location for the next byte in the instruction
;	3787	! stream to be written.  This value is found by loading the contents of the cell
;	3788	! pointed to by OUT_BYTE_STREAM.  The address of this pointer must be passed to
;	3789	! enable the pointer to be incremented.
;	3790	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 10-2
; Digital Equipment Corporation
;
;	3791	OUT_BYTE_PTR = .OUT_BYTE_STREAM[0];
;	3792	
;	3793	!++
;	3794	! Likewise, the address of the current instruction-stream counted-string
;	3795	! pointer, INST_CS, is passed.  Once again this provides the ability to update
;	3796	! the pointer.
;	3797	!--
;	3798	TOKEN_STG_DESC [DSC$W_LENGTH] = 0;
;	3799	TOKEN_STG_DESC [DSC$A_POINTER] = TOKEN_BUFFER;
;	3800	TOKEN_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	3801	
;	3802	!++
;	3803	! Whether or not indexing mode is allowed, is indicated by the first character
;	3804	! in the control string.  'Y' means yes, and anything else means no.
;	3805	!--
;	3806	IF (.CTRL_PTR[0] EQL 'Y')
;	3807	THEN
;	3808		BEGIN
;	3809		!++
;	3810		! Check for indexing.  The difficulty here is that this routine must
;	3811		! 'look ahead' before calling GET_NEXT_TOKEN because it will overwrite
;	3812		! the instruction string.  The string must be left untouched unless
;	3813		! indexing mode was actually specified.
;	3814		!--
;	3815		LOCAL
;	3816			INPUT_PTR,
;	3817			CHAR;
;	3818	
;	3819		INPUT_PTR = .INST_STG_DESC [DSC$A_POINTER];
;	3820		CHAR = CH$RCHAR (.INPUT_PTR);
;	3821		IF (.CHAR EQL '[')
;	3822		THEN
;	3823			BEGIN
;	3824			!++
;	3825			! Error if this is not an indexed reference.
;	3826			!--
;	3827			IF (GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_BUFFER) NEQ INDEXING_TOKEN)
;	3828			THEN
;	3829				BEGIN
;	3830				SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);
;	3831				RETURN(FALSE);
;	3832				END;
;	3833	
;	3834			!++
;	3835			! Output the indexing mode byte.
;	3836			!--
;	3837			OUT_BYTE_PTR[0] = (INDEXING_MODE ^ 4) OR .TOKEN_BUFFER[0];
;	3838			OUT_BYTE_PTR = .OUT_BYTE_PTR + BYTE_LENGTH;
;	3839			END;
;	3840		END;
;	3841	
;	3842	!++
;	3843	! Continue on according to the control string, breaking out of the loop when
;	3844	! the first 0 byte is encountered.
;	3845	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 10-3
; Digital Equipment Corporation
;
;	3846	CTRL_PTR = .CTRL_PTR +1;
;	3847	DO
;	3848		BEGIN
;	3849		BIND
;	3850			ARG_BYTE	= (.ARG_PTR) : REF VECTOR[,BYTE];
;	3851		
;	3852		SELECTONE .CTRL_PTR[0] OF
;	3853			SET
;	3854	
;	3855			['B']:	! Pass back 1 byte.
;	3856	
;	3857				BEGIN
;	3858				OUT_BYTE_PTR[0] = .ARG_PTR[0];
;	3859				OUT_BYTE_PTR = .OUT_BYTE_PTR +BYTE_LENGTH;
;	3860				ARG_PTR = .ARG_PTR +LONG_LENGTH;
;	3861				END;
;	3862	
;	3863			['C']:	! Counted byte string.
;	3864	
;	3865				BEGIN
;	3866				CH$MOVE(.ARG_BYTE[0], ARG_BYTE[1], .OUT_BYTE_PTR);
;	3867				OUT_BYTE_PTR = .OUT_BYTE_PTR + .ARG_BYTE[0];
;	3868				ARG_PTR = .ARG_PTR + LONG_LENGTH;
;	3869				END;
;	3870	
;	3871			['D']:	! Count + byte address.
;	3872	
;	3873				BEGIN
;	3874				CH$MOVE(.ARG_PTR[0], .ARG_PTR[1], .OUT_BYTE_PTR);
;	3875				OUT_BYTE_PTR = .OUT_BYTE_PTR + .ARG_PTR[0];
;	3876				ARG_PTR = .ARG_PTR + 2*LONG_LENGTH;
;	3877				END;
;	3878	
;	3879			[OTHERWISE]:	! Error.
;	3880				RETURN(0);
;	3881	
;	3882			TES;
;	3883	
;	3884		!++
;	3885		! Loop back to consider the next control character
;	3886		! until a null character is encountered.
;	3887		!--
;	3888		CTRL_PTR = .CTRL_PTR + 1;
;	3889		END
;	3890	
;	3891	WHILE (.CTRL_PTR[0] NEQ 0);
;	3892	
;	3893	!++
;	3894	! Update the instruction-stream pointer which is being maintained by the routine
;	3895	! which called this one.  This can be done as the address of the pointer was
;	3896	! passed.  Also, this is possible this routine remembers the number of bytes it
;	3897	! has written to the output byte stream.
;	3898	!--
;	3899	OUT_PC_PTR[0] = .OUT_PC_PTR[0] + (.OUT_BYTE_PTR - .OUT_BYTE_STREAM[0]);
;	3900	OUT_BYTE_STREAM[0] = .OUT_BYTE_PTR;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 10-4
; Digital Equipment Corporation
;
;	3901	
;	3902	!++
;	3903	! Likewise, update the caller's instruction string pointer.
;	3904	!--
;	3905	RETURN(TRUE);
;	3906	END;





					 03FC 00FD8 INST_OUTPUT:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9			      ; 3681
		         5E	       20  C2 00FDA 	    SUBL2   #32, SP						      ;
		         57	  14   AC  9E 00FDD 	    MOVAB   ARG0, ARG_PTR					      ; 3776
		         59	  10   AC  9E 00FE1 	    MOVAB   CTRL_STRING, CTRL_PTR				      ; 3783
		         58	  04   BC  D0 00FE5 	    MOVL    @OUT_BYTE_STREAM, OUT_BYTE_PTR			      ; 3791
				       6E  B4 00FE9 	    CLRW    TOKEN_STG_DESC					      ; 3798
		    04   AE	  0C   AE  9E 00FEB 	    MOVAB   TOKEN_BUFFER, TOKEN_STG_DESC+4			      ; 3799
		    08   AE	       14  B0 00FF0 	    MOVW    #20, TOKEN_STG_DESC+8				      ; 3800
		    59   8F	       69  91 00FF4 	    CMPB    (CTRL_PTR), #89					      ; 3806
				       3C  12 00FF8 	    BNEQ    2$							      ;
		         50	  0C   AC  D0 00FFA 	    MOVL    INST_STG_DESC, R0					      ; 3819
		         51	  04   A0  D0 00FFE 	    MOVL    4(R0), INPUT_PTR					      ;
		         51	       61  9A 01002 	    MOVZBL  (INPUT_PTR), CHAR					      ; 3820
	      0000005B   8F	       51  D1 01005 	    CMPL    CHAR, #91						      ; 3821
				       28  12 0100C 	    BNEQ    2$							      ;
				  0C   AE  9F 0100E 	    PUSHAB  TOKEN_BUFFER					      ; 3827
				       50  DD 01011 	    PUSHL   R0							      ;
		  F268   CF	       02  FB 01013 	    CALLS   #2, GET_NEXT_TOKEN					      ;
	      000000F0   8F	       50  D1 01018 	    CMPL    R0, #240						      ;
				       0F  13 0101F 	    BEQL    1$							      ;
			    006D824B   8F  DD 01021 	    PUSHL   #7176779						      ; 3830
	      00000000G  00	       01  FB 01027 	    CALLS   #1, LIB$SIGNAL					      ;
				       5A  11 0102E 	    BRB     8$							      ; 3831
	   88	    0C   AE	  40   8F  89 01030 1$:     BISB3   #64, TOKEN_BUFFER, (OUT_BYTE_PTR)+			      ; 3837
				       59  D6 01036 2$:     INCL    CTRL_PTR						      ; 3846
		         50	       57  D0 01038 3$:     MOVL    ARG_PTR, R0						      ; 3848
		    42   8F	       69  91 0103B 	    CMPB    (CTRL_PTR), #66					      ; 3852
				       05  12 0103F 	    BNEQ    4$							      ;
		         88	       67  90 01041 	    MOVB    (ARG_PTR), (OUT_BYTE_PTR)+				      ; 3858
				       17  11 01044 	    BRB     5$							      ; 3860
		    43   8F	       69  91 01046 4$:     CMPB    (CTRL_PTR), #67					      ; 3852
				       16  12 0104A 	    BNEQ    6$							      ;
		         56	       60  D0 0104C 	    MOVL    (R0), R6						      ; 3866
		         50	       66  9A 0104F 	    MOVZBL  (R6), R0						      ;
	   68	    01   A6	       50  28 01052 	    MOVC3   R0, 1(R6), (OUT_BYTE_PTR)				      ;
		         50	       66  9A 01057 	    MOVZBL  (R6), R0						      ; 3867
		         58	       50  C0 0105A 	    ADDL2   R0, OUT_BYTE_PTR					      ;
		         57	       04  C0 0105D 5$:     ADDL2   #4, ARG_PTR						      ; 3868
				       11  11 01060 	    BRB     7$							      ; 3852
		    44   8F	       69  91 01062 6$:     CMPB    (CTRL_PTR), #68					      ;
				       22  12 01066 	    BNEQ    8$							      ;
	   68	    04   B7	       67  28 01068 	    MOVC3   (ARG_PTR), @4(ARG_PTR), (OUT_BYTE_PTR)		      ; 3874
		         58	       87  C0 0106D 	    ADDL2   (ARG_PTR)+, OUT_BYTE_PTR				      ; 3875

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 10-5
; Digital Equipment Corporation
;
		         57	       04  C0 01070 	    ADDL2   #4, ARG_PTR						      ; 3876
				       59  D6 01073 7$:     INCL    CTRL_PTR						      ; 3888
				       69  95 01075 	    TSTB    (CTRL_PTR)						      ; 3891
				       BF  12 01077 	    BNEQ    3$							      ;
	   50	         58	  04   BC  C3 01079 	    SUBL3   @OUT_BYTE_STREAM, OUT_BYTE_PTR, R0			      ; 3899
		    08   BC	       50  C0 0107E 	    ADDL2   R0, @OUT_PC_PTR					      ;
		    04   BC	       58  D0 01082 	    MOVL    OUT_BYTE_PTR, @OUT_BYTE_STREAM			      ; 3900
		         50	       01  D0 01086 	    MOVL    #1, R0						      ; 3905
					   04 01089 	    RET     							      ;
				       50  D4 0108A 8$:     CLRL    R0							      ; 3681
					   04 0108C 	    RET     							      ;

; Routine Size:  181 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 11
; Digital Equipment Corporation
;
;	3907	ROUTINE OPCODE_MATCH (OPCO_STG_DESC, OPINFO_PTR) = 
;	3908	
;	3909	!++
;	3910	! Functional Description:
;	3911	!
;	3912	!	Look up the given opcode mnemonic in the OPINFO
;	3913	!	table to see if it is there.  If so, return the
;	3914	!	opcode and a pointer to the OPINFO table entry which 
;	3915	!	corresponds to this opcode.
;	3916	!
;	3917	! Calling Sequence:
;	3918	!
;	3919	!	OPCODE_MATCH ()
;	3920	!
;	3921	! Inputs:
;	3922	!
;	3923	!	OPCO_STG_DESC	-String descriptor for the given opcode.
;	3924	!	OPINFO_PTR	-The address of where we should copy the
;	3925	!			 OPINFO record pointer when we find the
;	3926	!			 one which corresponds to the given opcode.
;	3927	! Implicit Inputs:
;	3928	!
;	3929	!	The OPINFO table.  See PATINS.B32
;	3930	!
;	3931	! Outputs:
;	3932	!
;	3933	!	None.
;	3934	!
;	3935	! Implicit Outputs:
;	3936	!
;	3937	!	A pointer to the OPINFO table entry that
;	3938	!	corresponds to the found opcode mnemonic
;	3939	!	is returned via the formal pointer OPINFO_PTR.
;	3940	!
;	3941	! Returned Value:
;	3942	!
;	3943	!	-1	-if the lookup fails or if there is insufficient
;	3944	!		 information in the table entry for the program
;	3945	!		 to continue.
;	3946	!	The found OPCODE, otherwise.  This is non-standard,
;	3947	!	so we use a local macro to draw attention to it.
;	3948	!--
;	3949	
;	3950	BEGIN
;	3951	
;	3952	MACRO
;	3953		OPC_MATCH_ERROR = -1 %;					!  Error return for this routine.
;	3954	
;	3955	MAP
;	3956		OPCO_STG_DESC : REF BLOCK [, BYTE],
;	3957		OPINFO_PTR : REF VECTOR[,LONG];
;	3958	
;	3959	LOCAL
;	3960		OP_SIZE,
;	3961		OP_FROM_TABLE	:	VECTOR[ OP_CH_SIZE, BYTE ],

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 11-1
; Digital Equipment Corporation
;
;	3962		OP_FROM_USER	:	VECTOR[ OP_CH_SIZE, BYTE ];
;	3963	
;	3964	!++
;	3965	! First check that the supposed opcode is not too long or too short.
;	3966	! A zero cannot be returned as zero is a valid opcode.
;	3967	!--
;	3968	OP_SIZE = .OPCO_STG_DESC [DSC$W_LENGTH];
;	3969	IF (.OP_SIZE GTR OP_CH_SIZE) OR (.OP_SIZE LEQ 0)
;	3970	THEN
;	3971		RETURN(OPC_MATCH_ERROR);
;	3972	
;	3973	!++
;	3974	! Otherwise do the lookup linearly by first filling a local vector with spaces,
;	3975	! copying in the given opcode mnemonic, and then looping thru the table
;	3976	! comparing this one with the ones encoded (from RAD50) into ASCII.  This
;	3977	! approach is easier and less wasteful of code space than writing a routine to
;	3978	! convert ASCII to RAD50.
;	3979	!--
;	3980	CH$FILL(ASC_SPACE, OP_CH_SIZE, OP_FROM_USER);
;	3981	CH$MOVE(.OP_SIZE, CH$PTR(.OPCO_STG_DESC[DSC$A_POINTER], 0), OP_FROM_USER);
;	3982	INCR OPCODE FROM 0 TO MAXOPCODE DO
;	3983		BEGIN
;	3984		!++
;	3985		! Extract the opcode from the OPINFO table, converting it to ASCII, and
;	3986		! compare this with what is being sought.
;	3987		!--
;	3988		PAT$CONV_R_50( .PAT$GB_OPINFO[.OPCODE, OP_NAME], OP_FROM_TABLE );
;	3989		IF (CH$EQL(OP_CH_SIZE, OP_FROM_USER, OP_CH_SIZE, OP_FROM_TABLE))
;	3990		THEN
;	3991			BEGIN
;	3992			!++
;	3993			! Pass back both the opcode (the current index into the table),
;	3994			! and the pointer to the current table entry.
;	3995			!--
;	3996			OPINFO_PTR[0] = PAT$GB_OPINFO[ .OPCODE, OP_NAME ];
;	3997			RETURN(.OPCODE);
;	3998			END;
;	3999		END;
;	4000	
;	4001	!++
;	4002	! Failure, if routine falls through loop.
;	4003	!--
;	4004	RETURN(OPC_MATCH_ERROR);
;	4005	END;





					 08FC 0108D OPCODE_MATCH:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R11				      ; 3907
		         5B 00000000G  EF  9E 0108F 	    MOVAB   PAT$GB_OPINFO, R11					      ;
		         5E	       10  C2 01096 	    SUBL2   #16, SP						      ;
		         56	  04   AC  D0 01099 	    MOVL    OPCO_STG_DESC, R6					      ; 3968
		         57	       66  3C 0109D 	    MOVZWL  (R6), OP_SIZE					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 11-2
; Digital Equipment Corporation
;
		         06	       57  D1 010A0 	    CMPL    OP_SIZE, #6						      ; 3969
				       3C  14 010A3 	    BGTR    3$							      ;
				       57  D5 010A5 	    TSTL    OP_SIZE						      ;
				       38  15 010A7 	    BLEQ    3$							      ;
	   20	         6E	       00  2C 010A9 	    MOVC5   #0, (SP), #32, #6, OP_FROM_USER			      ; 3980
		         6E	       06     010AD									      ;
	   6E	    04   B6	       57  28 010AF 	    MOVC3   OP_SIZE, @4(R6), OP_FROM_USER			      ; 3981
				       55  D4 010B4 	    CLRL    OPCODE						      ; 3982
				  08   AE  9F 010B6 1$:     PUSHAB  OP_FROM_TABLE					      ; 3988
	   54	         55	       06  C5 010B9 	    MULL3   #6, OPCODE, R4					      ;
				     6B44  9F 010BD 	    PUSHAB  PAT$GB_OPINFO[R4]					      ;
				       9E  DD 010C0 	    PUSHL   @(SP)+						      ;
	      00000000G  EF	       02  FB 010C2 	    CALLS   #2, PAT$CONV_R_50					      ;
      08   AE	         6E	       06  29 010C9 	    CMPC3   #6, OP_FROM_USER, OP_FROM_TABLE			      ; 3989
				       09  12 010CE 	    BNEQ    2$							      ;
      08   BC	         54	       5B  C1 010D0 	    ADDL3   R11, R4, @OPINFO_PTR				      ; 3996
		         50	       55  D0 010D5 	    MOVL    OPCODE, R0						      ; 3997
					   04 010D8 	    RET     							      ;
	   D5	         55 000000FF   8F  F3 010D9 2$:     AOBLEQ  #255, OPCODE, 1$					      ; 3982
		         50	       01  CE 010E1 3$:     MNEGL   #1, R0						      ; 4004
					   04 010E4 	    RET     							      ; 3907

; Routine Size:  88 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 12
; Digital Equipment Corporation
;
;	4006	ROUTINE MAR_GET_LEX (INPUT_STG_DESC, LEXEME_STG_DESC) = 
;	4007	
;	4008	!++
;	4009	! Functional Description:
;	4010	!
;	4011	!	Extracts a lexeme from the input stream by calling the routine
;	4012	!	PAT$MAR_GET_LEX.  First MAR_GET_LEX zeros the lexeme buffer.
;	4013	!	The value of the routine is the token in the character string
;	4014	!	pointed to by LEXEME_STG_DESC, the string descriptor for the lexeme.
;	4015	!	Also the input buffer string descriptor is updated.
;	4016	!
;	4017	! Calling Sequence:
;	4018	!
;	4019	!	MAR_GET_LEX ( INPUT_STG_DESC, LEXEME_STG_DESC)
;	4020	!
;	4021	! Inputs:
;	4022	!
;	4023	!	INPUT_STG_DESC - String descriptor for input line
;	4024	!	LEXEME_STG_DESC - String descriptor for lexeme found
;	4025	!
;	4026	! Implicit Inputs:
;	4027	!
;	4028	!	NONE
;	4029	!
;	4030	! Outputs:
;	4031	!
;	4032	!	None.
;	4033	!
;	4034	! Implicit Outputs:
;	4035	!
;	4036	!	The string descriptors are updated.
;	4037	!
;	4038	! Returned Value:
;	4039	!
;	4040	!	An encoded representation of the token found.
;	4041	!
;	4042	!--
;	4043	
;	4044	BEGIN
;	4045	
;	4046	MAP
;	4047		INPUT_STG_DESC : REF BLOCK [, BYTE],
;	4048		LEXEME_STG_DESC : REF BLOCK[,BYTE];
;	4049	
;	4050	!++
;	4051	! First zero out the buffer which will hold the lexeme found.
;	4052	!--
;	4053	ZEROCOR (.LEXEME_STG_DESC[DSC$A_POINTER], (.LEXEME_STG_DESC[DSC$W_MAXLEN]/4));
;	4054	RETURN(PAT$MAR_GET_LEX(.INPUT_STG_DESC, .LEXEME_STG_DESC));
;	4055	END;






; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 12-1
; Digital Equipment Corporation
;
					 007C 010E5 MAR_GET_LEX:
							    .WORD   Save R2,R3,R4,R5,R6					      ; 4006
		         56	  08   AC  D0 010E7 	    MOVL    LEXEME_STG_DESC, R6					      ; 4053
		         50	  08   A6  3C 010EB 	    MOVZWL  8(R6), R0						      ;
		         50	       04  C6 010EF 	    DIVL2   #4, R0						      ;
		         50	       04  C4 010F2 	    MULL2   #4, R0						      ;
	   00	         6E	       00  2C 010F5 	    MOVC5   #0, (SP), #0, R0, @4(R6)				      ;
		    04   B6	       50     010F9									      ;
				       56  DD 010FC 	    PUSHL   R6							      ; 4054
				  04   AC  DD 010FE 	    PUSHL   INPUT_STG_DESC					      ;
	      00000000G  EF	       02  FB 01101 	    CALLS   #2, PAT$MAR_GET_LEX					      ;
					   04 01108 	    RET     							      ; 4006

; Routine Size:  36 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 13
; Digital Equipment Corporation
;
;	4056	ROUTINE ADD_LEX_T_OPRND (LEX_STG_DESC, OPRND_STG_DESC, MAX_BUF_SIZ) : NOVALUE = 
;	4057	
;	4058	!++
;	4059	! Functional Description:
;	4060	!
;	4061	!	This routine takes an ASCII lexeme and adds it to an operand buffer.
;	4062	!	It may be used to take any ASCII string described by a string
;	4063	!	descriptor and add it to a buffer described by another string
;	4064	!	descriptor.  The string descriptor for the latter is updated to
;	4065	!	include the new ASCII string.  The third input parameter gives the
;	4066	!	maximum size of the operand buffer.
;	4067	!
;	4068	! Calling Sequence:
;	4069	!
;	4070	!	ADD_LEX_T_OPRND ( LEX_STG_DESC, OPRND_STG_DESC)
;	4071	!
;	4072	! Inputs:
;	4073	!
;	4074	!	LEX_STG_DESC - String descriptor for input lexeme
;	4075	!	OPRND_STG_DESC - String descriptor for resultant operand string
;	4076	!	MAX_BUF_SIZ - Size of the buffer pointed to by OPRND_STG_DESC
;	4077	!
;	4078	! Implicit Inputs:
;	4079	!
;	4080	!	NONE
;	4081	!
;	4082	! Outputs:
;	4083	!
;	4084	!	None.
;	4085	!
;	4086	! Implicit Outputs:
;	4087	!
;	4088	!	The lexeme string is written into the next free bytes of the operand
;	4089	!	buffer.  The string descriptor for the resultant string, OPRND_STG_DESC,
;	4090	!	is updated.  If the combined string is too large for the buffer
;	4091	!	then an error is SIGNALed.
;	4092	!
;	4093	! Returned Value:
;	4094	!
;	4095	!	none
;	4096	!
;	4097	!--
;	4098	
;	4099	BEGIN
;	4100	
;	4101	MAP
;	4102		LEX_STG_DESC : REF BLOCK [, BYTE],
;	4103		OPRND_STG_DESC : REF BLOCK[,BYTE];
;	4104	
;	4105	!++
;	4106	! Fisrt check that there is room in the operand buffer for the lexeme string.
;	4107	!--
;	4108	IF ((.LEX_STG_DESC[DSC$W_LENGTH] + .OPRND_STG_DESC[DSC$W_LENGTH]) GTR .OPRND_STG_DESC[DSC$W_MAXLEN])
;	4109	THEN
;	4110		SIGNAL(PAT$_OPRNDLNG+MSG$K_WARN, 4, .OPRND_STG_DESC[DSC$W_LENGTH],

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 13-1
; Digital Equipment Corporation
;
;	4111			.OPRND_STG_DESC[DSC$A_POINTER], .LEX_STG_DESC[DSC$W_LENGTH],
;	4112			.LEX_STG_DESC[DSC$A_POINTER]);
;	4113	
;	4114	!++
;	4115	! Plenty of room in buffer.  Move the lexeme string into the buffer, starting
;	4116	! at the next unused byte in the buffer.
;	4117	!--
;	4118	CH$MOVE(.LEX_STG_DESC[DSC$W_LENGTH], .LEX_STG_DESC[DSC$A_POINTER],
;	4119		CH$PTR(.OPRND_STG_DESC[DSC$A_POINTER], .OPRND_STG_DESC[DSC$W_LENGTH]));
;	4120	
;	4121	!++
;	4122	! Now update the operand string descriptor to include the appended lexeme.
;	4123	!--
;	4124	OPRND_STG_DESC[DSC$W_LENGTH] = .OPRND_STG_DESC[DSC$W_LENGTH] + .LEX_STG_DESC[DSC$W_LENGTH];
;	4125	RETURN;
;	4126	END;





					 00FC 01109 ADD_LEX_T_OPRND:
							    .WORD   Save R2,R3,R4,R5,R6,R7				      ; 4056
		         57	  04   AC  D0 0110B 	    MOVL    LEX_STG_DESC, R7					      ; 4108
		         56	  08   AC  D0 0110F 	    MOVL    OPRND_STG_DESC, R6					      ;
		         50	       67  3C 01113 	    MOVZWL  (R7), R0						      ;
		         51	       66  3C 01116 	    MOVZWL  (R6), R1						      ;
		         50	       51  C0 01119 	    ADDL2   R1, R0						      ;
      08   A6	         10	       00  ED 0111C 	    CMPZV   #0, #16, 8(R6), R0					      ;
				       50     01121									      ;
				       1B  18 01122 	    BGEQ    1$							      ;
				  04   A7  DD 01124 	    PUSHL   4(R7)						      ; 4110
		         7E	       67  3C 01127 	    MOVZWL  (R7), -(SP)						      ;
				  04   A6  DD 0112A 	    PUSHL   4(R6)						      ;
		         7E	       66  3C 0112D 	    MOVZWL  (R6), -(SP)						      ;
				       04  DD 01130 	    PUSHL   #4							      ;
			    006D82C8   8F  DD 01132 	    PUSHL   #7176904						      ;
	      00000000G  00	       06  FB 01138 	    CALLS   #6, LIB$SIGNAL					      ;
		         50	       66  3C 0113F 1$:     MOVZWL  (R6), R0						      ; 4119
		         50	  04   A6  C0 01142 	    ADDL2   4(R6), R0						      ;
	   60	    04   B7	       67  28 01146 	    MOVC3   (R7), @4(R7), (R0)					      ; 4118
		         66	       67  A0 0114B 	    ADDW2   (R7), (R6)						      ; 4124
					   04 0114E 	    RET     							      ; 4056

; Routine Size:  70 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 14
; Digital Equipment Corporation
;
;	4127	GLOBAL ROUTINE PAT$REDUCE_INS (INS_PTR, EDITED_INS_DESC) : NOVALUE =
;	4128	
;	4129	!++
;	4130	! FUNCTIONAL DESCRIPTION:
;	4131	!
;	4132	!	This routine takes an ASCIC symbolic instruction and outputs a
;	4133	!	reduced ASCII instruction, that is, one with expressions reduces to
;	4134	!	single values and symbolic names replaced with values.  The resultant
;	4135	!	instruction is written into the buffer pointed to by EDITED_INS_DESC.
;	4136	!	The string descriptor is updated to contain the edited length.
;	4137	!
;	4138	! FORMAL PARAMETERS:
;	4139	!
;	4140	!	INS_PTR - Pointer to the symbolic instruction to be reduced
;	4141	!	EDITED_INS_DESC - String descriptor for output buffer
;	4142	!
;	4143	! IMPLICIT INPUTS:
;	4144	!
;	4145	!	EDITED_INS_DESC is already initialized.
;	4146	!
;	4147	! IMPLICIT OUTPUTS:
;	4148	!
;	4149	!	The reduced instruction is written into the output buffer.
;	4150	!
;	4151	! ROUTINE VALUE:
;	4152	!
;	4153	!	none
;	4154	!
;	4155	! COMPLETION CODES:
;	4156	!
;	4157	!	NONE
;	4158	!
;	4159	! SIDE EFFECTS:
;	4160	!
;	4161	!	If the reduction could not be performed, then an error message is
;	4162	!	SIGNALed and an UNWIND is performed.
;	4163	!	EDITED_INS_DESC contains an updated length.
;	4164	!
;	4165	!--
;	4166	
;	4167	BEGIN
;	4168	
;	4169	MAP
;	4170		EDITED_INS_DESC : REF BLOCK[,BYTE],			! String descriptor for reduced instruction
;	4171		INS_PTR : REF VECTOR[,BYTE];				! Pointer to input instruction (ASCIC)
;	4172	LOCAL
;	4173		CHAR : BYTE,						! Next character in instruction string
;	4174		INSTRUC_PTR : REF VECTOR[,BYTE],			! Local pointer into instruction
;	4175		LABEL_FLAG,						! Label flag
;	4176		INS_STG_DESC : BLOCK[8,BYTE],				! String descriptor for non-reduced part of input instruction
;	4177		LEXEME_DESC : BLOCK[12,BYTE],				! String descriptor for current lexeme
;	4178		LEX_BUF : BLOCK[CHS_PER_LEXEME,BYTE],			! Buffer to hold current lexeme
;	4179		OPR_FLAG;						! Operand flag
;	4180	
;	4181	LITERAL

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 14-1
; Digital Equipment Corporation
;
;	4182		SPACE = %X'20',						! ASCII value for space
;	4183		COMMA = %X'2C';						! ASCII value for comma
;	4184	
;	4185	!++
;	4186	! Define a string descriptor for the instruction to be reduced.
;	4187	!--
;	4188	INS_STG_DESC[DSC$W_LENGTH] = .INS_PTR[0];
;	4189	INS_STG_DESC[DSC$A_POINTER] = INS_PTR[1];
;	4190	INS_PTR[.INS_PTR[0]+1] = 0;					! Set an end-of-line indicator
;	4191	
;	4192	!++
;	4193	! Get the first lexeme which will be either a label or the opcode.
;	4194	! Put it into the output buffer.  Then search for the next significant
;	4195	! character.  If it is a colon, then move the colon into the output buffer
;	4196	! and get the opcode and move it in also.
;	4197	!--
;	4198	LABEL_FLAG = TRUE;
;	4199	EDITED_INS_DESC[DSC$W_LENGTH] = 0;
;	4200	LEXEME_DESC[DSC$A_POINTER] = LEX_BUF;
;	4201	LEXEME_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
;	4202	REPEAT
;	4203		BEGIN
;	4204		LEXEME_DESC[DSC$W_LENGTH] = 0;
;	4205		MAR_GET_LEX(INS_STG_DESC, LEXEME_DESC);
;	4206		CH$COPY(.LEXEME_DESC[DSC$W_LENGTH], .LEXEME_DESC[DSC$A_POINTER], SPACE,
;	4207			  .LEXEME_DESC[DSC$W_LENGTH]+1,
;	4208			  CH$PTR(.EDITED_INS_DESC[DSC$A_POINTER], .EDITED_INS_DESC[DSC$W_LENGTH]));
;	4209		EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] +
;	4210						.LEXEME_DESC[DSC$W_LENGTH] + 1;
;	4211		IF .LABEL_FLAG
;	4212		THEN
;	4213			BEGIN
;	4214			INSTRUC_PTR = .INS_STG_DESC[DSC$A_POINTER];
;	4215			DO
;	4216				CHAR = CH$RCHAR_A(INSTRUC_PTR)
;	4217			UNTIL ((.CHAR NEQU ' ') AND (.CHAR NEQU '	'));
;	4218			IF (.CHAR NEQU ':')
;	4219			THEN
;	4220				EXITLOOP;
;	4221			CH$MOVE(1, CHAR, CH$PTR(.EDITED_INS_DESC[DSC$A_POINTER], .EDITED_INS_DESC[DSC$W_LENGTH]));
;	4222			EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] + 1;
;	4223			INS_STG_DESC[DSC$W_LENGTH] = .INS_STG_DESC[DSC$W_LENGTH] +
;	4224					.INS_STG_DESC[DSC$A_POINTER] - .INSTRUC_PTR;
;	4225			INS_STG_DESC[DSC$A_POINTER] = .INSTRUC_PTR;
;	4226			LABEL_FLAG = FALSE;
;	4227			END
;	4228		ELSE
;	4229			EXITLOOP;
;	4230		END;
;	4231	
;	4232	!++
;	4233	! Now loop to get each operand.  The call to GET_OPERAND reduces all
;	4234	! the expressions and symbols in the operand to absolute numbers.
;	4235	! The only exception is user defined symbols.  These remain un-reduced
;	4236	! to allow correct use of PATCH area addresses in the command file.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 14-2
; Digital Equipment Corporation
;
;	4237	!--
;	4238	REPEAT
;	4239		BEGIN
;	4240		LEXEME_DESC[DSC$W_LENGTH] = 0;
;	4241		LEXEME_DESC[DSC$A_POINTER] = LEX_BUF;
;	4242		IF NOT (OPR_FLAG = GET_OPERAND(INS_STG_DESC, LEXEME_DESC, FALSE))
;	4243		THEN
;	4244			BEGIN
;	4245			!++
;	4246			! No more operands.  Return successfully.
;	4247			!--
;	4248			EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] - 1;
;	4249			RETURN;
;	4250			END;
;	4251	
;	4252		!++
;	4253		! If this is an operand containing an user-defined symbol, then
;	4254		! the string ends with a comma or null.  Ignore this character.
;	4255		!--
;	4256		IF (.OPR_FLAG EQLU OPR_FORW_REF)
;	4257		THEN
;	4258			LEXEME_DESC[DSC$W_LENGTH] = .LEXEME_DESC[DSC$W_LENGTH] - 1;
;	4259		IF (.LEXEME_DESC[DSC$W_LENGTH] + .EDITED_INS_DESC[DSC$W_LENGTH] + 1)
;	4260			 GTR .EDITED_INS_DESC[DSC$W_MAXLEN]
;	4261		THEN
;	4262			BEGIN
;	4263			SIGNAL(PAT$_OUTCMDLNG+MSG$K_SEVERE);
;	4264			END;
;	4265		CH$COPY(.LEXEME_DESC[DSC$W_LENGTH], .LEXEME_DESC[DSC$A_POINTER], COMMA,
;	4266		  .LEXEME_DESC[DSC$W_LENGTH]+1,
;	4267		  CH$PTR(.EDITED_INS_DESC[DSC$A_POINTER], .EDITED_INS_DESC[DSC$W_LENGTH]));
;	4268		EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] +
;	4269						.LEXEME_DESC[DSC$W_LENGTH] + 1;
;	4270		END;
;	4271	END;								! End of PAT$REDUCE_INS





					 01FC 0114F 	    .ENTRY  PAT$REDUCE_INS, Save R2,R3,R4,R5,R6,R7,R8		      ; 4127
		         5E	       2C  C2 01151 	    SUBL2   #44, SP						      ;
		    24   AE	  04   BC  9B 01154 	    MOVZBW  @INS_PTR, INS_STG_DESC				      ; 4188
      28   AE	    04   AC	       01  C1 01159 	    ADDL3   #1, INS_PTR, INS_STG_DESC+4				      ; 4189
		         50	  04   BC  9A 0115F 	    MOVZBL  @INS_PTR, R0					      ; 4190
		         50	  04   AC  C0 01163 	    ADDL2   INS_PTR, R0						      ;
				  01   A0  94 01167 	    CLRB    1(R0)						      ;
		         58	       01  D0 0116A 	    MOVL    #1, LABEL_FLAG					      ; 4198
		         56	  08   AC  D0 0116D 	    MOVL    EDITED_INS_DESC, R6					      ; 4199
				       66  B4 01171 	    CLRW    (R6)						      ;
		    1C   AE	  04   AE  9E 01173 	    MOVAB   LEX_BUF, LEXEME_DESC+4				      ; 4200
		    20   AE	       14  B0 01178 	    MOVW    #20, LEXEME_DESC+8					      ; 4201
				  18   AE  B4 0117C 1$:     CLRW    LEXEME_DESC						      ; 4204
				  18   AE  9F 0117F 	    PUSHAB  LEXEME_DESC						      ; 4205
				  28   AE  9F 01182 	    PUSHAB  INS_STG_DESC					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 14-3
; Digital Equipment Corporation
;
		  FF5B   CF	       02  FB 01185 	    CALLS   #2, MAR_GET_LEX					      ;
		         51	  18   AE  3C 0118A 	    MOVZWL  LEXEME_DESC, R1					      ; 4207
				       51  D6 0118E 	    INCL    R1							      ;
		         50	       66  3C 01190 	    MOVZWL  (R6), R0						      ; 4208
		         50	  04   A6  C0 01193 	    ADDL2   4(R6), R0						      ;
	   20	    1C   BE	  18   AE  2C 01197 	    MOVC5   LEXEME_DESC, @LEXEME_DESC+4, #32, R1, (R0)		      ; 4206
		         60	       51     0119D									      ;
		         50	       66  3C 0119F 	    MOVZWL  (R6), R0						      ; 4209
		         51	  18   AE  3C 011A2 	    MOVZWL  LEXEME_DESC, R1					      ;
		         50	       51  C0 011A6 	    ADDL2   R1, R0						      ;
	   66	         50	       01  A1 011A9 	    ADDW3   #1, R0, (R6)					      ; 4210
		         38	       58  E9 011AD 	    BLBC    LABEL_FLAG, 3$					      ; 4211
		         57	  28   AE  D0 011B0 	    MOVL    INS_STG_DESC+4, INSTRUC_PTR				      ; 4214
		         6E	       87  90 011B4 2$:     MOVB    (INSTRUC_PTR)+, CHAR				      ; 4216
		         20	       6E  91 011B7 	    CMPB    CHAR, #32						      ; 4217
				       F8  13 011BA 	    BEQL    2$							      ;
		         09	       6E  91 011BC 	    CMPB    CHAR, #9						      ;
				       F3  13 011BF 	    BEQL    2$							      ;
		         3A	       6E  91 011C1 	    CMPB    CHAR, #58						      ; 4218
				       22  12 011C4 	    BNEQ    3$							      ;
		         50	       66  3C 011C6 	    MOVZWL  (R6), R0						      ; 4221
		         50	  04   A6  C0 011C9 	    ADDL2   4(R6), R0						      ;
	   60	         6E	       01  28 011CD 	    MOVC3   #1, CHAR, (R0)					      ;
				       66  B6 011D1 	    INCW    (R6)						      ; 4222
		         50	  24   AE  3C 011D3 	    MOVZWL  INS_STG_DESC, R0					      ; 4223
		         50	  28   AE  C0 011D7 	    ADDL2   INS_STG_DESC+4, R0					      ;
      24   AE	         50	       57  A3 011DB 	    SUBW3   INSTRUC_PTR, R0, INS_STG_DESC			      ; 4224
		    28   AE	       57  D0 011E0 	    MOVL    INSTRUC_PTR, INS_STG_DESC+4				      ; 4225
				       58  D4 011E4 	    CLRL    LABEL_FLAG						      ; 4226
				       94  11 011E6 	    BRB     1$							      ; 4211
				  18   AE  B4 011E8 3$:     CLRW    LEXEME_DESC						      ; 4240
		    1C   AE	  04   AE  9E 011EB 	    MOVAB   LEX_BUF, LEXEME_DESC+4				      ; 4241
				       7E  D4 011F0 	    CLRL    -(SP)						      ; 4242
				  1C   AE  9F 011F2 	    PUSHAB  LEXEME_DESC						      ;
				  2C   AE  9F 011F5 	    PUSHAB  INS_STG_DESC					      ;
		  F3BF   CF	       03  FB 011F8 	    CALLS   #3, GET_OPERAND					      ;
		         57	       50  D0 011FD 	    MOVL    R0, OPR_FLAG					      ;
		         03	       57  E8 01200 	    BLBS    OPR_FLAG, 4$					      ;
				       66  B7 01203 	    DECW    (R6)						      ; 4248
					   04 01205 	    RET     							      ; 4249
		         03	       57  D1 01206 4$:     CMPL    OPR_FLAG, #3					      ; 4256
				       03  12 01209 	    BNEQ    5$							      ;
				  18   AE  B7 0120B 	    DECW    LEXEME_DESC						      ; 4258
		         50	  18   AE  3C 0120E 5$:     MOVZWL  LEXEME_DESC, R0					      ; 4259
		         51	       66  3C 01212 	    MOVZWL  (R6), R1						      ;
		         50	       51  C0 01215 	    ADDL2   R1, R0						      ;
				       50  D6 01218 	    INCL    R0							      ;
      08   A6	         10	       00  ED 0121A 	    CMPZV   #0, #16, 8(R6), R0					      ; 4260
				       50     0121F									      ;
				       0D  18 01220 	    BGEQ    6$							      ;
			    006D82BA   8F  DD 01222 	    PUSHL   #7176890						      ; 4263
	      00000000G  00	       01  FB 01228 	    CALLS   #1, LIB$SIGNAL					      ;
		         51	  18   AE  3C 0122F 6$:     MOVZWL  LEXEME_DESC, R1					      ; 4266
				       51  D6 01233 	    INCL    R1							      ;
		         50	       66  3C 01235 	    MOVZWL  (R6), R0						      ; 4267

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 14-4
; Digital Equipment Corporation
;
		         50	  04   A6  C0 01238 	    ADDL2   4(R6), R0						      ;
	   2C	    1C   BE	  18   AE  2C 0123C 	    MOVC5   LEXEME_DESC, @LEXEME_DESC+4, #44, R1, (R0)		      ; 4265
		         60	       51     01242									      ;
		         50	       66  3C 01244 	    MOVZWL  (R6), R0						      ; 4268
		         51	  18   AE  3C 01247 	    MOVZWL  LEXEME_DESC, R1					      ;
		         50	       51  C0 0124B 	    ADDL2   R1, R0						      ;
	   66	         50	       01  A1 0124E 	    ADDW3   #1, R0, (R6)					      ; 4269
				       94  11 01252 	    BRB     3$							      ; 4230

; Routine Size:  261 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 15
; Digital Equipment Corporation
;
;	4272	GLOBAL ROUTINE PAT$RESOLVE_INS (BUFFER_PTR) : NOVALUE  =
;	4273	
;	4274	!++
;	4275	! FUNCTIONAL DESCRIPTION:
;	4276	!
;	4277	!	This routine resolves all the forward references in the FWR table.
;	4278	!	It encodes the operands and enters them into the appropriate bytes
;	4279	!	in the buffers.
;	4280	!
;	4281	! FORMAL PARAMETERS:
;	4282	!
;	4283	!	BUFFER_PTR - Address of the descriptor for the buffer holding the
;	4284	!			binary instruction stream to be resolved
;	4285	!
;	4286	! IMPLICIT INPUTS:
;	4287	!
;	4288	!	PAT$GL_FWRLHD - ForWard Reference table listhead
;	4289	!
;	4290	! IMPLICIT OUTPUTS:
;	4291	!
;	4292	!	The resolved operands are witten into the instruction byte streams.
;	4293	!
;	4294	! ROUTINE VALUE:
;	4295	!
;	4296	!	FALSE - if any resolution fails.
;	4297	!	TRUE - if all resolutions were successful.
;	4298	!
;	4299	! COMPLETION CODES:
;	4300	!
;	4301	!	NONE
;	4302	!
;	4303	! SIDE EFFECTS:
;	4304	!
;	4305	!	none
;	4306	!
;	4307	!--
;	4308	
;	4309	BEGIN
;	4310	
;	4311	MAP
;	4312		BUFFER_PTR : REF BLOCK[,BYTE];				! String descriptor for binary instruction buffer
;	4313	
;	4314	LOCAL
;	4315		OUT_BYTE_PTR,						! Pointer into output buffer
;	4316		POINTER : REF BLOCK[,BYTE],				! Pointer to forward reference table entry
;	4317		OPR_FLAG,						! Flag if operand found valid
;	4318		INST_STG_DESC : BLOCK [8, BYTE],			! Instruction string descriptor
;	4319		OPINFO_PTR : REF BLOCK[ OPTSIZE, BYTE],			! Pointer into the OPINFO table
;	4320		BRANCH_SIZE,
;	4321		OPRND_STG_DESC : BLOCK[12,BYTE],			! String descriptor for next operand
;	4322		OPRND_BUF : VECTOR[MAX_BUF_SIZ,BYTE];			! Buffer to hold next operand
;	4323	
;	4324	!++
;	4325	! Now loop, resolving each forward reference in the table.
;	4326	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 15-1
; Digital Equipment Corporation
;
;	4327	WHILE (.PAT$GL_FWRLHD NEQA 0)
;	4328	DO
;	4329		BEGIN
;	4330		POINTER = .PAT$GL_FWRLHD;
;	4331		INST_STG_DESC [DSC$W_LENGTH] = .POINTER[FWR$W_OPRNDLNG];
;	4332		INST_STG_DESC [DSC$a_pointer] = .POINTER[FWR$A_OPRNDADR];
;	4333		OPRND_STG_DESC[DSC$W_LENGTH] = 0;
;	4334		OPRND_STG_DESC[DSC$A_POINTER] = OPRND_BUF;
;	4335		OPRND_STG_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
;	4336		OPR_FLAG = GET_OPERAND( INST_STG_DESC, OPRND_STG_DESC, TRUE);
;	4337		IF (NOT .OPR_FLAG) OR (.OPR_FLAG EQLU OPR_FORW_REF)
;	4338		THEN
;	4339			SIGNAL(PAT$_INVOPRND+MSG$K_WARN, 2, .POINTER[FWR$W_OPRNDLNG], .POINTER[FWR$A_OPRNDADR]);
;	4340	
;	4341		!++
;	4342		! Extract and encode one operand reference.  Give up if this fails.
;	4343		!--
;	4344		BRANCH_SIZE = NO_BR;
;	4345		OUT_BYTE_PTR = CH$PTR(.BUFFER_PTR[DSC$A_POINTER], .POINTER[FWR$B_BUFOFF]);
;	4346		OPINFO_PTR = .POINTER[FWR$A_OPINFO];
;	4347		IF (.OPINFO_PTR[OP_NUMOPS] EQL .POINTER[FWR$B_NTHOPRND]) OR
;	4348		   (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
;	4349		THEN
;	4350			IF (.POINTER[FWR$B_NTHOPRND] LSS MAXOPRNDS) OR
;	4351			   (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
;	4352			THEN
;	4353				BRANCH_SIZE = .OPINFO_PTR[OP_BR_TYPE];
;	4354		IF NOT (PAT$GL_ERRCODE = ENC_OPERAND( OPRND_STG_DESC, OUT_BYTE_PTR,
;	4355					    1 ^ .OPINFO_PTR[ OP_CONTEXT(.POINTER[FWR$B_NTHOPRND]) ],
;	4356					    .BRANCH_SIZE,  POINTER[FWR$L_PC], .OPINFO_PTR))
;	4357		THEN
;	4358			BEGIN
;	4359			!++
;	4360			! "Operand Syntax" error.  Instruction substution cannot be
;	4361			! done as it would alter all the offsets in the ForWard Reference
;	4362			! table (FWR$B_BUFOFF fields) and the remaining resolutions
;	4363			! would be written into the wrong places in the buffer.
;	4364			!--
;	4365			IF (.PAT$GL_ERRCODE EQL PAT$K_BR_RANGE)
;	4366			THEN
;	4367				SIGNAL(PAT$_BRTOOFAR+MSG$K_INFO);
;	4368			SIGNAL(PAT$_INVOPRND+MSG$K_WARN, 2, .POINTER[FWR$W_OPRNDLNG], .POINTER[FWR$A_OPRNDADR])
;	4369			END;
;	4370		IF (.OPRND_STG_DESC[DSC$W_LENGTH] NEQ 0)
;	4371		THEN
;	4372			SIGNAL(PAT$_INVOPRND+MSG$K_WARN, 2, .POINTER[FWR$W_OPRNDLNG],
;	4373				.POINTER[FWR$A_OPRNDADR]);
;	4374		PAT$GL_FWRLHD = .POINTER[FWR$L_FLINK];
;	4375		PAT$FREERELEASE(.POINTER, (FWR$C_SIZE + 3)/4);
;	4376		END;
;	4377	RETURN;
;	4378	END;								! End of PAT$RESOLVE_INS




; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 15-2
; Digital Equipment Corporation
;


					 0EFC 01254 	    .ENTRY  PAT$RESOLVE_INS, Save R2,R3,R4,R5,R6,R7,R9,R10,R11	      ; 4272
		         59 00000000G  EF  9E 01256 	    MOVAB   PAT$GL_FWRLHD, R9					      ;
		         5A 00000000G  EF  9E 0125D 	    MOVAB   PAT$GL_ERRCODE, R10					      ;
		         5B 00000000G  00  9E 01264 	    MOVAB   LIB$SIGNAL, R11					      ;
		         5E	FDE8   CE  9E 0126B 	    MOVAB   -536(SP), SP					      ;
	   57	    04   AC	       04  C1 01270 	    ADDL3   #4, BUFFER_PTR, R7					      ; 4345
		         50	       69  D0 01275 1$:     MOVL    PAT$GL_FWRLHD, R0					      ; 4327
				       01  12 01278 	    BNEQ    2$							      ;
					   04 0127A 	    RET     							      ;
		         52	       50  D0 0127B 2$:     MOVL    R0, POINTER						      ; 4330
		    F8   AD	  08   A2  B0 0127E 	    MOVW    8(POINTER), INST_STG_DESC				      ; 4331
		    FC   AD	  0C   A2  D0 01283 	    MOVL    12(POINTER), INST_STG_DESC+4			      ; 4332
				  EC   AD  B4 01288 	    CLRW    OPRND_STG_DESC					      ; 4333
		    F0   AD	  04   AE  9E 0128B 	    MOVAB   OPRND_BUF, OPRND_STG_DESC+4				      ; 4334
		    F4   AD	0200   8F  B0 01290 	    MOVW    #512, OPRND_STG_DESC+8				      ; 4335
				       01  DD 01296 	    PUSHL   #1							      ; 4336
				  EC   AD  9F 01298 	    PUSHAB  OPRND_STG_DESC					      ;
				  F8   AD  9F 0129B 	    PUSHAB  INST_STG_DESC					      ;
		  F319   CF	       03  FB 0129E 	    CALLS   #3, GET_OPERAND					      ;
		         55	       50  D0 012A3 	    MOVL    R0, OPR_FLAG					      ;
		         05	       55  E9 012A6 	    BLBC    OPR_FLAG, 3$					      ; 4337
		         03	       55  D1 012A9 	    CMPL    OPR_FLAG, #3					      ;
				       12  12 012AC 	    BNEQ    4$							      ;
				  0C   A2  DD 012AE 3$:     PUSHL   12(POINTER)						      ; 4339
		         7E	  08   A2  3C 012B1 	    MOVZWL  8(POINTER), -(SP)					      ;
				       02  DD 012B5 	    PUSHL   #2							      ;
			    006D82A8   8F  DD 012B7 	    PUSHL   #7176872						      ;
		         6B	       04  FB 012BD 	    CALLS   #4, LIB$SIGNAL					      ;
				       56  D4 012C0 4$:     CLRL    BRANCH_SIZE						      ; 4344
	   6E	         67	  14   A2  C1 012C2 	    ADDL3   20(POINTER), (R7), OUT_BYTE_PTR			      ; 4345
		         54	  10   A2  D0 012C7 	    MOVL    16(POINTER), OPINFO_PTR				      ; 4346
		         51	  04   A4  9E 012CB 	    MOVAB   4(OPINFO_PTR), R1					      ; 4347
		         50	  0B   A2  9A 012CF 	    MOVZBL  11(POINTER), R0					      ;
	   61	         04	       00  EC 012D3 	    CMPV    #0, #4, (R1), R0					      ;
				       50     012D7									      ;
				       0B  13 012D8 	    BEQL    5$							      ;
	   61	         04	       00  EC 012DA 	    CMPV    #0, #4, (R1), #-2					      ; 4348
			    FFFFFFFE   8F     012DE									      ;
				       16  12 012E3 	    BNEQ    7$							      ;
		         06	  0B   A2  91 012E5 5$:     CMPB    11(POINTER), #6					      ; 4350
				       0B  1F 012E9 	    BLSSU   6$							      ;
	   61	         04	       00  EC 012EB 	    CMPV    #0, #4, (R1), #-2					      ; 4351
			    FFFFFFFE   8F     012EF									      ;
				       05  12 012F4 	    BNEQ    7$							      ;
	   61	         04	       0C  EF 012F6 6$:     EXTZV   #12, #4, (R1), BRANCH_SIZE				      ; 4353
				       56     012FA									      ;
				       54  DD 012FB 7$:     PUSHL   OPINFO_PTR						      ; 4354
				  04   A2  9F 012FD 	    PUSHAB  4(POINTER)						      ; 4356
				       56  DD 01300 	    PUSHL   BRANCH_SIZE						      ; 4354
		         50	  0B   A2  9A 01302 	    MOVZBL  11(POINTER), R0					      ; 4355
		         50	       02  C4 01306 	    MULL2   #2, R0						      ;
		         50	       02  C0 01309 	    ADDL2   #2, R0						      ;
	   61	         02	       50  EF 0130C 	    EXTZV   R0, #2, (R1), R3					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 15-3
; Digital Equipment Corporation
;
				       53     01310									      ;
	   7E	         01	       53  78 01311 	    ASHL    R3, #1, -(SP)					      ;
				  10   AE  9F 01315 	    PUSHAB  OUT_BYTE_PTR					      ; 4354
				  EC   AD  9F 01318 	    PUSHAB  OPRND_STG_DESC					      ;
		  F913   CF	       06  FB 0131B 	    CALLS   #6, ENC_OPERAND					      ;
		         6A	       50  D0 01320 	    MOVL    R0, PAT$GL_ERRCODE					      ;
		         20	       50  E8 01323 	    BLBS    R0, 9$						      ;
		         02	       6A  D1 01326 	    CMPL    PAT$GL_ERRCODE, #2					      ; 4365
				       09  12 01329 	    BNEQ    8$							      ;
			    006D8253   8F  DD 0132B 	    PUSHL   #7176787						      ; 4367
		         6B	       01  FB 01331 	    CALLS   #1, LIB$SIGNAL					      ;
				  0C   A2  DD 01334 8$:     PUSHL   12(POINTER)						      ; 4368
		         7E	  08   A2  3C 01337 	    MOVZWL  8(POINTER), -(SP)					      ;
				       02  DD 0133B 	    PUSHL   #2							      ;
			    006D82A8   8F  DD 0133D 	    PUSHL   #7176872						      ;
		         6B	       04  FB 01343 	    CALLS   #4, LIB$SIGNAL					      ;
				  EC   AD  B5 01346 9$:     TSTW    OPRND_STG_DESC					      ; 4370
				       12  13 01349 	    BEQL    10$							      ;
				  0C   A2  DD 0134B 	    PUSHL   12(POINTER)						      ; 4372
		         7E	  08   A2  3C 0134E 	    MOVZWL  8(POINTER), -(SP)					      ;
				       02  DD 01352 	    PUSHL   #2							      ;
			    006D82A8   8F  DD 01354 	    PUSHL   #7176872						      ;
		         6B	       04  FB 0135A 	    CALLS   #4, LIB$SIGNAL					      ;
		         69	       62  D0 0135D 10$:    MOVL    (POINTER), PAT$GL_FWRLHD				      ; 4374
				       06  DD 01360 	    PUSHL   #6							      ; 4375
				       52  DD 01362 	    PUSHL   POINTER						      ;
	      00000000G  EF	       02  FB 01364 	    CALLS   #2, PAT$FREERELEASE					      ;
				     FF07  31 0136B 	    BRW     1$							      ; 4327
					   04 0136E 11$:    RET     							      ; 4272

; Routine Size:  283 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:17:21	DBB3:[PATCH.SRC]PATENC.B32;18					Page 16
; Digital Equipment Corporation
;
;	4379	END
;	4380	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$OWN       	    12    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$CODE      	  4975  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	     8  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582         6         0       223





; Size:		4975 code + 20 data bytes
; Run Time:	03:03.0
; Elapsed Time:	06:10.1
; Memory Used:	620 pages
; Compilation Complete
