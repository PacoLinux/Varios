
; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATBLD (	!
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.16'
;	0007			) =
;	0008	BEGIN
;	0009	
;	0010	! COPYRIGHT (c) 1977,1978
;	0011	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0012	!
;	0013	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0014	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0015	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0016	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0017	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0018	! TRANSFERRED.
;	0019	!
;	0020	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0021	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0022	! CORPORATION.
;	0023	!
;	0024	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0025	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0026	!
;	0027	
;	0028	!++
;	0029	! FACILITY:	PATCH
;	0030	!
;	0031	! ABSTRACT:	Initialize and build the Runtime Symbol Table (RST) data structures.
;	0032	!
;	0033	!
;	0034	! ENVIRONMENT:	This module runs on VAX under STARLET, user mode, non-AST level.
;	0035	!
;	0036	! Author:	Kevin Pammett, August 12, 1977.
;	0037	!
;	0038	!
;	0039	! MODIFICATIONS:
;	0040	!
;	0041	!  NO	DATE		PROGRAMMER		PURPOSE
;	0042	!  --	----		----------		-------
;	0043	!
;	0044	!  00	19-DEC-77	K.D. MORSE		ADAPT VERSION 36 FOR PATCH.
;	0045	!  01	2-JAN-78	K.D. MORSE		MINOR CHANGES IN
;	0046	!						CASE THERE IS NO GST.
;	0047	!  02	4-JAN-78	K.D. MORSE		FIX BUG THAT COMPUTES LENGTH
;	0048	!						OF TYPED VARIABLE.
;	0049	!  03	4-JAN-78	K.D. MORSE		PAT$DST_VALUE NOW DISTINGUISHES
;	0050	!						BETWEEN EVALUATE ERRORS. (37)
;	0051	!						FIX BUG IN ADD_MODULE BY SETTING
;	0052	!						THE NT_IS_BOUNDED BIT ONCE THE
;	0053	!						SYMBOL IS BOUNDED. (38)
;	0054	!						NO CHANGES FOR VERS 39.
;	0055	!  04	11-JAN-78	K.D. MORSE		ADD CHECKS FOR BIT FIELDS IN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 1-1
; Digital Equipment Corporation
;
;	0056	!						SECOND TYPE BYTE IN DST,
;	0057	!						(DSTR_ACC01 AND DSTR_ACC23).
;	0058	!  05	24-JAN-78	K.D. MORSE		NO CHANGES FOR 39-40.
;	0059	!  06	28-FEB-78	K.D. MORSE		CHANGE BUILD_MC TO IGNORE THE
;	0060	!						REST OF THE DST IF >50% OF THE
;	0061	!						RST SPACE HAS BEEN TAKEN UP FOR
;	0062	!						MC'S ONLY. (41)
;	0063	!  07	01-MAR-78	K.D. MORSE		NO CHANGES FOR 42-43, PATCH
;	0064	!						WILL NOT ACCEPT FORTRAN ARRAYS
;	0065	!						AS INPUT AND SO SHOULD NOT
;	0066	!						OUTPUT THEM.
;	0067	!  08	24-MAR-78	K.D. MORSE		NO CHANGES FOR 44-45.
;	0068	!  09	28-MAR-78	K.D. MORSE		ADD CODE TO ACCEPT ARRAYS AND
;	0069	!						"PC" RELATIVE DESCRIPTORS.
;	0070	!  10	07-APR-78	K.D. MORSE		REWORKED GLOBALS SO THAT THEY
;	0071	!						ARE NOW MAPPED INSTEAD OF IN
;	0072	!						THE RST.  (46) REMOVED CODE IN
;	0073	!						ADD_SAT THAT CHECKED IF A
;	0074	!						SYMBOL WAS PREVIOUSLY THERE (47).
;	0075	!						MC_GBL_LOCKED IS INITIALIZED (48).
;	0076	!						NO CHANGES FOR VERS 49
;	0077	!  11	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0078	!  12	12-MAY-78	K.D. MORSE		NO CHANGES FOR 50.
;	0079	!						INIT_MC_GLOBALS NOW SETS THE
;	0080	!						MC_IN_RST BIT TO FALSE FOR THE
;	0081	!						SPECIAL GLOBAL MC.  THIS IS
;	0082	!						NECESSARY BECAUSE THE SAT/LVT
;	0083	!						ACCESS FUNCTIONS MAY LOOK THERE
;	0084	!						BUT THERE ARE NO STORAGE
;	0085	!						DESCRIPTORS. (51)
;	0086	!  13	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 52.
;	0087	!  14	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 53.
;	0088	!  15	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0089	!  16	28-JUN-78	K.D. MORSE		CHECK FOR DUPLICATE MODULE NAMES
;	0090	!						IN PAT$BUILD_MC AND IF FOUND
;	0091	!						THEN SKIP SECOND ONE THROUGH
;	0092	!						THE NEXT EOM RECORD. (54)
;	0093	!						NO CHANGES FOR 55-57.
;	0094	!
;	0095	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 2
; Digital Equipment Corporation
;
;	0096	!
;	0097	! TABLE OF CONTENTS:
;	0098	!
;	0099	
;	0100	FORWARD ROUTINE
;	0101		PAT$INIT_RST : NOVALUE,					! Do the RST initialization.
;	0102		INIT_MC_GLOBALS : NOVALUE,				! Initialize the MC chain.
;	0103		BUILD_MC,						! Build the Module Chain (MC).
;	0104		BUILD_RST,						! Initialize the RST so that it
;	0105									!  contains a given set of modules.
;	0106		OK_TO_ADD,						! Check, initialize, and set up to ADD_MODULE
;	0107		PAT$ADD_MODULE,						! Add a module to the RST.
;	0108		ADD_NT,							! Add a DST symbol to the RST.
;	0109		ADD_SAT,						! Make a SAT entry for a symbol.
;	0110		ADD_LVT,						! Make an LVT entry for a symbol.
;	0111		PAT$GET_BOUNDS : NOVALUE;				! Calculate the bounds of an array.
;	0112	
;	0113	!
;	0114	! INCLUDE FILES:
;	0115	!
;	0116	
;	0117	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0118	REQUIRE 'SRC$:PATPCT.REQ';					! Define PATCH PSECTS
;	0134	REQUIRE 'LIB$:PATMSG.REQ';
;	0292	REQUIRE 'SRC$:VXSMAC.REQ';
;	0332	REQUIRE 'SRC$:PATGEN.REQ';
;	0511	REQUIRE 'SRC$:PATRST.REQ';
;	1569	REQUIRE 'SRC$:SYSSER.REQ';
;      R1577	SWITCHES LIST (SOURCE);
;      R1578	
;      R1579	EXTERNAL ROUTINE
;      R1580		PAT$fao_out;		! formats a line and outputs to the terminal
;      R1581	
;      R1582	SWITCHES LIST (NOSOURCE);
;	1627	
;	1628	!
;	1629	! MACROS:
;	1630	!
;	1631	
;	1632	!
;	1633	! EQUATED SYMBOLS:
;	1634	!
;	1635	
;	1636	
;	1637	!
;	1638	! EXTERNAL REFERENCES:
;	1639	!
;	1640	
;	1641	EXTERNAL
;	1642		PAT$GB_SYMBOLS : BYTE,					! Indicator if symbols are in the image
;	1643		PAT$GL_RST_BEGN,					! Starting address of RST
;	1644		PAT$GL_MC_PTR	: REF MC_RECORD,			! Pointer to the Module Chain (MC).
;	1645		PAT$GL_NT_HASH	: REF RST_POINTER;			! Pointer to the name table (NT) hash vector.
;	1646	
;	1647	EXTERNAL ROUTINE

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 2-1
; Digital Equipment Corporation
;
;	1648		PAT$FIND_MODULE,					! Scans module chanin for a module name
;	1649		PAT$SORT_SA_LVT : NOVALUE,				! Sort the SAT or LVT
;	1650		PAT$VS_INIT : NOVALUE,					! Initialize a vector storage area.
;	1651		PAT$VS_GET,						! Allocate records from a so-called
;	1652									!  "vector storage" vector.
;	1653		PAT$VS_FREE : NOVALUE,					! Release vector storage.
;	1654		PAT$VS_SHRINK : NOVALUE,				! Free up unused vector storage.
;	1655		PAT$MODULE_SIZE,					! Deduce how much RST space adding
;	1656									!   a module will take.
;	1657		PAT$DST_VALUE,						! Evaluate a DST
;	1658		PAT$SYMBOL_VALU,					! Evaluate a symbol given its NT_PTR.
;	1659		PAT$NT_HASH_FCN,					! Hashing function for calculating 
;	1660									!   dispersal of NT entries.
;	1661		PAT$POSITON_DST,					! Make a certain DST record available
;	1662									!   and 'SRC$:position' the DST for GET_NXT_DST.
;	1663		PAT$GET_NXT_DST,					! Make the next DST record available.
;	1664		PAT$GET_NXT_GST,					! Make the next GST record available.
;	1665	
;	1666		PAT$GET_NXT_SAT,					! Sequential access to the SAT.
;	1667		PAT$GET_NXT_LVT,					! Sequential access to the LVT.
;	1668	
;	1669		!++
;	1670		! We use two storage allocators - one when we want to allocate or
;	1671		! free up storage we want to address via RST-pointers, and one when
;	1672		! we deal with free storage in the same way that the rest
;	1673		! of PATCH does.
;	1674		!--
;	1675	
;	1676		PAT$FREEZ,						! Allocate and zero a block of ordinary storage.
;	1677		PAT$RST_FREEZ,						! Allocate and zero RST-pointer storage.
;	1678		PAT$REPORT_FREE;					! Report on remaining available RST storage.
;	1679	
;	1680	!
;	1681	! OWN STORAGE:
;	1682	!
;	1683	
;	1684	!++
;	1685	! We maintain a pointer to the MC record for the module we are currently
;	1686	! (de)allocating vector storage for.  This is done simply to avoid passing this
;	1687	! parameter around.
;	1688	!--
;	1689	
;	1690	OWN
;	1691		CURRENT_MODULE : REF MC_RECORD;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 3
; Digital Equipment Corporation
;
;	1692	GLOBAL ROUTINE PAT$INIT_RST : NOVALUE =
;	1693	
;	1694	!++
;	1695	! FUNCTIONAL DESCRIPTION:
;	1696	!
;	1697	!	Do the once-only initialization of PATCH's
;	1698	!	Runtime Symbol Table (RST) data structures.
;	1699	!
;	1700	! FORMAL PARAMETERS:
;	1701	!
;	1702	!	none
;	1703	!
;	1704	! IMPLICIT INPUTS:
;	1705	!
;	1706	!	In general, we expect that error reporting is done at
;	1707	!	the innermost level.  This means that we simply
;	1708	!	return bad status codes all the way out, without saying
;	1709	!	anything.
;	1710	!
;	1711	! IMPLICIT OUTPUTS:
;	1712	!
;	1713	!	none
;	1714	!
;	1715	! COMPLETION CODES:
;	1716	!
;	1717	!	NOVALUE - the only thing which can go wrong that we
;	1718	!		  don't handle is running out of free storage
;	1719	!		  when we ask for it blindly (i.e. not checking
;	1720	!		  that there is enough before we ask for it).
;	1721	!		- This must fail because we only assume that we
;	1722	!		  have enough storage for the NT hash vector and
;	1723	!		  a 1-element MC chain.  If there is really
;	1724	!		  not enough for this, PATCH is surely in trouble.
;	1725	!		- The storage manager doesn't return control to us
;	1726	!		  in any case...
;	1727	!
;	1728	! SIDE EFFECTS:
;	1729	!
;	1730	!	The RST gets initialized.
;	1731	!
;	1732	!--
;	1733	
;	1734	BEGIN
;	1735	
;	1736	LOCAL
;	1737		LIST_ALL,
;	1738		PTR	: REF VECTOR[,BYTE];
;	1739	
;	1740	!++
;	1741	! Before we can do much we must have the NT hash vector.  It is a fixed size and
;	1742	! gets allocated once-and-for-all.
;	1743	!--
;	1744	PAT$GL_NT_HASH = PAT$FREEZ( RST_UNITS(NT_HASH_SIZE * %SIZE(NT_HASH_RECORD)));
;	1745	
;	1746	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 3-1
; Digital Equipment Corporation
;
;	1747	! Add the global symbol definitions to the RST structures, and start off the
;	1748	! module chain with the 'fake' MC record reserved for globals. This code assumes
;	1749	! that PAT$GET_NXT_GST has already been set up so that the first time we call
;	1750	! it the first GST record is returned.  Begin adding MC's to the chain in a
;	1751	! forward-linked fashion.
;	1752	!--
;	1753	INIT_MC_GLOBALS();
;	1754	
;	1755	!++
;	1756	! Build the Module Chain, giving up if it doesn't work.  Note that this routine
;	1757	! only works when the 'next' record, as defined by PAT$GET_NXT_DST, is the first
;	1758	! record in the DST.  If we really wanted to do some manipulating of the DST
;	1759	! before building the module chain, we would have to invent a fake REWIND_DST or
;	1760	! something, or pass BUILD_MC the ID of where to start.  This would mean
;	1761	! that BUILD_MC would have to 'special-case' the first record instead of
;	1762	! just calling 'next' for them all.
;	1763	!--
;	1764	IF (NOT BUILD_MC())
;	1765	THEN
;	1766		RETURN;
;	1767	
;	1768	!++
;	1769	! Build an RST that contains those modules flagged as eligible in the module
;	1770	! chain. We also pass on the estimate of the number of globals that the RST
;	1771	! will contain.	
;	1772	!--
;	1773	IF (NOT BUILD_RST())
;	1774	THEN
;	1775		RETURN;
;	1776			
;	1777	!++
;	1778	! Sort the SAT and LVT vectors so that we can access them (later) more efficiently.
;	1779	!--
;	1780	PAT$SORT_SA_LVT( PAT$GET_NXT_SAT );
;	1781	PAT$SORT_SA_LVT( PAT$GET_NXT_LVT );
;	1782	
;	1783	END;


							    .TITLE  PATBLD
							    .IDENT  \X01.16\

							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 CURRENT_MODULE:
							    .BLKB   4

							    .GLOBL  PAT$GL_RST_BEGN, PAT$FAO_OUT, PAT$GB_SYMBOLS, PAT$GL_MC_PTR
							    .GLOBL  PAT$GL_NT_HASH, PAT$FIND_MODULE, PAT$SORT_SA_LVT
							    .GLOBL  PAT$VS_INIT, PAT$VS_GET, PAT$VS_FREE, PAT$VS_SHRINK
							    .GLOBL  PAT$MODULE_SIZE, PAT$DST_VALUE, PAT$SYMBOL_VALU
							    .GLOBL  PAT$NT_HASH_FCN, PAT$POSITON_DST, PAT$GET_NXT_DST
							    .GLOBL  PAT$GET_NXT_GST, PAT$GET_NXT_SAT, PAT$GET_NXT_LVT
							    .GLOBL  PAT$FREEZ, PAT$RST_FREEZ, PAT$REPORT_FREE


; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 3-2
; Digital Equipment Corporation
;
							    .PSECT  _PAT$CODE,NOWRT,2

					 0800 00000 	    .ENTRY  PAT$INIT_RST, Save R11				      ; 1692
		         5B 00000000G  EF  9E 00002 	    MOVAB   PAT$SORT_SA_LVT, R11				      ;
		         7E	  80   8F  9A 00009 	    MOVZBL  #128, -(SP)						      ; 1744
	      00000000G  EF	       01  FB 0000D 	    CALLS   #1, PAT$FREEZ					      ;
	      00000000G  EF	       50  D0 00014 	    MOVL    R0, PAT$GL_NT_HASH					      ;
	      00000000V  EF	       00  FB 0001B 	    CALLS   #0, INIT_MC_GLOBALS					      ; 1753
	      00000000V  EF	       00  FB 00022 	    CALLS   #0, BUILD_MC					      ; 1764
		         1C	       50  E9 00029 	    BLBC    R0, 1$						      ;
	      00000000V  EF	       00  FB 0002C 	    CALLS   #0, BUILD_RST					      ; 1773
		         12	       50  E9 00033 	    BLBC    R0, 1$						      ;
			    00000000G  EF  9F 00036 	    PUSHAB  PAT$GET_NXT_SAT					      ; 1780
		         6B	       01  FB 0003C 	    CALLS   #1, PAT$SORT_SA_LVT					      ;
			    00000000G  EF  9F 0003F 	    PUSHAB  PAT$GET_NXT_LVT					      ; 1781
		         6B	       01  FB 00045 	    CALLS   #1, PAT$SORT_SA_LVT					      ;
					   04 00048 1$:     RET     							      ; 1692

; Routine Size:  73 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 4
; Digital Equipment Corporation
;
;	1784	ROUTINE INIT_MC_GLOBALS : NOVALUE =
;	1785	
;	1786	!++
;	1787	! Functional Description:
;	1788	!
;	1789	!	This routine initializes the module chain.  It builds the dummy
;	1790	!	entry which is always the first link in the module chain.  All
;	1791	!	the global symbols are linked to the dummy module. This routine
;	1792	!	does that part of RST initialization which MUST
;	1793	!	work if PATCH is to survive.  
;	1794	!
;	1795	! Formal Parameters:
;	1796	!
;	1797	!	NONE
;	1798	!
;	1799	! Implicit Inputs:
;	1800	!
;	1801	!	none.
;	1802	!
;	1803	! Routine Value:
;	1804	!
;	1805	!	NONE
;	1806	!
;	1807	! Side Effects:
;	1808	!
;	1809	!	PAT$GL_MC_PTR gets initialized.
;	1810	!
;	1811	!--
;	1812	
;	1813	BEGIN
;	1814	
;	1815	!++
;	1816	! Build the single MC record which must always exist. This one does NOT
;	1817	! correspond to a module, but rather we use it to 'hang' the globals off.  The
;	1818	! building of this record must go OK - the storage manager doesn't give us
;	1819	! back control.
;	1820	!--
;	1821	PAT$GL_MC_PTR = PAT$RST_FREEZ(RST_UNITS(RST_MC_SIZE));
;	1822	
;	1823	!++
;	1824	! Initialize the few fields which this special MC record must have.  We assume
;	1825	! the rest of the record is 0.  The global MC is never marked 'MC_IN_RST'
;	1826	! because globals are not really 'in' the RST.
;	1827	!--
;	1828	PAT$GL_MC_PTR [MC_IS_GLOBAL] = TRUE;
;	1829	PAT$GL_MC_PTR [MC_IN_RST] = FALSE;
;	1830	PAT$GL_MC_PTR [MC_TYPE] = DSC$K_DTYPE_MOD;
;	1831	
;	1832	!++
;	1833	! Permanently allocate the storage which 'hangs' off this MC entry.  Since
;	1834	! the globals now remain in their own data base (the GST), the RST needs only
;	1835	! one NT and one SAT record for 'cache' use - i.e., we fill them when we
;	1836	! bring a GST entry into the RST for SYM_TO_VAL, etc.
;	1837	!--
;	1838	PAT$GL_MC_PTR[MC_GBL_NT_PTR] = PAT$RST_FREEZ(RST_UNITS(RST_NT_SIZE));

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 4-1
; Digital Equipment Corporation
;
;	1839	PAT$GL_MC_PTR[MC_GBL_SAT_PTR] = PAT$FREEZ(RST_UNITS(RST_SAT_SIZE));
;	1840	
;	1841	!++
;	1842	! Sometimes we do not want the GST consulted in a SYM_TO_VAL, and some
;	1843	! times we have consulted it and do not want some other call to overwrite the
;	1844	! two cache GBL/RST records.  For this reason, the following field is turned
;	1845	! on and off to indicate if the GST is 'locked' or not.
;	1846	!--
;	1847	PAT$GL_MC_PTR[MC_GBL_LOCKED] = FALSE;
;	1848	RETURN;
;	1849	END;





					 0E04 00049 INIT_MC_GLOBALS:
							    .WORD   Save R2,R9,R10,R11					      ; 1784
		         59 00000000G  EF  9E 0004B 	    MOVAB   PAT$RST_FREEZ, R9					      ;
		         5A 00000000G  EF  9E 00052 	    MOVAB   PAT$GL_RST_BEGN, R10				      ;
		         5B 00000000G  EF  9E 00059 	    MOVAB   PAT$GL_MC_PTR, R11					      ;
				       0F  DD 00060 	    PUSHL   #15							      ; 1821
		         69	       01  FB 00062 	    CALLS   #1, PAT$RST_FREEZ					      ;
		         6B	       50  D0 00065 	    MOVL    R0, PAT$GL_MC_PTR					      ;
	   52	         6B	       6A  C1 00068 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R2			      ; 1828
		    03   A2	       01  88 0006C 	    BISB2   #1, 3(R2)						      ;
		    03   A2	       02  8A 00070 	    BICB2   #2, 3(R2)						      ; 1829
		    02   A2	  BC   8F  90 00074 	    MOVB    #-68, 2(R2)						      ; 1830
				       07  DD 00079 	    PUSHL   #7							      ; 1838
		         69	       01  FB 0007B 	    CALLS   #1, PAT$RST_FREEZ					      ;
		    04   A2	       50  B0 0007E 	    MOVW    R0, 4(R2)						      ;
	   52	         6B	       6A  C1 00082 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R2			      ; 1839
				       03  DD 00086 	    PUSHL   #3							      ;
	      00000000G  EF	       01  FB 00088 	    CALLS   #1, PAT$FREEZ					      ;
		    35   A2	       50  D0 0008F 	    MOVL    R0, 53(R2)						      ;
	   50	         6B	       6A  C1 00093 	    ADDL3   PAT$GL_RST_BEGN, PAT$GL_MC_PTR, R0			      ; 1847
		    03   A0	       04  8A 00097 	    BICB2   #4, 3(R0)						      ;
					   04 0009B 	    RET     							      ; 1784

; Routine Size:  83 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5
; Digital Equipment Corporation
;
;	1850	ROUTINE BUILD_MC =
;	1851	
;	1852	!++
;	1853	! FUNCTIONAL DESCRIPTION:
;	1854	!
;	1855	!	This routine builds the Module Chain (MC) directly from the DST.
;	1856	!	This is part of a once-only PATCH initialization procedure.
;	1857	!
;	1858	!	If there is no DST (because none of the module
;	1859	!	were compiled with /debug symbols on), then this
;	1860	!	routine simply returns(true) when the first attempt
;	1861	!	it makes to fetch a DST record returns EOF.
;	1862	!
;	1863	! FORMAL PARAMETERS:
;	1864	!
;	1865	!	none
;	1866	!
;	1867	! IMPLICIT INPUTS:
;	1868	!
;	1869	!	-It is assumed that the first call to PAT$GET_NXT_DST
;	1870	!	that we make will retreive us the first record
;	1871	!	in the DST.
;	1872	!
;	1873	!	-The free-storage manager zeros-out the storage returned.
;	1874	!	(We therefore don't bother to zero-out 
;	1875	!	link fields, etc, in newly-obtained MC records).
;	1876	!
;	1877	!	-We assume that PAT$GL_MC_PTR has already been set to
;	1878	!	 point to the 'dummy' global MC record.
;	1879	!
;	1880	! IMPLICIT OUTPUTS:
;	1881	!
;	1882	!	The MC is built - it contains a host of implications.
;	1883	!
;	1884	! ROUTINE VALUE:
;	1885	!
;	1886	!	NONE
;	1887	!
;	1888	! COMPLETION CODES:
;	1889	!
;	1890	!	TRUE, if all goes OK,
;	1891	!	FALSE, otherwise.
;	1892	!
;	1893	! SIDE EFFECTS:
;	1894	!
;	1895	!	-The MC is built.
;	1896	!	-The DST is 'read' straight through to the end unless going any further
;	1897	!	 would take too much of the RST just for MC's.  In this case, the last
;	1898	!	 part of the DST is henceforth ignored by PATCH.
;	1899	!
;	1900	!--
;	1901	
;	1902	BEGIN
;	1903	
;	1904	LOCAL

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-1
; Digital Equipment Corporation
;
;	1905		SAT_COUNT,						! Count up per-module SAT entries,
;	1906		LVT_COUNT,						! Count up per-module LVT entries,
;	1907		NT_COUNT,						! Count up per-module NT entries,
;	1908		IN_MODULE,						! Flag to say whether we are 'in between'
;	1909									!  MODULE_BEGIN - MODULE_END pairs.
;	1910		DST_REC_ID,						! Record ID passed back by PAT$GET_NXT_DST.
;	1911		CURRENT : REF MC_RECORD,				! Pointer to the MC record we are
;	1912									! currently initializing.
;	1913		DST_RECRD : REF DST_RECORD;			 	! Pointer to the current record
;	1914									! of the DST we are reading.
;	1915	
;	1916	!++
;	1917	! Initialize the context flag IN_MODULE, and begin going thru the DST
;	1918	! sequentially. We assume that someone else, namely PATCH's INIT routine, has
;	1919	! made sure that the DST is available and that the 'next' record is the first
;	1920	! one.  The chain starts off with the 'fake' global MC record.  Other MC's are
;	1921	! added in forward-linked fashion.
;	1922	!--
;	1923	CURRENT = .PAT$GL_MC_PTR;
;	1924	IN_MODULE = FALSE;
;	1925	WHILE( (DST_RECRD = PAT$GET_NXT_DST( DST_REC_ID )) NEQ 0 )
;	1926	DO
;	1927		BEGIN
;	1928		!++
;	1929		! Process each record depending on its DST type.
;	1930		!--
;	1931		CASE .DST_RECRD [DSTR_TYPE] FROM DST_DST_LOWEST TO DST_DST_HIGHEST OF
;	1932	
;	1933		    SET
;	1934	
;	1935		    [DSC$K_DTYPE_MOD]:					! Module Begin Record.
;	1936			BEGIN
;	1937			LOCAL
;	1938				MOD_NAME_DESC : BLOCK[8,BYTE],
;	1939				NEW_PTR : REF MC_RECORD;
;	1940			IF (.IN_MODULE)					! Check for misplaced MODULE record.
;	1941			THEN
;	1942				BEGIN
;	1943				$FAO_TT_OUT( 'Module Begin Phase Error.' );
;	1944				RETURN(FALSE);
;	1945				END;
;	1946	
;	1947			!++
;	1948			! Now check to see if this module is already in the chain.
;	1949			! If found, skip until the next EOM record.
;	1950			!--
;	1951			MOD_NAME_DESC[DSC$W_LENGTH] = .DST_RECRD[DSTR_NAME];
;	1952			MOD_NAME_DESC[DSC$A_POINTER] = DST_RECRD[DSTR_NAME] + 1;
;	1953			IF (PAT$FIND_MODULE(MOD_NAME_DESC, FALSE) NEQ 0)
;	1954			THEN
;	1955				BEGIN
;	1956				$FAO_TT_OUT('Duplicate module !AD ignored.',
;     P 1957					.MOD_NAME_DESC[DSC$W_LENGTH],.MOD_NAME_DESC[DSC$A_POINTER]);
;	1958				DO
;	1959				DST_RECRD = PAT$GET_NXT_DST(DST_REC_ID)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-2
; Digital Equipment Corporation
;
;	1960				UNTIL .DST_RECRD[DSTR_TYPE] EQL DSC$K_DTYPE_EOM;
;	1961				END
;	1962			ELSE
;	1963			BEGIN
;	1964			!++
;	1965			! See if taking the RST space for this new MC record still
;	1966			! leaves a reasonable amount for subsequent "SET MODULE"
;	1967			! commands, (i.e., 50% of the RST).  If this is not the case,
;	1968			! then ignore the rest of the modules and exit from this loop.
;	1969			!--
;	1970			IF NOT PAT$REPORT_FREE() GTR RST_MODU_SIZE
;	1971			THEN
;	1972				BEGIN
;	1973				!++
;	1974				! Report informational message.  This routine must
;	1975				! do a normal return and not an UNWIND.
;	1976				!--
;	1977				SIGNAL(PAT$_LONGDST);
;	1978				EXITLOOP;
;	1979				END;
;	1980	
;	1981			!++
;	1982			! Allocate space for the new MC record.
;	1983			!--
;	1984			IF ((NEW_PTR = PAT$RST_FREEZ(RST_UNITS(RST_MC_SIZE))) EQL 0)
;	1985			THEN
;	1986				RETURN(FALSE);
;	1987			CURRENT [MC_NEXT] = .NEW_PTR;			! Link this one onto the previous one.
;	1988	
;	1989			!++
;	1990			! Initialize the new 'current' node, and those fields belonging
;	1991			! to it that we know the value of at this point. (Some values
;	1992			! get initialized only after  we have read the DST for this
;	1993			! module).
;	1994			!--
;	1995			IN_MODULE = TRUE;
;	1996			CURRENT = .NEW_PTR;
;	1997			SAT_COUNT = 0;
;	1998			LVT_COUNT = 0;
;	1999			NT_COUNT = 0;
;	2000			CURRENT [MC_TYPE] = .DST_RECRD [DSTR_TYPE];
;	2001			CURRENT [MC_DST_START] = .DST_REC_ID;
;	2002			CURRENT [MC_IS_MAIN] = FALSE;
;	2003			CURRENT [MC_IS_GLOBAL] = FALSE;
;	2004	
;	2005			!++
;	2006			! Encode the language indicator into 3 bits. This only
;	2007			! accomodates values 0-7, enough for now.  We may have to
;	2008			! enlarge this field later.
;	2009			!--
;	2010			CURRENT [MC_LANGUAGE] = .DST_RECRD [DSTR_VALUE];
;	2011	
;	2012			!++
;	2013			! If we want all modules to be IN the RST by default, set the
;	2014			! following to TRUE.  Otherwise set it to FALSE, and make the

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-3
; Digital Equipment Corporation
;
;	2015			! decision as to whether or not we want a module after its
;	2016			! DST has been read.  (See DSC$K_DTYPE_EOM, below).
;	2017			!--
;	2018			CURRENT [MC_IN_RST] = FALSE;
;	2019	
;	2020			!++
;	2021			! Moving the name could cause problems if we change the data
;	2022			! representation.  Note that here we move both the name-size
;	2023			! count as well as the name itself.
;	2024			!--
;	2025			CH$MOVE( .DST_RECRD [DSTR_NAME] + 1,
;	2026				DST_RECRD [DSTR_NAME],
;	2027				CURRENT [MC_NAME_CS]);
;	2028			END;
;	2029			END;
;	2030	
;	2031		    [DSC$K_DTYPE_EOM]:					! Module End Record.
;	2032			BEGIN
;	2033			IF (NOT .IN_MODULE)				! Check for misplaced END_MODULE record.
;	2034			THEN
;	2035				BEGIN
;	2036				$FAO_TT_OUT( '!/Module End Phase Error.' );
;	2037				RETURN(FALSE);
;	2038				END;
;	2039	
;	2040			!++
;	2041			! Reset the 'in MODULE' context flag, and initialize the
;	2042			! settings of all MC flag bits.
;	2043			!--
;	2044			IN_MODULE = FALSE;
;	2045	
;	2046			!++
;	2047			! Record the module statistics.
;	2048			!--
;	2049			CURRENT [MC_STATICS] = .SAT_COUNT;
;	2050			CURRENT [MC_LITERALS] = .LVT_COUNT;
;	2051			CURRENT [MC_NAMES] = .NT_COUNT;
;	2052			END;
;	2053	
;	2054		    [DSC$K_DTYPE_RTN,					! Routine DSTs.
;	2055		     DSC$K_DTYPE_SLB]:					! Labels in FORTRAN and BLISS.
;	2056			BEGIN
;	2057			!++
;	2058			! Just tally up the needed statistics so that we can build
;	2059			! the other data  structures later.
;	2060			!--
;	2061			NT_COUNT = .NT_COUNT +1;
;	2062			SAT_COUNT = .SAT_COUNT +1;
;	2063			END;
;	2064	
;	2065		    [DSC$K_DTYPE_EOR,					! BLISS-only End-of-Routine.
;	2066		     DSC$K_DTYPE_FLD]:					! BLISS-only FIELD records.
;	2067			;						! We can safely ignore these for now.
;	2068	
;	2069		    [DSC$K_DTYPE_LBL]:					! Label or Literal DSTs. (MARS only)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-4
; Digital Equipment Corporation
;
;	2070			BEGIN
;	2071			!++
;	2072			! This contributes 1 to NT, and another one to either LVT or SAT.
;	2073			!--
;	2074			NT_COUNT = .NT_COUNT +1;
;	2075			IF (.DST_RECRD [DSTR_ACC01] EQL ACCS_VALUEADR)
;	2076			THEN
;	2077				SAT_COUNT = .SAT_COUNT + 1		! The symbol is an ADDRESS.
;	2078			ELSE
;	2079				IF (.DST_RECRD [DSTR_ACC01] EQL ACCS_LITERAL)
;	2080				THEN
;	2081					LVT_COUNT = .LVT_COUNT +1;	! The symbol is a LITERAL.
;	2082			END;
;	2083	
;	2084		    [DSC$K_DTYPE_PCT]:					! PSECT DSTs.
;	2085			BEGIN
;	2086			IF (NOT.IN_MODULE )
;	2087			THEN
;	2088				BEGIN
;	2089				$FAO_TT_OUT('!/Misplaced PSECT.');
;	2090				RETURN(FALSE);
;	2091				END;
;	2092			NT_COUNT = .NT_COUNT +1;			! PSECTs also count as a symbol name.
;	2093			SAT_COUNT = .SAT_COUNT +1;
;	2094			END;
;	2095		
;	2096		    [INRANGE, OUTRANGE]:
;	2097			BEGIN
;	2098			!++
;	2099			! The only reason for not making the "SRM types"
;	2100			! part of the above CASE is because of the huge
;	2101			! case table which gets generated otherwise.
;	2102			!--
;	2103			IF (.DST_RECRD [DSTR_TYPE] EQL DSC$K_DTYPE_Z)
;	2104			THEN
;	2105				BEGIN
;	2106				!++
;	2107				! BLISS type ZERO records. Whatever symbol this is,
;	2108				! it contributes a name, for sure, and either a literal
;	2109				! or a static.  We assume the worst!
;	2110				!--
;	2111				NT_COUNT = .NT_COUNT +1;
;	2112				LVT_COUNT = .LVT_COUNT +1;
;	2113				SAT_COUNT= .SAT_COUNT +1;
;	2114				END
;	2115			ELSE
;	2116			IF (.DST_RECRD [DSTR_TYPE] LEQ DST_TYP_HIGHEST)
;	2117			THEN
;	2118				BEGIN
;	2119				!++
;	2120				! These types are candidates for the LVT and NT tables only.
;	2121				!--
;	2122				NT_COUNT = .NT_COUNT +1;
;	2123				SAT_COUNT = .SAT_COUNT +1;
;	2124				END

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-5
; Digital Equipment Corporation
;
;	2125			ELSE
;	2126				BEGIN
;	2127				!++
;	2128				! Probably an error in the DST data.
;	2129				!--
;	2130				END;
;	2131			END;
;	2132		    TES;
;	2133		END;							! Go back and process the next DST record.
;	2134	!++
;	2135	! Make sure we didn't run off the end of the DST unexpectedly.  This means that
;	2136	! we insist that EOM be the last record encountered.
;	2137	!--
;	2138	IF (.IN_MODULE)
;	2139	THEN
;	2140		BEGIN
;	2141		$FAO_TT_OUT('Premature End-of-DST Encountered.' );
;	2142		RETURN(FALSE);
;	2143		END;
;	2144	
;	2145	RETURN( TRUE );							! The chain has been built OK.
;	2146	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .BYTE   25							      ;
					      00001 	    .ASCII  \Module Begin Phase Error.\				      ;
					      0001A	    .BLKB   2
					      0001C P.AAB:  .BYTE   29							      ;
					      0001D 	    .ASCII  \Duplicate module !AD ignored.\			      ;
					      0003A	    .BLKB   2
					      0003C P.AAC:  .BYTE   25							      ;
					      0003D 	    .ASCII  \!/Module End Phase Error.\				      ;
					      00056	    .BLKB   2
					      00058 P.AAD:  .BYTE   18							      ;
					      00059 	    .ASCII  \!/Misplaced PSECT.\				      ;
					      0006B	    .BLKB   1
					      0006C P.AAE:  .BYTE   33							      ;
					      0006D 	    .ASCII  \Premature End-of-DST Encountered.\			      ;
					      0008E	    .BLKB   2



							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 0009C BUILD_MC:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11		      ; 1850
		         5E	       0C  C2 0009E 	    SUBL2   #12, SP						      ;
		         5B 00000000G  EF  D0 000A1 	    MOVL    PAT$GL_MC_PTR, CURRENT				      ; 1923
				       5A  D4 000A8 	    CLRL    IN_MODULE						      ; 1924
				       5E  DD 000AA 1$:     PUSHL   SP							      ; 1925
	      00000000G  EF	       01  FB 000AC 	    CALLS   #1, PAT$GET_NXT_DST					      ;
		         56	       50  D0 000B3 	    MOVL    R0, DST_RECRD					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-6
; Digital Equipment Corporation
;
				       03  12 000B6 	    BNEQ    2$							      ;
				     013E  31 000B8 	    BRW     20$							      ;
	   08	    B7   8F	  01   A6  8F 000BB 2$:     CASEB   1(DST_RECRD), #183, #8				      ; 1931
	 0012	       0124	     FFE9     000C1 3$:     .WORD   1$-3$,-						      ;
	 0027	       0131	     0110     000C7		    16$-3$,-						      ;
	 FFE9	       0131	     00EB     000CD		    4$-3$,-						      ;
								    15$-3$,-						      ;
								    17$-3$,-						      ;
								    6$-3$,-						      ;
								    13$-3$,-						      ;
								    17$-3$,-						      ;
								    1$-3$						      ;
				  01   A6  95 000D3 4$:     TSTB    1(DST_RECRD)					      ; 2103
				       07  12 000D6 	    BNEQ    5$							      ;
				       58  D6 000D8 	    INCL    NT_COUNT						      ; 2111
				       59  D6 000DA 	    INCL    LVT_COUNT						      ; 2112
				     0115  31 000DC 	    BRW     18$							      ; 2113
		         17	  01   A6  91 000DF 5$:     CMPB    1(DST_RECRD), #23					      ; 2116
				       C5  1A 000E3 	    BGTRU   1$							      ;
				     010A  31 000E5 	    BRW     17$							      ; 2122
		         0B	       5A  E9 000E8 6$:     BLBC    IN_MODULE, 7$					      ; 1940
				       7E  D4 000EB 	    CLRL    -(SP)						      ; 1943
			    00000000'  EF  9F 000ED 	    PUSHAB  P.AAA						      ;
				     010E  31 000F3 	    BRW     21$							      ;
		    04   AE	  07   A6  9B 000F6 7$:     MOVZBW  7(DST_RECRD), MOD_NAME_DESC				      ; 1951
		    08   AE	  08   A6  9E 000FB 	    MOVAB   8(DST_RECRD), MOD_NAME_DESC+4			      ; 1952
				       7E  D4 00100 	    CLRL    -(SP)						      ; 1953
				  08   AE  9F 00102 	    PUSHAB  MOD_NAME_DESC					      ;
	      00000000G  EF	       02  FB 00105 	    CALLS   #2, PAT$FIND_MODULE					      ;
				       50  D5 0010C 	    TSTL    R0							      ;
				       29  13 0010E 	    BEQL    9$							      ;
				  08   AE  DD 00110 	    PUSHL   MOD_NAME_DESC+4					      ; 1957
		         7E	  08   AE  3C 00113 	    MOVZWL  MOD_NAME_DESC, -(SP)				      ;
			    00000000'  EF  9F 00117 	    PUSHAB  P.AAB						      ;
	      00000000G  EF	       03  FB 0011D 	    CALLS   #3, PAT$FAO_OUT					      ;
				       5E  DD 00124 8$:     PUSHL   SP							      ; 1959
	      00000000G  EF	       01  FB 00126 	    CALLS   #1, PAT$GET_NXT_DST					      ;
		         56	       50  D0 0012D 	    MOVL    R0, DST_RECRD					      ;
		    BD   8F	  01   A6  91 00130 	    CMPB    1(DST_RECRD), #189					      ; 1960
				       ED  12 00135 	    BNEQ    8$							      ;
				       71  11 00137 	    BRB     12$							      ; 1953
	      00000000G  EF	       00  FB 00139 9$:     CALLS   #0, PAT$REPORT_FREE					      ; 1970
	      00007918   8F	       50  D1 00140 	    CMPL    R0, #31000						      ;
				       10  14 00147 	    BGTR    10$							      ;
			    006D8003   8F  DD 00149 	    PUSHL   #7176195						      ; 1977
	      00000000G  00	       01  FB 0014F 	    CALLS   #1, LIB$SIGNAL					      ;
				     00A0  31 00156 	    BRW     20$							      ; 1978
				       0F  DD 00159 10$:    PUSHL   #15							      ; 1984
	      00000000G  EF	       01  FB 0015B 	    CALLS   #1, PAT$RST_FREEZ					      ;
				       50  D5 00162 	    TSTL    NEW_PTR						      ;
				       03  12 00164 	    BNEQ    11$							      ;
				     00A8  31 00166 	    BRW     23$							      ;
	   51	         5B 00000000G  EF  C1 00169 11$:    ADDL3   PAT$GL_RST_BEGN, CURRENT, R1			      ; 1987
		         61	       50  B0 00171 	    MOVW    NEW_PTR, (R1)					      ;
		         5A	       01  D0 00174 	    MOVL    #1, IN_MODULE					      ; 1995

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 5-7
; Digital Equipment Corporation
;
		         5B	       50  D0 00177 	    MOVL    NEW_PTR, CURRENT					      ; 1996
				       57  D4 0017A 	    CLRL    SAT_COUNT						      ; 1997
				       58  7C 0017C 	    CLRQ    NT_COUNT						      ; 1999
	   50	         5B 00000000G  EF  C1 0017E 	    ADDL3   PAT$GL_RST_BEGN, CURRENT, R0			      ; 2000
		    02   A0	  01   A6  90 00186 	    MOVB    1(DST_RECRD), 2(R0)					      ;
		    04   A0	       6E  D0 0018B 	    MOVL    DST_REC_ID, 4(R0)					      ; 2001
		    03   A0	       05  8A 0018F 	    BICB2   #5, 3(R0)						      ; 2003
	   03	         03	  03   A6  F0 00193 	    INSV    3(DST_RECRD), #3, #3, 3(R0)				      ; 2010
				  03   A0     00198									      ;
		    03   A0	       02  8A 0019A 	    BICB2   #2, 3(R0)						      ; 2018
		         51	  07   A6  9A 0019E 	    MOVZBL  7(DST_RECRD), R1					      ; 2025
				       51  D6 001A2 	    INCL    R1							      ;
      0C   A0	    07   A6	       51  28 001A4 	    MOVC3   R1, 7(DST_RECRD), 12(R0)				      ;
				       4A  11 001AA 12$:    BRB     19$							      ; 1931
		         0A	       5A  E8 001AC 13$:    BLBS    IN_MODULE, 14$					      ; 2033
				       7E  D4 001AF 	    CLRL    -(SP)						      ; 2036
			    00000000'  EF  9F 001B1 	    PUSHAB  P.AAC						      ;
				       4B  11 001B7 	    BRB     21$							      ;
				       5A  D4 001B9 14$:    CLRL    IN_MODULE						      ; 2044
	   50	         5B 00000000G  EF  C1 001BB 	    ADDL3   PAT$GL_RST_BEGN, CURRENT, R0			      ; 2049
		    31   A0	       57  D0 001C3 	    MOVL    SAT_COUNT, 49(R0)					      ;
		    35   A0	       59  D0 001C7 	    MOVL    LVT_COUNT, 53(R0)					      ; 2050
		    08   A0	       58  D0 001CB 	    MOVL    NT_COUNT, 8(R0)					      ; 2051
				       25  11 001CF 	    BRB     19$							      ; 1931
				       58  D6 001D1 15$:    INCL    NT_COUNT						      ; 2074
      02   A6	         02	       00  ED 001D3 	    CMPZV   #0, #2, 2(DST_RECRD), #1				      ; 2075
				       01     001D8									      ;
				       19  13 001D9 	    BEQL    18$							      ;
		         03	  02   A6  93 001DB 	    BITB    2(DST_RECRD), #3					      ; 2079
				       15  12 001DF 	    BNEQ    19$							      ;
				       59  D6 001E1 	    INCL    LVT_COUNT						      ; 2081
				       11  11 001E3 	    BRB     19$							      ; 1931
		         0A	       5A  E8 001E5 16$:    BLBS    IN_MODULE, 17$					      ; 2086
				       7E  D4 001E8 	    CLRL    -(SP)						      ; 2089
			    00000000'  EF  9F 001EA 	    PUSHAB  P.AAD						      ;
				       12  11 001F0 	    BRB     21$							      ;
				       58  D6 001F2 17$:    INCL    NT_COUNT						      ; 2092
				       57  D6 001F4 18$:    INCL    SAT_COUNT						      ; 2093
				     FEB1  31 001F6 19$:    BRW     1$							      ; 1925
		         11	       5A  E9 001F9 20$:    BLBC    IN_MODULE, 22$					      ; 2138
				       7E  D4 001FC 	    CLRL    -(SP)						      ; 2141
			    00000000'  EF  9F 001FE 	    PUSHAB  P.AAE						      ;
	      00000000G  EF	       02  FB 00204 21$:    CALLS   #2, PAT$FAO_OUT					      ;
				       04  11 0020B 	    BRB     23$							      ; 2142
		         50	       01  D0 0020D 22$:    MOVL    #1, R0						      ; 2145
					   04 00210 	    RET     							      ;
				       50  D4 00211 23$:    CLRL    R0							      ; 1850
					   04 00213 	    RET     							      ;

; Routine Size:  376 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 6
; Digital Equipment Corporation
;
;	2147	ROUTINE BUILD_RST =
;	2148	
;	2149	!++
;	2150	! FUNCTIONAL DESCRIPTION:
;	2151	!
;	2152	!	Initialize the RST given a module chain.
;	2153	!
;	2154	! FORMAL PARAMETERS:
;	2155	!
;	2156	!	none.
;	2157	!
;	2158	! IMPLICIT INPUTS:
;	2159	!
;	2160	!	PAT$GL_MC_PTR	-is assumed to RST-point (in the sense
;	2161	!			 that an RST-pointer points) to the beginning
;	2162	!			 of the MC.  This MC is assumed to contain
;	2163	!			 all necessary information about those
;	2164	!			 modules marked elegible to be in the RST.
;	2165	!
;	2166	! IMPLICIT OUTPUTS:
;	2167	!
;	2168	!	There will be at least RST_AVAIL_SIZE bytes of
;	2169	!	free storage left after this routine finishes.
;	2170	!
;	2171	! ROUTINE VALUE:
;	2172	!
;	2173	!	none
;	2174	!
;	2175	! COMPLETION CODES:
;	2176	!
;	2177	!	TRUE, if all went OK, FALSE otherwise.
;	2178	!
;	2179	! SIDE EFFECTS:
;	2180	!
;	2181	!	A warning message is produced if any of the
;	2182	!	modules marked MC_IN_RST are not added to
;	2183	!	the RST.  This happens when we don't have
;	2184	!	enough space.
;	2185	!
;	2186	!--
;	2187	
;	2188	BEGIN
;	2189	
;	2190	LOCAL
;	2191		NOT_ALL_ADDED,						! A flag to tell if we added all the
;	2192									!  modules we wanted to.
;	2193		MC_PTR : REF MC_RECORD;					! Pointer to current MC record.
;	2194	
;	2195	!++
;	2196	! Initialize the flag that we use to detect when we didn't get to add all
;	2197	! modules we wanted to.
;	2198	!--
;	2199	NOT_ALL_ADDED = FALSE;
;	2200	
;	2201	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 6-1
; Digital Equipment Corporation
;
;	2202	! Loop thru the module chain trying to add the indicated modules to the RST.
;	2203	!  Note that we purposely don't look at the first MC record in the chain because
;	2204	! is is reserved for globals.
;	2205	!--
;	2206	MC_PTR = .PAT$GL_MC_PTR;
;	2207	WHILE( (MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0 )
;	2208	DO
;	2209		IF (.MC_PTR [MC_IN_RST])
;	2210		THEN
;	2211			IF (NOT PAT$ADD_MODULE( .MC_PTR ))		! Try to add the module.
;	2212			THEN
;	2213				BEGIN
;	2214				not_all_added = true;
;	2215				MC_PTR [MC_IN_RST] = FALSE;
;	2216				END;
;	2217	
;	2218	!++
;	2219	! Produce a warning message if we didn't add all those we tried to.
;	2220	!--
;	2221	IF (.NOT_ALL_ADDED) 
;	2222	THEN
;	2223		SIGNAL(PAT$_NOTALLSYM);
;	2224	
;	2225	RETURN(TRUE);
;	2226	END;





					 080C 00214 BUILD_RST:
							    .WORD   Save R2,R3,R11					      ; 2147
		         5B 00000000G  EF  9E 00216 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
				       53  D4 0021D 	    CLRL    NOT_ALL_ADDED					      ; 2199
		         52 00000000G  EF  D0 0021F 	    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 2206
	   50	         52	       6B  C1 00226 1$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2207
		         52	       60  3C 0022A 	    MOVZWL  (R0), MC_PTR					      ;
				       22  13 0022D 	    BEQL    2$							      ;
	   50	         52	       6B  C1 0022F 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2209
	   EE	    03   A0	       01  E1 00233 	    BBC     #1, 3(R0), 1$					      ;
				       52  DD 00238 	    PUSHL   MC_PTR						      ; 2211
	      00000000V  EF	       01  FB 0023A 	    CALLS   #1, PAT$ADD_MODULE					      ;
		         E2	       50  E8 00241 	    BLBS    R0, 1$						      ;
		         53	       01  D0 00244 	    MOVL    #1, NOT_ALL_ADDED					      ; 2214
	   50	         52	       6B  C1 00247 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2215
		    03   A0	       02  8A 0024B 	    BICB2   #2, 3(R0)						      ;
				       D5  11 0024F 	    BRB     1$							      ; 2209
		         0D	       53  E9 00251 2$:     BLBC    NOT_ALL_ADDED, 3$					      ; 2221
			    006D8013   8F  DD 00254 	    PUSHL   #7176211						      ; 2223
	      00000000G  00	       01  FB 0025A 	    CALLS   #1, LIB$SIGNAL					      ;
		         50	       01  D0 00261 3$:     MOVL    #1, R0						      ; 2225
					   04 00264 	    RET     							      ; 2147

; Routine Size:  81 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 6-2
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7
; Digital Equipment Corporation
;
;	2227	GLOBAL ROUTINE PAT$ADD_MODULE( MODULE_TO_ADD ) =
;	2228	
;	2229	!++
;	2230	! FUNCTIONAL DESCRIPTION:
;	2231	!
;	2232	!	Add the indicated module to the RST data base.
;	2233	!
;	2234	! FORMAL PARAMETERS:
;	2235	!
;	2236	!	MODULE_TO_ADD	-An RST-pointer to the MC record for
;	2237	!			 the module we are to initialize.
;	2238	!			 This is necessary because this module
;	2239	!			 is scope-wise 'above' all symbols
;	2240	!			 declared in the outer block of this module.
;	2241	!
;	2242	! IMPLICIT INPUTS:
;	2243	!
;	2244	!	none.
;	2245	!
;	2246	! IMPLICIT OUTPUTS:
;	2247	!
;	2248	!	none
;	2249	!
;	2250	! COMPLETION CODES:
;	2251	!
;	2252	!	TRUE, if all goes OK, FALSE otherwise.
;	2253	!
;	2254	! SIDE EFFECTS:
;	2255	!
;	2256	!	The symbols for the indicated module get added to
;	2257	!	the various RST data structures.
;	2258	!
;	2259	!--
;	2260	
;	2261	BEGIN
;	2262	
;	2263	LABEL
;	2264		ADD_DST_LOOP;						! The overall structure of this routine
;	2265									! is one large loop in which we add
;	2266									! successive DSTs to the RST.
;	2267	
;	2268	MAP
;	2269		MODULE_TO_ADD : REF MC_RECORD;
;	2270	
;	2271	LOCAL
;	2272		DST_REC_ID,						! ID we are passed back so that we can
;	2273									!  later refer to DST records.
;	2274		DST_RECRD : REF DST_RECORD,				! Pointer to where a fetched DST record lives.
;	2275		NT_PTR : REF NT_RECORD;					! Pointer to NT records we build.
;	2276	
;	2277	!++ 
;	2278	! A new module must define a new position from which to start as far as building
;	2279	! in scope structure is concerned.  To do this we reinitialize the scope stack,
;	2280	! a stack of RST-pointers, the top one of which points to the NT or MC record
;	2281	! that corresponds to the symbol (MODULE or ROUTINE) that is scope-wise above

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-1
; Digital Equipment Corporation
;
;	2282	! any symbol currently being added to the RST data base.  The reason why we
;	2283	! need a stack to keep track of this is simply because BLISS allows nested
;	2284	! ROUTINE declarations.
;	2285	!
;	2286	! Likewise we have to stack SAT pointers to ROUTINE SAT records so that when
;	2287	! we get the corresponding end-of-routine we can go to the SAT and fix up
;	2288	! the UB value.
;	2289	!--
;	2290	LOCAL
;	2291		SCOPE_STACK : VECTOR [MAX_SCOPE_DEPTH +1, %SIZE(RST_POINTER)],
;	2292		SAT_RTN_STACK : VECTOR [MAX_SCOPE_DEPTH +1, %SIZE(SAT_POINTER)],
;	2293		SCOPE_STACK_PTR,					! Index to current top of scope stack.
;	2294		CURENT_LANGUAGE;					! Per-module source code language indicator.
;	2295	
;	2296	!++
;	2297	! Make sure that we can go ahead and add the indicated module.  Also peform
;	2298	! any needed checks and initializations.
;	2299	!--
;	2300	IF (NOT OK_TO_ADD(.MODULE_TO_ADD, CURENT_LANGUAGE))
;	2301	THEN
;	2302		RETURN(FALSE);
;	2303	
;	2304	!++
;	2305	! Initialize the scope and SAT_RTN stacks.  (See above). Since the top-of-stack
;	2306	! entry is MODULE, the corresponding entry in the SAT_RTN stack is not used,
;	2307	! in BLISS, always used, in FORTRAN, and never used, in MARS.  This is because
;	2308	! BLISS has 'real' scoping, FORTRAN's scope is only 1 level deep, and MARS
;	2309	! doesn't give us DST entries for end-of-routines.
;	2310	!--
;	2311	SCOPE_STACK_PTR = 0;
;	2312	CH$FILL(0, %ALLOCATION(SAT_RTN_STACK), SAT_RTN_STACK );
;	2313	CH$FILL(0, %ALLOCATION(SCOPE_STACK), SCOPE_STACK );
;	2314	SCOPE_STACK[0] = .MODULE_TO_ADD;
;	2315	
;	2316	!++
;	2317	! Now process the DST record by record, ending when we encounter a module_end
;	2318	! record, or when some error occurs.
;	2319	!--
;	2320	WHILE( (DST_RECRD = PAT$GET_NXT_DST( DST_REC_ID )) NEQ 0 )
;	2321	DO
;	2322	   ADD_DST_LOOP:						! Failure to add a DST => we LEAVE add block.
;	2323		BEGIN
;	2324		!++
;	2325		! We process each record depending on its DST type.
;	2326		!--
;	2327		CASE .DST_RECRD [DSTR_TYPE] FROM DST_DST_LOWEST TO DST_DST_HIGHEST OF
;	2328		    SET
;	2329	
;	2330		    [DSC$K_DTYPE_EOM]:					! End module record.
;	2331			BEGIN
;	2332			!++
;	2333			! This is the ONLY successful way this routine can terminate
;	2334			! since we insist that a group of DST records end with an End
;	2335			! Module record.
;	2336			! Modules added OK are not about to be deleted.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-2
; Digital Equipment Corporation
;
;	2337			!--
;	2338			MODULE_TO_ADD [MC_IS_DYING] = FALSE;
;	2339	
;	2340			!++
;	2341			! See if we can free up some of the vector storage allocated
;	2342			! for this module.  This will be the case when we didn't actually
;	2343			! add as many of the NTs, SATs, or LVTs as the MC statictics
;	2344			! indicated we might. (Which is almost always the case because
;	2345			! the gathering  is not as detailed as it might be).
;	2346			!--
;	2347			PAT$VS_SHRINK( MODULE_TO_ADD [MC_NT_STORAGE] );
;	2348			PAT$VS_SHRINK( MODULE_TO_ADD [MC_SAT_STORAGE] );
;	2349			PAT$VS_SHRINK( MODULE_TO_ADD [MC_LVT_STORAGE] );
;	2350			RETURN(TRUE);
;	2351			END;
;	2352	
;	2353		    [DSC$K_DTYPE_RTN]:					! Begin a ROUTINE record.
;	2354			BEGIN
;	2355			!++
;	2356			! In all languages, a routine name is at least a symbol, which
;	2357			! must therefore appear in the NT. Add the symbol to the NT.
;	2358			!--
;	2359			IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])
;	2360			    ) EQL 0 )
;	2361			THEN
;	2362				LEAVE ADD_DST_LOOP;
;	2363	
;	2364			!++
;	2365			! Then, in BLISS, each routine record also  implies that we go
;	2366			! one level down as far as scope is concerned.  This is why we
;	2367			! maintain the so-called scope stack.
;	2368			!--
;	2369			IF (.CURENT_LANGUAGE EQL BLISS_MODULE)
;	2370			THEN
;	2371				BEGIN
;	2372				!++
;	2373				! Check for scope stack overflow.
;	2374				!--
;	2375				IF ((SCOPE_STACK_PTR = .SCOPE_STACK_PTR +1) GTR MAX_SCOPE_DEPTH)
;	2376				THEN
;	2377					BEGIN
;	2378					$FAO_TT_OUT('!/PAT$add_module: scope depth overflow');
;	2379					RETURN(FALSE);
;	2380					END;
;	2381	
;	2382				!++
;	2383				! Push the new scope level onto the scope stack.
;	2384				!--
;	2385				SCOPE_STACK [.SCOPE_STACK_PTR] = .NT_PTR;
;	2386				END;
;	2387	
;	2388			!++
;	2389			! Routine symbols also go into the SAT. The catch here is that
;	2390			! we don't yet know the length of the routine, so we have to
;	2391			! stack a pointer to the SAT record we build so that we can

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-3
; Digital Equipment Corporation
;
;	2392			! fix up this problem when we do get the info.
;	2393			!--
;	2394			IF ((SAT_RTN_STACK [.SCOPE_STACK_PTR] = 
;	2395				ADD_SAT( .NT_PTR, .DST_RECRD [DSTR_VALUE], 0))
;	2396			   EQL 0 )
;	2397			THEN
;	2398				BEGIN
;	2399				!++
;	2400				! Don't allow the next end_of_routine record
;	2401				! to overwrite something invalid.
;	2402				!--
;	2403				SAT_RTN_STACK [.SCOPE_STACK_PTR] = 0;
;	2404				RETURN(FALSE);
;	2405				END;
;	2406			END;
;	2407	
;	2408		    [DSC$K_DTYPE_EOR]:					! End of (BLISS and FORTRAN) routine.
;	2409			BEGIN
;	2410			!++
;	2411			! This is where we finally get to find out the length that the
;	2412			! current routine was.  This info allows us to complete the
;	2413			! building of the RST record which corresponds to the routine
;	2414			! itself.  If we do not have a valid pointer to this routine's
;	2415			! SAT, some logic error has occurred.
;	2416			!--
;	2417			IF (.SAT_RTN_STACK [.SCOPE_STACK_PTR] NEQ 0)
;	2418			THEN
;	2419				BEGIN
;	2420				LOCAL
;	2421					FIXUP_SAT_PTR : REF SAT_RECORD,
;	2422					RTN_NT_PTR : REF NT_RECORD;
;	2423	
;	2424				!++
;	2425				! Pickup a pointer to the SAT record which corresponds
;	2426				! the associated  ROUTINE NT record.
;	2427				!--
;	2428				FIXUP_SAT_PTR = .SAT_RTN_STACK [.SCOPE_STACK_PTR];
;	2429	
;	2430				!++
;	2431				! The upper bound for this routine is the address at
;	2432				! which the code for it ends.  NOTE: we have now
;	2433				! 'bounded' the symbol.
;	2434				!--
;	2435				FIXUP_SAT_PTR [SAT_UB] = .FIXUP_SAT_PTR [SAT_LB] 
;	2436					+ .DST_RECRD [DSTR_VALUE] -1;
;	2437				RTN_NT_PTR = .FIXUP_SAT_PTR [SAT_NT_PTR];	! ++37
;	2438				RTN_NT_PTR [NT_IS_BOUNDED] = TRUE;		! ++37
;	2439				SAT_RTN_STACK [.SCOPE_STACK_PTR] = 0;
;	2440				END
;	2441			ELSE
;	2442				BEGIN
;	2443				$FAO_TT_OUT('!/rtn end without begin');
;	2444				RETURN(FALSE);
;	2445				END;
;	2446	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-4
; Digital Equipment Corporation
;
;	2447			!++
;	2448			! Pop a scope level off of the scope stack.
;	2449			!--
;	2450			IF (.CURENT_LANGUAGE EQL BLISS_MODULE)
;	2451			THEN
;	2452				IF ((SCOPE_STACK_PTR = .SCOPE_STACK_PTR -1) LSS 0) ! Check for scope stack underflow.
;	2453				THEN
;	2454					BEGIN
;	2455					$FAO_TT_OUT('!/add_module: scope depth underflow');
;	2456					RETURN(FALSE);
;	2457					END;
;	2458			END;
;	2459	
;	2460		    [DSC$K_DTYPE_FLD]:				 ! BLISS fields are ignored.
;	2461			BEGIN
;	2462			END;
;	2463	
;	2464		    [DSC$K_DTYPE_LBL,					! Label or Literal DSTs. (MARS only)
;	2465		     DSC$K_DTYPE_SLB]:					! Labels in FORTRAN and BLISS.
;	2466			BEGIN
;	2467			!++
;	2468			! Add the symbol to the NT.
;	2469			!--
;	2470			IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
;	2471			THEN
;	2472				LEAVE ADD_DST_LOOP;
;	2473	
;	2474			!++
;	2475			! Then, add it to the LVT or SAT, depending
;	2476			! on whether the symbol is a literal or not.
;	2477			! Here PATCH ignores registers while DEBUG does not.
;	2478			! Hence, the more specific check of field DSTR_ACC01.
;	2479			!--
;	2480			IF ((.DST_RECRD [DSTR_TYPE] EQL DSC$K_DTYPE_SLB) OR
;	2481			   (.DST_RECRD [DSTR_ACC01] EQL ACCS_VALUEADR))
;	2482			THEN
;	2483				BEGIN
;	2484				IF (ADD_SAT( .NT_PTR, .DST_RECRD [DSTR_VALUE], 0) EQL 0)
;	2485				THEN
;	2486					RETURN(FALSE);
;	2487				END
;	2488			ELSE
;	2489				BEGIN
;	2490				IF (.DST_RECRD [DSTR_ACC01] EQL ACCS_LITERAL)
;	2491				THEN
;	2492					IF (NOT ADD_LVT( .NT_PTR, .DST_RECRD [DSTR_VALUE]))
;	2493					THEN
;	2494						RETURN(FALSE);
;	2495				END;
;	2496			END;
;	2497		    [DSC$K_DTYPE_PCT]:					! P-SECT record.
;	2498			BEGIN
;	2499			LOCAL
;	2500				PSECT_LENGTH : REF VECTOR[,LONG];
;	2501			!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-5
; Digital Equipment Corporation
;
;	2502			! Add the symbol to the NT.
;	2503			!--
;	2504			IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
;	2505			THEN
;	2506				LEAVE ADD_DST_LOOP;
;	2507	
;	2508			!++
;	2509			! The symbols also goes into the SAT. Since we have to pass on
;	2510			! the length of the PSECT, we must extract a field which is
;	2511			! in a variable position within the DST. This code must be
;	2512			! changed if the psect length is not directly after the counted
;	2513			! string name.
;	2514			!--
;	2515			PSECT_LENGTH = DST_RECRD[DSTR_NAME] + .DST_RECRD[DSTR_NAME] +1;
;	2516			IF (ADD_SAT( .NT_PTR, .DST_RECRD [DSTR_VALUE],
;	2517				.DST_RECRD [DSTR_VALUE] + .PSECT_LENGTH[0] ) EQL 0)
;	2518			THEN
;	2519				RETURN(FALSE);
;	2520			END;
;	2521	
;	2522		    [INRANGE, OUTRANGE]:
;	2523			BEGIN
;	2524			!++
;	2525			! This should be a separate CASE, but isn't due simply to the
;	2526			! size of the case table.  PATCH handles the following types
;	2527			! of symbols:
;	2528			!	dsc$k_dtype_v		bit
;	2529			!	dsc$k_dtype_bu		byte logical
;	2530			!	dsc$k_dtype_wu		word logical
;	2531			!	dsc$k_dtype_lu		longword logical
;	2532			!	dsc$k_dtype_qu		quadword logical
;	2533			!	dsc$k_dtype_b		byte integer
;	2534			!	dsc$k_dtype_w		word integer
;	2535			!	dsc$k_dtype_l		longword integer
;	2536			!	dsc$k_dtype_q		quadword integer
;	2537			!	dsc$k_dtype_f		single-precision floating
;	2538			!	dsc$k_dtype_d		double-precision floating
;	2539			!	dsc$k_dtype_fc		complex
;	2540			!	dsc$k_dtype_dc		double-precision complex
;	2541			!	dsc$k_dtype_t		ascii text
;	2542			!	dsc$k_dtype_nu		numeric string, unsigned
;	2543			!	dsc$k_dtype_nl		numeric string, left separate sign
;	2544			!	dsc$k_dtype_nlo		numeric string, left overpunched sign
;	2545			!	dsc$k_dtype_nr		numeric string, right separate sign
;	2546			!	dsc$k_dtype_nro		numeric string, right overpunched sign
;	2547			!	dsc$k_dtype_nz		numeric string, zoned sign
;	2548			!	dsc$k_dtype_p		packed decimal string
;	2549			!	dsc$k_dtype_zi		sequence of instructions
;	2550			!	dsc$k_dtype_zem		procedure entry mask
;	2551			! PATCH ignores the following types of symbols:
;	2552			!	dsc$k_dtype_z		unspecified
;	2553			!--
;	2554			IF (.DST_RECRD [DSTR_TYPE] GEQ DSC$K_DTYPE_V) AND
;	2555			   (.DST_RECRD [DSTR_TYPE] LEQ DST_TYP_HIGHEST)
;	2556			THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-6
; Digital Equipment Corporation
;
;	2557				!++
;	2558				! Check that PATCH can handle the symbol.  Discard
;	2559				! symbols defined as registers or by descriptors,
;	2560				! (bits 2+3 equal to 2 or 3) and symbols whose values
;	2561				! are based off registers (bits 0+1 equal to 2 or 3).
;	2562				! The remaining symbols (literals or value addresses not
;	2563				! based off registers) are now added to the NT and SAT.
;	2564				!--	
;	2565				IF ((.DST_RECRD[DSTR_ACC01] EQL ACCS_LITERAL) OR
;	2566				    (.DST_RECRD[DSTR_ACC01] EQL ACCS_VALUEADR))
;	2567				AND
;	2568				   ((.DST_RECRD[DSTR_ACC23] EQL ACCS_NOTBASDIR) OR
;	2569				    (.DST_RECRD[DSTR_ACC23] EQL ACCS_NOTBASIND))
;	2570				THEN
;	2571					BEGIN
;	2572					!++
;	2573					! Most of these symbols should also go into the SAT.
;	2574					! The ones that should not are the BLISS type 0
;	2575					! symbols which are not static.  PATCH
;	2576					! completely ignores all records which are type
;	2577					! 0 (unspecified) so there is no test to weed
;	2578					! them out here.
;	2579					! Processing of SRM data types depends
;	2580					! on whether the datum is scalar or not.
;	2581					! Only scalars are handled here.
;	2582					!--
;	2583					LOCAL
;	2584						SIZE;
;	2585					OWN
;	2586					    SRM_LENGTHS : VECTOR[12,BYTE]	! Sizes of SRM type data.
;	2587					    INITIAL( BYTE (
;	2588						1, !	DSC$K_DTYPE_BU,	Byte logical.
;	2589						2, !	DSC$K_DTYPE_WU,	Word logical.
;	2590						4, !	DSC$K_DTYPE_LU,	Longword logical.
;	2591						8, !	DSC$K_DTYPE_QU,	Quadword logical.
;	2592						1, !	DSC$K_DTYPE_B,	Byte integer.
;	2593						2, !	DSC$K_DTYPE_W,	Word integer.
;	2594						4, !	DSC$K_DTYPE_L,	Longword integer.
;	2595						8, !	DSC$K_DTYPE_Q,	Quadword integer.
;	2596						4, !	DSC$K_DTYPE_F,  single-precision floating
;	2597						8, !	DSC$K_DTYPE_D,  double-precision floating
;	2598						8, !	DSC$K_DTYPE_FC, complex
;	2599						16 !	DSC$K_DTYPE_DC, double-precision complex
;	2600					    ));
;	2601	
;	2602					!++
;	2603					! The only so-called SRM types which we
;	2604					! know the size of are those from
;	2605					! DSC$k_DTYPE_BU to _DC, inclusive.
;	2606					! We simply pick this size value out 
;	2607					! of the above vector.
;	2608					!--	
;	2609					IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
;	2610					THEN
;	2611						LEAVE ADD_DST_LOOP;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-7
; Digital Equipment Corporation
;
;	2612					SIZE = .DST_RECRD [DSTR_TYPE];
;	2613					IF (.SIZE GEQ DSC$K_DTYPE_BU) AND
;	2614					    (.SIZE LEQ DSC$K_DTYPE_DC)
;	2615					THEN
;	2616						SIZE = .DST_RECRD [DSTR_VALUE] - 1 +
;	2617							.SRM_LENGTHS [.SIZE - DSC$K_DTYPE_BU]
;	2618					ELSE
;	2619						!++
;	2620						! Unknown upper-bound addresses
;	2621						! must be 0.
;	2622						!--	
;	2623						SIZE = 0;
;	2624		
;	2625					!++
;	2626					! Add the symbols known to be static to the SAT.
;	2627					!--	
;	2628					IF (ADD_SAT(.NT_PTR, .DST_RECRD [DSTR_VALUE], .SIZE) EQL 0)
;	2629					THEN
;	2630						RETURN(FALSE);
;	2631					END				! end of TYPES _V THRU _Q
;	2632				ELSE
;	2633					BEGIN
;	2634					!++
;	2635					! Array types are more complicated than scalars
;	2636					! as there is more involved in calculating the
;	2637					! lower and upper address bounds.
;	2638					!--
;	2639					LOCAL
;	2640						DESC_ADDRESS,
;	2641						BOUNDS : ARRAY_BNDS_DESC;
;	2642					!++
;	2643					! Eliminate all dynamic arrays.  Those kept are
;	2644					! are described within the DST -- so called
;	2645					! "PC" based descriptors which have _BASD = 2
;	2646					! and _BREG = 15.
;	2647					!--
;	2648					IF (.DST_RECRD[DSTR_ACCES_TYPE] EQL ACCS_DESCRIPTOR) AND
;	2649					   (.DST_RECRD[DSTR_ACCES_BASD] EQL ACCS_BASDIR) AND
;	2650					       (.DST_RECRD[DSTR_ACCES_BREG] EQL 15)
;	2651					THEN
;	2652						BEGIN
;	2653						!++
;	2654						! If _BASD and _BREG are both zero, then
;	2655						! the descriptor may not be complete.
;	2656						! In this case the ADD_NT call fails.
;	2657						!--
;	2658						IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
;	2659						THEN
;	2660							LEAVE ADD_DST_LOOP;
;	2661						!++
;	2662						! Get the address of the array descriptor and
;	2663						! use it to build a 'bounds descriptor'.
;	2664						!--
;	2665						IF (PAT$DST_VALUE(.DST_RECRD, DESC_ADDRESS) EQL 0)
;	2666						THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-8
; Digital Equipment Corporation
;
;	2667							RETURN(FALSE);		! THIS TYPE NOT HANDLED
;	2668						PAT$GET_BOUNDS(.DESC_ADDRESS, BOUNDS);
;	2669	
;	2670						!++
;	2671						! The beginning of the array plus the number of
;	2672						! bytes of elements minus one is the address of
;	2673						! the end of the array.
;	2674						! Add this symbol to the SAT.
;	2675						!--
;	2676						IF (ADD_SAT(.NT_PTR, .BOUNDS[ARRAY_ADDRESS],
;	2677								.BOUNDS[ARRAY_ADDRESS] + 
;	2678								.BOUNDS[ARRAY_LENGTH] -1)
;	2679						   EQL 0)
;	2680						THEN
;	2681							RETURN(FALSE);
;	2682						END;			! END OF ARRAYS HANDLED CURRENTLY
;	2683					END;				! END OF ARRAYS AND DESCRIPTORS
;	2684			END;						! END OF INRANGE,OUTRANGE
;	2685		    TES;						! END OF CASE LOOP
;	2686		END;							! Go back and process the next record. (ADD_DST_LOOP)
;	2687	
;	2688	!++
;	2689	! If the above WHILE exits, then we encountered the end of the DST records
;	2690	! before we got an END_MODULE record to end the beginning MODULE one.  This is
;	2691	! considered a fatal error.
;	2692	!--
;	2693	$FAO_TT_OUT('!/Premature end of DST in routine ADD_MODULE.');
;	2694	
;	2695	RETURN(FALSE);
;	2696	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00090 P.AAF:  .BYTE   38							      ;
					      00091 	    .ASCII  \!/PAT$add_module: scope depth overflow\		      ;
					      000B7	    .BLKB   1
					      000B8 P.AAG:  .BYTE   23							      ;
					      000B9 	    .ASCII  \!/rtn end without begin\				      ;
					      000D0 P.AAH:  .BYTE   35							      ;
					      000D1 	    .ASCII  \!/add_module: scope depth underflow\		      ;
					      000F4 P.AAI:  .BYTE   45							      ;
					      000F5 	    .ASCII  \!/Premature end of DST in routine ADD_MODULE.\	      ;
					      00122	    .BLKB   2

							    .PSECT  _PAT$OWN,NOEXE,2

					      00004 SRM_LENGTHS:
							    .BYTE   1, 2, 4, 8, 1, 2, 4, 8, 4, 8, 8, 16			      ;



							    .PSECT  _PAT$CODE,NOWRT,2


; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-9
; Digital Equipment Corporation
;
					 0FFC 00265 	    .ENTRY  PAT$ADD_MODULE, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11      ; 2227
		         58 00000000G  EF  9E 00267 	    MOVAB   PAT$VS_SHRINK, R8					      ;
		         59 00000000'  EF  9E 0026E 	    MOVAB   P.AAF, R9						      ;
		         5A 00000000G  EF  9E 00275 	    MOVAB   PAT$GL_RST_BEGN, R10				      ;
		         5B 00000000V  EF  9E 0027C 	    MOVAB   ADD_NT, R11						      ;
		         5E	  A8   AE  9E 00283 	    MOVAB   -88(SP), SP						      ;
				  08   AE  9F 00287 	    PUSHAB  CURENT_LANGUAGE					      ; 2300
		         57	  04   AC  D0 0028A 	    MOVL    MODULE_TO_ADD, R7					      ;
				       57  DD 0028E 	    PUSHL   R7							      ;
	      00000000V  EF	       02  FB 00290 	    CALLS   #2, OK_TO_ADD					      ;
		         03	       50  E8 00297 	    BLBS    R0, 1$						      ;
				     020F  31 0029A 	    BRW     34$							      ;
				       56  D4 0029D 1$:     CLRL    SCOPE_STACK_PTR					      ; 2311
	   00	         6E	       00  2C 0029F 	    MOVC5   #0, (SP), #0, #44, SAT_RTN_STACK			      ; 2312
		    14   AE	       2C     002A3									      ;
	   00	         6E	       00  2C 002A6 	    MOVC5   #0, (SP), #0, #22, SCOPE_STACK			      ; 2313
		    40   AE	       16     002AA									      ;
		    40   AE	       57  B0 002AD 	    MOVW    R7, SCOPE_STACK					      ; 2314
				  04   AE  9F 002B1 2$:     PUSHAB  DST_REC_ID						      ; 2320
	      00000000G  EF	       01  FB 002B4 	    CALLS   #1, PAT$GET_NXT_DST					      ;
		         52	       50  D0 002BB 	    MOVL    R0, DST_RECRD					      ;
				       03  12 002BE 	    BNEQ    3$							      ;
				     01DD  31 002C0 	    BRW     32$							      ;
		         55	  01   A2  9E 002C3 3$:     MOVAB   1(DST_RECRD), R5					      ; 2327
	   08	    B7   8F	       65  8F 002C7 	    CASEB   (R5), #183, #8					      ;
	 0012	       01A1	     FFE5     002CC 4$:     .WORD   2$-4$,-						      ;
	 0012	       0169	     0169     002D2		    29$-4$,-						      ;
	 012B	       00E9	     00C2     002D8		    5$-4$,-						      ;
								    25$-4$,-						      ;
								    25$-4$,-						      ;
								    5$-4$,-						      ;
								    15$-4$,-						      ;
								    16$-4$,-						      ;
								    19$-4$						      ;
		         01	       65  91 002DE 5$:     CMPB    (R5), #1						      ; 2554
				       CE  1F 002E1 	    BLSSU   2$							      ;
		         17	       65  91 002E3 	    CMPB    (R5), #23						      ; 2555
				       C9  1A 002E6 	    BGTRU   2$							      ;
		         54	  02   A2  9E 002E8 	    MOVAB   2(DST_RECRD), R4					      ; 2565
		         03	       64  93 002EC 	    BITB    (R4), #3						      ;
				       07  13 002EF 	    BEQL    6$							      ;
	   64	         02	       00  ED 002F1 	    CMPZV   #0, #2, (R4), #1					      ; 2566
				       01     002F5									      ;
				       41  12 002F6 	    BNEQ    10$							      ;
		         0C	       64  93 002F8 6$:     BITB    (R4), #12						      ; 2568
				       07  13 002FB 	    BEQL    7$							      ;
	   64	         02	       02  ED 002FD 	    CMPZV   #2, #2, (R4), #1					      ; 2569
				       01     00301									      ;
				       35  12 00302 	    BNEQ    10$							      ;
		         7E	  40 AE46  3C 00304 7$:     MOVZWL  SCOPE_STACK[SCOPE_STACK_PTR], -(SP)			      ; 2609
				       52  DD 00309 	    PUSHL   DST_RECRD						      ;
		         6B	       02  FB 0030B 	    CALLS   #2, ADD_NT						      ;
		         53	       50  D0 0030E 	    MOVL    R0, NT_PTR						      ;
				       9E  13 00311 	    BEQL    2$							      ;
		         50	       65  9A 00313 	    MOVZBL  (R5), SIZE						      ; 2612

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-10
; Digital Equipment Corporation
;
		         02	       50  D1 00316 	    CMPL    SIZE, #2						      ; 2613
				       17  19 00319 	    BLSS    8$							      ;
		         0D	       50  D1 0031B 	    CMPL    SIZE, #13						      ; 2614
				       12  14 0031E 	    BGTR    8$							      ;
		         51 00000000'EF40  9A 00320 	    MOVZBL  SRM_LENGTHS-2[SIZE], R1				      ; 2616
		         51	  03   A2  C0 00328 	    ADDL2   3(DST_RECRD), R1					      ;
	   50	         51	       01  C3 0032C 	    SUBL3   #1, R1, SIZE					      ;
				       02  11 00330 	    BRB     9$							      ; 2613
				       50  D4 00332 8$:     CLRL    SIZE						      ; 2623
				       50  DD 00334 9$:     PUSHL   SIZE						      ; 2628
				     0155  31 00336 	    BRW     30$							      ;
	   64	         02	       00  ED 00339 10$:    CMPZV   #0, #2, (R4), #2					      ; 2648
				       02     0033D									      ;
				       0C  12 0033E 	    BNEQ    11$							      ;
	   64	         02	       02  ED 00340 	    CMPZV   #2, #2, (R4), #2					      ; 2649
				       02     00344									      ;
				       05  12 00345 	    BNEQ    11$							      ;
	   64	         04	       04  ED 00347 	    CMPZV   #4, #4, (R4), #15					      ; 2650
				       0F     0034B									      ;
				       03  13 0034C 11$:    BEQL    13$							      ;
				     FF60  31 0034E 12$:    BRW     2$							      ;
		         7E	  40 AE46  3C 00351 13$:    MOVZWL  SCOPE_STACK[SCOPE_STACK_PTR], -(SP)			      ; 2658
				       52  DD 00356 	    PUSHL   DST_RECRD						      ;
		         6B	       02  FB 00358 	    CALLS   #2, ADD_NT						      ;
		         53	       50  D0 0035B 	    MOVL    R0, NT_PTR						      ;
				       EE  13 0035E 	    BEQL    12$							      ;
				4004   8F  BB 00360 	    PUSHR   #^M<R2,SP>						      ; 2665
	      00000000G  EF	       02  FB 00364 	    CALLS   #2, PAT$DST_VALUE					      ;
				       50  D5 0036B 	    TSTL    R0							      ;
				       03  12 0036D 	    BNEQ    14$							      ;
				     013A  31 0036F 	    BRW     34$							      ;
				  0C   AE  9F 00372 14$:    PUSHAB  BOUNDS						      ; 2668
				  04   AE  DD 00375 	    PUSHL   DESC_ADDRESS					      ;
	      00000000V  EF	       02  FB 00378 	    CALLS   #2, PAT$GET_BOUNDS					      ;
	   50	    0C   AE	  10   AE  C1 0037F 	    ADDL3   BOUNDS+4, BOUNDS, R0				      ; 2677
				  FF   A0  9F 00385 	    PUSHAB  -1(R0)						      ; 2678
				  10   AE  DD 00388 	    PUSHL   BOUNDS						      ; 2676
				     0103  31 0038B 	    BRW     31$							      ;
	   50	         57	       6A  C1 0038E 15$:    ADDL3   PAT$GL_RST_BEGN, R7, R0				      ; 2338
		    03   A0	  40   8F  8A 00392 	    BICB2   #64, 3(R0)						      ;
				  1C   A0  9F 00397 	    PUSHAB  28(R0)						      ; 2347
		         68	       01  FB 0039A 	    CALLS   #1, PAT$VS_SHRINK					      ;
	   50	         57	       6A  C1 0039D 	    ADDL3   PAT$GL_RST_BEGN, R7, R0				      ; 2348
				  23   A0  9F 003A1 	    PUSHAB  35(R0)						      ;
		         68	       01  FB 003A4 	    CALLS   #1, PAT$VS_SHRINK					      ;
	   50	         57	       6A  C1 003A7 	    ADDL3   PAT$GL_RST_BEGN, R7, R0				      ; 2349
				  2A   A0  9F 003AB 	    PUSHAB  42(R0)						      ;
		         68	       01  FB 003AE 	    CALLS   #1, PAT$VS_SHRINK					      ;
		         50	       01  D0 003B1 	    MOVL    #1, R0						      ; 2350
					   04 003B4 	    RET     							      ;
		         7E	  40 AE46  3C 003B5 16$:    MOVZWL  SCOPE_STACK[SCOPE_STACK_PTR], -(SP)			      ; 2359
				       52  DD 003BA 	    PUSHL   DST_RECRD						      ;
		         6B	       02  FB 003BC 	    CALLS   #2, ADD_NT						      ;
		         53	       50  D0 003BF 	    MOVL    R0, NT_PTR						      ;
				       67  13 003C2 	    BEQL    22$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-11
; Digital Equipment Corporation
;
		         02	  08   AE  D1 003C4 	    CMPL    CURENT_LANGUAGE, #2					      ; 2369
				       12  12 003C8 	    BNEQ    18$							      ;
				       56  D6 003CA 	    INCL    SCOPE_STACK_PTR					      ; 2375
		         0A	       56  D1 003CC 	    CMPL    SCOPE_STACK_PTR, #10				      ;
				       06  15 003CF 	    BLEQ    17$							      ;
				       7E  D4 003D1 	    CLRL    -(SP)						      ; 2378
				       59  DD 003D3 	    PUSHL   R9							      ;
				       5C  11 003D5 	    BRB     24$							      ;
		    40 AE46	       53  B0 003D7 17$:    MOVW    NT_PTR, SCOPE_STACK[SCOPE_STACK_PTR]		      ; 2385
				       7E  D4 003DC 18$:    CLRL    -(SP)						      ; 2395
				  03   A2  DD 003DE 	    PUSHL   3(DST_RECRD)					      ;
				       53  DD 003E1 	    PUSHL   NT_PTR						      ;
	      00000000V  EF	       03  FB 003E3 	    CALLS   #3, ADD_SAT						      ;
		    14 AE46	       50  D0 003EA 	    MOVL    R0, SAT_RTN_STACK[SCOPE_STACK_PTR]			      ;
				       3A  12 003EF 	    BNEQ    22$							      ; 2394
				  14 AE46  D4 003F1 	    CLRL    SAT_RTN_STACK[SCOPE_STACK_PTR]			      ; 2403
				       74  11 003F5 	    BRB     28$							      ; 2404
		         50	  14 AE46  D0 003F7 19$:    MOVL    SAT_RTN_STACK[SCOPE_STACK_PTR], R0			      ; 2417
				       1C  13 003FC 	    BEQL    20$							      ;
	   51	    02   A0	  03   A2  C1 003FE 	    ADDL3   3(DST_RECRD), 2(FIXUP_SAT_PTR), R1			      ; 2436
      06   A0	         51	       01  C3 00404 	    SUBL3   #1, R1, 6(FIXUP_SAT_PTR)				      ;
		         50	       60  3C 00409 	    MOVZWL  (FIXUP_SAT_PTR), RTN_NT_PTR				      ; 2437
		         50	       6A  C0 0040C 	    ADDL2   PAT$GL_RST_BEGN, R0					      ; 2438
		    03   A0	  80   8F  88 0040F 	    BISB2   #128, 3(R0)						      ;
				  14 AE46  D4 00414 	    CLRL    SAT_RTN_STACK[SCOPE_STACK_PTR]			      ; 2439
				       07  11 00418 	    BRB     21$							      ; 2417
				       7E  D4 0041A 20$:    CLRL    -(SP)						      ; 2443
				  28   A9  9F 0041C 	    PUSHAB  P.AAG						      ;
				       12  11 0041F 	    BRB     24$							      ;
		         02	  08   AE  D1 00421 21$:    CMPL    CURENT_LANGUAGE, #2					      ; 2450
				       04  12 00425 	    BNEQ    22$							      ;
				       56  D7 00427 	    DECL    SCOPE_STACK_PTR					      ; 2452
				       03  19 00429 	    BLSS    23$							      ;
				     FE83  31 0042B 22$:    BRW     2$							      ;
				       7E  D4 0042E 23$:    CLRL    -(SP)						      ; 2455
				  40   A9  9F 00430 	    PUSHAB  P.AAH						      ;
				       70  11 00433 24$:    BRB     33$							      ;
		         7E	  40 AE46  3C 00435 25$:    MOVZWL  SCOPE_STACK[SCOPE_STACK_PTR], -(SP)			      ; 2470
				       52  DD 0043A 	    PUSHL   DST_RECRD						      ;
		         6B	       02  FB 0043C 	    CALLS   #2, ADD_NT						      ;
		         53	       50  D0 0043F 	    MOVL    R0, NT_PTR						      ;
				       E7  13 00442 	    BEQL    22$							      ;
		    BB   8F	       65  91 00444 	    CMPB    (R5), #187						      ; 2480
				       08  13 00448 	    BEQL    26$							      ;
      02   A2	         02	       00  ED 0044A 	    CMPZV   #0, #2, 2(DST_RECRD), #1				      ; 2481
				       01     0044F									      ;
				       04  12 00450 	    BNEQ    27$							      ;
				       7E  D4 00452 26$:    CLRL    -(SP)						      ; 2484
				       38  11 00454 	    BRB     30$							      ;
		         03	  02   A2  93 00456 27$:    BITB    2(DST_RECRD), #3					      ; 2490
				       CF  12 0045A 	    BNEQ    22$							      ;
				  03   A2  DD 0045C 	    PUSHL   3(DST_RECRD)					      ; 2492
				       53  DD 0045F 	    PUSHL   NT_PTR						      ;
	      00000000V  EF	       02  FB 00461 	    CALLS   #2, ADD_LVT						      ;
		         C0	       50  E8 00468 	    BLBS    R0, 22$						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 7-12
; Digital Equipment Corporation
;
				       3F  11 0046B 28$:    BRB     34$							      ; 2494
		         7E	  40 AE46  3C 0046D 29$:    MOVZWL  SCOPE_STACK[SCOPE_STACK_PTR], -(SP)			      ; 2504
				       52  DD 00472 	    PUSHL   DST_RECRD						      ;
		         6B	       02  FB 00474 	    CALLS   #2, ADD_NT						      ;
		         53	       50  D0 00477 	    MOVL    R0, NT_PTR						      ;
				       AF  13 0047A 	    BEQL    22$							      ;
		         50	       52  D0 0047C 	    MOVL    DST_RECRD, R0					      ; 2515
		         50	  07   A0  9A 0047F 	    MOVZBL  7(R0), R0						      ;
		         50	       52  C0 00483 	    ADDL2   DST_RECRD, R0					      ;
		         50	       08  C0 00486 	    ADDL2   #8, PSECT_LENGTH					      ;
	   7E	    03   A2	       60  C1 00489 	    ADDL3   (PSECT_LENGTH), 3(DST_RECRD), -(SP)			      ; 2517
				  03   A2  DD 0048E 30$:    PUSHL   3(DST_RECRD)					      ; 2516
				       53  DD 00491 31$:    PUSHL   NT_PTR						      ;
	      00000000V  EF	       03  FB 00493 	    CALLS   #3, ADD_SAT						      ;
				       50  D5 0049A 	    TSTL    R0							      ;
				       8D  12 0049C 	    BNEQ    22$							      ;
				       0C  11 0049E 	    BRB     34$							      ; 2519
				       7E  D4 004A0 32$:    CLRL    -(SP)						      ; 2693
				  64   A9  9F 004A2 	    PUSHAB  P.AAI						      ;
	      00000000G  EF	       02  FB 004A5 33$:    CALLS   #2, PAT$FAO_OUT					      ;
				       50  D4 004AC 34$:    CLRL    R0							      ; 2227
					   04 004AE 	    RET     							      ;

; Routine Size:  586 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8
; Digital Equipment Corporation
;
;	2697	ROUTINE OK_TO_ADD( MODULE_TO_ADD, LANGUAGE_ADDR ) =
;	2698	
;	2699	!++
;	2700	! FUNCTIONAL DESCRIPTION:
;	2701	!
;	2702	!	See if it is OK to add the indicated module to the RST data base.
;	2703	!	Also perform all necessary initializations so that ADD_MODULE
;	2704	!	can go ahead an do so.
;	2705	!
;	2706	! FORMAL PARAMETERS:
;	2707	!
;	2708	!	MODULE_TO_ADD	-An RST-pointer to the MC record for
;	2709	!			 the module we are to initialize.
;	2710	!	LANGUAGE_ADDR	-The address of where we should pass
;	2711	!			 back the module's language.  If this
;	2712	!			 value = 0, we don't position the DST
;	2713	!			 or check or pass back the language indicator.
;	2714	!
;	2715	! IMPLICIT INPUTS:
;	2716	!
;	2717	!	We believe the given MC pointer.  In particular,
;	2718	!	we will not allocate storage for a module
;	2719	!	if the corresponding storage descriptor
;	2720	!	already contains a pointer.  (i.e. is not 0).
;	2721	!
;	2722	! IMPLICIT OUTPUTS:
;	2723	!
;	2724	!	ADD_MODULE will not fail if it is called after this
;	2725	!	routine successfully completes.
;	2726	!
;	2727	!	The language code may be passed back to the caller.
;	2728	!
;	2729	! ROUTINE VALUE:
;	2730	! COMPLETION CODES:
;	2731	!
;	2732	!	TRUE, if all goes OK, FALSE otherwise.
;	2733	!
;	2734	! SIDE EFFECTS:
;	2735	!
;	2736	!	Storage for all symbols for this module
;	2737	!	is allocated so that PAT$VS_GET can then
;	2738	!	simply dole it out.
;	2739	!
;	2740	!	The DST is 'positioned' so that PAT$GET_NXT_DST
;	2741	!	will be able to sequentially read the DST starting
;	2742	!	at the first record in the DST after the DST record
;	2743	!	for the indicated module.
;	2744	!
;	2745	!--
;	2746	
;	2747	BEGIN
;	2748	
;	2749	MAP
;	2750		LANGUAGE_ADDR : REF VECTOR,
;	2751		MODULE_TO_ADD : REF MC_RECORD;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8-1
; Digital Equipment Corporation
;
;	2752	
;	2753	LOCAL
;	2754		DST_RECRD : REF DST_RECORD,				! Pointer to where a fetched DST record lives.
;	2755		BEGIN_DST_AT,						! ID of DST record where the DST for
;	2756									!  the module we are to add begins.
;	2757		DST_REC_ID,						! ID we are passed back so that we can
;	2758									!  later refer to DST records.
;	2759		CURENT_LANGUAGE,					! Per-module source code language indicator.
;	2760		NT_PTR : REF NT_RECORD,					! Pointer to NT records we build.
;	2761		STORAGE_DESC : REF VECT_STORE_DESC;			! We use the MC-contained descriptor of
;	2762									! vector storage for all indicated symbols.
;	2763	
;	2764	!++
;	2765	! Make sure that we have enough space to add this module before we begin.  This
;	2766	! is necessary because it would be very difficult to 'back out' once we began,
;	2767	! and we wouldn't like to have modules half initialized.
;	2768	!--
;	2769	IF (NOT (PAT$REPORT_FREE() - PAT$MODULE_SIZE(.MODULE_TO_ADD)) GTR RST_AVAIL_SIZE)
;	2770	THEN
;	2771		!++
;	2772		! We don't try to handle this one here because what is appropriate
;	2773		! depends on when (why) the module was being initialized.
;	2774		!--
;	2775		RETURN(FALSE);
;	2776	
;	2777	!++
;	2778	! Before allocating space for NT symbols, make sure that there will be some.
;	2779	!  It makes no sense for a module to be added which has no name symbols.
;	2780	!--
;	2781	IF (.MODULE_TO_ADD [MC_NAMES] EQL 0)
;	2782	THEN
;	2783		RETURN(FALSE);
;	2784	!++
;	2785	! See if NT storage has already been allocated.  To do this, pick up the vector
;	2786	! storage descriptor for the  indicated NT records and see that it points to 0.
;	2787	!--
;	2788	STORAGE_DESC = MODULE_TO_ADD [MC_NT_STORAGE];
;	2789	IF (.STORAGE_DESC [STOR_BEGIN_RST] NEQ 0)
;	2790	THEN
;	2791		RETURN(FALSE);
;	2792	
;	2793	!++
;	2794	! If we are going to allocate stroage for any SATs or LVTs, again check that
;	2795	! none is already allocated.
;	2796	!--
;	2797	IF (.MODULE_TO_ADD [MC_STATICS] NEQ 0)
;	2798	THEN
;	2799		BEGIN
;	2800		STORAGE_DESC = MODULE_TO_ADD [MC_SAT_STORAGE];
;	2801		IF (.STORAGE_DESC [STOR_BEGIN_RST] NEQ 0)
;	2802		THEN
;	2803			RETURN(FALSE);
;	2804		END;
;	2805	IF (.MODULE_TO_ADD [MC_LITERALS] NEQ 0)
;	2806	THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8-2
; Digital Equipment Corporation
;
;	2807		BEGIN
;	2808		STORAGE_DESC = MODULE_TO_ADD [MC_LVT_STORAGE];
;	2809		IF (.STORAGE_DESC [STOR_BEGIN_RST] NEQ 0)
;	2810		THEN
;	2811			RETURN(FALSE);
;	2812		END;
;	2813	
;	2814	!++
;	2815	! At this point there is more to do only if the given MC pointer is to the
;	2816	! 'global' MC record.  This is  because there is no DST checking or language
;	2817	! verification for the global MC case.
;	2818	!--
;	2819	IF (.LANGUAGE_ADDR NEQ 0)
;	2820	THEN
;	2821		BEGIN
;	2822		!++
;	2823		! Processing for all DST-originated modules.
;	2824		!
;	2825		! First, pick up the supposed DST record ID of where the DST for this
;	2826		! module begins.	
;	2827		!--
;	2828		BEGIN_DST_AT = .MODULE_TO_ADD [MC_DST_START];
;	2829		
;	2830		!++
;	2831		! Position the DST to the indicated record, and
;	2832		! make sure that it is of type MODULE.
;	2833		!--	
;	2834		IF ((DST_RECRD = PAT$POSITON_DST( .BEGIN_DST_AT )) EQL 0)
;	2835		THEN
;	2836			BEGIN
;	2837			!++	
;	2838			! The supposed record does not exist.
;	2839			!--	
;	2840			RETURN(FALSE);
;	2841			END
;	2842		ELSE
;	2843			!++
;	2844			! The record is reachable.  Make sure it is MODULE.
;	2845			!--	
;	2846			IF (.DST_RECRD [DSTR_TYPE] NEQ DSC$K_DTYPE_MOD)
;	2847			THEN
;	2848				BEGIN
;	2849				$FAO_TT_OUT('!/DST MODULE misplaced.');
;	2850				RETURN(FALSE);
;	2851				END;
;	2852		
;	2853		!++
;	2854		! Record type is OK.  Check that we know which source language the
;	2855		! module was written in.
;	2856		!--	
;	2857		IF((CURENT_LANGUAGE = .DST_RECRD [DSTR_VALUE]) NEQ MARS_MODULE)
;	2858		THEN
;	2859			!++
;	2860			! If it's not MARS, it must be BLISS or FORTRAN.
;	2861			!--	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8-3
; Digital Equipment Corporation
;
;	2862			IF (.CURENT_LANGUAGE NEQ BLISS_MODULE ) AND
;	2863			   (.CURENT_LANGUAGE NEQ FORTRAN_MODULE)
;	2864			THEN
;	2865				BEGIN
;	2866				$FAO_TT_OUT('!/Foreign language module: !XL',
;     P 2867					.CURENT_LANGUAGE);
;	2868				RETURN(FALSE);
;	2869				END;
;	2870	
;	2871		!++
;	2872		! Pass back the language code in which this module is written.  This is
;	2873		! needed because the caller of this routine doesn't get to look at the
;	2874		! DST record for this module.
;	2875		!--	
;	2876		LANGUAGE_ADDR[0] = .CURENT_LANGUAGE;
;	2877		END;
;	2878	
;	2879	!++
;	2880	! Now that nothing can go wrong, go ahead and allocate all
;	2881	! NT, and possibly all SAT and/or all LVT storage.
;	2882	!--
;	2883	PAT$VS_INIT(	MODULE_TO_ADD [MC_NT_STORAGE],
;	2884				.MODULE_TO_ADD [MC_NAMES],
;	2885				RST_NT_SIZE
;	2886			      );
;	2887	
;	2888	!++
;	2889	! NT storage is accessed via RST-pointers.
;	2890	!--
;	2891	MODULE_TO_ADD [MC_NT_STORAGE] = FALSE;
;	2892	
;	2893	!++
;	2894	! Likewise for SAT and LVT storage.  Only here we don't mind if no storage will
;	2895	! be needed.
;	2896	!--
;	2897	IF (.MODULE_TO_ADD [MC_STATICS] NEQ 0)
;	2898	THEN
;	2899		BEGIN
;	2900		PAT$VS_INIT(	MODULE_TO_ADD [MC_SAT_STORAGE],
;	2901				.MODULE_TO_ADD [MC_STATICS],
;	2902				RST_SAT_SIZE
;	2903			      );
;	2904	
;	2905		!++
;	2906		! SAT storage is not accessed via RST-pointers.
;	2907		!--
;	2908		MODULE_TO_ADD [MC_SAT_STORAGE] = TRUE;
;	2909		END;
;	2910	IF (.MODULE_TO_ADD [MC_LITERALS] NEQ 0)
;	2911	THEN
;	2912		BEGIN
;	2913		PAT$VS_INIT(	MODULE_TO_ADD [MC_LVT_STORAGE],
;	2914				.MODULE_TO_ADD [MC_LITERALS],
;	2915				RST_LVT_SIZE
;	2916			      );

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8-4
; Digital Equipment Corporation
;
;	2917	
;	2918		!++
;	2919		! LVT storage is not accessed via RST-pointers.
;	2920		!--
;	2921		MODULE_TO_ADD [MC_LVT_STORAGE] = TRUE;
;	2922		END;
;	2923	
;	2924	!++
;	2925	! Set the OWN variable which various other routines in this module work from,
;	2926	! to indicate which module we are currently building.  This is the only place
;	2927	! where this variable gets set.
;	2928	!--
;	2929	CURRENT_MODULE = .MODULE_TO_ADD;
;	2930	
;	2931	!++
;	2932	! Looks like we're OK to go ahead and try to! add the indicated module.  This is
;	2933	! the only place in this routine where we return TRUE status.
;	2934	!--
;	2935	RETURN(TRUE);
;	2936	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00124 P.AAJ:  .BYTE   23							      ;
					      00125 	    .ASCII  \!/DST MODULE misplaced.\				      ;
					      0013C P.AAK:  .BYTE   30							      ;
					      0013D 	    .ASCII  \!/Foreign language module: !XL\			      ;
					      0015B	    .BLKB   1



							    .PSECT  _PAT$CODE,NOWRT,2

					 0C0C 004AF OK_TO_ADD:
							    .WORD   Save R2,R3,R10,R11					      ; 2697
		         5A 00000000G  EF  9E 004B1 	    MOVAB   PAT$VS_INIT, R10					      ;
		         5B 00000000G  EF  9E 004B8 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
	      00000000G  EF	       00  FB 004BF 	    CALLS   #0, PAT$REPORT_FREE					      ; 2769
		         52	       50  D0 004C6 	    MOVL    R0, R2						      ;
		         53	  04   AC  D0 004C9 	    MOVL    MODULE_TO_ADD, R3					      ;
				       53  DD 004CD 	    PUSHL   R3							      ;
	      00000000G  EF	       01  FB 004CF 	    CALLS   #1, PAT$MODULE_SIZE					      ;
		         52	       50  C2 004D6 	    SUBL2   R0, R2						      ;
	      00000BB8   8F	       52  D1 004D9 	    CMPL    R2, #3000						      ;
				       75  15 004E0 	    BLEQ    5$							      ;
	   52	         53	       6B  C1 004E2 	    ADDL3   PAT$GL_RST_BEGN, R3, R2				      ; 2781
				  08   A2  D5 004E6 	    TSTL    8(R2)						      ;
				       6C  13 004E9 	    BEQL    5$							      ;
	   50	         52	       1C  C1 004EB 	    ADDL3   #28, R2, STORAGE_DESC				      ; 2788
				  01   A0  B5 004EF 	    TSTW    1(STORAGE_DESC)					      ; 2789
				       63  12 004F2 	    BNEQ    5$							      ;
				  31   A2  D5 004F4 	    TSTL    49(R2)						      ; 2797
				       09  13 004F7 	    BEQL    1$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8-5
; Digital Equipment Corporation
;
	   50	         52	       23  C1 004F9 	    ADDL3   #35, R2, STORAGE_DESC				      ; 2800
				  01   A0  B5 004FD 	    TSTW    1(STORAGE_DESC)					      ; 2801
				       55  12 00500 	    BNEQ    5$							      ;
				  35   A2  D5 00502 1$:     TSTL    53(R2)						      ; 2805
				       09  13 00505 	    BEQL    2$							      ;
	   50	         52	       2A  C1 00507 	    ADDL3   #42, R2, STORAGE_DESC				      ; 2808
				  01   A0  B5 0050B 	    TSTW    1(STORAGE_DESC)					      ; 2809
				       47  12 0050E 	    BNEQ    5$							      ;
				  08   AC  D5 00510 2$:     TSTL    LANGUAGE_ADDR					      ; 2819
				       48  13 00513 	    BEQL    7$							      ;
		         50	  04   A2  D0 00515 	    MOVL    4(R2), BEGIN_DST_AT					      ; 2828
				       50  DD 00519 	    PUSHL   BEGIN_DST_AT					      ; 2834
	      00000000G  EF	       01  FB 0051B 	    CALLS   #1, PAT$POSITON_DST					      ;
		         52	       50  D0 00522 	    MOVL    R0, DST_RECRD					      ;
				       30  13 00525 	    BEQL    5$							      ;
		    BC   8F	  01   A2  91 00527 	    CMPB    1(DST_RECRD), #188					      ; 2846
				       0A  13 0052C 	    BEQL    3$							      ;
				       7E  D4 0052E 	    CLRL    -(SP)						      ; 2849
			    00000000'  EF  9F 00530 	    PUSHAB  P.AAJ						      ;
				       18  11 00536 	    BRB     4$							      ;
		         52	  03   A2  D0 00538 3$:     MOVL    3(DST_RECRD), CURENT_LANGUAGE			      ; 2857
				       1B  13 0053C 	    BEQL    6$							      ;
		         02	       52  D1 0053E 	    CMPL    CURENT_LANGUAGE, #2					      ; 2862
				       16  13 00541 	    BEQL    6$							      ;
		         01	       52  D1 00543 	    CMPL    CURENT_LANGUAGE, #1					      ; 2863
				       11  13 00546 	    BEQL    6$							      ;
				       52  DD 00548 	    PUSHL   CURENT_LANGUAGE					      ; 2867
			    00000000'  EF  9F 0054A 	    PUSHAB  P.AAK						      ;
	      00000000G  EF	       02  FB 00550 4$:     CALLS   #2, PAT$FAO_OUT					      ;
				       55  11 00557 5$:     BRB     10$							      ; 2868
		    08   BC	       52  D0 00559 6$:     MOVL    CURENT_LANGUAGE, @LANGUAGE_ADDR			      ; 2876
				       1C  DD 0055D 7$:     PUSHL   #28							      ; 2883
	   52	         53	       6B  C1 0055F 	    ADDL3   PAT$GL_RST_BEGN, R3, R2				      ; 2884
				  08   A2  DD 00563 	    PUSHL   8(R2)						      ; 2883
				  1C   A2  9F 00566 	    PUSHAB  28(R2)						      ;
		         6A	       03  FB 00569 	    CALLS   #3, PAT$VS_INIT					      ;
	   52	         53	       6B  C1 0056C 	    ADDL3   PAT$GL_RST_BEGN, R3, R2				      ; 2891
				  1C   A2  94 00570 	    CLRB    28(R2)						      ;
				  31   A2  D5 00573 	    TSTL    49(R2)						      ; 2897
				       13  13 00576 	    BEQL    8$							      ;
				       0A  DD 00578 	    PUSHL   #10							      ; 2900
				  31   A2  DD 0057A 	    PUSHL   49(R2)						      ;
				  23   A2  9F 0057D 	    PUSHAB  35(R2)						      ;
		         6A	       03  FB 00580 	    CALLS   #3, PAT$VS_INIT					      ;
	   52	         53	       6B  C1 00583 	    ADDL3   PAT$GL_RST_BEGN, R3, R2				      ; 2908
		    23   A2	       01  90 00587 	    MOVB    #1, 35(R2)						      ;
				  35   A2  D5 0058B 8$:     TSTL    53(R2)						      ; 2910
				       13  13 0058E 	    BEQL    9$							      ;
				       06  DD 00590 	    PUSHL   #6							      ; 2913
				  35   A2  DD 00592 	    PUSHL   53(R2)						      ;
				  2A   A2  9F 00595 	    PUSHAB  42(R2)						      ;
		         6A	       03  FB 00598 	    CALLS   #3, PAT$VS_INIT					      ;
	   52	         53	       6B  C1 0059B 	    ADDL3   PAT$GL_RST_BEGN, R3, R2				      ; 2921
		    2A   A2	       01  90 0059F 	    MOVB    #1, 42(R2)						      ;
	      00000000'  EF	       53  D0 005A3 9$:     MOVL    R3, CURRENT_MODULE					      ; 2929

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 8-6
; Digital Equipment Corporation
;
		         50	       01  D0 005AA 	    MOVL    #1, R0						      ; 2935
					   04 005AD 	    RET     							      ;
				       50  D4 005AE 10$:    CLRL    R0							      ; 2697
					   04 005B0 	    RET     							      ;

; Routine Size:  258 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 9
; Digital Equipment Corporation
;
;	2937	ROUTINE ADD_NT( DST_RECRD, UP_SCOPE ) =
;	2938	
;	2939	!++
;	2940	! Functional Description:
;	2941	!
;	2942	!	Add a symbol to the name table (NT).
;	2943	!
;	2944	! Formal Parameters:
;	2945	!	DST_RECRD	-a pointer to the DST record that corresponds
;	2946	!			 to the symbol being added.
;	2947	!	UP_SCOPE	-an RST-pointer to the NT or MC record that
;	2948	!			 corresponds to the symbol that is scope-wise
;	2949	!			 above the symbol we are to add.
;	2950	!
;	2951	! Implicit Inputs:
;	2952	!
;	2953	!	The OWN, CURRENT_MODULE, has been set up to
;	2954	!	indicate the MC pointer to the module we are
;	2955	!	currently adding.
;	2956	!
;	2957	!	We call PAT$DST_VALUE with a DST_RECRD pointer - NOT a
;	2958	!	so-called DST_REC_ID.  This works, for now, because these
;	2959	!	two concepts are still the same.  If/when this is no longer
;	2960	!	true, we must change it and all calls to it so that only one
;	2961	!	way of specifying a DST record is used.
;	2962	!
;	2963	! Implicit Outputs:
;	2964	!
;	2965	!	None.
;	2966	!
;	2967	! Routine Value:
;	2968	!
;	2969	!	FALSE, if some real error occurs,
;	2970	!	an NT_PTR to where we did add or find it, otherwise.
;	2971	!
;	2972	! Side Effects:
;	2973	!
;	2974	!	The NT gets updated to reflect the addition of the new
;	2975	!	symbol if 1) PAT$DST_VALUE knows how to evaluate the
;	2976	!	given DST, and 2) We have not already built an NT
;	2977	!	record for this symbol (because it also came in as a GSD).
;	2978	!--
;	2979	
;	2980	BEGIN
;	2981	
;	2982	LABEL
;	2983		NEXT_DUP_LOOP;
;	2984	
;	2985	MAP
;	2986		UP_SCOPE : REF MC_RECORD,				! This is an example of a case where we would be
;	2987									! in trouble if pointers into the MC were not the
;	2988									! same as those into the NT because here we
;	2989									! don't yet know to which structure UP_SCOPE points.
;	2990		DST_RECRD : REF DST_RECORD;				! Pointer to the given DST record
;	2991									! which we use only for 'standard' DST

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 9-1
; Digital Equipment Corporation
;
;	2992									! structures.
;	2993	
;	2994	LOCAL
;	2995		LOOKUP_STATUS,						! SUCCESS CODE FROM PAT$DST_VALUE
;	2996		NT_HASH : REF NT_RECORD,				! Hash index used to access NT chains.
;	2997		NEW_NT_PTR : REF NT_RECORD,				! Pointer to NT record where the new
;	2998									! symbol gets inserted.
;	2999		NT_PTR : REF NT_RECORD,					! NT pointer used to scan along chains.
;	3000		DST_NAME_CS : CS_POINTER,				! Pointer to where the symbol name CS
;	3001									! is in the DST record.
;	3002		SYMBL_VALUE;						! The value of the symbol we are to add.
;	3003	
;	3004	!++
;	3005	! There is no point in adding an NT record for a symbol
;	3006	! we can't evaluate.
;	3007	!--
;	3008	IF ((LOOKUP_STATUS =  PAT$DST_VALUE( .DST_RECRD, SYMBL_VALUE)) EQL 0)	! ++038
;	3009	THEN
;	3010		BEGIN
;	3011		RETURN(FALSE);
;	3012		END;
;	3013	
;	3014	!++
;	3015	! The only difference in building an NT record from either of the three classes
;	3016	! of DST records we distinguish, (type zero, SRM types, and 'the rest'),
;	3017	! is the calculation of where in the record the name counted string is found.
;	3018	!
;	3019	! This code relies on the fact that the TYPE fields are in the same place in
;	3020	! the three types of DST records.
;	3021	!--
;	3022	DST_NAME_CS = DST_RECRD [DSTR_NAME];
;	3023	
;	3024	!++
;	3025	! Add the symbol to the name table.  Now we simply determine whether to add it
;	3026	! onto the end of an existing hash chain, or whether to begin a new one.
;	3027	!--
;	3028	NT_HASH = PAT$NT_HASH_FCN( .DST_NAME_CS );
;	3029	IF ((NT_PTR = .PAT$GL_NT_HASH [.NT_HASH]) NEQ 0)
;	3030	THEN
;	3031		BEGIN
;	3032		!++
;	3033		! There are already some symbols that hash to this same value.  This
;	3034		! means that we simply link the new  record onto the end of this chain.
;	3035		!--	
;	3036		WHILE( .NT_PTR [NT_FORWARD] NEQ 0 )
;	3037		DO
;	3038			!++
;	3039			! Skip along to the end of the chain.
;	3040			!--	
;	3041			NT_PTR = .NT_PTR [NT_FORWARD];
;	3042		END
;	3043	ELSE
;	3044		BEGIN
;	3045		!++
;	3046		! To build a new chain, we only need to know where in the hash vector

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 9-2
; Digital Equipment Corporation
;
;	3047		! to link it on. Make this hash-vector address look like a pointer
;	3048		! to an NT record so that we can fill in NT_FORWARD below thereby filling
;	3049		! in the hash vector.
;	3050		!--
;	3051		NT_PTR = PAT$GL_NT_HASH [.NT_HASH] - .PAT$GL_RST_BEGN;
;	3052		END;
;	3053	
;	3054	!++
;	3055	! Allocate space for the new NT record and fill in the fixed fields.  This must
;	3056	! go without hitch or we give up.  Note that the NT record we build is the same
;	3057	! no matter what type of DST record we build it from.
;	3058	!--
;	3059	IF ((NEW_NT_PTR = PAT$VS_GET( CURRENT_MODULE [MC_NT_STORAGE], RST_NT_OVERHEAD + .DST_NAME_CS[0]))
;	3060	   EQL 0 )
;	3061	THEN
;	3062		!++
;	3063		! We ran out of space.  This should never happen because we supposedly
;	3064		! knew how much vector storage to allocate before we began adding any NTs.
;	3065		!--
;	3066		RETURN(FALSE);
;	3067	
;	3068	NEW_NT_PTR [NT_UP_SCOPE] = .UP_SCOPE;
;	3069	NEW_NT_PTR [NT_DST_PTR] = .DST_RECRD;
;	3070	NEW_NT_PTR [NT_TYPE] = .DST_RECRD [DSTR_TYPE];
;	3071	
;	3072	!++
;	3073	! Moving the name could cause problems if we change the data representation.
;	3074	!  Note that here we move both the name-size count as well as the name itself.
;	3075	!--
;	3076	CH$MOVE( .DST_NAME_CS[0] +1, .DST_NAME_CS, NEW_NT_PTR [NT_NAME_CS] );
;	3077	
;	3078	!++
;	3079	! Add this new NT record to the name table by connecting up the hash-chain links.
;	3080	!  The new record points back to a previous NT record, OR, it points
;	3081	! back to the hash vector itself.  In either case there  is no NT record FORWARD
;	3082	! of the new record.
;	3083	!--
;	3084	NEW_NT_PTR [NT_BACKWARD] = .NT_PTR;
;	3085	NEW_NT_PTR [NT_FORWARD] = 0;
;	3086	
;	3087	!++
;	3088	! The following writes into the NT_FORWARD field of a previous NT record, OR,
;	3089	! it writes the first chain-pointer into the hash chain itself.  This
;	3090	! is why NT_FORWARD has to be the first field of the NT_FIELD_SET.
;	3091	!--
;	3092	NT_PTR [NT_FORWARD] = .NEW_NT_PTR;
;	3093	
;	3094	!++
;	3095	! All went ok so we return an RST-pointer to where this symbol got added.
;	3096	!--
;	3097	RETURN(.NEW_NT_PTR);
;	3098	END;




; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 9-3
; Digital Equipment Corporation
;


					 09FC 005B1 ADD_NT: .WORD   Save R2,R3,R4,R5,R6,R7,R8,R11			      ; 2937
		         5B 00000000G  EF  9E 005B3 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
		         5E	       04  C2 005BA 	    SUBL2   #4, SP						      ;
				       5E  DD 005BD 	    PUSHL   SP							      ; 3008
		         52	  04   AC  D0 005BF 	    MOVL    DST_RECRD, R2					      ;
				       52  DD 005C3 	    PUSHL   R2							      ;
	      00000000G  EF	       02  FB 005C5 	    CALLS   #2, PAT$DST_VALUE					      ;
				       50  D5 005CC 	    TSTL    LOOKUP_STATUS					      ;
				       79  13 005CE 	    BEQL    4$							      ;
	   53	         52	       07  C1 005D0 	    ADDL3   #7, R2, DST_NAME_CS					      ; 3022
				       53  DD 005D4 	    PUSHL   DST_NAME_CS						      ; 3028
	      00000000G  EF	       01  FB 005D6 	    CALLS   #1, PAT$NT_HASH_FCN					      ;
		         51	       6B  D0 005DD 	    MOVL    PAT$GL_RST_BEGN, R1					      ; 3036
		         50 00000000GFF40  3E 005E0 	    MOVAW   @PAT$GL_NT_HASH[NT_HASH], R0			      ; 3029
		         57	       60  3C 005E8 	    MOVZWL  (R0), NT_PTR					      ;
				       0F  13 005EB 	    BEQL    2$							      ;
				     6147  9F 005ED 1$:     PUSHAB  (R1)[NT_PTR]					      ; 3036
				       9E  B5 005F0 	    TSTW    @(SP)+						      ;
				       0C  13 005F2 	    BEQL    3$							      ;
				     6147  9F 005F4 	    PUSHAB  (R1)[NT_PTR]					      ; 3041
		         57	       9E  3C 005F7 	    MOVZWL  @(SP)+, NT_PTR					      ;
				       F1  11 005FA 	    BRB     1$							      ; 3036
	   57	         50	       51  C3 005FC 2$:     SUBL3   R1, R0, NT_PTR					      ; 3051
		         7E	       63  9A 00600 3$:     MOVZBL  (DST_NAME_CS), -(SP)				      ; 3059
		         6E	       0D  C0 00603 	    ADDL2   #13, (SP)						      ;
	   50 00000000'  EF	       51  C1 00606 	    ADDL3   R1, CURRENT_MODULE, R0				      ;
				  1C   A0  9F 0060E 	    PUSHAB  28(R0)						      ;
	      00000000G  EF	       02  FB 00611 	    CALLS   #2, PAT$VS_GET					      ;
		         58	       50  D0 00618 	    MOVL    R0, NEW_NT_PTR					      ;
				       2C  13 0061B 	    BEQL    4$							      ;
	   56	         58	       6B  C1 0061D 	    ADDL3   PAT$GL_RST_BEGN, NEW_NT_PTR, R6			      ; 3068
		    08   A6	  08   AC  B0 00621 	    MOVW    UP_SCOPE, 8(R6)					      ;
		    04   A6	       52  D0 00626 	    MOVL    R2, 4(R6)						      ; 3069
		    02   A6	  01   A2  90 0062A 	    MOVB    1(R2), 2(R6)					      ; 3070
		         50	       63  9A 0062F 	    MOVZBL  (DST_NAME_CS), R0					      ; 3076
				       50  D6 00632 	    INCL    R0							      ;
      0C   A6	         63	       50  28 00634 	    MOVC3   R0, (DST_NAME_CS), 12(R6)				      ;
		    0A   A6	       57  B0 00639 	    MOVW    NT_PTR, 10(R6)					      ; 3084
				       66  B4 0063D 	    CLRW    (R6)						      ; 3085
		         57	       6B  C0 0063F 	    ADDL2   PAT$GL_RST_BEGN, R7					      ; 3092
		         67	       58  B0 00642 	    MOVW    NEW_NT_PTR, (R7)					      ;
		         50	       58  D0 00645 	    MOVL    NEW_NT_PTR, R0					      ; 3097
					   04 00648 	    RET     							      ;
				       50  D4 00649 4$:     CLRL    R0							      ; 2937
					   04 0064B 	    RET     							      ;

; Routine Size:  155 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 10
; Digital Equipment Corporation
;
;	3099	ROUTINE ADD_SAT( NT_PTR, LOWER, UPPER ) =
;	3100	
;	3101	!++
;	3102	! Functional Description:
;	3103	!
;	3104	!	Build the SAT record to correspond to an NT record.
;	3105	!
;	3106	! Formal Parameters:
;	3107	!	NT_PTR		-An RST-pointer to the NT record for this symbol.
;	3108	!	LOWER		-The lower-bound value which is bound to 
;	3109	!			 this symbol.
;	3110	!	UPPER		-The upper-bound value which is bound to 
;	3111	!			 this symbol.
;	3112	!
;	3113	! Implicit Inputs:
;	3114	!
;	3115	!	Symbols marked NT_IS_GLOBAL have already been added
;	3116	!	to the SAT so we don't do it again.  We do update
;	3117	!	SAT information therein, though, once we have found
;	3118	!	out where we added it the last time.
;	3119	!
;	3120	!	The OWN, CURRENT_MODULE, has been set up to
;	3121	!	indicate the MC pointer to the module we are
;	3122	!	currently adding.  Storage allocation works
;	3123	!	from the vector storage descriptors stored therein.
;	3124	!
;	3125	! Implicit Outputs:
;	3126	!
;	3127	!	None.
;	3128	!
;	3129	! Routine Value:
;	3130	!
;	3131	!	0, if the SAT record was not built,
;	3132	!	a SAT-pointer to where it was build, otherwise.
;	3133	!
;	3134	! Side Effects:
;	3135	!
;	3136	!	The SAT gets updated to reflect the addition of the new
;	3137	!	symbol.
;	3138	!
;	3139	!	The NT bit, NT_IS_BOUNDED is set to TRUE or FALSE,
;	3140	!	depending on whether the given UPPER_BOUND is 0 or not.
;	3141	!--
;	3142	
;	3143	BEGIN
;	3144	
;	3145	MAP
;	3146		NT_PTR : REF NT_RECORD;
;	3147	
;	3148	LOCAL
;	3149		SAT_PTR : REF SAT_RECORD;
;	3150	
;	3151	SAT_PTR = 0;
;	3152	
;	3153	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 10-1
; Digital Equipment Corporation
;
;	3154	! Ask for space for the fixed-size record. This should not fail because
;	3155	! we supposedly knew how much space we wanted and allocated it all
;	3156	! before we got here.
;	3157	!--
;	3158	IF ((SAT_PTR = PAT$VS_GET(CURRENT_MODULE [MC_SAT_STORAGE], RST_SAT_SIZE)) EQL 0)
;	3159	THEN
;	3160		BEGIN
;	3161		$FAO_TT_OUT('!/sat overflow');				! Don't allow the SAT to overflow.
;	3162		RETURN(FALSE);
;	3163		END;
;	3164	
;	3165	!++
;	3166	! Otherwise go ahead and fill in the new record or update the old one.
;	3167	!--
;	3168	SAT_PTR [SAT_LB] = .LOWER;
;	3169	SAT_PTR [SAT_UB] = .UPPER;
;	3170	SAT_PTR [SAT_NT_PTR] = .NT_PTR;
;	3171	
;	3172	!++
;	3173	! Mark all NTs _BOUNDED or not depending on whether the (new) upper bound is 0
;	3174	! or not.
;	3175	!--
;	3176	IF (.UPPER NEQ 0)
;	3177	THEN
;	3178		NT_PTR [NT_IS_BOUNDED] = TRUE;
;	3179	
;	3180	!++
;	3181	! Return a pointer to where the SAT record was built.  Usually this is only
;	3182	! tested for non-zero, PAT$ADD_MODULE keeps a stack of SAT record pointers
;	3183	! for ROUTINEs, though, so it can go back and put in the UB value since we
;	3184	! don't get that until end-of-routine.
;	3185	!--
;	3186	RETURN(.SAT_PTR);
;	3187	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      0015C P.AAL:  .BYTE   14							      ;
					      0015D 	    .ASCII  \!/sat overflow\					      ;
					      0016B	    .BLKB   1



							    .PSECT  _PAT$CODE,NOWRT,2

					 0804 0064C ADD_SAT:.WORD   Save R2,R11						      ; 3099
		         5B 00000000G  EF  9E 0064E 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
				       52  D4 00655 	    CLRL    SAT_PTR						      ; 3151
				       0A  DD 00657 	    PUSHL   #10							      ; 3158
	   50 00000000'  EF	       6B  C1 00659 	    ADDL3   PAT$GL_RST_BEGN, CURRENT_MODULE, R0			      ;
				  23   A0  9F 00661 	    PUSHAB  35(R0)						      ;
	      00000000G  EF	       02  FB 00664 	    CALLS   #2, PAT$VS_GET					      ;
		         52	       50  D0 0066B 	    MOVL    R0, SAT_PTR						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 10-2
; Digital Equipment Corporation
;
				       11  12 0066E 	    BNEQ    1$							      ;
				       7E  D4 00670 	    CLRL    -(SP)						      ; 3161
			    00000000'  EF  9F 00672 	    PUSHAB  P.AAL						      ;
	      00000000G  EF	       02  FB 00678 	    CALLS   #2, PAT$FAO_OUT					      ;
				       1C  11 0067F 	    BRB     3$							      ; 3162
		    02   A2	  08   AC  7D 00681 1$:     MOVQ    LOWER, 2(SAT_PTR)					      ; 3168
		         62	  04   AC  B0 00686 	    MOVW    NT_PTR, (SAT_PTR)					      ; 3170
				  0C   AC  D5 0068A 	    TSTL    UPPER						      ; 3176
				       0A  13 0068D 	    BEQL    2$							      ;
	   50	    04   AC	       6B  C1 0068F 	    ADDL3   PAT$GL_RST_BEGN, NT_PTR, R0				      ; 3178
		    03   A0	  80   8F  88 00694 	    BISB2   #128, 3(R0)						      ;
		         50	       52  D0 00699 2$:     MOVL    SAT_PTR, R0						      ; 3186
					   04 0069C 	    RET     							      ;
				       50  D4 0069D 3$:     CLRL    R0							      ; 3099
					   04 0069F 	    RET     							      ;

; Routine Size:  84 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 11
; Digital Equipment Corporation
;
;	3188	ROUTINE ADD_LVT( NT_PTR, LVT_VAL ) =
;	3189	
;	3190	!++
;	3191	! Functional Description:
;	3192	!
;	3193	!	Build the LVT record to correspond to the 
;	3194	!	symbol we have just built the indicated NT
;	3195	!	record for.
;	3196	!
;	3197	! Formal Parameters:
;	3198	!
;	3199	!	NT_PTR		-An RST-pointer to the NT record for this symbol.
;	3200	!	LVT_VAL		-The literal value which is bound to 
;	3201	!			 this symbol.
;	3202	!
;	3203	! Implicit Inputs:
;	3204	!
;	3205	!	The OWN, CURRENT_MODULE, has been set up to
;	3206	!	indicate the MC pointer to the module we are
;	3207	!	currently adding.  Storage allocation works
;	3208	!	from the vector storage descriptors stored therein.
;	3209	!
;	3210	! Implicit Outputs:
;	3211	!
;	3212	!	None.
;	3213	!
;	3214	! Routine Value:
;	3215	!
;	3216	!	TRUE, if all goes OK,
;	3217	!	FALSE, otherwise.
;	3218	!
;	3219	! Side Effects:
;	3220	!
;	3221	!	The LVT gets updated to reflect the addition of the new
;	3222	!	symbol.
;	3223	!--
;	3224	
;	3225	BEGIN
;	3226	
;	3227	MAP
;	3228		NT_PTR : REF NT_RECORD;
;	3229	
;	3230	LOCAL
;	3231		LVT_PTR : REF LVT_RECORD;
;	3232	
;	3233	!++
;	3234	! Ask for space for the fixed-size record. This should not fail because we
;	3235	! supposedly knew how much space we wanted and allocated it all before
;	3236	! we got here.
;	3237	!--
;	3238	IF ((LVT_PTR =	PAT$VS_GET(CURRENT_MODULE[MC_LVT_STORAGE], RST_LVT_SIZE))
;	3239	   EQL 0 )
;	3240	THEN
;	3241		BEGIN
;	3242		$FAO_TT_OUT('!/lvt overflow');				! Don't allow the LVT to overflow.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 11-1
; Digital Equipment Corporation
;
;	3243		RETURN(FALSE);
;	3244		END;
;	3245	
;	3246	!++
;	3247	! Otherwise go ahead and fill in the new record.
;	3248	!--
;	3249	LVT_PTR [LVT_VALUE] = .LVT_VAL;
;	3250	LVT_PTR [LVT_NT_PTR] = .NT_PTR;
;	3251	
;	3252	RETURN(TRUE);
;	3253	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      0016C P.AAM:  .BYTE   14							      ;
					      0016D 	    .ASCII  \!/lvt overflow\					      ;
					      0017B	    .BLKB   1



							    .PSECT  _PAT$CODE,NOWRT,2

					 0004 006A0 ADD_LVT:.WORD   Save R2						      ; 3188
				       06  DD 006A2 	    PUSHL   #6							      ; 3238
	   50 00000000'  EF 00000000G  EF  C1 006A4 	    ADDL3   PAT$GL_RST_BEGN, CURRENT_MODULE, R0			      ;
				  2A   A0  9F 006B0 	    PUSHAB  42(R0)						      ;
	      00000000G  EF	       02  FB 006B3 	    CALLS   #2, PAT$VS_GET					      ;
		         52	       50  D0 006BA 	    MOVL    R0, LVT_PTR						      ;
				       11  12 006BD 	    BNEQ    1$							      ;
				       7E  D4 006BF 	    CLRL    -(SP)						      ; 3242
			    00000000'  EF  9F 006C1 	    PUSHAB  P.AAM						      ;
	      00000000G  EF	       02  FB 006C7 	    CALLS   #2, PAT$FAO_OUT					      ;
				       0D  11 006CE 	    BRB     2$							      ; 3243
		    02   A2	  08   AC  D0 006D0 1$:     MOVL    LVT_VAL, 2(LVT_PTR)					      ; 3249
		         62	  04   AC  B0 006D5 	    MOVW    NT_PTR, (LVT_PTR)					      ; 3250
		         50	       01  D0 006D9 	    MOVL    #1, R0						      ; 3252
					   04 006DC 	    RET     							      ;
				       50  D4 006DD 2$:     CLRL    R0							      ; 3188
					   04 006DF 	    RET     							      ;

; Routine Size:  64 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 12
; Digital Equipment Corporation
;
;	3254	GLOBAL ROUTINE PAT$GET_BOUNDS( DESCRIP_BLOCK, BOUNDS_DESC ) : NOVALUE =
;	3255	
;	3256	!++
;	3257	! Functional Description:
;	3258	!
;	3259	!	Deduce the virtual address of the beginning, and the length (in bytes),
;	3260	!	of the indicated array.  i.e. Given the SRM-defined 'array descriptor',
;	3261	!	produce the corresponding PATCH/RST-defined 'array bounds descriptor'.
;	3262	!	The latter is defined in PATRST.REQ
;	3263	!
;	3264	! Formal Parameters:
;	3265	!
;	3266	!	DESCRIP_BLOCK	-address of SRM array descriptor
;	3267	!	BOUNDS_DESC	-address of the ARRAY_BNDS_DESC we are
;	3268	!			 to 'fill in'.
;	3269	!
;	3270	! Implicit Inputs:
;	3271	!
;	3272	!	The SRM-defined notion of 'array descriptor'.
;	3273	!
;	3274	! Implicit Outputs:
;	3275	!
;	3276	!	None.
;	3277	!
;	3278	! Routine Value:
;	3279	!
;	3280	!	NOVALUE
;	3281	!
;	3282	! Side Effects:
;	3283	!
;	3284	!	BOUNDS_DESC is an output parameter.  (see above)
;	3285	!--
;	3286	
;	3287	BEGIN
;	3288	
;	3289	MAP
;	3290		DESCRIP_BLOCK : REF BLOCK [,BYTE],
;	3291		BOUNDS_DESC : REF ARRAY_BNDS_DESC;
;	3292	
;	3293	LOCAL
;	3294		SPAN_BLOCK : REF VECTOR,
;	3295		NUM_ARRAY_ELEMS;
;	3296	
;	3297	!++
;	3298	! Check that this is a valid array descriptor.  PATCH handles FORTRAN'S
;	3299	! _CLASS_A (general array) and _CLASS_S (type CHARACTER).
;	3300	!--
;	3301	IF (.DESCRIP_BLOCK [DSC$B_CLASS] EQL DSC$K_CLASS_A)
;	3302	THEN
;	3303		BEGIN
;	3304		!++
;	3305		! General array descriptors.  Check consistency and return if
;	3306		! something is wrong.
;	3307		!--
;	3308		IF ((NOT .DESCRIP_BLOCK [DSC$V_FL_COLUMN]) OR

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 12-1
; Digital Equipment Corporation
;
;	3309		    (NOT .DESCRIP_BLOCK [DSC$V_FL_COEFF]) OR
;	3310		    (NOT .DESCRIP_BLOCK [DSC$V_FL_BOUNDS]) OR
;	3311		    (.DESCRIP_BLOCK [DSC$B_DIMCT] LEQ 0))
;	3312		THEN
;	3313			BEGIN
;	3314			SIGNAL( PAT$_INVARRDSC );
;	3315			RETURN;
;	3316			END;
;	3317	
;	3318		!++
;	3319		! Calculate the required values for general arrays.  The length of the
;	3320		! array is simply tallied up by multiplying the total number of elements
;	3321		! by each element size.  The total number of elements is the product of
;	3322		! the number of elements in each dimension.
;	3323		!--
;	3324		SPAN_BLOCK = DESCRIP_BLOCK [DSC$L_M1];
;	3325		NUM_ARRAY_ELEMS = .SPAN_BLOCK[0];
;	3326		INCR COUNT FROM 1 TO (.DESCRIP_BLOCK [DSC$B_DIMCT] -1 )
;	3327		DO
;	3328			NUM_ARRAY_ELEMS = .NUM_ARRAY_ELEMS * .SPAN_BLOCK[.COUNT];
;	3329	
;	3330		!++
;	3331		! Calculate the length of the array, in bytes, and return this information.
;	3332		!--
;	3333		BOUNDS_DESC [ARRAY_LENGTH] = .NUM_ARRAY_ELEMS * .DESCRIP_BLOCK [DSC$W_LENGTH];
;	3334	
;	3335		!++
;	3336		! End of special processing for _CLASS_A.
;	3337		!--
;	3338		END
;	3339	ELSE
;	3340		IF (.DESCRIP_BLOCK[DSC$B_CLASS] EQL DSC$K_CLASS_S)
;	3341		THEN
;	3342			BEGIN
;	3343			!++
;	3344			! Class S is for static strings.  Return the needed information.
;	3345			!--
;	3346			BOUNDS_DESC[ARRAY_LENGTH] = .DESCRIP_BLOCK[DSC$W_LENGTH];
;	3347			END
;	3348		ELSE
;	3349			BEGIN
;	3350			!++
;	3351			! No other classes currently supported.
;	3352			!--
;	3353			SIGNAL(PAT$_INVARRDSC);
;	3354			RETURN;
;	3355			END;
;	3356	
;	3357	!++
;	3358	! Return the required information common to all types.  Currently, this is
;	3359	! only the address where the data begins.
;	3360	!--
;	3361	BOUNDS_DESC [ARRAY_ADDRESS] = .DESCRIP_BLOCK [DSC$A_POINTER];
;	3362	
;	3363	END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 12-2
; Digital Equipment Corporation
;





					 001C 006E0 	    .ENTRY  PAT$GET_BOUNDS, Save R2,R3,R4			      ; 3254
		         52	  04   AC  D0 006E2 	    MOVL    DESCRIP_BLOCK, R2					      ; 3301
		         04	  03   A2  91 006E6 	    CMPB    3(R2), #4						      ;
				       39  12 006EA 	    BNEQ    3$							      ;
	   44	    0A   A2	       05  E1 006EC 	    BBC     #5, 10(R2), 4$					      ; 3308
	   3F	    0A   A2	       06  E1 006F1 	    BBC     #6, 10(R2), 4$					      ; 3309
	   3A	    0A   A2	       07  E1 006F6 	    BBC     #7, 10(R2), 4$					      ; 3310
				  0B   A2  95 006FB 	    TSTB    11(R2)						      ; 3311
				       35  1B 006FE 	    BLEQU   4$							      ;
	   51	         52	       14  C1 00700 	    ADDL3   #20, R2, SPAN_BLOCK					      ; 3324
		         53	       61  D0 00704 	    MOVL    (SPAN_BLOCK), NUM_ARRAY_ELEMS			      ; 3325
		         54	  0B   A2  9A 00707 	    MOVZBL  11(R2), R4						      ; 3326
				       50  D4 0070B 	    CLRL    COUNT						      ;
				       04  11 0070D 	    BRB     2$							      ;
		         53	     6140  C4 0070F 1$:     MULL2   (SPAN_BLOCK)[COUNT], NUM_ARRAY_ELEMS		      ; 3328
	   F8	         50	       54  F2 00713 2$:     AOBLSS  R4, COUNT, 1$					      ; 3326
		         50	  08   AC  D0 00717 	    MOVL    BOUNDS_DESC, R0					      ; 3333
		         51	       62  3C 0071B 	    MOVZWL  (R2), R1						      ;
      04   A0	         53	       51  C5 0071E 	    MULL3   R1, NUM_ARRAY_ELEMS, 4(R0)				      ;
				       1E  11 00723 	    BRB     5$							      ; 3301
		         01	  03   A2  91 00725 3$:     CMPB    3(R2), #1						      ; 3340
				       0A  12 00729 	    BNEQ    4$							      ;
		         50	  08   AC  D0 0072B 	    MOVL    BOUNDS_DESC, R0					      ; 3346
		    04   A0	       62  3C 0072F 	    MOVZWL  (R2), 4(R0)						      ;
				       0E  11 00733 	    BRB     5$							      ; 3340
			    006D80B2   8F  DD 00735 4$:     PUSHL   #7176370						      ; 3353
	      00000000G  00	       01  FB 0073B 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 00742 	    RET     							      ; 3354
		    08   BC	  04   A2  D0 00743 5$:     MOVL    4(R2), @BOUNDS_DESC					      ; 3361
					   04 00748 	    RET     							      ; 3254

; Routine Size:  105 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:31:12	DBB3:[PATCH.SRC]PATBLD.B32;10					Page 13
; Digital Equipment Corporation
;
;	3364	END				!End of module
;	3365	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$OWN       	    16    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$CODE      	  1865  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	   380  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        25         0       227





; Size:		1865 code + 396 data bytes
; Run Time:	01:05.9
; Elapsed Time:	02:09.7
; Memory Used:	443 pages
; Compilation Complete
