
; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATEXA (
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.19') =
;	0007	BEGIN
;	0008	
;	0009	! Copyright (C) 1976,1977
;	0010	! Digital Equipment Corporation, Maynard, Massachusetts 01754
;	0011	!
;	0012	! This software is furnished under a license for use only on a
;	0013	! single computer system and may be copied only with the inclusion
;	0014	! of the above copyright notice. This software, or any
;	0015	! other copies thereof, may not be provided or otherwise made
;	0016	! available to any other person except for use on such system
;	0017	! and to one who agrees to these license terms. Title to and
;	0018	! ownership of the software shall at all times remain in DEC.
;	0019	!
;	0020	! The information in this software is subject to change without
;	0021	! notice and should not be construed as a commitment by Digital
;	0022	! Equipment Corporation.
;	0023	!
;	0024	! DEC assumes no responsibility for the use or reliability of
;	0025	! its software on equipment which is not supplied by DEC.
;	0026	!
;	0027	! FACILITY:	PATCH
;	0028	!
;	0029	!++
;	0030	! FUNCTIONAL DESCRIPTION:
;	0031	!
;	0032	!	EXAMINE, DEPOSIT, AND DELETE ROUTINES FOR STARLET PATCH FACILITY
;	0033	!
;	0034	! Version:	X01.19
;	0035	!
;	0036	! History:
;	0037	!	Author:
;	0038	!		Carol Peters, 21 Jul 1976: Version 01
;	0039	!
;	0040	!	Modified by:
;	0041	!		Kathleen Morse, 19 Oct 1977: Version X01.00
;	0042	!
;	0043	! Revision history:
;	0044	!  NO	DATE		PROGRAMMER		PURPOSE
;	0045	!  --	----		----------		-------
;	0046	!
;	0047	!  00	19-OCT-77	K.D. MORSE		ADAPT VERSION 49 FOR PATCH
;	0048	!  01	01-DEC-77	K.D. MORSE		ADD DELETE ROUTINE.
;	0049	!  02	27-DEC-77	K.D. MORSE		CHANGE PAT$OUT_VALUE CALLS. (57)
;	0050	!						ADD PAT$SYM_DEPOS. (58)
;	0051	!  03	2-JAN-78	K.D. MORSE		ADD CHECK FOR NO SYMBOLS IN IMAGE.
;	0052	!  04	3-JAN-78	K.D. MORSE		ADD CHECK FOR NO PATCHAREA
;	0053	!						ALLOCATED BEFORE DEPOSIT /PAT.
;	0054	!  05	4-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 50-53.
;	0055	!  06	5-JAN-78	K.D. MORSE		CHANGE PAT$INS_DECODE CALLS. (54)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 1-1
; Digital Equipment Corporation
;
;	0056	!						NO CHANGES FOR VERS 55,56.
;	0057	!  07	24-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 59.
;	0058	!  08	27-JAN-78	K.D. MORSE		ADD CHECK FOR EXIT_TOKEN IN
;	0059	!						PAT$REPLACE_CMD TO RECOGNIZE
;	0060	!						END OF OLD LIST.
;	0061	!  09	28-JAN-78	K.D. MORSE		BUILD REPLACEMENT CODE INTO
;	0062	!						TEMPORARY BUFFER.
;	0063	!  10	01-MAR-78	K.D. MORSE		CHANGE ERRONEOUS PAT$_DECODE
;	0064	!						ERROR MSGS TO PAT$_ENCODE.
;	0065	!  11	24-MAR-78	K.D. MORSE		NONE FOR VERS 60-61.
;	0066	!  12	04-APR-78	K.D. MORSE		NONE FOR VERS 62.
;	0067	!  13	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0068	!  14	28-APR-78	K.D. MORSE		ADD ASSEMBLER DIRECTIVE FLAG
;	0069	!						TO PAT$OUT_MEM_LOC.
;	0070	!  15	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 63.
;	0071	!  16	26-MAY-78	K.D. MORSE		ADD CODE TO ALLOW FORWARD
;	0072	!						REFERENCING IN SYMBOLIC
;	0073	!						INSTRUCTION OPERANDS.
;	0074	!  17	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
;	0075	!  18	19-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 64.
;	0076	!  19	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 65-67.
;	0077	!						ADD CODE FOR EV/LITERAL AND
;	0078	!						ROUTINE DISPLAY_LVTS. (66)
;	0079	!						NO CHANGES FOR VERS 69-74.
;	0080	!
;	0081	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 2
; Digital Equipment Corporation
;
;	0082	FORWARD ROUTINE
;	0083		PAT$DEPOSIT_CMD : NOVALUE,				! Deposits a datum into an address
;	0084		PAT$EXAMINE_CMD : NOVALUE,				! Examines a location
;	0085		PAT$REPLACE_CMD : NOVALUE,				! Replaces an instruction
;	0086		RELOCAT_INS : NOVALUE,					! Relocates instructions to patch area
;	0087		PAT$SUBST_INS,						! Substitutes instructions in patch area
;	0088		PAT$OUT_MEM_LOC,					! Outputs the contents of a memory location
;	0089		DISPLAY_LVTS : NOVALUE,					! Search LVT and display pathnames
;	0090		PAT$REG_MATCH,						! Matches a string to a register name
;	0091		PAT$FILL_BUF : NOVALUE;					! Writes data into temporary buffers
;	0092	
;	0093	LIBRARY 'SYS$LIBRARY:LIB.L32';					! System definitions
;	0094	REQUIRE 'SRC$:VXSMAC.REQ';
;	0134	REQUIRE 'SRC$:BSTRUC.REQ';
;	0185	REQUIRE 'SRC$:LISTEL.REQ';
;	0204	REQUIRE 'SRC$:PATPCT.REQ';
;	0220	REQUIRE 'SRC$:PATGEN.REQ';
;	0399	REQUIRE 'LIB$:PATMSG.REQ';
;	0557	REQUIRE 'SRC$:SYSLIT.REQ';
;	0592	REQUIRE 'SRC$:PATRST.REQ';
;	1650	REQUIRE 'SRC$:SYSSER.REQ';
;      R1658	SWITCHES LIST (SOURCE);
;      R1659	
;      R1660	EXTERNAL ROUTINE
;      R1661		PAT$fao_out;		! formats a line and outputs to the terminal
;      R1662	
;      R1663	SWITCHES LIST (NOSOURCE);
;	1708	REQUIRE 'SRC$:PATTER.REQ';
;	1788	REQUIRE 'SRC$:PREFIX.REQ';
;	1971	REQUIRE 'SRC$:PATPRE.REQ';
;	2111	
;	2112	EXTERNAL
;	2113		PAT$GB_SYMBOLS,						! Indicator if image had symbols
;	2114		PAT$GL_OLD_ASD,						! Descriptor for old contents assembler directive table
;	2115		PAT$GL_NEW_ASD,						! Descriptor for new contents assembler directive table
;	2116		PAT$GL_TEMP_BUF : BLOCK[,BYTE],				! Descriptor for temporary buffer for deposit values
;	2117		PAT$GL_RLOC_BUF : BLOCK[,BYTE],				! Descriptor for relocated instruction stream
;	2118		PAT$GB_SUBST_IN : VECTOR[,BYTE],			! Buffer for substitution instruction streams
;	2119		PAT$GL_BR_DISPL,					! Branch displacement that does not fit
;	2120		PAT$GL_PATAREA : REF BLOCK[,BYTE],			! Pointer to patch area descriptor
;	2121		PAT$GL_IMGHDR : REF BLOCK[,BYTE],			! Pointer to image header
;	2122		PAT$GB_LOC_TYPE: BYTE,					! Type of end range argument
;	2123		PAT$GB_MOD_PTR: REF VECTOR [, BYTE],			! Pointer to mode level
;	2124		PAT$GL_IHPPTR : REF BLOCK[,BYTE],			! Pointer to image header patch area
;	2125		PAT$CP_OUT_STR : REF VECTOR[,BYTE],			! Points into current output buffer
;	2126		PAT$GL_CONTEXT: BITVECTOR,				! Context bits longword
;	2127		PAT$GL_BUF_SIZ,						! Holds count in output buffer
;	2128		PAT$GL_HEAD_LST,					! Head of linked list of expressions
;	2129		PAT$GL_LAST_LOC,					! Last location displayed
;	2130		PAT$GL_LAST_VAL,					! Last value displayed
;	2131		PAT$GL_NEXT_LOC,					! Next location to display
;	2132		PAT$GL_SYMTBPTR,					! Pointer to current symbol table
;	2133		PAT$GL_OLDLABLS,					! Listhead for old contents labels (from current command)
;	2134		PAT$GL_NEWLABLS,					! Listhead for new contents un-relocated labels (from current command)
;	2135		PAT$GL_RLCLABLS;					! List head for new contents relocated labels (from current command)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 2-1
; Digital Equipment Corporation
;
;	2136	
;	2137	EXTERNAL ROUTINE
;	2138		PAT$ADD_LABELS : NOVALUE,				! Adds labels to user-defined symbol table
;	2139		PAT$ADD_NT_T_PV : NOVALUE,				! Build pathname vectors from NT_PTRs
;	2140		PAT$EXP_AREA : NOVALUE,					! Expands patch area
;	2141		PAT$FAO_PUT : NOVALUE,					! Formats buffered output
;	2142		PAT$FREERELEASE,					! Deallocates free memory
;	2143		PAT$FREEZ,						! Allocates and zeroes free memory
;	2144		PAT$GET_NXT_LVT,					! Provide access to the LVT
;	2145		PAT$GET_VALUE : NOVALUE,				! Gets byte stream of values from image
;	2146		PAT$INS_DECODE,						! Routine to output memory as
;	2147									! symbolic instructions
;	2148		PAT$INS_ENCODE,						! Routine to encode a symbolic instruction
;	2149		PAT$MAP_ADDR : NOVALUE,					! Computes mapped addresses
;	2150		PAT$OUT_NUM_VAL,					! Outputs numeric values
;	2151		PAT$OUT_PUT : NOVALUE,					! Actually does the terminal I/O
;	2152		PAT$OUT_SYM_VAL,					! Outputs symbol name with value
;	2153		PAT$PRINT_PATH : NOVALUE,				! Print out pathnames
;	2154		PAT$RESOLVE_INS : NOVALUE,				! Resolves forward references in symbolic instruction operands
;	2155		PAT$SYMBOL_VALU,					! Finds the value bound to a symbol name
;	2156		PAT$UNMAP_ADDR : NOVALUE,				! Computes unmapped addresses
;	2157		PAT$VAL_TO_SYM,						! Translates a value to a symbol name
;	2158		PAT$WRITE_MEM;						! Routine to write to user's memory

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 3
; Digital Equipment Corporation
;
;	2159	!++
;	2160	!
;	2161	! REGISTER_TABLE holds one entry per register.  Each entry is made
;	2162	! up of one longword.  The first byte holds the character count of
;	2163	! the register name.  The second through fourth bytes hold the
;	2164	! register name string.  A sample entry follows:
;	2165	!
;	2166	!	+---------------------------------------------------------------+
;	2167	!	!		!	0       !	R       !	2       !
;	2168	!	+---------------------------------------------------------------+
;	2169	!
;	2170	!--
;	2171	
;	2172	MACRO
;	2173		REGISTER_ENTRY (STRING) =
;     M 2174			%CHARCOUNT (STRING), %ASCII STRING, REP 3 - %CHARCOUNT (STRING) OF BYTE (0)%;
;	2175	
;	2176	BIND
;	2177		REGISTER_TABLE = UPLIT BYTE (
;	2178			REGISTER_ENTRY ('R0'),
;	2179			REGISTER_ENTRY ('R1'),
;	2180			REGISTER_ENTRY ('R2'),
;	2181			REGISTER_ENTRY ('R3'),
;	2182			REGISTER_ENTRY ('R4'),
;	2183			REGISTER_ENTRY ('R5'),
;	2184			REGISTER_ENTRY ('R6'),
;	2185			REGISTER_ENTRY ('R7'),
;	2186			REGISTER_ENTRY ('R8'),
;	2187			REGISTER_ENTRY ('R9'),
;	2188			REGISTER_ENTRY ('R10'),
;	2189			REGISTER_ENTRY ('R11'),
;	2190			REGISTER_ENTRY ('AP'),
;	2191			REGISTER_ENTRY ('FP'),
;	2192			REGISTER_ENTRY ('SP'),
;	2193			REGISTER_ENTRY ('PC'),
;	2194			REGISTER_ENTRY ('PSL')):
;	2195	
;	2196		BLOCK [, LONG];
;	2197	
;	2198	!++
;	2199	! These field definitions control access to the register table.
;	2200	!--
;	2201	MACRO
;	2202		REG_NAME	=8, 24, 0%,
;	2203		CTD_REG_NAME	=0, 24, 0%,
;	2204		REG_CH_CNT	=0,  8, 0%;
;	2205	
;	2206	!++
;	2207	! Common ascii counted strings used in FAO calls.
;	2208	!--
;	2209	
;	2210	BIND
;	2211		CS_ASCII	= UPLIT ( %ASCIC '''!AD'''),
;	2212		COLON_TAB_STG	= UPLIT ( %ASCIC ':  '),
;	2213		CAR_CTL_STG	= UPLIT ( %ASCIC '!/'),

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 3-1
; Digital Equipment Corporation
;
;	2214		OLD_TAB_STG	= UPLIT ( %ASCIC 'old:	'),
;	2215		NEW_TAB_STG	= UPLIT ( %ASCIC 'new:	');

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4
; Digital Equipment Corporation
;
;	2216	SWITCHES NOOPTIMIZE;
;	2217	GLOBAL ROUTINE PAT$DEPOSIT_CMD : NOVALUE =
;	2218	
;	2219	!++
;	2220	! FUNCTIONAL DESCRIPTION:
;	2221	!
;	2222	!	This routine handles all delete and deposit commands, those for
;	2223	!	instructions and those for values.  The instruction(s)/value(s)
;	2224	!	specified in the delete command must be identical to those actually
;	2225	!	contained in the location(s), otherwise an error message is produced and
;	2226	!	the command ends prematurely.  For a deposit command, the instruction(s)
;	2227	!	/value(s) specified are written to consecutive locations.  The image is
;	2228	!	not modified in either case unless the entire command works.
;	2229	!
;	2230	!	The command argument list is made up of entries that are
;	2231	!	each three longwords long. The first is a forward link to the
;	2232	!	next entry. The second longword in the first entry in the list
;	2233	!	is the address into which some value(s) is (are) to be deleted or deposited.
;	2234	!	The third longword is unused. The second longword in the second
;	2235	!	and subsequent entries are the values to be deleted or deposited.
;	2236	!	The first value should be the contents of the specified location;
;	2237	!	the second, the contents of that location plus the current mode_length, etc.
;	2238	!
;	2239	!	For instructions, the increment is the length of each subsequent 
;	2240	!	instruction. The second longword contains the address of a counted byte
;	2241	!	stream that is to be translated into a binary instruction which is the
;	2242	!	old contents of that location.
;	2243	!
;	2244	! CALLING SEQUENCE:
;	2245	!
;	2246	!	PAT$DEPOSIT_CMD ()
;	2247	!
;	2248	! INPUTS:
;	2249	!
;	2250	!	none
;	2251	!
;	2252	! IMPLICIT INPUTS:
;	2253	!
;	2254	!	PAT$GL_HEAD_LST, the head of the linked PATCH command argument list.
;	2255	!	The current mode.
;	2256	!
;	2257	! OUTPUTS:
;	2258	!
;	2259	!	none
;	2260	!
;	2261	! IMPLICIT OUTPUTS:
;	2262	!
;	2263	!	The values PAT$GL_LAST_LOC, PAT$GL_LAST_VAL, and PAT$GL_NEXT_LOC
;	2264	!	are set after each deposit is done.
;	2265	!
;	2266	! ROUTINE VALUE:
;	2267	!
;	2268	!	novalue
;	2269	!
;	2270	! SIDE EFFECTS:

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-1
; Digital Equipment Corporation
;
;	2271	!
;	2272	!	The specified addresses have their values changed.
;	2273	!	If a failure in a write occurs, the routine SIGNALs an error.
;	2274	!
;	2275	!--
;	2276	
;	2277	BEGIN
;	2278	
;	2279	LITERAL
;	2280		NOP_INSTR	= 1,					! Fill char for instructions
;	2281		ZERO_BYTE	= 0,					! Fill char for data
;	2282		ONE_PAGE	= 1,					! Number of pages to expand patch area
;	2283		MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction
;	2284	
;	2285	LOCAL
;	2286		INSTRUC_BUF: VECTOR [MAX_INST_LEN, BYTE],
;	2287		FILL_CHAR: BYTE,					! Fill character for delete command
;	2288		OLD_CONTENTS:	VECTOR[TTY_OUT_WIDTH, BYTE],		! Buffer to hold old contents of location
;	2289		MAPPED_LOC,						! Mapped address of deposit destination
;	2290		UNMAPPED_LOC,						! Unmapped address of deposit destination
;	2291		ISE_ADDR,						! Image section entry for deposit destination
;	2292		DEP_SRC_ADR,						! Pointer to deposit source
;	2293		DEP_SIZ,						! Size of deposit to be made
;	2294		POINTER;
;	2295	
;	2296	!++
;	2297	! Check that all parameters were specified on the command.
;	2298	!--
;	2299	POINTER = .PAT$GL_HEAD_LST;
;	2300	IF (.POINTER EQLA 0) OR (.LIST_ELEM_FLINK(.POINTER) EQLA 0)
;	2301	THEN
;	2302		SIGNAL (PAT$_INVCMD);
;	2303	
;	2304	!++
;	2305	! Initialize unmapped address and PAT$GL_CONTEXT.  The context bit causes
;	2306	! the routine PAT$OUT_MEM_LOC to display a location instead of evaluating
;	2307	! a numeric expression.
;	2308	!--
;	2309	UNMAPPED_LOC = .LIST_ELEM_EXP1 (.POINTER);
;	2310	PAT$GL_CONTEXT[EXAMINE_BIT] = TRUE;
;	2311	
;	2312	!++
;	2313	! For DEPOSIT commands only:
;	2314	!
;	2315	! Check if DEPOSIT qualifier, "/PATCH_AREA", was specified.
;	2316	! If so, check that the address specified is identical to the
;	2317	! start of the current patch area.  If it is not, report an
;	2318	! error and abort the DEPOSIT command.
;	2319	!--
;	2320	IF .PAT$GL_CONTEXT [PAT_AREA_BIT]
;	2321	THEN
;	2322		BEGIN
;	2323		IF (.PAT$GL_PATAREA[DSC$W_LENGTH] EQL 0)
;	2324		THEN
;	2325			IF (.PAT$GL_PATAREA [DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[IHP$L_RW_PATADR])

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-2
; Digital Equipment Corporation
;
;	2326			THEN
;	2327				PAT$EXP_AREA(ONE_PAGE);
;	2328		IF (.PAT$GL_PATAREA [DSC$A_POINTER] NEQA .UNMAPPED_LOC)
;	2329		THEN
;	2330			SIGNAL(PAT$_NOTPATADR, 2, .PAT$GL_PATAREA[DSC$A_POINTER], .UNMAPPED_LOC);
;	2331		END;
;	2332	
;	2333	!++
;	2334	! Set the fill character for DELETE commands.
;	2335	!--
;	2336	IF (.PAT$GB_MOD_PTR [MODE_INSTRUC])
;	2337	THEN
;	2338		BEGIN
;	2339		PAT$GL_SYMTBPTR = .PAT$GL_NEWLABLS;			! Use new contents label table
;	2340		FILL_CHAR = NOP_INSTR;					! Fill character for instructions
;	2341		END
;	2342	ELSE
;	2343		FILL_CHAR = ZERO_BYTE;					! Fill character for data
;	2344	
;	2345	!++
;	2346	! Loop to DEPOSIT (DELETE) all parameters specified in the command.
;	2347	!--
;	2348	REPEAT
;	2349		BEGIN
;	2350		POINTER = .LIST_ELEM_FLINK (.POINTER);
;	2351	
;	2352		!++
;	2353		! Now determine the length of the instruction or data
;	2354		! which is to be deposited or deleted.
;	2355		!--
;	2356		IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
;	2357		THEN
;	2358			BEGIN
;	2359			!++
;	2360			! This is a symbolic instruction to be deposited or deleted.
;	2361			! It is currently in the form of a counted ASCII string that
;	2362			! must be translated into binary form. The call to PAT$INS_ENCODE
;	2363			! needs the address for which the instruction is encoded in
;	2364			! order to resolve branches correctly.
;	2365			!--
;	2366			IF NOT PAT$INS_ENCODE (.LIST_ELEM_EXP1 (.POINTER),
;	2367				INSTRUC_BUF, .UNMAPPED_LOC,
;	2368				(IF .PAT$GL_CONTEXT[DELETE_BIT]
;	2369					 THEN PAT$GL_OLD_ASD
;	2370					 ELSE PAT$GL_NEW_ASD),
;	2371				PAT$GL_TEMP_BUF)
;	2372			THEN
;	2373				SIGNAL (PAT$_NOENCODE, 1, .LIST_ELEM_EXP1(.POINTER)); ! This instruction is invalid.
;	2374			DEP_SRC_ADR = INSTRUC_BUF [1];
;	2375			DEP_SIZ = .INSTRUC_BUF [0];
;	2376			END
;	2377		ELSE
;	2378			BEGIN
;	2379			!++
;	2380			! Determine length and address for deposits or deletes which are

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-3
; Digital Equipment Corporation
;
;	2381			! not symbolic instructions.  Then check for truncation of new value.
;	2382			!--
;	2383			DEP_SRC_ADR = LIST_ELEM_EXP1 (.POINTER);
;	2384			DEP_SIZ = .PAT$GB_MOD_PTR [MODE_LENGTH];
;	2385			IF (.LIST_ELEM_EXP1(.POINTER) LSS 0)
;	2386			THEN
;	2387				BEGIN
;	2388				IF .(LIST_ELEM_EXP1(.POINTER))<0, .DEP_SIZ*8, 1> NEQ .LIST_ELEM_EXP1(.POINTER)
;	2389				THEN
;	2390					SIGNAL(PAT$_NUMTRUNC);
;	2391				END
;	2392			ELSE
;	2393				IF .(LIST_ELEM_EXP1(.POINTER))<0, .DEP_SIZ*8, 0> NEQ .LIST_ELEM_EXP1(.POINTER)
;	2394				THEN
;	2395					SIGNAL(PAT$_NUMTRUNC);
;	2396			END;
;	2397	
;	2398		!++
;	2399		! Now write the new values into a temporary buffer.  They are not
;	2400		! written directly into memory in case part of the command fails.
;	2401		!--
;	2402		PAT$FILL_BUF (PAT$GL_TEMP_BUF, .DEP_SRC_ADR, .DEP_SIZ);
;	2403	
;	2404		!++
;	2405		! Finished with current value.  Reset last location,
;	2406		! next location, and last value, and exitloop.
;	2407		!--
;	2408		PAT$GL_LAST_LOC = .UNMAPPED_LOC;
;	2409		UNMAPPED_LOC = .UNMAPPED_LOC + .DEP_SIZ;
;	2410		IF NOT .PAT$GB_MOD_PTR [MODE_INSTRUC]
;	2411		THEN
;	2412			PAT$GL_LAST_VAL = .LIST_ELEM_EXP1 (.POINTER);
;	2413	
;	2414		!++
;	2415		! If there are no more values, then exit loop which builds 
;	2416		! temporary deposit buffer.
;	2417		!--
;	2418		IF (.LIST_ELEM_FLINK (.POINTER) EQLA 0)
;	2419		THEN
;	2420			EXITLOOP;
;	2421		END;
;	2422	
;	2423	!++
;	2424	! For DEPOSIT command only:
;	2425	!
;	2426	! First check if this is writing into the patch area.  If so, check that there
;	2427	! is enough room in the patch area.  If not, then expand the patch area if
;	2428	! possible (that is, if the current patch area is the one defined int the image
;	2429	! header).  Otherwise, report an error and abort this command.
;	2430	!--
;	2431	IF .PAT$GL_CONTEXT[PAT_AREA_BIT]
;	2432	THEN
;	2433		BEGIN
;	2434		IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
;	2435		THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-4
; Digital Equipment Corporation
;
;	2436			BEGIN
;	2437			IF (.PAT$GL_PATAREA[DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[IHP$L_RW_PATADR])
;	2438			THEN
;	2439				PAT$EXP_AREA((.PAT$GL_TEMP_BUF[DSC$W_LENGTH] + 
;	2440						A_PAGE - 1)/A_PAGE)
;	2441			ELSE
;	2442				SIGNAL(PAT$_INSUFPAT, 2, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
;	2443					.PAT$GL_PATAREA[DSC$A_POINTER],
;	2444					.PAT$GL_PATAREA[DSC$W_LENGTH]);
;	2445			END;
;	2446		END;
;	2447	
;	2448	!++
;	2449	! Now resolve any forward references inside the symbolic instruction operands.
;	2450	!--
;	2451	PAT$RESOLVE_INS(PAT$GL_TEMP_BUF);
;	2452	
;	2453	!++
;	2454	! Output the old values.
;	2455	!--
;	2456	PAT$GL_NEXT_LOC = .LIST_ELEM_EXP1(.PAT$GL_HEAD_LST);
;	2457	WHILE .PAT$GL_NEXT_LOC LSSA .UNMAPPED_LOC
;	2458	DO
;	2459		PAT$OUT_MEM_LOC(.PAT$GL_NEXT_LOC, OLD_TAB_STG, PAT$GL_OLD_ASD);
;	2460	
;	2461	!++
;	2462	! For DELETE commands only:
;	2463	!
;	2464	! Verify that the old values were actually in memory for DELETE commands.
;	2465	! Then fill the temporary buffer with the appropriate fill character.
;	2466	!--
;	2467	IF .PAT$GL_CONTEXT[DELETE_BIT]
;	2468	THEN
;	2469		BEGIN
;	2470		!++
;	2471		! Now get the actual value in the location and
;	2472		! check that it equals the specified value.
;	2473		!--
;	2474		LOCAL
;	2475			BYTE_COUNT,					! Count of bytes verified
;	2476			BUF_SIZE;					! Size of old contents buffer to get
;	2477		BYTE_COUNT = 0;
;	2478		WHILE (.BYTE_COUNT LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
;	2479		DO
;	2480			BEGIN
;	2481			IF ((BUF_SIZE = .PAT$GL_TEMP_BUF[DSC$W_LENGTH] - .BYTE_COUNT) GTR TTY_OUT_WIDTH)
;	2482			THEN
;	2483				BUF_SIZE = TTY_OUT_WIDTH;		! Request only as much as buffer can hold
;	2484			PAT$GET_VALUE(.LIST_ELEM_EXP1(.PAT$GL_HEAD_LST)+.BYTE_COUNT,
;	2485					 .BUF_SIZE, OLD_CONTENTS);
;	2486			IF CH$NEQ(.BUF_SIZE, .PAT$GL_TEMP_BUF[DSC$A_POINTER]+.BYTE_COUNT,
;	2487					 .BUF_SIZE, OLD_CONTENTS)
;	2488			THEN
;	2489				SIGNAL(PAT$_DIFVAL+MSG$K_WARN);
;	2490			BYTE_COUNT = .BYTE_COUNT + .BUF_SIZE;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-5
; Digital Equipment Corporation
;
;	2491			END;
;	2492		CH$FILL(.FILL_CHAR, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
;	2493			 .PAT$GL_TEMP_BUF[DSC$A_POINTER]);
;	2494		END;
;	2495	
;	2496	!++
;	2497	! Now write the temporary buffer into memory.
;	2498	!--
;	2499	PAT$GL_NEXT_LOC = .LIST_ELEM_EXP1(.PAT$GL_HEAD_LST);
;	2500	PAT$WRITE_MEM (.PAT$GL_NEXT_LOC, .PAT$GL_TEMP_BUF[DSC$A_POINTER],
;	2501				 .PAT$GL_TEMP_BUF[DSC$W_LENGTH]);
;	2502	
;	2503	!++
;	2504	! Output the new values.
;	2505	!--
;	2506	WHILE .PAT$GL_NEXT_LOC LSSA .UNMAPPED_LOC
;	2507	DO
;	2508		PAT$OUT_MEM_LOC(.PAT$GL_NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD);
;	2509	!++
;	2510	! Now check if the deposit was into the current patch area.  If so,
;	2511	! update the patch area descriptor.
;	2512	!--
;	2513	IF .PAT$GL_CONTEXT [PAT_AREA_BIT]
;	2514	THEN
;	2515		BEGIN
;	2516		PAT$GL_PATAREA[DSC$A_POINTER] = .PAT$GL_PATAREA[DSC$A_POINTER] + 
;	2517						.PAT$GL_TEMP_BUF[DSC$W_LENGTH];
;	2518		PAT$GL_PATAREA[DSC$W_LENGTH] = .PAT$GL_PATAREA[DSC$W_LENGTH] - 
;	2519						.PAT$GL_TEMP_BUF[DSC$W_LENGTH];
;	2520		END;
;	2521	!++
;	2522	! Now add the new labels to the user-defined symbol table.
;	2523	!--
;	2524	PAT$ADD_LABELS(PAT$GL_NEWLABLS);
;	2525	
;	2526	
;	2527	RETURN;
;	2528	END;


							    .TITLE  PATEXA
							    .IDENT  \X01.19\

							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .BYTE   2							      ;
					      00001 	    .ASCII  \R0\						      ;
					      00003 	    .BYTE   0							      ;
					      00004 	    .BYTE   2							      ;
					      00005 	    .ASCII  \R1\						      ;
					      00007 	    .BYTE   0							      ;
					      00008 	    .BYTE   2							      ;
					      00009 	    .ASCII  \R2\						      ;
					      0000B 	    .BYTE   0							      ;
					      0000C 	    .BYTE   2							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-6
; Digital Equipment Corporation
;
					      0000D 	    .ASCII  \R3\						      ;
					      0000F 	    .BYTE   0							      ;
					      00010 	    .BYTE   2							      ;
					      00011 	    .ASCII  \R4\						      ;
					      00013 	    .BYTE   0							      ;
					      00014 	    .BYTE   2							      ;
					      00015 	    .ASCII  \R5\						      ;
					      00017 	    .BYTE   0							      ;
					      00018 	    .BYTE   2							      ;
					      00019 	    .ASCII  \R6\						      ;
					      0001B 	    .BYTE   0							      ;
					      0001C 	    .BYTE   2							      ;
					      0001D 	    .ASCII  \R7\						      ;
					      0001F 	    .BYTE   0							      ;
					      00020 	    .BYTE   2							      ;
					      00021 	    .ASCII  \R8\						      ;
					      00023 	    .BYTE   0							      ;
					      00024 	    .BYTE   2							      ;
					      00025 	    .ASCII  \R9\						      ;
					      00027 	    .BYTE   0							      ;
					      00028 	    .BYTE   3							      ;
					      00029 	    .ASCII  \R10\						      ;
					      0002C 	    .BYTE   3							      ;
					      0002D 	    .ASCII  \R11\						      ;
					      00030 	    .BYTE   2							      ;
					      00031 	    .ASCII  \AP\						      ;
					      00033 	    .BYTE   0							      ;
					      00034 	    .BYTE   2							      ;
					      00035 	    .ASCII  \FP\						      ;
					      00037 	    .BYTE   0							      ;
					      00038 	    .BYTE   2							      ;
					      00039 	    .ASCII  \SP\						      ;
					      0003B 	    .BYTE   0							      ;
					      0003C 	    .BYTE   2							      ;
					      0003D 	    .ASCII  \PC\						      ;
					      0003F 	    .BYTE   0							      ;
					      00040 	    .BYTE   3							      ;
					      00041 	    .ASCII  \PSL\						      ;
					      00044 P.AAB:  .ASCII  <5>\'!AD'\<0><0>					      ;
					      0004C P.AAC:  .ASCII  <3>\:  \						      ;
					      00050 P.AAD:  .ASCII  <2>\!/\<0>						      ;
					      00054 P.AAE:  .ASCII  <5>\old:\<9><0><0>					      ;
					      0005C P.AAF:  .ASCII  <5>\new:\<9><0><0>					      ;

						    ISE$C_SIZE==	20
						    TXT$C_SIZE==	4
						    PAL$C_SIZE==	16
						    ASD$C_SIZE==	9
						    FWR$C_SIZE==	24
						    REGISTER_TABLE=	P.AAA
						    CS_ASCII=		P.AAB
						    COLON_TAB_STG=	P.AAC
						    CAR_CTL_STG=	P.AAD
						    OLD_TAB_STG=	P.AAE
						    NEW_TAB_STG=	P.AAF

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-7
; Digital Equipment Corporation
;
							    .GLOBL  PAT$GL_RST_BEGN, PAT$FAO_OUT, PAT$GB_SYMBOLS, PAT$GL_OLD_ASD
							    .GLOBL  PAT$GL_NEW_ASD, PAT$GL_TEMP_BUF, PAT$GL_RLOC_BUF
							    .GLOBL  PAT$GB_SUBST_IN, PAT$GL_BR_DISPL, PAT$GL_PATAREA
							    .GLOBL  PAT$GL_IMGHDR, PAT$GB_LOC_TYPE, PAT$GB_MOD_PTR
							    .GLOBL  PAT$GL_IHPPTR, PAT$CP_OUT_STR, PAT$GL_CONTEXT
							    .GLOBL  PAT$GL_BUF_SIZ, PAT$GL_HEAD_LST, PAT$GL_LAST_LOC
							    .GLOBL  PAT$GL_LAST_VAL, PAT$GL_NEXT_LOC, PAT$GL_SYMTBPTR
							    .GLOBL  PAT$GL_OLDLABLS, PAT$GL_NEWLABLS, PAT$GL_RLCLABLS
							    .GLOBL  PAT$ADD_LABELS, PAT$ADD_NT_T_PV, PAT$EXP_AREA
							    .GLOBL  PAT$FAO_PUT, PAT$FREERELEASE, PAT$FREEZ, PAT$GET_NXT_LVT
							    .GLOBL  PAT$GET_VALUE, PAT$INS_DECODE, PAT$INS_ENCODE
							    .GLOBL  PAT$MAP_ADDR, PAT$OUT_NUM_VAL, PAT$OUT_PUT, PAT$OUT_SYM_VAL
							    .GLOBL  PAT$PRINT_PATH, PAT$RESOLVE_INS, PAT$SYMBOL_VALU
							    .GLOBL  PAT$UNMAP_ADDR, PAT$VAL_TO_SYM, PAT$WRITE_MEM
							    .WEAK   ACCESS_CHECK

							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 00000 	    .ENTRY  PAT$DEPOSIT_CMD, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 2217
		         58 00000000G  00  9E 00002 	    MOVAB   LIB$SIGNAL, R8					      ;
		         59 00000000G  EF  9E 00009 	    MOVAB   PAT$GL_NEXT_LOC, R9					      ;
		         5A 00000000G  EF  9E 00010 	    MOVAB   PAT$GL_PATAREA, R10					      ;
		         5B 00000000G  EF  9E 00017 	    MOVAB   PAT$GL_TEMP_BUF, R11				      ;
		         5E	FF2C   CE  9E 0001E 	    MOVAB   -212(SP), SP					      ;
		         52 00000000G  EF  D0 00023 	    MOVL    PAT$GL_HEAD_LST, POINTER				      ; 2299
				       04  13 0002A 	    BEQL    1$							      ; 2300
				       62  D5 0002C 	    TSTL    (POINTER)						      ;
				       09  12 0002E 	    BNEQ    2$							      ;
			    006D80C2   8F  DD 00030 1$:     PUSHL   #7176386						      ; 2302
		         68	       01  FB 00036 	    CALLS   #1, LIB$SIGNAL					      ;
		         56	  04   A2  D0 00039 2$:     MOVL    4(POINTER), UNMAPPED_LOC				      ; 2309
	      00000000G  EF	       01  88 0003D 	    BISB2   #1, PAT$GL_CONTEXT+1				      ; 2310
	   3B 00000000G  EF	       03  E1 00044 	    BBC     #3, PAT$GL_CONTEXT+2, 4$				      ; 2320
				  00   BA  B5 0004C 	    TSTW    @PAT$GL_PATAREA					      ; 2323
				       1A  12 0004F 	    BNEQ    3$							      ;
		         51	       6A  D0 00051 	    MOVL    PAT$GL_PATAREA, R1					      ; 2325
		         50 00000000G  EF  D0 00054 	    MOVL    PAT$GL_IHPPTR, R0					      ;
		    14   A0	  04   A1  D1 0005B 	    CMPL    4(R1), 20(R0)					      ;
				       09  12 00060 	    BNEQ    3$							      ;
				       01  DD 00062 	    PUSHL   #1							      ; 2327
	      00000000G  EF	       01  FB 00064 	    CALLS   #1, PAT$EXP_AREA					      ;
		         50	       6A  D0 0006B 3$:     MOVL    PAT$GL_PATAREA, R0					      ; 2328
		         56	  04   A0  D1 0006E 	    CMPL    4(R0), UNMAPPED_LOC					      ;
				       13  13 00072 	    BEQL    4$							      ;
				       56  DD 00074 	    PUSHL   UNMAPPED_LOC					      ; 2330
		         50	       6A  D0 00076 	    MOVL    PAT$GL_PATAREA, R0					      ;
				  04   A0  DD 00079 	    PUSHL   4(R0)						      ;
				       02  DD 0007C 	    PUSHL   #2							      ;
			    006D810A   8F  DD 0007E 	    PUSHL   #7176458						      ;
		         68	       04  FB 00084 	    CALLS   #4, LIB$SIGNAL					      ;
		         50 00000000G  EF  D0 00087 4$:     MOVL    PAT$GB_MOD_PTR, R0					      ; 2336
		         10	  03   A0  E9 0008E 	    BLBC    3(R0), 5$						      ;
	      00000000G  EF 00000000G  EF  D0 00092 	    MOVL    PAT$GL_NEWLABLS, PAT$GL_SYMTBPTR			      ; 2339
		         57	       01  90 0009D 	    MOVB    #1, FILL_CHAR					      ; 2340
				       02  11 000A0 	    BRB     6$							      ; 2336

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-8
; Digital Equipment Corporation
;
				       57  94 000A2 5$:     CLRB    FILL_CHAR						      ; 2343
		         52	       62  D0 000A4 6$:     MOVL    (POINTER), POINTER					      ; 2350
		         50 00000000G  EF  D0 000A7 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2356
		         46	  03   A0  E9 000AE 	    BLBC    3(R0), 10$						      ;
				       5B  DD 000B2 	    PUSHL   R11							      ; 2366
	   09 00000000G  EF	       06  E1 000B4 	    BBC     #6, PAT$GL_CONTEXT+2, 7$				      ; 2368
		         50 00000000G  EF  9E 000BC 	    MOVAB   PAT$GL_OLD_ASD, R0					      ;
				       07  11 000C3 	    BRB     8$							      ;
		         50 00000000G  EF  9E 000C5 7$:     MOVAB   PAT$GL_NEW_ASD, R0					      ;
				       50  DD 000CC 8$:     PUSHL   R0							      ;
				       56  DD 000CE 	    PUSHL   UNMAPPED_LOC					      ; 2366
				  B0   AD  9F 000D0 	    PUSHAB  INSTRUC_BUF						      ;
				  04   A2  DD 000D3 	    PUSHL   4(POINTER)						      ;
	      00000000G  EF	       05  FB 000D6 	    CALLS   #5, PAT$INS_ENCODE					      ;
		         0E	       50  E8 000DD 	    BLBS    R0, 9$						      ;
				  04   A2  DD 000E0 	    PUSHL   4(POINTER)						      ; 2373
				       01  DD 000E3 	    PUSHL   #1							      ;
			    006D80F2   8F  DD 000E5 	    PUSHL   #7176434						      ;
		         68	       03  FB 000EB 	    CALLS   #3, LIB$SIGNAL					      ;
		         54	  B1   AD  9E 000EE 9$:     MOVAB   INSTRUC_BUF+1, DEP_SRC_ADR				      ; 2374
		         53	  B0   AD  9A 000F2 	    MOVZBL  INSTRUC_BUF, DEP_SIZ				      ; 2375
				       39  11 000F6 	    BRB     13$							      ; 2356
	   54	         52	       04  C1 000F8 10$:    ADDL3   #4, POINTER, DEP_SRC_ADR				      ; 2383
		         50 00000000G  EF  D0 000FC 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2384
		         53	  01   A0  9A 00103 	    MOVZBL  1(R0), DEP_SIZ					      ;
				  04   A2  D5 00107 	    TSTL    4(POINTER)						      ; 2385
				       0C  18 0010A 	    BGEQ    11$							      ;
	   50	         53	       03  78 0010C 	    ASHL    #3, DEP_SIZ, R0					      ; 2388
      04   A2	         50	       00  EE 00110 	    EXTV    #0, R0, 4(POINTER), R1				      ;
				       51     00115									      ;
				       0A  11 00116 	    BRB     12$							      ;
	   50	         53	       03  78 00118 11$:    ASHL    #3, DEP_SIZ, R0					      ; 2393
      04   A2	         50	       00  EF 0011C 	    EXTZV   #0, R0, 4(POINTER), R1				      ;
				       51     00121									      ;
		    04   A2	       51  D1 00122 12$:    CMPL    R1, 4(POINTER)					      ;
				       09  13 00126 	    BEQL    13$							      ;
			    006D8023   8F  DD 00128 	    PUSHL   #7176227						      ; 2395
		         68	       01  FB 0012E 	    CALLS   #1, LIB$SIGNAL					      ;
				       53  DD 00131 13$:    PUSHL   DEP_SIZ						      ; 2402
				       54  DD 00133 	    PUSHL   DEP_SRC_ADR						      ;
				       5B  DD 00135 	    PUSHL   R11							      ;
	      00000000V  EF	       03  FB 00137 	    CALLS   #3, PAT$FILL_BUF					      ;
	      00000000G  EF	       56  D0 0013E 	    MOVL    UNMAPPED_LOC, PAT$GL_LAST_LOC			      ; 2408
		         56	       53  C0 00145 	    ADDL2   DEP_SIZ, UNMAPPED_LOC				      ; 2409
		         50 00000000G  EF  D0 00148 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2410
		         08	  03   A0  E8 0014F 	    BLBS    3(R0), 14$						      ;
	      00000000G  EF	  04   A2  D0 00153 	    MOVL    4(POINTER), PAT$GL_LAST_VAL				      ; 2412
				       62  D5 0015B 14$:    TSTL    (POINTER)						      ; 2418
				       03  13 0015D 	    BEQL    15$							      ;
				     FF42  31 0015F 	    BRW     6$							      ;
	   48 00000000G  EF	       03  E1 00162 15$:    BBC     #3, PAT$GL_CONTEXT+2, 17$				      ; 2431
		         6B	  00   BA  B1 0016A 	    CMPW    @PAT$GL_PATAREA, PAT$GL_TEMP_BUF			      ; 2434
				       42  1E 0016E 	    BGEQU   17$							      ;
		         51	       6A  D0 00170 	    MOVL    PAT$GL_PATAREA, R1					      ; 2437
		         50 00000000G  EF  D0 00173 	    MOVL    PAT$GL_IHPPTR, R0					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-9
; Digital Equipment Corporation
;
		    14   A0	  04   A1  D1 0017A 	    CMPL    4(R1), 20(R0)					      ;
				       19  12 0017F 	    BNEQ    16$							      ;
		         50	       6B  3C 00181 	    MOVZWL  PAT$GL_TEMP_BUF, R0					      ; 2439
		         50	01FF   C0  9E 00184 	    MOVAB   511(R0), R0						      ;
	   7E	         50 00000200   8F  C7 00189 	    DIVL3   #512, R0, -(SP)					      ; 2440
	      00000000G  EF	       01  FB 00191 	    CALLS   #1, PAT$EXP_AREA					      ; 2439
				       18  11 00198 	    BRB     17$							      ; 2437
		         7E	  00   BA  3C 0019A 16$:    MOVZWL  @PAT$GL_PATAREA, -(SP)				      ; 2442
		         50	       6A  D0 0019E 	    MOVL    PAT$GL_PATAREA, R0					      ; 2443
				  04   A0  DD 001A1 	    PUSHL   4(R0)						      ; 2442
		         7E	       6B  3C 001A4 	    MOVZWL  PAT$GL_TEMP_BUF, -(SP)				      ;
				       02  DD 001A7 	    PUSHL   #2							      ;
			    006D80AA   8F  DD 001A9 	    PUSHL   #7176362						      ;
		         68	       05  FB 001AF 	    CALLS   #5, LIB$SIGNAL					      ;
				       5B  DD 001B2 17$:    PUSHL   R11							      ; 2451
	      00000000G  EF	       01  FB 001B4 	    CALLS   #1, PAT$RESOLVE_INS					      ;
		         50 00000000G  EF  D0 001BB 	    MOVL    PAT$GL_HEAD_LST, R0					      ; 2456
		         69	  04   A0  D0 001C2 	    MOVL    4(R0), PAT$GL_NEXT_LOC				      ;
		         56	       69  D1 001C6 18$:    CMPL    PAT$GL_NEXT_LOC, UNMAPPED_LOC			      ; 2457
				       17  1E 001C9 	    BGEQU   19$							      ;
			    00000000G  EF  9F 001CB 	    PUSHAB  PAT$GL_OLD_ASD					      ; 2459
			    00000000'  EF  9F 001D1 	    PUSHAB  OLD_TAB_STG						      ; 2217
				       69  DD 001D7 	    PUSHL   PAT$GL_NEXT_LOC					      ; 2459
	      00000000V  EF	       03  FB 001D9 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
				       E4  11 001E0 	    BRB     18$							      ; 2457
	   4F 00000000G  EF	       06  E1 001E2 19$:    BBC     #6, PAT$GL_CONTEXT+2, 24$				      ; 2467
				       54  D4 001EA 	    CLRL    BYTE_COUNT						      ; 2477
	   6B	         10	       00  ED 001EC 20$:    CMPZV   #0, #16, PAT$GL_TEMP_BUF, BYTE_COUNT		      ; 2478
				       54     001F0									      ;
				       3F  15 001F1 	    BLEQ    23$							      ;
		         55	       6B  3C 001F3 	    MOVZWL  PAT$GL_TEMP_BUF, BUF_SIZE				      ; 2481
		         55	       54  C2 001F6 	    SUBL2   BYTE_COUNT, BUF_SIZE				      ;
	      00000084   8F	       55  D1 001F9 	    CMPL    BUF_SIZE, #132					      ;
				       04  15 00200 	    BLEQ    21$							      ;
		         55	  84   8F  9A 00202 	    MOVZBL  #132, BUF_SIZE					      ; 2483
				4020   8F  BB 00206 21$:    PUSHR   #^M<R5,SP>						      ; 2484
		         50 00000000G  EF  D0 0020A 	    MOVL    PAT$GL_HEAD_LST, R0					      ;
				  04 B044  9F 00211 	    PUSHAB  @4(R0)[BYTE_COUNT]					      ;
	      00000000G  EF	       03  FB 00215 	    CALLS   #3, PAT$GET_VALUE					      ;
	   6E	    04 BB44	       55  29 0021C 	    CMPC3   BUF_SIZE, @PAT$GL_TEMP_BUF+4[BYTE_COUNT], OLD_CONTENTS    ; 2486
				       09  13 00222 	    BEQL    22$							      ;
			    006D82C0   8F  DD 00224 	    PUSHL   #7176896						      ; 2489
		         68	       01  FB 0022A 	    CALLS   #1, LIB$SIGNAL					      ;
		         54	       55  C0 0022D 22$:    ADDL2   BUF_SIZE, BYTE_COUNT				      ; 2490
				       BA  11 00230 	    BRB     20$							      ; 2478
	   57	         6E	       00  2C 00232 23$:    MOVC5   #0, (SP), FILL_CHAR, PAT$GL_TEMP_BUF, @PAT$GL_TEMP_BUF+4  ; 2492
		    04   BB	       6B     00236									      ;
		         50 00000000G  EF  D0 00239 24$:    MOVL    PAT$GL_HEAD_LST, R0					      ; 2499
		         69	  04   A0  D0 00240 	    MOVL    4(R0), PAT$GL_NEXT_LOC				      ;
		         7E	       6B  3C 00244 	    MOVZWL  PAT$GL_TEMP_BUF, -(SP)				      ; 2500
				  04   AB  DD 00247 	    PUSHL   PAT$GL_TEMP_BUF+4					      ;
				       69  DD 0024A 	    PUSHL   PAT$GL_NEXT_LOC					      ;
	      00000000G  EF	       03  FB 0024C 	    CALLS   #3, PAT$WRITE_MEM					      ;
		         56	       69  D1 00253 25$:    CMPL    PAT$GL_NEXT_LOC, UNMAPPED_LOC			      ; 2506
				       17  1E 00256 	    BGEQU   26$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 4-10
; Digital Equipment Corporation
;
			    00000000G  EF  9F 00258 	    PUSHAB  PAT$GL_NEW_ASD					      ; 2508
			    00000000'  EF  9F 0025E 	    PUSHAB  NEW_TAB_STG						      ; 2217
				       69  DD 00264 	    PUSHL   PAT$GL_NEXT_LOC					      ; 2508
	      00000000V  EF	       03  FB 00266 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
				       E4  11 0026D 	    BRB     25$							      ; 2506
	   13 00000000G  EF	       03  E1 0026F 26$:    BBC     #3, PAT$GL_CONTEXT+2, 27$				      ; 2513
		         50	       6A  D0 00277 	    MOVL    PAT$GL_PATAREA, R0					      ; 2516
		         51	       6A  D0 0027A 	    MOVL    PAT$GL_PATAREA, R1					      ;
		         52	       6B  3C 0027D 	    MOVZWL  PAT$GL_TEMP_BUF, R2					      ;
      04   A0	    04   A1	       52  C1 00280 	    ADDL3   R2, 4(R1), 4(R0)					      ;
		    00   BA	       6B  A2 00286 	    SUBW2   PAT$GL_TEMP_BUF, @PAT$GL_PATAREA			      ; 2518
			    00000000G  EF  9F 0028A 27$:    PUSHAB  PAT$GL_NEWLABLS					      ; 2524
	      00000000G  EF	       01  FB 00290 	    CALLS   #1, PAT$ADD_LABELS					      ;
					   04 00297 	    RET     							      ; 2217

; Routine Size:  664 bytes


;	2529	SWITCHES OPTIMIZE;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 5
; Digital Equipment Corporation
;
;	2530	GLOBAL ROUTINE PAT$EXAMINE_CMD : NOVALUE =
;	2531	
;	2532	!++
;	2533	! FUNCTIONAL DESCRIPTION:
;	2534	!
;	2535	!	Examines a list of addresses.
;	2536	!
;	2537	! CALLING SEQUENCE:
;	2538	!
;	2539	!	PAT$EXAMINE_CMD ()
;	2540	!
;	2541	! INPUTS:
;	2542	!
;	2543	!	none
;	2544	!
;	2545	! IMPLICIT INPUTS:
;	2546	!
;	2547	!	The address of the first element of a list of addresses.
;	2548	!	The last address examined, and the next logical address to examine.
;	2549	!
;	2550	! OUTPUTS:
;	2551	!
;	2552	!	none
;	2553	!
;	2554	! IMPLICIT OUTPUTS:
;	2555	!
;	2556	!	New values for last and next location, and last value
;	2557	!
;	2558	! ROUTINE VALUE:
;	2559	!
;	2560	!	novalue
;	2561	!
;	2562	! SIDE EFFECTS:
;	2563	!
;	2564	!	The values of various addresses are output.
;	2565	!	If an error occurs, the routine returns without further
;	2566	!	processing except to output an error message to the output
;	2567	!	device.
;	2568	!
;	2569	!--
;	2570	
;	2571	BEGIN
;	2572	
;	2573	LOCAL
;	2574		MAPPED_NEXT_LOC,					! Mapped address of next location
;	2575		ISE_ADDR,						! ISE address for mapped address
;	2576		POINTER;
;	2577	
;	2578	POINTER = .PAT$GL_HEAD_LST;
;	2579	IF (.POINTER EQL 0)
;	2580	THEN
;	2581	
;	2582		!++
;	2583		! No location was specified. Examine the next location in sequence.
;	2584		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 5-1
; Digital Equipment Corporation
;
;	2585		PAT$OUT_MEM_LOC (.PAT$GL_NEXT_LOC, 0, PAT$GL_OLD_ASD)
;	2586	ELSE DO
;	2587		BEGIN
;	2588	
;	2589		LOCAL
;	2590			LAST_LOC;
;	2591	
;	2592		!++
;	2593		! Pick up the next value which we will try to
;	2594		! display and copy it into LAST_LOC.
;	2595		!--
;	2596		LAST_LOC = .LIST_ELEM_EXP1 (.POINTER);
;	2597	
;	2598		!++
;	2599		! If the end range argument is null, then make it the same as the start
;	2600		! range argument so that only one location will be displayed.
;	2601		!--
;	2602		IF .LIST_ELEM_EXP2 (.POINTER) EQL 0
;	2603		THEN LIST_ELEM_EXP2 (.POINTER) = .LIST_ELEM_EXP1 (.POINTER);
;	2604	
;	2605		!++
;	2606		! Check for range reversal.
;	2607		!--
;	2608		IF( .LIST_ELEM_EXP2(.POINTER) LSSA .LIST_ELEM_EXP1(.POINTER) )
;	2609		THEN
;	2610			BEGIN
;	2611			SIGNAL (PAT$_EXARANGE);
;	2612			RETURN;
;	2613			END;
;	2614		WHILE (.LAST_LOC LEQ .LIST_ELEM_EXP2 (.POINTER)) DO
;	2615			BEGIN
;	2616			IF NOT PAT$OUT_MEM_LOC (.LAST_LOC, 0, PAT$GL_OLD_ASD)
;	2617			THEN RETURN;
;	2618			LAST_LOC = .PAT$GL_NEXT_LOC;
;	2619			END;
;	2620		END
;	2621	UNTIL (POINTER = .LIST_ELEM_FLINK (.POINTER)) EQL 0;
;	2622	
;	2623	END;





					 0E0C 00298 	    .ENTRY  PAT$EXAMINE_CMD, Save R2,R3,R9,R10,R11		      ; 2530
		         59 00000000V  EF  9E 0029A 	    MOVAB   PAT$OUT_MEM_LOC, R9					      ;
		         5A 00000000G  EF  9E 002A1 	    MOVAB   PAT$GL_NEXT_LOC, R10				      ;
		         5B 00000000G  EF  9E 002A8 	    MOVAB   PAT$GL_OLD_ASD, R11					      ;
		         52 00000000G  EF  D0 002AF 	    MOVL    PAT$GL_HEAD_LST, POINTER				      ; 2578
				       0A  12 002B6 	    BNEQ    1$							      ; 2579
				       5B  DD 002B8 	    PUSHL   R11							      ; 2585
				       7E  D4 002BA 	    CLRL    -(SP)						      ;
				       6A  DD 002BC 	    PUSHL   PAT$GL_NEXT_LOC					      ;
		         69	       03  FB 002BE 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
					   04 002C1 	    RET     							      ; 2579

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 5-2
; Digital Equipment Corporation
;
		         53	  04   A2  D0 002C2 1$:     MOVL    4(POINTER), LAST_LOC				      ; 2596
				  08   A2  D5 002C6 	    TSTL    8(POINTER)						      ; 2602
				       05  12 002C9 	    BNEQ    2$							      ;
		    08   A2	  04   A2  D0 002CB 	    MOVL    4(POINTER), 8(POINTER)				      ; 2603
		    04   A2	  08   A2  D1 002D0 2$:     CMPL    8(POINTER), 4(POINTER)				      ; 2608
				       0E  1E 002D5 	    BGEQU   3$							      ;
			    006D8092   8F  DD 002D7 	    PUSHL   #7176338						      ; 2611
	      00000000G  00	       01  FB 002DD 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 002E4 	    RET     							      ; 2612
		    08   A2	       53  D1 002E5 3$:     CMPL    LAST_LOC, 8(POINTER)				      ; 2614
				       11  14 002E9 	    BGTR    4$							      ;
				       5B  DD 002EB 	    PUSHL   R11							      ; 2616
				       7E  D4 002ED 	    CLRL    -(SP)						      ;
				       53  DD 002EF 	    PUSHL   LAST_LOC						      ;
		         69	       03  FB 002F1 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
		         0A	       50  E9 002F4 	    BLBC    R0, 5$						      ;
		         53	       6A  D0 002F7 	    MOVL    PAT$GL_NEXT_LOC, LAST_LOC				      ; 2618
				       E9  11 002FA 	    BRB     3$							      ; 2614
		         52	       62  D0 002FC 4$:     MOVL    (POINTER), POINTER					      ; 2621
				       C1  12 002FF 	    BNEQ    1$							      ;
					   04 00301 5$:     RET     							      ; 2530

; Routine Size:  106 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6
; Digital Equipment Corporation
;
;	2624	GLOBAL ROUTINE PAT$REPLACE_CMD : NOVALUE =
;	2625	
;	2626	!++
;	2627	! FUNCTIONAL DESCRIPTION:
;	2628	!
;	2629	!	This routine handles all REPLACE, INSERT and VERIFY commands, those for
;	2630	!	instructions and those for values.  The instruction/value specified in
;	2631	!	the command must be identical to those actually contained in the
;	2632	!	location, otherwise an error message is produced and the command
;	2633	!	ends prematurely.
;	2634	!
;	2635	!	The command argument list is made up of entries that are
;	2636	!	each three longwords long. The first is a forward link to the
;	2637	!	next entry. The second longword in the first entry in the list
;	2638	!	is the address into which some value(s) is (are) to be replaced.
;	2639	!	The third longword is unused. The second longword in successive
;	2640	!	arguments is the old values/instructions and thier replacemeents.
;	2641	!	The first value should be the contents of the specified location;
;	2642	!	the second, the contents of that location plus the current mode_length,
;	2643	!	etc.  The last old value has an EXIT_TOKEN in the third longword
;	2644	!	(all others have zero).
;	2645	!
;	2646	!	For instruction replacement, the second longword contains
;	2647	!	the address of a counted ascii stream that is to be translated
;	2648	!	into a binary instruction.
;	2649	!
;	2650	!	The VERIFY command is identical to the replace command save
;	2651	!	that it has no replacement values.  The INSERT command has only one
;	2652	!	old instruction and causes it to be moved to the patch area instead
;	2653	!	of replaced.
;	2654	!
;	2655	!	There are three label tables used to differentiate between old labels,
;	2656	!	new un-relocated labels, and new relocated labels.  The table(s) used
;	2657	!	to resolve symbols inside symbolic instructions depends updon which
;	2658	!	instruction is being encoded (old or new) and whether or not they are
;	2659	!	being relocated to patch area.  Three tables are necessary to handle
;	2660	!	relocation correctly, i.e., old labels can be used for all instructions
;	2661	!	but new labels cannot be used for relocated instructions.  No labels
;	2662	!	can be added to the user-defined symbol table until the PATCH command
;	2663	!	is successfully executed.
;	2664	!
;	2665	! CALLING SEQUENCE:
;	2666	!
;	2667	!	PAT$REPLACE_CMD ()
;	2668	!
;	2669	! INPUTS:
;	2670	!
;	2671	!	none
;	2672	!
;	2673	! IMPLICIT INPUTS:
;	2674	!
;	2675	!	PAT$GL_HEAD_LST, the head of the linked PATCH command argument list.
;	2676	!	the current mode, and the current patch area descriptor.
;	2677	!
;	2678	! OUTPUTS:

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-1
; Digital Equipment Corporation
;
;	2679	!
;	2680	!	none
;	2681	!
;	2682	! IMPLICIT OUTPUTS:
;	2683	!
;	2684	!	none
;	2685	!
;	2686	! ROUTINE VALUE:
;	2687	!
;	2688	!	novalue
;	2689	!
;	2690	! SIDE EFFECTS:
;	2691	!
;	2692	!	If a failure in a write or contents verification occurs,
;	2693	!	the routine returns immediately.  If the command is executed
;	2694	!	successfully, then the specified addresses have new values and any
;	2695	!	labels in the command are added to the user-defined symbol table.
;	2696	!
;	2697	!--
;	2698	
;	2699	BEGIN
;	2700	
;	2701	LITERAL
;	2702		NOP_INSTR = 1,						! Fill character for instructions
;	2703		ZERO_BYTE = 0,						! Fill characters for data
;	2704		MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction
;	2705	
;	2706	LOCAL
;	2707		BYTE_COUNT,						! Count of bytesverified
;	2708		BUF_SIZE,						! Size of OLD_CONTENTS to compare
;	2709		INSTRUC_BUF: VECTOR [MAX_INST_LEN, BYTE],
;	2710		OLD_CONTENTS : VECTOR[TTY_OUT_WIDTH,BYTE],		! Buffer to hold actual contents of location
;	2711		UNMAPPED_LOC,						! Unmapped address of DEPOSIT destination
;	2712		OLD_VALUE_PTR : REF VECTOR[,BYTE],			! Pointer of actual contents of location
;	2713		VAL_SIZ,						! Size of current value/instruction
;	2714		HOLE_SIZ,						! Cumulative size to replace
;	2715		NEXT_LOC,						! Pointer to next consecutive location
;	2716		FILL_CHAR : BYTE,					! Fill character for data/instructions
;	2717		POINTER,
;	2718		OLD_INS_SIZ,						! Number of bytes of old instruction moved for INSERT command
;	2719		NEW_INS_PTR;						! Pointer to first new instruction argument
;	2720	
;	2721	!++
;	2722	! Check for required parameter.
;	2723	!--
;	2724	POINTER = .PAT$GL_HEAD_LST;
;	2725	IF (.LIST_ELEM_FLINK (.POINTER) EQLA 0)  OR  (.POINTER EQLA 0)
;	2726	THEN
;	2727		SIGNAL(PAT$_INVCMD);
;	2728	
;	2729	!++
;	2730	! Set the examine bit for PAT$OUT_MEM_LOC.
;	2731	!
;	2732	PAT$GL_CONTEXT [EXAMINE_BIT] = TRUE;
;	2733	UNMAPPED_LOC = .LIST_ELEM_EXP1 (.POINTER);

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-2
; Digital Equipment Corporation
;
;	2734	NEXT_LOC = .LIST_ELEM_EXP1 (.POINTER);
;	2735	HOLE_SIZ = 0;
;	2736	PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;				! Use old contents label list
;	2737	
;	2738	!++
;	2739	! Now loop, validating the old contents are the expected values.
;	2740	! The last old value argument contains an EXIT_TOKEN in position LIST_ELEM_EXP2.
;	2741	!--
;	2742	REPEAT
;	2743		BEGIN
;	2744		POINTER = .LIST_ELEM_FLINK (.POINTER);
;	2745	
;	2746		!++
;	2747		! Now compute the binary instruction stream that should be in
;	2748		! the location.
;	2749		!--
;	2750		IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
;	2751		THEN
;	2752			BEGIN
;	2753			!++
;	2754			! This is a symbolic instruction.  It is currently
;	2755			! in the form of a counted ASCII string that must be translated
;	2756			! into binary form. The call to PAT$INS_ENCODE needs the address
;	2757			! into which the instruction is being deposited in order to
;	2758			! resolve branches correctly.
;	2759			!--
;	2760			IF NOT PAT$INS_ENCODE (.LIST_ELEM_EXP1 (.POINTER),
;	2761				INSTRUC_BUF, .NEXT_LOC, PAT$GL_OLD_ASD, PAT$GL_TEMP_BUF)
;	2762			THEN
;	2763				SIGNAL (PAT$_NOENCODE, 1, .LIST_ELEM_EXP1(.POINTER)); ! This instruction is not valid.
;	2764			OLD_VALUE_PTR = INSTRUC_BUF [1];
;	2765			VAL_SIZ = .INSTRUC_BUF [0];
;	2766			END
;	2767		ELSE
;	2768			BEGIN
;	2769			!++
;	2770			! Value is not an instruction.  Therefore it is on the parse
;	2771			! stack.  The current mode for length tells the number of bytes
;	2772			! of the value.  Set pointer to data and size indicator.  Then
;	2773			! check for a truncation error.
;	2774			!--
;	2775			OLD_VALUE_PTR = LIST_ELEM_EXP1 (.POINTER);
;	2776			VAL_SIZ = .PAT$GB_MOD_PTR [MODE_LENGTH];
;	2777			IF .LIST_ELEM_EXP1(.POINTER) LSS 0
;	2778			THEN
;	2779				BEGIN
;	2780				IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 1> NEQ .LIST_ELEM_EXP1(.POINTER)
;	2781				THEN
;	2782					SIGNAL(PAT$_NUMTRUNC);
;	2783				END
;	2784			ELSE
;	2785				IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 0> NEQ .LIST_ELEM_EXP1(.POINTER)
;	2786				THEN
;	2787					SIGNAL(PAT$_NUMTRUNC);
;	2788			END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-3
; Digital Equipment Corporation
;
;	2789	
;	2790		PAT$FILL_BUF(PAT$GL_TEMP_BUF, .OLD_VALUE_PTR, .VAL_SIZ);
;	2791		HOLE_SIZ = .HOLE_SIZ + .VAL_SIZ;			! Add current size to cumulative
;	2792		PAT$OUT_MEM_LOC(.NEXT_LOC, OLD_TAB_STG, PAT$GL_OLD_ASD); ! Output old contents
;	2793		NEXT_LOC = .PAT$GL_NEXT_LOC;				! Point to next location
;	2794	
;	2795		!++
;	2796		! Check if this is the last old argument.
;	2797		!--
;	2798		IF .LIST_ELEM_EXP2(.POINTER) EQL EXIT_TOKEN
;	2799		THEN
;	2800			EXITLOOP;
;	2801		END;
;	2802	
;	2803	!++
;	2804	! Resolve any forward references in symbolic instruction operands.
;	2805	!--
;	2806	PAT$RESOLVE_INS(PAT$GL_TEMP_BUF);
;	2807	
;	2808	!++
;	2809	! Now get the actual values in the locations and
;	2810	! check that they equal the specified values.
;	2811	!--
;	2812	BYTE_COUNT = 0;
;	2813	WHILE (.BYTE_COUNT LSS .HOLE_SIZ)
;	2814	DO
;	2815		BEGIN
;	2816		IF ((BUF_SIZE = .HOLE_SIZ - .BYTE_COUNT) GTR TTY_OUT_WIDTH)
;	2817		THEN
;	2818			BUF_SIZE = TTY_OUT_WIDTH;
;	2819		PAT$GET_VALUE(.LIST_ELEM_EXP1(.PAT$GL_HEAD_LST)+.BYTE_COUNT,
;	2820				 .BUF_SIZE, OLD_CONTENTS);
;	2821		IF CH$NEQ(.BUF_SIZE, .PAT$GL_TEMP_BUF[DSC$A_POINTER]+.BYTE_COUNT,
;	2822				 .BUF_SIZE, OLD_CONTENTS)
;	2823		THEN
;	2824			SIGNAL(PAT$_DIFVAL+MSG$K_WARN);
;	2825		BYTE_COUNT = .BYTE_COUNT + .BUF_SIZE;
;	2826		END;
;	2827	
;	2828	!++
;	2829	! Release the storage holding the old instructions.
;	2830	!--
;	2831	PAT$FREERELEASE(.PAT$GL_TEMP_BUF[DSC$A_POINTER], (.PAT$GL_TEMP_BUF[DSC$W_LENGTH]+3)/4);
;	2832	PAT$GL_TEMP_BUF[DSC$W_LENGTH] = 0;
;	2833	PAT$GL_TEMP_BUF[DSC$A_POINTER] = 0;
;	2834	!++
;	2835	! If this was a VERIFY command, we are all done.  Return for next command.
;	2836	!--
;	2837	IF .PAT$GL_CONTEXT[VERIFY_BIT]
;	2838	THEN
;	2839		RETURN;
;	2840	
;	2841	!++
;	2842	! Check if old instruction should be moved to patch area, i.e., is this an
;	2843	! INSERT command.  Remember the number of bytes of old instructions moved

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-4
; Digital Equipment Corporation
;
;	2844	! in case there are forward referenced symbols to relocate in the new
;	2845	! instructions.
;	2846	!--
;	2847	IF .PAT$GL_CONTEXT [INSERT_BIT]
;	2848	THEN
;	2849		BEGIN
;	2850		PAT$FILL_BUF(PAT$GL_TEMP_BUF, INSTRUC_BUF[1], .INSTRUC_BUF[0]);
;	2851		OLD_INS_SIZ = .PAT$GL_TEMP_BUF[DSC$W_LENGTH];		! Remember # of bytes of old instructions moved
;	2852		END
;	2853	ELSE
;	2854		BEGIN
;	2855		OLD_INS_SIZ = 0;					! No old instructions moved
;	2856		NEXT_LOC = .UNMAPPED_LOC;				! Set next deposit location for REPLACE command
;	2857		END;
;	2858	
;	2859	!++
;	2860	! Now fit the replacement value/instruction into the location.
;	2861	!--
;	2862	IF (NEW_INS_PTR = .LIST_ELEM_FLINK(.POINTER)) EQLA 0				! If no replacement argument
;	2863	THEN								! then report error
;	2864		SIGNAL(PAT$_INVCMD);
;	2865	PAT$GL_SYMTBPTR = .PAT$GL_NEWLABLS;				! Use the new contents label table
;	2866	
;	2867	!++
;	2868	! Now build a buffer containing the new values to be deposited.  The deposits
;	2869	! are not done directly to memory in case part of the command is invalid.
;	2870	!--
;	2871	WHILE (POINTER = .LIST_ELEM_FLINK(.POINTER)) NEQA 0		! Point to next argument
;	2872	DO
;	2873		BEGIN
;	2874		IF .PAT$GB_MOD_PTR [MODE_INSTRUC]			! Test for instruction or data replacement
;	2875		THEN
;	2876			BEGIN
;	2877			!++
;	2878			! Now encode the replacement instruction.
;	2879			!--
;	2880			FILL_CHAR = NOP_INSTR;				! Set the fill character
;	2881			IF NOT PAT$INS_ENCODE(.LIST_ELEM_EXP1(.POINTER), INSTRUC_BUF,
;	2882					 .NEXT_LOC, PAT$GL_NEW_ASD, PAT$GL_TEMP_BUF)
;	2883			THEN
;	2884				SIGNAL(PAT$_NOENCODE, 1, .LIST_ELEM_EXP1(.POINTER));
;	2885			PAT$FILL_BUF(PAT$GL_TEMP_BUF, INSTRUC_BUF[1], .INSTRUC_BUF[0]); ! Insert instruction into temporary buffer
;	2886			NEXT_LOC = .NEXT_LOC + .INSTRUC_BUF[0];
;	2887			END
;	2888		ELSE
;	2889			!++
;	2890			! The replacement is for a value.  Therefore it is on the parse
;	2891			! stack.  Check for a truncation error.  Then set the fill
;	2892			! character and write the value to the temporary buffer.
;	2893			!--
;	2894			BEGIN
;	2895			IF .LIST_ELEM_EXP1(.POINTER) LSS 0
;	2896			THEN
;	2897				BEGIN
;	2898				IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 1> NEQ .LIST_ELEM_EXP1(.POINTER)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-5
; Digital Equipment Corporation
;
;	2899				THEN
;	2900					SIGNAL(PAT$_NUMTRUNC);
;	2901				END
;	2902			ELSE
;	2903				IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 0> NEQ .LIST_ELEM_EXP1(.POINTER)
;	2904				THEN
;	2905					SIGNAL(PAT$_NUMTRUNC);
;	2906			FILL_CHAR = ZERO_BYTE;				! Set the fill character
;	2907			PAT$FILL_BUF(PAT$GL_TEMP_BUF, LIST_ELEM_EXP1(.POINTER), .VAL_SIZ);
;	2908			NEXT_LOC = .NEXT_LOC + .VAL_SIZ;
;	2909			END;
;	2910		END;
;	2911	!++
;	2912	! Resolve the forward references in symbolic instruction operands.
;	2913	!--
;	2914	PAT$RESOLVE_INS(PAT$GL_TEMP_BUF);
;	2915	
;	2916	!++
;	2917	! Now check the replacement size against old instruction size.
;	2918	!--
;	2919	IF .PAT$GL_TEMP_BUF[DSC$W_LENGTH] LSS .HOLE_SIZ			! Make temporary buffer at least as large as hole
;	2920	THEN
;	2921		BEGIN
;	2922		LOCAL
;	2923			TEMP_PTR;					! Temporary pointer to temporary buffer
;	2924	
;	2925		TEMP_PTR = PAT$FREEZ((.HOLE_SIZ + A_LONGWORD - 1)/A_LONGWORD);
;	2926		CH$COPY(.PAT$GL_TEMP_BUF[DSC$W_LENGTH], .PAT$GL_TEMP_BUF[DSC$A_POINTER],
;	2927			.FILL_CHAR, .HOLE_SIZ, .TEMP_PTR);
;	2928		PAT$FREERELEASE(.PAT$GL_TEMP_BUF[DSC$A_POINTER], (.PAT$GL_TEMP_BUF[DSC$W_LENGTH] +3)/4);
;	2929		PAT$GL_TEMP_BUF[DSC$A_POINTER] = CH$PTR(.TEMP_PTR, 0);
;	2930		PAT$GL_TEMP_BUF[DSC$W_LENGTH] = .HOLE_SIZ;
;	2931		END;
;	2932	
;	2933	!++
;	2934	! Now write the temporary buffer over the mapped input image.
;	2935	!--
;	2936	IF .PAT$GL_TEMP_BUF[DSC$W_LENGTH] EQL .HOLE_SIZ
;	2937	THEN
;	2938		BEGIN
;	2939		!++
;	2940		! Replacement data fits.  Write it to memory and output new contents.
;	2941		!--
;	2942		PAT$WRITE_MEM(.UNMAPPED_LOC, .PAT$GL_TEMP_BUF[DSC$A_POINTER], .PAT$GL_TEMP_BUF[DSC$W_LENGTH]);
;	2943		NEXT_LOC = .UNMAPPED_LOC + .HOLE_SIZ;
;	2944		PAT$GL_NEXT_LOC = .UNMAPPED_LOC;
;	2945		WHILE .PAT$GL_NEXT_LOC LSSA .NEXT_LOC			! Output new contents
;	2946		DO
;	2947			PAT$OUT_MEM_LOC(.PAT$GL_NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD);
;	2948		END
;	2949	ELSE
;	2950		BEGIN
;	2951		!++
;	2952		! The replacement instruction is too large.  It
;	2953		! must be relocated to the patch area.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-6
; Digital Equipment Corporation
;
;	2954		!--
;	2955		IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
;	2956		THEN
;	2957			RELOCAT_INS(.UNMAPPED_LOC, .HOLE_SIZ, .OLD_INS_SIZ, .NEW_INS_PTR)
;	2958		ELSE
;	2959			SIGNAL(PAT$_REPLACEERR);			! Internal error if patch area needed for data replacements
;	2960		END;
;	2961	!++
;	2962	! Now add all the new labels to the user-defined symbol table.
;	2963	!--
;	2964	PAT$ADD_LABELS(PAT$GL_OLDLABLS);
;	2965	PAT$ADD_LABELS(PAT$GL_NEWLABLS);
;	2966	PAT$ADD_LABELS(PAT$GL_RLCLABLS);
;	2967	RETURN;
;	2968	END;								! End of PAT$REPLACE_CMD





					 0FFC 00302 	    .ENTRY  PAT$REPLACE_CMD, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 2624
		         5E	FF2C   CE  9E 00304 	    MOVAB   -212(SP), SP					      ;
		         55 00000000G  EF  D0 00309 	    MOVL    PAT$GL_HEAD_LST, POINTER				      ; 2724
				       65  D5 00310 	    TSTL    (POINTER)						      ; 2725
				       04  13 00312 	    BEQL    1$							      ;
				       55  D5 00314 	    TSTL    POINTER						      ;
				       0D  12 00316 	    BNEQ    2$							      ;
			    006D80C2   8F  DD 00318 1$:     PUSHL   #7176386						      ; 2727
	      00000000G  00	       01  FB 0031E 	    CALLS   #1, LIB$SIGNAL					      ;
	      00000000G  EF	       01  88 00325 2$:     BISB2   #1, PAT$GL_CONTEXT+1				      ; 2732
		         5A	  04   A5  D0 0032C 	    MOVL    4(POINTER), UNMAPPED_LOC				      ; 2733
		         59	  04   A5  D0 00330 	    MOVL    4(POINTER), NEXT_LOC				      ; 2734
				       58  D4 00334 	    CLRL    HOLE_SIZ						      ; 2735
	      00000000G  EF 00000000G  EF  D0 00336 	    MOVL    PAT$GL_OLDLABLS, PAT$GL_SYMTBPTR			      ; 2736
		         55	       65  D0 00341 3$:     MOVL    (POINTER), POINTER					      ; 2744
		         52	  04   A5  9E 00344 	    MOVAB   4(POINTER), R2					      ; 2760
		         50 00000000G  EF  D0 00348 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2750
		         38	  03   A0  E9 0034F 	    BLBC    3(R0), 5$						      ;
			    00000000G  EF  9F 00353 	    PUSHAB  PAT$GL_TEMP_BUF					      ; 2760
			    00000000G  EF  9F 00359 	    PUSHAB  PAT$GL_OLD_ASD					      ;
				       59  DD 0035F 	    PUSHL   NEXT_LOC						      ;
				  B0   AD  9F 00361 	    PUSHAB  INSTRUC_BUF						      ;
				       62  DD 00364 	    PUSHL   (R2)						      ;
	      00000000G  EF	       05  FB 00366 	    CALLS   #5, PAT$INS_ENCODE					      ;
		         11	       50  E8 0036D 	    BLBS    R0, 4$						      ;
				       62  DD 00370 	    PUSHL   (R2)						      ; 2763
				       01  DD 00372 	    PUSHL   #1							      ;
			    006D80F2   8F  DD 00374 	    PUSHL   #7176434						      ;
	      00000000G  00	       03  FB 0037A 	    CALLS   #3, LIB$SIGNAL					      ;
		         53	  B1   AD  9E 00381 4$:     MOVAB   INSTRUC_BUF+1, OLD_VALUE_PTR			      ; 2764
		         57	  B0   AD  9A 00385 	    MOVZBL  INSTRUC_BUF, VAL_SIZ				      ; 2765
				       2D  11 00389 	    BRB     8$							      ; 2750
		         53	       52  D0 0038B 5$:     MOVL    R2, OLD_VALUE_PTR					      ; 2775
		         57	  01   A0  9A 0038E 	    MOVZBL  1(R0), VAL_SIZ					      ; 2776
	   50	         57	       03  78 00392 	    ASHL    #3, VAL_SIZ, R0					      ; 2780

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-7
; Digital Equipment Corporation
;
				       62  D5 00396 	    TSTL    (R2)						      ; 2777
				       07  18 00398 	    BGEQ    6$							      ;
	   62	         50	       00  EE 0039A 	    EXTV    #0, R0, (R2), R1					      ; 2780
				       51     0039E									      ;
				       05  11 0039F 	    BRB     7$							      ;
	   62	         50	       00  EF 003A1 6$:     EXTZV   #0, R0, (R2), R1					      ; 2785
				       51     003A5									      ;
		         62	       51  D1 003A6 7$:     CMPL    R1, (R2)						      ;
				       0D  13 003A9 	    BEQL    8$							      ;
			    006D8023   8F  DD 003AB 	    PUSHL   #7176227						      ; 2787
	      00000000G  00	       01  FB 003B1 	    CALLS   #1, LIB$SIGNAL					      ;
				0088   8F  BB 003B8 8$:     PUSHR   #^M<R3,R7>						      ; 2790
			    00000000G  EF  9F 003BC 	    PUSHAB  PAT$GL_TEMP_BUF					      ;
	      00000000V  EF	       03  FB 003C2 	    CALLS   #3, PAT$FILL_BUF					      ;
		         58	       57  C0 003C9 	    ADDL2   VAL_SIZ, HOLE_SIZ					      ; 2791
			    00000000G  EF  9F 003CC 	    PUSHAB  PAT$GL_OLD_ASD					      ; 2792
			    00000000'  EF  9F 003D2 	    PUSHAB  OLD_TAB_STG						      ; 2624
				       59  DD 003D8 	    PUSHL   NEXT_LOC						      ; 2792
	      00000000V  EF	       03  FB 003DA 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
		         59 00000000G  EF  D0 003E1 	    MOVL    PAT$GL_NEXT_LOC, NEXT_LOC				      ; 2793
		         0A	  08   A5  D1 003E8 	    CMPL    8(POINTER), #10					      ; 2798
				       03  13 003EC 	    BEQL    9$							      ;
				     FF50  31 003EE 	    BRW     3$							      ;
			    00000000G  EF  9F 003F1 9$:     PUSHAB  PAT$GL_TEMP_BUF					      ; 2806
	      00000000G  EF	       01  FB 003F7 	    CALLS   #1, PAT$RESOLVE_INS					      ;
				       54  D4 003FE 	    CLRL    BYTE_COUNT						      ; 2812
		         58	       54  D1 00400 10$:    CMPL    BYTE_COUNT, HOLE_SIZ				      ; 2813
				       44  18 00403 	    BGEQ    13$							      ;
	   56	         58	       54  C3 00405 	    SUBL3   BYTE_COUNT, HOLE_SIZ, BUF_SIZE			      ; 2816
	      00000084   8F	       56  D1 00409 	    CMPL    BUF_SIZE, #132					      ;
				       04  15 00410 	    BLEQ    11$							      ;
		         56	  84   8F  9A 00412 	    MOVZBL  #132, BUF_SIZE					      ; 2818
				4040   8F  BB 00416 11$:    PUSHR   #^M<R6,SP>						      ; 2819
		         50 00000000G  EF  D0 0041A 	    MOVL    PAT$GL_HEAD_LST, R0					      ;
				  04 B044  9F 00421 	    PUSHAB  @4(R0)[BYTE_COUNT]					      ;
	      00000000G  EF	       03  FB 00425 	    CALLS   #3, PAT$GET_VALUE					      ;
	   6E 00000000GFF44	       56  29 0042C 	    CMPC3   BUF_SIZE, @PAT$GL_TEMP_BUF+4[BYTE_COUNT], OLD_CONTENTS    ; 2821
				       0D  13 00435 	    BEQL    12$							      ;
			    006D82C0   8F  DD 00437 	    PUSHL   #7176896						      ; 2824
	      00000000G  00	       01  FB 0043D 	    CALLS   #1, LIB$SIGNAL					      ;
		         54	       56  C0 00444 12$:    ADDL2   BUF_SIZE, BYTE_COUNT				      ; 2825
				       B7  11 00447 	    BRB     10$							      ; 2813
		         50 00000000G  EF  3C 00449 13$:    MOVZWL  PAT$GL_TEMP_BUF, R0					      ; 2831
		         50	       03  C0 00450 	    ADDL2   #3, R0						      ;
	   7E	         50	       04  C7 00453 	    DIVL3   #4, R0, -(SP)					      ;
			    00000000G  EF  DD 00457 	    PUSHL   PAT$GL_TEMP_BUF+4					      ;
	      00000000G  EF	       02  FB 0045D 	    CALLS   #2, PAT$FREERELEASE					      ;
			    00000000G  EF  B4 00464 	    CLRW    PAT$GL_TEMP_BUF					      ; 2832
			    00000000G  EF  D4 0046A 	    CLRL    PAT$GL_TEMP_BUF+4					      ; 2833
	   01 00000000G  EF	       05  E1 00470 	    BBC     #5, PAT$GL_CONTEXT+2, 14$				      ; 2837
					   04 00478 	    RET     							      ;
	   1D 00000000G  EF	       07  E1 00479 14$:    BBC     #7, PAT$GL_CONTEXT+2, 15$				      ; 2847
		         7E	  B0   AD  9A 00481 	    MOVZBL  INSTRUC_BUF, -(SP)					      ; 2850
				  B1   AD  9F 00485 	    PUSHAB  INSTRUC_BUF+1					      ;
			    00000000G  EF  9F 00488 	    PUSHAB  PAT$GL_TEMP_BUF					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-8
; Digital Equipment Corporation
;
	      00000000V  EF	       03  FB 0048E 	    CALLS   #3, PAT$FILL_BUF					      ;
		         5B 00000000G  EF  3C 00495 	    MOVZWL  PAT$GL_TEMP_BUF, OLD_INS_SIZ			      ; 2851
				       05  11 0049C 	    BRB     16$							      ; 2847
				       5B  D4 0049E 15$:    CLRL    OLD_INS_SIZ						      ; 2855
		         59	       5A  D0 004A0 	    MOVL    UNMAPPED_LOC, NEXT_LOC				      ; 2856
		         56	       65  D0 004A3 16$:    MOVL    (POINTER), NEW_INS_PTR				      ; 2862
				       0D  12 004A6 	    BNEQ    17$							      ;
			    006D80C2   8F  DD 004A8 	    PUSHL   #7176386						      ; 2864
	      00000000G  00	       01  FB 004AE 	    CALLS   #1, LIB$SIGNAL					      ;
	      00000000G  EF 00000000G  EF  D0 004B5 17$:    MOVL    PAT$GL_NEWLABLS, PAT$GL_SYMTBPTR			      ; 2865
		         55	       65  D0 004C0 18$:    MOVL    (POINTER), POINTER					      ; 2871
				       03  12 004C3 	    BNEQ    19$							      ;
				     009B  31 004C5 	    BRW     26$							      ;
		         52	  04   A5  9E 004C8 19$:    MOVAB   4(POINTER), R2					      ; 2881
		         50 00000000G  EF  D0 004CC 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 2874
		         4E	  03   A0  E9 004D3 	    BLBC    3(R0), 22$						      ;
		         53	       01  90 004D7 	    MOVB    #1, FILL_CHAR					      ; 2880
			    00000000G  EF  9F 004DA 	    PUSHAB  PAT$GL_TEMP_BUF					      ; 2881
			    00000000G  EF  9F 004E0 	    PUSHAB  PAT$GL_NEW_ASD					      ;
				       59  DD 004E6 	    PUSHL   NEXT_LOC						      ;
				  B0   AD  9F 004E8 	    PUSHAB  INSTRUC_BUF						      ;
				       62  DD 004EB 	    PUSHL   (R2)						      ;
	      00000000G  EF	       05  FB 004ED 	    CALLS   #5, PAT$INS_ENCODE					      ;
		         11	       50  E8 004F4 	    BLBS    R0, 20$						      ;
				       62  DD 004F7 	    PUSHL   (R2)						      ; 2884
				       01  DD 004F9 	    PUSHL   #1							      ;
			    006D80F2   8F  DD 004FB 	    PUSHL   #7176434						      ;
	      00000000G  00	       03  FB 00501 	    CALLS   #3, LIB$SIGNAL					      ;
		         7E	  B0   AD  9A 00508 20$:    MOVZBL  INSTRUC_BUF, -(SP)					      ; 2885
				  B1   AD  9F 0050C 	    PUSHAB  INSTRUC_BUF+1					      ;
			    00000000G  EF  9F 0050F 	    PUSHAB  PAT$GL_TEMP_BUF					      ;
	      00000000V  EF	       03  FB 00515 	    CALLS   #3, PAT$FILL_BUF					      ;
		         50	  B0   AD  9A 0051C 	    MOVZBL  INSTRUC_BUF, R0					      ; 2886
		         59	       50  C0 00520 	    ADDL2   R0, NEXT_LOC					      ;
				       9B  11 00523 21$:    BRB     18$							      ; 2874
	   50	         57	       03  78 00525 22$:    ASHL    #3, VAL_SIZ, R0					      ; 2898
				       62  D5 00529 	    TSTL    (R2)						      ; 2895
				       07  18 0052B 	    BGEQ    23$							      ;
	   62	         50	       00  EE 0052D 	    EXTV    #0, R0, (R2), R1					      ; 2898
				       51     00531									      ;
				       05  11 00532 	    BRB     24$							      ;
	   62	         50	       00  EF 00534 23$:    EXTZV   #0, R0, (R2), R1					      ; 2903
				       51     00538									      ;
		         62	       51  D1 00539 24$:    CMPL    R1, (R2)						      ;
				       0D  13 0053C 	    BEQL    25$							      ;
			    006D8023   8F  DD 0053E 	    PUSHL   #7176227						      ; 2905
	      00000000G  00	       01  FB 00544 	    CALLS   #1, LIB$SIGNAL					      ;
				       53  94 0054B 25$:    CLRB    FILL_CHAR						      ; 2906
				0084   8F  BB 0054D 	    PUSHR   #^M<R2,R7>						      ; 2907
			    00000000G  EF  9F 00551 	    PUSHAB  PAT$GL_TEMP_BUF					      ;
	      00000000V  EF	       03  FB 00557 	    CALLS   #3, PAT$FILL_BUF					      ;
		         59	       57  C0 0055E 	    ADDL2   VAL_SIZ, NEXT_LOC					      ; 2908
				       C0  11 00561 	    BRB     21$							      ; 2871
			    00000000G  EF  9F 00563 26$:    PUSHAB  PAT$GL_TEMP_BUF					      ; 2914
	      00000000G  EF	       01  FB 00569 	    CALLS   #1, PAT$RESOLVE_INS					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 6-9
; Digital Equipment Corporation
;
00000000G  EF	         10	       00  ED 00570 	    CMPZV   #0, #16, PAT$GL_TEMP_BUF, HOLE_SIZ			      ; 2919
				       58     00578									      ;
				       49  18 00579 	    BGEQ    27$							      ;
	   50	         58	       03  C1 0057B 	    ADDL3   #3, HOLE_SIZ, R0					      ; 2925
	   7E	         50	       04  C7 0057F 	    DIVL3   #4, R0, -(SP)					      ;
	      00000000G  EF	       01  FB 00583 	    CALLS   #1, PAT$FREEZ					      ;
		         57	       50  D0 0058A 	    MOVL    R0, TEMP_PTR					      ;
	   53 00000000G  FF 00000000G  EF  2C 0058D 	    MOVC5   PAT$GL_TEMP_BUF, @PAT$GL_TEMP_BUF+4, FILL_CHAR, -	      ; 2926
		         67	       58     00599		    HOLE_SIZ, (TEMP_PTR)				      ;
		         50 00000000G  EF  3C 0059B 	    MOVZWL  PAT$GL_TEMP_BUF, R0					      ; 2928
		         50	       03  C0 005A2 	    ADDL2   #3, R0						      ;
	   7E	         50	       04  C7 005A5 	    DIVL3   #4, R0, -(SP)					      ;
			    00000000G  EF  DD 005A9 	    PUSHL   PAT$GL_TEMP_BUF+4					      ;
	      00000000G  EF	       02  FB 005AF 	    CALLS   #2, PAT$FREERELEASE					      ;
	      00000000G  EF	       57  D0 005B6 	    MOVL    TEMP_PTR, PAT$GL_TEMP_BUF+4				      ; 2929
	      00000000G  EF	       58  B0 005BD 	    MOVW    HOLE_SIZ, PAT$GL_TEMP_BUF				      ; 2930
00000000G  EF	         10	       00  ED 005C4 27$:    CMPZV   #0, #16, PAT$GL_TEMP_BUF, HOLE_SIZ			      ; 2936
				       58     005CC									      ;
				       45  12 005CD 	    BNEQ    29$							      ;
		         7E 00000000G  EF  3C 005CF 	    MOVZWL  PAT$GL_TEMP_BUF, -(SP)				      ; 2942
			    00000000G  EF  DD 005D6 	    PUSHL   PAT$GL_TEMP_BUF+4					      ;
				       5A  DD 005DC 	    PUSHL   UNMAPPED_LOC					      ;
	      00000000G  EF	       03  FB 005DE 	    CALLS   #3, PAT$WRITE_MEM					      ;
	   59	         5A	       58  C1 005E5 	    ADDL3   HOLE_SIZ, UNMAPPED_LOC, NEXT_LOC			      ; 2943
	      00000000G  EF	       5A  D0 005E9 	    MOVL    UNMAPPED_LOC, PAT$GL_NEXT_LOC			      ; 2944
		         59 00000000G  EF  D1 005F0 28$:    CMPL    PAT$GL_NEXT_LOC, NEXT_LOC				      ; 2945
				       44  1E 005F7 	    BGEQU   31$							      ;
			    00000000G  EF  9F 005F9 	    PUSHAB  PAT$GL_NEW_ASD					      ; 2947
			    00000000'  EF  9F 005FF 	    PUSHAB  NEW_TAB_STG						      ; 2624
			    00000000G  EF  DD 00605 	    PUSHL   PAT$GL_NEXT_LOC					      ; 2947
	      00000000V  EF	       03  FB 0060B 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
				       DC  11 00612 	    BRB     28$							      ; 2945
		         50 00000000G  EF  D0 00614 29$:    MOVL    PAT$GB_MOD_PTR, R0					      ; 2955
		         11	  03   A0  E9 0061B 	    BLBC    3(R0), 30$						      ;
				       56  DD 0061F 	    PUSHL   NEW_INS_PTR						      ; 2957
				0900   8F  BB 00621 	    PUSHR   #^M<R8,R11>						      ;
				       5A  DD 00625 	    PUSHL   UNMAPPED_LOC					      ;
	      00000000V  EF	       04  FB 00627 	    CALLS   #4, RELOCAT_INS					      ;
				       0D  11 0062E 	    BRB     31$							      ; 2955
			    006D8142   8F  DD 00630 30$:    PUSHL   #7176514						      ; 2959
	      00000000G  00	       01  FB 00636 	    CALLS   #1, LIB$SIGNAL					      ;
			    00000000G  EF  9F 0063D 31$:    PUSHAB  PAT$GL_OLDLABLS					      ; 2964
	      00000000G  EF	       01  FB 00643 	    CALLS   #1, PAT$ADD_LABELS					      ;
			    00000000G  EF  9F 0064A 	    PUSHAB  PAT$GL_NEWLABLS					      ; 2965
	      00000000G  EF	       01  FB 00650 	    CALLS   #1, PAT$ADD_LABELS					      ;
			    00000000G  EF  9F 00657 	    PUSHAB  PAT$GL_RLCLABLS					      ; 2966
	      00000000G  EF	       01  FB 0065D 	    CALLS   #1, PAT$ADD_LABELS					      ;
					   04 00664 32$:    RET     							      ; 2624

; Routine Size:  867 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7
; Digital Equipment Corporation
;
;	2969	ROUTINE RELOCAT_INS (OLD_LOC, HOLE_SIZE, OLD_INS_SIZ, ASC_INS_PTR) : NOVALUE =
;	2970	
;	2971	!++
;	2972	! FUNCTIONAL DESCRIPTION:
;	2973	!
;	2974	!	This routine relocates an instruction from an old address to the patch
;	2975	!	area.  It then moves in any new instructions, specified as an argument
;	2976	!	list for a patch command.  A branch or jump instruction is then put
;	2977	!	into the old address.  If there is not enough room left by the
;	2978	!	removal of the instruction, then more instructions are moved to the
;	2979	!	patch area until the branch instruction iwll fit.  Lastly, a return
;	2980	!	branch instruction is placed in the patch area to return execution
;	2981	!	to the next sequential instruction past the old address.
;	2982	!
;	2983	!	Any new instructions to be inserted are in a command argument
;	2984	!	list, created by the parser.  Each argument entry is made up of
;	2985	!	three longwords. The first is a forward link to the next entry.
;	2986	!	The second longword contains the address of a counted byte stream
;	2987	!	that is to be translated into a binary instruction which is
;	2988	!	to be inserted into the patch area.  The third longword is unused.
;	2989	!
;	2990	! CALLING SEQUENCE:
;	2991	!
;	2992	!	RELOCATE_CMD (OLD_LOCATION, NEW_INSTRUCTION_PTR)
;	2993	!
;	2994	! INPUTS:
;	2995	!
;	2996	!	OLD_LOC - Unmapped address of instruction to be moved
;	2997	!	HOLE_SIZE - Number of free bytes at OLD_LOC
;	2998	!	OLD_INS_SIZ - Number of bytes of old instruction preceding new instruction
;	2999	!	ASC_INS_PTR - Pointer to first new instruction on command argument list
;	3000	!
;	3001	! IMPLICIT INPUTS:
;	3002	!
;	3003	!	PAT$GL_TEMP_BUF - String descriptor for counted binary instructions
;	3004	!
;	3005	!	The head of the linked list, the current mode, and
;	3006	!	the current patch area descriptor.
;	3007	!
;	3008	! OUTPUTS:
;	3009	!
;	3010	!	none
;	3011	!
;	3012	! IMPLICIT OUTPUTS:
;	3013	!
;	3014	!	NONE
;	3015	!
;	3016	! ROUTINE VALUE:
;	3017	!
;	3018	!	novalue
;	3019	!
;	3020	! SIDE EFFECTS:
;	3021	!
;	3022	!	The patch area now contains the moved instruction and the new ones
;	3023	!	plus a branch instruction back to the inline code.  The old

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-1
; Digital Equipment Corporation
;
;	3024	!	instruction location contains a branch to the patch area.
;	3025	!	If a failure in a write or contents verification occurs,
;	3026	!	the routine returns immediately.
;	3027	!
;	3028	!--
;	3029	
;	3030	BEGIN
;	3031	
;	3032	LITERAL
;	3033		MAX_BYTE_DISP = 127,					! Maximum displacement for BRB
;	3034		MIN_BYTE_DISP = -128,					! Minimum displacement for BRB
;	3035		MAX_WORD_DISP = 32767,					! Maximum displacement for BRW
;	3036		MIN_WORD_DISP = -32768,					! Minimum displacement for BRW
;	3037		BRB_OPCODE = %X'11',					! Opcode for BRB
;	3038		BRW_OPCODE = %X'31',					! Opcode for BRW
;	3039		JMP_OPCODE = %X'17',					! Opcode for JMP
;	3040		BRB_INS_SIZ = 2,					! Size of BRB instruction
;	3041		BRW_INS_SIZ = 3,					! Size of BRW instruction
;	3042		JMP_INS_SIZ = 6,					! Size of JMP instruction
;	3043		PC_DEFERRED = %X'EF',					! PC deferred instruction mode
;	3044		NOP_INSTR = 1,						! Fill character for instruction
;	3045		MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction
;	3046	
;	3047	LOCAL
;	3048		SUCC_OLD_INS,						! Number of bytes of successive old instructions moved
;	3049		DECODED_INS,						! Pointer to ascii instruction
;	3050		NXT_ASC_INS,						! Pointer to next ascii instruction in argument list
;	3051		NEXT_PC,						! PC of next instruction to decode
;	3052		NEW_INS_PTR : REF VECTOR[,BYTE],			! Pointer to relocated instruction stream
;	3053		BR_DISPLACEMENT : SIGNED LONG,				! Displacement for branch instruction
;	3054		BR_INSTRUC : VECTOR[JMP_INS_SIZ+1,BYTE],		! Encoded counted string branch instruction
;	3055		NEW_LOC,						! Address in patch area for relocated instructions
;	3056		NEXT_LOC,						! Address of next instruction of inline code
;	3057		CUR_LOC,						! Address of current instruction to be moved
;	3058		LOCAL_BUF : VECTOR[MAX_INST_LEN, BYTE],			! Local buffer for binary instruction stream
;	3059		INSTRUC_BUF: VECTOR [MAX_INST_LEN, BYTE];		! Local buffer for ascic instructions
;	3060	
;	3061	!++
;	3062	! Enable instruction substitution.
;	3063	!--
;	3064	PAT$GL_CONTEXT[INST_SUBST] = TRUE;
;	3065	PAT$GL_SYMTBPTR = .PAT$GL_RLCLABLS;
;	3066	
;	3067	!++
;	3068	! Check that there is enough room in the patch area for the instructions
;	3069	! encoded in the temporary buffer, PAT$GL_TEMP_BUF.  This is the minimum size
;	3070	! that may be required.  Instruction substitution may enlarge this size.  This
;	3071	! will also insure that a patch area address is defined.
;	3072	!--
;	3073	IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
;	3074	THEN
;	3075		BEGIN
;	3076		IF (.PAT$GL_PATAREA[DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[DSC$A_POINTER])
;	3077		THEN
;	3078			BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-2
; Digital Equipment Corporation
;
;	3079			PAT$EXP_AREA((.PAT$GL_TEMP_BUF[DSC$W_LENGTH] + A_PAGE - 1)/A_PAGE);
;	3080			IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
;	3081			THEN
;	3082				SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
;	3083				 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
;	3084			END
;	3085		ELSE
;	3086			SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
;	3087			 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
;	3088		END;
;	3089	
;	3090	!++
;	3091	! Set pointer to relocation address.
;	3092	!--
;	3093	NEW_LOC = CH$PTR(.PAT$GL_PATAREA[DSC$A_POINTER], 0);
;	3094	
;	3095	!++
;	3096	! Now compute the branch displacement size.  Then build the binary code
;	3097	! based on the displacement.
;	3098	!--
;	3099	BR_DISPLACEMENT = .NEW_LOC - .OLD_LOC - BRB_INS_SIZ;
;	3100	IF (.BR_DISPLACEMENT LEQ MAX_BYTE_DISP) AND (.BR_DISPLACEMENT GEQ MIN_BYTE_DISP)
;	3101	THEN
;	3102		BEGIN
;	3103		BR_INSTRUC[0] = BRB_INS_SIZ;
;	3104		BR_INSTRUC[1] = BRB_OPCODE;
;	3105		CH$MOVE(.BR_INSTRUC[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(BR_INSTRUC[2],0));
;	3106		END
;	3107	ELSE
;	3108		IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)
;	3109		THEN
;	3110			BEGIN
;	3111			BR_INSTRUC[0] = BRW_INS_SIZ;
;	3112			BR_INSTRUC[1] = BRW_OPCODE;
;	3113			BR_DISPLACEMENT = .BR_DISPLACEMENT - (BRW_INS_SIZ - BRB_INS_SIZ);
;	3114			CH$MOVE(.BR_INSTRUC[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(BR_INSTRUC[2],0));
;	3115			END
;	3116		ELSE
;	3117			BEGIN
;	3118			BR_INSTRUC[0] = JMP_INS_SIZ;
;	3119			BR_INSTRUC[1] = JMP_OPCODE;
;	3120			BR_INSTRUC[2] = PC_DEFERRED;
;	3121			BR_DISPLACEMENT = .BR_DISPLACEMENT - (JMP_INS_SIZ - BRB_INS_SIZ);
;	3122			CH$MOVE(.BR_INSTRUC[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(BR_INSTRUC[3],0));
;	3123			END;
;	3124	
;	3125	!++
;	3126	! Now see if the branch instruction will fit in the hold left at the old
;	3127	! location.  If not, then move more instructions to the patch area until it
;	3128	! will fit.
;	3129	!--
;	3130	NEXT_LOC = .OLD_LOC + .HOLE_SIZE;				! Compute address of next inline instruction
;	3131	NEXT_PC = .OLD_LOC + .HOLE_SIZE;				! Compute address of next inline instruction
;	3132	SUCC_OLD_INS = .PAT$GL_TEMP_BUF[DSC$W_LENGTH];			! Remember where extra old instructions moved are
;	3133	WHILE .BR_INSTRUC[0] GTR .HOLE_SIZE

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-3
; Digital Equipment Corporation
;
;	3134	DO
;	3135		BEGIN
;	3136		!++
;	3137		! First decode the instruction at the next old location.  Then
;	3138		! re-encode it to get the binary stream.  Then insert it into
;	3139		! the temporary buffer.
;	3140		!--
;	3141		PAT$OUT_MEM_LOC(.NEXT_LOC, OLD_TAB_STG, PAT$GL_OLD_ASD);
;	3142		PAT$GL_BUF_SIZ = 0;
;	3143		PAT$CP_OUT_STR = CH$PTR(LOCAL_BUF[1]);
;	3144	
;	3145		!++
;	3146		! Because the instruction is actually in the code, the PC is the
;	3147		! same as the address of the byte stream.  PAT$INS_DECODE will update
;	3148		! the NEW_PC automatically.  To determine the length of the instruction
;	3149		! binary stream just decoded (for updating the HOLE_SIZE), NEXT_LOC must
;	3150		! be preserved.  Therefore, the return value from the routine is written
;	3151		! into NEW_PC not NEXT_LOC.  This will be the same value, unless the
;	3152		! routine failed.
;	3153		!--
;	3154		IF (NEXT_PC = PAT$INS_DECODE(.NEXT_LOC, 0, NEXT_PC, PAT$GL_OLD_ASD)) EQL 0
;	3155		THEN
;	3156			SIGNAL(PAT$_NODECODE);
;	3157		LOCAL_BUF[0] = .PAT$GL_BUF_SIZ;
;	3158		NEW_INS_PTR = CH$PTR(INSTRUC_BUF, 0);
;	3159		IF NOT PAT$INS_ENCODE(LOCAL_BUF, INSTRUC_BUF,
;	3160			 .OLD_LOC + .PAT$GL_TEMP_BUF[DSC$W_LENGTH], PAT$GL_NEW_ASD, PAT$GL_TEMP_BUF)
;	3161		THEN
;	3162			IF (.PAT$GB_SUBST_IN[0] NEQ 0)
;	3163			THEN
;	3164				NEW_INS_PTR = CH$PTR(PAT$GB_SUBST_IN, 0)
;	3165			ELSE
;	3166				SIGNAL(PAT$_NOENCODE, 1, LOCAL_BUF);
;	3167		PAT$FILL_BUF(PAT$GL_TEMP_BUF, NEW_INS_PTR[1], .NEW_INS_PTR[0]);
;	3168		HOLE_SIZE = .HOLE_SIZE + .NEXT_PC - .NEXT_LOC;
;	3169		NEXT_LOC = .NEXT_PC;
;	3170		END;
;	3171	
;	3172	!++
;	3173	! Decode the instructions in the temporary buffer and re-encode them at the
;	3174	! patch area address.  This will alter the addresses within the instructions.
;	3175	!--
;	3176	CUR_LOC = .PAT$GL_TEMP_BUF[DSC$A_POINTER];
;	3177	NEXT_PC = .OLD_LOC;
;	3178	NXT_ASC_INS = .ASC_INS_PTR;					! Get pointer to next new instruction argument
;	3179	WHILE .CUR_LOC LSSA (.PAT$GL_TEMP_BUF[DSC$A_POINTER] + .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
;	3180	DO
;	3181		BEGIN
;	3182		PAT$GL_BUF_SIZ = 0;
;	3183		PAT$CP_OUT_STR = CH$PTR(LOCAL_BUF[1]);
;	3184		IF (.CUR_LOC GEQA .PAT$GL_TEMP_BUF[DSC$A_POINTER] + .OLD_INS_SIZ) AND
;	3185		   (.CUR_LOC LSSA .PAT$GL_TEMP_BUF[DSC$A_POINTER] + .SUCC_OLD_INS)
;	3186		THEN
;	3187			BEGIN
;	3188			!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-4
; Digital Equipment Corporation
;
;	3189			! Take the new instructions out of the argument list in
;	3190			! case there are any labels which will be relocated.
;	3191			! This is only done for new instructions being deposited.
;	3192			! The old instructions being relocated are decoded and re-encoded.
;	3193			!--
;	3194			DECODED_INS = .LIST_ELEM_EXP1(.NXT_ASC_INS);
;	3195			NXT_ASC_INS = .LIST_ELEM_FLINK(.NXT_ASC_INS);
;	3196			PAT$GL_SYMTBPTR = .PAT$GL_RLCLABLS;		! Use reolcated label table
;	3197			END
;	3198		ELSE
;	3199			BEGIN
;	3200			!++
;	3201			! The instruction is an old instruction.  Therefore use the
;	3202			! old label table and encode it from the decoded instruction.
;	3203			!--
;	3204			DECODED_INS = LOCAL_BUF;			! Point to ascii instruction
;	3205			PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;		! Assume this is an old instruction
;	3206			END;
;	3207		IF (CUR_LOC = PAT$INS_DECODE(.CUR_LOC, 0, NEXT_PC, PAT$GL_NEW_ASD)) EQL 0
;	3208		THEN
;	3209			SIGNAL(PAT$_NODECODE);
;	3210		LOCAL_BUF[0] = .PAT$GL_BUF_SIZ;
;	3211		NEW_INS_PTR = CH$PTR(INSTRUC_BUF, 0);			! Set pointer to counted stream buffer
;	3212		IF NOT PAT$INS_ENCODE(.DECODED_INS, INSTRUC_BUF,
;	3213			 .NEW_LOC + .PAT$GL_RLOC_BUF[DSC$W_LENGTH], PAT$GL_NEW_ASD, PAT$GL_RLOC_BUF)
;	3214		THEN
;	3215			IF (.PAT$GB_SUBST_IN[0] NEQ 0)
;	3216			THEN
;	3217				NEW_INS_PTR = CH$PTR(PAT$GB_SUBST_IN, 0)
;	3218			ELSE
;	3219				SIGNAL(PAT$_NOENCODE, 1, LOCAL_BUF);
;	3220		PAT$FILL_BUF(PAT$GL_RLOC_BUF, NEW_INS_PTR[1], .NEW_INS_PTR[0]);
;	3221		END;
;	3222	PAT$GL_SYMTBPTR = .PAT$GL_RLCLABLS;				! Set relocated labels as default (old always gets searched)
;	3223	PAT$RESOLVE_INS(PAT$GL_RLOC_BUF);
;	3224	
;	3225	!++
;	3226	! Now a return branch instruction must be placed in the relocation buffer.
;	3227	! Compute the branch displacement size.  Then build the binary code based on
;	3228	! the displacement.
;	3229	!--
;	3230	BR_DISPLACEMENT = .NEXT_LOC - (.PAT$GL_PATAREA[DSC$A_POINTER] + 
;	3231				.PAT$GL_RLOC_BUF[DSC$W_LENGTH]) - BRB_INS_SIZ;
;	3232	IF (.BR_DISPLACEMENT LEQ MAX_BYTE_DISP) AND (.BR_DISPLACEMENT GEQ MIN_BYTE_DISP)
;	3233	THEN
;	3234		BEGIN
;	3235		INSTRUC_BUF[0] = BRB_INS_SIZ;
;	3236		INSTRUC_BUF[1] = BRB_OPCODE;
;	3237		CH$MOVE(.INSTRUC_BUF[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(INSTRUC_BUF[2],0));
;	3238		END
;	3239	ELSE
;	3240		IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)
;	3241		THEN
;	3242			BEGIN
;	3243			INSTRUC_BUF[0] = BRW_INS_SIZ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-5
; Digital Equipment Corporation
;
;	3244			INSTRUC_BUF[1] = BRW_OPCODE;
;	3245			BR_DISPLACEMENT = .BR_DISPLACEMENT - (BRW_INS_SIZ - BRB_INS_SIZ);
;	3246			CH$MOVE(.INSTRUC_BUF[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(INSTRUC_BUF[2],0));
;	3247			END
;	3248		ELSE
;	3249			BEGIN
;	3250			INSTRUC_BUF[0] = JMP_INS_SIZ;
;	3251			INSTRUC_BUF[1] = JMP_OPCODE;
;	3252			INSTRUC_BUF[2] = PC_DEFERRED;
;	3253			BR_DISPLACEMENT = .BR_DISPLACEMENT - (JMP_INS_SIZ - BRB_INS_SIZ);
;	3254			CH$MOVE(.INSTRUC_BUF[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(INSTRUC_BUF[3],0));
;	3255			END;
;	3256	PAT$FILL_BUF(PAT$GL_RLOC_BUF, INSTRUC_BUF[1], .INSTRUC_BUF[0]);
;	3257	
;	3258	!++
;	3259	! Now insert all new instructions into the patch area.
;	3260	!--
;	3261	IF (.PAT$GL_RLOC_BUF[DSC$W_LENGTH] GTR .PAT$GL_PATAREA[DSC$W_LENGTH])
;	3262	THEN
;	3263		BEGIN
;	3264		IF (.PAT$GL_PATAREA[DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[DSC$A_POINTER])
;	3265		THEN
;	3266			BEGIN
;	3267			PAT$EXP_AREA((.PAT$GL_RLOC_BUF[DSC$W_LENGTH] + A_PAGE - 1)/A_PAGE);
;	3268			IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_RLOC_BUF[DSC$W_LENGTH])
;	3269			THEN
;	3270				SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_RLOC_BUF[DSC$W_LENGTH],
;	3271				 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
;	3272			END
;	3273		ELSE
;	3274			SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_RLOC_BUF[DSC$W_LENGTH],
;	3275			 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
;	3276		END;
;	3277	PAT$WRITE_MEM(.PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_RLOC_BUF[DSC$A_POINTER], .PAT$GL_RLOC_BUF[DSC$W_LENGTH]);
;	3278	PAT$GL_PATAREA[DSC$W_LENGTH] = .PAT$GL_PATAREA[DSC$W_LENGTH] - .PAT$GL_RLOC_BUF[DSC$W_LENGTH];
;	3279	PAT$GL_PATAREA[DSC$A_POINTER] = .PAT$GL_PATAREA[DSC$A_POINTER] + .PAT$GL_RLOC_BUF[DSC$W_LENGTH];
;	3280	
;	3281	!++
;	3282	! Now there is room for the branch instruction at the old location hold.
;	3283	! Set up a buffer with the encoded branch instruction followed by NOP's to
;	3284	! insert there.  Then write it to the old location hole.
;	3285	!--
;	3286	IF (.HOLE_SIZE GTR .BR_INSTRUC[0])
;	3287	THEN
;	3288		BEGIN
;	3289		NEW_INS_PTR = PAT$FREEZ((.HOLE_SIZE + A_LONGWORD - 1)/A_LONGWORD);
;	3290		CH$COPY(.BR_INSTRUC[0], CH$PTR(BR_INSTRUC[1], 0), NOP_INSTR,
;	3291			 .HOLE_SIZE, CH$PTR(.NEW_INS_PTR, 0));
;	3292		PAT$WRITE_MEM(.OLD_LOC, CH$PTR(.NEW_INS_PTR, 0), .HOLE_SIZE);
;	3293		PAT$FREERELEASE(CH$PTR(.NEW_INS_PTR, 0), (.HOLE_SIZE + 3)/4);
;	3294		END
;	3295	ELSE
;	3296		PAT$WRITE_MEM(.OLD_LOC, CH$PTR(BR_INSTRUC[1], 0), .HOLE_SIZE);
;	3297	
;	3298	!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-6
; Digital Equipment Corporation
;
;	3299	! Now write out all the new instructions deposited.
;	3300	!--
;	3301	NEXT_LOC = .OLD_LOC;
;	3302	WHILE (.NEXT_LOC LSS .OLD_LOC+.HOLE_SIZE)
;	3303	DO
;	3304		BEGIN
;	3305		PAT$OUT_MEM_LOC(.NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD);
;	3306		NEXT_LOC = .PAT$GL_NEXT_LOC;
;	3307		END;
;	3308	NEXT_LOC = .NEW_LOC;
;	3309	WHILE (.NEXT_LOC LSS .PAT$GL_PATAREA[DSC$A_POINTER])
;	3310	DO
;	3311		BEGIN
;	3312		PAT$OUT_MEM_LOC(.NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD);
;	3313		NEXT_LOC = .PAT$GL_NEXT_LOC;
;	3314		END;
;	3315	
;	3316	RETURN;
;	3317	END;								! End of RELOCAT_INS





					 0FFC 00665 RELOCAT_INS:
							    .WORD   Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11		      ; 2969
		         5B 00000000G  EF  9E 00667 	    MOVAB   PAT$GL_RLOC_BUF, R11				      ;
		         5E	FF50   CE  9E 0066E 	    MOVAB   -176(SP), SP					      ;
	      00000000G  EF	       10  88 00673 	    BISB2   #16, PAT$GL_CONTEXT+2				      ; 3064
	      00000000G  EF 00000000G  EF  D0 0067A 	    MOVL    PAT$GL_RLCLABLS, PAT$GL_SYMTBPTR			      ; 3065
		         50 00000000G  EF  D0 00685 	    MOVL    PAT$GL_PATAREA, R0					      ; 3073
	      00000000G  EF	       60  B1 0068C 	    CMPW    (R0), PAT$GL_TEMP_BUF				      ;
				       55  1E 00693 	    BGEQU   2$							      ;
		         51 00000000G  EF  D0 00695 	    MOVL    PAT$GL_IHPPTR, R1					      ; 3076
		    04   A1	  04   A0  D1 0069C 	    CMPL    4(R0), 4(R1)					      ;
				       2B  12 006A1 	    BNEQ    1$							      ;
		         51 00000000G  EF  3C 006A3 	    MOVZWL  PAT$GL_TEMP_BUF, R1					      ; 3079
		         51	01FF   C1  9E 006AA 	    MOVAB   511(R1), R1						      ;
	   7E	         51 00000200   8F  C7 006AF 	    DIVL3   #512, R1, -(SP)					      ;
	      00000000G  EF	       01  FB 006B7 	    CALLS   #1, PAT$EXP_AREA					      ;
		         50 00000000G  EF  D0 006BE 	    MOVL    PAT$GL_PATAREA, R0					      ; 3080
	      00000000G  EF	       60  B1 006C5 	    CMPW    (R0), PAT$GL_TEMP_BUF				      ;
				       1C  1E 006CC 	    BGEQU   2$							      ;
		         7E	       60  3C 006CE 1$:     MOVZWL  (R0), -(SP)						      ; 3086
				  04   A0  DD 006D1 	    PUSHL   4(R0)						      ;
		         7E 00000000G  EF  3C 006D4 	    MOVZWL  PAT$GL_TEMP_BUF, -(SP)				      ;
				       03  DD 006DB 	    PUSHL   #3							      ;
			    006D80AA   8F  DD 006DD 	    PUSHL   #7176362						      ;
	      00000000G  00	       05  FB 006E3 	    CALLS   #5, LIB$SIGNAL					      ;
		         50 00000000G  EF  D0 006EA 2$:     MOVL    PAT$GL_PATAREA, R0					      ; 3093
		         5A	  04   A0  D0 006F1 	    MOVL    4(R0), NEW_LOC					      ;
		         59	  04   AC  D0 006F5 	    MOVL    OLD_LOC, R9						      ; 3099
	   50	         5A	       59  C3 006F9 	    SUBL3   R9, NEW_LOC, R0					      ;
      04   AE	         50	       02  C3 006FD 	    SUBL3   #2, R0, BR_DISPLACEMENT				      ;
		         50	  04   AE  D0 00702 	    MOVL    BR_DISPLACEMENT, R0					      ; 3100

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-7
; Digital Equipment Corporation
;
	      0000007F   8F	       50  D1 00706 	    CMPL    R0, #127						      ;
				       11  14 0070D 	    BGTR    3$							      ;
	      FFFFFF80   8F	       50  D1 0070F 	    CMPL    R0, #-128						      ;
				       08  19 00716 	    BLSS    3$							      ;
		    F8   AD	1102   8F  B0 00718 	    MOVW    #4354, BR_INSTRUC					      ; 3103
				       1B  11 0071E 	    BRB     4$							      ; 3105
	      00007FFF   8F	       50  D1 00720 3$:     CMPL    R0, #32767						      ; 3108
				       1E  14 00727 	    BGTR    5$							      ;
	      FFFF8000   8F	       50  D1 00729 	    CMPL    R0, #-32768						      ;
				       15  19 00730 	    BLSS    5$							      ;
		    F8   AD	3103   8F  B0 00732 	    MOVW    #12547, BR_INSTRUC					      ; 3111
				  04   AE  D7 00738 	    DECL    BR_DISPLACEMENT					      ; 3113
		         50	  F8   AD  9A 0073B 4$:     MOVZBL  BR_INSTRUC, R0					      ; 3114
      FA   AD	    04   AE	       50  28 0073F 	    MOVC3   R0, BR_DISPLACEMENT, BR_INSTRUC+2			      ;
				       18  11 00745 	    BRB     6$							      ; 3108
		    F8   AD	1706   8F  B0 00747 5$:     MOVW    #5894, BR_INSTRUC					      ; 3118
		    FA   AD	       11  8E 0074D 	    MNEGB   #17, BR_INSTRUC+2					      ; 3120
		    04   AE	       04  C2 00751 	    SUBL2   #4, BR_DISPLACEMENT					      ; 3121
		         50	  F8   AD  9A 00755 	    MOVZBL  BR_INSTRUC, R0					      ; 3122
      FB   AD	    04   AE	       50  28 00759 	    MOVC3   R0, BR_DISPLACEMENT, BR_INSTRUC+3			      ;
	   50	         59	  08   AC  C1 0075F 6$:     ADDL3   HOLE_SIZE, R9, R0					      ; 3130
		         58	       50  D0 00764 	    MOVL    R0, NEXT_LOC					      ;
		         6E	       50  D0 00767 	    MOVL    R0, NEXT_PC						      ; 3131
		         55 00000000G  EF  3C 0076A 	    MOVZWL  PAT$GL_TEMP_BUF, SUCC_OLD_INS			      ; 3132
      F8   AD	         08	       00  ED 00771 7$:     CMPZV   #0, #8, BR_INSTRUC, HOLE_SIZE			      ; 3133
				  08   AC     00776									      ;
				       03  14 00778 	    BGTR    8$							      ;
				     00C1  31 0077A 	    BRW     12$							      ;
			    00000000G  EF  9F 0077D 8$:     PUSHAB  PAT$GL_OLD_ASD					      ; 3141
			    00000000'  EF  9F 00783 	    PUSHAB  OLD_TAB_STG						      ; 2969
				       58  DD 00789 	    PUSHL   NEXT_LOC						      ; 3141
	      00000000V  EF	       03  FB 0078B 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
			    00000000G  EF  D4 00792 	    CLRL    PAT$GL_BUF_SIZ					      ; 3142
	      00000000G  EF	  59   AE  9E 00798 	    MOVAB   LOCAL_BUF+1, PAT$CP_OUT_STR				      ; 3143
			    00000000G  EF  9F 007A0 	    PUSHAB  PAT$GL_OLD_ASD					      ; 3154
				  04   AE  9F 007A6 	    PUSHAB  NEXT_PC						      ;
				       7E  D4 007A9 	    CLRL    -(SP)						      ;
				       58  DD 007AB 	    PUSHL   NEXT_LOC						      ;
	      00000000G  EF	       04  FB 007AD 	    CALLS   #4, PAT$INS_DECODE					      ;
		         6E	       50  D0 007B4 	    MOVL    R0, NEXT_PC						      ;
				       0D  12 007B7 	    BNEQ    9$							      ;
			    006D80EA   8F  DD 007B9 	    PUSHL   #7176426						      ; 3156
	      00000000G  00	       01  FB 007BF 	    CALLS   #1, LIB$SIGNAL					      ;
		    58   AE 00000000G  EF  90 007C6 9$:     MOVB    PAT$GL_BUF_SIZ, LOCAL_BUF				      ; 3157
		         57	  08   AE  9E 007CE 	    MOVAB   INSTRUC_BUF, NEW_INS_PTR				      ; 3158
			    00000000G  EF  9F 007D2 	    PUSHAB  PAT$GL_TEMP_BUF					      ; 3159
			    00000000G  EF  9F 007D8 	    PUSHAB  PAT$GL_NEW_ASD					      ;
		         50 00000000G  EF  3C 007DE 	    MOVZWL  PAT$GL_TEMP_BUF, R0					      ; 3160
				     6049  9F 007E5 	    PUSHAB  (R0)[R9]						      ;
				  14   AE  9F 007E8 	    PUSHAB  INSTRUC_BUF						      ; 3159
				  68   AE  9F 007EB 	    PUSHAB  LOCAL_BUF						      ;
	      00000000G  EF	       05  FB 007EE 	    CALLS   #5, PAT$INS_ENCODE					      ;
		         23	       50  E8 007F5 	    BLBS    R0, 11$						      ;
			    00000000G  EF  95 007F8 	    TSTB    PAT$GB_SUBST_IN					      ; 3162
				       09  13 007FE 	    BEQL    10$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-8
; Digital Equipment Corporation
;
		         57 00000000G  EF  9E 00800 	    MOVAB   PAT$GB_SUBST_IN, NEW_INS_PTR			      ; 3164
				       12  11 00807 	    BRB     11$							      ; 3162
				  58   AE  9F 00809 10$:    PUSHAB  LOCAL_BUF						      ; 3166
				       01  DD 0080C 	    PUSHL   #1							      ;
			    006D80F2   8F  DD 0080E 	    PUSHL   #7176434						      ;
	      00000000G  00	       03  FB 00814 	    CALLS   #3, LIB$SIGNAL					      ;
		         7E	       67  9A 0081B 11$:    MOVZBL  (NEW_INS_PTR), -(SP)				      ; 3167
				  01   A7  9F 0081E 	    PUSHAB  1(NEW_INS_PTR)					      ;
			    00000000G  EF  9F 00821 	    PUSHAB  PAT$GL_TEMP_BUF					      ;
	      00000000V  EF	       03  FB 00827 	    CALLS   #3, PAT$FILL_BUF					      ;
	   50	    08   AC	       6E  C1 0082E 	    ADDL3   NEXT_PC, HOLE_SIZE, R0				      ; 3168
      08   AC	         50	       58  C3 00833 	    SUBL3   NEXT_LOC, R0, HOLE_SIZE				      ;
		         58	       6E  D0 00838 	    MOVL    NEXT_PC, NEXT_LOC					      ; 3169
				     FF33  31 0083B 	    BRW     7$							      ; 3133
		         53 00000000G  EF  D0 0083E 12$:    MOVL    PAT$GL_TEMP_BUF+4, CUR_LOC				      ; 3176
		         6E	       59  D0 00845 	    MOVL    R9, NEXT_PC						      ; 3177
		         52	  10   AC  D0 00848 	    MOVL    ASC_INS_PTR, NXT_ASC_INS				      ; 3178
		         50 00000000G  EF  D0 0084C 13$:    MOVL    PAT$GL_TEMP_BUF+4, R0				      ; 3179
		         51 00000000G  EF  3C 00853 	    MOVZWL  PAT$GL_TEMP_BUF, R1					      ;
		         51	       50  C0 0085A 	    ADDL2   R0, R1						      ;
		         51	       53  D1 0085D 	    CMPL    CUR_LOC, R1						      ;
				       03  1F 00860 	    BLSSU   14$							      ;
				     00C7  31 00862 	    BRW     20$							      ;
			    00000000G  EF  D4 00865 14$:    CLRL    PAT$GL_BUF_SIZ					      ; 3182
	      00000000G  EF	  59   AE  9E 0086B 	    MOVAB   LOCAL_BUF+1, PAT$CP_OUT_STR				      ; 3183
	   51	         50	  0C   AC  C1 00873 	    ADDL3   OLD_INS_SIZ, R0, R1					      ; 3184
		         51	       53  D1 00878 	    CMPL    CUR_LOC, R1						      ;
				       1C  1F 0087B 	    BLSSU   15$							      ;
		         50	       55  C0 0087D 	    ADDL2   SUCC_OLD_INS, R0					      ; 3185
		         50	       53  D1 00880 	    CMPL    CUR_LOC, R0						      ;
				       14  1E 00883 	    BGEQU   15$							      ;
		         54	  04   A2  D0 00885 	    MOVL    4(NXT_ASC_INS), DECODED_INS				      ; 3194
		         52	       62  D0 00889 	    MOVL    (NXT_ASC_INS), NXT_ASC_INS				      ; 3195
	      00000000G  EF 00000000G  EF  D0 0088C 	    MOVL    PAT$GL_RLCLABLS, PAT$GL_SYMTBPTR			      ; 3196
				       0F  11 00897 	    BRB     16$							      ; 3184
		         54	  58   AE  9E 00899 15$:    MOVAB   LOCAL_BUF, DECODED_INS				      ; 3204
	      00000000G  EF 00000000G  EF  D0 0089D 	    MOVL    PAT$GL_OLDLABLS, PAT$GL_SYMTBPTR			      ; 3205
			    00000000G  EF  9F 008A8 16$:    PUSHAB  PAT$GL_NEW_ASD					      ; 3207
				  04   AE  9F 008AE 	    PUSHAB  NEXT_PC						      ;
				       7E  D4 008B1 	    CLRL    -(SP)						      ;
				       53  DD 008B3 	    PUSHL   CUR_LOC						      ;
	      00000000G  EF	       04  FB 008B5 	    CALLS   #4, PAT$INS_DECODE					      ;
		         53	       50  D0 008BC 	    MOVL    R0, CUR_LOC						      ;
				       0D  12 008BF 	    BNEQ    17$							      ;
			    006D80EA   8F  DD 008C1 	    PUSHL   #7176426						      ; 3209
	      00000000G  00	       01  FB 008C7 	    CALLS   #1, LIB$SIGNAL					      ;
		    58   AE 00000000G  EF  90 008CE 17$:    MOVB    PAT$GL_BUF_SIZ, LOCAL_BUF				      ; 3210
		         57	  08   AE  9E 008D6 	    MOVAB   INSTRUC_BUF, NEW_INS_PTR				      ; 3211
				       5B  DD 008DA 	    PUSHL   R11							      ; 3212
			    00000000G  EF  9F 008DC 	    PUSHAB  PAT$GL_NEW_ASD					      ;
		         50	       6B  3C 008E2 	    MOVZWL  PAT$GL_RLOC_BUF, R0					      ; 3213
				     604A  9F 008E5 	    PUSHAB  (R0)[NEW_LOC]					      ;
				  14   AE  9F 008E8 	    PUSHAB  INSTRUC_BUF						      ; 3212
				       54  DD 008EB 	    PUSHL   DECODED_INS						      ;
	      00000000G  EF	       05  FB 008ED 	    CALLS   #5, PAT$INS_ENCODE					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-9
; Digital Equipment Corporation
;
		         23	       50  E8 008F4 	    BLBS    R0, 19$						      ;
			    00000000G  EF  95 008F7 	    TSTB    PAT$GB_SUBST_IN					      ; 3215
				       09  13 008FD 	    BEQL    18$							      ;
		         57 00000000G  EF  9E 008FF 	    MOVAB   PAT$GB_SUBST_IN, NEW_INS_PTR			      ; 3217
				       12  11 00906 	    BRB     19$							      ; 3215
				  58   AE  9F 00908 18$:    PUSHAB  LOCAL_BUF						      ; 3219
				       01  DD 0090B 	    PUSHL   #1							      ;
			    006D80F2   8F  DD 0090D 	    PUSHL   #7176434						      ;
	      00000000G  00	       03  FB 00913 	    CALLS   #3, LIB$SIGNAL					      ;
		         7E	       67  9A 0091A 19$:    MOVZBL  (NEW_INS_PTR), -(SP)				      ; 3220
				  01   A7  9F 0091D 	    PUSHAB  1(NEW_INS_PTR)					      ;
				       5B  DD 00920 	    PUSHL   R11							      ;
	      00000000V  EF	       03  FB 00922 	    CALLS   #3, PAT$FILL_BUF					      ;
				     FF20  31 00929 	    BRW     13$							      ; 3179
	      00000000G  EF 00000000G  EF  D0 0092C 20$:    MOVL    PAT$GL_RLCLABLS, PAT$GL_SYMTBPTR			      ; 3222
				       5B  DD 00937 	    PUSHL   R11							      ; 3223
	      00000000G  EF	       01  FB 00939 	    CALLS   #1, PAT$RESOLVE_INS					      ;
		         50 00000000G  EF  D0 00940 	    MOVL    PAT$GL_PATAREA, R0					      ; 3230
		         51	       6B  3C 00947 	    MOVZWL  PAT$GL_RLOC_BUF, R1					      ;
	   50	    04   A0	       51  C1 0094A 	    ADDL3   R1, 4(R0), R0					      ;
		         50	       58  C2 0094F 	    SUBL2   NEXT_LOC, R0					      ;
		    04   AE	       50  CE 00952 	    MNEGL   R0, BR_DISPLACEMENT					      ; 3231
		    04   AE	       02  C2 00956 	    SUBL2   #2, BR_DISPLACEMENT					      ;
		         50	  04   AE  D0 0095A 	    MOVL    BR_DISPLACEMENT, R0					      ; 3232
	      0000007F   8F	       50  D1 0095E 	    CMPL    R0, #127						      ;
				       11  14 00965 	    BGTR    21$							      ;
	      FFFFFF80   8F	       50  D1 00967 	    CMPL    R0, #-128						      ;
				       08  19 0096E 	    BLSS    21$							      ;
		    08   AE	1102   8F  B0 00970 	    MOVW    #4354, INSTRUC_BUF					      ; 3235
				       1B  11 00976 	    BRB     22$							      ; 3237
	      00007FFF   8F	       50  D1 00978 21$:    CMPL    R0, #32767						      ; 3240
				       1E  14 0097F 	    BGTR    23$							      ;
	      FFFF8000   8F	       50  D1 00981 	    CMPL    R0, #-32768						      ;
				       15  19 00988 	    BLSS    23$							      ;
		    08   AE	3103   8F  B0 0098A 	    MOVW    #12547, INSTRUC_BUF					      ; 3243
				  04   AE  D7 00990 	    DECL    BR_DISPLACEMENT					      ; 3245
		         50	  08   AE  9A 00993 22$:    MOVZBL  INSTRUC_BUF, R0					      ; 3246
      0A   AE	    04   AE	       50  28 00997 	    MOVC3   R0, BR_DISPLACEMENT, INSTRUC_BUF+2			      ;
				       18  11 0099D 	    BRB     24$							      ; 3240
		    08   AE	1706   8F  B0 0099F 23$:    MOVW    #5894, INSTRUC_BUF					      ; 3250
		    0A   AE	       11  8E 009A5 	    MNEGB   #17, INSTRUC_BUF+2					      ; 3252
		    04   AE	       04  C2 009A9 	    SUBL2   #4, BR_DISPLACEMENT					      ; 3253
		         50	  08   AE  9A 009AD 	    MOVZBL  INSTRUC_BUF, R0					      ; 3254
      0B   AE	    04   AE	       50  28 009B1 	    MOVC3   R0, BR_DISPLACEMENT, INSTRUC_BUF+3			      ;
		         7E	  08   AE  9A 009B7 24$:    MOVZBL  INSTRUC_BUF, -(SP)					      ; 3256
				  0D   AE  9F 009BB 	    PUSHAB  INSTRUC_BUF+1					      ;
				       5B  DD 009BE 	    PUSHL   R11							      ;
	      00000000V  EF	       03  FB 009C0 	    CALLS   #3, PAT$FILL_BUF					      ;
		         50 00000000G  EF  D0 009C7 	    MOVL    PAT$GL_PATAREA, R0					      ; 3261
		         60	       6B  B1 009CE 	    CMPW    PAT$GL_RLOC_BUF, (R0)				      ;
				       49  1B 009D1 	    BLEQU   26$							      ;
		         51 00000000G  EF  D0 009D3 	    MOVL    PAT$GL_IHPPTR, R1					      ; 3264
		    04   A1	  04   A0  D1 009DA 	    CMPL    4(R0), 4(R1)					      ;
				       23  12 009DF 	    BNEQ    25$							      ;
		         51	       6B  3C 009E1 	    MOVZWL  PAT$GL_RLOC_BUF, R1					      ; 3267

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-10
; Digital Equipment Corporation
;
		         51	01FF   C1  9E 009E4 	    MOVAB   511(R1), R1						      ;
	   7E	         51 00000200   8F  C7 009E9 	    DIVL3   #512, R1, -(SP)					      ;
	      00000000G  EF	       01  FB 009F1 	    CALLS   #1, PAT$EXP_AREA					      ;
		         50 00000000G  EF  D0 009F8 	    MOVL    PAT$GL_PATAREA, R0					      ; 3268
		         6B	       60  B1 009FF 	    CMPW    (R0), PAT$GL_RLOC_BUF				      ;
				       18  1E 00A02 	    BGEQU   26$							      ;
		         7E	       60  3C 00A04 25$:    MOVZWL  (R0), -(SP)						      ; 3274
				  04   A0  DD 00A07 	    PUSHL   4(R0)						      ;
		         7E	       6B  3C 00A0A 	    MOVZWL  PAT$GL_RLOC_BUF, -(SP)				      ;
				       03  DD 00A0D 	    PUSHL   #3							      ;
			    006D80AA   8F  DD 00A0F 	    PUSHL   #7176362						      ;
	      00000000G  00	       05  FB 00A15 	    CALLS   #5, LIB$SIGNAL					      ;
		         7E	       6B  3C 00A1C 26$:    MOVZWL  PAT$GL_RLOC_BUF, -(SP)				      ; 3277
				  04   AB  DD 00A1F 	    PUSHL   PAT$GL_RLOC_BUF+4					      ;
		         50 00000000G  EF  D0 00A22 	    MOVL    PAT$GL_PATAREA, R0					      ;
				  04   A0  DD 00A29 	    PUSHL   4(R0)						      ;
	      00000000G  EF	       03  FB 00A2C 	    CALLS   #3, PAT$WRITE_MEM					      ;
		         50 00000000G  EF  D0 00A33 	    MOVL    PAT$GL_PATAREA, R0					      ; 3278
		         60	       6B  A2 00A3A 	    SUBW2   PAT$GL_RLOC_BUF, (R0)				      ;
		         51	       6B  3C 00A3D 	    MOVZWL  PAT$GL_RLOC_BUF, R1					      ; 3279
		    04   A0	       51  C0 00A40 	    ADDL2   R1, 4(R0)						      ;
		         56	  08   AC  D0 00A44 	    MOVL    HOLE_SIZE, R6					      ; 3286
      F8   AD	         08	       00  ED 00A48 	    CMPZV   #0, #8, BR_INSTRUC, R6				      ;
				       56     00A4D									      ;
				       3D  18 00A4E 	    BGEQ    27$							      ;
	   50	         56	       03  C1 00A50 	    ADDL3   #3, R6, R0						      ; 3289
	   7E	         50	       04  C7 00A54 	    DIVL3   #4, R0, -(SP)					      ;
	      00000000G  EF	       01  FB 00A58 	    CALLS   #1, PAT$FREEZ					      ;
		         57	       50  D0 00A5F 	    MOVL    R0, NEW_INS_PTR					      ;
		         50	  F8   AD  9A 00A62 	    MOVZBL  BR_INSTRUC, R0					      ; 3290
	   01	    F9   AD	       50  2C 00A66 	    MOVC5   R0, BR_INSTRUC+1, #1, R6, (NEW_INS_PTR)		      ;
		         67	       56     00A6B									      ;
				       56  DD 00A6D 	    PUSHL   R6							      ; 3292
				       57  DD 00A6F 	    PUSHL   NEW_INS_PTR						      ;
				       59  DD 00A71 	    PUSHL   R9							      ;
	      00000000G  EF	       03  FB 00A73 	    CALLS   #3, PAT$WRITE_MEM					      ;
	   50	         56	       03  C1 00A7A 	    ADDL3   #3, R6, R0						      ; 3293
	   7E	         50	       04  C7 00A7E 	    DIVL3   #4, R0, -(SP)					      ;
				       57  DD 00A82 	    PUSHL   NEW_INS_PTR						      ;
	      00000000G  EF	       02  FB 00A84 	    CALLS   #2, PAT$FREERELEASE					      ;
				       0E  11 00A8B 	    BRB     28$							      ; 3286
				       56  DD 00A8D 27$:    PUSHL   R6							      ; 3296
				  F9   AD  9F 00A8F 	    PUSHAB  BR_INSTRUC+1					      ;
				       59  DD 00A92 	    PUSHL   R9							      ;
	      00000000G  EF	       03  FB 00A94 	    CALLS   #3, PAT$WRITE_MEM					      ;
		         58	       59  D0 00A9B 28$:    MOVL    R9, NEXT_LOC					      ; 3301
	   52	         59	       56  C1 00A9E 29$:    ADDL3   R6, R9, R2						      ; 3302
		         52	       58  D1 00AA2 	    CMPL    NEXT_LOC, R2					      ;
				       1E  18 00AA5 	    BGEQ    30$							      ;
			    00000000G  EF  9F 00AA7 	    PUSHAB  PAT$GL_NEW_ASD					      ; 3305
			    00000000'  EF  9F 00AAD 	    PUSHAB  NEW_TAB_STG						      ; 2969
				       58  DD 00AB3 	    PUSHL   NEXT_LOC						      ; 3305
	      00000000V  EF	       03  FB 00AB5 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
		         58 00000000G  EF  D0 00ABC 	    MOVL    PAT$GL_NEXT_LOC, NEXT_LOC				      ; 3306
				       D9  11 00AC3 	    BRB     29$							      ; 3302

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 7-11
; Digital Equipment Corporation
;
		         58	       5A  D0 00AC5 30$:    MOVL    NEW_LOC, NEXT_LOC					      ; 3308
		         50 00000000G  EF  D0 00AC8 31$:    MOVL    PAT$GL_PATAREA, R0					      ; 3309
		    04   A0	       58  D1 00ACF 	    CMPL    NEXT_LOC, 4(R0)					      ;
				       1E  18 00AD3 	    BGEQ    32$							      ;
			    00000000G  EF  9F 00AD5 	    PUSHAB  PAT$GL_NEW_ASD					      ; 3312
			    00000000'  EF  9F 00ADB 	    PUSHAB  NEW_TAB_STG						      ; 2969
				       58  DD 00AE1 	    PUSHL   NEXT_LOC						      ; 3312
	      00000000V  EF	       03  FB 00AE3 	    CALLS   #3, PAT$OUT_MEM_LOC					      ;
		         58 00000000G  EF  D0 00AEA 	    MOVL    PAT$GL_NEXT_LOC, NEXT_LOC				      ; 3313
				       D5  11 00AF1 	    BRB     31$							      ; 3309
					   04 00AF3 32$:    RET     							      ; 2969

; Routine Size:  1167 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8
; Digital Equipment Corporation
;
;	3318	GLOBAL ROUTINE PAT$SUBST_INS (OLD_INS_PTR, INS_PC) =
;	3319	
;	3320	!++
;	3321	! FUNCTIONAL DESCRIPTION:
;	3322	!
;	3323	! This routine substitutes other instruction sequences for branch-type
;	3324	! instructions that have been relocated to a new address and whose branch
;	3325	! displacements are now too small.  The following table describes the
;	3326	! possible substitutions.  If the branch in the first replacement choice does
;	3327	! not reach, then the second replacement choice is used.  Notice that the blank
;	3328	! lines in the table separate groups of instructions that are handles
;	3329	! similarly for substitutions.
;	3330	!
;	3331	! OPC	INSTRUC		REPLACEMENT 1			REPLACEMENT 2
;	3332	! ---	-------		-------------			-------------
;	3333	!
;	3334	! 12	BNEQ <X>	BEQL .+03, BRW <X>		BEQL .+06, JMP <X>
;	3335	! 13	BEQL <X>	BNEQ .+03, BRW <X>		BNEQ .+06, JMP <X>
;	3336	! 14	BGTR <X>	BLEQ .+03, BRW <X>		BLEQ .+06, JMP <X>
;	3337	! 15	BLEQ <X>	BGTR .+03, BRW <X>		BGTR .+06, JMP <X>
;	3338	! 18	BGEQ <X>	BLSS .+03, BRW <X>		BLSS .+06, JMP <X>
;	3339	! 19	BLSS <X>	BLSS .+03, BRW <X>		BLSS .+06, JMP <X>
;	3340	! 1A	BGTRU <X>	BLEQU .+03, BRW <X>		BLEQU .+06, JMP <X>
;	3341	! 1B	BLEQU <X>	BGTRU .+03, BRW <X>		BGTRU .+06, JMP <X>
;	3342	! 1C	BVC <X>		BVS .+03, BRW <X>		BVS .+06, JMP <X>
;	3343	! 1D	BVS <X>		BVC .+03, BRW <X>		BVC .+06, JMP <X>
;	3344	! 1E	BGEQU <X>	BLSSU .+03, BRW <X>		BLSSU .+06, JMP <X>
;	3345	! 1F	BLSSU <X>	BGEQU .+03, BRW <X>		BGEQU .+06, JMP <X>
;	3346	! E0	BBS <X>		BBC .+03, BRW <X>		BBC .+06, JMP <X>
;	3347	! E1	BBC <X>		BBS .+03, BRW <X>		BBS .+06, JMP <X>
;	3348	! E2	BBSS <X>	BBCS .+03, BRW <X>		BBCS .+06, JMP <X>
;	3349	! E3	BBCS <X>	BBSS .+06, BRW <X>		BBSS .+03, JMP <X>
;	3350	! E4	BBSC <X>	BBCC .+03, BRW <X>		BBCC .+06, JMP <X>
;	3351	! E5	BBCC <X>	BBSC .+03, BRW <X>		BBSC .+06, JMP <X>
;	3352	! E8	BLBS <X>	BLBC .+03, BRW <X>		BLBC .+06, JMP <X>
;	3353	! E9	BLBC <X>	BLBS .+03, BRW <X>		BLBS .+06, JMP <X>
;	3354	!
;	3355	! E6	BBSSI <X>	BBSSI .+02, BRB .+03, BRW <X>	BBSSI .+02, BRB .+06, JMP <X>
;	3356	! E7	BBCCI <X>	BBCCI .+02, BRB .+03, BRW <X>	BBCCI .+02, BRB .+06, JMP <X>
;	3357	! F2	AOBLSS <X>	AOBLSS .+02, BRB .+03, BRW <X>	AOBLSS .+02, BRB .+06, JMP <X>
;	3358	! F3	AOBLEQ <X>	AOBLEQ .+02, BRB .+03, BRW <X>	AOBLEQ .+02, BRB .+06, JMP <X>
;	3359	! F4	SOBGEQ <X>	SOBGEQ .+02, BRB .+03, BRW <X>	SOBGEQ .+02, BRB .+06, JMP <X>
;	3360	! F5	SOBGTR <X>	SOBGTR .+02, BRB .+03, BRW <X>	SOBGTR .+02, BRB .+06, JMP <X>
;	3361	!
;	3362	! 9D	ACBB <X>	ACBB .+02, BRB .+06, JMP <X>
;	3363	! 3D	ACBW <X>	ACBW .+02, BRB .+06, JMP <X>
;	3364	! F1	ACBL <X>	ACBL .+02, BRB .+06, JMP <X>
;	3365	! 4F	ACBF <X>	ACBF .+02, BRB .+06, JMP <X>
;	3366	! 6F	ACBD <X>	ACBD .+02, BRB .+06, JMP <X>
;	3367	!
;	3368	! 11	BRB <X>		BRW <X>				JMP <X>
;	3369	! 10	BSBB <X>	BSBW <X>			JSB <X>
;	3370	!
;	3371	! 31	BRW <X>		JMP <X>
;	3372	! 30	BSBW <X>	JSB <X>

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-1
; Digital Equipment Corporation
;
;	3373	!
;	3374	! In addition to the above instructions, there are also three case
;	3375	! instructions.  None of these has a replacement.  (In fact, the encoder
;	3376	! does not know how to insert a case instruction correctly; it will only
;	3377	! insert the instruction parameters.  The branch displacements must be
;	3378	! inserted as .WORD directives.)
;	3379	!
;	3380	! CALLING SEQUENCE:
;	3381	!
;	3382	!	PAT$SUBST_INS (OLD-ENCODED-INSTRUCTION-ADDRESS, PC-OF-INSTRUCTION)
;	3383	!
;	3384	! INPUTS:
;	3385	!
;	3386	!	OLD_INS_PTR - Address of counted instruction stream to be substituted
;	3387	!	INS_PC - Unmapped address of where to put instruction
;	3388	!
;	3389	! IMPLICIT INPUTS:
;	3390	!
;	3391	!	PAT$GB_SUBST_IN - Buffer for substitution counted byte stream
;	3392	!
;	3393	! OUTPUTS:
;	3394	!
;	3395	!	NONE
;	3396	!
;	3397	! IMPLICIT OUTPUTS:
;	3398	!
;	3399	!	The substitution binary stream is written into INSTRUC_BUF
;	3400	!	as a counted byte stream.
;	3401	!
;	3402	! ROUTINE VALUE:
;	3403	!
;	3404	!	FALSE if no substitution instructions were possible.
;	3405	!	TRUE if substitution was successful.
;	3406	!
;	3407	! SIDE EFFECTS:
;	3408	!
;	3409	!	A substitution stream can now be written to memory, or an error
;	3410	!	reported.  However, if an instruction had a label associated with it
;	3411	!	any branches elsewhere in the code to it will no longer work!!!
;	3412	!
;	3413	!--
;	3414	
;	3415	BEGIN
;	3416	
;	3417	MAP
;	3418		OLD_INS_PTR : REF VECTOR[,BYTE];			! Old binary instruction stream
;	3419	
;	3420	LITERAL
;	3421		MIN_WORD_DISP = -32768,					! Minimum displacement for BRW
;	3422		MAX_WORD_DISP = 32767,					! Maximum displacement for BRW
;	3423		BRB_OPCODE = %X'11',					! Opcode for BRB instruction
;	3424		BRW_OPCODE = %X'31',					! Opcode for BRW instruction
;	3425		JMP_OPCODE = %X'17',					! Opcode forJMP instruction
;	3426		BNEQ_OPCODE = %X'12',					! Opcode for BNEQ instruction
;	3427		BLEQ_OPCODE = %X'15',					! Opcode for BLEQ instruction

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-2
; Digital Equipment Corporation
;
;	3428		BGEQ_OPCODE = %X'18',					! Opcode for BGEQ instruction
;	3429		BLSSU_OPCODE = %X'1F',					! Opcode for BLSSU instruction
;	3430		BBS_OPCODE = %X'E0',					! Opcode for BBS instruction
;	3431		BBCC_OPCODE = %X'E5',					! Opcode for BBCC instruction
;	3432		BLBS_OPCODE = %X'E8',					! Opcode for BLBS instruction
;	3433		BLBC_OPCODE = %X'E9',					! Opcode for BLBC instruction
;	3434		BBSSI_OPCODE = %X'E6',					! Opcode for BBSSI instruction
;	3435		BBCCI_OPCODE = %X'E7',					! Opcode for BBCCI instruction
;	3436		AOBLSS_OPCODE = %X'F2',					! Opcode for AOBLSS instruction
;	3437		SOBGTR_OPCODE = %X'F5',					! Opcode for SOBGTR instruction
;	3438		ACBB_OPCODE = %X'9D',					! Opcode for ACBB instruction
;	3439		ACBW_OPCODE = %X'3D',					! Opcode for ACBW instruction
;	3440		ACBL_OPCODE = %X'F1',					! Opcode for ACBL instruction
;	3441		ACBF_OPCODE = %X'4F',					! Opcode for ACBF instruction
;	3442		ACBD_OPCODE = %X'6F',					! Opcode for ACBD instruction
;	3443		CASEB_OPCODE = %X'8F',					! Opcode for CASEB instruction
;	3444		CASEW_OPCODE = %X'AF',					! Opcode for CASEW instruction
;	3445		CASEL_OPCODE = %X'CF',					! Opcode for CASEL instruction
;	3446		BSBW_OPCODE = %X'30',					! Opcode for BSBW instruction
;	3447		BSBB_OPCODE = %X'10',					! Opcode for BSBB instruction
;	3448		JSB_OPCODE = %X'16',					! Opcode for JSB instruction
;	3449		BRB_INS_SIZ = 2,					! Size of BRB instruction
;	3450		BRW_INS_SIZ = 3,					! Size of BRW instruction
;	3451		JMP_INS_SIZ = 6,					! Size of JMP instruction
;	3452		PC_DEFERRED = %X'EF',					! PC deferred instruction mode
;	3453		MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction
;	3454	
;	3455	LOCAL
;	3456		BR_DISPLACEMENT : SIGNED LONG;				! Displacement for branch instruction
;	3457	
;	3458	!++
;	3459	! Handle the first group of substitutions.  These may be replaced with
;	3460	! their complement and a BRW, i.e., opcodes BGTR through BLBC in the above
;	3461	! table.  The complement instruction must be set to branch around the BRW
;	3462	! instruction.  Therefore, the instruction stream changes from:
;	3463	!		<BR INS> TO <X>
;	3464	! TO:
;	3465	!		<BR COM INS> TO .+03		BRW <X>
;	3466	!--
;	3467	IF (.OLD_INS_PTR[1] GEQU BNEQ_OPCODE AND .OLD_INS_PTR[1] LEQU BLEQ_OPCODE) OR
;	3468	   (.OLD_INS_PTR[1] GEQU BGEQ_OPCODE AND .OLD_INS_PTR[1] LEQU BLSSU_OPCODE) OR
;	3469	   (.OLD_INS_PTR[1] GEQU BBS_OPCODE  AND .OLD_INS_PTR[1] LEQU BBCC_OPCODE ) OR
;	3470	   (.OLD_INS_PTR[1] GEQU BLBS_OPCODE AND .OLD_INS_PTR[1] LEQU BLBC_OPCODE )
;	3471	THEN
;	3472		BEGIN
;	3473		!++
;	3474		! Build the binary instruction stream for the complement branch.
;	3475		! Then build the BRW instruction with the old branch's displacement.
;	3476		!--
;	3477		PAT$GB_SUBST_IN[0] = BRW_INS_SIZ + .OLD_INS_PTR[0];	! Set the entire stream length
;	3478		PAT$GB_SUBST_IN[1] = (IF .OLD_INS_PTR[1] THEN (.OLD_INS_PTR[1] - 1)
;	3479						 ELSE (.OLD_INS_PTR[1] + 1));	! Set complement opcode
;	3480		CH$MOVE(.OLD_INS_PTR[0]-2, CH$PTR(OLD_INS_PTR[2]), CH$PTR(PAT$GB_SUBST_IN[2])); ! Move in instruction parameters
;	3481		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]] = BRW_INS_SIZ;		! Set complement branch around BRW instruction
;	3482		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+1] = BRW_OPCODE;	! Set BRW instruction opcode

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-3
; Digital Equipment Corporation
;
;	3483		BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new PC-relative displacement
;	3484		IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND
;	3485		   (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)			! Does displacement fit
;	3486		THEN
;	3487			(PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ])<0,16,1> = .BR_DISPLACEMENT	! Yes, move it into stream
;	3488		ELSE
;	3489			BEGIN
;	3490			!++
;	3491			! No, it did not fit.  Use a JMP instead of a BRW, which
;	3492			! is the second choice in the table.  The complement branch
;	3493			! displacement must be changed, too.
;	3494			!--
;	3495			PAT$GB_SUBST_IN[0] = .PAT$GB_SUBST_IN[0] + (JMP_INS_SIZ - BRW_INS_SIZ); ! Set new instruction stream length
;	3496			PAT$GB_SUBST_IN[ .OLD_INS_PTR[0] ] = JMP_INS_SIZ; ! Set complement branch around JMP instruction
;	3497			PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+1 ] = JMP_OPCODE; ! Set JMP opcode
;	3498			PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ] = PC_DEFERRED; ! Set instruction mode
;	3499			(PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+3 ])<0,32,1> = .BR_DISPLACEMENT -
;	3500						 (JMP_INS_SIZ - BRW_INS_SIZ); ! Set new branch displacement
;	3501	
;	3502			END
;	3503		END
;	3504	ELSE
;	3505	!++
;	3506	! The opcode was not one of the first group, therefore check to see if
;	3507	! it was one of the second group.
;	3508	!--
;	3509	IF (.OLD_INS_PTR[1] EQLU BBSSI_OPCODE) OR
;	3510	   (.OLD_INS_PTR[1] EQLU BBCCI_OPCODE) OR
;	3511	   (.OLD_INS_PTR[1] GEQU AOBLSS_OPCODE AND .OLD_INS_PTR[1] LEQU SOBGTR_OPCODE)
;	3512	THEN
;	3513		BEGIN
;	3514		!++
;	3515		! Handle the second group of substitutions.  THese may be replaced with
;	3516		! the instruction branch, a BRB instruction, and a BRW or JMP
;	3517		! instruction.  This group includes instructions BBSSI through ACBD in
;	3518		! the above table.  The instruction branch must be set to branch around
;	3519		! the BRB instruction.  The BRB instruction must be set to branch around
;	3520		! the BRW instruction.  Therefore, the instruction stream changes from:
;	3521		!	<BR INS> TO <X>
;	3522		! TO:
;	3523		!	<BR INS> TO .+02	BRB TO .+03	BRW <X>
;	3524		!--
;	3525		PAT$GB_SUBST_IN[0] = .OLD_INS_PTR[0] + BRB_INS_SIZ + BRW_INS_SIZ; ! Set the stream length
;	3526		CH$MOVE(.OLD_INS_PTR[0]-1, CH$PTR(OLD_INS_PTR[1]), CH$PTR(PAT$GB_SUBST_IN[1]));	! Copy old ins stream minus branch 
;	3527		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0] ] = BRB_INS_SIZ;	! Set displ to br around BRB ins
;	3528		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+1 ] = BRB_OPCODE;	! Set BRB opcode
;	3529		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ] = BRW_INS_SIZ;	! Set BRB around BRW ins
;	3530		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+3 ] = BRW_OPCODE;	! Set BRW opcode
;	3531		BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new PC-relative displacement
;	3532		IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND
;	3533		   (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)			! Does displacement fit?
;	3534		THEN
;	3535			(PAT$GB_SUBST_IN[ .PAT$GB_SUBST_IN[0]-1 ])<0,16,1> = .BR_DISPLACEMENT ! Yes, move in displacement
;	3536		ELSE
;	3537			BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-4
; Digital Equipment Corporation
;
;	3538			!++
;	3539			! No, displacement did not fit, therefore use the
;	3540			! second substitution choice.  This includes changing
;	3541			! the BRW to a JMP, and altering the branch around it.
;	3542			!--
;	3543			PAT$GB_SUBST_IN[0] = .PAT$GB_SUBST_IN[0] + (JMP_INS_SIZ - BRW_INS_SIZ); ! Set a new stream size
;	3544			PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ] = JMP_INS_SIZ; ! Change BRB displacement around JMP
;	3545			PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+3 ] = JMP_OPCODE; ! Replace the BRW opcode
;	3546			PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+4 ] = PC_DEFERRED; ! Set the instruction mode
;	3547			(PAT$GB_SUBST_IN[ .PAT$GB_SUBST_IN[0] + A_BYTE - A_LONGWORD ])<0,32,1> =
;	3548				 .BR_DISPLACEMENT - (JMP_INS_SIZ - BRW_INS_SIZ); ! Adjust the displ
;	3549			END;
;	3550		END
;	3551	ELSE
;	3552	!++
;	3553	! The opcode was not one of the second group, therefore check to see if it
;	3554	! was one of the third group.
;	3555	!--
;	3556	IF (.OLD_INS_PTR[1] EQLU ACBB_OPCODE) OR
;	3557	   (.OLD_INS_PTR[1] EQLU ACBW_OPCODE) OR
;	3558	   (.OLD_INS_PTR[1] EQLU ACBL_OPCODE) OR
;	3559	   (.OLD_INS_PTR[1] EQLU ACBF_OPCODE) OR
;	3560	   (.OLD_INS_PTR[1] EQLU ACBD_OPCODE)
;	3561	THEN
;	3562		BEGIN
;	3563		!++
;	3564		! Handle the third group of substitutions.  These may be replaced with
;	3565		! the instruction branch, a BRB instruction, and a JMP instruction.
;	3566		! This group includes instructions ACBB through ACBD in the above table.
;	3567		! The instruction branch must be set to branch around the BRB
;	3568		! instruction.  The BRB instruction must be set to branch around the
;	3569		! BRW instruction.  THerefore, the instruction stream changes from:
;	3570	
;	3571		! CHANGES FROM:
;	3572		!	<BR INS> TO <X>
;	3573		! TO:
;	3574		!	<BR INS> TO .+02	BRB TO .+06	JMP <X>
;	3575		!--
;	3576		PAT$GB_SUBST_IN[0] = .OLD_INS_PTR[0] + (JMP_INS_SIZ + BRB_INS_SIZ); ! Set the stream length
;	3577		CH$MOVE(.OLD_INS_PTR[0]-2, CH$PTR(OLD_INS_PTR[1]), CH$PTR(PAT$GB_SUBST_IN[1])); ! Copy old ins stream minus branch 
;	3578		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]-1] = BRB_INS_SIZ;	! Set displ to br around BRB ins
;	3579		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]] = 0;			! Clear other byte of displ word
;	3580		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+1] = BRB_OPCODE;	! Set BRB opcode
;	3581		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+2] = JMP_INS_SIZ;	! Set BRB around JMP instruction
;	3582		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+3] = JMP_OPCODE;	! Set BRW opcode
;	3583		PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+4] = PC_DEFERRED;	! Set instruction mode
;	3584		BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new PC-relative displacement
;	3585		(PAT$GB_SUBST_IN[ .PAT$GB_SUBST_IN[0] + A_BYTE - A_LONGWORD ])<0,32,1> = .BR_DISPLACEMENT; ! Adjust the displ
;	3586		END
;	3587	ELSE
;	3588	!++
;	3589	! The opcode was not one of the third group, therefore check to see if it
;	3590	! was one of the fourth group.
;	3591	!--
;	3592	IF (.OLD_INS_PTR[1] EQL BRB_OPCODE) OR (.OLD_INS_PTR[1] EQL BSBB_OPCODE)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-5
; Digital Equipment Corporation
;
;	3593	THEN
;	3594		BEGIN
;	3595		!++
;	3596		! Handle the fourth group of substitutions.  THese may be replaced with
;	3597		! the next larger displacement branch instruction of the same type.
;	3598		! This group includes instrucitons BRB and BSBB.  These instructions
;	3599		! can be handled similarly because:
;	3600		! (1) They have the same binary format, and
;	3601		! (2) The difference in opcodes for this branch
;	3602		!      displacement and the next larger is the same.
;	3603		! Therefore, because of (1), the variables BRB_INS_SIZ and
;	3604		! BRW_INS_SIZ would be identical to BSBB_INS_SIZ and
;	3605		! BSBW_INS_SIZ.  Also, because of (2), (BRW_OPCODE - BRB_OPCODE)
;	3606		! is the same as (BSBW_OPCODE - BSBB_OPCODE).
;	3607		!--
;	3608		PAT$GB_SUBST_IN[0] = BRW_INS_SIZ;			! Set ins stream size
;	3609		PAT$GB_SUBST_IN[1] = .OLD_INS_PTR[1] + (BRW_OPCODE - BRB_OPCODE); ! Set new opcode
;	3610		BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new displ
;	3611		IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND
;	3612		   (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)			! Does displ fit?
;	3613		THEN
;	3614			(PAT$GB_SUBST_IN[2])<0,16,1> = .BR_DISPLACEMENT	! Yes, move displ into stream
;	3615		ELSE
;	3616			BEGIN
;	3617			!++
;	3618			! No, displacement did not fit.  A longword displacement must be
;	3619			! used.  Therefore, convert to a JSB or JMP instruction.
;	3620			!--
;	3621			PAT$GB_SUBST_IN[0] = JMP_INS_SIZ;		! Set new stream size
;	3622			PAT$GB_SUBST_IN[1] = .PAT$GB_SUBST_IN[1] + (JMP_OPCODE - BRW_OPCODE); ! Set new opcode
;	3623			PAT$GB_SUBST_IN[2] = PC_DEFERRED;		! Set instruction mode
;	3624			(PAT$GB_SUBST_IN[3])<0,32,1> = .BR_DISPLACEMENT -
;	3625				 (JMP_INS_SIZ - BRW_INS_SIZ);		! Compute new displacement
;	3626			END
;	3627		END
;	3628	ELSE
;	3629	!++
;	3630	! The opcode was not one of the fourth group, therefore check to see if it
;	3631	! was one of the fifth group.
;	3632	!--
;	3633	IF (.OLD_INS_PTR[1] EQL BRW_OPCODE) OR (.OLD_INS_PTR[1] EQL BSBW_OPCODE)
;	3634	THEN
;	3635		BEGIN
;	3636		!++
;	3637		! Handle the fifth group of substitutions.  These may be replaced with
;	3638		! the next larger displacement branch instruction of the same type.
;	3639		! This group includes instructions BRW and BSBW.  These instructions
;	3640		! can be handled similarly because:
;	3641		! (1) They have the same binary format, and
;	3642		! (2) The difference in opcodes for this branch displacement
;	3643		!     and the next larger is the same.
;	3644		! Therefore, beacuse of (1), the variables JSB_INS_SIZ and JMP_INS_SIZ
;	3645		! would be identical.  Also, because of (2), (JMP_OPCODE - BRW_OPCODE)
;	3646		! is the same as (JSB_OPCODE - BSBW_OPCODE).
;	3647		!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-6
; Digital Equipment Corporation
;
;	3648		PAT$GB_SUBST_IN[0] = JMP_INS_SIZ;			! Set ins stream size
;	3649		PAT$GB_SUBST_IN[1] = .OLD_INS_PTR[1] + (JMP_OPCODE - BRW_OPCODE); ! Set opcode
;	3650		PAT$GB_SUBST_IN[2] = PC_DEFERRED;			! Set ins mode
;	3651		BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Get displacement
;	3652		(PAT$GB_SUBST_IN[3])<0,32,1> = .BR_DISPLACEMENT;	! Compute br displ
;	3653		END
;	3654	ELSE
;	3655		RETURN (FALSE);
;	3656	
;	3657	RETURN (TRUE);	
;	3658	END;								! End of PAT$SUBST_INS





					 0CFC 00AF4 	    .ENTRY  PAT$SUBST_INS, Save R2,R3,R4,R5,R6,R7,R10,R11	      ; 3318
		         5A 00000000G  EF  9E 00AF6 	    MOVAB   PAT$GL_BR_DISPL, R10				      ;
		         5B 00000000G  EF  9E 00AFD 	    MOVAB   PAT$GB_SUBST_IN, R11				      ;
		         57	  04   AC  D0 00B04 	    MOVL    OLD_INS_PTR, R7					      ; 3467
		         56	  01   A7  9E 00B08 	    MOVAB   1(R7), R6						      ;
		         12	       66  91 00B0C 	    CMPB    (R6), #18						      ;
				       05  1F 00B0F 	    BLSSU   1$							      ;
		         15	       66  91 00B11 	    CMPB    (R6), #21						      ;
				       25  1B 00B14 	    BLEQU   6$							      ;
		         18	       66  91 00B16 1$:     CMPB    (R6), #24						      ; 3468
				       05  1F 00B19 	    BLSSU   2$							      ;
		         1F	       66  91 00B1B 	    CMPB    (R6), #31						      ;
				       1B  1B 00B1E 	    BLEQU   6$							      ;
		    E0   8F	       66  91 00B20 2$:     CMPB    (R6), #224						      ; 3469
				       06  1F 00B24 	    BLSSU   3$							      ;
		    E5   8F	       66  91 00B26 	    CMPB    (R6), #229						      ;
				       0F  1B 00B2A 	    BLEQU   6$							      ;
		    E8   8F	       66  91 00B2C 3$:     CMPB    (R6), #232						      ; 3470
				       03  1E 00B30 	    BGEQU   5$							      ;
				     00AA  31 00B32 4$:     BRW     11$							      ;
		    E9   8F	       66  91 00B35 5$:     CMPB    (R6), #233						      ;
				       F7  1A 00B39 	    BGTRU   4$							      ;
	   6B	         67	       03  81 00B3B 6$:     ADDB3   #3, (R7), PAT$GB_SUBST_IN				      ; 3477
		         07	       66  E9 00B3F 	    BLBC    (R6), 7$						      ; 3478
		         50	       66  9A 00B42 	    MOVZBL  (R6), R0						      ;
				       50  D7 00B45 	    DECL    R0							      ;
				       05  11 00B47 	    BRB     8$							      ;
		         50	       66  9A 00B49 7$:     MOVZBL  (R6), R0						      ; 3479
				       50  D6 00B4C 	    INCL    R0							      ;
		    01   AB	       50  90 00B4E 8$:     MOVB    R0, PAT$GB_SUBST_IN+1				      ; 3478
		         50	       67  9A 00B52 	    MOVZBL  (R7), R0						      ; 3480
		         50	       02  C2 00B55 	    SUBL2   #2, R0						      ;
      02   AB	    02   A7	       50  28 00B58 	    MOVC3   R0, 2(R7), PAT$GB_SUBST_IN+2			      ;
		         50	       6B  9E 00B5E 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3481
		         51	       67  9A 00B61 	    MOVZBL  (R7), R1						      ;
		         50	       51  C0 00B64 	    ADDL2   R1, R0						      ;
		         60	       03  90 00B67 	    MOVB    #3, (R0)						      ;
		         50	       6B  9E 00B6A 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3482
		         51	       67  9A 00B6D 	    MOVZBL  (R7), R1						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-7
; Digital Equipment Corporation
;
		         50	       51  C0 00B70 	    ADDL2   R1, R0						      ;
		    01   A0	       31  90 00B73 	    MOVB    #49, 1(R0)						      ;
		         50	       67  9A 00B77 	    MOVZBL  (R7), R0						      ; 3483
		         50	       6A  C0 00B7A 	    ADDL2   PAT$GL_BR_DISPL, R0					      ;
		         51	       6B  9A 00B7D 	    MOVZBL  PAT$GB_SUBST_IN, BR_DISPLACEMENT			      ;
	   51	         50	       51  C3 00B80 	    SUBL3   BR_DISPLACEMENT, R0, BR_DISPLACEMENT		      ;
	      00007FFF   8F	       51  D1 00B84 	    CMPL    BR_DISPLACEMENT, #32767				      ; 3484
				       18  14 00B8B 	    BGTR    9$							      ;
	      FFFF8000   8F	       51  D1 00B8D 	    CMPL    BR_DISPLACEMENT, #-32768				      ; 3485
				       0F  19 00B94 	    BLSS    9$							      ;
		         50	       6B  9E 00B96 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3487
		         52	       67  9A 00B99 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00B9C 	    ADDL2   R2, R0						      ;
		    02   A0	       51  B0 00B9F 	    MOVW    BR_DISPLACEMENT, 2(R0)				      ;
				       37  11 00BA3 	    BRB     10$							      ; 3484
		         6B	       03  80 00BA5 9$:     ADDB2   #3, PAT$GB_SUBST_IN					      ; 3495
		         50	       6B  9E 00BA8 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3496
		         52	       67  9A 00BAB 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00BAE 	    ADDL2   R2, R0						      ;
		         60	       06  90 00BB1 	    MOVB    #6, (R0)						      ;
		         50	       6B  9E 00BB4 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3497
		         52	       67  9A 00BB7 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00BBA 	    ADDL2   R2, R0						      ;
		    01   A0	       17  90 00BBD 	    MOVB    #23, 1(R0)						      ;
		         50	       6B  9E 00BC1 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3498
		         52	       67  9A 00BC4 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00BC7 	    ADDL2   R2, R0						      ;
		    02   A0	       11  8E 00BCA 	    MNEGB   #17, 2(R0)						      ;
		         50	       6B  9E 00BCE 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3499
		         52	       67  9A 00BD1 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00BD4 	    ADDL2   R2, R0						      ;
      03   A0	         51	       03  C3 00BD7 	    SUBL3   #3, BR_DISPLACEMENT, 3(R0)				      ;
				     01C9  31 00BDC 10$:    BRW     24$							      ; 3467
		    E6   8F	       66  91 00BDF 11$:    CMPB    (R6), #230						      ; 3509
				       15  13 00BE3 	    BEQL    14$							      ;
		    E7   8F	       66  91 00BE5 	    CMPB    (R6), #231						      ; 3510
				       0F  13 00BE9 	    BEQL    14$							      ;
		    F2   8F	       66  91 00BEB 	    CMPB    (R6), #242						      ; 3511
				       03  1E 00BEF 	    BGEQU   13$							      ;
				     00B0  31 00BF1 12$:    BRW     17$							      ;
		    F5   8F	       66  91 00BF4 13$:    CMPB    (R6), #245						      ;
				       F7  1A 00BF8 	    BGTRU   12$							      ;
	   6B	         67	       05  81 00BFA 14$:    ADDB3   #5, (R7), PAT$GB_SUBST_IN				      ; 3525
		         50	       67  9A 00BFE 	    MOVZBL  (R7), R0						      ; 3526
				       50  D7 00C01 	    DECL    R0							      ;
      01   AB	         66	       50  28 00C03 	    MOVC3   R0, (R6), PAT$GB_SUBST_IN+1				      ;
		         50	       6B  9E 00C08 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3527
		         51	       67  9A 00C0B 	    MOVZBL  (R7), R1						      ;
		         50	       51  C0 00C0E 	    ADDL2   R1, R0						      ;
		         60	       02  90 00C11 	    MOVB    #2, (R0)						      ;
		         50	       6B  9E 00C14 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3528
		         51	       67  9A 00C17 	    MOVZBL  (R7), R1						      ;
		         50	       51  C0 00C1A 	    ADDL2   R1, R0						      ;
		    01   A0	       11  90 00C1D 	    MOVB    #17, 1(R0)						      ;
		         50	       6B  9E 00C21 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3529

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-8
; Digital Equipment Corporation
;
		         52	       67  9A 00C24 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00C27 	    ADDL2   R2, R0						      ;
		    02   A0	       03  90 00C2A 	    MOVB    #3, 2(R0)						      ;
		         50	       6B  9E 00C2E 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3530
		         52	       67  9A 00C31 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00C34 	    ADDL2   R2, R0						      ;
		    03   A0	       31  90 00C37 	    MOVB    #49, 3(R0)						      ;
		         50	       67  9A 00C3B 	    MOVZBL  (R7), R0						      ; 3531
		         50	       6A  C0 00C3E 	    ADDL2   PAT$GL_BR_DISPL, R0					      ;
		         51	       6B  9A 00C41 	    MOVZBL  PAT$GB_SUBST_IN, BR_DISPLACEMENT			      ;
	   51	         50	       51  C3 00C44 	    SUBL3   BR_DISPLACEMENT, R0, BR_DISPLACEMENT		      ;
	      00007FFF   8F	       51  D1 00C48 	    CMPL    BR_DISPLACEMENT, #32767				      ; 3532
				       18  14 00C4F 	    BGTR    15$							      ;
	      FFFF8000   8F	       51  D1 00C51 	    CMPL    BR_DISPLACEMENT, #-32768				      ; 3533
				       0F  19 00C58 	    BLSS    15$							      ;
		         50	       6B  9E 00C5A 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3535
		         52	       6B  9A 00C5D 	    MOVZBL  PAT$GB_SUBST_IN, R2					      ;
		         50	       52  C0 00C60 	    ADDL2   R2, R0						      ;
		    FF   A0	       51  B0 00C63 	    MOVW    BR_DISPLACEMENT, -1(R0)				      ;
				       38  11 00C67 	    BRB     16$							      ; 3532
		         6B	       03  80 00C69 15$:    ADDB2   #3, PAT$GB_SUBST_IN					      ; 3543
		         50	       6B  9E 00C6C 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3544
		         52	       67  9A 00C6F 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00C72 	    ADDL2   R2, R0						      ;
		    02   A0	       06  90 00C75 	    MOVB    #6, 2(R0)						      ;
		         50	       6B  9E 00C79 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3545
		         52	       67  9A 00C7C 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00C7F 	    ADDL2   R2, R0						      ;
		    03   A0	       17  90 00C82 	    MOVB    #23, 3(R0)						      ;
		         50	       6B  9E 00C86 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3546
		         52	       67  9A 00C89 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00C8C 	    ADDL2   R2, R0						      ;
		    04   A0	       11  8E 00C8F 	    MNEGB   #17, 4(R0)						      ;
		         50	       6B  9E 00C93 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3547
		         52	       6B  9A 00C96 	    MOVZBL  PAT$GB_SUBST_IN, R2					      ;
		         50	       52  C0 00C99 	    ADDL2   R2, R0						      ;
      FD   A0	         51	       03  C3 00C9C 	    SUBL3   #3, BR_DISPLACEMENT, -3(R0)				      ; 3548
				     0104  31 00CA1 16$:    BRW     24$							      ; 3509
		    9D   8F	       66  91 00CA4 17$:    CMPB    (R6), #157						      ; 3556
				       17  13 00CA8 	    BEQL    18$							      ;
		         3D	       66  91 00CAA 	    CMPB    (R6), #61						      ; 3557
				       12  13 00CAD 	    BEQL    18$							      ;
		    F1   8F	       66  91 00CAF 	    CMPB    (R6), #241						      ; 3558
				       0C  13 00CB3 	    BEQL    18$							      ;
		    4F   8F	       66  91 00CB5 	    CMPB    (R6), #79						      ; 3559
				       06  13 00CB9 	    BEQL    18$							      ;
		    6F   8F	       66  91 00CBB 	    CMPB    (R6), #111						      ; 3560
				       77  12 00CBF 	    BNEQ    19$							      ;
	   6B	         67	       08  81 00CC1 18$:    ADDB3   #8, (R7), PAT$GB_SUBST_IN				      ; 3576
		         50	       67  9A 00CC5 	    MOVZBL  (R7), R0						      ; 3577
		         50	       02  C2 00CC8 	    SUBL2   #2, R0						      ;
      01   AB	         66	       50  28 00CCB 	    MOVC3   R0, (R6), PAT$GB_SUBST_IN+1				      ;
		         50	       6B  9E 00CD0 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3578
		         52	       67  9A 00CD3 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00CD6 	    ADDL2   R2, R0						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-9
; Digital Equipment Corporation
;
		    FF   A0	       02  90 00CD9 	    MOVB    #2, -1(R0)						      ;
		         50	       6B  9E 00CDD 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3579
		         52	       67  9A 00CE0 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00CE3 	    ADDL2   R2, R0						      ;
				       60  94 00CE6 	    CLRB    (R0)						      ;
		         50	       6B  9E 00CE8 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3580
		         52	       67  9A 00CEB 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00CEE 	    ADDL2   R2, R0						      ;
		    01   A0	       11  90 00CF1 	    MOVB    #17, 1(R0)						      ;
		         50	       6B  9E 00CF5 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3581
		         52	       67  9A 00CF8 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00CFB 	    ADDL2   R2, R0						      ;
		    02   A0	       06  90 00CFE 	    MOVB    #6, 2(R0)						      ;
		         50	       6B  9E 00D02 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3582
		         52	       67  9A 00D05 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00D08 	    ADDL2   R2, R0						      ;
		    03   A0	       17  90 00D0B 	    MOVB    #23, 3(R0)						      ;
		         50	       6B  9E 00D0F 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3583
		         52	       67  9A 00D12 	    MOVZBL  (R7), R2						      ;
		         50	       52  C0 00D15 	    ADDL2   R2, R0						      ;
		    04   A0	       11  8E 00D18 	    MNEGB   #17, 4(R0)						      ;
		         50	       67  9A 00D1C 	    MOVZBL  (R7), R0						      ; 3584
		         50	       6A  C0 00D1F 	    ADDL2   PAT$GL_BR_DISPL, R0					      ;
		         51	       6B  9A 00D22 	    MOVZBL  PAT$GB_SUBST_IN, BR_DISPLACEMENT			      ;
	   51	         50	       51  C3 00D25 	    SUBL3   BR_DISPLACEMENT, R0, BR_DISPLACEMENT		      ;
		         50	       6B  9E 00D29 	    MOVAB   PAT$GB_SUBST_IN, R0					      ; 3585
		         52	       6B  9A 00D2C 	    MOVZBL  PAT$GB_SUBST_IN, R2					      ;
		         50	       52  C0 00D2F 	    ADDL2   R2, R0						      ;
		    FD   A0	       51  D0 00D32 	    MOVL    BR_DISPLACEMENT, -3(R0)				      ;
				       70  11 00D36 	    BRB     24$							      ; 3556
		         11	       66  91 00D38 19$:    CMPB    (R6), #17						      ; 3592
				       05  13 00D3B 	    BEQL    20$							      ;
		         10	       66  91 00D3D 	    CMPB    (R6), #16						      ;
				       3F  12 00D40 	    BNEQ    22$							      ;
		         6B	       03  90 00D42 20$:    MOVB    #3, PAT$GB_SUBST_IN					      ; 3608
      01   AB	         66	       20  81 00D45 	    ADDB3   #32, (R6), PAT$GB_SUBST_IN+1			      ; 3609
		         50	       67  9A 00D4A 	    MOVZBL  (R7), R0						      ; 3610
		         50	       6A  C0 00D4D 	    ADDL2   PAT$GL_BR_DISPL, R0					      ;
		         51	       6B  9A 00D50 	    MOVZBL  PAT$GB_SUBST_IN, BR_DISPLACEMENT			      ;
	   51	         50	       51  C3 00D53 	    SUBL3   BR_DISPLACEMENT, R0, BR_DISPLACEMENT		      ;
	      00007FFF   8F	       51  D1 00D57 	    CMPL    BR_DISPLACEMENT, #32767				      ; 3611
				       0F  14 00D5E 	    BGTR    21$							      ;
	      FFFF8000   8F	       51  D1 00D60 	    CMPL    BR_DISPLACEMENT, #-32768				      ; 3612
				       06  19 00D67 	    BLSS    21$							      ;
		    02   AB	       51  B0 00D69 	    MOVW    BR_DISPLACEMENT, PAT$GB_SUBST_IN+2			      ; 3614
				       39  11 00D6D 	    BRB     24$							      ; 3611
		         6B	       06  90 00D6F 21$:    MOVB    #6, PAT$GB_SUBST_IN					      ; 3621
		    01   AB	       1A  82 00D72 	    SUBB2   #26, PAT$GB_SUBST_IN+1				      ; 3622
		    02   AB	       11  8E 00D76 	    MNEGB   #17, PAT$GB_SUBST_IN+2				      ; 3623
      03   AB	         51	       03  C3 00D7A 	    SUBL3   #3, BR_DISPLACEMENT, PAT$GB_SUBST_IN+3		      ; 3624
				       27  11 00D7F 	    BRB     24$							      ; 3592
		         31	       66  91 00D81 22$:    CMPB    (R6), #49						      ; 3633
				       05  13 00D84 	    BEQL    23$							      ;
		         30	       66  91 00D86 	    CMPB    (R6), #48						      ;
				       21  12 00D89 	    BNEQ    25$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 8-10
; Digital Equipment Corporation
;
		         6B	       06  90 00D8B 23$:    MOVB    #6, PAT$GB_SUBST_IN					      ; 3648
      01   AB	         66	       1A  83 00D8E 	    SUBB3   #26, (R6), PAT$GB_SUBST_IN+1			      ; 3649
		    02   AB	       11  8E 00D93 	    MNEGB   #17, PAT$GB_SUBST_IN+2				      ; 3650
		         50	       67  9A 00D97 	    MOVZBL  (R7), R0						      ; 3651
		         50	       6A  C0 00D9A 	    ADDL2   PAT$GL_BR_DISPL, R0					      ;
		         51	       6B  9A 00D9D 	    MOVZBL  PAT$GB_SUBST_IN, BR_DISPLACEMENT			      ;
	   51	         50	       51  C3 00DA0 	    SUBL3   BR_DISPLACEMENT, R0, BR_DISPLACEMENT		      ;
		    03   AB	       51  D0 00DA4 	    MOVL    BR_DISPLACEMENT, PAT$GB_SUBST_IN+3			      ; 3652
		         50	       01  D0 00DA8 24$:    MOVL    #1, R0						      ; 3657
					   04 00DAB 	    RET     							      ;
				       50  D4 00DAC 25$:    CLRL    R0							      ; 3318
					   04 00DAE 	    RET     							      ;

; Routine Size:  699 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 9
; Digital Equipment Corporation
;
;	3659	GLOBAL ROUTINE PAT$OUT_MEM_LOC (LOCATION, PREFIX_STG, ASM_DIR_TBL) =
;	3660	
;	3661	!++
;	3662	! FUNCTIONAL DESCRIPTION:
;	3663	!
;	3664	!	Outputs the value of a memory location to the output
;	3665	!	device. If this routine is called as a result of an EXAMINE
;	3666	!	command, the location itself is also displayed, followed by
;	3667	!	a colon and a tab.
;	3668	!
;	3669	!	The appropriate mode settings are used to control the output
;	3670	!	style.
;	3671	!
;	3672	! CALLING SEQUENCE:
;	3673	!
;	3674	!	PAT$OUT_MEM_LOC ()
;	3675	!
;	3676	! INPUTS:
;	3677	!
;	3678	!	LOCATION	- Unmapped location whose contents are to be displayed.
;	3679	!	PREFIX_STG	- Prefix string to output before the location
;	3680	!			  0 = NONE
;	3681	!	ASM_DIR_TBL	- Address of assembler directive table descriptor
;	3682	!
;	3683	! IMPLICIT INPUTS:
;	3684	!
;	3685	!	PAT$GL_CONTEXT [EXAMINE_BIT]	- If this bit is set, the address of the
;	3686	!					  value is also displayed.
;	3687	!	PAT$GL_MOD_PTR			- Pointer to the current mode level
;	3688	!
;	3689	! OUTPUTS:
;	3690	!
;	3691	!	TRUE for success, FALSE for failure.
;	3692	!
;	3693	! IMPLICIT OUTPUTS:
;	3694	!
;	3695	!	NONE
;	3696	!
;	3697	! ROUTINE VALUE:
;	3698	!
;	3699	!	TRUE or FALSE
;	3700	!
;	3701	! SIDE EFFECTS:
;	3702	!
;	3703	!	Data is output to the data device.  An error message is produced if the
;	3704	!	memory location is not readable.
;	3705	!
;	3706	!--
;	3707	
;	3708	BEGIN
;	3709	LOCAL
;	3710		MAPPED_LOC : REF VECTOR[,BYTE],				! Mapped address of deposit location
;	3711		ISE_ADDR: REF VECTOR[,BYTE],				! ISE address for deposit location
;	3712		OUT_VALUES : VECTOR[ TTY_OUT_WIDTH, BYTE],
;	3713		OUTPUT_BUFFER : VECTOR[ TTY_OUT_WIDTH, BYTE];

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 9-1
; Digital Equipment Corporation
;
;	3714	
;	3715	!++
;	3716	! Initialize buffer address and size.
;	3717	!--
;	3718	PAT$CP_OUT_STR = OUTPUT_BUFFER + 1;
;	3719	PAT$GL_BUF_SIZ = 0;
;	3720	
;	3721	!++
;	3722	! First check if there is a prefix string to be output.
;	3723	!--
;	3724	IF (.PREFIX_STG NEQ 0)
;	3725	THEN
;	3726		PAT$FAO_PUT(.PREFIX_STG);
;	3727	
;	3728	!++
;	3729	! Now if the examine bit is set then output a location which is mapped
;	3730	! by PATCH.  If the examine bit is not set, then output an expression
;	3731	! for the EVALUATE command.
;	3732	!--
;	3733	IF .PAT$GL_CONTEXT [EXAMINE_BIT]
;	3734	THEN
;	3735		BEGIN
;	3736		!++
;	3737		! Print the address, making it come out as a longword regardless of
;	3738		! the current output mode length.
;	3739		!--
;	3740		PAT$MAP_ADDR(.LOCATION,MAPPED_LOC,ISE_ADDR);		! Compute mapped address
;	3741		PAT$OUT_SYM_VAL(.LOCATION, LONG_LENGTH, 0);
;	3742		PAT$GL_LAST_LOC = .LOCATION;
;	3743		PAT$GB_LOC_TYPE = MEMORY_LOC;
;	3744		PAT$FAO_PUT ( COLON_TAB_STG );
;	3745	
;	3746		!++
;	3747		! Handle output as symbolic instructions separately.
;	3748		!--
;	3749		IF( .PAT$GB_MOD_PTR[ MODE_INSTRUC ] )
;	3750		THEN
;	3751			IF ((LOCATION = PAT$INS_DECODE (.LOCATION, OUTPUT_BUFFER, LOCATION, .ASM_DIR_TBL)) EQL 0)
;	3752			THEN
;	3753				BEGIN
;	3754				SIGNAL (PAT$_NODECODE);
;	3755				RETURN(FALSE);
;	3756				END
;	3757			ELSE
;	3758				BEGIN
;	3759				PAT$MAP_ADDR (.LOCATION, MAPPED_LOC, ISE_ADDR);
;	3760				IF .PAT$GL_CONTEXT [EXAMINE_BIT]
;	3761				THEN
;	3762					PAT$GL_NEXT_LOC = .LOCATION;
;	3763	
;	3764				!++
;	3765				! PAT$GL_LAST_VAL may be set within PAT$INS_DECODE.
;	3766				!--
;	3767				END
;	3768		ELSE	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 9-2
; Digital Equipment Corporation
;
;	3769			BEGIN
;	3770			!++
;	3771			! Special attention for ascii output.
;	3772			!--
;	3773			IF (.PAT$GB_MOD_PTR [MODE_ASCII])
;	3774			THEN
;	3775				!++
;	3776				! Simply output the number of characters
;	3777				! implied by the current MODE_LENGTH setting.
;	3778				!--
;	3779				BEGIN
;	3780				PAT$GET_VALUE (.LOCATION, .PAT$GB_MOD_PTR[MODE_LENGTH], OUT_VALUES);
;	3781				PAT$FAO_PUT (CS_ASCII, .PAT$GB_MOD_PTR[MODE_LENGTH], OUT_VALUES);
;	3782				PAT$GL_NEXT_LOC = .LOCATION + .PAT$GB_MOD_PTR [MODE_LENGTH];
;	3783				PAT$GL_LAST_VAL = .(.MAPPED_LOC) <0, .PAT$GB_MOD_PTR [MODE_LENGTH] * 8>;
;	3784				END
;	3785			ELSE						! Otherwise we have one of the usual modes
;	3786				IF .PAT$GL_CONTEXT [EXAMINE_BIT]
;	3787				THEN
;	3788					BEGIN
;	3789					PAT$GET_VALUE(.LOCATION, .PAT$GB_MOD_PTR[MODE_LENGTH], OUT_VALUES);
;	3790					PAT$OUT_NUM_VAL(.OUT_VALUES, 0, 0, TRUE);
;	3791					PAT$GL_NEXT_LOC = .LOCATION + .PAT$GB_MOD_PTR [MODE_LENGTH];
;	3792					PAT$GL_LAST_VAL = .OUT_VALUES <0, .PAT$GB_MOD_PTR [MODE_LENGTH] * 8>;
;	3793					END;
;	3794			END
;	3795		END
;	3796	ELSE
;	3797		BEGIN
;	3798		!++
;	3799		! Output the value for the EVALUATE command here then return.
;	3800		! All other commands have set the examine bit.  Check for different
;	3801		! output modes, literal or instruction.
;	3802		!--
;	3803		IF (.PAT$GL_CONTEXT[LITERAL_BIT])
;	3804		THEN
;	3805			BEGIN
;	3806			!++
;	3807			! Call a routine which does the whole thing - including
;	3808			! flushing the output and producing an error message if no
;	3809			! such literal translation can be found.
;	3810			!--
;	3811			DISPLAY_LVTS(..LOCATION);
;	3812	
;	3813			!++
;	3814			! If the above routine returns then at least one literal
;	3815			! translation was found.  This form of evaluate sets the
;	3816			! psuedo '\' (last value displayed) only.
;	3817			!--
;	3818			PAT$GL_LAST_VAL = ..LOCATION;
;	3819			RETURN(TRUE);
;	3820			END;
;	3821	
;	3822		!++
;	3823		! Instruction mode works only if /LITERAL was not specified.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 9-3
; Digital Equipment Corporation
;
;	3824		!--
;	3825		IF (.PAT$GB_MOD_PTR[MODE_INSTRUC])
;	3826		THEN
;	3827			BEGIN
;	3828			LOCAL
;	3829				COUNT,
;	3830				ENCODED_BUF : VECTOR[38,BYTE];
;	3831			IF (NOT PAT$INS_ENCODE(..LOCATION, ENCODED_BUF, 0))
;	3832			THEN
;	3833				SIGNAL(PAT$_NOENCODE, 1, ..LOCATION);
;	3834			COUNT = .ENCODED_BUF[0];
;	3835			DO
;	3836				BEGIN
;	3837				PAT$OUT_NUM_VAL(.ENCODED_BUF[.COUNT], BYTE_LENGTH, HEX_RADIX, FALSE);
;	3838				COUNT = .COUNT - 1;
;	3839				END
;	3840			UNTIL .COUNT EQL 0;
;	3841			END
;	3842		ELSE
;	3843			BEGIN
;	3844			PAT$OUT_NUM_VAL(..LOCATION, 0, 0, TRUE);
;	3845			PAT$GL_LAST_VAL = .(LOCATION) <0, .PAT$GB_MOD_PTR [MODE_LENGTH] * 8>;
;	3846			END;
;	3847		END;
;	3848	
;	3849	!++
;	3850	! Write out the string and return.
;	3851	!--
;	3852	PAT$OUT_PUT( OUTPUT_BUFFER );
;	3853	
;	3854	RETURN TRUE
;	3855	END;





					 0FFC 00DAF 	    .ENTRY  PAT$OUT_MEM_LOC, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11     ; 3659
		         54 00000000G  00  9E 00DB1 	    MOVAB   LIB$SIGNAL, R4					      ;
		         55 00000000G  EF  9E 00DB8 	    MOVAB   PAT$MAP_ADDR, R5					      ;
		         56 00000000G  EF  9E 00DBF 	    MOVAB   PAT$OUT_NUM_VAL, R6					      ;
		         57 00000000G  EF  9E 00DC6 	    MOVAB   PAT$GL_NEXT_LOC, R7					      ;
		         58 00000000G  EF  9E 00DCD 	    MOVAB   PAT$FAO_PUT, R8					      ;
		         59 00000000G  EF  9E 00DD4 	    MOVAB   PAT$GL_LAST_VAL, R9					      ;
		         5A 00000000G  EF  9E 00DDB 	    MOVAB   PAT$GL_CONTEXT, R10					      ;
		         5B 00000000G  EF  9E 00DE2 	    MOVAB   PAT$GB_MOD_PTR, R11					      ;
		         5E	FEC8   CE  9E 00DE9 	    MOVAB   -312(SP), SP					      ;
	      00000000G  EF	  31   AE  9E 00DEE 	    MOVAB   OUTPUT_BUFFER+1, PAT$CP_OUT_STR			      ; 3718
			    00000000G  EF  D4 00DF6 	    CLRL    PAT$GL_BUF_SIZ					      ; 3719
				  08   AC  D5 00DFC 	    TSTL    PREFIX_STG						      ; 3724
				       06  13 00DFF 	    BEQL    1$							      ;
				  08   AC  DD 00E01 	    PUSHL   PREFIX_STG						      ; 3726
		         68	       01  FB 00E04 	    CALLS   #1, PAT$FAO_PUT					      ;
		         53	  04   AC  D0 00E07 1$:     MOVL    LOCATION, R3					      ; 3740
		         03	  01   AA  E8 00E0B 	    BLBS    PAT$GL_CONTEXT+1, 2$				      ; 3733

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 9-4
; Digital Equipment Corporation
;
				     00EC  31 00E0F 	    BRW     7$							      ;
				  04   AE  9F 00E12 2$:     PUSHAB  ISE_ADDR						      ; 3740
				  04   AE  9F 00E15 	    PUSHAB  MAPPED_LOC						      ;
				       53  DD 00E18 	    PUSHL   R3							      ;
		         65	       03  FB 00E1A 	    CALLS   #3, PAT$MAP_ADDR					      ;
		         7E	       04  7D 00E1D 	    MOVQ    #4, -(SP)						      ; 3741
				       53  DD 00E20 	    PUSHL   R3							      ;
	      00000000G  EF	       03  FB 00E22 	    CALLS   #3, PAT$OUT_SYM_VAL					      ;
	      00000000G  EF	       53  D0 00E29 	    MOVL    R3, PAT$GL_LAST_LOC					      ; 3742
			    00000000G  EF  94 00E30 	    CLRB    PAT$GB_LOC_TYPE					      ; 3743
			    00000000'  EF  9F 00E36 	    PUSHAB  COLON_TAB_STG					      ; 3659
		         68	       01  FB 00E3C 	    CALLS   #1, PAT$FAO_PUT					      ; 3744
		         52	       6B  D0 00E3F 	    MOVL    PAT$GB_MOD_PTR, R2					      ; 3749
		         3A	  03   A2  E9 00E42 	    BLBC    3(R2), 4$						      ;
				  0C   AC  DD 00E46 	    PUSHL   ASM_DIR_TBL						      ; 3751
				  04   AC  9F 00E49 	    PUSHAB  LOCATION						      ;
				  38   AE  9F 00E4C 	    PUSHAB  OUTPUT_BUFFER					      ;
				       53  DD 00E4F 	    PUSHL   R3							      ;
	      00000000G  EF	       04  FB 00E51 	    CALLS   #4, PAT$INS_DECODE					      ;
		    04   AC	       50  D0 00E58 	    MOVL    R0, LOCATION					      ;
				       0C  12 00E5C 	    BNEQ    3$							      ;
			    006D80EA   8F  DD 00E5E 	    PUSHL   #7176426						      ; 3754
		         64	       01  FB 00E64 	    CALLS   #1, LIB$SIGNAL					      ;
				     010C  31 00E67 	    BRW     14$							      ; 3755
				  04   AE  9F 00E6A 3$:     PUSHAB  ISE_ADDR						      ; 3759
				  04   AE  9F 00E6D 	    PUSHAB  MAPPED_LOC						      ;
				  04   AC  DD 00E70 	    PUSHL   LOCATION						      ;
		         65	       03  FB 00E73 	    CALLS   #3, PAT$MAP_ADDR					      ;
		         49	  01   AA  E9 00E76 	    BLBC    PAT$GL_CONTEXT+1, 5$				      ; 3760
		         67	  04   AC  D0 00E7A 	    MOVL    LOCATION, PAT$GL_NEXT_LOC				      ; 3762
				       7C  11 00E7E 	    BRB     6$							      ; 3749
		         3F	  04   A2  E9 00E80 4$:     BLBC    4(R2), 5$						      ; 3773
				FF7C   CD  9F 00E84 	    PUSHAB  OUT_VALUES						      ; 3780
		         7E	  01   A2  9A 00E88 	    MOVZBL  1(R2), -(SP)					      ;
				       53  DD 00E8C 	    PUSHL   R3							      ;
	      00000000G  EF	       03  FB 00E8E 	    CALLS   #3, PAT$GET_VALUE					      ;
				FF7C   CD  9F 00E95 	    PUSHAB  OUT_VALUES						      ; 3781
		         50	       6B  D0 00E99 	    MOVL    PAT$GB_MOD_PTR, R0					      ;
		         7E	  01   A0  9A 00E9C 	    MOVZBL  1(R0), -(SP)					      ;
			    00000000'  EF  9F 00EA0 	    PUSHAB  CS_ASCII						      ; 3659
		         68	       03  FB 00EA6 	    CALLS   #3, PAT$FAO_PUT					      ; 3781
		         50	       6B  D0 00EA9 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 3782
		         51	  01   A0  9A 00EAC 	    MOVZBL  1(R0), R1						      ;
	   67	         53	       51  C1 00EB0 	    ADDL3   R1, R3, PAT$GL_NEXT_LOC				      ;
		         50	  01   A0  9A 00EB4 	    MOVZBL  1(R0), R0						      ; 3783
		         50	       08  C4 00EB8 	    MULL2   #8, R0						      ;
      00   BE	         50	       00  EF 00EBB 	    EXTZV   #0, R0, @MAPPED_LOC, PAT$GL_LAST_VAL		      ;
				       69     00EC0									      ;
				       39  11 00EC1 	    BRB     6$							      ; 3773
		         35	  01   AA  E9 00EC3 5$:     BLBC    PAT$GL_CONTEXT+1, 6$				      ; 3786
				FF7C   CD  9F 00EC7 	    PUSHAB  OUT_VALUES						      ; 3789
		         7E	  01   A2  9A 00ECB 	    MOVZBL  1(R2), -(SP)					      ;
				       53  DD 00ECF 	    PUSHL   R3							      ;
	      00000000G  EF	       03  FB 00ED1 	    CALLS   #3, PAT$GET_VALUE					      ;
				       01  DD 00ED8 	    PUSHL   #1							      ; 3790

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 9-5
; Digital Equipment Corporation
;
				       7E  7C 00EDA 	    CLRQ    -(SP)						      ;
				FF7C   CD  DD 00EDC 	    PUSHL   OUT_VALUES						      ;
		         66	       04  FB 00EE0 	    CALLS   #4, PAT$OUT_NUM_VAL					      ;
		         50	       6B  D0 00EE3 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 3791
		         51	  01   A0  9A 00EE6 	    MOVZBL  1(R0), R1						      ;
	   67	         53	       51  C1 00EEA 	    ADDL3   R1, R3, PAT$GL_NEXT_LOC				      ;
		         50	  01   A0  9A 00EEE 	    MOVZBL  1(R0), R0						      ; 3792
		         50	       08  C4 00EF2 	    MULL2   #8, R0						      ;
    FF7C   CD	         50	       00  EF 00EF5 	    EXTZV   #0, R0, OUT_VALUES, PAT$GL_LAST_VAL			      ;
				       69     00EFB									      ;
				       6A  11 00EFC 6$:     BRB     12$							      ; 3733
	   10	    03   AA	       01  E1 00EFE 7$:     BBC     #1, PAT$GL_CONTEXT+3, 8$				      ; 3803
				  04   BC  DD 00F03 	    PUSHL   @LOCATION						      ; 3811
	      00000000V  EF	       01  FB 00F06 	    CALLS   #1, DISPLAY_LVTS					      ;
		         69	  04   BC  D0 00F0D 	    MOVL    @LOCATION, PAT$GL_LAST_VAL				      ; 3818
				       5F  11 00F11 	    BRB     13$							      ; 3819
		         50	       6B  D0 00F13 8$:     MOVL    PAT$GB_MOD_PTR, R0					      ; 3825
		         35	  03   A0  E9 00F16 	    BLBC    3(R0), 11$						      ;
				       7E  D4 00F1A 	    CLRL    -(SP)						      ; 3831
				  0C   AE  9F 00F1C 	    PUSHAB  ENCODED_BUF						      ;
				       63  DD 00F1F 	    PUSHL   (R3)						      ;
	      00000000G  EF	       03  FB 00F21 	    CALLS   #3, PAT$INS_ENCODE					      ;
		         0D	       50  E8 00F28 	    BLBS    R0, 9$						      ;
				       63  DD 00F2B 	    PUSHL   (R3)						      ; 3833
				       01  DD 00F2D 	    PUSHL   #1							      ;
			    006D80F2   8F  DD 00F2F 	    PUSHL   #7176434						      ;
		         64	       03  FB 00F35 	    CALLS   #3, LIB$SIGNAL					      ;
		         52	  08   AE  9A 00F38 9$:     MOVZBL  ENCODED_BUF, COUNT					      ; 3834
		         7E	       10  7D 00F3C 10$:    MOVQ    #16, -(SP)						      ; 3837
				       01  DD 00F3F 	    PUSHL   #1							      ;
		         7E	  14 AE42  9A 00F41 	    MOVZBL  ENCODED_BUF[COUNT], -(SP)				      ;
		         66	       04  FB 00F46 	    CALLS   #4, PAT$OUT_NUM_VAL					      ;
				       52  D7 00F49 	    DECL    COUNT						      ; 3838
				       EF  12 00F4B 	    BNEQ    10$							      ; 3840
				       19  11 00F4D 	    BRB     12$							      ; 3825
				       01  DD 00F4F 11$:    PUSHL   #1							      ; 3844
				       7E  7C 00F51 	    CLRQ    -(SP)						      ;
				       63  DD 00F53 	    PUSHL   (R3)						      ;
		         66	       04  FB 00F55 	    CALLS   #4, PAT$OUT_NUM_VAL					      ;
		         50	       6B  D0 00F58 	    MOVL    PAT$GB_MOD_PTR, R0					      ; 3845
		         50	  01   A0  9A 00F5B 	    MOVZBL  1(R0), R0						      ;
		         50	       08  C4 00F5F 	    MULL2   #8, R0						      ;
      04   AC	         50	       00  EF 00F62 	    EXTZV   #0, R0, LOCATION, PAT$GL_LAST_VAL			      ;
				       69     00F67									      ;
				  30   AE  9F 00F68 12$:    PUSHAB  OUTPUT_BUFFER					      ; 3852
	      00000000G  EF	       01  FB 00F6B 	    CALLS   #1, PAT$OUT_PUT					      ;
		         50	       01  D0 00F72 13$:    MOVL    #1, R0						      ; 3854
					   04 00F75 	    RET     							      ;
				       50  D4 00F76 14$:    CLRL    R0							      ; 3659
					   04 00F78 	    RET     							      ;

; Routine Size:  458 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 10
; Digital Equipment Corporation
;
;	3856	ROUTINE DISPLAY_LVTS (VALUE) : NOVALUE =
;	3857	
;	3858	!++
;	3859	!
;	3860	! FUNCTIONAL DESCRIPTION:
;	3861	!
;	3862	!	Given a value, display the pathnames of all literals in the LVT which
;	3863	!	have this value.
;	3864	!
;	3865	! CALLING SEQUENCE:
;	3866	!
;	3867	!	CALLS #1, DISPLAY_LVTS
;	3868	!
;	3869	! INPUTS:
;	3870	!
;	3871	!	VALUE - Literal value to be translated to symbols
;	3872	!
;	3873	! IMPLICIT INPUTS:
;	3874	!
;	3875	!	The initial set up for standard PATCH I/O has already been done.
;	3876	!	This routine (re)uses this buffer for its output.
;	3877	!
;	3878	! OUTPUTS:
;	3879	!
;	3880	!	none
;	3881	!
;	3882	! IMPLICIT OUTPUTS:
;	3883	!
;	3884	!	All the literal symbols associated with the value are printed.
;	3885	!
;	3886	! ROUTINE VALUE:
;	3887	!
;	3888	!	novalue
;	3889	!
;	3890	! SIDE EFFECTS:
;	3891	!
;	3892	!	Either output is sent to SYS$OUTPUT or a SIGNAL is generated and
;	3893	!	no return is done.
;	3894	!
;	3895	!--
;	3896	
;	3897	BEGIN
;	3898	
;	3899	LOCAL
;	3900		OUTPUT_BUFFER : REF VECTOR[,BYTE],			! Output buffer for SYS$OUTPUT writes
;	3901		LVT_PTR : REF LVT_RECORD,				! Pointer to LVT match
;	3902		ONE_FOUND;						! Indicator if at least one symbol was found
;	3903	
;	3904	!++
;	3905	! Initialize a flag which is used to know whether or not at least one match
;	3906	! to the given value has been found.  Also save a pointer to current output
;	3907	! buffer so that it can be reused.
;	3908	!--
;	3909	ONE_FOUND = FALSE;
;	3910	OUTPUT_BUFFER = .PAT$CP_OUT_STR;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 10-1
; Digital Equipment Corporation
;
;	3911	
;	3912	!++
;	3913	! Access to the LVT is via a 'canned' function.  Before using it, this routine
;	3914	! must signal its intention to do so.
;	3915	!--
;	3916	PAT$GET_NXT_LVT(SL_ACCE_INIT);
;	3917	
;	3918	!++
;	3919	! Loop through the LVT sequentially, asking to see all currently valid records.
;	3920	!--
;	3921	WHILE ((LVT_PTR = PAT$GET_NXT_LVT(SL_ACCE_RECS)) NEQA 0)
;	3922		DO
;	3923		BEGIN
;	3924		IF (.LVT_PTR[LVT_VALUE] EQL .VALUE)
;	3925		THEN
;	3926			BEGIN
;	3927			LOCAL
;	3928				NT_PTR : REF NT_RECORD,
;	3929				PATH_VEC : PATHNAME_VECTOR;
;	3930	
;	3931			!++
;	3932			! Found a match.  Print out the corresponding pathname by
;	3933			! first building a pathname vector based on the returned NT_PTR.
;	3934			!--
;	3935			ONE_FOUND = TRUE;
;	3936			NT_PTR = .LVT_PTR[LVT_NT_PTR];
;	3937			PAT$ADD_NT_T_PV(.NT_PTR, PATH_VEC);
;	3938			PAT$PRINT_PATH(PATH_VEC);
;	3939	
;	3940			!++
;	3941			! Write out the string and reset the global buffer pointers.
;	3942			!--
;	3943			PAT$OUT_PUT(.OUTPUT_BUFFER-1);
;	3944			PAT$CP_OUT_STR = .OUTPUT_BUFFER;
;	3945			PAT$GL_BUF_SIZ = 0;
;	3946			END;
;	3947		END;							! Loop back to consider the next LVT record
;	3948	
;	3949	!++
;	3950	! At this point, the LVT has been completely searched.  If no matches were
;	3951	! found, then signal a warning.
;	3952	!--
;	3953	IF (NOT .ONE_FOUND)
;	3954	THEN
;	3955		SIGNAL(PAT$_NOLITERAL+MSG$K_WARN, 1, .VALUE);
;	3956	RETURN;
;	3957	END;								! End of DISPLAY_LVTS





					 0C1C 00F79 DISPLAY_LVTS:
							    .WORD   Save R2,R3,R4,R10,R11				      ; 3856
		         5A 00000000G  EF  9E 00F7B 	    MOVAB   PAT$CP_OUT_STR, R10					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 10-2
; Digital Equipment Corporation
;
		         5B 00000000G  EF  9E 00F82 	    MOVAB   PAT$GET_NXT_LVT, R11				      ;
		         5E	       2C  C2 00F89 	    SUBL2   #44, SP						      ;
				       54  D4 00F8C 	    CLRL    ONE_FOUND						      ; 3909
		         53	       6A  D0 00F8E 	    MOVL    PAT$CP_OUT_STR, OUTPUT_BUFFER			      ; 3910
				       7E  D4 00F91 	    CLRL    -(SP)						      ; 3916
		         6B	       01  FB 00F93 	    CALLS   #1, PAT$GET_NXT_LVT					      ;
				       01  DD 00F96 1$:     PUSHL   #1							      ; 3921
		         6B	       01  FB 00F98 	    CALLS   #1, PAT$GET_NXT_LVT					      ;
		         52	       50  D0 00F9B 	    MOVL    R0, LVT_PTR						      ;
				       36  13 00F9E 	    BEQL    2$							      ;
		    04   AC	  02   A2  D1 00FA0 	    CMPL    2(LVT_PTR), VALUE					      ; 3924
				       EF  12 00FA5 	    BNEQ    1$							      ;
		         54	       01  D0 00FA7 	    MOVL    #1, ONE_FOUND					      ; 3935
		         50	       62  3C 00FAA 	    MOVZWL  (LVT_PTR), NT_PTR					      ; 3936
				4001   8F  BB 00FAD 	    PUSHR   #^M<R0,SP>						      ; 3937
	      00000000G  EF	       02  FB 00FB1 	    CALLS   #2, PAT$ADD_NT_T_PV					      ;
				       5E  DD 00FB8 	    PUSHL   SP							      ; 3938
	      00000000G  EF	       01  FB 00FBA 	    CALLS   #1, PAT$PRINT_PATH					      ;
				  FF   A3  9F 00FC1 	    PUSHAB  -1(OUTPUT_BUFFER)					      ; 3943
	      00000000G  EF	       01  FB 00FC4 	    CALLS   #1, PAT$OUT_PUT					      ;
		         6A	       53  D0 00FCB 	    MOVL    OUTPUT_BUFFER, PAT$CP_OUT_STR			      ; 3944
			    00000000G  EF  D4 00FCE 	    CLRL    PAT$GL_BUF_SIZ					      ; 3945
				       C0  11 00FD4 	    BRB     1$							      ; 3921
		         12	       54  E8 00FD6 2$:     BLBS    ONE_FOUND, 3$					      ; 3953
				  04   AC  DD 00FD9 	    PUSHL   VALUE						      ; 3955
				       01  DD 00FDC 	    PUSHL   #1							      ;
			    006D82E8   8F  DD 00FDE 	    PUSHL   #7176936						      ;
	      00000000G  00	       03  FB 00FE4 	    CALLS   #3, LIB$SIGNAL					      ;
					   04 00FEB 3$:     RET     							      ; 3856

; Routine Size:  115 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 11
; Digital Equipment Corporation
;
;	3958	GLOBAL ROUTINE PAT$REG_MATCH (STRING_DESC) =
;	3959	
;	3960	!++
;	3961	!
;	3962	! FUNCTIONAL DESCRIPTION:
;	3963	!
;	3964	!	Compares a string described by the string descriptor passed as the
;	3965	!	routine formal to each of the names of the machine registers.  If the
;	3966	!	string matches a register name, return the number of the register (0-16,
;	3967	!	where 16 is the PSL).  Otherwise return a -1.
;	3968	!
;	3969	! CALLING SEQUENCE:
;	3970	!
;	3971	!	CALLS #1, PAT$REG_MATCH
;	3972	!
;	3973	! INPUTS:
;	3974	!
;	3975	!	STRING_DESC - String descriptor to symbol string
;	3976	!
;	3977	! IMPLICIT INPUTS:
;	3978	!
;	3979	!	The VAX machine register table.
;	3980	!
;	3981	! OUTPUTS:
;	3982	!
;	3983	!	The number of the register whose name matched the string.
;	3984	!
;	3985	! IMPLICIT OUTPUTS:
;	3986	!
;	3987	!	none
;	3988	!
;	3989	! ROUTINE VALUE:
;	3990	!
;	3991	!	0-16 for the corresponding register
;	3992	!	-1 for no match
;	3993	!
;	3994	! SIDE EFFECTS:
;	3995	!
;	3996	!	none
;	3997	!
;	3998	!--
;	3999	
;	4000	BEGIN
;	4001	
;	4002	MAP
;	4003		STRING_DESC : REF BLOCK [, BYTE];
;	4004	
;	4005	LOCAL
;	4006		INDEX;
;	4007	
;	4008	INDEX = 0;
;	4009	REPEAT
;	4010		BEGIN
;	4011		IF CH$EQL (.STRING_DESC [DSC$W_LENGTH], CH$PTR (.STRING_DESC [DSC$A_POINTER]),
;	4012				.REGISTER_TABLE [.INDEX, REG_CH_CNT],

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 11-1
; Digital Equipment Corporation
;
;	4013				CH$PTR (REGISTER_TABLE [.INDEX, REG_NAME]))
;	4014		THEN RETURN .INDEX
;	4015		ELSE
;	4016			BEGIN
;	4017			INDEX = .INDEX + 1;
;	4018			IF .INDEX GTR REGISTER_COUNT - 1
;	4019			THEN RETURN -1
;	4020			END;
;	4021		END;
;	4022	END;





					 003C 00FEC 	    .ENTRY  PAT$REG_MATCH, Save R2,R3,R4,R5			      ; 3958
				       54  D4 00FEE 	    CLRL    INDEX						      ; 4008
	   55	    04   AC	       04  C1 00FF0 	    ADDL3   #4, STRING_DESC, R5					      ; 4011
		         50 00000000'EF44  DE 00FF5 1$:     MOVAL   REGISTER_TABLE[INDEX], R0				      ; 4012
		         51	       60  9A 00FFD 	    MOVZBL  (R0), R1						      ;
	   00	    00   B5	  04   BC  2D 01000 	    CMPC5   @STRING_DESC, @0(R5), #0, R1, 1(R0)			      ; 4011
		    01   A0	       51     01006									      ;
				       04  12 01009 	    BNEQ    2$							      ;
		         50	       54  D0 0100B 	    MOVL    INDEX, R0						      ; 4014
					   04 0100E 	    RET     							      ;
				       54  D6 0100F 2$:     INCL    INDEX						      ; 4017
		         10	       54  D1 01011 	    CMPL    INDEX, #16						      ; 4018
				       DF  15 01014 	    BLEQ    1$							      ;
		         50	       01  CE 01016 	    MNEGL   #1, R0						      ; 4019
					   04 01019 	    RET     							      ; 3958

; Routine Size:  46 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 12
; Digital Equipment Corporation
;
;	4023	GLOBAL ROUTINE PAT$FILL_BUF(BUF_DESC, DATA_PTR, DATA_SIZ) : NOVALUE =
;	4024	
;	4025	!++
;	4026	!
;	4027	! FUNCTIONAL DESCRIPTION:
;	4028	!
;	4029	!	Takes the data defined as the input arguments and puts them in the
;	4030	!	temporary deposit buffer.  This is accomplished by allocating a new
;	4031	!	larger buffer, copying in the old buffer, and then deallocating it.
;	4032	!	Then the buffer descriptor is updated.
;	4033	!
;	4034	! CALLING SEQUENCE:
;	4035	!
;	4036	!	CALLS #2, PAT$FILL_BUF
;	4037	!
;	4038	! INPUTS:
;	4039	!
;	4040	!	BUF_DESC - Buffer descriptor
;	4041	!	DATA_PTR - Address of the data to be put in the buffer
;	4042	!	DATA_SIZ - Number of bytes of data to be put in the buffer
;	4043	!
;	4044	! IMPLICIT INPUTS:
;	4045	!
;	4046	!	none
;	4047	!
;	4048	! OUTPUTS:
;	4049	!
;	4050	!	none
;	4051	!
;	4052	! IMPLICIT OUTPUTS:
;	4053	!
;	4054	!	The buffer descriptor is updated.
;	4055	!
;	4056	! ROUTINE VALUE:
;	4057	!
;	4058	!	none
;	4059	!
;	4060	! SIDE EFFECTS:
;	4061	!
;	4062	!	The data is written into the buffer.
;	4063	!
;	4064	!--
;	4065	
;	4066	BEGIN
;	4067	
;	4068	MAP
;	4069		BUF_DESC : REF BLOCK[,BYTE];				! Buffer descriptor
;	4070	
;	4071	LOCAL
;	4072		TEMP_PTR;						! Pointer to new buffer
;	4073	
;	4074	TEMP_PTR = PAT$FREEZ((.BUF_DESC[DSC$W_LENGTH] + .DATA_SIZ + A_LONGWORD -1)/A_LONGWORD); ! Allocate larger buffer
;	4075	IF .BUF_DESC[DSC$W_LENGTH] NEQ 0
;	4076	THEN
;	4077		BEGIN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 12-1
; Digital Equipment Corporation
;
;	4078		CH$MOVE(.BUF_DESC[DSC$W_LENGTH], .BUF_DESC[DSC$A_POINTER], .TEMP_PTR); ! Move in previous data
;	4079		PAT$FREERELEASE(.BUF_DESC[DSC$A_POINTER], (.BUF_DESC[DSC$W_LENGTH] +3)/4); ! Release old buffer
;	4080		END;
;	4081	CH$MOVE(.DATA_SIZ, .DATA_PTR, CH$PTR(.TEMP_PTR, .BUF_DESC[DSC$W_LENGTH])); ! Move in new data
;	4082	BUF_DESC[DSC$A_POINTER] = CH$PTR(.TEMP_PTR);			! Reset buffer dsc addr
;	4083	BUF_DESC[DSC$W_LENGTH] = .BUF_DESC[DSC$W_LENGTH] + .DATA_SIZ;	! Reset buf dsc siz
;	4084	END;





					 00FC 0101A 	    .ENTRY  PAT$FILL_BUF, Save R2,R3,R4,R5,R6,R7		      ; 4023
		         56	  04   AC  D0 0101C 	    MOVL    BUF_DESC, R6					      ; 4074
		         50	       66  3C 01020 	    MOVZWL  (R6), R0						      ;
		         50	  0C   AC  C0 01023 	    ADDL2   DATA_SIZ, R0					      ;
		         50	       03  C0 01027 	    ADDL2   #3, R0						      ;
	   7E	         50	       04  C7 0102A 	    DIVL3   #4, R0, -(SP)					      ;
	      00000000G  EF	       01  FB 0102E 	    CALLS   #1, PAT$FREEZ					      ;
		         57	       50  D0 01035 	    MOVL    R0, TEMP_PTR					      ;
				       66  B5 01038 	    TSTW    (R6)						      ; 4075
				       19  13 0103A 	    BEQL    1$							      ;
	   67	    04   B6	       66  28 0103C 	    MOVC3   (R6), @4(R6), (TEMP_PTR)				      ; 4078
		         50	       66  3C 01041 	    MOVZWL  (R6), R0						      ; 4079
		         50	       03  C0 01044 	    ADDL2   #3, R0						      ;
	   7E	         50	       04  C7 01047 	    DIVL3   #4, R0, -(SP)					      ;
				  04   A6  DD 0104B 	    PUSHL   4(R6)						      ;
	      00000000G  EF	       02  FB 0104E 	    CALLS   #2, PAT$FREERELEASE					      ;
		         50	       66  3C 01055 1$:     MOVZWL  (R6), R0						      ; 4081
		         50	       57  C0 01058 	    ADDL2   TEMP_PTR, R0					      ;
	   60	    08   BC	  0C   AC  28 0105B 	    MOVC3   DATA_SIZ, @DATA_PTR, (R0)				      ;
		    04   A6	       57  D0 01061 	    MOVL    TEMP_PTR, 4(R6)					      ; 4082
		         66	  0C   AC  A0 01065 	    ADDW2   DATA_SIZ, (R6)					      ; 4083
					   04 01069 	    RET     							      ; 4023

; Routine Size:  80 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:10:13	DBB3:[PATCH.SRC]PATEXA.B32;14					Page 13
; Digital Equipment Corporation
;
;	4085	END
;	4086	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$PLIT      	   100  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  _PAT$CODE      	  4202  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582         6         0       224





; Size:		4202 code + 100 data bytes
; Run Time:	02:35.1
; Elapsed Time:	03:50.3
; Memory Used:	552 pages
; Compilation Complete
