
; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 1
; Digital Equipment Corporation
;
;	0001	MODULE PATINT (							! RST interface routines for PATCH
;	0002			%IF %VARIANT EQL 1
;     L 0003			%THEN
;	0004				ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
;	0005			%FI
;	0006			IDENT = 'X01.14'
;	0007			) =
;	0008	BEGIN
;	0009	
;	0010	!
;	0011	! COPYRIGHT (c) 1977,1978
;	0012	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;	0013	!
;	0014	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;	0015	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;	0016	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;	0017	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;	0018	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;	0019	! TRANSFERRED.
;	0020	!
;	0021	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;	0022	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;	0023	! CORPORATION.
;	0024	!
;	0025	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;	0026	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;	0027	!
;	0028	
;	0029	!++
;	0030	! FACILITY:	PATCH
;	0031	!
;	0032	! ABSTRACT:	This is  the RST/DST/PATCH interface module.
;	0033	!		 This module exists because the DST/RST
;	0034	!		 module simply declares how it wants to see
;	0035	!		 the world, and leaves it up to this module
;	0036	!		 to interface to PATCH to make things look
;	0037	!		 that way.
;	0038	!
;	0039	!	This module defines the interface between the
;	0040	!	PATCH RST builder/manipulator and the LINKER-produced
;	0041	!	DST.  The former would like to show as little
;	0042	!	concern for where DST records are actually stored as
;	0043	!	possible.  The latter would like to provide this facility,
;	0044	!	but it must do so simply, (because we don't want to
;	0045	!	re-invent the world), efficiently, and in such
;	0046	!	as way as to allow us to do radically different
;	0047	!	things about where the DST actually exists.
;	0048	!
;	0049	!	Essentially what we do to solve this is to restrict the
;	0050	!	DST user to requesting records before he uses them,
;	0051	!	(probably) saying something about how long he wants
;	0052	!	to use them (or, equivalently, when he is willing to give
;	0053	!	them up), and using them given that they exist at the
;	0054	!	address he is told they are currently at.  This means that
;	0055	!	he can never make any assumptions about where a record is at.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 1-1
; Digital Equipment Corporation
;
;	0056	!	To get around this we introduce the concept of "Record Ids",
;	0057	!	which are simply identifiers by which the two sides of the
;	0058	!	interface agree to call records.  The first time you
;	0059	!	get a record, the interface tells you how you must
;	0060	!	henceforth refer to it.
;	0061	!
;	0062	!	The other aspect of the interface concerns so-called
;	0063	!	RST-pointers.  These pointers are used throught the
;	0064	!	RST module to access various (all) records.  The code
;	0065	!	uses these pointers implicitly, knowing nothing
;	0066	!	about what they actually are, and leaves it up to this
;	0067	!	interface to define them.  This is done by
;	0068	!	having a special storage allocator for the RST
;	0069	!	module.  It uses whatever kind of pointer this
;	0070	!	allocator returns, and leaves it up to
;	0071	!	the definition of the RST structures (RST_NT,
;	0072	!	RST_MC, etc.  see PATRST.REQ) to make
;	0073	!	sure that these RST-pointers do the job.
;	0074	!
;	0075	! Version:	X01.14
;	0076	!
;	0077	! ENVIRONMENT:	This module runs on VAX under STARLET, user mode, non-AST level.
;	0078	!
;	0079	! AUTHOR:	Kevin Pammett, CREATION DATE: 12 JULY 77
;	0080	!
;	0081	! MODIFIED BY:
;	0082	!
;	0083	!  NO	DATE		PROGRAMMER		PURPOSE
;	0084	!  --	----		----------		-------
;	0085	!
;	0086	!  00	13-DEC-77	K.D. MORSE		ADAPT VERSION 19 FOR PATCH.
;	0087	!  01	2-JAN-78	K.D. MORSE		ALLOW NO GST IN IMAGE.
;	0088	!  02	23-JAN-78	K.D. MORSE		ADD CODE FOR MORE SPECIFIC
;	0089	!						ERROR MESSAGES. (20)
;	0090	!  03	28-FEB-78	K.D. MORSE		SAVE_SCOPE NOW DOES A SET
;	0091	!						MODULE ON THE SCOPE'S MODULE.
;	0092	!  04	06-APR-78	K.D. MORSE		PAT$FIND_DST now maps the GST
;	0093	!						instead of reading it.(22)  Added
;	0094	!  						routine POSITION_GST to chain
;	0095	!						through the mapped GST.  Also 
;	0096	!						the logic in DBG$GET_NXT_GST
;	0097	!						now calls POSITION_GST. (23)
;	0098	!						Bug fix in FIND_DST to skip the
;	0099	!						first 2 GST records OK. (24)  
;	0100	!						Bug fix in POSITION_GST - round
;	0101	!						up a record byte count. (24)
;	0102	!						GSR_NEXT_ADDR is now a REF VECTOR[,byte]. (24)
;	0103	!						Added code to BUILD_PATH to check
;	0104	!						for DEFine symbols before
;	0105	!						consulting the RST.  BUILD_PATH
;	0106	!						has the final word on whether
;	0107	!						a symbol has a value or not. (25)
;	0108	!						None for vers 26.
;	0109	!  05	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
;	0110	!  06	17-MAY-78	K.D. MORSE		ERROR MESSGES FROM GST/DST INIT.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 1-2
; Digital Equipment Corporation
;
;	0111	!						ARE NOW INFOR SEVERITY. (27)
;	0112	!						POSITION_GST CHECKS FOR NO GST (27).
;	0113	!						NO CHANGES FOR VERS 28.
;	0114	!						DELETE_PATH IS GLOBAL AND HAS NO
;	0115	!						FORMAL INPUT AND ALWAYS ZEROS
;	0116	!						THE PATH_VEC_PTR. (29)
;	0117	!						BETTER ERROR MSG IN SAVE_SCOPE (30).
;	0118	!  07	18-MAY-78	K.D. MORSE		CANCEL THE SCOPE IF THE MODULE
;	0119	!						IT POINTS TO IS CANCELLED. (31)
;	0120	!						POSITION_GST NOW SEES GST AS 3
;	0121	!						RECORDS LESS THAN HEADER SAYS
;	0122	!						NOT 2. (32)
;	0123	!						NOTE THE "ROUND UP" IN GET_NXT_GST
;	0124	!						TO RECOGNIZE END OF GST RECORD. (32)
;	0125	!						NO CHANGES FOR VERS 33.
;	0126	!  08	24-MAY-78	K.D. MORSE		ADD GSD TYPE 3 - PROCEDURE
;	0127	!						DEFINITION WITH FORMAL ARGUMENT
;	0128	!						DESCRIPTIONS.
;	0129	!  09	25-MAY-78	K.D. MORSE		ADD SIGNAL_FLAG PARAMETER TO
;	0130	!						PAT$BUILD_PATH FOR FORWARD
;	0131	!						REFERENCED SYMBOLS.
;	0132	!  10	13-JUN-78	K.D. MORSE		ADD FAO COUNT TO SIGNALS.
;	0133	!  11	20-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 34-36.
;	0134	!  12	28-JUN-78	K.D. MORSE		NO CHANGES FOR 37-38.
;	0135	!						PAT$FIND_MODULE HAS NEW ARG
;	0136	!						INDICATING WHETHER OR NOT TO
;	0137	!						SIGNAL IF MODULE IS NOT FOUND (39).
;	0138	!  13	29-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 40.
;	0139	!  14	07-JUL-78	K.D. MORSE		NO CHANGES FOR VERS 41.
;	0140	!
;	0141	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 2
; Digital Equipment Corporation
;
;	0142	!
;	0143	! TABLE OF CONTENTS:
;	0144	!
;	0145	
;	0146	FORWARD ROUTINE
;	0147		PAT$SAVE_SCOPE,						! Store away the current scope position
;	0148									! (CSP) vector.
;	0149		PAT$BUILD_PATH,						! Collect symbol pathnames and eventually
;	0150									!  try to evaluate them.
;	0151		PAT$DELETE_PATH : NOVALUE,				! Throw away a pathvector.
;	0152		PAT$FIND_MODULE,					! Scan MC for a given module name.
;	0153		PAT$RST_FREEZ,						! Storage allocator for anything which
;	0154									!  which is accessed via RST-pointers.
;	0155		PAT$RST_RELEASE : NOVALUE,				! Storage deallocator for anything which
;	0156									!  which is allocated by PAT$RST_FREEZ.
;	0157		PAT$FIND_DST : NOVALUE,					! Find the DST and make it available.
;	0158		PAT$GET_DST_REC,					! Make a certain DST record available.
;	0159		PAT$POSITON_DST,					! Make a certain DST record available
;	0160									! and set up for PAT$GET_NXT_DST
;	0161		POSITION_GST,						! Make a certain GST record available
;	0162		PAT$GET_NXT_DST,					! Make the next DST record available.
;	0163		PAT$GET_NXT_GST;					! Make the next GST record available
;	0164	
;	0165	
;	0166	!
;	0167	! INCLUDE FILES:
;	0168	!
;	0169	
;	0170	LIBRARY 'SYS$LIBRARY:LIB.L32';
;	0171	REQUIRE 'SRC$:PATPCT.REQ';
;	0187	REQUIRE 'LIB$:PATMSG.REQ';
;	0345	REQUIRE 'SRC$:IMGDEF.REQ';
;	0387	REQUIRE 'SRC$:PATGEN.REQ';
;	0566	REQUIRE 'SRC$:BSTRUC.REQ';
;	0617	REQUIRE 'SRC$:LISTEL.REQ';
;	0636	REQUIRE 'SRC$:DLLNAM.REQ';
;	0669	REQUIRE 'SRC$:PATRST.REQ';
;	1727	REQUIRE 'SRC$:VXSMAC.REQ';
;	1767	REQUIRE 'SRC$:SYSSER.REQ';
;      R1775	SWITCHES LIST (SOURCE);
;      R1776	
;      R1777	EXTERNAL ROUTINE
;      R1778		PAT$fao_out;		! formats a line and outputs to the terminal
;      R1779	
;      R1780	SWITCHES LIST (NOSOURCE);
;	1825	REQUIRE 'SRC$:SYSLIT.REQ';
;	1860	REQUIRE 'SRC$:PREFIX.REQ';
;	2043	REQUIRE 'SRC$:PATPRE.REQ';
;	2183	
;	2184	!
;	2185	! MACROS:
;	2186	!
;	2187	
;	2188	!
;	2189	! EQUATED SYMBOLS:

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 2-1
; Digital Equipment Corporation
;
;	2190	!
;	2191	
;	2192	!
;	2193	! OWN STORAGE:
;	2194	!
;	2195	
;	2196	OWN
;	2197		PATH_VEC_PTR : REF PATHNAME_VECTOR INITIAL( 0 ),	! Pointer to the pathname vector we are 
;	2198									! currently building.  If 0, no such vector
;	2199									! is under construction.
;	2200		DST_BEGIN_ADDR,						! virtual address where DST begins.
;	2201									! 0 => no DST.  Initially we do not
;	2202									! want to assume this.
;	2203		DST_END_ADDR,						! Virtual address of last byte in DST.
;	2204		DST_NEXT_ADDR,						! Virtual address where 'next' DST record begins.
;	2205	
;	2206		!++
;	2207		! Now GST symbols corresponding to the above DST symbols.
;	2208		!--
;	2209		GSR_BEGIN_ADDR,						! Virtual address where GST begins (0=no GST)
;	2210		GSR_NEXT_ADDR : REF VECTOR[,WORD],			! Virtual address where 'next' GST record begins
;	2211		GST_BEGIN_ADDR : REF GST_RECORD,			! Virtual address of current GST record (used only by GET_NXT_GSD)
;	2212		GSD_REC_COUNT;						! Count-down of GSD records.
;	2213	
;	2214	!
;	2215	! EXTERNAL REFERENCES:
;	2216	!
;	2217	EXTERNAL ROUTINE
;	2218		PAT$PV_TO_CS,						! Encode pathname vectors for printing.
;	2219		PAT$FIND_SYM,						! Lookup DEFine symbols
;	2220		PAT$SET_MODULE : NOVALUE,				! Adds module to the RST
;	2221		PAT$SYM_TO_VAL,						! Correspong pathnames and values.
;	2222		PAT$SYM_TO_VALU,					! Sym_to_val + goodies.
;	2223		PAT$INIT_RST : NOVALUE,					! Build all RST data structures.
;	2224		PAT$FREEZ,						! Standard PATCH storage allocator.
;	2225		PAT$FREERELEASE : NOVALUE,				! Standard PATCH storage deallocator.
;	2226		LIB$_CREMAPSEC;						! Creates and maps a global section
;	2227	
;	2228	EXTERNAL
;	2229		PAT$GB_SYMBOLS,						! Indicator if image contains symbols
;	2230		PAT$GL_IMGHDR : REF BLOCK[,BYTE],			! Pointer to image header
;	2231		PAT$GL_OLDNBK : BLOCK[,BYTE],				! Name block for input image file
;	2232		PAT$GB_OLDNAME,						! Ascii name of input image file
;	2233		PAT$GL_OLDRAB : BLOCK[,BYTE],				! Rab for input image file
;	2234		PAT$GL_ISVADDR : VECTOR[,LONG],				! Last pair of virtual addresses used
;	2235		PAT$GL_CSP_PTR : REF PATHNAME_VECTOR,			! The Current Scope Position (CSP)
;	2236									! is defined by a pointer to the
;	2237									! pathname vector which is the CSP.
;	2238		PAT$GL_MC_PTR : REF MC_RECORD,				! The module chain
;	2239		PAT$GL_RST_BEGN,					! Address of start of RST
;	2240		PAT$GL_HEAD_LST,					! Head of PATCH argument list
;	2241		PAT$GL_SYMTBPTR,					! Pointer to current symbol table
;	2242		PAT$GL_SYMHEAD;						! Pointer to user-defined symbol table listhead

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3
; Digital Equipment Corporation
;
;	2243	GLOBAL ROUTINE PAT$BUILD_PATH( SYMBOL_DESC, PASS_BACK_VALUE, SIGNAL_FLAG ) =
;	2244	
;	2245	!++
;	2246	! Functional Description:
;	2247	!
;	2248	!    This routine serves two fairly distinct purposes.
;	2249	!
;	2250	! 1. If SYMBOL_DESC is a valid string descriptor, (ie not = 0),
;	2251	!    then the call was made to BUILD_PATH so that it could
;	2252	!    accumulate the elements of a pathname in order to
;	2253	!    build up a pathname vector.
;	2254	!
;	2255	! 2. Otherwise, the 0 SYMBOL_DESC is a flag which signals that
;	2256	!    no more elements are to come and what we have accumulated
;	2257	!    is supposedly a complete pathname.  What we are to do then
;	2258	!    is to simply look up this pathname in the RST data base and
;	2259	!    return the corresponding value via the PASS_BACK_VALUE pointer.
;	2260	!
;	2261	!	When a lookup is done, the following priority is observed:
;	2262	!
;	2263	!	1) a pathname consisting of 1 element may first be:
;	2264	!		1) a permanent symbol name (e.g. "R0")
;	2265	!		2) a DEFine symbol
;	2266	!	2) if 1), above, is not the case, or if the pathname
;	2267	!	   is longer than 1 element, then the symbol must
;	2268	!	   be found in the RST or an error occurs.
;	2269	!
;	2270	! Calling Sequence:
;	2271	!
;	2272	!	PAT$BUILD_PATH ( SYMBOL_DESC, PASS_BACK_VALUE, SIGNAL_FLAG)
;	2273	!
;	2274	! Inputs:
;	2275	!
;	2276	!	SYMBOL_DESC	- String descriptor for next peice of pathname or
;	2277	!			  zero indicating accumulated pathname is to be
;	2278	!			  evaluated.
;	2279	!	PASS_BACK_VALUE	- Address of where to return the symbol's value
;	2280	!	SIGNAL_FLAG	- Flag indicating whether to signal error message
;	2281	!			  if symbol is undefined. (TRUE=yes, FALSE=no)
;	2282	!
;	2283	! Implicit Inputs:
;	2284	!
;	2285	!	This routine works from the OWN that is local to this
;	2286	!	module, PATH_VEC_PTR, which points to the current pathname vector
;	2287	!	we are building.  The reason why this is not local to BUILD_PATH
;	2288	!	is so that it can be shared by SAVE_SCOPE.
;	2289	!
;	2290	! Return Value:
;	2291	!
;	2292	!	On pathname accumulation, we return TRUE unless some error
;	2293	!	like PATCH running out of free storage occurs; then an error is SIGNALed.
;	2294	!
;	2295	!	On symbol evaluation, we return TRUE if the symbol was found
;	2296	!	in the image symbol tables and PAT$K_USER_DEF if the symbol was found
;	2297	!	in the user-defined symbol table.  If the symbol is undefined,

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3-1
; Digital Equipment Corporation
;
;	2298	!	then depending upon SIGNAL_FLAG either an error message is SIGNALed
;	2299	!	and an UNWIND is done, or PAT$BUILD_PATH returns FALSE.  This is to
;	2300	!	handle forward references inside symbolic instructions.
;	2301	!--
;	2302	
;	2303	BEGIN
;	2304	
;	2305	MAP
;	2306		SYMBOL_DESC : REF BLOCK[,BYTE],				! This describes the element of the
;	2307									! pathname which we are to add on
;	2308									! to our list.
;	2309		PASS_BACK_VALUE : REF VECTOR[,LONG];			! This is where we are to pass back
;	2310									! the pathname value to.
;	2311	
;	2312	OWN
;	2313		PV_INDEX;						! We use an OWN index into the OWN
;	2314									! pathname vector so that on each call
;	2315									! we know where we're at.
;	2316	
;	2317	LOCAL
;	2318		CS_PTR : CS_POINTER,					! Temp counted string pointer.
;	2319		STATUS;							! Success/failure indication that we return.
;	2320	
;	2321	!++
;	2322	! Now see whether a pathname translation to symbolic value
;	2323	! is to occur. This is signaled by the flag SYMBOL_DESC being
;	2324	! equal to 0.
;	2325	!--
;	2326	IF (.SYMBOL_DESC EQL 0)
;	2327	THEN
;	2328		BEGIN
;	2329		!++
;	2330		! Evaluate the symbol.  First, for single-element pathnames we give
;	2331		! priority to the so-called PATCH permanent symbols, and to the symbols
;	2332		! DEFined by the user at PATCH-time.  No longer pathname could be such
;	2333		! a thing.
;	2334		!-- 
;	2335		STATUS = 0;
;	2336		IF (.PATH_VEC_PTR[1] EQL 0)
;	2337		THEN
;	2338			BEGIN
;	2339			LOCAL
;	2340				TEMP_SYM_TBL,
;	2341				DEF_SYM_DESC : BLOCK[8,BYTE];
;	2342	
;	2343			!++
;	2344			! A 1-element pathname may be or a DEFine symbol.  First build
;	2345			! a string descriptor for the name (since this is what
;	2346			! PAT$FIND_SYM wants).
;	2347			!--
;	2348			CS_PTR = .PATH_VEC_PTR[0];
;	2349			DEF_SYM_DESC[DSC$W_LENGTH] = .CS_PTR[0];
;	2350			DEF_SYM_DESC[DSC$A_POINTER] = CS_PTR[1];
;	2351	
;	2352			!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3-2
; Digital Equipment Corporation
;
;	2353			! The symbol is not a permanent one.  Now lookup it up in the
;	2354			! linked list reserved for DEFine symbols.
;	2355			!--	
;	2356			TEMP_SYM_TBL = .PAT$GL_SYMTBPTR;		! Remember curren symbol table
;	2357			PAT$GL_SYMTBPTR = .PAT$GL_SYMHEAD;		! Use user-defined symbol table
;	2358			STATUS = PAT$FIND_SYM(DEF_SYM_DESC);
;	2359			PAT$GL_SYMTBPTR = .TEMP_SYM_TBL;		! Restore current symbol table
;	2360	
;	2361			!++
;	2362			! If we found something, pass back the associated value
;	2363			! and set STATUS to the appropriate success code.
;	2364			!--	
;	2365			IF (.STATUS NEQ 0)
;	2366			THEN
;	2367				BEGIN
;	2368				PASS_BACK_VALUE[0] = .SYM_VALUE(.STATUS);
;	2369				STATUS = PAT$K_USER_DEF;
;	2370				END;
;	2371			END;
;	2372	
;	2373		!++
;	2374		! Now, if we didn't get something from the DEFine
;	2375		! or permanent symbol data bases, try the RST.
;	2376		!--
;	2377		IF (NOT .STATUS)
;	2378		THEN
;	2379			STATUS = PAT$SYM_TO_VAL( .PATH_VEC_PTR, .PASS_BACK_VALUE);
;	2380			
;	2381		!++
;	2382		! If no translation can be found, Check whether to SIGNAL an error
;	2383		! and cause an UNWIND or return FALSE.
;	2384		!--	
;	2385		IF (NOT .STATUS)
;	2386		THEN
;	2387			BEGIN
;	2388			LOCAL MESSAGE_BUF : VECTOR[TTY_OUT_WIDTH,BYTE];
;	2389	
;	2390			!++
;	2391			! Encode the pathname into a counted
;	2392			! string, and output the associated message.
;	2393			!--
;	2394			PAT$PV_TO_CS( .PATH_VEC_PTR, MESSAGE_BUF );
;	2395			PAT$DELETE_PATH();
;	2396			PATH_VEC_PTR = 0;
;	2397	
;	2398			!++
;	2399			! Check if this might be a forward reference and therefore
;	2400			! should not be signaled as an error.
;	2401			!--
;	2402			IF (NOT .SIGNAL_FLAG)
;	2403			THEN
;	2404				RETURN(FALSE)
;	2405			ELSE
;	2406				SIGNAL(PAT$_NOSYMBOL, 1, MESSAGE_BUF ); ! no return
;	2407			END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3-3
; Digital Equipment Corporation
;
;	2408	
;	2409		!++
;	2410		! If the evaluation succeeded, discard the pathname vector and 
;	2411		! return success.
;	2412		!--
;	2413		PAT$DELETE_PATH();
;	2414		RETURN(.STATUS);
;	2415		END;
;	2416	
;	2417	!++
;	2418	! A real string descriptor is supposed to pass on to us another pathname
;	2419	! element to accumulate.
;	2420	!
;	2421	! If this is the first call for a new pathname, we must allocate the storage
;	2422	! we will need for the vector of pointers to the element strings.
;	2423	!--
;	2424	IF (.PATH_VEC_PTR EQL 0)
;	2425	THEN
;	2426		BEGIN
;	2427		IF ((PATH_VEC_PTR = PAT$freez(RST_UNITS(%SIZE(PATHNAME_VECTOR)))) EQL 0)
;	2428		THEN
;	2429			SIGNAL(PAT$_NOFREE);				! No more storage.
;	2430	
;	2431		!++
;	2432		! The storage manager zeros out the pathname vector for us, so we only
;	2433		! have to set up the right pathname vector index.
;	2434		!--
;	2435		PV_INDEX = 0;
;	2436		END;
;	2437	
;	2438	!++
;	2439	! Now we need space for the element name itself, (including the count! ).
;	2440	!--
;	2441	IF ((CS_PTR = PAT$freez(RST_UNITS(.SYMBOL_DESC[DSC$W_LENGTH]+1))) EQL 0)
;	2442	THEN
;	2443		SIGNAL(PAT$_NOFREE);					! No more storage.
;	2444	
;	2445	!++
;	2446	! Copy the string into the allocated storage. Note that we must make up a counted
;	2447	! string because this is what pathname vector pointers are defined to point to.
;	2448	!--
;	2449	CS_PTR[0] = .SYMBOL_DESC[DSC$W_LENGTH];
;	2450	CH$MOVE( .SYMBOL_DESC[DSC$W_LENGTH], .SYMBOL_DESC[DSC$A_POINTER], CS_PTR[1] );
;	2451	
;	2452	!++
;	2453	! Now store the address of this counted string in  the 'next' slot in the
;	2454	! pathname vector.
;	2455	!--
;	2456	PATH_VEC_PTR[.PV_INDEX] = .CS_PTR;
;	2457	
;	2458	!++
;	2459	! And set up so that the next call to this routine stores the CS pointer into the
;	2460	! next slot.
;	2461	!--
;	2462	IF ((PV_INDEX = .PV_INDEX +1) GTR MAX_PATH_SIZE)

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3-4
; Digital Equipment Corporation
;
;	2463	THEN
;	2464		BEGIN
;	2465		SIGNAL (PAT$_PATHTLONG);
;	2466		RETURN(FALSE);
;	2467		END;
;	2468	RETURN(TRUE);
;	2469	END;


							    .TITLE  PATINT
							    .IDENT  \X01.14\

							    .PSECT  _PAT$OWN,NOEXE,2

					      00000 PATH_VEC_PTR:
							    .LONG   0							      ;
					      00004 DST_BEGIN_ADDR:
							    .BLKB   4
					      00008 DST_END_ADDR:
							    .BLKB   4
					      0000C DST_NEXT_ADDR:
							    .BLKB   4
					      00010 GSR_BEGIN_ADDR:
							    .BLKB   4
					      00014 GSR_NEXT_ADDR:
							    .BLKB   4
					      00018 GST_BEGIN_ADDR:
							    .BLKB   4
					      0001C GSD_REC_COUNT:
							    .BLKB   4
					      00020 PV_INDEX:
							    .BLKB   4

						    ISE$C_SIZE==	20
						    TXT$C_SIZE==	4
						    PAL$C_SIZE==	16
						    ASD$C_SIZE==	9
						    FWR$C_SIZE==	24
							    .GLOBL  PAT$GL_RST_BEGN, PAT$FAO_OUT, PAT$PV_TO_CS, PAT$FIND_SYM
							    .GLOBL  PAT$SET_MODULE, PAT$SYM_TO_VAL, PAT$SYM_TO_VALU
							    .GLOBL  PAT$INIT_RST, PAT$FREEZ, PAT$FREERELEASE, LIB$_CREMAPSEC
							    .GLOBL  PAT$GB_SYMBOLS, PAT$GL_IMGHDR, PAT$GL_OLDNBK, PAT$GB_OLDNAME
							    .GLOBL  PAT$GL_OLDRAB, PAT$GL_ISVADDR, PAT$GL_CSP_PTR
							    .GLOBL  PAT$GL_MC_PTR, PAT$GL_HEAD_LST, PAT$GL_SYMTBPTR
							    .GLOBL  PAT$GL_SYMHEAD
							    .WEAK   ACCESS_CHECK

							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 00000 	    .ENTRY  PAT$BUILD_PATH, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11      ; 2243
		         57 00000000G  EF  9E 00002 	    MOVAB   PAT$FREEZ, R7					      ;
		         58 00000000V  EF  9E 00009 	    MOVAB   PAT$DELETE_PATH, R8					      ;
		         59 00000000G  EF  9E 00010 	    MOVAB   PAT$GL_SYMTBPTR, R9					      ;
		         5A 00000000G  00  9E 00017 	    MOVAB   LIB$SIGNAL, R10					      ;
		         5B 00000000'  EF  9E 0001E 	    MOVAB   PATH_VEC_PTR, R11					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3-5
; Digital Equipment Corporation
;
		         5E	FF7C   CE  9E 00025 	    MOVAB   -132(SP), SP					      ;
		         53	  04   AC  D0 0002A 	    MOVL    SYMBOL_DESC, R3					      ; 2326
				       79  12 0002E 	    BNEQ    3$							      ;
				       52  D4 00030 	    CLRL    STATUS						      ; 2335
		         50	       6B  D0 00032 	    MOVL    PATH_VEC_PTR, R0					      ; 2336
				  04   A0  D5 00035 	    TSTL    4(R0)						      ;
				       32  12 00038 	    BNEQ    1$							      ;
		         56	       60  D0 0003A 	    MOVL    (R0), CS_PTR					      ; 2348
		    7C   AE	       66  9B 0003D 	    MOVZBW  (CS_PTR), DEF_SYM_DESC				      ; 2349
      FC   AD	         56	       01  C1 00041 	    ADDL3   #1, CS_PTR, DEF_SYM_DESC+4				      ; 2350
		         54	       69  D0 00046 	    MOVL    PAT$GL_SYMTBPTR, TEMP_SYM_TBL			      ; 2356
		         69 00000000G  EF  D0 00049 	    MOVL    PAT$GL_SYMHEAD, PAT$GL_SYMTBPTR			      ; 2357
				  7C   AE  9F 00050 	    PUSHAB  DEF_SYM_DESC					      ; 2358
	      00000000G  EF	       01  FB 00053 	    CALLS   #1, PAT$FIND_SYM					      ;
		         52	       50  D0 0005A 	    MOVL    R0, STATUS						      ;
		         69	       54  D0 0005D 	    MOVL    TEMP_SYM_TBL, PAT$GL_SYMTBPTR			      ; 2359
				       52  D5 00060 	    TSTL    STATUS						      ; 2365
				       08  13 00062 	    BEQL    1$							      ;
		    08   BC	  08   A2  D0 00064 	    MOVL    8(STATUS), @PASS_BACK_VALUE				      ; 2368
		         52	       03  D0 00069 	    MOVL    #3, STATUS						      ; 2369
		         33	       52  E8 0006C 1$:     BLBS    STATUS, 2$						      ; 2377
				  08   AC  DD 0006F 	    PUSHL   PASS_BACK_VALUE					      ; 2379
				       6B  DD 00072 	    PUSHL   PATH_VEC_PTR					      ;
	      00000000G  EF	       02  FB 00074 	    CALLS   #2, PAT$SYM_TO_VAL					      ;
		         52	       50  D0 0007B 	    MOVL    R0, STATUS						      ;
		         21	       52  E8 0007E 	    BLBS    STATUS, 2$						      ; 2385
				       5E  DD 00081 	    PUSHL   SP							      ; 2394
				       6B  DD 00083 	    PUSHL   PATH_VEC_PTR					      ;
	      00000000G  EF	       02  FB 00085 	    CALLS   #2, PAT$PV_TO_CS					      ;
		         68	       00  FB 0008C 	    CALLS   #0, PAT$DELETE_PATH					      ; 2395
				       6B  D4 0008F 	    CLRL    PATH_VEC_PTR					      ; 2396
		         78	  0C   AC  E9 00091 	    BLBC    SIGNAL_FLAG, 8$					      ; 2402
				       5E  DD 00095 	    PUSHL   SP							      ; 2406
				       01  DD 00097 	    PUSHL   #1							      ;
			    006D8070   8F  DD 00099 	    PUSHL   #7176304						      ;
		         6A	       03  FB 0009F 	    CALLS   #3, LIB$SIGNAL					      ;
		         68	       00  FB 000A2 2$:     CALLS   #0, PAT$DELETE_PATH					      ; 2413
		         50	       52  D0 000A5 	    MOVL    STATUS, R0						      ; 2414
					   04 000A8 	    RET     							      ;
				       6B  D5 000A9 3$:     TSTL    PATH_VEC_PTR					      ; 2424
				       16  12 000AB 	    BNEQ    5$							      ;
				       0B  DD 000AD 	    PUSHL   #11							      ; 2427
		         67	       01  FB 000AF 	    CALLS   #1, PAT$FREEZ					      ;
		         6B	       50  D0 000B2 	    MOVL    R0, PATH_VEC_PTR					      ;
				       09  12 000B5 	    BNEQ    4$							      ;
			    006D80FA   8F  DD 000B7 	    PUSHL   #7176442						      ; 2429
		         6A	       01  FB 000BD 	    CALLS   #1, LIB$SIGNAL					      ;
				  20   AB  D4 000C0 4$:     CLRL    PV_INDEX						      ; 2435
		         50	       63  3C 000C3 5$:     MOVZWL  (R3), R0						      ; 2441
		         50	       04  C0 000C6 	    ADDL2   #4, R0						      ;
	   7E	         50	       04  C7 000C9 	    DIVL3   #4, R0, -(SP)					      ;
		         67	       01  FB 000CD 	    CALLS   #1, PAT$FREEZ					      ;
		         56	       50  D0 000D0 	    MOVL    R0, CS_PTR						      ;
				       09  12 000D3 	    BNEQ    6$							      ;
			    006D80FA   8F  DD 000D5 	    PUSHL   #7176442						      ; 2443

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 3-6
; Digital Equipment Corporation
;
		         6A	       01  FB 000DB 	    CALLS   #1, LIB$SIGNAL					      ;
		         66	       63  90 000DE 6$:     MOVB    (R3), (CS_PTR)					      ; 2449
      01   A6	    04   B3	       63  28 000E1 	    MOVC3   (R3), @4(R3), 1(CS_PTR)				      ; 2450
		         50	  20   AB  D0 000E7 	    MOVL    PV_INDEX, R0					      ; 2456
		    00 BB40	       56  D0 000EB 	    MOVL    CS_PTR, @PATH_VEC_PTR[R0]				      ;
	   50	    20   AB	       01  C1 000F0 	    ADDL3   #1, PV_INDEX, R0					      ; 2462
		    20   AB	       50  D0 000F5 	    MOVL    R0, PV_INDEX					      ;
		         0A	       50  D1 000F9 	    CMPL    R0, #10						      ;
				       0B  15 000FC 	    BLEQ    7$							      ;
			    006D813A   8F  DD 000FE 	    PUSHL   #7176506						      ; 2465
		         6A	       01  FB 00104 	    CALLS   #1, LIB$SIGNAL					      ;
				       04  11 00107 	    BRB     8$							      ; 2466
		         50	       01  D0 00109 7$:     MOVL    #1, R0						      ; 2468
					   04 0010C 	    RET     							      ;
				       50  D4 0010D 8$:     CLRL    R0							      ; 2243
					   04 0010F 	    RET     							      ;

; Routine Size:  272 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 4
; Digital Equipment Corporation
;
;	2470	GLOBAL ROUTINE PAT$DELETE_PATH : NOVALUE =
;	2471	
;	2472	!++
;	2473	! Functional Description:
;	2474	!
;	2475	!	Delete the pathname vector we are passed a pointer to by the OWN,
;	2476	!	PATH_VEC_PTR, which several routines in this module work from.  Also,
;	2477	!	zero out this pointer so that the next call to BUILD_PATH knows
;	2478	!	there is no 'current' pathname vector being built.
;	2479	!
;	2480	! Formal Parameters:
;	2481	!
;	2482	!	none
;	2483	!
;	2484	! Implicit Inputs:
;	2485	!
;	2486	!	PATH_VEC_PTR - See above.
;	2487	!
;	2488	! Return Value:
;	2489	!
;	2490	!	NOVALUE - because the only thing which can go wrong
;	2491	!		  is a free storage error and in that
;	2492	!		  case the manager itself SIGNALs its way out.
;	2493	!
;	2494	!--
;	2495	
;	2496	BEGIN
;	2497	
;	2498	LOCAL
;	2499		CS_PTR : CS_POINTER;					! Each element of the pathname vector
;	2500									! is a pointer to a counted string.
;	2501	
;	2502	!++
;	2503	! Now see if there is really a pathname vector currently pointed to by the
;	2504	! pointer, PATH_VEC_PTR.
;	2505	!--
;	2506	IF (.PATH_VEC_PTR EQLA 0)
;	2507	THEN
;	2508		RETURN;
;	2509	
;	2510	!++
;	2511	! Simply throw away the storage which we allocated
;	2512	! for each element of the vector.
;	2513	!-
;	2514	INCR I FROM 0 TO MAX_PATH_SIZE
;	2515	DO
;	2516		!++
;	2517		! The first 0 entry ends the vector.
;	2518		!--
;	2519		IF ((CS_PTR = .PATH_VEC_PTR[.I]) EQL 0)
;	2520		THEN
;	2521			EXITLOOP
;	2522		ELSE
;	2523			PAT$FREERELEASE( .CS_PTR, RST_UNITS(.CS_PTR[0]+1) );
;	2524	

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 4-1
; Digital Equipment Corporation
;
;	2525	!++
;	2526	! Then throw away the vector itself.
;	2527	!--
;	2528	PAT$FREERELEASE( .PATH_VEC_PTR, RST_UNITS( %SIZE(PATHNAME_VECTOR) ));
;	2529	
;	2530	!++
;	2531	! Zero out the pointer so that subsequent re-uses know there is no longer
;	2532	! one there.
;	2533	!--
;	2534	PATH_VEC_PTR = 0;
;	2535	
;	2536	END;





					 0C0C 00110 	    .ENTRY  PAT$DELETE_PATH, Save R2,R3,R10,R11			      ; 2470
		         5A 00000000G  EF  9E 00112 	    MOVAB   PAT$FREERELEASE, R10				      ;
		         5B 00000000'  EF  9E 00119 	    MOVAB   PATH_VEC_PTR, R11					      ;
				       6B  D5 00120 	    TSTL    PATH_VEC_PTR					      ; 2506
				       25  13 00122 	    BEQL    3$							      ;
				       52  D4 00124 	    CLRL    I							      ; 2514
		         53	  00 BB42  D0 00126 1$:     MOVL    @PATH_VEC_PTR[I], CS_PTR				      ; 2519
				       13  13 0012B 	    BEQL    2$							      ;
		         50	       63  9A 0012D 	    MOVZBL  (CS_PTR), R0					      ; 2523
		         50	       04  C0 00130 	    ADDL2   #4, R0						      ;
	   7E	         50	       04  C7 00133 	    DIVL3   #4, R0, -(SP)					      ;
				       53  DD 00137 	    PUSHL   CS_PTR						      ;
		         6A	       02  FB 00139 	    CALLS   #2, PAT$FREERELEASE					      ;
	   E6	         52	       0A  F3 0013C 	    AOBLEQ  #10, I, 1$						      ; 2514
				       0B  DD 00140 2$:     PUSHL   #11							      ; 2528
				       6B  DD 00142 	    PUSHL   PATH_VEC_PTR					      ;
		         6A	       02  FB 00144 	    CALLS   #2, PAT$FREERELEASE					      ;
				       6B  D4 00147 	    CLRL    PATH_VEC_PTR					      ; 2534
					   04 00149 3$:     RET     							      ; 2470

; Routine Size:  58 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 5
; Digital Equipment Corporation
;
;	2537	GLOBAL ROUTINE PAT$SAVE_SCOPE( SET_SCOPE_FLAG ) =
;	2538	
;	2539	!++
;	2540	! Functional Description:
;	2541	!
;	2542	!    This routine serves two fairly distinct purposes.
;	2543	!
;	2544	! 1. IF SET_SCOPE_FLAG is ON, then this routine was
;	2545	!    called to SET the new current scope position (CSP).
;	2546	!    In this case we delete the storage taken by the old
;	2547	!    CSP, if there was any, and install the new CSP
;	2548	!    having checked its validity.
;	2549	!	SET SCOPE also implies SET MODULE.
;	2550	!
;	2551	! 2. If SET_SCOPE_FLAG is OFF, then the call was made to simply
;	2552	!    install a null CSP vector.  This happens as a result of the user
;	2553	!    cancelling scope, or cancelling a module whose name is the same as what the
;	2554	!    CSP pathname begins with.  The latter avoids the 'dangling scope' problem.
;	2555	!
;	2556	! Implicit Inputs:
;	2557	!
;	2558	!	This routine works from the OWN that is local to this
;	2559	!	module, PATH_VEC_PTR, which points to the current pathname vector
;	2560	!	which was (presumably) built by BUILD_PATH.  We store
;	2561	!	away this pathname vector pointer, and then zero out the
;	2562	!	one that BUILD_PATH uses so that it 'forgets' completely
;	2563	!	about having built it.
;	2564	!
;	2565	! Return Value:
;	2566	!
;	2567	! TRUE, if we are simply throwing away the old CSP,
;	2568	!       or if we installed a new one which was acceptable,
;	2569	! FALSE, otherwise.  (we were asked to install one which was invalid).
;	2570	!
;	2571	!--
;	2572	
;	2573	BEGIN
;	2574	
;	2575	LOCAL
;	2576		NEW_CSP_PTR : REF PATHNAME_VECTOR,
;	2577		MC_PTR : REF MC_RECORD,					! Used to chain along the MC.
;	2578		CS_PTR : CS_POINTER,					! Temp counted string pointer.
;	2579		STATUS;							! Success/failure indication that we return.
;	2580	
;	2581	!++
;	2582	! The gross structure of this routine just implements the two-function logic.
;	2583	!--
;	2584	IF (.SET_SCOPE_FLAG)
;	2585	THEN
;	2586		BEGIN
;	2587		!++
;	2588		! Install a new CSP vector. Check that the CSP we were given is valid.
;	2589		! First, see if the beginning element of the pathvector (which must be
;	2590		! MODULE) is in the MC.  Note that we don't consider the first entry in
;	2591		! the MC since it is used for globals only and hence is nameless.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 5-1
; Digital Equipment Corporation
;
;	2592		!--
;	2593		CS_PTR = .PATH_VEC_PTR[0];
;	2594		MC_PTR = .PAT$GL_MC_PTR;
;	2595		WHILE ((MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0)
;	2596		DO
;	2597			BEGIN
;	2598			IF (CH$EQL(.MC_PTR[MC_NAME_CS], MC_PTR[MC_NAME_ADDR],
;	2599					.CS_PTR[0], CS_PTR[1]))
;	2600			THEN
;	2601				EXITLOOP				! Found.  Continue on to do further checking.
;	2602			END;
;	2603	
;	2604		!++
;	2605		! If the module name was not found, we must not accept the CSP.
;	2606		!--
;	2607		IF (.MC_PTR EQL 0)
;	2608		THEN
;	2609			BEGIN
;	2610			!++
;	2611			! This is an error.  Note that if there was previous to this
;	2612			! call a valid CSP, it is not affected by this error.  ALso note
;	2613			! that the storage for the CSP we just found to be invalid is
;	2614			! discarded by the end-of-line processing AFTER the SIGNAL
;	2615			! produces the message.
;	2616			!--
;	2617			SIGNAL(PAT$_NOSUCHMODU,1,.CS_PTR);
;	2618			RETURN(FALSE);
;	2619			END;
;	2620	
;	2621		!++
;	2622		! Make sure that the indicated module is in the RST so that
;	2623		! further checking can be done and because a "set scope" implies a
;	2624		! "SET MODULE" command.
;	2625		!--
;	2626		IF NOT .MC_PTR[MC_IN_RST]
;	2627		THEN
;	2628			PAT$SET_MODULE(.MC_PTR);			! IF THIS FAILS, THERE IS NOT RETURN FROM THIS CALL
;	2629	
;	2630		!++
;	2631		! The module name is valid and in the RST.  Any further checking depends
;	2632		! on whether the given CSP is any longer than simply "module".  If this
;	2633		! is the case, we've done all the validating we can.
;	2634		!--
;	2635		IF (.PATH_VEC_PTR[1] NEQ 0)
;	2636		THEN
;	2637			BEGIN
;	2638			!++
;	2639			! Further checking is RST-dependent.
;	2640			!--
;	2641			LOCAL
;	2642				VAL_DESC : VALU_DESCRIPTOR,
;	2643				NT_PTR : REF NT_RECORD;
;	2644	
;	2645			!++
;	2646			! For initialized modules, we can do a complete check.

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 5-2
; Digital Equipment Corporation
;
;	2647			! This means that we effectively do a lookup, and then
;	2648			! make sure that the path leads to a symbol of type
;	2649			! ROUTINE.
;	2650			!--
;	2651			IF (NOT PAT$SYM_TO_VALU( .PATH_VEC_PTR, VAL_DESC))
;	2652			THEN
;	2653				BEGIN
;	2654				!++
;	2655				! Encode the pathname into a counted string and output
;	2656				! the associated message.
;	2657				!--
;	2658				LOCAL MESSAGE_BUF : VECTOR[TTY_OUT_WIDTH, BYTE];
;	2659	
;	2660				PAT$PV_TO_CS(.PATH_VEC_PTR, MESSAGE_BUF);
;	2661				SIGNAL(PAT$_NOSYMBOL, 1, MESSAGE_BUF);	! No return
;	2662				RETURN(FALSE);			!****** THIS SHOULDN'T BE NEEDED
;	2663				END;
;	2664	
;	2665			!++
;	2666			! Now we simply have to see that the valid path leads
;	2667			! to ROUTINE.  First we pick up the pointer to this
;	2668			! symbol's name table record.
;	2669			!--	
;	2670			NT_PTR = .VAL_DESC [VALU_NT_PTR];
;	2671			IF (NOT .NT_PTR[NT_TYPE] EQL DSC$K_DTYPE_RTN)
;	2672			THEN
;	2673				BEGIN
;	2674				!++
;	2675				! A valid path, but we can't accept it as a CSP
;	2676				! because perpending it to any symbol would
;	2677				! never result in a valid path.
;	2678				!--	
;	2679				SIGNAL(PAT$_BADCSP);
;	2680				RETURN(FALSE);
;	2681				END;
;	2682			END;
;	2683		!++
;	2684		! The CSP we are to SET has been checked out OK.
;	2685		!--
;	2686		NEW_CSP_PTR = .PATH_VEC_PTR;
;	2687		END;
;	2688	
;	2689	!++
;	2690	! If we get this far, the new CSP will be accepted. First, we have to release
;	2691	! the storage we used up in accumulating the pathname elements of the  old CSP,
;	2692	! if there was one.
;	2693	!--
;	2694	IF ((PATH_VEC_PTR = .PAT$GL_CSP_PTR) NEQ 0)
;	2695	THEN
;	2696		BEGIN
;	2697		PAT$DELETE_PATH();
;	2698		END;
;	2699	!++
;	2700	! If we were only throwing away the old vector, then we must be done.
;	2701	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 5-3
; Digital Equipment Corporation
;
;	2702	IF (NOT .SET_SCOPE_FLAG)
;	2703	THEN
;	2704		BEGIN
;	2705		PAT$GL_CSP_PTR = 0;
;	2706		RETURN(TRUE);
;	2707		END;
;	2708	
;	2709	!++
;	2710	! Installing a new CSP is simply a matter of saving away the pointer to the
;	2711	! PATHNAME_VECTOR.  We must also zero out the pointer to the vector which
;	2712	! BUILD_PATH uses to deal with these vectors, since we have effectively taken
;	2713	! this one away.
;	2714	!--
;	2715	PAT$GL_CSP_PTR = .NEW_CSP_PTR;
;	2716	PATH_VEC_PTR = 0;
;	2717	
;	2718	RETURN(TRUE);
;	2719	END;





					 0F7C 0014A 	    .ENTRY  PAT$SAVE_SCOPE, Save R2,R3,R4,R5,R6,R8,R9,R10,R11	      ; 2537
		         58 00000000G  00  9E 0014C 	    MOVAB   LIB$SIGNAL, R8					      ;
		         59 00000000G  EF  9E 00153 	    MOVAB   PAT$GL_CSP_PTR, R9					      ;
		         5A 00000000G  EF  9E 0015A 	    MOVAB   PAT$GL_RST_BEGN, R10				      ;
		         5B 00000000'  EF  9E 00161 	    MOVAB   PATH_VEC_PTR, R11					      ;
		         5E	FF74   CE  9E 00168 	    MOVAB   -140(SP), SP					      ;
		         03	  04   AC  E8 0016D 	    BLBS    SET_SCOPE_FLAG, 1$					      ; 2584
				     0098  31 00171 	    BRW     9$							      ;
		         56	  00   BB  D0 00174 1$:     MOVL    @PATH_VEC_PTR, CS_PTR				      ; 2593
		         55 00000000G  EF  D0 00178 	    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 2594
	   54	         55	       6A  C1 0017F 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R4				      ; 2595
		         55	       64  3C 00183 2$:     MOVZWL  (R4), MC_PTR					      ;
				       15  13 00186 	    BEQL    3$							      ;
	   54	         55	       6A  C1 00188 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R4				      ; 2598
		         51	  0C   A4  9A 0018C 	    MOVZBL  12(R4), R1						      ;
		         50	       66  9A 00190 	    MOVZBL  (CS_PTR), R0					      ; 2599
	   00	    0D   A4	       51  2D 00193 	    CMPC5   R1, 13(R4), #0, R0, 1(CS_PTR)			      ; 2598
		    01   A6	       50     00198									      ;
				       E6  12 0019B 	    BNEQ    2$							      ;
				       55  D5 0019D 3$:     TSTL    MC_PTR						      ; 2607
				       0C  12 0019F 	    BNEQ    4$							      ;
				       56  DD 001A1 	    PUSHL   CS_PTR						      ; 2617
				       01  DD 001A3 	    PUSHL   #1							      ;
			    006D8060   8F  DD 001A5 	    PUSHL   #7176288						      ;
				       3E  11 001AB 	    BRB     6$							      ;
	   50	         55	       6A  C1 001AD 4$:     ADDL3   PAT$GL_RST_BEGN, MC_PTR, R0				      ; 2626
	   09	    03   A0	       01  E0 001B1 	    BBS     #1, 3(R0), 5$					      ;
				       55  DD 001B6 	    PUSHL   MC_PTR						      ; 2628
	      00000000G  EF	       01  FB 001B8 	    CALLS   #1, PAT$SET_MODULE					      ;
		         50	       6B  D0 001BF 5$:     MOVL    PATH_VEC_PTR, R0					      ; 2635
				  04   A0  D5 001C2 	    TSTL    4(R0)						      ;
				       42  13 001C5 	    BEQL    8$							      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 5-4
; Digital Equipment Corporation
;
				  F8   AD  9F 001C7 	    PUSHAB  VAL_DESC						      ; 2651
				       50  DD 001CA 	    PUSHL   R0							      ;
	      00000000G  EF	       02  FB 001CC 	    CALLS   #2, PAT$SYM_TO_VALU					      ;
		         1A	       50  E8 001D3 	    BLBS    R0, 7$						      ;
				       5E  DD 001D6 	    PUSHL   SP							      ; 2660
				       6B  DD 001D8 	    PUSHL   PATH_VEC_PTR					      ;
	      00000000G  EF	       02  FB 001DA 	    CALLS   #2, PAT$PV_TO_CS					      ;
				       5E  DD 001E1 	    PUSHL   SP							      ; 2661
				       01  DD 001E3 	    PUSHL   #1							      ;
			    006D8070   8F  DD 001E5 	    PUSHL   #7176304						      ;
		         68	       03  FB 001EB 6$:     CALLS   #3, LIB$SIGNAL					      ;
				       37  11 001EE 	    BRB     13$							      ; 2662
		         50	  F8   AD  3C 001F0 7$:     MOVZWL  VAL_DESC, NT_PTR					      ; 2670
		         50	       6A  C0 001F4 	    ADDL2   PAT$GL_RST_BEGN, R0					      ; 2671
		    BE   8F	  02   A0  91 001F7 	    CMPB    2(R0), #190						      ;
				       0B  13 001FC 	    BEQL    8$							      ;
			    006D8040   8F  DD 001FE 	    PUSHL   #7176256						      ; 2679
		         68	       01  FB 00204 	    CALLS   #1, LIB$SIGNAL					      ;
				       1E  11 00207 	    BRB     13$							      ; 2680
		         52	       6B  D0 00209 8$:     MOVL    PATH_VEC_PTR, NEW_CSP_PTR				      ; 2686
		         6B	       69  D0 0020C 9$:     MOVL    PAT$GL_CSP_PTR, PATH_VEC_PTR			      ; 2694
				       05  13 0020F 	    BEQL    10$							      ;
		  FEFA   CF	       00  FB 00211 	    CALLS   #0, PAT$DELETE_PATH					      ; 2697
		         04	  04   AC  E8 00216 10$:    BLBS    SET_SCOPE_FLAG, 11$					      ; 2702
				       69  D4 0021A 	    CLRL    PAT$GL_CSP_PTR					      ; 2705
				       05  11 0021C 	    BRB     12$							      ; 2706
		         69	       52  D0 0021E 11$:    MOVL    NEW_CSP_PTR, PAT$GL_CSP_PTR				      ; 2715
				       6B  D4 00221 	    CLRL    PATH_VEC_PTR					      ; 2716
		         50	       01  D0 00223 12$:    MOVL    #1, R0						      ; 2718
					   04 00226 	    RET     							      ;
				       50  D4 00227 13$:    CLRL    R0							      ; 2537
					   04 00229 	    RET     							      ;

; Routine Size:  224 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 6
; Digital Equipment Corporation
;
;	2720	GLOBAL ROUTINE PAT$FIND_MODULE( MOD_NAME_DESC, SIGNAL_FLAG ) =
;	2721	
;	2722	!++
;	2723	! Functional Description:
;	2724	!
;	2725	!	Search the MC to see if the given module is there.
;	2726	!
;	2727	! Formal Parameters:
;	2728	!
;	2729	!	MOD_NAME_DESC	-a string descriptor for the supposed
;	2730	!			 module name.
;	2731	!	SIGNAL_FLAG	-indicator whether or not this routine should
;	2732	!			 SIGNAL if the module is not found
;	2733	!
;	2734	! Implicit Inputs:
;	2735	!
;	2736	!	none.
;	2737	!
;	2738	! Implicit Outputs:
;	2739	!
;	2740	!	none
;	2741	!
;	2742	! Returned Value:
;	2743	!
;	2744	!	0 - if the module is not found,
;	2745	!	an MC_PTR (non-zero) to the indicated MC record, otherwise.
;	2746	!
;	2747	! Side Effects:
;	2748	!
;	2749	!	none
;	2750	!--
;	2751	
;	2752	BEGIN
;	2753	MAP
;	2754		MOD_NAME_DESC : REF BLOCK[,BYTE];			! The supposed module name is
;	2755									! described via an SRM string descriptor.
;	2756	
;	2757	LOCAL
;	2758		MODU_CS_NAME : VECTOR[SYM_MAX_LENGTH+1, BYTE],		! COPY OF MODULE NAME FOR NOSUCHMODU ERROR MSG
;	2759		MC_PTR : REF MC_RECORD;					! We chain along the MC via this temp pointer.
;	2760	
;	2761	!++
;	2762	! Scan along the MC comparing the given string with the module name stored
;	2763	! therein.  Note that we skip the first MC record because it is reserved for
;	2764	! globals and is therefore nameless.
;	2765	!--
;	2766	MC_PTR = .PAT$GL_MC_PTR;
;	2767	WHILE ((MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0)
;	2768	DO
;	2769		BEGIN
;	2770		IF (CH$EQL(.MC_PTR[MC_NAME_CS],MC_PTR[MC_NAME_ADDR],
;	2771				.MOD_NAME_DESC[DSC$W_LENGTH],.MOD_NAME_DESC[DSC$A_POINTER] ))
;	2772		THEN
;	2773			BEGIN
;	2774			!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 6-1
; Digital Equipment Corporation
;
;	2775			! Found.  Internally in PATCH we agree that the 'value' of a
;	2776			! module string will be the RST address of its MC record.
;	2777			!--
;	2778			RETURN(.MC_PTR);
;	2779			END;
;	2780		END;
;	2781	
;	2782	!++
;	2783	! If we fall out of the above loop, then the given module name was not found.
;	2784	! Therefore if a SIGNAL is allowed, then construct a COUNTED_STRING pointer and
;	2785	! pass it as the error message argument.
;	2786	!--
;	2787	IF .SIGNAL_FLAG
;	2788	THEN
;	2789		BEGIN
;	2790		MODU_CS_NAME[0] = .MOD_NAME_DESC[DSC$W_LENGTH];
;	2791		CH$MOVE (.MODU_CS_NAME[0], .MOD_NAME_DESC[DSC$A_POINTER], MODU_CS_NAME[1]);
;	2792		SIGNAL(PAT$_NOSUCHMODU, 1, MODU_CS_NAME[0]);		! No return
;	2793		END;
;	2794	
;	2795	RETURN (0);
;	2796	END;





					 087C 0022A 	    .ENTRY  PAT$FIND_MODULE, Save R2,R3,R4,R5,R6,R11		      ; 2720
		         5B 00000000G  EF  9E 0022C 	    MOVAB   PAT$GL_RST_BEGN, R11				      ;
		         5E	       10  C2 00233 	    SUBL2   #16, SP						      ;
		         56 00000000G  EF  D0 00236 	    MOVL    PAT$GL_MC_PTR, MC_PTR				      ; 2766
	   54	         56	       6B  C1 0023D 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R4				      ; 2767
	   55	    04   AC	       04  C1 00241 	    ADDL3   #4, MOD_NAME_DESC, R5				      ; 2771
		         56	       64  3C 00246 1$:     MOVZWL  (R4), MC_PTR					      ; 2767
				       17  13 00249 	    BEQL    2$							      ;
	   54	         56	       6B  C1 0024B 	    ADDL3   PAT$GL_RST_BEGN, MC_PTR, R4				      ; 2770
		         50	  0C   A4  9A 0024F 	    MOVZBL  12(R4), R0						      ;
	   00	    0D   A4	       50  2D 00253 	    CMPC5   R0, 13(R4), #0, @MOD_NAME_DESC, @0(R5)		      ;
		    00   B5	  04   BC     00258									      ;
				       E8  12 0025C 	    BNEQ    1$							      ;
		         50	       56  D0 0025E 	    MOVL    MC_PTR, R0						      ; 2778
					   04 00261 	    RET     							      ;
		         1E	  08   AC  E9 00262 2$:     BLBC    SIGNAL_FLAG, 3$					      ; 2787
		         6E	  04   BC  90 00266 	    MOVB    @MOD_NAME_DESC, MODU_CS_NAME			      ; 2790
		         50	       6E  9A 0026A 	    MOVZBL  MODU_CS_NAME, R0					      ; 2791
      01   AE	    00   B5	       50  28 0026D 	    MOVC3   R0, @0(R5), MODU_CS_NAME+1				      ;
				       5E  DD 00273 	    PUSHL   SP							      ; 2792
				       01  DD 00275 	    PUSHL   #1							      ;
			    006D8060   8F  DD 00277 	    PUSHL   #7176288						      ;
	      00000000G  00	       03  FB 0027D 	    CALLS   #3, LIB$SIGNAL					      ;
				       50  D4 00284 3$:     CLRL    R0							      ; 2795
					   04 00286 	    RET     							      ; 2720

; Routine Size:  93 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 6-2
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7
; Digital Equipment Corporation
;
;	2797	GLOBAL ROUTINE PAT$FIND_DST : NOVALUE =
;	2798	
;	2799	!++
;	2800	! FUNCTIONAL DESCRIPTION:
;	2801	!
;	2802	!	Find out where the DST begins and make it available for
;	2803	!	PAT$GET_NXT_DST and PAT$GET_DST_REC.
;	2804	!	(or make it so that these routines return EOF if no DST exists).
;	2805	!	Then do the same for the GST.
;	2806	!
;	2807	! Calling Sequence:
;	2808	!
;	2809	!	PAT$FIND_DST()
;	2810	!
;	2811	! FORMAL PARAMETERS:
;	2812	!
;	2813	!	none
;	2814	!
;	2815	! IMPLICIT INPUTS:
;	2816	!
;	2817	!	The image header has been read and PAT$GL_IMGHDR points to it.
;	2818	!	The old image file is open and ready to read the DST and GST.
;	2819	!	The variables pointing to the file are:
;	2820	!		PAT$GL_OLDRAB, PAT$GL_OLDFAB, AND PAT$GL_OLDNAME.
;	2821	!
;	2822	! IMPLICIT OUTPUTS:
;	2823	!
;	2824	!	none
;	2825	!
;	2826	! COMPLETION CODES:
;	2827	!	none
;	2828	!
;	2829	! SIDE EFFECTS:
;	2830	!
;	2831	!	The notion of 'next' DST record is initialized
;	2832	!	here so that a call to PAT$GET_NXT_DST made after
;	2833	!	a call to this routine will fetch the first record.
;	2834	!
;	2835	!	The begin and end address of the DST are also established,
;	2836	!	but only for the purposes of the interface routines.
;	2837	!	There is no explicit requirement for this from the RST's 
;	2838	!	viewpoint - so long as the interface can somehow
;	2839	!	know when the last record has been passed on.
;	2840	!
;	2841	!	If anything goes wrong during the GST/DST initializations,
;	2842	!	(can't EXPREG, etc.), we output the corresponding message forcing
;	2843	!	the severity to -I-, and then continue on without the GST or DST.
;	2844	!	The exceptions to this are that there must be symbol table info in 
;	2845	!	the header (even if what's there is simply a pointer to say that 
;	2846	!	there is no DST or GST).
;	2847	!--
;	2848	
;	2849	BEGIN
;	2850	
;	2851	BIND

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-1
; Digital Equipment Corporation
;
;	2852		SYM_TBL_DATA = .PAT$GL_IMGHDR + .PAT$GL_IMGHDR [IHD$W_SYMDBGOFF]
;	2853						: BLOCK [, BYTE],
;	2854		EXESECNAM = UPLIT BYTE (%ASCIC 'DST'),
;	2855		GSTSECNAM = UPLIT BYTE (%ASCIC 'GST');
;	2856	
;	2857	LITERAL
;	2858		GL_OVERHEAD_REC	= 2,					! GST overhead records from Linker
;	2859		SYMS_PER_GLREC	= 28,					! Average GSTs per GST record.
;	2860		START_ADDRESS	= 0,					! Starting address offset
;	2861		END_ADDRESS	= 1;					! Ending address offset
;	2862	
;	2863	LOCAL
;	2864		STATUS : BLOCK[%UPVAL, BYTE],
;	2865		GLOBAL_RECORD : BLOCK [A_PAGE, BYTE],
;	2866		EXESECNAM_DESC : VECTOR [2, LONG],
;	2867		EXEFILNAM_DESC : VECTOR [2, LONG],
;	2868		GL_SYM_COUNT;
;	2869	
;	2870	!++
;	2871	! Check if this .EXE file has symbols at all.  There are two kinds of checks
;	2872	! which we make.  First, we see if the image header is consistent.
;	2873	! There are two checks for this - one which is always relevant, and one which
;	2874	! is relevant only if we have already determined that there will be DSTs.
;	2875	!--
;	2876	IF (.PAT$GL_IMGHDR [IHD$W_SYMDBGOFF] EQL 0)
;	2877	THEN
;	2878		BEGIN
;	2879		GST_BEGIN_ADDR = 0;
;	2880		DST_BEGIN_ADDR = 0;
;	2881		PAT$GB_SYMBOLS = FALSE;					! Indicate image has no symbols
;	2882		SIGNAL(PAT$_NOGBL+MSG$K_INFO);
;	2883		SIGNAL(PAT$_NOLCL+MSG$K_INFO);
;	2884		RETURN;
;	2885		END
;	2886	ELSE
;	2887		PAT$GB_SYMBOLS = TRUE;					! Indicate image has symbols
;	2888	
;	2889	!++
;	2890	! Then we see if this is a simple case of there legitimately not being a DST.
;	2891	! (i.e. the modules were simply not compiled with /DEBUG on).
;	2892	!--
;	2893	IF ((DST_BEGIN_ADDR = .SYM_TBL_DATA[IHS$W_DSTBLKS]) EQL 0)
;	2894	THEN
;	2895		BEGIN
;	2896		!++
;	2897		! Check that the VBN of the DST is also zero.  If it is not,
;	2898		! then the image header is contradictory.  Therefore, inform the
;	2899		! user and fix the header by setting the DST fields to zero.
;	2900		! This should only be an informational message.
;	2901		!--
;	2902		IF (.SYM_TBL_DATA[IHS$L_DSTVBN] NEQ 0)
;	2903		THEN
;	2904			SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
;	2905		SIGNAL(PAT$_NOLCL+MSG$K_INFO);
;	2906		DST_BEGIN_ADDR = 0;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-2
; Digital Equipment Corporation
;
;	2907		SYM_TBL_DATA[IHS$L_DSTVBN] = 0;
;	2908		SYM_TBL_DATA[IHS$W_DSTBLKS] = 0;
;	2909		END
;	2910	ELSE
;	2911		!++
;	2912		! Check that the VBN is legal.  If not, then this is an inconsistent
;	2913		! header.  Inform the user that it is invalid and
;	2914		! fix up the header, ignoring the symbols that might be there.
;	2915		!--
;	2916		IF (.SYM_TBL_DATA[IHS$L_DSTVBN] LEQ 2) OR
;	2917		   (.SYM_TBL_DATA[IHS$W_DSTBLKS] LSS 0)
;	2918		THEN
;	2919			BEGIN
;	2920			SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
;	2921			SIGNAL(PAT$_NOLCL+MSG$K_INFO);
;	2922			DST_BEGIN_ADDR = 0;
;	2923			SYM_TBL_DATA[IHS$L_DSTVBN] = 0;
;	2924			SYM_TBL_DATA[IHS$W_DSTBLKS] = 0;
;	2925			END;
;	2926	
;	2927	!++
;	2928	! Check that a GST exists.  If not, set an indicator.  Also make a valid image
;	2929	! header.  This insures PAT$WRTIMG will work correctly.
;	2930	!--
;	2931	IF ((GST_BEGIN_ADDR = .SYM_TBL_DATA[IHS$W_GSTRECS]) EQL 0)
;	2932	THEN
;	2933		BEGIN
;	2934		!++
;	2935		! Check that the VBN of the GST is also zero.  If it is not,
;	2936		! then the image header is contradictory.  Therefore, inform the
;	2937		! user and fix the header by setting the GST fields to zero.
;	2938		! This should only be an informational message.
;	2939		!--
;	2940		IF (.SYM_TBL_DATA[IHS$L_GSTVBN] NEQ 0)
;	2941		THEN
;	2942			SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
;	2943		SIGNAL(PAT$_NOGBL+MSG$K_INFO);
;	2944		GST_BEGIN_ADDR = 0;
;	2945		SYM_TBL_DATA[IHS$L_GSTVBN] = 0;
;	2946		SYM_TBL_DATA[IHS$W_GSTRECS] = 0;
;	2947		END
;	2948	ELSE
;	2949		!++
;	2950		! Check that the VBN is legal.  If not, then this is an inconsistent
;	2951		! header.  Inform the user that it is invalid and
;	2952		! fix up the header, ignoring the symbols that might be there.
;	2953		!--
;	2954		IF (.SYM_TBL_DATA[IHS$L_GSTVBN] LEQ 2) OR
;	2955		   (.SYM_TBL_DATA[IHS$W_GSTRECS] LSS 0)
;	2956		THEN
;	2957			BEGIN
;	2958			SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
;	2959			SIGNAL(PAT$_NOGBL+MSG$K_INFO);
;	2960			GST_BEGIN_ADDR = 0;
;	2961			SYM_TBL_DATA[IHS$L_GSTVBN] = 0;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-3
; Digital Equipment Corporation
;
;	2962			SYM_TBL_DATA[IHS$W_GSTRECS] = 0;
;	2963			END;
;	2964	
;	2965	!++
;	2966	! Don't try to create and map the DST if there is not one in the .EXE file to map in.
;	2967	!--
;	2968	IF (.DST_BEGIN_ADDR NEQ 0)
;	2969	THEN
;	2970		BEGIN
;	2971		PAT$GL_OLDRAB [RAB$L_UBF] = GLOBAL_RECORD;		! Set input buffer address
;	2972		PAT$GL_OLDRAB [RAB$W_USZ] = A_PAGE;			! Set input buffer size
;	2973		PAT$GL_ISVADDR [START_ADDRESS] = .PAT$GL_ISVADDR [END_ADDRESS] + 1;
;	2974		PAT$GL_ISVADDR [END_ADDRESS] = .PAT$GL_ISVADDR[END_ADDRESS] + 
;	2975						(.SYM_TBL_DATA[IHS$W_DSTBLKS] * A_PAGE);
;	2976		EXESECNAM_DESC [0] = 3;
;	2977		EXESECNAM_DESC [1] = EXESECNAM;
;	2978		EXEFILNAM_DESC [0] = .PAT$GL_OLDNBK[NAM$B_RSL];
;	2979		EXEFILNAM_DESC [1] = PAT$GB_OLDNAME;
;	2980	
;	2981		IF NOT (STATUS = LIB$_CREMAPSEC (PAT$GL_ISVADDR
;	2982						, PAT$GL_ISVADDR
;	2983						, 0
;	2984						, EXESECNAM_DESC
;	2985						, 0
;	2986						, EXEFILNAM_DESC
;	2987						, .SYM_TBL_DATA [IHS$W_DSTBLKS]
;	2988						, .SYM_TBL_DATA [IHS$L_DSTVBN]))
;	2989		THEN
;	2990			BEGIN
;	2991			!++
;	2992			! Unconditionally make the severity level informational so
;	2993			! that the message will be produced with no side effects.
;	2994			!--
;	2995	!		STATUS[STS$V_SEVERITY] = SYS$K_INFO;
;	2996			STATUS[STS$V_SEVERITY] = 3;
;	2997			DST_BEGIN_ADDR =0;
;	2998			SIGNAL(PAT$_CRMPSC-MSG$K_FATAL+MSG$K_INFO, 1, .STATUS);
;	2999			SIGNAL(.STATUS);
;	3000			END
;	3001		ELSE
;	3002			!++
;	3003			! Now load up the addresses of the beginning
;	3004			! and end of the DST.
;	3005			!--
;	3006			BEGIN
;	3007			DST_BEGIN_ADDR = .PAT$GL_ISVADDR [START_ADDRESS];
;	3008			DST_END_ADDR = .PAT$GL_ISVADDR [END_ADDRESS];
;	3009			DST_NEXT_ADDR = .DST_BEGIN_ADDR;
;	3010			END;
;	3011		END;							! For no DSTs.
;	3012	
;	3013	!++
;	3014	! Now map in the GST in the same way we did the DST.  Don't try to create and
;	3015	! map the GST if there is not one in the .exe file to map in.
;	3016	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-4
; Digital Equipment Corporation
;
;	3017	IF (.GST_BEGIN_ADDR NEQ 0)
;	3018	THEN
;	3019		BEGIN
;	3020		LOCAL
;	3021			GST_REC_PTR : REF VECTOR[,WORD];
;	3022	
;	3023		!++
;	3024		! Find the last mapped address used and compute the addresses into
;	3025		! which the GST will be mapped.
;	3026		!--
;	3027		PAT$GL_OLDRAB[RAB$L_UBF] = GLOBAL_RECORD;		! Set input buffer address
;	3028		PAT$GL_OLDRAB[RAB$W_USZ] = A_PAGE;			! Set input buffer size
;	3029		PAT$GL_ISVADDR[START_ADDRESS] = .PAT$GL_ISVADDR[END_ADDRESS] + 1;
;	3030	
;	3031	!***  NEED SOME SMARTS HERE TO CONVERT GSTRECS TO NUMBER OF BLOCKS
;	3032		PAT$GL_ISVADDR[END_ADDRESS] = .PAT$GL_ISVADDR[END_ADDRESS] +
;	3033						(.SYM_TBL_DATA[IHS$W_GSTRECS] * A_PAGE);
;	3034		EXESECNAM_DESC [0] = 3;
;	3035		EXESECNAM_DESC [1] = GSTSECNAM;
;	3036		EXEFILNAM_DESC [0] = .PAT$GL_OLDNBK[NAM$B_RSL];
;	3037		EXEFILNAM_DESC [1] = PAT$GB_OLDNAME;
;	3038	
;	3039		IF NOT (STATUS = LIB$_CREMAPSEC (PAT$GL_ISVADDR
;	3040						, PAT$GL_ISVADDR
;	3041						, 0
;	3042						, EXESECNAM_DESC
;	3043						, 0
;	3044						, EXEFILNAM_DESC
;	3045						, .SYM_TBL_DATA [IHS$W_GSTRECS]
;	3046						, .SYM_TBL_DATA [IHS$L_GSTVBN]
;	3047						))
;	3048		THEN
;	3049			BEGIN
;	3050			!++
;	3051			! Unconditionally make the severity level informational so
;	3052			! that the message will be produced with no side effects.
;	3053			!--
;	3054	!		STATUS[STS$V_SEVERITY] = SYS$K_INFO;
;	3055			STATUS[STS$V_SEVERITY] = 3;
;	3056			GST_BEGIN_ADDR =0;
;	3057			GSR_BEGIN_ADDR =0;
;	3058			SIGNAL (PAT$_CRMPSC-MSG$K_FATAL+MSG$K_INFO, 1, .STATUS);
;	3059			SIGNAL(.STATUS);
;	3060			END
;	3061		ELSE
;	3062			BEGIN
;	3063			!++
;	3064			! Now skip the first two records because they
;	3065			! are module header and module sub-header, respectively.
;	3066			! NOTE: this builds in the knowledge of how these
;	3067			! usually-RMS records are formatted.
;	3068			!--
;	3069			GST_REC_PTR = .PAT$GL_ISVADDR[START_ADDRESS];
;	3070	
;	3071			!++

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-5
; Digital Equipment Corporation
;
;	3072			! Get to the next record by adding the rounded-up
;	3073			! record byte count to the previous beginning
;	3074			! virtual address, then adding on 2 because the count
;	3075			! field is 2 bytes long.
;	3076			!--
;	3077			GST_REC_PTR = .GST_REC_PTR + 2 + ((.GST_REC_PTR[0] +1)/2)*2;
;	3078	
;	3079			!++
;	3080			! Now skip the sub-module header.
;	3081			!--
;	3082			GST_REC_PTR = .GST_REC_PTR + 2 + ((.GST_REC_PTR[0] +1)/2)*2;
;	3083	
;	3084			!++
;	3085			! And this is the address we wanted.  Both the first, and, at this
;	3086			! point, the 'next' records, start at this address.
;	3087			!--
;	3088			GSR_BEGIN_ADDR = .GST_REC_PTR;
;	3089			GSR_NEXT_ADDR = .GSR_BEGIN_ADDR;
;	3090	
;	3091			!++
;	3092			! Tell the inner mechanism how many GST records there will be.
;	3093			! This number is the number that the LINKer gave us, -3,
;	3094			! because of the 2 records we just skipped over, PLUS the
;	3095			! module-end record at the end of the GST.
;	3096			!--
;	3097			POSITION_GST( .SYM_TBL_DATA[IHS$W_GSTRECS] - 3 );
;	3098			END;
;	3099		END;							! For no GSTs.
;	3100	
;	3101	PAT$INIT_RST (.GL_SYM_COUNT);
;	3102	END;



							    .PSECT  _PAT$PLIT,NOWRT,NOEXE,0

					      00000 P.AAA:  .ASCII  <3>\DST\						      ;
					      00004 P.AAB:  .ASCII  <3>\GST\						      ;

						    EXESECNAM=		P.AAA
						    GSTSECNAM=		P.AAB


							    .PSECT  _PAT$CODE,NOWRT,2

					 0FFC 00287 	    .ENTRY  PAT$FIND_DST, Save R2,R3,R4,R5,R6,R7,R8,R9,R10,R11	      ; 2797
		         56 00000000G  EF  9E 00289 	    MOVAB   PAT$GL_OLDNBK+3, R6					      ;
		         57 00000000G  EF  9E 00290 	    MOVAB   PAT$GB_SYMBOLS, R7					      ;
		         58 00000000G  EF  9E 00297 	    MOVAB   PAT$GL_OLDRAB+36, R8				      ;
		         59 00000000G  00  9E 0029E 	    MOVAB   LIB$SIGNAL, R9					      ;
		         5A 00000000G  EF  9E 002A5 	    MOVAB   PAT$GL_ISVADDR, R10					      ;
		         5B 00000000'  EF  9E 002AC 	    MOVAB   DST_BEGIN_ADDR, R11					      ;
		         5E	FDF0   CE  9E 002B3 	    MOVAB   -528(SP), SP					      ;
		         50 00000000G  EF  D0 002B8 	    MOVL    PAT$GL_IMGHDR, R0					      ; 2852
		         52	  04   A0  3C 002BF 	    MOVZWL  4(R0), R2						      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-6
; Digital Equipment Corporation
;
		         52	       50  C0 002C3 	    ADDL2   R0, R2						      ;
				  04   A0  B5 002C6 	    TSTW    4(R0)						      ; 2876
				       1A  12 002C9 	    BNEQ    1$							      ;
				  14   AB  D4 002CB 	    CLRL    GST_BEGIN_ADDR					      ; 2879
				       6B  D4 002CE 	    CLRL    DST_BEGIN_ADDR					      ; 2880
				       67  D4 002D0 	    CLRL    PAT$GB_SYMBOLS					      ; 2881
			    006D8203   8F  DD 002D2 	    PUSHL   #7176707						      ; 2882
		         69	       01  FB 002D8 	    CALLS   #1, LIB$SIGNAL					      ;
			    006D81FB   8F  DD 002DB 	    PUSHL   #7176699						      ; 2883
		         69	       01  FB 002E1 	    CALLS   #1, LIB$SIGNAL					      ;
					   04 002E4 	    RET     							      ; 2884
		         67	       01  D0 002E5 1$:     MOVL    #1, PAT$GB_SYMBOLS					      ; 2887
		         53	  08   A2  9E 002E8 	    MOVAB   8(R2), R3						      ; 2893
		         6B	       63  3C 002EC 	    MOVZWL  (R3), DST_BEGIN_ADDR				      ;
				       06  12 002EF 	    BNEQ    2$							      ;
				       62  D5 002F1 	    TSTL    (R2)						      ; 2902
				       10  13 002F3 	    BEQL    4$							      ;
				       05  11 002F5 	    BRB     3$							      ; 2904
		         02	       62  D1 002F7 2$:     CMPL    (R2), #2						      ; 2916
				       18  14 002FA 	    BGTR    5$							      ;
			    006D8273   8F  DD 002FC 3$:     PUSHL   #7176819						      ; 2920
		         69	       01  FB 00302 	    CALLS   #1, LIB$SIGNAL					      ;
			    006D81FB   8F  DD 00305 4$:     PUSHL   #7176699						      ; 2921
		         69	       01  FB 0030B 	    CALLS   #1, LIB$SIGNAL					      ;
				       6B  D4 0030E 	    CLRL    DST_BEGIN_ADDR					      ; 2922
				       62  D4 00310 	    CLRL    (R2)						      ; 2923
				       63  B4 00312 	    CLRW    (R3)						      ; 2924
		         55	  0A   A2  9E 00314 5$:     MOVAB   10(R2), R5						      ; 2931
		    14   AB	       65  3C 00318 	    MOVZWL  (R5), GST_BEGIN_ADDR				      ;
				       0A  12 0031C 	    BNEQ    6$							      ;
	   54	         52	       04  C1 0031E 	    ADDL3   #4, R2, R4						      ; 2940
				       64  D5 00322 	    TSTL    (R4)						      ;
				       14  13 00324 	    BEQL    8$							      ;
				       09  11 00326 	    BRB     7$							      ; 2942
	   54	         52	       04  C1 00328 6$:     ADDL3   #4, R2, R4						      ; 2954
		         02	       64  D1 0032C 	    CMPL    (R4), #2						      ;
				       19  14 0032F 	    BGTR    9$							      ;
			    006D8273   8F  DD 00331 7$:     PUSHL   #7176819						      ; 2958
		         69	       01  FB 00337 	    CALLS   #1, LIB$SIGNAL					      ;
			    006D8203   8F  DD 0033A 8$:     PUSHL   #7176707						      ; 2959
		         69	       01  FB 00340 	    CALLS   #1, LIB$SIGNAL					      ;
				  14   AB  D4 00343 	    CLRL    GST_BEGIN_ADDR					      ; 2960
				       64  D4 00346 	    CLRL    (R4)						      ; 2961
				       65  B4 00348 	    CLRW    (R5)						      ; 2962
				       6B  D5 0034A 9$:     TSTL    DST_BEGIN_ADDR					      ; 2968
				       73  13 0034C 	    BEQL    11$							      ;
		         68	  10   AE  9E 0034E 	    MOVAB   GLOBAL_RECORD, PAT$GL_OLDRAB+36			      ; 2971
		    FC   A8	0200   8F  B0 00352 	    MOVW    #512, PAT$GL_OLDRAB+32				      ; 2972
	   6A	    04   AA	       01  C1 00358 	    ADDL3   #1, PAT$GL_ISVADDR+4, PAT$GL_ISVADDR		      ; 2973
		         50	       63  3C 0035D 	    MOVZWL  (R3), R0						      ; 2975
	   50	         50	       09  78 00360 	    ASHL    #9, R0, R0						      ; 0000
		    04   AA	       50  C0 00364 	    ADDL2   R0, PAT$GL_ISVADDR+4				      ; 2974
		    08   AE	       03  D0 00368 	    MOVL    #3, EXESECNAM_DESC					      ; 2976
		    0C   AE 00000000'  EF  9E 0036C 	    MOVAB   EXESECNAM, EXESECNAM_DESC+4				      ; 2797
		         6E	       66  9A 00374 	    MOVZBL  PAT$GL_OLDNBK+3, EXEFILNAM_DESC			      ; 2978

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-7
; Digital Equipment Corporation
;
		    04   AE 00000000G  EF  9E 00377 	    MOVAB   PAT$GB_OLDNAME, EXEFILNAM_DESC+4			      ; 2979
				       62  DD 0037F 	    PUSHL   (R2)						      ; 2981
		         7E	       63  3C 00381 	    MOVZWL  (R3), -(SP)						      ;
				  08   AE  9F 00384 	    PUSHAB  EXEFILNAM_DESC					      ;
				       7E  D4 00387 	    CLRL    -(SP)						      ;
				  18   AE  9F 00389 	    PUSHAB  EXESECNAM_DESC					      ;
				       7E  D4 0038C 	    CLRL    -(SP)						      ;
				       5A  DD 0038E 	    PUSHL   R10							      ;
				       5A  DD 00390 	    PUSHL   R10							      ;
	      00000000G  EF	       08  FB 00392 	    CALLS   #8, LIB$_CREMAPSEC					      ;
		         52	       50  D0 00399 	    MOVL    R0, STATUS						      ;
		         1B	       52  E8 0039C 	    BLBS    STATUS, 10$						      ;
	   03	         00	       03  F0 0039F 	    INSV    #3, #0, #3, STATUS					      ; 2996
				       52     003A3									      ;
				       6B  D4 003A4 	    CLRL    DST_BEGIN_ADDR					      ; 2997
				       52  DD 003A6 	    PUSHL   STATUS						      ; 2998
				       01  DD 003A8 	    PUSHL   #1							      ;
			    006D816B   8F  DD 003AA 	    PUSHL   #7176555						      ;
		         69	       03  FB 003B0 	    CALLS   #3, LIB$SIGNAL					      ;
				       52  DD 003B3 	    PUSHL   STATUS						      ; 2999
		         69	       01  FB 003B5 	    CALLS   #1, LIB$SIGNAL					      ;
				       07  11 003B8 	    BRB     11$							      ; 2981
		         6B	       6A  7D 003BA 10$:    MOVQ    PAT$GL_ISVADDR, DST_BEGIN_ADDR			      ; 3007
		    08   AB	       6B  D0 003BD 	    MOVL    DST_BEGIN_ADDR, DST_NEXT_ADDR			      ; 3009
				  14   AB  D5 003C1 11$:    TSTL    GST_BEGIN_ADDR					      ; 3017
				       6E  13 003C4 	    BEQL    12$							      ;
		         68	  10   AE  9E 003C6 	    MOVAB   GLOBAL_RECORD, PAT$GL_OLDRAB+36			      ; 3027
		    FC   A8	0200   8F  B0 003CA 	    MOVW    #512, PAT$GL_OLDRAB+32				      ; 3028
	   6A	    04   AA	       01  C1 003D0 	    ADDL3   #1, PAT$GL_ISVADDR+4, PAT$GL_ISVADDR		      ; 3029
		         50	       65  3C 003D5 	    MOVZWL  (R5), R0						      ; 3033
	   50	         50	       09  78 003D8 	    ASHL    #9, R0, R0						      ; 0000
		    04   AA	       50  C0 003DC 	    ADDL2   R0, PAT$GL_ISVADDR+4				      ; 3032
		    08   AE	       03  D0 003E0 	    MOVL    #3, EXESECNAM_DESC					      ; 3034
		    0C   AE 00000000'  EF  9E 003E4 	    MOVAB   GSTSECNAM, EXESECNAM_DESC+4				      ; 2797
		         6E	       66  9A 003EC 	    MOVZBL  PAT$GL_OLDNBK+3, EXEFILNAM_DESC			      ; 3036
		    04   AE 00000000G  EF  9E 003EF 	    MOVAB   PAT$GB_OLDNAME, EXEFILNAM_DESC+4			      ; 3037
				       64  DD 003F7 	    PUSHL   (R4)						      ; 3039
		         7E	       65  3C 003F9 	    MOVZWL  (R5), -(SP)						      ;
				  08   AE  9F 003FC 	    PUSHAB  EXEFILNAM_DESC					      ;
				       7E  D4 003FF 	    CLRL    -(SP)						      ;
				  18   AE  9F 00401 	    PUSHAB  EXESECNAM_DESC					      ;
				       7E  D4 00404 	    CLRL    -(SP)						      ;
				       5A  DD 00406 	    PUSHL   R10							      ;
				       5A  DD 00408 	    PUSHL   R10							      ;
	      00000000G  EF	       08  FB 0040A 	    CALLS   #8, LIB$_CREMAPSEC					      ;
		         52	       50  D0 00411 	    MOVL    R0, STATUS						      ;
		         1F	       52  E8 00414 	    BLBS    STATUS, 13$						      ;
	   03	         00	       03  F0 00417 	    INSV    #3, #0, #3, STATUS					      ; 3055
				       52     0041B									      ;
				  14   AB  D4 0041C 	    CLRL    GST_BEGIN_ADDR					      ; 3056
				  0C   AB  D4 0041F 	    CLRL    GSR_BEGIN_ADDR					      ; 3057
				       52  DD 00422 	    PUSHL   STATUS						      ; 3058
				       01  DD 00424 	    PUSHL   #1							      ;
			    006D816B   8F  DD 00426 	    PUSHL   #7176555						      ;
		         69	       03  FB 0042C 	    CALLS   #3, LIB$SIGNAL					      ;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 7-8
; Digital Equipment Corporation
;
				       52  DD 0042F 	    PUSHL   STATUS						      ; 3059
		         69	       01  FB 00431 	    CALLS   #1, LIB$SIGNAL					      ;
				       33  11 00434 12$:    BRB     14$							      ; 3039
		         51	       6A  D0 00436 13$:    MOVL    PAT$GL_ISVADDR, GST_REC_PTR				      ; 3069
		         50	       61  3C 00439 	    MOVZWL  (GST_REC_PTR), R0					      ; 3077
				       50  D6 0043C 	    INCL    R0							      ;
		         50	       02  C6 0043E 	    DIVL2   #2, R0						      ;
		         51	  02 A140  3E 00441 	    MOVAW   2(GST_REC_PTR)[R0], GST_REC_PTR			      ;
		         50	       61  3C 00446 	    MOVZWL  (GST_REC_PTR), R0					      ; 3082
				       50  D6 00449 	    INCL    R0							      ;
		         50	       02  C6 0044B 	    DIVL2   #2, R0						      ;
		         51	  02 A140  3E 0044E 	    MOVAW   2(GST_REC_PTR)[R0], GST_REC_PTR			      ;
		    0C   AB	       51  D0 00453 	    MOVL    GST_REC_PTR, GSR_BEGIN_ADDR				      ; 3088
		    10   AB	  0C   AB  D0 00457 	    MOVL    GSR_BEGIN_ADDR, GSR_NEXT_ADDR			      ; 3089
		         7E	       65  3C 0045C 	    MOVZWL  (R5), -(SP)						      ; 3097
		         6E	       03  C2 0045F 	    SUBL2   #3, (SP)						      ;
	      00000000V  EF	       01  FB 00462 	    CALLS   #1, POSITION_GST					      ;
				       50  DD 00469 14$:    PUSHL   GL_SYM_COUNT					      ; 3101
	      00000000G  EF	       01  FB 0046B 	    CALLS   #1, PAT$INIT_RST					      ;
					   04 00472 	    RET     							      ; 2797

; Routine Size:  492 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 8
; Digital Equipment Corporation
;
;	3103	GLOBAL ROUTINE PAT$GET_DST_REC ( REC_ID ) =
;	3104	
;	3105	!++
;	3106	! FUNCTIONAL DESCRIPTION:
;	3107	!
;	3108	!	Make the indicated DST record available.
;	3109	!
;	3110	! FORMAL PARAMETERS:
;	3111	!
;	3112	!	REC_ID	- The ID of the record we are to fetch.
;	3113	!		  This ID must be one which was previously returned
;	3114	!		  by a call to PAT$GET_NXT_DST.
;	3115	!
;	3116	! IMPLICIT INPUTS:
;	3117	!
;	3118	!	NONE
;	3119	!
;	3120	! IMPLICIT OUTPUTS:
;	3121	!
;	3122	!	NONE
;	3123	!
;	3124	! COMPLETION CODES:
;	3125	!
;	3126	!	0, if the indicated record does not exist,
;	3127	!	the address of where is can now be referenced, otherwise.
;	3128	!
;	3129	! SIDE EFFECTS:
;	3130	!
;	3131	!	The DST record is made available.
;	3132	!
;	3133	!--
;	3134	
;	3135	BEGIN
;	3136	
;	3137	BIND
;	3138		DST_RECRD = .REC_ID : DST_RECORD;
;	3139	
;	3140	!++
;	3141	! If there is no DST, simply return as though we were asked to read one
;	3142	! past the last one. (The interface's notion of EOF).
;	3143	!--
;	3144	IF (.DST_BEGIN_ADDR EQL 0)
;	3145	THEN
;	3146		RETURN(0);
;	3147	
;	3148	!++
;	3149	! The record ID is the same as the virtual address at which it can be
;	3150	! referenced.  The next record, then, is simply the one which is virtually
;	3151	! contiguous to this one, excepting for the case of the last record.
;	3152	! Here we are lenient - we say that the DST ended OK if one asks for a
;	3153	! record which is past the end marker, OR, if the count field
;	3154	! for a supposed 'next' record is 0.
;	3155	!--
;	3156	IF (.REC_ID EQL .DST_END_ADDR +1)
;	3157	THEN

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 8-1
; Digital Equipment Corporation
;
;	3158		RETURN(0);
;	3159	
;	3160	!++
;	3161	! Now that it is safe, check for 0-length records.
;	3162	!--
;	3163	IF (.DST_RECRD [DSTR_SIZE] EQL 0)
;	3164	THEN
;	3165		RETURN(0);
;	3166	
;	3167	!++
;	3168	! Then check that the ID is valid.  
;	3169	!--
;	3170	IF (.REC_ID LSSA .dst_begin_addr)   OR    (.REC_ID GTRA .dst_end_addr)
;	3171	THEN
;	3172		BEGIN
;	3173		!++
;	3174		! This should not happen - we check and report
;	3175		! errors here only to help us while debugging.
;	3176		!--
;	3177		SIGNAL (PAT$_INVDSTREC);				! Severe error
;	3178		RETURN(0);
;	3179		END;
;	3180	
;	3181	RETURN( .REC_ID );
;	3182	END;





					 080C 00473 	    .ENTRY  PAT$GET_DST_REC, Save R2,R3,R11			      ; 3103
		         5B 00000000'  EF  9E 00475 	    MOVAB   DST_END_ADDR, R11					      ;
		         52	  04   AC  D0 0047C 	    MOVL    REC_ID, R2						      ; 3138
		         53	       52  D0 00480 	    MOVL    R2, R3						      ; 3135
		         51	  FC   AB  D0 00483 	    MOVL    DST_BEGIN_ADDR, R1					      ; 3144
				       2A  13 00487 	    BEQL    3$							      ;
	   50	         6B	       01  C1 00489 	    ADDL3   #1, DST_END_ADDR, R0				      ; 3156
		         50	       52  D1 0048D 	    CMPL    R2, R0						      ;
				       21  13 00490 	    BEQL    3$							      ;
				       63  95 00492 	    TSTB    (R3)						      ; 3163
				       1D  13 00494 	    BEQL    3$							      ;
		         51	       52  D1 00496 	    CMPL    R2, R1						      ; 3170
				       05  1F 00499 	    BLSSU   1$							      ;
		         6B	       52  D1 0049B 	    CMPL    R2, DST_END_ADDR					      ;
				       0F  1B 0049E 	    BLEQU   2$							      ;
			    006D80CA   8F  DD 004A0 1$:     PUSHL   #7176394						      ; 3177
	      00000000G  00	       01  FB 004A6 	    CALLS   #1, LIB$SIGNAL					      ;
				       04  11 004AD 	    BRB     3$							      ; 3178
		         50	       52  D0 004AF 2$:     MOVL    R2, R0						      ; 3181
					   04 004B2 	    RET     							      ;
				       50  D4 004B3 3$:     CLRL    R0							      ; 3103
					   04 004B5 	    RET     							      ;

; Routine Size:  67 bytes


; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 8-2
; Digital Equipment Corporation
;


; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 9
; Digital Equipment Corporation
;
;	3183	GLOBAL ROUTINE PAT$POSITON_DST ( REC_ID ) =
;	3184	
;	3185	!++
;	3186	! FUNCTIONAL DESCRIPTION:
;	3187	!
;	3188	!	Make the indicated DST record available in such
;	3189	!	a way that PAT$GET_NXT_DST's idea of 'next' is
;	3190	!	defined to be the one after this routine fetches.
;	3191	!
;	3192	! FORMAL PARAMETERS:
;	3193	!
;	3194	!	REC_ID	- The ID of the record we are to fetch.
;	3195	!		  This ID must be one which was previously returned
;	3196	!		  by a call to PAT$GET_NXT_DST.
;	3197	!
;	3198	! IMPLICIT INPUTS:
;	3199	!
;	3200	!	NONE
;	3201	!
;	3202	! IMPLICIT OUTPUTS:
;	3203	!
;	3204	!	NONE
;	3205	!
;	3206	! COMPLETION CODES:
;	3207	!
;	3208	!	0, if the indicated record does not exist,
;	3209	!	the address of where is can now be referenced, otherwise.
;	3210	!
;	3211	! SIDE EFFECTS:
;	3212	!
;	3213	!	The DST record is made available.
;	3214	!	The 'next' DST record is henceforth defined to
;	3215	!	be the one after the one fetched by this call.
;	3216	!
;	3217	!--
;	3218	
;	3219	BEGIN
;	3220	
;	3221	LOCAL
;	3222		REC_ADDR : REF DST_RECORD;
;	3223	
;	3224	!++
;	3225	! PAT$GET_DST_REC does most of the work - 
;	3226	! we just include the above-described side effect.
;	3227	!--
;	3228	IF ((REC_ADDR = PAT$GET_DST_REC( .REC_ID )) EQL 0 )
;	3229	THEN
;	3230		RETURN(0);
;	3231	
;	3232	!++
;	3233	! RE-initialize INT's notion of 'next' DST record.
;	3234	!--
;	3235	DST_NEXT_ADDR = .REC_ADDR + .REC_ADDR [DSTR_SIZE] +1;
;	3236	RETURN( .REC_ADDR );
;	3237	END;

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 9-1
; Digital Equipment Corporation
;





					 0000 004B6 	    .ENTRY  PAT$POSITON_DST, Save nothing			      ; 3183
				  04   AC  DD 004B8 	    PUSHL   REC_ID						      ; 3228
		    B4   AF	       01  FB 004BB 	    CALLS   #1, PAT$GET_DST_REC					      ;
		         51	       50  D0 004BF 	    MOVL    R0, REC_ADDR					      ;
				       12  13 004C2 	    BEQL    1$							      ;
		         50	       61  9A 004C4 	    MOVZBL  (REC_ADDR), R0					      ; 3235
		         50	       51  C0 004C7 	    ADDL2   REC_ADDR, R0					      ;
00000000'  EF	         50	       01  C1 004CA 	    ADDL3   #1, R0, DST_NEXT_ADDR				      ;
		         50	       51  D0 004D2 	    MOVL    REC_ADDR, R0					      ; 3236
					   04 004D5 	    RET     							      ;
				       50  D4 004D6 1$:     CLRL    R0							      ; 3183
					   04 004D8 	    RET     							      ;

; Routine Size:  35 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 10
; Digital Equipment Corporation
;
;	3238	ROUTINE POSITION_GST ( GST_REC_COUNT ) =
;	3239	
;	3240	!++
;	3241	! FUNCTIONAL DESCRIPTION:
;	3242	!
;	3243	!	This routine, if called with a positive value initializes its OWN
;	3244	!	storage to remember the number of RMS-type records in the GST.
;	3245	!	If it is called with a negative or zero value, it returns the address
;	3246	!	of the next RMS-type record in the GST.  A negative value also causes
;	3247	!	the pointers to be positioned at the start of the GST.
;	3248	!
;	3249	! FORMAL PARAMETERS:
;	3250	!
;	3251	!	GST_REC_COUNT	- The number of RMS records in the GST.
;	3252	!			  (negative value) re-position to start and return
;	3253	!			  address of first GLOBAL.
;	3254	!			  (zero) return address of the next GLOBAL.
;	3255	!
;	3256	! IMPLICIT INPUTS:
;	3257	!
;	3258	!	GSR_BEGIN_ADDR	- Holds the starting address of the GST.
;	3259	!			  If the value is not GTR 0 or 1, then the GST
;	3260	!			  has not been mapped in so this routine returns 0.
;	3261	!
;	3262	! IMPLICIT OUTPUTS:
;	3263	!
;	3264	!	GSR_NEXT_ADDR	- Holds the address of the next RMS record in the GST
;	3265	!			  or the GST was not mapped in.
;	3266	!
;	3267	! ROUTINE VALUE:
;	3268	!
;	3269	!	0		- If there are no more records in the GST.
;	3270	!	non-zero	- The address of the next GST RMS record.
;	3271	!
;	3272	! SIDE EFFECTS:
;	3273	!
;	3274	!	The next GST record can now be accessed, and an OWN pointer to the next
;	3275	!	one is maintained.  The number of GST records yet to go is also updated
;	3276	!	so that the end of the GST can be detected.
;	3277	!
;	3278	!--
;	3279	
;	3280	BEGIN
;	3281	
;	3282	OWN
;	3283		TOTAL_RECORDS,
;	3284		RECORDS_LEFT;
;	3285	
;	3286	LOCAL
;	3287		BLOCK_ADDR;
;	3288	
;	3289	!++
;	3290	! If there is no mapped GST, then return 0, no atter why this routine
;	3291	! was called.
;	3292	!--

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 10-1
; Digital Equipment Corporation
;
;	3293	IF (NOT .GSR_BEGIN_ADDR GTRA 1)
;	3294	THEN
;	3295		RETURN(0);
;	3296	
;	3297	IF (.GST_REC_COUNT GTR 0)
;	3298	THEN
;	3299		BEGIN
;	3300		TOTAL_RECORDS = .GST_REC_COUNT;
;	3301		RETURN (0);
;	3302		END;
;	3303	
;	3304	IF (.GST_REC_COUNT NEQ 0)
;	3305	THEN
;	3306		BEGIN
;	3307		GSR_NEXT_ADDR = .GSR_BEGIN_ADDR;
;	3308		RECORDS_LEFT  = .TOTAL_RECORDS;
;	3309		END;
;	3310	
;	3311	!++
;	3312	! Stop the following from faulting if some caller ignores the end condition and
;	3313	! effectively causes us to 'run off the end' of the mapped GST.
;	3314	!--
;	3315	IF (NOT .RECORDS_LEFT GEQ 1)
;	3316	THEN
;	3317		RETURN(0);
;	3318	
;	3319	!++
;	3320	! Pick up the address of the current record, and update the pointer to the
;	3321	! subsequent one.
;	3322	!--
;	3323	BLOCK_ADDR = .GSR_NEXT_ADDR + 2;
;	3324	GSR_NEXT_ADDR = .GSR_NEXT_ADDR + 2 + ((.GSR_NEXT_ADDR[0] +1)/2)*2;
;	3325	RECORDS_LEFT = .RECORDS_LEFT - 1;
;	3326	RETURN (.BLOCK_ADDR);
;	3327	END;



							    .PSECT  _PAT$OWN,NOEXE,2

					      00024 TOTAL_RECORDS:
							    .BLKB   4
					      00028 RECORDS_LEFT:
							    .BLKB   4



							    .PSECT  _PAT$CODE,NOWRT,2

					 0804 004D9 POSITION_GST:
							    .WORD   Save R2,R11						      ; 3238
		         5B 00000000'  EF  9E 004DB 	    MOVAB   GSR_NEXT_ADDR, R11					      ;
		         01	  FC   AB  D1 004E2 	    CMPL    GSR_BEGIN_ADDR, #1					      ; 3293
				       3A  1B 004E6 	    BLEQU   3$							      ;
		         50	  04   AC  D0 004E8 	    MOVL    GST_REC_COUNT, R0					      ; 3297

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 10-2
; Digital Equipment Corporation
;
				       06  15 004EC 	    BLEQ    1$							      ;
		    10   AB	       50  D0 004EE 	    MOVL    R0, TOTAL_RECORDS					      ; 3300
				       2E  11 004F2 	    BRB     3$							      ; 3301
				       50  D5 004F4 1$:     TSTL    R0							      ; 3304
				       09  13 004F6 	    BEQL    2$							      ;
		         6B	  FC   AB  D0 004F8 	    MOVL    GSR_BEGIN_ADDR, GSR_NEXT_ADDR			      ; 3307
		    14   AB	  10   AB  D0 004FC 	    MOVL    TOTAL_RECORDS, RECORDS_LEFT				      ; 3308
		         01	  14   AB  D1 00501 2$:     CMPL    RECORDS_LEFT, #1					      ; 3315
				       1B  19 00505 	    BLSS    3$							      ;
	   51	         6B	       02  C1 00507 	    ADDL3   #2, GSR_NEXT_ADDR, R1				      ; 3323
		         52	       51  D0 0050B 	    MOVL    R1, BLOCK_ADDR					      ;
		         50	  00   BB  3C 0050E 	    MOVZWL  @GSR_NEXT_ADDR, R0					      ; 3324
				       50  D6 00512 	    INCL    R0							      ;
		         50	       02  C6 00514 	    DIVL2   #2, R0						      ;
		         6B	     6140  3E 00517 	    MOVAW   (R1)[R0], GSR_NEXT_ADDR				      ;
				  14   AB  D7 0051B 	    DECL    RECORDS_LEFT					      ; 3325
		         50	       52  D0 0051E 	    MOVL    BLOCK_ADDR, R0					      ; 3326
					   04 00521 	    RET     							      ;
				       50  D4 00522 3$:     CLRL    R0							      ; 3238
					   04 00524 	    RET     							      ;

; Routine Size:  76 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 11
; Digital Equipment Corporation
;
;	3328	GLOBAL ROUTINE PAT$GET_NXT_DST ( REC_ID_PTR ) =
;	3329	
;	3330	!++
;	3331	! FUNCTIONAL DESCRIPTION:
;	3332	!
;	3333	!	Make the next DST record available,
;	3334	!	and return both a pointer to where it
;	3335	!	can now be referenced, as well as an ID
;	3336	!	for it so that we can ask for it later.
;	3337	!
;	3338	! FORMAL PARAMETERS:
;	3339	!
;	3340	!	REC_ID_PTR - the address of where this routine will
;	3341	!		     stuff the ID it wants subsequent calls
;	3342	!		     to PAT$GET_DST_REC to use to refer
;	3343	!		     to the record fetched by this call.
;	3344	!
;	3345	! IMPLICIT INPUTS:
;	3346	!
;	3347	!	To be defined.
;	3348	!	(whatever context these routines work from).
;	3349	!
;	3350	! IMPLICIT OUTPUTS:
;	3351	!
;	3352	!	none
;	3353	!
;	3354	! COMPLETION CODES:
;	3355	!
;	3356	!	0, if the indicated record does not exist,
;	3357	!	the address of where is can now be referenced, otherwise.
;	3358	!
;	3359	! SIDE EFFECTS:
;	3360	!
;	3361	!	The DST record after the last one fetched is made available.
;	3362	!	If no record has yet been fetched, the first record in
;	3363	!	the DST is made available.
;	3364	!
;	3365	!--
;	3366	
;	3367	BEGIN
;	3368	
;	3369	MAP
;	3370		REC_ID_PTR : REF VECTOR[,LONG];
;	3371	
;	3372	!++
;	3373	! Since for us record IDs are the same as their virtual addresses, we can get
;	3374	! the next one the same way we can get ANY one.  The only detail to fill in is
;	3375	! passing back the ID for this next one.
;	3376	!--
;	3377	RETURN(REC_ID_PTR[0] = PAT$POSITON_DST( .DST_NEXT_ADDR ));
;	3378	END;





; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 11-1
; Digital Equipment Corporation
;

					 0000 00525 	    .ENTRY  PAT$GET_NXT_DST, Save nothing			      ; 3328
			    00000000'  EF  DD 00527 	    PUSHL   DST_NEXT_ADDR					      ; 3377
		    85   AF	       01  FB 0052D 	    CALLS   #1, PAT$POSITON_DST					      ;
		    04   BC	       50  D0 00531 	    MOVL    R0, @REC_ID_PTR					      ;
					   04 00535 	    RET     							      ; 3328

; Routine Size:  17 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12
; Digital Equipment Corporation
;
;	3379	GLOBAL ROUTINE PAT$GET_NXT_GST (ACCESS_FLAG) =
;	3380	
;	3381	!++
;	3382	! Functional description:
;	3383	!
;	3384	!	This routine returns the address of a fixed length record that
;	3385	!	contains a global symbol name and its associated value. This
;	3386	!	routine expects to be called repeatedly until each global symbol
;	3387	!	has been returned to the caller.
;	3388	!
;	3389	!	Before this routine is ever called, the location of the GST in
;	3390	!	the image file is found, and it is mapped into PATCH's image.
;	3391	!	The address of this buffer is held in the OWN variable GST_BEGIN_ADDR.
;	3392	!	This routine analyzes the GST record, and moves through the buffer,
;	3393	!	returning the buffer address of each global symbol entry as it is seen.
;	3394	!	When the buffer is exhausted, this routine reads in the next GST record.
;	3395	!	It halts at end of file and returns a value of zero to the caller.
;	3396	!
;	3397	!	This routine keeps the variable GST_BEGIN_ADDR up to date.
;	3398	!
;	3399	!	The format of one of these concatenated records is a single
;	3400	!	leading byte containing the value 1, indicating that the record
;	3401	!	is indeed a GSD record. The variable GST_BEGIN_ADDR addresses
;	3402	!	the byte following this leading byte.
;	3403	!
;	3404	!	Each entry in the record has a fixed number of overhead
;	3405	!	bytes followed by a symbol name that is a variable number of
;	3406	!	bytes. The entries we are interested in processing are the
;	3407	!	global symbol definitions, entry point symbol and mask
;	3408	!	definitions, and procedure definitions with formal argument descriptions.
;	3409	!	The other defined type, PSECT definition, is noted only because it
;	3410	!	must be successfully passed over.  The format of each of these types is
;	3411	!	illustrated below:
;	3412	!
;	3413	!
;	3414	!	Global symbol definition:
;	3415	!
;	3416	!		-----------------
;	3417	!	0	!   GSD type 1  !
;	3418	!		-----------------
;	3419	!	1	!   data type   !	ignored for now
;	3420	!		-----------------
;	3421	!	2	!     flag      !	bit 1 set means that this is
;	3422	!	3	!     bytes     !	a definition. ignore bit 0.
;	3423	!		-----------------
;	3424	!	4	!  psect index  !	ignored.
;	3425	!		-----------------
;	3426	!	5	!		!
;	3427	!		!     value     !	4 bytes
;	3428	!		!		!
;	3429	!		-----------------
;	3430	!	9	!		!
;	3431	!		!    symbol     !	stock counted character
;	3432	!		!     name      !	string.
;	3433	!		!		!

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-1
; Digital Equipment Corporation
;
;	3434	!		-----------------
;	3435	!
;	3436	!	The entry point symbol and mask definition entry is identical to
;	3437	!	the global symbol definition illustrated above, with the 
;	3438	!	addition of a two byte field for the procedure's register save
;	3439	!	mask. This two byte field is located after the symbol value
;	3440	!	field (which is an entry point address).
;	3441	!
;	3442	!		-----------------
;	3443	!	0	!   GSD type 2  !
;	3444	!		-----------------
;	3445	!	1	!   data type   !	ignored for now
;	3446	!		-----------------
;	3447	!	2	!     flag      !	not relevant for
;	3448	!	3	!     bytes     !	entry point def.
;	3449	!		-----------------
;	3450	!	4	!  psect index  !	ignored
;	3451	!		-----------------
;	3452	!		!		!
;	3453	!	5	!     value     !	4 bytes
;	3454	!		!		!
;	3455	!		-----------------
;	3456	!	9	!   register    !	ignored,
;	3457	!	10	!   save mask   !	2 bytes
;	3458	!		-----------------
;	3459	!	11	!		!
;	3460	!		!    symbol     !	stock counted character
;	3461	!		!     name      !	string
;	3462	!		!		!
;	3463	!		-----------------
;	3464	!
;	3465	!	The procedure definition with formal argument descriptions is
;	3466	!	identical to the entry point with mask definition above, save 
;	3467	!	that it has some additional fields.  There is a minimum number
;	3468	!	of arguments byte and a maximum number of arguments byte.  These
;	3469	!	are followed by a formal argument description for each possible
;	3470	!	argument (i.e., the maximum number).  The formal argument descriptions
;	3471	!	consist of an argument value control byte and a remaining count byte.
;	3472	!	The remaining count byte tells the number of bytes in the detailed
;	3473	!	argument description (from 0 to 255).
;	3474	!
;	3475	!		-----------------
;	3476	!	0	!   GSD type 3  !
;	3477	!		-----------------
;	3478	!	1	!   data type   !	ignored for now
;	3479	!		-----------------
;	3480	!	2	!     flag      !	bit 1 set means that this is
;	3481	!	3	!     bytes     !	a definition. ignore bit 0.
;	3482	!		-----------------
;	3483	!	4	!  psect index  !	ignored
;	3484	!		-----------------
;	3485	!		!		!
;	3486	!	5	!     value     !	4 bytes
;	3487	!		!		!
;	3488	!		-----------------

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-2
; Digital Equipment Corporation
;
;	3489	!	9	!   register    !	ignored,
;	3490	!	10	!   save mask   !	2 bytes
;	3491	!		-----------------
;	3492	!	11	!		!
;	3493	!		!    symbol     !	stock counted character
;	3494	!		!     name      !	string
;	3495	!		!		!
;	3496	!		-----------------
;	3497	!		! min # act arg !	1 byte
;	3498	!		-----------------
;	3499	!		! max # act arg !	1 byte
;	3500	!		-----------------
;	3501	!		! formal arg #1 !
;	3502	!		!  description  !
;	3503	!		-----------------
;	3504	!		!       .       !
;	3505	!		!       .       !
;	3506	!		!       .       !
;	3507	!		-----------------
;	3508	!		! formal arg #n !
;	3509	!		!  description  !
;	3510	!		-----------------
;	3511	!
;	3512	!	Each formal argument description has the following format:
;	3513	!
;	3514	!		-----------------
;	3515	!	0	! arg. val. ctl.!	1 byte
;	3516	!		-----------------
;	3517	!	1	! rem. byte cnt.!	1 byte
;	3518	!		-----------------
;	3519	!		!   detailed    !	anywhere
;	3520	!		!   argument    !	from 0-255
;	3521	!		!  description  !	bytes
;	3522	!		-----------------
;	3523	!
;	3524	!	PSECT definition:
;	3525	!
;	3526	!		-----------------
;	3527	!	0	!   GSD type 0  !
;	3528	!		-----------------
;	3529	!	1	!   alignment   !
;	3530	!		-----------------
;	3531	!	2	!     flag      !
;	3532	!	3	!     bytes     !
;	3533	!		-----------------
;	3534	!	4	!		!
;	3535	!		!  allocation   !	4 bytes
;	3536	!		!		!
;	3537	!		-----------------
;	3538	!	8	!		!
;	3539	!		!    symbol     !	stock counted character
;	3540	!		!     name      !	string.
;	3541	!		!		!
;	3542	!		-----------------
;	3543	!

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-3
; Digital Equipment Corporation
;
;	3544	! Calling sequence:
;	3545	!
;	3546	!	CALLS #0, PAT$GET_NXT_GST
;	3547	!
;	3548	! Inputs:
;	3549	!
;	3550	!	none
;	3551	!
;	3552	! Implicit inputs:
;	3553	!
;	3554	!	GST_BEGIN_ADDR	- Current address of record buffer
;	3555	!
;	3556	! Outputs:
;	3557	!
;	3558	!	The address of the next global symbol entry, or 0, if EOF.
;	3559	!
;	3560	! Implicit outputs:
;	3561	!
;	3562	!	GST_BEGIN_ADDR is updated to address the next entry.
;	3563	!
;	3564	! Routine value:
;	3565	!
;	3566	!	An address or 0
;	3567	!
;	3568	! Side effects:
;	3569	!
;	3570	!	Another record may be read in.
;	3571	!--
;	3572	
;	3573	BEGIN
;	3574	
;	3575	LOCAL
;	3576		OLD_ADDRESS : REF BLOCK [, BYTE];
;	3577	
;	3578	LABEL
;	3579		GET_RECORD;
;	3580	
;	3581	IF (.ACCESS_FLAG NEQ 0)
;	3582	THEN
;	3583		BEGIN
;	3584		IF ((GST_BEGIN_ADDR = POSITION_GST(-1)) EQL 0)
;	3585		THEN
;	3586			GST_BEGIN_ADDR = %X'FFFFFFFF';
;	3587		RETURN(0);
;	3588		END;
;	3589	
;	3590	!++
;	3591	! See whether the current buffer address is beyond the
;	3592	! end of the last GST record we looked at.  Note that we
;	3593	! rounded up GSR_NEXT_ADDR when calculating where the next
;	3594	! GST record will begin.  Therefore we must temporarily round
;	3595	! it down again when comparing it with GST_BEGIN_ADDR since it
;	3596	! may point to the last unused byte in a GST record.
;	3597	!--
;	3598	REPEAT

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-4
; Digital Equipment Corporation
;
;	3599	GET_RECORD:
;	3600		BEGIN
;	3601		!++
;	3602		! First check that there is a GST in this image.
;	3603		!--
;	3604		IF (.GST_BEGIN_ADDR EQL 0)
;	3605		THEN
;	3606			RETURN(0);
;	3607	
;	3608		IF (.GST_BEGIN_ADDR GEQA .GSR_NEXT_ADDR-1)
;	3609		THEN
;	3610			BEGIN
;	3611			!++
;	3612			! Record was finished.  Check that there are more records.
;	3613			! If so, then get another record.
;	3614			!--
;	3615			IF ((GST_BEGIN_ADDR = POSITION_GST(0)) EQL 0)
;	3616			THEN
;	3617				RETURN(0)
;	3618			ELSE
;	3619				BEGIN
;	3620				!++
;	3621				! If the next record is a GST record, then initialize
;	3622				! the variable GST_BEGIN_ADDR to point to the first
;	3623				! global symbol definition block in this record. 
;	3624				!--
;	3625				LOCAL
;	3626					BUFFER_ADDRESS : REF VECTOR [, BYTE];
;	3627	
;	3628				BUFFER_ADDRESS = .GST_BEGIN_ADDR;
;	3629				IF .BUFFER_ADDRESS [GST_RECORD_TYPE] EQL GST_TYPE
;	3630				THEN
;	3631					GST_BEGIN_ADDR = .GST_BEGIN_ADDR + 1
;	3632				ELSE
;	3633					BEGIN
;	3634					!++
;	3635					! This record is not a GST record.
;	3636					! Go on to the next.
;	3637					!--
;	3638					GST_BEGIN_ADDR = %X'FFFFFFFF';
;	3639					LEAVE GET_RECORD;
;	3640					END;
;	3641				END;
;	3642			END
;	3643		ELSE
;	3644			BEGIN
;	3645			!++
;	3646			! This is a global symbol. Save its address.
;	3647			! Then update the variable GST_BEGIN_ADDR to
;	3648			! point to the next symbol.
;	3649			!--
;	3650			OLD_ADDRESS = .GST_BEGIN_ADDR;
;	3651			CASE .OLD_ADDRESS [ENTRY_TYPE] FROM PSECT_DEF TO PROC_DEF OF
;	3652	
;	3653				SET

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-5
; Digital Equipment Corporation
;
;	3654	
;	3655				[PSECT_DEF]:
;	3656					BEGIN
;	3657					GST_BEGIN_ADDR = .OLD_ADDRESS + PSECT_OVERHEAD
;	3658						+ .OLD_ADDRESS [PSECT_NAM_COUNT];
;	3659					END;
;	3660	
;	3661	
;	3662				[GLOBAL_SYMBOL]:
;	3663					BEGIN
;	3664					GST_BEGIN_ADDR = .OLD_ADDRESS + GLSYM_OVERHEAD
;	3665						+ .OLD_ADDRESS [GLSYM_NAM_COUNT];
;	3666					RETURN .OLD_ADDRESS
;	3667					END;
;	3668	
;	3669	
;	3670				[ENTMSK_DEF]:
;	3671					BEGIN
;	3672					GST_BEGIN_ADDR = .OLD_ADDRESS + ENTMSK_OVERHEAD
;	3673						+ .OLD_ADDRESS [ENTMS_NAM_COUNT];
;	3674					RETURN .OLD_ADDRESS
;	3675					END;
;	3676	
;	3677	
;	3678				[PROC_DEF]:
;	3679					BEGIN
;	3680					LOCAL
;	3681						NUM_ARGS;		! Max formal args
;	3682					GST_BEGIN_ADDR = .OLD_ADDRESS + ENTMSK_OVERHEAD +
;	3683							.OLD_ADDRESS[ENTMS_NAM_COUNT];
;	3684					NUM_ARGS = .GST_BEGIN_ADDR[GST_P_MAX_ARG];
;	3685					GST_BEGIN_ADDR = .GST_BEGIN_ADDR + MINMAX_OVERHEAD;
;	3686					WHILE (.NUM_ARGS GTR 0)
;	3687					DO
;	3688						BEGIN
;	3689						GST_BEGIN_ADDR = .GST_BEGIN_ADDR +
;	3690								 .GST_BEGIN_ADDR[GST_P_REM_CNT] + ARGDSC_OVERHEAD;
;	3691						NUM_ARGS = .NUM_ARGS - 1;
;	3692						END;
;	3693					RETURN .OLD_ADDRESS
;	3694					END;
;	3695	
;	3696	
;	3697				[OUTRANGE]:
;	3698					BEGIN
;	3699					GST_BEGIN_ADDR = %X'FFFFFFFF';
;	3700					END;
;	3701	
;	3702				TES;
;	3703	
;	3704			END;
;	3705		END;
;	3706	END;



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-6
; Digital Equipment Corporation
;



					 0C0C 00536 	    .ENTRY  PAT$GET_NXT_GST, Save R2,R3,R10,R11			      ; 3379
		         5A	  9E   AF  9E 00538 	    MOVAB   POSITION_GST, R10					      ;
		         5B 00000000'  EF  9E 0053C 	    MOVAB   GST_BEGIN_ADDR, R11					      ;
				  04   AC  D5 00543 	    TSTL    ACCESS_FLAG						      ; 3581
				       11  13 00546 	    BEQL    2$							      ;
		         7E	       01  CE 00548 	    MNEGL   #1, -(SP)						      ; 3584
		         6A	       01  FB 0054B 	    CALLS   #1, POSITION_GST					      ;
		         6B	       50  D0 0054E 	    MOVL    R0, GST_BEGIN_ADDR					      ;
				       03  12 00551 	    BNEQ    1$							      ;
		         6B	       01  CE 00553 	    MNEGL   #1, GST_BEGIN_ADDR					      ; 3586
				     008F  31 00556 1$:     BRW     12$							      ; 3587
		         50	       6B  D0 00559 2$:     MOVL    GST_BEGIN_ADDR, R0					      ; 3604
				       F8  13 0055C 	    BEQL    1$							      ;
	   51	    FC   AB	       01  C3 0055E 	    SUBL3   #1, GSR_NEXT_ADDR, R1				      ; 3608
		         51	       50  D1 00563 	    CMPL    R0, R1						      ;
				       16  1F 00566 	    BLSSU   3$							      ;
				       7E  D4 00568 	    CLRL    -(SP)						      ; 3615
		         6A	       01  FB 0056A 	    CALLS   #1, POSITION_GST					      ;
		         6B	       50  D0 0056D 	    MOVL    R0, GST_BEGIN_ADDR					      ;
				       76  13 00570 	    BEQL    12$							      ;
		         50	       6B  D0 00572 	    MOVL    GST_BEGIN_ADDR, BUFFER_ADDRESS			      ; 3628
		         01	       60  91 00575 	    CMPB    (BUFFER_ADDRESS), #1				      ; 3629
				       13  12 00578 	    BNEQ    5$							      ;
				       6B  D6 0057A 	    INCL    GST_BEGIN_ADDR					      ; 3631
				       DB  11 0057C 	    BRB     2$							      ; 3629
		         52	       50  D0 0057E 3$:     MOVL    R0, OLD_ADDRESS					      ; 3650
	   03	         00	       62  8F 00581 	    CASEB   (OLD_ADDRESS), #0, #3				      ; 3651
	 0027	       001A	     000D     00585 4$:     .WORD   6$-4$,-						      ;
				     0034     0058B		    7$-4$,-						      ;
								    8$-4$,-						      ;
								    9$-4$						      ;
		         6B	       01  CE 0058D 5$:     MNEGL   #1, GST_BEGIN_ADDR					      ; 3699
				       C7  11 00590 	    BRB     2$							      ; 3651
		         50	  08   A2  9A 00592 6$:     MOVZBL  8(OLD_ADDRESS), R0					      ; 3658
		         50	       52  C0 00596 	    ADDL2   OLD_ADDRESS, R0					      ;
	   6B	         50	       09  C1 00599 	    ADDL3   #9, R0, GST_BEGIN_ADDR				      ;
				       BA  11 0059D 	    BRB     2$							      ; 3651
		         50	  09   A2  9A 0059F 7$:     MOVZBL  9(OLD_ADDRESS), R0					      ; 3665
		         50	       52  C0 005A3 	    ADDL2   OLD_ADDRESS, R0					      ;
	   6B	         50	       0A  C1 005A6 	    ADDL3   #10, R0, GST_BEGIN_ADDR				      ;
				       38  11 005AA 	    BRB     11$							      ; 3666
		         50	  0B   A2  9A 005AC 8$:     MOVZBL  11(OLD_ADDRESS), R0					      ; 3673
		         50	       52  C0 005B0 	    ADDL2   OLD_ADDRESS, R0					      ;
	   6B	         50	       0C  C1 005B3 	    ADDL3   #12, R0, GST_BEGIN_ADDR				      ;
				       2B  11 005B7 	    BRB     11$							      ; 3674
		         50	  0B   A2  9A 005B9 9$:     MOVZBL  11(OLD_ADDRESS), R0					      ; 3682
		         50	       52  C0 005BD 	    ADDL2   OLD_ADDRESS, R0					      ;
	   6B	         50	       0C  C1 005C0 	    ADDL3   #12, R0, GST_BEGIN_ADDR				      ;
		         50	       6B  D0 005C4 	    MOVL    GST_BEGIN_ADDR, R0					      ; 3684
		         51	  01   A0  9A 005C7 	    MOVZBL  1(R0), NUM_ARGS					      ;
		         6B	       02  C0 005CB 	    ADDL2   #2, GST_BEGIN_ADDR					      ; 3685
				       51  D5 005CE 10$:    TSTL    NUM_ARGS						      ; 3686

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 12-7
; Digital Equipment Corporation
;
				       12  15 005D0 	    BLEQ    11$							      ;
		         50	       6B  D0 005D2 	    MOVL    GST_BEGIN_ADDR, R0					      ; 3689
		         53	  01   A0  9A 005D5 	    MOVZBL  1(R0), R3						      ;
		         50	       53  C0 005D9 	    ADDL2   R3, R0						      ;
	   6B	         50	       02  C1 005DC 	    ADDL3   #2, R0, GST_BEGIN_ADDR				      ; 3690
				       51  D7 005E0 	    DECL    NUM_ARGS						      ; 3691
				       EA  11 005E2 	    BRB     10$							      ; 3686
		         50	       52  D0 005E4 11$:    MOVL    OLD_ADDRESS, R0					      ; 3693
					   04 005E7 	    RET     							      ;
				       50  D4 005E8 12$:    CLRL    R0							      ; 3379
					   04 005EA 	    RET     							      ;

; Routine Size:  181 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 13
; Digital Equipment Corporation
;
;	3707	GLOBAL ROUTINE PAT$RST_FREEZ ( UNITS ) =
;	3708	
;	3709	!++
;	3710	! FUNCTIONAL DESCRIPTION:
;	3711	!
;	3712	!	Isolate storage allocation for the RST builder/manipulator.
;	3713	!	i.e. Do exactly what PAT$FREEZ does for the rest of 
;	3714	!	PATCH, but take care of any differences (which may
;	3715	!	or may not exits), when it is the RST interface
;	3716	!	which wants the storage.
;	3717	!
;	3718	!	For now, there IS a difference - an RST-pointer is 
;	3719	!	returned, NOT the usual longword pointer.  RST-pointers
;	3720	!	are something internal to the RST builder/manipulator,
;	3721	!	and it doesn't want to ever see anything but RST-pointers
;	3722	!	(even if someday RST-pointers are the same thing as
;	3723	!	virtual addresses).  This is really the motivation for
;	3724	!	having PAT$RST_FREEZ.
;	3725	!
;	3726	! Formal Parameters:
;	3727	!
;	3728	!	UNITS - the number of units of storage which are
;	3729	!		required.  This unit will remain whatever
;	3730	!		unit PAT$FREEZ knows about.
;	3731	!
;	3732	! Implicit Inputs:
;	3733	!
;	3734	!	See PAT$FREEZ
;	3735	!
;	3736	! Implicit Outputs:
;	3737	!
;	3738	!	See PAT$FREEZ
;	3739	!
;	3740	! Routine Value:
;	3741	!
;	3742	!	0, if something goes wrong, an RST-pointer to the
;	3743	!	allocated storage, otherwise.
;	3744	!
;	3745	! Side Effects:
;	3746	!
;	3747	!	See PAT$FREEZ
;	3748	!--
;	3749	
;	3750	BEGIN
;	3751	LOCAL
;	3752		STORAGE_PTR;
;	3753	
;	3754	STORAGE_PTR = PAT$FREEZ( .UNITS );
;	3755	
;	3756	!++
;	3757	! Currently an RST-pointer is just like a virtual
;	3758	! address except that the top 16 bits are 0 in the
;	3759	! former, and hex 7FFF0000 in the latter.
;	3760	! NOTE:  THIS IS ONLY TRUE IF THE DEBUGGER INDICATOR IS TURNED OFF IN
;	3761	! PAT$FREE_INIT.  IF IT IS TURNED ON, THEN THE STORAGE IS OWN STORAGE, NOT

; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 13-1
; Digital Equipment Corporation
;
;	3762	! CONTAINED IN SYSTEM SPACE.
;	3763	!--
;	3764	RETURN( .STORAGE_PTR - .PAT$GL_RST_BEGN );
;	3765	
;	3766	END;





					 0000 005EB 	    .ENTRY  PAT$RST_FREEZ, Save nothing				      ; 3707
				  04   AC  DD 005ED 	    PUSHL   UNITS						      ; 3754
	      00000000G  EF	       01  FB 005F0 	    CALLS   #1, PAT$FREEZ					      ;
		         50 00000000G  EF  C2 005F7 	    SUBL2   PAT$GL_RST_BEGN, R0					      ; 3764
					   04 005FE 	    RET     							      ; 3707

; Routine Size:  20 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 14
; Digital Equipment Corporation
;
;	3767	GLOBAL ROUTINE PAT$RST_RELEASE ( RST_PTR, SIZE ) : NOVALUE =
;	3768	
;	3769	!++
;	3770	! FUNCTIONAL DESCRIPTION:
;	3771	!
;	3772	!	Isolate storage deallocation for all storage which
;	3773	!	is accessed via RST-pointers.
;	3774	!
;	3775	!	i.e. Do exactly what PAT$FREERELEASE does for the rest of 
;	3776	!	PATCH, but take care of any differences (which may
;	3777	!	or may not exits), when it is the RST interface
;	3778	!	which wants to free up this special-access storage.
;	3779	!
;	3780	!	For now, there IS a difference - an RST-pointer is
;	3781	!	given to indicate which storage to free up.  This makes
;	3782	!	PAT$RST_RELEASE the inverse of PAT$RST_FREEZ, just
;	3783	!	as is true for the standard PATCH storage primitives.
;	3784	!
;	3785	! Formal Parameters:
;	3786	!
;	3787	!  RST_PTR - this indicates which storage
;	3788	!		 is to be freed.  This must be the same as
;	3789	!		 one which was returned by DBG$RST_FREEZ.
;	3790	!  SIZE		-The number of units which corresponds
;	3791	!		 to the storage to be freed.
;	3792	!
;	3793	! Implicit Inputs:
;	3794	!
;	3795	!	See PAT$FREEZ
;	3796	!
;	3797	! Implicit Outputs:
;	3798	!
;	3799	!	See PAT$FREEZ
;	3800	!
;	3801	! Routine Value
;	3802	!
;	3803	!	NOVALUE
;	3804	!
;	3805	! Side Effects:
;	3806	!
;	3807	!	See PAT$FREEZ
;	3808	!--
;	3809	
;	3810	BEGIN
;	3811	
;	3812	!++
;	3813	! Currently an RST-pointer is just like a virtual
;	3814	! address except that the top 16 bits are 0 in
;	3815	! in the former and hex 7FFF0000 in the latter.
;	3816	!--
;	3817	PAT$FREERELEASE( .RST_PTR + .PAT$GL_RST_BEGN, .SIZE );
;	3818	END;




; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 14-1
; Digital Equipment Corporation
;


					 0000 005FF 	    .ENTRY  PAT$RST_RELEASE, Save nothing			      ; 3767
				  08   AC  DD 00601 	    PUSHL   SIZE						      ; 3817
	   7E	    04   AC 00000000G  EF  C1 00604 	    ADDL3   PAT$GL_RST_BEGN, RST_PTR, -(SP)			      ;
	      00000000G  EF	       02  FB 0060D 	    CALLS   #2, PAT$FREERELEASE					      ;
					   04 00614 	    RET     							      ; 3767

; Routine Size:  22 bytes



; Bliss-32 7.352	Saturday 22-AUG-1978 03:33:24	DBB3:[PATCH.SRC]PATINT.B32;14					Page 15
; Digital Equipment Corporation
;
;	3819	END								! End of module
;	3820	ELUDOM




							    .GLOBL  LIB$SIGNAL

;				       PSECT SUMMARY
;
;	Name		 Bytes			       Attributes
;
;  _PAT$OWN       	    44    WRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$CODE      	  1557  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)
;  _PAT$PLIT      	     8  NOWRT,  RD ,NOEXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(0)
;  $CODE$         	     0  NOWRT,  RD ,  EXE,NOSHR,  LCL,  REL,  CON,NOPIC,ALIGN(2)




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  DBA4:[SYSLIB]LIB.L32;1		      5582        15         0       227





; Size:		1557 code + 52 data bytes
; Run Time:	01:05.0
; Elapsed Time:	02:13.0
; Memory Used:	454 pages
; Compilation Complete
