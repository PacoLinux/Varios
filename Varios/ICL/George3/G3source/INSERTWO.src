  16 22FL    #SEG  INSERTWO6                    [ JUDY BIDGOOD   
  17 22_=    #OPT  K0INSERTWO=K0INSERT>K0ACCESS>K0FILESTORE>K0ALLGEO 
   7 23DW    #LIS  K0INSERTWO
   7 23YG          8HINSERTWO
   4 24D6    [   
  12 24XQ          SEGENTRY K1INSERTWO,X1INSERTWO
   4 25CB    [   
   4 25X2    #   
  21 26BL    #     THIS SEGMENT IMPLEMENTS THE FOLLOWING PARTS OF THE INSERT & REPLAC
   7 26W=    #     MACROS.   
   4 27*W    #   
   8 27TG    #     (NOT MARK 6)  
  18 28*6    # A)  CALCULATES WHICH DIRECTION WE SHOULD TAKE OVERFLOW.   
   4 28SQ    #   
  20 29#B    # B)  CALCULATES IF OVERFLOW SHOULD BE FITTED INTO AN ADJACENT BLOCK
  21 29S2    #     IN THE APPROPRIATE DIRECTION. IF SO READS IT DOWN. IF NOT,GOES TO 
   6 2=?L    #     (E)   
   4 2=R=    #   
  21 2?=W    # C)  IF RECORD FITS, CALCULATES IF IT IS WORTH^SMOOTHING^ THE CONTENTS 
  18 2?QG    #     OF THE 2 BLOX, & RECALCULATES OVERFLOW,& GOES TO (F)  
   4 2#=6    #   
  18 2#PQ    # D)  IF RECORD DOESN'T FIT,GOES ACROSS TO INSERTHR CHAPTER.
   4 2*9B    #   
  21 2*P2    # E)  SETS UP A USAGE BLOCK & INSERTS A BLOCK NUMBER IN THE FCB.CALCULAT
  17 2B8L    #     OVERFLOW INTO NEW BLOCK,SMOOTHING THE CONTENTS.   
   4 2BN=    #   
  14 2C7W    # F)  MOVES ACROSS OVERFLOW & INSERTS RECORD
   4 2CMG    #   
   6 2D76    #     ERRORS
   5 2DLQ    ZGEOER1 
  21 2F6B          GEOERR  1,NOFULLB        [FULLB HAS DISAPPEARED FROM FILE CHAIN.  
   5 2FL2    ZGEOER2 
  20 2G5L          GEOERR  1,OVERFLOW           [INSERT:OVERFLOW MISCALCULATED   
   5 2GK=    ZGEOER4 
  19 2H4W          GEOERR  1,BIT NSET           [EXPECTED SWITCHES NOT SET   
   5 2HJG    ZGEOER5 
  21 2J46          GEOERR   1,SHARE ?           [MORE THAN 2X GSBS IN 2 FILESTORE BLO
   5 2JHQ    ZGEOER6 
  20 2K3B          GEOERR  1,MOVEZERO           [UNEXPECTED ZERO MOVE IN INSERT  
   5 2KH2    ZGEOER7 
  18 2L2L          GEOERR  1,STO ZERO           [MOVE OR LESS AS ABOVE   
   5 2LG=    ZGEOER8 
  18 2L_W          GEOERR  1,WILL GO!           [INSERT HAS MISCALCULATED
   5 2MFG    ZGEOER9 
  18 2M_6          GEOERR  1,NO BLOCK           [ERROR IN SFINDFURB S/R. 
   5 2NDQ    ZGEOER10
  18 2NYB          GEOERR  1,BLOKRONG       [USAGE BLOCK IN FIXED CORE ! 
   5 2PD2    ZGEOER11
  21 2PXL          GEOERR  1,ENDBLOCK           [INSERT REACHED E.O.B. UNEXPECTEDLY. 
   5 2QC=    ZGEOER12
  21 2QWW          GEOERR 1,TOPHALF                [MISCALCULATION IN INSERT MACRO   
   5 2RBG    ZGEOER13
  20 2RW6          GEOERR 1,OTHER1/2           [MISCALCULATROE IN INSERT MACRO   
   4 2S*Q    #   
   5 2STB    SFULLB  
   8 2T*2    #HAL  BSTB+FULLB,0  
   6 2TSL    KXINSERTWO  
   4 2W#=    X   
  20 2WRW          +GSBS/4  [THISPARAMETER DECIDES THE MAXIMUM AMOUNT OF OEVRFLOW
  16 2X?G                   [WE TRY TO FIT INTO AN ADJACENT BLOLK
   6 2XR6    KPINSERTWO  
   5 2Y=Q    PERCENT 
  20 2YQB          +GSBS*3/10  [THIS PARAMEJER DETERMINES THE MINIMUM'FULLNESS'  
  17 2_=2                   [BEYOND WHICH WE DON'T ^SHARE^ BLOCKS.   
  10 2_PL    #     USES  OF AWORK WORDS  
   4 329=    #   
  11 32NW    #     AWORK1  : B0 :  REPLACE   
  16 338G    #               B1 :  REPLACING LAST RECORD IN BLOCK
  12 33N6    #               B2 :  CAREFUL FILE  
  14 347Q    #               B3 :  OVERFLOW FORWARD BIT  
  18 34MB    #               B4 :  ^RECORD IN NEXT BLOCK^(R.I.N.B.) BIT. 
  16 3572    #               B5 :  AN EMPTY BLOCK HAS BEEN SET UP
  19 35LL    #               B6 :  AN EMPTY BLOCK AT E.O.F.HAS BEEN SET UP.  
  16 366=    #               B7 :  INSERT3 BLOCK A RE-NAMED FUWB.
   4 36KW    #   
  14 375G    #              B15-B23: SIZE EXTRA REQUIRED 
  10 37K6    #     AWORK2  :  FILE DEPTH 
   4 384Q    #   
  15 38JB    #     AWORK3  :  TOP 9 BITS:- SIZE OF NEW RECORD
  19 3942    #             :  BOTTOM 10 BITS:- VOLUME USED IN INSERT1 BLOCK. 
   4 39HL    #   
  20 3=3=    #     AWORK4  :  OVERFLOW  (B3 OF AWORK1 INDICATES WHICH DIRECTION) 
   4 3=GW    #   
  11 3?2G    #     USES  OF ACOMMUNE WORDS   
   4 3?G6    #   
  21 3?_Q    #     ACOMMUNE4  : AMOUNT USED IN INSERT3 BLOCK(OR PTR TO SAME);PTR TO  
  11 3#FB    #                  INSERT1 BLOCK
  11 3#_2    #     ACOMMUNE5  : POINTS TO FCA
   4 3*DL    #   
  17 3*Y=    #     ACOMMUNE2  : PTR TO INSERT3 BLOCK(RENAMED A FUWB) 
   4 3BCW    #   
   4 3BXG    #   
   4 3CC6    #   
   8 3CWQ    #     SUBROUTINES   
   4 3DBB    #   
   4 3DW2    #   
   4 3F*L    #   
  10 3FT=    SFCB3          [SET X3-> FCB
   8 3G#W          SMO      FX2  
   9 3GSG          LDX   0  AWORK2   
  15 3H#6          SFSTACK  0,3                 [X3 -> FCA   
   8 3HRQ          SMO      FX2  
  14 3J?B          STO   3  ACOMMUNE5           [STORE   
   8 3JR2          PSTAC    3,3  
  15 3K=L          BFCBX    3,3                 [X3 -> FCB   
   7 3KQ=          EXIT  6  0
   4 3L9W    #   
   6 3LPG    SENDBLOCK   
   9 3M96    #SKI  K6INSERT>699-699  
   9 3MNQ          TRACE   3,SENDBL. 
  18 3N8B          LDX   1  3                   [X3 &X1 -> NEXT RECORD   
   5 3NN2    SEBLP   
  14 3P7L          LDEX  0  FRH(1)              [NEXT R.H
  15 3PM=          ADS   0  1                   [ADD INTO PTR
  17 3Q6W          BNZ   0  SEBLP               [J BACK IF NON ZERO  
   9 3QLG    #SKI  K6INSERT>699-699  
   9 3R66          TRACE   1,SENDIS  
  13 3RKQ          EXIT  7  0                   [EXIT
   4 3S5B    #   
   5 3SK2    SFURB   
   8 3T4L          SMO      FX2  
  17 3TJ=          LDX   0  AWORK2              [SET X2 - > FSTACK   
  15 3W3W          SFSTACK  0,2                 [X2 -> FCA   
   8 3WHG          SMO      FX2  
  14 3X36          STO   2  ACOMMUNE5           [STORE   
   5 3XGQ    SFFURB  
  17 3Y2B          PSTAC    2,2                 [X2 -> STACK BLOCK   
   9 3YG2          BRN      SFFULP   
   6 3Y_L    SFINDFURB   
  20 3_F=    #     CALLED BY X1.THE WORD AFTER THE CALL CONTAINS THE TYPE/SUBTYPE
  20 3_YW    #     WANTED.X3 ->FCB,X2 WILL POINT ON EXIT TO THE BLOCK REQUIRED.  
  17 42DG          LDX   2  FPTR(3)             [J OVER FSTACK BLOCK 
   5 42Y6    SFFULP  
  19 43CQ          BXE   2  CXFI,ZGEOER9        [ERROR IF END OF FILE CHAIN. 
  15 43XB          LDX   2  FPTR(2)             [NEXT BLOCK  
   9 44C2          LDX   0  ATYPE(2) 
   7 44WL    #SKI  K6INSERT  
  19 45B=          BXE   0  FILEPLUSFCB,ZGEOER9 [ERROR IF END OF FILE CHAIN. 
  16 45TW          BXU   0  0(1),SFFULP         [J IF WRONG TYPE 
  17 46*G          EXIT  1  1                   [EXIT ROUND TYPE-WORD
   4 46T6    #   
   5 47#Q    SEEKFURB
  14 47SB          LDX   2  ACOMMUNE5(2)        [-> FCA  
   6 48#2    SEEKFURB2   
   7 48RL          PSTAC 1,2 
  15 49?=          BFCBX 1,1                    [X1 -> FCB   
  15 49QW          SMO      FREADBLOCK(2)       [B.N. WANTED 
   8 4==G          LDX   7  0(1) 
   4 4=Q6    #   
   4 4?9Q    SFUB
  20 4?PB    #     THIS  ROUTINE LOOKS FOR THE USAGE BLOCK WHOSE B.N. IS IN X7.  
  20 4#92    #     X1 -> FCB ON ENTRY,X3 -> USAGE BLOCK ON NORMAL EXIT, EXIT +1  
  19 4#NL    #     MEANS IT'S NOT THERE. IF IT'S A FUWB, B7 OF AWORK1 IS SET.
  16 4*8=          LDX   3  FPTR(1)             [J OVER FSTACK   
   4 4*MW    SLPY
  15 4B7G          LDX   3  FPTR(3)             [NEXT BLOCK  
  19 4BM6          BXE   3  CXFI,SIXET          [EXIT IF END OF FILE CHAIN   
   9 4C6Q          LDX   0  ATYPE(3) 
  16 4CLB          BXE   0  FILEPLUSFCB,SIXET   [EXIT IF NEXT FCB
  19 4D62          BXU   7  BACK2(3),SLPY       [LOOP BACK IF WRONG B.S.H.   
  16 4DKL          BXE   0  FFSFURB,(6)         [EXIT OK IF FURB 
  18 4F5=          BXU   0  FFSFUWB,SLPY        [LOOP BACK IF NOT FUWB   
   7 4FJW          LDCT  0  2
   8 4G4G          SMO      FX2  
  14 4GJ6          ORS   0  AWORK1              [SET BIT 
   7 4H3Q          EXIT  6  0
   7 4HHB    SIXET EXIT  6  1
   4 4J32    #   
   4 4JGL    #   
   5 4K2=    OFLOWFOR
  20 4KFW    #     THIS SUBROUTINE CALCULATES HOW MUCH OVERFLOW WILL RESULT FROM 
  21 4K_G    #     INSERTING OR REPLACING A RECORD AND PUSHING EXTRA DATA THAT WON'T 
  16 4LF6    #     FIT OFF THE BOTTOM END.I.E. FORWARD OVERFLOW. 
   4 4LYQ    #   
  10 4MDB    #     ENVIRONMENT ON ENTRY  
   8 4MY2    #     X3 -> RECORD  
  14 4NCL    #     X5 CONTAINS VOLUME WE HAVE TO FIT IN. 
   7 4NX=    #     X2-> FCA  
   4 4PBW    #   
  10 4PWG    #     USE OF ACCUMULATORS   
  21 4QB6    #     X4 - RELATIVE PTR FROM START OF BLOCK TO RECORD WE'VE STEPPED TO. 
  12 4QTQ    #     X1 -> RECORD WE'VE STEPPED TO 
  14 4R*B    #     X3 -> RECORD INDICATER BY READ PTRS.  
   4 4RT2    #   
   7 4S#L    #     ON EXIT   
  21 4SS=    #     AWORK4 CONTAINS THE AMOUNT AFTER THE RECORD WHICH IS TO BE LEFT IN
   7 4T?W    #     THE BLOCK 
   4 4TRG    #   
  10 4W?6          LDX   4  FREADWORD(2) 
  21 4WQQ          LDX   1  3                   [WE USE X1 TO POINT TO THE RECORDS   
  21 4X=B                                       [CONTAINS A RELATIVE PTR INCLUDING   
  21 4XQ2                                       [ALL THE EXTRA WORDS(=[X47) WE HAVE  
  16 4Y9L                                       [TO FIND ROOM FOR
  19 4YP=          ADX   4  5                   [ADD ON EXTRA AREA REQUIRED  
   8 4_8W          SMO      FX2  
   9 4_NG          LDX   0  AWORK1   
  16 5286          BPZ   0  NREP8               [J IF NOT REPLACE
  17 52MQ          LDEX  0  FRH(3)              [SKIP OVER RECORD.   
   7 537B          ADX   4  0
   7 53M2          ADX   1  0
   5 546L    NREP8   
  21 54L=          BXGE  4  BSBSA1,NUFPH        [J IF ALREADY TOO MUCH,I.E THE REPLAC
  21 555W                                       [OR INSERTED RECORD WILL HAVE TO GO  
  16 55KG    XLP                                [INTO A NEW BLOCK
  14 5656          LDEX  0  FRH(1)              [NEXT R.H
   7 56JQ    #SKI  K6INSERT  
  19 574B          BZE   0  ZGEOER8             [SO IT DOES FRT AFTER ALL!   
  21 57J2          ADX   4  0                   [RELATIVE PTR,TO TELL US WHEN WE'VE  
  20 583L                                       [REACHED THE END OF THE BLOCK.   
  18 58H=          BXL   4  BSBSA1,NOTENUF      [J IF NOT OVERFLOWED YET.
  15 592W          SBX   4  0                   [STEP BACK.  
   8 59GG          BRN      NUF  
   5 5=26    NOTENUF 
  19 5=FQ          ADX   1  0                   [O/W,INCREMENT X1 & CARRY ON 
   8 5=_B          BRN      XLP  
   5 5?F2    NUFPH   
  19 5?YL          LDCT  0  #20                 [THE BIT WHICH INDICATES THAT
  21 5#D=          SMO      FX2                 [THE ^OPERATED ON^ RECORD(REPLACED OR
  21 5#XW          ORS   0  AWORK1               [INSERTED)GFES INTO THE NEXT BLOCK. 
   4 5*CG    NUF 
   8 5*X6          SMO      FX2  
  19 5BBQ          LDX   0  AWORK3          [A1 + AREA USED IN INSERT1 BLOCK 
   8 5BWB          ANDN  0  -1   
  19 5CB2          SBX   0  4                   [LESS (A1 + AMOUNT OF BLOCK  
  20 5CTL          ADX   0  5                   [ TO BE LEFT IN INSERT1 BLOCK)   
   8 5D*=          SMO      FX2  
  14 5DSW          STO   0  AWORK4              [STORE   
   8 5F#G    #SKI  K6INSERT>99-99
   9 5FS6          TRACE  0,OVERFLOW 
   7 5G?Q          EXIT  7  0
   4 5GRB    #   
   6 5H?2    #SKI  INSB  
   4 5HQL    (   
   5 5J==    OFLOWBAC
  21 5JPW    #     THIS ROUTINE CALCULATES THE AMOUNT OF OVERFLOW INCURRED BY PUSHING
  14 5K9G    #     THE DATA UP THE BLOCK,AND OFF THE TOP.
   4 5KP6    #   
  10 5L8Q    #     USE OF ACCUMULATORS   
  13 5LNB    #     X4 CONTAINS OVERFLOW EVENTUALLY   
  12 5M82    #     X5 CONTAINS AMOUNT TO FIT IN  
  13 5MML    #     X1 -> RECORD WE HAVE STEPPED TO.  
  15 5N7=    #     X3 -> RECORD INDICATED BY THE READ PTRS.  
   4 5NLW    #   
   7 5P6G    #     ON EXIT   
   8 5PL6    #     X3 UNCHANGED  
   9 5Q5Q    #     X5 CONTAINS O'FLOW
   4 5QKB    #   
  20 5R52          LDN   4  0                   [USED TO KEEP AMOUNT OF OVERFLOW.
  17 5RJL          LDX   1  3                   [  -> CURRENT REC.   
  13 5S4=          SBX   1  FREADWORD(2)    [-> FURB 
  15 5SHW          ADN   1  A1              [-> 1ST RECORD   
   4 5T3G    ZLP 
  21 5TH6          BXE   1  3,RECNEXTB          [J IF ^OPERATED ON^ RECORD GOES INTO 
  16 5W2Q                                       [PREVIOUS BLOCK  
  15 5WGB          LDEX  0  FRH(1)              [NEXT RECORD 
   7 5X22    #SKI  K6INSERT  
  14 5XFL          BZE   0  ZGEOER8             [ERROR   
  16 5X_=          ADS   0  4                   [CT OF OVERFLOW. 
   7 5YDW          ADX   1  0
  21 5YYG          BXL   4  5,ZLP               [J BACK IF TOTAL IS STILL LESS THAN  
  14 5_D6                                       [512+A1  
   9 5_XQ    #SKI  K6INSERT>199-199  
   9 62CB          TRACE   4,OFLOW B2
   7 62X2          EXIT  7  0
   5 63BL    RECNEXTB
  17 63W=          LDCT  0  #20                 [SET THE ^R.I.N.B^   
  12 64*W          SMO      FX2             [BIT 
   9 64TG          ORS   0  AWORK1   
   7 65*6          ADX   4  5
   7 65SQ          EXIT  7  0
   4 66#B    )   
   4 66S2    #   
  16 67?L    SFINDFULLB     [SET X3 ->FCB,X2-> APPROPRIATE FULLB 
  21 67R=    #     CALLED BY X6,OVERWRITES X2,WHICH POINTS TO AN  APPROPRIATE FULLB  
  14 68=W    #     FOR THIS FILE ON SUCCESSFUL EXIT (+1) 
  10 68QG    #     EXIT +0 => NO FULLB   
   9 69=6    #     X3 POINTS TO FCB. 
   8 69PQ          SMO      FX2  
   9 6=9B          LDX   0  AWORK2   
  17 6=P2          SFSTACK  0,2,2               [FIND X2 -> FSTACK   
  15 6?8L          BFCBX    3,2                 [X3 -> FCB   
   4 6?N=    SFLP
  15 6#7W          LDX   2  FPTR(2)             [NEXT BLOCK. 
  18 6#MG          BXE   2  CXFI,(6)            [J IF END OF FILE CHAIN  
  13 6*76          LDX   0  ATYPE(2)            [TYPE
  20 6*LQ          BXE   0  FILEPLUSFCB,(6)     [EXIT FCB, SEARCH UNSUCCESSFUL   
   8 6B6B          SMO      FX1  
  17 6BL2          BXU   0  SFULLB,SFLP         [J IF NOT BSTB/FULLB 
   9 6C5L          LDX   0  A1+1(2)  
  18 6CK=          BXU   0  BSPRE(3),SFLP       [J IF WRONG B.S.PREFIX.  
   7 6D4W          EXIT  6  1
   4 6DJG    #   
   5 6F46    SFCA2   
   8 6FHQ          SMO      FX2  
  14 6G3B          LDX   0  AWORK2              [DEPTH   
  15 6GH2          SFSTACK  0,2                 [X2 -> FCA   
   8 6H2L          SMO      FX2  
   9 6HG=          STO   2  ACOMMUNE5
   8 6H_W          EXIT  6   0   
   4 6JFG    #   
   4 6J_6    #   
   6 6KDQ    SCAREFULA   
  20 6KYB    #     THIS  ROUTINE DOES ALL THE CAREFUL UPDATING FOR 1 BLOCK HAVING
  21 6LD2    #     BEEN CHANGED. IF NECESSARY A BSTR/FULLB IS SET UP,OR ALTLEN'ED,   
  13 6LXL    #     AND THE BLOCK NO. IS SWAPPED OVER 
   4 6MC=    #   
  13 6MWW    #     OVERWRITES  X1,2,3,6, CALLED BY X7
  21 6NBG    #     X4 THROUGHOUT INDICATES WHICH BLOCK NUMBER TO CHANGE (A FREADBLOCK
  13 6NW6    #     TYPE  PTR REL. TO AD OF THE FCB); 
  19 6P*Q    #     ON EXIT  X2 -> THE USAGE BLOCK; THIS IS ASSUMED TO BE A   
   9 6PTB    #     FI/INSERT4 BLOCK  
   4 6Q*2    #   
   8 6QSL          LDX   2  FX2  
  10 6R#=          LDX   2  ACOMMUNE5(2) 
   8 6RRW          PSTAC    2,2  
  16 6S?G          BFCBX   3,2                  [SET X3-> FCB.   
   9 6SR6    #SKI  K6INSERT>199$199  
   9 6T=Q          TRACE   4,CAREFUL 
  17 6TQB          JBC      STEND,3,BFCARE      [EXIT IF NOT CAREFUL 
  19 6W=2          LDX   0  4                   [BLOCK WE'RE INTERESTED IN   
  14 6WPL          SBN   0  FBLKS-1             [DATUMISE
  20 6X9=          MAPBCH   0,3                 [CHECK IF BIT SET IN FMAPP BLOCK.
  16 6XNW          BNZ   0  STEND               [EXIT IF IT IS   
  16 6Y8G          SBX   7  FX1                 [DATUMISE LINK   
  21 6YN6          JBC      NEWFULLB,3,BFALTR   [IF FILE NOT ALTERED,SET UP A FULLB  
  17 6_7Q          CALL  6  SFINDFULLB          [X2-> FULLB,X3-> FCB 
  18 6_MB          BRN      NEWFULLB            [J IF FULLB NOT PRESENT  
  16 7272          LDX   6  ALOGLEN(2)          [NOW ALTLEN FULLB
   7 72LL          ADN   6  1
   7 736=          LDX   3  2
  15 73KW          ALTLEN  3,6                  [BY ONE WORD 
  17 745G          CALL  6  SFINDFULLB          [X2-> FULLB,X3->FCB  
  16 74K6          BRN      ZGEOER1         [ERROR IF NO FULLB   
  19 754Q          BRN      SFULONG             [WHENCE WE CAME FOR GEOERR.  
   5 75JB    NEWFULLB
  17 7642          SETNCORE  3,1,BSTB,FULLB     [SET UP FUUB,X1 -> IF
  14 76HL          CALL  6  SFCB3               [X3 ->FCB
  15 773=          LDX   2  3                   [X1 -> FCB   
   4 77GW    XLPA
  19 782G          LDX   2  FPTR(2)             [NEXT BLOCK IN FILE CHAIN.   
  18 78G6          BXE   2  CXFI,SCHAIN         [J IF END OF FILE CHAIN. 
   9 78_Q          LDX   0  ATYPE(2) 
  18 79FB          BXE   0  FILEPLUSFCB,SCHAIN  [J IF WE'VE REACHED FCB  
  18 79_2          SMO      FX1                 [O/W SEARCH FOR FULLB.   
  10 7=DL          BXU   0  SFULLB,XLPA  
   5 7=Y=    SCHAIN  
  17 7?CW          STO   1  6                   [PRESERVE FULLB PTR  
  19 7?XG          CHAIN    1,BPTR(2)           [CHAI> IN FRONT OF NEXT FCB  
  17 7#C6          LDX   2  6                   [PICK UP FULLB PTR.  
  17 7#WQ          LDX   0  BSPRE(3)            [B.S. PREFIX OF FULLB
   9 7*BB          STO   0  A1+1(2)  
  15 7*W2          LDN   0  2                   [R.H.OF FULLS
   8 7B*L          STO   0  A1(2)
   5 7BT=    SFULONG 
   5 7C#W    SGETBAC 
  18 7CSG          LDX   3  BSPRE(3)            [SAVE BSPRE OVER COOR.   
  15 7D#6          GETBACK  3              [GET ONE BLOCK.   
  10 7DRQ          ADDSKIP  I516A,BSGET  
  17 7F?B          LDX   1  3                   [SAVE OVER NEXT S/R  
  14 7FR2          CALL  6  SFCB3               [X3->FCB 
  21 7G=L          BXE   1  BSPRE(3),SBLOKOK    [JIF BSPRE HASN'T CHANGED OVER COOR  
  10 7GQ=          LDX   2  ACOMMUNE7(2) 
  15 7H9W          FREEBACK 1,2                 [FREE BLOCK  
  10 7HPG          ADDSKIP  I516A,ADLFBL 
   8 7J96          CALL  6  SFCB3
   9 7JNQ          BRN      SGETBAC  
   5 7K8B    SBLOKOK 
   9 7KN2          LDX   2  FPTR(3)  
  15 7L7L          CALL  6  SFLP                [X2 -> FULLB 
   9 7LM=          CALL  0  ZGEOER5  
   7 7M6W          SMO      4
   8 7MLG          LDX   0  0(3) 
  17 7N66          SMO      A1(2)               [OLD BLOCK IN FULLB  
   8 7NKQ          STO   0  A1(2)
  15 7P5B          LDN   0  1                   [UPDATE R.H  
   8 7PK2          ADS   0  A1(2)
   8 7Q4L          SMO      FX2  
  15 7QJ=          LDX   6  ACOMMUNE7           [NEW BLOCK   
   7 7R3W          SMO      4
  16 7RHG          STO   6  0(3)                [NGN BLOCK IN FCB
  16 7S36          CALL  1  SFINDFURB           [FIND USAGE BLOCK
   8 7SGQ    #HAL  FI+INSERT4,0  
  15 7T2B          STO   6  BACK2(2)            [BLOCK NUMBER
  12 7TG2          LDX   0  BSPRE(3)            [
  15 7T_L          STO   0  BACK1(2)            [B.S.PREFIX. 
  21 7WF=          MBS      3,BFALTR,BFALTB     [INDICATE FILE & BLOCK NOS. ALTERED  
  15 7WYW          STO   2  6                   [PTR TO FURB 
  16 7XDG          SBN   4  FBLKS-1             [RELATIVISE PTR  
  18 7XY6          MAPBSE 4,3                   [SET BIT IN FMAPP BLOCK  
  13 7YCQ          LDX   2  6                   [PTR 
   9 7YXB          ADN   4  FBLKS-1  
   8 7_C2          ADX   7  FX1  
   7 7_WL          EXIT  7  0
   5 82B=    STEND   
  17 82TW          CALL  1  SFINDFURB           [X2 ->INSERT4 BLOCK  
   8 83*G    #HAL  FI+INSERT4,0  
   7 83T6          EXIT  7  0
   4 84#Q    #   
   4 84SB    #   
  21 85#2    #     THIS  S/R DOES THE CAREFUL UPDATING FOR A NEW BLOCK; A BIT HAS TO 
  20 85RL    #     BE INSERTED IN THE FMAP BLOCK,AND A BLOCK NO. INSERTED IN THE 
   6 86?=    #     FCB   
   4 86QW    #   
  18 87=G    #     OVERWRITES X1,2,3,6; X4 -> BLOCK NO. BEFORE WHICH THE 
  21 87Q6    #     BLOCK IS TO BE INSERTED. IN THE CASE OF     NON-CAREFUL FILES,WE  
  20 889Q    #     CAN USE AN UNUSED BL.NO.,   IF ANY;O/W WE MUST GET A NEW ONE. 
  11 88PB    #     X2 ON EXIT -> USAGE BLOCK 
   5 8992    SINSERT 
   5 89NL    SINSERT1
   8 8=8=          SBX   7  FX1  
  15 8=MW          DOWN     INSERTBL,2          [INSERT BLOCK
  11 8?7G          TESTREP  FILEFULL,SFULL   
   8 8?M6          ADX   7  FX1  
  15 8#6Q          CALL  1  SFURB               [X2 -> INSERT
   8 8#LB    #HAL FI+INSERT3,0   
   7 8*62          EXIT  7  0
   4 8*KL    #   
  21 8B5=    #     THIS S/R MOVES DOWN AN AMOUNT OF CORE(IN AN USAIE BLOCK),OF SIZE  
  13 8BJW    #     [X0] DOWN THE USAGE BLOCK BY [X1] 
  18 8C4G    #     [X3] IS THE START OF THE AREA TO BE MOVED,& X2 -> FX2 
   4 8CJ6    #   
   6 8D3Q    MOVEDOWNB   
   9 8DHB    #SKI  K6INSERT>199-199  
   4 8F32    (   
  10 8FGL          TRACE    0,SIZEDOWN   
   8 8G2=          TRACE    1,BY 
   4 8GFW    )   
   7 8G_G    #SKI  K6INSERT  
   4 8HF6    (   
   9 8HYQ          BZE  1  ZGEOER6   
   9 8JDB          BZE  0  ZGEOER1   
  10 8JY2          BXGE 1  BSBS,ZGEOER6  
  10 8KCL          BXGE 0  BSBS,ZGEOER7  
   7 8KX=          LDN  4  -1
   9 8LBW          BXL  3  4,ZGEOER10
   4 8LWG    )   
  19 8MB6          LDX   4  1                   [SIZE OF SPACE TO BE CREATED 
  20 8MTQ                                       [THIS IS THE AMOUNT WE HAVE TO   
  17 8N*B          LDX   5  0                   [MOVE DOWN THE BLOCK 
  20 8NT2          ADX   5  3                   [X5   POINTS TO THE BOTTOM OF THE
  21 8P#L          LDX   6  5                   [AREA TO BE MOVED,X6 POINTS TO THE   
   7 8PS=          ADX   6  1
  21 8Q?W          SMO      6                   [BOTTOM OF THE AREA TO BE MOVED INTO.
  19 8QRG          STOZ     0                   [ZEROISE WORD AT END OF BLOCK
  21 8R?6    MOVELOOP       [   WE CAN ONLY MOVE DOWN [X4]=[X1] WORDS AT A TIME(OR   
  21 8RQQ                   [LESS,OF COURSE),FOR FEAR OF OVERWRITING WE START AT THE 
  21 8S=B          BXL   0  4,MOVELAST          [BOTTOM.J IF AMOUNT LEFT TO MOVE IS  
  18 8SQ2                                       [NOW LESS THAN MAXIMUM.  
   9 8T9L    #SKI  K6INSERT>399-399  
   9 8TP=          TRACE  5,NEXTDOWN 
  21 8W8W          SBX   5  4                   [MOVE POINTERS UP TO POINT TO NEXT   
  19 8WNG          SBX   6  4                   [AREAS TO BE MOVED TO & FROM.
   8 8X86          MOVE  5  0(1) 
  21 8XMQ          BXE   5  3,(7)               [EXIT IF AREA TO BE MOVED IS AN EXACT
  17 8Y7B                                       [MULTIPLE OF [X4].   
  20 8YM2          SBX   0  4                   [DECREMENT SIZE  OF AREA LEFT TO 
  21 8_6L          BRN      MOVELOOP            [MOVE AND JUMP BACK TO START OF LOOP 
  21 8_L=    MOVELAST                           [THIS CODE MOVES THE'REMAINDER' DOWN 
  17 925W          LDX   1  0                   [SIZE OF LAST MOVE   
   9 92KG    #SKI  K6INSERT>399-399  
   9 9356          TRACE  0,LASTDOWN 
  15 93JQ          LDX   5  3                   [FROM HERE   
   7 944B          LDX   6  3
  14 94J2          ADX   6  4                   [TO HERE 
   8 953L          MOVE  5  0(1) 
   7 95H=          EXIT  7  0
   4 962W    #   
   4 96GG    #   
   4 9726    #   
  11 97FQ    #     ENTRY POINT FROM INSERT.  
   4 97_B    #   
  15 98F2    #     BOTTOM   1/2 OF AWORK1 = EXTRA REQUIRED   
   4 98YL    #   
  21 99D=    #     AWORK3    = AMOUNT USED IN INSERT1 BLOCK(WHICH IS IN THE FILE CH.)
   4 99XW    #   
   6 9=CG    X1INSERTWO  
   9 9=X6    #SKI  K6INSERT>699-699  
  10 9?BQ          TRACE  FX2,INSERTWO   
  10 9?WB          ADDSKIP  I516A,INSE2  
  17 9#B2          CALL  1  SFURB               [X2 -> INSERT1 BLOCK 
   8 9#TL    #HAL  FI+INSERT1,0  
  17 9**=          LDX   3  2                   [X3 -> INSERT1 BLOCK 
   8 9*SW          SMO      FX2  
  15 9B#G          LDX   2  ACOMMUNE5           [X2 -> FCA   
   7 9BS6          PSTAC  1,2
  15 9C?Q          BFCBX  1,1                   [X1 -> FCB   
  17 9CRB          ADX   3  FREADWORD(2)        [X3 -> CURRENT RECORD
   6 9D?2    #SKI  INSB  
   4 9DQL    (   
   9 9F==          LDX   0  FBLMOD(1)
   9 9FPW          SBN   0  FBLKS-A1 
  19 9G9G          BZE   0  SONEBLOK            [J IF ONLY ONE BLOCK IN FILE 
  21 9GP6          ADN   0  FBLKS-2             [J IF OVERFLOW IS FROM PENULTIMATE   
  15 9H8Q          BXE   0  FREADBLOCK(2),SFORCALC   [BLOCK  
  19 9HNB          BXL   0  FREADBLOCK(2),SBAKCALC   [J IF FROM LAST BLOCK   
  19 9J82          LDN   0  FBLKS                   [J IF FROM FIRST BLOCK.  
  13 9JML          BXE   0  FREADBLOCK(2),SFORCALC   
  10 9K7=          SMO      FREADBLOCK(2)
  16 9KLW          LDX   7  1(1)                [SUCCEEDING B.N. 
   8 9L6G          CALL  6  SFUB 
  16 9LL6          BRN      SFORCALC            [J IF BLOCK FOUND
  10 9M5Q          LDX   0  FREADBLOCK(2)
   7 9MKB          SBN   0  1
   7 9N52          SMO      0
  17 9NJL          LDX   7  0(1)                [PRECEEDING BLOCK NO.
   8 9P4=          CALL  6  SFUB 
  16 9PHW          BRN      SBAKCALC            [J IF BL.FOUND   
  19 9Q3G          CALL  7  OFLOWFOR            [CALCULATE OVERFLOW FORWARDS 
  17 9QH6                                       [AND LEAVE IN AWORK4 
  19 9R2Q          CALL  7  OFLOWBAC            [CALCULATE OVERFLOW BACKWARDS
  17 9RGB          LDX   2  FX2                     [& LEAVE IN X4   
  21 9S22          BXGE  4  AWORK4(2),TRYFOR    [TRY FORWARDS,IF F'WARDS OVERFLOW IS 
  20 9SFL          BRN      TRYBAC              [LESS THAN OR EQUAL TO B'WARDS.  
   5 9S_=    SBAKCALC
   9 9TDW    #SKI  K6INSERT>199-199  
  12 9TYG          TRACE    FREADWORD(2),BACKWARD
  19 9WD6          CALL  7  OFLOWBAC            [CALCULATE B'WARDS O'FLOW.   
   8 9WXQ          LDX   2  FX2  
   5 9XCB    TRYBAC  
  16 9XX2          STO   4  AWORK4(2)           [STORE OVERFLOW. 
  16 9YBL          NGN   5  1                   [BLOCK MODIFIER  
   9 9YW=          BRN      TRYMERJ  
   4 9_*W    )   
   7 9_TG    #SKI  INSB<1$1  
   4 =2*6    (   
  17 =2SQ          LDX   4  FBLMOD(1)           [J IF NOT LAST BLOCK 
   8 =3#B          ADN   4  A1-1 
  13 =3S2          BXU   4  FREADBLOCK(2),SFORCALC   
   4 =4?L    )   
   5 =4R=    SONEBLOK
  12 =5=W          ADN   4  1              [BLOCK
   9 =5QG    #SKI  K6INSERT>199$199  
   9 =6=6          TRACE 4,ONEBLOCK  
  11 =6PQ          SETNCORE GSBS,1,FI,INSERT3
  19 =79B          STOZ     A1(1)               [ZEROISE BLOCK FOR TIME BEING
  14 =7P2          CALL  6  SFCB3               [-> FCB  
  15 =88L          LDX   2  FPTR(3)             [-> FSTACK   
  17 =8N=          CHAIN   1,2                  [CHAIN IN FILE CHAIN.
  17 =97W          LDCT  0  #14                 [EMPTY BLOCK & ...   
  20 =9MG          ORS   0  AWORK1(2)           [SET ^EMPTY BLOCK @ E.O.F^ BIT.  
  20 ==76          CALL  7  SINSERT1            [INSERT BLOCK ( @ END OF FILE )  
   8 ==LQ          SMO      FX2  
  20 =?6B          STO   2  ACOMMUNE4           [PRESERVE PTR TO INSERT3 BLOCK   
   8 =?L2          LDX   2  FX2  
  10 =#5L          LDX   2  ACOMMUNE5(2) 
   9 =#K=          CALL  1  SFFURB   
  15 =*4W    #HAL  FI+INSERT1,0                 [-> INSERT1  
   7 =*JG          LDX   3  2
  14 =B46          CALL  6  SFCA2               [-> FCA  
  15 =BHQ          ADX   3  FREADWORD(2)        [-> RECORD   
   5 =C3B    SFORCALC
   9 =CH2    #SKI  K6INSERT>199$199  
  12 =D2L          TRACE    FREADWORD(2),FORWARD 
  19 =DG=          CALL  7  OFLOWFOR            [CALCULATE FORWARDS OVERFLOW 
   8 =D_W          LDX   2  FX2  
   5 =FFG    TRYFOR  
  17 =F_6          LDCT  0  #40                 [SET THE ^OVERFLOWING
   9 =GDQ          ORS   0  AWORK1(2)
  18 =GYB          LDX   4  AWORK4(2)           [X4 = SIZE OF OVERFLOW   
  18 =HD2          LDN   5  1                   [MARKER - GET NEXT BLOCK 
   4 =HXL    #   
  20 =JC=    #     HAVING CALCULATED OVERFLOW & DIRECTION WE WANT TO GO, WE NOW  
  20 =JWW    #     LOOK TO SEE IF WE WANT TO FIT EXTRA INTO THE CONTIGUOUS BLOCK.
   4 =KBG    #   
   5 =KW6    TRYMERJ 
  16 =L*Q          LDCT  0  #20             [IF THE^RINB^ IS SET,
  20 =LTB          ANDX  0  AWORK1(2)       [ADD IN THE SIZE OF THE NEW RECORD   
  21 =M*2          BZE   0  NONEXTB         [& IF THE OVERFLOW( + NEW RECORD IF BEING
  20 =MSL          LDX   0  AWORK3(2)       [PUT IN NEXT BLOCK) IS GREATER THAN  
  21 =N#=          SRL   0  15              [THE PARAMETER ^X^ WE DON'T ATTEMPT TO   
  21 =NRW          ADX   4  0               [READ DOWN THE CONTIGUOUS BLOCK & SHARE I
   5 =P?G    NONEXTB 
  21 =PR6          BXGE  4  BSBS,TWONEWBLOX     [GO TO INSERTFR IF O'FLOW > GSBS-1   
  19 =Q=Q          SMO      ACOMMUNE5(2)        [SET FREADBLOCK TO POINT TO  
  16 =QQB          ADS   5  FREADBLOCK          [ADJACENT BLOCK  
  18 =R=2          CALL  6  SEEKFURB            [X3 ->^ADJACENT^ BLOCK   
  15 =RPL          BRN      YESFUB              [IT'S IN CORE
  15 =S9=          LDX   2  FX2                 [OVERWRITTEN.
   8 =SNW          SMO      FX1  
  20 =T8G          BXGE  4  X,XLESS         [JIF EXTRA INTO NEXT BLOCK TOO LARGE 
   8 =TN6          LDCT  0  #4   
   9 =W7Q          ANDX  0  AWORK1(2)
  21 =WMB          BZE   0  NOFUB2              [J IF^EMPTY BL.@ E.O.F.^BIT NOT SET. 
  10 =X72          SMO      ACOMMUNE5(2) 
  10 =XLL          SBS   5  FREADBLOCK   
   5 =Y6=    YEMPTYB 
  15 =YKW          LDX 3 ACOMMUNE4(2)     [->INSERT3 BLOCK   
  13 =_5G          LDX   2  ACOMMUNE5(2)     [-[FCA  
   8 =_K6          BRN   SGOTINS3
   4 ?24Q    #   
  20 ?2JB    #     THE OVERFLOW IS LESS THAN THE FACTOR X.THIS MEANS THAT WE READ
  20 ?342    #     DOWN A CONTIGUOUS BLOCK AND TRY TO FIT THE OVERFLOW IN TO IT. 
  20 ?3HL    #     ALTERNATIVELY THERE IS AN ADJACENT BLOCK IN CORE,IN WHICH CASE
  12 ?43=    #     WE TRY TO FIT THE EXTRA IN.   
   4 ?4GW    #   
   5 ?52G    TRYFURB 
  15 ?5G6          CALL  6  SEEKFURB2           [X3 ->BLOCK  
   8 ?5_Q          BRN   YESFUB  
   5 ?6FB    NOFUB   
   8 ?6_2          LDX   2  FX2  
   5 ?7DL    NOFUB2  
   9 ?7Y=          LDX   2  AWORK2(2)
  16 ?8CW          GETAFURB  0(2)           [GET THE USAGE BLOCK 
  15 ?8XG          CALL  6  SFCA2               [X2 -> FCA   
   9 ?9C6          BRN      TRYFURB  
   5 ?9WQ    YESFUB  
   9 ?=BB          NAME  3,FI,INSERT3
  19 ?=W2          SBS   5  FREADBLOCK(2)       [DOWNDATE FREADBLOCK AGAIN.  
   5 ??*L    SGOTINS3
  19 ??T=          ADN   3  A1                  [X3 -> BEGINNING OF BLOCK.   
  17 ?##W          CALL  7  SENDBLOCK           [X1 -> END OF BLOCK  
  19 ?#SG          NGX   7  1                   [X2 CONTAINS THE AMOUNT OF   
  17 ?*#6          ADX   7  3                   [BLOCK USED,NEGATED  
  17 ?*RQ          SBN   3  A1                  [X3 -> INSERT3 BLOCK 
  21 ?B?B          SMO      FX2                 [STORE AMOUNT USED IN INSERT3 BLOCK. 
  10 ?BR2    #     ! NB  'NOT' PLUS A1 ! 
   9 ?C=L          NGS   7  ACOMMUNE4
  18 ?CQ=          ADN   7  GSBS-1              [CALCULATE AMOUNT USED   
  18 ?D9W          BXL   7  4,WONTFIT           [J IF NOT ENOUGH ROOM.   
  20 ?DPG          LDX   0  7                   [X0 CONTAINS THE AREA LEFT AFTER 
  18 ?F96          SBX   0  4                   [MOVING IN THE OVERFLOW  
  21 ?FNQ          SMO      FX1                 [IF THIS AREA IS LESS THAN A CERTAIN 
  20 ?G8B          BXL   0  PERCENT,NSHAR       [NUMBER,WE DON'T SHARE THE BLOCKS
  19 ?GN2          LDX   6  FREADWORD(2)        [LOAD & PRESERVE FREADWORD.  
   4 ?H7L    #   
  20 ?HM=    #     WE CALCULATE THE AVERAGE  OF THE DATA SPREAD OVER THE TWO BLOX
  20 ?J6W    #     & ATTEMPT TO SHARE THE DATA IN THE 2 BLOX SO THAT THEY BOTH   
  20 ?JLG    #     CONTAIN (ROUGHLY) THE MEDIAN . WE ALSO INSERT THE EXTRA RECORD
  12 ?K66    #     IN THE GENERAL HURLY-BURLY.   
   4 ?KKQ    #   
  16 ?L5B          LDX   1  FX2                 [WE ADD TOGETHER 
  18 ?LK2          LDX   7  ACOMMUNE4(1)        [1) AMT. USED IN INSERT3.
   6 ?M4L    SHAR2BLOX   
  19 ?MJ=          LDX   0  AWORK3(1)           [2) AMT. USED IN INSERT1 + A1
   8 ?N3W          ANDN  0  -1   
   8 ?NHG          ADX   7   0   
  16 ?P36          LDEX  0  AWORK1(1)           [3) EXTRA WANTED.
   7 ?PGQ          ADX   7  0
  14 ?Q2B          SBN   7  A1                  [ SUB  A1
  15 ?QG2          SRA   7  1                   [DIVIDE BY 2 
   8 ?Q_L    #SKI  K6INSERT>99-99
   9 ?RF=          TRACE  7,SMOOTH 2 
   7 ?RYW    #SKI  K6INSERT  
  17 ?SDG          BXGE  7  BSBS,ZGEOER5        [J IO TOTAL TOO LARGE
  18 ?SY6          CALL  1  SFFURB              [SET X2->INSERT1 BLOCK   
   8 ?TCQ    #HAL  FI+INSERT1,0  
   8 ?TXB          LDX   1  FX2  
  15 ?WC2          SBN   6  A1                  [FREADWORD-A1
   8 ?WWL          LDCT  5  #020 
   9 ?XB=          LDX   0  AWORK3(1)
   8 ?XTW          SRL   0  15   
  20 ?Y*G          ADX   0  6                   [FREADWORD]-A1+SIZE OF NEW RECORD
   9 ?YT6          BXL   0  BSBS,NRNB
  21 ?_#Q          ORS   5  AWORK1(1)           [NEW REC JUST WON'T FIT IN ^CURRENT^ 
  21 ?_SB          BRN      NSHAR               [BLOCK SO SET RINB & DON'T BOTHER TO 
  21 #2#2                                       [RE-CALCULATE THE O'FLOW AS WE CAN'T 
  21 #2RL                                       [                       IMPROVE ON IT
   4 #3?=    NRNB
  21 #3QW          BXL   6  7,NRNB1             [JIF THE POSITION OF THE INSERTEE OR 
  21 #4=G                                       [REPLACEE SUGGESTS IT MAY FIT INTO   
  21 #4Q6                                       [                 THE ^CURRENT^ BLOCK
  20 #59Q          ORS   5  AWORK1(1)           [SET ^RECORD IN NEXT BLOCK^ BIT  
   4 #5PB    YRNB
   9 #692    #SKI  K6INSERT>299-299  
   9 #6NL          TRACE    4,YRNB   
   7 #78=          LDN   4  0
   8 #7MW          BRN      NB   
   5 #87G    NRNB1   
   9 #8M6          ANDX  5  AWORK1(1)
  19 #96Q          BNZ   5  YRNB                [JIF ^R.I.N.B.^ ALREADY SET  
   9 #9LB          LDEX  4  AWORK1(1)
   7 #=62          SBX   0  4
  21 #=KL          ADX   2  0                   [-> FIRST RECORD AFTER REPLACEE/INSER
  19 #?5=          ADX   4  0                   [= AMOUNT TO BE LEFT(SO FAR) 
   9 #?JW    #SKI  K6INSERT>299-299  
   8 ##4G          TRACE   4,NRNB
  21 ##J6          BXGE  4  7,NC                [J IF REPLACING NEW LAST REC IN BLOCK
   4 #*3Q    NB  
  15 #*HB          LDEX  0  A1+FRH(2)           [NEXT R.H.   
   7 #B32    #SKI  K6INSERT  
  16 #BGL          BZE   0  ZGEOER11            [ERROR IF E.O.B. 
  15 #C2=          ADX   2  0                   [ADD TO PTR. 
  21 #CFW          ADX   4  0                   [ADD NEXT R.H.INTO CUMULATIVE TOTAL  
  19 #C_G    #SKI  K6INSERT>699-699             [OF DATA TO BE LEFT IN BLOCK 
   4 #DF6    (   
   8 #DYQ          TRACE  4,OLOOP
   9 #FDB          TRACE  0,NEXT O   
   4 #FY2    )   
  17 #GCL          BXGE  4  7,NOT2NEWBLOX       [J IF SURPASSED AVGE.
  21 #GX=          BXGE  6  4,NB                [IF THE RECORD PTR GOES PAST F'WORD  
  21 #HBW          BZE   5  NB                  [WITHOUT EXCEEDING AVERAGE, AND RINB 
  21 #HWG          LDX   0  AWORK4(1)           [IS SET WE MUST HAVE A VERY LARGE NEW
  21 #JB6          BNZ   0  TWONEWBLOX5         [RECORD SO WE GO TO INSERTFR UNLESS  
  21 #JTQ                                       [         REPLACING LAST REC IN BLOCK
   7 #K*B    #SKI K6INSERT   
   4 #KT2    (   
   8 #L#L          LDCT  0  #10  
   9 #LS=          ANDX  0  AWORK1(1)
   9 #M?W          BZE   0  ZGEOER4  
   8 #MRG          LDCT  0  #200 
   9 #N?6          ANDX  0  AWORK1(1)
   9 #NQQ          BZE   0  ZGEOER4  
   4 #P=B    )   
   8 #PQ2          LDX   2  FX2  
   8 #Q9L          BRN      QFOR 
   6 #QP=    NOT2NEWBLOX 
  13 #R8W          BXGE  4  BSBS,ND             [B626
   9 #RNG          LDEX  5  A1+FRH(2)
   8 #S86          BNZ   5  NC   
   4 #SMQ    ND  
  16 #T7B          SBX   4  0                   [SUB LAST R.H.   
   4 #TM2    NC  
   4 #W6L    #   
  13 #WL=    #     WE NOW CONVERT TO CRUDE OVERFLOW. 
   4 #X5W    #   
   9 #XKG    #SKI  K6INSERT>299-299  
  17 #Y56          TRACE  4,CRUDE O             [UNCONVERTED AS YET  
   8 #YJQ          LDX   2  FX2  
   9 #_4B          LDX   0  AWORK3(2)
  20 #_J2          ANDN  0  -1              [SUBTRACT AMT.USED IN INSERT1 BLOCK  
   7 *23L          SBX   4  0
  13 *2H=          ADN   4  A1                  [+A1 
  14 *32W          NGX   4  4                   [INVERT  
  21 *3GG          LDCT  0  #20                 [IF R.I.N.B BIT SET WE DON'T WANT TO 
  21 *426          ANDX  0  AWORK1(2)           [ADJUST OVERFLOW BY SIZE OF NEW RECOR
  21 *4FQ          BZE   0  NRINB4              [ASIT WAS NEVER ADDED TO THE CRUED   
  14 *4_B                                       [OVERFLOW
  15 *5F2          LDXC  0  AWORK1(2)           [J IF INSERT 
   9 *5YL          BCC      YRINB4   
  20 *6D=          ANDN  0  #777                [SUBTRACT SIZE OF RECORD BEING   
  19 *6XW          LDX   7  AWORK3(2)           [REPLACED(I.E OLD RECORD FROM
  14 *7CG          SRL   7  15                  [OVERFLOW
   7 *7X6          SBX   0  7
   7 *8BQ          ADX   4  0
   9 *8WB          BRN      YRINB4   
   5 *9B2    NRINB4  
  21 *9TL          LDEX  0  AWORK1(2)           [ADD IN X1(=0 IF INSERT =SIZE OF REC.
  21 *=*=          ADX   4  0                   [TO BE REPLACED O/W) & ^EXTRA^REQU'D.
   5 *=SW    YRINB4  
   7 *?#G    #SKI  K6INSERT  
  20 *?S6          BXL   4  AWORK4(2),ZGEOER2   [J IF SMALLER THAN LAST OVERFLOW 
  14 *#?Q          STO   4  AWORK4(2)           [STORE.  
   4 *#RB    #   
  21 **?2    #     TRE OVERFLOW HAS BEEN CALCULATED, AND WE     KNOW IF THE RECORD   
  11 **QL    #     GOES IN THE NEXT BLOCK.   
   4 *B==    #   
   5 *BPW    NSHAR   
   8 *C9G          LDX   2  FX2  
   9 *CP6    #SKI  K6INSERT>699-699  
  11 *D8Q          TRACE    AWORK4(2),NSHAR  
   8 *DNB          LDCT  0  #10  
  19 *F82          ANDX  0  AWORK1(2)           [J IF ^EMPTY BLOCK^ BIT SET  
   8 *FML          BNZ   0  QFOR 
  15 *G7=          NAME  3,FI,INSERT4           [RENAME BLOCK
  17 *GLW          SMO      ACOMMUNE5(2)        [SMO BY PTR TO FCA   
  19 *H6G          LDX   4  FREADBLOCK          [PICK UP BLOCK  READING PTR  
   7 *HL6          NGN   5  1
   8 *J5Q          LDCT  0  #40  
   9 *JKB          ANDX  0  AWORK1(2)
  16 *K52          BZE   0  NOTFOR11            [J IF NOT FORWARD
   7 *KJL          LDN   5  1
   5 *L4=    NOTFOR11
  21 *LHW          ADX   4  5                   [ADD +/-1 TO GIVE B.N. OF INSERT3 BL.
  21 *M3G          LDX   5  ACOMMUNE4(2)      [PRESERVE ACOM4 OVER COORDINATING S/R  
  17 *MH6          CALL  7  SCAREFULA           [DO CAREFUL UPDATING 
  17 *N2Q          NAME  2,FI,INSERT3           [FOR INDEX,SILLY IT  
   7 *NGB          LDX   3  2
   8 *P22          LDX   2  FX2  
  10 *PFL          STO   5  ACOMMUNE4(2) 
   4 *P_=    QFOR
   8 *QDW          LDCT  0  #40  
   9 *QYG          ANDX  0  AWORK1(2)
   9 *RD6          BNZ   0  POINTFOR 
   9 *RXQ          GEOERR  1,MARK7   
   5 *SCB    POINTFOR
   4 *SX2    #   
  21 *TBL    #  1) WE HAVE CALCULATED THE OVERFLOW,WHICH ON ENTRY HERE IS FORWARDS.  
  21 *TW=    #     IF WE ARE SHARING 2 PART-FULL BLOX,WE MOVE DOWN THE INSERT3 BLOCK 
  17 *W*W    #     IF B5 OF AWORK1 IS SET,THE INSERT3 BLOCK IS EMPTY.
   4 *WTG    #   
  21 *X*6    #  2) WE THEN CALCULATE A POINTER TO THE FIRST WORD OF THE AREA(IN THE  
  14 *XSQ    #     INSERT1 BLOCK) WHICH WE WISH TO MOVE  
   4 *Y#B    #   
  21 *YS2    #  3) IF THE ^R.I.N.B^ BIT (B4 OF AWORK1) IS SET(THIS MEANS THE INSERTEE
  21 *_?L    #     [OR REPLACEE] GOES INTO THE INSERT3 BLOCK),WE GO TO LABEL ^RINBY^ 
   4 *_R=    #   
  21 B2=W    #  4) O/W WE MOVE ACROSS THE OVERFLOW& RENAME THE INSERT3 BLOCK A FILE/ 
  20 B2QG    #     FUWB.WE THEN MOVE DOWN THE BOTTOM SLIVER OF THE INSERT1 BLOCK,
  20 B3=6    #     MOVE IN THE NEW RECORD,UPDATE FREADWORD(& CMOD IF APPROPRIATE)
  15 B3PQ    #     RENAME THE INSERT1 BLOCK A FUWB & GO UP.  
   4 B49B    #   
  21 B4P2    #  5) AT ^RINBY^ LABEL WE HAVE TO MOVE ACROSS A ^SANDWICH^ OF OVERFLOW, 
  21 B58L    #     CONSISTING OF THE NEW RECORD EMBEDDED IN A MASS OF OLD DATA.EITHER
  17 B5N=    #     THE TOP OR THE BOTTOM OF THE SANDWICH MAY BE NULL.
   4 B67W    #   
  17 B6MG          STO   3  ACOMMUNE2(2)        [STORE PTR TO BLOCK  
  20 B776          ADN   3  A1                  [MOVE DATA DOWN FROM TOP OF BLOCK
   7 B7LQ          LDN   1  0
   8 B86B          LDCT  0  #20  
  17 B8L2          ANDX  0  AWORK1(2)           [J IF ^RINB^ NOT SET 
   9 B95L          BZE   0  NRINBY1  
  16 B9K=          LDX   1  AWORK3(2)       [SIZE OF NEW RECORD. 
   8 B=4W          SRL   1  15   
   5 B=JG    NRINBY1 
  21 B?46          ADX   1  AWORK4(2)           [+AMOUNT BEING DISPLACED INTO INSERT3
  21 B?HQ          STO   1  ACOMMUNE6(2)        [STORE AMOUNT EXTRA TO BE MOVED INTO 
  19 B#3B                                       [INSERT3 BLOCK IN ACOMMUNE6. 
   9 B#H2          LDEX  0  FRH(3)   
  17 B*2L          BNZ   0  YMVDOWN           [J  IF BLOCK NOT EMPTY 
  21 B*G=          SMO      1                   [ZEROISE WORD AFTER AS LAST WORD IN  
  14 B*_W          STOZ     0(3)                [BLOCK   
   9 BBFG          BRN      NMVDOWN  
   5 BB_6    YMVDOWN 
  19 BCDQ          LDX   0  ACOMMUNE4(2)        [EMOUNT USED IN INSERT3 BLOCK
  21 BCYB          CALL  7  MOVEDOWNB           [MOVE INSERT3 BLOCK'S CONTENTS DOWN  
   5 BDD2    NMVDOWN 
  17 BDXL          CALL  1  SFURB               [X2-> INSERT1 BLOCK  
   8 BFC=    #HAL  FI+INSERT1,0  
  13 BFWW          STO   2  6                   [& X6
   8 BGBG          LDX   1  FX2  
  19 BGW6          STO   6  ACOMMUNE4(1)        [STORE PTR TO INSERT1 BLOCK  
   9 BH*Q          LDX   0  AWORK3(1)
  20 BHTB          ANDN  0  -1              [ADD AMOUNT USED IN INSERT1 BLOCK.   
   7 BJ*2          ADX   2  0
  19 BJSL          SBX   2  AWORK4(1)           [SUB AREA TO BE MOVED OUT.   
  21 BK#=    #     X2 CONTAINS AN ABSOLUTE PTR TO THE START OF THE AREA TO BE MOVED  
  11 BKRW    #     INTO  THE INSERT3 BLOCK   
  21 BL?G          LDCT  0  #20                 [J IF ^RECORD IN NEXT BLOCK BIT^ SET 
   9 BLR6          ANDX  0  AWORK1(1)
   8 BM=Q          BNZ   0  RINBY
  21 BMQB    #     THE INSERTEE/REPLACEE REMAINS IN THE INSERT1 BLOCK IN THIS PATH   
  17 BN=2          SMO      AWORK4(1)           [MOVE OVERFLOW ACROSS
  17 BNPL          MOVE  2  0                   [TO THE INSERT3 BLOCK
  21 BP9=          LDX   3  6                   [WE'VE FINISHED WITH THE INSERT3 BLK.
  14 BPNW          LDX   2  ACOMMUNE5(1)        [-> FCA  
  21 BQ8G          ADX   3  FREADWORD(2)        [X3 -> POSITION INTO WHICH WE WISH TO
  15 BQN6          LDX   0  AWORK3(1)       [MOVE NEW RECORD 
   8 BR7Q          ANDN  0  -1   
  21 BRMB          SBX   0  FREADWORD(2)        [X0 CONTAINS THE AREA AFTER THE POS- 
  21 BS72          SBX   0  AWORK4(1)           [ITION OF THIS RECORD,THAT HAS TO BE 
  21 BSLL          BNZ   0  YMOVD               [MOVED DOWN THE BLOCK.J IF NON-ZERO  
   9 BT6=          LDX   0  AWORK3(1)
  16 BTKW          SRL   0  15              [SIZE OF NEW RECORD  
   7 BW5G          SMO      0
  20 BWK6          STOZ     0(3)                [ZEROISE NEW LAST WORD IN BLOCK. 
   9 BX4Q          BRN      NOMOVD   
   5 BXJB    YMOVD   
  20 BY42          LDEX  1  AWORK1(1)           [DISTANCE TO BE MOVED DOWN BLOCK.
  17 BYHL          CALL  7  MOVEDOWNB           [DO THE TRICKY STUFF.
   5 B_3=    NOMOVD  
  16 B_GW          MHUNTW  2,FILE,FWB           [FIND NEW RECORD 
   8 C22G          ADN   2  A1   
   8 C2G6          SMO      0(2) 
  15 C2_Q          MOVE  2  0                   [MOVE IT IN. 
   8 C3FB          LDX   1  FX2  
   9 C3_2          LDX   0  AWORK1(1)
  15 C4DL          BNG   0  YREP3               [J IF REPLACE
   8 C4Y=          LDEX  0  0(2) 
  10 C5CW          SMO      ACOMMUNE5(1) 
  16 C5XG          ADS   0  FREADWORD           [UPDATE FREADWORD
   5 C6C6    YREP3   
   8 C6WQ          NGN   7  A1-2 
   6 C7BB    UPDATCMOD   
  14 C7W2          LDX   2  ACOMMUNE5(1)        [-> FCA  
   7 C8*L          PSTAC 3,2 
  14 C8T=          BFCBX 3,3                    [-> FCB  
  10 C9#W          ADX   7  FREADBLOCK(2)
  20 C9SG          SBX   7  FBLMOD(3)           [IS INSERT3 BLOCK LAST BLOCK ?   
  14 C=#6          BNZ   7  NOCHCMOD            [J IF NOT
   9 C=RQ          LDX   0  CMOD(3)  
   9 C??B          BNG   0  NOCHCMOD 
  21 C?R2          LDCT  7  #14                 [J IF ^EMPTY BLOCK^ BITS NOT SET FOR 
  21 C#=L          ANDX  7  AWORK1(1)           [J IF ^EMPTY BLOCK^BITS NOT SET FOR  
  18 C#Q=                                       [WE CAN CALCULATE CMOD   
  15 C*9W          BZE   7  NONEGCM             [SET,WE CAN'T
   9 C*PG          NGS   7  CMOD(3)  
   9 CB96          BRN      NOCHCMOD 
   5 CBNQ    NONEGCM 
  20 CC8B          LDX   0  ACOMMUNE6(1)        [EXTRA PUT INTO INSERT3 BLOCK.   
  15 CCN2          ADS   0  CMOD(3)             [UPDATE CMOD 
   5 CD7L    NOCHCMOD
  21 CDM=          NGS   3  CMOD(3)             [WE WILL RECALCULATE CMOD CORRECTLY O
  21 CF6W                                       [CURRENTLY THERE IS A PATH THAT GOES 
  15 CFLG          SETREP   OK                  [DEFAULT OK  
   9 CG66          LDX   0  FBLMOD(3)
  12 CGKQ          SBN   0  GSBS-1-FNEARLY-FBLKS 
  17 CH5B          BNG   0  NOTFN2              [CHECK FOR FNEARLY   
   8 CHK2    #SKI  K6INSERT>99-99
  11 CJ4L          TRACE    FBLMOD(3),FNEARLY
   9 CJJ=          SETREP   FNEARLY  
   5 CK3W    NOTFN2  
   8 CKHG          LDN   0  #77  
   9 CL36          ANDX  0  FINFC(3) 
  18 CLGQ          BZE   0  RENAMEW             [J IF NOT INDEXED FILE   
   9 CM2B          ACROSS   INDEX,2  
   5 CMG2    RENAMEW 
  10 CM_L          LDX   2  ACOMMUNE2(1) 
   9 CNF=          NAME  2 ,FILE,FUWB
  17 CNYW          LDX   1  ACOMMUNE4(1)        [PTR TO INSERT1 BLOCK
  18 CPDG          NAME  1,FILE,FUWB            [RENAME FOR CORE UNJAMMER
   5 CPY6          UP
   4 CQCQ    #   
  20 CQXB    #     HERE  WE HAVE TO MOVE THE ^SANDWICH^ INTO THE INSERT3 BLOCK.  
   4 CRC2    #   
  21 CRWL    #     ON ENTRY HERE X2 -> CONTAINS AN ABS. PTR. TO THE START OF THE AREA
  13 CSB=    #     TO BE MOVED INTO THE INSERT3 BLOCK
  21 CSTW    #     X1 = FX2, X6 -> INSERT1 BLOCK,X3 ->START OF DATA IN INSERT3 BLOCK.
   4 CT*G    #   
   5 CTT6    RINBY   
  20 CW#Q          LDXC  0  AWORK1(1)           [X2 IS WHAT WE WANT FOR INSERT   
  17 CWSB          BCC      NREP18              [BUT NOT FOR REPLACE 
  18 CX#2          ANDN  0  #777                [FOR REPLACE WE SUBTRACT 
  19 CXRL          LDX   7  AWORK3(1)           [THE SIZE OF THE OLD RECORD  
  17 CY?=          SRL   7  15                  [FROM THE X2 POINTER 
   7 CYQW          SBX   0  7
   7 C_=G          ADX   2  0
   5 C_Q6    NREP18  
  21 D29Q          LDX   0  2                   [CALCULATE VOLUME UN-TOUCHED BY MOVE 
  21 D2PB          SBX   0  6                   [FROM INSERT1 BLOCK(+A1) & STORE IN  
  15 D392          STO   0  ACOMMUNE3(1)        [ACOMMUNE3.  
  14 D3NL          SMO      ACOMMUNE5(1)        [-> FCA  
  20 D48=          SBX   0  FREADWORD           [GIVES SIZE OF TOP OF ^SANDWICH^ 
  14 D4MW          NGX   0  0                   [INVERTED
   9 D57G    #SKI  K6INSERT>199-199  
   9 D5M6          TRACE  0,TOPSWICH 
  15 D66Q          BZE   0  NOTOPSWCH           [J IF NULL   
   7 D6LB    #SKI  K6INSERT  
   9 D762          BNG   0  ZGEOER12 
   7 D7KL          SMO      0
  19 D85=          MOVE  2  0                   [MOVE ACROSS TOP OF S'WICH   
   7 D8JW          ADX   2  0
  18 D94G          ADX   3  0                   [UPDATE TO & FROM PTRS   
   6 D9J6    NOTOPSWCH   
  20 D=3Q          SMO      ACOMMUNE5(1)        [PRESERVE FREADWORD (INVERTED)   
   9 D=HB          NGX   5  FREADWORD
   9 D?32          LDX   7  AWORK1(1)
  15 D?GL          BPZ   7  NSETRP              [J IF INSERT 
   8 D#2=          ADN   0  A1   
  10 D#FW          SMO      ACOMMUNE5(1) 
  19 D#_G          STO   0  FREADWORD           [RECORD PTR @ REPLACED RECORD
   7 D*F6          LDN   0  1
  19 D*YQ          SMO      ACOMMUNE5(1)        [BLOCK PTR @ INSERT3 BLOCK   
  10 DBDB          ADS   0  FREADBLOCK   
   5 DBY2    NSETRP  
  13 DCCL          LDX   4  2                   [SAVE
   9 DCX=          MHUNTW  2,FILE,FWB
   8 DDBW          ADN   2  A1   
   8 DDWG          SMO      0(2) 
  17 DFB6          MOVE  2  0                   [MOVE IN NEW RECORD. 
  16 DFTQ          ADX   3  0(2)                [UPDATE ^TO^ PTR.
   9 DG*B          LDX   0  AWORK3(1)
   8 DGT2          ANDN  0  -1   
  20 DH#L          ADX   5  0               [-FREADWORD+AMOUNT USED IN INSERT1   
  20 DHS=                                       [BLOCK= BOTTOM HALF OF SANDWICH  
  16 DJ?W          LDX   2  4                   [PICK UP PTR TO  
  21 DJRG          LDX   7  AWORK1(1)           [IF REPLACE,HAVE TO OMIT REPLACEE,   
  21 DK?6          BPZ   7  NOSUBREC            [SO WE SUB. FROM AMOUNT MOVED & ADD  
  21 DKQQ          SBX   5  0(2)                [TO ^FROM PTR,THE SIZE OF THE REPLACE
   9 DL=B    #SKI  K6INSERT>599-599  
  10 DLQ2          TRACE 0(2),SIZE REP   
  16 DM9L          ADX   2  0(2)                [ADD TO^FROM^PTR.
   5 DMP=    NOSUBREC
   9 DN8W    #SKI  K6INSERT>199-199  
   9 DNNG          TRACE    5,BOTSWCH
   9 DP86          BZE   5  NBOTSWCH 
   7 DPMQ    #SKI  K6INSERT  
   9 DQ7B          BNG   5  ZGEOER13 
  17 DQM2          SMO      5                   [O/W MOVE IT ACROSS. 
   7 DR6L          MOVE  2  0
   5 DRL=    NBOTSWCH
  17 DS5W          LDCT  0  #14                 [J IF NOT NEW BLOCK  
   9 DSKG          ANDX  0  AWORK1(1)
   9 DT56          BZE   0  NOSTOZ   
  20 DTJQ          SMO      5                   [O/W ZEROISE LAST WORD IN BLOCK  
   8 DW4B          STOZ     0(3) 
   5 DWJ2    NOSTOZ  
  21 DX3L          LDX   2  6                   [ZEROISE WORD AT TOP OF TOP HALF OF  
  21 DXH=          SMO      ACOMMUNE3(1)        [SANDWICH-NOW LAST WORD IN INSERT1   
  14 DY2W          STOZ     0(2)                [BLOCK.  
   9 DYGG          LDX   0  AWORK1(1)
  15 D_26          BNG   0  NOSETRP             [J IF REPLACE
  15 D_FQ          SBX   3  ACOMMUNE2(1)        [-> INSERT3  
  17 D__B          SMO      ACOMMUNE5(1)        [SET INSERT PTRS NOW!
  20 F2F2          STO   3  FREADWORD           [READ RECORD PTR. @ RECORD AFTER 
  15 F2YL          LDN   0  1                   [INSERTEE.   
  20 F3D=          SMO      ACOMMUNE5(1)        [BLOCK PTR @ NEXT BLOCK(INSERT3) 
  12 F3XW          ADS   0  FREADBLOCK          [
   5 F4CG    NOSETRP 
   8 F4X6          NGN   7  A1-1 
   9 F5BQ          BRN      UPDATCMOD
   4 F5WB    #   
  11 F6B2    #     EXIT  IF OVERFLOW > GSBS !
   4 F6TL    #   
   6 F7*=    TWONEWBLOX5 
   9 F7SW          LDEX  5  AWORK1(1)
   7 F8#G          ADX   5  0
  10 F8S6          BXL   5  BSBS,NSHAR   
   6 F9?Q    TWONEWBLOX4 
  21 F9RB          LDCT  0  #14                 [IF ISERT3 BLOCK NOT A FUWB,FREE IT  
  19 F=?2          ANDX  0  AWORK1(1)           [UNLESS OW BLOCK BIT(2) SET  
  10 F=QL          BNZ   0  TWONEWBLOX   
   6 F?==    TWONEWBLOX3 
   7 F?PW          LDCT  0  2
   9 F#9G          ANDX  0  AWORK1(1)
   9 F#P6          BNZ   0  SNAME4   
  15 F*8Q          FREECORE 3                   [FREE EX-FURB
  10 F*NB          BRN      TWONEWBLOX   
   5 FB82    SNAME4  
  20 FBML          NAME 3,FILE,FUWB             [RENAME SO IT GETS BACKWRITTEN   
   6 FC7=    TWONEWBLOX  
  10 FCLW          ACROSS   INSERTFR,1   
   4 FD6G    #   
  20 FDL6    #     EXIT  WHEN WE HAVE CURRENT BLOCK + CONTIGUOUS BLOCK,+ OVERFLOW
  17 FF5Q    #     WHICH WON'T FIT. WE HAVE TO SMOOTH THESE THREE.   
   4 FFKB    #   
   5 FG52    WONTFIT 
   9 FGJL    #SKI  K6INSERT>199$199  
   9 FH4=          TRACE    7,WONTFIT
  10 FHHW          BXL   4  BSBS,TLESS   
   8 FJ3G          LDX   1  FX2  
  10 FJH6          BRN      TWONEWBLOX3  
   5 FK2Q    TLESS   
  21 FKGB          SMO      FX1                 [J IF SPARE SPACE IN INSERT3 BLOCK IS
  16 FL22          BXL   7  PERCENT,THREE       [LESS THAN 30%.  
  21 FLFL    #     THERE ISN'T MUCH POINT IN TRYING TO SMOOTH 3 BLOCKS IN THIS CASE, 
  16 FL_=    #     AS THE THIRD IS ALREADY IN A PERFECT STATE.   
   8 FMDW          LDCT  0  #2   
   8 FMYG          SMO      FX2  
  21 FND6          ANDX  0  AWORK1              [IF BLOCK WAS ORIGINALLY A FUWB,DON'T
  15 FNXQ          BNZ   0  SNAME               [FREECORE IT 
  17 FPCB          FREECORE 3                   [RID OF INSERT3 BLOCK
   9 FPX2          BRN      XLESS1   
   5 FQBL    SNAME   
  21 FQW=          NAME  3,FILE,FUWB            [RENAME BLOCK,SO THAT IT EVENTUALLY  
  17 FR*W          BRN      XLESS1              [GETS BACKWRITTEN.   
   5 FRTG    THREE   
   8 FS*6          LDX   2  FX2  
  19 FSSQ          LDX   0  ACOMMUNE4(2)        [STORE AMT.USED IN INSERT3   
   8 FT#B          ADN   0  A1   
  16 FTS2          STO   0  AWORK4(2)           [FOR INSERTHR CH.
  10 FW?L          ACROSS   INSERTHR,1   
   4 FWR=    #   
   4 FX=W    #   
   4 FXQG    #   
  12 FY=6    #     INFORMATION HELD IN REGISTERS 
   6 FYPQ    # ON ENTRY:-
  18 F_9B    #     AWORK3    = AMOUNT OF SPACE USED IN INSERT1 BLOCK +A1 
   4 F_P2    #   
   5 G28L    XLESS   
   9 G2N=    #SKI  K6INSERT>199$199  
   8 G37W          TRACE  4,XLESS
  10 G3MG          SMO      ACOMMUNE5(2) 
  10 G476          SBS   5  FREADBLOCK   
   8 G4LQ          LDCT  0  #14  
   8 G56B          SMO      FX2  
   9 G5L2          ANDX  0  AWORK1   
  18 G65L          BNZ   0  YEMPTYB         [J IF^EMPTY BLOCK^ BITS SET  
   5 G6K=    XLESS1  
  21 G74W          SETNCORE GSBS,1,FI,INSERT3   [SETUP FI/INSERT3 BL.FOR^SINSERT^ S/R
  18 G7JG          STOZ     A1+FRH(1)           [S/R & ZEROISE 1ST R.H.  
  17 G846          LDCT  0  #30                 [SET^EMPTY BLOCK^BIT 
   9 G8HQ          ORS   0  AWORK1(2)
  18 G93B          LDCT  0  #20                 [& UNSET ^R.I.N.B^ BIT   
   9 G9H2          ERS   0  AWORK1(2)
  15 G=2L          CALL  6  SFCA2               [X2 -> FCA   
  10 G=G=          LDX   4  FREADBLOCK(2)
  16 G=_W          BNG   5  NOADD1              [J IF 'BACKWARD' 
  21 G?FG          ADN   4  1                   [X4 NOW POINTS TO THE BLOCK NUMBER   
  20 G?_6    NOADD1                             [BEFORE WHICH WE WISH TO INSERT A
   7 G#DQ          PSTAC 2,2 
  15 G#YB          CHAIN 1,2            [CHAIN NEW BLOCK IN  
  15 G*D2          CALL  7  SINSERT1            [NEW BLOCK.  
  15 G*XL          LDX   3  2                   [SERT3 BLOCK)
  14 GBC=          CALL  6  SFCA2               [-> FCA  
  17 GBWW          LDX   6  FREADWORD(2)        [LOAD OEAD WD. PTR   
   8 GCBG          LDX   1  FX2  
   7 GCW6          LDN   7  0
  19 GD*Q          STO   7  ACOMMUNE4(1)        [AMT. ^USED^ IN INSERT3 BLOCK
   9 GDTB          BRN   SHAR2BLOX   
   4 GF*2    #   
   5 GFSL    SFULL   
  10 GG#=          ACROSS   INSERTFR,2   
   4 GGRW    #   
   4 GH?G    [   
  14 GHR6          MENDAREA K6INSERT/5<100>30,K99INSERTWO
   4 GJ=Q    #END
   8 ____ ...77104235000400000000
