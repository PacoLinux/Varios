/* *  codeLine.java  Stores a line of code for VPTeX.  VIPER Team *  Copyright (C) 2002 VIPER Team * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation; either version 2 of the License, or *  (at your option) any later version. * *  This program is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. * *  You should have received a copy of the GNU General Public License *  along with this program; if not, write to the Free Software *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. * *  @author Stephen Hughes */package VPTeX;import java.util.*;/** Class which stores the details of any line of code contained in the document */public class CodeLine extends Line{    /** The text from the margin comment of this line */     protected String  Marge;    /** The variables which appear in this line */     protected Vector  variableList;     /** Whether math conversion has been performed on this line */    protected boolean Math;	/** Wheter the line is a simple statment or declaration */	protected int lineType=0;	    /** Default constructor for codeLine */    public CodeLine(){	    super();	    this.Marge= "";	    this.variableList= new Vector(0, 2);	    this.Math= false;    }    /** Constructor for codeLine, setting the content and line number from the super class, and Marge     * @param s  The Pascal contents of the codeline     * @param n  The line number in the source code     * @param s2 The margin comment for this CodeLine      */    public CodeLine(String s, int n, String s2, int type, boolean sel){	    super(s, n, sel); // Set the content and line number	    this.Marge= s2; // Set the value of the margin comments	    this.variableList= new Vector(0, 2); // Initialise and empty vector to store the variables	    this.Math= false; // Set Math to default false value		this.lineType=type;    }    /** Public method to add a variable to the variable list      *  @param v The variable found in the line to be added t the variable list       */    public void addVariable(Variable v){	    variableList.addElement(v);    }    /** Public method to return the variables referenced in this codeLine      * @return The list of variables in this line     */    public Vector getVariables(){	return this.variableList;    }    /** Public method to state that mathematical transformation has     *	been completed on this codeLine      */    public void setMath(){	    this.Math= true;    }	/** Returns the type of the line 0 being simple statment 1 being varible declaration	 * 2 being constant declaration and 3 being type declaration	 */	public int getLineType() {		return this.lineType;		}		    /** Return the content of the string and the margin comment as a LaTeX command      *  @return The string representation of the CodeLine	 */	public String toString(){			if(this.Math){				return this.content+"" ;			}			else				return ("\\textsf{" + emphasisedLine(this.content) + "}");			}// toString()    /** Method to return a String for the CodeLine with keyowrds emboldened      *  and variables emphasised     *  @return The LaTeX code for the emphasised CodeLine as a String     */	protected String emphasisedLine(String s){		Keywords keywords= new Keywords();		// The LaTeX code for the emphasised CodeLine. To be returned		String line= "";		// Boolean to check if current position is inside a String		boolean inString= false;		// Get the Vector of tokens for the CodeLine		Vector tokens= tokenizeLine(s);		// Loop through the Vector, emphasising the tokens		int noTokens= tokens.size();		for(int j= 0; j<noTokens; j++){			// Get the next token from the Vector			String currToken= (String)(tokens.elementAt(j));			// If the currToken is a keyword			if((keywords.contents).contains(currToken.toUpperCase()) && !inString){				// Add the LaTeX commands to embolden the token				currToken= ("\\textbf{" + formatString(currToken.toLowerCase()) + "} ");			}						else if (currToken.length()>0){				// If we get the start of a String				if(currToken.charAt(0)=='\'' && !inString){					// Make the String upright text					inString= true;					currToken= ("\\textrm{\\textup { " + '`' + formatString(currToken.substring(1,currToken.length())));				}				// If we get the end of a String				else if(currToken.charAt(0)=='\'' && inString){					// End the upright text command					inString= false;					currToken= ("\' } }" + currToken.substring(1,currToken.length()));				}				// If the currToken is a variable identifier				else if(!((keywords.contents).contains(currToken.toUpperCase())) && isValidIdentifier(currToken) && !inString){					// Add the LaTeX commands to emphasise the token					currToken= ("\\textit{" + formatString(currToken) + "} ");				}								//      if (!(keywords.contents).contains(currToken.toUpperCase()) && (!((keywords.contents).contains(currToken.toUpperCase())) && 				//		       isValidIdentifier(currToken)) && !inString)				else {					//System.out.print(" "+currToken);					currToken= formatString(currToken);				}				// Add the currToken to the String of the line							}			line+= currToken;		}		// Return the processed line		return (line);        }// emphasisedLine()    /** Private method to split the code line up into tokens.  Used to separate a line     *  prior to embolding keywords and emphasising variables.     *  @return A Vector of the tokens in this line     */    private Vector tokenizeLine(String s){	// Initialise the Vector of tokens	Vector tokens= new Vector();	// Integer used to mark the start of a token	int    startTokenMarker= 0;	if (s.length()==1) {			tokens.addElement(s);			return tokens;	}	else {	// Loop through the content String of the CodeLine 	for(int i=0; i<s.length(); i++){	    char c= s.charAt(i);	    // If we are not at the start of the line	    if(i>0){		if(c== ' ' || c== '(' || c== ')' || c== ',' || c== ';' || c== ':' || c== '[' || c== ']' ||		   c== '+' || c== '-' || c== '/' || c== '*' || c== '<' || c== '>' || c== '=' || c== '\\'||		   c== '.' || c== '\'' || c=='\n' || c=='\t'|| c== '@' || c== '^'){   		    // Add the latest token		    tokens.addElement(content.substring(startTokenMarker, i));		 /*   if (c== '<' || c== '>')			// Add the separator to the list of tokens			tokens.addElement("$ \\mathrm{" + content.substring(i, i+1) + " } $");		    else*/			tokens.addElement(content.substring(i, i+1));		    // Update the startTokenMarker		    startTokenMarker= i+1;		}		else if ( i==content.length()-1){					tokens.addElement(content.substring(startTokenMarker, i+1));		}	    }	    else{		// If the first entry in the line is a separator		if(c== ' ' || c== '(' || c== ')' || c== ',' || c== ';' || c== ':' || c== '[' || c== ']' ||		   c== '+' || c== '-' || c== '/' || c== '*' || c== '<' || c== '>' || c== '=' || c== '\\' ||		   c== '.' || c== '\'' || c=='\n'|| c=='\t'|| c== '@' || c== '^'){		    // Add the separator to the token list		    tokens.addElement(content.substring(i,i+1));		    // Update the startTokenMarker		    startTokenMarker= i+1;		}	    }	}	}	return tokens;	    }// tokenizeLine()    /** Private method which checks to see if a String     *  is a valid Pascal identifier     *  @param ident The identifier which is to be checked     *  @return A boolean stating whether ident is a valid identifier     */    protected static boolean isValidIdentifier(String ident){	char c= ident.charAt(0);	// A valid identifier should start with an underscore or a 	// normal alphabetic character.	return (c==95 || c==94 || c==40 || (c>=65 && c<91) || (c>96 && c<123));    }// isValidIdentifier	    public boolean hasMarge() {	for (int i=0;i<Marge.length();i++) {	    if(Marge.charAt(i)!=' ' || Marge.charAt(i)!='\t') {		return true;		    }	}	return false;    }        public String getMarge() {		return (Marge);    }		    }// Codeline