<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 2.78">
                                                                                           

 
<title>   Vector Pascal, an array language</title>
 
<h1 align="center">  Vector Pascal, an array language </h1>

<p>

<h3 align=center>Paul Cockshott, University of Glasgow, Imaging Faraday
Partnership<br />Greg Michaelson, Heriot Watt University </h3>

<p>

<h2> Abstract</h2>
<font size="-1">Vector Pascal is a language designed to support elegant and efficient expression
of algorithms using the SIMD model of computation. It imports into Pascal abstraction mechanisms
derived from  functional languages having their origins in APL. In particular it extends
 all operators to work on vectors of data. The type system is extended to
handle pixels and dimensional analysis. Code generation is via the ILCG system that allows
retargeting to multiple different SIMD instruction sets based on formal descrition
of the instruction set semantics.
</font>

<p>
       <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Introduction</h2>

<p>
The introduction of SIMD instruction sets[<a href="#IA32 " name="CITEIA32 ">13</a>][<a href="#AMD" name="CITEAMD">1</a>][<a href="#Peleg97" name="CITEPeleg97">25</a>][<a href="#Intel00" name="CITEIntel00">14</a>]
to Personal Computers potentially provides substantial performance increases,
but the ability of most programmers to harness this performance is held back
by two factors. The first is the limited availability of compilers that make
effective use of these instruction sets in a machine independent manner. This
remains the case despite the research efforts to develop compilers for multi-media
instruction sets[<a href="#Cheong97" name="CITECheong97">7</a>][<a href="#Leupers99" name="CITELeupers99">23</a>][<a href="#Krall00" name="CITEKrall00">21</a>][<a href="#Sreraman00" name="CITESreraman00">28</a>].
The second is the fact that most popular programming languages were designed
on the word at a time model of the classic von Neuman computer rather than
the SIMD model.  

<p>
Vector Pascal aims to provide an efficient and elegant notation for programmers
using Multi-Media enhanced CPUs. In doing so it borrows concepts for expressing
data parallelism that have a long history, dating back to Iverson's work on
APL in the early '60s[<a href="#Iverson62" name="CITEIverson62">16</a>]. 
We are using the word elegant in the technical sense
introduced by Chaiten[<a href="#Chaiten" name="CITEChaiten">6</a>]. By an elegant algorithm we mean one which is expressed as concisely as possible.
Elegance is a goal that one approaches asymtotically, approaching but never
attaining. APL and J[<a href="#Jintro" name="CITEJintro">19</a>] allow the construction of very elegant programs,
but at a cost. An inevitable consequence of elegance is the loss of redundancy.
APL programs are as concise, or even more concise than conventional mathematical
notation[<a href="#Iversion80" name="CITEIversion80">17</a>] and use a special characterset. This makes them hard
for the uninitiated to understand. J attempts to remedy this by restricting
itself to the ASCII characterset, but still looks dauntingly unfamiliar to programmers
brought up on more conventional languages. 
The aim of Vector Pascal is to provide the conceptual gains of Iverson's notation
within a framework familiar to imperative programmers.

<p>
Pascal[<a href="#Wirth" name="CITEWirth">20</a>]was chosen as a base language over the alternatives of C
and Java. C was rejected because notations like <tt>x+y</tt> for <tt>x</tt>
and <tt>y</tt> declared as arithmetic operations are already overloaded for
address operations in a way which precludes their use in map operations. 

<p>
        <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Array mechanisms for data parallelism</h2>
Vector Pascal extends the array type mechanism of Pascal  to
provide better support for data parallel programming in general,
and SIMD image processing in particular.
Data parallel programming can be built up from certain underlying
abstractions[<a href="#Ewing" name="CITEEwing">9</a>]:

<ul><p>
<li> operations on whole arrays</li>
<p>
<li> array slicing</li>
<p>
<li> conditional operations</li>
<p>
<li> reduction operations
</li>
<p>
<li> data reorganisation</li>
</ul>
We will first consider these in general before moving on to
look at their support in other languages, 
in particular J, Fortran 90[<a href="#Ewing" name="CITEEwing">9</a>] and  Nesl[<a href="#blelloch" name="CITEblelloch">3</a>] then finally looking
at how they are supported in Vector Pascal.

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Operations on whole arrays</h3>
The basic <em>conceptual</em> mechanism is the <em>map</em>, which takes an operator and
and a source array ( or pair of arrays ) and produces a result array by mapping the
source(s) under the operator. Let us denote the type of an arry of 
 T as   T[] . Then if we have a binary operator  <font face="symbol">w</font
>:(T<font face="symbol">Ä</font
>T)<font face="symbol">®</font
> T ,
 we automatically have an operator  <font face="symbol">w</font
>:(T[]<font face="symbol">Ä</font
>T[])<font face="symbol">®</font
> T[] 
 . Thus if  x,y  are arrays of integers  k = x+y  is the array
of integers where  k<sub>i</sub> = x<sub>i</sub>+y<sub>i</sub> : 

<p>

<table border="1">
<tr><td align="center">3</td><td align="center">5</td><td align="center">9</td></tr></table>
 =

<table border="1">
<tr><td align="center">2</td><td align="center">3</td><td align="center">5</td></tr></table>
 +

<table border="1">
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td></tr></table>
 

<p>
Similarly if we have a unary operator <font face="symbol">m</font
>:( T<font face="symbol">®</font
>T)
then we automatically have an operator <font face="symbol">m</font
>:(T[]<font face="symbol">®</font
>T[]). Thus z = sqr(x) is the array
where z<sub>i</sub> = x<sub>i</sub><sup>2</sup>:

<p>

<table border="1">
<tr><td align="center">4</td><td align="center">9</td><td align="center">25</td></tr></table>
 = sqr(

<table border="1">
<tr><td align="center">2</td><td align="center">3</td><td align="center">5</td></tr></table>
)

<p>
The map replaces the <em>serialisation</em> or <em>for loop</em> abstraction of classical imperative languages. 
The map concept is simple, and maps over lists are widely used in functional programming. 
For array based languages there are complications to do with the semantics
of operations between arrays of different lengths and different dimensions,
but Iverson[<a href="#Iverson62" name="CITEIverson62">16</a>] provided a consistent treatment of these. Recent languages
  built round this model are J, an interpretive language[<a href="#Jmanual" name="CITEJmanual">18</a>][<a href="#Burke" name="CITEBurke">4</a>][<a href="#Jintro" name="CITEJintro">19</a>],
High Performance Fortran[<a href="#Ewing" name="CITEEwing">9</a>], F[<a href="#Metcalf96" name="CITEMetcalf96">24</a>] a modern Fortran subset,  Nesl
an applicative data parallel language. In principle though any language
with array types can be extended in a similar way. The map approach to data
parallelism is machine independent. 
 Depending on the target machine, a compiler can output
sequential, SIMD, or MIMD code to handle it.

<p>
Recent implementations of Fortran, such as Fortran 90, F, and High Performance Fortran provide 
direct support for whole array operations. Given that <tt>A,B</tt> are arrays with the same rank
and same extents, the statements:
<pre>
REAL,DIMENSION(64)::A,B
A=3.0
B=B+SQRT(A)*0.5;

</pre>
would be legal, and would operate in a pointwise fashion on the whole arrays.
Intrinsic functions such as SQRT are defined to operate either on scalars or arrays, but
intrinsic functions are part of the language rather than part of a subroutine library.
User defined functions over scalara do not automatically extend to array arguments.

<p>
J<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> similarly allows direct implementation of array operations, though here the
array dimensions are deduced at run time:

<pre>
 a=. 1 2 3 5
   a
1 2 3 5
   b=. 1 2 4 8
   a+b
2 4 7 13

</pre>
The pair    is the assignment operator in J.
Unlike Fortran, J automatically overloads user defined funtions  over arrays.
In what follows <tt>^&amp;2</tt> is an expression binding the dyadic power function to
the contant 2, <tt>sqr</tt>
a user defined monadic operator.

<pre>
 sqr=.^&amp;2
   b=.1 2 4 8
   b+(sqr a)*0.5
1.5 4 8.5 20.5

</pre>

<p>
 Nesl provides similar generality;
the first J example above could be expressed as:

<pre>
      {a+b: a in [1,2,3,5]; b in [1,2,4,8]};
=&#62; [2, 4, 7, 13] : [int]

</pre>
and the second example as:

<pre>
      {b+ sqr(a)*0.5: a in [1,2,3,5]; b in [1,2,4,8]};
=&#62; [1.5, 4, 8.5, 20.5] : [float]

</pre>
Again user defined functions can be applied element wise, 
to arrays ( or sequences as they are called in the language).
The expressions in { } brackets  termed the Apply-to-Each construct,
are descended from the ZF notations used in SETL[<a href="#setl" name="CITEsetl">27</a>] and MIRANDA[<a href="#miranda" name="CITEmiranda">30</a>].

<p>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp; Array slicing</h3>
It is advantageous to be able to specify sections of arrays as values in expression.
The sections may be rows or columns in a matrix, a rectangular sub-range of the elements
of an array, as shown in figure <a href="#figslice">1</a>.
In image processing such rectangular sub regions of pixel arrays are called regions of interest. 
It may also be desirable to provide matrix diagonals[<a href="#vanderMeulen" name="CITEvanderMeulen">31</a>].

<p>

<p>
<a name="tth_fIg1">
</a> 
<table border="1"><tr><td>
<tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">16</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">8</td><td align="center">512</td></tr><tr><td></table>
&nbsp;&nbsp;

<table border="1"><tr><td>
<tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">16</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">8</td><td align="center">512</td></tr><tr><td></table>
&nbsp;&nbsp;

<table border="1"><tr><td>
<tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">1</td><td colspan="2" align="center">2 4</td><td>8</td></tr>
<tr><td align="center">1</td><td colspan="2" align="center">2 4</td><td>16</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">8</td><td align="center">512</td></tr><tr><td></table>

 
<p>
<center>Figure 1: Different ways of slicing the same array</center><a name="figslice">
</a>

<p>

<p>
The notion of array slicing was introduced to imperative languages by  Algol 68[<a href="#Tanenbaum" name="CITETanenbaum">29</a>].
In  Algol 68 if x has been declared as [1:10]INT x, then x[2:6] would be a slice
that could be used assignment or as an actual parameter.

<p>
Fortran 90 extends this notion to allow what it calls triplet subscripts, giving the start position
end position and step at which elements are to be taken from arrays.

<pre>
REAL,DIMENSION(10,10)::A,B
A(2:9,1:8:2)=B(3:10,2:9:2)

</pre>
would be equivalent to the loop nest:

<pre>

  DO 1,J=1,8,2
   DO 2, J=2,9
	     A(I,J)=b(I+1,J+1)
2  CONTINUE
1 CONTINUE

</pre>
J allows a similar operation to select subsequences.
In what follows <tt>i.</tt> n is a function which produces a list of the first n starting with 0,
and <tt>{</tt> is the sequence subscription operator.

<pre>
   a=. 2*i.10
   a
0 2 4 6 8 10 12 14 16 18
   3{a
6

</pre>
Selection of a subsequence is performed by forming a sequence of indices. Thus to
select the 3 consecutive elements starting with the second, we first form
the sequence <tt>2 3 4</tt> using the expression <tt>2+i.3</tt> and use this to
subscript the array <tt>a</tt>:

<pre>  
   (2+i.3){a
4 6 8
   
</pre>
 
<p>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp; Conditional operations</h3>
For data parallel programming one frequently wants to make an operation
work on some subset of the data based on some logical mask. This can be thought of providing
a finer grain of selection than subslicing, allowing arbitrary combinations of
array elements to be acted on.
For example one might want to replace all elements of an array A less than
the corresponding element in array B with the corresponding element of B.

<p>

<table border="1">
<tr><td>1</td><td>2</td><td>4</td><td>8</td><td align="center">A</td></tr>
<tr><td>2</td><td>3</td><td>4</td><td>5</td><td align="center">B</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td align="center">A &lt; B</td></tr>
<tr><td>2</td><td>3</td><td>4</td><td>8</td><td align="center"></td></tr></table>


<p>
Fortran 90 provides a mechanism to selectively update a section of an array under
a logical mask, the <tt>WHERE</tt> statement.
 
<pre>
REAL, DIMENSION(64)::A
REAL, DIMENSION(64)::B
WHERE (A&#62;B)
  A=A
ELSE WHERE
  A= B
END WHERE

</pre>
 <a name="where">
</a>
 The <tt>WHERE</tt> statement is analogous to   Algol 68 and <tt>C</tt> conditional expressions, but extended
to operate on arrays.
It can be performed in parallel on all elements of an array and lends itself to evaluation under
a mask on SIMD architectures.

<p>
 Nesl provides a generalised form of Apply-to-Each in which a sieve can be
applied to the arguments as in:

<pre>
    { a+b : a in[ 1,2,3]; b in [4,3,2] |a&lt;b}
=&#62;  [5,5] : [int]

</pre>
Notice that in  Nesl as in J values are allocated dynamically from a heap
so that the length of the sequence returned from a sieved Apply-to-Each can be
less than that of the argument sequences in its expression part. 
In Fortran 90, the <tt>WHERE</tt> statement applies  to an array whose
size is known on entry to the statement.

     <h3><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp; Reduction operations</h3>
In a reduction operation, a dyadic operator  injected between the elements of 
a vector, the rows or columns of a matrix etc,  produces a result of lower rank.
Examples would be the forming the sum of a table or finding the maximum or minimum
of a table.
So one could use + to reduce

<table border="1">
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td></tr></table>
   to 1+2+4+8=15

<p>
The first systematic treatment of reduction operations in programming languages is due
to Iverson[<a href="#Iverson62" name="CITEIverson62">16</a>]. He introduced the notion of a reduction functional which takes
a dyadic operator and, by currying, generates a tailored reduction function.
In APL as in J the reduction functional is denoted by <tt>/</tt>. Thus <tt>+/</tt> is the
function which forms the sum of an array.
<pre>
   a
1 2 3 5
   +/a
11

</pre>
The interpretation of reduction for comutative operators is simple, for non comutative ones
it is slightly less obvious. Consider:

<pre>
   -/a
_3

</pre>
The <tt>_3</tt> here, is the J notation for -3, derived  from the expansion (1<font face="symbol">-</font
>(2<font face="symbol">-</font
>(3<font face="symbol">-</font
>4(<font face="symbol">-</font
>0)))),
just as 11 was derived from the expansion (1+(2+(3+(4+0)))).
In J as in APL reduction applies uniformly to all binary operators.

<p>
Fortran 90, despite its debt to APL, is less general, providing a limited set of built in reduction
operators on comutative operators: <tt>SUM, PRODUCT, MAXVAL, MINVAL.</tt>
 Nesl likewise provides a limited set of reduction functions <tt>sum, minval, maxval, any, all</tt>.
The last two are boolean reductions, <tt>any</tt> returns true if at least one element of a sequence is true, <tt>
all </tt> if they are all true.

<p>
     <h3><a name="tth_sEc2.5">
2.5</a>&nbsp;&nbsp; Data reorganisation</h3>
In both linear algebra  and   image processing applications, it is often
desireable to be able to perform bulk reorganisation of data arrays.

<p>
<a name="tth_fIg2">
</a> 
<table border="1">
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td></tr>
<tr><td align="center">8</td><td align="center">16</td><td align="center">32</td></tr></table>

transposes to

<table border="1">
<tr><td align="center">1</td><td align="center">8</td></tr>
<tr><td align="center">2</td><td align="center">16</td></tr>
<tr><td align="center">4</td><td align="center">32</td></tr></table>

<center>Figure 2: Reorganising by transposition</center>

<p>
One may want to transpose a vector or matrix, or to shift the elements of
a vector. For example, one can express the convolution of a vector with 
a three element kernel in terms of multiplications, shifts and adds.
Let  a = 
<table border="1">
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td></tr></table>
 be a vector to be convolved with the kernel 
k = 
<table border="1">
<tr><td align="center">0.25</td><td align="center">0.5</td><td align="center">0.25</td></tr></table>
. This can be expressed by defining two temporary vectors 
<p>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
b,c = 0.25a,0.5a = </td><td nowrap="nowrap" align="center">
<table border="1">
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
0.25</td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
0.5</td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
1</td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
2</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
, </td><td nowrap="nowrap" align="center">
<table border="1">
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
0.5</td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
1</td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
2</td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
4</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


and then defining the result to the sum under shifts of b,c as shown in figure <a href="#fig:conv">3</a>

<p>
<a name="tth_fIg3">
</a> 
<table border="1">
<tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td></tr></table>
 convolve( 

<table border="1">
<tr><td align="center">0.25</td><td align="center">0.5</td><td align="center">0.25</td></tr></table>
)=
 
<table border="1">
<tr><td align="center">0.5</td><td align="center">1</td><td align="center">2</td><td align="center">2</td></tr>
<tr><td align="center">0.5</td><td align="center">1</td><td align="center">2</td><td align="center">4</td></tr>
<tr><td align="center">0.25</td><td align="center">0.25</td><td align="center">0.5</td><td align="center">1</td></tr><tr><td>
<tr><td align="center">1.25</td><td align="center">2.25</td><td align="center">4.5</td><td align="center">7</td></tr></table>


<center>Figure 3: Convolution by shifting</center>
<a name="fig:conv">
</a>

<p>
This example replicates the trailing value when shifting.
In other circumstances, when dealing with cellular automata for example, it
is convenient to be able to define circular shifts on data arrays.

<p>
Fortran 90 provides a rich set of functions to reshape, transpose and circularly shift arrays.
For instance given a 9 element vector v we can reshape it as a 3 by 3 matrix

<pre>

V= (/ 1,2,3,4,5,6,7,8,9 /)
M=RESHAPE(V,(/3,3/))

</pre>
gives us the array

<pre>
1  2  3
4  5  6
7  8  9

</pre>
We can then cyclically shift this along a dimension

<pre>
M2=CSHIFT(M,SHIFT=2,DIM=2)

</pre>
to give 

<pre>

3  1  2  
6  4  5  
9  7  8  
</pre>
 Nesl provides   on sequences, similar operations to those
provided on arrays by Fortran 90,
so that if

<pre>
v             =[ 1,2,3,4,5,6,7,8,9]
s             =[3,3,3]
partition(v,s)=[[1,2,3][4,5,6],7,8,9]]
rotate(v,3)   =[7,8,9,1,2,3,4,5,6]

</pre>

<p>
       <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Data parallelism in Vector Pascal</h2>

<p>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Assignment maps</h3>

<p>
Standard Pascal allows assignement of whole arrays. Vector Pascal extends this
to allow consistent use of mixed rank expressions on the right hand side of
an assignment. Given

<p>
<b>r0:real; r1:array[0..7] of real; r2:array[0..7,0..7] of real</b>

<p>
then we can write

<ol type="1"><p>
<li> r<b>1:= r2[3]; { supported in standard Pascal }</b></li>
<p>
<li> <b>r1:= 1/2; { assign 0.5 to each element of r1 }</b></li>
<p>
<li> <b>r2:= r1*3; { assign 1.5 to every element of r2}</b></li>
<p>
<li> <b>r1:= + r2; { r1gets the totals along the rows of r2}</b></li>
<p>
<li> <b>r1:= r1+r2[1];{ r1 gets the corresponding elements of row 1 of
r2 added to it}</b></li>
</ol>
The assignment of arrays is a generalisation of what standard Pascal allows.
Consider the first examples above, they are equivalent to:

<p>

<ol type="1"><p>
<li> <b>for i:=0 to 7 do r1[i]:=r2[3,i];</b></li>
<p>
<li> <b>for i:=0 to 7 do r1[i]:=1/2;</b></li>
<p>
<li> <b>for i:=0 to 7 do for j:=0 to 7 do r2[i,j]:=r1[j]*3;</b></li>
<p>
<li> <b>for i:=0 to 7 do begin t:=0; for j:=7 downto 0 do t:=r2[i,j]+t;
r1[i]:=t; end;</b></li>
<p>
<li> <b>for i:=0 to 7 do r1[i]:=r1[i]+r2[1,i];</b></li>
</ol>
In other words the compiler has to generate an implicit loop over
the elements of the array being assigned to and over the elements of the array
acting as the data-source. In the above <b>i,j,t</b> are assumed to be temporary
variables not refered to anywhere else in the program. The loop variables are
called implicit indices <a name="implicitindices">
</a>and
may be accessed using <b>iota</b>. 

<p>
The variable on the left hand side of an assignment defines an array context
within which expressions on the right hand side are evaluated. Each array context
has a rank given by the number of dimensions of the array on the left hand side.
A scalar variable has rank 0. Variables occuring in expressions with an array
context of rank <em>r</em> must have <em>r</em> or fewer dimensions. The <em>n</em>
bounds of any <em>n</em> dimensional array variable, with  n <font face="symbol">£</font
> r  occuring
within an expression evaluated in an array context of rank <em>r</em> must match
with the rightmost <em>n</em> bounds of the array on the left hand side of the
assignment statement. 

<p>
Where a variable is of lower rank than its array context, the variable is replicated
to fill the array context. This is shown in examples 2 and 3 above. Because
the rank of any assignment is constrained by the variable on the left hand side,
no temporary arrays, other than machine registers, need be allocated to store
the intermediate array results of expressions.

<p>
Maps are implicitly and promiscously defined on both monadic operators and unary functions.
If <b>f</b> is a function or unary operator
mapping from type <b>r</b> to type <b>t</b> then if <b>x</b> is an array
of <b>r</b> then <b>a:=f(x)</b> assigns an array of <b>t</b> such that
<b>a[i]=f(x[i])</b>.

<p>
Functions can return any data type whose size is known at compile time, including arrays and records.
A consistent copying semantics is used.

<p>
     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Slice operations</h3>

<p>
Image processing applications often have to deal with regions of interest, rectangular
sub-images within a larger image. Vector Pascal extends the array abstraction to
define sub-ranges of arrays. A sub-range  of an array variable are denoted by the variable followed
by a range expression in brackets.

<p>
The expressions within the range expression must conform to the index type of
the array variable. The type of a range expression <b>a[i..j]</b> where
<b>a: array[p..q] of t</b> is <b>array[0..j-i] of t.</b>

<p>
Examples

<p>
<b>dataset[i..i+2]:=blank;</b>

<p>
<b>twoDdata[2..3,5..6]:=twoDdata[4..5,11..12]*0.5;</b>

<p>
Subranges may be passed in as actual parameters to procedures whose corresponding
formal parameters are declared as variables of a schematic type. Hence given
the following declarations:

<p>
<b>type image(miny,maxy,minx,maxx:integer)=array[miny..maxy,minx..maxx]
of pixel;</b>

<p>
<b>procedure invert(var im:image);begin im:= - im; end;</b>

<p>
<b>var screen:array[0..319,0..199] of pixel;</b>

<p>
then the following statement would be valid:

<p>
<b>invert(screen[40..60,20..30]);</b>

<p>
A particular form of slicing is to select out the diagonal
of a matrix.
The syntactic form <b>diag</b>&lt;expression&#62; selects the
diagonal of the matrix to which it applies. A precise definition of
this is given in section <a href="#diag">3.5</a>.

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Conditional update operations</h3>
In Vector Pascal the sort of conditional updates handled by the Fortran <tt>WHERE</tt>
statement, are programmed using conditional expressions. The Fortran code shown in   <a href="#where">2.3</a> would translate to

<p>
<b>var a:array[0..63] of real;</b>

<p>
<b>a:=if a &gt; 0 then a else -a</b>

<p>
The <b>if</b> expression can be compiled in two ways:
<ol type="1"><p>
<li> Where the two arms of the if expression are parallelisable,
the condition and both arms are evaluated and then merged under
a boolean mask so the above assignment would be equivalent to:

<p>
<b>a:= (a and (a &gt; 0))or(not (a &gt; 0) and -a);</b>

<p>
were the above legal Pascal<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>.</li>
<p>
<li> If the code is not paralleliseable it is translated as
equivalent to a standard if statement, so the previous example
would be equivalent to:

<p>
<b> for i:=0 to 63 do if a[i] &gt; 0 then a[i]:=a[i] else a[i]:=-a[i];</b>

<p>
Expressions are non parallelisable if they include function calls.</li>
</ol>
The dual compilation strategy allows the same linguistic construct
to be used in recursive function definition and parallel data selection.

<p>
     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Operator Reduction</h3>
Maps take operators and arrays and deliver array results. The <em>reduction </em>
abstraction takes a dyadic operator and an array and returns a scalar result. It is denoted 
by the
functional form . Thus if a is an array, +a denotes
the sum over the array. More generally  \<font face="symbol">F</font
>x  for some dyadic
operator  <font face="symbol">F</font
> means  x<sub>0</sub><font face="symbol">F</font
>(x<sub>1</sub><font face="symbol">F</font
>..(x<sub>n</sub><font face="symbol">F</font
><font face="symbol">i</font
>)) 
where  <font face="symbol">i</font
> is the identity element for the operator and the type. Thus
we can write + for  <font face="symbol">å</font
>, * for  <font face="symbol">Õ</font
>
etc. The dot product of two vectors can thus be written as

<p>
<b>x:=+(y*z);</b>

<p>
instead of

<p>
<b>x:=0;</b>

<p>
<b>for i:=0 to n do x:= x+ y[i]*z[i];</b>

<p>
A reduction operation takes an argument of rank <em>r</em> and returns an argument
of rank <em>r-1</em> except in the case where its argument is or rank 0, in which
case it acts as the identity operation. Reduction is always performed along
the last array dimension of its argument. 
 
<p>
Semantically reduction by an operator say \odot is defined such that

<p>
<b>var a:array[low..high] of t;x:t;</b>

<p>
<b>x:=\odota;</b>

<p>
is equivalent to:

<p>
<b> var temp:t; i:low..high;</b>

<p>
<b> temp:= <em>identity</em>(t,\odot);</b>

<p>
<b> for i:= high downto low do temp:=a[i]\odottemp;</b>

<p>
<b>x:=temp;</b>

<p>
Where <em>identity</em>(t,\odot) is a function returning the identity element under the
operator \odot for the type <b>t</b>. The identity element  is defined to be the value such
that x = x\odot<em>identity</em>(t,\odot). Identity elements for operators and types
are shown in table <a href="#ids">1</a>.

     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Array reorganisation</h3>

<p>
By array reorganisation, we mean conservative operations, which 
preserve the number of elements in the orignal array.
If the shape of the array is also conserved we have an element
permutation operation. If the shape of the array is not
conserved but it's rank and extents are, we have a permutation of
the array dimensions. If the rank is not conserved we have
a flattening or reshaping of the array.

<p>
 Vector Pascal provides syntactic forms to access and manipulate  the implicit indices used
in maps and reductions. These syntactic forms allow the concise expression
of many   conservative array reorganisations.

<p>
The   form &nbsp;<b>iota </b><em>i </em> returns the <em>i</em>th current implicit index. 
Thus given the definitions

<p>
 <b> v1:array[1..3]of integer; v2:array[0..4]of
integer;</b>

<p>
the program fragment

<p>
<b>v1:=iota 0; </b>
<b>v2:=iota 0 *2;</b>

<p>
would set v1 and v2 as follows: 

<p>

<pre>
v1=	1	2	3
v2=	0	2	4	6	8

</pre>
whilst given the definitions

<p>
<b>m1:array[1..3,0..4] of integer;m2:array[0..4,1..3]of integer;</b>

<p>
then the program fragment 

<p>
<b>m2:= iota 0 +2*iota 1; </b>

<p>
would set m2

<p>

<pre>
m2=
	2	4	6
	3	5	7
	4	6	8	
	5	7	9
	6	8	10

</pre>
The argument to iota must be an integer known at compile time within
the range of implicit indices in the current context.

<p>
A generalised permutation of the implicit indices is performed using the syntatic
form <b>perm[</b>&lt;index-sel&#62;[,&lt;index-sel&#62;]*<b>] </b>&lt;expression&#62;. The &lt;index-sel&#62;s 
are integers known at compile time which specify a permution on the implicit
indices. Thus in e evaluated in context <b>perm[</b>i,j,k<b>]</b>e, then
<b>iota 0 =<b>iota i, iota 1=iota j, iota 2=iota k</b></b>. 

<p>
An example of where this is useful is in converting between different image formats.
Hardware frame buffers typically represent images with the pixels in the
red, green, blue, and alpha channels adjacent in memory. For image processing
it is convenient to hold them in distinct planes.
The <b>perm</b> operator provides a concise notation for translation between these
formats:

<p>
<b>screen:=perm[2,0,1]img;</b>

<p>
where:
<font size="-1">
<p>
<b>type rowindex=0..479;colindex=0..639;channel=red..alpha;</b>

<p>
<b>screen:array[rowindex,colindex,channel] of pixel;</b>

<p>
<b> img:array[channel,colindex,rowindex] of pixel;</b>
</font>

<p>
<b>trans</b> and <b>diag</b> <a name="diag">
</a> provide shorthand notions for expressions in terms of
<b>perm</b>. Thus in an assignment context of rank 2, <b>trans</b> = <b>perm[1,0]</b>
and <b>diag </b>= <b>perm[0,0]</b>.
The   form <b>trans</b><em>x</em> transposes a vector <a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>matrix, or tensor. It achieves
this by cyclic rotation of the implicit indices.
Thus if <b>trans</b> <em>e</em> , for some expression <em>e</em> is evaluated in a context with implicit indices 

<p>
<b>iota</b> <em>0</em>.. <b>iota</b> <em>n </em>

<p>
then the expression e is evaluated in a context with implicit indices 

<p>
<b>iota</b>'<em>0</em>.. <b>iota</b>'<em>n</em> 

<p>
where 

<p>
<b>iota</b>'<em>x</em> = <b>iota</b> ( (<em>x+1</em>)<b>mod</b> <em>n+1</em>)

<p>
It should be noted that transposition is generalised to arrays of rank greater
than 2.

<p>

<b>Examples&nbsp;&nbsp;</b>

<p>
Given the defintions used above, the program fragment:

<p>
<b>m1:= (trans v1)*v2; </b>

<p>
<b>m2 := trans m1; </b>

<p>
will set m1 and m2:

<p>

<pre>
m1=
	0	2	4	6	8
	0	4	8	12	16
	0	6	12	18	24
m2=
	0	0	0
	2	4	6
	4	8	12
	6	12	18
	8	16	24

</pre>

<p>
      <h4><a name="tth_sEc3.5.1">
3.5.1</a>&nbsp;&nbsp;Array shifts</h4>
The shifts and rotations of arrays supported in Fortran 90 and  Nesl
are not supported by any explicit operator, though one can of course use
a combination of other features to achieve them.
A left rotation can for instance be achieved as follows:

<p>
<b>a:=b[(1+iota 0)mod n];</b>

<p>
and a reversal by

<p>
<b>a:=b[n-iota 0  -1];</b>

<p>
Where in both examples:

<p>
<b>var a,b:array[0..n-1] of integer;</b>

     <h3><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;Efficiency considerations</h3>
 Expressions involving transposed vectors, matrix diagonals, and permuted vectors
or indexing by expressions involving modular arithmetic on <b>iota</b>,
  do not paralellise well on SIMD architectures
like the MMX, since these depend upon the fetching of blocks of adjacent elements into
the vector registers. This requires that element addresses be adjacent and
monotonically increasing. Assignments involving mapped vectors will usually
have to be handled by scalar registers. 

<p>
      <h4><a name="tth_sEc3.6.1">
3.6.1</a>&nbsp;&nbsp;Element permutation</h4>

<p>
Permutations are widely used in APL and J programming, an example being
sorting and array <tt>a</tt> into descending order using the J expression
<tt>  \:a{a </tt>
which uses the operator <tt>\:</tt> to produce a permutation of the indices
of <tt>a</tt> in descending order, and then uses { to index <tt>a</tt> with this permutation vector.
If one is to use analogous constructs, one muse allow
 an array may be indexed
by another array. If <b>x:array[t0] of t1</b> and <b>y:array[t1]
of t2</b>, then in Vector Pascal,  <b>y[x]</b> denotes the virtual array of type <b>array[t0]
of t2</b> such that <b>y[x][i]=y[x[i]]</b>.  

<p>

<b>Example&nbsp;&nbsp;</b>

<p>
Given the declarations

<p>
<b>const perm:array[0..3] of integer=(3,1,2,0);</b>

<p>
<b>var ma,m0:array[0..3] of integer; </b>

<p>
then the statements

<p>
<b>m0:= (iota 0)+1;</b>

<p>
<b>ma:=m0[perm]; </b>

<p>
would set the variables such that 

<p>

<pre>
m0=	1 	2 	3 	4
perm=	3	1	2	0
ma=	4	2	3	1

</pre>

<p>
        <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Extensions to the Pascal Type System</h2>

<p>
     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Pixels</h3>
Standard Pascal is a strongly typed language, with a comparatively rich collection
of type abstractions : enumeration, set formation, sub-ranging, array formation,
cartesian product<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a> and unioning<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>. However as an image processing language it suffers from
the disadvantage that no support is provided for pixels and images.
Given the vintage of the language this is not surprising and, it may be thought,
this deficiency can be readily overcome using existing language features. 
Can pixels not
be defined as a subrange 0..255 of the integers, and images modeled as two
dimensional arrays? 

<p>
They can be, and are so defined in many applications, but such an approach throws
onto the programmer the whole burden of handling the complexities of limited
precision arithmetic. Among the problems are:
<ol type="1"><p>
<li>When doing image processing it is frequently necessary to subtract one image
from another, or to create negatives of an image. Subtraction and negation
implies that pixels should be able to take on negative values.</li>
<p>
<li> When adding pixels using limited precision arithmetic, addition is nonmontonic due to wrap-round. 
Pixel values of 100 + 200 = 300, which in
8 bit precision is truncated to 44 a value darker than either of the
starting values.
A similar problem can arise with subtraction, for instance 100<font face="symbol">-</font
>200 = 156 in 8 bit unsigned arithmetic.</li>
<p>
<li> When multiplying 8 bit numbers, as one does in executing a convolution kernel,
one has to enlarge the representation and shift down by an appropriate amount to stay
within range.</li>
</ol>
These and similar problems make the coding of image filters a skilled task. The difficulty
arises because one is using an inappropriate conceptual representation of pixels.

<p>
The <em>conceptual model</em> of pixels in Vector Pascal is that they are real numbers in
the range <font face="symbol">-</font
>1.0 .. 1.0. This representation overcomes the aforementioned difficulties.
As a signed representation it lends itself to subtraction. As an unbiased representation,
it makes the adjustment of contrast easier, one can reduce contrast 50% simply by multiplying an image by 
 0.5
<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>.
Assignment to pixel variables in Vector Pascal is defined to be saturating - real numbers outside
the range <font face="symbol">-</font
>1..1 are clipped to it.
The multiplications involved in convolution operations fall naturally into place.

<p>
The <em>implementation model</em> of pixels used in Vector Pascal
is of 8 bit signed integers treated as
 fixed point binary fractions.
 All the conversions necessary to preserve 
the monotonicity of addition, the range of multiplication etc, are delegated to the code generator
which, where possible, will implement the semantics using efficient,
 saturated multi-media  arithmetic instructions.

<p>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Dimensioned Types</h3>

<p>
Dimensional analysis is familiar to scientists and engineers and provides a
routine check on the sanity of mathematical expressions. Dimensions can not
be expressed in the otherwise rigourous type system of standard Pascal, but
they are a useful protection against the sort of programming confusion between
imperial and metric units that caused the demise of a recent Mars probe. They
provide a means by which floating point types can be specialised to represent
dimensioned numbers as is required in physics calculations. For example:

<p>
<b>kms =(mass,distance,time);</b>

<p>
<b>meter=real of distance;</b>

<p>
<b>kilo=real of mass;</b>

<p>
<b>second=real of time;</b>

<p>
<b>newton=real of mass * distance * time POW -2;</b>

<p>
<b>meterpersecond = real of distance *time POW -1;</b>

<p>
The identifier must be a member of a scalar type, and that scalar type is then
refered to as the <em>basis space</em> of the dimensioned type. The identifiers of the
basis space are refered to as the dimensions of the dimensioned type. Associated
with each dimension of a dimensioned type there is an integer number refered
to as the power of that dimension. This is either introduced explicitly at type
declaration time, or determined implicitly for the dimensional type of expressions. 

<p>
A value of a dimensioned type is a dimensioned value. Let  log<sub>d</sub>t 
of a dimensioned type  t  be the power to which the dimension  d 
of type  t  is raised. Thus for  t = newton in the example above, and
 d = time,  log<sub>d</sub>t = <font face="symbol">-</font
>2 

<p>
If  x  and  y  are values of dimensioned types  t<sub>x</sub> and  t<sub>y</sub> respectively,
then the following operators are only permissible if  t<sub>x</sub> = t<sub>y</sub> : +,
- ,&lt;, &#62;, =, &lt;=, &#62;=. For + and -, the dimensional type of the result is the same
as that of the arguments. The operations. The operations *, / are permited
if the types  t<sub>x</sub> and  t<sub>y</sub>  share the same basis space, or if
the basis space of one of the types is a subrange of the basis space of the
other.  

<p>
The operation <b>POW</b> is permited between dimensioned types and integers.

<p>

<b>*&nbsp;&nbsp;</b>Dimension deduction rules

<p>

<ol type="1"><p>
<li> If  x = y*z  for  x:t<sub>1</sub>,y:t<sub>2</sub>,z:t<sub>3</sub>  with basis space  B 
then  <font face="symbol">"</font
><sub>d <font face="symbol">Î</font
> B</sub>log<sub>d</sub>t<sub>1</sub> = log<sub>d</sub>t<sub>2</sub>+log<sub>d</sub>t<sub>3</sub> .</li>
<p>
<li> If  x = y/z  for  x:t<sub>1</sub>,y:t<sub>2</sub>,z:t<sub>3</sub>  with basis space  B 
then  <font face="symbol">"</font
><sub>d <font face="symbol">Î</font
> B</sub>log<sub>d</sub>t<sub>1</sub> = log<sub>d</sub>t<sub>2</sub><font face="symbol">-</font
>log<sub>d</sub>t<sub>3</sub> .</li>
<p>
<li> If  x = y  <b>POW</b>  z  for  x:t<sub>1</sub>,y:t<sub>2</sub>,z:integer  with
basis space for  t<sub>2</sub> ,  B  then  <font face="symbol">"</font
><sub>d <font face="symbol">Î</font
> B</sub>log<sub>d</sub>t<sub>1</sub> = log<sub>d</sub>t<sub>2</sub>&times;z .</li>
</ol>

<p>
       <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Operators</h2>

<p>
      <h4><a name="tth_sEc5.0.1">
5.0.1</a>&nbsp;&nbsp;Dyadic Operations</h4>

<p>
Dyadic operators supported are <b>+, +:, -:, -, *, /, div, mod , **,
pow, &lt;, &#62;, &#62;=, &lt;=, =, &lt;&#62;, shr, shl, and, or, in, min, max</b>. All of these are consistently
extended to operate over arrays. The operators **, pow denote exponentiation
and raising to an integer power as in ISO Extended Pascal.
 The operators +: and -: exist to support saturated
arithmetic on bytes as supported by the MMX instruction set.

      <h4><a name="tth_sEc5.0.2">
5.0.2</a>&nbsp;&nbsp;Unary operators</h4>
The unary operators supported are <b>+, -, *, /, max, min,
div, not, round, sqrt, sin, cos, tan, abs, ln, ord, chr, succ, pred</b> and <b>@</b>.

<p>
Thus the following are valid unary expressions<b>: -1, +b, not true, sqrt
abs x, sin theta.</b> In standard Pascal some of these operators are treated as
functions,. Syntactically this means that their arguments must be enclosed in
brackets, as in <b>sin(theta)</b>. This usage remains syntactically correct
in Vector Pascal. 

<p>
The dyadic operators   are   extended to unary context
by the insertion of an identity element under the operation. 
This is a generalisation of the monadic use of + and - in standard pascal where
<b>+a=0+a</b> and <b>-a
= 0-a</b> with 0 being the additive identity, so too <b>/2 = 1/2</b> with 1 the multiplicative
identity. For sets the notation <b>-s</b> means the
complement of the set <b>s</b>. The identity elements inserted are given in table <a href="#ids">1</a>.

<p>
<a name="tth_tAb1">
</a> <center>Table 1: Identity element</center><a name="ids">
</a>

<p>
<center> 
<table border="1">
<tr><td align="center">type</td><td align="center">operators</td><td align="center">identity elem</td></tr><tr><td>
<tr><td align="center">number</td><td align="center">+,-</td><td align="center">0</td></tr>
<tr><td align="center">set</td><td align="center">+</td><td align="center">empty set</td></tr>
<tr><td align="center">set</td><td align="center">-,*</td><td align="center">fullset</td></tr>
<tr><td align="center">number</td><td align="center">*,/ ,div,mod</td><td align="center">1</td></tr>
<tr><td align="center">boolean</td><td align="center">and</td><td align="center">true</td></tr>
<tr><td align="center">boolean</td><td align="center">or </td><td align="center">false</td></tr></table>

<p>
</center>
<p>
      <h4><a name="tth_sEc5.0.3">
5.0.3</a>&nbsp;&nbsp;Operator overloading</h4>
The dyadic operators can be extended to operate on new types
by operator overloading. 
Figure <a href="#complex">4</a> shows how arithmetic on the type <b>complex</b>
required by Extended Pascal [<a href="#ISO90" name="CITEISO90">15</a>] is defined in Vector Pascal.
Each  operator is associated with a semantic function 
and an identity element.
The operator symbols must be drawn from the set of predefined vector
pascal operators, and when expressions involving them are parsed,
priorities are inherited from the predefined operators.
The type signature of the operator is deduced from the type of the 
function<a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>.

<p>
<a name="tth_fIg4">
</a> 
<pre>
type
        complex = record data: array[0..1] of real;end;
var     complexzero,complexone:complex;

{ headers for functions onto the complex numbers }	
function cmplx               (realpart,imag:real):complex;
function complex_add         (A,B:Complex):complex;
function complex_conjugate   (A:Complex):complex; 
function complex_subtract    (A,B:Complex):complex; 
function complex_multiply    (A,B:Complex):complex;  
function complex_divide      (A,B:Complex):complex;  
function im                  (c:complex):real; 
function re                  (c:complex):real;
{	Standard operators on complex numbers 	}
{           symbol   function           identity element }
operator    + =     complex_add,       complexzero;
operator    / =     complex_divide,    complexone;
operator    * =     complex_multiply,  complexone;
operator    - =     complex_subtract,  complexzero;

</pre>

<center>Figure 4: Defining operations on complex numbers</center>
<a name="complex">
</a><font size="-1">
Note that only the function headers are given here as this
code comes from the interface part of the system unit. The function
bodies and the initialisation of the variables complexone and
complexzero are handled in the implementation part of the unit.</font>

<p>
When parsing expressions, the compiler first tries to
resolve operations in terms of the predefined operators
of the language, taking into account the standard mechanisms
allowing operators to work on arrays. Only if these
fail does it search for an overloaded operator whose type
signature matches the context.

<p>
In the example in figure <a href="#complex">4</a>, complex numbers are
defined to be records containing an array of reals, rather
than simply as an array of reals. Had they been so defined, the operators +,*,-,/ on reals would
have masked the corresponding operators on complex numbers.

<p>
The provision of an identity element for complex addition and subtraction
ensures that unary minus, as in <font face="symbol">-</font
>x for x:complex, is well defined, and correspondingly
that unary / denotes complex reciprocal.
Overloaded operators can be used in array maps and array reductions. 

       <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;An example algorithm</h2>
As an example of Vector Pascal we will look at an image filtering algorithm.
In particular we will look at applying a separable 3  element convolution 
kernel to an image. We shall initially present the algorithm in standard
Pascal and then look at how one might re-express it in Vector Pascal.

<p>
Convolution of an image by a matrix of real numbers can be used to
smooth or sharpen an image, depending on the matrix used.
If A is an output image, K a convolution matrix, then
if 
B is the convolved  image

<p>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
B<sub>y,x</sub> = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font face="symbol" size="+3">å<br /></font>
<font size="-1">i</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font face="symbol" size="+3">å<br /></font>
<font size="-1">j</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
A<sub>y+i,x+j</sub>K<sub>i,j</sub></td></tr></table>
</td></tr></table>

 

<p>
A separable convolution kernel is a vector of real numbers that can be
applied independently to the rows and columns of an image to provide filtering. 
It is a specialisation of the more general
convolution matrix, but is algorithmically more efficient to implement.
If <b>k</b> is a convolution vector, then the corresponding matrix K is
such that K<sub>i,j</sub> = <b>k</b><sub>i</sub> <b>k</b><sub>j</sub>.

<p>
Given a starting image A as a two dimensional array of pixels, and a 
three element kernel  c<sub>1</sub>, c<sub>2</sub>, c<sub>3</sub>, the algorithm first forms a temporary
array T whose 	whose elements are the
weighted sum of adjacent rows T<sub>y,x</sub> = c<sub>1</sub>A<sub>y<font face="symbol">-</font
>1,x</sub>+c<sub>2</sub>A<sub>y,x</sub>+c<sub>3</sub>A<sub>y+1,x</sub>.
Then in a second phase it sets the original image to be the weighted sum
of the columns of the temporary array: A<sub>y,x</sub> = c<sub>1</sub>T<sub>y,x<font face="symbol">-</font
>1</sub>+c<sub>2</sub>T<sub>y,x</sub>+c<sub>3</sub>Ty,x+1. 
Clearly the outer edges of the image are a special case, since the convolution
is defined over the neighbours of the pixel, and the pixels along the boundaries
a missing one neighbour. A number of solutions are available for this, but
for simplicity we will perform only vertical convolutions on the left and right
edges and horizontal convolutions on the top and bottom lines of the image.

<p>

<p>
<a name="tth_fIg5">
</a> 
<pre>
type
    pixel = -128..127;
    tplain = array[0..maxpix ,0..maxpix] of pixel;

procedure conv(var theim:tplain;c1,c2,c3:real);
var tim:array[0..maxpix,0..maxpix]of pixel;
    temp:real;
    i,j:integer;
begin
        for i:=1 to maxpix-1 do
         for j:= 0 to maxpix do begin 
              temp:= theim[i-1][j]*c1+theim[i][j]*c2+theim[i+1][j]*c3;
              if temp&#62;127 then temp :=127 else
              if temp&lt;-128 then temp:=-128;
              tim[i][j]:=round(temp);
         end;
        for j:= 0 to maxpix do begin
                tim[0][j]:=theim[0][j]; tim[maxpix][j]:=theim[maxpix][j];
        end;
        for i:=0 to maxpix do begin
            for j:= 1 to maxpix-1 do begin
                temp:= tim[i][j-1]*c1+tim[i][j+1]*c3+tim[i][j]*c2;
                if temp&#62;127 then temp :=127 else
                if temp&lt;-128 then temp:=-128;
                tim[i][j]:=round(temp);
            end;
            theim[i][0]:=tim[i][0]; theim[i][maxpix]:=tim[i][maxpix];
        end;
end;

</pre>

<center>Figure 5: Standard Pascal implementation of the convolution</center><a name="sconv">
</a>

<p>
Figure <a href="#sconv">5</a> shows <tt>conv</tt> an implementation of the convolution in
Standard Pascal. The pixel data type has to be explicitly introduced
as the subrange -128..127. Explicit checks have to be inplace to prvent
range errors, since the result of a convolution may, depending on the
kernel used, be outside the bounds of valid pixels. Arithmetic is
done in floating point and then rounded.

<p>
<a name="tth_fIg6">
</a> 
<pre>
procedure pconv(var theim:tplain;c1,c2,c3:real);
var tim:array[0..maxpix,0..maxpix]of pixel;
    p1,p2,p3:array[0..maxpix]of  pixel;
begin
     p1:=c1; p2:=c2; p3:=c3;        
     tim [1..maxpix-1] := 
        theim[0..maxpix-2]*p1 +theim[1..maxpix-1]*p2+theim[2..maxpix]*p3;
     tim[0]:=theim[0]; tim[maxpix]:=theim[maxpix];
     theim[][1..maxpix-1]:=
        tim[][0..maxpix-2]*p1+tim[][2..maxpix]*p3+tim[][1..maxpix-1]*p2;
     theim[][0]:=tim[][0]; theim[][maxpix]:=tim[][maxpix];
end;
</pre>

<p>
<center>Figure 6: Vector Pascal implementation of the convolution</center><a name="vconv">
</a>

<p>
Image processing algorithms lend themselves particularly well to
data-parallel expression, working as they do on arrays of data
subject to uniform operations.
Figure <a href="#vconv">6</a> shows a data-parallel version of the algorithm,
<tt>pconv</tt>, implemented in Vector Pascal. Note that all explicit loops
disappear in this version, being replaced by assignments of array slices.
The first line of the algorithm initialises three vectors <tt>p1, p2, p3</tt>
of pixels to hold the replicated copies of the kernel coefficients <tt>c1, c2, c3</tt>
in fixed point format.
These vectors are then used to multiply  rows of the image to
build up the convolution.
The notation <tt>theim[][1..maxpix-1]</tt> denotes columns 1..maxpix-1 of all rows of the 
image. Because the built in pixel data type is used,
all range checking is handled by the compiler.
Since fixed point arithmetic is used throughout, there will be slight rounding
errors not encountered with the previous algorithm, but these are
acceptable in most image processing applications. 
Fixed point pixel arithmetic has the advantage that it can be efficently
implemented in parallel using multi-media instructions.

<p>
It is clear that the data-parallel implementation is somewhat more concise
than the sequential one,  12 lines with 505 characters compared to 26 lines with 952 characters.
It also  runs considerably faster, as shown in
table <a href="#convperf">2</a>.
This expresses the performance of different implementations in millions
of effective arithmetic operations per second. It is assumed that the basic
algorithm requires 6 multiplications and 6 adds per pixel processed.
The data parallel algorithm runs 12 times faster than the serial one
when both are compiled using Vector Pascal and targeted at the MMX
instructionset. The <tt>pconv</tt>  also runs a third faster than <tt>conv</tt> when it is
targeted at the 486 instructionset, which in effect, serialises the code.

<p>
For comparison <tt>conv</tt> was run on   other Pascal Compilers<a href="#tthFtNtAAI" name="tthFrefAAI"><sup>8</sup></a>, DevPascal 1.9, Borland
Pascal and its successor Delphi<a href="#tthFtNtAAJ" name="tthFrefAAJ"><sup>9</sup></a>. These are extended implementations, but with no support for vector arithmetic.
 Delphi is are state of the art commercial compilers, as Borland Pascal was
when released in 1992. DevPas is a recent free compiler.
In all cases range checking was enabled for consistency with Vector Pascal. The only other change was to define the
type pixel as equivalent to the system type shortint to force implementation
as a signed byte.
Delphi runs <tt>conv</tt> 40% faster than Vector Pascal does, whereas Borland
Pascal runs it at only 7% of the speed, and DevPascal is roughly comparable to Vector Pascal.

<p>

<p>
<a name="tth_tAb2">
</a> <center>Table 2: Comparative Performance on Convolution</center><a name="convperf">
</a>

<table>
<tr><td>Algorithm</td><td>Implementation</td><td>Target Processor</td><td align="center">Million Ops Per Second</td></tr>
<tr><td>conv</td><td>Vector Pascal</td><td>Pentium + MMX  </td><td align="center">61</td></tr>
<tr><td></td><td>Borland Pascal</td><td>286 + 287</td><td align="center">5.5</td></tr>
<tr><td></td><td>Delphi 4</td><td>486  </td><td align="center">86</td></tr>
<tr><td></td><td>DevPascal</td><td>486</td><td align="center">62</td></tr>
<tr><td>pconv</td><td>Vector Pascal</td><td>486  </td><td align="center">80 </td></tr>
<tr><td></td><td>Vector Pascal</td><td>Pentium + MMX  </td><td align="center">817</td></tr></table>


<p>
<font size="-1">Measurements done on a 1Ghz Athlon, running Windows 2000.</font> 

<p>
Further performance comparisons are given in table <a href="#kernels">3</a>.
The tests here involve vector arithmetic on vectors of length 640 and take the
general form v<sub>1</sub> = v<sub>2</sub> <font face="symbol">f</font
>v<sub>3</sub> for some operator <font face="symbol">f</font
> and some
vectors v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>. The exception being the dot product
operation coded as 
<pre>
r:=\+ r2*r3

</pre> in Vector Pascal, and using conventional
loops for the other compilers.
When targeted on a 486 the performance of the Vector Pascal compiler
for vector arithmetic is consistently better than that of other compilers. The exception to this is dot
product operations on which Delphi performs particularly well.
When the target machine is a K6 which incorporates both the
MMX and the 3DNow SIMD instruction sets, the acceleration is
broadly in line with the degree of parallelism offered by the
architecture: 8 fold for byte operands, 4 fold for 16 bit ones,
and 2 fold for integers and reals.
The speedup is best for the 8 bit operands, a sevenfold acceleration
on byte additions for example. For larger operands it falls off   to 60% for 32 bit integers and 33% for 
32 bit reals. As shown in table <a href="#gains">4</a> the Intel P3 gives slightly greater vectorisation gains for
floating point arithmetic. For both the Athlon and the P3 the vectorisation gains
on floating point arithmetic are disappointingly low compared to those obtained for
other data types.

<p>
For data types where saturated arithmetic is used, the accleration
is most marked, a 12 fold acceleration being achieved for saturated 
byte additions and a 16 fold acceleration on pixel additions. 
These additional gains come from the removal of bounds checking
code that would otherwise be required.

<p>
 
<p>
<a name="tth_tAb3">
</a> <center>Table 3: Performance on vector kernels</center><a name="kernels">
</a>

<table>
<tr><td>DevP</td><td>TMT</td><td>BP 286</td><td>DP 486</td><td>VP 486</td><td>VP K6</td><td>test</td></tr>
<tr><td>71</td><td>80</td><td>46 </td><td>166</td><td>333</td><td>2329 </td><td>unsigned byte additions </td></tr>
<tr><td>55</td><td>57</td><td>38</td><td>110</td><td>179</td><td>2329 </td><td>saturated unsigned byte additions</td></tr>
<tr><td>85</td><td>59</td><td>47 </td><td>285 </td><td>291 </td><td>466 </td><td>32 bit integer additions</td></tr>
<tr><td>66</td><td>74</td><td>39</td><td>124 </td><td>291</td><td>1165</td><td>16 bit integer additions</td></tr>
<tr><td>47</td><td>10</td><td>33</td><td>250 </td><td>291</td><td>388 </td><td>real additions </td></tr>
<tr><td>49</td><td>46</td><td>23</td><td>98</td><td>146</td><td>2330</td><td>pixel additions </td></tr>
<tr><td>67</td><td>14</td><td>39</td><td>99</td><td>146</td><td>1165</td><td>pixel multiplications </td></tr>
<tr><td>47</td><td>10</td><td>32</td><td>161</td><td>146</td><td>141 </td><td>real dot product </td></tr>
<tr><td>79</td><td>58</td><td>33</td><td>440 </td><td>161</td><td>166 </td><td>integer dot product   </td></tr></table>

<font size="-1">
<p>
DevP - Dev Pascal version 1.9 

<p>
TMT - TMT Pascal version 3

<p>
BP 286 - Borland Pascal compiler with 287 instructions enabled range checks off.

<p>
DP 486 - Delphi version 4

<p>
VP 486 - Vector Pascal targeted at a 486

<p>
VP K6 - Vector Pascal targeted at and AMD K6

<p>
All figures in millions of operations per second on a 1 Ghz Athlon.</font>

<p>

<p>
<a name="tth_tAb4">
</a> <center>Table 4: Vectorisation gains with P3 and Athlon processors</center>
<a name="gains">
</a>

<table border="1">
<tr><td></td><td align="center"> P3
	</td><td align="center"> Athlon
</td></tr>
<tr><td> operation
	</td><td align="center"> % vectorisation speedup
	</td><td align="center"> % vectorisation speedup
</td></tr>
<tr><td> byte+
	</td><td align="center"> 423
	</td><td align="center"> 599
</td></tr>
<tr><td> byte +:
	</td><td align="center"> 1126
	</td><td align="center"> 1201
</td></tr>
<tr><td> int +
	</td><td align="center"> 75
	</td><td align="center"> 60
</td></tr>
<tr><td> short +
	</td><td align="center"> 332
	</td><td align="center"> 300
</td></tr>
<tr><td> real +
	</td><td align="center"> 62
	</td><td align="center"> 33
</td></tr>
<tr><td> pixel +
	</td><td align="center"> 814
	</td><td align="center"> 1496
</td></tr>
<tr><td> pixel *
	</td><td align="center"> 290
	</td><td align="center"> 698
</td></tr>
<tr><td> real dot product
	</td><td align="center"> 29
	</td><td align="center"> -3
</td></tr>
<tr><td> integer dot product
	</td><td align="center"> -4
	</td><td align="center"> 3
</td></tr></table>

<p>
Figures give the % speedup from using native code generators versus generic
486 code generators on a 450Mhz P3 and a 1Ghz Athlon.

<p>

<b>Performance on the Dhrystone Benchmark&nbsp;&nbsp;</b>

<p>
For an indicator of the performance of Vector Pascal on other instruction mixes,
the Dhrystone Pascal benchmark was used. This indicates that Vector Pascal is
substantially slower on such instruction mixes than Delphi but considerably
faster than Borland Pascal. All measurements were performed on a 1Ghz Athlon.
One reason why the Delphi compiler is so fast is its use of registers for parameter
passing in procedure calls.

<p>
<a name="tth_tAb5">
</a> <center>Table 5: Dhrystone performance</center>

<p>
<center> 
<table border="1">
<tr><td align="center">Compiler</td><td align="right">Dhrystones per sec</td><td align="right">Microseconds Per Dhrystone</td></tr><tr><td>
<tr><td align="center">Borland Pascal</td><td align="right">444444</td><td align="right">2.3</td></tr>
<tr><td align="center">Vector Pascal</td><td align="right">805282</td><td align="right">1.2</td></tr>
<tr><td align="center">TMT Pascal</td><td align="right">1123848</td><td align="right">0.9</td></tr>
<tr><td align="center">DevPascal</td><td align="right">1404494</td><td align="right">0.7</td></tr>
<tr><td align="center">Delphi</td><td align="right">2472187</td><td align="right">0.4</td></tr></table>

<p>
</center>
<p>
       <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Implementation</h2>

<p>
At the heart of our implementation is the machine independent Intermediate Language for
Code Generation (ILCG).  ILCG[<a href="#Cockshott00" name="CITECockshott00">8</a>] is strongly typed, supporting the base types
common in most programming languages along with type constructors for vectors,
stacks and references. In particular, operators may be
implicitly overloaded for vector operations. Its purpose is to act as an input
to an automatically constructed code generator, working on the syntax matching
principles described in [<a href="#graham80" name="CITEgraham80">11</a>]. Simple rules link high-level register
transfer descriptions with the equivalent low-level assembly representations.
ILCG may be used as a machine-oriented semantics of a high-level program or of
a CPU.  It may also be used as an intermediate language for program
transformation.

     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Analogous work</h3>
There has been sustained research within the parallel programming community
into the exploitation   of SIMD parallelism on multi-processor architectures.
Most work in this field has been driven by the needs of high-performance
scientific processing, from finite element analysis to meteorology. In
particular, there has been considerable interest in exploiting data parallelism
in FORTRAN array processing, culminating in High Performance Fortran and F.
Typically this involves two approaches. First of all, operators may be
overloaded to allow array-valued expressions, similar to APL. Secondly, loops
may be analysed to establish where it is possible to unroll loop bodies for
parallel evaluation. Compilers embodying these techniques tend to be
architecture specific to maximise performance and they have been aimed
primarily at specialised super-computer architectures, even though contemporary
general purpose microprocessors provide similar features, albeit on a far
smaller scale.

<p>
There has been recent interest in the application of vectorisation techniques
to instruction  level parallelism. Thus, Cheong and Lam [<a href="#Cheong97" name="CITECheong97">7</a>] discuss
the use of the Stanford University SUIF parallelising compiler to exploit  the
SUN VIS extensions for the UltraSparc from C programs. They report speedups of
around 4 on byte integer parallel addition. Krall and Lelait's compiler [<a href="#Krall00" name="CITEKrall00">21</a>]
 also exploits the VIS extensions on the Sun UltraSPARC processor from C
using the CoSy compiler framework. They compare classic vectorisation
techniques to  unrolling, concluding that both are equally effective, and
report speedups of 2.7 to 4.7. Sreraman and Govindarajan [<a href="#Sreraman00" name="CITESreraman00">28</a>] exploit
Intel MMX parallelism from C with SUIF, using a variety of vectorisation
techniques to generates inline assembly language,  achieving speedups from 2 to
6.5.   All of these groups target specific architectures. Finally, Leupers
[<a href="#Leupers99" name="CITELeupers99">23</a>] has reported a C compiler that uses vectorising optimisation
techniques for compiling code for the multimedia instruction sets of some
signal processors, but this is not generalised to the types of processors used
in desktop computers.

<p>
There has been extensive research, initiated by Graham and Glanville, into the
automatic production of code generators but predominantly for conventional
rather than parallel instruction sets.
There has also been research in the hardware/software co-design community into
compilation techniques for non-standard architectures. Leupers [<a href="#Leupers94" name="CITELeupers94">22</a>]
MIMOLA language allows the expression of both programs and structural hardware
descriptions, driving the micro-code compiler MSSQ. Hadjiyiannis'
[<a href="#Hadjiyiannis97" name="CITEHadjiyiannis97">12</a>] Instruction Set Description Language and Ramsey and
Davidson's [<a href="#Ramsey97" name="CITERamsey97">26</a>] Specification Language for Encoding and Decoding are
also aimed at embedded systems, based on low level architecture descriptions.It
is not clear whether MIMOLA, ISDL or SLED could readily be used for describing
data parallelism through operator overloading as found in MMX extensions.
Furthermore, ISDL and SLED's type systems will not readily express the vector
types required for MMX.

<p>
To exploit MMX and other extended instruction sets it is desirable to develop
compiler technology based on a richer meta-language which can express
non-standard instruction sets in a succinct but architecture
independent manner. Such a meta-language should support a rich set of types and
associated operators, and be amenable to formal manipulation. It should also
support a relatively high level of abstraction from different manufacturers'
register level implementations of what are effectively the same MMX operations.

<p>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Intermediate Language for Code Generation</h3>

<p>
A Vector Pascal program is translated into
an ILCG abstract semantic tree implemented as a Java datastructure. The tree is passed
to a machine generated Java class corresponding to the code generator for the
target machine. Code generator classes currently exist for the Intel 486, Pentium
with MMX, and P3 and also the AMD K6. Output is assembler code which is assembled
using the NASM assembler and linked using the gcc loader.

<p>
The code generators follow the pattern matching approach described in[<a href="#Aho" name="CITEAho">2</a>][<a href="#Cattel80" name="CITECattel80">5</a>]and
[<a href="#graham80" name="CITEgraham80">11</a>], and are automatically generated from machine specifications
written in ILCG . ILCG is a strongly
typed language which supports vector data types and the mapping of operators over vectors.
It is well suited to describing SIMD instruction sets. The code generator
classes export from their interfaces details about the degree of parallelism
supported for each data-type. This is used by the front end compiler to iterate
over arrays longer than those supported by the underlying machine. Where supported
parallelism is unitary, this defaults to iteration over the whole array.

<p>
Selection of target machines is by a compile time switch which causes the appropriate
code generator class to be dynamically loaded. 

<p>

<p>
<a name="tth_fIg7">
</a> 
<center><a href="system.eps">Figure</a>

<center>Figure 7: System Architecture</center>
</center>
<a name="fig:system">
</a>
<p>
 The structure of the  Vector Pascal
 system is shown in figure <a href="#fig:system">7.2</a>.
It is complex.

<p>
Consider first the path followed from a source file, the phases that it goes through are

<ul>
<br />i.  The source file (1) is parsed by a java class PascalCompiler.class (2) a   
hand written, recursive descent parser[<a href="#Watt" name="CITEWatt">32</a>], and results
in a Java data structure (3), an ILCG tree, which is basically a semantic
tree for the program. 
<br />ii.  The resulting tree is transformed (4) from sequential to parallel form
and  machine independent optimisations are performed.
Since ILCG trees
 are java objects, they can contain methods to self-optimise. Each class
contains for instance a method <tt>eval</tt> which attempts to evaluate a tree at
compile time. Another method <tt>simplify</tt> applies generic machine
independent transpormations to the code. Thus the <tt>simplify</tt>
method of the class <tt>For</tt> can perform loop unrolling,
removal of redundant loops etc. Other methods allow tree walkers
to apply context specific transformations.
<br />iii.  The resulting ilcg tree (7) is walked over by a class that encapsulates
the semantics of the target machine's instructionset (10); for example Pentium.class.
During code generation the tree is futher transformed, as machine
specific register optimisations are performed. 
The output of this process is an assembler file (11).
<br />iv.  This is then fed through an appropriate assembler and linker, assumed
to be externally provided to generate an executable program.</ul>

<p>
       <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Vectorisation</h3>

<p>
The parser initially generates serial code for all constructs.
It then interogates the current code generator class to determine
the degree of parallelism possible for the types of operations performed
in a loop, and if these are greater than one, it vectorises the code.

<p>
Given the declaration 

<p>
<b>var v1,v2,v3:array[1..9] of integer;</b>

<p>
then the statement

<p>
<b>v1:=v2+v3;</b>

<p>
would first be translated to the ILCG sequence shown in figure <a href="#seqf">8</a>

<p>
<a name="tth_fIg8">
</a> 
<pre>
{ var  i;
  for  i=1 to 9 step 1 do {
   v1[^i]:= +(^(v2[^i]),^(v3[^i]));
  };
}

</pre>

<center>Figure 8: Sequential form of array assignment</center><a name="seqf">
</a>

<p>
In the example above variable names such as <tt>v1</tt> and <tt>i</tt> have been used
for clarity. In reality <tt>i</tt> would be an addressing expression like:
<tt> (ref int32)mem(+(^((ref int32)ebp),     -1860))</tt>,
which encodes both the type and the address of the variable.
The code generator is queried as to the parallelism available on
the type <tt>int32</tt> and, since it is a Pentium with MMX, returns
2.
The loop is then split into two, a portion that can be executed in
parallel and a residual sequential component, resulting in the 
ILCG shown in figure <a href="#parf">9</a>.
<p>
<a name="tth_fIg9">
</a> 
<pre>
{ var i;  
   for i=    1 to     8 step     2 do {
    (ref int32 vector ( 2 ))mem(+(@v1,*(-(^i,1),4))):=
       +(^((ref int32 vector ( 2 ))mem(+(@v2,*(-(^i,1),4)))), 
         ^((ref int32 vector ( 2 ))mem(+(@v3,*(-(^i,1),4)))));
   };
   for i=    9 to     9 step     1 do {
      v1[^i]:= +(^(v2[^i]),^(v3[^i]));
   };
}

</pre>

<center>Figure 9: Parallelised loop</center><a name="parf">
</a>

<p>
In the parallel part of the code, the array subscriptions have been replaced
by explictly cast memory addresses. This coerces the locations from their
original types to the type required by the vectorisation.
Applying the <tt>simplify </tt> method of the For class  the
following generic transformations are performed:

<ol type="1"><p>
<li> The second loop is replaced by a single statement.</li>
<p>
<li> The parallel loop is unrolled twofold.</li>
<p>
<li> The For class is replaced by a sequence of statements with
explicit gotos.</li>
</ol>
The result is shown in figure <a href="#simpf">10</a>.
When the <tt>eval</tt> method is invoked, 
constant folding causes the loop test condition
to be evaluated  to <tt>if &#62;(^i,8) then	goto leb4af11b47f</tt>.

<p>
<a name="tth_fIg10">
</a> 
<pre>
{ var i:
  i:= 1;
  leb4af11b47e:
  if &#62;( 2, 0) then	if &#62;(^i,8) then	goto leb4af11b47f
	                else null
                        fi
	 else if &lt;(^i, 8) then	goto leb4af11b47f
	 else null
         fi
  fi;
 (ref int32 vector ( 2 ))mem(+(@v1,*(-(^i,1),4))):=
       +(^((ref int32 vector ( 2 ))mem(+(@v2,*(-(^i,1),4)))), 
         ^((ref int32 vector ( 2 ))mem(+(@v3,*(-(^i,1),4)))));
  i:=+(^i,2);
 (ref int32 vector ( 2 ))mem(+(@v1,*(-(^i,1),4))):=
       +(^((ref int32 vector ( 2 ))mem(+(@v2,*(-(^i,1),4)))), 
         ^((ref int32 vector ( 2 ))mem(+(@v3,*(-(^i,1),4)))));
  i:=+(^i,2);
  goto leb4af11b47e;
  leb4af11b47f:
  i:=    9;
  v1[^i]:= +(^(v2[^i]),^(v3[^i]));
}

</pre>

<center>Figure 10: After applying <tt>simplify</tt> to the tree</center>
<a name="simpf">
</a> 

<p>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Machine descriptions in ILCG</h3>
ILCG exists both as a tree language, defined as a set of
Java classes, and as a textual notation that can be used to describe the 
semantics of machine instructions.

<p>
 Pentium.class (10 in figure <a href="#fig:system">7.2</a>)  is produced from a file Pentium.ilc (8), 
in   ILCG, which gives a semantic
description of the Pentium's instructionset. This is processed
by a code generator generator which builds the source file Pentium.java.

<p>
A machine description typically consists of a set of register declarations
followed by a set of instruction formats and a set of operations.
This approach works well only with machines that have an orthogonal
instruction set, ie, those that allow addressing modes and operators
to be combined in an independent manner.

      <h4><a name="tth_sEc7.4.1">
7.4.1</a>&nbsp;&nbsp;Registers </h4>
When entering machine descriptions in ilcg registers can be declared
along with their type hence
<b>
<p>
register word EBX assembles['ebx'] ;

<p>
reserved register word ESP assembles['esp'];
 
<p>
</b>would declare <b>EBX</b> to be of type <b>ref word</b>.

<p>
      <h4><a name="tth_sEc7.4.2">
7.4.2</a>&nbsp;&nbsp;Aliasing</h4>
A register can be declared to be a sub-field of another register,
hence we could write 
<b>
<p>
 alias register octet AL = EAX(0:7) assembles['al']; 

<p>
 alias register octet BL = EBX(0:7) assembles['bl'];

<p>
</b>to indicate that <b>BL</b> occupies the bottom 8 bits of register <b>EBX</b>.
In this notation bit zero is taken to be the least significant bit of a value.
There are assumed to be two pregiven registers <b>FP, GP</b> that
are used by compilers to point to  areas of memory.
These can be aliased to a particular real register.<b>

<p>
register word EBP assembles['ebp'] ;

<p>
alias register word FP = EBP(0:31) assembles ['ebp'];

<p>
</b>Additional registers may be reserved, indicating that the code generator
must not use them to hold temporary values:

<p>
<b>reserved register word ESP assembles['esp'];
</b>
 
<p>
      <h4><a name="tth_sEc7.4.3">
7.4.3</a>&nbsp;&nbsp;Register sets</h4>
A set of registers that are used in the same way by the instructionset
can be defined.
<b>
<p>
pattern reg means [ EBP<font face="symbol">|</font
> EBX<font face="symbol">|</font
>ESI<font face="symbol">|</font
>EDI<font face="symbol">|</font
>ECX <font face="symbol">|</font
>EAX<font face="symbol">|</font
>EDX<font face="symbol">|</font
>ESP]  ;

<p>
pattern breg means[ AL<font face="symbol">|</font
>AH<font face="symbol">|</font
>BL<font face="symbol">|</font
>BH<font face="symbol">|</font
>CL<font face="symbol">|</font
>CH<font face="symbol">|</font
>DL<font face="symbol">|</font
>DH];
</b>

<p>
All registers in an register set should be of the same length.
 
<p>
      <h4><a name="tth_sEc7.4.4">
7.4.4</a>&nbsp;&nbsp;Register Stacks</h4>
Whilst some machines have registers organised as an array,
another class of machines, those oriented around postfix instructionsets,
have register stacks.

<p>
The ILCG syntax allows register stacks to be declared:

<p>
<b>register stack (8)ieee64 FP assembles[ ' '] ;

<p>
</b>Two access operations are supported on stacks:

<p>
<b>PUSH&nbsp;&nbsp;</b> is a void dyadic operator taking a stack of type ref t as first argument
and a value of  type t as the second argument. Thus we might have:
 <b>
<p>
PUSH(FP,<font face="symbol">­</font
>mem(20))
</b>

<p>

<b>POP&nbsp;&nbsp;</b> is a monadic operator returning t on stacks of type t. So we might have
<b>
<p>
mem(20):=POP(FP)
</b> 

     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Instruction formats</h3>

<p>
An instruction format is an abstraction over a class of concrete instructions.
It abstracts over particular operations
 and types thereof
whilst specifying how arguments can be combined.
<b>
<p>
instruction pattern 

<p>
RR( operator op, anyreg r1, anyreg r2, int t)

<p>
        means[r1:=(t) op( <font face="symbol">­</font
>((ref t) r1),<font face="symbol">­</font
>((ref t) r2))]    

<p>
	assembles[op ' ' r1 ',' r2];

<p>
</b>In the above example, we specify a register to register instruction format
that uses the first register as a source and a destination whilst the second
register is only a destination. The 
 result is returned in register r1.

<p>
We might however wish to have a more powerful abstraction, which was capable of
taking more abstract apecifications for its arguments. For example, many machines
allow arguments to instructions to be addressing modes that can be either
registers or memory references. For us to be able to specify this in an instruction
format we need to be able to provide grammer non-terminals as arguments
to the instruction formats.

<p>
For example we might want to be able to say

<p>
<b>instruction  pattern 

<p>
RRM(operator op, reg r1, maddrmode rm, int t)

<p>
        means [r1:=(t) op( <font face="symbol">­</font
>((ref t)r1),<font face="symbol">­</font
>((ref t) rm))]

<p>
        assembles[op ' ' r1 ',' rm ] ;</b>

<p>
This implies that addrmode and reg must be non terminals.
Since the non terminals required by different machines will vary, there
must be a means of declaring such non-terminals in ilcg.

<p>
An example would be:

<p>
<b>  pattern regindirf(reg r) 
	means[<font face="symbol">­</font
>(r) ]
	assembles[ r ];

<p>
pattern baseplusoffsetf(reg r, signed s) 
	means[+(  <font face="symbol">­</font
>(r) ,const s)]
	assembles[  r '+' s ];

<p>
pattern addrform means[baseplusoffsetf<font face="symbol">|</font
> regindirf];

<p>
 pattern maddrmode(addrform f) 
means[mem(f) ] assembles[ '[' f ']' ];

<p>
</b>This gives us a way of including non terminals as parameters to patterns.
Instruction patterns can also specify vector operations as in:
<b>
<p>
 instruction pattern PADDD(mreg m, mrmaddrmode ma)

<p>
	means[(ref int32 vector(2)m:=(int32 vector(2))+( (int32 vector(2))<font face="symbol">­</font
>(m),(int32 vector(2))<font face="symbol">­</font
>(ma)))]

<p>
	assembles ['paddd 'm ',' ma];

<p>
</b>Here vector casts are used to specify that the result register will
hold the type <b>int32 vector(2)</b>, and to constrain the types of the
arguments and results of the + operator.

     <h3><a name="tth_sEc7.6">
7.6</a>&nbsp;&nbsp;Instructionsets</h3>
At the end of an ILCG machine description file, the instructionset is defined.
This is given as an ordered list of instruction patterns.
When generating code the patterns are applied in the order in which
they are specified until a complete match of a statement has been achieved.
If a partial match fails the code generator backtracks and attempts the
next instruction. Care has to  be taken to place the most general
and
powerfull instructions first.
Figure <a href="#matchf">11</a> illustrates this showing the effect of
matching the parallelised loop shown in figure <a href="#simpf">10</a> against
the Pentium instruction set. Note that incrementing the loop
counter is performed using load effective address (lea) since
this, being more general, occurs before add in the instruction list.

<p>
This pattern matching with backtracking can potentially be slow, so the
code generator operates in learning mode. For each subtree that it has
sucessfully matched, it stores a string representation of the tree in
a hash table along with the instruction that matched it. When a tree has
to be matched, it checks the hash table to see if an equivalent tree has
already been recognised. In this way common idioms only have to be fully
analysed the first time that they are encountered.

<p>
<a name="tth_fIg11">
</a> 
<pre>
 mov DWORD ecx,     1
 leb4b08729615:
 cmp DWORD ecx,      8
 jg near  leb4b08729616
 lea edi,[  ecx-(     1)]; substituting in edi with 3 occurences and score of 1
 movq MM1, [  ebp+edi* 4+     -1620]
 paddd MM1, [  ebp+edi* 4+     -1640]
 movq  [  ebp+edi* 4+     -1600],MM1
 lea ecx,[  ecx+     2]
 lea edi,[  ecx-(     1)]; substituting in edi with 3 occurences and score of 1
 movq MM1, [  ebp+edi* 4+     -1620]
 paddd MM1, [  ebp+edi* 4+     -1640]
 movq  [  ebp+edi* 4+     -1600],MM1
 lea ecx,[  ecx+     2]
 jmp  leb4b08729615
 leb4b08729616:

</pre>

<center>Figure 11: The result of matching the parallelised loop against the Pentium
instruction set</center><a name="matchf">
</a>

<p>
       <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Conclusions</h2>

<p>
 Vector Pascal currently
runs under Windows98 , Windows2000 and Linux. Separate compilation using Turbo
Pascal style units is supported. C calling conventions  allow use of
existing libraries.
Work is underway to 
port the BLAS library to Vector Pascal, and to develop an IDE and literate programming
system for it.

<p>
Vector Pascal provides an effective approach to providing a programming environment
for multi-media instruction sets. It borrows abstraction mechanisms that have
a long history of sucessfull use in interpretive programming languages, combining
these with modern compiler techniques to target SIMD instruction sets. It provides
a uniform source language that can target multiple different processors without
the programmer having to think about the target machine. Use of Java as the
implementation language aids portability of the compiler accross operating systems.

<p>

<p>
<h2>References</h2>
<dl compact="compact">
<dt><a href="#CITEAMD" name="AMD">[1]</a></dt><dd>Advanced Micro Devices, 3DNow! Technology Manual, 1999. 
<dt><a href="#CITEAho" name="Aho">[2]</a></dt><dd>Aho, A.V., Ganapathi, M, TJiang S.W.K., Code Generation Using Tree Matching
and Dynamic Programming, ACM Trans, Programming Languages and Systems 11, no.4,
1989, pp.491-516. 
<dt><a href="#CITEblelloch" name="blelloch">[3]</a></dt><dd> Blelloch, G. E.,  Nesl: A Nested Data-Parallel Language, Carnegie Mellon University,
CMU-CS-95-170, Sept 1995.
<dt><a href="#CITEBurke" name="Burke">[4]</a></dt><dd>Burke, Chris, J User Manual, ISI, 1995.
<dt><a href="#CITECattel80" name="Cattel80">[5]</a></dt><dd>Cattell R. G. G., Automatic derivation of code generators from machine descriptions,
ACM Transactions on Programming Languages and Systems, 2(2), pp. 173-190, April
1980. 
<dt><a href="#CITEChaiten" name="Chaiten">[6]</a></dt><dd>Chaitin. G., Elegant Lisp Programs, in The Limits of Mathematics, pp. 29-56,
Springer, 1997.
<dt><a href="#CITECheong97" name="Cheong97">[7]</a></dt><dd>Cheong, G., and Lam, M., An Optimizer for Multimedia Instruction Sets, 2nd SUIF
Workshop, Stanford University, August 1997. 
<dt><a href="#CITECockshott00" name="Cockshott00">[8]</a></dt><dd>Cockshott, Paul, Direct Compilation of High Level Languages for Multi-media
Instruction-sets, Department of Computer Science, University of Glasgow, Nov
2000.
<dt><a href="#CITEEwing" name="Ewing">[9]</a></dt><dd> Ewing, A. K., Richardson, H., Simpson, A. D., Kulkarni, R., Writing Data Parallel
Programs with High Performance Fortran, Edinburgh Parallel Computing Centre, Ver 1.3.1.

<p>
<dt><a href="#CITEsable" name="sable">[10]</a></dt><dd>  Gagnon, E., SABLECC, AN OBJECT-ORIENTED
                     COMPILER FRAMEWORK,
                                   School of Computer Science
                                   McGill University, Montreal ,
                                          March 1998. 

<p>
<dt><a href="#CITEgraham80" name="graham80">[11]</a></dt><dd>Susan L. Graham, Table Driven Code Generation, IEEE Computer, Vol 13, No. 8,
August 1980, pp 25..37.
<dt><a href="#CITEHadjiyiannis97" name="Hadjiyiannis97">[12]</a></dt><dd> Hadjiyiannis, G., Hanono, S. and Devadas, S., ISDL: an
Instruction Set Description Language for Retargetability, DAC'97, ACM. 
<dt><a href="#CITEIA32 " name="IA32 ">[13]</a></dt><dd>Intel, Intel Architecture Software Developers Manual Volumes 1 and 2, 1999. 
<dt><a href="#CITEIntel00" name="Intel00">[14]</a></dt><dd>Intel, Willamette Processor Software Developer's Guide, February, 2000. 
<dt><a href="#CITEISO90" name="ISO90">[15]</a></dt><dd>ISO, Extended Pascal ISO 10206:1990, 1991.
<dt><a href="#CITEIverson62" name="Iverson62">[16]</a></dt><dd>Iverson K. E., A Programming Language, John Wiley &amp; Sons, Inc., New York (1962),
p. 16. 
<dt><a href="#CITEIversion80" name="Iversion80">[17]</a></dt><dd>Iverson, K. E. . Notation as a tool of thought. Communications of the ACM, 23(8),
444-465, 1980.
<dt><a href="#CITEJmanual" name="Jmanual">[18]</a></dt><dd>Iverson K. E, A personal View of APL, IBM Systems Journal, Vol 30, No 4, 1991. 
<dt><a href="#CITEJintro" name="Jintro">[19]</a></dt><dd>Iverson, Kenneth E., J Introduction and Dictionary, Iverson Software Inc. (ISI),
Toronto, Ontario, 1995.&nbsp;
<dt><a href="#CITEWirth" name="Wirth">[20]</a></dt><dd>Jensen K., and Wirth N., Pascal User Manual and Report, Springer, 1978.
<dt><a href="#CITEKrall00" name="Krall00">[21]</a></dt><dd>Krall, A., and Lelait, S., Compilation Techniques for Multimedia Processors,
International Journal of Parallel Programming, Vol. 28, No. 4, pp 347-361, 2000. 
<dt><a href="#CITELeupers94" name="Leupers94">[22]</a></dt><dd> Leupers, R., Niemmann, R. and Marwedel, P. Methods for
Retargetable DSP Code Generation, VLSI Signal Processing 94, IEEE.
<dt><a href="#CITELeupers99" name="Leupers99">[23]</a></dt><dd>Leupers, R., Compiler Optimization for Media Processors, EMMSEC 99/Sweden 1999. 
<dt><a href="#CITEMetcalf96" name="Metcalf96">[24]</a></dt><dd>Metcalf, M., and Reid., J., The F Programming Language, OUP, 1996. 
<dt><a href="#CITEPeleg97" name="Peleg97">[25]</a></dt><dd>Peleg, A., Wilke S., Weiser U., Intel MMX for Multimedia PCs, Comm. ACM, vol
40, no. 1 1997.

<p>
<dt><a href="#CITERamsey97" name="Ramsey97">[26]</a></dt><dd> Ramsey, N. and Fernandez, M., ACM Transactions on Programming
Languages and Systems, Vol. 19, No. 3, 1997, pp492-524.

<p>
<dt><a href="#CITEsetl" name="setl">[27]</a></dt><dd> 
Schwartz, J.T., Dewar, R.B.K., Dubinsky, E., and Schonberg, E., Programming with Sets: An Introduction to SETL (1986), Springer-Verlag, New York
<dt><a href="#CITESreraman00" name="Sreraman00">[28]</a></dt><dd>Srereman, N., and Govindarajan, G., A Vectorizing Compiler for Multimedia Extensions,
International Journal of Parallel Programming, Vol. 28, No. 4, pp 363-400, 2000.
<dt><a href="#CITETanenbaum" name="Tanenbaum">[29]</a></dt><dd> Tannenbaum, A. S., A Tutorial on  Algol 68, Computing Surveys, Vol. 8, No. 2, June 1976, p.155-190.
<dt><a href="#CITEmiranda" name="miranda">[30]</a></dt><dd> Turner, D., An overview of MIRANDA, SIGPLAN Notices, December 1986.

<p>
<dt><a href="#CITEvanderMeulen" name="vanderMeulen">[31]</a></dt><dd>van der Meulen, S. G., Algol 68 Might Have Beens, SIGPLAN notices Vol. 12, No. 6, 1977.
<dt><a href="#CITEWatt" name="Watt">[32]</a></dt><dd> Watt, D. A., and Brown, D. F., Programming Language Processors in Java, Prentice Hall, 2000.

<p>
 </dl><hr /><h3>Footnotes:</h3>

<p>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>We will give examples from J rather than APL here for ease of
representation in ASCII.
<p>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>This compilation strategy requires
that true is equivalent to -1 and false to 0.
This is typically the representation of booleans returned by vector
comparison instructions on SIMD instruction sets. In Vector Pascal this representation
is used generally and in consequence,
<b>true</b> &lt; <b>false</b>.
<p>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Note that
<b>trans</b> is not strictly speaking an operator, as there exists no Pascal type corresponding
to a column vector.
<p>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>The <b>record</b> construct.
<p>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>The <b>case</b>
construct in records.
<p>
<a name="tthFtNtAAG"></a><a href="#tthFrefAAG"><sup>6</sup></a>When pixels are represented as integers in the range 0..255, a 50% contrast reduction has to be
expressed as ((p<font face="symbol">-</font
>128) <font face="symbol">¸</font
>2)+128.
<p>
<a name="tthFtNtAAH"></a><a href="#tthFrefAAH"><sup>7</sup></a>Vector Pascal allows function results to be of any type.
<p>
<a name="tthFtNtAAI"></a><a href="#tthFrefAAI"><sup>8</sup></a>In addition to those
shown the tests were perfomed on PascalX, which failed either to compile or
to run the benchmarks. TMT Pascal failed to run the convolution test.
<p>
<a name="tthFtNtAAJ"></a><a href="#tthFrefAAJ"><sup>9</sup></a>version 4
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 2.78.<br />On 23 Jan 2002, 14:17.</small>
</html>
