#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout LyX-Code

unit ilcp;
\layout LyX-Code

(*! This contains the types used to represent ilcg internally in pascal
 *)
\layout LyX-Code

interface
\layout LyX-Code

uses rollbackbuffers;
\layout LyX-Code

(*! flags to encode formats *)
\layout LyX-Code

const foctet=0;
\layout LyX-Code

fhalfword=1;
\layout LyX-Code

fword=2;
\layout LyX-Code

fdword=3;
\layout LyX-Code

fqword=4;
\layout LyX-Code

fquadword=fqword;
\layout LyX-Code

fvoid=-1;
\layout LyX-Code

freal=16;
\layout LyX-Code

fvector=32;
\layout LyX-Code

fref=64;
\layout LyX-Code

fnotreal=128;
\layout LyX-Code

fsigned=8+fnotreal;
\layout LyX-Code

funsigned=fnotreal;
\layout LyX-Code

fint8=foctet+fsigned;
\layout LyX-Code

fuint8=foctet+funsigned;
\layout LyX-Code

fint16=fhalfword+fsigned;
\layout LyX-Code

fuint16=fhalfword+funsigned;
\layout LyX-Code

fint32=fword+fsigned;
\layout LyX-Code

fuint32=fword+funsigned;
\layout LyX-Code

fint64=fdword+fsigned;
\layout LyX-Code

fuint64=fdword+funsigned;
\layout LyX-Code

fdoubleword=fdword;
\layout LyX-Code

fieee32=fword+freal;
\layout LyX-Code

fieee64=fdword+freal;
\layout LyX-Code

fint=fint32;
\layout LyX-Code

fbool=fint;
\layout LyX-Code

fvecmult=256; { multiply vec length by this and pack into word }
\layout LyX-Code

maxalt=2000;
\layout LyX-Code

maxparam=12;
\layout LyX-Code

maxflag=32;
\layout LyX-Code

maxreg=255;
\layout LyX-Code

realLitSupported=1;
\layout LyX-Code

rollbacksize=2000000;
\layout LyX-Code

ilcptimes='*';
\layout LyX-Code

ilcpand='AND';
\layout LyX-Code

ilcpdivide='/';
\layout LyX-Code

ilcpextend='EXTEND';
\layout LyX-Code

ilcppop='POP';
\layout LyX-Code

ilcppush='PUSH';
\layout LyX-Code

ilcpnot='NOT';
\layout LyX-Code

ilcpor='OR';
\layout LyX-Code

ilcpplus='+';
\layout LyX-Code

ilcpmax='MAX';
\layout LyX-Code

ilcpmin='MIN';
\layout LyX-Code

ilcpminus='-';
\layout LyX-Code

ilcpremainder='MOD';
\layout LyX-Code

ilcpreplicate='rep';
\layout LyX-Code

ilcpcall='CALL';
\layout LyX-Code

ilcpsatplus='+:';
\layout LyX-Code

ilcpsatminus='-:';
\layout LyX-Code

ilcpsatmult='*:';
\layout LyX-Code

ilcpshl='<<';
\layout LyX-Code

ilcpshr='>>';
\layout LyX-Code

ilcplt='<';
\layout LyX-Code

ilcpgt='>';
\layout LyX-Code

ilcpleq='<=';
\layout LyX-Code

ilcpgeq='>=';
\layout LyX-Code

ilcpneq='<>';
\layout LyX-Code

ilcpSQRT='SQRT';
\layout LyX-Code

ilcpROUND='ROUND';
\layout LyX-Code

ilcpCOS='COS';
\layout LyX-Code

ilcpSIN='SIN';
\layout LyX-Code

ilcpLN='LN';
\layout LyX-Code

ilcpTAN='TAN';
\layout LyX-Code

ilcpABS='ABS';
\layout LyX-Code

ilcpFLOAT='FLOAT';
\layout LyX-Code

ilcpeq='=';
\layout LyX-Code

ilcprep='REP';
\layout LyX-Code

recmax=80;
\layout LyX-Code

constfoldingon:boolean=true;
\layout LyX-Code

type pilcgnode=^ilcgnode;
\layout LyX-Code

formatcode=integer;
\layout LyX-Code

regbytecode= 0..255;
\layout LyX-Code

reservationcode=set of regbytecode;
\layout LyX-Code

instructionsetindex=0..1023;
\layout LyX-Code

(*! lists the possible types of ilcg node *)
\layout LyX-Code

nodeclass=(deref,
\layout LyX-Code

arraysubscript,
\layout LyX-Code

reallit,
\layout LyX-Code

intlit,
\layout LyX-Code

format,
\layout LyX-Code

regstack,
\layout LyX-Code

unboundformat, { this will match any format }
\layout LyX-Code

ref,
\layout LyX-Code

gotonode,
\layout LyX-Code

patterntag,
\layout LyX-Code

failure, { represents an interrupt exception }
\layout LyX-Code

typevar, { matches any type in a pattern }
\layout LyX-Code

Assignop,
\layout LyX-Code

forloop,
\layout LyX-Code

memref,
\layout LyX-Code

dyadicop,
\layout LyX-Code

ifnode,
\layout LyX-Code

sequence,
\layout LyX-Code

alternation,
\layout LyX-Code

monad,
\layout LyX-Code

monop,
\layout LyX-Code

dyad,
\layout LyX-Code

typecast,
\layout LyX-Code

constant,
\layout LyX-Code

param,
\layout LyX-Code

reg,
\layout LyX-Code

location,
\layout LyX-Code

labelnode);
\layout LyX-Code

(*! representation of reals within the compiler *)
\layout LyX-Code

intreal = double;
\layout LyX-Code

intint = int64;
\layout LyX-Code

ppattern = ^pattern;
\layout LyX-Code

registerstack=record
\layout LyX-Code

format:formatcode;
\layout LyX-Code

depth:integer;
\layout LyX-Code

printsas:string[40];
\layout LyX-Code

end;
\layout LyX-Code

(*! An ilcg node is a record with a tag field to discriminate type *)
\layout LyX-Code

ilcgnode= record
\layout LyX-Code

simple:boolean; { true if already simplified }
\layout LyX-Code

case tag:nodeclass of
\layout LyX-Code

patterntag:(pat:ppattern;);
\layout LyX-Code

deref,
\layout LyX-Code

ref,
\layout LyX-Code

constant,
\layout LyX-Code

monad,
\layout LyX-Code

dyad,
\layout LyX-Code

memref,
\layout LyX-Code

typecast,
\layout LyX-Code

failure:(arg,fn,arg2:pilcgnode;);
\layout LyX-Code

location:(locvalue:pilcgnode;);
\layout LyX-Code

regstack:(stackdetails:registerstack;);
\layout LyX-Code

arraysubscript:( base, { base address }
\layout LyX-Code

offset:pilcgnode; { i,th element }
\layout LyX-Code

{ step calculated from format}
\layout LyX-Code

elementformat:integer);
\layout LyX-Code

Assignop,
\layout LyX-Code

gotonode:(src,dest:pilcgnode;);
\layout LyX-Code

alternation:(first,last:integer);
\layout LyX-Code

intlit,
\layout LyX-Code

reallit:( reallitarg:intreal;
\layout LyX-Code

intlitarg:intint;
\layout LyX-Code

litformat:integer);
\layout LyX-Code

ifnode:( condition,
\layout LyX-Code

action,
\layout LyX-Code

alternative:pilcgnode;);
\layout LyX-Code

unboundformat,
\layout LyX-Code

format:(formatarg:integer);
\layout LyX-Code

monop,
\layout LyX-Code

dyadicop:(opname:string[15];);
\layout LyX-Code

labelnode,
\layout LyX-Code

param,
\layout LyX-Code

reg:(index:integer;);
\layout LyX-Code

sequence:(current,next:pilcgnode;);
\layout LyX-Code

forloop:( indexvar,
\layout LyX-Code

start,
\layout LyX-Code

stop,
\layout LyX-Code

incr,
\layout LyX-Code

loopaction:pilcgnode);
\layout LyX-Code

end;
\layout LyX-Code

register= record
\layout LyX-Code

format:formatcode;
\layout LyX-Code

permanentlyreserved:boolean;
\layout LyX-Code

printsas:string[15];
\layout LyX-Code

code:integer;
\layout LyX-Code

basecode:reservationcode;
\layout LyX-Code

end;
\layout LyX-Code

pprintlist = ^ printnode;
\layout LyX-Code

patternindex = ppattern;
\layout LyX-Code

paramnode =ppattern;
\layout LyX-Code

paramref=0..maxparam;
\layout LyX-Code

paramlist=array[paramref] of paramnode;
\layout LyX-Code

pparamlist = ^ paramlist;
\layout LyX-Code

printsort = (printchar,printparam);
\layout LyX-Code

printnode = record
\layout LyX-Code

next:pprintlist;
\layout LyX-Code

case literal:printsort of
\layout LyX-Code

printchar:(litval:char;);
\layout LyX-Code

printparam:(index:paramref);
\layout LyX-Code

end;
\layout LyX-Code

pattern = record
\layout LyX-Code

meaning:pilcgnode;
\layout LyX-Code

matchedassembler:pprintlist;
\layout LyX-Code

params:pparamlist;
\layout LyX-Code

paramcount:integer;
\layout LyX-Code

end;
\layout LyX-Code

nodevisitor=procedure(var p:pilcgnode);
\layout LyX-Code

var
\layout LyX-Code

registers:array[0..maxreg] of register ;
\layout LyX-Code

reservations:reservationcode;
\layout LyX-Code

{ flags are integers passed through from the
\layout LyX-Code

ilcg source that can be used to guide compilation }
\layout LyX-Code

flags:array[0..maxflag] of integer;
\layout LyX-Code

{ controls if debug info sent to output }
\layout LyX-Code

verbose:boolean;
\layout LyX-Code

{ predefined patterns }
\layout LyX-Code

pattype_, patlabel_,
\layout LyX-Code

patlabel:ppattern;
\layout LyX-Code

fp,sp:integer; { holds the register numbers }
\layout LyX-Code

(*! alternatives are filled in by machine generated code generator
\layout LyX-Code

it holds a list of alternative patterns in the order they
\layout LyX-Code

must be matched.
\layout LyX-Code

*)
\layout LyX-Code

alternatives:array[0..maxalt] of ppattern;
\layout LyX-Code

instructionsetorder:array[instructionsetindex] of patternindex;
\layout LyX-Code

lastinstruction, { the last valid entry in the instructionsetorder}
\layout LyX-Code

LASTREG,
\layout LyX-Code

lastalt:integer;{ the last valid entry in alternatives }
\layout LyX-Code

{ functions called by the machine generated code }
\layout LyX-Code

function buildparamref(i:integer):pilcgnode;
\layout LyX-Code

function typeparam:ppattern;
\layout LyX-Code

function string2printlist(s:String ):pprintlist;
\layout LyX-Code

procedure pappendp(var l:pprintlist; i:integer);
\layout LyX-Code

procedure pappends(var l:pprintlist; s:string);
\layout LyX-Code

{------------------------------------------------------------------}
\layout LyX-Code

{ below here are the user api functions of ilcp }
\layout LyX-Code

{ prints an ilcg node tree }
\layout LyX-Code

procedure printtree(n:Pilcgnode; var f:text);
\layout LyX-Code

{ print the assembler spec of a pattern }
\layout LyX-Code

procedure printassmspec(p:pprintlist;var f:text);
\layout LyX-Code

(*! Constructors for ilcp nodes *)
\layout LyX-Code

function new_arraysubscript(baseaddr,index:pilcgnode;form:integer):pilcgnode;
\layout LyX-Code

function new_assign(dest,src:pilcgnode):pilcgnode;
\layout LyX-Code

function new_deref(loc:pilcgnode):pilcgnode;
\layout LyX-Code

function new_dyad(left:pilcgnode;op:string;right:pilcgnode):pilcgnode;
\layout LyX-Code

function new_monad(op:string;right:pilcgnode):pilcgnode;
\layout LyX-Code

function new_for( indexvar,
\layout LyX-Code

start,
\layout LyX-Code

stop,
\layout LyX-Code

incr,
\layout LyX-Code

loopaction:pilcgnode):pilcgnode;
\layout LyX-Code

function new_format(form:integer):pilcgnode;
\layout LyX-Code

function new_goto(dest:pilcgnode):pilcgnode;
\layout LyX-Code

function new_if(condition,thenpart,elsepart:pilcgnode):pilcgnode;
\layout LyX-Code

function new_intlit(i:intint;intformat:integer):pilcgnode;
\layout LyX-Code

function new_label:pilcgnode;
\layout LyX-Code

function new_memref(dest:pilcgnode;form:integer):pilcgnode;
\layout LyX-Code

function new_reallit(i:intreal;rformat:integer):pilcgnode;
\layout LyX-Code

function new_register(regindex:integer):pilcgnode;
\layout LyX-Code

function new_seq(hd,tl:pilcgnode):pilcgnode;
\layout LyX-Code

function new_typecast(format:integer; exp:pilcgnode):pilcgnode;
\layout LyX-Code

(*! Codegen
\layout LyX-Code

This outputs assembler for the tree pointed to
\layout LyX-Code

by n to the file assemblerfile
\layout LyX-Code

*)
\layout LyX-Code

function codegen(n:pilcgnode; var assemblerfile:text):boolean;
\layout LyX-Code

{ perform depth first traversal of tree p
\layout LyX-Code

calling visitor on all nodes.
 This may
\layout LyX-Code

change the original tree }
\layout LyX-Code

procedure visit(var p:pilcgnode;visitor:nodevisitor);
\layout LyX-Code

{ returns the format code of the return type of an expression }
\layout LyX-Code

function getformat(n:pilcgnode):integer;
\layout LyX-Code

{ uses a format code to obtaing the length in bytes of the object }
\layout LyX-Code

function lengthinbytes(format:integer):integer;
\layout LyX-Code

{ create a vector type descriptor }
\layout LyX-Code

function vectorof(basetype, length:integer):integer;
\layout LyX-Code

{ masks out all vector information from a type }
\layout LyX-Code

function getbaseformat(f:integer):integer;
\layout LyX-Code

{ replace all occurences of A with B in the tree C
\layout LyX-Code

return a complete new copy of the tree
\layout LyX-Code

}
\layout LyX-Code

Function substituteAwithBinC(A,B:pilcgnode;C:pilcgnode):pilcgnode;
\layout LyX-Code

{ perform basic simplification of an ilcg tree }
\layout LyX-Code

function simplify(n:pilcgnode):pilcgnode;
\layout LyX-Code

{ remove one level of cast from n }
\layout LyX-Code

function decast(n:pilcgnode):pilcgnode;
\layout LyX-Code

{ true if the general format includes the specific one }
\layout LyX-Code

function formatincludes(general,specific:integer):boolean;
\layout LyX-Code

(*! Functions to manipulate register reservation *)
\layout LyX-Code

function reserved(r:integer):boolean;
\layout LyX-Code

(*! true if register r is reserved *)
\layout LyX-Code

procedure reserve(r:integer);
\layout LyX-Code

(*! add register r to the reservation set *)
\layout LyX-Code

procedure unreserve(r:integer);
\layout LyX-Code

implementation
\layout LyX-Code

type
\layout LyX-Code

checkpoint = record
\layout LyX-Code

mark:integer;
\layout LyX-Code

reserved:reservationcode;
\layout LyX-Code

end;
\layout LyX-Code

pilcglist=^ilcglist;
\layout LyX-Code

ilcglist=record
\layout LyX-Code

head:pilcgnode;
\layout LyX-Code

tail:pilcglist;
\layout LyX-Code

end;
\layout LyX-Code

var bitbucket:string ; { this string is used to dispose of matches we }
\layout LyX-Code

{ do not need to record }
\layout LyX-Code

labcount:integer;
\layout LyX-Code

recursiondepth:integer;
\layout LyX-Code

alternativesBeingTried:array[0..maxalt]of pilcgnode;
\layout LyX-Code

function binarymatch(src,template:pilcgnode):boolean;
\layout LyX-Code

forward;
\layout LyX-Code

function cons(p:pilcgnode;l:pilcglist):pilcglist;
\layout LyX-Code

var t:pilcglist;
\layout LyX-Code

begin
\layout LyX-Code

new(t);
\layout LyX-Code

t^.head:=p;t^.tail:=l;
\layout LyX-Code

cons:=t;
\layout LyX-Code

end;
\layout LyX-Code

procedure freelist(n:pilcglist);
\layout LyX-Code

begin
\layout LyX-Code

if n <> nil
\layout LyX-Code

then begin
\layout LyX-Code

freelist(n^.tail);
\layout LyX-Code

dispose(n);
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

function inlist(l:pilcglist;n:pilcgnode):boolean;
\layout LyX-Code

begin
\layout LyX-Code

if l=nil
\layout LyX-Code

then inlist:=false
\layout LyX-Code

else if binarymatch(l^.head,n)
\layout LyX-Code

then inlist:=true
\layout LyX-Code

else inlist:= inlist(l^.tail,n)
\layout LyX-Code

end;
\layout LyX-Code

procedure addtoset(var l:pilcglist;n:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if not inlist(l,n)
\layout LyX-Code

then l:=cons(n,l)
\layout LyX-Code

end;
\layout LyX-Code

{----------------------------------------------------------}
\layout LyX-Code

{ Tree visiting utilities }
\layout LyX-Code

{----------------------------------------------------------}
\layout LyX-Code

procedure visit(var p:pilcgnode;visitor:nodevisitor);
\layout LyX-Code

begin
\layout LyX-Code

if p<> nil then
\layout LyX-Code

with p^ do
\layout LyX-Code

case tag of
\layout LyX-Code

monop,
\layout LyX-Code

labelnode,
\layout LyX-Code

dyadicop,
\layout LyX-Code

alternation,
\layout LyX-Code

intlit,
\layout LyX-Code

reallit,
\layout LyX-Code

regstack,
\layout LyX-Code

patterntag,
\layout LyX-Code

reg,
\layout LyX-Code

format,
\layout LyX-Code

param: { no subnodes }
\layout LyX-Code

begin { do nothing}
\layout LyX-Code

end;
\layout LyX-Code

monad: begin
\layout LyX-Code

visit(fn,visitor);
\layout LyX-Code

visit(arg,visitor);
\layout LyX-Code

end;
\layout LyX-Code

constant,
\layout LyX-Code

ref,
\layout LyX-Code

memref,
\layout LyX-Code

deref: visit(arg,visitor);
\layout LyX-Code

gotonode: visit(dest,visitor);
\layout LyX-Code

dyad: begin
\layout LyX-Code

visit(arg,visitor);
\layout LyX-Code

visit(fn,visitor);
\layout LyX-Code

visit(arg2,visitor);
\layout LyX-Code

end;
\layout LyX-Code

location: visit(locvalue,visitor);
\layout LyX-Code

typecast: begin
\layout LyX-Code

visit(arg,visitor);
\layout LyX-Code

visit(arg2,visitor);
\layout LyX-Code

end;
\layout LyX-Code

arraysubscript: begin
\layout LyX-Code

visit(base,visitor);
\layout LyX-Code

visit(offset,visitor);
\layout LyX-Code

end;
\layout LyX-Code

assignop:begin
\layout LyX-Code

visit(dest,visitor);
\layout LyX-Code

visit(src,visitor);
\layout LyX-Code

end ;
\layout LyX-Code

sequence:begin
\layout LyX-Code

visit(current,visitor);
\layout LyX-Code

visit(next,visitor);
\layout LyX-Code

end;
\layout LyX-Code

forloop:begin visit(indexvar,visitor);
\layout LyX-Code

visit(start,visitor);
\layout LyX-Code

visit(stop,visitor);
\layout LyX-Code

visit(incr,visitor);
\layout LyX-Code

visit(loopaction,visitor);
\layout LyX-Code

end;
\layout LyX-Code

ifnode:begin
\layout LyX-Code

visit(condition,visitor);
\layout LyX-Code

visit(action,visitor);
\layout LyX-Code

visit(alternative,visitor);
\layout LyX-Code

end;
\layout LyX-Code

else write( ' visit unknown node type tag ',ord(tag));
\layout LyX-Code

end;
\layout LyX-Code

visitor(p);
\layout LyX-Code

end;
\layout LyX-Code

type prenodevisitor=function (var p:pilcgnode):boolean;
\layout LyX-Code

{ previsit will only visit the subsidiary nodes if
\layout LyX-Code

the prenodevisitor function returns true }
\layout LyX-Code

procedure previsit(var p:pilcgnode;visitor:prenodevisitor);
\layout LyX-Code

procedure visit(var p:pilcgnode;visitor:prenodevisitor);
\layout LyX-Code

begin
\layout LyX-Code

if p<> nil then
\layout LyX-Code

if visitor(p )
\layout LyX-Code

then
\layout LyX-Code

with p^ do
\layout LyX-Code

case tag of
\layout LyX-Code

monop,
\layout LyX-Code

labelnode,
\layout LyX-Code

dyadicop,
\layout LyX-Code

alternation,
\layout LyX-Code

intlit,
\layout LyX-Code

reallit,
\layout LyX-Code

regstack,
\layout LyX-Code

patterntag,
\layout LyX-Code

reg,
\layout LyX-Code

format,
\layout LyX-Code

param: { no subnodes }
\layout LyX-Code

begin { do nothing}
\layout LyX-Code

end;
\layout LyX-Code

monad: begin
\layout LyX-Code

visit(fn,visitor);
\layout LyX-Code

visit(arg,visitor);
\layout LyX-Code

end;
\layout LyX-Code

constant,
\layout LyX-Code

ref,
\layout LyX-Code

memref,
\layout LyX-Code

deref: visit(arg,visitor);
\layout LyX-Code

gotonode: visit(dest,visitor);
\layout LyX-Code

dyad: begin
\layout LyX-Code

visit(arg,visitor);
\layout LyX-Code

visit(fn,visitor);
\layout LyX-Code

visit(arg2,visitor);
\layout LyX-Code

end;
\layout LyX-Code

location: visit(locvalue,visitor);
\layout LyX-Code

forloop:begin visit(indexvar,visitor);
\layout LyX-Code

visit(start,visitor);
\layout LyX-Code

visit(stop,visitor);
\layout LyX-Code

visit(incr,visitor);
\layout LyX-Code

visit(loopaction,visitor);
\layout LyX-Code

end;
\layout LyX-Code

typecast: begin
\layout LyX-Code

visit(arg,visitor);
\layout LyX-Code

visit(arg2,visitor);
\layout LyX-Code

end;
\layout LyX-Code

arraysubscript: begin
\layout LyX-Code

visit(base,visitor);
\layout LyX-Code

visit(offset,visitor);
\layout LyX-Code

end;
\layout LyX-Code

assignop:begin
\layout LyX-Code

visit(dest,visitor);
\layout LyX-Code

visit(src,visitor);
\layout LyX-Code

end ;
\layout LyX-Code

sequence:begin
\layout LyX-Code

visit(current,visitor);
\layout LyX-Code

visit(next,visitor);
\layout LyX-Code

end;
\layout LyX-Code

ifnode:begin
\layout LyX-Code

visit(condition,visitor);
\layout LyX-Code

visit(action,visitor);
\layout LyX-Code

visit(alternative,visitor);
\layout LyX-Code

end;
\layout LyX-Code

else write( ' visit unknown node type tag ',ord(tag));
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

begin
\layout LyX-Code

visit(p,visitor);
\layout LyX-Code

end;
\layout LyX-Code

{ produce a modified copy of the tree p under
\layout LyX-Code

the filter provided by node visitor.
\layout LyX-Code

the original is unchanged.
\layout LyX-Code

At the end, p points to a new tree
\layout LyX-Code

}
\layout LyX-Code

procedure modify(var p:pilcgnode;visitor:nodevisitor);
\layout LyX-Code

var q:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if p<> nil then begin
\layout LyX-Code

new (q);
\layout LyX-Code

q^:=p^;
\layout LyX-Code

p:=q;
\layout LyX-Code

with p^ do
\layout LyX-Code

case tag of
\layout LyX-Code

monop,
\layout LyX-Code

labelnode,
\layout LyX-Code

dyadicop,
\layout LyX-Code

alternation,
\layout LyX-Code

intlit,
\layout LyX-Code

reallit,
\layout LyX-Code

regstack,
\layout LyX-Code

patterntag,
\layout LyX-Code

reg,
\layout LyX-Code

format,
\layout LyX-Code

param: { no subnodes }
\layout LyX-Code

begin { do nothing}
\layout LyX-Code

end;
\layout LyX-Code

monad: begin
\layout LyX-Code

modify(fn,visitor);
\layout LyX-Code

modify(arg,visitor);
\layout LyX-Code

end;
\layout LyX-Code

constant,
\layout LyX-Code

ref,
\layout LyX-Code

memref,
\layout LyX-Code

deref: modify(arg,visitor);
\layout LyX-Code

forloop:begin modify(indexvar,visitor);
\layout LyX-Code

modify(start,visitor);
\layout LyX-Code

modify(stop,visitor);
\layout LyX-Code

modify(incr,visitor);
\layout LyX-Code

modify(loopaction,visitor);
\layout LyX-Code

end;
\layout LyX-Code

arraysubscript: begin
\layout LyX-Code

modify(base,visitor);
\layout LyX-Code

modify(offset,visitor);
\layout LyX-Code

end;
\layout LyX-Code

gotonode: modify(dest,visitor);
\layout LyX-Code

dyad: begin
\layout LyX-Code

modify(arg,visitor);
\layout LyX-Code

modify(fn,visitor);
\layout LyX-Code

modify(arg2,visitor);
\layout LyX-Code

end;
\layout LyX-Code

location: modify(locvalue,visitor);
\layout LyX-Code

typecast: begin
\layout LyX-Code

modify(arg,visitor);
\layout LyX-Code

modify(arg2,visitor);
\layout LyX-Code

end;
\layout LyX-Code

assignop:begin
\layout LyX-Code

modify(dest,visitor);
\layout LyX-Code

modify(src,visitor);
\layout LyX-Code

end ;
\layout LyX-Code

sequence:begin
\layout LyX-Code

modify(current,visitor);
\layout LyX-Code

modify(next,visitor);
\layout LyX-Code

end;
\layout LyX-Code

ifnode:begin
\layout LyX-Code

modify(condition,visitor);
\layout LyX-Code

modify(action,visitor);
\layout LyX-Code

modify(alternative,visitor);
\layout LyX-Code

end;
\layout LyX-Code

else write( ' modify unknown node type tag ',ord(tag));
\layout LyX-Code

end;
\layout LyX-Code

visitor(p);
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

procedure nullmodifier(var p:pilcgnode);begin end;
\layout LyX-Code

{make an exact copy of a node }
\layout LyX-Code

function clone(p:pilcgnode):pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

modify(p,nullmodifier);
\layout LyX-Code

clone:=p;
\layout LyX-Code

end;
\layout LyX-Code

{ replace an array subscription with a memref }
\layout LyX-Code

procedure subscript2memref( var p:pilcgnode);
\layout LyX-Code

var t:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if (p ^.tag = arraysubscript)
\layout LyX-Code

then
\layout LyX-Code

begin
\layout LyX-Code

t:=new_memref(
\layout LyX-Code

new_dyad( p^.base,
\layout LyX-Code

ilcpplus,
\layout LyX-Code

new_dyad(p^.offset,
\layout LyX-Code

ilcptimes,
\layout LyX-Code

new_intlit(
\layout LyX-Code

lengthinbytes(p^.elementformat),
\layout LyX-Code

fint))),
\layout LyX-Code

p^.elementformat);
\layout LyX-Code

p:=t;
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

procedure replacesubscripts(var p:pilcgnode);
\layout LyX-Code

begin visit(p,subscript2memref) end;
\layout LyX-Code

{-------------------------------------------------------}
\layout LyX-Code

{ Vectorisation section of codegen }
\layout LyX-Code

{-------------------------------------------------------}
\layout LyX-Code

var assignmentcount:integer;
\layout LyX-Code

assigntype:integer;
\layout LyX-Code

procedure assignfinder(var p:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if p<>nil
\layout LyX-Code

then if p^.tag=assignop
\layout LyX-Code

then begin
\layout LyX-Code

assignmentcount:=assignmentcount+1;
\layout LyX-Code

assigntype:=getformat(p^.src);
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

function getparallelism(n:pilcgnode):integer;
\layout LyX-Code

var i,k,j,f:integer;
\layout LyX-Code

begin
\layout LyX-Code

k:=1;
\layout LyX-Code

assignmentcount:=0;
\layout LyX-Code

visit(n,assignfinder);
\layout LyX-Code

for i:=0 to lastreg do
\layout LyX-Code

begin
\layout LyX-Code

f:=getbaseformat(registers[i].format);
\layout LyX-Code

if (f and not fref)=assigntype
\layout LyX-Code

then begin
\layout LyX-Code

j:=(registers[i].format) div fvecmult;
\layout LyX-Code

if j>k
\layout LyX-Code

then k:=j;
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

getparallelism:=k;
\layout LyX-Code

end;
\layout LyX-Code

var callcount:integer;
\layout LyX-Code

procedure callfinder(var p:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if p<>nil
\layout LyX-Code

then if p^.tag=dyadicop
\layout LyX-Code

then if p^.opname=ilcpcall
\layout LyX-Code

then callcount:=callcount+1;
\layout LyX-Code

end;
\layout LyX-Code

var forcount,gotocount:integer;
\layout LyX-Code

procedure forfinder(var p:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if p<>nil
\layout LyX-Code

then if p^.tag=forloop
\layout LyX-Code

then forcount:=forcount+1;
\layout LyX-Code

if p<>nil
\layout LyX-Code

then if p^.tag=gotonode
\layout LyX-Code

then gotocount:=gotocount+1;
\layout LyX-Code

end;
\layout LyX-Code

{ count the procedure calls in a tree }
\layout LyX-Code

function callsin(p:pilcgnode):integer;
\layout LyX-Code

begin
\layout LyX-Code

callcount:=0;
\layout LyX-Code

visit(p,callfinder);
\layout LyX-Code

callsin:=callcount;
\layout LyX-Code

end;
\layout LyX-Code

{ count the procedure calls in a tree }
\layout LyX-Code

function forsin(p:pilcgnode):integer;
\layout LyX-Code

begin
\layout LyX-Code

forcount:=0;
\layout LyX-Code

visit(p,forfinder);
\layout LyX-Code

forsin:=forcount;
\layout LyX-Code

end;
\layout LyX-Code

function innerloop(p:pilcgnode):boolean ;
\layout LyX-Code

begin
\layout LyX-Code

gotocount:=0;
\layout LyX-Code

if (forsin(p) = 1)
\layout LyX-Code

and
\layout LyX-Code

(callsin(p) = 0)
\layout LyX-Code

then innerloop:=gotocount=0
\layout LyX-Code

else innerloop:=false
\layout LyX-Code

end;
\layout LyX-Code

{ count the assignments calls in a tree }
\layout LyX-Code

function assignsin(p:pilcgnode):integer;
\layout LyX-Code

begin
\layout LyX-Code

assignmentcount:=0;
\layout LyX-Code

visit(p,assignfinder);
\layout LyX-Code

assignsin:=assignmentcount;
\layout LyX-Code

end;
\layout LyX-Code

var currentindexvar:pilcgnode;
\layout LyX-Code

offsetsaresimple:boolean;
\layout LyX-Code

{ This checks if the index of an array is
\layout LyX-Code

a deref of the curren index var }
\layout LyX-Code

procedure simpleindexcheck(var p:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if p<> nil
\layout LyX-Code

then
\layout LyX-Code

if p^.tag=arraysubscript
\layout LyX-Code

then begin
\layout LyX-Code

if p^.offset^.tag <> deref
\layout LyX-Code

then offsetsaresimple:=false
\layout LyX-Code

else
\layout LyX-Code

if not binarymatch(p^.offset^.arg,currentindexvar)
\layout LyX-Code

then offsetsaresimple:=false
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

{ returns true if all offsets to arrays in loop
\layout LyX-Code

are indexeded by I }
\layout LyX-Code

function allOffsetsInLareI(L,I:pilcgnode):boolean;
\layout LyX-Code

begin
\layout LyX-Code

offsetsaresimple:=true;
\layout LyX-Code

currentindexvar:=I;
\layout LyX-Code

visit(L,simpleindexcheck);
\layout LyX-Code

allOffsetsInLareI:=offsetsaresimple;
\layout LyX-Code

end;
\layout LyX-Code

var nonarrayassignmentcount:integer;
\layout LyX-Code

procedure countnonarrayassignments(var p:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if p<>nil
\layout LyX-Code

then if p^.tag=assignop
\layout LyX-Code

then
\layout LyX-Code

if decast(p^.dest)^.tag<> arraysubscript
\layout LyX-Code

then nonarrayassignmentcount:=
\layout LyX-Code

nonarrayassignmentcount+1;
\layout LyX-Code

end;
\layout LyX-Code

var isolatedindexcount:integer;
\layout LyX-Code

function checkisolatedindices(var p:pilcgnode):boolean;
\layout LyX-Code

{ this is a prenode visitor so it returns true if
\layout LyX-Code

the node is to be further searched }
\layout LyX-Code

begin
\layout LyX-Code

if binarymatch(p,currentindexvar)
\layout LyX-Code

then isolatedindexcount:=isolatedindexcount+1;
\layout LyX-Code

if p=nil
\layout LyX-Code

then checkisolatedindices:=false
\layout LyX-Code

else
\layout LyX-Code

case p^.tag of
\layout LyX-Code

memref,
\layout LyX-Code

arraysubscript:checkisolatedindices:=false;
\layout LyX-Code

else checkisolatedindices:=true;
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

{ check if we have any occurences of the index var that are
\layout LyX-Code

not part of array subscripts }
\layout LyX-Code

function IndexOccursInNonArrayExpression(indexvar,oldbody:pilcgnode):boolean;
\layout LyX-Code

begin
\layout LyX-Code

currentindexvar:=indexvar;
\layout LyX-Code

isolatedindexcount:=0;
\layout LyX-Code

previsit(oldbody,checkisolatedindices);
\layout LyX-Code

IndexOccursInNonArrayExpression:= isolatedindexcount>0;
\layout LyX-Code

end;
\layout LyX-Code

{ call with loop pointing at a for loop
\layout LyX-Code

return true if safe to vectorise loop
\layout LyX-Code

}
\layout LyX-Code

function vectorisable(loop:pilcgnode):boolean;
\layout LyX-Code

function anyNonArrayAssignments:boolean;
\layout LyX-Code

begin
\layout LyX-Code

nonarrayassignmentcount:=0;
\layout LyX-Code

visit(loop,countnonarrayassignments);
\layout LyX-Code

anyNonArrayAssignments:= nonArrayAssignmentCount>0
\layout LyX-Code

end;
\layout LyX-Code

begin
\layout LyX-Code

if loop=nil
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if loop^.tag<> forloop
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if assignsin(loop)>1 { this is a conservative rule }
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if callsin(loop)>0
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if forsin(loop)>1
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if loop^.incr^.tag<>intlit
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if loop^.incr^.intlitarg<>1
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if anyNonArrayAssignments
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if IndexOccursInNonArrayExpression(loop^.indexvar,loop^.loopaction)
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

if getparallelism(loop)<2
\layout LyX-Code

then vectorisable:=false
\layout LyX-Code

else
\layout LyX-Code

vectorisable:= allOffsetsInLAreI(loop^.loopaction,loop^.indexvar)
\layout LyX-Code

end;
\layout LyX-Code

function scalarreplicator(scalar:pilcgnode;replicate:integer):pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

scalarreplicator:=
\layout LyX-Code

new_typecast(vectorof(getformat(scalar),replicate),
\layout LyX-Code

new_dyad(scalar,ilcprep,new_intlit(replicate,fint)));
\layout LyX-Code

end;
\layout LyX-Code

var replicationfactor:integer;
\layout LyX-Code

function expressionVectorisor(var p:pilcgnode):boolean;
\layout LyX-Code

{ this is a pre visitor so it should return false
\layout LyX-Code

if no further rewriting is to be done on the node
\layout LyX-Code

}
\layout LyX-Code

var t:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if p=nil
\layout LyX-Code

then expressionVectorisor:=false
\layout LyX-Code

else
\layout LyX-Code

case p^.tag of
\layout LyX-Code

arraysubscript: if binarymatch(p^.offset,new_deref(currentindexvar))
\layout LyX-Code

then begin
\layout LyX-Code

{ replace with replicated array }
\layout LyX-Code

t:=new_arraySubscript(
\layout LyX-Code

p^.base,
\layout LyX-Code

new_deref(currentindexvar),
\layout LyX-Code

vectorof( getbaseformat(p^.elementformat),replicationfactor));
\layout LyX-Code

expressionvectorisor:=false;
\layout LyX-Code

p:=t;
\layout LyX-Code

end else
\layout LyX-Code

begin
\layout LyX-Code

p:=scalarReplicator(p,replicationfactor);
\layout LyX-Code

expressionvectorisor:=false;
\layout LyX-Code

end;
\layout LyX-Code

format: begin
\layout LyX-Code

p:=new_format(vectorof(p^.formatarg,replicationfactor));
\layout LyX-Code

expressionvectorisor:=false;
\layout LyX-Code

end;
\layout LyX-Code

intlit,
\layout LyX-Code

reallit,
\layout LyX-Code

memref: begin
\layout LyX-Code

p:=scalarReplicator(p,replicationfactor);
\layout LyX-Code

expressionVectorisor:=false;
\layout LyX-Code

end;
\layout LyX-Code

else expressionVectorisor:=true;
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

{ takes a loop and returns an unrolled loop }
\layout LyX-Code

function unroll(loop:pilcgnode):pilcgnode;
\layout LyX-Code

var start,stop,increment:intint;
\layout LyX-Code

timesround,i,j,k:integer;
\layout LyX-Code

step:pilcgnode;
\layout LyX-Code

label 99;
\layout LyX-Code

function replicate(n:integer):pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if n<=1
\layout LyX-Code

then replicate:=loop^.
 loopaction
\layout LyX-Code

else replicate:= new_seq(replicate(n-1),
\layout LyX-Code

new_seq( step,
\layout LyX-Code

loop^.loopaction)
\layout LyX-Code

)
\layout LyX-Code

end;
\layout LyX-Code

begin
\layout LyX-Code

if loop=nil
\layout LyX-Code

then unroll:=nil
\layout LyX-Code

else
\layout LyX-Code

if loop^.tag<>forloop
\layout LyX-Code

then unroll:=loop
\layout LyX-Code

else
\layout LyX-Code

if (loop^.start^.tag=intlit)
\layout LyX-Code

and
\layout LyX-Code

(loop^.stop^.tag=intlit)
\layout LyX-Code

and
\layout LyX-Code

(loop^.incr^.tag=intlit)
\layout LyX-Code

and
\layout LyX-Code

(loop^.incr^.intlitarg>0)
\layout LyX-Code

then
\layout LyX-Code

begin
\layout LyX-Code

start:=loop^.start^.intlitarg;
\layout LyX-Code

stop:=loop^.stop^.intlitarg;
\layout LyX-Code

increment:=loop^.incr^.intlitarg;
\layout LyX-Code

timesround:= (stop-start+1) div increment;
\layout LyX-Code

k:=5;
\layout LyX-Code

for i:=k downto 1 do
\layout LyX-Code

if ( timesround mod i )=0
\layout LyX-Code

then begin
\layout LyX-Code

j:=i;
\layout LyX-Code

goto 99;
\layout LyX-Code

end ;
\layout LyX-Code

99:
\layout LyX-Code

step:=new_assign( loop^.indexvar,
\layout LyX-Code

new_dyad(
\layout LyX-Code

new_deref(loop^.indexvar),
\layout LyX-Code

ilcpplus,
\layout LyX-Code

loop^.incr
\layout LyX-Code

)
\layout LyX-Code

);
\layout LyX-Code

if j=timesround
\layout LyX-Code

then unroll:= new_seq(
\layout LyX-Code

new_assign(loop^.indexvar,loop^.start),
\layout LyX-Code

replicate(j))
\layout LyX-Code

else unroll:=new_for(
\layout LyX-Code

loop^.indexvar,
\layout LyX-Code

loop^.start,
\layout LyX-Code

loop^.stop,
\layout LyX-Code

loop^.incr,
\layout LyX-Code

replicate(j))
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

procedure vectoriseloop(newstep:integer;
\layout LyX-Code

oldloop:pilcgnode;
\layout LyX-Code

var quotientloop: pilcgnode;
\layout LyX-Code

var remainderloop: pilcgnode);
\layout LyX-Code

{ newstep specifies the vectorisation step
\layout LyX-Code

this generates two new loops for the oldloop
\layout LyX-Code

suppose the old loop was of the form
\layout LyX-Code

for i:= 1 to 11 step 1 do x[i]:=x[i]+y[i];
\layout LyX-Code

suppose newstep = 4
\layout LyX-Code

we will get a paif of newloops of form
\layout LyX-Code

for i:= 1 to 5 step 4 do x[i..i+3]:=x[i..i+3]+y[i..i+3]
\layout LyX-Code

for i:= 9 to 11 step 1 do x[i]:=x[i]+y[i];
\layout LyX-Code

}
\layout LyX-Code

var oldstart,oldfinish,oldstep:pilcgnode;
\layout LyX-Code

indexvar:pilcgnode;
\layout LyX-Code

looprange,
\layout LyX-Code

loopremainder,
\layout LyX-Code

secondloopfinish,
\layout LyX-Code

rangeinfirstloop,
\layout LyX-Code

one,
\layout LyX-Code

timesroundfirstloop,
\layout LyX-Code

oldbody,
\layout LyX-Code

newbody,
\layout LyX-Code

firstnewstop,secondnewstart,firstnewstep:pilcgnode;
\layout LyX-Code

firstloopbody,secondloopbody:pilcgnode;
\layout LyX-Code

needreplicatediterator:boolean;
\layout LyX-Code

begin
\layout LyX-Code

if newstep<2
\layout LyX-Code

then begin
\layout LyX-Code

quotientloop:=nil;
\layout LyX-Code

remainderloop:=oldloop;
\layout LyX-Code

end
\layout LyX-Code

else begin
\layout LyX-Code

{ loop of the form
\layout LyX-Code

FOR indexvar:=oldstart TO oldfinish STEP oldstep DO oldbody }
\layout LyX-Code

oldbody:=oldloop^.loopaction;
\layout LyX-Code

secondloopbody:=oldbody;
\layout LyX-Code

oldstart:=oldloop^.start;
\layout LyX-Code

oldstep:=oldloop^.incr;
\layout LyX-Code

indexvar:=oldloop^.indexvar;
\layout LyX-Code

oldfinish:=oldloop^.stop;
\layout LyX-Code

secondloopfinish:=oldfinish;
\layout LyX-Code

one:=new_intlit(1,getformat(oldstart));
\layout LyX-Code

firstnewstep:=new_intlit(newstep,getformat(oldstart));
\layout LyX-Code

{ oldfinish - oldstart + 1 }
\layout LyX-Code

looprange:=new_dyad(
\layout LyX-Code

new_dyad(oldfinish,ilcpminus,oldstart),
\layout LyX-Code

ilcpplus,
\layout LyX-Code

one
\layout LyX-Code

);
\layout LyX-Code

{ looprange mod newstep }
\layout LyX-Code

loopremainder:= new_dyad(looprange,
\layout LyX-Code

ilcpremainder,
\layout LyX-Code

firstnewstep);
\layout LyX-Code

rangeinfirstloop:=new_dyad(looprange,ilcpminus,loopremainder);
\layout LyX-Code

timesroundfirstloop:=new_dyad(looprange,ilcpdivide,firstnewstep);
\layout LyX-Code

firstnewstop:=new_dyad( oldstart,
\layout LyX-Code

ilcpplus,
\layout LyX-Code

new_dyad( rangeinfirstloop,
\layout LyX-Code

ilcpminus,
\layout LyX-Code

one));
\layout LyX-Code

secondnewstart:=new_dyad( new_dyad(one,ilcpplus,oldfinish),
\layout LyX-Code

ilcpminus,
\layout LyX-Code

loopremainder);
\layout LyX-Code

currentindexvar:=indexvar;
\layout LyX-Code

replicationfactor:=newstep;
\layout LyX-Code

newbody:=clone(oldbody);
\layout LyX-Code

previsit(newbody, expressionVectorisor);
\layout LyX-Code

quotientloop:=new_for( indexvar,
\layout LyX-Code

oldstart,
\layout LyX-Code

firstnewstop,
\layout LyX-Code

firstnewstep,
\layout LyX-Code

newbody);
\layout LyX-Code

remainderloop:=new_for( indexvar,
\layout LyX-Code

secondnewstart,
\layout LyX-Code

oldfinish,
\layout LyX-Code

oldstep,
\layout LyX-Code

oldbody);
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

{ create a vector type descriptor }
\layout LyX-Code

function vectorof(basetype, length:integer):integer;
\layout LyX-Code

begin
\layout LyX-Code

vectorof:=basetype +fvector+ (length*fvecmult);
\layout LyX-Code

end;
\layout LyX-Code

{-----------------------------------------------------------}
\layout LyX-Code

{ register allocation }
\layout LyX-Code

{-----------------------------------------------------------}
\layout LyX-Code

function reserved(r:integer):boolean;
\layout LyX-Code

(*! true if register r is reserved *)
\layout LyX-Code

begin
\layout LyX-Code

reserved:= registers[r].permanentlyreserved
\layout LyX-Code

or
\layout LyX-Code

(registers[r].basecode * reservations <>[])
\layout LyX-Code

end;
\layout LyX-Code

procedure reserve(r:integer);
\layout LyX-Code

(*! add register r to the reservation set *)
\layout LyX-Code

begin
\layout LyX-Code

reservations := reservations + registers[r].basecode;
\layout LyX-Code

end;
\layout LyX-Code

procedure unreserve(r:integer);
\layout LyX-Code

(*! remove register r from the reservation set *)
\layout LyX-Code

begin
\layout LyX-Code

reservations:=reservations - registers[r].basecode;
\layout LyX-Code

end ;
\layout LyX-Code

{ looks for a free reg of the given type and returns -1 if
\layout LyX-Code

it does not find it otherwise returns the register number}
\layout LyX-Code

function findfreereg(format:integer):integer;
\layout LyX-Code

var i,j,k:integer; label 99;
\layout LyX-Code

begin
\layout LyX-Code

j:=-1;
\layout LyX-Code

for i:=0 to lastreg do begin
\layout LyX-Code

if ((not fref and registers[i].format )= ( not fref and format) )
\layout LyX-Code

and
\layout LyX-Code

not reserved(i)
\layout LyX-Code

then begin j:= i ; goto 99 end
\layout LyX-Code

end ;
\layout LyX-Code

99: findfreereg:=j;
\layout LyX-Code

end;
\layout LyX-Code

{-----------------------------------------------------------}
\layout LyX-Code

{ Constructors - functions used to build the tree }
\layout LyX-Code

{-----------------------------------------------------------}
\layout LyX-Code

function new_deref(loc:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=deref;
\layout LyX-Code

p^.arg:=loc;
\layout LyX-Code

new_deref:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_monad(op:string;right :pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=monad;
\layout LyX-Code

p^.arg:=right;
\layout LyX-Code

new(p^.fn);
\layout LyX-Code

p^.fn^.tag:=monop;
\layout LyX-Code

p^.fn^.opname:=op;
\layout LyX-Code

new_monad:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_dyad(left:pilcgnode;op:string;right:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

flag:integer;
\layout LyX-Code

l,r:intint;
\layout LyX-Code

b:boolean;
\layout LyX-Code

function consensus:integer;
\layout LyX-Code

begin
\layout LyX-Code

consensus:=left^.litformat
\layout LyX-Code

end ;
\layout LyX-Code

function canreduce:boolean;
\layout LyX-Code

begin
\layout LyX-Code

canreduce:= constfoldingon
\layout LyX-Code

and
\layout LyX-Code

(left^.litformat=right^.litformat)
\layout LyX-Code

end ;
\layout LyX-Code

begin
\layout LyX-Code

IF
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

AND(
\layout LyX-Code

(op=ilcplt)
\layout LyX-Code

or
\layout LyX-Code

(op=ilcpgt)
\layout LyX-Code

or
\layout LyX-Code

(op=ilcpgeq)
\layout LyX-Code

or
\layout LyX-Code

(op=ilcpleq)
\layout LyX-Code

or
\layout LyX-Code

(ilcpeq=op)
\layout LyX-Code

)
\layout LyX-Code

THEN begin { boolean evaluations }
\layout LyX-Code

l:=left^.intlitarg; r:=right^.intlitarg;
\layout LyX-Code

b:= (op=ilcplt) and (l<r)
\layout LyX-Code

or
\layout LyX-Code

(op=ilcpgt) and (l>r)
\layout LyX-Code

or
\layout LyX-Code

(op=ilcpgeq) and (l>=r)
\layout LyX-Code

or
\layout LyX-Code

(op=ilcpleq) and (l<=r)
\layout LyX-Code

or
\layout LyX-Code

(ilcpeq=op) and (l=r);
\layout LyX-Code

if b then p:= new_intlit(-1,fint8)
\layout LyX-Code

else p:= new_intlit(0,fint)
\layout LyX-Code

end
\layout LyX-Code

else
\layout LyX-Code

IF (OP=ILCPPLUS)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_INTLIT(LEFT^.INTLITARG+RIGHT^.INTLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPAND)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_INTLIT(LEFT^.INTLITARG and RIGHT^.INTLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPOR)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_INTLIT(LEFT^.INTLITARG or RIGHT^.INTLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPTIMES)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.INTLITARG=1)
\layout LyX-Code

THEN P:= LEFT
\layout LyX-Code

ELSE IF (OP=ILCPTIMES)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.INTLITARG=1)
\layout LyX-Code

THEN P:= RIGHT
\layout LyX-Code

ELSE IF (OP=ILCPPLUS)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.INTLITARG=0)
\layout LyX-Code

THEN P:= LEFT
\layout LyX-Code

ELSE IF (OP=ILCPPLUS)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.INTLITARG=0)
\layout LyX-Code

THEN P:= RIGHT
\layout LyX-Code

ELSE IF (OP=ILCPTIMES)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.INTLITARG=1)
\layout LyX-Code

THEN P:= RIGHT
\layout LyX-Code

ELSE IF (OP=ILCPDIVIDE)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_INTLIT(LEFT^.INTLITARG div RIGHT^.INTLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPREMAINDER)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_INTLIT(LEFT^.INTLITARG mod RIGHT^.INTLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPMINUS)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_INTLIT(LEFT^.INTLITARG-RIGHT^.INTLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPPLUS)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=REALLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=REALLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_REALLIT(LEFT^.REALLITARG+RIGHT^.REALLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPTIMES)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=REALLIT)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=REALLIT)
\layout LyX-Code

AND
\layout LyX-Code

CANREDUCE
\layout LyX-Code

THEN P:= NEW_REALLIT(LEFT^.REALLITARG*RIGHT^.REALLITARG,CONSENSUS)
\layout LyX-Code

ELSE IF (OP=ILCPPLUS)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=DYAD)
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.FN^.OPNAME=ILCPPLUS)
\layout LyX-Code

AND
\layout LyX-Code

(RIGHT^.TAG=INTLIT)
\layout LyX-Code

THEN p:= new_dyad(LEFT^.ARG,ILCPPLUS,
\layout LyX-Code

new_dyad(RIGHT, ILCPPLUS,LEFT^.ARG2))
\layout LyX-Code

ELSE BEGIN
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=dyad;
\layout LyX-Code

if ((OP=ILCPTIMES)OR(OP=ILCPPLUS)or (op=ILCPAND) or (op=ILCPOR))
\layout LyX-Code

AND
\layout LyX-Code

(LEFT^.TAG=INTLIT)
\layout LyX-Code

then begin { for commutative ops put the literal second }
\layout LyX-Code

{ this will match many instructions better }
\layout LyX-Code

p^.arg2:=left;
\layout LyX-Code

p^.arg:=right;
\layout LyX-Code

end
\layout LyX-Code

else begin
\layout LyX-Code

p^.arg:=left;
\layout LyX-Code

p^.arg2:=right;
\layout LyX-Code

end;
\layout LyX-Code

new(p^.fn);
\layout LyX-Code

p^.fn^.tag:=dyadicop;
\layout LyX-Code

p^.fn^.opname:=op;
\layout LyX-Code

END;
\layout LyX-Code

new_dyad:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_for( indexvar,
\layout LyX-Code

start,
\layout LyX-Code

stop,
\layout LyX-Code

incr,
\layout LyX-Code

loopaction:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if (start^.tag = intlit)
\layout LyX-Code

and
\layout LyX-Code

(stop^.tag = intlit)
\layout LyX-Code

and
\layout LyX-Code

(incr^.tag = intlit)
\layout LyX-Code

and
\layout LyX-Code

(incr^.intlitarg>0)
\layout LyX-Code

and
\layout LyX-Code

(stop^.intlitarg<start^.intlitarg)
\layout LyX-Code

then new_for:=nil
\layout LyX-Code

else if (start^.tag = intlit)
\layout LyX-Code

and
\layout LyX-Code

(stop^.tag = intlit)
\layout LyX-Code

and
\layout LyX-Code

(incr^.tag = intlit)
\layout LyX-Code

and
\layout LyX-Code

(incr^.intlitarg>0)
\layout LyX-Code

and
\layout LyX-Code

(1=(((stop^.intlitarg -start^.intlitarg)+1) div incr^.intlitarg))
\layout LyX-Code

then new_for:= new_seq( new_assign(indexvar,start),
\layout LyX-Code

loopaction)
\layout LyX-Code

else
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.simple:=false;
\layout LyX-Code

p^.tag:=forloop;
\layout LyX-Code

p^.indexvar:=indexvar;
\layout LyX-Code

p^.start:=start;
\layout LyX-Code

p^.stop:=stop;
\layout LyX-Code

p^.incr:=incr;
\layout LyX-Code

p^.loopaction:=loopaction;
\layout LyX-Code

new_for:=p;
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

function new_format(form:integer):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=format;
\layout LyX-Code

p^.formatarg:=form;
\layout LyX-Code

new_format:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_if(condition,thenpart,elsepart:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if condition^.tag<> intlit
\layout LyX-Code

then begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.simple:=false;
\layout LyX-Code

p^.tag:=ifnode;
\layout LyX-Code

p^.condition:=condition;
\layout LyX-Code

p^.action:=thenpart;
\layout LyX-Code

p^.alternative:=elsepart;
\layout LyX-Code

new_if:=p;
\layout LyX-Code

end
\layout LyX-Code

else
\layout LyX-Code

begin
\layout LyX-Code

if condition^.intlitarg<>0
\layout LyX-Code

then new_if:=thenpart
\layout LyX-Code

else new_if:=elsepart
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

function new_goto(dest:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:= gotonode;
\layout LyX-Code

p^.dest:=dest;
\layout LyX-Code

new_goto:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_label:pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=labelnode;
\layout LyX-Code

p^.index:=labcount;
\layout LyX-Code

labcount:=labcount+1;
\layout LyX-Code

new_label:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_memref(dest:pilcgnode;form:integer):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=memref;
\layout LyX-Code

p^.arg:=dest;
\layout LyX-Code

p^.arg2:=new_format(form or fref);
\layout LyX-Code

new_memref:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_arraysubscript(baseaddr,index:pilcgnode;form:integer):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=arraysubscript;
\layout LyX-Code

p^.
 base:= baseaddr;
\layout LyX-Code

p^.offset:=index;
\layout LyX-Code

p^.elementformat:=(form or fref);
\layout LyX-Code

new_arraysubscript:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_assign(dest,src:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=assignop;
\layout LyX-Code

p^.src:=src;
\layout LyX-Code

p^.dest:=dest;
\layout LyX-Code

new_assign:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_reallit(i:intreal;rformat:integer):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=reallit;
\layout LyX-Code

p^.litformat:=rformat;
\layout LyX-Code

p^.reallitarg:=i;
\layout LyX-Code

new_reallit:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_intlit(i:intint;intformat:integer):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=intlit;
\layout LyX-Code

p^.litformat:=intformat;
\layout LyX-Code

p^.intlitarg:=i;
\layout LyX-Code

new_intlit:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_register(regindex:integer):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=reg;
\layout LyX-Code

p^.index:=regindex;
\layout LyX-Code

new_register:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_seq(hd,tl:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=sequence;
\layout LyX-Code

p^.current:=hd;
\layout LyX-Code

p^.next:=tl;
\layout LyX-Code

new_seq:=p;
\layout LyX-Code

end;
\layout LyX-Code

function new_typecast(format:integer; exp:pilcgnode):pilcgnode;
\layout LyX-Code

var p:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.tag:=typecast;
\layout LyX-Code

p^.arg:=new_format(format);
\layout LyX-Code

p^.arg2:=exp;
\layout LyX-Code

new_typecast:=p;
\layout LyX-Code

end;
\layout LyX-Code

function typeofop(f:pilcgnode;arg1,arg2:integer):integer;
\layout LyX-Code

var s:string;
\layout LyX-Code

begin
\layout LyX-Code

s:=f^.opname;
\layout LyX-Code

if (s=ilcplt) or
\layout LyX-Code

(s=ilcpgt) or
\layout LyX-Code

(s=ilcpgeq) or
\layout LyX-Code

(s=ilcpleq) or
\layout LyX-Code

(s=ilcpeq) or
\layout LyX-Code

(s=ilcpneq)
\layout LyX-Code

then typeofop:=fbool
\layout LyX-Code

else if (arg1)<>(arg2)
\layout LyX-Code

then begin
\layout LyX-Code

if (arg1 and freal) <>(arg2 and freal)
\layout LyX-Code

then begin
\layout LyX-Code

if (arg1 and freal)=freal
\layout LyX-Code

then typeofop:=arg1
\layout LyX-Code

else typeofop:=arg2
\layout LyX-Code

end
\layout LyX-Code

else
\layout LyX-Code

if arg1>arg2
\layout LyX-Code

then typeofop:=arg1
\layout LyX-Code

else typeofop:= arg2
\layout LyX-Code

end
\layout LyX-Code

else
\layout LyX-Code

typeofop:=arg2
\layout LyX-Code

end;
\layout LyX-Code

function typeoffunc(f:pilcgnode;argumenttype:integer):integer;
\layout LyX-Code

var s:string;
\layout LyX-Code

begin
\layout LyX-Code

s:=f^.opname;
\layout LyX-Code

if (s= 'ROUND' ) or (s= 'TRUNC')
\layout LyX-Code

then typeoffunc:=fint
\layout LyX-Code

else if (s = 'FLOAT')
\layout LyX-Code

then typeoffunc:=fieee64
\layout LyX-Code

else typeoffunc:= argumenttype
\layout LyX-Code

end;
\layout LyX-Code

function simplify(n:pilcgnode):pilcgnode;
\layout LyX-Code

var l1,l2,n1:pilcgnode;
\layout LyX-Code

init,increment,test:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if verbose
\layout LyX-Code

then printtree(n,output);
\layout LyX-Code

if n<>nil then with n^ do
\layout LyX-Code

case n^.tag of
\layout LyX-Code

forloop:begin
\layout LyX-Code

l1:=new_label;
\layout LyX-Code

l2:=new_label;
\layout LyX-Code

init:=new_assign(indexvar,start);
\layout LyX-Code

increment:=new_assign(
\layout LyX-Code

indexvar,
\layout LyX-Code

new_dyad(indexvar,ilcpplus,incr));
\layout LyX-Code

test:=new_if(
\layout LyX-Code

new_dyad(incr,ilcpgt,new_intlit(0,fint)),
\layout LyX-Code

new_if(
\layout LyX-Code

new_dyad(
\layout LyX-Code

new_deref(indexvar),
\layout LyX-Code

ilcpleq,
\layout LyX-Code

stop),
\layout LyX-Code

new_goto(l1),
\layout LyX-Code

nil),
\layout LyX-Code

new_if(new_dyad(
\layout LyX-Code

new_deref(indexvar),
\layout LyX-Code

ilcpgeq,
\layout LyX-Code

stop),
\layout LyX-Code

new_goto(l1),
\layout LyX-Code

nil));
\layout LyX-Code

n:=new_seq(new_seq(init,new_goto(l2)),
\layout LyX-Code

new_seq(new_seq(l1,
\layout LyX-Code

new_seq( loopaction ,
\layout LyX-Code

increment)
\layout LyX-Code

),
\layout LyX-Code

new_seq(l2,test)
\layout LyX-Code

)
\layout LyX-Code

);
\layout LyX-Code

if verbose
\layout LyX-Code

then printtree(n,output);
\layout LyX-Code

simplify:=n;
\layout LyX-Code

end;
\layout LyX-Code

ifnode:if not simple
\layout LyX-Code

then begin
\layout LyX-Code

l1:=new_label;l2:=new_label;
\layout LyX-Code

n1:= new_if(condition,new_goto(l1),nil);
\layout LyX-Code

n1^.simple:=true;
\layout LyX-Code

n1:=new_seq(n1,
\layout LyX-Code

new_seq(alternative,
\layout LyX-Code

new_seq(new_goto(l2),
\layout LyX-Code

new_seq(l1,
\layout LyX-Code

new_seq(action,l2)
\layout LyX-Code

)
\layout LyX-Code

)
\layout LyX-Code

)
\layout LyX-Code

);
\layout LyX-Code

n1^.simple:=true;
\layout LyX-Code

{ printtree(n1,debugfile); }
\layout LyX-Code

simplify:=n1;
\layout LyX-Code

end
\layout LyX-Code

else simplify:=n;
\layout LyX-Code

else begin
\layout LyX-Code

{ this is a dummy implementation for now }
\layout LyX-Code

n^.simple:=true;
\layout LyX-Code

simplify:=n;
\layout LyX-Code

end
\layout LyX-Code

end
\layout LyX-Code

else simplify:=nil
\layout LyX-Code

end;
\layout LyX-Code

function lengthinbytes(format:integer):integer;
\layout LyX-Code

begin
\layout LyX-Code

if (format and fvector) =0
\layout LyX-Code

then case format and 7 of
\layout LyX-Code

foctet: lengthinbytes:=1;
\layout LyX-Code

fhalfword: lengthinbytes:=2;
\layout LyX-Code

fword: lengthinbytes:=4;
\layout LyX-Code

fdword: lengthinbytes:=8;
\layout LyX-Code

fqword: lengthinbytes:=16;
\layout LyX-Code

else lengthinbytes:=0;
\layout LyX-Code

end
\layout LyX-Code

else lengthinbytes:= lengthinbytes(format and 7)*
\layout LyX-Code

(format div fvecmult);
\layout LyX-Code

end;
\layout LyX-Code

function formatincludes(general,specific:integer):boolean;
\layout LyX-Code

begin
\layout LyX-Code

if general = specific
\layout LyX-Code

then formatincludes:=true
\layout LyX-Code

else
\layout LyX-Code

if (general and specific and fref)<>0
\layout LyX-Code

then { both are ref types check if the referants are the same }
\layout LyX-Code

formatincludes:=
\layout LyX-Code

formatincludes( general - fref,specific - fref)
\layout LyX-Code

else
\layout LyX-Code

if general <= fqword { general is untyped }
\layout LyX-Code

then formatincludes := lengthinbytes(general)=lengthinbytes(specific)
\layout LyX-Code

else formatincludes := false
\layout LyX-Code

end;
\layout LyX-Code

function decast(n:pilcgnode):pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if n=nil
\layout LyX-Code

then decast:=n
\layout LyX-Code

else
\layout LyX-Code

if n^.tag <> typecast
\layout LyX-Code

then decast:=n
\layout LyX-Code

else decast:= n^.arg2
\layout LyX-Code

end;
\layout LyX-Code

procedure getcheckpoint(var b:rollbackbuffer; var p:checkpoint);
\layout LyX-Code

begin
\layout LyX-Code

p.mark:=getmark(b);
\layout LyX-Code

p.reserved:=reservations;
\layout LyX-Code

end;
\layout LyX-Code

procedure setcheckpoint(var b:rollbackbuffer; var p:checkpoint);
\layout LyX-Code

begin
\layout LyX-Code

setmark(b,p.mark);
\layout LyX-Code

reservations:=p.reserved;
\layout LyX-Code

end;
\layout LyX-Code

function label2str(l:pilcgnode):string;
\layout LyX-Code

var s:string;
\layout LyX-Code

begin
\layout LyX-Code

str(l^.index,s);
\layout LyX-Code

label2str:='l'+s;
\layout LyX-Code

end;
\layout LyX-Code

function match(m:pilcgnode;var b:rollbackbuffer):boolean;
\layout LyX-Code

(*! This is the master matching routine in the code generator
\layout LyX-Code

it matches the tree n against the instructionset until
\layout LyX-Code

it gets a resolution, or if it fails returns false *)
\layout LyX-Code

type
\layout LyX-Code

evalcontext=(lhs,rhs); { only in rhs context can we load regs }
\layout LyX-Code

function patternmatch(context:evalcontext;n:pilcgnode; p:pattern;var s :string):
boolean;
\layout LyX-Code

(*! This attempts to match n against p, returns result in s *)
\layout LyX-Code

var
\layout LyX-Code

paramresults:array[paramref] of string;
\layout LyX-Code

paramsbound:array[paramref] of boolean;
\layout LyX-Code

paramsources:array[paramref] of pilcgnode;
\layout LyX-Code

mark:checkpoint;
\layout LyX-Code

pno:integer;
\layout LyX-Code

function regload(r, src:pilcgnode):boolean;
\layout LyX-Code

(*! attemps to load register r with the
\layout LyX-Code

expression indicated by src.
\layout LyX-Code

It will only work in rhs context *)
\layout LyX-Code

var
\layout LyX-Code

load:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if (context=rhs)
\layout LyX-Code

and
\layout LyX-Code

formatincludes(registers[r^.index].format and not fref,getformat(src))
\layout LyX-Code

and
\layout LyX-Code

not reserved(r^.index)
\layout LyX-Code

then begin
\layout LyX-Code

new(load);
\layout LyX-Code

load^.tag:=Assignop;
\layout LyX-Code

load^.src:=src;
\layout LyX-Code

load^.dest:=r;
\layout LyX-Code

if (m^.tag=assignop )
\layout LyX-Code

and
\layout LyX-Code

(m^.dest^.tag=reg)
\layout LyX-Code

and
\layout LyX-Code

binarymatch(src,m^.src)
\layout LyX-Code

then regload:=false { we are recursing }
\layout LyX-Code

else
\layout LyX-Code

if match(load,b)
\layout LyX-Code

then begin
\layout LyX-Code

reserve(r^.index);
\layout LyX-Code

regload:=true
\layout LyX-Code

end
\layout LyX-Code

else regload:=false;
\layout LyX-Code

dispose(load);
\layout LyX-Code

end
\layout LyX-Code

else regload:=false
\layout LyX-Code

end;
\layout LyX-Code

procedure print2str(p:pprintlist);
\layout LyX-Code

(*! this evaluates the assembler output in the
\layout LyX-Code

context of the parameter bindings
\layout LyX-Code

*)
\layout LyX-Code

begin
\layout LyX-Code

if p<> nil
\layout LyX-Code

then with p^ do begin
\layout LyX-Code

if literal=printchar
\layout LyX-Code

then s:=s+litval
\layout LyX-Code

else s:=s+paramresults[index];
\layout LyX-Code

print2str(next);
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

{ match n against all aternatives in range j..k}
\layout LyX-Code

function matchalt(n:pilcgnode;j,k:integer):boolean;
\layout LyX-Code

var i,d:integer; ok:boolean;
\layout LyX-Code

label 1;
\layout LyX-Code

begin
\layout LyX-Code

ok:=false;
\layout LyX-Code

for i:= j to k do begin
\layout LyX-Code

getcheckpoint(b,mark);
\layout LyX-Code

begin
\layout LyX-Code

if patternmatch(context,n,alternatives[i]^,s)
\layout LyX-Code

then begin
\layout LyX-Code

ok:=true;
\layout LyX-Code

goto 1;
\layout LyX-Code

end ;
\layout LyX-Code

end ;
\layout LyX-Code

setcheckpoint(b,mark);
\layout LyX-Code

end;
\layout LyX-Code

1:matchalt:=ok;
\layout LyX-Code

end;
\layout LyX-Code

function getformat(n:pilcgnode):integer;
\layout LyX-Code

{ inner version of getformat which can
\layout LyX-Code

evaluate the format of bound parameters }
\layout LyX-Code

begin
\layout LyX-Code

if n=nil then getformat:=fvoid
\layout LyX-Code

else
\layout LyX-Code

with n^ do
\layout LyX-Code

case tag of
\layout LyX-Code

reallit,
\layout LyX-Code

intlit: getformat:=litformat ;
\layout LyX-Code

monad: getformat:=typeoffunc(fn,getformat(arg));
\layout LyX-Code

deref: getformat:=getformat(arg) and not fref;
\layout LyX-Code

format: getformat:=formatarg;
\layout LyX-Code

ref: getformat:=getformat(arg) or fref;
\layout LyX-Code

dyad: getformat:=typeofop(fn,getformat(arg),getformat(arg2));
\layout LyX-Code

constant,
\layout LyX-Code

typecast:getformat:=getformat(arg);
\layout LyX-Code

param : if paramsbound[index]
\layout LyX-Code

then getformat:=getformat(paramsources[index])
\layout LyX-Code

else getformat:=fvoid;
\layout LyX-Code

memref: getformat:=getformat(arg2);
\layout LyX-Code

reg: getformat:=REGISTERS[N^.INDEX].format;
\layout LyX-Code

else getformat:=fvoid;
\layout LyX-Code

end;
\layout LyX-Code

end; {of getformat}
\layout LyX-Code

function binarymatch(src,template:pilcgnode):boolean;
\layout LyX-Code

(*! This attempts to match the source against the template
\layout LyX-Code

within the context of the parameter bindings above
\layout LyX-Code

*)
\layout LyX-Code

function typecompatible(template,src:pilcgnode):boolean;
\layout LyX-Code

var st:integer;
\layout LyX-Code

begin
\layout LyX-Code

st:=getformat(src);
\layout LyX-Code

case template^.tag of
\layout LyX-Code

ref:
\layout LyX-Code

if (st and fref) =0
\layout LyX-Code

then typecompatible := false
\layout LyX-Code

else typecompatible := typecompatible(template^.arg,new_deref(src));
\layout LyX-Code

param:
\layout LyX-Code

if paramsbound[template^.index]
\layout LyX-Code

then typecompatible:=formatincludes(getformat(template),st)
\layout LyX-Code

else
\layout LyX-Code

typecompatible:= binarymatch(src,template) ;
\layout LyX-Code

else typecompatible:=formatincludes(getformat(template),st)
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

var tempnode:pilcgnode; i:integer; ok:boolean;
\layout LyX-Code

saved:evalcontext;
\layout LyX-Code

begin
\layout LyX-Code

if src=template then binarymatch:=true
\layout LyX-Code

else if src=nil
\layout LyX-Code

then binarymatch := template=nil
\layout LyX-Code

else
\layout LyX-Code

if template=nil
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if (src^.tag = typecast) and (src^.tag<>template^.tag)
\layout LyX-Code

then binarymatch:=binarymatch(decast(src),template)
\layout LyX-Code

else case template^.tag of
\layout LyX-Code

deref: if decast (template^.arg)^.tag=param
\layout LyX-Code

{ we have a candidate for filling a register }
\layout LyX-Code

then begin
\layout LyX-Code

if src^.tag=deref
\layout LyX-Code

then begin
\layout LyX-Code

if binarymatch(src^.arg,template^.arg)
\layout LyX-Code

then binarymatch:=true
\layout LyX-Code

else binarymatch:= binarymatch(src,decast(template^.arg))
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=binarymatch(src,template^.arg);
\layout LyX-Code

end
\layout LyX-Code

else if src^.tag<>deref
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

memref:
\layout LyX-Code

if src^.tag<> template^.tag
\layout LyX-Code

then begin
\layout LyX-Code

binarymatch:=false
\layout LyX-Code

end
\layout LyX-Code

else begin
\layout LyX-Code

{ when evaluateing a memref we can load
\layout LyX-Code

registers to get the address
\layout LyX-Code

thus we indicate we are in rhs context
\layout LyX-Code

}
\layout LyX-Code

saved:=context;
\layout LyX-Code

context:=rhs;
\layout LyX-Code

ok:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

context:=saved;
\layout LyX-Code

binarymatch:=ok;
\layout LyX-Code

end ;
\layout LyX-Code

failure:
\layout LyX-Code

if src^.tag<> template^.tag
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

reallit: if src^.tag<> reallit
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=src^.reallitarg=template^.reallitarg;
\layout LyX-Code

intlit: if src^.tag<> intlit
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=src^.intlitarg=template^.intlitarg;
\layout LyX-Code

format: if src^.tag<> format
\layout LyX-Code

then binarymatch:=typecompatible(template,src)
\layout LyX-Code

else binarymatch:=formatincludes(template^.formatarg,src^.formatarg);
\layout LyX-Code

typevar,
\layout LyX-Code

unboundformat:binarymatch:= true
\layout LyX-Code

or (
\layout LyX-Code

(src^.tag=deref) and
\layout LyX-Code

(src^.arg^.tag=format))
\layout LyX-Code

;
\layout LyX-Code

ref: if (getformat(src)and fref)<>fref
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else begin
\layout LyX-Code

new(tempnode);
\layout LyX-Code

tempnode^.tag:=format;
\layout LyX-Code

tempnode^.formatarg:= getformat(src) and not fref;
\layout LyX-Code

binarymatch:=binarymatch(tempnode,template^.arg) ;
\layout LyX-Code

dispose(tempnode);
\layout LyX-Code

end ;
\layout LyX-Code

location: if src^.tag<>location
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

binarymatch:=binarymatch(src^.locvalue,template^.locvalue);
\layout LyX-Code

gotonode: if src^.tag<>gotonode
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:= binarymatch(src^.dest,template^.dest);
\layout LyX-Code

patterntag: if src^.tag<>patterntag
\layout LyX-Code

then
\layout LyX-Code

binarymatch:=patternmatch(context,src,template^.pat^,bitbucket)
\layout LyX-Code

else
\layout LyX-Code

binarymatch:=binarymatch(src^.pat^.meaning,template^.pat^.meaning);
\layout LyX-Code

Assignop: if src^.tag<> Assignop
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else begin
\layout LyX-Code

context:=lhs;
\layout LyX-Code

if binarymatch(src^.dest,template^.dest)
\layout LyX-Code

then begin
\layout LyX-Code

context:=rhs;
\layout LyX-Code

binarymatch:=binarymatch(src^.src,template^.src);
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false
\layout LyX-Code

end ;
\layout LyX-Code

forloop: if src^.tag<>forloop
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else with template^ do
\layout LyX-Code

if not binarymatch(src^.indexvar, indexvar)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.start,start)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.stop,stop)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.incr,incr)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.loopaction,loopaction);
\layout LyX-Code

regstack: binarymatch:=(template^.tag=src^.tag)
\layout LyX-Code

and
\layout LyX-Code

(template^.stackdetails.printsas= src^.stackdetails.printsas);
\layout LyX-Code

monad:
\layout LyX-Code

if
\layout LyX-Code

(template^.fn^.opname=ilcppop)
\layout LyX-Code

then begin
\layout LyX-Code

{ try to push the src onto the stack }
\layout LyX-Code

{ so the instruction can pop it }
\layout LyX-Code

new(tempnode);
\layout LyX-Code

tempnode^.tag:=dyad;
\layout LyX-Code

new(tempnode^.fn);
\layout LyX-Code

tempnode^.fn^.tag:=monop;
\layout LyX-Code

tempnode^.fn^.opname:=ilcppush;
\layout LyX-Code

tempnode^.arg:=template^.arg;
\layout LyX-Code

tempnode^.arg2:=src;
\layout LyX-Code

binarymatch:=match(tempnode,b);
\layout LyX-Code

dispose(tempnode^.fn);
\layout LyX-Code

dispose(tempnode);
\layout LyX-Code

end
\layout LyX-Code

else
\layout LyX-Code

if src^.tag<> template^.tag
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if not binarymatch(src^.fn,template^.fn)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.arg,template^.arg)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=true;
\layout LyX-Code

dyad: if src^.tag<> template^.tag
\layout LyX-Code

then
\layout LyX-Code

binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if not binarymatch(src^.fn,template^.fn)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.arg,template^.arg)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

binarymatch:=binarymatch(src^.arg2,template^.arg2);
\layout LyX-Code

ifnode: if src^.tag<> ifnode
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

begin
\layout LyX-Code

context:=rhs;
\layout LyX-Code

if not binarymatch(src^.condition,template^.condition)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.action,template^.action)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.alternative,template^.alternative);
\layout LyX-Code

end ;
\layout LyX-Code

sequence: if src^.tag<> sequence
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.current,template^.current)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.next,template^.next);
\layout LyX-Code

alternation:binarymatch:= matchalt(src,template^.first,template^.last);
\layout LyX-Code

dyadicop,
\layout LyX-Code

monop: binarymatch:=src^.opname=template^.opname;
\layout LyX-Code

typecast: if typecompatible(template^.arg,src)
\layout LyX-Code

then binarymatch:=binarymatch(src,template^.arg2)
\layout LyX-Code

else binarymatch:=false;
\layout LyX-Code

constant: begin
\layout LyX-Code

{ we match the type of the source against
\layout LyX-Code

the input and then check that the source
\layout LyX-Code

is a literal
\layout LyX-Code

}
\layout LyX-Code

new(tempnode);
\layout LyX-Code

tempnode^.tag:=format;
\layout LyX-Code

tempnode^.formatarg:=getformat(src);
\layout LyX-Code

ok:=binarymatch(tempnode,template^.arg);
\layout LyX-Code

dispose(tempnode);
\layout LyX-Code

if ok
\layout LyX-Code

then begin
\layout LyX-Code

tempnode:=decast(src);
\layout LyX-Code

if (tempnode<>nil)
\layout LyX-Code

and
\layout LyX-Code

(template^.arg<>nil)
\layout LyX-Code

and
\layout LyX-Code

(template^.arg^.tag=param )
\layout LyX-Code

then begin
\layout LyX-Code

i:=template^.arg^.index;
\layout LyX-Code

paramsbound[i]:=true;
\layout LyX-Code

paramsources[i]:=src;
\layout LyX-Code

if tempnode^.tag=intlit
\layout LyX-Code

then begin
\layout LyX-Code

binarymatch:=true;
\layout LyX-Code

str(tempnode^.intlitarg,paramresults[i])
\layout LyX-Code

end
\layout LyX-Code

else if tempnode^.tag=reallit
\layout LyX-Code

then begin
\layout LyX-Code

binarymatch:=true;
\layout LyX-Code

str(tempnode^.reallitarg,paramresults[i])
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false
\layout LyX-Code

end;
\layout LyX-Code

param: if not paramsbound[template^.index]
\layout LyX-Code

then begin { attempt to bind the parameter }
\layout LyX-Code

ok:=patternmatch(context,src,p.params[template^.index]^,paramresults[template^.inde
x]);
\layout LyX-Code

if ok then begin
\layout LyX-Code

binarymatch:=true;
\layout LyX-Code

paramsources[template^.index]:=src;
\layout LyX-Code

paramsbound[template^.index]:=true;
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false;
\layout LyX-Code

end
\layout LyX-Code

else { already bound must be identical }
\layout LyX-Code

binarymatch:=binarymatch(src, paramsources[template^.index]);
\layout LyX-Code

reg: if src^.tag =reg
\layout LyX-Code

then binarymatch:=src^.index=template^.index
\layout LyX-Code

else binarymatch:=regload(template,src);
\layout LyX-Code

labelnode :if src^.tag = labelnode
\layout LyX-Code

then begin
\layout LyX-Code

s:=label2str(src);
\layout LyX-Code

binarymatch:=true;
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false;
\layout LyX-Code

else begin { default unhandled case }
\layout LyX-Code

if verbose
\layout LyX-Code

then writeln('failure in binary match template tag=',ord(template^.tag));
\layout LyX-Code

binarymatch:=false;
\layout LyX-Code

end
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

var z:integer; printed:boolean;
\layout LyX-Code

begin { patternmatch }
\layout LyX-Code

for pno:=0 to maxparam do paramsbound[pno]:=false;
\layout LyX-Code

getcheckpoint(b,mark); { make this atomic }
\layout LyX-Code

s:='';
\layout LyX-Code

recursiondepth:=recursiondepth+1;
\layout LyX-Code

if verbose
\layout LyX-Code

then begin
\layout LyX-Code

for z:=0 to recursiondepth do write(' ');
\layout LyX-Code

printtree(p.meaning,output);
\layout LyX-Code

write(' to ');
\layout LyX-Code

printtree(N,output);
\layout LyX-Code

writeln;
\layout LyX-Code

end;
\layout LyX-Code

if (recursiondepth<recmax)
\layout LyX-Code

and
\layout LyX-Code

binarymatch(n,p.meaning)
\layout LyX-Code

then begin
\layout LyX-Code

print2Str(p.matchedassembler);
\layout LyX-Code

patternmatch:=true;
\layout LyX-Code

if verbose
\layout LyX-Code

then begin
\layout LyX-Code

printed:=false;
\layout LyX-Code

for z:= 0 to maxparam do printed:=printed or paramsbound[z];
\layout LyX-Code

for z:=0 to recursiondepth do write(' ');
\layout LyX-Code

for z:= 0 to maxparam do if paramsbound[z] then
\layout LyX-Code

write('param [',z,']=',paramresults[z]);
\layout LyX-Code

writeln('->',s);
\layout LyX-Code

end ;
\layout LyX-Code

end
\layout LyX-Code

else begin
\layout LyX-Code

setcheckpoint(b,mark);
\layout LyX-Code

patternmatch:=false;
\layout LyX-Code

end;
\layout LyX-Code

recursiondepth:=recursiondepth-1;
\layout LyX-Code

end; {pattern match}
\layout LyX-Code

function instructionmatch(n:pilcgnode):boolean ;
\layout LyX-Code

(*! this attempts to match n against each instruction in turn
\layout LyX-Code

in the instructionset *)
\layout LyX-Code

var i:integer;ok:boolean;s2:string; mark:checkpoint;
\layout LyX-Code

oldreservations:reservationcode;
\layout LyX-Code

label 1;
\layout LyX-Code

begin
\layout LyX-Code

ok:=false;
\layout LyX-Code

{ an instruction that is generated should not in itself
\layout LyX-Code

affect the reservation status of the registers
\layout LyX-Code

so save and restore the reservation status
\layout LyX-Code

}
\layout LyX-Code

oldreservations:=reservations;
\layout LyX-Code

if verbose
\layout LyX-Code

then begin
\layout LyX-Code

printtree(n,output);
\layout LyX-Code

writeln;
\layout LyX-Code

end;
\layout LyX-Code

for i:=0 to lastinstruction do
\layout LyX-Code

begin
\layout LyX-Code

if verbose
\layout LyX-Code

then writeln(' try instr ',i);
\layout LyX-Code

getcheckpoint(b,mark);
\layout LyX-Code

if patternmatch(lhs,n,instructionsetorder[i]^,s2)
\layout LyX-Code

then begin
\layout LyX-Code

ok:=true;
\layout LyX-Code

appendstr(b,s2+'
\backslash 
n');
\layout LyX-Code

goto 1;
\layout LyX-Code

end ;
\layout LyX-Code

setcheckpoint(b,mark);
\layout LyX-Code

end;
\layout LyX-Code

1:instructionmatch:=ok;
\layout LyX-Code

reservations:=oldreservations;
\layout LyX-Code

end; {instruction match}
\layout LyX-Code

var t1:boolean;
\layout LyX-Code

mark:checkpoint;
\layout LyX-Code

r1:integer;
\layout LyX-Code

n1,r,quotient,remainder:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if m=nil then match:=true
\layout LyX-Code

else
\layout LyX-Code

with m^ do begin
\layout LyX-Code

t1:=false;
\layout LyX-Code

getcheckpoint(b,mark); { make this an atomic transaction }
\layout LyX-Code

case tag of
\layout LyX-Code

sequence:{ for a sequence match all terms in sequence }
\layout LyX-Code

if match(current,b)
\layout LyX-Code

then t1:=match(next,b)
\layout LyX-Code

else t1:=false;
\layout LyX-Code

forloop: if instructionmatch(m)
\layout LyX-Code

then t1:=true
\layout LyX-Code

else begin
\layout LyX-Code

r1:=findfreereg(getformat(m^.indexvar)) ;
\layout LyX-Code

if innerloop(m)
\layout LyX-Code

and
\layout LyX-Code

(r1>=0 )
\layout LyX-Code

then begin
\layout LyX-Code

reserve(r1);
\layout LyX-Code

t1:=false;
\layout LyX-Code

r:=new_register(r1);
\layout LyX-Code

n1:=substituteAwithBinC(m^.indexvar,r,m);
\layout LyX-Code

if vectorisable (n1)
\layout LyX-Code

then begin
\layout LyX-Code

vectoriseloop( getparallelism(n1),
\layout LyX-Code

n1,
\layout LyX-Code

quotient,
\layout LyX-Code

remainder);
\layout LyX-Code

if match(simplify(unroll(quotient)),b)
\layout LyX-Code

then t1:=
\layout LyX-Code

match(simplify(remainder),b)
\layout LyX-Code

else t1:=false;
\layout LyX-Code

end;
\layout LyX-Code

if verbose
\layout LyX-Code

then printtree(n1,output);
\layout LyX-Code

if not t1
\layout LyX-Code

then
\layout LyX-Code

if not m^.simple
\layout LyX-Code

then t1:= match(simplify(n1),b)
\layout LyX-Code

else t1:=false;
\layout LyX-Code

dispose(r);
\layout LyX-Code

unreserve(r1);
\layout LyX-Code

end ;
\layout LyX-Code

if not t1
\layout LyX-Code

then
\layout LyX-Code

if not m^.simple
\layout LyX-Code

then t1:= match(simplify(m),b)
\layout LyX-Code

else t1:=false;
\layout LyX-Code

end ;
\layout LyX-Code

ifnode:{ for a control statement attempt to match
\layout LyX-Code

it directly against the instructionset which
\layout LyX-Code

may work for some instructions, otherwise
\layout LyX-Code

attempt to simplify the control statement
\layout LyX-Code

}
\layout LyX-Code

if instructionmatch(m)
\layout LyX-Code

then t1:=true
\layout LyX-Code

else begin
\layout LyX-Code

replacesubscripts(m^ .condition);
\layout LyX-Code

if not m^.simple
\layout LyX-Code

then t1:= match(simplify(m),b)
\layout LyX-Code

else t1:=false;
\layout LyX-Code

end;
\layout LyX-Code

reallit,
\layout LyX-Code

intlit,
\layout LyX-Code

monad,
\layout LyX-Code

dyad,
\layout LyX-Code

failure,
\layout LyX-Code

Assignop,
\layout LyX-Code

gotonode,
\layout LyX-Code

labelnode: { for a statement attempt to match against the
\layout LyX-Code

entire instructionset }
\layout LyX-Code

begin
\layout LyX-Code

replacesubscripts(m);
\layout LyX-Code

t1:= instructionmatch(m);
\layout LyX-Code

end ;
\layout LyX-Code

deref,
\layout LyX-Code

format,
\layout LyX-Code

unboundformat, { this will match any format }
\layout LyX-Code

ref,
\layout LyX-Code

patterntag,
\layout LyX-Code

typevar,
\layout LyX-Code

memref,
\layout LyX-Code

dyadicop,
\layout LyX-Code

alternation,
\layout LyX-Code

monop,
\layout LyX-Code

typecast,
\layout LyX-Code

constant,
\layout LyX-Code

param,
\layout LyX-Code

reg: t1:=false; { not allowed at the top level }
\layout LyX-Code

else begin
\layout LyX-Code

if verbose
\layout LyX-Code

then writeln('could not match node of type ',ord(tag));
\layout LyX-Code

t1:=false;
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

if not t1 then setcheckpoint(b,mark);
\layout LyX-Code

match:=t1;
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

function binarymatch(src,template:pilcgnode):boolean;
\layout LyX-Code

(*! This attempts to match the source against the template
\layout LyX-Code

this is an unparameterised version that
\layout LyX-Code

does not generate any code as it does so
\layout LyX-Code

*)
\layout LyX-Code

function typecompatible(template,src:pilcgnode):boolean;
\layout LyX-Code

var st:integer;
\layout LyX-Code

begin
\layout LyX-Code

st:=getformat(src);
\layout LyX-Code

case template^.tag of
\layout LyX-Code

ref:
\layout LyX-Code

if (st and fref) =0
\layout LyX-Code

then typecompatible := false
\layout LyX-Code

else typecompatible := typecompatible(template^.arg,new_deref(src));
\layout LyX-Code

param: typecompatible:=false;
\layout LyX-Code

else typecompatible:=formatincludes(getformat(template),st)
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

var tempnode:pilcgnode; i:integer; ok:boolean;
\layout LyX-Code

begin
\layout LyX-Code

if src=template then binarymatch:=true
\layout LyX-Code

else if src=nil
\layout LyX-Code

then binarymatch := template=nil
\layout LyX-Code

else
\layout LyX-Code

if template=nil
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if (src^.tag = typecast) and (src^.tag<>template^.tag)
\layout LyX-Code

then binarymatch:=binarymatch(decast(src),template)
\layout LyX-Code

else case template^.tag of
\layout LyX-Code

deref: if decast (template^.arg)^.tag=param
\layout LyX-Code

{ we have a candidate for filling a register }
\layout LyX-Code

then begin
\layout LyX-Code

if src^.tag=deref
\layout LyX-Code

then if binarymatch(src^.arg,template^.arg)
\layout LyX-Code

then binarymatch:=true
\layout LyX-Code

else if binarymatch(src,decast(template^.arg))
\layout LyX-Code

then binarymatch:=true
\layout LyX-Code

else if src^.tag<>deref
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

end
\layout LyX-Code

else if src^.tag<>deref
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

memref,
\layout LyX-Code

failure:
\layout LyX-Code

if src^.tag<> template^.tag
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if template^.tag= memref
\layout LyX-Code

then begin
\layout LyX-Code

{ when evaluateing a memref we can load
\layout LyX-Code

registers to get the address
\layout LyX-Code

thus we indicate we are in rhs context
\layout LyX-Code

}
\layout LyX-Code

ok:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

binarymatch:=ok;
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=binarymatch(src^.arg,template^.arg);
\layout LyX-Code

reallit: if src^.tag<> reallit
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=src^.reallitarg=template^.reallitarg;
\layout LyX-Code

intlit: if src^.tag<> intlit
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=src^.intlitarg=template^.intlitarg;
\layout LyX-Code

format: if src^.tag<> format
\layout LyX-Code

then binarymatch:=typecompatible(template,src)
\layout LyX-Code

else binarymatch:=formatincludes(template^.formatarg,src^.formatarg);
\layout LyX-Code

typevar,
\layout LyX-Code

unboundformat:binarymatch:= true
\layout LyX-Code

or (
\layout LyX-Code

(src^.tag=deref) and
\layout LyX-Code

(src^.arg^.tag=format))
\layout LyX-Code

;
\layout LyX-Code

ref: if (getformat(src)and fref)<>fref
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else begin
\layout LyX-Code

new(tempnode);
\layout LyX-Code

tempnode^.tag:=format;
\layout LyX-Code

tempnode^.formatarg:= getformat(src) and not fref;
\layout LyX-Code

binarymatch:=binarymatch(tempnode,template^.arg) ;
\layout LyX-Code

dispose(tempnode);
\layout LyX-Code

end ;
\layout LyX-Code

location: if src^.tag<>location
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

binarymatch:=binarymatch(src^.locvalue,template^.locvalue);
\layout LyX-Code

gotonode: if src^.tag<>gotonode
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:= binarymatch(src^.dest,template^.dest);
\layout LyX-Code

patterntag: if src^.tag<>patterntag
\layout LyX-Code

then
\layout LyX-Code

binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

binarymatch:=binarymatch(src^.pat^.meaning,template^.pat^.meaning);
\layout LyX-Code

Assignop: if src^.tag<> Assignop
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else begin
\layout LyX-Code

if binarymatch(src^.dest,template^.dest)
\layout LyX-Code

then begin
\layout LyX-Code

binarymatch:=binarymatch(src^.src,template^.src);
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false
\layout LyX-Code

end ;
\layout LyX-Code

forloop: if src^.tag<>forloop
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else with template^ do
\layout LyX-Code

if not binarymatch(src^.indexvar, indexvar)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.start,start)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.stop,stop)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.incr,incr)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.loopaction,loopaction);
\layout LyX-Code

regstack: binarymatch:=(template^.tag=src^.tag)
\layout LyX-Code

and
\layout LyX-Code

(template^.stackdetails.printsas= src^.stackdetails.printsas);
\layout LyX-Code

monad:
\layout LyX-Code

if src^.tag<> template^.tag
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if not binarymatch(src^.fn,template^.fn)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.arg,template^.arg)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=true;
\layout LyX-Code

dyad: if src^.tag<> template^.tag
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if not binarymatch(src^.fn,template^.fn)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.arg,template^.arg)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

binarymatch:=binarymatch(src^.arg2,template^.arg2);
\layout LyX-Code

ifnode: if src^.tag<> ifnode
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else
\layout LyX-Code

if not binarymatch(src^.condition,template^.condition)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.action,template^.action)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.alternative,template^.alternative);
\layout LyX-Code

sequence: if src^.tag<> sequence
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else if not binarymatch(src^.current,template^.current)
\layout LyX-Code

then binarymatch:=false
\layout LyX-Code

else binarymatch:=binarymatch(src^.next,template^.next);
\layout LyX-Code

alternation:binarymatch:= (src^.tag=alternation )
\layout LyX-Code

and
\layout LyX-Code

(template^.first=src^.first);
\layout LyX-Code

dyadicop,
\layout LyX-Code

monop: binarymatch:=src^.opname=template^.opname;
\layout LyX-Code

typecast: if typecompatible(template^.arg,src)
\layout LyX-Code

then binarymatch:=binarymatch(src,template^.arg2)
\layout LyX-Code

else binarymatch:=false;
\layout LyX-Code

constant: begin
\layout LyX-Code

{ we match the type of the source against
\layout LyX-Code

the input and then check that the source
\layout LyX-Code

is a literal
\layout LyX-Code

}
\layout LyX-Code

new(tempnode);
\layout LyX-Code

tempnode^.tag:=format;
\layout LyX-Code

tempnode^.formatarg:=getformat(src);
\layout LyX-Code

ok:=binarymatch(tempnode,template^.arg);
\layout LyX-Code

dispose(tempnode);
\layout LyX-Code

binarymatch:=ok
\layout LyX-Code

end;
\layout LyX-Code

param: binarymatch:=false;
\layout LyX-Code

reg: if src^.tag =reg
\layout LyX-Code

then binarymatch:=src^.index=template^.index
\layout LyX-Code

else binarymatch:=false;
\layout LyX-Code

arraysubscript:
\layout LyX-Code

binarymatch:=binarymatch(src^.base,template^.base)
\layout LyX-Code

and
\layout LyX-Code

binarymatch(src^.offset,template^.offset);
\layout LyX-Code

labelnode :if src^.tag = labelnode
\layout LyX-Code

then begin
\layout LyX-Code

binarymatch:=true;
\layout LyX-Code

end
\layout LyX-Code

else binarymatch:=false;
\layout LyX-Code

else begin { default unhandled case }
\layout LyX-Code

if verbose
\layout LyX-Code

then writeln('failure in binary match template tag=',ord(template^.tag));
\layout LyX-Code

binarymatch:=false;
\layout LyX-Code

end
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

var substarg,subsrep:pilcgnode;
\layout LyX-Code

procedure subs(var p:pilcgnode);
\layout LyX-Code

begin
\layout LyX-Code

if binarymatch(substarg,p)
\layout LyX-Code

then p:=subsrep;
\layout LyX-Code

end;
\layout LyX-Code

Function substituteAwithBinC(A,B:pilcgnode;C:pilcgnode):pilcgnode;
\layout LyX-Code

var x:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

substarg:=A;subsrep:=B;
\layout LyX-Code

x:=c;
\layout LyX-Code

modify(x,subs);
\layout LyX-Code

substituteAwithBinC:=x;
\layout LyX-Code

end;
\layout LyX-Code

{ masks out all vector information from a type }
\layout LyX-Code

function getbaseformat(f:integer):integer;
\layout LyX-Code

begin
\layout LyX-Code

getbaseformat:= (f and 255) and (not fvector);
\layout LyX-Code

end;
\layout LyX-Code

{ get the format code for an expression }
\layout LyX-Code

function getformat(n:pilcgnode):integer;
\layout LyX-Code

begin
\layout LyX-Code

if n=nil then getformat:=fvoid
\layout LyX-Code

else
\layout LyX-Code

with n^ do
\layout LyX-Code

case tag of
\layout LyX-Code

reallit,
\layout LyX-Code

intlit: getformat:=litformat ;
\layout LyX-Code

monad: getformat:=typeoffunc(fn,getformat(arg));
\layout LyX-Code

deref: getformat:=getformat(arg) and not fref;
\layout LyX-Code

format: getformat:=formatarg;
\layout LyX-Code

ref: getformat:=getformat(arg) or fref;
\layout LyX-Code

dyad: getformat:=typeofop(fn,getformat(arg),getformat(arg2));
\layout LyX-Code

constant,
\layout LyX-Code

typecast:getformat:=getformat(arg);
\layout LyX-Code

arraysubscript:getformat:= elementformat;
\layout LyX-Code

memref: getformat:=getformat(arg2);
\layout LyX-Code

reg: with registers[index] do getformat:=format;
\layout LyX-Code

else getformat:=fvoid;
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

procedure printassmspec(p:pprintlist;var f:text);
\layout LyX-Code

(*! this writes out the
\layout LyX-Code

assembler spec of an instruction
\layout LyX-Code

*)
\layout LyX-Code

begin
\layout LyX-Code

if p<> nil
\layout LyX-Code

then begin
\layout LyX-Code

case p^.literal of
\layout LyX-Code

printchar: write(f,p^.litval) ;
\layout LyX-Code

printparam: write(f,'#',p^.index:0) ;
\layout LyX-Code

else write(f,' illegal node ');
\layout LyX-Code

end;
\layout LyX-Code

printassmspec(p^.next,f);
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

procedure printtree(n:Pilcgnode; var f:text);
\layout LyX-Code

begin
\layout LyX-Code

if n= nil then write(f,'NIL')
\layout LyX-Code

else
\layout LyX-Code

with n^ do
\layout LyX-Code

case tag of
\layout LyX-Code

param: write(f,'#',index:0);
\layout LyX-Code

alternation: write(f,'[',first,'..',last,']');
\layout LyX-Code

monop,
\layout LyX-Code

dyadicop:write(f,opname);
\layout LyX-Code

reallit: write (f, reallitarg,':',litformat);
\layout LyX-Code

intlit: write (f, intlitarg,':',litformat);
\layout LyX-Code

monad: begin
\layout LyX-Code

printtree(fn,f);
\layout LyX-Code

write(f,'(');
\layout LyX-Code

printtree(arg,f);
\layout LyX-Code

write(f,')');
\layout LyX-Code

end;
\layout LyX-Code

deref: begin
\layout LyX-Code

write(f,'^(');
\layout LyX-Code

printtree( arg,f);
\layout LyX-Code

write(f,')');
\layout LyX-Code

end;
\layout LyX-Code

memref: begin
\layout LyX-Code

write(f,'mem[');
\layout LyX-Code

printtree(arg,f);
\layout LyX-Code

write(f,']:');
\layout LyX-Code

{ printtree(arg2,f); }
\layout LyX-Code

end;
\layout LyX-Code

format: write(f,'format(',formatarg,')');
\layout LyX-Code

ref: begin
\layout LyX-Code

write(f,'ref ');
\layout LyX-Code

printtree(arg,f) ;
\layout LyX-Code

end;
\layout LyX-Code

gotonode: begin
\layout LyX-Code

write(f,'goto ');
\layout LyX-Code

printtree(dest,f);
\layout LyX-Code

end;
\layout LyX-Code

labelnode: write(f,'l',index:0);
\layout LyX-Code

arraysubscript: begin
\layout LyX-Code

printtree(base,f);
\layout LyX-Code

write(f,'[');
\layout LyX-Code

printtree(offset,f);
\layout LyX-Code

write(f,']');
\layout LyX-Code

end;
\layout LyX-Code

dyad: begin
\layout LyX-Code

write(f,'(':0);
\layout LyX-Code

printtree(arg,f);
\layout LyX-Code

write(f, ' ':0);
\layout LyX-Code

printtree(fn, f);
\layout LyX-Code

write(f,' ');
\layout LyX-Code

printtree(arg2,f);
\layout LyX-Code

write(f,')');
\layout LyX-Code

end;
\layout LyX-Code

constant: begin
\layout LyX-Code

write(f,'const ');
\layout LyX-Code

printtree(arg,f);
\layout LyX-Code

end;
\layout LyX-Code

regstack: write(f,stackdetails.printsas);
\layout LyX-Code

location: begin
\layout LyX-Code

write(f,'loc ');
\layout LyX-Code

printtree(locvalue,f);
\layout LyX-Code

end;
\layout LyX-Code

typecast: begin
\layout LyX-Code

write(f,'(');
\layout LyX-Code

printtree(arg,f);
\layout LyX-Code

write(f,')');
\layout LyX-Code

printtree(arg2,f);
\layout LyX-Code

end;
\layout LyX-Code

patterntag: begin
\layout LyX-Code

write(f,'pat ');
\layout LyX-Code

printtree(pat.meaning,f);
\layout LyX-Code

end;
\layout LyX-Code

reg: with registers[index] do
\layout LyX-Code

write(f,printsas,':',getformat(n));
\layout LyX-Code

assignop:begin
\layout LyX-Code

printtree(dest,f);
\layout LyX-Code

write(f,':=');
\layout LyX-Code

printtree(src,f);
\layout LyX-Code

end ;
\layout LyX-Code

sequence:begin
\layout LyX-Code

printtree( current,f);
\layout LyX-Code

writeln(f);
\layout LyX-Code

printtree(next,f);
\layout LyX-Code

end;
\layout LyX-Code

forloop:begin
\layout LyX-Code

write(f,'for ');
\layout LyX-Code

printtree(indexvar,f);
\layout LyX-Code

write(f,':=');
\layout LyX-Code

printtree(start,f);
\layout LyX-Code

write(f,' to ');
\layout LyX-Code

printtree(stop,f);
\layout LyX-Code

write(f,' step ');
\layout LyX-Code

printtree(incr,f);
\layout LyX-Code

writeln(f,' do');
\layout LyX-Code

printtree(loopaction,f);
\layout LyX-Code

writeln(f,' od');
\layout LyX-Code

end;
\layout LyX-Code

ifnode:begin
\layout LyX-Code

write(f,'if ');
\layout LyX-Code

printtree(condition,f);
\layout LyX-Code

writeln(f);
\layout LyX-Code

write(f,'then ');
\layout LyX-Code

printtree(action,f);
\layout LyX-Code

writeln(f);
\layout LyX-Code

write(f,'else ');
\layout LyX-Code

printtree(alternative,f);
\layout LyX-Code

writeln(f);
\layout LyX-Code

write(f,'fi');
\layout LyX-Code

end;
\layout LyX-Code

else write(f, 'tag ',ord(tag));
\layout LyX-Code

end;
\layout LyX-Code

end;
\layout LyX-Code

function codegen(n:pilcgnode; var assemblerfile:text):boolean;
\layout LyX-Code

var b:rollbackbuffer;
\layout LyX-Code

begin
\layout LyX-Code

recursiondepth:=0;
\layout LyX-Code

initbuf(b, rollbacksize);
\layout LyX-Code

if match(n,b) then begin
\layout LyX-Code

writerollback(b,assemblerfile);
\layout LyX-Code

codegen:=true;
\layout LyX-Code

end else codegen:=false;
\layout LyX-Code

freebuf(b);
\layout LyX-Code

end;
\layout LyX-Code

function string2printlist(s:String ):pprintlist;
\layout LyX-Code

var s2:string; p:pprintlist;i:integer;
\layout LyX-Code

begin
\layout LyX-Code

if length(s)=0 then string2printlist:=nil
\layout LyX-Code

else begin
\layout LyX-Code

new(p);
\layout LyX-Code

p^.literal:=printchar;
\layout LyX-Code

p^.litval:=s[1];
\layout LyX-Code

s2:='';
\layout LyX-Code

for i:=2 to length(s) do s2:=s2+s[i];
\layout LyX-Code

p^.next:=string2printlist(s2);
\layout LyX-Code

string2printlist:=p;
\layout LyX-Code

end
\layout LyX-Code

end;
\layout LyX-Code

procedure pappends(var l:pprintlist; s:string);
\layout LyX-Code

procedure recurse(var l:pprintlist);
\layout LyX-Code

begin
\layout LyX-Code

if l=nil
\layout LyX-Code

then l:=string2printlist(s)
\layout LyX-Code

else recurse(l^.next);
\layout LyX-Code

end;
\layout LyX-Code

begin
\layout LyX-Code

recurse(l);
\layout LyX-Code

end;
\layout LyX-Code

procedure pappendp(var l:pprintlist; i:integer);
\layout LyX-Code

procedure recurse(var l:pprintlist);
\layout LyX-Code

begin
\layout LyX-Code

if l=nil
\layout LyX-Code

then begin
\layout LyX-Code

new(l);
\layout LyX-Code

l^.next:=nil;
\layout LyX-Code

l^.literal:=printparam;
\layout LyX-Code

l^.index:=i;
\layout LyX-Code

end
\layout LyX-Code

else recurse(l^.next);
\layout LyX-Code

end;
\layout LyX-Code

begin
\layout LyX-Code

recurse(l);
\layout LyX-Code

end;
\layout LyX-Code

function typeparam:ppattern;
\layout LyX-Code

var myrec:ppattern;
\layout LyX-Code

begin
\layout LyX-Code

new(myrec);
\layout LyX-Code

with myrec^ do begin
\layout LyX-Code

paramcount :=0;
\layout LyX-Code

matchedassembler:=nil;
\layout LyX-Code

new(meaning);
\layout LyX-Code

meaning^.tag:=typevar;
\layout LyX-Code

end;
\layout LyX-Code

typeparam:=myrec;
\layout LyX-Code

end;
\layout LyX-Code

{
\layout LyX-Code

function lookupreg(l:pregister;var s:string):pilcgnode;
\layout LyX-Code

var myrec:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

if l=nil then lookupreg=nil
\layout LyX-Code

else if reglist^.name =s then
\layout LyX-Code

begin
\layout LyX-Code

new(myrec);
\layout LyX-Code

myrec^.tag:=reg;
\layout LyX-Code

myrec^.index:=l^.index;
\layout LyX-Code

lookupreg:=myrec
\layout LyX-Code

end
\layout LyX-Code

else lookupreg:= lookupreg(l^.next,s) ;
\layout LyX-Code

end; }
\layout LyX-Code

function buildparamref(i:integer):pilcgnode;
\layout LyX-Code

var myrec:pilcgnode;
\layout LyX-Code

begin
\layout LyX-Code

new(myrec);
\layout LyX-Code

myrec^.tag:=param;
\layout LyX-Code

myrec^.index:=i;
\layout LyX-Code

buildparamref:=myrec;
\layout LyX-Code

end;
\layout LyX-Code

begin
\layout LyX-Code

new(patlabel);
\layout LyX-Code

patlabel_:=patlabel; { this version of the name is auto generated at times
\layout LyX-Code

as a synonym }
\layout LyX-Code

with patlabel^ do begin
\layout LyX-Code

new(meaning);
\layout LyX-Code

meaning^.tag:=labelnode;
\layout LyX-Code

paramcount:=0;
\layout LyX-Code

matchedassembler:=nil;
\layout LyX-Code

new(params);
\layout LyX-Code

end;
\layout LyX-Code

new(pattype_);
\layout LyX-Code

with pattype_^ do begin
\layout LyX-Code

new(meaning);
\layout LyX-Code

meaning^.tag:=alternation;
\layout LyX-Code

meaning^.first:=0;
\layout LyX-Code

meaning^.last:=0;
\layout LyX-Code

paramcount:=0;
\layout LyX-Code

matchedassembler:=nil;
\layout LyX-Code

new(params);
\layout LyX-Code

end;
\layout LyX-Code

labcount:=1;
\layout LyX-Code

verbose:=false;
\layout LyX-Code

end.
\the_end
