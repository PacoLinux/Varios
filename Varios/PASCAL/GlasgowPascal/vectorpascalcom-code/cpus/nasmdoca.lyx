#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass article
\begin_preamble
\usepackage{calc}
\usepackage{hyperref}\usepackage{setspace}
\usepackage{multicol}
\usepackage[normalem]{ulem}
\usepackage{color}
 
\setlength{\oddsidemargin}{1.2500in-1in}
\setlength{\textwidth}{\paperwidth - 1.2500in-1.2500in}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard
\align left 

\series bold 
\size large 
A.7 ADDPS: SSE Packed Single-FP ADD
\layout Standard
\align left 

\size footnotesize 
ADDPS xmmreg,r/m128 ; 0F 58 /r [KATMAI,SSE]
\layout Standard
\align left 
ADDPS treats both operands as vectors of four 32-bit floating-point numbers
 and adds each number in the source operand to the corresponding number
 in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.8 ADDSS: SSE Scalar Single-FP ADD
\layout Standard
\align left 

\size footnotesize 
ADDSS xmmreg,xmmreg/mem32 ; F3 0F 58 /r [KATMAI,SSE]
\layout Standard
\align left 
ADDSS adds the 32-bit floating-point number in the lowest 4 bytes of the
 source operand to the floating-point number in the lowest quarter of the
 destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.10 ANDNPS: SSE Bitwise Logical AND NOT
\layout Standard
\align left 

\size footnotesize 
ANDNPS xmmreg,r/m128 ; 0F 55 /r [KATMAI,SSE]
\layout Standard
\align left 
ANDNPS performs a bitwise AND operation on the source operand and the complement
 of the destination register, and stores the result in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.11 ANDPS: SSE Bitwise Logical AND
\layout Standard
\align left 

\size footnotesize 
ANDPS xmmreg,r/m128 ; 0F 54 /r [KATMAI,SSE]
\layout Standard
\align left 
ANDPS performs a bitwise AND operation on the source operand and the destination
 register, and stores the result in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.23 CMPccPS: SSE Packed Single-FP Compare
\layout Standard
\align left 

\size footnotesize 
CMPPS xmmreg,r/m128,imm8 ; 0F C2 /r ib [KATMAI,SSE]
\layout Standard
\align left 

\size footnotesize 
CMPEQPS xmmreg,r/m128 ; 0F C2 /r 00 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPLEPS xmmreg,r/m128 ; 0F C2 /r 02 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPLTPS xmmreg,r/m128 ; 0F C2 /r 01 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPNEQPS xmmreg,r/m128 ; 0F C2 /r 04 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPNLEPS xmmreg,r/m128 ; 0F C2 /r 06 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPNLTPS xmmreg,r/m128 ; 0F C2 /r 05 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPORDPS xmmreg,r/m128 ; 0F C2 /r 07 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPUNORDPS xmmreg,r/m128 ; 0F C2 /r 03 [KATMAI,SSE]
\layout Standard
\align left 
CMPPS treats both operands as vectors of four 32-bit floating-point numbers.
 For each pair of such numbers CMPPS produces an all 1 32-bit mask or an
 all 0 32-bit mask, using the comparison specified by imm8, and puts this
 mask in the corresponding location in the destination register.
 The allowed values of imm8 are 0-7, which correspond to the eight pseudo-ops
 shown above.
 
\layout Standard
\align left 

\series bold 
\size large 
A.25 CMPccSS: SSE Scalar Single-FP Compare
\layout Standard
\align left 

\size footnotesize 
CMPSS xmmreg,xmmreg/mem32,imm8; F3 0F C2 /r ib [KATMAI,SSE]
\layout Standard
\align left 

\size footnotesize 
CMPEQSS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 00 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPLESS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 02 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPLTSS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 01 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPNEQSS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 04 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPNLESS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 06 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPNLTSS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 05 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPORDSS xmmreg,xmmreg/mem32 ; F3 0F C2 /r 07 [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CMPUNORDSS xmmreg,xmmreg/mem32; F3 0F C2 /r 03 [KATMAI,SSE]
\layout Standard
\align left 
CMPSS is the same as CMPPS except that it compares only the first pair of
 32-bit floating point numbers.
 
\layout Standard
\align left 

\series bold 
\size large 
A.28 COMISS: SSE Scalar Compare and Set EFLAGS
\layout Standard
\align left 

\size footnotesize 
COMISS xmmreg,xmmreg/mem32 ; 0F 2F /r [KATMAI,SSE]
\layout Standard
\align left 
COMISS compares the 32-bit floating-point numbers in the lowest part of
 the two operands, and sets the CPU flags appropriately.
 COMISS differs from UCOMISS in that it signals an invalid numeric exeception
 if an operand is an sNaN or a qNaN, whereas UCOMISS does so only if an
 operand is an sNaN.
 
\layout Standard
\align left 

\series bold 
\size large 
A.30 CVTPI2PS: SSE Packed Integer to Floating-Point Conversion
\layout Standard
\align left 

\size footnotesize 
CVTPI2PS xmmreg,r/m64 ; 0F 2A /r [KATMAI,SSE]
\layout Standard
\align left 
CVTPI2PS considers the source operand as a pair of signed 32-bit integers
 and converts them to 32-bit floating-point numbers, storing the result
 in the lower half of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.31 CVTPS2PI, CVTTPS2PI: SSE Packed Floating-Point to Integer Conversion
\layout Standard
\align left 

\size footnotesize 
CVTPS2PI mmxreg,xmmreg/mem64 ; 0F 2D /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CVTTPS2PI mmxreg,xmmreg/mem64 ; 0F 2C /r [KATMAI,SSE]
\layout Standard
\align left 
These instructions consider the source operand as a pair of 32-bit floating-poin
t numbers and convert them to signed 32-bit integers, storing the result
 in the destination register.
 Note that if the source operand is a register then only its lower half
 is used.
 If the conversion is inexact, then CVTTPS2PI truncates, whereas CVTPS2PI
 rounds according to the MXCSR.
 
\layout Standard
\align left 

\series bold 
\size large 
A.32 CVTSI2SS: SSE Scalar Integer to Floating-Point Conversion
\layout Standard
\align left 

\size footnotesize 
CVTSI2SS xmmreg,r/m32 ; F3 0F 2A /r [KATMAI,SSE]
\layout Standard
\align left 
CVTSI2SS considers the source operand as a 32-bit signed integer, and converts
 it to a 32-bit float, storing the result in the lowest quarter of the destinati
on register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.33 CVTSS2SI, CVTTSS2SI: SSE Scalar Floating-Point to Integer Conversion
\layout Standard
\align left 

\size footnotesize 
CVTSS2SI reg32,xmmreg/mem32 ; F3 0F 2D /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
CVTTSS2SI reg32,xmmreg/mem32 ; F3 0F 2C /r [KATMAI,SSE]
\layout Standard
\align left 
These instructions consider the source operand as a 32-bit floating-point
 number and convert it to a signed 32-bit integer, storing the result in
 the destination register.
 Note that if the source operand is a register then only its lowest quarter
 is used.
 If the conversion is inexact, then CVTTSS2SI truncates, whereas CVTSS2SI
 rounds according to the MXCSR.
 
\layout Standard
\align left 

\series bold 
\size large 
A.37 DIVPS: Packed Single-FP Divide
\layout Standard
\align left 

\size footnotesize 
DIVPS xmmreg,r/m128 ; 0F 5E /r [KATMAI,SSE]
\layout Standard
\align left 
DIVPS considers both operands as vectors of four 32-bit floating-point numbers
 and divides each such number in the destination register by the corresponding
 number in the source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.38 DIVSS: Scalar Single-FP Divide
\layout Standard
\align left 

\size footnotesize 
DIVSS xmmreg,xmmreg/mem32 ; F3 0F 5E /r [KATMAI,SSE]
\layout Standard
\align left 
c{DIVSS} divides the 32-bit floating-point number in the lowest quarter
 of the destination register by the corresponding number in the source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.39 EMMS: Empty MMX State
\layout Standard
\align left 

\size footnotesize 
EMMS ; 0F 77 [PENT,MMX]
\layout Standard
\align left 
EMMS sets the FPU tag word (marking which floating-point registers are available
) to all ones, meaning all registers are available for the FPU to use.
 It should be used after executing MMX instructions and before executing
 any subsequent floating-point operations.
 
\layout Standard
\align left 

\series bold 
\size large 
A.53 FEMMS: Fast EMMS
\layout Standard
\align left 

\size footnotesize 
FEMMS ; 0F 0E [3DNOW]
\layout Standard
\align left 
FEMMS is like EMMS except that it is faster and leaves the contents of the
 MMX / floating-point registers undefined.
 
\layout Standard
\align left 

\series bold 
\size large 
A.88 FXRSTOR: Restore FP, MMX and SSE States
\layout Standard
\align left 

\size footnotesize 
FXRSTOR m512byte ; 0F AE /1 [P6,SSE,FPU]
\layout Standard
\align left 
FXRSTOR reloads the FP and MMX state, and the SSE state (environment and
 registers), from the memory area defined by m512byte.
 This data should have been written by a previous FXSAVE.
 
\layout Standard
\align left 

\series bold 
\size large 
A.89 FXSAVE: Store FP and MMX State and Streaming SIMD
\layout Standard
\align left 

\size footnotesize 
FXSAVE m512byte ; 0F AE /0 [P6,SSE,FPU]
\layout Standard
\align left 
FXSAVE writes the current FP and MMX state, and SSE state (environment and
 registers), to the specified destination defined by m512byte.
 It does this without checking for pending unmasked floating-point exceptions
 (similar to the operation of FNSAVE).
 Unlike the FSAVE/FNSAVE instructions, the processor retains the contents
 of the FP and MMX state and Streaming SIMD Extension state in the processor
 after the state has been saved.
 This instruction has been optimized to maximize floating-point save performance.
 
\layout Standard
\align left 

\series bold 
\size large 
A
\layout Standard
\align left 

\series bold 
\size large 
A.111 LDMXCSR: SSE Load MXCSR
\layout Standard
\align left 

\size footnotesize 
LDMXCSR mem32 ; 0F AE /2 [KATMAI,SSE]
\layout Standard
\align left 
LDMXCSR loads a 32-bit value out of memory and stores it into the MXCSR
 (the SSE control/status register).
 
\layout Standard
\align left 

\series bold 
\size large 
A.121 MASKMOVQ: Byte Mask Write
\layout Standard
\align left 

\size footnotesize 
MASKMOVQ mmxreg,mmxreg ; 0F F7 /r [KATMAI]
\layout Standard
\align left 
MASKMOVQ uses the most significant bit in each byte of the second MMX resister
 to selectively write (0 = no write, 1 = write) each byte of the first MMX
 register to the 64-bit memory location DS:DI or DS:EDI (depending on the
 addressing mode).
 
\layout Standard
\align left 

\series bold 
\size large 
A.122 MAXPS: SSE Packed Single-FP Maximum
\layout Standard
\align left 

\size footnotesize 
MAXPS xmmreg,r/m128 ; 0F 5F /r [KATMAI,SSE]
\layout Standard
\align left 
MAXPS considers its operands as vectors of four 32-bit floating-point numbers,
 and for each pair it stores the maximum of the the two in the corresponding
 quarter of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.123 MAXSS: SSE Scalar Single-FP Maximum
\layout Standard
\align left 

\size footnotesize 
MAXSS xmmreg,r/m128 ; F3 0F 5F /r [KATMAI,SSE]
\layout Standard
\align left 
MAXSS determines the maximum 32-bit floating-point number from the lowest
 quarter of both operands, and places this in the lowest quarter of the
 destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.124 MINPS: SSE Packed Single-FP Minimum
\layout Standard
\align left 

\size footnotesize 
MINPS xmmreg,r/m128 ; 0F 5D /r [KATMAI,SSE]
\layout Standard
\align left 
MINPS considers its operands as vectors of four 32-bit floating-point numbers,
 and for each pair it stores the minimum of the the two in the corresponding
 quarter of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.125 MINSS: SSE Scalar Single-FP Maximum
\layout Standard
\align left 

\size footnotesize 
MINSS xmmreg,r/m128 ; F3 0F 5D /r [KATMAI,SSE]
\layout Standard
\align left 
MINSS determines the minimum 32-bit floating-point number from the lowest
 quarter of both operands, and places this in the lowest quarter of the
 destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.127 MOVAPS: Move Aligned Four Packed Single-FP
\layout Standard
\align left 

\size footnotesize 
MOVAPS xmmreg,r/m128 ; 0F 28 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVAPS r/m128,xmmreg ; 0F 29 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVAPS copies 16 bytes from the source operand to the destination operand.
 If one of the operands is a memory location it must be aligned on a 16-byte
 boundary (otherwise use MOVUPS).
 
\layout Standard
\align left 

\series bold 
\size large 
A.128 MOVD: Move Doubleword to/from MMX Register
\layout Standard
\align left 

\size footnotesize 
MOVD mmxreg,r/m32 ; 0F 6E /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
MOVD r/m32,mmxreg ; 0F 7E /r [PENT,MMX]
\layout Standard
\align left 
MOVD copies 32 bits from its source (second) operand into its destination
 (first) operand.
 When the destination is a 64-bit MMX register, the top 32 bits are set
 to zero.
 
\layout Standard
\align left 

\series bold 
\size large 
A.129 MOVHLPS: SSE Move High to Low
\layout Standard
\align left 

\size footnotesize 
MOVHLPS xmmreg,xmmreg ; OF 12 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVHLPS moves 8 bytes from the upper half of the source register to the
 lower half of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.130 MOVHPS: SSE Move High
\layout Standard
\align left 

\size footnotesize 
MOVHPS xmmreg,mem64 ; 0F 16 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVHPS mem64,xmmreg ; 0F 17 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVHPS xmmreg,xmmreg ; 0F 16 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVHPS xmmreg,mem64 moves 8 bytes from mem64 to the upper half of xmmreg.
 
\layout Standard
\align left 
MOVHPS mem64,xmmreg moves 8 bytes from the upper half of xmmreg to mem64.
 
\layout Standard
\align left 
MOVHPS xmmreg,xmmreg is simply a synonym for MOVLHPS xmmreg,xmmreg.
 
\layout Standard
\align left 

\series bold 
\size large 
A.131 MOVLHPS: SSE Move Low to High
\layout Standard
\align left 

\size footnotesize 
MOVLHPS xmmreg,xmmreg ; 0F 16 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVLHPS moves 8 bytes from the lower half of the source register to the
 upper half of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.132 MOVLPS: SSE Move Low
\layout Standard
\align left 

\size footnotesize 
MOVLPS xmmreg,mem64 ; 0F 12 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVLPS mem64,xmmreg ; 0F 13 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVLPS xmmreg,xmmreg ; 0F 12 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVLPS xmmreg,mem64 moves 8 bytes from mem64 to the lower half of xmmreg.
 
\layout Standard
\align left 
MOVLPS mem64,xmmreg moves 8 bytes from the lower half of xmmreg to mem64.
 
\layout Standard
\align left 
MOVLPS xmmreg,xmmreg is simply a synonym for MOVHLPS xmmreg,xmmreg.
 
\layout Standard
\align left 

\series bold 
\size large 
A.133 MOVMSKPS: Move Mask To Integer
\layout Standard
\align left 

\size footnotesize 
MOVMSKPS reg32,xmmreg ; 0F 50 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVMSKPS forms a 4-bit mask from the most significant bit of each of the
 four 32-bit numbers in the source register, and stores this mask in the
 destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.134 MOVNTPS: Move Aligned Four Packed Single-FP Non Temporal
\layout Standard
\align left 

\size footnotesize 
MOVNTPS mem128,xmmreg ; 0F 2B /r [KATMAI,SSE]
\layout Standard
\align left 
MOVNTPS copies the contents of the XMM register into the given memory location,
 doing so in such a way as to minimize cache pollution.
 The memory location must be 16-byte aligned.
 
\layout Standard
\align left 

\series bold 
\size large 
A.135 MOVNTQ: Move 64 Bits Non Temporal
\layout Standard
\align left 

\size footnotesize 
MOVNTQ mem64,mmxreg ; 0F E7 /r [KATMAI]
\layout Standard
\align left 
MOVNTPS copies the contents of the MMX register into the given memory location,
 doing so in such a way as to minimize cache pollution.
 
\layout Standard
\align left 

\series bold 
\size large 
A.136 MOVQ: Move Quadword to/from MMX Register
\layout Standard
\align left 

\size footnotesize 
MOVQ mmxreg,r/m64 ; 0F 6F /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
MOVQ r/m64,mmxreg ; 0F 7F /r [PENT,MMX]
\layout Standard
\align left 
MOVQ copies 64 bits from its source (second) operand into its destination
 (first) operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.138 MOVSS: Move Scalar Single-FP
\layout Standard
\align left 

\size footnotesize 
MOVSS xmmreg,xmmreg/mem32 ; F3 0F 10 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVSS xmmreg/mem32,xmmreg ; F3 0F 11 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVSS copies the lower 4 bytes of the source operand to the lower 4 bytes
 of the destination operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.140 MOVUPS: Move Unaligned Four Packed Single-FP
\layout Standard
\align left 

\size footnotesize 
MOVUPS xmmreg,r/m128 ; 0F 10 /r [KATMAI,SSE] 
\layout Standard
\align left 

\size footnotesize 
MOVUPS r/m128,xmmreg ; 0F 11 /r [KATMAI,SSE]
\layout Standard
\align left 
MOVUPS copies 16 bytes from the source operand to the destination operand.
 In contrast to MOVAPS, no assumption is made about alignment.
 
\layout Standard
\align left 

\series bold 
\size large 
A.143 MULSS: Scalar Single-FP Multiply
\layout Standard
\align left 

\size footnotesize 
MULSS xmmreg,xmmreg/mem32 ; F3 0F 59 /r [KATMAI,SSE]
\layout Standard
\align left 
MULSS multiplies the first of the four 32-bit floating-point numbers in
 the destination register by the corresponding number in the source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.147 ORPS: SSE Bitwise Logical OR
\layout Standard
\align left 

\size footnotesize 
ORPS xmmreg,r/m128 ; 0F 56 /r [KATMAI,SSE]
\layout Standard
\align left 
ORPS performs a bitwise OR operation on the source operand and the destination
 register, and stores the result in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.150 PACKSSDW, PACKSSWB, PACKUSWB: Pack Data
\layout Standard
\align left 

\size footnotesize 
PACKSSDW mmxreg,r/m64 ; 0F 6B /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PACKSSWB mmxreg,r/m64 ; 0F 63 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PACKUSWB mmxreg,r/m64 ; 0F 67 /r [PENT,MMX]
\layout Standard
\align left 
All these instructions start by forming a notional 128-bit word by placing
 the source (second) operand on the left of the destination (first) operand.
 PACKSSDW then splits this 128-bit word into four doublewords, converts
 each to a word, and loads them side by side into the destination register;
 PACKSSWB and PACKUSWB both split the 128-bit word into eight words, converts
 each to a byte, and loads those side by side into the destination register.
 
\layout Standard
\align left 
PACKSSDW and PACKSSWB perform signed saturation when reducing the length
 of numbers: if the number is too large to fit into the reduced space, they
 replace it by the largest signed number (7FFFh or 7Fh) that will fit, and
 if it is too small then they replace it by the smallest signed number (8000h
 or 80h) that will fit.
 PACKUSWB performs unsigned saturation: it treats its input as unsigned,
 and replaces it by the largest unsigned number that will fit.
 
\layout Standard
\align left 

\series bold 
\size large 
A.151 PADDxx: MMX Packed Addition
\layout Standard
\align left 

\size footnotesize 
PADDB mmxreg,r/m64 ; 0F FC /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PADDW mmxreg,r/m64 ; 0F FD /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PADDD mmxreg,r/m64 ; 0F FE /r [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PADDSB mmxreg,r/m64 ; 0F EC /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PADDSW mmxreg,r/m64 ; 0F ED /r [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PADDUSB mmxreg,r/m64 ; 0F DC /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PADDUSW mmxreg,r/m64 ; 0F DD /r [PENT,MMX]
\layout Standard
\align left 
PADDxx all perform packed addition between their two 64-bit operands, storing
 the result in the destination (first) operand.
 The PADDxB forms treat the 64-bit operands as vectors of eight bytes, and
 add each byte individually; PADDxW treat the operands as vectors of four
 words; and PADDD treats its operands as vectors of two doublewords.
 
\layout Standard
\align left 
PADDSB and PADDSW perform signed saturation on the sum of each pair of bytes
 or words: if the result of an addition is too large or too small to fit
 into a signed byte or word result, it is clipped (saturated) to the largest
 or smallest value which will fit.
 PADDUSB and PADDUSW similarly perform unsigned saturation, clipping to
 0FFh or 0FFFFh if the result is larger than that.
 
\layout Standard
\align left 

\series bold 
\size large 
A.152 PADDSIW: MMX Packed Addition to Implicit Destination
\layout Standard
\align left 

\size footnotesize 
PADDSIW mmxreg,r/m64 ; 0F 51 /r [CYRIX,MMX]
\layout Standard
\align left 
PADDSIW, specific to the Cyrix extensions to the MMX instruction set, performs
 the same function as PADDSW, except that the result is not placed in the
 register specified by the first operand, but instead in the register whose
 number differs from the first operand only in the last bit.
 So PADDSIW MM0,MM2 would put the result in MM1, but PADDSIW MM1,MM2 would
 put the result in MM0.
 
\layout Standard
\align left 

\series bold 
\size large 
A.153 PAND, PANDN: MMX Bitwise AND and AND-NOT
\layout Standard
\align left 

\size footnotesize 
PAND mmxreg,r/m64 ; 0F DB /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PANDN mmxreg,r/m64 ; 0F DF /r [PENT,MMX]
\layout Standard
\align left 
PAND performs a bitwise AND operation between its two operands (i.e.
 each bit of the result is 1 if and only if the corresponding bits of the
 two inputs were both 1), and stores the result in the destination (first)
 operand.
 
\layout Standard
\align left 
PANDN performs the same operation, but performs a one's complement operation
 on the destination (first) operand first.
 
\layout Standard
\align left 

\series bold 
\size large 
A.154 PAVEB: MMX Packed Average
\layout Standard
\align left 

\size footnotesize 
PAVEB mmxreg,r/m64 ; 0F 50 /r [CYRIX,MMX]
\layout Standard
\align left 
PAVEB, specific to the Cyrix MMX extensions, treats its two operands as
 vectors of eight unsigned bytes, and calculates the average of the correspondin
g bytes in the operands.
 The resulting vector of eight averages is stored in the first operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.155 PAVGB, PAVGW: Packed Average
\layout Standard
\align left 

\size footnotesize 
PAVGB mmxreg,r/m64 ; 0F E0 /r [KATMAI] 
\layout Standard
\align left 

\size footnotesize 
PAVGW mmxreg,r/m64 ; 0F E3 /r [KATMAI]
\layout Standard
\align left 
For each byte in the source register, PAVGB computes the average of this
 byte and the corresponding byte in the destination register, and stores
 this average in place of the byte in the source register.
 
\layout Standard
\align left 
PAVGW does the same thing, but operating on 4 pairs of words instead of
 8 pairs of bytes.
 
\layout Standard
\align left 
In all cases, the values operated one are considered to be unsigned, and
 the result is rounded up if it is not an integer.
 
\layout Standard
\align left 

\series bold 
\size large 
A.156 PAVGUSB: Average Of Unsigned Packed 8-bit Values
\layout Standard
\align left 

\size footnotesize 
PAVGUSB mmxreg,r/m64 ; 0F 0F /r BF [3DNOW]
\layout Standard
\align left 
PAVGUSB produces the averages (rounded up) of the eight unsigned 8-bit integer
 values in the source operand and the eight corresponding unsigned 8-bit
 integer values in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.157 PCMPxx: MMX Packed Comparison
\layout Standard
\align left 

\size footnotesize 
PCMPEQB mmxreg,r/m64 ; 0F 74 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PCMPEQW mmxreg,r/m64 ; 0F 75 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PCMPEQD mmxreg,r/m64 ; 0F 76 /r [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PCMPGTB mmxreg,r/m64 ; 0F 64 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PCMPGTW mmxreg,r/m64 ; 0F 65 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PCMPGTD mmxreg,r/m64 ; 0F 66 /r [PENT,MMX]
\layout Standard
\align left 
The PCMPxx instructions all treat their operands as vectors of bytes, words,
 or doublewords; corresponding elements of the source and destination are
 compared, and the corresponding element of the destination (first) operand
 is set to all zeros or all ones depending on the result of the comparison.
 
\layout Standard
\align left 
PCMPxxB treats the operands as vectors of eight bytes, PCMPxxW treats them
 as vectors of four words, and PCMPxxD as two doublewords.
 
\layout Standard
\align left 
PCMPEQx sets the corresponding element of the destination operand to all
 ones if the two elements compared are equal; PCMPGTx sets the destination
 element to all ones if the element of the first (destination) operand is
 greater (treated as a signed integer) than that of the second (source)
 operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.158 PDISTIB: MMX Packed Distance and Accumulate with Implied Register
\layout Standard
\align left 

\size footnotesize 
PDISTIB mmxreg,mem64 ; 0F 54 /r [CYRIX,MMX]
\layout Standard
\align left 
PDISTIB, specific to the Cyrix MMX extensions, treats its two input operands
 as vectors of eight unsigned bytes.
 For each byte position, it finds the absolute difference between the bytes
 in that position in the two input operands, and adds that value to the
 byte in the same position in the implied output register.
 The addition is saturated to an unsigned byte in the same way as PADDUSB.
 
\layout Standard
\align left 
The implied output register is found in the same way as PADDSIW (
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}
\end_inset 

.
 
\layout Standard
\align left 
Note that PDISTIB cannot take a register as its second source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.159 PEXTRW: Extract Word
\layout Standard
\align left 

\size footnotesize 
PEXTRW reg32,mmxreg,imm8 ; 0F C5 /r ib [KATMAI]
\layout Standard
\align left 
PEXTRW moves the word in the MMX register (selected by the two least significant
 bits of imm8) into the lower half of the 32-bit integer register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.160 PF2ID: Packed Floating-Point To Integer Conversion
\layout Standard
\align left 

\size footnotesize 
PF2ID mmxreg,r/m64 ; 0F 0F /r 1D [3DNOW]
\layout Standard
\align left 
PF2ID converts two 32-bit floating point numbers in the source operand into
 32-bit signed integers in the destination register, using truncation.
 
\layout Standard
\align left 

\series bold 
\size large 
A.161 PF2IW: Packed Floating-Point to Integer Conversion
\layout Standard
\align left 

\size footnotesize 
PF2IW mmxreg,r/m64 ; 0F 0F /r 1C [ATHLON]
\layout Standard
\align left 
PF2IW converts two 32-bit floating point numbers in the source operand into
 16-bit signed integers in the destination register, using truncation and
 sign-extending to 32 bits.
 
\layout Standard
\align left 

\series bold 
\size large 
A.162 PFACC: Floating-Point Accumulate
\layout Standard
\align left 

\size footnotesize 
PFACC mmxreg,r/m64 ; 0F 0F /r AE [3DNOW]
\layout Standard
\align left 
PFACC treats the source and destination operands as pairs of 32-bit floating-poi
nt numbers.
 The sum of the pair in the destination register is stored in the lower
 half of the destination register, and the sum of the pair in the source
 operand is stored in the upper half of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.163 PFADD: Packed Floating-Point Addition
\layout Standard
\align left 

\size footnotesize 
PFADD mmxreg,r/m64 ; 0F 0F /r 9E [3DNOW]
\layout Standard
\align left 
PFADD adds the contents of the source operand to the contents of the destination
 register, treating both as pairs of 32-bit floating-point numbers.
 
\layout Standard
\align left 

\series bold 
\size large 
A.164 PFCMPEQ, PFCMPGE, PFCMPGT: Packed Floating-Point Comparison.
\layout Standard
\align left 

\size footnotesize 
PFCMPEQ mmxreg,r/m64 ; 0F 0F /r B0 [3DNOW] 
\layout Standard
\align left 

\size footnotesize 
PFCMPGE mmxreg,r/m64 ; 0F 0F /r 90 [3DNOW] 
\layout Standard
\align left 

\size footnotesize 
PFCMPGT mmxreg,r/m64 ; 0F 0F /r A0 [3DNOW]
\layout Standard
\align left 
These instructions perform comparisons between pairs of 32-bit floating-point
 numbers, storing the two results in the destination register.
 PFCMPEQ stores 0xFFFFFFFF if the numbers are equal, and 0 otherwise.
 PFCMPGE stores 0xFFFFFFFF if the destination is greater than or equal to
 the source, and 0 otherwise.
 PFCMPGT stores 0xFFFFFFFF if the destination is greater than the source,
 and 0 otherwise.
 
\layout Standard
\align left 

\series bold 
\size large 
A.165 PFMAX: Packed Floating-Point Maximum
\layout Standard
\align left 

\size footnotesize 
PFMAX mmxreg,r/m64 ; 0F 0F /r A4 [3DNOW]
\layout Standard
\align left 
For each half of the destination register, sets it equal to the maximum
 of itself and the corresponding half of the source operand, treating both
 as 32-bit floating-point numbers.
 
\layout Standard
\align left 

\series bold 
\size large 
A.166 PFMIN: Packed Floating-Point Minimum
\layout Standard
\align left 

\size footnotesize 
PFMIN mmxreg,r/m64 ; 0F 0F /r 94 [3DNOW]
\layout Standard
\align left 
For each half of the destination register, sets it equal to the minimum
 of itself and the corresponding half of the source operand, treating both
 as 32-bit floating-point numbers.
 
\layout Standard
\align left 

\series bold 
\size large 
A.167 PFMUL: Packed Floating-Point Multiply
\layout Standard
\align left 

\size footnotesize 
PFMUL mmxreg,r/m64 ; 0F 0F /r B4 [3DNOW]
\layout Standard
\align left 
PFMUL multiples the contents of the destination register by the contents
 of the source operand, treating both as pairs of 32-bit floating-point
 numbers.
 
\layout Standard
\align left 

\series bold 
\size large 
A.168 PFNACC: Packed Floating-Point Negative Accumulate
\layout Standard
\align left 

\size footnotesize 
PFNACC mmxreg,r/m64 ; 0F 0F /r 8A [ATHLON]
\layout Standard
\align left 
PFNACC works the same as PFACC, except that the difference rather than the
 sum is stored, the value in the upper half in both cases being subtracted
 from the value in the lower half.
 
\layout Standard
\align left 

\series bold 
\size large 
A.169 PFPNACC: Packed Floating-Point Mixed Accumulate
\layout Standard
\align left 

\size footnotesize 
PFPNACC mmxreg,r/m64 ; 0F 0F /r 8E [ATHLON]
\layout Standard
\align left 
PFPNACC is a mixture of PFACC and PFNACC.
 The new value of the lower half of the destination register is obtained
 by subtracting the upper half from the lower half.
 But the new value of the upper half of the destination register is obtained
 by adding both halves of the source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.170 PFRCP: Floating-Point Reciprocal Approximation
\layout Standard
\align left 

\size footnotesize 
PFRCP mmxreg,r/m64 ; 0F 0F /r 96 [3DNOW]
\layout Standard
\align left 
PFRCP calculates an approximation (accurate to 14 bits) of the reciprocal
 of the 32-bit floating-point number in the lower half of the source and
 stores it in both halves of the destination.
 
\layout Standard
\align left 

\series bold 
\size large 
A.171 PFRCPIT1: Floating-Point Reciprocal Refinement
\layout Standard
\align left 

\size footnotesize 
PFRCPIT1 mmxreg,r/m64 ; 0F 0F /r A6 [3DNOW]
\layout Standard
\align left 
PFRCPIT1 performs the first step in the iterative refinement of a reciprocal
 produced by PFRCP.
 
\layout Standard
\align left 

\series bold 
\size large 
A.172 PFRCPIT2: Floating-Point Refinement (Last Step)
\layout Standard
\align left 

\size footnotesize 
PFRCPIT2 mmxreg,r/m64 ; 0F 0F /r B6 [3DNOW]
\layout Standard
\align left 
PFRCPIT2 performs the second and final step in the iterative refinement
 of a reciprocal produced by PFRCP or of a reciprocal square root produced
 by PFRSQRT.
 
\layout Standard
\align left 

\series bold 
\size large 
A.173 PFRSQIT1: Floating-Point Reciprocal Square-Root Refinement
\layout Standard
\align left 

\size footnotesize 
PFRSQIT1 mmxreg,r/m64 ; 0F 0F /r A7 [3DNOW]
\layout Standard
\align left 
PFRSQIT1 performs the first step in the iterative refinement of a reciprocal
 square root produced by PFRSQRT.
 
\layout Standard
\align left 

\series bold 
\size large 
A.174 PFRSQRT: Floating-Point Reciprocal Square-Root Approximation
\layout Standard
\align left 

\size footnotesize 
PFRSQRT mmxreg,r/m64 ; 0F 0F /r 97 [3DNOW]
\layout Standard
\align left 
PFRSQRT calculates an approximation (accurate to 15 bits) of the reciprocal
 of the square root of the 32-bit floating-point number in the lower half
 of the source and stores it in both halves of the destination.
 If the source value is negative then it is treated as positive except that
 its sign is copied to the result.
 
\layout Standard
\align left 

\series bold 
\size large 
A.175 PFSUB: Packed Floating-Point Subtraction
\layout Standard
\align left 

\size footnotesize 
PFSUB mmxreg,r/m64 ; 0F 0F /r 9A [3DNOW]
\layout Standard
\align left 
PFSUB subtracts the pair of 32-bit floating-point numbers in the source
 operand from the corresponding pair in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.176 PFSUBR: Packed Floating-Point Reverse Subtraction
\layout Standard
\align left 

\size footnotesize 
PFSUBR mmxreg,r/m64 ; 0F 0F /r AA [3DNOW]
\layout Standard
\align left 
PFSUB subtracts the pair of 32-bit floating-point numbers in the source
 operand from the corresponding pair in the destination register, and then
 negates the results.
 
\layout Standard
\align left 

\series bold 
\size large 
A.177 PI2FD: Packed Integer To Floating-Point Conversion
\layout Standard
\align left 

\size footnotesize 
PI2FD mmxreg,r/m64 ; 0F 0F /r 0D [3DNOW]
\layout Standard
\align left 
PI2FD converts the pair of signed 32-bit integers in the source operand
 into 32-bit floating-point numbers (using truncation) and stores the results
 in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.178 PI2FW: Packed Integer To Floating-Point Conversion
\layout Standard
\align left 

\size footnotesize 
PI2FW mmxreg,r/m64 ; 0F 0F /r 0C [ATHLON]
\layout Standard
\align left 
PI2FW treats the source operand as a pair of signed 16-bit integers, by
 ignoring the upper 16 bits of each 32-bit half.
 These integers are converted to 32-bit floating-point numbers and stored
 in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.179 PINSRW: Insert Word
\layout Standard
\align left 

\size footnotesize 
PINSRW mmxreg,r/m16,imm8 ; 0F C4 /r ib [KATMAI]
\layout Standard
\align left 
PINSRW loads a word from the 16-bit integer register or memory location
 and inserts it in the MMX register, at a position defined by the two least
 significant bits of the imm8 constant.
 
\layout Standard
\align left 
Instead of specifying a 16-bit register you can instead specify a 32-bit
 register, of which only the bottom half will be used.
 This may seem peculiar, but it's the way Intel prefers.
 
\layout Standard
\align left 

\series bold 
\size large 
A.180 PMACHRIW: MMX Packed Multiply and Accumulate with Rounding
\layout Standard
\align left 

\size footnotesize 
PMACHRIW mmxreg,mem64 ; 0F 5E /r [CYRIX,MMX]
\layout Standard
\align left 
PMACHRIW acts almost identically to PMULHRIW (
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{section A.189)}}
\end_inset 

, but instead of storing its result in the implied destination register,
 it adds its result, as four packed words, to the implied destination register.
 No saturation is done: the addition can wrap around.
 
\layout Standard
\align left 
Note that PMACHRIW cannot take a register as its second source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.181 PMADDWD: MMX Packed Multiply and Add
\layout Standard
\align left 

\size footnotesize 
PMADDWD mmxreg,r/m64 ; 0F F5 /r [PENT,MMX]
\layout Standard
\align left 
PMADDWD treats its two inputs as vectors of four signed words.
 It multiplies corresponding elements of the two operands, giving four signed
 doubleword results.
 The top two of these are added and placed in the top 32 bits of the destination
 (first) operand; the bottom two are added and placed in the bottom 32 bits.
 
\layout Standard
\align left 

\series bold 
\size large 
A.182 PMAGW: MMX Packed Magnitude
\layout Standard
\align left 

\size footnotesize 
PMAGW mmxreg,r/m64 ; 0F 52 /r [CYRIX,MMX]
\layout Standard
\align left 
PMAGW, specific to the Cyrix MMX extensions, treats both its operands as
 vectors of four signed words.
 It compares the absolute values of the words in corresponding positions,
 and sets each word of the destination (first) operand to whichever of the
 two words in that position had the larger absolute value.
 
\layout Standard
\align left 

\series bold 
\size large 
A.183 PMAXSW: Packed Signed Integer Word Maximum
\layout Standard
\align left 

\size footnotesize 
PMAXSW mmxreg,r/m64 ; 0F EE /r [KATMAI]
\layout Standard
\align left 
PMAXSW considers both operands as vectors of 4 signed words.
 Each such word in the destination register is replaced by the corresponding
 word in the source operand if that is larger.
 
\layout Standard
\align left 

\series bold 
\size large 
A.184 PMAXUB: Packed Unsigned Integer Byte Maximum
\layout Standard
\align left 

\size footnotesize 
PMAXUB mmxreg,r/m64 ; 0F DE /r [KATMAI]
\layout Standard
\align left 
PMAXUB considers both operands as vectors of 8 unsigned bytes.
 Each such byte in the destination register is replaced by the corresponding
 byte in the source operand if that is larger.
 
\layout Standard
\align left 

\series bold 
\size large 
A.185 PMINSW: Packed Signed Integer Word Minimum
\layout Standard
\align left 

\size footnotesize 
PMINSW mmxreg,r/m64 ; 0F EA /r [KATMAI]
\layout Standard
\align left 
PMINSW considers both operands as vectors of 4 signed words.
 Each such word in the destination register is replaced by the corresponding
 word in the source operand if that is smaller.
 
\layout Standard
\align left 

\series bold 
\size large 
A.186 PMINUB: Packed Unsigned Integer Byte Minimum
\layout Standard
\align left 

\size footnotesize 
PMINUB mmxreg,r/m64 ; 0F DA /r [KATMAI]
\layout Standard
\align left 
PMINUB considers both operands as vectors of 8 unsigned bytes.
 Each such byte in the destination register is replaced by the corresponding
 byte in the source operand if that is smaller.
 
\layout Standard
\align left 

\series bold 
\size large 
A.187 PMOVMSKB: Move Byte Mask To Integer
\layout Standard
\align left 

\size footnotesize 
PMOVMSKB reg32,mmxreg ; 0F D7 /r [KATMAI]
\layout Standard
\align left 
PMOVMSKB creates an 8-bit mask formed of the most significant bit of each
 byte of its source operand, and stores this in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.188 PMULHRWA: Packed Multiply With Rounding
\layout Standard
\align left 

\size footnotesize 
PMULHRWA mmxreg,r/m64 ; 0F 0F /r B7 [3DNOW]
\layout Standard
\align left 
PMULHRWA performs the same operation as PMULHW, except that it rounds the
 results rather than truncating.
 
\layout Standard
\align left 
Note that the PMULHRWA instruction is called PMULHRW in AMD documentation.
 But NASM uses the form PMULHRWA to avoid conflict with Cyrix's different
 PMULHRW instruction (which NASM calls PMULHRWC).
 
\layout Standard
\align left 

\series bold 
\size large 
A.189 PMULHRWC, PMULHRIW: MMX Packed Multiply High with Rounding
\layout Standard
\align left 

\size footnotesize 
PMULHRWC mmxreg,r/m64 ; 0F 59 /r [CYRIX,MMX] 
\layout Standard
\align left 

\size footnotesize 
PMULHRIW mmxreg,r/m64 ; 0F 5D /r [CYRIX,MMX]
\layout Standard
\align left 
These instructions, specific to the Cyrix MMX extensions, treat their operands
 as vectors of four signed words.
 Words in corresponding positions are multiplied, to give a 32-bit value
 in which bits 30 and 31 are guaranteed equal.
 Bits 30 to 15 of this value (bit mask 0x7FFF8000) are taken and stored
 in the corresponding position of the destination operand, after first rounding
 the low bit (equivalent to adding 0x4000 before extracting bits 30 to 15).
 
\layout Standard
\align left 
For PMULHRWC, the destination operand is the first operand; for PMULHRIW
 the destination operand is implied by the first operand in the manner of
 PADDSIW (
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}
\end_inset 

.
 
\layout Standard
\align left 
Note that the PMULHRWC instruction is called PMULHRW in Cyrix documentation.
 But NASM uses the form PMULHRWC to avoid conflict with AMD's different
 PMULHRW instruction (which NASM calls PMULHRWA) 
\layout Standard
\align left 

\series bold 
\size large 
A.190 PMULHUW: Packed Multiply High Unsigned
\layout Standard
\align left 

\size footnotesize 
PMULHUW mmxreg,r/m64 ; 0F E4 /r [KATMAI]
\layout Standard
\align left 
PMULHUW multiplies the four unsigned words in the destination register with
 the four unsigned words in the source operand.
 The high-order 16 bits of each of the 32-bit intermediate results are written
 to the destination operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.191 PMULHW, PMULLW: MMX Packed Multiply
\layout Standard
\align left 

\size footnotesize 
PMULHW mmxreg,r/m64 ; 0F E5 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PMULLW mmxreg,r/m64 ; 0F D5 /r [PENT,MMX]
\layout Standard
\align left 
PMULxW treats its two inputs as vectors of four signed words.
 It multiplies corresponding elements of the two operands, giving four signed
 doubleword results.
 
\layout Standard
\align left 
PMULHW then stores the top 16 bits of each doubleword in the destination
 (first) operand; PMULLW stores the bottom 16 bits of each doubleword in
 the destination operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.192 PMVccZB: MMX Packed Conditional Move
\layout Standard
\align left 

\size footnotesize 
PMVZB mmxreg,mem64 ; 0F 58 /r [CYRIX,MMX] 
\layout Standard
\align left 

\size footnotesize 
PMVNZB mmxreg,mem64 ; 0F 5A /r [CYRIX,MMX] 
\layout Standard
\align left 

\size footnotesize 
PMVLZB mmxreg,mem64 ; 0F 5B /r [CYRIX,MMX] 
\layout Standard
\align left 

\size footnotesize 
PMVGEZB mmxreg,mem64 ; 0F 5C /r [CYRIX,MMX]
\layout Standard
\align left 
These instructions, specific to the Cyrix MMX extensions, perform parallel
 conditional moves.
 The two input operands are treated as vectors of eight bytes.
 Each byte of the destination (first) operand is either written from the
 corresponding byte of the source (second) operand, or left alone, depending
 on the value of the byte in the implied operand (specified in the same
 way as PADDSIW, in 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}
\end_inset 

.
 
\layout Standard
\align left 
PMVZB performs each move if the corresponding byte in the implied operand
 is zero.
 PMVNZB moves if the byte is non-zero.
 PMVLZB moves if the byte is less than zero, and PMVGEZB moves if the byte
 is greater than or equal to zero.
 
\layout Standard
\align left 
Note that these instructions cannot take a register as their second source
 operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.196 POR: MMX Bitwise OR
\layout Standard
\align left 

\size footnotesize 
POR mmxreg,r/m64 ; 0F EB /r [PENT,MMX]
\layout Standard
\align left 
POR performs a bitwise OR operation between its two operands (i.e.
 each bit of the result is 1 if and only if at least one of the corresponding
 bits of the two inputs was 1), and stores the result in the destination
 (first) operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.197 PREFETCH, PREFETCHW: Prefetch cache line
\layout Standard
\align left 

\size footnotesize 
PREFETCH mem ; 0F 0D /0 [3DNOW] 
\layout Standard
\align left 

\size footnotesize 
PREFETCHW mem ; 0F 0D /1 [3DNOW]
\layout Standard
\align left 
PREFETCH loads a cache line into the L1 data cache.
 PREFETCHW does the same, but also marks the cache line as modified.
 
\layout Standard
\align left 

\series bold 
\size large 
A.198 PREFETCHNTA, PREFETCHT0, PREFETCHT1, PREFETCHT2: Prefetch cache line
\layout Standard
\align left 

\size footnotesize 
PREFETCHNTA mem ; 0F 18 /0 [KATMAI] 
\layout Standard
\align left 

\size footnotesize 
PREFETCHT0 mem ; 0F 18 /1 [KATMAI] 
\layout Standard
\align left 

\size footnotesize 
PREFETCHT1 mem ; 0F 18 /2 [KATMAI] 
\layout Standard
\align left 

\size footnotesize 
PREFETCHT2 mem ; 0F 18 /3 [KATMAI]
\layout Standard
\align left 
These instructions move the data specified by the address closer to the
 processor using, respectively, the nta, t0, t1 and t2 hints.
 
\layout Standard
\align left 

\series bold 
\size large 
A.199 PSADBW: Packed Sum of Absolute Differences
\layout Standard
\align left 

\size footnotesize 
PSADBW mmxreg,r/m64 ; 0F F6 /r [KATMAI]
\layout Standard
\align left 
PSADBW computes the sum of the absolute differences of the unsigned signed
 bytes in the destination register and those in the source operand.
 It then places this sum in the lowest word of the destination register,
 and sets the three other words to zero.
 
\layout Standard
\align left 

\series bold 
\size large 
A.200 PSHUFW: Packed Shuffle Word
\layout Standard
\align left 

\size footnotesize 
PSHUFW mmxreg,r/m64,imm8 ; 0F 70 /r ib [KATMAI]
\layout Standard
\align left 
PSHUFW uses the imm8 value to select which of the four words of the source
 operand will be placed in each of the words of the destination register.
 Bits 0 and 1 of imm8 encode the source for word 0 (the lowest word) of
 the destination register, bits 2 and 3 encode the source for word 1, bits
 4 and 5 for word 2, and bits 6 and 7 for word 3 (the highest word).
 Each 2-bit encoding is a number in the range 0-3 that specifies the correspondi
ng word of the source operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.201 PSLLx, PSRLx, PSRAx: MMX Bit Shifts
\layout Standard
\align left 

\size footnotesize 
PSLLW mmxreg,r/m64 ; 0F F1 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSLLW mmxreg,imm8 ; 0F 71 /6 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSLLD mmxreg,r/m64 ; 0F F2 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSLLD mmxreg,imm8 ; 0F 72 /6 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSLLQ mmxreg,r/m64 ; 0F F3 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSLLQ mmxreg,imm8 ; 0F 73 /6 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSRAW mmxreg,r/m64 ; 0F E1 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSRAW mmxreg,imm8 ; 0F 71 /4 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSRAD mmxreg,r/m64 ; 0F E2 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSRAD mmxreg,imm8 ; 0F 72 /4 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSRLW mmxreg,r/m64 ; 0F D1 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSRLW mmxreg,imm8 ; 0F 71 /2 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSRLD mmxreg,r/m64 ; 0F D2 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSRLD mmxreg,imm8 ; 0F 72 /2 ib [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSRLQ mmxreg,r/m64 ; 0F D3 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSRLQ mmxreg,imm8 ; 0F 73 /2 ib [PENT,MMX]
\layout Standard
\align left 
PSxxQ perform simple bit shifts on the 64-bit MMX registers: the destination
 (first) operand is shifted left or right by the number of bits given in
 the source (second) operand, and the vacated bits are filled in with zeros
 (for a logical shift) or copies of the original sign bit (for an arithmetic
 right shift).
 
\layout Standard
\align left 
PSxxW and PSxxD perform packed bit shifts: the destination operand is treated
 as a vector of four words or two doublewords, and each element is shifted
 individually, so bits shifted out of one element do not interfere with
 empty bits coming into the next.
 
\layout Standard
\align left 
PSLLx and PSRLx perform logical shifts: the vacated bits at one end of the
 shifted number are filled with zeros.
 PSRAx performs an arithmetic right shift: the vacated bits at the top of
 the shifted number are filled with copies of the original top (sign) bit.
 
\layout Standard
\align left 

\series bold 
\size large 
A.202 PSUBxx: MMX Packed Subtraction
\layout Standard
\align left 

\size footnotesize 
PSUBB mmxreg,r/m64 ; 0F F8 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSUBW mmxreg,r/m64 ; 0F F9 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSUBD mmxreg,r/m64 ; 0F FA /r [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSUBSB mmxreg,r/m64 ; 0F E8 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSUBSW mmxreg,r/m64 ; 0F E9 /r [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PSUBUSB mmxreg,r/m64 ; 0F D8 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PSUBUSW mmxreg,r/m64 ; 0F D9 /r [PENT,MMX]
\layout Standard
\align left 
PSUBxx all perform packed subtraction between their two 64-bit operands,
 storing the result in the destination (first) operand.
 The PSUBxB forms treat the 64-bit operands as vectors of eight bytes, and
 subtract each byte individually; PSUBxW treat the operands as vectors of
 four words; and PSUBD treats its operands as vectors of two doublewords.
 
\layout Standard
\align left 
In all cases, the elements of the operand on the right are subtracted from
 the corresponding elements of the operand on the left, not the other way
 round.
 
\layout Standard
\align left 
PSUBSB and PSUBSW perform signed saturation on the sum of each pair of bytes
 or words: if the result of a subtraction is too large or too small to fit
 into a signed byte or word result, it is clipped (saturated) to the largest
 or smallest value which will fit.
 PSUBUSB and PSUBUSW similarly perform unsigned saturation, clipping to
 0FFh or 0FFFFh if the result is larger than that.
 
\layout Standard
\align left 

\series bold 
\size large 
A.203 PSUBSIW: MMX Packed Subtract with Saturation to Implied Destination
\layout Standard
\align left 

\size footnotesize 
PSUBSIW mmxreg,r/m64 ; 0F 55 /r [CYRIX,MMX]
\layout Standard
\align left 
PSUBSIW, specific to the Cyrix extensions to the MMX instruction set, performs
 the same function as PSUBSW, except that the result is not placed in the
 register specified by the first operand, but instead in the implied destination
 register, specified as for PADDSIW (
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}
\end_inset 

.
 
\layout Standard
\align left 

\series bold 
\size large 
A.204 PSWAPD: Packed Swap Doubleword
\layout Standard
\align left 

\size footnotesize 
PSWAPD mmxreg,r/m64 ; 0F 0F /r BB [ATHLON]
\layout Standard
\align left 
PSWAPD copies the source operand to the destination register, swapping the
 upper and lower halves in the process.
 
\layout Standard
\align left 

\series bold 
\size large 
A.205 PUNPCKxxx: Unpack Data
\layout Standard
\align left 

\size footnotesize 
PUNPCKHBW mmxreg,r/m64 ; 0F 68 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PUNPCKHWD mmxreg,r/m64 ; 0F 69 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PUNPCKHDQ mmxreg,r/m64 ; 0F 6A /r [PENT,MMX]
\layout Standard
\align left 

\size footnotesize 
PUNPCKLBW mmxreg,r/m64 ; 0F 60 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PUNPCKLWD mmxreg,r/m64 ; 0F 61 /r [PENT,MMX] 
\layout Standard
\align left 

\size footnotesize 
PUNPCKLDQ mmxreg,r/m64 ; 0F 62 /r [PENT,MMX]
\layout Standard
\align left 
PUNPCKxx all treat their operands as vectors, and produce a new vector generated
 by interleaving elements from the two inputs.
 The PUNPCKHxx instructions start by throwing away the bottom half of each
 input operand, and the PUNPCKLxx instructions throw away the top half.
 
\layout Standard
\align left 
The remaining elements, totalling 64 bits, are then interleaved into the
 destination, alternating elements from the second (source) operand and
 the first (destination) operand: so the leftmost element in the result
 always comes from the second operand, and the rightmost from the destination.
 
\layout Standard
\align left 
PUNPCKxBW works a byte at a time, PUNPCKxWD a word at a time, and PUNPCKxDQ
 a doubleword at a time.
 
\layout Standard
\align left 
So, for example, if the first operand held 0x7A6A5A4A3A2A1A0A and the second
 held 0x7B6B5B4B3B2B1B0B, then: 
\layout Standard
\align left 
PUNPCKHBW would return 0x7B7A6B6A5B5A4B4A.
 
\layout Standard
\align left 
PUNPCKHWD would return 0x7B6B7A6A5B4B5A4A.
 
\layout Standard
\align left 
PUNPCKHDQ would return 0x7B6B5B4B7A6A5A4A.
 
\layout Standard
\align left 
PUNPCKLBW would return 0x3B3A2B2A1B1A0B0A.
 
\layout Standard
\align left 
PUNPCKLWD would return 0x3B2B3A2A1B0B1A0A.
 
\layout Standard
\align left 
PUNPCKLDQ would return 0x3B2B1B0B3A2A1A0A.
 
\layout Standard
\align left 

\series bold 
\size large 
A.209 PXOR: MMX Bitwise XOR
\layout Standard
\align left 

\size footnotesize 
PXOR mmxreg,r/m64 ; 0F EF /r [PENT,MMX]
\layout Standard
\align left 
PXOR performs a bitwise XOR operation between its two operands (i.e.
 each bit of the result is 1 if and only if exactly one of the corresponding
 bits of the two inputs was 1), and stores the result in the destination
 (first) operand.
 
\layout Standard
\align left 

\series bold 
\size large 
A.211 RCPPS: SSE Packed Single-FP Reciprocal Approximation
\layout Standard
\align left 

\size footnotesize 
RCPPS xmmreg,r/m128 ; 0F 53 /r [KATMAI,SSE]
\layout Standard
\align left 
Four each of the four 32-bit floating-point numbers in the source operand
 RCPPS calculates an approximation of the reciprocal and stores it in the
 corresponding quarter of the destination register.
 The absolute value of the error for each of these approximations is at
 most 3/8192.
 
\layout Standard
\align left 

\series bold 
\size large 
A.212 RCPSS: SSE Scalar Single-FP Reciprocal Approximation
\layout Standard
\align left 

\size footnotesize 
RCPSS xmmreg,xmmreg/mem32 ; F3 0F 53 /r [KATMAI,SSE]
\layout Standard
\align left 
RCPSS calculates an approximation of the reciprocal of the 32-bit floating-point
 in the source operand (using the lowest quarter of the source operand if
 it is a register) and places the result in the lowest quarter of the destinatio
n register.
 The absolute value of the error for this approximation is at most 3/8192.
 
\layout Standard
\align left 

\series bold 
\size large 
A.222 RSQRTPS: Packed Single-FP Square Root Reciprocal
\layout Standard
\align left 

\size footnotesize 
RSQRTPS xmmreg,r/m128 ; 0F 52 /r [KATMAI,SSE]
\layout Standard
\align left 
For each of the four 32-bit floating-point numbers in the source operand,
 RSQRTPS computes an approximation of the reciprocal of the square root,
 and puts this in the corresponding quarter of the destination register.
 The maximum absolute error for this approximation is 3/8192.
 
\layout Standard
\align left 

\series bold 
\size large 
A.223 RSQRTSS:Scalar Single-FP Square Root Reciprocal
\layout Standard
\align left 

\size footnotesize 
RSQRTSS xmmreg,r/m128 ; F3 0F 52 /r [KATMAI,SSE]
\layout Standard
\align left 
RSQRTSS computes an approximation of the reciprocal of the square root of
 the first 32-bit floating-point number from xmm2/m32 and puts it in the
 lowest quarter of the destination register.
 The maximum absolute error for this approximation is 3/8192.
 
\layout Standard
\align left 

\series bold 
\size large 
A.231 SFENCE: Store Fence
\layout Standard
\align left 

\size footnotesize 
SFENCE ; 0F AE /7 [KATMAI]
\layout Standard
\align left 
SFENCE guarantees that all store instructions which precede it in the program
 order are globally visible before any store instructions which follow it.
 
\layout Standard
\align left 

\series bold 
\size large 
A.235 SHUFPS: Shuffle Single-FP
\layout Standard
\align left 

\size footnotesize 
SHUFPS xmmreg,r/m128,imm8 ; 0F C6 /r ib [KATMAI,SSE]
\layout Standard
\align left 
SHUFPS copies two quarters of the destination register to the lower two
 quarters of the destination register, and copies two quarters of the source
 operand to the upper two quarters of the destination register.
 
\layout Standard
\align left 
Bits 0 and 1 of imm8 determine which of the four quarters of the destination
 register gets copied to the lowest quater of the destination register.
 Bits 2 and 3 of imm8 similary deterine which quarter is copied to the second
 quarter of the destination register.
 Bits 4-7 likewise select the quarters of the source operand to be copied.
 
\layout Standard
\align left 

\series bold 
\size large 
A.239 SQRTPS: Packed Single-FP Square Root
\layout Standard
\align left 

\size footnotesize 
SQRTPS xmmreg,r/m128 ; 0F 51 /r [KATMAI,SSE]
\layout Standard
\align left 
SQRTPS considers the source operand as a vector of four 32-bit floating-point
 numbers, and for each of these it computes the square root and stores the
 result in the corresponding quarter of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.240 SQRTSS: Scalar Single-FP Square Root
\layout Standard
\align left 

\size footnotesize 
SQRTSS xmmreg,xmmreg/mem32 ; F3 0F 51 /r [KATMAI,SSE]
\layout Standard
\align left 
SQRTSS computes the square root of the 32-bit floating-point number in the
 lowest quarter of the source operand and stores the result in the lowest
 quarter of the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.242 STMXCSR: SSE Store MXCSR
\layout Standard
\align left 

\size footnotesize 
STMXCSR mem32 ; 0F AE /3 [KATMAI,SSE]
\layout Standard
\align left 
STMXCSR copies the the MXCSR (the SSE control/status register) into the
 32-bit memory location.
 
\layout Standard
\align left 

\series bold 
\size large 
A.246 SUBPS: Packed Single-FP Subtract
\layout Standard
\align left 

\size footnotesize 
SUBPS xmmreg,r/m128 ; 0F 5C /r [KATMAI,SSE]
\layout Standard
\align left 
SUBPS considers both operands as vectors of four 32-bit floating-point numbers,
 and subtracts each such number in the source operand from the corresponding
 number in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.247 SUBSS: Scalar Single-FP Subtract
\layout Standard
\align left 

\size footnotesize 
SUBSS xmmreg,xmmreg/mem32 ; F3 0F 5C /r [KATMAI,SSE]
\layout Standard
\align left 
SUBSS subtracts the 32-bit floating-point number in the lowest 4 bytes of
 the source operand from the corresponding number in the destination register.
 
\layout Standard
\align left 

\series bold 
\size large 
A.256 UCOMISS: Unordered Scalar Single-FP Compare and set EFLAGS
\layout Standard
\align left 

\size footnotesize 
UCOMISS xmmreg,xmmreg/mem32 ; 0F 2E /r [KATMAI,SSE]
\layout Standard
\align left 
UCOMISS compares the 32-bit floating-point numbers in the lowest part of
 the two operands, and sets the CPU flags appropriately.
 UCOMISS differs from COMISS in that it signals an invalid numeric exeception
 only if an operand is an sNaN, whereas COMISS does so also if an operand
 is a qNaN.
 
\layout Standard
\align left 

\series bold 
\size large 
A.259 UNPCKHPS: Unpack High Packed Single-FP Data
\layout Standard
\align left 

\size footnotesize 
UNPCKHPS xmmreg,r/m128 ; 0F 15 /r [KATMAI,SSE]
\layout Standard
\align left 
UNPCKHPS performs an interleaved unpack of the high-order data elements
 of the two operands in the following manner: labelling the data elements
 of the destination register as X0, X1, X2 and X3 (from low to high) and
 those of the source operand as Y0, Y1, Y2 and Y3 the UNPCKHPS instruction
 simultaneously performs the four assignments X0 := X2, X1 := Y2, X2 :=
 X3 and X3 := Y3.
 
\layout Standard
\align left 

\series bold 
\size large 
A.260 UNPCKLPS: Unpack Low Packed Single-FP Data
\layout Standard
\align left 

\size footnotesize 
UNPCKLPS xmmreg,r/m128 ; 0F 14 /r [KATMAI,SSE]
\layout Standard
\align left 
UNPCKLPS performs an interleaved unpack of the low-order data elements of
 the two operands in the following manner: labelling the data elements of
 the destination register as X0, X1, X2 and X3 (from low to high) and those
 of the source operand as Y0, Y1, Y2 and Y3 the UNPCKLPS instruction simultaneou
sly performs the four assignments X0 := X0, X1 := Y0, X2 := X1 and X3 :=
 Y1.
 
\layout Standard
\align left 

\series bold 
\size large 
A.269 XLATB: Translate Byte in Lookup Table
\layout Standard
\align left 

\size footnotesize 
XLATB ; D7 [8086]
\layout Standard
\align left 
XLATB adds the value in AL, treated as an unsigned byte, to BX or EBX, and
 loads the byte from the resulting address (in the segment specified by
 DS) back into AL.
 
\layout Standard
\align left 
The base register used is BX if the address size is 16 bits, and EBX if
 it is 32 bits.
 If you need to use an address size not equal to the current BITS setting,
 you can use an explicit a16 or a32 prefix.
 
\layout Standard
\align left 
The segment register used to load from [BX+AL] or [EBX+AL] can be overridden
 by using a segment register name as a prefix (for example, es xlatb).
 
\layout Standard
\align left 

\series bold 
\size large 
A.271 XORPS: SSE Bitwise Logical XOR
\layout Standard
\align left 

\size footnotesize 
XORPS xmmreg,r/m128 ; 0F 57 /r [KATMAI,SSE]
\layout Standard
\align left 
XORPS performs a bitwise XOR operation on the source operand and the destination
 register, and stores the result in the destination register.
 
\layout Standard
\align center 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{Previous Chapter }}
\end_inset 

| 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{Contents }}
\end_inset 

| 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
uline{
\backslash 
textcolor[rgb]{0.000,0.000,1.000}{Index }}
\end_inset 


\the_end
