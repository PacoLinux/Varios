%% LyX 1.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass{article}
\usepackage[T1]{fontenc}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}
%% Special footnote code from the package 'stblftnt.sty'
%% Author: Robin Fairbairns -- Last revised Dec 13 1996
\let\SF@@footnote\footnote
\def\footnote{\ifx\protect\@typeset@protect
    \expandafter\SF@@footnote
  \else
    \expandafter\SF@gobble@opt
  \fi
}
\expandafter\def\csname SF@gobble@opt \endcsname{\@ifnextchar[%]
  \SF@gobble@twobracket
  \@gobble
}
\edef\SF@gobble@opt{\noexpand\protect
  \expandafter\noexpand\csname SF@gobble@opt \endcsname}
\def\SF@gobble@twobracket[#1]#2{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \newenvironment{lyxlist}[1]
   {\begin{list}{}
     {\settowidth{\labelwidth}{#1}
      \setlength{\leftmargin}{\labelwidth}
      \addtolength{\leftmargin}{\labelsep}
      \renewcommand{\makelabel}[1]{##1 \hfill}}}
   {\end{list}}
 \newenvironment{lyxcode}
   {\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \verbatim@font}%
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
<!entity header system "header.sgml">

\makeatother

\begin{document}


\vfill{}
\title{Vector Pascal}
\vfill{}


\date{Date }


\author{<firstname>Joe</firstname><surname>Doe</surname>}

\maketitle
\begin{abstract}
Vector Pascal is a dialect of Pascal designed to make efficient use of the multi-media
instructionsets of recent procesors. It supports data parallel operations and
saturated arithmetic. This manual describes the Vector Pascal language.
\end{abstract}

\section{First Section}

A number of widely used contemporary processors have instructionset extensions
for improved performance in multi-media applications. The aim is to allow operations
to proceed on multiple pixels each clock cycle. Such instructionsets have been
incorporated both in specialist DSP chips like the Texas C62xx\cite{Texas}
and in general purpose CPU chips like the Intel IA32\cite{Intel00} or the AMD
K6 \cite{AMD}.

These instructionset extensions are typically based on the Single Instruction-stream
Multiple Data-stream (SIMD\index{SIMD}) model in which a single instruction
causes the same mathematical operation to be carried out on several operands,
or pairs of operands at the same time. The level or parallelism supported ranges
from 2 floating point operations at a time on the AMD\index{AMD} K\index{K6}6
architecture to 16 byte operations at a time on the intel P4 architecture. Whilst
processor architectures are moving towards greater levels of parallelism, the
most widely used programming languages like C\index{C}, Java\index{Java} and
Delphi\index{Delphi} are structured around a model of computation in which
operations take place on a single value at a time. This was appropriate when
processors worked this way, but has become an impediment to programmers seeking
to make use of the performance offered by multi-media instructionsets.

Vector Pascal aims to provide an efficient and concise notation for programmers
using Multi-Media enhanced CPUs. In doing so it borrows concepts for expressing
data parallelism that have a long history, dating back to Iverson's work on
APL\index{APL} in the early '60s\cite{Iverson62}. 

The\-\textbackslash{}(T \textbackslash{})as having type \( T[] \). Then if
we have a binary operator \( \omega :(T\otimes T)\rightarrow T \), in languages
derived from APL we automatically have an operator \( \omega :(T[]\otimes T[])\rightarrow T[] \)
\(  \). Thus if \( x,y \) are arrays of integers \( k=x+y \) is the array
of integers where \( k_{i}=x_{i}+y_{i} \).

The basic concept is simple, there are complications to do with the semantics
of operations between arrays of different lengths and different dimensions,
but Iverson provides a consistent treatment of these. The most recent languages
to be built round this model are J\index{J}, an interpretive language\cite{Jmanual}\cite{Burke}\cite{Jintro},
and F\cite{Metcalf96} a modernised Fortran\index{Fortran}. In principle though
any language with array types can be extended in a similar way. Iverson's approach
to data parallelism is machine independent. It can be implemented using scalar
instructions or using the SIMD model. The only difference is speed. 

Vector Pascal incorporates Iverson's approach to data parallelism. Its aim is
to provide a notation that allows the natural and elegant expression of data
parallel algorithms within a base language that is already familiar to a considerable
body of programmers and combine this with modern compilation techniques. 

By an elegant algorithm I mean one which is expressed as concisely as possible.
Elegance is a goal that one approaches asymtotically, approaching but never
attaining\cite{Chaitin}. APL and J allow the construction of very elegant programs,
but at a cost. An inevitable consequence of elegance is the loss of redundancy.
APL programs are as concise, or even more concise than conventional mathematical
notation\cite{Iverson80} and use a special characterset. This makes them hard
for the uninitiated to understand. J attempts to remedy this by restricting
itself to the ASCII characterset, but still looks dauntingly unfamiliar to programmers
brought up on more conventional languages. Both APL and J are interpretive which
makes them ill suited to many of the applications for which SIMD speed is required.
The aim of Vector Pascal is to provide the conceptual gains of Iverson's notation
within a framework familiar to imperative programmers.

Pascal\index{Pascal}\cite{Jensen}was chosen as a base language over the alternatives
of C and Java. C was rejected because notations like \texttt{x+y} for \texttt{x}
and \texttt{y} declared as \texttt{int x{[}4{]},y{[}4{]}}, already have the
meaning of adding the addresses of the arrays together. Java was rejected because
of the difficulty of efficiently transmitting data parallel operations via its
intermediate code to a just in time code generator. 

Iverson's approach to data parallelism is machine independent. It can be implemented
using scalar instructions or using the SIMD\index{SIMD} model. The only difference
is speed. Vector Pascal incorporates Iverson's approach to data parallelism.


\section{Alphabet}

In what follows examples and reserved words of Vector Pascal will be denoted
in bold face. Vector Pascal programs are made up of letter, digits and special
symbols.
\begin{table}

\caption{The letters of Vector Pascal\label{letters}.}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline 
A&
B&
C&
D&
E&
F&
G&
H&
I&
J&
K&
L&
M\\
\hline 
\hline 
N&
O&
P&
Q&
R&
S&
T&
U&
V&
W&
X&
Y&
Z\\
\hline 
a&
b&
c&
d&
e&
f&
g&
h&
i&
j&
k&
l&
m\\
\hline 
n&
o&
p&
q&
r&
s&
t&
u&
v&
w&
x&
y&
z\\
\hline 
\end{tabular}\par}\end{table}
 The digits are shown in table \ref{digits}.
\begin{table}

\caption{The digits of Vector Pascal.\label{digits}}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline 
0&
1&
2&
3&
4&
5&
6&
7&
8&
9\\
\hline 
\end{tabular}\par}\end{table}
 The special symbols are shown in table\ref{specials} .
\begin{table}

\caption{Special symbols\label{specials}}
\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
+&
:&
(\\
\hline 
-&
'&
)\\
\hline 
{*}&
=&
{[}\\
\hline 
/&
<>&
{]}\\
\hline 
:=&
<&
\{\\
\hline 
.&
<=&
\}\\
\hline 
,&
>=&
\textasciicircum{}\\
\hline 
;&
>&
..\\
\hline 
+:&
@&
{*})\\
\hline 
-:&
\$&
({*}\\
\hline 
\_&
{*}{*}&
\\
\hline 
\end{tabular}\par}\vspace{0.3cm}
\end{table}



\section{Reserved words}

The reserved words are

\textbf{ABS, ADDR, AND, ARRAY,}

\textbf{BEGIN,}

\textbf{CASE, CHR, CONST, COS,}

\textbf{DISPOSE, DIV, DO, DOWNTO,}

\textbf{END, ELSE, EXIT,}

\textbf{FALSE, FILE, FOR, FUNCTION,}

\textbf{GOTO,}

\textbf{IF, IMPLEMENTATION, IN, INTERFACE, IOTA,}

\textbf{LABEL, LIBRARY, LN,}

\textbf{MAX, MIN, MOD,}

\textbf{NEW, NOT,}

\textbf{OF, OR, ORD,}

\textbf{PACKED, POW,PRED, PROCEDURE, PROGRAM,}

\textbf{READ, READLN, RECORD, REPEAT, ROUND,}

\textbf{SET, SHL, SHR, SIN, SIZEOF, STRING, SQRT, SUCC,}

\textbf{TAN, THEN, TO, TRANS, TRUE, TYPE,}

\textbf{VAR,}

\textbf{WITH, WHILE, WRITE, WRITELN,}

\textbf{UNIT, UNTIL, USES }

Reserved words may be written in either lower case or upper case letters, or
any combination of the two. 


\section{Comments}

The comment\index{comment} construct 

\textbf{\{\index{}} < any sequence of characters not containing ``\}'' >
\textbf{\}} 

may be inserted between any two identifiers, special symbols, numbers or reserved
words without altering the semantics or syntactic correctness of the program.
The bracketing pair \textbf{({*} {*})\index{*)}} may substitute for \textbf{\{
\}}. Where a comment starts with \textbf{\{} it continues until the next \textbf{\}}.
Where it starts with \textbf{({*}\index{(*}} it must be terminated by \textbf{{*})}\footnote{%
Note this differs from ISO Pascal which allows a comment starting with \{ to
terminate with {*}) and vice versa.
}.


\section{Identifiers}

Identifiers are used to name values, storage locations, programs, program modules,
types, procedures and functions. An identifier\index{identifier} starts with
a letter followed by zero or more letters, digits or the special symbol \textbf{\_}.
Case is not significant in identifiers.


\section{Literals}


\subsection{Integer numbers}

Integer numbers are formed of a sequence of decimal digits, thus \textbf{1},
\textbf{23}, \textbf{9976} etc, or as hexadecimal\index{hexadecimal} numbers,
or as numbers of any base between 2 and 36. A hexadecimal number takes the form
of a \textbf{\$} followed by a sequence of hexadecimal digits thus \textbf{\$01,
\$3ff, \$5A}. The letters in a hexadecimal number may be upper or lower case
and drawn from the range \textbf{a..f} or \textbf{A..F. }

A based integer\index{integer} is written with the base first followed by a
\# character and then a sequence of letters or digits. Thus \textbf{2\#1101}
is a binary number \textbf{8\#67} an octal\index{octal} number and \textbf{20\#7i}
a base 20 number.

The default precision for integers is 32 bits\footnote{%
The notation used for grammar definition is a tabularised BNF . Each boxed table
defines a production, with the production name in the left column. Each line
in the right column is an alternative for the production. The metasymbol + indicates
one or more repetitions of what immediately preceeds it. The Kleene star {*}
is used for zero or more repetitions. Terminal symbols are in single quotes.
Sequences in brackets {[} {]} are optional.
}.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<digit sequence>&
<digit> +\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<decimal integer>&
<digit sequence>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<hex integer>&
`\$'<hexdigit>+\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<based integer> &
<digit sequence>'\#'<alphanumeric>+\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unsigned integer>&
<decimal integer>\\
&
<hex integer>\\
&
<based integer>\\
\hline 
\end{tabular}
\begin{table}

\caption{The hexadecimal digits of Vector Pascal.}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline 
Value&
0&
1&
2&
3&
4&
5&
6&
7&
8&
9&
10&
11&
12&
13&
14&
15\\
\hline 
Notation 1&
0&
1&
2&
3&
4&
5&
6&
7&
8&
9&
A&
B&
C&
D&
E&
F\\
\hline 
Notation 2&
&
&
&
&
&
&
&
&
&
&
a&
b&
c&
d&
e&
f\\
\hline 
\end{tabular}\par}
.
\end{table}
 \par}
\vspace{0.3cm}


\subsection{Real numbers}

Real numbers are supported in floating point notation, thus \textbf{14.7, 9.99e5,
38E3, 3.6e-4} are all valid denotations for real\index{real} numbers. The default
precision for real numbers is also 32 bit, though intermediate calculations
may use higher precision. The choice of 32 bits as the default precision is
influenced by the fact that 32 bit floating point vector operations are well
supported in multi-media\index{media} instructions.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<exp>&
`e'\\
&
`E'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<scale factor>&
{[}<sign>{]} <unsigned integer>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<sign>&
`-'\\
&
`+'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unsigned real>&
<decimal integer> `.' <digit sequence>\\
&
<decimal integer>` .' <digit sequence> <exp><scale factor> \\
&
<decimal integer><exp> <scale factor>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Character strings}

Sequences of characters enclosed by quotes are called literal\index{literal}
strings. Literal strings\index{strings} consisting of a single character are
constants of the standard type char. If the string is to contain a quote character
this quote character must be written twice.

\textbf{\small 'A' 'x' 'hello' 'John''s house'}{\small \par}

are all valid literal strings. The allowable characters in literal strings are:

\texttt{'} \texttt{\small ' '!' '\char`\"{}' '\#' '\$' '\%' '\&' ''' '(' ')'
'{*}' '+' ',' '-' '.' '/', }{\small \par}

\texttt{\small '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' ':' ';' '<' '=' '>' '?', }{\small \par}

\texttt{\small '@' 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O', }{\small \par}

\texttt{\small 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z' '{[}' '\textbackslash{}'
'{]}' '\textasciicircum{}' '\_', }{\small \par}

\texttt{\small '`' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o', }{\small \par}

\texttt{\small 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '\{' '|' '\}' '\textasciitilde{}'}{\small \par}


\section{Declarations}

Vector Pascal is a language supporting nested declaration\index{declaration}
contexts. A declaration context is either a program context, and unit interface
or implementation context, or a procedure or function context. A resolution
context determines the meaning of an identifier. Within a resolution context,
identifiers can be declared to stand for constants, types, variables, procedures
or functions. When an identifier is used, the meaning taken on by the identifier
is that given in the closest containing resolution context. Resolution contexts
are any declaration context or a \textbf{with} statement context. The ordering
of these contexts when resolving an identifier is:

\begin{enumerate}
\item The declaration context identified by any \textbf{with} statements which nest
the current occurence of the identifier. These \textbf{with} statement contexts
are searched from the innermost to the outermost.
\item The declaration context of the currently nested procedure\index{procedure}
declarations. These procedure contexts are searched from the innermost to the
outermost.
\item The declaration context of the current unit\index{unit} or program\index{program}.
\item The interface declaration contexts of the units mentioned in the use list of
the current unit or program. These contexts are searched from the rightmost
unit mentioned in the use list to the leftmost identifier in the use list.
\item The interface declartion context of the System\index{System} unit.
\item The pre-declared identifiers of the language.
\end{enumerate}



\subsection{Constants}

A constant definition introduces an identifier as a synonym for a constant. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<constant declaration>&
<identifier>=<expression>\\
&
<identifier>':'<type>'='<typed constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Constants can be simple constants or typed constants. A simple constant must
be a constant expression whose value is known at compile time. This restricts
it to expressions for which all component identifiers are other constants, and
for which the permitted operators\index{operators} are given in table\ref{MMConst}
. This restricts simple constants to be of scalar or string types.

\begin{table}

\caption{The operators permitted in Vector Pascal constant expressions.\label{MMConst}}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline 
+&
-&
{*}&
/&
div&
mod&
shr&
shl&
and&
or\\
\hline 
\end{tabular}\par}\end{table}
Typed constants provide the program with initialised variables which may hold
array types.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<typed constant>&
<expression>\\
&
<array constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Array constants}

Array constants are comma separated lists of constant expressions enclosed by
brackets. Thus 

\textbf{tr:array{[}1..3{]} of real =(1.0,1.0,2.0);}

is a valid array constant declaration, as is:

\textbf{t2:array{[}1..2,1..3{]} of real=((1.0,2.0,4.0),(1.0,3.0,9.0));}

The array constant\index{constant}\index{array constant} must structurally
match the type\index{type} given to the identifier. That is to say it must
match with respect to number of dimensions, length of each dimension, and type
of the array elements.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<array constant>&
'(' <typed constant> {[},<typed constant>{]}{*} ')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Predeclared constants\index{constants}}

\begin{lyxlist}{00.00.0000}
\item [\textbf{maxint\index{maxint}}]The largest supported integer value.
\item [\textbf{pi\index{pi}}] A real numbered approximation to \( \pi  \)
\item [\textbf{maxchar\index{maxchar}}] The highest character in the character set.
\item [\textbf{maxstring\index{maxstring}}]The maximum number of characters allowed
in a string.
\item [\textbf{maxreal\index{maxreal}}]The highest representable real. 
\item [\textbf{minreal\index{minreal}}]The smallest representable positive real number. 
\item [\textbf{epsreal\index{epsreal}}]The smallest real number which when added
to 1.0 yields a value distinguishable from 1.0. 
\item [\textbf{maxdouble\index{maxdouble}}]The highest representable double precision
real number.
\item [\textbf{mindouble\index{mindouble}}]The smallest representable positive double
precision real number.
\end{lyxlist}

\subsection{Labels}

Labels are written as digit sequences. Labels must be declared before they are
used. They can be used to label the start of a statement and can be the destination
of a \textbf{goto\index{goto}} statement. A \textbf{goto} statement must have
as its destination a label\index{label} declared within the current innermost
declaration context. A statement can be prefixec by a label followed by a colon.

Example

\textbf{label 99;}

\textbf{begin read(x); if x>9 goto 99; write(x{*}2);99: end;}


\subsection{Types}

A type declaration determines the set of values that expressions of this type
may assume and associates with this set an identifier.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<type>&
<simple type>\\
&
<structured type>\\
&
<pointer type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<type definition>&
<identifier>'='<type> \\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Simple types}

Simple types are either scalar, standard, subrange or dimensioned types.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<simple type>&
<scalar type>\\
&
<integral type>\\
&
<subrange type>\\
&
<dimensioned type>\\
&
<floating point type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Scalar types}

A scalar\index{scalar} type\index{type} defines an ordered set of identifier
by listing these identifiers. The declaration takes the form of a comma separated
list of identifiers enclosed by brackets. The identifiers in the list are declared
simultaneously with the declared scalar type to be constants of this declared
scalar type. Thus 

\textbf{colour = (red,green,blue);}

\textbf{day=(monday,tuesday,wednesday,thursday,friday,saturday,sunday);}

are valid scalar type declarations.


\subsubsection{Standard types}

The following types are provided as standard in Vector Pascal:
\begin{table}

\caption{Categorisation of the standard types.}
{\centering \begin{tabular}{|c|c|}
\hline 
type&
category\\
\hline 
\hline 
real&
floating point\\
\hline 
double&
floating point\\
\hline 
byte&
integral\\
\hline 
shortint&
integral\\
\hline 
word&
integral\\
\hline 
integer&
integral\\
\hline 
cardinal&
integral\\
\hline 
boolean&
scalar\\
\hline 
char&
scalar\\
\hline 
\end{tabular}\par}\end{table}


\begin{lyxlist}{00.00.0000}
\item [\textbf{integer\index{integer}}]The numbers are in the range -maxint to +maxint.
\item [\textbf{real\index{real}}]These are a subset of the reals constrained by the
IEEE 32 bit floating point format.
\item [\textbf{double\index{double}}]These are a subset of the real numbers constrained
by the IEEE\index{IEEE} 64 bit floating point format.
\item [\textbf{boolean\index{boolean}}]These take on the values \textbf{(false\index{false},true\index{true})}
which are ordered such that \textbf{true<false}. 
\item [\textbf{char\index{char}}]These include the characters from \textbf{chr(0)}
to \textbf{charmax}\index{charmax}. All the allowed characters for string literals
are in the type char, but the characterset may include other characters whose
printable form is country specific. 
\item [\textbf{byte\index{byte}}]These take on the positive integers between 0 and
255.
\item [\textbf{shortint\index{shortint}}]These take on the signed values between
-128 and 127.
\item [\textbf{word\index{word}}]These take on the positive integers from 0 to 65535.
\item [\textbf{cardinal\index{cardinal}}]These take on the positive integers form
0 to 4292967295, i.e., the most that can be represented in a 32 bit unsigned
number.
\item [\textbf{longint\index{longint}}]A 64 bit integer.
\end{lyxlist}

\subsubsection{Subrange types}

A type may be declared as a subrange\index{subrange} of another scalar\index{scalar}
or integer\index{integer} type by indicating the largest and smallest value
in the subrange. These values must be constants known at compile time.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<subrange type>&
<constant> '..' <constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Examples: 1..10, 'a'..'f', monday..thursday.


\subsubsection{Dimensioned types}

These provide a means by which floating point types can be specialised to represent
dimensioned numbers as is required in physics calculations. For example:

\textbf{kms =(mass,distance,time);}

\textbf{meter=real of distance;}

\textbf{kilo=real of mass;}

\textbf{second=real of time;}

\textbf{newton=real of mass {*} distance {*} time POW -2;}

\textbf{meterpersecond = real of distance {*}time POW -1;}

The grammar is given by:

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<dimensioned type>&
<real type> <dimension >{[}'{*}' <dimension>{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<real type>&
'real'\\
&
'double'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<dimension>&
<identifier> {[}'POW' {[}<sign>{]} <unsigned integer>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The identifier\index{identifier} must be a member of a scalar type, and that
scalar type is then refered to as the basis space of the dimensioned type. The
identifiers of the basis\index{basis} space are refered to as the dimensions
of the dimensioned type\index{type}. Associated with each dimension of a dimensioned
type there is an integer number refered to as the power of that dimension. This
is either introduced explicitly at type declaration time, or determined implicitly
for the dimensional type of expressions. 

A value of a dimensioned type is a dimensioned value. Let \( \log _{d}t \)
of a dimensioned type \( t \) be the power to which the dimension \( d \)
of type \( t \) is raised. Thus for \( t= \)newton in the example above, and
\( d= \)time, \( \log _{d}t=-2 \)

If \( x \) and \( y \) are values of dimensioned\index{dimensioned} types
\( t_{x} \)and \( t_{y} \)respectively, then the following operators are only
permissible if \( t_{x}=t_{y} \)

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
+&
-&
<&
>&
<>&
=&
<=&
>=\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

For + and -, the dimensional\index{dimensional} type of the result is the same
as that of the arguments. The operations 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
{*}&
/\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

are permited if the types \( t_{x} \)and \( t_{y} \) share the same basis
space, or if the basis space of one of the types is a subrange of the basis
space of the other.  

The operation \textbf{POW} is permited between dimensioned types and integers.


\paragraph*{Dimension deduction rules}

\begin{enumerate}
\item If \( x=y*z \) for \( x:t_{1},y:t_{2},z:t_{3} \) with basis space \( B \)
then \( \forall _{d\in B}\log _{d}t_{1}=\log _{d}t_{2}+\log _{d}t_{3} \). 
\item If \( x=y/z \) for \( x:t_{1},y:t_{2},z:t_{3} \) with basis space \( B \)
then \( \forall _{d\in B}\log _{d}t_{1}=\log _{d}t_{2}-\log _{d}t_{3} \). 
\item If \( x=y \) \textbf{POW} \( z \) for \( x:t_{1},y:t_{2},z:integer \) with
basis space for \( t_{2} \), \( B \) then \( \forall _{d\in B}\log _{d}t_{1}=\log _{d}t_{2}\times z \). 
\end{enumerate}

\subsection{Stuctured types}


\subsubsection{Static Array\index{array}\index{array, static} types}

An array type is a structure consisting of a fixed number of elements all of
which are the same type. The type of the elements is refered to as the element
type. The elements of an array value are indicated by bracketed indexing expressions.
The definition of an array\index{array} type\index{type} simultaneously defines
the permited type of indexing expression and the element type. 

The index\index{index} type\index{type} of a static\index{static} array\index{array, static}
must be a scalar\index{scalar} or subrange\index{subrange} type. This implies
that the bounds of a static array are known at compile time.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<array type>&
'array' '{[}' <index type>{[},<index type>{]}{*} '{]}' 'of' <type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<index type>&
<subrange type>\\
&
<scalar type>\\
&
<integral type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Examples

\textbf{array{[}colour{]} of boolean;}

\textbf{array{[}1..100{]} of integer;}

\textbf{array{[}1..2,4..6{]} of byte;}

\textbf{array{[}1..2{]} of array{[}4..6{]} of byte;}

The notation {[}\emph{b,c}{]} in an array declaration is shorthand for the notation
{[}\emph{b}{]}\textbf{of array}{[}\emph{c}{]}. The number of dimensions of an
array type is refered to as its rank. Scalar types have rank 0.


\subsubsection{String types}

A string\index{string} type denotes the set of all sequences of characters
up to some finite length and must have the syntactic form:

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<string-type>&
'string{[}' <integer constant>'{]}'\\
&
'string'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

the integer constant indicates the maximum number of characters that may be
held in the string type. The maximum number of characters that can be held in
any string is indicated by the predeclared constant \textbf{maxstring}. The
type \textbf{string} is shorthand for \textbf{string{[}maxstring{]}}.


\subsubsection{Record types}

A record type defines a set of simlar data structures. Each member of this set,
a record instance, is a cartesian product of number of components or \emph{fields}
specified in the record\index{record} type definition. Each field has an identifier
and a type. The scope of these identifiers is the record itself.

A record type may have as a final component a \emph{variant\index{variant}
part}. The variant part, if a variant part exists, is a union of several variants,
each of which may itself be a cartesian product of a set of fields. If a variant
part exists there may be a tag field whose value indicates which variant is
assumed by the record instance.

All field identifiers even if they occur within different variant parts, must
be unique within the record type.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<record type>&
'record' <field list> 'end'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<field list>&
<fixed part>\\
&
<fixed part>';' <variant part>\\
&
<variant part>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<fixed part>&
<record section> {[} ';' <record section.{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<record section>&
<identifier>{[}',' <identifier>{]}{*} ':' <type>\\
&
<empty>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variant part>&
'case' {[}<tag field> ':'{]} <type identifier> 'of'<variant>{[}';' <variant>{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variant>&
<constant> {[}',' <constant>{]}{*}':' '(' <field list> ')'\\
&
<empty>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Set types}

A set\index{set} type defines the range of values which is the powerset of
its base type. The base type must be a scalar type, a character type, integer
type or a subrange thereof.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<set type>&
'set' 'of' <base type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Dynamic\index{Dynamic} types}

Variables declared within the program are accessed by their identifier. These
variables exist throughout the existence of the scope within which they are
declared, be this unit, program or procedure. These variables are assigned storage
locations whose addresses, either absolute or relative to some register, can
be determined at compile time. Such locations a refered to as static\index{static}\footnote{%
The Pascal concept of static variables should not be equated with the notion
of static variables in some other languages such as C or Java. In Pascal a variable
is considered static if its offset either relative to the stack base or relative
to the start of the global segment can be determined at compile/link time. In
C a variable is static only if its location relative to the start of the global
segment is known at compile time.
}. Storage locations may also be allocated dynamically. Given a type \textbf{t},
the type of a pointer\index{pointer} to an instance of type \textbf{t} is \textbf{\textasciicircum{}t}. 

A pointer of type \textbf{\textasciicircum{}t} can be initialised to point to
a new store location of type t by use of the built in procedure \textbf{new}.
Thus if \textbf{p:\textasciicircum{}t},

\textbf{new(p);}

causes \textbf{p} to point at a store location of type \textbf{t}.


\subsubsection*{Pointers to dynamic\index{dynamic}\index{dynamic array} arrays\index{array, dynamic}\index{array}}

The types pointed to by pointer types can be any of the types mentioned so far,
that is to say, any of the types allowed for static\index{static} variables.
In addition however, pointer types can be declared to point at dynamic arrays.
A dynamic array is an array whose bounds are determined at run time.

Pascal\index{Pascal90} 90\cite{ISO90} introduced the notion of schematic or
parameterised types as a means of creating dynamic arrays. Thus where \textbf{r}
is some integral or ordinal type one can write 

\textbf{type z(a,b:r)=array{[}a..b{]} of t;}

If \textbf{p:\textasciicircum{}z}, then 

\textbf{new(p,n,m)}

where \textbf{n,m:r} initialises \textbf{p} to point to an array of bounds \textbf{n..m}.
The bounds of the array can then be accessed as \textbf{p\textasciicircum{}.a,
p\textasciicircum{}.b}. Vector Pascal currently allows dynamic but not static\index{static}
parameterised types.


\subsection{Variables\index{Variables}}

Variable declarations consist of a list of identifiers denoting the new variables,
followed by their types.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variable declaration>&
<identifer> {[}',' <identifier>{]}{*} ':' <type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Variables are abstractions over values. They can be either simple identifiers,
components or ranges of components of arrays, fields of records or referenced
dynamic variables.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variable>&
<identifier>\\
&
<indexed variable>\\
&
<indexed range>\\
&
<field designator>\\
&
<referenced variable>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Examples

\textbf{x,y:real;}

\textbf{i:integer;}

\textbf{point:\textasciicircum{}real;}

\textbf{dataset:array{[}1..n{]}of integer;}

\textbf{twoDdata:array{[}1..n,4..7{]} of real;}


\subsubsection{Entire Variables}

An entire variable is denoted by its identifier. Examples \textbf{x,y,point}, 


\subsubsection{Indexed Variables}

A component of an \emph{n} dimensional array variable is denoted by the variable
followed by \emph{n} index expressions in brackets.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<indexed variable>&
<variable>'{[}' <expression>{[}','<expression>{]}{*} '{]}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The type of the indexing expression must conform to the index type of the array
variable. The type of the indexed variable is the component type of the array.

Examples

\textbf{twoDdata{[}2,6{]}}

\textbf{dataset{[}i{]}}

Given the declaration 

\textbf{a=array{[}p{]} of q}

then the elements of arrays of type \textbf{a}, will have type \textbf{q} and
will be identified by indices\index{indices} of type \textbf{p} thus:

\textbf{b{[}i{]}}

where \textbf{i:p}, \textbf{b:a}.

Given the declaration

\textbf{z = string{[}x{]}}

for some integer x \textbf{\( \leq  \)maxstring}, then the characters within
strings\index{strings} of type \textbf{z} will be identified by indices in
the range \textbf{1..x,} thus:

\textbf{y{[}j{]}}

where \textbf{y:z}, \textbf{j:1..x}.


\subsubsection{Indexed Ranges}

A range of components of an array variable are denoted by the variable followed
by a range expression in brackets.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<indexed range>&
<variable> '{[}' <range expression>{[}',' <range expression>{]}{*} '{]}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<range expression>&
<expression> '..' <expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The expressions within the range\index{range} expression must conform to the
index type of the array variable. The type of a range expression \textbf{a{[}i..j{]}}
where \textbf{a: array{[}p..q{]} of t} is \textbf{array{[}0..j-i{]} of t.}

Examples:

\textbf{dataset{[}i..i+2{]}:=blank;}

\textbf{twoDdata{[}2..3,5..6{]}:=twoDdata{[}4..5,11..12{]}{*}0.5;}

Subranges\index{Subranges} may be passed in as actual parameters to procedures
whose corresponding formal parameters\index{parameters} are declared as variables
of a schematic\index{schematic} type. Hence given the following declarations:

\textbf{type image(miny,maxy,minx,maxx:integer)=array{[}miny..maxy,minx..maxx{]}
of byte;}

\textbf{procedure invert(var im:image);begin im:=255-im; end;}

\textbf{var screen:array{[}0..319,0..199{]} of byte;}

then the following statement would be valid:

\textbf{invert(screen{[}40..60,20..30{]});}


\subsubsection{Virtual\index{Virtual} array variables}

If an array\index{array} variable occurs on the right hand side of an assignment
statement, there is a further form of indexing possible. An array may be indexed
by another array. If \textbf{x:array{[}t0{]} of t1} and \textbf{y:array{[}t1{]}
of t2}, then \textbf{y{[}x{]}} denotes the virtual array of type \textbf{array{[}t0{]}
of t2} such that \textbf{y{[}x{]}{[}i{]}=y{[}x{[}i{]}{]}}. This construct is
useful for performing permutations. To fully understand the following example
refer to sections \ref{iota},\ref{implicitindices}.


\paragraph{Example}

Given the declarations

\textbf{const perm:array{[}0..3{]} of integer=(3,1,2,0);}

\textbf{var ma,m0:array{[}0..3{]} of integer; }

then the statements

\textbf{m0:= (iota 0)+1;}

\textbf{write('m0=');for j:=0 to 3 do write(m0{[}j{]});writeln;}

\textbf{ma:=m0{[}perm{]}; }

\textbf{write('perm=');for j:=0 to 3 do write(perm{[}j{]});writeln; }

\textbf{writeln('ma:=m0{[}perm{]}');for j:=0 to 3 do write(ma{[}j{]});writeln;}

would produce the output 

\begin{lyxcode}
m0=~1~2~3~4

perm=~~3~1~2~0~

ma:=m0{[}perm{]}~

4~2~3~1
\end{lyxcode}

\subsubsection{Field\index{Field} Designators}

A component of an instance of a record type, or the parameters of an instance
of a schematic type are denoted by the record or schematic type instance followed
by the field or parameter name.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<field designator>&
<variable>'.'<identifier>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Referenced Variables\index{Variables}}

If \textbf{p:\textasciicircum{}t}, then \textbf{p\textasciicircum{}} denotes
the dynamic variable of type \textbf{t} referenced by \textbf{p}.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<referenced variable>&
<variable> '\textasciicircum{}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Procedures and Functions}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<procedure declaration>&
<procedure heading>';'{[}<proc tail>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
<proc tail>&
'forward'&
must be followed by defintion of procedure body\\
\hline 
\hline 
&
'external'&
imports a non Pascal prodcedure\\
\hline 
&
<block>&
procedure implemented here\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<procedure heading> &
'procedure' <identifer> {[}'('<formal parameter section>{[}';'<formal parameter
section>{]}{*}')'{]}\\
&
'function'<identifer> {[}'('<formal parameter section>{[}';'<formal parameter
secection>{]}{*}')'{]}':'<type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<formal parameter section>&
{[}'var'{]}<identifier>{[}','<identifier>{]}':'<type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Procedure and function declarations allow algorithms to be identified by name
and have arguments associated with them so that they may be invoked by procedure
statements or function calls. The parameters declared in the procedure heading
are local to the scope of the procedure. The parameters in the procedure heading
are termed formal\index{formal parameter} parameters. If the identifiers in
a formal parameter section are preceded by the word \textbf{var}, then the formal
parameters are termed variable parameters. The block\footnote{%
see section \ref{block}.
} of a procedure or function constitutes a scope local to its executable compound
statement. Within a function declaration there must be at least one statement
assigning a value to the function identifier. This assignment determines the
result of a function, but assignment to this identifier does not cause an immediate
return from the function. 


\paragraph{Examples}

The function sba is the mirror image of the abs function.

\textbf{function sba(i:integer):integer; }

\textbf{begin if i>o then sba:=-i else sba:=i end;}

\textbf{type stack:array{[}0..100{]} of integer;}

\textbf{procedure push(var s:stack;i:integer);}

\textbf{begin s{[}s{[}0{]}{]}:=i;s{[}0{]}:=s{[}0{]}+1; end;}


\section{Expressions\index{Expressions}}

An expression is a rule for computing a value by the application of operators
and functions to other values. These operators can be \emph{monadic} - taking
a single argument, or \emph{dyadic} - taking two arguments. 


\subsection{Mixed type expressions}

The arithmetic operators are defined over the base types integer and real. If
a dyadic operator that can take either real\index{real} or integer\index{integer}
arguments is applied to arguments one of which is an integer and the other a
real, the integer argument is first implicitly converted to a real before the
operator is applied. Similarly, if a dyadic operator is applied to two integral
numbers of different precision, the number of lower precision is initially converted
to the higher precisions, and the result is of the higher precision. Higher
precision of types \emph{t,u} is defined such that if either has the greater
number of 


\subsection{Primary expressions}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<primary expression> &
'(' <expression> ')'\\
&
<literal string>\\
&
'true'\\
&
'false'\\
&
<unsigned integer>\\
&
<unsigned real>\\
&
<variable>\\
&
<constant id>\\
&
<function call>\\
&
<set construction>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The most primitive expressions are instances of the literals defined in the
language: literal strings, boolean literals, literal reals and literal integers.
'Salerno', \textbf{true}, 12, \$ea8f, 1.2e9 are all primary expressions. The
next level of abstraction is provided by symbolic identifiers for values. \textbf{X},
\textbf{left}, \textbf{a.max}, \textbf{p\textasciicircum{}.next}, \textbf{z{[}1{]}},
\textbf{image{[}4..200,100..150{]}} are all primary expressions provided that
the identifiers have been delared as variables or constants.

An expression surrounded by brackets \textbf{( )} is also a primary expression.
Thus if \emph{e} is an expression so is \textbf{(} \emph{e} \textbf{)}. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<function call>&
<function id> {[} '(' <expression> {[},<expression>{]}{*} ')' {]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<element>&
<expression>\\
&
<range expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Let \emph{e} be an expression of type \( t_{1} \) and if \textbf{f} is an identifier
of type \textbf{function\index{function}(\( t_{1} \) ):\( t_{2} \)}, then
\textbf{f(} \emph{e} \textbf{)} is a primary expression of type \( t_{2} \).
A function which takes no parameters is invoked without following its identifier
by brackets. It will be an error if any of the actual parameters supplied to
a function are incompatible with the formal parameters declared for the function.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<set construction>&
'{[}' {[}<element>{[},<element>{]}{*}{]} '{]}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Finally a primary expression may be a set construction. A set construction is
written as a sequence of zero or more elements enclosed in brackets \textbf{{[}
{]}} and separated by commas. The elements themselves are either expressions
evaluating to single values or range expressions denoting a sequence of consecutive
values. The type of a set construction is deduced by the compiler from the context
in which it occurs. A set construction occuring on the right hand side of an
assignment inherits the type of the variable to which it is being assigned.
The following are all valid set constructions:

\textbf{{[}{]}, {[}1..9{]}, {[}z..j,9{]}, {[}a,b,c,{]}}

\textbf{{[}{]}} denotes the empty set.


\subsection{Unary expressions}

A unary expression is formed by applying a unary operator to another unary or
primary expression. The unary operators supported are \textbf{+, -, {*}, /,
div\index{div}, mod\index{mod}, and\index{and}, or\index{or}, not\index{not},
round\index{round}, sqrt\index{sqrt}, sin\index{sin}, cos\index{cos}, tan\index{tan},
abs\index{abs}, ln\index{ln}, ord\index{ord}, chr\index{chr}, succ\index{succ},
pred\index{pred}, iota\index{iota}, trans\index{trans}, addr\index{addr}}
and \textbf{@}\index{@}.

Thus the following are valid unary expressions\textbf{: -1, +b, not true, sqrt
abs x, sin theta.} In standard Pascal some of these operators are treated as
functions,. Syntactically this means that their arguments must be enclosed in
brackets, as in \textbf{sin(theta)}. This usage remains syntactically correct
in Vector Pascal. 

The dyadic operators \textbf{+, -, {*}, /, div, mod , and or} are all extended
to unary context by the insertion of an implicit value under the operation.
Thus just as \textbf{-a = 0-a} so too \textbf{/2 = 1/2}. For sets the notation
\textbf{-s} means the complement of the set \textbf{s}. The implicit value inserted
are given below.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
type&
operators&
implicit value\\
\hline 
\hline 
number&
+,-&
0\\
\hline 
set\index{set}&
+&
empty set\\
\hline 
set&
-,{*}&
fullset\\
\hline 
number&
{*},/ ,div,mod&
1\\
\hline 
boolean\index{boolean}&
and&
true\\
\hline 
boolean&
or &
false\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

A unary operator can be applied to an array\index{array} argument and returns
an array result. Similarly any user declared function over a scalar\index{scalar}
type can be applied to an array type and return an array. If \textbf{f} is a
function or unary operator mapping from type \textbf{r} to type \textbf{t} then
if \textbf{x} is an array of \textbf{r,} and \textbf{a} an array of \textbf{t},
then \textbf{a:=f(x)} assigns an array of \textbf{t} such that \textbf{a{[}i{]}=f(x{[}i{]})}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c||l|}
\hline 
lhs of production&
rhs&
meaning\\
\hline 
<unaryop>&
'+'&
\textbf{+x = 0+x}\\
&
'-'&
\textbf{-x = 0-x}\\
&
'{*}'&
\textbf{{*}x=1{*}x}\\
&
'/'&
\textbf{/x=1.0/x}\\
&
'div'&
\textbf{div x =1 div x}\\
&
'mod'&
\textbf{mod x = 1 mod x}\\
&
'and'&
\textbf{and x = true and x}\\
&
'or'&
\textbf{or x = false or x}\\
&
'not'&
complements booleans\\
&
'round'&
rounds a real to the closest integer\\
&
'sqrt'&
returns square root as a real\index{real} number.\\
&
'sin'&
sine of its argument. Argument in radians. Result is real.\\
&
'cos'&
cosine of its argument. Argument in radians. Result is real.\\
&
'tan'&
tangent of its argument. Argument in radians. Result is real.\\
&
'abs'&
if \textbf{x<0} then \textbf{abs x = -x} else \textbf{abs x= x}\\
&
'ln'&
 \( \log _{e} \) of its argument. Result is real.\\
&
'ord'&
 argument of ordinal type, the returns ordinal number of the argument.\\
&
'chr'&
 converts an integer\index{integer} into a character\index{character}.\\
&
'succ'&
 argument of ordinal type, returns the next ordinal in the type.\\
&
'pred'&
argument of ordinal type it returns the previous ordinal in the type.\\
&
'iota'&
\textbf{iota i} returns the \textbf{i}th current index\index{index}\\
&
'trans'&
transposes a matrix\index{matrix} or vector\index{vector}\\
&
'@','addr'&
Given a variable, this returns an untyped pointer\index{pointer} to the variable.\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unary expression>&
<unaryop> <unary expression>\\
&
'sizeof' '(' <type> ')'\\
&
<operator reduction>\\
&
<primary expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{sizeof}

The construct \textbf{sizeof\index{sizeof}(} \emph{t} \textbf{)} where \emph{t}
is a type, returns the number of bytes\index{bytes} occupied by an instance
of the type.


\subsubsection{iota\label{iota}}

The operator iota i returns the ith current implicit index\footnote{%
See section \ref{implicitindices}.
}. 


\paragraph{Examples}

Thus given the definition 

\textbf{v1:array{[}1..3{]}of integer; v2:array{[}0..4{]}of integer;}

the program fragment

\textbf{v1:=iota 0; }

\textbf{writeln('v1'); for i:=1 to 3 do write( v1{[}i{]}); writeln; }

\textbf{v2:=iota 0 {*}2; }

\textbf{writeln('v2'); for i:=0 to 4 do write(v2{[}i{]}); writeln;}

would produce the output: 

\begin{lyxcode}
v1~

1~2~3~

v2~

0~2~4~6~8
\end{lyxcode}
whilst given the definitions

\textbf{m1:array{[}1..3,0..4{]} of integer;m2:array{[}0..4,1..3{]}of integer;}

then the program fragment 

\textbf{m2:= iota 0 +2{*}iota 1; }

\textbf{writeln('m2:= iota 0 +2{*}iota 1 '); }

\textbf{for i:=0 to 4 do begin for j:=1 to 3 do write(m2{[}i,j{]}); writeln;
end; }

would produce the output

\begin{lyxcode}
m2:=~iota~0~+2{*}iota~1~

2~4~6~

3~5~7~

4~6~8~

5~7~9~

6~8~10~~
\end{lyxcode}
The argument to iota\index{iota} must be an integer known at compile time within
the range of implicit indices in the current context.


\subsubsection{trans}

The operator trans\index{trans} transposes a vector or matrix. It achieves
this by cyclic rotation of the implicit indices\index{indices}\index{implicit indices}.
Thus if \textbf{trans} \emph{e} is evaluated in a context with implicit indices 

\textbf{iota} \emph{0}.. \textbf{iota} \emph{n }

then the expression e is evaluated in a context with implicit indices 

\textbf{iota}'\emph{0}.. \textbf{iota}'\emph{n} 

where 

\textbf{iota}'\emph{x} = \textbf{iota} ( (\emph{x+1})\textbf{mod} \emph{n+1})

It should be noted that transposition is generalised to arrays of rank greater
than 2.


\paragraph{Examples}

Given the defintions used above in section \ref{iota}, the program fragment:

\textbf{m1:= (trans v1){*}v2; }

\textbf{writeln('(trans v1){*}v2'); }

\textbf{for i:=1 to 3 do begin for j:=0 to 4 do write(m1{[}i,j{]}); writeln;
end; }

\textbf{m2 := trans m1; }

\textbf{writeln('transpose 1..3,0..4 matrix'); }

\textbf{for i:=0 to 4 do begin for j:=1 to 3 do write(m2{[}i,j{]}); writeln;
end;}

will produce the output:

\begin{lyxcode}
(trans~v1){*}v2~

0~~2~~4~~6~~8~

0~~4~~8~12~16~

0~~6~12~18~24~

transpose~1..3,0..4~matrix~

0~~0~~0~

2~~4~~6~

4~~8~12~

6~12~18~

8~16~24
\end{lyxcode}

\subsubsection{Operator Reduction}

Any dyadic operator can be converted to a monadic\index{monadic} reduction\index{reduction}
operator by the functional \textbackslash{}. Thus if \textbf{a} is an array,
\textbf{\textbackslash{}+a} denotes the sum over the array. More generally \( \setminus \Phi x \)
for some dyadic operator \( \Phi  \) means \( x_{0}\Phi (x_{1}\Phi ..(x_{n}\Phi \iota )) \)
where \( \iota  \) is the implicit value given the operator and the type. Thus
we can write \textbackslash{}+ for \( \sum  \), \textbackslash{}{*} for \( \prod  \)
etc. The dot product of two vectors can thus be written as

\textbf{x:= \textbackslash{}+ y{*}z;}

instead of

\textbf{x:=0;}

\textbf{for i:=0 to n do x:= x+ y{[}i{]}{*}z{[}i{]};}

A reduction operation takes an argument of rank\index{rank} \emph{r} and returns
an argument of rank \emph{r-1} except in the case where its argument is or rank
0, in which case it acts as the identity operation. Reduction is always performed
along the last array\index{array} dimension\index{dimension} of its argument. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<operator reduction>&
'\textbackslash{}'<dyadicop> <multiplicative expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<dyadicop>&
<expop>\\
&
<multop>\\
&
<addop>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Factor\index{Factor}}

A factor is an expression that optionally performs exponentiation. Vector Pascal
supports exponentiation either by integer exponents or by real exponents. A
number \emph{x} can be raised to an integral power \emph{y} by using the construction
\emph{x} \textbf{pow\index{pow}} \emph{y}. A number can be raised to an arbitrary
real power by the \textbf{{*}{*}} operator. The result of \textbf{{*}{*}\index{**}}
is always real valued.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<expop>&
'pow'\\
&
'{*}{*}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<factor>&
<unary expression> {[} <expop> <unary expression>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Multiplicative expressions}

Multiplicative expressions consist of factors linked by the multiplicative operators
\textbf{{*}, /, div\index{div}, mod\index{mod}, shr\index{shr}, shl\index{shl}
and}\index{and}. The use of these operators is sumarised in table \ref{multop}.

\begin{table}

\caption{Multiplicative operators\label{multop}}
{\centering \begin{tabular}{ccccc}
Operator&
Left&
Right&
Result&
Effect of \emph{a} \textbf{op} \emph{b}\\
\hline 
\textbf{{*}}&
integer&
integer&
integer&
multiply\\
&
real&
real&
real&
multiply\\
\textbf{/}&
integer&
integer&
real&
division\\
&
real&
real&
real&
division\\
\textbf{div}&
integer&
integer&
integer&
division\\
\textbf{mod}&
integer&
integer&
integer&
remainder\\
\textbf{and}&
boolean&
boolean&
boolean&
logical and\\
\textbf{shr}&
integer&
integer&
integer&
shift \emph{a} by \emph{b} bits right\\
\textbf{shl}&
integer&
integer&
integer&
shift \emph{a} by \emph{b} bits left\\
\textbf{in}&
\emph{t}&
\textbf{set of} \emph{t}&
boolean&
true if \emph{a} is member of \emph{b}\\
\hline 
\end{tabular}\par}\end{table}


\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<multop>&
'{*}'\\
&
'/'\\
&
'div'\\
&
'shr'\\
&
'shl'\\
&
'and'\\
&
'mod'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<multiplicative expression>&
<factor> {[} <multop> <factor> {]}{*}\\
&
<factor>'in'<multiplicative expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Additive expressions}

An additive expression allows multiplicative expressions to be combined using
the addition operators \textbf{+\index{+}, -\index{-}, or, +:\index{+:}\index{or},
-:}\index{-:}. The additive operations are sumarised in table\ref{addops}
.

\begin{table}

\caption{Addition operations\label{addops}}
{\centering \begin{tabular}{ccccc}
\hline 
Operation&
Left&
Right&
Result&
Effect of \emph{a} \textbf{op} \emph{b}\\
\hline 
\hline 
\textbf{+}&
integer&
integer&
integer&
sum of \emph{a} and \emph{b}\\
&
real&
real&
real&
sum of \emph{a} and \emph{b}\\
&
set&
set&
set&
union of \emph{a} and \emph{b}\\
\textbf{-}&
integer&
integer&
integer&
result of subtracting \emph{b} from \emph{a}\\
&
real&
real&
real&
result of subtracting \emph{b} from \emph{a}\\
&
set&
set&
set&
complement of \emph{b} relative to \emph{a}\\
\textbf{+:}&
0..255&
0..255&
0..255&
saturated addition cliped to 0..255 \\
&
-128..127&
-128..127&
-128..127&
saturated addition clipped to -128..127\\
\textbf{-:}&
0..255&
0..255&
0..255&
saturated subtraction clipped to 0..255\\
&
-128..127&
-128..127&
-128..127&
saturated subtraction clippled to -128..127\\
\textbf{or}&
boolean&
boolean&
boolean&
logical or\\
\hline 
\end{tabular}\par}\end{table}


\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<addop>&
'+'\\
&
'-'\\
&
'or'\\
&
'+:'\\
&
'-:'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<additive expression>&
<multiplicative expression> {[} <addop> <multiplicative expression> {]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<expression>&
<additive expression> <relational operator> <expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\section{Statements}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<statement>&
<variable>':='<expression>\\
&
<procedure statement>\\
&
<empty statement>\\
&
'goto' <label>;\\
&
'begin' <statement>{[};<statement>{]}{*}'end'\\
&
'if'<expression>'then'<statement>{[}'else'<statement>{]}\\
&
<case statement>\\
&
'for' <variable>:= <expression> 'to' <expression> 'do' <statement>\\
&
'for' <variable>:= <expression> 'downto' <expression> 'do' <statement>\\
&
'repeat' <statement> 'until' <expression>\\
&
'with' <record variable> 'do' < statement>\\
&
'while' <expression> 'do' <statement>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Assignment\label{assignment}}

An assignment replaces the current value of a variable by a new value specified
by an expression. The assignment operator\index{operator} is\index{is} :=\index{:=}.
Standard Pascal allows assignment\index{assignment} of whole arrays\index{array}.
Vector Pascal extends this to allow consistent use of mixed rank\index{rank}
expressions on the right hand side of an assignment. Given

\textbf{r0:real; r1:array{[}0..7{]} of real; r2:array{[}0..7,0..7{]} of real}

then we can write

\begin{enumerate}
\item r\textbf{1:= r2{[}3{]}; \{ supported in standard Pascal \}}
\item \textbf{r1:= /2; \{ assign 0.5 to each element of r1 \}}
\item \textbf{r2:= r1{*}3; \{ assign 1.5 to every element of r2\}}
\item \textbf{r1:= \textbackslash{}+ r2; \{ r1gets the totals along the rows of r2\}}
\item \textbf{r1:= r1+r2{[}1{]};\{ r1 gets the corresponding elements of row 1 of
r2 added to it\}}
\end{enumerate}
The assignment of arrays is a generalisation of what standard Pascal allows.
Consider the first examples above, they are equivalent to:

\begin{enumerate}
\item \textbf{for i:=0 to 7 do r1{[}i{]}:=r2{[}3,i{]};}
\item \textbf{for i:=0 to 7 do r1{[}i{]}:=/2;}
\item \textbf{for i:=0 to 7 do for j:=0 to 7 do r2{[}i,j{]}:=r1{[}j{]}{*}3;}
\item \textbf{for i:=0 to 7 do begin t:=0; for j:=7 downto 0 do t:=r2{[}i,j{]}+t;
r1{[}i{]}:=t; end;}
\item \textbf{for i:=0 to 7 do r1{[}i{]}:=r1{[}i{]}+r2{[}1,i{]};}
\end{enumerate}
In other words the compiler has to generate an implicit loop\index{loop} over
the elements of the array being assigned to and over the elements of the array
acting as the data-source. In the above \textbf{i,j,t} are assumed to be temporary
variables not refered to anywhere else in the program. The loop variables are
called implicit indices\index{indices}\index{implicit indices} \label{implicitindices}and
may be accessed using \textbf{iota}. 

The variable on the left hand side of an assignment defines an array\index{array}
context within which expressions on the right hand side are evaluated. Each
array context has a rank given by the number of dimensions\index{dimensions}
of the array on the left hand side. A scalar variable has rank\index{rank}
0. Variables occuring in expressions with an array context of rank \emph{r}
must have \emph{r} or fewer dimensions. The \emph{n} bounds of any \emph{n}
dimensional array variable, with \( n\leq r \) occuring within an expression
evaluated in an array context of rank \emph{r} must match with the rightmost
\emph{n} bounds of the array on the left hand side of the assignment statement. 

Where a variable is of lower rank than its array context, the variable is replicated
to fill the array context\index{array context}. This is shown in examples 2
and 3 above. Because the rank of any assignment is constrained by the variable
on the left hand side, no temporary arrays, other than machine registers, need
be allocated to store the intermediate array results of expressions.


\subsection{Procedure statement}

A procedure statement executes a named procedure\index{procedure}. A procedure
statement may, in the case where the named procedure has formal parameters,
contain a list of actual parameters. These are substituted in place of the formal
parameters contained in the declaration. Parameters may be value parameters
or variable parameters. 

Semantically the effect of a value parameter is that a copy is taken of the
actual parameter\index{parameter} and this copy substituted into the body of
the procedure. Value parameters may be structured values such as records and
arrays. For scalar values, expressions may be passed as actual parameters. Array
expressions are not currently allowed as actual parameters. 

A variable parameter is passed by reference, and any alteration of the formal
parameter induces a corresponding change in the actual parameter. Actual variable
parameters must be variables.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c||c|}
\hline 
<parameter>&
<variable>&
for formal parameters declared as var\\
&
<expression>&
for other formal parameters \\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<procedure statement>&
<identifier>\\
&
<identifier> '(' <parameter> {[}','<parameter>{]}{*} ')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\paragraph{Examples}

\begin{enumerate}
\item \textbf{printlist;}
\item \textbf{compare(avec,bvec,result);}
\end{enumerate}

\subsection{Goto statement}

A goto statement transfers control to a labelled statement. The destination
label must be declared in a label\index{label} declaration. It is illegal to
jump into or out of a procedure.


\paragraph{Example}

\textbf{goto\index{goto} 99;}


\subsection{Compound statement}

A list of statements separated by semicolons may be grouped into a compound
statement by bracketing them wth \textbf{begin} and \textbf{end} .


\paragraph{Example}

\textbf{begin\index{begin} a:=x{*}3; b:=sqrt a end\index{end};}


\subsection{If statement}

The basic control flow construct is the if statemen. If the boolean expression
between \textbf{if\index{if}} and \textbf{then\index{then}} is true then the
statement following \textbf{then} is followed. If it is false and an else part
is present, the statement following \textbf{else\index{else}} is executed. 


\subsection{Case statement}

The case\index{case} statement specifies an expression which is evaluated and
which must be of integral or ordinal type. Dependent upon the value of the expression
control transfers to the statement labeled by the matching constant.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<case statement>&
'case'<expression>'of'<caselist>'end'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<caselist>&
<caselist element>{[}';'<caselist element.{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<caselist element>&
<caselabel>{[}',' <caselabel>{]}':'<statement>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<caselabel>&
<constant>\\
&
<constant> '..' <constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\paragraph{Examples}

\vspace{0.3cm}
{\raggedright \begin{tabular}{ll}
\textbf{case} i \textbf{of}&
\textbf{case} c \textbf{of}\\
\textbf{1:s:=abs s;}&
\textbf{'a':write('A');}\\
\textbf{2:s:= sqrt s;}&
\textbf{'b','B':write('B');}\\
\textbf{3: s:=0}&
\textbf{'A','C'..'Z','c'..'z':write(' ');}\\
\textbf{end}&
\textbf{end}\\
\end{tabular}\par}
\vspace{0.3cm}


\subsection{With statement}

The within the component statement of the with\index{with} statement the fields
of the record variable can be refered to without prefixing them by the name
of the record variable. The effect is to import the component statement into
the scope defined by the record\index{record} variable declaration so that
the fieldnames appear as simple variable names.


\paragraph{Example}

\textbf{var s:record x,y:real end;}

\textbf{begin}

\textbf{with s do begin x:=0;y:=1 end ;}

\textbf{end}


\subsection{For statement}

A for\index{for} statement executes its component statement repeatedly under
the control of an iteration\index{iteration} variable. The iteration variable
must be of an integral or ordinal type. The variable is either set to count
up through a range or down through a range.

\textbf{for i:= e1 to\index{to} e2 do s}

is eqivalent to

\textbf{i:=e1; temp:=e2;while i<=temp do s;}

whilst

\textbf{for i:= e1 downto\index{downto} e2 do s}

is equivalent to

\textbf{i:=e1; temp:=e2;while i>= temp do s;}


\subsection{While statement}

A while\index{while} statement executes its component statement whilst its
boolean expression is true. The statement

\textbf{while e do s}

is equivalent to

\textbf{10: if not e then goto 99; s; goto 10; 99:}


\subsection{Repeat statement}

A repeat\index{repeat} statement executes its component statement at least
once, and then continues to execute the component statement until its component
expression becomes true.

\textbf{repeat s until e}

is equivalent to

\textbf{10: s;if e then goto 99; goto 10;99:}


\section{Programs and Units}

Vector Pascal supports the popular system of separate compilation units\index{units}
found in Turbo\index{Turbo Pascal} Pascal. A compilation unit can be either
a program, a unit or a library\index{library}.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<program>&
'program' <identifier>';'{[}<uses>';'{]}<block>'.'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<uses>&
'uses' <identifer>{[}','<identifier>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
\label{block}<block>&
{[}<decls>';'{]}{*}'begin' <statement>{[}';'<statement>{]}{*}'end'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<decls>&
'const' <constant declaration>{[}';'<constant declaration>{]}{*}\\
&
'type'<type defintion>{[}';'<type defintion>{]}{*}\\
&
'label' <label>{[}',' <label>{]}\\
&
<procedure declaration>\\
&
'var' <variable declaration>{[} ';' <variable declaration> {]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unit>&
<unittype> <identifer>'interface' <decls><uses> 'implementation'<block>'.'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unittype>&
'unit'\\
&
'library'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

An executable compilation unit must be declared as a program\index{program}.
The program can use several other compilation units all of which must be either
units or libraries. The units or libraries that it directly uses are specified
by a list of identifiers in an optional use list at the start of the program.
A unit or libray has two declaration portions and an executable block. 


\subsection{The export of identifiers from units}

The first declaration portion is the interface part and is preceded by the reserved
word \textbf{interface}\index{interface}.

The definitions in the interface section of unit files constitute a sequence
of enclosing scopes, such that successive units in the with list ever more closely
contain the program itself. Thus when resolving an identifier, if the identifier
can not be resolved within the program scope, the declaration of the identifier
within the interface section of the rightmost unit in the uses list is taken
as the defining occurence. It follows that rightmost occurence of an identifier
definition within the interface parts of units on the uses list overides all
occurences in interface parts of units to its left in the uses list.

The implementation part of a unit consists of declarations\index{declarations},
preceded by the reserved word \textbf{implementatio}n\index{implementation}
that are private to the unit with the exception that a function or procedure
declared in an interface context can ommit the procedure body, provided that
the function or procedure is redeclared in the implementation part of the unit.
In that case the function or procedure heading given in the interface part is
taken to refer to the function or procedure of the same name whose body is declared
in the implementation part. The function or procedure headings sharing the same
name in the interface and implementation parts must correspond with respect
to parameter types, parameter order and, in the case of functions, with respect
to return types.

A unit may itself contain a use list, which is treated in the same way as the
use lists of a program. That is to say, the use list of a unit makes accessible
identifiers declared within the interface parts of the units named within the
use list to the unit itself.


\subsection{The export of procedures from libraries.}

If a compilation unit is prefixed by the reserved word \textbf{library} rather
than the words \textbf{program} or \textbf{unit}, then the procedure and function
declarations in its interface part are made accessible to routines written in
other languages. 


\subsection{The invocation of programs and units}

Programs and units contain an executable block\index{block}. The rules for
the execution of these are as follows: 

\begin{enumerate}
\item When a program is invoked by the operating system, the units or libraries in
its use list are invoked first followed by the executable block of the program
itself. 
\item When a unit or library is invoked, the units or libraries in its use list are
invoked first followed by the executable block of the unit or library itself. 
\item The order of invocation of the units or libraries in a use list is left to right
with the exception provided by rule 4. 
\item No unit or library may be invoked more than once.
\end{enumerate}
Note that rule 4 implies that a unit \emph{x} to the right of a unit \emph{y}
within a use list, may be invoked before the unit \emph{y,} if the unit \emph{y}
or some other unit to \emph{y}'s left names \emph{x} in its use list.

Note that the executable part of a library will only be invoked if the library
in the context of a Vector Pascal program. If the library is linked to a main
program in some other language, then the library and any units that it uses
will not be invoked. Care should thus be taken to ensure that Vector Pascal
libraries to be called from main programs written in other languages do not
depend upon initialisation code contained within the executable blocks of units.


\subsection{The compilation of programs and units.}

When the compiler\index{compiler} processes the use list of a unit or a program
then, from left to right, for each identifier in the use list it attempts to
find an already compiled unit whose filename prefix is equal to the identifier.
If such a file exists, it then looks for a source\index{source} file whose
filename prefix is equal to the identifier, and whose suffix\index{suffix}
is '.pas'\index{'.pas'}. If such a file exists and is older than the already
compiled file, the already compiled unit, the compiler loads the definitions
contained in the pre-compiled unit. If such a file exists and is newer than
the pre-compiled unit, then the compiler attempts to re-compile the unit source
file. If this recompilation proceeds without the dectection of any errors the
compiler loads the definitions of the newly compiled unit.


\subsection{The System Unit}

All programs and units include by default the unit system.pas as an implicit
member of their with list. This contains declarations of private run time routines
needed by Vector Pascal and also the following user accessible routines.



\textbf{procedure append(var f:file);} This opens a file in append mode.



\textbf{procedure assign(var f:file;var fname:string);} Associates a file name
with a file. It does not open the file.



\textbf{procedure blockread(var f:file;var buf;count:integer; var resultcount:integer);}
Trys to read count bytes from the file into the buffer. Resultcount contains
the number actually read.

\textbf{}

\textbf{procedure blockwrite}(var f:file;var buf;count:integer; var resultcount:integer);
Write count bytes from the buffer. Resultcount gives the number actually read.



\textbf{procedure close}(var f:file); Closes a file.



\textbf{function eof}(var f:file):boolean;

True if we are at the end of file f.



\textbf{procedure erase}(var f:file); Delete file f.



\textbf{function eoln}(var f:file):boolean; True if at the end of a line.



\textbf{function exp}(d:real):real; Return \( e^{x} \)



\textbf{function filesize}(var f: fileptr):integer; Return number of bytes in
a file.



\textbf{function filepos}(var f:fileptr):integer; Return current position in
a file.



\textbf{procedure freemem(var p:pointer; num:integer);} Free num bytes of heap
store. Called by dispose.



\textbf{procedure getmem(var p:pointer; num:integer);} Allocate num bytes of
heap. Called by new.



\textbf{procedure gettime(var hour,min,sec,hundredth:integer);} Return time
of day.

\textbf{ }

\textbf{function int(r:real):real;} Return the integer part of r as a real.

\textbf{ }

\textbf{function ioresult:integer;} Returns a code indicating if the previous
file operation completed ok. Zero if no error occured.



\textbf{function length(var s:string):integer;} Returns the length of s.



\textbf{procedure pascalexit(code:integer);} Terminate the program with code.

\textbf{}

\textbf{function secs:real;} Time in 1/100 seconds since program started.



\textbf{function random:integer;} Returns a random integer.

 

\textbf{procedure randomize;} Assign a new time dependent seed to the random
number generator.



\textbf{procedure reset(var f:file);} Open a file for reading.



\textbf{procedure rewrite(var f :file);} Open a file for writing.


\section{Implementation issues}


\subsection{Invoking the compiler}


\subsection{Porting to other architectures}


\subsection{Compiler Structure}


\subsection{ILCG}


\subsection{An example ILCG description }


\subsection{Array representation}

A static\index{static} array\index{array, static} is represented simply by
the number of bytes required to store the array being allocated in the global
segment or on the stack.

A dynamic array\index{array}\index{array, dynamic} is always represented on
the heap\index{heap}. Since its rank\index{rank} is known to the compiler
what needs to be stored at run time are the bounds and the means to access it.
For simplicity we make the format of dyanamic and conformant arrays the same.
Thus for schema\index{schema}  

\textbf{s(a,b,c,d:integer)= array{[}a..b,c..d{]} of integer }

whose run time bounds are evaluated to be 2..4,3..7 we would have the following
structure:

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
address&
field&
value\\
\hline 
\hline 
x&
base of data&
address of first integer in the array\\
\hline 
x+4&
a&
2\\
\hline 
x+8&
b&
4\\
\hline 
x+12&
step&
20\\
\hline 
x+16&
c&
3\\
\hline 
x+20&
d&
7\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The base address for a schematic array on the heap, will point at the first
byte after the array header show. For a conformant array, it will point at the
first data byte of the array or array range\index{range} being passed as a
parameter. The step field specifies the length of an element of the second dimension
in bytes. It is included to allow for the case where we have a conformant\index{conformant}
array\index{array, conformant} formal parameter 

\textbf{x:array{[}a..b:integer,c..d:integer{]} of integer}

to which we pass as actual parameter\index{parameter} the range 

\textbf{p{[}2..4,3..7{]} }

as actual parameter, where \textbf{p:array{[}1..10,1..10{]} of integer}

In this case the base address would point at @p{[}2,3{]} and the step would
be 40 - the length of 10 integers.


\subsection{Range\index{range} checking}

When arrays are indexed, the compiler plants run time checks to see if the indices
are within bounds\index{bounds}. In many cases the optimiser is able to remove
these checks, but in those cases where it is unable to do so, some performance
degradation can occur. Range checks can be disabled or enabled by the compiler
directives.

\{\$r-\} \{ disable range checks \}

\{\$r+\} \{ enable range checks \}

Performance can be further enhanced by the practice of declaring arrays to have
lower bounds of zero. The optimiser is generally able to generate more efficient
code for zero based arrays.

\begin{thebibliography}{10}
\bibitem{AMD}Advanced Micro Devices, 3DNow! Technology Manual, 1999. 
\bibitem{2}Aho, A.V., Ganapathi, M, TJiang S.W.K., Code Generation Using Tree Matching
and Dynamic Programming, ACM Trans, Programming Languages and Systems 11, no.4,
1989, pp.491-516. 
\bibitem{Burke}Burke, Chris, J User Manual, ISI, 1995.
\bibitem{Cattel80}Cattell R. G. G., Automatic derivation of code generators from machine descriptions,
ACM Transactions on Programming Languages and Systems, 2(2), pp. 173-190, April
1980. 
\bibitem{Chaitin}Chaitin. G., Elegant Lisp Programs, in The Limits of Mathematics, pp. 29-56,
Springer, 1997.
\bibitem{Cheong97} Cheong, G., and Lam, M., An Optimizer for Multimedia Instruction Sets, 2nd
SUIF Workshop, Stanford University, August 1997. 
\bibitem{graham80}Susan L. Graham, Table Driven Code Generation, IEEE Computer, Vol 13, No. 8,
August 1980, pp 25..37. 
\bibitem{IA32 }Intel, Intel Architecture Software Developers Manual Volumes 1 and 2, 1999. 
\bibitem{Intel00}Intel, Willamette Processor Software Developer's Guide, February, 2000. 
\bibitem{ISO90}ISO, Extended Pascal ISO 10206:1990, 1991.
\bibitem{Iverson62}K. E. Iverson, A Programming Language, John Wiley \& Sons, Inc., New York (1962),
p. 16. 
\bibitem{Iverson80}Iverson, K. E. . Notation as a tool of thought. Communications of the ACM, 23(8),
444-465, 1980.
\bibitem{Jmanual}Iverson K. E, A personal View of APL, IBM Systems Journal, Vol 30, No 4, 1991. 
\bibitem{Jintro}Iverson, Kenneth E., J Introduction and Dictionary, Iverson Software Inc. (ISI),
Toronto, Ontario, 1995.
\bibitem{Jensen}Jensen K., and Wirth N., Pascal User Manual and Report, Springer, 1978.
\bibitem{Krall00}Krall, A., and Lelait, S., Compilation Techniques for Multimedia Processors,
International Journal of Parallel Programming, Vol. 28, No. 4, pp 347-361, 2000. 
\bibitem{Leupers99}Leupers, R., Compiler Optimization for Media Processors, EMMSEC 99/Sweden 1999. 
\bibitem{Metcalf96}Metcalf, M., and Reid., J., The F Programming Language, OUP, 1996. 
\bibitem{Peleg97}Peleg, A., Wilke S., Weiser U., Intel MMX for Multimedia PCs, Comm. ACM, vol
40, no. 1 1997. 
\bibitem{Sreraman00}Srereman, N., and Govindarajan, G., A Vectorizing Compiler for Multimedia Extensions,
International Journal of Parallel Programming, Vol. 28, No. 4, pp 363-400, 2000. 
\bibitem{sable}\'{ E}tienne Gagnon, SABLECC, AN OBJECT-ORIENTED COMPILER FRAMEWORK, School
of Computer Science McGill University, Montreal, March 1998. 
\bibitem{Texas}Texas Instruments, TMS320C62xx CPU and Instruction Set Reference Guide, 1998.
\end{thebibliography}
\end{document}
