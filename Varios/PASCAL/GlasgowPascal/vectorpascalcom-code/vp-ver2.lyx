#This file was created by <wpc> Fri Feb 15 09:40:23 2002
#LyX 1.0 (C) 1995-1999 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass article
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{epsfig}
\makeatletter


\usepackage{times}
\usepackage{a4}

\makeatother
\newtheorem{listing}{}
\end_preamble

\layout Title

Vector Pascal, an array language
\layout Author

Paul Cockshott, University of Glasgow, Imaging Faraday Partnership
\newline 
 Greg Michaelson, Heriot Watt University
\layout Abstract


\size small 
Vector Pascal is a language designed to support elegant and efficient expression
 of algorithms using the SIMD model of computation.
 It imports into Pascal abstraction mechanisms derived from functional languages
 having their origins in APL.
 In particular it extends all operators to work on vectors of data.
 The type system is extended to handle pixels and dimensional analysis.
 Code generation is via the ILCG system that allows retargeting to multiple
 different SIMD instruction sets based on formal descrition of the instruction
 set semantics. 
\size default

\layout Section

Introduction
\layout Standard

The introduction of SIMD instruction sets
\begin_inset LatexCommand \cite{IA32 }

\end_inset 


\begin_inset LatexCommand \cite{AMD}

\end_inset 


\begin_inset LatexCommand \cite{Peleg97}

\end_inset 


\begin_inset LatexCommand \cite{Intel00}

\end_inset 

 to Personal Computers potentially provides substantial performance increases,
 but the ability of most programmers to harness this performance is held
 back by two factors.
 The first is the limited availability of compilers that make effective
 use of these instruction sets in a machine independent manner.
 This remains the case despite the research efforts to develop compilers
 for multi-media instruction sets
\begin_inset LatexCommand \cite{Cheong97}

\end_inset 


\begin_inset LatexCommand \cite{Leupers99}

\end_inset 


\begin_inset LatexCommand \cite{Krall00}

\end_inset 


\begin_inset LatexCommand \cite{Sreraman00}

\end_inset 

.
 The second is the fact that most popular programming languages were designed
 on the word at a time model of the classic von Neuman computer rather than
 the SIMD model.
\layout Standard

Vector Pascal aims to provide an efficient and elegant notation for programmers
 using Multi-Media enhanced CPUs.
 In doing so it borrows concepts for expressing data parallelism that have
 a long history, dating back to Iverson's work on APL in the early '60s
\begin_inset LatexCommand \cite{Iverson62}

\end_inset 

.
 We are using the word elegant in the technical sense introduced by Chaiten
\begin_inset LatexCommand \cite{Chaiten}

\end_inset 

.
 By an elegant algorithm we mean one which is expressed as concisely as
 possible.
 Elegance is a goal that one approaches asymtotically, approaching but never
 attaining.
 APL and J
\begin_inset LatexCommand \cite{Jintro}

\end_inset 

 allow the construction of very elegant programs, but at a cost.
 An inevitable consequence of elegance is the loss of redundancy.
 APL programs are as concise, or even more concise than conventional mathematica
l
 notation
\begin_inset LatexCommand \cite{Iversion80}

\end_inset 

 and use a special characterset.
 This makes them hard for the uninitiated to understand.
 J attempts to remedy this by restricting itself to the ASCII characterset,
 but still looks dauntingly unfamiliar to programmers brought up on more
 conventional languages.
 The aim of Vector Pascal is to provide the conceptual gains of Iverson's
 notation within a framework familiar to imperative programmers.
\layout Standard

Pascal
\begin_inset LatexCommand \cite{Wirth}

\end_inset 

was chosen as a base language over the alternatives of C and Java.
 C was rejected because notations like 
\family typewriter 
x+y
\family default 
 for 
\family typewriter 
x
\family default 
 and 
\family typewriter 
y
\family default 
 declared as arithmetic operations are already overloaded for address operations
 in a way which precludes their use in map operations. 
\layout Section

Array mechanisms for data parallelism
\layout Standard

Vector Pascal extends the array type mechanism of Pascal to provide better
 support for data parallel programming in general, and SIMD image processing
 in particular.
 Data parallel programming can be built up from certain underlying abstractions
\begin_inset LatexCommand \cite{Ewing}

\end_inset 

: 
\layout Itemize

operations on whole arrays 
\layout Itemize

array slicing 
\layout Itemize

conditional operations 
\layout Itemize

reduction operations 
\layout Itemize

data reorganisation 
\layout Standard

We will first consider these in general before moving on to look at their
 support in other languages, in particular J, Fortran 90
\begin_inset LatexCommand \cite{Ewing}

\end_inset 

 and 
\shape smallcaps 
Nesl
\shape default 

\begin_inset LatexCommand \cite{blelloch}

\end_inset 

 then finally looking at how they are supported in Vector Pascal. 
\layout Subsection

Operations on whole arrays
\layout Standard

The basic 
\emph on 
conceptual
\emph default 
 mechanism is the 
\emph on 
map
\emph default 
, which takes an operator and and a source array ( or pair of arrays ) and
 produces a result array by mapping the source(s) under the operator.
 Let us denote the type of an arry of 
\begin_inset Formula \(  T \)
\end_inset 

as 
\begin_inset Formula \(  T[] \)
\end_inset 

.
 Then if we have a binary operator 
\begin_inset Formula \(  \omega :(T\otimes T)\rightarrow T \)
\end_inset 

, we automatically have an operator 
\begin_inset Formula \(  \omega :(T[]\otimes T[])\rightarrow T[] \)
\end_inset 

 
\begin_inset Formula \(   \)
\end_inset 

.
 Thus if 
\begin_inset Formula \(  x,y \)
\end_inset 

 are arrays of integers 
\begin_inset Formula \(  k=x+y \)
\end_inset 

 is the array of integers where 
\begin_inset Formula \(  k_{i}=x_{i}+y_{i} \)
\end_inset 

:
\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

3
\newline 
5
\newline 
9
 


\layout Standard

= 
\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

2
\newline 
3
\newline 
5
 


\layout Standard

+ 
\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

1
\newline 
2
\newline 
4
 


\layout Standard

Similarly if we have a unary operator 
\begin_inset Formula \( \mu\)
\end_inset 

:( T
\begin_inset Formula \( \rightarrow\)
\end_inset 

T) then we automatically have an operator 
\begin_inset Formula \( \mu\)
\end_inset 

:(T[]
\begin_inset Formula \( \rightarrow\)
\end_inset 

T[]).
 Thus 
\begin_inset Formula \( z=\)
\end_inset 

sqr
\begin_inset Formula \( (x)\)
\end_inset 

 is the array where 
\begin_inset Formula \( z_{i}=x_{i}^{2}\)
\end_inset 

:
\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

4
\newline 
9
\newline 
25
 


\layout Standard

= sqr( 
\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

2
\newline 
3
\newline 
5
 


\layout Standard

)
\layout Standard

The map replaces the 
\emph on 
serialisation
\emph default 
 or 
\emph on 
for loop
\emph default 
 abstraction of classical imperative languages.
 The map concept is simple, and maps over lists are widely used in functional
 programming.
 For array based languages there are complications to do with the semantics
 of operations between arrays of different lengths and different dimensions,
 but Iverson
\begin_inset LatexCommand \cite{Iverson62}

\end_inset 

 provided a consistent treatment of these.
 Recent languages built round this model are J, an interpretive language
\begin_inset LatexCommand \cite{Jmanual}

\end_inset 


\begin_inset LatexCommand \cite{Burke}

\end_inset 


\begin_inset LatexCommand \cite{Jintro}

\end_inset 

, High Performance Fortran
\begin_inset LatexCommand \cite{Ewing}

\end_inset 

, F
\begin_inset LatexCommand \cite{Metcalf96}

\end_inset 

 a modern Fortran subset, 
\shape smallcaps 
Nesl
\shape default 
 an applicative data parallel language.
 In principle though any language with array types can be extended in a
 similar way.
 The map approach to data parallelism is machine independent.
 Depending on the target machine, a compiler can output sequential, SIMD,
 or MIMD code to handle it.
\layout Standard

Recent implementations of Fortran, such as Fortran 90, F, and High Performance
 Fortran provide direct support for whole array operations.
 Given that 
\family typewriter 
A,B
\family default 
 are arrays with the same rank and same extents, the statements:
\latex latex 

\backslash begin{verbatim}
\newline 
REAL,DIMENSION(64)::A,B
\newline 
A=3.0
\newline 
B=B+SQRT(A)*0.5;
\newline 

\backslash end{verbatim}
\latex default 
 would be legal, and would operate in a pointwise fashion on the whole arrays.
 Intrinsic functions such as SQRT are defined to operate either on scalars
 or arrays, but intrinsic functions are part of the language rather than
 part of a subroutine library.
 User defined functions over scalara do not automatically extend to array
 arguments.
\layout Standard

J
\begin_float footnote 

\layout Standard

We will give examples from J rather than APL here for ease of representation
 in ASCII.
\end_float 

 similarly allows direct implementation of array operations, though here
 the array dimensions are deduced at run time: 
\latex latex 

\backslash begin{verbatim}
\newline 
 a=. 1 2 3 5
\newline 
   a
\newline 
1 2 3 5
\newline 
   b=. 1 2 4 8
\newline 
   a+b
\newline 
2 4 7 13
\newline 

\backslash end{verbatim}
\latex default 
 The pair 
\family typewriter 
=.
\family default 
 is the assignment operator in J.
 Unlike Fortran, J automatically overloads user defined funtions over arrays.
 In what follows 
\family typewriter 

\i \^{&}
2
\family default 
 is an expression binding the dyadic power function to the contant 2, 
\family typewriter 
sqr
\family default 
 a user defined monadic operator. 
\latex latex 

\backslash begin{verbatim}
\newline 
 sqr=.^&2
\newline 
   b=.1 2 4 8
\newline 
   b+(sqr a)*0.5
\newline 
1.5 4 8.5 20.5
\newline 

\backslash end{verbatim}
\latex default 

\layout Standard


\shape smallcaps 
Nesl
\shape default 
 provides similar generality; the first J example above could be expressed
 as: 
\latex latex 

\backslash begin{verbatim}
\newline 
      {a+b: a in [1,2,3,5]; b in [1,2,4,8]};
\newline 
=> [2, 4, 7, 13] : [int]
\newline 

\backslash end{verbatim}
\latex default 
 and the second example as: 
\latex latex 

\backslash begin{verbatim}
\newline 
      {b+ sqr(a)*0.5: a in [1,2,3,5]; b in [1,2,4,8]};
\newline 
=> [1.5, 4, 8.5, 20.5] : [float]
\newline 

\backslash end{verbatim}
\latex default 
 Again user defined functions can be applied element wise, to arrays ( or
 sequences as they are called in the language).
 The expressions in { } brackets termed the Apply-to-Each construct, are descended from the ZF
 notations used in SETL
\begin_inset LatexCommand \cite{setl}

\end_inset 

 and MIRANDA
\begin_inset LatexCommand \cite{miranda}

\end_inset 

.
\layout Subsection

Array slicing
\layout Standard

It is advantageous to be able to specify sections of arrays as values in
 expression.
 The sections may be rows or columns in a matrix, a rectangular sub-range
 of the elements of an array, as shown in figure 
\begin_inset LatexCommand \ref{figslice}

\end_inset 

.
 In image processing such rectangular sub regions of pixel arrays are called
 regions of interest.
 It may also be desirable to provide matrix diagonals
\begin_inset LatexCommand \cite{vanderMeulen}

\end_inset 

.
\layout Standard


\begin_float fig 

\layout Standard



\LyXTable
multicol5
4 4 0 0 0 0 0 0
2 0 0 0
0 0 0 0
0 0 0 0
0 2 0 0
8 2 1 "" ""
8 0 1 "" ""
8 0 0 "" ""
8 0 2 "" ""
0 8 2 0 0 0 0 "" ""
0 8 2 0 0 0 0 "" ""
0 8 2 0 0 0 0 "" ""
0 8 2 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""

1
\newline 
1
\newline 
1
\newline 
1
\newline 
 1
\newline 
2
\newline 
4
\newline 
8
\newline 
 1
\newline 
2
\newline 
4
\newline 
16
\newline 
 1
\newline 
2
\newline 
8
\newline 
512
 


\layout Standard


\latex latex 

\backslash  
\latex default 

\latex latex 

\backslash  
\latex default 

\layout Standard



\LyXTable
multicol5
4 4 0 0 0 0 0 0
2 1 0 0
0 1 0 0
0 0 0 0
0 2 0 0
8 2 0 "" ""
8 0 0 "" ""
8 0 0 "" ""
8 0 2 "" ""
0 8 2 1 0 0 0 "" ""
0 8 2 1 0 0 0 "" ""
0 8 2 1 0 0 0 "" ""
0 8 2 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""

1
\newline 
1
\newline 
1
\newline 
1
\newline 
1
\newline 
2
\newline 
4
\newline 
8
\newline 
1
\newline 
2
\newline 
4
\newline 
16
\newline 
 1
\newline 
2
\newline 
8
\newline 
512
 


\layout Standard


\latex latex 

\backslash  
\latex default 

\latex latex 

\backslash  
\latex default 

\layout Standard



\LyXTable
multicol5
4 4 0 0 0 0 0 0
2 0 0 0
0 0 0 0
0 0 0 0
0 2 0 0
8 2 0 "" ""
8 0 0 "" ""
8 0 0 "" ""
8 0 2 "" ""
0 8 2 0 0 0 0 "" ""
0 8 2 1 0 0 0 "" ""
0 8 2 1 0 0 0 "" ""
0 8 2 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
1 8 0 0 0 0 0 "|c|" ""
2 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
1 8 0 1 0 0 0 "|c|" ""
2 8 0 1 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""

1
\newline 
1
\newline 
1
\newline 
1
\newline 
 1
\newline 
2 4
\newline 
8
\newline 
 1
\newline 
2 4
\newline 
16
\newline 
 1
\newline 
2
\newline 
8
\newline 
512
 


\layout Caption

Different ways of slicing the same array
\layout Standard


\begin_inset LatexCommand \label{figslice}

\end_inset 


\end_float 


\layout Standard

The notion of array slicing was introduced to imperative languages by 
\shape smallcaps 
Algol 68
\shape default 

\begin_inset LatexCommand \cite{Tanenbaum}

\end_inset 

.
 In 
\shape smallcaps 
Algol 68
\shape default 
 if x has been declared as [1:10]INT x, then x[2:6] would be a slice that
 could be used assignment or as an actual parameter.
\layout Standard

Fortran 90 extends this notion to allow what it calls triplet subscripts,
 giving the start position end position and step at which elements are to
 be taken from arrays. 
\latex latex 

\backslash begin{verbatim}
\newline 
REAL,DIMENSION(10,10)::A,B
\newline 
A(2:9,1:8:2)=B(3:10,2:9:2)
\newline 

\backslash end{verbatim}
\latex default 
 would be equivalent to the loop nest: 
\latex latex 

\backslash begin{verbatim}
\newline 

\newline 
  DO 1,J=1,8,2
\newline 
   DO 2, J=2,9
\newline 
	     A(I,J)=b(I+1,J+1)
\newline 
2  CONTINUE
\newline 
1 CONTINUE
\newline 

\backslash end{verbatim}
\latex default 
 J allows a similar operation to select subsequences.
 In what follows 
\family typewriter 
i.
\family default 
 
\begin_inset Formula \( n\)
\end_inset 

 is a function which produces a list of the first 
\begin_inset Formula \( n\)
\end_inset 

 starting with 0, and 
\family typewriter 
{
\family default 
 is the sequence subscription operator. 
\latex latex 

\backslash begin{verbatim}
\newline 
   a=. 2*i.10
\newline 
   a
\newline 
0 2 4 6 8 10 12 14 16 18
\newline 
   3{a
\newline 
6
\newline 

\backslash end{verbatim}
\latex default 
 Selection of a subsequence is performed by forming a sequence of indices.
 Thus to select the 3 consecutive elements starting with the second, we
 first form the sequence 
\family typewriter 
2 3 4
\family default 
 using the expression 
\family typewriter 
2+i.3
\family default 
 and use this to subscript the array 
\family typewriter 
a
\family default 
: 
\latex latex 

\backslash begin{verbatim}  
\newline 
   (2+i.3){a
\newline 
4 6 8
\newline 
   
\backslash end{verbatim}
\latex default 

\layout Subsection

Conditional operations
\layout Standard

For data parallel programming one frequently wants to make an operation
 work on some subset of the data based on some logical mask.
 This can be thought of providing a finer grain of selection than subslicing,
 allowing arbitrary combinations of array elements to be acted on.
 For example one might want to replace all elements of an array A less than
 the corresponding element in array B with the corresponding element of
 B.
\layout Standard



\LyXTable
multicol5
4 5 0 0 0 0 0 0
1 0 0 0
0 0 0 0
0 1 0 0
0 1 0 0
2 1 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
2 0 1 "" ""
8 0 1 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 2 1 0 0 0 0 "" ""
0 8 1 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

1
\newline 
2
\newline 
4
\newline 
8
\newline 
A
\newline 
 2
\newline 
3
\newline 
4
\newline 
5
\newline 
B
\newline 
 1
\newline 
1
\newline 
0
\newline 
0
\newline 
A
\begin_inset Formula \( <\)
\end_inset 

B
\newline 
2
\newline 
3
\newline 
4
\newline 
8
\newline 

 


\layout Standard

Fortran 90 provides a mechanism to selectively update a section of an array
 under a logical mask, the 
\family typewriter 
WHERE
\family default 
 statement. 
\latex latex 

\backslash begin{verbatim}
\newline 
REAL, DIMENSION(64)::A
\newline 
REAL, DIMENSION(64)::B
\newline 
WHERE (A>B)
\newline 
  A=A
\newline 
ELSE WHERE
\newline 
  A= B
\newline 
END WHERE
\newline 

\backslash end{verbatim}
\latex default 
 
\begin_inset LatexCommand \label{where}

\end_inset 

 The 
\family typewriter 
WHERE
\family default 
 statement is analogous to 
\shape smallcaps 
Algol 68
\shape default 
 and 
\family typewriter 
C
\family default 
 conditional expressions, but extended to operate on arrays.
 It can be performed in parallel on all elements of an array and lends itself
 to evaluation under a mask on SIMD architectures.
\layout Standard


\shape smallcaps 
Nesl
\shape default 
 provides a generalised form of Apply-to-Each in which a sieve can be applied
 to the arguments as in: 
\latex latex 

\backslash begin{verbatim}
\newline 
    { a+b : a in[ 1,2,3]; b in [4,3,2] |a<b}
\newline 
=>  [5,5] : [int]
\newline 

\backslash end{verbatim}
\latex default 
 Notice that in 
\shape smallcaps 
Nesl
\shape default 
 as in J values are allocated dynamically from a heap so that the length
 of the sequence returned from a sieved Apply-to-Each can be less than that
 of the argument sequences in its expression part.
 In Fortran 90, the 
\family typewriter 
WHERE
\family default 
 statement applies to an array whose size is known on entry to the statement.
 
\layout Subsection

Reduction operations
\layout Standard

In a reduction operation, a dyadic operator injected between the elements
 of a vector, the rows or columns of a matrix etc, produces a result of
 lower rank.
 Examples would be the forming the sum of a table or finding the maximum
 or minimum of a table.
 So one could use + to reduce 
\layout Standard



\LyXTable
multicol5
1 4 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

1
\newline 
2
\newline 
4
\newline 
8
 


\layout Standard

to 1+2+4+8=15
\layout Standard

The first systematic treatment of reduction operations in programming languages
 is due to Iverson
\begin_inset LatexCommand \cite{Iverson62}

\end_inset 

.
 He introduced the notion of a reduction functional which takes a dyadic
 operator and, by currying, generates a tailored reduction function.
 In APL as in J the reduction functional is denoted by 
\family typewriter 
/
\family default 
.
 Thus 
\family typewriter 
+/
\family default 
 is the function which forms the sum of an array.
\latex latex 

\backslash begin{verbatim}
\newline 
   a
\newline 
1 2 3 5
\newline 
   +/a
\newline 
11
\newline 

\backslash end{verbatim}
\latex default 
 The interpretation of reduction for comutative operators is simple, for
 non comutative ones it is slightly less obvious.
 Consider: 
\latex latex 

\backslash begin{verbatim}
\newline 
   -/a
\newline 
_3
\newline 

\backslash end{verbatim}
\latex default 
 The 
\family typewriter 
_3
\family default 
 here, is the J notation for -3, derived from the expansion 
\begin_inset Formula \( (1-(2-(3-4(-0))))\)
\end_inset 

, just as 11 was derived from the expansion 
\begin_inset Formula \( (1+(2+(3+(4+0))))\)
\end_inset 

.
 In J as in APL reduction applies uniformly to all binary operators.
\layout Standard

Fortran 90, despite its debt to APL, is less general, providing a limited
 set of built in reduction operators on comutative operators: 
\family typewriter 
SUM, PRODUCT, MAXVAL, MINVAL.
\family default 
 
\shape smallcaps 
Nesl
\shape default 
 likewise provides a limited set of reduction functions 
\family typewriter 
sum, minval, maxval, any, all
\family default 
.
 The last two are boolean reductions, 
\family typewriter 
any
\family default 
 returns true if at least one element of a sequence is true, 
\family typewriter 
all 
\family default 
 if they are all true.
\layout Subsection

Data reorganisation
\layout Standard

In both linear algebra and image processing applications, it is often desireable
 to be able to perform bulk reorganisation of data arrays. 
\begin_float fig 

\layout Standard



\LyXTable
multicol5
2 3 0 0 0 0 0 0
1 1 0 0
0 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

1
\newline 
2
\newline 
4
\newline 
8
\newline 
16
\newline 
32
 


\layout Standard

transposes to 
\layout Standard



\LyXTable
multicol5
3 2 0 0 0 0 0 0
1 1 0 0
0 1 0 0
0 1 0 0
8 1 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

1
\newline 
8
\newline 
2
\newline 
16
\newline 
4
\newline 
32
 


\layout Caption

Reorganising by transposition
\end_float 


\layout Standard

One may want to transpose a vector or matrix, or to shift the elements of
 a vector.
 For example, one can express the convolution of a vector with a three element
 kernel in terms of multiplications, shifts and adds.
 Let 
\begin_inset Formula \( a=\)
\end_inset 


\layout Standard



\LyXTable
multicol5
1 4 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

1
\newline 
2
\newline 
4
\newline 
8
 


\layout Standard

be a vector to be convolved with the kernel 
\begin_inset Formula \( k=\)
\end_inset 


\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

0.25
\newline 
0.5
\newline 
0.25
 


\layout Standard

.
 This can be expressed by defining two temporary vectors 
\begin_inset Formula \[ b,c=0.25a,0.5a=
\begin{tabular}{|c|c|c|c|}\hline
0.25&0.5&1&2\\\hline
\end{tabular}, \begin{tabular}{|c|c|c|c|}\hline
0.5&1&2&4\\\hline
\end{tabular}\]
\end_inset 

 and then defining the result to the sum under shifts of 
\begin_inset Formula \( b,c\)
\end_inset 

 as shown in figure 
\begin_inset LatexCommand \ref{fig:conv}

\end_inset 


\begin_float fig 

\layout Standard



\LyXTable
multicol5
1 4 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

1
\newline 
2
\newline 
4
\newline 
8
 


\layout Standard

convolve( 
\layout Standard



\LyXTable
multicol5
1 3 0 0 0 0 0 0
1 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""

0.25
\newline 
0.5
\newline 
0.25
 


\layout Standard

)= 
\layout Standard



\LyXTable
multicol5
4 4 0 0 0 0 0 0
1 1 0 0
0 1 0 0
0 2 0 0
0 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 1 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 2 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

0.5
\newline 
1
\newline 
2
\newline 
2
\newline 
0.5
\newline 
1
\newline 
2
\newline 
4
\newline 
0.25
\newline 
0.25
\newline 
0.5
\newline 
1
\newline 
1.25
\newline 
2.25
\newline 
4.5
\newline 
7
 


\layout Caption

Convolution by shifting
\layout Standard


\begin_inset LatexCommand \label{fig:conv}

\end_inset 


\end_float 

 This example replicates the trailing value when shifting.
 In other circumstances, when dealing with cellular automata for example,
 it is convenient to be able to define circular shifts on data arrays.
\layout Standard

Fortran 90 provides a rich set of functions to reshape, transpose and circularly
 shift arrays.
 For instance given a 9 element vector v we can reshape it as a 3 by 3 matrix
 
\latex latex 

\backslash begin{verbatim}
\newline 

\newline 
V= (/ 1,2,3,4,5,6,7,8,9 /)
\newline 
M=RESHAPE(V,(/3,3/))
\newline 

\backslash end{verbatim}
\latex default 
 gives us the array 
\latex latex 

\backslash begin{verbatim}
\newline 
1  2  3
\newline 
4  5  6
\newline 
7  8  9
\newline 

\backslash end{verbatim}
\latex default 
 We can then cyclically shift this along a dimension 
\latex latex 

\backslash begin{verbatim}
\newline 
M2=CSHIFT(M,SHIFT=2,DIM=2)
\newline 

\backslash end{verbatim}
\latex default 
 to give 
\latex latex 

\backslash begin{verbatim}
\newline 

\newline 
3  1  2  
\newline 
6  4  5  
\newline 
9  7  8  
\backslash end{verbatim}
\latex default 
 
\shape smallcaps 
Nesl
\shape default 
 provides on sequences, similar operations to those provided on arrays by
 Fortran 90, so that if 
\latex latex 

\backslash begin{verbatim}
\newline 
v             =[ 1,2,3,4,5,6,7,8,9]
\newline 
s             =[3,3,3]
\newline 
partition(v,s)=[[1,2,3][4,5,6],7,8,9]]
\newline 
rotate(v,3)   =[7,8,9,1,2,3,4,5,6]
\newline 

\backslash end{verbatim}
\latex default 

\layout Section

Data parallelism in Vector Pascal
\layout Subsection

Assignment maps
\layout Standard

Standard Pascal allows assignement of whole arrays.
 Vector Pascal extends this to allow consistent use of mixed rank expressions
 on the right hand side of an assignment.
 Given
\layout Standard


\series bold 
r0:real; r1:array[0..7] of real; r2:array[0..7,0..7] of real
\series default 

\layout Standard

then we can write 
\layout Enumerate

r
\series bold 
1:= r2[3]; { supported in standard Pascal }
\series default 

\layout Enumerate


\series bold 
r1:= 1/2; { assign 0.5 to each element of r1 }
\series default 

\layout Enumerate


\series bold 
r2:= r1*3; { assign 1.5 to every element of r2}
\series default 

\layout Enumerate


\series bold 
r1:= 
\backslash 
+ r2; { r1gets the totals along the rows of r2}
\series default 

\layout Enumerate


\series bold 
r1:= r1+r2[1];{ r1 gets the corresponding elements of row 1 of r2 added to it}
\series default 

\layout Standard

The assignment of arrays is a generalisation of what standard Pascal allows.
 Consider the first examples above, they are equivalent to:
\layout Enumerate


\series bold 
for i:=0 to 7 do r1[i]:=r2[3,i];
\series default 

\layout Enumerate


\series bold 
for i:=0 to 7 do r1[i]:=1/2;
\series default 

\layout Enumerate


\series bold 
for i:=0 to 7 do for j:=0 to 7 do r2[i,j]:=r1[j]*3;
\series default 

\layout Enumerate


\series bold 
for i:=0 to 7 do begin t:=0; for j:=7 downto 0 do t:=r2[i,j]+t; r1[i]:=t; end;
\series default 

\layout Enumerate


\series bold 
for i:=0 to 7 do r1[i]:=r1[i]+r2[1,i];
\series default 

\layout Standard

In other words the compiler has to generate an implicit loop
\begin_inset LatexCommand \index{loop}

\end_inset 

 over the elements of the array being assigned to and over the elements
 of the array acting as the data-source.
 In the above 
\series bold 
i,j,t
\series default 
 are assumed to be temporary variables not refered to anywhere else in the
 program.
 The loop variables are called implicit indices
\begin_inset LatexCommand \index{indices}

\end_inset 


\begin_inset LatexCommand \index{implicit indices}

\end_inset 

 
\begin_inset LatexCommand \label{implicitindices}

\end_inset 

and may be accessed using 
\series bold 
iota
\series default 
.
\layout Standard

The variable on the left hand side of an assignment defines an array context
 within which expressions on the right hand side are evaluated.
 Each array context has a rank given by the number of dimensions of the
 array on the left hand side.
 A scalar variable has rank 0.
 Variables occuring in expressions with an array context of rank 
\emph on 
r
\emph default 
 must have 
\emph on 
r
\emph default 
 or fewer dimensions.
 The 
\emph on 
n
\emph default 
 bounds of any 
\emph on 
n
\emph default 
 dimensional array variable, with 
\begin_inset Formula \(  n\leq r \)
\end_inset 

 occuring within an expression evaluated in an array context of rank 
\emph on 
r
\emph default 
 must match with the rightmost 
\emph on 
n
\emph default 
 bounds of the array on the left hand side of the assignment statement.
\layout Standard

Where a variable is of lower rank than its array context, the variable is
 replicated to fill the array context.
 This is shown in examples 2 and 3 above.
 Because the rank of any assignment is constrained by the variable on the
 left hand side, no temporary arrays, other than machine registers, need
 be allocated to store the intermediate array results of expressions.
\layout Standard

Maps are implicitly and promiscously defined on both monadic operators and
 unary functions.
 If 
\series bold 
f
\series default 
 is a function or unary operator mapping from type 
\series bold 
r
\series default 
 to type 
\series bold 
t
\series default 
 then if 
\series bold 
x
\series default 
 is an array of 
\series bold 
r
\series default 
 then 
\series bold 
a:=f(x)
\series default 
 assigns an array of 
\series bold 
t
\series default 
 such that 
\series bold 
a[i]=f(x[i])
\series default 
.
\layout Standard

Functions can return any data type whose size is known at compile time,
 including arrays and records.
 A consistent copying semantics is used.
\layout Subsection

Slice operations
\layout Standard

Image processing applications often have to deal with regions of interest,
 rectangular sub-images within a larger image.
 Vector Pascal extends the array abstraction to define sub-ranges of arrays.
 A sub-range of an array variable are denoted by the variable followed by
 a range expression in brackets.
\layout Standard

The expressions within the range expression must conform to the index type
 of the array variable.
 The type of a range expression 
\series bold 
a[i..j]
\series default 
 where 
\series bold 
a: array[p..q] of t
\series default 
 is 
\series bold 
array[0..j-i] of t.
\series default 

\layout Standard

Examples
\layout Standard


\series bold 
dataset[i..i+2]:=blank;
\series default 

\layout Standard


\series bold 
twoDdata[2..3,5..6]:=twoDdata[4..5,11..12]*0.5;
\series default 

\layout Standard

Subranges may be passed in as actual parameters to procedures whose correspondin
g
 formal parameters are declared as variables of a schematic type.
 Hence given the following declarations:
\layout Standard


\series bold 
type image(miny,maxy,minx,maxx:integer)=array[miny..maxy,minx..maxx] of pixel;
\series default 

\layout Standard


\series bold 
procedure invert(var im:image);begin im:= - im; end;
\series default 

\layout Standard


\series bold 
var screen:array[0..319,0..199] of pixel;
\series default 

\layout Standard

then the following statement would be valid:
\layout Standard


\series bold 
invert(screen[40..60,20..30]);
\series default 
 A particular form of slicing is to select out the diagonal of a matrix.
 The syntactic form 
\series bold 
diag
\series default 
<expression> selects the diagonal of the matrix to which it applies.
 A precise definition of this is given in section 
\begin_inset LatexCommand \ref{diag}

\end_inset 

. 
\layout Subsection

Conditional update operations
\layout Standard

In Vector Pascal the sort of conditional updates handled by the Fortran
 
\family typewriter 
WHERE
\family default 
 statement, are programmed using conditional expressions.
 The Fortran code shown in 
\begin_inset LatexCommand \ref{where}

\end_inset 

 would translate to 
\series bold 
var a:array[0..63] of real;
\series default 

\layout Standard


\series bold 
a:=if a
\begin_inset Formula \( >\)
\end_inset 

0 then a else -a
\series default 

\layout Standard

The 
\series bold 
if
\series default 
 expression can be compiled in two ways:
\layout Enumerate

Where the two arms of the if expression are parallelisable, the condition
 and both arms are evaluated and then merged under a boolean mask so the
 above assignment would be equivalent to:
\begin_deeper 
\layout Standard


\series bold 
a:= (a and (a
\begin_inset Formula \( >\)
\end_inset 

0))or(not (a
\begin_inset Formula \( >\)
\end_inset 

0) and -a);
\series default 

\layout Standard

were the above legal Pascal
\begin_float footnote 

\layout Standard

This compilation strategy requires that true is equivalent to -1 and false
 to 0.
 This is typically the representation of booleans returned by vector comparison
 instructions on SIMD instruction sets.
 In Vector Pascal this representation is used generally and in consequence,
 
\series bold 
true
\series default 

\begin_inset Formula \( <\)
\end_inset 


\series bold 
false
\series default 
.
\end_float 

. 
\end_deeper 
\layout Enumerate

If the code is not paralleliseable it is translated as equivalent to a standard
 if statement, so the previous example would be equivalent to:
\begin_deeper 
\layout Standard


\series bold 
for i:=0 to 63 do if a[i]
\begin_inset Formula \( >\)
\end_inset 

0 then a[i]:=a[i] else a[i]:=-a[i];
\series default 

\layout Standard

Expressions are non parallelisable if they include function calls.
\end_deeper 
\layout Standard

The dual compilation strategy allows the same linguistic construct to be
 used in recursive function definition and parallel data selection.
\layout Subsection

Operator Reduction
\layout Standard

Maps take operators and arrays and deliver array results.
 The 
\emph on 
reduction 
\emph default 
 abstraction takes a dyadic operator and an array and returns a scalar result.
 It is denoted by the functional form 
\backslash 
.
 Thus if a is an array, 
\backslash 
+a denotes the sum over the array.
 More generally 
\begin_inset Formula \(  \setminus \Phi x \)
\end_inset 

 for some dyadic operator 
\begin_inset Formula \(  \Phi  \)
\end_inset 

 means 
\begin_inset Formula \(  x_{0}\Phi (x_{1}\Phi ..(x_{n}\Phi \iota )) \)
\end_inset 

 where 
\begin_inset Formula \(  \iota  \)
\end_inset 

 is the identity element for the operator and the type.
 Thus we can write 
\backslash 
+ for 
\begin_inset Formula \(  \sum  \)
\end_inset 

, 
\backslash 
* for 
\begin_inset Formula \(  \prod  \)
\end_inset 

 etc.
 The dot product of two vectors can thus be written as
\layout Standard


\series bold 
x:=
\backslash 
+(y*z);
\series default 

\layout Standard

instead of
\layout Standard


\series bold 
x:=0;
\series default 

\layout Standard


\series bold 
for i:=0 to n do x:= x+ y[i]*z[i];
\series default 

\layout Standard

A reduction operation takes an argument of rank 
\emph on 
r
\emph default 
 and returns an argument of rank 
\emph on 
r-1
\emph default 
 except in the case where its argument is or rank 0, in which case it acts
 as the identity operation.
 Reduction is always performed along the last array dimension of its argument.
 
\layout Standard

Semantically reduction by an operator say 
\begin_inset Formula \( \odot\)
\end_inset 

 is defined such that
\layout Standard


\series bold 
var a:array[low..high] of t;x:t;
\series default 

\layout Standard


\series bold 
x:=
\backslash 

\begin_inset Formula \( \odot\)
\end_inset 

a;
\series default 

\layout Standard

is equivalent to:
\layout Standard


\series bold 
var temp:t; i:low..high;
\series default 

\layout Standard


\series bold 
temp:= 
\emph on 
identity
\emph default 
(t,
\begin_inset Formula \( \odot\)
\end_inset 

);
\series default 

\layout Standard


\series bold 
for i:= high downto low do temp:=a[i]
\begin_inset Formula \( \odot\)
\end_inset 

temp;
\series default 

\layout Standard


\series bold 
x:=temp;
\series default 

\layout Standard

Where 
\emph on 
identity
\emph default 
(t,
\begin_inset Formula \( \odot\)
\end_inset 

) is a function returning the identity element under the operator 
\begin_inset Formula \( \odot\)
\end_inset 

 for the type 
\series bold 
t
\series default 
.
 The identity element is defined to be the value such that 
\begin_inset Formula \( x=x\odot\)
\end_inset 


\emph on 
identity
\emph default 
(t,
\begin_inset Formula \( \odot)\)
\end_inset 

.
 Identity elements for operators and types are shown in table 
\begin_inset LatexCommand \ref{ids}

\end_inset 

. 
\layout Subsection

Array reorganisation
\layout Standard

By array reorganisation, we mean conservative operations, which preserve
 the number of elements in the orignal array.
 If the shape of the array is also conserved we have an element permutation
 operation.
 If the shape of the array is not conserved but it's rank and extents are,
 we have a permutation of the array dimensions.
 If the rank is not conserved we have a flattening or reshaping of the array.
 
\layout Standard

Vector Pascal provides syntactic forms to access and manipulate the implicit
 indices used in maps and reductions.
 These syntactic forms allow the concise expression of many conservative
 array reorganisations.
 The form 
\latex latex 

\backslash  {}
\latex default 

\series bold 
iota 
\series default 

\emph on 
i 
\emph default 
 returns the 
\emph on 
i
\emph default 
th current implicit index.
 Thus given the definitions
\layout Standard


\series bold 
v1:array[1..3]of integer; v2:array[0..4]of integer;
\series default 

\layout Standard

the program fragment
\layout Standard


\series bold 
v1:=iota 0; 
\series default 
 
\series bold 
v2:=iota 0 *2;
\series default 

\layout Standard

would set v1 and v2 as follows:
\layout Standard


\latex latex 

\backslash begin{verbatim}
\newline 
v1=	1	2	3
\newline 
v2=	0	2	4	6	8
\newline 

\backslash end{verbatim}
\latex default 
 whilst given the definitions
\layout Standard


\series bold 
m1:array[1..3,0..4] of integer;m2:array[0..4,1..3]of integer;
\series default 

\layout Standard

then the program fragment
\layout Standard


\series bold 
m2:= iota 0 +2*iota 1; 
\series default 

\layout Standard

would set m2
\layout Standard


\latex latex 

\backslash begin{verbatim}
\newline 
m2=
\newline 
	2	4	6
\newline 
	3	5	7
\newline 
	4	6	8	
\newline 
	5	7	9
\newline 
	6	8	10
\newline 

\backslash end{verbatim}
\latex default 
 The argument to iota
\begin_inset LatexCommand \index{iota}

\end_inset 

 must be an integer known at compile time within the range of implicit indices
 in the current context.
\layout Standard

A generalised permutation of the implicit indices is performed using the
 syntatic form 
\series bold 
perm[
\series default 
<index-sel>[,<index-sel>]*
\series bold 
] 
\series default 
<expression>.
 The <index-sel>s are integers known at compile time which specify a permution
 on the implicit indices.
 Thus in 
\begin_inset Formula \( e\)
\end_inset 

 evaluated in context 
\series bold 
perm[
\series default 

\begin_inset Formula \( i,j,k\)
\end_inset 


\series bold 
]
\series default 

\begin_inset Formula \( e\)
\end_inset 

, then 
\series bold 
iota 0 =
\series bold 
iota 
\begin_inset Formula \( i,\)
\end_inset 

 iota 1=iota 
\begin_inset Formula \( j,\)
\end_inset 

 iota 2=iota 
\begin_inset Formula \( k\)
\end_inset 


\series bold 

\series default 
.
\layout Standard

An example of where this is useful is in converting between different image
 formats.
 Hardware frame buffers typically represent images with the pixels in the
 red, green, blue, and alpha channels adjacent in memory.
 For image processing it is convenient to hold them in distinct planes.
 The 
\series bold 
perm
\series default 
 operator provides a concise notation for translation between these formats:
\layout Standard


\series bold 
screen:=perm[2,0,1]img;
\series default 

\layout Standard

where: 
\size small 

\layout Standard


\size small 

\series bold 
type rowindex=0..479;colindex=0..639;channel=red..alpha;
\series default 

\layout Standard


\size small 

\series bold 
screen:array[rowindex,colindex,channel] of pixel;
\series default 

\layout Standard


\size small 

\series bold 
img:array[channel,colindex,rowindex] of pixel;
\series default 

\size default
 
\layout Standard


\series bold 
trans
\series default 
 and 
\series bold 
diag
\series default 
 
\begin_inset LatexCommand \label{diag}

\end_inset 

 provide shorthand notions for expressions in terms of 
\series bold 
perm
\series default 
.
 Thus in an assignment context of rank 2, 
\series bold 
trans
\series default 
 = 
\series bold 
perm[1,0]
\series default 
 and 
\series bold 
diag 
\series default 
= 
\series bold 
perm[0,0]
\series default 
.
 The form 
\series bold 
trans
\begin_inset LatexCommand \index{trans}

\end_inset 


\series default 

\emph on 
x
\emph default 
 transposes a vector 
\begin_float footnote 

\layout Standard

Note that 
\series bold 
trans
\series default 
 is not strictly speaking an operator, as there exists no Pascal type correspond
ing
 to a column vector.
\end_float 

matrix, or tensor.
 It achieves this by cyclic rotation of the implicit indices
\begin_inset LatexCommand \index{indices}

\end_inset 


\begin_inset LatexCommand \index{implicit indices}

\end_inset 

.
 Thus if 
\series bold 
trans
\series default 
 
\emph on 
e
\emph default 
 , for some expression 
\emph on 
e
\emph default 
 is evaluated in a context with implicit indices
\layout Standard


\series bold 
iota
\series default 
 
\emph on 
0
\emph default 
.. 
\series bold 
iota
\series default 
 
\emph on 
n 
\emph default 

\layout Standard

then the expression e is evaluated in a context with implicit indices
\layout Standard


\series bold 
iota
\series default 
'
\emph on 
0
\emph default 
.. 
\series bold 
iota
\series default 
'
\emph on 
n
\emph default 

\layout Standard

where
\layout Standard


\series bold 
iota
\series default 
'
\emph on 
x
\emph default 
 = 
\series bold 
iota
\series default 
 ( (
\emph on 
x+1
\emph default 
)
\series bold 
mod
\series default 
 
\emph on 
n+1
\emph default 
)
\layout Standard

It should be noted that transposition is generalised to arrays of rank greater
 than 2.
\layout Paragraph

Examples
\layout Standard

Given the defintions used above, the program fragment:
\layout Standard


\series bold 
m1:= (trans v1)*v2; 
\series default 

\layout Standard


\series bold 
m2 := trans m1; 
\series default 

\layout Standard

will set m1 and m2:
\layout Standard


\latex latex 

\backslash begin{verbatim}
\newline 
m1=
\newline 
	0	2	4	6	8
\newline 
	0	4	8	12	16
\newline 
	0	6	12	18	24
\newline 
m2=
\newline 
	0	0	0
\newline 
	2	4	6
\newline 
	4	8	12
\newline 
	6	12	18
\newline 
	8	16	24
\newline 

\backslash end{verbatim}
\latex default 

\layout Subsubsection

Array shifts
\layout Standard

The shifts and rotations of arrays supported in Fortran 90 and 
\shape smallcaps 
Nesl
\shape default 
 are not supported by any explicit operator, though one can of course use
 a combination of other features to achieve them.
 A left rotation can for instance be achieved as follows:
\layout Standard


\series bold 
a:=b[(1+iota 0)mod n];
\series default 

\layout Standard

and a reversal by
\layout Standard


\series bold 
a:=b[n-iota 0 -1];
\series default 

\layout Standard

Where in both examples:
\layout Standard


\series bold 
var a,b:array[0..n-1] of integer;
\series default 

\layout Subsection

Efficiency considerations
\layout Standard

Expressions involving transposed vectors, matrix diagonals, and permuted
 vectors or indexing by expressions involving modular arithmetic on 
\series bold 
iota
\series default 
, do not paralellise well on SIMD architectures like the MMX, since these
 depend upon the fetching of blocks of adjacent elements into the vector
 registers.
 This requires that element addresses be adjacent and monotonically increasing.
 Assignments involving mapped vectors will usually have to be handled by
 scalar registers.
\layout Subsubsection

Element permutation
\layout Standard

Permutations are widely used in APL and J programming, an example being
 sorting and array 
\family typewriter 
a
\family default 
 into descending order using the J expression 
\latex latex 

\backslash verb+  
\backslash :a{a +
\latex default 
 which uses the operator 
\latex latex 

\backslash verb+
\backslash :+
\latex default 
 to produce a permutation of the indices of 
\family typewriter 
a
\family default 
 in descending order, and then uses { to index 
\family typewriter 
a
\family default 
 with this permutation vector.
 If one is to use analogous constructs, one muse allow an array may be indexed
 by another array.
 If 
\series bold 
x:array[t0] of t1
\series default 
 and 
\series bold 
y:array[t1] of t2
\series default 
, then in Vector Pascal, 
\series bold 
y[x]
\series default 
 denotes the virtual array of type 
\series bold 
array[t0] of t2
\series default 
 such that 
\series bold 
y[x][i]=y[x[i]]
\series default 
. 
\layout Paragraph

Example
\layout Standard

Given the declarations
\layout Standard


\series bold 
const perm:array[0..3] of integer=(3,1,2,0);
\series default 

\layout Standard


\series bold 
var ma,m0:array[0..3] of integer; 
\series default 

\layout Standard

then the statements
\layout Standard


\series bold 
m0:= (iota 0)+1;
\series default 

\layout Standard


\series bold 
ma:=m0[perm]; 
\series default 

\layout Standard

would set the variables such that
\layout Standard


\latex latex 

\backslash begin{verbatim}
\newline 
m0=	1 	2 	3 	4
\newline 
perm=	3	1	2	0
\newline 
ma=	4	2	3	1
\newline 

\backslash end{verbatim}
\latex default 

\layout Section

Extensions to the Pascal Type System
\layout Subsection

Pixels
\layout Standard

Standard Pascal is a strongly typed language, with a comparatively rich
 collection of type abstractions : enumeration, set formation, sub-ranging,
 array formation, cartesian product
\begin_float footnote 

\layout Standard

The 
\series bold 
record
\series default 
 construct.
\end_float 

 and unioning
\begin_float footnote 

\layout Standard

The 
\series bold 
case
\series default 
 construct in records.
\end_float 

.
 However as an image processing language it suffers from the disadvantage
 that no support is provided for pixels and images.
 Given the vintage of the language this is not surprising and, it may be
 thought, this deficiency can be readily overcome using existing language
 features.
 Can pixels not be defined as a subrange 0..255 of the integers, and images
 modeled as two dimensional arrays?
\layout Standard

They can be, and are so defined in many applications, but such an approach
 throws onto the programmer the whole burden of handling the complexities
 of limited precision arithmetic.
 Among the problems are:
\layout Enumerate

When doing image processing it is frequently necessary to subtract one image
 from another, or to create negatives of an image.
 Subtraction and negation implies that pixels should be able to take on
 negative values. 
\layout Enumerate

When adding pixels using limited precision arithmetic, addition is nonmontonic
 due to wrap-round.
 Pixel values of 
\begin_inset Formula \( 100 + 200 = 300\)
\end_inset 

, which in 8 bit precision is truncated to 44 a value darker than either
 of the starting values.
 A similar problem can arise with subtraction, for instance 
\begin_inset Formula \( 100-200=156\)
\end_inset 

 in 8 bit unsigned arithmetic. 
\layout Enumerate

When multiplying 8 bit numbers, as one does in executing a convolution kernel,
 one has to enlarge the representation and shift down by an appropriate
 amount to stay within range. 
\layout Standard

These and similar problems make the coding of image filters a skilled task.
 The difficulty arises because one is using an inappropriate conceptual
 representation of pixels.
\layout Standard

The 
\emph on 
conceptual model
\emph default 
 of pixels in Vector Pascal is that they are real numbers in the range 
\begin_inset Formula \( -1.0 .. 1.0\)
\end_inset 

.
 This representation overcomes the aforementioned difficulties.
 As a signed representation it lends itself to subtraction.
 As an unbiased representation, it makes the adjustment of contrast easier,
 one can reduce contrast 50% simply by multiplying an image by 0.5 
\begin_float footnote 

\layout Standard

When pixels are represented as integers in the range 0..255, a 50% contrast reduction has to be expressed as 
\begin_inset Formula \( ((p-128) \div 2)+128\)
\end_inset 

.
\end_float 

.
 Assignment to pixel variables in Vector Pascal is defined to be saturating
 - real numbers outside the range 
\begin_inset Formula \( -1..1\)
\end_inset 

 are clipped to it.
 The multiplications involved in convolution operations fall naturally into
 place.
\layout Standard

The 
\emph on 
implementation model
\emph default 
 of pixels used in Vector Pascal is of 8 bit signed integers treated as
 fixed point binary fractions.
 All the conversions necessary to preserve the monotonicity of addition,
 the range of multiplication etc, are delegated to the code generator which,
 where possible, will implement the semantics using efficient, saturated
 multi-media arithmetic instructions.
\layout Subsection

Dimensioned Types
\layout Standard

Dimensional analysis is familiar to scientists and engineers and provides
 a routine check on the sanity of mathematical expressions.
 Dimensions can not be expressed in the otherwise rigourous type system
 of standard Pascal, but they are a useful protection against the sort of
 programming confusion between imperial and metric units that caused the
 demise of a recent Mars probe.
 They provide a means by which floating point types can be specialised to
 represent dimensioned numbers as is required in physics calculations.
 For example:
\layout Standard


\series bold 
kms =(mass,distance,time);
\series default 

\layout Standard


\series bold 
meter=real of distance;
\series default 

\layout Standard


\series bold 
kilo=real of mass;
\series default 

\layout Standard


\series bold 
second=real of time;
\series default 

\layout Standard


\series bold 
newton=real of mass * distance * time POW -2;
\series default 

\layout Standard


\series bold 
meterpersecond = real of distance *time POW -1;
\series default 

\layout Standard

The identifier must be a member of a scalar type, and that scalar type is
 then refered to as the 
\emph on 
basis space
\emph default 
 of the dimensioned type.
 The identifiers of the basis space are refered to as the dimensions of
 the dimensioned type.
 Associated with each dimension of a dimensioned type there is an integer
 number refered to as the power of that dimension.
 This is either introduced explicitly at type declaration time, or determined
 implicitly for the dimensional type of expressions.
\layout Standard

A value of a dimensioned type is a dimensioned value.
 Let 
\begin_inset Formula \(  \log _{d}t \)
\end_inset 

 of a dimensioned type 
\begin_inset Formula \(  t \)
\end_inset 

 be the power to which the dimension 
\begin_inset Formula \(  d \)
\end_inset 

 of type 
\begin_inset Formula \(  t \)
\end_inset 

 is raised.
 Thus for 
\begin_inset Formula \(  t= \)
\end_inset 

newton in the example above, and 
\begin_inset Formula \(  d= \)
\end_inset 

time, 
\begin_inset Formula \(  \log _{d}t=-2 \)
\end_inset 


\layout Standard

If 
\begin_inset Formula \(  x \)
\end_inset 

 and 
\begin_inset Formula \(  y \)
\end_inset 

 are values of dimensioned types 
\begin_inset Formula \(  t_{x} \)
\end_inset 

and 
\begin_inset Formula \(  t_{y} \)
\end_inset 

respectively, then the following operators are only permissible if 
\begin_inset Formula \(  t_{x}=t_{y} \)
\end_inset 

: +, - ,<, >, =, <=, >=.
 For + and -, the dimensional type of the result is the same as that of
 the arguments.
 The operations.
 The operations *, / are permited if the types 
\begin_inset Formula \(  t_{x} \)
\end_inset 

and 
\begin_inset Formula \(  t_{y} \)
\end_inset 

 share the same basis space, or if the basis space of one of the types is
 a subrange of the basis space of the other.
\layout Standard

The operation 
\series bold 
POW
\series default 
 is permited between dimensioned types and integers.
\layout Paragraph*

Dimension deduction rules
\layout Enumerate

If 
\begin_inset Formula \(  x=y*z \)
\end_inset 

 for 
\begin_inset Formula \(  x:t_{1},y:t_{2},z:t_{3} \)
\end_inset 

 with basis space 
\begin_inset Formula \(  B \)
\end_inset 

 then 
\begin_inset Formula \(  \forall _{d\in B}\log _{d}t_{1}=\log _{d}t_{2}+\log _{d}t_{3} \)
\end_inset 

. 
\layout Enumerate

If 
\begin_inset Formula \(  x=y/z \)
\end_inset 

 for 
\begin_inset Formula \(  x:t_{1},y:t_{2},z:t_{3} \)
\end_inset 

 with basis space 
\begin_inset Formula \(  B \)
\end_inset 

 then 
\begin_inset Formula \(  \forall _{d\in B}\log _{d}t_{1}=\log _{d}t_{2}-\log _{d}t_{3} \)
\end_inset 

. 
\layout Enumerate

If 
\begin_inset Formula \(  x=y \)
\end_inset 

 
\series bold 
POW
\series default 
 
\begin_inset Formula \(  z \)
\end_inset 

 for 
\begin_inset Formula \(  x:t_{1},y:t_{2},z:integer \)
\end_inset 

 with basis space for 
\begin_inset Formula \(  t_{2} \)
\end_inset 

, 
\begin_inset Formula \(  B \)
\end_inset 

 then 
\begin_inset Formula \(  \forall _{d\in B}\log _{d}t_{1}=\log _{d}t_{2}\times z \)
\end_inset 

. 
\layout Section

Operators
\layout Subsubsection

Dyadic Operations
\layout Standard

Dyadic operators supported are 
\series bold 
+, +:, -:, -, *, /, div, mod , **, pow, <, >, >=, <=, =, <>, shr, shl, and, or, in, min, max
\series default 
.
 All of these are consistently extended to operate over arrays.
 The operators **, pow denote exponentiation and raising to an integer power as in ISO Extended
 Pascal.
 The operators +: and -: exist to support saturated arithmetic on bytes
 as supported by the MMX instruction set. 
\layout Subsubsection

Unary operators
\layout Standard

The unary operators supported are 
\series bold 
+, -, *, /, max, min, div, not, round, sqrt, sin, cos, tan, abs, ln, ord, chr,
 succ, pred
\series default 
 and 
\series bold 
@
\series default 
.
\layout Standard

Thus the following are valid unary expressions
\series bold 
: -1, +b, not true, sqrt abs x, sin theta.
\series default 
 In standard Pascal some of these operators are treated as functions,.
 Syntactically this means that their arguments must be enclosed in brackets,
 as in 
\series bold 
sin(theta)
\series default 
.
 This usage remains syntactically correct in Vector Pascal.
\layout Standard

The dyadic operators are extended to unary context by the insertion of an
 identity element under the operation.
 This is a generalisation of the monadic use of + and - in standard pascal
 where 
\series bold 
+a=0+a
\series default 
 and 
\series bold 
-a = 0-a
\series default 
 with 0 being the additive identity, so too 
\series bold 
/2 = 1/2
\series default 
 with 1 the multiplicative identity.
 For sets the notation 
\series bold 
-s
\series default 
 means the complement of the set 
\series bold 
s
\series default 
.
 The identity elements inserted are given in table 
\begin_inset LatexCommand \ref{ids}

\end_inset 

. 
\begin_float tab 

\layout Caption

Identity element
\layout Standard


\begin_inset LatexCommand \label{ids}

\end_inset 


\latex latex 
 
\backslash vspace{0.3cm}
\latex default 
 
\latex latex 

\backslash centering 
\latex default 

\layout Standard



\LyXTable
multicol5
7 3 0 0 0 0 0 0
1 2 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 1 "" ""
8 0 1 "" ""
8 0 1 "" ""
0 8 1 2 0 0 0 "" ""
0 8 1 2 0 0 0 "" ""
0 8 1 2 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

type
\newline 
 operators
\newline 
 identity elem
\newline 
number
\newline 
 +,-
\newline 
 0
\newline 
set
\begin_inset LatexCommand \index{set}

\end_inset 


\newline 
 +
\newline 
 empty set
\newline 
set
\newline 
 -,*
\newline 
 fullset
\newline 
number
\newline 
 *,/ ,div,mod
\newline 
 1
\newline 
boolean
\begin_inset LatexCommand \index{boolean}

\end_inset 


\newline 
 and
\newline 
 true
\newline 
boolean
\newline 
 or 
\newline 
 false
 


\layout Standard


\latex latex 

\backslash par{}
\latex default 

\latex latex 
 
\backslash vspace{0.3cm}
\latex default 

\end_float 


\layout Subsubsection

Operator overloading
\layout Standard

The dyadic operators can be extended to operate on new types by operator
 overloading.
 Figure 
\begin_inset LatexCommand \ref{complex}

\end_inset 

 shows how arithmetic on the type 
\series bold 
complex
\series default 
 required by Extended Pascal 
\begin_inset LatexCommand \cite{ISO90}

\end_inset 

 is defined in Vector Pascal.
 Each operator is associated with a semantic function and an identity element.
 The operator symbols must be drawn from the set of predefined vector pascal
 operators, and when expressions involving them are parsed, priorities are
 inherited from the predefined operators.
 The type signature of the operator is deduced from the type of the function
\begin_float footnote 

\layout Standard

Vector Pascal allows function results to be of any type.
\end_float 

. 
\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
type
\newline 
        complex = record data: array[0..1] of real;end;
\newline 
var     complexzero,complexone:complex;
\newline 

\newline 
{ headers for functions onto the complex numbers }	
\newline 
function cmplx               (realpart,imag:real):complex;
\newline 
function complex_add         (A,B:Complex):complex;
\newline 
function complex_conjugate   (A:Complex):complex; 
\newline 
function complex_subtract    (A,B:Complex):complex; 
\newline 
function complex_multiply    (A,B:Complex):complex;  
\newline 
function complex_divide      (A,B:Complex):complex;  
\newline 
function im                  (c:complex):real; 
\newline 
function re                  (c:complex):real;
\newline 
{	Standard operators on complex numbers 	}
\newline 
{           symbol   function           identity element }
\newline 
operator    + =     complex_add,       complexzero;
\newline 
operator    / =     complex_divide,    complexone;
\newline 
operator    * =     complex_multiply,  complexone;
\newline 
operator    - =     complex_subtract,  complexzero;
\newline 

\backslash end{verbatim}
\latex default 

\layout Caption

Defining operations on complex numbers
\layout Standard


\begin_inset LatexCommand \label{complex}

\end_inset 


\size small 
Note that only the function headers are given here as this code comes from
 the interface part of the system unit.
 The function bodies and the initialisation of the variables complexone
 and complexzero are handled in the implementation part of the unit.
\size default

\end_float 

 When parsing expressions, the compiler first tries to resolve operations
 in terms of the predefined operators of the language, taking into account
 the standard mechanisms allowing operators to work on arrays.
 Only if these fail does it search for an overloaded operator whose type
 signature matches the context.
\layout Standard

In the example in figure 
\begin_inset LatexCommand \ref{complex}

\end_inset 

, complex numbers are defined to be records containing an array of reals,
 rather than simply as an array of reals.
 Had they been so defined, the operators +,*,-,/ on reals would have masked
 the corresponding operators on complex numbers.
\layout Standard

The provision of an identity element for complex addition and subtraction
 ensures that unary minus, as in 
\begin_inset Formula \( -x\)
\end_inset 

 for 
\begin_inset Formula \( x:\)
\end_inset 

complex, is well defined, and correspondingly that unary / denotes complex
 reciprocal.
 Overloaded operators can be used in array maps and array reductions. 
\layout Section

An example algorithm
\layout Standard

As an example of Vector Pascal we will look at an image filtering algorithm.
 In particular we will look at applying a separable 3 element convolution
 kernel to an image.
 We shall initially present the algorithm in standard Pascal and then look
 at how one might re-express it in Vector Pascal.
\layout Standard

Convolution of an image by a matrix of real numbers can be used to smooth
 or sharpen an image, depending on the matrix used.
 If 
\begin_inset Formula \( A\)
\end_inset 

 is an output image, 
\begin_inset Formula \( K\)
\end_inset 

 a convolution matrix, then if 
\begin_inset Formula \( B\)
\end_inset 

 is the convolved image 
\begin_inset Formula \[ B_{y,x}=\sum_{i}\sum_{j} A_{y+i,x+j}K_{i,j}\]
\end_inset 


\layout Standard

A separable convolution kernel is a vector of real numbers that can be applied
 independently to the rows and columns of an image to provide filtering.
 It is a specialisation of the more general convolution matrix, but is algorithm
ically
 more efficient to implement.
 If 
\series bold 
k
\series default 
 is a convolution vector, then the corresponding matrix 
\begin_inset Formula \( K\)
\end_inset 

 is such that 
\begin_inset Formula \( K_{i,j}={\textbf{k}}_{i} {\textbf{k}}_{j}\)
\end_inset 

.
\layout Standard

Given a starting image 
\begin_inset Formula \( A\)
\end_inset 

 as a two dimensional array of pixels, and a three element kernel 
\begin_inset Formula \(  c_{1}, c_{2}, c_{3}\)
\end_inset 

, the algorithm first forms a temporary array 
\begin_inset Formula \( T\)
\end_inset 

 whose whose elements are the weighted sum of adjacent rows 
\begin_inset Formula \( T_{y,x}=c_{1}A_{y-1,x}+c_{2}A_{y,x}+c_{3}A_{y+1,x}\)
\end_inset 

.
 Then in a second phase it sets the original image to be the weighted sum
 of the columns of the temporary array: 
\begin_inset Formula \( A_{y,x}=c_{1}T_{y,x-1}+c_{2}T_{y,x}+c_{3}T{y,x+1}\)
\end_inset 

.
 Clearly the outer edges of the image are a special case, since the convolution
 is defined over the neighbours of the pixel, and the pixels along the boundarie
s
 a missing one neighbour.
 A number of solutions are available for this, but for simplicity we will
 perform only vertical convolutions on the left and right edges and horizontal
 convolutions on the top and bottom lines of the image.
\layout Standard


\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
type
\newline 
    pixel = -128..127;
\newline 
    tplain = array[0..maxpix ,0..maxpix] of pixel;
\newline 

\newline 
procedure conv(var theim:tplain;c1,c2,c3:real);
\newline 
var tim:array[0..maxpix,0..maxpix]of pixel;
\newline 
    temp:real;
\newline 
    i,j:integer;
\newline 
begin
\newline 
        for i:=1 to maxpix-1 do
\newline 
         for j:= 0 to maxpix do begin 
\newline 
              temp:= theim[i-1][j]*c1+theim[i][j]*c2+theim[i+1][j]*c3;
\newline 
              if temp>127 then temp :=127 else
\newline 
              if temp<-128 then temp:=-128;
\newline 
              tim[i][j]:=round(temp);
\newline 
         end;
\newline 
        for j:= 0 to maxpix do begin
\newline 
                tim[0][j]:=theim[0][j]; tim[maxpix][j]:=theim[maxpix][j];
\newline 
        end;
\newline 
        for i:=0 to maxpix do begin
\newline 
            for j:= 1 to maxpix-1 do begin
\newline 
                temp:= tim[i][j-1]*c1+tim[i][j+1]*c3+tim[i][j]*c2;
\newline 
                if temp>127 then temp :=127 else
\newline 
                if temp<-128 then temp:=-128;
\newline 
                tim[i][j]:=round(temp);
\newline 
            end;
\newline 
            theim[i][0]:=tim[i][0]; theim[i][maxpix]:=tim[i][maxpix];
\newline 
        end;
\newline 
end;
\newline 

\backslash end{verbatim}
\latex default 

\layout Caption

Standard Pascal implementation of the convolution
\layout Standard


\begin_inset LatexCommand \label{sconv}

\end_inset 


\end_float 

 Figure 
\begin_inset LatexCommand \ref{sconv}

\end_inset 

 shows 
\family typewriter 
conv
\family default 
 an implementation of the convolution in Standard Pascal.
 The pixel data type has to be explicitly introduced as the subrange -128..127.
 Explicit checks have to be inplace to prvent range errors, since the result
 of a convolution may, depending on the kernel used, be outside the bounds
 of valid pixels.
 Arithmetic is done in floating point and then rounded. 
\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
procedure pconv(var theim:tplain;c1,c2,c3:real);
\newline 
var tim:array[0..maxpix,0..maxpix]of pixel;
\newline 
    p1,p2,p3:array[0..maxpix]of  pixel;
\newline 
begin
\newline 
     p1:=c1; p2:=c2; p3:=c3;        
\newline 
     tim [1..maxpix-1] := 
\newline 
        theim[0..maxpix-2]*p1 +theim[1..maxpix-1]*p2+theim[2..maxpix]*p3;
\newline 
     tim[0]:=theim[0]; tim[maxpix]:=theim[maxpix];
\newline 
     theim[][1..maxpix-1]:=
\newline 
        tim[][0..maxpix-2]*p1+tim[][2..maxpix]*p3+tim[][1..maxpix-1]*p2;
\newline 
     theim[][0]:=tim[][0]; theim[][maxpix]:=tim[][maxpix];
\newline 
end;
\backslash end{verbatim}
\latex default 

\layout Caption

Vector Pascal implementation of the convolution
\layout Standard


\begin_inset LatexCommand \label{vconv}

\end_inset 


\end_float 


\layout Standard

Image processing algorithms lend themselves particularly well to data-parallel
 expression, working as they do on arrays of data subject to uniform operations.
 Figure 
\begin_inset LatexCommand \ref{vconv}

\end_inset 

 shows a data-parallel version of the algorithm, 
\family typewriter 
pconv
\family default 
, implemented in Vector Pascal.
 Note that all explicit loops disappear in this version, being replaced
 by assignments of array slices.
 The first line of the algorithm initialises three vectors 
\family typewriter 
p1, p2, p3
\family default 
 of pixels to hold the replicated copies of the kernel coefficients 
\family typewriter 
c1, c2, c3
\family default 
 in fixed point format.
 These vectors are then used to multiply rows of the image to build up the
 convolution.
 The notation 
\family typewriter 
theim[][1..maxpix-1]
\family default 
 denotes columns 1..maxpix-1 of all rows of the image.
 Because the built in pixel data type is used, all range checking is handled
 by the compiler.
 Since fixed point arithmetic is used throughout, there will be slight rounding
 errors not encountered with the previous algorithm, but these are acceptable
 in most image processing applications.
 Fixed point pixel arithmetic has the advantage that it can be efficently
 implemented in parallel using multi-media instructions.
\layout Standard

It is clear that the data-parallel implementation is somewhat more concise
 than the sequential one, 12 lines with 505 characters compared to 26 lines
 with 952 characters.
 It also runs considerably faster, as shown in table 
\begin_inset LatexCommand \ref{convperf}

\end_inset 

.
 This expresses the performance of different implementations in millions
 of effective arithmetic operations per second.
 It is assumed that the basic algorithm requires 6 multiplications and 6
 adds per pixel processed.
 The data parallel algorithm runs 12 times faster than the serial one when
 both are compiled using Vector Pascal and targeted at the MMX instructionset.
 The 
\family typewriter 
pconv
\family default 
 also runs a third faster than 
\family typewriter 
conv
\family default 
 when it is targeted at the 486 instructionset, which in effect, serialises
 the code.
\layout Standard

For comparison 
\family typewriter 
conv
\family default 
 was run on other Pascal Compilers
\begin_float footnote 

\layout Standard

In addition to those shown the tests were perfomed on PascalX, which failed
 either to compile or to run the benchmarks.
 TMT Pascal failed to run the convolution test.
\end_float 

, DevPascal 1.9, Borland Pascal and its successor Delphi
\begin_float footnote 

\layout Standard

version 4
\end_float 

.
 These are extended implementations, but with no support for vector arithmetic.
 Delphi is are state of the art commercial compilers, as Borland Pascal
 was when released in 1992.
 DevPas is a recent free compiler.
 In all cases range checking was enabled for consistency with Vector Pascal.
 The only other change was to define the type pixel as equivalent to the
 system type shortint to force implementation as a signed byte.
 Delphi runs 
\family typewriter 
conv
\family default 
 40% faster than Vector Pascal does, whereas Borland Pascal runs it at only
 7% of the speed.
\layout Standard


\begin_float tab 

\layout Caption

Comparative Performance on Convolution
\layout Standard


\begin_inset LatexCommand \label{convperf}

\end_inset 


\layout Standard



\LyXTable
multicol5
7 4 0 0 0 0 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
2 0 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
8 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 8 0 0 0 0 0 "" ""

Algorithm
\newline 
Implementation
\newline 
Target Processor
\newline 
Million Ops Per Second
\newline 
conv
\newline 
Vector Pascal
\newline 
Pentium + MMX 
\newline 
61
\newline 

\newline 
Borland Pascal
\newline 
286 + 287
\newline 
5.5
\newline 

\newline 
Delphi 4
\newline 
486 
\newline 
86
\newline 

\newline 
DevPascal
\newline 
486
\newline 
62
\newline 
pconv
\newline 
Vector Pascal
\newline 
486 
\newline 
80 
\newline 

\newline 
Vector Pascal
\newline 
Pentium + MMX 
\newline 
817
\newline 


\layout Standard


\size small 
Measurements done on a 1Ghz Athlon, running Windows 2000.
\size default

\end_float 

 Further performance comparisons are given in table 
\begin_inset LatexCommand \ref{kernels}

\end_inset 

.
 The tests here involve vector arithmetic on vectors of length 640 and take
 the general form 
\begin_inset Formula \( v_{1}=v_{2} \phi v_{3}\)
\end_inset 

 for some operator 
\begin_inset Formula \( \phi\)
\end_inset 

 and some vectors 
\begin_inset Formula \( v_{1}, v_{2}, v_{3}\)
\end_inset 

.
 The exception being the dot product operation coded as 
\latex latex 

\backslash begin{verbatim}
\newline 
r:=
\backslash + r2*r3
\newline 

\backslash end{verbatim}
\latex default 
 in Vector Pascal, and using conventional loops for the other compilers.
 When targeted on a 486 the performance of the Vector Pascal compiler is
 roughly comparable with that of Delphi.
 The exception being dot product operations on which Delphi performs particularl
y
 well.
 When the target machine is a K6 which incorporates both the MMX and the
 3DNow SIMD instruction sets, the acceleration is broadly in line with the
 degree of parallelism offered by the architecture: 8 fold for byte operands,
 4 fold for 16 bit ones, and 2 fold for integers and reals.
 The speedup is best for the 8 bit operands, a sevenfold acceleration on
 byte additions for example.
 For larger operands it falls off to 60% for 32 bit integers and 33% for 32 bit reals.
\layout Standard

For data types where saturated arithmetic is used, the accleration is most
 marked, a 12 fold acceleration being achieved for saturated byte additions
 and a 16 fold acceleration on pixel additions.
 These additional gains come from the removal of bounds checking code that
 would otherwise be required. 
\layout Standard


\begin_float tab 

\layout Caption

Performance on vector kernels
\layout Standard


\begin_inset LatexCommand \label{kernels}

\end_inset 


\layout Standard



\LyXTable
multicol5
10 7 0 0 0 0 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
2 0 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
2 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""
0 2 0 0 0 0 0 "" ""

 DevP
\newline 
TMT
\newline 
BP 286
\newline 
DP 486
\newline 
VP 486
\newline 
VP K6
\newline 
test
\newline 
71
\newline 
80
\newline 
46 
\newline 
166
\newline 
333
\newline 
 2329 
\newline 
 unsigned byte additions 
\newline 
 55
\newline 
57
\newline 
38
\newline 
110
\newline 
179
\newline 
 2329 
\newline 
 saturated unsigned byte additions
\newline 
 85
\newline 
59
\newline 
47 
\newline 
285 
\newline 
291 
\newline 
 466 
\newline 
 32 bit integer additions
\newline 
 66
\newline 
74
\newline 
39
\newline 
124 
\newline 
291
\newline 
 1165
\newline 
16 bit integer additions
\newline 
47
\newline 
10
\newline 
33
\newline 
250 
\newline 
291
\newline 
388 
\newline 
real additions 
\newline 
49
\newline 
46
\newline 
23
\newline 
98
\newline 
146
\newline 
2330
\newline 
pixel additions 
\newline 
67
\newline 
14
\newline 
39
\newline 
99
\newline 
146
\newline 
1165
\newline 
pixel multiplications 
\newline 
47
\newline 
10
\newline 
32
\newline 
161
\newline 
146
\newline 
141 
\newline 
real dot product 
\newline 
79
\newline 
58
\newline 
33
\newline 
440 
\newline 
161
\newline 
166 
\newline 
integer dot product 
\newline 


\layout Standard


\size small 
DevP - Dev Pascal version 1.9
\layout Standard


\size small 
TMT - TMT Pascal version 3
\layout Standard


\size small 
BP 286 - Borland Pascal compiler with 287 instructions enabled range checks
 off.
\layout Standard


\size small 
DP 486 - Delphi version 4
\layout Standard


\size small 
VP 486 - Vector Pascal targeted at a 486
\layout Standard


\size small 
VP K6 - Vector Pascal targeted at and AMD K6
\layout Standard


\size small 
All figures in millions of operations per second on a 1 Ghz Athlon.
\size default

\end_float 


\layout Paragraph

Performance on the Dhrystone Benchmark
\layout Standard

For an indicator of the performance of Vector Pascal on other instruction
 mixes, the Dhrystone Pascal benchmark was used.
 This indicates that Vector Pascal is substantially slower on such instruction
 mixes than Delphi but considerably faster than Borland Pascal.
 All measurements were performed on a 1Ghz Athlon.
 One reason why the Delphi compiler is so fast is its use of registers for
 parameter passing in procedure calls. 
\begin_float tab 

\layout Caption

Dhrystone performance
\layout Standard


\latex latex 

\backslash vspace{0.3cm}
\latex default 
 
\latex latex 

\backslash centering 
\latex default 

\layout Standard



\LyXTable
multicol5
6 3 0 0 0 0 0 0
1 2 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 1 "" ""
4 0 1 "" ""
4 0 1 "" ""
0 8 1 2 0 0 0 "" ""
0 4 1 2 0 0 0 "" ""
0 4 1 2 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""
0 4 0 1 0 0 0 "" ""

Compiler
\newline 
 Dhrystones per sec
\newline 
 Microseconds Per Dhrystone
\newline 
Borland Pascal
\newline 
 444444
\newline 
 2.3
\newline 
Vector Pascal
\newline 
 805282
\newline 
 1.2
\newline 
TMT Pascal
\newline 
 1123848
\newline 
 0.9
\newline 
DevPascal
\newline 
 1404494
\newline 
 0.7
\newline 
Delphi
\newline 
 2472187
\newline 
 0.4
 


\layout Standard


\latex latex 

\backslash par{}
\latex default 

\latex latex 

\backslash vspace{0.3cm}
\latex default 

\end_float 


\layout Section

Implementation
\layout Standard

At the heart of our implementation is the machine independent Intermediate
 Language for Code Generation (ILCG).
 ILCG
\begin_inset LatexCommand \cite{Cockshott00}

\end_inset 

 is strongly typed, supporting the base types common in most programming
 languages along with type constructors for vectors, stacks and references.
 In particular, operators may be implicitly overloaded for vector operations.
 Its purpose is to act as an input to an automatically constructed code
 generator, working on the syntax matching principles described in 
\begin_inset LatexCommand \cite{graham80}

\end_inset 

.
 Simple rules link high-level register transfer descriptions with the equivalent
 low-level assembly representations.
 ILCG may be used as a machine-oriented semantics of a high-level program
 or of a CPU.
 It may also be used as an intermediate language for program transformation.
 
\layout Subsection

Analogous work
\layout Standard

There has been sustained research within the parallel programming community
 into the exploitation of SIMD parallelism on multi-processor architectures.
 Most work in this field has been driven by the needs of high-performance
 scientific processing, from finite element analysis to meteorology.
 In particular, there has been considerable interest in exploiting data
 parallelism in FORTRAN array processing, culminating in High Performance
 Fortran and F.
 Typically this involves two approaches.
 First of all, operators may be overloaded to allow array-valued expressions,
 similar to APL.
 Secondly, loops may be analysed to establish where it is possible to unroll
 loop bodies for parallel evaluation.
 Compilers embodying these techniques tend to be architecture specific to
 maximise performance and they have been aimed primarily at specialised
 super-computer architectures, even though contemporary general purpose
 microprocessors provide similar features, albeit on a far smaller scale.
\layout Standard

There has been recent interest in the application of vectorisation techniques
 to instruction level parallelism.
 Thus, Cheong and Lam 
\begin_inset LatexCommand \cite{Cheong97}

\end_inset 

 discuss the use of the Stanford University SUIF parallelising compiler
 to exploit the SUN VIS extensions for the UltraSparc from C programs.
 They report speedups of around 4 on byte integer parallel addition.
 Krall and Lelait's compiler 
\begin_inset LatexCommand \cite{Krall00}

\end_inset 

 also exploits the VIS extensions on the Sun UltraSPARC processor from C
 using the CoSy compiler framework.
 They compare classic vectorisation techniques to unrolling, concluding
 that both are equally effective, and report speedups of 2.7 to 4.7.
 Sreraman and Govindarajan 
\begin_inset LatexCommand \cite{Sreraman00}

\end_inset 

 exploit Intel MMX parallelism from C with SUIF, using a variety of vectorisatio
n
 techniques to generates inline assembly language, achieving speedups from
 2 to 6.5.
 All of these groups target specific architectures.
 Finally, Leupers 
\begin_inset LatexCommand \cite{Leupers99}

\end_inset 

 has reported a C compiler that uses vectorising optimisation techniques
 for compiling code for the multimedia instruction sets of some signal processor
s,
 but this is not generalised to the types of processors used in desktop
 computers.
\layout Standard

There has been extensive research, initiated by Graham and Glanville, into
 the automatic production of code generators but predominantly for conventional
 rather than parallel instruction sets.
 There has also been research in the hardware/software co-design community
 into compilation techniques for non-standard architectures.
 Leupers 
\begin_inset LatexCommand \cite{Leupers94}

\end_inset 

 MIMOLA language allows the expression of both programs and structural hardware
 descriptions, driving the micro-code compiler MSSQ.
 Hadjiyiannis' 
\begin_inset LatexCommand \cite{Hadjiyiannis97}

\end_inset 

 Instruction Set Description Language and Ramsey and Davidson's 
\begin_inset LatexCommand \cite{Ramsey97}

\end_inset 

 Specification Language for Encoding and Decoding are also aimed at embedded
 systems, based on low level architecture descriptions.It is not clear whether
 MIMOLA, ISDL or SLED could readily be used for describing data parallelism
 through operator overloading as found in MMX extensions.
 Furthermore, ISDL and SLED's type systems will not readily express the
 vector types required for MMX.
\layout Standard

To exploit MMX and other extended instruction sets it is desirable to develop
 compiler technology based on a richer meta-language which can express non-stand
ard
 instruction sets in a succinct but architecture independent manner.
 Such a meta-language should support a rich set of types and associated
 operators, and be amenable to formal manipulation.
 It should also support a relatively high level of abstraction from different
 manufacturers' register level implementations of what are effectively the
 same MMX operations.
\layout Subsection

Intermediate Language for Code Generation
\layout Standard

A Vector Pascal program is translated into an ILCG abstract semantic tree
 implemented as a Java datastructure.
 The tree is passed to a machine generated Java class corresponding to the
 code generator for the target machine.
 Code generator classes currently exist for the Intel 486, Pentium with
 MMX, and P3 and also the AMD K6.
 Output is assembler code which is assembled using the NASM assembler and
 linked using the gcc loader.
\layout Standard

The code generators follow the pattern matching approach described in
\begin_inset LatexCommand \cite{Aho}

\end_inset 


\begin_inset LatexCommand \cite{Cattel80}

\end_inset 

and 
\begin_inset LatexCommand \cite{graham80}

\end_inset 

, and are automatically generated from machine specifications written in
 ILCG .
 ILCG is a strongly typed language which supports vector data types and
 the mapping of operators over vectors.
 It is well suited to describing SIMD instruction sets.
 The code generator classes export from their interfaces details about the
 degree of parallelism supported for each data-type.
 This is used by the front end compiler to iterate over arrays longer than
 those supported by the underlying machine.
 Where supported parallelism is unitary, this defaults to iteration over
 the whole array.
\layout Standard

Selection of target machines is by a compile time switch which causes the
 appropriate code generator class to be dynamically loaded.
\layout Standard


\begin_float fig 

\layout Standard


\align center 

\begin_inset Figure
file system.eps
flags 9

\end_inset 


\layout Caption


\align center 
System Architecture
\layout Standard


\begin_inset LatexCommand \label{fig:system}

\end_inset 


\end_float 


\layout Standard

The structure of the Vector Pascal system is shown in figure 
\begin_inset LatexCommand \ref{fig:system}

\end_inset 

.
 It is complex.
\layout Standard

Consider first the path followed from a source file, the phases that it
 goes through are 
\layout Itemize

i.
 The source file (1) is parsed by a java class PascalCompiler.class (2)
 a hand written, recursive descent parser
\begin_inset LatexCommand \cite{Watt}

\end_inset 

, and results in a Java data structure (3), an ILCG tree, which is basically
 a semantic tree for the program. 
\layout Itemize

ii.
 The resulting tree is transformed (4) from sequential to parallel form
 and machine independent optimisations are performed.
 Since ILCG trees are java objects, they can contain methods to self-optimise.
 Each class contains for instance a method 
\family typewriter 
eval
\family default 
 which attempts to evaluate a tree at compile time.
 Another method 
\family typewriter 
simplify
\family default 
 applies generic machine independent transpormations to the code.
 Thus the 
\family typewriter 
simplify
\family default 
 method of the class 
\family typewriter 
For
\family default 
 can perform loop unrolling, removal of redundant loops etc.
 Other methods allow tree walkers to apply context specific transformations.
 
\layout Itemize

iii.
 The resulting ilcg tree (7) is walked over by a class that encapsulates
 the semantics of the target machine's instructionset (10); for example
 Pentium.class.
 During code generation the tree is futher transformed, as machine specific
 register optimisations are performed.
 The output of this process is an assembler file (11). 
\layout Itemize

iv.
 This is then fed through an appropriate assembler and linker, assumed to
 be externally provided to generate an executable program. 
\layout Subsection

Vectorisation
\layout Standard

The parser initially generates serial code for all constructs.
 It then interogates the current code generator class to determine the degree
 of parallelism possible for the types of operations performed in a loop,
 and if these are greater than one, it vectorises the code.
\layout Standard

Given the declaration
\layout Standard


\series bold 
var v1,v2,v3:array[1..9] of integer;
\series default 

\layout Standard

then the statement
\layout Standard


\series bold 
v1:=v2+v3;
\series default 

\layout Standard

would first be translated to the ILCG sequence shown in figure 
\begin_inset LatexCommand \ref{seqf}

\end_inset 


\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
{ var  i;
\newline 
  for  i=1 to 9 step 1 do {
\newline 
   v1[^i]:= +(^(v2[^i]),^(v3[^i]));
\newline 
  };
\newline 
}
\newline 

\backslash end{verbatim}
\latex default 

\layout Caption

Sequential form of array assignment
\layout Standard


\begin_inset LatexCommand \label{seqf}

\end_inset 


\end_float 

 In the example above variable names such as 
\family typewriter 
v1
\family default 
 and 
\family typewriter 
i
\family default 
 have been used for clarity.
 In reality 
\family typewriter 
i
\family default 
 would be an addressing expression like: 
\latex latex 

\backslash verb{ (ref int32)mem(+(^((ref int32)ebp),     -1860)){
\latex default 
, which encodes both the type and the address of the variable.
 The code generator is queried as to the parallelism available on the type
 
\family typewriter 
int32
\family default 
 and, since it is a Pentium with MMX, returns 2.
 The loop is then split into two, a portion that can be executed in parallel
 and a residual sequential component, resulting in the ILCG shown in figure
 
\begin_inset LatexCommand \ref{parf}

\end_inset 

.
\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
{ var i;  
\newline 
   for i=    1 to     8 step     2 do {
\newline 
    (ref int32 vector ( 2 ))mem(+(@v1,*(-(^i,1),4))):=
\newline 
       +(^((ref int32 vector ( 2 ))mem(+(@v2,*(-(^i,1),4)))), 
\newline 
         ^((ref int32 vector ( 2 ))mem(+(@v3,*(-(^i,1),4)))));
\newline 
   };
\newline 
   for i=    9 to     9 step     1 do {
\newline 
      v1[^i]:= +(^(v2[^i]),^(v3[^i]));
\newline 
   };
\newline 
}
\newline 

\backslash end{verbatim}
\latex default 

\layout Caption

Parallelised loop
\layout Standard


\begin_inset LatexCommand \label{parf}

\end_inset 


\end_float 

 In the parallel part of the code, the array subscriptions have been replaced
 by explictly cast memory addresses.
 This coerces the locations from their original types to the type required
 by the vectorisation.
 Applying the 
\family typewriter 
simplify 
\family default 
 method of the For class the following generic transformations are performed:
 
\layout Enumerate

The second loop is replaced by a single statement. 
\layout Enumerate

The parallel loop is unrolled twofold. 
\layout Enumerate

The For class is replaced by a sequence of statements with explicit gotos.
 
\layout Standard

The result is shown in figure 
\begin_inset LatexCommand \ref{simpf}

\end_inset 

.
 When the 
\family typewriter 
eval
\family default 
 method is invoked, constant folding causes the loop test condition to be
 evaluated to 
\latex latex 

\backslash verb{if >(^i,8) then	goto leb4af11b47f{
\latex default 
. 
\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
{ var i:
\newline 
  i:= 1;
\newline 
  leb4af11b47e:
\newline 
  if >( 2, 0) then	if >(^i,8) then	goto leb4af11b47f
\newline 
	                else null
\newline 
                        fi
\newline 
	 else if <(^i, 8) then	goto leb4af11b47f
\newline 
	 else null
\newline 
         fi
\newline 
  fi;
\newline 
 (ref int32 vector ( 2 ))mem(+(@v1,*(-(^i,1),4))):=
\newline 
       +(^((ref int32 vector ( 2 ))mem(+(@v2,*(-(^i,1),4)))), 
\newline 
         ^((ref int32 vector ( 2 ))mem(+(@v3,*(-(^i,1),4)))));
\newline 
  i:=+(^i,2);
\newline 
 (ref int32 vector ( 2 ))mem(+(@v1,*(-(^i,1),4))):=
\newline 
       +(^((ref int32 vector ( 2 ))mem(+(@v2,*(-(^i,1),4)))), 
\newline 
         ^((ref int32 vector ( 2 ))mem(+(@v3,*(-(^i,1),4)))));
\newline 
  i:=+(^i,2);
\newline 
  goto leb4af11b47e;
\newline 
  leb4af11b47f:
\newline 
  i:=    9;
\newline 
  v1[^i]:= +(^(v2[^i]),^(v3[^i]));
\newline 
}
\newline 

\backslash end{verbatim}
\latex default 

\layout Caption

After applying 
\family typewriter 
simplify
\family default 
 to the tree
\layout Standard


\begin_inset LatexCommand \label{simpf}

\end_inset 


\end_float 


\layout Subsection

Machine descriptions in ILCG
\layout Standard

ILCG exists both as a tree language, defined as a set of Java classes, and
 as a textual notation that can be used to describe the semantics of machine
 instructions.
\layout Standard

Pentium.class (10 in figure 
\begin_inset LatexCommand \ref{fig:system}

\end_inset 

) is produced from a file Pentium.ilc (8), in ILCG, which gives a semantic
 description of the Pentium's instructionset.
 This is processed by a code generator generator which builds the source
 file Pentium.java.
\layout Standard

A machine description typically consists of a set of register declarations
 followed by a set of instruction formats and a set of operations.
 This approach works well only with machines that have an orthogonal instruction
 set, ie, those that allow addressing modes and operators to be combined
 in an independent manner. 
\layout Subsubsection

Registers 
\layout Standard

When entering machine descriptions in ilcg registers can be declared along
 with their type hence 
\series bold 
register word EBX assembles['ebx'] ;
\layout Standard


\series bold 
reserved register word ESP assembles['esp'];
\series default 

\layout Standard

would declare 
\series bold 
EBX
\series default 
 to be of type 
\series bold 
ref word
\series default 
.
\layout Subsubsection

Aliasing
\layout Standard

A register can be declared to be a sub-field of another register, hence
 we could write 
\series bold 
 alias register octet AL = EAX(0:7) assembles['al'];
\layout Standard


\series bold 
alias register octet BL = EBX(0:7) assembles['bl'];
\series default 

\layout Standard

to indicate that 
\series bold 
BL
\series default 
 occupies the bottom 8 bits of register 
\series bold 
EBX
\series default 
.
 In this notation bit zero is taken to be the least significant bit of a
 value.
 There are assumed to be two pregiven registers 
\series bold 
FP, GP
\series default 
 that are used by compilers to point to areas of memory.
 These can be aliased to a particular real register.
\series bold 
register word EBP assembles['ebp'] ;
\layout Standard


\series bold 
alias register word FP = EBP(0:31) assembles ['ebp'];
\series default 

\layout Standard

Additional registers may be reserved, indicating that the code generator
 must not use them to hold temporary values:
\layout Standard


\series bold 
reserved register word ESP assembles['esp']; 
\series default 

\layout Subsubsection

Register sets
\layout Standard

A set of registers that are used in the same way by the instructionset can
 be defined. 
\series bold 
pattern reg means [
\begin_inset Formula \(  EBP| EBX|ESI|EDI|ECX |EAX|EDX|ESP\)
\end_inset 

] ;
\layout Standard


\series bold 
pattern breg means[
\begin_inset Formula \(  AL|AH|BL|BH|CL|CH|DL|DH\)
\end_inset 

]; 
\series default 

\layout Standard

All registers in an register set should be of the same length. 
\layout Subsubsection

Register Stacks
\layout Standard

Whilst some machines have registers organised as an array, another class
 of machines, those oriented around postfix instructionsets, have register
 stacks.
\layout Standard

The ILCG syntax allows register stacks to be declared:
\layout Standard


\series bold 
register stack (8)ieee64 FP assembles[ ' '] ;
\series default 

\layout Standard

Two access operations are supported on stacks: 
\layout Paragraph

PUSH
\layout Standard

is a void dyadic operator taking a stack of type ref 
\begin_inset Formula \( t\)
\end_inset 

 as first argument and a value of type 
\begin_inset Formula \( t\)
\end_inset 

 as the second argument.
 Thus we might have:  
\series bold 
PUSH(FP,
\begin_inset Formula \( \uparrow\)
\end_inset 

mem(20)) 
\series default 

\layout Paragraph

POP
\layout Standard

is a monadic operator returning 
\begin_inset Formula \( t\)
\end_inset 

 on stacks of type 
\begin_inset Formula \( t\)
\end_inset 

.
 So we might have 
\series bold 
mem(20):=POP(FP) 
\series default 

\layout Subsection

Instruction formats
\layout Standard

An instruction format is an abstraction over a class of concrete instructions.
 It abstracts over particular operations and types thereof whilst specifying
 how arguments can be combined. 
\series bold 
instruction pattern
\layout Standard


\series bold 
RR( operator op, anyreg r1, anyreg r2, int t)
\layout Standard


\series bold 
means[r1:=(t) op( 
\begin_inset Formula \( \uparrow\)
\end_inset 

((ref t) r1),
\begin_inset Formula \( \uparrow\)
\end_inset 

((ref t) r2))]
\layout Standard


\series bold 
assembles[op ' ' r1 ',' r2];
\series default 

\layout Standard

In the above example, we specify a register to register instruction format
 that uses the first register as a source and a destination whilst the second
 register is only a destination.
 The result is returned in register r1.
\layout Standard

We might however wish to have a more powerful abstraction, which was capable
 of taking more abstract apecifications for its arguments.
 For example, many machines allow arguments to instructions to be addressing
 modes that can be either registers or memory references.
 For us to be able to specify this in an instruction format we need to be
 able to provide grammer non-terminals as arguments to the instruction formats.
\layout Standard

For example we might want to be able to say
\layout Standard


\series bold 
instruction pattern
\layout Standard


\series bold 
RRM(operator op, reg r1, maddrmode rm, int t)
\layout Standard


\series bold 
means [r1:=(t) op( 
\begin_inset Formula \( \uparrow\)
\end_inset 

((ref t)r1),
\begin_inset Formula \( \uparrow\)
\end_inset 

((ref t) rm))]
\layout Standard


\series bold 
assembles[op ' ' r1 ',' rm ] ;
\series default 

\layout Standard

This implies that addrmode and reg must be non terminals.
 Since the non terminals required by different machines will vary, there
 must be a means of declaring such non-terminals in ilcg.
\layout Standard

An example would be:  
\series bold 
 pattern regindirf(reg r) means[
\begin_inset Formula \( \uparrow\)
\end_inset 

(r) ] assembles[ r ];
\layout Standard


\series bold 
pattern baseplusoffsetf(reg r, signed s) means[+( 
\begin_inset Formula \( \uparrow\)
\end_inset 

(r) ,const s)] assembles[ r '+' s ];
\layout Standard


\series bold 
pattern addrform means[baseplusoffsetf
\begin_inset Formula \( |\)
\end_inset 

 regindirf];
\layout Standard


\series bold 
pattern maddrmode(addrform f) means[mem(f) ] assembles[ '[' f ']' ];
\series default 

\layout Standard

This gives us a way of including non terminals as parameters to patterns.
 Instruction patterns can also specify vector operations as in: 
\series bold 
 instruction pattern PADDD(mreg m, mrmaddrmode ma)
\layout Standard


\series bold 
means[(ref int32 vector(2)m:=(int32 vector(2))+( (int32 vector(2))
\begin_inset Formula \( \uparrow\)
\end_inset 

(m),(int32 vector(2))
\begin_inset Formula \( \uparrow\)
\end_inset 

(ma)))]
\layout Standard


\series bold 
assembles ['paddd 'm ',' ma];
\series default 

\layout Standard

Here vector casts are used to specify that the result register will hold
 the type 
\series bold 
int32 vector(2)
\series default 
, and to constrain the types of the arguments and results of the + operator.
 
\layout Subsection

Instructionsets
\layout Standard

At the end of an ILCG machine description file, the instructionset is defined.
 This is given as an ordered list of instruction patterns.
 When generating code the patterns are applied in the order in which they
 are specified until a complete match of a statement has been achieved.
 If a partial match fails the code generator backtracks and attempts the
 next instruction.
 Care has to be taken to place the most general and powerfull instructions
 first.
 Figure 
\begin_inset LatexCommand \ref{matchf}

\end_inset 

 illustrates this showing the effect of matching the parallelised loop shown
 in figure 
\begin_inset LatexCommand \ref{simpf}

\end_inset 

 against the Pentium instruction set.
 Note that incrementing the loop counter is performed using load effective
 address (lea) since this, being more general, occurs before add in the
 instruction list.
\layout Standard

This pattern matching with backtracking can potentially be slow, so the
 code generator operates in learning mode.
 For each subtree that it has sucessfully matched, it stores a string representa
tion
 of the tree in a hash table along with the instruction that matched it.
 When a tree has to be matched, it checks the hash table to see if an equivalent
 tree has already been recognised.
 In this way common idioms only have to be fully analysed the first time
 that they are encountered. 
\begin_float fig 

\latex latex 

\backslash begin{verbatim}
\newline 
 mov DWORD ecx,     1
\newline 
 leb4b08729615:
\newline 
 cmp DWORD ecx,      8
\newline 
 jg near  leb4b08729616
\newline 
 lea edi,[  ecx-(     1)]; substituting in edi with 3 occurences and score of 1
\newline 
 movq MM1, [  ebp+edi* 4+     -1620]
\newline 
 paddd MM1, [  ebp+edi* 4+     -1640]
\newline 
 movq  [  ebp+edi* 4+     -1600],MM1
\newline 
 lea ecx,[  ecx+     2]
\newline 
 lea edi,[  ecx-(     1)]; substituting in edi with 3 occurences and score of 1
\newline 
 movq MM1, [  ebp+edi* 4+     -1620]
\newline 
 paddd MM1, [  ebp+edi* 4+     -1640]
\newline 
 movq  [  ebp+edi* 4+     -1600],MM1
\newline 
 lea ecx,[  ecx+     2]
\newline 
 jmp  leb4b08729615
\newline 
 leb4b08729616:
\newline 

\backslash end{verbatim}
\latex default 

\layout Caption

The result of matching the parallelised loop against the Pentium instruction
 set
\layout Standard


\begin_inset LatexCommand \label{matchf}

\end_inset 


\end_float 


\layout Section

Conclusions
\layout Standard

Vector Pascal currently runs under Windows98 , Windows2000 and Linux.
 Separate compilation using Turbo Pascal style units is supported.
 C calling conventions allow use of existing libraries.
 Work is underway to port the BLAS library to Vector Pascal, and to develop
 an IDE and literate programming system for it.
\layout Standard

Vector Pascal provides an effective approach to providing a programming
 environment for multi-media instruction sets.
 It borrows abstraction mechanisms that have a long history of sucessfull
 use in interpretive programming languages, combining these with modern
 compiler techniques to target SIMD instruction sets.
 It provides a uniform source language that can target multiple different
 processors without the programmer having to think about the target machine.
 Use of Java as the implementation language aids portability of the compiler
 accross operating systems.
\layout Bibliography

\bibitem {AMD}
Advanced Micro Devices, 3DNow! Technology Manual, 1999. 
\layout Bibliography

\bibitem {Aho}
Aho, A.V., Ganapathi, M, TJiang S.W.K., Code Generation Using Tree Matching
 and Dynamic Programming, ACM Trans, Programming Languages and Systems 11,
 no.4, 1989, pp.491-516. 
\layout Bibliography

\bibitem {blelloch}
 Blelloch, G.
 E., 
\shape smallcaps 
Nesl
\shape default 
: A Nested Data-Parallel Language, Carnegie Mellon University, CMU-CS-95-170,
 Sept 1995. 
\layout Bibliography

\bibitem {Burke}
Burke, Chris, J User Manual, ISI, 1995. 
\layout Bibliography

\bibitem {Cattel80}
Cattell R.
 G.
 G., Automatic derivation of code generators from machine descriptions,
 ACM Transactions on Programming Languages and Systems, 2(2), pp.
 173-190, April 1980. 
\layout Bibliography

\bibitem {Chaiten}
Chaitin.
 G., Elegant Lisp Programs, in The Limits of Mathematics, pp.
 29-56, Springer, 1997. 
\layout Bibliography

\bibitem {Cheong97}
Cheong, G., and Lam, M., An Optimizer for Multimedia Instruction Sets, 2nd
 SUIF Workshop, Stanford University, August 1997. 
\layout Bibliography

\bibitem {Cockshott00}
Cockshott, Paul, Direct Compilation of High Level Languages for Multi-media
 Instruction-sets, Department of Computer Science, University of Glasgow,
 Nov 2000. 
\layout Bibliography

\bibitem {Ewing}
 Ewing, A.
 K., Richardson, H., Simpson, A.
 D., Kulkarni, R., Writing Data Parallel Programs with High Performance
 Fortran, Edinburgh Parallel Computing Centre, Ver 1.3.1.
\layout Bibliography

\bibitem {sable}
 Gagnon, E., SABLECC, AN OBJECT-ORIENTED COMPILER FRAMEWORK, School of Computer
 Science McGill University, Montreal , March 1998.
\layout Bibliography

\bibitem {graham80}
Susan L.
 Graham, Table Driven Code Generation, IEEE Computer, Vol 13, No.
 8, August 1980, pp 25..37. 
\layout Bibliography

\bibitem {Hadjiyiannis97}
 Hadjiyiannis, G., Hanono, S.
 and Devadas, S., ISDL: an Instruction Set Description Language for Retargetabil
ity,
 DAC'97, ACM. 
\layout Bibliography

\bibitem {IA32 }
Intel, Intel Architecture Software Developers Manual Volumes 1 and 2, 1999.
 
\layout Bibliography

\bibitem {Intel00}
Intel, Willamette Processor Software Developer's Guide, February, 2000.
 
\layout Bibliography

\bibitem {ISO90}
ISO, Extended Pascal ISO 10206:1990, 1991. 
\layout Bibliography

\bibitem {Iverson62}
Iverson K.
 E., A Programming Language, John Wiley & Sons, Inc., New York (1962), p.
 16. 
\layout Bibliography

\bibitem {Iversion80}
Iverson, K.
 E.
 .
 Notation as a tool of thought.
 Communications of the ACM, 23(8), 444-465, 1980. 
\layout Bibliography

\bibitem {Jmanual}
Iverson K.
 E, A personal View of APL, IBM Systems Journal, Vol 30, No 4, 1991. 
\layout Bibliography

\bibitem {Jintro}
Iverson, Kenneth E., J Introduction and Dictionary, Iverson Software Inc.
 (ISI), Toronto, Ontario, 1995.
\protected_separator 

\layout Bibliography

\bibitem {Wirth}
Jensen K., and Wirth N., Pascal User Manual and Report, Springer, 1978.
 
\layout Bibliography

\bibitem {Krall00}
Krall, A., and Lelait, S., Compilation Techniques for Multimedia Processors,
 International Journal of Parallel Programming, Vol.
 28, No.
 4, pp 347-361, 2000. 
\layout Bibliography

\bibitem {Leupers94}
 Leupers, R., Niemmann, R.
 and Marwedel, P.
 Methods for Retargetable DSP Code Generation, VLSI Signal Processing 94,
 IEEE. 
\layout Bibliography

\bibitem {Leupers99}
Leupers, R., Compiler Optimization for Media Processors, EMMSEC 99/Sweden
 1999. 
\layout Bibliography

\bibitem {Metcalf96}
Metcalf, M., and Reid., J., The F Programming Language, OUP, 1996. 
\layout Bibliography

\bibitem {Peleg97}
Peleg, A., Wilke S., Weiser U., Intel MMX for Multimedia PCs, Comm.
 ACM, vol 40, no.
 1 1997.
\layout Bibliography

\bibitem {Ramsey97}
 Ramsey, N.
 and Fernandez, M., ACM Transactions on Programming Languages and Systems,
 Vol.
 19, No.
 3, 1997, pp492-524.
\layout Bibliography

\bibitem {setl}
 Schwartz, J.T., Dewar, R.B.K., Dubinsky, E., and Schonberg, E., Programming
 with Sets: An Introduction to SETL (1986), Springer-Verlag, New York 
\layout Bibliography

\bibitem {Sreraman00}
Srereman, N., and Govindarajan, G., A Vectorizing Compiler for Multimedia
 Extensions, International Journal of Parallel Programming, Vol.
 28, No.
 4, pp 363-400, 2000. 
\layout Bibliography

\bibitem {Tanenbaum}
 Tannenbaum, A.
 S., A Tutorial on 
\shape smallcaps 
Algol 68
\shape default 
, Computing Surveys, Vol.
 8, No.
 2, June 1976, p.155-190. 
\layout Bibliography

\bibitem {miranda}
 Turner, D., An overview of MIRANDA, SIGPLAN Notices, December 1986.
\layout Bibliography

\bibitem {vanderMeulen}
van der Meulen, S.
 G.,
\shape smallcaps 
Algol 68
\shape default 
 Might Have Beens, SIGPLAN notices Vol.
 12, No.
 6, 1977. 
\layout Bibliography

\bibitem {Watt}
 Watt, D.
 A., and Brown, D.
 F., Programming Language Processors in Java, Prentice Hall, 2000.
\the_end
