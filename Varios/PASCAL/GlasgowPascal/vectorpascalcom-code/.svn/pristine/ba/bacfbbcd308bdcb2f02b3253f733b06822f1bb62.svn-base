\chapter{Elements of the language}


\section{Alphabet}
The Vector Pascal compiler accepts files in the UTF-8 encoding of
 Unicode as source. Since ASCII is a subset of this, ASCII files are valid input.

Vector Pascal programs are made up of letter, digits and special 
symbols. The letters digits and special symbols are draw either from a base
 character set or from an extended character set. The base character set is drawn 
from ASCII and restricts the letters to be from the Latin alphabet. 
The extended character set allows letters from other alphabets. 
 



 The special symbols used in the base alphabet are shown in table\ref{specials} .
\begin{table}

\caption{Special symbols\label{specials}}
\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
+&
:&
(\\
\hline 
-&
'&
)\\
\hline 
{*}&
=&
{[}\\
\hline 
/&
<>&
{]}\\
\hline 
:=&
<&
\{\\
\hline 
.&
<=&
\}\\
\hline 
,&
>=&
\textasciicircum{}\\
\hline 
;&
>&
..\\
\hline 
+:&
@&
{*})\\
\hline 
-:&
\$&
({*}\\
\hline 
\_&
{*}{*}&
\\
\hline 
\end{tabular}\par}\vspace{0.3cm}
\end{table}
\subsection{Extended alphabet}
The extended alphabet is described in \href{VPUnicode.htm}{Using Unicode with Vector Pascal}.


\section{Reserved words}
\label{resw}
The reserved words are {%\small\bf

	\texttt{{ABS, ADDR, AND, ARRAY,}}

	\texttt{{BEGIN, BYTE2PIXEL,}}

	\texttt{{CASE, CAST, CDECL, CHR, CONST, COS,}}

	\texttt{{ DIV, DO, DOWNTO,}}

	\texttt{{END, ELSE, EXIT, EXTERNAL,}}

	\texttt{{FALSE, FILE, FOR, FUNCTION,}}

	\texttt{{GOTO,}}

	\texttt{{IF, IMPLEMENTATION, IN, INTERFACE, IOTA,}}

	\texttt{{LABEL, LIBRARY, LN,}}

	\texttt{{MAX, MIN, MOD,}}

	\texttt{{NAME, NDX,  NOT,}}

	\texttt{{OF, OR, ORD, OTHERWISE},}

	{\tt PACKED, PERM, PIXEL2BYTE,  POW,  PRED,} \\{\tt PROCEDURE,  PROGRAM,}
{\tt  PROTECTED ,}

	\texttt{{RDU,  RECORD, REPEAT, ROUND,}}

	\texttt{{SET, SHL, SHR, SIN, SIZEOF, STRING, SQRT, SUCC,}}

	\texttt{{TAN, THEN, TO, TRANS, TRUE, TYPE,}}

	\texttt{{VAR,}}

	\texttt{{WITH, WHILE, }}
	\texttt{{UNIT, UNTIL, USES }}
}

Reserved words may be written in either lower case or upper case letters, or
any combination of the two. 


\section{Comments}

The comment\index{comment} construct 

\texttt{\{\index{}} < any sequence of characters not containing {}``\}{}''
> \texttt{\}} 

may be inserted between any two identifiers, special symbols, numbers or reserved
words without altering the semantics or syntactic correctness of the program.
The bracketing pair \texttt{({*} {*})\index{*)}} may substitute for \texttt{\{
\}}. Where a comment starts with \texttt{\{} it continues until the next \texttt{\}}.
Where it starts with \texttt{({*}\index{(*}} it must be terminated by \texttt{{*})}\footnote{%
Note this differs from ISO Pascal which allows a comment starting with \{ to
terminate with {*}) and vice versa.
}.


\section{Identifiers}

Identifiers are used to name values, storage locations, programs, program modules,
types, procedures and functions. An identifier\index{identifier} starts with
a letter followed by zero or more letters, digits or the special symbol \texttt{\_}.
Case is not significant in identifiers.
ISO Pascal allows the Latin letters A-Z   to be used in identifiers. 
Vector Pascal extends this by allowing symbols from the Greek, 
Cyrillic, Katakana and Hiragana, or CJK character sets

 

\section{Literals}


\subsection{Integer numbers}

Integer numbers are formed of a sequence of decimal digits, thus \texttt{1},
\texttt{23}, \texttt{9976} etc, or as hexadecimal\index{hexadecimal} numbers,
or as numbers of any base between 2 and 36. A hexadecimal number takes the form
of a \texttt{\$} followed by a sequence of hexadecimal digits thus \texttt{\$01,
\$3ff, \$5A}. The letters in a hexadecimal number may be upper or lower case
and drawn from the range \texttt{a..f} or \texttt{A..F. }

A based integer\index{integer} is written with the base first followed by a
\# character and then a sequence of letters or digits. Thus \texttt{2\#1101}
is a binary number \texttt{8\#67} an octal\index{octal} number and \texttt{20\#7i}
a base 20 number.

The default precision for integers is 32 bits\footnote{%
The notation used for grammar definition is a tabularised BNF . Each boxed table
defines a production, with the production name in the left column. Each line
in the right column is an alternative for the production. The metasymbol + indicates
one or more repetitions of what immediately preceeds it. The Kleene star {*}
is used for zero or more repetitions. Terminal symbols are in single quotes.
Sequences in brackets {[} {]} are optional.
}.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<digit sequence>&
<digit> +\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<decimal integer>&
<digit sequence>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<hex integer>&
`\$'<hexdigit>+\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<based integer> &
<digit sequence>'\#'<alphanumeric>+\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unsigned integer>&
<decimal integer>\\
&
<hex integer>\\
&
<based integer>\\
\hline 
\end{tabular}
\begin{table}

\caption{The hexadecimal digits of Vector Pascal.}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline 
Value&
0&
1&
2&
3&
4&
5&
6&
7&
8&
9&
10&
11&
12&
13&
14&
15\\
\hline 
Notation 1&
0&
1&
2&
3&
4&
5&
6&
7&
8&
9&
A&
B&
C&
D&
E&
F\\
\hline 
Notation 2&
&
&
&
&
&
&
&
&
&
&
a&
b&
c&
d&
e&
f\\
\hline 
\end{tabular}\par}
.
\end{table}
 \par}
\vspace{0.3cm}


\subsection{Real numbers}

Real numbers are supported in floating point notation, thus \texttt{14.7}, 
 {\tt \ 9.99e5}, 
{\tt
38E3,} \  {\tt 3.6e-4} are all valid denotations for real\index{real} numbers. The default
precision for real numbers is also 32 bit, though intermediate calculations
may use higher precision. The choice of 32 bits as the default precision is
influenced by the fact that 32 bit floating point vector operations are well
supported in multi-media\index{media} instructions.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<exp>&
`e'\\
&
`E'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<scale factor>&
{[}<sign>{]} <unsigned integer>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<sign>&
`-'\\
&
`+'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unsigned real>&
<decimal integer> `.' <digit sequence>\\
&
<decimal integer>` .' <digit sequence> <exp><scale factor> \\
&
<decimal integer><exp> <scale factor>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Fixed point numbers}

In Vector Pascal pixels\index{pixels} are represented as signed fixed point
fractions in the range -1.0 to 1.0. Within this range, fixed point literals
have the same syntactic form as real numbers.


\subsection{Character strings}

Sequences of characters enclosed by quotes are called literal\index{literal}
strings. Literal strings\index{strings} consisting of a single character are
constants of the standard type char. If the string is to contain a quote character
this quote character must be written twice.

\texttt{\small 'A' 'x' 'hello' 'John''s house'}{\small \par}

are all valid literal strings. The allowable characters in literal strings are
any of the Unicode characters above u0020. The character strings must be input
to the compiler in UTF-8 format.




\chapter{Declarations}

Vector Pascal is a language supporting nested declaration\index{declaration}
contexts. A declaration context is either a program context, and unit interface
or implementation context, or a procedure or function context. A resolution
context determines the meaning of an identifier. Within a resolution context,
identifiers can be declared to stand for constants, types, variables, procedures
or functions. When an identifier is used, the meaning taken on by the identifier
is that given in the closest containing resolution context. Resolution contexts
are any declaration context or a \texttt{with} statement context. The ordering
of these contexts when resolving an identifier is:

\begin{enumerate}
\item The declaration context identified by any \texttt{with} statements which nest
the current occurrence of the identifier. These \texttt{with} statement contexts
are searched from the innermost to the outermost.
\item The declaration context of the currently nested procedure\index{procedure}
declarations. These procedure contexts are searched from the innermost to the
outermost.
\item The declaration context of the current unit\index{unit} or program\index{program}.
\item The interface declaration contexts of the units mentioned in the use list of
the current unit or program. These contexts are searched from the rightmost
unit mentioned in the use list to the leftmost identifier in the use list.
\item The interface declaration context of the System\index{System} unit.
\item The pre-declared identifiers of the language.
\end{enumerate}



\section{Constants}

A constant definition introduces an identifier as a synonym for a constant. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<constant declaration>&
<identifier>=<expression>\\
&
<identifier>':'<type>'='<typed constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Constants can be simple constants or typed constants. A simple constant must
be a constant expression whose value is known at compile time. This restricts
it to expressions for which all component identifiers are other constants, and
for which the permitted operators\index{operators} are given in table\ref{MMConst}
. This restricts simple constants to be of scalar or string types.


\begin{table}

\caption{The operators permitted in Vector Pascal constant expressions.\label{MMConst}}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline 
+&
-&
{*}&
/&
div&
mod&
shr&
shl&
and&
or\\
\hline 
\end{tabular}\par}\end{table}
Typed constants provide the program with initialised variables which may hold
array types.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<typed constant>&
<expression>\\
&
<array constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Array constants}

Array constants are comma separated lists of constant expressions enclosed by
brackets. Thus 

\texttt{tr:array{[}1..3{]} of real =(1.0,1.0,2.0);}

is a valid array constant declaration, as is:

{\small
\texttt{t2:array{[}1..2,1..3{]} of real=((1.0,2.0,4.0),(1.0,3.0,9.0));}}

The array constant\index{constant}\index{array constant} must structurally
match the type\index{type} given to the identifier. That is to say it must
match with respect to number of dimensions, length of each dimension, and type
of the array elements.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<array constant>&
'(' <typed constant> {[},<typed constant>{]}{*} ')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Pre-declared constants\index{constants}}

\begin{lyxlist}{00.00.0000}
\item [\texttt{maxint\index{maxint}}]The largest supported integer value.
\item [\texttt{pi\index{pi}}] A real numbered approximation to $ \pi  $
\item [\texttt{maxchar\index{maxchar}}] The highest character in the character set.
\item [\texttt{maxstring\index{maxstring}}]The maximum number of characters allowed
in a string.
\item [\texttt{maxreal\index{maxreal}}]The highest representable real. 
\item [\texttt{minreal\index{minreal}}]The smallest representable positive real number. 
\item [\texttt{epsreal\index{epsreal}}]The smallest real number which when added
to 1.0 yields a value distinguishable from 1.0. 
\item [\texttt{maxdouble\index{maxdouble}}]The highest representable double precision
real number.
\item [\texttt{mindouble\index{mindouble}}]The smallest representable positive double
precision real number.
\item [\texttt{complexzero\index{complexzero}}]A complex number with zero real and
imaginary parts.
\item [\texttt{complexone}\index{complexone}]A complex number with real part 1 and
imaginary part 0.
\end{lyxlist}

\section{Labels}

Labels are written as digit sequences. Labels must be declared before they are
used. They can be used to label the start of a statement and can be the destination
of a \texttt{goto\index{goto}} statement. A \texttt{goto} statement must have
as its destination a label\index{label} declared within the current innermost
declaration context. A statement can be prefixed by a label followed by a colon.

Example

\texttt{label 99;}

\texttt{begin read(x); if x>9 goto 99; write(x{*}2);99: end;}


\section{Types}

A type declaration determines the set of values that expressions of this type
may assume and associates with this set an identifier.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<type>&
<simple type>\\
&
<structured type>\\
&
<pointer type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<type definition>&
<identifier>'='<type> \\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Simple types}

Simple types are either scalar, standard, subrange or dimensioned types.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<simple type>&
<scalar type>\\
&
<integral type>\\
&
<subrange type>\\
&
<dimensioned type>\\
&
<floating point type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Scalar types}

A scalar\index{scalar} type\index{type} defines an ordered set of identifier
by listing these identifiers. The declaration takes the form of a comma separated
list of identifiers enclosed by brackets. The identifiers in the list are declared
simultaneously with the declared scalar type to be constants of this declared
scalar type. Thus 
\begin{verbatim}
colour = (red,green,blue);
day=(monday,tuesday,wednesday,thursday,
     friday,saturday,sunday);
\end{verbatim}
are valid scalar type declarations.


\subsubsection{Standard types}\label{auxtypes}

The following types are provided as standard in Vector Pascal:
\begin{table}

\caption{Categorisation of the standard types.}
{\centering \begin{tabular}{|c|c|}
\hline 
type&
category\\
\hline 
\hline 
real&
floating point\\
\hline 
double&
floating point\\
\hline 
byte&
integral\\
\hline 
pixel&
fixed point\\
\hline 
shortint&
integral\\
\hline 
word&
integral\\
\hline 
integer&
integral\\
\hline 
cardinal&
integral\\
\hline 
boolean&
scalar\\
\hline 
char&
scalar\\
\hline 
\end{tabular}\par}\end{table}


\begin{lyxlist}{00.00.0000}
\item [\texttt{integer\index{integer}}]The numbers are in the range -maxint to +maxint.
\item [\texttt{real\index{real}}]These are a subset of the reals constrained by the
IEEE 32 bit floating point format.
\item [\texttt{double\index{double}}]These are a subset of the real numbers constrained
by the IEEE\index{IEEE} 64 bit floating point format.
\item [\texttt{pixel\index{pixel}}]These are represented as fixed\index{fixed} point\index{point}
binary\index{binary} fractions\index{fractions} in the range -1.0 to 1.0.
\item [\texttt{boolean\index{boolean}}]These take on the values \texttt{(false\index{false},true\index{true})}
which are ordered such that \texttt{true<false}. 
\item [\texttt{char\index{char}}]These include the characters from \texttt{chr(0)}
to \texttt{charmax}\index{charmax}. All the allowed characters for string literals
are in the type char, but the character-set may include other characters whose
printable form is country specific. 
\item [\texttt{pchar}\index{pchar}]Defined as \texttt{\textasciicircum{}char}.
\item [\texttt{byte\index{byte}}]These take on the positive integers between 0 and
255.
\item [\texttt{shortint\index{shortint}}]These take on the signed values between
-128 and 127.
\item [\texttt{word\index{word}}]These take on the positive integers from 0 to 65535.
\item [\texttt{cardinal\index{cardinal}}]These take on the positive integers form
0 to 4292967295, i.e., the most that can be represented in a 32 bit unsigned
number.
\item [\texttt{longint\index{longint}}]A 32 bit integer, retained for compatibility
with Turbo Pascal.
\item [\texttt{int\index{int64}64}]A 64 bit integer.
\item [\texttt{complex\index{complex}}]A complex number with the real and imaginary
parts held to 32 bit precision.
\end{lyxlist}

\subsubsection{Subrange types}

A type may be declared as a subrange\index{subrange} of another scalar\index{scalar}
or integer\index{integer} type by indicating the largest and smallest value
in the subrange. These values must be constants known at compile time.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<subrange type>&
<constant> '..' <constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Examples: 1..10, 'a'..'f', monday..thursday.


\subsubsection{Pixels}

The \emph{conceptual model} of pixels in Vector Pascal is that they are real
numbers in the range $ -1.0..1.0 $. As a signed representation it lends itself
to subtraction. As an unbiased representation, it makes the adjustment of contrast
easier. For example, one can reduce contrast 50\% simply by multiplying an image
by 0.5 \footnote{%
When pixels are represented as integers in the range 0..255, a 50\% contrast
reduction has to be expressed as $ ((p-128)\div 2)+128 $.
}. Assignment to pixel variables in Vector Pascal is defined to be saturating
- real numbers outside the range $ -1..1 $ are clipped to it. The multiplications
involved in convolution operations fall naturally into place. 

The \emph{implementation model} of pixels used in Vector Pascal is of 8 bit
signed integers treated as fixed point binary fractions. All the conversions
necessary to preserve the monotonicity of addition, the range of multiplication
etc, are delegated to the code generator which, where possible, will implement
the semantics using efficient, saturated multi-media arithmetic instructions. 


\subsubsection{Dimensioned types}

These provide a means by which floating point types can be specialised to represent
dimensioned numbers as is required in physics calculations. For example:

\texttt{kms =(mass,distance,time);}

\texttt{meter=real of distance;}

\texttt{kilo=real of mass;}

\texttt{second=real of time;}

\texttt{newton=real of mass {*} distance {*} time POW -2;}

\texttt{meterpersecond = real of distance {*}time POW -1;}

The grammar is given by:

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<dimensioned type>&
<real type> <dimension >{[}'{*}' <dimension>{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<real type>&
'real'\\
&
'double'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<dimension>&
<identifier> {[}'POW' {[}<sign>{]} <unsigned integer>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The identifier\index{identifier} must be a member of a scalar type, and that
scalar type is then referred to as the basis space of the dimensioned type.
The identifiers of the basis\index{basis} space are referred to as the dimensions
of the dimensioned type\index{type}. Associated with each dimension of a dimensioned
type there is an integer number referred to as the power of that dimension.
This is either introduced explicitly at type declaration time, or determined
implicitly for the dimensional type of expressions. 

A value of a dimensioned type is a dimensioned value. Let $ \log _{d}t $
of a dimensioned type $ t $ be the power to which the dimension $ d $
of type $ t $ is raised. Thus for $ t= $newton in the example above, and
$ d= $time, $ \log _{d}t=-2 $

If $ x $ and $ y $ are values of dimensioned\index{dimensioned} types
$ t_{x} $and $ t_{y} $respectively, then the following operators are only
permissible if $ t_{x}=t_{y} $

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
+&
-&
<&
>&
<>&
=&
<=&
>=\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

For + and -, the dimensional\index{dimensional} type of the result is the same
as that of the arguments. The operations 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
{*}&
/\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

are permitted if the types $ t_{x} $and $ t_{y} $ share the same basis
space, or if the basis space of one of the types is a subrange of the basis
space of the other.  

The operation \texttt{POW} is permitted between dimensioned types and integers.


\paragraph*{Dimension deduction rules}

\begin{enumerate}
\item If $ x=y*z $ for $ x:t_{1},y:t_{2},z:t_{3} $ with basis space $ B $
then 

 
 $$ \forall _{ d \in B } \log_dt_1= \log_dt_2+\log_dt_3 $$
 
\item If $ x=y/z $ for $ x:t_{1},y:t_{2},z:t_{3} $ with basis space $ B $
then 

 
$$ \forall_{d \in B}\log _{d}t_{1}=\log _{d}t_{2}-\log _{d}t_{3} $$
 
\item If $ x=y $ \texttt{POW} $ z $ for $ x:t_{1},y:t_{2},z:integer $ with
basis space for $ t_{2} $, $ B $ then 

 
$$ \forall_{d\in B}\log _{d}t_{1}=\log _{d}t_{2}\times z $$.
 
\end{enumerate}

\subsection{Structured types}


\subsubsection{Static Array\index{array}\index{array, static} types}

An array type is a structure consisting of a fixed number of elements all of
which are the same type. The type of the elements is referred to as the element
type. The elements of an array value are indicated by bracketed indexing expressions.
The definition of an array\index{array} type\index{type} simultaneously defines
the permitted type of indexing expression and the element type. 

The index\index{index} type\index{type} of a static\index{static} array\index{array, static}
must be a scalar\index{scalar} or subrange\index{subrange} type. This implies
that the bounds of a static array are known at compile time.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<array type>&
'array' '{[}' <index type>{[},<index type>{]}{*} '{]}' 'of' <type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<index type>&
<subrange type>\\
&
<scalar type>\\
&
<integral type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Examples

\texttt{array{[}colour{]} of boolean;}

\texttt{array{[}1..100{]} of integer;}

\texttt{array{[}1..2,4..6{]} of byte;}

\texttt{array{[}1..2{]} of array{[}4..6{]} of byte;}

The notation {[}\emph{b,c}{]} in an array declaration is shorthand for the notation
{[}\emph{b}{]} \texttt{of array} {[} \emph{c} {]}. The number of dimensions of an
array type is referred to as its rank. Scalar types have rank 0.


\subsubsection{String types}

A string\index{string} type denotes the set of all sequences of characters
up to some finite length and must have the syntactic form:

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<string-type>&
'string{[}' <integer constant>'{]}'\\
&
'string'\\
&'string{(}' <ingeger constant>'{)}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

the integer constant indicates the maximum number of characters that may be
held in the string type. The maximum number of characters that can be held in
any string is indicated by the pre-declared constant \texttt{maxstring}. The
type \texttt{string} is shorthand for \texttt{string{[}maxstring{]}}.


\subsubsection{Record types}

A record type defines a set of similar data structures. Each member of this
set, a record instance, is a Cartesian product of number of components or \emph{fields}
specified in the record\index{record} type definition. Each field has an identifier
and a type. The scope of these identifiers is the record itself.

A record type may have as a final component a \emph{variant\index{variant}
part}. The variant part, if a variant part exists, is a union of several variants,
each of which may itself be a Cartesian product of a set of fields. If a variant
part exists there may be a tag field whose value indicates which variant is
assumed by the record instance.

All field identifiers even if they occur within different variant parts, must
be unique within the record type.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<record type>&
'record' <field list> 'end'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<field list>&
<fixed part>\\
&
<fixed part>';' <variant part>\\
&
<variant part>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<fixed part>&
<record section> {[} ';' <record section.{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<record section>&
<identifier>{[}',' <identifier>{]}{*} ':' <type>\\
&
<empty>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variant part>&
'case' {[}<tag field> ':'{]} <type identifier> 'of'<variant>{[}';' <variant>{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variant>&
<constant> {[}',' <constant>{]}{*}':' '(' <field list> ')'\\
&
<empty>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{Set types}

A set\index{set} type defines the range of values which is the power-set of
its base type. The base type must be an ordered type, that is a type on which the
operations $<$, $=$ and $>$ are defined\footnote{ ISO Pascal requires
the base type to be a scalar type, a character type, integer
type or a subrange thereof. When the base type is one of these, Vector Pascal implements
the set using bitmaps. When the type is other than these, balanced binary trees are used.
It is strongly recomended that use be made of Boehm garbage collector (see section \ref{garbage}) if non-bitmapped
sets are used in a program.}.
Thus sets may be declared whose base types are characters, numbers, ordinals, or strings. Any user
defined type on which the comparison operators have been defined can also be the base type
of a set.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<set type>&
'set' 'of' <base type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Dynamic\index{Dynamic} types}

Variables declared within the program are accessed by their identifier. These
variables exist throughout the existence of the scope within which they are
declared, be this unit, program or procedure. These variables are assigned storage
locations whose addresses, either absolute or relative to some register, can
be determined at compile time. Such locations a referred to as static\index{static}\footnote{%
The Pascal concept of static variables should not be equated with the notion
of static variables in some other languages such as C or Java. In Pascal a variable
is considered static if its offset either relative to the stack base or relative
to the start of the global segment can be determined at compile/link time. In
C a variable is static only if its location relative to the start of the global
segment is known at compile time.
}. Storage locations may also be allocated dynamically. Given a type \texttt{t},
the type of a pointer\index{pointer} to an instance of type \texttt{t} is \texttt{\textasciicircum{}t}. 

A pointer of type \texttt{\textasciicircum{}t} can be initialised to point to
a new store location of type t by use of the built in procedure \texttt{new}.
Thus if \texttt{p:\textasciicircum{}t},

\texttt{new(p);}

causes \texttt{p} to point at a store location of type \texttt{t}.


\subsubsection{Pointers to dynamic\index{dynamic}\index{dynamic array} arrays\index{array, dynamic}\index{array}}

The types pointed to by pointer types can be any of the types mentioned so far,
that is to say, any of the types allowed for static\index{static} variables.
In addition however, pointer types can be declared to point at dynamic arrays.
A dynamic array is an array whose bounds are determined at run time.

Pascal\index{Pascal90} 90\cite{ISO90} introduced the notion of schematic or
parameterised types as a means of creating dynamic arrays. Thus where \texttt{r}
is some integral or ordinal type one can write 

\texttt{type z(a,b:r)=array{[}a..b{]} of t;}

If \texttt{p:\textasciicircum{}z}, then 

\texttt{new(p,n,m)}

where \texttt{n,m:r} initialises \texttt{p} to point to an array of bounds \texttt{n..m}.
The bounds of the array can then be accessed as \texttt{p\textasciicircum{}.a,
p\textasciicircum{}.b}. In this case {\tt a, b} are the formal parameters of
the array type. Vector Pascal currently only allows  
parameterised types to be allocated on the heap via {\tt new}. The extended form of the procedure {\tt new } must be passed an actual
parameter for each formal parameter in the array type.

\subsubsection{Dynamic arrays\index{dynamic array}}
Vector Pascal also allows the use of Delphi style declarations for dynamic arrays. Thus one
can declare:
\begin{verbatim}
type vector = array of real;
     matrix = array of array of real;
\end{verbatim}
The size of such arrays has to be explicitly initialised at runtime by a call to the
library procedure {\tt setlength}.
Thus one might have:
\begin{verbatim}
function readtotal:real;
var len:integer;
    v:vector;
begin
 readln(len);
 setlength(v,len);
 readln(v);
 readtotal := \+ v;
end;
\end{verbatim}
The function {\tt readtotal} reads the number of elements in a vector from
the standard input. It then calls {\tt setlength} to initialise the vector length.
Next it reads in the vector and computes its total using the reduction operator \verb{ \+{.

In the example, the variable {\tt v} denotes an array of reals not a pointer
to an array of reals. However, since the array size is not known at compile time
{\tt setlength} will allocate space for the array  on the heap not in the local stack
frame. The use of {\tt setlength} is thus restricted to programs which have been
compiled with the garbage collection flag enabled (see section \ref{BOEHM}).
The procedure {\tt setlength } must be passed a parameter for each dimension of
the dynamic array. The bounds of the array {\tt a} formed by {\tt \\ setlength(a,i,j,k)\\}
would then be {\tt 0..i-1, 0..j-1, 0..k-1}. 

\subsubsection{Low \index{low} and High \index{high}}
The build in functions {\tt low } and {\tt high} return the lower and upper bounds
of an array respectively. They work with both static and dynamic arrays.
Consider the following examples.
\begin{verbatim}
program arrays;
type  z(a,b:integer)=array[a..b] of real;
      vec = array of real;
      line= array [1..80] of char;
      matrix = array of array of real;
var i:^z; v:vec; l:line; m:matrix;
begin
 setlength(v,10);setlength(m,5,4);
 new(i,11,13);
 writeln(low(v), high(v));
 writeln(low(m), high(m));
 writeln(low(m[0]),high(m[0]));
 writeln(low(line),high(line));
 writeln(low(i^),high(i^));
end.
\end{verbatim}
would print
\begin{verbatim}
           0           9
           0           4
           0           3
           1          80
          11          13
\end{verbatim}
\section{File types}

A type may be declared to be a file of a type. This form of definition is kept
only for backward compatibility. All file types are treated as being equivalent.
A file type corresponds to a handle to an operating system file. A file variable
must be associated with the operating system file by using the procedures \texttt{assign,
rewrite, append}, and \texttt{reset} provided by the system unit. A pre-declared
file type \texttt{text} exists.

Text files are assumed to be in Unicode UTF-8 format. Conversions are performed between
the internal representation of characters and UTF-8 on input/output from/to a text file.

\section{Variables\index{Variables}}

Variable declarations consist of a list of identifiers denoting the new variables,
followed by their types.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variable declaration>&
<identifier> {[}',' <identifier>{]}{*} ':' <type><extmod>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Variables are abstractions over values. They can be either simple identifiers,
components or ranges of components of arrays, fields of records or referenced
dynamic variables.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<variable>&
<identifier>\\
&
<indexed variable>\\
&
<indexed range>\\
&
<field designator>\\
&
<referenced variable>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Examples

\texttt{x,y:real;}

\texttt{i:integer;}

\texttt{point:\textasciicircum{}real;}

\texttt{dataset:array{[}1..n{]}of integer;}

\texttt{twoDdata:array{[}1..n,4..7{]} of real;}


\subsection{External Variables}

A variable may be declared to be external by appending the external modifier.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<extmod>&
';' 'external' 'name' <stringlit>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

This indicates that the variable is declared in a non Vector Pascal external
library. The name by which the variable is known in the external library is
specified in a string literal. 

Example

\texttt{count:integer; external name '\_count';}


\subsection{Entire Variables}\label{entire}

An entire variable is denoted by its identifier. Examples \texttt{x,y,point}, 


\subsection{Indexed Variables}

A component of an \emph{n} dimensional array variable is denoted by the variable
followed by \emph{n} index expressions in brackets.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<indexed variable>&
<variable>'{[}' <expression>{[}','<expression>{]}{*} '{]}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The type of the indexing expression must conform to the index type of the array
variable. The type of the indexed variable is the component type of the array.

Examples

\texttt{twoDdata{[}2,6{]}}

\texttt{dataset{[}i{]}}

Given the declaration 

\texttt{a=array{[}p{]} of q}

then the elements of arrays of type \texttt{a}, will have type \texttt{q} and
will be identified by indices\index{indices} of type \texttt{p} thus:

\texttt{b{[}i{]}}

where \texttt{i:p}, \texttt{b:a}.

Given the declaration

\texttt{z = string{[}x{]}}

for some integer x \texttt{$ \leq  $maxstring}, then the characters within
strings\index{strings} of type \texttt{z} will be identified by indices in
the range \texttt{1..x,} thus:

\texttt{y{[}j{]}}

where \texttt{y:z}, \texttt{j:1..x}.


\subsubsection{Indexed Ranges}

A range of components of an array variable are denoted by the variable followed
by a range expression in brackets.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<indexed range>&
<variable> '{[}' <range expression>{[}',' <range expression>{]}{*} '{]}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<range expression>&
<expression> '..' <expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The expressions within the range\index{range} expression must conform to the
index type of the array variable. The type of a range expression \texttt{a{[}i..j{]}}
where \texttt{a: array{[}p..q{]} of t} is \texttt{array{[}0..j-i{]} of t.}

Examples:

\texttt{dataset{[}i..i+2{]}:=blank;}

\texttt{twoDdata{[}2..3,5..6{]}:=twoDdata{[}4..5,11..12{]}{*}0.5;}

Subranges\index{Subranges} may be passed in as actual parameters to procedures
whose corresponding formal parameters\index{parameters} are declared as variables
of a schematic\index{schematic} type. Hence given the following declarations:

\texttt{type image(miny,maxy,minx,maxx:integer)=array{[}miny..maxy,minx..maxx{]}
of byte;}

\texttt{procedure invert(var im:image);begin im:=255-im; end;}

\texttt{var screen:array{[}0..319,0..199{]} of byte;}

then the following statement would be valid:

\texttt{invert(screen{[}40..60,20..30{]});}


\subsubsection{Indexing arrays with arrays}

If an array\index{array} variable occurs on the right hand side of an assignment
statement, there is a further form of indexing possible. An array may be indexed
by another array. If \texttt{x:array{[}t0{]} of t1} and \texttt{y:array{[}t1{]}
of t2}, then \texttt{y{[}x{]}} denotes the virtual array of type \texttt{array{[}t0{]}
of t2} such that \texttt{y{[}x{]}{[}i{]}=y{[}x{[}i{]}{]}}. This construct is
useful for performing permutations. To fully understand the following example
refer to sections \ref{iota},\ref{manimplicitindices}.


\paragraph{Example}

Given the declarations

\texttt{const perm:array{[}0..3{]} of integer=(3,1,2,0);}

\texttt{var ma,m0:array{[}0..3{]} of integer; }

then the statements

\texttt{m0:= (iota 0)+1;}

\texttt{write('m0=');for j:=0 to 3 do write(m0{[}j{]});writeln;}

\texttt{ma:=m0{[}perm{]}; }

\texttt{write('perm=');for j:=0 to 3 do write(perm{[}j{]});writeln; }

\texttt{writeln('ma:=m0{[}perm{]}');for j:=0 to 3 do write(ma{[}j{]});writeln;}

would produce the output 

\begin{lyxcode}
m0=~1~2~3~4

perm=~~3~1~2~0~

ma:=m0{[}perm{]}~

4~2~3~1
\end{lyxcode}

This basic method can also be applied to multi-dimensional array. Consider the
following example of an image warp:
\begin{verbatim}
type pos 	= 0..255;
     image      = array[pos,pos] of pixel;
     warper     = array[pos,pos,0..1] of pos;
var  im1 ,im2 :image;
     warp     :warper;
begin
    ....
    getbackwardswarp(warp);
    im2 := im1 [ warp ];
    ....
\end{verbatim}
The procedure {\tt getbackwardswarp } determines for each pixel position {\tt x, y} in an
image the position in the source image from which it is to be obtained.
After the assignment we have the postcondition $${\tt im2[x,y]}=
{\tt im1[warp[x,y,0],warp[x,y,1]]} \forall { \tt x,y} \in {\tt pos}$$
\subsection{Field\index{Field} Designators}

A component of an instance of a record type, or the parameters of an instance
of a schematic type are denoted by the record or schematic type instance followed
by the field or parameter name.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<field designator>&
<variable>'.'<identifier>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Referenced Variables\index{Variables}}

If \texttt{p:\textasciicircum{}t}, then \texttt{p\textasciicircum{}} denotes
the dynamic variable of type \texttt{t} referenced by \texttt{p}.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<referenced variable>&
<variable> '\textasciicircum{}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\section{Procedures and Functions}

Procedure and function declarations allow algorithms to be identified by name
and have arguments associated with them so that they may be invoked by procedure
statements or function calls. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<procedure declaration>&
<procedure heading>';'{[}<proc tail>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
<proc tail>&
'forward'&
must be followed by definition of procedure body\\
\hline 
\hline 
&
'external'&
imports a non Pascal procedure\\
\hline 
&
<block>&
procedure implemented here\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<paramlist>&
'('<formal parameter section>{[}';'<formal parameter section>{]}{*}')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

%\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<procedure heading> &
'procedure' <identifier> {[}<paramlist>{]}\\
&
'function'<identifier> {[}<paramlist>{]}':'<type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

%\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<formal parameter section>&
{[}'var'{]}<identifier>{[}','<identifier>{]}':'<type>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The parameters declared in the procedure heading are local to the scope of the
procedure. The parameters in the procedure heading are termed formal\index{formal parameter}
parameters. If the identifiers in a formal parameter section are preceded by
the word \texttt{var}, then the formal parameters are termed variable parameters.
The block\footnote{%
see section \ref{block}.
} of a procedure or function constitutes a scope local to its executable compound
statement. Within a function declaration there must be at least one statement
assigning a value to the function identifier. This assignment determines the
result of a function, but assignment to this identifier does not cause an immediate
return from the function. 

Function return values can be scalars, pointers, records, strings or sets. Arrays
may not be returned from a function.


\paragraph{Examples}

The function sba is the mirror image of the abs function.

\texttt{function sba(i:integer):integer; }

\texttt{begin if i>o then sba:=-i else sba:=i end;}

\texttt{type stack:array{[}0..100{]} of integer;}

\texttt{procedure push(var s:stack;i:integer);}

\texttt{begin s{[}s{[}0{]}{]}:=i;s{[}0{]}:=s{[}0{]}+1; end;}


\chapter{Algorithms}


\section{Expressions\index{Expressions}}

An expression is a rule for computing a value by the application of operators
and functions to other values. These operators can be \emph{monadic} - taking
a single argument, or \emph{dyadic} - taking two arguments. 


\subsection{Mixed type expressions}

The arithmetic operators are defined over the base types integer and real. If
a dyadic operator that can take either real\index{real} or integer\index{integer}
arguments is applied to arguments one of which is an integer and the other a
real, the integer argument is first implicitly converted to a real before the
operator is applied. Similarly, if a dyadic operator is applied to two integral
numbers of different precision, the number of lower precision is initially converted
to the higher precisions, and the result is of the higher precision. Higher
precision of types \emph{t,u} is defined such that the type with the greater
precision is the one which can represent the largest range of numbers. Hence
reals\index{reals} are taken to be higher precision than longints even though
the number of significant bits in a real may be less than in a longint.

When performing mixed type arithmetic between pixels and another numeric data
type, the values of both types are converted to reals before the arithmetic
is performed. If the result of such a mixed type expression is subsequently
assigned to a pixel\index{pixel} variable, all values greater than 1.0 are
mapped to 1.0 and all values below -1.0 are mapped to -1.0. 


\subsection{Primary expressions}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<primary expression> &
'(' <expression> ')'\\
&
<literal string>\\
&
'true'\\
&
'false'\\
&
<unsigned integer>\\
&
<unsigned real>\\
&
<variable>\\
&
<constant id>\\
&
<function call>\\
&
<set construction>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The most primitive expressions are instances of the literals defined in the
language: literal strings, boolean literals, literal reals and literal integers.
'Salerno', \texttt{true}, 12, \$ea8f, 1.2e9 are all primary expressions. The
next level of abstraction is provided by symbolic identifiers for values. \texttt{X},
\texttt{left}, \texttt{a.max}, \texttt{p\textasciicircum{}.next}, \texttt{z{[}1{]}},
\texttt{image{[}4..200,100..150{]}} are all primary expressions provided that
the identifiers have been declared as variables or constants.

An expression surrounded by brackets \texttt{( )} is also a primary expression.
Thus if \emph{e} is an expression so is \texttt{(} \emph{e} \texttt{)}. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<function call>&
<function id> {[} '(' <expression> {[},<expression>{]}{*} ')' {]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<element>&
<expression>\\
&
<range expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Let \emph{e} be an expression of type $ t_{1} $ and if \texttt{f} is an identifier
of type \texttt{function\index{function}($ t_{1} $ ):$ t_{2} $}, then
\texttt{f(} \emph{e} \texttt{)} is a primary expression of type $ t_{2} $.
A function which takes no parameters is invoked without following its identifier
by brackets. It will be an error if any of the actual parameters supplied to
a function are incompatible with the formal parameters declared for the function.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<set construction>&
'{[}' {[}<element>{[},<element>{]}{*}{]} '{]}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Finally a primary expression may be a set construction. A set construction is
written as a sequence of zero or more elements enclosed in brackets \texttt{{[}
{]}} and separated by commas. The elements themselves are either expressions
evaluating to single values or range expressions denoting a sequence of consecutive
values. The type of a set construction is deduced by the compiler from the context
in which it occurs. A set construction occurring on the right hand side of an
assignment inherits the type of the variable to which it is being assigned.
The following are all valid set constructions:

\texttt{{[}{]}, {[}1..9{]}, {[}z..j,9{]}, {[}a,b,c,{]}}

\texttt{{[}{]}} denotes the empty set.


\subsection{Unary expressions}

A unary expression is formed by applying a unary operator to another unary or
primary expression. The unary operators supported are \texttt{+, -, {*}, /,
div\index{div}, mod\index{mod}, and\index{and}, or\index{or}, not\index{not},
round\index{round}, sqrt\index{sqrt}, sin\index{sin}, cos\index{cos}, tan\index{tan},
abs\index{abs}, ln\index{ln}, ord\index{ord}, chr\index{chr}, byte2pixel\index{pixel},
pixel2byte\index{byte}, succ\index{succ}, pred\index{pred}, iota\index{iota},
trans\index{trans}, addr\index{addr}} and \texttt{@}\index{@}.

Thus the following are valid unary expressions\texttt{: -1}, {\tt +b, not true}, {\tt sqrt
abs x}, {\tt sin theta.}\label{primfns} In standard Pascal some of these operators are treated as
functions,. Syntactically this means that their arguments must be enclosed in
brackets, as in \texttt{sin(theta)}. This usage remains syntactically correct
in Vector Pascal. 

The dyadic operators \texttt{+, -, {*}, /, div, mod , and or} are all extended
to unary context by the insertion of an implicit value under the operation.
Thus just as \texttt{-a = 0-a} so too \texttt{/2 = 1/2}. For sets the notation
\texttt{-s} means the complement of the set \texttt{s}. The implicit value inserted
are given below.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
type&
operator\texttt{s}&
\texttt{implicit value}\\
\hline 
\hline 
\texttt{number}&
\texttt{+,-}&
0\\
\hline 
string&
\texttt{+}&
''\\
\hline 
set\index{set}&
\texttt{+}&
empty set\\
\hline 
%set&
%\texttt{-,{*}}&
%full-set\\
%\hline 
number&
\texttt{{*},/ ,div,mod}&
1\\
\hline 
number&
\texttt{max}&
lowest representable number of the type\\
\hline 
number&
\texttt{min}&
highest representable number of the type\\
\hline 
boolean\index{boolean}&
\texttt{and}&
true\\
\hline 
boolean&
\texttt{or} &
false\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

A unary operator can be applied to an array\index{array} argument and returns
an array result. Similarly any user declared function over a scalar\index{scalar}
type can be applied to an array type and return an array. If \texttt{f} is a
function or unary operator mapping from type \texttt{r} to type \texttt{t} then
if \texttt{x} is an array of \texttt{r,} and \texttt{a} an array of \texttt{t},
then \texttt{a:=f(x)} assigns an array of \texttt{t} such that \texttt{a{[}i{]}=f(x{[}i{]})}

\begin{table}
\caption{Unary operators}\label{tab:unops}
{\centering \begin{tabular}{|c|c||l|}
\hline 
{\small lhs }&
{\small rhs}&
{\small meaning}\\
\hline 
{\small <unaryop>}&
{\small '+'}&
{\small +x = 0+x identity operator}\\
{\small }&
{\small '-'}&
{\small -x = 0-x, }\\
&
&
{\small note: this is defined on integer, real and complex}\\
{\small }&
{\small '{*}', '$\times$'}&
{\small {*}x=1{*}x identity operator}\\
{\small }&
{\small '/'}&
{\small /x=1.0/x }\\
&
&
{\small note: this is defined on integer, real and complex}\\
{\small }&
{\small 'div', '$\div $'}&
{\small div x =1 div x}\\
{\small }&
{\small 'mod'}&
{\small mod x = 1 mod x}\\
{\small }&
{\small 'and'%, '$\and$'
}&
{\small and x = true and x}\\
{\small }&
{\small 'or'%, '$\or$'
}&
{\small or x = false or x}\\
{\small }&
{\small 'not', '$\neg$'}&
{\small complements booleans}\\
{\small }&
{\small 'round'}&
{\small rounds a real to the closest integer}\\
{\small }&
{\small 'sqrt', '$\sqrt{} $'} &
{\small returns square root as a real\index{real} number.}\\
{\small }&
{\small 'sin'}&
{\small sine of its argument. Argument in radians. Result is real.}\\
{\small }&
{\small 'cos'}&
{\small cosine of its argument. Argument in radians. Result is real.}\\
{\small }&
{\small 'tan'}&
{\small tangent of its argument. Argument in radians. Result is real.}\\
{\small }&
{\small 'abs'}&
{\small if x<0 then abs x = -x else abs x= x}\\
{\small }&
{\small 'ln'}&
 {\small $ \log _{e} $ of its argument. Result is real.}\\
{\small }&
{\small 'ord'}&
 {\small argument scalar type, returns ordinal }\\
&
&
{\small number of the argument.}\\
{\small }&
{\small 'chr'}&
 {\small converts an integer\index{integer} into a character\index{character}.}\\
{\small }&
{\small 'succ'}&
 {\small argument scalar type,}\\
&
&
 {\small returns the next scalar in the type.}\\
{\small }&
{\small 'pred'}&
{\small argument scalar type, }\\
&
&
{\small returns the previous scalar in the type.}\\
{\small }&
{\small 'iota', '$\iota$'}&
{\small iota i returns the ith current index\index{index}}\\
{\small }&
{\small 'trans'}&
{\small transposes a matrix\index{matrix} or vector\index{vector}}\\
{\small }&
{\small 'pixel2byte'}&
{\small convert pixel in range -1.0..1.0 to byte in range 0..255}\\
{\small }&
{\small 'byte2pixel'}&
{\small convert a byte in range 0..255 to a pixel in}\\
&
&
 {\small the range -1.0..1.0}\\
{\small }&
{\small '@','addr'}&
{\small Given a variable, this returns an} \\
&
&
{\small untyped pointer\index{pointer} to the variable.}\\
\hline 
\end{tabular}\small \par}
\end{table}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<unary expression>&
<unaryop> <unary expression>\\
&
'sizeof' '(' <type> ')'\\
&
<operator reduction>\\
&
<primary expression>\\
\hline 
&
'if'<expression> 'then' <expression> 'else' <expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsubsection{sizeof}

The construct \texttt{sizeof\index{sizeof}(} \emph{t} \texttt{)} where \emph{t}
is a type, returns the number of bytes\index{bytes} occupied by an instance
of the type.


\subsubsection{iota\label{iota}}

The operator iota i returns the ith current implicit index\footnote{%
See section \ref{manimplicitindices}.
}. 


\paragraph{Examples}

Thus given the definitions 

\texttt{var v1:array{[}1..3{]}of integer; }

\texttt{v2:array{[}0..4{]} of integer;}

then the program fragment

\texttt{v1:=iota 0;}

\texttt{v2:=iota 0 {*}2;}

\texttt{}

\texttt{for i:=1 to 3 do write( v1{[}i{]}); writeln; }

\texttt{writeln('v2'); }

\texttt{for i:=0 to 4 do write( v2{[}i{]}); writeln; }

would produce the output

\begin{lyxcode}
v1

1~2~3~

v2~

0~2~4~6~8
\end{lyxcode}
whilst given the definitions

\texttt{m1:array{[}1..3,0..4{]} of integer;m2:array{[}0..4,1..3{]}of integer;}

then the program fragment 

\texttt{m2:= iota 0 +2{*}iota 1; }

\texttt{writeln('m2:= iota 0 +2{*}iota 1 '); }

\texttt{for i:=0 to 4 do begin for j:=1 to 3 do write(m2{[}i,j{]}); writeln;
end; }

would produce the output

\begin{lyxcode}
m2:=~iota~0~+2{*}iota~1~

2~4~6~

3~5~7~

4~6~8~

5~7~9~

6~8~10~~
\end{lyxcode}
The argument to \texttt{iota}\index{iota} must be an integer known at compile
time within the range of implicit indices in the current context. The reserved
word \texttt{ndx\index{ndx}} is a synonym for \texttt{iota}.


\paragraph{perm}

A generalised permutation of the implicit indices is performed using the syntactic
form: 

\begin{quote}
\texttt{perm}\texttt{{[}}\texttt{\textit{index-sel{[},index-sel{]}{*} {]}expression }}
\end{quote}
The \textit{index-sel}s are integers known at compile time which specify a permutation
on the implicit indices. Thus in $ e $ evaluated in context \texttt{perm}\texttt{{[}$ i,j,k ${]}$ e $},
then: 

\begin{quote}
\texttt{iota 0 = iota} \texttt{$ i, $} \texttt{iota 1= iota} \texttt{$ j, $}
\texttt{iota 2= iota} \texttt{$ k $}
\end{quote}
This is particularly useful in converting between different image formats. Hardware
frame buffers typically represent images with the pixels in the red, green,
blue, and alpha channels adjacent in memory. For image processing it is convenient
to hold them in distinct planes. The \texttt{perm} operator provides a concise
notation for translation between these formats: \begin{verbatim}
type rowindex=0..479;
     colindex=0..639;
var channel=red..alpha;
    screen:array[rowindex,colindex,channel] of pixel;
    img:array[channel,colindex,rowindex] of pixel;
...
screen:=perm[2,0,1]img;
\end{verbatim}

\texttt{trans\index{trans}} and \texttt{diag} \label{diag} provide shorthand
notions for expressions in terms of \texttt{perm}\index{perm}. Thus in an assignment
context of rank 2, \texttt{trans = perm{[}1,0{]}} and \texttt{diag = perm{[}0,0{]}}. 


\subsubsection{trans}

The operator trans\index{trans} transposes a vector or matrix. It achieves
this by cyclic rotation of the implicit indices\index{indices}\index{implicit indices}.
Thus if \texttt{trans} \emph{e} is evaluated in a context with implicit indices 

\texttt{iota} \emph{0}.. \texttt{iota} \emph{n }

then the expression e is evaluated in a context with implicit indices 

\texttt{iota}'\emph{0}.. \texttt{iota}'\emph{n} 

where 

\texttt{iota}'\emph{x} = \texttt{iota} ( (\emph{x+1})\texttt{mod} \emph{n+1})

It should be noted that transposition is generalised to arrays of rank greater
than 2.


\paragraph{Examples}

Given the definitions used above in section \ref{iota}, the program fragment:

\texttt{m1:= (trans v1){*}v2; }

\texttt{writeln('(trans v1){*}v2'); }

\texttt{for i:=1 to 3 do begin for j:=0 to 4 do write(m1{[}i,j{]}); writeln;
end; }

\texttt{m2 := trans m1; }

\texttt{writeln('transpose 1..3,0..4 matrix'); }

\texttt{for i:=0 to 4 do begin for j:=1 to 3 do write(m2{[}i,j{]}); writeln;
end;}

will produce the output:

\begin{lyxcode}
(trans~v1){*}v2~

0~~2~~4~~6~~8~

0~~4~~8~12~16~

0~~6~12~18~24~

transpose~1..3,0..4~matrix~

0~~0~~0~

2~~4~~6~

4~~8~12~

6~12~18~

8~16~24
\end{lyxcode}

\subsection{Operator Reduction}

Any dyadic operator can be converted to a monadic\index{monadic} reduction\index{reduction}
operator by the functional \textbackslash{}. Thus if \texttt{a} is an array,
\texttt{\textbackslash{}+a} denotes the sum over the array. More generally $ \setminus \Phi x $
for some dyadic operator $ \Phi  $ means $ x_{0}\Phi (x_{1}\Phi ..(x_{n}\Phi \iota )) $
where $ \iota  $ is the implicit value given the operator and the type. Thus
we can write \texttt{\textbackslash{}+} for summation, \texttt{\textbackslash{}{*}} for nary product
etc. The dot product of two vectors can thus be written as
\begin{verbatim}
x:= \+ y*x;
\end{verbatim} 

instead of

\texttt{x:=0;}

\texttt{for i:=0 to n do x:= x+ y{[}i{]}{*}z{[}i{]};}

A reduction operation takes an argument of rank\index{rank} \emph{r} and returns
an argument of rank \emph{r-1} except in the case where its argument is of rank
0, in which case it acts as the identity operation. Reduction is always performed
along the last array\index{array} dimension\index{dimension} of its argument. 

The operations of summation and product can be be written eithter as the two
functional forms $\backslash$ +
and $\backslash$ $ *$ or  as the prefix operators $\sum$ (Unicode 2211) and $\prod$ (Unicode 220f).




\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<operator reduction>&
'\textbackslash{}'<dyadic op> <multiplicative expression>\\
& '$\sum$' <mutliplicative expression>\\
& '$\prod$' < multiplicative expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<dyadic op>&
<expop>\\
&
<multop>\\
&
<addop>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The reserved word \texttt{rdu\index{rdu}} is available as a lexical alternative
to \textbackslash{}, so \textbackslash{}+ is equivalent to \texttt{rdu}+.


\subsection{Complex conversion}

Complex\index{Complex} numbers can be produced from reals using the function
\texttt{cmplx}\index{cmplx}. \texttt{cmplx(}\emph{re,im}\texttt{)} is the complex
number with real part \emph{re}, and imaginaray part \emph{im}.

The real and imaginary parts of a complex number can be obtained by the functions
\texttt{re} and \texttt{im}. \texttt{re}(\emph{c}) is the real part of the complex
number \emph{c}. \texttt{im}(\emph{c}) is the imaginary part of the complex
number \emph{c}.


\subsection{Conditional expressions}

The conditional expression allows two different values to be returned depenent
upon a boolean expression.

\begin{verbatim}
var a:array[0..63] of real;
... 

a:=if a>0 then a else -a; 

...
\end{verbatim}

The \texttt{if} expression can be compiled in two ways: 

\begin{enumerate}
\item Where the two arms of the if expression are parallelisable, the condition and
both arms are evaluated and then merged under a boolean mask. Thus, the above
assignment would be equivalent to: 


\texttt{a:= (a and (a$ > $0))or(not (a$ > $0) and -a);}

were the above legal Pascal\footnote{%
This compilation strategy requires that true is equivalent to -1 and false to
0. This is typically the representation of booleans returned by vector comparison
instructions on SIMD instruction sets. In Vector Pascal this representation
is used generally and in consequence, \texttt{true}$ < $\texttt{false}.
}. 

\item If the code is not paralleliseable it is translated as equivalent to a standard
if statement. Thus, the previous example would be equivalent to: 


\texttt{for i:=0 to 63 do if a{[}i{]}$ > $0 then a{[}i{]}:=a{[}i{]} else
a{[}i{]}:=-a{[}i{]};}

Expressions are non parallelisable if they include function calls. 

\end{enumerate}
The dual compilation strategy allows the same linguistic construct to be used
in recursive function definitions and parallel data selection. 

\subsubsection{Use of boolean mask vectors}
In array programming many operations can be efficiently be expressed in terms
of boolean mask vectors.
Given the declarations:\begin{verbatim}
    i:array[1..4] of integer;
    r:array[1..4] of real;
    c:array[1..4] of complex;
    b:array[1..4] of boolean;
    s:array[1..4] of string;\end{verbatim}
and if 
    
\subsection{Factor\index{Factor}}

A factor is an expression that optionally performs exponentiation. Vector Pascal
supports exponentiation either by integer exponents or by real exponents. A
number \emph{x} can be raised to an integral power \emph{y} by using the construction
\emph{x} \texttt{pow\index{pow}} \emph{y}. A number can be raised to an arbitrary
real power by the \texttt{{*}{*}} operator. The result of \texttt{{*}{*}\index{**}}
is always real valued.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<expop>&
'pow'\\
&
'{*}{*}'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<factor>&
<unary expression> {[} <expop> <unary expression>{]}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Multiplicative expressions}

Multiplicative expressions consist of factors linked by the multiplicative operators
\texttt{{*}, $\times$, /, div, $\div$,\index{div}, mod\index{mod}, shr\index{shr}, shl\index{shl}
and}\index{and}. The use of these operators is summarised in table \ref{multop}.


\begin{table}

\caption{Multiplicative operators\label{multop}}
{\centering \begin{tabular}{ccccc}
{\small Operator}&
{\small Left}&
{\small Right}&
{\small Result}&
{\small Effect of} \emph{\small a} \texttt{\small op} \emph{\small b}{\small }\\
\hline 
\texttt{\small {*}, $\times$}{\small }&
{\small integer}&
{\small integer}&
{\small integer}&
{\small multiply}\\
{\small }&
{\small real}&
{\small real}&
{\small real}&
{\small multiply}\\
{\small }&
{\small complex}&
{\small complex}&
{\small complex}&
{\small multiply}\\
\texttt{\small /}{\small }&
{\small integer}&
{\small integer}&
{\small real}&
{\small division}\\
{\small }&
{\small real}&
{\small real}&
{\small real}&
{\small division}\\
{\small }&
{\small complex}&
{\small complex}&
{\small complex}&
{\small division}\\
\texttt{\small div, $\div$}{\small }&
{\small integer}&
{\small integer}&
{\small integer}&
{\small division}\\
\texttt{\small mod}{\small }&
{\small integer}&
{\small integer}&
{\small integer}&
{\small remainder}\\
\texttt{\small and}{\small }&
{\small boolean}&
{\small boolean}&
{\small boolean}&
{\small logical and}\\
\texttt{\small shr}{\small }&
{\small integer}&
{\small integer}&
{\small integer}&
{\small shift} \emph{\small a} {\small by} \emph{\small b} {\small bits right}\\
\texttt{\small shl}{\small }&
{\small integer}&
{\small integer}&
{\small integer}&
{\small shift} \emph{\small a} {\small by} \emph{\small b} {\small bits left}\\
\texttt{\small in, $\in$}{\small }&
\emph{\small t}{\small }&
\texttt{\small set of} \emph{\small t}{\small }&
{\small boolean}&
{\small true if} \emph{\small a} {\small is member of} \emph{\small b}\\
\hline 
\end{tabular}\small \par}\end{table}


\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<multop>&
'{*}'\\
&'{$\times$}'\\
&
'/'\\
&
'div'\\
&
'$\div$'\\
&
'shr'\\
&
'shl'\\
&
'and'\\
&
'mod'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<multiplicative expression>&
<factor> {[} <multop> <factor> {]}{*}\\
&
<factor>'in'<multiplicative expression>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\subsection{Additive expressions}

An additive expression allows multiplicative expressions to be combined using
the addition operators \texttt{+\index{+}, -\index{-}, or, +:\index{+:}\index{or},max\index{max},
min\index{min}, -:}\index{-:}, 
\verb+><+\index{\verb+><+}. The additive operations are summarised in table\ref{addops}
.


\begin{table}

\caption{Addition operations\label{addops}}
{\centering \begin{tabular}{cccccc}
\hline 
{\small }&
{\small Left}&
{\small }&
{\small Right}&
{\small Result}&
{\small Effect of} \emph{\small a} \texttt{\small op} \emph{\small b}{\small }\\
\hline 
\hline 
\texttt{\footnotesize +}{\footnotesize }&
{\footnotesize integer}&
{\footnotesize }&
{\footnotesize integer}&
{\footnotesize integer}&
{\footnotesize sum of} \emph{\footnotesize a} {\footnotesize and} \emph{\footnotesize b}{\footnotesize }\\
{\footnotesize }&
{\footnotesize real}&
{\footnotesize }&
{\footnotesize real}&
{\footnotesize real}&
{\footnotesize sum of} \emph{\footnotesize a} {\footnotesize and} \emph{\footnotesize b}{\footnotesize }\\
{\footnotesize }&
{\footnotesize complex}&
{\footnotesize }&
{\footnotesize complex}&
{\footnotesize complex}&
{\footnotesize sum of} \emph{\footnotesize a} {\footnotesize and} \emph{\footnotesize b}{\footnotesize }\\
{\footnotesize }&
{\footnotesize set}&
{\footnotesize }&
{\footnotesize set}&
{\footnotesize set}&
{\footnotesize union of} \emph{\footnotesize a} {\footnotesize and} \emph{\footnotesize b}{\footnotesize }\\
{\footnotesize }&
{\footnotesize string}&
{\footnotesize }&
{\footnotesize string}&
{\footnotesize string}&
{\footnotesize concatenate\index{concatenate}} \emph{\footnotesize a} {\footnotesize with}
\emph{\footnotesize b} {\footnotesize 'ac'+'de'='acde'}\\
\texttt{\footnotesize -}{\footnotesize }&
{\footnotesize integer}&
{\footnotesize }&
{\footnotesize integer}&
{\footnotesize integer}&
{\footnotesize result of subtracting} \emph{\footnotesize b} {\footnotesize from}
\emph{\footnotesize a}{\footnotesize }\\
{\footnotesize }&
{\footnotesize real}&
{\footnotesize }&
{\footnotesize real}&
{\footnotesize real}&
{\footnotesize result of subtracting} \emph{\footnotesize b} {\footnotesize from}
\emph{\footnotesize a}{\footnotesize }\\
{\footnotesize }&
{\footnotesize complex}&
{\footnotesize }&
{\footnotesize complex}&
{\footnotesize complex}&
{\footnotesize result of subtracting} \emph{\footnotesize b} {\footnotesize from}
\emph{\footnotesize a}{\footnotesize }\\
{\footnotesize }&
{\footnotesize set}&
{\footnotesize }&
{\footnotesize set}&
{\footnotesize set}&
{\footnotesize complement\index{complement} of} \emph{\footnotesize b} {\footnotesize relative
to} \emph{\footnotesize a}{\footnotesize }\\
\texttt{\footnotesize +:}{\footnotesize }&
{\footnotesize 0..255}&
{\footnotesize }&
{\footnotesize 0..255}&
{\footnotesize 0..255}&
{\footnotesize saturated + clipped to 0..255 }\\
{\footnotesize }&
{\footnotesize -128..127}&
{\footnotesize }&
{\footnotesize -128..127}&
{\footnotesize -128..127}&
{\footnotesize saturated + clipped to -128..127}\\
\texttt{\footnotesize -:}{\footnotesize }&
{\footnotesize 0..255}&
{\footnotesize }&
{\footnotesize 0..255}&
{\footnotesize 0..255}&
{\footnotesize saturated\index{saturated} - clipped to 0..255}\\
{\footnotesize }&
{\footnotesize -128..127}&
{\footnotesize }&
{\footnotesize -128..127}&
{\footnotesize -128..127}&
{\footnotesize saturated - clipped to -128..127}\\
\texttt{\footnotesize min\index{min}}{\footnotesize }&
{\footnotesize integer}&
{\footnotesize }&
{\footnotesize integer}&
{\footnotesize integer}&
{\footnotesize returns the lesser of the numbers}\\
&
{\footnotesize real}&
{\footnotesize }&
{\footnotesize real}&
{\footnotesize real}&
{\footnotesize returns the lesser of the numbers}\\
\texttt{\footnotesize max\index{max}}{\footnotesize }&
{\footnotesize integer}&
{\footnotesize }&
{\footnotesize integer}&
{\footnotesize integer}&
{\footnotesize returns the greater of the numbers}\\
&
{\footnotesize real}&
{\footnotesize }&
{\footnotesize real}&
{\footnotesize real}&
{\footnotesize returns the greater of the numbers}\\
\texttt{\footnotesize or}{\footnotesize }&
{\footnotesize boolean}&
{\footnotesize }&
{\footnotesize boolean}&
{\footnotesize boolean}&
{\footnotesize logical or}\\
{ \verb+><+}&
{\footnotesize set}&
{\footnotesize }&
{\footnotesize set}&
{\footnotesize set}&
{\footnotesize symetric difference}\\

\hline 
\end{tabular}\footnotesize \par}\end{table}


\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
{\footnotesize <addop>}&
{\footnotesize '+'}\\
{\footnotesize }&
{\footnotesize '-'}\\
{\footnotesize }&
{\footnotesize 'or'}\\
{\footnotesize }&
{\footnotesize 'max'}\\
{\footnotesize }&
{\footnotesize 'min'}\\
{\footnotesize }&
{\footnotesize '+:'}\\
{\footnotesize }&
{\footnotesize '-:'}\\
\hline 
\end{tabular}\footnotesize \par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
{\footnotesize <additive expression>}&
{\footnotesize <multiplicative expression> {[} <addop> <multiplicative expression>
{]}{*}}\\
\hline 
\end{tabular}\footnotesize \par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
{\footnotesize <expression>}&
{\footnotesize <additive expression> <relational operator> <expression>}\\
\hline 
\end{tabular}\footnotesize \par}
\vspace{0.3cm}


\subsection{Expressions}
An expression can optionally involve the use of  a relational operator
to compare the results of two additive expressions. Relational operators
always return boolean results and are listed in table \ref{relop}.
\begin{table}
\caption{Relational operators}\label{relop}\center
\begin{tabular}{cc}\hline
\verb+<+& Less than\\
\verb+>+& Greater than\\
\verb+<=+& Less than or equal to\\
\verb+>=+& Greater than or equal to\\
\verb+<>+ & Not equal to\\
\verb+=+& Equal to\\
\hline
\end{tabular}

\end{table}

\subsection{Operator overloading}

The dyadic operators\index{operator}
\index{operator, overloadin} can be extended to operate on new types by operator overloading.
Figure \ref{complex} shows how arithmetic on the type \texttt{complex} required
by Extended Pascal \cite{ISO90} is defined in Vector Pascal. Each operator
is associated with a semantic function and
if it is a non-relational operator,
an identity element. The operator
symbols must be drawn from the set of predefined Vector Pascal operators, and
when expressions involving them are parsed, priorities are inherited from the
predefined operators. The type signature of the operator is deduced from the
type of the function\footnote{%
Vector Pascal allows function results to be of any non-procedural type.
}. 

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
{\footnotesize <operator-declaration>}&
{\footnotesize 'operator' 'cast' '=' <identifier>}\\
&{\footnotesize 'operator' <dyadicop> '=' <identifier>','<identifier>}\\
&{\footnotesize 'operator' <relational operator> '=' <identifier>}\\
\hline 
\end{tabular}\footnotesize \par}
\vspace{0.3cm}
\begin{figure}{\small
\input complex
}
\caption{Defining operations on complex numbers}



\label{complex}{\small Note that only the function headers are given here as
this code comes from the interface part of the system unit. The function bodies
and the initialisation of the variables complexone and complexzero are handled
in the implementation part of the unit.}{\small \par}
\end{figure}
 When parsing expressions, the compiler first tries to resolve operations in
terms of the predefined operators of the language, taking into account the standard
mechanisms allowing operators to work on arrays. Only if these fail does it
search for an overloaded operator whose type signature matches the context. 

In the example in figure \ref{complex}, complex numbers are defined to be records
containing an array of reals, rather than simply as an array of reals. Had they
been so defined, the operators \texttt{+,{*},-,/} on reals would have masked
the corresponding operators on complex numbers. 

The provision of an identity element for complex addition and subtraction ensures
that unary minus, as in $ -x $ for $ x: $complex, is well defined, and
correspondingly that unary / denotes complex reciprocal. Overloaded operators
can be used in array maps and array reductions. 

\subsubsection{Implicit casts}\index{cast}
The Vector Pascal language already contains a number of implicit type
conversions that are context determind. An example is the promotion of
integers to reals in the context of arithmetic expressions. The set of
implicit casts can be added to by declaring an operator to be a cast
as is shown in the line:

\parbox{14cm}{\texttt{\textit{operator} 	\textit{cast} 	=	\textit{real2cmplx}  ;}}\\

Given an implict cast from type $t_0\rightarrow t_1$,
the function associated with the implicit cast is then called 
on the result
of any expression $e:t_0 $ whose expression context requires 
it to be of type $t_1$.
\section{Statements}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<statement>&
{\small <variable>':='<expression>}\\
{\small }&
{\small <procedure statement>}\\
{\small }&
{\small <empty statement>}\\
{\small }&
{\small 'goto' <label>;}\\
{\small }&
{\small 'exit'{[}'('<expression>')'{]}}\\
{\small }&
{\small 'begin' <statement>{[};<statement>{]}{*}'end'}\\
{\small }&
{\small 'if'<expression>'then'<statement>{[}'else'<statement>{]}}\\
{\small }&
{\small <case statement>}\\
{\small }&
{\small 'for' <variable>:= <expression> 'to' <expression> 'do' <statement>}\\
{\small }&
{\small 'for' <variable>:= <expression> 'downto' <expression> 'do' <statement>}\\
{\small }&
{\small 'repeat' <statement> 'until' <expression>}\\
{\small }&
{\small 'with' <record variable> 'do' < statement>}\\
{\small }&
{\small <io statement>}\\
{\small }&
{\small 'while' <expression> 'do' <statement>}\\
\hline 
\end{tabular}\small \par}
\vspace{0.3cm}


\subsection{Assignment\label{assignment}}

An assignment replaces the current value of a variable by a new value specified
by an expression. The assignment operator\index{operator} is\index{is} :=\index{:=}.
Standard Pascal allows assignment\index{assignment} of whole arrays\index{array}.
Vector Pascal extends this to allow consistent use of mixed rank\index{rank}
expressions on the right hand side of an assignment. Given

\texttt{r0:real; r1:array{[}0..7{]} of real; }

{\tt r2:array{[}0..7,0..7{]} of real}

then we can write

\begin{enumerate}
\item r\texttt{1:= r2{[}3{]}; \{ supported in standard Pascal \}}
\item \texttt{r1:= /2; \{ assign 0.5 to each element of r1 \}}
\item \texttt{r2:= r1{*}3; \{ assign 1.5 to every element of r2\}}
\item \texttt{r1:= \textbackslash{}+ r2; \{ r1 gets the totals along the rows of r2\}}
\item \texttt{r1:= r1+r2{[}1{]};\{ r1 gets the corresponding elements of row 1 of
r2 added to it\}}
\end{enumerate}
The assignment of arrays is a generalisation of what standard Pascal allows.
Consider the first examples above, they are equivalent to:

\begin{enumerate}
\item \texttt{for i:=0 to 7 do r1{[}i{]}:=r2{[}3,i{]};}
\item \texttt{for i:=0 to 7 do r1{[}i{]}:=/2;}
\item {\tt for i:=0 to 7 do 

for j:=0 to 7 do r2{[}i,j{]}:=r1{[}j{]}{*}3;}
\item {\tt for i:=0 to 7 do 

begin 

\ t:=0; 

\ for j:=7 downto 0 do t:=r2{[}i,j{]}+t;

\ r1{[}i{]}:=t; 

end;}
\item \texttt{for i:=0 to 7 do r1{[}i{]}:=r1{[}i{]}+r2{[}1,i{]};}
\end{enumerate}
In other words the compiler has to generate an implicit loop\index{loop} over
the elements of the array being assigned to and over the elements of the array
acting as the data-source. In the above \texttt{i,j,t} are assumed to be temporary
variables not referred to anywhere else in the program. The loop variables are
called implicit indices\index{indices}\index{implicit indices} \label{manimplicitindices}and
may be accessed using \texttt{iota}. 

The variable on the left hand side of an assignment defines an array\index{array}
context within which expressions on the right hand side are evaluated. Each
array context has a rank given by the number of dimensions\index{dimensions}
of the array on the left hand side. A scalar variable has rank\index{rank}
0. Variables occurring in expressions with an array context of rank \emph{r}
must have \emph{r} or fewer dimensions. The \emph{n} bounds of any \emph{n}
dimensional array variable, with $ n\leq r $ occurring within an expression
evaluated in an array context of rank \emph{r} must match with the rightmost
\emph{n} bounds of the array on the left hand side of the assignment statement. 

Where a variable is of lower rank than its array context, the variable is replicated
to fill the array context\index{array context}. This is shown in examples 2
and 3 above. Because the rank of any assignment is constrained by the variable
on the left hand side, no temporary arrays, other than machine registers, need
be allocated to store the intermediate array results of expressions.


\subsection{Procedure statement}

A procedure statement executes a named procedure\index{procedure}. A procedure
statement may, in the case where the named procedure has formal parameters,
contain a list of actual parameters. These are substituted in place of the formal
parameters contained in the declaration. Parameters may be value parameters
or variable parameters. 

Semantically the effect of a value parameter is that a copy is taken of the
actual parameter\index{parameter} and this copy substituted into the body of
the procedure. Value parameters may be structured values such as records and
arrays. For scalar values, expressions may be passed as actual parameters. Array
expressions are not currently allowed as actual parameters. 

A variable parameter is passed by reference, and any alteration of the formal
parameter induces a corresponding change in the actual parameter. Actual variable
parameters must be variables.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c||c|}
\hline 
<parameter>&
<variable>&
for formal parameters declared as var\\
&
<expression>&
for other formal parameters \\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<procedure statement>&
<identifier>\\
&
<identifier> '(' <parameter> {[}','<parameter>{]}{*} ')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\paragraph{Examples}

\begin{enumerate}
\item \texttt{printlist;}
\item \texttt{compare(avec,bvec,result);}
\end{enumerate}

\subsection{Goto statement}

A goto statement transfers control to a labelled statement. The destination
label must be declared in a label\index{label} declaration. It is illegal to
jump into or out of a procedure.


\paragraph{Example}

\texttt{goto\index{goto} 99;}


\subsection{Exit\index{Exit} Statement}

An exit statement transfers control to the calling point of the current procedure
or function. If the exit statement is within a function then the exit statement
can have a parameter: an expression whose value is returned from the function.


\paragraph{Examples}

\begin{enumerate}
\item \texttt{exit;}
\item \texttt{exit(5);}
\end{enumerate}

\subsection{Compound statement}

A list of statements separated by semicolons may be grouped into a compound
statement by bracketing them with \texttt{begin} and \texttt{end} .


\paragraph{Example}

\texttt{begin\index{begin} a:=x{*}3; b:=sqrt a end\index{end};}


\subsection{If statement}

The basic control flow construct is the if statement. If the boolean expression
between \texttt{if\index{if}} and \texttt{then\index{then}} is true then the
statement following \texttt{then} is followed. If it is false and an else part
is present, the statement following \texttt{else\index{else}} is executed. 


\subsection{Case statement}

The case\index{case} statement specifies an expression which is evaluated and
which must be of integral or ordinal type. Dependent upon the value of the expression
control transfers to the statement labelled by the matching constant.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<case statement>&
'case'<expression>'of'<case actions>'end'\\


\hline 
\end{tabular}\par}
\vspace{0.3cm}
\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<case actions>&
<case list>\\&
<case list> 'else' <statement>\\&
<case list> 'otherwise' <statement>\\


\hline 
\end{tabular}\par}
\vspace{0.3cm}
\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<case list>&
<case list element>{[}';'<case list element.{]}{*}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<case list element>&
<case label>{[}',' <case label>{]}':'<statement>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<case label>&
<constant>\\
&
<constant> '..' <constant>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}


\paragraph{Examples}

\vspace{0.3cm}
{\raggedright \begin{tabular}{ll}
\texttt{case} i \texttt{of}&
\texttt{case} c \texttt{of}\\
\texttt{1:s:=abs s;}&
\texttt{'a':write('A');}\\
\texttt{2:s:= sqrt s;}&
\texttt{'b','B':write('B');}\\
\texttt{3: s:=0}&
\texttt{'A','C'..'Z','c'..'z':write(' ');}\\
\texttt{end}&
\texttt{end}\\
\end{tabular}\par}
\vspace{0.3cm}


\subsection{With statement}

Within the component statement of the with\index{with} statement the fields
of the record variable can be referred to without prefixing them by the name
of the record variable. The effect is to import the component statement into
the scope defined by the record\index{record} variable declaration so that
the field-names appear as simple variable names.


\paragraph{Example}

\texttt{var s:record x,y:real end;}

\texttt{begin}

\texttt{with s do begin x:=0;y:=1 end ;}

\texttt{end}


\subsection{For statement}

A for\index{for} statement executes its component statement repeatedly under
the control of an iteration\index{iteration} variable. The iteration variable
must be of an integral or ordinal type. The variable is either set to count
up through a range or down through a range.

\texttt{for i:= e1 to\index{to} e2 do s}

is equivalent to

\texttt{i:=e1; temp:=e2;while i<=temp do s;}

whilst

\texttt{for i:= e1 downto\index{downto} e2 do s}

is equivalent to

\texttt{i:=e1; temp:=e2;while i>= temp do s;}


\subsection{While statement}

A while\index{while} statement executes its component statement whilst its
boolean expression is true. The statement

\texttt{while e do s}

is equivalent to

\texttt{10: if not e then goto 99; s; goto 10; 99:}


\subsection{Repeat statement}

A repeat\index{repeat} statement executes its component statement at least
once, and then continues to execute the component statement until its component
expression becomes true.

\texttt{repeat s until e}

is equivalent to

\texttt{10: s;if e then goto 99; goto 10;99:}


\section{Input Output }

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<io statement>&
'writeln'{[}<outparamlist>{]}\\
&
'write'<outparamlist>\\
&
'readln'{[}<inparamlist>{]}\\
&
'read'<inparamlist>\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<outparamlist>&
'('<outparam>{[}','<outparam>{]}{*}')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<outparam>&
<expression>{[}':' <expression>{]} {[}':'<expression>{]} \\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<inparamlist>&
'('<variable>{[}','<variable>{]}{*}')'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Input and output are supported from and to the console and also from and to
files. 


\subsection{Input}

The basic form of input is the \texttt{read} statement. This takes a list of
parameters the first of which may optionally be a file variable. If this file
variable is present it is the input file. In the absence of a leading file variable
the input file is the standard input stream. The parameters take the form of
variables into which appropriate translations of textual representations of
values in the file are read. The statement 

\texttt{read\index{read}(}\emph{a,b,c}\texttt{) }

where \emph{a,b,c} are non file parameters is exactly equivalent to the sequence
of statements 

\texttt{read(}\emph{a}\texttt{);read(}\emph{b}\texttt{);read(}\emph{c}\texttt{) }

The \texttt{readln}\index{readln} statement has the same effect as the read
statement but finishes by reading a new line from the input file. The representation
of the new line is operating system dependent. The statement 

\texttt{readln(}\emph{a,b,c}\texttt{) }

where \emph{a,b,c} are non file parameters is thus exactly equivalent to the
sequence of statements 

\texttt{read(}\emph{a}\texttt{);read(}\emph{b}\texttt{);read(}\emph{c}\texttt{);readln; }

Allowed typed for read statements are: integers, reals, strings and enumerated
types.


\subsection{Output }

The basic form of output is the \texttt{write\index{write}} statement. This
takes a list of parameters the first of which may optionally be a file variable.
If this file variable is present it is the output file. In the absence of a
leading file variable the output file is the console. The parameters take the
form of expressions whose values whose textual representations are written to
the output file. The statement 

\texttt{write(}\emph{a,b,c}\texttt{) }

where \emph{a,b,c} are non file parameters is exactly equivalent to the sequence
of statements 

\texttt{write(}\emph{a}\texttt{);write(}\emph{b}\texttt{);write(}\emph{c}\texttt{) }

The \texttt{writeln\index{writeln}} statement has the same effect as the write
statement but finishes by writing a new line to the output file. The representation
of the new line is operating system dependent. The statement 

\texttt{writeln(}\emph{a,b,c}\texttt{) }

where \emph{a,b,c} are non file parameters is thus exactly equivalent to the
sequence of statements 

\texttt{write(}\emph{a}\texttt{);write(}\emph{b}\texttt{);write(}\emph{c}\texttt{);writeln; }

Allowed types for write statements are integers, reals, strings and enumerated
types.


\subsubsection{Parameter formating\index{formating} }

A non file parameter can be followed by up to two integer expressions prefixed
by colons which specify the field widths to be used in the output. The write
parameters can thus have the following forms: 

\emph{e e}:\emph{m e}:\emph{m}:\emph{n }

\begin{enumerate}
\item If \emph{e} is an integral type its decimal expansion will be written preceeded
by sufficient blanks to ensure that the total textual field width produced is
not less than \emph{m}. 
\item If \emph{e} is a real its decimal expansion will be written preceeded by sufficient
blanks to ensure that the total textual field width produced is not less than
\emph{m}. If \emph{n} is present the total number of digits after the decimal
point will be \emph{n}. If \emph{n} is omitted then the number will be written
out in exponent and mantissa form with 6 digits after the decimal point
\item If \emph{e} is boolean the strings 'true' or 'false' will be written into a
field of width not less than m. 
\item If \emph{e} is a string then the string will be written into a field of width
not less than \emph{m}.
\end{enumerate}

\chapter{Programs and Units}
\label{progunit}
Vector Pascal supports the popular system of separate compilation units\index{units}
found in Turbo\index{Turbo Pascal} Pascal. A compilation unit can be either
a program, a unit or a library\index{library}.

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|}
\hline 
<program>&
'program' <identifier>';'{[}<uses>';'{]}<block>'.'\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline
<invocation>&
<identifier>['(' <type identifier>{[}','<type identifier>{]*}')']\\
\hline
\end{tabular}\par}

\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
<uses>&
'uses' <invocation>{[}','<invocation>{]}{*}\\
\hline
\end{tabular}\par}
\vspace{0.2cm}

\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
\label{block}<block>&
{[}<decls>';'{]}{*}'begin' <statement>{[}';'<statement>{]}{*}'end'\\
\hline
\end{tabular}\par}
\vspace{0.3cm}


\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
<decls>&
'const' <constant declaration>{[}';'<constant declaration>{]}{*}\\
&
'type'<type definition>{[}';'<type definition>{]}{*}\\
&
'label' <label>{[}',' <label>{]}\\
&
<procedure declaration>\\
&
'var' <variable declaration>{[} ';' <variable declaration> {]}\\
\hline
\end{tabular}\par}
\vspace{0.2cm}
\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
<unit>&
<unit header> <unit body>\\

\hline
\end{tabular}\par}

\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
<unit body>&
'interface'[<uses>][<decls>] 'implementation'<block>'.'\\&
'interface'[ <uses>][<decls>] 'in' <invocation> ';'\\

\hline
\end{tabular}\par}

\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
<unit header>&
<unit type><identifier>\\
&'unit' <identifier> '(' <type identifier> [',' <type identifier>]* ')'\\

\hline
\end{tabular}\par}
\vspace{0.2cm}

\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|}
\hline
<unit type>&
'unit'\\
&
'library'\\
\hline
\end{tabular}\par}
\vspace{0.2cm}

An executable compilation unit must be declared as a program\index{program}.
The program can use several other compilation units all of which must be either
units or libraries. The units or libraries that it directly uses are specified
by a list of identifiers in an optional use list at the start of the program.
A unit or library has two declaration portions and an executable block.


\section{The export of identifiers from units}

The first declaration portion is the interface part and is preceded by the reserved
word \texttt{interface}\index{interface}.

The definitions in the interface section of unit files constitute a sequence
of enclosing scopes, such that successive units in the with list ever more closely
contain the program itself. Thus when resolving an identifier, if the identifier
can not be resolved within the program scope, the declaration of the identifier
within the interface section of the rightmost unit in the uses list is taken
as the defining occurrence. It follows that rightmost occurrence of an identifier
definition within the interface parts of units on the uses list overrides all
occurrences in interface parts of units to its left in the uses list.

The implementation part of a unit consists of declarations\index{declarations},
preceded by the reserved word \texttt{implementatio}n\index{implementation}
that are private to the unit with the exception that a function or procedure
declared in an interface context can omit the procedure body, provided that
the function or procedure is redeclared in the implementation part of the unit.
In that case the function or procedure heading given in the interface part is
taken to refer to the function or procedure of the same name whose body is declared
in the implementation part. The function or procedure headings sharing the same
name in the interface and implementation parts must correspond with respect
to parameter types, parameter order and, in the case of functions, with respect
to return types.

A unit may itself contain a use list, which is treated in the same way as the
use lists of a program. That is to say, the use list of a unit makes accessible
identifiers declared within the interface parts of the units named within the
use list to the unit itself.


\subsection{The export of procedures from libraries.}

If a compilation unit is prefixed by the reserved word \texttt{library} rather
than the words \texttt{program} or \texttt{unit}, then the procedure and function
declarations in its interface part are made accessible to routines written in
other languages.


\subsection{The export of Operators from units}

A unit can declare a type and export operators for that type.

\section{Unit parameterisation and generic functions}
Standard Pascal provides es some limited support for polymorphism\index{polymorphism}
in its {\tt read} and {\tt write} functions.
Vector Pascal allows the writing of polymorphic functions and
procedures through the use of parameteric units.

A unit header can include an optional parameter list. The parameters identifiers which are
interepreted as type names. These can be used to declare polymorphic procedures and
functions, parameterised by these type names.
This is shown in figure \ref{unit:genericsort}.

\begin{figure}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{3.5cm}{\scriptsize{}}\'\parbox{14cm}{\textsf{\textbf{unit}  \textit{genericsort(t)}  ;}}\\
\+\parbox{14cm}{\textsf{\textbf{interface} }}\\
%\+\parbox{14cm}{\textsf{\textbf{type} }}\\
%\parbox{14cm}{\textsf{\textit{t} =\textit{integer} ;}}\\
\<\parbox{14cm}{\textsf{\textbf{type} }}\\
\parbox{14cm}{\textsf{\textit{dataarray} \textit{(} \textit{n} ,\textit{m} :\textit{integer} )=\textbf{array} [\textit{n} ..\textit{m} ] \textbf{of}  \textit{t} ;}}\\
\<\textsf{\textbf{procedure}  \textit{sort} \textit{(} \textbf{var}  \textit{a} :\textit{dataarray} );} (see Figure \ref{sec:./genericsortsort} )\\
\\
\<\parbox{14cm}{\textsf{\textbf{implementation} }}\\
\\
\<\textsf{\textbf{procedure}  \textit{sort} \textit{(} \textbf{var}  \textit{a} :\textit{dataarray} );} (see Figure \ref{sec:./genericsortsort} )\\
\-\<\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\<\-\parbox{14cm}{\textsf{\textbf{end} .}}\\
\end{tabbing}


\caption{A polymorphic sorting unit.}\label{unit:genericsort}

\end{figure}
\begin{figure}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf {\textbf {procedure } \textsf{ \textit{sort} \textit{(} } \textbf{ var } \textsf{ \textit{a} :\textit{dataarray} );}}}\\
\+\parbox{14cm}{\textsf{\textbf{var} }}\\
\parbox{14cm}{\textsf{Let \textit{i}, \textit{j} $\in$ integer;}}\\
\parbox{14cm}{\textsf{Let \textit{temp} $\in$ t;}}\\
\-\<\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\+\parbox{14cm}{\textsf {\textbf {for } \textsf{\textit{i}$\leftarrow$ \textit{a.n}} \textbf{ to } \textsf{\textit{a.m} - 1} \textbf{ do } }}\\
\+\parbox{14cm}{\textsf {\textbf {for } \textsf{\textit{j}$\leftarrow$ \textit{a.n}} \textbf{ to } \textsf{\textit{a.m} - 1} \textbf{ do } }}\\
\+\<\parbox{14cm}{\textsf {\textbf {if } \textsf{\textit{a}$_{\textit{j}}$ $>$ \textit{a}$_{\textit{j} + 1}$} \textbf{ then } \textsf{\textit{begin}} \textbf{ begin } }}\\
\parbox{14cm}{\textsf{\textit{temp}$\leftarrow$ \textit{a}$_{\textit{j}}$}; }\\
\parbox{14cm}{\textsf{\textit{a}$_{\textit{j}}$ $\leftarrow$ \textit{a}$_{\textit{j} + 1}$}; }\\
\parbox{14cm}{\textsf{\textit{a}$_{\textit{j} + 1}$ $\leftarrow$ \textit{temp}}; }\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\<\-\<\-\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\end{tabbing}


\caption{procedure sort}\label{sec:./genericsortsort}

\end{figure}

\section{The invocation of programs and units}

Programs and units contain an executable block\index{block}. The rules for
the execution of these are as follows:

\begin{enumerate}
\item When a program is invoked by the operating system, the units or libraries in
its use list are invoked first followed by the executable block of the program
itself.
\item When a unit or library is invoked, the units or libraries in its use list are
invoked first followed by the executable block of the unit or library itself.
\item The order of invocation of the units or libraries in a use list is left to right
with the exception provided by rule 4.
\item No unit or library may be invoked more than once.
\end{enumerate}
Note that rule 4 implies that a unit \emph{x} to the right of a unit \emph{y}
within a use list, may be invoked before the unit \emph{y,} if the unit \emph{y}
or some other unit to \emph{y}'s left names \emph{x} in its use list.

Note that the executable part of a library will only be invoked if the library
in the context of a Vector Pascal program. If the library is linked to a main
program in some other language, then the library and any units that it uses
will not be invoked. Care should thus be taken to ensure that Vector Pascal
libraries to be called from main programs written in other languages do not
depend upon initialisation code contained within the executable blocks of units.



\section{The compilation of programs and units.}

When the compiler\index{compiler} processes the use list of a unit or a program
then, from left to right, for each identifier in the use list it attempts to
find an already compiled unit whose filename prefix is equal to the identifier.
If such a file exists, it then looks for a source\index{source} file whose
filename prefix is equal to the identifier, and whose suffix\index{suffix}
is \texttt{.pas}\index{'.pas'}. If such a file exists and is older than the
already compiled file, the already compiled unit, the compiler loads the definitions
contained in the pre-compiled unit. If such a file exists and is newer than
the pre-compiled unit, then the compiler attempts to re-compile the unit source
file. If this recompilation proceeds without the detection of any errors the
compiler loads the definitions of the newly compiled unit. The definitions in
a unit are saved to a file with the suffix \texttt{.mpu,} and prefix given by
the unit name. The compiler also generates an assembler file for each unit compiled.


\subsection{Linking to external libraries}

It is possible to specify to which external libraries - that is to say libraries
written in another languge, a program should be linked by placing in the main
program linkage directives. For example

\texttt{\{\$linklib ncurses\}}

would cause the program to be linked to the ncurses library.


\section{Instantiation of parametric units}
Instantiation of a parametric unit refers to the process by which the unbound type variables introduced
in the parameter list of the unit are bound to actual types.
In Vector Pascal all instantiation of parametric units and all type polymorphism are resolved\index{polymorphism}
at compile time.
Two mechanisms are provided by which a parametric unit may be instantiated.
\subsection{Direct instantiation}
If a generic unit is invoked in the use list of a program or unit, then the unit name
must be followed by a list of type identifiers. Thus given the generic sort unit
 in figure \ref{unit:genericsort}, one could instantiate it to sort arrays of reals by
 writing

 \textsf{\textbf{uses } \textit{genericsort}(\textit{real});}

 at the head of a program. Following this header, the
 procedure \textsf{\textit{sort}} would be declared as operating
 on arrays of reals.
 \subsection{Indirect instantiation}
 A named unit file can indirectly instantiate a generic unit where its unit body
 uses the syntax

'interface' <uses><decls> 'in' <invocation> ';'

For example 


\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf{\textbf{unit}  \textit{intsort} ;}}\\
\+\parbox{14cm}{\textsf{\textbf{interface} }}\\
\parbox{14cm}{\textsf {\textbf {in } \textsf{\textit{genericsort} (\textit{integer})}; }}\\
\\
\end{tabbing}
would create a named unit to sort integers. The naming of the parametric
units allows more than one instance of a given parametric unit to be used
in a program. The generic sort unit could be used to provide both integer and
real sorting procedures. The different variants of the procedures would be
distinquished by using fully qualified names - e.g., \textsf{\textit{ intsort.sort}}.
\section{The System Unit}
\label{sysunit}
All programs and units include by default the unit system.pas as an implicit
member of their with list. This contains declarations of private run time routines
needed by Vector Pascal and also the following user accessible routines.

\-

\begin{lyxlist}{00.00.0000}
\item [\texttt{function}]\texttt{abs\index{abs}} Return absolute value of a real or integer.
\item [\texttt{procedure}]\texttt{append\index{append}(var f:file);} This opens a
file in append mode.

\item [\texttt{function}]\texttt{arctan\index{arctan}(x:Real):Real;}
\item [\texttt{procedure}]\texttt{assign\index{assign}(var f:file;var fname:string);}
Associates a file name with a file. It does not open the file.
\item [\texttt{procedure}]\texttt{blockread\index{blockread}(var f:file;var buf;count:integer;
var resultcount:integer);} Trys to read count bytes from the file into the buffer.
Resultcount contains the number actually read.
\item [\texttt{LatexCommand}]\texttt{\textbackslash{}index\{blockwrite\}procedure
blockwrite(var f:file;var buf;count:integer; var resultcount:integer);} Write
count bytes from the buffer. Resultcount gives the number actually read.
\item [\texttt{procedure}]\texttt{close}\index{close}(var f:file); Closes a file.
\item [\texttt{function}]\texttt{eof}\index{eof}(var f:file):boolean; True if we
are at the end of file f.
\item [\texttt{procedure}]\texttt{erase}\index{erase}(var f:file); Delete file f.
\item [\texttt{function}]\texttt{eoln}\index{eoln}(var f:file):boolean; True if at
the end of a line.
\item [\texttt{function}]\texttt{exp}\index{exp}(d:real):real; Return $ e^{x} $
\item [\texttt{function}]\texttt{filesize}\index{filesize}(var f: fileptr):integer;
Return number of bytes in a file.
\item [\texttt{function}]\texttt{filepos}\index{filepos}(var f:fileptr):integer;
Return current position in a file.
\item [\texttt{procedure}]\texttt{freemem\index{freemem}(var p:pointer; num:integer);}
Free num bytes of heap store. Called by dispose.
\item [\-bold]procedure getmem\index{getmem}(var p:pointer; num:integer); Allocate
num bytes of heap. Called by new.
\item [\texttt{procedure}]\texttt{gettime\index{gettime}(var hour,min,sec,hundredth:integer);}
Return time of day.
\item [\texttt{}]Return the integer part of r as a real.
\item [\texttt{function}]\texttt{ioresult:integer;} Returns a code indicating if the
previous file operation completed ok. Zero if no error occurred.
\item [\texttt{function}]\texttt{length\index{length}(var s:string):integer;} Returns
the length of s.
\item [\texttt{procedure}]\texttt{pascalexit\index{pascalexit}(code:integer);} Terminate
the program with code.
\item [\texttt{\-}]Time in 1/100 seconds since program started.
\item [\texttt{function}]\texttt{random\index{random}:integer;} Returns a random
integer.
\item [\texttt{procedure}]\texttt{randomize\index{randomize};} Assign a new time
dependent seed to the random number generator.
\item [\texttt{procedure}]\texttt{reset\index{reset}(var f:file);} Open a file for
reading.
\item [\texttt{procedure}]\texttt{rewrite\index{rewrite}(var f :file);} Open a file
for writing.
\item [\texttt{function}]\texttt{trunc(r:real):integer;} Truncates a real to an integer.
\end{lyxlist}

\chapter{Implementation issues}

The compiler is implemented in java to ease portability between operating systems.


\section{Invoking the compiler}

The compiler is invoked with the command \label{commandline}

\begin{lyxcode}
vpc\index{vpc}~filename
\end{lyxcode}
where filename is the name of a Pascal program or unit. For example

\begin{lyxcode}
vpc~test
\end{lyxcode}
will compile the program test.pas and generate an executable file \texttt{test},
(\texttt{test.exe} under windows). 

The command \texttt{vpc} is a shell script which invokes the java runtime system
to execute a \texttt{.jar} file containing the compiler classes. Instead of
running vpc the java interpreter can be directly invoked as follows

\begin{lyxcode}
java~-jar~mmpc.jar~filename
\end{lyxcode}
The \texttt{vpc} script sets various compiler options appropriate to the operating
system being used.


\subsection{Environment variable}

The environment variable \texttt{mmpcdir\index{mmpcdir}} must be set to the
directory which contains the \texttt{mmpc\index{mmpc}.jar} file, the runtime
library \texttt{rtl.o} and the \texttt{system.pas} file.


\subsection{Compiler options}
\label{comp:opt}
The following flags\index{flags} can be supplied to the compiler :

\begin{lyxlist}{00.00.0000}
\item[\texttt{-L}] Causes a latex listing to be produced of
all files compiled. The level of detail can be controled
using the codes -L1 to -L3, otherwise the maximum detail level is used.
\item[\texttt{-OPT$n$}] Sets the optimisation level attempted.
-OPT0 is no optimisation, -OPT3 is the maximum level attempted. 
The default is -OPT1.
\item [\texttt{-Afilename\index{-Afilename}}]Defines the assembler file to be created.
In the absence of this option the assembler file is \texttt{p.asm.}
\item [\texttt{-Ddirname\index{-Ddirname}}]Defines the directory in which to find
\texttt{rtl.o} and \texttt{system.pas}.
\item [\texttt{-BOEHM}\index{-BOEHM}\index{garbage collection}\label{garbage}\label{BOEHM}]
Causes the program to be linked with the Boehm conservative garbage
collector.
\item [\texttt{-V\index{-V}}]Causes the code generator to produce a verbose diagnostic
listing to \texttt{foo.lst} when compiling \texttt{foo.pas}.
\item [\texttt{-oexefile\index{-oexefile}}]Causes the linker to output to \texttt{exefile}
instead of the default output of \texttt{p.exe.}
\item [\texttt{-U\index{-U}}]Defines whether references to external procedures in
the assembler file should be preceded by an under-bar '\_'. This is required
for the coff object format but not for elf.
\item [\texttt{-S\index{-S}}]Suppresses assembly and linking of the program. An assembler
file is still generated.
\item [\texttt{-fFORMAT\index{-fFORMAT}}]Specifies the object format to be generated
by the assembler. The object formats currently used are elf when compiling under
Unix or when compiling under windows using the cygwin version of the gcc linker,
or coff when using the djgpp version of the gcc linker. for other formats consult
the NASM documentation.
\item [\texttt{-cpuCGFLAG\index{-cpuCGFLAG}}]Specifies the code generator to be used.
Currently the code generators shown in table \ref{cgs} are supported.
\item 
\begin{table}

\caption{Code generators supported\label{cgs}}
{\centering \begin{tabular}{|c|l|}
\hline 
\texttt{CGFLAG}&
\texttt{description}\\
\hline 
\hline 
\texttt{IA\index{IA32}32}&
generates code for the Intel 486 instruction-set\\
&uses the NASM assembler\\
\hline
\texttt{Pentium\index{Pentium}}&
generates code for the Intel P6 with MMX instruction-set\\
& uses the NASM \index{NASM} assembler\\
\hline

\hline
\texttt{gnuPentium\index{Pentium}}&
generates code for the Intel P6 with MMX instruction-set\\
& using the {\tt as} \index{as} assembler in the gcc package\\
\hline
\texttt{K6\index{K6}}&
generates code for the AMD\index{AMD} K6 instruction-set, use for Athlon\\
& uses the NASM assembler\\
\hline
\texttt{P3\index{P3}}&
generates code for the Intel\index{Intel} PIII processor family\texttt{}\\
& uses the NASM assembler\\
\hline
\texttt{P4} &
generates code for the Intel PIV family and Athlon XP\\
& uses the NASM assembler\\
\hline
\texttt{AMD64} &generates code for an AMD 64 bit cpu \\
 
\hline
\end{tabular}\par}\end{table}

\end{lyxlist}

\subsection{Dependencies}

The Vector Pascal compiler depends upon a number of other utilities which are
usually pre-installed on Linux systems, and are freely available for Windows
systems.

\begin{lyxlist}{00.00.0000}
\item [NASM]The net-wide assembler. This is used to convert the output of the code
generator to linkable modules. It is freely available on the web for Windows.
For the Pentium processor it is possible to use the {\tt as} assembler instead.
\item [gcc]The GNU C Compiler, used to compile the run time library and to link modules
produced by the assembler to the run time library.
\item [java]The java virtual machine must be available to interpret the compiler.
There are number of java interpreters and just in time compilers are freely available
for Windows.
%\item [nvcc]The nvidia CUDA compiler, required if compiling for an Nvidia GPU. 
%Part of the free Nvidia toolkit download.
\end{lyxlist}


\section{Calling conventions}

Procedure parameters are passed using a modified C calling convention to facilitate
calls to external C procedures. Parameters are pushed on to the stack from right
to left. Value parameters are pushed entire onto the stack, var parameters are
pushed as addresses.


\paragraph{Example }

\begin{lyxcode}
\textrm{\texttt{\small unit~callconv;}}{\small \par}

\textrm{\texttt{\small interface}}{\small \par}

\textrm{\texttt{\small type~intarr=~array{[}1..8{]}~of~integer;}}{\small \par}

\textrm{\texttt{\small procedure~foo(var~a:intarr;~b:intarr;~c:integer);}}{\small \par}

\textrm{\texttt{\small implementation}}{\small \par}

\textrm{\texttt{\small procedure~foo(var~a:intarr;~b:intarr;~c:integer);}}{\small \par}

\textrm{\texttt{\small begin}}{\small \par}

\textrm{\texttt{\small end;}}{\small \par}

\textrm{\texttt{\small var~x,y:intarr;}}{\small \par}

\textrm{\texttt{\small begin}}{\small \par}

~\textrm{\texttt{\small ~~~~~~~foo(x,y,3);}}{\small \par}

\textrm{\texttt{\small end.}}{\small \par}
\end{lyxcode}
This would generate the following code for the procedure foo.

\begin{lyxcode}
\texttt{\footnotesize ;~procedure~generated~by~code~generator~class~ilcg.tree.PentiumCG}{\footnotesize \par}

\texttt{\footnotesize le8e68de10c5:}{\footnotesize \par}

\texttt{\footnotesize ;~~~~~~~~foo}{\footnotesize \par}

~\texttt{\footnotesize enter~~~spaceforfoo-4{*}1,1}{\footnotesize \par}

\texttt{\footnotesize ;8}{\footnotesize \par}

~\texttt{\footnotesize le8e68de118a:}{\footnotesize \par}

\texttt{\footnotesize spaceforfoo~equ~4}{\footnotesize \par}

\texttt{\footnotesize ;....~code~for~foo~goes~here}{\footnotesize \par}

\texttt{\footnotesize fooexit:}{\footnotesize \par}

\texttt{\footnotesize leave}{\footnotesize \par}

~\texttt{\footnotesize ret~0}{\footnotesize \par}
\end{lyxcode}
and the calling code is

\begin{lyxcode}
~\texttt{\footnotesize push~DWORD~~~~~~3~~~~~~~~~;~push~rightmost~argument}{\footnotesize \par}

~\texttt{\footnotesize lea~esp,{[}~~esp-32{]}~~~~~~~~;~create~space~for~the~array}{\footnotesize \par}

~\texttt{\footnotesize mov~DWORD~~{[}~~ebp~-52{]},0~~;~for~loop~to~copy~the~array}{\footnotesize \par}

~\texttt{\footnotesize le8e68de87fd:~~~~~~~~~~~~~;~the~loop~is~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~;~unrolled~twice~and}{\footnotesize \par}

~\texttt{\footnotesize cmp~DWORD~~{[}~~ebp-52{]},~7~~;~parallelised~to~copy~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~;~16~bytes~per~cycle}{\footnotesize \par}

~\texttt{\footnotesize jg~near~~le8e68de87fe}{\footnotesize \par}

~\texttt{\footnotesize mov~ebx,DWORD~~{[}~~ebp~~-52{]}}{\footnotesize \par}

~\texttt{\footnotesize imul~~~ebx,~~~~4}{\footnotesize \par}

~\texttt{\footnotesize movq~MM1,~{[}~~ebx+~le8e68dddaa2-48{]}}{\footnotesize \par}

~\texttt{\footnotesize movq~~{[}~~esp+ebx{]},MM1}{\footnotesize \par}

~\texttt{\footnotesize mov~eax,DWORD~~{[}~~ebp+~~~~~-52{]}}{\footnotesize \par}

~\texttt{\footnotesize lea~ebx,{[}~~eax+~~~~~2{]}}{\footnotesize \par}

~\texttt{\footnotesize imul~~~ebx,~~~~4}{\footnotesize \par}

~\texttt{\footnotesize movq~MM1,~{[}~~ebx+~le8e68dddaa2~-48{]}}{\footnotesize \par}

~\texttt{\footnotesize movq~~{[}~~esp+ebx{]},MM1}{\footnotesize \par}

~\texttt{\footnotesize lea~ebx,{[}~~ebp+~~~~~-52{]}}{\footnotesize \par}

~\texttt{\footnotesize add~~DWORD~~{[}~ebx{]},~~~~~4}{\footnotesize \par}

~\texttt{\footnotesize jmp~~le8e68de87fd}{\footnotesize \par}

~\texttt{\footnotesize le8e68de87fe:~~~~~~~~~~~~~~~;~end~of~array~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~copying~loop}{\footnotesize \par}

~\texttt{\footnotesize push~DWORD~~le8e68dddaa2-32~;~push~the~address~of~the~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~var~parameter}{\footnotesize \par}

~\texttt{\footnotesize EMMS~~~~~~~~~~~~~~~~~~~~~~~~;~clear~MMX~state}{\footnotesize \par}

~\texttt{\footnotesize ~call~le8e68de10c5~~~~~~~~~~;~call~the~local~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~label~for~foo}{\footnotesize \par}

~\texttt{\footnotesize add~esp,~40~~~~~~~~~~~~~~~~~;~free~space~on~the~stack}{\footnotesize \par}
\end{lyxcode}

\subsubsection{Function results}

Function results are returned in registers for scalars following the C calling
convention for the operating system on which the compiler is implemented. Records,
strings and sets are returned by the caller passing an implicit parameter containing
the address of a temporary buffer in the calling environment into which the
result can be assigned. Given the following program

\texttt{program}

\texttt{type t1= set of char;}

\texttt{var x,y:t1;}

\texttt{function bar:t1;begin bar:=y;end;}

\texttt{~}

\texttt{begin}

\texttt{~~~~~~~~x:=bar;}

\texttt{end.}

The call of bar would generate

\begin{lyxcode}
~{\footnotesize }\texttt{\footnotesize push~ebp}{\footnotesize \par}

~\texttt{\footnotesize add~~dword{[}esp{]}~,~-128~~~~~;~address~of~buffer~on~stack}{\footnotesize \par}

~\texttt{\footnotesize call~le8eb6156ca8~~~~~~~~~~;~call~bar~to~place~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~;~result~in~buffer}{\footnotesize \par}

~\texttt{\footnotesize add~esp,~4~~~~~~~~~~~~~~~~~;~discard~the~address}{\footnotesize \par}

~\texttt{\footnotesize mov~DWORD~~{[}~~ebp+~-132{]},~0;~for~loop~to~copy~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~;~the~set~16~bytes}{\footnotesize \par}

~\texttt{\footnotesize le8eb615d99f:~~~~~~~~~~~~~~;~at~a~time~into~x~using~the~}{\footnotesize \par}

~\texttt{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~;~MMX~registers}{\footnotesize \par}

~\texttt{\footnotesize cmp~DWORD~~{[}~~ebp+~~~~~-132{]},~~31}{\footnotesize \par}

~\texttt{\footnotesize jg~near~~le8eb615d9910}{\footnotesize \par}

~\texttt{\footnotesize mov~ebx,DWORD~~{[}~~ebp+~~~~~-132{]}}{\footnotesize \par}

~\texttt{\footnotesize movq~MM1,~{[}~~ebx+ebp~+~~~~~-128{]}}{\footnotesize \par}

~\texttt{\footnotesize movq~~{[}~~ebx+ebp~+~~~~~-64{]},MM1}{\footnotesize \par}

~\texttt{\footnotesize mov~eax,DWORD~~{[}~~ebp+~~~~~-132{]}}{\footnotesize \par}

~\texttt{\footnotesize lea~ebx,{[}~~eax+~~~~~8{]}}{\footnotesize \par}

~\texttt{\footnotesize movq~MM1,~{[}~~ebx+ebp~+~~~~~-128{]}}{\footnotesize \par}

~\texttt{\footnotesize movq~~{[}~~ebx+ebp~+~~~~~-64{]},MM1}{\footnotesize \par}

~\texttt{\footnotesize lea~ebx,{[}~~ebp+~~~~~-132{]}}{\footnotesize \par}

~\texttt{\footnotesize add~~DWORD~~{[}~ebx{]},~~~~~16}{\footnotesize \par}

~\texttt{\footnotesize jmp~~le8eb615d99f}{\footnotesize \par}

~\texttt{\footnotesize le8eb615d9910:}{\footnotesize \par}
\end{lyxcode}

\section{Array representation}

The maximum number of array dimensions supported in the compiler is 5.

A static\index{static} array\index{array, static} is represented simply by
the number of bytes required to store the array being allocated in the global
segment or on the stack.

A dynamic array\index{array}\index{array, dynamic} is always represented on
the heap\index{heap}. Since its rank\index{rank} is known to the compiler
what needs to be stored at run time are the bounds and the means to access it.
For simplicity we make the format of dynamic and conformant arrays the same.
Thus for schema\index{schema}  

\texttt{s(a,b,c,d:integer)= array{[}a..b,c..d{]} of integer }

whose run time bounds are evaluated to be 2..4,3..7 we would have the following
structure:

\vspace{0.2cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
address&
field&
value\\
\hline 
\hline 
x&
base of data&
address of first integer in the array\\
\hline 
x+4&
a&
2\\
\hline 
x+8&
b&
4\\
\hline 
x+12&
step&
20\\
\hline 
x+16&
c&
3\\
\hline 
x+20&
d&
7\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

The base address for a schematic array on the heap, will point at the first
byte after the array header show. For a conformant array, it will point at the
first data byte of the array or array range\index{range} being passed as a
parameter. The step field specifies the length of an element of the second dimension
in bytes. It is included to allow for the case where we have a conformant\index{conformant}
array\index{array, conformant} formal parameter 

\texttt{x:array{[}a..b:integer,c..d:integer{]} of integer}

to which we pass as actual parameter\index{parameter} the range 

\texttt{p{[}2..4,3..7{]} }

as actual parameter, where \texttt{p:array{[}1..10,1..10{]} of integer}

In this case the base address would point at @p{[}2,3{]} and the step would
be 40 - the length of 10 integers.


\subsection{Range\index{range} checking}

When arrays are indexed, the compiler plants run time checks to see if the indices
are within bounds\index{bounds}. In many cases the optimiser is able to remove
these checks, but in those cases where it is unable to do so, some performance
degradation can occur. Range checks can be disabled or enabled by the compiler
directives.

\{\$r-\} \{ disable range checks \}

\{\$r+\} \{ enable range checks \}

Performance can be further enhanced by the practice of declaring arrays to have
lower bounds of zero. The optimiser is generally able to generate more efficient
code for zero based arrays.


