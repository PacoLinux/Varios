/**
 */
package ilcg.tree;
import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.*;
import ilcg.Pascal.ProgressNotifier;
import ilcg.SymbolTable;

import ilcg.SyntaxError;

/**
 *  This class provides the generic utility methods used in all processor
 *  specific code generators which extend it. It is called walker because the
 *  code generators walk syntax trees <B><I><FONT FACE="Arial"><P>
 *
 *  Transaction mechanism</P> </B> </I> </FONT> <P>
 *
 *  The process of walking the syntax tree and matching it against the machine
 *  description may involve backtracking. This can occur when a particular goal
 *  pursued by the pattern matcher eventually fails. Whilst performing a pattern
 *  match, a stream of machine code instructions is generated, and registers are
 *  reserved. It is important that when backtracking occurs we can prevent any
 *  machine instructions that would have been generated by the failed pattern
 *  match from being copied to the output file.</P> <P>
 *
 *  This is ensured by writing all lines of assembler code to a <I>
 *  RollBackBuffer</I> , which buffers assembler programs line by line until it
 *  is flushed to an output file. The <I>RollBackBuffe</I> r can be queried as
 *  to what its current line number is using the <I>mark()</I> call.</P> <P>
 *
 *  The write point of the buffer can then be moved back to this point at a
 *  later instant by a call of rollBackTo().</P> <P>
 *
 *  Each instance of Walker contains a RollBackBuffer field <I>buf.</P> </I> <P>
 *
 *  The pattern matcher thus organises its matching into abortable transactions.
 *  Whenever it attempts to match a machine instruction against the syntax tree
 *  it starts a transaction by recording the current write point of <I>buf</I> .
 *  If the match of the instruction fails it calls <I>rollBack()</I> , a method
 *  which both rolls back the output stream and unreserves any registers.</P>
 *  <FONT FACE="Arial"><P>
 *
 *  Register reservation transactions</P> </FONT> <P>
 *
 *  Whilst matching the syntax tree it is necessary to reserve registers that
 *  currently contain the results of the pattern matched so far. However when a
 *  match fails we want to be able to unreserve all registers that were recorded
 *  since the start of the transaction. This is done by ensuring that all
 *  register reservation is done through the <I>reserve()</I> method. This not
 *  only reserves the register, it also pushes onto a datastructure called the
 *  <I>reservationStack</I> a <I>Reservation</I> object, basically a pair
 *  consisting of a line number and a register.</P> <P>
 *
 *  When the <I>rollBack</I> method is called, the <I>reservationStack</I> is
 *  popped of all registers reserved since the mark point, and all reservations
 *  of these registers are canceled.</P> <B><I><FONT FACE="Arial"><P>
 *
 *  Register Spilling</P> </B> </I> </FONT> <P>
 *
 *  When generating code we may run out of registers. It is necessary to provide
 *  a means of spilling registers that is machine independent and which fits in
 *  with the transaction mechanism outlined above.</P> <P>
 *
 *  The indended approach is to provide a <I>spill </I> method that will be
 *  called to save a register. The default spill method in the class Walker will
 *  allocate a new variable in the local stack frame for each variable to be
 *  spilled and generate a simple assignment statement to this location as an
 *  ilcg tree. This is then passed to the pattern matcher to generate machine
 *  code. For this to work we need:</P>
 *  <OL>
 *    <LI> Access to the local store allocator for the current stack frame. This
 *    can be obtained if the compiler brackets all blocks to be compiled within
 *    Block nodes which provide a pointer to the current local store allocator.
 *    The Walker can then keep a record of the LocalStoreAllocator to use when
 *    spilling.</LI>
 *    <LI> When allocating a register the Walker must actually allocate a
 *    RegisterAlias which initially points at the register but which, in the
 *    event of a spill being forced,will point at the location to which the
 *    register has been spilled.</LI>
 *    <LI> Since the spill operation itself will only have an array of Registers
 *    to work on, supplied eventually by the machine specific pattern matcher,
 *    the Registers must be aware of all aliases that currently exist.</LI>
 *    <LI> There must be a mechanism for forgetting all spills that have
 *    occurred after a given line number was output.</LI>
 *    <LI> There must be a mechanism for the matcher to check that a spill on a
 *    register aliases is unspilled before a machine instruction using that
 *    alias is sent to the RollBackBuffer.</LI>
 *  </OL>
 *
 * @author     wpc
 * @created    June 22, 2001
 */
public abstract class Walker implements Serializable
{

    /**
     * Reports on progress, used in the
     *surrounding development environment
     */
    public static ProgressNotifier notifier               = new ProgressNotifier();

    /**
     *  Controls whetherverbose debugging info output to the log file.
     */
    public  boolean verbose                         = false;
    boolean dontexceedlogmax                       = true;
    public boolean useregisteraliases 				=true;
    /**
     * number of discrete calls on codegen
     */
    public int invocations                         = 0;

    /**
     *  Flags is a hash table that contains named flags indexed on strings. The
     *  value of the flags will be of type java.lang.Integer. These may be used by
     *  a compiler to decide on a strategy for the generation of syntax trees
     */
    public Hashtable flags                         = new Hashtable();
    /**
     * The hastable ilcgTransforms holds mappings generated by any
     * automatic ilct->ilcg transform rules specified in the Ilcg for the processor.
     * It is indexed on the source ilcg node and yields a translated one
     * */
    // public Hastable<Node,Node> ilcgTransforms 		=new Hastable<Node,Node>();
    // used to store the printable results of patterns
    /**
     *  this stack stores Reservation objects to provide a rollback mechanism for
     *  register reservationh
     */
    public Stack reservationStack                  = new Stack();

    /**
     *  Last line of source processed
     */
    public int lastLine                            = 0;
    // Hashtable reservationSet=new Hashtable();
    /**
     *  set of all registers
     */
    public MyRegSet registerSet                       = new MyRegSet();//MyHashSet();

    /**
     * The minimum number of registers to be reserved from pre allocation
     *by the sub expression optimiser
     */
    int minimumFreeRegisters                       = 3;

    /**
     * if true we reserve a register during the process of loading it
     */
    boolean prereserve                             = false;

    /**
     *  Description of the Field
     */
    public Dictionary registerIndex                = new Hashtable();

    /**
     *  Current spill allocator used to allocate storage for register spills
     */
    public LocalStoreAllocator currentSpills       = newAllocator();
    String undefined                               = "  u n d e f ";
    SymbolTable names                              = new SymbolTable(new Hashtable());
    /**
     * The register to be used as the frame pointer, must be overidden in
     *actual code generators
     */
    Register regFP                                 = new Register("FP", "word", true, 0);
    Node matchedTree;        // used to store matched sub trees
    String matchedAssembler; // used to store the equivalent assembler
    Node   transformedMatchedTree;// used to store the transformed version of the matched tree if it exists
    /** specifies is the processor supports gather instructions */
    public boolean hasGather =false;
    /**
     *  holds how much the stack pointer has been changed by when params are pushed
     */
    int spchange                                   = 0;

    // index all registers by name
    public RollBackBuffer buf                             = new RollBackBuffer();
    transient PrintWriter logfile;
    // transient String[] logvec = new String[logmax];
    // this holds the current parameters used by the pattern matcher
    // the first row holds the trees matched by parameters
    // the second row holds the assembler strings they translate to

    Object[][] bindings                            = {{null}, {""},{null}};
    int asfinallymatched							=0;
    int beforematching								=2;
    int asoutput									=1;
    int[]prebindings							   = {};
    String[] recTrace                              = new String[recmax + 2];
    Register FP, SP;

    /**
     *  flag to control degree of loading into registers
     */
    boolean tryHalfLoad                            = true;
    Hashtable typerenametab                        = new Hashtable();
    String commentprefix			       = "; #";
    String pad                                     = "";
    int logged                                     = 0;
    int recsp                                      = 0;
    int patternrecsp                               = 0;
    int assigninc                                  = 100;
    int dyadicinc                                  = 10000;
    boolean leftright                              = true;
    public void printcomment(String s)
    {
        buf.writeln(commentprefix+s);
        if(verbose)log(s);
    }
    /**
     * the number of matches we will try before failing. This figure is adjusted as the algorithm runs. It is initialised
     *to a billion so that it is not a serious limit at the start
     */
    int matchbudget                                = 100000000;
    Calendar thecalendar						=Calendar.getInstance();
    long whenmatchingmuststopMillis				=System.currentTimeMillis()+600000;//{ allow ten mins }
    long trialmatchinMillis						= 4000; //{ 4 seconds }
    /** If ignore past failures is true then the matcher ignores the hints in its boundedhint tables
            which it will otherwise use to prevent it trying to match a tree that is similar to one
            that previously failed */
    boolean ignorepastfailures 		       =true;
    /**
     * the number of chars in the string representation of an expression above which it
     *will be split up and the left and right sides assigned to temporaries.
     *This is not strictly necessary but it is done to acclerate matching in the
     *machine specific code generators which typically grows non-linearly with
     *expression length.
     */
    int maxExpLen                                  = 2000;


    /**
     *  common sub expressions in a statement are put into a single register
     */
    public final static int subExpressionOptimise  = 1;
    /**
    *  loop invariants moved out of the loop
    */
    public final static int removeloopinvariants =2;
    /**
     *  Loops are unrolled up to some unroll limit
     */

    public final static int unrollLoops  = 4;
    /**
     *  any variables declared local to a statement will be place in registers
     */
    public final static int cacheLocals            = 8;

    public final static int tryAlternatives        = 16;

    /**
     * controls level of optimisation
     */
    public static int optimisationLevel            = subExpressionOptimise;

    /**
     *  the following keeps track of whether we are in an assignment context
     */
    Stack assignmentContext                        = new Stack();

    // Stack lastTime = new Stack();
    /*
     *  Description of the Field
     */
    public static boolean
    leftToRight              = true,
    spillingOn              = false,
    shortcut              = true;

    /**
     *  Description of the Field : the prefix is normally blank but for .coff format it is "_"
     */
    public static String procprefix                = "";

    /**
     * max number of lines allowed in log file
     */
    final static int logmax                        = 1400000;

    /**
     * max allowed recursion depth
     */
    final static int recmax                        = 100;
    // used as a memo table by codegen
    public Hashtable exactmatch                           = new Hashtable();

    /**
     * if true print out line number before code generating a statement
     */
    public static boolean linecount                = false;
    /**
     *  Description of the Field
     */
    public static int switchon                     = java.lang.Integer.MAX_VALUE - 2;
    /**
     *  Description of the Field
     */
    public static int switchoff                    = java.lang.Integer.MAX_VALUE;

    int stats                                      = 0;

    /**
     * This stores the result of the last switchtable record made
     *by method record(), it is useful when performing optimised
     *matching of instructions to ilcg trees
     */
    int recordedswitch                             = 0;
    Hashtable recordedtable                        = null;
    BigInteger reservationhash                     = BigInteger.ZERO;
    int ressp                                      = 0;
    int hashmod                                    = 10000;

    boolean canoptimise                            = true;


    /**
     *  Constructor for the Walker object
     */
    public Walker()
    {
        try
            {
                logfile = new PrintWriter(new FileOutputStream("listing.txt"));
            }
        catch(IOException e)
            {
                logfile = new PrintWriter(System.out);
            }
        logged = 0;
        buf = new RollBackBuffer();
        // logvec = new String[logmax];
    }


    void notify(int l)
    {
        notifier.done("generated", l);
    }


    /**
     * set an optimisation level between 0 and 7
     *
     * @param  L  The new optimisationLevel value
     */
    public void setOptimisationLevel(int L)
    {
        optimisationLevel = L;
    }


    /**
     * cause the assembler to define a symbol , the default version uses nasm syntax you
     *should override for other assemblers
     *
     * @param  symbol  Description of the Parameter
     */
    public void defineSymbol(String symbol)
    {
        buf.writeln("%define " + symbol + " ; defined by walker");
    }


    /**
     *  Use this to select which register to use as the stack pointer
     *
     * @param  sp  The new sP value
     */
    public void setSP(Register sp)
    {
        SP = sp;
    }


    /**
     *  Use this to select which register to use as the frame pointer
     *
     * @param  fp  The new fP value
     */
    public void setFP(Register fp)
    {
        FP = fp;
    }

/** True if the processor ABI supports call by register */
	public boolean ABIsupportsCallByRegister(){return false;}
	/** returns the ith parameter register of given format **/
public	Register ithParamOfFormat(int i,String format){return null; } // override on processors which do support it
	                                                         // if they dont support it this should never be called
    /**
     * Returns the name of the processor
     *
     * @return    Description of the Return Value
     */
    public String getprocessorname()
    {
        String[] comp  = getClass().toString().split("\\W");
        String last    = comp[comp.length - 1];
        return last.substring(0, last.length() - 2);
    }


    /**
     *  define the file to which debugging info is written
     *
     * @param  lf  The new logfile value
     */
    public void setLogfile(PrintWriter lf)
    {
        logfile = lf;// logvec = new String[logmax];
        logged = 0;
    }


    /**
     *  Gets the logFile attribute of the Walker object
     *
     * @return    The logFile value
     */
    public PrintWriter getLogFile()
    {
        return logfile;
    }


    /**
     *  override in subclass for non 32 bit processor
     *
     * @return    The addressLenInBytes value
     */
    public int getAddressLenInBytes()
    {
        return 4;
    }


    /**
     *  determines if a type is a basic format or a more closely specified type *
     *
     * @param  t  Description of Parameter
     * @return    The format value
     */
    public boolean isFormat(String t)
    {
        return t == Node.octet || t == Node.word || t == Node.halfword
               || t == Node.doubleword || t == Node.quadword;
    }


    /**
     *  return the type used as addresses on a CPU, assume 32 bit unsigned int as
     *  default
     *
     * @return    The addressType value
     */
    public String getAddressType()
    {
        return Node.int32;
    }


    /**
     *  return the stack pointer
     *
     * @return    The sP value
     */
    public Register getSP()
    {
        return SP;
    }


    /**
     *  Tree builders can use this to generate expressions accessing local vars
     *
     * @return    The fP value
     */
    public Register getFP()
    {
        return FP;
    }


    /**
     * check if the list of strings contains a label
     *
     * @param  l  Description of the Parameter
     * @return    Description of the Return Value
     */
    boolean nolabelsin(String[] l)
    {
        for(int i = 0; i < l.length; i++)
            {
                if(islabeled(l[i].trim()))
                    {
                        return false;
                    }
            }
        return true;
    }


    /**
     * Test if an assembler line starts with a label, overide if this is
     *not an adequate test
     *
     * @param  s  Description of the Parameter
     * @return    Description of the Return Value
     */
    boolean islabeled(String s)
    {
        return (s.indexOf("label") > 0) || (s.startsWith("label"));
    }


    /**
     *  cast to a ref address
     *
     * @param  n              Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    public Node refaddr(Node n)
    throws Exception
    {
        // cast n to a ref address
        String t  = getAddressType();
        return new Cast("ref " + t, n);
    }


    /**
     *  cast to an address
     *
     * @param  n              Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    public Node addr(Node n)
    throws Exception
    {
        if(n instanceof Register)
            return forcederef(refaddr(n), getAddressType());
        return n;
    }


    /**
     *  create a new temporary variable
     *
     * @param  sizeinBytes    Description of Parameter
     * @param  type           Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    public Memref newTemp(int sizeinBytes, String type)
    throws Exception
    {
        return new Memref(
                   new Dyad(new Int(currentSpills.alloc(sizeinBytes, sizeinBytes)),
                            addr(currentBase==null?  FP:currentBase),  // Op.sum(getAddressType(), getAddressType(), getAddressType())
                            "+"),
                   type);
    }

    /**
     *  define how a given type is to be printed out in the assembler since a given
     *  assembler may use different terminaology depending on word size etc
     *
     * @param  ilcgname  Description of Parameter
     * @param  asmname   Description of Parameter
     */
    public void typerename(String ilcgname, String asmname)
    {
        typerenametab.put(ilcgname, asmname);
    }


    /**
     *  This is used by the code generator to map ilcg types to assembler types. It
     *  must previously have set up an association by calling typerename
     *
     * @param  ilcgType  Description of Parameter
     * @return           Description of the Returned Value
     */
    public String type2Assembler(String ilcgType)
    {
        try
            {
                Object associated  = typerenametab.get(ilcgType);
                if(associated != null)
                    {
                        return associated.toString();
                    }
                if(ilcgType.startsWith("ref "))
                    {
                        return type2Assembler(ilcgType.substring(4));
                    }
                return ilcgType;
            }
        catch(Exception e)
            {
                log("Error in type2Assembler "+e);
                return ilcgType;
            }
    }


    /**
     *  The direction that the stack grows when a value is pushed. It must take on
     *  the values +1 or -1.
     *
     * @return    Description of the Returned Value
     */
    public int stackDirection()
    {
        return -1;
    }


    /**
     *  Creates a store allocator for the machine in question with the appropriate
     *  stack direction and initial offset from fp for local variables
     *
     * @return    Description of the Returned Value
     */
    public LocalStoreAllocator newAllocator()
    {
        return new LocalStoreAllocator(stackDirection(), 0);
    }


    /**
     *  Description of the Method
     *
     * @param  prereserved  Description of Parameter
     * @return              Description of the Returned Value
     */
    public LocalStoreAllocator newAllocator(int prereserved)
    {
        return new LocalStoreAllocator(stackDirection(), prereserved);
    }


    /**
     *  Returns an allocator for parameters ( with offsets in the opposite
     *  direction ) if isparam is true.
     *
     * @param  prereserved  reserved for call frame
     * @param  isparam      true if Parameter allocation
     * @return              Description of the Returned Value
     */
    public LocalStoreAllocator newAllocator(int prereserved, boolean isparam)
    {
        if(isparam)
            {
                return new LocalStoreAllocator(stackDirection() * -1, prereserved);
            }
        return newAllocator(prereserved);
    }


    /**
     *  write the assembler code to the PrintWriter
     *
     * @param  s  Description of Parameter
     */
    public void flush(PrintWriter s)
    {
        buf.flush(s);
    }


    /**
     *  Description of the Method
     */
    public void flushlog()
    {
        int i;
        logfile.println("Debug log from code generator " + getClass()+
                        "\noptimisation level ="+optimisationLevel
                        +"\n For .optimiseon ="+For.optimiseon
                        +"\n For .loopunroll ="+For.loopunroll
                        +"\n Ilcg transforms of for loops="+transformationEnabled);
        /*
         *  if (logged > logmax) {
         *  for (i = 0; i < logmax; i++) {
         *  logfile.println(logvec[(logged + i) % logmax]);
         *  }
         *  }
         *  else {
         *  for (i = 0; i < logged; i++) {
         *  logfile.println(logvec[i]);
         *  }
         *  }
         */
        logfile.close();
    }


    /**
     * This version of match is the logical interface used by the
     *code generator, it calls innermatch, which handles the
     *process of finding an optimised match. match can be overridden
     *in the hand written part of the code generator enabling the
     *hand written sub-class of the automatically written code generator
     *to call back on the automatic portion. This can be useful if
     *one wants to put in machine specific strategies for pattern
     *matching.
     *
     * @param  n              Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    public boolean match(Node n)
    throws Exception
    {
        try
            {
                return innermatch(n);
            }
        catch(Exception ex)
            {
                dlog(" in match " + ex);
                throw ex;
            }
    }


    /**
     *  This calls the machine specific matcher to perform matching on
     *an ilcg tree. If the flag tryAlternatives is set, it attempts
     *an optimised match.
     *
     * @param  n              tree to be matched.
     * @return                true if matched ok
     * @exception  Exception  Description of the Exception
     */
    boolean innermatch(Node n)
    throws Exception
    {
        if(invocations > matchbudget||timexpired())
            {
                if(verbose)
                    {
                        dlog("fail budget out ");
                        if(timexpired())
                            dlog("took too long in real time");
                        System.out.print("innermatch fails budget out" + invocations);
                    }
                return false;
            }
        invocations++;
        if((tryAlternatives & optimisationLevel) == tryAlternatives)
            {
                int mark                     = buf.mark();
                int oldinvocations           = invocations;
                int oldbudget                = matchbudget;
                boolean res                  = match(n, false, 0);
                int firstattemptInvocations  = invocations - oldinvocations;
                int quota                    = firstattemptInvocations + 880;
                if(!res)
                    {
                        // the code was unmatchable
                        return false;
                    }
                // store the first attempt
                String[] bestattempt         = buf.sequester(mark);
                int lastpos                  = recordedswitch;
                int bestpos                  = lastpos;
                Hashtable lasttab            = recordedtable;
                try
                    {
                        int count  = 1;
                        int x      = 2;
                        // try at most x alternatives with an effort of quota on each
                        matchbudget = invocations + quota;
                        while(count < x && match(n, true, lastpos + 1))
                            {
                                count++;
                                matchbudget = invocations + quota;
                                lastpos = recordedswitch;
                                String[] secondattempt  = buf.sequester(mark);
                                if(secondattempt.length < bestattempt.length)
                                    {
                                        bestattempt = secondattempt;
                                        bestpos = lastpos;
                                    }
                            }
                    }
                catch(Exception ex)
                    {
                        if(verbose)
                            {
                                dlog("second attempt failed " + ex);
                            }
                    }
                // use the first result
                matchbudget = oldbudget;
                return match(n, true, bestpos);
            }
        return match(n, false, 0);
    }


    /**
     * this is the version of match which is overridden by automaticly produced code generators.
     *if restart is true, it forces search to start at startpoint in the
     *list of alternatives
     *
     * @param  n              Description of the Parameter
     * @param  restart        Description of the Parameter
     * @param  startpoint     Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    public boolean match(Node n, boolean restart, int startpoint)
    throws Exception
    {
        return false;
    }


    /**
     *  calls the symbolic evaluator on code, this will have a side effect of
     *reordeing all expression trees to minimise register use
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public Node optimize(Node n)
    {
        return n.eval();
    }


    /**
     *  forces a variable to be derefed to the target type
     *
     * @param  n              Description of Parameter
     * @param  targetType     Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    public Node forcederef(Node n, String targetType)
    throws Exception
    {
        String rt  = n.returnType();
        if(verbose)
            {
                log(" forcederef " + n + " to " + targetType);
            }
        if(typecompatiblewith(n, targetType))
            {
                return n;
            }
        if(!rt.startsWith("ref"))
            {
                throw new Exception("type mismatch " + rt + "," + targetType);
            }
        return
            forcederef(new Deref(n), targetType);
    }


    /**
     *  Description of the Method
     */
    public void listmatches()
    {
        for(Enumeration e = exactmatch.keys(); e.hasMoreElements();)
            {
                System.out.println(e.nextElement());
            }
    }


    /**
     *  Attempts code generation of a node checking if we have done it exactly before
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public boolean codeGen(Node n)
    {
        boolean res                = false;
        try
            {
                if (verbose)dlog("start codegen");
                String oldpad              = pad;
                pad = pad + " ";
                if((invocations > matchbudget)||timexpired())
                    {
                        if(verbose)
                            {
                                if( timexpired())
                                    {
                                        dlog("ran out of matching time");
                                        if(verbose)System.out.println("ran out of matching time");
                                    }
                                else
                                    {
                                        dlog(
                                            "budget ran out,budget=" + matchbudget
                                            + " invocations =" + invocations+
                                            "\n for "+n);
                                        if(verbose)System.out.println(
                                                "budget out on " + n + " budget=" + matchbudget);
                                    }
                            }
                        return false;
                    }
                invocations++;
                // increase the padding on the start of lines of the log file
                // used for debugging
                if(n == null)
                    {
                        return true;
                    }
                String trace="";
                if(n instanceof Statement) trace="Statement"+n.hashCode();
                else
                    trace = n.toString();
                if(recursing(trace, recsp - 1))
                    {
                        if(verbose)
                            {
                                log("failed because of recursion on " + trace);
                            }
                        return false;
                    }
                recTrace[recsp] = trace;
                // recsp++;
                int m                      = buf.mark();
                String exactsig            = trace;
                exactsig = trace + hashReservations()
                           + (16 * currentSpills.getLimit() + optimisationLevel);
                Object lasttime            = exactmatch.get(exactsig);
                boolean havematchedbefore  = lasttime != null
                                             && lasttime instanceof String[]&& !(n instanceof Statement);
                if(!havematchedbefore)
                    {
                        int limit = currentSpills.getLimit();
                        res = codegen(n);
                        if(!res)
                            {
                                rollBack(m);
                            }
                        String[] assembleroutput;
                        if(res)
                            {
                                assembleroutput = buf.sequester(m);
                                buf.append(assembleroutput);
                                // we dont store statements in the cache
                                // as they recursively define the whole
                                // program and we dont want masses of
                                // copies in the cache doing nothing
                                if(!(n instanceof Statement) && !(n instanceof Block))
                                    {
                                        if(nolabelsin(assembleroutput))
                                            {
                                                exactmatch.put(exactsig, assembleroutput);
                                            }
                                    }
                            }
                        // recsp--;
                    }
                else
                    {
                        res = true;
                        if(verbose)
                            {
                                log("exact match found for " + trace);
                            }
                        buf.append((String[]) lasttime);
                    }
                pad = oldpad;
                // return it to its old level
            }
        catch(Exception eee)
            {
                log("failed because " + eee);
                // eee.printStackTrace();
                return false;
            }
        return res;
    }


    /**
     * test if it is possible to code generate node n
     *
     * @param  n  Description of the Parameter
     * @return    Description of the Return Value
     */
    public boolean generateable(Node n)
    {
        int m        = buf.mark();
        int limit = currentSpills.getLimit();
        long save=whenmatchingmuststopMillis;
        setdeadline(trialmatchinMillis);
        if(verbose)System.out.println("try to generate:"+n);
        boolean res  = codeGen(n );
        whenmatchingmuststopMillis=save;
        if(verbose)log("generateable returns "+res);
        rollBack(m);
        return res;
    }
    public void setdeadline(long millis)
    {
        if(verbose)System.out.println("deadline set for "+(millis/1000.0)+"seconds");
        whenmatchingmuststopMillis=System.currentTimeMillis()+ millis;
    }
    public long timeleft()
    {
        return whenmatchingmuststopMillis-System.currentTimeMillis();
    }
    boolean timexpired()
    {
        return timeleft()<=0;
    }
    /**
     *  Invoke the linker on a file. Must be overriden to specify what linker to
     *  use.
     *
     * @param  infile  Description of Parameter
     * @param  ofile   Description of Parameter
     * @return         Description of the Returned Value
     */
    public boolean link(String infile, String ofile)
    {
        return false;
    }


    /**
     *This returns the string used to declare a variable as global.
     *It should be overridden if the chosen assembler uses a different directive
     *
     * @return    Description of the Return Value
     */
    public String globalDirective()
    {
        return "GLOBAL";
    }


    /**
     *  Description of the Method
     *
     * @return    Description of the Return Value
     */
    public String sectionDirective()
    {
        return "section";
    }



    /**
     *  Invoke the assembler on a file. May be overriden to alter what assembler
     *  to use.
     *
     * @param  infile  Description of Parameter
     * @param  ofile   Description of Parameter
     * @return         Description of the Returned Value
     */
    public  boolean assemble(String infile, String ofile)
    {
        return sassemble(infile, ofile);
    }

    /**
     *  This is the asm command that can be used by other ia32 family processors
     *
     *@param  infile  Description of Parameter
     *@param  ofile   Description of Parameter
     *@return         Description of the Returned Value
     */
    public static boolean sassemble(String infile, String ofile)
    {
        Runtime sys = Runtime.getRuntime();
        try
            {
                String com = "nasm -f" + AsmLink.objectformat + " -lasm.lst  -g -o " + ofile + " " + infile;
                System.out.println(com);
                Process p = sys.exec(com);
                StreamGobbler errorGobbler = new
                StreamGobbler(p.getErrorStream(), "ERROR");
                // any output?
                StreamGobbler outputGobbler = new
                StreamGobbler(p.getInputStream(), "OUTPUT");
                // kick them off
                errorGobbler.start();
                outputGobbler.start();
                if(p.waitFor() == 0)
                    {
                        return true;
                    }
            }
        catch(Exception ep)
            {
                System.err.println(ep);
            }
        return false;
    }

    /**
     *  You should overide in subclasses to provide actual procedure entry and exit
     *  technique for a particular processor and language the default is for a 386
     *
     * @param  p  Description of Parameter
     * @return    Description of the Returned Value
     */

    public  boolean cgProcedure(Procedure p)
    {
        currentBase=FP;
        if(p instanceof Unit)
            {
                currentBase=((Unit)p).getBase();
            }
        else if(p.lexLevel==0)
            {
                currentBase=new Label("PmainBase");
            }
        return wscgProcedure(p, this);
    }
    /**
    	 *  Description of the Method
    	 *
    	 *@param  p  procedure to generate
    	 *@param  w  pass in the actual walker used
    	 *@return    true if code generated it
    	 */
    static int suffixes=0;
    static int stacksafety = 512; // stack space to use for temporary pushes by main program
    public static boolean wscgProcedure(Procedure p, Walker w)
    {
        String name = p.name;
        String suffix= "l"+suffixes;
        suffixes++;
        if(p.isImported)
            {
                w.buf.writeln("\tEXTERN " + procprefix + name);
                if(p.lib != null)
                    {
                        w.buf.writeln("\tIMPORT " + procprefix + name + " " + p.lib);
                    }
                // this jump is needed in case we have a local label for the procedure
                // it ensures that a call to the local label is redirected to the procedure
                //buf.writeln(p.getStartAddressLabel()+":");
                //buf.writeln("\tjmp "+name);
                return true;
            }
        w.buf.writeln("section .text  "+
                      "\n; procedure generated by code generator "+w.getClass());
        if(p.isExported)
            {
                //w.buf.writeln("\tEXPORT "+procprefix+name);   // only use export for dlls
                w.exportLabel(new ExtLabel(procprefix + name));
            }
        //if(p.name=="_main")buf.writeln("..start:");
        w.buf.writeln(p.getStartAddressLabel() + ":");
        if(p.isExported)
            {
                w.buf.writeln(procprefix + name + ":");
            }
        else
            {
                w.buf.writeln(";\t " + name);
            }
        if(p instanceof Unit)
            {
                w.buf.writeln("; entering a unit at lexical level "+p.lexLevel);
                w.buf.writeln("%define definedunit$"+name+"$base");
                w.buf.writeln(name + ":");
                w.buf.writeln(" enter  0," + p.lexLevel);
            }
        else
            {
                w.buf.writeln("; entering a procedure at lexical level "+p.lexLevel);
                if(Math.abs(p.alloc.getLimit())>30000)
                    {
                        w.buf.writeln(" enter   0" +","+p.lexLevel);
                        w.buf.writeln(" sub esp,spacefor"+ p.name+suffix+"+  "+(p.lexLevel==0?stacksafety-Math.abs(p.alloc.getLimit()):0));
                        if(p.lexLevel>0&&(Math.abs(p.alloc.getLimit())>65000))
                            System.out.println(" WARNING: Procedure "+p.name+" uses "+Math.abs(p.alloc.getLimit())+
                                               " bytes of stack space for variables\n this can cause non-deterministic "+
                                               " segment access violations on the stack on some operating systems."+
                                               " It would be a good idea to reduce this by puting large arrays on the heap\n"+
                                               " and initialising them with new(p) ");
                    }
                else   w.buf.writeln(" enter spacefor"+p.name+suffix + "-4*" + p.lexLevel+","+p.lexLevel);
                if(p.isExported)
                    {
                        w.buf.writeln("\tpush ebx\n\tpush esi\n\tpush edi");
                    }
            }
        if(p.toCall != null)
            {
                for(int ui = 0; ui < p.toCall.length; ui++)
                    {
                        w.buf.writeln(" call unit$" + p.toCall[ui]);
                    }
                w.buf.writeln("cmp byte[" + name + "ready],1\n jnz " + name + "init\n jmp " + name+suffix + "exit");
                w.buf.writeln(name + "init:mov byte[" + name + "ready],1");
            }
        boolean res = w.codegen(new Block(p.getSubtree(), p.alloc));
        w.buf.writeln("spacefor" + p.name +suffix+ " equ " + Math.abs(p.alloc.getLimit()));
        w.buf.writeln(name+suffix + "exit:");
        if(p.isExported)
            {
                w.buf.writeln("\tpop edi\n\tpop esi\n\tpop ebx");
            }
        w.buf.writeln("leave\n ret " + (p.calleePopsArgs ? p.paramspace : 0));
        if(p instanceof Unit)
            {
                // plant the data decls for the unit
                w.buf.writeln("\tSECTION .bss");
                w.buf.writeln("\talignb 16");
                w.buf.writeln("resb spacefor" + p.name+suffix);
                w.buf.writeln("\talignb 16");
                w.buf.writeln(((Unit) p).getBase()+":");
                //	w.codeGen(((Unit) p).getBase());
            }
        else if(p.lexLevel==0)
            {
                // plant the data decls for the unit
                w.buf.writeln("\tSECTION .bss");
                w.buf.writeln("\talignb 16");
                w.buf.writeln("resb spacefor" + p.name+suffix);
                w.buf.writeln("\talignb 16");
                w.buf.writeln("PmainBase:");
            }
        if(p.toCall != null)
            {
                w.buf.writeln("\tSECTION .data");
                w.buf.writeln(name + "ready dd 0");
            }
        return res;
    }


    /**
     *  Returns the node containing a function return value of the appropriate type
     *  specified by t
     *
     * @param  t  Description of Parameter
     * @return    Description of the Returned Value
     */
    public abstract Node functionRetReg(String t);


    /**
     *  Code generates function return code
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public abstract boolean cgReturn(Return n);


    /**
     *  Code generates procedure application, must be overridden in supplied sub
     *  class
     *
     * @param  d  Description of Parameter
     * @return    Description of the Returned Value
     */
    public abstract boolean cgApply(Monad d);


    /**
     *  Code generates statements can be overridden in user supplie sub class.
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */

    public boolean cgStatement(Node n)
    {
        boolean yes  = true;
        int resmark = ressp;
        while(yes)
            {
                // do statements  non recursively
                resmark=ressp;
                Statement s  = (Statement) n;
                if(s.line >= 0)
                    {
                        lastLine = s.line;
                        verbose = (lastLine >= switchon) && (lastLine <= switchoff);
                        buf.writeln(commentprefix + lastLine);
                        if(verbose || linecount)
                            {
                                System.out.println(lastLine);
                            }
                    }
                try
                    {
                        Node act    = s.action;
                        Register r  = null;
                        boolean ok  = false;
                        if(verbose)
                            log(
                                "cgstatement optlevel=" + optimisationLevel + ":"
                                + act + "\n has local=" + s.hasLocal());
                        if(s.hasLocal()
                                && (cacheLocals== (cacheLocals & optimisationLevel))
                                && !(countlocals(s.action) > 1)
                                &&(!temps.contains(s.getLocal().toString()))
                          )
                            {
                                Memref i       = s.getLocal();
                                temps.add(i.toString());
                                String refvrt  = i.returnType();
                                try
                                    {
                                        r = findFreeReg(refvrt);
                                        if(verbose)
                                            {
                                                printcomment("substitute local variable " + i);
                                                log(" found in cgStatement " + r);
                                            }
                                        int stillfree  = stillFree(refvrt);
                                        if(r == null || (stillfree <= minimumFreeRegisters)||((stillfree-1)<s.weight()))
                                            {
                                                if(verbose && r != null)
                                                    {
                                                        printcomment(
                                                            "not enough free regs " + stillfree
                                                            + "<=" + minimumFreeRegisters+" or weight"+s.weight());
                                                    }
                                                printcomment("; # try to substitute in " + i + ":" + refvrt);
                                                printcomment(
                                                    ";  # but dont use, not enough free regs "
                                                    + stillfree + "<= minimum free ("
                                                    + minimumFreeRegisters +") or "
                                                    + (stillfree-1) +"< weight("+s.weight()+") or r==null (" +(r==null)+")");
                                                ok = codeGen(act);
                                            }
                                        else
                                            {
                                                if(verbose && r != null)
                                                    log(" enough free regs " + stillfree + "<="
                                                        + minimumFreeRegisters);
                                                if(verbose)log("perform substitution " + i + "<-" + r);
                                                Node sact        = ExpressionSubstituter.substituteAwithBinC(
                                                                       i, new Cast(refvrt, r), act);
                                                if(verbose)log("->" + sact);
                                                reserve(r);
                                                int start        = buf.mark();
                                                printcomment("; #substitute in " + i + ":" + refvrt
                                                             + "\n; # use register " + r);
                                                int oldbudget=matchbudget;
                                                // we allow an amount of effort proportional to the expression complexity
                                                matchbudget = invocations + (int)(sact.toString().length())+950;
                                                long save=whenmatchingmuststopMillis;
                                                setdeadline(matchbudget);
                                                try
                                                    {
                                                        ok = codeGen(sact);
                                                    }
                                                catch(Exception ee)
                                                    {
                                                        if(verbose) log("; #code generation with subsitution failed with exception "+ee);
                                                        ok=false;
                                                    }
                                                if(!ok)
                                                    {
                                                        if(verbose)printcomment("; #code generation with subsitution failed");
                                                        rollBackReservations(resmark);
                                                    }
                                                matchbudget = oldbudget;
                                                whenmatchingmuststopMillis=save;
                                                boolean firstok  = ok;
                                                unreserve(r);
                                                if(!ok)
                                                    {
                                                        buf.writeln(
                                                            "; #code generation with subsitution failed");
                                                    }
                                                if(!ok)
                                                    {
                                                        ok = codeGen(act);
                                                    }
                                                if(ok && firstok && tryAlternatives ==(tryAlternatives & optimisationLevel))
                                                    {
                                                        String[] first   = buf.sequester(start);
                                                        boolean ok2      = codeGen(act);
                                                        String[] second  = buf.sequester(start);
                                                        if(first.length < second.length)
                                                            {
                                                                buf.append(first);
                                                            }
                                                        else
                                                            buf.append(second);
                                                    }
                                            }
                                        if(verbose)
                                            {
                                                log("codegenerated action");
                                            }
                                    }
                                catch(Exception en)
                                    {
                                        dlog("substitution fails" + en);
                                        if(verbose)printcomment("substitution failed and raised exception");
                                        ok = codeGen(act);
                                    }
                                temps.remove(i.toString());
                            }
                        else
                            {
                                ok = codeGen(act);
                            }
                        if(!ok)
                            {
                                rollBackReservations(resmark);
                                return false;
                            }
                        if(s.next instanceof Statement&& !s.hasLocal())// only iterate for statements without locals
                            // this is to ensure that reservation stack is handled correctly for nested local variables
                            // so those must be done recursively
                            {
                                n = s.next;
                            }
                        else     // we must do it recursively as it has locals
                            {
                                boolean laststatementmatches= codeGen(s.next);
                                rollBackReservations(resmark);
                                stats++;
                                if(s.line > 0)
                                    {
                                        notify(s.line);
                                    }
                                if((stats % 10) == 0)
                                    {
                                        if(s.line > 0)
                                            {
                                                System.out.print(".");
                                            }
                                    }
                                return laststatementmatches;
                            }
                        rollBackReservations(resmark);
                    }
                catch(Exception a)
                    {
                        dlog("in cgStatement " + a);
                        return false;
                    }
            }
        return true;
    }




    /**
     *  this simply prints "extern l", this should be over ridden if the syntax
     *  differs
     *
     * @param  l  Description of Parameter
     * @return    Description of the Returned Value
     */
    public boolean cgImplabel(ImpLabel l)
    {
        String defined  = "defined" + l.getLab();
        buf.writeln(directivePrefix() + "ifndef " + defined);
        defineSymbol(defined);
        buf.writeln(externDirective() + "\t " + l.getLab());
        buf.writeln(directivePrefix() + "endif");
        return true;
    }


    /**
     *  This plants in the assembler the info needed to export a label. This simply
     *  writes Global l for the default case. Override if this is the wrong
     *  assembler syntax.
     *
     * @param  l  Description of Parameter
     */
    public void exportLabel(Label l)
    {
        buf.writeln("\t" + globalDirective() + " " + l);
    }


    /**
     *  Description of the Method
     *
     * @return    Description of the Return Value
     */
    public String directivePrefix()
    {
        return "%";
    }
    /**
    	 *
    	 *
    	 * @return   any prelude required for an assembler file
    	 */
    public String prelude()
    {
        return "";
    }

    /**
     *
     *
     * @return    name of the file containing macros used by code generator
     */
    public String macrofile()
    {
        return "macros.asm";
    }
    /** returns the assembler directive to generate 64 bit code if needed othewise null */
    public String bits()
    {
        return "";
    }

    /**
     *
     *
     * @return    syntax of the external directive
     */
    public String externDirective()
    {
        return "EXTERN";
    }


    /**
     *  This is the default code generator for control statements. It can be
     *  overriden by user defined classes but this is not required.
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public boolean cgControl(Node n)
    {
        if(verbose)log("cgControl "+n);
        try
            {
                if(!((Control) n).isSimple())
                    {
                        String oldn  = n.toString();
                        if(verbose)
                            {
                                log("simplify " + oldn);
                            }
                        n = ((Control) n).simplify().eval();
                        String newn  = n.toString();
                        if(verbose)
                            {
                                log("simplified to " + newn);
                            }
                        if(newn.equals(oldn))
                            {
                                log("simplification failed ");
                                return false;
                            }
                        return codeGen(n);
                    }
                if(match(n))
                    {
                        String temp  = defprintproc();
                        buf.writeln(temp);
                        dlog(n + "\n\t->" + temp + " ok");
                        return true;
                    }
            }
        catch(Exception e1)
            {
                dlog("error " + e1);
            }
        return false;
    }


    /**
     *  Description of the Method
     *
     * @param  bytes  Description of the Parameter
     */
    public void reservebytes(int bytes)
    {
        buf.writeln(" times " + bytes + "  db ' '");
    }


    /**
     *  Code generates blocks can be overridden in user supplie sub class.
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public boolean cgBlock(Node n)
    {
        LocalStoreAllocator old  = currentSpills;
        currentSpills = ((Block) n).alloc;
        boolean answer           = codeGen(((Block) n).getSubtree());
        currentSpills = old;
        return answer;
    }
    Node currentBase=null;

    /**
     *  returns the assembly code associated with a given variable at present
     *
     * @param  unsigned  Description of Parameter
     * @return           Description of the Returned Value
     */

    /*
     *  String currentbindingof(String n)
     *  {
     *  /unimp("current binding of ");
     *  Object val=names.get(n);
     *  if(val==null)return "undefined var "+n;
     *  return val.toString();
     *  }
     *  ** map an unsigned type to equivalent signed type
     */
    public String typeToSigned(String unsigned)
    {
        if(unsigned.equals(Node.uint32))
            {
                return Node.int32;
            }
        if(unsigned.equals(Node.uint16))
            {
                return Node.int16;
            }
        if(unsigned.equals(Node.uint8))
            {
                return Node.int8;
            }
        if(unsigned.equals(Node.uint64))
            {
                return Node.int64;
            }
        return unsigned;
    }


    /**
     *  Spill a register
     *
     * @param  r              Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    public Node spill(Register r)
    throws Exception
    {
        if(verbose)
            {
                log("Spill " + r);
            }
        int bytes  = r.width / 8;
        Node loc   = newTemp(r.width / 8, r.returnType());
        Node val   = new Deref(r);
        Node save  = new Assign(loc, val).eval();
        if(codeGen(save))
            {
                unreserve(r);
                r.spill(loc);
            }
        return loc;
    }


    /**
     *  Description of the Method
     *
     * @param  n              Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    public Node storeinmem(Node n)
    throws Exception
    {
        Node loc   = newTemp(n.returnType());
        Node val   = n;
        Node save  = new Assign(loc, val).eval();
        if(!codeGen(save))
            {
                throw new Exception(" can not generate store of " + n);
            }
        return new Deref(loc);
    }


    /**
     * this returns either a constant or a memory reference.
     *If the value is an expression it is put into memory
     *and the deref of the memref is returned
     *
     * @param  n              Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    public Node flushtomem(Node n)
    throws Exception
    {
        if(n.knownAtCompileTime())
            {
                return n;
            }
        if(ismemderef(n))
            {
                return n;
            }
        return storeinmem(n);
    }


    /**
     *  restore a spilled register
     *
     * @param  r              Description of Parameter
     * @exception  Exception  Description of Exception
     */
    public void unspill(Register r)
    throws Exception
    {
        if(verbose)
            {
                log("unspill(" + r + ")");
            }
        Node loc   = new Memref(
            new Dyad(new Int(currentSpills.alloc(r.width / 8, r.width / 8)),
                     addr(FP),
                     Op.sum(getAddressType(), getAddressType(), getAddressType())),
            r.returnType());
        Node val   = new Deref(loc);
        Node save  = new Assign(r, val).eval();
        if(codeGen(save))
            {
            }
        else
            {
                log("Unspill failed ");
            }
    }

    // code to do with reserving registers
    // and maintaining the transactional structure
    /**
     *  rolls back the output buffer to the marked line number and unreserves all
     *  registers reserved since that line
     *
     * @param  mark  Description of Parameter
     */
    public void rollBack(int mark)
    {
        buf.rollBackTo(mark);
    }


    boolean isitaregister(Node target)
    {
        boolean isregister  = false;
        if(target instanceof Cast)
            {
                Cast c  = ((Cast) target);
                isregister = isitaregister(c.subtree);
            }
        else
            {
                isregister = target instanceof Register;
                if(isregister)
                    {
                        isregister = !((Register) target).permanentlyReserved();
                    }
            }
        return isregister;
    }
    boolean registerHasAliasOfType(Node target, String s,Register[] aliases)
    {
        s=Format.typeDeref(s);
        if(!useregisteraliases) return false;
        if(verbose)dlog("registerHasAliasOfType("+ target+","+   s+")");
        if(target instanceof Cast)
            {
                Cast c  = ((Cast) target);
                return registerHasAliasOfType(c.subtree,s,aliases);
            }
        if(target instanceof Register)
            {
                if(verbose)dlog("it is a register");
                Register r=(Register)target;
                if(r.aliases==null)
                    {
                        r.aliases= new HashMap<String,Register>();
                        Register rp=r;// parent of target
                        while(rp.getParent() != null)
                            rp =rp.getParent();
                        Iterator regs =registerSet.iterator();
                        while(regs.hasNext())
                            {
                                Object rr= regs.next();
                                if(rr instanceof Register)
                                    {
                                        Register r2= (Register)rr;
                                        Register r2p=r2;// parent of the current instance
                                        while(r2p.getParent() != null)
                                            r2p =r2p.getParent();
                                        if(rp.equals(r2p))    // they share space
                                            {
                                                String rt=Format.typeDeref(r2.returnType());
                                                r.aliases.put(rt,r2);
                                                if(verbose) dlog(" r parent ="+rp+"== r2 parent ="+r2p+" r2 type ="+rt+" want   "+s);
                                                if(rt.equals(s))
                                                    {
                                                        if(verbose)dlog("types match, but do sizes match ? "+(r.width == r2.width)+ " "+ r.width + " ,"+ r2.width);
                                                        // if of the right type for operation
                                                        if(r.width == r2.width)    // ask if they have same number of bits as target
                                                            {
                                                                aliases[0]=r2;
                                                            }
                                                    }
                                            }
                                    }
                            }
                    }
                {
                    Register alias = r.aliases.get(s);
                    if(alias== null)  return false;
                    aliases[0]=alias;
                    return true;
                }
            }
        return false;
    }

    boolean isitunreservedregister(Node target)
    {
        boolean isregister  = false;
        if(target instanceof Cast)
            {
                Cast c  = ((Cast) target);
                isregister = isitunreservedregister(c.subtree);
            }
        else
            {
                isregister = target instanceof Register;
                if(isregister)
                    {
                        isregister = !((Register) target).isReserved();
                    }
            }
        return isregister;
    }


    /**
     *  this is called to see if node can match an object. The object may be an
     *  unbound register in which case special recognition is necessary otherwise
     *  string equality of expressions is used
     *
     * @param  referedToBySymbol  Description of Parameter
     * @param  toBeMatched        Description of Parameter
     * @return                    Description of the Returned Value
     */
    public boolean treeIdenticalToOrAssignableToParam(int referedToBySymbol, Node toBeMatched)
    {
        if(verbose)
            {
                dlog(
                    "treeIdenticalOrAssignableto(referedtoby="
                    + referedToBySymbol + ",tobematched=" + toBeMatched);
            }
        if(bindings[asoutput][referedToBySymbol] == null)
            {
                if(verbose)dlog("bindings[asfinallymatched]["+referedToBySymbol+"] == null");
                return false;
            }
        Node target         = (Node) bindings[asfinallymatched][referedToBySymbol];
        String a1           = bindings[asoutput][referedToBySymbol].toString();
        String a2           = toBeMatched.toString();
        String a3           = target.toString();
        if(verbose)
            {
                dlog("is to be matched (" + a2 + ")== target " + a3);
            }
        boolean isregister  = isitaregister(target);
        Register [] aliases = {null};
        if(Assign.checkAssignComp(target.returnType(), toBeMatched.returnType())
                || Assign.checkAssignComp(target.returnType(),  new Deref(toBeMatched).returnType())
                ||(isregister &&registerHasAliasOfType(target,(toBeMatched).returnType(),aliases))
          )
            {
                if(! isregister)
                    {
                        return a2.equals(a3);
                    }
                else
                    {
                        try
                            {
                                if(verbose)
                                    {
                                        dlog("is a register  to which we wish to assign target =" + target);
                                    }
                                if(isitaregister(toBeMatched))
                                    {
                                        // we never assign a register to itself
                                        if(decast(target).equals(decast(toBeMatched)))
                                            {
                                                return true;
                                            }
                                    }
                                if(toBeMatched.returnType().startsWith("ref"))
                                    {
                                        toBeMatched = new Deref(toBeMatched);
                                    }
                                if(isitunreservedregister(target))
                                    {
                                        if(aliases[0]!=null)  // means we found a register of
                                            // different type in the same bits of cpu
                                            // use that one
                                            target=aliases[0];
                                        boolean ok  = codeGen(new Assign(target, toBeMatched));
                                        if(ok)
                                            {
                                                reserve(target);
                                            }
                                        return ok;
                                    }
                                else
                                    {
                                        dlog("it was reserved");
                                    }
                            }
                        catch(Exception e)
                            {
                                dlog("error in treeIdenticalToOrAssignableToParam"+e.toString());
                            }
                    }
            }
        if(verbose)
            {
                log("args compatible fails, isregister =" + isregister);
            }
        return false;
    }


    /**
     *  Associates the index with the string of the object in the hashtable
     *  it is used within the matcher to record which match was successful
     *  so that on subsequent matches the search process can be short circuited
     *
     * @param  t      Description of Parameter
     * @param  index  Description of Parameter
     * @param  o      Description of Parameter
     */
    public void record(Hashtable t, int index, Node o)
    {
        String status  = "";
        String k       = key(o);
        recordedswitch = index;
        recordedtable = t;
        Object ob      = t.get(k);
        if(ob == null
                || (((tryAlternatives & optimisationLevel) == tryAlternatives)
                    && index != ((Int) ob).intValue())
          )
            {
                if(verbose)
                    {
                        dlog("Record " + k + "->" + index);
                    }
                if(t != null)
                    {
                        t.put(k, new Int(index));
                    }
            }
    }


    String key(Node n)
    {
        try
            {
                return n.sig() + hashReservations()+ isItRhs();
            }
        catch(Exception e)
            {
                return n.sig()+ isItRhs();
            }
    }


    /**
     *  test what number is associated with the object, default is 0
     *
     * @param  t  Hashtable to look o up in
     * @param  o  We see if we have seen this before
     * @return    Description of the Returned Value
     */
    public int testmemo(Hashtable t, Node o)
    {
        String k  = key(o);
        Object w  = t.get(k);
        if(w == null)
            {
                if(verbose)
                    {
                        dlog(k + "-> null ");
                    }
                return 0;
            }
        if(verbose)
            {
                dlog(k + "-> alternative " + w);
            }
        return ((Int) w).intValue();
    }


    /**
     *  Gets the parallelism available on this cpu for a given type
     *
     * @param  elementType  The value type
     * @return              The parallelism value
     */
    public int getParallelism(String elementType)
    {
        return 1;
    }


    /**
     *  Gets the reserved attribute of the register
     *
     * @param  r  A register
     * @return    The reserved value
     */
    boolean isReserved(Register r)
    {
        return r.isReserved();
    }
    boolean parentIsReserved(Register r)
    {
        if(isReserved(r)) return true;
        Register rr = r.getParent();
        if(rr==null) return false;
        if(rr.equals(r)) return false;
        return parentIsReserved(rr);
    }

    /**
     *  Gets the itRhs attribute of the Walker object
     *
     * @return    The itRhs value
     */
    boolean isItRhs()
    {
        if(assignmentContext.empty())
            {
                return true;
            }
        Object c  = assignmentContext.pop();
        assignmentContext.push(c);
        return "rhs".equals(c);
    }


    /**
     *  write to the log file if verbose mode
     *
     * @param  s  Comment string for a pattern
     * @param  n  the tree it is to be matched to
     */
    void dlog(String s, Node n)
    {
        if(verbose)
            {
                log("Match " + s + " to " + n);
            }
    }


    /**
     *   write to the log file in verbose mode
     *
     * @param  s  Description of Parameter
     */
    void dlog(String s)
    {
        if(verbose)
            {
                s= s+" :[";
                for(int i=0; i<bindings[asfinallymatched].length; i++)
                    {
                        Object o=bindings[beforematching][i];
                        if(o != null)
                            {
                                if(i>0)s=s+",\t";
                                s= s+o;
                            }
                        o=bindings[asfinallymatched][i];
                        if(o != null)
                            {
                                s= s+"->"+o;
                            }
                        o=bindings[asoutput][i];
                        if(o != null)
                            {
                                s= s+"->"+o;
                            }
                    }
                s=s+"]";
                log(s);
            }
    }


    /**
     *  returns the string that was last pushed on the eval stack
     *
     * @return    Description of the Returned Value
     */
    String defprintproc()
    {
        return matchedAssembler;
    }


    /**
     *   return the currently matched assembler code
     *
     * @param  o  Description of Parameter
     * @return    Description of the Returned Value
     */
    String defprintproc(Object o)
    {
        return defprintproc();
    }


    /**
     *  get the format returned by a node
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    String returnFormat(Node n)
    {
        return typeToFormat(n.returnType());
    }


    /**
     *  return the base format of a type string ( basically a says how long the type is )
     *
     * @param  s  Description of Parameter
     * @return    Description of the Returned Value
     */
    String typeToFormat(String s)
    {
        String f  = Format.typeToFormat(s);
        dlog("type " + s + " -> format " + f);
        return f;
    }


    /**
     *  function that binds a value to the parameter, returns true if identifier
     *  unbound or, if the current value matches the newly bound value
     *
     * @param  value  Description of the Parameter
     * @param  id     Description of the Parameter
     * @return        return true if the object is bound to the identifier sucessfully
     *or if id already bound if it has this value
     */
    boolean bind(Object value, int id)
    {
        if(unbound(id))
            {
                bindings[asfinallymatched][id] = value;
                if(verbose)
                    {
                        log("key " + id + "<-" + value);
                    }
                return true;
            }
        Object val  = bindings[asfinallymatched][id];
        if(verbose)
            {
                log("key " + id + " has value " + val);
            }
        return (value.equals(val));
    }


    /**
     *  tests if anything bound to object in symbol table
     *
     * @param  o  Description of Parameter
     * @return    Description of the Returned Value
     */
    boolean unbound(int o)
    {
        Object val  = bindings[asfinallymatched][o];
        if(val == null)
            {
                return true;
            }
        return false;
    }
    boolean testiftrue(Node n)
    {
        if(verbose)dlog("testiftrue ",n);
        n=n.eval();
        if(verbose)dlog("testiftrue evaluates to ",n);
        if(!(n instanceof Number))return false;
        return ((Number)n).intValue()!=0;
    }

    /**
     *  send a string to the log file
     *
     * @param  s  Description of Parameter
     */
    public void log(String s)
    {
        try
            {
                s = s + "\t\t" + listReservations() + "\t" + recsp;
            }
        catch(Exception e)
            {
            }
        if((logged > logmax && dontexceedlogmax))
            {
                verbose = false;
                flushlog();
            }
        // logvec[logged % logmax] = pad + s;
        logfile.println(pad + s);
        logged++;
    }


    /**
     *  send message to the log file
     *
     * @param  o  the object written in text form to the log file
     */
    void log(Object o)
    {
        log(o.toString());
    }


    /**
     *  returns true of the type returned by n is the specified type
     *
     * @param  n     Description of Parameter
     * @param  type  Description of Parameter
     * @return       Description of the Returned Value
     */
    boolean matches(Node n, String type)
    {
        return returnFormat(n) == type;
    }


    /**
     *  does code generation but calls shte optimiser first
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    boolean optimizedCodeGen(Node n)
    {
        return codeGen(optimize(n));
    }


    /**
     *  code generates n and returns true if it works
     *this routine will extract frequently used sub expresssions from an assignement
     *and evaluate them before the assignement cacheing them to registers
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    boolean codegen(Node n)
    {
        if(n == null)
            {
                return true;
            }
        if(verbose)dlog("codegen ",n);
        boolean ok=false;
        if(n instanceof Assign || n instanceof If)
            {
                ok  = subexpOptimisedCodeGen(n);
            }
        else ok= unoptimisedcodegen(n);
        if(verbose &&(!ok))dlog("codegen fails for "+n);
        return ok;
    }
    boolean transformationEnabled=false;
    /** use this to switch on any transformation grammar rules in the code generator */
    public void enableTransforms()
    {
        transformationEnabled=true;
    }

    /** use this to switch off any transformation grammar rules in the code generator */
    public void disableTransforms()
    {
        transformationEnabled=false;
    }
    Set temps = new HashSet();
    int tempcount=0;
    public Node transformCodeTree(Node n)
    {
        if(transformationEnabled)
            try
                {
                    int resmark = ressp;
                    int m  = buf.mark();
                    Node modified = n.eval();
                    Node nn= transformer(modified);
                    String nns=nn.toString();
                    if(verbose)dlog("produced "+nns);
                    rollBackReservations(resmark);
                    rollBack(m);
                    return nn;
                }
            catch(Exception e)
                {
                    if(verbose)dlog("transformation failed because "+e);
                }
        return n;
    }



    /**
     * Removes loop invariant sub expressions before code generating
     *
     * @param  n              Node which must be a For
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */


    boolean cgFor(For f)	throws Exception
    {
        if(verbose) dlog("cgFor ",f);
        if(transformationEnabled)
            {
                if(verbose)printcomment("for loop handled by ilcg tranformer ");
                disableTransforms();
                Node n=transformCodeTree(f);
                if(!n.equals(f))   // was transformed we do not want to retransform the new code
                    {
                        boolean ok =unoptimisedcodegen(n);
                        enableTransforms();
                        if(ok) return ok;
                    } // we may need to transform nested loops
                enableTransforms();
            }
        Set temps = new HashSet();
        int tempcount=0;// local version just for the for loop
        Statement forholder=new Statement(f);
        For currentfor = f;
        Statement predecessors = forholder;
        Vector<Node> invs           = f.sortedLoopInvariants();
        String sofar="";
        if(verbose)
            {
                dlog("forloop written set ");
                for(Object o:f.writtenset())dlog("\t"+o);
                dlog("forloop invariants");
                for(Node n1 : invs)dlog("invariant "+n1);
            }
        if(f.callfree()&&f.optimiseon&&f.innermost()&&((optimisationLevel&removeloopinvariants)>0))
            for(Node inv:invs)
                if(tempcount<3)//only include 3
                    try
                        {
                            // perform a series of checks to see if this invariant should be kept
                            boolean invmemref  = inv instanceof Memref;
                            if(inv == null)
                                {
                                    if(verbose)dlog("no invariant in loop");
                                    continue; // no substitution possible
                                }
                            if(inv instanceof Op|| inv instanceof Control)
                                {
                                    if(verbose)dlog("invariant "+inv+" was operator or control");
                                    continue;
                                }
                            if(inv.toString().contains("rep("))
                                {
                                    if(verbose)dlog("invariant "+inv+" is a repetition operation this is not worth taking out of loop");
                                    continue;
                                }
                            if(temps.contains(inv.toString())||sofar.contains(inv.toString()))
                                {
                                    if(verbose)dlog("invariant "+inv+" already substituted");
                                    continue; // already substituted
                                }
                            Node cost=inv.getCost();
                            float icost = cost instanceof Number ? ((Number)cost).floatValue():inv.weight();
                            if(icost <1.6)
                                {
                                    if(verbose)dlog("invariant "+inv+" kept because inv cost estimate="+cost+"<1.6 it does not do enough to be worth caching");
                                    continue; // it does not do enough to be worth caching
                                }
                            if(verbose)dlog("invariant "+inv+" has cost "+icost);
                            if((invmemref && (0 == (optimisationLevel))))         // it would not go in a register so dont substitute
                                {
                                    if(verbose)dlog("invariant "+inv+" kept because it was a memory ref and cachelocals was off");
                                    continue;
                                }
                            //System.out.println("\n found replaceable invariant " + inv + "\nwith weight " + inv.weight());
                            String t           = inv.returnType();
                            Memref temp        = newTemp((invmemref?t: "ref " + t));
                            //System.out.println("temp="+temp);
                            Node substitution  = (invmemref ? (Node)temp :(Node) new Deref(temp, t));
                            if(verbose)
                                {
                                    String tag=("in loop " + f + "\n found invariant " + inv + "\nwith weight " + inv.weight() +" and cost "+icost+
                                                "\nclass of invariant was " + inv.getClass() +
                                                "\ntype was " + t + "\ntemp created was " + temp +
                                                "\nsubstitution was " + substitution);
                                    dlog(tag);
                                }
                            sofar += ("\n "+inv);
                            Node newfor        = ExpressionSubstituter.substituteAwithBinC(inv, substitution, currentfor);
                            if(!newfor.toString().contains(substitution.toString()))
                                {
                                    if (verbose)
                                        {
                                            dlog(" substitution did not change updated for loop ignore invariant ");
                                            continue;
                                        }
                                }
                            if(verbose)dlog("->"+newfor);
                            forholder.action=newfor;
                            Node dinv =inv;
                            if(inv instanceof Memref) dinv = new Deref(inv);
                            Assign initialiser=new Assign(temp,new Cast(t, dinv));
                            Statement opt      = new Statement(new Statement(
                                                                   new Statement( initialiser),
                                                                   predecessors)
                                                              );
                            if((optimisationLevel&cacheLocals)==0)   // the combination of invariant locals and cache locals
                                {
                                    // can cause registers to be over written
                                    // so only mark these as local if we are not caching locals
                                    initialiser.setInitialising();
                                    opt.setLocal(temp);
                                }
                            if(verbose)log(" invariant subsitiution creates \n"+opt+
                                               "\n substitutions so far =\n"+sofar);
                            predecessors= opt;
                            currentfor=(For)newfor;
                            temps.add(temp.toString());
                            tempcount++;
                        }
                    catch(Exception e)
                        {
                            //System.out.println("failed to handle invariant " + e);
                            dlog("failed to handle invariant " + e);
                            return cgControl(f);
                        }
                else return cgControl(f);
        forholder.action = currentfor.simplify();
        return codegen(predecessors);
    }

    /**
     *  this does the actual work of creating code for a node It causes the corresponding code
     *to be placed in the assembler output buffer
     *
     * @param  n  a tree to be code generated
     * @return    true if code generation was possible
     */
    boolean unoptimisedcodegen(Node n)
    {
        if( transformationEnabled) n=transformCodeTree(n);
        int m  = buf.mark();
        int limit = currentSpills .getLimit();
        // n=n.eval();
        if(verbose)
            {
                log("unoptimisedcodegen \n" + n);
            }
        try
            {
                if(n instanceof Location)
                    {
                        Node tree  = ((Location) n).getSubtree();
                        // check for cartesians and expand them out
                        if(tree instanceof Cast
                                && ((Cast) tree).getSubtree() instanceof Cartesian)
                            {
                                tree = ((Cast) tree).getSubtree();
                            }
                        if(tree instanceof Cartesian)
                            {
                                int i;
                                int len;
                                Cartesian c  = (Cartesian) tree;
                                len = c.argc();
                                for(i = 0; i < len; i++)
                                    {
                                        if(!(codeGen(new Location(c.argi(i)))))
                                            {
                                                return false;
                                            }
                                    }
                                return true;
                            }
                        else if(verbose)
                            {
                                log(tree.getClass());
                            }
                    }
                if(n instanceof Procedure)
                    {
                        String s= n.sig();
                        //  System.out.println("look for"+s);
                        if(exactmatch.get(s)!=null)
                            {
                                //	System.out.println("found");
                                String [] seq=(String[])exactmatch.get(s);
                                buf.append(seq);
                                return true;
                            }
                        return cgProcedure((Procedure) n);
                    }
                if(n instanceof Block)
                    {
                        return cgBlock(n);
                    }
                if(n instanceof Return)
                    {
                        return cgReturn((Return) n);
                    }
                if(n instanceof Statement)
                    {
                        return cgStatement(n.eval());
                    }
                else if(n instanceof ImpLabel)
                    {
                        return cgImplabel((ImpLabel) n);
                    }
                else if(n instanceof For)
                    {
                        if(verbose)log("found for in unoptimised codegen "+n);
                        recsp++;
                        // first try direct match incase we have a block move which will match an instruction
                        boolean matched = match(n);
                        recsp--;
                        if(matched)
                            {
                                String temp  = defprintproc();
                                buf.writeln(temp);
                                dlog(n + "\t->" + temp + " ok");
                                return true;
                            }
                        return cgFor((For)n);
                    }
                else if(n instanceof Control)
                    {
                        return cgControl(n);
                    }
                else if((n instanceof Monad)
                        && (((Monad) n).oper instanceof Function))
                    {
                        return cgApply((Monad) n);
                    }
                else if(n instanceof Assign
                        || n instanceof Label
                        || n instanceof Location
                        || n instanceof Dyad && n.toString().startsWith("PUSH"))
                    {
                        if(n instanceof Assign)
                            {
                                Assign ass = (Assign)n;
                                Node asrc = ass.src;
                                if(asrc instanceof SubField)
                                    {
                                        Register []regs = {findFreeReg(asrc.returnType())};
                                        if(regs[0]==null)
                                            {
                                                if(verbose) log("can not find free reg for asrc");
                                            }
                                        else if(loadregister(regs,asrc))
                                            {
                                                reserve(regs[0]);
                                                boolean worked= codegen(new Assign(ass.dest, new Deref(regs[0])));
                                                unreserve(regs[0]);
                                                return worked;
                                            }
                                    }
                                else
                                    {
                                        boolean isreg=isitaregister(((Assign)n).dest);
                                        boolean isinitialising=((Assign)n).initialisingassign;
                                        if(verbose)log("is an assign, isreg="+isreg+" isinitialising="+isinitialising);
                                        if(isreg&&isinitialising  )
                                            {
                                                if(verbose)log(" found to be reserved "+((Assign)n).dest);
                                                if(isReserved ((Register)((Assign)n).dest))unreserve(((Assign)n).dest);
                                                if(splitup(handlerefref((Assign) n)))
                                                    {
                                                        if(verbose)printcomment("finished initialising assign, try to reserve "+((Assign)n).dest);
                                                        reserve( ((Assign)n).dest);
                                                        return true;
                                                    }
                                                else
                                                    {
                                                        if(verbose)log(" splitup fails in initialising assign");
                                                        boolean imatched  = false;
                                                        recsp++;
                                                        imatched = match(n);
                                                        recsp--;
                                                        if(imatched)
                                                            {
                                                                if(verbose)printcomment("finished initialising assign, try to reserve "+((Assign)n).dest);
                                                                reserve( ((Assign)n).dest);
                                                                return true;
                                                            }
                                                    }
                                            }
                                        else if(splitup(handlerefref((Assign) n)))
                                            {
                                                return true;
                                            }
                                        dlog("assign fails ");
                                    }
                            }
                        if(verbose)
                            {
                                log("  match in unoptimised codegen " + n);
                            }
                        boolean matched  = false;
                        recsp++;
                        matched = match(n);
                        recsp--;
                        if(matched)
                            {
                                String temp  = defprintproc();
                                buf.writeln(temp);
                                dlog(n + "\t->" + temp + " ok");
                                return true;
                            }
                        else
                            {
                                if(n instanceof Assign)
                                    {
                                        Assign asn      = (Assign) n;
                                        Node src        = asn.src;
                                        String srctype  = src.returnType();
                                        if(Format.isVector(srctype))
                                            {
                                                return vectorAssignRewrite(asn);
                                            }
                                    }
                            }
                    }
                else if(match(n))
                    {
                        if(verbose)
                            {
                                dlog(" ok call defprintprog");
                            }
                        String temp  = defprintproc();
                        buf.writeln(temp);
                        dlog(n + "\t->" + temp + " ok");
                        // dlog("matched but not currently outputing assembler");
                        return true;
                    }
            }
        catch(Exception ex)
            {
                dlog("in unoptimisedcodegen \n" + ex.toString() + " for \n" + n);
                if(ex instanceof ClassCastException)
                    {
                        throw new Error(ex.toString());
                    }
            }
        rollBack(m);
        if(verbose)
            {
                dlog(n + "fail");
            }
        return false;
    }
    /** Over ride this function in particular code generators if the
        type has to be evaluated on a stack. This will typically apply to
        floating point types on old Intel architectures without fpu registers */
    boolean usestackfor(String type)
    {
        return false;
    }
    /** Over ride this in chips with different fpu stack depths */
    int fpustackdepth()
    {
        return 7;
    }

    Assign handlerefref(Assign a)
    {
        String st = a.src.returnType();
        String dt = a.dest.returnType();
        if(st .startsWith("ref")||dt.startsWith("ref ref"))try
                {
                    return new Assign(new Cast("ref "+getAddressType(), decast(a.dest)),new Cast(getAddressType(), decast(a.src)));
                }
            catch(Exception e)
                {
                    System.out.println(" problem with handlerefref "+e);
                }
        return a;
    }
    int[] extend(int[] arg,int to)
    {
        if(arg.length >= to) return arg;
        int[] na = new int[to];
        int i;
        for(i=0; i<arg.length; i++)na[i]=arg[i];
        return na;
    }
    /**
     * Attempts to split complex expressions into sequence of simpler ones
     *
     * @param  a  Description of the Parameter
     * @return    Description of the Return Value
     */

    boolean splitup(Assign a)
    {
        int safetylimit  = 5;
        int charlimit  = maxExpLen  ;
        try
            {
                int scharlen			= a.src.toString().length();
                int dlen            = a.dest.weight();
                String vrt;
                String refvrt       = "ref " + (vrt = a.src.returnType());
                boolean splitsrc    = false;
                int sf              = (usestackfor(vrt)?
                                       fpustackdepth():
                                       stillFree(refvrt));
                int intlimit	   ;
                // determine how many integer registers are free since this can
                // also be a constraint on whether we need to split the expression
                intlimit = stillFree("ref "+getAddressType());
                int intcode = Format.getCode(getAddressType());
                int retcode = Format.getCode(vrt);
                int limit = 1+(intcode>retcode ? intcode :retcode);
                int []slens         = extend(a.src.weights(),limit);
                int[] ws 	    =  extend(a.weights(),limit);
                int retusage = slens[retcode];
                int intusage = slens[intcode];
                if(verbose)
                    {
                        dlog("in split src retusage=" + retusage +
                             " intusage =" + intusage + " sf = "
                             + sf +"intlimit="+intlimit+
                             " scharlen="+scharlen+" charlimit="+charlimit);
                    }
                boolean src2long = scharlen>=charlimit;
                if(retusage>1&&((retusage >= (sf))  ||
                                retusage >= (safetylimit) ||
                                (intusage >=(intlimit)) ||
                                scharlen>=charlimit))
                    {
                        // catch things which might overflow the fpu stack as well with safety limit above
                        splitsrc = true;
                    }
                else if(retusage > sf)
                    {
                        if(verbose)
                            dlog("src ret weight=" + retusage + "stillfree =" + stillFree(refvrt));
                        splitsrc = totalregsoftype(refvrt) > 1;  // so we dont falsely report things to long for fpu stack
                    }
                boolean splitwhole  = ((((ws[retcode]) > safetylimit&&!Format.isInteger(vrt))||      // this only applies to fpu values
                                        (ws[retcode]) > sf)||
                                       (ws[intcode]>intlimit)
                                      )
                                      && retusage > 1;
                if(verbose)
                    dlog("splitsrc=" + splitsrc +" splitwhole=" + splitwhole);
                if(splitwhole && !splitsrc && (sf > 2))
                    {
                        // the test that sf>2 is necessary to prevent recursion
                        if(decast(a.dest.eval()) instanceof Memref)
                            {
                                Memref atemp        = newTemp(vrt);
                                Memref plaindest    = (Memref) decast(a.dest.eval());
                                Node offset         = plaindest.index;
                                Memref newdestaddr  = newTemp(offset.returnType());
                                Node newassign      = ExpressionSubstituter.substituteAwithBinC(
                                                          a.src, new Deref(atemp), a);
                                newassign = ExpressionSubstituter.substituteAwithBinC(offset,
                                            new Deref(newdestaddr), newassign);
                                Statement pair      = new Statement(
                                    new Statement(
                                        new Assign(newdestaddr, offset),
                                        new Statement(new Assign(atemp, a.src),
                                                      new Statement(newassign))));
                                if(sf>2) pair.setLocal(atemp);
                                if(verbose)
                                    {
                                        dlog("split to\n  " + pair);
                                    }
                                return codeGen(pair);
                            }
                        else
                            {
                                Memref atemp    = newTemp(vrt);
                                Statement pair  = new Statement(new Assign(atemp, a.src),
                                                                new Statement(
                                                                    new Assign((a.dest), forcederef(atemp, vrt))));
                                pair.setLocal(atemp);
                                if(verbose)
                                    {
                                        dlog("split to \n " + pair);
                                    }
                                return codeGen(pair);
                            }
                    }
                else if(splitsrc &&decast(a.src)instanceof Dyad)
                    {
                        if(sf<=2)
                            {
                                dlog("split src fails because still free <=2");
                                return false; // splitup will not work
                            }
                        Dyad d         = (Dyad)decast(a.src);
                        String right   = d.right.toString();
                        String left    = d.left.toString();
                        Node replaced  = (d.right.weight() > d.left.weight()
                                          ? d.right
                                          : d.left);
                        Memref temp    = newTemp(replaced.returnType());
                        Assign first     = new Assign(temp, replaced.eval());
                        if(verbose)
                            {
                                dlog("spliting a dyadic assign left weight=" + d.left.weight()+" right weight="+ d.right.weight());
                            }
                        try
                            {
                                Node second       = ExpressionSubstituter.substituteAwithBinC(
                                                        replaced, new Deref(temp), a);
                                if(src2long)
                                    if(!(a.toString().length() > second.toString().length()))
                                        {
                                            if(verbose)dlog("failed because new form is longer");
                                            return false;
                                        }
                                Statement pair=new Statement(new Statement(first,new Statement(second,null)));
                                //if(sf>2) pair.setLocal(temp);
                                if(verbose)
                                    {
                                        dlog("split to->"+pair);
                                    }
                                boolean ok =  codeGen(pair);
                                return ok;
                            }
                        catch(Exception ee)
                            {
                                if(verbose)
                                    {
                                        System.out.println(
                                            " while spliting and subtituting " + a
                                            + " \n got error " + ee);
                                        ee.printStackTrace();
                                    }
                            }
                    }
            }
        catch(Exception ee)
            {
                if(verbose)
                    {
                        System.out.println(
                            " while spliting " + a + " \n got error " + ee);
                        ee.printStackTrace();
                    }
            }
        return false;
    }


    /**
     * return true if an assignment is too complex to  be easily handled in registers
     *
     * @param  a              Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    boolean toolong(Assign a)
    throws Exception
    {
        int len        = a.src.weight() + a.dest.weight();
        String refvrt  = "ref " + a.src.returnType();
        if(len > 6)
            {
                return true;
            }// catch things which overflow the fpu stack
        if(len > stillFree(refvrt))
            {
                if(verbose)
                    {
                        dlog("len=" + len + "stillfree =" + stillFree(refvrt));
                    }
                return totalregsoftype(refvrt) > 1;  // so we dont falsely report things to long for fpu stack
            }
        return false;
    }


    /**
     *  Description of the Method
     *
     * @param  type           Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    public Memref newTemp(String type)
    throws Exception
    {
        return newTemp(Format.lengthInBytes(type), type);
    }

//
    /**
     * rewrite the vector assignment as a for loop
     *
     * @param  a  Description of Parameter
     * @return    Description of the Returned Value
     */
    boolean vectorAssignRewrite(Assign a)
    {
        String srctype;
        int len             = Format.getVectorTypeLength(srctype = a.src.returnType());
        String elementType  = Format.getVectorElementType(srctype);
        int replication     = getParallelism(elementType);
        if(len <= replication*2)   // only do it if there is more than
            // or failure leads to infinite recursion
            {
                replication = 1;
            }
        /*  else

          if ( ( len % replication ) != 0 )
          {
              replication = 1;
          }*/
        // handle vectors with odd number of elements
        try
            {
                Node loop  = buildLoop(a, len, replication, elementType);
                dlog("in vectorAssignRewrite" + loop);
                if(codeGen(loop))
                    {
                        return true;
                    }
                return codeGen(buildLoop(a, len, 1, elementType));
            }
        catch(Exception ee)
            {
                dlog("in vectorAssignRewrite" + ee);
                return false;
            }
    }


    /**
     *  construct loop code for a vector assignment
     *
     * @param  a              an assignment to be repeated
     * @param  len            the length of the vector over which it is to be repeated
     * @param  parfactor      parallelism supported by the machine
     * @param  elemtype       type being assigned
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    Node buildLoop(Assign a, int len, int parfactor, String elemtype)
    throws Exception
    {
        try
            {
                Memref i  = newTemp(4, "ref int32");
                if((len % parfactor)==0)
                    return new For(i, new Int(0), new Int(len - 1), new Int(parfactor),
                                   expandAction(a, i, parfactor, elemtype));
                int firstpart = (len / parfactor)*parfactor;
                return new Statement(
                           new For(i, new Int(0), new Int(firstpart - 1), new Int(parfactor),
                                   expandAction(a, i, parfactor, elemtype)),
                           new Statement(
                               new For(i, new Int(firstpart), new Int(len - 1), new Int(1),
                                       expandAction(a, i, 1, elemtype))));
            }
        catch(Exception ee)
            {
                dlog("in buildloop" + ee);
                throw ee;
            }
    }

    int refcount(String t)
    {
        if(t.startsWith("ref "))
            return 1 + refcount(t.substring(4));
        return 0;
    }
//
    /**
     *  expand an arbitrary expression to be parallel by a given factor
     *all array references are appropriately subscripted and replaced
     *by references of the appropriate parallelism
     *
     * @param  a              Description of Parameter
     * @param  induction      Description of Parameter
     * @param  parfactor      Description of Parameter
     * @param  et             Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    Node expandAction(Node a, Node induction, int parfactor, String et)
    throws Exception
    {
        if(true)
            {
                dlog(
                    "expandAction(" + a + "," + induction + "," + parfactor
                    + ", " + et + ")" +
                    "\n class " + a.getClass().toString());
            }
        if(a instanceof Assign)
            {
                Assign asn  = (Assign) a;
                String dt   = et;
                if(!dt.startsWith("ref"))
                    {
                        dt = "ref " + dt;
                    }
                Node dest   = expandAction(asn.dest, induction, parfactor, dt);
                Node src    = expandAction(asn.src, induction, parfactor, et);
                if(verbose)
                    {
                        dlog("expand action on an assignment " + a);
                        dlog("dest =" + dest);
                        dlog("src=" + src);
                    }
                return new Assign(dest, src).eval();
            }
        else if(a instanceof Deref)
            {
                Node dres  = new Deref(
                    expandAction(((Deref) a).getArg(), induction, parfactor, et));
                dlog("->" + dres);
                return dres;
            }
        else if(a instanceof Cast)
            {
                String dt  = (parfactor > 1
                              ? et + " vector ( " + parfactor + " )"
                              : et);
                while(refcount(a.returnType()) > refcount(dt))
                    {
                        dt = "ref " + dt;
                    }
                dlog("cast to " + dt);
                Node cres  = new Cast(dt,
                                      expandAction(((Cast) a).getSubtree(), induction, parfactor,
                                                   et));
                dlog("->" + cres);
                return cres;
            }
        else if(a instanceof Memref)
            {
                String elemtype  = "undefined";
                String vectype   = elemtype;
                try
                    {
                        Memref var      = (Memref) a;
                        vectype = var.returnType();
                        if(Format.isVector(vectype))
                            {
                                elemtype = Format.getVectorElementType(vectype);
                            }
                        else
                            {
                                elemtype = vectype;
                            }
                        String vartype  = "ref "
                                          + (parfactor == 1
                                             ? elemtype
                                             : elemtype + " vector ( " + parfactor + " )");
                        Memref newvar   = new Memref(
                            new Dyad(var.index,
                                     new Dyad(new Deref(induction),
                                              new Int(Format.lengthInBytes(elemtype)), "*"    // Op.prod(Node.int32, Node.int32, Node.int32)
                                             ),
                                     "+"// Op.sum(Node.int32, Node.int32, Node.int32)
                                    ),
                            vartype);
                        dlog("->" + newvar);
                        return newvar;
                    }
                catch(Exception en)
                    {
                        dlog("in expand action " + en + "\n" + vectype + "," + elemtype);
                        throw en;
                    }
            }
        else if(a instanceof Dyad)
            {
                Dyad d     = (Dyad) a;
                String nt  = (parfactor > 1
                              ? et + " vector ( " + parfactor + " )"
                              : et);
                d = new Dyad(expandAction(d.left, induction, parfactor, et),
                             expandAction(d.right, induction, parfactor, et),   // new Op(d.O.Symbol, nt, nt, nt)
                             d.O.Symbol);
                dlog("->" + d);
                return d;
            }
        else if(a instanceof Monad)
            {
                Monad m    = (Monad) a;
                String nt  = (parfactor > 1
                              ? et + " vector ( " + parfactor + " )"
                              : et);
                m = new Monad(new Op(m.oper.Symbol, nt, nt, nt),
                              expandAction(m.arg, induction, parfactor, et));
                dlog("->" + m);
                return m;
            }
        else
            {
                throw new Exception(" cant expand vector action " + a);
            }
    }

//

    /**
     *  declare a compile time variable that is private to the code generator
     *
     * @param  s  Description of Parameter
     */
    void declarevar(String s)
    {
        names.put(s, undefined);
    }
    boolean anymatcher(Node n)
    {
        if(verbose)dlog("Walker.anymatcher ",n);
        matchedTree  = n ;
        matchedAssembler = "";
        return true;
    }
    Node anytransformer(Node n)
    {
        return n;
    }
    Node transformer(Node n)throws Exception
    {
        return n;
    }
//

    /**
     *  undeclare a compile time variable
     *
     * @param  s  Description of Parameter
     */
    void forgetvar(String s)
    {
        names.remove(s);
    }


    /**
     *  checks that node n's return type occupies the same space as the type named
     *  by tidentifier
     *
     * @param  n            Description of Parameter
     * @param  tidentifier  string containing printout of type
     * @return              Description of the Returned Value
     */
    boolean typecompatiblewith(Node n, String tidentifier)
    {
        // check that the current type associated with the
        // identifier is compatible with the node
        String returns  = returnFormat(n);
        dlog("type compatible with " + tidentifier, n);
        while(returns.startsWith("ref") && tidentifier.startsWith("ref"))
            {
                tidentifier = Format.typeDeref(tidentifier);
                returns = Format.typeDeref(returns);
            }
        boolean ok      = (tidentifier.equals(returns));    //||(returns.startsWith( "ref" )&&tidentifier.equals(getAddressType()));
        if(ok)
            {
                return true;
            }
        if(Format.isUntypedFormat(tidentifier))
            {
                return tidentifier.equals(Format.typeToFormat(returns));
            }
        String fi       = typeToFormat(tidentifier);
        dlog(" is " + fi + " == " + returns);
        return fi.equals(returns);
    }


    /**
     *  check that the current type associated with the
     * identifier is identical to that of   the node
     *
     * @param  n            Description of Parameter
     * @param  tidentifier  Description of Parameter
     * @return              Description of the Returned Value
     */
    boolean typeequalitywith(Node n, String tidentifier)
    {
        // check that the current type associated with the
        // identifier is identical to that of   the node
        String returns  = n.returnType();
        if(verbose)
            {
                dlog(
                    "check type equality with " + tidentifier + " actually is "
                    + returns + " ",
                    n);
            }
        while(returns.startsWith("ref") && tidentifier.startsWith("ref"))
            {
                tidentifier = Format.typeDeref(tidentifier);
                returns = Format.typeDeref(returns);
            }
        boolean ok      = (tidentifier.equals(returns));    //||(returns.startsWith( "ref" )&&tidentifier.equals(getAddressType()));
        if(!ok)
            {
                boolean isint  = false;
                long val       = 0;
                if(n.knownAtCompileTime())
                    {
                        if(n instanceof Int)
                            {
                                isint = true;
                                val = ((Int) n).longValue();
                            }
                        else if(n instanceof Integer)
                            {
                                isint = true;
                                val = ((Integer) n).longValue();
                            }
                    }
                if(isint)
                    {
                        /*
                         *  it is permisible to fit a larger integer into a smaller
                         *  location if the value will fit. This is done for
                         *  risc machines which often only allow 16 bit integer
                         *  constants in the instructions.
                         *  However this means that patterns which plant literal
                         *  constants must be placed in descending order of size
                         *  in the instructionset definition, otherwise 32 bit
                         *  integer constants may be allocated only 8 bit fields etc.
                         */
                        if(tidentifier.equals(Node.int32)&& returns.equals(Node .int64))
                            {
                                ok=(val <=2147483647)&&(val >= -2147483648);
                            }
                        else if(tidentifier.equals(Node.int16) && (returns.equals(Node.int32)||returns.equals(Node .int64)))
                            {
                                ok = (val <= 32767) && (val >= -32768);
                            }
                        else if(tidentifier.equals(Node.int8)
                                && (returns.equals(Node.int32) || returns.equals(Node.int16)||returns.equals(Node .int64)))
                            {
                                ok = (val < 128) && (val > -128);
                            }
                    }
            }
        // if(!ok){
        // ok=	checkUnitaryVectorMatch(tidentifier,returns)
        // ||checkUnitaryVectorMatch(returns,tidentifier);
        // }
        if(verbose)
            {
                dlog(
                    "check type equality with " + tidentifier + " actually is "
                    + returns + " " + ok,
                    n);
            }
        return ok;
    }


    boolean checkUnitaryVectorMatch(String possiblevector, String possibleelement)
    {
        if(!Format.isVector(possiblevector))
            {
                return false;
            }
        if(!(Format.getVectorTypeLength(possiblevector) == 1))
            {
                return false;
            }
        return possibleelement.equals(
                   Format.getVectorElementType(possiblevector));
    }


    /**
     *  used to associate a type string with a particular parameter in a unification
     *
     * @param  actualtype  a type string
     * @param  paramindex  denotes the index of the paramaeter in the list of parameters to a pattern
     * @return             Description of the Returned Value
     */
    boolean bindtype(String actualtype, int paramindex)
    {
        if(bindings[asfinallymatched][paramindex] == null)
            {
                bindings[asfinallymatched][paramindex] = bindings[asoutput][paramindex] = actualtype;
            }
        String typePattern  = (String) bindings[asoutput][paramindex];
        if(verbose)
            {
                log(
                    "try to bind actualtype " + actualtype + "to param " + paramindex
                    + "=" + typePattern);
            }
        if(actualtype.equals("unbound"))
            {
                return true;
            }
        // unbound matches anything
        // remove preceeding refs
        while(typePattern.startsWith("ref") && actualtype.startsWith("ref"))
            {
                typePattern = Format.typeDeref(typePattern);
                actualtype = Format.typeDeref(actualtype);
            }
        // check that the actual type
        // is compatible with the type pattern
        if(actualtype.equals(typePattern))
            {
                return true;
            }
        String tfat,tftp;
        if(typePattern.equals(tfat=typeToFormat(actualtype)))
            {
                return true;
            }
        if(actualtype.equals(tftp=typeToFormat(typePattern)))
            {
                return true;
            }
        if(verbose)
            {
                log("check assign comp ref " + typePattern + ":=" + actualtype);
            }
        if(Assign.checkAssignComp("ref " + typePattern, actualtype))
            {
                return true;
            }
        if(! tfat.equals(tftp))return false;
        return bindString(paramindex,
                          /*
                           *  typeToFormat
                           */
                          (actualtype));
    }


    /**
     *  binds a parameter in the unification to a string, typically used to bind
     *a parameter to a string of assembler code it produces
     *
     * @param  paramindex  Description of Parameter
     * @param  value       Description of Parameter
     * @return             Description of the Returned Value
     */
    boolean bindString(int paramindex, String value)
    {
        if(verbose)
            {
                log("bindstring var " + paramindex + " to " + value);
            }
        Object val   = bindings[asoutput][paramindex];
        if(val == null)
            {
                bindings[asoutput][paramindex] = bindings[asfinallymatched][paramindex] = value;
                return true;
            }
        String sval  = val.toString();
        if(sval.equals(value))
            {
                return true;
            }
        return false;
    }


    /**
     *   check if the string representation of n is s
     *
     * @param  n  Description of Parameter
     * @param  s  Description of Parameter
     * @return    Description of the Returned Value
     */
    boolean dyadMatches(Op n, String s)
    {
        return (n.Symbol.toLowerCase().equals(s.toLowerCase()));
    }


    /**
     *  returns a message that a method used for code matching is not yet implemented
     *
     * @param  s  Description of Parameter
     */
    void unimp(String s)
    {
        System.err.println("Unimplemented proc " + s);
    }

// ----------------------------------------------------------------------------------

    /**
     *  reserve a register so it can not be used again until unreserved
     *
     * @param  r  register to reserve
     */

    void reserve(Register r)
    {
        if(r.isReserved())
            {
                return;
            }// dont reserve multiple times as reservation stored as boolean
        validReservations=false;
        ((Register) r).reserve();
        reservationStack.push(new Reservation(ressp++, r));
        reservationhash = reservationhash.add(
                              new BigInteger(
                                  java.lang.Integer.toString(
                                      r.toString().hashCode() % hashmod)));
        if(verbose)
            {
                dlog("reserve register at depth " + ressp + "," + r);
            }
    }// used in keeping a hashcode representing reservation status


    /**
     *  free register if r is a register
     *
     * @param  r  Description of Parameter
     */
    void unreserve(Node r)
    {
        try
            {
                if(r instanceof Register)
                    {
                        unreserve((Register) r);
                    }
                else if(r instanceof Deref)
                    {
                        unreserve(((Deref) r).arg);
                    }
                else if(r instanceof Cast)
                    {
                        unreserve(((Cast) r).getSubtree());
                    }
            }
        catch(Exception e)
            {
                dlog("in unreserve " + e.toString());
            }
    }


    void reserve(Node r)
    {
        if(verbose)
            {
                log(" try to reserve " + r);
            }
        try
            {
                if(r instanceof Register)
                    {
                        reserve((Register) r);
                    }
                else if(r instanceof Deref)
                    {
                        reserve(((Deref) r).arg);
                    }
                else if(r instanceof Cast)
                    {
                        reserve(((Cast) r).getSubtree());
                    }
            }
        catch(Exception e)
            {
                if(verbose)
                    {
                        dlog("in reserve " + e.toString());
                    }
            }
    }


    /**
     *  free a register
     *
     * @param  r              Description of Parameter
     * @exception  Exception  Description of Exception
     */
    void unreserve(Register r)
    throws Exception
    {
        validReservations=false;
        if(r.isSpilled())
            {
                unspill(r);
            }
        r.unreserve();
        reservationhash = reservationhash.subtract(
                              new BigInteger(
                                  java.lang.Integer.toString(
                                      r.toString().hashCode() % hashmod)));
        // reservationSet.remove(r);
        // names.put(r,undefined);
        if(verbose)
            {
                log("Unreserve " + r);
            }
    }


    /**
     *  resetst the reservations of registers to be what they were at the mark point mark
     *
     * @param  mark           Description of the Parameter
     * @exception  Exception  Description of Exception
     */
    void rollBackReservations(int mark)
    throws Exception
    {
        if(reservationStack.empty())
            {
                return;
            }
        Object top     = reservationStack.peek();
        if(!(top instanceof Reservation))
            {
                throw new Exception("Non reservation on reservation stack" + top);
            }
        Reservation r  = (Reservation) top;
        dlog("rollBackReservations to " + mark);
        if(r.mark >= mark)
            {
                if(verbose)
                    {
                        log(r.reserved.toString() + ":" + r.mark);
                    }
                unreserve(r.reserved);
                reservationStack.pop();
                ressp = r.mark;
                rollBackReservations(mark);
            }
    }


    /**
     *  produces a string of the reserved registers
     *
     * @return                string of reserved registers
     * @exception  Exception  Description of Exception
     */
    public String listReservations()
    throws Exception
    {
        String list        = " ";
        Iterator elems  = registerSet.iterator();
        while(elems.hasNext())
            {
                Object R  = elems.next();
                if((R instanceof Register))
                    {
                        Register r  = (Register) R;
                        if(isReserved(r) && (!r.permanentlyReserved())
                                && r.getParent() == null
                          )
                            {
                                list = list + r;
                            }
                    }
            }
        return list;
    }


    /**
     *  produces a hashcode of the reserved registers
     *
     * @return                string of reserved registers as a hashcode
     * @exception  Exception  Description of Exception
     */
    String cacheReservations ;
    boolean validReservations=false;
    String hashReservations()
    throws Exception
    {
        if(!validReservations)
            {
                long total=0;
                int t1=registerSet.reservationlines.length;
                for(int i=1; i<t1; i++)
                    {
                        int [] line = registerSet.getline(i);
                        int k= line.length;
                        for(int j=0; j<k; j++)total=total*11+line[j];
                    }
                cacheReservations= "h"+total;
                validReservations=true;
            }
        return cacheReservations;
        /*


        	String list        = "";
        	Enumeration elems  = registerSet.iterator();

        	boolean[] bools    = new boolean[registerSet.size()];

        	for ( int i = 0; i < bools.length; i++ )
        	{
        		bools[i] = false;
        	}

        	while ( elems.hasMoreElements() )
        	{
        		Object R  = elems.nextElement();

        		if ( ( R instanceof Register ) )
        		{
        			Register r  = ( Register ) R;

        			bools[r.parentnum] |= r.isReserved();
        		}
        	}

        	boolean got_one    = false;
        	int i              = bools.length;

        	while ( ( !got_one ) && ( i >= 0 ) )
        	{
        		got_one = bools[--i];
        	}
        	while ( i >= 0 )
        	{
        		list = ( bools[i--] ? "1" : "0" ) + list;
        	}

        	BigInteger bigint  = new BigInteger( list, 2 );

        	return list; */
    }


    /**
     * counts the number of reserved registers exluding permanently reserved ones
     *
     * @return    Description of the Return Value
     */
    int countReservations()
    {
        int count          = 0;
        Iterator elems  = registerSet.iterator();
        while(elems.hasNext())
            {
                Object R  = elems.next();
                if((R instanceof Register))
                    {
                        Register r  = (Register) R;
                        if(r.getParent()==null)
                            if(isReserved(r))
                                {
                                    if(!r.permanentlyReserved())
                                        {
                                            count++;
                                        }
                                }
                    }
            }
        return count;
    }


    /**
     *  produce a comma separated list of the unreserved registers
     *
     * @param  r  list of registers
     * @return    Description of the Returned Value
     */
    String freeregs(Register[] r)
    {
        String res  = "";
        for(int i = 0; i < r.length; i++)
            {
                if(!isReserved(r[i]))
                    {
                        res = res + r[i] + ",";
                    }
            }
        return res;
    }


    /**
     *  search array for object
     *
     * @param  regs  Description of Parameter
     * @param  r     Description of Parameter
     * @return       Description of the Returned Value
     */
    boolean foundin(Object[] regs, Object r)
    {
        // log("foundin "+regs+r);
        for(int i = 0; i < regs.length; i++)
            {
                if(regs[i].equals(r))
                    {
                        return true;
                    }
            }
        return false;
    }


    /**
     *  search array for object
     *
     * @param  regs           Description of Parameter
     * @return                Description of the Returned Value
     * @exception  Exception  Description of Exception
     */
    Register findFreeReg(Register[] regs)
    throws Exception
    {
        int start   = 0;// +(int) Math.random() * regs.length;
        for(int i = start; i < start + regs.length; i++)
            {
                if(!isReserved(regs[i % regs.length]))
                    {
                        return new RegReservation(regs[i % regs.length]);
                    }
            }
        if(!spillingOn)
            {
                return null;
            }
        // disable spilling for now
        int target  = (int)(Math.random() * regs.length);
        spill(regs[target]);
        return findFreeReg(regs);
    }


    /**
     *  find a free register that occupies position startbit   of a larger
     *  register
     *
     * @param  regs           vector of registers to search
     * @param  startbit       position that the register must start in parent
     * @return                a register
     * @exception  Exception  Description of Exception
     */
    Register findFreeReg(Register[] regs, int startbit)
    throws Exception
    {
        int start   = 0;// (int) Math.random() * regs.length;
        for(int i = start; i < start + regs.length; i++)
            {
                if(!isReserved(regs[i % regs.length]))
                    {
                        if(regs[i % regs.length].getStartInParent() == startbit
                                && regs[i % regs.length].getParent() != null)
                            {
                                return new RegReservation(regs[i % regs.length]);
                            }
                    }
            }
        if(!spillingOn)
            {
                return null;
            }
        // disable spilling for now
        int target  = 0;// (int) (Math.random() * regs.length);
        spill(regs[target]);
        return findFreeReg(regs, startbit);
    }


    /**
     *  Search entire register set for a register of the right type
     *
     * @param  type           type to find
     * @return                a register
     * @exception  Exception  Description of Exception
     */
    public Register findFreeReg(String type)
    throws Exception
    {
        return findFreeReg(type, null);
    }


    /**
     * look for a register of the appropriate type with the appropriate parent
     *
     * @param  type           Description of the Parameter
     * @param  parent         Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    Register findFreeReg(String type, Register parent)
    throws Exception
    {
        String drt  = Format.typeDeref(type);
        if(verbose)
            {
                dlog("want reg of type " + drt + " with parent " + parent);
            }
        int len     = Format.lengthInBits(drt);
        // System.out.println("for "+type+"want length " + len);
        for(Iterator i = registerSet.iterator(); i.hasNext();)
            {
                Object o  = i.next();
                if(o != null && o instanceof Register)
                    {
                        Register father;
                        Register r        = (Register) o;
                        String rrt        = r.returnType();
                        boolean typeok    = rrt.equals(type)||rrt.equals("ref "+type);
                        String rt         = Format.typeDeref(rrt);
                        int rlen          = Format.lengthInBits(rt);
                        // System.out.println(o + ":" + rt + " len " + rlen);
                        boolean reserved  = isReserved(r);
                        boolean alias     = (father = r.getParent()) != null;  // check this if we want to prevent use of low mmx regs
                        boolean confused  = floatintconfusion(type, r.returnType());
                        boolean lengthok  = len == rlen;
                        if(verbose)
                            {
                                dlog(
                                    r.toString()+":"+rrt + " confused=" + confused + " alias="
                                    + alias + " reserved=" + reserved + " lengthok="
                                    + lengthok +" typeok ="+typeok);
                            }
                        if(lengthok && typeok && !reserved && !confused  // &&(alias?rt.equals(Node.ieee32):true)
                          )
                            {
                                if(verbose)
                                    {
                                        dlog("ok");
                                    }
                                // buf.writeln("; #use "+r+":"+rt);
                                if(parent == null)
                                    {
                                        return r;
                                    }
                                if(verbose)
                                    {
                                        dlog(
                                            "parent wanted is " + parent + " r=" + r
                                            + " alias=" + father + " parent==r"
                                            + parent.equals(r));
                                    }
                                if(parent.equals(r) || parent.equals(father)
                                  )
                                    {
                                        return r;
                                    }
                            }
                    }
            }
        // System.out.println("could not find a free reg of type "+type);
        return null;
    }


    /**
     * count the number of free registers of a type
     *
     * @param  type           Description of the Parameter
     * @return                Description of the Return Value
     * @exception  Exception  Description of the Exception
     */
    int stillFree(String type)
    throws Exception
    {
        return stillFree(type, false);
    }


    int totalregsoftype(String type)
    throws Exception
    {
        return stillFree(type, true);
    }


    int stillFree(String type, boolean dontcare)
    throws Exception
    {
        String drt  = Format.typeDeref(type);
        int len     = Format.lengthInBits(drt);
        if(verbose)dlog("in still free want length " + len + " for " + type);
        int count   = 0;
        int resmark = ressp;
        boolean oldverbose=verbose;
        verbose=false;
        for(Iterator i = registerSet.iterator(); i.hasNext();)
            {
                Object o  = i.next();
                if(o != null && o instanceof Register)
                    {
                        Register r       = (Register) o;
                        String rt        = Format.typeDeref(r.returnType());
                        int rlen         = Format.lengthInBits(rt);
                        Register father;
                        //if(verbose)dlog( "check " + r );
                        if(len == rlen && (dontcare || !isReserved(r))
                                && Assign.checkAssignComp(r.returnType(), Format.typeDeref(type))   //!floatintconfusion( type, r.returnType() )
                                && (Format.isVector(rt)
                                    ? true
                                    : !r.toString().contains("MM")  // stop us using low words of mmx reg
                                    ||
                                    r.toString().contains("X")  // but allow XXM regs
                                   )
                          )
                            {
                                count++;
                                reserve(r);
                            }
                    }
            }
        rollBackReservations(resmark);
        verbose=oldverbose;
        return count;
    }

// -------------------------------------------------------------------------------------------------------

    /**
     *check if two values of the same length are an int and a float
     *
     * @param  t1  ref type to be assigned
     * @param  t2  type of the register
     * @return     Description of the Returned Value
     */
    boolean floatintconfusion(String t1, String t2)
    {
        // if(verbose)dlog("check float/int confusion for (" + t1 +")("+ t2+")");
        if(t1.equals("ref ieee32") && !t2.equals(t1))
            {
                if(verbose)
                    {
                        dlog("is confused");
                    }
                return true;
            }
        if(t1.equals("ref ieee64") && !t2.equals(t1))
            {
                return true;
            }
        if(t2.equals("ref ieee32") && !t2.equals(t1))
            {
                return true;
            }
        if(t2.equals("ref ieee64") && !t2.equals(t1))
            {
                return true;
            }
        return false;
    }

// check if the node is one o
    /**
     *  return true if n in one of the registers regs
     *
     * @param  regs  Description of Parameter
     * @param  n     Description of Parameter
     * @return       Description of the Returned Value
     */
    boolean alreadyaReg(Register[] regs, Node n)
    {
        if(n instanceof Deref)
            {
                return alreadyaReg(regs, ((Deref) n).arg);
            }
        if((n instanceof Register))
            {
                // log("is instance of register "+n);
                if(foundin(regs, ((Register) n)))
                    {
                        matchedTree = n;
                        matchedAssembler = n.toString();
                        return true;
                    }
            }
        // log("alreadyaReg finds that either "+n+ "is not a reg or it is not in the appropriate set ");
        if((n instanceof Cast))
            {
                return alreadyaReg(regs, ((Cast) n).subtree);
            }
        return false;
    }


    /**
     *  enter the left hand side of an assignment
     */
    void enterLhs()
    {
        assignmentContext.push("lhs");
    }


    /**
     *  record that we are leaving lhs of an assignment
     */
    void leaveLhs()
    {
        if(!assignmentContext.empty())
            {
                assignmentContext.pop();
            }
    }


    /**
     *  record that we are in right hand side context of an assigmment
     */
    void enterRhs()
    {
        assignmentContext.push("rhs");
    }


    /**
     *  record that we are leaving rhs of an assignment
     */
    void leaveRhs()
    {
        if(!assignmentContext.empty())
            {
                assignmentContext.pop();
            }
    }


    /**
     *  Description of the Method
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public Node decast(Node n)
    {
        return (n instanceof Cast ? ((Cast) n).subtree : n);
    }


    /**
     *  checks if node is a register else if the flag nodeIsRhs is true it attempts
     *  to load the node into the register
     *
     * @param  regs  Description of Parameter
     * @param  n     Description of Parameter
     * @return       Description of the Returned Value
     */

    boolean tryBindingRegisterTo(Register[] regs, Node n)
    {
        /*
         *  we first check if the node already
         *  is this register
         */
        if(alreadyaReg(regs, n))
            {
                if(verbose)
                    {
                        log("already a reg");
                    }
                // comment this is now done by alreadyaReg
                // matchedTree=n;
                // matchedAssembler=(decast(n).toString());
                return true;
            }
        String nt          = n.returnType();
        if(verbose)
            {
                log("try binding " + n + " to a register");
            }
        Object associated  = names.get(n);
        if(isItRhs())
            {
                try
                    {
                        {
                            // if it is a src not a dest
                            // if the result will fit in these regs
                            if(verbose)
                                {
                                    dlog("value type " + nt);
                                }
                            String dereftype  = Format.typeDeref(nt);
                            String rt         = regs[0].returnType();
                            if(verbose)
                                {
                                    dlog("register type " + rt);
                                }
                            if(nt.startsWith("ref ref")
                                    && Assign.checkAssignComp(rt, getAddressType()))
                                {
                                    dlog("loading a pointer into register");
                                    names.put(n, "loading in a reg ");
                                    if(verbose)
                                        {
                                            if(Format.isVector(nt))
                                                {
                                                    log(
                                                        " assignment compatible " + rt + " "
                                                        + dereftype);
                                                }
                                        }
                                    // note that we deref the right hand side here
                                    if(loadregister(regs,
                                                    new Cast(getAddressType(), new Deref(n))))
                                        {
                                            return true;
                                        }
                                    else
                                        {
                                            // make sure we dont try this again
                                            names.put(n, "wont go in register");
                                        }
                                }
                            else
                                {
                                    boolean isaref        = nt.startsWith("ref");
                                    boolean isassignable  = Assign.checkAssignComp(rt,
                                                            dereftype);
                                    // put in special case of allowing assign from
                                    // ieee64 to ieee32 if the dest is a register
                                    if(! isassignable)
                                        {
                                            if(rt.equals("ref ieee32")&& dereftype.equals("ieee64"))
                                                {
                                                    isassignable=true;
                                                }
                                        }
                                    if(verbose)
                                        {
                                            dlog(
                                                "check assign compatibility of " + rt
                                                + "and " + dereftype + "\n is a ref ="
                                                + isaref + "\n is assignable ="
                                                + isassignable);
                                        }
                                    if(isaref && isassignable)
                                        {
                                            names.put(n, "loading in a reg ");
                                            if(verbose)
                                                {
                                                    if(Format.isVector(nt))
                                                        {
                                                            log(
                                                                " assignment compatible " + rt + " "
                                                                + dereftype);
                                                        }
                                                }
                                            // note that we deref the right hand side here
                                            if(loadregister(regs, new Deref(n)))
                                                {
                                                    return true;
                                                }
                                            else
                                                {
                                                    // make sure we dont try this again
                                                    names.put(n, "wont go in register");
                                                }
                                        }
                                    else if(Assign.checkAssignComp(rt, nt)&& ! isaref)
                                        {
                                            // note in this case we do not deref the rhs because it
                                            // is already value
                                            names.put(n, "loading in a reg ");
                                            if(loadregister(regs, n))
                                                {
                                                    return true;
                                                }
                                            else
                                                {
                                                    // make sure we dont try this again
                                                    names.put(n, "wont go in register");
                                                }
                                        }
                                    else if((rt.equals("ref int16")  && dereftype.equals("int8"))
                                            || (rt.equals("ref int32")  && dereftype.equals("int8"))
                                            || (rt.equals("ref int64")  && (dereftype.equals("int32") ||dereftype.equals("uint32")))
                                            || (rt.equals("ref int32")  && (dereftype.equals("int16") ||dereftype.equals("uint16")))
                                            || (rt.equals("ref uint16")  && dereftype.equals("uint8"))
                                            || (rt.equals("ref uint32")  && dereftype.equals("uint8"))
                                            || (rt.equals("ref ieee64")  && dereftype.equals("ieee32"))
                                            || (rt.equals("ref uint32")  && dereftype.equals("uint16")))
                                        {
                                            return tryBindingRegisterTo(regs,
                                                                        new ilcg.tree.Monad(
                                                                            new Op("EXTEND", dereftype,
                                                                                   Format.typeDeref(rt)),
                                                                            (isaref ? new Deref(n) : n)));
                                        }
                                }
                        }
                    }
                catch(Exception e1)
                    {
                        dlog("in tryBindingRegister " + e1);
                    }
            }
        if(verbose)
            {
                log("failed");
            }
        return false;
    }


    /**
     *  detects repeated recursion on the same expression
     *
     * @param  n      Description of Parameter
     * @param  level  Description of Parameter
     * @return        Description of the Returned Value
     */
    boolean recursing(String n, int level)
    {
        return recursing(n, level, -1);
    }


    /**
     *  Description of the Method
     *
     * @param  n      Description of Parameter
     * @param  level  Description of Parameter
     * @param  count  Description of Parameter
     * @return        Description of the Returned Value
     */
    boolean recursing(String n, int level, int count)
    {
        if(count > 0)
            {
                return true;
            }
        boolean answer  = false;
        if(level <= 0)
            {
                return false;
            }
        if(level > recmax)
            {
                dlog("rec level " + level);
                return true;
            }
        if(recTrace[level].equals(n))
            {
                answer = recursing(n, level - 1, count + 1);
            }
        else
            {
                answer = recursing(n, level - 1, count);
            }
        if(answer)
            {
                dlog(" recTrace[" + level + "]=" + recTrace[level]);
            }
        return answer;
    }
    Node raiseprecision(Node n, String type)throws Exception
    {
        if(n.returnType().equals(type))return n;
        int length = Format.lengthInBits(type);
        if(n instanceof SubField)
            {
                Node subtree = ((SubField)n).getSubtree();
                int sublength= Format.lengthInBits(subtree.returnType());
                if(length==sublength)return new Cast(type,subtree);
                if(length<sublength)return new SubField(subtree,0,type);
            }
        if(n instanceof Cast)return raiseprecision(((Cast)n).getSubtree(),type);
        if(n instanceof Dyad)
            {
                Dyad d= (Dyad)n;
                Op o = d.O;
                if(o.Symbol.equals("+")||o.Symbol.equals("-")||
                        o.Symbol.equals("*")||o.Symbol.equals("/")||
                        o.Symbol.equals(Node.divide)||o.Symbol.equals(Node.min)||
                        o.Symbol.equals(Node.max))
                    return new Dyad(raiseprecision(d.left,type),raiseprecision(d.right,type),o.Symbol);
            }
        return new  Monad(
                   new Op("EXTEND", n.returnType(), type), n);
    }
// holds last attempt

    /**
     *  Attempts to generate code to place the value of node n in one of the
     *  defined registers. The routine attempts to minimise the instructions
     *  generated.
     *
     * @param  regs  Description of Parameter
     * @param  n     Description of Parameter
     * @return       Description of the Returned Value
     */
    boolean loadregister(Register[] regs, Node n)
    {
        if(recsp > recmax)
            {
                if(verbose)
                    {
                        dlog("recursion too deep");
                    }
                System.out.println("Recursion Stack overflow in code generator");
                for(int i = 0; i <= regs.length; i++)
                    {
                        System.out.println(regs[i].sig() + regs[i].resStatus());
                    }
                return false;
            }
        /*
         *  we first check if the node already
         *  is one of these registers
         */
        if(alreadyaReg(regs, n))
            {
                if(verbose)
                    {
                        log("already a reg");
                    }
                matchedTree = n;
                matchedAssembler = (decast(n).toString());
                return true;
            }
        String pattern  = n.toString();
        try
            {
                if(verbose)
                    {
                        log("load into register " + pattern);
                    }
                n = n.eval();
                // try loading it into the register
                Register r;
                // try loading it into the register
                Register subregister  = regs[0];
                SubField sf;
                boolean wasSubField   = false;
                if(n instanceof SubField)
                    {
                        // we need to select a register from the list that is
                        // an appropriate subfield of a larger register
                        wasSubField = true;
                        sf = (SubField) n;
                        n = sf.getSubtree();
                        RegReservation rr=null;
                        dlog("got subfield");
                        boolean notfound=true;
                        while(notfound)
                            {
                                rr = (RegReservation) findFreeReg(regs, sf.lowbit);
                                if(rr == null)
                                    {
                                        return false;
                                    }
                                dlog("try "+rr);
                                subregister = rr.getParent();
                                if(parentIsReserved(subregister))
                                    {
                                        dlog(" it is reserved already "+subregister);
                                        // deal with examples like bh being reserved and we find bl
                                        // in which case we reserve bl and continue searching
                                        reserve(subregister);
                                    }
                                else notfound=false;
                            }
                        dlog("rr=" + rr + ", subregister=" + subregister + "subregister.getParent()"+subregister.getParent());
                        if(!Format.typeDeref(subregister.getParent().returnType()).equals(
                                    n.returnType()))
                            {
                                dlog(
                                    subregister.getParent().returnType() + "!="
                                    + n.returnType() + " for " + subregister);
                                r = findFreeReg("ref " + n.returnType(),
                                                subregister.getParent());
                            }
                        else
                            {
                                r = new RegReservation(subregister.getParent());
                            }
                        if(verbose)
                            {
                                log(
                                    " selected  parent register " + r + " subregister "
                                    + subregister);
                            }
                        if(r == null)
                            {
                                if(sf.decomposable())
                                    {
                                        if(verbose)
                                            {
                                                log("decomposable subfield" + sf);
                                            }
                                        if(loadregister(regs, sf.decompose()))
                                            {
                                                return true;
                                            }
                                    }
                            }
                    }
                else
                    {
                        r = findFreeReg(regs);
                    }
                if(verbose)
                    {
                        log("load into " + r);
                    }
                if(r == null)
                    {
                        throw new Exception("no regs free");
                    }
                String assignedVal    = Format.typeDeref(r.returnType());
                // remove the leading ref
                Node src              = n;
                String srctype        = src.returnType();
                if(srctype.startsWith("ref "))
                    {
                        srctype = Format.typeDeref(srctype);
                    }
                // make sure it is not already a ref
                Cast castr            = new Cast("ref " + srctype, r);
                Node derefsrc;
                Assign ra             = new Assign(castr, derefsrc = forcederef(src, srctype));
                String trace          = n.toString();
                boolean res           = Assign.checkAssignComp(r.returnType(), srctype);
                if(verbose)
                    {
                        log("assign check returns " + res);
                    }
                if(!res)
                    {
                        if(Format.isSigned(assignedVal)&&Format.isSigned(srctype)&&Format.lengthInBits(srctype)<Format.lengthInBits(assignedVal))
                            {
                                // we can extend lower length integers to longer ones
                                Node castsrc = new Cast(assignedVal,derefsrc);
                                ra=new Assign(r,castsrc);
                                res= true;
                            }
                        else
                            // put in special case of allowing assign from
                            // ieee64 to ieee32 if the dest is a register
                            if(r.returnType().equals("ref ieee32")&& srctype.equals("ieee64"))
                                {
                                    res=true;
                                }
                            else if(verbose)
                                {
                                    log("2nd assign check returns " + res);
                                }
                    }
                if(recursing(trace, recsp - 1))
                    {
                        if(verbose)
                            {
                                log("failed because of recursion on " + trace);
                            }
                        return false;
                    }
                recTrace[recsp] = trace;
                if(prereserve)
                    {
                        reserve(r);
                    }
                recsp++;
                String oldpad         = pad;
                if(prereserve)
                    {
                        pad = pad + r;
                    }
                // try codegenerating
                res = res && codeGen(new Statement(ra,null));
                recsp--;
                if(!prereserve)
                    {
                        reserve(r);
                    }
                if(!res)
                    {
                        unreserve(r);
                        pad = oldpad;
                        String nt= n.returnType();
                        if(!(n instanceof SubField)&&Format.isInteger(nt) &&Format.lengthInBits(nt)<32)
                            {
                                if(verbose)dlog("raise to higher precision and subfield");
                                n=new SubField(raiseprecision(n,"int32"),0,nt);
                                return loadregister(regs,n);
                            }
                    }
                if(res)
                    {
                        if(wasSubField)
                            {
                                // free up the whole of the register and reserve
                                // just the subfield we need
                                unreserve(r);
                                reserve(subregister);
                                matchedTree = subregister;
                                matchedAssembler = subregister.toString();
                                return true;
                            }
                        Node answer  = castr;
                        matchedTree = answer;
                        matchedAssembler = r.toString();
                        return true;
                    }
            }
        catch(Exception e)
            {
                dlog("in loadregister failed because " + e);
            }
        return false;
    }
    Set alreadyoptimised = new HashSet();
// this takes a statement, assignment or list of statements with
// no branches or labels and finds any common sub expressions that
// can be evaluated prior to the statements
// there must be no read after write dependencies in the code to be optimised
    Node subexpOptimise(Node n,Set substitutions)
    {
        if(alreadyoptimised.contains(n)) return n;
        try
            {
                CommonRHSFinder subs       = new CommonRHSFinder();
                if(n instanceof If)
                    {
                        ((If) n).cond.examine(subs);
                    }
                else
                    {
                        n.examine(subs);
                    }
                int repcount  = subs.getRepeatCount();
                if(repcount > 0)
                    {
                        Object[] subexps  = subs.getRepeats();
                        // chose one sub expression and assign it to a temporary
                        Node value        = (Node) subexps[0];
                        if(verbose)
                            {
                                System.out.println("subexpoptimise "+n);
                                System.out.println("substitution list is" +"\n{"+substitutions+"}");
                                for(int ii=0; ii<subexps.length; ii++)
                                    if(subs.score((Node)subexps[ii]) * subs.usage((Node) subexps[ii]) > subs.optimiseThreshold)
                                        System.out.println("common sub expression target " + subexps[ii]);
                            }
                        if(substitutions.contains(value))return n;// already substituted in
                        String refvrt     = "ref " + value.returnType();
                        Memref r        = newTemp(refvrt);
                        substitutions.add(r);
                        if(subs.score(value) * subs.usage(value) > subs.optimiseThreshold)
                            {
                                Node prepare     = new Assign(r,
                                                              forcederef(value,
                                                                      Format.typeDeref(r.returnType())));
                                alreadyoptimised.add(prepare);
                                Node A           = value;
                                Node B           = new Deref(new Cast(refvrt, r)).eval();
                                substitutions.add(B);
                                Node simplified;
                                if(n instanceof If)
                                    {
                                        If nif  = (If) n;
                                        // for ifs only substitute into condition
                                        simplified = new If(
                                            ExpressionSubstituter.substituteAwithBinC(
                                                A, B, nif.cond),
                                            nif.a1,
                                            nif.a2);
                                    }
                                else simplified = ExpressionSubstituter.substituteAwithBinC(A, B, n);
                                simplified=subexpOptimise(simplified,substitutions);
                                alreadyoptimised.add(simplified);
                                Statement ns = new Statement(new Statement(prepare,new Statement(simplified)));
                                ns . setLocal(r);
                                alreadyoptimised.add(ns);
                                return ns;
                            }
                    }
            }
        catch(Exception ee)
            {
                dlog("in subexpoptimise "+ee);
            }
        return n;
    }
    /**
     *  Description of the Method       looks for common sub expressions in an assignment
     *it should not be called if there is any chance that there are data dependencies in the node n
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    boolean subexpOptimisedCodeGen(Node n)
    {
        int oldinvocations         = invocations;
        dlog(" sub exp optimise " + n);
        // if(!(n instanceof Assign))return n;
        // try and find any common sub expressions to evaluate first
        CommonRHSFinder subs       = new CommonRHSFinder();
        int mark                   = buf.mark();
        int limit = currentSpills.getLimit();
        int firstTryInvocations    = 1000;
        //String[] unoptimisedlines  = buf.sequester( mark );
        if(canoptimise)
            {
                try
                    {
                        if(n instanceof If)
                            {
                                ((If) n).cond.examine(subs);
                            }
                        else
                            {
                                n.examine(subs);
                            }
                        int repcount  = subs.getRepeatCount();
                        if(verbose) dlog("rep count ="+repcount);
                        if((subExpressionOptimise & optimisationLevel) != 0)
                            {
                                if(repcount > 0)
                                    {
                                        Object[] subexps  = subs.getRepeats();
                                        // chose one sub expression and assign it to the register
                                        int max=0;
                                        int bestpos=0;
                                        int pos;
                                        for(pos = 0; pos<subexps.length; pos++)
                                            {
                                                Node v = (Node)subexps[pos];
                                                int thiscost =(int)(subs.usage(v)*subs.score(v));
                                                if(thiscost > max)
                                                    {
                                                        max=thiscost;
                                                        bestpos=pos;
                                                    }
                                                if(verbose) dlog(" candidate "+v+" cost "+thiscost);
                                            }
                                        Node value        = (Node) subexps[bestpos];
                                        String vs=value.toString();
                                        if(verbose)
                                            {
                                                dlog("common sub expression list is");
                                                for(int ii=0; ii<subexps.length; ii++)
                                                    dlog("common sub expression " + subexps[ii] +"\t"+subs.score((Node)subexps[ii]) * subs.usage((Node)subexps[ii]));
                                            }
                                        String refvrt     = "ref " + value.returnType();
                                        Register r        = findFreeReg(refvrt);
                                        int arefree       = 0;
                                        arefree = stillFree(refvrt);
                                        if(subs.score(value) * subs.usage(value) < subs.optimiseThreshold)
                                            {
                                                if(verbose)
                                                    {
                                                        printcomment(" not worth substituting "+value+ " "+(subs.score(value) * subs.usage(value))+"<"+subs.optimiseThreshold);
                                                        log(" not worth caching " + value);
                                                    }
                                            }
                                        else if(r == null
                                                || ((arefree) <= minimumFreeRegisters)
                                                || (arefree <(n.weight()-1))
                                               )
                                            {
                                                if(verbose)
                                                    {
                                                        log("not enough free regs" + arefree + "<="
                                                            + minimumFreeRegisters +" or weight of exp");
                                                    }
                                            }
                                        else
                                            {
                                                Node prepare     = new Assign(r,
                                                                              forcederef(value,
                                                                                      Format.typeDeref(r.returnType())));
                                                Node A           = value;
                                                Node B           = new Deref(new Cast(refvrt, r));
                                                Node simplified;
                                                if(n instanceof If)
                                                    {
                                                        If nif  = (If) n;
                                                        // for ifs only substitute into condition
                                                        simplified = new If(
                                                            ExpressionSubstituter.substituteAwithBinC(
                                                                A, B, nif.cond),
                                                            nif.a1,
                                                            nif.a2);
                                                    }
                                                else
                                                    {
                                                        simplified = ExpressionSubstituter.substituteAwithBinC(
                                                                         A, B, n);
                                                    }
                                                if(simplified.equals(n))
                                                    {
                                                        // do nothing
                                                    }
                                                else
                                                    {
                                                        if(verbose)
                                                            {
                                                                log("simplified to " + simplified);
                                                            }
                                                        // reserve a new register for the left hand side of the main assignment
                                                        if(unoptimisedcodegen(prepare))
                                                            {
                                                                reserve(r);
                                                                // we are only willing to put the about same amount of compile time
                                                                // effort into finding the optimised solution as the unoptimised one
                                                                int oldlimit             = matchbudget;
                                                                matchbudget = invocations
                                                                              + simplified.toString().length() * 2 + 12;
                                                                //canoptimise = false;
                                                                dlog("matchbudget="+matchbudget);
                                                                long save=whenmatchingmuststopMillis;
                                                                setdeadline(matchbudget);
                                                                boolean res = subexpOptimisedCodeGen(simplified);
                                                                matchbudget = oldlimit;
                                                                whenmatchingmuststopMillis=save;
                                                                canoptimise = true;
                                                                unreserve(r);
                                                                if(!res)
                                                                    {
                                                                        buf.rollBackTo(mark);
                                                                        throw new Exception(
                                                                            "can not generate optimised");
                                                                    }
                                                                // otherwise see which is the shortest
                                                                // in some cases register optimisation may
                                                                // lead to less efficient code
                                                                String[] optimisedlines  = buf.sequester(mark);
                                                                {
                                                                    /*if ( unoptimisedlines.length +3
                                                                    		 < optimisedlines.length )
                                                                    {
                                                                    	// output the unoptimised code
                                                                                                                    // if it needs more than one new instruction
                                                                    	throw new Exception(
                                                                    			"optimised worse unpoptimised length =" +unoptimisedlines.length+
                                                                    			"optimised length="+optimisedlines.length);
                                                                    }*/
                                                                }
                                                                // output the optimised code
                                                                printcomment(
                                                                    " substituting in " + r + " with "
                                                                    + subs.usage(value)
                                                                    + " occurences and score of "
                                                                    + subs.score(value));
                                                                buf.append(optimisedlines);
                                                                return true;
                                                            }
                                                        canoptimise = true;
                                                    }
                                            }
                                    }
                            }
                    }
                catch(Exception f)
                    {
                        dlog("opt:" + f);
                        // System.out.println(f);
                    }
            }
        if(!unoptimisedcodegen(n))
            {
                return false;
            }
        //buf.append( unoptimisedlines );
        return true;
    }


    /**
     *  checks if an object is in an array
     *
     * @param  set       Description of Parameter
     * @param  instance  Description of Parameter
     * @return           Description of the Returned Value
     */
    public static boolean inarray(Object[] set, Object instance)
    {
        int i;
        for(i = 0; i < set.length; i++)
            {
                if(instance.equals(set[i]))
                    {
                        return true;
                    }
            }
        return false;
    }


    boolean haslocals(Node n)
    {
        LocalFinder e  = new LocalFinder();
        n.examine(e);
        return !e.none;
    }


    int countlocals(Node n)
    {
        LocalFinder e  = new LocalFinder();
        n.examine(e);
        return e.count;
    }


    /**
     * this tries to test all combinations
     *of operators and operands to see if the
     *code generator can handle them
     *
     * @return    Description of the Return Value
     */
    public boolean selftest()
    {
        Memref v1;
        Memref v2;
        Memref v3;
        int i;
        int j;
        int k;
        int linesgenerated=0;
        int successes=0;
        int fails=0;
        boolean localverbose=verbose;
        verbose=false;
        String t1;
        String t2;
        String t3;
        String[] itypes  =
        {
            "int8", "uint8", "int16", "uint16", "int32",
            "uint32", "int64", "uint64", "ieee32", "ieee64"
        };
        String[] ops     =
        {
            Node.plus, Node.minus, Node.divide, Node.remainder,
            Node.times, Node.shr, Node.shl, Node.satplus, Node.satminus,
            Node.max, Node.min
        };
        String[] cmp     = {Node.lt, Node.le, Node.eq, Node.neq, Node.ge, Node.gt};
        int[] isizes     = {1, 1, 2, 2, 4, 4, 8, 8, 4, 8};
        try
            {
                // test assignments
                for(i = 0; i < itypes.length; i++)
                    {
                        t1 = itypes[i];
                        int size1=isizes[i];
                        v1 = newTemp(isizes[i], t1);
                        for(j = 0; j < itypes.length; j++)
                            {
                                t2 = itypes[j];
                                int size2=isizes[j];
                                v2 = newTemp(isizes[j], t2);
                                Node n2  = v2;
                                if(!(Format.isReal(t2) && !Format.isReal(t1)))
                                    if(! (Format.isSigned(t2) && Format.isUnsigned(t1)))
                                        {
                                            try
                                                {
                                                    System.out.println(" ");
                                                    matchbudget = 1000 + invocations;
                                                    dlog("matchbudget ="+matchbudget);
                                                    Node src=forcederef(n2, t2);
                                                    if (size1>size2) src = new Cast(t1,src);
                                                    Node n         = ( new Assign(v1, src));
                                                    int m          = buf.mark();
                                                    long save=whenmatchingmuststopMillis;
                                                    if(codeGen( (  new Statement(n))))
                                                        {
                                                            System.out.println(
                                                                "ok\t" + t1 + ":=" + t2 + ":" + n);
                                                            successes++;
                                                        }
                                                    else
                                                        {
                                                            System.out.println(
                                                                "fail\t" + t1 + ":=" + t2 + ":" + n);
                                                            fails++;
                                                            logfile = new PrintWriter(System.out);
                                                            if(localverbose)
                                                                {
                                                                    verbose=true;
                                                                    boolean ok=codeGen( (new Statement(n)));
                                                                    verbose=false;
                                                                }
                                                        }
                                                    whenmatchingmuststopMillis=save;
                                                    String[] copy  = buf.sequester(m);
                                                    for(int l = 0; l < copy.length; l++)
                                                        {
                                                            System.out.println("\t" + copy[l]);
                                                            linesgenerated++;
                                                        }
                                                }
                                            catch(AssignmentException e1)
                                                {
                                                    if(isizes[j] > isizes[i]&& Format.isInteger(t1)&&Format.isInteger(t2))
                                                        {
                                                            Node src       = new SubField(forcederef(n2, t2), 0,
                                                                                          t1);
                                                            Node m         = new Assign(v1, src);
                                                            int m2         = buf.mark();
                                                            if(codeGen(new Statement(m)))
                                                                {
                                                                    System.out.println("ok\t" + t1 + ":=" + src);
                                                                    successes++;
                                                                }
                                                            else
                                                                {
                                                                    System.out.println(
                                                                        "fail\t" + t1 + ":=" + src);
                                                                    fails++;
                                                                    logfile = new PrintWriter(System.out);
                                                                    if(localverbose)
                                                                        {
                                                                            logfile = new PrintWriter(System.out);
                                                                            verbose=true;
                                                                            boolean ok=codeGen(new Statement(m));
                                                                            verbose=false;
                                                                        }
                                                                }
                                                            String[] copy  = buf.sequester(m2);
                                                            for(int l = 0; l < copy.length; l++)
                                                                {
                                                                    System.out.println("\t" + copy[l]);
                                                                }
                                                        }
                                                    // else
                                                    // System.out.println(t1+":="+t2+" "+e1);
                                                }
                                        }
                            }
                    }
                try
                    {
                        int pos        = buf.mark();
                        System.out.println("pointer assignment");
                        v2 = newTemp(Format.lengthInBytes(getAddressType()),
                                     getAddressType());
                        v1 = newTemp(Format.lengthInBytes(getAddressType()), "ref int8");
                        if(codeGen(
                                    new Assign(new Cast("ref " + getAddressType(), v1),
                                               addr(forcederef(v2, getAddressType())))))
                            {
                                System.out.println("ok\tref ref int8:=" + getAddressType());
                                successes++;
                            }
                        else
                            {
                                System.out.println("fail\tref ref int8:=" + getAddressType());
                                fails++;
                            }
                        String[] copy  = buf.sequester(pos);
                        for(int l = 0; l < copy.length; l++)
                            {
                                System.out.println("\t" + copy[l]);
                                linesgenerated++;
                            }
                    }
                catch(Exception ee3)
                    {
                        System.out.println("fail exception ee3 " + ee3);
                        fails++;
                    }
                System.out.println("Arithmetic tests");
                for(j = 0; j < ops.length; j++)
                    {
                        String op=ops[j];
                        for(i = 0; i < itypes.length; i++)
                            {
                                boolean invalidtypes =false;
                                if(((op.equals(Node.satplus)||op.equals(Node.satminus))))
                                    {
                                        invalidtypes=Format.lengthInBits(itypes[i])>8;// we only need to support saturated bytes
                                    }
                                else if(op.equals(Node.shr)||op.equals(Node.shl)||op.equals(Node.remainder))
                                    {
                                        invalidtypes=Format.isReal(itypes[i]);
                                    }
                                if(! invalidtypes)
                                    {
                                        t2 = t1 = itypes[i];
                                        v1 = newTemp(isizes[i], t1);
                                        v2 = newTemp(isizes[i], t1);
                                        //    verbose = t2.equals("int8") && ops[j].equals("+:");
                                        Node n2        = new Dyad(forcederef(v1, t2), forcederef(v2, t2),
                                                                  ops[j]);
                                        Node n         = new Assign(v1, forcederef(n2, t2));
                                        int m          = buf.mark();
                                        matchbudget = 1000 + invocations;
                                        dlog("matchbudget ="+matchbudget);
                                        if(codeGen(new Statement(n)))
                                            {
                                                System.out.println(
                                                    "ok\t" + t1 + " " + ops[j] + " "+n+" " + invocations);
                                                successes++;
                                            }
                                        else
                                            {
                                                System.out.println(
                                                    "fail\t" + t1 + " " + ops[j] + " "+n+" " + invocations);
                                                fails++;
                                                if(localverbose)
                                                    {
                                                        logfile = new PrintWriter(System.out);
                                                        verbose=true;
                                                        boolean ok=codeGen(new Statement(n));
                                                        verbose=false;
                                                    }
                                            }
                                        String[] copy  = buf.sequester(m);
                                        for(int l = 0; l < copy.length; l++)
                                            {
                                                System.out.println("\t" + copy[l]);
                                                linesgenerated++;
                                            }
                                    }
                            }
                    }
                System.out.println("Comparison tests");
                v3 = newTemp(1, Node.int8);
                for(j = 0; j < cmp.length; j++)
                    {
                        for(i = 0; i < itypes.length; i++)
                            {
                                t2 = t1 = itypes[i];
                                v1 = newTemp(isizes[i], t1);
                                v2 = newTemp(isizes[i], t1);
                                Node n2        = new Dyad(forcederef(v1, t2), forcederef(v2, t2),
                                                          cmp[j]);
                                Node n         = new Assign(v3, forcederef(n2, Node.int8));
                                int m          = buf.mark();
                                matchbudget = 1000 + invocations;
                                if(codeGen(new Statement(n)))
                                    {
                                        System.out.println(
                                            "ok\t" + t1 + " " + cmp[j] + " "+ " "+n+" " + invocations);
                                        successes++;
                                    }
                                else
                                    {
                                        System.out.println(
                                            "fail\t" + t1 + " " + cmp[j] + " "+ " "+n+" " + invocations);
                                        fails++;
                                        if(localverbose)
                                            {
                                                verbose=true;
                                                boolean ok=codeGen(new Statement(n));
                                                verbose=false;
                                            }
                                    }
                                String[] copy  = buf.sequester(m);
                                for(int l = 0; l < copy.length; l++)
                                    {
                                        System.out.println("\t" + copy[l]);
                                        linesgenerated++;
                                    }
                            }
                    }
            }
        catch(Exception e99)
            {
                System.out.println("failed exception e99 " + e99);
                fails++;
                return false;
            }
        System.out.println("Success rate              \t"+(successes*100 )/(fails+successes)+"%\n"
                           +"Assembler lines per success\t"+(linesgenerated*1.0)/successes+"\n"
                           +"Invocations / codegen call \t"+(invocations+1.0)/(fails+successes)+"\n");
        buf.flush(new PrintWriter(System.out));
        verbose=localverbose;
        return true;
    }


    boolean ismemderef(Node n)
    {
        IsMemref i  = new IsMemref();
        n.examine(i);
        return i.itIs;
    }


    /**
     * Return the address of a variable
     *
     * @param  n  Description of the Parameter
     * @return    Description of the Return Value
     */
    Node addrof(Node n)
    {
        IsMemref i  = new IsMemref();
        n.examine(i);
        return i.ref;
    }

}

/**
 * @author     wpc
 * @created    June 22, 2001
 */
class Reservation implements Serializable
{


    /**
     *  Description of the Field
     */
    public int mark;

    /**
     *  Description of the Field
     */
    public Register reserved;


    /**
     *  Constructor for the Reservation object
     *
     * @param  m  Description of Parameter
     * @param  r  Description of Parameter
     */
    public Reservation(int m, Register r)
    {
        mark = m;
        reserved = r;
    }
}
// end of class walker
/**
 *This is applied to a node to see if it is a memref after the derefs have been
 *carried out
 *
 * @author     Paul Cockshott
 * @created    22 November 2005
 */
class IsMemref extends CommonMemExpressionFinder
{


    boolean stop  = false;
    boolean itIs  = false;
    Node ref      = null;


    /**
     *  This is called each time a node is visited, but before any subtrees are
     *  visited. If it returns false the subtree below the node is not visited
     *
     * @param  n  Description of Parameter
     * @return    Description of the Returned Value
     */
    public boolean visit(Node n)
    {
        if(n instanceof Memref)
            {
                stop = true;
                itIs = true;
                ref = ((Memref) n).index;
                return false;
            }
        if((n instanceof Dyad)
                || ((n instanceof Monad) && (!(n instanceof Deref))))
            {
                stop = true;
            }
        return !stop;
    }
}

class LocalFinder implements TreeExaminer
{


    boolean none  = true;
    int count     = 0;


    /**
     * This is called each time a node is visited, but before any subtrees are visited. If it returns
     *false the subtree below the node is not visited
     *
     * @param  n  Description of the Parameter
     * @return    Description of the Return Value
     */

    public boolean visit(Node n)
    {
        if(n instanceof Statement)
            {
                if(((Statement) n).hasLocal())
                    {
                        none = false;
                        count++;
                    }
            }
        return none;
    }


    /**
     * This is called after all subtrees have been visited
     *
     * @param  n  Description of the Parameter
     */
    public void leave(Node n)
    {
        if(n instanceof Statement)
            {
                if(((Statement) n).hasLocal())
                    {
                        none = false;
                    }
            }
    }

}



