Here are four files that comprise a unit for Turbo
Pascal 5.5, COMPLEX.  COMPLEX is a preliminary
implementation of the complex numbers as a TP 5.5
Object.  I have included support for the Streams
of the OBJECTS unit provided with TP 5.5.

One of the file is TRIG.PAS, the source code for a unit
TRIG.TPU designed to implement the trigonometric functions
that Turbo Pascal 5.5 does not include and the hyperbolic
functions.  It is provided on the Turbo Professional 5.0
BONUS diskette and is in the public domain.  The others are
TRIG.TPU, its compiled form, COMPLEX.PAS, my source code,
and COMPLEX.TPU, its compiled form.

Some of the algorithms are quite naive; I do intend to
improve them in the near future.  I will also extend this
package to the "extended" complex numbers; that is, the
Riemann sphere.  For those of you who are not familiar with
the Riemann sphere, this can be simply explained as adding a
"point at infinity" to the complex numbers.  In the future,
I will add units for the quaternions, and for various
classes of functions and curves over the complex numbers.

This package is copyright 1989 by Eric Robert Jablow.
However, you may modify it and use it in any non-profit
project you wish provided that you provide credit to me.

Please note that I have used two routines from the Turbo
Professional 5.0 package by TurboPower Software.  Should you
wish to recompile this unit, and should you not own that
fine project, you will need to modify the ReportError method
so that it does not use the OpenStdDev and HexPtr routines
from Turbo Professional 5.0 (and the StdErrHandle constant).
I used them to ensure that error messages would be sent to
DOS's standard error device and to print the address of any
ComplexNumber object that caused an error.

I have been extremely verbose in the COMPLEX.PAS unit;
unfortunately, that is the only documentation I have as yet.
I think that I could have used names like `Cos' or `Read'
for my methods instead of `ComplexCos' or `ReadNum'.
However, I decided not do anything that confusing for now.

Please send me comments, questions, bug reports, and
suggestions for later versions of this.

Here is a sample program to compute and print the 5 complex
fifth roots of 2.0 + 3.0i.

Program ComplexSample;

Uses Complex;

var
  j    : Integer;
  z    : ComplexNumber;
  root : ComplexNumber;

begin
  z.Init(2.0, 3.0);     { Set z equal to 2.0 + 3.0i. }
  root.RealInit(1.0);   { Set root equal to 1.0+0.0i }
                        { for now.                    }
                        { Both Init and RealInit are  }
                        { valid constructors.         }
  For j := 0 To 4 Do
    Begin
      root := z;        { Now root equals 2.0 + 3.0i.}

      root.BrRealPower( 0.2, 2 * j * Pi);

                        { Take the fifth root, using  }
                        { the correct branch of the   }
                        { complex logarithm.          }

      root.Display;     { Write root to the screen.   }
      WriteLn           { Go to next line.            }
    End
end; { SampleComplex }

This is not the most efficient manner of doing this, and I
didn't present all of the methods, but I think you can get
the flavor of what I've done.

P.S.  Because this was so preliminary, I compiled it with
range checking on and with support for the standalone Turbo
Debugger version 1.5.  Bye!

Respectfully,
Eric Jablow

