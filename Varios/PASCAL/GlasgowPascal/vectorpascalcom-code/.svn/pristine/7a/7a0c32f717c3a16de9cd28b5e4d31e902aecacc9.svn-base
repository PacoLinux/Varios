/*
\section{P6}
*/

/* 
 

Basic ia32 processor description int ilcg
 copyright(c) Paul Cockshott, University of Glasgow
 Feb 2000


\subsection{Declare types to correspond to internal ilcg types }
\begin{verbatim}
*/

type word=DWORD;
type uint32=DWORD;
type int32=DWORD;
type ieee64=QWORD;
type doubleword=QWORD;
type uint64=QWORD;
type int64=QWORD;
type octet=BYTE;
type uint8=BYTE; 
type int16=WORD;
type uint16=WORD;
type int8=BYTE;
type ieee32=DWORD;
type halfword=WORD;
pattern oplen means[word|halfword|octet];
/* \end{verbatim}
\subsection{compiler configuration flags }
\begin{verbatim}
*/
flag realLitSupported = 0;
/* \end{verbatim}
\subsection{Register declarations}

\begin{verbatim}
*/
register int64 EADX assembles ['eadx']; 
alias register int32 EAX= EADX (0:31) assembles ['eax'] ;
alias register int32 EDX= EADX (32:63) assembles ['edx'] ;
alias register uint64 EADXu=EADX(0:63)assembles['eadx'];
register int32 ECX assembles['ecx'] ;
register int32 EBX assembles['ebx'] ;
register int32 EBP assembles['ebp'] ;
alias register int32 FP = EBP(0:31) assembles ['ebp'];
reserved register int32 ESP assembles['esp'];
alias register int32 SP = ESP(0:31) assembles['esp'];
register int32 ESI assembles['esi'] ;
register int32 EDI assembles['edi'] ; 
/*register int32 fitemp assembles['dword[fitemp]'];/* not a real register */
alias register uint32 uax= EAX (0:31) assembles ['eax'] ;
alias register uint32 ucx= ECX (0:31) assembles ['ecx'] ;
alias register uint32 ubx= EBX (0:31) assembles ['ebx'] ;
alias register uint32 usi= ESI (0:31) assembles ['esi'] ;
alias register uint32 udi= EDI (0:31) assembles ['edi'] ;
alias register uint32 udx= EDX (0:31) assembles ['edx'];

/* use these for signed 8 bit values */
 alias register int8 AL = EAX(0:7) assembles['al'];
 alias register int8 BL = EBX(0:7) assembles['bl'];
 alias register int8 CL = ECX(0:7) assembles['cl'];
 alias register int8 DL = EDX(0:7) assembles['dl'];
 alias register int8 iBH = EBX(8:15) assembles['bh'];
 alias register int8 iCH = ECX(8:15) assembles['ch'];
 alias register int8 iDH = EDX(8:15) assembles['dh'];

/* use these for unsigned 8 bit values */
/* alias register uint8 AH = EAX(8:15) assembles['ah']; dont use this*/
 alias register uint8 BH = EBX(8:15) assembles['bh'];
 alias register uint8 CH = ECX(8:15) assembles['ch'];
 alias register uint8 DH = EDX(8:15) assembles['dh'];
 alias register uint8 uAL = EAX(0:7) assembles['al'];
 alias register uint8 uBL = EBX(0:7) assembles['bl'];
 alias register uint8 uCL = ECX(0:7) assembles['cl'];
 alias register uint8 uDL = EDX(0:7) assembles['dl'];

/* use these for untyped 8 bit values */
 alias register octet oAL = EAX(0:7) assembles['al'];
 alias register octet oBL = EBX(0:7) assembles['bl'];
 alias register octet oCL = ECX(0:7) assembles['cl'];
 alias register octet oDL = EDX(0:7) assembles['dl'];

 alias register int16 AX =EAX(0:15)assembles['ax'];
 alias register int16 BX =EBX(0:15)assembles['bx'];

 alias register int16 DX =EDX(0:15)assembles['dx'];
 alias register int16 CX =ECX(0:15)assembles['cx'];
 alias register uint16 uAX =EAX(0:15)assembles['ax'];
 alias register uint16 uBX =EBX(0:15)assembles['bx'];

 alias register uint16 uDX =EDX(0:15)assembles['dx'];
 alias register uint16 uCX =ECX(0:15)assembles['cx'];
 alias register halfword SI = ESI(0:15)assembles['si'];
 alias register halfword DI = EDI(0:15)assembles['di'];
 
 
register stack(4096)int32 mainSTACK assembles[ 'mainSTACK'];
                  /* \end{verbatim}
\subsection{Register sets }
There are several intersecting sets of registers defined
for different instructions. Note that the ECX  and CL,CH registers
are named last  in their   lists to increase the chance
that they are free for sepecial instructions that need them.
\begin{verbatim}
*/
pattern indexreg means[EAX|EBX|EDX|EDI|ESI|EBP|ESP|EAX|ECX];
pattern accumulators means[EAX|EDX|ECX|EBX];
pattern ireg means [  indexreg]  ;
pattern ureg means [ ubx|udi|usi|udx|ESP|ucx|EBP|uax ]  ;

pattern reg means [ireg|ureg];

/* Note that the order of the byte registers is chosen to keep the ah and al regs
   free for instructions that require themspecifically, particularly
conditional expressions on the floating point stack, that return boolean
results in al */
pattern bireg means[ BL|DL|AL|iBH|iDH|iCH|CL];
pattern bureg means[BH|DH|uAL|uBL|uDL|uCL|CH];
pattern boreg means[oBL|oAL|oDL|oCL];
pattern biacc means[AL];
pattern buacc means[uAL];
pattern bacc means[biacc|buacc];
pattern nonacc means[EBX|EDI|ESI|ECX];
pattern noncount means[EDX|EBX|EDI|ESI|EAX];
pattern bnoncount means[ BL|DL|AL|iBH|iDH|iCH];
pattern bunoncount means[BH|DH|uAL|uBL|uDL|CH];
pattern wnoncount means[BX|AX|DX|SI|DI];
pattern noncountreg means[bnoncount|bunoncount|noncount|wnoncount];
pattern binonacc means[BL|DL|CL];
pattern bunonacc means[BH|DH|uDL|uCL|CH];
pattern bnonacc means[binonacc|bunonacc];
pattern breg means[bnoncount|bunoncount|bnonacc|bureg|boreg|bireg|bacc];
pattern swreg means[BX|AX|DX|CX];
pattern uwreg means[uBX|uDX|uCX];
pattern untypedwreg means[SI|DI];
pattern wreg means[swreg|uwreg|untypedwreg];
pattern pushreg means[reg|wreg]; /* these are directly pushable */
/*pattern dummyreg means[fitemp];*/
pattern dpushreg means[reg];
pattern anyreg means[ breg|wreg|reg];
pattern signedreg means[bireg|swreg|ireg];
pattern unsignedreg means[bureg|ureg|uwreg|ureg];
pattern acc means[EAX];
pattern qacc means[EADX]; 
pattern dacc means[EDX];
pattern wacc means[AX];
pattern ebxacc means[EBX];
pattern ebxbacc means[BL];
pattern ecxacc means[ECX];
pattern ecxbacc means[CL];
pattern ecxbuacc means[uCL];
pattern ecxuacc means[ucx];
pattern modreg means [ECX];
pattern sourcereg means [ESI];
pattern destreg means [EDI];
pattern countreg means [ECX];
pattern eadxu means [EADXu];
pattern shiftcountreg means [ecxbacc|ecxbuacc|ecxacc|ecxuacc];

/*\end{verbatim}

\subsection{Operator definition}
This section defines operations that can be used to parameterise
functions.
\begin{verbatim}

*/
operation add means  +  assembles [ 'add'];
/* */operation and means  AND  assembles[ 'and'];
operation or means OR assembles['or'];
operation xor means XOR assembles['xor'];/* */
operation sub means  -  assembles [ 'sub'];
operation mul means * assembles ['mul'];
operation imul means * assembles ['imul '];
operation bel means < assembles ['b'];
operation lt means < assembles ['l'];
operation ab means > assembles ['a'];
operation gt means > assembles ['g'];
operation eq means = assembles ['z'];
operation be means <= assembles ['be'];
operation le means <= assembles ['le'];
operation ae means >= assembles ['ae'];
operation ge means >= assembles ['ge'];
operation ne means <> assembles ['nz'];
operation shiftleft means << assembles ['l'];
operation shiftright means >> assembles ['r'];

pattern condition means[ne|ge|le|eq|gt|lt];
pattern equals means[eq];
pattern eqcondition means[ne|eq];
pattern unsignedcondition means[ne|ae|be|eq|ab|bel];
pattern operator means[add | sub|imul|and|or|xor];
pattern logoperator means[and|or|xor];

pattern nonmultoperator means[add|sub|logoperator];
pattern saddoperator means[add|imul|and|or|xor];
pattern shiftop means [shiftleft|shiftright];

/*

\end{verbatim}
\subsection{Data formats}
Here we define ilcg symbols for the types that
can be used as part of instructions.
\begin{verbatim}
*/
pattern unsigned means[uint32|uint8|uint16];
pattern signed means[   int8 |   int16|int32 ];
pattern int means[   int8 |   int16 |int32| uint32|uint8|uint16];
pattern double means[ieee64] ;
pattern float  means[ieee32];
pattern real means [ieee64|float];
pattern byte means[uint8|int8|octet];

pattern word32 means[int32|uint32|word];
pattern word16 means[int16|uint16|halfword];
pattern wordupto32 means[byte|word16|word32];
pattern dataformat means[octet|word];
pattern longint means [int32|uint32];
pattern hiint means[int32|int64|int16];
pattern two(type t)means[2] assembles['2'];
pattern four(type t)means[4] assembles['4'];
pattern eight(type t)means[8] assembles['8'];
pattern integer64 means[int64|uint64];

pattern scale means[two|four|eight];

/* \end{verbatim}

Define the address forms used in lea instructions
these differ from the address forms used in other instructions as the
semantics includes no memory reference.
Also of course register and immediate modes are not present.

\begin{verbatim} */
pattern labelf(label l)
	means [l]
	assembles[l];
pattern sconst(signed s)means[const s]assembles[s];
pattern uconst(unsigned s) means [const s] assembles[s];
pattern lconstf means[sconst|labelf];
pattern labelconstf(lconstf l,lconstf s)
	means [+(l, s)]
	assembles[l'+'s];
pattern constf(signed s)
	means[const s]
	assembles [s];
pattern offset means[constf|labelf|labelconstf|uconst];
pattern regindirf(reg r)
	means[^(r) ]
	assembles[ r ];

pattern simplescaled(reg r1,scale s)
	means[*(^(r1),s)]
	assembles[r1 '*'s];

pattern negcompscaled(reg r1,scale s,offset o)
	means[*(-(^(r1),o),s)]
	assembles[r1 '*'s'-(' s'*'o')'];
pattern compscaled(reg r1,scale s,offset o)
	means[*(+(^(r1),o),s)]
	assembles[r1 '*'s'+(' s'*'o')'];
pattern scaled means[compscaled|negcompscaled|simplescaled];
pattern baseminusoffsetf(reg r, offset s ) 
	means[-(   ^(r) ,  s)]
	assembles[  r '-(' s ')'];
pattern baseplusoffsetf(reg r, offset s )
	means[+(   ^(r) ,  s)]
	assembles[  r '+' s ];
pattern scaledIndexPlusOffsetf( scaled s, offset offs)
	means[+(s, offs)]
	assembles[ s '+' offs];

pattern nsreg means[EDI|ESI|EBX|EBP|EAX|EDX|ECX];
address pattern basePlusScaledIndexf(reg r1,nsreg r2,scale s)
	means[+(^(r1),*(^(r2),s))]
        assembles[  r1 '+' r2 '*'  s ]; 
/*address pattern basePlusScaledIndexf(reg r1,scaled s)
	means[+(^(r1),s)]
        assembles[  r1 '+'   s   ];*/
address pattern basePlusScaledIndexPlusOffsetf(reg r1,scaled s,offset off,longint t)
	means[+(^(r1),+(s,off)) ]
        assembles[  r1 '+' s '+'off  ];
address pattern basePlusScaledIndexPlusOffsetf2(reg r1,scaled s,offset off,longint t)
	means[+(s,+(^(r1),off)) ]
        assembles[  r1 '+' s '+'off  ];
address pattern basePlusIndexPlusOffsetf(reg r1,reg r2,offset off)
	means[+(^(r1),+(^(r2),  off))]
        assembles[  r1 '+' r2 ' +'off  ];
address pattern basePlusIndexf(reg r1,reg r2)
	means [+(^(r1),^(r2))]
	assembles[  r1 '+' r2   ];
pattern directf(unsigned s) 
	means[const s]
	assembles[  s  ];
pattern udirectf(int s) 
	means[const s]
	assembles[  s  ];

pattern riscaddr means[offset|baseplusoffsetf|regindirf];
/*\end{verbatim}\subsection{Choice of effective address}
 This contains the useful formats for the load effective address instruction.
The pattern 
 regindirf is excluded here as it adds nothing
   we do not have already from mov instructions.

\begin{verbatim}
*/
pattern uncasteaform means[directf  |udirectf|
	labelf|  labelconstf|
	
        scaledIndexPlusOffsetf|	
	basePlusScaledIndexPlusOffsetf| 
	basePlusScaledIndexPlusOffsetf2|
	scaledIndexPlusOffsetf|
	basePlusScaledIndexf| 
	baseplusoffsetf |

	basePlusIndexPlusOffsetf| 
	baseminusoffsetf
	|basePlusIndexf
];
pattern eaform(uncasteaform f,longint t)  /* allow the address expression to be cast to an integer */
	means[(t)f]
	assembles[f];
/*\end{verbatim}
 \subsection{ Formats for all memory addresses}
 \begin{verbatim}*/
pattern addrform means[eaform|regindirf];


/** \end{verbatim}
define the address patterns used in other instructions

\begin{verbatim}

*/





pattern maddrmode(addrform f)
	means[mem(f) ]
	assembles[ '[' f ']' ];
pattern memrisc(riscaddr r)
	means[mem(r)]
	assembles['['r']'];
pattern gmaddrmode means[maddrmode];
pattern immediate(signed s)means [const s] assembles [s];
pattern intimmediate(int s)means [const s] assembles [s];
pattern uimmediate(unsigned s)means[const s] assembles[s];
pattern jumpmode means[labelf|maddrmode];
pattern addrmode means[maddrmode|anyreg];
pattern uwaddrmode means[maddrmode|uwreg];
pattern uaddrmode means[maddrmode|ureg];
pattern baddrmode means[maddrmode|breg];
pattern waddrmode means[maddrmode|reg];
pattern wmemdummy means[maddrmode];
pattern regshift(shiftcountreg r)means[^(r)] assembles['cl'];
pattern shiftcount means[immediate|regshift];
pattern regaddrop(addrmode r)means[^(r)] assembles[r];
pattern uwregaddrop(uwaddrmode r)means[^(r)]assembles[r];
pattern regaddrimmediate means[intimmediate|maddrmode|regaddrop];
pattern uwregaddrimmediate means[uimmediate|uwregaddrop];
/* \end{verbatim}

\subsection{Instruction patterns for the  386}
\subsubsection{Stack operations }

\begin{verbatim}
*/

instruction pattern STACKSTORE(reg r1 )
	means[(ref int32)mem((int32)POP(mainSTACK)):=^(r1)]
	assembles['xchg DWORD[esp],'r1'\n  pop DWORD['r1']\n   '];
instruction pattern STACKWSTORE(wreg r1 )
	means[(ref halfword)mem((int32)POP(mainSTACK)):=^(r1)]
	assembles['xchg DWORD[esp],esi\n  mov word[esi],'r1'\n  pop esi'];
instruction pattern STACKBSTORE(breg r1 )
	means[(ref octet)mem((int32)POP(mainSTACK)):=^(r1)]
	assembles['xchg DWORD[esp],esi\n  mov BYTE[esi],'r1'\n  pop esi'];
instruction  pattern SMLIT( nonmultoperator op,offset s) 
        means[ PUSH(mainSTACK,(int32)op((int32) POP(mainSTACK), s))] 
    	assembles[op '  DWORD[esp] ,' s];

instruction  pattern SMULIT( nonmultoperator op,offset s) 
        means[ PUSH(mainSTACK,(int32)*((int32) POP(mainSTACK), s))] 
    	assembles['xchg eax,DWORD[esp]\n imul eax ,' s'\n xchg eax,DWORD[esp]' ];

instruction pattern SADD(saddoperator op)
	means [PUSH(mainSTACK,(longint)+((longint)POP(mainSTACK),(longint)POP(mainSTACK)))]
	assembles['xchg eax,DWORD[esp]\n add DWORD[esp+4],eax\n pop eax'];
 
instruction pattern SOP(saddoperator op)
	means [PUSH(mainSTACK,(longint)op((longint)POP(mainSTACK),(longint)POP(mainSTACK)))]
	assembles['xchg eax,DWORD[esp]\n 'op' eax,DWORD[esp+4]\n mov DWORD[esp+4],eax\n pop eax'];
instruction  pattern SMR( nonmultoperator op,reg r1) 
        means[ PUSH(mainSTACK,(int32)op( (longint)POP(mainSTACK),(longint)^( r1)))] 
    	assembles[op '  DWORD[esp] ,' r1];
instruction  pattern SMRSHIFT( shiftop op,shiftcountreg r1) 
        means[ PUSH(mainSTACK, op( (int32)POP(mainSTACK),^( r1)))]
    	assembles['xchg eax, [esp]\n'
                  'sh'op '  eax ,cl' 
                  '\n xchg eax,[esp]']; 
instruction  pattern BSMR( nonmultoperator op,breg r1) 
        means[ PUSH(mainSTACK,(octet)op( (int8)POP(mainSTACK),^( r1)))]
    	assembles[op '  byte[esp] ,' r1]; 

instruction  pattern SMRADD( reg r1) 
        means[ r1:=(int32)+((longint) POP(mainSTACK),^( r1))] 
    	assembles['add 'r1',DWORD[esp] \n add esp,4']; 

instruction  pattern SMRP( nonmultoperator op,reg r1,type t)
        means[ PUSH(mainSTACK,(ref t)op( (longint)POP(mainSTACK),(longint)^(r1)))] 
    	assembles[op '  DWORD[esp] ,' r1]; 
instruction pattern RPUSH(dpushreg r)
	means[PUSH(mainSTACK,^(r))] 
	assembles['push '  r];
instruction pattern RPUSHE(ureg r, integer64 t) 
	means[PUSH(mainSTACK,(t)EXTEND(^(r)))]
	assembles[' push dword 0 ; extend 'r' to 64'
                  '\n push '  r];
instruction pattern POPEADXu(type t,eadxu r)
	means[r:=(uint64)POP(mainSTACK)]
	assembles['pop eax\n pop edx'];
instruction pattern STOREAXDu(eadxu r,destreg d)
	means[(ref uint64)mem(^(d)):=^(r)]
	assembles['mov eax,['d']\n mov edx,['d'+4]'];
pattern eadxi means[EADX];
instruction pattern LOADEADX(eadxi r,destreg d)
	means[r:=^((ref doubleword)mem(^(d)))]
	assembles['mov ['d'],eax\n mov ['d'+4],edx'];
instruction pattern RPOP(dpushreg r,type t) 
	means[(ref t)r:=(t)POP(mainSTACK)] 
	assembles['pop  '  r];	
instruction pattern BPUSH(bureg r) 
	means[PUSH(mainSTACK,^(r))]
	assembles['push dword 0\n mov BYTE[esp],'r];
instruction pattern BSPUSH(baddrmode r)
	means[PUSH(mainSTACK,(int8)^(r))]
	assembles['push esi\n movsx esi, BYTE 'r'\n xchg esi,[esp]'];
instruction pattern BSPOP(bireg r)
	means[r:=(octet)POP(mainSTACK)]
	assembles['mov  '  r',BYTE[esp]\n add esp,4']; 
instruction pattern BPOP(bureg r) 
	means[r:=(octet)POP(mainSTACK)]
	assembles['mov  '  r',BYTE[esp]\n add esp,4'];	
instruction pattern REFPOP(addrmode r,type t,type t2)
	means[(ref ref t)r:=(ref t2)POP(mainSTACK)] 
	assembles['pop DWORD '  r];


instruction pattern REFPOP2(addrmode r,type t) 
	means[(ref ref t)r:=( word)POP(mainSTACK)] 
	assembles['pop dword '  r];
instruction pattern SDEREFDOUBLEw(int t)
	means[PUSH(mainSTACK,(doubleword)^(mem((word)POP(mainSTACK))))]
	assembles['xchg esi,[esp]\n push dword [esi]\n mov esi, [4+esi]  \n  xchg esi,[4+esp]'];

instruction pattern WPOP(addrmode r,type t)
	means[(ref ref t)r:=(word)POP(mainSTACK)] 
	assembles['pop DWORD '  r];
instruction pattern MEMPOP(memrisc m)
	means[(ref int32)m:=(int32)POP(mainSTACK)]
	assembles['pop DWORD 'm];		 
instruction pattern LITPUSH(offset s) 
	means[PUSH(mainSTACK, s)] 
	assembles['push DWORD '  s];
instruction pattern MEMPUSH(maddrmode m)
	means[PUSH(mainSTACK,(word)^( m))] 
	assembles['push DWORD ' m]; 
instruction pattern DMEMPUSH(eaform ea) 
	means[PUSH(mainSTACK,(doubleword)^((ref doubleword)mem(ea)))] 
	assembles['push DWORD['ea'+4]\n push DWORD['ea']'];

instruction pattern STACKLOAD(word32 t)
	means[PUSH(mainSTACK,^((ref t)mem((int32)POP(mainSTACK))))]
	assembles['xchg DWORD[esp],eax\n  mov eax,DWORD[eax]\n  xchg DWORD[esp],eax'];
instruction pattern REFPUSH(maddrmode m,type t) 
	means[PUSH(mainSTACK,(ref t)^(m))] 
	assembles['push DWORD ' m];
instruction pattern SDEREF(int t)
 means[PUSH(mainSTACK,(t)^(mem((int32)POP(mainSTACK))))]
 assembles['xchg esi,[esp]\n mov esi,dword[esi]\n  xchg esi,[esp]'];
instruction pattern SDEREFDOUBLEWORD(int t)
 means[PUSH(mainSTACK,(doubleword)^(mem((int32)POP(mainSTACK))))]
 assembles['xchg esi,[esp]\n push dword[esi]\n mov esi,dword[esi+4]\n  xchg esi,[esp+4]'];

/* \end{verbatim}
\subsubsection{Data movement  to and from registers }
\begin{verbatim}
*/
instruction pattern SELECT(reg r1,reg r2,addrmode r3,wordupto32 t)
	means[(ref t) r1:=OR(AND((t)^(r1),(t)^(r2)),AND((t)^(r3),NOT(^(r2))))]
	assembles[
		'and 'r1      ','     		r2         '\n'
                'not 'r2                         '\n'
		'and 'r2      ','   t ' ' 	r3         '\n'
		'or 'r1       ','     		r2];
instruction  pattern LOAD(maddrmode rm, anyreg r1, type t) 
        means[ (ref t) r1:= (t)^(rm )] 
	assembles['mov ' r1 ',' t ' ' rm];
instruction  pattern LOADW(maddrmode rm, wreg r1, word16 t) 
        means[ (ref t) r1:= (t)^(rm )] 
	assembles['mov ' r1 ',' t ' ' rm];
instruction  pattern LOADB(maddrmode rm, breg r1) 
        means[  r1:= (octet)^(rm )] 
	assembles['mov ' r1 ','  'byte ' rm];
instruction pattern MOVZXB(reg r1, baddrmode rm)
	means[  r1:=EXTEND( (uint8)^( rm) )]
	assembles['movzx ' r1 ', BYTE  'rm]; 
instruction pattern MOVZXB2(reg r1, baddrmode rm) 
	means[  r1:=EXTEND( (uint8)^( rm) )]
	assembles['movzx ' r1 ', BYTE  'rm]; 

instruction pattern MOVSXB(reg r1,baddrmode rm) 
	means[r1:=(int32)EXTEND( (int8)^( rm) )]
	assembles['movsx 'r1',BYTE   'rm];
instruction pattern MOVZXBW(uwreg r1, baddrmode rm)
	means[  r1:= EXTEND((uint8)^(rm))]
	assembles['movzx ' r1 ', BYTE  'rm];  
instruction pattern MOVSXBW(swreg r1, baddrmode rm)
	means[  r1:= EXTEND(^(rm))]
	assembles['movsx ' r1 ', BYTE  'rm];  
instruction pattern MOVZXW(reg r1, uwaddrmode rm) 
	means[  r1:=EXTEND((uint16)^(rm))]
	assembles['movzx ' r1 ', word  'rm]; 
instruction pattern MOVSXW(reg r1, wreg rm) 
	means[  r1:=(int32)EXTEND(^(rm))]
	assembles['movsx ' r1 ', WORD   'rm]; 
instruction pattern Tob(reg r, breg b)
	means[b:= (octet) ^( r)]
        assembles['push ' r '\nmov 'b', [esp] '  '\n add esp ,4' ];



instruction pattern MOVSBW(wreg r1, breg rm) 
	means[  r1:=(int16)EXTEND(^(rm))]
	assembles['movsx ' r1 ',   'rm];
instruction pattern MOVZBW(wreg r1, bureg rm) 
	means[  r1:=(int16)EXTEND(^(rm))]
	assembles['movzx ' r1 ',   'rm];


instruction pattern ToBYTE(reg r, breg b)
	means[b:= (octet) ^( r)]
        assembles['push ' r '\nmov ' b ',BYTE[esp]\nadd esp,4 ' ];



instruction pattern STOREBR(baddrmode rm, breg r1)
        means[  (ref octet ) rm:= ^(r1) ]
	assembles['mov BYTE 'rm',' r1];
instruction pattern STORER(memrisc rm, reg r1, word32 t)
        means[  (ref t) rm:= ^( r1) ]
	assembles['mov ' t ' 'rm',' r1];
 instruction pattern STOREWR(memrisc rm, wreg r1, word16 t)
        means[  (ref t) rm:= ^( r1) ]
	assembles['mov ' t ' 'rm',' r1];
instruction  pattern NULMOV(anyreg r3, type t)
	means[(ref t)r3:=^((ref t)r3)]
        assembles[';nulmov ' r3  r3];
instruction  pattern NONNULMOV(anyreg r3, anyreg r4, type t)
	means[(ref t)r3:=^((ref t)r4)]
        assembles['mov ' r3 ',' r4];
instruction  pattern STORELIT(addrmode rm,  type t, int s)
        means[ (ref t) rm:= (t)const s  ]
	assembles['mov ' t ' 'rm ','  ' ' s];
instruction  pattern CLEARREG(reg rm,  type t, int s)
        means[ (ref t) rm:= (t)0  ]
	assembles['xor '  rm ','  rm];
/*
\end{verbatim}
\subsubsection{Register to register arithmetic }
\begin{verbatim}
*/ 
instruction  pattern RMLIT(nonmultoperator op,addrmode rm,  type t, offset sm)
        means[  (ref t) rm:= op(^(rm),(t) sm)  ]
	assembles[op '  ' t ' ' rm ',' sm];
instruction  pattern MLIT(nonmultoperator op,memrisc rm,  type t, offset sm)
        means[  (ref t) rm:= op(^(rm),(t) sm)  ]
	assembles[op '  ' t ' ' rm ',' sm];
instruction  pattern INC(addrmode rm,int t)
	means[(ref t)rm:=   + (^(rm),1)]
	assembles['inc ' t ' ' rm];
instruction  pattern DEC(addrmode rm,int t)
	means[(ref t)rm:=   - ((t)^(rm),1)]
	assembles['dec ' t ' ' rm];
instruction  pattern SHIFT(shiftop op, shiftcount s, noncountreg r,type t)
	means[(ref t) r:= op(^(r),s)]
	assembles['sh' op' ' r ', 's];
instruction  pattern GENSHIFT(shiftop op, breg s, noncountreg r,type t)
	means[(ref t) r:= op(^(r),s)]
	assembles['xchg cl,'s'\n sh' op' ' r ', cl\n xchg cl,'s];
instruction  pattern RMR( nonmultoperator op,memrisc rm,anyreg r1,wordupto32 t)
        means[ (ref t) rm :=op((t) ^( rm),(t)^( r1))]
    	assembles[op '  '   t ' ' rm ',' r1]; 
instruction pattern RMRAdd(addrmode rm, anyreg r1, wordupto32 t)
 		means[ (ref t) rm :=+((t) ^( rm),(t)^( r1))]
    	assembles['add'     ' ' rm','t ' ' r1]; 
instruction  pattern ADDRMR( nonmultoperator op,memrisc rm,anyreg r1,wordupto32 t)
        means[ (ref t) rm :=+((t) ^( rm),(t)^( r1))]
    	assembles[ 'add  '   t ' ' rm ',' r1]; 
instruction  pattern RMRB( nonmultoperator op,addrmode rm,breg r1,byte t)
        means[ (ref t) rm :=op((t) ^( rm),(t)^( r1))]
    	assembles[op '  '   t ' ' rm ',' r1]; 
instruction pattern nulbass(breg r1,byte t)
	means[(ref t)r1:=(t)^(r1)]
	assembles['; nulbas'];
instruction pattern ADDUSB(addrmode fm,breg r1,breg rm)
	means[ rm:= +:((uint8)^(rm),^(r1))]
	assembles[ 'add  ' rm ',' r1 '\n jnc $+4\n mov ' rm',255\n nop\n nop']; 
instruction pattern SUBUSB(breg r1,breg rm)
	means[ rm:= -:((uint8)^(rm),^(r1))]
	assembles[ 'sub  ' rm ',' r1 '\n jnc $+4\n mov ' rm',0\n nop\n nop'];
instruction pattern ADDSSB(breg r1,breg rm)
	means[ rm:=(int8) +:((int8)^(rm),^(r1))]
	assembles[ 'add  ' rm ',' r1 '\n jno $+10\n jg $+6\n mov 'rm' ,-128 \n jng $+4\n mov ' rm',127\n '];
instruction pattern MULTSSB(breg r1,bnonacc r2)
	means[r2:=*:(^(r2),^(r1))]
	assembles['push ax\n mov al,'r1'\n imul  'r2'\n shr ax,7\n mov 'r2',al\n pop ax'];
 
instruction pattern MULTSSBAL(bacc r1,bnonacc r2)
	means[r1:=*:(^(r1),^(r2))]
	assembles['imul  'r2'\n shr ax,7'];

instruction pattern SUBSSB(addrmode fm,breg r1,breg rm)
	means[ rm:= (int8)-:((int8)^(rm),^(r1))]
	assembles[ 'sub  ' rm ',' r1 '\n jno $+10\n jg $+6\n mov 'rm' ,-128 \n jng $+4\n mov ' rm',127\n nop\n nop'];
instruction pattern UINT8MAX(breg r1,breg r2)
        means[ (ref uint8)r1:=MAX((uint8)^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n ja $+4\n mov 'r1','r2];
instruction pattern INTMAX(reg r1,reg r2)
        means[ r1:=MAX(^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n jl $+4\n mov 'r1','r2];
 

instruction pattern INTABS(reg r1)
        means[ r1:=ABS(^(r1))]
	assembles['sub '  r1  ',0'      '\n jns $+4\n neg 'r1];
instruction pattern UINT8MIN(breg r1,breg r2)
        means[ (ref uint8)r1:=MIN((uint8)^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n jna $+4\n mov 'r1','r2];
instruction pattern INT8MAX(breg r1,breg r2)
        means[ (ref int8)r1:=MAX((int8)^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n jg $+4\n mov 'r1','r2];
instruction pattern INT8MIN(breg r1,breg r2)
        means[ (ref int8)r1:=MIN((int8)^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n jl $+4\n mov 'r1','r2];
instruction pattern LEA(reg r1, eaform ea)
	means [r1:=ea]
        assembles ['lea ' r1 ',[' ea ']' ];
instruction pattern NOTOP(addrmode rm, type t)
	means[(ref t)rm:= NOT((t)^(rm))]
	assembles['not 't ' ' rm];
instruction pattern Negate(anyreg r1,type t)
	means[(ref t)r1:= -((t)0,( t)^(r1))]
	assembles ['neg ' ' '  r1];
instruction pattern MNegate(anyreg r1,type t)
	means[(ref t)r1:= *((t)-1,( t)^(r1))]
	assembles ['neg '  ' '  r1];
instruction  pattern RLIT(operator op,pushreg r0,  type t, signed sm)
        means[r0:=  op(^( r0), const sm)  ]
	assembles[op '  '  r0 ',' sm];
instruction pattern RRint32( operator op, reg r1, reg r2)
        means[r1:=(int32) op((int32) ^(  r1),(int32)^(  r2))]
	assembles[op ' ' r1 ',' r2];
instruction pattern RRD( operator op, indexreg r1, indexreg r2)
        means[r1:= (int32)op( ^(  r1),^(  r2))]
	assembles[op ' ' r1 ',' r2';RRD'];
instruction pattern RR( nonmultoperator op, anyreg r1, anyreg r2, int t)
        means[(ref t)r1:=(t) op((t) ^( (ref t) r1),(t)^(  r2))]
	assembles[op ' ' r1 ',' r2';RR'];
instruction pattern RRPLUS(  anyreg r1, maddrmode r2, int t)
        means[r1:=(t) +((t) ^( (ref t) r2),(t)^( (ref t) r1))]
	assembles['add ' r1 ',' r2];
 
instruction  pattern RRM(operator op, pushreg r1, maddrmode rm, int t)
        means [r1:=(t) op((t) ^(r1),(t)^( rm))] 
        assembles[op ' ' r1 ',' rm ] ;
pattern bnonacreg means[DH|DL|BH|BL|CH|CL];
pattern baccreg means[AL];
pattern baccregmode means[maddrmode|baccreg];
pattern bnonacregmode means[maddrmode|bnonacreg];
instruction pattern fastBIDIV(baccreg r1,bnonacregmode r2)
        means[r1:=div((int8)^(r1),(int8)^(r2))]
	assembles[' movsx ax,'r1'\n idiv BYTE 'r2 ];
instruction pattern BIDIV(baccreg r1, bnonacregmode r2,baccregmode r3)
        means[r3:=div((int8)^(r1),(int8)^(r2))]
	assembles[' movsx ax,'r1'\n idiv BYTE 'r2'\n mov BYTE 'r3',al'];
instruction pattern BUDIV(buacc r1, bnonacregmode r2,bnonacregmode r3)
        means[r3:=div((uint8)^(r1),(uint8)^(r2))]
	assembles[' movzx ax,'r1'\n idiv BYTE 'r2'\n mov BYTE 'r3',al'];
instruction pattern BIMUL(baccreg r1, bnonacreg r2)
        means[r2:=*((int8)^(r1),(int8)^(r2))]
	assembles['imul BYTE 'r2'\n mov BYTE 'r2',al'];
instruction pattern fastIMUL(acc a,dacc d)
	means[(ref int32)a:=*((int32)^(a),^(d))]
	assembles['imul edx'];
instruction pattern CDQ(qacc r1,acc r2)
	means[r1:=EXTEND(^(r2))]
	assembles['cdq'];
instruction pattern IDIV(acc r1, qacc r2, indexreg r3)
	means[r1:=div(^(r2),^(r3))]
	assembles['idiv 'r3];
instruction pattern RIDIV(indexreg r1, qacc r2, indexreg r3)
	means[r1:=div(^(r2),^(r3))]
	assembles['idiv 'r3'\n mov 'r1',eax'];

pattern nonaccreg means[EDI|ESI|EBX|EBP|ECX];
instruction pattern IDIVstack(nonaccreg r2)
   	means[PUSH(mainSTACK,(int32)div((int32)POP(mainSTACK),(int32)^(r2))) ]
	assembles[' xchg eax,[esp]\n push edx\n'
              ' cdq\n'
              ' idiv   'r2'\n' 
              ' pop edx\n' 
              ' xchg eax,[esp]\n\n '];
instruction pattern IMODstack(nonaccreg r2)
   	means[PUSH(mainSTACK,(int32)MOD((int32)POP(mainSTACK),(int32)^(r2))) ]
	assembles[' xchg eax,[esp] ; IMODstack \n push edx\n'
              ' cdq\n'
              ' idiv   'r2'\n' 
             
              ' xchg eax,[esp+4]\n '
			  ' mov edx,[esp+4]\n'
			  ' pop edx\n' ];

instruction pattern RUWDIV(uwreg r1, wreg r2)
	means[r1:=div(^(r1),^(r2))]
	assembles[';RUWDIV\n push eax\n push edx \n push ecx\n movzx eax,'r1'\n cdq\n movzx ecx,'r2'\n idiv   ecx\npop ecx\n pop edx\n mov 'r1',ax \n pop eax'];
instruction pattern SIDIV(nonacc r1,nonacc r2)
   	means[r1:=div((int32)^(r1),^( r2)) ]
	assembles['push eax\n push edx\n mov eax,'r1'\n cdq\n idiv   ' r2 '\n pop edx\n mov 'r1',eax \n pop eax'];
instruction pattern UDIV(acc r1,modreg r2)
   	means[PUSH(mainSTACK,div((uint32)^(r1),^( r2))) ]
	assembles['push edx\n xor edx,edx\n div   ' r2 '\n xchg eax,DWORD[esp]\n xchg eax,edx'];
instruction pattern IMULLIT(pushreg r1,addrmode rm, signed s)
	means[(ref int32)r1:=*(^(rm),const s)]
	assembles['imul 'r1',DWORD 'rm','s];

instruction pattern IMOD(acc r1, modreg r2)
        means[PUSH(mainSTACK,(int32)MOD((int32)^(r1),^( r2))) ]
	assembles['push edx; IMOD \n cdq\n idiv   ' r2 '\n xchg edx,DWORD[esp]'];
instruction pattern UMOD(acc r1, modreg r2)
        means[PUSH(mainSTACK,MOD((uint32)^(r1),^( r2))) ]
	assembles['push edx; UMOD\n xor edx,edx\n div   ' r2 '\n xchg edx,DWORD[esp]'];
instruction pattern BIMOD(baccreg r1, bnonacreg r2)
        means[r2:=MOD((int8)^(r1),(int8)^(r2))]
	assembles[' movsx ax,'r1' ;BIMOD\n idiv 'r2'\n mov 'r2',ah'];

 
instruction pattern MODFFFF(wreg r)
	means[r:=MOD(^(r),65535)]
	assembles[' '];
instruction pattern DIV8(ureg r)
	means[r:=div((uint32)^(r),8)]
	assembles['shr 'r ',3'];

instruction pattern MOD16(reg r)
	means[r:=MOD(^(r),16)]
	assembles['and 'r ',15'];
instruction pattern MOD4(reg r)
	means[r:=MOD(^(r),4)]
	assembles['and 'r ',3'];
instruction pattern MOD2(reg r)
	means[r:=MOD(^(r),2)]
	assembles['and 'r ',1'];	
instruction pattern PLANT(label l)
	means[l]
	assembles[l ':'];  
instruction pattern PLANTRCONST( double r,type t)
	means[loc (t)r]
	assembles[ 'dq ' r];
instruction pattern PLANTICONST( longint r,type t) 
	means[loc (t) r] 
	assembles[ 'dd ' r]; 
 
instruction pattern PLANTSCONST( float  r,type t)
	means[loc (t) r]
	assembles[ 'dd ' r];
instruction pattern PLANTBCONST( byte r,type t) 
	means[loc (t) r]
	assembles[ 'db ' r]; 
instruction pattern PLANTWCONST( word16 r,type t) 
	means[loc (t) r] 
	assembles[ 'dw ' r];
	/*
\end{verbatim}
\subsubsection{Control transfers and tests }
\begin{verbatim}
*/
instruction pattern FAIL(int i)
	means[interrupt i]
	assembles['int 'i];
instruction pattern GOTO(jumpmode l)
	means[goto l]
	assembles['jmp ' l];
instruction pattern IFLITGOTO(label l,addrmode r1,signed r2,condition c,signed t,int b)
	means[if((b)c((t) ^(r1),const r2))goto l]
	assembles[' cmp 't' ' r1 ',  '  r2 '\n j' c ' near  '  l];

instruction pattern IFULITGOTO(label l,addrmode r1,unsigned r2,unsignedcondition c,unsigned t,int b)
	means[if((b)c((t) ^(r1),(t)const r2))goto l]
	assembles[' cmp 't' ' r1 ',  '  r2 '\n j' c ' near  '  l];
instruction pattern BIFLITGOTO(label l,baddrmode r1,signed arg2,condition c,signed t)
	means[if(c((t) ^(r1),const arg2))goto l]
	assembles[' cmp 't' ' r1 ',  't  arg2 '\n j' c ' near  '  l];
instruction pattern IFGOTOB(label l,bireg r1,regaddrimmediate r2,condition c,signed t,int b)
	means[if((int8)c( ^(r1),(int8) r2))goto l]
	assembles['cmp ' r1 ',byte' '  '  r2 '\n j' c ' near  ' l];
instruction pattern IFGOTOW(label l,wreg r1,regaddrimmediate r2,condition c,signed t,int b)
	means[if((int8)c( ^(r1),(int16) r2))goto l]
	assembles['cmp ' r1 ',word' '  '  r2 '\n j' c ' near  ' l];
instruction pattern IFGOTO(label l,ireg r1,regaddrimmediate r2,condition c,signed t,int b)
	means[if((int8)c( ^(r1),(int32) r2))goto l]
	assembles['cmp ' r1 ',dword' '  '  r2 '\n j' c ' near  ' l];

instruction pattern IFUGOTO(label l,ureg r1,ureg r2,unsignedcondition c,signed t,int b)
	means[if((int8)c( ^(r1),^( r2)))goto l]
	assembles['cmp ' r1 ',dword' '  '  r2 '\n j' c ' near  ' l];
instruction pattern IFASSp6(signedreg r1,regaddrimmediate r2,condition c,type t2,maddrmode r3,maddrmode rm, type t )
	means[if((t2)c( (t)^(r1),(t) r2))(ref t)rm:= (t)^(r3)]
	assembles['cmp ' r1 ','t '  '  r2
		'\n mov 'r1','t rm
		'\n cmov'c' 'r1','r3'\n mov 't rm ',' r1];
instruction pattern IFASS(signedreg r1,acc r2,maddrmode rm, type t,equals c,type t2 )
	means[if((t2)c( (t)^(rm),(t) r2))(ref t)rm:= (t)^(r1)]
	assembles['cmpxchg ' t rm ',' '  '  r1 ];
 
instruction pattern SET(condition c,reg r1,reg   rm, breg r,signed t,byte b)
	means[r:=(b) c((int32)^(r1),(t) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern SETU(unsignedcondition c,ureg r1,ureg rm, breg r,unsigned t)
	means[r:= c((t)^(r1),(t) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern SETW(condition c,wreg r1,wreg   rm, breg r,signed t,byte b)
	means[r:=(b) c((int16)^(r1),(int16) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern SETUW(unsignedcondition c,uwreg r1,uwregaddrimmediate rm, breg r,unsigned t)
	means[r:= c((t)^(r1),(uint16) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern SETB(condition c,bireg r1,bireg   rm, breg r,signed t,byte b)
	means[r:=(b) c((t)^(r1),(int8) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern SETUB(unsignedcondition c,bureg r1,regaddrimmediate rm, breg r,unsigned t)
	means[r:= c((t)^(r1),(uint8) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern SETeq(eqcondition c,reg r1,regaddrimmediate rm, breg r,oplen t)
	means[r:= c((t)^(r1),(t) rm)]
	assembles['cmp 'r1 ',' ' ' rm '\n set'c ' ' r'\n sub 'r',1\n not 'r];
instruction pattern IFBOOL(label l,breg r1)
	means[ if( ^(r1))goto l]
	assembles['and ' r1 ',' r1 '\n jnz near ' l];
instruction pattern BOUNDC(reg r1,int lwb,int upb)
	means[if(OR(<( ^(r1), const lwb), >( ^(r1), const upb)) )interrupt 5]
 	assembles['boundc ' r1 ','lwb','upb];

instruction pattern BOUND0(reg r1,reg r2)
	means[if(OR(<( ^(r2), ^((ref int32)mem(  ^(r1) ))), >( ^(r2), ^((ref int32)mem(+(^(r1), 4))))) )interrupt 5]
 	assembles['bound ' r2 ',[' r1 ']'];
instruction pattern BOUND4(reg r1,reg r2)
	means[if(OR(<( ^(r2),^((ref int32)mem(+(^(r1),4)))),>(^(r2),^((ref int32)mem(+(^(r1), 8))))))interrupt 5]
 	assembles['bound ' r2 ',[' r1 '+4]'];
instruction pattern BOUND16(reg r1,reg r2)
	means[if(OR(<( ^(r2),^((ref int32)mem(+(^(r1),16)))),>(^(r2),^((ref int32)mem(+(^(r1), 20))))))interrupt 5]
 	assembles['bound ' r2 ',[' r1 '+16]'];
instruction pattern IFIN(reg r1,reg r2, label l)
	means[ if((int8)AND((uint8)^(mem(r1 )) , <<( (uint8)1,^(r2))))goto l]
	assembles['bt  [' r1 '],' r2 '\n jc 'l];

instruction pattern TESTIN(reg r1,reg r2, breg r,type t)
	means[ r:=<>(AND((t)^(mem(r1 )) , (t)<<( 1,^(r2))),0)]
	assembles['bt  [' r1 '],' r2 '\n setc 'r'\n not 'r'\n inc 'r];
instruction pattern BTS(reg r1,reg r2)
	means[(ref uint8)mem(r1 ):=OR((uint8)^(mem(r1 ) ), <<( (uint8)1,^(r2)))]
	assembles['bts [' r1 '],' r2];
instruction pattern REPMOVSD(countreg s,maddrmode m1,sourcereg si, destreg di)
	means[for (ref int32)m1:=0 to ^(s) step 1 do 
              (ref int32)mem(+(^(di),*(^((ref int32)m1),4))):=^((ref int32)mem(+(^(si),*(^((ref int32)m1),4))))
	]
	assembles[' inc ecx\n rep movsd'];  
instruction pattern REPMOVSB(countreg s,maddrmode m1,sourcereg si, destreg di)
	means[for (ref int32)m1:=0 to ^(s) step 1 do 
              (ref octet)mem(+(^(di),^((ref int32)m1))):=^((ref octet)mem(+(^(si),^((ref int32)m1))))
	]
	assembles[' inc ecx\n rep movsb'];
	
instruction pattern INTMAX(reg r1,reg r2)
	means[ r1:=MAX(^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n cmovl 'r1','r2];
instruction pattern INTMIN(reg r1,reg r2)
  	means[ r1:=MIN(^(r1),^(r2))]
	assembles['cmp 'r1','r2'\n  cmovg 'r1','r2];
			
 
/* these come last as they are a fallback for having no free registers must go after fpu ops*/










/* these come last as they are a fallback for having no free registers */





 
/* \end{verbatim} */


/* \subsection{Intel fpu instructions} 
Copyright (c) University of Glasgow 2003
\begin{verbatim}
*/  

register stack(8)ieee64 ST assembles[ 'ST']; 
 
pattern anyreal means[ieee32|ieee64];
pattern fputype means[anyreal|int64|int32];
pattern fpuint means[int32|int16|int64];
operation fdiv means div assembles['div'];
operation frem means MOD assembles['prem'];
pattern foperator means[add | sub|mul|fdiv];

pattern fioperator means[add | sub|mul]; 
pattern fround(type t,fpuint i) means [(i)ROUND((t)POP(ST))] assembles['frndint'];
pattern fsqrt(type t) means[(t)SQRT((t)POP(ST))]   assembles ['fsqrt'];
pattern fsin(type t) means[(t)SIN((t)POP(ST))]  assembles ['fsin'];
pattern fcos(type t) means[(t)COS((t)POP(ST))]   assembles ['fcos'];
pattern fextend(type t) means[(int64)EXTEND((int32)POP(ST))] assembles ['; fextend '];
pattern fln(type t)means[(t)LN((t)POP(ST))] assembles['fldln2\n fxch\n fyl2x'];
pattern fptan(type t) means[(t)TAN((t)POP(ST))]assembles['fsincos\nfdivp st1'];
pattern fabs(type t) means[(t)ABS((t)POP(ST))]assembles['fabs'];
pattern fmoperator means [fround|fsqrt|fsin|fcos|fptan|fln|fabs|fextend];

instruction pattern RDIVB(breg b1,baddrmode b2)
	means[b1:=div(^(b1),^(b2))]
	assembles['bytediv 'b1','b2];
instruction pattern RMULTB(breg b1,baddrmode b2)
	means[b1:=*(^(b1),^(b2))]
	assembles['bytemult 'b1','b2];

instruction pattern FISTB(breg b1,type t)
	means[b1:=(int8)(int32)ROUND((t)POP(ST))]
	assembles['fistb 'b1];
instruction pattern FILDB(baddrmode b2)
	means[PUSH(ST,(int8)^(b2))]
	assembles['fildb 'b2];
instruction pattern FILDR(reg r)
	means[PUSH(ST,(int32)^(r))]
	assembles['mov dword[fttemp], 'r'\n fild dword[fttemp]; fildr'];

instruction pattern FSTR(memrisc a)
	means[(ref ieee64) a:= (ieee64)POP(ST)]
	assembles['fstp qword ' a];
instruction pattern FSTRF(memrisc a)
	means[(ref ieee32) a:= (ieee32)POP(ST)]
	assembles['fstp dword ' a];
instruction pattern FLOATMS(anyreal t,hiint t2)
	means[PUSH(ST,(t)FLOAT((t2)POP(mainSTACK)))]
	assembles['fild dword [esp]\n add esp,4'];
	

instruction pattern EXTENDMS(type t)
	means[PUSH(ST,(int64)EXTEND((int32)POP(mainSTACK)))]
	assembles['fild dword [esp]\n add esp,4'];
instruction pattern EXTENDANY(type t)
	means[PUSH(ST,(ieee64)EXTEND((t)POP(ST)))]
	assembles['; extend fpu stack'];
instruction pattern FPOPMS(type t)
	means[PUSH(ST,(ieee32)POP(mainSTACK))]
	assembles[' fld dword [esp]\n add esp,4'];
instruction pattern FPOPMSI64(type t)
	means[PUSH(ST,(int64)POP(mainSTACK))]
	assembles['fild qword [esp]\n add esp,8'];
instruction pattern DPOPMS(type t)
	means[PUSH(ST,(ieee64)POP(mainSTACK))]
	assembles['fld qword [esp]\n add esp,8'];
instruction pattern FPUSHD(type t)
	means[PUSH(mainSTACK,(ieee64)POP(ST))]
	assembles['sub esp,8\n fstp qword [esp]'];
instruction pattern FPUSHF(type t)
	means[PUSH(mainSTACK,(ieee32)POP(ST))]
	assembles['sub esp,4\n fstp dword [esp]'];
instruction pattern FISTR(wmemdummy m, hiint i, type t)
	means[(ref i )m:=(i )POP(ST)]
	assembles['fistp 'i' ' m];
instruction pattern FISTP(wmemdummy m, hiint i, type t)
	means[(ref i )m:=(i )POP(ST)]
	assembles['fistp 'i' ' m];
instruction pattern FEX(hiint i)
	means[PUSH(ST,(int64)EXTEND((i)POP(ST)))]
	assembles['; treat st0 as int64'];
instruction pattern FPUSHI(type t)
	means[PUSH(mainSTACK,(int32)ROUND((t)POP(ST)))]
	assembles['sub esp,4\n fistp dword [esp]'];
instruction pattern FLD(maddrmode a)
	means[PUSH(ST,^((ref ieee64) a))]
	assembles['fld qword ' a];
instruction pattern FLDF(maddrmode a)
	means[PUSH(ST,^((ref ieee32) a))]
	assembles['fld dword ' a];
instruction pattern FILD(wmemdummy a,real t, hiint i)
	means[PUSH(ST,^((ref i) a))]
	assembles['fild 'i ' ' a'; fild'];
instruction pattern FILDF(maddrmode a,real t, hiint i)
	means[PUSH(ST,FLOAT((i)^( a)))]
	assembles['fild 'i ' ' a'; fildf'];
 
instruction pattern FLOATLDR(reg r,anyreal t)
	means[PUSH(ST,(t)FLOAT((int32)^(r)))]
	assembles['mov dword[fttemp], 'r'\n fild dword[fttemp];floatdr'];
instruction pattern FILDIP(real t)
	means[PUSH(ST, (int32)POP(mainSTACK))]
	assembles['fild dword[esp]\n add esp,4'];
 	
operation flt means < assembles ['b'];
operation fgt means > assembles ['a'];
operation feq means = assembles ['z'];
operation fle means <= assembles ['na'];
operation fge means >= assembles ['ae'];
operation fne means <> assembles ['nz'];
pattern fcondition means[fne|fge|fle|feq|fgt|flt];
pattern fpuval means[ieee32|ieee64|int32|int64];
/*
instruction pattern p6FIFGOTO(label l, maddrmode a,fcondition c,int t,fpuval t2) 
	means[if((t)c((t2)POP(ST),(t2)POP(ST)))goto l]
	assembles['fxch\nfcomip st0,st1 \n  fincstp\n j' c ' near  ' l];

instruction pattern p6FSET(fcondition c, breg r,fpuval t2)
	means[(ref int8)r:=(int8) c((t2)POP(ST), (t2)POP(ST))]
	assembles['fxch\n fcomip st0,st1\n \n  fincstp\n   set'c ' ' r'\nnot 'r'\n inc 'r];
*/

instruction pattern FIFGOTO(label l, maddrmode a,fcondition c,int t,fpuval t2) 
	means[if((t)c((t2)POP(ST), ^((ref ieee32)a)))goto l] 
	assembles['fcomp dword ' a ' \npush ax\n fstsw ax\n sahf\n pop ax\n j' c ' near  ' l];
instruction pattern FIFGOTOgeneral(label l,  fcondition c,int t,fpuval t2) 
	means[if((t)c((t2)POP(ST), (t2)POP(ST)))goto l] 
	assembles['fxch\n fcompp \npush ax  \n fstsw ax\n sahf\n pop ax\n j' c ' near ' l];
instruction pattern FSET(fcondition c, breg r,fpuval t2)
	means[(ref int8)r:=(int8) c((t2)POP(ST), (t2)POP(ST))]
	assembles['fxch\n fcompp\n push ax\n fstsw ax\n sahf\n pop ax\n set'c ' ' r'\nnot 'r'\n inc 'r];
instruction pattern FMOP(fmoperator op)
	means[PUSH(ST,op)]
	assembles[op];
instruction pattern FCHS(real t)
	means[PUSH(ST,(t)-((t)0,(t)POP(ST)))]
	assembles['fchs'];
 
instruction pattern FLOADLIT(float f)
	means[PUSH(ST,const f)]
	assembles['floadlit 'f];
/*	assembles['db 0ebh,4\ndd 'f'\n fld dword  [$-4]'];*/
/* this handles any length of real and should come last in the set of codes */
instruction pattern FLOADDLIT(real f,anyreal t)
	means[PUSH(ST,(t)const f)]
	assembles['floadlit 'f];
/*	assembles['db 0ebh,8\ndq ' f'\nfld qword  [$-8]'];*/
instruction pattern FILOADLIT(hiint i,fputype t)
	means[PUSH(ST,(t) const i)]
	assembles['filoadlit 'i];
/*	assembles['db 0ebh,10\ndt ' i'.0\nfld tword  [$-10]'];*/

instruction pattern FOP(maddrmode a,foperator op)
	means[PUSH(ST,op((ieee64)POP(ST),^((ref ieee64)a)  )) ]
	assembles['f'op '  qword  ' a];
instruction pattern FOPF(maddrmode a,foperator op,real t) 
	means[PUSH(ST,(t)op((t)POP(ST),(t)^((ref t)a)  )) ] 
	assembles['f'op ' ' t   ' ' a]; 
instruction pattern FOPI(maddrmode a,fioperator op,fputype t) 
	means[PUSH(ST,op((t)POP(ST),FLOAT(^(a) ) )) ] 
	assembles['fi'op '  dword  ' a]; 
instruction pattern FIDIV(maddrmode a,fputype t) 
	means[PUSH(ST,div((t)POP(ST),FLOAT(^(a) ) )) ] 
	assembles['fidiv' '  dword  ' a'\n'
		  ' fldcw word [roundzero]\n frndint\n fldcw word [roundnear]']; 
instruction pattern FOPII(maddrmode a,fioperator op,fputype t) 
	means[PUSH(ST,op((t)POP(ST),^(a)  )) ] 
	assembles['fi'op '  dword  ' a]; 
instruction pattern FOPIIMS(maddrmode a,fioperator op,signed t) 
	means[PUSH(mainSTACK,(int32)op((t)POP(ST),(t)^(a)  )) ] 
	assembles['fi'op '  dword  ' a'\n sub esp,4\n fistp dword[esp]'];
instruction pattern RPFOP(foperator op,fputype t)
	means[PUSH(ST,(t)op((t)POP(ST),(t)POP(ST)))]
	assembles['f'op'p' ' st1']; 
 
 

instruction pattern FMAXp6(maddrmode a,type t)		/* this version only works on P6s and above*/
	means[PUSH(ST,(t)MAX((t)POP(ST),(t)POP(ST)))]
	assembles['fcomi st0,st1\n fcmovb st0,st1 \nfstp st1'];
instruction pattern MAXp6(reg r1,reg r2)
	means[r1:= (int32)MAX(^(r1),^(r2))]
	assembles['cmp 'r1','r2'\ncmovl 'r1','r2];
instruction pattern MINp6(reg r1,reg r2)
	means[r1:= (int32)MIN(^(r1),^(r2))]
	assembles['cmp 'r2','r1'\ncmovl 'r1','r2];

instruction pattern FMINp6(maddrmode a,type t)
	means[PUSH(ST,(t)MIN((t)POP(ST),(t)POP(ST)))]
	assembles['fcomi st0,st1\n fcmovnb st0,st1 \nfstp st1'];
instruction pattern FMAX(maddrmode a,fputype t)		/* this version only works on P6s and above*/
	means[PUSH(ST,(t)MAX((t)POP(ST),(t)POP(ST)))]
	assembles['fcom st0,st1  \npush ax\n fstsw ax\n sahf\n pop ax\n jnb $+4 \n fxch \nfstp st1'];
instruction pattern FMIN(maddrmode a,fputype t)
	means[PUSH(ST,(t)MIN((t)POP(ST),(t)POP(ST)))]
	assembles['fcom st0,st1  \n push ax\n fstsw ax\n sahf\n pop ax\n jb $+4 \n fxch \nfstp st1'];
instruction pattern FIMIN(maddrmode a,fputype t)
	means[PUSH(mainSTACK,(int32)MIN((t)POP(ST),(t)POP(ST)))]
	assembles['fcom st0,st1  \n push ax\n fstsw ax\n sahf\n pop ax\n jb $+4 \n fxch \nfstp st1\n sub esp,4\n fistp dword[esp]'];
instruction pattern FPREM(fputype t)
	means[PUSH(ST,(t)MOD((t) POP(ST),(t)POP(ST)))]
	assembles['fxch \n fprem\n fstp st1'];	
instruction pattern FPREMu(int t)
	means[PUSH(ST,(t)MOD( (t)POP(ST),(t)POP(ST)))]
	assembles['fxch \n fprem\n fstp st1'];




/* \end{verbatim}
\subsection{Pentium extensions to the FPU codes }
\begin{verbatim}*/

/* \end{verbatim} */
 

/*

\subsection{MMX registers and instructions}
\subsubsection{Registers}
\begin{verbatim}
*/

register doubleword MM0 assembles[ 'MM0']; 
register doubleword MM1 assembles[ 'MM1'];  
register doubleword MM2 assembles[ 'MM2'];  
register doubleword MM3 assembles[ 'MM3'];  
register doubleword MM4 assembles[ 'MM4'];  
pattern MMXREGS means[MM0|MM1|MM2|MM3|MM4];
alias register uint64 MM1U=MM1(0:63) assembles ['MM1'];
alias register int64 MM1I=MM1(0:63) assembles ['MM1'];

/* reserve for working space */
reserved register doubleword MM7 assembles[ 'MM7']; 
reserved register doubleword MM5 assembles[ 'MM5'];  
reserved register doubleword MM6 assembles[ 'MM6']; 
/** used for operations using half registers */ 
alias register word MM0L=MM0(0:31) assembles['MM0'];
alias register word MM1L=MM1(0:31) assembles['MM1'];
alias register word MM2L=MM2(0:31) assembles['MM2'];
alias register word MM3L=MM3(0:31) assembles['MM3'];
alias register word MM4L=MM4(0:31) assembles['MM4'];
alias register word MM1LU=MM1U(0:31) assembles['MM1'];
alias register word MM1LI=MM1I(0:31) assembles['MM1'];


alias register word MM5L=MM5(0:31) assembles['MM5'];
/* used for 16 bit parallelism */
alias register int16 vector (4) MM016=MM0(0:63) assembles['MM0'];
alias register int16 vector (4) MM116=MM1(0:63) assembles['MM1'];
alias register int16 vector (4) MM216=MM2(0:63) assembles['MM2'];
alias register int16 vector (4) MM316=MM3(0:63) assembles['MM3'];
alias register int16 vector (4) MM416=MM4(0:63) assembles['MM4'];
alias register int16 vector (4) MM516=MM5(0:63) assembles['MM5'];

alias register int32 vector (2) MM032=MM0(0:63) assembles['MM0'];
alias register int32 vector (2) MM132=MM1(0:63) assembles['MM1'];
alias register int32 vector (2) MM232=MM2(0:63) assembles['MM2'];
alias register int32 vector (2) MM332=MM3(0:63) assembles['MM3'];
alias register int32 vector (2) MM432=MM4(0:63) assembles['MM4'];
alias register int32 vector (2) MM532=MM5(0:63) assembles['MM5'];

alias register int8 vector (8) MM08=MM0(0:63) assembles['MM0'];
alias register int8 vector (8) MM18=MM1(0:63) assembles['MM1'];
alias register int8 vector (8) MM28=MM2(0:63) assembles['MM2'];
alias register int8 vector (8) MM38=MM3(0:63) assembles['MM3'];
alias register int8 vector (8) MM48=MM4(0:63) assembles['MM4'];
alias register int8 vector (8) MM58=MM5(0:63) assembles['MM5'];
alias register uint8 vector (8) MM08u=MM0(0:63) assembles['MM0'];
alias register uint8 vector (8) MM18u=MM1(0:63) assembles['MM1'];
alias register uint8 vector (8) MM28u=MM2(0:63) assembles['MM2'];
alias register uint8 vector (8) MM38u=MM3(0:63) assembles['MM3'];
alias register uint8 vector (8) MM48u=MM4(0:63) assembles['MM4'];
alias register uint8 vector (8) MM58u=MM5(0:63) assembles['MM5'];

alias register octet vector (8) MM08o=MM0(0:63) assembles['MM0'];
alias register octet vector (8) MM18o=MM1(0:63) assembles['MM1'];
alias register octet vector (8) MM28o=MM2(0:63) assembles['MM2'];
alias register octet vector (8) MM38o=MM3(0:63) assembles['MM3'];
alias register octet vector (8) MM48o=MM4(0:63) assembles['MM4'];
alias register octet vector (8) MM58o=MM5(0:63) assembles['MM5'];
pattern im8reg means[MM48|MM38|MM58|MM08|MM18|MM28];
pattern um8reg means[MM48u|MM38u|MM58u|MM08u|MM18u|MM28u];
pattern om8reg means[MM48o|MM38o|MM58o|MM08o|MM18o|MM28o];
pattern im2reg means[MM432|MM332|MM532|MM032|MM132|MM232];
pattern im4reg means[MM416|MM316|MM516|MM016|MM116|MM216];
pattern untypedmreg means [MM1|MM3|MM4|MM5|MM2|MM0|MM7|MM6];
pattern lmreg means [MM1L|MM3L|MM4L| MM2L|MM0L| MM5L];
pattern umreg means[MM1U];
pattern iMreg means[MM1I];
pattern ilmreg means[MM1LI];
pattern ulmreg means[MM1LU];
pattern wmreg means[lmreg|ulmreg|ilmreg];
pattern mreg means[im2reg|untypedmreg|umreg|im4reg|im8reg|iMreg|um8reg|MMXREGS|om8reg];

 
/* define m4 macros to generate casts to the desired types */











/*\end{verbatim}
\subsubsection{Addressing modes}
\begin{verbatim}
*/
pattern mrmaddrmode means[maddrmode|mreg];
pattern mriscaddrmode means[memrisc|mreg];
/*\end{verbatim}
\subsubsection{MMX instructions}
\begin{verbatim}
*/
instruction pattern PMULLW(im4reg m, im4reg ma)
	means[m := *(^(m),^(ma))]
	assembles['pmullw ' m ',' ma];
instruction pattern PMULLSSB(im8reg m1,mreg m2, mrmaddrmode ma)
	means[m1:= (int8 vector(8))*:((int8 vector(8))^(m1),(int8 vector(8))^(ma))]
	assembles['pxor MM7,MM7'   /* clear regs mm5 and mm7 */
		  '\n pxor MM5,MM5'
		  '\n punpckhbw MM7,'ma /* mm7 now has 4 words with the top 4 bytes of ma in them */
		  '\n pxor MM6,MM6'
		  '\n punpckhbw MM6,'m1
                  '\n punpcklbw MM5,'ma 
                  '\n pmulhw MM7,MM6'
                  '\n psraw MM7,7'
		  '\n pxor MM6,MM6'		 
                  '\n punpcklbw MM6,'m1
                  '\n pmulhw MM5,MM6'
		  '\n psraw MM5,7'
		  '\n packsswb MM5,MM7'
		  '\n movq 'm1',MM5'];

instruction pattern MMXPUSH(mreg m)
	means[PUSH(mainSTACK,m)]
	assembles['sub esp,8\n movq [esp],'m];
instruction pattern MMXPOP(mreg m )
	means[m:=(doubleword)POP(mainSTACK)]
	assembles['movq 'm',[esp]\n add esp,8'];
instruction pattern PADDD(mreg m, mrmaddrmode ma)
	means[(ref int32 vector(2))m := (int32 vector(2))+((int32 vector(2))^(m),(int32 vector(2))^(ma))]
	assembles ['paddd 'm ',' ma];
instruction pattern PADDW(im4reg m, mrmaddrmode ma)
	means[(ref int16 vector(4))m := (int16 vector(4))+((int16 vector(4))^(m),(int16 vector(4))^(ma))]
	assembles ['paddw 'm ',' ma];
instruction pattern PADDB(im8reg m, mrmaddrmode ma)
	means[(ref int8 vector(8))m := (int8 vector(8))+((int8 vector(8))^(m),(int8 vector(8))^(ma))]
	assembles ['paddb 'm ',' ma];

operation meq means = assembles ['eq'];
operation mgt means > assembles ['gt'];
pattern mcondition means[meq|mgt];
instruction pattern CMPPB(mreg m,mrmaddrmode ma,mcondition cond)
	means[(ref octet vector(8))m:= (octet vector(8))cond((octet vector(8))^(m),(octet vector(8))^(ma))]
	assembles['pcmp' cond 'b 'm','ma];
instruction pattern CMPPBR(mreg m,mrmaddrmode ma,mcondition cond)
	means[(ref octet vector(8))m:= (octet vector(8))<((octet vector(8))^(ma),(octet vector(8))^(m))]
	assembles['pcmpgtb 'm','ma];
 
 instruction pattern CMPPW(im4reg m,im4reg ma,mcondition cond)
	means[m:= EXTEND((int8 vector (4))cond(^(m),^(ma)))]
	assembles['pcmp' cond 'w 'm','ma];
 
 instruction pattern CMPPWR(im4reg m,im4reg ma,mcondition cond)
	means[ma:= EXTEND((int8 vector (4))<(^(ma),^(m)))]
	assembles['pcmpgtw 'm','ma
             '\n movq 'ma','m];
 

 instruction pattern CMPPD(im2reg m,im2reg ma,mcondition cond)
	means[m:= EXTEND((int8 vector (2))cond(^(m),^(ma)))]
	assembles['pcmp' cond 'd 'm','ma];
 
 instruction pattern CMPPDR(im2reg m,im2reg ma,im2reg m3)
	means[m3:= EXTEND((int8 vector (2))<(^(ma),^(m)))]
	assembles['pcmpgtd 'm','ma'\n movq 'm3','m];

 instruction pattern PADDUB(mreg m, mrmaddrmode ma)
	means[(ref uint8 vector(8))m := (uint8 vector(8))+((uint8 vector(8))^(m),(uint8 vector(8))^(ma))]
	assembles ['paddb 'm ',' ma];
instruction pattern PADDSB(im8reg m, mrmaddrmode ma)
	means[m := (int8 vector(8))+:(^(m),(int8 vector(8))^(ma))]
	assembles ['paddsb 'm ',' ma];
instruction pattern PADDSB3(im8reg m,im8reg m2, mrmaddrmode ma)
	means[m := (int8 vector(8))+:(^(m2),(int8 vector(8))^(ma))]
	assembles ['movq 'm','m2'\n paddsb 'm ',' ma];

instruction pattern PADDUSB(mreg m, mrmaddrmode ma)
	means[(ref uint8 vector(8))m := (uint8 vector(8))+:((uint8 vector(8))^(m),(uint8 vector(8))^(ma))]
	assembles ['paddusb 'm ',' ma];
/* stack add instructions */
 instruction pattern SPADDUSB(mreg m )
	means[(ref uint8 vector(8))m := (uint8 vector(8))+:((uint8 vector(8))POP(mainSTACK),(uint8 vector(8))POP(mainSTACK))]
	assembles ['movq 'm',[esp]\n paddusb 'm ',[esp+8]\n add esp,16'];
instruction pattern SPADDUB(mreg m )
	means[(ref uint8 vector(8))m := (uint8 vector(8))+((uint8 vector(8))POP(mainSTACK),(uint8 vector(8))POP(mainSTACK))]
	assembles ['movq 'm',[esp]\n paddb 'm ',[esp+8]\n add esp,16' ];
instruction pattern SPADDSB(im8reg m )
	means[m := (int8 vector(8))+:((int8 vector(8))POP(mainSTACK),(int8 vector(8))POP(mainSTACK))]
	assembles ['movq 'm',[esp]\n paddsb 'm ',[esp+8]\n add esp,16'];


instruction pattern SPSUBD(mreg m )
	means[(ref int32 vector(2))m := (int32 vector(2))-((int32 vector(2))^(m),(int32 vector(2))POP(mainSTACK))]
	assembles ['psubd 'm ',[esp]\n add esp,8' ];
instruction pattern PSUBW(im4reg m, mrmaddrmode ma)
	means[(ref int16 vector(4))m := (int16 vector(4))-((int16 vector(4))^(m),(int16 vector(4))^(ma))]
	assembles ['psubw 'm ',' ma];
instruction pattern PSUBB(im8reg m, mrmaddrmode ma)
	means[(ref int8 vector(8))m := (int8 vector(8))-((int8 vector(8))^(m),(int8 vector(8))^(ma))]
	assembles ['psubb 'm ',' ma];
instruction pattern PSUBUB(mreg m, mrmaddrmode ma)
	means[(ref uint8 vector(8))m := (uint8 vector(8))-((uint8 vector(8))^(m),(uint8 vector(8))^(ma))]
	assembles ['psubb 'm ',' ma];
instruction pattern PSUBSB(im8reg m, mrmaddrmode ma)
	means[(ref int8 vector(8))m := (int8 vector(8))-:((int8 vector(8))^(m),(int8 vector(8))^(ma))]
	assembles ['psubsb 'm ',' ma];
instruction pattern PSUBUSB(mreg m, mrmaddrmode ma)
	means[(ref uint8 vector(8))m := (uint8 vector(8))-:((uint8 vector(8))^(m),(uint8 vector(8))^(ma))]
	assembles ['psubusb 'm ',' ma];
instruction pattern PAND(mreg m, mrmaddrmode ma)
	means[m := AND(^(m),^(ma))]
	assembles ['pand 'm ',' ma];
instruction pattern PANDN(mreg m, mrmaddrmode ma)
	means[m := AND(^(ma),NOT(^(m)))]
	assembles ['pandn 'm ',' ma];
instruction pattern POR(mreg m, mrmaddrmode ma)
	means[m := OR(^(m),^(ma))]
	assembles ['por 'm ',' ma];
instruction pattern MOVDS(waddrmode rm, wmreg m)
	means[(ref word)rm:= ^(m)]
	assembles['movd 'rm ','m];
instruction pattern MOVDL(waddrmode rm, wmreg m)
	means[m := (word)^(rm)]
	assembles['movd 'm ','rm];
instruction pattern MOVOCTUINTL(memrisc rm, mreg m)
	means[m := (uint8 vector(8))^(rm)]
	assembles['movq ' m ',' rm];
instruction pattern MOVQS(memrisc rm, mreg m)
	means[(ref doubleword)rm:= ^((ref doubleword)m)]
	assembles['movq 'rm ','m];
instruction pattern MOVQSGEN(memrisc rm, mreg m)
	means[(ref doubleword)rm:= ^(m)]
	assembles['movq 'rm ','m];
instruction pattern MOVQR(mreg rm, mreg m)
	means[(ref doubleword)rm:= ^(m)]
	assembles['movq 'rm ','m];

instruction pattern MOVOCTUINTS(memrisc rm,mreg m)
	means[(ref uint8 vector(8))rm:=^(m)]
	assembles['movq 'rm','m];
instruction pattern MOVQL(mrmaddrmode rm, mreg m)
	means[m := (doubleword)^(rm)]
	assembles['movq ' m ',' rm];
instruction pattern MOVQLR(im8reg rm, im8reg m)
	means[m := ^(rm)]
	assembles['movq ' m ',' rm];


instruction pattern REP2(mreg m, reg r)
	means[m:=rep(^(r),2)]
	assembles['push 'r'\n push 'r'\n movq 'm',[esp]\n add esp,8'];

instruction pattern REP4(mreg m, wreg r)
	means[m:=rep(^(r),4)]
	assembles['push 'r'\n push 'r'\n push 'r'\n push 'r'\n movq 'm',[esp]\n add esp,8'];

instruction pattern REP8(mreg m, breg r)
	means[m:=rep(^(r),8)]
	assembles['sub esp,2\n mov [esp], 'r'\n mov [esp+1], 'r'\n xchg [esp],ax\npush ax\npush ax\n push ax\nxchg [esp+6],ax\n movq 'm',[esp]\n add esp,8'];
instruction pattern PACKSSDW(reg r, mreg m)
	means[(ref int16 vector(4))m:=^((ref int32 vector(4))mem(r))]
	assembles['movq 'm',['r']\n packssdw 'm',['r'+8]'];

instruction pattern PACKSSWB(reg r, im8reg m)
	means[(ref int8 vector(8))m:=^((ref int16 vector(8))mem(r))]
	assembles['movq 'm',['r']\n packsswb 'm',['r'+8]'];

instruction pattern PACKUSWB(reg r, mreg m)
	means[(ref uint8 vector(8))m:=^((ref int16 vector(8))mem(r))]
	assembles['movq 'm',['r']\n packuswb 'm',['r'+8]'];













/* \end{verbatim} */

/*
\end{verbatim}
\subsection{Streaming SIMD registers and instructions}
Copyright University of Glasgow (c) 2002
\subsubsection{Registers}
\begin{verbatim}

*/

register quadword XMM0 assembles[ 'XMM0'];
alias register ieee32 XMM00=XMM0(0:31) assembles['xmm0'] ;
register quadword XMM1 assembles[ 'XMM1']; 
alias register ieee32 XMM10=XMM1(0:31) assembles['xmm1'] ;
register quadword XMM2 assembles[ 'XMM2']; 
alias register ieee32 XMM20=XMM2(0:31) assembles['xmm2'] ;
register quadword XMM3 assembles[ 'XMM3']; 
alias register  ieee32 XMM30=XMM3(0:31) assembles['xmm3'] ;
register quadword XMM4 assembles[ 'XMM4']; 
alias register ieee32 XMM40=XMM4(0:31) assembles['xmm4'] ;
register quadword XMM5 assembles[ 'XMM5']; 
alias register ieee32 XMM50=XMM5(0:31) assembles['xmm5'] ;
register quadword XMM6 assembles[ 'XMM6']; 
alias register  ieee32 XMM60=XMM6(0:31) assembles['xmm6'] ;
register quadword XMM7 assembles[ 'XMM7'];
alias register ieee32 XMM70=XMM7(0:31) assembles['xmm7'] ;
alias register ieee32 vector(4) SXMM0=XMM0(0:127) assembles['Xmm0'];
alias register ieee32 vector(4) SXMM1=XMM1(0:127) assembles['Xmm1'];
alias register ieee32 vector(4) SXMM2=XMM2(0:127) assembles['Xmm2'];
alias register ieee32 vector(4) SXMM3=XMM3(0:127) assembles['Xmm3'];
alias register ieee32 vector(4) SXMM4=XMM4(0:127) assembles['Xmm4'];

alias register ieee32 vector(4) SXMM5=XMM5(0:127) assembles['Xmm5'];

pattern oxmreg means [XMM1|XMM3|XMM4|XMM5|XMM6|XMM2|XMM0|XMM7];
pattern sxxmreg means[SXMM0|SXMM1|SXMM2|SXMM3|SXMM4|SXMM5];
pattern xmreg means[sxxmreg|oxmreg];
pattern sxmreg means[XMM00|XMM10|XMM20|XMM30|XMM70|XMM60|XMM50|XMM40]; 
/* define m4 macros to generate casts to the desired types */




/*\end{verbatim}
\subsubsection{Addressing modes}
\begin{verbatim}
*/
pattern smaddrmode means[maddrmode|sxmreg];
pattern psmaddrmode means[maddrmode|sxxmreg];



/*\end{verbatim}
\subsubsection{Operations}
\begin{verbatim}
*/

operation sdiv means div assembles ['div'];
operation min means MIN assembles ['MIN'];
operation max means MAX assembles ['MAX'];
pattern soperator means[add|mul|sdiv|sub|min|max];
/*\end{verbatim}
\subsubsection{XMMX instructions}
\begin{verbatim}
*/
instruction  pattern OPSS(soperator op, smaddrmode rm,sxmreg r1)
        means[ (ref ieee32) r1 :=op( ( ieee32)^( r1),( ieee32)^(  rm))]
    	assembles[op 'ss  '    r1 ',' rm];
instruction  pattern ADDSS( smaddrmode rm,sxmreg r1)/* this knows about + commuting OPSS does not */
        means[ (ref ieee32) r1 :=+( ( ieee32)^( r1),( ieee32)^(  rm))]
    	assembles['addss  '    r1 ',' rm];
instruction  pattern OPPS(soperator op, xmreg rm,xmreg r1)
        means[  (ref ieee32 vector(4))r1 :=op( (ieee32 vector(4))^( r1), (ieee32 vector(4))^(  rm))]
    	assembles[op 'ps  '    r1 ',' rm];
instruction  pattern ADDPS( xmreg rm,xmreg r1)
        means[  (ref ieee32 vector(4))r1 :=+( (ieee32 vector(4))^( r1), (ieee32 vector(4))^(  rm))]
    	assembles['addps  '    r1 ',' rm];
instruction  pattern STORUPS( smaddrmode rm,xmreg r1)
        means[ (ref ieee32 vector(4))rm :=(ieee32 vector(4))^(r1)]
    	assembles['movups  '    rm ', ' r1];
instruction  pattern MOVUPS( psmaddrmode rm,xmreg r1)
        means[   r1 :=(ieee32 vector(4))^(rm)]
    	assembles['movups  '    r1 ', ' rm];
instruction  pattern MOVSS( smaddrmode rm,sxmreg r1)
        means[ (ref ieee32) r1 :=^((ref ieee32) rm)]
    	assembles['movss  '    r1 ', ' rm];
instruction pattern XRLOADLIT(float f,sxmreg r1)
	means[ (ref ieee32)r1:=const f]
	assembles['xrloadlit 'r1','f];

instruction  pattern CVTSI2SS( maddrmode rm,sxmreg r1)
        means[ (ref ieee32) r1 :=(ieee32)FLOAT((int32)^( rm))]
    	assembles['cvtsi2ss  '    r1 ', ' rm];
instruction  pattern CVTIR2SS( reg r0,sxmreg r1)
        means[ (ref ieee32) r1 :=(ieee32)FLOAT((int32)^(  r0))]
    	assembles['cvtsi2ss  '    r1 ', ' r0]; 
instruction  pattern CVTSS2SI( reg r1,sxmreg r0)
        means[ (ref int32) r1 :=(int32)ROUND(^(  r0))]
    	assembles['cvtss2si  '    r1 ', ' r0]; 
    	/*assembles['push ' r0
    	       '\n cvtsi2ss  '    r1 ',  [esp] \n add esp,4'];
*/instruction  pattern STORESS( maddrmode rm,sxmreg r1)
        means[ (ref ieee32) rm :=( ieee32)^( r1)]
    	assembles['movss  '    rm ',' r1];
instruction pattern SSRPUSH(sxmreg r)
	means[PUSH(mainSTACK,^(r))]
	assembles['sub esp,4\n movss [esp],'  r];
instruction pattern SSRPOP(sxmreg r)
	means[(ref ieee32)r:=(ieee32)POP(mainSTACK)]
	assembles[' movss 'r ',[esp]\n add esp,4'];
instruction pattern SSRPOPI(sxmreg r)
	means[(ref ieee32)r:=(ieee32)FLOAT((int32)POP(mainSTACK))]
	assembles[' cvtsi2ss 'r ',[esp]\n add esp,4'];
instruction pattern COMISSIFGOTO(label l,sxmreg r1,sxmreg r2,fcondition c) 
	means[if(c(^(r1),^(r2)))goto l] 
	assembles['comiss ' r1 ','  r2 '\n j' c ' near  ' l];  
instruction pattern COMISS(fcondition c,sxmreg r1,sxmreg r2, breg r)
	means[(ref uint8)r:=(uint8) c(^(r1),^(r2))]
	assembles['comiss 'r1 ',' r2 '\n set'c ' ' r];


instruction pattern FREP4(xmreg m, reg r)
	means[m:=rep(^(r),4)]
	assembles['push 'r'\n push 'r'\n push 'r'\n push 'r'\n movups 'm',[esp]\n add esp,16'];





 
/* \begin{verbatim}*/
instructionset [ MINp6|MAXp6|IFASSp6|IFLITGOTO
	|BIFLITGOTO
	|IFIN
	|IFGOTO
	|IFGOTOB
	|IFGOTOW
	|FIFGOTOgeneral
	|LOAD
	|LOADB
	|LOADW
	|MOVZXB
	|MOVSXB
	|MOVZXW
	|MOVSXW
	|MOVZXB2
	|MOVZBW
	|MOVSBW
	|MOVZXBW
	|MOVSXBW
	|CLEARREG
	|STORELIT
	|LEA
	|INC
	|RMLIT
	|RMR
	|DEC
	|IMULLIT
	|BIMUL
	|RLIT
	|RRM
	|RMRB
	|RMR
	|RMRAdd
	|RRint32
	|RR
	|IDIV
	|fastBIDIV
	|BIDIV
	|UDIV
	|RIDIV	
	|MOD2
	|MOD4
	|MOD16
 	|IMOD
	|UMOD
	|BIMOD
        |IMODstack
	|CDQ
	|fastIMUL
	|Negate
	|NOTOP
	|MNegate
	|BTS
	|TESTIN
	|SHIFT
	|UINT8MAX
	|UINT8MIN
	|INT8MAX
	|INT8MIN
	|SELECT
	|PLANT
	|LITPUSH
	|MEMPUSH
	|SETB
	|SETUB
	|SETW
	|SETUW
	|SET
	|SETU
	|Tob
	|GOTO
	|FAIL
	|BOUND4
	|BOUND0
	|BOUND16
                 /* Note !! the order below is important you must try and match
                         a 32 bit const before a 16 before an 8
                        Otherwise you will plant a word where you want to plant
                        a doubleword if the constant turns out to be small enough
                        etc
		*/
		
	|PLANTICONST
	|PLANTWCONST
	|PLANTBCONST
	|PLANTRCONST
	|PLANTSCONST
		
	|REPMOVSD
	|REPMOVSB 
	|ADDUSB
	|SUBUSB
	|ADDSSB
	|SUBSSB
	|MULTSSB
	|MULTSSBAL	
	|STOREWR
	|STORER
	|STOREBR
|ADDSS|CVTSI2SS|CVTIR2SS| /* CVTSS2SI| */ XRLOADLIT|
 OPPS| OPSS| COMISSIFGOTO|  COMISS|	STORUPS|MOVUPS |
       STORESS| MOVSS|SSRPOPI|SSRPOP|FREP4|ADDPS
|FMINp6|FMAXp6    /* |p6FIFGOTO|p6FSET  */|FCHS|FOPF|FLOADLIT| FILOADLIT|/* FLOATF|*/
	FMAX|FMIN|FLD|FLDF|FILDF|FILD|
	FLOADDLIT|FILDB|		  
	RPFOP|FMOP|  FPREM| FOP|FOPI|
        FOPII|FOPIIMS|FPOPMSI64|FIMIN|
        RMULTB|
	FISTR|FSTR|FSTRF|FILDIP|EXTENDMS|EXTENDANY|
	FIFGOTO|FIFGOTOgeneral|FSET|DPOPMS|
	FLOATLDR|FLOATMS|FPOPMS|FILDR|FISTB|FPREM|FIDIV|FISTP|FPUSHI|FPUSHD|FPUSHF|SSRPUSH| SDEREF
	|SDEREFDOUBLEw/* pushes */		
	|IFBOOL
	|SMLIT
	|SMRP
	|SADD
	|SMULIT
	|SMRADD
	|SOP
	|SMR
	|BSMR
	|STOREWR
	|STORER
	|STOREBR
	|REFPOP
	|REFPOP2
	|MEMPOP
	
	|BPOP
	|BSPOP
	|RPUSH
	|REFPUSH
	|BSPUSH
	|DMEMPUSH 
	|RPUSHE                    
	|BPUSH
	|STACKSTORE
	|STACKWSTORE
	|STACKBSTORE
	|RPOP
	|SMRSHIFT	|IFLITGOTO|LOADB|LOADW|LOAD|MOVZXB|MOVSXB|MOVZXW|MOVSXW|MOVZXB2|MOVZXBW|MOVSXBW|
		CLEARREG|STORELIT|LEA|INC|TESTIN|SHIFT|MLIT|GENSHIFT|
		RMLIT|ADDRMR| 		
 	/* Note !! the order below is important you must try and match
                         a 32 bit const before a 16 before an 8
                        Otherwise you will plant a word where you want to plant
                        a doubleword if the constant turns out to be small enough
                        to fit in. Thus PLANTBCONST  accepts a value of 13 even
                        if this is typed to be an int32
          
		*/
		PLANTICONST|PLANTWCONST|PLANTBCONST|PLANTRCONST|PLANTSCONST|
		DEC|IMULLIT|
		 MODFFFF| INTABS|
		Negate|NOTOP|MNegate|BTS|
		UINT8MAX|UINT8MIN|INT8MAX|INT8MIN|SELECT|
		PLANT|LITPUSH| MEMPUSH|
		SETB|SETW|SETUB|SETUW|
		SET|SETU|IFASS|SETeq|RMR|
		IFLITGOTO|IFULITGOTO|BIFLITGOTO|IFIN|IFGOTO|IFUGOTO|
		BIMUL|RLIT|LEA|RRM|fastIMUL|RMRB|/*RRD|*/RRPLUS|RR|DIV8|IDIV|fastBIDIV|BIDIV|BUDIV|UDIV|CDQ|RUWDIV|
		RIDIV|SIDIV|IDIVstack|IFGOTOB|IFGOTOW|
		GOTO|FAIL|BOUND4|BOUND0|BOUND16|BOUNDC|
		REPMOVSB|REPMOVSD |ADDUSB|SUBUSB|ADDSSB|SUBSSB|MULTSSB|MULTSSBAL |
                STOREWR|STORER|STOREBR| REFPUSH|RPUSH | MOVQSGEN|PADDD|PADDW|PADDB|PADDSB|PADDSB3|PADDUSB|PADDUB|SPADDSB|SPADDUSB|SPADDUB|PACKSSDW|PACKSSWB|PACKUSWB|
		CMPPB|CMPPBR|CMPPD|CMPPDR|CMPPW|CMPPWR|
		SPSUBD|PSUBW|PSUBB|PSUBSB|PSUBUSB|PSUBUB|POR|PAND|PANDN|PMULLSSB|
               PMULLW|MOVDS|MOVDL|MOVQS|MOVQL|MOVQLR|MOVOCTUINTS|MOVOCTUINTL|REP2|REP4|REP8|
		MMXPUSH|MOVQR]
 
/*

\end{verbatim}
*/
