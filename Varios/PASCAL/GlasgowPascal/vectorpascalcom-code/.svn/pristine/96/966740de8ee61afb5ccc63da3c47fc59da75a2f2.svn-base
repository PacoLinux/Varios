\documentclass[10pt, a4paper]{article}
\usepackage{graphicx, epsfig}
\reversemarginpar
\title{asmdoc.pas}
\begin{document}
\maketitle

\tableofcontents
\section{mmxandsse}
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\end{tabbing}
\textrm{\section{Multi-media instruction specifications}} 
\textrm{In this section we give a semi-formal definition of the multi media instructionsets used} 
\textrm{on Intel and AMD processors.} 
\textrm{For each instruction we provide a specification of its semantics and indicate the} 
\textrm{assembler syntax used. For all instructions we provide Nasm syntax and} 
\textrm{for the Intel MMX instructions we also provide the gnu assembler syntax.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\newcommand{\asm}[3]{\paragraph{Nasm Syntax }\texttt{#1}} 
\textrm{\paragraph{Gnu Syntax }\texttt{#2}} 
\textrm{\paragraph{Machines }#3\\}} 
\textrm{\def\sseii{P3,P4,ATHLONXP}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\\
\\
\parbox{14cm}{\textsf{\textbf{program}  \textit{MMXandSSE} ;}}\\
\end{tabbing}
\textrm{\paragraph{Base types :}} 
\textrm{we first define the the underlying base types used by the multi-media instructions.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\\
\+\parbox{14cm}{\textsf{\textbf{type} }}\\
\\
\parbox{14cm}{\textsf{\textit{int8} =-128..127;}}\\
\parbox{14cm}{\textsf{\textit{uint8} =0..255;}}\\
\parbox{14cm}{\textsf{\textit{int16} =-32768..32767;}}\\
\parbox{14cm}{\textsf{\textit{uint16} =0..65535;}}\\
\parbox{14cm}{\textsf{\textit{int32} =\textit{integer} ;}}\\
\parbox{14cm}{\textsf{\textit{int64}  = -9223372036854775807..9223372036854775807;}}\\
\parbox{14cm}{\textsf{\textit{ieee32} = \textit{real} ;}}\\
\parbox{14cm}{\textsf{\textit{ieee64} =\textit{double} ;}}\\
\end{tabbing}
\textrm{\paragraph{Aggregates} we now define the short vector types} 
\textrm{that the MMX, 3DNOW and  SSE instisructions.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\+ \\
\<\parbox{3.5cm}{\scriptsize{MMX}}\'\>\parbox{14cm}{\textsf{\textit{int32vec2} =\textbf{array} [0..1] \textbf{of}  \textit{int32} ;}}\\
\parbox{14cm}{\textsf{\textit{int16vec4} =\textbf{array} [0..3] \textbf{of}  \textit{int16} ;}}\\
\parbox{14cm}{\textsf{\textit{uint16vec4} =\textbf{array} [0..3] \textbf{of}  \textit{uint16} ;}}\\
\parbox{14cm}{\textsf{\textit{int8vec8} =\textbf{array} [0..7] \textbf{of}  \textit{int8} ;}}\\
\parbox{14cm}{\textsf{\textit{uint8vec8} =\textbf{array} [0..7] \textbf{of}  \textit{uint8} ;}}\\
\<\parbox{3.5cm}{\scriptsize{3DNOW}}\'\>\parbox{14cm}{\textsf{\textit{ieee32vec2} =\textbf{array} [0..1] \textbf{of}  \textit{ieee32} ;}}\\
\<\parbox{3.5cm}{\scriptsize{SSE}}\'\>\parbox{14cm}{\textsf{\textit{ieee32vec4} =\textbf{array} [0..3] \textbf{of}  \textit{ieee32} ;}}\\
\<\parbox{3.5cm}{\scriptsize{SSE2}}\'\>\parbox{14cm}{\textsf{\textit{ieee64vec2} =\textbf{array} [0..1] \textbf{of}  \textit{ieee64} ;}}\\
\parbox{14cm}{\textsf{\textit{int32vec4} =\textbf{array} [0..3] \textbf{of}  \textit{int32} ;}}\\
\parbox{14cm}{\textsf{\textit{int16vec8} =\textbf{array} [0..8] \textbf{of}  \textit{int16} ;}}\\
\parbox{14cm}{\textsf{\textit{uint16vec8} =\textbf{array} [0..8] \textbf{of}  \textit{uint16} ;}}\\
\parbox{14cm}{\textsf{\textit{int8vec16} =\textbf{array} [0..15] \textbf{of}  \textit{int8} ;}}\\
\parbox{14cm}{\textsf{\textit{uint8vec16} =\textbf{array} [0..15]\textbf{of}  \textit{uint8} ;}}\\
\\
\end{tabbing}
\textrm{\paragraph{MMX register types} we define the MMX registers as variant records with multiple possible} 
\textrm{internal representations.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\+ \\
\\
\+\parbox{14cm}{\textsf{\textit{mmx}  = \textbf{record} }}\\
\+\parbox{14cm}{\textsf {\textbf {case } \textsf{\textit{char}} \textbf{ of } }}\\
\parbox{14cm}{'a':\textsf{(\textit{a} : \textit{int64})}; }\\
\parbox{14cm}{'b':\textsf{(\textit{b} : \textit{int32vec2})}; }\\
\parbox{14cm}{'c':\textsf{(\textit{c} : \textit{int16vec4})}; }\\
\parbox{14cm}{'d':\textsf{(\textit{d} : \textit{uint16vec4})}; }\\
\parbox{14cm}{'e':\textsf{(\textit{e} : \textit{int8vec8})}; }\\
\parbox{14cm}{'f':\textsf{(\textit{f} : \textit{uint8vec8})}; }\\
\<\<\<\parbox{3.5cm}{\scriptsize{Only AMD}}\'\>\>\>\parbox{14cm}{'g':\textsf{(\textit{g} : \textit{ieee32vec2})}; }\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\parbox{14cm}{\textsf{\textit{regid} $=$ 0..7}; }\\
\end{tabbing}
\textrm{\paragraph{SSE register types} we define the types that} 
\textrm{of the SSE registers as a variant record allowing any of the} 
\textrm{formats supported in either SSE1 or SSE2 instruction-sets.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\+ \+ \\
\+\parbox{14cm}{\textsf{\textit{xmm} $=$ \textit{record}}}\\
\+\parbox{14cm}{\textsf {\textbf {case } \textsf{\textit{char}} \textbf{ of } }}\\
\<\<\<\<\parbox{3.5cm}{\scriptsize{SSE}}\'\>\>\>\>\parbox{14cm}{'a':\textsf{(\textit{a} : \textit{ieee32vec4})}; }\\
\<\<\<\<\parbox{3.5cm}{\scriptsize{SSE2}}\'\>\>\>\>\parbox{14cm}{'b':\textsf{(\textit{b} : \textit{ieee64vec2})}; }\\
\parbox{14cm}{'c':\textsf{(\textit{c} : \textit{int32vec4})}; }\\
\parbox{14cm}{'d':\textsf{(\textit{d} : \textit{int16vec8})}; }\\
\parbox{14cm}{'e':\textsf{(\textit{e} : \textit{uint16vec8})}; }\\
\parbox{14cm}{'f':\textsf{(\textit{f} : \textit{int8vec16})}; }\\
\parbox{14cm}{'g':\textsf{(\textit{g} : \textit{uint8vec16})}; }\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\\
\end{tabbing}
\textrm{\paragraph{Define memory}} 
\textrm{we define the memory both as an array of bytes and as an array} 
\textrm{of 16 byte vectors, because the SSE instructions have distinct} 
\textrm{aligned and unaligned memory load instructions.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\+ \+ \+ \\
\<\<\<\parbox{3.5cm}{\scriptsize{arbitrary}}\'\>\>\parbox{14cm}{\textsf{\textbf{const} }}\\
\parbox{14cm}{\textsf{\textit{memsize} $=$ 16777216}; }\\
\<\parbox{14cm}{\textsf{\textbf{type} }}\\
\parbox{14cm}{\textsf{\textit{alignment} $=$ (\textit{IA32})}; }\\
\<\parbox{14cm}{\textsf{\textbf{var} }}\\
\+\parbox{14cm}{\textsf{\textit{mem} : \textit{record}}}\\
\+\parbox{14cm}{\textsf {\textbf {case } \textsf{\textit{allignment}} \textbf{ of } }}\\
\parbox{14cm}{\textsf{\textit{IA32} : (\textit{bytemem} : \textit{array}$_{0..\textit{memsize} - 1}$)}; }\\
\parbox{14cm}{\textsf{\textit{SSE} : (\textit{vecmem} : \textit{array}$_{0..\textit{memsize} \div 16 - 1}$)}; }\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\parbox{14cm}{\textsf{\textit{mmxreg} : \textit{array}$_{\textit{regid}}$}; }\\
\parbox{14cm}{\textsf{\textit{xmmreg} : \textit{array}$_{\textit{regid}}$}; }\\
\\
\end{tabbing}
\textrm{Each instruction is now presented as a procedure to give the semantics,} 
\textrm{along with this the {\tt NASM} and {\tt gas}  syntax for the intruction is given.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\+ \+ \+ \+ \\
\\
\\
\<\textsf{\textbf{procedure}  \textit{ADDPS} \textit{(}  \textit{d} :\textit{regid} ; \textit{src} :\textit{xmm} );} (see Section \ref{sec:asmdocADDPS} )\\
\end{tabbing}
\section{procedure ADDPS}\label{sec:asmdocADDPS}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf {\textbf {procedure } \textsf{\textit{ADDPS} (\textit{d} : \textit{regid})}; }}\\
\end{tabbing}
\textrm{Add packed single precsion floating point. Source can be register or 16 byte aligned  memory vector.} 
\textrm{\asm{ADDPS xmmreg,r/m128}{}{P3,P4,ATHLONXP}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\parbox{14cm}{\textsf{\textit{xmmreg}$_{\textit{d}}$.\textit{a}$\leftarrow$ \textit{src.a} + \textit{xmmreg}$_{\textit{d}}$.\textit{a}}}\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\+\textsf{\textbf{procedure}  \textit{ADDSS} \textit{(}  \textit{d} :\textit{regid} ; \textit{src}  :\textit{xmm} );} (see Section \ref{sec:asmdoc/ADDPSADDSS} )\\
\end{tabbing}
\section{procedure ADDSS}\label{sec:asmdoc/ADDPSADDSS}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf {\textbf {procedure } \textsf{\textit{ADDSS} (\textit{d} : \textit{regid})}; }}\\
\end{tabbing}
\textrm{Scalar single floating point add. Source memory or xmm register.} 
\textrm{This instruction is useful if one wants to do floating point scalar arithmetic} 
\textrm{without corrupting the MMX registers.} 
\textrm{\asm{ADDSS xmmreg,xmmreg/mem32}{}{P3,P4,ATHLONXP}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\parbox{14cm}{\textsf{\textit{xmmreg}$_{\textit{d}}$.\textit{a}$_{0}$$\leftarrow$ \textit{src.a}$_{0}$ + \textit{xmmreg}$_{\textit{d}}$.\textit{a}$_{0}$}}\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\+\textsf{\textbf{procedure}  \textit{ANDNPS} \textit{(}  \textit{d} :\textit{regid} ; \textit{src} :\textit{xmm} );} (see Section \ref{sec:asmdoc/ADDPS/ADDSSANDNPS} )\\
\end{tabbing}
\section{procedure ANDNPS}\label{sec:asmdoc/ADDPS/ADDSSANDNPS}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf {\textbf {procedure } \textsf{\textit{ANDNPS} (\textit{d} : \textit{regid})}; }}\\
\end{tabbing}
\textrm{And negated, src is register or 16-byte aligned memory vector.} 
\textrm{\asm{ANDNPS xmmreg,r/m128}{}{\sseii}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\parbox{14cm}{\textsf{\textit{xmmreg}$_{\textit{d}}$.\textit{g}$\leftarrow$ \textit{src.g} $\wedge$ \textbf{not} \textit{xmmreg}$_{\textit{d}}$ .\textit{g}}}\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\+\textsf{\textbf{procedure}  \textit{ANDPS} \textit{(} \textit{d} :\textit{regid} ; \textit{src} :\textit{xmm} );} (see Section \ref{sec:asmdoc/ADDPS/ADDSS/ANDNPSANDPS} )\\
\end{tabbing}
\section{procedure ANDPS}\label{sec:asmdoc/ADDPS/ADDSS/ANDNPSANDPS}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf {\textbf {procedure } \textsf{\textit{ANDPS} (\textit{d} : \textit{regid})}; }}\\
\end{tabbing}
\textrm{16 byte bitwise logical and. \asm{ANDPS xmmreg,r/m128 }{}{\sseii}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\parbox{14cm}{\textsf{\textit{xmmreg}$_{\textit{d}}$.\textit{g}$\leftarrow$ \textit{src.g} $\wedge$ \textit{xmmreg}$_{\textit{d}}$.\textit{g}}; }\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\end{tabbing}
\textrm{We define an enumerated type for comparison operations} 
\textrm{that can be done in parallel on packed floating point values. These} 
\textrm{are passed as an 8 bit immediate field to the comparison opcode.} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\\
\\
\+\parbox{14cm}{\textsf{\textbf{type} }}\\
\parbox{14cm}{\textsf{\textit{fcomp} $=$ (\textit{feq})}; }\\
\\
\\
\<\textsf{\textbf{procedure}  \textit{CMPPS} \textit{(}  \textit{d} : \textit{regid} ; \textit{src} :\textit{xmm} ; \textit{imm8} :\textit{fcomp} );} (see Section \ref{sec:asmdoc/ADDPS/ADDSS/ANDNPS/ANDPSCMPPS} )\\
\end{tabbing}
\section{procedure CMPPS}\label{sec:asmdoc/ADDPS/ADDSS/ANDNPS/ANDPSCMPPS}

\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\parbox{14cm}{\textsf {\textbf {procedure } \textsf{\textit{CMPPS} (\textit{d} : \textit{regid})}; }}\\
\end{tabbing}
\textrm{Parallel single precision floating point comparison.} 
\textrm{Compares 4 floats and creates a boolean mask as a result.} 
\textrm{Such masks can then be used to select results from other vectors.} 
\textrm{The src is either a register or a 16-byte aligned vector.} 
\textrm{\asm{CMPPS xmmreg,r/m128,imm8}{}{\sseii}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\\
\+\parbox{14cm}{\textsf{\textbf{var} }}\\
\parbox{14cm}{\textsf{\textit{i} : 0..3}; }\\
\-\<\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\+\parbox{14cm}{\textsf {\textbf {for } \textsf{\textit{i}$\leftarrow$ 0} \textbf{ to } \textsf{3} \textbf{ do } }}\\
\+\parbox{14cm}{\textsf {\textbf {case } \textsf{\textit{imm8}} \textbf{ of } }}\\
\parbox{14cm}{\textsf{$\textit{feq} : \textit{xmmreg}_{d}.\textit{c}_{i}\leftarrow \left\{ \begin{array}{ll}
        -  1 & \mbox{if \textit{xmmreg}$_{\textit{d}}$.\textit{a}$_{\textit{i}}$ $=$ \textit{src.a}$_{\textit{i}}$}\\ 
       0 & \mbox{otherwise}\\ 
\end{array} \right.$}; }\\
\parbox{14cm}{\textsf{$\textit{flt} : \textit{xmmreg}_{d}.\textit{c}_{i}\leftarrow \left\{ \begin{array}{ll}
        -  1 & \mbox{if \textit{xmmreg}$_{\textit{d}}$.\textit{a}$_{\textit{i}}$ $<$ \textit{src.a}$_{\textit{i}}$}\\ 
       0 & \mbox{otherwise}\\ 
\end{array} \right.$}; }\\
\parbox{14cm}{\textsf{$\textit{fle} : \textit{xmmreg}_{d}.\textit{c}_{i}\leftarrow \left\{ \begin{array}{ll}
        -  1 & \mbox{if \textit{xmmreg}$_{\textit{d}}$.\textit{a}$_{\textit{i}}$ $\leq$ \textit{src.a}$_{\textit{i}}$}\\ 
       0 & \mbox{otherwise}\\ 
\end{array} \right.$}; }\\
\parbox{14cm}{\textsf{$\textit{feq} : \textit{xmmreg}_{d}.\textit{c}_{i}\leftarrow \left\{ \begin{array}{ll}
        -  1 & \mbox{if \textit{xmmreg}$_{\textit{d}}$.\textit{a}$_{\textit{i}}$ $=$ \textit{src.a}$_{\textit{i}}$}\\ 
       0 & \mbox{otherwise}\\ 
\end{array} \right.$}; }\\
\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\<\-\<\-\parbox{14cm}{\textsf{\textbf{end} ;}}\\
\\
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.23 CMPccPS: SSE Packed Single-FP} 
\textrm{Compare}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize  ; 0F C2 /r} 
\textrm{ib {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPEQPS xmmreg,r/m128 ; 0F C2 /r 00} 
\textrm{{[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPLEPS xmmreg,r/m128 ; 0F C2 /r 02} 
\textrm{{[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPLTPS xmmreg,r/m128 ; 0F C2 /r 01} 
\textrm{{[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPNEQPS xmmreg,r/m128 ; 0F C2 /r} 
\textrm{04 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPNLEPS xmmreg,r/m128 ; 0F C2 /r} 
\textrm{06 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPNLTPS xmmreg,r/m128 ; 0F C2 /r} 
\textrm{05 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPORDPS xmmreg,r/m128 ; 0F C2 /r} 
\textrm{07 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPUNORDPS xmmreg,r/m128 ; 0F C2 /r} 
\textrm{03 {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}CMPPS treats both operands as vectors of four 32-bit} 
\textrm{floating-point numbers. For each pair of such numbers CMPPS produces} 
\textrm{an all 1 32-bit mask or an all 0 32-bit mask, using the comparison} 
\textrm{specified by imm8, and puts this mask in the corresponding location} 
\textrm{in the destination register. The allowed values of imm8 are 0-7, which} 
\textrm{correspond to the eight pseudo-ops shown above. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.25 CMPccSS: SSE Scalar Single-FP} 
\textrm{Compare}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPSS xmmreg,xmmreg/mem32,imm8; F3} 
\textrm{0F C2 /r ib {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPEQSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{C2 /r 00 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPLESS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{C2 /r 02 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPLTSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{C2 /r 01 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPNEQSS xmmreg,xmmreg/mem32 ; F3} 
\textrm{0F C2 /r 04 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPNLESS xmmreg,xmmreg/mem32 ; F3} 
\textrm{0F C2 /r 06 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPNLTSS xmmreg,xmmreg/mem32 ; F3} 
\textrm{0F C2 /r 05 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPORDSS xmmreg,xmmreg/mem32 ; F3} 
\textrm{0F C2 /r 07 {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CMPUNORDSS xmmreg,xmmreg/mem32; F3} 
\textrm{0F C2 /r 03 {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}CMPSS is the same as CMPPS except that it compares} 
\textrm{only the first pair of 32-bit floating point numbers. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.28 COMISS: SSE Scalar Compare and} 
\textrm{Set EFLAGS}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize COMISS xmmreg,xmmreg/mem32 ; 0F 2F} 
\textrm{/r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}COMISS compares the 32-bit floating-point numbers} 
\textrm{in the lowest part of the two operands, and sets the CPU flags appropriately.} 
\textrm{COMISS differs from UCOMISS in that it signals an invalid numeric} 
\textrm{exeception if an operand is an sNaN or a qNaN, whereas UCOMISS does} 
\textrm{so only if an operand is an sNaN. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.30 CVTPI2PS: SSE Packed Integer} 
\textrm{to Floating-Point Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CVTPI2PS xmmreg,r/m64 ; 0F 2A /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}CVTPI2PS considers the source operand as a pair of} 
\textrm{signed 32-bit integers and converts them to 32-bit floating-point} 
\textrm{numbers, storing the result in the lower half of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.31 CVTPS2PI, CVTTPS2PI: SSE Packed} 
\textrm{Floating-Point to Integer Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CVTPS2PI mmxreg,xmmreg/mem64 ; 0F} 
\textrm{2D /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CVTTPS2PI mmxreg,xmmreg/mem64 ; 0F} 
\textrm{2C /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}These instructions consider the source operand as} 
\textrm{a pair of 32-bit floating-point numbers and convert them to signed} 
\textrm{32-bit integers, storing the result in the destination register. Note} 
\textrm{that if the source operand is a register then only its lower half} 
\textrm{is used. If the conversion is inexact, then CVTTPS2PI truncates, whereas} 
\textrm{CVTPS2PI rounds according to the MXCSR. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.32 CVTSI2SS: SSE Scalar Integer} 
\textrm{to Floating-Point Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CVTSI2SS xmmreg,r/m32 ; F3 0F 2A /r} 
\textrm{{[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}CVTSI2SS considers the source operand as a 32-bit} 
\textrm{signed integer, and converts it to a 32-bit float, storing the result} 
\textrm{in the lowest quarter of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.33 CVTSS2SI, CVTTSS2SI: SSE Scalar} 
\textrm{Floating-Point to Integer Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CVTSS2SI reg32,xmmreg/mem32 ; F3 0F} 
\textrm{2D /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize CVTTSS2SI reg32,xmmreg/mem32 ; F3} 
\textrm{0F 2C /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}These instructions consider the source operand as} 
\textrm{a 32-bit floating-point number and convert it to a signed 32-bit integer,} 
\textrm{storing the result in the destination register. Note that if the source} 
\textrm{operand is a register then only its lowest quarter is used. If the} 
\textrm{conversion is inexact, then CVTTSS2SI truncates, whereas CVTSS2SI} 
\textrm{rounds according to the MXCSR. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.37 DIVPS: Packed Single-FP Divide}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize DIVPS xmmreg,r/m128 ; 0F 5E /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}DIVPS considers both operands as vectors of four} 
\textrm{32-bit floating-point numbers and divides each such number in the} 
\textrm{destination register by the corresponding number in the source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.38 DIVSS: Scalar Single-FP Divide}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize DIVSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{5E /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}c\{DIVSS\} divides the 32-bit floating-point number} 
\textrm{in the lowest quarter of the destination register by the corresponding} 
\textrm{number in the source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.39 EMMS: Empty MMX State}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize EMMS ; 0F 77 {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}EMMS sets the FPU tag word (marking which floating-point} 
\textrm{registers are available) to all ones, meaning all registers are available} 
\textrm{for the FPU to use. It should be used after executing MMX instructions} 
\textrm{and before executing any subsequent floating-point operations. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.53 FEMMS: Fast EMMS}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize FEMMS ; 0F 0E {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}FEMMS is like EMMS except that it is faster and leaves} 
\textrm{the contents of the MMX / floating-point registers undefined. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.88 FXRSTOR: Restore FP, MMX and} 
\textrm{SSE States}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize FXRSTOR m512byte ; 0F AE /1 {[}P6,SSE,FPU{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}FXRSTOR reloads the FP and MMX state, and the SSE} 
\textrm{state (environment and registers), from the memory area defined by} 
\textrm{m512byte. This data should have been written by a previous FXSAVE. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.89 FXSAVE: Store FP and MMX State} 
\textrm{and Streaming SIMD}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize FXSAVE m512byte ; 0F AE /0 {[}P6,SSE,FPU{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}FXSAVE writes the current FP and MMX state, and SSE} 
\textrm{state (environment and registers), to the specified destination defined} 
\textrm{by m512byte. It does this without checking for pending unmasked floating-point} 
\textrm{exceptions (similar to the operation of FNSAVE). Unlike the FSAVE/FNSAVE} 
\textrm{instructions, the processor retains the contents of the FP and MMX} 
\textrm{state and Streaming SIMD Extension state in the processor after the} 
\textrm{state has been saved. This instruction has been optimized to maximize} 
\textrm{floating-point save performance. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.111 LDMXCSR: SSE Load MXCSR}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize LDMXCSR mem32 ; 0F AE /2 {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}LDMXCSR loads a 32-bit value out of memory and stores} 
\textrm{it into the MXCSR (the SSE control/status register). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.121 MASKMOVQ: Byte Mask Write}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MASKMOVQ mmxreg,mmxreg ; 0F F7 /r} 
\textrm{{[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MASKMOVQ uses the most significant bit in each byte} 
\textrm{of the second MMX resister to selectively write (0 = no write, 1 =} 
\textrm{write) each byte of the first MMX register to the 64-bit memory location} 
\textrm{DS:DI or DS:EDI (depending on the addressing mode). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.122 MAXPS: SSE Packed Single-FP} 
\textrm{Maximum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MAXPS xmmreg,r/m128 ; 0F 5F /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MAXPS considers its operands as vectors of four 32-bit} 
\textrm{floating-point numbers, and for each pair it stores the maximum of} 
\textrm{the the two in the corresponding quarter of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.123 MAXSS: SSE Scalar Single-FP} 
\textrm{Maximum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MAXSS xmmreg,r/m128 ; F3 0F 5F /r} 
\textrm{{[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MAXSS determines the maximum 32-bit floating-point} 
\textrm{number from the lowest quarter of both operands, and places this in} 
\textrm{the lowest quarter of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.124 MINPS: SSE Packed Single-FP} 
\textrm{Minimum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MINPS xmmreg,r/m128 ; 0F 5D /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MINPS considers its operands as vectors of four 32-bit} 
\textrm{floating-point numbers, and for each pair it stores the minimum of} 
\textrm{the the two in the corresponding quarter of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.125 MINSS: SSE Scalar Single-FP} 
\textrm{Maximum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MINSS xmmreg,r/m128 ; F3 0F 5D /r} 
\textrm{{[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MINSS determines the minimum 32-bit floating-point} 
\textrm{number from the lowest quarter of both operands, and places this in} 
\textrm{the lowest quarter of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.127 MOVAPS: Move Aligned Four Packed} 
\textrm{Single-FP}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVAPS xmmreg,r/m128 ; 0F 28 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVAPS r/m128,xmmreg ; 0F 29 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVAPS copies 16 bytes from the source operand to} 
\textrm{the destination operand. If one of the operands is a memory location} 
\textrm{it must be aligned on a 16-byte boundary (otherwise use MOVUPS). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.128 MOVD: Move Doubleword to/from} 
\textrm{MMX Register}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVD mmxreg,r/m32 ; 0F 6E /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVD r/m32,mmxreg ; 0F 7E /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVD copies 32 bits from its source (second) operand} 
\textrm{into its destination (first) operand. When the destination is a 64-bit} 
\textrm{MMX register, the top 32 bits are set to zero. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.129 MOVHLPS: SSE Move High to Low}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVHLPS xmmreg,xmmreg ; OF 12 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVHLPS moves 8 bytes from the upper half of the} 
\textrm{source register to the lower half of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.130 MOVHPS: SSE Move High}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVHPS xmmreg,mem64 ; 0F 16 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVHPS mem64,xmmreg ; 0F 17 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVHPS xmmreg,xmmreg ; 0F 16 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVHPS xmmreg,mem64 moves 8 bytes from mem64 to the} 
\textrm{upper half of xmmreg. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVHPS mem64,xmmreg moves 8 bytes from the upper} 
\textrm{half of xmmreg to mem64. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVHPS xmmreg,xmmreg is simply a synonym for MOVLHPS} 
\textrm{xmmreg,xmmreg. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.131 MOVLHPS: SSE Move Low to High}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVLHPS xmmreg,xmmreg ; 0F 16 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVLHPS moves 8 bytes from the lower half of the} 
\textrm{source register to the upper half of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.132 MOVLPS: SSE Move Low}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVLPS xmmreg,mem64 ; 0F 12 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVLPS mem64,xmmreg ; 0F 13 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVLPS xmmreg,xmmreg ; 0F 12 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVLPS xmmreg,mem64 moves 8 bytes from mem64 to the} 
\textrm{lower half of xmmreg. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVLPS mem64,xmmreg moves 8 bytes from the lower} 
\textrm{half of xmmreg to mem64. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVLPS xmmreg,xmmreg is simply a synonym for MOVHLPS} 
\textrm{xmmreg,xmmreg. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.133 MOVMSKPS: Move Mask To Integer}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVMSKPS reg32,xmmreg ; 0F 50 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVMSKPS forms a 4-bit mask from the most significant} 
\textrm{bit of each of the four 32-bit numbers in the source register, and} 
\textrm{stores this mask in the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.134 MOVNTPS: Move Aligned Four Packed} 
\textrm{Single-FP Non Temporal}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVNTPS mem128,xmmreg ; 0F 2B /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVNTPS copies the contents of the XMM register into} 
\textrm{the given memory location, doing so in such a way as to minimize cache} 
\textrm{pollution. The memory location must be 16-byte aligned. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.135 MOVNTQ: Move 64 Bits Non Temporal}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVNTQ mem64,mmxreg ; 0F E7 /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVNTPS copies the contents of the MMX register into} 
\textrm{the given memory location, doing so in such a way as to minimize cache} 
\textrm{pollution. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.136 MOVQ: Move Quadword to/from} 
\textrm{MMX Register}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVQ mmxreg,r/m64 ; 0F 6F /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVQ r/m64,mmxreg ; 0F 7F /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVQ copies 64 bits from its source (second) operand} 
\textrm{into its destination (first) operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.138 MOVSS: Move Scalar Single-FP}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{10 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVSS xmmreg/mem32,xmmreg ; F3 0F} 
\textrm{11 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVSS copies the lower 4 bytes of the source operand} 
\textrm{to the lower 4 bytes of the destination operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.140 MOVUPS: Move Unaligned Four} 
\textrm{Packed Single-FP}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVUPS xmmreg,r/m128 ; 0F 10 /r {[}KATMAI,SSE{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MOVUPS r/m128,xmmreg ; 0F 11 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MOVUPS copies 16 bytes from the source operand to} 
\textrm{the destination operand. In contrast to MOVAPS, no assumption is made} 
\textrm{about alignment. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.143 MULSS: Scalar Single-FP Multiply}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize MULSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{59 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}MULSS multiplies the first of the four 32-bit floating-point} 
\textrm{numbers in the destination register by the corresponding number in} 
\textrm{the source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.147 ORPS: SSE Bitwise Logical OR}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize ORPS xmmreg,r/m128 ; 0F 56 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}ORPS performs a bitwise OR operation on the source} 
\textrm{operand and the destination register, and stores the result in the} 
\textrm{destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.150 PACKSSDW, PACKSSWB, PACKUSWB:} 
\textrm{Pack Data}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PACKSSDW mmxreg,r/m64 ; 0F 6B /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PACKSSWB mmxreg,r/m64 ; 0F 63 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PACKUSWB mmxreg,r/m64 ; 0F 67 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}All these instructions start by forming a notional} 
\textrm{128-bit word by placing the source (second) operand on the left of} 
\textrm{the destination (first) operand. PACKSSDW then splits this 128-bit} 
\textrm{word into four doublewords, converts each to a word, and loads them} 
\textrm{side by side into the destination register; PACKSSWB and PACKUSWB} 
\textrm{both split the 128-bit word into eight words, converts each to a byte,} 
\textrm{and loads those side by side into the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PACKSSDW and PACKSSWB perform signed saturation when} 
\textrm{reducing the length of numbers: if the number is too large to fit} 
\textrm{into the reduced space, they replace it by the largest signed number} 
\textrm{(7FFFh or 7Fh) that will fit, and if it is too small then they replace} 
\textrm{it by the smallest signed number (8000h or 80h) that will fit. PACKUSWB} 
\textrm{performs unsigned saturation: it treats its input as unsigned, and} 
\textrm{replaces it by the largest unsigned number that will fit. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.151 PADDxx: MMX Packed Addition}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDB mmxreg,r/m64 ; 0F FC /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDW mmxreg,r/m64 ; 0F FD /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDD mmxreg,r/m64 ; 0F FE /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDSB mmxreg,r/m64 ; 0F EC /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDSW mmxreg,r/m64 ; 0F ED /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDUSB mmxreg,r/m64 ; 0F DC /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDUSW mmxreg,r/m64 ; 0F DD /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PADDxx all perform packed addition between their} 
\textrm{two 64-bit operands, storing the result in the destination (first)} 
\textrm{operand. The PADDxB forms treat the 64-bit operands as vectors of} 
\textrm{eight bytes, and add each byte individually; PADDxW treat the operands} 
\textrm{as vectors of four words; and PADDD treats its operands as vectors} 
\textrm{of two doublewords. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PADDSB and PADDSW perform signed saturation on the} 
\textrm{sum of each pair of bytes or words: if the result of an addition is} 
\textrm{too large or too small to fit into a signed byte or word result, it} 
\textrm{is clipped (saturated) to the largest or smallest value which will} 
\textrm{fit. PADDUSB and PADDUSW similarly perform unsigned saturation, clipping} 
\textrm{to 0FFh or 0FFFFh if the result is larger than that. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.152 PADDSIW: MMX Packed Addition} 
\textrm{to Implicit Destination}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PADDSIW mmxreg,r/m64 ; 0F 51 /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PADDSIW, specific to the Cyrix extensions to the} 
\textrm{MMX instruction set, performs the same function as PADDSW, except} 
\textrm{that the result is not placed in the register specified by the first} 
\textrm{operand, but instead in the register whose number differs from the} 
\textrm{first operand only in the last bit. So PADDSIW MM0,MM2 would put the} 
\textrm{result in MM1, but PADDSIW MM1,MM2 would put the result in MM0. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.153 PAND, PANDN: MMX Bitwise AND} 
\textrm{and AND-NOT}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PAND mmxreg,r/m64 ; 0F DB /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PANDN mmxreg,r/m64 ; 0F DF /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PAND performs a bitwise AND operation between its} 
\textrm{two operands (i.e. each bit of the result is 1 if and only if the} 
\textrm{corresponding bits of the two inputs were both 1), and stores the} 
\textrm{result in the destination (first) operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PANDN performs the same operation, but performs a} 
\textrm{one's complement operation on the destination (first) operand first. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.154 PAVEB: MMX Packed Average}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PAVEB mmxreg,r/m64 ; 0F 50 /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PAVEB, specific to the Cyrix MMX extensions, treats} 
\textrm{its two operands as vectors of eight unsigned bytes, and calculates} 
\textrm{the average of the corresponding bytes in the operands. The resulting} 
\textrm{vector of eight averages is stored in the first operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.155 PAVGB, PAVGW: Packed Average}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PAVGB mmxreg,r/m64 ; 0F E0 /r {[}KATMAI{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PAVGW mmxreg,r/m64 ; 0F E3 /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}For each byte in the source register, PAVGB computes} 
\textrm{the average of this byte and the corresponding byte in the destination} 
\textrm{register, and stores this average in place of the byte in the source} 
\textrm{register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PAVGW does the same thing, but operating on 4 pairs} 
\textrm{of words instead of 8 pairs of bytes. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}In all cases, the values operated one are considered} 
\textrm{to be unsigned, and the result is rounded up if it is not an integer. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.156 PAVGUSB: Average Of Unsigned} 
\textrm{Packed 8-bit Values}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PAVGUSB mmxreg,r/m64 ; 0F 0F /r BF} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PAVGUSB produces the averages (rounded up) of the} 
\textrm{eight unsigned 8-bit integer values in the source operand and the} 
\textrm{eight corresponding unsigned 8-bit integer values in the destination} 
\textrm{register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.157 PCMPxx: MMX Packed Comparison}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PCMPEQB mmxreg,r/m64 ; 0F 74 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PCMPEQW mmxreg,r/m64 ; 0F 75 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PCMPEQD mmxreg,r/m64 ; 0F 76 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PCMPGTB mmxreg,r/m64 ; 0F 64 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PCMPGTW mmxreg,r/m64 ; 0F 65 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PCMPGTD mmxreg,r/m64 ; 0F 66 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}The PCMPxx instructions all treat their operands} 
\textrm{as vectors of bytes, words, or doublewords; corresponding elements} 
\textrm{of the source and destination are compared, and the corresponding} 
\textrm{element of the destination (first) operand is set to all zeros or} 
\textrm{all ones depending on the result of the comparison. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PCMPxxB treats the operands as vectors of eight bytes,} 
\textrm{PCMPxxW treats them as vectors of four words, and PCMPxxD as two doublewords. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PCMPEQx sets the corresponding element of the destination} 
\textrm{operand to all ones if the two elements compared are equal; PCMPGTx} 
\textrm{sets the destination element to all ones if the element of the first} 
\textrm{(destination) operand is greater (treated as a signed integer) than} 
\textrm{that of the second (source) operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.158 PDISTIB: MMX Packed Distance} 
\textrm{and Accumulate with Implied Register}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PDISTIB mmxreg,mem64 ; 0F 54 /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PDISTIB, specific to the Cyrix MMX extensions, treats} 
\textrm{its two input operands as vectors of eight unsigned bytes. For each} 
\textrm{byte position, it finds the absolute difference between the bytes} 
\textrm{in that position in the two input operands, and adds that value to} 
\textrm{the byte in the same position in the implied output register. The} 
\textrm{addition is saturated to an unsigned byte in the same way as PADDUSB. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}The implied output register is found in the same} 
\textrm{way as PADDSIW (\uline{\textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Note that PDISTIB cannot take a register as its second} 
\textrm{source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.159 PEXTRW: Extract Word}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PEXTRW reg32,mmxreg,imm8 ; 0F C5 /r} 
\textrm{ib {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PEXTRW moves the word in the MMX register (selected} 
\textrm{by the two least significant bits of imm8) into the lower half of} 
\textrm{the 32-bit integer register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.160 PF2ID: Packed Floating-Point} 
\textrm{To Integer Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PF2ID mmxreg,r/m64 ; 0F 0F /r 1D {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PF2ID converts two 32-bit floating point numbers} 
\textrm{in the source operand into 32-bit signed integers in the destination} 
\textrm{register, using truncation. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.161 PF2IW: Packed Floating-Point} 
\textrm{to Integer Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PF2IW mmxreg,r/m64 ; 0F 0F /r 1C {[}ATHLON{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PF2IW converts two 32-bit floating point numbers} 
\textrm{in the source operand into 16-bit signed integers in the destination} 
\textrm{register, using truncation and sign-extending to 32 bits. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.162 PFACC: Floating-Point Accumulate}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFACC mmxreg,r/m64 ; 0F 0F /r AE {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFACC treats the source and destination operands} 
\textrm{as pairs of 32-bit floating-point numbers. The sum of the pair in} 
\textrm{the destination register is stored in the lower half of the destination} 
\textrm{register, and the sum of the pair in the source operand is stored} 
\textrm{in the upper half of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.163 PFADD: Packed Floating-Point} 
\textrm{Addition}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFADD mmxreg,r/m64 ; 0F 0F /r 9E {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFADD adds the contents of the source operand to} 
\textrm{the contents of the destination register, treating both as pairs of} 
\textrm{32-bit floating-point numbers. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.164 PFCMPEQ, PFCMPGE, PFCMPGT: Packed} 
\textrm{Floating-Point Comparison.}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFCMPEQ mmxreg,r/m64 ; 0F 0F /r B0} 
\textrm{{[}3DNOW{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFCMPGE mmxreg,r/m64 ; 0F 0F /r 90} 
\textrm{{[}3DNOW{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFCMPGT mmxreg,r/m64 ; 0F 0F /r A0} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}These instructions perform comparisons between pairs} 
\textrm{of 32-bit floating-point numbers, storing the two results in the destination} 
\textrm{register. PFCMPEQ stores 0xFFFFFFFF if the numbers are equal, and} 
\textrm{0 otherwise. PFCMPGE stores 0xFFFFFFFF if the destination is greater} 
\textrm{than or equal to the source, and 0 otherwise. PFCMPGT stores 0xFFFFFFFF} 
\textrm{if the destination is greater than the source, and 0 otherwise. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.165 PFMAX: Packed Floating-Point} 
\textrm{Maximum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFMAX mmxreg,r/m64 ; 0F 0F /r A4 {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}For each half of the destination register, sets it} 
\textrm{equal to the maximum of itself and the corresponding half of the source} 
\textrm{operand, treating both as 32-bit floating-point numbers. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.166 PFMIN: Packed Floating-Point} 
\textrm{Minimum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFMIN mmxreg,r/m64 ; 0F 0F /r 94 {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}For each half of the destination register, sets it} 
\textrm{equal to the minimum of itself and the corresponding half of the source} 
\textrm{operand, treating both as 32-bit floating-point numbers. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.167 PFMUL: Packed Floating-Point} 
\textrm{Multiply}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFMUL mmxreg,r/m64 ; 0F 0F /r B4 {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFMUL multiples the contents of the destination register} 
\textrm{by the contents of the source operand, treating both as pairs of 32-bit} 
\textrm{floating-point numbers. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.168 PFNACC: Packed Floating-Point} 
\textrm{Negative Accumulate}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFNACC mmxreg,r/m64 ; 0F 0F /r 8A} 
\textrm{{[}ATHLON{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFNACC works the same as PFACC, except that the difference} 
\textrm{rather than the sum is stored, the value in the upper half in both} 
\textrm{cases being subtracted from the value in the lower half. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.169 PFPNACC: Packed Floating-Point} 
\textrm{Mixed Accumulate}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFPNACC mmxreg,r/m64 ; 0F 0F /r 8E} 
\textrm{{[}ATHLON{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFPNACC is a mixture of PFACC and PFNACC. The new} 
\textrm{value of the lower half of the destination register is obtained by} 
\textrm{subtracting the upper half from the lower half. But the new value} 
\textrm{of the upper half of the destination register is obtained by adding} 
\textrm{both halves of the source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.170 PFRCP: Floating-Point Reciprocal} 
\textrm{Approximation}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFRCP mmxreg,r/m64 ; 0F 0F /r 96 {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFRCP calculates an approximation (accurate to 14} 
\textrm{bits) of the reciprocal of the 32-bit floating-point number in the} 
\textrm{lower half of the source and stores it in both halves of the destination. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.171 PFRCPIT1: Floating-Point Reciprocal} 
\textrm{Refinement}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFRCPIT1 mmxreg,r/m64 ; 0F 0F /r A6} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFRCPIT1 performs the first step in the iterative} 
\textrm{refinement of a reciprocal produced by PFRCP. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.172 PFRCPIT2: Floating-Point Refinement} 
\textrm{(Last Step)}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFRCPIT2 mmxreg,r/m64 ; 0F 0F /r B6} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFRCPIT2 performs the second and final step in the} 
\textrm{iterative refinement of a reciprocal produced by PFRCP or of a reciprocal} 
\textrm{square root produced by PFRSQRT. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.173 PFRSQIT1: Floating-Point Reciprocal} 
\textrm{Square-Root Refinement}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFRSQIT1 mmxreg,r/m64 ; 0F 0F /r A7} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFRSQIT1 performs the first step in the iterative} 
\textrm{refinement of a reciprocal square root produced by PFRSQRT. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.174 PFRSQRT: Floating-Point Reciprocal} 
\textrm{Square-Root Approximation}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFRSQRT mmxreg,r/m64 ; 0F 0F /r 97} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFRSQRT calculates an approximation (accurate to} 
\textrm{15 bits) of the reciprocal of the square root of the 32-bit floating-point} 
\textrm{number in the lower half of the source and stores it in both halves} 
\textrm{of the destination. If the source value is negative then it is treated} 
\textrm{as positive except that its sign is copied to the result. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.175 PFSUB: Packed Floating-Point} 
\textrm{Subtraction}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFSUB mmxreg,r/m64 ; 0F 0F /r 9A {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFSUB subtracts the pair of 32-bit floating-point} 
\textrm{numbers in the source operand from the corresponding pair in the destination} 
\textrm{register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.176 PFSUBR: Packed Floating-Point} 
\textrm{Reverse Subtraction}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PFSUBR mmxreg,r/m64 ; 0F 0F /r AA} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PFSUB subtracts the pair of 32-bit floating-point} 
\textrm{numbers in the source operand from the corresponding pair in the destination} 
\textrm{register, and then negates the results. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.177 PI2FD: Packed Integer To Floating-Point} 
\textrm{Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PI2FD mmxreg,r/m64 ; 0F 0F /r 0D {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PI2FD converts the pair of signed 32-bit integers} 
\textrm{in the source operand into 32-bit floating-point numbers (using truncation)} 
\textrm{and stores the results in the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.178 PI2FW: Packed Integer To Floating-Point} 
\textrm{Conversion}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PI2FW mmxreg,r/m64 ; 0F 0F /r 0C {[}ATHLON{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PI2FW treats the source operand as a pair of signed} 
\textrm{16-bit integers, by ignoring the upper 16 bits of each 32-bit half.} 
\textrm{These integers are converted to 32-bit floating-point numbers and} 
\textrm{stored in the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.179 PINSRW: Insert Word}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PINSRW mmxreg,r/m16,imm8 ; 0F C4 /r} 
\textrm{ib {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PINSRW loads a word from the 16-bit integer register} 
\textrm{or memory location and inserts it in the MMX register, at a position} 
\textrm{defined by the two least significant bits of the imm8 constant. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Instead of specifying a 16-bit register you can instead} 
\textrm{specify a 32-bit register, of which only the bottom half will be used.} 
\textrm{This may seem peculiar, but it's the way Intel prefers. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.180 PMACHRIW: MMX Packed Multiply} 
\textrm{and Accumulate with Rounding}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMACHRIW mmxreg,mem64 ; 0F 5E /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMACHRIW acts almost identically to PMULHRIW (\uline{\textcolor[rgb]{0.000,0.000,1.000}{section A.189)}},} 
\textrm{but instead of storing its result in the implied destination register,} 
\textrm{it adds its result, as four packed words, to the implied destination} 
\textrm{register. No saturation is done: the addition can wrap around. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Note that PMACHRIW cannot take a register as its} 
\textrm{second source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.181 PMADDWD: MMX Packed Multiply} 
\textrm{and Add}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMADDWD mmxreg,r/m64 ; 0F F5 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMADDWD treats its two inputs as vectors of four} 
\textrm{signed words. It multiplies corresponding elements of the two operands,} 
\textrm{giving four signed doubleword results. The top two of these are added} 
\textrm{and placed in the top 32 bits of the destination (first) operand;} 
\textrm{the bottom two are added and placed in the bottom 32 bits. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.182 PMAGW: MMX Packed Magnitude}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMAGW mmxreg,r/m64 ; 0F 52 /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMAGW, specific to the Cyrix MMX extensions, treats} 
\textrm{both its operands as vectors of four signed words. It compares the} 
\textrm{absolute values of the words in corresponding positions, and sets} 
\textrm{each word of the destination (first) operand to whichever of the two} 
\textrm{words in that position had the larger absolute value. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.183 PMAXSW: Packed Signed Integer} 
\textrm{Word Maximum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMAXSW mmxreg,r/m64 ; 0F EE /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMAXSW considers both operands as vectors of 4 signed} 
\textrm{words. Each such word in the destination register is replaced by the} 
\textrm{corresponding word in the source operand if that is larger. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.184 PMAXUB: Packed Unsigned Integer} 
\textrm{Byte Maximum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMAXUB mmxreg,r/m64 ; 0F DE /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMAXUB considers both operands as vectors of 8 unsigned} 
\textrm{bytes. Each such byte in the destination register is replaced by the} 
\textrm{corresponding byte in the source operand if that is larger. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.185 PMINSW: Packed Signed Integer} 
\textrm{Word Minimum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMINSW mmxreg,r/m64 ; 0F EA /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMINSW considers both operands as vectors of 4 signed} 
\textrm{words. Each such word in the destination register is replaced by the} 
\textrm{corresponding word in the source operand if that is smaller. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.186 PMINUB: Packed Unsigned Integer} 
\textrm{Byte Minimum}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMINUB mmxreg,r/m64 ; 0F DA /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMINUB considers both operands as vectors of 8 unsigned} 
\textrm{bytes. Each such byte in the destination register is replaced by the} 
\textrm{corresponding byte in the source operand if that is smaller. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.187 PMOVMSKB: Move Byte Mask To} 
\textrm{Integer}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMOVMSKB reg32,mmxreg ; 0F D7 /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMOVMSKB creates an 8-bit mask formed of the most} 
\textrm{significant bit of each byte of its source operand, and stores this} 
\textrm{in the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.188 PMULHRWA: Packed Multiply With} 
\textrm{Rounding}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMULHRWA mmxreg,r/m64 ; 0F 0F /r B7} 
\textrm{{[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMULHRWA performs the same operation as PMULHW, except} 
\textrm{that it rounds the results rather than truncating. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Note that the PMULHRWA instruction is called PMULHRW} 
\textrm{in AMD documentation. But NASM uses the form PMULHRWA to avoid conflict} 
\textrm{with Cyrix's different PMULHRW instruction (which NASM calls PMULHRWC). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.189 PMULHRWC, PMULHRIW: MMX Packed} 
\textrm{Multiply High with Rounding}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMULHRWC mmxreg,r/m64 ; 0F 59 /r {[}CYRIX,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMULHRIW mmxreg,r/m64 ; 0F 5D /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}These instructions, specific to the Cyrix MMX extensions,} 
\textrm{treat their operands as vectors of four signed words. Words in corresponding} 
\textrm{positions are multiplied, to give a 32-bit value in which bits 30} 
\textrm{and 31 are guaranteed equal. Bits 30 to 15 of this value (bit mask} 
\textrm{0x7FFF8000) are taken and stored in the corresponding position of} 
\textrm{the destination operand, after first rounding the low bit (equivalent} 
\textrm{to adding 0x4000 before extracting bits 30 to 15). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}For PMULHRWC, the destination operand is the first} 
\textrm{operand; for PMULHRIW the destination operand is implied by the first} 
\textrm{operand in the manner of PADDSIW (\uline{\textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Note that the PMULHRWC instruction is called PMULHRW} 
\textrm{in Cyrix documentation. But NASM uses the form PMULHRWC to avoid conflict} 
\textrm{with AMD's different PMULHRW instruction (which NASM calls PMULHRWA) \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.190 PMULHUW: Packed Multiply High} 
\textrm{Unsigned}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMULHUW mmxreg,r/m64 ; 0F E4 /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMULHUW multiplies the four unsigned words in the} 
\textrm{destination register with the four unsigned words in the source operand.} 
\textrm{The high-order 16 bits of each of the 32-bit intermediate results} 
\textrm{are written to the destination operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.191 PMULHW, PMULLW: MMX Packed Multiply}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMULHW mmxreg,r/m64 ; 0F E5 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMULLW mmxreg,r/m64 ; 0F D5 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMULxW treats its two inputs as vectors of four signed} 
\textrm{words. It multiplies corresponding elements of the two operands, giving} 
\textrm{four signed doubleword results. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMULHW then stores the top 16 bits of each doubleword} 
\textrm{in the destination (first) operand; PMULLW stores the bottom 16 bits} 
\textrm{of each doubleword in the destination operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.192 PMVccZB: MMX Packed Conditional} 
\textrm{Move}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMVZB mmxreg,mem64 ; 0F 58 /r {[}CYRIX,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMVNZB mmxreg,mem64 ; 0F 5A /r {[}CYRIX,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMVLZB mmxreg,mem64 ; 0F 5B /r {[}CYRIX,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PMVGEZB mmxreg,mem64 ; 0F 5C /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}These instructions, specific to the Cyrix MMX extensions,} 
\textrm{perform parallel conditional moves. The two input operands are treated} 
\textrm{as vectors of eight bytes. Each byte of the destination (first) operand} 
\textrm{is either written from the corresponding byte of the source (second)} 
\textrm{operand, or left alone, depending on the value of the byte in the} 
\textrm{implied operand (specified in the same way as PADDSIW, in \uline{\textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PMVZB performs each move if the corresponding byte} 
\textrm{in the implied operand is zero. PMVNZB moves if the byte is non-zero.} 
\textrm{PMVLZB moves if the byte is less than zero, and PMVGEZB moves if the} 
\textrm{byte is greater than or equal to zero. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Note that these instructions cannot take a register} 
\textrm{as their second source operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.196 POR: MMX Bitwise OR}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize POR mmxreg,r/m64 ; 0F EB /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}POR performs a bitwise OR operation between its two} 
\textrm{operands (i.e. each bit of the result is 1 if and only if at least} 
\textrm{one of the corresponding bits of the two inputs was 1), and stores} 
\textrm{the result in the destination (first) operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.197 PREFETCH, PREFETCHW: Prefetch} 
\textrm{cache line}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PREFETCH mem ; 0F 0D /0 {[}3DNOW{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PREFETCHW mem ; 0F 0D /1 {[}3DNOW{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PREFETCH loads a cache line into the L1 data cache.} 
\textrm{PREFETCHW does the same, but also marks the cache line as modified. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.198 PREFETCHNTA, PREFETCHT0, PREFETCHT1,} 
\textrm{PREFETCHT2: Prefetch cache line}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PREFETCHNTA mem ; 0F 18 /0 {[}KATMAI{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PREFETCHT0 mem ; 0F 18 /1 {[}KATMAI{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PREFETCHT1 mem ; 0F 18 /2 {[}KATMAI{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PREFETCHT2 mem ; 0F 18 /3 {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}These instructions move the data specified by the} 
\textrm{address closer to the processor using, respectively, the nta, t0,} 
\textrm{t1 and t2 hints. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.199 PSADBW: Packed Sum of Absolute} 
\textrm{Differences}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSADBW mmxreg,r/m64 ; 0F F6 /r {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSADBW computes the sum of the absolute differences} 
\textrm{of the unsigned signed bytes in the destination register and those} 
\textrm{in the source operand. It then places this sum in the lowest word} 
\textrm{of the destination register, and sets the three other words to zero. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.200 PSHUFW: Packed Shuffle Word}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSHUFW mmxreg,r/m64,imm8 ; 0F 70 /r} 
\textrm{ib {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSHUFW uses the imm8 value to select which of the} 
\textrm{four words of the source operand will be placed in each of the words} 
\textrm{of the destination register. Bits 0 and 1 of imm8 encode the source} 
\textrm{for word 0 (the lowest word) of the destination register, bits 2 and} 
\textrm{3 encode the source for word 1, bits 4 and 5 for word 2, and bits} 
\textrm{6 and 7 for word 3 (the highest word). Each 2-bit encoding is a number} 
\textrm{in the range 0-3 that specifies the corresponding word of the source} 
\textrm{operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.201 PSLLx, PSRLx, PSRAx: MMX Bit} 
\textrm{Shifts}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSLLW mmxreg,r/m64 ; 0F F1 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSLLW mmxreg,imm8 ; 0F 71 /6 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSLLD mmxreg,r/m64 ; 0F F2 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSLLD mmxreg,imm8 ; 0F 72 /6 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSLLQ mmxreg,r/m64 ; 0F F3 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSLLQ mmxreg,imm8 ; 0F 73 /6 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRAW mmxreg,r/m64 ; 0F E1 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRAW mmxreg,imm8 ; 0F 71 /4 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRAD mmxreg,r/m64 ; 0F E2 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRAD mmxreg,imm8 ; 0F 72 /4 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRLW mmxreg,r/m64 ; 0F D1 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRLW mmxreg,imm8 ; 0F 71 /2 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRLD mmxreg,r/m64 ; 0F D2 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRLD mmxreg,imm8 ; 0F 72 /2 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRLQ mmxreg,r/m64 ; 0F D3 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSRLQ mmxreg,imm8 ; 0F 73 /2 ib {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSxxQ perform simple bit shifts on the 64-bit MMX} 
\textrm{registers: the destination (first) operand is shifted left or right} 
\textrm{by the number of bits given in the source (second) operand, and the} 
\textrm{vacated bits are filled in with zeros (for a logical shift) or copies} 
\textrm{of the original sign bit (for an arithmetic right shift). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSxxW and PSxxD perform packed bit shifts: the destination} 
\textrm{operand is treated as a vector of four words or two doublewords, and} 
\textrm{each element is shifted individually, so bits shifted out of one element} 
\textrm{do not interfere with empty bits coming into the next. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSLLx and PSRLx perform logical shifts: the vacated} 
\textrm{bits at one end of the shifted number are filled with zeros. PSRAx} 
\textrm{performs an arithmetic right shift: the vacated bits at the top of} 
\textrm{the shifted number are filled with copies of the original top (sign)} 
\textrm{bit. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.202 PSUBxx: MMX Packed Subtraction}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBB mmxreg,r/m64 ; 0F F8 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBW mmxreg,r/m64 ; 0F F9 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBD mmxreg,r/m64 ; 0F FA /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBSB mmxreg,r/m64 ; 0F E8 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBSW mmxreg,r/m64 ; 0F E9 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBUSB mmxreg,r/m64 ; 0F D8 /r {[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBUSW mmxreg,r/m64 ; 0F D9 /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSUBxx all perform packed subtraction between their} 
\textrm{two 64-bit operands, storing the result in the destination (first)} 
\textrm{operand. The PSUBxB forms treat the 64-bit operands as vectors of} 
\textrm{eight bytes, and subtract each byte individually; PSUBxW treat the} 
\textrm{operands as vectors of four words; and PSUBD treats its operands as} 
\textrm{vectors of two doublewords. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}In all cases, the elements of the operand on the} 
\textrm{right are subtracted from the corresponding elements of the operand} 
\textrm{on the left, not the other way round. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSUBSB and PSUBSW perform signed saturation on the} 
\textrm{sum of each pair of bytes or words: if the result of a subtraction} 
\textrm{is too large or too small to fit into a signed byte or word result,} 
\textrm{it is clipped (saturated) to the largest or smallest value which will} 
\textrm{fit. PSUBUSB and PSUBUSW similarly perform unsigned saturation, clipping} 
\textrm{to 0FFh or 0FFFFh if the result is larger than that. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.203 PSUBSIW: MMX Packed Subtract} 
\textrm{with Saturation to Implied Destination}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSUBSIW mmxreg,r/m64 ; 0F 55 /r {[}CYRIX,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSUBSIW, specific to the Cyrix extensions to the} 
\textrm{MMX instruction set, performs the same function as PSUBSW, except} 
\textrm{that the result is not placed in the register specified by the first} 
\textrm{operand, but instead in the implied destination register, specified} 
\textrm{as for PADDSIW (\uline{\textcolor[rgb]{0.000,0.000,1.000}{section A.152)}}. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.204 PSWAPD: Packed Swap Doubleword}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PSWAPD mmxreg,r/m64 ; 0F 0F /r BB} 
\textrm{{[}ATHLON{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PSWAPD copies the source operand to the destination} 
\textrm{register, swapping the upper and lower halves in the process. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.205 PUNPCKxxx: Unpack Data}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PUNPCKHBW mmxreg,r/m64 ; 0F 68 /r} 
\textrm{{[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PUNPCKHWD mmxreg,r/m64 ; 0F 69 /r} 
\textrm{{[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PUNPCKHDQ mmxreg,r/m64 ; 0F 6A /r} 
\textrm{{[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PUNPCKLBW mmxreg,r/m64 ; 0F 60 /r} 
\textrm{{[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PUNPCKLWD mmxreg,r/m64 ; 0F 61 /r} 
\textrm{{[}PENT,MMX{]} }\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PUNPCKLDQ mmxreg,r/m64 ; 0F 62 /r} 
\textrm{{[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKxx all treat their operands as vectors, and} 
\textrm{produce a new vector generated by interleaving elements from the two} 
\textrm{inputs. The PUNPCKHxx instructions start by throwing away the bottom} 
\textrm{half of each input operand, and the PUNPCKLxx instructions throw away} 
\textrm{the top half. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}The remaining elements, totalling 64 bits, are then} 
\textrm{interleaved into the destination, alternating elements from the second} 
\textrm{(source) operand and the first (destination) operand: so the leftmost} 
\textrm{element in the result always comes from the second operand, and the} 
\textrm{rightmost from the destination. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKxBW works a byte at a time, PUNPCKxWD a word} 
\textrm{at a time, and PUNPCKxDQ a doubleword at a time. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}So, for example, if the first operand held 0x7A6A5A4A3A2A1A0A} 
\textrm{and the second held 0x7B6B5B4B3B2B1B0B, then: \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKHBW would return 0x7B7A6B6A5B5A4B4A. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKHWD would return 0x7B6B7A6A5B4B5A4A. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKHDQ would return 0x7B6B5B4B7A6A5A4A. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKLBW would return 0x3B3A2B2A1B1A0B0A. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKLWD would return 0x3B2B3A2A1B0B1A0A. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PUNPCKLDQ would return 0x3B2B1B0B3A2A1A0A. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.209 PXOR: MMX Bitwise XOR}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize PXOR mmxreg,r/m64 ; 0F EF /r {[}PENT,MMX{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}PXOR performs a bitwise XOR operation between its} 
\textrm{two operands (i.e. each bit of the result is 1 if and only if exactly} 
\textrm{one of the corresponding bits of the two inputs was 1), and stores} 
\textrm{the result in the destination (first) operand. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.211 RCPPS: SSE Packed Single-FP} 
\textrm{Reciprocal Approximation}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize RCPPS xmmreg,r/m128 ; 0F 53 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Four each of the four 32-bit floating-point numbers} 
\textrm{in the source operand RCPPS calculates an approximation of the reciprocal} 
\textrm{and stores it in the corresponding quarter of the destination register.} 
\textrm{The absolute value of the error for each of these approximations is} 
\textrm{at most 3/8192. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.212 RCPSS: SSE Scalar Single-FP} 
\textrm{Reciprocal Approximation}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize RCPSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{53 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}RCPSS calculates an approximation of the reciprocal} 
\textrm{of the 32-bit floating-point in the source operand (using the lowest} 
\textrm{quarter of the source operand if it is a register) and places the} 
\textrm{result in the lowest quarter of the destination register. The absolute} 
\textrm{value of the error for this approximation is at most 3/8192. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.222 RSQRTPS: Packed Single-FP Square} 
\textrm{Root Reciprocal}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize RSQRTPS xmmreg,r/m128 ; 0F 52 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}For each of the four 32-bit floating-point numbers} 
\textrm{in the source operand, RSQRTPS computes an approximation of the reciprocal} 
\textrm{of the square root, and puts this in the corresponding quarter of} 
\textrm{the destination register. The maximum absolute error for this approximation} 
\textrm{is 3/8192. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.223 RSQRTSS:Scalar Single-FP Square} 
\textrm{Root Reciprocal}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize RSQRTSS xmmreg,r/m128 ; F3 0F 52 /r} 
\textrm{{[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}RSQRTSS computes an approximation of the reciprocal} 
\textrm{of the square root of the first 32-bit floating-point number from} 
\textrm{xmm2/m32 and puts it in the lowest quarter of the destination register.} 
\textrm{The maximum absolute error for this approximation is 3/8192. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.231 SFENCE: Store Fence}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize SFENCE ; 0F AE /7 {[}KATMAI{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}SFENCE guarantees that all store instructions which} 
\textrm{precede it in the program order are globally visible before any store} 
\textrm{instructions which follow it. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.235 SHUFPS: Shuffle Single-FP}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize SHUFPS xmmreg,r/m128,imm8 ; 0F C6} 
\textrm{/r ib {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}SHUFPS copies two quarters of the destination register} 
\textrm{to the lower two quarters of the destination register, and copies} 
\textrm{two quarters of the source operand to the upper two quarters of the} 
\textrm{destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}Bits 0 and 1 of imm8 determine which of the four} 
\textrm{quarters of the destination register gets copied to the lowest quater} 
\textrm{of the destination register. Bits 2 and 3 of imm8 similary deterine} 
\textrm{which quarter is copied to the second quarter of the destination register.} 
\textrm{Bits 4-7 likewise select the quarters of the source operand to be} 
\textrm{copied. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.239 SQRTPS: Packed Single-FP Square} 
\textrm{Root}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize SQRTPS xmmreg,r/m128 ; 0F 51 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}SQRTPS considers the source operand as a vector of} 
\textrm{four 32-bit floating-point numbers, and for each of these it computes} 
\textrm{the square root and stores the result in the corresponding quarter} 
\textrm{of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.240 SQRTSS: Scalar Single-FP Square} 
\textrm{Root}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize SQRTSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{51 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}SQRTSS computes the square root of the 32-bit floating-point} 
\textrm{number in the lowest quarter of the source operand and stores the} 
\textrm{result in the lowest quarter of the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.242 STMXCSR: SSE Store MXCSR}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize STMXCSR mem32 ; 0F AE /3 {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}STMXCSR copies the the MXCSR (the SSE control/status} 
\textrm{register) into the 32-bit memory location. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.246 SUBPS: Packed Single-FP Subtract}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize SUBPS xmmreg,r/m128 ; 0F 5C /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}SUBPS considers both operands as vectors of four} 
\textrm{32-bit floating-point numbers, and subtracts each such number in the} 
\textrm{source operand from the corresponding number in the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.247 SUBSS: Scalar Single-FP Subtract}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize SUBSS xmmreg,xmmreg/mem32 ; F3 0F} 
\textrm{5C /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}SUBSS subtracts the 32-bit floating-point number} 
\textrm{in the lowest 4 bytes of the source operand from the corresponding} 
\textrm{number in the destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.256 UCOMISS: Unordered Scalar Single-FP} 
\textrm{Compare and set EFLAGS}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize UCOMISS xmmreg,xmmreg/mem32 ; 0F 2E} 
\textrm{/r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}UCOMISS compares the 32-bit floating-point numbers} 
\textrm{in the lowest part of the two operands, and sets the CPU flags appropriately.} 
\textrm{UCOMISS differs from COMISS in that it signals an invalid numeric} 
\textrm{exeception only if an operand is an sNaN, whereas COMISS does so also} 
\textrm{if an operand is a qNaN. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.259 UNPCKHPS: Unpack High Packed} 
\textrm{Single-FP Data}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize UNPCKHPS xmmreg,r/m128 ; 0F 15 /r} 
\textrm{{[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}UNPCKHPS performs an interleaved unpack of the high-order} 
\textrm{data elements of the two operands in the following manner: labelling} 
\textrm{the data elements of the destination register as X0, X1, X2 and X3} 
\textrm{(from low to high) and those of the source operand as Y0, Y1, Y2 and} 
\textrm{Y3 the UNPCKHPS instruction simultaneously performs the four assignments} 
\textrm{X0 := X2, X1 := Y2, X2 := X3 and X3 := Y3. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.260 UNPCKLPS: Unpack Low Packed} 
\textrm{Single-FP Data}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize UNPCKLPS xmmreg,r/m128 ; 0F 14 /r} 
\textrm{{[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}UNPCKLPS performs an interleaved unpack of the low-order} 
\textrm{data elements of the two operands in the following manner: labelling} 
\textrm{the data elements of the destination register as X0, X1, X2 and X3} 
\textrm{(from low to high) and those of the source operand as Y0, Y1, Y2 and} 
\textrm{Y3 the UNPCKLPS instruction simultaneously performs the four assignments} 
\textrm{X0 := X0, X1 := Y0, X2 := X1 and X3 := Y1. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.269 XLATB: Translate Byte in Lookup} 
\textrm{Table}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize XLATB ; D7 {[}8086{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}XLATB adds the value in AL, treated as an unsigned} 
\textrm{byte, to BX or EBX, and loads the byte from the resulting address} 
\textrm{(in the segment specified by DS) back into AL. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}The base register used is BX if the address size} 
\textrm{is 16 bits, and EBX if it is 32 bits. If you need to use an address} 
\textrm{size not equal to the current BITS setting, you can use an explicit} 
\textrm{a16 or a32 prefix. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}The segment register used to load from {[}BX+AL{]}} 
\textrm{or {[}EBX+AL{]} can be overridden by using a segment register name} 
\textrm{as a prefix (for example, es xlatb). \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}\textbf{\large A.271 XORPS: SSE Bitwise Logical XOR}\end{flushleft}{\large \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}{\footnotesize XORPS xmmreg,r/m128 ; 0F 57 /r {[}KATMAI,SSE{]}}\end{flushleft}{\footnotesize \par}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{flushleft}XORPS performs a bitwise XOR operation on the source} 
\textrm{operand and the destination register, and stores the result in the} 
\textrm{destination register. \end{flushleft}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\end{tabbing}
\textrm{\begin{center}\uline{\textcolor[rgb]{0.000,0.000,1.000}{Previous Chapter }}|} 
\textrm{\uline{\textcolor[rgb]{0.000,0.000,1.000}{Contents }}| \uline{\textcolor[rgb]{0.000,0.000,1.000}{Index }}\end{center}} 
\textrm{\end{document}} 
\begin{tabbing}
***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=***\=\kill
\\
\\
\\
\+\parbox{14cm}{\textsf{\textbf{begin} }}\\
\<\-\parbox{14cm}{\textsf{\textbf{end} .}}\\
\end{tabbing}
\end{document}
