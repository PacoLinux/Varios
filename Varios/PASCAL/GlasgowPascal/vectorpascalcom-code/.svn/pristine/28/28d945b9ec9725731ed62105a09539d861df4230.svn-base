/**
 */
package ilcg.tree;
import ilcg.SyntaxError;
import ilcg.SymbolTable;
import java.io.*;
import java.util.*;
import ilcg.Pascal.ProgressNotifier;
/**
 *  

 *
 *@author     wpc
 *@created    June 22, 2001
 */
class Reservation implements Serializable {
	/**
	 *  Description of the Field
	 */
	public int mark;
	/**
	 *  Description of the Field
	 */
	public Register reserved;


	/**
	 *  Constructor for the Reservation object
	 *
	 *@param  m  Description of Parameter
	 *@param  r  Description of Parameter
	 */
	public Reservation(int m, Register r) {
		mark = m;
		reserved = r;
	}
}

/**
 *  This class provides the generic utility methods used in all processor
 *  specific code generators which extend it. It is called walker because the
 *  code generators walk syntax trees <B><I><FONT FACE="Arial"><P>
 *
 *  Transaction mechanism</P> </B> </I> </FONT> <P>
 *
 *  The process of walking the syntax tree and matching it against the machine
 *  description may involve backtracking. This can occur when a particular goal
 *  pursued by the pattern matcher eventually fails. Whilst performing a pattern
 *  match, a stream of machine code instructions is generated, and registers are
 *  reserved. It is important that when backtracking occurs we can prevent any
 *  machine instructions that would have been generated by the failed pattern
 *  match from being copied to the output file.</P> <P>
 *
 *  This is ensured by writing all lines of assembler code to a <I>
 *  RollBackBuffer</I> , which buffers assembler programs line by line until it
 *  is flushed to an output file. The <I>RollBackBuffe</I> r can be queried as
 *  to what its current line number is using the <I>mark()</I> call.</P> <P>
 *
 *  The write point of the buffer can then be moved back to this point at a
 *  later instant by a call of rollBackTo().</P> <P>
 *
 *  Each instance of Walker contains a RollBackBuffer field <I>buf.</P> </I> <P>
 *
 *  The pattern matcher thus organises its matching into abortable transactions.
 *  Whenever it attempts to match a machine instruction against the syntax tree
 *  it starts a transaction by recording the current write point of <I>buf</I> .
 *  If the match of the instruction fails it calls <I>rollBack()</I> , a method
 *  which both rolls back the output stream and unreserves any registers.</P>
 *  <FONT FACE="Arial"><P>
 *
 *  Register reservation transactions</P> </FONT> <P>
 *
 *  Whilst matching the syntax tree it is necessary to reserve registers that
 *  currently contain the results of the pattern matched so far. However when a
 *  match fails we want to be able to unreserve all registers that were recorded
 *  since the start of the transaction. This is done by ensuring that all
 *  register reservation is done through the <I>reserve()</I> method. This not
 *  only reserves the register, it also pushes onto a datastructure called the
 *  <I>reservationStack</I> a <I>Reservation</I> object, basically a pair
 *  consisting of a line number and a register.</P> <P>
 *
 *  When the <I>rollBack</I> method is called, the <I>reservationStack</I> is
 *  popped of all registers reserved since the mark point, and all reservations
 *  of these registers are canceled.</P> <B><I><FONT FACE="Arial"><P>
 *
 *  Register Spilling</P> </B> </I> </FONT> <P>
 *
 *  When generating code we may run out of registers. It is necessary to provide
 *  a means of spilling registers that is machine independent and which fits in
 *  with the transaction mechanism outlined above.</P> <P>
 *
 *  The indended approach is to provide a <I>spill </I> method that will be
 *  called to save a register. The default spill method in the class Walker will
 *  allocate a new variable in the local stack frame for each variable to be
 *  spilled and generate a simple assignment statement to this location as an
 *  ilcg tree. This is then passed to the pattern matcher to generate machine
 *  code. For this to work we need:</P>
 *  <OL>
 *    <LI> Access to the local store allocator for the current stack frame. This
 *    can be obtained if the compiler brackets all blocks to be compiled within
 *    Block nodes which provide a pointer to the current local store allocator.
 *    The Walker can then keep a record of the LocalStoreAllocator to use when
 *    spilling.</LI>
 *    <LI> When allocating a register the Walker must actually allocate a
 *    RegisterAlias which initially points at the register but which, in the
 *    event of a spill being forced,will point at the location to which the
 *    register has been spilled.</LI>
 *    <LI> Since the spill operation itself will only have an array of Registers
 *    to work on, supplied eventually by the machine specific pattern matcher,
 *    the Registers must be aware of all aliases that currently exist.</LI>
 *    <LI> There must be a mechanism for forgetting all spills that have
 *    occurred after a given line number was output.</LI>
 *    <LI> There must be a mechanism for the matcher to check that a spill on a
 *    register aliases is unspilled before a machine instruction using that
 *    alias is sent to the RollBackBuffer.</LI>
 *  </OL>
 *
 *
 *@author     wpc
 *@created    June 22, 2001
 */
public abstract class Walker implements Serializable{

/** Reports on progress, used in the
            surrounding development environment */
	public ProgressNotifier notifier= new ProgressNotifier();
        void notify(int l){
		notifier.done("generated",l );
	}
	/**
	 *  Controls whetherverbose debugging info output to the log file.
	 */
	public boolean verbose = false;
	boolean dontexceedlogmax=true;
        /** number of discrete calls on codegen */
	public int invocations=0;
	/**
	 *  Flags is a hash table that contains named flags indexed on strings. The
	 *  value of the flags will be of type java.lang.Integer. These may be used by
	 *  a compiler to decide on a strategy for the generation of syntax trees
	 */
	public Hashtable flags = new Hashtable();
	// used to store the printable results of patterns
	/**
	 *  this stack stores Reservation objects to provide a rollback mechanism for
	 *  register reservation
	 */
	public Stack reservationStack = new Stack();

	/**
	 *  Last line of source processed
	 */
	public int lastLine = 0;
	//Hashtable reservationSet=new Hashtable();
	/**
	 *  set of all registers
	 */
	public MySet registerSet = new MyHashSet();
	/** The minimum number of registers to be reserved from pre allocation 
		by the sub expression optimiser
	*/
	int minimumFreeRegisters =2;
	/** if true we reserve a register during the process of loading it */
	boolean prereserve=false;
	

	/**
	 *  Description of the Field
	 */
	public Dictionary registerIndex = new Hashtable();
	/**
	 *  Current spill allocator used to allocate storage for register spills
	 */
	public LocalStoreAllocator currentSpills = newAllocator();
	String undefined = "  u n d e f ";
	SymbolTable names = new SymbolTable(new Hashtable());
	//SymbolTable variableCache = new SymbolTable(new Hashtable());
	/** The register to be used as the frame pointer, must be overidden in
	actual code generators */
	Register regFP = new Register("FP", "word", true);
	Node matchedTree;
	// used to store matched sub trees
	String matchedAssembler;

	/**
	 *  holds how much the stack pointer has been changed by when params are pushed
	 */
	int spchange = 0;
	// index all registers by name
	RollBackBuffer buf = new RollBackBuffer();
	transient PrintWriter logfile;
        //transient String[] logvec = new String[logmax];
	// this holds the current parameters used by the pattern matcher
	// the first row holds the trees matched by parameters
	// the second row holds the assembler strings they translate to

	Object[][] bindings = {{null}, {""}};
	String[] recTrace = new String[recmax + 2];
	Register FP, SP;
	/**
	 *  flag to control degree of loading into registers
	 */
	boolean tryHalfLoad = true;
	Hashtable typerenametab = new Hashtable();

	String pad = "";
	int logged = 0;
	int recsp = 0;
	int patternrecsp = 0;
	int assigninc = 100;
	int dyadicinc = 10000;
	boolean leftright = true;
	
	/** the number of matches we will try before failing. This figure is adjusted as the algorithm runs. It is initialised
	    to a billion so that it is not a serious limit at the start */
	int matchbudget=1000000000;
	/** the number of chars in the string representation of an expression above which it
            will be split up and the left and right sides assigned to temporaries.
	    This is not strictly necessary but it is done to acclerate matching in the
	    machine specific code generators which typically grows non-linearly with
	    expression length. */
	int maxExpLen = 320; 

	public static final int cacheLocals=1;
	public static final int subExpressionOptimise=2;
	public static final int tryAlternatives =4;
	/** controls level of optimisation */
	public static int optimisationLevel =subExpressionOptimise;
        /** set an optimisation level between 0 and 7 */
	public void setOptimisationLevel(int L)
	{        optimisationLevel = L;
	}
	/**
	 *  the following keeps track of whether we are in an assignment context
	 */
	Stack assignmentContext = new Stack();

	Stack lastTime = new Stack();
	/**
	 *  Description of the Field
	 */
	public static boolean
			leftToRight = true,
			spillingOn = false,
			shortcut = true;
	
	/**
	 *  Description of the Field : the prefix is normally blank but for .coff format it is "_"
	 */
	public static String procprefix = "";
	/** max number of lines allowed in log file */
	final static int logmax = 1400000;
	/** max allowed recursion depth */
	final static int recmax = 100;
	/** cause the assembler to define a symbol , the default version uses nasm syntax you
	  should override for other assemblers
	  */
	public void defineSymbol(String symbol)
	{ buf.writeln("%define "+symbol+" ; defined by walker");}

	/**
	 *  Constructor for the Walker object
	 */
	public Walker() {
		try {
			logfile = new PrintWriter(new FileOutputStream("listing.txt"));
		}
		catch (IOException e) {
			logfile = new PrintWriter(System.out);
		}
                logged=0;
		//buf = new RollBackBuffer();
		//logvec = new String[logmax];
	}
  

	/**
	 *  Use this to select which register to use as the stack pointer
	 *
	 *@param  sp  The new sP value
	 */
	public void setSP(Register sp) {
		SP = sp;
	}


	/**
	 *  Use this to select which register to use as the frame pointer
	 *
	 *@param  fp  The new fP value
	 */
	public void setFP(Register fp) {
		FP = fp;
	}


	/**
	 *  define the file to which debugging info is written
	 *
	 *@param  lf  The new logfile value
	 */
	public void setLogfile(PrintWriter lf) {
		logfile = lf;//logvec = new String[logmax];
		logged=0;
	}


	/**
	 *  override in subclass for non 32 bit processor
	 *
	 *@return    The addressLenInBytes value
	 */
	public int getAddressLenInBytes() {
		return 4;
	}


	/**
	 *  determines if a type is a basic format or a more closely specified type *
	 *
	 *@param  t  Description of Parameter
	 *@return    The format value
	 */
	public boolean isFormat(String t) {
		return t == Node.octet || t == Node.word || t == Node.halfword || t == Node.doubleword || t == Node.quadword;
	}


	/**
	 *  return the type used as addresses on a CPU, assume 32 bit unsigned int as
	 *  default
	 *
	 *@return    The addressType value
	 */
	public String getAddressType() {
		return Node.int32;
	}


	/**
	 *  return the stack pointer
	 *
	 *@return    The sP value
	 */
	public Register getSP() {
		return SP;
	}


	/**
	 *  Tree builders can use this to generate expressions accessing local vars
	 *
	 *@return    The fP value
	 */
	public Register getFP() {
		return FP;
	}

	/** check if the list of strings contains a label */
        boolean nolabelsin(String[]l)
	{
		for(int i=0;i<l.length;i++)if(islabeled(l[i].trim()))return false;
		return true;
	}
	/** Test if an assembler line starts with a label, overide if this is
            not an adequate test */
         boolean islabeled(String s)
	{ return  (s.indexOf("label")>0)||(s.startsWith("label"));}
	/**
	 *  cast to a ref address
	 *
	 *@param  n              Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	public Node refaddr(Node n) throws Exception {
		// cast n to a ref address
		String t = getAddressType();
		return new Cast("ref " + t, n);
	}


	/**
	 *  cast to an address
	 *
	 *@param  n              Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	public Node addr(Node n) throws Exception {
		return forcederef(refaddr(n), getAddressType());
	}


	/**
	 *  create a new temporary variable
	 *
	 *@param  sizeinBytes    Description of Parameter
	 *@param  type           Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	public Memref newTemp(int sizeinBytes, String type) throws Exception {
		return new Memref(new Dyad(new Int(currentSpills.alloc(sizeinBytes, sizeinBytes)), addr(FP),
				Op.sum(getAddressType(), getAddressType(), getAddressType())), type);
	}


	/**
	 *  define how a given type is to be printed out in the assembler since a given
	 *  assembler may use different terminaology depending on word size etc
	 *
	 *@param  ilcgname  Description of Parameter
	 *@param  asmname   Description of Parameter
	 */
	public void typerename(String ilcgname, String asmname) {
		typerenametab.put(ilcgname, asmname);
	}


	/**
	 *  This is used by the code generator to map ilcg types to assembler types. It
	 *  must previously have set up an association by calling typerename
	 *
	 *@param  ilcgType  Description of Parameter
	 *@return           Description of the Returned Value
	 */
	public String type2Assembler(String ilcgType) {
		Object associated = typerenametab.get(ilcgType);
		if (associated != null) {
			return associated.toString();
		}
		if(ilcgType.startsWith("ref "))return type2Assembler(ilcgType.substring(4));
		return ilcgType;
	}


	/**
	 *  The direction that the stack grows when a value is pushed. It must take on
	 *  the values +1 or -1.
	 *
	 *@return    Description of the Returned Value
	 */
	public int stackDirection() {
		return -1;
	}


	/**
	 *  Creates a store allocator for the machine in question with the appropriate
	 *  stack direction and initial offset from fp for local variables
	 *
	 *@return    Description of the Returned Value
	 */
	public LocalStoreAllocator newAllocator() {
		return new LocalStoreAllocator(stackDirection(), 0);
	}


	/**
	 *  Description of the Method
	 *
	 *@param  prereserved  Description of Parameter
	 *@return              Description of the Returned Value
	 */
	public LocalStoreAllocator newAllocator(int prereserved) {
		return new LocalStoreAllocator(stackDirection(), prereserved);
	}


	/**
	 *  Returns an allocator for parameters ( with offsets in the opposite
	 *  direction ) if isparam is true.
	 *
	 *@param  prereserved  reserved for call frame
	 *@param  isparam      true if Parameter allocation
	 *@return              Description of the Returned Value
	 */
	public LocalStoreAllocator newAllocator(int prereserved, boolean isparam) {
		if (isparam) {
			return new LocalStoreAllocator(stackDirection() * -1, prereserved);
		}
		return newAllocator(prereserved);
	}


	/**
	 *  write the assembler code to the PrintWriter
	 *
	 *@param  s  Description of Parameter
	 */
	public void flush(PrintWriter s) {
		buf.flush(s);
	}


	/**
	 *  Description of the Method
	 */
	public void flushlog() {
		int i;

		logfile.println("Debug log from code generator " + getClass());
		/*if (logged > logmax) {
			for (i = 0; i < logmax; i++) {
				logfile.println(logvec[(logged + i) % logmax]);
			}
		}
		else {
			for (i = 0; i < logged; i++) {
				logfile.println(logvec[i]);
			}
		}*/
		logfile.close();
	}
	/** This version of match is the logical interface used by the
            code generator, it calls innermatch, which handles the
            process of finding an optimised match. match can be overridden
            in the hand written part of the code generator enabling the
	    hand written sub-class of the automatically written code generator
            to call back on the automatic portion. This can be useful if
            one wants to put in machine specific strategies for pattern 
	    matching. */
	public boolean match(Node n)throws Exception
	{return innermatch(n);
	}

	/**
	 *  This calls the machine specific matcher to perform matching on
            an ilcg tree. If the flag tryAlternatives is set, it attempts
	    an optimised match.
	 *
	 *@param  n  tree to be matched.
	 *@return    true if matched ok
	 */
	boolean innermatch(Node n)throws Exception
	{	if (invocations>matchbudget){
				if(verbose){
					dlog("fail budget out");
					System.out.print("innermatch fails budget out"+invocations);
				}
				return false;
		}
		invocations++;
		if((tryAlternatives&optimisationLevel)==tryAlternatives){
			int mark=buf.mark();
			int oldinvocations=invocations;
			int oldbudget = matchbudget;
			boolean res = match(n,false,0);
			int firstattemptInvocations= invocations-oldinvocations;
			int quota = firstattemptInvocations + 5;
			if(!res){
				// the code was unmatchable
				return false;
			}
			// store the first attempt
			String[] bestattempt = buf.sequester(mark);
			int lastpos=recordedswitch;
			int bestpos=lastpos;
			Hashtable lasttab=recordedtable;
			try{
				int count=1;
				int x=2;
				// try at most x alternatives with an effort of quota on each
				matchbudget=invocations+quota;
				while(count<x&&match(n,true,lastpos+1)){
					count++;
					matchbudget=invocations+quota;
					lastpos=recordedswitch;
					String[] secondattempt=buf.sequester(mark);
					if(secondattempt.length<bestattempt.length){
						bestattempt=secondattempt;
						bestpos=lastpos;
					}
				}
			}
			catch(Exception ex)
			{ if (verbose) dlog("second attempt failed "+ex);}
			// use the first result
			matchbudget=oldbudget;
			return match(n,true,bestpos);

		}
		return match(n,false,0);
	}
	/** this is the version of match which is overridden by automaticly produced code generators.
            if restart is true, it forces search to start at startpoint in the
            list of alternatives */	
	public boolean match(Node n,boolean restart,int startpoint)throws Exception{
		return false;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public Node optimize(Node n) {
		return n.eval();
	}


	/**
	 *  forces a variable to be derefed to the target type
	 *
	 *@param  n              Description of Parameter
	 *@param  targetType     Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	public Node forcederef(Node n, String targetType)
			 throws Exception {
		String rt = n.returnType();
		if (verbose) {
			log(" forcederef " + n + " to " + targetType);
		}
		if (typecompatiblewith(n, targetType)) {
			return n;
		}
		if (!rt.startsWith("ref")) {
			throw new Exception("type mismatch " + rt + "," + targetType);
		}
		return
				forcederef(new Deref(n), targetType);
	}
	// used as a memo table by codegen
	Hashtable exactmatch=new Hashtable();
	public void listmatches()
	{
		
		for (Enumeration e = exactmatch.keys() ; e.hasMoreElements() ;) {
        	 System.out.println(e.nextElement());
  		   }

	}
	/**
	 *  Attempts code generation of a node checking if we have done it exactly before
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public boolean codeGen(Node n) {
		String oldpad = pad;
		pad = pad + " ";
		if(invocations>matchbudget){
			if (verbose){ dlog("budget ran out,budget="+matchbudget+
			" invocations ="+invocations);
			System.out.println("budget out on "+n+" budget="+matchbudget);
			}
			 return false;
		}
		invocations++;

		// increase the padding on the start of lines of the log file
		// used for debugging
		if (n == null) {
			return true;
		}
		String trace;
		trace = n.toString();
		if (recursing(trace, recsp - 1)) {
			if (verbose) {
				log("failed because of recursion on " + trace);
			}
			return false;
		}
		recTrace[recsp] = trace;
	//	recsp++;
		int m = buf.mark();
		String exactsig=trace;
		try{
			exactsig=trace+listReservations()+currentSpills.getLimit()+optimisationLevel;
		}
		catch(Exception eee)
		{
			log("failed because "+ eee);
			return false;
		}

		boolean res=false;
                Object lasttime = exactmatch.get(exactsig);
                boolean havematchedbefore = lasttime!=null&& lasttime instanceof String[];
                if(!havematchedbefore){res = codegen(n);
			if (!res) {
				rollBack(m);
			}
			String[] assembleroutput;
			if (res){
				assembleroutput=buf.sequester(m);
				buf.append(assembleroutput);
				// we dont store statements in the cache
				// as they recursively define the whole
				// program and we dont want masses of
				// copies in the cache doing nothing
				if(!(n instanceof Statement)&&!(n instanceof Block))
                                  if(nolabelsin(assembleroutput))
				   exactmatch.put(exactsig,assembleroutput);
			}
		//	recsp--;
		}else{
			res=true;
			if(verbose)log("exact match found for "+trace);
			buf.append((String[])lasttime);
		}
		pad = oldpad;
		// return it to its old level
		return res;
	}
	/** test if it is possible to code generate node n */
        public boolean generateable(Node n)
	{
		int m=buf.mark();
	//	if(verbose)System.out.println("try to generate:"+n);
		boolean res=codeGen(n);
	//	if(verbose)System.out.println("generateable returns "+res);
		rollBack(m);
		return res;
	}

	/**
	 *  Invoke the linker on a file. Must be overriden to specify what linker to
	 *  use.
	 *
	 *@param  infile  Description of Parameter
	 *@param  ofile   Description of Parameter
	 *@return         Description of the Returned Value
	 */
	public boolean link(String infile, String ofile) {
		return false;
	}
	/**
	This returns the string used to declare a variable as global.
	It should be overridden if the chosen assembler uses a different directive */
	public String globalDirective(){return "GLOBAL";}
	public String sectionDirective(){return "section";}


	/**
	 *  Invoke the assembler on a file. Must be overriden to specify what assembler
	 *  to use.
	 *
	 *@param  infile  Description of Parameter
	 *@param  ofile   Description of Parameter
	 *@return         Description of the Returned Value
	 */
	public abstract boolean assemble(String infile, String ofile);


	/**
	 *  You should overide in subclasses to provide actual procedure entry and exit
	 *  technique for a particular processor and language
	 *
	 *@param  p  Description of Parameter
	 *@return    Description of the Returned Value
	 */

	public abstract boolean cgProcedure(Procedure p);


	/**
	 *  Returns the node containing a function return value of the appropriate type
	 *  specified by t
	 *
	 *@param  t  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public abstract Node functionRetReg(String t);


	/**
	 *  Code generates function return code
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public abstract boolean cgReturn(Return n);


	/**
	 *  Code generates procedure application, must be overridden in supplied sub
	 *  class
	 *
	 *@param  d  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public abstract boolean cgApply(Monad d);
	/** if true print out line number before code generating a statement */
	public static boolean linecount=false;
	public static int switchon=-2;
	/**
	 *  Code generates statements can be overridden in user supplie sub class.
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */

	public boolean cgStatement(Node n) {
		boolean yes=true;
                while(yes){// do statements non recursively
			Statement s = (Statement) n;
			if (s.line >= 0) {
				if(s.line==switchon)verbose=true;
				lastLine = s.line;
				buf.writeln("; #" + lastLine);
				if (verbose||linecount) {
					System.out.println(lastLine);
				}
			}
			try {
				Node act = s.action;
				Register r=null;
				boolean ok=false;
				if(verbose){
					log("cgstatement optlevel="+optimisationLevel+":"+n+"\n has local="+s.hasLocal());
					
				}
				if(s.hasLocal()&&(0!=(cacheLocals&optimisationLevel))){
				
						Memref i=s.getLocal();
						if(verbose)log("substitute local variable "+i);
						String refvrt = i.returnType();
						buf.writeln("; #substitute in "+i+":"+refvrt);
						try{
							r = findFreeReg(refvrt);
							if(verbose)log(" found in cgStatement "+r);
                                                        int stillfree=stillFree(refvrt);
							if (r == null||(stillfree<=minimumFreeRegisters)) {
								if (verbose&& r!=null) {log("not enough free regs"+stillfree+"<="+minimumFreeRegisters);}
								buf.writeln(";  #dont use, not enough free regs"+stillfree+"<="+minimumFreeRegisters);
								ok=codeGen(act);
							}
							else {
								if(verbose)log("perform substitution");
								Node sact=ExpressionSubstituter.substituteAwithBinC(i,new Cast(refvrt,r),act);
								reserve(r);
								ok=codeGen(sact);
				 				unreserve(r);
								if(!ok)buf.writeln("; #code generation with subsitution failed");
								if(!ok)ok=codeGen(act);
								}
							if(verbose)log("codegenerated action");
						}
						catch (Exception en){dlog("substitution fails"+en );
						ok=codeGen(act);}

				}
				else ok=codeGen(act);
				if (!ok) {
					return false;
				}

				if (s.next instanceof Statement){n=s.next;}else
				return codeGen(s.next);
			}
			catch (Exception a) {
				dlog("in cgStatement " + a);
				return false;
			}
			stats++;
			if (s.line >0 )notify(s.line);
			if((stats %10 )==0)if (s.line>0)	System.out.print(".");
		}
		return true;
	}

	int stats=0;
	/**
	 *  this simply prints "extern l", this should be over ridden if the syntax
	 *  differs
	 *
	 *@param  l  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public boolean cgImplabel(Label l) {
		String defined = "defined"+l;
		buf.writeln(directivePrefix()+"ifndef "+defined);
		defineSymbol(defined);
		//buf.writeln(directivePrefix()+"define "+defined+" "+l);
		buf.writeln(externDirective()+"\t " + l);
		buf.writeln(directivePrefix()+"endif");
		return true;
	}


	/**
	 *  This plants in the assembler the info needed to export a label. This simply
	 *  writes Global l for the default case. Override if this is the wrong
	 *  assembler syntax.
	 *
	 *@param  l  Description of Parameter
	 */
	public void exportLabel(Label l) {
		buf.writeln("\t"+globalDirective()+" "+ l);
	}
	public String directivePrefix(){ return "%";}
	public String macrofile(){return "macros.asm";}
	public String externDirective(){return "EXTERN";}

	/**
	 *  This is the default code generator for control statements. It can be
	 *  overriden by user defined classes but this is not required.
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public boolean cgControl(Node n) {
	 try{
		if (match(n)) {
			String temp = defprintproc();
			buf.writeln(temp);
			dlog(n + "\n\t->" + temp + " ok");
			return true;
		}
		if (!((Control) n).isSimple()) {
			String oldn = n.toString();
			if (verbose) {
				log("simplify " + oldn);
			}
			n = ((Control) n).simplify().eval();
			String newn = n.toString();
			if (verbose) {
				log("simplified to " + newn);
			}
			if (newn.equals(oldn)) {
				log("simplification failed ");
				return false;
			}
			return codeGen(n);
		}
	   }
	   catch(Exception e1){
		dlog("error "+e1);
	   }
		return false;
	}
public void reservebytes(int bytes){
                                buf.writeln(" times "+bytes +"  db ' '");
				}

	/**
	 *  Code generates blocks can be overridden in user supplie sub class.
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public boolean cgBlock(Node n) {
		LocalStoreAllocator old = currentSpills;
		currentSpills = ((Block) n).alloc;
		
		boolean answer = codeGen(((Block) n).getSubtree());
		currentSpills = old;
		return answer;
	}


	/**
	 *  returns the assembly code associated with a given variable at present
	 *
	 *@param  unsigned  Description of Parameter
	 *@return           Description of the Returned Value
	 */
	/*
	 *  String currentbindingof(String n)
	 *  {
	 *  /unimp("current binding of ");
	 *  Object val=names.get(n);
	 *  if(val==null)return "undefined var "+n;
	 *  return val.toString();
	 *  }
	 *  ** map an unsigned type to equivalent signed type
	 */
	public String typeToSigned(String unsigned) {
		if (unsigned.equals(Node.uint32)) {
			return Node.int32;
		}
		if (unsigned.equals(Node.uint16)) {
			return Node.int16;
		}
		if (unsigned.equals(Node.uint8)) {
			return Node.int8;
		}
		if (unsigned.equals(Node.uint64)) {
			return Node.int64;
		}
		return unsigned;
	}


	/**
	 *  Spill a register
	 *
	 *@param  r              Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	public Node spill(Register r) throws Exception {
		if (verbose) {
			log("Spill " + r);
		}
		int bytes = r.width / 8;

		Node loc = newTemp(r.width / 8, r.returnType());
		Node val = new Deref(r);
		Node save = new Assign(loc, val).eval();
		if (codeGen(save)) {
			unreserve(r);
			r.spill(loc);
		}
		return loc;
	}


	/**
	 *  restore a spilled register
	 *
	 *@param  r              Description of Parameter
	 *@exception  Exception  Description of Exception
	 */
	public void unspill(Register r) throws Exception {
		if (verbose) {
			log("unspill(" + r + ")");
		}
		Node loc = new Memref(new Dyad(new Int(currentSpills.alloc(r.width / 8, r.width / 8)), addr(FP),
				Op.sum(getAddressType(), getAddressType(), getAddressType())), r.returnType());
		Node val = new Deref(loc);
		Node save = new Assign(r, val).eval();
		if (codeGen(save)) {
		}
		else {
			log("Unspill failed ");
		}

	}


// code to do with reserving registers
// and maintaining the transactional structure
	/**
	 *  rolls back the output buffer to the marked line number and unreserves all
	 *  registers reserved since that line
	 *
	 *@param  mark  Description of Parameter
	 */
	public void rollBack(int mark) {
		buf.rollBackTo(mark);

	}
	boolean isitaregister(Node target){
		boolean isregister=false;
		if (target instanceof Cast) {
			Cast c = ((Cast) target);
			isregister = isitaregister(c.subtree)  ;
		 
		}
		else {
			isregister = target instanceof Register;
			if (isregister) {
				isregister = !((Register) target).permanentlyReserved();
			}
		}
		return isregister;
	}
	boolean isitunreservedregister(Node target){
		boolean isregister=false;
		if (target instanceof Cast) {
			Cast c = ((Cast) target);
			isregister = isitunreservedregister(c.subtree)  ;
		 
		}
		else {
			isregister = target instanceof Register;
			if (isregister) {
				isregister = !((Register) target).isReserved();
			}
		}
		return isregister;
	}
	/**
	 *  this is called to see if node can match an object. The object may be an
	 *  unbound register in which case special recognition is necessary otherwise
	 *  string equality of expressions is used
	 *
	 *@param  referedToBySymbol  Description of Parameter
	 *@param  toBeMatched        Description of Parameter
	 *@return                    Description of the Returned Value
	 */
	public boolean treeIdenticalToOrAssignableToParam(int referedToBySymbol, Node toBeMatched) {
		if(verbose)dlog("treeIdenticalOrAssignableto(referedtoby=" + referedToBySymbol + ",tobematched=" + toBeMatched);
		if (bindings[1][referedToBySymbol] == null) {
			return false;
		}
		Node target = (Node) bindings[0][referedToBySymbol];
		String a1 = bindings[1][referedToBySymbol].toString();
		String a2 = toBeMatched.toString();

		String a3 = target.toString();
		if(verbose)dlog("is to be matched (" + a2 + ")== target " + a3);
		if (a2.equals(a3)) {
			dlog(a2 + "==" + a3);
			return true;
		}
		;
		if(verbose)dlog("is " + a1 + "==" + a2);
		if (a1.equals(a2)) {
			dlog(a1 + "==" + a2);
			return true;
		}
		boolean isregister = isitaregister(target);
		

		if (Assign.checkAssignComp(target.returnType(), toBeMatched.returnType()) ||
			Assign.checkAssignComp(target.returnType(), new Deref(toBeMatched).returnType())) {
			if (isregister) {
				try {
					if(verbose){dlog("is a register");dlog("target ="+target);}
			 
					if(isitaregister(toBeMatched)){
						// we never assign a register to itself
						if(decast(target).equals(decast(toBeMatched)))return true;
					}
					if (toBeMatched.returnType().startsWith("ref")) {
						toBeMatched = new Deref(toBeMatched);
					}
					if(isitunreservedregister(target)){
						boolean ok= codeGen(new Assign(target, toBeMatched));
						if (ok)reserve(target);
						return ok;
					}
					else dlog("it was reserved");
				}
				catch (Exception e) {
					dlog(e.toString());
				}
			}
		}
		if (verbose) {
			log("args compatible fails, isregister =" + isregister);
		}
		return false;
	}


	/**
	 *  Associates the index with the string of the object in the hashtable
	 *  it is used within the matcher to record which match was successful
         *  so that on subsequent matches the search process can be short circuited
	 *
	 *@param  t      Description of Parameter
	 *@param  index  Description of Parameter
	 *@param  o      Description of Parameter
	 */
	public void record(Hashtable t, int index, Node o) {
		String status="";
		String k = key(o);
		recordedswitch=index;recordedtable=t;
		Object ob=t.get(k);		
		if(ob==null||
                   (((tryAlternatives&optimisationLevel)==tryAlternatives)&&index!=((Int)ob).intValue())
		){
		   if(verbose)dlog("Record "+k+"->"+index);
		  if(t!=null) t.put(k, new Int(index));
                }
	}
	/** This stores the result of the last switchtable record made
 	by method record(), it is useful when performing optimised
	matching of instructions to ilcg trees */
	int recordedswitch=0;
	Hashtable recordedtable=null;
	long reservationhash=0;
        String key(Node n)
        {try{return n.sig()+listReservations();}
         catch(Exception e){    
		return n.sig();
         }        
        }
	/**
	 *  test what number is associated with the object, default is 0
	 *
	 *@param  t  Description of Parameter
	 *@param  o  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public int testmemo(Hashtable t, Node o) {
		String k=key(o);
		Object w = t.get(k);
		if (w == null) {
			if (verbose) dlog(k+ "-> null " );
			return 0;
		}
		if (verbose) {
			dlog(k+ "-> alternative " + w);
		}
		return ((Int) w).intValue();
	}


	/**
	 *  Gets the parallelism attribute of the Walker object
	 *
	 *@param  elementType  Description of Parameter
	 *@return              The parallelism value
	 */
	public int getParallelism(String elementType) {
		return 1;
	}


	/**
	 *  Gets the reserved attribute of the Walker object
	 *
	 *@param  r  Description of Parameter
	 *@return    The reserved value
	 */
	boolean isReserved(Register r) {
		return r.isReserved();
	}


	/**
	 *  Gets the itRhs attribute of the Walker object
	 *
	 *@return    The itRhs value
	 */
	boolean isItRhs() {
		Object c = assignmentContext.pop();
		assignmentContext.push(c);
		return "rhs".equals(c);
	}


	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 *@param  n  Description of Parameter
	 */
	void dlog(String s, Node n) {
		if (verbose) {
			log("Match " + s + " to " + n);
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 */
	void dlog(String s) {
		if (verbose) {
			log(s);
		}
	}


	/**
	 *  returns the string that was last pushed on the eval stack
	 *
	 *@return    Description of the Returned Value
	 */
	String defprintproc() {
		return matchedAssembler;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  o  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	String defprintproc(Object o) {
		return defprintproc();
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	String returnFormat(Node n) {
		return typeToFormat(n.returnType());
	}


	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	String typeToFormat(String s) {
		String f = Format.typeToFormat(s);
		dlog("type " + s + " -> format " + f);
		return f;
	}


	/**
	 *  function that binds a value to the parameter, returns true if identifier
	 *  unbound or, if the current value matches the newly bound value
	 *
	 *@param  value  Description of Parameter
	 *@param  id     Description of Parameter
	 *@return        Description of the Returned Value
	 */
	boolean bind(Object value, int id) {
		if (unbound(id)) {
			bindings[0][id] = value;
			if (verbose) {
				log("key " + id + "<-" + value);
			}
			return true;
		}
		Object val = bindings[0][id];
		if (verbose) {
			log("key " + id + " has value " + val);
		}
		return (value.equals(val));
	}


	/**
	 *  tests if anything bound to object in symbol table
	 *
	 *@param  o  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean unbound(int o) {
		Object val = bindings[0][o];
		if (val == null) {
			return true;
		}
		return false;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 */
	void log(String s) {
		try {
			s = s +"\t\t"+ listReservations()+"\t"+recsp;
		}
		catch (Exception e) {
		}
                 if ((logged>logmax&&  dontexceedlogmax) )  {   verbose=false;flushlog();}
		//logvec[logged % logmax] = pad + s;
		logfile.println(pad+s);
		logged++;
		
	}


	/**
	 *  Description of the Method
	 *
	 *@param  o  Description of Parameter
	 */
	void log(Object o) {
		log(o.toString());
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n     Description of Parameter
	 *@param  type  Description of Parameter
	 *@return       Description of the Returned Value
	 */
	boolean matches(Node n, String type) {
		return returnFormat(n) == type;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean optimizedCodeGen(Node n) {
		return codeGen(optimize(n));
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean codegen(Node n) {
		if (n == null) {
			return true;
		}
		if (n instanceof Assign|| n instanceof If) {
			boolean ok=subexpOptimisedCodeGen(n);
			

			return ok;
		}
		return unoptimisedcodegen(n);
	}




// this does the actual work

// codeGen with a capital G is used to track
// entry and exits to the code gen routine
// we know that it is never called with a null parameter
	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean unoptimisedcodegen(Node n) {

		int m = buf.mark();
//	n=n.eval();
		if (verbose) {
			log("unoptimisedcodegen " + n);
		}
		try {
			if (n instanceof Location) {
				Node tree = ((Location) n).getSubtree();
				// check for cartesians and expand them out
				if (tree instanceof Cast && ((Cast)tree).getSubtree() instanceof Cartesian)
				tree=((Cast)tree).getSubtree();
				if (tree instanceof Cartesian) {
					int i;
					int len;
					Cartesian c = (Cartesian) tree;
					len = c.argc();
					for (i = 0; i < len; i++) {
						if (!(codeGen(new Location(c.argi(i))))) {
							return false;
						}
					}
					return true;
				}
				else if (verbose) {
					log(tree.getClass());
				}
			}
			if (n instanceof Procedure) {
				return cgProcedure((Procedure) n);
			}
			if (n instanceof Block) {
				return cgBlock(n);
			}

			if (n instanceof Return) {
				return cgReturn((Return) n);
			}
			if (n instanceof Statement) {
				return cgStatement(n);
			}
			else
					if (n instanceof ImpLabel) {
				return cgImplabel((Label) n);
			}
			else
					if (n instanceof Control) {
				return cgControl(n);
			}
			else
					if ((n instanceof Monad) && (((Monad) n).oper instanceof Function)) {
				return cgApply((Monad) n);
			}
			else
					if(n instanceof Assign && toolong((Assign)n)&& splitup((Assign)n)){
					return true;
			}
			else
			if (n instanceof Assign || n instanceof Label || n instanceof Location ||
					n instanceof Dyad && n.toString().startsWith("PUSH"))
			{

				if (verbose) {
					log("  match in unoptimised codegen " + n);
				}
				// attempt to remove common sub expressions
				boolean matched = false;
				recsp++;
				matched = match(n);
				recsp--;
				if (matched) {
					String temp = defprintproc();
					buf.writeln(temp);
					dlog(n + "\t->" + temp + " ok");
					return true;
				}
				else {
					if (n instanceof Assign) {

						Assign asn = (Assign) n;
						Node src = asn.src;
						String srctype = src.returnType();
						if (Format.isVector(srctype)) {
							return vectorAssignRewrite(asn);
						}
					}
				}
			}
			else if (match(n)) {
			               if (verbose)dlog(" ok call defprintprog");
					String temp = defprintproc();
					buf.writeln(temp);
					dlog(n + "\t->" + temp + " ok");

				//dlog("matched but not currently outputing assembler");
				return true;
			}
		}
		catch (Exception ex) {
			dlog("in unoptimisedcodegen " + ex.toString());
			if (ex instanceof ClassCastException) {
				throw new Error(ex.toString());
			}

		}
		rollBack(m);
		if (verbose) {
			dlog(n + "fail");
		}
		return false;
	}

/** Attempts to split complex expressions into sequence of simpler ones */
boolean splitup(Assign a)
{
          
	try{
		if( a.src instanceof Dyad){
			Dyad d=(Dyad)a.src;
			String right = d.right.toString();
			String left =  d.left.toString();
			Node replaced = (right.length()>left.length()?d.right:d.left);
			
			Memref temp=newTemp(replaced.returnType());
			
			Node first = new Assign(temp,replaced);
			try{
				Node second= ExpressionSubstituter .substituteAwithBinC(replaced,new Deref(temp),a);
				if(!(a.toString().length()>second.toString().length()))
					return false;
				Statement action = new Statement(
                                                   new Statement(first,
                                                   new Statement(second)));
				action.setLocal(temp);
				if(verbose)log("convert "+a+"\nto "+action);
				boolean ok =codeGen(action);
				if(verbose){
				 if(ok)log("--- ok for ---"+action);
				 else log("** fail for ***"+action);
				}
				return ok;
			}catch(Exception ee)
			{
				if(verbose)System.out.println(" while spliting and subtituting "+a+" \n got error "+ee);
			}
		}
	}catch(Exception ee)
	{
		if(verbose)System.out.println(" while spliting "+a+" \n got error "+ee);
	}
	return false;
}
/** return true if an assignment is too complex to  be easily handled in registers */
boolean toolong(Assign a)
{
	int len=a.src.toString().length();
	 
        if(len>maxExpLen){
		return true;
	}

	return false;
}


public Memref newTemp( String type) throws Exception {return newTemp(Format.lengthInBytes(type),type);}


// rewrite the vector assignment as a for loop
	/**
	 *  Description of the Method
	 *
	 *@param  a  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean vectorAssignRewrite(Assign a) {
		String srctype;
		int len = Format.getVectorTypeLength(srctype = a.src.returnType());
		String elementType = Format.getVectorElementType(srctype);
		int replication = getParallelism(elementType);
		if (len == replication) {
			replication = 1;
		}
		if ((len % replication) != 0) {
			replication = 1;
		}
		// handle vectors with odd number of elements
		try {
			Node loop = buildLoop(a, len, replication, elementType);
			dlog("in vectorAssignRewrite" + loop);
			if (codeGen(loop)) {
				return true;
			}
			return codeGen(buildLoop(a, len, 1, elementType));
		}
		catch (Exception ee) {
			dlog("in vectorAssignRewrite" + ee);
			return false;
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@param  a              Description of Parameter
	 *@param  len            Description of Parameter
	 *@param  parfactor      Description of Parameter
	 *@param  elemtype       Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	Node buildLoop(Assign a, int len, int parfactor, String elemtype) throws Exception {
		Memref i = newTemp(4, "ref int32");
		try {
			return new For(i, new Int(0), new Int(len - 1), new Int(parfactor),
					expandAction(a, i, parfactor, elemtype));
		}
		catch (Exception ee) {
			dlog("in buildloop" + ee);
			throw ee;
		}
	}

// expand an arbitrary expression to be parallel by a given factor

// all array references are appropriately subscripted and replaced
// by references of the appropriate parallelism
	/**
	 *  Description of the Method
	 *
	 *@param  a              Description of Parameter
	 *@param  induction      Description of Parameter
	 *@param  parfactor      Description of Parameter
	 *@param  et             Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	Node expandAction(Node a, Node induction, int parfactor, String et) throws Exception {
		if (true) {
			dlog("expandAction(" + a + "," + induction + "," + parfactor + ", " + et + ")");
		}
		if (a instanceof Assign) {
			Assign asn = (Assign) a;
			String dt = et;
			if(!dt.startsWith("ref"))dt="ref "+dt;
			return new Assign(expandAction(asn.dest, induction, parfactor, dt), 
			expandAction(asn.src, induction, parfactor, et)).eval();
		}
		else
				if (a instanceof Deref) {
			return new Deref(expandAction(((Deref) a).getArg(), induction, parfactor, et));
		}
		else
				if (a instanceof Cast) {
				String dt=(parfactor > 1 ? et + " vector ( " + parfactor + " )" : et);
				if(a.returnType().startsWith("ref ")&& !dt.startsWith("ref "))
					dt="ref "+dt;
			dlog("cast to " + dt);
			return new Cast(dt,
					expandAction(((Cast) a).getSubtree(), induction, parfactor, et)
					);
		}
		else
			if (a instanceof Memref) {
			try {
				Memref var = (Memref) a;
				String vectype = var.returnType();
				String elemtype = Format.getVectorElementType(vectype);

				String vartype = "ref " + (parfactor == 1 ? elemtype : elemtype + " vector ( " + parfactor + " )");
				Memref newvar =
						new Memref(
						new Dyad(var.index,
						new Dyad(new Deref(induction),
						new Int(Format.lengthInBytes(elemtype)),
						Op.prod(Node.int32, Node.int32, Node.int32)
						),
						Op.sum(Node.int32, Node.int32, Node.int32)
						),
						vartype
						);
				dlog("->" + newvar);
				return newvar;
			}
			catch (Exception en) {
				dlog("in expand action " + en);
				throw en;
			}
		}
		else if (a instanceof Dyad) {
			Dyad d = (Dyad) a;
			String nt = (parfactor > 1 ? et + " vector ( " + parfactor + " )" : et);
			d = new Dyad(expandAction(d.left, induction, parfactor, et),
					expandAction(d.right, induction, parfactor, et),
					new Op(d.O.Symbol, nt, nt, nt));
			dlog("->" + d);
			return d;
		}
		else if (a instanceof Monad) {
			Monad m = (Monad) a;
			String nt = (parfactor > 1 ? et + " vector ( " + parfactor + " )" : et);
			m = new Monad(new Op(m.oper.Symbol, nt, nt, nt), expandAction(m.arg, induction, parfactor, et));
			dlog("->" + m);
			return m;
		}
		else {
			throw new Exception(" cant expand vector action " + a);
		}

	}

// declare a compile time variable that is private to the code generator

	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 */
	void declarevar(String s) {
		names.put(s, undefined);
	}

// undeclare a compile time variable

	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 */
	void forgetvar(String s) {
		names.remove(s);
	}


	/**
	 *  checks that node n's return type occupies the same space as the type named
	 *  by tidentifier
	 *
	 *@param  n            Description of Parameter
	 *@param  tidentifier  Description of Parameter
	 *@return              Description of the Returned Value
	 */
	boolean typecompatiblewith(Node n, String tidentifier) {
		// check that the current type associated with the
		// identifier is compatible with the node

		String returns = returnFormat(n);
		dlog("type compatible with " + tidentifier, n);
		while (returns.startsWith("ref") && tidentifier.startsWith("ref")) {
			tidentifier = Format.typeDeref(tidentifier );
			returns = Format.typeDeref(returns );
		}
		if (tidentifier.equals(returns)) {
			return true;
		}
		if(Format.isUntypedFormat(tidentifier)){
			return tidentifier.equals(Format.typeToFormat(returns));
		}
		String fi = typeToFormat(tidentifier);
		dlog(" is " + fi + " == " + returns);
		return fi.equals(returns);
	}


	/**
	 *  checks if two type strings describe an identical object
	 *
	 *@param  n            Description of Parameter
	 *@param  tidentifier  Description of Parameter
	 *@return              Description of the Returned Value
	 */
	boolean typeequalitywith(Node n, String tidentifier) {
		// check that the current type associated with the
		// identifier is identical to that of   the node

		String returns = n.returnType();
		
		while (returns.startsWith("ref") && tidentifier.startsWith("ref")) {
			tidentifier = Format.typeDeref(tidentifier );
			returns = Format.typeDeref(returns );
		}
		boolean ok=(tidentifier.equals(returns));
		//if(!ok){
		//	ok=	checkUnitaryVectorMatch(tidentifier,returns)
		//		||checkUnitaryVectorMatch(returns,tidentifier);
		//}
		dlog("check type equality with " + tidentifier+" actually is "+returns+" "+ok, n);
		return ok;

	}
	boolean checkUnitaryVectorMatch(String possiblevector,String possibleelement)
	{
		if(!Format.isVector(possiblevector))return false;
		if(!(Format.getVectorTypeLength(possiblevector)==1))return false;
		return possibleelement.equals(Format.getVectorElementType(possiblevector));
	}

	/**
	 *  Description of the Method
	 *
	 *@param  actualtype  Description of Parameter
	 *@param  paramindex  Description of Parameter
	 *@return             Description of the Returned Value
	 */
	boolean bindtype(String actualtype, int paramindex) {
		if (bindings[0][paramindex] == null) {
			bindings[0][paramindex] = bindings[1][paramindex] = actualtype;
		}
		String typePattern = (String) bindings[1][paramindex];

		if (verbose) {
			log("bind actualtype " + actualtype + "to param " + paramindex + "=" + typePattern);
		}

		if (actualtype.equals("unbound")) {
			return true;
		}
		// unbound matches anything
		// remove preceeding refs
		while (typePattern.startsWith("ref") && actualtype.startsWith("ref")) {
			typePattern =Format.typeDeref( typePattern );
			actualtype = Format.typeDeref(actualtype );
		}
		// check that the actual type
		// is compatible with the type pattern

		if (actualtype.equals(typePattern)) {
			return true;
		}
		if (typePattern.equals(typeToFormat(actualtype))) {
			return true;
		}
		if (actualtype.equals(typeToFormat(typePattern))) {
			return true;
		}
		if (verbose) {
			log("check assign comp ref " + typePattern + ":=" + actualtype);
		}
		if (Assign.checkAssignComp("ref " + typePattern, actualtype)) {
			return true;
		}
		return bindString(paramindex,
		/*
		 *  typeToFormat
		 */
				(actualtype));
	}


	/**
	 *  Description of the Method
	 *
	 *@param  paramindex  Description of Parameter
	 *@param  value       Description of Parameter
	 *@return             Description of the Returned Value
	 */
	boolean bindString(int paramindex, String value) {
		if (verbose) {
			log("bindstring var " + paramindex + " to " + value);
		}
		Object val = bindings[1][paramindex];
		if (val == null) {
			bindings[1][paramindex] = bindings[0][paramindex] = value;
			return true;
		}
		String sval = val.toString();
		if (sval.equals(value)) {
			return true;
		}

		return false;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@param  s  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean dyadMatches(Op n, String s) {
		return (n.Symbol.equals(s));
	}


	/**
	 *  Description of the Method
	 *
	 *@param  s  Description of Parameter
	 */
	void unimp(String s) {
		System.err.println("Unimplemented proc " + s);
	}

//----------------------------------------------------------------------------------

	/**
	 *  Section dealing with register reservations
	 *
	 *@param  r  Description of Parameter
	 */

	void reserve(Register r) {
		if(isReserved(r))return;// dont reserve multiple times as reservation stored as boolean
		((Register) r).reserve();
		reservationStack.push(new Reservation(ressp++,r));
		reservationhash+= r.toString().hashCode()%hashmod;
		if (verbose) {
			log("reserve register at depth " + ressp + "," + r);
		}
	}
	int ressp=0;
	int hashmod=10000; // used in keeping a hashcode representing reservation status

	/**
	 *  Description of the Method
	 *
	 *@param  r  Description of Parameter
	 */
	void unreserve(Node r) {
		try {
			if (r instanceof Register) {
				unreserve((Register) r);
			}else
			if (r instanceof Deref) {
				unreserve(((Deref) r).arg);
			}else	
			if(r instanceof Cast){ unreserve(((Cast)r).getSubtree());}
		}
		catch (Exception e) {
			dlog("in unreserve " + e.toString());
		}
	}
	void reserve(Node r) {
		if(verbose)log(" try to reserve "+r);
		try {
			if (r instanceof Register) {
				reserve((Register) r);
			}else
			if (r instanceof Deref) {
				reserve(((Deref) r).arg);
			}else
			if(r instanceof Cast){ reserve(((Cast)r).getSubtree());}
		}
		catch (Exception e) {
			if(verbose)dlog("in reserve " + e.toString());
		}
	}

	/**
	 *  Description of the Method
	 *
	 *@param  r              Description of Parameter
	 *@exception  Exception  Description of Exception
	 */
	void unreserve(Register r) throws Exception {
		if (r.isSpilled()) {
			unspill(r);
		}
		r.unreserve();
		reservationhash-= r.toString().hashCode()%hashmod;
//        reservationSet.remove(r);
//        names.put(r,undefined);
		if (verbose) {
			log("Unreserve " + r);
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@exception  Exception  Description of Exception
	 */
	void rollBackReservations(int mark) throws Exception {
		if (reservationStack.empty()) {
			return;
		}
		Object top = reservationStack.peek();
		if (!(top instanceof Reservation)) {
			throw new Exception("Non reservation on reservation stack" + top);
		}
		Reservation r = (Reservation) top;
		dlog("rollBackReservations to " + mark);

		if (r.mark >= mark) {
			if (verbose) {
				log(r.reserved.toString() + ":" + r.mark);
			}
			unreserve(r.reserved);
			reservationStack.pop();
			ressp=r.mark;
			rollBackReservations(mark);
		}

	}


	/**
	 *  produces a string listing the registers reserved
	 *
	 *@return                string of reserved registers
	 *@exception  Exception  Description of Exception
	 */
	String listReservations() throws Exception {
		String list = " ";
		try{/*
		Object r1=reservationStack.peek();
		if(r1!=null)if(r1 instanceof Reservation)
                   list=list+((Reservation)r1).reserved+":"+((Reservation)r1).mark+",";
                */
		}
		catch(Exception e){
			
		}
		Enumeration elems = registerSet.iterator();
		while (elems.hasMoreElements()) {
			Object R = elems.nextElement();
			if ((R instanceof Register)) {
				Register r = (Register) R;
				if (isReserved(r)&&(!r.permanentlyReserved())
                                    && r.getParent()==null
					) {
					list = list +r+ r.resStatus();
				}
			}
		}
		return list;
	}
	/** counts the number of reserved registers exluding permanently reserved ones */
	int countReservations()  {
		int count=0;
	
		Enumeration elems = registerSet.iterator();
		while (elems.hasMoreElements()) {
			Object R = elems.nextElement();
			if ((R instanceof Register)) {
				Register r = (Register) R;
				if (isReserved(r)) {
				if(!r.permanentlyReserved())count++;
				}
			}
		}
		return count;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  r  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	String freeregs(Register[] r) {
		String res = "";
		for (int i = 0; i < r.length; i++) {
			if (!isReserved(r[i])) {
				res = res + r[i] + ",";
			}
		}
		return res;
	}


	/**
	 *  search array for object
	 *
	 *@param  regs  Description of Parameter
	 *@param  r     Description of Parameter
	 *@return       Description of the Returned Value
	 */
	boolean foundin(Object[] regs, Object r) {
		//log("foundin "+regs+r);
		for (int i = 0; i < regs.length; i++) {
			if (regs[i].equals(r)) {
				return true;
			}
		}
		return false;
	}


	/**
	 *  search array for object
	 *
	 *@param  regs           Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	Register findFreeReg(Register[] regs) throws Exception {
		int start = 0;//+(int) Math.random() * regs.length;
		for (int i = start; i < start + regs.length; i++) {
			if (!isReserved(regs[i % regs.length])) {
				return new RegReservation(regs[i % regs.length]);
			}
		}
		if (!spillingOn) {
			return null;
		}
		// disable spilling for now
		int target = (int) (Math.random() * regs.length);
		spill(regs[target]);
		return findFreeReg(regs);
	}


	/**
	 *  find a free register that occupies positions startbit to endbit of a larger
	 *  register
	 *
	 *@param  regs           Description of Parameter
	 *@param  startbit       Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	Register findFreeReg(Register[] regs, int startbit) throws Exception {
		int start =0;// (int) Math.random() * regs.length;
		for (int i = start; i < start + regs.length; i++) {
			if (!isReserved(regs[i % regs.length])) {
				if (regs[i % regs.length].getStartInParent() == startbit && regs[i % regs.length].getParent() != null) {
					return new RegReservation(regs[i % regs.length]);
				}
			}
		}
		if (!spillingOn) {
			return null;
		}
		// disable spilling for now
		int target =0;// (int) (Math.random() * regs.length);
		spill(regs[target]);
		return findFreeReg(regs, startbit);
	}


	/**
	 *  Search entire register set for a register of the right type
	 *
	 *@param  type           Description of Parameter
	 *@return                Description of the Returned Value
	 *@exception  Exception  Description of Exception
	 */
	Register findFreeReg(String type) throws Exception {
		String drt= Format.typeDeref(type);
                if(verbose)dlog("want reg of type "+drt);
		int len = Format.lengthInBits(drt);
		//System.out.println("for "+type+"want length " + len);
	

		for (Enumeration i = registerSet.iterator(); i.hasMoreElements(); ) {
			Object o = i.nextElement();
			if (o != null && o instanceof Register) {
				Register r = (Register) o;
				String rrt=r.returnType();
				boolean typeok=rrt.equals(type);
				String rt = Format.typeDeref(rrt);
				int rlen = Format.lengthInBits(rt);
				//System.out.println(o + ":" + rt + " len " + rlen);
				boolean reserved =isReserved(r);
				boolean alias = r.getParent()!=null;// check this if we want to prevent use of low mmx regs
				boolean confused = floatintconfusion(type,r.returnType());
				boolean lengthok= len==rlen;
				//System.out.println("typeok="+typeok+",confused="+confused+" alias="+alias+" reserved="+reserved+" lengthok="+lengthok);
				
				if(verbose)dlog("confused="+confused+" alias="+alias+" reserved="+reserved+" lengthok="+lengthok);
				if (lengthok&&typeok && !reserved &&!confused// &&(alias?rt.equals(Node.ieee32):true)
				) {
				//	dlog("ok");
				//	buf.writeln("; #use "+r+":"+rt);	
					return r;
				}
			 
			}
		}
		//System.out.println("could not find a free reg of type "+type);
		return null;

	}
	/** count the number of free registers of a type */ 
	int stillFree(String type) throws Exception {String drt= Format.typeDeref(type);
		int len = Format.lengthInBits(drt);
		dlog("in still free want length " + len+ " for "+type);
		int count=0;
		for (Enumeration i = registerSet.iterator(); i.hasMoreElements(); ) {

			Object o = i.nextElement();
			if (o != null && o instanceof Register) {
				Register r = (Register) o;
				String rt = Format.typeDeref(r.returnType());
				int rlen = Format.lengthInBits(rt);
				dlog(o + ":" + rt + " len " + rlen);
				if (len == rlen && !isReserved(r) &&
						!floatintconfusion(type, r.returnType()) 
					//	&&(r.getParent() == null?true:rt.equals(Node.ieee32)||rt.equals(Node.ieee64))// stop us using low words of mmx reg
				) {
					count++;
				}
			}
		}

		return count;

	}
//-------------------------------------------------------------------------------------------------------

	/**
	 *  Description of the Method
	 *
	 *@param  t1  Description of Parameter
	 *@param  t2  Description of Parameter
	 *@return     Description of the Returned Value
	 */
	boolean floatintconfusion(String t1, String t2) {
// check if two values of the same length are an int and a float
		if(verbose)dlog("check float/int confusion for (" + t1 +")("+ t2+")");
		if (t1.equals("ref ieee32") && !t2.equals(t1)) {
		if(verbose)dlog("is confused");
			return true;
		}
		if (t1.equals("ref ieee64") && !t2.equals(t1)) {
			return true;
		}
		if (t2.equals("ref ieee32") && !t2.equals(t1)) {
			return true;
		}
		if (t2.equals("ref ieee64") && !t2.equals(t1)) {
			return true;
		}

		return false;
	}


// check if the node is one o
	/**
	 *  Description of the Method
	 *
	 *@param  regs  Description of Parameter
	 *@param  n     Description of Parameter
	 *@return       Description of the Returned Value
	 */
	boolean alreadyaReg(Register[] regs, Node n) {
		if (n instanceof Deref) {
			return alreadyaReg(regs, ((Deref) n).arg);
		}
		if ((n instanceof Register)) {
			//log("is instance of register "+n);
			if (foundin(regs, ((Register) n))) {
				matchedTree = n;
				matchedAssembler = n.toString();
				return true;
			}

		}
		//log("alreadyaReg finds that either "+n+ "is not a reg or it is not in the appropriate set ");
		if ((n instanceof Cast)) {
			return alreadyaReg(regs, ((Cast) n).subtree);
		}
		return false;
	}


	/**
	 *  Description of the Method
	 */
	void enterLhs() {
		assignmentContext.push("lhs");
	}


	/**
	 *  Description of the Method
	 */
	void leaveLhs() {
		assignmentContext.pop();
	}


	/**
	 *  Description of the Method
	 */
	void enterRhs() {
		assignmentContext.push("rhs");
	}


	/**
	 *  Description of the Method
	 */
	void leaveRhs() {
		assignmentContext.pop();
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	public Node decast(Node n) {
		return (n instanceof Cast ? ((Cast) n).subtree : n);
	}


	/**
	 *  checks if node is a register else if the flag nodeIsRhs is true it attempts
	 *  to load the node into the register
	 *
	 *@param  regs  Description of Parameter
	 *@param  n     Description of Parameter
	 *@return       Description of the Returned Value
	 */

	boolean tryBindingRegisterTo(Register[] regs, Node n) {
		/*
		 *  we first check if the node already
		 *  is this register
		 */
		if (alreadyaReg(regs, n)) {
			if (verbose) {
				log("already a reg");
			}
			// comment this is now done by alreadyaReg
			//matchedTree=n;
			//matchedAssembler=(decast(n).toString());
			return true;
		}
		String nt = n.returnType();
		if (verbose) {
			log("try binding " + n + " to a register");
		}
		Object associated = names.get(n);

		if (isItRhs()) {
			 {
				// if it is a src not a dest
				// if the result will fit in these regs

				if(verbose)dlog("value type "+nt);
				String dereftype = Format.typeDeref(nt);
				String rt = regs[0].returnType();
				if(verbose)dlog("register type "+rt);
				if (nt.startsWith("ref ref") && Assign.checkAssignComp(rt, getAddressType())) {
					dlog("loading a pointer into register");
					names.put(n, "loading in a reg ");
					if (verbose) {
						if (Format.isVector(nt)) {
							log(" assignment compatible " + rt + " " + dereftype);
						}
					}
					// note that we deref the right hand side here
					if (loadregister(regs, new Cast(getAddressType(), new Deref(n)))) {
						return true;
					}
					else {
						// make sure we dont try this again
						names.put(n, "wont go in register");
					}
				}
				else{ 
                                        boolean isaref=nt.startsWith("ref");
					boolean isassignable=Assign.checkAssignComp(rt,dereftype);
 					if (verbose)dlog("check assign compatibility of "+rt+"and "+dereftype+
								"\n is a ref ="+isaref+
								"\n is assignable ="+isassignable);
					if (isaref&& isassignable) {
						names.put(n, "loading in a reg ");
						if (verbose) {
							if (Format.isVector(nt)) {
								log(" assignment compatible " + rt + " " + dereftype);
							}
						}
						// note that we deref the right hand side here
						if (loadregister(regs, new Deref(n))) {
							return true;
						}
						else {
							// make sure we dont try this again
							names.put(n, "wont go in register");
						}
					}
					else
					if (Assign.checkAssignComp(rt, nt)) {
						// note in this case we do not deref the rhs because it
						// is already value
						names.put(n, "loading in a reg ");
						if (loadregister(regs, n)) {
							return true;
						}
						else {
							// make sure we dont try this again
							names.put(n, "wont go in register");
						}
					}
					else if((rt.equals("ref int16")&& dereftype.equals("int8"))||
						 (rt.equals("ref int32")&& dereftype.equals("int8"))||
						 (rt.equals("ref int32")&& dereftype.equals("int16"))||
						 (rt.equals("ref uint16")&& dereftype.equals("uint8"))||
						 (rt.equals("ref uint32")&& dereftype.equals("uint8"))||
						 (rt.equals("ref uint32")&& dereftype.equals("uint16")))
					{	return tryBindingRegisterTo(regs,new ilcg.tree.Monad(
							new Op("EXTEND",dereftype,Format.typeDeref(rt)),
							(isaref?new Deref(n):n)));
					}
				}
			}
		}
		if (verbose) {
			log("failed");
		}
		return false;
	}


	/**
	 *  detects repeated recursion on the same expression
	 *
	 *@param  n      Description of Parameter
	 *@param  level  Description of Parameter
	 *@return        Description of the Returned Value
	 */
	boolean recursing(String n, int level) {
		return recursing(n, level, 0);
	}


	/**
	 *  Description of the Method
	 *
	 *@param  n      Description of Parameter
	 *@param  level  Description of Parameter
	 *@param  count  Description of Parameter
	 *@return        Description of the Returned Value
	 */
	boolean recursing(String n, int level, int count) {
		if (count > 0) {
			return true;
		}
		boolean answer = false;
		if (level <= 0) {
			return false;
		}
		if (level > recmax) {
			dlog("rec level " + level);
			return true;
		}
		if (recTrace[level].equals(n)) {
			answer = recursing(n, level - 1, count + 1);
		}
		else {
			answer = recursing(n, level - 1, count);
		}
		if (answer) {
			dlog(" recTrace[" + level + "]=" + recTrace[level]);
		}
		return answer;
	}
	// holds last attempt


	/**
	 *  Attempts to generate code to place the value of node n in one of the
	 *  defined registers. The routine attempts to minimise the instructions
	 *  generated.
	 *
	 *@param  regs  Description of Parameter
	 *@param  n     Description of Parameter
	 *@return       Description of the Returned Value
	 */
	boolean loadregister(Register[] regs, Node n) {
		if (recsp > recmax) {
			if(verbose)dlog("recursion too deep");
			System.out.println("Recursion Stack overflow in code generator");
			for(int i=0 ;i<= regs.length;i++)
			{System.out.println(regs[i].sig()+regs[i].resStatus());
			}
			return false;
		}
		/*
		 *  we first check if the node already
		 *  is one of these registers
		 */
		if (alreadyaReg(regs, n)) {
			if (verbose) {
				log("already a reg");
			}
			matchedTree = n;
			matchedAssembler = (decast(n).toString());
			return true;
		}

		String pattern = n.toString();
		try {
			if (verbose) {
				log("load into register " + pattern);
			}
			n = n.eval();

			// try loading it into the register
			Register r;

			// try loading it into the register
			Register subregister = regs[0];
			SubField sf;
			boolean wasSubField = false;
			if (n instanceof SubField) {
				// we need to select a register from the list that is
				// an appropriate subfield of a larger register
				wasSubField = true;
				sf = (SubField) n;
				n = sf.getSubtree();
				RegReservation rr = (RegReservation) findFreeReg(regs, sf.lowbit);
				if (rr == null) {
					return false;
				}
				subregister = rr.getParent();
				r = new RegReservation(subregister.getParent());
				if (verbose) {
					log(" selected  parent register " + r + " subregister " + subregister);
				}
			}
			else {
				r = findFreeReg(regs);
			}
			if (verbose) {
				log("load into " + r);
			}
			if (r == null) {
				throw new Exception("no regs free");
			}
		
			String assignedVal = Format.typeDeref(r.returnType() );
			// remove the leading ref
			Node src = n;
			String srctype = src.returnType();
			if (srctype.startsWith("ref ")) {
				srctype = Format.typeDeref(srctype );
			}
			// make sure it is not already a ref
			Cast castr = new Cast("ref " + srctype, r);
			Node derefsrc;
			Assign ra = new Assign(castr,derefsrc= forcederef(src, srctype));
			String trace = n.toString();
			boolean res = Assign.checkAssignComp(r.returnType(), srctype);
			if (recursing(trace, recsp - 1)) {
				if (verbose) {
					log("failed because of recursion on " + trace);
				}
				return false;
			}
			recTrace[recsp] = trace;
			if(prereserve)reserve(r);
			recsp++;
			String oldpad = pad;
			if(prereserve)pad = pad + r;
			// try codegenerating
			res = res && codeGen(ra);
		        
			recsp--;
			if(!prereserve)reserve(r);
			if (!res) {
				unreserve(r);
				pad = oldpad;
			}
			if (res) {
				if (wasSubField) {
					// free up the whole of the register and reserve
					// just the subfield we need
					unreserve(r);
					reserve(subregister);
					matchedTree = subregister;
					matchedAssembler = subregister.toString();
					return true;
				}
				Node answer = castr;
				matchedTree = answer;
				matchedAssembler = r.toString();
				return true;
			}

		}
		catch (Exception e) {
			dlog("in loadregister failed because " + e);
		}


		return false;
	}




	/**
	 *  Description of the Method       looks for common sub expressions in an assignment
 it should not be called if there is any chance that there are data dependencies in the node n
	 *
	 *@param  n  Description of Parameter
	 *@return    Description of the Returned Value
	 */
	boolean subexpOptimisedCodeGen(Node n) {
		int oldinvocations=invocations;
		dlog(" sub exp optimise " + n);
		//if(!(n instanceof Assign))return n;
// try and find any common sub expressions to evaluate first
		CommonRHSFinder subs = new CommonRHSFinder();
		int mark=buf.mark();

		if(!unoptimisedcodegen(n)){return false;}
		int firstTryInvocations = invocations-oldinvocations;
		String[] unoptimisedlines=buf.sequester(mark);

		try {

			if(n instanceof If) ((If)n).cond.examine(subs); else n.examine(subs);
			int repcount=subs.getRepeatCount();
			if ((subExpressionOptimise&optimisationLevel)!=0){
			  if(repcount > 0) {
				Object[] subexps = subs.getRepeats();
				// chose one sub expression and assign it to the register
				Node value =(Node) subexps[0];

				if (verbose) {
					dlog("common sub expression " + value);
				}
				String refvrt = "ref " + value.returnType();
				Register r = findFreeReg(refvrt);
				int arefree=0;
				if(subs.score(value)*subs.usage(value)<subs.optimiseThreshold){
					if(verbose){log (" not worth caching "+value);}
				}
				else
				if (r == null||((arefree=stillFree(refvrt))<=minimumFreeRegisters)) {
					if (verbose) {log("not enough free regs"+arefree+"<="+minimumFreeRegisters);}
				}
				else {

					Node prepare = new Assign(r, forcederef(value,Format.typeDeref( r.returnType() )));
					Node A=value;
					Node B=new Deref(new Cast(refvrt, r));

					Node simplified ;
					if(n instanceof If){
						If nif=(If)n;
						// for ifs only substitute into condition
						simplified=new If(ExpressionSubstituter.substituteAwithBinC(A,B,nif.cond),nif.a1,nif.a2);
					}
					else simplified= ExpressionSubstituter.substituteAwithBinC(A,B,n);
					if (simplified.equals(n)) {

					// do nothing
					}
					else {

						if (verbose) {
							log("simplified to " + simplified);

						}

						// reserve a new register for the left hand side of the main assignment
						if(subexpOptimisedCodeGen(prepare)){
							reserve(r);
							// we are only willing to put the about same amount of compile time
							// effort into finding the optimised solution as the unoptimised one
							int oldlimit=matchbudget;
							matchbudget=invocations+firstTryInvocations*2+20;
							boolean res = subexpOptimisedCodeGen(simplified);
							matchbudget=oldlimit;
							unreserve(r);
							if(!res){buf.rollBackTo(mark);
									throw new Exception("can not generate optimised");
									}
							// otherwise see which is the shortest
							// in some cases register optimisation may
							// lead to less efficient code
							String[] optimisedlines = buf.sequester(mark);
							{

								if(unoptimisedlines.length<optimisedlines.length){
									// output the unoptimised code

									throw new Exception("optimised worse");
								}
							}
							// output the optimised code
							buf.writeln("; #substituting in "+r+" with "+subs.usage(value)+
								" occurences and score of "+subs.score(value));

							buf.append(optimisedlines);
							return true;
						}
					}
				}
			  }
			}
		}
		catch (Exception f) {
			dlog("opt:"+f);
		//	System.out.println(f);
		}
		buf.append(unoptimisedlines);
		return true;

	}


	/**
	 *  checks if an object is in an array
	 *
	 *@param  set       Description of Parameter
	 *@param  instance  Description of Parameter
	 *@return           Description of the Returned Value
	 */
	public static boolean inarray(Object[] set, Object instance) {
		int i;
		for (i = 0; i < set.length; i++) {
			if (instance.equals(set[i])) {
				return true;
			}
		}
		return false;
	}
}
// end of class walker
/**
 *  Used to search for memory references that can be substituted with register
 *  references
 *
 *@author     wpc
 *@created    June 22, 2001
 */

class CommonMemExpressionFinder extends CommonSubExpressionFinder {


	/**
	 *  This is called after all subtrees have been visited
	 *
	 *@param  n  Description of Parameter
	 */
	public void leave(Node n) {
		if (n instanceof Memref) {
			record( n);
		}
	}

}

/**
 *  finds memory dereferences in the tree
 *
 *@author     wpc
 *@created    June 22, 2001
 */
class CommonRHSFinder extends CommonSubExpressionFinder {
        int optimiseThreshold=3;

	/**
	 *  This is called after all subtrees have been visited
	 *
	 *@param  n  Description of Parameter
	 */
	public void leave(Node n) {
		int count = score(n);
		if(count>0)record(n);
	}
	public int score(Node n)
	{
	    if(n ==null) return 0; 
	//	if(!n.returnType().equals(Node.int32))return 0;
		if (n instanceof Deref) {
		
			return mscore(n);
		}
		if( n instanceof Dyad){ return mscore(n);}
		
		return 0;
	}
	int mscore(Node n)
	{
		
		if(n==null)return 0;
		if ( n instanceof Cast){ return mscore(((Cast)n).subtree);}
		if ( n instanceof Memref) return mscore(((Memref)n).index)+4;
		if (n instanceof Deref) {
			Deref d = (Deref) n;
			return mscore(d.arg);
		}
		if (n instanceof Dyad) {Dyad d=(Dyad)n;
		        int inc=2;
			if(d.O.Symbol.equals("<")||d.O.Symbol.equals(">")||d.O.Symbol.equals("="))inc=4;
		        if (d.O.Symbol.equals("*"))inc= -1;        // dont optimise these as they can be done
		                                               // in address expressions
			return mscore(d.left)+mscore(d.right)+inc;
		}
		return 0;
	}


}



