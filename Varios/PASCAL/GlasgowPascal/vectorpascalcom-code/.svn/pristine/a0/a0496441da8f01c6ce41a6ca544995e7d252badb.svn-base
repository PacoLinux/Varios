#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass amsart
\language english
\inputencoding auto
\fontscheme pslatex
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title
\added_space_top vfill \added_space_bottom vfill 
Intermediate Language for Code Generation and the ILCP API
\layout Date

Feb 2003 
\layout Author


\begin_inset ERT
status Open

\layout Standard

\end_inset 

Paul
\begin_inset ERT
status Open

\layout Standard

\end_inset 

Cockshott
\begin_inset ERT
status Open

\layout Standard

\end_inset 


\layout Abstract

This describes the strategy of code generation to be used with the ILCP
 code generator generator system for Pascal.
 It is intended to be used by writers of compiler front ends.
 Familiarity with assembly language and with compiler technology is assumed.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section

What is ILCG
\layout Standard

ILCG is short for Intermediate Language for Code Generation.
 It is a notation that serves two purposes:
\layout Enumerate

It can be used to describe the semantics of a computer's instructionset.
\layout Enumerate

It can be used to describe the semantics of a computer program.
\layout Standard

Like most formal notations it can have several concrete representations.
 One representation would be as a flat ascii file using the grammar defined
 in section 
\begin_inset LatexCommand \ref{sec:ILCG-grammar}

\end_inset 

.
 Another would be as an internal tree structure in a computers memory.
 Tools and libraries exist to translate flat ascii representations of ILCG
 into internal tree structures based on the data-types of Java and Pascal.
 Since this document is concerned with the use of compiler tools in Pascal
 we shall concentrate on this representation.
\layout Section

Structure of the code-generation process
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard


\begin_inset Graphics FormatVersion 1
	filename treediag.eps
	display default
	size_type 1
	width 5in
	scale 75
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0

\end_inset 


\layout Caption

Overview of the translation process
\begin_inset LatexCommand \label{cap:Overview-of-the}

\end_inset 


\end_inset 


\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:Overview-of-the}

\end_inset 

 shows the way ILCG can be used to translate high level languages into assembly
 code.
 Amachine description in ILCG - for instance the 386 description given in
 section 
\begin_inset LatexCommand \ref{sec:Example-ILCG-machine}

\end_inset 

, is input to a translation program written in Java (
\family typewriter 
ilcg.Ilcp.java
\family default 
) which generates a Pascal unit, which in this case we might call 
\family typewriter 
I386.pas
\family default 
.
 When this unit is invoked during program startup it initialises a collection
 of tables and trees which together constitute an internal Pascal representation
 of the original Ascii machine description file.
\layout Standard

A Pascal lexical and syntax analyser process a Pascal source file and translate
 it to an internal Ilcp tree structure, with nodes of type 
\family typewriter 
ilcgnode
\family default 
.
 The tree representing the program is then compared to the tree representing
 the machine by a unit 
\family typewriter 
Ilcp.pas
\family default 
.
 
\layout Standard

Let us call the tree representing the machine 
\begin_inset Formula $m$
\end_inset 

 and the tree representing the program 
\begin_inset Formula $p$
\end_inset 

.
 The tree matching unit takes each statement 
\begin_inset Formula $s$
\end_inset 

 in 
\begin_inset Formula $p$
\end_inset 

and searches for an instruction 
\begin_inset Formula $i$
\end_inset 

 in 
\begin_inset Formula $m$
\end_inset 

 which has the same type signature.
 If the tree for the instruction 
\begin_inset Formula $i$
\end_inset 

 and the tree for the statement 
\begin_inset Formula $s$
\end_inset 

 correspond exactly, then the corresponding assembly instruction is output
 to an assembler file.
 If it does not exactly correspond, the tree matcher attempts to break 
\begin_inset Formula $s$
\end_inset 

 into a series of substatement trees 
\begin_inset Formula $s_{1},s_{2},...$
\end_inset 

 which can individually be matched against instructions.
 
\layout Standard

This approach to machine code generation was pioneered by Susan Graham in
 the 80s.
 It has the advantages of yielding very good matches between the source
 code and the instructionset - matches which are frequently as good as a
 human assembly coder could achieve.
 We will give an intial example of how this works before going into more
 details
\layout Subsection

Machine description files
\layout Standard

CPUs are defined in hardware description language ILCG.
 What follows is a cut down example.
\layout Subsection

Define registers
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
register int32 EAX assembles['eax'] ;
\newline 
register int32 ECX assembles['ecx'] ;
\newline 
register int32 EBX assembles['ebx'] ;
\newline 
register word EBP assembles['ebp'] ;
\newline 
alias register word FP = EBP(0:31) assembles ['ebp'];
\newline 
reserved register word ESP assembles['esp'];
\newline 
register int32 ESI assembles['esi'] ;
\newline 
register int32 EDI assembles['edi'] ;
\newline 
register int32 EDX assembles['edx'];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Define sets of registers
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern indexreg means[EDI|ESI|EBX|EBP|ESP|EAX|EDX|ECX];
\newline 
pattern accumulators means[EAX|EDX|ECX|EBX];
\newline 
pattern ireg means [ indexreg] ;
\newline 
pattern ureg means [EBP| ubx|udi|usi|udx|ESP|ucx|uax ] ;
\newline 

\newline 
pattern reg means [ireg|ureg];
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Define operations supported
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 

\newline 
*/
\newline 
operation add means + assembles [ 'add'];
\newline 
operation and means AND assembles[ 'and'];
\newline 
operation or means OR assembles['or'];
\newline 
operation xor means XOR assembles['xor'];/* */
\newline 
operation sub means - assembles [ 'sub']; 
\newline 
operation imul means * assembles ['imul '];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Define address modes
\layout LyX-Code

pattern labelf(label l)
\newline 
 means [l]
\newline 
 assembles[l];
\newline 

\newline 
pattern constf(signed s)
\newline 
 means[const s]
\newline 
 assembles [s];
\newline 
pattern offset means[constf|labelf];
\newline 
pattern regindirf(reg r) 
\newline 
 means[^(r) ]
\newline 
 assembles[ r ];
\layout LyX-Code

pattern baseplusoffsetf(reg r, offset s )
\newline 
 means[+( ^(r) , s)]
\newline 
 assembles[ r '+' s ];
\newline 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim} 
\newline 
pattern eaform means[
\newline 
 labelf|
\newline 
 basePlusScaledIndexPlusOffsetf| 
\newline 
 baseplusoffsetf  ];
\newline 

\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Type casts
\layout Standard

The syntax for the type casts is C style so we have for example 
\family typewriter 
(ieee64) int32
\family default 
 to represent a conversion of an 32 bit integer to a 64 bit real.
 These type casts act as constraints on the pattern matcher during code
 generation.
 They do not perform any data transformation.
 They are inserted into machine descritions to constrain the types of the
 arguments that will be matched for an instruction.
 They are also used by compilers to decorate ILCG trees in order both to
 enforce, and to allow limited breaking of, the type rules.
\layout Subsubsection

Define instructions
\layout Standard

An instruction format is an abstraction over a class of concrete instructions.
 It abstracts over particular operations and types thereof whilst specifying
 how arguments can be combined.
\layout LyX-Code


\series bold 
instruction pattern LOAD(maddrmode rm, anyreg r1, wordupto32 t) 
\newline 
 means[ (ref t) r1:= (t)^(rm )] 
\newline 
 assembles['mov ' r1 ',' t ' ' rm];
\series default 
 
\layout LyX-Code


\series bold 
instruction pattern STORER(maddrmode rm, reg r1, word32 t)
\newline 
 means[ (ref t) rm:= ^( r1) ]
\newline 
 assembles['mov ' t ' 'rm',' r1];
\newline 

\newline 
instruction pattern STORELIT(addrmode rm, type t, int s)
\newline 
 means[ (ref t) rm:= (t)const s ]
\newline 
 assembles['mov ' t ' 'rm ',' ' ' s];
\layout Paragraph*

Arithmetic instructions
\layout LyX-Code


\series bold 
instruction pattern 
\layout LyX-Code


\series bold 
 RRM(operator op, reg r1, maddrmode rm, int t)
\layout LyX-Code


\series bold 
 means [r1:=(t) op( 
\begin_inset Formula $\uparrow $
\end_inset 

((ref t)r1),
\begin_inset Formula $\uparrow $
\end_inset 

((ref t) rm))]
\layout LyX-Code


\series bold 
 assembles[op ' ' r1 ',' rm ] ;
\layout LyX-Code


\series bold 
instruction pattern 
\layout LyX-Code


\series bold 
 RR( operator op, anyreg r1, anyreg r2, int t)
\layout LyX-Code


\series bold 
 means[r1:=(t) op( 
\begin_inset Formula $\uparrow $
\end_inset 

((ref t) r1),
\begin_inset Formula $\uparrow $
\end_inset 

((ref t) r2))]
\layout LyX-Code


\series bold 
 assembles[op ' ' r1 ',' r2];
\layout Standard

The
\series bold 
 int t
\series default 
 parameter is a type variable which will match any integer type - this stops
 the instructions from being used for floating point operations
\layout LyX-Code


\series bold 
instruction pattern RMLIT(nonmultoperator op,
\newline 
                      addrmode rm, type t, offset sm)
\newline 
 means[ (ref t) rm:= op(^(rm),(t) sm) ]
\newline 
 assembles[op ' ' t ' ' rm ',' sm];
\newline 

\newline 
instruction pattern INC(addrmode rm,int t)
\newline 
 means[(ref t)rm:= + (^(rm),1)]
\newline 
 assembles['inc ' t ' ' rm];
\newline 

\layout Subsubsection

Define instruction order
\layout LyX-Code

instructionset[LOAD| STORELIT| INC| RMLIT| RRM| RR| STORE];
\layout Standard

List these from the most specific to the most general 
\layout Standard

Store is most general, since it can store the result of any expression that
 has been evaluated to a register.
 Load is the most specific, as it is only used in the middle of expression
 evaluation and can only match a variable.
\layout Subsection

Matching
\layout Standard

Source trees are matched against the machine description by a function within
 the unit 
\family typewriter 
ILCP.pas
\family default 
:
\layout LyX-Code

function match(m:pilcgnode;var b:rollbackbuffer):boolean;
\layout Standard

For each instruction pattern in turn try to match the 
\series bold 
m
\series default 
 to the meaning of the instruction, if a match is found output the assembler
 part substituting in the parameters where relevant, otherwise return false.
\layout Standard

In doing this the following substitutions can be made
\layout Enumerate

for a register parameter r and expression e, recursively call match(r:=e)
\layout Enumerate

for an address mode parameter m , and expression e attempt to match the
 address mode to e.
\layout Paragraph*

Example
\layout Standard

i:=2
\layout Standard

Assume i at offset 10 from ebp, parser generates the tree shown in figure
 
\begin_inset LatexCommand \ref{cap:Tree-for-x:=2}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed true

\layout Standard


\begin_inset Graphics FormatVersion 1
	filename assntree.eps
	display default
	size_type 1
	height 2in
	keepAspectRatio
	rotateOrigin center
	lyxsize_type 0

\end_inset 


\layout Caption

Tree for i:=2 where i is at offset 10 from ebp
\begin_inset LatexCommand \label{cap:Tree-for-x:=2}

\end_inset 


\end_inset 


\layout Standard

we can represent this textually as
\layout Standard


\emph on 
(ref int32)mem(+(^(ebp),10)):= (int32)2
\layout Standard

match this to
\layout Standard


\series bold 
(ref t) r1:= (t)^(rm ) : LOAD
\layout Standard


\series bold 
(ref t) rm:= (t)const s : STORELIT
\layout Standard


\series bold 
(ref t)rm:= + (^(rm),1) : INC
\layout Standard


\series bold 
(ref t) rm:= op(^(rm),(t) sm) : RMLIT
\layout Standard


\series bold 
r1:=(t) op( ^((ref t)r1),^((ref t) rm)) :RRM
\layout Standard


\series bold 
(ref t) rm:= ^( r1) : STORER
\layout Standard

try LOAD, first bind 
\series bold 
t
\series default 
 to 
\emph on 
int32
\emph default 
, then attempt to bind 
\series bold 
r1
\series default 
 to 
\emph on 
mem(+(^(ebp),10))
\emph default 
 this fails because
\series bold 
 r1
\series default 
 is of type register
\layout Standard

try STORELIT, bind 
\series bold 
t
\series default 
 to 
\emph on 
int32
\emph default 
 then attempt to bind 
\series bold 
rm
\series default 
 to 
\emph on 
mem(+(^(ebp),10))
\layout Standard

rm is of type addrmode defined by
\layout LyX-Code


\series bold 
pattern addrmode means[maddrmode|anyreg];
\layout LyX-Code


\series bold 
pattern maddrmode(eaform f) means[mem(f) ] 
\layout LyX-Code


\series bold 
 assembles[ '[' f ']' ]
\series default 
;
\layout Standard

Try to match maddrmode to 
\emph on 
mem(+(^(ebp),10)) , 
\series bold 
\emph default 
mem(f)
\series default 
\emph on 
, 
\emph default 
this works if f binds to +(^(ebp),10).
\layout Standard

But a valid eaform is the pattern
\layout LyX-Code

pattern baseplusoffsetf(reg r, offset s )
\newline 
 means[+( ^(r) , s)]
\newline 
 assembles[ r '+' s ];
\layout Standard

which clearly matches.
\layout Standard

We have now matched
\layout Standard

(ref int32) mem(+(^(ebp),10)):=
\layout Standard

we have to match 2 to const s - which obviously works
\layout Standard

Then generate the assembler pattern for storelit
\layout LyX-Code


\series bold 
['mov ' t ' 'rm ',' ' ' s]
\layout Standard

substituting in the parameters
\layout Standard

t->int32->'dword'
\layout Standard

rm->memaddrword->eaform->baseplus offset-> '[ebp+10]'
\layout Standard

s->2
\layout Standard

so we generate
\layout LyX-Code

mov dword[ebp+10],2
\layout Standard

which is the optimal instruction for the instructionset.
\layout Subsection

Other optimisations
\layout Standard

In addition to matching statements against instructions the unit ilcp.pas
 performs some other optimisations.
\layout Subsubsection

Constant Folding
\layout Standard

One frequently has expressions all of part of which can be computed at compile
 time.
 These arise both because of constants the user has introduced and also
 in the evaluation of array expressions.
\layout Standard

Example
\layout LyX-Code

const a=9;
\layout LyX-Code

const b=1;
\layout LyX-Code

var c:Integer ;
\layout LyX-Code

begin
\layout LyX-Code

 c:=getint;
\layout LyX-Code

 c:=c+a*b;
\layout Standard

Visual inspection shows that the last line could read 
\layout LyX-Code

c:=c+9 
\layout Standard

Consider the formula
\layout Standard

(7+a)+(b+5) with a, b both variables not constants
\layout Standard

This has tree
\layout LyX-Code

       +
\layout LyX-Code

       |
\layout LyX-Code

   ------------------
\layout LyX-Code

   |                |
\layout LyX-Code

   +                +
\layout LyX-Code

   |                |
\layout LyX-Code

---------        ------------
\layout LyX-Code

|       |       |            |
\layout LyX-Code

7       a       b            5
\layout Standard

As it stands it can not be evaluated as a,b stop both branches of the tree
 from being known at compile time.
 But we know that in principle it is equal to a+b+12.
 To get this we must re-organise the tree.
 
\layout Standard

The strategy is to first move all the constant nodes to the right hand side
 of the tree leaving the variables on the left.
\layout Standard

The tree now becomes
\layout LyX-Code

       +
\layout LyX-Code

       |
\layout LyX-Code

   ------------------
\layout LyX-Code

   |                |
\layout LyX-Code

   +                +
\layout LyX-Code

   |                |
\layout LyX-Code

---------        ------------
\layout LyX-Code

|       |       |            |
\layout LyX-Code

a       7       b            5
\layout Standard

We next promote any constant right hand sides.
      That is to say
\layout Standard

we raise them to the right.
 After one stage we get:
\layout LyX-Code

             +
\layout LyX-Code

             |
\layout LyX-Code

        ----------
\layout LyX-Code

       |          |
\layout LyX-Code

       +          +
\layout LyX-Code

       |          |
\layout LyX-Code

       a       -------------
\layout LyX-Code

               |           |
\layout LyX-Code

               +           7
\layout LyX-Code

               |
\layout LyX-Code

           ------------
\layout LyX-Code

          |            |
\layout LyX-Code

          b            5
\layout Standard

We next recursively evaluate the re-organised tree.
\layout Standard

This will again attempt to reorganise:
\layout LyX-Code

             +
\layout LyX-Code

             |
\layout LyX-Code

        ----------
\layout LyX-Code

       |          |
\layout LyX-Code

       +          +
\layout LyX-Code

       |          |
\layout LyX-Code

       a       -------------
\layout LyX-Code

               |           |
\layout LyX-Code

               b           +
\layout LyX-Code

                           |
\layout LyX-Code

                     ------------
\layout LyX-Code

                    |            |
\layout LyX-Code

                    7            5
\layout Standard

which can be evaluated to a+b+12
\layout Subsubsection

Identity Element
\layout Standard

A value 
\begin_inset Formula $\varepsilon $
\end_inset 

 is the identity element of a typed operator 
\begin_inset Formula $\otimes $
\end_inset 

 if
\layout Standard

x 
\begin_inset Formula $\otimes $
\end_inset 


\begin_inset Formula $\varepsilon $
\end_inset 

= x , 
\begin_inset Formula $\forall $
\end_inset 

x
\layout Standard

Then for we have the following typical identity elements:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

type
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

operator
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

value
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

number
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

+
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

0
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

number
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

*
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

1
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bool
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

or
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

false
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bool
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

and
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

true
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

A constant folder should thus apply the following transformations
\layout Standard

x + 0 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

x * 1 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

x - 0 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

x / 1 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

x or false 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

x and true 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

x xor false 
\begin_inset Formula $\Rightarrow $
\end_inset 

x
\layout Standard

Note that these apply even when x not known till run time
\layout Subsubsection

Absorbers
\layout Standard

A value 
\begin_inset Formula $\alpha $
\end_inset 

 is the absorber of a typed operator 
\begin_inset Formula $\otimes $
\end_inset 

 if
\layout Standard

x 
\begin_inset Formula $\otimes $
\end_inset 


\begin_inset Formula $\alpha $
\end_inset 

= 
\begin_inset Formula $\alpha $
\end_inset 

 , 
\begin_inset Formula $\forall $
\end_inset 

x
\layout Standard

The absorbers relevant for compilation are
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

type
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

operator
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

value
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

number
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

*
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

0
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bool
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

and
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

false
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bool
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

or
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

true
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

thus a constant folder should handle the operations
\layout Standard

x * 0 
\begin_inset Formula $\Rightarrow $
\end_inset 

0
\layout Standard

x and false 
\begin_inset Formula $\Rightarrow $
\end_inset 

false
\layout Standard

x or true 
\begin_inset Formula $\Rightarrow $
\end_inset 

true
\layout Subsubsection

Dead Code Removal
\layout Standard

This is a special instance of constant folding.
 Consider the following:
\layout LyX-Code

const a=9;
\layout LyX-Code

begin
\layout LyX-Code

  if a>12 then c:=4 else c:=3;
\layout LyX-Code

end;
\layout Standard

We know from inspection that a is never >12 so that the then part of the
 if-then-else is never taken.
 So we can rewrite this as:
\layout LyX-Code

const a=9;
\layout LyX-Code

begin
\layout LyX-Code

   c:=3;
\layout LyX-Code

end;
\layout Standard

We do this by extending the constructor function for if-then-else so that
 if the condition is known at compile time only one branch of the loop is
 returned.
\layout Subsubsection

Register caching of induction variables
\layout Standard

Inner loops which have no function calls have their loop induction variables
 replaced by registers.
\layout Subsubsection

Vectorisation
\layout Standard

Most modern PCs are capable of performing several arithmetic operations
 in parallel.
 For instance a P4 can add 4 32 bit floating point operations in a single
 instruction, an AMD machine can add 2 32 bit floats with one instruction.
 The code generator analyses inner loops and those which have the general
 form
\layout LyX-Code

for i:=low to high do 
\layout LyX-Code

  a[i]:= b[i] op1 c[i] op2 d[i] ....
\layout Standard

are vectorised if vector instructions to perform operations op1, op2 etc
 exist.
\layout Standard

The resulting code takes the form of two loops, the quotient loop and the
 remainder loop.
 The quotient loop is executed in parallel up to the parallism factor defined
 by the machines vector registers, the remainder loop is then serialised.
\layout Standard

Suppose low=0 and high =10 and the type of a[i],b[i] etc is 32 bit float
 and that the machine is p4, then the quotient loop translates to
\layout LyX-Code

for i:= 0 to 7 step 4 do
\layout LyX-Code

a[i..i+3]:=b[i..i+3] op1 c[i..i+3] op2 d[i..i+3] ....
\layout Standard

the remainder loop translates to
\layout LyX-Code

for i:=8 to 10 do 
\layout LyX-Code

  a[i]:= b[i] op1 c[i] op2 d[i] ....
\layout Standard

The absence of scalar to vector arithmetic instructions on the Intel and
 AMD processors means that the gains from vectorisation are more limited
 if any of the operands in the assignment statement are scalars rather than
 vectors.
 The code generator will attempt to vectorise these, but in doing so it
 is forced to make multiple copies of scalars prior to loading them into
 vector registers.
 This is relatively costly.
\layout LyX-Code

\layout Subsubsection

Dead for loop elimination
\layout Standard

given
\layout LyX-Code

for i~ e1 ..
 e2 do c1
\layout Standard

then if we know at compile time that e1 will always be greater than e2,
 we can remove the entire for statement.
\layout Subsubsection

Loop unrolling
\layout Standard

It is advantageous to unroll loops to some degree.
 Unrolling loops has the advantages that:
\layout Enumerate

Since the size of basic block is increased the chances of pipeline stalls
 are reduced.
 This may be less significant with the very latest processors.
\layout Enumerate

The total number of instructions executed can be reduced since in simple
 an inner loop the comparison and branch instructions can make up around
 30% of the instructions executed.
 If we perform 5 fold unrolling we reduce this overhead, allowing the loop
 to execute about 25% faster.
\layout Standard

A for loop of the form
\layout LyX-Code

for i:= 1 to 10 do x[i]:=j[i]+1;
\layout Standard

Will be expanded to
\layout LyX-Code

for i:=1 to 10 do begin
\layout LyX-Code

 x[i]:=j[i]+1;
\layout LyX-Code

 i:=i+1;
\layout LyX-Code

 x[i]:=j[i]+1;
\layout LyX-Code

 i:=i+1;
\layout LyX-Code

 x[i]:=j[i]+1;
\layout LyX-Code

 i:=i+1;
\layout LyX-Code

 x[i]:=j[i]+1;
\layout LyX-Code

 i:=i+1;
\layout LyX-Code

 x[i]:=j[i]+1;
\layout LyX-Code

end
\layout Standard

Shorter loops are expanded less agressively.
 For loops of length less than 5, this enables the loop to be replaced with
 straight line code.
\layout Subsubsection

Unitary loop handling
\layout Standard

In the loop
\layout LyX-Code

for i~ 
\shape slanted 
e1
\shape default 
 ..
 
\shape slanted 
e2
\shape default 
 do 
\shape slanted 
c1
\layout Standard

If we know that 
\family typewriter 
\shape slanted 
e1=e2
\family default 
\shape default 
, then we can substitute it with
\layout LyX-Code

i:=
\shape slanted 
e1
\shape default 
;
\shape slanted 
c1
\shape default 
;
\layout Standard

So that 
\layout LyX-Code

const x=3 ;
\layout LyX-Code

    y=3-x;
\layout LyX-Code

begin
\layout LyX-Code

  for i~1 to y+1 do x[i]:= z[i]+y;
\layout LyX-Code

end;
\layout Standard

will simplify to
\layout LyX-Code

i:=1 ; x[i]:=z[i];
\layout Standard

Since vectorisation and loop unrolling are performed prior to dead loop
 removal and unitary loop handling the net effect is that
\layout Enumerate

Single precision floating point loops of length up to 20 are replaced with
 vectorised straight line code.
\layout Enumerate

Byte loops of length up to 40 are replaced by vectorised straight line code.
\layout Enumerate

For loops whose length modulo the vector register length is zero, the remainder
 loop is ellided, giving a fully vectorised loop.
\layout Section

ILCG nodes and their semantics
\layout Subsection

Types in ILCG
\layout Standard

ILCG is a strongly typed notation.
 Expression trees, memory locations and registers all have types.
 The type system is relatively simple being made up of base types and fixed
 length vectors of these types.
 Whilst less flexible than the type system of high level languages this
 is sufficient to describe the types understood by current CPUs.
\layout Subsubsection

Base types
\layout Standard

Base types are subdivided into integer, real, and unformated types.
 Real types are further subdivided according to whether they are signed
 or not, and according to length.
 Table 
\begin_inset LatexCommand \ref{cap:The-base-types}

\end_inset 

 , sumarises the base types supported.
\layout Standard


\begin_inset Float table
placement htbp
wide false
collapsed true

\layout Caption

The base types of ILCG
\begin_inset LatexCommand \label{cap:The-base-types}

\end_inset 


\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="15" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Name
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

length in bits
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

category
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

octet
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

untyped format
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

halfword
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

16
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

untyped format
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

word
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

untyped format
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

doubleword
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

64
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

untyped format
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

quadword
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

128
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

untyped format
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

int8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

signed integer
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

int16
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

16
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

signed integer
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

int32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

signed integer
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

int64
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

64
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

signed integer
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

uint8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

unsigned integer
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

uint16
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

16
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

unsigned integer
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

uint32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

unsigned integer
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

ieee32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

floating point
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

ieee64
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

64
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

floating point
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Subsubsection

Reference types
\layout Standard

A base type describes a unitary value.
 A storage location such as a register or a memory word is a reference type.
 A register that contains a 32 bit signed integer is of type 
\series bold 
ref int32
\series default 
 for example.
 Conceptually this is because the register refers to one of the integers,
 a usage borrowed from Algol-68 to distinguish permisible operations on
 storage locations from those permisable on simple values.
\layout Subsubsection

Vector types
\layout Standard

Avector type can be formed from a base type, hence we can have a type like
 
\series bold 
vector(4) ieee32
\series default 
 to represent a vector of four single precision floating point values.
 The vector definition facility is limited to fixed length vectors of base
 types, two dimensional arrays are not supported.
 This is obviously less sophisticated than a high level programming language
 requires but is sufficient to describe the types that can be manipulated
 by the vector registers of current machines.
\layout Subsubsection

Pascal encoding
\layout Standard

In the ILCG trees manipulated by Pascal programs the types of values are
 encoded in format tag words as shown in figure 
\begin_inset LatexCommand \ref{cap:Layout-of-a}

\end_inset 

.
 Since the type system is finite, a single word rather than a tree structure
 suffices.
 
\layout Standard

If only the length field of the word is initialised, then the word indicates
 an untyped format.
 
\layout Standard

The use of the integer and real bits in the word are mutually exclusive.
 The signed bit should only be used if the integer bit is set.
 
\layout Standard

The vector length field should only be used if the vector bit is set.
\layout Standard

A collection of formats are exported as predeclared constants from ilcp.pas:
 
\family typewriter 
fint, fint16, fuint16
\family default 
 etc.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename typetag.eps
	display default
	size_type 1
	width 4in
	rotateOrigin center
	lyxsize_type 0

\end_inset 


\layout Caption

Layout of a format description word in an ILCG tree
\begin_inset LatexCommand \label{cap:Layout-of-a}

\end_inset 


\end_inset 


\layout Subsection

ILCG tree nodes
\layout Standard

The nodes of the ILCG internal tree are represented by variant records in
 Pascal with a tag field of the type:
\layout LyX-Code

nodeclass=(
\layout LyX-Code

 deref,   arraysubscript,reallit,      intlit,
\layout LyX-Code

 format,  regstack,      unboundformat,ref,
\layout LyX-Code

 gotonode,patterntag,    failure,      typevar,
\layout LyX-Code

 Assignop,forloop,       memref,       dyadicop,
\layout LyX-Code

 ifnode,  sequence,      alternation,  monad,
\layout LyX-Code

 monop,   dyad,          typecast,     constant,
\layout LyX-Code

 param,   reg,           location,     labelnode,
\layout LyX-Code

 procedurenode
\layout LyX-Code

);
\layout Standard

Many of these sorts of nodes are used only in machine descriptions.
 The format of the variant records describing the nodes in Pascal is:
\layout LyX-Code

ilcgnode= record
\layout LyX-Code

      simple:boolean; {  already simplified }
\layout LyX-Code

      case tag:nodeclass of
\layout LyX-Code

      patterntag:(pat:ppattern;);
\layout LyX-Code

\layout LyX-Code

      deref,ref,constant,monad,
\layout LyX-Code

      dyad,memref,typecast,failure:
\layout LyX-Code

       (arg,fn,arg2:pilcgnode;);
\layout LyX-Code

\layout LyX-Code

      location:(locvalue:pilcgnode;);
\layout LyX-Code

\layout LyX-Code

      regstack:(stackdetails:registerstack;);
\layout LyX-Code

\layout LyX-Code

      arraysubscript:
\layout LyX-Code

        ( base, { base address }
\layout LyX-Code

          offset:pilcgnode; { i,th element }
\layout LyX-Code

          { step calculated from format}
\layout LyX-Code

          elementformat:integer);
\layout LyX-Code

\layout LyX-Code

      Assignop,gotonode:
\layout LyX-Code

       (src,dest:pilcgnode;);
\layout LyX-Code

\layout LyX-Code

      alternation:
\layout LyX-Code

       (first,last:integer);
\layout LyX-Code

\layout LyX-Code

      intlit,reallit:
\layout LyX-Code

       ( reallitarg:intreal;
\layout LyX-Code

         intlitarg:intint;
\layout LyX-Code

         litformat:integer);
\layout LyX-Code

\layout LyX-Code

      ifnode:
\layout LyX-Code

       ( condition,
\layout LyX-Code

         action,
\layout LyX-Code

         alternative:pilcgnode;);
\layout LyX-Code

\layout LyX-Code

      unboundformat,format:
\layout LyX-Code

       (formatarg:integer);
\layout LyX-Code

\layout LyX-Code

      monop,dyadicop:
\layout LyX-Code

       (opname:string[15];);
\layout LyX-Code

\layout LyX-Code

     labelnode,param,reg:
\layout LyX-Code

       (index:integer;);
\layout LyX-Code

\layout LyX-Code

     sequence:
\layout LyX-Code

       (current,next:pilcgnode;);
\layout LyX-Code

\layout LyX-Code

     forloop:
\layout LyX-Code

      ( indexvar,
\layout LyX-Code

        start,
\layout LyX-Code

        stop,
\layout LyX-Code

        incr,
\layout LyX-Code

      loopaction:pilcgnode);
\layout LyX-Code

\layout LyX-Code

      procedurenode:
\layout LyX-Code

       ( procedurebody:pilcgnode;
\layout LyX-Code

         languagespecificinfo:pointer);
\layout LyX-Code

end;
\layout Subsection

Constructor functions
\layout Standard

Many of these classes of nodes can only occur in machine description trees,
 but for the ones that are used in constructing program trees, a collection
 of constructor functions is exported by the unit 
\family typewriter 
ILCP.pas
\family default 
.function I shall describe the semaintics of the ILCG trees in terms of these
 constructor functions.
\layout Subsubsection

new_arraysubscript
\layout LyX-Code

function new_arraysubscript(baseaddr,index:pilcgnode;form:integer):pilcgnode;
\layout Standard

Creates a node representing an array subscription operation.
 The baseaddr should be an ILCG tree for an integer expression giving the
 starting address of the array.
 The index should be a tree giving an ILCG expression for the offset into
 the array.
 The form parameter is a tag word describing the format of the array elements
 ( not the array itself ).
 The base address should be adjusted to allow for arrays starting at non-zero
 values.
 
\layout Paragraph*

Example: 
\layout Standard

given the pascal array declaration:
\layout Standard

var x:array[2..4] of integer; i:integer;
\layout Standard

then if x was at address 100 and i at address 90, then the subscription
 
\family typewriter 
x[i]
\family default 
 would translate to the ILCG tree
\layout LyX-Code

new_arraysubscript(
\layout LyX-Code

 new_intlit(100-8,fint32),     { allow for starting at 2 }
\layout LyX-Code

 new_deref(new_memref(new_intlit(90,fint32),fint32)),
\layout LyX-Code

 fint32);
\layout Subsubsection

new_assign
\layout LyX-Code

function new_assign(dest,src:pilcgnode):pilcgnode; 
\layout Standard

This creates a pointer to an ilcgnode whose tag is 
\family typewriter 
assignop
\family default 
.
 The source should be a tree of type 
\series bold 
ref
\series default 
 
\emph on 
t 
\emph default 
and the destination a tree of type 
\emph on 
t
\emph default 
.
 The effect when passed to the code generator is to generate code to evaluate
 the 
\family typewriter 
src
\family default 
 and store it in the
\family typewriter 
 dest
\family default 
.
\layout Subsubsection

new_deref
\layout LyX-Code

function new_deref(loc:pilcgnode):pilcgnode; 
\layout Standard

This creates a node representing the memory or register dereferencing operation.
 If
\family typewriter 
 x
\family default 
 is a node representing a location, 
\family typewriter 
new_deref(x)
\family default 
 is a node representing fetching the contents of a location.
 Thus if 
\family typewriter 
x,y
\family default 
 are both registers or memory locations 
\family typewriter 
new_assign(x,new_deref(y))
\family default 
 represents the operation of copying the contents of 
\family typewriter 
y
\family default 
 into 
\family typewriter 
x
\family default 
, or in pascal source terms 
\family typewriter 
x:=y
\family default 
.
\layout Standard


\begin_inset Float table
placement htbp
wide false
collapsed true

\layout Caption

Monadic operations.
\begin_inset LatexCommand \label{cap:Monadic-operations.}

\end_inset 


\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="12" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="left" valignment="top" leftline="true" width="0pt">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

operator
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

means
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

comment
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'EXTEND'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

extend precision
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

expand a short integer rep to longer rep
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'POP'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

pop off stack
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

argument must be a stack
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'NOT'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bitwise negate
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'SQRT'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

squareroot
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

returns a real
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'ROUND'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

round to integer
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

argument must be real
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'COS'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

cosine
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'SIN'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

sine
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'TAN'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

tangent
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'ABS'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

absolute value
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'FLOAT'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

float an integer
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'LN'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

natural log
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout LyX-Code

 
\end_inset 


\layout Subsubsection

new_dyad
\layout LyX-Code

function new_dyad(left:pilcgnode;op:string;right:pilcgnode):pilcgnode; 
\layout Standard

This creates a node representing a binary expression.
 The operators are drawn from the set of strings shown in table 
\begin_inset LatexCommand \ref{cap:Dyadic-operators}

\end_inset 

.
\layout Paragraph*

Example
\layout LyX-Code

new_assign(x, new_dyad(new_deref(x),'+', new_deref(y)));
\layout Subsubsection

new_monad
\layout LyX-Code

function new_monad(op:string;right:pilcgnode):pilcgnode;
\layout Standard

This creates a node representing the application of a monadic operator.
\layout Standard

The monadic operators are drawn from the set shown in table 
\begin_inset LatexCommand \ref{cap:Monadic-operations.}

\end_inset 

.
 They are typically operations for which hardware support exists and for
 which subroutines calls are not necessary.
\layout Standard


\begin_inset Float table
placement htbp
wide false
collapsed true

\layout LyX-Code

\layout Caption

Dyadic operators
\begin_inset LatexCommand \label{cap:Dyadic-operators}

\end_inset 


\layout LyX-Code
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="24" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="left" valignment="top" leftline="true" width="0pt">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

string
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

means
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

comment
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'*'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

multiply
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'AND'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bitwise and
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'/'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

divide
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'PUSH'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

push on stack
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

left arg must be a stack
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'OR'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bitwise or
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'+'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

add
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'MIN'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

return least
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'MAX'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

return greater
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'-'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

subtract
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'REP'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

replicate
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

a REP 
\begin_inset Formula $n$
\end_inset 

makes an 
\begin_inset Formula $n$
\end_inset 

 element vector or a
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'='
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

equals
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

by default returns byte with true = FF
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'<>'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

not equals
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'>='
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

greater than or equal
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'<='
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

less than or equal
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'>'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

greater than
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'<'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

less thean
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'>>'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

shift right
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

a>>n shifts a n places right
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'<<'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

shift left
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'*:'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

saturated multiply
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'-:'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

saturated subtract
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'+:'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

saturated add
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'CALL'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

call procedure
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

x CALL y, x is procedure, y arglist
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

'MOD'
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

remainder
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Subsubsection

new_for
\layout LyX-Code

function new_for( indexvar, start, stop, incr, loopaction:pilcgnode):pilcgnode;
 
\layout Standard

Generates a new for loop tree, equivalent to:
\layout LyX-Code

for indexvar:=start to stop step incr do loopaction.
\layout Standard

The value of the indexvar is undefined on exit from the loop.
 For loops are the target for vectorisation optimisations.
 Loops that use explicit gotos will not be vectorised.
\layout Subsubsection

new_format
\layout LyX-Code

function new_format(form:integer):pilcgnode; 
\layout Standard

Given an ILCG type tag (see fig 
\begin_inset LatexCommand \ref{cap:Layout-of-a}

\end_inset 

), this creates an ILCG node that can be used in a typecast.
\layout Paragraph*

Example: 
\layout LyX-Code

new_format(fint32);
\layout Subsubsection

new_goto
\layout LyX-Code

function new_goto(dest:pilcgnode):pilcgnode;
\layout Standard

Creates a node representing a branch.
 The destination can be a label or an expression that evaluates to an address.
\layout Subsubsection

new_if
\layout LyX-Code

function new_if(condition,thenpart,elsepart:pilcgnode):pilcgnode; 
\layout Standard

Creates a node representing a high level language if-then-else statement.
 The condition must be an integer expression.
 It it is nonzero the then part is executed.
\layout Subsubsection

new_intlit
\layout LyX-Code

function new_intlit(i:intint;intformat:integer):pilcgnode;
\layout Standard

Creates a new integer literal in an expression.
 The intformat field is a type tag specifying if it is unsigned or signed,
 how long it is etc.
\layout Subsubsection

new_label
\layout LyX-Code

function new_label:pilcgnode; 
\layout Standard

Creates a new local label.
 These will print out to the assembler file as l0, l1, etc.
\layout Subsubsection

new_memref
\layout LyX-Code

function new_memref(dest:pilcgnode;form:integer):pilcgnode; 
\layout Standard

Create a node representing a memory location.
 Its type is specified in the form field.
 This is a type tag as defined in figure 
\begin_inset LatexCommand \ref{cap:Layout-of-a}

\end_inset 

.
\layout Subsubsection

new_procedure
\layout LyX-Code

function new_procedure(body:pilcgnode;compilerinfo:pointer):pilcgnode; 
\layout Standard

This creates a node representing a prodedure.
 This node has two fields :
\layout List
\labelwidthstring 00.00.0000

body This defines the semantics of the prodedure and is an ilcg tree.
\layout List
\labelwidthstring 00.00.0000

compilerinfo This is a compiler specific field that encodes type information
 about the procedure such as whether its parameters are passed by reference
 or by value, what the calling convention is etc.
 This information is ignored by ILCP, and is only used when callback procedures
 are activated, (see section 
\begin_inset LatexCommand \ref{cap:Overview-of-the}

\end_inset 

).
 The front end of the compiler should initialise this field to point into
 a record in its symbol table.
\layout LyX-Code

\layout Subsubsection

new_reallit
\layout LyX-Code

function new_reallit(i:intreal;rformat:integer):pilcgnode; 
\layout Standard

Creates an real literal whose length is specified by the rformat field.
\layout Subsubsection

new_register
\layout LyX-Code

function new_register(regindex:integer):pilcgnode; 
\layout Standard

The registers of the machine are assigned internal numbers by the codegenerator
 generator.
 These do not correspond to the numbers that they have in machine code.
 There exists one predefined register for all processors 
\family typewriter 
fp
\family default 
.
 This is exported by ILCP.pas and defines the register used as the frame
 pointer.
 Which register is used for this is machine specific, but on intel machines
 
\family typewriter 
fp
\family default 
 is typically an alias for the 
\family typewriter 
ebp
\family default 
 register.
\layout Subsubsection

new_seq
\layout LyX-Code

function new_seq(hd,tl:pilcgnode):pilcgnode; 
\layout Standard

This forms a pair of statements into a compound statement.
 Thus the Pascal sequence:
\layout LyX-Code

a:=2; b:=a+1;
\layout Standard

would be mapped to
\layout LyX-Code

new_seq(
\layout LyX-Code

 new_assign(a,new_intlit(2,fint32)),
\layout LyX-Code

 new_assign(b,new_dyad(new_deref(a),'+',new_intlit(1,fintew))));
\layout Subsubsection

new_typecast
\layout LyX-Code

function new_typecast(format:integer; exp:pilcgnode):pilcgnode;
\layout Standard

This is a C style type cast which casts the expression exp to have the specific
 format.
 Typecasts should be used liberally to disambiguate machine code operations
 in the cases where a machine has several different instructions which perform
 the same operation but whose arguments are of different types.
\layout Section

Invoking the Code-Generator-Generator
\layout Standard

The code generator generator is a java program Ilcp.class in the package
 ilcg.
 It is invoked by the command line
\layout Standard


\family typewriter 
java ilcg.Ilcp
\family default 
 
\emph on 
ilcgsrc unitname destdir
\layout Standard

For example
\layout LyX-Code

java ilcg.Ilcp P4.ilc P4cg src/cgs
\layout Standard

would take the source file P4.ilc and generate a pascal unit P4cg.pas in directory
 src/cgs.
\layout Standard

Note that directory names when passed as parameters to java programs follow
 Linux rather than windows conventions.
 The resulting structure of the code generator would be as shown in figure
 
\begin_inset LatexCommand \ref{cap:Structure-of-units}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement htbp
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics FormatVersion 1
	filename cgstruct.eps
	display default
	size_type 0
	rotateOrigin center
	lyxsize_type 0

\end_inset 


\layout Caption

Structure of units in a compiler.
\begin_inset LatexCommand \label{cap:Structure-of-units}

\end_inset 


\end_inset 


\layout Section

Calling the code generator
\layout Standard

The main entry point to the code generator is the function
\layout LyX-Code

function codegen(n:pilcgnode; var assemblerfile:text):boolean;
\layout Standard

This is passed an ilcg tree and an open output file, and returns true if
 it was able to generate code for the tree.
\layout Subsection

Callbacks 
\begin_inset LatexCommand \label{sub:Callbacks}

\end_inset 


\layout Standard

Under 3 circumstances the code generator needs help from the higher levels
 of the compiler in order to generate correct code.
 These occasions are all associated with the generation of procedure calls.
 The calling conventions used for procedures will vary between languages
 and between implementations of languages.
 As examples: will parameters be passed on the stack or in registers?
\layout Standard

If on the stack are they pushed left to right or vice-versa? 
\layout Standard

What mechanism is to be used for nested procedures - a display or the use
 of static links?
\layout Standard

Are parameters passed by value or by reference?
\layout Standard

How are function results returned?
\layout Standard

The technique used to handle this is for the code generator to invoke callback
 functions within the higher levels of the compiler.
 The callback functions all have the type:
\layout LyX-Code

type 
\layout LyX-Code

 assemblercallback=procedure(p:pilcgnode;var b:rollbackbuffer);
\layout Standard

There are 3 such callbacks exported as procedure variables by ilcp.pas.
\layout LyX-Code

{ callback functions initialised by the syntax analyser }
\layout LyX-Code

procedureentrycode,
\layout LyX-Code

procedurecallcode,
\layout LyX-Code

procedureexitcode:assemblercallback;
\layout Standard

The syntax analyser level should initialise these variables prior to invoking
 codegen.
 The callback procedures can call the function match when evaluating sub-express
ions associated with procedure calls.
\layout LyX-Code

(*! This is the master matching routine in the code generator
\layout LyX-Code

it matches the tree n against the instructionset until
\layout LyX-Code

it gets a resolution, or if it fails returns false *)
\layout LyX-Code

function match(m:pilcgnode;var b:rollbackbuffer):boolean;
\layout Section

Use of multiple back ends in one compiler
\layout Standard

The code generator is currently written using the Turbo pascal dialect.
 It makes no use of objects or classes.
 All modularity is provided using units.
 This poses no problems so long as one wants a compiler targeted at only
 one machine.
 However if you want compile time options to be used to select different
 target machines this structure is not adequate.
\layout Standard

In the java implementation of the ILCG system this is resolved by implementing
 all code generators as sub-classes of a single parent class and allowing
 you to dynamically instanciate the code generator with an Intel or AMD
 sub-class.
 A different strategy is necessary in a non-object based language.
 Here I will suggest two possible approaches to solving the problem, but
 first I will explain the relationship between the unit ILCP.pas and the
 derived unit P4cg.pas shown in figure 
\begin_inset LatexCommand \ref{cap:Structure-of-units}

\end_inset 

.
\layout Standard

ILCP.pas exports a number of tables:
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
registers
\family default 
 this holds a descriptor for each register or aliased register declared
 in the machine description, indexed by the internal register number.
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
alternatives
\family default 
 this holds pointers to the patterns that occur in alternatations ( see
 section 
\begin_inset LatexCommand \ref{sub:pattern-declarations}

\end_inset 

 ) in the machine description.
\layout List
\labelwidthstring 00.00.0000


\family typewriter 
instructionsetorder
\family default 
 this contains an array of pointers to all the instruction patterns in the
 order in which they are to be tried.
\layout Standard

When the unit P4cg.pas is initialised it executes code to fill in these tables
 with an appropriate machine description and then sets the variables 
\family typewriter 
lastinstruction, lastreg, lastalt 
\family default 
to point to the last entries in thses tables.
 Were one to include multiple machine generated CPU description units like
 P4cg, then one would end up with the last such unit to be initialsed overwritti
ng the tables set up by the earlier units.
 To get round this two possible strategies can be followed.
\layout Enumerate

Suppose we want to include two code generators p4cg.pas and k6cg.pas.
 We make a copy of the unit ILCP.pas, call this ILCPk6.pas.
 We then hand alter the heading of the machine generated unit k6cg.pas so
 that it USES ILCPk6.pas instead of ILCP.
 The result is that K6cg will initialise a second set of tables in ILCPk6
 not in ILCP.
\layout Enumerate

We package each code generator, P4cg and K6cg with ILCP and place these
 in distinct DLLs: K6.dll, P4.dll one of which is then called to perform code
 generation at compile time.
\layout Section

ILCG grammar
\begin_inset LatexCommand \label{sec:ILCG-grammar}

\end_inset 


\layout Standard

This is a definition of the grammer of ILCG using the Sable grammar specificatio
n lanaguage.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 

\newline 

\newline 

\newline 

\newline 
Package ilcg;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Helpers
\layout Standard

Helpers are regular expressions macros used in the definition of terminal
 symbols of the grammar.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
Helpers
\newline 
  letter = [['A'..'Z']+['a'..'z']];
\newline 
  digit = ['0'..'9'];
\newline 
  alphanum = [letter+['0'..'9']];
\newline 
  cr = 13;
\newline 
  lf = 10;
\newline 
  tab = 9;
\newline 
    digit_sequence = digit+;
\newline 
    fractional_constant = digit_sequence? '.' digit_sequence | digit_sequence '.';
\newline 
    sign = '+' | '-';
\newline 
    exponent_part = ('e' | 'E') sign? digit_sequence;
\newline 
    floating_suffix = 'f' | 'F' | 'l' | 'L';
\newline 
  eol = cr lf | cr | lf;        // This takes care of different platforms
\newline 
  not_cr_lf = [[32..127] - [cr + lf]];
\newline 
  exponent = ('e'|'E');
\newline 
  quote = ''';
\newline 
  all =[0..127];
\newline 
  schar = [all-'''];
\newline 
  not_star = [all - '*'];
\newline 
  not_star_slash = [not_star - '/'];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Tokens
\layout Standard

The tokens section defines the terminal symbols of the grammar.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
Tokens
\newline 
  floating_constant = fractional_constant exponent_part? floating_suffix? |
\newline 
        digit_sequence exponent_part floating_suffix?;
\newline 
 /* 
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsubsection

Terminals specifying data formats
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
 void ='void';
\newline 
 octet = 'octet'; int8 = 'int8'; uint8 = 'uint8';
\newline 
 halfword = 'halfword'; int16 = 'int16' ; uint16 = 'uint16' ;
\newline 
 word = 'word'; int32 = 'int32' ; 
\newline 
 uint32 = 'uint32' ; ieee32 = 'ieee32';
\newline 
 doubleword = 'doubleword'; int64 = 'int64' ; 
\newline 
 uint64 = 'uint64'; ieee64 = 'ieee64';
\newline 
 quadword = 'quadword';
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsubsection

Terminals describing reserved words 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
 function= 'function';
\newline 
 flag = 'flag';
\newline 
 location = 'loc';
\newline 
 procedure='instruction';
\newline 
 returns ='returns';
\newline 
 label = 'label';
\newline 
 goto='goto';
\newline 
 fail ='interrupt';
\newline 
 for ='for';
\newline 
 to='to';
\newline 
 step='step';
\newline 
 do ='do';
\newline 
 ref='ref';
\newline 
 const='const';
\newline 
 reg= 'register';
\newline 
 operation = 'operation';
\newline 
 alias = 'alias';
\newline 
 instruction = 'instruction';
\newline 
 address = 'address';
\newline 
 vector ='vector';
\newline 
 stack = 'stack';
\newline 
 sideeffect='sideeffect';
\newline 
 if ='if';
\newline 
 reserved='reserved';
\newline 
 precondition ='precondition';
\newline 

\newline 
 instructionset='instructionset';
\newline 
/* 
\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Terminals for describing new patterns
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim} */
\newline 
 pattern = 'pattern';
\newline 
 means = 'means';
\newline 
 assembles = 'assembles'; 
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Terminals specifying operators
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
 colon = ':';
\newline 
 semicolon= ';';
\newline 
 comma = ',';
\newline 
 dot = '.' ;
\newline 
 bra ='(';
\newline 
 
\newline 
 ket =')';
\newline 
 plus = '+';
\newline 
 satplus = '+:';
\newline 
 satminus = '-:';
\newline 
 satmult ='*:';
\newline 
 map='->';
\newline 
 equals = '=';
\newline 
 le = '<=';
\newline 
 ge='>=';
\newline 
 ne='<>';
\newline 
 shl='<<';
\newline 
 shr='>>';
\newline 
 lt='<';
\newline 
 gt='>';
\newline 
 minus = '-';
\newline 
 times = '*';
\newline 
 exponentiate = '**';
\newline 
 divide = 'div';
\newline 
 replicate = 'rep';
\newline 
 and = 'AND';
\newline 
 or = 'OR' ;
\newline 
 xor = 'XOR';
\newline 
 not = 'NOT';
\newline 
 sin='SIN';
\newline 
 cos='COS';
\newline 
 abs='ABS';
\newline 
 tan='TAN';
\newline 
 ln='LN';
\newline 
 min='MIN';
\newline 
 max='MAX';
\newline 
 sqrt='SQRT';
\newline 
 trunc='TRUNCATE';
\newline 
 round='ROUND';
\newline 
 float='FLOAT';
\newline 
 remainder = 'MOD';
\newline 
 extend= 'EXTEND';
\newline 
 store = ':=';
\newline 
 deref = '^';
\newline 
 push ='PUSH';
\newline 
 pop ='POP';
\newline 
 call='APPLY';
\newline 
 full='FULL';
\newline 
 empty='EMPTY';
\newline 
 subscript='SUBSCRIPT'; 
\newline 
 intlit = digit+;
\newline 
 
\newline 
 vbar = '|';
\newline 
 sket=']';
\newline 
 sbra='[';
\newline 
 end='end';
\newline 
 typetoken='type';
\newline 
 mem='mem';
\newline 
 string = quote schar+ quote;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Standard

identifiers come after reserved words in the grammar
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 

\newline 
*/
\newline 
 identifier = letter alphanum*;  
\newline 
 blank = (' '|cr|lf|tab)+;
\newline 
 comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
\newline 

\newline 
Ignored Tokens 
\newline 
blank,comment;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Non terminal symbols
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
Productions
\newline 
 program = statementlist instructionlist;
\newline 
 instructionlist =instructionset sbra alternatives sket;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsection

Non terminals specifying data formats
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
 format = {octet} octet| {halfword} halfword |
\newline 
          {word} word | {doubleword} doubleword |
\newline 
          {quadword} quadword;
\newline 
 
\newline 
 
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsubsection

non terminals corresponding to type descriptions
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
 reference =   ref type ;
\newline 
 array = vector bra number ket;
\newline 
 aggregate={stack} stack bra number ket |{vector}array |{non};
\newline 
 predeclaredtype =   {format} format|{tformat}tformat ;
\newline 
 typeprim={typeid}  typeid| {predeclaredtype}predeclaredtype;
\newline 
type= {predeclaredtype}predeclaredtype|
\newline 
{typeid}  typeid|
\newline 
{array}typeprim array|
\newline 
 {cartesian}sbra type cartesian* sket|
\newline 
{reftype}reference|
\newline 
{map}bra [arg]:type map [result]:type ket;
\newline 
 cartesian =  comma type;
\newline 
 
\newline 
 tformat = {signed} signed|{unsigned}unsigned|{ieee32}ieee32|{ieee63}ieee64;
\newline 
 signed = int32 | {int8} int8 | {int16} int16 | {int64} int64;
\newline 
 unsigned = uint32 | {uint8} uint8 | {uint16} uint16 | 
\newline 
            {uint64} uint64;
\newline 
   
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsubsection

non terminals corresponding to typed values 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
 value = /*{refval}refval |      */
\newline 
 {rhs}rhs|
\newline 
 {loc}loc|
\newline 
 {void}void|
\newline 
 {cartval}cartval|
\newline 
{dyadic} dyadic bra [left]:value comma [right]:value ket|
\newline 
{monadic}monadic bra value ket;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsection

value corresponding to a cartesian product type e.g.
 record initialisers 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
 cartval=sbra value carttail* sket;
\newline 
 carttail = comma value;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

conditions used in defining control structures
\layout Standard


\begin_inset ERT
status Open

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
condition={dyadic} dyadic bra [left]:condition comma [right]:condition ket|
\newline 
{monadic}monadic bra condition ket |
\newline 
{id}identifier|
\newline 
{number}number;
\newline 
 rhs={number}number|
\newline 
 {cast}bra type ket value|
\newline 
 {const}const identifier |
\newline 
  {deref}deref  bra  refval ket;
\newline 
 
\newline 
 refval = loc|
\newline 
 {refcast} bra type ket loc;
\newline 
 loc = {id}identifier|
\newline 
 {memory}mem bra value ket ;
\newline 
 
\newline 

\newline 
/*predeclaredregister = {fp}fp|{gp}gp;*/
\newline 
 number =  {reallit} optionalsign reallit|
\newline 
           {integer} optionalsign intlit;
\newline 
 optionalsign = |{plus}plus|{minus}minus;
\newline 
 reallit= floating_constant;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsection

operators
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\layout Standard

\backslash 
begin{verbatim}*/ 
\newline 
dyadic  = {plus} plus|
\newline 
{minus} minus |
\newline 
{identifier} identifier|
\newline 
{exp}exponentiate|
\newline 
 {times} times |
\newline 
 {divide}  divide|
\newline 
{replicate} replicate|
\newline 
 {lt}lt|
\newline 
 {gt}gt|
\newline 
 {call}call|
\newline 
{le}le|
\newline 
{ge}ge|
\newline 
{eq}equals|
\newline 
{ne}ne|
\newline 
{min}min|{max}max|
\newline 
{push}push|
\newline 
{subscript}subscript|
\newline 
{satplus}satplus|
\newline 
{satmult}satmult|
\newline 
{satminus}satminus|
\newline 
{shl}shl|
\newline 
{shr}shr|
\newline 
             {remainder} remainder|
\newline 
             {or}or|
\newline 
             {and}and|
\newline 
             {xor}xor;
\newline 
monadic={not}not|{full}full|{empty}empty|{pop}pop|{sin}sin|
\newline 
{trunc}trunc|{round}round|{float}float| {extend}extend|
\newline 
{cos}cos|{tan}tan|{abs}abs|{sqrt}sqrt |{ln}ln;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsection

register declaration 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
registerdecl= reservation reg aggregate type identifier assembles sbra string sket  ;
\newline 
reservation = {reserved}reserved|{unreserved}; 
\newline 

\newline 
aliasdecl =
\newline 
alias reg aggregate type
\newline 
          [child]:identifier equals [parent]:identifier bra [lowbit]:intlit colon [highbit]:intlit ket
\newline 
          assembles sbra string sket;
\newline 
 
\newline 
opdecl = operation identifier means operator assembles sbra string sket;
\newline 
operator = {plus}plus|
\newline 
{minus}minus|
\newline 
{times}times|
\newline 
{lt}lt|
\newline 
{gt}gt|
\newline 
{min}min|
\newline 
{max}max|
\newline 
{shl}shl|
\newline 
{shr}shr|
\newline 
 {le}le|
\newline 
{ge}ge|
\newline 
{eq}equals|
\newline 
{ne}ne|
\newline 
{divide} divide|
\newline 
           {remainder}remainder|
\newline 
{or}or|
\newline 
{and}and|
\newline 
{xor}xor;
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 
\layout Subsection

pattern declarations
\begin_inset LatexCommand \label{sub:pattern-declarations}

\end_inset 


\layout Standard


\begin_inset ERT
status Open

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
assign =  refval store value ;
\newline 
meaning = {value}value|
\newline 
{assign}assign|
\newline 
{goto}goto value|
\newline 
{fail}fail value|
\newline 
{if}if bra value ket meaning|
\newline 
{for} for refval store [start]:value to [stop]:value step [increment]:value do meaning|
\newline 
  {loc}location value;
\newline 
patterndecl = pattern identifier paramlist means sbra meaning sket assemblesto sideeffects precond
\newline 
               |
\newline 
              {alternatives} pattern identifier means sbra alternatives sket;
\newline 

\newline 
paramlist = bra param paramtail* ket|{nullparam}bra ket;
\newline 
param = typeid identifier|{typeparam} typetoken identifier|{label}label identifier;
\newline 
typeid = identifier;
\newline 
paramtail = comma param;
\newline 
alternatives = type alts*; 
\newline 
alts = vbar type;
\newline 
precond = precondition sbra condition sket|{unconditional};
\newline 
asideeffect=   sideeffect  returnval;
\newline 
sideeffects = asideeffect*;
\newline 
assemblesto=assembles sbra assemblypattern sket;
\newline 
assemblypattern = assemblertoken*;
\newline 
assemblertoken = {string} string | {identifier} identifier;
\newline 
returnval = returns identifier;
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 statements 
\begin_inset ERT
status Open

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
statement = {aliasdecl} aliasdecl|
\newline 
            {registerdecl} registerdecl |    
\newline 
{addressmode} address patterndecl|
\newline 
{instructionformat}procedure patterndecl|
\newline 
{opdecl}opdecl|
\newline 
{flag} flag identifier equals intlit| 
\newline 
{typerename}typetoken predeclaredtype     equals identifier|
\newline 
{patterndecl} patterndecl;
\newline 
statementlist = statement semicolon statements*;
\newline 
statements =  statement  semicolon;
\newline 

\newline 

\newline 
// 
\backslash 
end{verbatim}
\end_inset 


\layout Section

Example ILCG machine description 
\begin_inset LatexCommand \label{sec:Example-ILCG-machine}

\end_inset 


\layout Standard

Basic IA32 processor description in ilcg copyright(c) Paul Cockshott, University
 of Glasgow Feb 2000.
\layout Standard

This is derived from the include file i386base.m4.
 It contains the declarations of the registers and instruction patterns
 of the 80386 architecture that have been inherited by subsequent processors
 made by Intel and AMD.
 
\layout Subsection

Declare types to correspond to internal ilcg types 
\layout Standard

This maps the internal ilcg types to the syntax used for them by the Nasm
 assembler.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 

\newline 
type word=DWORD;
\newline 
type uint32=DWORD;
\newline 
type int32=DWORD;
\newline 
type ieee64=QWORD;
\newline 
type int64=QWORD;
\newline 
type octet=BYTE;
\newline 
type uint8=BYTE; 
\newline 
type int16=WORD;
\newline 
type int8=BYTE;
\newline 
type ieee32=DWORD;
\newline 
type halfword=WORD;
\newline 

\newline 
/* 
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

compiler configuration flags 
\layout Standard

If this is set to 0 then the compiler will plant real literals in the data
 segment rather than attempting to generate them as part of an instruction
 field.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
flag realLitSupported = 0;
\newline 
/* 
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Register declarations
\layout Standard

We first declare the 32 bit registers of the processor, giving them the
 type of a 32 bit signed integer.
 This is the most frequent use of the registers.
 
\layout Standard

The stack pointer is declared as reserved to prevent the register allocator
 using it in expressions.
 The EBP register is declared to be the frame pointer.
 The frame pointer is reserved by default.
 It is the only register that the compiler needs to know about as it uses
 it to locate local variables.
 Aliasing the FP register to the EBP register ensures that on the intel
 processors, EBP is used for variable access.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
register int32 EAX assembles['eax'] ;
\newline 
register int32 ECX assembles['ecx'] ;
\newline 
register int32 EBX assembles['ebx'] ;
\newline 
register word EBP assembles['ebp'] ;
\newline 
alias register word FP = EBP(0:31) assembles ['ebp'];
\newline 
reserved register word ESP assembles['esp'];
\newline 
register int32 ESI assembles['esi'] ;
\newline 
register int32 EDI assembles['edi'] ;
\newline 
register int32 EDX assembles['edx'];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 We now redeclare the unreserved registers as unsigned variables aliased
 to the same state bits to allow them to hold unsigned integers.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
alias register uint32 uax= EAX (0:31) assembles ['eax'] ;
\newline 
alias register uint32 ucx= ECX (0:31) assembles ['ecx'] ;
\newline 
alias register uint32 ubx= EBX (0:31) assembles ['ebx'] ;
\newline 
alias register uint32 usi= ESI (0:31) assembles ['esi'] ;
\newline 
alias register uint32 udi= EDI (0:31) assembles ['edi'] ;
\newline 
alias register uint32 udx= EDX (0:31) assembles ['edx'];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Standard

The intel architecture allows portions of some of the registers to be used
 to operate on 8 bit quantities.
 We declare a set of registers aliased to these locations, some of which
 are used to hold signed bytes and some to hold unsigned bytes.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 

\newline 

\newline 
/* use these for signed 8 bit values */
\newline 
 alias register int8 AL = EAX(0:7) assembles['al']; 
\newline 
 alias register int8 BL = EBX(0:7) assembles['bl'];
\newline 
 alias register int8 CL = ECX(0:7) assembles['cl'];
\newline 
 alias register int8 DL = EDX(0:7) assembles['dl'];
\newline 
/* use these for unsigned 8 bit values */
\newline 

\newline 
 alias register uint8 BH = EBX(8:15) assembles['bh'];
\newline 
 alias register uint8 CH = ECX(8:15) assembles['ch'];
\newline 
 alias register uint8 DH = EDX(8:15) assembles['dh'];
\newline 
 alias register uint8 uAL = EAX(0:7) assembles['al']; 
\newline 
 alias register uint8 uBL = EBX(0:7) assembles['bl'];
\newline 
 alias register uint8 uCL = ECX(0:7) assembles['cl'];
\newline 
 alias register uint8 uDL = EDX(0:7) assembles['dl'];
\newline 
 
\newline 
/* use these for untyped 8 bit values */
\newline 
 alias register octet oAL = EAX(0:7) assembles['al']; 
\newline 
 alias register octet oBL = EBX(0:7) assembles['bl'];
\newline 
 alias register octet oCL = ECX(0:7) assembles['cl'];
\newline 
 alias register octet oDL = EDX(0:7) assembles['dl'];
\newline 

\newline 
/* use these for 16 bit values */
\newline 
 alias register int16 AX =EAX(0:15)assembles['ax'];
\newline 
 alias register int16 BX =EBX(0:15)assembles['bx'];
\newline 
 alias register int16 DX =EDX(0:15)assembles['dx'];
\newline 
 alias register int16 CX =ECX(0:15)assembles['cx'];
\newline 
 alias register halfword SI = ESI(0:15)assembles['si'];
\newline 
 alias register halfword DI = EDI(0:15)assembles['di'];
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 We declare a stack which is used as the destination of push instructions.
 The depth of the stack is notional, obviously in practice one could use
 more, it is just declared deep enough for any practical compile time expression.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 

\newline 
register stack(4096)int32 mainSTACK assembles[ 'mainSTACK']; 
\newline 
 /* 
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Register sets 
\layout Standard

There are several intersecting sets of registers defined for different instructi
ons.
 Note that the ECX and CL,CH registers are named last in their lists to
 increase the chance that they are free for sepecial instructions that need
 them.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern indexreg means[EDI|ESI|EBX|EBP|ESP|EAX|EDX|ECX];
\newline 
pattern accumulators means[EAX|EDX|ECX|EBX];
\newline 
pattern ireg means [ indexreg] ;
\newline 
pattern ureg means [EBP| ubx|udi|usi|udx|ESP|ucx|uax ] ;
\newline 

\newline 
pattern reg means [ireg|ureg];
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 Note that the order of the byte registers is chosen to keep the ah and
 al regs free for instructions that require them specifically, particularly
 conditional expressions on the floating point stack, that return boolean
 results in al 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
pattern bireg means[ BL|DL|AL|CL];
\newline 
pattern bureg means[BH|DH|uAL|uBL|uDL|uCL|CH];
\newline 
pattern boreg means[oBL|oAL|oDL|oCL];
\newline 
pattern breg means[bireg|bureg|boreg];
\newline 
pattern wreg means[BX|CX|DX|AX|SI|DI];
\newline 
pattern pushreg means[reg|wreg]; /* these are directly pushable */
\newline 
pattern anyreg means[ breg|wreg|reg];
\newline 
pattern signedreg means[bireg|ireg|wreg];
\newline 
pattern unsignedreg means[bureg|ureg|wreg];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 The intel architecture contains a number of instructions inherited from
 the early 16 bit microprocessor, the 8086 which were non-orthogonal with
 respect to registers.
 In order to use these instructions particular register sets are defined
 that are used only in a few instructions.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
pattern acc means[EAX];
\newline 
pattern dacc means[EDX];
\newline 
pattern wacc means[AX];
\newline 
pattern bacc means[AL];
\newline 
pattern bnonacc means[BL|CL|DL];
\newline 
pattern ebxacc means[EBX];
\newline 
pattern ebxbacc means[BL];
\newline 
pattern ecxacc means[ECX];
\newline 
pattern ecxbacc means[CL];
\newline 
pattern modreg means [ECX];
\newline 
pattern sourcereg means [ESI];
\newline 
pattern destreg means [EDI];
\newline 
pattern countreg means [ECX];
\newline 
pattern shiftcountreg means [ecxbacc|ecxacc];
\newline 

\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Operator definition
\layout Standard

This section defines operations that can be used to parameterise functions.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 

\newline 
*/
\newline 
operation add means + assembles [ 'add'];
\newline 
operation and means AND assembles[ 'and'];
\newline 
operation or means OR assembles['or'];
\newline 
operation xor means XOR assembles['xor'];/* */
\newline 
operation sub means - assembles [ 'sub']; 
\newline 
operation mul means * assembles ['mul'];
\newline 
operation imul means * assembles ['imul '];
\newline 
operation bel means < assembles ['b'];
\newline 
operation lt means < assembles ['l'];
\newline 
operation ab means > assembles ['a'];
\newline 
operation gt means > assembles ['g'];
\newline 
operation eq means = assembles ['z'];
\newline 
operation be means <= assembles ['be'];
\newline 
operation le means <= assembles ['le'];
\newline 
operation ae means >= assembles ['ae'];
\newline 
operation ge means >= assembles ['ge'];
\newline 
operation ne means <> assembles ['nz'];
\newline 
operation shiftleft means << assembles ['l'];
\newline 
operation shiftright means >> assembles ['r'];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 The intel assembly language uses different mnemonics to control jumps on
 comparisions of signed and unsigned quantities.
 That is why the comparison operators are multiply defined above.
 The two families of comparision operations are grouped as conditions and
 unsigned conditions below.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
pattern condition means[ne|ge|le|eq|gt|lt];
\newline 
pattern unsignedcondition means[ne|ae|be|eq|ab|bel];
\newline 
pattern operator means[add | sub|imul|and|or|xor];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 

 The multiplication operator can only have a register as a destination,
 whereas other arithmetic instructions can have a memory location.
 Thus the there need to be different classes of operators for these different
 addressing forms of the instructions.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
pattern nonmultoperator means[add|sub|and|or|xor];
\newline 
pattern saddoperator means[add|imul|and|or|xor];
\newline 
pattern shiftop means [shiftleft|shiftright];
\newline 

\newline 
/*
\newline 

\newline 

\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Data formats
\layout Standard

Here we define ilcg symbols for the types that can be used as part of instructio
ns.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern unsigned means[uint32|uint8|uint16];
\newline 
pattern signed means[ int8 | int16|int32 ];
\newline 
pattern int means[ int8 | int16 |int32| uint32|uint8|uint16];
\newline 
pattern double means[ieee64] ;
\newline 
pattern float means[ieee32];
\newline 
pattern real means [ieee64|float];
\newline 
pattern byte means[uint8|int8|octet];
\newline 
pattern word32 means[int32|uint32|word];
\newline 
pattern word16 means[int16|uint16|halfword];
\newline 
pattern wordupto32 means[byte|word16|word32];
\newline 
pattern dataformat means[octet|word];
\newline 
pattern longint means [int32|uint32];
\newline 
pattern hiint means[int32|int64|int16];
\newline 
/*
\newline 

\backslash 
end{verbatim}
\end_inset 

 Some integers are special in the sense that the addressing modes allow
 scaled index addressing that multiplies a register by 2, 4, or 8.
 These are thus declared under the pattern scale.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern two(type t)means[2] assembles['2'];
\newline 
pattern four(type t)means[4] assembles['4'];
\newline 
pattern eight(type t)means[8] assembles['8'];
\newline 
pattern scale means[two|four|eight];
\newline 

\newline 
/* 
\backslash 
end{verbatim}
\end_inset 


\layout Standard

Define the address forms used in lea instructions these differ from the
 address forms used in other instructions as the semantics includes no memory
 reference.
 Also of course register and immediate modes are not present.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim} */
\newline 
pattern labelf(label l)
\newline 
 means [l]
\newline 
 assembles[l];
\newline 
pattern labelconstf(label l,signed s)
\newline 
 means [+(l,const s)]
\newline 
 assembles[l'+'s];
\newline 
pattern constf(signed s)
\newline 
 means[const s]
\newline 
 assembles [s];
\newline 
pattern offset means[constf|labelf|labelconstf];
\newline 
pattern regindirf(reg r) 
\newline 
 means[^(r) ]
\newline 
 assembles[ r ];
\newline 

\newline 
pattern baseminusoffsetf(reg r, offset s ) 
\newline 
 means[-( ^(r) , s)] 
\newline 
 assembles[ r '-(' s ')']; 
\newline 
pattern baseplusoffsetf(reg r, offset s )
\newline 
 means[+( ^(r) , s)]
\newline 
 assembles[ r '+' s ];
\newline 
pattern scaledIndexPlusOffsetf(reg r1, scale s, offset offs)
\newline 
 means[+(*(^(r1),s), offs)]
\newline 
 assembles[r1 '*' s '+' offs];
\newline 
address pattern basePlusScaledIndexf(reg r1,reg r2,scale s)
\newline 
 means[+(^(r1),*(^(r2),s))]
\newline 
 assembles[ r1 '+' r2 '*' s ];
\newline 
address pattern basePlusScaledIndexPlusOffsetf(reg r1,reg r2,
\newline 
 scale s,offset off,longint t)
\newline 
 means[+((t)+(^(r1), off),*(^(r2),s) )]
\newline 
 assembles[ r1 '+' r2 '*' s '+'off ];
\newline 
address pattern basePlusIndexPlusOffsetf(reg r1,reg r2,offset off)
\newline 
 means[+(^(r1),+(^(r2), off))]
\newline 
 assembles[ r1 '+' r2 ' +'off ];
\newline 
address pattern basePlusIndexf(reg r1,reg r2)
\newline 
 means [+(^(r1),^(r2))]
\newline 
 assembles[ r1 '+' r2 ];
\newline 
pattern directf(unsigned s) 
\newline 
 means[const s] 
\newline 
 assembles[ s ];
\newline 

\newline 
 
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Choice of effective address
\layout Standard

This contains the useful formats for the load effective address instruction.
 The pattern regindirf is excluded here as it adds nothing we do not have
 already from mov instructions.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern uncasteaform means[directf |
\newline 
 labelf| labelconstf|
\newline 
 basePlusScaledIndexPlusOffsetf| 
\newline 
 baseplusoffsetf | 
\newline 
 basePlusIndexf
\newline 
 /* dont use the rest as they are rarely useful and 
\newline 
 slow the code generator
\newline 
 |basePlusScaledIndexf| 
\newline 
 scaledIndexPlusOffsetf| 
\newline 
 baseminusoffsetf|
\newline 
 basePlusIndexPlusOffsetf */
\newline 
];
\newline 
 /* allow the address expression to be cast to an integer */
\newline 
pattern eaform(uncasteaform f,longint t) 
\newline 
 means[(t)f]
\newline 
 assembles[f];
\newline 
/*
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Formats for all memory addresses
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}*/
\newline 
pattern addrform means[eaform|regindirf];
\newline 
/* 
\backslash 
end{verbatim}
\end_inset 

 define the address patterns used in other instructions 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern maddrmode(addrform f) means[mem(f) ] 
\newline 
 assembles[ '[' f ']' ];
\newline 
pattern immediate(signed s)means [const s] 
\newline 
 assembles [s]; 
\newline 
pattern intimmediate(int s)means [const s] 
\newline 
 assembles [s];
\newline 
pattern jumpmode means[labelf|maddrmode];
\newline 
pattern addrmode means[maddrmode|anyreg];
\newline 
pattern baddrmode means[maddrmode|breg];
\newline 
pattern waddrmode means[maddrmode|reg];
\newline 
pattern regshift(shiftcountreg r)means[^(r)] assembles['cl'];
\newline 
pattern shiftcount means[immediate|regshift];
\newline 
pattern regaddrop(addrmode r)means[^(r)] assembles[r];
\newline 
pattern regaddrimmediate means[intimmediate|maddrmode|regaddrop];
\newline 
/* 
\backslash 
end{verbatim}
\end_inset 


\layout Subsection

Instruction patterns for the 386
\layout Subsubsection

Stack operations 
\layout Standard

These are real instructions and also short sequences of instructios that
 perform operations on the stack.
 One should define sufficient instructions for a complete reverse polish
 machine here, since the code generators automatically produced from ILCG
 will not necessarily have register spilling enabled.
 If that is not enabled and an expression is more complex than can be handled
 by the available registers, the pattern matcher can fall back on generating
 reverse polish stack code for complex expressions.
 
\layout Standard

The stack operations that operate on the top elements of the stack should
 leave registers unchanged.
 Thus there is a certain amount of register pushing and exchanging in these
 sequences.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 

\newline 
instruction pattern STACKSTORE(reg r1 )
\newline 
 means[(ref int32)mem(POP(mainSTACK)):=^(r1)]
\newline 
 assembles['xchg DWORD[esp],'r1'
\backslash 
n'
\newline 
' pop DWORD['r1']
\backslash 
n'
\newline 
' pop 'r1];
\newline 

\newline 
instruction pattern STACKWSTORE(wreg r1 )
\newline 
 means[(ref halfword)mem(POP(mainSTACK)):=^(r1)]
\newline 
 assembles['xchg DWORD[esp],esi
\backslash 
n'
\newline 
' mov word[esi],'r1'
\backslash 
n'
\newline 
' pop esi'];
\newline 

\newline 
instruction pattern STACKBSTORE(breg r1 )
\newline 
 means[(ref octet)mem(POP(mainSTACK)):=^(r1)]
\newline 
 assembles['xchg DWORD[esp],esi
\backslash 
n'
\newline 
' mov BYTE[esi],'r1'
\backslash 
n'
\newline 
' pop esi'];
\newline 

\newline 
instruction pattern SMLIT( nonmultoperator op,offset s) 
\newline 
 means[ PUSH(mainSTACK,(int32)op( POP(mainSTACK), s))] 
\newline 
 assembles[op ' DWORD[esp] ,' s];
\newline 

\newline 
instruction pattern SMULIT( nonmultoperator op,offset s) 
\newline 
 means[ PUSH(mainSTACK,(int32)*( POP(mainSTACK), s))] 
\newline 
 assembles['xchg eax,DWORD[esp]
\backslash 
n'
\newline 
 ' imul eax ,' s'
\backslash 
n'
\newline 
 ' xchg eax,DWORD[esp]' ];
\newline 

\newline 
instruction pattern SADD(saddoperator op)
\newline 
 means [PUSH(mainSTACK,(longint)+(POP(mainSTACK),POP(mainSTACK)))]
\newline 
 assembles['xchg eax,DWORD[esp]
\backslash 
n'
\newline 
' add DWORD[esp+4],eax
\backslash 
n'
\newline 
' pop eax']; 
\newline 

\newline 
instruction pattern SOP(saddoperator op)
\newline 
 means [PUSH(mainSTACK,
\newline 
             (longint)op(POP(mainSTACK),POP(mainSTACK)))]
\newline 
 assembles['xchg eax,DWORD[esp]
\backslash 
n'
\newline 
' '
\newline 
 op' eax,DWORD[esp+4]
\backslash 
n'
\newline 
 ' mov DWORD[esp+4],eax
\backslash 
n'
\newline 
 ' pop eax'];
\newline 

\newline 
instruction pattern SMR( nonmultoperator op,reg r1) 
\newline 
 means[ PUSH(mainSTACK,(int32)op( POP(mainSTACK),^( r1)))] 
\newline 
 assembles[op ' DWORD[esp] ,' r1]; 
\newline 

\newline 
instruction pattern BSMR( nonmultoperator op,breg r1) 
\newline 
 means[ PUSH(mainSTACK,(octet)op( POP(mainSTACK),^( r1)))] 
\newline 
 assembles[op ' byte[esp] ,' r1]; 
\newline 

\newline 
instruction pattern SMRADD( reg r1) 
\newline 
 means[ r1:=(int32)+( POP(mainSTACK),^( r1))] 
\newline 
 assembles['add 'r1',DWORD[esp] 
\backslash 
n'
\newline 
' add esp,4']; 
\newline 

\newline 
instruction pattern SMRP( nonmultoperator op,reg r1,type t) 
\newline 
 means[ PUSH(mainSTACK,(ref t)op( POP(mainSTACK),^(r1)))] 
\newline 
 assembles[op ' DWORD[esp] ,' r1]; 
\newline 

\newline 
instruction pattern RPUSH(pushreg r) 
\newline 
 means[PUSH(mainSTACK,^(r))] 
\newline 
 assembles['push ' r]; 
\newline 

\newline 
instruction pattern RPOP(pushreg r,type t) 
\newline 
 means[(ref t)r:=(t)POP(mainSTACK)] 
\newline 
 assembles['pop ' r]; 
\newline 

\newline 
instruction pattern BPUSH(bureg r) 
\newline 
 means[PUSH(mainSTACK,^(r))] 
\newline 
 assembles['push 0
\backslash 
n'
\newline 
' mov BYTE[esp],'r];
\newline 

\newline 
instruction pattern BSPUSH(baddrmode r)
\newline 
 means[PUSH(mainSTACK,(int8)^(r))]
\newline 
 assembles['push esi
\backslash 
n'
\newline 
' movsx esi,'r'
\backslash 
n'
\newline 
' xchg esi,[esp]'];
\newline 

\newline 
instruction pattern BSPOP(bireg r)
\newline 
 means[r:=POP(mainSTACK)]
\newline 
 assembles['mov ' r',BYTE[esp]
\backslash 
n'
\newline 
' add esp,4']; 
\newline 

\newline 
instruction pattern BPOP(bureg r) 
\newline 
 means[r:=POP(mainSTACK)] 
\newline 
 assembles['mov ' r',BYTE[esp]
\backslash 
n'
\newline 
' add esp,4']; 
\newline 

\newline 
instruction pattern REFPOP(addrmode r,type t) 
\newline 
 means[(ref ref t)r:=POP(mainSTACK)] 
\newline 
 assembles['pop DWORD ' r];
\newline 

\newline 
instruction pattern MEMPOP(maddrmode m)
\newline 
 means[(ref int32)m:=POP(mainSTACK)]
\newline 
 assembles['pop DWORD 'm]; 
\newline 

\newline 
instruction pattern LITPUSH(offset s) 
\newline 
 means[PUSH(mainSTACK, s)] 
\newline 
 assembles['push DWORD ' s];
\newline 

\newline 
instruction pattern MEMPUSH(maddrmode m) 
\newline 
 means[PUSH(mainSTACK,(int32)^((ref int32)m))] 
\newline 
 assembles['push DWORD ' m]; 
\newline 

\newline 
instruction pattern DMEMPUSH(eaform ea) 
\newline 
 means[PUSH(mainSTACK,(doubleword)^((ref doubleword)mem(ea)))] 
\newline 
 assembles['push DWORD['ea'+4]
\backslash 
n'
\newline 
' push DWORD['ea']']; 
\newline 

\newline 
instruction pattern STACKLOAD(word32 t)
\newline 
 means[PUSH(mainSTACK,^((ref t)mem(POP(mainSTACK))))]
\newline 
 assembles['xchg DWORD[esp],eax'
\newline 
 '
\backslash 
n'
\newline 
' mov eax,DWORD[eax]'
\newline 
 '
\backslash 
n'
\newline 
' xchg DWORD[esp],eax'];
\newline 

\newline 
instruction pattern REFPUSH(maddrmode m,type t) 
\newline 
 means[PUSH(mainSTACK,(ref t)^(m))] 
\newline 
 assembles['push DWORD ' m]; 
\newline 

\newline 
instruction pattern SDEREF(int t)
\newline 
 means[PUSH(mainSTACK,(t)^(mem(POP(mainSTACK))))]
\newline 
 assembles['xchg esi,[esp]
\backslash 
n'
\newline 
' mov esi,dword[esi]
\backslash 
n'
\newline 
' xchg esi,[esp]'];
\newline 

\newline 
instruction pattern SDEREFDOUBLEWORD(int t)
\newline 
 means[PUSH(mainSTACK,(doubleword)^(mem(POP(mainSTACK))))]
\newline 
 assembles['xchg esi,[esp]
\backslash 
n'
\newline 
 ' push dword[esi]
\backslash 
n'
\newline 
 ' mov esi,dword[esi+4]
\backslash 
n'
\newline 
 ' xchg esi,[esp]'];
\newline 

\newline 
/* 
\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Data movement to and from registers 
\layout Standard

The select pattern is desingned to be used in conditional expressions.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 

\newline 
instruction pattern SELECT(reg r1,reg r2,addrmode r3,wordupto32 t)
\newline 
 means[(ref t) r1:=
\newline 
              OR(AND((t)^(r1),(t)^(r2)),AND((t)^(r3),NOT(^(r2))))]
\newline 
 assembles[
\newline 
 'and 'r1 ','r2 '
\backslash 
n'
\newline 
 'not 'r2 '
\backslash 
n'
\newline 
 'and 'r2 ',' t ' 'r3 '
\backslash 
n'
\newline 
 'or 'r1 ',' r2];
\newline 

\newline 
instruction pattern LOAD(maddrmode rm, anyreg r1, wordupto32 t) 
\newline 
 means[ (ref t) r1:= (t)^(rm )] 
\newline 
 assembles['mov ' r1 ',' t ' ' rm]; 
\newline 

\newline 
instruction pattern MOVZXB(reg r1, baddrmode rm) 
\newline 
 means[ r1:=(uint32)EXTEND( (uint8)^( rm) )]
\newline 
 assembles['movzx ' r1 ', BYTE 'rm]; 
\newline 

\newline 
instruction pattern MOVZXB2(reg r1, baddrmode rm) 
\newline 
 means[ r1:=(int32)EXTEND( (uint8)^( rm) )]
\newline 
 assembles['movzx ' r1 ', BYTE 'rm]; 
\newline 

\newline 
instruction pattern MOVSXB(reg r1,baddrmode rm) 
\newline 
 means[r1:=(int32)EXTEND( (int8)^( rm) )]
\newline 
 assembles['movsx 'r1',BYTE 'rm]; 
\newline 

\newline 
instruction pattern MOVZXW(reg r1, wreg rm) 
\newline 
 means[ r1:=(uint32)EXTEND(^(rm))]
\newline 
 assembles['movzx ' r1 ', 'rm]; 
\newline 

\newline 
instruction pattern MOVSXW(reg r1, wreg rm) 
\newline 
 means[ r1:=(int32)EXTEND(^(rm))]
\newline 
 assembles['movsx ' r1 ', 'rm]; 
\newline 

\newline 
instruction pattern ToBYTE(reg r, breg b)
\newline 
 means[b:= (octet) ^( r)]
\newline 
 assembles['push ' r '
\backslash 
nmov ' b ',BYTE[esp]
\backslash 
nadd esp,4 ' ];
\newline 

\newline 
instruction pattern STOREBR(maddrmode rm, breg r1)
\newline 
 means[ (ref octet ) rm:= ^(r1) ]
\newline 
 assembles['mov BYTE 'rm',' r1];
\newline 

\newline 
instruction pattern STORER(maddrmode rm, reg r1, word32 t)
\newline 
 means[ (ref t) rm:= ^( r1) ]
\newline 
 assembles['mov ' t ' 'rm',' r1];
\newline 

\newline 
instruction pattern STOREWR(maddrmode rm, wreg r1, word16 t)
\newline 
 means[ (ref t) rm:= ^( r1) ]
\newline 
 assembles['mov ' t ' 'rm',' r1];
\newline 

\newline 
instruction pattern NULMOV(reg r3, type t)
\newline 
 means[(ref t)r3:=^((ref t)r3)]
\newline 
 assembles[';nulmov ' r3 r3];
\newline 

\newline 
instruction pattern STORELIT(addrmode rm, type t, int s)
\newline 
 means[ (ref t) rm:= (t)const s ]
\newline 
 assembles['mov ' t ' 'rm ',' ' ' s];
\newline 

\newline 
instruction pattern CLEARREG(reg rm, type t, int s)
\newline 
 means[ (ref t) rm:= (t)0 ]
\newline 
 assembles['xor ' rm ',' rm];
\newline 
/*
\newline 

\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Register to register arithmetic 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/ 
\newline 

\newline 
instruction pattern RMLIT(nonmultoperator op,
\newline 
                          addrmode rm, type t, offset sm)
\newline 
 means[ (ref t) rm:= op(^(rm),(t) sm) ]
\newline 
 assembles[op ' ' t ' ' rm ',' sm];
\newline 

\newline 
instruction pattern INC(addrmode rm,int t)
\newline 
 means[(ref t)rm:= + (^(rm),1)]
\newline 
 assembles['inc ' t ' ' rm];
\newline 

\newline 
instruction pattern DEC(addrmode rm,int t)
\newline 
 means[(ref t)rm:= - ((t)^(rm),1)]
\newline 
 assembles['dec ' t ' ' rm];
\newline 

\newline 
instruction pattern SHIFT(shiftop op, 
\newline 
                         shiftcount s, anyreg r,type t)
\newline 
 means[(ref t) r:= (t)op(^(r),s)]
\newline 
 assembles['sh' op' ' r ', 's]; 
\newline 

\newline 
instruction pattern RMR( nonmultoperator op,
\newline 
                         addrmode rm,anyreg r1,wordupto32 t)
\newline 
 means[ (ref t) rm :=op((t) ^( rm),(t)^( r1))]
\newline 
 assembles[op ' ' t ' ' rm ',' r1]; 
\newline 

\newline 
instruction pattern RMRB( nonmultoperator op,
\newline 
                          addrmode rm,breg r1,byte t)
\newline 
 means[ (ref t) rm :=op((t) ^( rm),(t)^( r1))]
\newline 
 assembles[op ' ' t ' ' rm ',' r1]; 
\newline 

\newline 
instruction pattern ADDUSB(addrmode fm,breg r1,breg rm)
\newline 
 means[ rm:= +:((uint8)^(rm),^(r1))]
\newline 
 assembles[ 'add ' rm ',' r1 '
\backslash 
n'
\newline 
' jnc $+4
\backslash 
n'
\newline 
' mov ' rm',255
\backslash 
n'
\newline 
' nop
\backslash 
n'
\newline 
' nop']; 
\newline 

\newline 
instruction pattern SUBUSB(breg r1,breg rm)
\newline 
 means[ rm:= -:((uint8)^(rm),^(r1))]
\newline 
 assembles[ 'sub ' rm ',' r1 '
\backslash 
n'
\newline 
' jnc $+4
\backslash 
n'
\newline 
' mov ' rm',0
\backslash 
n'
\newline 
' nop
\backslash 
n'
\newline 
' nop'];
\newline 

\newline 
instruction pattern ADDSSB(breg r1,breg rm)
\newline 
 means[ rm:=(int8) +:((int8)^(rm),^(r1))]
\newline 
 assembles[ 'add ' rm ',' r1 '
\backslash 
n'
\newline 
' jno $+10
\backslash 
n'
\newline 
' jg $+6
\backslash 
n'
\newline 
' mov 'rm' ,-128 
\backslash 
n'
\newline 
' jng $+4
\backslash 
n'
\newline 
' mov ' rm',127
\backslash 
n'
\newline 
' '];
\newline 

\newline 
instruction pattern MULTSSB(bacc r1,bnonacc r2)
\newline 
 means[r2:=*:(^(r1),^(r2))]
\newline 
 assembles['imul 'r2'
\backslash 
n'
\newline 
' shr ax,7
\backslash 
n'
\newline 
' mov 'r2',al'];
\newline 

\newline 
instruction pattern MULTSSBAL(bacc r1,bnonacc r2)
\newline 
 means[r1:=*:(^(r1),^(r2))]
\newline 
 assembles['imul 'r2'
\backslash 
n'
\newline 
' shr ax,7'];
\newline 

\newline 

\newline 
instruction pattern SUBSSB(addrmode fm,breg r1,breg rm)
\newline 
 means[ rm:= (int8)-:((int8)^(rm),^(r1))]
\newline 
 assembles[ 'sub ' rm ',' r1 '
\backslash 
n'
\newline 
' jno $+10
\backslash 
n'
\newline 
' jg $+6
\backslash 
n'
\newline 
' mov 'rm' ,-128 
\backslash 
n'
\newline 
' jng $+4
\backslash 
n'
\newline 
' mov ' rm',127
\backslash 
n'
\newline 
' nop
\backslash 
n'
\newline 
' nop'];
\newline 

\newline 
instruction pattern UINT8MAX(breg r1,breg r2)
\newline 
 means[ (ref uint8)r1:=MAX((uint8)^(r1),^(r2))]
\newline 
 assembles['cmp 'r1','r2'
\backslash 
n'
\newline 
' ja $+4
\backslash 
n'
\newline 
' mov 'r1','r2];
\newline 

\newline 
instruction pattern UINT8MIN(breg r1,breg r2)
\newline 
 means[ (ref uint8)r1:=MIN((uint8)^(r1),^(r2))]
\newline 
 assembles['cmp 'r1','r2'
\backslash 
n'
\newline 
' jna $+4
\backslash 
n'
\newline 
' mov 'r1','r2];
\newline 

\newline 
instruction pattern INT8MAX(breg r1,breg r2)
\newline 
 means[ (ref int8)r1:=MAX((int8)^(r1),^(r2))]
\newline 
 assembles['cmp 'r1','r2'
\backslash 
n'
\newline 
' jg $+4
\backslash 
n'
\newline 
' mov 'r1','r2];
\newline 

\newline 
instruction pattern INT8MIN(breg r1,breg r2)
\newline 
 means[ (ref int8)r1:=MIN((int8)^(r1),^(r2))]
\newline 
 assembles['cmp 'r1','r2'
\backslash 
n'
\newline 
' jl $+4
\backslash 
n'
\newline 
' mov 'r1','r2];
\newline 

\newline 
instruction pattern LEA(reg r1, eaform ea)
\newline 
 means [r1:=ea]
\newline 
 assembles ['lea ' r1 ',[' ea ']' ];
\newline 

\newline 
instruction pattern NOTOP(addrmode rm, type t)
\newline 
 means[(ref t)rm:= NOT((t)^(rm))]
\newline 
 assembles['not 't ' ' rm];
\newline 

\newline 
instruction pattern Negate(anyreg r1,type t)
\newline 
 means[(ref t)r1:= -((t)0,( t)^(r1))]
\newline 
 assembles ['neg ' ' ' r1];
\newline 

\newline 
instruction pattern MNegate(anyreg r1,type t)
\newline 
 means[(ref t)r1:= *((t)-1,( t)^(r1))]
\newline 
 assembles ['neg ' ' ' r1];
\newline 

\newline 
instruction pattern RLIT(operator op,
\newline 
                         pushreg r0, type t, signed sm)
\newline 
 means[r0:= op(^( r0), const sm) ]
\newline 
 assembles[op ' ' r0 ',' sm];
\newline 

\newline 
instruction pattern RR( nonmultoperator op, 
\newline 
                        anyreg r1, anyreg r2, int t)
\newline 
 means[r1:=(t) op((t) ^( (ref t) r1),(t)^( (ref t) r2))]
\newline 
 assembles[op ' ' r1 ',' r2];
\newline 

\newline 
instruction pattern RRM(operator op, 
\newline 
                        pushreg r1, maddrmode rm, int t)
\newline 
 means [r1:=(t) op((t) ^(r1),(t)^( rm))]
\newline 
 assembles[op ' ' r1 ',' rm ] ;
\newline 

\newline 
/*
\newline 

\backslash 
end{verbatim}
\end_inset 

 The following instructions require the distinction between accumulator
 and non-accumulator 8 bit registers.
 This is because byte multiply and divide are inherited from the obsolete
 8086 instructions.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
pattern bnonacreg means[DH|DL|BH|BL|CH|CL];
\newline 
pattern baccreg means[AL];
\newline 
pattern baccregmode means[maddrmode|baccreg];
\newline 
pattern bnonacregmode means[maddrmode|bnonacreg];
\newline 

\newline 
instruction pattern fastBIDIV(baccreg r1,bnonacregmode r2)
\newline 
 means[r1:=div((int8)^(r1),(int8)^(r2))]
\newline 
 assembles[' movsx ax,'r1'
\backslash 
n'
\newline 
' idiv BYTE 'r2];
\newline 

\newline 
instruction pattern BIDIV(baccreg r1, 
\newline 
                          bnonacregmode r2,baccregmode r3)
\newline 
 means[r3:=div((int8)^(r1),(int8)^(r2))]
\newline 
 assembles[' movsx ax,'r1'
\backslash 
n'
\newline 
' idiv BYTE 'r2'
\backslash 
n'
\newline 
' mov BYTE 'r3',al'];
\newline 

\newline 
instruction pattern BIMUL(baccreg r1, bnonacreg r2)
\newline 
 means[r2:=*((int8)^(r1),(int8)^(r2))]
\newline 
 assembles['imul BYTE 'r2'
\backslash 
n'
\newline 
' mov BYTE 'r2',al'];
\newline 

\newline 
instruction pattern fastIMUL(acc a,dacc d)
\newline 
 means[(ref int32)a:=*((int32)^(a),^(d))]
\newline 
 assembles['imul edx'];
\newline 

\newline 
instruction pattern IDIV(acc r1,modreg r2)
\newline 
 means[PUSH(mainSTACK,div((int32)^(r1),^( r2))) ]
\newline 
 assembles['push edx
\backslash 
n'
\newline 
' cdq
\backslash 
n'
\newline 
' idiv ' r2 '
\backslash 
n'
\newline 
' xchg eax,DWORD[esp]
\backslash 
n'
\newline 
' xchg eax,edx'];
\newline 

\newline 
instruction pattern UDIV(acc r1,modreg r2)
\newline 
 means[PUSH(mainSTACK,div((uint32)^(r1),^( r2))) ]
\newline 
 assembles['push edx
\backslash 
n'
\newline 
' xor edx,edx
\backslash 
n'
\newline 
' div ' r2 '
\backslash 
n'
\newline 
' xchg eax,DWORD[esp]
\backslash 
n'
\newline 
' xchg eax,edx'];
\newline 

\newline 
instruction pattern IMULLIT(pushreg r1,addrmode rm, signed s)
\newline 
 means[(ref int32)r1:=*(^(rm),const s)]
\newline 
 assembles['imul 'r1',DWORD 'rm','s];
\newline 

\newline 
instruction pattern IMOD(acc r1, modreg r2)
\newline 
 means[PUSH(mainSTACK,MOD((int32)^(r1),^( r2))) ]
\newline 
 assembles['push edx
\backslash 
n'
\newline 
' cdq
\backslash 
n'
\newline 
' idiv ' r2 '
\backslash 
n'
\newline 
' xchg edx,DWORD[esp]'];
\newline 

\newline 
instruction pattern UMOD(acc r1, modreg r2)
\newline 
 means[PUSH(mainSTACK,MOD((uint32)^(r1),^( r2))) ]
\newline 
 assembles['push edx
\backslash 
n'
\newline 
' xor edx,edx
\backslash 
n'
\newline 
' div ' r2 '
\backslash 
n'
\newline 
' xchg edx,DWORD[esp]'];
\newline 

\newline 
instruction pattern BIMOD(baccreg r1, bnonacreg r2)
\newline 
 means[r2:=MOD((int8)^(r1),(int8)^(r2))]
\newline 
 assembles[' movsx ax,'r1'
\backslash 
n'
\newline 
' idiv 'r2'
\backslash 
n'
\newline 
' mov 'r2',ah'];
\newline 

\newline 

\newline 
instruction pattern MOD2(reg r)
\newline 
 means[r:=MOD(^(r),2)]
\newline 
 assembles['and 'r ',1'];
\newline 

\newline 
instruction pattern MOD4(reg r)
\newline 
 means[r:=MOD(^(r),4)]
\newline 
 assembles['and 'r ',3'];
\newline 

\newline 
instruction pattern MOD8(reg r)
\newline 
 means[r:=MOD(^(r),8)]
\newline 
 assembles['and 'r ',7'];
\newline 

\newline 
instruction pattern DIV8(ureg r)
\newline 
 means[r:=div((uint32)^(r),8)]
\newline 
 assembles['shr 'r ',3'];
\newline 

\newline 

\newline 
instruction pattern MOD16(reg r)
\newline 
 means[r:=MOD(^(r),16)]
\newline 
 assembles['and 'r ',15']; 
\newline 

\newline 
instruction pattern PLANT(label l)
\newline 
 means[l]
\newline 
 assembles[l ':']; 
\newline 

\newline 
instruction pattern PLANTRCONST( double r,type t)
\newline 
 means[loc (t)r]
\newline 
 assembles[ 'dq ' r];
\newline 

\newline 
instruction pattern PLANTICONST( longint r,type t) 
\newline 
 means[loc (t) r] 
\newline 
 assembles[ 'dd ' r]; 
\newline 
 
\newline 

\newline 
instruction pattern PLANTSCONST( float r,type t)
\newline 
 means[loc (t) r]
\newline 
 assembles[ 'dd ' r];
\newline 

\newline 
instruction pattern PLANTBCONST( byte r,type t) 
\newline 
 means[loc (t) r] 
\newline 
 assembles[ 'db ' r]; 
\newline 

\newline 
instruction pattern PLANTWCONST( word16 r,type t) 
\newline 
 means[loc (t) r] 
\newline 
 assembles[ 'dw ' r];
\newline 
 /*
\newline 

\backslash 
end{verbatim}
\end_inset 


\layout Subsubsection

Control transfers and tests 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 

\newline 
instruction pattern FAIL(int i)
\newline 
 means[interrupt i]
\newline 
 assembles['int 'i];
\newline 

\newline 
instruction pattern GOTO(jumpmode l)
\newline 
 means[goto l]
\newline 
 assembles['jmp ' l];
\newline 

\newline 
instruction pattern IFLITGOTO(label l,addrmode r1,
\newline 
                              signed r2,condition c,
\newline 
                              signed t,int b)
\newline 
 means[if((b)c((t) ^(r1),const r2))goto l]
\newline 
 assembles[' cmp 't' ' r1 ', ' r2 '
\backslash 
n'
\newline 
' j' c ' near ' l];
\newline 

\newline 
instruction pattern BIFLITGOTO(label l,baddrmode r1,
\newline 
                               signed arg2,condition c,signed t)
\newline 
 means[if(c((t) ^(r1),const arg2))goto l]
\newline 
 assembles[' cmp 't' ' r1 ', 't arg2 '
\backslash 
n'
\newline 
' j' c ' near ' l];
\newline 

\newline 
instruction pattern IFGOTO(label l,
\newline 
                           signedreg r1,
\newline 
                           regaddrimmediate r2,
\newline 
                           condition c,
\newline 
                           signed t,
\newline 
                           int b)
\newline 
 means[if((int8)c((t) ^(r1),(t) r2))goto l]
\newline 
 assembles['cmp ' r1 ','t ' ' r2 '
\backslash 
n'
\newline 
' j' c ' near ' l];
\newline 

\newline 

\newline 
instruction pattern IFASS(signedreg r1,
\newline 
                         regaddrimmediate r2,
\newline 
                         condition c,
\newline 
                         anyreg r3,
\newline 
                         addrmode rm, 
\newline 
                         type t )
\newline 
 means[if((int8)c((t) ^(r1),(t) r2))(ref t)rm:= (t)^(r3)]
\newline 
 assembles['cmp ' r1 ','t ' ' r2 '
\backslash 
n'
\newline 
' mov 'r1','t rm'
\backslash 
n'
\newline 
' cmov'c' 'r1','r3'
\backslash 
n'
\newline 
' mov 't rm ',' r1];
\newline 

\newline 
instruction pattern ANDIFGOTO(label l,anyreg r1,
\newline 
                             regaddrimmediate r2,
\newline 
                             condition c,
\newline 
                             int t,
\newline 
                             int b,
\newline 
                             anyreg r3,
\newline 
                             regaddrimmediate r4, 
\newline 
                             condition c2, 
\newline 
                             int t2,
\newline 
                             int b)
\newline 
 means[if((b)AND((b)c((t) ^(r1),(t) r2),
\newline 
                 (b)c2((t2)^(r3),(t2)r4)))goto l]
\newline 
 assembles['andifgoto ' c','r1','t r2','c2','r3',' t2 r4 ',' l];
\newline 

\newline 
instruction pattern SET(condition c,signedreg r1,
\newline 
                        regaddrimmediate rm, breg r,signed t)
\newline 
 means[r:= c((t)^(r1),(t) rm)]
\newline 
 assembles['cmp 'r1 ','t ' ' rm '
\backslash 
n'
\newline 
' set'c ' ' r'
\backslash 
n'
\newline 
' sub 'r',1
\backslash 
n'
\newline 
' not 'r];
\newline 

\newline 
instruction pattern SETU(unsignedcondition c,
\newline 
                         unsignedreg r1,
\newline 
                         regaddrimmediate rm, 
\newline 
                         breg r,unsigned t)
\newline 
 means[r:= c((t)^(r1),(t) rm)]
\newline 
 assembles['cmp 'r1 ','t ' ' rm '
\backslash 
n'
\newline 
' set'c ' ' r'
\backslash 
n'
\newline 
' sub 'r',1
\backslash 
n'
\newline 
' not 'r];
\newline 

\newline 
instruction pattern IFBOOL(label l,breg r1)
\newline 
 means[ if( (int8)^(r1))goto l]
\newline 
 assembles['test ' r1 ',' r1 '
\backslash 
n'
\newline 
' jnz near ' l];
\newline 

\newline 
instruction pattern BOUND0(reg r1,reg r2)
\newline 
 means[if(OR(<( ^(r2), ^((ref int32)mem( ^(r1) ))), 
\newline 
             >( ^(r2), ^((ref int32)mem(+(^(r1), 4))))) 
\newline 
         )interrupt 5]
\newline 
 assembles['bound ' r2 ',[' r1 ']'];
\newline 

\newline 
instruction pattern BOUND4(reg r1,reg r2)
\newline 
 means[if(OR(<( ^(r2),^((ref int32)mem(+(^(r1),4)))),
\newline 
             >(^(r2),^((ref int32)mem(+(^(r1), 8)))))
\newline 
            )interrupt 5]
\newline 
 assembles['bound ' r2 ',[' r1 '+4]'];
\newline 

\newline 
instruction pattern BOUND16(reg r1,reg r2)
\newline 
 means[if(OR(<( ^(r2),^((ref int32)mem(+(^(r1),16)))),
\newline 
             >(^(r2),^((ref int32)mem(+(^(r1), 20)))))
\newline 
         )interrupt 5]
\newline 
 assembles['bound ' r2 ',[' r1 '+16]'];
\newline 

\newline 
instruction pattern IFIN(reg r1,reg r2, label l)
\newline 
 means[ if((int8)AND((uint8)^(mem(r1 )) , 
\newline 
          <<( (uint8)1,^(r2))))goto l]
\newline 
 assembles['bt [' r1 '],' r2 '
\backslash 
n'
\newline 
' jc 'l];
\newline 

\newline 

\newline 
instruction pattern TESTIN(reg r1,reg r2, breg r)
\newline 
 means[ r:=AND((uint8)^(mem(r1 )) , <<( (uint8)1,^(r2)))]
\newline 
 assembles['bt [' r1 '],' r2 '
\backslash 
n'
\newline 
' setc 'r'
\backslash 
n'
\newline 
' not 'r'
\backslash 
n'
\newline 
' inc 'r];
\newline 

\newline 
instruction pattern BTS(reg r1,reg r2)
\newline 
 means[(ref uint8)mem(r1 ):=
\newline 
         OR((uint8)^(mem(r1 ) ), <<( (uint8)1,^(r2)))]
\newline 
 assembles['bts [' r1 '],' r2];
\newline 

\newline 
instruction pattern REPMOVSD(countreg s,maddrmode m1,
\newline 
                             sourcereg si, destreg di)
\newline 
 means[for (ref int32)m1:=0 to ^(s) step 1 do 
\newline 
        (ref int32)mem(+(^(di),*(^((ref int32)m1),4))):=
\newline 
          ^((ref int32)mem(+(^(si),*(^((ref int32)m1),4))))
\newline 
 ]
\newline 
 assembles[' inc ecx
\backslash 
n'
\newline 
' rep movsd']; 
\newline 

\newline 
instruction pattern REPMOVSB(countreg s,maddrmode m1,
\newline 
                             sourcereg si, destreg di)
\newline 
 means[for (ref int32)m1:=0 to ^(s) step 1 do 
\newline 
 (ref octet)mem(+(^(di),^((ref int32)m1))):=
\newline 
     ^((ref octet)mem(+(^(si),^((ref int32)m1))))]
\newline 
 assembles[' inc ecx
\backslash 
n'
\newline 
' rep movsb'];
\newline 
 
\newline 
/*
\newline 

\backslash 
end{verbatim}
\end_inset 

 The instructions are now listed in the order in which they are to be attempted
 by the matcher.
 The order chosen is a compromise between matching speed and code optimality.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{verbatim}
\newline 
*/
\newline 
 
\newline 
define(IA32codes,LOAD|MOVZXB|MOVSXB|MOVZXW|MOVSXW|MOVZXB2|
\newline 
 CLEARREG|STORELIT|INC|LEA|
\newline 
 RMLIT|RMR|
\newline 
 STOREWR|STORER|STOREBR|/* stores */
\newline 
 
\newline 
 DEC|IMULLIT|
\newline 
 BIMUL|RLIT|RRM|RMRB|RR|DIV8|IDIV|fastBIDIV|BIDIV|UDIV
\newline 
 |MOD2|MOD4|MOD8|MOD16| IMOD|UMOD|
\newline 
 fastIMUL|
\newline 
 Negate|NOTOP|MNegate|BTS|TESTIN|SHIFT|
\newline 
 UINT8MAX|UINT8MIN|INT8MAX|INT8MIN|SELECT|
\newline 
 PLANT|LITPUSH| MEMPUSH|
\newline 
 SET|SETU|ToBYTE|ANDIFGOTO |IFLITGOTO
\newline 
 |BIFLITGOTO|IFIN|IFGOTO
\newline 
 |GOTO|FAIL|BOUND4|BOUND0|BOUND16
\newline 
 |PLANTBCONST|PLANTWCONST|PLANTICONST
\newline 
 |PLANTRCONST|PLANTSCONST
\newline 
 |REPMOVSB|REPMOVSD |ADDUSB|SUBUSB|ADDSSB
\newline 
 |SUBSSB|MULTSSB|MULTSSBAL )
\newline 
/* these come last as they are a fallback 
\newline 
 for having no free registers */
\newline 
define(lastIA32codes, 
\newline 
 RPUSH| REFPUSH|SDEREF|SDEREFDOUBLEWORD/* pushes */
\newline 
 |IFBOOL|SMLIT|SMRP|SADD|SMULIT/* stack ops */
\newline 
 |SMRADD|SOP|SMR|BSMR|/* stack ops */
\newline 
 STOREWR|STORER|STOREBR|/* stores */
\newline 
 STACKLOAD |REFPOP|MEMPOP|BPOP|BSPOP|BSPUSH|DMEMPUSH
\newline 
 |BPUSH|STACKSTORE|STACKWSTORE|STACKBSTORE|RPOP)
\newline 

\newline 

\newline 
/* 
\backslash 
end{verbatim}
\end_inset 

 */
\the_end
