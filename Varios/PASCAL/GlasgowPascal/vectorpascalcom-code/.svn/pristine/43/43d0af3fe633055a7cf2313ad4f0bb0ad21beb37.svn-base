<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.03">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

   
<title> Vector Pascal Reference Manual</title>
 
<h1 align="center">Vector Pascal Reference Manual </h1>

<p>

<h3 align="center">Paul Cockshott  </h3>

<p>

<a href ="./intro.htm">Back to Menu</a><br><br>

<h1>Contents </h1><a href="#tth_chAp1"
>1&nbsp; Introduction</a><br>
<a href="#tth_chAp2"
>2&nbsp; Elements of the language</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Alphabet</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; Reserved words</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; Comments</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; Identifiers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5"
>2.5&nbsp; Literals</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.1"
>2.5.1&nbsp; Integer numbers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.2"
>2.5.2&nbsp; Real numbers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.3"
>2.5.3&nbsp; Character strings</a><br>
<a href="#tth_chAp3"
>3&nbsp; Declarations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; Constants</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1.1"
>3.1.1&nbsp; Array constants</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1.2"
>3.1.2&nbsp; Predeclared constants</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Labels</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; Types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3.1"
>3.3.1&nbsp; Simple types</a><br>




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3.2"
>3.3.2&nbsp; Stuctured types</a><br>




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3.3"
>3.3.3&nbsp; Dynamic types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; File types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5.1"
>3.5.1&nbsp; Entire Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5.2"
>3.5.2&nbsp; Indexed Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5.3"
>3.5.3&nbsp; Indexed Ranges</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5.4"
>3.5.4&nbsp; Virtual array variables</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5.5"
>3.5.5&nbsp; Field Designators</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5.6"
>3.5.6&nbsp; Referenced Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; Procedures and Functions</a><br>

<a href="#tth_chAp4"
>4&nbsp; Algorithms</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.1"
>4.1.1&nbsp; Mixed type expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.2"
>4.1.2&nbsp; Primary expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.3"
>4.1.3&nbsp; Unary expressions</a><br>






&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.4"
>4.1.4&nbsp; Factor</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.5"
>4.1.5&nbsp; Multiplicative expressions</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Statements</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.1"
>4.2.1&nbsp; Assignment</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.2"
>4.2.2&nbsp; Procedure statement</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.3"
>4.2.3&nbsp; Goto statement</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.4"
>4.2.4&nbsp; Compound statement</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.5"
>4.2.5&nbsp; If statement</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.6"
>4.2.6&nbsp; Case statement</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.7"
>4.2.7&nbsp; With statement</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.8"
>4.2.8&nbsp; For statement</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.9"
>4.2.9&nbsp; While statement</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.10"
>4.2.10&nbsp; Repeat statement</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Input Output </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.1"
>4.3.1&nbsp; Input</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.2"
>4.3.2&nbsp; Output </a><br>

<a href="#tth_chAp5"
>5&nbsp; Programs and Units</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; The export of identifiers from units</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.1"
>5.1.1&nbsp; The export of procedures from libraries.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; The invocation of programs and units</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; The compilation of programs and units.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; The System Unit</a><br>
<a href="#tth_chAp6"
>6&nbsp; Implementation issues</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; Invoking the compiler</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.1"
>6.1.1&nbsp; Environment variable</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.2"
>6.1.2&nbsp; Compiler options</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.3"
>6.1.3&nbsp; Dependencies</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; Compiler Structure</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; Calling conventions</a><br>


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; Array representation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4.1"
>6.4.1&nbsp; Range checking</a><br>
 <a href="#tth_sEcindex">Index</a><br>

<p>

<h1>List of Tables </h1>

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb2.1"
>2.1&nbsp;  The letters of Vector Pascal.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb2.2"
>2.2&nbsp;  The digits of Vector Pascal.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb2.3"
>2.3&nbsp;  Special symbols</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb2.4"
>2.4&nbsp;  The hexadecimal digits of Vector Pascal.</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb3.1"
>3.1&nbsp;  The operators permitted in Vector Pascal constant expressions.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb3.2"
>3.2&nbsp;  Categorisation of the standard types.</a><br>

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb4.1"
>4.1&nbsp;  Multiplicative operators</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb4.2"
>4.2&nbsp;  Addition operations</a><br>


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_tAb6.1"
>6.1&nbsp;  Code generators supported</a><br>


<p>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br>Introduction</h1>

<p>
Vector Pascal is a dialect of Pascal designed to make efficient use of the multi-media
instructionsets of recent procesors. It supports data parallel operations and
saturated arithmetic. This manual describes the Vector Pascal language.

<p>
A number of widely used contemporary processors have instructionset extensions
for improved performance in multi-media applications. The aim is to allow operations
to proceed on multiple pixels each clock cycle. Such instructionsets have been
incorporated both in specialist DSP chips like the Texas C62xx[<a href="#Texas" name="CITETexas">22</a>]
and in general purpose CPU chips like the Intel IA32[<a href="#Intel00" name="CITEIntel00">10</a>] or the AMD
K6 [<a href="#AMD" name="CITEAMD">1</a>].

<p>
These instructionset extensions are typically based on the Single Instruction-stream
Multiple Data-stream (SIMD<a name="SIMD10">
</a>) model in which a single instruction
causes the same mathematical operation to be carried out on several operands,
or pairs of operands at the same time. The level or parallelism supported ranges
from 2 floating point operations at a time on the AMD<a name="AMD10">
</a> K<a name="K610">
</a>6
architecture to 16 byte operations at a time on the intel P4 architecture. Whilst
processor architectures are moving towards greater levels of parallelism, the
most widely used programming languages like C<a name="C10">
</a>, Java<a name="Java10">
</a> and
Delphi<a name="Delphi10">
</a> are structured around a model of computation in which
operations take place on a single value at a time. This was appropriate when
processors worked this way, but has become an impediment to programmers seeking
to make use of the performance offered by multi-media instructionsets.

<p>
Vector Pascal aims to provide an efficient and concise notation for programmers
using Multi-Media enhanced CPUs. In doing so it borrows concepts for expressing
data parallelism that have a long history, dating back to Iverson's work on
APL<a name="APL10">
</a> in the early '60s[<a href="#Iverson62" name="CITEIverson62">12</a>]. 

<p>
The(T )as having type  T[] . Then if
we have a binary operator  <font face="symbol">w</font
>:(T<font face="symbol">Ä</font
>T)<font face="symbol">®</font
> T , in languages
derived from APL we automatically have an operator  <font face="symbol">w</font
>:(T[]<font face="symbol">Ä</font
>T[])<font face="symbol">®</font
> T[] 
 . Thus if  x,y  are arrays of integers  k=x+y  is the array
of integers where  k<sub>i</sub>=x<sub>i</sub>+y<sub>i</sub> .

<p>
The basic concept is simple, there are complications to do with the semantics
of operations between arrays of different lengths and different dimensions,
but Iverson provides a consistent treatment of these. The most recent languages
to be built round this model are J<a name="J10">
</a>, an interpretive language[<a href="#Jmanual" name="CITEJmanual">14</a>][<a href="#Burke" name="CITEBurke">3</a>][],
and F[<a href="#Metcalf96" name="CITEMetcalf96">18</a>] a modernised Fortran<a name="Fortran10">
</a>. In principle though
any language with array types can be extended in a similar way. Iverson's approach
to data parallelism is machine independent. It can be implemented using scalar
instructions or using the SIMD model. The only difference is speed. 

<p>
Vector Pascal incorporates Iverson's approach to data parallelism. Its aim is
to provide a notation that allows the natural and elegant expression of data
parallel algorithms within a base language that is already familiar to a considerable
body of programmers and combine this with modern compilation techniques. 

<p>
By an elegant algorithm I mean one which is expressed as concisely as possible.
Elegance is a goal that one approaches asymtotically, approaching but never
attaining[<a href="#Chaitin" name="CITEChaitin">5</a>]. APL and J allow the construction of very elegant programs,
but at a cost. An inevitable consequence of elegance is the loss of redundancy.
APL programs are as concise, or even more concise than conventional mathematical
notation[<a href="#Iverson80" name="CITEIverson80">13</a>] and use a special characterset. This makes them hard
for the uninitiated to understand. J attempts to remedy this by restricting
itself to the ASCII characterset, but still looks dauntingly unfamiliar to programmers
brought up on more conventional languages. Both APL and J are interpretive which
makes them ill suited to many of the applications for which SIMD speed is required.
The aim of Vector Pascal is to provide the conceptual gains of Iverson's notation
within a framework familiar to imperative programmers.

<p>
Pascal<a name="Pascal10">
</a>[<a href="#Jensen" name="CITEJensen">15</a>]was chosen as a base language over the alternatives
of C and Java. C was rejected because notations like <tt>x+y</tt> for <tt>x</tt>
and <tt>y</tt> declared as <tt>int x[4],y[4]</tt>, already have the
meaning of adding the addresses of the arrays together. Java was rejected because
of the difficulty of efficiently transmitting data parallel operations via its
intermediate code to a just in time code generator. 

<p>
Iverson's approach to data parallelism is machine independent. It can be implemented
using scalar instructions or using the SIMD<a name="SIMD10">
</a> model. The only difference
is speed. Vector Pascal incorporates Iverson's approach to data parallelism.

<p>
 <h1><a name="tth_chAp2">
Chapter 2 </a><br>Elements of the language</h1>

<p>
 <h2><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Alphabet</h2>

<p>
In what follows examples and reserved words of Vector Pascal will be denoted
in bold face. Vector Pascal programs are made up of letter, digits and special
symbols.

<p>
<a name="tth_tAb2.1">
</a> <center>Table 2.1: The letters of Vector Pascal<a name="letters">
</a>.</center>
<center> 
<table border="1">
<tr><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F</td><td align="center">G</td><td align="center">H</td><td align="center">I</td><td align="center">J</td><td align="center">K</td><td align="center">L</td><td align="center">M</td></tr><tr><td>
<tr><td align="center">N</td><td align="center">O</td><td align="center">P</td><td align="center">Q</td><td align="center">R</td><td align="center">S</td><td align="center">T</td><td align="center">U</td><td align="center">V</td><td align="center">W</td><td align="center">X</td><td align="center">Y</td><td align="center">Z</td></tr>
<tr><td align="center">a</td><td align="center">b</td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">f</td><td align="center">g</td><td align="center">h</td><td align="center">i</td><td align="center">j</td><td align="center">k</td><td align="center">l</td><td align="center">m</td></tr>
<tr><td align="center">n</td><td align="center">o</td><td align="center">p</td><td align="center">q</td><td align="center">r</td><td align="center">s</td><td align="center">t</td><td align="center">u</td><td align="center">v</td><td align="center">w</td><td align="center">x</td><td align="center">y</td><td align="center">z</td></tr></table>

<p>
</center>
<p>
 The digits are shown in table <a href="#digits">2.2</a>.

<p>
<a name="tth_tAb2.2">
</a> <center>Table 2.2: The digits of Vector Pascal.<a name="digits">
</a></center>
<center> 
<table border="1">
<tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td></tr></table>

<p>
</center>
<p>
 The special symbols are shown in table<a href="#specials">2.3</a> .

<p>
<a name="tth_tAb2.3">
</a> <center>Table 2.3: Special symbols<a name="specials">
</a></center>

<center> 
<table border="1">
<tr><td align="center">+</td><td align="center">:</td><td align="center">(</td></tr>
<tr><td align="center">-</td><td align="center">'</td><td align="center">)</td></tr>
<tr><td align="center">*</td><td align="center">=</td><td align="center">[</td></tr>
<tr><td align="center">/</td><td align="center">&lt;&#62;</td><td align="center">]</td></tr>
<tr><td align="center">:=</td><td align="center">&lt;</td><td align="center">{</td></tr>
<tr><td align="center">.</td><td align="center">&lt;=</td><td align="center">}</td></tr>
<tr><td align="center">,</td><td align="center">&#62;=</td><td align="center"></td></tr>
<tr><td align="center">;</td><td align="center">&#62;</td><td align="center">..</td></tr>
<tr><td align="center">+:</td><td align="center">@</td><td align="center">*)</td></tr>
<tr><td align="center">-:</td><td align="center">$</td><td align="center">(*</td></tr>
<tr><td align="center">_</td><td align="center">**</td><td align="center"></td></tr></table>

<p>
</center>
<p>
 <h2><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Reserved words</h2>

<p>
The reserved words are

<p>
<b>ABS, ADDR, AND, ARRAY,</b>

<p>
<b>BEGIN,</b>

<p>
<b>CASE, CHR, CONST, COS,</b>

<p>
<b>DISPOSE, DIV, DO, DOWNTO,</b>

<p>
<b>END, ELSE, EXIT,</b>

<p>
<b>FALSE, FILE, FOR, FUNCTION,</b>

<p>
<b>GOTO,</b>

<p>
<b>IF, IMPLEMENTATION, IN, INTERFACE, IOTA,</b>

<p>
<b>LABEL, LIBRARY, LN,</b>

<p>
<b>MAX, MIN, MOD,</b>

<p>
<b>NEW, NOT,</b>

<p>
<b>OF, OR, ORD,</b>

<p>
<b>PACKED, POW,PRED, PROCEDURE, PROGRAM,</b>

<p>
<b>READ, READLN, RECORD, REPEAT, ROUND,</b>

<p>
<b>SET, SHL, SHR, SIN, SIZEOF, STRING, SQRT, SUCC,</b>

<p>
<b>TAN, THEN, TO, TRANS, TRUE, TYPE,</b>

<p>
<b>VAR,</b>

<p>
<b>WITH, WHILE, WRITE, WRITELN,</b>

<p>
<b>UNIT, UNTIL, USES </b>

<p>
Reserved words may be written in either lower case or upper case letters, or
any combination of the two. 

<p>
 <h2><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Comments</h2>

<p>
The comment<a name="comment23">
</a> construct 

<p>
<b>{<a name="23">
</a></b> &lt; any sequence of characters not containing ``}''
&#62; <b>}</b> 

<p>
may be inserted between any two identifiers, special symbols, numbers or reserved
words without altering the semantics or syntactic correctness of the program.
The bracketing pair <b>(* *)<a name="*)23">
</a></b> may substitute for <b>{
}</b>. Where a comment starts with <b>{</b> it continues until the next <b>}</b>.
Where it starts with <b>(*<a name="(*23">
</a></b> it must be terminated by <b>*)</b><a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>.

<p>
 <h2><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;Identifiers</h2>

<p>
Identifiers are used to name values, storage locations, programs, program modules,
types, procedures and functions. An identifier<a name="identifier24">
</a> starts with
a letter followed by zero or more letters, digits or the special symbol <b>_</b>.
Case is not significant in identifiers.

<p>
 <h2><a name="tth_sEc2.5">
2.5</a>&nbsp;&nbsp;Literals</h2>

<p>
     <h3><a name="tth_sEc2.5.1">
2.5.1</a>&nbsp;&nbsp;Integer numbers</h3>

<p>
Integer numbers are formed of a sequence of decimal digits, thus <b>1</b>,
<b>23</b>, <b>9976</b> etc, or as hexadecimal<a name="hexadecimal25">
</a> numbers,
or as numbers of any base between 2 and 36. A hexadecimal number takes the form
of a <b>$</b> followed by a sequence of hexadecimal digits thus <b>$01,
$3ff, $5A</b>. The letters in a hexadecimal number may be upper or lower case
and drawn from the range <b>a..f</b> or <b>A..F. </b>

<p>
A based integer<a name="integer25">
</a> is written with the base first followed by a
# character and then a sequence of letters or digits. Thus <b>2#1101</b>
is a binary number <b>8#67</b> an octal<a name="octal25">
</a> number and <b>20#7i</b>
a base 20 number.

<p>
The default precision for integers is 32 bits<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;digit sequence&#62;</td><td align="center">&lt;digit&#62; +</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;decimal integer&#62;</td><td align="center">&lt;digit sequence&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;hex integer&#62;</td><td align="center">`$'&lt;hexdigit&#62;+</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;based integer&#62; </td><td align="center">&lt;digit sequence&#62;'#'&lt;alphanumeric&#62;+</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;unsigned integer&#62;</td><td align="center">&lt;decimal integer&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;hex integer&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;based integer&#62;</td></tr></table>


<p>
<a name="tth_tAb2.4">
</a> <center>Table 2.4: The hexadecimal digits of Vector Pascal.</center>
<center> 
<table border="1">
<tr><td align="center">Value</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td></tr>
<tr><td align="center">Notation 1</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F</td></tr>
<tr><td align="center">Notation 2</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">a</td><td align="center">b</td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">f</td></tr></table>

<p>
</center>.

<p>
 
</center>     <h3><a name="tth_sEc2.5.2">
2.5.2</a>&nbsp;&nbsp;Real numbers</h3>

<p>
Real numbers are supported in floating point notation, thus <b>14.7, 9.99e5,
38E3, 3.6e-4</b> are all valid denotations for real<a name="real25">
</a> numbers. The default
precision for real numbers is also 32 bit, though intermediate calculations
may use higher precision. The choice of 32 bits as the default precision is
influenced by the fact that 32 bit floating point vector operations are well
supported in multi-media<a name="media25">
</a> instructions.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;exp&#62;</td><td align="center">`e'</td></tr>
<tr><td align="center"></td><td align="center">`E'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;scale factor&#62;</td><td align="center">[&lt;sign&#62;] &lt;unsigned integer&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;sign&#62;</td><td align="center">`-'</td></tr>
<tr><td align="center"></td><td align="center">`+'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;unsigned real&#62;</td><td align="center">&lt;decimal integer&#62; `.' &lt;digit sequence&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;decimal integer&#62;` .' &lt;digit sequence&#62; &lt;exp&#62;&lt;scale factor&#62; </td></tr>
<tr><td align="center"></td><td align="center">&lt;decimal integer&#62;&lt;exp&#62; &lt;scale factor&#62;</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc2.5.3">
2.5.3</a>&nbsp;&nbsp;Character strings</h3>

<p>
Sequences of characters enclosed by quotes are called literal<a name="literal25">
</a>
strings. Literal strings<a name="strings25">
</a> consisting of a single character are
constants of the standard type char. If the string is to contain a quote character
this quote character must be written twice.

<p>
<b><font size="-1">'A' 'x' 'hello' 'John''s house'</font></b><font size="-1">
<p>
</font>are all valid literal strings. The allowable characters in literal strings are:

<p>
<tt>'</tt> <tt><font size="-1">' '!' '"' '#' '$' '%' '&amp;' ''' '(' ')'
'*' '+' ',' '-' '.' '/', </font></tt><font size="-1">
<p>
</font><tt><font size="-1">'0' '1' '2' '3' '4' '5' '6' '7' '8' '9' ':' ';' '&lt;' '=' '&#62;' '?', </font></tt><font size="-1">
<p>
</font><tt><font size="-1">'@' 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O', </font></tt><font size="-1">
<p>
</font><tt><font size="-1">'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z' '[' ''
']' '' '_', </font></tt><font size="-1">
<p>
</font><tt><font size="-1">'`' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o', </font></tt><font size="-1">
<p>
</font><tt><font size="-1">'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '{' '|' '}' ''</font></tt><font size="-1">
<p>
</font> <h1><a name="tth_chAp3">
Chapter 3 </a><br>Declarations</h1>

<p>
Vector Pascal is a language supporting nested declaration<a name="declaration30">
</a>
contexts. A declaration context is either a program context, and unit interface
or implementation context, or a procedure or function context. A resolution
context determines the meaning of an identifier. Within a resolution context,
identifiers can be declared to stand for constants, types, variables, procedures
or functions. When an identifier is used, the meaning taken on by the identifier
is that given in the closest containing resolution context. Resolution contexts
are any declaration context or a <b>with</b> statement context. The ordering
of these contexts when resolving an identifier is:

<p>

<ol type="1"><p>
<li> The declaration context identified by any <b>with</b> statements which nest
the current occurence of the identifier. These <b>with</b> statement contexts
are searched from the innermost to the outermost.</li>
<p>
<li> The declaration context of the currently nested procedure<a name="procedure30">
</a>
declarations. These procedure contexts are searched from the innermost to the
outermost.</li>
<p>
<li> The declaration context of the current unit<a name="unit30">
</a> or program<a name="program30">
</a>.</li>
<p>
<li> The interface declaration contexts of the units mentioned in the use list of
the current unit or program. These contexts are searched from the rightmost
unit mentioned in the use list to the leftmost identifier in the use list.</li>
<p>
<li> The interface declartion context of the System<a name="System30">
</a> unit.</li>
<p>
<li> The pre-declared identifiers of the language.</li>
</ol>

<p>
 <h2><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Constants</h2>

<p>
A constant definition introduces an identifier as a synonym for a constant. 

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;constant declaration&#62;</td><td align="center">&lt;identifier&#62;=&lt;expression&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;identifier&#62;':'&lt;type&#62;'='&lt;typed constant&#62;</td></tr></table>

<p>
</center>Constants can be simple constants or typed constants. A simple constant must
be a constant expression whose value is known at compile time. This restricts
it to expressions for which all component identifiers are other constants, and
for which the permitted operators<a name="operators31">
</a> are given in table<a href="#MMConst">3.1</a>
. This restricts simple constants to be of scalar or string types.

<p>

<p>
<a name="tth_tAb3.1">
</a> <center>Table 3.1: The operators permitted in Vector Pascal constant expressions.<a name="MMConst">
</a></center>
<center> 
<table border="1">
<tr><td align="center">+</td><td align="center">-</td><td align="center">*</td><td align="center">/</td><td align="center">div</td><td align="center">mod</td><td align="center">shr</td><td align="center">shl</td><td align="center">and</td><td align="center">or</td></tr></table>

<p>
</center>
<p>
Typed constants provide the program with initialised variables which may hold
array types.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;typed constant&#62;</td><td align="center">&lt;expression&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;array constant&#62;</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc3.1.1">
3.1.1</a>&nbsp;&nbsp;Array constants</h3>

<p>
Array constants are comma separated lists of constant expressions enclosed by
brackets. Thus 

<p>
<b>tr:array[1..3] of real =(1.0,1.0,2.0);</b>

<p>
is a valid array constant declaration, as is:

<p>
<b>t2:array[1..2,1..3] of real=((1.0,2.0,4.0),(1.0,3.0,9.0));</b>

<p>
The array constant<a name="constant31">
</a><a name="array constant31">
</a> must structurally
match the type<a name="type31">
</a> given to the identifier. That is to say it must
match with respect to number of dimensions, length of each dimension, and type
of the array elements.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;array constant&#62;</td><td align="center">'(' &lt;typed constant&#62; [,&lt;typed constant&#62;]* ')'</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc3.1.2">
3.1.2</a>&nbsp;&nbsp;Predeclared constants<a name="constants31">
</a></h3>

<p>

<dl compact="compact">

     
       
      
       <dt><b><b>maxint<a name="maxint31">
</a></b></b></dt>
	<dd>The largest supported integer value.</dd>
 <dt><b><b>pi<a name="pi31">
</a></b></b></dt>
	<dd> A real numbered approximation to  <font face="symbol">p</font
></dd>
 <dt><b><b>maxchar<a name="maxchar31">
</a></b></b></dt>
	<dd> The highest character in the character set.</dd>
 <dt><b><b>maxstring<a name="maxstring31">
</a></b></b></dt>
	<dd>The maximum number of characters allowed
in a string.</dd>
 <dt><b><b>maxreal<a name="maxreal31">
</a></b></b></dt>
	<dd>The highest representable real.</dd>
 <dt><b><b>minreal<a name="minreal31">
</a></b></b></dt>
	<dd>The smallest representable positive real number.</dd>
 <dt><b><b>epsreal<a name="epsreal31">
</a></b></b></dt>
	<dd>The smallest real number which when added
to 1.0 yields a value distinguishable from 1.0.</dd>
 <dt><b><b>maxdouble<a name="maxdouble31">
</a></b></b></dt>
	<dd>The highest representable double precision
real number.</dd>
 <dt><b><b>mindouble<a name="mindouble31">
</a></b></b></dt>
	<dd>The smallest representable positive double
precision real number.
</dd>
</dl>

<p>
 <h2><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Labels</h2>

<p>
Labels are written as digit sequences. Labels must be declared before they are
used. They can be used to label the start of a statement and can be the destination
of a <b>goto<a name="goto32">
</a></b> statement. A <b>goto</b> statement must have
as its destination a label<a name="label32">
</a> declared within the current innermost
declaration context. A statement can be prefixec by a label followed by a colon.

<p>
Example

<p>
<b>label 99;</b>

<p>
<b>begin read(x); if x&#62;9 goto 99; write(x*2);99: end;</b>

<p>
 <h2><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Types</h2>

<p>
A type declaration determines the set of values that expressions of this type
may assume and associates with this set an identifier.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;type&#62;</td><td align="center">&lt;simple type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;structured type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;pointer type&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;type definition&#62;</td><td align="center">&lt;identifier&#62;'='&lt;type&#62; </td></tr></table>

<p>
</center>     <h3><a name="tth_sEc3.3.1">
3.3.1</a>&nbsp;&nbsp;Simple types</h3>

<p>
Simple types are either scalar, standard, subrange or dimensioned types.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;simple type&#62;</td><td align="center">&lt;scalar type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;integral type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;subrange type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;dimensioned type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;floating point type&#62;</td></tr></table>

<p>
</center>
<h4>Scalar types</h4>

<p>
A scalar<a name="scalar33">
</a> type<a name="type33">
</a> defines an ordered set of identifier
by listing these identifiers. The declaration takes the form of a comma separated
list of identifiers enclosed by brackets. The identifiers in the list are declared
simultaneously with the declared scalar type to be constants of this declared
scalar type. Thus 

<p>
<b>colour = (red,green,blue);</b>

<p>
<b>day=(monday,tuesday,wednesday,thursday,friday,saturday,sunday);</b>

<p>
are valid scalar type declarations.

<p>

<h4>Standard types</h4>

<p>
The following types are provided as standard in Vector Pascal:

<p>
<a name="tth_tAb3.2">
</a> <center>Table 3.2: Categorisation of the standard types.</center>
<center> 
<table border="1">
<tr><td align="center">type</td><td align="center">category</td></tr><tr><td>
<tr><td align="center">real</td><td align="center">floating point</td></tr>
<tr><td align="center">double</td><td align="center">floating point</td></tr>
<tr><td align="center">byte</td><td align="center">integral</td></tr>
<tr><td align="center">shortint</td><td align="center">integral</td></tr>
<tr><td align="center">word</td><td align="center">integral</td></tr>
<tr><td align="center">integer</td><td align="center">integral</td></tr>
<tr><td align="center">cardinal</td><td align="center">integral</td></tr>
<tr><td align="center">boolean</td><td align="center">scalar</td></tr>
<tr><td align="center">char</td><td align="center">scalar</td></tr></table>

<p>
</center>
<p>

<dl compact="compact">

     
       
      
       <dt><b><b>integer<a name="integer33">
</a></b></b></dt>
	<dd>The numbers are in the range -maxint to +maxint.</dd>
 <dt><b><b>real<a name="real33">
</a></b></b></dt>
	<dd>These are a subset of the reals constrained by the
IEEE 32 bit floating point format.</dd>
 <dt><b><b>double<a name="double33">
</a></b></b></dt>
	<dd>These are a subset of the real numbers constrained
by the IEEE<a name="IEEE33">
</a> 64 bit floating point format.</dd>
 <dt><b><b>boolean<a name="boolean33">
</a></b></b></dt>
	<dd>These take on the values <b>(false<a name="false33">
</a>,true<a name="true33">
</a>)</b>
which are ordered such that <b>true&lt;false</b>.</dd>
 <dt><b><b>char<a name="char33">
</a></b></b></dt>
	<dd>These include the characters from <b>chr(0)</b>
to <b>charmax</b><a name="charmax33">
</a>. All the allowed characters for string literals
are in the type char, but the characterset may include other characters whose
printable form is country specific.</dd>
 <dt><b><b>byte<a name="byte33">
</a></b></b></dt>
	<dd>These take on the positive integers between 0 and
255.</dd>
 <dt><b><b>shortint<a name="shortint33">
</a></b></b></dt>
	<dd>These take on the signed values between
-128 and 127.</dd>
 <dt><b><b>word<a name="word33">
</a></b></b></dt>
	<dd>These take on the positive integers from 0 to 65535.</dd>
 <dt><b><b>cardinal<a name="cardinal33">
</a></b></b></dt>
	<dd>These take on the positive integers form
0 to 4292967295, i.e., the most that can be represented in a 32 bit unsigned
number.</dd>
 <dt><b><b>longint<a name="longint33">
</a></b></b></dt>
	<dd>A 64 bit integer.
</dd>
</dl>

<p>

<h4>Subrange types</h4>

<p>
A type may be declared as a subrange<a name="subrange33">
</a> of another scalar<a name="scalar33">
</a>
or integer<a name="integer33">
</a> type by indicating the largest and smallest value
in the subrange. These values must be constants known at compile time.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;subrange type&#62;</td><td align="center">&lt;constant&#62; '..' &lt;constant&#62;</td></tr></table>

<p>
</center>Examples: 1..10, 'a'..'f', monday..thursday.

<p>

<h4>Dimensioned types</h4>

<p>
These provide a means by which floating point types can be specialised to represent
dimensioned numbers as is required in physics calculations. For example:

<p>
<b>kms =(mass,distance,time);</b>

<p>
<b>meter=real of distance;</b>

<p>
<b>kilo=real of mass;</b>

<p>
<b>second=real of time;</b>

<p>
<b>newton=real of mass * distance * time POW -2;</b>

<p>
<b>meterpersecond = real of distance *time POW -1;</b>

<p>
The grammar is given by:

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;dimensioned type&#62;</td><td align="center">&lt;real type&#62; &lt;dimension &#62;['*' &lt;dimension&#62;]*</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;real type&#62;</td><td align="center">'real'</td></tr>
<tr><td align="center"></td><td align="center">'double'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;dimension&#62;</td><td align="center">&lt;identifier&#62; ['POW' [&lt;sign&#62;] &lt;unsigned integer&#62;]</td></tr></table>

<p>
</center>The identifier<a name="identifier33">
</a> must be a member of a scalar type, and that
scalar type is then refered to as the basis space of the dimensioned type. The
identifiers of the basis<a name="basis33">
</a> space are refered to as the dimensions
of the dimensioned type<a name="type33">
</a>. Associated with each dimension of a dimensioned
type there is an integer number refered to as the power of that dimension. This
is either introduced explicitly at type declaration time, or determined implicitly
for the dimensional type of expressions. 

<p>
A value of a dimensioned type is a dimensioned value. Let  log<sub>d</sub>t 
of a dimensioned type  t  be the power to which the dimension  d 
of type  t  is raised. Thus for  t = newton in the example above, and
 d = time,  log<sub>d</sub>t=<font face="symbol">-</font
>2 

<p>
If  x  and  y  are values of dimensioned<a name="dimensioned33">
</a> types
 t<sub>x</sub> and  t<sub>y</sub> respectively, then the following operators are only
permissible if  t<sub>x</sub>=t<sub>y</sub> 

<p>
<center> 
<table border="1">
<tr><td align="center">+</td><td align="center">-</td><td align="center">&lt;</td><td align="center">&#62;</td><td align="center">&lt;&#62;</td><td align="center">=</td><td align="center">&lt;=</td><td align="center">&#62;=</td></tr></table>

<p>
</center>For + and -, the dimensional<a name="dimensional33">
</a> type of the result is the same
as that of the arguments. The operations 

<p>
<center> 
<table border="1">
<tr><td align="center">*</td><td align="center">/</td></tr></table>

<p>
</center>are permited if the types  t<sub>x</sub> and  t<sub>y</sub>  share the same basis
space, or if the basis space of one of the types is a subrange of the basis
space of the other.  

<p>
The operation <b>POW</b> is permited between dimensioned types and integers.

<p>

<b>*&nbsp;&nbsp;</b>Dimension deduction rules

<p>

<ol type="1"><p>
<li> If  x=y*z  for  x:t<sub>1</sub>,y:t<sub>2</sub>,z:t<sub>3</sub>  with basis space  B 
then  <font face="symbol">"</font
><sub>d <font face="symbol">Î</font
> B</sub>log<sub>d</sub>t<sub>1</sub>=log<sub>d</sub>t<sub>2</sub>+log<sub>d</sub>t<sub>3</sub> .</li>
<p>
<li> If  x=y/z  for  x:t<sub>1</sub>,y:t<sub>2</sub>,z:t<sub>3</sub>  with basis space  B 
then  <font face="symbol">"</font
><sub>d <font face="symbol">Î</font
> B</sub>log<sub>d</sub>t<sub>1</sub>=log<sub>d</sub>t<sub>2</sub><font face="symbol">-</font
>log<sub>d</sub>t<sub>3</sub> .</li>
<p>
<li> If  x=y  <b>POW</b>  z  for  x:t<sub>1</sub>,y:t<sub>2</sub>,z:integer  with
basis space for  t<sub>2</sub> ,  B  then  <font face="symbol">"</font
><sub>d <font face="symbol">Î</font
> B</sub>log<sub>d</sub>t<sub>1</sub>=log<sub>d</sub>t<sub>2</sub>&times;z .</li>
</ol>

<p>
     <h3><a name="tth_sEc3.3.2">
3.3.2</a>&nbsp;&nbsp;Stuctured types</h3>

<p>

<h4>Static Array<a name="array33">
</a><a name="array, static33">
</a> types</h4>

<p>
An array type is a structure consisting of a fixed number of elements all of
which are the same type. The type of the elements is refered to as the element
type. The elements of an array value are indicated by bracketed indexing expressions.
The definition of an array<a name="array33">
</a> type<a name="type33">
</a> simultaneously defines
the permited type of indexing expression and the element type. 

<p>
The index<a name="index33">
</a> type<a name="type33">
</a> of a static<a name="static33">
</a> array<a name="array, static33">
</a>
must be a scalar<a name="scalar33">
</a> or subrange<a name="subrange33">
</a> type. This implies
that the bounds of a static array are known at compile time.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;array type&#62;</td><td align="center">'array' '[' &lt;index type&#62;[,&lt;index type&#62;]* ']' 'of' &lt;type&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;index type&#62;</td><td align="center">&lt;subrange type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;scalar type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;integral type&#62;</td></tr></table>

<p>
</center>Examples

<p>
<b>array[colour] of boolean;</b>

<p>
<b>array[1..100] of integer;</b>

<p>
<b>array[1..2,4..6] of byte;</b>

<p>
<b>array[1..2] of array[4..6] of byte;</b>

<p>
The notation [<em>b,c</em>] in an array declaration is shorthand for the notation
[<em>b</em>]<b>of array</b>[<em>c</em>]. The number of dimensions of an
array type is refered to as its rank. Scalar types have rank 0.

<p>

<h4>String types</h4>

<p>
A string<a name="string33">
</a> type denotes the set of all sequences of characters
up to some finite length and must have the syntactic form:

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;string-type&#62;</td><td align="center">'string[' &lt;integer constant&#62;']'</td></tr>
<tr><td align="center"></td><td align="center">'string'</td></tr></table>

<p>
</center>the integer constant indicates the maximum number of characters that may be
held in the string type. The maximum number of characters that can be held in
any string is indicated by the predeclared constant <b>maxstring</b>. The
type <b>string</b> is shorthand for <b>string[maxstring]</b>.

<p>

<h4>Record types</h4>

<p>
A record type defines a set of simlar data structures. Each member of this set,
a record instance, is a cartesian product of number of components or <em>fields</em>
specified in the record<a name="record33">
</a> type definition. Each field has an identifier
and a type. The scope of these identifiers is the record itself.

<p>
A record type may have as a final component a <em>variant<a name="variant33">
</a>
part</em>. The variant part, if a variant part exists, is a union of several variants,
each of which may itself be a cartesian product of a set of fields. If a variant
part exists there may be a tag field whose value indicates which variant is
assumed by the record instance.

<p>
All field identifiers even if they occur within different variant parts, must
be unique within the record type.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;record type&#62;</td><td align="center">'record' &lt;field list&#62; 'end'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;field list&#62;</td><td align="center">&lt;fixed part&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;fixed part&#62;';' &lt;variant part&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;variant part&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;fixed part&#62;</td><td align="center">&lt;record section&#62; [ ';' &lt;record section.]*</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;record section&#62;</td><td align="center">&lt;identifier&#62;[',' &lt;identifier&#62;]* ':' &lt;type&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;empty&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;variant part&#62;</td><td align="center">'case' [&lt;tag field&#62; ':'] &lt;type identifier&#62; 'of'&lt;variant&#62;[';' &lt;variant&#62;]*</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;variant&#62;</td><td align="center">&lt;constant&#62; [',' &lt;constant&#62;]*':' '(' &lt;field list&#62; ')'</td></tr>
<tr><td align="center"></td><td align="center">&lt;empty&#62;</td></tr></table>

<p>
</center>
<h4>Set types</h4>

<p>
A set<a name="set33">
</a> type defines the range of values which is the powerset of
its base type. The base type must be a scalar type, a character type, integer
type or a subrange thereof.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;set type&#62;</td><td align="center">'set' 'of' &lt;base type&#62;</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc3.3.3">
3.3.3</a>&nbsp;&nbsp;Dynamic<a name="Dynamic33">
</a> types</h3>

<p>
Variables declared within the program are accessed by their identifier. These
variables exist throughout the existence of the scope within which they are
declared, be this unit, program or procedure. These variables are assigned storage
locations whose addresses, either absolute or relative to some register, can
be determined at compile time. Such locations a refered to as static<a name="static33">
</a><a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>. Storage locations may also be allocated dynamically. Given a type <b>t</b>,
the type of a pointer<a name="pointer33">
</a> to an instance of type <b>t</b> is <b>t</b>. 

<p>
A pointer of type <b>t</b> can be initialised to point to
a new store location of type t by use of the built in procedure <b>new</b>.
Thus if <b>p:t</b>,

<p>
<b>new(p);</b>

<p>
causes <b>p</b> to point at a store location of type <b>t</b>.

<p>

<h4>Pointers to dynamic<a name="dynamic33">
</a><a name="dynamic array33">
</a> arrays<a name="array, dynamic33">
</a><a name="array33">
</a></h4>

<p>
The types pointed to by pointer types can be any of the types mentioned so far,
that is to say, any of the types allowed for static<a name="static33">
</a> variables.
In addition however, pointer types can be declared to point at dynamic arrays.
A dynamic array is an array whose bounds are determined at run time.

<p>
Pascal<a name="Pascal9033">
</a> 90[<a href="#ISO90" name="CITEISO90">11</a>] introduced the notion of schematic or
parameterised types as a means of creating dynamic arrays. Thus where <b>r</b>
is some integral or ordinal type one can write 

<p>
<b>type z(a,b:r)=array[a..b] of t;</b>

<p>
If <b>p:z</b>, then 

<p>
<b>new(p,n,m)</b>

<p>
where <b>n,m:r</b> initialises <b>p</b> to point to an array of bounds <b>n..m</b>.
The bounds of the array can then be accessed as <b>p.a,
p.b</b>. Vector Pascal currently allows dynamic but not static<a name="static33">
</a>
parameterised types.

<p>
 <h2><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;File types</h2>

<p>
A type may be declared to be a file of a type. This form of definition is kept
only for backward compatibility. All file types are treated as being equivalent.
A file type corresponds to a handle to an operating system file. A file variable
must be associated with the operationg system file by using the procedures <b>assign,
rewrite, append</b>, and <b>reset</b> provided by the system unit. A predeclared
file type <b>text</b> exists.

<p>
 <h2><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Variables<a name="Variables35">
</a></h2>

<p>
Variable declarations consist of a list of identifiers denoting the new variables,
followed by their types.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;variable declaration&#62;</td><td align="center">&lt;identifer&#62; [',' &lt;identifier&#62;]* ':' &lt;type&#62;</td></tr></table>

<p>
</center>Variables are abstractions over values. They can be either simple identifiers,
components or ranges of components of arrays, fields of records or referenced
dynamic variables.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;variable&#62;</td><td align="center">&lt;identifier&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;indexed variable&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;indexed range&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;field designator&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;referenced variable&#62;</td></tr></table>

<p>
</center>Examples

<p>
<b>x,y:real;</b>

<p>
<b>i:integer;</b>

<p>
<b>point:real;</b>

<p>
<b>dataset:array[1..n]of integer;</b>

<p>
<b>twoDdata:array[1..n,4..7] of real;</b>

<p>
     <h3><a name="tth_sEc3.5.1">
3.5.1</a>&nbsp;&nbsp;Entire Variables</h3>

<p>
An entire variable is denoted by its identifier. Examples <b>x,y,point</b>, 

<p>
     <h3><a name="tth_sEc3.5.2">
3.5.2</a>&nbsp;&nbsp;Indexed Variables</h3>

<p>
A component of an <em>n</em> dimensional array variable is denoted by the variable
followed by <em>n</em> index expressions in brackets.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;indexed variable&#62;</td><td align="center">&lt;variable&#62;'[' &lt;expression&#62;[','&lt;expression&#62;]* ']'</td></tr></table>

<p>
</center>The type of the indexing expression must conform to the index type of the array
variable. The type of the indexed variable is the component type of the array.

<p>
Examples

<p>
<b>twoDdata[2,6]</b>

<p>
<b>dataset[i]</b>

<p>
Given the declaration 

<p>
<b>a=array[p] of q</b>

<p>
then the elements of arrays of type <b>a</b>, will have type <b>q</b> and
will be identified by indices<a name="indices35">
</a> of type <b>p</b> thus:

<p>
<b>b[i]</b>

<p>
where <b>i:p</b>, <b>b:a</b>.

<p>
Given the declaration

<p>
<b>z = string[x]</b>

<p>
for some integer x <b>  <font face="symbol">£</font
> maxstring</b>, then the characters within
strings<a name="strings35">
</a> of type <b>z</b> will be identified by indices in
the range <b>1..x,</b> thus:

<p>
<b>y[j]</b>

<p>
where <b>y:z</b>, <b>j:1..x</b>.

<p>
     <h3><a name="tth_sEc3.5.3">
3.5.3</a>&nbsp;&nbsp;Indexed Ranges</h3>

<p>
A range of components of an array variable are denoted by the variable followed
by a range expression in brackets.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;indexed range&#62;</td><td align="center">&lt;variable&#62; '[' &lt;range expression&#62;[',' &lt;range expression&#62;]* ']'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;range expression&#62;</td><td align="center">&lt;expression&#62; '..' &lt;expression&#62;</td></tr></table>

<p>
</center>The expressions within the range<a name="range35">
</a> expression must conform to the
index type of the array variable. The type of a range expression <b>a[i..j]</b>
where <b>a: array[p..q] of t</b> is <b>array[0..j-i] of t.</b>

<p>
Examples:

<p>
<b>dataset[i..i+2]:=blank;</b>

<p>
<b>twoDdata[2..3,5..6]:=twoDdata[4..5,11..12]*0.5;</b>

<p>
Subranges<a name="Subranges35">
</a> may be passed in as actual parameters to procedures
whose corresponding formal parameters<a name="parameters35">
</a> are declared as variables
of a schematic<a name="schematic35">
</a> type. Hence given the following declarations:

<p>
<b>type image(miny,maxy,minx,maxx:integer)=array[miny..maxy,minx..maxx]
of byte;</b>

<p>
<b>procedure invert(var im:image);begin im:=255-im; end;</b>

<p>
<b>var screen:array[0..319,0..199] of byte;</b>

<p>
then the following statement would be valid:

<p>
<b>invert(screen[40..60,20..30]);</b>

<p>
     <h3><a name="tth_sEc3.5.4">
3.5.4</a>&nbsp;&nbsp;Virtual<a name="Virtual35">
</a> array variables</h3>

<p>
If an array<a name="array35">
</a> variable occurs on the right hand side of an assignment
statement, there is a further form of indexing possible. An array may be indexed
by another array. If <b>x:array[t0] of t1</b> and <b>y:array[t1]
of t2</b>, then <b>y[x]</b> denotes the virtual array of type <b>array[t0]
of t2</b> such that <b>y[x][i]=y[x[i]]</b>. This construct is
useful for performing permutations. To fully understand the following example
refer to sections <a href="#iota">4.1.3</a>,<a href="#implicitindices">4.2.1</a>.

<p>

<b>Example&nbsp;&nbsp;</b>

<p>
Given the declarations

<p>
<b>const perm:array[0..3] of integer=(3,1,2,0);</b>

<p>
<b>var ma,m0:array[0..3] of integer; </b>

<p>
then the statements

<p>
<b>m0:= (iota 0)+1;</b>

<p>
<b>write('m0=');for j:=0 to 3 do write(m0[j]);writeln;</b>

<p>
<b>ma:=m0[perm]; </b>

<p>
<b>write('perm=');for j:=0 to 3 do write(perm[j]);writeln; </b>

<p>
<b>writeln('ma:=m0[perm]');for j:=0 to 3 do write(ma[j]);writeln;</b>

<p>
would produce the output 

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
m0=&nbsp;1&nbsp;2&nbsp;3&nbsp;4

<p>
perm=&nbsp;&nbsp;3&nbsp;1&nbsp;2&nbsp;0&nbsp;

<p>
ma:=m0[perm]&nbsp;

<p>
4&nbsp;2&nbsp;3&nbsp;1
</dd>
</dl>

<p>
     <h3><a name="tth_sEc3.5.5">
3.5.5</a>&nbsp;&nbsp;Field<a name="Field35">
</a> Designators</h3>

<p>
A component of an instance of a record type, or the parameters of an instance
of a schematic type are denoted by the record or schematic type instance followed
by the field or parameter name.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;field designator&#62;</td><td align="center">&lt;variable&#62;'.'&lt;identifier&#62;</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc3.5.6">
3.5.6</a>&nbsp;&nbsp;Referenced Variables<a name="Variables35">
</a></h3>

<p>
If <b>p:t</b>, then <b>p</b> denotes
the dynamic variable of type <b>t</b> referenced by <b>p</b>.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;referenced variable&#62;</td><td align="center">&lt;variable&#62; ''</td></tr></table>

<p>
</center> <h2><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;Procedures and Functions</h2>

<p>
Procedure and function declarations allow algorithms to be identified by name
and have arguments associated with them so that they may be invoked by procedure
statements or function calls. 

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;procedure declaration&#62;</td><td align="center">&lt;procedure heading&#62;';'[&lt;proc tail&#62;]</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;proc tail&#62;</td><td align="center">'forward'</td><td align="center">must be followed by defintion of procedure body</td></tr><tr><td>
<tr><td align="center"></td><td align="center">'external'</td><td align="center">imports a non Pascal prodcedure</td></tr>
<tr><td align="center"></td><td align="center">&lt;block&#62;</td><td align="center">procedure implemented here</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;paramlist&#62;</td><td align="center">'('&lt;formal parameter section&#62;[';'&lt;formal parameter section&#62;]*')'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;procedure heading&#62; </td><td align="center">'procedure' &lt;identifer&#62; [&lt;paramlist&#62;]</td></tr>
<tr><td align="center"></td><td align="center">'function'&lt;identifer&#62; [&lt;paramlist&#62;]':'&lt;type&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;formal parameter section&#62;</td><td align="center">['var']&lt;identifier&#62;[','&lt;identifier&#62;]':'&lt;type&#62;</td></tr></table>

<p>
</center>The parameters declared in the procedure heading are local to the scope of the
procedure. The parameters in the procedure heading are termed formal<a name="formal parameter36">
</a>
parameters. If the identifiers in a formal parameter section are preceded by
the word <b>var</b>, then the formal parameters are termed variable parameters.
The block<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a> of a procedure or function constitutes a scope local to its executable compound
statement. Within a function declaration there must be at least one statement
assigning a value to the function identifier. This assignment determines the
result of a function, but assignment to this identifier does not cause an immediate
return from the function. 

<p>
Function return values can be scalars, pointers, records, strings or sets. Arrays
may not be returned from a function.

<p>

<b>Examples&nbsp;&nbsp;</b>

<p>
The function sba is the mirror image of the abs function.

<p>
<b>function sba(i:integer):integer; </b>

<p>
<b>begin if i&#62;o then sba:=-i else sba:=i end;</b>

<p>
<b>type stack:array[0..100] of integer;</b>

<p>
<b>procedure push(var s:stack;i:integer);</b>

<p>
<b>begin s[s[0]]:=i;s[0]:=s[0]+1; end;</b>

<p>
 <h1><a name="tth_chAp4">
Chapter 4 </a><br>Algorithms</h1>

<p>
 <h2><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Expressions<a name="Expressions41">
</a></h2>

<p>
An expression is a rule for computing a value by the application of operators
and functions to other values. These operators can be <em>monadic</em> - taking
a single argument, or <em>dyadic</em> - taking two arguments. 

<p>
     <h3><a name="tth_sEc4.1.1">
4.1.1</a>&nbsp;&nbsp;Mixed type expressions</h3>

<p>
The arithmetic operators are defined over the base types integer and real. If
a dyadic operator that can take either real<a name="real41">
</a> or integer<a name="integer41">
</a>
arguments is applied to arguments one of which is an integer and the other a
real, the integer argument is first implicitly converted to a real before the
operator is applied. Similarly, if a dyadic operator is applied to two integral
numbers of different precision, the number of lower precision is initially converted
to the higher precisions, and the result is of the higher precision. Higher
precision of types <em>t,u</em> is defined such that if either has the greater
number of 

<p>
     <h3><a name="tth_sEc4.1.2">
4.1.2</a>&nbsp;&nbsp;Primary expressions</h3>

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;primary expression&#62; </td><td align="center">'(' &lt;expression&#62; ')'</td></tr>
<tr><td align="center"></td><td align="center">&lt;literal string&#62;</td></tr>
<tr><td align="center"></td><td align="center">'true'</td></tr>
<tr><td align="center"></td><td align="center">'false'</td></tr>
<tr><td align="center"></td><td align="center">&lt;unsigned integer&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;unsigned real&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;variable&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;constant id&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;function call&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;set construction&#62;</td></tr></table>

<p>
</center>The most primitive expressions are instances of the literals defined in the
language: literal strings, boolean literals, literal reals and literal integers.
'Salerno', <b>true</b>, 12, $ea8f, 1.2e9 are all primary expressions. The
next level of abstraction is provided by symbolic identifiers for values. <b>X</b>,
<b>left</b>, <b>a.max</b>, <b>p.next</b>, <b>z[1]</b>,
<b>image[4..200,100..150]</b> are all primary expressions provided that
the identifiers have been delared as variables or constants.

<p>
An expression surrounded by brackets <b>( )</b> is also a primary expression.
Thus if <em>e</em> is an expression so is <b>(</b> <em>e</em> <b>)</b>. 

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;function call&#62;</td><td align="center">&lt;function id&#62; [ '(' &lt;expression&#62; [,&lt;expression&#62;]* ')' ]</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;element&#62;</td><td align="center">&lt;expression&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;range expression&#62;</td></tr></table>

<p>
</center>Let <em>e</em> be an expression of type  t<sub>1</sub>  and if <b>f</b> is an identifier
of type <b>function<a name="function41">
</a>( t<sub>1</sub>  ): t<sub>2</sub> </b>, then
<b>f(</b> <em>e</em> <b>)</b> is a primary expression of type  t<sub>2</sub> .
A function which takes no parameters is invoked without following its identifier
by brackets. It will be an error if any of the actual parameters supplied to
a function are incompatible with the formal parameters declared for the function.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;set construction&#62;</td><td align="center">'[' [&lt;element&#62;[,&lt;element&#62;]*] ']'</td></tr></table>

<p>
</center>Finally a primary expression may be a set construction. A set construction is
written as a sequence of zero or more elements enclosed in brackets <b>[
]</b> and separated by commas. The elements themselves are either expressions
evaluating to single values or range expressions denoting a sequence of consecutive
values. The type of a set construction is deduced by the compiler from the context
in which it occurs. A set construction occuring on the right hand side of an
assignment inherits the type of the variable to which it is being assigned.
The following are all valid set constructions:

<p>
<b>[], [1..9], [z..j,9], [a,b,c,]</b>

<p>
<b>[]</b> denotes the empty set.

<p>
     <h3><a name="tth_sEc4.1.3">
4.1.3</a>&nbsp;&nbsp;Unary expressions</h3>

<p>
A unary expression is formed by applying a unary operator to another unary or
primary expression. The unary operators supported are <b>+, -, *, /,
div<a name="div41">
</a>, mod<a name="mod41">
</a>, and<a name="and41">
</a>, or<a name="or41">
</a>, not<a name="not41">
</a>,
round<a name="round41">
</a>, sqrt<a name="sqrt41">
</a>, sin<a name="sin41">
</a>, cos<a name="cos41">
</a>, tan<a name="tan41">
</a>,
abs<a name="abs41">
</a>, ln<a name="ln41">
</a>, ord<a name="ord41">
</a>, chr<a name="chr41">
</a>, succ<a name="succ41">
</a>,
pred<a name="pred41">
</a>, iota<a name="iota41">
</a>, trans<a name="trans41">
</a>, addr<a name="addr41">
</a></b>
and <b>@</b><a name="41">
</a>.

<p>
Thus the following are valid unary expressions<b>: -1, +b, not true, sqrt
abs x, sin theta.</b> In standard Pascal some of these operators are treated as
functions,. Syntactically this means that their arguments must be enclosed in
brackets, as in <b>sin(theta)</b>. This usage remains syntactically correct
in Vector Pascal. 

<p>
The dyadic operators <b>+, -, *, /, div, mod , and or</b> are all extended
to unary context by the insertion of an implicit value under the operation.
Thus just as <b>-a = 0-a</b> so too <b>/2 = 1/2</b>. For sets the notation
<b>-s</b> means the complement of the set <b>s</b>. The implicit value inserted
are given below.

<p>
<center> 
<table border="1">
<tr><td align="center">type</td><td align="center">operators</td><td align="center">implicit value</td></tr><tr><td>
<tr><td align="center">number</td><td align="center">+,-</td><td align="center">0</td></tr>
<tr><td align="center">set<a name="set41">
</a></td><td align="center">+</td><td align="center">empty set</td></tr>
<tr><td align="center">set</td><td align="center">-,*</td><td align="center">fullset</td></tr>
<tr><td align="center">number</td><td align="center">*,/ ,div,mod</td><td align="center">1</td></tr>
<tr><td align="center">boolean<a name="boolean41">
</a></td><td align="center">and</td><td align="center">true</td></tr>
<tr><td align="center">boolean</td><td align="center">or </td><td align="center">false</td></tr></table>

<p>
</center>A unary operator can be applied to an array<a name="array41">
</a> argument and returns
an array result. Similarly any user declared function over a scalar<a name="scalar41">
</a>
type can be applied to an array type and return an array. If <b>f</b> is a
function or unary operator mapping from type <b>r</b> to type <b>t</b> then
if <b>x</b> is an array of <b>r,</b> and <b>a</b> an array of <b>t</b>,
then <b>a:=f(x)</b> assigns an array of <b>t</b> such that <b>a[i]=f(x[i])</b>

<p>
<center> 
<table border="1">
<tr><td align="center">lhs of production</td><td align="center">rhs</td><td>meaning</td></tr>
<tr><td align="center">&lt;unaryop&#62;</td><td align="center">'+'</td><td><b>+x = 0+x</b></td></tr>
<tr><td align="center"></td><td align="center">'-'</td><td><b>-x = 0-x</b></td></tr>
<tr><td align="center"></td><td align="center">'*'</td><td><b>*x=1*x</b></td></tr>
<tr><td align="center"></td><td align="center">'/'</td><td><b>/x=1.0/x</b></td></tr>
<tr><td align="center"></td><td align="center">'div'</td><td><b>div x =1 div x</b></td></tr>
<tr><td align="center"></td><td align="center">'mod'</td><td><b>mod x = 1 mod x</b></td></tr>
<tr><td align="center"></td><td align="center">'and'</td><td><b>and x = true and x</b></td></tr>
<tr><td align="center"></td><td align="center">'or'</td><td><b>or x = false or x</b></td></tr>
<tr><td align="center"></td><td align="center">'not'</td><td>complements booleans</td></tr>
<tr><td align="center"></td><td align="center">'round'</td><td>rounds a real to the closest integer</td></tr>
<tr><td align="center"></td><td align="center">'sqrt'</td><td>returns square root as a real<a name="real41">
</a> number.</td></tr>
<tr><td align="center"></td><td align="center">'sin'</td><td>sine of its argument. Argument in radians. Result is real.</td></tr>
<tr><td align="center"></td><td align="center">'cos'</td><td>cosine of its argument. Argument in radians. Result is real.</td></tr>
<tr><td align="center"></td><td align="center">'tan'</td><td>tangent of its argument. Argument in radians. Result is real.</td></tr>
<tr><td align="center"></td><td align="center">'abs'</td><td>if <b>x&lt;0</b> then <b>abs x = -x</b> else <b>abs x= x</b></td></tr>
<tr><td align="center"></td><td align="center">'ln'</td><td> log<sub>e</sub>  of its argument. Result is real.</td></tr>
<tr><td align="center"></td><td align="center">'ord'</td><td>argument of ordinal type, the returns ordinal number of the argument.</td></tr>
<tr><td align="center"></td><td align="center">'chr'</td><td>converts an integer<a name="integer41">
</a> into a character<a name="character41">
</a>.</td></tr>
<tr><td align="center"></td><td align="center">'succ'</td><td>argument of ordinal type, returns the next ordinal in the type.</td></tr>
<tr><td align="center"></td><td align="center">'pred'</td><td>argument of ordinal type it returns the previous ordinal in the type.</td></tr>
<tr><td align="center"></td><td align="center">'iota'</td><td><b>iota i</b> returns the <b>i</b>th current index<a name="index41">
</a></td></tr>
<tr><td align="center"></td><td align="center">'trans'</td><td>transposes a matrix<a name="matrix41">
</a> or vector<a name="vector41">
</a></td></tr>
<tr><td align="center"></td><td align="center">'@','addr'</td><td>Given a variable, this returns an untyped pointer<a name="pointer41">
</a> to the variable.</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;unary expression&#62;</td><td align="center">&lt;unaryop&#62; &lt;unary expression&#62;</td></tr>
<tr><td align="center"></td><td align="center">'sizeof' '(' &lt;type&#62; ')'</td></tr>
<tr><td align="center"></td><td align="center">&lt;operator reduction&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;primary expression&#62;</td></tr></table>

<p>
</center>
<h4>sizeof</h4>

<p>
The construct <b>sizeof<a name="sizeof41">
</a>(</b> <em>t</em> <b>)</b> where <em>t</em>
is a type, returns the number of bytes<a name="bytes41">
</a> occupied by an instance
of the type.

<p>

<h4>iota<a name="iota">
</a></h4>

<p>
The operator iota i returns the ith current implicit index<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>. 

<p>

<b>Examples&nbsp;&nbsp;</b>

<p>
Thus given the definition bold v1:array[1..3]of integer; v2:array[0..4]of
integer;

<p>
the program fragment

<p>
Standard<b>writeln('v1'); for i:=1 to 3 do write( v1[i]); writeln; </b>

<p>
<b>v2:=iota 0 *2;</b>

<p>
would produce the output: 

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
v1&nbsp;

<p>
1&nbsp;2&nbsp;3&nbsp;

<p>
v2&nbsp;

<p>
0&nbsp;2&nbsp;4&nbsp;6&nbsp;8
</dd>
</dl>
whilst given the definitions

<p>
<b>m1:array[1..3,0..4] of integer;m2:array[0..4,1..3]of integer;</b>

<p>
then the program fragment 

<p>
<b>m2:= iota 0 +2*iota 1; </b>

<p>
<b>writeln('m2:= iota 0 +2*iota 1 '); </b>

<p>
<b>for i:=0 to 4 do begin for j:=1 to 3 do write(m2[i,j]); writeln;
end; </b>

<p>
would produce the output

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
m2:=&nbsp;iota&nbsp;0&nbsp;+2*iota&nbsp;1&nbsp;

<p>
2&nbsp;4&nbsp;6&nbsp;

<p>
3&nbsp;5&nbsp;7&nbsp;

<p>
4&nbsp;6&nbsp;8&nbsp;

<p>
5&nbsp;7&nbsp;9&nbsp;

<p>
6&nbsp;8&nbsp;10&nbsp;&nbsp;
</dd>
</dl>
The argument to iota<a name="iota41">
</a> must be an integer known at compile time within
the range of implicit indices in the current context.

<p>

<h4>trans</h4>

<p>
The operator trans<a name="trans41">
</a> transposes a vector or matrix. It achieves
this by cyclic rotation of the implicit indices<a name="indices41">
</a><a name="implicit indices41">
</a>.
Thus if <b>trans</b> <em>e</em> is evaluated in a context with implicit indices 

<p>
<b>iota</b> <em>0</em>.. <b>iota</b> <em>n </em>

<p>
then the expression e is evaluated in a context with implicit indices 

<p>
<b>iota</b>'<em>0</em>.. <b>iota</b>'<em>n</em> 

<p>
where 

<p>
<b>iota</b>'<em>x</em> = <b>iota</b> ( (<em>x+1</em>)<b>mod</b> <em>n+1</em>)

<p>
It should be noted that transposition is generalised to arrays of rank greater
than 2.

<p>

<b>Examples&nbsp;&nbsp;</b>

<p>
Given the defintions used above in section <a href="#iota">4.1.3</a>, the program fragment:

<p>
<b>m1:= (trans v1)*v2; </b>

<p>
<b>writeln('(trans v1)*v2'); </b>

<p>
<b>for i:=1 to 3 do begin for j:=0 to 4 do write(m1[i,j]); writeln;
end; </b>

<p>
<b>m2 := trans m1; </b>

<p>
<b>writeln('transpose 1..3,0..4 matrix'); </b>

<p>
<b>for i:=0 to 4 do begin for j:=1 to 3 do write(m2[i,j]); writeln;
end;</b>

<p>
will produce the output:

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
(trans&nbsp;v1)*v2&nbsp;

<p>
0&nbsp;&nbsp;2&nbsp;&nbsp;4&nbsp;&nbsp;6&nbsp;&nbsp;8&nbsp;

<p>
0&nbsp;&nbsp;4&nbsp;&nbsp;8&nbsp;12&nbsp;16&nbsp;

<p>
0&nbsp;&nbsp;6&nbsp;12&nbsp;18&nbsp;24&nbsp;

<p>
transpose&nbsp;1..3,0..4&nbsp;matrix&nbsp;

<p>
0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;

<p>
2&nbsp;&nbsp;4&nbsp;&nbsp;6&nbsp;

<p>
4&nbsp;&nbsp;8&nbsp;12&nbsp;

<p>
6&nbsp;12&nbsp;18&nbsp;

<p>
8&nbsp;16&nbsp;24
</dd>
</dl>

<p>

<h4>Operator Reduction</h4>

<p>
Any dyadic operator can be converted to a monadic<a name="monadic41">
</a> reduction<a name="reduction41">
</a>
operator by the functional . Thus if <b>a</b> is an array,
<b>+a</b> denotes the sum over the array. More generally  \<font face="symbol">F</font
>x 
for some dyadic operator  <font face="symbol">F</font
> means  x<sub>0</sub><font face="symbol">F</font
>(x<sub>1</sub><font face="symbol">F</font
>..(x<sub>n</sub><font face="symbol">F</font
><font face="symbol">i</font
>)) 
where  <font face="symbol">i</font
> is the implicit value given the operator and the type. Thus
we can write + for  <font face="symbol">å</font
>, * for  <font face="symbol">Õ</font
>
etc. The dot product of two vectors can thus be written as

<p>
<b>x:= + y*z;</b>

<p>
instead of

<p>
<b>x:=0;</b>

<p>
<b>for i:=0 to n do x:= x+ y[i]*z[i];</b>

<p>
A reduction operation takes an argument of rank<a name="rank41">
</a> <em>r</em> and returns
an argument of rank <em>r-1</em> except in the case where its argument is or rank
0, in which case it acts as the identity operation. Reduction is always performed
along the last array<a name="array41">
</a> dimension<a name="dimension41">
</a> of its argument. 

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;operator reduction&#62;</td><td align="center">''&lt;dyadicop&#62; &lt;multiplicative expression&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;dyadicop&#62;</td><td align="center">&lt;expop&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;multop&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;addop&#62;</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc4.1.4">
4.1.4</a>&nbsp;&nbsp;Factor<a name="Factor41">
</a></h3>

<p>
A factor is an expression that optionally performs exponentiation. Vector Pascal
supports exponentiation either by integer exponents or by real exponents. A
number <em>x</em> can be raised to an integral power <em>y</em> by using the construction
<em>x</em> <b>pow<a name="pow41">
</a></b> <em>y</em>. A number can be raised to an arbitrary
real power by the <b>**</b> operator. The result of <b>**<a name="**41">
</a></b>
is always real valued.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;expop&#62;</td><td align="center">'pow'</td></tr>
<tr><td align="center"></td><td align="center">'**'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;factor&#62;</td><td align="center">&lt;unary expression&#62; [ &lt;expop&#62; &lt;unary expression&#62;]</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc4.1.5">
4.1.5</a>&nbsp;&nbsp;Multiplicative expressions</h3>

<p>
Multiplicative expressions consist of factors linked by the multiplicative operators
<b>*, /, div<a name="div41">
</a>, mod<a name="mod41">
</a>, shr<a name="shr41">
</a>, shl<a name="shl41">
</a>
and</b><a name="and41">
</a>. The use of these operators is sumarised in table <a href="#multop">4.1</a>.

<p>

<p>
<a name="tth_tAb4.1">
</a> <center>Table 4.1: Multiplicative operators<a name="multop">
</a></center>
<center> 
<table>
<tr><td align="center">Operator</td><td align="center">Left</td><td align="center">Right</td><td align="center">Result</td><td align="center">Effect of <em>a</em> <b>op</b> <em>b</em></td></tr>
<tr><td align="center"><b>*</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">multiply</td></tr>
<tr><td align="center"></td><td align="center">real</td><td align="center">real</td><td align="center">real</td><td align="center">multiply</td></tr>
<tr><td align="center"><b>/</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">real</td><td align="center">division</td></tr>
<tr><td align="center"></td><td align="center">real</td><td align="center">real</td><td align="center">real</td><td align="center">division</td></tr>
<tr><td align="center"><b>div</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">division</td></tr>
<tr><td align="center"><b>mod</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">remainder</td></tr>
<tr><td align="center"><b>and</b></td><td align="center">boolean</td><td align="center">boolean</td><td align="center">boolean</td><td align="center">logical and</td></tr>
<tr><td align="center"><b>shr</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">shift <em>a</em> by <em>b</em> bits right</td></tr>
<tr><td align="center"><b>shl</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">shift <em>a</em> by <em>b</em> bits left</td></tr>
<tr><td align="center"><b>in</b></td><td align="center"><em>t</em></td><td align="center"><b>set of</b> <em>t</em></td><td align="center">boolean</td><td align="center">true if <em>a</em> is member of <em>b</em></td></tr></table>

<p>
</center>
<p>
<center> 
<table border="1">
<tr><td align="center">&lt;multop&#62;</td><td align="center">'*'</td></tr>
<tr><td align="center"></td><td align="center">'/'</td></tr>
<tr><td align="center"></td><td align="center">'div'</td></tr>
<tr><td align="center"></td><td align="center">'shr'</td></tr>
<tr><td align="center"></td><td align="center">'shl'</td></tr>
<tr><td align="center"></td><td align="center">'and'</td></tr>
<tr><td align="center"></td><td align="center">'mod'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;multiplicative expression&#62;</td><td align="center">&lt;factor&#62; [ &lt;multop&#62; &lt;factor&#62; ]*</td></tr>
<tr><td align="center"></td><td align="center">&lt;factor&#62;'in'&lt;multiplicative expression&#62;</td></tr></table>

<p>
</center>
<h4>Additive expressions</h4>

<p>
An additive expression allows multiplicative expressions to be combined using
the addition operators <b>+<a name="+41">
</a>, -<a name="-41">
</a>, or, +:<a name="+:41">
</a><a name="or41">
</a>,
-:</b><a name="-:41">
</a>. The additive operations are sumarised in table<a href="#addops">4.2</a>
.

<p>

<p>
<a name="tth_tAb4.2">
</a> <center>Table 4.2: Addition operations<a name="addops">
</a></center>
<center> 
<table>
<tr><td align="center">Operation</td><td align="center">Left</td><td align="center">Right</td><td align="center">Result</td><td align="center">Effect of <em>a</em> <b>op</b> <em>b</em></td></tr><tr><td>
<tr><td align="center"><b>+</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">sum of <em>a</em> and <em>b</em></td></tr>
<tr><td align="center"></td><td align="center">real</td><td align="center">real</td><td align="center">real</td><td align="center">sum of <em>a</em> and <em>b</em></td></tr>
<tr><td align="center"></td><td align="center">set</td><td align="center">set</td><td align="center">set</td><td align="center">union of <em>a</em> and <em>b</em></td></tr>
<tr><td align="center"><b>-</b></td><td align="center">integer</td><td align="center">integer</td><td align="center">integer</td><td align="center">result of subtracting <em>b</em> from <em>a</em></td></tr>
<tr><td align="center"></td><td align="center">real</td><td align="center">real</td><td align="center">real</td><td align="center">result of subtracting <em>b</em> from <em>a</em></td></tr>
<tr><td align="center"></td><td align="center">set</td><td align="center">set</td><td align="center">set</td><td align="center">complement of <em>b</em> relative to <em>a</em></td></tr>
<tr><td align="center"><b>+:</b></td><td align="center">0..255</td><td align="center">0..255</td><td align="center">0..255</td><td align="center">saturated addition cliped to 0..255 </td></tr>
<tr><td align="center"></td><td align="center">-128..127</td><td align="center">-128..127</td><td align="center">-128..127</td><td align="center">saturated addition clipped to -128..127</td></tr>
<tr><td align="center"><b>-:</b></td><td align="center">0..255</td><td align="center">0..255</td><td align="center">0..255</td><td align="center">saturated subtraction clipped to 0..255</td></tr>
<tr><td align="center"></td><td align="center">-128..127</td><td align="center">-128..127</td><td align="center">-128..127</td><td align="center">saturated subtraction clippled to -128..127</td></tr>
<tr><td align="center"><b>or</b></td><td align="center">boolean</td><td align="center">boolean</td><td align="center">boolean</td><td align="center">logical or</td></tr></table>

<p>
</center>
<p>
<center> 
<table border="1">
<tr><td align="center">&lt;addop&#62;</td><td align="center">'+'</td></tr>
<tr><td align="center"></td><td align="center">'-'</td></tr>
<tr><td align="center"></td><td align="center">'or'</td></tr>
<tr><td align="center"></td><td align="center">'+:'</td></tr>
<tr><td align="center"></td><td align="center">'-:'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;additive expression&#62;</td><td align="center">&lt;multiplicative expression&#62; [ &lt;addop&#62; &lt;multiplicative expression&#62; ]*</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;expression&#62;</td><td align="center">&lt;additive expression&#62; &lt;relational operator&#62; &lt;expression&#62;</td></tr></table>

<p>
</center> <h2><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Statements</h2>

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;statement&#62;</td><td align="center">&lt;variable&#62;':='&lt;expression&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;procedure statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;empty statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">'goto' &lt;label&#62;;</td></tr>
<tr><td align="center"></td><td align="center">'begin' &lt;statement&#62;[;&lt;statement&#62;]*'end'</td></tr>
<tr><td align="center"></td><td align="center">'if'&lt;expression&#62;'then'&lt;statement&#62;['else'&lt;statement&#62;]</td></tr>
<tr><td align="center"></td><td align="center">&lt;case statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">'for' &lt;variable&#62;:= &lt;expression&#62; 'to' &lt;expression&#62; 'do' &lt;statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">'for' &lt;variable&#62;:= &lt;expression&#62; 'downto' &lt;expression&#62; 'do' &lt;statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">'repeat' &lt;statement&#62; 'until' &lt;expression&#62;</td></tr>
<tr><td align="center"></td><td align="center">'with' &lt;record variable&#62; 'do' &lt; statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;io statement&#62;</td></tr>
<tr><td align="center"></td><td align="center">'while' &lt;expression&#62; 'do' &lt;statement&#62;</td></tr></table>

<p>
</center>     <h3><a name="tth_sEc4.2.1">
4.2.1</a>&nbsp;&nbsp;Assignment<a name="assignment">
</a></h3>

<p>
An assignment replaces the current value of a variable by a new value specified
by an expression. The assignment operator<a name="operator42">
</a> is<a name="is42">
</a> :=<a name=":=42">
</a>.
Standard Pascal allows assignment<a name="assignment42">
</a> of whole arrays<a name="array42">
</a>.
Vector Pascal extends this to allow consistent use of mixed rank<a name="rank42">
</a>
expressions on the right hand side of an assignment. Given

<p>
<b>r0:real; r1:array[0..7] of real; r2:array[0..7,0..7] of real</b>

<p>
then we can write

<p>

<ol type="1"><p>
<li> r<b>1:= r2[3]; { supported in standard Pascal }</b></li>
<p>
<li> <b>r1:= /2; { assign 0.5 to each element of r1 }</b></li>
<p>
<li> <b>r2:= r1*3; { assign 1.5 to every element of r2}</b></li>
<p>
<li> <b>r1:= + r2; { r1gets the totals along the rows of r2}</b></li>
<p>
<li> <b>r1:= r1+r2[1];{ r1 gets the corresponding elements of row 1 of
r2 added to it}</b></li>
</ol>
The assignment of arrays is a generalisation of what standard Pascal allows.
Consider the first examples above, they are equivalent to:

<p>

<ol type="1"><p>
<li> <b>for i:=0 to 7 do r1[i]:=r2[3,i];</b></li>
<p>
<li> <b>for i:=0 to 7 do r1[i]:=/2;</b></li>
<p>
<li> <b>for i:=0 to 7 do for j:=0 to 7 do r2[i,j]:=r1[j]*3;</b></li>
<p>
<li> <b>for i:=0 to 7 do begin t:=0; for j:=7 downto 0 do t:=r2[i,j]+t;
r1[i]:=t; end;</b></li>
<p>
<li> <b>for i:=0 to 7 do r1[i]:=r1[i]+r2[1,i];</b></li>
</ol>
In other words the compiler has to generate an implicit loop<a name="loop42">
</a> over
the elements of the array being assigned to and over the elements of the array
acting as the data-source. In the above <b>i,j,t</b> are assumed to be temporary
variables not refered to anywhere else in the program. The loop variables are
called implicit indices<a name="indices42">
</a><a name="implicit indices42">
</a> <a name="implicitindices">
</a>and
may be accessed using <b>iota</b>. 

<p>
The variable on the left hand side of an assignment defines an array<a name="array42">
</a>
context within which expressions on the right hand side are evaluated. Each
array context has a rank given by the number of dimensions<a name="dimensions42">
</a>
of the array on the left hand side. A scalar variable has rank<a name="rank42">
</a>
0. Variables occuring in expressions with an array context of rank <em>r</em>
must have <em>r</em> or fewer dimensions. The <em>n</em> bounds of any <em>n</em>
dimensional array variable, with  n <font face="symbol">£</font
> r  occuring within an expression
evaluated in an array context of rank <em>r</em> must match with the rightmost
<em>n</em> bounds of the array on the left hand side of the assignment statement. 

<p>
Where a variable is of lower rank than its array context, the variable is replicated
to fill the array context<a name="array context42">
</a>. This is shown in examples 2
and 3 above. Because the rank of any assignment is constrained by the variable
on the left hand side, no temporary arrays, other than machine registers, need
be allocated to store the intermediate array results of expressions.

<p>
     <h3><a name="tth_sEc4.2.2">
4.2.2</a>&nbsp;&nbsp;Procedure statement</h3>

<p>
A procedure statement executes a named procedure<a name="procedure42">
</a>. A procedure
statement may, in the case where the named procedure has formal parameters,
contain a list of actual parameters. These are substituted in place of the formal
parameters contained in the declaration. Parameters may be value parameters
or variable parameters. 

<p>
Semantically the effect of a value parameter is that a copy is taken of the
actual parameter<a name="parameter42">
</a> and this copy substituted into the body of
the procedure. Value parameters may be structured values such as records and
arrays. For scalar values, expressions may be passed as actual parameters. Array
expressions are not currently allowed as actual parameters. 

<p>
A variable parameter is passed by reference, and any alteration of the formal
parameter induces a corresponding change in the actual parameter. Actual variable
parameters must be variables.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;parameter&#62;</td><td align="center">&lt;variable&#62;</td><td align="center">for formal parameters declared as var</td></tr>
<tr><td align="center"></td><td align="center">&lt;expression&#62;</td><td align="center">for other formal parameters </td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;procedure statement&#62;</td><td align="center">&lt;identifier&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;identifier&#62; '(' &lt;parameter&#62; [','&lt;parameter&#62;]* ')'</td></tr></table>

<p>
</center>
<b>Examples&nbsp;&nbsp;</b>

<p>

<ol type="1"><p>
<li> <b>printlist;</b></li>
<p>
<li> <b>compare(avec,bvec,result);</b></li>
</ol>

<p>
     <h3><a name="tth_sEc4.2.3">
4.2.3</a>&nbsp;&nbsp;Goto statement</h3>

<p>
A goto statement transfers control to a labelled statement. The destination
label must be declared in a label<a name="label42">
</a> declaration. It is illegal to
jump into or out of a procedure.

<p>

<b>Example&nbsp;&nbsp;</b>

<p>
<b>goto<a name="goto42">
</a> 99;</b>

<p>
     <h3><a name="tth_sEc4.2.4">
4.2.4</a>&nbsp;&nbsp;Compound statement</h3>

<p>
A list of statements separated by semicolons may be grouped into a compound
statement by bracketing them wth <b>begin</b> and <b>end</b> .

<p>

<b>Example&nbsp;&nbsp;</b>

<p>
<b>begin<a name="begin42">
</a> a:=x*3; b:=sqrt a end<a name="end42">
</a>;</b>

<p>
     <h3><a name="tth_sEc4.2.5">
4.2.5</a>&nbsp;&nbsp;If statement</h3>

<p>
The basic control flow construct is the if statemen. If the boolean expression
between <b>if<a name="if42">
</a></b> and <b>then<a name="then42">
</a></b> is true then the
statement following <b>then</b> is followed. If it is false and an else part
is present, the statement following <b>else<a name="else42">
</a></b> is executed. 

<p>
     <h3><a name="tth_sEc4.2.6">
4.2.6</a>&nbsp;&nbsp;Case statement</h3>

<p>
The case<a name="case42">
</a> statement specifies an expression which is evaluated and
which must be of integral or ordinal type. Dependent upon the value of the expression
control transfers to the statement labeled by the matching constant.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;case statement&#62;</td><td align="center">'case'&lt;expression&#62;'of'&lt;caselist&#62;'end'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;caselist&#62;</td><td align="center">&lt;caselist element&#62;[';'&lt;caselist element.]*</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;caselist element&#62;</td><td align="center">&lt;caselabel&#62;[',' &lt;caselabel&#62;]':'&lt;statement&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;caselabel&#62;</td><td align="center">&lt;constant&#62;</td></tr>
<tr><td align="center"></td><td align="center">&lt;constant&#62; '..' &lt;constant&#62;</td></tr></table>

<p>
</center>
<b>Examples&nbsp;&nbsp;</b>

<p>
 
<table>
<tr><td><b>case</b> i <b>of</b></td><td><b>case</b> c <b>of</b></td></tr>
<tr><td><b>1:s:=abs s;</b></td><td><b>'a':write('A');</b></td></tr>
<tr><td><b>2:s:= sqrt s;</b></td><td><b>'b','B':write('B');</b></td></tr>
<tr><td><b>3: s:=0</b></td><td><b>'A','C'..'Z','c'..'z':write(' ');</b></td></tr>
<tr><td><b>end</b></td><td><b>end</b></td></tr></table>

<p>
     <h3><a name="tth_sEc4.2.7">
4.2.7</a>&nbsp;&nbsp;With statement</h3>

<p>
The within the component statement of the with<a name="with42">
</a> statement the fields
of the record variable can be refered to without prefixing them by the name
of the record variable. The effect is to import the component statement into
the scope defined by the record<a name="record42">
</a> variable declaration so that
the fieldnames appear as simple variable names.

<p>

<b>Example&nbsp;&nbsp;</b>

<p>
<b>var s:record x,y:real end;</b>

<p>
<b>begin</b>

<p>
<b>with s do begin x:=0;y:=1 end ;</b>

<p>
<b>end</b>

<p>
     <h3><a name="tth_sEc4.2.8">
4.2.8</a>&nbsp;&nbsp;For statement</h3>

<p>
A for<a name="for42">
</a> statement executes its component statement repeatedly under
the control of an iteration<a name="iteration42">
</a> variable. The iteration variable
must be of an integral or ordinal type. The variable is either set to count
up through a range or down through a range.

<p>
<b>for i:= e1 to<a name="to42">
</a> e2 do s</b>

<p>
is eqivalent to

<p>
<b>i:=e1; temp:=e2;while i&lt;=temp do s;</b>

<p>
whilst

<p>
<b>for i:= e1 downto<a name="downto42">
</a> e2 do s</b>

<p>
is equivalent to

<p>
<b>i:=e1; temp:=e2;while i&#62;= temp do s;</b>

<p>
     <h3><a name="tth_sEc4.2.9">
4.2.9</a>&nbsp;&nbsp;While statement</h3>

<p>
A while<a name="while42">
</a> statement executes its component statement whilst its
boolean expression is true. The statement

<p>
<b>while e do s</b>

<p>
is equivalent to

<p>
<b>10: if not e then goto 99; s; goto 10; 99:</b>

<p>
     <h3><a name="tth_sEc4.2.10">
4.2.10</a>&nbsp;&nbsp;Repeat statement</h3>

<p>
A repeat<a name="repeat42">
</a> statement executes its component statement at least
once, and then continues to execute the component statement until its component
expression becomes true.

<p>
<b>repeat s until e</b>

<p>
is equivalent to

<p>
<b>10: s;if e then goto 99; goto 10;99:</b>

<p>
 <h2><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Input Output </h2>

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;io statement&#62;</td><td align="center">'writeln'[&lt;outparamlist&#62;]</td></tr>
<tr><td align="center"></td><td align="center">'write'&lt;outparamlist&#62;</td></tr>
<tr><td align="center"></td><td align="center">'readln'[&lt;inparamlist&#62;]</td></tr>
<tr><td align="center"></td><td align="center">'read'&lt;inparamlist&#62;</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;outparamlist&#62;</td><td align="center">'('&lt;outparam&#62;[','&lt;outparam&#62;]*')'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;outparam&#62;</td><td align="center">&lt;expression&#62;[':' &lt;expression&#62;] [':'&lt;expression&#62;] </td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;inparamlist&#62;</td><td align="center">'('&lt;variable&#62;[','&lt;variable&#62;]*')'</td></tr></table>

<p>
</center>Input and output are supported from and to the console and also from and to
files. 

<p>
     <h3><a name="tth_sEc4.3.1">
4.3.1</a>&nbsp;&nbsp;Input</h3>

<p>
The basic form of input is the <b>read</b> statement. This takes a list of
parameters the first of which may optionally be a file variable. If this file
variable is present it is the input file. In the absence of a leading file variable
the intput file is the keyboard. The parameters take the form of variables into
which appropriate translations of testual representations of values in the file
are read. The statement 

<p>
<b>read<a name="read43">
</a>(</b><em>a,b,c</em><b>) </b>

<p>
where <em>a,b,c</em> are non file parameters is exactly equivalent to the sequence
of statements 

<p>
<b>read(</b><em>a</em><b>);read(</b><em>b</em><b>);read(</b><em>c</em><b>) </b>

<p>
The <b>readln</b><a name="readln43">
</a> statement has the same effect as the read
statement but finishes by reading a new line from the input file. The representation
of the new line is operating system dependent. The statement 

<p>
<b>readln(</b><em>a,b,c</em><b>) </b>

<p>
where <em>a,b,c</em> are non file parameters is thus exactly equivalent to the
sequence of statements 

<p>
<b>read(</b><em>a</em><b>);read(</b><em>b</em><b>);read(</b><em>c</em><b>);readln; </b>

<p>
     <h3><a name="tth_sEc4.3.2">
4.3.2</a>&nbsp;&nbsp;Output </h3>

<p>
The basic form of output is the <b>write<a name="write43">
</a></b> statement. This
takes a list of parameters the first of which may optionally be a file variable.
If this file variable is present it is the output file. In the absence of a
leading file variable the output file is the console. The parameters take the
form of expressions whose values whose textual representations are written to
the output file. The statement 

<p>
<b>write(</b><em>a,b,c</em><b>) </b>

<p>
where <em>a,b,c</em> are non file parameters is exactly equivalent to the sequence
of statements 

<p>
<b>write(</b><em>a</em><b>);write(</b><em>b</em><b>);write(</b><em>c</em><b>) </b>

<p>
The <b>writeln<a name="writeln43">
</a></b> statement has the same effect as the write
statement but finishes by writing a new line to the output file. The representation
of the new line is operating system dependent. The statement 

<p>
<b>writeln(</b><em>a,b,c</em><b>) </b>

<p>
where <em>a,b,c</em> are non file parameters is thus exactly equivalent to the
sequence of statements 

<p>
<b>write(</b><em>a</em><b>);write(</b><em>b</em><b>);write(</b><em>c</em><b>);writeln; </b>

<p>

<h4>Parameter formating<a name="formating43">
</a> </h4>

<p>
A non file parameter can be followed by up to two integer expressions prefixed
by colons which specify the field widths to be used in the output. The write
parameters can thus have the following forms: 

<p>
<em>e e</em>:<em>m e</em>:<em>m</em>:<em>n </em>

<p>

<ol type="1"><p>
<li> If <em>e</em> is an integral type its decimal expansion will be written preceeded
by sufficient blanks to ensure that the total textual field width produced is
not less than <em>m</em>.</li>
<p>
<li> If <em>e</em> is a real its decimal expansion will be written preceeded by sufficient
blanks to ensure that the total textual field width produced is not less than
<em>m</em>. If <em>n</em> is present the total number of digits after the decimal
point will be <em>n</em>. If <em>n</em> is ommited then the number will be written
out in exponent and mantissa form with 6 digits after the decimal point</li>
<p>
<li> If <em>e</em> is boolean the strings 'true' or 'false' will be written into a
field of width not less than m.</li>
<p>
<li> If <em>e</em> is a string then the string will be written into a field of width
not less than <em>m</em>.</li>
</ol>

<p>
 <h1><a name="tth_chAp5">
Chapter 5 </a><br>Programs and Units</h1>

<p>
Vector Pascal supports the popular system of separate compilation units<a name="units50">
</a>
found in Turbo<a name="Turbo Pascal50">
</a> Pascal. A compilation unit can be either
a program, a unit or a library<a name="library50">
</a>.

<p>
<center> 
<table border="1">
<tr><td align="center">&lt;program&#62;</td><td align="center">'program' &lt;identifier&#62;';'[&lt;uses&#62;';']&lt;block&#62;'.'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;uses&#62;</td><td align="center">'uses' &lt;identifer&#62;[','&lt;identifier&#62;]</td></tr></table>

<p>
</center><center> 
<table border="1"><a name="block">
</a>
<tr><td align="center">&lt;block&#62;</td><td align="center">[&lt;decls&#62;';']*'begin' &lt;statement&#62;[';'&lt;statement&#62;]*'end'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;decls&#62;</td><td align="center">'const' &lt;constant declaration&#62;[';'&lt;constant declaration&#62;]*</td></tr>
<tr><td align="center"></td><td align="center">'type'&lt;type defintion&#62;[';'&lt;type defintion&#62;]*</td></tr>
<tr><td align="center"></td><td align="center">'label' &lt;label&#62;[',' &lt;label&#62;]</td></tr>
<tr><td align="center"></td><td align="center">&lt;procedure declaration&#62;</td></tr>
<tr><td align="center"></td><td align="center">'var' &lt;variable declaration&#62;[ ';' &lt;variable declaration&#62; ]</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;unit&#62;</td><td align="center">&lt;unittype&#62; &lt;identifer&#62;'interface' &lt;decls&#62;&lt;uses&#62; 'implementation'&lt;block&#62;'.'</td></tr></table>

<p>
</center><center> 
<table border="1">
<tr><td align="center">&lt;unittype&#62;</td><td align="center">'unit'</td></tr>
<tr><td align="center"></td><td align="center">'library'</td></tr></table>

<p>
</center>An executable compilation unit must be declared as a program<a name="program50">
</a>.
The program can use several other compilation units all of which must be either
units or libraries. The units or libraries that it directly uses are specified
by a list of identifiers in an optional use list at the start of the program.
A unit or libray has two declaration portions and an executable block. 

<p>
 <h2><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;The export of identifiers from units</h2>

<p>
The first declaration portion is the interface part and is preceded by the reserved
word <b>interface</b><a name="interface51">
</a>.

<p>
The definitions in the interface section of unit files constitute a sequence
of enclosing scopes, such that successive units in the with list ever more closely
contain the program itself. Thus when resolving an identifier, if the identifier
can not be resolved within the program scope, the declaration of the identifier
within the interface section of the rightmost unit in the uses list is taken
as the defining occurence. It follows that rightmost occurence of an identifier
definition within the interface parts of units on the uses list overides all
occurences in interface parts of units to its left in the uses list.

<p>
The implementation part of a unit consists of declarations<a name="declarations51">
</a>,
preceded by the reserved word <b>implementatio</b>n<a name="implementation51">
</a>
that are private to the unit with the exception that a function or procedure
declared in an interface context can ommit the procedure body, provided that
the function or procedure is redeclared in the implementation part of the unit.
In that case the function or procedure heading given in the interface part is
taken to refer to the function or procedure of the same name whose body is declared
in the implementation part. The function or procedure headings sharing the same
name in the interface and implementation parts must correspond with respect
to parameter types, parameter order and, in the case of functions, with respect
to return types.

<p>
A unit may itself contain a use list, which is treated in the same way as the
use lists of a program. That is to say, the use list of a unit makes accessible
identifiers declared within the interface parts of the units named within the
use list to the unit itself.

<p>
     <h3><a name="tth_sEc5.1.1">
5.1.1</a>&nbsp;&nbsp;The export of procedures from libraries.</h3>

<p>
If a compilation unit is prefixed by the reserved word <b>library</b> rather
than the words <b>program</b> or <b>unit</b>, then the procedure and function
declarations in its interface part are made accessible to routines written in
other languages. 

<p>
 <h2><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;The invocation of programs and units</h2>

<p>
Programs and units contain an executable block<a name="block52">
</a>. The rules for
the execution of these are as follows: 

<p>

<ol type="1"><p>
<li> When a program is invoked by the operating system, the units or libraries in
its use list are invoked first followed by the executable block of the program
itself.</li>
<p>
<li> When a unit or library is invoked, the units or libraries in its use list are
invoked first followed by the executable block of the unit or library itself.</li>
<p>
<li> The order of invocation of the units or libraries in a use list is left to right
with the exception provided by rule 4.</li>
<p>
<li> No unit or library may be invoked more than once.</li>
</ol>
Note that rule 4 implies that a unit <em>x</em> to the right of a unit <em>y</em>
within a use list, may be invoked before the unit <em>y,</em> if the unit <em>y</em>
or some other unit to <em>y</em>'s left names <em>x</em> in its use list.

<p>
Note that the executable part of a library will only be invoked if the library
in the context of a Vector Pascal program. If the library is linked to a main
program in some other language, then the library and any units that it uses
will not be invoked. Care should thus be taken to ensure that Vector Pascal
libraries to be called from main programs written in other languages do not
depend upon initialisation code contained within the executable blocks of units.

<p>
 <h2><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;The compilation of programs and units.</h2>

<p>
When the compiler<a name="compiler53">
</a> processes the use list of a unit or a program
then, from left to right, for each identifier in the use list it attempts to
find an already compiled unit whose filename prefix is equal to the identifier.
If such a file exists, it then looks for a source<a name="source53">
</a> file whose
filename prefix is equal to the identifier, and whose suffix<a name="suffix53">
</a>
is <tt>.pas</tt><a name="'.pas'53">
</a>. If such a file exists and is older than the
already compiled file, the already compiled unit, the compiler loads the definitions
contained in the pre-compiled unit. If such a file exists and is newer than
the pre-compiled unit, then the compiler attempts to re-compile the unit source
file. If this recompilation proceeds without the dectection of any errors the
compiler loads the definitions of the newly compiled unit. The definitions in
a unit are saved to a file with the suffix <tt>.mpu,</tt> and prefix given by
the unit name. The compiler also generates an assembler file for each unit compiled.

<p>
 <h2><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;The System Unit</h2>

<p>
All programs and units include by default the unit system.pas as an implicit
member of their with list. This contains declarations of private run time routines
needed by Vector Pascal and also the following user accessible routines.

<p>
<b>procedure append<a name="append54">
</a>(var f:file);</b> This opens a file in append
mode.

<p>
<b>procedure assign<a name="assign54">
</a>(var f:file;var fname:string);</b> Associates
a file name with a file. It does not open the file.

<p>
<b>procedure blockread<a name="blockread54">
</a>(var f:file;var buf;count:integer;
var resultcount:integer);</b> Trys to read count bytes from the file into the buffer.
Resultcount contains the number actually read.

<p>
<b></b><b>procedure blockwrite</b><a name="blockwrite54">
</a>(var f:file;var buf;count:integer;
var resultcount:integer); Write count bytes from the buffer. Resultcount gives
the number actually read.

<p>
<b>procedure close</b><a name="close54">
</a>(var f:file); Closes a file.

<p>
<b>function eof</b><a name="eof54">
</a>(var f:file):boolean;

<p>
True if we are at the end of file f.

<p>
<b>procedure erase</b><a name="erase54">
</a>(var f:file); Delete file f.

<p>
<b>function eoln</b><a name="eoln54">
</a>(var f:file):boolean; True if at the end
of a line.

<p>
<b>function exp</b><a name="exp54">
</a>(d:real):real; Return  e<sup>x</sup> 

<p>
<b>function filesize</b><a name="filesize54">
</a>(var f: fileptr):integer; Return
number of bytes in a file.

<p>
<b>function filepos</b><a name="filepos54">
</a>(var f:fileptr):integer; Return current
position in a file.

<p>
<b>procedure freemem<a name="freemem54">
</a>(var p:pointer; num:integer);</b> Free
num bytes of heap store. Called by dispose.

<p>
<b>procedure getmem<a name="getmem54">
</a>(var p:pointer; num:integer);</b> Allocate
num bytes of heap. Called by new.

<p>
<b>procedure gettime<a name="gettime54">
</a>(var hour,min,sec,hundredth:integer);</b>
Return time of day.

<p>
<b></b><b>function int<a name="int54">
</a>(r:real):real;</b> Return the integer part of r
as a real.

<p>
<b></b><b>function ioresult<a name="ioresult54">
</a>:integer;</b> Returns a code indicating
if the previous file operation completed ok. Zero if no error occured.

<p>
<b>function length<a name="length54">
</a>(var s:string):integer;</b> Returns the length
of s.

<p>
<b>procedure pascalexit<a name="pascalexit54">
</a>(code:integer);</b> Terminate the
program with code.

<p>
<b></b><b>function secs<a name="secs54">
</a>:real;</b> Time in 1/100 seconds since program
started.

<p>
<b>function random<a name="random54">
</a>:integer;</b> Returns a random integer.

<p>
<b>procedure randomize<a name="randomize54">
</a>;</b> Assign a new time dependent
seed to the random number generator.

<p>
<b>procedure reset<a name="reset54">
</a>(var f:file);</b> Open a file for reading.

<p>
<b>procedure rewrite<a name="rewrite54">
</a>(var f :file);</b> Open a file for writing.

<p>
 <h1><a name="tth_chAp6">
Chapter 6 </a><br>Implementation issues</h1>

<p>
The compiler is implemented in java to ease portability between operating systems.

<p>
 <h2><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Invoking the compiler</h2>

<p>
The compiler is invoked with the command 

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
vpc<a name="vpc61">
</a>&nbsp;filename
</dd>
</dl>
where filename is the name of a pascal program or unit. For example

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
vpc&nbsp;test
</dd>
</dl>
will compile the program test.pas and generate an executable file <tt>test</tt>,
(<tt>test.exe</tt> under windows). 

<p>
The command <tt>vpc</tt> is a shell script which invokes the java runtime system
to execute a <tt>.jar</tt> file containing the compiler classes. Instead of
running vpc the java interpreter can be directly invoked as follows

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
java&nbsp;-jar&nbsp;mmpc.jar&nbsp;filename
</dd>
</dl>
The <tt>vpc</tt> script sets various compiler options appropriate to the operating
system being used.

<p>
     <h3><a name="tth_sEc6.1.1">
6.1.1</a>&nbsp;&nbsp;Environment variable</h3>

<p>
The environment variable <tt>mmpcdir<a name="mmpcdir61">
</a></tt> must be set to the
directory which contains the <tt>mmpc<a name="mmpc61">
</a>.jar</tt> file, the runtime
library <tt>rtl.o</tt> and the <tt>system.pas</tt> file.

<p>
     <h3><a name="tth_sEc6.1.2">
6.1.2</a>&nbsp;&nbsp;Compiler options</h3>

<p>
The following flags<a name="flags61">
</a> can be supplied to the compiler :

<p>

<dl compact="compact">

     
       
      
       <dt><b><tt>-Afilename<a name="-Afilename61">
</a></tt></b></dt>
	<dd>Defines the assembler file to be created.
In the absence of this option the assembler file is <tt>p.asm.</tt></dd>
 <dt><b><tt>-Ddirname<a name="-Ddirname61">
</a></tt></b></dt>
	<dd>Defines the directory in which to find
<tt>rtl.o</tt> and <tt>system.pas</tt>.</dd>
 <dt><b><tt>-V<a name="-V61">
</a></tt></b></dt>
	<dd>Causes the code generator to produce a verbose diagnostic
listing to <tt>foo.lst</tt> when compiling <tt>foo.pas</tt>.</dd>
 <dt><b><tt>-oexefile<a name="-oexefile61">
</a></tt></b></dt>
	<dd>Causes the linker to output to <tt>exefile</tt>
instead of the default output of <tt>p.exe.</tt></dd>
 <dt><b><tt>-U<a name="-U61">
</a></tt></b></dt>
	<dd>Defines whether references to external procedures in
the assembler file should be preceded by an underbar '_'. This is required
for the coff object format but not for elf.</dd>
 <dt><b><tt>-S<a name="-S61">
</a></tt></b></dt>
	<dd>Suppresses assembly and linking of the progam. An assembler
file is still generated.</dd>
 <dt><b><tt>-fFORMAT<a name="-fFORMAT61">
</a></tt></b></dt>
	<dd>Specifies the object format to be generated
by the assembler. The object formats currently used are elf when compiling under
unix or when compiling under windows using the cygwin version of the gcc linker,
or coff when using the djgpp version of the gcc linker. for other formats consult
the NASM documentation.</dd>
 <dt><b><tt>-cpuCGFLAG<a name="-cpuCGFLAG61">
</a></tt></b></dt>
	<dd>Specifies the code generator to be used.
Currently the code generators shown in table <a href="#cgs">6.1</a> are supported.</dd>
 <dt><b></b></dt>
	<dd>
<p>
<a name="tth_tAb6.1">
</a> <center>Table 6.1: Code generators supported<a name="cgs">
</a></center>
<center> 
<table border="1">
<tr><td align="center"><b>CGFLAG</b></td><td><b>description</b></td></tr><tr><td>
<tr><td align="center"><tt>IA<a name="IA3261">
</a>32</tt></td><td>generates code for the Intel 486 instructionset</td></tr>
<tr><td align="center"><tt>Pentium<a name="Pentium61">
</a></tt></td><td>generates code for the Intel P6 with MMX instructionset</td></tr>
<tr><td align="center"><tt>K6<a name="K661">
</a></tt></td><td>generates code for the AMD<a name="AMD61">
</a> K6 instructionset, use for Athlon</td></tr>
<tr><td align="center"><tt>P3<a name="P361">
</a></tt></td><td>generates code for the Intel<a name="Intel61">
</a> PIII processor family</td></tr></table>

<p>
</center>
<p>
</dd>
</dl>     <h3><a name="tth_sEc6.1.3">
6.1.3</a>&nbsp;&nbsp;Dependencies</h3>

<p>
The Vector Pascal compiler depends upon a number of other utilities which are
ususally pre-installed on Linux systems, and are freely available for Windows
systems.

<p>

<dl compact="compact">

     
       
      
       <dt><b>NASM</b></dt>
	<dd>The netwide assembler. This is used to convert the output of the code
generator to linkable modules. It is freely available on the web for Windows.</dd>
 <dt><b>gcc</b></dt>
	<dd>The GNU C Compiler, used to compile the run time library and to link modules
produced by the assembler to the run time library.</dd>
 <dt><b>java</b></dt>
	<dd>The java virtual machine must be available to interpret the compiler.
The a number of java interpreters and just in time compilers are freely available
for Windows.
</dd>
</dl>

<p>
 <h2><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Compiler Structure</h2>

<p>
The main program class of the compiler ilcg.Pascal.PascalCompiler translates
the source code of the program into an internal structure called an ILCG tree
[<a href="#Cockshott00" name="CITECockshott00">7</a>]. A machine generated code generator then translates this
into assembler code. An example would be the class ilcg.tree.IA32. An assembler
and linker specified in descendent class of the code generator then translate
the assembler code into an executable file.

<p>
To port the compiler to a new machine, say a P4, it is necessary to 

<p>

<ol type="1"><p>
<li> Write a new machine description <tt>P4.ilc</tt> in ILCG source code.</li>
<p>
<li> Compile this to a code generator in java with the ilcg compiler generator using
a command of the form

<p>

<ol type="a"><p>
<li> <tt>java ilcg.ILCG cpus/P4.ilc ilcg/tree/P4.java P4</tt></li>
</ol></li>
<p>
<li> Write an interface class ilcg/tree/P4CG which is a subclass of P4 and which
invokes the assembler and linker.</li>
</ol>
Sample machine descriptions and interface classes are available on request to
those wishing to port the compiler.

<p>
 <h2><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Calling conventions</h2>

<p>
Procedure parameters are passed using a modified C calling convention to facilitate
calls to external C procedures. Parameters are pushed on to the stack from right
to left. Value parameters are pushed entire onto the stack, var parameters are
pushed as addresses.

<p>

<b>Eacmple &nbsp;&nbsp;</b>

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
unit&nbsp;callconv;

<p>
interface

<p>
type&nbsp;intarr=&nbsp;array[1..8]&nbsp;of&nbsp;integer;

<p>
procedure&nbsp;foo(var&nbsp;a:intarr;&nbsp;b:intarr;&nbsp;c:integer);

<p>
implementation

<p>
procedure&nbsp;foo(var&nbsp;a:intarr;&nbsp;b:intarr;&nbsp;c:integer);

<p>
begin

<p>
end;

<p>
var&nbsp;x,y:intarr;

<p>
begin

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo(x,y,3);

<p>
end.
</dd>
</dl>
This would generate the following code for the prodedure foo.

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
;&nbsp;procedure&nbsp;generated&nbsp;by&nbsp;code&nbsp;generator&nbsp;class&nbsp;ilcg.tree.PentiumCG

<p>
le8e68de10c5:

<p>
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo

<p>
&nbsp;enter&nbsp;&nbsp;&nbsp;spaceforfoo-4*1,1

<p>
;8

<p>
&nbsp;le8e68de118a:

<p>
spaceforfoo&nbsp;equ&nbsp;4

<p>
;....&nbsp;code&nbsp;for&nbsp;foo&nbsp;goes&nbsp;here

<p>
fooexit:

<p>
leave

<p>
&nbsp;ret&nbsp;0
</dd>
</dl>
and the calling code is

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
&nbsp;push&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;push&nbsp;rightmost&nbsp;argument

<p>
&nbsp;lea&nbsp;esp,[&nbsp;&nbsp;esp+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-32]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;create&nbsp;space&nbsp;for&nbsp;the&nbsp;array

<p>
&nbsp;mov&nbsp;DWORD&nbsp;&nbsp;[&nbsp;&nbsp;ebp+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-52],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;;&nbsp;for&nbsp;loop&nbsp;to&nbsp;copy&nbsp;the&nbsp;array

<p>
&nbsp;le8e68de87fd:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;the&nbsp;loop&nbsp;is&nbsp;unrolled&nbsp;twice&nbsp;and

<p>
&nbsp;cmp&nbsp;DWORD&nbsp;&nbsp;[&nbsp;&nbsp;ebp+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-52],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;;&nbsp;parallelised&nbsp;to&nbsp;copy&nbsp;16&nbsp;bytes&nbsp;per&nbsp;cycle

<p>
&nbsp;jg&nbsp;near&nbsp;&nbsp;le8e68de87fe

<p>
&nbsp;mov&nbsp;ebx,DWORD&nbsp;&nbsp;[&nbsp;&nbsp;ebp+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-52]

<p>
&nbsp;imul&nbsp;&nbsp;&nbsp;ebx,&nbsp;&nbsp;&nbsp;&nbsp;4

<p>
&nbsp;movq&nbsp;MM1,&nbsp;[&nbsp;&nbsp;ebx+&nbsp;le8e68dddaa2+&nbsp;&nbsp;&nbsp;&nbsp;-48]

<p>
&nbsp;movq&nbsp;&nbsp;[&nbsp;&nbsp;esp+ebx],MM1

<p>
&nbsp;mov&nbsp;eax,DWORD&nbsp;&nbsp;[&nbsp;&nbsp;ebp+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-52]

<p>
&nbsp;lea&nbsp;ebx,[&nbsp;&nbsp;eax+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2]

<p>
&nbsp;imul&nbsp;&nbsp;&nbsp;ebx,&nbsp;&nbsp;&nbsp;&nbsp;4

<p>
&nbsp;movq&nbsp;MM1,&nbsp;[&nbsp;&nbsp;ebx+&nbsp;le8e68dddaa2+&nbsp;&nbsp;&nbsp;&nbsp;-48]

<p>
&nbsp;movq&nbsp;&nbsp;[&nbsp;&nbsp;esp+ebx],MM1

<p>
&nbsp;lea&nbsp;ebx,[&nbsp;&nbsp;ebp+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-52]

<p>
&nbsp;add&nbsp;&nbsp;DWORD&nbsp;&nbsp;[&nbsp;ebx],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4

<p>
&nbsp;jmp&nbsp;&nbsp;le8e68de87fd

<p>
&nbsp;le8e68de87fe:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;end&nbsp;of&nbsp;array&nbsp;copying&nbsp;loop

<p>
&nbsp;push&nbsp;DWORD&nbsp;&nbsp;le8e68dddaa2+&nbsp;&nbsp;&nbsp;&nbsp;-32&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;push&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;var&nbsp;parameter

<p>
&nbsp;EMMS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;clear&nbsp;MMX&nbsp;state

<p>
&nbsp;&nbsp;call&nbsp;le8e68de10c5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;call&nbsp;the&nbsp;local&nbsp;label&nbsp;for&nbsp;foo

<p>
&nbsp;add&nbsp;esp,&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;free&nbsp;space&nbsp;on&nbsp;the&nbsp;stack
</dd>
</dl>

<p>

<h4>Function results</h4>

<p>
Function results are returned in registers for scalars following the C calling
convention for the operating system on which the compiler is implemented. Records,
strings and sets are returned by the caller passing an implicit parameter containing
the address of a temporary buffer in the calling environment into which the
result can be assigned. Given the following program

<p>
<b>program</b>

<p>
<b>type t1= set of char;</b>

<p>
<b>var x,y:t1;</b>

<p>
<b>function bar:t1;begin bar:=y;end;</b>

<p>
<b>&nbsp;</b>

<p>
<b>begin</b>

<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:=bar;</b>

<p>
<b>end.</b>

<p>
The call of bar would generate

<p>

<dl compact="compact">
 <dt><b></b></dt>
	<dd>
&nbsp;push&nbsp;ebp

<p>
 add &nbsp;dword[esp]&nbsp;,    &nbsp;-128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;address&nbsp;of&nbsp;buffer&nbsp;on&nbsp;stack

<p>
 call&nbsp;le8eb6156ca8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;call&nbsp;bar&nbsp;to&nbsp;place&nbsp;result&nbsp;in&nbsp;buffer

<p>
 add&nbsp;esp,&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;discard&nbsp;the&nbsp;address

<p>
 mov&nbsp;DWORD &nbsp;[ &nbsp;ebp+    &nbsp;-132],  &nbsp;0&nbsp;&nbsp;&nbsp;;&nbsp;for&nbsp;loop&nbsp;to&nbsp;copy&nbsp;the&nbsp;set&nbsp;16&nbsp;bytes

<p>
 le8eb615d99f:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;at&nbsp;a&nbsp;time&nbsp;into&nbsp;x&nbsp;using&nbsp;the&nbsp;MMX&nbsp;registers

<p>
 cmp&nbsp;DWORD &nbsp;[ &nbsp;ebp+    &nbsp;-132],  31

<p>
 jg&nbsp;near &nbsp;le8eb615d9910

<p>
 mov&nbsp;ebx,DWORD &nbsp;[ &nbsp;ebp+    &nbsp;-132]

<p>
 movq&nbsp;MM1,&nbsp;[ &nbsp;ebx+ebp&nbsp;+    &nbsp;-128]

<p>
 movq &nbsp;[ &nbsp;ebx+ebp&nbsp;+    &nbsp;-64],MM1

<p>
 mov&nbsp;eax,DWORD &nbsp;[ &nbsp;ebp+    &nbsp;-132]

<p>
 lea&nbsp;ebx,[ &nbsp;eax+    &nbsp;8]

<p>
 movq&nbsp;MM1,&nbsp;[ &nbsp;ebx+ebp&nbsp;+    &nbsp;-128]

<p>
 movq &nbsp;[ &nbsp;ebx+ebp&nbsp;+    &nbsp;-64],MM1

<p>
 lea&nbsp;ebx,[ &nbsp;ebp+    &nbsp;-132]

<p>
 add &nbsp;DWORD &nbsp;[&nbsp;ebx],    &nbsp;16

<p>
 jmp &nbsp;le8eb615d99f

<p>
 le8eb615d9910:
</dd>
</dl>

<p>
 <h2><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;Array representation</h2>

<p>
A static<a name="static64">
</a> array<a name="array, static64">
</a> is represented simply by
the number of bytes required to store the array being allocated in the global
segment or on the stack.

<p>
A dynamic array<a name="array64">
</a><a name="array, dynamic64">
</a> is always represented on
the heap<a name="heap64">
</a>. Since its rank<a name="rank64">
</a> is known to the compiler
what needs to be stored at run time are the bounds and the means to access it.
For simplicity we make the format of dyanamic and conformant arrays the same.
Thus for schema<a name="schema64">
</a>  

<p>
<b>s(a,b,c,d:integer)= array[a..b,c..d] of integer </b>

<p>
whose run time bounds are evaluated to be 2..4,3..7 we would have the following
structure:

<p>
<center> 
<table border="1">
<tr><td align="center">address</td><td align="center">field</td><td align="center">value</td></tr><tr><td>
<tr><td align="center">x</td><td align="center">base of data</td><td align="center">address of first integer in the array</td></tr>
<tr><td align="center">x+4</td><td align="center">a</td><td align="center">2</td></tr>
<tr><td align="center">x+8</td><td align="center">b</td><td align="center">4</td></tr>
<tr><td align="center">x+12</td><td align="center">step</td><td align="center">20</td></tr>
<tr><td align="center">x+16</td><td align="center">c</td><td align="center">3</td></tr>
<tr><td align="center">x+20</td><td align="center">d</td><td align="center">7</td></tr></table>

<p>
</center>The base address for a schematic array on the heap, will point at the first
byte after the array header show. For a conformant array, it will point at the
first data byte of the array or array range<a name="range64">
</a> being passed as a
parameter. The step field specifies the length of an element of the second dimension
in bytes. It is included to allow for the case where we have a conformant<a name="conformant64">
</a>
array<a name="array, conformant64">
</a> formal parameter 

<p>
<b>x:array[a..b:integer,c..d:integer] of integer</b>

<p>
to which we pass as actual parameter<a name="parameter64">
</a> the range 

<p>
<b>p[2..4,3..7] </b>

<p>
as actual parameter, where <b>p:array[1..10,1..10] of integer</b>

<p>
In this case the base address would point at @p[2,3] and the step would
be 40 - the length of 10 integers.

<p>
     <h3><a name="tth_sEc6.4.1">
6.4.1</a>&nbsp;&nbsp;Range<a name="range64">
</a> checking</h3>

<p>
When arrays are indexed, the compiler plants run time checks to see if the indices
are within bounds<a name="bounds64">
</a>. In many cases the optimiser is able to remove
these checks, but in those cases where it is unable to do so, some performance
degradation can occur. Range checks can be disabled or enabled by the compiler
directives.

<p>
{$r-} { disable range checks }

<p>
{$r+} { enable range checks }

<p>
Performance can be further enhanced by the practice of declaring arrays to have
lower bounds of zero. The optimiser is generally able to generate more efficient
code for zero based arrays.

<p>
<a name="tth_sEcindex"></a>

<h2> Index (showing section)</h2>

<h2>Bibliography</h2>

<dl compact="compact">
 <dt><a href="#CITEAMD" name="AMD">[1]</a></dt><dd>Advanced Micro Devices, 3DNow! Technology Manual, 1999. 
</dd>
 <dt><a href="#CITE2" name="2">[2]</a></dt><dd>Aho, A.V., Ganapathi, M, TJiang S.W.K., Code Generation Using Tree Matching
and Dynamic Programming, ACM Trans, Programming Languages and Systems 11, no.4,
1989, pp.491-516. 
</dd>
 <dt><a href="#CITEBurke" name="Burke">[3]</a></dt><dd>Burke, Chris, J User Manual, ISI, 1995.
</dd>
 <dt><a href="#CITECattel80" name="Cattel80">[4]</a></dt><dd>Cattell R. G. G., Automatic derivation of code generators from machine descriptions,
ACM Transactions on Programming Languages and Systems, 2(2), pp. 173-190, April
1980. 
</dd>
 <dt><a href="#CITEChaitin" name="Chaitin">[5]</a></dt><dd>Chaitin. G., Elegant Lisp Programs, in The Limits of Mathematics, pp. 29-56,
Springer, 1997.
</dd>
 <dt><a href="#CITECheong97" name="Cheong97">[6]</a></dt><dd>Cheong, G., and Lam, M., An Optimizer for Multimedia Instruction Sets, 2nd SUIF
Workshop, Stanford University, August 1997. 
</dd>
 <dt><a href="#CITECockshott00" name="Cockshott00">[7]</a></dt><dd>Cockshott, Paul, Direct Compilation of High Level Languages for Multi-media
Instruction-sets, Department of Computer Science, University of Glasgow, Nov
2000.
</dd>
 <dt><a href="#CITEgraham80" name="graham80">[8]</a></dt><dd>Susan L. Graham, Table Driven Code Generation, IEEE Computer, Vol 13, No. 8,
August 1980, pp 25..37. 
</dd>
 <dt><a href="#CITEIA32 " name="IA32 ">[9]</a></dt><dd>Intel, Intel Architecture Software Developers Manual Volumes 1 and 2, 1999. 
</dd>
 <dt><a href="#CITEIntel00" name="Intel00">[10]</a></dt><dd>Intel, Willamette Processor Software Developer's Guide, February, 2000. 
</dd>
 <dt><a href="#CITEISO90" name="ISO90">[11]</a></dt><dd>ISO, Extended Pascal ISO 10206:1990, 1991.
</dd>
 <dt><a href="#CITEIverson62" name="Iverson62">[12]</a></dt><dd>K. E. Iverson, A Programming Language, John Wiley &amp; Sons, Inc., New York (1962),
p. 16. 
</dd>
 <dt><a href="#CITEIverson80" name="Iverson80">[13]</a></dt><dd>Iverson, K. E. . Notation as a tool of thought. Communications of the ACM, 23(8),
444-465, 1980.
</dd>
 <dt><a href="#CITEJmanual" name="Jmanual">[14]</a></dt><dd>Iverson K. E, A personal View of APL, IBM Systems Journal, Vol 30, No 4, 1991. 
</dd>
 <dt><a href="#CITEJensen" name="Jensen">[15]</a></dt><dd>Iverson, Kenneth E., J Introduction and Dictionary, Iverson Software Inc. (ISI),
Toronto, Ontario, 1995.
</dd>
 <dt><a href="#CITEKrall00" name="Krall00">[16]</a></dt><dd>Krall, A., and Lelait, S., Compilation Techniques for Multimedia Processors,
International Journal of Parallel Programming, Vol. 28, No. 4, pp 347-361, 2000. 
</dd>
 <dt><a href="#CITELeupers99" name="Leupers99">[17]</a></dt><dd>Leupers, R., Compiler Optimization for Media Processors, EMMSEC 99/Sweden 1999. 
</dd>
 <dt><a href="#CITEMetcalf96" name="Metcalf96">[18]</a></dt><dd>Metcalf, M., and Reid., J., The F Programming Language, OUP, 1996. 
</dd>
 <dt><a href="#CITEPeleg97" name="Peleg97">[19]</a></dt><dd>Peleg, A., Wilke S., Weiser U., Intel MMX for Multimedia PCs, Comm. ACM, vol
40, no. 1 1997. 
</dd>
 <dt><a href="#CITESreraman00" name="Sreraman00">[20]</a></dt><dd>Srereman, N., and Govindarajan, G., A Vectorizing Compiler for Multimedia Extensions,
International Journal of Parallel Programming, Vol. 28, No. 4, pp 363-400, 2000. 
</dd>
 <dt><a href="#CITEsable" name="sable">[21]</a></dt><dd>\' Etienne Gagnon, SABLECC, AN OBJECT-ORIENTED COMPILER FRAMEWORK, School
of Computer Science McGill University, Montreal, March 1998. 
</dd>
 <dt><a href="#CITETexas" name="Texas">[22]</a></dt><dd>Texas Instruments, TMS320C62xx CPU and Instruction Set Reference Guide, 1998.</dd>
</dl>

<p>
<hr /><h3>Footnotes:</h3>

<p>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Note this differs from ISO Pascal which allows a comment starting with { to
terminate with *) and vice versa.

<p>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>The notation used for grammar definition is a tabularised BNF . Each boxed table
defines a production, with the production name in the left column. Each line
in the right column is an alternative for the production. The metasymbol + indicates
one or more repetitions of what immediately preceeds it. The Kleene star *
is used for zero or more repetitions. Terminal symbols are in single quotes.
Sequences in brackets [ ] are optional.

<p>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>The Pascal concept of static variables should not be equated with the notion
of static variables in some other languages such as C or Java. In Pascal a variable
is considered static if its offset either relative to the stack base or relative
to the start of the global segment can be determined at compile/link time. In
C a variable is static only if its location relative to the start of the global
segment is known at compile time.

<p>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>see section <a href="#block">5</a>.

<p>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>See section <a href="#implicitindices">4.2.1</a>.

<br><br><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.03.<br>On  8 Mar 2002, 20:51.</small>
</html>
