<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<B><I><FONT FACE="Arial"><P>Transaction mechanism</P>
</B></I></FONT><P>The process of walking the syntax tree and matching it against the machine description may involve backtracking. This can occur when a particular goal pursued by the pattern matcher eventually fails. Whilst performing a pattern match, a stream of machine code instructions is generated, and registers are reserved. It is important that when backtracking occurs we can prevent any machine instructions that would have been generated by the failed pattern match from being copied to the output file.</P>
<P>This is ensured by writing all lines of  assembler code to a <I>RollBackBuffer</I>, which buffers assembler programs line by line until it is flushed to an output file. The <I>RollBackBuffe</I>r can be queried as to what its current line number is using the <I>mark()</I> call.</P>
<P>The write point of the buffer can then be moved back to this point at a later instant by a call of rollBackTo().</P>
<P>Each instance of Walker contains a RollBackBuffer field <I>buf.</P>
</I><P>The pattern matcher thus organises its matching into abortable transactions. Whenever it attempts to match a machine instruction against the syntax tree it starts a transaction by recording the current write point of <I>buf</I>. If the match of the instruction fails it calls <I>rollBack()</I>, a method which both rolls back the output stream and unreserves any registers.</P>
<FONT FACE="Arial"><P>Register reservation transactions</P>
</FONT><P>Whilst matching the syntax tree it is necessary to reserve registers that currently contain the results of the pattern matched so far. However when a match fails we want to be able to unreserve all registers that were recorded since the start of the transaction. This is done by ensuring that all register reservation is done through the <I>reserve()</I> method. This not only reserves the register, it also pushes onto a datastructure called the <I>reservationStack</I> a <I>Reservation</I> object, basically a pair consisting of a line number and a register.</P>
<P>When the <I>rollBack</I> method is called, the <I>reservationStack</I> is popped of all registers reserved since the mark point, and all reservations of these registers are canceled.</P>
<B><I><FONT FACE="Arial"><P>Register Spilling</P>
</B></I></FONT><P>When generating code we may run out of registers. It is necessary to provide a means of spilling registers that is machine independent and which fits in with the transaction mechanism outlined above.</P>
<P>The indended approach is to provide a <I>spill </I>method that will be called to save a register. The default spill method in the class Walker will allocate a new variable in the local stack frame for each variable to be spilled and generate a simple assignment statement to this location as an ilcg tree. This is then passed to the pattern matcher to generate machine code. For this to work we need:</P>
<OL>

<LI>Access to the local store allocator for the current stack frame. This can  be obtained if the compiler brackets all blocks to be compiled within Block nodes which provide a pointer to the current local store allocator. The Walker can then keep a record of the LocalStoreAllocator to use when spilling.</LI>
<LI>When allocating a register the Walker must actually allocate a RegisterAlias which initially points at the register but which, in the event of a spill being forced,will point at the location to which the register has been spilled.</LI>
<LI>Since the spill operation itself will only have an array of Registers to work on, supplied eventually by the machine specific pattern matcher, the Registers must be aware of all aliases that currently exist.</LI>
<LI>There must be a mechanism for forgetting all spills that have occurred after a given line number was output.</LI>
<LI>There must be a mechanism for the matcher to check that a spill on a register aliases is unspilled before a machine instruction using that alias is sent to the RollBackBuffer.</LI></OL>
</BODY>
</HTML>
