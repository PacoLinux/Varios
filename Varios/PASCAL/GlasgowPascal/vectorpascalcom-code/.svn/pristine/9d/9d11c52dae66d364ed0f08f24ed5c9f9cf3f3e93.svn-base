/*
\section{PowerPC}
*/

/*
PowerPC Microprocessor Family: The Programming Environments for 32-Bit Microprocessors 

Associated Product Family(ies): PowerPC
Associated Product(s): PowerPC 603e Microprocessor, PowerPC 740 Microprocessor (300MHz to 550MHz), 
PowerPC 740 Microprocessor (up to 266MHz), PowerPC 750 Microprocessor (300MHz to 550MHz), PowerPC 750 
Microprocessor (up to 266MHz), PowerPC EM603e Microprocessor, PowerPC 750FX Microprocessor, 
PowerPC 750CX and 750CXe Microprocessor

Software Reference Manual 
The primary objective of this manual is to help programmers provide software that is compatible across 
the family of 32-bit PowerPC(TM) processors. Because the PowerPC architecture is designed to be flexible 
to  support a broad range of both 32 and 64-bit processors, this book provides a general description 
of features that are common to PowerPC processors and indicates those features that are optional or 
that may be implemented differently in the design of each processor. 

Topics include PowerPC register set, operand conventions, addressing modes and instruction set summary, 
cache model and memory coherency, exceptions, memory management, instruction set, PowerPC instruction 
set listings, architecture cross reference, multiple-precision shifts, floating-point models, synchronization 
programming examples, simplified mnemonics and a glossary of terms and abbreviations.

Publication Number: G522-0290-01 
p~~~~~~~~~~~~~6Y A#A #
=
Q]

Link: http://www-3.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF778525699600719DF2/$file/6xx_pem.pdf

File: 6xx_pem.pdf 

*/
/*
\ 	PowerPC  
\	Youssef Gdura           
*/  
 /*09/10/09 new part start*/
type word=l;
type uint32=l;
type int32=l;
type ieee64=l;
type int64=q;
type octet=b;
type uint8=b; 
type int16=w;
type uint16=w; 
type int8=b;
type ieee32=s;

type halfword=w;
/*09/10/09 end*/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Loop Definitions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
 
     

  
 
  




/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Type Declarations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
/*
\begin{verbatim} 
*/
type int8=BYTE;
type uint8=BYTE; 
type octet=BYTE;

type int16=WORD;
type uint16=WORD;
type halfword=WORD;



type int32=DWORD;
type uint32=DWORD;
type ieee32=DWORD;  
type word=DWORD;


type ieee64=QWORD; 
type int64=QWORD;
type uint64=QWORD;


/*
\end{verbatim}
*/
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Data formats Patterns 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
/*
\begin{verbatim}
*/
pattern unsigned 		means [uint32|uint8|uint16];
pattern unsignedup16	means [uint8|uint16];
pattern signedup16	means [int16|uint16|int8|uint8];
pattern signed 			means [int8|int16|int32|int64];
pattern int 			means [int32|uint32|int8|uint8|uint16|int16|int64];
pattern double 			means [ieee64];
pattern float  			means [ieee32];
pattern real 			means [float|double];

pattern word64 			means [int64|uint64];
pattern word32 			means [int32|uint32|word];
pattern word16 			means [int16|uint16|halfword];
pattern byte 			means [uint8|int8|octet];


pattern wordupto16  	means [byte|word16];
pattern wordupto32 		means [word32|byte|word16];
pattern wordupto64 		means [word32|byte|word16|word64];
pattern dataformat 		means [octet|word];
pattern longint 		means [int32|uint32];
pattern hiint 			means [int32|int64|int16];
pattern two(type t)		means[2] assembles['2'];
pattern four(type t)	means[4] assembles['4'];
pattern eight(type t)	means[8] assembles['8'];

pattern scale means[two|four|eight];

/* 
\end{verbatim}
*/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Registers Declarations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

/*
\begin{verbatim}
*/

/* General Purpose Registers (gpr)  */

/* 64 bit registers */


reserved register int64 R0 assembles['r0'];
reserved register int64 R1 assembles['r1'];
reserved register int64 R2 assembles['r2'];
 

register int64 R3 assembles['r3'];
register int64 R4 assembles['r4'];
register int64 R5 assembles['r5'];
register int64 R6 assembles['r6'];
register int64 R7 assembles['r7'];
register int64 R8 assembles['r8'];
register int64 R9 assembles['r9'];
register int64 R10 assembles['r10'];
register int64 R11 assembles['r11'];
register int64 R12 assembles['r12'];
register int64 R13 assembles['r13'];
register int64 R14 assembles['r14'];
register int64 R15 assembles['r15'];
register int64 R16 assembles['r16'];
register int64 R17 assembles['r17'];
register int64 R18 assembles['r18'];
register int64 R19 assembles['r19'];
register int64 R20 assembles['r20'];
 

register int64 R22 assembles['r22'];
register int64 R23 assembles['r23'];
register int64 R24 assembles['r24'];
register int64 R25 assembles['r25'];
register int64 R26 assembles['r26'];
register int64 R27 assembles['r27'];
register int64 R28 assembles['r28'];
register int64 R29 assembles['r29'];
 
reserved register int64 R21 assembles['r21'];  /* Reserved for Pmainbase  */
reserved register int64 R30 assembles['r30'];  /* Reserved for macros  */
reserved register int64 R31 assembles['r31'];  /* Reserved for frame pointer */

/*Alias regsiters */
alias register word64 LR = R0(0:63) assembles ['r0'] ;	/* Coping of the Link Register (LR)*/
alias register word64 SP = R1(0:63) assembles ['r1'] ;	/* Stack Pointer (SP )*/
alias register word64 FP = R31(0:63) assembles ['r31'] ;	/* Frame Pointer (FP) or Table of Contents */
alias register word64 SD = R13(0:63) assembles ['r13'] ; 	/* Small Data (SD) pointer */
alias register word64 TMPREG = R30(0:63) assembles ['r30'] ;	/* Used as a temporary register*/


alias register uint64 uR3=R3(0:63) assembles['r3'];
alias register uint64 uR4=R4(0:63) assembles['r4'];
alias register uint64 uR5=R5(0:63) assembles['r5'];
alias register uint64 uR6=R6(0:63) assembles['r6'];
alias register uint64 uR7=R7(0:63) assembles['r7'];
alias register uint64 uR8=R8(0:63) assembles['r8'];
alias register uint64 uR9=R9(0:63) assembles['r9'];
alias register uint64 uR10=R10(0:63) assembles['r10'];
alias register uint64 uR11=R11(0:63) assembles['r11'];
alias register uint64 uR12=R12(0:63) assembles['r12'];
alias register uint64 uR13=R13(0:63) assembles['r13'];
alias register uint64 uR14=R14(0:63) assembles['r14'];
alias register uint64 uR15=R15(0:63) assembles['r15'];
alias register uint64 uR16=R16(0:63) assembles['r16'];
alias register uint64 uR17=R17(0:63) assembles['r17'];
alias register uint64 uR18=R18(0:63) assembles['r18'];
alias register uint64 uR19=R19(0:63) assembles['r19'];
alias register uint64 uR20=R20(0:63) assembles['r20'];
alias register uint64 uR21=R21(0:63) assembles['r21'];
alias register uint64 uR22=R22(0:63) assembles['r22'];
alias register uint64 uR23=R23(0:63) assembles['r23'];
alias register uint64 uR24=R24(0:63) assembles['r24'];
alias register uint64 uR25=R25(0:63) assembles['r25'];
alias register uint64 uR26=R26(0:63) assembles['r26'];
alias register uint64 uR27=R27(0:63) assembles['r27'];
alias register uint64 uR28=R28(0:63) assembles['r28'];
alias register uint64 uR29=R29(0:63) assembles['r29'];
alias register uint64 uR30=R30(0:63) assembles['r30'];
 


/* 8bit registers */

/* Signed 8 bit values */

alias register int8 bR3=R3(0:7) assembles['r3'];
alias register int8 bR4=R4(0:7) assembles['r4'];
alias register int8 bR5=R5(0:7) assembles['r5'];
alias register int8 bR6=R6(0:7) assembles['r6'];
alias register int8 bR7=R7(0:7) assembles['r7'];
alias register int8 bR8=R8(0:7) assembles['r8'];
alias register int8 bR9=R9(0:7) assembles['r9'];
alias register int8 bR10=R10(0:7) assembles['r10'];
 

/* Unsigned Registers (Byte values) */

alias register uint8 ubR3=R3(0:7) assembles['r3'];
alias register uint8 ubR4=R4(0:7) assembles['r4'];
alias register uint8 ubR5=R5(0:7) assembles['r5'];
alias register uint8 ubR6=R6(0:7) assembles['r6'];
alias register uint8 ubR7=R7(0:7) assembles['r7'];
alias register uint8 ubR8=R8(0:7) assembles['r8'];
alias register uint8 ubR9=R9(0:7) assembles['r9'];
alias register uint8 ubR10=R10(0:7) assembles['r10'];
 

/* Untyped Registers (Byte values) */

alias register octet oR3=R3(0:7) assembles['r3'];
alias register octet oR4=R4(0:7) assembles['r4'];
alias register octet oR5=R5(0:7) assembles['r5'];
alias register octet oR6=R6(0:7) assembles['r6'];
alias register octet oR7=R7(0:7) assembles['r7'];
alias register octet oR8=R8(0:7) assembles['r8'];
alias register octet oR9=R9(0:7) assembles['r9'];
alias register octet oR10=R10(0:7) assembles['r10'];
 

/* 16 bit registers */

/* Signed Registers (halfword values) */

alias register int16 sR3=R3(0:15) assembles['r3'];
alias register int16 sR4=R4(0:15) assembles['r4'];
alias register int16 sR5=R5(0:15) assembles['r5'];
alias register int16 sR6=R6(0:15) assembles['r6'];
alias register int16 sR7=R7(0:15) assembles['r7'];
alias register int16 sR8=R8(0:15) assembles['r8'];
alias register int16 sR9=R9(0:15) assembles['r9'];
alias register int16 sR10=R10(0:15) assembles['r10'];
 

/* Untyped Registers (halfword values) */ 

alias register uint16 hR3=R3(0:15) assembles['r3'];
alias register uint16 hR4=R4(0:15) assembles['r4'];
alias register uint16 hR5=R5(0:15) assembles['r5'];
alias register uint16 hR6=R6(0:15) assembles['r6'];
alias register uint16 hR7=R7(0:15) assembles['r7'];
alias register uint16 hR8=R8(0:15) assembles['r8'];
alias register uint16 hR9=R9(0:15) assembles['r9'];
alias register uint16 hR10=R10(0:15) assembles['r10'];


/* Untyped Registers (halfword values) */ 

alias register halfword hxR3=R3(0:15) assembles['r3'];
alias register halfword hxR4=R4(0:15) assembles['r4'];
alias register halfword hxR5=R5(0:15) assembles['r5'];
alias register halfword hxR6=R6(0:15) assembles['r6'];
alias register halfword hxR7=R7(0:15) assembles['r7'];
alias register halfword hxR8=R8(0:15) assembles['r8'];
alias register halfword hxR9=R9(0:15) assembles['r9'];
alias register halfword hxR10=R10(0:15) assembles['r10'];
 

/* 32 bit registers */
/* Signed Registers (32bit word values) */


alias register int32 swR3=R3(0:31) assembles['r3'];
alias register int32 swR4=R4(0:31) assembles['r4'];
alias register int32 swR5=R5(0:31) assembles['r5'];
alias register int32 swR6=R6(0:31) assembles['r6'];
alias register int32 swR7=R7(0:31) assembles['r7'];
alias register int32 swR8=R8(0:31) assembles['r8'];
alias register int32 swR9=R9(0:31) assembles['r9'];
alias register int32 swR10=R10(0:31) assembles['r10'];
alias register int32 swR11=R11(0:31) assembles['r11'];
alias register int32 swR12=R12(0:31) assembles['r12'];
alias register int32 swR13=R13(0:31) assembles['r13'];
alias register int32 swR14=R14(0:31) assembles['r14'];
alias register int32 swR15=R15(0:31) assembles['r15'];
alias register int32 swR16=R16(0:31) assembles['r16'];
alias register int32 swR17=R17(0:31) assembles['r17'];
alias register int32 swR18=R18(0:31) assembles['r18'];
alias register int32 swR19=R19(0:31) assembles['r19'];
alias register int32 swR20=R20(0:31) assembles['r20'];
alias register int32 swR21=R21(0:31) assembles['r21'];
alias register int32 swR22=R22(0:31) assembles['r22'];
alias register int32 swR23=R23(0:31) assembles['r23'];
alias register int32 swR24=R24(0:31) assembles['r24'];
alias register int32 swR25=R25(0:31) assembles['r25'];
alias register int32 swR26=R26(0:31) assembles['r26'];
alias register int32 swR27=R27(0:31) assembles['r27'];
alias register int32 swR28=R28(0:31) assembles['r28'];
alias register int32 swR29=R29(0:31) assembles['r29'];
alias register int32 swR30=R30(0:31) assembles['r30'];
 

/* Unsigned Registers (32bit word values) */ 

alias register uint32 uwR3=R3(0:31) assembles['r3'];
alias register uint32 uwR4=R4(0:31) assembles['r4'];
alias register uint32 uwR5=R5(0:31) assembles['r5'];
alias register uint32 uwR6=R6(0:31) assembles['r6'];
alias register uint32 uwR7=R7(0:31) assembles['r7'];
alias register uint32 uwR8=R8(0:31) assembles['r8'];
alias register uint32 uwR9=R9(0:31) assembles['r9'];
alias register uint32 uwR10=R10(0:31) assembles['r10'];
alias register uint32 uwR11=R11(0:31) assembles['r11'];
alias register uint32 uwR12=R12(0:31) assembles['r12'];
alias register uint32 uwR13=R13(0:31) assembles['r13'];
alias register uint32 uwR14=R14(0:31) assembles['r14'];
alias register uint32 uwR15=R15(0:31) assembles['r15'];
alias register uint32 uwR16=R16(0:31) assembles['r16'];
alias register uint32 uwR17=R17(0:31) assembles['r17'];
alias register uint32 uwR18=R18(0:31) assembles['r18'];
alias register uint32 uwR19=R19(0:31) assembles['r19'];
alias register uint32 uwR20=R20(0:31) assembles['r20'];
alias register uint32 uwR21=R21(0:31) assembles['r21'];
alias register uint32 uwR22=R22(0:31) assembles['r22'];
alias register uint32 uwR23=R23(0:31) assembles['r23'];
alias register uint32 uwR24=R24(0:31) assembles['r24'];
alias register uint32 uwR25=R25(0:31) assembles['r25'];
alias register uint32 uwR26=R26(0:31) assembles['r26'];
alias register uint32 uwR27=R27(0:31) assembles['r27'];
alias register uint32 uwR28=R28(0:31) assembles['r28'];
alias register uint32 uwR29=R29(0:31) assembles['r29'];
alias register uint32 uwR30=R30(0:31) assembles['r30'];
 


register stack(4096)int64 mainSTACK assembles[ 'mainSTACK']; 

/* \end{verbatim}
\subsection{Register sets }
\begin{verbatim}
*/
/*XXXXXXXXXXXXXXXXXXXXXXX Register Sets XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

pattern siregs means[R0|R1|R2|R4|R5|R6|R7|R8|R9|R10|R11|R12|R13|R14|R15|R16|R17|R18|R19|R20|R22|R23|R24|R25|R26|R27|R28|R29|R21|R30|R31|R3];

 
pattern uiregs means[uR4|uR5|uR6|uR7|uR8|uR9|uR10|uR11|uR12|uR13|uR14|uR15|uR16|uR17|uR18|uR19|uR20|uR22|uR23|uR24|uR25|uR26|uR27|uR28|uR29|uR21|uR30|uR3];
 
 
pattern swregs means[swR4|swR5|swR6|swR7|swR8|swR9|swR10|swR11|swR12|swR13|swR14|swR15|swR16|swR17|swR18|swR19|swR20|swR22|swR23|swR24|swR25|swR26|swR27|swR28|swR29|swR21|swR30|swR3];

 
pattern uwregs means[uwR4|uwR5|uwR6|uwR7|uwR8|uwR9|uwR10|uwR11|uwR12|uwR13|uwR14|uwR15|uwR16|uwR17|uwR18|uwR19|uwR20|uwR22|uwR23|uwR24|uwR25|uwR26|uwR27|uwR28|uwR29|uwR21|uwR30|uwR3];

 
pattern sbregs means[bR4|bR5|bR6|bR7|bR8|bR9|bR10|bR3];

 
pattern ubregs means[ubR4|ubR5|ubR6|ubR7|ubR8|ubR9|ubR10|ubR3];

 
pattern uoregs means[oR4|oR5|oR6|oR7|oR8|oR9|oR10|oR3];

 
pattern shregs means[sR4|sR5|sR6|sR7|sR8|sR9|sR10|sR3];

 
pattern uhregs means[hR4|hR5|hR6|hR7|hR8|hR9|hR10|hR3];

 
pattern uhxregs means[hxR4|hxR5|hxR6|hxR7|hxR8|hxR9|hxR10|hxR3];
 
/* \end{verbatim}
\subsection{Register Pattern }
\begin{verbatim}    
*/
pattern indexreg 	means	[ siregs ] ;
pattern reg 		means	[ siregs | uiregs ];
pattern wreg 		means	[ swregs | uwregs ];
pattern hreg 		means	[ shregs | uhregs | uhxregs ];
pattern breg	 	means	[ sbregs | ubregs | uoregs ];
pattern anyreg 		means	[  breg|reg    | wreg   | hreg    ];
pattern wordreg		means	[ wreg | hreg | breg ];
pattern signedreg	means	[ siregs | swregs | shregs | sbregs ];
pattern unsignedreg means	[ uiregs | uwregs | ubregs | uhregs | uhxregs];
/*09/10/09 new part start*/
pattern nsreg		means	[ shregs | uhregs | uhxregs ];
/*09/10/09 end*/
/*
\end{verbatim}
*/
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Operators Definitions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

/*
\begin{verbatim}
*/
operation add 		means 	+  	assembles ['add'];
operation and 		means 	AND	assembles ['and'];
operation or  		means 	OR 	assembles ['or'] ;
operation xor	 	means 	XOR	assembles ['xor'];
operation sub 		means 	-  	assembles ['sub'];
operation mul	  	means 	* 	assembles ['mullw'];  
operation muli	  	means 	* 	assembles ['mull'];  
operation dv		means	div assembles ['divw']; 
operation max		means	MAX assembles['max'];
operation min		means	MIN assembles['min'];
operation rem		means	MOD assembles['rem'];
operation lt	  	means	< 	assembles ['lt'];
operation gt 		means 	> 	assembles ['gt'];
operation eq	 	means 	= 	assembles ['eq'];
operation ng 		means 	<= 	assembles ['ng'];
operation le 		means	<= 	assembles ['le'];
operation nl 		means 	>= 	assembles ['nl'];
operation ge 		means 	>= 	assembles ['ge'];
operation ne 		means 	<> 	assembles ['ne'];

operation shiftleft 	means 	<< 	assembles ['l'];
operation shiftright	means 	>> 	assembles ['r'];

/* \end{verbatim} 
\subsection{Operations Pattern }
\begin{verbatim}
*/

pattern logicoperator		means [and|or|xor];
pattern logicandoperator	means [and];
pattern nonmultoperator 	means [add|sub|logicoperator]; 
pattern immediateoperator 	means [add|sub|muli|or|xor]; 
pattern operator 			means [mul|dv|nonmultoperator]; 
pattern condition 			means [lt|gt|eq|ng|le|nl|ge|ne];
pattern cregcond			means [lt|gt|eq];
pattern unsignedcondition 	means [ne|nl|ng|eq];
pattern shiftop 			means [shiftleft|shiftright];
pattern eqcondition 		means [ne|eq];
/*
\end{verbatim}
*/
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					Memory Addresses Operations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
/*
\begin{verbatim}
*/
pattern 	labelf(label l)	
		means [l]	
		assembles [l];

pattern 	eareg(anyreg r)	
	 	means	[^(r)]		
		assembles ['('r')'];
	
pattern		regindirf(anyreg r)
	    means[^(r) ]
	    assembles['0(' r ')'];
	    
pattern 	offset(wordupto16 s)
		means	[const s]
		assembles [s];

pattern regoffset(wordupto32 s)
		means	[const s]
		assembles [s];


pattern 	immediate(signed s)
		means  	[const s] 	
		assembles [s];

pattern 	uimmediate(unsigned s)
		means  	[const s] 	
		assembles [s];

pattern 	intimmediate(int s) 
		means 	[const s] 	
		assembles [s];


		
/*09/10/09 new part start*/
	
pattern directf(unsigned s)
	means[const s]
	assembles[  s '(,1)' ];
pattern udirectf(int s)
	means[const s]
	assembles[  s '(,1)' ];
pattern barelab(label l)
	means[l]
	assembles[l];
pattern labelconstf(barelab l,signed s)
	means [+(l,const s)]
	assembles[l'+'s];
pattern constf(signed s)
	means[const s]
	assembles [s];


pattern offset2 means[/*labelconstf|*/constf|barelab];
pattern 	baseplusoffsetf(anyreg r, offset s )
		means	[ +( ^(r) , s )]
		assembles [ s'('r')' ];
pattern 	baseminusoffsetf(anyreg r, offset s ) 
		means	[ -( ^(r) , s )]
		 assembles [ '-'s'('r')'];


/* allow the address expression to be cast to an integer */
/*pattern eaform(guncasteaform f,int t)  
	means[(t)f]
	assembles[f];*/ 
	
pattern mainbase(barelab l,offset s)
	means [+(l,const s)]
	assembles[s'(r21)'];
/*
pattern mainbase1(barelab l,regoffset s)
	means [+(l, const s)]
	assembles['loadintr  r28 ,' s
			  '\n add r21,r21,r28'
			  '\n 0(r21)'];
*/	
pattern 	eaform 		means [/*mainbase|*/baseplusoffsetf | baseminusoffsetf  ];

pattern 	addrform 	means [eaform| regindirf];

pattern 	maddrmode(addrform f) 		
		means 	[mem(f)] 
		assembles [ f ];

pattern 	jumpmode 		means	[labelf|maddrmode];
pattern 	addrmode 		means	[maddrmode|anyreg]; 


pattern 	regaddrop(addrmode r)
		means[^(r)] 
		assembles[r];


pattern 	regaddrimmediate 	means[intimmediate|maddrmode|regaddrop];

instruction pattern PLANT(label l)
		means		[l] 
		assembles	[l':'];  
		
instruction pattern GOTO(anyreg r)
		means		[goto r]
		assembles	['mfctr TMPREG'
				   '\n mtctr ' r
				   '\n bctr ' 
				   '\n mtctr TMPREG' ];
				   
instruction pattern GOTO1(labelf l)
		means		[goto l]
		assembles	['b ' l];

instruction pattern LOADADDRESSfromVAR(wreg r, labelf lbl)
		means		[r:= lbl ]
		assembles	['lis ' r ',' lbl'@ha'
					 '\n la  ' r ',' lbl'@l(' r ')'];

instruction pattern LOADADDRESSfromDISP(wreg r, eaform ea)
		means		[r:= ea ]
		assembles	['la 'r','ea];

instruction pattern LOADADDRESSfromDISP2(wreg r, addrform ea)
		means		[r:= ea ]
		assembles	['la 'r','ea];

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
						Stack Instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction pattern INCSP(wordupto16 i)  
		means[ R1 :=+ (^(R1),i) ] 
		assembles['addi SP, SP, 'i]; 

instruction pattern DECSP(wordupto16 i)
		means[ R1 :=- (^(R1),i) ]  
		assembles['addi SP,SP,-'i]; 
			
instruction pattern PUSHDREG(reg r) 
		means[PUSH(mainSTACK,^(r))] 
		assembles['stdu ' r ', -8(SP)']; 

instruction pattern POPDREG(reg r)
		means[r:=(int64)POP(mainSTACK)] 
		assembles['ldu 'r', 8(SP)']; 
		

instruction pattern PUSHWREG(wreg r) 
		means[PUSH(mainSTACK,^(r))] 
		assembles['stwu 'r', -4(SP) '];  
	
instruction pattern POPWREG(wreg r,word32 t)
		means[(ref t) r:=(int32)POP(mainSTACK)] 
		assembles['lwzu 'r', 4(SP)']; 

instruction pattern PUSHHREG(hreg r) 
		means[PUSH(mainSTACK,^(r))] 
		assembles['sthu 'r', -4(SP)']; 
	
instruction pattern POPHREG(hreg r,word16 t)
		means[(ref t) r:=(int16)POP(mainSTACK)] 
		assembles['lhzu 'r', 4(SP)']; 

instruction pattern PUSHBREG(breg r) 
		means[PUSH(mainSTACK,^(r))] 
		assembles['stbu 'r', -4(SP)']; 
	
instruction pattern POPBREG(breg r,byte t)
		means[(ref t) r:=(int8)POP(mainSTACK)] 
		assembles['lbzu 'r', 4(SP)']; 


/*
\end{verbatim}
*/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Load Instructions  
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
instruction pattern UALOADD(reg r, reg base, offset s, word64 t)
    	means		[r:= (t)^(mem(+(^(base),s)))]
		assembles	['unalignload ' r ',' base ',' s ];

instruction pattern UALOADW(wreg r, wreg base, offset s,word32 t)
    	means		[r:= (t)^(mem(+(^(base),s)))]
		assembles	['unalignload ' r ',' base ',' s ];

instruction pattern UALOADH(hreg r, hreg base, offset s, word16 t)
    	means		[r:= (t)^(mem(+(^(base),s)))]
		assembles	['unalignload ' r ',' base ',' s ];

instruction pattern UALOADB(breg r, breg base, offset s, byte t)
    	means		[r:= (t)^(mem(+(^(base),s)))]
		assembles	['unalignload ' r ',' base ',' s ];
		
instruction pattern LOAD(maddrmode rm, reg r, word64 t)
    	means		[r:= (t)^(rm)]
		assembles	['ld ' r ',' rm ];

instruction pattern LOADW(maddrmode rm, wreg r, word32 t)
    	means		[r:= (t)^(rm)]
		assembles	['lwz ' r ',' rm ];

instruction pattern LOADH(maddrmode rm, hreg r, word16 t)
    	means		[r:= (t)^(rm)]
		assembles	['lhz ' r ',' rm ];

instruction pattern LOADB(maddrmode rm, breg r, byte t)
    	means		[r:= (t)^(rm)]
		assembles	['lbz ' r ',' rm ];
pattern waddrmode means[maddrmode|wreg];
pattern haddrmode means[maddrmode|hreg];
pattern baddrmode means[maddrmode|breg];


instruction pattern LWZ(maddrmode rm, anyreg r,word32 t1,word64 t2)
    	means		[r:= (t2)EXTEND((t1)^(rm))]
		assembles	['lwz ' r ',' rm ];

instruction pattern LHZ(maddrmode rm, anyreg r, word16 t1,word64 t2)
		means		[r:=(t2)EXTEND((t1)^(rm))]
		assembles	['lhz ' r ',' rm];

instruction pattern LHZ2(maddrmode rm, anyreg r, word16 t1,word32 t2)
		means		[r:=(t2)EXTEND((t1)^(rm))]
		assembles	['lhz ' r ',' rm];
		
instruction pattern LBZ(maddrmode rm, anyreg r, byte t1,word64 t2)
		means		[r:=(t2)EXTEND((t1)^(rm))]
		assembles	['lbz ' r ',' rm];

instruction pattern LBZ2(maddrmode rm, anyreg r, byte t1,word32 t2)
		means		[r:=(t2)EXTEND((t1)^(rm))]
		assembles	['lbz ' r ',' rm];
		
instruction pattern LBZ3(maddrmode rm, anyreg r, byte t1,word16 t2)
		means		[r:=(t2)EXTEND((t1)^(rm))]
		assembles	['lbz ' r ',' rm];

instruction pattern LDX(reg r, reg r2, reg r3)
		means 		[r:=(int64) mem( +( ^(r2) , ^(r3)  ) ) ]
		assembles	['ldx ' r ',' r2 ',' r3 ];

instruction pattern LWZX(reg r, anyreg r2, anyreg r3,word32 t)
		means 		[r:=(int64)EXTEND( (t)mem( +( ^(r2) , ^(r3)  ) ) )]
		assembles	['lwzx ' r ',' r2 ',' r3 ]; 
 
instruction pattern LHZX(reg r, anyreg r2, anyreg r3,word16 t)
		means		[r:=(int64)EXTEND((t) mem(+(^(r2) ,^(r3) ) ) )]
		assembles	['lhzx ' r ',' r2 ',' r3 ];

instruction pattern LBZX(reg r, anyreg r2, anyreg r3,byte t)
		means		[r:=(int64)EXTEND((t) mem(+( ^(r2) , ^(r3) ) ) )]
		assembles	['lbzx ' r ',' r2 ',' r3 ];

 
instruction pattern LHZX2(anyreg r, anyreg r2, anyreg r3,word16 t,word32 tt)
		means		[r:=(tt)EXTEND((t) mem(+(^(r2) ,^(r3) ) ) )]
		assembles	['lhzx ' r ',' r2 ',' r3 ];

instruction pattern LBZX2(anyreg r, anyreg r2, anyreg r3,byte t,word32 tt)
		means		[r:=(tt)EXTEND((t) mem(+( ^(r2) , ^(r3) ) ) )]
		assembles	['lbzx ' r ',' r2 ',' r3 ];

instruction pattern LBZX3(anyreg r, anyreg r2, anyreg r3,byte t,word16 tt)
		means		[r:=(tt)EXTEND((t) mem(+( ^(r2) , ^(r3) ) ) )]
		assembles	['lbzx ' r ',' r2 ',' r3 ];

instruction pattern LOADLITI1(wordupto16 i, anyreg r)
		means		[r:=const i]
		assembles	['li ' r ',' i ]; 

instruction pattern LOADLITI(int i, anyreg r)
		means		[r:=const i]
		assembles	['loadintr ' r ',' i ]; 

instruction pattern LOADLITD(int i, anyreg r)
		means		[r:=const i]
		assembles	['loadd ' i
					 '\n mr ' r ', TMPREG']; 

instruction pattern LOADLITS(int i, anyreg r)
		means		[r:=const i]
		assembles	['loads ' i
					 '\n mr ' r ', TMPREG']; 

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Store Instructions  
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
instruction pattern UASTORE(reg r, reg base, offset s)
    	means		[ mem(+(^(base),s)) := r]
		assembles	['unalignstore ' r ',' base ',' s ];

instruction pattern STORED(maddrmode rm, reg r, word64 t)   
    	means		[ (ref t) rm:= ^(r) ]
		assembles	['std 'r','rm];
		
instruction pattern STOREW(maddrmode rm, wreg r, word32 t)
		means		[ (ref t) rm:= ^(r) ]
		assembles	['stw 'r','rm];
		
instruction pattern SW(reg r,reg rm, wordupto32 t)
	means[(ref t)mem(rm):=(t)^(r)]
	assembles['stw 'r',0('rm')'];
	
	
instruction pattern STOREW2(barelab l, wreg r1, wreg r2, word32 t, regoffset s)
		means		[(ref t) mem(+(l, s)) := r1]
		assembles['loadintr ' r2 ',' s
			  '\n add r27,r21,' r2
			  '\n stw' r1 ',0(r27)'];

instruction pattern STOREH(maddrmode rm, hreg r , word16 t)
		means		[ (ref t) rm:= ^( r) ]
		assembles	['sth 'r','rm];

instruction pattern STOREB(maddrmode rm, breg r, byte t)
	    	means		[ (ref t) rm:= ^(r) ]
		assembles	['stb 'r','rm];

/*
\end{verbatim}
*/
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Arithmetic Operations  
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
pattern const16(wordupto16 i)
    	        means           [ const i ]
                assembles       [ i ];
 
 pattern unconst16(unsignedup16 i)
    	        means           [ const i ]
                assembles       [ i ];
                
instruction pattern LOGOPERATION(operator op, anyreg r, anyreg r2, anyreg r3, int t)
	means		[(ref t) r := op ( (t)^(r3),(t)^(r2) ) ]
	assembles	[op' 'r','r3','r2];

instruction pattern ARIMOPERATION(immediateoperator op,reg r, anyreg r2, const16 r3, int t)
	means		[r :=   (t)op( (t)^(r2),r3 ) ]
	assembles	[op'i 'r','r2','r3];

instruction pattern ANDMOPERATION(reg r, anyreg r2, unconst16 r3, int t)
	means		[r :=   (t)AND( (t)^(r2),r3 ) ]
	assembles	['andi. ' r ',' r2 ',' r3];

instruction pattern ORMOPERATION(reg r, anyreg r2, unconst16 r3, int t)
	means		[r :=   (t)OR( (t)^(r2),r3 ) ]
	assembles	['ori' r ',' r2 ',' r3];

instruction pattern ARIOPERATION(operator op,reg r, anyreg r2, anyreg r3, int t)
	means		[r := EXTEND( (t)op( (t)^(r2),(t)^(r3) ) )]
	assembles	[op' 'r','r2','r3];

instruction pattern DIVD(reg r, reg r2)
   	means		[r:=div(^(r),^(r2))]
	assembles	['divd 'r','r','r2];
	
instruction pattern DIVW(wreg r, wreg r2)
   	means		[r:=div(^(r),^(r2))]
	assembles	['divw 'r','r','r2];
	
instruction pattern UDIVD(unsignedreg r, unsignedreg r2)
   	means		[r:=div((uint64)^(r),(uint64)^(r2))]
	assembles	['divdu 'r','r','r2];

instruction pattern UDIVW(unsignedreg r, unsignedreg r2)
   	means		[r:=div((uint32)^(r),(uint32)^(r2))]
	assembles	['divwu 'r','r','r2];

instruction pattern DIVD8(reg r)
	means		[r:=div((uint64)^(r),8)]
	assembles	['li r20,8 \n divdu 'r','r',r20'];

instruction pattern DIVW8(wreg r)
	means		[r:=div((uint32)^(r),8)]
	assembles	['li r20,8 \n divwu 'r','r',r20'];

instruction pattern MOD2(reg r)
	means		[r:=MOD(^(r),2)]
	assembles	['andi. 'r','r',1'];
	
instruction pattern MOD4(reg r)
	means		[r:=MOD(^(r),4)]
	assembles	['andi. 'r','r',3'];
	
instruction pattern MOD8(reg r)
	means		[r:=MOD(^(r),8)]
	assembles	['andi. 'r','r',7'];
	
instruction pattern MOD16(reg r)
	means		[r:=MOD(^(r),16)]
	assembles	['andi. 'r','r',15'];	

instruction pattern MODint32(anyreg r1, anyreg r2, anyreg r3, wordupto32 t)
    means[(ref t)r1:=  MOD(  (t)^(  r2), (t)^(  r3))]
	assembles['divw  ' r1 ',' r2 ',' r3
		   '\n mullw ' r1 ',' r1 '.' r3
		   '\n subf  ' r1 ',' r1 ',' r2];
instruction pattern MODEXTNEDint32(wreg r1, anyreg r2, immediate s,wordupto32 t)
    means[r1:=MOD((int32)EXTEND((t)^(r2)),s) ]
	assembles['li  r30 ,' s
			  '\n divw  ' r1 ',' r2  ', r30'
		      '\n mullw ' r1 ',' r1  ', r30'
		      '\n subf  ' r1 ',' r1  ',' r2];

/*
\begin{verbatim}
*/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					Conditional Operations  
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/


instruction pattern IFWBOOL(label l, wordreg r, wordupto32 t) 
	means		[if(  (t)^(r)  ) goto l]
	assembles	['cmpwi ' r ',0' '\n bne ' l]; 		

instruction pattern IFDBOOL(label l, reg r, word64 t) 
	means		[if(  (t)^(r)  ) goto l]
	assembles	['cmpdi ' r ',0' '\n bne ' l]; 


instruction pattern IFLOGICOP(nonmultoperator op, addrmode rm1, addrmode rm2,anyreg r, int t, label l)
	means [if ( (int8) op( (int8)^(rm1) , (int8)^(rm2) ) ) goto l]
	assembles ['nop'];
	/*assembles [op ' 'rm2','rm1];*/

instruction pattern IFGOTO(label l, anyreg r1, anyreg  r2,eqcondition c)
	means[if((int8)c( ^(r1),^(r2)))goto l]
	assembles['cmpw ' r1 ','  r2 
			  '\n b'c ' ' l];
instruction pattern IFGTGOTO(label l,anyreg r1, anyreg  r2)
	means[if((int8)>( ^(r1),^(r2)))goto l]
	assembles['cmpw ' r1 ','  r2 
			  '\n bgt ' l];
instruction pattern IFLTGOTO(label l,anyreg r1, anyreg  r2)
	means[if((int8)<( ^(r1),^(r2)))goto l]
	assembles['cmpw ' r1 ','  r2 
			  '\n blt ' l];
instruction pattern IFGEGOTO(label l,anyreg r1, anyreg  r2)
	means[if((int8)>=( ^(r1),^(r2)))goto l]
	assembles['cmpw ' r1 ','  r2 
			  '\n bge ' l];
instruction pattern IFLEGOTO(label l,anyreg r1, anyreg  r2)
	means[if((int8)<=( ^(r1),^(r2)))goto l]
	assembles['cmpw ' r1 ','  r2 
			  '\n ble ' l];

instruction pattern IFLITGOTO(label l,anyreg r1,wordupto16 r2,condition c,signed t,int b)
	means[if((b)c((t) ^(r1),const r2))goto l]
	assembles['cmpwi  ' r1 ',  '  r2 
			  '\n b'c '   '  l];

instruction pattern IFLITGOTO2(label l,anyreg r1,signed s,condition c,signed t,int b)
	means[if((b)c((t) ^(r1),const s))goto l]
	assembles[' loadint ' s
			  '\n cmpw  ' r1 ', r30 '  
			  '\n b'c '   '  l];

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					Compersion Operations  
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/


instruction pattern SETW(condition c,anyreg r3,anyreg r2, anyreg r,type t1, wordupto32 t)
	means		[(ref t1) r:=(t1) c((t)^(r3),(t)^(r2))]
 	assembles  ['cmpw 'r3 ',' r2 
 				'\n li ' r ',0' 
 				'\n b'c ' 1f' 
 				'\n b 1f' 
 				'\n 1: not	' r ',' r 
 				'\n 2: nop'];

instruction pattern SETD(condition c,anyreg r3,anyreg r2, anyreg r,type t1, word64 t)
	means		[(ref t1) r:=(t1) c((int64)^((ref t)r3),(int64)^((ref t)r2))]
 	assembles  ['cmpd 'r3 ',' r2 
 				'\n li ' r ',0' 
 				'\n b'c ' 1f' 
 				'\n b 1f' 
 				'\n 1: not	' r ',' r 
 				'\n 2: nop'];

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			MINIMUM & MAXIMUM Operations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
instruction pattern INTDMIN(reg r1,reg r2)
	  	means		[ r1:=MIN(^(r1),^(r2))] 
		assembles	['cmpd  'r1','r2'\n  blt 1f \n addi 'r1','r2',0 \n 1:nop'];
instruction pattern INTDMAX(reg r1,reg r2)
	  	means		[ r1:=MAX(^(r1),^(r2))]
		assembles	['cmpd  'r1','r2'\n  bgt 1f \n addi 'r1','r2',0 \n 1:nop'];
instruction pattern INTWMIN(wreg r1,wreg r2)
	  	means		[ r1:=MIN(^(r1),^(r2))] 
		assembles	['cmpw  'r1','r2'\n  blt 1f \n addi 'r1','r2',0 \n 1:nop'];
instruction pattern INTWMAX(wreg r1,wreg r2)
	  	means		[ r1:=MAX(^(r1),^(r2))]
		assembles	['cmpw  'r1','r2'\n  bgt 1f \n addi 'r1','r2',0 \n 1:nop'];
instruction pattern INTHMIN(hreg r1,hreg r2)
        means[ (ref int16)r1:=MIN((int16)^(r1),(int16)^(r2))]
		assembles	['cmpw 'r2','r1'\n  blt 1f \n addi 'r2','r1',0 \n 1:nop'];
instruction pattern INTHMAX(hreg r1,hreg r2)
        means[(ref int16) r1:=MAX((int16)^(r1),(int16)^(r2))]
		assembles	['cmpw 'r2','r1'\n  bgt 1f \n addi 'r2','r1',0 \n 1:nop'];
instruction pattern INTBMIN(breg r1,breg r2)
        means[(ref int8) r1:=MIN((int8)^(r1),^(r2))]
		assembles	['cmpw 'r2','r1'\n  blt 1f \n addi 'r2','r1',0 \n 1:nop'];
instruction pattern INTBMAX(breg r1,breg r2)
        means[(ref int8)r1:=MAX((int8)^(r1),^(r2))]
		assembles	['cmpw 'r2','r1'\n  bgt 1f \n addi 'r2','r1',0 \n 1:nop'];
instruction pattern INTNBMIN(breg r1,breg r2)
        means[(ref uint8) r1:=MIN((uint8)^(r1),^(r2))]
		assembles	['cmpw 'r2','r1'\n  blt 1f \n addi 'r2','r1',0 \n 1:nop'];
instruction pattern INTNBMAX(breg r1,breg r2)
        means[(ref uint8)r1:=MAX((uint8)^(r1),^(r2))]
		assembles	['cmpw 'r2','r1'\n  bgt 1f \n addi 'r2','r1',0 \n 1:nop'];


/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			SHIFT Operations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction pattern SHIFTWIMM(shiftop op, anyreg r, immediate s, type t)
		means		[ (ref t) r:= (t)op(^(r),s)] 
		assembles	['s'op'wi ' r ', ' r ',' s];

instruction pattern SHIFTWREG(shiftop op, anyreg r, anyreg r2, type t)
		means		[ (ref t) r:= (t)op(^(r),^(r2))]
		assembles	['s'op 'w ' r ', ' r ',' r2];

instruction pattern SHIFTDIMM(shiftop op, anyreg r, immediate s, type t)
		means		[ (ref t) r:= (t)op(^(r),s)] 
		assembles	['s'op'di ' r ', ' r ',' s];

instruction pattern SHIFTDREG(shiftop op, anyreg r, anyreg r2, type t)
		means		[ (ref t) r:= (t)op(^(r),^(r2))]
		assembles	['s'op 'd ' r ', 'r ',' r2];

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Saturated Operations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
instruction pattern ADDUSB(ubregs r1,ubregs rm)
	means[ rm:= +:((uint8)^(rm),^(r1))]
	assembles[ 'add.  ' rm ',' rm ',' r1 
			'\n bne 1f '
			'\n li ' rm ',255'
			'\n 1: nop']; 
/*	assembles[ 'vaddubs  ' rm ',' rm ',' r1]; */
	
instruction pattern ADDSSB(sbregs r1,sbregs rm)
	means[ rm:=(int8) +:((int8)^(rm),^(r1))]
	assembles[ 'add.  ' rm ',' rm ',' r1 
			'\n bne 1f '
			'\n li ' rm ',127'
			'\n 1: nop']; 
/*	assembles[ 'vaddsbs  ' rm ',' rm ',' r1]; */

instruction pattern SUBUSB(ubregs r1,ubregs rm)
	means[ rm:= -:((uint8)^(rm),^(r1))]
	assembles[ 'sub  ' rm ',' rm ',' r1 
			'\n bne 1f '
			'\n li ' rm ',0'
			'\n 1: nop']; 

/*	assembles[ 'vsububs  ' rm ',' rm ',' r1]; */

instruction pattern SUBSSB(sbregs r1,sbregs rm)
	means[ rm:= (int8)-:((int8)^(rm),^(r1))]
	assembles[ 'sub  ' rm ',' rm ',' r1 
				'\n bne 1f '
			'\n li ' rm ',-127'
			'\n 1: nop']; 

instruction pattern MULUSB(ubregs r1,ubregs rm)
	means[ rm:= *:((uint8)^(rm),^(r1))]
	assembles[ 'add.  ' rm ',' rm ',' r1 
			'\n bne 1f '
			'\n li ' rm ',255'
			'\n 1: nop']; 
/*	assembles[ 'vaddubs  ' rm ',' rm ',' r1]; */
	
instruction pattern MULSSB(sbregs r1,sbregs rm)
	means[ rm:=(int8) *:((int8)^(rm),^(r1))]
	assembles[ 'add.  ' rm ',' rm ',' r1 
			'\n bne 1f '
			'\n li ' rm ',127'
			'\n 1: nop']; 

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Other Operations
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction  pattern INC(addrmode rm,int t)
	means[(ref t)rm:=   + (^(rm),1)]
	assembles['addi' rm ',' rm ',1']; 

instruction  pattern DEC(addrmode rm,int t)
	means[(ref t)rm:=   - ((t)^(rm),1)]
	assembles['addi' rm ',' rm ',-1']; 
	
instruction pattern IFBOOL(label l,breg r1)
	means[ if( (int8)^(r1))goto l]
	assembles['cmpw ' r1 ',' r1 '\n beq ' l];
	
instruction pattern NOTOP(anyreg r,anyreg r2, type t)
	means[(ref t)r:= NOT((t)^(r2))]
	assembles['not ' r ',' r2];
	
instruction pattern NEG(anyreg r, int t)
		means		[(ref t)r:= -((t)0,(t)^((ref t)r))]
		assembles 	['neg ' r ',' r];    

instruction pattern STOREPNTR64(maddrmode rm1,reg r, type t)
    		means		[ (ref ref t) rm1:=  ^(r) ]
			assembles	['std ' r ', ' rm1 ];		
			
instruction pattern STOREPNTR32(maddrmode rm1,wreg r, type t)
    		means		[ (ref ref t) rm1:=  ^(r) ]
			assembles	['stw ' r ', ' rm1 ];		

instruction pattern UASTOREPNTR(reg r, reg base, offset s, type t)
    	means		[(ref ref t) mem(+(^(base),s)) := ^(r)] 
		assembles	['unalignstore ' r ',' base ',' s ];

instruction pattern CLEARREG(anyreg r,  type t)
    		means		[ (ref t) r:= (t)0 ]
		assembles	['li ' r ',0'];
		
instruction pattern SELECT(anyreg r,anyreg r2,addrmode rm,wordupto64 t)
	means		[(ref t) r:=OR(AND((t)^(r),(t)^(r2)),AND((t)^(rm),NOT(^(r2))))]
	assembles	['   and ' r ',' r ',' r2
			 '\n not ' r2 ',' r2 
			 '\n andi. ' r2 ',' r2 ',' rm
			 '\n or  ' r ',' r ',' r2];   

instruction pattern PLANTDICONST( word64 r,type t) 
	means[loc (t) r] 
	assembles[ '.quad ' r];

instruction pattern PLANTICONST(longint r,type t) 
	means[loc (t) r] 
	assembles[ '.long ' r];

instruction pattern PLANTBCONST( byte r,type t) 
	means[loc (t) r]
	assembles[ '.byte ' r];
instruction pattern PLANTHCONST( word16 r,type t) 
	means[loc (t) r] 
	assembles[ '.short ' r];

instruction pattern FAIL(int i)
	means [interrupt i]
	assembles ['li      0,1'
				'\n li      3,1'
				'\n sc '];

/* \end{verbatim} */


 
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 	Floating-Point Instructions Definitions - PowerPC-base Architecture
	2007/2008
	Youssef Gdura & Dr. Paul Cockshoot    
	Computer Science Dep. Glagsow Unievrsity
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/



/* Floating Point Registers */

/* Signed double-precision 64-bit registers */



register ieee64 F0 assembles['f0'];
register ieee64 F1 assembles['f1'];
register ieee64 F2 assembles['f2'];
register ieee64 F3 assembles['f3'];
register ieee64 F4 assembles['f4'];
register ieee64 F5 assembles['f5'];
register ieee64 F6 assembles['f6'];
register ieee64 F7 assembles['f7'];
register ieee64 F8 assembles['f8'];
register ieee64 F9 assembles['f9'];
register ieee64 F10 assembles['f10'];
register ieee64 F11 assembles['f11'];
register ieee64 F12 assembles['f12'];
register ieee64 F13 assembles['f13'];
register ieee64 F14 assembles['f14'];
register ieee64 F15 assembles['f15'];
register ieee64 F16 assembles['f16'];
register ieee64 F17 assembles['f17'];
register ieee64 F18 assembles['f18'];
register ieee64 F19 assembles['f19'];
register ieee64 F20 assembles['f20'];
register ieee64 F21 assembles['f21'];
register ieee64 F22 assembles['f22'];
register ieee64 F23 assembles['f23'];
register ieee64 F24 assembles['f24'];
register ieee64 F25 assembles['f25'];
register ieee64 F26 assembles['f26'];
register ieee64 F27 assembles['f27'];
register ieee64 F28 assembles['f28'];
register ieee64 F29 assembles['f29'];
 

reserved register ieee64 f30 assembles['f30'];  
reserved register ieee64 f31 assembles['f31']; 

/* Signed floating point 32-bit registers */



alias register ieee32 sF0=F0(0:31) assembles['f0'];
alias register ieee32 sF1=F1(0:31) assembles['f1'];
alias register ieee32 sF2=F2(0:31) assembles['f2'];
alias register ieee32 sF3=F3(0:31) assembles['f3'];
alias register ieee32 sF4=F4(0:31) assembles['f4'];
alias register ieee32 sF5=F5(0:31) assembles['f5'];
alias register ieee32 sF6=F6(0:31) assembles['f6'];
alias register ieee32 sF7=F7(0:31) assembles['f7'];
alias register ieee32 sF8=F8(0:31) assembles['f8'];
alias register ieee32 sF9=F9(0:31) assembles['f9'];
alias register ieee32 sF10=F10(0:31) assembles['f10'];
alias register ieee32 sF11=F11(0:31) assembles['f11'];
alias register ieee32 sF12=F12(0:31) assembles['f12'];
alias register ieee32 sF13=F13(0:31) assembles['f13'];
alias register ieee32 sF14=F14(0:31) assembles['f14'];
alias register ieee32 sF15=F15(0:31) assembles['f15'];
 
/*
\ 
\ 
\pattern freg means[F0|F1|F2|F3|F4|F5|F6|F7|F8|F9|F10|F11|F12|F13|F14|F15|F16|F17|F18|F19|F20|F21|F22|F23|F24|F25|F26|F27|F28|F29];
\ 
\ 
\pattern sfreg means[sF0|sF1|sF2|sF3|sF4|sF5|sF6|sF7|sF8|sF9|sF10|sF11|sF12|sF13|sF14|sF15];
*/
pattern freg means[F0|F1|F2|F3|F4|F5|F6|F7|F8|F9|F10|F11|F12|F13|F14|F15|F16|F17|F18|F19|F20|F21|F22|F23|F24|F25|F26|F27|F28|F29];
 
 
pattern sfreg means[sF0|sF1|sF2|sF3|sF4|sF5|sF6|sF7|sF8|sF9|sF10|sF11|sF12|sF13|sF14|sF15];

pattern anyfreg means [ freg | sfreg ]; 

/* \subsection{fpu instructions} 

\begin{verbatim}
*/  

register stack(32)ieee64 ST assembles[ 'ST']; 
operation fml	  	means 	* 	assembles ['mul'];
operation fdv		means	div assembles ['div'];

pattern		foperator	means[ add|sub|fml|fdv ];
pattern 	anyreal 	means[ieee32|ieee64];
pattern 	fptype 	means[anyreal|int64|int32];
pattern 	fpuint 		means[int32|int16|int64];


pattern 	fimmediate(real s)
			means  	[const s] 	
			assembles 	[s];


/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			LOAD instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
/*
instruction pattern LOADFS(maddrmode rm, anyfreg f1, real t)
    means		[(ref ieee32)f1:= (ieee32)^((ref t) rm)]  
	assembles	['lfs ' f1 ',' rm ]; */ 
	
instruction pattern LOADFD(maddrmode rm, anyfreg f1, real t)
    means		[(ref ieee64)f1:= (ieee64)^((ref t) rm)]  
	assembles	['lfd ' f1 ',' rm ]; 

instruction pattern LOADLITSF(fimmediate s, sfreg r)
		means		[r:= s]
		assembles	['sloadr ' r ',' s ]; 

instruction pattern LOADLITDF(fimmediate s, freg r)
		means		[r:= s]
		assembles	['dloadr ' r ',' s]; 

instruction pattern MOVEREGTREG(anyfreg f1, anyfreg f2, real t)
    means		[(ref t)f2:= (t)^((ref t) f1)]  
	assembles	['fmr ' f2 ',' f1 ]; 

instruction pattern LOADFS(maddrmode rm, anyfreg f1, real t)
    means		[(ref ieee32)f1:= (ieee32)^((ref t) rm)]  
	assembles	['lfs ' f1 ',' rm ]; 

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			STORE instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction pattern STOREFS(maddrmode rm, anyfreg f1, float t)
    means		[ (ref ieee32) rm:= (t)^(f1) ]
	assembles	['stfs 'f1','rm];
	
instruction pattern STOREFD(maddrmode rm, anyfreg f1, double t)
    means		[ (ref ieee64) rm:= (t)^(f1) ]
	assembles	['stfd 'f1','rm];	


/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					Arithmetic Opertaions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

		 	 
instruction pattern DOPERATION(foperator op, freg f1, freg f2)
	means 		[f1:=op( ^(f1),^(f2) )]
	assembles	['f'op ' 'f1','f1','f2];

instruction pattern SOPERATION(foperator op, sfreg sf1, sfreg sf2)
	means		[sf1:=(ieee32)op( (ieee32)^(sf1),(ieee32)^(sf2) )]
	assembles	['f'op's 'sf1','sf1','sf2];


/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					Trigeomatric Functions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/


instruction pattern FSIND(freg f, freg f1 )
				means[f:= SIN(^(f1))]   
				assembles ['FSIND ' f1 ', f31'];

instruction pattern FSINSCONS(sfreg f, fimmediate s )
				means[f:= SIN(s)]   
				assembles ['fsins ' s
					       '\n fmr ' f ', f1'];
instruction pattern FSINS(sfreg f, sfreg reg )
				means[f:= SIN(^(reg))]   
				assembles ['fsins ' reg
					       '\n fmr ' f ', f1'];
								
instruction pattern FCOSD(freg f, freg f1 )
				means[f:= COS(^(f1))]   
				assembles ['FCOSD ' f ',  f1'];

instruction pattern FCOSS(sfreg f, sfreg f1 )
				means[f:= COS(^(f1))]   
				assembles ['fcoss ' f2
							'\n fmr ' f ', f1'];

instruction pattern FTANS(freg f, freg f1)
				means[f:= TAN(^(f1))]   
				assembles ['ftans ' f1
							'\n fmr ' f ', f1'];

instruction pattern FTAND(freg f, freg f1)
				means[f:= TAN(^(f1))]   
				assembles ['FTAND ' f ', f'];

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					Geomatric Functions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/


instruction pattern SQRTS(freg f)
	means		[f:=SQRT(^(f))]
	assembles	['fsqrt 'f','f];
	
instruction pattern SQRTD(freg f, sfreg sf)
	means		[sf:=(ieee32)SQRT(^(f))]
	assembles	['fsqrts 'sf','f];	

instruction pattern FABS(anyfreg f1, anyfreg f2 )
				means[f1:= ABS(^(f2))]   
				assembles ['fabs ' f1 ', ' f2];




/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
						Comparesion Opertaions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/



instruction pattern FSET(condition c,anyfreg f1,anyfreg f2, breg r,byte b)  
	means[r:=(b) c( ^((ref ieee32)f1), (ieee32)^(f2) )]
	assembles  ['fcmpo 0,' f1 ', ' f2     
				'\n li ' r ',0'
				'\n b'c ' 1f' 
				'\n b 1f' 
				'\n 1: not ' r ',' r 
				'\n 2: nop'];


/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			Conditional Opertaions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction pattern FIFGOTO(condition c, label l, anyfreg f1, anyfreg f2, real t)
	means		[if( c( (t)^(f1) , (t)^(f2) ) ) goto l]
	assembles	['fcmpo    2,' f1 ',' f2
				 '\n b'c ' 2,' l ];

instruction pattern IFEQUALGOTO(condition c,label l, anyfreg f1,int t, real t1,anyfreg f2) 
	means		[if( (t) c ( (t1)^( f1) , (t1)^(f2) ) ) goto l] 
	assembles  ['fcmpo  0,' f1  ','  f2
				'\n beq ' l];  


instruction pattern FIFEQUALCONSTGOTO (condition c,label l, anyfreg f1,int t, real t1,fimmediate s) 
	means		[if( (t) c ( (t1)^((ref t1)f1) , s ) ) goto l] 
	assembles  ['floadr  ' s
				'\n fcmpo 0, 'f1 ', f30'
				'\n beq ' l];  
			 
			 
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
						Miscellaneous Opertaions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
			 
instruction pattern FMAX(anyfreg f1,anyfreg f2, real t)
	means		[ (ref t)f1:=MAX((t)^(f1),(t)^(f2))]
	assembles	['fcmpo 0, 'f1','f2'\n bgt $+8\n fmr 'f1','f2]; 

instruction pattern FMIN(anyfreg f1,anyfreg f2, real t)
	means		[ (ref t)f1:=MIN((t)^(f1),(t)^(f2))]
	assembles	['fcmpo 0, 'f1','f2'\n blt $+8\n fmr 'f1','f2]; 

instruction pattern FNEG(anyfreg f, real t)
		means	[(ref t)f:= -((t)0.0,(t)^((ref t)f))]
		assembles ['fneg ' f ',' f];

instruction pattern PLANTSCONST( float  r,fptype t)
	means[loc (ieee32) r]
	assembles[ '.float ' r];
	
instruction pattern PLANTDCONST( double r,type t)
	means[loc (ieee64)r]
	assembles[ '.double ' r];
	
			 
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					STACK-REGISTER instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction pattern PUSHDFREG(freg f) 
	means		[PUSH(mainSTACK,^(f))] 
	assembles	['stfdu ' f ', -8(SP)']; 
	
instruction pattern POPDFREG(freg f)
	means		[f:=(ieee64)POP(mainSTACK)] 
	assembles	['lfdu 'f', 8(SP)']; 
	
instruction pattern PUSHSFREG(sfreg f) 
	means		[PUSH(mainSTACK,^(f))] 
	assembles	['stfsu 'f', -4(SP)']; 

instruction pattern POPSFREG(sfreg f)
	means		[f:=(ieee32)POP(mainSTACK)] 
	assembles	['lfsu 'f', 4(SP)']; 


/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
					STACK-STACK instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

				
instruction pattern CONVINTtoSP(anyreal t,wreg r, freg f0, sfreg f1) 
	means[PUSH(mainSTACK,(ieee32)FLOAT((int32)POP(mainSTACK)))]
        assembles [ 'lwa ' r ', 0(SP)'
					'\n std	' r  ', -8(SP)'
					'\n lfd	' f0 ', 8(SP)'
					'\n fcfid	' f0 ',' f0
					'\n frsp ' f1 ',' f0
					'\n stfs ' f1 ', 0(SP)'];

instruction pattern CONVINTtoDP(freg f1) 
	means[PUSH(mainSTACK,(ieee64)FLOAT((int64)POP(mainSTACK)))]
        assembles [ 'lfd	' f1 ', 0(SP)'
					'\n fcfid	' f1 ',' f1
					'\n stfd ' f1 ', 0(SP)'];


instruction pattern CONVSPtoD(sfreg f1,anyfreg f2) 
		means [PUSH(mainSTACK,(int64)ROUND((ieee32)POP(mainSTACK)))] 
		assembles [	'flsu		' f1 ',4(SP)' 
					'\n fctid ' f2 ',' f1 
					'\n stfdu	' f2 ',-8(SP)'];

instruction pattern CONVSPtoW(sfreg f1, anyfreg f2) 
		means [PUSH(mainSTACK,(int32)ROUND((ieee32)POP(mainSTACK)))] 
		assembles [	'fls		' f1 ',0(SP)' 
					'\n fctiw	' f2 ',' f1 
					'\n stfs	' f2 ',0(SP)'];

instruction pattern CONVDPtoD(freg f1,freg f2) 
		means [PUSH(mainSTACK,(int64)ROUND((ieee64)POP(mainSTACK)))] 
		assembles [	'fld		' f1 ',0(SP)' 
					'\n fctid ' f2 ',' f1 
					'\n stfd	' f2 ',0(SP)'];

instruction pattern CONVDPtoW(freg f1, anyfreg f2) 
		means [PUSH(mainSTACK,(int32)ROUND((ieee64)POP(mainSTACK)))] 
		assembles [	'fldu		' f1 ',8(SP)' 
					'\n fctiw	' f2 ',' f1 
					'\n frsp    ' f2 ',' f2
					'\n stfsu	' f2 ',-4(SP)'];

instruction pattern ROUNDSPtoD(sfreg f1,anyfreg f2,reg r) 
		means [r:=(int64)ROUND((ieee32)^(f1))] 
		assembles [	'fctid  ' f2 ',' f1 
					'\n stfd  ' f2 ',-8(SP)'
					'\n ld    ' r  ', 8(SP)'];

instruction pattern ROUNDSPtoW(sfreg f1, anyfreg f2,wreg r) 
		means [r:=(int32)ROUND((ieee32)^(f1))] 
		assembles [	'fctiw  ' f1 ',' f1 
					'\n stfd  ' f1 ',-8(SP)'
					'\n lwa   ' r  ', 4(SP)'];

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			CONVERT instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
 

instruction pattern CONVFToINTW(anyfreg f2,anyfreg f1, wreg r) 
 	means 	[r:=(int32)^((ref ieee32)f1)]
	assembles ['fctiw  ' f2 ',' f1 
		       '\n stfd ' f2 ', -8(SP)'
		       '\n lwa  ' r ', -4(SP)']; 

instruction pattern CONVFToINTD(anyfreg f2, anyfreg f1, reg r) 
 	means 	[r:=(int64)^((ieee32)f1)]
 	assembles ['fctid ' f2 ',' f1 
		       '\n stfd ' f2 ', -8(SP)'
		       '\n ld  ' r ', 8(SP)']; 

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			EXTEND & ROUNDING instructions
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/

instruction pattern EXTENDSTD(freg f1,sfreg f2)
	means[f1:=(ieee64)EXTEND(^(f2))]
	assembles['	stfs ' f2 ', 0(SP)'
	          '\n	lfs  ' f1 ', 0(SP)'];
	

instruction pattern EXTENDSToD(anyfreg f1)  
	means[PUSH(mainSTACK,(ieee64)EXTEND((ieee32)POP(mainSTACK)))]
	assembles [ 'lfsu		' f1 ', 4(SP)'
				'\n stfdu	' f1 ', -8(SP)'];


instruction pattern ROUNDDTS(sfreg f1,freg f2)
	means[f1:=(ieee32)^(f2)]
	assembles['frsp ' f1 ', ' f2];

			
instruction pattern CONVINT32TSP(anyfreg f1,wreg r)
	means[f1:=(ieee32)FLOAT((int32)^(r))]
	assembles['extsw ' r ',' r 
			'\n std ' r ',-8(SP)' 
			'\n lfd ' f1 ',8(SP)'
			'\n fcfid ' f1 ',' f1
			'\n frsp ' f1 ',' f1];

instruction pattern CONVINT32TDP(freg f1,wreg r)
	means[f1:=(ieee64)FLOAT((int32)^(r))]
	assembles['extsw ' r ',' r
			'\n std ' r ',-8(SP)'
			'\n lfd ' f1 ',8(SP)'
			'\n fcfid ' f1',' f1];


instruction pattern CONVINT64TSP(anyfreg f1,reg r)
	means[f1:=(ieee32)FLOAT((int64)^(r))]
	assembles['std ' r ',-8(SP)' 
		    '\n lfd ' f1 ',8(SP)'
			'\n fcfid ' f1 ',' f1
			'\n frsp ' f1 ',' f1];

instruction pattern CONVINT64TDP(anyfreg f1,reg r)
	means[f1:=(ieee64)FLOAT((int64)^(r))]
	assembles['std ' r ',-8(SP)'
			'\n lfd ' f1',8(SP)'
			'\n fcfid ' f1',' f1];
				

instruction pattern LOADSPLIT(float fs, sfreg f) 
		means[f :=const fs]
		assembles['sloadr ' f ',' fs ];

instruction pattern LOADDPLIT(float fs, freg f) 
		means[f :=const fs]
		assembles['dloadr ' f ',' fs ];		
		

/* {PowerPC floating-Point instructions} */



pattern 	bfaddrmode 		means	[maddrmode];  
pattern 	hfaddrmode 		means	[maddrmode];
pattern 	wfaddrmode 		means	[maddrmode];
pattern 	qfaddrmode 		means	[maddrmode];


/* instructions for extending with zero's to 64-bits */

instruction pattern WMOVZXB(reg r, bfaddrmode rm, wordupto64 t)
	means [r := EXTEND((uint8)^(rm))]
	assembles ['lbz ' r ',' rm];


instruction pattern WMOVZXHW(reg r, hfaddrmode rm, wordupto64 t)
	means [r := EXTEND((uint16)^(rm))]
	assembles ['lhz 'r','rm];
	
instruction pattern PLANTLABEL( label l) 
	means[loc l] 
	assembles[ '.quad ' l];

pattern FLN(anyfreg f1,anyfreg f2,real t)
	means[(ref t) f1:=(t)LN((t)f2)] 
	assembles['nop'];

instruction pattern INTABS(anyreg r)
        means[ r:=ABS(^(r))]
		assembles['cmpwi ' r ',0'
				  '\n bge  1f' 
 				  '\n neg	' r ',' r
 				  '\n 2: nop'];





/*
\ PPC  machine description
*/

   

  
/* 
\section{SPE}
*/ 

register ieee32 vector(1024)  NV0  assembles[' 0'];
register ieee32 vector(1024)  NV1  assembles[' 1'];
register ieee32 vector(1024)  NV2  assembles[' 2'];
register ieee32 vector(1024)  NV3  assembles[' 3'];
register ieee32 vector(1024)  NV4  assembles[' 4'];
register ieee32 vector(1024)  NV5  assembles[' 5'];
register ieee32 vector(1024)  NV6  assembles[' 6'];
register ieee32 vector(1024)  NV7  assembles[' 7'];

pattern nregf means[NV0|NV1|NV2|NV3|NV4|NV5|NV6|NV7];
pattern nsrcf means[swR22|swR23|swR24|swR25|swR26|swR27];
pattern naddrmodef (nsrcf r)
        means[ mem(^(r))]
        assembles [r];
instruction  pattern speLOAD( naddrmodef rm, nregf r1)
        means[   r1 :=(ieee32 vector(1024))^(rm)]
        assembles['li 3, ' r1
				  '\n la  4,0(' rm ')'
				  '\n bl  speLoadVec'];


instruction  pattern speSTORE( naddrmodef dest1, nregf r1)
        means[(ref ieee32 vector(1024))  dest1  := ^(r1)]
        assembles['li 3, ' r1
				  '\n la  4,0(' dest1 ')'
				   '\n bl  speStoreVec'];

 instruction pattern speADDFLT(nregf r0,nregf r1 )
        means[r0:= +(^(r0),^(r1))]
        assembles['li 3, ' r0
				  '\n li 4,' r1
				  '\n bl  speAddVec'];

 instruction pattern speSUBFLT(nregf r0,nregf r1 )
        means[r0:= -(^(r0),^(r1))]
        assembles['li 3,' r0
				  '\n li 4,' r1
				  '\n bl  speSubVec'];

 instruction pattern speMULFLT(nregf r0,nregf r1 )
        means[r0:= *(^(r0),^(r1))]
        assembles['li 3,' r0
				  '\n li 4,' r1
				  '\n bl  speMulVec'];


 instruction pattern speDIVFLT(nregf r0,nregf r1 )
        means[r0:= div(^(r0),^(r1))]
        assembles['li 3,' r0
				  '\n li   4,' r1
				  '\n bl  speDivVec'];

instruction pattern speSQRTFLT(nregf r0)
	means		[r0:=SQRT(^(r0))]
       assembles['li 3,' r0
				  '\n li 4,' r0
				  '\n bl  speSQRTFVec'];

instruction  pattern speREPFLT( nregf r0, sfreg r1)
        means[   r0:=rep(^(r1),1024)]
        assembles['li 3, ' r0
				  '\n fmr 1,' r1
				  '\n bl  speRepVec'];


/*
\begin{verbatim}
*/








/*
\ PPC  machine description
*/

   

  
/* 
\section{SPE}
*/ 

register int32 vector(1024)  NVI0  assembles[' 0'];
register int32 vector(1024)  NVI1  assembles[' 1'];
register int32 vector(1024)  NVI2  assembles[' 2'];
register int32 vector(1024)  NVI3  assembles[' 3'];
register int32 vector(1024)  NVI4  assembles[' 4'];
register int32 vector(1024)  NVI5  assembles[' 5'];
register int32 vector(1024)  NVI6  assembles[' 6'];
register int32 vector(1024)  NVI7  assembles[' 7'];

pattern nregi means[NVI0|NVI1|NVI2|NVI3|NVI4|NVI5|NVI6|NVI7];
pattern nsrci means[swR22|swR23|swR24|swR25|swR26|swR27];
pattern naddrmodei (nsrci r)
        means[ mem(^(r))]
        assembles [r];
instruction  pattern speLOADINT( naddrmodei rm, nregi r1)
        means[   r1 :=(int32 vector(1024))^(rm)]
        assembles['li 3, ' r1
				  '\n la  4,0(' rm ')'
				  '\n bl  speLoadIntVec'];


instruction  pattern speSTOREINT( naddrmodei dest1, nregi r1)
        means[(ref int32 vector(1024))  dest1  := ^(r1)]
        assembles['li 3, ' r1
				  '\n la  4,0(' dest1 ')'
				   '\n bl  speStoreIntVec'];

 instruction pattern speADDINT(nregi r0,nregi r1 )
        means[r0:= +(^(r0),^(r1))]
        assembles['li 3, ' r0
				  '\n li 4,' r1
				  '\n bl  speAddIntVec'];

 instruction pattern speSUBINT(nregi r0,nregi r1 )
        means[r0:= -(^(r0),^(r1))]
        assembles['li 3,' r0
				  '\n li 4,' r1
				  '\n bl  speSubIntVec'];

 instruction pattern speMULINT(nregi r0,nregi r1 )
        means[r0:= *(^(r0),^(r1))]
        assembles['li 3,' r0
				  '\n li 4,' r1
				  '\n bl  speMulIntVec'];


 instruction pattern speDIVINT(nregi r0,nregi r1 )
        means[r0:= div(^(r0),^(r1))]
        assembles['li 3,' r0
				  '\n li   4,' r1
				  '\n bl  speDivIntVec'];

instruction pattern speREPINT(nregi vr, wreg r)
	means[vr:=rep(^(r),1024)]
	assembles['li 3,' vr
			  '\n mr 4,' r
				  '\n bl  speRepIntVec'];

/*
\begin{verbatim}
*/








/* \begin{verbatim}*/
/*instructionset [ PPCintcodes | PPCfpucodes  | PPCnewfpucodes |lastPPCintcodes | SPEfloatcodes ]*/
 
/*
\end{verbatim}
*/ 
instructionset[LOADW|LOAD|UALOADW|LOADLITI1|UALOADD|UALOADH|UALOADB|UASTORE|LWZ|LWZX|SW|STOREW|STORED|LOADB|LBZ
|LBZ2|LBZ3|LBZX|LBZX2|LBZX3|LOADADDRESSfromDISP|LOADB|STOREB|LOADH|STOREH|LOADH|LHZ|LHZX|LHZX2|LHZ2
|IFLITGOTO|IFLITGOTO2|MODEXTNEDint32|ARIMOPERATION|ANDMOPERATION|ORMOPERATION|LOGOPERATION|ARIOPERATION|STOREPNTR32|STOREPNTR64|LOADADDRESSfromVAR|LOADADDRESSfromDISP2|GOTO1|IFBOOL|INC
|DEC|CLEARREG|PLANT|GOTO|FAIL|NEG|ROUNDDTS|ROUNDSPtoW|ROUNDSPtoD|CONVINT32TSP|CONVINT32TDP|CONVINT64TSP|CONVINT64TDP|LOADSPLIT|LOADDPLIT
|speLOAD|speSTORE|speADDFLT|speSUBFLT|speMULFLT|speDIVFLT|speREPFLT|speSQRTFLT|speLOADINT|speSTOREINT|speREPINT|speADDINT|speSUBINT|speMULINT|speDIVINT
|SHIFTDIMM|SHIFTWIMM|INTNBMIN|INTNBMAX|INTWMIN|INTWMAX|INTDMIN|INTDMAX|INTHMIN|INTHMAX|INTBMIN|INTBMAX|UASTOREPNTR|SELECT|SHIFTDREG
|SHIFTWREG|PLANTICONST|PLANTBCONST|PLANTHCONST|PLANTDCONST|DIVD|DIVW|UDIVW|UDIVD|SETW|SETD|MOD2|MOD4|MOD8|DIVD8
|DIVW8|MOD16|MODint32|ADDUSB|ADDSSB|SUBUSB|SUBSSB|MULUSB|MULSSB|LOADLITI|LOADLITD|LOADLITS|IFGOTO|IFGTGOTO|IFLTGOTO
|IFGEGOTO|IFLEGOTO|IFWBOOL|IFDBOOL|INCSP|DECSP|LDX|NOTOP|PLANTLABEL|FLN|INTABS|WMOVZXB|WMOVZXHW|LOADFS|LOADFD
|STOREFS|STOREFD|FIFGOTO|FIFEQUALCONSTGOTO|IFEQUALGOTO|LOADLITSF|LOADLITDF|SOPERATION|DOPERATION|FSET|CONVFToINTD|CONVFToINTW|EXTENDSToD|FSINSCONS|FSINS
|FSIND|FCOSS|FCOSD|FTANS|FTAND|SQRTS|SQRTD|FABS|FMIN|FMAX|FNEG|PLANTDCONST|PLANTSCONST|EXTENDSTD|MOVEREGTREG
|CONVSPtoW|CONVSPtoD|CONVDPtoD|CONVDPtoW|CONVINTtoSP|CONVINTtoDP|PUSHWREG|POPWREG|PUSHDREG|POPDREG|PUSHSFREG|PUSHDFREG|POPSFREG|POPDFREG|PUSHHREG
|POPHREG|PUSHBREG|POPBREG]
