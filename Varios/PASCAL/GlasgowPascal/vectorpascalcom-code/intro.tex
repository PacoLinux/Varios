\chapter*{Introduction}

Vector Pascal is a dialect of Pascal designed to make efficient use of the multi-media
instructionsets of recent procesors. It supports data parallel operations and
saturated arithmetic. This manual describes the Vector Pascal language.

A number of widely used contemporary processors have instructionset extensions
for improved performance in multi-media applications. The aim is to allow operations
to proceed on multiple pixels each clock cycle. Such instructionsets have been
incorporated both in specialist DSP chips like the Texas C62xx\cite{Texas}
and in general purpose CPU chips like the Intel IA32\cite{Intel00} or the AMD
K6 \cite{AMD}.

These instructionset extensions are typically based on the Single Instruction-stream
Multiple Data-stream (SIMD\index{SIMD}) model in which a single instruction
causes the same mathematical operation to be carried out on several operands,
or pairs of operands at the same time. The level or parallelism supported ranges
from 2 floating point operations at a time on the AMD\index{AMD} K\index{K6}6
architecture to 16 byte operations at a time on the intel P4 architecture. Whilst
processor architectures are moving towards greater levels of parallelism, the
most widely used programming languages like C\index{C}, Java\index{Java} and
Delphi\index{Delphi} are structured around a model of computation in which
operations take place on a single value at a time. This was appropriate when
processors worked this way, but has become an impediment to programmers seeking
to make use of the performance offered by multi-media instructionsets. The introduction
of SIMD instruction sets\cite{IA32}\cite{Peleg97} to Personal Computers potentially
provides substantial performance increases, but the ability of most programmers
to harness this performance is held back by two factors. The first is the limited
availability of compilers that make effective use of these instructionsets in
a machine independent manner. This remains the case despite the research efforts
to develop compilers for multi-media instructionsets\cite{Cheong97}\cite{Leupers99}\cite{Krall00}\cite{Sreraman00}.
The second is the fact that most popular programming languages were designed
on the word at a time model of the classic von Neumann computer. 

Vector Pascal aims to provide an efficient and concise notation for programmers
using Multi-Media enhanced CPUs. In doing so it borrows concepts for expressing
data parallelism that have a long history, dating back to Iverson's work on
APL\index{APL} in the early '60s\cite{Iverson62}. 

Define a vector of type \emph{T} as having type \( T[] \). Then if we have
a binary operator \( \omega :(T\otimes T)\rightarrow T \), in languages derived
from APL we automatically have an operator \( \omega :(T[]\otimes T[])\rightarrow T[] \)
\(  \). Thus if \( x,y \) are arrays of integers \( k=x+y \) is the array
of integers where \( k_{i}=x_{i}+y_{i} \).

The basic concept is simple, there are complications to do with the semantics
of operations between arrays of different lengths and different dimensions,
but Iverson provides a consistent treatment of these. The most recent languages
to be built round this model are J\index{J}, an interpretive language\cite{Jmanual}\cite{Burke}\cite{Jintro},
and F\cite{Metcalf96} a modernised Fortran\index{Fortran}. In principle though
any language with array types can be extended in a similar way. Iverson's approach
to data parallelism is machine independent. It can be implemented using scalar
instructions or using the SIMD model. The only difference is speed. 

Vector Pascal incorporates Iverson's approach to data parallelism. Its aim is
to provide a notation that allows the natural and elegant expression of data
parallel algorithms within a base language that is already familiar to a considerable
body of programmers and combine this with modern compilation techniques. 

By an elegant algorithm I mean one which is expressed as concisely as possible.
Elegance is a goal that one approaches asymptotically, approaching but never
attaining\cite{Chaitin}. APL and J allow the construction of very elegant programs,
but at a cost. An inevitable consequence of elegance is the loss of redundancy.
APL programs are as concise, or even more concise than conventional mathematical
notation\cite{Iverson80} and use a special character-set. This makes them hard
for the uninitiated to understand. J attempts to remedy this by restricting
itself to the ASCII character-set, but still looks dauntingly unfamiliar to
programmers brought up on more conventional languages. Both APL and J are interpretive
which makes them ill suited to many of the applications for which SIMD speed
is required. The aim of Vector Pascal is to provide the conceptual gains of
Iverson's notation within a framework familiar to imperative programmers.

Pascal\index{Pascal}\cite{Jensen}was chosen as a base language over the alternatives
of C and Java. C was rejected because notations like \texttt{x+y} for \texttt{x}
and \texttt{y} declared as \texttt{int x{[}4{]}}, {\tt y{[}4{]}}, already have the
meaning of adding the addresses of the arrays together. Java was rejected because
of the difficulty of efficiently transmitting data parallel operations via its
intermediate code to a just in time code generator. 

Iverson's approach to data parallelism is machine independent. It can be implemented
using scalar instructions or using the SIMD\index{SIMD} model. The only difference
is speed. Vector Pascal incorporates Iverson's approach to data parallelism.



