#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass article
\begin_preamble
\usepackage{graphicx, epsfig}
\reversemarginpar
\title{indexfiles.pas}
\end_preamble
\options  
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 10
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section

indexfiles
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{program}  
\backslash 
textit{indexfiles} ;}}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{uses}  
\backslash 
textit{bloomfilter} ;}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{const} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{dirsep} =
\backslash 
textrm{
\backslash 
textup { `
\backslash 
( 
\backslash 
backslash 
\backslash 
)' } };}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{wordmax} =25;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{above} =
\backslash 
textrm{
\backslash 
textup { `..' } };}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{this} =
\backslash 
textrm{
\backslash 
textup { `.' } };}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{type} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{lexeme} =
\backslash 
textbf{string} ;}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{var} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{index} 
\backslash 
(
\backslash 
in
\backslash 
) file of filefilter;}}
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{loadset} 
\backslash 
textit{(} 
\backslash 
textbf{var}  
\backslash 
textit{f} :
\backslash 
textit{text} ;
\backslash 
textbf{var}  
\backslash 
textit{words} :
\backslash 
textit{bloom} );} (see Section 
\backslash 
ref{sec:indexfilesloadset} )
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{processfile} 
\backslash 
textit{(} 
\backslash 
textit{fn} ,
\backslash 
textit{path} :
\backslash 
textbf{string} );} (see Section 
\backslash 
ref{sec:indexfilesprocessfile} )
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{intodir} 
\backslash 
textit{(} 
\backslash 
textit{s} :
\backslash 
textbf{string} ; 
\backslash 
textit{prefix} :
\backslash 
textbf{string} );} (see Section 
\backslash 
ref{sec:indexfilesintodir} )
\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
<
\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{assign} (
\backslash 
textit{index}, 
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `wordindex.ind' } }})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{rewrite} (
\backslash 
textit{index})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{intodir} (
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `.' } }}, 
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `.' } }})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{close} (
\backslash 
textit{index})}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} .}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 


\layout Section

loadset
\layout Standard


\begin_inset LatexCommand \label{sec:indexfilesloadset}

\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{loadset} 
\backslash 
textit{(} 
\backslash 
textbf{var}  
\backslash 
textit{f} :
\backslash 
textit{text} ;
\backslash 
textbf{var}  
\backslash 
textit{words} :
\backslash 
textit{bloom} );}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 

 This procedure finds all the unique words in a file and returns them in
 lexset.
 This module is responsible for all of the parsing of the input files.
 It declares the set 
\family sans 
letters
\family default 
 used in discriminating words from other text.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{const} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{a} =
\backslash 
textrm{
\backslash 
textup { `a' } };}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{z} =
\backslash 
textrm{
\backslash 
textup { `z' } };}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{var} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{letters} 
\backslash 
(
\backslash 
in
\backslash 
) set of char ;}}
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{type} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{state}  = 
\backslash 
textit{(} 
\backslash 
textit{inword} , 
\backslash 
textit{skipping} );}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{var} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{c} 
\backslash 
(
\backslash 
in
\backslash 
)  char;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{s} 
\backslash 
(
\backslash 
in
\backslash 
)  state;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{theword} 
\backslash 
(
\backslash 
in
\backslash 
) lexeme;}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
textsf{
\backslash 
textbf{function}  
\backslash 
textit{getch} :
\backslash 
textit{char} ;} (see Section 
\backslash 
ref{sec:indexfiles/loadsetgetch} )
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{getlex} 
\backslash 
textit{(} 
\backslash 
textbf{var}  
\backslash 
textit{l} :
\backslash 
textit{lexeme} );} (see Section 
\backslash 
ref{sec:indexfiles/loadsetgetlex} )
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
<
\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{s}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{skipping}}; }
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{letters}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{}[
\backslash 
textrm{
\backslash 
textup { `a' } }..
\backslash 
textrm{
\backslash 
textup { `z' } }, 
\backslash 
textrm{
\backslash 
textup { `A' } }..
\backslash 
textrm{
\backslash 
textup { `Z' } }]}; }
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{repeat} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{getlex} (
\backslash 
textit{theword})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{setfilter} (
\backslash 
textit{theword}, 
\backslash 
textit{words})}; }
\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {until } 
\backslash 
textsf{
\backslash 
textit{theword} 
\backslash 
(=
\backslash 
) 
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `' } }}}; }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{3.5cm}{
\backslash 
scriptsize{of loadset}}
\backslash 
'{
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end}  ;}}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 


\layout Section

processfile
\layout Standard


\begin_inset LatexCommand \label{sec:indexfilesprocessfile}

\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{processfile} 
\backslash 
textit{(} 
\backslash 
textit{fn} ,
\backslash 
textit{path} :
\backslash 
textbf{string} );}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 

 this builds an index for file fn and adds it to the index 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{var} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{ff} 
\backslash 
(
\backslash 
in
\backslash 
) filefilter;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{f} 
\backslash 
(
\backslash 
in
\backslash 
) text;}}
\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
<
\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{writeln}(
\backslash 
textit{path})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{assign} (
\backslash 
textit{f}, 
\backslash 
textit{fn})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
texttt{
\backslash 
small{
\backslash 
{
\backslash 
$i-
\backslash 
}}}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{reset} (
\backslash 
textit{f})}; }
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{ioresult} 
\backslash 
(=
\backslash 
) 0} 
\backslash 
textbf{ then } }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
texttt{
\backslash 
small{
\backslash 
{
\backslash 
$i+
\backslash 
}}}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{ff.wordset}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{}}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{loadset} (
\backslash 
textit{f}, 
\backslash 
textit{ff.wordset})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{ff.filename}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{path}}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{write}(
\backslash 
textit{index}, 
\backslash 
textit{ff})}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {else } 
\backslash 
textsf{
\backslash 
textbf{writeln}(
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `cant open ' } }}, 
\backslash 
textit{fn}, 
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `:' } }}, 
\backslash 
textit{path})}; }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{close} (
\backslash 
textit{f})}; }
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 


\layout Section

intodir
\layout Standard


\begin_inset LatexCommand \label{sec:indexfilesintodir}

\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{intodir} 
\backslash 
textit{(} 
\backslash 
textit{s} :
\backslash 
textbf{string} ; 
\backslash 
textit{prefix} :
\backslash 
textbf{string} );}}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{var} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{buf: 
\backslash 
textbf{ array } 
\backslash 
textsf{[0..100] } 
\backslash 
textbf{ of } 
\backslash 
textsf{ 
\backslash 
textit{ascii} ;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{n} 
\backslash 
(
\backslash 
in
\backslash 
) pchar;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{un}, 
\backslash 
textit{path} 
\backslash 
(
\backslash 
in
\backslash 
) string;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{thedir} 
\backslash 
(
\backslash 
in
\backslash 
) pdir;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{theentry} 
\backslash 
(
\backslash 
in
\backslash 
) pdirentry;}}
\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
<
\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{unicodestring2ascii} (
\backslash 
textit{s}, 
\backslash 
textit{buf}
\backslash 
(_{0}
\backslash 
))}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{thedir} :=
\backslash 
textit{opendir} 
\backslash 
textit{(} @
\backslash 
textit{buf} );}}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{thedir} 
\backslash 
(
\backslash 
neq
\backslash 
) 
\backslash 
textit{nil}} 
\backslash 
textbf{ then } 
\backslash 
textsf{
\backslash 
textit{begin}} 
\backslash 
textbf{ begin } }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{chdir} 
\backslash 
textit{(} @
\backslash 
textit{buf} );}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{theentry}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{readdir} (
\backslash 
textit{thedir})}; }
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {while } 
\backslash 
textsf{(
\backslash 
textit{theentry} 
\backslash 
(
\backslash 
neq
\backslash 
) 
\backslash 
textit{nil})} 
\backslash 
textbf{ do } }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{n}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{entryname} (
\backslash 
textit{theentry})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{un}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{strpas} (
\backslash 
textit{n})}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{path}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{prefix} + 
\backslash 
textit{dirsep} + 
\backslash 
textit{un}}; }
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{isdir} (
\backslash 
textit{n})} 
\backslash 
textbf{ then } 
\backslash 
textsf{
\backslash 
textit{begin}} 
\backslash 
textbf{ begin } }}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{un} 
\backslash 
(
\backslash 
neq
\backslash 
) 
\backslash 
textit{above}} 
\backslash 
textbf{ then } }}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{un} 
\backslash 
(
\backslash 
neq
\backslash 
) 
\backslash 
textit{this}} 
\backslash 
textbf{ then } }}
\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{intodir} (
\backslash 
textit{un}, 
\backslash 
textit{path})}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end}  
\backslash 
textbf{else}  
\backslash 
textit{processfile}  
\backslash 
textit{(} 
\backslash 
textit{un} ,
\backslash 
textit{path} );}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{theentry}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{readdir} (
\backslash 
textit{thedir})}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{unicodestring2ascii} (
\backslash 
textit{above}, 
\backslash 
textit{buf}
\backslash 
(_{0}
\backslash 
))}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{s} 
\backslash 
(
\backslash 
neq
\backslash 
) 
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `.' } }}} 
\backslash 
textbf{ then } 
\backslash 
textsf{
\backslash 
textit{chdir} 
\backslash 
textit{(} @
\backslash 
textit{buf} );}}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 


\layout Section

getch
\layout Standard


\begin_inset LatexCommand \label{sec:indexfiles/loadsetgetch}

\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{function}  
\backslash 
textit{getch} :
\backslash 
textit{char} ;}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 

 Read in a character from the current file, return the null character on
 end of file.
 This function has to deal with the problems of 
\layout Enumerate

End of lines, which in Pascal are detected by the 
\family sans 
eoln
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
 {}
\end_inset 


\family default 
 function.
 These are dealt with by returning the ASCII CR character 13.
 
\layout Enumerate

End of file, detected by the 
\family sans 
eof
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
 {}
\end_inset 


\family default 
 function.
 This is dealt with by returning the ASCII NUL character 0.
 The occurence of NUL characters is dealt with at the next higher level
 of processing to ensure that termination occurs.
 
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{var} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{Let 
\backslash 
textit{local} 
\backslash 
(
\backslash 
in
\backslash 
) char;}}
\backslash 

\backslash 

\newline 

\backslash 
-
\backslash 
<
\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{eoln} (
\backslash 
textit{f})} 
\backslash 
textbf{ then } }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{readln} 
\backslash 
textit{(} 
\backslash 
textit{f} );}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{getch}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textbf{chr}(13)}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} }}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{else} }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{eof} (
\backslash 
textit{f})} 
\backslash 
textbf{ then } }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{getch}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textbf{chr}(0)}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} }}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{else} }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{read} 
\backslash 
textit{(} 
\backslash 
textit{f} ,
\backslash 
textit{local} );}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{getch}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{local}}; }
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{3.5cm}{
\backslash 
scriptsize{of getch}}
\backslash 
'{
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end}  ;}}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 


\layout Section

getlex
\layout Standard


\begin_inset LatexCommand \label{sec:indexfiles/loadsetgetlex}

\end_inset 


\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{procedure}  
\backslash 
textit{getlex} 
\backslash 
textit{(} 
\backslash 
textbf{var}  
\backslash 
textit{l} :
\backslash 
textit{lexeme} );}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 

 This procedure parses the input stream for the next word.
 It then returns it in l.
 It operates as a simple finite state machine that can be in one of two
 states: 
\layout Enumerate


\family sans 
skipping
\family default 
 : the machine is in this state between words whilst it moves over non letter
 characters.
 
\layout Enumerate


\family sans 
inword
\family default 
 : the machine is in this state whilst it parses a word.
 
\layout Standard

The special case of the occurence of the null character causes a branch
 to label 99 ensuring that a null string is returned by the procedure.
 This is used at the next higher level as a termination condition.
 Labels, though deprecated in structured programming remain a useful construct
 for escaping from loops.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 

 Note that membership of the character in the set of letters is used to
 switch between the two states of the parser.
 This is an entirely orthodox use of sets in Pascal.
 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{tabbing}
\newline 
***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
=***
\backslash 
={
\backslash 
kill
\newline 
}
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{label}  99;}}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{l}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{
\backslash 
textrm{
\backslash 
textup { `' } }}}; }
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {while } 
\backslash 
textsf{
\backslash 
textit{s} 
\backslash 
(=
\backslash 
) 
\backslash 
textit{skipping}} 
\backslash 
textbf{ do } }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{c}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{getch}}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{c}} 
\backslash 
textbf{ in } 
\backslash 
textsf{
\backslash 
textit{letters}} 
\backslash 
textbf{ then } 
\backslash 
textsf{
\backslash 
textit{s}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{inword}}; }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{c} 
\backslash 
(=
\backslash 
) 
\backslash 
textbf{chr}(0)} 
\backslash 
textbf{ then }  
\backslash 
textbf{ goto } 
\backslash 
textsf{99}; }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
+
\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {while } 
\backslash 
textsf{
\backslash 
textit{s} 
\backslash 
(=
\backslash 
) 
\backslash 
textit{inword}} 
\backslash 
textbf{ do } }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{begin} }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{length} (
\backslash 
textit{l}) 
\backslash 
(=
\backslash 
) 
\backslash 
textit{wordmax}}}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {then }  
\backslash 
textbf{ goto } 
\backslash 
textsf{99}; }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{l}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{l} + 
\backslash 
textit{c}}; }
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textit{c}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{getch}}; }
\backslash 

\backslash 

\newline 

\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{c}} 
\backslash 
textbf{ in } 
\backslash 
textsf{
\backslash 
textit{letters}} 
\backslash 
textbf{ then } 
\backslash 
textsf{
\backslash 
textit{s}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{inword}} 
\backslash 
textbf{ else } 
\backslash 
textsf{
\backslash 
textit{s}
\backslash 
(
\backslash 
leftarrow
\backslash 
) 
\backslash 
textit{skipping}}; }}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf {
\backslash 
textbf {if } 
\backslash 
textsf{
\backslash 
textit{c} 
\backslash 
(=
\backslash 
) 
\backslash 
textbf{chr}(0)} 
\backslash 
textbf{ then }  
\backslash 
textbf{ goto } 
\backslash 
textsf{99}; }}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end} ;}}
\backslash 

\backslash 

\newline 

\backslash 
parbox{14cm}{
\backslash 
textsf{99:}}
\backslash 

\backslash 

\newline 

\backslash 
<
\backslash 
-
\backslash 
parbox{3.5cm}{
\backslash 
scriptsize{of getlex}}
\backslash 
'{
\backslash 
parbox{14cm}{
\backslash 
textsf{
\backslash 
textbf{end}  ;}}}
\backslash 

\backslash 

\newline 

\backslash 
end{tabbing}
\end_inset 


\layout Section

bloomfilter
\layout Standard


\begin_inset Include \input{bloomfilter.lyx}

\end_inset 


\the_end
