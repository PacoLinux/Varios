 /*
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *      
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *      
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *      MA 02110-1301, USA.
 */

 
package ilcg2;
import ilcg2.node.*;
import ilcg2.lexer.*;
import ilcg2.parser.*;
import ilcg2.analysis.*;
import ilcg.tree.StreamGobbler;
import java.io.*;
import java.util.*; 

public class Ilcg2 
{
	 Hashtable<String,String> patternName2FullName = new Hashtable<String,String>();
	 HashSet<String> patternNames = new HashSet<String>();
	 HashSet<String> duplicates = new HashSet<String>();
	 String processorid,parserid,classid,srcname;
	 PrintWriter printer;
	 int errors =0;
	 Node ast;
	 boolean translatorfound=false;
	 String preface="/* compiler generated by Ilcg */ \n"+
	                "import java.util.*;\nimport java.io.*;\nimport ilcg.tree.*;\n";
	 Ilcg2 (Node tree,String n){ast=tree;srcname=n;}
	 void findalts() { TranslationAltfinder taf = new TranslationAltfinder();ast.apply(taf);} 
	 String toaltname(String a,String b){return"A"+fcap(a)+fcap(b);}
	 String fcap(String a){return uc(hd(a))+lc(tl(a));}
	 String hd(String a){return a.substring(0,1);}
	 String tl(String a){return a.substring(1);}
	 String lc(String a){return a.toLowerCase() ;}
	 String uc(String a){return a.toUpperCase() ;}
	 
	 void printalts(){
		 for(String s:patternName2FullName.keySet()){
			 System.out.println(s+":"+patternName2FullName.get(s));
		 }
	 }
	 void translate()throws Exception{		 
		 ast.apply(new translatorfinder());
		 if(translatorfound){
			  generatetranslator();
			  if(errors>0) throw new translationException ( "Error generating translator");
			 ;makecodegen(processorid);
			 makeparser(parserid);
		}
	 }
	 void generatetranslator()throws Exception{
		// findalts(); 
		// checkdup();
		 fileopen(); 
		 processpatterns();
		 }
	 String impa(String s){return "import "+parserid+"."+s+".*;\n";}
	 void processpatterns(){
		  printer.println("package "+parserid+";\n"
		  +preface
		  +impa("analysis")
		  +impa("lexer")
		  +impa("parser")
		  +impa("node") 
		  +"class "+classid+"  {");
		  ast.apply(new patternprinter());
		  genmain();
		  printer.println("}");
		  printer.close();
	 }
	 void genmain()// generates main method
	 {
	  printer.println(
	   "public static void main(String[] arguments){\n"
       +"if(arguments.length <1){ System.out.println(\"usage:\\njava "+parserid+"."+classid+" sourcefile   \");System.exit(1); }"
       +"\ntry{   FileReader r=    new FileReader(arguments[0]);"
       +"\n     PushbackReader pr =  new PushbackReader(  new BufferedReader( r), 1024)  ;"
	   +"\n     Lexer lexer = new Lexer( pr ); "
       +"\n     Parser parser = new Parser(lexer);"
       +"\n     "+parserid+".node.Node ast = parser.parse();     "    
       +"\n     "+processorid+"CG cpu = new "+processorid+"CG();"   
       +"\n     if(arguments.length>1){ cpu.verbose=true;  }"
       +"\n     ilcg.tree.Node[] trans = Translator.translate(ast,cpu);"  
       
       +"\n     if(cpu.verbose){ System.out.println( trans[0].toString());}"
       +"\n     PrintWriter asm  = new PrintWriter(new FileOutputStream(arguments[0]+\".asm\"));"
       +"\n     cpu.setLogfile(new PrintWriter(new FileOutputStream(arguments[0]+ \".lst\")));" 
       +"\n     try{"
       +"\n       if(!cpu.codeGen(trans[0])) throw new Exception(\"codegen fails on code \");" 
       +"\n       cpu.buf.writeln(cpu.sectionDirective()+\"  .data\");"
       +"\n       if(!cpu.codeGen(trans[1])) throw new Exception(\"codegen fails on data\");" 
       +"\n     } catch(Exception e){ System.out.println(e);}"
       +"\n     cpu.flush(asm);cpu.flushlog(); asm.close();"
       +"\n     cpu.assemble(arguments[0]+\".asm\",arguments[0]+\".o\" );"
       +"\n} catch(Exception e){ System.out.println(e);}"
       +"\n }"
	 );
	 }
	 void fileopen()throws Exception{ // opens output file
	    String s = parserid+"/"+classid+".java";
	    printer = new PrintWriter(new FileOutputStream(s));
	    System.out.println("Generating file "+s);
	 }
	 void checkdup() throws Exception{
			ast.apply(new patternfinder());
			for(String s : duplicates)
			 System.err.println(s);
			if(duplicates.size()>0) throw new translationException("Duplicated pattern names");
			for(String s:patternName2FullName.keySet())
			 if(! patternNames.contains(s))throw new translationException("name "+s+" was used but not defined"); 
	 }
	 void makeparser(String n){
		 String [] ps = {n+".sab"};
		 System.out.println("Processing  file "+ps[0]);
		try{ 
		//	SableCC.main(p); 
		Runtime sys = Runtime.getRuntime();
  
                String com = "java -jar sablecc.jar " +  ps[0];
                 
                System.out.println(com);
                Process p = sys.exec(com);
                StreamGobbler errorGobbler = new
                StreamGobbler(p.getErrorStream(), "ERROR");
                // any output?
                StreamGobbler outputGobbler = new
                StreamGobbler(p.getInputStream(), "OUTPUT");
                // kick them off
                errorGobbler.start();
                outputGobbler.start();
                if(p.waitFor() == 0)
                    {
                        return  ;
                    }
            
			}
		catch(Exception eee){System.out.println(eee);System.exit(-1);}
	 }
	 void makecodegen(String n)throws Exception{
		 String [] p = {"cpus/"+n+".ilc","ilcg/tree/"+n+".java",n};
		 System.out.println("Processing  file "+p[0]+" to make file "+p[1]);
		 ilcg.Ilcg.main(p);
	 }
	 class patternprinter extends DepthFirstAdapter{// this translates
	                                                // individual ilcg
	                                                // patterns to java methods
		public void outATranslationstatement(ATranslationstatement node) 
		{ 
			try
			{
				String s = node.getIdentifier().toString().trim();
				checkparams(node);
				printer.println("public void out"
					+patternName2FullName.get(s)+"("
					+patternName2FullName.get(s)+" node){");
				initlocals();
				outputprecond(node);
				formilcgresult();
				printer.println("}");
			}
			catch(Exception ex){errors++;
			System.err.println(ex.toString());
			}
		}
		void initlocals(){}
		void outputprecond(ATranslationstatement node){
			PPrecond pp = node.getPrecond();
			if(pp instanceof APrecond){
				APrecond ap =(APrecond)pp;
				String com = ap.getCodecomment().toString().trim();
				printer.println(com);
			}
		}
		void formilcgresult(){}
		void checkparams(ATranslationstatement node)throws Exception{
			class paramfinder extends DepthFirstAdapter{
				HashSet<String> prims =new HashSet<String>(); 
				public void inATypeidTypeprim(ATypeidTypeprim node)
                {
                 prims.add(node.toString().trim());
                }
			}
			paramfinder pf = new paramfinder();
			node.getParamlist().apply(pf);
			for(String s :pf.prims){
					if(!patternNames.contains(s))
					throw new translationException(s+" is used as a parameter type but no such pattern exists");
			}
		}
	 }
	 class patternfinder extends DepthFirstAdapter{
		public void inATranslationstatement(ATranslationstatement node){
			String s = node.getIdentifier().toString().trim();cpn(s);
		}
        public void inAAlternativesTranslationstatement(AAlternativesTranslationstatement node){
			String s = node.getIdentifier().toString().trim();cpn(s);
		} 
		void cpn(String s){
		 if(patternNames.contains(s))duplicates.add(s);
		 patternNames.add(s);
	    }
	 }
	 class translatorfinder extends DepthFirstAdapter{
		public void inATranslator(ATranslator node)
		{translatorfound=true;
        processorid= node.getProcessorid().toString().trim();
        classid= node.getClassid().toString().trim();
        parserid= node.getParserid().toString().trim();
		}
	 }
	 class translationException extends Exception{
		 translationException(String s){super(s);}
	 }
	 class TranslationAltfinder extends DepthFirstAdapter{
		
	  public void inAAlternativesTranslationstatement(AAlternativesTranslationstatement node)
      {
		  String id = node.getIdentifier().toString().trim();
          PAlternatives alts= node. getAlternatives();
          class altfinder extends DepthFirstAdapter{
			  String id;
			altfinder(String s){id=s;}
			public void inAAlternatives(AAlternatives node)
			{
					String tn = node.getType().toString().trim();
					patternName2FullName.put(tn,toaltname(tn,id));
			}
			public void inAAlts(AAlts node)
			{
				 String tn = node.getType().toString().trim();
				 patternName2FullName.put(tn,toaltname(tn,id));
			}
		  }
		  altfinder af = new altfinder(id);
		  alts.apply(af);
      }
    }
    public static void main(String[] arguments)
    {
        if(arguments.length <1){ System.out.println("usage:\njava ilcg.Main sourcefile   ");System.exit(1); }
       try
        {   FileReader r=    new FileReader(arguments[0]);
            PushbackReader pr =  new PushbackReader(  new BufferedReader( r), 1024)  ;
	        Lexer lexer = new Lexer( pr ); 
            Parser parser = new Parser(lexer);
            Node ast = parser.parse();             
            Ilcg2 trans = new Ilcg2(ast,arguments[0]);
            trans.translate(); 
        }
       catch(Exception e){ System.out.println(e);System.out.println("exit");}
    }
}

