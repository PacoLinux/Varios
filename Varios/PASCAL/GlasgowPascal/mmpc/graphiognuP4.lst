 unoptimisedcodegen seq(
  null,
  seq(
   assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))),
   ))		 	0
 cgstatement optlevel=0:seq(
  assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))),
  )
 has local=false		 	0
   sub exp optimise assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	0
  unoptimisedcodegen assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	0
  in still free want length 64 for ref uint8 vector ( 8 )		 	0
  in still free want length 32 for ref int32		 	0
  in split src weight=1 dest weight=2 sf = 5intlimit=11 scharlen=50 charlimit=2000		 	0
  splitsrc=false splitwhole=false		 	0
    match in unoptimised codegen assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	0
  M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 ):=^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[LABref uint8 vector ( 8 )h-3204915108055699955true-> null 		 	1
  Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LOAD> Match ( ref t ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOAD> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOAD> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOAD> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOAD> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOAD> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOAD> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LOADB> Match ( ref t ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADB> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADB> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADB> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADB> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADB> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADB> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LOADW> Match ( ref t ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADW> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADW> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADW> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADW> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADW> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  LOADW> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXB> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZXB>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZXB> ireg>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXB> ireg> indexreg> failed		 	1
  MOVZXB> ireg>  record failure pattern ireg means [ indexreg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  MOVZXB> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXB> ureg> failed		 	1
  MOVZXB>  record failure pattern reg means [ ireg | ureg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSXB> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXB> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVSXB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXB> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVSXB> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXB> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSXB> ireg> indexreg> failed		 	1
  MOVSXB> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXB> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSXB> ureg> failed		 	1
  Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXW> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXW> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXW> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZXW>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXW> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZXW> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXW> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXW> ireg> indexreg> failed		 	1
  MOVZXW> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXW> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXW> ureg> failed		 	1
  Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSXW> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXW> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXW> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVSXW>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXW> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVSXW> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXW> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSXW> ireg> indexreg> failed		 	1
  MOVSXW> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXW> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSXW> ureg> failed		 	1
  Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXB2> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB2> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB2> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZXB2>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB2> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZXB2> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB2> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXB2> ireg> indexreg> failed		 	1
  MOVZXB2> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXB2> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXB2> ureg> failed		 	1
  Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZBW> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZBW> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVZBW>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZBW> swreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZBW> swreg> failed		 	1
  MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZBW> uwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZBW> uwreg> failed		 	1
  MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZBW> untypedwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZBW> untypedwreg> failed		 	1
  MOVZBW>  record failure pattern wreg means [ swreg | uwreg | untypedwreg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSBW> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSBW> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVSBW>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSBW> swreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSBW> swreg> failed		 	1
  MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSBW> uwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSBW> uwreg> failed		 	1
  MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSBW> untypedwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSBW> untypedwreg> failed		 	1
  Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVZXBW> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVZXBW> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVZXBW> failed		 	1
  Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSXBW> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVSXBW> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVSXBW> failed		 	1
  Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CLEARREG> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CLEARREG> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CLEARREG> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CLEARREG> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  CLEARREG>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CLEARREG> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  CLEARREG> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CLEARREG> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  CLEARREG> ireg> indexreg> failed		 	1
  CLEARREG> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CLEARREG> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  CLEARREG> ureg> failed		 	1
  Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORELIT> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORELIT> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORELIT> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  STORELIT>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  STORELIT> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORELIT> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORELIT> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false-> null 		 	1
  STORELIT> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> bind actualtype int32to param 1=int32		 	1
  STORELIT> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> Match  alternatives format   to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> labelconstf>  try to commute arguments 		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	1
  STORELIT> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=1 dest weight=0 sf = 11intlimit=11 scharlen=42 charlimit=2000		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %eaxref int32:=^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg>  record failure pattern breg means [ bireg | bureg | boreg ] %eaxref int32h-3204915108055699955false0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg>  record failure pattern wreg means [ swreg | uwreg | untypedwreg ] %eaxref int32h-3204915108055699955false0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Record %eaxref int32h-3204915108055699955false->0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Record %eaxref int32h-3204915108055699955false->0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Record %eaxref int32h-3204915108055699955false->2		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match rm  to mem(ref int32,+((int32)^(%ebp),     8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern maddrmode ( addrform f ) means [ mem ( f ) ] assembles [ f ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match mem ( f )  to mem(ref int32,+((int32)^(%ebp),     8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match mem ( f )  to mem(ref int32,+((int32)^(%ebp),     8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match f  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match f  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> +int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode>  failvar= 0+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match ( t ) f  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match ( t ) f  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> bind actualtype int32to param 1=int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match  alternatives format   to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match f  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match f  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> +int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform>  failvar= 0+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> directf> Match const s  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> directf> Match const s  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> udirectf> Match const s  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> udirectf> Match const s  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf>  try to commute arguments 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %ebpref wordh-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0%ebpref wordh-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> %ebpref wordh-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0%ebpref wordh-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record %ebpref wordh-3204915108055699955true->0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record %ebpref wordh-3204915108055699955true->0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L8int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L8int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> L8int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0L8int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding     8 to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef     8 to int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,    8),
  )		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,    8),
  )
 has local=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%eax,    8)		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%eax,    8)		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=0 dest weight=0 sf = 11intlimit=11 scharlen=5 charlimit=2000		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%eax,    8)		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %eaxref int32:=L8int32h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %eaxref int32h-3204915108055699955false-> alternative     2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with uint8 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with int8 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with octet actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with int16 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with uint16 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with halfword actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match CastRhs predeclared or vector cast uint32=int32 to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match CastRhs predeclared or vector cast int32=int32 to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match EXTEND ( ( int8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match CastRhs predeclared or vector cast uint32=int32 to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match CastRhs predeclared or vector cast int32=int32 to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match EXTEND ( ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match CastRhs predeclared or vector cast int32=int32 to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match EXTEND ( ( uint8 ) ^ ( rm ) )  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> %eaxref int32h-3204915108055699955false-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> %eaxref int32h-3204915108055699955false-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> bind actualtype int32to param 1=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%eax,    8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> %eaxref int32h-3204915108055699955false-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> maddrmode> Match mem ( f )  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> maddrmode> Match mem ( f )  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> %eaxref int32h-3204915108055699955false-> alternative     2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Record %eaxref int32h-3204915108055699955false->1		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> bind actualtype int32to param 1=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match  alternatives format   to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match check type equality with int8 actually is int32 true to     8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %eaxref int32:=L8int32h-3204915108055699955true->20		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%eax,    8)	-> movl  $    8, %eax ok		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record L8int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record L8int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to (int32)^(%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +((int32)^(%ebp),     8)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to (int32)^(%ebp)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match r  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> %ebpref wordh-3204915108055699955true-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf>  failvar= 0%ebpref wordh-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> %ebpref wordh-3204915108055699955true-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0%ebpref wordh-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebp		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match s  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match s  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> L8int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf>  failvar= 0L8int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match  alternatives format   to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match check type equality with int8 actually is int32 true to     8		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Record L8int32h-3204915108055699955true->0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Record +int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)h-3204915108055699955true->6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Record +int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)h-3204915108055699955true->0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %eaxref int32:=^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true->7		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))	-> movl         8(%ebp),%eax ok		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true->0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true->0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  record failure pattern offset means [ constf | barelab | labelconstf ] ^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L6int32h2149911365540569994true-> null 		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L6int32h2149911365540569994true0 switchvar 0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record L6int32h2149911365540569994true->0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=1 dest weight=0 sf = 11intlimit=11 scharlen=57 charlimit=2000		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %eaxref int32:=+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %eaxref int32h-3204915108055699955false-> alternative     2		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with uint8 actually is int32 false to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with int8 actually is int32 false to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with octet actually is int32 false to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with int16 actually is int32 false to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with uint16 actually is int32 false to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with halfword actually is int32 false to ^(%eax)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match CastRhs predeclared or vector cast uint32=int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match CastRhs predeclared or vector cast int32=int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match EXTEND ( ( int8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match CastRhs predeclared or vector cast uint32=int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match CastRhs predeclared or vector cast int32=int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match EXTEND ( ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match CastRhs predeclared or vector cast int32=int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match EXTEND ( ( uint8 ) ^ ( rm ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> %eaxref int32h-3204915108055699955false-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> try binding %eax to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> failed		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match rm  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> bind actualtype int32to param 1=int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match rm  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> %eaxref int32h-3204915108055699955false-> alternative     1		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 1		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> %eaxref int32h-3204915108055699955false-> alternative     2		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> bind actualtype int32to param 1=int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LEA ( reg r1 , leaform ea ) means [ r1 := ea ] assembles [ 'lea ' ea ',' r1 ]  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Match r1 := ea  to assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Match r1  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Match pattern reg means [ ireg | ureg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> ireg> indexreg> already a reg		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Match ea  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Match ea  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Match pattern leaform means [ scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf | barelab ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf>  try to commute arguments 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match r1  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf>  failvar= 0M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=1 dest weight=0 sf = 11intlimit=11 scharlen=47 charlimit=2000		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %eaxref int32:=^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %eaxref int32h-3204915108055699955false-> alternative     2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match rm  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern maddrmode ( addrform f ) means [ mem ( f ) ] assembles [ f ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match mem ( f )  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match mem ( f )  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match f  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match f  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match ( t ) f  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match ( t ) f  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> bind actualtype int32to param 1=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match  alternatives format   to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match f  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match f  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> directf> Match const s  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> directf> Match const s  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> udirectf> Match const s  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> udirectf> Match const s  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf>  try to commute arguments 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match l  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> (ref int32)%ebpref wordh-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0(ref int32)%ebpref wordh-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> (ref int32)%ebpref wordh-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0(ref int32)%ebpref wordh-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record (ref int32)%ebpref wordh-3204915108055699955true->0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record (ref int32)%ebpref wordh-3204915108055699955true->0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L-8int32h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L-8int32h-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> L-8int32h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0L-8int32h-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding     -8 to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef     -8 to int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,    -8),
  )		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,    -8),
  )
 has local=false		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%eax,    -8)		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%eax,    -8)		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=0 dest weight=0 sf = 11intlimit=11 scharlen=6 charlimit=2000		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%eax,    -8)		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %eaxref int32:=L-8int32h-3204915108055699955true-> null 		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %eaxref int32h-3204915108055699955false-> alternative     2		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with uint8 actually is int32 false to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with int8 actually is int32 false to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with octet actually is int32 false to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with int16 actually is int32 false to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with uint16 actually is int32 false to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with halfword actually is int32 false to ^(%eax)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match CastRhs predeclared or vector cast uint32=int32 to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match CastRhs predeclared or vector cast int32=int32 to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match EXTEND ( ( int8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match CastRhs predeclared or vector cast uint32=int32 to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match CastRhs predeclared or vector cast int32=int32 to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match EXTEND ( ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match CastRhs predeclared or vector cast int32=int32 to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> %eaxref int32h-3204915108055699955false-> null 		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> %eaxref int32h-3204915108055699955false-> null 		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> try binding %eax to a register		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> failed		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match rm  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> bind actualtype int32to param 1=int32		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%eax,    -8)		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match rm  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> %eaxref int32h-3204915108055699955false-> alternative     1		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 1		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> %eaxref int32h-3204915108055699955false-> alternative     2		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> already a reg		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> bind actualtype int32to param 1=int32		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match  alternatives format   to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match check type equality with int8 actually is int32 true to     -8		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %eaxref int32:=L-8int32h-3204915108055699955true->20		 	7
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%eax,    -8)	-> movl  $    -8, %eax ok		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 	6
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record L-8int32h2149911365540569994true->0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record L-8int32h2149911365540569994true->0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^((ref int32)%ebp)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^((ref int32)%ebp),     -8)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^((ref int32)%ebp)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match r  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> (ref int32)%ebpref wordh-3204915108055699955true-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf>  failvar= 0(ref int32)%ebpref wordh-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> (ref int32)%ebpref wordh-3204915108055699955true-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0(ref int32)%ebpref wordh-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to (ref int32)%ebp		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match s  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match s  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> L-8int32h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf>  failvar= 0L-8int32h-3204915108055699955true0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match  alternatives format   to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match check type equality with int8 actually is int32 true to     -8		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> baseplusoffsetf> Record L-8int32h-3204915108055699955true->0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> eaform> Record +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h-3204915108055699955true->6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> maddrmode> Record +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h-3204915108055699955true->0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %eaxref int32:=^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true->7		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))	-> movl         -8(%ebp),%eax ok		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> Record M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Record M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match r1  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> L6int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf>  failvar= 0L6int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> L6int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0L6int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding     6 to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef     6 to int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,    6),
  )		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,    6),
  )
 has local=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%eax,    6)		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%eax,    6)		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=0 dest weight=0 sf = 11intlimit=11 scharlen=5 charlimit=2000		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%eax,    6)		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %eaxref int32:=L6int32h-3204915108055699955true-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %eaxref int32h-3204915108055699955false-> alternative     2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with uint8 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with int8 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with octet actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with int16 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with uint16 actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with halfword actually is int32 false to ^(%eax)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match CastRhs predeclared or vector cast uint32=int32 to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match CastRhs predeclared or vector cast int32=int32 to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match EXTEND ( ( int8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match CastRhs predeclared or vector cast uint32=int32 to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match CastRhs predeclared or vector cast int32=int32 to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match EXTEND ( ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match CastRhs predeclared or vector cast int32=int32 to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match EXTEND ( ( uint8 ) ^ ( rm ) )  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> %eaxref int32h-3204915108055699955false-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> %eaxref int32h-3204915108055699955false-> null 		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW>  failvar= 1%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> try binding %eax to a register		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> failed		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> bind actualtype int32to param 1=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%eax,    6)		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match rm  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> %eaxref int32h-3204915108055699955false-> alternative     1		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 1		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> %eaxref int32h-3204915108055699955false-> alternative     2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 2		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> %eaxref int32h-3204915108055699955false-> alternative     0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg>  failvar= 0%eaxref int32h-3204915108055699955false0 switchvar 0		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %eax		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> already a reg		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> bind actualtype int32to param 1=int32		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match  alternatives format   to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match check type equality with int8 actually is int32 true to     6		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %eaxref int32:=L6int32h-3204915108055699955true->20		 	5
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%eax,    6)	-> movl  $    6, %eax ok		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> ireg> Record L6int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Record L6int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to     6		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match r  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf>  failvar= 0M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true-> null 		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg>  failvar= 0M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h-3204915108055699955true0 switchvar 0		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> value type ref int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> register type ref int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> load into %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg>  is word == word		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> assign check returns true		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 	4
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match s  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match s  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> L6int32h2149911365540569994true-> alternative     0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf>  failvar= 0L6int32h2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> constf> Match const s  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> constf> Match const s  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> constf> Match  alternatives format   to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> baseplusoffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Record +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true->3		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> rollBackReservations to 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> %eax:0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LEA> Unreserve %eax		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %eaxref int32:=+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true->21		 	3
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))	-> lea       6(%eax),%eax ok		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 	2
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true->0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true->0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	1
  STORELIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match r  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type ref int32		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true-> null 		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true0 switchvar 0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf>  try to commute arguments 		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  record failure pattern offset means [ constf | barelab | labelconstf ] +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  try to commute arguments 		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match r  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type int32		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  STORELIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> ^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  failvar= 0^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf>  record failure pattern offset means [ constf | barelab | labelconstf ] ^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  STORELIT> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r2 ) , off )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r2  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern nsreg means [ EDI | ESI | EBX | EBP | EAX | EDX | ECX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> value type ref int32		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> register type ref int32		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> load into %edi		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  is word == word		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> assign check returns true		 %eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  unoptimisedcodegen seq(
  assign((ref int32)%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  cgstatement optlevel=0:seq(
  assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>    sub exp optimise assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   unoptimisedcodegen assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   in still free want length 32 for ref int32		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   in split src weight=1 dest weight=0 sf = 10intlimit=10 scharlen=47 charlimit=2000		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   splitsrc=false splitwhole=false		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>     match in unoptimised codegen assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   %ediref int32:=^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFLITGOTO> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   BIFLITGOTO> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFIN> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFGOTO> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFGOTOB> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   IFGOTOW> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   FIFGOTOgeneral> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match ( ref t ) r1  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%edi)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match  alternatives format   to ^(%edi)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match check type equality with int32 actually is int32 true to ^(%edi)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match r1  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> %ediref int32h2149911365540569994false-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD>  failvar= 0%ediref int32h2149911365540569994false0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> %ediref int32h2149911365540569994false-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg>  failvar= 0%ediref int32h2149911365540569994false0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bireg> try binding %edi to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bireg> failed		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bireg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bureg> try binding %edi to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bureg> failed		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> bureg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> boreg> try binding %edi to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> boreg> failed		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> boreg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg>  record failure pattern breg means [ bireg | bureg | boreg ] %ediref int32h2149911365540569994false0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> breg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> %ediref int32h2149911365540569994false-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg>  failvar= 0%ediref int32h2149911365540569994false0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> swreg> try binding %edi to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> swreg> failed		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> swreg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> uwreg> try binding %edi to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> uwreg> failed		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> uwreg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> untypedwreg> try binding %edi to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> untypedwreg> failed		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> untypedwreg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg>  record failure pattern wreg means [ swreg | uwreg | untypedwreg ] %ediref int32h2149911365540569994false0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> wreg> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> %ediref int32h2149911365540569994false-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg>  failvar= 0%ediref int32h2149911365540569994false0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> ireg> %ediref int32h2149911365540569994false-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> ireg>  failvar= 0%ediref int32h2149911365540569994false0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %edi		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> ireg> indexreg> already a reg		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> ireg> Record %ediref int32h2149911365540569994false->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> reg> Record %ediref int32h2149911365540569994false->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Record %ediref int32h2149911365540569994false->2		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match ( t ) ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match ( t ) ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> bind actualtype int32to param 2=int32		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match  alternatives format   to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match check type equality with int32 actually is int32 true to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match ^ ( rm )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match rm  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> Match pattern maddrmode ( addrform f ) means [ mem ( f ) ] assembles [ f ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> Match mem ( f )  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> Match mem ( f )  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> Match f  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> Match f  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h2149911365540569994true-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match ( t ) f  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match ( t ) f  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> bind actualtype int32to param 1=int32		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match  alternatives format   to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match f  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match f  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h2149911365540569994true-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> directf> Match const s  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> directf> Match const s  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> directf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> udirectf> Match const s  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> udirectf> Match const s  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> udirectf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match l  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match l  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> barelab> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf>  try to commute arguments 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match l  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match l  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> barelab> Match l  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> barelab> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> labelconstf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> scaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> (ref int32)%ebpref wordh2149911365540569994true-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0(ref int32)%ebpref wordh2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> (ref int32)%ebpref wordh2149911365540569994true-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0(ref int32)%ebpref wordh2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> already a reg		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record (ref int32)%ebpref wordh2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record (ref int32)%ebpref wordh2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L-8int32h2149911365540569994true-> alternative     0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L-8int32h2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> L-8int32h2149911365540569994true-> alternative     0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0L-8int32h2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding     -8 to a register		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %ebx		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef     -8 to int32		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%ebx,    -8),
  )		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%ebx,    -8),
  )
 has local=false		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>    sub exp optimise assign(%ebx,    -8)		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   unoptimisedcodegen assign(%ebx,    -8)		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in still free want length 32 for ref int32		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   in split src weight=0 dest weight=0 sf = 10intlimit=10 scharlen=6 charlimit=2000		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   splitsrc=false splitwhole=false		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>     match in unoptimised codegen assign(%ebx,    -8)		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   %ebxref int32:=L-8int32h2149911365540569994true-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFLITGOTO> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   BIFLITGOTO> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFIN> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTO> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOB> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   IFGOTOW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   FIFGOTOgeneral> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bireg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> bureg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> boreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg>  record failure pattern breg means [ bireg | bureg | boreg ] %ebxref int32h2149911365540569994false0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> breg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> swreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> uwreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> untypedwreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg>  record failure pattern wreg means [ swreg | uwreg | untypedwreg ] %ebxref int32h2149911365540569994false0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> wreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> ireg> Record %ebxref int32h2149911365540569994false->0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> reg> Record %ebxref int32h2149911365540569994false->0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Record %ebxref int32h2149911365540569994false->2		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match  alternatives format   to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> Match ^ ( rm )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOAD> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match ( ref t ) r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with uint8 actually is int32 false to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with int8 actually is int32 false to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> Match check type equality with octet actually is int32 false to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADB> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match ( ref t ) r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with int16 actually is int32 false to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with uint16 actually is int32 false to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> Match check type equality with halfword actually is int32 false to ^(%ebx)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   LOADW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> Match CastRhs predeclared or vector cast uint32=int32 to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match CastRhs predeclared or vector cast int32=int32 to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> Match EXTEND ( ( int8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXB> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> Match CastRhs predeclared or vector cast uint32=int32 to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match CastRhs predeclared or vector cast int32=int32 to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> Match EXTEND ( ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match CastRhs predeclared or vector cast int32=int32 to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> Match EXTEND ( ( uint8 ) ^ ( rm ) )  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXB2> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW>  failvar= 1%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> swreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> uwreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> untypedwreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZBW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW>  failvar= 1%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> swreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> uwreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> untypedwreg> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSBW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVZXBW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match r1  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> try binding %ebx to a register		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> failed		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   MOVSXBW> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match rm  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> bind actualtype int32to param 1=int32		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> Match 0  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   CLEARREG> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%ebx,    -8)		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( ref t ) rm  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match rm  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> %ebxref int32h2149911365540569994false-> null 		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> maddrmode> Match mem ( f )  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> maddrmode> Match mem ( f )  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> maddrmode> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> %ebxref int32h2149911365540569994false-> alternative     2		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 2		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> %ebxref int32h2149911365540569994false-> alternative     0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg>  failvar= 0%ebxref int32h2149911365540569994false0 switchvar 0		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> already a reg		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Record %ebxref int32h2149911365540569994false->1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match ( t ) const s  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> bind actualtype int32to param 1=int32		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match const s  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match  alternatives format   to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> Match check type equality with int8 actually is int32 true to     -8		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   STORELIT> rollBackReservations to 1		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   Record %ebxref int32:=L-8int32h2149911365540569994true->20		 %eadx	5
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   assign(%ebx,    -8)	-> movl  $    -8, %ebx ok		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rep count =0		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   rollBackReservations to 1		 %eadx	4
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 2,%ebx		 %ebx%eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Record L-8int32h3789333324346973721true->0		 %ebx%eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Record L-8int32h3789333324346973721true->0		 %ebx%eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^((ref int32)%ebp)		 %ebx%eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %ebx%eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %ebx:1		 %ebx%eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %ebx		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^((ref int32)%ebp),     -8)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^((ref int32)%ebp)		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match r  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> (ref int32)%ebpref wordh2149911365540569994true-> alternative     0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf>  failvar= 0(ref int32)%ebpref wordh2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> (ref int32)%ebpref wordh2149911365540569994true-> alternative     0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0(ref int32)%ebpref wordh2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to (ref int32)%ebp		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> already a reg		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match s  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match s  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> L-8int32h2149911365540569994true-> null 		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf>  failvar= 0L-8int32h2149911365540569994true0 switchvar 0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match  alternatives format   to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> constf> Match check type equality with int8 actually is int32 true to     -8		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> baseplusoffsetf> Record L-8int32h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> eaform> Record +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h2149911365540569994true->6		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> maddrmode> Record +int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)h2149911365540569994true->0		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   LOAD> rollBackReservations to 1		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   Record %ediref int32:=^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true->7		 %eadx	3
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))	-> movl         -8(%ebp),%edi ok		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   rep count =0		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   rollBackReservations to 1		 %eadx	2
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> reserve register at depth 2,%edi		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> L6int32h-5738444977846951095true-> null 		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0L6int32h-5738444977846951095true0 switchvar 0		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %edi%eadx	1
  STORELIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Record L6int32h-5738444977846951095true->0		 %edi%eadx	1
  STORELIT> maddrmode> eaform> Record +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-5738444977846951095true->7		 %edi%eadx	1
  STORELIT> maddrmode> Record +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-5738444977846951095false->0		 %edi%eadx	1
  STORELIT> Record M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-5738444977846951095false->0		 %edi%eadx	1
  STORELIT> Match ( t ) const s  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  STORELIT> Match ( t ) const s  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  STORELIT> bind actualtype uint8 vector ( 8 )to param 1=uint8 vector ( 8 )		 %edi%eadx	1
  STORELIT> Match const s  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  STORELIT> Match const s  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  STORELIT> rollBackReservations to 0		 %edi%eadx	1
  STORELIT> %edi:1		 %edi%eadx	1
  STORELIT> Unreserve %edi		 %eadx	1
  STORELIT> rollBackReservations to 0		 %eadx	1
  STORELIT> %eax:0		 %eadx	1
  STORELIT> Unreserve %eax		 	1
  Match pattern LEA ( reg r1 , leaform ea ) means [ r1 := ea ] assembles [ 'lea ' ea ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LEA> Match r1 := ea  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LEA> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LEA> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LEA> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  LEA>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  LEA> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LEA> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  LEA> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  LEA> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LEA> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  LEA> ireg> indexreg> failed		 	1
  LEA> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  LEA> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  LEA> ureg> failed		 	1
  Match pattern INC ( addrmode rm , int t ) means [ ( ref t ) rm := + ( ^ ( rm ) , 1 ) ] assembles [ 'inc' t ' ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INC> Match ( ref t ) rm := + ( ^ ( rm ) , 1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INC> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INC> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  INC> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern RMLIT ( nonmultoperator op , addrmode rm , type t , offset sm ) means [ ( ref t ) rm := op ( ^ ( rm ) , ( t ) sm ) ] assembles [ op t '  $' sm ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMLIT> Match ( ref t ) rm := op ( ^ ( rm ) , ( t ) sm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMLIT> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMLIT> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMLIT> Match pattern addrmode means [ maddrmode | anyreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMLIT> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RMLIT>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RMLIT> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMLIT> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMLIT> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false-> null 		 	1
  RMLIT> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> bind actualtype int32to param 1=int32		 	1
  RMLIT> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> Match  alternatives format   to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> labelconstf>  try to commute arguments 		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	1
  RMLIT> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L6int32h2149911365540569994true-> alternative     0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L6int32h2149911365540569994true0 switchvar 0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	1
  RMLIT> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match r  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type ref int32		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true-> null 		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf>  failvar= 1+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true0 switchvar 0		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf>  try to commute arguments 		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf>  try to commute arguments 		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match r  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type int32		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  RMLIT> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> ^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  RMLIT> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r2 ) , off )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r2  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern nsreg means [ EDI | ESI | EBX | EBP | EAX | EDX | ECX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> value type ref int32		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> register type ref int32		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> load into %edi		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  is word == word		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> assign check returns true		 %eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  unoptimisedcodegen seq(
  assign((ref int32)%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 %eadx	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  cgstatement optlevel=0:seq(
  assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 %eadx	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   exact match found for assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>   rollBackReservations to 1		 %eadx	2
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> reserve register at depth 2,%edi		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> L6int32h-5738444977846951095true-> alternative     0		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0L6int32h-5738444977846951095true0 switchvar 0		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %edi%eadx	1
  RMLIT> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %edi%eadx	1
  RMLIT> Match op ( ^ ( rm ) , ( t ) sm )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  RMLIT> rollBackReservations to 0		 %edi%eadx	1
  RMLIT> %edi:1		 %edi%eadx	1
  RMLIT> Unreserve %edi		 %eadx	1
  RMLIT> rollBackReservations to 0		 %eadx	1
  RMLIT> %eax:0		 %eadx	1
  RMLIT> Unreserve %eax		 	1
  Match pattern RMR ( nonmultoperator op , addrmode rm , anyreg r1 , wordupto32 t ) means [ ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ op t ' ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMR> Match ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMR> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMR> Match pattern wordupto32 means [ byte | word16 | word32 ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RMR>  failvar= 0^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RMR> byte> Match pattern byte means [ uint8 | int8 | octet ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR>  record failure pattern wordupto32 means [ byte | word16 | word32 ] ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  Match pattern DEC ( addrmode rm , int t ) means [ ( ref t ) rm := - ( ( t ) ^ ( rm ) , 1 ) ] assembles [ 'dec' t ' ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  DEC> Match ( ref t ) rm := - ( ( t ) ^ ( rm ) , 1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  DEC> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  DEC> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  DEC> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern IMULLIT ( pushreg r1 , addrmode rm , signed s ) means [ ( ref int32 ) r1 := * ( ^ ( rm ) , const s ) ] assembles [ 'imull $' s ', ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IMULLIT> Match ( ref int32 ) r1 := * ( ^ ( rm ) , const s )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IMULLIT> Match ( ref int32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern BIMUL ( baccreg r1 , bnonacreg r2 ) means [ r2 := * ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) ) ] assembles [ 'imul ' r2 '
 movb %al,' r2 ' ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BIMUL> Match r2 := * ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BIMUL> Match r2  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BIMUL> Match pattern bnonacreg means [ DH | DL | BH | BL | CH | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BIMUL> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  BIMUL> failed		 	1
  Match pattern RLIT ( operator op , pushreg r0 , type t , signed sm ) means [ r0 := ( t ) op ( ^ ( r0 ) , const sm ) ] assembles [ op t '   $' sm ',' r0 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RLIT> Match r0 := ( t ) op ( ^ ( r0 ) , const sm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RLIT> Match r0  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RLIT> Match pattern pushreg means [ reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RLIT> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RLIT>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RLIT> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RLIT> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RLIT> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RLIT> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RLIT> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RLIT> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RLIT> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RLIT> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RLIT> reg> ireg> indexreg> failed		 	1
  RLIT> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RLIT> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RLIT> reg> ureg> failed		 	1
  RLIT>  record failure pattern pushreg means [ reg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  Match pattern RRM ( operator op , pushreg r1 , maddrmode rm , int t ) means [ r1 := ( t ) op ( ( t ) ^ ( r1 ) , ( t ) ^ ( rm ) ) ] assembles [ op t ' ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RRM> Match r1 := ( t ) op ( ( t ) ^ ( r1 ) , ( t ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RRM> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRM> Match pattern pushreg means [ reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRM> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RRM>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RRM> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRM> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RRM> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RRM> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRM> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RRM> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RRM> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRM> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RRM> reg> ireg> indexreg> failed		 	1
  RRM> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRM> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RRM> reg> ureg> failed		 	1
  Match pattern RMRB ( nonmultoperator op , addrmode rm , breg r1 , byte t ) means [ ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ op t ' ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMRB> Match ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMRB> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMRB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRB> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRB> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRB> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRB> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRB> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRB> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern RMR ( nonmultoperator op , addrmode rm , anyreg r1 , wordupto32 t ) means [ ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ op t ' ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMR> Match ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMR> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMR> Match pattern wordupto32 means [ byte | word16 | word32 ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RMR>  failvar= 1^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RMR> byte> Match pattern byte means [ uint8 | int8 | octet ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> byte> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word16> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMR> word32> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern RMRAdd ( addrmode rm , anyreg r1 , wordupto32 t ) means [ ( ref t ) rm := + ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ 'add' t ' ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMRAdd> Match ( ref t ) rm := + ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RMRAdd> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RMRAdd> Match pattern wordupto32 means [ byte | word16 | word32 ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RMRAdd>  failvar= 1^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RMRAdd> byte> Match pattern byte means [ uint8 | int8 | octet ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> byte> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> byte> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> byte> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> byte> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word16> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  RMRAdd> word32> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern RRint32 ( operator op , reg r1 , reg r2 ) means [ r1 := ( int32 ) op ( ( int32 ) ^ ( r1 ) , ( int32 ) ^ ( r2 ) ) ] assembles [ op 'l ' r2 ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RRint32> Match r1 := ( int32 ) op ( ( int32 ) ^ ( r1 ) , ( int32 ) ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RRint32> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRint32> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRint32> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RRint32>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RRint32> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRint32> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RRint32> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RRint32> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRint32> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RRint32> ireg> indexreg> failed		 	1
  RRint32> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RRint32> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RRint32> ureg> failed		 	1
  Match pattern RR ( nonmultoperator op , anyreg r1 , anyreg r2 , int t ) means [ r1 := ( t ) op ( ( t ) ^ ( ( ref t ) r1 ) , ( t ) ^ ( ( ref t ) r2 ) ) ] assembles [ op t ' ' r2 ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RR> Match r1 := ( t ) op ( ( t ) ^ ( ( ref t ) r1 ) , ( t ) ^ ( ( ref t ) r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RR> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> Match pattern anyreg means [ breg | wreg | reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RR>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RR> breg> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> breg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RR> breg>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RR> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> breg> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> breg> bireg> failed		 	1
  RR> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> breg> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> breg> bureg> failed		 	1
  RR> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> breg> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> breg> boreg> failed		 	1
  RR> breg>  record failure pattern breg means [ bireg | bureg | boreg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  RR> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> wreg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RR> wreg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RR> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> wreg> swreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> wreg> swreg> failed		 	1
  RR> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> wreg> uwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> wreg> uwreg> failed		 	1
  RR> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> wreg> untypedwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> wreg> untypedwreg> failed		 	1
  RR> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RR> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RR> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RR> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RR> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> reg> ireg> indexreg> failed		 	1
  RR> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RR> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RR> reg> ureg> failed		 	1
  RR>  record failure pattern anyreg means [ breg | wreg | reg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  Match pattern IDIV ( acc r1 , qacc r2 , indexreg r3 ) means [ r1 := div ( ^ ( r2 ) , ^ ( r3 ) ) ] assembles [ 'idiv ' r3 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IDIV> Match r1 := div ( ^ ( r2 ) , ^ ( r3 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IDIV> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  IDIV> Match pattern acc means [ EAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  IDIV> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  IDIV> failed		 	1
  Match pattern fastBIDIV ( baccreg r1 , bnonacregmode r2 ) means [ r1 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) ) ] assembles [ ' movsbw ' r1 ',%ax
 idiv  ' r2 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  fastBIDIV> Match r1 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  fastBIDIV> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  fastBIDIV> Match pattern baccreg means [ AL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  fastBIDIV> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  fastBIDIV> failed		 	1
  Match pattern BIDIV ( baccreg r1 , bnonacregmode r2 , baccregmode r3 ) means [ r3 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) ) ] assembles [ ' movsbw ' r1 ',%ax
 idiv  ' r2 '
 mov  %al,' r3 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BIDIV> Match r3 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BIDIV> Match r3  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BIDIV> Match pattern baccregmode means [ maddrmode | baccreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BIDIV> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  BIDIV>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  BIDIV> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BIDIV> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BIDIV> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false-> null 		 	1
  BIDIV> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> bind actualtype int32to param 1=int32		 	1
  BIDIV> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> Match  alternatives format   to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> labelconstf>  try to commute arguments 		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	1
  BIDIV> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L6int32h2149911365540569994true-> alternative     0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L6int32h2149911365540569994true0 switchvar 0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	1
  BIDIV> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match r  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type ref int32		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true-> null 		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf>  failvar= 1+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true0 switchvar 0		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf>  try to commute arguments 		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf>  try to commute arguments 		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match r  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type int32		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  BIDIV> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> ^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  BIDIV> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r2 ) , off )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r2  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern nsreg means [ EDI | ESI | EBX | EBP | EAX | EDX | ECX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> value type ref int32		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> register type ref int32		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> load into %edi		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>  is word == word		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> assign check returns true		 %eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>  unoptimisedcodegen seq(
  assign((ref int32)%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 %eadx	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>  cgstatement optlevel=0:seq(
  assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 %eadx	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>   exact match found for assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>   rollBackReservations to 1		 %eadx	2
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> reserve register at depth 2,%edi		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> L6int32h-5738444977846951095true-> alternative     0		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0L6int32h-5738444977846951095true0 switchvar 0		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %edi%eadx	1
  BIDIV> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %edi%eadx	1
  BIDIV> Record M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-5738444977846951095false->0		 %edi%eadx	1
  BIDIV> Match div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  BIDIV> rollBackReservations to 0		 %edi%eadx	1
  BIDIV> %edi:1		 %edi%eadx	1
  BIDIV> Unreserve %edi		 %eadx	1
  BIDIV> rollBackReservations to 0		 %eadx	1
  BIDIV> %eax:0		 %eadx	1
  BIDIV> Unreserve %eax		 	1
  Match pattern UDIV ( acc r1 , modreg r2 ) means [ PUSH ( mainSTACK , div ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) ) ] assembles [ 'pushl %edx
 xor %edx,%edx
 div   ' r2 '
 xchg (%esp),%eax
 xchg %eax,%edx' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  UDIV> Match PUSH ( mainSTACK , div ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IDIVold ( nonaccreg r2 ) means [ PUSH ( mainSTACK , ( int32 ) div ( ( int32 ) POP ( mainSTACK ) , ( int32 ) ^ ( r2 ) ) ) ] assembles [ ' xchg %eax,(%esp)
 pushl %edx
' ' cltd
' ' idiv   ' r2 '
' ' popl %edx
' ' xchg %eax,(%esp)

 ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IDIVold> Match PUSH ( mainSTACK , ( int32 ) div ( ( int32 ) POP ( mainSTACK ) , ( int32 ) ^ ( r2 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IMOD ( acc r1 , modreg r2 ) means [ PUSH ( mainSTACK , MOD ( ( int32 ) ^ ( r1 ) , ^ ( r2 ) ) ) ] assembles [ 'pushl %edx
 cltd
 idiv   ' r2 '
 xchgl %edx,(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IMOD> Match PUSH ( mainSTACK , MOD ( ( int32 ) ^ ( r1 ) , ^ ( r2 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern UMOD ( acc r1 , modreg r2 ) means [ PUSH ( mainSTACK , MOD ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) ) ] assembles [ 'pushl %edx
 xor %edx,%edx
 div   ' r2 '
 xchgl %edx,(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  UMOD> Match PUSH ( mainSTACK , MOD ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern CDQ ( qacc r1 , acc r2 ) means [ r1 := EXTEND ( ^ ( r2 ) ) ] assembles [ 'cdq' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CDQ> Match r1 := EXTEND ( ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CDQ> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CDQ> Match pattern qacc means [ EADX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  CDQ> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  CDQ> failed		 	1
  Match pattern fastIMUL ( acc a , dacc d ) means [ ( ref int32 ) a := * ( ( int32 ) ^ ( a ) , ^ ( d ) ) ] assembles [ 'imul %edx' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  fastIMUL> Match ( ref int32 ) a := * ( ( int32 ) ^ ( a ) , ^ ( d ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  fastIMUL> Match ( ref int32 ) a  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern Negate ( anyreg r1 , type t ) means [ ( ref t ) r1 := - ( ( t ) 0 , ( t ) ^ ( r1 ) ) ] assembles [ 'neg' t ' ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Negate> Match ( ref t ) r1 := - ( ( t ) 0 , ( t ) ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Negate> Match ( ref t ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> Match pattern anyreg means [ breg | wreg | reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  Negate>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  Negate> breg> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> breg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  Negate> breg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  Negate> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> breg> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> breg> bireg> failed		 	1
  Negate> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> breg> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> breg> bureg> failed		 	1
  Negate> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> breg> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> breg> boreg> failed		 	1
  Negate> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> wreg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  Negate> wreg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  Negate> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> wreg> swreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> wreg> swreg> failed		 	1
  Negate> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> wreg> uwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> wreg> uwreg> failed		 	1
  Negate> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> wreg> untypedwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> wreg> untypedwreg> failed		 	1
  Negate> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  Negate> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  Negate> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  Negate> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  Negate> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> reg> ireg> indexreg> failed		 	1
  Negate> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Negate> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Negate> reg> ureg> failed		 	1
  Match pattern NOTOP ( addrmode rm , type t ) means [ ( ref t ) rm := NOT ( ( t ) ^ ( rm ) ) ] assembles [ 'not' t ' ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  NOTOP> Match ( ref t ) rm := NOT ( ( t ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  NOTOP> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  NOTOP> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  NOTOP> Match pattern addrmode means [ maddrmode | anyreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  NOTOP> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  NOTOP>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  NOTOP> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  NOTOP> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  NOTOP> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false-> null 		 	1
  NOTOP> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> bind actualtype int32to param 1=int32		 	1
  NOTOP> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> Match  alternatives format   to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> labelconstf>  try to commute arguments 		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	1
  NOTOP> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L6int32h2149911365540569994true-> alternative     0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L6int32h2149911365540569994true0 switchvar 0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	1
  NOTOP> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match r  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type ref int32		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true-> null 		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf>  failvar= 1+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true0 switchvar 0		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf>  try to commute arguments 		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf>  try to commute arguments 		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match r  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type int32		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  NOTOP> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> ^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  NOTOP> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r2 ) , off )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r2  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern nsreg means [ EDI | ESI | EBX | EBP | EAX | EDX | ECX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> value type ref int32		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> register type ref int32		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> load into %edi		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>  is word == word		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> assign check returns true		 %eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>  unoptimisedcodegen seq(
  assign((ref int32)%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 %eadx	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>  cgstatement optlevel=0:seq(
  assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 %eadx	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>   exact match found for assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>   rollBackReservations to 1		 %eadx	2
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> reserve register at depth 2,%edi		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> L6int32h-5738444977846951095true-> alternative     0		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0L6int32h-5738444977846951095true0 switchvar 0		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %edi%eadx	1
  NOTOP> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %edi%eadx	1
  NOTOP> Match NOT ( ( t ) ^ ( rm ) )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  NOTOP> Match NOT  to ^		 %edi%eadx	1
  NOTOP> rollBackReservations to 0		 %edi%eadx	1
  NOTOP> %edi:1		 %edi%eadx	1
  NOTOP> Unreserve %edi		 %eadx	1
  NOTOP> rollBackReservations to 0		 %eadx	1
  NOTOP> %eax:0		 %eadx	1
  NOTOP> Unreserve %eax		 	1
  Match pattern MNegate ( anyreg r1 , type t ) means [ ( ref t ) r1 := * ( ( t ) - 1 , ( t ) ^ ( r1 ) ) ] assembles [ 'neg' t ' ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MNegate> Match ( ref t ) r1 := * ( ( t ) - 1 , ( t ) ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MNegate> Match ( ref t ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> Match pattern anyreg means [ breg | wreg | reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MNegate>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MNegate> breg> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> breg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MNegate> breg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MNegate> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> breg> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> breg> bireg> failed		 	1
  MNegate> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> breg> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> breg> bureg> failed		 	1
  MNegate> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> breg> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> breg> boreg> failed		 	1
  MNegate> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> wreg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MNegate> wreg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MNegate> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> wreg> swreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> wreg> swreg> failed		 	1
  MNegate> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> wreg> uwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> wreg> uwreg> failed		 	1
  MNegate> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> wreg> untypedwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> wreg> untypedwreg> failed		 	1
  MNegate> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MNegate> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MNegate> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MNegate> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MNegate> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> reg> ireg> indexreg> failed		 	1
  MNegate> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MNegate> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MNegate> reg> ureg> failed		 	1
  Match pattern BTS ( reg r1 , reg r2 ) means [ ( ref uint8 ) mem ( r1 ) := OR ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ] assembles [ 'bts ' r2 ',(' r1 ')' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BTS> Match ( ref uint8 ) mem ( r1 ) := OR ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BTS> Match ( ref uint8 ) mem ( r1 )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern TESTIN ( reg r1 , reg r2 , breg r ) means [ r := <> ( AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) , ( int8 ) 0 ) ] assembles [ 'bt  ' r2 ',(' r1 ')
 setc ' r '
 not ' r '
 inc ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  TESTIN> Match r := <> ( AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) , ( int8 ) 0 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  TESTIN> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  TESTIN> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  TESTIN> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  TESTIN>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  TESTIN> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  TESTIN> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  TESTIN> bireg> failed		 	1
  TESTIN> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  TESTIN> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  TESTIN> bureg> failed		 	1
  TESTIN> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  TESTIN> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  TESTIN> boreg> failed		 	1
  Match pattern SHIFT ( shiftop op , shiftcount s , anyreg r , type t ) means [ ( ref t ) r := ( t ) op ( ^ ( r ) , s ) ] assembles [ 'sh' op ' ' s ', ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SHIFT> Match ( ref t ) r := ( t ) op ( ^ ( r ) , s )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SHIFT> Match ( ref t ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> Match pattern anyreg means [ breg | wreg | reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SHIFT>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SHIFT> breg> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> breg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SHIFT> breg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SHIFT> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> breg> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> breg> bireg> failed		 	1
  SHIFT> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> breg> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> breg> bureg> failed		 	1
  SHIFT> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> breg> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> breg> boreg> failed		 	1
  SHIFT> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> wreg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SHIFT> wreg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SHIFT> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> wreg> swreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> wreg> swreg> failed		 	1
  SHIFT> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> wreg> uwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> wreg> uwreg> failed		 	1
  SHIFT> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> wreg> untypedwreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> wreg> untypedwreg> failed		 	1
  SHIFT> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SHIFT> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SHIFT> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SHIFT> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SHIFT> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> reg> ireg> indexreg> failed		 	1
  SHIFT> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SHIFT> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SHIFT> reg> ureg> failed		 	1
  Match pattern UINT8MAX ( breg r1 , breg r2 ) means [ ( ref uint8 ) r1 := MAX ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 ja 0f
 mov ' r2 ',' r1 '
0:
' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  UINT8MAX> Match ( ref uint8 ) r1 := MAX ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  UINT8MAX> Match ( ref uint8 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern UINT8MIN ( breg r1 , breg r2 ) means [ ( ref uint8 ) r1 := MIN ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 jna 0f
 mov ' r2 ',' r1 '
0:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  UINT8MIN> Match ( ref uint8 ) r1 := MIN ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  UINT8MIN> Match ( ref uint8 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern INT8MAX ( breg r1 , breg r2 ) means [ ( ref int8 ) r1 := MAX ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 jg 0f
 mov ' r2 ',' r1 '
0:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INT8MAX> Match ( ref int8 ) r1 := MAX ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INT8MAX> Match ( ref int8 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern INT8MIN ( breg r1 , breg r2 ) means [ ( ref int8 ) r1 := MIN ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 jl 0f
 mov ' r2 ',' r1 '
0:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INT8MIN> Match ( ref int8 ) r1 := MIN ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INT8MIN> Match ( ref int8 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern SELECT ( reg r1 , reg r2 , addrmode r3 , signed t ) means [ ( ref t ) r1 := OR ( AND ( ( t ) ^ ( r1 ) , ( t ) ^ ( r2 ) ) , AND ( ( t ) ^ ( r3 ) , NOT ( ^ ( r2 ) ) ) ) ] assembles [ 'andl ' r2 ',' r1 '
' 'notl ' r1 '
' 'andl ' r3 ',' ' ' r2 '
' 'orl ' r2 ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SELECT> Match ( ref t ) r1 := OR ( AND ( ( t ) ^ ( r1 ) , ( t ) ^ ( r2 ) ) , AND ( ( t ) ^ ( r3 ) , NOT ( ^ ( r2 ) ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SELECT> Match ( ref t ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SELECT> Match pattern signed means [ int8 | int16 | int32 ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  SELECT> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  SELECT> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  SELECT> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  SELECT> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  SELECT> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  SELECT> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern PLANT ( label l ) means [ l ] assembles [ l ':' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANT> Match l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANT> Match l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern LITPUSH ( offset s ) means [ PUSH ( mainSTACK , s ) ] assembles [ 'pushl $' s ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  LITPUSH> Match PUSH ( mainSTACK , s )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern MEMPUSH ( maddrmode m ) means [ PUSH ( mainSTACK , ( word ) ^ ( m ) ) ] assembles [ 'pushl ' m ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MEMPUSH> Match PUSH ( mainSTACK , ( word ) ^ ( m ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SETB ( condition c , bireg r1 , bireg rm , breg r , signed t , byte b ) means [ r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setb
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETB> Match r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETB> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETB> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SETB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SETB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETB> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETB> bireg> failed		 	1
  SETB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETB> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETB> bureg> failed		 	1
  SETB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETB> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETB> boreg> failed		 	1
  Match pattern SETUB ( unsignedcondition c , bureg r1 , regaddrimmediate rm , breg r , unsigned t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setub
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETUB> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETUB> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUB> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SETUB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SETUB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUB> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETUB> bireg> failed		 	1
  SETUB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUB> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETUB> bureg> failed		 	1
  SETUB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUB> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETUB> boreg> failed		 	1
  Match pattern SETW ( condition c , wreg r1 , wreg rm , breg r , signed t , byte b ) means [ r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setw
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETW> Match r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETW> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETW> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETW> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SETW>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SETW> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETW> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETW> bireg> failed		 	1
  SETW> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETW> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETW> bureg> failed		 	1
  SETW> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETW> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETW> boreg> failed		 	1
  Match pattern SETUW ( unsignedcondition c , uwreg r1 , uwreg rm , breg r , unsigned t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setuw
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETUW> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETUW> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUW> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUW> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SETUW>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SETUW> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUW> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETUW> bireg> failed		 	1
  SETUW> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUW> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETUW> bureg> failed		 	1
  SETUW> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETUW> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETUW> boreg> failed		 	1
  Match pattern SET ( condition c , ireg r1 , ireg rm , breg r , signed t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmpl' ' ' rm ',' ' ' r1 '#set
 set' c ' ' r '
 subb $1 ,' r '
 not ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SET> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SET> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SET> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SET> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SET>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SET> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SET> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SET> bireg> failed		 	1
  SET> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SET> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SET> bureg> failed		 	1
  SET> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SET> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SET> boreg> failed		 	1
  Match pattern SETU ( unsignedcondition c , ureg r1 , ureg rm , breg r , unsigned t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmpl' ' ' rm ',' ' ' r1 '#setu
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETU> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SETU> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETU> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETU> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SETU>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SETU> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETU> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETU> bireg> failed		 	1
  SETU> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETU> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETU> bureg> failed		 	1
  SETU> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SETU> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SETU> boreg> failed		 	1
  Match pattern Tob ( reg r , breg b ) means [ b := ( octet ) ^ ( r ) ] assembles [ 'pushl ' r '
movb (%esp), ' b '
 addl $4,%esp ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Tob> Match b := ( octet ) ^ ( r )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Tob> Match b  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Tob> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Tob> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  Tob>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  Tob> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Tob> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Tob> bireg> failed		 	1
  Tob> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Tob> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Tob> bureg> failed		 	1
  Tob> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Tob> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  Tob> boreg> failed		 	1
  Match pattern GOTO ( jumpmode l ) means [ goto l ] assembles [ 'jmp ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  GOTO> Match goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern FAIL ( int i ) means [ interrupt i ] assembles [ 'int $' i ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  FAIL> Match interrupt i  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern BOUND4 ( reg r1 , reg r2 ) means [ if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 8 ) ) ) ) ) ) interrupt 5 ] assembles [ 'bound ' r2 ',4(' r1 ')' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BOUND4> Match if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 8 ) ) ) ) ) ) interrupt 5  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern BOUND0 ( reg r1 , reg r2 ) means [ if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( ^ ( r1 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) ) ) interrupt 5 ] assembles [ 'bound ' r2 ',(' r1 ')' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BOUND0> Match if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( ^ ( r1 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) ) ) interrupt 5  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern BOUND16 ( reg r1 , reg r2 ) means [ if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 16 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 20 ) ) ) ) ) ) interrupt 5 ] assembles [ 'bound ' r2 ',16(' r1 ')' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BOUND16> Match if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 16 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 20 ) ) ) ) ) ) interrupt 5  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern PLANTICONST ( longint r , type t ) means [ loc ( t ) r ] assembles [ '.long ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANTICONST> Match loc ( t ) r  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern PLANTWCONST ( word16 r , type t ) means [ loc ( t ) r ] assembles [ '.short ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANTWCONST> Match loc ( t ) r  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern PLANTBCONST ( byte r , type t ) means [ loc ( t ) r ] assembles [ '.byte ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANTBCONST> Match loc ( t ) r  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern PLANTRCONST ( double r , type t ) means [ loc ( t ) r ] assembles [ '.double ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANTRCONST> Match loc ( t ) r  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern PLANTSCONST ( float r , type t ) means [ loc ( t ) r ] assembles [ '.float ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  PLANTSCONST> Match loc ( t ) r  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern REPMOVSD ( countreg s , maddrmode m1 , sourcereg si , destreg di ) means [ for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref int32 ) mem ( + ( ^ ( di ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) := ^ ( ( ref int32 ) mem ( + ( ^ ( si ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) ) ] assembles [ ' inc %ecx
 jle 1f
 rep movsl
1:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REPMOVSD> Match for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref int32 ) mem ( + ( ^ ( di ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) := ^ ( ( ref int32 ) mem ( + ( ^ ( si ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern REPMOVSB ( countreg s , maddrmode m1 , sourcereg si , destreg di ) means [ for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref octet ) mem ( + ( ^ ( di ) , ^ ( ( ref int32 ) m1 ) ) ) := ^ ( ( ref octet ) mem ( + ( ^ ( si ) , ^ ( ( ref int32 ) m1 ) ) ) ) ] assembles [ ' inc %ecx
 jle 1f
 rep movsb
1:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REPMOVSB> Match for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref octet ) mem ( + ( ^ ( di ) , ^ ( ( ref int32 ) m1 ) ) ) := ^ ( ( ref octet ) mem ( + ( ^ ( si ) , ^ ( ( ref int32 ) m1 ) ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern ADDUSB ( addrmode fm , breg r1 , breg rm ) means [ rm := +: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'addb  ' r1 ',' rm '
 jnc 0f
 movb $255, ' rm '
 0:nop
 ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  ADDUSB> Match rm := +: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  ADDUSB> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDUSB> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDUSB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  ADDUSB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  ADDUSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDUSB> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  ADDUSB> bireg> failed		 	1
  ADDUSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDUSB> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  ADDUSB> bureg> failed		 	1
  ADDUSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDUSB> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  ADDUSB> boreg> failed		 	1
  Match pattern SUBUSB ( breg r1 , breg rm ) means [ rm := -: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'subb  ' r1 ',' rm '
 jnc 0f
 movb $0, ' rm '
 0:nop
 ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SUBUSB> Match rm := -: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SUBUSB> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBUSB> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBUSB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SUBUSB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SUBUSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBUSB> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SUBUSB> bireg> failed		 	1
  SUBUSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBUSB> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SUBUSB> bureg> failed		 	1
  SUBUSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBUSB> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SUBUSB> boreg> failed		 	1
  Match pattern ADDSSB ( breg r1 , breg rm ) means [ rm := +: ( ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'addb  ' r1 ',' rm '
 jno 0f
 jg 1f
 movb $-128 ,' rm '  
 jng 0f
1:
 movb $127, ' rm '
0:
 ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  ADDSSB> Match rm := +: ( ^ ( rm ) , ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  ADDSSB> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDSSB> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDSSB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  ADDSSB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  ADDSSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDSSB> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  ADDSSB> bireg> failed		 	1
  ADDSSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDSSB> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  ADDSSB> bureg> failed		 	1
  ADDSSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  ADDSSB> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  ADDSSB> boreg> failed		 	1
  Match pattern SUBSSB ( addrmode fm , breg r1 , breg rm ) means [ rm := ( int8 ) -: ( ( int8 ) ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'subb  ' r1 ',' rm '
 jno 0f
 jg 1f
 movb $-128, ' rm '  
 jng 0f
1: movb $127,' rm '
0: nop
 nop' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SUBSSB> Match rm := ( int8 ) -: ( ( int8 ) ^ ( rm ) , ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SUBSSB> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBSSB> Match pattern breg means [ bireg | bureg | boreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBSSB> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SUBSSB>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SUBSSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBSSB> bireg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SUBSSB> bireg> failed		 	1
  SUBSSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBSSB> bureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SUBSSB> bureg> failed		 	1
  SUBSSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SUBSSB> boreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SUBSSB> boreg> failed		 	1
  Match pattern MULTSSB ( bacc r1 , bnonacc r2 ) means [ r2 := *: ( ^ ( r2 ) , ^ ( r1 ) ) ] assembles [ 'imul  ' r2 '
 shr $7,%ax
 movb %al, ' r2 ' ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MULTSSB> Match r2 := *: ( ^ ( r2 ) , ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MULTSSB> Match r2  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MULTSSB> Match pattern bnonacc means [ BL | CL | DL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MULTSSB> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MULTSSB> failed		 	1
  Match pattern MULTSSBAL ( bacc r1 , bnonacc r2 ) means [ r1 := *: ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'imul  ' r2 '
 shr  $7,%ax' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MULTSSBAL> Match r1 := *: ( ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MULTSSBAL> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MULTSSBAL> Match pattern bacc means [ AL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MULTSSBAL> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MULTSSBAL> failed		 	1
  Match pattern STOREWR ( memrisc rm , wreg r1 , word16 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STOREWR' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREWR> Match ( ref t ) rm := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREWR> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STOREWR> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern STORER ( memrisc rm , reg r1 , word32 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STORER' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORER> Match ( ref t ) rm := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORER> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORER> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern STOREBR ( maddrmode rm , breg r1 ) means [ ( ref octet ) rm := ^ ( r1 ) ] assembles [ 'movb ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREBR> Match ( ref octet ) rm := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREBR> Match ( ref octet ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern INTMIN ( reg r1 , reg r2 ) means [ r1 := MIN ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r1 ',' r2 '
  cmovl ' r2 ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INTMIN> Match r1 := MIN ( ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INTMIN> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMIN> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMIN> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  INTMIN>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  INTMIN> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMIN> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  INTMIN> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  INTMIN> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMIN> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  INTMIN> ireg> indexreg> failed		 	1
  INTMIN> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMIN> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  INTMIN> ureg> failed		 	1
  Match pattern INTMAX ( reg r1 , reg r2 ) means [ r1 := MAX ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r1 ',' r2 '
 cmovg ' r2 ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INTMAX> Match r1 := MAX ( ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  INTMAX> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMAX> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMAX> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  INTMAX>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  INTMAX> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMAX> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  INTMAX> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  INTMAX> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMAX> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  INTMAX> ireg> indexreg> failed		 	1
  INTMAX> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  INTMAX> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  INTMAX> ureg> failed		 	1
  Match pattern FSET ( fcondition c , breg r , fputype t ) means [ ( ref int8 ) r := ( int8 ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ] assembles [ 'fxch' '
  fucompp' '
 pushw %ax' '
 fnstsw %ax' '
 sahf' '
 popw %ax' '
 set' c ' ' r '
 not ' r '
 inc ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  FSET> Match ( ref int8 ) r := ( int8 ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  FSET> Match ( ref int8 ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern STORESS ( smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) rm := ( ieee32 ) ^ ( r1 ) ] assembles [ 'movss  ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORESS> Match ( ref ieee32 ) rm := ( ieee32 ) ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORESS> Match ( ref ieee32 ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern COMISSIFGOTO ( label l , sxmreg r1 , sxmreg r2 , fcondition c , int t ) means [ if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l ] assembles [ 'comiss ' r1 ',' r2 '
 j' c ' ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  COMISSIFGOTO> Match if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern RPUSH ( pushreg r ) means [ PUSH ( mainSTACK , ^ ( r ) ) ] assembles [ 'pushl ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RPUSH> Match PUSH ( mainSTACK , ^ ( r ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern REFPUSH ( maddrmode m , type t ) means [ PUSH ( mainSTACK , ( ref t ) ^ ( m ) ) ] assembles [ 'push l ' m ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REFPUSH> Match PUSH ( mainSTACK , ( ref t ) ^ ( m ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SDEREF ( int t ) means [ PUSH ( mainSTACK , ( t ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) ) ] assembles [ 'xchgl %esi,(%esp)
 movl (%esi),%esi
  xchgl %esi,(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SDEREF> Match PUSH ( mainSTACK , ( t ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SDEREFDOUBLEw ( int t ) means [ PUSH ( mainSTACK , ( doubleword ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) ) ] assembles [ 'xchgl %esi,(%esp)
 pushl (%esi)
 movl  4(%esi),%esi
  xchgl %esi,4(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SDEREFDOUBLEw> Match PUSH ( mainSTACK , ( doubleword ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern IFBOOL ( label l , breg r1 ) means [ if ( ( int8 ) ^ ( r1 ) ) goto l ] assembles [ 'test ' r1 ',' r1 '
 jnz ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  IFBOOL> Match if ( ( int8 ) ^ ( r1 ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SMLIT ( nonmultoperator op , offset s ) means [ PUSH ( mainSTACK , ( int32 ) op ( ( int32 ) POP ( mainSTACK ) , s ) ) ] assembles [ op 'l  $' s ',(%esp) ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMLIT> Match PUSH ( mainSTACK , ( int32 ) op ( ( int32 ) POP ( mainSTACK ) , s ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SMRP ( nonmultoperator op , reg r1 , type t ) means [ PUSH ( mainSTACK , ( ref t ) op ( ( word ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ op 'l ' r1 ',(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMRP> Match PUSH ( mainSTACK , ( ref t ) op ( ( word ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SADD ( saddoperator op ) means [ PUSH ( mainSTACK , ( longint ) + ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) ) ] assembles [ 'xchgl %eax,(%esp)
 addl %eax, 4(%esp)
 popl %eax' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SADD> Match PUSH ( mainSTACK , ( longint ) + ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SMULIT ( nonmultoperator op , offset s ) means [ PUSH ( mainSTACK , ( int32 ) * ( ( int32 ) POP ( mainSTACK ) , s ) ) ] assembles [ 'xchgl %eax,(%esp)
 imul  $' s ',%eax
 xchgl %eax,(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMULIT> Match PUSH ( mainSTACK , ( int32 ) * ( ( int32 ) POP ( mainSTACK ) , s ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SMRADD ( reg r1 ) means [ r1 := ( int32 ) + ( ( int32 ) POP ( mainSTACK ) , ^ ( r1 ) ) ] assembles [ 'addl (%esp), ' r1 ' 
 addl $4, %esp' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMRADD> Match r1 := ( int32 ) + ( ( int32 ) POP ( mainSTACK ) , ^ ( r1 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMRADD> Match r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SMRADD> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SMRADD> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SMRADD>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SMRADD> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SMRADD> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  SMRADD> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  SMRADD> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SMRADD> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SMRADD> ireg> indexreg> failed		 	1
  SMRADD> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SMRADD> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SMRADD> ureg> failed		 	1
  Match pattern SOP ( saddoperator op ) means [ PUSH ( mainSTACK , ( longint ) op ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) ) ] assembles [ 'xchgl %eax,(%esp)
 ' op 'l  4(%esp),%eax
 movl %eax,4(%esp)
 popl %eax' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SOP> Match PUSH ( mainSTACK , ( longint ) op ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SMR ( nonmultoperator op , reg r1 ) means [ PUSH ( mainSTACK , ( int32 ) op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ op 'l ' r1 ',(%esp) ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMR> Match PUSH ( mainSTACK , ( int32 ) op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern BSMR ( nonmultoperator op , breg r1 ) means [ PUSH ( mainSTACK , ( octet ) op ( ( octet ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ op 'b ' r1 ',(%esp) ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BSMR> Match PUSH ( mainSTACK , ( octet ) op ( ( octet ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern STOREWR ( memrisc rm , wreg r1 , word16 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STOREWR' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREWR> Match ( ref t ) rm := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREWR> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STOREWR> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STOREWR> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern STORER ( memrisc rm , reg r1 , word32 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STORER' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORER> Match ( ref t ) rm := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORER> Match ( ref t ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  STORER> Match pattern word32 means [ int32 | uint32 | word ]  to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match  alternatives format   to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  STORER> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))))		 	1
  Match pattern STOREBR ( maddrmode rm , breg r1 ) means [ ( ref octet ) rm := ^ ( r1 ) ] assembles [ 'movb ' r1 ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREBR> Match ( ref octet ) rm := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STOREBR> Match ( ref octet ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern REFPOP ( addrmode r , type t , type t2 ) means [ ( ref ref t ) r := ( ref t2 ) POP ( mainSTACK ) ] assembles [ 'popl ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REFPOP> Match ( ref ref t ) r := ( ref t2 ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REFPOP> Match ( ref ref t ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern REFPOP2 ( addrmode r , type t ) means [ ( ref ref t ) r := ( word ) POP ( mainSTACK ) ] assembles [ 'popl ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REFPOP2> Match ( ref ref t ) r := ( word ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  REFPOP2> Match ( ref ref t ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern MEMPOP ( maddrmode m ) means [ ( ref int32 ) m := ( int32 ) POP ( mainSTACK ) ] assembles [ 'popl ' m ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MEMPOP> Match ( ref int32 ) m := ( int32 ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MEMPOP> Match ( ref int32 ) m  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern BPOP ( bureg r ) means [ r := ( octet ) POP ( mainSTACK ) ] assembles [ 'movb (%esp),  ' r '
 add $4,%esp' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BPOP> Match r := ( octet ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BPOP> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BPOP> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BPOP> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  BPOP> failed		 	1
  Match pattern BSPOP ( bireg r ) means [ r := ( int8 ) POP ( mainSTACK ) ] assembles [ 'movb (%esp),  ' r '
 addl $4,%esp' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BSPOP> Match r := ( int8 ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BSPOP> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BSPOP> Match pattern bireg means [ BL | DL | AL | CL ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  BSPOP> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  BSPOP> failed		 	1
  Match pattern BSPUSH ( baddrmode r ) means [ PUSH ( mainSTACK , ( int8 ) ^ ( r ) ) ] assembles [ 'pushl %esi
 movsbl ' r ',%esi
 xchgl %esi,(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BSPUSH> Match PUSH ( mainSTACK , ( int8 ) ^ ( r ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern DMEMPUSH ( regindirf ea ) means [ PUSH ( mainSTACK , ( doubleword ) ^ ( ( ref doubleword ) mem ( ea ) ) ) ] assembles [ 'pushl  4' ea '
 pushl ' ea ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  DMEMPUSH> Match PUSH ( mainSTACK , ( doubleword ) ^ ( ( ref doubleword ) mem ( ea ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern RPUSHE ( ureg r ) means [ PUSH ( mainSTACK , ( int64 ) EXTEND ( ^ ( r ) ) ) ] assembles [ ' pushl $0 # extend ' r ' to 64' '
 pushl ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RPUSHE> Match PUSH ( mainSTACK , ( int64 ) EXTEND ( ^ ( r ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern BPUSH ( bureg r ) means [ PUSH ( mainSTACK , ^ ( r ) ) ] assembles [ 'pushl $0
 movb ' r ',(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  BPUSH> Match PUSH ( mainSTACK , ^ ( r ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern STACKSTORE ( reg r1 ) means [ ( ref int32 ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 ) ] assembles [ 'xchgl (%esp),' r1 '
  popl (' r1 ')
   ' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STACKSTORE> Match ( ref int32 ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STACKSTORE> Match ( ref int32 ) mem ( ( int32 ) POP ( mainSTACK ) )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern STACKWSTORE ( wreg r1 ) means [ ( ref halfword ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 ) ] assembles [ 'xchgl (%esp),%esi
  movw ' r1 ',(%esi)' '
  popl %esi' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STACKWSTORE> Match ( ref halfword ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STACKWSTORE> Match ( ref halfword ) mem ( ( int32 ) POP ( mainSTACK ) )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern STACKBSTORE ( breg r1 ) means [ ( ref octet ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 ) ] assembles [ 'xchgl (%esp),%esi
  movb ' r1 ',(%esi)' '
  popl %esi' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STACKBSTORE> Match ( ref octet ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STACKBSTORE> Match ( ref octet ) mem ( ( int32 ) POP ( mainSTACK ) )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern RPOP ( pushreg r , type t ) means [ ( ref t ) r := ( t ) POP ( mainSTACK ) ] assembles [ 'popl  ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RPOP> Match ( ref t ) r := ( t ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  RPOP> Match ( ref t ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> Match pattern pushreg means [ reg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RPOP>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RPOP> reg> Match pattern reg means [ ireg | ureg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> reg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RPOP> reg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RPOP> reg> ireg> Match pattern ireg means [ indexreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> reg> ireg> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  RPOP> reg> ireg>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  RPOP> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> reg> ireg> indexreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RPOP> reg> ireg> indexreg> failed		 	1
  RPOP> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  RPOP> reg> ureg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  RPOP> reg> ureg> failed		 	1
  Match pattern SMRSHIFT ( shiftop op , shiftcountreg r1 ) means [ PUSH ( mainSTACK , op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ 'xchgl %eax, (%esp)
' 'sh' op 'l  %cl,%eax ' '
 xchgl %eax,(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SMRSHIFT> Match PUSH ( mainSTACK , op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern OPPDADD ( soperator op , xmreg rm , xmreg r1 ) means [ ( ref ieee64 vector ( 2 ) ) r1 := + ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) ) ] assembles [ 'addpd  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPDADD> Match ( ref ieee64 vector ( 2 ) ) r1 := + ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPDADD> Match ( ref ieee64 vector ( 2 ) ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern MOVDQL ( maddrmode rm , xmreg r1 ) means [ ( ref quadword ) r1 := ^ ( rm ) ] assembles [ 'movdqu ' rm ',' r1 '#MOVQDL
 prefetcht0 128+' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVDQL> Match ( ref quadword ) r1 := ^ ( rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVDQL> Match ( ref quadword ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern OPSS ( soperator op , smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := op ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) ) ] assembles [ op 'ss  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPSS> Match ( ref ieee32 ) r1 := op ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPSS> Match ( ref ieee32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern OPSD ( soperator op , xmmr64m rm , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := op ( ( ieee64 ) ^ ( r1 ) , ( ieee64 ) ^ ( rm ) ) ] assembles [ op 'sd  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPSD> Match ( ref ieee64 ) r1 := op ( ( ieee64 ) ^ ( r1 ) , ( ieee64 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPSD> Match ( ref ieee64 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern ADDSS ( smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := + ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) ) ] assembles [ 'addss  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  ADDSS> Match ( ref ieee32 ) r1 := + ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  ADDSS> Match ( ref ieee32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern CVTSI2SD ( reg rm , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := ( ieee64 ) FLOAT ( ( int32 ) ^ ( rm ) ) ] assembles [ 'cvtsi2sd  ' rm ', ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTSI2SD> Match ( ref ieee64 ) r1 := ( ieee64 ) FLOAT ( ( int32 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTSI2SD> Match ( ref ieee64 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern CVTSI2SS ( maddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) rm ) ) ] assembles [ 'cvtsi2ss  ' rm ', ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTSI2SS> Match ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTSI2SS> Match ( ref ieee32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern CVTSD2SI ( xmmr64m rm , reg r1 ) means [ ( ref int32 ) r1 := ( int32 ) ROUND ( ( ieee64 ) ^ ( rm ) ) ] assembles [ 'cvtsd2si  ' rm ', ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTSD2SI> Match ( ref int32 ) r1 := ( int32 ) ROUND ( ( ieee64 ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTSD2SI> Match ( ref int32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern CVTIR2SS ( reg r0 , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) r0 ) ) ] assembles [ 'cvtsi2ss  ' r0 ', ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTIR2SS> Match ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) r0 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  CVTIR2SS> Match ( ref ieee32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern XRLOADLIT ( float f , float t , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ( t ) const f ] assembles [ 'movss 0f,' r1 '
 jmp 1f' ' 
 0:
.float ' f '
 1:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  XRLOADLIT> Match ( ref ieee32 ) r1 := ( t ) const f  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  XRLOADLIT> Match ( ref ieee32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern XRDLOADLIT ( real f , real t , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := ( t ) const f ] assembles [ 'movsd 0f,' r1 '
 jmp 1f' ' 
0:
.double ' f '
1:' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  XRDLOADLIT> Match ( ref ieee64 ) r1 := ( t ) const f  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  XRDLOADLIT> Match ( ref ieee64 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern MOVSS ( smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ^ ( ( ref ieee32 ) rm ) ] assembles [ 'movss  ' rm ', ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSS> Match ( ref ieee32 ) r1 := ^ ( ( ref ieee32 ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSS> Match ( ref ieee32 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern MOVSD ( xmmr64m rm , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := ^ ( ( ref ieee64 ) rm ) ] assembles [ 'movsd  ' rm ', ' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSD> Match ( ref ieee64 ) r1 := ^ ( ( ref ieee64 ) rm )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVSD> Match ( ref ieee64 ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern SSRPUSH ( sxmreg r ) means [ PUSH ( mainSTACK , ^ ( r ) ) ] assembles [ 'subl $4,%esp
 movss ' r ',(%esp)' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSRPUSH> Match PUSH ( mainSTACK , ^ ( r ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern SSRPOPI ( sxmreg r ) means [ ( ref ieee32 ) r := ( ieee32 ) FLOAT ( ( int32 ) POP ( mainSTACK ) ) ] assembles [ ' cvtsi2ss (%esp),' r '
 addl $4,%esp' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSRPOPI> Match ( ref ieee32 ) r := ( ieee32 ) FLOAT ( ( int32 ) POP ( mainSTACK ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSRPOPI> Match ( ref ieee32 ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern SSRPOP ( sxmreg r ) means [ ( ref ieee32 ) r := ( ieee32 ) POP ( mainSTACK ) ] assembles [ ' movss (%esp),' r '
 addl $4,%esp' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSRPOP> Match ( ref ieee32 ) r := ( ieee32 ) POP ( mainSTACK )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSRPOP> Match ( ref ieee32 ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern FREP4 ( xmreg m , wreg r ) means [ m := rep ( ^ ( r ) , 4 ) ] assembles [ 'push ' r '
 push ' r '
 push ' r '
 push ' r '
 movups (%esp),' m '
 add $16,%esp' ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  FREP4> Match m := rep ( ^ ( r ) , 4 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  FREP4> Match m  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> Match pattern xmreg means [ psxmreg | pdxmreg | xmregi324 | xmreg8 | xmreg16 | uxmreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  FREP4>  failvar= 0M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  FREP4> psxmreg> Match pattern psxmreg means [ XMM7R324 | XMM6R324 | XMM5R324 | XMM4R324 | XMM3R324 | XMM2R324 | XMM1R324 | XMM0R324 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> psxmreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  FREP4> psxmreg> failed		 	1
  FREP4> pdxmreg> Match pattern pdxmreg means [ XMM7R642 | XMM6R642 | XMM5R642 | XMM4R642 | XMM3R642 | XMM2R642 | XMM1R642 | XMM0R642 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> pdxmreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  FREP4> pdxmreg> failed		 	1
  FREP4> xmregi324> Match pattern xmregi324 means [ XMM0I324 | XMM3I324 | XMM2I324 | XMM1I324 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> xmregi324> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  FREP4> xmregi324> failed		 	1
  FREP4> xmreg8> Match pattern xmreg8 means [ XMM0I8 | XMM3I8 | XMM1I8 | XMM2I8 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> xmreg8> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  FREP4> xmreg8> failed		 	1
  FREP4> xmreg16> Match pattern xmreg16 means [ XMM0I16 | XMM3I16 | XMM1I16 | XMM2I16 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> xmreg16> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  FREP4> xmreg16> failed		 	1
  FREP4> uxmreg> Match pattern uxmreg means [ XMM1 | XMM3 | XMM4 | XMM5 | XMM6 | XMM2 | XMM0 | XMM7 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  FREP4> uxmreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  FREP4> uxmreg> failed		 	1
  FREP4>  record failure pattern xmreg means [ psxmreg | pdxmreg | xmregi324 | xmreg8 | xmreg16 | uxmreg ] M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0		 	1
  Match pattern SSQRT ( sxmreg r ) means [ r := SQRT ( ^ ( r ) ) ] assembles [ 'sqrtss ' r ',' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSQRT> Match r := SQRT ( ^ ( r ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SSQRT> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SSQRT> Match pattern sxmreg means [ XMM00 | XMM10 | XMM20 | XMM30 | XMM40 | XMM50 | XMM60 | XMM70 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SSQRT> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SSQRT> failed		 	1
  Match pattern SDSQRT ( xmmr64 r ) means [ r := SQRT ( ^ ( r ) ) ] assembles [ 'sqrtsd ' r ',' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SDSQRT> Match r := SQRT ( ^ ( r ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  SDSQRT> Match r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SDSQRT> Match pattern xmmr64 means [ XMM0R64 | XMM1R64 | XMM2R64 | XMM3R64 | XMM4R64 | XMM5R64 | XMM6R64 | XMM7R64 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  SDSQRT> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  SDSQRT> failed		 	1
  Match pattern OPPS ( soperator op , xmreg rm , xmreg r1 ) means [ ( ref ieee32 vector ( 4 ) ) r1 := op ( ( ieee32 vector ( 4 ) ) ^ ( r1 ) , ( ieee32 vector ( 4 ) ) ^ ( rm ) ) ] assembles [ op 'ps  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPS> Match ( ref ieee32 vector ( 4 ) ) r1 := op ( ( ieee32 vector ( 4 ) ) ^ ( r1 ) , ( ieee32 vector ( 4 ) ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPS> Match ( ref ieee32 vector ( 4 ) ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern OPPD ( soperator op , xmreg rm , xmreg r1 ) means [ ( ref ieee64 vector ( 2 ) ) r1 := op ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) ) ] assembles [ op 'pd  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPD> Match ( ref ieee64 vector ( 2 ) ) r1 := op ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPD> Match ( ref ieee64 vector ( 2 ) ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern STORUPD ( smaddrmode rm , xmreg r1 ) means [ ( ref ieee64 vector ( 2 ) ) rm := ( ieee64 vector ( 2 ) ) ^ ( r1 ) ] assembles [ 'movupd  ' r1 ', ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORUPD> Match ( ref ieee64 vector ( 2 ) ) rm := ( ieee64 vector ( 2 ) ) ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORUPD> Match ( ref ieee64 vector ( 2 ) ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern MOVUPD ( smaddrmode r1 , xmreg rm ) means [ rm := ( ieee64 vector ( 2 ) ) ^ ( r1 ) ] assembles [ 'movupd  ' r1 ', ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVUPD> Match rm := ( ieee64 vector ( 2 ) ) ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVUPD> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> Match pattern xmreg means [ psxmreg | pdxmreg | xmregi324 | xmreg8 | xmreg16 | uxmreg ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false-> null 		 	1
  MOVUPD>  failvar= 1M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 )h-3204915108055699955false0 switchvar 0		 	1
  MOVUPD> psxmreg> Match pattern psxmreg means [ XMM7R324 | XMM6R324 | XMM5R324 | XMM4R324 | XMM3R324 | XMM2R324 | XMM1R324 | XMM0R324 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> psxmreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVUPD> psxmreg> failed		 	1
  MOVUPD> pdxmreg> Match pattern pdxmreg means [ XMM7R642 | XMM6R642 | XMM5R642 | XMM4R642 | XMM3R642 | XMM2R642 | XMM1R642 | XMM0R642 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> pdxmreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVUPD> pdxmreg> failed		 	1
  MOVUPD> xmregi324> Match pattern xmregi324 means [ XMM0I324 | XMM3I324 | XMM2I324 | XMM1I324 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> xmregi324> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVUPD> xmregi324> failed		 	1
  MOVUPD> xmreg8> Match pattern xmreg8 means [ XMM0I8 | XMM3I8 | XMM1I8 | XMM2I8 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> xmreg8> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVUPD> xmreg8> failed		 	1
  MOVUPD> xmreg16> Match pattern xmreg16 means [ XMM0I16 | XMM3I16 | XMM1I16 | XMM2I16 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> xmreg16> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVUPD> xmreg16> failed		 	1
  MOVUPD> uxmreg> Match pattern uxmreg means [ XMM1 | XMM3 | XMM4 | XMM5 | XMM6 | XMM2 | XMM0 | XMM7 ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVUPD> uxmreg> try binding mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))) to a register		 	1
  MOVUPD> uxmreg> failed		 	1
  Match pattern COMISSIFGOTO ( label l , sxmreg r1 , sxmreg r2 , fcondition c , int t ) means [ if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l ] assembles [ 'comiss ' r1 ',' r2 '
 j' c ' ' l ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  COMISSIFGOTO> Match if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  Match pattern COMISS ( fcondition c , sxmreg r1 , sxmreg r2 , breg r ) means [ ( ref uint8 ) r := ( uint8 ) c ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'comiss ' r1 ',' r2 '
 set' c ' ' r '
 not ' r '
 inc ' r ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  COMISS> Match ( ref uint8 ) r := ( uint8 ) c ( ^ ( r1 ) , ^ ( r2 ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  COMISS> Match ( ref uint8 ) r  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern OPPI8 ( poperator op , xmreg rm , xmreg r1 ) means [ ( ref int8 vector ( 16 ) ) r1 := op ( ( int8 vector ( 16 ) ) ^ ( r1 ) , ( int8 vector ( 16 ) ) ^ ( rm ) ) ] assembles [ 'p' op 'b  ' rm ',' r1 ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPI8> Match ( ref int8 vector ( 16 ) ) r1 := op ( ( int8 vector ( 16 ) ) ^ ( r1 ) , ( int8 vector ( 16 ) ) ^ ( rm ) )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  OPPI8> Match ( ref int8 vector ( 16 ) ) r1  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern STORUPS ( maddrmode rm , xmreg r1 ) means [ ( ref ieee32 vector ( 4 ) ) rm := ( ieee32 vector ( 4 ) ) ^ ( r1 ) ] assembles [ 'movups  ' r1 ', ' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORUPS> Match ( ref ieee32 vector ( 4 ) ) rm := ( ieee32 vector ( 4 ) ) ^ ( r1 )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  STORUPS> Match ( ref ieee32 vector ( 4 ) ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  Match pattern MOVQS ( maddrmode rm , mreg m ) means [ ( ref doubleword ) rm := ^ ( m ) ] assembles [ 'movq ' m ',' rm ]  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVQS> Match ( ref doubleword ) rm := ^ ( m )  to assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 	1
  MOVQS> Match ( ref doubleword ) rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVQS> Match rm  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVQS> Match pattern maddrmode ( addrform f ) means [ mem ( f ) ] assembles [ f ]  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVQS> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVQS> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)))		 	1
  MOVQS> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false-> null 		 	1
  MOVQS> maddrmode>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955false0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> Match ( t ) f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> bind actualtype int32to param 1=int32		 	1
  MOVQS> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> Match  alternatives format   to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> Match check type equality with int32 actually is int32 true to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> Match f  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> directf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> udirectf> Match const s  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> labelconstf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> labelconstf>  try to commute arguments 		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> labelconstf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> scaledIndexPlusOffsetf>  try to commute arguments 		 	1
  MOVQS> maddrmode> eaform> scaledIndexPlusOffsetf> Match * ( ^ ( r1 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> barelab> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match off  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> L6int32h2149911365540569994true-> alternative     0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0L6int32h2149911365540569994true0 switchvar 0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match const s  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  try to commute arguments 		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match ^ ( r1 )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match r1  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> value type int32		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( off , * ( ^ ( r2 ) , s ) )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> %eax:0		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Unreserve %eax		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2>  try to commute arguments 		 	1
  MOVQS> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match * ( ^ ( r2 ) , s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match r  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type ref int32		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true-> null 		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf>  failvar= 1+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h2149911365540569994true0 switchvar 0		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf>  try to commute arguments 		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match l  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match pattern barelab ( label l ) means [ l ] assembles [ l ]  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> Match l  to     6		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> barelab> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf>  try to commute arguments 		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match ^ ( r )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match r  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match pattern reg means [ ireg | ureg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> Match pattern ireg means [ indexreg ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg>  failvar= 0+int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32)h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> try binding +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to a register		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> value type int32		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> register type ref int32		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into register +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> load into %eax		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  forcederef +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6) to int32		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> Match type compatible with int32 to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  is word == word		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> assign check returns true		 	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )		 	2
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)),
  )
 has local=false		 	2
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg>   exact match found for assign(%eax,+(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	2
  MOVQS> maddrmode> eaform> baseplusoffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> ^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true-> null 		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf>  failvar= 1^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h2149911365540569994true0 switchvar 0		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> constf> Match const s  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> constf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> barelab> Match l  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> barelab> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> Match + ( l , const s )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> labelconstf> rollBackReservations to 1		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 0		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> %eax:0		 %eadx	1
  MOVQS> maddrmode> eaform> baseplusoffsetf> Unreserve %eax		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to +(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r1 )  to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r1  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern reg means [ ireg | ureg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> Match pattern ireg means [ indexreg ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true-> null 		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg>  failvar= 0M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32h-3204915108055699955true0 switchvar 0		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to mem(ref int32,+((int32)^(%ebp),     8))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> try binding mem(ref int32,+((int32)^(%ebp),     8)) to a register		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> value type ref int32		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> register type ref int32		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into register ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> load into %eax		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  forcederef ^(mem(ref int32,+((int32)^(%ebp),     8))) to int32		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> Match type compatible with int32 to ^(mem(ref int32,+((int32)^(%ebp),     8)))		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> type int32 -> format word		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  is word == word		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> assign check returns true		 	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )		 	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8)))),
  )
 has local=false		 	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg>   exact match found for assign(%eax,^(mem(ref int32,+((int32)^(%ebp),     8))))		 	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> ireg> indexreg> reserve register at depth 1,%eax		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r2 ) , off )  to +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6)		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match ^ ( r2 )  to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match r2  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern nsreg means [ EDI | ESI | EBX | EBP | EAX | EDX | ECX ]  to mem(ref int32,+(^((ref int32)%ebp),     -8))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> try binding mem(ref int32,+(^((ref int32)%ebp),     -8)) to a register		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> value type ref int32		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> register type ref int32		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> check assign compatibility of ref int32and int32
 is a ref =true
 is assignable =true		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> load into register ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> load into %edi		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>  forcederef ^(mem(ref int32,+(^((ref int32)%ebp),     -8))) to int32		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match type compatible with int32 to ^(mem(ref int32,+(^((ref int32)%ebp),     -8)))		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> type int32 -> format word		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>  is word == word		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> assign check returns true		 %eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>  unoptimisedcodegen seq(
  assign((ref int32)%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )		 %eadx	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>  cgstatement optlevel=0:seq(
  assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8)))),
  )
 has local=false		 %eadx	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>   exact match found for assign(%edi,^(mem(ref int32,+(^((ref int32)%ebp),     -8))))		 %eadx	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>   rollBackReservations to 1		 %eadx	2
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> reserve register at depth 2,%edi		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match off  to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> Match pattern offset means [ constf | barelab | labelconstf ]  to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> L6int32h-5738444977846951095true-> alternative     0		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf>  failvar= 0L6int32h-5738444977846951095true0 switchvar 0		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match const s  to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match pattern signed means [ int8 | int16 | int32 ]  to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match  alternatives format   to     6		 %edi%eadx	1
  MOVQS> maddrmode> eaform> basePlusIndexPlusOffsetf> constf> Match check type equality with int8 actually is int32 true to     6		 %edi%eadx	1
  MOVQS> Match ^ ( m )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  MOVQS> Match ^ ( m )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  MOVQS> Match m  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	1
  MOVQS> Match pattern mreg means [ im4reg | untypedmreg | im8reg | im8ureg | im2reg ]  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	1
  MOVQS> M[LABref uint8 vector ( 8 )h-5738444977846951095true-> null 		 %edi%eadx	1
  MOVQS>  failvar= 0M[LABref uint8 vector ( 8 )h-5738444977846951095true0 switchvar 0		 %edi%eadx	1
  MOVQS> im4reg> Match pattern im4reg means [ MM416 | MM316 | MM516 | MM016 | MM116 | MM216 ]  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	1
  MOVQS> im4reg> try binding mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae) to a register		 %edi%eadx	1
  MOVQS> im4reg> value type ref uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im4reg> register type ref int16 vector ( 4 )		 %edi%eadx	1
  MOVQS> im4reg> check assign compatibility of ref int16 vector ( 4 )and uint8 vector ( 8 )
 is a ref =true
 is assignable =false		 %edi%eadx	1
  MOVQS> im4reg> failed		 %edi%eadx	1
  MOVQS> im4reg> rollBackReservations to 2		 %edi%eadx	1
  MOVQS> untypedmreg> Match pattern untypedmreg means [ MM1 | MM3 | MM4 | MM5 | MM2 | MM0 | MM7 | MM6 ]  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	1
  MOVQS> untypedmreg> try binding mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae) to a register		 %edi%eadx	1
  MOVQS> untypedmreg> value type ref uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> untypedmreg> register type ref doubleword		 %edi%eadx	1
  MOVQS> untypedmreg> check assign compatibility of ref doublewordand uint8 vector ( 8 )
 is a ref =true
 is assignable =false		 %edi%eadx	1
  MOVQS> untypedmreg> failed		 %edi%eadx	1
  MOVQS> untypedmreg> rollBackReservations to 2		 %edi%eadx	1
  MOVQS> im8reg> Match pattern im8reg means [ MM48 | MM38 | MM58 | MM08 | MM18 | MM28 ]  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	1
  MOVQS> im8reg> try binding mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae) to a register		 %edi%eadx	1
  MOVQS> im8reg> value type ref uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8reg> register type ref int8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8reg> check assign compatibility of ref int8 vector ( 8 )and uint8 vector ( 8 )
 is a ref =true
 is assignable =false		 %edi%eadx	1
  MOVQS> im8reg> failed		 %edi%eadx	1
  MOVQS> im8reg> rollBackReservations to 2		 %edi%eadx	1
  MOVQS> im8ureg> Match pattern im8ureg means [ MM48u | MM38u | MM58u | MM08u | MM18u | MM28u ]  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	1
  MOVQS> im8ureg> try binding mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae) to a register		 %edi%eadx	1
  MOVQS> im8ureg> value type ref uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8ureg> register type ref uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8ureg> check assign compatibility of ref uint8 vector ( 8 )and uint8 vector ( 8 )
 is a ref =true
 is assignable =true		 %edi%eadx	1
  MOVQS> im8ureg>  assignment compatible ref uint8 vector ( 8 ) uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8ureg> load into register ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  MOVQS> im8ureg> load into %MM4		 %edi%eadx	1
  MOVQS> im8ureg>  forcederef ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)) to uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8ureg> type uint8 vector ( 8 ) -> format uint8 vector ( 8 )		 %edi%eadx	1
  MOVQS> im8ureg> Match type compatible with uint8 vector ( 8 ) to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	1
  MOVQS> im8ureg> assign check returns true		 %edi%eadx	1
  MOVQS> im8ureg>  unoptimisedcodegen seq(
  assign((ref uint8 vector ( 8 ))%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))),
  )		 %edi%eadx	2
  MOVQS> im8ureg>  cgstatement optlevel=0:seq(
  assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))),
  )
 has local=false		 %edi%eadx	2
  MOVQS> im8ureg>    sub exp optimise assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	2
  MOVQS> im8ureg>   unoptimisedcodegen assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	2
  MOVQS> im8ureg>   in still free want length 64 for ref uint8 vector ( 8 )		 %edi%eadx	2
  MOVQS> im8ureg>   in still free want length 32 for ref int32		 %edi%eadx	2
  MOVQS> im8ureg>   in split src weight=1 dest weight=0 sf = 5intlimit=9 scharlen=50 charlimit=2000		 %edi%eadx	2
  MOVQS> im8ureg>   splitsrc=false splitwhole=false		 %edi%eadx	2
  MOVQS> im8ureg>     match in unoptimised codegen assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	2
  MOVQS> im8ureg>   %MM4ref uint8 vector ( 8 ):=^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[LABref uint8 vector ( 8 )h-5738444977846951095true-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFLITGOTO> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BIFLITGOTO> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFIN> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFGOTO> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFGOTOB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFGOTOW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FIFGOTOgeneral> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match ( ref t ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOAD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match ( ref t ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match ( ref t ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   LOADW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg>  record failure pattern ireg means [ indexreg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB>  record failure pattern reg means [ ireg | ureg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXB2> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW>  record failure pattern wreg means [ swreg | uwreg | untypedwreg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZBW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSBW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXBW> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXBW> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXBW> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVZXBW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXBW> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXBW> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXBW> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSXBW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   CLEARREG> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> maddrmode> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg>  record failure pattern breg means [ bireg | bureg | boreg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg>  record failure pattern anyreg means [ breg | wreg | reg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> anyreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT>  record failure pattern addrmode means [ maddrmode | anyreg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   STORELIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern LEA ( reg r1 , leaform ea ) means [ r1 := ea ] assembles [ 'lea ' ea ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> Match r1 := ea  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   LEA>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   LEA> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern INC ( addrmode rm , int t ) means [ ( ref t ) rm := + ( ^ ( rm ) , 1 ) ] assembles [ 'inc' t ' ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match ( ref t ) rm := + ( ^ ( rm ) , 1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   INC> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RMLIT ( nonmultoperator op , addrmode rm , type t , offset sm ) means [ ( ref t ) rm := op ( ^ ( rm ) , ( t ) sm ) ] assembles [ op t '  $' sm ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> Match ( ref t ) rm := op ( ^ ( rm ) , ( t ) sm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> maddrmode> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> anyreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMLIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RMR ( nonmultoperator op , addrmode rm , anyreg r1 , wordupto32 t ) means [ ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ op t ' ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> Match ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> Match pattern wordupto32 means [ byte | word16 | word32 ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMR>  failvar= 0^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMR>  record failure pattern wordupto32 means [ byte | word16 | word32 ] ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern DEC ( addrmode rm , int t ) means [ ( ref t ) rm := - ( ( t ) ^ ( rm ) , 1 ) ] assembles [ 'dec' t ' ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match ( ref t ) rm := - ( ( t ) ^ ( rm ) , 1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match pattern int means [ int8 | int16 | int32 | uint32 | uint8 | uint16 ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   DEC> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IMULLIT ( pushreg r1 , addrmode rm , signed s ) means [ ( ref int32 ) r1 := * ( ^ ( rm ) , const s ) ] assembles [ 'imull $' s ', ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IMULLIT> Match ( ref int32 ) r1 := * ( ^ ( rm ) , const s )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IMULLIT> Match ( ref int32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   IMULLIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BIMUL ( baccreg r1 , bnonacreg r2 ) means [ r2 := * ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) ) ] assembles [ 'imul ' r2 '
 movb %al,' r2 ' ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BIMUL> Match r2 := * ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BIMUL> Match r2  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIMUL> Match pattern bnonacreg means [ DH | DL | BH | BL | CH | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIMUL> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   BIMUL> failed		 %edi%eadx	3
  MOVQS> im8ureg>   BIMUL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RLIT ( operator op , pushreg r0 , type t , signed sm ) means [ r0 := ( t ) op ( ^ ( r0 ) , const sm ) ] assembles [ op t '   $' sm ',' r0 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> Match r0 := ( t ) op ( ^ ( r0 ) , const sm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> Match r0  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> Match pattern pushreg means [ reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT>  record failure pattern pushreg means [ reg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   RLIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RRM ( operator op , pushreg r1 , maddrmode rm , int t ) means [ r1 := ( t ) op ( ( t ) ^ ( r1 ) , ( t ) ^ ( rm ) ) ] assembles [ op t ' ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> Match r1 := ( t ) op ( ( t ) ^ ( r1 ) , ( t ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> Match pattern pushreg means [ reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RRM>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRM> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RMRB ( nonmultoperator op , addrmode rm , breg r1 , byte t ) means [ ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ op t ' ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RMR ( nonmultoperator op , addrmode rm , anyreg r1 , wordupto32 t ) means [ ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ op t ' ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> Match ( ref t ) rm := op ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> Match pattern wordupto32 means [ byte | word16 | word32 ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMR>  failvar= 1^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> byte> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word16> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> word32> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RMRAdd ( addrmode rm , anyreg r1 , wordupto32 t ) means [ ( ref t ) rm := + ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) ) ] assembles [ 'add' t ' ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> Match ( ref t ) rm := + ( ( t ) ^ ( rm ) , ( t ) ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> Match pattern wordupto32 means [ byte | word16 | word32 ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> ^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd>  failvar= 1^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match check type equality with uint8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> Match check type equality with octet actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> byte> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word16> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> word32> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RMRAdd> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RRint32 ( operator op , reg r1 , reg r2 ) means [ r1 := ( int32 ) op ( ( int32 ) ^ ( r1 ) , ( int32 ) ^ ( r2 ) ) ] assembles [ op 'l ' r2 ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> Match r1 := ( int32 ) op ( ( int32 ) ^ ( r1 ) , ( int32 ) ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RRint32> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RR ( nonmultoperator op , anyreg r1 , anyreg r2 , int t ) means [ r1 := ( t ) op ( ( t ) ^ ( ( ref t ) r1 ) , ( t ) ^ ( ( ref t ) r2 ) ) ] assembles [ op t ' ' r2 ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RR> Match r1 := ( t ) op ( ( t ) ^ ( ( ref t ) r1 ) , ( t ) ^ ( ( ref t ) r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RR> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RR>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IDIV ( acc r1 , qacc r2 , indexreg r3 ) means [ r1 := div ( ^ ( r2 ) , ^ ( r3 ) ) ] assembles [ 'idiv ' r3 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IDIV> Match r1 := div ( ^ ( r2 ) , ^ ( r3 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IDIV> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   IDIV> Match pattern acc means [ EAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   IDIV> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   IDIV> failed		 %edi%eadx	3
  MOVQS> im8ureg>   IDIV> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern fastBIDIV ( baccreg r1 , bnonacregmode r2 ) means [ r1 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) ) ] assembles [ ' movsbw ' r1 ',%ax
 idiv  ' r2 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   fastBIDIV> Match r1 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   fastBIDIV> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   fastBIDIV> Match pattern baccreg means [ AL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   fastBIDIV> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   fastBIDIV> failed		 %edi%eadx	3
  MOVQS> im8ureg>   fastBIDIV> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BIDIV ( baccreg r1 , bnonacregmode r2 , baccregmode r3 ) means [ r3 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) ) ] assembles [ ' movsbw ' r1 ',%ax
 idiv  ' r2 '
 mov  %al,' r3 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> Match r3 := div ( ( int8 ) ^ ( r1 ) , ( int8 ) ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> Match r3  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> Match pattern baccregmode means [ maddrmode | baccreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> maddrmode> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> baccreg> Match pattern baccreg means [ AL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> baccreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> baccreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> baccreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV>  record failure pattern baccregmode means [ maddrmode | baccreg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   BIDIV> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern UDIV ( acc r1 , modreg r2 ) means [ PUSH ( mainSTACK , div ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) ) ] assembles [ 'pushl %edx
 xor %edx,%edx
 div   ' r2 '
 xchg (%esp),%eax
 xchg %eax,%edx' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UDIV> Match PUSH ( mainSTACK , div ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UDIV> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IDIVold ( nonaccreg r2 ) means [ PUSH ( mainSTACK , ( int32 ) div ( ( int32 ) POP ( mainSTACK ) , ( int32 ) ^ ( r2 ) ) ) ] assembles [ ' xchg %eax,(%esp)
 pushl %edx
' ' cltd
' ' idiv   ' r2 '
' ' popl %edx
' ' xchg %eax,(%esp)

 ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IDIVold> Match PUSH ( mainSTACK , ( int32 ) div ( ( int32 ) POP ( mainSTACK ) , ( int32 ) ^ ( r2 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IDIVold> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IMOD ( acc r1 , modreg r2 ) means [ PUSH ( mainSTACK , MOD ( ( int32 ) ^ ( r1 ) , ^ ( r2 ) ) ) ] assembles [ 'pushl %edx
 cltd
 idiv   ' r2 '
 xchgl %edx,(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IMOD> Match PUSH ( mainSTACK , MOD ( ( int32 ) ^ ( r1 ) , ^ ( r2 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IMOD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern UMOD ( acc r1 , modreg r2 ) means [ PUSH ( mainSTACK , MOD ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) ) ] assembles [ 'pushl %edx
 xor %edx,%edx
 div   ' r2 '
 xchgl %edx,(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UMOD> Match PUSH ( mainSTACK , MOD ( ( uint32 ) ^ ( r1 ) , ^ ( r2 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UMOD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern CDQ ( qacc r1 , acc r2 ) means [ r1 := EXTEND ( ^ ( r2 ) ) ] assembles [ 'cdq' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CDQ> Match r1 := EXTEND ( ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CDQ> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CDQ> Match pattern qacc means [ EADX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CDQ> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   CDQ> failed		 %edi%eadx	3
  MOVQS> im8ureg>   CDQ> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern fastIMUL ( acc a , dacc d ) means [ ( ref int32 ) a := * ( ( int32 ) ^ ( a ) , ^ ( d ) ) ] assembles [ 'imul %edx' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   fastIMUL> Match ( ref int32 ) a := * ( ( int32 ) ^ ( a ) , ^ ( d ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   fastIMUL> Match ( ref int32 ) a  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   fastIMUL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern Negate ( anyreg r1 , type t ) means [ ( ref t ) r1 := - ( ( t ) 0 , ( t ) ^ ( r1 ) ) ] assembles [ 'neg' t ' ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> Match ( ref t ) r1 := - ( ( t ) 0 , ( t ) ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> Match ( ref t ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Negate>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Negate> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern NOTOP ( addrmode rm , type t ) means [ ( ref t ) rm := NOT ( ( t ) ^ ( rm ) ) ] assembles [ 'not' t ' ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> Match ( ref t ) rm := NOT ( ( t ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> Match pattern addrmode means [ maddrmode | anyreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> maddrmode> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> anyreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   NOTOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MNegate ( anyreg r1 , type t ) means [ ( ref t ) r1 := * ( ( t ) - 1 , ( t ) ^ ( r1 ) ) ] assembles [ 'neg' t ' ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> Match ( ref t ) r1 := * ( ( t ) - 1 , ( t ) ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> Match ( ref t ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MNegate> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BTS ( reg r1 , reg r2 ) means [ ( ref uint8 ) mem ( r1 ) := OR ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ] assembles [ 'bts ' r2 ',(' r1 ')' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BTS> Match ( ref uint8 ) mem ( r1 ) := OR ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BTS> Match ( ref uint8 ) mem ( r1 )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BTS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern TESTIN ( reg r1 , reg r2 , breg r ) means [ r := <> ( AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) , ( int8 ) 0 ) ] assembles [ 'bt  ' r2 ',(' r1 ')
 setc ' r '
 not ' r '
 inc ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> Match r := <> ( AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) , ( int8 ) 0 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   TESTIN> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SHIFT ( shiftop op , shiftcount s , anyreg r , type t ) means [ ( ref t ) r := ( t ) op ( ^ ( r ) , s ) ] assembles [ 'sh' op ' ' s ', ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> Match ( ref t ) r := ( t ) op ( ^ ( r ) , s )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> Match ( ref t ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> Match pattern anyreg means [ breg | wreg | reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> breg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> swreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> swreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> swreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> uwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> uwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> untypedwreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> untypedwreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> wreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SHIFT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern UINT8MAX ( breg r1 , breg r2 ) means [ ( ref uint8 ) r1 := MAX ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 ja 0f
 mov ' r2 ',' r1 '
0:
' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UINT8MAX> Match ( ref uint8 ) r1 := MAX ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UINT8MAX> Match ( ref uint8 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   UINT8MAX> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern UINT8MIN ( breg r1 , breg r2 ) means [ ( ref uint8 ) r1 := MIN ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 jna 0f
 mov ' r2 ',' r1 '
0:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UINT8MIN> Match ( ref uint8 ) r1 := MIN ( ( uint8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   UINT8MIN> Match ( ref uint8 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   UINT8MIN> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern INT8MAX ( breg r1 , breg r2 ) means [ ( ref int8 ) r1 := MAX ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 jg 0f
 mov ' r2 ',' r1 '
0:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INT8MAX> Match ( ref int8 ) r1 := MAX ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INT8MAX> Match ( ref int8 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INT8MAX> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern INT8MIN ( breg r1 , breg r2 ) means [ ( ref int8 ) r1 := MIN ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r2 ',' r1 '
 jl 0f
 mov ' r2 ',' r1 '
0:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INT8MIN> Match ( ref int8 ) r1 := MIN ( ( int8 ) ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INT8MIN> Match ( ref int8 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INT8MIN> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SELECT ( reg r1 , reg r2 , addrmode r3 , signed t ) means [ ( ref t ) r1 := OR ( AND ( ( t ) ^ ( r1 ) , ( t ) ^ ( r2 ) ) , AND ( ( t ) ^ ( r3 ) , NOT ( ^ ( r2 ) ) ) ) ] assembles [ 'andl ' r2 ',' r1 '
' 'notl ' r1 '
' 'andl ' r3 ',' ' ' r2 '
' 'orl ' r2 ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match ( ref t ) r1 := OR ( AND ( ( t ) ^ ( r1 ) , ( t ) ^ ( r2 ) ) , AND ( ( t ) ^ ( r3 ) , NOT ( ^ ( r2 ) ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match ( ref t ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match pattern signed means [ int8 | int16 | int32 ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match check type equality with int8 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   SELECT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern PLANT ( label l ) means [ l ] assembles [ l ':' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANT> Match l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANT> Match l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern LITPUSH ( offset s ) means [ PUSH ( mainSTACK , s ) ] assembles [ 'pushl $' s ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LITPUSH> Match PUSH ( mainSTACK , s )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   LITPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MEMPUSH ( maddrmode m ) means [ PUSH ( mainSTACK , ( word ) ^ ( m ) ) ] assembles [ 'pushl ' m ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MEMPUSH> Match PUSH ( mainSTACK , ( word ) ^ ( m ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MEMPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SETB ( condition c , bireg r1 , bireg rm , breg r , signed t , byte b ) means [ r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setb
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> Match r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SETB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SETUB ( unsignedcondition c , bureg r1 , regaddrimmediate rm , breg r , unsigned t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setub
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETUB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SETW ( condition c , wreg r1 , wreg rm , breg r , signed t , byte b ) means [ r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setw
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> Match r := ( b ) c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SETW>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SETUW ( unsignedcondition c , uwreg r1 , uwreg rm , breg r , unsigned t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmp' t ' ' rm ',' ' ' r1 '#setuw
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETUW> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SET ( condition c , ireg r1 , ireg rm , breg r , signed t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmpl' ' ' rm ',' ' ' r1 '#set
 set' c ' ' r '
 subb $1 ,' r '
 not ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SET> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SET> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SET> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SET> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SET>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SET> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SET> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SET> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SET> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SET> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SET> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SETU ( unsignedcondition c , ureg r1 , ureg rm , breg r , unsigned t ) means [ r := c ( ( t ) ^ ( r1 ) , ( t ) rm ) ] assembles [ 'cmpl' ' ' rm ',' ' ' r1 '#setu
 set' c ' ' r '
 subb $1, ' r '
 not ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> Match r := c ( ( t ) ^ ( r1 ) , ( t ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SETU>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SETU> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern Tob ( reg r , breg b ) means [ b := ( octet ) ^ ( r ) ] assembles [ 'pushl ' r '
movb (%esp), ' b '
 addl $4,%esp ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> Match b := ( octet ) ^ ( r )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> Match b  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   Tob>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Tob> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern GOTO ( jumpmode l ) means [ goto l ] assembles [ 'jmp ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   GOTO> Match goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   GOTO> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern FAIL ( int i ) means [ interrupt i ] assembles [ 'int $' i ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FAIL> Match interrupt i  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FAIL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BOUND4 ( reg r1 , reg r2 ) means [ if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 8 ) ) ) ) ) ) interrupt 5 ] assembles [ 'bound ' r2 ',4(' r1 ')' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BOUND4> Match if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 8 ) ) ) ) ) ) interrupt 5  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BOUND4> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BOUND0 ( reg r1 , reg r2 ) means [ if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( ^ ( r1 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) ) ) interrupt 5 ] assembles [ 'bound ' r2 ',(' r1 ')' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BOUND0> Match if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( ^ ( r1 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 4 ) ) ) ) ) ) interrupt 5  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BOUND0> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BOUND16 ( reg r1 , reg r2 ) means [ if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 16 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 20 ) ) ) ) ) ) interrupt 5 ] assembles [ 'bound ' r2 ',16(' r1 ')' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BOUND16> Match if ( OR ( < ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 16 ) ) ) ) , > ( ^ ( r2 ) , ^ ( ( ref int32 ) mem ( + ( ^ ( r1 ) , 20 ) ) ) ) ) ) interrupt 5  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BOUND16> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern PLANTICONST ( longint r , type t ) means [ loc ( t ) r ] assembles [ '.long ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTICONST> Match loc ( t ) r  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTICONST> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern PLANTWCONST ( word16 r , type t ) means [ loc ( t ) r ] assembles [ '.short ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTWCONST> Match loc ( t ) r  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTWCONST> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern PLANTBCONST ( byte r , type t ) means [ loc ( t ) r ] assembles [ '.byte ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTBCONST> Match loc ( t ) r  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTBCONST> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern PLANTRCONST ( double r , type t ) means [ loc ( t ) r ] assembles [ '.double ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTRCONST> Match loc ( t ) r  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTRCONST> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern PLANTSCONST ( float r , type t ) means [ loc ( t ) r ] assembles [ '.float ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTSCONST> Match loc ( t ) r  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   PLANTSCONST> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern REPMOVSD ( countreg s , maddrmode m1 , sourcereg si , destreg di ) means [ for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref int32 ) mem ( + ( ^ ( di ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) := ^ ( ( ref int32 ) mem ( + ( ^ ( si ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) ) ] assembles [ ' inc %ecx
 jle 1f
 rep movsl
1:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REPMOVSD> Match for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref int32 ) mem ( + ( ^ ( di ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) := ^ ( ( ref int32 ) mem ( + ( ^ ( si ) , * ( ^ ( ( ref int32 ) m1 ) , 4 ) ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REPMOVSD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern REPMOVSB ( countreg s , maddrmode m1 , sourcereg si , destreg di ) means [ for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref octet ) mem ( + ( ^ ( di ) , ^ ( ( ref int32 ) m1 ) ) ) := ^ ( ( ref octet ) mem ( + ( ^ ( si ) , ^ ( ( ref int32 ) m1 ) ) ) ) ] assembles [ ' inc %ecx
 jle 1f
 rep movsb
1:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REPMOVSB> Match for ( ref int32 ) m1 := 0 to ^ ( s ) step 1 do ( ref octet ) mem ( + ( ^ ( di ) , ^ ( ( ref int32 ) m1 ) ) ) := ^ ( ( ref octet ) mem ( + ( ^ ( si ) , ^ ( ( ref int32 ) m1 ) ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REPMOVSB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern ADDUSB ( addrmode fm , breg r1 , breg rm ) means [ rm := +: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'addb  ' r1 ',' rm '
 jnc 0f
 movb $255, ' rm '
 0:nop
 ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> Match rm := +: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   ADDUSB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SUBUSB ( breg r1 , breg rm ) means [ rm := -: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'subb  ' r1 ',' rm '
 jnc 0f
 movb $0, ' rm '
 0:nop
 ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> Match rm := -: ( ( uint8 ) ^ ( rm ) , ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SUBUSB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern ADDSSB ( breg r1 , breg rm ) means [ rm := +: ( ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'addb  ' r1 ',' rm '
 jno 0f
 jg 1f
 movb $-128 ,' rm '  
 jng 0f
1:
 movb $127, ' rm '
0:
 ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> Match rm := +: ( ^ ( rm ) , ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSSB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SUBSSB ( addrmode fm , breg r1 , breg rm ) means [ rm := ( int8 ) -: ( ( int8 ) ^ ( rm ) , ^ ( r1 ) ) ] assembles [ 'subb  ' r1 ',' rm '
 jno 0f
 jg 1f
 movb $-128, ' rm '  
 jng 0f
1: movb $127,' rm '
0: nop
 nop' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> Match rm := ( int8 ) -: ( ( int8 ) ^ ( rm ) , ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> Match pattern breg means [ bireg | bureg | boreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bireg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bireg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> bureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> boreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> boreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> boreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SUBSSB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MULTSSB ( bacc r1 , bnonacc r2 ) means [ r2 := *: ( ^ ( r2 ) , ^ ( r1 ) ) ] assembles [ 'imul  ' r2 '
 shr $7,%ax
 movb %al, ' r2 ' ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSB> Match r2 := *: ( ^ ( r2 ) , ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSB> Match r2  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSB> Match pattern bnonacc means [ BL | CL | DL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSB> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSB> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSB> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MULTSSBAL ( bacc r1 , bnonacc r2 ) means [ r1 := *: ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'imul  ' r2 '
 shr  $7,%ax' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSBAL> Match r1 := *: ( ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSBAL> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSBAL> Match pattern bacc means [ AL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSBAL> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSBAL> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MULTSSBAL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STOREWR ( memrisc rm , wreg r1 , word16 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STOREWR' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match ( ref t ) rm := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STORER ( memrisc rm , reg r1 , word32 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STORER' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match ( ref t ) rm := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STOREBR ( maddrmode rm , breg r1 ) means [ ( ref octet ) rm := ^ ( r1 ) ] assembles [ 'movb ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREBR> Match ( ref octet ) rm := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREBR> Match ( ref octet ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STOREBR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern INTMIN ( reg r1 , reg r2 ) means [ r1 := MIN ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r1 ',' r2 '
  cmovl ' r2 ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> Match r1 := MIN ( ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   INTMIN> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern INTMAX ( reg r1 , reg r2 ) means [ r1 := MAX ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'cmp ' r1 ',' r2 '
 cmovg ' r2 ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> Match r1 := MAX ( ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   INTMAX> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern FSET ( fcondition c , breg r , fputype t ) means [ ( ref int8 ) r := ( int8 ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ] assembles [ 'fxch' '
  fucompp' '
 pushw %ax' '
 fnstsw %ax' '
 sahf' '
 popw %ax' '
 set' c ' ' r '
 not ' r '
 inc ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FSET> Match ( ref int8 ) r := ( int8 ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FSET> Match ( ref int8 ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FSET> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STORESS ( smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) rm := ( ieee32 ) ^ ( r1 ) ] assembles [ 'movss  ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORESS> Match ( ref ieee32 ) rm := ( ieee32 ) ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORESS> Match ( ref ieee32 ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORESS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern COMISSIFGOTO ( label l , sxmreg r1 , sxmreg r2 , fcondition c , int t ) means [ if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l ] assembles [ 'comiss ' r1 ',' r2 '
 j' c ' ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   COMISSIFGOTO> Match if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   COMISSIFGOTO> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RPUSH ( pushreg r ) means [ PUSH ( mainSTACK , ^ ( r ) ) ] assembles [ 'pushl ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RPUSH> Match PUSH ( mainSTACK , ^ ( r ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern REFPUSH ( maddrmode m , type t ) means [ PUSH ( mainSTACK , ( ref t ) ^ ( m ) ) ] assembles [ 'push l ' m ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REFPUSH> Match PUSH ( mainSTACK , ( ref t ) ^ ( m ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REFPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SDEREF ( int t ) means [ PUSH ( mainSTACK , ( t ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) ) ] assembles [ 'xchgl %esi,(%esp)
 movl (%esi),%esi
  xchgl %esi,(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SDEREF> Match PUSH ( mainSTACK , ( t ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SDEREF> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SDEREFDOUBLEw ( int t ) means [ PUSH ( mainSTACK , ( doubleword ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) ) ] assembles [ 'xchgl %esi,(%esp)
 pushl (%esi)
 movl  4(%esi),%esi
  xchgl %esi,4(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SDEREFDOUBLEw> Match PUSH ( mainSTACK , ( doubleword ) ^ ( mem ( ( word ) POP ( mainSTACK ) ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SDEREFDOUBLEw> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern IFBOOL ( label l , breg r1 ) means [ if ( ( int8 ) ^ ( r1 ) ) goto l ] assembles [ 'test ' r1 ',' r1 '
 jnz ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFBOOL> Match if ( ( int8 ) ^ ( r1 ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   IFBOOL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SMLIT ( nonmultoperator op , offset s ) means [ PUSH ( mainSTACK , ( int32 ) op ( ( int32 ) POP ( mainSTACK ) , s ) ) ] assembles [ op 'l  $' s ',(%esp) ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMLIT> Match PUSH ( mainSTACK , ( int32 ) op ( ( int32 ) POP ( mainSTACK ) , s ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMLIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SMRP ( nonmultoperator op , reg r1 , type t ) means [ PUSH ( mainSTACK , ( ref t ) op ( ( word ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ op 'l ' r1 ',(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMRP> Match PUSH ( mainSTACK , ( ref t ) op ( ( word ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMRP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SADD ( saddoperator op ) means [ PUSH ( mainSTACK , ( longint ) + ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) ) ] assembles [ 'xchgl %eax,(%esp)
 addl %eax, 4(%esp)
 popl %eax' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SADD> Match PUSH ( mainSTACK , ( longint ) + ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SADD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SMULIT ( nonmultoperator op , offset s ) means [ PUSH ( mainSTACK , ( int32 ) * ( ( int32 ) POP ( mainSTACK ) , s ) ) ] assembles [ 'xchgl %eax,(%esp)
 imul  $' s ',%eax
 xchgl %eax,(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMULIT> Match PUSH ( mainSTACK , ( int32 ) * ( ( int32 ) POP ( mainSTACK ) , s ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMULIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SMRADD ( reg r1 ) means [ r1 := ( int32 ) + ( ( int32 ) POP ( mainSTACK ) , ^ ( r1 ) ) ] assembles [ 'addl (%esp), ' r1 ' 
 addl $4, %esp' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> Match r1 := ( int32 ) + ( ( int32 ) POP ( mainSTACK ) , ^ ( r1 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> Match r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   SMRADD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SOP ( saddoperator op ) means [ PUSH ( mainSTACK , ( longint ) op ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) ) ] assembles [ 'xchgl %eax,(%esp)
 ' op 'l  4(%esp),%eax
 movl %eax,4(%esp)
 popl %eax' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SOP> Match PUSH ( mainSTACK , ( longint ) op ( ( longint ) POP ( mainSTACK ) , ( longint ) POP ( mainSTACK ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SMR ( nonmultoperator op , reg r1 ) means [ PUSH ( mainSTACK , ( int32 ) op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ op 'l ' r1 ',(%esp) ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMR> Match PUSH ( mainSTACK , ( int32 ) op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BSMR ( nonmultoperator op , breg r1 ) means [ PUSH ( mainSTACK , ( octet ) op ( ( octet ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ op 'b ' r1 ',(%esp) ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BSMR> Match PUSH ( mainSTACK , ( octet ) op ( ( octet ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BSMR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STOREWR ( memrisc rm , wreg r1 , word16 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STOREWR' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match ( ref t ) rm := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match check type equality with int16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match check type equality with uint16 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> Match check type equality with halfword actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STOREWR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STORER ( memrisc rm , reg r1 , word32 t ) means [ ( ref t ) rm := ^ ( r1 ) ] assembles [ 'mov' t ' ' r1 ',' rm '#STORER' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match ( ref t ) rm := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match ( ref t ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match check type equality with int32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match check type equality with uint32 actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match  alternatives format   to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> Match check type equality with word actually is uint8 vector ( 8 ) false to ^(%MM4)		 %edi%eadx	3
  MOVQS> im8ureg>   STORER> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STOREBR ( maddrmode rm , breg r1 ) means [ ( ref octet ) rm := ^ ( r1 ) ] assembles [ 'movb ' r1 ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREBR> Match ( ref octet ) rm := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STOREBR> Match ( ref octet ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STOREBR> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern REFPOP ( addrmode r , type t , type t2 ) means [ ( ref ref t ) r := ( ref t2 ) POP ( mainSTACK ) ] assembles [ 'popl ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REFPOP> Match ( ref ref t ) r := ( ref t2 ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REFPOP> Match ( ref ref t ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   REFPOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern REFPOP2 ( addrmode r , type t ) means [ ( ref ref t ) r := ( word ) POP ( mainSTACK ) ] assembles [ 'popl ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REFPOP2> Match ( ref ref t ) r := ( word ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   REFPOP2> Match ( ref ref t ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   REFPOP2> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MEMPOP ( maddrmode m ) means [ ( ref int32 ) m := ( int32 ) POP ( mainSTACK ) ] assembles [ 'popl ' m ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MEMPOP> Match ( ref int32 ) m := ( int32 ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MEMPOP> Match ( ref int32 ) m  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MEMPOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BPOP ( bureg r ) means [ r := ( octet ) POP ( mainSTACK ) ] assembles [ 'movb (%esp),  ' r '
 add $4,%esp' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BPOP> Match r := ( octet ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BPOP> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BPOP> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BPOP> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   BPOP> failed		 %edi%eadx	3
  MOVQS> im8ureg>   BPOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BSPOP ( bireg r ) means [ r := ( int8 ) POP ( mainSTACK ) ] assembles [ 'movb (%esp),  ' r '
 addl $4,%esp' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BSPOP> Match r := ( int8 ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BSPOP> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BSPOP> Match pattern bireg means [ BL | DL | AL | CL ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   BSPOP> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   BSPOP> failed		 %edi%eadx	3
  MOVQS> im8ureg>   BSPOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BSPUSH ( baddrmode r ) means [ PUSH ( mainSTACK , ( int8 ) ^ ( r ) ) ] assembles [ 'pushl %esi
 movsbl ' r ',%esi
 xchgl %esi,(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BSPUSH> Match PUSH ( mainSTACK , ( int8 ) ^ ( r ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BSPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern DMEMPUSH ( regindirf ea ) means [ PUSH ( mainSTACK , ( doubleword ) ^ ( ( ref doubleword ) mem ( ea ) ) ) ] assembles [ 'pushl  4' ea '
 pushl ' ea ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   DMEMPUSH> Match PUSH ( mainSTACK , ( doubleword ) ^ ( ( ref doubleword ) mem ( ea ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   DMEMPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RPUSHE ( ureg r ) means [ PUSH ( mainSTACK , ( int64 ) EXTEND ( ^ ( r ) ) ) ] assembles [ ' pushl $0 # extend ' r ' to 64' '
 pushl ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RPUSHE> Match PUSH ( mainSTACK , ( int64 ) EXTEND ( ^ ( r ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RPUSHE> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern BPUSH ( bureg r ) means [ PUSH ( mainSTACK , ^ ( r ) ) ] assembles [ 'pushl $0
 movb ' r ',(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BPUSH> Match PUSH ( mainSTACK , ^ ( r ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   BPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STACKSTORE ( reg r1 ) means [ ( ref int32 ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 ) ] assembles [ 'xchgl (%esp),' r1 '
  popl (' r1 ')
   ' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STACKSTORE> Match ( ref int32 ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STACKSTORE> Match ( ref int32 ) mem ( ( int32 ) POP ( mainSTACK ) )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STACKSTORE> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STACKWSTORE ( wreg r1 ) means [ ( ref halfword ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 ) ] assembles [ 'xchgl (%esp),%esi
  movw ' r1 ',(%esi)' '
  popl %esi' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STACKWSTORE> Match ( ref halfword ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STACKWSTORE> Match ( ref halfword ) mem ( ( int32 ) POP ( mainSTACK ) )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STACKWSTORE> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STACKBSTORE ( breg r1 ) means [ ( ref octet ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 ) ] assembles [ 'xchgl (%esp),%esi
  movb ' r1 ',(%esi)' '
  popl %esi' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STACKBSTORE> Match ( ref octet ) mem ( ( int32 ) POP ( mainSTACK ) ) := ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STACKBSTORE> Match ( ref octet ) mem ( ( int32 ) POP ( mainSTACK ) )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STACKBSTORE> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern RPOP ( pushreg r , type t ) means [ ( ref t ) r := ( t ) POP ( mainSTACK ) ] assembles [ 'popl  ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> Match ( ref t ) r := ( t ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> Match ( ref t ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> Match pattern pushreg means [ reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> Match pattern reg means [ ireg | ureg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> Match pattern ireg means [ indexreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> indexreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> indexreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> indexreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ireg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ureg> Match pattern ureg means [ EBP | ubx | udi | usi | udx | ESP | ucx | uax ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ureg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ureg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> ureg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> reg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   RPOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SMRSHIFT ( shiftop op , shiftcountreg r1 ) means [ PUSH ( mainSTACK , op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) ) ] assembles [ 'xchgl %eax, (%esp)
' 'sh' op 'l  %cl,%eax ' '
 xchgl %eax,(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMRSHIFT> Match PUSH ( mainSTACK , op ( ( longint ) POP ( mainSTACK ) , ^ ( r1 ) ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SMRSHIFT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern OPPDADD ( soperator op , xmreg rm , xmreg r1 ) means [ ( ref ieee64 vector ( 2 ) ) r1 := + ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) ) ] assembles [ 'addpd  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPDADD> Match ( ref ieee64 vector ( 2 ) ) r1 := + ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPDADD> Match ( ref ieee64 vector ( 2 ) ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   OPPDADD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVDQL ( maddrmode rm , xmreg r1 ) means [ ( ref quadword ) r1 := ^ ( rm ) ] assembles [ 'movdqu ' rm ',' r1 '#MOVQDL
 prefetcht0 128+' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVDQL> Match ( ref quadword ) r1 := ^ ( rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVDQL> Match ( ref quadword ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVDQL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern OPSS ( soperator op , smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := op ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) ) ] assembles [ op 'ss  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPSS> Match ( ref ieee32 ) r1 := op ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPSS> Match ( ref ieee32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   OPSS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern OPSD ( soperator op , xmmr64m rm , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := op ( ( ieee64 ) ^ ( r1 ) , ( ieee64 ) ^ ( rm ) ) ] assembles [ op 'sd  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPSD> Match ( ref ieee64 ) r1 := op ( ( ieee64 ) ^ ( r1 ) , ( ieee64 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPSD> Match ( ref ieee64 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   OPSD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern ADDSS ( smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := + ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) ) ] assembles [ 'addss  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSS> Match ( ref ieee32 ) r1 := + ( ( ieee32 ) ^ ( r1 ) , ( ieee32 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSS> Match ( ref ieee32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   ADDSS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern CVTSI2SD ( reg rm , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := ( ieee64 ) FLOAT ( ( int32 ) ^ ( rm ) ) ] assembles [ 'cvtsi2sd  ' rm ', ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSI2SD> Match ( ref ieee64 ) r1 := ( ieee64 ) FLOAT ( ( int32 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSI2SD> Match ( ref ieee64 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSI2SD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern CVTSI2SS ( maddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) rm ) ) ] assembles [ 'cvtsi2ss  ' rm ', ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSI2SS> Match ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSI2SS> Match ( ref ieee32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSI2SS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern CVTSD2SI ( xmmr64m rm , reg r1 ) means [ ( ref int32 ) r1 := ( int32 ) ROUND ( ( ieee64 ) ^ ( rm ) ) ] assembles [ 'cvtsd2si  ' rm ', ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSD2SI> Match ( ref int32 ) r1 := ( int32 ) ROUND ( ( ieee64 ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSD2SI> Match ( ref int32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CVTSD2SI> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern CVTIR2SS ( reg r0 , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) r0 ) ) ] assembles [ 'cvtsi2ss  ' r0 ', ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTIR2SS> Match ( ref ieee32 ) r1 := ( ieee32 ) FLOAT ( ^ ( ( ref int32 ) r0 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   CVTIR2SS> Match ( ref ieee32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   CVTIR2SS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern XRLOADLIT ( float f , float t , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ( t ) const f ] assembles [ 'movss 0f,' r1 '
 jmp 1f' ' 
 0:
.float ' f '
 1:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   XRLOADLIT> Match ( ref ieee32 ) r1 := ( t ) const f  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   XRLOADLIT> Match ( ref ieee32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   XRLOADLIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern XRDLOADLIT ( real f , real t , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := ( t ) const f ] assembles [ 'movsd 0f,' r1 '
 jmp 1f' ' 
0:
.double ' f '
1:' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   XRDLOADLIT> Match ( ref ieee64 ) r1 := ( t ) const f  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   XRDLOADLIT> Match ( ref ieee64 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   XRDLOADLIT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVSS ( smaddrmode rm , sxmreg r1 ) means [ ( ref ieee32 ) r1 := ^ ( ( ref ieee32 ) rm ) ] assembles [ 'movss  ' rm ', ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSS> Match ( ref ieee32 ) r1 := ^ ( ( ref ieee32 ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSS> Match ( ref ieee32 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVSD ( xmmr64m rm , xmmr64 r1 ) means [ ( ref ieee64 ) r1 := ^ ( ( ref ieee64 ) rm ) ] assembles [ 'movsd  ' rm ', ' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSD> Match ( ref ieee64 ) r1 := ^ ( ( ref ieee64 ) rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSD> Match ( ref ieee64 ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVSD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SSRPUSH ( sxmreg r ) means [ PUSH ( mainSTACK , ^ ( r ) ) ] assembles [ 'subl $4,%esp
 movss ' r ',(%esp)' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPUSH> Match PUSH ( mainSTACK , ^ ( r ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPUSH> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SSRPOPI ( sxmreg r ) means [ ( ref ieee32 ) r := ( ieee32 ) FLOAT ( ( int32 ) POP ( mainSTACK ) ) ] assembles [ ' cvtsi2ss (%esp),' r '
 addl $4,%esp' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPOPI> Match ( ref ieee32 ) r := ( ieee32 ) FLOAT ( ( int32 ) POP ( mainSTACK ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPOPI> Match ( ref ieee32 ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPOPI> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SSRPOP ( sxmreg r ) means [ ( ref ieee32 ) r := ( ieee32 ) POP ( mainSTACK ) ] assembles [ ' movss (%esp),' r '
 addl $4,%esp' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPOP> Match ( ref ieee32 ) r := ( ieee32 ) POP ( mainSTACK )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPOP> Match ( ref ieee32 ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SSRPOP> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern FREP4 ( xmreg m , wreg r ) means [ m := rep ( ^ ( r ) , 4 ) ] assembles [ 'push ' r '
 push ' r '
 push ' r '
 push ' r '
 movups (%esp),' m '
 add $16,%esp' ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> Match m := rep ( ^ ( r ) , 4 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> Match m  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> Match pattern xmreg means [ psxmreg | pdxmreg | xmregi324 | xmreg8 | xmreg16 | uxmreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> psxmreg> Match pattern psxmreg means [ XMM7R324 | XMM6R324 | XMM5R324 | XMM4R324 | XMM3R324 | XMM2R324 | XMM1R324 | XMM0R324 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> psxmreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> psxmreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> psxmreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> pdxmreg> Match pattern pdxmreg means [ XMM7R642 | XMM6R642 | XMM5R642 | XMM4R642 | XMM3R642 | XMM2R642 | XMM1R642 | XMM0R642 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> pdxmreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> pdxmreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> pdxmreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmregi324> Match pattern xmregi324 means [ XMM0I324 | XMM3I324 | XMM2I324 | XMM1I324 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmregi324> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmregi324> failed		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmregi324> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg8> Match pattern xmreg8 means [ XMM0I8 | XMM3I8 | XMM1I8 | XMM2I8 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg8> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg8> failed		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg8> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg16> Match pattern xmreg16 means [ XMM0I16 | XMM3I16 | XMM1I16 | XMM2I16 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg16> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg16> failed		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> xmreg16> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> uxmreg> Match pattern uxmreg means [ XMM1 | XMM3 | XMM4 | XMM5 | XMM6 | XMM2 | XMM0 | XMM7 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> uxmreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> uxmreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> uxmreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4>  record failure pattern xmreg means [ psxmreg | pdxmreg | xmregi324 | xmreg8 | xmreg16 | uxmreg ] %MM4ref uint8 vector ( 8 )h-5738444977846951095false0		 %edi%eadx	3
  MOVQS> im8ureg>   FREP4> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SSQRT ( sxmreg r ) means [ r := SQRT ( ^ ( r ) ) ] assembles [ 'sqrtss ' r ',' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSQRT> Match r := SQRT ( ^ ( r ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SSQRT> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SSQRT> Match pattern sxmreg means [ XMM00 | XMM10 | XMM20 | XMM30 | XMM40 | XMM50 | XMM60 | XMM70 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SSQRT> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SSQRT> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SSQRT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern SDSQRT ( xmmr64 r ) means [ r := SQRT ( ^ ( r ) ) ] assembles [ 'sqrtsd ' r ',' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SDSQRT> Match r := SQRT ( ^ ( r ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   SDSQRT> Match r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SDSQRT> Match pattern xmmr64 means [ XMM0R64 | XMM1R64 | XMM2R64 | XMM3R64 | XMM4R64 | XMM5R64 | XMM6R64 | XMM7R64 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   SDSQRT> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   SDSQRT> failed		 %edi%eadx	3
  MOVQS> im8ureg>   SDSQRT> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern OPPS ( soperator op , xmreg rm , xmreg r1 ) means [ ( ref ieee32 vector ( 4 ) ) r1 := op ( ( ieee32 vector ( 4 ) ) ^ ( r1 ) , ( ieee32 vector ( 4 ) ) ^ ( rm ) ) ] assembles [ op 'ps  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPS> Match ( ref ieee32 vector ( 4 ) ) r1 := op ( ( ieee32 vector ( 4 ) ) ^ ( r1 ) , ( ieee32 vector ( 4 ) ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPS> Match ( ref ieee32 vector ( 4 ) ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   OPPS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern OPPD ( soperator op , xmreg rm , xmreg r1 ) means [ ( ref ieee64 vector ( 2 ) ) r1 := op ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) ) ] assembles [ op 'pd  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPD> Match ( ref ieee64 vector ( 2 ) ) r1 := op ( ( ieee64 vector ( 2 ) ) ^ ( r1 ) , ( ieee64 vector ( 2 ) ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPD> Match ( ref ieee64 vector ( 2 ) ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   OPPD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STORUPD ( smaddrmode rm , xmreg r1 ) means [ ( ref ieee64 vector ( 2 ) ) rm := ( ieee64 vector ( 2 ) ) ^ ( r1 ) ] assembles [ 'movupd  ' r1 ', ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORUPD> Match ( ref ieee64 vector ( 2 ) ) rm := ( ieee64 vector ( 2 ) ) ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORUPD> Match ( ref ieee64 vector ( 2 ) ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORUPD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVUPD ( smaddrmode r1 , xmreg rm ) means [ rm := ( ieee64 vector ( 2 ) ) ^ ( r1 ) ] assembles [ 'movupd  ' r1 ', ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> Match rm := ( ieee64 vector ( 2 ) ) ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> Match pattern xmreg means [ psxmreg | pdxmreg | xmregi324 | xmreg8 | xmreg16 | uxmreg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD>  failvar= 1%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> psxmreg> Match pattern psxmreg means [ XMM7R324 | XMM6R324 | XMM5R324 | XMM4R324 | XMM3R324 | XMM2R324 | XMM1R324 | XMM0R324 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> psxmreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> psxmreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> psxmreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> pdxmreg> Match pattern pdxmreg means [ XMM7R642 | XMM6R642 | XMM5R642 | XMM4R642 | XMM3R642 | XMM2R642 | XMM1R642 | XMM0R642 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> pdxmreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> pdxmreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> pdxmreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmregi324> Match pattern xmregi324 means [ XMM0I324 | XMM3I324 | XMM2I324 | XMM1I324 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmregi324> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmregi324> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmregi324> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg8> Match pattern xmreg8 means [ XMM0I8 | XMM3I8 | XMM1I8 | XMM2I8 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg8> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg8> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg8> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg16> Match pattern xmreg16 means [ XMM0I16 | XMM3I16 | XMM1I16 | XMM2I16 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg16> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg16> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> xmreg16> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> uxmreg> Match pattern uxmreg means [ XMM1 | XMM3 | XMM4 | XMM5 | XMM6 | XMM2 | XMM0 | XMM7 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> uxmreg> try binding %MM4 to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> uxmreg> failed		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> uxmreg> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVUPD> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern COMISSIFGOTO ( label l , sxmreg r1 , sxmreg r2 , fcondition c , int t ) means [ if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l ] assembles [ 'comiss ' r1 ',' r2 '
 j' c ' ' l ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   COMISSIFGOTO> Match if ( ( t ) c ( ^ ( r1 ) , ^ ( r2 ) ) ) goto l  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   COMISSIFGOTO> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern COMISS ( fcondition c , sxmreg r1 , sxmreg r2 , breg r ) means [ ( ref uint8 ) r := ( uint8 ) c ( ^ ( r1 ) , ^ ( r2 ) ) ] assembles [ 'comiss ' r1 ',' r2 '
 set' c ' ' r '
 not ' r '
 inc ' r ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   COMISS> Match ( ref uint8 ) r := ( uint8 ) c ( ^ ( r1 ) , ^ ( r2 ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   COMISS> Match ( ref uint8 ) r  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   COMISS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern OPPI8 ( poperator op , xmreg rm , xmreg r1 ) means [ ( ref int8 vector ( 16 ) ) r1 := op ( ( int8 vector ( 16 ) ) ^ ( r1 ) , ( int8 vector ( 16 ) ) ^ ( rm ) ) ] assembles [ 'p' op 'b  ' rm ',' r1 ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPI8> Match ( ref int8 vector ( 16 ) ) r1 := op ( ( int8 vector ( 16 ) ) ^ ( r1 ) , ( int8 vector ( 16 ) ) ^ ( rm ) )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   OPPI8> Match ( ref int8 vector ( 16 ) ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   OPPI8> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern STORUPS ( maddrmode rm , xmreg r1 ) means [ ( ref ieee32 vector ( 4 ) ) rm := ( ieee32 vector ( 4 ) ) ^ ( r1 ) ] assembles [ 'movups  ' r1 ', ' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORUPS> Match ( ref ieee32 vector ( 4 ) ) rm := ( ieee32 vector ( 4 ) ) ^ ( r1 )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   STORUPS> Match ( ref ieee32 vector ( 4 ) ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   STORUPS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVQS ( maddrmode rm , mreg m ) means [ ( ref doubleword ) rm := ^ ( m ) ] assembles [ 'movq ' m ',' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> Match ( ref doubleword ) rm := ^ ( m )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> Match ( ref doubleword ) rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> Match rm  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> Match pattern maddrmode ( addrform f ) means [ mem ( f ) ] assembles [ f ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> maddrmode> Match mem ( f )  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> maddrmode> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQS> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVDQL ( maddrmode rm , xmreg r1 ) means [ ( ref quadword ) r1 := ^ ( rm ) ] assembles [ 'movdqu ' rm ',' r1 '#MOVQDL
 prefetcht0 128+' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVDQL> Match ( ref quadword ) r1 := ^ ( rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVDQL> Match ( ref quadword ) r1  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVDQL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Match pattern MOVQL ( maddrmode rm , mreg m ) means [ m := ( doubleword ) ^ ( rm ) ] assembles [ 'movq ' rm ',' m '
 prefetchnta 128+' rm ]  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match m := ( doubleword ) ^ ( rm )  to assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match m  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match pattern mreg means [ im4reg | untypedmreg | im8reg | im8ureg | im2reg ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> %MM4ref uint8 vector ( 8 )h-5738444977846951095false-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL>  failvar= 0%MM4ref uint8 vector ( 8 )h-5738444977846951095false0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> im4reg> Match pattern im4reg means [ MM416 | MM316 | MM516 | MM016 | MM116 | MM216 ]  to %MM4		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> im4reg> already a reg		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Record %MM4ref uint8 vector ( 8 )h-5738444977846951095false->0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match ( doubleword ) ^ ( rm )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match ( doubleword ) ^ ( rm )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match CastRhs predeclared or vector cast doubleword=uint8 vector ( 8 ) to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match ^ ( rm )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match ^ ( rm )  to ^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae))		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match rm  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> Match pattern maddrmode ( addrform f ) means [ mem ( f ) ] assembles [ f ]  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> Match mem ( f )  to mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> Match f  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> Match f  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> Match pattern addrform means [ eaform | regindirf ]  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> LABh-5738444977846951095true-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode>  failvar= 0LABh-5738444977846951095true0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match ( t ) f  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match ( t ) f  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> bind actualtype int32to param 1=int32		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match pattern longint means [ int32 | uint32 ]  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match  alternatives format   to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match check type equality with int32 actually is int32 true to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match f  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match f  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> Match pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ]  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> LABh-5738444977846951095true-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform>  failvar= 0LABh-5738444977846951095true0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> directf> Match const s  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> directf> Match const s  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> directf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> udirectf> Match const s  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> udirectf> Match const s  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> udirectf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> labelconstf> Match + ( l , const s )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> labelconstf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> scaledIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusScaledIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusScaledIndexPlusOffsetf2> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> baseplusoffsetf> Match + ( ^ ( r ) , s )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> baseplusoffsetf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusScaledIndexf> Match + ( ^ ( r1 ) , * ( ^ ( r2 ) , s ) )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusScaledIndexf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> scaledIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> baseminusoffsetf> Match - ( ^ ( r ) , s )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> baseminusoffsetf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusIndexf> Match + ( ^ ( r1 ) , ^ ( r2 ) )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> basePlusIndexf> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform>  record failure pattern guncasteaform means [ directf | udirectf | labelconstf | scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf ] LABh-5738444977846951095true0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> eaform> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> Match ^ ( r )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> Match ^ ( r )  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> Match r  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> Match pattern reg means [ ireg | ureg ]  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> LABh-5738444977846951095true-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf>  failvar= 0LABh-5738444977846951095true0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> Match pattern ireg means [ indexreg ]  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> LABh-5738444977846951095true-> null 		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg>  failvar= 0LABh-5738444977846951095true0 switchvar 0		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> try binding label121f7ffc8fbaae to a register		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> value type int32		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> register type ref int32		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> check assign compatibility of ref int32and int32
 is a ref =false
 is assignable =true		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> load into register label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> load into %ebx		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>  forcederef label121f7ffc8fbaae to int32		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> type int32 -> format word		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> Match type compatible with int32 to label121f7ffc8fbaae		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> type int32 -> format word		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>  is word == word		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> assign check returns true		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>  unoptimisedcodegen seq(
  assign((ref int32)%ebx,label121f7ffc8fbaae),
  )		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>  cgstatement optlevel=0:seq(
  assign(%ebx,label121f7ffc8fbaae),
  )
 has local=false		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>    sub exp optimise assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   unoptimisedcodegen assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   in still free want length 32 for ref int32		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   in split src weight=0 dest weight=0 sf = 9intlimit=9 scharlen=19 charlimit=2000		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   splitsrc=false splitwhole=false		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>     match in unoptimised codegen assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   %ebxref int32:=LABh-5738444977846951095true-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern IFLITGOTO ( label l , addrmode r1 , signed r2 , condition c , signed t , int b ) means [ if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l ] assembles [ ' cmp' t '  $' r2 ',  ' r1 '
 j' c '   ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFLITGOTO> Match if ( ( b ) c ( ( t ) ^ ( r1 ) , const r2 ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFLITGOTO> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern BIFLITGOTO ( label l , baddrmode r1 , signed arg2 , condition c , signed t ) means [ if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l ] assembles [ ' cmp' t '  $' arg2 ',  ' r1 '
 j' c '   ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   BIFLITGOTO> Match if ( c ( ( t ) ^ ( r1 ) , const arg2 ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   BIFLITGOTO> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern IFIN ( reg r1 , reg r2 , label l ) means [ if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l ] assembles [ 'bt  ' r2 ',(' r1 ')
 jc ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFIN> Match if ( ( int8 ) AND ( ( uint8 ) ^ ( mem ( r1 ) ) , << ( ( uint8 ) 1 , ^ ( r2 ) ) ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFIN> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern IFGOTO ( label l , ireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l ] assembles [ 'cmpl ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFGOTO> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int32 ) r2 ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFGOTO> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern IFGOTOB ( label l , bireg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l ] assembles [ 'cmpb ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFGOTOB> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int8 ) r2 ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFGOTOB> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern IFGOTOW ( label l , wreg r1 , regaddrimmediate r2 , condition c , signed t , int b ) means [ if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l ] assembles [ 'cmpw ' r2 ',' '  ' r1 '
 j' c '   ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFGOTOW> Match if ( ( int8 ) c ( ^ ( r1 ) , ( int16 ) r2 ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   IFGOTOW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern FIFGOTOgeneral ( label l , fcondition c , int t , fputype t ) means [ if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l ] assembles [ 'fxch
 fcompp 
push %ax  
 fstsw %ax
 sahf
 pop %ax
 j' c '   ' l ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   FIFGOTOgeneral> Match if ( ( t ) c ( ( t ) POP ( ST ) , ( t ) POP ( ST ) ) ) goto l  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   FIFGOTOgeneral> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern LOAD ( maddrmode rm , anyreg r1 , word32 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match ( ref t ) r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match pattern anyreg means [ breg | wreg | reg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> Match pattern breg means [ bireg | bureg | boreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bireg> Match pattern bireg means [ BL | DL | AL | CL ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bireg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bireg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bireg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bureg> Match pattern bureg means [ BH | DH | uAL | uBL | uDL | uCL | CH ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bureg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bureg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> bureg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> boreg> Match pattern boreg means [ oBL | oAL | oDL | oCL ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> boreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> boreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> boreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg>  record failure pattern breg means [ bireg | bureg | boreg ] %ebxref int32h-5738444977846951095false0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> breg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> swreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> swreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> swreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> uwreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> uwreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> uwreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> untypedwreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> untypedwreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> untypedwreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg>  record failure pattern wreg means [ swreg | uwreg | untypedwreg ] %ebxref int32h-5738444977846951095false0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> wreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> ireg> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> ireg> Record %ebxref int32h-5738444977846951095false->0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> reg> Record %ebxref int32h-5738444977846951095false->0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Record %ebxref int32h-5738444977846951095false->2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match ( t ) ^ ( rm )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> bind actualtype int32to param 2=int32		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match pattern word32 means [ int32 | uint32 | word ]  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match  alternatives format   to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match check type equality with int32 actually is int32 true to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match ^ ( rm )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> Match ^ ( rm )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOAD> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern LOADB ( maddrmode rm , breg r1 , byte t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match ( ref t ) r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match pattern byte means [ uint8 | int8 | octet ]  to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match check type equality with uint8 actually is int32 false to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match check type equality with int8 actually is int32 false to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> Match check type equality with octet actually is int32 false to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADB> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern LOADW ( maddrmode rm , wreg r1 , word16 t ) means [ ( ref t ) r1 := ( t ) ^ ( rm ) ] assembles [ 'mov' t ' ' rm ',' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match ( ref t ) r1 := ( t ) ^ ( rm )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match ( ref t ) r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match pattern word16 means [ int16 | uint16 | halfword ]  to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match check type equality with int16 actually is int32 false to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match check type equality with uint16 actually is int32 false to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match  alternatives format   to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> Match check type equality with halfword actually is int32 false to ^(%ebx)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LOADW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVZXB ( reg r1 , baddrmode rm ) means [ r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> Match r1 := ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> Match ( uint32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> Match CastRhs predeclared or vector cast uint32=int32 to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVSXB ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) ) ] assembles [ 'movsbl ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match r1 := ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match ( int32 ) EXTEND ( ( int8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match CastRhs predeclared or vector cast int32=int32 to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> Match EXTEND ( ( int8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXB> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVZXW ( reg r1 , wreg rm ) means [ r1 := ( uint32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzwl ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> Match r1 := ( uint32 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> Match ( uint32 ) EXTEND ( ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> Match CastRhs predeclared or vector cast uint32=int32 to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVSXW ( reg r1 , wreg rm ) means [ r1 := ( int32 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movswl ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match r1 := ( int32 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match ( int32 ) EXTEND ( ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match CastRhs predeclared or vector cast int32=int32 to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> Match EXTEND ( ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVZXB2 ( reg r1 , baddrmode rm ) means [ r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) ) ] assembles [ 'movzbl ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match r1 := ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match ( int32 ) EXTEND ( ( uint8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match CastRhs predeclared or vector cast int32=int32 to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> Match EXTEND ( ( uint8 ) ^ ( rm ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXB2> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVZBW ( wreg r1 , bureg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movzbw ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW>  failvar= 1%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> swreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> swreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> swreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> uwreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> uwreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> uwreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> untypedwreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> untypedwreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> untypedwreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZBW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVSBW ( wreg r1 , breg rm ) means [ r1 := ( int16 ) EXTEND ( ^ ( rm ) ) ] assembles [ 'movsbw ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> Match r1 := ( int16 ) EXTEND ( ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> Match pattern wreg means [ swreg | uwreg | untypedwreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW>  failvar= 1%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> swreg> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> swreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> swreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> swreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> uwreg> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> uwreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> uwreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> uwreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> untypedwreg> Match pattern untypedwreg means [ SI | DI ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> untypedwreg> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> untypedwreg> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> untypedwreg> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSBW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVZXBW ( uwreg r1 , breg rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movzx ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXBW> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXBW> Match pattern uwreg means [ uBX | uCX | uDX | uSI | uDI | uAX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXBW> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXBW> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVZXBW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern MOVSXBW ( swreg r1 , baddrmode rm ) means [ r1 := EXTEND ( ^ ( rm ) ) ] assembles [ 'movsx ' rm ',   ' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXBW> Match r1 := EXTEND ( ^ ( rm ) )  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXBW> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXBW> Match pattern swreg means [ AX | BX | CX | DX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXBW> try binding %ebx to a register		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXBW> failed		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   MOVSXBW> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern CLEARREG ( reg rm , type t , int s ) means [ ( ref t ) rm := ( t ) 0 ] assembles [ 'xor' t ' ' rm ',' rm ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm := ( t ) 0  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match ( ref t ) rm  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match rm  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match ( t ) 0  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> bind actualtype int32to param 1=int32		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match 0  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match 0  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> Match 0  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   CLEARREG> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern STORELIT ( addrmode rm , type t , int s ) means [ ( ref t ) rm := ( t ) const s ] assembles [ 'mov' t '  $' s ',' ' ' rm ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match ( ref t ) rm := ( t ) const s  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match ( ref t ) rm  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match rm  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match pattern addrmode means [ maddrmode | anyreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> %ebxref int32h-5738444977846951095false-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> maddrmode> Match mem ( f )  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> maddrmode> Match mem ( f )  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> maddrmode> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> Match pattern anyreg means [ breg | wreg | reg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> %ebxref int32h-5738444977846951095false-> alternative     2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> anyreg> reg> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Record %ebxref int32h-5738444977846951095false->1		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match ( t ) const s  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match ( t ) const s  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> bind actualtype int32to param 1=int32		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match const s  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> Match const s  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   STORELIT> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Match pattern LEA ( reg r1 , leaform ea ) means [ r1 := ea ] assembles [ 'lea ' ea ',' r1 ]  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Match r1 := ea  to assign(%ebx,label121f7ffc8fbaae)		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Match r1  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Match pattern reg means [ ireg | ureg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> ireg> Match pattern ireg means [ indexreg ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> ireg> %ebxref int32h-5738444977846951095false-> alternative     0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> ireg>  failvar= 0%ebxref int32h-5738444977846951095false0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> ireg> indexreg> Match pattern indexreg means [ EAX | EBX | EDI | ESI | EBP | ESP | EAX | ECX | EDX ]  to %ebx		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> ireg> indexreg> already a reg		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Match ea  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Match ea  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Match pattern leaform means [ scaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf | basePlusScaledIndexPlusOffsetf2 | baseplusoffsetf | basePlusIndexPlusOffsetf | basePlusScaledIndexf | scaledIndexPlusOffsetf | baseminusoffsetf | basePlusIndexf | barelab ]  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> LABh-5738444977846951095true-> null 		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA>  failvar= 0LABh-5738444977846951095true0 switchvar 0		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( off , * ( ^ ( r2 ) , s ) ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf2> Match + ( * ( ^ ( r2 ) , s ) , + ( ^ ( r1 ) , off ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusScaledIndexPlusOffsetf2> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> baseplusoffsetf> Match + ( ^ ( r ) , s )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> baseplusoffsetf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusIndexPlusOffsetf> Match + ( ^ ( r1 ) , + ( ^ ( r2 ) , off ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusScaledIndexf> Match + ( ^ ( r1 ) , * ( ^ ( r2 ) , s ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusScaledIndexf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> Match + ( * ( ^ ( r1 ) , s ) , offs )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> scaledIndexPlusOffsetf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> baseminusoffsetf> Match - ( ^ ( r ) , s )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> baseminusoffsetf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusIndexf> Match + ( ^ ( r1 ) , ^ ( r2 ) )  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> basePlusIndexf> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> barelab> Match l  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> barelab> Match l  to label121f7ffc8fbaae		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> Record LABh-5738444977846951095true->9		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   LEA> rollBackReservations to 2		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   Record %ebxref int32:=LABh-5738444977846951095true->21		 %edi%eadx	5
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   assign(%ebx,label121f7ffc8fbaae)	-> lea  label121f7ffc8fbaae,%ebx ok		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   rep count =0		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg>   rollBackReservations to 2		 %edi%eadx	4
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> indexreg> reserve register at depth 3,%ebx		 %edi%ebx%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> ireg> Record LABh-4099023019040547368true->0		 %edi%ebx%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> regindirf> Record LABh-4099023019040547368true->0		 %edi%ebx%eadx	3
  MOVQS> im8ureg>   MOVQL> maddrmode> Record LABh-4099023019040547368true->1		 %edi%ebx%eadx	3
  MOVQS> im8ureg>   MOVQL> rollBackReservations to 2		 %edi%ebx%eadx	3
  MOVQS> im8ureg>   MOVQL> %ebx:2		 %edi%ebx%eadx	3
  MOVQS> im8ureg>   MOVQL> Unreserve %ebx		 %edi%eadx	3
  MOVQS> im8ureg>   MOVQL> rollBackReservations to 2		 %edi%eadx	3
  MOVQS> im8ureg>   Record %MM4ref uint8 vector ( 8 ):=^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[LABref uint8 vector ( 8 )h-5738444977846951095true->150		 %edi%eadx	3
  MOVQS> im8ureg>   assign(%MM4,^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))	-> movq   0(%ebx),%MM4
 prefetchnta 128+  0(%ebx) ok		 %edi%eadx	2
  MOVQS> im8ureg>   rep count =0		 %edi%eadx	2
  MOVQS> im8ureg>   rollBackReservations to 2		 %edi%eadx	2
  MOVQS> im8ureg> reserve register at depth 3,%MM4		 %edi%eadx%MM4	1
  MOVQS> Record M[LABref uint8 vector ( 8 )h-1760337158963269795true->3		 %edi%eadx%MM4	1
  MOVQS> rollBackReservations to 0		 %edi%eadx%MM4	1
  MOVQS> %MM4:2		 %edi%eadx%MM4	1
  MOVQS> Unreserve %MM4		 %edi%eadx	1
  MOVQS> rollBackReservations to 0		 %edi%eadx	1
  MOVQS> %edi:1		 %edi%eadx	1
  MOVQS> Unreserve %edi		 %eadx	1
  MOVQS> rollBackReservations to 0		 %eadx	1
  MOVQS> %eax:0		 %eadx	1
  MOVQS> Unreserve %eax		 	1
  Record M[+int32int32int32(^ref int32ref int32int32(M[+int32int32int32((int32)^ref wordref wordword(%ebpref word, L8int32)ref int32, +int32int32int32(^ref int32ref int32int32(M[+int32int32int32(^ref int32ref int32int32((ref int32)%ebpref word, L-8int32)ref int32, L6int32))ref uint8 vector ( 8 ):=^ref uint8 vector ( 8 )ref uint8 vector ( 8 )uint8 vector ( 8 )(M[LABref uint8 vector ( 8 )h-3204915108055699955true->148		 	1
  assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))	-> movq %MM4,        6(%eax,%edi ,1) ok		 	0
  rep count =0		 	0
 unoptimisedcodegen seq(
  seq(
    procedure (
	label121f7ffc8f1a94	/* internal label*/ ,
	loadbmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 80 )  ,ref int32  ]  	/* args */,
int8	 /* return type*/,
seq(
      seq(
        seq(/* 182 */
          assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
          seq(/* 183 */
           assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
           seq(/* 184 */
            reset[(int32)+(^((ref int32)%ebp),     -148)],
            seq(/* 216 */
             seq(
               seq(
                 ioresult[],
                 seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
                  )),
               seq(
                if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
                  seq(/* 185 */
                    assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                    seq(/* 186 */
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       seq(
                                                         seq(
                                                           null,
                                                           seq(
                                                            seq(
                                                              length[(int32)label121f7ffc99bac4],
                                                              seq(
                                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                               )),
                                                            )),
                                                         seq(
                                                          null,
                                                          )),
                                                       seq(
                                                        null,
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                seq(
                                                  length[(int32)+((int32)^(%ebp),     8)],
                                                  seq(
                                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                                   )),
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    ioresult[],
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                     ))),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        seq(
                          printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                          seq(
                           seq(
                             printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                             seq(
                              seq(
                                printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                                seq(
                                 println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                 )),
                              )),
                           )),
                        )),
                     seq(/* 187 */
                      seq(
                        null,
                        ),
                      ))),
                  ) , seq(/* 191 */
                  seq(
                    seq(
                      null,
                      seq(
                       filesize[(int32)+(^((ref int32)%ebp),     -148)],
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                        ))),
                    seq(
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                     )),
                  seq(/* 192 */
                   assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
                   seq(/* 193 */
                    blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                    seq(/* 215 */
                     seq(
                       seq(
                         null,
                         seq(
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                          )),
                       seq(
                        seq(/* 196 */
                          seq(
                            seq(
                              seq(
                                seq(
                                  getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                                  seq(
                                   assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                                   seq(
                                    assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                    ))),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                  ))),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                                ))),
                            seq(
                             initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                             )),
                          seq(/* 197 */
                           seq(
                             seq(
                               seq(
                                 seq(
                                   getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                                   seq(
                                    assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                    seq(
                                     assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                     ))),
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                                  seq(
                                   assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                                   ))),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                                 ))),
                             seq(
                              initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                              )),
                           seq(/* 212 */
                            if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                              seq(/* 199 */
                                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                                seq(/* 200 */
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               null,
                                               seq(
                                                seq(
                                                  length[(int32)label121f7ffc9c1ac6],
                                                  seq(
                                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                                   )),
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    seq(
                                      printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                      seq(
                                       println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                       )),
                                    )),
                                 seq(/* 201 */
                                  seq(
                                    null,
                                    ),
                                  ))),
                              ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                              seq(/* 204 */
                                assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                                seq(/* 205 */
                                 seq(
                                   seq(
                                     null,
                                     seq(
                                      label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                      seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                       ))),
                                   seq(
                                    if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                      seq(
                                        seq(
                                          null,
                                          seq(
                                           label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                           seq(
                                            assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                            ))),
                                        seq(
                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                         )),
                                      ) , seq(
                                      null,
                                      )),
                                    )),
                                 seq(/* 208 */
                                  seq(
                                    var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                    seq(
                                      seq(
                                        null,
                                        ),
                                      seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                       )),
                                    seq(
                                     var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                     null,
                                     seq(
                                      var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                      if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                        seq(
                                         label121f7ffc9c5aca,
                                         seq(
                                          seq(
                                            seq(
                                              seq(
                                                if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                                seq(
                                                 if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                               )),
                                            seq(
                                             blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                             )),
                                          seq(
                                           if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                           seq(
                                            assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                            seq(
                                             goto(label121f7ffc9c5aca),
                                             seq(
                                              label121f7ffc9c5ac8,
                                              ))))))) , null),
                                      ))),
                                  seq(/* 209 */
                                   seq(
                                     var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                     seq(
                                       null,
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                        seq(
                                         seq(
                                           seq(
                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                             seq(
                                              assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                              )),
                                           seq(
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                              var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                              for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                                var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                                for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                                  seq(
                                                    seq(
                                                      if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                      seq(
                                                       if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                       )),
                                                    seq(
                                                     if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                     )),
                                                  seq(
                                                   assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                                   ))),
                                                )),
                                              )),
                                            )),
                                         ))),
                                     ),
                                   seq(/* 211 */
                                    assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                    seq(/* 212 */
                                     seq(
                                       null,
                                       ),
                                     )))))),
                              ) , seq(
                              null,
                              ))),
                            seq(/* 213 */
                             freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                             seq(/* 214 */
                              pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                              seq(/* 215 */
                               seq(
                                 null,
                                 ),
                               )))))),
                        )),
                     seq(/* 216 */
                      seq(
                        null,
                        ),
                      )))))),
                )),
             seq(/* 217 */
              seq(
                null,
                ),
              ))))),
        seq(
         label121f7ffc999ac2,
         seq(
          ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
          ))),
      )	/* subtree */,
LocalStoreAllocator(-1,424)	/* allocator */,
164),
    seq(
     procedure (
	label121f7ffc8f0a8e	/* internal label*/ ,
	storebmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 512 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
       seq(
         seq(/* 151 */
           assign[(int32)+(^((ref int32)%ebp),     -144),(int32)+((int32)^(%ebp),     8)],
           seq(/* 152 */
            rewrite[(int32)+(^((ref int32)%ebp),     -144)],
            seq(/* 154 */
             label121f7ffc8f4a9a[(int32)+(^((ref int32)%ebp),     -108),(int32)^(mem(ref int32,+((int32)^(%ebp),     1032)))],
             seq(/* 155 */
              blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(^((ref int32)%ebp),     -108),    54,(int32)+(^((ref int32)%ebp),     -140)],
              seq(/* 156 */
               seq(
                 seq(
                   seq(
                     seq(
                       getmem[(int32)+(^((ref int32)%ebp),     -12),    36],
                       seq(
                        assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     4)),    0),
                        seq(
                         assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                         ))),
                     seq(
                      assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     16)),    0),
                      seq(
                       assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32)))),
                       ))),
                   seq(
                    assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     28)),    0),
                    seq(
                     assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8)))),
                     ))),
                 seq(
                  initvec[(int32)+(^((ref int32)%ebp),     -12),    3,(int32)    1],
                  )),
               seq(/* 160 */
                seq(
                  var(mem(ref int32,+(^((ref int32)%ebp),     -148))),
                  seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)))),
                    seq(
                     seq(
                       seq(
                         assign(mem(ref int32,+(^((ref int32)%ebp),     -252)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)))),
                         seq(
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -248)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)))),
                          )),
                       seq(
                        for(mem(ref int32,+(^((ref int32)%ebp),     -148)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -256))) ,     1 ,seq(
                          var(mem(ref int32,+(^((ref int32)%ebp),     -152))),
                          for(mem(ref int32,+(^((ref int32)%ebp),     -152)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -252))) ,     1 ,seq(
                            var(mem(ref int32,+(^((ref int32)%ebp),     -156))),
                            for(mem(ref int32,+(^((ref int32)%ebp),     -156)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -248))) ,     1 ,seq(
                              seq(
                                seq(
                                  if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -156))),Fail(    5) , null),
                                  seq(
                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -148))),Fail(    5) , null),
                                   )),
                                seq(
                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -152))),Fail(    5) , null),
                                 )),
                              seq(
                               assign(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -152))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -156))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12))))))),(uint8)+(^(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -156))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -152))))), ^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     1032)))))))),  -128)),
                               ))),
                            )),
                          )),
                        )),
                     )),
                  ),
                seq(/* 164 */
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))),     1))),
                 seq(/* 165 */
                  seq(
                    seq(
                      label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                      seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                       )),
                    seq(
                     if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                       seq(
                         seq(
                           null,
                           seq(
                            label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                            seq(
                             assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                             ))),
                         seq(
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                          )),
                       ) , seq(
                       null,
                       )),
                     )),
                  seq(/* 168 */
                   seq(
                     var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                     seq(
                      var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                      null,
                      seq(
                       var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                       if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                         assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),    0),
                         seq(
                          label121f7ffc993aba,
                          seq(
                           seq(
                             seq(
                               seq(
                                 if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8))))),Fail(    5) , null),
                                 seq(
                                  if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20))))),Fail(    5) , null),
                                  )),
                               seq(
                                if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32))))),Fail(    5) , null),
                                )),
                             seq(
                              blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -112))),(int32)+(^((ref int32)%ebp),     -140)],
                              )),
                           seq(
                            if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc993ab8) , null),
                            seq(
                             assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     1)),
                             seq(
                              goto(label121f7ffc993aba),
                              seq(
                               label121f7ffc993ab8,
                               ))))))) , null),
                       ))),
                   seq(/* 171 */
                    freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -12))),    36],
                    seq(/* 172 */
                     pasclose[(int32)+(^((ref int32)%ebp),     -144)],
                     seq(/* 174 */
                      seq(
                        null,
                        ),
                      )))))))))))),
         seq(
          label121f7ffc965ab6,
          )),
       )	/* subtree */,
LocalStoreAllocator(-1,316)	/* allocator */,
1028),
     seq(
      procedure (
	label121f7ffc8f4a9a	/* internal label*/ ,
	initbmpheader	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[ref octet vector ( 54 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
        seq(
          var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
          seq(
            var(mem(ref int32,+(^((ref int32)%ebp),     -32))),
            seq(
              seq(/* 91 */
                assign((ref uint8)mem(ref uint8,^(mem(ref int32,+((int32)^(%ebp),     8)))),(uint8) 66),
                seq(/* 92 */
                 assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     1)),(uint8) 77),
                 seq(/* 96 */
                  assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     2)),+(*(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1)), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),     54)),
                  seq(/* 97 */
                   seq(
                     seq(
                       var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
                       for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     -1 ,     8 ,assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))),
                       ),
                     seq(
                      for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     3 ,     1 ,assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),(uint8) 0)),
                      )),
                   seq(/* 98 */
                    assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     10)),    54),
                    seq(/* 138 */
                     seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -32)),(ref octet vector ( 40 ))+(^(mem(ref int32,+((int32)^(%ebp),     8))),     14)),
                       seq(
                        seq(/* 128 */
                          assign((ref int32)mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -32)))),    40),
                          seq(/* 129 */
                           assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     4)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1)),
                           seq(/* 130 */
                            assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     8)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),
                            seq(/* 131 */
                             assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     12)),(int16)  1),
                             seq(/* 132 */
                              assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     14)),(int16)SubField(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1),     8), 0,int16)),
                              seq(/* 133 */
                               assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     16)),    0),
                               seq(/* 134 */
                                assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     24)),    3780),
                                seq(/* 135 */
                                 assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     28)),    3780),
                                 seq(/* 136 */
                                  assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     32)),    0),
                                  seq(/* 137 */
                                   assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     36)),    0),
                                   seq(/* 138 */
                                    seq(
                                      null,
                                      ),
                                    ))))))))))),
                        )),
                     seq(/* 141 */
                      seq(
                        null,
                        ),
                      ))))))),
              seq(
               label121f7ffc8f5a9e,
               )),
            ),
          ),
        )	/* subtree */,
LocalStoreAllocator(-1,32)	/* allocator */,
8),
      ))),
  seq(
   seq(
     procedure (
	label121f7ffca57acc	/* internal label*/ ,
	unit$graphio	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	0  	/* lexical level */,
	[]  	/* args */,
void	 /* return type*/,
seq(
       label121f7ffc8f1a96,
       )	/* subtree */,
LocalStoreAllocator(-1,0)	/* allocator */,
0),
     seq(
      seq(
        seq(
          seq(
            seq(
              label121f7ffc8fbaae,
              seq(
                loc( 0),
               )),
            seq(
             seq(
               label121f7ffc8fbaac,
               seq(
                 loc( 0),
                )),
             seq(
              seq(
                label121f7ffc8fbaaa,
                seq(
                  loc( 0),
                 )),
              seq(
               seq(
                 label121f7ffc8fbaa8,
                 seq(
                   loc( 0),
                  )),
               seq(
                seq(
                  label121f7ffc8fbaa6,
                  seq(
                    loc( 0),
                   )),
                seq(
                 seq(
                   label121f7ffc8fbaa4,
                   seq(
                     loc( 0),
                    )),
                 seq(
                  seq(
                    label121f7ffc8fbaa2,
                    seq(
                      loc( 0),
                     )),
                  seq(
                   seq(
                     label121f7ffc8fbaa0,
                     seq(
                       loc( 0),
                      )),
                   )))))))),
          seq(
           label121f7ffc99bac4,
           seq(
            seq(
              seq(
                seq(
                  seq(
                     loc(  10),
                    seq(
                      loc(  99),
                     )),
                  seq(
                    loc(  97),
                   )),
                seq(
                 seq(
                    loc(  110),
                   seq(
                     loc(  116),
                    )),
                 seq(
                   loc(  32),
                  ))),
              seq(
               seq(
                 seq(
                    loc(  111),
                   seq(
                     loc(  112),
                    )),
                 seq(
                   loc(  101),
                  )),
               seq(
                 loc(  110),
                seq(
                  loc(  32),
                 )))),
            ))),
        seq(
         label121f7ffc9c1ac6,
         seq(
          seq(
            seq(
              seq(
                seq(
                  seq(
                     loc(  30),
                    seq(
                      loc(  32),
                     )),
                  seq(
                    loc(  56),
                   seq(
                     loc(  32),
                    ))),
                seq(
                 seq(
                    loc(  98),
                   seq(
                     loc(  105),
                    )),
                 seq(
                   loc(  116),
                  seq(
                    loc(  32),
                   )))),
              seq(
               seq(
                 seq(
                    loc(  98),
                   seq(
                     loc(  109),
                    )),
                 seq(
                   loc(  112),
                  seq(
                    loc(  32),
                   ))),
               seq(
                seq(
                   loc(  102),
                  seq(
                    loc(  105),
                   )),
                seq(
                  loc(  108),
                 seq(
                   loc(  101),
                  ))))),
            seq(
             seq(
               seq(
                 seq(
                    loc(  115),
                   seq(
                     loc(  32),
                    )),
                 seq(
                   loc(  110),
                  seq(
                    loc(  111),
                   ))),
               seq(
                seq(
                   loc(  116),
                  seq(
                    loc(  32),
                   )),
                seq(
                  loc(  115),
                 seq(
                   loc(  117),
                  )))),
             seq(
              seq(
                seq(
                   loc(  112),
                  seq(
                    loc(  112),
                   )),
                seq(
                  loc(  111),
                 seq(
                   loc(  114),
                  ))),
              seq(
               seq(
                  loc(  116),
                 seq(
                   loc(  101),
                  )),
               seq(
                 loc(  100),
                ))))),
          ))),
      )),
   ))		 	0
 cgstatement optlevel=0:seq(
  seq(
    procedure (
	label121f7ffc8f1a94	/* internal label*/ ,
	loadbmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 80 )  ,ref int32  ]  	/* args */,
int8	 /* return type*/,
seq(
      seq(
        seq(/* 182 */
          assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
          seq(/* 183 */
           assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
           seq(/* 184 */
            reset[(int32)+(^((ref int32)%ebp),     -148)],
            seq(/* 216 */
             seq(
               seq(
                 ioresult[],
                 seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
                  )),
               seq(
                if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
                  seq(/* 185 */
                    assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                    seq(/* 186 */
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       seq(
                                                         seq(
                                                           null,
                                                           seq(
                                                            seq(
                                                              length[(int32)label121f7ffc99bac4],
                                                              seq(
                                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                               )),
                                                            )),
                                                         seq(
                                                          null,
                                                          )),
                                                       seq(
                                                        null,
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                seq(
                                                  length[(int32)+((int32)^(%ebp),     8)],
                                                  seq(
                                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                                   )),
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    ioresult[],
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                     ))),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        seq(
                          printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                          seq(
                           seq(
                             printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                             seq(
                              seq(
                                printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                                seq(
                                 println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                 )),
                              )),
                           )),
                        )),
                     seq(/* 187 */
                      seq(
                        null,
                        ),
                      ))),
                  ) , seq(/* 191 */
                  seq(
                    seq(
                      null,
                      seq(
                       filesize[(int32)+(^((ref int32)%ebp),     -148)],
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                        ))),
                    seq(
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                     )),
                  seq(/* 192 */
                   assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
                   seq(/* 193 */
                    blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                    seq(/* 215 */
                     seq(
                       seq(
                         null,
                         seq(
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                          )),
                       seq(
                        seq(/* 196 */
                          seq(
                            seq(
                              seq(
                                seq(
                                  getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                                  seq(
                                   assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                                   seq(
                                    assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                    ))),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                  ))),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                                ))),
                            seq(
                             initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                             )),
                          seq(/* 197 */
                           seq(
                             seq(
                               seq(
                                 seq(
                                   getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                                   seq(
                                    assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                    seq(
                                     assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                     ))),
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                                  seq(
                                   assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                                   ))),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                                 ))),
                             seq(
                              initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                              )),
                           seq(/* 212 */
                            if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                              seq(/* 199 */
                                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                                seq(/* 200 */
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               null,
                                               seq(
                                                seq(
                                                  length[(int32)label121f7ffc9c1ac6],
                                                  seq(
                                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                                   )),
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    seq(
                                      printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                      seq(
                                       println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                       )),
                                    )),
                                 seq(/* 201 */
                                  seq(
                                    null,
                                    ),
                                  ))),
                              ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                              seq(/* 204 */
                                assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                                seq(/* 205 */
                                 seq(
                                   seq(
                                     null,
                                     seq(
                                      label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                      seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                       ))),
                                   seq(
                                    if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                      seq(
                                        seq(
                                          null,
                                          seq(
                                           label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                           seq(
                                            assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                            ))),
                                        seq(
                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                         )),
                                      ) , seq(
                                      null,
                                      )),
                                    )),
                                 seq(/* 208 */
                                  seq(
                                    var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                    seq(
                                      seq(
                                        null,
                                        ),
                                      seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                       )),
                                    seq(
                                     var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                     null,
                                     seq(
                                      var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                      if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                        seq(
                                         label121f7ffc9c5aca,
                                         seq(
                                          seq(
                                            seq(
                                              seq(
                                                if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                                seq(
                                                 if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                               )),
                                            seq(
                                             blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                             )),
                                          seq(
                                           if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                           seq(
                                            assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                            seq(
                                             goto(label121f7ffc9c5aca),
                                             seq(
                                              label121f7ffc9c5ac8,
                                              ))))))) , null),
                                      ))),
                                  seq(/* 209 */
                                   seq(
                                     var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                     seq(
                                       null,
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                        seq(
                                         seq(
                                           seq(
                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                             seq(
                                              assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                              )),
                                           seq(
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                              var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                              for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                                var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                                for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                                  seq(
                                                    seq(
                                                      if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                      seq(
                                                       if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                       )),
                                                    seq(
                                                     if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                     )),
                                                  seq(
                                                   assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                                   ))),
                                                )),
                                              )),
                                            )),
                                         ))),
                                     ),
                                   seq(/* 211 */
                                    assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                    seq(/* 212 */
                                     seq(
                                       null,
                                       ),
                                     )))))),
                              ) , seq(
                              null,
                              ))),
                            seq(/* 213 */
                             freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                             seq(/* 214 */
                              pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                              seq(/* 215 */
                               seq(
                                 null,
                                 ),
                               )))))),
                        )),
                     seq(/* 216 */
                      seq(
                        null,
                        ),
                      )))))),
                )),
             seq(/* 217 */
              seq(
                null,
                ),
              ))))),
        seq(
         label121f7ffc999ac2,
         seq(
          ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
          ))),
      )	/* subtree */,
LocalStoreAllocator(-1,424)	/* allocator */,
164),
    seq(
     procedure (
	label121f7ffc8f0a8e	/* internal label*/ ,
	storebmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 512 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
       seq(
         seq(/* 151 */
           assign[(int32)+(^((ref int32)%ebp),     -144),(int32)+((int32)^(%ebp),     8)],
           seq(/* 152 */
            rewrite[(int32)+(^((ref int32)%ebp),     -144)],
            seq(/* 154 */
             label121f7ffc8f4a9a[(int32)+(^((ref int32)%ebp),     -108),(int32)^(mem(ref int32,+((int32)^(%ebp),     1032)))],
             seq(/* 155 */
              blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(^((ref int32)%ebp),     -108),    54,(int32)+(^((ref int32)%ebp),     -140)],
              seq(/* 156 */
               seq(
                 seq(
                   seq(
                     seq(
                       getmem[(int32)+(^((ref int32)%ebp),     -12),    36],
                       seq(
                        assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     4)),    0),
                        seq(
                         assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                         ))),
                     seq(
                      assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     16)),    0),
                      seq(
                       assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32)))),
                       ))),
                   seq(
                    assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     28)),    0),
                    seq(
                     assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8)))),
                     ))),
                 seq(
                  initvec[(int32)+(^((ref int32)%ebp),     -12),    3,(int32)    1],
                  )),
               seq(/* 160 */
                seq(
                  var(mem(ref int32,+(^((ref int32)%ebp),     -148))),
                  seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)))),
                    seq(
                     seq(
                       seq(
                         assign(mem(ref int32,+(^((ref int32)%ebp),     -252)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)))),
                         seq(
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -248)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)))),
                          )),
                       seq(
                        for(mem(ref int32,+(^((ref int32)%ebp),     -148)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -256))) ,     1 ,seq(
                          var(mem(ref int32,+(^((ref int32)%ebp),     -152))),
                          for(mem(ref int32,+(^((ref int32)%ebp),     -152)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -252))) ,     1 ,seq(
                            var(mem(ref int32,+(^((ref int32)%ebp),     -156))),
                            for(mem(ref int32,+(^((ref int32)%ebp),     -156)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -248))) ,     1 ,seq(
                              seq(
                                seq(
                                  if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -156))),Fail(    5) , null),
                                  seq(
                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -148))),Fail(    5) , null),
                                   )),
                                seq(
                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -152))),Fail(    5) , null),
                                 )),
                              seq(
                               assign(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -152))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -156))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12))))))),(uint8)+(^(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -156))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -152))))), ^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     1032)))))))),  -128)),
                               ))),
                            )),
                          )),
                        )),
                     )),
                  ),
                seq(/* 164 */
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))),     1))),
                 seq(/* 165 */
                  seq(
                    seq(
                      label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                      seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                       )),
                    seq(
                     if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                       seq(
                         seq(
                           null,
                           seq(
                            label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                            seq(
                             assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                             ))),
                         seq(
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                          )),
                       ) , seq(
                       null,
                       )),
                     )),
                  seq(/* 168 */
                   seq(
                     var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                     seq(
                      var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                      null,
                      seq(
                       var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                       if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                         assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),    0),
                         seq(
                          label121f7ffc993aba,
                          seq(
                           seq(
                             seq(
                               seq(
                                 if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8))))),Fail(    5) , null),
                                 seq(
                                  if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20))))),Fail(    5) , null),
                                  )),
                               seq(
                                if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32))))),Fail(    5) , null),
                                )),
                             seq(
                              blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -112))),(int32)+(^((ref int32)%ebp),     -140)],
                              )),
                           seq(
                            if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc993ab8) , null),
                            seq(
                             assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     1)),
                             seq(
                              goto(label121f7ffc993aba),
                              seq(
                               label121f7ffc993ab8,
                               ))))))) , null),
                       ))),
                   seq(/* 171 */
                    freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -12))),    36],
                    seq(/* 172 */
                     pasclose[(int32)+(^((ref int32)%ebp),     -144)],
                     seq(/* 174 */
                      seq(
                        null,
                        ),
                      )))))))))))),
         seq(
          label121f7ffc965ab6,
          )),
       )	/* subtree */,
LocalStoreAllocator(-1,316)	/* allocator */,
1028),
     seq(
      procedure (
	label121f7ffc8f4a9a	/* internal label*/ ,
	initbmpheader	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[ref octet vector ( 54 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
        seq(
          var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
          seq(
            var(mem(ref int32,+(^((ref int32)%ebp),     -32))),
            seq(
              seq(/* 91 */
                assign((ref uint8)mem(ref uint8,^(mem(ref int32,+((int32)^(%ebp),     8)))),(uint8) 66),
                seq(/* 92 */
                 assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     1)),(uint8) 77),
                 seq(/* 96 */
                  assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     2)),+(*(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1)), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),     54)),
                  seq(/* 97 */
                   seq(
                     seq(
                       var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
                       for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     -1 ,     8 ,assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))),
                       ),
                     seq(
                      for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     3 ,     1 ,assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),(uint8) 0)),
                      )),
                   seq(/* 98 */
                    assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     10)),    54),
                    seq(/* 138 */
                     seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -32)),(ref octet vector ( 40 ))+(^(mem(ref int32,+((int32)^(%ebp),     8))),     14)),
                       seq(
                        seq(/* 128 */
                          assign((ref int32)mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -32)))),    40),
                          seq(/* 129 */
                           assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     4)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1)),
                           seq(/* 130 */
                            assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     8)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),
                            seq(/* 131 */
                             assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     12)),(int16)  1),
                             seq(/* 132 */
                              assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     14)),(int16)SubField(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1),     8), 0,int16)),
                              seq(/* 133 */
                               assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     16)),    0),
                               seq(/* 134 */
                                assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     24)),    3780),
                                seq(/* 135 */
                                 assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     28)),    3780),
                                 seq(/* 136 */
                                  assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     32)),    0),
                                  seq(/* 137 */
                                   assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     36)),    0),
                                   seq(/* 138 */
                                    seq(
                                      null,
                                      ),
                                    ))))))))))),
                        )),
                     seq(/* 141 */
                      seq(
                        null,
                        ),
                      ))))))),
              seq(
               label121f7ffc8f5a9e,
               )),
            ),
          ),
        )	/* subtree */,
LocalStoreAllocator(-1,32)	/* allocator */,
8),
      ))),
  seq(
   seq(
     procedure (
	label121f7ffca57acc	/* internal label*/ ,
	unit$graphio	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	0  	/* lexical level */,
	[]  	/* args */,
void	 /* return type*/,
seq(
       label121f7ffc8f1a96,
       )	/* subtree */,
LocalStoreAllocator(-1,0)	/* allocator */,
0),
     seq(
      seq(
        seq(
          seq(
            seq(
              label121f7ffc8fbaae,
              seq(
                loc( 0),
               )),
            seq(
             seq(
               label121f7ffc8fbaac,
               seq(
                 loc( 0),
                )),
             seq(
              seq(
                label121f7ffc8fbaaa,
                seq(
                  loc( 0),
                 )),
              seq(
               seq(
                 label121f7ffc8fbaa8,
                 seq(
                   loc( 0),
                  )),
               seq(
                seq(
                  label121f7ffc8fbaa6,
                  seq(
                    loc( 0),
                   )),
                seq(
                 seq(
                   label121f7ffc8fbaa4,
                   seq(
                     loc( 0),
                    )),
                 seq(
                  seq(
                    label121f7ffc8fbaa2,
                    seq(
                      loc( 0),
                     )),
                  seq(
                   seq(
                     label121f7ffc8fbaa0,
                     seq(
                       loc( 0),
                      )),
                   )))))))),
          seq(
           label121f7ffc99bac4,
           seq(
            seq(
              seq(
                seq(
                  seq(
                     loc(  10),
                    seq(
                      loc(  99),
                     )),
                  seq(
                    loc(  97),
                   )),
                seq(
                 seq(
                    loc(  110),
                   seq(
                     loc(  116),
                    )),
                 seq(
                   loc(  32),
                  ))),
              seq(
               seq(
                 seq(
                    loc(  111),
                   seq(
                     loc(  112),
                    )),
                 seq(
                   loc(  101),
                  )),
               seq(
                 loc(  110),
                seq(
                  loc(  32),
                 )))),
            ))),
        seq(
         label121f7ffc9c1ac6,
         seq(
          seq(
            seq(
              seq(
                seq(
                  seq(
                     loc(  30),
                    seq(
                      loc(  32),
                     )),
                  seq(
                    loc(  56),
                   seq(
                     loc(  32),
                    ))),
                seq(
                 seq(
                    loc(  98),
                   seq(
                     loc(  105),
                    )),
                 seq(
                   loc(  116),
                  seq(
                    loc(  32),
                   )))),
              seq(
               seq(
                 seq(
                    loc(  98),
                   seq(
                     loc(  109),
                    )),
                 seq(
                   loc(  112),
                  seq(
                    loc(  32),
                   ))),
               seq(
                seq(
                   loc(  102),
                  seq(
                    loc(  105),
                   )),
                seq(
                  loc(  108),
                 seq(
                   loc(  101),
                  ))))),
            seq(
             seq(
               seq(
                 seq(
                    loc(  115),
                   seq(
                     loc(  32),
                    )),
                 seq(
                   loc(  110),
                  seq(
                    loc(  111),
                   ))),
               seq(
                seq(
                   loc(  116),
                  seq(
                    loc(  32),
                   )),
                seq(
                  loc(  115),
                 seq(
                   loc(  117),
                  )))),
             seq(
              seq(
                seq(
                   loc(  112),
                  seq(
                    loc(  112),
                   )),
                seq(
                  loc(  111),
                 seq(
                   loc(  114),
                  ))),
              seq(
               seq(
                  loc(  116),
                 seq(
                   loc(  101),
                  )),
               seq(
                 loc(  100),
                ))))),
          ))),
      )),
   ))
 has local=false		 	0
  unoptimisedcodegen seq(
  procedure (
	label121f7ffc8f1a94	/* internal label*/ ,
	loadbmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 80 )  ,ref int32  ]  	/* args */,
int8	 /* return type*/,
seq(
    seq(
      seq(/* 182 */
        assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
        seq(/* 183 */
         assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
         seq(/* 184 */
          reset[(int32)+(^((ref int32)%ebp),     -148)],
          seq(/* 216 */
           seq(
             seq(
               ioresult[],
               seq(
                assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
                )),
             seq(
              if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
                seq(/* 185 */
                  assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                  seq(/* 186 */
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       seq(
                                                         null,
                                                         seq(
                                                          seq(
                                                            length[(int32)label121f7ffc99bac4],
                                                            seq(
                                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                             )),
                                                          )),
                                                       seq(
                                                        null,
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              seq(
                                                length[(int32)+((int32)^(%ebp),     8)],
                                                seq(
                                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                                 )),
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  ioresult[],
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                   ))),
                               seq(
                                null,
                                )),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      seq(
                        printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                        seq(
                         seq(
                           printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                           seq(
                            seq(
                              printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                              seq(
                               println[^(mem(ref int32,+(unit$system$base,     -24)))],
                               )),
                            )),
                         )),
                      )),
                   seq(/* 187 */
                    seq(
                      null,
                      ),
                    ))),
                ) , seq(/* 191 */
                seq(
                  seq(
                    null,
                    seq(
                     filesize[(int32)+(^((ref int32)%ebp),     -148)],
                     seq(
                      assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                      ))),
                  seq(
                   assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                   )),
                seq(/* 192 */
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
                 seq(/* 193 */
                  blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                  seq(/* 215 */
                   seq(
                     seq(
                       null,
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                        )),
                     seq(
                      seq(/* 196 */
                        seq(
                          seq(
                            seq(
                              seq(
                                getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                  ))),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                ))),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                              ))),
                          seq(
                           initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                           )),
                        seq(/* 197 */
                         seq(
                           seq(
                             seq(
                               seq(
                                 getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                  seq(
                                   assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                   ))),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                                 ))),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                               ))),
                           seq(
                            initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                            )),
                         seq(/* 212 */
                          if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                            seq(/* 199 */
                              assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                              seq(/* 200 */
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             null,
                                             seq(
                                              seq(
                                                length[(int32)label121f7ffc9c1ac6],
                                                seq(
                                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                                 )),
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  seq(
                                    printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                    seq(
                                     println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                     )),
                                  )),
                               seq(/* 201 */
                                seq(
                                  null,
                                  ),
                                ))),
                            ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                            seq(/* 204 */
                              assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                              seq(/* 205 */
                               seq(
                                 seq(
                                   null,
                                   seq(
                                    label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                     ))),
                                 seq(
                                  if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                    seq(
                                      seq(
                                        null,
                                        seq(
                                         label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                          ))),
                                      seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                       )),
                                    ) , seq(
                                    null,
                                    )),
                                  )),
                               seq(/* 208 */
                                seq(
                                  var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                  seq(
                                    seq(
                                      null,
                                      ),
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                     )),
                                  seq(
                                   var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                   null,
                                   seq(
                                    var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                    if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                      seq(
                                       label121f7ffc9c5aca,
                                       seq(
                                        seq(
                                          seq(
                                            seq(
                                              if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                              seq(
                                               if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                               )),
                                            seq(
                                             if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                             )),
                                          seq(
                                           blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                           )),
                                        seq(
                                         if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                          seq(
                                           goto(label121f7ffc9c5aca),
                                           seq(
                                            label121f7ffc9c5ac8,
                                            ))))))) , null),
                                    ))),
                                seq(/* 209 */
                                 seq(
                                   var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                   seq(
                                     null,
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                      seq(
                                       seq(
                                         seq(
                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                           seq(
                                            assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                            )),
                                         seq(
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                            var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                              var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                              for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                                seq(
                                                  seq(
                                                    if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                    seq(
                                                     if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                     )),
                                                  seq(
                                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                   )),
                                                seq(
                                                 assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                                 ))),
                                              )),
                                            )),
                                          )),
                                       ))),
                                   ),
                                 seq(/* 211 */
                                  assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                  seq(/* 212 */
                                   seq(
                                     null,
                                     ),
                                   )))))),
                            ) , seq(
                            null,
                            ))),
                          seq(/* 213 */
                           freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                           seq(/* 214 */
                            pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                            seq(/* 215 */
                             seq(
                               null,
                               ),
                             )))))),
                      )),
                   seq(/* 216 */
                    seq(
                      null,
                      ),
                    )))))),
              )),
           seq(/* 217 */
            seq(
              null,
              ),
            ))))),
      seq(
       label121f7ffc999ac2,
       seq(
        ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
        ))),
    )	/* subtree */,
LocalStoreAllocator(-1,424)	/* allocator */,
164),
  seq(
   procedure (
	label121f7ffc8f0a8e	/* internal label*/ ,
	storebmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 512 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
     seq(
       seq(/* 151 */
         assign[(int32)+(^((ref int32)%ebp),     -144),(int32)+((int32)^(%ebp),     8)],
         seq(/* 152 */
          rewrite[(int32)+(^((ref int32)%ebp),     -144)],
          seq(/* 154 */
           label121f7ffc8f4a9a[(int32)+(^((ref int32)%ebp),     -108),(int32)^(mem(ref int32,+((int32)^(%ebp),     1032)))],
           seq(/* 155 */
            blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(^((ref int32)%ebp),     -108),    54,(int32)+(^((ref int32)%ebp),     -140)],
            seq(/* 156 */
             seq(
               seq(
                 seq(
                   seq(
                     getmem[(int32)+(^((ref int32)%ebp),     -12),    36],
                     seq(
                      assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     4)),    0),
                      seq(
                       assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                       ))),
                   seq(
                    assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     16)),    0),
                    seq(
                     assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32)))),
                     ))),
                 seq(
                  assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     28)),    0),
                  seq(
                   assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8)))),
                   ))),
               seq(
                initvec[(int32)+(^((ref int32)%ebp),     -12),    3,(int32)    1],
                )),
             seq(/* 160 */
              seq(
                var(mem(ref int32,+(^((ref int32)%ebp),     -148))),
                seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)))),
                  seq(
                   seq(
                     seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -252)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)))),
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -248)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)))),
                        )),
                     seq(
                      for(mem(ref int32,+(^((ref int32)%ebp),     -148)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -256))) ,     1 ,seq(
                        var(mem(ref int32,+(^((ref int32)%ebp),     -152))),
                        for(mem(ref int32,+(^((ref int32)%ebp),     -152)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -252))) ,     1 ,seq(
                          var(mem(ref int32,+(^((ref int32)%ebp),     -156))),
                          for(mem(ref int32,+(^((ref int32)%ebp),     -156)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -248))) ,     1 ,seq(
                            seq(
                              seq(
                                if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -156))),Fail(    5) , null),
                                seq(
                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -148))),Fail(    5) , null),
                                 )),
                              seq(
                               if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -152))),Fail(    5) , null),
                               )),
                            seq(
                             assign(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -152))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -156))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12))))))),(uint8)+(^(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -156))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -152))))), ^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     1032)))))))),  -128)),
                             ))),
                          )),
                        )),
                      )),
                   )),
                ),
              seq(/* 164 */
               assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))),     1))),
               seq(/* 165 */
                seq(
                  seq(
                    label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                    seq(
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                     )),
                  seq(
                   if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                     seq(
                       seq(
                         null,
                         seq(
                          label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                          seq(
                           assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                           ))),
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                        )),
                     ) , seq(
                     null,
                     )),
                   )),
                seq(/* 168 */
                 seq(
                   var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                   assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                   seq(
                    var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                    null,
                    seq(
                     var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                     if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),    0),
                       seq(
                        label121f7ffc993aba,
                        seq(
                         seq(
                           seq(
                             seq(
                               if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8))))),Fail(    5) , null),
                               seq(
                                if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20))))),Fail(    5) , null),
                                )),
                             seq(
                              if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32))))),Fail(    5) , null),
                              )),
                           seq(
                            blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -112))),(int32)+(^((ref int32)%ebp),     -140)],
                            )),
                         seq(
                          if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc993ab8) , null),
                          seq(
                           assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     1)),
                           seq(
                            goto(label121f7ffc993aba),
                            seq(
                             label121f7ffc993ab8,
                             ))))))) , null),
                     ))),
                 seq(/* 171 */
                  freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -12))),    36],
                  seq(/* 172 */
                   pasclose[(int32)+(^((ref int32)%ebp),     -144)],
                   seq(/* 174 */
                    seq(
                      null,
                      ),
                    )))))))))))),
       seq(
        label121f7ffc965ab6,
        )),
     )	/* subtree */,
LocalStoreAllocator(-1,316)	/* allocator */,
1028),
   seq(
    procedure (
	label121f7ffc8f4a9a	/* internal label*/ ,
	initbmpheader	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[ref octet vector ( 54 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
      seq(
        var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
        seq(
          var(mem(ref int32,+(^((ref int32)%ebp),     -32))),
          seq(
            seq(/* 91 */
              assign((ref uint8)mem(ref uint8,^(mem(ref int32,+((int32)^(%ebp),     8)))),(uint8) 66),
              seq(/* 92 */
               assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     1)),(uint8) 77),
               seq(/* 96 */
                assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     2)),+(*(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1)), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),     54)),
                seq(/* 97 */
                 seq(
                   seq(
                     var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
                     for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     -1 ,     8 ,assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))),
                     ),
                   seq(
                    for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     3 ,     1 ,assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),(uint8) 0)),
                    )),
                 seq(/* 98 */
                  assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     10)),    54),
                  seq(/* 138 */
                   seq(
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -32)),(ref octet vector ( 40 ))+(^(mem(ref int32,+((int32)^(%ebp),     8))),     14)),
                     seq(
                      seq(/* 128 */
                        assign((ref int32)mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -32)))),    40),
                        seq(/* 129 */
                         assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     4)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1)),
                         seq(/* 130 */
                          assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     8)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),
                          seq(/* 131 */
                           assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     12)),(int16)  1),
                           seq(/* 132 */
                            assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     14)),(int16)SubField(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1),     8), 0,int16)),
                            seq(/* 133 */
                             assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     16)),    0),
                             seq(/* 134 */
                              assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     24)),    3780),
                              seq(/* 135 */
                               assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     28)),    3780),
                               seq(/* 136 */
                                assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     32)),    0),
                                seq(/* 137 */
                                 assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     36)),    0),
                                 seq(/* 138 */
                                  seq(
                                    null,
                                    ),
                                  ))))))))))),
                      )),
                   seq(/* 141 */
                    seq(
                      null,
                      ),
                    ))))))),
            seq(
             label121f7ffc8f5a9e,
             )),
          ),
        ),
      )	/* subtree */,
LocalStoreAllocator(-1,32)	/* allocator */,
8),
    )))		 	0
  cgstatement optlevel=0:seq(
  procedure (
	label121f7ffc8f1a94	/* internal label*/ ,
	loadbmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 80 )  ,ref int32  ]  	/* args */,
int8	 /* return type*/,
seq(
    seq(
      seq(/* 182 */
        assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
        seq(/* 183 */
         assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
         seq(/* 184 */
          reset[(int32)+(^((ref int32)%ebp),     -148)],
          seq(/* 216 */
           seq(
             seq(
               ioresult[],
               seq(
                assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
                )),
             seq(
              if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
                seq(/* 185 */
                  assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                  seq(/* 186 */
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       seq(
                                                         null,
                                                         seq(
                                                          seq(
                                                            length[(int32)label121f7ffc99bac4],
                                                            seq(
                                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                             )),
                                                          )),
                                                       seq(
                                                        null,
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              seq(
                                                length[(int32)+((int32)^(%ebp),     8)],
                                                seq(
                                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                                 )),
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  ioresult[],
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                   ))),
                               seq(
                                null,
                                )),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      seq(
                        printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                        seq(
                         seq(
                           printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                           seq(
                            seq(
                              printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                              seq(
                               println[^(mem(ref int32,+(unit$system$base,     -24)))],
                               )),
                            )),
                         )),
                      )),
                   seq(/* 187 */
                    seq(
                      null,
                      ),
                    ))),
                ) , seq(/* 191 */
                seq(
                  seq(
                    null,
                    seq(
                     filesize[(int32)+(^((ref int32)%ebp),     -148)],
                     seq(
                      assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                      ))),
                  seq(
                   assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                   )),
                seq(/* 192 */
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
                 seq(/* 193 */
                  blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                  seq(/* 215 */
                   seq(
                     seq(
                       null,
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                        )),
                     seq(
                      seq(/* 196 */
                        seq(
                          seq(
                            seq(
                              seq(
                                getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                  ))),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                ))),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                              ))),
                          seq(
                           initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                           )),
                        seq(/* 197 */
                         seq(
                           seq(
                             seq(
                               seq(
                                 getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                                 seq(
                                  assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                  seq(
                                   assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                   ))),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                                 ))),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                               ))),
                           seq(
                            initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                            )),
                         seq(/* 212 */
                          if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                            seq(/* 199 */
                              assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                              seq(/* 200 */
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             null,
                                             seq(
                                              seq(
                                                length[(int32)label121f7ffc9c1ac6],
                                                seq(
                                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                                 )),
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  seq(
                                    printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                    seq(
                                     println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                     )),
                                  )),
                               seq(/* 201 */
                                seq(
                                  null,
                                  ),
                                ))),
                            ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                            seq(/* 204 */
                              assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                              seq(/* 205 */
                               seq(
                                 seq(
                                   null,
                                   seq(
                                    label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                     ))),
                                 seq(
                                  if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                    seq(
                                      seq(
                                        null,
                                        seq(
                                         label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                          ))),
                                      seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                       )),
                                    ) , seq(
                                    null,
                                    )),
                                  )),
                               seq(/* 208 */
                                seq(
                                  var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                  seq(
                                    seq(
                                      null,
                                      ),
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                     )),
                                  seq(
                                   var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                   null,
                                   seq(
                                    var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                    if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                      seq(
                                       label121f7ffc9c5aca,
                                       seq(
                                        seq(
                                          seq(
                                            seq(
                                              if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                              seq(
                                               if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                               )),
                                            seq(
                                             if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                             )),
                                          seq(
                                           blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                           )),
                                        seq(
                                         if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                          seq(
                                           goto(label121f7ffc9c5aca),
                                           seq(
                                            label121f7ffc9c5ac8,
                                            ))))))) , null),
                                    ))),
                                seq(/* 209 */
                                 seq(
                                   var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                   seq(
                                     null,
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                      seq(
                                       seq(
                                         seq(
                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                           seq(
                                            assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                            )),
                                         seq(
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                            var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                              var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                              for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                                seq(
                                                  seq(
                                                    if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                    seq(
                                                     if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                     )),
                                                  seq(
                                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                   )),
                                                seq(
                                                 assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                                 ))),
                                              )),
                                            )),
                                          )),
                                       ))),
                                   ),
                                 seq(/* 211 */
                                  assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                  seq(/* 212 */
                                   seq(
                                     null,
                                     ),
                                   )))))),
                            ) , seq(
                            null,
                            ))),
                          seq(/* 213 */
                           freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                           seq(/* 214 */
                            pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                            seq(/* 215 */
                             seq(
                               null,
                               ),
                             )))))),
                      )),
                   seq(/* 216 */
                    seq(
                      null,
                      ),
                    )))))),
              )),
           seq(/* 217 */
            seq(
              null,
              ),
            ))))),
      seq(
       label121f7ffc999ac2,
       seq(
        ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
        ))),
    )	/* subtree */,
LocalStoreAllocator(-1,424)	/* allocator */,
164),
  seq(
   procedure (
	label121f7ffc8f0a8e	/* internal label*/ ,
	storebmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 512 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
     seq(
       seq(/* 151 */
         assign[(int32)+(^((ref int32)%ebp),     -144),(int32)+((int32)^(%ebp),     8)],
         seq(/* 152 */
          rewrite[(int32)+(^((ref int32)%ebp),     -144)],
          seq(/* 154 */
           label121f7ffc8f4a9a[(int32)+(^((ref int32)%ebp),     -108),(int32)^(mem(ref int32,+((int32)^(%ebp),     1032)))],
           seq(/* 155 */
            blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(^((ref int32)%ebp),     -108),    54,(int32)+(^((ref int32)%ebp),     -140)],
            seq(/* 156 */
             seq(
               seq(
                 seq(
                   seq(
                     getmem[(int32)+(^((ref int32)%ebp),     -12),    36],
                     seq(
                      assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     4)),    0),
                      seq(
                       assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                       ))),
                   seq(
                    assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     16)),    0),
                    seq(
                     assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32)))),
                     ))),
                 seq(
                  assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     28)),    0),
                  seq(
                   assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8)))),
                   ))),
               seq(
                initvec[(int32)+(^((ref int32)%ebp),     -12),    3,(int32)    1],
                )),
             seq(/* 160 */
              seq(
                var(mem(ref int32,+(^((ref int32)%ebp),     -148))),
                seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8)))),
                  seq(
                   seq(
                     seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -252)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20)))),
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -248)),^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32)))),
                        )),
                     seq(
                      for(mem(ref int32,+(^((ref int32)%ebp),     -148)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -256))) ,     1 ,seq(
                        var(mem(ref int32,+(^((ref int32)%ebp),     -152))),
                        for(mem(ref int32,+(^((ref int32)%ebp),     -152)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -252))) ,     1 ,seq(
                          var(mem(ref int32,+(^((ref int32)%ebp),     -156))),
                          for(mem(ref int32,+(^((ref int32)%ebp),     -156)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -248))) ,     1 ,seq(
                            seq(
                              seq(
                                if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -156))),Fail(    5) , null),
                                seq(
                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -148))),Fail(    5) , null),
                                 )),
                              seq(
                               if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -152))),Fail(    5) , null),
                               )),
                            seq(
                             assign(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -152))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -156))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12))))))),(uint8)+(^(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -156))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -148))), ^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -152))))), ^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     1032)))))))),  -128)),
                             ))),
                          )),
                        )),
                      )),
                   )),
                ),
              seq(/* 164 */
               assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     32))),     1))),
               seq(/* 165 */
                seq(
                  seq(
                    label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                    seq(
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                     )),
                  seq(
                   if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                     seq(
                       seq(
                         null,
                         seq(
                          label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    4],
                          seq(
                           assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                           ))),
                       seq(
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -112)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                        )),
                     ) , seq(
                     null,
                     )),
                   )),
                seq(/* 168 */
                 seq(
                   var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                   assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     1032))),     20)))),
                   seq(
                    var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                    null,
                    seq(
                     var(mem(ref int32,+(^((ref int32)%ebp),     -116))),
                     if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                       assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),    0),
                       seq(
                        label121f7ffc993aba,
                        seq(
                         seq(
                           seq(
                             seq(
                               if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     8))))),Fail(    5) , null),
                               seq(
                                if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     20))))),Fail(    5) , null),
                                )),
                             seq(
                              if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     32))))),Fail(    5) , null),
                              )),
                           seq(
                            blockwrite[(int32)+(^((ref int32)%ebp),     -144),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -12))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -12)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -112))),(int32)+(^((ref int32)%ebp),     -140)],
                            )),
                         seq(
                          if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -116))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc993ab8) , null),
                          seq(
                           assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     1)),
                           seq(
                            goto(label121f7ffc993aba),
                            seq(
                             label121f7ffc993ab8,
                             ))))))) , null),
                     ))),
                 seq(/* 171 */
                  freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -12))),    36],
                  seq(/* 172 */
                   pasclose[(int32)+(^((ref int32)%ebp),     -144)],
                   seq(/* 174 */
                    seq(
                      null,
                      ),
                    )))))))))))),
       seq(
        label121f7ffc965ab6,
        )),
     )	/* subtree */,
LocalStoreAllocator(-1,316)	/* allocator */,
1028),
   seq(
    procedure (
	label121f7ffc8f4a9a	/* internal label*/ ,
	initbmpheader	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[ref octet vector ( 54 )  ,ref int32 vector ( 9 )  ]  	/* args */,
uint8	 /* return type*/,
seq(
      seq(
        var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
        seq(
          var(mem(ref int32,+(^((ref int32)%ebp),     -32))),
          seq(
            seq(/* 91 */
              assign((ref uint8)mem(ref uint8,^(mem(ref int32,+((int32)^(%ebp),     8)))),(uint8) 66),
              seq(/* 92 */
               assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     1)),(uint8) 77),
               seq(/* 96 */
                assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     2)),+(*(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1)), +(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),     54)),
                seq(/* 97 */
                 seq(
                   seq(
                     var(mem(ref int32,+(^((ref int32)%ebp),     -8))),
                     for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     -1 ,     8 ,assign(mem(ref uint8 vector ( 8 ),+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),^(mem(ref uint8 vector ( 8 ),label121f7ffc8fbaae)))),
                     ),
                   seq(
                    for(mem(ref int32,+(^((ref int32)%ebp),     -8)),    0 ,     3 ,     1 ,assign((ref uint8)mem(ref uint8,+(^(mem(ref int32,+((int32)^(%ebp),     8))), +(^(mem(ref int32,+(^((ref int32)%ebp),     -8))),     6))),(uint8) 0)),
                    )),
                 seq(/* 98 */
                  assign((ref int32)mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     8))),     10)),    54),
                  seq(/* 138 */
                   seq(
                     assign(mem(ref int32,+(^((ref int32)%ebp),     -32)),(ref octet vector ( 40 ))+(^(mem(ref int32,+((int32)^(%ebp),     8))),     14)),
                     seq(
                      seq(/* 128 */
                        assign((ref int32)mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -32)))),    40),
                        seq(/* 129 */
                         assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     4)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     32))),     1)),
                         seq(/* 130 */
                          assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     8)),+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     20))),     1)),
                          seq(/* 131 */
                           assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     12)),(int16)  1),
                           seq(/* 132 */
                            assign((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     14)),(int16)SubField(*(+(^(mem(ref int32,+(^(mem(ref int32,+((int32)^(%ebp),     12))),     8))),     1),     8), 0,int16)),
                            seq(/* 133 */
                             assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     16)),    0),
                             seq(/* 134 */
                              assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     24)),    3780),
                              seq(/* 135 */
                               assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     28)),    3780),
                               seq(/* 136 */
                                assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     32)),    0),
                                seq(/* 137 */
                                 assign((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -32))),     36)),    0),
                                 seq(/* 138 */
                                  seq(
                                    null,
                                    ),
                                  ))))))))))),
                      )),
                   seq(/* 141 */
                    seq(
                      null,
                      ),
                    ))))))),
            seq(
             label121f7ffc8f5a9e,
             )),
          ),
        ),
      )	/* subtree */,
LocalStoreAllocator(-1,32)	/* allocator */,
8),
    )))
 has local=false		 	0
   unoptimisedcodegen procedure (
	label121f7ffc8f1a94	/* internal label*/ ,
	loadbmpfile	/* public label */ ,
	false	/* isexported */,
	false	/* imported */,
	false	/* arguments are pushed left to right */,
	false	/* callee pops args*/,
	1  	/* lexical level */,
	[uint16 vector ( 80 )  ,ref int32  ]  	/* args */,
int8	 /* return type*/,
seq(
  seq(
    seq(/* 182 */
      assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
      seq(/* 183 */
       assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
       seq(/* 184 */
        reset[(int32)+(^((ref int32)%ebp),     -148)],
        seq(/* 216 */
         seq(
           seq(
             ioresult[],
             seq(
              assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
              )),
           seq(
            if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
              seq(/* 185 */
                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                seq(/* 186 */
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       null,
                                                       seq(
                                                        seq(
                                                          length[(int32)label121f7ffc99bac4],
                                                          seq(
                                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                           )),
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            seq(
                                              length[(int32)+((int32)^(%ebp),     8)],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                ioresult[],
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                 ))),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    seq(
                      printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                      seq(
                       seq(
                         printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                         seq(
                          seq(
                            printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                            seq(
                             println[^(mem(ref int32,+(unit$system$base,     -24)))],
                             )),
                          )),
                       )),
                    )),
                 seq(/* 187 */
                  seq(
                    null,
                    ),
                  ))),
              ) , seq(/* 191 */
              seq(
                seq(
                  null,
                  seq(
                   filesize[(int32)+(^((ref int32)%ebp),     -148)],
                   seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                    ))),
                seq(
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                 )),
              seq(/* 192 */
               assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
               seq(/* 193 */
                blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                seq(/* 215 */
                 seq(
                   seq(
                     null,
                     seq(
                      assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                      )),
                   seq(
                    seq(/* 196 */
                      seq(
                        seq(
                          seq(
                            seq(
                              getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                ))),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                              ))),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                            ))),
                        seq(
                         initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                         )),
                      seq(/* 197 */
                       seq(
                         seq(
                           seq(
                             seq(
                               getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                 ))),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                               ))),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                             ))),
                         seq(
                          initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                          )),
                       seq(/* 212 */
                        if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                          seq(/* 199 */
                            assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                            seq(/* 200 */
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           null,
                                           seq(
                                            seq(
                                              length[(int32)label121f7ffc9c1ac6],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                seq(
                                  printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                  seq(
                                   println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                   )),
                                )),
                             seq(/* 201 */
                              seq(
                                null,
                                ),
                              ))),
                          ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                          seq(/* 204 */
                            assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                            seq(/* 205 */
                             seq(
                               seq(
                                 null,
                                 seq(
                                  label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                   ))),
                               seq(
                                if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                  seq(
                                    seq(
                                      null,
                                      seq(
                                       label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                        ))),
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                     )),
                                  ) , seq(
                                  null,
                                  )),
                                )),
                             seq(/* 208 */
                              seq(
                                var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                seq(
                                  seq(
                                    null,
                                    ),
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                   )),
                                seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                 null,
                                 seq(
                                  var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                  if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                    seq(
                                     label121f7ffc9c5aca,
                                     seq(
                                      seq(
                                        seq(
                                          seq(
                                            if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                            seq(
                                             if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                             )),
                                          seq(
                                           if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                           )),
                                        seq(
                                         blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                         )),
                                      seq(
                                       if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                        seq(
                                         goto(label121f7ffc9c5aca),
                                         seq(
                                          label121f7ffc9c5ac8,
                                          ))))))) , null),
                                  ))),
                              seq(/* 209 */
                               seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                 seq(
                                   null,
                                   seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                    seq(
                                     seq(
                                       seq(
                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                          )),
                                       seq(
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                          var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                            var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                              seq(
                                                seq(
                                                  if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                  seq(
                                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                   )),
                                                seq(
                                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                               ))),
                                            )),
                                          )),
                                        )),
                                     ))),
                                 ),
                               seq(/* 211 */
                                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                seq(/* 212 */
                                 seq(
                                   null,
                                   ),
                                 )))))),
                          ) , seq(
                          null,
                          ))),
                        seq(/* 213 */
                         freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                         seq(/* 214 */
                          pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                          seq(/* 215 */
                           seq(
                             null,
                             ),
                           )))))),
                    )),
                 seq(/* 216 */
                  seq(
                    null,
                    ),
                  )))))),
            )),
         seq(/* 217 */
          seq(
            null,
            ),
          ))))),
    seq(
     label121f7ffc999ac2,
     seq(
      ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
      ))),
  )	/* subtree */,
LocalStoreAllocator(-1,424)	/* allocator */,
164)		 	0
   unoptimisedcodegen  begin seq(
  seq(
    seq(/* 182 */
      assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
      seq(/* 183 */
       assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
       seq(/* 184 */
        reset[(int32)+(^((ref int32)%ebp),     -148)],
        seq(/* 216 */
         seq(
           seq(
             ioresult[],
             seq(
              assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
              )),
           seq(
            if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
              seq(/* 185 */
                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                seq(/* 186 */
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       null,
                                                       seq(
                                                        seq(
                                                          length[(int32)label121f7ffc99bac4],
                                                          seq(
                                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                           )),
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            seq(
                                              length[(int32)+((int32)^(%ebp),     8)],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                ioresult[],
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                 ))),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    seq(
                      printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                      seq(
                       seq(
                         printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                         seq(
                          seq(
                            printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                            seq(
                             println[^(mem(ref int32,+(unit$system$base,     -24)))],
                             )),
                          )),
                       )),
                    )),
                 seq(/* 187 */
                  seq(
                    null,
                    ),
                  ))),
              ) , seq(/* 191 */
              seq(
                seq(
                  null,
                  seq(
                   filesize[(int32)+(^((ref int32)%ebp),     -148)],
                   seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                    ))),
                seq(
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                 )),
              seq(/* 192 */
               assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
               seq(/* 193 */
                blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                seq(/* 215 */
                 seq(
                   seq(
                     null,
                     seq(
                      assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                      )),
                   seq(
                    seq(/* 196 */
                      seq(
                        seq(
                          seq(
                            seq(
                              getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                ))),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                              ))),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                            ))),
                        seq(
                         initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                         )),
                      seq(/* 197 */
                       seq(
                         seq(
                           seq(
                             seq(
                               getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                 ))),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                               ))),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                             ))),
                         seq(
                          initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                          )),
                       seq(/* 212 */
                        if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                          seq(/* 199 */
                            assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                            seq(/* 200 */
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           null,
                                           seq(
                                            seq(
                                              length[(int32)label121f7ffc9c1ac6],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                seq(
                                  printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                  seq(
                                   println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                   )),
                                )),
                             seq(/* 201 */
                              seq(
                                null,
                                ),
                              ))),
                          ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                          seq(/* 204 */
                            assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                            seq(/* 205 */
                             seq(
                               seq(
                                 null,
                                 seq(
                                  label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                   ))),
                               seq(
                                if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                  seq(
                                    seq(
                                      null,
                                      seq(
                                       label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                        ))),
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                     )),
                                  ) , seq(
                                  null,
                                  )),
                                )),
                             seq(/* 208 */
                              seq(
                                var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                seq(
                                  seq(
                                    null,
                                    ),
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                   )),
                                seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                 null,
                                 seq(
                                  var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                  if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                    seq(
                                     label121f7ffc9c5aca,
                                     seq(
                                      seq(
                                        seq(
                                          seq(
                                            if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                            seq(
                                             if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                             )),
                                          seq(
                                           if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                           )),
                                        seq(
                                         blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                         )),
                                      seq(
                                       if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                        seq(
                                         goto(label121f7ffc9c5aca),
                                         seq(
                                          label121f7ffc9c5ac8,
                                          ))))))) , null),
                                  ))),
                              seq(/* 209 */
                               seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                 seq(
                                   null,
                                   seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                    seq(
                                     seq(
                                       seq(
                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                          )),
                                       seq(
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                          var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                            var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                              seq(
                                                seq(
                                                  if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                  seq(
                                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                   )),
                                                seq(
                                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                               ))),
                                            )),
                                          )),
                                        )),
                                     ))),
                                 ),
                               seq(/* 211 */
                                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                seq(/* 212 */
                                 seq(
                                   null,
                                   ),
                                 )))))),
                          ) , seq(
                          null,
                          ))),
                        seq(/* 213 */
                         freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                         seq(/* 214 */
                          pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                          seq(/* 215 */
                           seq(
                             null,
                             ),
                           )))))),
                    )),
                 seq(/* 216 */
                  seq(
                    null,
                    ),
                  )))))),
            )),
         seq(/* 217 */
          seq(
            null,
            ),
          ))))),
    seq(
     label121f7ffc999ac2,
     seq(
      ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
      ))),
  ) end 		 	0
    unoptimisedcodegen seq(
  seq(
    seq(/* 182 */
      assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
      seq(/* 183 */
       assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
       seq(/* 184 */
        reset[(int32)+(^((ref int32)%ebp),     -148)],
        seq(/* 216 */
         seq(
           seq(
             ioresult[],
             seq(
              assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
              )),
           seq(
            if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
              seq(/* 185 */
                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                seq(/* 186 */
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       null,
                                                       seq(
                                                        seq(
                                                          length[(int32)label121f7ffc99bac4],
                                                          seq(
                                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                           )),
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            seq(
                                              length[(int32)+((int32)^(%ebp),     8)],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                ioresult[],
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                 ))),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    seq(
                      printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                      seq(
                       seq(
                         printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                         seq(
                          seq(
                            printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                            seq(
                             println[^(mem(ref int32,+(unit$system$base,     -24)))],
                             )),
                          )),
                       )),
                    )),
                 seq(/* 187 */
                  seq(
                    null,
                    ),
                  ))),
              ) , seq(/* 191 */
              seq(
                seq(
                  null,
                  seq(
                   filesize[(int32)+(^((ref int32)%ebp),     -148)],
                   seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                    ))),
                seq(
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                 )),
              seq(/* 192 */
               assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
               seq(/* 193 */
                blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                seq(/* 215 */
                 seq(
                   seq(
                     null,
                     seq(
                      assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                      )),
                   seq(
                    seq(/* 196 */
                      seq(
                        seq(
                          seq(
                            seq(
                              getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                ))),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                              ))),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                            ))),
                        seq(
                         initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                         )),
                      seq(/* 197 */
                       seq(
                         seq(
                           seq(
                             seq(
                               getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                 ))),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                               ))),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                             ))),
                         seq(
                          initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                          )),
                       seq(/* 212 */
                        if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                          seq(/* 199 */
                            assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                            seq(/* 200 */
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           null,
                                           seq(
                                            seq(
                                              length[(int32)label121f7ffc9c1ac6],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                seq(
                                  printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                  seq(
                                   println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                   )),
                                )),
                             seq(/* 201 */
                              seq(
                                null,
                                ),
                              ))),
                          ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                          seq(/* 204 */
                            assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                            seq(/* 205 */
                             seq(
                               seq(
                                 null,
                                 seq(
                                  label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                   ))),
                               seq(
                                if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                  seq(
                                    seq(
                                      null,
                                      seq(
                                       label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                        ))),
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                     )),
                                  ) , seq(
                                  null,
                                  )),
                                )),
                             seq(/* 208 */
                              seq(
                                var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                seq(
                                  seq(
                                    null,
                                    ),
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                   )),
                                seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                 null,
                                 seq(
                                  var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                  if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                    seq(
                                     label121f7ffc9c5aca,
                                     seq(
                                      seq(
                                        seq(
                                          seq(
                                            if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                            seq(
                                             if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                             )),
                                          seq(
                                           if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                           )),
                                        seq(
                                         blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                         )),
                                      seq(
                                       if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                        seq(
                                         goto(label121f7ffc9c5aca),
                                         seq(
                                          label121f7ffc9c5ac8,
                                          ))))))) , null),
                                  ))),
                              seq(/* 209 */
                               seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                 seq(
                                   null,
                                   seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                    seq(
                                     seq(
                                       seq(
                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                          )),
                                       seq(
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                          var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                            var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                              seq(
                                                seq(
                                                  if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                  seq(
                                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                   )),
                                                seq(
                                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                               ))),
                                            )),
                                          )),
                                        )),
                                     ))),
                                 ),
                               seq(/* 211 */
                                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                seq(/* 212 */
                                 seq(
                                   null,
                                   ),
                                 )))))),
                          ) , seq(
                          null,
                          ))),
                        seq(/* 213 */
                         freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                         seq(/* 214 */
                          pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                          seq(/* 215 */
                           seq(
                             null,
                             ),
                           )))))),
                    )),
                 seq(/* 216 */
                  seq(
                    null,
                    ),
                  )))))),
            )),
         seq(/* 217 */
          seq(
            null,
            ),
          ))))),
    seq(
     label121f7ffc999ac2,
     seq(
      ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
      ))),
  )		 	0
    cgstatement optlevel=0:seq(
  seq(
    seq(/* 182 */
      assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
      seq(/* 183 */
       assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
       seq(/* 184 */
        reset[(int32)+(^((ref int32)%ebp),     -148)],
        seq(/* 216 */
         seq(
           seq(
             ioresult[],
             seq(
              assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
              )),
           seq(
            if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
              seq(/* 185 */
                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                seq(/* 186 */
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     seq(
                                                       null,
                                                       seq(
                                                        seq(
                                                          length[(int32)label121f7ffc99bac4],
                                                          seq(
                                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                           )),
                                                        )),
                                                     seq(
                                                      null,
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            seq(
                                              length[(int32)+((int32)^(%ebp),     8)],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                ioresult[],
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                                 ))),
                             seq(
                              null,
                              )),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    seq(
                      printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                      seq(
                       seq(
                         printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                         seq(
                          seq(
                            printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                            seq(
                             println[^(mem(ref int32,+(unit$system$base,     -24)))],
                             )),
                          )),
                       )),
                    )),
                 seq(/* 187 */
                  seq(
                    null,
                    ),
                  ))),
              ) , seq(/* 191 */
              seq(
                seq(
                  null,
                  seq(
                   filesize[(int32)+(^((ref int32)%ebp),     -148)],
                   seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                    ))),
                seq(
                 assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
                 )),
              seq(/* 192 */
               assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
               seq(/* 193 */
                blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
                seq(/* 215 */
                 seq(
                   seq(
                     null,
                     seq(
                      assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                      )),
                   seq(
                    seq(/* 196 */
                      seq(
                        seq(
                          seq(
                            seq(
                              getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                                ))),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                              ))),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                            ))),
                        seq(
                         initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                         )),
                      seq(/* 197 */
                       seq(
                         seq(
                           seq(
                             seq(
                               getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                               seq(
                                assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                                seq(
                                 assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                                 ))),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                               ))),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                             ))),
                         seq(
                          initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                          )),
                       seq(/* 212 */
                        if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                          seq(/* 199 */
                            assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                            seq(/* 200 */
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           null,
                                           seq(
                                            seq(
                                              length[(int32)label121f7ffc9c1ac6],
                                              seq(
                                               assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                               )),
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                seq(
                                  printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                  seq(
                                   println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                   )),
                                )),
                             seq(/* 201 */
                              seq(
                                null,
                                ),
                              ))),
                          ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                          seq(/* 204 */
                            assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                            seq(/* 205 */
                             seq(
                               seq(
                                 null,
                                 seq(
                                  label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                   ))),
                               seq(
                                if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                  seq(
                                    seq(
                                      null,
                                      seq(
                                       label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                        ))),
                                    seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                     )),
                                  ) , seq(
                                  null,
                                  )),
                                )),
                             seq(/* 208 */
                              seq(
                                var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                seq(
                                  seq(
                                    null,
                                    ),
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                   )),
                                seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                 null,
                                 seq(
                                  var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                  if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                    seq(
                                     label121f7ffc9c5aca,
                                     seq(
                                      seq(
                                        seq(
                                          seq(
                                            if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                            seq(
                                             if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                             )),
                                          seq(
                                           if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                           )),
                                        seq(
                                         blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                         )),
                                      seq(
                                       if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                        seq(
                                         goto(label121f7ffc9c5aca),
                                         seq(
                                          label121f7ffc9c5ac8,
                                          ))))))) , null),
                                  ))),
                              seq(/* 209 */
                               seq(
                                 var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                                 seq(
                                   null,
                                   seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                    seq(
                                     seq(
                                       seq(
                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                         seq(
                                          assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                          )),
                                       seq(
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                          var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                            var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                            for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                              seq(
                                                seq(
                                                  if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                  seq(
                                                   if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                   )),
                                                seq(
                                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                               ))),
                                            )),
                                          )),
                                        )),
                                     ))),
                                 ),
                               seq(/* 211 */
                                assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                                seq(/* 212 */
                                 seq(
                                   null,
                                   ),
                                 )))))),
                          ) , seq(
                          null,
                          ))),
                        seq(/* 213 */
                         freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                         seq(/* 214 */
                          pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                          seq(/* 215 */
                           seq(
                             null,
                             ),
                           )))))),
                    )),
                 seq(/* 216 */
                  seq(
                    null,
                    ),
                  )))))),
            )),
         seq(/* 217 */
          seq(
            null,
            ),
          ))))),
    seq(
     label121f7ffc999ac2,
     seq(
      ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
      ))),
  )
 has local=false		 	0
     unoptimisedcodegen seq(
  seq(/* 182 */
    assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
    seq(/* 183 */
     assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
     seq(/* 184 */
      reset[(int32)+(^((ref int32)%ebp),     -148)],
      seq(/* 216 */
       seq(
         seq(
           ioresult[],
           seq(
            assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
            )),
         seq(
          if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
            seq(/* 185 */
              assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
              seq(/* 186 */
               seq(
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     null,
                                                     seq(
                                                      seq(
                                                        length[(int32)label121f7ffc99bac4],
                                                        seq(
                                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                         )),
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          seq(
                                            length[(int32)+((int32)^(%ebp),     8)],
                                            seq(
                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                             )),
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              ioresult[],
                              seq(
                               assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                               ))),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    null,
                    )),
                 seq(
                  seq(
                    printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                    seq(
                     seq(
                       printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                       seq(
                        seq(
                          printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                          seq(
                           println[^(mem(ref int32,+(unit$system$base,     -24)))],
                           )),
                        )),
                     )),
                  )),
               seq(/* 187 */
                seq(
                  null,
                  ),
                ))),
            ) , seq(/* 191 */
            seq(
              seq(
                null,
                seq(
                 filesize[(int32)+(^((ref int32)%ebp),     -148)],
                 seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                  ))),
              seq(
               assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
               )),
            seq(/* 192 */
             assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
             seq(/* 193 */
              blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
              seq(/* 215 */
               seq(
                 seq(
                   null,
                   seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                    )),
                 seq(
                  seq(/* 196 */
                    seq(
                      seq(
                        seq(
                          seq(
                            getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                              ))),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                            ))),
                        seq(
                         assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                         seq(
                          assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                          ))),
                      seq(
                       initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                       )),
                    seq(/* 197 */
                     seq(
                       seq(
                         seq(
                           seq(
                             getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                               ))),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                             ))),
                         seq(
                          assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                           ))),
                       seq(
                        initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                        )),
                     seq(/* 212 */
                      if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                        seq(/* 199 */
                          assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                          seq(/* 200 */
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         null,
                                         seq(
                                          seq(
                                            length[(int32)label121f7ffc9c1ac6],
                                            seq(
                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                             )),
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              seq(
                                printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                seq(
                                 println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                 )),
                              )),
                           seq(/* 201 */
                            seq(
                              null,
                              ),
                            ))),
                        ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                        seq(/* 204 */
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                          seq(/* 205 */
                           seq(
                             seq(
                               null,
                               seq(
                                label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                 ))),
                             seq(
                              if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                seq(
                                  seq(
                                    null,
                                    seq(
                                     label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                      ))),
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                   )),
                                ) , seq(
                                null,
                                )),
                              )),
                           seq(/* 208 */
                            seq(
                              var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                              seq(
                                seq(
                                  null,
                                  ),
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                 )),
                              seq(
                               var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                               null,
                               seq(
                                var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                  assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                  seq(
                                   label121f7ffc9c5aca,
                                   seq(
                                    seq(
                                      seq(
                                        seq(
                                          if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                          seq(
                                           if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                           )),
                                        seq(
                                         if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                         )),
                                      seq(
                                       blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                       )),
                                    seq(
                                     if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                      seq(
                                       goto(label121f7ffc9c5aca),
                                       seq(
                                        label121f7ffc9c5ac8,
                                        ))))))) , null),
                                ))),
                            seq(/* 209 */
                             seq(
                               var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                               seq(
                                 null,
                                 seq(
                                  assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                  seq(
                                   seq(
                                     seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                        )),
                                     seq(
                                      for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                        var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                          var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                            seq(
                                              seq(
                                                if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                seq(
                                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                               )),
                                            seq(
                                             assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                             ))),
                                          )),
                                        )),
                                      )),
                                   ))),
                               ),
                             seq(/* 211 */
                              assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                              seq(/* 212 */
                               seq(
                                 null,
                                 ),
                               )))))),
                        ) , seq(
                        null,
                        ))),
                      seq(/* 213 */
                       freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                       seq(/* 214 */
                        pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                        seq(/* 215 */
                         seq(
                           null,
                           ),
                         )))))),
                  )),
               seq(/* 216 */
                seq(
                  null,
                  ),
                )))))),
          )),
       seq(/* 217 */
        seq(
          null,
          ),
        ))))),
  seq(
   label121f7ffc999ac2,
   seq(
    ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
    )))		 	0
     cgstatement optlevel=0:seq(
  seq(/* 182 */
    assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
    seq(/* 183 */
     assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
     seq(/* 184 */
      reset[(int32)+(^((ref int32)%ebp),     -148)],
      seq(/* 216 */
       seq(
         seq(
           ioresult[],
           seq(
            assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
            )),
         seq(
          if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
            seq(/* 185 */
              assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
              seq(/* 186 */
               seq(
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   seq(
                                                     null,
                                                     seq(
                                                      seq(
                                                        length[(int32)label121f7ffc99bac4],
                                                        seq(
                                                         assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                         )),
                                                      )),
                                                   seq(
                                                    null,
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          seq(
                                            length[(int32)+((int32)^(%ebp),     8)],
                                            seq(
                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                             )),
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              ioresult[],
                              seq(
                               assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                               ))),
                           seq(
                            null,
                            )),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    null,
                    )),
                 seq(
                  seq(
                    printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                    seq(
                     seq(
                       printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                       seq(
                        seq(
                          printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                          seq(
                           println[^(mem(ref int32,+(unit$system$base,     -24)))],
                           )),
                        )),
                     )),
                  )),
               seq(/* 187 */
                seq(
                  null,
                  ),
                ))),
            ) , seq(/* 191 */
            seq(
              seq(
                null,
                seq(
                 filesize[(int32)+(^((ref int32)%ebp),     -148)],
                 seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                  ))),
              seq(
               assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
               )),
            seq(/* 192 */
             assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
             seq(/* 193 */
              blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
              seq(/* 215 */
               seq(
                 seq(
                   null,
                   seq(
                    assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                    )),
                 seq(
                  seq(/* 196 */
                    seq(
                      seq(
                        seq(
                          seq(
                            getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                              ))),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                            ))),
                        seq(
                         assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                         seq(
                          assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                          ))),
                      seq(
                       initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                       )),
                    seq(/* 197 */
                     seq(
                       seq(
                         seq(
                           seq(
                             getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                             seq(
                              assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                              seq(
                               assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                               ))),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                             ))),
                         seq(
                          assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                           ))),
                       seq(
                        initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                        )),
                     seq(/* 212 */
                      if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                        seq(/* 199 */
                          assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                          seq(/* 200 */
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         null,
                                         seq(
                                          seq(
                                            length[(int32)label121f7ffc9c1ac6],
                                            seq(
                                             assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                             )),
                                          )),
                                       seq(
                                        null,
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              seq(
                                printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                                seq(
                                 println[^(mem(ref int32,+(unit$system$base,     -24)))],
                                 )),
                              )),
                           seq(/* 201 */
                            seq(
                              null,
                              ),
                            ))),
                        ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                        seq(/* 204 */
                          assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                          seq(/* 205 */
                           seq(
                             seq(
                               null,
                               seq(
                                label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                                 ))),
                             seq(
                              if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                                seq(
                                  seq(
                                    null,
                                    seq(
                                     label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                      ))),
                                  seq(
                                   assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                   )),
                                ) , seq(
                                null,
                                )),
                              )),
                           seq(/* 208 */
                            seq(
                              var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                              seq(
                                seq(
                                  null,
                                  ),
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                 )),
                              seq(
                               var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                               null,
                               seq(
                                var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                                if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                  assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                  seq(
                                   label121f7ffc9c5aca,
                                   seq(
                                    seq(
                                      seq(
                                        seq(
                                          if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                          seq(
                                           if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                           )),
                                        seq(
                                         if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                         )),
                                      seq(
                                       blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                       )),
                                    seq(
                                     if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                      seq(
                                       goto(label121f7ffc9c5aca),
                                       seq(
                                        label121f7ffc9c5ac8,
                                        ))))))) , null),
                                ))),
                            seq(/* 209 */
                             seq(
                               var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                               seq(
                                 null,
                                 seq(
                                  assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                  seq(
                                   seq(
                                     seq(
                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                       seq(
                                        assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                        )),
                                     seq(
                                      for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                        var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                          var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                          for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                            seq(
                                              seq(
                                                if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                                seq(
                                                 if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                                 )),
                                              seq(
                                               if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                               )),
                                            seq(
                                             assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                             ))),
                                          )),
                                        )),
                                      )),
                                   ))),
                               ),
                             seq(/* 211 */
                              assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                              seq(/* 212 */
                               seq(
                                 null,
                                 ),
                               )))))),
                        ) , seq(
                        null,
                        ))),
                      seq(/* 213 */
                       freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                       seq(/* 214 */
                        pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                        seq(/* 215 */
                         seq(
                           null,
                           ),
                         )))))),
                  )),
               seq(/* 216 */
                seq(
                  null,
                  ),
                )))))),
          )),
       seq(/* 217 */
        seq(
          null,
          ),
        ))))),
  seq(
   label121f7ffc999ac2,
   seq(
    ret((int8)^(mem(ref int8,+(^((ref int32)%ebp),     -5)))),
    )))
 has local=false		 	0
      unoptimisedcodegen seq(/* 182 */
  assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
  seq(/* 183 */
   assign[(int32)+(^((ref int32)%ebp),     -148),(int32)+((int32)^(%ebp),     8)],
   seq(/* 184 */
    reset[(int32)+(^((ref int32)%ebp),     -148)],
    seq(/* 216 */
     seq(
       seq(
         ioresult[],
         seq(
          assign(mem(ref int32,+(^((ref int32)%ebp),     -152)),^(%eax)),
          )),
       seq(
        if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -152))),     0),seq(
          seq(/* 185 */
            assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
            seq(/* 186 */
             seq(
               seq(
                 seq(
                   seq(
                     seq(
                       seq(
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       seq(
                                         seq(
                                           seq(
                                             seq(
                                               seq(
                                                 seq(
                                                   null,
                                                   seq(
                                                    seq(
                                                      length[(int32)label121f7ffc99bac4],
                                                      seq(
                                                       assign(mem(ref int32,+(^((ref int32)%ebp),     -176)),^(%eax)),
                                                       )),
                                                    )),
                                                 seq(
                                                  null,
                                                  )),
                                               seq(
                                                null,
                                                )),
                                             seq(
                                              null,
                                              )),
                                           seq(
                                            null,
                                            )),
                                         seq(
                                          null,
                                          )),
                                       seq(
                                        seq(
                                          length[(int32)+((int32)^(%ebp),     8)],
                                          seq(
                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -200)),^(%eax)),
                                           )),
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              null,
                              )),
                           seq(
                            ioresult[],
                            seq(
                             assign(mem(ref int32,+(^((ref int32)%ebp),     -224)),^(%eax)),
                             ))),
                         seq(
                          null,
                          )),
                       seq(
                        null,
                        )),
                     seq(
                      null,
                      )),
                   seq(
                    null,
                    )),
                 seq(
                  null,
                  )),
               seq(
                seq(
                  printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc99bac4,^(mem(ref int32,+(^((ref int32)%ebp),     -176))),    5],
                  seq(
                   seq(
                     printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)+((int32)^(%ebp),     8),^(mem(ref int32,+(^((ref int32)%ebp),     -200))),    5],
                     seq(
                      seq(
                        printint[^(mem(ref int32,+(unit$system$base,     -24))),(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -224))),    12,    5],
                        seq(
                         println[^(mem(ref int32,+(unit$system$base,     -24)))],
                         )),
                      )),
                   )),
                )),
             seq(/* 187 */
              seq(
                null,
                ),
              ))),
          ) , seq(/* 191 */
          seq(
            seq(
              null,
              seq(
               filesize[(int32)+(^((ref int32)%ebp),     -148)],
               seq(
                assign(mem(ref int32,+(^((ref int32)%ebp),     -228)),^(%eax)),
                ))),
            seq(
             assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),^(mem(ref int32,+(^((ref int32)%ebp),     -228)))),
             )),
          seq(/* 192 */
           assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    54),
           seq(/* 193 */
            blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(^((ref int32)%ebp),     -108),^(mem(ref int32,+(^((ref int32)%ebp),     -120))),(int32)+(^((ref int32)%ebp),     -144)],
            seq(/* 215 */
             seq(
               seq(
                 null,
                 seq(
                  assign(mem(ref int32,+(^((ref int32)%ebp),     -232)),(ref octet vector ( 40 ))+(^((ref int32)%ebp),     -94)),
                  )),
               seq(
                seq(/* 196 */
                  seq(
                    seq(
                      seq(
                        seq(
                          getmem[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    36],
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     4)),    0),
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)),    2),
                            ))),
                        seq(
                         assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     16)),    0),
                         seq(
                          assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                          ))),
                      seq(
                       assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     28)),    0),
                       seq(
                        assign(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                        ))),
                    seq(
                     initvec[(int32)^(mem(ref int32,+((int32)^(%ebp),     168))),    3,(int32)    1],
                     )),
                  seq(/* 197 */
                   seq(
                     seq(
                       seq(
                         seq(
                           getmem[(int32)+(^((ref int32)%ebp),     -112),    36],
                           seq(
                            assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     4)),    0),
                            seq(
                             assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     8))),     -1)),
                             ))),
                         seq(
                          assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     16)),    0),
                          seq(
                           assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20)),+(^((ref int32)mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     4))),     -1)),
                           ))),
                       seq(
                        assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     28)),    0),
                        seq(
                         assign(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32)),    2),
                         ))),
                     seq(
                      initvec[(int32)+(^((ref int32)%ebp),     -112),    3,(int32)    1],
                      )),
                   seq(/* 212 */
                    if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     8),seq(
                      seq(/* 199 */
                        assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) 0),
                        seq(/* 200 */
                         seq(
                           seq(
                             seq(
                               seq(
                                 seq(
                                   seq(
                                     seq(
                                       null,
                                       seq(
                                        seq(
                                          length[(int32)label121f7ffc9c1ac6],
                                          seq(
                                           assign(mem(ref int32,+(^((ref int32)%ebp),     -256)),^(%eax)),
                                           )),
                                        )),
                                     seq(
                                      null,
                                      )),
                                   seq(
                                    null,
                                    )),
                                 seq(
                                  null,
                                  )),
                               seq(
                                null,
                                )),
                             seq(
                              null,
                              )),
                           seq(
                            seq(
                              printstring[^(mem(ref int32,+(unit$system$base,     -24))),(int32)label121f7ffc9c1ac6,^(mem(ref int32,+(^((ref int32)%ebp),     -256))),    5],
                              seq(
                               println[^(mem(ref int32,+(unit$system$base,     -24)))],
                               )),
                            )),
                         seq(/* 201 */
                          seq(
                            null,
                            ),
                          ))),
                      ) , if((int8)=(EXTEND(^((ref int16)mem(ref int16,+(^(mem(ref int32,+(^((ref int32)%ebp),     -232))),     14)))),     24),seq(
                      seq(/* 204 */
                        assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),*(+(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8))),     1), +(^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32))),     1))),
                        seq(/* 205 */
                         seq(
                           seq(
                             null,
                             seq(
                              label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                              seq(
                               assign(mem(ref int32,+(^((ref int32)%ebp),     -260)),^(%eax)),
                               ))),
                           seq(
                            if((int8)<>(^(mem(ref int32,+(^((ref int32)%ebp),     -260))),     0),seq(
                              seq(
                                seq(
                                  null,
                                  seq(
                                   label121f7ffadca1b0[(int32)^(mem(ref int32,+(^((ref int32)%ebp),     -116))),    4],
                                   seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -264)),^(%eax)),
                                    ))),
                                seq(
                                 assign(mem(ref int32,+(^((ref int32)%ebp),     -116)),-(+(^(mem(ref int32,+(^((ref int32)%ebp),     -116))),     4), ^(mem(ref int32,+(^((ref int32)%ebp),     -264))))),
                                 )),
                              ) , seq(
                              null,
                              )),
                            )),
                         seq(/* 208 */
                          seq(
                            var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                            seq(
                              seq(
                                null,
                                ),
                              seq(
                               assign(mem(ref int32,+(^((ref int32)%ebp),     -268)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                               )),
                            seq(
                             var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                             null,
                             seq(
                              var(mem(ref int32,+(^((ref int32)%ebp),     -120))),
                              if((int8)<=(    0, ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),seq(
                                assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),    0),
                                seq(
                                 label121f7ffc9c5aca,
                                 seq(
                                  seq(
                                    seq(
                                      seq(
                                        if(OR(<(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     0), >(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))))),Fail(    5) , null),
                                        seq(
                                         if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))))),Fail(    5) , null),
                                         )),
                                      seq(
                                       if(OR( 0, >(    0, ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))))),Fail(    5) , null),
                                       )),
                                    seq(
                                     blockread[(int32)+(^((ref int32)%ebp),     -148),(int32)+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112)))))),^(mem(ref int32,+(^((ref int32)%ebp),     -116))),(int32)+(^((ref int32)%ebp),     -144)],
                                     )),
                                  seq(
                                   if((int8)=(^(mem(ref int32,+(^((ref int32)%ebp),     -120))), ^(mem(ref int32,+(^((ref int32)%ebp),     -268)))),goto(label121f7ffc9c5ac8) , null),
                                   seq(
                                    assign(mem(ref int32,+(^((ref int32)%ebp),     -120)),+(^(mem(ref int32,+(^((ref int32)%ebp),     -120))),     1)),
                                    seq(
                                     goto(label121f7ffc9c5aca),
                                     seq(
                                      label121f7ffc9c5ac8,
                                      ))))))) , null),
                              ))),
                          seq(/* 209 */
                           seq(
                             var(mem(ref int32,+(^((ref int32)%ebp),     -320))),
                             seq(
                               null,
                               seq(
                                assign(mem(ref int32,+(^((ref int32)%ebp),     -424)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     8)))),
                                seq(
                                 seq(
                                   seq(
                                     assign(mem(ref int32,+(^((ref int32)%ebp),     -420)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     20)))),
                                     seq(
                                      assign(mem(ref int32,+(^((ref int32)%ebp),     -416)),^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     32)))),
                                      )),
                                   seq(
                                    for(mem(ref int32,+(^((ref int32)%ebp),     -320)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -424))) ,     1 ,seq(
                                      var(mem(ref int32,+(^((ref int32)%ebp),     -324))),
                                      for(mem(ref int32,+(^((ref int32)%ebp),     -324)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -420))) ,     1 ,seq(
                                        var(mem(ref int32,+(^((ref int32)%ebp),     -328))),
                                        for(mem(ref int32,+(^((ref int32)%ebp),     -328)),    0 , ^(mem(ref int32,+(^((ref int32)%ebp),     -416))) ,     1 ,seq(
                                          seq(
                                            seq(
                                              if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     8))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -324))),Fail(    5) , null),
                                              seq(
                                               if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     20))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -328))),Fail(    5) , null),
                                               )),
                                            seq(
                                             if((int8)<(^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     32))), (int32)mem(ref int32,+(^((ref int32)%ebp),     -320))),Fail(    5) , null),
                                             )),
                                          seq(
                                           assign(mem(ref int8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -320))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -328))))), ^(mem(ref int32,^(mem(ref int32,^(mem(ref int32,+((int32)^(%ebp),     168))))))))),SubField(+(EXTEND(^(mem(ref uint8,+(+(*(^(mem(ref int32,+(^((ref int32)%ebp),     -324))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     12)))), +(*(^(mem(ref int32,+(^((ref int32)%ebp),     -328))), ^(mem(ref int32,+(^(mem(ref int32,+(^((ref int32)%ebp),     -112))),     24)))), ^(mem(ref int32,+(^((ref int32)%ebp),     -320))))), ^(mem(ref int32,^(mem(ref int32,+(^((ref int32)%ebp),     -112))))))))),     -128), 0,int8)),
                                           ))),
                                        )),
                                      )),
                                    )),
                                 ))),
                             ),
                           seq(/* 211 */
                            assign(mem(ref int8,+(^((ref int32)%ebp),     -5)),(int8) -1),
                            seq(/* 212 */
                             seq(
                               null,
                               ),
                             )))))),
                      ) , seq(
                      null,
                      ))),
                    seq(/* 213 */
                     freemem[(ref uint8)^(mem(ref int32,+(^((ref int32)%ebp),     -112))),    36],
                     seq(/* 214 */
                      pasclose[(int32)+(^((ref int32)%ebp),     -148)],
                      seq(/* 215 */
                       seq(
                         null,
                         ),
                       )))))),
                )),
             seq(/* 216 */
              seq(
                null,
                ),
              )))))),
        )),
     seq(/* 217 */
      seq(
        null,
        ),
      )))))		 	0
Debug log from code generator class ilcg.tree.gnuP4CG
