Input/Output
================

STJB,A001,ENGR,WX
	FEB17-0810 JOB# 0026
JBID, JOB-26
	JOB #0026 SPOOLING IN
LOCT,JOB-7
	JOB #0007 UNDEFINED
	HOLD, JOB-9
	SPAC,PRINTER-1
 	REPEAT,PRINTER-1
  	ERR 0
REPT,PRINTER-!
RSTI,PRINTER-1
RELS,JOB-9
JBID,0
 	JOB #0009 	SPOOLING OUT
 	JOB #0011	1/O WAIT
 	JOB #0015	FXECUTING
 	JOB #0026 	SPOOLING IN


LISTING
============

BEGIN	<<EXAMPLE 2-2. COMMAND INTERPRETER>>
BYTE ARRAY IMAGE(0:81);
ARRAY WORDBUF(*)=IMAGE;
INTEGER LENGTH,
		ERCODE;
BYTE POINTER IMAGPIR:=@IMAGE;
BYTE ARRAY EBUF(0:3):= "ERR ";
ARRAY MNEM(0:41):=%100000,%000001,	<<STOPPER>>
			"ALTR", "BKLG", "BKSP", "DLTD", "DLTJ",	<<1>>
			"DRIN", "DSPL", "HOLD", "JBID", "LIST",	<<6>>
			"LOCT", "RELS", "REPT", "RSTT", "SPAC",	<<11>>
			"STAT", "STJB", "STOP", "STRT"			<<16>>
			%077777,%177777			<<STOPPER>>;	<<20>>
LABEL READ;
DEFINE PROCHEAD = (OPERANDPTR,ERRORCODE);

VALUE OPERANDPIR;
BYTE POINTER OPERANDPIR;	<<ADR COMMAND OPERAND>>
INTEGER ERRORCODE;			<<ERROR NUMBER RETURN>>
OPTION EXTERNAL
#;


DEFINE DUPLICATE = ASSEMBLE(DUP)#;
PROCEDURE ALTR PROCHEAD;	<<CHANGE JOB PRIORITY>>
PROCEDURE BKLG PROCHEAD;	<<DISPLAY QUEUED JOBS>>
PROCEDURE BKSP PROCHEAD;	<<BACKSPACE DEVICE>>
PROCEDURE DLDT PROCHEAD;	<<DELETE DEVICE OUTPUT>>
PROCEDURE DLTJ PROCHEAD;	<< CANCEL JOB>>
PROCEDURE DRIN PROCHEAD;	<<DRAIN PHYSICAL DEVICE>>
PROCEDURE DSPL PROCHEAD;	<<DISPLAY SYSTEM INFORMATION>>
PROCEDURE HOLD PROCHEAD;	<<PREVENT EXECUTION OF A JOB OR JOBS>>
PROCEDURE JBID PROCHEAD;	<<DISPLAY JOB INFORMATION>>
PROCEDURE LIST PROCHEAD;	<<MESSAGE LISTING CONTROL>>
PROCEDURE LOCT PROCHEAD:	<<LOCATE A JOB IN THE SYSTEM>>
PROCEDURE RELS PROCHEAD:	<<RELEASE HELD JOB OR JOBS>>
PROCEDURE REPT PROCHEAD;	<<REPEAT CURRENT I/0 OPERATION>>
PROCEDURE RSIT PROCHEAD;	<<ABORT AND RESTART CURRENT OPERATION>>
PROCEDURE SPAC PROCHEAD;	<<SINGLE SPACE DEVICE>>
PROCEDURE STAT PROCHEAD;	<<DISPLAY ACTIVITY STATUS>>
PROCEDURE SIJB PROCHEAD;	<<START A JOB>>
PROCEDURE STOP PROCHEAD;	<<STOP ALL OPERATIONS>>

INTEGER NI:=O, N2:=20, K=X;
BYTE ARRAY T1 (0:3)=Q;
LABEL NEXT,LESSL, FOUND, EXIT;
		MOVE I1:=IMAGPIR, (4);		<<TRANSFER COMMAND MNEMONIC>>
NEXT:	IF N+1 = N2 THEN RETURN;	<<NOT FOUND>>
		K:= (NI+ N2 > &LSR(1);		<<FIND TABLE MIDPOINT >>
		ASSEMBLEâ€¹DDUP;LDD MNEM, I,X; DCMP); <<COMPARE MNEMONICS>>
		IF = THEN GOTO FOUND;
		IF < THEN GOTO LESSL;
		NI:=K;					<<MOVE LOWER TABLE LIMIT UP>>
		GOTO NEXT;
LESSL:	N2: =K;					<<MOVE UPPER TABLE LIMIT DOWN>>
		GOTO NEXT;
FOUND:	ASSEMBLE (LOAD P+1,X);	<<LOAD CORRESPONDING PCAL>>
		GOTO EXIT;
		ASSEMBLE(
			PCAL ALIR; PCAL BKLG; PCAL BKSP; PCAL DLID; PCAL DLIJ;
			PCAL DRIN; PCAL DSPL; PCAL HOLD; PCAL JBID; PCAL LIST;
			PCAL LOCT; PCAL RELS; PCAL REPT; PCAL RSIT: PCAL SPAC;
			PCAL STAT; PcAL SIJB; PCAL STOP: PCAL SIRT
		<<END ASSEMBLE>>);
EXIT:		CMNDSRCH: =TOS; <<RETURN PCAL INSTRUCTION>>
END <<CMNDSRCH>>;

SUBROUTINE GETCOMMAND;
BEGIN
		@IMAGPIR: =@IMAGE;	<<RESET POINTER TO START OF BUFFER>>
		WORDBUF:=[8/%15,8/%15];	<<RETURN,RETURN>>
		MOVE WORDBUF(1):=WORDBUF,(40);	<<SET IMAGE TO RETURNS>>
I		INPUT(IMAGE); <<READ A COMMAND>>
END	<<GETCOMMAND >>;

SUBROUTINE SKIPBLANKS;
BEGIN
		SCAN IMAGPIR WHILE 76440,1;
		IF CARRY THEN ASSEMBLE (DEL,ZERO); <<BLANK LINE - RETURN 0>>
		@IMAGPIR: = TOS; <<RETURN POINTER OR 0>>
END <<SKIPBLANKS>>;

SUBROUTINE ERROR (NUMBR);
	VALUE NUMBR;
	INTEGER NUMBR:
		OUTPUI(EBUF,NUMBR); <<PRINT DIAGNOSTIC>>
		
<<START OF MAIN CODE>>
READ:
		GETCOMMAND;
		SKIPBLANKS:
		IF @IMAGPIRO THEN GO TO READ;	<<BLANK LINE>>
		TOS:=CMNDSRCH;	<<GET APPROPRIATE PCAL>>
		DUPLICATE:
		IF TOS=O THEN BEGIN
						ERROR (*):	<<ERR 0 - INVALID COMMAND>>
						GOTO READ;
					END:
		@IMAGPTR:=@IMAGPIR+ 4;	<<SET POINTER BEHIND MNEMONIC >>
		SKIPBLANKS;				<<LOCATE OPERAND STRING>>
		TOS:=@IMAGPIR;			<<PASS POINIER BY VALUE, 0 IF NO OPRNDS>>
		TOS:=@ERCODE;			<<PASS ERROR CODE BY REFERENCE>>
		ASSEMBLE(XEQ 2);		<<CALL PROCEDURE>>
		DEL;					<<REMOVE PCAL INSTRUCTION FROM STACK>>
		IF ERCODE>0 THEN ERROR(ERCODE):
		GOTO READ;				<<READ ANOTHER STATEMENT>>
END	<<COMMAND INTERPRETER>>.





