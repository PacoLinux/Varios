FORTRAN 22
FORTRAN II AND FORTRAN IV TRANSLATOR TO ALGOL    11/16/68               00000000
BURROUGHS CORPORATION, DETROIT MICHIGAN                                 00001000
% ********************     FORTRAN TO ALGOL     ********************;   01009000
*******************     FORTRAN ERROR MESSAGES     *******************  01009970
                                                                        01009980
ERROR NO.   ERROR MESSAGE                                               01009990
                                                                        01010000
    01   A FIXED OR FLOATING POINT IDENTIFIER IS REQUIRED.              01010010
    02   A STATEMENT NUMBER IS NOT GREATER THAN 0.                      01010020
    03   A STATEMENT NUMBER EXCEEDS 5 DIGITS.                           01010024
    04   A CHARACTER IS ILLEGALLY PLACED IN THIS STATEMENT.             01010076
    05   AN IDENTIFIER EXCEEDS 6 CHARACTERS.                            01010077
    06   AN IDENTIFIER IS MISSING.                                      01010078
    07   THE FIRST CHARACTER OF AN IDENTIFIER IS NOT ALPHABETIC.        01010079
    08   A 0 SUBSCRIPT HAS OCCURRED IN A DIMENSION OR EQUIVALENCE LIST. 01010080
    09   A NON-SUBSCRIPTED IDENTIFIER IS REQUIRED.                      01010081
    10   AN INTEGER EXCEEDS 32767.                                      01010082
    11   THE NUMBER OF SUBSCRIPS IN AN ARRAY DOES NOT AGREE WITH THE    01010083
           DIMENSION STATEMENT.                                         01010084
    12   A SUBSCRIPT OF AN IDENTIFIER IS IN ERROR.                      01010085
    13   A STATEMENT IS INCORRECTLY WRITTEN.                            01010086
    14   THE NUMBER OF ACTUAL ARGUMENTS OF A FUNCTION DOES NOT AGREE    01010140
           WITH THE NUMBER OF DUMMY ARGUMENTS.                          01010145
    15   AN UNDEFINED FUNCTION IS USED.                                 01010150
    16   A NON-FUNCTION IDENTIFIER IS BEING USED AS A FUNCTION.         01010160
    17   A FIXED,FLOATING POINT OR LOGICAL IDENTIFIER IS REQUIRED.      01010170
    18   AN ILLEGAL IDENTIFIER IS PRESENT IN AN ASSIGNMENT STATEMENT.   01010180
    19   A CALL STATEMENT DOES NOT CONTAIN A SUBROUTINE NAME.           01010190
    20   THERE IS AN ILLEGAL IDENTIFIER IN A SUBPROGRAM ARGUMENT LIST.  01010200
    21   AN EXPRESSION CONTAINS AN ILLEGAL CHARACTER.                   01010210
    22   A RELATIONAL OPERATOR IS MISSING FROM A LOGICAL EXPRESSION.    01010220
    23   A FORMAT STATEMENT CALLS FOR A TOTAL FIELD WIDTH COUNT         01010230
           EXCEEDING 132 CHARACTERS.                                    01010235
    24   A TAPE UNIT NUMBER EXCEEDS THE MAXIMUM OF 24.                  01010240
    25   A VARIABLE IDENTIFIER IS REQUIRED.                             01010250
    26   AN EQUAL SIGN IS MISSING FROM A COMPOUND I/O LIST.             01010260
    27   A RIGHT PARENTHESIS IS MISSING FROM A COMPOUND I/O LIST.       01010270
    28   A COMMA IS MISSING FROM A COMPOUND I/O LIST.                   01010280
    29   A COMPOIND I/O LIST CONTAINS DUPLICATE INDEX VARIABLE NAMES.   01010290
    30   THE NUMBER OF NESTED I/O IMPLIED DO LOOPS EXCEEDS THE MAXIMUM  01010300
           ALLOWED.                                                     01010305
    31   A COMPOUND I/O LIST IS INCORRECTLY WRITTEN.                    01010310
    32   AN I/O LIST IDENTIFIER IS NOT A VARIABLE.                      01010320
    34   AN IDENTIFER APPEARS MORE THAN ONCE IN A DIMENSION STATEMENT.  01010340
    35   AN ARRAY HAS MOVE THAN THREE DIMENSIONS.                       01010350
    36   A VARIABLE USED AS A DIMENSION IS NOT PRESENT IN THE           01010360
           SUBPROGRAM ARGUMENT LIST.                                    01010365
    37   A VARIABLE DIMENSION IS NOT A FIXED POINT,NON-SUBSCRIPTED      01010370
           VARIABLE.                                                    01010375
    38   A DO LOOP OVERLAPS ANOTHER DO LOOP.                            01010380
    39   THE STATEMENT NUMBER IS MISSING FROM A FORMAT STATEMENT.       01010390
    40   THE NAME OF A STATEMENT FUNCTION HAS BEEN USED TO REPRESENT    01010400
           ANOTHER TYPE IDENTIFIER.                                     01010405
    41   THE SUBPROGRAM ARGUMENT LIST CONTAINS DUPLICATE ARGUMENTS OR   01010410
           AN ARGUMENT THAT IS REPRESENTED BY THE SAME NAME AS THE      01010413
           SUBPROGRAM.                                                  01010416
    42   A DO LOOP ENDS WITH A DO STATEMENT.                            01010420
    43   THE TERMINAL STATEMENT NUMBER OF A DO LOOP PRECEDES THE DO     01010430
           STATEMENT.                                                   01010435
    44   AN INDEX VARIABLE OF A DO STATEMENT IS NOT FIXED POINT.        01010440
    46   AN ILLEGAL IDENTIFIER APPEARS IN A COMMON OR EQUIVALENCE LIST. 01010460
    47   THE NUMBER OF ARGUMENTS IN THE ARGUMENT LIST OF A SUBROUTINE   01010470
           CALL STATEMENT DOES NOT AGREE WITH THE NUMBER IN THE         01010473
           SUBROUTINE ARGUMENT LIST.                                    01010476
    48   THE STATEMENT IS NOT IMPLEMENTED.                              01010480
    49   THE NAME OF A SUBROUTINE EXCEEDS SIX CHARACTERS.               01010490
    50   AN IDENTIFIER APPEARS MORE THAN ONCE IN A COMMON STATEMENT.    01010500
    51   A DUMMY ARGUMENT OF A SUBPROGRAM APPEARS IN AN EQUIVALENCE LIST01010510
    52   TWO VARIABLES IN A COMMON LIST HAVE BEEN SET EQUIVALENT.       01010520
    53   AN IDENTIFIER IS MISSING IN AN EQUIVALENCE LIST.               01010530
    54   THE NAME OF A SUBPROGRAM DEFINED AS A SUBPROGRAM ARGUMENT HAS  01010540
           ALSO APPEARED IN A COMMON OR EQUIVALENCE LIST.               01010545
    55   A VARIABLE IN A TYPE STATEMENT HAS BEEN PREVIOUSLY DEFINED.    01010550
    56   A STATEMENT OCCURS WHICH IS NOT OF A FORTRAN TYPE.             01010560
    57   A SLASH IS INCORRECTLY USED IN A STATEMENT.                    01010570
    58   A DOLLAR SIGN IS INCORRECTLY USED.                             01010580
    59   THE FIRST SPECIAL CHARACTER IN A STATEMENT IN ERROR.           01010590
    60   DUPLICATE STATEMENT NUMBERS HAVE OCCURED.                      01010600
    61   THE NUMBER OF DATA ELEMENTS IN A DATA STATEMENT DOES NOT AGREE 01010610
           WITH THE NUMBER OF VARIABLES IN THE DATA LIST.               01010615
    62   A DATA LIST IDENTIFIER IN A DATA STATEMENT IS NOT A VARIABLE.  01010620
    63   A * IN A DATA STATEMENT IS PRECEDED BY A 0.                    01010630
    64   A LOGICAL IDENTIFIER IS REQUIRED.                              01010640
    65   THERE IS AN ILLEGAL CHARACTER FOLLOWING AN @.                  01010650
    66   A MAX OR MIN FUNCTION HAS LESS THAN TWO ARGUMENTS.             01010660
    67   A DATA STATEMENT CONTAINS AN ILLEGAL LOGICAL CONSTANT.         01010670
    68   A STATEMENT EXCEEDS THE MAXIMUM NUMBER OF CHARACTERS ALLOWED.  01010680
    69   A TAPE DECLARATION ON THE START  CARD SPECIFIES AN EXCESSIVE   01010690
           NUMBER OF UNITS.                                             01010695
    70   THE INTEGER FOLLOWING THE OCTAL OPTION ON THE START  CARD      01010700
           EXCEEDS 1023 OR HAS BEEN DECLARED 0.                         01010705
    71   THE START  CARD CONTAIN AN ILLEGAL ITEM.                       01010710
    72   THE FINAL DOLLAR SIGN IS MISSING ON THE START CARD.            01010720
    74   A STATEMENT FUNCTION HAS BEEN DEFINED AFTER THE FIRST          01010740
           EXECUTABLE STATEMENT.                                        01010745
    75   AN IDENTIFIER OTHER THAN A SUBSCRIPTED VARIABLE IS DIMENSIONED.01010750
    76   A FILE NUMBER {0 HAS BEEN GIVEN FOR A DISK FILE.               01010760
    77   THE NO. OF AREAS GIVEN FOR A DISK FILE IS {0 OR >20.           01010770
    78   THE NO. OF LOGICAL RECORDS FOR A DISK FILE IS {0 OR >1,048,575.01010780
    79   THE NO. OF WORDS IN A RECORD FOR A DISK FILE IS {0 OR >524,287.01010790
    80   THE ASSOCIATED VARIABLE FOR A DISK FILE HAS MORE THAN 6 CHARS. 01010800
    81   THE SIZE OF THE RECORD HAS NOT BEEN GIVEN FOR THIS TEMPORARY   01010810
           FILE.                                                        01010815
    82   THE ASSOCIATED VARIABLE HAS NOT BEEN GIVEN FOR A RANDOM FILE.  01010820
    83   THE FIND STATEMENT IS NOT NECESSARY AND IS NOT IMPLEMENTED.    01010830
    84   THE DEFINE FILE STATEMENT IS NOT NECESSARY AND IS NOT          01010840
           IMPLEMENTED.                                                 01010845
    85   THERE IS NOT ENOUGH INFORMATION FOR THE DISK FILE.             01010850
    86   THE SAVE FACTOR FOR A DISK FILE IS {0 OR >1023.                01010860
    90   A FORTRAN 2 LOGICAL EXPRESSION CONTAINS AN ILLEGAL SYMBOL.     01010900
    91   A FORTRAN 2 LOGICAL EXPRESSION USES A (-) SIGN INCORRECTLY.    01010910
    92   A FORTRAN 2 LOGICAL EXPRESSION MUST BE ASSIGNED TO A FLOATING  01010920
           POINT NAME.                                                  01010925
    93   AN ILLEGAL IF STATEMENT IS BEING USED.                         01010930
    94   THE TWO/FOUR INDICATOR CARD IS MISSING.                        01010940
    95   A SUBSCRIPTED VARIABLE NAME IN FORTRAN 2 EXCEEDS 3 CHARACTERS  01010950
           AND ENDS IN F.                                               01010955
************************************************************************01011000
BEGIN                                                                   01011050
REAL RR1,RR2,RR3,RR4,RR5,RR6,RR7,RR8,RR9,RR10,RR11,RR12,RR20;           01011100
REAL STREAM PROCEDURE EXAMIN(NCR); VALUE NCR;                           01011150
BEGIN SI~NCR; DI~ LOC EXAMIN; DI~DI+7; DS~CHR END;                      01011200
INTEGER STREAM PROCEDURE GETF(Q); VALUE Q;                              01011200
BEGIN SI~LOC GETF; SI~SI-7; DI~LOC Q; DI~DI+5;                          01011300
  SKIP 3 DB; 9(IF SB THEN DS~SET ELSE DS~RESET; SKIP SB);               01011350
  DI~LOC Q; SI~Q; DS~WDS; SI~Q; GETF~SI END;                            01011400
COMMENT START SETTING UP FILE PARAMETERS;                               01011450
  IF EXAMIN(RR20~GETF(3)+"Y03")!12 THEN RR1~5 ELSE                      01011500
    BEGIN RR1~2; RR2~150 END;                                           01011550
  IF EXAMIN(RR20+5)!12 THEN RR3~4 ELSE                                  01011600
    BEGIN RR3~2; RR4~150 END;                                           01011650
  IF EXAMIN(RR20+10)!12 THEN                                            01011700
    BEGIN RR5~56; RR6~10 END ELSE                                       01011750
    BEGIN RR5~10; RR6~150 END;                                          01011800
  IF EXAMIN(RR20+15)=12 THEN RR7~150;                                   01011850
  IF EXAMIN(RR20+20)!12 THEN                                            01011870
    BEGIN RR8~56; RR9~10 END ELSE                                       01011890
    BEGIN RR8~10; RR9~150 END;                                          01011910
  IF EXAMIN(RR20+25)!12 THEN                                            01011930
    BEGIN RR10~56; RR11~10 END ELSE                                     01011950
    BEGIN RR10~10; RR11~150 END;                                        01011970
BEGIN                                                                   01012000
LABEL  AUS,ENDSR,STPH3;                                                 01015000
DEFINE  TBLK=256#; %  STANDARD BLOCK SIZE OF BINARY RECORDS;            01018000
                                                                        01021000
                                                                        01024000
DEFINE  TP=16#;    %  STANDARD NUMBER OF TAPE FILES;                    01027000
DEFINE  XLABEL=0#; %  STANDARD STATEMENT NUMBER FOR END STATEMENT;      01030000
DEFINE  LMAX=24#;  %  MAXIMUM ALLOWABLE START CARD OVERRIDE OF SW,SL,TP;01033000
DEFINE  DXMAX=8#;  %  MAXIMUM ALLOWABLE NESTING OF I/O IMPLIED DO LOOPS;01036000
DEFINE  P=71#;     %  SEARCH MODULUS;                                   01039000
DEFINE  RP=29#;    %  SEARCH MODULUS FOR RESERVE WORD TABLE;            01040000
DEFINE  RW=95#;    %  NUMBER OF RESERVE WORDS IN TABLE;                 01041000
DEFINE  UNDEF=0#;  %  LCLASS IS UNDEFINED;                              01042000
DEFINE  NSV=1#;    %  LCLASS IS THAT OF NON-SUBSCRIPTED VARIABLE;       01045000
DEFINE  SV=2#;     %  LCLASS IS THAT OF SUBSCRIPTED VARIABLE;           01048000
DEFINE  FN=3#;     %  LCLASS IS THAT OF A FUNCTION;                     01051000
DEFINE  SR=4#;     %  LCLASS IS THAT OF A SUBROUTINE;                   01054000
DEFINE  FM=5#;     %  LCLASS IS THAT OF A FORMAT IDENTIFIER;            01057000
DEFINE  LS=6#;     %  LCLASS IS THAT OF A LIST IDENTIFIER;              01060000
DEFINE  LB=7#;     %  LCLASS IS THAT OF A LABEL;                        01063000
DEFINE  DA=8#;     %  LCLASS IS THAT OF A DEFINED FUNCTION ARGUMENT;    01066000
DEFINE  PR=10#;    %  LCLASS IS TEMPORARILY SET = UNKNOWN PROCEDURE;    01069000
DEFINE  XP=11#;    %  LCLASS IS THAT OF AN EXPRESSION;                  01072000
DEFINE  MD=12#;    %  LCLASS IS THAT OF A MONITOR OR DUMP STATEMENT;    01075000
DEFINE  EQ=13#;    %  LCLASS IS THAT OF AN EQUIVALENCE STATEMENT;       01078000
DEFINE  DV=14#;    %  LCLASS IS THAT OF A DATA VARIABLE LIST;           01079000
DEFINE  DC=15#;    %  LCLASS IS THAT OF A DATA INITIAL VALUE LIST;      01080000
DEFINE  FXP=1#;    %  MODE IS FIXED POINT;                              01081000
DEFINE  FLP=2#;    %  MODE IS FLOATING POINT;                           01084000
DEFINE  BOO=3#;    %  MODE IS BOOLEAN;                                  01087000
DEFINE  DBP=4#;    %  MODE IS DOUBLE PRECISION;                         01090000
DEFINE  CMP=5#;    %  MODE IS COMPLEX;                                  01093000
DEFINE  CMAX=700#; %  MAXIMUM CHARACTER LENGTH OF FORTRAN STATEMENTS;   01096000
DEFINE CBMAX=511#;%  MAXIMUM ALLOWABLE COMMON BLOCKS;                   01099000
FILE IN CARD(RR1,10,RR2);                                               01102000
SAVE FILE OUT LINE DISK SERIAL[20:2400](RR3,15,RR4,SAVE 10);            01105000
                                                                        01108000
                                                                        01111000
FILE OUT FORFIL DISK SERIAL[20:2400]"OCRDIMG"(2,RR5,RR6,SAVE 10);       01112000
SAVE FILE OUT PNCH DISK SERIAL[20:2400](2,10,RR7,SAVE 1);               01114000
FILE IN TAPE(2,RR8,RR9);                                                01115000
SAVE FILE OUT NEWTAPE DISK SERIAL[20:2400](2,RR10,RR11,SAVE 10);        01115500
SWITCH FILE SWFI~CARD,TAPE;                                             01116000
DEFINE  XBWRD="      "#;     %  BLANK FIELD;                            01117000
DEFINE  HASH="######"#;      %  FILLER CHARACTERS;                      01120000
%  DEFINITION OF PARTIAL WORD FIELDS;                                   01123000
  DEFINE    CX1=[12:06]#,  CX2=[12:12]#,  CX3=[12:18]#,  CX4=[12:24]#;  01126000
  DEFINE    CX5=[12:30]#,  CX6=[12:36]#;                                01129000
  DEFINE    AX1=[3:15]#,  AX2=[18:15]#,  AX3=[33:15]#,  M5L=12:18:30#;  01132000
INTEGER BOXI;      %  POINTS TO TOP OF ID ARRAY;                        01135000
INTEGER BOXIR;     %  POINTS TO ENTRY IN RESERVE WORD TABLE;            01136000
INTEGER BOXL;      %  STARTING ID INDEX (LESS 1) FOR LOCAL VARIABLES;   01138000
INTEGER BOXP;      %  RECOVERS ID ADDRESS OF SUBPROGRAM IDENTIFIER;     01141000
INTEGER BOXC;      %  TOTAL NUMBER OF COMMON ENTRIES;                   01144000
INTEGER JV;        %  POINTS TO THE LOCATION OF INDENTIFER IN ID ARRAY; 01147000
INTEGER JVR;       %  POINTS TO LOCATION OF INDENTIFER IN RSWORD ARRAY; 01148000
INTEGER XF;        %  POINTS TO TOP OF INFO;                            01150000
INTEGER NOM,NOM1,NOM2,NOM3,NOM4;       %  THESE MUST BE CONSECUTIVE;    01153000
INTEGER NOMR;      %  TEMPORARY GLOBAL LOCATION OF RESERVE WORD;        01154000
INTEGER KX;        %  POINTS TO OUTPUT BUFFER CHARACTER;                01156000
INTEGER ACOUNT;    %  ALGOL CARD SEQUENCE NUMBER;                       01159000
INTEGER CARTE;     %  FORTRAN CARD SEQUENCE NUMBER;                     01162000
INTEGER CART1;     %  CARTE - 1;                                        01163000
INTEGER PGCT;      %  PAGE COUNT FOR PRINTED LISTING;                   01165000
INTEGER SARG;      %  RESIDUE OF NOM MOD P;                             01168000
INTEGER SARGR;     %  RESIDUE OF NOMR MOD PR;                           01169000
INTEGER CCT;       %  NUMBER OF SUBSCRIPTS IN DIMENSION DECLARATION;    01171000
INTEGER SQCT;      %  COUNT OF Q SUFFIX FOR RESERVE WORDS;              01172000
INTEGER IPHASE;    %  TRANSLATION PHASE;                                01174000
INTEGER CHCT;      %  INDEX FOR RBAND;                                  01177000
INTEGER TPOSIT;    %  INDICATES POSITION OF TENIR;                      01180000
INTEGER CHAR;      %  CHARACTER REGISTER-FOCUSES ON RBAND ALWAYS;       01183000
INTEGER FWCT;      %  LENGTH OF ALPHA-NUMERIC STRING IN NOM&NOM1&ETC.;  01186000
INTEGER NHOLL;     %  BINARY EQUIVALENT OF BCD INTEGER;                 01189000
INTEGER LJSTCT;    %  LEFT MARGIN FOR ALGOL DECK;                       01192000
INTEGER WH;        %  INDEX FOR WHOLD ARRAY;                            01195000
INTEGER STNXT;     %  LABEL OF NEXT STATEMENT;                          01198000
INTEGER STANO;     %  LABEL OF STATEMENT CURRENTLY IN RBAND;            01201000
INTEGER COLMN1;    %  CONTENTS OF COLUMN1 OF CARD IMAGE IN READH ARRAY; 01204000
INTEGER TYPUS;     %  MODE OF STATEMENT IN RBAND;                       01207000
INTEGER MODUS;     %  MODE OF STATEMENT IN READH;                       01210000
INTEGER CTOTAL;    %  TOTAL CHARACTERS IN RBAND;                        01213000
INTEGER KPASS;     %  LAST CHARACTER PASSED;                            01216000
INTEGER JST;       %  TEMPORARY FOR STACK, STACK2 ROUTINES;             01219000
INTEGER FLGX;      %  CHARACTER COUNT FOR TENIR;                        01222000
INTEGER FLGZ;      %  CHARACTER COUNT FOR WB ARRAY;                     01225000
INTEGER NHMX;      %  LENGTH OF HOLLERITH STRING;                       01228000
INTEGER CARTX;     %  SEQUENCE NUMBER OF ZEROETH CONTINUATION CARD;     01231000
INTEGER RSVX;      %  RATCHET DIAL FOR FLGX;                            01234000
INTEGER RSVZ;      %  RATCHET DIAL FOR FLGZ;                            01237000
INTEGER DRPX;      %  PHASE II CHARACTER COUNT FOR WX ARRAY & TENIR;    01240000
INTEGER SRPX;      %  PHASE II CHARACTER COUNT SAVE WHEN USING COMMENTS;01241000
INTEGER DRPZ;      %  PHASE II CHARACTER COUNT FOR WB ARRAY;            01243000
INTEGER EQUMAX;    %  MAXIMUM NUMBER OF EQUIVALENCE PAIRS;              01246000
INTEGER GANZ;      %  INTEGRAL PART OF FLOATING POINT CONSTANT;         01249000
INTEGER NULLEN;    %  LEADING ZEROES IN FRACTIONAL PART OF FLP CONSTANT;01252000
INTEGER BRUCH;     %  NON-ZERO FRACTIONAL PART OF FLP CONSTANT;         01255000
INTEGER POTENZ;    %  EXPONENT (POWER OF TEN) OF FLP CONSTANT;          01258000
INTEGER LISTCT;    %  TOTAL NUMBER OF I/O LISTS TO BE DECLARED;         01261000
INTEGER SPCT;      %  DEPTH OF DO-LOOP NESTING (USED FOR MARGIN CONTROL)01264000
INTEGER PNAME;     %  NAME OF FUNCTION OR SUBROUTINE BEING PROCESSED;   01267000
INTEGER CNOM;      %  CURRENT COMMON BLOCK NAME;                        01270000
INTEGER JTAB;      %  POINTER FOR USE WITH TABLE LOOKUP ROUTINES;       01273000
INTEGER ARGMAX;    %  MAXIMUM NUMBER OF DEFINED FUNCTION ARGUMENTS;     01276000
INTEGER JSWGO;     %  TOTAL NUMBER OF DISTINCT COMPUTED GO-TO SWITCHES; 01279000
INTEGER KCT;       %  NUMBER OF ALGOL DIMENSIONS OF SUBSCRIPTED VAR.    01282000
INTEGER JXLS;      %  POINTS TO LAST WORD ENTERED IN XSTACK;            01285000
INTEGER BOXA;      %  COUNT OF SUBPROGRAM PARAMETERS;                   01288000
INTEGER BOXMD;     %  POINTS TO FIRST MONITOR OR DUMP ENTRY IN ID ARRAY;01291000
INTEGER BOXE;      %  POINTS TO FIRST EQ ENTRY IN ID ARRAY;             01294000
INTEGER RG1;       %  ARGUMENT/EXPRESSION COUNT;                        01297000
INTEGER RG2;       %  POSITION OF CLOSING RIGHT PARENTHESIS;            01300000
INTEGER RG3;       %  POSITION OF LAST ZERO-LEVEL SUBTRACTION SIGN;     01303000
INTEGER RG4;       %  POSITION OF LAST EQUAL SIGN IN EXPRESSION;        01306000
INTEGER CEQ;       %  NUMBER OF EQUALS IN AN I/O LIST;                  01307000
INTEGER PNT;       %  POINTER FOR USE WITH INFO ARRAY;                  01309000
INTEGER PSCALE;    %  CURRENT SCALE FACTOR;                             01312000
INTEGER SVL;       %  SUBSCRIPTED VARIABLE LEVEL COUNT;                 01315000
INTEGER NSRG;      %  ARGUMENT COUNT FOR USE WITH NSARGL,FNPR, & SRCALL;01318000
INTEGER RESULT;    %  EXPRESSION MODE AS DETERMINED BY NSARG;           01321000
INTEGER BOXJ;      %  DO NOT PURGE ID ARRAY BELOW THIS LEVEL;           01324000
INTEGER ALTO;      %  UPPER LIMIT FOR ERRMSG CALL ON SQUEEZE;           01327000
INTEGER BASSO;     %  LOWER LIMIT FOR ERRMSG CALL ON SQUEEZE;           01330000
INTEGER DFCT;      %  TOTAL OF DEFINED FUNCTIONS TO BE DECLARED;        01331000
INTEGER DXCT;      %  TOTAL OF I/O LIST DUMMY INDICES TO BE DECLARED;   01333000
INTEGER IXCT;      %  TOTAL OF NSSV DUMMY LIST INDICES TO BE DECLARED;  01336000
INTEGER DATACT;    %  COUNT OF SUBPROGRAMS WITH DATA STATEMENTS;        01337000
INTEGER BLKDCT;    %  COUNT OF SUBPROGRAMS WITH BLOCK DATA STATEMENTS;  01338000
INTEGER BOXDV;     %  POINTS TO FIRST DATA VARIABLE ENTRY IN ID ARRAY;  01338100
INTEGER BOXDC;     %  POINTS TO FIRST DATA CONSTANT ENTRY IN ID ARRAY;  01338200
INTEGER ARRAY  ID,LOW,ADR[0:1022];   %  ENTRY ARRAYS FOR INFO TABLE;    01339000
INTEGER ARRAY RSWORD,LOWR[0:RW];  %  RESERVE WORD TABLE AND ENTRY;      01340000
REAL ARRAY INFO[0:63,0:127];           %  BASIC INFORMATION TABLE;      01342000
DEFINE  CL=[33:8]#, CR=[41:7]#;      %  USED WITH INFO SUBSCRIPTS;      01345000
INTEGER ARRAY TAPES[0:LMAX]; %  TAPE ARRAY - 1 ELEMENT PER FILE;        01347000
INTEGER ARRAY SENSW,SENSL[0:LMAX];   %  SENSE SWITCHES & SENSE LIGHTS;  01348000
REAL ARRAY DISK[0:24];       %  THIS ARRAY HOLDS INFO ON EACH DISK FILE;01349000
                             %    WORD 1 CONTAINS FILE NO (B 11 - 47)   01349100
                             %                    SAVE FACTOR (B 1-10)  01349150
%                                 WORD 2 CONTAINS ASSOCIATED VARIABLE;  01349200
%                                 WORD 3 CONTAINS FILE TYPE  (BIT 1);   01349300
%                                                 ACCESS TECH. (B 2-3); 01349400
%                                                 LOG. RECORDS (B 4-23);01349500
%                                                 WORDS (B 24-42);      01349600
%                                                 AREAS (B 43-48);;     01349700
INTEGER ARRAY OUTB[0:72];    %  72-CHARACTER OUTPUT BUFFER;             01351000
INTEGER ARRAY OUTBP[0:9];    % 10 WORD OUTPUT BUFFER;                   01351500
INTEGER ARRAY SOUTB[0:72];   %  72-CHARACTER SAVE OUTPUT BUFFER;        01352000
INTEGER ARRAY KEY[0:P];      %  ENTRY TO ID ARRAY;                      01354000
INTEGER ARRAY KEYR[0:RP];    %  ENTRY TO RESERVE WORD TABLE;            01355000
REAL ARRAY DESCR[0:2];       %  RFB,WFB,RRV  I/O DESCRIPTORS;           01357000
INTEGER ARRAY RBAND[0:CMAX]; %  FORTRAN STATEMENT BUFFER;               01360000
INTEGER ARRAY READT[0:9];    %  10 WORD CARD IMAGE BUFFER;              01362000
INTEGER ARRAY READH[0:80];   %  FORTRAN CARD IMAGE BUFFER;              01363000
INTEGER ARRAY RHBAND[0:80];  %  SAVES READH ARRAY;                      01364000
INTEGER ARRAY FOROUT[0:14];  %  15 WORD FORTRAN OUTPUT BUFFER;          01365000
INTEGER ARRAY ALGPRT[0:14];  %  15 WORD ALGOL PRINT BUFFER;             01366000
BOOLEAN ARRAY ALFA[0:63];    %  WORD MODE SC=ALPHA TEST MATRIX;         01369000
INTEGER ARRAY D[0:3];        %  DIMENSIONS OF SUBSCRIPTED VARIABLE;     01372000
INTEGER ARRAY WHOLD[0:511];  %  BCD OUTPUT STRING BUFFER AREA;          01375000
INTEGER ARRAY WX[0:511];     %  I/O WORD MODE BUFFER FOR TENIR;         01378000
INTEGER ARRAY WZ[0:6];       %  I/O WORD MODE BUFFER FOR WB ARRAY;      01381000
REAL ARRAY WB[0:63,0:127];   %  INTERNAL STORAGE AREA;                  01384000
INTEGER ARRAY ASTACK[0:63];  %  ELEMENTS OF ASSIGNED GO-TO SWITCH;      01387000
INTEGER ARRAY LSTX[0:100];   %  I/O LIST INFORMATION TABLE;             01390000
INTEGER ARRAY NHOLD[0:18];   %  ALPHA-NUMERIC ARRAY FOR USE WITH SSCAN; 01393000
INTEGER ARRAY E[0:6];        %  DIMENSION OF REBLOCKED SUBSCR.VAR.;     01396000
INTEGER ARRAY SVCH[0:50,0:3];%  USED IN TRANSPOSITION OF SUBSCRIPTS;    01399000
INTEGER ARRAY INDEX[0:DXMAX];%  DUMMY INDICES FOR CURRENT I/O LIST;     01402000
INTEGER ARRAY XSTACK[0:20,0:20];       %  COMPUTED GO-TO LISTS;         01405000
INTEGER ARRAY LXSAVE[0:63];  %  STARTING INDICES FOR LISTS IN XSTACK;   01408000
INTEGER ARRAY TENOR[0:200,0:63];       %  INTERMEDIATE STORAGE ARRAY;   01409000
INTEGER ARRAY CSTACK,BSTACK[0:15,0:63];                                 01411000
% CSTACK           COMMON ITEMS;                                        01414000
% BSTACK           NAME OF ASSOCIATED COMMON BLOCK;                     01417000
BOOLEAN ARRAY CBDECL[0:CBMAX];         %  HAS ARRAY BEEN DECLARED       01420000
INTEGER ARRAY  CBNOM,CBSIZE[0:CBMAX];                                   01423000
%  CBNOM           LIST OF COMMON BLOCK NAMES;                          01426000
%  CBSIZE          LIST OF COMMON BLOCK LENGTHS;                        01429000
INTEGER ARRAY ASNVAR,SSN,DOTAB,DOJ,DOM2,DOM3[0:50];                     01432000
% ASNVAR           ASSIGNED GO TO VARIABLES;                            01435000
%    SSN           NEGATIVE STEP SIZE INDICATOR;                        01436000
%  DOTAB           LAST LABEL IN SCOPE OF DO LOOP                       01438000
%    DOJ           DO LOOP INDEX                                        01441000
%   DOM2           UPPER BOUND OF DO LOOP INDEX                         01444000
%   DOM3           INCREMENT FOR DO LOOP INDEX                          01447000
INTEGER ARRAY RELTAB,RELSYM[0:6];      %  RELATIONAL OPERATOR TABLES;   01450000
DEFINE  CNEXT=RBAND[CHCT+1]#;        %  NEXT CHARACTER IN RBAND;        01453000
DEFINE  DPART=INFO[(PNT+1).CL,(PNT+1).CR]#;      %  DIMENSIONS OF SV;   01456000
DEFINE  D1=DPART.AX1#;       %  POSITION OF 1ST DIMENSION WITHIN DPART; 01459000
DEFINE  D2=DPART.AX2#;       %  POSITION OF 2ND DIMENSION WITHIN DPART; 01462000
DEFINE  D3=DPART.AX3#;       %  POSITION OF 3RD DIMENSION WITHIN DPART; 01465000
DEFINE  DCT=DPART.[1:2]#;    %  DIMENSION COUNT;                        01468000
BOOLEAN T4SW;      %  PROGRAM IS FORTRAN FOUR;                          01469000
BOOLEAN T2SW;      %  PROGRAM IS FORTRAN TWO;                           01470000
BOOLEAN OKTLSW;    %  OKTL FORMAT IS TO BE USED FOR BINARY TAPE FILES;  01471000
BOOLEAN SVSW;      %  IDENTIFIER IS THAT OF A SUBSCRIPTED VARIABLE;     01474000
BOOLEAN IGCK;      %  DETERMINES IF STATEMENT FOLLOWS LOGICAL IF;       01475000
BOOLEAN TBSW;      %  IDENTIFIER IS PRESENT IN ID ARRAY;                01477000
BOOLEAN TBSWR;     %  IDENTIFIER IS PRESENT IN RESERVE WORD TABLE;      01477500
BOOLEAN BETEST;    %  TEST IF BEGIN-END NECESSARY AFTER LOGIF;          01478000
BOOLEAN PCOSW;     %  PUNCH ALGOL DECK BUT DO NOT MAKE 0CRDIMG;         01480000
BOOLEAN PPSW;      %  PUNCH ALGOL DECK IN ANY CASE;                     01483000
BOOLEAN FLSW;      %  FORTRAN LISTING;                                  01484000
BOOLEAN ALSW;      %  ALGOL LISTING;                                    01485000
BOOLEAN STSW;      %  SYNTAX CHECK ONLY;                                01485500
BOOLEAN BWX;       %  POINTS PHASE 1 OUTPUT TOWARD WX (ELSE WB) ARRAYS; 01486000
BOOLEAN HEADSW;    %  SIGNALS RNIT TO PRINT HEADING;                    01489000
BOOLEAN SRCHSW;    %  COMMENTS ARE TO BE IGNORED WHILE SEARCHING;       01492000
BOOLEAN XCSW;      %  IGNORE COMMON (BUT TAKE NOTE OF ANY DIMENSIONS);  01495000
BOOLEAN XESW;      %  IGNORE EQUIVALENCE STATEMENTS;                    01498000
BOOLEAN GDSW;      %  DECLARE COMMON VARIABLES GLOBALLY;                01499000
BOOLEAN BRKUSW;    %  EMIT SIMPLE INDEXING (DESPITE COMMON OR EQUIV);   01501000
BOOLEAN GLOBSW;    %  DECLARE ALL VARIABLES WHETHER USED OR NOT;        01504000
BOOLEAN ISSW;      %  INHIBIT SUBSCRIPT SWITCHING;                      01505000
BOOLEAN PFXSW;     %  SWITCH FOR PREFIXING;                             01506000
BOOLEAN CONSW;     %  READH CONTAINS A PORTION OF CURRENT STATEMENT;    01507000
BOOLEAN FNSW;      %  SWITCH FOR EXTERNAL FUNCTION - TWO;               01508000
BOOLEAN LGSW;      %  SWITCH FOR BOOLEAN EXPRESSION - TWO;              01509000
BOOLEAN DFSW;      %  BE ALERT FOR DEFINED FUNCTION STATEMENTS;         01510000
BOOLEAN FCNSW;     %  CURRENT SUBPROGRAM IS A FUNCTION;                 01513000
BOOLEAN SUBSW;     %  CURRENT SUBPROGRAM IS A SUBROUTINE;               01516000
BOOLEAN BGNSW;     %  FORMATS MUST BE PLACED IN AN OUTER BLOCK;         01519000
BOOLEAN RORW;      %  READ OR WRITE INDICATOR -USED FOR DISK FILES;     01520000
BOOLEAN DSKST;     %  DISK STATEMENT INDICATOR;                         01521000
BOOLEAN LISTSW;    %  AN I/O LIST IS BEING PROCESSED;                   01522000
BOOLEAN ACD;       %  SWITCH FOR OUTPUT OF ALGOL SUBROUTINES;           01523000
BOOLEAN LG;        %  SWITCH USED WITH ALGOL DECLARATIONS;              01524000
BOOLEAN FALSCH;    %  BOOLEAN CONSTANT;                                 01525000
BOOLEAN WAHR;      %  BOOLEAN CONSTANT;                                 01528000
BOOLEAN CAB;       %  TRUE IF ALFOL STATEMENT GLOBAL;                   01529000
BOOLEAN CQSW;      %  VARIABLE IS RELATED TO COMMON OR EQUIV ARRAYS;    01531000
BOOLEAN FXPSW;     %  EXPRESSION IS OF TYPE INTEGER;                    01534000
BOOLEAN LBSW;      %  LABEL SWITCH;                                     01535000
BOOLEAN FTT;       %  DECLARE VARIABLES IN COMMON GLOBALLY;             01536000
BOOLEAN DFCNSW;    %  IF ERROR OCCURS WHILE TRUE THEN CLEAN UP INFO;    01537000
BOOLEAN OUTSW;     %  AN OUTPUT LIST IS BEING PROCESSED;                01540000
BOOLEAN SPCHRSW;   %  SWITCH FOR DETERMINING DATA COM SPECIAL CHARS.;   01541000
BOOLEAN ZSW;       %  SWITCH FOR ZERO REAL NUMBERS;                     01542000
BOOLEAN CTRLSW;    %  TURNS OFF WHEN CARRIAGE CONTROL IS FOUND;         01543000
BOOLEAN CARSW;     %  CARRIAGE CONTROL IS USED;                         01544000
BOOLEAN REPEATSW;  %  MULTIPLE FORTRAN JOBS;                            01545000
BOOLEAN LINESW;    %  TURNED ON FOR COLUMN 1 OF EACH FORMAT LINE;       01546000
BOOLEAN DATASW;    %  CURRENT SUBPROGRAM CONTAINS A DATA STATEMENT;     01547000
BOOLEAN BLKDSW;    %  CURRENT SUBPROGRAM HAS A BLOCK DATA STATEMENT;    01548000
DEFINE  VSPACE=3#; %  INFO SPACE REQUIRED PER VARIABLE & FUNCTION ENTRY;01549000
DEFINE  BPART=INFO[PNT.CL,PNT.CR]#;    %  BOOLEAN INFORMATION IN INFO;  01552000
DEFINE  ALTER=BPART.[1:1]#, ALTERED=BOOLEAN(ALTER)#;                    01555000
DEFINE  USE=BPART.[2:1]#, USED=BOOLEAN(USE)#;                           01558000
DEFINE  MOOD=BPART.[3:3]#;             %  LOGICAL MODE;                 01561000
DEFINE  CLASS=BPART.[6:4]#;            %  LOGICAL CLASS;                01564000
DEFINE  AFIELD=BPART.[10:15]#;         %  15 BIT FIELD;                 01567000
DEFINE  LENGTH=AFIELD#;      %  ARRAY LENGTH (USED FOR LCLASS SV);      01570000
DEFINE  ARGS=AFIELD#;        %  ARG COUNT, IF KNOWN (LCLASS FN & SR);   01573000
DEFINE  ZADR=AFIELD#;        %  FLGZ ADDRESS FOR FORMATS: EQ LISTS ETC. 01576000
DEFINE  IASV=AFIELD#;         %  ASSOCIATED VARIABLE FLAG FOR NSV       01577000
DEFINE  CBIT=BPART.[25:1]#;  %  COMMON ITEM;                            01579000
DEFINE  EBIT=BPART.[26:1]#, EB=BOOLEAN(EBIT)#;   %  EQUIVALENCE ITEM;   01582000
DEFINE  PBIT=BPART.[27:1]#, PB=BOOLEAN(PBIT)#;   %  SUBPROGRAM ARGUMENT;01585000
DEFINE  ABIT=BPART.[28:1]#, AB=BOOLEAN(ABIT)#;   %  ARGCT IS KNOWN;     01588000
DEFINE  FTYPE=BPART.[29:3]#; %  FUNCTION VARIETY;                       01591000
DEFINE  FF=1#;     %  FUNCTION DEFINED VIA FUNCTION STATEMENT;          01594000
DEFINE  DF=2#;     %  FUNCTION DEFINED VIA ARITHMETIC STATEMENT;        01597000
DEFINE  LF=3#;     %  STANDARD FORTRAN & ALGOL LIBRARY OR INTRINSIC;    01600000
DEFINE  SF=4#;     %  SPECIAL FORTRAN LIBRARY OR INTRINSIC;             01603000
DEFINE  OKBIT=BPART.[32:1]#, OK=BOOLEAN(OKBIT)#; %  DECLARATION WAS OK; 01606000
DEFINE  ARGL=BPART.[33:15]#;           %  POINTS TO ARGUMENT MODE LIST; 01609000
DEFINE  CCHAR=BPART.[33:15]#;          %  FORMAT CARRIAGE CONTROL;      01612000
DEFINE  MDFLAG=BPART.[33:15]#;         %  MONITOR OR DUMP (LCLASS MD);  01615000
DEFINE  BASE=BPART.[33:15]#; %  LCLASS NSV,SV-REL. LOC. IN COMMON BLOCK;01618000
DEFINE  LPART=INFO[(PNT+1).CL,(PNT+1).CR]#;      %  LABEL PART;         01621000
DEFINE  PRESENCE=LPART.[1:1]#, PRESENT=BOOLEAN(PRESENCE)#;              01624000
DEFINE  JUMP=LPART.[2:1]#;             %  LABEL OF A GO-TO COMMAND;     01627000
DEFINE  GOAL=LPART.[3:1]#;             %  OBJECT OF A JUMP COMMAND;     01630000
DEFINE  F=LPART.[4:1]#;                %  LABEL IS THAT OF A FORMAT;    01633000
DEFINE  CCTRL=LPART.[5:1]#;  %  FORMAT IS PURELY FOR CARRIAGE CONTROL;  01636000
DEFINE  CIBLE=LPART.[12:36]#;          %  TARGET LABEL;                 01639000
DEFINE  NPART=INFO[(PNT+1).CL,(PNT+1).CR]#;      %  SF NAME PART;       01642000
DEFINE  RESERVE=CPART.[4:1]#, RS=BOOLEAN(RESERVE)#;                     01644000
DEFINE  AMODE=NPART.[9:3]#;  %  ARGUMENTS ARE ALL OF INDICATED MODE;    01645000
DEFINE  NAME=NPART.CX6#;     %  ALGOL FUNCTION NAME (FTYPES SF,LF ONLY);01648000
DEFINE  INEXT=NPART.CX6#;    %  LINKS MONITOR/DUMP (LCLASS MD) ENTRIES; 01651000
DEFINE  RECURSIVE= #;        %  DESCRIPTIVE NOISE WORD;                 01654000
DEFINE  NOTHING= #;          %  DESCRIPTIVE NOISE WORD;                 01657000
DEFINE  CPART=INFO[(PNT+2).CL,(PNT+2).CR]#;      %  COMMON BLOCK;       01660000
DEFINE  DBIT=CPART.[1:1]#, DB=BOOLEAN(DBIT)#;    %  DECLARED AS ARRAY;  01663000
DEFINE  SLBIT=CPART.[2:1]#, SLB=BOOLEAN(SLBIT)#; %  SUPPRESS LOC. DECL. 01666000
DEFINE  FLBIT=CPART.[3:1]#, FLB=BOOLEAN(FLBIT)#; % DEFINED MODE IS FLP; 01669000
DEFINE  CNAME=CPART.CX6#;    %  COMMON BLOCK NAME;                      01672000
DEFINE  D1PART=INFO[(PNT+3).CL,(PNT+3).CR]#;     %  ADJUSTABLE LIMIT;   01675000
DEFINE  D2PART=INFO[(PNT+4).CL,(PNT+4).CR]#;     %  ADJUSTABLE LIMIT;   01678000
DEFINE  D3PART=INFO[(PNT+5).CL,(PNT+5).CR]#;     %  ADJUSTABLE LIMIT;   01681000
DEFINE  SEGMENT=DEFINE CNEXT=RBAND[CHCT+1]##;    %  CREATES A SEGMENT;  01684000
RECURSIVE PROCEDURE PASS (T);  VALUE T; INTEGER T; FORWARD;             01685000
RECURSIVE PROCEDURE STACK (T); VALUE T; INTEGER T; FORWARD;             01685500
RECURSIVE PROCEDURE PASS2(T);  VALUE T; INTEGER T; FORWARD;             01686000
RECURSIVE PROCEDURE STACK2(T); VALUE T; INTEGER T; FORWARD;             01686500
INTEGER PROCEDURE LCLASS;  BEGIN SEGMENT; LCLASS~CLASS END;             01687000
PROCEDURE CPUT(C);  VALUE C;  INTEGER C;  BEGIN SEGMENT; CLASS~C END;   01690000
INTEGER PROCEDURE MODE;  BEGIN SEGMENT; MODE~MOOD END;                  01693000
PROCEDURE MPUT(M);  VALUE M;  INTEGER M;  BEGIN SEGMENT; MOOD~M END;    01696000
BOOLEAN PROCEDURE CB;  BEGIN SEGMENT; CB~BOOLEAN(CBIT) END;             01699000
INTEGER PROCEDURE ADDRESS;  BEGIN SEGMENT; ADDRESS~ZADR END;            01702000
PROCEDURE ZPUT(Z);  VALUE Z;  INTEGER Z;  BEGIN SEGMENT; ZADR~Z END;    01705000
BOOLEAN PROCEDURE INTG(T); VALUE T; INTEGER T;                          01708000
  INTG~((("I"{T) AND (T{"N")) AND ALFA[T]);                             01711000
BOOLEAN PROCEDURE INTGW(T); VALUE T; INTEGER T;  INTGW~INTG(T.CX1);     01714000
INTEGER PROCEDURE DFALT(N);    VALUE N;    INTEGER N;                   01717000
  DFALT~(IF INTGW(N) THEN FXP ELSE FLP);                                01720000
PROCEDURE PURGE(L);    VALUE L;    INTEGER L;                           01723000
  WHILE BOXI>L DO BEGIN                                                 01726000
    KEY[ID[BOXI] MOD P]~LOW[BOXI]; XF~ADR[BOXI]-1; BOXI~BOXI-1 END;     01729000
PROCEDURE TBSCH;                                                        01732000
BEGIN SEGMENT;                                                          01735000
  JV~KEY[SARG~(NOM MOD P)]; WHILE ID[JV]!NOM AND JV>0 DO JV~LOW[JV];    01738000
  PNT~(IF (TBSW~JV>0) THEN ADR[JV] ELSE XF+1) END;                      01741000
PROCEDURE TBSCHR;                                                       01742000
BEGIN                                                                   01742300
      JVR~KEYR[SARGR~(NOMR MOD RP)]; WHILE RSWORD[JVR]!NOMR AND JVR>0 DO01742700
  JVR~LOWR[JVR]; TBSWR~JVR>0 END;                                       01743000
PROCEDURE LAVER(N);    VALUE N;    INTEGER N;                           01744000
BEGIN    OWN INTEGER K;                                                 01747000
  K~XF+N; WHILE XF<K DO INFO[(XF~(XF+1)).CL,XF.CR]~0 END;               01750000
PROCEDURE NFIX(N);    VALUE N;    INTEGER N;                            01753000
BEGIN    %  SARG MUST BE DEFINED (USUALLY BY TBSCH) BEFORE CALLING NFIX;01756000
  LOW[BOXI~(BOXI+1)]~KEY[SARG]; KEY[SARG]~BOXI;                         01759000
  ID[BOXI]~NOM; ADR[BOXI]~PNT~XF+1; LAVER(N) END;                       01762000
PROCEDURE NFIXR;                                                        01763000
BEGIN                                                                   01763300
  LOWR[BOXIR~(BOXIR+1)]~KEYR[SARGR]; KEYR[SARGR]~BOXIR;                 01763700
  RSWORD[BOXIR]~NOMR END;                                               01764000
PROCEDURE RWCHK(N); VALUE N; INTEGER N;                                 01764300
BEGIN NOMR~N; TBSCHR; IF TBSWR THEN RESERVE~1 END;                      01764500
PROCEDURE EMBED(N,L);    VALUE N,L;    INTEGER N,L;                     01765000
BEGIN SEGMENT;  SARG~((NOM~N) MOD P); NFIX(L) END;                      01768000
PROCEDURE VPROC;                                                        01771000
BEGIN                                                                   01771500
  TBSCH; IF NOT TBSW THEN BEGIN NFIX(VSPACE);                           01772000
  IF NOT PFXSW THEN RWCHK(NOM) END END;                                 01772500
PROCEDURE LOOKUP(N);  VALUE N;  INTEGER N;  BEGIN NOM~N; VPROC END;     01774000
PROCEDURE EFFACE(I);    VALUE I;    INTEGER I;                          01777000
BEGIN  INTEGER J;                                                       01780000
  IF (J~KEY[SARG~(ID[I] MOD P)])=I THEN KEY[SARG]~LOW[I]                01783000
  ELSE BEGIN                                                            01786000
    WHILE LOW[J]>I DO J~LOW[J]; LOW[J]~LOW[I] END END;                  01789000
PROCEDURE SQUEEZE(HAUT,BAS);    VALUE HAUT,BAS;    INTEGER HAUT,BAS;    01792000
BEGIN  INTEGER DELTA,J,JD;                                              01795000
  IF HAUT}BOXI THEN BEGIN J~XF; PURGE(BAS); XF~J END                    01798000
  ELSE IF (DELTA~(HAUT-BAS))>0 THEN BEGIN                               01801000
    J~BAS; WHILE (J~(J+1)){HAUT DO EFFACE(J);                           01804000
    J~HAUT; WHILE (J~(J+1)){BOXI DO BEGIN                               01807000
      IF KEY[SARG~((ID[JD~(J-DELTA)]~ID[J]) MOD P)]=J THEN KEY[SARG]~JD;01810000
      LOW[JD]~(IF LOW[J]{HAUT THEN LOW[J] ELSE LOW[J]-DELTA);           01813000
      ADR[JD]~ADR[J] END;                                               01816000
  BOXI~BOXI-DELTA END END;                                              01819000
PROCEDURE SVDCMP;                                                       01822000
BEGIN  OWN REAL TSV;                                                    01825000
  CCT~(TSV~DPART).[1:2]; D[1]~TSV.AX1; D[2]~TSV.AX2; D[3]~TSV.AX3 END;  01828000
PROCEDURE SVQ;                                                          01831000
BEGIN SEGMENT;  TBSCH;                                                  01834000
  IF (SVSW~TBSW) THEN IF (SVSW~LCLASS=SV) THEN IF BOOLEAN(IPHASE)       01837000
    THEN CCT~DCT ELSE SVDCMP END;                                       01840000
INTEGER PROCEDURE MAX(A1,A2); VALUE A1, A2; INTEGER A1, A2;             01843000
  MAX~(IF A1}A2 THEN A1 ELSE A2);                                       01846000
INTEGER PROCEDURE MIN(A1,A2); VALUE A1, A2; INTEGER A1, A2;             01849000
  MIN~(IF A1{A2 THEN A1 ELSE A2);                                       01852000
INTEGER STREAM PROCEDURE XJUST(T);  VALUE T;                            01855000
BEGIN SI~LOC T; DI~LOC XJUST; DS~8 DEC END;                             01858000
PROCEDURE HEADER;                                                       01861000
BEGIN                                                                   01864000
FORMAT HDRFMT(X37,"FORTRAN TO ALGOL TRANSLATOR"),                       01867000
 PH1FMT(X37,"PHASE 1  FORTRAN STATEMENTS"//),                           01870000
 PH2FMT(X37,"PHASE 2    ALGOL STATEMENTS"//);                           01873000
  IF(IPHASE=1 AND FLSW) OR (IPHASE=2 AND ALSW AND NOT STSW) THEN        01876000
  BEGIN IF CARSW THEN WRITE(LINE[PAGE]); WRITE(LINE,HDRFMT);            01879000
    IF IPHASE=1 AND FLSW THEN WRITE(LINE,PH1FMT)                        01880000
    ELSE WRITE(LINE,PH2FMT) END END;                                    01882000
                                                                        01885000
                                                                        01888000
                                                                        01891000
                                                                        01894000
                                                                        01897000
                                                                        01898000
                                                                        01900000
                                                                        01903000
                                                                        01906000
                                                                        01909000
                                                                        01912000
                                                                        01915000
                                                                        01918000
                                                                        01921000
                                                                        01924000
                                                                        01927000
                                                                        01930000
                                                                        01932000
                                                                        01933000
                                                                        01936000
STREAM PROCEDURE PACK(A,C,S); VALUE C; BEGIN                            01939000
  SI~S; SI~SI+7; DI~A; DI~DI+C; DS~CHR END;                             01942000
                                                                        01942400
                                                                        01942800
                                                                        01943200
                                                                        01943600
                                                                        01944000
                                                                        01944400
                                                                        01944800
                                                                        01945000
                                                                        01948000
                                                                        01951000
                                                                        01954000
                                                                        01957000
                                                                        01960000
STREAM PROCEDURE UNPACK(A,B); BEGIN SI~A; DI~B;                         01963000
  16(32(DI~DI+7; DS~CHR)) END;                                          01966000
                                                                        01969000
                                                                        01972000
                                                                        01975000
PROCEDURE WSET; BEGIN END;                                              01978000
         COMMENT WSET DUMMY NEEDED FOR CARD 99999998;                   01981000
                                                                        01984000
STREAM PROCEDURE DCLZ(SQ,DQ);                                           01987000
BEGIN  SI~SQ; DI~DQ; SI~SI+1; 7(DI~DI+7; DS~CHR) END;                   01990000
PROCEDURE GNZ;                                                          01993000
BEGIN  OWN INTEGER J;                                                   01996000
                                                                        01998000
  IF (DRPZ~(DRPZ+1)){FLGZ THEN BEGIN                                    01999000
    IF (J~(DRPZ MOD 7))=0                                               02002000
    THEN DCLZ(WB[DRPZ DIV 896,(DRPZ DIV 7).[41:7]],WZ);                 02005000
    CHAR~WZ[J] END END;                                                 02008000
                                                                        02011000
                                                                        02014000
                                                                        02017000
STREAM PROCEDURE PACKOUT(A,B);                                          02020000
BEGIN                                                                   02023000
  SI~A; DI~B; 2(36(SI~SI+7;DS~1 CHR)) END;                              02026000
                                                                        02029000
                                                                        02032000
STREAM PROCEDURE SEQNOF(SQ,DQ,CT);                                      02035000
BEGIN                                                                   02038000
  DI~DQ; DS~16 LIT"                "; SI~SQ; 2(40(DS~1 CHR));           02041000
  DS~12 LIT"           F"; SI~CT; DS~4 DEC;                             02041500
  DS~8 LIT"        " END;                                               02042000
STREAM PROCEDURE SEQNOAP(SQ,DQ,CT);                                     02044000
BEGIN                                                                   02045000
  DI~DQ; DS~16 LIT"                "; SI~SQ; 2(36(DS~1 CHR));           02046000
  SI~CT; DS~5 DEC; DS~3 LIT"000";DS~24 LIT"                        "END;02047000
PROCEDURE FOROUTSP;                                                     02050000
BEGIN                                                                   02053000
FORMAT OUTT(X16,80A1,"F",A4);                                           02056000
OWN INTEGER I;                                                          02056500
  IF CARSW THEN WRITE(LINE[DBL],OUTT,FOR I~0 STEP 1 UNTIL 80 DO         02056800
    RHBAND[I]) ELSE                                                     02056900
  WRITE(LINE,OUTT,FOR I~0 STEP 1 UNTIL 80 DO RHBAND[I])END;             02057000
STREAM PROCEDURE SEQNOA(DQ,CT);                                         02059000
BEGIN                                                                   02062000
  DI~DQ; SI~CT; DS~5 DEC; DS~3 LIT"000" END;                            02065000
                                                                        02068000
PROCEDURE ALGOUT;                                                       02069000
BEGIN                                                                   02071000
  IF ALSW AND NOT STSW THEN BEGIN SEQNOAP(OUTBP,ALGPRT,ACOUNT);         02072000
    IF CARSW THEN WRITE(LINE[DBL],12,ALGPRT[*]) ELSE                    02072500
  WRITE(LINE,15,ALGPRT[*]) END;                                         02073000
  IF NOT STSW THEN BEGIN SEQNOA(OUTBP[9],ACOUNT);                       02073500
  IF NOT PCOSW THEN WRITE(FORFIL,10,OUTBP[*]);                          02074000
  IF PCOSW OR PPSW THEN WRITE(PNCH,10,OUTBP[*])  END;                   02075000
END;                                                                    02076000
                                                                        02077000
                                                                        02078000
                                                                        02080000
                                                                        02083000
                                                                        02086000
                                                                        02089000
                                                                        02092000
PROCEDURE ERROUT(N,E); VALUE N,E; INTEGER N,E;                          02095000
BEGIN LABEL EIT; INTEGER SV,I;                                          02098000
FORMAT ER1("A TYPE ",I3,"ERROR OCCURS IN THE PRECEDING STATEMENT"),     02101000
 ER2("SEE BELOW:"),ER3(X10,100A1);                                      02104000
  WRITE(LINE,ER1,E); IF N=5 THEN BEGIN SV~N; GO TO EIT END;             02107000
  WRITE(LINE,ER2);E~((N~(CHCT DIV 100))+1)|100; N~CHCT;                 02110000
  DO RBAND[N~(N+1)]~" " UNTIL N}E; N~0;                                 02111000
  WRITE(LINE,ER3,  FOR I~0 STEP 1 UNTIL E DO RBAND[I]);                 02113000
 EIT: N~0; DO RBAND[N]~"." UNTIL (N~(N+1))>99;                          02116000
  IF SV!5 THEN RBAND[CHCT MOD 100]~"*";                                 02119000
  WRITE(LINE,ER3,FOR I~0 STEP 1 UNTIL 100 DO RBAND[I]) END;             02122000
                                                                        02125000
PROCEDURE OUTPUT(N,E);    VALUE N,E;    INTEGER N,E;                    02128000
BEGIN LABEL EIT; SEGMENT;                                               02131000
  IF N=1 THEN BEGIN IF FLSW AND IPHASE=1 THEN BEGIN                     02134000
    SEQNOF(READT,FOROUT,CARTE); IF CARSW THEN                           02136000
    WRITE(LINE[DBL],15,FOROUT[*]) ELSE WRITE(LINE,15,FOROUT[*]) END END 02137000
  ELSE IF N=2 THEN BEGIN                                                02140000
    ACOUNT~ACOUNT+1; PACKOUT(OUTB,OUTBP); ALGOUT END                    02143000
                                                                        02143500
  ELSE ERROUT(N,E)END;                                                  02146000
                                                                        02149000
PROCEDURE CHANGESPCHR (T); VALUE T; INTEGER T;                          02152000
BEGIN SPCHRSW~TRUE;                                                     02154000
  IF T="~" THEN PASS (":=####")                                         02154000
  ELSE IF T="<" THEN PASS (" LSS #")                                    02155000
  ELSE IF T="{" THEN PASS (" LEQ #")                                    02156000
  ELSE IF T="}" THEN PASS (" GEQ #")                                    02157000
  ELSE IF T=">" THEN PASS (" GTR #")                                    02158000
  ELSE IF T="!" THEN PASS (" NEQ #")                                    02159000
  ELSE STACK (T); SPCHRSW~FALSE END;                                    02160000
PROCEDURE CHANGESPCHR2(T); VALUE T; INTEGER T;                          02161000
BEGIN SPCHRSW~TRUE;                                                     02162000
  IF T="~" THEN PASS2(":=####")                                         02163000
  ELSE IF T="<" THEN PASS2(" LSS #")                                    02164000
  ELSE IF T="{" THEN PASS2(" LEQ #")                                    02165000
  ELSE IF T="}" THEN PASS2(" GEQ #")                                    02166000
  ELSE IF T=">" THEN PASS2(" GTR #")                                    02167000
  ELSE IF T="!" THEN PASS2(" NEQ #")                                    02168000
  ELSE STACK2(T); SPCHRSW~FALSE END;                                    02169000
                                                                        02170000
                                                                        02171000
                                                                        02173000
PROCEDURE GNC; CHAR~RBAND[CHCT~(CHCT+1)];  COMMENT  PHASE 1 VERSION;    02176000
PROCEDURE SCAN;                                                         02179000
BEGIN                                                                   02182000
  INTEGER STREAM PROCEDURE IDSCAN(NOM,RBANDE);                          02185000
  BEGIN  LABEL LX;                                                      02188000
    SI~RBANDE; DI~NOM;                                                  02191000
  5(DS~2 LIT "00";                                                      02194000
       6(SI~SI+7;                                                       02197000
         IF SC=ALPHA THEN BEGIN DS~CHR; TALLY~TALLY+1 END               02200000
         ELSE JUMP OUT 2 TO LX));                                       02203000
LX: DS~6 LIT "######";                                                  02206000
  IDSCAN~TALLY END;                                                     02209000
  CHAR~RBAND[CHCT~(CHCT+1+(FWCT~IDSCAN(NOM,RBAND[CHCT+1])))] END;       02212000
PROCEDURE RESCAN; BEGIN CHCT~-1; SCAN END;                              02215000
PROCEDURE PNX; BEGIN  COMMENT  PHASE 1 VERSION OF PNX;                  02218000
  NHOLL~NHMX~0;                                                         02221000
  WHILE (CHAR~RBAND[CHCT~(CHCT+1)]){9 DO BEGIN                          02224000
    NHOLL~10|NHOLL+(WHOLD[NHMX~(NHMX+1)]~CHAR) END END;                 02227000
STREAM PROCEDURE CLZ(SQ,DQ);                                            02230000
BEGIN  SI~SQ; DI~DQ; DI~DI+1; 7(SI~SI+7; DS~CHR) END;                   02233000
PROCEDURE STACKZ(T);    VALUE T;    INTEGER T;                          02236000
BEGIN SEGMENT;                                                          02239000
  WZ[JST~((FLGZ~(FLGZ+1)) MOD 7)]~T;                                    02242000
  IF JST=6 THEN CLZ(WZ,WB[(FLGZ DIV 896),(FLGZ DIV 7).[41:7]]) END;     02245000
PROCEDURE STACK(T);    VALUE T;    INTEGER T;                           02248000
  IF NOT SPCHRSW THEN CHANGESPCHR (T) ELSE BEGIN                        02249000
  IF BWX THEN BEGIN                                                     02251000
    IF (JST~(FLGX~(FLGX+1)).[39:9])=0 THEN IF FLGX!0 THEN BEGIN         02254000
      TPOSIT~TPOSIT+1 END;                                              02257000
      PACK(TENOR[TPOSIT,   JST.[39:6]],   JST.[45:3],T) END             02260000
  ELSE STACKZ(T);                                                       02263000
END;                                                                    02264000
PROCEDURE STACK2(T); VALUE T; INTEGER T;                                02266000
  IF NOT SPCHRSW THEN CHANGESPCHR2(T) ELSE BEGIN                        02268000
 OUTB[KX~(KX+1)]~T;                                                     02269000
 IF KX}71 THEN BEGIN OUTPUT(2,0); KX~-1 END END;                        02272000
PROCEDURE CKNQ;                                                         02273000
BEGIN                                                                   02273100
  INTEGER NOMT;                                                         02273200
  NOMT~NOM; SQCT~1; WHILE NOMT.[42:6]="#" DO BEGIN                      02273300
    NOMT~NOMT.CX5; SQCT~SQCT+1 END END;                                 02273400
PROCEDURE STACKQ;                                                       02273500
BEGIN                                                                   02273600
  CKNQ;                                                                 02273700
  WHILE (SQCT~SQCT-1)}0 DO STACK("Q") END;                              02273800
PROCEDURE STACKQ2;                                                      02274000
BEGIN                                                                   02274100
  CKNQ;                                                                 02274200
  WHILE (SQCT~SQCT-1)}0 DO STACK2("Q") END;                             02274300
PROCEDURE PASS2(T); VALUE T; INTEGER T;                                 02275000
  WHILE (KPASS~T.CX1)!"#" DO BEGIN STACK2(KPASS); T~"#"&T[M5L] END;     02278000
PROCEDURE ZCMNT;                                                        02281000
BEGIN PASS2("COMMEN"); STACK2("T"); STACK2(" "); STACK2(" ") END;       02284000
PROCEDURE POSIT(N); VALUE N; INTEGER N;  WHILE KX<N DO STACK2(" ");     02287000
PROCEDURE LJUST;                                                        02290000
  IF KX}0 THEN BEGIN                                                    02293000
    WHILE KX{70 DO OUTB[KX~(KX+1)]~" "; OUTPUT(2,0); KX~-1 END;         02296000
PROCEDURE MARGIN; WHILE (KX+1)<LJSTCT DO OUTB[KX~(KX+1)]~" ";           02299000
PROCEDURE INDENT; BEGIN LJUST; MARGIN; STACK2(" ") END;                 02302000
PROCEDURE SECURE(N); VALUE N; INTEGER N; IF KX+N>71 THEN INDENT;        02305000
PROCEDURE ZSEMI; BEGIN STACK2(";"); LJUST END;                          02308000
PROCEDURE BRI(N);    VALUE N;    INTEGER N;                             02311000
BEGIN                                                                   02314000
  IF N>3 THEN BEGIN PASS2("BOOLEA"); STACK2("N") END                    02317000
  ELSE IF BOOLEAN(N) THEN PASS2("REAL##")                               02320000
  ELSE BEGIN PASS2("INTEGE"); STACK2("R") END; STACK2(" ");             02323000
  IF N>1 THEN BEGIN PASS2("ARRAY "); STACK2(" ") END END;               02326000
PROCEDURE ZAHLX(N);    VALUE N;    INTEGER N;                           02329000
BEGIN WH~0; DO WHOLD[WH~(WH+1)]~(N MOD 10) UNTIL (N~(N DIV 10)){0 END;  02332000
PROCEDURE ZAHL1(N);    VALUE N;    INTEGER N;                           02335000
BEGIN ZAHLX(N); DO STACK(WHOLD[WH]) UNTIL (WH~(WH-1)){0 END;            02338000
PROCEDURE ZAHL2(N);    VALUE N;    INTEGER N;    BEGIN                  02341000
  ZAHLX(N); IF LBSW THEN BEGIN SECURE(WH+1); STACK2("L"); LBSW~FALSE END02343000
  ELSE SECURE(WH); DO STACK2(WHOLD[WH]) UNTIL (WH~(WH-1)){0 END;        02344000
PROCEDURE EQLDEC(T);    VALUE T;    INTEGER T;                          02347000
BEGIN SEGMENT;                                                          02350000
  PASS2("[0:###");                                                      02353000
  IF T{1023 THEN ZAHL2(MIN(1022,T))                                     02356000
  ELSE BEGIN ZAHL2(T.[30:9]); PASS2(",0:511") END; STACK2("]") END;     02359000
BOOLEAN PROCEDURE QUERY(ARG,STACK);                                     02362000
  VALUE ARG;  INTEGER ARG;  INTEGER ARRAY STACK[0];                     02365000
BEGIN  LABEL QX;  INTEGER K;                                            02368000
  QUERY~TRUE; K~STACK[JTAB~0];                                          02371000
  WHILE (JTAB~(JTAB+1)){K DO IF ARG=STACK[JTAB] THEN GO TO QX;          02374000
  QUERY~FALSE; QX: END;                                                 02377000
PROCEDURE FMTST(ARG,TABLE);                                             02398000
  VALUE ARG; INTEGER ARG; INTEGER ARRAY TABLE[0];                       02401000
  IF NOT QUERY(ARG,TABLE) THEN TABLE[TABLE[0]~JTAB]~ARG;                02404000
INTEGER PROCEDURE SJUST(A);    VALUE A;    INTEGER A;                   02407000
BEGIN WHILE A.CX1=0 DO A~"#"&A[M5L]; SJUST~A END;                       02410000
BOOLEAN PROCEDURE ALFAN(T); VALUE T; INTEGER T; ALFAN~(T{9 OR ALFA[T]); 02413000
BOOLEAN PROCEDURE STCK;                                                 02414000
  BEGIN STCK~FALSE; IF READH[11]="$"THEN IF READH[6]="S" THEN           02414300
  IF READH[7]="T" THEN IF READH[8]="A" THEN IF READH[9]="R" THEN        02414700
  IF READH[10]="T" THEN STCK~TRUE END;                                  02415000
                                                                        02415200
                                                                        02415400
                                                                        02415600
STREAM PROCEDURE CONVT(A);                                              02416000
BEGIN                                                                   02416200
  SI~A; DI~A;  IF SC!"A" THEN BEGIN                                     02416400
  2(40(IF SC="#" THEN DS~1 LIT"=" ELSE                                  02416600
  IF SC="[" THEN DS~1 LIT")" ELSE                                       02416800
  IF SC="&" THEN DS~1 LIT"+" ELSE                                       02417000
  IF SC="%" THEN DS~1 LIT"(" ELSE                                       02417200
  IF SC=""" THEN DS~1 LIT"&" ELSE                                       02417400
  DI~DI+1; SI~SI+1)) END END;                                           02417600
PROCEDURE IMGREAD;                                                      02418000
BEGIN                                                                   02418200
  OWN BOOLEAN NEWTOG,SEQTOG;                                            02418300
  OWN INTEGER INCR,SWIX,I,J;                                            02418400
  OWN ARRAY CD,TP[0:9];                                                 02418500
  LABEL CARDONLY,CDTP,CDX,EXIT,EOFCD,CDT1,CDT2,CDT3,TAPEONLY,NOCRD;     02418600
  SWITCH SWGO~CARDONLY,CDTP,NOCRD,TAPEONLY;                             02418700
  SWITCH SWCDT~CDT1,CDT2,CDT3;                                          02418800
STREAM PROCEDURE RESEQ(A,B);                                            02418900
BEGIN                                                                   02419000
  SI~A; DI~B; DS~8 DEC END;                                             02419100
                                                                        02419200
STREAM PROCEDURE MOVER(A,B);                                            02419300
BEGIN                                                                   02419400
  SI~A; DI~B; DS~10 WDS END;                                            02419500
BOOLEAN STREAM PROCEDURE REPACK(A,B);                                   02419900
BEGIN                                                                   02420000
  SI~A; DI~B; 2(40(DI~DI+7; DS~CHR));                                   02420100
  SI~A; TALLY~1; 2(36(IF SC!" " THEN BEGIN TALLY~0; JUMP OUT END;       02420200
  SI~SI+1)); REPACK~TALLY END;                                          02420250
                                                                        02420300
INTEGER STREAM PROCEDURE COMP(A,B);                                     02420400
COMMENT                                                                 02420500
  COMP=1 IF A<B                                                         02420600
  COMP=2 IF A>B                                                         02420700
  COMP=3 IF A=B;                                                        02420800
                                                                        02421000
BEGIN                                                                   02421200
  LABEL EXIT;                                                           02421300
  SI~A;  DI~B;  TALLY~1; IF 8SC<DC THEN GO TO EXIT;                     02421800
  SI~A; DI~B;  TALLY~2; IF 8SC>DC THEN GO TO EXIT                       02421900
  ELSE TALLY~3;                                                         02422000
EXIT: COMP~TALLY END;                                                   02422200
INTEGER STREAM PROCEDURE SCANDOLLAR(A,B);                               02422900
COMMENT VALUE RETURNED WILL BE AS LISTED BELOW                          02423000
  0  NO $ CARD                                                          02423100
  1  $ CARD                                                             02423200
  2  $ CARD NEW TAPE                                                    02423300
  3  $ TAPE                                                             02423400
  4  $ TAPE NEW TAPE                                                    02423500
      IF RESEQ IS ON A $ CARD WHICH SPECIFIES NEW                       02423600
      THEN THE INCREMENT WILL BE STORED IN B.                           02423700
      INCREMENT FROM 1 TO 100,000;                                      02423800
BEGIN                                                                   02423900
LOCAL W1,W2,W3,   T1,T2,T3;                                             02424000
LABEL EXIT,SEQ,LOOP1,LOOP2,LOOP3;                                       02424100
  TALLY~0; SI~A; IF SC!"$" THEN GO TO EXIT; SI~SI+1;                    02424200
  DI~LOC W1; DS~4 LIT "TAPE";                                           02424300
  DI~LOC W2; DS~3 LIT "NEW"; DI~LOC W3; DS~5 LIT "RESEQ";               02424400
COMMENT MARK END OF CARD;                                               02424500
  DI~A; 2(DI~DI+36); DS~LIT ".";                                        02424600
LOOP1: IF SC=" " THEN BEGIN SI~SI+1; GO TO LOOP1 END;                   02424700
  IF SC="." THEN GO TO EXIT; DI~LOC W1; IF 4SC=DC THEN TALLY~3          02424800
  ELSE TALLY~1;                                                         02424900
                                                                        02425000
LOOP2: IF SC=" " THEN BEGIN SI~SI+1; GO TO LOOP2 END;                   02425100
  IF SC="." THEN GO TO EXIT; DI~LOC W2; IF 3SC=DC THEN BEGIN            02425200
  SI~SI+1; DI~LOC W1; IF 4SC=DC THEN TALLY~TALLY+1 END;                 02425300
LOOP3: IF SC=" " THEN BEGIN SI~SI+1; GO TO LOOP3 END;                   02425400
  IF SC="." THEN GO TO EXIT; DI~LOC W3; IF 5SC=DC THEN GO TO SEQ ELSE   02425500
  GO TO EXIT;                                                           02425600
SEQ: IF SC=" " THEN BEGIN SI~SI+1; GO TO SEQ END;                       02425700
     IF SC="." THEN GO TO EXIT; T1~TALLY; TALLY~0;                      02425800
  6(IF SC}"0" THEN BEGIN SI~SI+1; TALLY~TALLY+1 END ELSE JUMP OUT);     02425900
  T2~TALLY;                                                             02425950
  TALLY~T1; SI~SI-T2; DI~B; DS~T2 OCT;                                  02426000
EXIT: SCANDOLLAR~TALLY                                                  02426100
END SCANDOLLAR;                                                         02426200
  GO TO SWGO[SWIX]; J~0;                                                02427000
  READ(CARD,10,CD[*]); I~SCANDOLLAR(CD[0],INCR); SEQTOG~INCR!0;         02427100
  IF I=0 THEN BEGIN MOVER(CD[0],READT[0]); SWIX~1; GO TO CDX END;       02427200
  IF I=2 OR I=4 THEN NEWTOG~TRUE ELSE NEWTOG~FALSE;                     02427300
  IF I<3 THEN SWIX~1 ELSE BEGIN SWIX~2;                                 02427400
  READ(TAPE,10,TP[*]); READ(CARD,10,CD[*])[NOCRD] END;                  02427500
  GO TO SWGO[SWIX];                                                     02427600
CARDONLY: READ(CARD,10,READT[*]); GO TO CDX;                            02427700
EOFCD: SWIX~3; GO TO CDX;                                               02427800
CDTP:  I~COMP(TP[9],CD[9]); GO TO SWCDT[I];                             02427900
CDT1:  MOVER(TP[0],READT[0]); READ(TAPE,10,TP[*]); GO TO CDX;           02428000
CDT3:  READ(TAPE,10,TP[*]);                                             02428100
CDT2:  MOVER(CD[0],READT[0]); READ(CARD,10,CD[*])[EOFCD]; GO TO CDX;    02428200
NOCRD: MOVER(TP[0],READT[0]); SWIX~4;               GO TO CDX;          02428300
TAPEONLY: READ(TAPE,10,READT[*]);                                       02428400
CDX:   IF NEWTOG THEN BEGIN IF SEQTOG THEN BEGIN J~J+INCR;              02428500
       RESEQ(J,READT[9]); END;                                          02428550
       WRITE(NEWTAPE,10,READT[*]) END;                                  02428600
EXIT:  IF NOT ACD AND NOT (RBAND[0]="A" AND RBAND[1]="L" AND            02428700
       RBAND[2]="G" AND RBAND[3]="O" AND RBAND[4]="L" AND               02428800
       RBAND[5]="$") THEN CONVT(READT);                                 02428900
       IF REPACK(READT[0],READH[0])  THEN GO TO SWGO[SWIX]              02429000
END IMGREAD;                                                            02431000
PROCEDURE READC;                                                        02434000
BEGIN LABEL L1,L2,L3,L4,L5; INTEGER J,K;                                02437000
  CAB~FALSE;                                                            02437500
  IF ACD THEN IF RBAND[6]="H" THEN IF RBAND[7]="A" THEN IF RBAND[8]="L" 02438000
   THEN IF RBAND[9]="T" THEN IF RBAND[10]="$" THEN BEGIN ACD~FALSE;     02438500
  K~6;              SRCHSW~TRUE; GO TO L4 END;                          02439000
  CARTE~CARTE+1;                                                        02440000
  IF RBAND[0]="L" THEN IF RBAND[1]="A" THEN IF RBAND[2]="S"             02443000
  THEN IF RBAND[3]="T" THEN IF RBAND[4]="$" THEN L4: BEGIN J~0;         02446000
    DO BEGIN READH[J]~" "; READH[J+6]~RBAND[J+K] END UNTIL(J~(J+1))}6;  02449000
    J~11; DO READH[J]~" " UNTIL (J~(J+1))}80; GO TO L2 END;             02452000
  IMGREAD;                                                              02455000
                                                                        02455500
                                                                        02456000
    IF (READH[0]!"A" AND NOT ACD AND NOT SRCHSW AND NOT LG) THEN        02457000
      BEGIN J~0; DO RHBAND[J]~READH[J] UNTIL (J~(J+1))>80; LG~TRUE END; 02458000
  IF ACD THEN GO TO L1 ELSE IF RBAND[0]="A" AND RBAND[1]="L" AND        02459000
  RBAND[2]="G"  AND RBAND[3]="O" AND RBAND[4]="L"  AND RBAND[5]="$"     02459500
  THEN L1: BEGIN CONSW~FALSE; GO TO L5 END;                             02460000
L2: STNXT~XBWRD;                                                        02461000
  IF READH[J~0]>9 THEN J~1;                                             02464000
  DO IF READH[J]{9 THEN BEGIN                                           02467000
    STNXT~0; WHILE (READH[J]=0 OR READH[J]>9) AND J<5 DO J~(J+1);       02470000
    WHILE J<5 DO BEGIN                                                  02473000
      IF READH[J]{9 THEN STNXT~STNXT|10+READH[J]; J~(J+1) END;          02476000
    END UNTIL (J~(J+1))}5;                                              02479000
  IF READH[5]!" " THEN BEGIN                                            02482000
    IF READH[5]=0 THEN GO TO L3;                                        02485000
    IF READH[0]!" " THEN IF READH[0]>9 THEN IF READH[0]!COLMN1          02488000
      OR TYPUS="C" THEN GO TO L3;                                       02491000
                                                                        02494000
    MODUS~TYPUS; STNXT~STANO END                                        02497000
  ELSE BEGIN L3: CONSW~FALSE;                                           02500000
    IF (J~READH[0])=" " THEN MODUS~" "                                  02503000
    ELSE IF J{9 THEN MODUS~" "                                          02506000
    ELSE IF J="A" THEN BEGIN MODUS~"C"; CAB~TRUE END                    02507000
    ELSE IF T2SW AND J="F" THEN MODUS~"F"                               02508000
    ELSE IF T2SW AND J="B" THEN MODUS~"B"                               02508500
    ELSE MODUS~"C" END; L5: END;                                        02509000
PROCEDURE PASS(T); VALUE T; INTEGER T;                                  02512000
  WHILE (KPASS~T.CX1)!"#" DO BEGIN STACK(KPASS); T~"#"&T[M5L] END;      02515000
PROCEDURE RESERVEWD(M); VALUE M; INTEGER M;                             02516000
BEGIN                                                                   02516500
  NOMR~M; TBSCHR; NFIXR END;                                            02517000
PROCEDURE OPEN;                                                         02518000
BEGIN LABEL OP1,OP3,OP4,ALG,LB; OWN INTEGER CH,J,N,NH,COL;              02521000
BOOLEAN BAC;                                                            02522000
PROCEDURE TRF(A); VALUE A; INTEGER A;                                   02524000
  IF (CHCT~(CHCT+1))<CMAX THEN RBAND[CHCT]~A;                           02527000
PROCEDURE TRZ; IF (CHCT~(CHCT+1))<CMAX THEN RBAND[CHCT]~CH;             02530000
PROCEDURE PULL;                                                         02533000
BEGIN  LABEL X;                                                         02536000
  DO IF COL}71 THEN BEGIN                                               02539000
    CH~" "; IF CONSW THEN READC ELSE GO TO X;                           02542000
    IF NOT CONSW THEN GO TO X; COL~5; OUTPUT(1,0) END                   02545000
  UNTIL (CH~READH[COL~(COL+1)])!" "; X: END;                            02548000
OP1: OUTPUT(1,0); CONSW~TRUE; STANO~STNXT; COLMN1~READH[0]; CHCT~-1;    02551000
  BAC~CAB; FNSW~LGSW~FALSE;                                             02552000
  IF (TYPUS~MODUS)="F" THEN FNSW~TRUE ELSE IF TYPUS="B" THEN LGSW~TRUE  02553000
    ELSE                                                                02553100
  IF TYPUS="C" OR ACD THEN BEGIN                                        02554000
  J~-1;                                                                 02557000
    WHILE CONSW DO BEGIN IF ACD THEN COL~-1 ELSE                        02560000
      COL~0; WHILE COL<71 DO BEGIN                                      02563000
        TRF(READH[COL~(COL+1)]); IF READH[COL]!" " THEN J~CHCT END;     02566000
      READC; IF CONSW THEN OUTPUT(1,0) END;                             02569000
  IF (J~MIN(J,CMAX))}0 AND NOT SRCHSW THEN BEGIN                        02572000
  CHCT~0; IF (BAC AND IPHASE=2) OR ACD THEN GO TO ALG;                  02573000
      IF COLMN1="A" THEN BEGIN PASS("A$####"); GO TO ALG END;           02574000
      STACK("C"); STACK("$");                                           02575000
      IF COLMN1!"C" THEN BEGIN                                          02578000
        STACK("""); STACK(COLMN1); STACK("""); PASS(" CARD ") END;      02581000
     ALG: CHCT~0; WHILE RBAND[CHCT]=" " DO CHCT~(CHCT+1);               02584000
      IF IPHASE=2 THEN BEGIN DO STACK2(RBAND[CHCT])                     02585000
        UNTIL(CHCT~(CHCT+1))>J; LJUST; IF NOT ACD AND NOT CAB THEN      02586000
        BEGIN SRCHSW~TRUE; GO TO LB END END ELSE                        02586500
      DO STACK(RBAND[CHCT]) UNTIL (CHCT~(CHCT+1))>J; STACK(12) END;     02587000
    GO TO OP1 END;                                                      02590000
  LB: CARTX~CARTE; COL~5; PULL; OP3:                                    02593000
  IF CH{9 THEN BEGIN                                                    02596000
    WHOLD[N~0]~CH; PULL;                                                02599000
    WHILE CH{9 DO BEGIN WHOLD[N~(N+1)]~CH; PULL END;                    02602000
    IF CH="H" THEN BEGIN                                                02605000
      NH~WHOLD[J~0]; WHILE (J~(J+1)){N DO NH~10|NH+WHOLD[J];            02608000
                                                                        02609000
      TRF("""); J~0;                                                    02611000
      DO IF COL<71 THEN BEGIN TRF(READH[COL~(COL+1)]); J~(J+1) END      02614000
      ELSE IF CONSW THEN BEGIN                                          02617000
        READC; IF CONSW THEN BEGIN OUTPUT(1,0); COL~5 END END           02620000
      ELSE BEGIN TRF(" "); J~(J+1) END UNTIL J}NH;                      02623000
      TRF("""); OP4: PULL; IF ALFAN(CH) OR CH="(" THEN TRF(",");        02626000
      GO TO OP3 END;                                                    02629000
    J~0; DO TRF(WHOLD[J]) UNTIL (J~(J+1))>N;                            02632000
    IF CH="X" THEN BEGIN TRZ; GO TO OP4 END END;                        02635000
  IF ALFA[CH] THEN BEGIN                                                02638000
    DO BEGIN IF (CHCT~(CHCT+1))<CMAX THEN RBAND[CHCT]~CH; PULL END      02641000
    UNTIL NOT ALFA[CH] AND CH>9;                                        02644000
    GO TO OP3 END;                                                      02647000
  IF CH!" " THEN BEGIN TRZ; PULL; GO TO OP3 END;                        02650000
  IF CHCT<0 THEN IF STANO=XBWRD THEN GO TO OP1;                         02653000
  IF CHCT}CMAX THEN BEGIN OUTPUT(5,068); GO TO OP1 END;                 02656000
  RBAND[(CTOTAL~CHCT)+1]~" " END;                                       02659000
BEGIN  INTEGER J;                                                       02662000
PROCEDURE ENTER(M1,N,M2,FT,N1,N2);                                      02665000
  VALUE M1,N,M2,FT,N1,N2;    INTEGER M1,N,M2,FT,N1,N2;                  02668000
BEGIN                                                                   02671000
  NOM~N1; TBSCH; NFIX(VSPACE);                                          02674000
  CPUT(FN); MPUT(M1); ABIT~1; ARGS~N; FTYPE~FT; NAME~N2; AMODE~M2 END;  02677000
PROCEDURE INTRF(N);  VALUE N;  INTEGER N;  ENTER(FLP,1,FLP,LF,N,N);     02680000
STREAM PROCEDURE BLANKOUT(A);                                           02683000
BEGIN                                                                   02686000
  SI~A; DI~A; 10(DS~8 LIT"        ") END;                               02689000
J~"A"; DO ALFA[J]~ALFA[J+16]~ALFA[J+33]~TRUE UNTIL (J~(J+1))>"I";       02692000
  ALFA[","]~FALSE;                                                      02695000
  WAHR~TRUE; FALSCH~FALSE; BWX~TRUE; FLGX~-1; FLGZ~6;                   02698000
  BLANKOUT(READT);                                                      02700000
  READH[J~0]~"C"; DO READH[J~(J+1)]~" " UNTIL J}79;                     02701000
  J~0; DO RBAND[J]~" " UNTIL (J~(J+1))>CMAX;                            02704000
  WX[0]~WZ[0]~KEY[0]~0;      %  ARRAYS ARE INITIALLY SET TO ZERO BY MCP;02707000
                                                                        02710000
  STNXT~XBWRD; CHAR~MODUS~" ";                                          02713000
  FLSW~ALSW~TRUE; REPEATSW~FALSE;                                       02715000
  T2SW~T4SW~FALSE;                                                      02715200
  IPHASE~1;                                                             02715250
  HEADER;                                                               02715270
        OPEN; RESCAN; IF CHAR="$" THEN BEGIN                            02715300
    IF NOM.CX4="FOUR" THEN T4SW~TRUE                                    02715500
    ELSE IF NOM.CX3="TWO" THEN T2SW~TRUE                                02715600
    ELSE BEGIN OUTPUT(3,094); GO TO AUS END END                         02715700
    ELSE BEGIN OUTPUT(3,094); GO TO AUS END;                            02715900
FILL RELTAB[*] WITH 6,                                                  02716000
  "LT####",  "LE####",  "EQ####",  "NE####",  "GE####",  "GT####";      02719000
FILL RELSYM[*] WITH 6, "<", "{", "=", "!", "}", ">";                    02722000
  BOXI~XF~0;                                                            02725000
  INTRF("COS###"); INTRF("ABS###"); INTRF("SIN###"); INTRF("EXP###");   02728000
  INTRF("TANH##"); INTRF("SQRT##");                                     02731000
  ENTER(FLP,1,FLP,LF,"ATAN##","ARCTAN");                                02734000
  ENTER(FLP,2,FLP,LF,"SIGN##","TSIGN#");                                02737000
  ENTER(FLP,2,FLP,LF,"DIM###","DIM###");                                02740000
  ENTER(FLP,1,FXP,SF,"FLOAT#","######");                                02743000
IF T4SW THEN BEGIN                                                      02745000
  ENTER(FLP,1,FLP,LF,"ALOG##","LN####");                                02746000
  ENTER(FLP,1,FLP,LF,"ALOG10","LOG###");                                02749000
  ENTER(FXP,1,FLP,LF,"INT###","INT###");                                02752000
  ENTER(FXP,1,FLP,LF,"IFIX##","INT###");                                02755000
  ENTER(FXP,1,FXP,LF,"IABS##","ABS###");                                02758000
  ENTER(FXP,2,FXP,LF,"IDIM##","DIM###");                                02761000
  ENTER(FXP,2,FXP,LF,"ISIGN#","TSIGN#");                                02764000
  ENTER(FLP,1,FLP,LF,"AINT##","INT###");                                02765000
  ENTER(FXP,2,FXP,SF,"MOD###","MOD###");                                02767000
  ENTER(FLP,2,FLP,SF,"AMOD##","MOD###");                                02770000
                                                                        02773000
  ENTER(FLP,2,FXP,SF,"AMAX0#","MAX###");                                02776000
  ENTER(FLP,2,FLP,SF,"AMAX1#","MAX###");                                02779000
  ENTER(FXP,2,FXP,SF,"MAX0##","MAX###");                                02782000
  ENTER(FXP,2,FLP,SF,"MAX1##","MAX###");                                02785000
  ENTER(FLP,2,FXP,SF,"AMIN0#","MIN###");                                02788000
  ENTER(FLP,2,FLP,SF,"AMIN1#","MIN###");                                02791000
  ENTER(FXP,2,FXP,SF,"MIN0##","MIN###");                                02794000
  ENTER(FXP,2,FLP,SF,"MIN1##","MIN###");                                02797000
END;                                                                    02798000
IF T2SW THEN BEGIN                                                      02798500
  ENTER(FLP,1,FLP,LF,"LOG###","LN####");                                02799000
  ENTER(FLP,1,FLP,LF,"LOG10#","LOG###");                                02799050
  ENTER(FXP,1,FLP,LF,"XINT##","INT###");                                02799100
  ENTER(FXP,1,FLP,LF,"XFIX##","INT###");                                02799150
  ENTER(FXP,1,FXP,LF,"XABS##","ABS###");                                02799200
  ENTER(FXP,2,FXP,LF,"XDIM##","DIM###");                                02799250
  ENTER(FXP,2,FXP,LF,"XSIGN#","TSIGN#");                                02799300
  ENTER(FLP,1,FLP,LF,"INT###","INT###");                                02799350
  ENTER(FXP,2,FXP,SF,"XMOD##","MOD###");                                02799400
  ENTER(FLP,2,FLP,SF,"MOD###","MOD###");                                02799450
  ENTER(FLP,2,FXP,SF,"MAX0##","MAX###");                                02799500
  ENTER(FLP,2,FLP,SF,"MAX1##","MAX###");                                02799550
  ENTER(FXP,2,FXP,SF,"XMAX0#","MAX###");                                02799600
  ENTER(FXP,2,FLP,SF,"XMAX1#","MAX###");                                02799650
  ENTER(FLP,2,FXP,SF,"MIN0##","MIN###");                                02799700
  ENTER(FLP,2,FLP,SF,"MIN1##","MIN###");                                02799750
  ENTER(FXP,2,FXP,SF,"XMIN0#","MIN###");                                02799800
  ENTER(FXP,2,FLP,SF,"XMIN1#","MIN###");                                02799850
END;                                                                    02799900
  BOXJ~BOXI;                                                            02800000
END*;    %  THIS SEGMENT IS GIVEN BACK PERMANENTLY;                     02803000
DO BEGIN                                                                02806000
%          *****************      INIT      *****************           02809000
BEGIN INTEGER J,JJ,OKTL,DMAX; LABEL DFD,DFA;                            02812000
LABEL SP;                                                               02813000
  DEFINE STACK=STACK2#, PASS=PASS2#;                                    02815000
PROCEDURE LSET(AY);    INTEGER ARRAY AY[0];                             02818000
  IF CHAR="~" OR CHAR="=" THEN BEGIN PNX;                               02821000
    IF NHOLL{0 OR NHOLL>LMAX THEN OUTPUT(3,069) ELSE AY[0]~NHOLL END    02824000
  ELSE WHILE CHAR="," DO BEGIN  PNX;                                    02827000
    IF NHOLL{0 OR NHOLL>LMAX THEN OUTPUT(3,069) ELSE BEGIN              02830000
      AY[0]~MAX(AY[0],NHOLL); AY[NHOLL]~1 END END;                      02833000
PROCEDURE LSTN(N);    VALUE N;    INTEGER N;                            02836000
BEGIN  COMMENT  LSTN IS SPECIALIZED TO GENERATE AT MOST TWO ARGUMENTS;  02839000
  PASS("ARG1##"); IF N}2 THEN PASS(",ARG2#") END;                       02842000
PROCEDURE PRDEC(ID,N);    VALUE ID,N;    INTEGER ID,N;                  02845000
BEGIN                                                                   02848000
  IF N>0 THEN BRI(1); PASS("PROCED"); PASS("URE ##"); PASS(ID);         02851000
  STACK("("); LSTN(N); STACK(")"); STACK(";"); POSIT(33);               02854000
  PASS("VALUE "); LSTN(N); STACK(";"); POSIT(52);                       02857000
  BRI(1); LSTN(N); STACK(";"); INDENT; PASS(ID); STACK("~") END;        02860000
PROCEDURE MAXMIN(ID,OP);    VALUE ID,OP;    INTEGER ID,OP;              02863000
BEGIN                                                                   02866000
  PRDEC(ID,2); PASS("IF ARG"); STACK(1); STACK(OP); PASS("ARG2##");     02869000
  PASS(" THEN "); PASS("ARG1##"); PASS(" ELSE "); PASS("ARG2##");       02872000
  ZSEMI END;                                                            02875000
% THE FOLLOWING PROCEDURE IS USED TO EXTRACT THE SPECIFICATIONS FOR ;   02876050
%   A DISK FILE FROM THE START$ CARD. THE INFORMATION IS PLACED INTO ;  02876100
%   THE DISK ARRAY;                                                     02876150
PROCEDURE DISDES;                                                       02876200
  BEGIN INTEGER DJ;                                                     02876250
    DJ~3|(DISK[0]~DISK[0]+1);                                           02876300
    DISK [DJ]~1; DISK[DJ-1]~"######";                                   02876350
    PNX;                                                                02876400
    IF NHOLL{0 THEN OUTPUT(0,076) ELSE DISK[DJ-2].[11:5]~NHOLL;         02876450
  IF CHAR=")" THEN OUTPUT (3,85) ELSE                                   02876475
    DO BEGIN                                                            02876500
      SCAN;                                                             02876550
      IF NOM="PERM##" THEN DISK[DJ].[1:1]~1                             02876600
      ELSE IF NOM="TEMP##" THEN NOTHING                                 02876650
      ELSE IF NOM="SERIAL" THEN DISK[DJ].[2:2]~1                        02876700
      ELSE IF NOM="RANDOM" THEN NOTHING                                 02876750
      ELSE IF NOM="UPDATE" THEN DISK[DJ].[2:2]~2                        02876800
      ELSE IF NOM="SAVE##" THEN                                         02876810
        BEGIN PNX; IF NHOLL{0 OR NHOLL>1023 THEN OUTPUT (3,086)         02876820
        ELSE DISK[DJ-2].[1:10]~ NHOLL END                               02876830
      ELSE IF NOM="AREAS#" THEN                                         02876850
        BEGIN  PNX; IF NHOLL{0 OR NHOLL>20 THEN OUTPUT(3,077)           02876900
        ELSE DISK[DJ].[43:5]~NHOLL END                                  02876950
      ELSE IF NOM="LOGICA" AND NOM1="LRECOR" AND NOM2="DS####" THEN     02877000
        BEGIN  PNX; IF NHOLL{0 OR NHOLL>1048575 THEN OUTPUT(3,078)      02877050
        ELSE DISK[DJ].[4:20]~NHOLL END                                  02877100
      ELSE IF NOM="WORDS#" THEN                                         02877150
        BEGIN PNX; IF NHOLL{0 OR NHOLL>524287 THEN OUTPUT(3,079)        02877200
        ELSE DISK[DJ].[24:19]~NHOLL END                                 02877250
      ELSE IF NOM="BLOCKE" AND NOM1="DRECOR" AND NOM2="DSIZE#" THEN     02877270
        BEGIN PNX;IF NHOLL{0 THEN OUTPUT(3,079)                         02877275
        ELSE DISK[DJ-2].[16:32]~NHOLL  END                              02877280
      ELSE IF NOM="AV####" THEN                                         02877300
        BEGIN SCAN; IF FWCT>6 THEN OUTPUT(3,080)                        02877325
        ELSE BEGIN VPROC; IASV~1; BOXJ~BOXI; DISK[DJ-1]~NOM END END     02877350
      ELSE BEGIN OUTPUT(3,071); GO TO SP END;                           02877375
    END UNTIL CHAR=")";                                                 02877400
    IF DISK[DJ].[1:1]=0 AND DISK[DJ].[24:19]=0 THEN OUTPUT(3,081);      02877410
    IF DISK[DJ].[2:2]=0 AND DISK[DJ-1]="######" THEN OUTPUT(3,082);     02877420
    GNC;                                                                02877450
    IF CHAR="," THEN GNC                                                02877500
  END;                                                                  02877550
%  LOGIC FOR INITIALIZATION AND PROCESSING OF START CARD;               02878000
  PURGE(BOXJ);                                                          02881000
  KX~-1; OUTB[72]~ACOUNT~PGCT~J~0; IPHASE~1; LJSTCT~2;                  02884000
  CBNOM[0]~DATACT~BLKDCT~CARTE~0;                                       02887000
  DO BEGIN SENSW[J]~SENSL[J]~0; TAPES[J]~1 END UNTIL (J~(J+1))>LMAX;    02890000
  SENSW[0]~SENSL[0]~0; TAPES[0]~TP;                                     02893000
  FLSW~ALSW~TRUE;                                                       02893500
  IF RR4=150 THEN CARSW~FALSE ELSE CARSW~TRUE;                          02893700
  DISK[0]~0;                                                            02894000
  OKTL~TBLK;                                                            02896000
  FTT~TRUE;                                                             02897000
  BRKUSW~OKTLSW~PCOSW~PPSW~XCSW~XESW~GDSW~STSW~ISSW~FALSE;              02899000
  SRCHSW~PFXSW~TRUE; ACD~LG~LBSW~FALSE;                                 02902000
  IF REPEATSW THEN HEADER;                                              02903000
  RESCAN;                                                               02905000
  IF NOM!"START#" OR CHAR!"$" THEN BEGIN                                02908000
    DO BEGIN                                                            02911000
      DO BEGIN OPEN; RESCAN END UNTIL CHAR="$";                         02914000
      IF NOM="LAST##" THEN GO TO AUS END UNTIL NOM="START#"             02917000
        AND NOT STCK END;                                               02918000
IF CHCT<CTOTAL THEN DO BEGIN  SCAN;                                     02920000
  IF NOM="SL####" THEN LSET(SENSL)                                      02923000
  ELSE IF NOM="SW####" THEN LSET(SENSW)                                 02926000
  ELSE IF NOM="TAPES#" THEN BEGIN IF CHAR="," THEN BEGIN J~0;           02929000
    DO TAPES[J]~0 UNTIL (J~(J+1))>LMAX END; LSET(TAPES) END             02929500
  ELSE IF NOM="DISK##" THEN DO DISDES UNTIL CHAR!"("                    02930000
  ELSE IF NOM="PCO###" THEN PPSW~PCOSW~TRUE                             02932000
  ELSE IF NOM="PC####" THEN PPSW~TRUE                                   02935000
  ELSE IF NOM="SFL###" THEN FLSW~FALSE                                  02936000
  ELSE IF NOM="SAL###" THEN ALSW~FALSE                                  02936500
  ELSE IF NOM="FL####" THEN FLSW~TRUE                                   02937000
  ELSE IF NOM="AL####" THEN ALSW~TRUE                                   02937500
  ELSE IF NOM="SYNTAX" THEN STSW~TRUE                                   02937800
  ELSE IF NOM="XC####" THEN XCSW~TRUE                                   02938000
  ELSE IF NOM="XE####" THEN XESW~TRUE                                   02941000
  ELSE IF NOM="GLODCL" THEN GDSW~TRUE                                   02942000
  ELSE IF NOM="GLOBAL" AND FWCT=6 THEN BRKUSW~TRUE                      02944000
  ELSE IF NOM="ISS###" THEN ISSW~TRUE                                   02945000
  ELSE IF NOM="NOPFX#" THEN PFXSW~FALSE                                 02946000
  ELSE IF NOM="OCTAL#" THEN BEGIN  OKTLSW~TRUE;                         02947000
  IF CHAR="~" OR CHAR="=" THEN BEGIN PNX;                               02950000
    IF NHOLL{0 OR NHOLL>1023 THEN OUTPUT(3,070) ELSE OKTL~NHOLL END END 02953000
  ELSE OUTPUT(3,071) END UNTIL CHAR!"/";                                02956000
IF CHAR!"$" THEN OUTPUT(3,072);                                         02959000
SP: IPHASE~2; HEADER; PASS("BEGIN#"); LJUST;                            02962000
  PASS("FILE #"); PASS("IN ###"); PASS("CARD 0"); PASS("(2,10)"); ZSEMI;02965000
  KX~4; PASS("OUT ##"); PASS("PUNCH "); STACK(0); PASS("(2,10)"); ZSEMI;02968000
  KX~8; PASS("PRINT "); STACK(4); PASS("(2,15)"); ZSEMI;                02971000
  KX~4; PASS("XXXXXX"); STACK(" "); STACK(2); PASS("(2,15)"); ZSEMI;    02974000
  J~0; WHILE (J~(J+1)){TAPES[0] DO IF BOOLEAN(TAPES[J]) THEN BEGIN      02977000
    KX~4; PASS("TAPE##"); ZAHL2(J); STACK(" "); STACK(2);               02980000
    PASS("(2,15)"); ZSEMI END;                                          02983000
  J~0; WHILE (J~(J+1)){DISK[0] DO BEGIN                                 02984000
    IF DISK[(JJ~3|J)].[1:1]=1 THEN PASS("SAVE #");                      02984100
    PASS("FILE #");                                                     02984150
    PASS("DISK##"); ZAHL2(DISK[JJ-2].[11:5]);                           02984200
    PASS(" DISK ");                                                     02984300
    IF DISK[JJ].[2:2]=2 THEN PASS("UPDATE") ELSE IF DISK[JJ].[2:2]=0    02984400
      THEN PASS("RANDOM") ELSE PASS("SERIAL");STACK(" ");               02984500
    IF DISK[JJ].[4:20]!0 THEN BEGIN STACK("["); ZAHL2(DISK[JJ].[43:5]); 02984600
      STACK(":"); ZAHL2(DISK[JJ].[4:20]); STACK("]"); STACK(" ") END;   02984700
  PASS("(2####");    IF DISK[JJ].[24:19]=0 THEN OUTPUT(3,087) ELSE      02984800
    BEGIN STACK(","); ZAHL2(DISK[JJ].[24:19]); IF DISK[JJ-2].[16:32]!0  02984850
    THEN BEGIN STACK(","); ZAHL2(DISK[JJ-2].[16:32]) END;               02984900
      IF DISK[JJ].[1:1]=1 AND                                           02984910
    DISK[JJ-2].[1:10]!0 THEN BEGIN PASS(",SAVE "); ZAHL2(DISK[JJ-2].    02984925
    [1:10]) END END; STACK(")"); ZSEMI; DISK[JJ-2].[1:10]~0 END;        02984950
  PASS("SWITCH"); PASS(" FILE "); PASS("FILESW"); STACK("~");           02986000
  PASS("XXXXXX"); J~0;                                                  02989000
  WHILE (J~(J+1)){TAPES[0] DO BEGIN  STACK(","); SECURE(7);             02992000
  JJ~0;                                                                 02993000
  WHILE (JJ~(JJ+1)){DISK[0] DO IF J=DISK[3|JJ-2].[11:5] THEN            02993500
    BEGIN PASS("DISK##"); ZAHL2(J); GO TO DFD END;                      02994000
    IF BOOLEAN(TAPES[J]) THEN BEGIN PASS("TAPE##"); ZAHL2(J) END        02995000
    ELSE PASS("XXXXXX"); DFD: END;                                      02998000
  JJ~DMAX~0; J~J-1;                                                     02999000
  WHILE(JJ~JJ+1){DISK[0] DO DMAX~MAX(DMAX,DISK[3|JJ-2].[11:5]);         02999250
  IF DMAX>TAPES[0] THEN WHILE (J~(J+1)){DMAX DO BEGIN                   02999500
    STACK(","); SECURE(7); JJ~0; WHILE (JJ~(JJ+1)){DISK[0] DO           02999750
    IF J=DISK[3|JJ-2].[11:5] THEN BEGIN PASS("DISK##"); ZAHL2(J);       03000000
      GO TO DFA;                                                        03000100
    END; PASS("XXXXXX"); DFA: END;                                      03000250
  ZSEMI;                                                                03000500
  PASS("LABEL "); PASS(" FINIS"); ZSEMI;                                03001000
IF SENSL[0]>0 THEN BEGIN BRI(4); PASS("SENSL#"); SENSL[0]~4;            03004000
  EQLDEC(SENSL[0]); ZSEMI; END;                                         03005000
IF SENSW[0]>0 THEN BEGIN BRI(4); PASS("SENSW#"); SENSW[0]~6;            03006000
  EQLDEC(SENSW[0]); ZSEMI; END;                                         03007000
  BRI(3); PASS("DATA##"); EQLDEC(32767); STACK(";"); POSIT(32);         03008000
  PASS("COMMEN"); PASS("T USED"); PASS(" WITH "); PASS("DATA S");       03009000
  PASS("TATEME"); PASS("NTS ON"); PASS("LY####"); ZSEMI;                03009100
BRI(1); PASS("Q,XPR;"); POSIT(14); BRI(0); STACK("K");                  03010000
  J~0; WHILE(J~J+1){DISK[0] DO IF DISK[3|J-1]!"######" THEN BEGIN       03011000
  STACK(","); IF PFXSW THEN                                             03011500
    STACK("J"); PASS(DISK[3|J-1]); IF RS THEN STACKQ END; ZSEMI;        03012000
  IF READH[0]="A" THEN BEGIN SRCHSW~FALSE; IPHASE~2;                    03012300
   OPEN; END;                                                           03012700
  IF T2SW THEN BEGIN PASS("DEFINE"); PASS(" B=BOO"); PASS("LEAN##");    03012900
    STACK("#"); ZSEMI END;                                              03012950
  PASS("FORMAT"); STACK(" "); STACK("F"); STACK("("); PASS("//////");   03013000
    PASS(""STOP "); STACK("/"); PASS(" PAUSE"); PASS("  NO. ");         03016000
    STACK("""); PASS(",I5), "); PASS("OKTL(#"); ZAHL2(OKTL); STACK("O");03019000
    STACK(")"); ZSEMI;                                                  03022000
  IF SENSL[0]>0 THEN BEGIN PRDEC("SLITE#",0); KX~-1; PASS("IF ARG");    03023000
    PASS("1!0 TH"); PASS("EN SEN"); PASS("SL[ARG"); PASS("1]~TRU");     03023250
    PASS("E ELSE"); PASS(" WHILE"); PASS(" (ARG1"); PASS("~(ARG1");     03023500
    PASS("+1)){#"); PASS(SJUST(XJUST(SENSL[0]))); PASS(" DO###");       03023750
    INDENT; PASS("SENSL["); PASS("ARG1]~"); PASS("FALSE#"); ZSEMI END;  03024000
  PRDEC("INT###",1); PASS("SIGN(A"); PASS("RG1)|E"); PASS("NTIER(");    03025000
    PASS("ABS###"); PASS("(ARG1)"); STACK(")"); ZSEMI;                  03028000
  PRDEC("TANH##",1); PASS("((Q~EX"); PASS("P(ARG1"); PASS("|2))-1");    03031000
    PASS(")/(Q+1"); STACK(")"); ZSEMI;                                  03034000
  MAXMIN("MAX###","}"); MAXMIN("MIN###","{");                           03037000
  PRDEC("DIM###",2); PASS("MAX(AR"); PASS("G1-ARG"); PASS("2,0)##");    03040000
    ZSEMI;                                                              03043000
  PRDEC("TSIGN#",2); PASS("SIGN(I"); PASS("F ARG2"); PASS("=0 THE");    03046000
    PASS("N 1 EL"); PASS("SE ARG"); PASS("2)|ABS"); PASS("(ARG1)");     03047000
    ZSEMI;                                                              03049000
  PRDEC("LOG###",1); PASS("LN(ARG"); PASS("1)/2.3"); PASS("025850");    03050000
    PASS("9298##"); ZSEMI;                                              03051000
  PRDEC("ERROR#",0); KX~-1; PASS("BEGIN "); PASS("WRITE(");             03052000
    PASS("PRINT,"); PASS("F,ARG1"); PASS("); GO "); PASS("TO FIN");     03055000
    PASS("IS END"); ZSEMI;                                              03058000
  TPOSIT~0;                                                             03059000
IPHASE~1; HEADER; IF SRCHSW THEN BEGIN SRCHSW~FALSE; OPEN END ELSE      03061000
  BEGIN RHBAND[80]~XJUST(CARTE); FOROUTSP END;                          03061500
  HEADSW~FALSE END;                                                     03062000
                                                                        03063000
IF NOT PFXSW THEN BEGIN                                                 03063030
  RESERVEWD("ALPHA#");                                                  03063040
  RESERVEWD("AND###");                                                  03063050
  RESERVEWD("ARRAY#");                                                  03063060
  RESERVEWD("BEGIN#");                                                  03063070
  RESERVEWD("BREAK#");                                                  03063080
  RESERVEWD("CARD##");                                                  03063085
  RESERVEWD("CLOSE#");                                                  03063090
  RESERVEWD("DATA##");                                                  03063095
  RESERVEWD("DEFINE");                                                  03063100
  RESERVEWD("DIV###");                                                  03063110
  RESERVEWD("DO####");                                                  03063120
  RESERVEWD("DOUBLE");                                                  03063130
  RESERVEWD("DUMP##");                                                  03063140
  RESERVEWD("DX1###");                                                  03063142
  RESERVEWD("DX2###");                                                  03063144
  RESERVEWD("DX3###");                                                  03063146
  RESERVEWD("ELSE##");                                                  03063150
  RESERVEWD("END###");                                                  03063160
  RESERVEWD("EQV###");                                                  03063170
  RESERVEWD("ERROR#");                                                  03063175
  RESERVEWD("F#####");                                                  03063177
  RESERVEWD("FALSE#");                                                  03063180
  RESERVEWD("FILE##");                                                  03063190
  RESERVEWD("FILESW");                                                  03063195
  RESERVEWD("FILL##");                                                  03063200
  RESERVEWD("FINIS#");                                                  03063205
  RESERVEWD("FOR###");                                                  03063210
  RESERVEWD("FORMAT");                                                  03063220
  RESERVEWD("GEQ###");                                                  03063225
  RESERVEWD("GO####");                                                  03063230
  RESERVEWD("GTR###");                                                  03063235
  RESERVEWD("IF####");                                                  03063240
  RESERVEWD("IMP###");                                                  03063250
  RESERVEWD("IN####");                                                  03063260
  RESERVEWD("K#####");                                                  03063265
  RESERVEWD("LABEL#");                                                  03063270
  RESERVEWD("LEQ###");                                                  03063275
  RESERVEWD("LIST##");                                                  03063280
  RESERVEWD("LOCK##");                                                  03063290
  RESERVEWD("MAX###");                                                  03063293
  RESERVEWD("LSS###");                                                  03063295
  RESERVEWD("MIN###");                                                  03063297
  RESERVEWD("MOD###");                                                  03063300
  RESERVEWD("NEQ###");                                                  03063305
  RESERVEWD("NOT###");                                                  03063310
  RESERVEWD("OCT###");                                                  03063320
  RESERVEWD("OR####");                                                  03063330
  RESERVEWD("OUT###");                                                  03063340
  RESERVEWD("OWN###");                                                  03063350
  RESERVEWD("PRINT#");                                                  03063352
  RESERVEWD("PUNCH#");                                                  03063353
  RESERVEWD("Q#####");                                                  03063355
  RESERVEWD("READ##");                                                  03063360
  RESERVEWD("REAL##");                                                  03063370
  RESERVEWD("REWIND");                                                  03063380
  RESERVEWD("SAVE##");                                                  03063390
  RESERVEWD("SPACE#");                                                  03063400
  RESERVEWD("STEP##");                                                  03063410
  RESERVEWD("STREAM");                                                  03063420
  RESERVEWD("SWITCH");                                                  03063430
  RESERVEWD("TSIGN#");                                                  03063435
  RESERVEWD("THEN##");                                                  03063440
  RESERVEWD("TO####");                                                  03063450
  RESERVEWD("TRUE##");                                                  03063460
  RESERVEWD("UNTIL#");                                                  03063470
  RESERVEWD("VALUE#");                                                  03063480
  RESERVEWD("WHILE#");                                                  03063490
  RESERVEWD("WITH##");                                                  03063500
  RESERVEWD("WRITE#");                                                  03063510
  RESERVEWD("XPR###");                                                  03063515
  RESERVEWD("ZIP###");                                                  03063520
  RESERVEWD("ARCTAN");                                                  03063530
  RESERVEWD("ENTIER");                                                  03063540
  RESERVEWD("LN####");                                                  03063550
  RESERVEWD("TIME##");                                                  03063560
  RESERVEWD("TAPE1#");                                                  03063566
  RESERVEWD("TAPE2#");                                                  03063567
  RESERVEWD("TAPE3#");                                                  03063568
  RESERVEWD("TAPE4#");                                                  03063569
  RESERVEWD("TAPE5#");                                                  03063570
  RESERVEWD("TAPE6#");                                                  03063571
  RESERVEWD("TAPE7#");                                                  03063572
  RESERVEWD("TAPE8#");                                                  03063573
  RESERVEWD("TAPE9#");                                                  03063574
  RESERVEWD("TAPE10");                                                  03063575
  RESERVEWD("TAPE11");                                                  03063576
  RESERVEWD("TAPE12");                                                  03063577
  RESERVEWD("TAPE13");                                                  03063578
  RESERVEWD("TAPE14");                                                  03063579
  RESERVEWD("TAPE15");                                                  03063580
  RESERVEWD("TAPE16");                                                  03063581
END;                                                                    03063590
%          *************      END OF INIT      *************            03064000
  DO BEGIN                                                              03067000
%          *****************      RNIT      *****************           03070000
BEGIN SEGMENT;                                                          03073000
  RESCAN; IF NOM="ALGOL#" AND CHAR="$" THEN BEGIN SRCHSW~FALSE;         03074000
    IPHASE~2; ACD~TRUE; HEADER; OPEN; SRCHSW~FALSE; IPHASE~1;           03074500
    HEADER; HEADSW~FALSE; OPEN; RESCAN; IF CHAR ="$" AND (NOM="START#"  03075000
    OR NOM="LAST##" OR NOM="FINISH") THEN GO TO STPH3 END;              03075500
  PURGE(BOXJ);                                                          03076000
  IGCK~TRUE;                                                            03077000
  IPHASE~1; IF HEADSW THEN HEADER;                                      03079000
  DFCNSW~FCNSW~GLOBSW~HEADSW~LISTSW~SUBSW~FALSE; DFSW~SRCHSW~TRUE;      03082000
  BLKDSW~DATASW~FALSE;                                                  03083000
  FNSW~LGSW~FALSE;                                                      03084000
  KX~RSVX~-1;RSVZ~FLGZ~6;                                               03085000
  PNAME~XBWRD; BOXA~0; BOXL~BOXI;                                       03088000
  BOXDV~BOXDC~0;                                                        03090000
  BOXC~BOXE~BOXMD~JXLS~JSWGO~LISTCT~0;                                  03091000
  ASTACK[0]~ASNVAR[0]~DOTAB[0]~0;                                       03094000
  DFCT~DXCT~EQUMAX~IXCT~SVL~0 END;                                      03097000
%          *****************      PH1      *****************            03100000
BEGIN  LABEL NEXT,RECOVER;                                              03103000
INTEGER NX;        %  PARTIAL WORD FIELD REGISTER;                      03106000
BOOLEAN ATSIGN;    %  USED BY N CAN,NXDMP;                              03107000
RECURSIVE PROCEDURE NSEXP; FORWARD;                                     03109000
RECURSIVE PROCEDURE STMNT;  FORWARD;                                    03112000
RECURSIVE PROCEDURE ARTHX; FORWARD;                                     03115000
RECURSIVE PROCEDURE BEXP; FORWARD;                                      03118000
RECURSIVE PROCEDURE FMTSPEC; FORWARD;                                   03121000
RECURSIVE PROCEDURE LISTEL; FORWARD;                                    03124000
RECURSIVE PROCEDURE NSARGL; FORWARD;                                    03127000
RECURSIVE PROCEDURE SFNOM; FORWARD;                                     03130000
RECURSIVE PROCEDURE ARTHI; FORWARD;                                     03133000
RECURSIVE PROCEDURE XPRCALL(M);    VALUE M;    INTEGER M;    FORWARD;   03136000
RECURSIVE PROCEDURE ARGCALL(M,T);  VALUE M,T;  INTEGER M,T;  FORWARD;   03139000
RECURSIVE PROCEDURE DLISTEL(K1);  INTEGER K1;  FORWARD;                 03140000
RECURSIVE PROCEDURE BLCOM; FORWARD;                                     03141000
RECURSIVE BOOLEAN PROCEDURE DXQ;  FORWARD;                              03142000
PROCEDURE ZAHL(T);    VALUE T;    INTEGER T;                            03145000
  IF T{0 THEN STACK(0) ELSE PASS(SJUST(XJUST(T)));                      03148000
PROCEDURE ERRMSG(T);    VALUE T;    INTEGER T;                          03151000
BEGIN  INTEGER K;                                                       03154000
  IF DFCNSW THEN BEGIN SQUEEZE(ALTO,BASSO); DFCNSW~FALSE END;           03157000
  LISTSW~SRCHSW~FALSE; FLGZ~RSVZ; INDEX[0]~0;                           03160000
  IF (K~(FLGX.[25:14]-RSVX.[25:14]))>0 THEN BEGIN                       03163000
    WHILE (K~(K-1))>0 DO BEGIN TPOSIT~TPOSIT-1 END;                     03166000
    IF RSVX.[39:9]!511 THEN BEGIN TPOSIT~TPOSIT-1 END                   03169000
    END;                                                                03172000
  BWX~TRUE; FLGX~RSVX; OUTPUT(3,T);                                     03175000
  STACK("X"); STACK("$"); ZAHL(CARTX);                                  03178000
  IF CARTE>CARTX+1 THEN BEGIN STACK(","); ZAHL(CARTE-1) END;            03181000
  SVL~0; GO TO RECOVER END;                                             03184000
PROCEDURE CUTBACK(K);    VALUE K;    INTEGER K;                         03187000
BEGIN  INTEGER J;                                                       03190000
  J~-1; WHILE (K~(K+1)){CTOTAL DO RBAND[J~(J+1)]~RBAND[K]; CTOTAL~J;    03193000
  RBAND[J+1]~" " END;                                                   03196000
PROCEDURE NPROC;                                                        03199000
BEGIN  OWN INTEGER K;                                                   03202000
  VPROC;                                                                03205000
  IF (K~MODE)=UNDEF THEN MPUT(DFALT(NOM))                               03208000
  ELSE IF K>FLP THEN ERRMSG(001) END;                                   03211000
                                                                        03214000
                                                                        03217000
PROCEDURE LPROC(L);    VALUE L;    INTEGER L;                           03220000
BEGIN SEGMENT; NOM~L; TBSCH;                                            03223000
  IF NOT TBSW THEN BEGIN NFIX(3); CPUT(LB) END END;                     03226000
PROCEDURE LPULL;                                                        03229000
BEGIN SEGMENT;                                                          03232000
  PNX; IF NHOLL{0 THEN ERRMSG(002); IF NHOLL>99999 THEN ERRMSG(03);     03235000
  LPROC(NHOLL) END;                                                     03238000
PROCEDURE ADJZ; BEGIN BWX~FALSE; WHILE (FLGZ MOD 7)!6 DO STACK("#") END;03241000
PROCEDURE VERIFY(CX);  VALUE CX; INTEGER CX;  IF CHAR!CX THEN ERRMSG(4);03244000
PROCEDURE NDUMP; BEGIN PASS(NOM); IF FWCT>6 THEN ERRMSG(05) END;        03247000
PROCEDURE DUMPH; BEGIN INTEGER J; J~0; WHILE (J~(J+1)){NHMX DO          03250000
       STACK(WHOLD[J]); NHMX~0 END;                                     03253000
PROCEDURE SKAN;                                                         03256000
BEGIN SCAN;                                                             03259000
  IF FWCT{0 THEN ERRMSG(6); IF(T4SW AND FWCT>6) OR (T2SW AND FWCT>7)    03262000
    THEN ERRMSG(5);                                                     03263000
    IF NOT ALFA[NOM.CX1] THEN ERRMSG(7) END;                            03265000
PROCEDURE PNCHECK;                                                      03266000
BEGIN SEGMENT; PNX; IF NHMX{0 THEN ERRMSG(06) END;                      03267000
PROCEDURE PNSCAN;                                                       03268000
BEGIN PNCHECK; IF NHOLL{0 THEN ERRMSG(08) END;                          03271000
PROCEDURE RSWDZ;                                                        03274000
BEGIN SEGMENT;  NPROC; USE~1;                                           03277000
  IF LCLASS{NSV THEN BEGIN CPUT(NSV); STACK("J"); PASS(NOM) END         03280000
  ELSE ERRMSG(09) END;                                                  03283000
PROCEDURE MFIELD;                                                       03286000
  IF RBAND[CHCT+1]{9 THEN BEGIN                                         03289000
    PNX; NOM~NHOLL END                                                  03292000
  ELSE SKAN;                                                            03295000
PROCEDURE SCREEN(N);    VALUE N;    INTEGER N;                          03298000
BEGIN  STACK("J"); PASS(N) END;                                         03301000
PROCEDURE PASSJ(N);    VALUE N;    INTEGER N;                           03304000
  IF N.CX1>9 THEN SCREEN(N) ELSE ZAHL(N);                               03307000
PROCEDURE SVPASS;                                                       03310000
BEGIN  USE~1; STACK("%"); NDUMP; STACK("[") END;                        03313000
PROCEDURE ARGBCT(B);    VALUE B;    BOOLEAN B;                          03316000
BEGIN  INTEGER C,L;             COMMENT                                 03319000
  RG1=ARG COUNT/RG2=POSITION OF LAST ")"/RG3=LAST "-"/RG4=LAST "=";     03322000
  L~RG1~RG3~RG4~CEQ~0; RG2~CHCT;                                        03325000
  DO BEGIN                                                              03328000
    IF (C~RBAND[RG2~(RG2+1)])=""" THEN DO                               03331000
      UNTIL (C~RBAND[RG2~(RG2+1)])=""" OR RG2>CTOTAL;                   03334000
    IF C{9 THEN BEGIN                                                   03337000
      DO UNTIL (C~RBAND[RG2~(RG2+1)])>9;                                03340000
      IF C="." THEN DO UNTIL (C~RBAND[RG2~(RG2+1)])>9;                  03343000
      IF C="E" THEN BEGIN                                               03346000
        IF (C~RBAND[RG2~(RG2+1)]){9 THEN RBAND[RG2-1]~"@"               03349000
        ELSE IF C="+" OR C="-" AND RBAND[RG2+1]{9 THEN BEGIN            03352000
          RBAND[RG2-1]~"@"; C~0 END END END;                            03355000
    WHILE ALFAN(C) DO C~RBAND[RG2~(RG2+1)];                             03358000
  IF C="(" THEN L~L+1                                                   03361000
  ELSE IF C=")" THEN BEGIN                                              03364000
    IF (L~(L-1))<0 THEN BEGIN                                           03367000
      RG1~RG1+1; IF B THEN SVCH[SVL,RG1]~RG2 END END                    03370000
  ELSE IF L=0 THEN BEGIN                                                03373000
    IF C="," THEN BEGIN RG1~RG1+1; IF B THEN SVCH[SVL,RG1]~RG2 END      03376000
    ELSE IF C="=" THEN BEGIN RG4~RG2; CEQ~CEQ+1 END ELSE IF C="-"       03379000
    THEN IF RBAND[RG2-1]!"@" AND RBAND[RG2-1]!"(" THEN RG3~RG2 END      03382000
  ELSE IF C="=" THEN CEQ~CEQ+1 END                                      03383000
  UNTIL L<0 OR C=" " END;                                               03385000
PROCEDURE ARGCT;  ARGBCT(FALSE);                                        03388000
PROCEDURE SVPR;                                                         03391000
BEGIN INTEGER CX,JRG,K,JRGFN;                                           03394000
BOOLEAN CC,EC;                                                          03395000
  CC~FALSE; EC~FALSE;                                                   03396000
  SVL~SVL+1; SVCH[SVL,0]~CHCT; SVPASS; SVDCMP;                          03397000
  IF CB THEN CC~TRUE; IF EB THEN EC~TRUE;                               03398000
  ARGBCT(TRUE); IF DCT!(JRG~RG1) THEN ERRMSG(011); CX~RG2;              03400000
  IF ISSW AND NOT (CC OR EC) THEN JRGFN~0;                              03401000
  DO BEGIN                                                              03403000
  IF ISSW AND (NOT(CC OR EC) OR GDSW)                                   03403300
          THEN JRGFN~JRGFN+1 ELSE JRGFN~JRG;                            03403500
  K~CHCT~SVCH[SVL,JRGFN-1]; PNX;                                        03404000
    IF NHMX>0 AND (CHAR="," OR CHAR=")") THEN BEGIN                     03405000
      STACK("#"); ZAHL(NHOLL) END                                       03406000
    ELSE BEGIN CHCT~K; STACK("*"); ARTHX END;                           03407000
  IF CHCT!SVCH[SVL,JRGFN] THEN ERRMSG(012);                             03408000
    STACK(IF JRG>1 THEN "," ELSE "]") END UNTIL (JRG~(JRG-1)){0;        03409000
  SVL~SVL-1; CHCT~CX; GNC END;                                          03412000
PROCEDURE SPEW(N,X);  VALUE N,X;  INTEGER N,X;                          03415000
  WHILE (N~(N-1))}0 DO STACK(X);                                        03418000
PROCEDURE NSCAN;                                                        03421000
BEGIN  COMMENT  CHAR MUST CONTAIN EITHER "." OR "@" OR A NUMERAL;       03424000
  DEFINE  CNEXT=RBAND[CHCT+1]#;                                         03427000
  GANZ~NULLEN~BRUCH~POTENZ~0; ZSW~FALSE;                                03430000
  IF CHAR{9 THEN BEGIN CHCT~CHCT-1; PNX; GANZ~NHOLL; ZSW~TRUE END;      03433000
  IF CHAR="." AND NOT (ALFA[RBAND[CHCT+2]] AND ALFA[CNEXT]) THEN BEGIN  03436000
    WHILE CNEXT=0 DO BEGIN NULLEN~NULLEN+1; CHCT~CHCT+1 END;            03439000
    ZSW~TRUE; PNX; BRUCH~NHOLL END;                                     03442000
  IF CHAR="E" THEN BEGIN                                                03445000
    IF (CHAR~CNEXT){9 THEN RBAND[CHCT]~CHAR~"@"                         03448000
    ELSE IF (CHAR="+" OR CHAR="-") AND RBAND[CHCT+2]{9 THEN             03451000
      RBAND[CHCT]~CHAR~"@" END;                                         03454000
  IF (ATSIGN~(CHAR="@")) THEN BEGIN GNC;                                03457000
    IF CHAR="+" THEN BEGIN PNCHECK; POTENZ~NHOLL END                    03460000
    ELSE IF CHAR="-" THEN BEGIN PNCHECK; POTENZ~-NHOLL END              03463000
    ELSE IF CHAR{9 THEN BEGIN CHCT~CHCT-1; PNX; POTENZ~NHOLL END        03466000
    ELSE ERRMSG(065);                                                   03469000
    IF GANZ=0 AND POTENZ>0 THEN BEGIN                                   03472000
      IF POTENZ>NULLEN THEN BEGIN POTENZ~POTENZ-NULLEN; NULLEN~0 END    03475000
      ELSE BEGIN NULLEN~NULLEN-POTENZ; POTENZ~0 END END END END;        03478000
PROCEDURE NXDMP;                                                        03481000
BEGIN SEGMENT;     %  NSCAN MUST HAVE BEEN PREVIOUSLY CALLED;           03484000
  IF GANZ>0 THEN ZAHL1(GANZ);                                           03487000
  IF BRUCH!0 THEN BEGIN STACK("."); SPEW(NULLEN,0); ZAHL1(BRUCH) END;   03490000
  IF POTENZ=0 THEN BEGIN                                                03493000
    IF GANZ=0 AND BRUCH=0 THEN ZAHL(IF ATSIGN AND NOT ZSW THEN 1 ELSE 0)03494000
    END                                                                 03495000
  ELSE IF POTENZ>0 THEN BEGIN STACK("@"); ZAHL(POTENZ) END              03496000
  ELSE BEGIN STACK("@"); STACK("-"); ZAHL(ABS(POTENZ)) END END;         03499000
PROCEDURE FTRIM;                                                        03500000
  BEGIN WHILE NOM.[42:6]="#" DO NOM~NOM.CX5;                            03500300
  IF FWCT{6 THEN NOM~SJUST(NOM.CX5); FWCT~FWCT-1 END;                   03500700
BOOLEAN PROCEDURE FNTEST;                                               03501000
  BEGIN FNTEST~FALSE;                                                   03501300
  IF CHAR="(" AND (FWCT}4 AND                                           03501700
    RBAND[CHCT-1]="F") THEN FNTEST~TRUE END;                            03501800
BOOLEAN PROCEDURE DXCHECK;                                              03502000
  IF (DXCHECK~LISTSW) THEN DXCHECK~QUERY(NOM,INDEX);                    03505000
PROCEDURE XTYPE;                                                        03508000
BEGIN    COMMENT    CAUTION:  XTYPE DOES NOT RESTORE NOM OR FWCT;       03511000
  LABEL L1;  INTEGER CT,CT1;                                            03514000
  CT~CHCT; CT1~CHAR;                                                    03517000
L1: GNC;                                                                03520000
    IF ALFA[CHAR] THEN BEGIN  CHCT~CHCT-1; SKAN;                        03523000
      IF DXCHECK THEN FXPSW~TRUE                                        03526000
      ELSE BEGIN IF T2SW AND FNTEST THEN FTRIM;                         03529000
        NPROC; FXPSW~MODE=FXP END END                                   03530000
    ELSE IF CHAR="." THEN FXPSW~FALSE                                   03531000
    ELSE IF CHAR{9 THEN BEGIN SCAN;                                     03532000
      IF CHAR="@" THEN FXPSW~FALSE                                      03534000
      ELSE IF CHAR="." THEN BEGIN SCAN; IF(QUERY(NOM,RELTAB) AND        03535000
        CHAR=".") THEN FXPSW~TRUE ELSE FXPSW~FALSE END                  03536000
      ELSE IF CHAR!"E" THEN FXPSW~TRUE                                  03538000
      ELSE IF (CHAR~RBAND[CHCT+1]){9 THEN FXPSW~FALSE                   03541000
      ELSE FXPSW~((CHAR!"+" AND CHAR!"-") OR RBAND[CHCT+2]>9) END       03544000
    ELSE IF CHCT}CTOTAL THEN ERRMSG(13) ELSE GO TO L1;                  03547000
  CHAR~CT1; CHCT~CT END;                                                03550000
BOOLEAN PROCEDURE ARITHOP;                                              03553000
BEGIN SEGMENT;  ARITHOP~TRUE;                                           03556000
  IF CHAR="|" OR CHAR="+" OR CHAR="-" THEN STACK(CHAR)                  03559000
  ELSE IF CHAR="*" THEN BEGIN                                           03562000
    IF CNEXT!"*" THEN STACK("|") ELSE BEGIN STACK("*"); GNC END END     03565000
  ELSE IF CHAR="/" THEN BEGIN                                           03568000
    XTYPE; IF FXPSW THEN PASS(" DIV #") ELSE STACK("/") END             03571000
  ELSE ARITHOP~FALSE END;                                               03574000
PROCEDURE DFPROC;                                                       03577000
BEGIN  INTEGER K,KPNT,L;                                                03580000
  IF PFXSW THEN BEGIN STACK("D"); STACK("F") END;                       03583000
    NDUMP; IF RS THEN STACKQ; STACK("("); KPNT~PNT; K~ARGL; L~0;        03584000
  DO BEGIN                                                              03586000
    PNT~(L~(L+1))+K; XPRCALL(MODE);                                     03589000
    STACK(CHAR) END UNTIL CHAR!","; VERIFY(")");                        03592000
  PNT~KPNT; IF ARGS!L THEN ERRMSG(014); GNC END;                        03595000
PROCEDURE LFNAME;  PASS(NAME);                                          03598000
PROCEDURE LFPROC;  BEGIN LFNAME; ARGCALL(AMODE,ARGS) END;               03601000
PROCEDURE MAXMIN;  %  LEFT PARENTHESIS MUST BE PRESENT;                 03604000
BEGIN  BOOLEAN B;  INTEGER AM,N;                                        03607000
  IF (N~NAME)="MAX###" OR N="MIN###" THEN BEGIN                         03610000
    IF (B~((AM~AMODE)=FLP AND MODE=FXP)) THEN PASS("INT(##");           03613000
    ARGCT; IF RG1<2 THEN ERRMSG(066);                                   03616000
    DO BEGIN PASS(N); STACK("(") END UNTIL (RG1~(RG1-1))<2;             03619000
    XPRCALL(AM); VERIFY(","); STACK(",");                               03622000
    DO BEGIN XPRCALL(AM); STACK(")"); IF CHAR="," THEN STACK(",") END   03625000
    UNTIL CHAR!","; VERIFY(")"); IF B THEN STACK(")"); GNC END          03628000
  ELSE ERRMSG(015) END;                                                 03631000
PROCEDURE MODF(M);    VALUE M;    INTEGER M;                            03634000
BEGIN SEGMENT;                                                          03637000
  STACK("("); STACK("("); XPRCALL(M); VERIFY(","); PASS(") MOD ");      03640000
   STACK("("); XPRCALL(M); VERIFY(")"); STACK(")"); STACK(")"); GNC END;03643000
PROCEDURE SFPROC;                                                       03646000
BEGIN SEGMENT;                                                          03649000
  IF CHAR="(" THEN BEGIN                                                03652000
    IF NOM="FLOAT#" THEN ARGCALL(FXP,1)                                 03655000
    ELSE IF T4SW AND NOM="MOD###" OR T2SW AND NOM="XMOD##"              03658000
      THEN MODF(FXP)                                                    03659000
    ELSE IF T4SW AND NOM="AMOD##" OR T2SW AND NOM="MOD###"              03661000
      THEN MODF(FLP)                                                    03662000
    ELSE MAXMIN END                                                     03664000
  ELSE SFNOM END;                                                       03667000
PROCEDURE FNPR;              %  CHAR MUST CONTAIN A LEFT PARENTHESIS;   03670000
BEGIN  INTEGER C;                                                       03673000
  IF (C~LCLASS)=UNDEF OR C=PR THEN BEGIN CPUT(FN); FTYPE~FF END         03676000
  ELSE IF C!FN THEN ERRMSG(016);                                        03679000
  IF(C~FTYPE)=FF THEN BEGIN                                             03682000
    IF PFXSW THEN BEGIN STACK("F"); STACK("N") END;                     03682500
    NDUMP; IF RS THEN STACKQ; NSARGL END                                03683000
  ELSE IF C=DF THEN DFPROC                                              03685000
  ELSE IF C=LF THEN LFPROC                                              03688000
  ELSE IF C=SF THEN SFPROC                                              03691000
  ELSE ERRMSG(015) END;                                                 03694000
PROCEDURE STRPR;                                                        03697000
BEGIN SEGMENT;                                                          03700000
  STACK("""); GNC; STACK(CHAR);                                         03703000
  DO BEGIN GNC; STACK(CHAR) END UNTIL CHAR=""" OR CHCT}CTOTAL;          03706000
  VERIFY("""); GNC END;                                                 03709000
PROCEDURE XPRCALL(M); VALUE M; INTEGER M;  BEGIN                        03712000
  GNC; IF CHAR=""" THEN STRPR ELSE BEGIN CHCT~CHCT-1;                   03714000
  IF M=FLP THEN ARTHX ELSE IF M=FXP THEN ARTHI ELSE IF M=BOO THEN BEXP  03715000
  ELSE ERRMSG(017)END END;                                              03718000
PROCEDURE ARGCALL(M,T);    VALUE M,T;    INTEGER M,T;                   03721000
BEGIN  INTEGER L;                                                       03724000
  IF T>0 THEN BEGIN                                                     03727000
    STACK("("); L~0;                                                    03730000
    DO BEGIN  L~L+1; XPRCALL(M); STACK(CHAR) END UNTIL CHAR!",";        03733000
    VERIFY(")"); IF L!T THEN ERRMSG(014); GNC END END;                  03736000
PROCEDURE ITEMQ;             %  IF LISTSW THEN CHECK DXQ BEFORE ENTRY.  03739000
BEGIN  OWN INTEGER CLASS;    %  NPROC HAS ALREADY DETERMINED THE MODE;  03742000
  IF CHAR="(" THEN BEGIN IF LCLASS=SV THEN SVPR ELSE FNPR END           03745000
  ELSE IF (CLASS~LCLASS)=NSV THEN BEGIN STACK("J"); PASS(NOM) END       03748000
  ELSE IF CLASS=UNDEF THEN BEGIN CPUT(NSV); STACK("J"); PASS(NOM) END   03751000
  ELSE IF CLASS=DA THEN BEGIN PASS("ARG###"); PASS(NOM) END             03754000
  ELSE ERRMSG(18) END;                                                  03757000
PROCEDURE ARTHPRIM;                                                     03760000
  BEGIN IF T2SW AND FNTEST THEN FTRIM; NPROC; USE~1; ITEMQ END;         03761000
PROCEDURE SFNOM;                                                        03763000
BEGIN SEGMENT;                                                          03766000
  IF NOM="MOD###" OR NOM="AMOD##" OR NOM="XMOD##" THEN PASS("MOD###")   03769000
  ELSE ERRMSG(015) END;                                                 03772000
PROCEDURE FNOM;                                                         03775000
BEGIN  INTEGER F;                                                       03778000
  IF (F~FTYPE)=SF THEN SFNOM                                            03781000
  ELSE IF F=LF THEN LFNAME                                              03784000
  ELSE IF F=FF THEN BEGIN                                               03787000
    IF PFXSW THEN BEGIN STACK("F"); STACK("N") END; NDUMP;              03788000
    IF RS THEN STACKQ END                                               03789000
  ELSE IF F=DF THEN BEGIN                                               03790000
    IF PFXSW THEN BEGIN STACK("D"); STACK("F") END; NDUMP;              03791000
    IF RS THEN STACKQ END                                               03792000
  ELSE ERRMSG(015) END;                                                 03793000
PROCEDURE NSARG;                                                        03796000
BEGIN  INTEGER C,K;                                                     03799000
  IF ALFA[CNEXT] THEN BEGIN  K~CHCT; SKAN;                              03802000
    IF CHAR="," OR CHAR=")" THEN BEGIN                                  03805000
      IF DXCHECK THEN BEGIN RESULT~FXP; C~NSV END                       03808000
      ELSE BEGIN VPROC; ALTER~1; USE~1;                                 03811000
        IF (C~LCLASS)=UNDEF THEN CPUT(C~NSV);                           03814000
        IF (RESULT~MODE)=UNDEF THEN MPUT(RESULT~DFALT(NOM)) END;        03817000
      IF C=NSV OR C=DA THEN ITEMQ                                       03820000
      ELSE IF C=SV THEN BEGIN STACK("%"); NDUMP END                     03823000
      ELSE IF C=PR THEN BEGIN STACK("Z"); NDUMP END                     03826000
      ELSE IF C=FN THEN FNOM                                            03829000
      ELSE IF C=SR THEN BEGIN                                           03832000
        IF PFXSW THEN BEGIN STACK("S"); STACK("R") END;                 03832500
        NDUMP;IF RS THEN STACKQ END                                     03833000
      ELSE ERRMSG(020) END                                              03835000
    ELSE BEGIN CHCT~K; NSEXP END END                                    03838000
  ELSE NSEXP END;                                                       03841000
PROCEDURE NSARGL;                                                       03844000
BEGIN  INTEGER L;                                                       03847000
  L~0; STACK("(");                                                      03850000
  DO BEGIN L~L+1; NSARG; STACK(CHAR) END UNTIL CHAR!",";                03853000
  NSRG~L; VERIFY(")"); GNC END;                                         03856000
PROCEDURE PRIMARY;                                                      03859000
BEGIN SEGMENT;  GNC;                                                    03862000
  IF ALFA[CHAR] THEN BEGIN  CHCT~CHCT-1; SKAN;                          03865000
    IF LISTSW THEN IF DXQ THEN NOTHING ELSE ARTHPRIM ELSE ARTHPRIM END  03868000
  ELSE IF CHAR="@" OR CHAR{9 THEN BEGIN NSCAN; NXDMP END                03871000
  ELSE IF CHAR="." AND CNEXT{9 THEN BEGIN NSCAN; NXDMP END              03874000
  ELSE IF CHAR="(" THEN BEGIN                                           03877000
    STACK("("); ARTHX; VERIFY(")"); STACK(")"); GNC END                 03880000
  ELSE IF CHAR=""" THEN STRPR ELSE ERRMSG(21) END;                      03883000
PROCEDURE FACTOR;                                                       03886000
BEGIN IF LGSW AND (CHAR!"(" AND (CNEXT!"(" AND RBAND[CHCT+2]!"-"))      03889000
  THEN BEGIN PASS("B(####"); PRIMARY;                                   03889500
    STACK(")") END ELSE PRIMARY;                                        03890000
  IF CHAR="*" THEN IF CNEXT!"*" THEN CHAR~"|" ELSE BEGIN                03892000
    IF LGSW THEN ERRMSG(090) ELSE                                       03893000
    STACK("*"); GNC; FACTOR END END;                                    03895000
PROCEDURE TERM;                                                         03898000
BEGIN  FACTOR;                                                          03901000
  IF LGSW THEN BEGIN IF CHAR="|" THEN BEGIN  PASS(" AND #"); TERM END   03902000
    ELSE IF CHAR="/" THEN ERRMSG(090) END ELSE                          03903000
  IF CHAR="|" THEN BEGIN STACK("|"); TERM END                           03904000
  ELSE IF CHAR="/" THEN BEGIN                                           03907000
    XTYPE; IF FXPSW THEN PASS(" DIV #") ELSE STACK("/"); TERM END END;  03910000
PROCEDURE ARTHP;                                                        03913000
BEGIN INTEGER K; TERM;                                                  03916000
  IF LGSW THEN BEGIN IF CHAR="+" THEN BEGIN PASS(" OR ##"); ARTHP END   03917000
    ELSE IF CHAR="-" THEN BEGIN IF RBAND[CHCT-1]!"(" AND                03917300
    ((K~RBAND[CHCT-2])!"*" OR K!"+") THEN ERRMSG(091) ELSE              03917700
    PASS(" NOT ##"); ARTHP END END ELSE                                 03918000
  IF CHAR="+" OR CHAR="-" THEN BEGIN STACK(CHAR); ARTHP END END;        03919000
PROCEDURE ARTHX;                                                        03922000
BEGIN  GNC;                                                             03925000
  IF LGSW AND CHAR="-" THEN  PASS(" NOT #") ELSE                        03927000
  IF CHAR="-" THEN STACK("-") ELSE IF CHAR!"+" THEN CHCT~CHCT-1;        03928000
ARTHP END;                                                              03931000
PROCEDURE ARTHI;                                                        03934000
BEGIN SEGMENT;  XTYPE; IF FXPSW THEN ARTHX                              03937000
  ELSE BEGIN PASS("INT(##"); ARTHX; STACK(")") END END;                 03940000
PROCEDURE RVSG;                                                         03943000
BEGIN SEGMENT; TERM; IF CHAR="+" THEN BEGIN STACK("-"); RVSG END END;   03946000
BOOLEAN PROCEDURE NOPE;                                                 03949000
BEGIN  OWN INTEGER J,K;                                                 03952000
  IF (NOPE~(CNEXT="." AND ALFA[RBAND[CHCT+2]])) THEN BEGIN              03955000
    J~CHCT; K~CHAR; GNC; SCAN;                                          03958000
    IF NOM="NOT###" AND CHAR="." THEN BEGIN NDUMP; STACK(" ") END       03961000
    ELSE BEGIN NOPE~FALSE; CHAR~K; CHCT~J END END END;                  03964000
BOOLEAN PROCEDURE BOP;                                                  03967000
BEGIN  OWN INTEGER K;                                                   03970000
  IF CHAR="." THEN BEGIN  K~CHCT; SCAN;                                 03973000
    IF BOP~((NOM="AND###" OR NOM="OR####") AND CHAR=".") THEN BEGIN     03976000
      STACK(" "); NDUMP; STACK(" ") END                                 03979000
    ELSE BEGIN CHCT~K; CHAR~"." END END                                 03982000
  ELSE BOP~FALSE END;                                                   03985000
BOOLEAN PROCEDURE RELOP;                                                03988000
BEGIN  OWN INTEGER K;                                                   03991000
  IF CHAR="." THEN BEGIN  K~CHCT; SCAN;                                 03994000
    IF RELOP~(CHAR="." AND QUERY(NOM,RELTAB)) THEN STACK(RELSYM[JTAB])  03997000
    ELSE BEGIN CHCT~K; CHAR~"." END END                                 04000000
  ELSE IF RELOP~QUERY(CHAR,RELSYM) THEN STACK(RELSYM[JTAB]) END;        04003000
BOOLEAN PROCEDURE TVALUE(K4); INTEGER K4;                               04006000
BEGIN  OWN INTEGER J,K;                                                 04009000
  IF (TVALUE~(CNEXT="." AND ALFA[RBAND[CHCT+2]])) THEN BEGIN            04012000
    J~CHCT; K~CHAR; GNC; SCAN;                                          04015000
    IF (NOM="TRUE##" OR NOM="FALSE#") AND CHAR="." THEN BEGIN           04018000
      IF K4=1 THEN NDUMP ELSE IF NOM="TRUE##" THEN STACK("1")           04021000
      ELSE STACK("0"); GNC END                                          04022000
    ELSE BEGIN TVALUE~FALSE; CHAR~K; CHCT~J END END END;                04024000
PROCEDURE ARTHREL;                                                      04027000
BEGIN SEGMENT;                                                          04030000
  ARTHX; IF RELOP THEN ARTHX ELSE ERRMSG(022) END;                      04033000
PROCEDURE BCONTIN;  IF BOP THEN BEXP;                                   04036000
PROCEDURE BTERM;                                                        04039000
BEGIN  OWN INTEGER K;                                                   04042000
  IF ALFA[CHAR~CNEXT] THEN BEGIN  K~CHCT; SKAN; TBSCH;                  04045000
    IF TBSW AND MODE=BOO THEN BEGIN USE~1; ITEMQ END                    04048000
    ELSE BEGIN CHCT~K; ARTHREL END END                                  04051000
  ELSE IF CHAR ="(" THEN BEGIN                                          04054000
    NSEXP; IF RESULT!BOO THEN ERRMSG(064);                              04057000
    END                                                                 04060000
  ELSE IF NOPE THEN BTERM                                               04063000
  ELSE IF NOT TVALUE(1) THEN ARTHREL END;                               04066000
PROCEDURE BEXP;  BEGIN BTERM; BCONTIN END;                              04069000
PROCEDURE NSEXP;                                                        04072000
BEGIN  INTEGER K,R;                                                     04075000
  IF ALFA[CHAR~CNEXT] THEN BEGIN  K~CHCT; SKAN; CHCT~K;                 04078000
    IF DXCHECK THEN R~FXP ELSE BEGIN VPROC; R~MODE END;                 04081000
    IF R=BOO THEN BEXP                                                  04084000
    ELSE IF R{FLP THEN BEGIN                                            04087000
      ARTHX; IF RELOP THEN BEGIN ARTHX; BCONTIN; R~BOO END END          04090000
    ELSE ERRMSG(017) END                                                04093000
  ELSE IF CHAR="(" THEN BEGIN                                           04096000
    STACK("("); CHCT~CHCT+1; NSEXP; VERIFY(")"); STACK(")"); GNC;       04099000
    IF (R~RESULT)=BOO THEN BCONTIN                                      04102000
    ELSE IF R{FLP THEN BEGIN                                            04105000
      IF ARITHOP THEN ARTHP;                                            04108000
      IF RELOP THEN BEGIN ARTHX; BCONTIN; R~BOO END END                 04111000
    ELSE ERRMSG(017) END                                                04114000
  ELSE IF TVALUE(1) THEN BEGIN BCONTIN; R~BOO END                       04117000
  ELSE IF NOPE THEN BEGIN BEXP; R~BOO END                               04120000
  ELSE BEGIN ARTHX; R~FLP;                                              04123000
    IF RELOP THEN BEGIN ARTHX; BCONTIN; R~BOO END END;                  04126000
  RESULT~R END;                                                         04129000
PROCEDURE FMPULL;                                                       04132000
BEGIN SEGMENT;                                                          04135000
                                                                        04138000
                                                                        04141000
                                                                        04144000
  LPULL; F~1; STACK("#"); ZAHL(NHOLL) END;                              04147000
PROCEDURE FLPULL;                                                       04150000
BEGIN INTEGER C; LABEL DST;                                             04153000
  IF CNEXT{9 THEN BEGIN  PNX;                                           04156000
    IF NHOLL=0 THEN ERRMSG(24);                                         04157000
    C~DISK[0];      % CHECK IF THIS FILE IS A DISK FILE;                04158000
    WHILE (C~C-1)}0 DO IF NHOLL=DISK[3|C+1].[11:5] THEN                 04159000
      BEGIN PASS("DISK##"); ZAHL(NHOLL); DSKST~TRUE;                    04160000
      IF DISK[3|C+2]!HASH AND RORW THEN BEGIN STACK("[");               04161000
        NOM~DISK[3|C+2]; VPROC; IF PFXSW THEN STACK("J");               04161500
        PASS(DISK[3|C+2]); IF RS THEN STACKQ; STACK("]") END;           04162000
        GO TO DST END;                                                  04162500
    IF NHOLL>TAPES[0] THEN ERRMSG(24);                                  04163000
    PASS("TAPE##"); ZAHL(NHOLL);                                        04164000
    DST:END                                                             04165000
  ELSE BEGIN                                                            04166000
    PASS("FILESW"); STACK("["); SKAN; NPROC; USE~1;                     04168000
    IF LCLASS{NSV THEN BEGIN CPUT(NSV); STACK("J"); PASS(NOM) END       04168500
    ELSE ERRMSG(09); STACK("]") END                                     04169000
END;                                                                    04170000
BOOLEAN PROCEDURE DXQ;                                                  04171000
BEGIN SEGMENT;                                                          04174000
  IF (DXQ~QUERY(NOM,INDEX)) THEN BEGIN                                  04177000
    STACK("D"); STACK("X"); ZAHL(JTAB) END END;                         04180000
PROCEDURE NSSV;                                                         04183000
BEGIN  INTEGER J,K,KPNT,N;                                              04186000
BOOLEAN CC,EC;                                                          04187000
  CC~FALSE; EC~FALSE;                                                   04188000
  N~NOM; SVDCMP; IXCT~MAX(K~J~CCT,IXCT);                                04189000
  IF CB THEN CC~TRUE; IF EB THEN EC~TRUE;                               04190000
  DO BEGIN                                                              04192000
    PASS("FOR ##"); PASS("INDEX#"); ZAHL(J); STACK("~");                04195000
    STACK("1");                                                         04196000
    PASS(" STEP "); PASS("1 ####"); PASS("UNTIL ");                     04197000
    IF D[J]>0 THEN ZAHL(D[J]) ELSE BEGIN  KPNT~PNT;                     04198000
      NOM~(IF J=1 THEN D1PART ELSE IF J=2 THEN D2PART ELSE D3PART).CX6; 04201000
      LOOKUP(NOM); USE~1; STACK("J"); PASS(NOM); PNT~KPNT END;          04204000
    PASS(" DO ##") END                                                  04207000
  UNTIL (J~(J-1)){0;                                                    04210000
  STACK("%"); PASS(N); STACK("["); J~K;                                 04213000
    DO BEGIN PASS("*INDEX"); IF ISSW AND NOT (CC OR EC) THEN            04216000
      ZAHL(CCT-J+1) ELSE ZAHL(J);                                       04216500
      STACK(IF J=1 THEN "]" ELSE ",") END                               04217000
  UNTIL (J~(J-1)){0 END;                                                04219000
PROCEDURE DP1(K1);  INTEGER K1;                                         04220000
BEGIN SEGMENT;                                                          04220100
  PASS("DATA[#");                                                       04220200
  IF K1}-1 THEN BEGIN                                                   04220300
    ZAHL((K1~(K1+1)) DIV 512); STACK(","); ZAHL(K1.[39:9]) END          04220400
  ELSE BEGIN PASS("(K~(K+"); PASS("1)).[3"); PASS("3:6],K");            04220500
    PASS(".[39:9"); STACK("]") END;                                     04220600
  STACK("]") END;                                                       04220700
PROCEDURE DPULL(M,K1);  VALUE M;  INTEGER M,K1;                         04221000
BEGIN SEGMENT;                                                          04221100
  STACK("~");                                                           04221200
  IF M=BOO THEN BEGIN                                                   04221300
    PASS("BOOLEA"); STACK("N"); STACK("("); DP1(K1); STACK(")") END     04221400
  ELSE DP1(K1);                                                         04221500
  STACK(";") END;                                                       04221600
PROCEDURE SETK(K1);  INTEGER K1;                                        04221700
BEGIN SEGMENT;                                                          04221800
  PASS("K~####"); IF K1=-1 THEN BEGIN STACK("-"); K1~-K1 END;           04221900
  ZAHL(K1); STACK(";"); K1~-2 END ;                                     04221950
PROCEDURE SIMPEL;                                                       04222000
BEGIN  INTEGER C,L;                                                     04225000
  IF DXQ THEN NOTHING                                                   04228000
  ELSE BEGIN                                                            04231000
    VPROC; IF MODE=UNDEF THEN MPUT(DFALT(NOM));                         04234000
    USE~1; IF NOT OUTSW THEN ALTER~1;                                   04237000
    IF (L~LCLASS){NSV THEN ITEMQ                                        04240000
    ELSE IF L=SV AND CHAR="(" THEN ITEMQ                                04243000
    ELSE IF L=SV THEN NSSV                                              04246000
    ELSE ERRMSG(025) END END;                                           04249000
PROCEDURE VSIMP(K1);  INTEGER K1;                                       04250000
BEGIN  INTEGER C,L,M;                                                   04250100
  IF DXQ THEN DPULL(FXP,K1)                                             04250200
  ELSE BEGIN                                                            04250300
  VPROC; IF (M~MODE)=UNDEF THEN MPUT(M~DFALT(NOM));                     04250400
    USE~1; IF NOT OUTSW THEN ALTER~1;                                   04250500
    IF (L~LCLASS){NSV THEN BEGIN CPUT(NSV); STACK("J"); NDUMP END       04250600
    ELSE IF L=SV AND CHAR="(" THEN SVPR                                 04250700
    ELSE IF L=SV THEN BEGIN IF K1!-2 THEN SETK(K1); NSSV END            04250800
    ELSE ERRMSG(046);                                                   04250900
    DPULL(M,K1) END END;                                                04251000
PROCEDURE LCINIT(CT,CX,LG1,RG);  INTEGER CT,CX,LG1,RG;                  04252000
BEGIN  INTEGER LG2,LGX;                                                 04255000
  GNC; CT~CHCT; ARGCT; LGX~CX~RG2; RG~RG1;                              04258000
  IF RG4{0 THEN ERRMSG(026); IF RBAND[RG2]!")" THEN ERRMSG(027);        04261000
  CHCT~RG4; WHILE ALFAN(RBAND[CHCT~(CHCT-1)]) DO;                       04264000
  IF RBAND[LG1~CHCT]!"," THEN ERRMSG(028); SKAN;                        04267000
  IF QUERY(NOM,INDEX) THEN ERRMSG(029); IF JTAB>DXMAX THEN ERRMSG(030); 04270000
  DXCT~MAX(DXCT,JTAB);                                                  04273000
  INDEX[INDEX[0]~JTAB]~NOM; PASS("FOR DX"); ZAHL(JTAB);                 04276000
  STACK("~"); ARTHI; LG2~CHCT; VERIFY(","); PASS(" STEP ");             04279000
  SVL~SVL+1; ARGBCT(TRUE); IF RG2!CX THEN ERRMSG(031); RG~RG-RG1;       04282000
  IF RG1=1 THEN ZAHL(1) ELSE IF RG1=2 THEN BEGIN                        04285000
    LGX~CHCT~SVCH[SVL,1]; ARTHI; IF CHCT!CX THEN ERRMSG(031) END        04288000
  ELSE ERRMSG(031); SVL~SVL-1;                                          04291000
  PASS(" UNTIL"); STACK(" "); CHCT~LG2; ARTHI; PASS(" DO ##");          04294000
  IF CHCT!LGX THEN ERRMSG(031) END;                                     04295000
PROCEDURE LCURSE;                                                       04296000
BEGIN  BOOLEAN B;  INTEGER CT,CX,LG1,LG2,LGX,RG;                        04297000
  LCINIT(CT,CX,LG1,RG);                                                 04298000
  IF B~(RG>2) OR (RBAND[LG1-1]=")" AND RBAND[CT+1]="(")                 04300000
  THEN STACK("["); RBAND[LG1]~"$"; CHCT~CT;                             04301000
  DO BEGIN                                                              04303000
    LISTEL; IF CHAR="," THEN STACK(CHAR) END UNTIL CHAR!",";            04306000
  IF CHCT!LG1 THEN ERRMSG(031); IF B THEN STACK("]"); RBAND[LG1]~",";   04309000
  CHCT~CX; INDEX[0]~INDEX[0]-1; GNC END;                                04312000
PROCEDURE VCURSE(K1);  INTEGER K1;                                      04313000
BEGIN  BOOLEAN B;  INTEGER CT,CX,LG1,LG2,LGX,RG;                        04313100
  IF K1}-1 THEN SETK(K1);                                               04313200
  LCINIT(CT,CX,LG1,RG);                                                 04313400
  IF B~(RG>2) THEN PASS("BEGIN "); RBAND[LG1]~"$"; CHCT~CT;             04313500
  DO DLISTEL(K1) UNTIL CHAR!",";                                        04313600
  IF CHCT!LG1 THEN ERRMSG(031); IF B THEN PASS(" END;#");               04313700
  RBAND[LG1]~","; CHCT~CX; INDEX[0]~INDEX[0]-1; GNC END;                04313800
PROCEDURE CKCRS;                                                        04314000
BEGIN SEGMENT; INTEGER CT,J,N; LABEL L1;                                04314100
  GNC; CT~CHCT; ARGCT; IF CEQ>0 THEN BEGIN IF RG4>0 THEN                04314200
  BEGIN CHCT~CT-1; GO TO L1 END; CHCT~CT-1;                             04314210
  J~-1; DO BEGIN GNC; J~J+1; END UNTIL CHAR!"("; N~0;                   04314230
  CHCT~CT-1; IF J>CEQ THEN DO BEGIN GNC; J~J-1; N~N+1 END UNTIL J=CEQ;  04314250
L1:                                                                     04314260
  LCURSE; IF N!0 THEN DO IF CHAR=")" THEN GNC UNTIL (N~(N-1){0) END     04314270
  ELSE BEGIN CHCT~CT; J~0; DO BEGIN GNC; J~J+1 END UNTIL                04314300
  CHAR!"("; CHCT~CHCT-1; IF ALFA[CHAR~CNEXT] THEN BEGIN DO BEGIN        04314400
  LISTEL; IF CHAR="," THEN STACK(CHAR) END UNTIL CHAR!","; DO IF        04314450
  CHAR=")" THEN GNC UNTIL (J~(J-1)<1) END ELSE                          04314500
  ERRMSG(032) END END;                                                  04314600
PROCEDURE LISTEL;                                                       04315000
BEGIN SEGMENT;                                                          04318000
  IF ALFA[CHAR~CNEXT] THEN BEGIN SKAN; SIMPEL END                       04321000
  ELSE IF CHAR="(" THEN CKCRS                                           04324000
  ELSE ERRMSG(032) END;                                                 04327000
PROCEDURE LISTP;                                                        04330000
BEGIN SEGMENT;  INDEX[0]~0;                                             04333000
  DO BEGIN LISTEL; IF CHAR!" " THEN STACK(CHAR) END UNTIL CHAR!"," END; 04336000
PROCEDURE LARDAT(K2);  INTEGER K2;                                      04337000
BEGIN SEGMENT;                                                          04337100
  PASS(";FILL "); PASS("DATA[#"); ZAHL(K2 DIV 512);                     04337200
  PASS(",*] WI") ; PASS("TH ###") END;                                  04337300
PROCEDURE GT(L); VALUE L; INTEGER L; BEGIN PASS("GO TO "); PASS(L) END; 04339000
PROCEDURE LISTPZ;                                                       04342000
BEGIN  LABEL L1,XIT;  INTEGER FLGZX,J,JL,JLH,JLMAX,JLN,JQ;  REAL T1,T2; 04345000
  PASS("LIST##"); ADJZ; JLH~((FLGZX~FLGZ) DIV 7); LISTSW~TRUE; LISTP;   04348000
  VERIFY(" "); STACK(")"); STACK(";");                                  04351000
  LISTSW~FALSE; JLN~FLGZ-FLGZX; ADJZ; JLMAX~(FLGZ DIV 7);               04354000
  BWX~TRUE; J~0;                                                        04357000
  WHILE (J~(J+1)){LISTCT DO BEGIN                                       04360000
    IF LSTX[J].AX2=JLN THEN BEGIN                                       04363000
      JQ~(LSTX[J].AX3 DIV 7); JL~JLH;                                   04366000
      WHILE (JL~(JL+1)){JLMAX DO BEGIN                                  04369000
        IF (T1~WB[(JQ~(JQ+1)).[35:6],JQ.[41:7]])                        04369500
        !(T2~WB[JL.[35:6],JL.[41:7]]) THEN GO TO L1;                    04370000
        IF T1.[6:6]!T2.[6:6] OR T1.CX6!T2.CX6 THEN GO TO L1 END;        04372000
      FLGZ~FLGZX; ZAHL(J); GO TO XIT END; L1: END;                      04375000
  ZAHL(LISTCT~(LISTCT+1)); LSTX[LISTCT]~FLGZX&JLN[18:33:15]; XIT: END;  04378000
PROCEDURE HVALUE(K2);  INTEGER K2;                                      04378100
BEGIN INTEGER K3;                                                       04378200
  GNC;                                                                  04378250
  DO BEGIN STACK("""); K3~0;                                            04378300
    DO BEGIN      STACK(CHAR); K3~K3+1; GNC;                            04378400
    END UNTIL CHAR=""" OR K3=6;                                         04378500
  IF CHAR!""" THEN BEGIN STACK("""); K2~K2+1;                           04378600
  IF K2 MOD 512 = 0 AND K2!0 THEN LARDAT(K2) ELSE STACK(",") END        04378700
  ELSE STACK(""")                                                       04378750
  END UNTIL CHAR="""; GNC END;                                          04378800
PROCEDURE DLISTEL(K1);  INTEGER K1;                                     04379000
BEGIN SEGMENT;                                                          04379100
  IF ALFA[CHAR~CNEXT] THEN BEGIN SKAN; VSIMP(K1) END                    04379110
  ELSE IF CHAR="(" THEN VCURSE(K1)                                      04379120
  ELSE ERRMSG(062) END;                                                 04379130
PROCEDURE DCPULL(K2); INTEGER K2;                                       04380000
BEGIN  DEFINE CNEXT=RBAND[CHCT+1]#;                                     04380100
  GNC;                                                                  04380120
  IF CHAR="." AND ALFA[CNEXT] THEN BEGIN CHCT~CHCT-1;                   04380140
    IF TVALUE(0) THEN NOTHING ELSE ERRMSG(067) END                      04380160
  ELSE IF CHAR="T" AND NOT ALFA[CNEXT] THEN BEGIN                       04380180
    STACK("1"); GNC END                                                 04380200
  ELSE IF CHAR="F" AND NOT ALFA[CNEXT] THEN BEGIN                       04380220
    STACK("0"); GNC END                                                 04380240
  ELSE IF CHAR="+" THEN PRIMARY                                         04380250
  ELSE IF CHAR="-" THEN BEGIN STACK("-"); PRIMARY END                   04380255
  ELSE IF CHAR=""" THEN HVALUE(K2)                                      04380257
  ELSE BEGIN IF CHAR="O" THEN BEGIN PASS("OCT###"); GNC;                04380260
    IF CHAR{9 THEN DO BEGIN STACK(CHAR); GNC END UNTIL CHAR>9 END       04380263
    ELSE BEGIN CHCT~CHCT-1; PRIMARY END END END;                        04380265
PROCEDURE DATAC(K2);  INTEGER K2;                                       04380600
BEGIN INTEGER CT,CK,KQ,NH;                                              04380610
  CT~CHCT; PNX;                                                         04380620
  IF CHAR="*" THEN BEGIN                                                04380630
    IF (NH~NHOLL){0 THEN ERRMSG(063);                                   04380640
    KQ~1; CK~CHCT;                                                      04380650
  DO BEGIN IF K2 MOD 512 =0 AND K2!0 THEN LARDAT(K2);                   04380660
      DCPULL(K2); IF K2 MOD 512!511       THEN STACK(",");              04380665
      K2~K2+1; CHCT~CK;                                                 04380670
      END UNTIL (KQ~(KQ+1))}NH END                                      04380675
    ELSE CHCT~CT;                                                       04380680
  IF K2 MOD 512 = 0 AND K2!0 THEN LARDAT(K2);                           04380685
  DCPULL(K2);                                                           04380690
  IF CHAR!"/" THEN STACK(",") ELSE STACK(";");                          04380700
  K2~K2+1 END;                                                          04380710
PROCEDURE DATAPR;                                                       04380800
BEGIN  INTEGER ADR1,ADR2,FLZ1,FLZ2,K1,K2;                               04380810
  INDEX[0]~0; LISTSW~TRUE;                                              04380815
  ADJZ; ADR1~FLGZ; K1~-1; DO DLISTEL(K1) UNTIL CHAR!","; VERIFY("/");   04380820
  FLZ1~FLGZ; LISTSW~FALSE;                                              04380830
  ADJZ; ADR2~FLGZ; K2~0; PASS("FILL D"); PASS("ATA[0,");                04380840
  PASS("*] WIT"); PASS("H ####"); DO DATAC(K2) UNTIL CHAR!",";          04380843
  VERIFY("/"); GNC;                                                     04380846
  FLZ2~FLGZ; ADJZ;                                                      04380850
  IF K1>K2 THEN ERRMSG(061);                                            04380860
  NOM~".DATAV"; TBSCH;                                                  04380870
  IF TBSW THEN INEXT~BOXI+1 ELSE BOXDV~BOXI+1;                          04380880
  NFIX(2); CPUT(DV); ZPUT(ADR1); BASE~FLZ1;                             04380890
  NOM~".DATAC"; TBSCH;                                                  04380900
  IF TBSW THEN INEXT~BOXI+1 ELSE BOXDC~BOXI+1;                          04380910
  NFIX(2); CPUT(DC); ZPUT(ADR2); BASE~FLZ2 END;                         04380920
PROCEDURE TPROC;                                                        04381000
BEGIN SEGMENT;                                                          04384000
BOOLEAN FMSW;                                                           04385000
  RORW~TRUE;       % SET IND. SO THAT ASSOC. VAR. WILL BE USED FOR DISK;04386000
  IF NOT IGCK THEN PASS("B$####");                                      04386500
  IF CHCT>8 THEN FMSW~TRUE ELSE FMSW~FALSE;                             04386700
  STACK(IF OUTSW THEN "W" ELSE "R"); STACK("$"); FLPULL; STACK(",");    04387000
  IF T4SW AND CHAR="," THEN FMPULL ELSE                                 04390000
  IF T2SW AND CHAR="," AND FMSW THEN FMPULL                             04391000
  ELSE IF OKTLSW THEN PASS("OKTL##") ELSE STACK("*");                   04393000
  IF T4SW THEN VERIFY(")"); IF T2SW AND CHAR!" " OR    T4SW AND         04396000
  CNEXT!" " THEN BEGIN STACK(","); LISTPZ; VERIFY(" ") END;             04399000
  STACK(")") END;                                                       04402000
PROCEDURE GTO(L);    VALUE L;    INTEGER L;                             04405000
BEGIN SEGMENT;  LPROC(L); GOAL~1;                                       04408000
  PASS("GO TO "); STACK("&"); ZAHL(L) END;                              04411000
PROCEDURE THGTO(L);    VALUE L;    INTEGER L;                           04414000
BEGIN PASS(" THEN "); GTO(L) END;                                       04417000
PROCEDURE ZGTO(R,L);    VALUE R,L;    INTEGER R,L;                      04420000
BEGIN SEGMENT; STACK(R); STACK(0); THGTO(L) END;                        04423000
PROCEDURE JCHECK(L);    VALUE L;    INTEGER L;                          04426000
BEGIN SEGMENT;                                                          04429000
  IF STANO!XBWRD THEN BEGIN LPROC(STANO); IF IGCK THEN BEGIN JUMP~1;    04432000
    CIBLE~L END END END;                                                04432500
PROCEDURE DMN;                                                          04435000
BEGIN  INTEGER KPNT,L,LC,M;                                             04438000
  VPROC; IF (LC~LCLASS)=UNDEF THEN CPUT(LC~SV);                         04441000
  IF T2SW AND FNTEST THEN ERRMSG(095);                                  04442000
  IF LC!SV THEN ERRMSG(075); IF DB THEN ERRMSG(034); DBIT~1;            04444000
  D[1]~D[2]~D[3]~CCT~0; L~1;                                            04447000
  DO BEGIN                                                              04450000
    IF (CCT~(CCT+1))>3 THEN ERRMSG(35);                                 04453000
    IF PB AND ALFA[CNEXT] THEN BEGIN  KPNT~PNT; SKAN; VPROC;            04456000
      IF NOT PB THEN ERRMSG(036);                                       04459000
      IF (M~MODE)=UNDEF THEN MPUT(M~DFALT(NOM));                        04462000
      IF M!FXP THEN ERRMSG(037);                                        04465000
      IF (LC~LCLASS)=UNDEF THEN CPUT(NSV)                               04468000
      ELSE IF LC!NSV THEN ERRMSG(037); PNT~KPNT; D[CCT]~NOM END         04471000
    ELSE BEGIN PNSCAN; IF NHOLL>32768 THEN ERRMSG(10);                  04474000
      L~(D[CCT]~NHOLL)|L END END UNTIL CHAR!",";                        04475000
  VERIFY(")"); LENGTH~L;                                                04477000
  IF ALFA[D[1].CX1] THEN D1PART~D[1] ELSE D1~D[1];                      04480000
  IF ALFA[D[2].CX1] THEN D2PART~D[2] ELSE D2~D[2];                      04483000
  IF ALFA[D[3].CX1] THEN D3PART~D[3] ELSE D3~D[3];                      04486000
  DCT~CCT; GNC END;                                                     04489000
PROCEDURE DIMEN;                                                        04492000
BEGIN  BWX~FALSE; CHCT~8;                                               04495000
  DO BEGIN SKAN; VERIFY("("); DMN END UNTIL CHAR!",";                   04498000
  VERIFY(" ") END;                                                      04501000
PROCEDURE RETOUR;                                                       04504000
BEGIN SEGMENT;  DFSW~FALSE; GTO(XLABEL) END;                            04507000
PROCEDURE STEND;                                                        04510000
BEGIN  OWN INTEGER J;                                                   04513000
  IF STANO!XBWRD THEN IF QUERY(STANO,DOTAB) THEN BEGIN                  04516000
    IF DOTAB[DOTAB[0]]!STANO THEN BEGIN DOTAB[0]~JTAB-1; ERRMSG(38) END;04519000
    WHILE (J~DOTAB[0])>0 AND DOTAB[J]=STANO DO BEGIN                    04522000
    BWX~TRUE; PASS(" END U"); PASS("NTIL ("); SCREEN(DOJ[J]);           04525000
    STACK("~"); STACK("("); SCREEN(DOJ[J]); IF BOOLEAN(SSN[J]) THEN     04528000
      STACK("-") ELSE STACK("+");                                       04528500
    PASSJ(DOM3[J]); IF BOOLEAN(SSN[J]) THEN BEGIN                       04529000
      PASS("))<###"); SSN[J]~0 END ELSE                                 04529500
    PASS("))>###"); PASSJ(DOM2[J]); DOTAB[0]~J-1 END END;               04531000
  IF BWX THEN STACK(";") END;                                           04534000
PROCEDURE MONTOR(C,T);    VALUE C,T;    INTEGER C,T;                    04537000
BEGIN  INTEGER ADR,CT;                                                  04540000
  ADJZ; ADR~FLGZ; CHCT~C;                                               04543000
  DO BEGIN  CT~CHCT; SCAN;                                              04546000
    IF NOM="PRINT#" OR NOM="PUNCH#" THEN NDUMP                          04549000
    ELSE BEGIN CHCT~CT; FLPULL END; VERIFY("("); STACK("(");            04552000
    DO BEGIN                                                            04555000
      IF CNEXT{9 THEN BEGIN LPULL; GOAL~1; STACK("&"); ZAHL(NHOLL) END  04558000
      ELSE BEGIN SKAN;                                                  04561000
        IF CHAR!"(" THEN NDUMP                                          04564000
        ELSE BEGIN SVQ; IF SVSW THEN SVPR ELSE ERRMSG(033) END END;     04567000
      STACK(CHAR) END UNTIL CHAR!","; VERIFY(")");                      04570000
    IF T="M" THEN GNC ELSE BEGIN                                        04573000
      LPULL; GOAL~1; VERIFY(":"); ZAHL(NHOLL); STACK(":");              04576000
      IF CNEXT{9 THEN BEGIN PNX; ZAHL(NHOLL) END                        04579000
      ELSE BEGIN SKAN; NPROC; USE~1; IF LCLASS{NSV THEN BEGIN           04582000
        CPUT(NSV); IF PFXSW THEN STACK("J"); PASS(NOM);                 04582500
        IF RS THEN STACKQ END ELSE ERRMSG(09) END END;                  04583000
    IF CHAR="," THEN STACK(",") END UNTIL CHAR!",";                     04585000
  IF CHAR!" " THEN BEGIN VERIFY(";"); GNC; VERIFY(" ") END; STACK(";"); 04588000
  ADJZ; NOM~".....*"; TBSCH;                                            04591000
  IF TBSW THEN INEXT~BOXI+1 ELSE BOXMD~BOXI+1;                          04594000
  NFIX(2); CPUT(MD); MDFLAG~T; ZPUT(ADR) END;                           04597000
PROCEDURE FWCK;                                                         04598000
  BEGIN INTEGER SHOLL,WHOLL;                                            04598200
  SHOLL~NHOLL; PNX; IF (NHOLL | SHOLL)>132 THEN ERRMSG(023)             04598400
  ELSE IF NHOLL>63 THEN BEGIN WHOLL~NHOLL-63; NHOLL~63; STACK("X");     04598600
    ZAHL(WHOLL); STACK(",") END; IF SHOLL!0 THEN ZAHL(SHOLL) END;       04598800
PROCEDURE FMTSPEC;                                                      04600000
BEGIN LABEL F,F0,F1,F2,F3,F4,F5,F6,XIT; INTEGER HX,I,J,K,L,CT;          04603000
BOOLEAN PS;                                                             04604000
  L~0;                                                                  04606000
F: LINESW~TRUE;                                                         04609000
  WHILE RBAND[CHCT~(CHCT+1)]="/" DO STACK("/"); CHCT~CHCT-1;            04612000
F0: WHILE RBAND[CHCT+1]="," DO CHCT~CHCT+1;                             04615000
F1: PNX; PS~FALSE;                                                      04618000
  IF NHOLL{0 AND CHAR=""" THEN BEGIN                                    04621000
    HX~0;                                                               04624000
    WHILE (CHAR~RBAND[CHCT~(CHCT+1)])!""" DO WHOLD[HX~(HX+1)]~CHAR;     04627000
F2: IF LINESW THEN BEGIN                                                04630000
      IF (CHAR~WHOLD[1] ) { 9 OR CHAR=" " THEN BEGIN                    04633000
        IF CTRLSW THEN CCHAR~CHAR END;                                  04636000
      WHOLD[1]~" ";                                                     04639000
      IF CHAR=0 THEN STACK("/") END;                                    04642000
    J~0; DO BEGIN                                                       04645000
      STACK(""");                                                       04648000
      I~MIN(HX,J+63); WHILE (J~(J+1)){I DO STACK(WHOLD[J]); STACK("""); 04651000
      IF I<HX THEN STACK(",") END UNTIL (J~I)}HX;                       04654000
      GO TO F4 END;                                                     04657000
  IF CHAR="L" THEN BEGIN DUMPH; STACK("L"); PNX; ZAHL(MAX(1,NHOLL));    04658000
    GO TO F3 END;                                                       04659000
  IF CHAR="O" THEN BEGIN                                                04660000
    FWCK; STACK("O"); GO TO F3 END;                                     04663000
  IF CHAR="A" OR CHAR="I" THEN BEGIN                                    04666000
    K~CHAR; FWCK; STACK(K); ZAHL(NHOLL);                                04669000
F3: CHCT~CHCT-1;                                                        04672000
F4: CTRLSW~LINESW~FALSE;                                                04675000
F5: DO GNC UNTIL CHAR!",";                                              04678000
    IF ALFAN(CHAR) OR CHAR="(" OR CHAR=""" THEN STACK(",");             04681000
    CHCT~CHCT-1; GO TO F1 END;                                          04684000
  IF CHAR="E" THEN BEGIN                                                04687000
    FWCK; STACK("R"); ZAHL(NHOLL); STACK("."); PNX; ZAHL(NHOLL);        04690000
                                                                        04693000
    GO TO F3 END;                                                       04696000
  IF CHAR="F" THEN BEGIN                                                04699000
    FWCK; STACK("R"); I~NHOLL-1; ZAHL(NHOLL);                           04702000
    STACK("."); PNX; ZAHL(MIN(NHOLL,I)); GO TO F3 END;                  04705000
F6: IF CHAR="P" THEN BEGIN PSCALE~MAX(0,NHOLL); CT~CHCT; PNX; CHCT~CT;  04708000
  IF CHAR="E" THEN GO TO F1;      STACK("S"); IF PS THEN                04708200
      STACK("-");                                                       04708500
    ZAHL(PSCALE); STACK(","); GO TO F1 END;                             04709000
  IF CHAR="H" THEN BEGIN                                                04711000
    HX~0;                                                               04714000
    DO BEGIN GNC; WHOLD[HX~(HX+1)]~CHAR END UNTIL (NHOLL~(NHOLL-1)){0;  04717000
    GO TO F2 END;                                                       04720000
  IF CHAR="X" THEN BEGIN                                                04723000
    STACK("X"); I~MAX(NHOLL,1); J~CHCT; PNX;                            04726000
    IF ALFA[CHAR] OR CHAR="(" THEN BEGIN ZAHL(I); CHCT~J; GO TO F4 END; 04729000
    ZAHL(MAX(I|NHOLL,I)); GO TO F3 END;                                 04732000
  IF CHAR="(" THEN BEGIN DUMPH; STACK("("); L~L+1; GO TO F0 END;        04735000
  IF NHOLL{0 THEN BEGIN                                                 04738000
    IF CHAR="," THEN GO TO F5;                                          04741000
    IF CHAR="/" THEN BEGIN STACK("/"); GO TO F END;                     04744000
    IF CHAR=")" THEN BEGIN                                              04747000
      STACK(")");                                                       04750000
      IF (L~(L-1))<0 THEN BEGIN STACK(";"); GO TO XIT END;              04753000
      GO TO F5 END;                                                     04756000
    IF CHAR="-" THEN BEGIN PNX; IF CHAR="P" THEN BEGIN                  04759000
  PS~TRUE; GO TO F6 END                                                 04762000
  END END;                                                              04765000
  ERRMSG(4);                                                            04768000
XIT: ADJZ END;                                                          04771000
PROCEDURE FMT;                                                          04774000
BEGIN  INTEGER KPNT;                                                    04777000
  ADJZ; IF STANO=XBWRD THEN ERRMSG(039); LOOKUP(STANO); F~1; KPNT~PNT;  04780000
  ZPUT(FLGZ); CHCT~6;                                                   04783000
  IF CTOTAL=CHCT+4 THEN IF RBAND[CHCT+1]=""" THEN CCTRL~1;              04786000
  CTRLSW~TRUE; PSCALE~0;                                                04789000
  FMTSPEC; GNC; VERIFY(" "); PNT~KPNT; OKBIT~1 END;                     04792000
PROCEDURE CGOTO;                                                        04795000
BEGIN  LABEL L1,L2;  INTEGER LONG,TQ,TSW,T1,T2;                         04798000
  CHCT~4; DFSW~FALSE; T1~LXSAVE[JSWGO+1]~JXLS;                          04801000
  DO BEGIN LPULL; GOAL~1; XSTACK[(T1~(T1+1)) DIV 21,T1 MOD 21]~NHOLL END04804000
  UNTIL CHAR!","; VERIFY(")");                                          04807000
  GNC; VERIFY(","); LONG~T1-JXLS; TSW~0;                                04810000
  WHILE (TSW~(TSW+1)){JSWGO DO BEGIN                                    04813000
    IF (LXSAVE[TSW+1]-(TQ~LXSAVE[TSW]))=LONG THEN BEGIN  T2~JXLS;       04816000
      WHILE (T2~(T2+1)){T1 DO IF XSTACK[T2 DIV 21,T2 MOD 21]            04819000
        !XSTACK[(TQ~(TQ+1)) DIV 21,TQ MOD 21] THEN GO TO L1;            04822000
      GO TO L2 END;                                                     04825000
    L1: END;                                                            04828000
  TSW~JSWGO~(JSWGO+1);                                                  04831000
  JXLS~T1;                                                              04834000
L2: GT("SWGO##"); ZAHL(TSW); STACK("["); ARTHI; STACK("]");             04837000
  VERIFY(" ") END;                                                      04840000
PROCEDURE DFCN;                                                         04843000
BEGIN  INTEGER J,K,KPNT,M;                                              04846000
  IF T2SW AND FNTEST THEN FTRIM;                                        04847000
  VPROC; IF LCLASS!UNDEF THEN ERRMSG(040); KPNT~PNT;                    04849000
  IF MODE=UNDEF THEN MPUT(DFALT(NOM));                                  04852000
  CPUT(FN); FTYPE~DF; ALTO~BASSO~BOXI; ARGL~K~XF; DFCNSW~TRUE;          04855000
  STACK("D"); STACK("$"); NDUMP; STACK("("); J~0;                       04858000
  DO BEGIN                                                              04861000
    SKAN; TBSCH; J~J+1; NDUMP; STACK(CHAR);                             04864000
    IF TBSW THEN BEGIN                                                  04867000
      IF PNT>K THEN ERRMSG(041);                                        04870000
      IF (M~MODE)=UNDEF THEN M~DFALT(NOM) END                           04873000
    ELSE M~DFALT(NOM);                                                  04876000
    PNT~XF+1; NFIX(1); CPUT(DA); MPUT(M); ALTO~BASSO+J END              04879000
  UNTIL CHAR!","; VERIFY(")"); GNC; VERIFY("=");                        04882000
  PNT~KPNT; ABIT~1; ARGS~J; XPRCALL(MODE); PNT~KPNT;                    04885000
  VERIFY(" "); OKBIT~1; SQUEEZE(ALTO,BASSO); DFCNSW~FALSE;              04887000
  DFCT~DFCT+1 END;                                                      04888000
PROCEDURE IFGO(L,R);    VALUE L,R;    INTEGER L,R;                      04891000
BEGIN SEGMENT;                                                          04894000
  PASS("IF ###"); CHCT~2;                                               04897000
  IF RG3>0 THEN BEGIN                                                   04900000
    RBAND[RG3]~" "; ARTHX; VERIFY(" "); STACK(R); RVSG; VERIFY(")") END 04903000
  ELSE BEGIN ARTHX; VERIFY(")"); STACK(R); STACK(0) END;                04906000
  THGTO(L) END;                                                         04909000
PROCEDURE BIFURC(L1,R1,L2,R2);  VALUE L1,R1,L2,R2;  INTEGER L1,R1,L2,R2;04912000
BEGIN SEGMENT;                                                          04915000
  IF L1=STNXT THEN IFGO(L2,R2)                                          04918000
  ELSE IF L2=STNXT THEN IFGO(L1,R1)                                     04921000
  ELSE BEGIN IFGO(L2,R2); PASS(" ELSE "); GTO(L1) END END;              04924000
PROCEDURE TRFORK(L1,R1,L2,R2);  VALUE L1,R1,L2,R2;  INTEGER L1,R1,L2,R2;04927000
BEGIN SEGMENT;                                                          04930000
  PASS("IF ###"); PASS("(XPR~("); CHCT~2; ARTHX; VERIFY(")");           04933000
  STACK(")"); STACK(")"); ZGTO(R1,L1);                                  04936000
  PASS(" ELSE "); PASS("IF XPR"); ZGTO(R2,L2) END;                      04939000
PROCEDURE ARTHIF;                                                       04942000
BEGIN INTEGER T1,T2,T3;                                                 04945000
  CHCT~RG2; LPULL; T1~NHOLL; VERIFY(",");                               04948000
  LPULL; T2~NHOLL; VERIFY(",");                                         04951000
  LPULL; T3~NHOLL; VERIFY(" "); CHCT~2;                                 04954000
  IF T1=T2 THEN BEGIN                                                   04957000
    IF T1!T3 THEN BIFURC(T3,">",T1,"{")                                 04960000
    ELSE BEGIN PASS("XPR~##"); ARTHX; VERIFY(")"); GTO(T1) END END      04963000
  ELSE IF T1=T3 THEN BIFURC(T3,"!",T2,"=")                              04966000
  ELSE IF T2=T3 THEN BIFURC(T3,"}",T1,"<")                              04969000
  ELSE IF T1=STNXT THEN TRFORK(T3,">",T2,"=")                           04972000
  ELSE IF T2=STNXT THEN TRFORK(T3,">",T1,"<")                           04975000
  ELSE IF T3=STNXT THEN TRFORK(T1,"<",T2,"=")                           04978000
  ELSE BEGIN TRFORK(T3,">",T2,"="); PASS(" ELSE "); GTO(T1) END END;    04981000
PROCEDURE LOGIF;                                                        04984000
BEGIN SEGMENT;                                                          04987000
  CHCT~2; PASS("IF (##"); BEXP; VERIFY(")"); STACK(")"); PASS(" THEN ");04990000
  CUTBACK(CHCT); IGCK~FALSE; STMNT; IGCK~TRUE END;                      04993000
PROCEDURE TWBRIF;                                                       04994000
BEGIN SEGMENT; INTEGER T1,T2; BOOLEAN SLS,NTSW;                         04994050
  SLS~NTSW~FALSE;                                                       04994100
  CHCT~RG2; LPULL; T1~NHOLL; VERIFY(",");                               04994150
  LPULL; T2~NHOLL; VERIFY(" "); CHCT~2; SCAN;                           04994200
  IF T2SW AND NOM="SENSEL" AND NOM1.CX4="IGHT" THEN SLS~TRUE;           04994250
  IF T1=T2 THEN BEGIN                                                   04994300
    IF SLS THEN BEGIN PASS("SENSL["); CHCT~12; ARTHI; VERIFY(")");      04994350
      PASS("]~FALS"); PASS("E; ###") END;IF  T1!STNXT THEN GTO(T1) END  04994400
  ELSE BEGIN PASS("IF ###"); IF T1=STNXT THEN BEGIN PASS("NOT ##");     04994430
    NTSW~TRUE END;                                                      04994440
    IF T4SW THEN BEGIN CHCT~2; STACK("("); BEXP; VERIFY(")");           04994450
      STACK(")") END                                                    04994470
    ELSE IF T2SW THEN BEGIN                                             04994500
      IF LGSW THEN BEGIN CHCT~2; STACK("("); ARTHX; VERIFY(")");        04994530
        STACK(")") END                                                  04994550
      ELSE IF SLS THEN BEGIN PASS("SENSL["); CHCT~12; ARTHI;            04994570
        VERIFY(")"); STACK("]") END                                     04994600
      ELSE BEGIN CHCT~2; SCAN; IF NOM="SENSES" AND NOM1.CX5="WITCH" THEN04994650
        BEGIN PASS("SENSW["); CHCT~13; ARTHI; VERIFY(")"); STACK("]")END04994700
      ELSE ERRMSG(093) END END;                                         04994750
    PASS(" THEN ");  IF SLS THEN BEGIN                                  04994800
      IF NTSW THEN BEGIN GTO(T2);PASS(" ELSE "); PASS("SENSL[");        04994850
        CHCT~12; ARTHI; PASS("]~FALS"); PASS("E;####") END              04994900
      ELSE BEGIN PASS("BEGIN "); PASS("SENSL["); CHCT~12; ARTHI;        04994950
        PASS("]~FALS"); PASS("E;####"); GTO(T1); PASS(" END #");        04995000
        IF T2!STNXT THEN BEGIN PASS(" ELSE "); GTO(T2) END END END      04995050
    ELSE BEGIN                                                          04995100
      IF NTSW THEN GTO(T2)                                              04995150
      ELSE BEGIN GTO(T1); IF T2!STNXT THEN BEGIN PASS(" ELSE ");        04995200
        GTO(T2) END END                                                 04995210
    END END END;                                                        04995250
PROCEDURE IFSTA;                                                        04996000
BEGIN  DFSW~FALSE;                                                      04998000
  ARGCT; CHCT~RG2; PNX; IF CHAR="," THEN BEGIN PNX; IF CHAR="," THEN    04999000
    ARTHIF ELSE TWBRIF END ELSE LOGIF END;                              05000000
PROCEDURE DOST;                                                         05002000
BEGIN INTEGER J,JHQ; DFSW~FALSE;                                        05005000
  IF STANO!XBWRD THEN IF QUERY(STANO,DOTAB) THEN ERRMSG(042);           05008000
  CHCT~1; LPULL; IF PRESENT THEN ERRMSG(043);                           05011000
  IF QUERY(NHOLL,DOTAB) THEN IF NHOLL!DOTAB[DOTAB[0]] THEN ERRMSG(038); 05014000
  DOTAB[J~DOTAB[0]~(DOTAB[0]+1)]~NHOLL; CHCT~CHCT-1;                    05017000
  SKAN; DOJ[J]~NOM; RSWDZ; IF MODE!FXP THEN ERRMSG(044); ALTER~1;       05020000
  VERIFY("="); STACK("~"); ARTHI; VERIFY(","); STACK(";");              05023000
  IF RBAND[CHCT+1]{9 THEN JHQ~1 ELSE JHQ~2; MFIELD; IF JHQ=2 THEN       05025000
  BEGIN TBSCH; IF TBSW THEN USE~1; END;                                 05026000
  DOM2[J]~NOM;                                                          05027000
  DOM3[J]~1; IF CHAR="," THEN BEGIN IF RBAND[CHCT+1]="-" THEN BEGIN     05029000
    SSN[J]~1;    GNC END; MFIELD; DOM3[J]~NOM END;                      05030000
  VERIFY(" "); PASS("DO ###"); PASS("BEGIN "); BWX~FALSE END;           05032000
PROCEDURE ASGN;                                                         05035000
BEGIN  INTEGER K;    DFSW~FALSE;                                        05038000
  CHCT~-1; SKAN; K~NOM; SCAN;                                           05041000
  IF CHAR!" " OR NOM!K THEN BEGIN                                       05044000
    RESCAN; VPROC; USE~1; ALTER~1; IF LCLASS>FN THEN ERRMSG(025);       05047000
    IF (K~MODE)=UNDEF THEN MPUT(K~DFALT(NOM));                          05050000
    IF NOT PFXSW AND LCLASS=FN THEN BEGIN STACK("J"); PASS(NOM) END ELSE05052000
    ITEMQ; VERIFY("="); STACK("~");                                     05053000
    IF T2SW AND LGSW THEN BEGIN PASS("REAL(#"); IF K!FLP THEN           05054000
      ERRMSG(092); ARTHX; STACK(")") END ELSE                           05055000
    XPRCALL(K); VERIFY(" ") END END;                                    05056000
PROCEDURE AGOTO;                                                        05059000
BEGIN SEGMENT;    DFSW~FALSE;                                           05062000
  CHCT~3; SKAN; FMTST(NOM,ASNVAR);                                      05065000
  GT("ASSIGN"); PASS("[ASV##"); NDUMP; STACK("]") END;                  05068000
PROCEDURE ASSIGN;                                                       05071000
BEGIN  INTEGER J;                                                       05074000
  CHCT~5; LPULL; GOAL~1; FMTST(NHOLL,ASTACK); J~JTAB;                   05077000
  VERIFY("T"); GNC; VERIFY("O"); SKAN; FMTST(NOM,ASNVAR);               05080000
  PASS("ASV###"); NDUMP; STACK("~"); ZAHL(J) END;                       05083000
PROCEDURE SRCALL;                                                       05086000
BEGIN  INTEGER C,K;    DFSW~FALSE;                                      05089000
  NSRG~0; NPROC; USE~1; K~PNT;                                          05092000
  IF (C~LCLASS)!SR THEN BEGIN                                           05095000
    IF C!UNDEF AND C!PR THEN ERRMSG(019); CPUT(SR) END;                 05098000
  IF PFXSW THEN BEGIN STACK("S"); STACK("R") END; NDUMP;                05101000
    IF RS THEN STACKQ; IF CHAR="(" THEN NSARGL; VERIFY(" ");            05102000
  PNT~K;                                                                05104000
  IF AB THEN BEGIN IF ARGS!NSRG THEN ERRMSG(047) END                    05107000
  ELSE IF NOT PB THEN BEGIN ABIT~1; ARGS~NSRG END END;                  05110000
                                                                        05113000
                                                                        05116000
PROCEDURE SLITET;                                                       05119000
BEGIN INTEGER Q;                                                        05120000
  PASS("IF SEN"); PASS("SL[###"); CHCT~10; ARTHI; VERIFY(","); Q~CHCT;  05122000
  PASS("] THEN"); STACK(" "); SKAN; RSWDZ; ALTER~1; PASS("~1 ELS");     05122100
  PASS("E ####"); CHCT~Q; SKAN; RSWDZ; PASS("~2; SE"); PASS("NSL[##");  05122200
  CHCT~10; ARTHI; PASS("]~FALS"); STACK("E"); SKAN; GNC; VERIFY(" ")    05122300
  END;                                                                  05122400
PROCEDURE SSWTCH;                                                       05122500
BEGIN INTEGER Q;                                                        05125000
  PASS("IF SEN"); PASS("SW[###"); CHCT~10; ARTHI; VERIFY(","); Q~CHCT;  05128000
  PASS("] THEN"); STACK(" "); SKAN; RSWDZ; ALTER~1; PASS("~1 ELS");     05131000
  PASS("E ####"); CHCT~Q; SKAN; RSWDZ; PASS("~2####"); GNC; VERIFY(" ") 05132000
  END;                                                                  05133000
                                                                        05134000
PROCEDURE SLITE;                                                        05137000
BEGIN SEGMENT;                                                          05140000
  CHCT~9; PASS("SLITE("); ARTHI; STACK(")"); VERIFY(")");               05143000
  GNC; VERIFY(" ") END;                                                 05146000
PROCEDURE SLITETW;                                                      05146500
BEGIN SEGMENT;                                                          05147000
  CHCT~9; PASS("SLITE("); ARTHI; STACK(")"); VERIFY(" ") END;           05148000
                                                                        05149000
PROCEDURE CALL;                                                         05152000
BEGIN SEGMENT;                                                          05155000
  DFSW~FALSE; CHCT~3; SKAN;                                             05158000
  IF FWCT<6 THEN BEGIN                                                  05161000
    IF NOM="SLITE#" THEN SLITE                                          05164000
    ELSE IF NOM="DVCHK#" THEN NOTHING                                   05167000
    ELSE IF NOM="EXIT##" THEN GT("FINIS#")                              05170000
    ELSE IF NOM="DUMP##" THEN NOTHING                                   05173000
    ELSE IF NOM="PDUMP#" THEN NOTHING                                   05176000
    ELSE SRCALL END                                                     05179000
  ELSE IF FWCT!6 THEN ERRMSG(049)                                       05182000
  ELSE IF NOM="SLITET" THEN SLITET                                      05185000
  ELSE IF NOM="SSWTCH" THEN SSWTCH                                      05188000
  ELSE IF NOM="OVERFL" THEN NOTHING                                     05191000
  ELSE SRCALL END;                                                      05194000
PROCEDURE CLIST;                                                        05197000
BEGIN  INTEGER JL,JR;                                                   05200000
  DO BEGIN  SKAN; VPROC;                                                05203000
    IF LCLASS>SV THEN ERRMSG(046); IF CB THEN ERRMSG(050);              05206000
    CBIT~1; CNAME~CNOM; BOXC~BOXC+1; JL~BOXC DIV 64; JR~BOXC MOD 64;    05209000
    CSTACK[JL,JR]~NOM; BSTACK[JL,JR]~CNOM;                              05212000
    IF CHAR="(" THEN DMN END UNTIL CHAR!"," END;                        05215000
PROCEDURE COMMON;                                                       05218000
BEGIN SEGMENT;  BWX~FALSE;                                              05221000
IF XCSW THEN NOTHING ELSE BEGIN                                         05224000
  CHCT~5; CNOM~XBWRD;                                                   05227000
  IF CNEXT!"/" THEN CLIST ELSE GNC;                                     05230000
  WHILE CHAR="/" DO BEGIN                                               05233000
    IF CNEXT="/" THEN BEGIN GNC; CNOM~XBWRD END                         05236000
    ELSE BEGIN SKAN; CNOM~NOM; VERIFY("/") END;                         05239000
    CLIST END;                                                          05242000
  VERIFY(" ") END END;                                                  05245000
PROCEDURE RETURN;                                                       05248000
  BEGIN INTEGER XTANO; DFSW~FALSE;                                      05251000
  XTANO~STANO;                                                          05253000
  JCHECK(XLABEL);                                                       05254000
  IF MODUS!" " THEN RETOUR                                              05257000
  ELSE IF QUERY(STANO,DOTAB) THEN RETOUR                                05260000
  ELSE BEGIN                                                            05263000
    OPEN; RESCAN; IF NOM!"END###" THEN BEGIN RETOUR; STACK(";") END     05266000
    ELSE BEGIN IF XTANO!XBWRD THEN BEGIN LPROC(XLABEL); GOAL~1 END END; 05267000
    GO TO NEXT END END;                                                 05269000
PROCEDURE RGOTO;                                                        05272000
BEGIN INTEGER L;  DFSW~FALSE;                                           05275000
  CHCT~3; LPULL; VERIFY(" ");                                           05278000
  IF(((L~NHOLL)!STNXT AND     IGCK) OR NOT IGCK) THEN                   05281000
  BEGIN GTO(L); JCHECK(L) END ELSE BWX~FALSE END;                       05284000
PROCEDURE ELIST;                                                        05287000
BEGIN  BOOLEAN B;  INTEGER I,K,LC;    BWX~FALSE;                        05290000
  GNC; VERIFY("("); B~FALSE; I~0;                                       05293000
  DO BEGIN SKAN; VPROC; EBIT~1; NDUMP; I~I+1;                           05296000
    IF (LC~LCLASS)>SV THEN ERRMSG(046); IF PB THEN ERRMSG(051);         05299000
    IF CB THEN IF B THEN ERRMSG(052) ELSE B~TRUE;                       05302000
    IF CHAR="(" THEN BEGIN  STACK("("); K~0;                            05305000
      DO BEGIN PNSCAN; K~K+1; ZAHL(NHOLL); STACK(CHAR) END              05308000
      UNTIL CHAR!",";                                                   05311000
      IF LC=SV THEN IF DCT!K THEN ERRMSG(011); IF K>3 THEN ERRMSG(035); 05314000
      VERIFY(")"); GNC END;                                             05317000
    STACK(CHAR) END UNTIL CHAR!","; VERIFY(")");                        05320000
  IF I{1 THEN ERRMSG(053); EQUMAX~EQUMAX+I; GNC END;                    05323000
PROCEDURE EQUIV;                                                        05326000
BEGIN  INTEGER ADR;    BWX~FALSE;                                       05329000
IF XESW THEN NOTHING ELSE BEGIN                                         05332000
  ADJZ; ADR~FLGZ; CHCT~10;                                              05335000
  DO BEGIN ELIST; IF CHAR="," THEN STACK(",") END UNTIL CHAR!",";       05338000
  VERIFY(" "); STACK(";"); ADJZ;                                        05341000
  NOM~".....E"; TBSCH;                                                  05344000
  IF TBSW THEN INEXT~BOXI+1 ELSE BOXE~BOXI+1;                           05347000
  NFIX(2); CPUT(EQ); ZPUT(ADR) END END;                                 05350000
PROCEDURE STOP(C);    VALUE C;    INTEGER C;                            05353000
BEGIN SEGMENT;    DFSW~FALSE;    CHCT~C;                                05356000
  PASS("ERROR("); PNX; ZAHL(NHOLL); VERIFY(" "); STACK(")") END;        05359000
PROCEDURE BACKSP;                                                       05362000
BEGIN SEGMENT;  DFSW~FALSE;                                             05365000
  PASS("SPACE("); CHCT~8; FLPULL; VERIFY(" "); PASS(",-1)##") END;      05368000
PROCEDURE ENDFILE;                                                      05371000
BEGIN SEGMENT;  DFSW~FALSE;                                             05374000
  PASS("CLOSE("); CHCT~6; FLPULL; VERIFY(" ");                          05377000
  IF DSKST THEN PASS(",SAVE)") ELSE PASS(",*)###") END ;                05378000
PROCEDURE ROULER;                                                       05380000
BEGIN SEGMENT;  DFSW~FALSE;                                             05383000
  PASS("REWIND"); STACK("("); CHCT~5; FLPULL; VERIFY(" ");              05386000
  STACK(")") END;                                                       05389000
PROCEDURE LOCKF;                                                        05390000
  BEGIN SEGMENT;                                                        05390500
  PASS("LOCK ("); CHCT~3; FLPULL; VERIFY(" "); PASS(",SAVE)") END;      05391000
PROCEDURE ENSTA;                                                        05392000
BEGIN SEGMENT;                                                          05395000
  JCHECK(XLABEL);                                                       05398000
  LPROC(XLABEL); PRESENCE~1; STACK("&"); ZAHL(XLABEL); STACK(":");      05401000
                                                                        05402000
  STACK("E"); STACK("$");                                               05404000
  IF FLGX>511 THEN BEGIN                                                05407000
  TPOSIT~0 END;                                                         05410000
                                                                        05413000
  GO TO ENDSR END;                                                      05416000
PROCEDURE DATA;                                                         05417000
BEGIN SEGMENT;                                                          05418000
  BWX~FALSE; DATASW~TRUE; CHCT~3;                                       05419000
  DO DATAPR UNTIL CHAR!",";                                             05420000
  VERIFY(" ") END;                                                      05421000
PROCEDURE DFLIST;  ERRMSG(048);                                         05422000
PROCEDURE RCD;                                                          05425000
BEGIN SEGMENT;                                                          05428000
  DFSW~FALSE; PASS("R$CARD"); STACK(","); CHCT~3; FMPULL;               05431000
  IF CHAR="," THEN BEGIN STACK(","); OUTSW~FALSE; LISTPZ END;           05434000
  VERIFY(" "); STACK(")") END;                                          05437000
PROCEDURE WR2;                                                          05438000
  BEGIN SEGMENT; INTEGER K;                                             05438200
  DFSW~FALSE; IF NOM.CX4="READ" THEN BEGIN OUTSW~FALSE; K~CHCT~3 END    05438300
    ELSE BEGIN OUTSW~TRUE; K~CHCT~4 END; SCAN;                          05438400
  IF NOM="INPUTT" AND NOM1.CX3="APE" THEN BEGIN CHCT~12; TPROC END ELSE 05438500
    IF NOM="OUTPUT" AND NOM1.CX4="TAPE" THEN BEGIN CHCT~14; TPROC END   05438600
    ELSE IF (NX~NOM.CX4)="TAPE" THEN BEGIN CHCT~K+4; TPROC END          05438700
    ELSE IF(NX="DRUM" OR NOM.CX3="SPO") THEN ERRMSG(048)                05438800
    ELSE IF NOT OUTSW THEN RCD ELSE ERRMSG(056) END;                    05439000
PROCEDURE ETYPE;                                                        05440000
BEGIN SEGMENT; BWX~FALSE;                                               05443000
  IF T2SW THEN CHCT~-1 ELSE CHCT~7;                                     05445000
  DO BEGIN                                                              05446000
    SKAN;                     VPROC; IF EB OR CB THEN ERRMSG(054);      05449000
    IF LCLASS=UNDEF THEN CPUT(PR) END                                   05452000
  UNTIL CHAR!","; VERIFY(" "); FNSW~FALSE END;                          05455000
PROCEDURE PRC;                                                          05458000
BEGIN SEGMENT;  DFSW~FALSE; CHCT~4;                                     05461000
  IF NOT IGCK THEN PASS("B$####");                                      05463000
  STACK("W"); STACK("$"); PASS(NOM&"#"[42:42:6]); STACK(","); FMPULL;   05464000
  IF CHAR="," THEN BEGIN STACK(","); OUTSW~TRUE; LISTPZ END;            05467000
  VERIFY(" "); STACK(")") END;                                          05470000
PROCEDURE BLOCKDATA;  BEGIN SEGMENT; BWX~FALSE; BLKDSW~DATASW~TRUE END; 05473000
PROCEDURE TYPDEC(CH,M);    VALUE CH,M;    INTEGER CH,M;                 05476000
BEGIN SEGMENT;  BWX~FALSE;                                              05479000
  CHCT~CH; SKAN; IF NOM="FUNCTI" AND NOM1.CX2="ON" THEN ENSTA; CHCT~CH; 05482000
  DO BEGIN  SKAN; VPROC;                                                05485000
    IF MODE!UNDEF THEN ERRMSG(055);                                     05488000
    IF CHAR="(" THEN DMN;                                               05491000
    MPUT(M) END UNTIL CHAR!",";                                         05494000
  VERIFY(" ") END;                                                      05497000
PROCEDURE DEFILE;                                                       05498000
  ERRMSG(084);     % ERROR CHECKING MAY BE ADDED HERE;                  05499000
PROCEDURE LP3;                                                          05500000
BEGIN SEGMENT;                                                          05503000
  IF (NX~NOM.CX4)="CALL" THEN CALL                                      05506000
  ELSE IF NX="DATA" THEN DATA                                           05509000
  ELSE IF NX="LIST" THEN DFLIST                                         05512000
  ELSE IF NX="DUMP" THEN MONTOR(3,"D")                                  05515000
  ELSE BLCOM END;                                                       05518000
PROCEDURE LP2;                                                          05521000
BEGIN SEGMENT;                                                          05524000
  IF NOM="COMMON" THEN COMMON                                           05527000
  ELSE IF NOM="DIMENS" AND NOM1.CX3="ION" THEN DIMEN                    05530000
  ELSE IF NOM="EQUIVA" AND NOM1="LENCE#" THEN EQUIV                     05533000
  ELSE IF NOM="SUBROU" AND NOM1.CX4="TINE" THEN ENSTA                   05536000
  ELSE IF NOM="MONITO" AND NOM1.CX1="R" THEN MONTOR(6,"M")              05539000
  ELSE IF NOM="FUNCTI" AND NOM1.CX2="ON" THEN ENSTA                     05542000
  ELSE IF NOM="DEFINE" AND NOM1.CX4="FILE" THEN DEFILE                  05543000
  ELSE LP3 END;                                                         05545000
PROCEDURE LP1;                                                          05548000
BEGIN SEGMENT;                                                          05551000
  IF NOM="IF####" THEN IFSTA                                            05554000
  ELSE IF NOM="GOTO##" THEN CGOTO                                       05557000
  ELSE IF NOM="READ##" THEN BEGIN OUTSW~FALSE; TPROC END                05560000
  ELSE IF NOM="WRITE#" THEN BEGIN OUTSW~TRUE; TPROC END                 05563000
  ELSE LP3 END;                                                         05566000
PROCEDURE BLCOM;                                                        05569000
BEGIN SEGMENT;                                                          05572000
  IF (NX~NOM.CX4)="READ" AND T4SW THEN RCD                              05575000
  ELSE IF T2SW AND(NOM.CX4="READ" OR NOM.CX5="WRITE") THEN WR2          05576000
  ELSE IF NX="REAL" THEN TYPDEC(3,FLP)                                  05578000
  ELSE IF (NX~NOM.CX5)="PRINT" OR NX="PUNCH" THEN PRC                   05581000
  ELSE IF NOM="COMMON" THEN COMMON                                      05584000
  ELSE IF NOM="LOGICA" AND (NX~NOM1.CX1)="L" THEN TYPDEC(6,BOO)         05587000
  ELSE IF NOM="INTEGE" AND NX="R" THEN TYPDEC(6,FXP)                    05590000
  ELSE IF NOM="COMPLE" AND NX="X" THEN TYPDEC(6,CMP)                    05593000
  ELSE IF NOM="EXTERN" AND NOM1.CX2="AL" THEN ETYPE                     05596000
  ELSE IF FNSW THEN ETYPE                                               05597000
  ELSE IF NOM="DOUBLE" AND NOM1="PRECIS" AND NOM2.CX3="ION"             05599000
    THEN TYPDEC(14,DBP)                                                 05602000
  ELSE IF T2SW AND NOM.CX2="IF" THEN BEGIN CHCT~1; SCAN;                05603000
    IF NOM="ACCUMU" AND NOM1="LATORO" AND NOM2="VERFLO" AND NOM3.CX1="W"05603200
      THEN NOTHING                                                      05603400
    ELSE IF NOM="QUOTIE" AND NOM1="NTOVER" AND NOM2.CX4="FLOW" THEN     05603600
      NOTHING                                                           05603800
    ELSE IF NOM="DIVIDE" AND NOM1.CX5="CHECK" THEN NOTHING              05604000
    ELSE ERRMSG(056) END                                                05604500
  ELSE ERRMSG(056) END;                                                 05605000
PROCEDURE LPAR;                                                         05608000
  IF (T4SW AND FWCT>6) OR (T2SW AND FWCT>7) THEN LP2 ELSE               05611000
    IF NOM="FORMAT" THEN FMT ELSE BEGIN ARGCT;                          05614000
    IF RBAND[RG2]!")" OR RBAND[RG2+1]!"=" THEN BEGIN RESCAN; LP1 END    05617000
    ELSE BEGIN CHCT~-1; SKAN; VPROC; IF LCLASS=SV THEN ASGN             05620000
      ELSE IF DFSW THEN DFCN ELSE ERRMSG(074) END END;                  05623000
PROCEDURE BLANK;                                                        05626000
BEGIN SEGMENT;                                                          05629000
  IF (NX~NOM.CX4)="CALL" THEN CALL                                      05632000
  ELSE IF NX="GOTO" THEN RGOTO                                          05635000
  ELSE IF NX="STOP" THEN STOP(3)                                        05638000
  ELSE IF NX="LOCK" THEN LOCKF                                          05639000
  ELSE IF NOM.CX5="PAUSE" THEN NOTHING                                  05641000
  ELSE IF NOM="ASSIGN" THEN ASSIGN                                      05644000
  ELSE IF NOM="RETURN" THEN RETURN                                      05647000
  ELSE IF NOM="REWIND" THEN ROULER                                      05650000
  ELSE IF NOM="ENDFIL" AND NOM1.CX1="E" THEN ENDFILE                    05653000
  ELSE IF NOM="CONTIN" AND NOM1="UE####" THEN BWX~FALSE                 05656000
  ELSE IF NOM="BACKSP" AND (NX~NOM1.CX3)="ACE" THEN BACKSP              05659000
  ELSE IF NOM="BLOCKD" AND NX="ATA" THEN BLOCKDATA                      05662000
  ELSE IF NOM="END###" THEN ENSTA                                       05665000
  ELSE IF NOM="SUBROU" AND NOM1.CX4="TINE" THEN ENSTA                   05668000
  ELSE IF     T2SW AND NOM="SENSEL" AND NOM1.CX4="IGHT" THEN SLITETW    05669000
  ELSE BLCOM END;                                                       05671000
PROCEDURE COMMA;                                                        05674000
BEGIN SEGMENT;                                                          05677000
  IF (NX~NOM.CX4)="GOTO" THEN AGOTO                                     05680000
  ELSE IF NX="DATA" THEN DATA                                           05683000
  ELSE BLCOM END;                                                       05686000
PROCEDURE EQUALS;                                                       05689000
  IF NOM.CX2="DO" THEN BEGIN ARGCT; IF RG1}1 THEN DOST ELSE ASGN END    05692000
  ELSE ASGN;                                                            05695000
PROCEDURE SLASH;                                                        05698000
  IF NOM="COMMON" THEN COMMON                                           05701000
  ELSE IF NOM.CX4="DATA" THEN DATA                                      05704000
  ELSE ERRMSG(057);                                                     05707000
PROCEDURE DOLLAR;                                                       05710000
  IF NOM="GLOBAL" AND FWCT=6 THEN GLOBSW~TRUE                           05713000
  ELSE IF NOM="START#" OR NOM="LAST##" OR NOM="FINISH"OR NOM="ALGOL#"   05716000
  THEN ENSTA ELSE ERRMSG(058);                                          05719000
PROCEDURE FIND;                                                         05720000
  IF NOM.CX4="FIND" THEN ERRMSG(083) ELSE ERRMSG(059);                  05721000
PROCEDURE STMNT;                                                        05722000
BEGIN SEGMENT;                                                          05725000
  RESCAN;                                                               05728000
  IF CHAR="(" THEN LPAR ELSE IF CHAR=" " THEN BLANK                     05731000
  ELSE IF CHAR="," THEN COMMA ELSE IF CHAR="=" THEN EQUALS              05734000
  ELSE IF CHAR="$" THEN DOLLAR                                          05737000
  ELSE IF CHAR="/" THEN SLASH                                           05740000
  ELSE IF CHAR="@" THEN FIND                                            05742000
  ELSE ERRMSG(059) END;                                                 05743000
PROCEDURE PRTETE;                                                       05746000
BEGIN  INTEGER KPNT;                                                    05749000
  LOOKUP(PNAME); KPNT~PNT; ARGL~XF;                                     05752000
  DO BEGIN                                                              05755000
    SKAN; TBSCH; BOXA~BOXA+1; BOXL~BOXL+1;                              05758000
    IF TBSW THEN IF PNT>KPNT THEN ERRMSG(041);                          05761000
    PNT~XF+1; NFIX(VSPACE+3); IF NOT PFXSW THEN RWCHK(NOM);             05764000
    PBIT~1 END UNTIL CHAR!",";                                          05765000
  VERIFY(")"); GNC;                                                     05767000
  PNT~KPNT; ABIT~1; ARGS~BOXA END;                                      05770000
PROCEDURE FNCHECK(C,M);    VALUE C,M;    INTEGER C,M;                   05773000
BEGIN  INTEGER MD;                                                      05776000
  CHCT~C; SCAN;                                                         05779000
  IF NOM="FUNCTI" AND NOM1.CX2="ON" THEN BEGIN                          05782000
    CHCT~C+8; SKAN; EMBED(PNAME~NOM,VSPACE);                            05785000
    IF NOT PFXSW THEN RWCHK(PNAME); FCNSW~TRUE;                         05786000
    CPUT(FN); FTYPE~FF; MPUT(MD~(IF M=UNDEF THEN DFALT(NOM) ELSE M));   05788000
    PRTETE; VERIFY(" "); IF PFXSW THEN BEGIN                            05791000
    EMBED(PNAME,VSPACE); CPUT(NSV); MPUT(MD) END END                    05792000
  ELSE STMNT; STEND END ;                                               05794000
PROCEDURE STNMBR;                                                       05797000
BEGIN SEGMENT;                                                          05800000
  RORW~FALSE;      % RESET IND. FOR NEXT STATEMENT;                     05801000
  DSKST~FALSE;     % RESET DISK STATEMENT INDICATOR;                    05802000
  BWX~TRUE; RSVX~FLGX; RSVZ~FLGZ; CHCT~0;                               05803000
  IF STANO!XBWRD THEN BEGIN                                             05806000
    LPROC(STANO); IF PRESENT THEN ERRMSG(60);                           05809000
    PRESENCE~1; STACK("&"); ZAHL(STANO); STACK(":"); RSVX~FLGX END END; 05812000
%  PICK OFF PROCEDURE HEADING SHOULD THERE BE ONE;                      05815000
STNMBR; RESCAN; BOXP~BOXI+1;                                            05818000
IF NOM="SUBROU" AND NOM1.CX4="TINE" THEN BEGIN                          05821000
  CHCT~9; SKAN; EMBED(PNAME~NOM,VSPACE); IF NOT PFXSW THEN RWCHK(PNAME);05824000
  SUBSW~TRUE; CPUT(SR); ABIT~1;                                         05825000
  IF CHAR="(" THEN PRTETE; VERIFY(" ") END                              05827000
ELSE IF CHAR="(" THEN BEGIN                                             05830000
  IF NOM.CX4="REAL" THEN FNCHECK(3,FLP)                                 05833000
  ELSE IF NOM="LOGICA" AND (NX~NOM1.CX1)="L" THEN FNCHECK(6,BOO)        05836000
  ELSE IF NOM="INTEGE" AND NX="R" THEN FNCHECK(6,FXP)                   05839000
  ELSE IF NOM="COMPLE" AND NX="X" THEN FNCHECK(6,CMP)                   05842000
  ELSE IF NOM="DOUBLE" AND NOM1="PRECIS" AND NOM2.CX3="ION"             05845000
    THEN FNCHECK(14,DBP)                                                05848000
  ELSE BEGIN FNCHECK(-1,UNDEF); STEND END END                           05851000
ELSE BEGIN STMNT; STEND END;                                            05854000
  SRCHSW~FALSE;                                                         05857000
DO BEGIN           %  PROCESS NEXT STATEMENT;                           05860000
  BWX~TRUE; OPEN; NEXT: STNMBR; STMNT;                                  05863000
  RECOVER: STEND END UNTIL FALSE END;                                   05866000
%          *****************  END OF PH1  *****************             05869000
ENDSR:  %  *****************      PH2      *****************            05872000
BEGIN  BOOLEAN RPSW;  INTEGER KCT,QCT;                                  05875000
INTEGER ARRAY WXY[0:511];   COMMENT PH2 VERSION OF OLD WX ARRAY;        05876000
DEFINE STACK=STACK2#, PASS=PASS2#, ZAHL=ZAHL2#, STACKQ=STACKQ2#;        05878000
PROCEDURE SRHEAD; FORWARD;                                              05881000
PROCEDURE COMDEC; FORWARD;                                              05884000
PROCEDURE PRLK4; FORWARD;                                               05885000
PROCEDURE CQTAB(W,M,I);  INTEGER ARRAY W,M,I[0];  FORWARD;              05887000
PROCEDURE GNC;                                                          05890000
BEGIN  OWN INTEGER J;                                                   05893000
  CHAR~";";                                                             05896000
  IF BWX THEN BEGIN                                                     05899000
    IF (DRPX~(DRPX+1)){FLGX THEN BEGIN                                  05902000
      IF (J~DRPX.[39:9])=0 THEN BEGIN                                   05905000
        UNPACK(TENOR[TPOSIT,0],WXY[0]);                                 05908000
                                                                        05911000
          TPOSIT~TPOSIT+1 END;                                          05914000
      CHAR~WXY[J] END END                                               05917000
  ELSE GNZ END;                                                         05920000
STREAM PROCEDURE SSCAN(DQ,SQ);                                          05923000
BEGIN  LABEL LX;                                                        05926000
  SI~SQ; DI~DQ;                                                         05929000
  3(DS~2 LIT "00";                                                      05932000
     6(SI~SI+7; IF SC=ALPHA THEN DS~CHR ELSE JUMP OUT 2 TO LX));        05935000
LX:  DS~6 LIT "######" END;                                             05938000
PROCEDURE SCAN;                                                         05941000
BEGIN    COMMENT  PHASE 2 VERSION OF SCAN;                              05944000
  GNC; NHOLD[FWCT~0]~CHAR;                                              05947000
  WHILE ALFAN(CHAR) DO BEGIN GNC; NHOLD[FWCT~(FWCT+1)]~CHAR END;        05950000
  SSCAN(NOM,NHOLD) END;                                                 05953000
PROCEDURE PNX; BEGIN    COMMENT  PHASE 2 VERSION OF PNX;                05956000
  NHOLL~NHMX~0; GNC;                                                    05959000
  WHILE CHAR{9 DO BEGIN                                                 05962000
    NHOLL~10|NHOLL+(WHOLD[NHMX~(NHMX+1)]~CHAR); GNC END END;            05965000
PROCEDURE CQCLR;                                                        05968000
BEGIN  INTEGER J;                                                       05971000
  J~BOXL; WHILE (J~(J+1)){BOXI DO BEGIN  PNT~ADR[J];                    05974000
    IF LCLASS{SV AND CB THEN BEGIN CBIT~0; EBIT~0; USE~1 END END END;   05977000
PROCEDURE LMASK(L);    VALUE L;    INTEGER L;                           05980000
BEGIN SEGMENT;                                                          05983000
  LOOKUP(L); STACK("L"); ZAHL(IF BOOLEAN(JUMP) THEN CIBLE ELSE L) END;  05986000
PROCEDURE FDECL(FT);    VALUE FT;    INTEGER FT;                        05989000
BEGIN SEGMENT;                                                          05992000
  IF FT=FN THEN BEGIN IF PFXSW THEN BEGIN                               05995000
    STACK("F"); STACK("N") END END                                      05996000
  ELSE IF FT=DF THEN BEGIN IF PFXSW THEN BEGIN                          05997000
    STACK("D"); STACK("F") END END END;                                 05998000
PROCEDURE MDECL(M);    VALUE M;    INTEGER M;                           06001000
BEGIN SEGMENT;                                                          06004000
  IF M=FXP THEN BEGIN PASS("INTEGE"); STACK("R") END                    06007000
  ELSE IF M=FLP THEN PASS("REAL##")                                     06010000
  ELSE IF M=BOO THEN BEGIN PASS("BOOLEA"); STACK("N") END               06013000
  ELSE IF M=DBP THEN PASS("DOUBLE")                                     06016000
  ELSE IF M=CMP THEN BEGIN PASS("COMPLE"); STACK("X") END;              06019000
  STACK(" ") END;                                                       06022000
PROCEDURE PFX(L);    VALUE L;    INTEGER L;                             06025000
BEGIN SEGMENT;                                                          06028000
  IF L=DA THEN PASS("ARG###") ELSE                                      06029000
  TBSCH; IF PFXSW THEN BEGIN                                            06030000
  IF L=NSV THEN STACK("J")                                              06031000
  ELSE IF L=SV THEN BEGIN STACK("S"); STACK("V") END                    06034000
                                                                        06037000
  ELSE IF L=FN THEN BEGIN STACK("F"); STACK("N") END                    06040000
  ELSE IF L=SR THEN BEGIN STACK("S"); STACK("R") END END;               06043000
END;                                                                    06044000
PROCEDURE PUSH(N,C);    VALUE N,C;    INTEGER N,C;                      06046000
  BEGIN IF KX+C}71 THEN INDENT; PASS(N) END;                            06049000
PROCEDURE STASH(T);    VALUE T;    INTEGER T;                           06052000
  BEGIN STACK(T); IF KX<0 THEN INDENT END;                              06055000
PROCEDURE STACKC(T); VALUE T; INTEGER T; BEGIN INTEGER SX;              06055500
  OUTB[KX~(KX+1)]~T; IF KX}71 THEN BEGIN                                06055800
  DO IF OUTB[KX]!" " THEN BEGIN SOUTB[KX]~OUTB[KX];                     06056200
  OUTB[KX]~" " END UNTIL OUTB[KX~(KX-1)]=" "; SX~KX;                    06056500
  OUTPUT(2,0); KX~-1; INDENT;                                           06056800
  DO IF SX<71 THEN       OUTB[KX~(KX+1)]~ SOUTB[SX~(SX+1)]              06057200
  UNTIL SX}71 END END;                                                  06057500
PROCEDURE CQDX(I,J);    VALUE I,J;    INTEGER I,J;                      06058000
  IF J<1023 THEN ZAHL(I) ELSE IF J=1023 THEN ZAHL(I-1)                  06061000
  ELSE BEGIN ZAHL(I.[30:9]); STACK(","); ZAHL(I.[39:9]) END;            06064000
PROCEDURE ECALC;                                                        06067000
BEGIN INTEGER J,JFN;                                                    06070000
  J~KCT~0; IF ISSW THEN JFN~CCT+1;                                      06073000
  WHILE (J~(J+1)){CCT DO BEGIN                                          06076000
  IF ISSW THEN JFN~JFN-1 ELSE JFN~J;                                    06078000
    KCT~KCT+1;                                                          06079000
    IF D[JFN]{1023 THEN E[KCT]~D[JFN]                                   06082000
    ELSE BEGIN E[KCT]~511; E[KCT~(KCT+1)]~D[JFN].[30:9] END END END;    06085000
PROCEDURE SVDX(N);    VALUE N;    INTEGER N;                            06088000
BEGIN SEGMENT;             %   ECALC MUST HAVE BEEN PREVIOUSLY CALLED IN06091000
  SECURE(4|CCT+15); NOM~N; PFX(SV); PASS(N); IF RS THEN STACKQ;         06094000
    STACK("[");                                                         06095000
  DO BEGIN                                                              06097000
    STACK(0); STACK(":"); ZAHL(MIN(1022,E[KCT]));                       06100000
    STACK(IF KCT{1 THEN "]" ELSE ",") END UNTIL (KCT~(KCT-1)){0 END;    06103000
PROCEDURE CSORT(JC);           INTEGER JC;                              06104000
BEGIN LABEL X; INTEGER J,K;                                             06104100
  J~JC;                                                                 06104200
  WHILE (J~(J+1)){BOXC DO IF CSTACK[J DIV 64,J MOD 64]=NOM THEN         06104300
  BEGIN WHILE (J~(J-1))>JC DO                                           06104400
    CSTACK[(K~J+1) DIV 64, K MOD 64]~CSTACK[J DIV 64,J MOD 64];         06104500
    CSTACK[(JC~JC+1) DIV 64,JC MOD 64]~NOM;                             06104600
  GO TO X END;                                                          06104700
X: END;                                                                 06104800
PROCEDURE EQRLCO;                                                       06105000
BEGIN INTEGER JC,KPNT;                                                  06105100
  BWX~FALSE;                                                            06105150
  JC~0; IF (QCT~0)<BOXE THEN                                            06105200
  BEGIN KPNT~PNT~ADR[BOXE];                                             06105300
  DO BEGIN                                                              06105400
    DRPZ~ADDRESS;                                                       06105500
    DO BEGIN                                                            06105550
      DO BEGIN                                                          06105600
        SCAN; LOOKUP(NOM); IF CB THEN CSORT(JC) END UNTIL CHAR!",";     06105700
      GNC END UNTIL CHAR!",";                                           06105800
    PNT~KPNT END UNTIL (KPNT~PNT~ADR[INEXT]){0 END END;                 06105900
INTEGER PROCEDURE LNGTH;                                                06106000
BEGIN SEGMENT; LNGTH~(IF LCLASS=SV THEN LENGTH ELSE 1) END;             06109000
PROCEDURE RNIT2;                                                        06112000
BEGIN  INTEGER C,I,J,KPNT,L,LC;                                         06115000
  IF PNAME!XBWRD THEN BOXL~BOXL+1;                                      06118000
  IPHASE~2; LJSTCT~SPCT~0; KX~-1; HEADER;                               06121000
  IF FCNSW THEN BEGIN  LOOKUP(PNAME);                                   06124000
    IF NOT USED THEN BEGIN                                              06127000
      USE~1; ZCMNT; PASS(PNAME); PASS(" IS UN"); PASS("DEFINE");        06130000
      STACK("D"); ZSEMI END END;                                        06133000
  I~BOXJ;                    %  HERE WE EXCLUDE UNNEEDED LABELS;        06136000
  WHILE (I~(I+1)){BOXI DO BEGIN                                         06139000
    KPNT~PNT~ADR[I];                                                    06142000
    IF (LC~LCLASS)=LB AND F=0 THEN BEGIN                                06145000
      L~ID[I];                                                          06148000
      IF PRESENT THEN BEGIN                                             06151000
        IF BOOLEAN(JUMP) THEN BEGIN    J~0;                             06154000
          DO LOOKUP(C~CIBLE) UNTIL NOT BOOLEAN(JUMP) OR (J~(J+1))>BOXI; 06157000
          IF J>BOXI THEN BEGIN                                          06160000
            ZCMNT; PASS("LABEL "); ZAHL(L); PASS(" LEADS");             06163000
            PASS(" TO A "); PASS("LOOP;#"); LJUST END                   06166000
          ELSE BEGIN PNT~KPNT; CIBLE~C END END END                      06169000
      ELSE BEGIN                                                        06172000
        ZCMNT; PASS("LABEL "); ZAHL(L); PASS(" IS MI"); PASS("SSING;"); 06175000
        LJUST END END                                                   06178000
    ELSE IF LC=LB AND F=1 AND BOOLEAN(GOAL) THEN BEGIN                  06180300
      ZCMNT; PASS("GO TO "); PASS("LEADS "); PASS("TO A #");            06180500
      PASS("FORMAT"); STACK(";"); LJUST END                             06180800
    ELSE IF LC=PR THEN CPUT(SR)                                         06181000
    ELSE IF LC=SV AND MODE = UNDEF THEN MPUT(DFALT(ID[I]))              06182000
    ELSE IF LC=UNDEF THEN BEGIN                                         06184000
      CPUT(NSV); IF MODE=UNDEF THEN MPUT(DFALT(ID[I])) END END;         06187000
END;     %  ********  END OF PHASE TWO INITIALIZATION  ********;        06190000
PROCEDURE WARN(N);    VALUE N;    INTEGER N;                            06193000
BEGIN SEGMENT;                                                          06196000
  ZCMNT; PASS(N); STACK(" ");                                           06199000
  PASS("APPEAR"); PASS("S IN A"); PASS("N IMPR"); PASS("OPER C");       06202000
  PASS("OMMON "); PASS("OR EQU"); PASS("IVALEN"); PASS("CE STA");       06205000
  PASS("TEMENT"); ZSEMI END;                                            06208000
PROCEDURE PCHK2(NEWSIZE,CNX,BNX);    VALUE CNX,BNX;    INTEGER CNX,BNX; 06211000
  INTEGER ARRAY NEWSIZE[0];                                             06214000
BEGIN  INTEGER C;                                                       06217000
  IF QUERY(CNX,CBNOM) THEN BEGIN                                        06220000
    C~LNGTH+BNX; NEWSIZE[JTAB]~MAX(NEWSIZE[JTAB],C) END                 06223000
  ELSE WARN(CNX) END;                                                   06226000
PROCEDURE PCHK1(W,M,I,NEWSIZE,NX,BN,CN,J);                              06229000
  VALUE NX,BN,CN,J;  INTEGER NX,BN,CN,J;                                06232000
  INTEGER ARRAY W,M,I,NEWSIZE[0];                                       06235000
BEGIN SEGMENT;                                                          06238000
  LOOKUP(NX);                                                           06241000
  IF BN<0 OR (CB AND CNAME!CN) THEN WARN(NX) ELSE BEGIN                 06244000
    BASE~BN; CNAME~CN; CBIT~1;                                          06247000
    PCHK2(NEWSIZE,CN,BN) END;                                           06250000
  W[J]~W[QCT]; M[J]~M[QCT]; I[J]~I[QCT]; QCT~QCT-1 END;                 06253000
BOOLEAN PROCEDURE CHK1(W,M,I,NEWSIZE);                                  06256000
  INTEGER ARRAY W,M,I,NEWSIZE[0];                                       06259000
BEGIN  INTEGER J;                                                       06262000
  CHK1~TRUE; J~1;                                                       06265000
  WHILE J{QCT DO BEGIN                                                  06268000
    LOOKUP(W[J]);                                                       06271000
    IF CB THEN BEGIN                                                    06274000
      CHK1~FALSE; PCHK1(W,M,I,NEWSIZE,M[J],BASE-I[J],CNAME,J) END       06277000
    ELSE BEGIN                                                          06280000
      LOOKUP(M[J]);                                                     06283000
      IF CB THEN BEGIN                                                  06286000
        CHK1~FALSE; PCHK1(W,M,I,NEWSIZE,W[J],BASE+I[J],CNAME,J) END     06289000
      ELSE J~J+1 END END END;                                           06292000
INTEGER PROCEDURE DCHECK;                                               06295000
BEGIN  INTEGER DW;                                                      06298000
  DCHECK~1;                                                             06301000
  IF CHAR="(" THEN BEGIN  SVQ;                                          06304000
    PNX; DW~NHOLL;                                                      06307000
    IF CHAR="," THEN BEGIN  PNX; DW~(NHOLL-1)|D[1]+DW;                  06310000
      IF CHAR="," THEN BEGIN  PNX; DW~((NHOLL-1)|D[1]|D[2])+DW END END; 06313000
    DCHECK~DW; GNC END END;                                             06316000
PROCEDURE EQPROC(W,M,I,NEWSIZE);                                        06319000
  INTEGER ARRAY W,M,I,NEWSIZE[0];                                       06322000
BEGIN  BOOLEAN BC;  INTEGER CNX,DW,INCR,J,QCX,T1,T2;                    06325000
  BC~FALSE; T1~XBWRD; T2~-1; QCX~QCT;                                   06328000
  DO BEGIN                                                              06331000
    SCAN; LOOKUP(NOM); DW~DCHECK; BC~(CB OR BC);                        06334000
    IF CB THEN BEGIN INCR~BASE+DW; CNX~CNAME END;                       06337000
    IF (DW=T2 AND NOM<T1) OR DW>T2 THEN BEGIN T1~NOM; T2~DW END;        06340000
    W[QCT~(QCT+1)]~NOM; I[QCT]~DW END UNTIL CHAR!","; GNC;              06343000
  IF BC THEN BEGIN                                                      06346000
    J~QCX+1; WHILE J{QCT DO PCHK1(W,M,I,NEWSIZE,W[J],INCR-I[J],CNX,J);  06349000
    QCT~QCX END                                                         06352000
  ELSE BEGIN  J~QCX;                                                    06355000
    WHILE (J~(J+1)){QCT DO BEGIN M[J]~T1; I[J]~T2-I[J] END END END;     06358000
PROCEDURE CBK(N);  VALUE N;  INTEGER N;                                 06361000
BEGIN SEGMENT;                                                          06364000
  IF N=XBWRD THEN BEGIN PASS("BLANK "); PASS("COMMON") END              06367000
  ELSE BEGIN PASS("COMMON"); PASS("BLOCK "); PASS(N) END END;           06370000
PROCEDURE CBK1(N);    VALUE N;    INTEGER N;                            06373000
BEGIN SEGMENT;                                                          06376000
  IF N!XBWRD THEN BEGIN PASS("CBLK##"); PASS(N) END                     06379000
  ELSE PASS("COMMON") END;                                              06382000
PROCEDURE LTRUE(N);    VALUE N;    INTEGER N;                           06383000
BEGIN SEGMENT;                                                          06383100
  PASS("COMMEN"); PASS("T TRUE"); PASS(" LENGT"); STACK("H");           06383300
  STACK("="); ZAHL(N); ZSEMI END;                                       06383400
PROCEDURE CDECL;                                                        06385000
BEGIN INTEGER BNOM,CBNX,J,JL,JR,KPNT,Q; BOOLEAN B;                      06388000
  INTEGER ARRAY W,M,I[0:EQUMAX+5];                                      06391000
  INTEGER ARRAY NEWSIZE[0:CBMAX];                                       06394000
  BWX~FALSE; CBNX~CBNOM[0];                                             06397000
  J~0; WHILE (J~(J+1)){CBNX DO NEWSIZE[J]~0;                            06400000
  IF BOXC>0 THEN BEGIN                                                  06403000
    J~1; DO BEGIN                                                       06406000
      JL~J DIV 64; JR~J MOD 64; LOOKUP(CSTACK[JL,JR]);                  06409000
      IF QUERY(BNOM~BSTACK[JL,JR],CBNOM) THEN NOTHING                   06412000
      ELSE BEGIN CBNOM[CBNOM[0]~JTAB]~BNOM; NEWSIZE[JTAB]~0 END;        06415000
      BASE~NEWSIZE[JTAB];                                               06418000
      NEWSIZE[JTAB]~NEWSIZE[JTAB]+LNGTH END UNTIL (J~(J+1))>BOXC END;   06421000
  IF (QCT~0)<BOXE THEN BEGIN                                            06424000
    KPNT~PNT~ADR[BOXE];                                                 06427000
    DO BEGIN                                                            06430000
      DRPZ~ADDRESS;                                                     06433000
      DO EQPROC(W,M,I,NEWSIZE) UNTIL CHAR!",";                          06436000
      PNT~KPNT END UNTIL (KPNT~PNT~ADR[INEXT]){0 END;                   06439000
  IF QCT>0 THEN DO UNTIL CHK1(W,M,I,NEWSIZE);                           06442000
%  CHECK FOR DISCREPANCIES IN COMMON BLOCK SIZES;                       06445000
  J~0; WHILE (J~(J+1)){CBNX DO IF NEWSIZE[J]{CBSIZE[J] THEN NOTHING     06448000
  ELSE BEGIN                                                            06451000
    ZCMNT; PASS("NEW SI"); PASS("ZE OF "); CBK(CBNOM[J]);               06454000
    PASS(" IS: #"); ZAHL(CBSIZE[J]~NEWSIZE[J]); ZSEMI END;              06457000
  J~CBNX; WHILE (J~(J+1)){CBNOM[0] DO BEGIN                             06460000
    IF NOT GDSW THEN BEGIN                                              06461000
    MDECL(FLP); PASS("ARRAY "); CBK1(CBNOM[J]);                         06463000
    EQLDEC(CBSIZE[J]~NEWSIZE[J]); STACK(";"); POSIT(45);                06466000
    LTRUE(CBSIZE[J]) END ELSE CBSIZE[J]~NEWSIZE[J] END;                 06469000
  IF GDSW AND FTT THEN BEGIN FOR Q~FXP,FLP,BOO DO BEGIN                 06470000
    J~BOXL; B~FALSE;                                                    06470200
    WHILE(J~(J+1)){BOXI DO BEGIN PNT~ADR[J];                            06470400
      IF LCLASS=SV THEN IF MODE=Q THEN IF CB AND NOT EB THEN            06470800
        BEGIN IF B THEN STACK(",")                                      06471200
        ELSE BEGIN B~TRUE; MDECL(Q); PASS("ARRAY ") END;                06471600
      SVDCMP; ECALC; SVDX(ID[J]) END END;                               06472000
    IF B THEN ZSEMI END;                                                06472400
    FOR Q~FXP,FLP,BOO DO BEGIN                                          06472800
      J~BOXL; B~FALSE; WHILE (J~(J+1)){BOXI DO BEGIN                    06473200
        PNT~ADR[J]; IF LCLASS=NSV THEN IF MODE=Q THEN IF CB             06473600
        AND NOT EB THEN BEGIN IF B THEN STACK(",")                      06474000
        ELSE BEGIN B~TRUE; MDECL(Q) END;                                06474300
      SECURE(9); IF PFXSW THEN STACK("J"); PASS(ID[J]);LOOKUP(ID[J]);   06474600
          IF RS THEN STACKQ END END;                                    06474700
  IF B THEN ZSEMI END; FTT~FALSE END;                                   06474900
  SRHEAD; COMDEC; IF QCT>0 THEN CQTAB(W,M,I) END;                       06475000
PROCEDURE SRHEAD;                                                       06478000
BEGIN  BOOLEAN B;  INTEGER J,JK,KPNT,L,M;                               06481000
  BWX~TRUE;                                                             06484000
  IF DATASW AND NOT BLKDSW THEN BEGIN                                   06485000
    MDECL(BOO); STACK("B"); ZAHL(DATACT~(DATACT+1)); ZSEMI END;         06486000
  PNT~ADR[BOXP]; IF FCNSW THEN MDECL(MODE);                             06487000
  PASS("PROCED"); PASS("URE ##");                                       06490000
  IF FCNSW THEN BEGIN NOM~PNAME; PFX(FN); PASS(PNAME); IF RS THEN       06493000
    STACKQ END                                                          06494000
  ELSE IF SUBSW THEN BEGIN NOM~PNAME; PFX(SR); PASS(PNAME); IF RS THEN  06495000
    STACKQ END                                                          06496000
  ELSE IF BLKDSW THEN BEGIN PASS("BLOCKD"); PASS("ATA###");             06497000
  ZAHL(BLKDCT~(BLKDCT+1)) END                                           06498000
  ELSE BEGIN PASS("MAINPR"); STACK("O") END;                            06499000
  IF BOXA{0 THEN ZSEMI ELSE BEGIN                                       06502000
    KPNT~PNT; JK~BOXP+BOXA; LJSTCT~2; STACK("(");                       06505000
    J~BOXP; WHILE (J~(J+1)){JK DO BEGIN  PNT~ADR[J];                    06508000
      SECURE(10); LOOKUP(ID[J]); PFX(LCLASS); PASS(ID[J]);              06511000
      IF RS THEN STACKQ;                                                06512000
      STACK(IF J<JK THEN "," ELSE ")") END; ZSEMI;                      06514000
    J~BOXP; B~FALSE;                                                    06517000
    WHILE (J~(J+1)){JK DO BEGIN  PNT~ADR[J];                            06520000
      IF LCLASS=NSV THEN IF NOT ALTERED THEN BEGIN                      06523000
        IF B THEN STACK(",")                                            06525000
        ELSE BEGIN B~TRUE; MARGIN; PASS("VALUE ") END;                  06526000
        SECURE(8); NOM~ID[J]; TBSCH; IF PFXSW THEN STACK("J");          06529000
          PASS(ID[J]); IF RS THEN STACKQ END END; IF B THEN ZSEMI;      06529500
    J~BOXP; WHILE(J~(J+1)){JK DO BEGIN PNT~ADR[J];                      06530000
      IF LCLASS=UNDEF THEN CPUT(NSV); IF MODE=UNDEF THEN                06530500
      BEGIN NOM~ID[J]; MPUT(DFALT(NOM)) END END;                        06531000
    FOR L~NSV,SV,FN DO FOR M~FXP,FLP,BOO DO BEGIN  J~BOXP; B~FALSE;     06532000
      WHILE (J~(J+1)){JK DO BEGIN  PNT~ADR[J];                          06535000
        IF LCLASS=L THEN IF MODE=M THEN BEGIN                           06538000
          IF B THEN STACK(",") ELSE BEGIN B~TRUE; MARGIN; MDECL(M);     06541000
            IF L=SV THEN PASS("ARRAY ")                                 06544000
            ELSE IF L=FN THEN BEGIN                                     06547000
              PASS("PROCED"); PASS("URE ##") END END;                   06550000
          IF L=SV THEN BEGIN  SVDCMP;                                   06553000
            SECURE(CCT|2+10); LOOKUP(ID[J]); PFX(SV); PASS(ID[J]);      06556000
              IF RS THEN STACKQ; STACK("[");                            06557000
            DO BEGIN                                                    06559000
              IF D[CCT]>1023 THEN BEGIN STACK(0); STACK(",") END;       06562000
              STACK(0); STACK(IF CCT=1 THEN "]" ELSE ",") END           06565000
            UNTIL (CCT~(CCT-1)){0 END                                   06568000
          ELSE BEGIN SECURE(10); LOOKUP(ID[J]); PFX(L);                 06571000
          PASS(ID[J]); IF RS THEN STACKQ END END END;                   06572000
      IF B THEN ZSEMI END;                                              06574000
    J~BOXP; B~FALSE;                                                    06577000
    WHILE (J~(J+1)){JK DO BEGIN  PNT~ADR[J];                            06580000
      IF LCLASS=SR THEN BEGIN                                           06583000
        IF B THEN STACK(",") ELSE BEGIN                                 06586000
        MARGIN; PASS("PROCED"); PASS("URE ##") END;                     06589000
        B~TRUE; SECURE(8); PFX(SR); PASS(ID[J]); IF RS THEN STACKQ      06592000
      END END;                                                          06593000
    IF B THEN ZSEMI END;                                                06595000
LJSTCT~0; PASS("BEGIN#"); LJUST END;                                    06598000
PROCEDURE COMDEC;                                                       06601000
BEGIN  INTEGER CN,J,LC;                                                 06604000
  IF NOT GDSW THEN BEGIN                                                06606000
  J~BOXL; WHILE (J~(J+1)){BOXI DO BEGIN  PNT~ADR[J];                    06607000
    IF (LC~LCLASS){SV THEN IF CB THEN IF USED OR GLOBSW THEN BEGIN      06610000
      SLBIT~1;                                                          06613000
      IF BRKUSW THEN ZCMNT ELSE PASS("DEFINE"); POSIT(9);               06616000
      LOOKUP(ID[J]);                                                    06617000
      PFX(LC); PASS(ID[J]); IF RS THEN STACKQ;                          06619000
      POSIT(17); STACK("="); CBK1(CN~CNAME);                            06620000
      IF QUERY(CN,CBNOM) THEN BEGIN                                     06622000
        IF LC=SV THEN BEGIN                                             06625000
          STACK("#"); STACK(";"); POSIT(32); PASS("COMMEN"); STACK("T");06628000
          POSIT(43); PASS("BASE=#") END;                                06631000
        STACK("["); CQDX(1+BASE,CBSIZE[JTAB]); STACK("]"); STACK("#");  06634000
        ZSEMI END END;                                                  06637000
    IF CB THEN BEGIN EBIT~0; CNAME~CBSIZE[JTAB] END END END;            06640000
END;                                                                    06641000
PROCEDURE DELE(W,M,I,N);  VALUE N;  INTEGER N;  INTEGER ARRAY W,M,I[0]; 06643000
BEGIN SEGMENT; W[N]~W[QCT]; M[N]~M[QCT]; I[N]~I[QCT]; QCT~QCT-1 END;    06646000
PROCEDURE DBL(W,M,I);    INTEGER ARRAY W,M,I[0];                        06649000
BEGIN  INTEGER N;                                                       06652000
  IF QCT>0 THEN BEGIN  N~1;                                             06655000
    DO IF W[N]!M[N] THEN N~N+1 ELSE DELE(W,M,I,N) UNTIL N>QCT END END;  06658000
PROCEDURE REDUCE(W,M,I);    INTEGER ARRAY W,M,I[0];                     06661000
BEGIN  LABEL CQ2;  BOOLEAN B;  INTEGER J,N,T;                           06664000
  DBL(W,M,I);      %  ELIMINATE SELF-REDUNDANT ENTRIES;                 06667000
CQ2:  B~FALSE; J~0;                                                     06670000
  WHILE (J~(J+1)){QCT DO BEGIN  N~0;                                    06673000
    WHILE (N~(N+1)){QCT DO BEGIN                                        06676000
      IF J=N THEN BEGIN                                                 06679000
        IF W[N]=M[N] THEN BEGIN                                         06682000
          DO DELE(W,M,I,N) UNTIL QCT<N OR W[N]!M[N]; GO TO CQ2 END END  06685000
      ELSE IF W[J]=W[N] THEN BEGIN  B~TRUE;                             06688000
        IF I[J]<I[N] OR (I[J]=I[N] AND M[J]}M[N]) THEN BEGIN            06691000
          W[N]~M[J]; M[J]~M[N]; T~I[J]; I[J]~I[N]; I[N]~I[N]-T END      06694000
        ELSE BEGIN W[N]~M[N]; M[N]~M[J]; I[N]~I[J]-I[N] END END END END;06697000
  T~QCT; DBL(W,M,I); IF QCT<T OR B THEN GO TO CQ2 END;                  06700000
PROCEDURE EPROC2(W,M,I,ECL);                                            06703000
  VALUE ECL;  INTEGER ECL;  INTEGER ARRAY W,M,I[0];                     06706000
BEGIN  BOOLEAN B,FL,FX,RBLK,SVX;  INTEGER BS,C,J,LC,LNG,MAITRE,MX;      06709000
  J~0; B~FL~FX~RBLK~SVX~FALSE; LOOKUP(MAITRE~M[1]); C~LNG~LENGTH;       06712000
  WHILE (J~(J+1)){QCT DO IF M[J]=MAITRE THEN BEGIN  LOOKUP(W[J]);       06715000
    IF (MX~MODE)=BOO THEN B~TRUE ELSE IF MX=FXP THEN FX~TRUE            06718000
    ELSE FL~TRUE; C~MAX(LNGTH+I[J],C);                                  06721000
    IF LCLASS=SV THEN BEGIN  SVX~TRUE;                                  06724000
      IF I[J]>0 OR DCT>1 THEN RBLK~TRUE END END;                        06727000
  MDECL(MX~(IF FL THEN FLP ELSE IF (FX OR NOT B) THEN FXP ELSE BOO));   06730000
  IF SVX THEN PASS("ARRAY "); PASS("ECL###"); ZAHL(ECL);                06733000
  IF SVX THEN EQLDEC(C); STACK(";"); POSIT(45); LTRUE(C);               06736000
  J~1; WHILE J{QCT DO IF M[J]=MAITRE THEN BEGIN  LOOKUP(W[J]);          06739000
    BASE~BS~I[J]; SLBIT~1; CNAME~C;                                     06742000
    IF MODE=BOO AND MX!BOO THEN FLBIT~1;                                06745000
    IF (LC~LCLASS)!SV THEN EBIT~0                                       06748000
    ELSE IF BS=0 AND C{1022 AND NOT RBLK THEN EBIT~0;                   06751000
    PASS("DEFINE"); POSIT(9); PFX(LC); PASS(W[J]);                      06754000
    IF RS THEN STACKQ; POSIT(17);                                       06755000
    STACK("="); PASS("ECL###"); ZAHL(ECL);                              06757000
    IF SVX THEN BEGIN                                                   06760000
      IF LC=SV THEN BEGIN                                               06763000
        STACK("#"); STACK(";"); POSIT(32); PASS("COMMEN"); STACK("T");  06766000
        POSIT(43); PASS("BASE=#") END;                                  06769000
      STACK("["); CQDX(1+BS,C); STACK("]") END;                         06772000
    STACK("#"); ZSEMI; DELE(W,M,I,J) END                                06775000
  ELSE J~J+1 END;                                                       06778000
PROCEDURE CQTAB(W,M,I);    INTEGER ARRAY W,M,I[0];                      06781000
BEGIN  LABEL CQ3;  INTEGER ECL,J,K,N;                                   06784000
  REDUCE(W,M,I);                                                        06787000
%  NOW WE ATTEMPT TO FIND THE MASTER OF EACH EQUIVALENCE CLASS;         06790000
%  THIS ALGORITHM SEEMS TO REQUIRE ONLY ONE PASS;                       06793000
  J~0; WHILE (J~(J+1)){QCT DO BEGIN                                     06796000
    N~0; WHILE (N~(N+1)){QCT DO IF W[J]=M[N] THEN BEGIN                 06799000
      M[N]~M[J]; I[N]~I[N]+I[J] END END;                                06802000
%  MASTERS, WHICH HAD BEEN PURGED AS LEFT-ENTRIES, MUST NOW BE APPENDED 06805000
%    TO W,M,I TABLES;                                                   06808000
  K~QCT; J~0;      %  RETAIN PRESENT VALUE OF QCT;                      06811000
  WHILE (J~(J+1)){QCT DO BEGIN  N~QCT;                                  06814000
    WHILE (N~(N+1)){K DO IF M[J]=M[N] THEN GO TO CQ3;                   06817000
    W[K~(K+1)]~M[K]~M[J]; I[K]~0; CQ3: END;  QCT~K;                     06820000
  ECL~0; WHILE QCT>0 DO EPROC2(W,M,I,(ECL~(ECL+1))) END;                06823000
PROCEDURE LOCDEC;                                                       06826000
BEGIN  BOOLEAN B;  INTEGER J,L,M;                                       06829000
PROCEDURE DXDECL(ID,JMAX);    VALUE ID,JMAX;    INTEGER ID,JMAX;        06832000
BEGIN  INTEGER J,L;                                                     06835000
  PASS("OWN ##"); MDECL(FXP); J~1;                                      06838000
  DO BEGIN PASS(ID); ZAHL(J); IF J<JMAX THEN STACK(",") END             06841000
  UNTIL (J~(J+1))>JMAX;                                                 06844000
  ZSEMI END;                                                            06847000
  IF GLOBSW THEN CQCLR;                                                 06850000
  FOR M~FXP,FLP,BOO DO BEGIN                                            06853000
    J~BOXL; B~FALSE;                                                    06856000
    WHILE (J~(J+1)){BOXI DO BEGIN                                       06859000
      PNT~ADR[J];                                                       06862000
    IF GDSW AND CB THEN SLBIT~1;                                        06863000
      IF LCLASS=SV THEN IF MODE=M THEN IF USED AND NOT SLB AND NOT EB   06865000
      THEN BEGIN                                                        06868000
        IF B THEN STACK(",")                                            06871000
        ELSE BEGIN B~TRUE; PASS("OWN ##"); MDECL(M); PASS("ARRAY ") END;06874000
        SVDCMP; ECALC; SVDX(ID[J]) END END;                             06877000
    IF B THEN ZSEMI END;                                                06880000
  IF DXCT>0 THEN DXDECL("DX####",DXCT);                                 06883000
  IF IXCT>0 THEN DXDECL("INDEX#",IXCT);                                 06886000
  IF ASNVAR[0]>0 THEN BEGIN                                             06889000
    PASS("OWN ##"); MDECL(FXP); PASS("ASV###"); PASS(ASNVAR[J~1]);      06892000
    WHILE (J~(J+1)){ASNVAR[0] DO BEGIN                                  06895000
      STACK(","); SECURE(9); PASS("ASV###"); PASS(ASNVAR[J]) END;       06898000
    ZSEMI END;                                                          06901000
  FOR M~FXP,FLP,BOO DO BEGIN                                            06904000
    J~BOXL; B~FALSE;                                                    06907000
    WHILE (J~(J+1)){BOXI DO BEGIN                                       06910000
      PNT~ADR[J];                                                       06913000
    IF LCLASS=NSV AND    IASV=0 THEN IF MODE=M THEN IF USED AND NOT     06916000
      SLB AND NOT EB                                                    06917000
      THEN BEGIN                                                        06919000
        IF B THEN STACK(",")                                            06922000
        ELSE BEGIN B~TRUE; PASS("OWN ##"); MDECL(M) END;                06925000
        SECURE(9); IF PFXSW THEN STACK("J"); PASS(ID[J]);               06928000
        LOOKUP(ID[J]);                                                  06928500
        IF RS THEN STACKQ END END;                                      06929000
    IF B THEN ZSEMI END;                                                06931000
  J~BOXL; B~FALSE;                                                      06934000
  WHILE (J~(J+1)){BOXI DO BEGIN                                         06937000
    PNT~ADR[J];                                                         06940000
    IF (L~LCLASS)=FN OR L=SR THEN IF USED                               06943000
    THEN IF FTYPE=FF OR L!FN THEN BEGIN                                 06946000
      IF B THEN STACK(",") ELSE BEGIN                                   06949000
        B~TRUE; ZCMNT; PASS("THE FO"); PASS("LLOWIN"); PASS("G PROC");  06952000
        PASS("EDURES"); PASS(" ARE U"); PASS("SED:  ") END;             06955000
      SECURE(9); LOOKUP(ID[J]); PFX(L); PASS(ID[J]);                    06958000
      IF RS THEN STACKQ END END;                                        06959000
  IF B THEN ZSEMI;                                                      06961000
  IF BRKUSW THEN CQCLR END;                                             06964000
%    ********  END OF LOCDEC  ********;                                 06967000
PROCEDURE FMTHD;                                                        06970000
BEGIN  BOOLEAN B;  INTEGER I,J,K,L;                                     06973000
  BWX~FALSE; LJSTCT~SPCT~0; B~FALSE; I~BOXL;                            06976000
  WHILE (I~(I+1)){BOXI DO BEGIN  PNT~ADR[I];                            06979000
  IF LCLASS=LB THEN IF BOOLEAN(F) THEN IF PRESENT AND OK AND NOT CCTRL=106982000
  THEN BEGIN                                                            06985000
    IF B THEN BEGIN STACK(","); LJUST END                               06988000
    ELSE BEGIN B~TRUE; PASS("FORMAT"); STACK(" ") END;                  06991000
    DRPZ~ADDRESS; STACK("F"); STACK("L"); ZAHL(ID[I]); STACK("("); L~0; 06994000
    WHILE L}0 DO BEGIN                                                  06997000
      K~0; GNC;                                                         07000000
      WHILE ALFAN(CHAR) OR CHAR="." DO BEGIN                            07003000
        WHOLD[K~(K+1)]~CHAR; GNC END;                                   07006000
      SECURE(K+1); J~0; WHILE (J~(J+1)){K DO STACK(WHOLD[J]);           07009000
      IF CHAR=""" THEN BEGIN                                            07012000
        K~0; DO GNC UNTIL (WHOLD[K~(K+1)]~CHAR)="""; SECURE(K+2);       07015000
        J~1; STACK("""); DO STACK(WHOLD[J]) UNTIL (J~(J+1))}K END;      07018000
      STACK(CHAR);                                                      07021000
      IF CHAR="(" THEN L~L+1 ELSE IF CHAR=")" THEN L~L-1 END END END;   07024000
  IF B THEN ZSEMI;                                                      07027000
  I~BOXL; WHILE (I~(I+1)){BOXI DO BEGIN  PNT~ADR[I];                    07030000
  IF LCLASS=LB THEN IF BOOLEAN(F) THEN IF NOT OK THEN BEGIN             07033000
    ZCMNT;                                                              07036000
    PASS("FORMAT"); STACK(" "); STACK("F"); STACK("L"); ZAHL(ID[I]);    07039000
    IF PRESENT THEN BEGIN PASS(" IS IN"); PASS(" ERROR") END            07042000
    ELSE BEGIN PASS(" IS MI"); PASS("SSING#") END; ZSEMI END END END;   07045000
PROCEDURE LDECL;                                                        07048000
BEGIN  BOOLEAN B;  INTEGER J,K,L;                                       07051000
  IF (BGNSW~((FLGX+FLGZ)>4096)) THEN BEGIN PASS("BEGIN#"); LJUST END;   07054000
  J~BOXL; B~FALSE;                                                      07057000
  WHILE (J~(J+1)){BOXI DO BEGIN                                         07060000
    PNT~ADR[J];                                                         07063000
    IF LCLASS=LB THEN IF F=0 AND BOOLEAN(GOAL) AND NOT BOOLEAN(JUMP)    07066000
    THEN BEGIN                                                          07069000
      IF B THEN STACK(",") ELSE BEGIN B~TRUE; PASS("LABEL ") END;       07072000
      SECURE(8); STACK("L"); ZAHL(ID[J]) END END;                       07075000
  IF B THEN ZSEMI;                                                      07078000
  IF (K~ASTACK[0])>0 THEN BEGIN                                         07081000
    PASS("SWITCH"); STACK(" "); PASS("ASSIGN"); STACK("~");             07084000
    LMASK(ASTACK[J~1]);                                                 07087000
    WHILE (J~(J+1)){K DO BEGIN                                          07090000
      STACK(","); SECURE(8); LMASK(ASTACK[J]) END;                      07093000
    ZSEMI END;                                                          07096000
  IF JSWGO>0 THEN BEGIN                                                 07099000
    LXSAVE[(K~1)+JSWGO]~JXLS;                                           07102000
    DO BEGIN                                                            07105000
      PASS("SWITCH"); PASS(" SWGO#"); ZAHL(K); STACK("~");              07108000
      J~LXSAVE[K]+1; L~LXSAVE[K+1];                                     07111000
      DO BEGIN                                                          07114000
        SECURE(8); LMASK(XSTACK[J DIV 21,J MOD 21]);                    07117000
        IF J<L THEN STACK(",") END UNTIL (J~(J+1))>L;                   07120000
      ZSEMI END UNTIL (K~(K+1))>JSWGO END END;                          07123000
PROCEDURE PROC1(N);    VALUE N;    INTEGER N;                           07126000
BEGIN  BOOLEAN B;    LOOKUP(N);                                         07129000
%  PROC1 WATCHES OUT FOR BOOLEAN NSV VARIABLES EMBEDDED IN FLP OR FXP   07132000
%  EQUIVALENCE CLASSES;                                                 07135000
  SECURE(8);                                                            07138000
  IF (B~FLB) THEN BEGIN                                                 07141000
    PASS("BOOLEA"); STACK("N"); STACK("("); SECURE(8) END;              07144000
  IF PFXSW THEN STACK("J"); PASS(N); IF RS THEN STACKQ;                 07147000
  IF B THEN STACK(")") END;                                             07148000
PROCEDURE NDUMP; BEGIN PASS(NOM); IF FWCT>6 THEN PASS(NOM1);            07150000
  IF FWCT>12 THEN PASS(NOM2) END;                                       07151000
PROCEDURE SCRP;                                                         07153000
BEGIN  LABEL LK1,LK2;  INTEGER J,L,NX;                                  07156000
%  SCRP TERMINATES AT ZERO LEVEL COMMA OR RIGHT BRACKET;                07159000
  L~0; LK1:                                                             07162000
  NX~0; DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)>9;                         07165000
  IF NX>1 THEN BEGIN LK2:                                               07168000
    IF CHAR="." THEN DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)>9;            07171000
    IF CHAR="@" THEN BEGIN GNC;                                         07174000
      IF (WHOLD[NX~(NX+1)]~CHAR){9 OR CHAR="-"                          07177000
      THEN DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)>9 END;                  07180000
    SECURE(NX); J~1; DO STACK(WHOLD[J]) UNTIL (J~(J+1))}NX END          07183000
  ELSE IF CHAR="%" THEN BEGIN SCAN;                                     07186000
    IF CHAR="[" THEN BEGIN  LOOKUP(NOM);                                07189000
      IF FLB THEN BEGIN  SECURE(8);                                     07192000
        PASS("BOOLEA"); STACK(" "); STACK("("); PRLK4; STACK(")") END   07195000
      ELSE PRLK4; GO TO LK1 END;                                        07198000
    SECURE(FWCT+3); PFX(SV); NDUMP; IF RS THEN STACKQ; SVQ;             07201000
    IF CQSW THEN IF BASE!0 OR CCT>1 OR LENGTH>1022 THEN BEGIN           07204000
      STASH("["); STASH("#"); STASH("]") END END                        07207000
  ELSE IF CHAR="J" THEN BEGIN SCAN; PROC1(NOM) END                      07210000
  ELSE IF CHAR="Z" THEN BEGIN SCAN; LOOKUP(NOM); PFX(LCLASS);           07213000
    NDUMP; IF RS THEN STACKQ END                                        07214000
  ELSE IF ALFA[CHAR] THEN BEGIN                                         07216000
    NX~CHAR; SCAN; SECURE(FWCT+2); STACK(NX); NDUMP END                 07219000
  ELSE IF CHAR=""" THEN BEGIN  NX~0;                                    07222000
    DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)="""; SECURE(NX+1); STACK("""); 07225000
    J~1; DO STACK(WHOLD[J]) UNTIL (J~(J+1))>NX; GNC END;                07228000
  IF CHAR="." OR CHAR="@" THEN BEGIN WHOLD[NX~1]~CHAR; GO TO LK2 END;   07231000
  IF CHAR="(" THEN L~L+1 ELSE IF CHAR=")" THEN L~L-1;                   07234000
  IF L>0 THEN BEGIN STASH(CHAR); GO TO LK1 END;                         07237000
  IF L=0 AND CHAR!"," AND CHAR!"]" THEN BEGIN                           07240000
    STASH(CHAR); GO TO LK1 END END;                                     07243000
PROCEDURE PWFLD;                                                        07244000
BEGIN SEGMENT; PASS(")).[33"); PASS(":6],K."); PASS("[39:9]") END;      07244100
PROCEDURE CQPR2(WN);    VALUE WN;    INTEGER WN;                        07244200
BEGIN SEGMENT;  STACK("("); SCRP; STACK(")");                           07244300
  IF WN!1 THEN BEGIN STACK("|"); ZAHL(WN) END END;                      07244400
PROCEDURE CQPR1(PX,W,N);  VALUE W,N;  INTEGER W,N;  INTEGER ARRAY PX[0];07245000
BEGIN  BOOLEAN B;  INTEGER K;                                           07245100
  IF (B~(N>1023)) THEN PASS("(K~(##"); IF N=1023 THEN W~W-1;            07245200
  IF (K~CCT)=1 THEN SCRP ELSE BEGIN  CQPR2(PX[K]);                      07245300
    WHILE (K~(K-1))>1 DO BEGIN  GNC;                                    07245400
      IF CHAR="#" THEN BEGIN PNX; W~PX[K]|NHOLL+W END                   07245500
     ELSE BEGIN STACK("+"); CQPR2(PX[K]) END END;                       07245600
    GNC; IF CHAR="#" THEN BEGIN PNX; W~W+NHOLL END                      07245700
    ELSE BEGIN STACK("+"); CQPR2(PX[1]) END END;                        07245800
  IF W<0 THEN BEGIN STACK("-"); ZAHL(ABS(W)) END                        07245900
  ELSE IF W>0 THEN BEGIN STACK("+"); ZAHL(W) END;                       07245950
  IF B THEN PWFLD END;                                                  07245960
PROCEDURE SCPR3(N);    VALUE N;    INTEGER N;                           07246000
BEGIN SEGMENT;                                                          07246100
  IF N{1022 THEN SCRP                                                   07246200
  ELSE IF N=1023 THEN BEGIN SCRP; STACK("-"); ZAHL(1) END               07246300
  ELSE BEGIN PASS("(K~(##"); SCRP; PWFLD END END;                       07246400
PROCEDURE SCPR2(NH,N);    VALUE NH,N;    INTEGER NH,N;                  07247000
BEGIN SEGMENT;                                                          07248000
  IF N{1022 THEN ZAHL(NH) ELSE IF N=1023 THEN ZAHL(NH-1) ELSE BEGIN     07249000
    ZAHL(NH DIV 512); STACK(","); ZAHL(NH MOD 512) END END;             07250000
PROCEDURE SCPR1(N);    VALUE N;    INTEGER N;                           07251000
BEGIN SEGMENT;                                                          07252000
  GNC; IF CHAR="#" THEN BEGIN PNX; SCPR2(NHOLL,N) END ELSE SCPR3(N) END;07253000
PROCEDURE NCQPR;                                                        07254000
BEGIN INTEGER DM1,DM2,DM3;                                              07255000
  IF CCT=1 THEN SCPR1(D[1])                                             07256000
  ELSE IF CCT=2 THEN BEGIN                                              07257000
  IF NOT ISSW THEN BEGIN                                                07257500
    DM1~D[1]; SCPR1(D[2]); STACK(","); SCPR1(DM1) END                   07258000
    ELSE BEGIN DM2~D[2]; SCPR1(D[1]); STACK(","); SCPR1(DM2) END END    07258500
  ELSE BEGIN DM2~D[2]; IF ISSW THEN BEGIN DM3~D[3];                     07259000
    SCPR1(D[1]); STACK(","); SCPR1(DM2); STACK(","); SCPR1(DM3)END ELSE 07260000
    BEGIN DM1~D[1];                                                     07260500
    SCPR1(D[3]); STACK(","); SCPR1(DM2); STACK(","); SCPR1(DM1) END END;07261000
 END;                                                                   07261100
PROCEDURE CQPR;                                                         07261200
BEGIN  LABEL L1,XIT;  INTEGER K,WEIGHT;  INTEGER ARRAY PX[0:3];         07261300
  PX[1]~1; PX[3]~(PX[2]~D[1])|D[2]; WEIGHT~BASE;                        07261400
  K~CCT; WHILE K>1 DO BEGIN WEIGHT~WEIGHT-PX[K]; K~K-1 END;             07261450
  DO BEGIN  GNC;                                                        07261500
    IF CHAR="#" THEN BEGIN PNX; WEIGHT~WEIGHT+PX[CCT]|NHOLL; CCT~CCT-1  07261600
    END                                                                 07261650
    ELSE GO TO L1 END UNTIL CCT{0;                                      07261700
  SCPR2(WEIGHT,CNAME); GO TO XIT;                                       07261800
L1: CQPR1(PX,WEIGHT,CNAME); XIT: END;                                   07261900
PROCEDURE PRLK4;                                                        07262000
BEGIN SEGMENT;                                                          07263000
  SVQ; IF PFXSW THEN BEGIN STACK("S"); STACK("V") END;                  07264000
    NDUMP; IF RS THEN STACKQ; STACK("[");                               07264500
  IF (CB AND NOT GDSW) OR EB THEN CQPR ELSE NCQPR; STACK("]") END;      07265000
PROCEDURE ARTHP;                                                        07266000
BEGIN  LABEL LK1,LK2,LX,LZ;  INTEGER J,K,NX;                            07267000
LK1:  NX~0; DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)>9;                     07270000
  IF NX>1 THEN BEGIN LK2:                                               07273000
    IF CHAR="." THEN DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)>9;            07276000
    IF CHAR="@" THEN BEGIN GNC;                                         07279000
      IF (WHOLD[NX~(NX+1)]~CHAR){9 OR CHAR="+" OR CHAR="-"              07282000
      THEN DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)>9 END;                  07285000
    SECURE(NX); J~1; DO STACK(WHOLD[J]) UNTIL (J~(J+1))}NX END          07288000
  ELSE IF CHAR="%" THEN BEGIN SCAN;                                     07291000
    IF CHAR="[" THEN BEGIN  LOOKUP(NOM);                                07294000
      IF FLB THEN BEGIN  SECURE(8);                                     07297000
        PASS("BOOLEA"); STACK("N"); STACK("("); PRLK4; STACK(")") END   07300000
      ELSE PRLK4;                                                       07303000
      GO TO LK1 END;                                                    07306000
    SECURE(FWCT+7); TBSCH; IF PFXSW THEN BEGIN                          07309000
      STACK("S"); STACK("V") END; NDUMP; IF RS THEN STACKQ; SVQ;        07310000
    IF CQSW THEN IF BASE!0 OR CCT>1 OR LENGTH>1022 THEN BEGIN           07312000
      STASH("["); STASH("#"); STASH("]") END END                        07315000
  ELSE IF CHAR="J" THEN BEGIN SCAN; PROC1(NOM) END                      07318000
  ELSE IF CHAR="Z" THEN BEGIN                                           07321000
    SCAN; LOOKUP(NOM); PFX(LCLASS); NDUMP; IF RS THEN STACKQ END        07324000
  ELSE IF ALFA[CHAR] THEN BEGIN                                         07327000
    NX~CHAR; SCAN; SECURE(FWCT+2); STACK(NX); NDUMP;                    07330000
      IF NX="B" AND NOM="EGIN##" THEN BEGIN                             07333000
        LJSTCT~MIN(SPCT~(SPCT+2),14); GO TO LX END;                     07336000
      IF NX="T" AND NOM="HEN###" THEN BEGIN                             07339000
        STACK(" "); GO TO LZ END;                                       07342000
      IF NX="E" AND NOM="ND####" THEN LJSTCT~MAX(SPCT~(SPCT-2),0)       07345000
      ELSE IF NX="T" AND NOM="O#####" THEN BEGIN                        07351000
        STASH(" "); GNC; SECURE(8);                                     07354000
        IF CHAR="&" THEN BEGIN PNX; LMASK(NHOLL) END                    07357000
        ELSE BEGIN STACK(CHAR); SCAN; NDUMP END END END                 07360000
  ELSE IF CHAR=""" THEN BEGIN                                           07363000
    NX~0; DO GNC UNTIL (WHOLD[NX~(NX+1)]~CHAR)=""";                     07366000
    SECURE(NX+1); STACK(""");                                           07369000
    J~1; DO STACK(WHOLD[J]) UNTIL (J~(J+1))>NX;                         07372000
    GNC END;                                                            07375000
  IF CHAR="." OR CHAR="@" THEN BEGIN WHOLD[NX~1]~CHAR; GO TO LK2 END;   07378000
  IF CHAR!";" THEN BEGIN STASH(CHAR); GO TO LK1 END;                    07381000
  IF RPSW THEN BEGIN STACK(")"); RPSW~FALSE END;                        07384000
  STACK(";"); LX: LJUST; MARGIN; LZ: END;                               07387000
PROCEDURE ASGNSV;                                                       07387500
BEGIN SEGMENT;                                                          07387510
  SCAN;  LOOKUP(NOM); RPSW~FLB; PRLK4; GNC; STACK(CHAR);                07387520
  IF RPSW THEN PASS("REAL(#"); ARTHP; RPSW~FALSE END;                   07387530
PROCEDURE ASGNJ;                                                        07387600
BEGIN SEGMENT;                                                          07387610
  LOOKUP((IF FWCT}7 THEN NOM1.CX1 ELSE "#")&NOM[M5L]);                  07387620
   IF PFXSW THEN STACK("J"); PASS(NOM); IF RS THEN STACKQ; STACK(CHAR); 07387630
  IF (RPSW~FLB) THEN PASS("REAL(#");                                    07387635
  ARTHP; RPSW~FALSE END;                                                07387640
PROCEDURE BLDATA;                                                       07388000
BEGIN  INTEGER DRPMAX,K1,K2;                                            07388100
  IF NOT BLKDSW THEN BEGIN                                              07388150
  PASS("IF B##"); ZAHL(DATACT); PASS(" THEN "); PASS("BEGIN "); LJUST;  07388200
  STACK("B"); ZAHL(DATACT); PASS("~FALSE"); ZSEMI;                      07388250
  END;                                                                  07388275
  IF BOXDC>0 AND BOXDV>0 THEN BEGIN  K2~ADR[BOXDC];  K1~ADR[BOXDV];     07388300
    BWX~FALSE;                                                          07388305
    DO BEGIN                                                            07388310
      PNT~K2; K2~ADR[INEXT]; DRPMAX~BASE; DRPZ~ADDRESS;                 07388320
      DO BEGIN POSIT(1); ARTHP END UNTIL DRPZ}DRPMAX;                   07388330
      PNT~K1; K1~ADR[INEXT]; DRPMAX~BASE; DRPZ~ADDRESS;                 07388340
      DO BEGIN  SCAN; POSIT(1);                                         07388345
        IF CHAR="%" THEN ASGNSV ELSE IF NOM.CX1="J" THEN ASGNJ          07388350
        ELSE BEGIN NDUMP; STACK(CHAR); ARTHP END END                    07388355
      UNTIL DRPZ}DRPMAX END UNTIL K1{0 OR K2{0 END                      07388360
  ELSE BEGIN                                                            07388370
    ZCMNT; PASS("NO DAT"); PASS("A STAT"); PASS("EMENTS"); ZSEMI END;   07388380
    NOM~PNAME; TBSCH;                                                   07388390
  IF FCNSW THEN BEGIN  PNT~ADR[BOXP];                                   07388400
    IF PFXSW THEN STACK("J"); PASS(PNAME); IF RS THEN STACKQ;           07388500
      STACK("~");                                                       07388550
    IF MODE=BOO THEN PASS("FALSE#") ELSE ZAHL(0); ZSEMI END;            07388600
                                                                        07388800
                                                                        07388900
  IF NOT BLKDSW THEN BEGIN PASS("END###"); ZSEMI END; BWX~TRUE END;     07388960
PROCEDURE IDRPL;                                                        07390000
BEGIN LABEL ID1,ID2,XIT,NC,CMNT,SKIP; BOOLEAN B;                        07393000
  INTEGER I,J,JLST,K,L,N,NTMP,KS;                                       07394000
  INTEGER ARRAY ARGZ[0:63];                                             07396000
BWX~FALSE; JLST~LJSTCT~SPCT~0;                                          07399000
RPSW ~ FALSE;                                                           07400000
WHILE (JLST~(JLST+1)){LISTCT DO BEGIN                                   07402000
  DRPZ~LSTX[JLST].AX3;                                                  07405000
  PASS("LIST##"); STACK(" "); PASS("LIST##"); ZAHL(JLST);               07408000
  STACK("("); ARTHP END;                                                07411000
LDECL;   %  DECLARE LABELS PRIOR TO MONITOR AND DUMP STATEMENTS;        07414000
  IF BOXMD>0 THEN BEGIN  K~PNT~ADR[BOXMD];                              07417000
    DO BEGIN  DRPZ~ADDRESS;                                             07420000
      IF (L~MDFLAG)="D" THEN PASS("DUMP##")                             07423000
      ELSE BEGIN PASS("MONITO"); STACK("R") END; STACK(" ");            07426000
      DO BEGIN                                                          07429000
        SCAN; NDUMP; STACK(CHAR);                                       07432000
        IF CHAR="[" THEN BEGIN GNC;                                     07435000
          SCAN; PROC1(NOM); STACK(CHAR); GNC; STACK (CHAR) END;         07438000
        DO BEGIN SCAN;                                                  07441000
          IF CHAR="&" THEN BEGIN LBSW~TRUE; PNX; LOOKUP(NHOLL);         07444000
            ZAHL(IF BOOLEAN(JUMP) THEN CIBLE ELSE NHOLL) END            07447000
          ELSE IF CHAR="%" THEN BEGIN SCAN; PRLK4; GNC END              07450000
          ELSE BEGIN  LOOKUP(NOM);                                      07453000
            IF QUERY(NOM,ASNVAR) THEN PASS("ASV###")                    07456000
            ELSE IF TBSW THEN BEGIN                                     07459000
              IF (I~LCLASS){SV OR I=SR THEN PFX(I) ELSE FDECL(FTYPE) END07462000
            ELSE IF PFXSW THEN STACK("J"); NDUMP; IF RS THEN STACKQ END;07465000
          STACK(CHAR) END UNTIL CHAR!",";                               07468000
        IF L="M" THEN GNC                                               07471000
        ELSE BEGIN PNX; LMASK(NHOLL); STACK(":"); SCAN; NDUMP END;      07474000
        STACK(CHAR) END UNTIL CHAR!",";                                 07477000
      LJUST; PNT~K; K~PNT~ADR[INEXT] END UNTIL K{0 END;                 07480000
BWX~TRUE; KX~DRPX~-1;                                                   07483000
IF DFCT=0 AND DATASW THEN BLDATA;      %  INITIALIZE DATA;              07484000
ID1:  IF DRPX}FLGX THEN GO TO XIT;                                      07486000
  SCAN;                                                                 07489000
ID2: IF FWCT{0 THEN BEGIN                                               07492000
    IF CHAR="%" THEN ASGNSV                                             07495000
    ELSE IF CHAR="&" THEN BEGIN  PNX; LOOKUP(NHOLL);                    07504000
      IF BOOLEAN(GOAL) AND NOT BOOLEAN(JUMP) THEN BEGIN                 07507000
        STACK("L"); ZAHL(NHOLL); STACK(":"); STACK(" ") END END;        07510000
    GO TO ID1 END;                                                      07513000
  IF CHAR="$" AND NOM.CX1="B" THEN BEGIN BETEST~TRUE; SCAN END;         07515000
  IF CHAR="$" THEN IF FWCT=1 THEN BEGIN                                 07516000
    IF (K~KS~NOM.CX1)="W" AND BETEST THEN BEGIN INDENT; PASS("BEGIN ")  07518000
    END;                                                                07518500
      IF K="W" OR K="R" THEN BEGIN                                      07519000
      N~KX; PASS(IF K="W" THEN "WRITE(" ELSE "READ(#"); SCAN; NDUMP;    07522000
      IF CHAR="[" THEN BEGIN GNC;                                       07525000
        STACK("["); SCAN; PROC1(NOM); STACK("]"); GNC END;              07528000
      K~KX; GNC;                                                        07531000
      IF CHAR="*" THEN BEGIN STACK(","); STACK("*"); GNC END            07534000
      ELSE IF CHAR="O" THEN BEGIN STACK(","); STACK("O"); SCAN; NDUMP;  07535000
        END                                                             07536000
      ELSE IF CHAR="$" THEN BEGIN SCAN; NDUMP END                       07537000
      ELSE BEGIN  PNX; LOOKUP(I~NHOLL);                                 07540000
        IF BOOLEAN(F) AND PRESENT AND OK                                07543000
        THEN IF BOOLEAN(J~CCTRL) OR (L~CCHAR)!0 THEN BEGIN              07546000
            IF L=" " THEN IF BOOLEAN(J) THEN NOTHING ELSE               07547000
              GO TO SKIP ELSE                                           07548000
            IF L=0 THEN PASS("[DBL]#")                                  07549000
            ELSE IF L=1 THEN PASS("[PAGE]")                             07552000
            ELSE IF L="+" THEN BEGIN IF BOOLEAN(J) THEN BEGIN KX~-1;    07555000
              WHILE KX{K DO OUTB[KX~(KX+1)]~" "; KX~-1; GO TO ID1 END   07556000
              ELSE BEGIN PASS("[NO]##"); GO TO NC END END               07557000
            ELSE BEGIN STACK("["); STACK(L); STACK("]") END;            07558000
            STACK(")"); IF BOOLEAN(J) THEN BEGIN IF BETEST THEN         07559000
              PASS(" END##"); BETEST~FALSE END;                         07560000
            ZSEMI; MARGIN;                                              07561000
            IF BOOLEAN(J) THEN GO TO ID1 END;                           07564000
  SKIP:                                                                 07566000
      POSIT(N); KX~K; NC: STACK(","); STACK("F"); STACK("L"); ZAHL(I)   07567000
        END;                                                            07567500
      STACK(CHAR);                                                      07570000
      IF CHAR!")" THEN BEGIN SCAN; NDUMP; STACK(")") END;               07573000
    IF KS="R" THEN BEGIN PASS("[FINIS"); STACK("]") END                 07575000
    ELSE IF BETEST THEN PASS(" END##"); BETEST~FALSE;                   07575500
      ZSEMI; MARGIN; GO TO ID1 END;                                     07576000
    IF K="C" THEN BEGIN                                                 07579000
      ZCMNT; CMNT: GNC; WHILE CHAR!12 DO BEGIN STACKC(CHAR); GNC END;   07582000
                  SCAN;IF NOM="C#####" AND CHAR="$" THEN BEGIN          07582500
        STACKC(" "); LJUST; MARGIN;                                     07582700
        GO TO CMNT END ELSE                                             07583000
      STASH(";"); LJUST; MARGIN; GO TO ID2 END;                         07585000
    IF K="A" THEN BEGIN                                                 07585500
      GNC; WHILE CHAR!12 DO BEGIN STASH(CHAR); GNC;                     07586000
        IF CHAR!12 AND NOT ALFAN(CHAR) AND KX>60 THEN INDENT END;       07586500
      LJUST; MARGIN; GO TO ID1 END;                                     07587000
    IF K="X" THEN BEGIN                                                 07588000
      ZCMNT; PASS("SEE LI"); STACK("N"); STACK("E");                    07591000
      SCAN;                                                             07594000
      IF CHAR="," THEN BEGIN                                            07597000
        STACK("S"); STACK(" "); NDUMP; STACK(" ");                      07600000
        PASS("THROUG"); STACK("H"); SCAN END;                           07603000
      STACK(" "); NDUMP; STACK(" ");                                    07606000
      PASS("OF FOR"); PASS("TRAN L"); PASS("ISTING");                   07609000
      ZSEMI; MARGIN; GO TO ID1 END;                                     07612000
    IF K="E" THEN BEGIN                                                 07615000
      IF FCNSW THEN BEGIN                                               07618000
        NOM~PNAME; TBSCH; IF PFXSW       THEN BEGIN                     07621000
          IF PFXSW THEN BEGIN STACK("F"); STACK("N") END;               07621300
          PASS(PNAME); IF RS THEN STACKQ; STACK("~");                   07621500
          IF PFXSW THEN STACK("J"); PASS(PNAME);                        07621700
          IF RS THEN STACKQ END END;                                    07622000
      PASS(" END##");                                                   07624000
      IF BGNSW THEN PASS(" END##");                                     07627000
      ZSEMI; GO TO XIT END;                                             07630000
    IF K="D" THEN BEGIN                                                 07633000
      SCAN; LOOKUP(K~NOM); NTMP~ARGL; MDECL(MODE);                      07636000
      PASS("PROCED"); PASS("URE ##"); IF PFXSW THEN BEGIN               07639000
        STACK("D"); STACK("F") END; NDUMP; IF RS THEN STACKQ;           07639500
        STACK("("); L~0;                                                07640000
      DO BEGIN                                                          07642000
        SCAN; SECURE(FWCT+4); ARGZ[L~(L+1)]~NOM; PFX(DA); NDUMP;        07645000
        STACK(CHAR) END UNTIL CHAR!","; ZSEMI;                          07648000
      B~FALSE; J~1;                                                     07651000
      DO BEGIN  PNT~NTMP+J;  IF NOT ALTERED THEN BEGIN                  07652000
        IF B THEN BEGIN SECURE(10); STACK(",") END                      07654000
        ELSE BEGIN B~TRUE; PASS("VALUE ") END;                          07657000
        PFX(DA); PASS(ARGZ[J]) END END UNTIL (J~(J+1))>L;               07660000
      IF B THEN ZSEMI;                                                  07662000
      FOR N~FXP,FLP,BOO DO BEGIN                                        07663000
        J~1; B~FALSE;                                                   07666000
        DO BEGIN  PNT~NTMP+J;  IF MODE=N THEN BEGIN                     07669000
          IF B THEN BEGIN SECURE(10); STACK(",") END                    07672000
          ELSE BEGIN B~TRUE; MDECL(N) END;                              07675000
          PFX(DA); PASS(ARGZ[J]) END END UNTIL (J~(J+1))>L;             07678000
        IF B THEN ZSEMI END;                                            07681000
      LOOKUP(K);                                                        07683000
      FDECL(DF); PASS(K); IF RS THEN STACKQ; STACK("~"); ARTHP;         07684000
      IF DATASW AND (DFCT~(DFCT-1)){0 THEN BLDATA;                      07685000
      GO TO ID1 END END;                                                07686000
  IF NOM.CX1="J" THEN BEGIN ASGNJ; GO TO ID1 END;                       07687000
  IF NOM="END###" THEN LJSTCT~MAX(SPCT~(SPCT-2),0); NDUMP; STACK(CHAR); 07702000
  IF CHAR=";" THEN BEGIN LJUST; MARGIN; GO TO ID1 END;                  07705000
  ARTHP; GO TO ID1;                                                     07708000
XIT: LJUST END;    COMMENT  END OF IDRPL;                               07711000
  RNIT2; IF T2SW THEN EQRLCO; CDECL; LOCDEC; FMTHD; IDRPL;              07712000
                                                                        07713000
                                                                        07714000
                                                                        07715000
                                                                        07716000
                                                                        07716100
                                                                        07716200
                                                                        07716300
                                                                        07716400
                                                                        07716410
                                                                        07716420
                                                                        07716430
                                                                        07716440
                                                                        07716500
                                                                        07716510
                                                                        07716600
                                                                        07716700
                                                                        07716800
HEADSW~TRUE; KX~RSVX~FLGX~-1 END;                                       07717000
RESCAN;                                                                 07720000
IF NOM="END###" AND CHAR=" " THEN BEGIN  IPHASE~1; HEADER; HEADSW~FALSE;07723000
  TPOSIT~0;                                                             07724000
  DO BEGIN OPEN; RESCAN END UNTIL NOM!"END###" OR CHAR!" " END;         07726000
END UNTIL CHAR="$" AND (NOM="START#" OR NOM="LAST##"                    07729000
  OR NOM ="FINISH");                                                    07730000
STPH3:  %  *****************      PH3      ******************           07732000
BEGIN  INTEGER J;  DEFINE STACK=STACK2#, PASS=PASS2#;                   07735000
PROCEDURE BLSET(A,X);    VALUE X;    INTEGER X;    INTEGER ARRAY A[0];  07738000
IF A[0]>0 THEN                                                          07739000
BEGIN                                                                   07741000
  J~1; DO BEGIN                                                         07744000
    INDENT; PASS(X); STACK("["); ZAHL2(J); STACK("]"); STACK("~");      07747000
    IF BOOLEAN(A[J]) THEN PASS("TRUE;#") ELSE PASS("FALSE;");           07750000
    LJUST END UNTIL (J~(J+1))>A[0] END;                                 07753000
COMMENT  OUTPUT OUTER CALLING SEQUENCE;                                 07756000
  LJSTCT~0; IPHASE~2; HEADER;                                           07759000
  ZCMNT; PASS("INITIA"); PASS("LIZING"); PASS(" BLOCK"); ZSEMI;         07762000
  PASS("  XPR~"); PASS("Q~K~0;"); LJUST;                                07765000
  BLSET(SENSW,"SENSW#"); BLSET(SENSL,"SENSL#");                         07768000
  J~0; WHILE (J~(J+1)){DATACT DO BEGIN                                  07768100
    STACK("B"); ZAHL2(J); PASS("~TRUE;"); LJUST END;                    07768200
  J~0; WHILE (J~(J+1)){BLKDCT DO BEGIN                                  07768300
    PASS("BLOCK#"); PASS("DATA##"); ZAHL2(J); ZSEMI END;                07768400
PASS("MAINPR");PASS("O; FIN"); PASS("IS:   ");                          07771000
LJUST;ACOUNT~   99998; PASS("END.##");                                  07772000
LJUST END OF PH3; COMMENT PATCHED TO MAKE END. CARD SEQ NO 99999997;    07774000
  REPEATSW~TRUE;                                                        07775000
  RESCAN END UNTIL NOM="LAST##";                                        07777000
AUS: IF RR5=10 THEN LOCK(FORFIL); WSET END END.                         99999998
END;END.        LAST CARD ON 0CRDING TAPE                               99999999
LJUST END OF PH3; COMMENT PATCHED TO MAKE END. CARD SEQ NO 99999997;    07774000
  REPEATSW~TRUE;                                                        07775000
