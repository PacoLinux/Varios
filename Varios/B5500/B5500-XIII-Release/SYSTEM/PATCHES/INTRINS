$#PATCH NUMBER 1  FOR INTRINSICS.XII CONTAINS 3 CARDS                        &&&
%        I N T R I N S I C S      M A R K    X I I . 1     02/15/71     00000000
$VOID 00611301                                                          00611300
                        1                                               99998100
$#PATCH NUMBER  2 FOR INTRINSICS.XII   CONTAINS   4 CARDS           I
%        I N T R I N S I C S      M A R K    X I I .10     04/15/71     00000000
        PUNCH           = UNITYPE=6#,  % UNIT IS CARD PUNCH    %TR 830 I02710150
                        IF PUNCH THEN FIB[16].[32:1] ~ CHNNL;  %TR 830 I02734150
                        10                                              99998100
$#PATCH NUMBER  3  FOR INTRINSICS.XII CONTAINS  1 CARDS           C
              IF WH1=0 AND WH2=0 THEN EXP~-1 ELSE FINDE ;               02952000
$#PATCH NUMBER 4 FOR  INTRINSICS.XII   CONTAINS  41 CARDS           I
              SEQ,                 % TRUE IFF FILE HAS SEQ NUMBERS.     09202450
              READREC,             % TRUE IFF SCANNER MAY READ A RECORD 09202460
              BYE,                                                      09204850
              SCNR,                                                     09204860
              BSIZE~(P(MKS,DKADR,1,FILX,ALGOLREAD)-SEQ)|8 ;             09207700
$VOID 09208652                                                          09208401
    SUBROUTINE SCANNER ;                                                09212600
         IF (CHAR~POLISH)<0 THEN                                        09214200
              IF BSIZE=0 THEN                                           09214250
                   BEGIN                                                09214275
                   IF GOTDIGIT THEN CHAR~","                            09214300
                   ELSE IF READREC THEN GO LOOK                         09214350
                   END                                                  09214355
              ELSE GO LOOK ;                                            09214360
                                                                        09214460
    SUBROUTINE SCAN ;                                                   09214465
SCNR:    BEGIN SCANNER ;                                                09214470
         IF CHAR="/" THEN                                               09214475
              BEGIN READREC~0 ;                                         09214480
              WHILE CHAR!"=" AND BSIZE>0 DO SCANNER;  READREC~1 ;       09214485
              IF BSIZE=0 AND GOTDIGIT THEN CHAR~"," ELSE GO SCNR ;      09214487
              END ;                                                     09214490
         END OF SCAN ;                                                  09214495
              DECADES~DECADES+COUNTER ;                                 09214546
              IF DBLTOG THEN P(0,POT[COUNTER],DLM,0,NUMBER,DLA)         09214547
              ELSE P(POT[COUNTER],|,NUMBER,+) ;                         09214550
BYE:     IF (DONE~CHAR="*") THEN READIT ;                               09215400
         BUILDNUMBER ;                                                  09216000
              BUILDNUMBER ;                                             09216500
         IF NUMBER!0 THEN                                               09218000
              IF DBLTOG THEN P(POT[69+ABS(NUMBER)],POT[ABS(NUMBER)],    09218025
                               IF NUMBER<0 THEN P(DLD) ELSE P(DLM))     09218050
              ELSE P(POT[ABS(NUMBER)],IF NUMBER<0 THEN P(/) ELSE P(|)) ;09218100
$VOID 09218611                                                          09218610
         DO BEGIN SCANNER ;                                             09220200
         BEGIN SCANNER;  IF CHAR=""" THEN GO GETCOMMA ;                 09221500
         WHILE CHAR!"," AND CHAR!"*" DO SCAN;  IF CHAR="*" THEN GO BYE ;09222100
         BSIZE~BSIZE-(SEQ~(SEQ~(*(4 INX *[FIB[14]])).[36:6])!0 AND SEQ!809224710
                                                          AND SEQ!9)|8 ;09224720
         LSTRN~READREC~1 ;                                              09224800
$VOID 09225201                                                          09225200
$#PATCH NUMBER 5 FOR  INTRINSICS.XII   CONTAINS  323 CARDS          C
PROCEDURE FBINBACKBLOCK(F1,D,F2,F3,L,E1,E2,P1);  VALUE D,F2,L,E1,E2,P1 ;00022296
REAL D,F2,L,E1,E2,P1;  ARRAY F3[*];  NAME F1;  FORWARD;  % INT # @160.  00022297
PROCEDURE FBINBACKBLOCK(FILX,DKADDR,FI,FMT,LISX,EDITCODE,EOFL,PARL) ;   02767050
VALUE DKADDR,FI,LISX,EDITCODE,EOFL,PARL ;   % INT # @160.               02767100
REAL DKADDR,FI,LISX,EDITCODE,EOFL,PARL;  ARRAY FMT[*];  NAME FILX ;     02767150
    BEGIN                                                               02767200
                                                                        02767250
    INTEGER BSIZE, LSTRN=19 ;                                           02767300
                                                                        02767350
    REAL LISTYPE=20, ARRAYSTUFF=18, ALGOLWRITE=12, ALGOLREAD=13,        02767400
         SELECT=14, FORTERR=24, ARY, TYPE, DBLPREC=20, INDX=EOFL,       02767450
         OUT, FLG, IOINT, T1, T2, T3, T4, T5, TWDT, WH1=18, WH2=17,     02767500
         SIZE=PARL, INTINT=5, PRNTR, CKPBI, FMTWRD=CKPBI ;              02767550
                                                                        02767600
    NAME LISTADDR, ADDR ;                                               02767650
                                                                        02767700
    ARRAY AR1=LISTADDR[*], FIB[*], IOBUFF[*], TPAR=23[*] ;              02767750
                                                                        02767800
    LABEL ALIST, BLKDTA, SEVENS, ENDALL, AWAY, SPCL1, SPCL2, DSZ,       02767850
          CMPXL, DUBEL, LOGCL, STRNL, INTREL, BDERR, ENDIT, ERROR,      02767900
          BO, BI, BO1, BI1, BDERR1, BDERR2, BI2, MAX, LOOP, STRNL1,     02767950
          PRINTER, OUTL, BKSPC ;                                        02767975
                                                                        02768000
    SWITCH TYPL~INTREL, STRNL, INTREL, LOGCL, DUBEL, CMPXL ;            02768050
                                                                        02768100
    DEFINE DONE = LSTRN=(-1) #,                                         02768150
           NOTDONE = LSTRN!(-1) #,                                      02768200
           KIND = FIB[4].[8:4] #,                                       02768250
           TAPEF = 2 #,                                                 02768300
           REMOTEF = 13 #,                                              02768325
           DATACOMF = 10 #,                                             02768330
           INTEGR = 1 #,                                                02768350
           STRING = 2 #,                                                02768400
           REEL = 3 #,                                                  02768450
           LOGICAL = 4 #,                                               02768500
           DBLPRECSN = 5 #,                                             02768550
           COMPLEX = 6 #,                                               02768600
           TYPEF = [44:4] #,                                            02768650
           INDXF = [18:15] #,                                           02768700
           SIZEF = [33:15] # ;                                          02768750
                                                                        02768800
    SUBROUTINE BLANKIT ;                                                02768805
         BEGIN                                                          02768810
         STREAM(C~P(XCH),A~BSIZE-1,B~P(DUP).[36:6]:D~IOBUFF) ;          02768815
              BEGIN                                                     02768820
              SI~LOC A; 8(SI~SI-1; DS~CHR); SI~D; DS~A WDS ;            02768825
              B(DS~32WDS; DS~32WDS) ;                                   02768830
              END ;                                                     02768835
         P(DEL,DEL,DEL) ;                                               02768840
         END OF BLANKIT ;                                               02768845
                                                                        02768846
    SUBROUTINE CKPB ;                                                   02768850
         BEGIN                                                          02768900
         P(MKS,FLG,DKADDR);  IF OUT THEN P(0,(-1)) ELSE P(DEL,CKPBI) ;  02768950
         IF (BSIZE~P(FILX,IOINT))<0 THEN GO ENDIT ;                     02769000
         END OF CKPB ;                                                  02769050
                                                                        02769100
    SUBROUTINE IO ;                                                     02769700
         BEGIN P(0) ;                                                   02769750
ENDALL:  P(MKS,FLG,DKADDR);  IF OUT THEN P(0,BSIZE);  P(FILX,IOINT) ;   02769800
         IF P THEN                                                      02769850
ENDIT:        BEGIN FILX[NOT 3]~FILX[NOT 4]~0; P(XIT) END ;             02769900
         CKPB ;                                                         02769950
         END OF IO ;                                                    02770000
                                                                        02770050
    REAL SUBROUTINE NXTITM ;                                            02770100
         BEGIN                                                          02770150
         P(IF TWDT THEN P(*[AR1[INDX.[33:7]]],INDX AND 255,CDC)         02770200
           ELSE [AR1[INDX]]) ;                                          02770250
         INDX~INDX+1;  NXTITM~P ;                                       02770300
         END OF NXTITM ;                                                02770350
                                                                        02770400
    SUBROUTINE GETNEXTLISTITEM ;                                        02770450
         BEGIN                                                          02770500
         IF ARY THEN                                                    02770550
              BEGIN                                                     02770600
ALIST:        P(NXTITM) ;                                               02770650
              IF DBLPREC THEN IF OUT THEN WH2~*NXTITM ELSE INDX~INDX+1 ;02770700
              ARY~SIZE>INDX ;                                           02770750
              END                                                       02770800
         ELSE IF TYPE=COMPLEX THEN                                      02770850
                   BEGIN TYPE~-COMPLEX; P([LISTADDR[1]]) END            02770900
              ELSE BEGIN                                                02770950
                   P(ARRAYSTUFF~LISTYPE~0);  LISTADDR~[LISX] ;          02771000
                   DBLPREC~(TYPE~LISTYPE.TYPEF)=DBLPRECSN ;             02771050
                   IF ARY~ARRAYSTUFF!0 THEN                             02771100
                        BEGIN                                           02771150
                        IF TYPE=COMPLEX THEN TYPE~-COMPLEX ;            02771200
                        SIZE~(INDX~ARRAYSTUFF.INDXF)+ARRAYSTUFF.SIZEF ; 02771250
                        P(LISTADDR~MEM[LISTADDR.[18:15]]) ;             02771300
                        TWDT~NOT P(LOD,TOP);  P(DEL) ;                  02771350
                        GO ALIST ;                                      02771400
                        END ;                                           02771500
                   P(DEL,[LISTADDR[0]]) ;                               02771550
                   IF DBLPREC THEN IF OUT THEN WH2~LISTADDR[1] ;        02771600
                   END ;                                                02771650
         IF OUT THEN WH1~*P ELSE ADDR~P ;                               02771700
         END OF GETNEXTLISTITEM ;                                       02771750
                                                                        02771800
    SUBROUTINE GETANDCHECK ;                                            02772050
         BEGIN                                                          02772100
         GETNEXTLISTITEM;  T1~T1-1 ;                                    02772150
         IF DONE THEN                                                   02772200
BDERR1:       BEGIN P(1) ;                                              02772250
BDERR:        T1~P;  P(MKS,T1,TYPE,T2,FLG,BSIZE,(-2),FORTERR) ;         02772425
              END ;                                                     02772950
         FLG~FLG+1 ;                                                    02772975
         END OF GETANDCHECK ;                                           02773000
                                                                        02773050
%************************:: CODE STARTS HERE ::************************%02773100
                                                                        02773150
    LSTRN~CKPBI~1 ;                                                     02773200
    IF EDITCODE=6 THEN                                                  02773250
         BEGIN % BLOCKDATA.                                             02773300
BLKDTA:  GETNEXTLISTITEM;  P((FMTWRD~FMT[FI~P+FI])=0) ;                 02773400
         T2~FMTWRD.[18:15];  BSIZE~(FMTWRD!0)+BSIZE ;                   02773425
         IF DONE THEN BEGIN IF NOT P THEN GO BDERR1; P(XIT) END ;       02773450
         FLG~FLG+1 ;                                                    02773475
         IF P THEN BEGIN P(2); GO BDERR END;  T1~FMTWRD.[33:15]-1 ;     02773500
         T3~FMT[FI~FI+1];  T4~FMT[FI+1] ;                               02773550
         GO TYPL[T2-1] ;                                                02773600
CMPXL:   IF ABS(TYPE)!COMPLEX THEN GO BDERR2;  ADDR[0]~T3 ;             02773650
         GETNEXTLISTITEM;  ADDR[0]~T4;  IF T1{0 THEN GO SPCL1 ;         02773700
         GETANDCHECK ;                                                  02773725
         GO CMPXL ;                                                     02773750
DUBEL:   IF NOT DBLPREC THEN GO BDERR2;  ADDR[0]~T3;  ADDR[1]~T4 ;      02773800
         IF T1 LEQ 0 THEN                                               02773850
SPCL1:        BEGIN P(2); GO BLKDTA END ;                               02773900
         GETANDCHECK ;                                                  02773950
         GO DUBEL ;                                                     02774000
LOGCL:   IF TYPE!LOGICAL THEN                                           02774050
BDERR2:       BEGIN P(3); GO BDERR END ;                                02774100
         ADDR[0]~T3;  IF T1 LEQ 0 THEN GO SPCL2;  GETANDCHECK ;         02774150
         GO LOGCL ;                                                     02774200
STRNL:   T4~FI;  T3~T1+1;  FMTWRD~FMTWRD.[3:15] ;                       02774220
STRNL1:  IF ABS(TYPE)=COMPLEX OR DBLPREC THEN GO BDERR2 ;               02774225
         ADDR[0]~FMT[FI] ;                                              02774230
         IF T1>0 THEN FI~FI+1                                           02774250
         ELSE BEGIN                                                     02774275
              IF (FMTWRD~FMTWRD-1){0 THEN GO SPCL2;  FI~T4;  T1~T3 ;    02774300
              END ;                                                     02774325
         GETANDCHECK ;                                                  02774350
         GO STRNL1 ;                                                    02774375
INTREL:  IF ABS(TYPE)=COMPLEX THEN GO BDERR2;  P(T3,[ADDR[0]]) ;        02774400
         IF TYPE=INTEGR OR TYPE=LOGICAL THEN                            02774410
              BEGIN                                                     02774420
              IF T3>P(MAX) THEN BEGIN P(4); GO BDERR END ;              02774430
              P(ISD) ;                                                  02774440
              END                                                       02774450
         ELSE P(~) ;                                                    02774460
         IF DBLPREC THEN ADDR[1]~0 ;                                    02774470
         IF T1 LEQ 0 THEN                                               02774480
SPCL2:        BEGIN P(1); GO BLKDTA END ;                               02774500
         GETANDCHECK ;                                                  02774550
         GO INTREL ;                                                    02774600
         END OF BLOCKDATA ;                                             02774650
    FIB~FILX[NOT 2];  FILX[NOT 3]~PARL;  FILX[NOT 4]~EOFL ;             02774700
    P(FIB[5]) ;                                                         02774750
    IF FI<0 THEN GO OUTL;  P(P.[43:2]!T1~(EDITCODE=5)+2,*P(.ALGOLREAD));02774800
    FLG~DKADDR;  GO DSZ ;                                               02774850
OUTL:                                                                   02774950
    OUT~1;  P(P.[43:1],*P(.ALGOLWRITE)) ;                               02775000
    IF FLG~DKADDR<0 THEN                                                02775050
DSZ:     DKADDR~0 ;                                                     02775100
    IOINT~P;  IF P THEN P(MKS,0,T1,FILX,1,SELECT) ;                     02775250
    IF EDITCODE=5 THEN                                                  02775300
         BEGIN % BACKSPACE.                                             02775350
         IF FIB[5].[41:2]!0 THEN GO ENDIT;  CKPBI~3;  CKPB;  IO ;       02775400
         IF NOT (FIB[FLG~0]!1 AND KIND=TAPEF) THEN GO ENDIT ;           02775450
BKSPC:   IF (*(*[FILX])).[3:15]!P(SEVENS) THEN BEGIN IO; GO BKSPC END ; 02775500
         IF (*(*[FILX])).[18:15]!P(SEVENS) THEN GO AWAY;  GO ENDIT ;    02775550
         END ;                                                          02775650
    T2~(FIB[5] AND 96)!0;  CKPB;  T4~(T1~KIND)=TAPEF;  CKPBI~3 ;        02775675
    IF PRNTR~T1=1 OR T1=7 OR T1=12 THEN                                 02775700
         BEGIN                                                          02775725
         IF T2 THEN BEGIN IOBUFF~TPAR; P(" "); BLANKIT END ;            02775730
         IF BSIZE>17 THEN BSIZE~17 ;                                    02775733
         END ;                                                          02775735
    IF FIB[0]=0 THEN FIB[0]~2;  T5~T1=REMOTEF OR T1=DATACOMF ;          02775740
    IF FIB[0]!2 AND T4 THEN                                             02775750
         BEGIN T1~4 ;                                                   02775800
ERROR:   P(MKS,FIB[6],FILX.[33:15],T1,FORTERR) ;                        02775850
         END ;                                                          02775900
    IF T4 AND NOT FIB[13].[24:1] THEN P(MKS,(-1),FORTERR) ;             02775925
    T3~P(SEVENS) ;                                                      02775950
    IF EDITCODE=0 THEN                                                  02776000
         BEGIN % NO FORMAT, NO LIST.                                    02776050
         IOBUFF~*FILX ;                                                 02776100
         IF OUT THEN                                                    02776150
              BEGIN                                                     02776200
              IF PRNTR THEN                                             02776205
                   BEGIN                                                02776210
PRINTER:           IF NOT T2 THEN FIB[17]~*P(DUP)+BSIZE ;               02776220
                   P(MKS,1,0,T2,BSIZE,FILX,ALGOLWRITE);  CKPB ;         02776225
                   FIB[17]~*P(DUP)-BSIZE ;                              02776230
                   STREAM(TPAR,BSIZE,S~*FILX) ;                         02776235
                        BEGIN                                           02776240
                        SI~TPAR; DS~BSIZE WDS; DI~TPAR; 18(DS~8LIT" ") ;02776245
                        END ;                                           02776250
                   GO ENDIT ;                                           02776255
                   END ;                                                02776280
              IF T5 THEN P(" ") ELSE P("0");  BLANKIT ;                 02776320
              IF T4 THEN IOBUFF[0]~(NOT 0)&(BSIZE-1)[33:33:15] ;        02776550
              END                                                       02776600
         ELSE IF T4 THEN GO BI2 ;                                       02776650
AWAY:    P(1);  GO ENDALL ;                                             02776700
         END ;                                                          02776750
    GETNEXTLISTITEM;  IF NOT OUT THEN GO BI ;                           02776800
BO: T1~T4;  IOBUFF~IF PRNTR THEN TPAR ELSE *FILX ;                      02776850
    IF T5 THEN BEGIN P(" "); BLANKIT END ;                              02776875
BO1:IOBUFF[T1]~WH1;  IF DBLPREC THEN IOBUFF[T1~T1+1]~WH2 ;              02776900
    GETNEXTLISTITEM ;                                                   02776950
    IF NOT (DONE OR (T1~T1+1)+DBLPREC}BSIZE) THEN GO BO1 ;              02777000
    IF PRNTR THEN GO PRINTER;  IF NOT T4 THEN GO AWAY ;                 02777050
    P((T1-1)&T3[3:33:15]) ;                                             02777100
    IF DONE THEN BEGIN P(SEVENS,CFX,[IOBUFF[0]],~); GO AWAY END ;       02777150
    P([IOBUFF[T3~0]],~) ;                                               02777200
    IO;  GO BO ;                                                        02777250
SEVENS:::@77777                                                         02777260
MAX:::   @7777777777777 ;                                               02777265
BI: IOBUFF~*FILX;  IF (T1~T4) THEN BSIZE~IOBUFF[0] AND T3 ;             02777300
BI1:ADDR[0]~IOBUFF[T1];  IF DBLPREC THEN ADDR[1]~IOBUFF[T1~T1+1] ;      02777350
    GETNEXTLISTITEM ;                                                   02777400
    IF NOT (DONE OR (T1~T1+1)+DBLPREC>BSIZE) THEN GO BI1 ;              02777450
    IF NOT T4 THEN GO AWAY ;                                            02777500
    IF DONE THEN                                                        02777550
         BEGIN                                                          02777600
BI2:     WHILE IOBUFF[0].[18:15]!T3 DO BEGIN IO; IOBUFF~*FILX END ;     02777650
         GO AWAY ;                                                      02777700
         END ;                                                          02777750
    IF IOBUFF[0].[18:15]=T3 THEN BEGIN T1~5; GO ERROR END ;             02777800
    IO;  GO BI ;                                                        02777850
    END OF FBINBACKBLOCK ;                                              02777950
          CC, GG, LL, FF, EE, II, DD, ERR3, TEST1, AWAY, JJ,            02780900
$VOID 02787251                                                          02787050
                        BEGIN TYPE~-COMPLEX; P([LISTADDR[1]]) END       02788000
                             IF TYPE=COMPLEX THEN TYPE~-COMPLEX ;       02788300
$VOID 02788601                                                          02788600
$VOID 02789201                                                          02789050
    IF (LSTRN~1)!FIB[0] AND FIB[4].[8:4]=2 THEN                         02789950
    T3~P(DEL);  T2~P ;                                                  02796800
    P(MKS,T2,T3,W,D,CODE,TYPE,CHR-T1,FIB[7],BUFF,COMMAS,DLRSGN,(-3),    02796850
      FORTERR) ;                                                        02796900
$VOID 02797401                                                          02796950
LABEL    TYPERR, FMCYC, FMERR, MON, FNOL, FMTLST, FRMTCD, NFPH,         02810300
$VOID 02810801                                                          02810700
$VOID 02812101                                                          02812050
IF EDITCODE!1 AND EDITCODE!3 THEN                                       02862210
    BEGIN P(MKS) ;                                                      02862220
    IF EDITCODE!6 THEN P(FILX,DKADR);  P(FI,FMTA,*P(.LISX)) ;           02862230
    IF EDITCODE=4 THEN P(EOFL,INTCALL(PARL,@154))                       02862250
    ELSE P(EDITCODE,EOFL,INTCALL(PARL,@160)) ;                          02862260
    P(XIT) ;                                                            02862270
    END ;                                                               02862300
$VOID 02862705                                                          02862702
$VOID 02862717                                                          02862716
IF EDITCODE=1 THEN GO FNOL;  GO FMTLST ;                                02862800
$VOID 02863801                                                          02862900
$VOID 02882501                                                          02864200
$VOID 02885701                                                          02885600
          FIVPT, JJ, RAPUP, X1, OVRFLW2, ONE ;                          02886840
$VOID 02888121                                                          02887960
$VOID 02890441                                                          02890440
    IF (LSTRN~1)!FIB[0] AND T1=2 THEN                                   02892640
IF EDITCODE=0 OR EDITCODE=2 OR EDITCODE=4 THEN                          02964405
    BEGIN                                                               02964410
    P(MKS,FILX,DKADR) ;                                                 02964415
    IF EDITCODE=4 THEN P(FI,FMTA,INTCALL(*P(.LISX),@155))               02964420
    ELSE P((-1),FMTA,*P(.LISX),EDITCODE,0,INTCALL(0,@160)) ;            02964425
    P(XIT) ;                                                            02964430
    END ;                                                               02964435
P(XIT) ;                                                                02965500
$VOID 02965601                                                          02965600
P(XIT) ;                                                                02971100
$VOID 02973001                                                          02971200
    IF (LSTRN~1)!FIB[0] AND T1=2                                        02978660
    THEN P(MKS,FIB[7],FILX.[33:15],4,FORTERR) ;                         02978661
    END GETFILE ;                                                       07902405
    REAL T1,T2,T3,T4,T5,E=-6,F=-7,G=-8,H=-9,I=-10,J=-11,K=-12 ;         07902410
    INTEGER IT2=T2 ;                                                    07902415
    ARRAY TEN=22[*] ;                                                   07902417
    LABEL LOOP, ALFA ;                                                  07902420
    REAL SUBROUTINE SIZ ;                                               07902425
         BEGIN                                                          07902430
         TEN[T3]~TEN[68];  T1~0 ;                                       07902435
LOOP:    IF TEN[T1~T1+1] LSS T2 THEN GO LOOP;  SIZ~T1 ;                 07902440
         END OF SIZ ;                                                   07902445
% * * * * * * * * * * * * * * PROGRAM STARTS * * * * * * * * * * * * * *07902447
    IF CODE=(-2) THEN                                                   07902450
         BEGIN T3~5;  T2~B ;                                            07902455
         STREAM(E,D,C,B,A,N3~P(ALFA),N1~SIZ,T2~T2~A,N2~SIZ,TPAR) ;      07902460
              BEGIN                                                     07902465
              DS~15LIT"-DATA STMT ERR#"; SI~LOC E; DS~DEC ;             07902470
              DS~4LIT",LT="; SI~LOC N3; SI~SI+D; DS~CHR ;               07902475
              DS~4LIT",DT="; SI~LOC N3; SI~SI+C; DS~CHR ;               07902480
              DS~3LIT",L="; SI~LOC B; DS~N1 DEC ;                       07902485
              DS~3LIT",D="; DS~N2 DEC; DS~2LIT":~" ;                    07902490
              END ;                                                     07902495
         GO WRAPUP ;                                                    07902500
         END ;                                                          07902505
    IF CODE=(-1) THEN                                                   07902510
         BEGIN                                                          07902515
         STREAM(TPAR); DS~33LIT"-MIXD UNFMT/ALPHA-MODE TAPE I/O:~" ;    07902520
         GO WRAPUP ;                                                    07902523
         END ;                                                          07902525
    IF CODE=(-3) THEN                                                   07902530
         BEGIN T3~4;  T2~I ;                                            07902535
         STREAM(J,K,I,F1~SIZ,D~T2~H,F2~SIZ,F3~G>10 AND 15>G,F,          07902540
                N3~P(ALFA),C1~IT2~E,C~SIZ,R1~IT2~D+1,R~SIZ,             07902545
                BUFF~C,B,A,TPAR) ;                                      07902550
              BEGIN                                                     07902555
              DS~11LIT"-DATA ERR #"; SI~LOC J; SI~SI+7; DS~CHR ;        07902560
              DS~3LIT",F="; A(DS~LIT"$"); B(DS~LIT"K"); SI~SI+7 ;       07902565
              DS~CHR; DS~F1 DEC; F3(DS~LIT"."; SI~LOC D; DS~F2 DEC) ;   07902570
              DS~3LIT",T="; SI~LOC N3; SI~SI+F; DS~CHR; DS~3LIT",C=" ;  07902575
              DS~C DEC; DS~3LIT",H="; SI~BUFF; SI~SI-1; DS~CHR ;        07902580
              DS~3LIT",R="; SI~LOC R1; DS~R DEC; DS~2LIT":~" ;          07902585
              END ;                                                     07902590
         GO WRAPUP ;                                                    07902595
ALFA:::  @2531625143242300 ;                                            07902600
         END ;                                                          07902605
              DS~26LIT"-MIXD FMT/UNFMT TAPE I/O:~" ;                    07906740
         IF FIB[0]!1 AND KIND=2 THEN                                    09224600
$#PATCH NUMBER  6 FOR INTRINSICS.XII   CONTAINS  2 CARDS            C
              IF INHEAD[(IRC ~ IRC + (IRC < 29))] ! 0                   00722700
                 THEN IDA ~ INHEAD[IRC];                                00722800
$#PATCH NUMBER   7 FOR INTRINSICS.XII    CONTAINS  2 CARDS          C
         IF NT > 2 THEN                                                 00761800
         IF NT > 2 THEN                                                 00768800
$#PATCH NUMBER  8 FOR INTRINSICS.XII    CONTAINS   8 CARDS          C
      INTEGER SPOUT;                                                    00101450
      SPOUT:=(I=5);                                                     00107820
      IF SPOUT THEN % SPO OUTPUT                                        00110910
$ OMIT 00110941, IF TIMESHARING;                                        00110939
         P(0,0,NOT,IOD,INX,15,COM,XIT)                                  00110940
$ INCLUDE 00110961, IF TIMESHARING;                                     00110959
         P(1,IOD,NUMWDS|8,1,0,11,SSN,COM,XIT)                           00110960
         ELSE                                                           00110990
$#PATCH NUMBER  9 FOR INTRINSICS.XII   CONTAINS  9 CARDS            C
    BOOLEAN   DATACOM;                                                  08503325
    BEGIN IF DATACOM THEN                                               08506800
    BEGIN P(MKS,1,0,0,BSIZE+((NOT DATACOM).[47:1]),FILX,ALGOLWRITE);    08507300
         IF NOT DATACOM THEN                                            08507310
    BEGIN;STREAM(A~BSIZE-1+DATACOM:D~*FILX);                            08507450
           IF DATACOM~FIB[4].[8:4]=10 OR FIB[4].[8:4]=13 THEN           08507850
              BSIZE ~ 9 ELSE                                            08507855
         DATACOM ~    FIB[4].[8:4] = 10 OR FIB[4].[8:4] = 13;           08519175
         IF DATACOM THEN CLEAR                                          08519350
$#PATCH NUMBER  10 FOR INTRINSICS.XII   CONTAINS  1866 CARDS        I
PROCEDURE COBOLDECIMALTOOCTALCONVERT(A); % INT #=@151, CODE=09300000    00022282
VALUE A;  NAME A;  FORWARD ;                                            00022283
PROCEDURE COBOLOCTOLTODECIMALCONVERT(A,L,H,R,N,S,T); % INT #=@152       00022284
VALUE L,H,R,N,S,T;  REAL L,H,R,N,S,T; NAME A; FORWARD; % CODE=09400000  00022285
PROCEDURE COBOLVARSZ;  FORWARD;%  CODE=09500000  INT #=@161             00022298
PROCEDURE COBOLIONONDSK;  FORWARD;%  CODE=09600000  INT #=@162          00022299
PROCEDURE COBOLIODSK;  FORWARD;%  CODE=09700000  INT #=@163             00022300
INTEGER PROCEDURE DELTA(P1,P2);  VALUE P1,P2;  REAL P1,P2;       %@036  00022310
         LABEL TY11,TY13,TY14,TY15,TY16,TY17,TY18,TY19;                 00403000
                   TY12,TY13,TY14,TY15,TY16,TY17,TY18,TY19;             00403200
         GO TO EXIT;                                                    00419900
 TY19::  % IMPLEMENTED FOR COBOL 68 ARRAY DECLARATION  1 OR 2 DIM       00420000
         A ~ *[PRTPOINTER[17]];                                         00420100
         FOR I ~ 1 STEP 1 UNTIL A[0] DO                                 00420110
              BEGIN                                                     00420120
              C ~ A[I];                                                 00420130
              P(MKS,[PRTPOINTER[C.[FF]]],                               00420140
                   P(DUP,LOD,P(DUP).[FF],P(XCH).[CF]),                  00420150
                   IF C.[17:1] THEN P(XCH,DEL) ELSE P,                  00420160
                   C.[16:2],1,C.[CF],RECURSE);                          00420170
              END;                                                      00420180
         P([PRTPOINTER[17]] INX M,3,COM,DEL);                           00420190
 EXIT::                                                                 00429900
END INTRINSIC INTRINSIC;                                                00430000
         NAME  WAIN = IPFIDX;  % COBOL68 INFILE WORK AREA               00706420
         NAME  WAOUT = T2;     % COBOL68 OUTFILE WORK AREA              00706520
              PERFORMGEN  =  13,    % COBOL68 IN-OUT PROCEDURES         00707510
           IF AC.[46:1] THEN         % COBOL68                          00716430
              BEGIN P(MKS,BINGO,0,PERFORMGEN);                          00716440
                    COIOD ~ [WAOUT];                                    00716445
                    WAOUT ~ *[OUTFIL];                                  00716450
              END ELSE                                                  00716460
              IF AC.[46:1] THEN             % COBOL68                   00717240
                   BEGIN  COIOD ~ [WAOUT];                              00717250
                          WAOUT ~ P(PRFIB[20].[FF],DIB 0,LOD);          00717260
                   END;                                                 00717270
              PRFIB[4].[7:1] ~ ((AC AND 3) = 1); %COBOL61 TAPE SORT FLG 00718900
              IF INHEAD[(IRC ~ IRC + (IRC < 29))] ! 0                   00722700
                 THEN IDA ~ INHEAD[IRC];                                00722800
              IF AC.[46:1] THEN P(MKS,BINGO,0,PERFORMGEN)  ELSE         00723980
               BEGIN  ENDQ ~ 0;  IF AC.[46:1] THEN                      00736800
                        P(MKS,BINGO,0,PERFORMGEN)    % COBOL68          00736850
                   ELSE P(MKS,BINGO,[PRTBASE[P(DUP)]],LOD,IPFIDX,COC)   00736900
              STREAM(P1~*[CIIOD],P2~R,P3~P(DUP).[36:6],                 00749400
                 ELSE IF AC THEN P(0,MKS,*[CIIOD],VL,EQUALS)            00751600
         STREAM(P1~*[CIIOD],P2~R,P3~P(DUP).[36:6],P4~*[DATX[VLOW]]);    00751900
         IF AC THEN IF CORESIZE.[1:1] THEN     % IDENTIFY COBOL68       00756610
              BEGIN  AC~3; CORESIZE~ABS(CORESIZE);                      00756620
                     BLKCTR ~ BLKCTR - 1;                               00756630
                     END;                                               00756650
         OUTFIB[4].[7:1] ~ ((AC AND 3) = 1);     %COBOL61 DISK SORT FLG 00761000
         IF NT > 2 THEN                                                 00761800
               IF(AC AND 3)=3 THEN        % COBOL68                     00763050
                   BEGIN  CIIOD ~ [WAIN];                               00763100
                          WAIN ~ *[INFIL];                              00763150
               END END ELSE                                             00763200
          IF AC THEN BEGIN P(MKS,(NOT 2) INX [INFIL],1,COFCR);          00763400
                     IF AC.[46:1] THEN      % COBOL68                   00763440
                        BEGIN CIIOD~[WAIN];  WAIN~P(*[INFIL[NOT 2]],    00763450
                                     20,COC,0,XCH,FCX,DIB 0,LOD);       00763460
                    END END ELSE BEGIN    % OPEN ALGOL INPUT FILE       00763500
         IF(AC AND 3)!3 THEN CIIOD ~ [INFIL];                           00764350
         IF NT > 2 THEN                                                 00768800
         OPENOUT;  IF(AC AND 3)!3 THEN COIOD ~ [OUTFIL];                00773000
               BEGIN  ENDQ ~ 1;  IF AC.[46:1] THEN                      00776200
                        P(MKS,BINGO,0,PERFORMGEN)    % COBOL68          00776250
                   ELSE P(MKS,BINGO,[PRTBASE[P(DUP)]],LOD,IPFIDX,COC)   00776300
               END ELSE P(MKS,1,0,0,OUTPRO);                            00776400
         NAME  WAOUT = T2;     % COBOL68 OUTFILE WORK AREA              00803120
              PERFORMGEN = 13,    % COBOL68 IN-OUT PROCEDURES           00803610
           IF AC.[46:1] THEN         % COBOL68                          00809730
              BEGIN P(MKS,BINGO,0,PERFORMGEN);                          00809740
                    COIOD ~ [WAOUT];                                    00809745
                    WAOUT ~ *[OUTFIL];                                  00809750
              END ELSE                                                  00809760
              IF AC.[46:1] THEN             % COBOL68                   00810440
                   BEGIN  COIOD ~ [WAOUT];                              00810450
                          WAOUT ~ P(PRFIB[20].[FF],DIB 0,LOD);          00810460
                   END;                                                 00810470
                 ELSE IF (AC AND 3) ! 3 THEN  % NOT COBOL68             00815900
                      V[VLOW] ~ (*P(DUP)) & (*[CIIOD])[CTC];            00815910
              IF AC THEN IF AC.[46:1] THEN P(MKS,BINGO,0,PERFORMGEN)    00817100
                   ELSE P(MKS,BINGO,[PRTBASE[P(DUP)]],LOD,IPFIDX,COC)   00817150
                 ELSE V[I]~NFLAG(P(TP[I+1])&(IF(AC AND 3)=3 THEN        00824300
                      P(2,NOT,XCH,INX,LOD,20,COC,0,XCH,FCX,DIB 0,LOD,I) 00824310
                      ELSE P(LOD,I))[CTF]);                             00824320
           OPENOUT;  IF(AC AND 3)!3 THEN COIOD ~ OUTFIL;                00824500
           STPP ~ 2 | MS - 2;                                           00824550
         IF FM THEN                                                     00828200
              BEGIN OPENOUT; IF(AC AND 3)!3 THEN COIOD ~ OUTFIL END     00828250
               BEGIN  ENDQ ~ 1;  IF AC.[46:1] THEN                      00833800
                        P(MKS,BINGO,0,PERFORMGEN)    % COBOL68          00833850
                   ELSE P(MKS,BINGO,[PRTBASE[P(DUP)]],LOD,IPFIDX,COC)   00833900
               END ELSE P(MKS,1,0,0,OUTPRO);                            00834000
PROCEDURE COBOLFCR;                                                     02600000
    BEGIN                                                               02600100
         REAL CODE      =-1;      % 0=INVALID,1=OPEN INPUT,2=OPEN REV IN02600110
                                  % 3=OPEN OUT,4=CLOSE,5=OPEN I-O,6=SORT02600120
                                  % 7=CLOSE CRUNCH,16=OPEN1,17=CLOSE1   02600200
         NAME FLOC      =-2;      % POINTER TO FIB DESCRIPTOR           02600300
         REAL MKSCW     =-3;      % = MKSCW :NO REEL,= 1 FOR REEL CLOSE 02600400
                                  % = REEL # FOR REEL OPEN.             02600410
         REAL CLOSELOCK =-4;      % HOW TO CLOSE THE FILE               02600420
                                  %   0 = REWIND (RETAIN)               02600430
                                  %   1 = NO REWIND (RETAIN)            02600450
                                  %   2 = LOCK (SAVE)                   02600470
                                  %   4 = PURGE  LOCK (RELEASE + PURGE) 02600480
                                  %   6 = RELEASE LOCK (RELEASE + LOCK) 02600500
                                  %   7 = RELEASE (LOOK AT SAVE FACTOR) 02600510
                                  %  64 = CRUNCH                        02600515
    % PRT DESCRIPTORS                                                   02600600
         REAL COBOLCONTROL =23,   % COBOL 61: FOR CALLING USE ROUTINES  02600650
              COBOLINDEX   =22,   % COBOL 61: FOR CALLING USE ROUTINES  02600700
              COBOLIO      =14,   % COBOL READ WRITE                    02600800
              FCR          =12,   % COBOL FCR                           02600900
              PERFORMGEN   =13;   % COBOL 68: FOR PERFORMING USE ROUTNS 02600990
        REAL INTINT        =5;    % ARRAY DEC INTRINSIC                 02600994
        NAME  MEM          =2;    % DUMMY DATA DESCRIPTOR               02600995
        ARRAY FPB          =3[*], % FILE PARAMETER BLOCK                02601000
              PGUSE        =24[*];% USE ROUTINES ARRAY - COB61:13 WDS   02601100
                                  %                      COB68: 6 WDS   02601400
    % LOCALS                                                            02601500
         REAL REEL;               % MUST BE HERE FOR MKSCW DIDDLE       02601600
         ARRAY FIB[*];            % FILE INFO BLOCK                     02601700
         REAL I;                  % INDEX + TEMPORARY                   02601800
         NAME IOD=I;              % IO DESCRIPTORS FOR CLOSE            02601900
         REAL IX;                 % INDEX TO FPB                        02601950
         ARRAY LBL[*];            %LABEL FOR BUILDLABEL+HEADER FOR CLOSE02602000
         REAL NOTSERL;            % SET TRUE FOR RANDOM & IO FILES      02602050
         INTEGER PU1,PU2,         % USED BY BUILDLABEL + USERS.DONT MOVE02602100
                 FU1,FU2;         % USED BY BUILDLABEL + USERS.DONT MOVE02602150
         REAL RPU1 = PU1,         % USED BY BUILDLABEL                  02602199
              RPU2 = PU2;         % USED BY BUILDLABEL                  02602200
$VOID 02602221                                                          02602220
         REAL T,                  % TEMPORARY                           02602250
              TEST,               % TRUE WHEN CALLING USERS,USERS68 SAYS02602300
                                  % TEST FOR BEG OR END FILE USE ROUTINE02602350
              COB68;              % TRUE IF THIS IS COBOL 68            02602400
    DEFINE                                                              02602410
         AF             = [12:12]#,        % COB68: FILE USE ROUTINE    02602430
         ALGOLIO(ALGOLIO1)=P([IOD],ALGOLIO1,11,COM,DEL,DEL)#,           02602440
         ARR            = [36:12]#,        % COB68: REEL USE ROUTINE    02602450
         BACKSPACE      = P((-I),[FLOC[3]] INX 0,9,11,COM)#,            02602455
         BCOUNT         = FIB[6]#,         % BLOCK COUNT                02602460
         BF             = [1:11]#,         % COB68: FILE USE ROUTINE    02602470
         BOUNDED        = FIB[9].[2:1]#,   % TRUE IF BOUNDED FROM ABOVE 02602480
         BREAKFAIL      = P(FIB[15].[25:5],(T=1)|4,12,COM)#,%BR OUT FAIL02602490
         BUFFERSIZE     = FIB[18].[3:15]#, % BUFFER SIZE REQUESTED      02602500
         BUFREQ         = FIB[13].[1:9]#,  % NO. OF BUFFERS REQUESTED   02602510
         BUFTOP         = FIB[16]#,% COPY OF TOP IOD:POINTS TO BEG BUFFR02602520
         BRR            = [24:12]#,        % COB68: REEL USE ROUTINE    02602530
         CALLHASH(CALLHASH1)=P(MKS,FLOC,*FIB[8],CALLHASH1,COC)#,        02602550
         CLOSE          = 4#,                                           02602560
         CLOSED         =(FIB[5].[41:2]!0)#,%FILE CLOSED                02602570
         CLOSEDRET      = @20#,            % CLOSED RETAINED            02602580
         COBOLCLOSE     = P(CLOSELOCK&REEL [2:47:1],FLOC,CODE,13,COM,   02602585
                            DEL,DEL,DEL)#,                              02602586
         COBOLFILE      = FIB[13]#,        % ON SAYS FILE IS COBOL      02602590
         COBOLFILBIT    = FIB[13].[47:1]#,                              02602600
         COBOLOPENIN    = P(REEL,FLOC,CODE,13,COM,.I,~,DEL,DEL)#,       02602610
         COBOLOPENOUT   = P(REEL,FLOC,CODE,13,COM,DEL,DEL,DEL)#,        02602620
         COUNT          = FIB[12]#,  % NOTSERL : NO. OF CURRENT BLOCK   02602630
                          % SERIAL IN(OUT): RECORD COUNT WITHIN BLOCK   02602640
         CURRENTREEL    = FIB[13].[28:10]#,% CURRENT REEL NUMBER        02602650
         DIRECTION      = (FIB[13].[25:1])#,% 1=REVERSE,0=FORWARD       02602660
         DISCARDWA      = P(MEM OR ((*RCPRT).[FF]),3,COM,DEL)#,         02602670
         DISK           = FIB[4].[8:4]=4#,                              02602680
         DISKR          = 10#,             % DISK RANDOM (FPB)          02602690
         DISKS          = 12#,             % DISK SERIAL (FPB)          02602700
         ENDFILE        = FIB[5].[40:1]#,  % RECOGNIZED END OF FILE     02602710
         EOF            = [27:1]#,         % EOF BIT IN IOD             02602720
         EORF           = [42:6]#,         % SENTINEL: 1=EOR  0=EOF     02602730
         EORRERUN       = FIB[4].[3:2]#,%EOR RERUN:1=OUTPUT TAPE,2=SCRCH02602740
         FPBXDONE       = FIB[4].[12:1]#,  % [13:11] IS FPB INDEX       02602770
         FCRCLOSE(FCRCLOSE1)=P(MKS,FCRCLOSE1,0,[FLOC],4,FCR)#,          02602780
         FCROPENOUT     = P(MKS,T,[FLOC],3,FCR)#,                       02602790
         FILIO          = FIB[13].[22:1]#, % FILE OPEN IO               02602795
         FPBTYPE        = FPB[IX+3].[43:5]#,% FPB FILE TYPE             02602798
         GETDISKROW     = P(FPB[IX],FPB[IX+1],10,LBL,4,11,COM,DEL,DEL,  02602800
                              DEL,DEL,DEL)#,                            02602805
         HASH           = (FIB[8]!0)#,     % COB61: HASH ROUTINES PRESNT02602810
         HEADERPTR      = FIB[14]#,        % DESC. FOR DISK FILE HEADER 02602820
         HNMROWS        = LBL[9]#,         % HEADER: NUMBER OF ROWS     02602830
                                           % (DO NOT CHANGE)            02602831
         HNMSZRS        = NOTSERL#,        % HEADER: SIZE OF ROWS       02602840
         INFILE         = FIB[13].[27:1]#,  % FILE OPEN INPUT           02602850
         IODONE         = FLOC[I+2].[19:1]#,% DONE BIT ON IN IOD        02602860
         IOERR(IOERR1)  = P(0,FLOC,IOERR1,17,COM)#, % CALL IOERR-DONT DS02602865
         LABELED        = NOT UNLABELED#,                               02602870
         LABEQ          = FIB[5].[17:1]#,  % LABEL EQUATED FROM DISK    02602880
         LASTIO         = FIB[13].[46:1]#, % 1=LAST WAS PHYSICAL READ   02602885
         LBLPTR         = FLOC[1]#,        % LABEL DESCRIPTOR           02602890
         LOCK           = 2#,                                           02602900
         LSUBL          = FIB[1]#,         % DISK: LOWER BOUND RECORD NO02602910
         LSUBU          = FIB[3]#,         % DISK: UPPER BOUND RECORD NO02602920
         MABUSE         = FIB[4].[1:1]#,   % USE ROUTINES PRESENT       02602930
         MAXR           = FIB[18][8:38:10]#, % MAX REC SZ FOR CONCATS   02602945
         MAXREC         = FIB[18].[CF]#,   % MAXIMUM RECORD LENGTH      02602950
         MT             = 2#,              % MAGNETIC TAPE              02602955
         NMSZROWS       = FIB[8]#,         % DISK:DECLARED NUMBR,SZ ROWS02602960
         NOAIT          = FIB[20].[3:1]#,  % AIT FOR WA WAS DESTROYED   02602965
         NOREW          = 1#,              % NO REWIND                  02602970
         NOTCLOSED      = FIB[5].[41:2]=0#,% FILE NOT CLOSED            02602980
         NOTINANDOPEN   = FIB[5].[41:3]!1#,% FILE NOT(INPUT & OPEN)     02602990
         NUMBUFF        = FIB[13].[10:9]#, % NO.OF BUFFERS ASSIGNED     02603000
$VOID 02603006                                                          02603005
         NUMREC         = FIB[11]#,        % NO.OF RECORDS PER BLOCK    02603010
$VOID 02603012                                                          02603011
         OPENIN         = 1#,                                           02603020
         OPENIO         = 5#,                                           02603025
         OPENOUT        = 3#,                                           02603030
         OPTIONAL       = FIB[5].[39:1]#,  % REEL OPTIONAL AND ABSENT   02603040
         OUTAP          = T#,              % EOR RERUN ON OUTPUT TAPE   02603050
         PBIT           = [2:1]#,          % PRESENCE BIT               02603051
         PERFORMUSE     = P(MKS,[FIB],T,0,PERFORMGEN)#,                 02603060
         PURGEREEL      = P([FLOC[3]]&@23[CTF],20,11,COM,DEL,DEL,DEL)#, 02603080
         PURGE          = 4#,                                           02603090
         RANDOM         = FIB[4].[29:1]#,  % RANDOM ACCESS IS THE ORDER 02603100
         RCOUNT         = FIB[7]#,         % NO.OF RECORDS INTO FILE    02603110
         RCPRT          = FIB[20].[FF]#,   % PRT OF DESC POINTING TO REC02603115
         RECSPERBLK     = LBL[0].[30:12]#, % HEADER: RECORDS PER BLOCK  02603120
         REDECWA        = P(MKS,RCPRT,MAXREC,1,1,1,INTINT)#,  % DECLARE 02603130
                                              % SAVE ARRAY FOR WORK AREA02603140
         RELEASE        = 7#,                                           02603200
         RESETPARITY    = FLOC[3]~ (*P(DUP))&0[28:28:1]#, % RESET PARITY02603202
         RESETREADBIT   = 0[24:24:1]#,     % USED TO TURN OFF READ BIT  02603205
         REWIND         = 0#,                                           02603210
         SEGSPEROW      = LBL[8]#,         % HEADER:SEGMENTS PER ROW    02603220
         SEGSPBLK       = LBL[0].[42:6]#,  % HEADER:SEGMENTS PER BLOCK  02603230
$INCLUDE 02603236, IF TIMESHARING;                                      02603232
         SLEEPCM        = 36,COM#,         % SLEEP COMUNICATE           02603235
$OMIT 02603239, IF TIMESHARING;                                         02603237
         SLEEPCM        = 2,COM#,          % SLEEP COMUNICATE           02603238
         SORT           = 6#,                                           02603240
$VOID 02603247                                                          02603245
         SORTFILE       = (FIB[4].[7:1] OR FIB[18].[1:1])#,             02603250
         SZF            = [8:10]#,                                      02603260
         TECH           = FIB[5].[46:2]#,                               02603270
         TECHB          = 2#,              % TECHNIQUE B                02603280
         TECHC          = 3#,              % TECHNIQUE C                02603290
         TERM(TERM1)    = P(1,FLOC,TERM1,17,COM)#, % TERMINATE ON IO ERR02603300
         TIP            = FLOC[3]#,        % TOP IOD                    02603310
         UNITYPE        = (FIB[4].[8:4])#, %ASSND INTERNAL HARDWARE TYPE02603330
         UNLABELED      = FIB[4].[2:1]#,   % UNLABELED FILE             02603340
         WAITIO         = P([FLOC[I+2]],@2000000000,SLEEPCM,DEL,DEL)#,  02603360
         WORDSLEFT      = FIB[17]#,        % NO.OF WORDS LEFT IN BLOCK  02603370
         WRITBACK       = FIB[13].[23:1]#, % WRITE BLOCK BACK ON IO     02603380
         WRITEAFTEREOF  = FIB[13].[44:2]#;                              02603385
    LABEL LINVALID,LOPENIN,LOPREVIN,LOPENOUT,LCLOSE,LOPENIO,LSORT,      02603390
          LOPEN1,LCLOSE1,STARTL,EXIT,TSTBRK,BSTP;%                      02603395
    SWITCH TYPE ~ LINVALID,LOPENIN,LOPREVIN,LOPENOUT,LCLOSE,LOPENIO,    02603400
                  LSORT;%                                               02603450
         SUBROUTINE GOUSE68;                                            02609005
              BEGIN PERFORMUSE; END;                                    02609006
         SUBROUTINE USERS68;                                            02609010
              BEGIN                                                     02609020
                   IF TEST THEN                                         02609030
              BEGIN             % CHECK FOR FILE USE ROUTINES           02609040
                   IF (T~FIB[FU1].BF)!0 THEN GOUSE68;                   02609050
                   IF (T~FIB[FU1].AF)!0 THEN GOUSE68;                   02609060
                   IF (T~PGUSE[PU1].BF)!0 THEN GOUSE68;                 02609070
                   IF (T~PGUSE[PU1].AF)!0 THEN GOUSE68;                 02609080
              END;                                                      02609090
                   IF PU2>0 THEN                                        02609100
              BEGIN             % NOT DISK: CHECK FOR REEL USE ROUTINES 02609110
                   IF (T~FIB[FU1].BRR)!0 THEN GOUSE68;                  02609120
                   IF (T~FIB[FU1].ARR)!0 THEN GOUSE68;                  02609130
                   IF (T~PGUSE[PU1].BRR)!0 THEN GOUSE68;                02609140
                   IF (T~PGUSE[PU1].ARR)!0 THEN GOUSE68;                02609150
              END;                                                      02609160
              END USERS68;                                              02609170
% * * * * * * * * * * * * * * S T A R T  H E R E * * * * * * * * * * * *02610150
         REEL ~ IF P(MKSCW,TOP,XCH,DEL) THEN MKSCW ELSE 0;%             02610200
         COB68 ~ (FIB~*FLOC).SZF=22;%                                   02610300
         IF NOT FPBXDONE THEN FIB[4].[12:12] ~ %                        02610400
              ((FIB[4].[12:12]-1)|ETRLNG)&1 [36:47:1];%                 02610500
         IF REEL>9 THEN%                                                02610600
              BEGIN                           % CONVERT REEL NO.TO OCTAL02610700
                   STREAM(K~0:L~REEL);%                                 02610800
                   BEGIN SI~LOC L; SI~SI+5;%                            02610900
                         DI~LOC K; DS~3 OCT;%                           02611000
                   END;%                                                02611100
                   REEL ~ P;%                                           02611200
              END;%                                                     02611300
         IX ~ FIB[4].[13:11];% INDEX TO FPB                             02611370
         IF CODE!CLOSE THEN%                                            02611390
              IF (T~FPBTYPE)=DISKR OR CODE=OPENIO THEN BEGIN IF T=DISKR 02611400
                   AND NOT COB68 THEN BUFREQ ~ 1; NOTSERL ~ TRUE; END   02611430
              ELSE IF T<3 OR T=11 OR (T}7 AND T<10) THEN%               02611450
                   IF FIB[8].[20:5]>0 THEN    % HAS BEEN LABEQ FRM DISK 02611480
                        BEGIN NMSZROWS~0; LABEQ ~ TRUE; END;%           02611490
         IF CODE=SORT THEN GO TO LSORT;%                                02611495
         IF CODE!CLOSE THEN%                                            02611500
              BEGIN                                                     02611510
                   IF (T=14) AND COB68 THEN TERM(27); %OLD STYLE DATA-C 02611520
$ VOID  02611601                                                        02611600
                   FIB[13].[19:5] ~0;%                                  02611610
                   IF T=DISKR OR T=DISKS THEN  % SET FIB5 FOR NEW LOCK  02611620
                   IF TECH > 1 THEN TERM(30) ELSE % NO TECH B&C ON DISK 02611630
                   IF FALSE THEN               % SYNTAX * * * WALTS BUG 02611634
                   FIB[5].[3:3] ~ IF CODE=1 THEN 1 ELSE  % READ,OK WRITE02611635
                                  IF CODE=3 THEN 2 ELSE  % WRITE,OK READ02611640
                                  IF CODE=5 THEN 0 ELSE  % FEEL FREE    02611650
                                  CODE.[FF]; % 3=READ,NO WRITE  4=MINE  02611660
                   CODE ~ CODE AND 63;       % PULL OUT CODE AND ZERO FF02611670
              END;%                                                     02611680
              NUMBUFF ~ BUFREQ;%                                        02611700
    STARTL:%                                                            02611800
         IF CODE>5 THEN IF CODE=16 THEN GO TO LOPEN1 ELSE%              02611900
                        IF CODE=17 THEN GO TO LCLOSE1 ELSE TERM(25);%   02612000
         GO TO TYPE[CODE];%                                             02612100
    LOPENIO:%                                                           02612200
         CODE ~ OPENIN;%                                                02612300
         FILIO ~ 1;%                                                    02612400
         GO TO LOPENIN;%                                                02612500
    LOPREVIN:%                                                          02612600
         IF ((T~TECH)=TECHC) OR (T=TECHB AND NUMREC!1) THEN TERM(5);    02612700
    LOPENIN:%                                                           02612800
         IF NOTCLOSED THEN TERM(2|CODE-1);%                             02612900
$VOID 02613501                                                          02613000
         IF REEL=0 THEN REEL ~ CURRENTREEL ELSE CURRENTREEL ~ REEL;     02613600
$ VOID  02614101                                                        02613700
$VOID 02614111                                                          02614110
         IF (T~FPBTYPE)=DISKR OR T=DISKS THEN%                          02614200
              BEGIN%                                                    02614300
$VOID 02614351                                                          02614350
                   NMSZROWS ~ 0; % SINCE ITS INPUT                      02614400
                   IF LSUBU!0 THEN     % UPPER BOUND                    02614500
                        BEGIN LSUBU ~ *P(DUP)-1; BOUNDED ~ TRUE; END;   02614600
                   IF LSUBL!0 THEN LSUBL ~ *P(DUP)-1;%                  02614700
                   WRITEAFTEREOF ~ 0;%                                  02614750
                   BCOUNT ~ IF (RCOUNT~LSUBL)=0 THEN 0 ELSE % STARTING  02614800
                        (RCOUNT-1) DIV NUMREC + 1;          % BLOCK     02614900
              END;%                                                     02615000
         COBOLOPENIN;      % STORE BOOLEAN RESULT IN I: TRUE FOR        02615100
                           % LABELED AND NOT SORT FILE ON OPEN IN       02615105
         IF COB68 THEN%                                                 02615110
              BEGIN%                                                    02615115
                   IF NOAIT THEN%                                       02615120
                        BEGIN%                                          02615125
                             REDECWA;%                                  02615130
                             NOAIT ~ 0;%                                02615133
                        END;%                                           02615135
              END ELSE MABUSE ~(*P(DUP))OR PGUSE[10|FILIO]!0%           02615140
                   OR PGUSE[2+9|FILIO]!0 OR ((UNITYPE=MT)|PGUSE[1]!0)   02615150
                   OR ((UNITYPE=MT)|PGUSE[3]!0);%                       02615160
         IF DISK THEN%                                                  02615170
$VOID 02615181                                                          02615180
              BEGIN%                                                    02615200
$VOID 02615211                                                          02615210
                   IF NOT COB68 THEN                                    02615250
                   IF RANDOM THEN TIP ~ 1 INX TIP;% DISK ADDR IN WRD 1  02615300
                   BUILDLABEL;%                                         02615400
                   IF MABUSE THEN%                                      02615500
                        BEGIN     % BEGINNING INPUT/IO FILE             02615600
                             FU1~ 0; TEST ~ 1; PU2 ~ FU2 ~ -1;          02615700
                             IF COB68 THEN BEGIN PU1 ~ 4|FILIO;%        02615800
                                 USERS68; END%                          02615900
                             ELSE BEGIN PU1 ~ 10|FILIO; USERS; END;%    02616000
                        END;%                                           02616100
                   IF COB68 THEN                                        02616140
                        BEGIN                                           02616160
                             BCOUNT ~ (IF RANDOM THEN NOT 0             02616180
                                          ELSE RCOUNT DIV NUMREC);      02616200
                             COUNT~BCOUNT + (NUMBUFF-1)&FIB[5][1:44:1]; 02616220
                        END ELSE                                        02616240
                        BEGIN                                           02616260
                             IF NOTSERL THEN TIP~(BUFFERSIZE+1)INX TIP; 02616300
                   COUNT ~ IF NOTSERL THEN -1 ELSE 0;%                  02616400
                   RESETPARITY;%                                        02616450
                        END;                                            02616470
                   GO TO EXIT;%                                         02616500
              END DISK;%                                                02616600
$VOID 02616621                                                          02616610
         IF HASH THEN CALLHASH(2);%                                     02616700
         IF MABUSE AND I THEN     % LABELED AND NOT SORT                02616800
$VOID 02616851                                                          02616850
              BEGIN               % BEGINNING INPUT FILE/REEL           02616900
                   PU1 ~ FU1 ~ 0; TEST ~ CURRENTREEL=1;%                02617000
                   PU2 ~ FU2 ~ 1;%                                      02617100
                   IF COB68 THEN USERS68 ELSE USERS;%                   02617200
              END;%                                                     02617300
         GO TO TSTBRK;%                                                 02617400
    LOPENOUT:%                                                          02617500
         IF NOTCLOSED THEN TERM(6);%                                    02617600
$VOID 02618451                                                          02617700
         IF REEL!0 THEN CURRENTREEL~REEL;% FIXES OPEN OUT REEL DATA-NAME02618500
$VOID 02618521                                                          02618520
         IF (T~FPBTYPE)=5 OR T=8 OR T=9 % UNLABELED SPEC UNIT, PT, OR MT02618550
              THEN UNLABELED ~ 1;%                                      02618600
         IF NOT COB68 THEN MABUSE ~ *P(DUP) OR PGUSE[4]!0 OR PGUSE[6]!0 02618640
              OR ((T=MT)|PGUSE[5])!0 OR ((T=MT)|PGUSE[7])!0;%           02618645
         IF T=DISKR OR T=DISKS THEN%                                    02618650
              BEGIN%                                                    02618700
$VOID 02618711                                                          02618710
                   IF LSUBU!0 THEN BEGIN LSUBU ~ *P(DUP)-1;%            02618750
                        BOUNDED ~ TRUE; END;%                           02618800
                   IF LSUBL!0 THEN LSUBL ~ *P(DUP)-1;%                  02618900
                   BCOUNT ~ (RCOUNT~LSUBL) DIV NUMREC;%                 02619000
                   IF COB68 AND NMSZROWS = 0 THEN     % DISK DEFAULT IS 02619004
                        IF NOT DISK THEN              % (LBL EQU ONLY)  02619005
                        NMSZROWS ~ 100&20[20:43:5];   % 20 ROWS 100 RECS02619006
              END%                                                      02619010
         ELSE IF LABELED THEN%                                          02619020
$VOID 02619031                                                          02619030
              BEGIN%                                                    02619100
                   BUILDLABEL;%                                         02619200
                   IF NOT SORTFILE THEN%                                02619300
                        BEGIN IF HASH THEN CALLHASH(2);%                02619400
                             IF MABUSE THEN % BEGINNING OUTPUT FILE/REEL02619410
                                  BEGIN TEST ~ REEL=1; FU1 ~ 0; PU2 ~ 5;02619420
                                       IF COB68 THEN%                   02619430
                                            BEGIN PU1~2; USERS68; END%  02619500
                                       ELSE BEGIN PU1~4;FU2~1;USERS;END;02619600
                                  END;%                                 02619700
                        END;%                                           02619800
              END;%                                                     02619900
         COBOLOPENOUT;%                                                 02620000
         IF COB68 THEN  % MOVE WA TO BUF.SAVE WA ADDR. POINT PRT TO BUFF02620010
              BEGIN%                                                    02620015
                   IF NOAIT THEN%                                       02620020
                        BEGIN%                                          02620030
                             REDECWA;%                                  02620040
                             NOAIT ~ 0;%                                02620050
                        END;%                                           02620060
                   IF NOT DISK THEN WORDSLEFT ~ BUFFERSIZE;             02620065
              END OF COB68;%                                            02620070
         IF DISK THEN%                                                  02620100
              BEGIN%                                                    02620200
                   IF RANDOM THEN                                       02620250
                        IF COB68 THEN BCOUNT ~ NOT 0                    02620300
                        ELSE TIP ~ 1 INX TIP;                           02620350
                   BUILDLABEL;%                                         02620400
                   LBL ~ *[HEADERPTR];%                                 02620500
                   LBL[7] ~ -1;%                                        02620600
$ VOID 02620701                                                         02620700
                   IF MABUSE THEN%                                      02620800
                        BEGIN     % BEGINNING OUTPUT FILE               02620810
                            FU1 ~ 0; TEST ~ 1; PU2 ~ FU2 ~ -1;          02620900
                            IF COB68 THEN BEGIN PU1 ~ 2; USERS68; END   02621000
                            ELSE BEGIN PU1 ~ 4; USERS; END;             02621100
                        END;%                                           02621200
                   IF NOT COB68 THEN                                    02621220
                        BEGIN                                           02621230
                   RESETPARITY;%                                        02621250
                   IF NOTSERL THEN%                                     02621300
                        BEGIN%                                          02621310
                                  TIP ~ (BUFFERSIZE+1) INX TIP;%        02621325
                             BUFTOP ~ (*P(DUP)) & 1[24:47:1];  %READ    02621330
                        END   END;                                      02621335
              END DISK;%                                                02621340
         IF NOT COB68 THEN COUNT ~ IF NOTSERL THEN -1 ELSE NUMREC;      02621350
    TSTBRK:%                                                            02621360
         IF (T~EORRERUN)!0 AND CURRENTREEL!1 THEN IF BREAKFAIL AND OUTAP02621364
              THEN BEGIN PURGEREEL; GO TO STARTL; END % TRY BREAK AGAIN 02621365
              ELSE P(DEL);%                                             02621370
         GO TO EXIT;%                                                   02621371
    LCLOSE:%                                                            02621375
         IF OPTIONAL THEN % EOF ON ABSENT OPTIONAL FILE                 02621380
              BEGIN FIB[5] ~ (*P(DUP))&4 [39:42:6]; % MARK CLOSED RLSD  02621400
                    P(XIT);%                                            02621500
              END;%                                                     02621600
         IF NOT SORTFILE AND CLOSED THEN BEGIN IOERR(12-FIB[5].[43:1]); 02621700
              GO TO EXIT; END;                                          02621750
$VOID 02621801                                                          02621800
         IF NOT INFILE THEN IF (LABELED AND NOT SORTFILE) THEN%         02621900
$VOID   02621999                                                        02621901
              IF DISK THEN%                                             02622000
                   BEGIN      % MOVE RECORD COUNT FROM HEADER TO LABEL  02622010
                        STREAM(A~P([HEADERPTR],LOD,7,COC,1,+),          02622020
                               B~ 5 INX LBLPTR);%                       02622030
                            BEGIN SI~LOC A; DI~DI+5; DS~7 DEC; END;%    02622040
                        IF MABUSE THEN      % END OUTPUT FILE           02622050
                            BEGIN FU1~2; TEST~1; PU2~FU2~-1;            02622070
                                 IF COB68 THEN BEGIN PU1~3; USERS68; END02622100
                                 ELSE BEGIN PU1~6; USERS; END;%         02622200
                            END;%                                       02622300
                   END        % NOT DISK                                02622400
              ELSE BEGIN      % MOVE BLK & RECORD COUNTS FROM FIB TO LBL02622500
                        IF HASH THEN CALLHASH(1);%                      02622600
                        STREAM(A~BCOUNT,B~RCOUNT,C~5 INX LBLPTR);%      02622700
                            BEGIN SI~LOC A; DS~5 DEC; DS~7 DEC; END;%   02622800
                        LBL ~ LBLPTR;%                                  02622900
                        LBL[4].EORF~ REEL!0;%                           02623000
                        LBL ~ 0; %FILE CLOSE FORGETS LABELS-SO CLEAR PTR02623100
                        IF REEL THEN CLOSELOCK ~ LOCK;%                 02623200
                        IF MABUSE THEN      % END OUTPUT FILE/REEL      02623300
                            BEGIN FU1~2; TEST ~ REEL=0; PU2 ~ 7;        02623400
                                IF COB68 THEN BEGIN PU1~3; USERS68; END 02623500
                                ELSE BEGIN PU1~6; FU2~3; USERS; END;    02623600
                            END;%                                       02623610
                   END; % OF NONDISK                                    02623620
         IF DISK AND LABELED AND NOT SORTFILE THEN%                     02623700
                   BEGIN%                                               02623800
                        LSUBL ~ *P(DUP)+1;%                             02623900
                        IF BOUNDED THEN  % IF UPPER BOUND               02624000
                            BEGIN LSUBU ~ *P(DUP)+1; BOUNDED~FALSE; END 02624100
                           ELSE IF COB68 THEN LSUBU ~ 0;                02624200
                        LBL ~ *[HEADERPTR];%                            02624300
                        HNMSZRS ~-(((SEGSPEROW|RECSPERBLK) DIV SEGSPBLK)02624400
                             & HNMROWS [20:43:5]);% NM,SZ ROWS FR HEADER02624500
                        NMSZROWS ~ 0; % ZERO FIB NM,SZ ROWS             02624600
                        IF NOT COB68 THEN                               02624610
                           BEGIN IF RANDOM THEN WORDSLEFT~0;            02624620
                           IF (FILIO OR FIB[5].[41:3]=0) AND WRITBACK   02624630
                              AND TECH=0 AND LASTIO THEN                02624640
                           IF RANDOM AND WRITEAFTEREOF ! 0 THEN         02624650
                              BEGIN  RCOUNT ~ *P(DUP) - 1;              02624660
                                     LBL[7] ~ *P(DUP) - 1;              02624670
                                     END ELSE WRITEAFTEREOF ~ 0;        02624680
                           END;                                         02624690
                   END;%                                                02624700
              IF UNITYPE=MT AND CLOSELOCK=REWIND AND NOT REEL THEN%     02624800
                   BEGIN%                                               02624900
                        STREAM(K~0:A~FPB[IX+2]); % GET REEL NO. FROM FPB02624910
                            BEGIN DI~LOC K;SI~ LOC A;DS~3 OCT;END;%     02624920
                        IF P!CURRENTREEL THEN CLOSELOCK ~ LOCK;%        02625000
                   END;%                                                02625100
              T ~ CURRENTREEL;%                                         02625105
              IF TECH=0 AND NOT COB68 THEN IF WRITEAFTEREOF=2 THEN      02625110
                   BEGIN%                                               02625115
                        RCOUNT ~ *P(DUP)+1;%                            02625120
                        FIB[13].[44:1] ~ 0;%                            02625125
                        LBL[7] ~ *P(DUP)+1;%                            02625130
                   END ELSE IF WRITEAFTEREOF=1 THEN%                    02625135
                   BEGIN%                                               02625140
                        RCOUNT ~ *P(DUP)-1;%                            02625150
                        FIB[13].[45:1] ~ 0;%                            02625160
                        LBL[7] ~ *P(DUP)-1;%                            02625170
                   END;%                                                02625180
              COBOLCLOSE;%                                              02625200
              IF HNMSZRS.[1:1] THEN                                     02625210
                   BEGIN%                                               02625220
                        NMSZROWS ~ ABS(HNMSZRS);%                       02625225
                        HNMSZRS ~ 0;%                                   02625230
                        WRITBACK ~ FALSE; % RANDOM OUTPUT AND I-O       02625240
                   END;%                                                02625250
              IF REEL THEN%                                             02625255
                   BEGIN % REEL SWITCH                                  02625260
                        REEL ~ T+1;%                                    02625265
                        CODE ~ 3-(2|INFILE)+DIRECTION;%                 02625268
                        IF CODE=OPENOUT THEN CURRENTREEL ~ REEL;%       02625270
                        GO TO STARTL;%                                  02625300
                   END%                                                 02625400
              ELSE CURRENTREEL ~ 0;                                     02625500
$ VOID  02625901                                                        02625510
              GO TO EXIT;%                                              02625950
    LINVALID:%                                                          02626000
         TERM(25);%                                                     02626050
    LCLOSE1:%                                                           02626100
         IF NOTINANDOPEN THEN TERM(12-FIB[5].[43:1]);%                  02626150
         IF ENDFILE THEN BEGIN I ~ 1; GO TO BSTP; END;%                 02626200
         FOR I ~ 1 STEP 1 UNTIL NUMBUFF DO%                             02626250
              BEGIN     % WAIT UNTIL ALL I0-S ARE DONE%                 02626300
                   IF NOT IODONE THEN WAITIO;%                          02626350
                   IF FLOC[I+2].EOF THEN GO BSTP;%                      02626400
              END;%                                                     02626450
         I ~ NUMBUFF;%                                                  02626500
    BSTP:%                                                              02626550
         BACKSPACE;   % BACKSPACE I BLOCKS                              02626600
         TIP.EOF ~ ENDFILE;%                                            02626650
         FIB[5].[40:6] ~ CLOSEDRET;%                                    02626700
         GO TO EXIT;%                                                   02626750
    LOPEN1:%                                                            02626800
         IF FIB[5].[40:6]!CLOSEDRET THEN TERM(6);%                      02626850
         FIB[5].[40:6] ~ 0;%                                            02626900
         BUFTOP ~(*P(DUP))& RESETREADBIT;%                              02626950
         INFILE ~ 0; % MAKE IT OUTPUT                                   02627000
         LBLPTR ~(*P(DUP))& RESETREADBIT;%                              02627050
         IF TIP.EOF THEN%                                               02627100
              BEGIN    % HAD  READ EOF BEFORE BACKSPACE                 02627150
                   WORDSLEFT ~ BUFFERSIZE;%                             02627200
                   TIP.EOF ~ 0; % RESET EOF                             02627250
                   COUNT ~ NUMREC;  % # RECS LEFT IN BUFF =  WHOLE BUFF 02627300
                   BUFTOP.[CF] ~ TIP.[CF];%                             02627340
              END%                                                      02627350
         ELSE BEGIN % NO EOF - OPEN IN PLACE                            02627400
                   RCOUNT ~ *P(DUP)-1;% BACK UP BECAUSE WE              02627450
                   BCOUNT ~ *P(DUP)-1;% WERE READING                    02627500
                   WORDSLEFT ~ BUFFERSIZE-(TIP.[CF]-BUFTOP.[CF]);%      02627510
                   COUNT ~ WORDSLEFT DIV MAXREC;   % # RECS LEFT IN BUFF02627600
              END;%                                                     02627650
         FOR T ~ 1 STEP 1 UNTIL NUMBUFF DO%                             02627700
              FLOC[T+2] ~ FLAG(BUFTOP&FLOC[T+2][CTC]); % CHANGE TO WRITE02627750
         GO TO EXIT;%                                                   02627800
    LSORT:%                                                             02627850
         IOD ~ [TIP];%                                                  02627860
         IF CLOSELOCK=NOREW THEN         % FCR CALLED WITH THESE PARAMS 02627870
              BEGIN                      %IF IO COMPLETE BUT NOT PRESENT02627880
                   IF NOT (*IOD).EOF     % NOT EOF:MUST HAVE BEEN PARITY02627890
                        THEN TERM(19)    % TERMINATE ON PARITY          02627900
                   ELSE                  % MUST HAVE BEEN EOF OR EOR    02627910
                        BEGIN ALGOLIO(11);% READLABEL                   02627920
                              LBL ~ LBLPTR;%                            02627930
                              IF LBL[4].EORF=0 THEN P(1,RTN);%RETURN EOF02627940
                              REEL ~ CURRENTREEL+1;%REEL SWITCH ON INPUT02627950
                              T ~ COBOLFILBIT; % REMEMBER IF COBOL FILE 02627960
                              FCRCLOSE(PURGE);                          02627970
                              FIB[13]~(*P(DUP))&REEL[28:38:10]% NXT REEL02628000
                                      &0 [47:47:1]; % MAKE IT LOOK ALGOL02628050
                              ALGOLIO(0);% OPEN INPUT NEXT REEL         02628100
                              FIB[13] ~(*P(DUP))OR T;% RESTORE COBOL BIT02628150
                              P(0,RTN); % RETURN EOR                    02628200
                        END;%                                           02628250
              END NOREW;%                                               02628300
         IF CLOSELOCK=REWIND THEN%                                      02628310
              BEGIN     % REEL SWITCH ON OUTPUT                         02628320
                   LBL ~ LBLPTR;%                                       02628330
                   LBL[4].EORF ~ 1;  % EOR                              02628340
                   LBL ~ 0;%FILE CLOSE FOGETS LABEL SO PTR MUST BE CLRD 02628350
                   T ~ CURRENTREEL+1;%                                  02628360
                   FCRCLOSE(RELEASE);     % CLOSE RELEASE CURRENT REEL  02628370
                   CURRENTREEL ~ REEL ~ T;%WITH NO REEL SWITCH-DONE HERE02628380
                   IF COBOLFILE THEN FCROPENOUT ELSE ALGOLIO(0);%NXT RL 02628390
                   P(XIT);           % OPEN OUT (ALGOL OR COBOL)NXT REEL02628400
              END;%                                                     02628450
         IF CLOSELOCK=LOCK THEN                                         02628500
              BEGIN%                                                    02628510
                   T ~ IF CURRENTREEL=1 THEN REWIND ELSE RELEASE;       02628520
                   FCRCLOSE(T);      % CLOSE REWIND FIRST REEL,         02628550
                   P(XIT);           % CLOSE RELEASE ALL OTHERS         02628600
              END;%                                                     02628700
    EXIT::%                                                             02628800
         END COBOLFCR;%                                                 02628900
PROCEDURE COBOLDECIMALTOOCTALCONVERT(A) ;  %% INTRINSIC # @151.         09300000
VALUE A;  NAME A ;                                                      09300100
    % THIS PROCEDURE CONVERTS A STRING OF N BCD DIGITS, STARTING AT WORD09300200
    % ADDRESS A, CHARACTER OFFSET S, INTO A DOUBLE-LENGTH VALUE. THE LOW09300300
    % PART OF THIS IS STORED IN S, THE HIGH PART IN N. IF N.[1:1]=1,THEN09300400
    % THE SIGN OF THE VALUE IS OBTAINED FROM THE ZONE BITS OF THE 1-ST  09300500
    % CHARACTER (BCD DIGIT), OTHERWISE FROM THE LAST. 0{S{7, 0{ABS(N){2309300600
    BEGIN                                                               09300700
    REAL N=A-2, S=N-1, Q=9, C ;                                         09300800
    LABEL B,D,E,T8,G ;                                                  09300900
    Q~N}0;  P(DIB 1) ;                                                  09301000
    IF (N~ABS(N)){8 THEN                                                09301100
         BEGIN                                                          09301200
         STREAM(C:S,A,N); BEGIN SI~A; SI~SI+S; DI~LOC C; DS~N OCT END ; 09301300
         IF NOT Q THEN GO D;  N~P ;                                     09301400
         END                                                            09301500
    ELSE BEGIN  P(0) ;                                                  09301600
         IF N>16 THEN                                                   09301700
              BEGIN                                                     09301800
              STREAM(S,Z~0,A:N~N-16,CA~[C]) ;                           09301900
                   BEGIN                                                09302000
                   SI~A; SI~SI+S; DI~LOC A; DS~N OCT; DI~LOC S ;        09302100
                   DS~8 OCT; DI~CA; DS~8 OCT ;                          09302200
                   END ;                                                09302300
              P(0,T8,DLM,DLA) ;                                         09302400
    B:        P(0,T8,DLM,0,ABS(C),DLA) ;                                09302500
              END                                                       09302600
         ELSE BEGIN                                                     09302700
              STREAM(S:A,N~N-8,CA~[C]) ;                                09302800
                   BEGIN                                                09302900
                   SI~A; SI~SI+S; DI~LOC S; DS~N OCT; DI~CA; DS~8 OCT ; 09303000
                   END ;                                                09303100
              IF P(DUP)>P(G) THEN GO B;  P(T8,|,ABS(C),+) ;             09303200
              END ;                                                     09303300
         IF C!0 AND Q THEN                                              09303400
              BEGIN                                                     09303500
              P(C,DIA 1);  GO E ;                                       09303600
    T8:::     100000000.0 ;                                             09303700
    G:::      5496.0 ;                                                  09303800
              END ;                                                     09303900
         IF Q THEN S~S+N-1 ;                                            09304000
    D:   STREAM(S:A); BEGIN SI~A; SI~SI+S; S~TALLY; DI~LOC S; DI~DI+7;  09304100
                      DS~ZON; END;                                      09304200
         P(P=@40,DIA 47) ;                                              09304300
    E:   N~P(TRB 1) ;                                                   09304400
         END ;                                                          09304500
    S~P ;                                                               09304600
    END OF COBOLDECIMALTOOCTALCONVERT ;                                 09304700
PROCEDURE COBOLOCTOLTODECIMALCONVERT(A,L,H,S,N,R,T); % INTRINSIC # @152.09400000
VALUE L,H,R,N,S,T;  REAL L,H,R,N,S,T;  NAME A ;                         09400100
    % THIS PROCEDURE CONVERTS THE DOUBLE-LENGTH WORD (L,H) INTO A STRING09400200
    % OF N BCD DIGITS. THE STRING STARTS AT WORD ADDRESS A, CHARACTER   09400300
    % OFFSET S. PRIOR TO THE CONVERSION, (L,H) IS SCALED-TO-THE-LEFT/RHT09400400
    % BY R DIGITS, I.E. (L,H) IS DIVIDED/MULTED BY 10*R. T IS A COMBINED09400500
    % TRUNCATION/J-SIGN TOGGLE: T.[2:1]=1 => PUT THE SIGN OF (L,H) IN   09400600
    % 1-ST CHR OF THE STRING; T.[1:1]=1 => PUT SIGN IN THE LAST CHR;    09400700
    % ABS(T).[47:1]=1 => TRUNCATE (L,H) BEFORE CONVERSION (AND AFTER    09400800
    % SCALING); ABS(T).[46:1]=1 => ROUND (L,H) BEFORE CONVERSION (AND   09400900
    % AFTER SCALING). NOTE THAT 0{S{7, 0{N{23.                          09401000
    BEGIN                                                               09401100
    INTEGER IR=R, IH=H, IL=L ;                                          09401200
    REAL B=17, SERR=19, WH=11, DMOD=21, Q=9 ;                           09401300
    ARRAY TEN=23[*] ;                                                   09401400
    LABEL HLF,T8,T16 ;                                                  09401500
    IF R<0 THEN                                                         09401600
         BEGIN                                                          09401700
         STREAM(S,N,A); BEGIN DI~DI+S; N(DS~LIT"0") END ;               09401800
         N~N+R;  R~0 ;                                                  09401900
         END ;                                                          09402000
         IF T.[1:2]=0 THEN H ~ ABS(H);                                  09402100
    IF H.[2:1] THEN P(0,H/TEN[R]) ELSE P(L,H,TEN[R+27],TEN[R],DLD) ;    09402200
    L~0 ;                                                               09402300
    IF P(ABS(Q~P),DUP)<P(HLF) THEN H~R~SERR~0                           09402400
    ELSE BEGIN                                                          09402500
         IF SERR~P(DUP)>TEN[23] THEN P(TEN[27+N],TEN[N],DMOD,B,XCH) ;   09402600
         IF P(DUP).[2:1] THEN                                           09402700
              BEGIN IF T THEN P(HLF,-); H~(IR~P) DIV P(T8) END          09402800
         ELSE BEGIN                                                     09402900
              IF NOT T THEN P(0,HLF,DLA);  H~P ;                        09403000
              H~P(L~P,H,0,IL~P(L,H,0,T16,DLD,HLF,-),XCH,DEL,0,T16,DLM,  09403100
                  DLS) ;                                                09403200
              IR~P(R~P,H,0,IH~P(R,H,0,T8,DLD,HLF,-),XCH,DEL,0,T8,DLM,   09403300
                   DLS,HLF,-) ;                                         09403400
              END ;                                                     09403500
         END ;                                                          09403600
    IF N{8 THEN                                                         09403700
         BEGIN P(L!0 OR H!0 OR R}TEN[N] OR N=0) ;                       09403800
         STREAM(R,N,S,A); BEGIN DI~DI+S; SI~LOC R; DS~N DEC END ;       09403900
         END                                                            09404000
    ELSE IF N{16 THEN                                                   09404100
              BEGIN P(L!0 OR H}TEN[N-8]) ;                              09404200
              STREAM(H,R,N~N-8,S,A) ;                                   09404300
                   BEGIN DI~DI+S; SI~LOC H; DS~N DEC; DS~8 DEC END ;    09404400
              END                                                       09404500
         ELSE BEGIN P(L}TEN[N-16]) ;                                    09404600
              STREAM(L,H,R,N~N-16,S,A) ;                                09404700
                 BEGIN DI~DI+S; SI~LOC L; DS~N DEC; DS~8DEC; DS~8DEC END09404800
              END ;                                                     09404900
    IF P OR SERR THEN IF P(1,WH.[18:15],DUP)!0 THEN P(DIB 0,~) ;        09405000
    IF Q<0 THEN                                                         09405100
         BEGIN                                                          09405200
         IF T>0 THEN                                                    09405300
              BEGIN                                                     09405400
              STREAM(N~N-2,S,A) ;                                       09405500
                   BEGIN                                                09405600
                   DI~DI+S; DS~SET; DS~RESET; DI~DI+N; DS~RESET;DS~RESET09405700
                   END ;                                                09405800
              P(XIT) ;                                                  09405900
    HLF:::    0.499999999999 ;                                          09406000
    T16:::    10000000000000000.0 ;                                     09406100
    T8:::     100000000.0 ;                                             09406200
              END ;                                                     09406300
         STREAM(S~S+N-1,A); BEGIN DI~DI+S; DS~SET; DS~RESET END ;       09406400
         END ;                                                          09406500
    END OF COBOLOCTALTODECIMALCONVERT ;                                 09406600
PROCEDURE COBOLVARSZ;                                                   09500000
    BEGIN                                                               09500100
    REAL                                                                09500200
         TYPE      = -1;                    % 0-2: EXAMINE              09500300
                                            % 0=REPLACING FIRST         09500400
                                            % 1=REP/TALLY ALL,          09500500
                                            % 2=LEADING/UNTIL FIRST     09500600
                                            % 3: VARIABLE SIZE SMEAR    09500700
                                            % 4-9: VARIABLE SIZE RELATE 09500800
                                            % 4=<, 5=}, 6=>, 7={,8==,9=!09500900
                                            % 10: VARIABLE SIZE MOVE    09501000
                                            % 11: NEG ALPHA TEST        09501100
                                            % 12: POSITIVE ALPHA TEST   09501200
   ARRAY DESC      = -2[*];                 % RELATE: JUNKA DESCRIPTOR  09501300
                                            % MOVE,SMEAR:  =0           09501400
    REAL CODE      = -2,                    % EXAMINE:[47:1]=1 IF REP   09501500
                                            % [46:1]=1 IF TALLYING      09501600
                                            % [45:1]=1 IF REPLACING OR  09501700
                                            % TALLYING UNTIL FIRST      09501800
         DLENGTH   = -3,                    % MOVE & RELATE: DEST LENGTH09501900
                                            % SMEAR: LENGTH TO SMEAR    09502000
         LNGTH     = -3,                    % EXAMINE: LENGTH           09502100
         SLENGTH   = -4,                    % SOURCE LENGTH (SMEAR: =0) 09502200
         RCHR      = -4,                    % EXAMINE: CHAR TO REPLACE  09502300
         DOFSET    = -5,                    % MOVE,RELATE,SMEAR:DEST OFF09502400
         SCHR      = -5,                    % EXAMINE: CHAR SOUGHT      09502500
         SMCHR     = -6,                    % SMEAR: CHAR TO SMEAR      09502600
                                            % EXAMINE: MKS              09502700
         SOFSET    = -6,                    % MOVE&RELATE: SOURCE OFFSET09502800
         OFFSET    = -7;                    % EXAMINE: OFFSET           09502900
    ARRAY                                                               09503000
         DEST      = -7[*],                 % MOVE,RELATE,SMEAR:DEST    09503100
         SOURCE    = -8[*];                 % MOVE,RELATE,EXAMINE:SOURCE09503200
    REAL                                                                09503300
         RELATE,                                                        09503400
         DIFFER,                                                        09503500
         NMOD64,                                                        09503600
         SAVOFF,                                                        09503700
         NDIV64,                                                        09503800
         N,                                                             09503900
         NWDS;                                                          09504000
   ARRAY D[*];                                                          09504100
    DEFINE                                                              09504200
         REPLACECHR = DI~DI-1; SI~LOC P6; SI~SI-1; DS~1 CHR#,           09504300
         LISTP1TOP6 = P1~NMOD64,P2~NDIV64,P3~(NDIV64 DIV 64),           09504400
                      P4~SCHR,P5~RCHR,P6~OFFSET#;                       09504500
    LABEL VARIEXAM,CMD,SMEAR;%                                          09504600
%****************************** START HERE *****************************09504700
         IF TYPE{2 THEN GO TO VARIEXAM;%                                09504800
         D ~  [DEST];%                                                  09504900
         IF TYPE=3 THEN GO TO SMEAR;%                                   09505000
         IF (DIFFER ~ DLENGTH-SLENGTH)<0 THEN    % VARIABLE MOVE ONLY   09505100
         IF TYPE=10 THEN%                                               09505200
    BEGIN%                                                              09505300
         SLENGTH ~ DLENGTH;                                             09505400
         NMOD64 ~ SLENGTH.[42:6];%                                      09505500
    END;                                                                09505600
         IF DIFFER!0 AND TYPE}4 AND TYPE{9 THEN  % IF THERE IS A DIFFER-09505700
              BEGIN % THEN MOVE SHORTER TO JUNKA&FILL OUT WITH BLANKS   09505800
                   IF DIFFER<0 THEN  % INTERCHANGE TO MAKE DEST THE     09505900
                        BEGIN  % LONGER, SOURCE THE SHORTER             09506000
                             D ~ [DEST]; DEST ~ [SOURCE]; SOURCE ~ [D]; 09506100
                             SAVOFF ~ SOFSET; SOFSET ~ DOFSET; DOFSET~0;09506200
                             NWDS~DLENGTH;DLENGTH~SLENGTH;SLENGTH~NWDS; 09506300
                        END ELSE%                                       09506400
                        BEGIN%                                          09506500
                             IF TYPE<8 THEN TYPE~TYPE-TYPE.[47:1]%      09506600
                                  +(TYPE.[47:1]=0);%                    09506700
                             SAVOFF ~ DOFSET;%                          09506800
                             DOFSET ~ 0;%                               09506900
                        END;%                                           09507000
                   RELATE ~ TYPE;                                       09507100
                   TYPE ~ 10;                                           09507200
                   D ~ [DESC];%                                         09507300
              END;%                                                     09507400
    CMD:                     % TRANSFER OR COMPARE FIELDS               09507500
         IF TYPE!10 OR DIFFER}0 OR RELATE>0 THEN NMOD64~SLENGTH.[42:6]; 09507600
         NDIV64 ~ SLENGTH DIV 64;%                                      09507700
         IF TYPE<8 THEN%                                                09507800
    BEGIN%                                                              09507900
         STREAM(P0~0:P1~NMOD64,P2~NDIV64,P2A~NDIV64!0,P3~(NDIV64 DIV 64)09508000
               ,P4~SOURCE,P5~SOFSET,P6~DOFSET,P7~TYPE}6,%               09508100
                P8~TYPE.[47:1],P9~D);%                                  09508200
         BEGIN                                                          09508300
              SI ~ P4; SI ~ SI+P5; DI ~ DI+P6;                          09508400
              CI ~ CI+P7; GO TO GREQ; GO TO GOLSQ;%                     09508500
         GREQ:                                                          09508600
              P3(63(P0~SI;P9~DI;IF 63SC=DC THEN ELSE%                   09508700
                   BEGIN SI~P0;DI~P9;IF 63 SC>DC THEN;%                 09508800
                        JUMP OUT 2 TO XYT1;%                            09508900
                   END);%                                               09509000
                  2(P0~SI;P9~DI;IF 63SC=DC THEN ELSE%                   09509100
                   BEGIN SI~P0;DI~P9;IF 63 SC>DC THEN;%                 09509200
                        JUMP OUT 2 TO XYT1;%                            09509300
                   END);%                                               09509400
                 IF SC=DC THEN ELSE%                                    09509500
                  BEGIN SI~SI-1;DI~DI-1;IF SC>DC THEN;%                 09509600
                        JUMP OUT 1 XYT1;%                               09509700
                   END); GO TO L1;%                                     09509800
         XYT1: GO TO XYT2;%                                             09509900
         GOLSQ:GO TO LSEQ;%                                             09510000
         L1:  P2   (P0~SI;P9~DI;IF 63SC=DC THEN ELSE%                   09510100
                   BEGIN SI~P0;DI~P9;IF 63 SC>DC THEN;                  09510200
                        JUMP OUT 1 TO XYT2;%                            09510300
                   END);%                                               09510400
              P2A  (P0~SI;P9~DI;IF P2 SC=DC THEN ELSE%                  09510500
                   BEGIN SI~P0;DI~P9;IF P2 SC>DC THEN;%                 09510600
                        JUMP OUT 1 TO XYT2;%                            09510700
                   END);%                                               09510800
              IF P1 SC}DC THEN;%                                        09510900
         XYT2: GO TO XYT3;%                                             09511000
         LSEQ:                                                          09511100
              P3(63(P0~SI;P9~DI;IF 63SC=DC THEN ELSE%                   09511200
                   BEGIN SI~P0;DI~P9;IF 63 SC<DC THEN;%                 09511300
                        JUMP OUT 2 TO XYT3;%                            09511400
                  END);%                                                09511500
                  2(P0~SI;P9~DI;IF 63SC=DC THEN ELSE%                   09511600
                   BEGIN SI~P0;DI~P9;IF 63 SC<DC THEN;%                 09511700
                        JUMP OUT 2 TO XYT3;%                            09511800
                   END);%                                               09511900
                 IF SC=DC THEN ELSE%                                    09512000
                  BEGIN SI~SI-1;DI~DI-1;IF SC<DC THEN;%                 09512100
                        JUMP OUT 1 TO XYT3;%                            09512200
                   END); GO TO L2;%                                     09512300
         XYT3: GO TO XYT;%                                              09512400
         L2:  P2   (P0~SI;P9~DI;IF 63SC=DC THEN ELSE%                   09512500
                   BEGIN SI~P0;DI~P9;IF 63 SC<DC THEN;%                 09512600
                        JUMP OUT 1 TO XYT;%                             09512700
                   END);%                                               09512800
              P2A  (P0~SI;P9~DI;IF P2 SC=DC THEN ELSE%                  09512900
                   BEGIN SI~P0;DI~P9;IF P2 SC<DC THEN;%                 09513000
                        JUMP OUT 1 TO XYT;%                             09513100
                   END);%                                               09513200
              IF P1 SC{DC THEN;%                                        09513300
         XYT: P8(IF TOGGLE THEN TALLY~1; JUMP OUT 1 TO STOR);%          09513400
              IF TOGGLE THEN ELSE TALLY~1;%                             09513500
         STOR:P0~TALLY;%                                                09513600
         END STREAM;%                                                   09513700
    END ELSE%                                                           09513800
    BEGIN%                                                              09513900
         STREAM(P0~0:P1~NMOD64,P2~NDIV64,P2A~NDIV64!0,P3~(NDIV64 DIV 64)09514000
               ,P4~SOURCE,P5~SOFSET,P6~DOFSET,P7~(TYPE}10)+(TYPE>10),%  09514100
                P8~TYPE.[47:1],P9~D);%                                  09514200
         BEGIN%                                                         09514300
              SI ~ P4; SI ~ SI+P5; DI ~ DI+P6;                          09514400
              CI ~ CI+P7; GO TO EQUL; GO TO TRFR; GO TO GOTAN;%         09514500
         EQUL:%                                                         09514600
              P3( 63(IF 63 SC=DC THEN ELSE JUMP OUT 2 TO XYT1);%        09514700
              2(IF 63 SC=DC THEN ELSE JUMP OUT 2 TO XYT1);%             09514800
              IF     1 SC=DC  THEN ELSE JUMP OUT 1 TO XYT1); GO TO L;%  09514900
         GOTAN: GO TO TANL;%                                            09515000
         L:   P2(IF 63 SC=DC THEN ELSE JUMP OUT 1 TO XYT1);%            09515100
              P2A(IF P2 SC=DC THEN ELSE JUMP OUT 1 TO XYT1);%           09515200
              IF    P1 SC=DC  THEN; GO TO XYT1;%                        09515300
         TRFR:%                                                         09515400
              P3(63(DS~63 CHR); 2(DS~63 CHR); DS~CHR);% MOVE 64|64      09515500
              P2(DS ~ 63 CHR); DS ~ P2 CHR; DS ~ P1 CHR; GO TO DONE1;%  09515600
         XYT1: GO TO XYT2;%                                             09515700
         TANL:%                                                         09515800
              P3(63(63(IF SC=ALPHA THEN IF SC{"Z" THEN SI~SI+1 ELSE%    09515900
                    JUMP OUT 3 TO XYT2 ELSE JUMP OUT 3 TO XYT2));%      09516000
                  2(63(IF SC=ALPHA THEN IF SC{"Z" THEN SI~SI+1 ELSE%    09516100
                    JUMP OUT 3 TO XYT2 ELSE JUMP OUT 3 TO XYT2));%      09516200
                       IF SC=ALPHA THEN IF SC{"Z" THEN SI~SI+1 ELSE%    09516300
                    JUMP OUT 1 TO XYT2 ELSE JUMP OUT 1 TO XYT2);%       09516400
              GO TO L1;                                                 09516500
         XYT2: GO TO XYT;                                               09516600
         DONE1: GO TO DONE;                                             09516700
         L1:     P2(63(IF SC=ALPHA THEN IF SC{"Z" THEN SI~SI+1 ELSE%    09516800
                    JUMP OUT 2 TO XYT ELSE JUMP OUT 2 TO XYT));%        09516900
                    P2(IF SC=ALPHA THEN IF SC{"Z" THEN SI~SI+1 ELSE%    09517000
                    JUMP OUT 1 TO XYT ELSE JUMP OUT  1 TO XYT);%        09517100
                    P1(IF SC=ALPHA THEN IF SC{"Z" THEN SI~SI+1 ELSE%    09517200
                    JUMP OUT 1 TO XYT ELSE JUMP OUT 1 TO XYT);%         09517300
         XYT: P8(IF TOGGLE THEN ELSE TALLY~1; JUMP OUT 1 TO STOR);%     09517400
              IF TOGGLE THEN TALLY~1;%                                  09517500
         STOR: P0~TALLY;%                                               09517600
         DONE:%                                                         09517700
         END STREAM;%                                                   09517800
    END;%                                                               09517900
         IF TYPE!10 THEN P(RTN);%                                       09518000
         IF DIFFER>0 THEN                                               09518100
    BEGIN                    % FILL OUT DEST WITH BLANKS TO MAKE UP DIFF09518200
         DOFSET ~ (P(SLENGTH+DOFSET,DUP)).[45:3];                       09518300
         D ~ P(8,IDV,D,INX);%                                           09518400
    SMEAR::NDIV64 ~(NWDS~(((DIFFER~(DLENGTH-SLENGTH)-%                  09518500
              (N~(8-DOFSET).[45:3])) DIV 8) - (DIFFER}8))) DIV 64;%     09518600
         STREAM(P1~DIFFER.[45:3],P2~DOFSET,P3~8|(DIFFER}8)+N,P4~NWDS,   09518700
                P5~NDIV64,P6~SMCHR,P7~(TYPE=3 AND SMCHR!" "),P8~D);%    09518800
         BEGIN                                                          09518900
              DI ~ DI+P2; P8~DI; P7(SI~LOC P7; SI~SI-1);%               09519000
              CI~CI+P7; GO TO BLNK; GO TO SMR;%                         09519100
         BLNK:P3(DS ~ LIT " "); GO TO CONT;%                            09519200
         SMR: P3(DS ~ 1 CHR; SI~SI-1);%                                 09519300
         CONT:SI ~ P8; P5(DS ~ 63 WDS); DS ~ P5 WDS; DS ~ P4 WDS;%      09519400
              CI~CI+P7; GO TO FINB; GO TO FINS;%                        09519500
         FINB:P1(DS ~ LIT " "); GO TO XYT;%                             09519600
         FINS:P1(DS ~ 1 CHR; SI~SI-1);%                                 09519700
         XYT:%                                                          09519800
         END STREAM;                                                    09519900
    END;%                                                               09520000
         IF RELATE>0 THEN              % BLANK FILL DONE                09520100
              BEGIN                    % GO BACK AND DO COMPARE         09520200
                   SOFSET ~ SAVOFF;%                                    09520300
                   SOURCE ~ [DEST];%                                    09520400
                   SLENGTH ~ DLENGTH;%                                  09520500
                   TYPE ~ RELATE;%                                      09520600
                   GO TO CMD;%                                          09520700
              END;%                                                     09520800
         P(XIT);                                                        09520900
    VARIEXAM::%                                                         09521000
         NMOD64 ~ LNGTH.[42:6];%                                        09521100
         NDIV64 ~ LNGTH DIV 64;%                                        09521200
         IF TYPE=0 THEN                                                 09521300
    BEGIN                                   % REPLACING FIRST           09521400
         STREAM(LISTP1TOP6,P7~SOURCE);%                                 09521500
         BEGIN                                                          09521600
              DI~DI+P6; SI~LOC P5; SI~SI-1;                             09521700
              P3(63(63(IF SC=DC THEN JUMP OUT 3 TO REP; SI~SI-1));%     09521800
                  2(63(IF SC=DC THEN JUMP OUT 3 TO REP; SI~SI-1));%     09521900
                       IF SC=DC THEN JUMP OUT 1 TO REP; SI~SI-1; );%    09522000
              P2(63(IF SC=DC THEN JUMP OUT 2 TO REP; SI~SI-1));%        09522100
                 P2(IF SC=DC THEN JUMP OUT 1 TO REP; SI~SI-1);%         09522200
                 P1(IF SC=DC THEN JUMP OUT 1 TO REP; SI~SI-1);%         09522300
              GO TO XYT;                                                09522400
         REP: REPLACECHR;                                               09522500
         XYT:                                                           09522600
         END STREAM;                                                    09522700
    END ELSE IF TYPE=1 THEN                                             09522800
    BEGIN                                   % REP AND/OR TALLYING ALL   09522900
         STREAM(P0~0:LISTP1TOP6,P7~3-CODE)"0=REP&TALLY,1=TALLY ONLY,    09523000
                2=REP ONLY"(P8~SOURCE);%                                09523100
         BEGIN                                                          09523200
              DI~DI+P6; SI~LOC P5; SI~SI-1;%                            09523300
              P3(63(63(IF 1 SC=DC THEN%                                 09523400
                   BEGIN CI~CI+P7; GO TO TALL1; GO TO TALL1; GO TO REP1;09523500
                   TALL1: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09523600
                          CI~CI+P7; GO TO REP1; GO TO NXT1;%            09523700
                   REP1:  REPLACECHR; SI~LOC P5;%                       09523800
                   END;%                                                09523900
                   NXT1:  SI~SI-1;)));%                                 09524000
              P3( 2(63(IF 1 SC=DC THEN%                                 09524100
                   BEGIN CI~CI+P7; GO TO TALL2; GO TO TALL2; GO TO REP2;09524200
                   TALL2: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09524300
                          CI~CI+P7; GO TO REP2; GO TO NXT2;%            09524400
                   REP2:  REPLACECHR; SI~LOC P5;%                       09524500
                   END;%                                                09524600
                   NXT2:  SI~SI-1;)));%                                 09524700
              P3(      IF 1 SC=DC THEN%                                 09524800
                   BEGIN CI~CI+P7; GO TO TALL3; GO TO TALL3; GO TO REP3;09524900
                   TALL3: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09525000
                          CI~CI+P7; GO TO REP3; GO TO NXT3;%            09525100
                   REP3:  REPLACECHR; SI~LOC P5;%                       09525200
                   END;%                                                09525300
                   NXT3:  SI~SI-1;);%                                   09525400
                 P2(63(IF 1 SC=DC THEN%                                 09525500
                   BEGIN CI~CI+P7; GO TO TALL4; GO TO TALL4; GO TO REP4;09525600
                   TALL4: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09525700
                          CI~CI+P7; GO TO REP4; GO TO NXT4;%            09525800
                   REP4:  REPLACECHR; SI~LOC P5;%                       09525900
                   END;%                                                09526000
                   NXT4:  SI~SI-1;));%                                  09526100
                    P2(IF 1 SC=DC THEN%                                 09526200
                   BEGIN CI~CI+P7; GO TO TALL5; GO TO TALL5; GO TO REP5;09526300
                   TALL5: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09526400
                          CI~CI+P7; GO TO REP5; GO TO NXT5;%            09526500
                   REP5:  REPLACECHR; SI~LOC P5;%                       09526600
                   END;%                                                09526700
                   NXT5:  SI~SI-1;);%                                   09526800
                    P1(IF 1 SC=DC THEN%                                 09526900
                   BEGIN CI~CI+P7; GO TO TALL6; GO TO TALL6; GO TO REP6;09527000
                   TALL6: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09527100
                          CI~CI+P7; GO TO REP6; GO TO NXT6;%            09527200
                   REP6:  REPLACECHR; SI~LOC P5;%                       09527300
                   END;%                                                09527400
                   NXT6:  SI~SI-1;);%                                   09527500
         END STREAM;                                                    09527600
    END ELSE                                                            09527700
    BEGIN                                   %REP/TALLY UNTIL 1ST/LEADING09527800
         STREAM(P0~0:LISTP1TOP6,P7~3-CODE.[46:2],P8~CODE.[45:1],%       09527900
                P9~SOURCE);%                                            09528000
         BEGIN                                                          09528100
              DI~DI+P6; SI~LOC P5; SI~SI-1;%                            09528200
              P3(63(63(CI~CI+P8; GO TO REPL1; GO TO REPUF1;%            09528300
                   REPL1: IF 1SC!DC THEN JUMP OUT 3 TO XYT1;GO TO DOIT1;09528400
                   REPUF1: IF 1SC=DC THEN JUMP OUT 3 TO XYT1;%          09528500
                   DOIT1: CI~CI+P7; GO TO TALL1; GO TO TALL1;GO TO REP1;09528600
                   TALL1: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09528700
                          CI~CI+P7; GO TO REP1; GO TO NXT1;%            09528800
                   REP1:  REPLACECHR; SI~LOC  P5;%                      09528900
                   NXT1:  SI~SI-1 ))); GO TO L2;      XYT1: GO TO XYT2; 09529000
         L2:  P3( 2(63(CI~CI+P8; GO TO REPL2; GO TO REPUF2;%            09529100
                   REPL2: IF 1SC!DC THEN JUMP OUT 3 TO XYT2;GO TO DOIT2;09529200
                   REPUF2:IF 1SC=DC THEN JUMP OUT 3 TO XYT2;%           09529300
                   DOIT2: CI~CI+P7; GO TO TALL2; GO TO TALL2;GO TO REP2;09529400
                   TALL2: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09529500
                          CI~CI+P7; GO TO REP2; GO TO NXT2;%            09529600
                   REP2:  REPLACECHR; SI~LOC  P5;%                      09529700
                   NXT2:  SI~SI-1 ))); GO TO L3;      XYT2: GO TO XYT3; 09529800
         L3:  P3(      CI~CI+P8; GO TO REPL3; GO TO REPUF3;%            09529900
                   REPL3: IF 1SC!DC THEN JUMP OUT 1 TO XYT3;GO TO DOIT3;09530000
                   REPUF3:IF 1SC=DC THEN JUMP OUT 1 TO XYT3;%           09530100
                   DOIT3: CI~CI+P7; GO TO TALL3; GO TO TALL3;GO TO REP3;09530200
                   TALL3: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09530300
                          CI~CI+P7; GO TO REP3; GO TO NXT3;%            09530400
                   REP3:  REPLACECHR; SI~LOC  P5;%                      09530500
                   NXT3:  SI~SI-1 ); GO TO L4;        XYT3: GO TO XYT4; 09530600
         L4:     P2(63(CI~CI+P8; GO TO REPL4; GO TO REPUF4;%            09530700
                   REPL4: IF 1SC!DC THEN JUMP OUT 2 TO XYT4;GO TO DOIT4;09530800
                   REPUF4:IF 1SC=DC THEN JUMP OUT 2 TO XYT4;%           09530900
                   DOIT4: CI~CI+P7; GO TO TALL4; GO TO TALL4;GO TO REP4;09531000
                   TALL4: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09531100
                          CI~CI+P7; GO TO REP4; GO TO NXT4;%            09531200
                   REP4:  REPLACECHR; SI~LOC  P5;%                      09531300
                   NXT4:  SI~SI-1 )); GO TO L5;       XYT4: GO TO XYT5; 09531400
         L5:        P2(CI~CI+P8; GO TO REPL5; GO TO REPUF5;%            09531500
                   REPL5: IF 1SC!DC THEN JUMP OUT 1 TO XYT5;GO TO DOIT5;09531600
                   REPUF5:IF 1SC=DC THEN JUMP OUT 1 TO XYT5;%           09531700
                   DOIT5: CI~CI+P7; GO TO TALL5; GO TO TALL5;GO TO REP5;09531800
                   TALL5: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09531900
                          CI~CI+P7; GO TO REP5; GO TO NXT5;%            09532000
                   REP5:  REPLACECHR; SI~LOC  P5;%                      09532100
                   NXT5:  SI~SI-1 ); GO TO L6;        XYT5: GO TO XYT;  09532200
         L6:        P1(CI~CI+P8; GO TO REPL6; GO TO REPUF6;%            09532300
                   REPL6: IF 1SC!DC THEN JUMP OUT 1 TO XYT; GO TO DOIT6;09532400
                   REPUF6:IF 1SC=DC THEN JUMP OUT 1 TO XYT;%            09532500
                   DOIT6: CI~CI+P7; GO TO TALL6; GO TO TALL6;GO TO REP6;09532600
                   TALL6: SI~P0; SI~SI+8; P0~SI; SI~LOC P5;%            09532700
                          CI~CI+P7; GO TO REP6; GO TO NXT6;%            09532800
                   REP6:  REPLACECHR; SI~LOC  P5;%                      09532900
                   NXT6:  SI~SI-1 );%                                   09533000
         XYT:%                                                          09533100
         END STREAM;%                                                   09533200
    END;%                                                               09533300
         IF CODE.[46:1] THEN P(RTN);%                                   09533400
    END COBOLVARSZ;%                                                    09533500
PROCEDURE COBOLIONONDSK;     % PRONOUNCED COBOL-IO-NON-DISK             09600000
         BEGIN                                                          09600100
         REAL CODE      = -1;     % 0=READ,1=WRITE,6=WRTBLK             09600200
         NAME DLOC      = -2;     % POINTS TO BUFFER IO DESCRIPTOR      09600300
         REAL NUMWDS    = -3,     % # WDS TO BE WRITTEN                 09600400
              KEY       = -4,     % CARRIAGE RETURN                     09600500
              CHNNL     = -4,     % LP CHANNEL SKIP                     09600600
              LINES     = -5,     % # LINES TO BE SPACED                09600700
              SKIPBFR   = -6;     % 1=SPACE BEFORE PRINT                09600800
INTEGER                                                                 09600900
              LINAGE    = -7;     % LINE PRINTER: [1:1]=1 IF LINAGE     09601000
                                  % CLAUSE PRESENT,[33:15]= LINAGE LIMIT09601100
                                  % ON NEXT END-OF-PAGE                 09601200
%LOCALS                                                                 09601300
        REAL  IOMASK;                                                   09601400
        ARRAY FIB [*];            % FIB ARRAY                           09601500
        REAL  FILECTRL  = 12,     % USED TO CALL COBOLFCR               09601600
              PERFORMGEN= 13,     % USED FOR PERFORMING USE ROUTINES    09601700
              COBOLIODSK= 15;                                           09601800
        NAME  FLOC;               % POINTER TO FIB                      09601900
        ARRAY FPB       = 3[*];   % FILE PARAMETER BLOCK                09602000
        NAME  MEM       =  2;     % DUMMY DATA DESC                     09602100
        ARRAY PGUSE     = 24[*];  % PROGRAM USE ROUTINES                09602200
        REAL  RTOG,               % 1=I/O DONE THIS ROUND               09602300
              T,RT,               % TEMPORARY                           09602400
              CTOG,               % 1=INHIBIT TRANSFER OF RECORD TO     09602500
                                  % BUFFER ON TECHNIQUE-C WRITE         09602600
              UNITYPE,            % STORE UNIT TYPE FOR MANY TESTS      09602700
              ENDREEL;            % USED ONLY ON READ                   09602800
        ARRAY DEST[*];            % DESTINATION IN MOVEREC              09602900
DEFINE                                                                  09603000
        AF              = [12:12]#,          % FILE USE ROUTINE         09603100
        ARR             = [36:12]#,          % REEL USE ROUTINE         09603200
        ARROW           = P(0,NOT,NUMWDS,TIP,INX,~)#,                   09603300
                                  % THIS INSERTS THE GROUP MARK         09603400
        BCOUNT          = FIB[6]#,          % BLOCK COUNT               09603500
        BINARY          = FIB[13].[24:1]#,  % 1=BINARY,0=ALPHA          09603600
        BF              = [1:11]#,           % FILE USE ROUTINE         09603700
        BREAK           = FIB[9] ! 0 #   ,  % BREAKOUT RESTART POINT    09603800
        BREAKOUT        = IF(RCOUNT MOD FIB[9])=0 THEN                  09603900
                            P(0,0,12,COM,DEL,DEL)#,% CALL BREAKOUT      09604000
        BRR             = [24:12]#,          % REEL USE ROUTINE         09604100
        BUFFNUM         = FIB[13].[1:9] #,  % # OF BUFFS REQUSTED       09604200
        BUFFSIZE        = FIB[18].[3:15]#,  % BUFFER SIZE  (REQUESTED)  09604300
        BUFFSZ          = FIB[18][8:8:10]#, % SIZE FOR CONCATINATES     09604400
        BUFTOP          = FIB[16]#,% COPY OF TOP IOD: POINTS TO BEG BUFF09604500
        CHECK(CHECK1)   = IF P(DUP)!(CHECK1) THEN P(CHECK1,0,FLOC,#,    09604600
         ONERR(ONERR1)  =   ONERR1,17,COM,DEL,DEL,DEL,DEL);    P(DEL)#, 09604700
                                  % THE ABOVE ARE USED ON BLOCK+REC CHKS09604800
        CLOSEANDOPEN    =P(MKS,1,0,FLOC,4,FILECTRL, %CLOSE NO RWD       09604900
                           MKS,FLOC,1,FILECTRL)#,   % OPEN INPUT        09605000
        COUNT           = FIB[12] #,        % USED FOR BLOCKING TECH-A,B09605100
        DELAY           = TIP.[20:1] #,     % THIS ALLOWS ONE CYCLE DELY09605200
        DISK            = (UNITYPE~(FIB[4].[8:4]))=4#,                  09605300
        DONE            = TIP.[19:1] #,     % 1= IO COMPLETED           09605400
        ENDFILE         = FIB[5].[40:1] #,  % ALREADY PASSED EOF        09605500
        ENDPROCESS      = FIB[5].[39:2]#,   % SEE OPTIONAL AND ENDFILE  09605600
        EOF             =((*DLOC).[27:1])#, % FIRST EOF OR EOT          09605700
        FNAM            = FIB[4].[13:11]#,  % FILE NAME INDEX IN FPB    09605800
        FOREVER         =(NOT 0).[9:39] #,  % UNTIL END TIME            09605900
        HOWOPEN         = FIB[5].[41:3]#,   % 1=OPEN INPUT,0= OPEN OUTPT09606000
                                            % 1 > CLOSED                09606100
        INFILE          = FIB[13].[27:1]#,   % FILE OPEN INPUT          09606200
        INVALIDUSER     = FIB[5]<0#,        % INVALID USER NOT PARITY   09606300
        INXLINAGE       = P(LOCOFCTR,DUP,LOD,LINES,ADD,XCH,~)#,         09606400
        IOERR(IOERR1)   = P(0,FLOC,IOERR1,17,COM,DEL,DEL,DEL)#,         09606500
                             % ABOVE CALLS IOERROR ROUTINE              09606600
        LABELED         = NOT FIB[4].[2:1]#,                            09606700
        LABEQ           = FIB[5].[17:1] #,  % LABEL EQUATED FROM DISK   09606800
        LBLPTR          = FLOC[1] #,        % LABEL POINTER             09606900
        LINAGELIM       = FIB[1]#,     % LOGICAL LENGTH OF PRINTED PAGE 09607000
        LINEPRINT       = UNITYPE=1 OR UNITYPE=7 OR UNITYPE=12 #,       09607100
                             % 1= LP , 7 = PBT , 12 = PBD               09607200
        LINTOG          = LINAGE.[1:1]#,     % TRUE IF LINAGE PRESENT   09607300
        LOCOFCTR        = FIB[3]#,           % PRT LOC OF LINAGE COUNTER09607400
        MABUSE          = FIB[4].[1:1]#,     % MAY BE USE RTNS PRESENT  09607500
        MAXR            = FIB[18][8:38:10]#,% MAX REC SZ FOR CONCATS    09607600
        MAXREC          = FIB[18].[33:15]#, % MAX REC SZ                09607700
        MINREC          = FIB[18].[CF]#,     % MINIMUM RECORD SIZE      09607800
        NONSTD          = FIB [5].[16: 1]#, % NON-STANDARD LABELS       09607900
        NUMBUF          = FIB[13].[10: 9]#, % NUMBER OF BUFFERS ASSIGNED09608000
        NUMREC          = FIB[11] #,        % RECORDS PER BLOCK         09608100
        NXTLINAGE       = LINAGE.[33:15]#,   % PRINTER: LINAGE LIMIT    09608200
        NXTREEL         = P(MKS,2,1,FLOC,4, % THIS DOES REEL SWITCHING  09608300
                           FILECTRL)#,      %                           09608400
        OPTIONAL        = FIB[ 5].[39:1]#,  % OPTIONAL FILE NOT PRESENT 09608500
        PARITY          = TIP.[28:1]#,      % PARITY BIT ON DESC        09608600
        PBIT            = [2:1]#,           % PRESENCE BIT              09608700
        PRESENT         =((*DLOC).[2:1])#,  % CHECKS PRESENTSBIT        09608800
        PROPER          =21+CODE+CODE+REVERSE#,% GENERATES PROPER IOERR 09608900
        PUNCH           = UNITYPE=6#,  % UNIT IS CARD PUNCH             09609000
        RCOUNT          = FIB[7] #,         % RECORD COUNT              09609100
        RCPRT           = (FIB[20].[FF])#,  %PRT OF DESC POINTING TO REC09609200
        READER          =(UNITYPE MOD 11=0)#,% 0=READER 11=PSUDOREADER  09609300
        READLBL         =P(DLOC INX 0,11,11  % THIS READS THE LABEL.    09609400
                          ,COM,DEL,DEL)#,    %                          09609500
        RECPERBLK       = H[0].[30:12] #,    % RECORDS PER BLOCK        09609600
        REMOTEIO        =P(BUFFSIZE,DLOC,   % READ & WRITE BATCH SYSTEM 09609700
                         FOREVER,LINES,KEY=0,CFX,TIP,CODE,36,COM,  %FOR 09609800
                         DEL,DEL,DEL,DEL,DEL,1,SUB,RTN)#,%TYPE 19 FILES 09609900
        REMOTEREAD      =P(BUFFSIZE,TIP,0,  % READ FOR TSS              09610000
                         (-13),COM,0,RTN)#, %                           09610100
        REMOTEWRIT      =P(TIP,NUMWDS  |8,  % WRITE FOR TSS             09610200
                         LINES,KEY,CFX,0,(-11),COM,DEL,RTN)#,           09610300
        REVERSE         = FIB[5].[44:1] #,  % 1=REVERSE                 09610400
        SETPRESENCEBIT  =P(TIP OR MEM ,DLOC,~)#,% SET PRESENCE BIT      09610500
$ INCLUDE 09610701, IF TIMESHARING;                                     09610600
        SLEEP           = 36 #,                                         09610700
$ OMIT    09610901, IF TIMESHARING;                                     09610800
        SLEEP           =  2 #,                                         09610900
        TAPEE           = TIP.[7:1] #,       % 1= TAPES   0=ALL ELSE    09611000
        TECHA           =(FIB[5].[46:2]=1) #,% TECHNIQUE-A              09611100
        TECHC           =(FIB[5].[46:2]=3) #,% TECHNIQUE-C              09611200
        TERM(TERM1)     = P(1,FLOC,TERM1,17,COM)#,%TERMINATE I/O ERROR  09611300
        TIP             = (*DLOC) #,         % LOAD I/O DESC            09611400
        TOSZF           = [8:38:10]#,                                   09611500
        UNBLKD          = (FIB[5].[46:2]=0)#, % 1 RECORD PER BLOCK      09611600
        WAITIO          = P(DLOC,IOMASK,     % THIS SLEEPS ON I/O       09611700
                         SLEEP,COM,DEL,DEL)#,% WAITING FOR A COMPLETE   09611800
        WORDSLEFT       = FIB[17]#;          % WORDS LEFT IN BUFFER     09611900
LABEL LPRETURN,START,SETUP,EOFSETCK,C,IMPROPER;                         09612000
SUBROUTINE GOUSE;       % CALLS USE ROUTINES                            09612100
    BEGIN P(MKS,[FIB],T,0,PERFORMGEN); END;%                            09612200
SUBROUTINE INPUTPARITY;%                                                09612300
    BEGIN%                                                              09612400
         SETPRESENCEBIT;%                                               09612500
         IF (T ~ RT ~ PGUSE[4].BRR)!0 THEN GOUSE; % INPUT ERROR USE RTN 09612600
         IF (T ~ FIB[15].BF) ! 0 THEN GOUSE;                            09612700
         IF RTOG THEN IF REVERSE THEN IOERR(29) ELSE%                   09612800
              IF (T OR RT)=0 THEN IOERR(19);%                           09612900
    END INPUTPARITY;%                                                   09613000
SUBROUTINE OUTPUTERROR;%                                                09613100
    BEGIN%                                                              09613200
         IF NOT EOF THEN % TAPE WRITE PARITY OR BLANK TAPE              09613300
              BEGIN     % OUTPUT ERROR USE ROUTINES                     09613400
                   IF (T ~ PGUSE[5].BRR)!0 THEN GOUSE;%                 09613500
              IF (T ~ FIB[15].BF) ! 0 THEN GOUSE;                       09613600
                   TERM(20);%                                           09613700
              END;%                                                     09613800
         SETPRESENCEBIT;%                                               09613900
         NXTREEL;  % REEL SWITCH                                        09614000
    END OUTPUTERROR;%                                                   09614100
SUBROUTINE  INPUTEOFEOR;                                                09614200
              BEGIN     % EOF OR EOR                                    09614300
                   ENDFILE ~ TRUE;%                                     09614400
                   SETPRESENCEBIT;%                                     09614500
                   IF READER OR REVERSE THEN P(1,RTN);%                 09614600
                   IF LABELED THEN%                                     09614700
                        BEGIN%                                          09614800
                        READLBL;%                                       09614900
                        STREAM(SENT~0,BC~0,RC~0:L~5 INX LBLPTR);        09615000
                             BEGIN          % THIS RETREIVES END OF REEL09615100
                             DI~LOC SENT;   % SENTINEL,BLOCK & REC COUNT09615200
                             DI~DI+7; SI~L; SI~SI-1;%                   09615300
                             DS~CHR; DS~5 OCT; DS~7 OCT;%               09615400
                             END;%                                      09615500
                        CHECK(RCOUNT-1) ONERR(16);%                     09615600
                        CHECK(BCOUNT-1) ONERR(17);%                     09615700
                        ENDREEL ~ P;        % STORE SENTINEL            09615800
                        IF MABUSE THEN%                                 09615900
                             BEGIN          % END INPUT REEL USE RTNS   09616000
                                  IF (T~PGUSE[1].BRR)!0 THEN GOUSE;%    09616100
                                  IF (T~PGUSE[1].ARR)!0 THEN GOUSE;%    09616200
                                  IF NOT ENDREEL THEN%                  09616300
                                      BEGIN % END INPUT FILE USE RTNS   09616400
                                      IF (T~PGUSE[1].BF)!0 THEN GOUSE;  09616500
                                      IF (T~PGUSE[1].AF)!0 THEN GOUSE;  09616600
                                      END;%                             09616700
                                  IF (T~FIB[2].BRR)!0 THEN GOUSE; % END 09616800
                                  IF (T~FIB[2].ARR)!0 THEN GOUSE; % REEL09616900
                                  IF NOT ENDREEL THEN%                  09617000
                                      BEGIN % END FILE USE ROUTINES%    09617100
                                      IF (T~FIB[2].BF)!0 THEN GOUSE;%   09617200
                                      IF (T~FIB[2].AF)!0 THEN GOUSE;%   09617300
                                      END;%                             09617400
                             END USE;%                                  09617500
                        END LABELED;%                                   09617600
                   IF LABELED AND NOT ENDREEL THEN P(1,RTN);%           09617700
                   IF NONSTD THEN%                                      09617800
                        BEGIN%                                          09617900
                        ENDFILE ~ FALSE;%                               09618000
                        CLOSEANDOPEN;%                                  09618100
                        P(1,RTN);%                                      09618200
                        END;%                                           09618300
                   BCOUNT ~ *P(DUP)-1;%                                 09618400
                   RCOUNT ~ *P(DUP)-1;%                                 09618500
                   NXTREEL;%                                            09618600
                   P(DEL,DEL);      % DELETE BRANCH RETURNS             09618700
                   GO TO START;%                                        09618800
    END  INPUTEOFEOR;                                                   09618900
SUBROUTINE MOVEREC;     % MOVES RECORD BETWEEN WORK AREA AND BUFFER     09619000
    BEGIN%                                                              09619100
         IF NOT DONE THEN WAITIO;%                                      09619200
         P(*RCPRT,TIP INX 0);                                           09619300
         IF NOT PRESENT THEN                % MAY BE ERROR OR EOF       09619400
              IF CODE THEN                                              09619500
                   IF EOF THEN OUTPUTERROR                              09619600
                        ELSE P(XCH,P(DUP).[8:10],.NUMWDS,ISD)           09619700
                   ELSE IF EOF THEN INPUTEOFEOR;                        09619800
         DEST ~ IF CODE THEN P ELSE P(XCH);%                            09619900
         STREAM(FROM~P:NUMWDS,E~P(DUP).[36:6],X~DEST);%                 09620000
              BEGIN%                                                    09620100
                   SI~FROM;E(DS~32 WDS;DS~32 WDS); DS~NUMWDS WDS;%      09620200
              END;%                                                     09620300
         P(DEL);%                                                       09620400
         IF NOT PRESENT THEN                % PARITY ERROR OCCURED      09620500
              IF CODE THEN OUTPUTERROR ELSE INPUTPARITY;                09620600
    END MOVEREC;%                                                       09620700
SUBROUTINE DIDDLEREC;   % ADJUSTS TOP IOD AND COUNTERS TO NEXT RECORD   09620800
    BEGIN                                                               09620900
         MOVEREC;%                                                      09621000
         WORDSLEFT ~ T;%                                                09621100
         DLOC[0] ~ NUMWDS INX TIP;%                                     09621200
         RCOUNT ~ *P(DUP)+1;%                                           09621300
         IF BREAK THEN BREAKOUT;%                                       09621400
         IF PARITY THEN INPUTPARITY;%                                   09621500
    END DIDDLEREC;%                                                     09621600
SUBROUTINE PREL;        % DOES ACTUAL I/O                               09621700
    BEGIN%                                                              09621800
         P(TIP,DLOC,PRL,DEL);          % DO IO                          09621900
         RCOUNT ~ *P(DUP)+1;           % COUNT RECORDS                  09622000
         BCOUNT ~ *P(DUP)+(RTOG~1);    % COUNT BLOCK & SET RTOG         09622100
         IF BREAK THEN BREAKOUT;%                                       09622200
    END PREL;%                                                          09622300
SUBROUTINE SKIPPER;     % DOES SKIPPING ON LINE PRINTER                 09622400
    BEGIN%                                                              09622500
         NUMBUF ~ 1;%               % INHIBIT BUFFER ROTATION           09622600
         IF CHNNL!0 THEN LINES~1;%                                      09622700
         DLOC[0] ~ TIP & 1 [18:47:1] & (16+CHNNL) [27:42:6];%           09622800
         FOR T~2 STEP 2 UNTIL LINES DO%                                 09622900
              BEGIN%                                                    09623000
                   PREL;%                                               09623100
                   IF NOT DONE THEN WAITIO;%                            09623200
                   IF NOT PRESENT THEN%                                 09623300
                        IF EOF THEN SETPRESENCEBIT ELSE OUTPUTERROR;%   09623400
              END;%                                                     09623500
         IF LINES THEN%                                                 09623600
              BEGIN%                                                    09623700
                   DLOC[0] ~ TIP & (2-(2|(CHNNL!0)))[27:46:2];%         09623800
                   PREL;%                                               09623900
                   IF NOT DONE THEN WAITIO;%                            09624000
                   IF NOT PRESENT THEN%                                 09624100
                        IF EOF THEN SETPRESENCEBIT ELSE OUTPUTERROR;    09624200
              END;%                                                     09624300
         NUMBUF  ~ BUFFNUM;  % RESTORE NO. OF BUFFERS FOR ROTATION      09624400
    END SKIPPER;%                                                       09624500
SUBROUTINE REVREAD;     % DOES READ REVERSE I/O                         09624600
    BEGIN%                                                              09624700
         DLOC[0] ~ FLAG(BUFTOP);%                                       09624800
         PREL;%                                                         09624900
         IF NOT DONE THEN WAITIO;                                       09625000
         BUFTOP.[CF] ~ TIP;%                                            09625100
         WORDSLEFT ~ MEM[1 INX TIP];%                                   09625200
    END REVREAD;%                                                       09625300
SUBROUTINE READREV;     % HANDLES A READ REVERSE                        09625400
    BEGIN%                                                              09625500
         IF NOT TECHA THEN%                                             09625600
              BEGIN     % UNBLOCKED                                     09625700
                   REVREAD;%                                            09625800
                   DLOC[0] ~ NOT(WORDSLEFT-2) INX TIP;%                 09625900
                   MOVEREC;%                                            09626000
              END%                                                      09626100
         ELSE           % TECHA                                         09626200
              IF (WORDSLEFT~T){0 THEN%                                  09626300
                   BEGIN%                                               09626400
                        REVREAD;%                                       09626500
                        DLOC[0] ~ (NOT(MAXREC-2) INX TIP) & MAXR;%      09626600
                        MOVEREC;%                                       09626700
                   END ELSE%                                            09626800
                   BEGIN%                                               09626900
                        DLOC[0] ~ NOT(NUMWDS-1) INX%                    09627000
                                   (TIP & (NOT TIP) [2:28:1]);%         09627100
                        MOVEREC;%                                       09627200
                        RCOUNT ~ *P(DUP)+1;%                            09627300
                   END;%                                                09627400
    END READREV;%                                                       09627500
SUBROUTINE WRIT;        % WRITES A BLOCK                                09627600
    BEGIN%                                                              09627700
         IF NOT CTOG THEN MOVEREC;%                                     09627800
         COUNT ~ NUMREC;%                                               09627900
         NUMWDS ~ (WORDSLEFT~BUFFSIZE)-T; % SIZE OF BLOCK TO BE WRITTEN 09628000
         IF LINEPRINT THEN%                                             09628100
              BEGIN%                                                    09628200
                   IF LINTOG THEN INXLINAGE;%                           09628300
                   IF SKIPBFR THEN     % SPACING BEFORE PRINT           09628400
                        BEGIN%                                          09628500
                             SKIPPER;%                                  09628600
                             LINES ~ CHNNL ~ 0;%                        09628700
                             GO TO SETUP;%                              09628800
                        END;%                                           09628900
                   IF CHNNL!0 OR LINES{2 THEN%                          09629000
              SETUP:    DLOC[0] ~ FLAG(BUFTOP & LINES [27:47:1]%        09629100
                                              & LINES [28:46:1]%        09629200
                                              & CHNNL [29:44:4])%       09629300
                   ELSE%                                                09629400
                        BEGIN%                                          09629500
                        DLOC[0] ~ FLAG(BUFTOP & @20 [27:42:6]);%        09629600
                        PREL;%                                          09629700
                        IF NOT DONE THEN WAITIO;%                       09629800
                        IF NOT PRESENT THEN OUTPUTERROR;%               09629900
                        LINES ~ LINES-2;%                               09630000
                        SKIPPER;%                                       09630100
                        GO TO LPRETURN;%                                09630200
                        END;%                                           09630300
              END LINEPRINTER%                                          09630400
         ELSE DLOC[0] ~ FLAG(BUFTOP & NUMWDS TOSZF);% FOR TECHS B & C   09630500
         IF TAPEE THEN IF NOT BINARY THEN ARROW ELSE                    09630600
              ELSE IF PUNCH THEN DLOC[0] ~ TIP & CHNNL[32:47:1];        09630700
         PREL;%                                                         09630800
         IF UNITYPE=12 AND NOT DONE THEN WAITIO;                        09630900
LPRETURN:BUFTOP.[CF] ~ TIP;%                                            09631000
         IF LINTOG THEN IF (*P(LOCOFCTR))>LINAGELIM THEN%               09631100
              BEGIN%                                                    09631200
                   P(0,LOCOFCTR,~);%                                    09631300
                   LINAGELIM ~ NXTLINAGE;%                              09631400
                   P(1,RTN);%                                           09631500
              END;%                                                     09631600
    END WRIT;%                                                          09631700
SUBROUTINE REED;        % READS A BLOCK                                 09631800
    BEGIN%                                                              09631900
         IF NUMWDS<1 AND RCOUNT>0 THEN TERM(26);%                       09632000
         DLOC[0] ~ FLAG(FIB[16]);%                                      09632100
         PREL;%                                                         09632200
         BUFTOP.[CF] ~ TIP;%                                            09632300
         MOVEREC;%                                                      09632400
         WORDSLEFT ~ MEM[(NOT 0) INX TIP];%                             09632500
         DLOC[0] ~ NUMWDS INX TIP;%                                     09632600
    END REED;%                                                          09632700
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% START HERE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%09632800
         FIB ~ *(FLOC ~ (NOT 2) INX DLOC);%                             09632900
         IF DISK THEN GO TO P(COBOLIODSK);%                             09633000
         IOMASK ~ @2000000000;%                                         09633100
   START:IF NOT(ENDPROCESS=0 OR CODE) THEN GO TO EOFSETCK;              09633200
         IF CODE=6 THEN      % WRITE BLOCK                              09633300
              IF HOWOPEN!0 THEN GO TO IMPROPER ELSE%                    09633400
                   BEGIN%                                               09633500
                        IF (T~WORDSLEFT)=BUFFSIZE THEN P(0,RTN);%       09633600
                        RCOUNT ~ *P(DUP)-1;%                            09633700
                        WRIT;%                                          09633800
                        P(0,RTN);%                                      09633900
                   END WRITE BLOCK;%                                    09634000
         IF CODE>1 THEN IF CODE!6 THEN TERM(25);    % UNRECOGNIZED CODE 09634100
IMPROPER:IF (1-CODE)!HOWOPEN THEN      % CHECK USE VS HOW OPEN          09634200
              IF HOWOPEN>1 THEN TERM(31+CODE)    % CLOSED               09634300
              ELSE TERM(PROPER);%                % USAGE                09634400
         IF UNITYPE=13 THEN                                             09634500
$INCLUDE 09634701  ,IF TIMESHARING;                                     09634600
              BEGIN IF NOT CODE THEN REMOTEREAD; REMOTEWRIT; END;       09634700
$OMIT    09634901  ,IF TIMESHARING;                                     09634800
                   REMOTEIO;                                            09634900
         T ~ WORDSLEFT - (NUMWDS~NUMWDS); % T=NXT WORDSLEFT             09635000
         IF CODE THEN                  % WRITE                          09635100
              BEGIN%                                                    09635200
                   IF TECHC THEN%                                       09635300
                        BEGIN%                                          09635400
                        IF NUMWDS>MAXREC THEN%                          09635500
                             T ~ WORDSLEFT - (NUMWDS~MAXREC);%          09635600
              C:        IF T}MINREC THEN DIDDLEREC  % RECORD NOW IN WORK09635700
                             ELSE                   % AREA WILL FIT     09635800
                                                    %NEXT RECORD MAY FIT09635900
                        IF T<0 THEN             % REC NOW IN WA WONT FIT09636000
                             BEGIN%                                     09636100
                             T ~ WORDSLEFT; % UNUSED PORTION OF BUFFER  09636200
                             CTOG ~ TRUE;   % WRITE BLOCK WITHOUT       09636300
                             WRIT;          % RECORD NOW IN WA          09636400
                             CTOG ~ FALSE;                              09636500
                             T ~ WORDSLEFT-NUMWDS; % NEW WORDSLEFT      09636600
                             GO TO C;       % NOW PROCESS RECORD IN WA  09636700
                             END%                                       09636800
                        ELSE WRIT; % 0<T<MINREC: CANT FIT ANOTHER RECORD09636900
                        END ELSE    % NOT TECHC                         09637000
                        IF (COUNT~*P(DUP)-1)>0 THEN DIDDLEREC ELSE WRIT;09637100
                   P(0,RTN);%                                           09637200
              END WRITE;%                                               09637300
         IF REVERSE THEN READREV ELSE % READ                            09637400
              IF T<1 OR UNBLKD THEN REED ELSE%                          09637500
                   IF NUMWDS<1 THEN GO TO EOFSETCK ELSE DIDDLEREC;%     09637600
         P(0,RTN);%                                                     09637700
EOFSETCK:          IF ENDFILE THEN TERM (15);                           09637800
                   ENDFILE ~ TRUE ;                                     09637900
                   P(1,RTN);                                            09638000
% END OF EOF SET CHECK                                                  09638100
END COBOLIONONDISK;                                                     09638200
PROCEDURE COBOLIODSK;                                                   09700000
         BEGIN                                                          09700100
         REAL RCW       = +0;     %USED TO CALL COBOLIONONDSK           09700200
         REAL CODE      = -1;     % 0=READ,1=WRITE,2=SEEK,6=WRTBLK,     09700300
         NAME DLOC      = -2;     % POINTS TO BUFFER I/O DESC           09700400
         REAL NUMWDS    = -3;     % # WDS TO BE WRITTEN                 09700500
%LOCALS                                                                 09700600
        INTEGER  BS ;             % USED IN COMPUTING DISK ADDR         09700700
        REAL  COBOLIONONDSK= 14;                                        09700800
        REAL  DEST    ;           % DESTINATION IN RANDOM MOVE          09700900
        ARRAY FIB [*];            % FIB ARRAY                           09701000
        NAME  FLOC;               % POINTER TO FIB                      09701100
        ARRAY FPB = 3[*];         % FILE PARAMETER BLOCK                09701200
        ARRAY H[*];               % DISK FILE HEADER                    09701300
        REAL  INTINT    =  5;     % INTRINSIC INTRINSIC                 09701400
        NAME  MEM = 2;            % DUMMY DATA DESC                     09701500
        NAME  PERFORMER = 13;     % USED FOR PERFORMING USE ROUTINES    09701600
        ARRAY PGUSE=24[*];        % PROGRAM USE ROUTINES                09701700
        INTEGER  RT ;             % USED IN COMPUTING DISK ADDR         09701800
        REAL  T;                  % TEMPORARY                           09701900
        INTEGER  DAS;             % USED TO COMPUTE DISK ADDRESS        09702000
DEFINE                                                                  09702100
        AF              = [12:12]#,         % FILE USE ROUTINE          09702200
        ARR             = [36:12]#,         % REEL USE ROUTINE          09702300
        BCOUNT          = FIB[6]#,          % BLOCK COUNT               09702400
        BF              = [1:11]#,          % FILE USE ROUTINE          09702500
        BOUNDED         = FIB[9].[2:1]#,    % TRUE IF BOUNED FROM ABOVE 09702600
        BREAK           = FIB[9] ! 0 #   ,  % BREAKOUT RESTART POINT    09702700
        BREAKOUT        = IF(RCOUNT MOD FIB[9])=0 THEN                  09702800
                            P(0,0,12,COM,DEL,DEL)#,% CALL BREAKOUT      09702900
        BRR             = [24:12]#,         % REEL USE ROUTINE          09703000
        BUFFNUM         = FIB[13].[1:9] #,  % # OF BUFFS REQUSTED       09703100
        BUFFSIZE        = FIB[18].[3:15]#,  % BUFFER SIZE  (REQUESTED)  09703200
        BUFFSZ          = FIB[18][8:8:10]#, % SIZE FOR CONCATINATES     09703300
        BUFTOP          = FIB [16]#,        % USED ON I-O AND RANDOM    09703400
        COUNT           = FIB[12] #,        % USED FOR BLOCKING TECH-A,B09703500
        DINXPRT         = P(*RCPRT & TIP [CTC],RCPRT,~)#,%UPDATE POINTER09703600
        DONE            = TIP.[19:1] #,     % 1= IO COMPLETED           09703700
        DISK            = (UT =4)#,         % DISK IS UNIT TYPE OF 4    09703800
        ERBIT           = FIB[13].[19:1] #, % IOERR 19 NOT YET SPOUTED  09703900
        FLAGINWA        = 0[1:1:1]#,        % SAYS WE ARE IN WORK AREA  09704000
        FNAM            = FIB[4].[13:11]#,  % FILE NAME INDEX IN FPB    09704100
        ENDFILE         = FIB[5].[40:1] #,  % ALREADY PASSED EOF        09704200
        ENDPROCESS      = FIB[5].[39:2]#,   % SEE OPTIONAL AND ENDFILE  09704300
        EOF             =((*DLOC).[27:1])#, % FIRST EOF OR EOT          09704400
        GETSEG          = P(FPB[BS:=FNAM],FPB[BS+1],T,H,4,11,COM,DEL,DEL09704500
                            ,DEL,DEL,DEL)#, % THIS GETS A NEW DISK ROW  09704600
        KEY             = FIB[15].[12:10]#, % REL PRT LOC OF ACTUAL KEY 09704700
        HAVEWA          =(INWA OR FIB[20].[CF]>1)#,% TRUE IF WE ARE NOW 09704800
                        %IN WORK AREA OR HAVE MADE IT PRESENT PREVIOUSLY09704900
        HOWOPEN         = FIB[5].[41:3]#,   % 1=OPEN INPUT,0= OPEN OUTPT09705000
                                            % 1 > CLOSED                09705100
        INVALIDUSER     = FIB[5]<0#,        % INVALID USER NOT PARITY   09705200
        INWA            = FIB[20]}0#,       % SAYS WE ARE IN WORK AREA  09705300
        INXPRT          = P(NUMWDS INX *RCPRT,RCPRT,~)#,% UPDATE POINTER09705400
        IOERR(IOERR1)   = P(0,FLOC,IOERR1,17,COM,DEL,DEL,DEL)#,         09705500
                             % ABOVE CALLS IOERROR ROUTINE              09705600
        IOMASK          = 0&1[19:47:1] #,   % USED TO WAIT FOR IOFINISH 09705700
        LASTDONE        = FIB[13].[21:1] #, % NOT OF LAST OPERATION DONE09705800
        LBLPTR          = FLOC[1] #,        % LABEL POINTER             09705900
        LSUBL           = FIB [1]   #,      % LOWER BOUND FOR RANDOM    09706000
        LSUBU           = FIB [3] #,        % UPPER BOUND FOR DISK REC  09706100
        MABUSE          = FIB[4].[1:1]#,    % MAY BE USE RTNS PRESENT   09706200
        MAKEPRESENTWA   = P(*RCPRT & 1 [CTC],0,CDC)#,                   09706300
        MAXR            = FIB[18][8:38:10]#,% MAX REC SZ FOR CONCATS    09706400
        MAXREC          = FIB[18].[33:15]#, % MAX REC SZ                09706500
        MINREC          = FIB[18].[CF]#,    % MINIMUM RECORD SIZE       09706600
        NOAIT           = FIB[20].[3:1]#,   % AIT FOR WA WAS DESTROYED  09706700
        NUMBUF          = FIB[13].[10: 9]#, % NUMBER OF BUFFERS ASSIGNED09706800
        NUMBSPC         = H[9].[43:5] #,    % NUMBER OF ROWS SPECIFIED  09706900
        NUMREC          = FIB[11] #,        % RECORDS PER BLOCK         09707000
        OPENIO          = FIB[13].[22:1]#,  % 1= OPEN INPUT-OUPUT (DISK)09707100
        PARITY          = FIB[13].[20:1] #, % IO ERROR OCCURED IN BLOCK 09707200
        PBIT            = [2:1]#,           % PRESENCE BIT              09707300
        POINTPRTTOBUF   = P((*RCPRT OR MEM) & TIP [CTC],RCPRT,~)#,      09707400
        POINTPRTTOWA    = P(*RCPRT & FIB[20] [CTC],RCPRT,~)#,           09707500
        PRESENT         =((*DLOC).[2:1])#,  % CHECKS PRESENTSBIT        09707600
        PROPER          =21+CODE+CODE#,     % GENERATES PROPER IOERR    09707700
        RCOUNT          = FIB[7] #,         % RECORD COUNT              09707800
        RCPRT           = (FIB[20].[FF])#,  %PRT OF DESC POINTING TO REC09707900
        RECPERBLK       = H[0].[30:12] #,   % RECORDS PER BLOCK         09708000
        REDECWA         = P(MKS,RCPRT,MAXREC,1,1,1,INTINT)#,            09708100
                          % DECLARE SAVE ARRAY FOR WORK AREA            09708200
        REEDING         = ((*DLOC).[24:1])#,%LAST IO WAS READ           09708300
        RESETPANDERBIT  = FIB[13]:=*P(DUP)&0[19:19:2]#,%RESET ERR BITS  09708400
        RESETREADBIT    = 0[24:24:1]#,      % USED TO TURN OFF READ BIT 09708500
        REVERSE         = FIB[5].[44:1] #,  % 1=REVERSE INPUT           09708600
        ROWLGTH         = H[1]#,            % ROW LGTH FROM HEADER      09708700
        SAVEWADDR       = FIB[20]~*P(DUP)&*P(RCPRT)[CTC]#,% SAVE ADDRESS09708800
        SERIAL          = FIB[4].[27:3]=0 #,% FILE ACCESS = SERIAL      09708900
        SEGPERBLK       = H[0].[42:6] #,    % SEGMENTS PER BLOCK        09709000
        SETPANDERBIT    = FIB[13]:=*P(DUP)&3[19:46:2]#,                 09709100
                          % SET PARITY AND IOERR 19 BITS                09709200
        SETPRESENTSBIT  =P(TIP OR MEM ,DLOC,~)#,% SET PRESENCE BIT      09709300
        SETREADBIT      = 1[24:47:1]#,      %USED TO TURN READ BIT ON   09709400
$ INCLUDE 09709601 , IF  TIMESHARING;                                   09709500
        SLEEP           = 36 #,                                         09709600
$ OMIT    09709801,  IF  TIMESHARING ;                                  09709700
        SLEEP           =  2 #,                                         09709800
        TECHA           =(FIB[5].[46:2]=1)#,% TECHNIQUE-A               09709900
        TERM(TERM1)     = P(1,FLOC,TERM1,17,COM)#,%TERMINATE I/O ERROR  09710000
        TIP             = (*DLOC) #,        % LOAD I/O DESC             09710100
        TOSZF           = [8:38:10]#,       % TO SIZE FIELD             09710200
        TOTREC          = H[7]    #,        % TOTAL RECORDS ON FILE     09710300
        UT              = (FIB[4].[8:4])#,  % HARDWARE TYPE             09710400
        WA              = P(RCPRT,DIB 0,LOD)#,% LOAD WORK AREA PTR      09710500
        WAITIO          = P(DLOC,IOMASK,    % THIS SLEEPS ON I/O        09710600
                         SLEEP,COM,DEL,DEL)#,% WAITING FOR A COMPLETE   09710700
        WORDSLEFT       = FIB[17]#,         % WORDS LEFT IN BUFFER      09710800
        WRITBACK        = FIB[13].[23:1]#;  % FLAG TO SAY WRITE BACK    09710900
LABEL   MOOVE,FLOTE,SEEKRTN,START,READREV;                              09711000
LABEL   SERIALIO,SIOEOD,RNDEOD,EOFSETCK;                                09711100
SUBROUTINE GOUSE;                    % THIS CALLS USE ROUTINES          09711200
         BEGIN                                                          09711300
                   P(MKS,T,0,PERFORMER);                                09711400
         END GOUSE;                                                     09711500
SUBROUTINE  ERROR;                   %THIS PROCESSES ALL ERRORS         09711600
         BEGIN                                                          09711700
         IF REEDING AND  CODE  AND (NUMREC=1) THEN  %SKIP ERROR CODE    09711800
         ELSE BEGIN                                                     09711900
              IF  OPENIO  THEN  IF  (T:=RT:=PGUSE[4].ARR) !  0  THEN    09712000
                    GOUSE  ELSE   ELSE       %WAS ERROR ON IO           09712100
              IF  REEDING AND (NOT CODE) THEN  %READ ERROR              09712200
                    IF (T:=RT:=PGUSE[4].BRR) ! 0 THEN                   09712300
                          GOUSE  ELSE   ELSE                            09712400
                    IF (T:=PGUSE[5].BRR) ! 0  THEN GOUSE;  %WRITE ERROR 09712500
              IF (T~FIB[15].BF) ! 0 THEN GOUSE;     % ERROR ON FILE-N   09712600
              IF REEDING AND (NOT CODE) THEN                            09712700
                   BEGIN                      %CHECK USE PROC FOR       09712800
                   IF ERBIT  THEN             %INPUT ERRORS             09712900
                        IF (T OR RT) = 0 THEN IOERR(19);                09713000
                   ERBIT := FALSE;                                      09713100
                   END  ELSE  TERM(20);       %WRITE ERR  TERM          09713200
              END;                                                      09713300
         END ERROR;                                                     09713400
SUBROUTINE MOVEREC;   %MOVES DATA  TO AND  FROM WORKAREA                09713500
         BEGIN                                                          09713600
              IF NOT DONE THEN WAITIO;         %DONT MOVE TILL IO DONE  09713700
              IF  NOT PRESENT THEN                                      09713800
                    BEGIN                      %GOT AN ERROR            09713900
                    SETPRESENTSBIT;                                     09714000
                    SETPANDERBIT;              %SET  ERROR FLAGS        09714100
                    IF NOT REEDING THEN                                 09714200
                         BEGIN                 %ERROR ON OUTPUT         09714300
                         DEST := WA;           %MOVE  FIRST RECORD      09714400
                         P(TIP INX 1);         %TO WORK  AREA           09714500
                         GO MOOVE;                                      09714600
                         END;                                           09714700
                    END;                                                09714800
               P(BUFTOP INX(BS~NUMWDS|(RCOUNT MOD NUMREC)+ 1));         09714900
               WA;                                   %MOVE TO/FROM WA   09715000
               DEST ~ IF CODE THEN P(XCH) ELSE P;    %FOR READ OR WRITE 09715100
MOOVE:         STREAM(FROM~P:NUMWDS,E~P(DUP).[37:5],DEST~P(*P(.DEST))); 09715200
                    BEGIN                                               09715300
                    SI:=FROM; E(DS:=32 WDS; DS:=32 WDS); DS:=NUMWDS WDS;09715400
                    END STREAM;                                         09715500
               P(DEL);                                                  09715600
               IF PARITY THEN  ERROR;                                   09715700
          END MOVEREC;                                                  09715800
SUBROUTINE DISKADDRESS;      %THIS COMPUTES THE DISK ADDRESS READ & WRIT09715900
    BEGIN                                                               09716000
              RT ~ SEGPERBLK | DAS;              % REL SEGMENT NO       09716100
              IF P(RT DIV ROWLGTH,DUP) } NUMBSPC THEN P(1,RTN);         09716200
              IF (BS~H[(T~ P + 10)]) = 0 THEN                           09716300
                   BEGIN                                                09716400
                   GETSEG;                                              09716500
                   IF HOWOPEN!0 THEN IF NOT OPENIO THEN IOERR(22);      09716600
                   BS ~ H[T];                                           09716700
                   END;                                                 09716800
              STREAM( A ~ BS ~ BS + RT MOD ROWLGTH,                     09716900
                   B~(BUFTOP INX 0)-(IF NOT CODE THEN WRITBACK ELSE 0));09717000
                     BEGIN SI~LOC A;  DS~8 DEC; END;                    09717100
    END DISKADDRESS;                                                    09717200
SUBROUTINE ROTATEBUF;           %THIS ROTATES BUFFERS                   09717300
         BEGIN                                                          09717400
              IF  NUMBUF > 1 THEN                                       09717500
                   P(NUMBUF,DLOC,13,11,COM,DEL,DEL,DEL);                09717600
              WORDSLEFT := BUFFSIZE;                                    09717700
              RESETPANDERBIT;                                           09717800
              FIB[16].[CF] := TIP;                                      09717900
         END ROTATEBUF;                                                 09718000
SUBROUTINE  PREL;                 % THIS DOES ACTUAL I/O                09718100
              BEGIN                                                     09718200
                   P( TIP,DLOC);                                        09718300
                   IF WRITBACK THEN              % DO SPECIAL WRITE-IO  09718400
                   BEGIN                                                09718500
                             WRITBACK ~ FALSE;   % TURN OFF READ BIT    09718600
                             DLOC[0]~ TIP&RESETREADBIT;% TO MAKE WRITE  09718700
                   END;                                                 09718800
                   P(PRL,DEL);                   % DO I-O               09718900
                   IF BREAK THEN BREAKOUT;                              09719000
              END PREL;                                                 09719100
SUBROUTINE REED;                %THIS READS BLOCKS                      09719200
         BEGIN                                                          09719300
              WORDSLEFT := BUFFSIZE;                                    09719400
              DLOC[0] := FLAG(BUFTOP & SETREADBIT);   %TO  RESET IOD    09719500
              CODE ~ P(CODE,0);                                         09719600
              DISKADDRESS;                                              09719700
              CODE ~ P;                                                 09719800
              MEM[BUFTOP INX NOT 2] ~ DAS;         % SAVE BLOCK NUMBER  09719900
              PREL;                                                     09720000
              FIB[16].[CF] := TIP;                 %SAVE BUFF ADDRESS   09720100
         END REED;                                                      09720200
SUBROUTINE WRIT;                 %THIS WRITES BLOCKS                    09720300
         BEGIN                                                          09720400
              WORDSLEFT := BUFFSIZE;                                    09720500
              WRITBACK ~ FALSE;                                         09720600
              DAS := BCOUNT;                            %BLOCK ADDRESS  09720700
              DLOC[0] := FLAG(BUFTOP & RESETREADBIT);   %RESET IOD      09720800
              DISKADDRESS;                                              09720900
              PREL;                                                     09721000
              FIB[16].[CF] := TIP;                 %SAVE BUFF ADDRESS   09721100
         END WRIT;                                                      09721200
SUBROUTINE SEEK;            %THIS FINDS AND/OR READS BLOCKS             09721300
         BEGIN                                                          09721400
         IF (DAS := RCOUNT DIV NUMREC) = BCOUNT THEN GO SEEKRTN;        09721500
         IF SERIAL THEN                                                 09721600
              BEGIN                                                     09721700
              IF NOT HOWOPEN THEN                                       09721800
                   BEGIN                %NOT INPUT                      09721900
                   IF RCOUNT < TOTREC THEN TOTREC := RCOUNT;            09722000
                   IF NUMREC > 1 THEN                                   09722100
                        BEGIN           %BLOCKED OUTPUT                 09722200
                        NUMBUF := 1;    %FILL ONLY ONE                  09722300
                        WRITBACK := (WORDSLEFT<BUFFSIZE);  %BUFFER      09722400
                        END;                                            09722500
                   END;                                                 09722600
              IF NUMBUF ! 1 THEN                                        09722700
              IF (DAS{COUNT) AND (DAS>BCOUNT) THEN   %BLOCK IS PRESENT  09722800
                   IF MEM[DLOC[NUMBUF-1] INX NOT 2] = COUNT THEN        09722900
                        DAS := COUNT + 1;                               09723000
              COUNT := (RCOUNT DIV NUMREC) + NUMBUF - 1;                09723100
              DO   BEGIN                                                09723200
                   IF NOT DONE THEN WAITIO;                             09723300
                   IF NOT PRESENT THEN                                  09723400
                        IF NOT REEDING                                  09723500
                             THEN MOVEREC ELSE SETPRESENTSBIT;          09723600
                        IF DAS | NUMREC { LSUBU                         09723700
                             THEN REED ELSE ROTATEBUF;                  09723800
                   END UNTIL (DAS := DAS + 1) > COUNT;                  09723900
              IF NOT HOWOPEN THEN WAITIO;                               09724000
              BCOUNT := DAS ~ DAS - NUMBUF;                             09724100
              NUMBUF := BUFFNUM;                                        09724200
              END ELSE                  %MUST BE RANDOM                 09724300
              IF HOWOPEN OR (NUMREC > 1) THEN  %INPUT OR BLOCKED        09724400
                   BEGIN                                                09724500
                   IF NUMBUF = 1 THEN    % JUST READ DONT TRY TO FIND   09724600
                        BEGIN IF NOT DONE THEN WAITIO;  REED;  END      09724700
                   ELSE BEGIN                                           09724800
                        FOR T := 1 STEP 1 UNTIL NUMBUF -1               09724900
                             DO         %FIND BLOCK IN CORE             09725000
                             IF MEM[DLOC[T] INX NOT 2] = DAS            09725100
                                  THEN GO FLOTE;                        09725200
                             IF NOT DONE THEN WAITIO;                   09725300
                             REED;      %MAKE PRESENT IN CORE           09725400
FLOTE:                       IF CODE < 2 THEN                           09725500
                                  BEGIN                                 09725600
                                  IF WRITBACK THEN       %READ OR       09725700
                                       BEGIN             %WRITE         09725800
                                       WRIT;                            09725900
                                       DAS := RCOUNT DIV NUMREC;        09726000
                                       END ELSE ROTATEBUF;              09726100
                                  WHILE MEM[TIP INX NOT 2] ! DAS        09726200
                                       DO  ROTATEBUF;                   09726300
                                  BCOUNT := DAS;                        09726400
                                  END;                                  09726500
                        END;                                            09726600
                   END;                                                 09726700
SEEKRTN:                                                                09726800
              ENDFILE := FALSE;                                         09726900
         WORDSLEFT := BUFFSIZE - ((RCOUNT MOD NUMREC) | NUMWDS);        09727000
         LASTDONE ~ FALSE;        % PREVENT SERIALIO OVERWRITE          09727100
         IF CODE = 2 THEN P(XIT);                                       09727200
         END SEEK;                                                      09727300
%***%   S T A R T   Y E E   H E R E   Y E E   D I S K E R S   %***%     09727400
START:                                                                  09727500
       FIB := *(FLOC := (NOT 2) INX DLOC);                              09727600
       IF NOT DISK THEN                                                 09727700
            BEGIN                                                       09727800
            FLOC := P(.RCW,LOD);                                        09727900
            FIB := CODE;                                                09728000
            DEST := P(.DLOC,LOD);                                       09728100
            BS := NUMWDS;                                               09728200
            CODE := 1;                                                  09728300
            RCW := DLOC := NUMWDS := 0;                                 09728400
            P([FLOC],DUP,0,XCH,CFX,STF,1,INX,STS);                      09728500
            GO TO P(COBOLIONONDSK);                                     09728600
            END;                                                        09728700
       H := *[FIB[14]];                                                 09728800
       IF CODE > 2 THEN                             %WRITE BLOCK SAME   09728900
            IF CODE = 6 THEN CODE := 1 ELSE TERM(25);   %AS WRITE       09729000
       IF HOWOPEN > 1 THEN TERM(31 + CODE);                             09729100
       IF CODE = 2 THEN                                                 09729200
            BEGIN  RCOUNT~(IF KEY=0 THEN 0 ELSE P(KEY,DIB 0,LOD)) - 1;  09729300
              IF (RCOUNT<LSUBL) OR (RCOUNT>LSUBU) THEN                  09729400
                   GO EOFSETCK ELSE SEEK;   % ONLY SEEK VALID RECS      09729500
            END;                                                        09729600
       IF NOT OPENIO THEN                                               09729700
            IF (1 - CODE) ! HOWOPEN THEN TERM(PROPER);                  09729800
       IF SERIAL THEN          % PROCESS SERIAL FILE                    09729900
            BEGIN                                                       09730000
            IF OPENIO THEN GO SERIALIO;                                 09730100
            IF (RCOUNT<LSUBL) OR (RCOUNT>LSUBU) THEN GO EOFSETCK;       09730200
            MOVEREC;                                                    09730300
            IF REVERSE THEN GO READREV;                                 09730400
            IF CODE THEN IF RCOUNT > TOTREC THEN TOTREC := RCOUNT;      09730500
            IF (WORDSLEFT := *P(DUP) - NUMWDS) { 0 THEN                 09730600
                 BEGIN                  %BLOCK IS EXHAUSTED             09730700
                 IF CODE THEN WRIT ELSE                                 09730800
                      IF (DAS := BCOUNT + NUMBUF) | NUMREC { LSUBU THEN 09730900
                           BEGIN        %READ AHEAD TO KEEP             09731000
                           REED;        %BUFFERS READY                  09731100
                           COUNT := DAS;                                09731200
                           END ELSE ROTATEBUF;                          09731300
                 BCOUNT := * P(DUP) + 1;                                09731400
                 END;                                                   09731500
            RCOUNT := *P(DUP) + 1;                                      09731600
            IF FALSE THEN          % THIS CODE EXECUTED ONLY FOR TAPE   09731700
READREV:         BEGIN             % OPEN-REVERSE EQUATED TO DISK       09731800
                 IF (WORDSLEFT ~ *P(DUP) - NUMWDS) { 0 THEN             09731900
                      BEGIN          % BLOCK IS EXHAUSTED               09732000
                      IF (DAS ~ BCOUNT - NUMBUF) | NUMREC } LSUBL THEN  09732100
                           BEGIN  REED;  COUNT ~ DAS;                   09732200
                           END  ELSE  ROTATEBUF;                        09732300
                      BCOUNT ~ *P(DUP) - 1;                             09732400
                      END;                                              09732500
                 RCOUNT ~ *P(DUP) - 1;                                  09732600
                 END REVINPUT;                                          09732700
            IF KEY ! 0 THEN P(RCOUNT,KEY,DIB 0,ISD);                    09732800
            P(0,RTN);                                                   09732900
    % %  E N D  O F  S E R I A L  ----  I O  N E X T  % %               09733000
SERIALIO:                                                               09733100
         RCOUNT ~ *P(DUP) - (T ~ (CODE AND LASTDONE));                  09733200
         IF (RCOUNT<LSUBL) OR (RCOUNT>LSUBU) THEN GO EOFSETCK;          09733300
         IF T THEN WORDSLEFT ~ *P(DUP) + NUMWDS ELSE                    09733400
              IF WORDSLEFT { 0 THEN                                     09733500
                   BEGIN                %BLOCK IS EXHAUSTED             09733600
                   IF (DAS := BCOUNT + NUMBUF) | NUMREC { TOTREC THEN   09733700
                        BEGIN           %ANOTHER BLOCK                  09733800
                        REED;           %  IN SIGHT                     09733900
                        COUNT := DAS;                                   09734000
                        END ELSE                                        09734100
                        IF WRITBACK THEN    % WRITE CURRENT BLOCK       09734200
                             WRIT           % LESS WE FORGIT            09734300
                             ELSE      % OR USE NEXT BUFFER             09734400
                             ROTATEBUF;     % BECAUSE ITS THERE         09734500
                    BCOUNT := *P(DUP) + 1;                              09734600
                    END;                                                09734700
               IF RCOUNT > TOTREC THEN                                  09734800
                    IF CODE THEN TOTREC ~ RCOUNT ELSE                   09734900
                         BEGIN  CODE~32;  GO SIOEOD;  END;              09735000
               MOVEREC;                                                 09735100
SIOEOD:        IF (WORDSLEFT := *P(DUP) - NUMWDS) { 0 THEN              09735200
                    IF CODE THEN        %WROTE LAST RECORD              09735300
                         BEGIN           % OF YEE BLOCK                 09735400
                         IF (DAS:=BCOUNT+NUMBUF)|NUMREC { TOTREC THEN   09735500
                              BEGIN               %READ AHEAD TOO       09735600
                              WRITBACK := TRUE;   %KEEP BUFFERS FULL    09735700
                              REED;                                     09735800
                               COUNT := DAS;                            09735900
                               END ELSE     % WRITE BLOCK NOW           09736000
                               WRIT;        % ...A WRITE IN TIME...     09736100
                          BCOUNT := *P(DUP) + 1;                        09736200
                          END ELSE                                      09736300
                     ELSE IF CODE THEN WRITBACK := TRUE; %NOT FULL BLK  09736400
                LASTDONE := NOT CODE;                                   09736500
                IF KEY ! 0 THEN P(RCOUNT,1,+,KEY,DIB 0,ISD);            09736600
                RCOUNT := *P(DUP) + 1;                                  09736700
                IF CODE=32 THEN GO EOFSETCK ELSE P(0,RTN);              09736800
            END SERIAL;    % END OF ALL SERIAL PROCESSING               09736900
    %%% RANDOM AND RANDOM IO START HERE %%%                             09737000
         RCOUNT := (IF KEY = 0 THEN 0 ELSE P(KEY,DIB 0,LOD)) - 1;       09737100
         IF (RCOUNT<LSUBL) OR (RCOUNT>LSUBU) THEN GO EOFSETCK;          09737200
         IF RCOUNT > TOTREC THEN                                        09737300
              IF CODE THEN TOTREC ~ RCOUNT ELSE                         09737400
                   BEGIN CODE ~ 32;  GO RNDEOD;  END;                   09737500
         IF (DAS ~ RCOUNT DIV NUMREC) ! BCOUNT THEN                     09737600
              IF (NUMREC ! CODE) THEN SEEK ELSE BCOUNT ~ DAS;           09737700
         MOVEREC;                                                       09737800
RNDEOD:  WORDSLEFT := *P(DUP) - NUMWDS;                                 09737900
         IF CODE THEN                                                   09738000
              IF NUMREC = 1             %UNBLOCKED OUTPUT               09738100
                   THEN WRIT                                            09738200
                   ELSE WRITBACK := TRUE;                               09738300
         IF CODE!32 THEN P(0,RTN);                                      09738400
EOFSETCK:                                                               09738500
         IF (WORDSLEFT < BUFFSIZE) AND                                  09738600
              (NOT(HOWOPEN) OR (OPENIO AND WRITBACK))                   09738700
         THEN BEGIN                                                     09738800
              NUMBUF := 1;              %WRITE LAST BUFFER              09738900
              WRIT;                     %AND CHECK FOR                  09739000
              WAITIO;                   %ERRORS                         09739100
              NUMBUF := BUFFNUM;                                        09739200
              IF NOT PRESENT THEN                                       09739300
                   BEGIN                                                09739400
                   SETPRESENTSBIT;                                      09739500
                   ERROR;                                               09739600
              END  END;                                                 09739700
         IF SERIAL AND CODE ! 2 THEN        % ONLY 1 EOF ALLOWED        09739800
              IF ENDFILE THEN TERM(15) ELSE ENDFILE ~ TRUE;             09739900
         IF CODE = 32 THEN             % CLEAR WORK AREA                09740000
              BEGIN  H ~ WA;           % IF READ BEYOND EOF             09740100
                   FOR RT ~ 0 STEP 1 UNTIL (NUMWDS-1) DO H[RT] ~ 0;     09740200
              END;                                                      09740300
         IF CODE ! 2 THEN P(1,RTN) ELSE   % LET PROGRAM KNOW ITS EOF    09740400
              LASTDONE ~ FALSE;           % PREVENT SERIALIO OVERWRITE  09740500
   %%% END OF EOF CHECKING                                              09740600
END OF COBOL DISK INTRINSICS;                                           09740700
$#PATCH NUMBER  11 FOR INTRINSICS.XII CONTAINS  88 CARDS          C
%        I N T R I N S I C S      M A R K    X I I .16     05/15/71     00000000
         WH2=9, C=20, CODE, T4, COMMAS, DLRSGN, VL, DC10 ;              02780550
          ERROR, BACK, GOTNUMBER, MAX, ENDALL, EDIT, BLANKS, ADJT, CHKC,02780950
          FERROR, EX, ASK, ERR1, EX1, O1, O2, E1, E2, STNRD ;           02781000
                                        IF SC!":" THEN IF SC!"<" THEN   02781900
    SUBROUTINE RNDADJ ;                                                 02782705
         BEGIN                                                          02782710
         E~(T4~P(XCH)+T2)+E;  T2~T2-T4;  T3~T3-T4;  VL~1 ;              02782715
         P(XCH,TEN[T4],/,.T4,ISN,XCH) ;                                 02782720
         END OF RNDADJ ;                                                02782725
                                                                        02782730
                T~0,J~CODE!9,Z~T1<9) ;                                  02782900
              W(L3: IF SC}"0" THEN BEGIN TALLY~TALLY+1; DS~CHR END      02783050
                        CI~CI+Z; GO L3 ;                                02783275
         BUFF~P;  T3~P;  DC10~(DECPT~P) AND CODE>10 ;                   02784100
         T1~T1-((C~P(XCH))!0)-P(XCH)-T3;  T4~P;  P(XCH) ;               02784125
         IF COMMAS THEN IF C="," AND NOT DC10 THEN C~0 ;                02784150
         STREAM(C~0,BUFF,SGN~0,T2~0,T1:HADSGN~SGN,T~T1.[36:6]) ;        02784400
    T1~W;  SGN~1;  E~EXP~DECPT~T2~WH1~WH2~0 ;                           02790950
         IF DECPT~C="." THEN                                            02792355
              BEGIN IF CODE=10 THEN ERR(2);  P((-T1)) ;                 02792360
              STREAM(BUFF,C~0,T2~0,T1:T~T1.[36:6]) ;                    02792365
                   BEGIN SI~BUFF ;                                      02792370
                   T1(IF SC!"0" THEN IF SC!" " THEN IF SC!"O" THEN      02792375
                        BEGIN                                           02792380
                        IF SC<"0" THEN                                  02792385
                             BEGIN                                      02792390
                             DI~LOC T2; DI~DI-1; DS~CHR; TALLY~TALLY+1 ;02792395
                             END ;                                      02792400
                        JUMP OUT TO L ;                                 02792405
                        END ;                                           02792410
                      TALLY~TALLY+1; SI~SI+1) ;                         02792415
                   DI~T1 ;                                              02792420
                   T(2(32(IF SC!"0" THEN IF SC!" " THEN IF SC!"O" THEN  02792425
                             BEGIN T1~DI ;                              02792430
                             IF SC<"0" THEN                             02792435
                                  BEGIN DI~DI-8 ;                       02792440
                                  T1~DI; DI~LOC T2; DI~DI-1; DS~CHR ;   02792445
                                  END ;                                 02792450
                             JUMP OUT 3 TO L ;                          02792455
                             END ;                                      02792460
                          DI~DI-8; SI~SI+1))) ;                         02792465
                   T1~DI ;                                              02792470
              L:   BUFF~SI; T2~TALLY ;                                  02792475
                   END ;                                                02792480
              T1~P(SUB,SSP);  C~P;  BUFF~P;  E~P+T1 ;                   02792485
              IF C<10 THEN IF T1=0 THEN GO GOTNUMBER ELSE GO E2 ;       02792490
              END ;                                                     02792495
         IF C="*" THEN GO ASK;  WH1~1-DECPT;  GO EX1 ;                  02792500
         END                                                            02792505
    ELSE SGN~SGN OR T1=0 ;                                              02792510
E2: IF CODE{10 THEN DECPT~1;  VL~0 ;                                    02792550
    IF T3=0 THEN IF COMMAS THEN GO CHKC ELSE P(DEL)                     02792700
$VOID 02792851                                                          02792800
         IF VL THEN BEGIN IF NOT DC10 THEN ADJT: E~E+T3; P(DEL) END     02792900
              IF DC10 THEN E~E+T4-T3 ;                                  02793000
                   BEGIN                                                02793075
                   IF T2<12 THEN GO STNRD ;                             02793100
                   IF DBLPREC THEN                                      02793125
                        BEGIN                                           02793130
                        IF P(DUP)=0 THEN IF T2>23 OR T1=0 OR C!0 THEN   02793135
                             BEGIN                                      02793140
                             VL~1;  T2~T2-T3;  IF DC10 THEN T3~T3-T4 ;  02793145
                             GO ADJT ;                                  02793150
                             END ;                                      02793155
                        IF T2>23 THEN                                   02793160
                             BEGIN                                      02793165
                             P((TEN[T2-T3-12]|P(MAX)<WH1)-24);  RNDADJ ;02793170
                             END ;                                      02793175
                        WH2~P(0,XCH,WH2,WH1,0,TEN[T3],DLM,DLA,XCH) ;    02793180
                        END                                             02793185
                   ELSE BEGIN                                           02793190
                        P((TEN[T3-T2+12]|WH1>P(MAX))-12);  RNDADJ ;     02793195
STNRD:                  P(TEN[T3]|WH1,+) ;                              02793200
                        END ;                                           02793205
                   END ;                                                02793245
CHKC:    IF NOT (C!0 OR T1{0) THEN GO BACK ;                            02793350
EX: IF CODE=10 THEN ERR(2);  P(SGN);  SGN~1 ;                           02793550
    IF DBLPREC THEN                                                     02794300
    IF TYPE=INTEGR OR TYPE=LOGICAL THEN                                 02794800
         BEGIN                                                          02794850
         IF P(DUP)>P(MAX) THEN BEGIN P(DEL); ERR3: ERR(3) END ;         02794900
         P([ADDR[0]],ISD);  GO ASK ;                                    02794950
         END ;                                                          02795000
$VOID 02795301                                                          02795050
MAX:::   @0007777777777777 ;                                            02795410
$VOID 02796651                                                          02796550
                        16                                              99998100
$#PATCH NUMBER  12 FOR INTRINSICS.XII CONTAINS   5 CARDS          C
RERRA:   IF FILX.[18:15]>1 THEN                                         00698100
              BEGIN PARL~FILX[NOT 3];  FILX[NOT 3]~FILX[NOT 4]~0 END    00698150
         ELSE BEGIN                                                     00698200
              IF FILX.[18:15]=1 THEN P(FILX,14,COM);  PARL~0;  FILX~*2 ;00698300
              END ;                                                     00698400
$#PATCH NUMBER  13 FOR INTRINSICS.XII CONTAINS 193 CARDS          C
         MINREC         = FIB[18].[FF]#,   % MINIMUM RECORD SIZE        02602952
         PRINTFILE      = FIB[20] #,       % CF=1 IS PRINTFILE          02603070
$ VOID                                                                  02611520
                   IF COB68 THEN IF TECH!TECHC THEN MINREC~MAXREC;      02611675
                   IF NOT (DISK) THEN                                   02620065
                        BEGIN   WORDSLEFT ~ BUFFERSIZE;                 02620070
                             PRINTFILE ~ P(DUP,LOD,(FIB[4].[8:4]),      02620075
                             P(DUP)=1,P(XCH,DUP)=7,P(XCH)=12,OR,OR,CCX);02620080
                        END UNDISK;    % 1=LP,  7=PBT,  12=PBD          02620085
              END COB68ING;                                             02620090
         REAL                                                           09602300
              TCW,                % TECH C: NUMBER WORDS TO BE READ     09602500
              TCDIF,              % TECH C: (ACTUAL RECORD - MIN REC)   09602600
        LINEPRINT       = FIB[20] #,         % CF=1 IS PRINTFILE        09607100
$ VOID                                                                  09607200
        MINREC          = FIB[18].[FF] #,   % MINIMUM RECORD SIZE       09607800
        PROPER          =P(CODE,P(DUP),+,P(DUP)=12,+,REVERSE,+,21,+) #, 09608900
                                  % GENERATES PROPER IOERROR            09608910
LABEL LPRETURN,START,IMPROPER,ROVER,EOFSETCK;                           09612000
$ VOID                                                                  09612500
         IF NOT PRESENT THEN IF NOT (T OR RT) THEN                      09612800
              IOERR(19 + 10 | REVERSE);                                 09612850
         SETPRESENCEBIT;                                                09612900
                        CHECK(RCOUNT) ONERR(16);                        09615600
                        CHECK(BCOUNT) ONERR(17);                        09615700
$ VOID 09618501                                                         09618400
         WORDSLEFT ~ *P(DUP) - NUMWDS;                                  09620500
         DLOC[0] ~ (IF REVERSE THEN NOT(NUMWDS-1) ELSE NUMWDS) INX TIP; 09620600
         RCOUNT ~ *P(DUP) + 1;                                          09620700
         IF CODE THEN                            % CHECK FOR            09620800
              IF NOT PRESENT THEN OUTPUTERROR    % OUTPUT PARITY ERROR  09620900
         ELSE ELSE                                                      09621000
              IF PARITY THEN INPUTPARITY;        % INPUT PARITY ERROR   09621100
         IF BREAK THEN BREAKOUT;                                        09621200
    END MOVERECORDTOANDFROMWORKAREA;                                    09621300
$ VOID  09621601                                                        09621400
$ VOID                                                                  09622000
         BCOUNT ~ *P(DUP) + 1;         % UP BLOCK COUNT                 09622100
$ VOID                                                                  09622200
SUBROUTINE  SKIPPER;              % DOES SPACING ON PRINTER             09622400
    BEGIN                                                               09622500
         WHILE LINES > 0 DO                                             09622600
              BEGIN                                                     09622700
              IF NOT DONE THEN WAITIO;                                  09622800
              IF NOT PRESENT THEN OUTPUTERROR;                          09622900
              DLOC[0] ~ TIP & 1[18:47:1] & 16[27:42:6];                 09623000
              IF LINES = 1 THEN                                         09623100
                   DLOC[0] ~ TIP & 2[27:46:2];                          09623200
              PREL;                                                     09623300
              LINES ~ LINES - 2;                                        09623400
              END;                                                      09623500
    END SKIPPINGALLTHOSELINES;                                          09623600
$ VOID  09624501                                                        09623700
SUBROUTINE  GOLP;                 % MAKES THY PRYNTER GO                09624600
    BEGIN                                                               09624700
         IF LINTOG THEN INXLINAGE;                                      09624800
         RT ~ BUFFSIZE - WORDSLEFT;    % !0 MEANS DATA PRESENT          09624900
         IF NOT UNBLKD THEN                                             09625000
              BEGIN                                                     09625100
              IF TECHC THEN                                             09625200
                   BEGIN                                                09625300
                   IF NUMWDS > MAXREC THEN NUMWDS ~ MAXREC;             09625400
                   IF NUMWDS { 0 THEN TERM(36);                         09625500
                   END;                                                 09625600
              IF NUMWDS > WORDSLEFT THEN SKIPBFR ~ TRUE                 09625700
                   ELSE BEGIN MOVEREC;  GO LPRETURN;  END;              09625800
              END;                                                      09625900
         IF CHNNL ! 0 THEN LINES ~ 0;                                   09626000
         IF SKIPBFR THEN                                                09626100
              BEGIN                                                     09626200
                   IF NOT DONE THEN WAITIO;                             09626300
                   IF NOT PRESENT THEN OUTPUTERROR;                     09626400
                   DLOC[0] ~ FLAG(BUFTOP & (RT = 0) [18:47:1]           09626500
                                  &RT   TOSZF                           09626550
                                  &(LINES>0)[27:46:2] & CHNNL[29:44:4]);09626600
                   IF LINES = 1 THEN DLOC[0]~TIP & 2[27:46:2];          09626700
                   PREL;                                                09626800
                   WORDSLEFT ~ BUFFSIZE;                                09626850
                   IF (LINES ~ LINES - 2) > 0 THEN SKIPPER;             09626900
                   IF UNITYPE=12 THEN IF NOT DONE THEN WAITIO;          09627000
                   BUFTOP.[CF] ~ TIP;                                   09627100
                   MOVEREC;                                             09627200
              END ELSE                                                  09627300
              BEGIN                                                     09627400
                   IF RT ! 0 THEN                                       09627500
                        BEGIN                                           09627600
                        DLOC[0] ~ FLAG(BUFTOP & 0[27:42:6]              09627700
                                       & RT  TOSZF);                    09627750
                        PREL;                                           09627800
                        WORDSLEFT ~ BUFFSIZE;                           09627850
                        IF UNITYPE=12 THEN IF NOT DONE THEN WAITIO;     09627900
                        BUFTOP.[CF] ~ TIP;                              09628000
                        END;                                            09628100
                   MOVEREC;                                             09628200
                   DLOC[0] ~ FLAG(BUFTOP & (LINES>0)[27:46:2]           09628300
                                         & RT  TOSZF                    09628350
                                         & CHNNL [29:44:4]);            09628400
                   IF LINES = 1 THEN DLOC[0]~TIP & 2[27:46:2];          09628500
                   PREL;                                                09628600
                   WORDSLEFT ~ BUFFSIZE;                                09628650
                   IF (LINES ~ LINES - 2) > 0 THEN SKIPPER;             09628700
                   IF UNITYPE=12 THEN IF NOT DONE THEN WAITIO;          09628800
                   BUFTOP.[CF] ~ TIP;                                   09628900
$ VOID                                                                  09629000
              END;                                                      09629100
LPRETURN:                                                               09629200
         IF LINTOG THEN IF (*P(LOCOFCTR)) > LINAGELIM THEN              09629300
              BEGIN                                                     09629400
                   P(0,LOCOFCTR,STD);                                   09629500
                   LINAGELIM ~ NXTLINAGE;                               09629600
                   P(1,RTN);                                            09629700
              END;                                                      09629800
         P(0,RTN);                                                      09629900
    END GOINTOPRINTER;                                                  09630000
$ VOID   09630801                                                       09630001
SUBROUTINE WRIT;             % WRITES A BLOCK                           09630900
    BEGIN                                                               09631000
         DLOC[0] ~ FLAG(BUFTOP & (BUFFSIZE-WORDSLEFT) TOSZF);           09631100
         IF TAPEE THEN IF NOT BINARY THEN ARROW ELSE                    09631200
              ELSE IF PUNCH THEN DLOC[0] ~ TIP & CHNNL[32:47:1];        09631300
         PREL;                                                          09631400
         WORDSLEFT ~ BUFFSIZE;                                          09631500
         BUFTOP.[CF] ~ TIP;                                             09631600
$ VOID                                                                  09632000
$ VOID                                                                  09632400
         WORDSLEFT ~ 0;                                                 09632500
$ VOID                                                                  09632600
         IF CODE > 1 THEN              % SHOULD BE WRITE BLOCK          09633300
              BEGIN                                                     09633400
                   IF CODE ! 6 THEN TERM(25);    % UNRECOGNIZED CODE    09633500
                   IF HOWOPEN ! 0 THEN GO IMPROPER;   % IO ERROR        09633600
                   IF WORDSLEFT < BUFFSIZE THEN                         09633700
                        IF LINEPRINT THEN GOLP ELSE WRIT;               09633800
                   P(0,RTN);                                            09633900
              END WRITEBLOCK;                                           09634000
$ VOID                                                                  09634100
         IF CODE THEN                  % WRITE A RECORD                 09635000
              IF LINEPRINT THEN GOLP ELSE                               09635100
              BEGIN                                                     09635200
                   IF TECHC THEN                                        09635300
                        BEGIN                                           09635400
                        IF NUMWDS > MAXREC THEN NUMWDS ~ MAXREC;        09635500
                        IF NUMWDS > WORDSLEFT THEN WRIT;                09635600
                        IF NUMWDS < MINREC THEN TERM(36);               09635700
                        END;                                            09635800
                   MOVEREC;                                             09635900
                   IF WORDSLEFT < MINREC THEN WRIT;                     09636000
                   P(0,RTN);                                            09636100
              END;                                                      09636200
                                       % READ A RECORD                  09636300
ROVER:   IF WORDSLEFT { 0 THEN                                          09636400
              BEGIN                    % A NEW BLOCK WAS READ           09636500
                   IF NOT DONE THEN WAITIO;                             09636600
$ VOID                                                                  09636700
                   WORDSLEFT ~                                          09636800
                        MEM[(IF REVERSE THEN 1 ELSE NOT 0) INX TIP];    09636900
                   IF REVERSE THEN DLOC[0] ~ NOT(MAXREC-2) INX TIP;     09637000
              END;                                                      09637100
         IF TECHC THEN                                                  09637200
              BEGIN                                                     09637300
                   NUMWDS ~ P(.NUMWDS,LOD,.TCW,STD,MINREC);             09637400
                   MOVEREC;                                             09637500
                   IF (TCW~TCW) > MAXREC THEN TCW ~ MAXREC;             09637600
                   IF TCW < NUMWDS THEN                                 09637700
                        IF (TCW=0) AND (WORDSLEFT+NUMWDS=1) THEN        09637800
                             BEGIN                                      09637900
                                  REED;                                 09638000
                                  RCOUNT ~ *P(DUP) - 1;                 09638100
                                  GO ROVER;                             09638200
                             END ELSE TERM(26 + (TCW!0));               09638300
                   IF (TCDIF ~ TCW - NUMWDS) > 0 THEN                   09638400
                        BEGIN                                           09638500
                             STREAM(TCDIF,E~P(DUP).[36:6],              09638600
                                   FROM~ TIP INX 0,                     09638700
                                   DEST ~ NUMWDS INX (*RCPRT));         09638800
                                  BEGIN  SI ~ FROM;                     09638900
                                       E(DS~32 WDS;  DS~32 WDS);        09639000
                                       DS ~ TCDIF WDS;                  09639100
                                  END STREAM;                           09639200
                             DLOC[0] ~ TCDIF INX TIP;                   09639300
                             WORDSLEFT ~ *P(DUP) - TCDIF;               09639400
                             NUMWDS ~ TCW;                              09639450
                        END;                                            09639500
              P(RCPRT,DUP,LOD,NUMWDS,DIA 38,DIB 8,TRB 10,XCH,STD);      09639550
              END            % TECH C FILE READING                      09639600
              ELSE MOVEREC;                                             09639700
         IF WORDSLEFT { 0 OR UNBLKD THEN REED;                          09639800
         P(0,RTN);                                                      09639900
EOFSETCK:                                                               09640000
         IF ENDFILE THEN TERM(15);                                      09640100
         ENDFILE ~ TRUE;                                                09640200
         P(1,RTN);                                                      09640300
END COBOLIONONDISK;                                                     09640500
$#PATCH NUMBER  14 FOR INTRINSICS.XII CONTAINS   3 CARDS          I
         ARRY ~ *[PRTPOINTER[17]];                                      00420100
         FOR I ~ 1 STEP 1 UNTIL ARRY[0] DO                              00420110
              C ~ ARRY[I];                                              00420130
$#PATCH NUMBER  15 FOR INTRINSICS.XII CONTAINS  12 CARDS          I
                    WAOUT ~ P(*[OUTFIL],0,CDC);                         00716450
                          WAOUT ~ P(PRFIB[20].[FF],DUP,DIB 0,LOD,0,     00717260
                                    CDC,DEL,DIB 0,LOD);                 00717270
                   END;                                                 00717280
                          WAIN ~ P([INFIL],DUP,LOD,0,CDC,DEL,LOD);      00763150
                        BEGIN CIIOD ~ [WAIN];                           00763450
                              WAIN ~ P(*[INFIL[NOT 2]],20,COC,0,XCH,FCX,00763460
                                    DUP,DIB 0,LOD,0,CDC,DEL,DIB 0,LOD); 00763470
                    WAOUT ~ P(*[OUTFIL],0,CDC);                         00809750
                          WAOUT ~ P(PRFIB[20].[FF],DUP,DIB 0,LOD,0,     00810460
                                    CDC,DEL,DIB 0,LOD);                 00810470
                   END;                                                 00810480
$#PATCH NUMBER  16 FOR INTRINSICS.XII CONTAINS   7 CARDS          I
        PROPER          =REVERSE+CODE+CODE+21#,%GENERATES PROPER IOERR  09707700
       IF CODE > 2 THEN IF CODE ! 6 THEN TERM(25) ELSE     %WRITE BLOCK 09728900
            BEGIN IF HOWOPEN > 1 THEN TERM(37);                         09728930
                  IF NOT OPENIO THEN IF HOWOPEN THEN TERM(34+REVERSE);  09728960
                  GO EOFSETCK;    %WRITES BLOCK:IMMEDIATE-NO ROTATION   09729000
            END;                                                        09729050
         IF CODE = 6 THEN P(0,RTN);                                     09739750
$#PATCH NUMBER 17 FOR INTRINSICS.XII CONTAINS  197 CARDS          I
%    T S-I N T R I N S I C S      M A R K     X I I .  21  06/15/71     00000000
              CALLINT(CALLINT1) = P(CALLINT1 & 85[1:41:7],XCH,COC) #,   00000218
              FORTERRI= @134 #,                                         00000220
              EXPI    = @20 #,                                          00000221
              LNI     = @17 #,                                          00000222
              DEXPI   = @77 #,                                          00000223
              DLOGI   = @101 #,                                         00000224
              CABSI   = @53 #,                                          00000225
              SINI    = @14 #,                                          00000226
              SQRTI   = @13 #,                                          00000227
              ATAN2I  = @114 #,                                         00000228
              DMODI   = @65 #,                                          00000229
              DSINI   = @105 #,                                         00000230
              DSQRTI  = @123 #,                                         00000231
              XTOII   = @6 #,                                           00000232
              CXTOII  = @56 #,                                          00000233
              COSI    = @15 #,                                          00000234
              TANI    = @111 #,                                         00000235
              ARCTANI = @16 #,                                          00000236
              DATANI  = @113 #,                                         00000237
              ARSINI  = @116 #,                                         00000238
              GAMMAI  = @126 #,                                         00000239
           SQRT=+1 ;                                                    03100400
P(INTDESC(SQRTI)) ;                                                     03100410
$VOID 03401151                                                          03401150
              T=+1,V=+2,ERR=+3,BOOL=+4,CDTOG=+5 ;                       03401300
      INTEGER J=+6,I=J,R=CDTOG ;                                        03401400
      REAL EXP=+7,LN=+8,DEXP=EXP,DLOG=LN,CABS=+9,ATAN2=+10,SQRT=+11,    03401500
           COS=+12,SIN=+13 ;                                            03401510
      DEFINE DF(DF1)=FLAG(DF1 OR T) # ;                                 03401520
      LABEL REXPOR,DEXPOR,REXPOD,DEXPOD,CEXPOD,CEXPOR,REXPOC,DEXPOC,L1, 03401600
            L2,L3,L4,CEXPOC,CDENT,RDENT,TOPI,TOPIL,PI2,TPI2,HAF,PI,MAX, 03401700
            F096,L5,PIT,CREL,PICK,RX1,RX2,REXPOR1,CEXPOD2 ;             03401710
P(0&85[1:41:7],0,DF(FORTERRI),0,0,0);  IF CODE=0 THEN GO REXPOR ;       03401800
IF CODE<5 THEN IF CODE!2 THEN BEGIN P(DF(DEXPI),DF(DLOGI)); GO PICK END;03401900
P(DF(EXPI),DF(LNI),DF(CABSI),DF(ATAN2I),DF(SQRTI),DF(COSI),DF(SINI)) ;  03401910
PICK:    T~0 ;                                                          03401920
GO TO REXPOC;      %  REAL ** COMPLEX       2                           03402300
GO TO DEXPOC;      %  DOUBLE ** COMPLEX     5                           03402600
GO TO CEXPOC;      %  COMPLEX ** COMPLEX    8                           03402810
DEXPOC:  R~P(.C);  I~P(.D);  C~C+0&C[1:1:8]&D[47:9:1];  GO L3 ;         03402815
REXPOC:  R~P(.B);  I~P(.C) ;                                            03402820
L3:      IF C=0 THEN BEGIN P(0); GO L1 END ;                            03402825
         IF B=0 THEN                                                    03402830
              BEGIN                                                     03402835
              IF A=0 THEN BEGIN P(1); GO L1 END ;                       03402837
              IF C>0 THEN GO L5 ;                                       03402840
              IF ABS(A) LEQ P(MAX) THEN IF P(A,.BOOL,ISN)=A THEN        03402845
L4:                BEGIN A~BOOL ;                                       03402850
L5:                P(ABS(C),A,MKS,.EXP,LOD,INTCALL(*P(.LN),XTOII),DEL) ;03402855
                   IF B!0 THEN GO L2;  IF BOOL THEN P(CHS) ;            03402860
L1:                P(R,STD,0,I,STD,XIT) ;                               03402865
                   END ;                                                03402870
              T~P(PI)|A;  P(MKS,MKS,ABS(C),LN,A,|,EXP);  GO L2 ;        03402875
              END ;                                                     03402880
         T~(V~P(MKS,ABS(C),LN))|B ;                                     03402885
         IF A=0 THEN                                                    03402890
              BEGIN                                                     03402895
              IF C>0 THEN P(MKS,T,COS,R,STD,MKS,T,SIN,I,STD,XIT) ;      03402900
              P(MKS,(-P(PI))|B,EXP) ;                                   03402905
L2:           P(V~P,MKS,T,COS,|,R,STD,MKS,T,SIN,V,|,I,STD,XIT) ;        03402910
              END ;                                                     03402915
         IF C<0 THEN                                                    03402920
              BEGIN P(MKS,V|A-B|P(PI),EXP); T~T+P(PI)|A; GO L2 END ;    03402925
         IF ABS(A) LEQ 1023 THEN IF P(A,.BOOL,ISN)=A THEN GO L4 ;       03402930
         P(MKS,A|V,EXP);  GO L2 ;                                       03402950
CEXPOC:  IF B=0 THEN GO CEXPOD2 ;                                       03402965
         R~P(.C);  I~P(.D);  IF D=0 THEN GO L3 ;                        03402970
         IF C=0 THEN BEGIN T~ABS(D); P(PIT); IF D<0 THEN P(SSN); V~P END03402975
         ELSE BEGIN T~P(MKS,D,C,CABS); V~P(MKS,D,C,ATAN2) END ;         03402980
         T~(BOOL~P(MKS,T,LN))|B+V|A;  P(MKS,BOOL|A-V|B,EXP);  GO L2 ;   03402985
PI:::    3.14159265359 ;                                                03402990
MAX:::   @0007777777777777 ;                                            03402991
PIT:::   @1141444176652104 ;                                            03402992
          IF ABS(A)<4096 THEN IF (J~A)=A THEN                           03403200
REXPOR1:  BEGIN IF BOOL~J<0 THEN J~-J ;                                 03403300
                IF CDTOG!0 THEN                                         03404410
                   BEGIN                                                03404415
                   IF CDTOG>2 THEN P(.C,.D) ELSE P(.B,.C) ;             03404420
                   IF C=0 THEN RX1: P(0,XCH,STD,STD,XIT) ;              03404425
                   IF (J~(J~A) AND 3)=0 THEN GO RX1 ;                   03404430
                   IF J=1 THEN BEGIN P(XCH); GO RX1 END ;               03404435
                   IF J=2 THEN RX2: P(0,XCH,STD,XCH,CHS,XCH,STD,XIT) ;  03404440
                   P(XCH);  GO RX2 ;                                    03404445
                   END ;                                                03404450
        IF B>0                                                          03404700
          THEN P(MKS,INTCALL(P(MKS,INTCALL(B,LNI)|A),EXPI),.B,STD,XIT) ;03404710
REXPOD:  P(0,.B,.C);  GO RDENT ;                                        03404900
DEXPOR:  P(C,.B,.C);  C~B;  B~0;  GO RDENT ;                            03405000
DEXPOD:  P(D,.C,.D) ;                                                   03405100
RDENT:   CODE~P;  R~P;  JUNK~P;  IF C=0 THEN P(0,CODE,STD,XIT) ;        03405200
$VOID 03408001                                                          03405300
         IF A=0 THEN P(1,R,STD,0,CODE,STD,XIT) ;                        03408100
                IF ABS(A)<P(F096) THEN IF (J~A)=A THEN                  03408300
                          P(J,.T,STD,JUNK,C) ;                          03408500
                            IF BOOL THEN P(.T,STD,0,XCH,1,XCH,T,DLD) ;  03409500
                            P(R,STD,CODE,STD,XIT) ;                     03409600
         IF C>0 THEN P(MKS,MKS,JUNK,C,DLOG,JUNK,B,A,DLM,DEXP,CODE,STD,  03409800
                       JUNK,R,STD,XIT) ;                                03409900
CDENT:    IF ABS(A)<P(F096) THEN IF (J~A)=A THEN                        03410300
          BEGIN                                                         03410305
          IF C=0 OR B=0 THEN                                            03410310
              BEGIN CDTOG~CDTOG OR 2; IF B=0 THEN B~C; GO REXPOR1 END ; 03410315
              IF BOOL~J<0 THEN J~-J ;                                   03410400
                 GO CREL;  F096::: 4096; CREL:                          03410450
CEXPOD:  A~A+0&A[1:1:8]&B[47:9:1] ;                                     03412900
CEXPOD2: IF C=0 THEN IF D=0 THEN P(XIT) ;                               03413000
         IF A=0 THEN P(1,.C,STD,0,.D,STD,XIT) ;                         03413050
$VOID 03413451                                                          03413450
    REAL H=+2, B=-1, BL=-2, A=-3, AL=-4, E=17;  LABEL G,Q ;             04100200
    IF B=0 THEN IF BL=0 THEN P(MKS,INTCALL(13,FORTERRI)) ;              04100300
$VOID 05100451                                                          05100450
IF HUGE~X>27 THEN IF X>P(EMAX) THEN P(MKS,INTCALL(14,FORTERRI)) ;       05101150
          JUNK = 17 ;                                                   05200400
$VOID 05200701                                                          05200450
IF ABS(X)>P(EMAX) THEN P(MKS,INTCALL(15,FORTERRI)) ;                    05200900
P(MKS,INTCALL(X,EXPI),.X,STN,MKS,1,MKS,Y,TOPI,MOD,DUP,SSP,.Y,STD,       05201000
  CALLINT(SINI),DUP,X,MUL,.JUNK,STD,DUP,MUL,SUB,CALLINT(SQRTI),MUL) ;   05201100
$VOID 05300451                                                          05300450
IF X LEQ 0 THEN P(MKS,INTCALL(16+(X!0),FORTERRI)) ;                     05301100
          JUNK = 17 ;                                                   05400400
$VOID 05400801                                                          05400450
IF Y=0 THEN                                                             05400900
     IF X=0 THEN P(MKS,INTCALL(18,FORTERRI))                            05400950
     ELSE IF X>0 THEN P(MKS,INTCALL(X,LNI),.JUNK,STD,0,RTN) ;           05400975
JUNK~P(MKS,INTCALL(P(MKS,X,INTCALL(Y,CABSI)),LNI)) ;                    05401000
P(MKS,Y,INTCALL(X,ATAN2I),RTN) ;                                        05401100
BEGIN REAL X=-1 ;                                                       05500200
$VOID 05500301                                                          05500250
IF X LEQ 0 THEN P(MKS,INTCALL(19+(X!0),FORTERRI)) ;                     05500500
P(MKS,INTCALL(X,LNI),LGI,MUL,RTN) ;                                     05500600
          JUNK = 17 ;                                                   05600400
$VOID 05600501                                                          05600450
IF X LEQ 0 THEN P(MKS,INTCALL(21+(X!0),FORTERRI)) ;                     05600700
P(MKS,XL,INTCALL(X,DLOGI),JUNK,LGIL,LGI,DLM,.JUNK,STD,RTN) ;            05600800
$VOID 05700501                                                          05700500
IF P(MKS,XL,X,TOPIL,INTCALL(TOPI,DMODI),JUNK,.X,STD,.XL,STN,X,PI2L,PI2, 05701200
     DLS,XCH,DEL)>0                                                     05701250
$VOID 05800701                                                          05800450
IF ABS(Y)>P(EMAX) THEN P(MKS,INTCALL(23,FORTERRI)) ;                    05801000
P(MKS,INTCALL(Y,EXPI),DUP,DUP,1,XCH,/,.Y,STN,SUB,HAF,MUL,.T,STD,        05801100
  Y,ADD,HAF,MUL,MKS,X,TOPI,MOD,DUP,SSP,.X,STD,CALLINT(SINI),.Y,STN,MUL, 05801200
  MKS,1,Y,DUP,MUL,SUB,CALLINT(SQRTI),T,MUL) ;                           05801300
           LOW = -4 ;                                                   05900400
$VOID 05900501                                                          05900500
P(MKS,XL,X,PI2L,PI2,DLA,CALLINT(DSINI),RTN) ;                           05900700
$VOID 06000701                                                          06000450
IF ABS(Y)>P(EMAX) THEN P(MKS,INTCALL(24,FORTERRI)) ;                    06001000
P(MKS,INTCALL(Y,EXPI),DUP,DUP,1,XCH,/,.Y,STN,SUB,MHAF,MUL,MKS,X,TOPI,   06001100
  MOD,DUP,SSP,.X,STD,CALLINT(SINI),.T,STN,MUL,.JUNK,STD,Y,ADD,HAF,MUL,  06001200
  MKS,1,T,DUP,MUL,SUB,CALLINT(SQRTI),MUL) ;                             06001300
BEGIN REAL T ;                                                          06200200
      IF (T~P(MKS,INTCALL(X,TANI)))=0 THEN P(PMAX)                      06200500
BEGIN                                                                   06400200
     IF A!0 THEN P(MKS,INTCALL(A/B,ARCTANI))                            06400550
          IF A>0 THEN P(MKS,INTCALL(A/B,ARCTANI),PI,ADD)                06400750
               IF A<0 THEN P(MKS,INTCALL(A/B,ARCTANI),PI,SUB)           06400850
           JUNK = 17 ;                                                  06500600
$VOID 06500701                                                          06500700
    BEGIN P(MKS,AL,A,BL,B,DLD,CALLINT(DATANI)) ;                        06501000
$VOID 06600268                                                          06600233
IF X>1 THEN P(MKS,INTCALL(26,FORTERRI)) ;                               06600800
IF U~X>P(HAF) THEN X~P(MKS,1,X,SUB,HAF,MUL,.XSQ,STN,CALLINT(SQRTI))     06600900
BEGIN REAL X = -1 ;                                                     06700200
$VOID 06700301                                                          06700250
IF ABS(X)>1 THEN P(MKS,INTCALL(25,FORTERRI)) ;                          06700500
      P(PI2,MKS,INTCALL(X,ARSINI),SUB) ;                                06700600
BEGIN REAL X = -1 ;                                                     06800200
$VOID 06800301                                                          06800250
IF X>P(EMAX) THEN P(MKS,INTCALL(29,FORTERRI)) ;                         06800800
  P(MKS,INTCALL(X,EXPI),DUP,1,XCH,/,SUB,.5,MUL) ;                       06801100
$VOID 06900268                                                          06900233
IF (T~ABS(X))>P(EMAX) THEN P(MKS,INTCALL(30,FORTERRI)) ;                06900600
    .5,MUL,1,ADD) ELSE P(MKS,INTCALL(X,EXPI),DUP,1,XCH,/,ADD,.5,MUL) ;  06900900
BEGIN REAL T ;                                                          07000200
ELSE P(MKS,INTCALL(X,EXPI),DUP,.T,STN,1,XCH,/,DUP,T,ADD,.T,STD,SUB,T,/);07001100
           JUNK = 17 ;                                                  07100400
$VOID 07100501                                                          07100450
IF X LEQ 0 THEN IF X=0 THEN P(0,.JUNK,STN,RTN)                          07100700
                ELSE P(MKS,INTCALL(27,FORTERRI)) ;                      07100710
P(XL,X,0,MKS,INTCALL(X,SQRTI),.JUNK,STN,DLD,0,JUNK,DLA,0,HAF,DLM,.JUNK, 07100800
  STD,RTN) ;                                                            07100810
           JUNK = 17 ;                                                  07200400
$VOID 07200601                                                          07200500
P(MKS,INTCALL(P(MKS,X,INTCALL(Y,CABSI),X,SSP,ADD,HAF,MUL),SQRTI)) ;     07200900
$VOID 07300301                                                          07300300
    P(ABS(X),W,MUL,MKS,INTCALL(XSQ,EXPI),MSRTPI,MUL,T,MUL,/,1,ADD) ;    07301850
$VOID 07400301                                                          07400250
IF X>52 THEN P(MKS,INTCALL(28,FORTERRI)) ;                              07400900
IF S THEN P(DEL,MPI,MKS,INTCALL(P(PI)|Y,SINI),V,MUL,Y,MUL,/) ;          07403300
$VOID 07500351                                                          07500250
IF X LEQ 0 THEN P(MKS,INTCALL(31+(X!0),FORTERRI)) ;                     07500600
IF X<3.28 THEN P(MKS,INTCALL(P(MKS,INTCALL(X,GAMMAI)),LNI),RTN) ;       07500700
               X,DUP,.5,SUB,MKS,INTCALL(X,LNI),MUL,XCH,SUB,ADD) ;       07501900
         ARRAY TPAR[*],FIB[*],FPB=3[*] ;                                07901000
    TPAR~P([TPAR[1]],CFX,SFB)&10[8:38:10] ;                             07902448
                        21                                              99998100
$#PATCH NUMBER  18 FOR INTRINSICS.XII CONTAINS 1 CARDS            I
$VOID 02984261                                                          02984180
$#PATCH NUMBER 19 FOR INTRINSICS.XII CONTAINS 7 CARDS             C
         P(MKS,*[DATX[S]]); IF NOT AC THEN P(0,RDS,CFX,0); P(HIVALU);   00746000
         P(MKS,MHK);  IF NOT AC THEN P(0,CDC,MHK,XCH,RDS,CFX,0);        00770100
              P(HIVALU);                                                00770120
           P(MKS,MHK);  IF NOT AC THEN P(0,CDC,MHK,XCH,RDS,CFX,0);      00822800
              P(HIVALU);                                                00822820
         P(MKS,MHK);  IF NOT AC THEN P(0,CDC,MHK,XCH,RDS,CFX,0);        00827200
              P(HIVALU);                                                00827220
$#PATCH NUMBER 20 FOR INTRINSICS.XII CONTAINS 3 CARDS             C
              IF AC THEN BEGIN   ENDQ ~ 0;                              00817100
                        IF AC.[46:1] THEN P(MKS,BINGO,0,PERFORMGEN)     00817120
                   END ELSE P(MKS,0,*[OUTFIL],0,OUTPRO);                00817200
$#PATCH NUMBER 21 FOR INTRINSICS.XII CONTAINS 2 CARDS             C
              BUFF~(*FILX)&BSIZE[8:38:10] ;                             00207300
              BUFF~(*FILX)&BSIZE[8:38:10] ;                             00608600
$#PATCH NUMBER 22 FOR INTRINSICS.XII CONTAINS  4 CARDS            C
%        I N T R I N S I C S      M A R K    X I I I. 0    07/15/71     00000000
LOOP:    IF TEN[T1~T1+1]{T2 THEN GO LOOP;   SIZ~T1 ;                    07902440
                        0                                               99998100
         DS:=16 LIT "INTRINSICS XIII.";  DS:=2 DEC;                     99998400
$#PATCH NUMBER 23 FOR INTRINSICS.XII CONTAINS  3 CARDS            C
EX1:IF NOT (C!"E" AND C!"D") THEN GO EX ;                               02793500
    IF C="+" OR C="-" THEN BEGIN P(T2,T1+1); SKIP; T2~P END             02793510
    ELSE IF C!"@" OR HOLTOG THEN GO ERR1 ;                              02793515
$#PATCH NUMBER 24 FOR INTRINSICS.XII CONTAINS  6 CARDS            C
EX: IF CODE=10 THEN ERR(2);  P(SGN);  SGN~EXP~1 ;                       02793550
    P(DECPT);  DECPT~1;  CONVERT;  IF SGN THEN P(SSN);  E~(T4~P)+E ;    02793800
         BEGIN IF NOT DECPT THEN E~E-D; IF NOT EXP THEN E~E-SCALE END   02794050
D1: IF P (SCALE,DUP)<0 THEN P(DEL,0) ;                                  02897080
    IF (SKP~-P(D+P,DUP)+W-5-SGN-DLRSGN)<0 THEN GO OVRFLW2 ;             02897100
         IF D THEN ND~-SCALE ELSE T4~SCALE ;                            02897520
$#PATCH NUMBER 25 FOR INTRINSICS.XII CONTAINS 16 CARDS            C
         STREAM(C~0,BUFF,VL~1,SGN~0,T2~0,T1:T~T1.[36:6],HADSGN~SGN) ;   02784400
              BEGIN SI~BUFF; DI~T2 ;                                    02784450
L1:                          CI~CI+HADSGN; GO L2; HADSGN~DI; VL~DI ;    02784750
$VOID 02784801                                                          02784800
                             END ELSE VL~DI ;                           02785350
                             VL~TALLY ;                                 02785725
                             END ELSE BEGIN TALLY~0; VL~TALLY END ;     02786200
         T1~P(SUB,SSP);  SGN~P;  VL~P;  BUFF~P ;                        02786400
         DEBLANKDEZEROGETSGN~(C~P)>9 ;                                  02786425
    IF SGN OR VL THEN P(CHS);  ADDR[0]~P;  IF T2 THEN GO TEST1 ;        02791700
    ELSE IF T1=0 THEN BEGIN SGN~VL OR SGN; GO GOTNUMBER END  ;          02792510
         SGN~WH1.[1:1];  DECPT~CODE>10;  ND~12 ;                        02893600
$VOID 02896561                                                          02896560
         IF P THEN BEGIN IF (CHR~CHR+E)>MAXCHR THEN GO AWAY;P(WH3=0) END02896720
         ELSE IF P(W-D-DECPT-E,DUP)<0 THEN GO OVRFLW2 ;                 02896760
    SGN~WH1.[1:1] ;                                                     02979935
$#PATCH NUMBER 26 FOR INTRINSICS.XII CONTAINS  9 CARDS            C
              END;%                                                     02615140
$VOID 02615161                                                          02615150
                   IF MABUSE OR NOT COB68 THEN%                         02615500
         IF (MABUSE OR NOT COB68) AND I THEN  % LABELED AND NOT SORT    02616800
$VOID 02618646                                                          02618640
                             IF MABUSE OR NOT COB68 THEN%BEG OUT FILE/RL02619410
                   IF MABUSE OR NOT COB68 THEN%                         02620800
                        IF MABUSE OR NOT COB68 THEN% END OUTPUT FILE    02622050
                        IF MABUSE OR NOT COB68 THEN% END OUTPUT FILE/RL 02623300
$#PATCH NUMBER 27 FOR INTRINSICS.XII CONTAINS  3 CARDS            C
         IF DISKSIZE { (Y ~ TBO DIV BF) THEN                            00760200
              DISKSIZE ~ Y + Y   ELSE                                   00760300
              WHILE (DISKSIZE MOD Y)!0 DO DISKSIZE~DISKSIZE + 1;        00760400
$#PATCH NUMBER 28 FOR INTRINSICS.XII CONTAINS 10 CARDS            C
                             DIFFER ~ ABS(DIFFER);%                     09506350
                   D ~ [DESC[0]];%                                      09507300
         P(SLENGTH+DOFSET,DUP,8,IDV,*P(.D),INX,.D,~,7,LND,.DOFSET,~);   09518300
$VOID 09518401                                                          09518400
                P4A~NWDS!0,P5~NDIV64,P5A~NDIV64!0,P6~SMCHR,P7~(TYPE=3   09518800
                AND SMCHR!" "),P8~D);%                                  09518850
         CONT:SI ~ P8; P5(DS ~ 63 WDS); P5A(DS ~ P5 WDS);%              09519400
              P4A(DS ~ P4 WDS);%                                        09519450
                   DOFSET ~ 0;%                                         09520650
                   D ~ [DESC];%                                         09520660
$#PATCH NUMBER  29  FOR  INTRINSICS.XII  CONTAINS  3 CARDS        I
                        IF NOT COB68 THEN IF RANDOM THEN WORDSLEFT~0;   02624610
$ VOID  02624691                                                        02624620
$ VOID  02625181                                                        02625110
$#PATCH NUMBER  30  FOR  INTRINSICS.XII  CONTAINS  4 CARDS        C
                         FOREVER,(IF CODE THEN LINES ELSE 1),      %FOR 02710950
                         KEY=0,CFX,TIP,CODE,36,COM,          %REMOTE OR 02711000
                         FOREVER,(IF CODE THEN LINES ELSE 1),      %FOR 09609750
                         KEY=0,CFX,TIP,CODE,36,COM,          %REMOTE OR 09609800
$#PATCH NUMBER  31  FOR  INTRINSICS.XII  CONTAINS  1 CARDS        C
                                         & (BUFFSIZE-WORDSLEFT) TOSZF   09628350
$#PATCH NUMBER  32  FOR  INTRINSICS.XII  CONTAINS 12 CARDS        C
    ARRAY TEN=22[*], AR1=LISTADDR[*], TPAR=23[*], FPB=3[*], FIB[*] ;    02886640
           PRNTR~((T1~FIB[4].[8:4])=1 OR T1=12 OR T1=7) AND             02892200
                  FPB[FIB[4].[13:11]+3].[43:5]<20 ;                     02892205
ARRAY    FMTA      =  -3[*], FPB = 3[*] ;                               02901600
IF PRNTR~PRNTR&(((T1~FIB[4].[8:4])=1 OR T1=7 OR T1=12) AND FPB[FIB[4]   02911000
         .[13:11]+3].[43:5]<20)[47:47:1] THEN                           02911005
    ARRAY TEN=22[*], AR1=LISTADDR[*], TPAR=23[*], FPB=3[*], FIB[*] ;    02976245
    IF PRNTR~((T1~FIB[4].[8:4])=1 OR T1=7 OR T1=12) AND FPB[FIB[4]      02978585
              .[13:11]+3].[43:5]<20 THEN                                02978590
ARRAY    FMTA      =  -2[*], FPB = 3[*] ;                               02991580
IF PRNTR~PRNTR&(((T1~FIB[4].[8:4])=1 OR T1=7 OR T1=12) AND FPB[FIB[4]   02992880
         .[13:11]+3].[43:5]<20)[47:47:1] THEN                           02992885
$#PATCH NUMBER  33  FOR  INTRINSICS.XII  CONTAINS  6 CARDS        I
         IF NOT P(DUP,LOD).[2:1] THEN                                   00712340
              IF NOT (P(DUP,LOD,DUP).[27:1] AND P(XCH).[7:1]) THEN      00712350
                   P(1,XCH,2,LNG,XCH,INX,72,17,COM);                    00712360
$ VOID                                                                  00713550
$ VOID  00735301                                                        00735200
          IF NOT(*COIOD).[2:1] THEN P(1,[COIOD[NOT 2]],74,17,COM);      00806850
$#PATCH NUMBER  34  FOR  INTRINSICS.XII  CONTAINS  1 CARDS        I
                             IF NUMWDS<1 THEN TERM(36);                 02753450
