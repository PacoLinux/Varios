

07:12 JUL 29 '97 F_CP6_C.:E05SI                                            1    
    1      /*M* F_CP6_C   File management FPT MACROS - Master File */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X* MEC,MOC,EXM=20,CLM=30,CRM=78               */
    8      /* TABS 7,9,21,78 */
    9      /* The *K* name in fields set by the monitor begin with #FC */
   10
   11                          /*F* NAME: File_Manipulation
   12
   13                          File manipulation services are provided to
   14                          control disk files, tape files, and devices.
   15                          The related
   16                          macros for generating vector-located parameters
   17                          are included in a group at the end of this
   18                          subsection.
   19
   20                          As described in the CP-6 Programmer Reference
   21                          Manual, the system maintains account and file
   22                          directories as well as file information tables.
   23                          The monitor provides file manipulation services to
   24                          allow the user to operate on these structures.
   25
   26                          For disk, these services provide extensive
   27                          support for user permanent and scratch files as
   28                          well as for temporary "star" files. These services
   29                          permit the user to:
   30
   31                          o Create or locate files on public storage or
   32                          on a specific pack set (M$OPEN).
   33
   34                          o Control cataloging and disposition of
   35                          permanent files (M$OPEN or M$CLOSE).
   36
   37                          o Supply password protection and access
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            2    
   38                          controls for named files (M$OPEN or
   39                          M$CLOSE).
   40
   41                          o Obtain portions of the file information
   42                          table (M$OPEN; also see Appendix C of
   43                          CE75 for the FIT contents and services
   44                          which allow the user to view portions of the
   45                          FIT).
   46
   47                          The system supports a variety of tape
   48                          file formats, including several ANS standard
   49                          formats. The monitor services permit the user to:
   50
   51                          o Define and create tape volume sets which
   52                          the system supervises, assuring that the
   53                          recording density is uniform and that the
   54                          format is consistent for labeled tapes
   55                          (M$OPEN).
   56
   57                     o Supply password protection and access controls for labeled
   58                     tape CP-6 formats.
   59
   60                     o Obtain portions of the file information
   61                     table (FIT) for labeled tape CP-6
   62                     formats.
   63
   64                     o Control tape volume changes (M$CVOL).
   65
   66                     For devices, monitor services permit the user to:
   67
   68                     o Acquire access to a device through the
   69                     name mentioned when it was reserved on
   70                     a !RESOURCE command.
   71
   72                     o Access unit record devices by use of
   73                     special names (such as LO, ME).  Special
   74                     names provide appropriate defaults for
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            3    
   75                     on-line and batch processing which direct
   76                     input or output to the correct device for
   77                     each of these processing environments.
   78
   79                     o Control logical devices when more
   80                     flexibility is needed than special names
   81                     provide.  Input from or output to a
   82                     device is processed symbiotically, that is
   83                     spooled on disk before being directed to
   84                     a final destination.  Two logical devices
   85                     automatically defined for each user are
   86                     LP01, a line printer; and CP01, a
   87                     card punch.
   88
   89                     */
   90                                    /************************************/
   91                                    /**     M$OPEN- OPEN PROCEDURE     **/
   92                                    /************************************/
   93
   94                          /*F* NAME: M$OPEN - Open DCB.
   95
   96                          The M$OPEN monitor service performs the
   97                          functions necessary to give a user access to the
   98                          I/O medium through a DCB.  For scratch disk files
   99                          and for devices, the open procedure requires
  100                          few parameters.
  101
  102                          In all cases, the open procedure initializes
  103                          the DCB with the parameters supplied in the FPT.
  104                          A number of M$OPEN parameters are meaningful at
  105                          file creation (and have no meaning if specified
  106                          when opening an existing file). File attributes
  107                          are transferred from the open FPT to the DCB and
  108                          to the file information table (FIT) at file
  109                          creation. Whenever the file is opened
  110                          subsequently for input or updating functions, the
  111                          open procedure obtains the attributes from the FIT
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            4    
  112                          and places them in the DCB for use by the monitor.
  113
  114                          The open procedure can be complex, especially
  115                          for disk and labeled tape files. Some or all of
  116                          the following functions may occur during the open
  117                          procedure:
  118
  119                          o Security checking - Access permission
  120                           (ACCESS) and password correctness (PASS)
  121                           are checked for disk and labeled tape files.
  122                           Ownership of resource or authorization to use a
  123                           workstation are checked for devices.
  124
  125
  126                          o Cataloging - On opening a disk file for
  127                           input or update functions, the file
  128                           directory is checked to determine that the
  129                           file exists and, if so, where it is located.
  130                          }
  131                           The user may replace an existing file by
  132                           creating a new file (EXIST=NEWFILE).  The
  133                           user may catalog the new file at open
  134                           time (CTG=YES) which deletes the old file
  135                           at that time also. Or the user may preserve
  136                           the old file while the new file is being
  137                           created; the new file can be cataloged
  138                           when it is closed by specifying SAVE
  139                           disposition which deletes the old file.
  140
  141                          o Shared access checking - Each DCB
  142                           opening a file can specify that other
  143                           DCBs may concurrently use the file for
  144                           input or updating, or that sharing
  145                           is not permitted.  Whether a file open
  146                           is allowed depends on the open status
  147                           of any DCBs currently open to the file
  148                           and options specified for the DCB
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            5    
  149                           attempting to open the file. These options
  150                           are compared and the results of this
  151                           testing either allow the open, or
  152                           disallow the open, giving a 'file busy'
  153                           indication and causing an alternate
  154                           return.  Conditions required for file
  155                           sharing are summarized in Table 3-2 (see
  156                           M$OPEN).  When the open is allowed, the apparent
  157                           status of DCBs currently open to the file is
  158                           changed in some cases, as noted in the
  159                           table.
  160
  161                          o File extension - Disk space allocation is
  162                           performed automatically for some disk files.
  163                           The user may specify the size of the
  164                           secondary extents for keyed, indexed, IREL, unit
  165                           record, and consecutive disk files (XTNSIZE).
  166                           For other file organizations, the user
  167                           may request file extension(M$EXTEND).
  168
  169                          In addition to the conventional open
  170                          functions, the M$OPEN service permits the user to
  171                          request related functions. Among the functions
  172                          available through the M$OPEN service are:
  173
  174                          o Obtaining file attributes and attempting
  175                           security checks without actually opening
  176                           the file (TEST=YES).
  177
  178                          o Specifying indirectly the next disk or labeled
  179                           tape file to be accessed.
  180                           The user can request 1) the next file
  181                           following the file most recently accessed
  182                           by the DCB,  2) the first
  183                           file on the tape volume set or the account's
  184                           file directory, or 3) a file that meets
  185                           certain conditions.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            6    
  186
  187                          o Deleting a disk file from the catalog, which
  188                           results in the release of the granules
  189                           containing the file (DELETE=YES).
  190
  191                          o Reusing a set of file attributes from an
  192                           existing file to create a new file (for
  193                           example, calling M$OPEN with
  194                           FPARAM retrieves the attributes; then calling
  195                           M$OPEN with IFPARAM framing the FPARAM
  196                           attributes can create a new file with the same
  197                           attributes).
  198
  199                           The form of the call for this procedure is as follows:
  200
  201                          CALL M$OPEN (FPT_OPEN)  [ALTRET (label)];
  202
  203                          The options specified in the OPEN FPT override
  204                          those previously specified in the DCB or on
  205                          the SET command.  For each parameter
  206                          not specified, either the current value or the default
  207                          is used.                                                */
  208
  209
  210
  211       %MACRO FPT_OPEN  (FPTN=FPT_OPEN,
  212                IFPARAM=NIL,
  213                NAME=NIL,
  214                PASS=NIL,
  215                ACCESS=NIL,
  216                ACSVEH=NIL,
  217                WINDOW=NIL,
  218                UATTR=NIL,
  219                SN=NIL,
  220                PROCATTR=NIL,
  221                INSTATTR=NIL,
  222                FPARAM=NIL,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            7    
  223                ACCT=NIL,
  224                UHL=NIL,
  225                SETSTA=NIL,
  226                ALTKEYS=NIL,
  227                FPRG=NIL,
  228                IRKEYS=NIL,
  229                NODENAME=NIL,
  230                VIRTUAL=NIL,
  231                TAB=NIL,
  232                RECFIELD=NIL,
  233                HDR=NIL,
  234                IRREC=NIL,
  235                WSN=NIL,
  236                FORM=NIL,
  237                DCB =NIL,
  238                SCRUB(YES='1'B,NO='0'B)='0'B,
  239                REASSIGN(YES='1'B,NO='0'B)='0'B,
  240                SETDCB(YES='1'B,NO='0'B)='0'B,
  241                TEST(YES='1'B,NO='0'B)='0'B,
  242                NXTA(YES='1'B,NO='0'B)='0'B,
  243                NXTF(YES='1'B,NO='0'B)='0'B,
  244                THISF(YES='1'B,NO='0'B)='0'B,
  245              MNTONLY(YES='1'B,NO='0'B)='0'B,
  246             REV(YES='1'B,NO='0'B)='0'B,
  247                DELETE(YES='1'B,NO='0'B)='0'B,
  248                EXIST(OLDFILE=2,NEWFILE=3,ERROR=1)=0,
  249                CTG(YES='1'B,NO='0'B)='01'B,
  250                SHARE(ALL=1,IN=2,NONE=3)=0,
  251                ASN(FILE=1,TAPE=2,DEVICE=3,COMGROUP=4,FPAP=9)=0,
  252                TYPE="BINASC(0)",
  253                RES="BINASC(0)",
  254               DISP(SCRATCH=1,NAMED=2)=0,
  255                FUN(UPDATE=1,IN=2,CREATE=3)=0,
  256                ORG(CONSEC=1,KEYED=2,RANDOM=3,UR=4,RELATIVE=5,
  257                   INDEXED=6,IDS=7,TERMINAL=8,SYMB=9,FPRG=10,CG=11,
  258                   HANDLER=12,IREL=13,
  259                   FIXED=15,VARIABLE=16,UNDEF=17,RESTRICT=18,FREE=19,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            8    
  260                   DBGDCB=20,DBGCG=21,DBGSYSID=22,SE=23,X364=24,FORM=25)=0,
  261              BLOCKED(YES='1'B,NO='0'B)='01'B,
  262              SPANNED(YES='1'B,NO='0'B)='01'B,
  263              ACS(SEQUEN=1,DIRECT=2,BLOCK=3,JRNL=4,UBLOCK=12,
  264                   DS2=5,DS3=6,DS4=7,DS5=8,DS6=9,DS7=10,DS8=11)=0,
  265                LSTAOR(YES='1'B,NO='0'B)='01'B,
  266              JRNLBYPASS(YES='1'B,NO='0'B)='01'B,
  267               GHSTACS(JRNLOPN=2,NONE=3,ANY)=0,
  268                KEYX=0,
  269                KEYL=0,
  270               TERMCONLGL(YES='1'B,NO='0'B)='1'B,
  271               DCBCONLGL(YES='1'B,NO='0'B)='1'B,
  272               OVERFDE(YES='1'B,NO='0'B)='0'B,
  273               AU(YES='1'B,NO='0'B)='01'B,
  274               QISS(YES='1'B,NO='0'B)='01'B,
  275                DELF(YES='1'B,NO='0'B)='0'B,
  276                NOLIST(YES='1'B,NO='0'B)='0'B,
  277                BUF(YES='1'B,NO='0'B)='0'B,
  278                QS(YES='1'B,NO='0'B)='0'B,
  279                ARCHIVE(YES='1'B,NO='0'B)='0'B,
  280                BAD(YES='1'B,NO='0'B)='0'B,
  281                BUPM(YES='1'B,NO='0'B)='01'B,
  282                LOAD(YES='1'B,NO='0'B)='01'B,
  283                XONLY(YES='1'B,NO='0'B)='0'B,
  284                IOERROK(YES='1'B,NO='0'B)='01'B,
  285                IGNOREFSN(YES='1'B,NO='0'B)='01'B,
  286                ANSISPANSEQ(YES='1'B,NO='0'B)='01'B,
  287                ANYF(YES='1'B,NO='0'B)='0'B,
  288                LSLIDE=0,
  289                LRDL0=0,
  290                SPARE=0,
  291                BLKL=0,
  292                RECL=262143,
  293                NRECS=0,
  294                IXTNSIZE=0,
  295                XTNSIZE=0,
  296                VOL=0,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            9    
  297                MAXVOL=0,
  298                CNVRT(YES='1'B,NO='0'B)='01'B,
  299                DVFC="BINASC(0)",
  300                SEQCOL=73,
  301                SEQ(YES='1'B,NO='0'B)='01'B,
  302                LINES=0,
  303                SEQID=' ',
  304                CHAIN=0,
  305                EXPIRE(NEVER=-1,ANY)=0,
  306                 EVENT=0,
  307                EBCDIC(YES='1'B,NO='0'B)='01'B,
  308                DENSITY(D800=2,D1600=3,D6250=4,D38000=5)=0,
  309                VOLACCESS(ALL=1,IN=2,NONE=3)=0,
  310                FINDPOS(YES='1'B,NO='0'B)='0'B,
  311                FSN=0,
  312                DBGDCBNO=0,
  313                DBGSYSID=0,
  314                STCLASS=STATIC,
  315                PFMT="BIT(72)",
  316                XTEND(YES='1'B,NO='0'B)='01'B,
  317                CVOL(YES='1'B,NO='0'B)='01'B,
  318                COMP(YES='1'B,NO='0'B)='01'B,
  319                VECTOR=VECTOR,
  320                KEYTYPE(FLDID=1,COORD=2,NONE=0)=0,
  321                COPIES=0,
  322                SEED='0'B,
  323                SEEDSPECIFIED(YES='1'B,NO='0'B)='0'B,
  324                ATTR='0'B,
  325                UOPT0(YES='1'B,NO='0'B)='01'B,
  326                UOPT1(YES='1'B,NO='0'B)='01'B,
  327                UOPT2(YES='1'B,NO='0'B)='01'B,
  328                UOPT3(YES='1'B,NO='0'B)='01'B,
  329                UOPT4(YES='1'B,NO='0'B)='01'B,
  330                UOPT5(YES='1'B,NO='0'B)='01'B,
  331                UOPT6(YES='1'B,NO='0'B)='01'B,
  332                UOPT7(YES='1'B,NO='0'B)='01'B,
  333                UOPT8(YES='1'B,NO='0'B)='01'B);
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            10   
  334
  335       %LSET LISTDIR='0'B;
  336       %LSET LISTEXP='1'B;
  337       %LSET LISTCOM='0'B;
  338       %LSET LISTSUB='1'B;
  339       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  340       %IF (SUBSTR(STR,0,6)='STATIC') OR
  341       (SUBSTR(STR,0,8)='CONSTANT') OR
  342       (SUBSTR(STR,0,3)='EXT');
  343       %LSET INIT=CHARTEXT('INIT');
  344       %ELSE;
  345       %LSET INIT=CHARTEXT('/*');
  346       %ENDIF;
  347       %IF (TEXTCHAR(ALTKEYS)~='NIL');
  348       %LSET ALTFPRG=TEXTCHAR(ALTKEYS);
  349       %ERROR (TEXTCHAR(FPRG)~='NIL','FPRG ILLEGAL - ALTKEYS SPECIFIED');
  350       %ERROR (TEXTCHAR(IRKEYS)~='NIL','IRKEYS ILLEGAL - ALTKEYS SPECIFIED');
  351       %ELSEIF (TEXTCHAR(FPRG)~='NIL');
  352       %LSET ALTFPRG=TEXTCHAR(FPRG);
  353       %ERROR (TEXTCHAR(IRKEYS)~='NIL','IRKEYS ILLEGAL - FPRG SPECIFIED');
  354       %ELSE;
  355       %LSET ALTFPRG=TEXTCHAR(IRKEYS);
  356       %ENDIF;
  357       %IF (TEXTCHAR(WSN)~='NIL');
  358       %LSET WSNNNAM=TEXTCHAR(WSN);
  359       %ERROR (TEXTCHAR(NODENAME)~='NIL','NODENAME ILLEGAL - WSN SPECIFIED');
  360       %ELSE;
  361       %LSET WSNNNAM=TEXTCHAR(NODENAME);
  362       %ENDIF;
  363       %IF (TEXTCHAR(ACSVEH)~='NIL');
  364       %LSET ACSWIN=TEXTCHAR(ACSVEH);
  365       %ERROR (TEXTCHAR(WINDOW)~='NIL','WINDOW ILLEGAL - ACSVEH SPECIFIED');
  366       %ELSE;
  367       %LSET ACSWIN=TEXTCHAR(WINDOW);
  368      %ENDIF;
  369      %IF (TEXTCHAR(FSN)~='0');
  370      %LSET FSNDBG=TEXTCHAR(FSN);
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            11   
  371      %ERROR (TEXTCHAR(DBGDCBNO)~='0','DBGDCBNO ILLEGAL - FSN SPECIFIED');
  372      %ERROR (TEXTCHAR(DBGSYSID)~='0','DBGSYSID ILLEGAL - FSN SPECIFIED');
  373      %ELSEIF (TEXTCHAR(DBGDCBNO)~='0');
  374      %LSET FSNDBG=TEXTCHAR(DBGDCBNO);
  375      %ERROR (TEXTCHAR(DBGSYSID)~='0','DBGSYSID ILLEGAL - DBGDCBNO SPECIFIED');
  376      %ELSE;
  377      %LSET FSNDBG=TEXTCHAR(DBGSYSID);
  378      %ENDIF;
  379       %IF (TEXTCHAR(UHL)~='NIL');
  380       %LSET UHLSSTA=TEXTCHAR(UHL);
  381       %ERROR (TEXTCHAR(SETSTA)~='NIL','SETSTA ILLEGAL - UHL SPECIFIED');
  382       %ERROR (TEXTCHAR(VIRTUAL)~='NIL','VIRTUAL ILLEGAL - UHL SPECIFIED');
  383       %ELSEIF (TEXTCHAR(SETSTA)~='NIL');
  384       %LSET UHLSSTA=TEXTCHAR(SETSTA);
  385       %ERROR (TEXTCHAR(VIRTUAL)~='NIL','VIRTUAL ILLEGAL - SETSTA SPECIFIED');
  386       %ELSE;
  387       %LSET UHLSSTA=TEXTCHAR(VIRTUAL);
  388       %ENDIF;
  389       %IF (TEXTCHAR(TAB) ~= 'NIL');
  390      %LSET TABFIELD=TEXTCHAR(TAB);
  391        %ERROR (TEXTCHAR(RECFIELD)~='NIL','RECFIELD ILLEGAL - TAB SPECIFIED');
  392       %ELSE;
  393       %LSET TABFIELD=TEXTCHAR(RECFIELD);
  394       %ENDIF;
  395       %IF (TEXTCHAR(HDR) ~= 'NIL');
  396       %LSET HDRIRREC=TEXTCHAR(HDR);
  397       %ERROR (TEXTCHAR(IRREC)~='NIL','IRREC ILLEGAL - HDR SPECIFIED');
  398       %ELSE;
  399       %LSET HDRIRREC=TEXTCHAR(IRREC);
  400       %ENDIF;
  401
  402
  403
  404      DCL 1 FPTN STCLASS,
  405            2 V_ PFMT %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  406                          /*B* PFMT defaults to specify "BIT(72)"
  407                          specifies the format of each parameter in the P area.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            12   
  408                          For modules that require the Assign/Merge
  409                          format, specify -
  410                          PFMT = "PTR", and add VECTOR=ADDR for BASED version     */
  411            2 SN_ PFMT %INIT(VECTOR(SN))%CHARTEXT('/**/'),
  412                          /*K* SN = VARIABLE  Locates an area containing
  413                          a list of tape serial numbers or a pack set
  414                          name.   This area may be generated via the VLP_SN
  415                          macro which is described later in this section.
  416
  417                          For tapes, this list must be in the same order in
  418                          which the volume set was created and cannot contain
  419                          duplicate or blank serial numbers.  Blank serial
  420                          numbers occurring at the end of the list will be
  421                          counted in MAXVOL.  To conform to ANSI standards,
  422                          each serial number must be composed of characters
  423                          from the center four columns of the code
  424                          table specified in ANSI X3.4-1968 except for
  425                          position 5/15 and those positions where there
  426                          is a provision for alternative graphic
  427                          representation.
  428                          */
  429
  430            2 UHL_ PFMT %INIT(VECTOR(%CHARTEXT(UHLSSTA)))%CHARTEXT('/**/'),
  431                          /*K* UHL = VARIABLE
  432                          Locates the VLP_ULBL into which
  433                          User Header Labels (UHLs) are to be read during
  434                          an IN or UPDATE open of a labeled tape file
  435                          or from which UHLs are to be written during a
  436                          CREATE open.  User header labels are 80 bytes each
  437                          and must begin with 'UHL'.  The number of labels
  438                          read is returned in VLP_ULBL.NUM#.
  439
  440                          The user is responsible for determining the proper
  441                          label number (fourth byte) of each written UHL. To
  442                          conform to ANSI standards, the label number and
  443                          contents can be any character from the center four
  444                          columns of the code table specified in ANSI X3.4-1968
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            13   
  445                          except for position 5/15 and those positions where
  446                          there is a provision for alternative graphic
  447                          representation.
  448                                                                             */
  449            2 SETSTA_ REDEF UHL_ PFMT,
  450                          /*K* SETSTA = VARIABLE.  Locates a VLP_SETSTA that
  451                          sets the STATION defaults for reads and writes through
  452                          this COMGROUP DCB. This DCB's name on the COMGROUP
  453                          may also be specified in the VLP_SETSTA.
  454                                                                                  */
  455            2 VIRTUAL_ REDEF UHL_ PFMT,
  456                          /*K* VIRTUAL = VARIABLE.  Locates an area containing
  457                          a VLP_VIRTUAL which describes the parameters
  458                          for a LARGE VIRTUAL segment.  Its presence during the
  459                          open of a KEYED file invokes the large virtual segment
  460                          mechanism for access and modification of the data in
  461                          the file.
  462                          ..::HL "For a description of VLP_VIRTUAL, see"
  463                          ..::HL "Section 4 where other services related to"
  464                          ..::HL "Memory Control are discussed."
  465                          */
  466            2 NAME_ PFMT %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
  467                          /*K* NAME = VARIABLE.
  468                          Specifies the name of the
  469                          file to which the DCB is to be assigned.
  470                          The named file will be maintained on disk storage
  471                          or labeled tape volumes.  For FIXED or
  472                          VARIABLE tape file names, lower-case alphabetic
  473                          characters are not allowed and, to conform to ANSI
  474                          standards, this rule must be observed:  a
  475                          name must be composed of at most 17 characters
  476                          including upper case alphabetic characters, numeric
  477                          characters, space, and the following special
  478                          characters: ! " % & ' ( ) * + , . / ? ; : < > = -.
  479                          For other tape files and NAMED (see DISP) disk files,
  480                          the name may consist of up to 31 alphanumeric characters
  481                          from the following character set: A-Z,a-z,0-9,:,$,_,-.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            14   
  482                          The name is specified in TEXTC form.
  483                          For "star" disk files, the first character is an
  484                          asterisk and may be followed by up to 30 arbitrary bytes.
  485                          For FEP real device handlers (see ORG option
  486                          below), NAME locates the handler name.
  487                          .xeq
  488
  489                          NAME locates an area containing
  490                          the file name.  This area may be generated by
  491                          invoking the VLP_NAME macro.  VLP_NAME
  492                          specifies the name of the
  493                          file to which the DCB is to be assigned.
  494                                                                                  */
  495            2 PASS_ PFMT %INIT(VECTOR(PASS))%CHARTEXT('/**/'),
  496                          /*K* PASS = VARIABLE.
  497                          Is 8 characters with no restriction
  498                          on the choice of characters.  Passwords do not apply
  499                          to FIXED or VARIABLE tape files, or to STAR
  500                          disk files.
  501                          .xeq
  502                          PASS locates an area which
  503                          contains a password.  This area may be
  504                          generated via the VLP_PASS macro.
  505
  506                          The default causes this parameter to be ignored.
  507                                                                                  */
  508            2 ACCESS_ PFMT %INIT(VECTOR(ACCESS))%CHARTEXT('/**/'),
  509                          /*K* ACCESS = VARIABLE     Locates an access
  510                          control list which contains the access permissions
  511                          to the file
  512                          for specific accounts. The list can be created by
  513                          invoking the VLP_ACCESS and VLP_ATTR macros which
  514                          are described later in this section.
  515                                                                                  */
  516            2 ACSVEH_ PFMT %INIT(VECTOR(%CHARTEXT(ACSWIN)))%CHARTEXT('/**/'),
  517                          /*K* ACSVEH = VARIABLE     Locates an access
  518                          vehicle control list which contains the access
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            15   
  519                          permissions to the file for specific processors.
  520                          By defining
  521                          an access vehicle control list, the file creator
  522                          can permit a processor to access the file on
  523                          behalf of a user although the user's account is
  524                          not granted the same permissions.
  525                          The list can be generated by invoking the VLP_ACSVEH
  526                          and VLP_ATTR macros which are described later
  527                          in this section.
  528
  529                          This parameter is valid only in conjunction
  530                          with an access control list which includes
  531                          'EXEC' permission (restriction).
  532                                                                             */
  533            2 WINDOW_ REDEF ACSVEH_ PFMT,
  534                          /*K* WINDOW = VARIABLE   Locates an area containing
  535                          the description of the window to use.  The area may
  536                          be generated by the VLP_WINDOW macro.                   */
  537            2 UATTR_ PFMT %INIT(VECTOR(UATTR))%CHARTEXT('/**/'),
  538                          /*K* UATTR = VARIABLE  Locates an area
  539                     containing user attributes.  Although the CP-6 system places
  540                     no restrictions on setting this data, this
  541                     parameter is available for user processors.
  542                     This area may be generated via the VLP_ATTR macro
  543                     which is described later in this section.                    */
  544            2 INSTATTR_ PFMT %INIT(VECTOR(INSTATTR))%CHARTEXT('/**/'),
  545                          /*K* INSTATTR = VARIABLE.
  546                          Locates an area
  547                     containing installation attributes.  Although the CP-6 system
  548                     places no restrictions on setting this data,
  549                     this parameter is reserved for use by the
  550                     installation manager.
  551                     This area can be generated by invoking the
  552                     VLP_ATTR macro which is described later in this
  553                     section.
  554                     The default is NIL.
  555                     */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            16   
  556            2 PROCATTR_ PFMT %INIT(VECTOR(PROCATTR))%CHARTEXT('/**/'),
  557                          /*K* PROCATTR= VARIABLE     Locates an area
  558                          containing processor attributes.  Although the CP-6 system
  559                          places no restrictions on setting this data,
  560                          this parameter is reserved for use by processors.
  561                          This area may be generated via the VLP_ATTR
  562                          macro which is described later in this section.         */
  563            2 ACCT_ PFMT %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
  564                          /*K* ACCT = VARIABLE.
  565                          The account in which the file is cataloged is 8 characters
  566                          from the ASCII 7-bit set, excluding control characters.
  567                          .xeq
  568
  569                          ACCT locates an area which
  570                          contains the account name.  This area may
  571                          be generated by invoking the VLP_ACCT macro.
  572                          The default causes this parameter to be ignored.
  573                                                                                  */
  574
  575            2 IFPARAM_ PFMT %INIT(VECTOR(IFPARAM))%CHARTEXT('/**/'),
  576                          /*K* IFPARAM = VARIABLE.
  577                          Locates an area
  578                          containing data which is to be used for this
  579                          CREATE open. The FIT data may be obtained from a
  580                          previous call to M$OPEN specifying FPARAM.
  581                          IFPARAM permits a user to copy all attributes of a
  582                          file and to merge these attributes into the DCB
  583                          before the merge of parameters from this open FPT.
  584                          Thus attributes from the IFPARAM area   may be
  585                          overridden by the other open FPT contents.
  586                          The default is NIL.
  587                                                                                  */
  588            2 FPARAM_ PFMT %INIT(VECTOR(FPARAM))%CHARTEXT('/**/'),
  589                          /*K* FPARAM = VARIABLE.
  590                          Locates an area where
  591                          the monitor is to pass portions of the file
  592                          information table (FIT). The area to receive the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            17   
  593                          file attributes should be 1024 words in length to
  594                          accommodate the complete set of file information.
  595                          The file name, serial number and account are not
  596                          passed to the user, but other permanent file
  597                          attributes are returned.
  598                          The library service XSF$LOCCODE
  599                          is  provided to give the user access to the
  600                          contents of the FPARAM area. This  service  allows
  601                          the user to specify a code describing a portion of
  602                          the FPARAM data; the service returns a pointer to
  603                          the desired data which allows the user to access
  604                          the data by field names. For the codes, field
  605                          names, and the format of the call to these
  606                          services, refer to CP-6 Host Library Services
  607                          Reference Manual (CE71).  If NAME=ERASE is
  608                          specified and NXTF is not specified, the FIT
  609                          of the file directory (CODES 14 and 9) is returned.
  610
  611                          If FPARAM locates an area that is less
  612                          than 30 words long, nothing is stored in this area.
  613                          On a TEST=YES open, an FPARAM area less than 30
  614                          words can be specified to cause the file information to
  615                          be returned in the DCB, however.
  616
  617                          FPARAM is not applicable for devices or for labeled tape
  618                          of formats V, D, U, or F.
  619
  620                          The default is NIL.
  621                                                                                  */
  622
  623            2 WSN_ PFMT %INIT(VECTOR(%CHARTEXT(WSNNNAM)))%CHARTEXT('/**/'),
  624                          /*K* WSN = VARIABLE.
  625                          Specifies a workstation
  626                          name or the '@' symbol to mean the user's workstation
  627                          of origin.  This parameter is meaningful for ASN=DEVICE
  628                          in combination with the RES parameter when
  629                          RES is set to a 2-character device mnemonic.  When
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            18   
  630                          WSN is specified, output is sent when the associated
  631                          DCB is closed or at job step (rather than at
  632                          end-of-job, as happens if WSN is blank).  Also, when
  633                          WSN is specified, output through multiple DCBs
  634                          open to the same RES is kept separate (instead of
  635                          being merged, as occurs if WSN is blank).
  636
  637                          NOTE:  WSN must be blank if RES is to specify a
  638                          special name, a logical device defined by LDEV
  639                          or M$LDEV, a device allocated by the RESOURCE
  640                          command, or the reserved logical device name
  641                          LP01 or CP01.
  642
  643                          For ASN=FILE, WSN specifies the name of a network
  644                          node where the designated file is to be accessed
  645                          via the ISO 8571 FTAM protocol, if the ISO FTAM
  646                          feature is installed in your system.
  647
  648                          .xeq
  649                          WSN locates an area containing
  650                          a workstation name.  This area may be
  651                          generated via the VLP_WSN macro.
  652                          The default causes this parameter to be ignored.
  653                          */
  654
  655            2 NODENAME_ REDEF WSN_ PFMT,
  656                          /*K* NODENAME = VARIABLE   Locates a VLP_NODENAME
  657                          area which describes the node to which this device open
  658                          is directed.  It is meaningful only if RES='FE  '
  659                          and is used to convert RES='FE  ' into 'FEnn' where
  660                          nn is a node number. See also RES.
  661                                                                                   */
  662            2 TAB_ PFMT %INIT(VECTOR(%CHARTEXT(TABFIELD)))%CHARTEXT('/**/'),
  663                          /*K* TAB = VARIABLE     Locates an area
  664                          containing a horizontal tabulation definition.
  665                          This area may be generated via the VLP_TAB macro
  666                          which is described later in this section.               */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            19   
  667            2 RECFIELD_ REDEF TAB_ PFMT,
  668                          /*K* RECFIELD = VARIABLE.
  669                          Locates an area containing the physical field
  670                          definitions for records in the file.  This area
  671                          may be generated via the VLP_RECFIELD macro which
  672                          is described later in this section.  RECFIELD is
  673                          meaningful only on create opens of IREL, INDEXED,
  674                          KEYED, CONSECUTIVE, or RELATIVE files.  The
  675                          default is NIL.                                         */
  676
  677            2 HDR_ PFMT %INIT(VECTOR(%CHARTEXT(HDRIRREC)))%CHARTEXT('/**/'),
  678                          /*K* HDR = VARIABLE     Locates an area containing
  679                          a printer page header definition. The area may
  680                          be generated by invoking the VLP_HDR macro which
  681                          is described later in this section.                     */
  682            2 IRREC_ REDEF HDR_ PFMT,
  683                          /*K* IRREC = VARIABLE.
  684                          Locates an area describing the logical order of
  685                          fields for records in the file.  This area may be
  686                          generated via the VLP_IRREC macro which is
  687                          described later in this section.
  688                          Meaningful only on create opens of IREL, INDEXED,
  689                          KEYED, CONSECUTIVE, or RELATIVE files.
  690                          RECFIELD must also be specified.
  691                          The default is NIL.
  692                          */
  693            2 FORM_ PFMT %INIT(VECTOR(FORM))%CHARTEXT('/**/'),
  694                          /*K* FORM = VARIABLE.
  695                          Locates an area
  696                          containing a unit record form name.
  697                          This area may be generated via the VLP_FORM macro
  698                          which is described later in this section.  In case of
  699                          a conflict between this option and FORM for M$LDEV,
  700                          the M$LDEV form definition is used.
  701                          The default is NIL.
  702                                                                                  */
  703            2 ALTKEYS_ PFMT %INIT(VECTOR(%CHARTEXT(ALTFPRG)))%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            20   
  704                          /*K* ALTKEYS = VARIABLE.
  705                          Locates an area containing alternate key
  706                          definitions.  This area may be generated via the
  707                          VLP_ALTKEYS macro which is described later in this
  708                          section.  Meaningful only on create opens of
  709                          INDEXED files.  The default is NIL.                     */
  710
  711            2 FPRG_ REDEF ALTKEYS_ PFMT,
  712                          /*K* FPRG = VARIABLE.
  713                          Locates an area containing
  714                          a VLP_FPRG specifying a FEP rununit.
  715
  716                          If this is an ORG=FPRG open of the user's terminal
  717                          or of a resource device, the specified FEP rununit
  718                          will be loaded as a result of this M$OPEN.
  719
  720                          If this is symbiont device open or a file open,
  721                          the VLP_FPRG specifies a FEP rununit to be loaded
  722                          into the path to the destination device whenever
  723                          the contents of this file are sent to a FEP device.
  724
  725                          When an M$OPEN is performed and FPRG is specified,
  726                          the profile of the destination is returned in the
  727                          profile area of the VLP_FPRG structure.
  728
  729                          The default is NIL.
  730                                                                                  */
  731
  732            2 IRKEYS_ REDEF ALTKEYS_ PFMT,
  733                          /*K* IRKEYS = VARIABLE.
  734                          Locates an area containing Indexed Relational
  735                          (IREL) key definitions.  This area may be generated
  736                          via the VLP_IRKEYS macro which is described later
  737                          in this section.  Meaningful on create opens of
  738                          IREL files only.  RECFIELD must also be specified.
  739                          The default is NIL.                                     */
  740
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            21   
  741            2 V DALIGNED,
  742              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
  743                          /*K* DCB = DCBNAME.
  744                          Specifies the name of the DCB.
  745                          DCB is used to refer to the DCB in !SET  commands
  746                          and data manipulation FPT invocations.
  747                          This parameter is required.
  748
  749                          Certain names
  750                          listed in Table 3-1 cause the monitor to provide
  751                          appropriate defaults for FUN and RES when the DCB is
  752                          initialized by a process other than the M$DCB macro.
  753
  754
  755                          ..::TB "DCB Defaults as a Function of DCBname"
  756                          }DCBN     FUN       RES   DCBN(d)   FUN        RES
  757                          }
  758                          }(a)      (f)       ME    F$xxx (e) (f)        ME
  759                          }M$LO     CREATE    LO    F$101     IN         ME
  760                          }M$LL     CREATE    LO    F$102     CREATE     ME
  761                          }M$DO     CREATE    LO    F$103     IN         NO
  762                          }M$PO     CREATE    NO    F$104     CREATE     NO
  763                          }M$SI     IN        CR    F$105     IN         CR
  764                          }M$SO     CREATE    NO    F$106     CREATE     CP
  765                          }M$UI     IN        CR    F$107     UPDATE     ME
  766                          }M$OU     CREATE    (c)   F$108     CREATE     LO
  767                          }M$EI     IN        CR    F$5       IN         CR
  768                          }M$EO     CREATE    NO    F$6       CREATE     LO
  769                          }M$ME     UPDATE    ME    F$7       CREATE     CP
  770                          }M$DR     CREATE    (g)
  771                          }#1  (b)  IN        CR
  772                          }#2  (b)  IN        CR
  773                          }#3  (b)  CREATE    (c)
  774                          }#4  (b)  CREATE    LO
  775                          }
  776                          }--------------------------------------------------
  777                          a  Any other 1- to 31-character name that conforms
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            22   
  778                     a  Any other 1- to 31-character name that conforms to language
  779                     requirements; refer to the appropriate language manual for
  780                character set restrictions.  IBEX also places restrictions on the
  781                DCB name specified in a !SET command; refer to the CP-6
  782                Programmer Reference for details.
  783                b  These are actually positions on a command line.  Typically,
  784                they are used by compiler/processor invoking commands to
  785                establish source (#1), update (#2), object (#3), and listout
  786                (#4) DCBs.  The defaults for #1 through #4 take precedence over
  787                defaults for the DCB name, as do their (implied) SET commands.
  788                c  This DCB defaults to the 'GO' file (a disk file with the name
  789                *G).
  790                d  The FORTRAN compiler assigns FORTRAN program DCBs F$ names.
  791                Other processors or users may also create F$ DCB names.
  792                e  Any other DCB name beginning with F$.
  793                f  Depends on the first operation. If M$WRITE, FUN is set to
  794                CREATE, otherwise FUN is set to IN.
  795                g  M$DR is the DCB used to perform the DRIBBLE function, and as
  796                such, is always opened with an assign-merge record specifying a
  797                FID.
  798                ..::TB                                                            */
  799
  800              3 INITZ,
  801                          /*B* INITZ is not a single parameter, but includes
  802                          SCRUB and REASSIGN and defines the type of
  803                          initialization to be performed on the DCB.              */
  804                4 SCRUB# BIT(1) %INIT(SCRUB)%CHARTEXT('/**/') UNAL,
  805                          /*K* SCRUB = {YES|NO} YES specifies that the DCB is
  806                          to be completely erased and then reinitialized
  807                          with default  conditions. The scrubbing of
  808                          the DCB occurs prior to the remerge of values from
  809                          the  SET command (if REASSIGN=YES) and prior
  810                          to the merge of parameters from this open FPT.
  811                          The default is NO.                                      */
  812
  813                4 REASSIGN# BIT(1) %INIT(REASSIGN)%CHARTEXT('/**/') UNAL,
  814                          /*K* REASSIGN= {YES|NO} YES requests that the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            23   
  815                          assign/merge record (values from the  SET
  816                          command) is to be remerged into the DCB.
  817                          Following the merge of the values from the SET
  818                          command into the DCB, the parameters from the open
  819                          FPT are merged into the DCB.
  820
  821                          The REASSIGN parameter permits the user to
  822                          return a DCB to its original state at the start of
  823                          the program, by opening with SCRUB=YES
  824                          and REASSIGN=YES. The REASSIGN parameter also
  825                          allows a user to override the usual merge sequence
  826                          as follows: (1)  the user calls M$GETDCB with
  827                          MERGE=NO to obtain a DCB, (2) next the user calls
  828                          M$OPEN with SETDCB=YES to initialize but not open
  829                          the DCB, (3) then the user calls M$OPEN with
  830                          REASSIGN=YES as the only parameter in the FPT; as
  831                          a result the values from the SET command are
  832                          merged into the DCB after the
  833                          program-specified OPEN values, instead of before them.
  834                          The default is NO.
  835
  836                          NOTE:  For DCBs which were present at program invocation
  837                          or were obtained via M$GETDCB with the MERGE option, the
  838                          SET command values are already in the DCB unless it has
  839                          been altered by M$OPEN.
  840                          */
  841
  842              3 SETDCB# BIT(1) %INIT(SETDCB)%CHARTEXT('/**/') UNAL,
  843                          /*K* SETDCB = {YES|NO} YES specifies that the
  844                          M$OPEN process is to merge the parameters of this
  845                          open FPT into the DCB (including the SCRUB or REASSIGN
  846                          operations, if requested).  However, the
  847                          DCB is not to be opened.  Only those options that can
  848                          be stored in a closed DCB can be successfully placed
  849                          there via the SETDCB option.  Such options consist of
  850                          those that are COMMON to the M$DCB and FPT_OPEN macros.
  851                          The default for the SETDCB option is NO.                */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            24   
  852
  853              3 DELETE# BIT(1) %INIT(DELETE)%CHARTEXT('/**/') UNAL,
  854                          /*K* DELETE = {YES|NO}  Applies to disk files only.
  855                          YES specifies that the M$OPEN service is to delete
  856                          the specified file.  An open never occurs,
  857                          but DELETE observes the rules of a successful
  858                          FUN=IN or FUN=UPDATE open, prior to deleting
  859                          a file.
  860                          When FUN=CREATE, DELETE has no meaning.
  861                          The default is DELETE=NO.                               */
  862
  863              3 OPER,
  864                          /*B* OPER includes the types of open operations.        */
  865                4 TEST# BIT(1) %INIT(TEST)%CHARTEXT('/**/') UNAL,
  866                          /*K* TEST = {YES|NO}.
  867                          Is meaningful for disk and labeled
  868                          tape files only. TEST=YES specifies that this is
  869                          a test operation: the DCB is not opened and
  870                          subsequently does not require a close. TEST=YES
  871                          is normally used in conjunction with the NXTA,
  872                          NXTF, and FPARAM parameters to obtain
  873                          information regarding
  874                          files via the DCB.
  875
  876                          If FPARAM is specified or the function is not IN,
  877                          security checks are
  878                          made and the alternate return is taken if the user
  879                          does not have access to the file. If FPARAM is
  880                          not specified, the FIT is not accessed, returning only
  881                          the filename and directory descriptors in the DCB.
  882
  883                          Under no circumstances will the error 'file busy'
  884                          be returned when TEST=YES.
  885
  886                          The default is NO.
  887                                                                                  */
  888                4 NXTA# BIT(1) %INIT(NXTA)%CHARTEXT('/**/') UNAL,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            25   
  889                          /*K* NXTA = {YES|NO}.
  890                          Has meaning only for disk files.
  891                          NXTA=YES specifies that the user wants to access a
  892                          different account which is obtained from the pack
  893                          set account directory (PAD) if the SN parameter is
  894                          specified or from the master account directory(MAD) if
  895                          the SN parameter is not specified. The monitor
  896                          obtains the account name following the account
  897                          specified in the DCB and then changes the DCB to
  898                          reflect this next account. If no account is
  899                          specified in the DCB, the monitor places the first
  900                          account in the directory into the DCB. If there
  901                          are no more accounts available, the alternate
  902                          return is taken.
  903                          The default is NO.
  904                                                                                  */
  905
  906
  907                4 NXTF# BIT(1) %INIT(NXTF)%CHARTEXT('/**/') UNAL,
  908                          /*K* NXTF= {YES|NO} is meaningful only for
  909                          disk files or labeled tape files. NXTF=YES
  910                          specifies that when the DCB is opened the monitor
  911                          is to access the next file in sequence (following
  912                          the one most recently accessed via the DCB). If
  913                          no file name or file sequence number is specified
  914                          (currently) in the DCB, the first file on the tape
  915                          or in the account file directory is accessed. If
  916                          there are no more files available, the alternate
  917                          return is taken.
  918
  919                          The effect of NXTF can be modified by other
  920                          parameters specified for the M$OPEN call; see the
  921                          parameters THISF and SRCHCOND.
  922                          The default is NO.                                      */
  923
  924                4 THISF# BIT(1) %INIT(THISF)%CHARTEXT('/**/') UNAL,
  925                          /*K* THISF = {YES|NO} is meaningful only in
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            26   
  926                          conjunction with NXTF. THISF=YES specifies that
  927                          the search for the next file is to start with the
  928                          file named in the DCB, not the file following the
  929                          one named. For tapes, the file may be specified
  930                          by name or by file sequence number (FSN).               */
  931
  932                4 MNTONLY# BIT(1) %INIT(MNTONLY)%CHARTEXT('/**/') UNAL,
  933                          /*K* MNTONLY = {YES|NO}.
  934                          YES specifies that the initial
  935                          tape volume is to be mounted without opening any files.
  936                          The tape volume is positioned to its beginning.
  937                          MNTONLY is only meaningful for tapes.
  938                          The file sequence number (FSN) and file
  939                          section number (FSECT) of the first file (section)
  940                          are returned in the DCB for labelled tapes.
  941                          F$DCB.ASN# is set to TAPE for labelled tapes and to DEVICE
  942                          for free or managed tapes.
  943                          The default causes this parameter to be ignored.
  944                                                                                  */
  945              3 EXIST# UBIN(2) %INIT(EXIST)%CHARTEXT('/**/') UNAL,
  946                          /*K* EXIST = OPTION.
  947                          Is meaningful at CREATE
  948                          opens for disk files only. Named disk files
  949                          (DISP=NAMED) are conditionally created according
  950                          to the EXIST options listed next, provided there
  951                          are no sharing conflicts (see SHARE parameter).
  952                          Scratch files are unconditionally created (thus
  953                          the EXIST parameter is not meaningful if
  954                          DISP=SCRATCH).
  955
  956                          ERROR - Requests new file creation if a file of
  957                          this name does not exist. If a file of the same
  958                          name exists
  959                          the alternate return is
  960                          taken.
  961
  962                          NEWFILE - Requests new file creation even if a
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            27   
  963                          file of the same name exists. The new file
  964                          replaces any existing old file if CTG=YES on the
  965                          create open or if the new file is closed with
  966                          DISP=SAVE.
  967                          .BRF
  968                          NOTE:  When EXIST=NEWFILE and FUN=CREATE, EXIST
  969                          operates as if it were OLDFILE if all the following
  970                          conditions are true:
  971
  972                          1.  The M$OPEN does not specify NAME.
  973                          2.  The previous open of the DCB of this name in
  974                          this session (not necessarily in the job step)
  975                          specified FUN = CREATE, EXIST = NEWFILE.
  976                          3.  A SET or RESET command for this DCB has not
  977                          been issued since the previous open.
  978
  979                          See the CTG parameter for a discussion of the
  980                          types of concurrent use of the new and old files
  981                          by other users. If another user already has the
  982                          old file open with FUN=UPDATE or FUN=CREATE, the
  983                          alternate return is taken.
  984
  985                          OLDFILE - Requests that the existing file be
  986                          opened to end-of-file.  This is similar to
  987                          opening a file with FUN=UPDATE.  If the user
  988                          is not allowed to write records to the existing
  989                          file, then the altreturn is taken.  If a file
  990                          of the same name does not exist, a new file is
  991                          created.
  992                          .xeq
  993
  994                          The default causes this parameter to be ignored.
  995                          */
  996
  997              3 CTG# BIT(2) %INIT(CTG)%CHARTEXT('/**/') UNAL,
  998                          /*K* CTG = {YES|NO}.
  999                          is meaningful only for
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            28   
 1000                          CREATE opens of disk files. This parameter
 1001                          controls cataloging of the file at open time.
 1002
 1003                          YES specifies that the file is to be
 1004                          cataloged in the file directory at open time. If
 1005                          EXIST=NEWFILE, any existing old file of the same
 1006                          name is deleted from the file directory (and is
 1007                          released when any current users close the old
 1008                     file). When CTG=YES and SHARE=ALL or SHARE=IN, the new file
 1009                     may be concurrently opened by other users, as if it
 1010                     were opened UPDATE instead of CREATE.
 1011
 1012                     NO specifies that the file is not to be
 1013                     cataloged at open time. If CTG=NO and a new file
 1014                     is being created (EXIST=NEWFILE, EXIST=ERROR, or
 1015                     EXIST=OLDFILE when the old file does not exist), the newly
 1016                     created file is not available for access by other
 1017                     users until after it is closed for the first time
 1018                     with DISP=SAVE.
 1019                     .xeq
 1020
 1021                     The default causes this parameter to be ignored.
 1022                     */
 1023
 1024              3 SHARE# UBIN(2) %INIT(SHARE)%CHARTEXT('/**/') UNAL,
 1025                          /*K* SHARE = OPTION.
 1026                          Is meaningful for disk files and
 1027                          comgroups only, and is applicable for disk files
 1028                          only if ORG is not CONSEC or UR.
 1029                          SHARE restricts concurrent usage of a file by multiple
 1030                          DCBs.  The SHARE options are:  NONE, IN, and ALL.
 1031                          File management allows a DCB to be opened to a file
 1032                          only after examining the FUN, EXIST, and SHARE
 1033                          parameters specified for this user and the FUN and
 1034                          SHARE options in effect for any other DCBs
 1035                          currently open to the file.  Table 3-2 shows the
 1036                          conditions under which a DCB is permitted to open
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            29   
 1037                          the file that is to be shared with other DCBs. If
 1038                          parameters on this open call are incompatible with
 1039                          current usage of the file, the alternate return is
 1040                          taken with a 'file busy' indication given.  If this
 1041                          open succeeds, the FUN and SHARE parameters
 1042                          on this open may alter or set the current usage
 1043                          status of the file.
 1044                          .xeq
 1045                          (See Table 3-2 for complete information on this
 1046                          topic.)
 1047
 1048                          The default causes this parameter to be ignored.
 1049
 1050                          Normally, file management will be able to
 1051                          maintain the user's current position when
 1052                          SHARE=ALL has been specified, and updates
 1053                          are being made to the
 1054                          file.  The exception to this is with alternate
 1055                          indexes in Indexed and IREL files.  In order
 1056                          to access a record on an alternate index when
 1057                          SHARE=ALL has been specified, a key MUST be
 1058                          specified.
 1059                          ..::HL ".BRP"
 1060                          ..::TB "Conditions for Shared Use of Disk Files"
 1061                     }Intent of       Parameters on current    Current Usage (1)
 1062                     }Current M$OPEN  M$OPEN:                  of the file
 1063                }---------------------------------------------------------------
 1064                }Replace         FUN=CREATE, DISP=NAMED   FUN=IN
 1065                }existing        EXIST=NEWFILE            SHARE=NONE or IN
 1066                }file            SHARE=n/a
 1067                }---------------------------------------------------------------
 1068                }Open existing   FUN=IN                   FUN=IN
 1069                }file for        SHARE=NONE or IN         SHARE=NONE or IN
 1070                }input           -----------------------------------------------
 1071                }                FUN=IN                   FUN=IN
 1072                }                SHARE=ALL                SHARE=NONE, IN or ALL
 1073                }                                      -------------------------
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            30   
 1074                }                                         FUN=UPDATE
 1075                }                                         SHARE=IN or ALL (2)
 1076                }---------------------------------------------------------------
 1077                }Update a file   FUN=UPDATE (3)           (no other DCBs may be
 1078                }                SHARE=NONE               open to the file)
 1079                }                -----------------------------------------------
 1080                }                FUN=UPDATE (3)           FUN=IN (4)
 1081                }                SHARE=IN                 SHARE=ALL (4,2)
 1082                }                -----------------------------------------------
 1083                }                FUN=UPDATE (3)           FUN=IN (5)
 1084                }                SHARE=ALL                SHARE=ALL (2)
 1085                }                -----------------------------------------------
 1086                }                FUN=UPDATE (3)           FUN=UPDATE
 1087                }                SHARE=ALL                SHARE=ALL (2)
 1088                }---------------------------------------------------------------
 1089                .FIF
 1090                .FIN
 1091                .inl 6
 1092                .unl 4
 1093                .unl 4
 1094                1.  The current usage status is initialized from the FUN and SHARE
 1095                options of the first opener of the file.
 1096                .unl 4
 1097                2.  The current usage status of a consecutive or unit-record file
 1098                is forced to SHARE=NONE.  A consecutive file may be used as a common
 1099                journal, however (see ACS=JRNL).
 1100                .unl 4
 1101                3.  The options FUN=CREATE, EXIST=OLDFILE, DISP=NAMED are equivalent
 1102           to FUN=UPDATE for purposes of determining if file sharing is allowed.
 1103           .unl 4
 1104           4.  The Current Usage status of the file (FUN=IN, SHARE=ALL)
 1105           is changed to FUN=UPDATE and SHARE=IN.  Following the file close
 1106           by the DCB which opened to update the file, current usage status
 1107           reverts to FUN=IN and SHARE=ALL.
 1108           .unl 4
 1109           5.  The Current Usage status of the file (FUN=IN) is
 1110           changed to FUN=UPDATE and thereafter no other DCBs may open the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            31   
 1111           file with SHARE=IN until all DCBs currently open to the file
 1112           are closed.
 1113           .inl 0
 1114
 1115           ..::TB
 1116           */
 1117
 1118              3 CVOL# BIT(2) %INIT(CVOL)%CHARTEXT('/**/') UNAL,
 1119                          /*K* CVOL = {YES|NO}.
 1120                          YES specifies that the user
 1121                          desires to be notified (via ALTRET on M$READ or
 1122                          M$WRITE) of end-of-volume conditions.  For
 1123                          labeled tapes the user may then M$CVOL to cause
 1124                          the next volume to be mounted or perform another
 1125                          I/O request which automatically causes the next
 1126                          volume to be mounted.  CVOL is primarily useful
 1127                          when user trailing labels are desired and may cause
 1128                          the ALTRETurning M$WRITE to fail in which case it
 1129                          must be retried.
 1130
 1131                          CVOL should only be specified for SPANNED=NO tape
 1132                          files since spanned tape files may have records
 1133                          which cross volume boundaries.  These records are
 1134                          difficult to process if the user takes CVOL
 1135                          control.
 1136
 1137                          For free tapes, end-of-tape will be reported
 1138                          to permit the user to M$CVOL to the next output
 1139                          tape or M$WRITE which automatically mounts the
 1140                          next output tape.  For read operations, two file marks
 1141                          are interpreted to indicate end-of-volume.
 1142                          A read encountering two file marks will
 1143                          1) if CVOL was specified, return an end-of-file
 1144                          error and leave tape position after the first
 1145                          file mark or 2) if CVOL was not specified,
 1146                          cause the next volume to be automatically
 1147                          mounted and read.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            32   
 1148                          .xeq
 1149
 1150                          The default causes this parameter to be ignored.
 1151                                                                             */
 1152
 1153              3 FINDPOS# BIT(1) UNAL %INIT(FINDPOS)%CHARTEXT('/**/'),
 1154                          /*K* FINDPOS = {YES|NO}.
 1155                          YES specifies that
 1156                          although an I/O error has been detected on
 1157                          a tape, the next HDR1 label (start of file)
 1158                          is to be located on a NXTF open.  Note that
 1159                          more than 1 file may be skipped (check F$DCB.FSN#
 1160                          to determine this) and that further I/O errors
 1161                          are ignored until a HDR1 label is found (might
 1162                          result in tape going off reel end).
 1163                          The default is NO.
 1164                                                                                  */
 1165              3 SRCHCOND,
 1166                          /*K* SRCHCOND.   Specifies a mask of bits that
 1167                          are used to select what files are to be found when
 1168                          NXTF=YES. The user sets mask bits via the
 1169                          keywords listed below. For example, specifying
 1170                          ANYF=YES sets the SRCHCOND.ANYF field in the FPT.
 1171                          If SRCHCOND is zero, NXTF returns the next
 1172                          existing file. If SRCHCOND is non-zero, the next
 1173                          file with any of the selected descriptor bits set
 1174                          is found (the descriptor bits are stored in the
 1175                          DESC portion of the DCB).  The default is zero.
 1176                                                                                  */
 1177                4 DELF# BIT(1) %INIT(DELF)%CHARTEXT('/**/'),
 1178                          /*K* SRCHCOND.DELF = {YES|NO} When NXTF=YES and
 1179                          DELF=YES, the open process searches for a deleted
 1180                          file.                                                   */
 1181                4 NOLIST# BIT(1) %INIT(NOLIST)%CHARTEXT('/**/'),
 1182                          /*K* SRCHCOND.NOLIST = {YES|NO} When NXTF=YES and
 1183                          NOLIST=YES, the open process searches for a file
 1184                          with the 'no list' attribute.                           */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            33   
 1185                4 BUF# BIT(1) %INIT(BUF)%CHARTEXT('/**/'),
 1186                          /*K* SRCHCOND.BUF = {YES|NO} When NXTF=YES and
 1187                          BUF=YES, the open process searches for a file that
 1188                          is to be backed up.                                     */
 1189                4 * BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1190                4 BAD# BIT(1) %INIT(BAD)%CHARTEXT('/**/'),
 1191                          /*K* SRCHCOND.BAD = {YES|NO} When NXTF=YES and
 1192                          BAD=YES, the open process searches
 1193                          for a file with a file inconsistency.                   */
 1194                4 QS# BIT(1) %INIT(QS)%CHARTEXT('/**/'),
 1195                          /*K* SRCHCOND.QS = {YES|NO} When NXTF=YES and
 1196                          QS=YES, the open process searches for a file
 1197                          that is queued for the EFT ARChive or RETrieve process. */
 1198                4 * BIT(2) %INIT('0'B)%CHARTEXT('/**/'),
 1199                4 ARCHIVE# BIT(1) %INIT(ARCHIVE)%CHARTEXT('/**/'),
 1200                          /*K* SRCHCOND.ARCHIVE = {YES|NO}  When NXTF=YES
 1201                          and ARCHIVE=YES the open process searches for
 1202                          a file that is known to the archive system.             */
 1203                4 ANYF# BIT(1) %INIT(ANYF)%CHARTEXT('/**/'),
 1204                          /*K* SRCHCOND.ANYF = {YES|NO} When NXTF=YES and
 1205                          ANYF=YES, the open process stops on every entry in
 1206                          the file directory, even deleted entries.               */
 1207                4 * BIT(7) %INIT('0'B)%CHARTEXT('/**/'),
 1208                4 REV# BIT(1) %INIT(REV)%CHARTEXT('/**/'),
 1209                          /*K* SRCHCOND.REV = {YES|NO} When NXTF or NXTA=YES and
 1210                          REV=YES, the open process searches the file or account
 1211                          directory in reverse order.                             */
 1212
 1213              3 FUN# UBIN(9) %INIT(FUN)%CHARTEXT('/**/') UNAL,
 1214                          /*K* FUN = OPTION.
 1215                          Applies to comgroups, disk and
 1216                          tape files used to read, update or create a file.
 1217                          Unless otherwise specified, record positioning
 1218                          is to the first data record in the file.
 1219                          For devices, FUN specifies the I/O operations
 1220                          to be allowed.
 1221
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            34   
 1222                          IN - Used to read records from a file.
 1223                          Specifies the read only mode.
 1224
 1225                          UPDATE - Used to update records in a file.
 1226                          Specifies the read and write mode.  On
 1227                          opening an existing UR file for UPDATE,
 1228                          the file will be positioned at the end,
 1229                          not the beginning as for non-UR files.
 1230
 1231                          CREATE - The type of file open that CREATE
 1232                          performs will depend on the parameters of
 1233                          the M$OPEN option EXIST.  See EXIST for
 1234                          details.  Specifies the write and read mode.
 1235                          If the file is cataloged at M$OPEN time
 1236                          (CTG=YES), the function effectively changes
 1237                          to UPDATE (FUN=UPDATE).  This means that any
 1238                          of the SHARE options specified will apply.
 1239
 1240                          .xeq
 1241                          The default causes this parameter to be ignored.
 1242                                                                                  */
 1243
 1244              3 ASN# UBIN(9) %INIT(ASN)%CHARTEXT('/**/') UNAL,
 1245                          /*K* ASN = OPTION.
 1246                          FILE, TAPE, DEVICE, or COMGROUP
 1247                          indicates whether the DCB parameters describe
 1248                          a DISK file (FILE), a labeled tape (TAPE),
 1249                          a specific device (DEVICE), or a communication
 1250                          group (COMGROUP).
 1251                          .xeq
 1252                          The default causes this parameter to be ignored.
 1253                          */
 1254
 1255              3 UOPT#(0:8) BIT(2)%INIT(UOPT0,UOPT1,UOPT2,UOPT3,UOPT4,
 1256                UOPT5,UOPT6,UOPT7,UOPT8)%CHARTEXT('/**/'),
 1257
 1258                          /*K* UOPT0 - UOPT8 = {YES|NO}.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            35   
 1259                          Specify flags
 1260                          controllable by !SET, M$DCB, and M$OPEN for use by
 1261                          programs.  These flags are ignored by the monitor
 1262                          and are available for passing information to a user
 1263                          program or processor via a DCB.  The significance
 1264                          of these flags is program dependent.  Information
 1265                          concerning their use should be obtained from
 1266                          documentation for the processor for which they
 1267                          are specified.  If more than one processor or user
 1268                          program references a DCB, care should be taken to
 1269                          ensure that flags are set or reset appropriately
 1270                          for each.
 1271                          .xeq
 1272                          The default causes this parameter to be ignored.
 1273                                                                                  */
 1274              3 ORG# UBIN(9) %INIT(ORG)%CHARTEXT('/**/') UNAL,
 1275                          /*K* ORG = OPTION.
 1276                          File organization.
 1277
 1278                          When ASN=FILE, COMGROUP or TAPE, ORG is meaningful
 1279                          for FUN=CREATE opens only.
 1280
 1281                          CONSEC specifies that the records in
 1282                          the file are consecutively organized and
 1283                          each record will be processed sequentially.
 1284
 1285                          DBGCG is legal for ASN=DEVICE issued from the
 1286                          debugger domain only and specifies that this DCB
 1287                          is to be opened as a pathway across which the
 1288                          debugger will communicate with its FEP
 1289                          counterpart in order to debug a FEP user.
 1290                          The FEP user to debug is specified by the
 1291                          NAME, ACCT, PSN and SETSTA parameters which are
 1292                          used to describe a STATION on a COMGROUP that is
 1293                          to be debugged.
 1294
 1295                          DBGDCB is legal for ASN=DEVICE issued from the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            36   
 1296                          debugger domain only and specifies that this DCB
 1297                          is to be opened as a pathway across which the
 1298                          debugger will communicate with its FEP
 1299                          counterpart in order to debug a FEP user.
 1300                          The FEP user to debug is specified by the
 1301                          DBGDCBNO (in the M$OPEN FPT) which specifies the
 1302                          DCB number to which the FEP user is connected.
 1303
 1304                          DBGSYSID is legal for ASN=DEVICE issued from the
 1305                          debugger domain only and specifies that this DCB
 1306                          is to be opened as a pathway across which the
 1307                          debugger will communicate with its FEP
 1308                          counterpart in order to debug a FEP user.
 1309                          The FEP user to debug is specified by the
 1310                          DBGSYSID (in the M$OPEN FPT) which gives the FEP user's
 1311                          sysid and by RES='FEnn' specifying that the user
 1312                          resides on node nn, or by RES='FE  ' in
 1313                          conjunction with the NODENAME (at M$OPEN) which
 1314                          gives the name of the node on which the user resides.
 1315
 1316                          FIXED specifies ANS or EBCDIC tape format F -
 1317                          fixed-length (RECL) records with no control
 1318                          information.  (See EBCDIC, CNVRT, BLOCKED.)
 1319
 1320                          FORM specifies that an FEP-attached terminal or an
 1321                          FEP-attached line printer is to be operated using
 1322                          a field-oriented form.  A form is within
 1323                          an area defined by a CP-6 window.  The
 1324                          contents of the form is defined by field declarations.
 1325                     The user program declares the position on the screen or page
 1326                     of each field and its attributes using the M$DCLFLD monitor
 1327                     service.
 1328                     The attributes or data may later be modified using M$MDFFLD.
 1329                     The data in the field may be erased with M$ERASE, or the
 1330                     entire field declaration deleted using M$RLSFLD.
 1331                     M$WRITE allows the program to modify data in a field.
 1332                     M$SLCFLD is used to select which fields are to be modified,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            37   
 1333                     erased, released, read, or written; alternatively, a KEY
 1334                     specified on these operations can identify the field.
 1335                     An M$READ returns the data from an input field that is
 1336                     selected and has had data entered into it by the terminal
 1337                     operator.
 1338                     One M$READ is required for each field into which data
 1339                     has been entered.  F$DCB.EOMCHAR# and F$DCB.ACTPOS are
 1340                     returned only for the field in which the cursor was
 1341                     positioned when the activation character was entered.
 1342                     For other fields, F$DCB.EOMCHAR# is set to %EOM_EOR#.
 1343                     Even if a field is explicitly specified on the read,
 1344                     M$READs must be repeated until an end-of-file ALTRET
 1345                     occurs; this is necessary before other operations on
 1346                     the form are permitted.
 1347
 1348                     FPRG is legal for ASN=DEVICE and specifies
 1349                     FEP program access.  The user program reads and
 1350                     writes simple strings of data which are the outputs
 1351                     of and inputs to FEP programs which control the
 1352                     actual presentation of the data on the media.
 1353                     If VFC is specified on an M$WRITE, the first
 1354                     character of the buffer is discarded.  Any
 1355                     character in the data (including TAB) is sent
 1356                     unmodified to the FEP program.
 1357                     Appropriate forms programs may be invoked via the
 1358                     M$SETFP system service or via the
 1359                     FPRG variable on this FPT_OPEN.
 1360
 1361                     FREE specifies real free tape (i.e., not managed tape
 1362                     for which FIXED or VARIABLE must be
 1363                     specified).
 1364
 1365                     HANDLER specifies a
 1366                     real device handler and is legal for ASN=DEVICE
 1367                     only. RES must be either 'FEnn' specifying the
 1368                     handler be started on node nn, or RES is 'FE  '
 1369                     specifying the NODENAME at M$OPEN to identify
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            38   
 1370                     the node on which the handler will reside.
 1371                     FEP HANDLERS are described in the
 1372                     FEP Monitor Services Reference Manual.  The FEP
 1373                     HANDLER will continue to run even after this DCB
 1374                     is closed. Starting of FEP HANDLERS requires the
 1375                     MFEP privilege.
 1376                     (NAME specifies the name of this handler.)
 1377
 1378                     IDS is a special case of RANDOM which
 1379                     is formatted by the IDS processor.
 1380
 1381                     INDEXED is a special case of KEYED in
 1382                     which the key value is contained within
 1383                     the record data, is of fixed length, and
 1384                     may be as large as 255 characters.
 1385                     More than one index may be specified via
 1386                     the ALTKEYS option at M$OPEN.
 1387
 1388                     IREL (Indexed Relational) is an enhanced form of
 1389                     indexed files in which each key may be made up of
 1390                     more than one field in the record, and each key
 1391                     fragment may have a data type associated with it.
 1392                     See the IRKEYS option of M$OPEN and VLP_IRKEYS
 1393                     for a description of key definitions.
 1394
 1395                     KEYED  specifies that the location of
 1396                     each record in the file is determined by
 1397                     an explicit identifier (key) that may be
 1398                     used to access the record directly.  A key may
 1399                     consist of up to 255 characters.
 1400
 1401                     RANDOM specifies that the records in the
 1402                     file are a collection of 1024 word granules.
 1403                     The first word of each granule is used
 1404                     by file management to indicate whether or
 1405                     not the granule has been written.
 1406
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            39   
 1407                     RELATIVE specifies that the file space is preallocated
 1408                     for NRECS number of records, the
 1409                     records are of fixed length(RECL), and may be
 1410                     accessed sequentially or by specifying the relative
 1411                     record number within the file.
 1412
 1413                     RESTRICT is for internal system use only.
 1414
 1415                     SE specifies that a video display terminal is to be
 1416                     operated in a screen-editing mode.  ASN=DEVICE and
 1417                     RES=UCnn must be specified, and the UCnn must be used
 1418                     only in this DCB.  WINDOW may also be specified to
 1419                     locate a VLP_WINDOW area that describes the
 1420                     characteristics of the screen-editing window.  In
 1421                     addition, KEYL specifies the length of the fixed-length
 1422                     keys used to identify records displayed in the window.
 1423                     For information on scrolling and manipulating records
 1424                     on the screen, see "Screen Editing Access Method",
 1425                     Terminal Control section,
 1426                     ..::HL "in this manual."
 1427                     ..::HL "\in the Monitor Services Reference (CE74)."
 1428
 1429                     SYMB specifies a special type of UR file
 1430                     used by the operating system.  It is not
 1431                     useful for users.
 1432
 1433                     TERMINAL is legal only for ASN = DEVICE or COMGROUP
 1434                     and specifies terminal control type access.  The
 1435                     page control formatting available in ORG = UR is
 1436                     not available, although TAB and VFC (if appropriate)
 1437                     still apply.  Unlike ORG = UR, characters are sent
 1438                     untranslated to the media, and the TRANS option on
 1439                     M$WRITE controls whether the media handler is to
 1440                     do output manipulation (e.g., line-wrapping, VFC and
 1441                     control code interpretation, and CHARSETNAME translation).
 1442
 1443                     UR specifies a Unit Record formatted
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            40   
 1444                     file.  All options
 1445                     available for formatting unit record output devices
 1446                     (such as HDR, TAB, FORM, etc.) are available in
 1447                     UR files.  UR is the default organization for unit record
 1448                     devices.  Whenever an M$WRITE is done through a
 1449                     DCB with ORG = UR, the written data is translated
 1450                     into the 96 ASCII graphics and TAB with all
 1451                     characters outside this set translated to
 1452                     space.  This translation is inhibited by specifying
 1453                     TRANS = YES on the M$WRITE and this is the only
 1454                     effect of TRANS in this organization.
 1455
 1456                     VARIABLE specifies ANS tape format D for unspanned
 1457                     files, ANS tape format S for spanned files, and format
 1458                     V for EBCDIC files - variable length records. (See
 1459                     EBCDIC, CNVRT, BLOCKED, SPANNED.)
 1460
 1461                     X364 provides a subset of the functions defined by the
 1462                     ANSI X3.64-1979 standard, which describes the
 1463                     commands to be sent to a terminal for performing
 1464                     operations such as cursor positioning and erasure.
 1465                     X364 allows the user to write applications programs
 1466                     in a device-independent manner, as if for an
 1467                     X3.64-compatible terminal.  The CP-6 operating
 1468                     system then translates the commands into those
 1469                     understood by the user's terminal, which doesn't have
 1470                     to be X3.64 compatible.  Through CP-6's windowing
 1471                     capabilities, multiple X364 virtual devices may
 1472                     simultaneously be present, with some possibly
 1473                     connected to other host users or other CP-6 host
 1474                     computers.  X364 virtual devices may also be present
 1475                     with other types of virtual devices on the same
 1476                     screen.
 1477                     ..::HL "For information on the functions available"
 1478                     ..::HL "see the CP-6 Programmer Reference,"
 1479                     ..::HL "in the appendix, X3.64 Functions."
 1480                     .xeq
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            41   
 1481
 1482                     The default causes this parameter to be ignored.
 1483                      */
 1484
 1485              3 ACS# UBIN(9) %INIT(ACS)%CHARTEXT('/**/') UNAL,
 1486                          /*K* ACS = OPTION.
 1487                          All ACS options apply to disk
 1488                          files; only the SEQUEN and JRNL options
 1489                          apply to tape files.  The ACS parameter defines access
 1490                          characteristics for a file and restricts user access to
 1491                          the file only as specifically stated in the explanation
 1492                          of each option.
 1493
 1494                          .INL +10
 1495                          .UNL 10
 1496                          SEQUEN    When creating a keyed file
 1497                               the user must supply keys in ascending
 1498                               order.  A file created with this option
 1499                               can be read or written with or without
 1500                               a key.
 1501
 1502                          .UNL 10
 1503                          DIRECT    When creating or updating a keyed file,
 1504                               the user may supply keys in any order. A
 1505                               file created with this option can be read or
 1506                               written with or without a key.
 1507
 1508                          .UNL 10
 1509                          JRNL      Specifies journal access mode for a
 1510                               consecutive, named disk or tape file.  This
 1511                               mode is designed to permit one user (the
 1512                               journal owner) to control the file while
 1513                               any user may write to the file.  A user
 1514                               may become the journal owner by performing
 1515                               the first open of the file if neither the file
 1516                               nor the DCB specifies GHSTACS=JRNLOPN.  Otherwise,
 1517                               the first attempt to open the file waits for the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            42   
 1518                               system ghost to open it first, thereby becoming
 1519                               its owner.   In order to
 1520                               keep this file name continually available
 1521                               for output from users, the journal owner
 1522                               can periodically close and rename the
 1523                               journal file.  Thus, other users of the file
 1524                               can continue to send output to the file
 1525                               without being aware that a new physical
 1526                               file was substituted for the file just
 1527                               closed.  The file opened in journal mode
 1528                               is subject to these special rules:
 1529
 1530                               1.  The first user opening the file must
 1531                               specify FUN=CREATE whether the file exists
 1532                               or not and whether GHSTACS=JRNLOPN or not
 1533                               (otherwise an alternate return results).
 1534                               EXIST=OLDFILE must be used to extend an old
 1535                               file.  The owner keeps the journal available
 1536                               by keeping this DCB open (close with rename
 1537                               does not close a journal DCB).  (Any attempt
 1538                               to update the file after the owner has
 1539                               closed it results in an alternate return.)
 1540
 1541                               2.  Other users who access the file in
 1542                               journal mode must open the file with
 1543                               FUN=UPDATE or CREATE; FUN=IN causes an
 1544                               alternate return.  The only meaningful
 1545                               EXIST option is ERROR.
 1546
 1547                               3.  For the owner and any user of the
 1548                               file, the following rules apply at
 1549                               M$OPEN:
 1550
 1551                               o  DISP must be set to NAMED or must
 1552                                  not be specified at all.
 1553                               o  CTG = YES is assumed.
 1554                               o  ORG must be set to CONSEC.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            43   
 1555                               o  SHARE is ignored.
 1556                               o  NXTA, NXTF, THISF, DELETE must
 1557                                  not be specified.
 1558                               o  For a tape file opened in journal
 1559                                  mode, a file of the same name must
 1560                                  not concurrently exist on disk.
 1561                                  (When a tape journal file is opened
 1562                                  in journal mode, a dummy file of the
 1563                                  same name is opened on disk.)
 1564
 1565                          .UNL 10
 1566                          DS2 through DS8^^^^Specifies data-segment access
 1567                               for a random file.  This mode permits
 1568                               users to share the data of a random file
 1569                               directly in memory.  The size of the file(IXTNSIZE)
 1570                               must be between 2 and 257 granules,
 1571                               which requires between 1 and 256
 1572                               pages of memory to be available for the
 1573                               data-segment.  The first granule of the file
 1574                               is used to fill in the holes caused by the
 1575                               1-word granule headers.
 1576                          M$EXTEND may be used to enlarge the file and data segment
 1577                          simultaneously, or if SIZ=0, to enlarge the data segment
 1578                          to the current size of the file.  M$TRUNC may be used to
 1579                          cause the current state of the data segment to be saved
 1580                          in the file.
 1581                          If an attempt is made to create a 1-granule file in this
 1582                          mode, EXIST=ERROR is enforced and the data segment size
 1583                          is obtained from XTNSIZE instead of IXTNSIZE-1. Also in
 1584                          this case, the file cannot be cataloged (although the
 1585                          CTG option is honored and permits the file to be shared,
 1586                          and any access control specifications function normally).
 1587                          In addition, M$EXTEND is still used to enlarge the data
 1588                          segment, but M$TRUNC does nothing.
 1589
 1590                          .UNL 10
 1591                          BLOCK     Is for internal system use only.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            44   
 1592                          .xeq
 1593
 1594                          .UNL 10
 1595                          The default causes this parameter to be ignored.
 1596                                                                                  */
 1597
 1598              3 TYPE# CHAR(2) %INIT(TYPE)%CHARTEXT('/**/') UNAL,
 1599                          /*K* TYPE = VALUE-CHAR(2).
 1600                          Is the processor
 1601                          specified file type supplied for convenience and
 1602                          is not used by file management.  This 2-character
 1603                          field may be supplied by users or
 1604                          system processors when creating files.
 1605                          .xeq
 1606                          }
 1607                          }  1st Character:
 1608                          }     D = Data
 1609                          }     I = Database
 1610                          }     O = Object Unit
 1611                          }     R = Run Unit
 1612                          }     S = Source
 1613                          }     U = Update
 1614                          }     W = Workspace
 1615                          }     X = Work file
 1616                          }     Y = reserved
 1617                          }     1 = schema for databases
 1618                          }     2 = subschema for databases
 1619                     }     * = file reserved for system use:  can only be created by
 1620                     }         operating system; can be read or deleted by user.
 1621                     }     blank = undefined
 1622                     }  2nd character for processors:
 1623                     }     A = APL
 1624                     }     a = ARES
 1625                     }     B = BASIC
 1626                     }     C = COBOL
 1627                     }     D = TP (TRADER)
 1628                     }     E = EDIT
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            45   
 1629                     }     F = FORTRAN
 1630                     }     f = FPL
 1631                     }     G = GMAP
 1632                     }     I = IDS
 1633                     }     J = IMP
 1634                     }     K = PASCAL
 1635                     }     L = CALF
 1636                     }     M = ELSIE
 1637                     }     P = Performance Monitor or PARTRGE
 1638                     }     Q = IDP
 1639                     }     R = RPG
 1640                     }     S = SORT
 1641                     }     T = TEXT
 1642                     }     1 = reserved
 1643                     }     6 = PL-6
 1644                     }  2nd character for data:
 1645                     }     A = ASCII
 1646                     }     B = ASCII and single precision
 1647                     }     D = Double precision
 1648                     }     S = Single precision
 1649                     }     a = APL data block attributes
 1650                     }     c = APL component file
 1651                     }     d = display definitions (X$FORMAT commands)
 1652                     }     g = graphics (a CP-6 DIGIS file)
 1653                     }     blank = undefined or unformatted
 1654
 1655                     The default causes this parameter to be ignored.
 1656                     */
 1657
 1658              3 COMP# BIT(2) UNAL %INIT(COMP)%CHARTEXT('/**/'),
 1659                          /*K* COMP = {YES|NO}.
 1660                          YES specifies that the file
 1661                          is to have the attribute "compressed".  All
 1662                          records written into a file will be compressed.
 1663                          The records will be restored when read.
 1664                          Compression reduces file size to approximately 60
 1665                          percent of the space it would occupy if uncompressed
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            46   
 1666                          and increases user service time required to
 1667                          access the file by approximately two and one half
 1668                          times.
 1669                          COMP is applicable only to CREATE
 1670                          opens of consecutive and keyed disk files.
 1671                          Encryption cannot be used on compressed files.
 1672                          .xeq
 1673
 1674                          The default causes this parameter to be ignored.
 1675                                                                                  */
 1676
 1677              3 BLOCKED# BIT(2) UNAL %INIT(BLOCKED)%CHARTEXT('/**/'),
 1678                          /*K* BLOCKED = {YES|NO}.
 1679                          YES specifies that logical
 1680                          records and record segments are to be packed into
 1681                          physical tape records.  NO results in, at most, one
 1682                          record or record segment per tape record. BLOCKED
 1683                          applies only to FIXED and VARIABLE labeled and
 1684                          managed tape files.  BLOCKED is determined for IN
 1685                          or UPDATE opens from the labeled tape file opened.
 1686                          Blocked and unblocked files may be
 1687                          freely intermixed on a volume. BLOCKED should be
 1688                          used in conjunction with SPANNED for optimum
 1689                          tape record utilization. (BLOCKED must be
 1690                          specified for INPUT or UPDATE managed tape files.)
 1691                          CP-6 format tape files are always blocked.
 1692                          .xeq
 1693
 1694                          The default causes this parameter to be ignored.
 1695                                                                             */
 1696
 1697              3 SPANNED# BIT(2) UNAL %INIT(SPANNED)%CHARTEXT('/**/'),
 1698                          /*K* SPANNED = {YES|NO}.
 1699                          YES specifies whether
 1700                          logical records may be divided between physical
 1701                          tape records.  Spanned records may exceed the record
 1702                          limit imposed by RECL since RECL applies to
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            47   
 1703                          record segment size.
 1704                          SPANNED applies only to VARIABLE labeled and
 1705                          managed tape files.
 1706                          SPANNED is determined for IN or UPDATE opens from
 1707                          the tape file opened.  Spanned and unspanned files
 1708                          may be freely intermixed on a volume. SPANNED should
 1709                          be used in conjunction with BLOCKED for optimum
 1710                          tape record utilization.  (SPANNED must be
 1711                          specified for INPUT or UPDATE managed tape files.)
 1712
 1713                          .xeq
 1714                          CP-6 format tape files are always spanned.
 1715
 1716                          The default causes this parameter to be ignored.
 1717
 1718                                                                             */
 1719
 1720              3 BUPM# BIT(2) %INIT(BUPM)%CHARTEXT('/**/'),
 1721                          /*K* BUPM = {YES|NO}.
 1722                          YES specifies that file is
 1723                          to be backed up if modified.
 1724                          The default causes this parameter to be ignored.
 1725                                                                                  */
 1726              3 LOAD# BIT(2) %INIT(LOAD)%CHARTEXT('/**/'),
 1727                          /*K* LOAD = {YES|NO}.
 1728                          is meaningful only for
 1729                          files with alternate indices.  If LOAD=NO,
 1730                          then all alternate indices, along with the
 1731                          primary index are updated every time a record
 1732                          is written.
 1733
 1734                          If "LOAD=YES", then only the primary index,
 1735                          and any index that is specified as being
 1736                          "UNIQUE" is updated when a record is written.
 1737                          Unless the user specifies otherwise, the
 1738                          alternate indices are updated when the file
 1739                          is closed.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            48   
 1740                          .xeq
 1741                          The default causes this parameter to be ignored.
 1742                                                                                  */
 1743              3 LSTAOR# BIT(2) %INIT(LSTAOR)%CHARTEXT('/**/'),
 1744                          /*K* LSTAOR = {YES|NO}.
 1745                          Specifies, for comgroups
 1746                          only, when the VLP_STATION pointed to by
 1747                          F$DCB.LASTSTA$ is to be updated.  If YES, it is
 1748                          updated only on reads.  If NO, it is updated
 1749                          on both reads and writes.
 1750                          .xeq
 1751                          The default causes this parameter to be ignored.
 1752                          */
 1753              3 JRNLBYPASS# BIT(2) %INIT(JRNLBYPASS)%CHARTEXT('/**/'),
 1754                          /*K* JRNLBYPASS = {YES|NO}.
 1755                          YES specifies that for opens
 1756                               of comgroups that have the journaling attribute,
 1757                               journaling is not to be done for this open.  AU=YES
 1758                               must also be specified.
 1759                               The default is NO.
 1760                               .xeq
 1761                                                                                  */
 1762              3 GHSTACS# UBIN(4) %INIT(GHSTACS)%CHARTEXT('/**/') UNAL,
 1763                          /*K* GHSTACS = VALUE-DEC(0-15).
 1764                          Specifies a function code
 1765                               to be passed to the system access ghost prior to opening
 1766                               the DCB to a disk file.  The only currently implemented
 1767                               code is JRNLOPN, which asks the ghost to open a journal,
 1768                               either as the owner of this journal (see F$DCB.ACS#) or
 1769                               to journal this comgroup (see FPT_CGCTL.JRNLSTA).
 1770                               The value NONE may be used to reset to zero a previous
 1771                               non-zero value (either in the DCB for M$OPEN, or in the
 1772                               file for M$CLOSE).
 1773                               .xeq
 1774                               The default causes this parameter to be ignored.
 1775                                                                                  */
 1776              3 RES# CHAR(4) %INIT(RES)%CHARTEXT('/**/') UNAL,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            49   
 1777                          /*K* RES = VALUE-CHAR(4).
 1778                          Specifies a device designation ('dvnn'
 1779                          or 'dv').  dv is the 2-character device mnemonic or
 1780                          special name (e.g., MT for tape, special name ME).
 1781                          nn is a 2-digit number identifying a device allocated
 1782                          via the RESOURCE command, a reserved logical device
 1783                          name (such as LP01 or CP01), or a logical device name
 1784                          defined via the LDEV command or M$LDEV service.
 1785                          When ASN=DEVICE, RES is either: a) a user-defined
 1786                          logical device name (LDEV); b) the name of an
 1787                          installation-defined device at a workstation (see the
 1788                          WSN parameter); or c) one of the following special
 1789                          names or device types:
 1790
 1791                            .FIF
 1792                                C1             JE             NC
 1793                                CL[nn]         JF             NO
 1794                                CP[nn]         L1             OD[nn]
 1795                                CR[nn]         LO             P1
 1796                                DP[nn]         LP[nn]         PO
 1797                                FE[nn]         LT[nn]         SI
 1798                                FT[nn]         ME             UC[nn]
 1799                                GR             MT[nn]
 1800
 1801                            .FIN
 1802                            CP[nn], CR[nn], GR, JE, JF, LO, LP[nn], ME, NO,
 1803                            and UC[nn] are Unit Record Special Names.
 1804                            See the Files, Devices, and Comgroups section in
 1805                            the CP-6 Programmer Reference Manual for detailed
 1806                            information on these resource types.
 1807
 1808                            CP[nn], FT[nn], LP[nn], LT[nn],
 1809                            and MT[nn] are discussed in the CP-6 Programmer
 1810                            Reference, Section 3, RESOURCELIST Component and
 1811                            RESOURCE Command.
 1812                            .spf
 1813                            Note:  LT in a fid is ASN=TAPE as describe in
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            50   
 1814                            the CP-6 Programmer Reference, Section 2,  "Tape
 1815                            Fids", for free tape.  When ASN=DEVICE,
 1816                            both MT[nn] and LT[nn] are equivalent to FT[nn].
 1817
 1818                            C1, L1, P1, PO, and SI may be specified only if
 1819                            ASN=DEVICE.  C1 and SI are equivalent to CR; L1 is
 1820                            equivalent to LP; P1 and PO are equivalent to CP.
 1821
 1822                            CL[nn] specifies an installation-defined communications
 1823                            resource.
 1824
 1825                            DP[nn] specifies privileged access to disk devices or
 1826                            packsets.  FMDIAG privilege is usually required.
 1827
 1828                            FE[nn] specifies the starting of a FEP handler if ORG
 1829                            is HANDLER, or debugger access to a FEP-user if ORG is
 1830                            DBGCG, DBGDCB, or DBGSYSID.  FUN must be CREATE.
 1831
 1832                            NC specifies a network communication connection accessing
 1833                       the session-transport interface of the ISO 7-layer model.
 1834
 1835                       OD[nn] specifies access to controlling functions for an
 1836                       optical-disk subsystem.
 1837
 1838                       When ASN=FILE, RES is only significant if the packset
 1839                       is being accessed exclusively, in which case RES=DPnn may
 1840                       be used to specify a particular resource allocated via the
 1841                       RESOURCE command.
 1842
 1843                       When ASN=COMGROUP, RES is ignored.
 1844
 1845                       When ASN=TAPE, RES is used to identify a particular
 1846                       resource as described for ASN=FILE.
 1847
 1848                       .xeq
 1849                       For the default, see M$OPEN, the DCB parameter.
 1850                                                                */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            51   
 1851              3 KEYX# UBIN(18) %INIT(KEYX)%CHARTEXT('/**/') UNAL,
 1852                          /*K* KEYX = VALUE-DEC(0-32K).
 1853                          For ORG=INDEXED, position of the primary
 1854                          key in the record (byte offset, starting at 0).
 1855                          KEYX is only meaningful on a create open.
 1856                          .xeq
 1857                          The default is 0.
 1858                                                                                  */
 1859              3 KEYL# UBIN(9) %INIT(KEYL)%CHARTEXT('/**/') UNAL,
 1860                          /*K* KEYL = VALUE-DEC(1-255).
 1861                          For ORG=INDEXED, the length in bytes of the
 1862                          primary key in the record.  KEYL is only
 1863                          meaningful on a create open.
 1864
 1865                          For ORG=SE, KEYL specifies the length, 1 to 4
 1866                          8-bit bytes, of the key that identifies records
 1867                          within the editing window.
 1868                          .xeq
 1869
 1870                          If the default is taken or an invalid value is
 1871                          specified, KEYL is assumed to be 1 for ORG=INDEXED
 1872                          and 4 for ORG=SE.
 1873                          Otherwise, the default causes this parameter to
 1874                          be ignored.
 1875                                                                                  */
 1876              3 DISP# UBIN(9) %INIT(DISP)%CHARTEXT('/**/') UNAL,
 1877                          /*K* DISP = OPTION.
 1878                          Is meaningful for disk files for FUN=CREATE
 1879                          opens only.
 1880                          When a new file is created, it is either
 1881                          allowed to be cataloged as a named file
 1882                          or never allowed to be cataloged and is
 1883                          classified as a scratch file.  The options are
 1884                          as follows:
 1885
 1886                          NAMED - Specifies that when the new file
 1887                          is created it has been given a name that will
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            52   
 1888                          allow it to be cataloged as a named file.
 1889
 1890                          SCRATCH - Specifies that the new file is a
 1891                          scratch file.  It will not have a name, will not
 1892                          have a specifiable account, can never be cataloged
 1893                          (regardless of the CTG option), and will go away
 1894                          when closed.  Scratch files are all allocated from
 1895                          space on DP#SYS and limited by the user TDISK limit.
 1896
 1897                          .xeq
 1898                          The default causes this parameter to be ignored.
 1899                                                                             */
 1900
 1901              3 BLKL# UBIN(18) %INIT(BLKL)%CHARTEXT('/**/') UNAL,
 1902                          /*K* BLKL = VALUE-DEC(1-32764).
 1903                          Specifies the maximum
 1904                          physical tape record size (in bytes) that will be
 1905                          read from or written to a labeled tape.
 1906                          For CREATE opens BLKL will be rounded up to a multiple
 1907                          of 4 (ANS formats) or 8 (CP-6 ORGs).
 1908                          For IN or UPDATE opens BLKL is determined from the
 1909                          file opened except for managed tape files for
 1910                          which BLKL must be specified.
 1911                          .xeq
 1912
 1913                          The default causes this parameter to be ignored.
 1914                                                                             */
 1915
 1916              3 RECL# UBIN(18) %INIT(RECL)%CHARTEXT('/**/') UNAL,
 1917                          /*K* RECL = VALUE-DEC(1-262142).
 1918                          For fixed record length formats such as RELATIVE and
 1919                          FIXED, RECL is the maximum data record length in bytes.
 1920                          For VARIABLE formats, RECL is the maximum record segment
 1921                          length in bytes.  For unspanned files, at most one
 1922                          record segment is used per record, thus limiting each
 1923                          record to RECL bytes which includes 4 bytes
 1924                          of record information.  For spanned files, RECL is
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            53   
 1925                          the maximum length of the data record not
 1926                          including record information bytes.  RECL may be
 1927                          zero for spanned files indicating that there is no
 1928                          maximum.
 1929
 1930                          RECL is determined for IN or UPDATE opens from
 1931                          the file opened except for managed tape files for
 1932                          which RECL must be specified.
 1933                          .xeq
 1934
 1935                          The default causes this parameter to be ignored.
 1936                                                                                  */
 1937
 1938              3 LSLIDE# UBIN(18) %INIT(LSLIDE)%CHARTEXT('/**/') UNAL,
 1939                          /*K* LSLIDE  = VALUE-DEC(1-511).
 1940                          Specifies the number of
 1941                          blocks that can be added to the KEYED, INDEXED, or
 1942                          IREL disk file's level 0 index
 1943                          since the current higher-level index structure was
 1944                          created. If the specified value is exceeded, the
 1945                          higher-level index structure will be rebuilt when
 1946                          the file is closed.  If a value of 511 is
 1947                          specified, the higher-level index structure will
 1948                          never be rebuilt for this reason.
 1949                          .xeq
 1950                          The default causes this parameter to be ignored.
 1951                                                                                  */
 1952
 1953              3 LRDL0# UBIN(18) %INIT(LRDL0)%CHARTEXT('/**/') UNAL,
 1954                          /*K* LRDL0 = VALUE-DEC(1-511).
 1955                          Specifies the number of
 1956                          contiguous blocks that can be added to the
 1957                          KEYED, INDEXED, or IREL disk file's
 1958                          level 0 index since the current higher-level index
 1959                          structure was created.  If the specified number is
 1960                          exceeded, the higher-level index structure will be
 1961                          rebuilt when the file is closed.  A value of 511
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            54   
 1962                          specifies that the upper level will never be
 1963                          rebuilt for this reason.
 1964                          .xeq
 1965                          The default causes this parameter to be ignored.
 1966                                                                                  */
 1967
 1968              3 SPARE# UBIN(18) %INIT(SPARE)%CHARTEXT('/**/') UNAL,
 1969                          /*K* SPARE = VALUE-DEC(1-511).
 1970                          Meaningful for KEYED, INDEXED, IREL or SE
 1971                          organization.  For a KEYED, INDEXED, or IREL disk
 1972                          file, SPARE specifies in words the amount of spare
 1973                          space to be left unused at the end of each index
 1974                          block while the file is being created
 1975                          or updated with sequential access.  The
 1976                          value specified may not exceed 511 words. If it
 1977                          does, it is treated modulo 512.
 1978                          This spare space is reserved so that
 1979                          additional keys can be inserted in a minimum time
 1980                          when updating the file with direct access (as in
 1981                          EDIT).  If the file will never be updated with
 1982                          direct access, a spare value of 1 should be specified.
 1983
 1984                          For SE access method, SPARE specifies how many
 1985                          joins to allow (deleted records) before the FEP
 1986                          asks for more records to fill the cache.  If
 1987                          SPARE is greater than 99, Read-Only mode is
 1988                          assumed.
 1989
 1990                          .xeq
 1991                          The default causes this parameter to be ignored.
 1992                                                                                  */
 1993
 1994              3 XTNSIZE# UBIN(18) %INIT(XTNSIZE)%CHARTEXT('/**/') UNAL,
 1995                          /*K* XTNSIZE = VALUE-DEC(1-2**17)
 1996                          For FUN=CREATE disk files, size in granules of
 1997                          the secondary extents (used to add on extents).
 1998                          Not applicable to RELATIVE, RANDOM or IDS organizations.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            55   
 1999                          .xeq
 2000                          The default causes this parameter to be ignored.
 2001                                                                                  */
 2002
 2003              3 IXTNSIZE# SBIN %INIT(IXTNSIZE)%CHARTEXT('/**/') ,
 2004                          /*K* IXTNSIZE = VALUE-DEC(1- ? )
 2005                          For FUN=CREATE disk files or comgroups, size in granules
 2006                          of the initial extent.  Not applicable to RELATIVE files.
 2007                          .xeq
 2008                          The default is 0.
 2009                                                                                  */
 2010              3 NRECS# SBIN %INIT(NRECS)%CHARTEXT('/**/'),
 2011                          /*K* NRECS = VALUE-DEC(1- ?).
 2012                          NRECS is valid if ORG=RELATIVE or ORG=SE.
 2013                          For FUN=CREATE of a relative disk file,
 2014                          NRECS specifies the number of records in the file.
 2015                          For Screen Editing access method, NRECS specifies
 2016                          the number of records in the FEP cache.
 2017                          .xeq
 2018                          The default is 0.
 2019                                                                                  */
 2020              3 EXPIRE# SBIN %INIT(EXPIRE)%CHARTEXT('/**/'),
 2021                          /*K* EXPIRE = {ddd|NEVER}.
 2022                          Specifies the number
 2023                          of days to retain the file (ddd) or that the file
 2024                          is never to expire(NEVER).
 2025                          Files may be
 2026                          automatically purged from the public disk file system
 2027                          if they have expired whenever secondary storage
 2028                          space passes below an installation established threshold.
 2029                          The value specified may not exceed the maximum
 2030                          expiration period authorized for the user.  If the
 2031                          maximum expiration period is exceeded or
 2032                          unspecified, the default expiration period
 2033                          authorized for that user will be used.
 2034
 2035                          For labeled tape volumes in protected systems EXPIRE
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            56   
 2036                          specifies the number of days to protect the volume
 2037                          against content changing operations (UPDATE or
 2038                          CREATE).  In semi-protected systems, unexpired
 2039                          volumes require an OVER keyin to UPDATE or CREATE
 2040                          open.  EXPIRE has no effect in unprotected systems.
 2041                          The expiration date of the entire volume set is
 2042                          that of the first file of the volume set.
 2043
 2044                          If EXPIRE is not specified, the default value, as
 2045                          established in the authorization record for the
 2046                          user, determines the expiration date.
 2047                          .xeq
 2048
 2049                          The default causes the parameter to be ignored.
 2050                                                                                  */
 2051              3 EBCDIC# BIT(2) %INIT(EBCDIC)%CHARTEXT('/**/') UNAL,
 2052                          /*K* EBCDIC = {YES|NO}.
 2053                          YES specifies that tape file labels
 2054                          (including user labels) are to be translated from
 2055                          EBCDIC to ASCII on input and from ASCII to EBCDIC
 2056                          on output.  Data is subject to translation (see
 2057                          M$DCB, CNVRT#).  For IN or UPDATE, F$DCB.EBCDIC# is
 2058                          determined from the current volume.  For CREATE
 2059                          it must be the same as for the current volume
 2060                          unless the current volume is the first volume
 2061                          of the volume set and is positioned to the beginning
 2062                          of the volume.  EBCDIC files cannot be created on
 2063                          ASCII volumes and vice versa.  EBCDIC applies only
 2064                          to VARIABLE and FIXED files on labeled and
 2065                          managed tape and to free tape.   EBCDIC must be
 2066                          specified on output and input for free and managed
 2067                          tape files.
 2068                          .xeq
 2069
 2070                          The default causes this parameter to be ignored.
 2071                                                                             */
 2072
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            57   
 2073              3 CNVRT# BIT(2) %INIT(CNVRT)%CHARTEXT('/**/') UNAL,
 2074                          /*K* CNVRT = {YES|NO}.
 2075                          YES specifies that for EBCDIC
 2076                          tape files (as determined by tape labels on input
 2077                          and F$DCB.EBCDIC# on output) data is to be translated
 2078                          from EBCDIC to ASCII after reading or ASCII to EBCDIC
 2079                          before writing.  Translation is done while data is
 2080                          being moved between user and monitor buffer for all
 2081                          file formats.
 2082                          CNVRT applies only to FIXED and VARIABLE
 2083                          formats.  For non-binary writes to free
 2084                     tape if CNVRT is set and EBCDIC is not, the user's buffer is
 2085                     converted to assure that no high order bits are set
 2086                     (which will cause an I/O error).  If both CNVRT and EBCDIC
 2087                     are set for device tapes, normal translation takes place.
 2088                     .xeq
 2089
 2090                     The default causes this parameter to be ignored.
 2091                     */
 2092
 2093              3 XTEND# BIT(2) %INIT(XTEND)%CHARTEXT('/**/') UNAL,
 2094                          /*K* XTEND = {YES|NO}.
 2095                          For CREATE opens of labeled
 2096                          tape files YES causes the volume set to be positioned
 2097                          after the last file if VOL = 0.  If VOL is
 2098                          non-zero, the volume selected is positioned after
 2099                          its last file.  XTEND = NO causes the next file to
 2100                          be created at current volume position.
 2101                          .xeq
 2102                          The default causes this parameter to be ignored.
 2103                                                                                  */
 2104
 2105              3 XONLY# BIT(1) %INIT(XONLY)%CHARTEXT('/**/'),
 2106                          /*K* XONLY = {YES|NO}.
 2107                          Specifies that F$DCB.FFLG.EXEC# is
 2108                          to be set unconditionally once the DCB is open.  This will
 2109                          prevent another program (associated in a different domain)
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            58   
 2110                          from using or closing the DCB.
 2111                          The default is NO.
 2112                                                                                  */
 2113              3 IOERROK# BIT(2) UNAL %INIT(IOERROK)%CHARTEXT('/**/'),
 2114                          /*K* IOERROK = {YES|NO}.
 2115                          Is meaningful only for tape files.  If IOERROK=NO,
 2116                          tape I/O errors cause the tape position to be lost, and
 2117                          no further operations are allowed except rewind or
 2118                          dismount.  (The user may then reissue the failed read,
 2119                          write or position operation with IOERROK set in the
 2120                          FPT.)
 2121
 2122                          If IOERROK=YES, tape file management will try to
 2123                          recover from I/O errors as completely as possible.  The
 2124                          action taken depends on the operation in progress at the
 2125                          time of the error.  In particular, no errors will be
 2126                          returned during the processing of an I/O error.  Various
 2127                          bits in the TYC will, however, be set to indicate the I/O
 2128                     error itself, as well as data inconsistencies or lost data.
 2129                     For more information, see the description of IOERROK for
 2130                     M$READ, M$WRITE and M$PRECORD.  Also see the description
 2131                     of the DCB field BADARS#.
 2132
 2133                     .xeq
 2134                     The default causes this parameter to be ignored.
 2135                                               */
 2136              3 * UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
 2137              3 DCBCONLGL# BIT(1) UNAL %INIT(DCBCONLGL)%CHARTEXT('/**/'),
 2138                          /*K* DCBCONLGL = {YES|NO} is meaningful only if
 2139                          ORG = CG.  Specifies whether DCBs are allowed to
 2140                          open to this comgroup.  The default is YES.  See
 2141                          VLP_CGCP for additional information.                    */
 2142              3 TERMCONLGL# BIT(1) UNAL %INIT(TERMCONLGL)%CHARTEXT('/**/'),
 2143                          /*K* TERMCONLGL = {YES|NO} is meaningful only if
 2144                          ORG = CG.   Specifies whether terminals are allowed
 2145                          to open to this comgroup.  The default causes this
 2146                          parameter to be ignored.  See
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            59   
 2147                          VLP_CGCP for additional information.                    */
 2148              3 OVERFDE# BIT(1) UNAL %INIT(OVERFDE)%CHARTEXT('/**/'),
 2149                          /*K* OVERFDE = {YES|NO}  YES means that EFT should be
 2150                          allowed to make a new file over the current file
 2151                          directory entry.  NO means that EFT should not be
 2152                          permitted to make a new file over a current file
 2153                          directory entry.  The default is NO.                    */
 2154
 2155              3 IGNOREFSN# BIT(2) UNAL %INIT(IGNOREFSN)%CHARTEXT('/**/'),
 2156                          /*K* IGNOREFSN = {YES|NO}.
 2157                          is meaningful only for labelled tape files.  If
 2158                     IGNOREFSN=NO, each tape file is located by the file sequence
 2159                     number in its HDR1 label before it is opened.  If such a
 2160                     file sequence number
 2161                     is not correct, the file may not be found.  In addition,
 2162                     when IGNOREFSN=NO, the first file section of each tape file
 2163                     is required, and, if it is not present, the open will
 2164                     fail.
 2165
 2166                     If IGNOREFSN=YES, tape file management will not check the
 2167                     file sequence number of a tape file when it is being
 2168                     opened.  In addition, if the first file section does
 2169                     not exist, the first file section found (which may or may
 2170                     not be the earliest file section of the file) is used.  With
 2171                     this
 2172                     capability, a user may successfully read all the files on
 2173                     many types of malformed or partial tape sets.
 2174
 2175                     IGNOREFSN=YES causes file sequence numbers to be ignored
 2176                     only when used in combination with NXTF,
 2177                     or when opening a tape file by name.  If IGNOREFSN=YES
 2178                     when opening a tape file by file sequence number, only
 2179                     the file section is ignored.  If IGNOREFSN=YES when opening
 2180                     a tape file by name, the search will stop at
 2181                     the end of the tape (set).
 2182
 2183                     Note that if a non-first file section is used and bad
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            60   
 2184                     spanning information is present (due to a record being
 2185                     spanned from a previous section which is not present or was
 2186                     not found),
 2187                     TYC.DI will be set in the DCB.  No error message will be
 2188                     generated, and the partial record will be processed as if
 2189                     it were the first record in the file.
 2190                     .xeq
 2191                     The default causes this parameter to be ignored.
 2192                                               */
 2193              3 SEEDSPECIFIED# BIT(1) UNAL %INIT(SEEDSPECIFIED)%CHARTEXT('/**/'),
 2194                          /*K* SEEDSPECIFIED = {YES|NO}  YES means that SEED
 2195                          was specified in this FPT_OPEN, and should replace
 2196                          the encryption seed in the DCB.  Note that this is
 2197                          the only way to set an encryption seed on an open.
 2198                          The default is NO.
 2199                                                                                  */
 2200              3 ANSISPANSEQ# BIT(2) UNAL %INIT(ANSISPANSEQ)%CHARTEXT('/**/'),
 2201                          /*K* ANSISPANSEQ = {YES|NO}
 2202                          ANSISPANSEQ=YES indicates
 2203                          that ANSI spanning should be expected for tape files.
 2204                          ANSISPANSEQ=NO indicates that IBM spanning information
 2205                          should be expected.  Meaningful only for tape files.
 2206                          .xeq
 2207                          The default causes this parameter to be ignored.
 2208                                                                                  */
 2209              3 * UBIN(10) UNAL %INIT(0)%CHARTEXT('/**/'),
 2210
 2211              3 VOL# UBIN(9) %INIT(VOL)%CHARTEXT('/**/') UNAL,
 2212                          /*K* VOL = VALUE-DEC(1-511).
 2213                          On open, VOL specifies
 2214                          which volume of the volume set (as specified by
 2215                          the serial number list) is to be initially mounted.
 2216                          A value of 0 or 1 indicates the first volume, 2 the
 2217                          second, etc.  VOL is used in conjunction with XTEND
 2218                          to determine which volume of the volume set to extend.
 2219                          VOL indicates which volume is currently mounted if
 2220                          the DCB is open.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            61   
 2221                          .xeq
 2222                          The default causes this parameter to be ignored.
 2223                                                                                  */
 2224              3 MAXVOL# UBIN(9) %INIT(MAXVOL)%CHARTEXT('/**/') UNAL,
 2225                          /*K* MAXVOL = VALUE-DEC(1-511).
 2226                          Specifies the number
 2227                          of extra tape volumes which will be requested as
 2228                          scratch tapes after the volumes in the serial number
 2229                          list are used up.
 2230                          .xeq
 2231                          The default causes this parameter to be ignored.
 2232                                                                                  */
 2233              3 CHAIN# UBIN(9) %INIT(CHAIN)%CHARTEXT('/**/') UNAL,
 2234
 2235              3 KEYTYPE# UBIN(9) UNAL %INIT(KEYTYPE)%CHARTEXT('/**/'),
 2236                     /*K* KEYTYPE = {FLDID | COORD | NONE}.  This field specifies
 2237                     the default key type for reads and writes to a form device.
 2238                          The default is NONE.
 2239                                                                                  */
 2240              3 ATTR# BIT(18) UNAL %INIT(ATTR)%CHARTEXT('/**/'),
 2241                          /*K* ATTR = VALUE-BIT(18).
 2242                          Specifies the attribute(s) desired for an open with
 2243                          RES='CL'.  Values should be chosen from EQUs in
 2244                          CP_6_SUBS whose names begin with 'ATTR_CL_'.
 2245                          .xeq
 2246                          The default causes this parameter to be ignored.
 2247                          */
 2248              3 DVFC# CHAR(1) UNAL %INIT(DVFC)%CHARTEXT('/**/'),
 2249                          /*K* DVFC = VALUE-CHAR(1).
 2250                          Specifies the default format
 2251                          control character for records which have no
 2252                          format control specified on the M$WRITE
 2253                          request.
 2254                          .xeq
 2255
 2256                          The default causes this parameter to be ignored.
 2257                                                                                  */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            62   
 2258              3 * UBIN (9) UNAL %INIT(0)%CHARTEXT('/**/'),
 2259              3 SEQCOL# UBIN(9) UNAL %INIT(SEQCOL)%CHARTEXT('/**/'),
 2260                          /*K* SEQCOL = VALUE-DEC(1-255).  Specifies the column
 2261                          number in which sequencing is to be performed.  The
 2262                          sequence ID is printed followed by the record
 2263                          sequence number.  Sequencing is controlled by the
 2264                          SEQ = YES parameter.
 2265                          .xeq
 2266                          The default causes this parameter to be ignored.
 2267                          */
 2268
 2269              3 SEQ# BIT(2) UNAL %INIT(SEQ)%CHARTEXT('/**/'),
 2270                          /*K* SEQ = {YES|NO}.
 2271                          YES specifies that sequencing is
 2272                          to occur on each output record.
 2273                          .xeq
 2274                          The default causes this parameter to be ignored.
 2275                                                                                  */
 2276              3 AU# BIT(2) %INIT(AU)%CHARTEXT('/**/'),
 2277                          /*K* AU = {YES|NO}.
 2278                          is meaningful only for a
 2279                          COMGROUP and indicates that the user is to
 2280                          be the administrative user.
 2281                          .xeq
 2282                          The default causes this parameter to be ignored.
 2283                                                                                  */
 2284              3 QISS# BIT(2) %INIT(QISS)%CHARTEXT('/**/'),
 2285                          /*K* QISS = {YES|NO}.
 2286                          is meaningful only for
 2287                          CREATE opens of comgroups.  YES specifies that
 2288                          the station tree is to be the queue tree.
 2289                          NO specifies that the message type tree is to
 2290                          be the queue tree.
 2291                          .xeq
 2292                          The default causes this parameter to be ignored.
 2293                                                                                  */
 2294              3 VOLACCESS# UBIN(3) UNAL %INIT(VOLACCESS)%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            63   
 2295                          /*K* VOLACCESS = OPTION.
 2296                          Indicates labeled tape volume
 2297                          set access limitations.
 2298
 2299                          NONE specifies that only the owner of the
 2300                          volume set (account of user creating first
 2301                          file on the volume set) will be allowed
 2302                          access to this volume set.
 2303
 2304                          IN specifies that all may read the volume
 2305                          set but only the owner may write on it.
 2306
 2307                          ALL specifies that all may read or write
 2308                          the volume set.
 2309                          .xeq
 2310
 2311                          The default causes this parameter to be ignored.
 2312                                                                                  */
 2313              3 LINES# UBIN(18) UNAL %INIT(LINES)%CHARTEXT('/**/'),
 2314                          /*K* LINES = VALUE-DEC(1-32K).
 2315                          Specifies the number of
 2316                          printable lines per page.
 2317                          .xeq
 2318                          The default causes this parameter to be ignored.
 2319                                                                                  */
 2320
 2321              3 SEQID# CHAR(4) UNAL %INIT(SEQID)%CHARTEXT('/**/'),
 2322                          /*K* SEQID = VALUE-CHAR(4).
 2323                          Specifies a 4 character
 2324                          sequence identification which is to be appended to each
 2325                          output record when record sequencing has been
 2326                          requested.
 2327                          .xeq
 2328                          The default causes this parameter to be ignored.
 2329                          */
 2330
 2331              3 EVENT# SBIN UNAL %INIT(EVENT)%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            64   
 2332                          /*K* EVENT = VALUE-DEC(1-?).
 2333                          Specifies an event number to be returned to the
 2334                          user of this ASN=DEVICE DCB when B$COMIO events or
 2335                          B$FPRG events are returned to the user.  Zero
 2336                          indicates not to return these events.
 2337                          The default causes this parameter to be ignored.
 2338                                                                                  */
 2339
 2340              3 FSN# UBIN(18) UNAL %INIT(FSN)%CHARTEXT('/**/'),
 2341                          /*K* FSN = VALUE-DEC(1-9999).
 2342                          File sequence number
 2343                          for labeled tape indicates the position of the
 2344                          tape file relative to the beginning of the set with
 2345                          first file of volume set numbered 1.  For IN or UPDATE
 2346                          opens, FSN indicates the number of the desired file
 2347                          if no name is specified and the number of the file
 2348                          at which to begin searching for the named file if a name
 2349                          is specified.  FSN is supplied for CREATE opens.
 2350                          .xeq
 2351                          The default causes this parameter to be ignored.
 2352                                                                                  */
 2353              3 DBGDCBNO# REDEF FSN# UBIN(18) UNAL,
 2354              3 DBGSYSID# REDEF FSN# UBIN(18) UNAL,
 2355              3 COPIES# UBIN (9) UNAL %INIT(COPIES)%CHARTEXT('/**/'),
 2356                          /*K* COPIES = VALUE-DEC(1-511).  Specifies the
 2357                          number of copies of this file to be printed.  COPIES
 2358                     is only meaningful for devices and unit-record files.  This
 2359                     field is copied into the CODE16.COPIES field in the FIT of
 2360                     the opened file.  For devices, this is superseded by the
 2361                     COPIES option of M$LDEV.
 2362
 2363                     The default is zero, which causes this parameter to be
 2364                     ignored.  Note that at least one copy will always be
 2365                     printed, unless COPIES is greater than 1.  Also
 2366                     note that COPIES cannot be changed for an existing
 2367                     unit-record file.
 2368                     */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            65   
 2369              3 DENSITY# UBIN(9) UNAL %INIT(DENSITY)%CHARTEXT('/**/'),
 2370                          /*K* DENSITY = OPTION.
 2371                          Options are D800, D1600, D6250, and D38000.
 2372                          The recording density at which
 2373                          a tape is to be written.  DENSITY may be specified
 2374                          when creating the first file of a volume set or
 2375                          when the volume's density can not be determined.
 2376                          All following files are created at the same density
 2377                          as the first.  For IN or UPDATE opens, DENSITY
 2378                          is determined from the tape volume containing the
 2379                          opened file unless the density could not be
 2380                          determined during AVR due to an I/O error.
 2381                          .xeq
 2382
 2383                          The default causes this parameter to be ignored.
 2384                                                                                  */
 2385              3 SEED# BIT(36) UNAL %INIT(SEED)%CHARTEXT('/**/'),
 2386                          /*K* SEED = VALUE-BIT(36).
 2387                          Is meaningful for disk files with any organization
 2388                          except INDEXED or IREL.  SEED specifies an octal or
 2389                          bit string which is to be used as the seed for
 2390                          encrypting (on M$WRITE) or decrypting (on M$READ)
 2391                          records in the file.
 2392
 2393                          Specifying a seed on a particular
 2394                          write or read overrides that set on the open, for
 2395                          that one write or read.
 2396
 2397                          .xeq
 2398                          Note that, to set or reset a seed on an M$OPEN,
 2399                          SEEDSPECIFIED must be YES.
 2400
 2401                          The default seed is '0'B (no encryption).
 2402                          */
 2403              3 * BIT(36) %INIT('0'B)%CHARTEXT('/**/'); /* Spare                  */
 2404
 2405
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            66   
 2406
 2407          %MEND;
 2408
 2409                               /***********************************************/
 2410                               /** VECTOR LOCATED PARAMETER AREA DEFINITIONS **/
 2411                               /***********************************************/
 2412
 2413                          /*F* NAME:  VLP_NAME
 2414
 2415                          The VLP_NAME macro may be used to generate
 2416                          file names (or any other entity that is in
 2417                          TEXTC format, such as a key for a keyed file).
 2418                          It generates a length byte and a character
 2419                          string of fixed length.  See also VLP_NAMEV.
 2420                          */
 2421
 2422       %MACRO VLP_NAME   (FPTN=VLP_NAME,
 2423                         NAME='                               ',
 2424                        L=,
 2425                        LEN=,
 2426                        STCLASS=STATIC);
 2427
 2428       %LSET LISTDIR='0'B;
 2429       %LSET LISTEXP='1'B;
 2430       %LSET LISTCOM='0'B;
 2431       %LSET LISTSUB='1'B;
 2432       %LSET LNG=CHARTEXT('');
 2433       %LSET SIZ=CHARTEXT('');
 2434       %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2435       %IF STR='STA' OR STR='CON' OR STR='EXT';
 2436       %IF LENGTHC(TEXTCHAR(L))=0;
 2437       %LSET SIZ=LENGTHC(NAME);
 2438       %ENDIF;
 2439       %IF LENGTHC(TEXTCHAR(LEN))=0;
 2440       %LSET LNG=0;
 2441       %ENDIF;
 2442       %LSET INIT=CHARTEXT('INIT');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            67   
 2443       %ELSE;
 2444       %IF LENGTHC(TEXTCHAR(LEN))=0;
 2445       %LSET LNG=CHARTEXT(CONCAT(TEXTCHAR(FPTN),'.L#'));
 2446       %IF STR='AUT';
 2447       %LSET LNG=31;
 2448       %ENDIF;
 2449       %ENDIF;
 2450       %LSET INIT=CHARTEXT('/*');
 2451       %ENDIF;
 2452
 2453
 2454      DCL 1 FPTN STCLASS,           /* FILE NAME DEFINITION AREA                  */
 2455            2 L# UBIN(9) %INIT(L%SIZ)%CHARTEXT('/**/') UNAL,
 2456                          /*K* L = VALUE-DEC(0-511).
 2457                          Specifies the number of significant
 2458                          characters in the name.  It defaults to the
 2459                          length of NAME, or to 31 if NAME is not
 2460                          specified.
 2461                          */
 2462            2 NAME# CHAR(LEN%LNG) %INIT(NAME)%CHARTEXT('/**/') UNAL;
 2463                          /*K* NAME = VALUE-CHAR.  Specifies a file name
 2464                          in TEXTC format.  The length of the CHAR field
 2465                          generated is the length of NAME (31 if NAME is
 2466                          not specified).  The LEN parameter can be
 2467                          specified to override the length (e.g. LEN=5).
 2468                          See M$OPEN for the character set for file names.
 2469                          If a non-initializing STCLASS is used, the default for
 2470                          LEN causes generation of a variable-length character
 2471                          string whose length is in the length byte (VLP_NAME.L#).
 2472                          If STCLASS=AUTO is used, LEN must be specified.
 2473                          See also VLP_NAMEV for a different type of based
 2474                          structure.
 2475                          */
 2476
 2477       %MEND;
 2478
 2479                          /*K* LEN = VALUE-DEC(0-511).
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            68   
 2480                          Specifies the number of
 2481                          bytes to be provided for the name.
 2482                          */
 2483
 2484                          /*F* NAME:  VLP_NAMEV
 2485
 2486                          The VLP_NAMEV macro generates a based version
 2487                          of the VLP_NAME macro with the length of the
 2488                          character string being the value currently in
 2489                          the length byte.
 2490                          */
 2491      %MACRO VLP_NAMEV   (FPTN=VLP_NAMEV,
 2492                          STCLASS=BASED);
 2493
 2494      %LSET LISTDIR='0'B;
 2495      %LSET LISTEXP='1'B;
 2496      %LSET LISTCOM='0'B;
 2497      %LSET LISTSUB='1'B;
 2498
 2499      DCL 1 FPTN STCLASS,
 2500            2 L# UBIN(9) UNAL,
 2501            2 NAME# CHAR(FPTN.L#);
 2502
 2503      %MEND;
 2504
 2505
 2506                          /*F* NAME:  VLP_ACCT
 2507
 2508                          The VLP_ACCT macro may be used to generate
 2509                          an account name.
 2510                          */
 2511
 2512       %MACRO VLP_ACCT   (FPTN=VLP_ACCT,
 2513                        ACCT=' ',
 2514                        STCLASS=STATIC);
 2515
 2516       %LSET LISTDIR='0'B;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            69   
 2517       %LSET LISTEXP='1'B;
 2518       %LSET LISTCOM='0'B;
 2519       %LSET LISTSUB='1'B;
 2520       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2521       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2522       (SUBSTR(STR,0,8)='CONSTANT') OR
 2523       (SUBSTR(STR,0,3)='EXT');
 2524       %LSET INIT=CHARTEXT('INIT');
 2525       %ELSE;
 2526       %LSET INIT=CHARTEXT('/*');
 2527       %ENDIF;
 2528
 2529
 2530      DCL 1 FPTN STCLASS,           /* ACCOUNT AREA                               */
 2531            2 ACCT# CHAR(8) %INIT(ACCT)%CHARTEXT('/**/');
 2532                          /*K* ACCT = VALUE-CHAR(8)  Specifies an account name
 2533                          which specifies the file directory in which the file
 2534                          is to be cataloged.  See M$OPEN for the character
 2535                          set for account names.  The VLP_ACCT macro should be
 2536                          used to generate the area which is referenced in
 2537                          various file management services.
 2538                          The default is blanks.
 2539                          */
 2540
 2541       %MEND;
 2542
 2543                          /*F* NAME:  VLP_PASS
 2544
 2545                          The VLP_PASS macro may be used to generate a
 2546                          password.
 2547                          */
 2548
 2549       %MACRO VLP_PASS    (FPTN=VLP_PASS,
 2550                         PASS=' ',
 2551                         STCLASS=STATIC);
 2552
 2553       %LSET LISTDIR='0'B;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            70   
 2554       %LSET LISTEXP='1'B;
 2555       %LSET LISTCOM='0'B;
 2556       %LSET LISTSUB='1'B;
 2557       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2558       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2559       (SUBSTR(STR,0,8)='CONSTANT') OR
 2560       (SUBSTR(STR,0,3)='EXT');
 2561       %LSET INIT=CHARTEXT('INIT');
 2562       %ELSE;
 2563       %LSET INIT=CHARTEXT('/*');
 2564       %ENDIF;
 2565
 2566
 2567      DCL 1 FPTN STCLASS,           /* PASSWORD AREA                              */
 2568            2 PASS# CHAR(8) %INIT(PASS)%CHARTEXT('/**/');
 2569                          /*K* PASS = VALUE-CHAR(8)  Specifies a password.  See
 2570                          M$DCB for the character set for passwords.  The
 2571                          VLP_PASS macro should be used to generate the area
 2572                          containing the password for the various file
 2573                          management services.
 2574
 2575                          The default is blanks, which is equivalent
 2576                          to "no password".
 2577                          */
 2578
 2579       %MEND;
 2580
 2581                          /*F* NAME:  VLP_NODENAME
 2582
 2583                          The VLP_NODENAME macro may be used to generate a
 2584                          nodename.
 2585                          */
 2586
 2587       %MACRO VLP_NODENAME    (FPTN=VLP_NODENAME,
 2588                         NODENAME=' ',
 2589                         STCLASS=STATIC);
 2590
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            71   
 2591       %LSET LISTDIR='0'B;
 2592       %LSET LISTEXP='1'B;
 2593       %LSET LISTCOM='0'B;
 2594       %LSET LISTSUB='1'B;
 2595       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2596       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2597       (SUBSTR(STR,0,8)='CONSTANT') OR
 2598       (SUBSTR(STR,0,3)='EXT');
 2599       %LSET INIT=CHARTEXT('INIT');
 2600       %ELSE;
 2601       %LSET INIT=CHARTEXT('/*');
 2602       %ENDIF;
 2603
 2604
 2605      DCL 1 FPTN STCLASS,           /* NODENAME AREA                              */
 2606            2 NODENAME# CHAR(8) %INIT(NODENAME)%CHARTEXT('/**/');
 2607                          /*K* NODENAME = VALUE-CHAR(8)  Specifies a nodename.  See
 2608                          M$DCB for the character set for filenames as the set for
 2609                          a nodename is the same.
 2610                          The VLP_NODENAME macro should be used to generate the
 2611                          area containing the nodename for the various file
 2612                          management services.
 2613
 2614                          The default is blanks, which is equivalent
 2615                          to "not specified".
 2616                          */
 2617
 2618       %MEND;
 2619
 2620                          /*F* NAME:  VLP_ATTR
 2621
 2622                          The VLP_ATTR macro may be used
 2623                          in conjunction with
 2624                          such keywords as ACCESS, ACSVEH, PROCATTR,
 2625                          INSTATTR, and UATTR. The VLP_ATTR macro generates
 2626                          an attribute area or the head for a list.
 2627                          The VLP_ATTR macro has three parameters,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            72   
 2628                          the name (FPTN) for the structure and the
 2629                          storage class(STCLASS) and the number of words to
 2630                          reserve in the FIT of the file for future expansion
 2631                          of the corresponding attribute area (NAW).  Specification
 2632                          of NAW is not required for such expansion, but it
 2633                          does insure that it will be possible.
 2634
 2635                          When creating an attribute area, the user invokes
 2636                          the VLP_ATTR macro to generate the first two levels
 2637                          of the structure, including the size fields and a
 2638                          field called Q. The following sample shows the
 2639                          invocation of the VLP_ATTR macro with the third
 2640                          level of structure which the user supplies, and
 2641                          also the assignment of a value to that field.
 2642
 2643                          }Example:
 2644                          }
 2645                          }%VLP_ATTR (FPTN=VLP_PROCATTR);
 2646                          }3 PROCATTR(0:2) UBIN INIT(5,2,3);
 2647                          }
 2648                          }VLP_PROCATTR.Q.PROCATTR(2)=9;
 2649                          }
 2650                          Note: The attributes generated via VLP_ATTR and
 2651                          referenced by  INSTATTR, PROCATTR, or UATTR are
 2652                          stored in the file information  table (FIT).  The
 2653                          combined size of all fields in the FIT must not
 2654                          exceed 1019 words.
 2655
 2656                          When creating an access control list or an
 2657                          access vehicle control list, the user invokes the
 2658                          VLP_ATTR macro to generate the first two levels of
 2659                          the list structure and the list size. See
 2660                          VLP_ACCESS and VLP_ACSVEH for examples of use of
 2661                          the VLP_ATTR macro to generate a list head.
 2662
 2663
 2664                                                                             */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            73   
 2665       %MACRO VLP_ATTR    (FPTN=VLP_ATTR,
 2666                        STCLASS=STATIC,
 2667                        NAW=0);
 2668
 2669       %LSET LISTDIR='0'B;
 2670       %LSET LISTEXP='1'B;
 2671       %LSET LISTCOM='0'B;
 2672       %LSET LISTSUB='1'B;
 2673       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2674       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2675       (SUBSTR(STR,0,8)='CONSTANT') OR
 2676       (SUBSTR(STR,0,3)='EXT');
 2677       %LSET INIT=CHARTEXT('INIT');
 2678       %ELSE;
 2679       %LSET INIT=CHARTEXT('/*');
 2680       %ENDIF;
 2681
 2682      DCL 1 FPTN STCLASS ALIGNED,
 2683            2 NAW# UBIN(18) UNAL %INIT(NAW)%CHARTEXT('/**/'),
 2684            2 SIZ# UBIN(18) UNAL %INIT(SIZEW(FPTN.Q))%CHARTEXT('/**/'),
 2685            2 Q,
 2686       %MEND;
 2687                          /*F* NAME:  VLP_ACCESS
 2688
 2689                          This macro generates one entry for
 2690                          an access control list. An entry sets the access
 2691                          permissions granted to a specified account. Each
 2692                          permission must be explicitly specified and
 2693                          implies no other permission. For example, the
 2694                          permission to delete records (DELR=YES) does not
 2695                          imply permission to read the file. The user must
 2696                          separately specify read permission by
 2697                          READ=YES. The VLP_ACCESS parameters are listed
 2698                          below.
 2699
 2700                          The access control list consists of a list
 2701                          head (generated via the VLP_ATTR macro) and a
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            74   
 2702                          series of entries generated by invocations of the
 2703                          VLP_ACCESS macro. The VLP_ACCESS macros must
 2704                          immediately follow the VLP_ATTR macro. (The list size is
 2705                          generated automatically.) The list name is
 2706                          assigned via the VLP_ATTR macro. A name
 2707                          is unnecessary for each entry generated via
 2708                          VLP_ACCESS; thus a default is associated with each
 2709                          entry.
 2710                          To indicate the last entry,  the list must
 2711                          contain LAST=";" as the final parameter.
 2712                          The storage class attribute (STCLASS) must
 2713                          be the same for %VLP_ATTR and each %VLP_ACCESS
 2714                          used to form an access control list.
 2715
 2716
 2717                          This access control list may be applied to
 2718                          either a file or  an account.
 2719
 2720                          }EXAMPLE:
 2721                          }
 2722                          }%VLP_ATTR(FPTN=ACT);
 2723                          }%VLP_ACCESS(READ=YES,UPD=YES,DELF=YES,ACCT='?0781');
 2724                          }%VLP_ACCESS(WNEW=YES,UPD=YES,ACCT='JOHN');
 2725                          }%VLP_ACCESS(NOLIST=YES,ACCT='SAM',LAST=";");
 2726                          */
 2727
 2728       %MACRO VLP_ACCESS  (FPTN="*",
 2729                        READ(YES='1'B,NO='0'B)='0'B,
 2730                        DELR(YES='1'B,NO='0'B)='0'B,
 2731                        WNEW(YES='1'B,NO='0'B)='0'B,
 2732                        UPD(YES='1'B,NO='0'B)='0'B,
 2733                        DELF(YES='1'B,NO='0'B)='0'B,
 2734                        NOLIST(YES='1'B,NO='0'B)='0'B,
 2735                        REATTR(YES='1'B,NO='0'B)='0'B,
 2736                        EXEC(YES='1'B,NO='0'B)='0'B,
 2737                        AU(YES='1'B,NO='0'B)='0'B,
 2738                        AURD(YES='1'B,NO='0'B)='0'B,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            75   
 2739                        TCTL(YES='1'B,NO='0'B)='0'B,
 2740                        ACCT=' ',
 2741                        STCLASS=STATIC,
 2742                        LAST=",");
 2743
 2744       %LSET LISTDIR='0'B;
 2745       %LSET LISTEXP='1'B;
 2746       %LSET LISTCOM='0'B;
 2747       %LSET LISTSUB='1'B;
 2748       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2749       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2750       (SUBSTR(STR,0,8)='CONSTANT') OR
 2751       (SUBSTR(STR,0,3)='EXT');
 2752       %LSET INIT=CHARTEXT('INIT');
 2753       %ELSE;
 2754       %LSET INIT=CHARTEXT('/*');
 2755       %ENDIF;
 2756
 2757              3 FPTN,
 2758                4 FFLG,
 2759                5 READ# BIT(1) %INIT(READ)%CHARTEXT('/**/'),
 2760                          /*K* READ = {YES|NO}
 2761                          .xeq F_DCB_C M$DCB  FFLG.READ#
 2762                          This parameter is used
 2763                to initialize the field VLP_ACCESS.FFLG.READ#.  The default is NO.
 2764                */
 2765                5 DELR# BIT(1) %INIT(DELR)%CHARTEXT('/**/'),
 2766                          /*K* DELR = {YES|NO}
 2767                          .xeq F_DCB_C M$DCB  FFLG.DELR#
 2768                          This parameter is used
 2769                to initialize the field VLP_ACCESS.FFLG.DELR#.  The default is NO.
 2770                */
 2771                5 WNEW# BIT(1) %INIT(WNEW)%CHARTEXT('/**/'),
 2772                          /*K* WNEW = {YES|NO}
 2773                          .xeq F_DCB_C M$DCB  FFLG.WNEW#
 2774                          This parameter is used
 2775                to initialize the field VLP_ACCESS.FFLG.WNEW#.  The default is NO.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            76   
 2776                */
 2777                5 UPD# BIT(1) %INIT(UPD)%CHARTEXT('/**/'),
 2778                          /*K* UPD = {YES|NO}
 2779                          .xeq F_DCB_C M$DCB  FFLG.UPD#
 2780                          This parameter is used
 2781                to initialize the field VLP_ACCESS.FFLG.UPD#.  The default is NO.
 2782                */
 2783                5 DELF# BIT(1) %INIT(DELF)%CHARTEXT('/**/'),
 2784                          /*K* DELF = {YES|NO}
 2785                          .xeq F_DCB_C M$DCB  FFLG.DELF#
 2786                          This parameter is used
 2787                to initialize the field VLP_ACCESS.FFLG.DELF#. The default is NO.
 2788                */
 2789                5 NOLIST# BIT(1) %INIT(NOLIST)%CHARTEXT('/**/'),
 2790                          /*K* NOLIST = {YES|NO}
 2791                          .xeq F_DCB_C M$DCB  FFLG.NOLIST#
 2792                          This parameter is used
 2793                to initialize the field VLP_ACCESS.FFLG.NOLIST#.  The default is NO.
 2794                */
 2795                5 REATTR# BIT(1) %INIT(REATTR)%CHARTEXT('/**/'),
 2796                          /*K* REATTR = {YES|NO)
 2797                          .xeq F_DCB_C M$DCB  FFLG.REATTR#
 2798                          This parameter is used
 2799                to initialize the field VLP_ACCESS.FFLG.REATTR#.  The default is NO.
 2800                */
 2801                5 EXEC# BIT(1) %INIT(EXEC)%CHARTEXT('/**/'),
 2802                          /*K* EXEC = {YES|NO}  Specifying YES causes a
 2803                          search of any access vehicle list for a match
 2804                          with the running processor.  If no match is found,
 2805                          F$DCB.FFLG is set to VLP_ACCESS.FFLG and F$DCB.FFLG.EXEC#
 2806                          is reset.  Otherwise, F$DCB.FFLG is set to
 2807                          VLP_ACSVEH.FFLG for the matching vehicle and
 2808                          F$DCB.FFLG.EXEC# is set.  This parameter is used
 2809                          to initialize the field VLP_ACCESS.FFLG.EXEC#.
 2810                          The default is NO.
 2811                          */
 2812                5 * BIT(1) %INIT('0'B)%CHARTEXT('/**/'), /* CREATE#               */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            77   
 2813                5 AU# BIT(1) %INIT(AU)%CHARTEXT('/**/'),
 2814                          /*K* AU = {YES|NO}
 2815                          .xeq F_DCB_C M$DCB  FFLG.AU#
 2816                          This parameter is
 2817                          used to initialize the field VLP_ACCESS.FFLG.AU#.
 2818                          The default is NO.
 2819                          */
 2820                5 AURD# BIT(1) %INIT(AURD)%CHARTEXT('/**/'),
 2821                          /*K* AURD = {YES|NO}
 2822                          .xeq F_DCB_C M$DCB  FFLG.AURD#
 2823                          This parameter is
 2824                          used to initialize the field VLP_ACCESS.FFLG.AURD#.
 2825                          The default is NO.
 2826                          */
 2827                5 TCTL# BIT(1) %INIT(TCTL)%CHARTEXT('/**/'),
 2828                          /*K* TCTL = {YES|NO}
 2829                          .xeq F_DCB_C M$DCB  FFLG.TCTL#
 2830                          This parameter is
 2831                          used to initialize the field VLP_ACCESS.FFLG.TCTL#.
 2832                          The default is NO.
 2833                          */
 2834                5 * BIT(6) %INIT('0'B)%CHARTEXT('/**/'),
 2835                4 ACCT# CHAR(8) %INIT(ACCT)%CHARTEXT('/**/')LAST
 2836                          /*K* ACCT = VALUE-CHAR(8)  Specifies the account
 2837                          to which the permissions in VLP_ACCESS.FFLG are to be
 2838                          granted.  A wildcard character '?' may be included in the
 2839                          account specification.
 2840                          */
 2841       %MEND;
 2842
 2843                          /*F* NAME:  VLP_ACSVEH
 2844
 2845                          The VLP_ACSVEH macro generates one entry for
 2846                          an access vehicle control list. An entry sets the
 2847                          access permissions granted to a specified
 2848                          processor (that is, a vehicle). Each permission
 2849                          must be explicitly specified and implies no other
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            78   
 2850                          permission. For example, the permission to delete
 2851                          records (DELR=YES) does not imply permission to
 2852                          read the file. The user must separately specify
 2853                          read permission by  READ=YES.
 2854
 2855                          The access vehicle control list consists of a
 2856                          list head (generated via the VLP_ATTR macro) and a
 2857                          series of entries generated by invocations of the
 2858                          VLP_ACSVEH macro.
 2859                          The access vehicle control list is constructed in the
 2860                          same manner as the access control list, using VLP_ACSVEH
 2861                          instead of the VLP_ACCESS macro.
 2862                          The VLP_ACSVEH name defaults to *.
 2863                          The storage class attribute (STCLASS) must be
 2864                          the same for %VLP_ATTR and each %VLP_ACSVEH used
 2865                          to form an access vehicle control list.
 2866
 2867                          }EXAMPLE:
 2868                          }
 2869                          }%VLP_ATTR(FPTN=VEH);
 2870                          }%VLP_ACSVEH(READ=YES,UPD=YES,DELF=YES,VEHICLE='EDIT');
 2871                          }%VLP_ACSVEH(WNEW=YES,UPD=YES,VEHICLE='COBOL');
 2872                          }%VLP_ACSVEH(NOLIST=YES,VEHICLE='PCL',LAST=";");
 2873                                                                             */
 2874       %MACRO VLP_ACSVEH  (FPTN="*",
 2875                        READ(YES='1'B,NO='0'B)='0'B,
 2876                        DELR(YES='1'B,NO='0'B)='0'B,
 2877                        WNEW(YES='1'B,NO='0'B)='0'B,
 2878                        UPD(YES='1'B,NO='0'B)='0'B,
 2879                        DELF(YES='1'B,NO='0'B)='0'B,
 2880                        REATTR(YES='1'B,NO='0'B)='0'B,
 2881                        AU(YES='1'B,NO='0'B)='0'B,
 2882                        AURD(YES='1'B,NO='0'B)='0'B,
 2883                        TCTL(YES='1'B,NO='0'B)='0'B,
 2884                        VEHICLE=' ',
 2885                        LEN=0,
 2886                        STCLASS=STATIC,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            79   
 2887                        LAST=",");
 2888
 2889       %LSET LISTDIR='0'B;
 2890       %LSET LISTEXP='1'B;
 2891       %LSET LISTCOM='0'B;
 2892       %LSET LISTSUB='1'B;
 2893       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2894       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2895       (SUBSTR(STR,0,8)='CONSTANT') OR
 2896       (SUBSTR(STR,0,3)='EXT');
 2897       %LSET INIT=CHARTEXT('INIT');
 2898       %ELSE;
 2899       %LSET INIT=CHARTEXT('/*');
 2900       %ENDIF;
 2901
 2902                3 FPTN,
 2903                4 FFLG,
 2904                5 READ# BIT(1) %INIT(READ)%CHARTEXT('/**/'),
 2905                          /*K* READ = {YES|NO}
 2906                          .xeq F_DCB_C M$DCB  FFLG.READ#
 2907                          This parameter is used
 2908                          to initialize the field VLP_ACSVEH.FFLG.READ#.
 2909                          The default is NO.
 2910                          */
 2911                5 DELR# BIT(1) %INIT(DELR)%CHARTEXT('/**/'),
 2912                          /*K* DELR = {YES|NO}
 2913                          .xeq F_DCB_C M$DCB  FFLG.DELR#
 2914                          This parameter is used
 2915                          to initialize the field VLP_ACSVEH.FFLG.DELR#.
 2916                          The default is NO.
 2917                          */
 2918                5 WNEW# BIT(1) %INIT(WNEW)%CHARTEXT('/**/'),
 2919                          /*K* WNEW = {YES|NO}
 2920                          .xeq F_DCB_C M$DCB  FFLG.WNEW#
 2921                          This parameter is used
 2922                          to initialize the field VLP_ACSVEH.FFLG.WNEW#.
 2923                          The default is NO.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            80   
 2924                          */
 2925                5 UPD# BIT(1) %INIT(UPD)%CHARTEXT('/**/'),
 2926                          /*K* UPD = {YES|NO}
 2927                          .xeq F_DCB_C M$DCB  FFLG.UPD#
 2928                          This parameter is used
 2929                          to initialize the field VLP_ASCVEH.FFLG.UPD#.
 2930                          The default is NO.
 2931                          */
 2932                5 DELF# BIT(1) %INIT(DELF)%CHARTEXT('/**/'),
 2933                          /*K* DELF = {YES|NO}
 2934                          .xeq F_DCB_C M$DCB  FFLG.DELF#
 2935                          This parameter is used
 2936                          to initialize the field VLP_ACSVEH.FFLG.DELF#.
 2937                          The default is NO.
 2938                          */
 2939                5 * BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 2940                5 REATTR# BIT(1) %INIT(REATTR)%CHARTEXT('/**/'),
 2941                          /*K* REATTR = {YES|NO}
 2942                          .xeq F_DCB_C M$DCB  FFLG.REATTR#
 2943                          This parameter is used
 2944                          to initialize the field VLP_ACSVEH.FFLG.REATTR#.
 2945                          The default is NO.
 2946                          */
 2947                5 * BIT(2) %INIT('0'B)%CHARTEXT('/**/'), /* EXEC#, CREATE#        */
 2948                5 AU# BIT(1) %INIT(AU)%CHARTEXT('/**/'),
 2949                          /*K* AU = {YES|NO}
 2950                          .xeq F_DCB_C M$DCB  FFLG.AU#
 2951                          This parameter is
 2952                          used to initialize the field VLP_ACCESS.FFLG.AU#.
 2953                          The default is NO.
 2954                          */
 2955                5 AURD# BIT(1) %INIT(AURD)%CHARTEXT('/**/'),
 2956                          /*K* AURD = {YES|NO}
 2957                          .xeq F_DCB_C M$DCB  FFLG.AURD#
 2958                          This parameter is
 2959                          used to initialize the field VLP_ACCESS.FFLG.AURD#.
 2960                          The default is NO.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            81   
 2961                          */
 2962                5 TCTL# BIT(1) %INIT(TCTL)%CHARTEXT('/**/'),
 2963                          /*K* TCTL = {YES|NO}
 2964                          .xeq F_DCB_C M$DCB  FFLG.TCTL#
 2965                          This parameter is
 2966                          used to initialize the field VLP_ACCESS.FFLG.TCTL#.
 2967                          The default is NO.
 2968                          */
 2969                5 * BIT(6) %INIT('0'B)%CHARTEXT('/**/'),
 2970                4 C UBIN BYTE UNAL %INIT(SIZEC(VEHICLE))%CHARTEXT('/**/'),
 2971                4 VEHICLE# CHAR(LEN) %INIT(VEHICLE)%CHARTEXT('/**/')LAST
 2972                          /*K* LEN = VALUE-DEC(0-31)  Specifies the size of the
 2973                          field to be allocated for VEHICLE.  The default is 0,
 2974                          which causes a list of initialized VLP_ACSVEH structures
 2975                          to function properly, since PL6 interprets 0 in this
 2976                          context as LENGTHC(VEHICLE).  This option is thus most
 2977                          useful when STCLASS is SYMREF or BASED, where a
 2978                          specification of "...VLP_ACSVEH.C" would accurately
 2979                          describe the field.                                     */
 2980                          /*K* VEHICLE = VALUE-CHAR(31)  Specifies the vehicle
 2981                          to which the permissions in VLP_ACSVEH.FFLG
 2982                          are to be granted.  This field is TEXTC, with the
 2983                          count byte at VLP_ACSVEH.C.
 2984                          */
 2985       %MEND;
 2986
 2987                          /*F* NAME:  VLP_WSN
 2988
 2989                          This macro generates an area containing a
 2990                          workstation name. The workstation name is
 2991                          meaningful in conjunction with a device fid or
 2992                          special name (RES on M$DCB or M$OPEN, DEV on M$LDEV).
 2993                          The workstation specifies a cluster of unit record
 2994                          devices; the device type selects those devices in the
 2995                          workstation of that type.
 2996
 2997                          A symbol ('@') can be substituted for the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            82   
 2998                          workstation name to mean the user's workstation of
 2999                          origin.  The definition of
 3000                          workstation names and assignment of devices to
 3001                          workstations are made by the installation manager.
 3002
 3003                          */
 3004       %MACRO VLP_WSN   (FPTN=VLP_WSN,WSN=' ',STCLASS=STATIC);
 3005
 3006       %LSET LISTDIR='0'B;
 3007       %LSET LISTEXP='1'B;
 3008       %LSET LISTCOM='0'B;
 3009       %LSET LISTSUB='1'B;
 3010       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3011       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3012       (SUBSTR(STR,0,8)='CONSTANT') OR
 3013       (SUBSTR(STR,0,3)='EXT');
 3014       %LSET INIT=CHARTEXT('INIT');
 3015       %ELSE;
 3016       %LSET INIT=CHARTEXT('/*');
 3017       %ENDIF;
 3018
 3019
 3020      DCL 1 FPTN STCLASS,           /* WORK STATION NAME                          */
 3021            2 WSN# CHAR(8) %INIT(WSN)%CHARTEXT('/**/');
 3022                          /*K* WSN = VALUE-CHAR(8)
 3023                          Contains the workstation name
 3024                          which is referenced by WSN in various
 3025                          file management services.
 3026                          */
 3027
 3028       %MEND;
 3029
 3030                          /*F* NAME:  VLP_SN
 3031
 3032                          The VLP_SN macro creates an
 3033                          area containing the list of
 3034                          serial numbers of the volumes or tape reels that
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            83   
 3035                          are to be accessed; or the pack set name for
 3036                          pack set access.
 3037                          The serial numbers and pack set names
 3038                          may consist of up to 6 alphanumeric characters.
 3039                          The pack set names are defined by the installation
 3040                          manager.
 3041
 3042                          The following examples demonstrate the use of
 3043                          this macro.
 3044
 3045                          Example for disk:
 3046
 3047                          %VLP_SN (FPTN=PACK_SET,N=1,SN='PAC   ');
 3048
 3049
 3050                          Example for tape:
 3051
 3052                          %VLP_SN (FPTN=TAPE_SET,N=2,SN="'100001','100002'");
 3053
 3054                          */
 3055       %MACRO VLP_SN  (FPTN=VLP_SN,
 3056              %N=1,
 3057              SN=' ',
 3058              STCLASS=STATIC);
 3059
 3060       %LSET LISTDIR='0'B;
 3061       %LSET LISTEXP='1'B;
 3062       %LSET LISTCOM='0'B;
 3063       %LSET LISTSUB='1'B;
 3064       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3065       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3066       (SUBSTR(STR,0,8)='CONSTANT') OR
 3067       (SUBSTR(STR,0,3)='EXT');
 3068       %LSET INIT=CHARTEXT('INIT');
 3069       %ELSE;
 3070       %LSET INIT=CHARTEXT('/*');
 3071       %ENDIF;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            84   
 3072
 3073
 3074      DCL 1 FPTN STCLASS DALIGNED,  /* PSN OR SER. NO. LIST                       */
 3075            2 NUM# SBIN %INIT(N)%CHARTEXT('/**/'),
 3076                          /*K* N = VALUE-DEC(1-?)  Specifies
 3077                          the number of serial numbers
 3078                          which have been defined within this structure.
 3079                          The default for N is one.
 3080                          */
 3081            2 SN#(0:%MAX(0,N-1)) CHAR(6) UNAL %INIT(SN*0)%CHARTEXT('/**/');
 3082                          /*K* SN = 1 to n VALUES-CHAR(6)  Specifies
 3083                          the serial numbers of the volumes contained in the
 3084                          tape volume set.  They must be given in the order
 3085                          that the volume set was created or is to be created.
 3086                          */
 3087
 3088       %MEND;
 3089
 3090                          /*F* NAME:  VLP_FORM
 3091
 3092                          The VLP_FORM macro generates
 3093                          an area containing the
 3094                          name of the form to be mounted on a unit record device.
 3095                          The form name is defined in the Form Definition
 3096                          File (created by the installation manager
 3097                          via Super).  For devices which have pagination, the
 3098                          definition specifies paper width, printable length,
 3099                          and vertical format control information.
 3100                          For other unit record devices, the definition specifies
 3101                          device width.
 3102
 3103                          The form name is meaningful for opens to UR disk
 3104                          files and to devices.  The form name is also meaningful
 3105                          for calls to the M$LDEV monitor service.
 3106                          */
 3107       %MACRO VLP_FORM (FPTN=VLP_FORM,
 3108              FORM=' ',
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            85   
 3109              STCLASS=STATIC);
 3110
 3111       %LSET LISTDIR='0'B;
 3112       %LSET LISTEXP='1'B;
 3113       %LSET LISTCOM='0'B;
 3114       %LSET LISTSUB='1'B;
 3115       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3116       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3117       (SUBSTR(STR,0,8)='CONSTANT') OR
 3118       (SUBSTR(STR,0,3)='EXT');
 3119       %LSET INIT=CHARTEXT('INIT');
 3120       %ELSE;
 3121       %LSET INIT=CHARTEXT('/*');
 3122       %ENDIF;
 3123
 3124      DCL 1 FPTN STCLASS,
 3125            2 FORM# CHAR(6) %INIT(FORM)%CHARTEXT('/**/');
 3126                          /*K* FORM = VALUE-CHAR(6)
 3127                          Specifies the name of the forms to be mounted on
 3128                          a unit record device.
 3129                          The default is blanks.  Blanks mean use standard
 3130                          forms for the device.
 3131                          */
 3132       %MEND;
 3133
 3134                          /*F* NAME:  VLP_TAB
 3135
 3136                          The VLP_TAB macro generates an area
 3137                          containing horizontal tabulation definition.
 3138                          Tabulation is only applicable on output to
 3139                          devices and Unit Record (UR) files.
 3140                                                                             */
 3141       %MACRO VLP_TAB     (FPTN=VLP_TAB,
 3142                         MARGIN=0,
 3143                         TABS=0,
 3144                         STCLASS=STATIC);
 3145
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            86   
 3146       %LSET LISTDIR='0'B;
 3147       %LSET LISTEXP='1'B;
 3148       %LSET LISTCOM='0'B;
 3149       %LSET LISTSUB='1'B;
 3150       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3151       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3152       (SUBSTR(STR,0,8)='CONSTANT') OR
 3153       (SUBSTR(STR,0,3)='EXT');
 3154       %LSET INIT=CHARTEXT('INIT');
 3155       %ELSE;
 3156       %LSET INIT=CHARTEXT('/*');
 3157       %ENDIF;
 3158
 3159      DCL 1 FPTN STCLASS ALIGNED,
 3160            2 MARGIN# UBIN(9) %INIT(MARGIN)%CHARTEXT('/**/') UNAL,
 3161                          /*K* MARGIN = VALUE-DEC(0-255)  specifies the
 3162                          lefthand margin by column number.  The leftmost column
 3163                          is considered to be column 1.
 3164                          Record from the user's M$WRITE request
 3165                          will have blanks inserted so the the user's text
 3166                          starts in the specified column.
 3167                          The default (0 or 255) causes this parameter to
 3168                          be ignored.
 3169                          */
 3170            2 TABS# (0:30) UBIN(9) UNAL %INIT(TABS,0*0)%CHARTEXT('/**/');
 3171                          /*K* TABS = 1-31 VALUES-DEC(0-255)  Specifies
 3172                          horizontal tabulation columns.
 3173                          There is a maximum of 31 tabulation columns,
 3174                          which must be in ascending numeric order and
 3175                          separated by commas.
 3176                          Records from user M$WRITE requests which
 3177                          have HT (Horizontal Tab) characters in the
 3178                          record will be processed as if each HT
 3179                          were replaced by a string of blanks up to
 3180                          the next-higher horizontal tabulation
 3181                          column.
 3182
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            87   
 3183                          If MARGIN is also specified, tabulation is
 3184                          displaced so that the MARGIN column on the output
 3185                          medium is TABS column 1.
 3186                          The default is no tabulation.  (Each HT character in an
 3187                          output record is replaced by a single blank.)
 3188                          */
 3189       %MEND;
 3190
 3191                          /*F* NAME:  VLP_HDR
 3192
 3193                          The VLP_HDR macro generates
 3194                          an area containing page header information
 3195                          for a unit record device.  The page header information
 3196                          is applicable to unit record files and devices
 3197                          which have pagination.
 3198                                                                             */
 3199       %MACRO VLP_HDR     (FPTN=VLP_HDR,
 3200                         HEADERHEIGHT=1,
 3201                         INDENT=0,
 3202             RESETPAGE(YES='1'B,NO='0'B)='0'B,
 3203                         COUNT=0,
 3204                         TITLE=' ',
 3205                         LEN=0,
 3206                         STCLASS=STATIC);
 3207
 3208       %LSET LISTDIR='0'B;
 3209       %LSET LISTEXP='1'B;
 3210       %LSET LISTCOM='0'B;
 3211       %LSET LISTSUB='1'B;
 3212       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3213       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3214       (SUBSTR(STR,0,8)='CONSTANT') OR
 3215       (SUBSTR(STR,0,3)='EXT');
 3216       %LSET INIT=CHARTEXT('INIT');
 3217       %ELSE;
 3218       %LSET INIT=CHARTEXT('/*');
 3219       %ENDIF;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            88   
 3220
 3221      DCL 1 FPTN STCLASS ALIGNED,
 3222            2 CTL,
 3223              3 * UBIN(8) UNAL %INIT(0)%CHARTEXT('/**/'),
 3224              3 RESETPAGE# BIT(1) UNAL %INIT(RESETPAGE)%CHARTEXT('/**/'),
 3225                          /*K* RESETPAGE = {YES|NO}  YES specifies
 3226                          page numbering is to be restarted at page 1. NO
 3227                          specifies that no change is to be made.
 3228                          The default is NO.
 3229                                                                                  */
 3230              3 * UBIN(5) UNAL %INIT(0)%CHARTEXT('/**/'),
 3231              3 HEADERHEIGHT# UBIN(4) %INIT(HEADERHEIGHT)%CHARTEXT('/**/') UNAL,
 3232                          /*K* HEADERHEIGHT = VALUE-DEC(0-15)
 3233                          Specifies the height of the page header area.  The default
 3234                          is 1 (i.e., single space after printing
 3235                          title line).                                            */
 3236              3 INDENT# UBIN(9) %INIT(INDENT)%CHARTEXT('/**/') UNAL,
 3237                          /*K* INDENT = VALUE-DEC(1-255)  Specifies
 3238                          the column in which TITLE text is to start (see TITLE).
 3239                          Lefthand column is column 1, and is the default.        */
 3240              3 COUNT# UBIN(9) %INIT(COUNT)%CHARTEXT('/**/') UNAL,
 3241                          /*K* COUNT = VALUE-DEC(1-255)  Specifies
 3242                          that the page number is to be printed on the TITLE
 3243                          line, with its lefthand digit in the
 3244                          specified column.
 3245                          The default is 0 (i.e., no page numbering).
 3246                          */
 3247            2 TITL,
 3248              3 L# UBIN(9) %INIT(SIZEC(TITLE))%CHARTEXT('/**/') UNAL,
 3249              3 TITLE# CHAR(LEN) %INIT(TITLE)%CHARTEXT('/**/') UNAL;
 3250                          /*K* TITLE = VALUE-CHAR(1-?)
 3251                          Specifies the text which
 3252                          is to be printed as a title on the top
 3253                          of every page of output for the line
 3254                          printer.  This field is TEXTC.                          */
 3255
 3256                          /*K* LEN = VALUE-DEC(0-511)
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            89   
 3257                          Specifies the number of bytes to be reserved for
 3258                          the text of the TITLE field.  Note that the length
 3259                          byte of the TITLE field is always initialized to
 3260                          the size in characters of TITLE.  The LEN
 3261                          parameter will not affect this value.  However,
 3262                          the LEN parameter may be used to reserve a larger
 3263                          space in the character portion of the TITLE field
 3264                          than would be required for the initial TITLE text.
 3265                          The default is 0.                                       */
 3266       %MEND;
 3267
 3268                          /*F* NAME:  VLP_ULBL
 3269
 3270                          The VLP_ULBL macro creates an
 3271                          area containing a user label group for input or
 3272                          output.  For output, N should be the number of
 3273                          user labels to write.  On input, N is set to the
 3274                          number of user labels read; the size of VLP_ULBL
 3275                          determines the number of labels read.
 3276                          */
 3277       %MACRO VLP_ULBL  (FPTN=VLP_ULBL,
 3278              %N=1,
 3279              ULBL=' ',
 3280              STCLASS=STATIC);
 3281
 3282      %LSET LISTDIR='0'B;
 3283      %LSET LISTEXP='1'B;
 3284      %LSET LISTCOM='0'B;
 3285      %LSET LISTSUB='1'B;
 3286      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3287      %IF (SUBSTR(STR,0,6)='STATIC') OR
 3288       (SUBSTR(STR,0,8)='CONSTANT') OR
 3289       (SUBSTR(STR,0,3)='EXT');
 3290       %LSET INIT=CHARTEXT('INIT');
 3291      %ELSE;
 3292       %LSET INIT=CHARTEXT('/*');
 3293      %ENDIF;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            90   
 3294
 3295
 3296      DCL 1 FPTN STCLASS DALIGNED,
 3297            2 NUM# SBIN %INIT(N)%CHARTEXT('/**/'),
 3298                          /*K* N = VALUE-DEC(1-?)  Specifies
 3299                          the number of user labels which are to be written.
 3300                          The default for N is one.
 3301                          */
 3302            2 ULBL#(0:%MAX(0,N-1)) CHAR(80) UNAL %INIT(ULBL*0)%CHARTEXT('/**/'),
 3303                /*K* ULBL = "'UxL1labeltext'[,'UxL2labeltext',...,'UxLnlabeltext']"
 3304                specifies if x is 'H' the User Header Labels to
 3305                be written during a M$OPEN or M$CVOL or if x is 'T'
 3306                the User Trailer Labels to be written during a
 3307                M$CLOSE or M$CVOL.  The structure may be used to
 3308                receive user labels on input.
 3309                */
 3310            2 ULBLFIELD(0:%MAX(0,N-1)) REDEF ULBL# UNAL,
 3311              3 LABELID CHAR(3) UNAL,
 3312              3 LABELNUM CHAR(1) UNAL,
 3313              3 USERAPPL CHAR(76) UNAL;
 3314
 3315      %MEND;
 3316
 3317
 3318                          /*F* NAME:  VLP_ALTKEYS
 3319
 3320                          The VLP_ALTKEYS macro creates an area describing
 3321                          alternate index keys for indexed files.  It may
 3322                          be specified on create opens or on closes.  Note
 3323                          that only alternate keys are defined by
 3324                          VLP_ALTKEYS.  The primary key is defined by the
 3325                          KEYX and KEYL parameters of FPT_OPEN and is always
 3326                          unique.
 3327
 3328                          The VLP_ALTKEYS area includes the field VLP_ALTKEYS.SIZ#
 3329                          followed by an array, K.  K is an array of dimension
 3330                          (0:N-1), with one entry for each alternate index.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            91   
 3331                          For create opens SIZ# contains the number of indices
 3332                          that are being created at this time, while N is
 3333                          the number to leave room for in the File
 3334                          Information Table (FIT).
 3335                          */
 3336
 3337       %MACRO VLP_ALTKEYS  (FPTN=VLP_ALTKEYS,
 3338                            %N=1,
 3339                            KEYL=1,
 3340                            KEYX=0,
 3341                            UNIQUE(YES='1'B,NO='0'B)='0'B,
 3342                            STCLASS=STATIC);
 3343
 3344      %LSET LISTDIR='0'B;
 3345      %LSET LISTEXP='1'B;
 3346      %LSET LISTCOM='0'B;
 3347      %LSET LISTSUB='1'B;
 3348      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3349      %IF (SUBSTR(STR,0,6)='STATIC') OR
 3350       (SUBSTR(STR,0,8)='CONSTANT') OR
 3351       (SUBSTR(STR,0,3)='EXT');
 3352       %LSET INIT=CHARTEXT('INIT');
 3353      %ELSE;
 3354       %LSET INIT=CHARTEXT('/*');
 3355      %ENDIF;
 3356
 3357
 3358      DCL 1 FPTN STCLASS DALIGNED,
 3359            2 SIZ# UBIN %INIT(N)%CHARTEXT('/**/'),
 3360                          /*K* N = VALUE-DEC(0-80) specifies the number of
 3361                     alternate indices to leave room for in the FIT of the file.
 3362                     This value is used to initialize VLP_ALTKEYS.SIZ#,
 3363                     but the SIZ# field may be changed at create open to
 3364                     establish the number of alternate indices to be created.     */
 3365
 3366            2 K(0:%(N-1)),
 3367
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            92   
 3368              3 UNIQUE# BIT(1) %INIT(UNIQUE*0)%CHARTEXT('/**/'),
 3369                          /*K* UNIQUE = {YES|NO} if YES, then the keys
 3370                          in this index must be unique.  If a record is
 3371                          written which contains a key with the same value
 3372                          as an existing key, then the write will fail.
 3373                          If UNIQUE = NO, then duplicate entries will
 3374                          be created if several records have the same
 3375                          key value.  The order of the duplicate keys
 3376                          is the order of arrival of the records.                 */
 3377
 3378              3 * BIT(8) %INIT('0'B*0)%CHARTEXT('/**/'),
 3379              3 KEYL# UBIN(9) UNAL %INIT(KEYL*0)%CHARTEXT('/**/'),
 3380                          /*K* KEYL = VALUE-DEC(1-255)  Specifies the
 3381                          length of the key for this index.  The default is
 3382                          one.                                                    */
 3383
 3384              3 KEYX# UBIN(18) UNAL %INIT(KEYX*0)%CHARTEXT('/**/');
 3385                          /*K* KEYX = VALUE-DEC(0-4000)  Specifies the
 3386                          byte offset into the record of the beginning
 3387                          of this key.  The default is zero, which indicates
 3388                          the first column in the record.
 3389                          */
 3390
 3391      %MEND;
 3392                          /*F* NAME: VLP_VIRTUAL
 3393
 3394                          The VLP_VIRTUAL macro describes the parameters for a
 3395                          large virtual segment when a keyed file is being opened.
 3396                          It contains parameters that influence the use of a large
 3397                          virtual segment.
 3398
 3399                          The values for SEGSIZE and PHYSICAL especially affect
 3400                          performance.  When possible, it is desirable to have
 3401                          physical backing for the virtual segment as close to
 3402                          one-to-one as possible.  Within the constraints of user
 3403                          authorization and system memory size, this can be done
 3404                          as long as SEGSIZE is not more than 16MW.  On
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            93   
 3405                          machines that support section page tables, DPS90
 3406                          and DPS8000, all virtual segments larger than 4MW
 3407                          are backed up by a section page table which allows
 3408                          a maximum of 15K pages PHYSICAL.  Smaller virtual
 3409                          segments on these machines are backed up by either
 3410                          a dense page table, on the DPS90 and DPS8000, or a
 3411                          fragmented page table, on the DPS90.  A dense page
 3412                          table allows a maximum of 16K pages PHYSICAL; a
 3413                          fragmented page table allows a maximum of 256 pages
 3414                          PHYSICAL.  On machines which do not support
 3415                          section page tables, DPS 8s and Level 66s, virtual
 3416                          segments larger than 16MW are backed up by
 3417                          fragmented page tables allowing for 256 pages
 3418                          PHYSICAL.  Smaller virtual segments on these
 3419                          machines are backed up with dense page tables
 3420                          allowing for 16K pages PHYSICAL.
 3421                                                    */
 3422
 3423      %MACRO VLP_VIRTUAL (FPTN=VLP_VIRTUAL,
 3424                               SEGSIZE=0,
 3425                               SEGNUM(VS1=1,VS2=2,VS3=3)=0,
 3426                               PHYSICAL=10,
 3427                          NOFILE(YES='1'B,NO='0'B)='0'B,
 3428                          MINPHYS=10,
 3429                               INITIALIZE(YES='1'B,NO='0'B)='0'B,
 3430                               INITVALUE=0,
 3431                               STCLASS=STATIC);
 3432
 3433      %LSET LISTDIR='0'B;
 3434      %LSET LISTEXP='1'B;
 3435      %LSET LISTCOM='0'B;
 3436      %LSET LISTSUB='1'B;
 3437      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3438      %IF (SUBSTR(STR,0,6)='STATIC') OR
 3439       (SUBSTR(STR,0,8)='CONSTANT') OR
 3440       (SUBSTR(STR,0,3)='EXT');
 3441       %LSET INIT=CHARTEXT('INIT');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            94   
 3442      %ELSE;
 3443       %LSET INIT=CHARTEXT('/*');
 3444      %ENDIF;
 3445
 3446      DCL 1 FPTN STCLASS ALIGNED,
 3447            2 INITIALIZE# BIT(1) UNAL %INIT(INITIALIZE)%CHARTEXT('/**/'),
 3448                     /*K* INITIALIZE = {YES|NO}. YES specifies that any page that
 3449                     has not been accessed before, and does not exist in the paging
 3450                     file, will be initialized to the value specified in INITVALUE.
 3451                     NO specifies that a value selected by the system will be used
 3452                     to initialize the page.  The default is NO.
 3453                                     */
 3454
 3455            2 NOFILE# BIT(1) UNAL %INIT(NOFILE)%CHARTEXT('/**/'),
 3456                     /*K* NOFILE = {YES|NO}. Specifies if the user wants control
 3457                of the missing page faults or not.  If YES is specified, whenever
 3458                a page needs to be paged in, the user will get an event.  The
 3459                user then can use M$CVM or M$GVP to allocate that page.
 3460                */
 3461            2 * BIT(7) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3462            2 WSQ# UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
 3463                          /*K* WSQ - UBIN(9)  Is returned to the user containing the
 3464                     WSQ allocated.  This is needed in conjunction with the NOFILE
 3465                     option to determine what WSQ to use.
 3466                     */
 3467            2 DCB# UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
 3468            2 SEGNUM# UBIN(9) UNAL %INIT(SEGNUM)%CHARTEXT('/**/'),
 3469                          /*K* SEGNUM = {VS1|VS2|VS3}  Specifies which of
 3470                          the three large virtual segments is to be used for
 3471                          this file.
 3472                          */
 3473            2 INITVALUE# UBIN ALIGNED %INIT(INITVALUE)%CHARTEXT('/**/'),
 3474                          /*K* INITVALUE = VALUE-DEC(0-2**32-1). Value will be used
 3475                          when INITIALIZE=YES
 3476                          is specified as the value that the page is to be set to on
 3477                     the initial access of the page (if it does not exist in the
 3478                     paging file). The default is 0.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            95   
 3479                     */
 3480
 3481            2 SEGSIZE# UBIN %INIT(SEGSIZE)%CHARTEXT('/**/'),
 3482                /*K* SEGSIZE = VALUE-DEC(1-4294967296) specifies in words the size
 3483                of the large virtual segment. The actual bounding of a virtual
 3484                segment is done on a page basis so the SEGSIZE will be rounded up
 3485           to a number of virtual pages. Any page access that is not within bounds
 3486           will cause a missing page fault.
 3487
 3488           For the virtual array capability, super descriptors and a
 3489           page table are maintained within the virtual segment.  If
 3490           SEGSIZE is less than or equal to 2 megawords, then the
 3491           size of PHYSICAL can be less than or equal to SEGSIZE.
 3492           If SEGSIZE is greater than 2 megawords, then PHYSICAL
 3493           will be limited to a maximum of 256K.  Above 2 megawords,
 3494           the page table is fragmented.  Fragmented page tables are
 3495           limited to a maximum of 256 real pages mapped in memory
 3496           at any time.
 3497           */
 3498
 3499            2 PHYSICAL# UBIN HALF HALIGNED %INIT(PHYSICAL)%CHARTEXT('/**/'),
 3500                          /*K* PHYSICAL = VALUE-DEC(1-16384).
 3501                          Specifies the number of physical pages
 3502                backing the virtual area. This parameter determines how many pages
 3503                are held within memory at any given time. The parameter has a great
 3504                effect on the access speed of the virtual segment. (See SEGSIZE
 3505                for additional restrictions on the size of PHYSICAL.)  The
 3506                default is ten pages. If the value specified is less than four,
 3507                a value of four is assumed.
 3508                */
 3509            2 MINPHYS# UBIN HALF HALIGNED %INIT(MINPHYS)%CHARTEXT('/**/'),
 3510                          /*K* MINPHYS = VALUE-DEC(1-16384).
 3511                          Specifies the minimum number of physical pages
 3512       backing the virtual area. This parameter determines the least number of pages
 3513       that are held within memory at any given time. The parameter has a great
 3514       effect on the access speed of the virtual segment. The default
 3515       is ten pages. If the value specified is less than four, a value of
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            96   
 3516       four is assumed.
 3517       */
 3518
 3519            2 PTR$ PTR ALIGNED %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 3520           /*K* PTR$=POINTER. is returned on successful open with a pointer to the
 3521           segment that was used for this large virtual area. It should
 3522           be used on all references to the area.
 3523            */
 3524            2 READS# UBIN ALIGNED %INIT(0)%CHARTEXT('/**/'),
 3525                          /*K* READS = VALUE-DEC(0-2**32-1)  This contains the
 3526                          number of file reads which have been
 3527                          done for a virtual segment.
 3528                          This will be returned on an M$VIRTUAL monitor
 3529                          service requesting information about the segment.
 3530                          */
 3531            2 WRITES# UBIN ALIGNED %INIT(0)%CHARTEXT('/**/'),
 3532                          /*K* WRITES = VALUE-DEC(0-2**32-1)  This contains the
 3533                          number of file writes which have been
 3534                          done for a virtual segment.
 3535                          This will be returned on an M$VIRTUAL monitor service
 3536                          requesting information about the segment.
 3537                          */
 3538            2 FAULTS# UBIN ALIGNED %INIT(0)%CHARTEXT('/**/'),
 3539                          /*K* FAULTS = VALUE-DEC(0-2**32-1)  This contains the
 3540                          number of missing page faults for a virtual segment.
 3541                          This will be returned on an M$VIRTUAL monitor service
 3542                          requesting information about the segment.
 3543                          */
 3544            2 CURPGS# UBIN ALIGNED %INIT(0)%CHARTEXT('/**/'),
 3545                     /*K* CURPGS = VALUE-DEC(0-size of PHYSICAL)  This contains the
 3546                     current number of memory pages used for a virtual
 3547                     segment.  This will be returned on an M$VIRTUAL monitor
 3548                     service requesting information about the segment.
 3549                     */
 3550            2 MAXPGS# UBIN ALIGNED %INIT(0)%CHARTEXT('/**/'),
 3551                          /*K* MAXPGS = VALUE-DEC(0-size of PHYSICAL)  This
 3552                          contains the maximum number of memory pages
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            97   
 3553                          which have been used for a virtual
 3554                          segment.  This will be returned on an M$VIRTUAL monitor
 3555                          service requesting information about the segment.
 3556                          */
 3557            2 TRUNCS# UBIN ALIGNED %INIT(0)%CHARTEXT('/**/'),
 3558                          /*K* TRUNCS = VALUE-DEC(0-2**32-1)  This contains the
 3559                          number of truncates which have been
 3560                          done for a virtual segment.
 3561                          This will be returned on an M$VIRTUAL monitor
 3562                          service requesting information about the segment.
 3563                          */
 3564            2 * UBIN %INIT(0)%CHARTEXT('/**/');
 3565      %MEND;
 3566                          /*F*  NAME:  VLP_RECFIELD
 3567
 3568                                The VLP_RECFIELD macro creates an area
 3569                                describing the physical definitions of
 3570                                fields in consecutive, relative, keyed,
 3571                                indexed, and IREL files.
 3572
 3573                                VLP_RECFIELD may only be specified on a
 3574                                create open of a file and a close of a
 3575                                non-IREL file.  File management will make
 3576                                this information available by placing it
 3577                                in CODE18 of the File Information Table
 3578                                (FIT).  It will also be available in the
 3579                                read-only segment when the file is open.
 3580                                When such a file is open, F$DCB.FIELDX
 3581                                will contain the word offset from the
 3582                                start of the read-only segment to the
 3583                                beginning of a VLP_RECFIELD structure.
 3584                                If F$DCB.FIELDX is zero, there are no
 3585                                field descriptions for the file.
 3586
 3587                                The VLP_RECFIELD structure contains three
 3588                                basic elements:  an identifier field,
 3589                                VLP_RECFIELD.VLPID#; an area containing
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            98   
 3590                                field descriptions, VLP_RECFIELD.FIELD or
 3591                                VLP_RECFIELD.DECFIELD; and a count of the
 3592                                number of elements in the field area,
 3593                                VLP_RECFIELD.NFIELDS#.
 3594
 3595                                VLP_RECFIELD.VLPID# is an identifier field
 3596                                which allows VLP_RECFIELD to be
 3597                                distinguished from other VLPs which could
 3598                                be specified in the same vector location
 3599                                in an FPT_OPEN or FPT_CLOSE.  This field
 3600                                must always contain a value of 511.  If
 3601                                the storage class specified for VLP_RECFIELD
 3602                                permits initialization, VLP_RECFIELD.VLPID#
 3603                                will be initialized to 511 automatically
 3604                                when the macro is invoked.  Otherwise, the
 3605                                user must ensure that VLP_RECFIELD.VLPID#
 3606                                is set to 511 prior to its use in a call
 3607                                to M$OPEN or M$CLOSE.  If the default
 3608                                storage class of STATIC is used, this field
 3609                                will be automatically initialized to 511.
 3610
 3611                                The VLP_RECFIELD field array
 3612                                (VLP_RECFIELD.FIELD or
 3613                                VLP_RECFIELD.DECFIELD) actually describes
 3614                                the fields in a record.  In most cases, each
 3615                                element of the field array describes a
 3616                                separate field in the record.  However, it
 3617                                is possible to define a field to be a
 3618                                single dimension array or list (data type
 3619                                LIST or VLIST).  Any field defined as a list
 3620                                requires two contiguous elements in the
 3621                                field array; one to define the field as a
 3622                                list and one to describe the list elements.
 3623                                Field descriptions are described in more
 3624                                detail below.
 3625
 3626                                VLP_RECFIELD.NFIELDS# contains the number
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            99   
 3627                                of elements in the VLP_RECFIELD field array.
 3628                                Note that fields defined as lists (data type
 3629                                LIST or VLIST) require two elements in the
 3630                                field array.  A maximum of 511 elements may
 3631                                be specified.  The N parameter may be used
 3632                                to initialize this value.
 3633
 3634                                The order in which fields are specified in
 3635                                VLP_RECFIELD must
 3636                                exactly match the physical order of fields
 3637                                in the record.  There is no mechanism for
 3638                                redefining fields.
 3639
 3640                                Each VLP_RECFIELD element
 3641                                must be assigned values for data type,
 3642                                length, and possibly scale factor.
 3643                                Certain data types have particular
 3644                                restrictions; to ensure their correctness,
 3645                                field lengths, types, and scale will be
 3646                                verified whenever a VLP_RECFIELD area is
 3647                                specified.
 3648                                ..::IT "Rules for VLP_RECFIELD\RULES"
 3649                                Both decimal and non-decimal data types may
 3650                                be specified.  Conventions for specifying
 3651                                decimal and non-decimal data are as follows:
 3652
 3653                                .inl 4
 3654                                .unl 4
 3655                                o   Decimal data types require
 3656                                specification of data type, length, and
 3657                                scale.
 3658                                .inl 0
 3659                                .inl 8
 3660                                .unl 4
 3661                                o   Decimal data types are as follows:  PDLA,
 3662                                PDTA, PDLE, PDTE, PDNS, PDFLT, UDNS, UDLO,
 3663                                UDTO, UDLS, UDTS, UDFLT, DATE, and TIME.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            100  
 3664                                .unl 4
 3665                                o   Lengths are in nibbles for packed
 3666                                decimal and in bytes for unpacked decimal.
 3667                                .unl 4
 3668                                o   The scale factor indicates the
 3669                                position of the decimal point for scaled
 3670                                decimal numbers.  A value of zero places
 3671                                the decimal point to the right of the least
 3672                                significant digit.  Positive values move the
 3673                                decimal point to the left, while negative
 3674                                values move it to the right.
 3675
 3676                                .inl 0
 3677                                .inl 4
 3678                                .unl 4
 3679                                o   Non-decimal data types require
 3680                                specification of data type and length.
 3681                                .inl 0
 3682                                .inl 8
 3683                                .unl 4
 3684                                o   Non-decimal data types include the
 3685                                following:  NO, CHAR, TEXTC, TEXTH, SBIN,
 3686                                UBIN, UTS, SFLT, DFLT, LIST, and
 3687                                VLIST.
 3688                                .unl 4
 3689                                o   Lengths are in bits for SBIN, UBIN, and
 3690                                UTS data types.  Lengths are in bytes for
 3691                                NO, CHAR, SFLT, and DFLT data types.
 3692                                Lengths for TEXTC and TEXTH data types are
 3693                                not known until a record is actually read
 3694                                or written and are therefore ignored at
 3695                                initialization.
 3696                                .unl 4
 3697                                o   A field of type LIST or VLIST
 3698                                defines an array of elements of another
 3699                                data type.
 3700                                .unl 4
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            101  
 3701                                o   The length
 3702                                of a VLP_RECFIELD element of type LIST
 3703                                indicates the number of elements in the
 3704                                list.
 3705                                .unl 4
 3706                                o   The length of a VLP_RECFIELD
 3707                                element of type VLIST specifies an
 3708                                index into the VLP_RECFIELD field array of
 3709                                a count field which will contain the number
 3710                                of elements in the list.  The count field
 3711                                must precede the VLIST field, may not
 3712                                have a data type of NO, DATE, TIME, UTS,
 3713                                LIST, or VLIST, and may not be a
 3714                                LIST or VLIST element.
 3715                                .unl 4
 3716                                o   The VLP_RECFIELD element which
 3717                                immediately follows an element of type LIST
 3718                                or VLIST defines the characteristics of
 3719                                the list elements.
 3720                                .unl 4
 3721                                o   A field of type LIST
 3722                                or VLIST may not contain elements of
 3723                                type LIST, VLIST, TEXTC, or TEXTH.
 3724                                .inl 0
 3725
 3726                                Legal data types and their requirements are
 3727                                described in the following table.
 3728       ..::TB "Legal Data Types and Requirements for VLP_RECFIELD\ Data Type            \#3\Alignment\#3\    Length        \#3\ Scale    "
 3729       }NO,CHAR            #byte  #1-4095 bytes     #^^^N/A
 3730       }TEXTC,TEXTH        #byte  #N/A              #^^^N/A
 3731       }SBIN,UBIN          #bit   #1-36 bits        #^^^N/A
 3732       }UTS                #byte  #36 bits          #^^^N/A
 3733       }SFLT               #byte  #4 bytes          #^^^N/A
 3734       }DFLT               #byte  #8 bytes          #^^^N/A
 3735       }PDLA,PDTA,PDLE,PDTE#nibble#2-63 nibbles     #-32 - +31
 3736       }PDNS               #nibble#1-63 nibbles     #-32 - +31
 3737       }DATE,TIME          #byte  #16 nibbles       #^^^^0
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            102  
 3738       }PDFLT              #nibble#4-63 nibbles     #-32 - +31
 3739       }UDNS,UDLO,UDTO     #byte  #1-63 bytes       #-32 - +31
 3740       }UDLS,UDTS          #byte  #2-63 bytes       #-32 - +31
 3741       }UDFLT              #byte  #3-63 bytes       #-32 - +31
 3742       }LIST               #varies#1-4095 elements  #^^^N/A
 3743       }VLIST              #varies#count field index#^^^N/A
 3744       ..::TB
 3745       ..::IT "IREL Files and VLP_RECFIELD\IREL_FILES"
 3746       On M$WRITEs to an IREL disk
 3747       file, any decimal fields which are used in
 3748       keys will be validated to ensure that they
 3749       contain legal values.  Note that data types
 3750       NO, TEXTC, TEXTH, LIST, and VLIST
 3751       may not be used in a key definition for an
 3752       IREL file.  Any element of the VLP_RECFIELD field
 3753       array which is defined to be a LIST
 3754       or VLIST element may not be used in a
 3755       key definition for an IREL file.  Also, any
 3756       field following a TEXTC, TEXTH, or VLIST
 3757       field may not be used in a key definition
 3758       for an IREL file.  SBIN and UBIN fields may
 3759       be used in key definitions for an IREL file
 3760       only if they begin and end on byte
 3761       boundaries.
 3762       ..::IT "Examples of VLP_RECFIELD Usage\EXAMPLES"
 3763       Macro Initialization
 3764       .spf 1
 3765       Since the VLP_RECFIELD field array is
 3766       interpreted differently for decimal and
 3767       non-decimal data types, it may be necessary
 3768       to invoke the macro several times in order
 3769       to correctly initialize the field elements.
 3770       However, if all field elements are identical,
 3771       only one macro invocation is required.
 3772
 3773       Example 1
 3774       .spf 1
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            103  
 3775       A single invocation of the macro will cause the
 3776       field definitions to be declared in array form
 3777       and initialized appropriately.  That is, the
 3778       VLP_RECFIELD.FIELD and VLP_RECFIELD.DECFIELD
 3779       arrays will be declared in the structure.
 3780
 3781       For instance, to initialize a structure
 3782       containing 10 fields of type CHAR and length 20:
 3783
 3784       .fif
 3785       }%VLP_RECFIELD(FPTN=RECFIELD,STCLASS=STATIC,
 3786       }              N=10,DTYPE=CHAR,LEN=20,
 3787       }              FIRST=YES,LAST=YES);
 3788       .fin
 3789
 3790       In this example, the VLP_RECFIELD.FIELD array
 3791       is declared such that field elements 0 through 9
 3792       are initialized as character fields of length 20.
 3793       The VLP_RECFIELD.DECFIELD array will redefine
 3794       the VLP_RECFIELD.FIELD array, should the user
 3795       wish to alter one or more field definitions at
 3796       run time.  Example 3 describes how to view or
 3797       alter field elements at run time.
 3798
 3799       Example 2
 3800       .spf 1
 3801       Multiple invocations of the macro must be used
 3802       to initialize a structure containing a variety
 3803       of data types.  In such a structure, the field
 3804       definitions will not be declared in array form
 3805       since field elements must be declared
 3806       individually.
 3807
 3808       Initializing such a structure requires one macro
 3809       invocation to produce the structure header
 3810       including its name, storage class, and the
 3811       total number of elements that the VLP_RECFIELD
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            104  
 3812       field area will contain.
 3813       Subsequent invocations are required to
 3814       produce individual field elements and must
 3815       declare the same STCLASS as the first for
 3816       purposes of initialization. Note that
 3817       the value of N in the first invocation
 3818       declares the total number of elements in the
 3819       VLP_RECFIELD field area, but N in a subsequent
 3820       invocation defines only the number of
 3821       elements for that individual invocation.
 3822       Hence, the sum of all the Ns in
 3823       subsequent invocations must equal the
 3824       N specified in the first, or header,
 3825       invocation.
 3826
 3827       If the user wishes to view or alter field
 3828       elements of such a structure at run time, it is
 3829       necessary to invoke one additional version of
 3830       the macro which redefines or points to the
 3831       full original structure.  This single, additional
 3832       macro invocation will declare the
 3833       VLP_RECFIELD.FIELD and VLP_RECFIELD.DECFIELD
 3834       arrays.  The user can then use the second
 3835       redefined or based structure to view individual
 3836       field elements at run time via the appropriate
 3837       array.  Example 3 describes how to view or alter
 3838       field elements at run time.
 3839
 3840       For instance, to initialize a structure
 3841       containing two fields of type DATE, one field
 3842       of type VLIST containing elements of type CHAR
 3843       and length 20, and one field of type UBIN and
 3844       length 36 as the count field for the VLIST field:
 3845
 3846       .fif
 3847       }%VLP_RECFIELD(FPTN=RECFIELD,
 3848       }              STCLASS=CONSTANT,N=5,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            105  
 3849       }              FIRST=YES,LAST=NO);
 3850       }%VLP_RECFIELD(STCLASS=CONSTANT,
 3851       }              N=2,DTYPE=DATE,LEN=16,
 3852       }              SCALE=0,FIRST=NO,LAST=NO);
 3853       }%VLP_RECFIELD(STCLASS=CONSTANT,
 3854       }              N=1,DTYPE=UBIN,LEN=36,
 3855       }              FIRST=NO,LAST=NO);
 3856       }%VLP_RECFIELD(STCLASS=CONSTANT,
 3857       }              N=1,DTYPE=VLIST,LEN=2,
 3858       }              FIRST=NO,LAST=NO);
 3859       }%VLP_RECFIELD(STCLASS=CONSTANT,
 3860       }              N=1,DTYPE=CHAR,LEN=20,
 3861       }              FIRST=NO,LAST=YES);
 3862
 3863       and, optionally:
 3864
 3865       }%VLP_RECFIELD(FPTN=RECFIELD2,
 3866       STCLASS="REDEF RECFIELD",
 3867       N=5,FIRST=YES,LAST=YES);
 3868       .fin
 3869
 3870       Run Time Initialization or Viewing
 3871       .spf 1
 3872       Example 3
 3873       .spf 1
 3874       A user may wish to set or view VLP_RECFIELD
 3875       values at times other than initialization. Since
 3876       the VLP_RECFIELD field array is interpreted
 3877       differently depending upon data type, the
 3878       user must refer to an element in either the
 3879       VLP_RECFIELD.FIELD array (non-decimal) or
 3880       the VLP_RECFIELD.DECFIELD array (decimal).
 3881
 3882       For instance, field definitions could be
 3883       referenced at run time in the following fashion:
 3884
 3885       .fif
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            106  
 3886       }%VLP_RECFIELD(FPTN=VLP_RECFIELD,
 3887       }              STCLASS="BASED(FIELD$)");
 3888       .fin
 3889
 3890       For non-decimal data types, the
 3891       VLP_RECFIELD.FIELD array should be used to
 3892       specify or view lengths and data types.  Equates
 3893       for data type values may be found in the
 3894       VREBL_DATATYPES macro in the B$OBJECT_C
 3895       include file in the library account.  E.g.,
 3896       to define an element as UBIN(18), set
 3897       VLP_RECFIELD.FIELD.TYPE#(i) to %UBIN_DATATYPE
 3898       and VLP_RECFIELD.FIELD.LEN#(i) to 18.
 3899
 3900       For decimal data types, the
 3901       VLP_RECFIELD.DECFIELD array should be used to
 3902       specify or view data type, length, and scale.
 3903       E.g., to define an element as DATE, set
 3904       VLP_RECFIELD.DECFIELD.TYPE#(i) to
 3905       %DATE_DATATYPE,
 3906       VLP_RECFIELD.DECFIELD.LEN#(i) to 16, and
 3907       VLP_RECFIELD.DECFIELD.SCALE#(i) to 0.
 3908       ..::IT "Field Starting Positions\FIELD_STARTS"
 3909       During the open of a file which contains
 3910       field definitions, the starting position
 3911       of each field or list
 3912       element is computed by file management
 3913       from the data type and length
 3914       specified.  Since certain data
 3915       types must have particular alignments,
 3916       file management will assume that slack bits
 3917       exist between two fields if the second
 3918       field would otherwise begin on an illegal
 3919       boundary.  Hence, slack bits do not need
 3920       to be included in field definitions.
 3921       However, the user is advised to be careful
 3922       when considering alignment requirements.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            107  
 3923
 3924       The calculated starting positions will be
 3925       made available in the read-only segment
 3926       when the file is open.  F$DCB.STARTX will
 3927       contain the word offset from the start of
 3928       the read-only segment to the beginning of
 3929       this area.  The FM$FIELD_START macro,
 3930       contained in the file FM_FIELD_C.:LIBRARY,
 3931       may be used to access this information.
 3932       If F$DCB.STARTX is zero, there are no
 3933       starting positions available in the
 3934       read-only segment.  This will only be true
 3935       when there are no field descriptions for
 3936       the file.
 3937
 3938       Each element in the FM$FIELD_START.OFFSET
 3939       array contains the bit offset of a field
 3940       from the beginning of a record.  The index
 3941       into this array for any field is
 3942       the same as its index in the VLP_RECFIELD
 3943       field array.  When calculating starting
 3944       positions for fields of type LIST or VLIST,
 3945       the alignment rules for the list element
 3946       will be used.  The starting position for a
 3947       list element will be identical to the
 3948       starting position of the list field.  E.g,
 3949       if VLP_RECFIELD.FIELD(i) defines a list
 3950       (data type LIST or VLIST) and, subsequently,
 3951       VLP_RECFIELD.FIELD(i+1) describes the
 3952       characteristics of the list elements, then
 3953       FM$FIELD_START.OFFSET(i) will be identical
 3954       to FM$FIELD_START.OFFSET(i+1).
 3955
 3956       Note that actual starting positions for
 3957       fields which follow variable length fields
 3958       (data types TEXTC, TEXTH, and VLIST) cannot
 3959       be known until run time and, therefore,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            108  
 3960       only relative starting positions for these
 3961       fields will be reflected in the field start
 3962       array.  File management computes the
 3963       minimum length of a variable length
 3964       field and calculates the starting position
 3965       of all following fields accordingly.
 3966       A field of type TEXTC is assumed to have a
 3967       minimum length of 9 bits
 3968       since such a field must contain at least a
 3969       one byte count.  Similarly, a field of type
 3970       TEXTH is assumed to have a length of 18
 3971       bits, and a field of type VLIST is assumed
 3972       to have a length of zero since its count
 3973       field is defined separately.  It is the
 3974       responsibility of the user to compute
 3975       actual starting positions of fields which
 3976       follow a variable length field.
 3977       */
 3978      %MACRO VLP_RECFIELD (FPTN=VLP_RECFIELD,
 3979                           STCLASS=STATIC,
 3980                           %N=1,
 3981                           %DTYPE(NO=0,
 3982                                 SBIN=1,
 3983                                 SFLT=3,
 3984                                 DFLT=4,
 3985                                 PDLA=9,
 3986                                 PDFLT=10,
 3987                                 CHAR=21,
 3988                                 TEXTC=22,
 3989                                 UBIN=24,
 3990                                 PDTA=25,
 3991                                 PDTE=31,
 3992                                 PDNS=40,
 3993                                 UDNS=41,
 3994                                 UDLS=42,
 3995                                 UDTS=43,
 3996                                 UDLO=44,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            109  
 3997                                 UDTO=45,
 3998                                 LIST=47,
 3999                                 VLIST=48,
 4000                                 UDFLT=50,
 4001                                 PDLE=51,
 4002                                 DATE=54,
 4003                                 UTS=55,
 4004                                 TEXTH=56,
 4005                                 TIME=57)=0,
 4006                           LEN=0,
 4007                           SCALE=0,
 4008                           %LAST (YES='1'B,
 4009                                 NO ='0'B)='1'B,
 4010                           %FIRST(YES='1'B,
 4011                                 NO='0'B)='1'B);
 4012
 4013      /*!* VP Y */
 4014      %LSET LISTDIR='0'B;
 4015      %LSET LISTEXP='1'B;
 4016      %LSET LISTCOM='0'B;
 4017      %LSET LISTSUB='1'B;
 4018      /*!* VP N */
 4019      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4020      %IF (SUBSTR(STR,0,6)='STATIC')   OR
 4021          (SUBSTR(STR,0,8)='CONSTANT') OR
 4022          (SUBSTR(STR,0,3)='EXT');
 4023      %LSET INIT=CHARTEXT('INIT');
 4024      %ELSE;
 4025      %LSET INIT=CHARTEXT('/*');
 4026      %ENDIF;
 4027
 4028      /*!* VP Y */
 4029      %IF FIRST;
 4030      DCL 1 FPTN STCLASS DALIGNED,
 4031            2 VLPID#   UBIN(9)  CALIGNED %INIT(511)%CHARTEXT('/**/'),
 4032            2 NFIELDS# UBIN(27) CALIGNED %INIT(N)%CHARTEXT('/**/'),
 4033                          /*K* N = VALUE-DEC(1-511).
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            110  
 4034                          Specifies the total number of elements in the
 4035                          VLP_RECFIELD field array if VLP_RECFIELD is
 4036                          invoked only once to define one or more identical
 4037                          fields, or if VLP_RECFIELD is invoked to create
 4038                          a header for subsequent VLP_RECFIELD invocations
 4039                          (FIRST=YES).  If specified in a subsequent
 4040                          VLP_RECFIELD invocation (FIRST=NO), it determines
 4041                          only the number of elements defined in the
 4042                          individual invocation.  Note that a field of type
 4043                          LIST or VLIST requires two elements in the field
 4044                          array.  All other field types require only one.
 4045                          The default is 1.                                       */
 4046      %IF LAST;
 4047      %IF DTYPE= 9 OR DTYPE=10 OR DTYPE=25 OR DTYPE=31 OR DTYPE=40 OR
 4048          DTYPE=41 OR DTYPE=42 OR DTYPE=43 OR DTYPE=44 OR DTYPE=45 OR
 4049          DTYPE=50 OR DTYPE=51 OR DTYPE=54 OR DTYPE=57;
 4050
 4051              2 DECFIELD(0:%(N-1)),
 4052
 4053                3 TYPE# UBIN(6) UNAL %INIT(DTYPE*0)%CHARTEXT('/**/'),
 4054                          /*K* DTYPE = VALUE-DEC(0-63).
 4055                          Specifies the data type of the field or list
 4056                          element.  Data types supported by file management
 4057                          are:
 4058
 4059                               .inl 9
 4060                               .unl 9
 4061                               NO     - No data type
 4062                               .unl 9
 4063                               SBIN   - Signed binary
 4064                               .unl 9
 4065                               UBIN   - Unsigned binary
 4066                               .unl 9
 4067                               UTS    - Universal time stamp.  Count of an
 4068                                        interval of time in 1/100 seconds.
 4069                                        Length is 36 bits.  Must be byte
 4070                                        aligned.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            111  
 4071                               .unl 9
 4072                               SFLT   - Real binary single precision
 4073                                        floating point
 4074                               .unl 9
 4075                               DFLT   - Real binary double precision
 4076                                        floating point
 4077                               .unl 9
 4078                               PDLA   - Packed decimal, leading ASCII sign
 4079                               .unl 9
 4080                               PDTA   - Packed decimal, trailing ASCII sign
 4081                               .unl 9
 4082                               PDLE   - Packed decimal, leading EBCDIC sign
 4083                               .unl 9
 4084                               PDTE   - Packed decimal, trailing EBCDIC sign
 4085                               .unl 9
 4086                               PDNS   - Packed decimal, no sign
 4087                               .unl 9
 4088                               PDFLT  - Packed decimal, floating point
 4089                               .unl 9
 4090                               DATE   - Packed decimal, leading ASCII sign.
 4091                                        Count of the number of 1/100
 4092                                        seconds since A.D. January 1, 1.
 4093                                        Length is 16 nibbles including sign.
 4094                                        Must be byte aligned.
 4095                               .unl 9
 4096                               TIME   - Packed decimal, leading ASCII sign.
 4097                                        Count of an interval of time in
 4098                                        1/100 seconds.  Length is 16 nibbles
 4099                                        including sign.  Must be byte
 4100                                        aligned.
 4101                               .unl 9
 4102                               UDNS   - Unpacked decimal, no sign
 4103                               .unl 9
 4104                               UDLS   - Unpacked decimal, leading sign
 4105                               .unl 9
 4106                               UDTS   - Unpacked decimal, trailing sign
 4107                               .unl 9
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            112  
 4108                               UDLO   - Unpacked decimal, leading
 4109                                        overpunched sign
 4110                               .unl 9
 4111                               UDTO   - Unpacked decimal, trailing
 4112                                        overpunched sign
 4113                               .unl 9
 4114                               UDFLT  - Unpacked decimal, floating point
 4115                               .unl 9
 4116                               CHAR   - Fixed length character string
 4117                               .unl 9
 4118                               TEXTC  - Character varying preceded by a
 4119                                        byte character count
 4120                               .unl 9
 4121                               TEXTH  - Character varying preceded by a
 4122                                        half-word character count
 4123                               .unl 9
 4124                               LIST   - Single dimension array of elements
 4125                                        of another data type.  Length
 4126                                        specifies the number of array
 4127                                        elements.  List elements are defined
 4128                                        by the VLP_RECFIELD element which
 4129                                        immediately follows.
 4130                               .unl 9
 4131                               VLIST  - Single dimension array of elements
 4132                                        of another data type, where the
 4133                                        number of array elements varies.
 4134                                        Length specifies the index into the
 4135                                        VLP_RECFIELD field array of a count
 4136                                        field which will contain the number
 4137                                        of elements in the array for a
 4138                                        given record.  List elements are
 4139                                        defined by the VLP_RECFIELD element
 4140                                        which immediately follows.
 4141                               .inl 0
 4142
 4143                          %EQUs for these values may be found in the
 4144                          VREBL_DATATYPES macro in the B$OBJECT_C include
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            113  
 4145                          file in the library account.  They have the form
 4146                          %type_DATATYPE.
 4147
 4148                          Descriptions of most of the various data types
 4149                          may be found in the DPS 8 Assembly Instructions
 4150                          manual (DH03).
 4151
 4152                          The overpunched sign data types are a special
 4153                          case of unpacked decimal.  The sign and leading
 4154                          or trailing digits are combined into a single
 4155                          character.  The character '{' represents '+0'.
 4156                          The character '}' represents '-0'.  The
 4157                          characters 'A' through 'I' represent the numbers
 4158                          1 through 9 with a '+' sign.  The characters 'J'
 4159                          through 'R' represent the numbers 1 through 9 with
 4160                          a '-' sign.
 4161
 4162                          For packed decimal data types, octal 13
 4163                          represents the ASCII plus sign and
 4164                          octal 14 represents the EBCDIC plus sign.
 4165                          Any value from octal 12 through 17
 4166                          will be accepted for the sign, with octal
 4167                          15 representing a minus sign, and all
 4168                          other values representing a plus sign.
 4169
 4170                          The default for DTYPE is 0.                             */
 4171
 4172                3 LEN# UBIN(6) UNAL %INIT(LEN*0)%CHARTEXT('/**/'),
 4173                          /*K* LEN = VALUE-DEC(1-4095).
 4174                          Specifies the length of the field.  Legal length
 4175                          values range from 1-63 for decimal data types and
 4176                          from 1-4095 for non-decimal data types.  However,
 4177                          certain data types have specific length
 4178                          restrictions.  Please see the table
 4179                          "Legal Data Types and Requirements for VLP_RECFIELD"
 4180                          for a summary of this information.
 4181                          The default is 0.                                       */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            114  
 4182
 4183                3 SCALE# SBIN(6) UNAL %INIT(SCALE*0)%CHARTEXT('/**/'),
 4184                          /*K* SCALE = VALUE-DEC(-32 - +31).
 4185                          Specifies the scale factor for a decimal data
 4186                          type.  Ignored for non-decimal data types.
 4187                          The default is 0.                                       */
 4188                2 FIELD(0:%(N-1)) REDEF DECFIELD,
 4189                3 TYPE# UBIN(6) UNAL,
 4190                3 LEN# UBIN(12) UNAL;
 4191
 4192      %ELSE;
 4193            2 FIELD(0:%(N-1)),
 4194              3 TYPE#  UBIN(6)  UNAL %INIT(DTYPE*0)%CHARTEXT('/**/'),
 4195              3 LEN#   UBIN(12) UNAL %INIT(LEN*0)%CHARTEXT('/**/'),
 4196            2 DECFIELD(0:%(N-1)) REDEF FIELD,
 4197              3 TYPE#  UBIN(6)  UNAL,
 4198              3 LEN#   UBIN(6)  UNAL,
 4199              3 SCALE# SBIN(6)  UNAL;
 4200      %ENDIF;
 4201      %ENDIF;
 4202      %ELSE;
 4203      %IF N > 1;
 4204            2 * (0:%(N-1)),
 4205      %ELSE;
 4206            2 * ,
 4207      %ENDIF;
 4208              3 *      UBIN(6)  UNAL %INIT(DTYPE*0)%CHARTEXT('/* Type */'),
 4209      %IF LAST;
 4210      %LSET LAST_CHAR = CHARTEXT(';');
 4211      %ELSE;
 4212      %LSET LAST_CHAR = CHARTEXT(',');
 4213      %ENDIF;
 4214      %IF DTYPE= 9 OR DTYPE=10 OR DTYPE=25 OR DTYPE=31 OR DTYPE=40 OR
 4215          DTYPE=41 OR DTYPE=42 OR DTYPE=43 OR DTYPE=44 OR DTYPE=45 OR
 4216          DTYPE=50 OR DTYPE=51 OR DTYPE=54 OR DTYPE=57;
 4217              3 *      UBIN(6)  UNAL %INIT(LEN*0)%CHARTEXT('/* Len */'),
 4218                3 *    SBIN(6)  UNAL %INIT(SCALE*0)%CHARTEXT('/* Scale */') %LAST_CHAR
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            115  
 4219      %ELSE;
 4220                3 *    UBIN(12) UNAL %INIT(LEN*0)%CHARTEXT('/* Len */') %LAST_CHAR
 4221      %ENDIF;
 4222      %ENDIF;
 4223      /*!* VP N */
 4224                          /*K* FIRST = {YES|NO}.
 4225                          Yes specifies that the header portion of the
 4226                          structure is to be created and
 4227                          VLP_RECFIELD.NFIELDS# is to be initialized.
 4228                          I.e., this is the first invocation of the
 4229                          macro.  No specifies that no header is to be
 4230                          generated. I.e., this is a secondary invocation
 4231                          of the macro.  The default is YES.                      */
 4232
 4233                          /*K* LAST = {YES|NO}.
 4234                          Yes specifies that this is the last invocation
 4235                          of the macro and the structure is complete.  No
 4236                          specifies that this is not the last invocation
 4237                          of the macro.  The default is YES.                      */
 4238      %MEND;
 4239
 4240                          /*F*  NAME:  VLP_IRREC
 4241
 4242                          The VLP_IRREC macro creates an area describing
 4243                          the logical order of record fields in consecutive,
 4244                          relative, keyed, indexed, and IREL files.  This
 4245                          information exists for use by processors and/or
 4246                          user programs.
 4247
 4248                          VLP_IRREC.NFIELDS# contains the number of entries
 4249                          in the VLP_IRREC.FIELDN# array.  The N
 4250                          parameter may be used to initialize this value.
 4251                          The maximum number of entries is 511.  However,
 4252                          the number of entries specified in a
 4253                          VLP_IRREC.FIELDN# array must be less than or
 4254                          equal to the total number of entries specified in
 4255                          the corresponding VLP_RECFIELD field array.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            116  
 4256
 4257                          Each element in a VLP_IRREC.FIELDN# array contains
 4258                          an index into the corresponding VLP_RECFIELD field
 4259                          array.  This index may not indicate a VLP_RECFIELD
 4260                          entry which
 4261                          is defined to be an element of either a fixed
 4262                          or variable length list.  Note that the order
 4263                          in which fields are indicated in VLP_IRREC is
 4264                          totally independent of their order in
 4265                          VLP_RECFIELD.
 4266
 4267                          VLP_IRREC may only be specified on a create open
 4268                          or close of a file.  Note, however, that a
 4269                          VLP_IRREC specified on a close of an Indexed
 4270                          Relational (IREL) file will only be used if there
 4271                          is no VLP_RECFIELD also specified on the close.
 4272
 4273                          File
 4274                          management will make this information available by
 4275                          placing it in CODE21 of the File Information Table
 4276                          (FIT).  It will also be available in the read-only
 4277                          segment when the file is open.  When a file is
 4278                          open, F$DCB.IRRECX will contain the word offset
 4279                          from the start of the read-only segment to the
 4280                          beginning of a VLP_IRREC area.  If F$DCB.IRRECX
 4281                          is zero, no logical field descriptions exist for
 4282                          the file.
 4283
 4284                          NOTE: VLP_IRREC contains an identifier field
 4285                          which allows it to be distinguished from other
 4286                          VLP's which could be specified in the same vector
 4287                          location in an FPT_OPEN or FPT_CLOSE.  This
 4288                          identifier field, VLP_IRREC.VLPID#, must always
 4289                          be set to a decimal value of 511.  If the
 4290                          storage class specified for VLP_IRREC permits
 4291                          initialization, VLP_IRREC.VLPID# will be
 4292                          initialized to 511 automatically when the macro
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            117  
 4293                          is invoked.  Otherwise, the user must ensure that
 4294                          VLP_IRREC.VLPID# is set to 511 prior to its use
 4295                          in a call to M$OPEN or M$CLOSE.  If the default
 4296                          storage class of STATIC is used, this field will
 4297                          be automatically initialized to 511.
 4298                          */
 4299      %MACRO VLP_IRREC (FPTN=VLP_IRREC,
 4300                        STCLASS=STATIC,
 4301                        %N=1,
 4302                        FIELDN=0);
 4303
 4304      %LSET LISTDIR='0'B;
 4305      %LSET LISTEXP='1'B;
 4306      %LSET LISTCOM='0'B;
 4307      %LSET LISTSUB='1'B;
 4308      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4309      %IF (SUBSTR(STR,0,6)='STATIC')   OR
 4310          (SUBSTR(STR,0,8)='CONSTANT') OR
 4311          (SUBSTR(STR,0,3)='EXT');
 4312      %LSET INIT=CHARTEXT('INIT');
 4313      %ELSE;
 4314      %LSET INIT=CHARTEXT('/*');
 4315      %ENDIF;
 4316
 4317      DCL 1 FPTN STCLASS DALIGNED,
 4318            2 VLPID#            UBIN(9)  CALIGNED %INIT(511)%CHARTEXT('/**/'),
 4319            2 NFIELDS#          UBIN(27) CALIGNED %INIT(N)%CHARTEXT('/**/'),
 4320                          /*K* N = VALUE-DEC(0-511).
 4321                          Specifies the number of entries in the
 4322                          VLP_IRREC.FIELDN# array.  The default is 1.
 4323                          */
 4324            2 FIELDN#(0:%(N-1)) UBIN(9)  CALIGNED %INIT(FIELDN*0)%CHARTEXT('/**/');
 4325                          /*K* FIELDN = VALUE-DEC(0-511).
 4326                          Specifies an index into the corresponding
 4327                          VLP_RECFIELD field array.  Note that all elements
 4328                          of the VLP_IRREC.FIELDN# array will be initialized
 4329                          to this value.  Therefore, it will usually be
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            118  
 4330                          necessary to set the values for individual
 4331                          elements of the VLP_IRREC.FIELDN# array at run
 4332                          time.  The default is 0.
 4333                          */
 4334      %MEND;
 4335                          /*F*  NAME:  VLP_IRKEYS
 4336
 4337                                The VLP_IRKEYS macro creates an area
 4338                                describing keys for Indexed Relational
 4339                                (IREL) files.  VLP_IRKEYS may only be
 4340                                specified on a create open of an IREL file.
 4341
 4342                                File management will make this information
 4343                                available by placing it in CODE19 of the
 4344                                File Information Table (FIT).
 4345
 4346                                In order to specify keys in an IREL file,
 4347                                physical field definitions for a record in
 4348                                the file must be provided as well.  Hence,
 4349                                VLP_RECFIELD must also be specified
 4350                                on a create open of an IREL file.  See the
 4351                                description of VLP_RECFIELD for an
 4352                                explanation of physical field definitions.
 4353
 4354                                IREL files are a superset of alternate
 4355                                keyed files (INDEXED files specifying
 4356                                alternate keys).  There are two significant
 4357                                differences between these two file
 4358                                organizations.  Keys in IREL files are
 4359                                defined as a list of fields which may or
 4360                                may not be contiguous and which may be
 4361                                specified in any order.  Since fields
 4362                                have data types associated with them,
 4363                                keys are sorted by data type instead of
 4364                                utilizing the ASCII collating sequence.
 4365                                ..::IT "How to Define IREL Keys\DEFINING_IREL_KEYS"
 4366                                IREL keys are defined by specifying a list
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            119  
 4367                                of fields contained in the corresponding
 4368                                VLP_RECFIELD area.
 4369
 4370                                .inl 0
 4371                                .inl 4
 4372                                .unl 4
 4373                                o   The number of keys
 4374                                in a VLP_IRKEYS structure is determined by
 4375                                the value in VLP_IRKEYS.NKEYS#.  The NKEYS
 4376                                parameter may be used to initialize this
 4377                                value.  A maximum of 72 keys may be defined.
 4378                                .unl 4
 4379                                o   The fields which comprise the keys are
 4380                                specified in the VLP_IRKEYS.K array.  The
 4381                                N parameter may be used to initialize the
 4382                                number of fields in the VLP_IRKEYS.K array.
 4383                                .unl 4
 4384                                o   Elements of the VLP_IRKEYS.K array
 4385                                include:
 4386                                .inl 0
 4387                                .inl 8
 4388                                .unl 4
 4389                                o   An index into
 4390                                the VLP_RECFIELD field array, indicating
 4391                                a field which makes up a portion of the key.
 4392                                .unl 4
 4393                                o   Two flags:  UNIQUE and KEYEND.  The
 4394                                UNIQUE flag specifies whether or not a key
 4395                                is unique.  If a key is specified to be
 4396                                unique, duplicates are not allowed.  The
 4397                                UNIQUE flag of the first VLP_IRKEYS.K
 4398                                element in a key is used to determine
 4399                                whether a key is defined to be unique.  The
 4400                                KEYEND flag specifies whether or not a
 4401                                VLP_IRKEYS.K element is the last or end
 4402                                field of a key.
 4403                                .inl 0
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            120  
 4404                                .inl 4
 4405                                .unl 4
 4406                                o   The order in which fields are specified
 4407                                in the VLP_IRKEYS.K array indicates the
 4408                                order of those fields in the keys.
 4409                                .inl 0
 4410                                ..::IT "Hierarchy of Keys"
 4411                                The primary key definition must begin
 4412                                with the zeroth entry of the VLP_IRKEYS.K
 4413                                array and will extend through the first
 4414                                VLP_IRKEYS.K element which specifies
 4415                                KEYEND.  The primary key will always be
 4416                                considered unique.  Alternate keys may be
 4417                                defined following the primary key.  E.g.,
 4418                                a second key may begin at the first
 4419                                VLP_IRKEYS.K element immediately following
 4420                                the last element of the primary key and will
 4421                                extend through the next element which
 4422                                specifies KEYEND.  Subsequent keys may be
 4423                                defined in the same fashion.  The user may
 4424                                indicate that duplicates are allowed on any
 4425                                alternate key.
 4426                                ..::IT "Rules for IREL Keys\RULES"
 4427                                Rules for defining IREL keys are as follows:
 4428
 4429                                .inl 4
 4430                                .unl 4
 4431                                o   Fields with data types NO, TEXTC, TEXTH,
 4432                                LIST, and VLIST may not be used in key
 4433                                definitions.
 4434                                .unl 4
 4435                                o   A VLP_RECFIELD element which immediately
 4436                                follows an element of type LIST or VLIST
 4437                                in a VLP_RECFIELD field array may not be
 4438                                used in a key definition since it defines
 4439                                the list elements and is therefore part of
 4440                                the list field.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            121  
 4441                                .unl 4
 4442                                o   Any fields in a record which follow a
 4443                                variable length field (data types TEXTC,
 4444                                TEXTH, or VLIST) may not be used in key
 4445                                definitions.
 4446                                .unl 4
 4447                                o   An SBIN or UBIN field may be
 4448                                used in key definitions, but only if it
 4449                                begins and ends on a byte boundary; i.e,
 4450                                it begins on a byte boundary and has a bit
 4451                                length which is evenly divisible by 9.
 4452                                .unl 4
 4453                                o   Packed decimal fields may be used in key
 4454                                definitions, even if they begin on odd
 4455                                nibble boundaries.  However, care must be
 4456                                exercised when performing keyed operations
 4457                                in this case.  Although packed decimal
 4458                                fields which are contiguous in the record
 4459                                do not have slack bits between them, even
 4460                                if they begin or end on odd nibble
 4461                                boundaries, file management will place each
 4462                                such field on a byte boundary when forming
 4463                                and storing internal file keys.  Thus, if a
 4464                                key contains a field which has an odd number
 4465                                of nibbles, file management will insert a
 4466                                slack nibble at the end of the field in the
 4467                                file key to ensure that the next field
 4468                                placed in the file key begins on a byte
 4469                                boundary.
 4470
 4471                                For instance, assume there is a packed
 4472                                decimal field in the record which begins on
 4473                                an odd nibble boundary and has a length of
 4474                                3.  The portion of the record which contains
 4475                                this field looks like:
 4476
 4477                                .brn 5
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            122  
 4478                                .fif
 4479                                }bit# -> |0 1234 5678|0 1234 5678|
 4480                                }--------+-----------+-----------+------
 4481                                }. . . . |?!????!nib1|x!nib2!nib3| . . .
 4482                                }--------+-----------+-----------+------
 4483                                }           byte i     byte i+1
 4484
 4485                                .fin
 4486                                When placed in file management's internal
 4487                                key, this field will look like:
 4488
 4489                                .brn 5
 4490                                .fif
 4491                                }bit# -> |0 1234 5678|0 1234 5678|
 4492                                }--------+-----------+-----------+------
 4493                                }. . . . |x!nib1!nib2|x!nib3!xxxx| . . .
 4494                                }--------+-----------+-----------+------
 4495                                }           byte j     byte j+1
 4496                                .fin
 4497
 4498                                When a key is returned to the
 4499                                user (e.g., via M$READ), the key buffer
 4500                                contains a copy of the file key.
 4501                                Therefore, each field in the
 4502                                key buffer will begin on a byte boundary.
 4503                                Similarly, a user specifying a key
 4504                                containing packed decimal fields must ensure
 4505                                that each key field is correctly moved into
 4506                                the key buffer so that it begins on a byte
 4507                                boundary.  The correct size in bytes of a
 4508                                key buffer must be computed accordingly.
 4509                                .unl 4
 4510                                o   Any individual key definition may not exceed
 4511                                511 bytes in length, including necessary
 4512                                slack bits.
 4513                                .unl 4
 4514                                o   All key definitions must
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            123  
 4515                                be completely contained in the first 4000
 4516                                bytes of the record.
 4517                                .inl 0
 4518                          */
 4519      %MACRO VLP_IRKEYS (FPTN=VLP_IRKEYS,
 4520                         STCLASS=STATIC,
 4521                         NKEYS=1,
 4522                         %N=1,
 4523                         KEYEND(YES='1'B,NO='0'B)='0'B,
 4524                         UNIQUE(YES='1'B,NO='0'B)='0'B,
 4525                         FIELDN=0);
 4526
 4527      %LSET LISTDIR='0'B;
 4528      %LSET LISTEXP='1'B;
 4529      %LSET LISTCOM='0'B;
 4530      %LSET LISTSUB='1'B;
 4531      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4532      %IF (SUBSTR(STR,0,6)='STATIC')   OR
 4533          (SUBSTR(STR,0,8)='CONSTANT') OR
 4534          (SUBSTR(STR,0,3)='EXT');
 4535      %LSET INIT=CHARTEXT('INIT');
 4536      %ELSE;
 4537      %LSET INIT=CHARTEXT('/*');
 4538      %ENDIF;
 4539
 4540      DCL 1 FPTN STCLASS DALIGNED,
 4541            2 NKEYS# UBIN %INIT(NKEYS)%CHARTEXT('/**/'),
 4542                          /*K* NKEYS = VALUE-DEC(0-72).
 4543                               Specifies the number of keys defined in the
 4544                               structure.  The default is 1.
 4545                          */
 4546            2 K(0:%(N-1)),
 4547                          /*K* N = VALUE-DEC(0-n).
 4548                               Specifies the number of entries required in
 4549                               in the VLP_IRKEYS.K array in order to specify
 4550                               all the fields needed for key definitions.
 4551                               The default is 1.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            124  
 4552                          */
 4553
 4554              3 KEYEND# BIT(1) %INIT(KEYEND*0)%CHARTEXT('/**/'),
 4555                          /*K* KEYEND = {YES|NO}.
 4556                               If YES, this entry in the VLP_IRKEYS.K array
 4557                               indicates the last field segment of a key
 4558                               definition.  If NO, this is not the last
 4559                               field in a key definition.  Note that all
 4560                               elements of the VLP_IRKEYS.K array will be
 4561                               initialized to this value.  The default is
 4562                               NO.
 4563                          */
 4564
 4565              3 UNIQUE# BIT(1) %INIT(UNIQUE*0)%CHARTEXT('/**/'),
 4566                          /*K* UNIQUE = {YES|NO}.
 4567                               If YES, then this key must be unique.  If NO,
 4568                               then duplicates are allowed on this key.
 4569                               UNIQUE only needs to be specified on the
 4570                               first field segment of a key definition.
 4571                               Note that all elements of the VLP_IRKEYS.K
 4572                               array will be initialized to this value.
 4573                               The default is NO.
 4574                          */
 4575
 4576              3 * BIT(7) %INIT('0'B*0)%CHARTEXT('/**/'),
 4577
 4578              3 FIELDN# UBIN(9) CALIGNED %INIT(FIELDN*0)%CHARTEXT('/**/');
 4579                          /*K* FIELDN = VALUE-DEC(0-511).
 4580                               Specifies the index into the corresponding
 4581                               VLP_RECFIELD field array of the field which
 4582                               defines this portion of the key.  Note that
 4583                               all elements of the VLP_IRKEYS.K array will
 4584                               be initialized to this value.  The default
 4585                               is 0.
 4586                          */
 4587      %MEND;
 4588                                    /************************************/
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            125  
 4589                                    /**   M$CLOSE- CLOSE DCB PROCEDURE **/
 4590                                    /************************************/
 4591
 4592
 4593                          /*F* NAME: M$CLOSE - Close DCB.
 4594
 4595                          The M$CLOSE service
 4596                          terminates and inhibits I/O through a specified
 4597                          DCB, until the DCB is again opened.
 4598                          In addition, unique positioning and updating
 4599                          operations occur for the following devices and
 4600                          files.
 4601
 4602                          For tape updating, the M$CLOSE service performs
 4603                          these additional functions:
 4604
 4605                          o  Performs end-of-file processing appropriate to tapes:
 4606                          }
 4607                          For free or managed tape, if the last operation performed
 4608                          was a write, two file marks are written and the tape
 4609                          positioned between them. If the last operation was
 4610                          a write-end-of-file, one file mark is written and the
 4611                          tape positioned before it.
 4612                          }
 4613                          For labeled tape User Trailing Labels may be
 4614                          specified to be written following the End Of File
 4615                          label group for CREATEd files. A buffer may be
 4616                          specified for receipt of any UTLs present for IN
 4617                          or UPDATE file if the file was not modified. Tape
 4618                          position is left following the file mark which follows
 4619                          the end of file label group (including UTLs).
 4620
 4621                          o  Positions the tape following end-of-file
 4622                          processing, if the POS parameter is specified.
 4623
 4624                          For disk the M$CLOSE service performs these additional
 4625                          functions:
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            126  
 4626
 4627                          o  Handles file disposition, which may include
 4628                          releasing a file or entering it in the account
 4629                          file directory. The disposition of a
 4630                          file is determined in part by parameters
 4631                          specified when the DCB was opened. If a
 4632                          file was opened with DISP=SCRATCH for any
 4633                          function, the close process always releases
 4634                          the secondary storage allocated to the file.
 4635                          If a file was opened with DISP=NAMED, the
 4636                          close process disposes of the file as
 4637                          specified by the user in the DISP parameter
 4638                          of the M$CLOSE service.
 4639
 4640                          o  Permits the user to modify file attributes
 4641                          (see CHGATTR).
 4642
 4643                          o  Permits the user to release unused granules
 4644                          (see RELG).
 4645
 4646                          o  Allows the user to request rebuilding of
 4647                          the upper level index for a keyed, indexed
 4648                          or IREL file (see REBLD).
 4649
 4650                          The form of the call for this service is as follows:
 4651
 4652                          CALL M$CLOSE (FPT_CLOSE) [ALTRET (label)];
 4653
 4654                          The parameters for the service are as follows:
 4655
 4656                          */
 4657
 4658
 4659
 4660       %MACRO FPT_CLOSE  (FPTN=FPT_CLOSE,
 4661              VECTOR=VECTOR,
 4662              PFMT="BIT(72)",
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            127  
 4663              NAME=NIL,
 4664              PASS=NIL,
 4665              ACCESS=NIL,
 4666              ACSVEH=NIL,
 4667              UATTR=NIL,
 4668              INSTATTR=NIL,
 4669              PROCATTR=NIL,
 4670              ACCT=NIL,
 4671              IFPARAM=NIL,
 4672              ALTKEYS=NIL,
 4673              SN=NIL,
 4674              IRREC=NIL,
 4675              UTL=NIL,
 4676              RECFIELD=NIL,
 4677              DCB=NIL,
 4678              CHGATT(YES='1'B,NO='0'B)='0'B,
 4679              RELG(YES='1'B,NO='0'B)='0'B,
 4680              REBLD(YES='1'B,NO='0'B)='0'B,
 4681              BACKUP(YES='1'B,NO='0'B)='0'B,
 4682              ALTBLD(YES='1'B,NO='0'B)='01'B,
 4683            XTNSIZE=0,
 4684            LSLIDE=0,
 4685            LRDL0=0,
 4686            SPARE=0,
 4687            EXPIRE(NEVER=-1,ANY)=0,
 4688              ASTOW(YES='1'B,NO='0'B)='0'B,
 4689              ISTOW(YES='1'B,NO='0'B)='0'B,
 4690              UPDDESC(YES='1'B,NO='0'B)='0'B,
 4691              DELFDE(YES='1'B,NO='0'B)='0'B,
 4692             BUPM(YES='1'B,NO='0'B)='01'B,
 4693              TYPE="BINASC(0)",
 4694              STCLASS=STATIC,
 4695              DISP(SCRATCH=1,SAVE=2,RELEASE=1,CLRES=3)=0,
 4696              GHSTACS(NONE=3,JRNLOPN=2,ANY)=0,
 4697              NOMARKS(YES='1'B,NO='0'B)='0'B,
 4698              TRUNCATE(YES='1'B,NO='0'B)='0'B,
 4699            POS(PTL=1,REM=2,REL=3,PTV=4,POT=5)=0);
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            128  
 4700
 4701       %LSET LISTDIR='0'B;
 4702       %LSET LISTEXP='1'B;
 4703       %LSET LISTCOM='0'B;
 4704       %LSET LISTSUB='1'B;
 4705       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4706       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4707       (SUBSTR(STR,0,8)='CONSTANT') OR
 4708       (SUBSTR(STR,0,3)='EXT');
 4709       %LSET INIT=CHARTEXT('INIT');
 4710       %ELSE;
 4711       %LSET INIT=CHARTEXT('/*');
 4712       %ENDIF;
 4713       %IF (TEXTCHAR(SN)~='NIL');
 4714       %LSET SNIRREC=TEXTCHAR(SN);
 4715       %ERROR (TEXTCHAR(IRREC)~='NIL','IRREC ILLEGAL - SN SPECIFIED');
 4716       %ELSE;
 4717       %LSET SNIRREC=TEXTCHAR(IRREC);
 4718       %ENDIF;
 4719       %IF (TEXTCHAR(UTL)~='NIL');
 4720       %LSET UTLRECFIELD=TEXTCHAR(UTL);
 4721       %ERROR (TEXTCHAR(RECFIELD)~='NIL','RECFIELD ILLEGAL - UTL SPECIFIED');
 4722       %ELSE;
 4723       %LSET UTLRECFIELD=TEXTCHAR(RECFIELD);
 4724       %ENDIF;
 4725
 4726
 4727      DCL 1 FPTN STCLASS,
 4728            2 V_ PFMT %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4729            2 SN_ PFMT %INIT(VECTOR(%CHARTEXT(SNIRREC)))%CHARTEXT('/**/'),
 4730                          /*K* SN = VARIABLE      Locates a VLP_SN area.
 4731                          This area will contain the tape serial numbers
 4732                          which were used to create new tape volumes from
 4733                          scratch tapes.  See the VLP_SN macro described later
 4734                          in this section for a definition of serial number list.
 4735                          */
 4736
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            129  
 4737            2 IRREC_ REDEF SN_ PFMT,
 4738                          /*K* IRREC = VARIABLE
 4739                          Locates a VLP_IRREC area containing a description
 4740                          of the logical order of fields in a record.  It
 4741                          may be specified for consecutive, relative, keyed,
 4742                          indexed, or Indexed Relational (IREL) files.
 4743
 4744                          For non-IREL files, this area will replace the
 4745                          current logical record description if CHGATT=YES,
 4746                          the user has the required permission, and the
 4747                          number of entries specified in VLP_IRREC.NFIELDS#
 4748                          is less than or equal to the number of fields in
 4749                          either the current physical field definitions for
 4750                          the file or a VLP_RECFIELD area also supplied on
 4751                          the close.
 4752
 4753                          For IREL files, the same conditions apply except
 4754                          that no VLP_RECFIELD may be specified on the
 4755                          close.
 4756                          */
 4757
 4758            2 UTL_ PFMT %INIT(VECTOR(%CHARTEXT(UTLRECFIELD)))%CHARTEXT('/**/'),
 4759                          /*K* UTL = VARIABLE
 4760                          Locates a VLP_ULBL area for
 4761                          User Trailer Labels (UTLs). UTLs are read into
 4762                          the buffer at close of the file if the file was
 4763                          opened with FUN=IN or UPDATE if the file was not
 4764                          modified. UTLs are written from this buffer
 4765                          during the close of a file opened with FUN=CREATE.
 4766                          User labels are 80 bytes each and must begin with
 4767                          'UTL'. Labels are packed into the buffer
 4768                          contiguously.
 4769                                                                                  */
 4770
 4771            2 RECFIELD_ REDEF UTL_ PFMT,
 4772                          /*K* RECFIELD = VARIABLE
 4773                          Locates a VLP_RECFIELD area containing record
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            130  
 4774                          field definitions.  This area will replace the
 4775                          current record field definitions if CHGATT=YES and
 4776                          the user has the required permission.  It may be
 4777                          specified for consecutive, relative, keyed, or
 4778                          indexed files.  The default is NIL.
 4779                          */
 4780
 4781            2 NAME_ PFMT %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
 4782                          /*K* NAME = VARIABLE     Locates an area
 4783                          containing a file name (see the VLP_NAME macro
 4784                          described later in this section). If CHGATT=YES
 4785                          and the user has the required permission, the
 4786                          specified name becomes the new name for the
 4787                          file.*/
 4788
 4789            2 PASS_ PFMT %INIT(VECTOR(PASS))%CHARTEXT('/**/'),
 4790                          /*K* PASS = VARIABLE     Locates an area
 4791                          containing a password (see the VLP_PASS macro
 4792                          which is described later in this section). If
 4793                          CHGATT=YES and the user has the required
 4794                          permission, the specified password becomes the new
 4795                          password for the file.*/
 4796
 4797            2 ACCESS_ PFMT %INIT(VECTOR(ACCESS))%CHARTEXT('/**/'),
 4798                          /*K* ACCESS = VARIABLE     Locates an access control
 4799                          list area (see the VLP_ACCESS macro described
 4800                          in this section). If CHGATT=YES and the
 4801                          user has the required permission, the specified
 4802                          list becomes the new access control list for the
 4803                          file.
 4804                                                                                  */
 4805            2 ACSVEH_ PFMT %INIT(VECTOR(ACSVEH))%CHARTEXT('/**/'),
 4806                          /*K* ACSVEH = VARIABLE     Locates an access
 4807                          vehicle control list (see the VLP_ACSVEH macro
 4808                          described in this section). If CHGATT=YES
 4809                          and the user has the required permission, the
 4810                          specified list becomes the new access vehicle
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            131  
 4811                          control list for the file.
 4812                                                                                  */
 4813            2 UATTR_ PFMT %INIT(VECTOR(UATTR))%CHARTEXT('/**/'),
 4814                          /*K* UATTR = VARIABLE       Locates an area
 4815                          containing user attributes (see the VLP_ATTR macro
 4816                          described in this section). If CHGATT=YES
 4817                          and the user has the required permission, the
 4818                          specified user attributes become the new user
 4819                          attributes for the file.
 4820                                                                                  */
 4821            2 INSTATTR_ PFMT %INIT(VECTOR(INSTATTR))%CHARTEXT('/**/'),
 4822                          /*K* INSTATTR = VARIABLE     Locates an area
 4823                          containing installation attributes (see the VLP_ATTR macro
 4824                          described in this section). If CHGATT=YES
 4825                          and the user has the required permission, the
 4826                          specified installation attributes become the
 4827                          new installation attributes for the file.
 4828                                                                                  */
 4829            2 PROCATTR_ PFMT %INIT(VECTOR(PROCATTR))%CHARTEXT('/**/'),
 4830                          /*K* PROCATTR = VARIABLE       Locates an area
 4831                          containing processor attributes (see the VLP_ATTR
 4832                          macro described in this section). If
 4833                          CHGATT=YES and the user has the required
 4834                          permission, the specified processor attributes
 4835                          become the new processor attributes for the file.
 4836                                                                                  */
 4837            2 ACCT_ PFMT %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 4838                          /*K* ACCT = VARIABLE     Locates an area containing
 4839                          an account name (see the VLP_ACCT macro which is
 4840                          described later in this section). If CHGATT=YES and
 4841                          the user has the required permission, the specified
 4842                          account becomes the new account in which the file
 4843                          resides, provided the account already exists on the
 4844                          same packset as the old account.
 4845                          This facility is not yet implemented.                   */
 4846            2 IFPARAM_ PFMT %INIT(VECTOR(IFPARAM))%CHARTEXT('/**/'),
 4847                          /*K* IFPARAM = VARIABLE     Locates an area
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            132  
 4848                          containing FIT data which may be used in conjunction
 4849                          with CHGATT=YES to alter various portions of a file's
 4850                          FIT (see CHGATT for a list of the alterable ones).      */
 4851
 4852            2 ALTKEYS_ PFMT %INIT(VECTOR(ALTKEYS))%CHARTEXT('/**/'),
 4853                          /*K* ALTKEYS = VARIABLE
 4854                          Locates a VLP_ALTKEYS
 4855                          which describes the alternate indices to replace
 4856                          the existing alternate indices in the indexed
 4857                          file, if CHGATT=YES, and the user has the required
 4858                          permission.  The alternate keys may only be
 4859                          redefined if the last key in the new definition
 4860                          does not extend beyond the last key in the old
 4861                          definition.
 4862                          The default causes this parameter to be ignored.        */
 4863
 4864            2 V DALIGNED,
 4865              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 4866                          /*K* DCB = DCBNAME  Specifies the DCB to be closed.
 4867                          */
 4868              3 OPER,
 4869                4 CHGATT# BIT(1) %INIT(CHGATT)%CHARTEXT('/**/') UNAL,
 4870                          /*K* CHGATT = {YES|NO} YES requests
 4871                          modification of one or more of the following file
 4872                          attributes: BUPM, TYPE, XTNSIZE, EXPIRE, LSLIDE,
 4873                          LRDL0, SPARE, NAME, PASS, ACCESS,
 4874                          ACSVEH, UATTR, INSTATTR, PROCATTR, ALTKEYS,
 4875                          and IRKEYS. The
 4876                          modifications are permitted if the file has been
 4877                          opened specifying FUN=UPDATE, or FUN=CREATE, and
 4878                          the user has REATTR permission, except for NAME,
 4879                          PASS, ACCESS and ACSVEH, which require DELF
 4880                          permission.                                             */
 4881                4 RELG# BIT(1) %INIT(RELG)%CHARTEXT('/**/') UNAL,
 4882                          /*K* RELG = {YES|NO} YES requests release of
 4883                          unused granules allocated for this disk file. RELG=YES
 4884                          is typically specified when the user anticipates
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            133  
 4885                          little or no updating to a file.
 4886                                                                                  */
 4887                4 REBLD# BIT(1) %INIT(REBLD)%CHARTEXT('/**/') UNAL,
 4888                          /*K* REBLD = {YES|NO} YES requests rebuilding
 4889                          of the upper level index for a keyed, indexed
 4890                          or IREL disk file.
 4891
 4892                          (Re)building an upper-level index structure
 4893                          increases the number of granules in the file,
 4894                          but has no effect upon
 4895                          the actual content of the level-0 index granules.
 4896                          REBLD (re)creates a pyramid structure which
 4897                          File Management can use to locate keys in the
 4898                          level-0 granules without having to search through
 4899                          the level-0 granules in a sequential fashion.
 4900
 4901                          A level-1 structure should not exist if
 4902                          there are 3 or fewer granules at level 0.  At an
 4903                          attempt to read a record whose key is not located
 4904                          in whichever level-0 granule is currently in
 4905                          memory (when there is an upper-level index
 4906                          structure), then File Management goes directly
 4907                          to the first granule at the highest level, and
 4908                          searches "downward" toward level-0 to locate the
 4909                          key.  If there are 1, 2, or 3 granules located
 4910                          at level 0, then this multi-level search
 4911                          requires (on the average) more disk accesses
 4912                          than would a sequential search at level-0 (which
 4913                          occurs if there is no upper-level index).
 4914                          Creating 4 granules of level-0 index is a
 4915                          "break-even" point at which a multi-level search
 4916                          requires (on the average) just as many reads as
 4917                          a sequential search.  File Management will therefore
 4918                          create a level-1 index when the DCB is closed.
 4919                          For files with 5 or more granules of level-0
 4920                          index, the multi-level index pyramid can save a
 4921                          significant number of disk I/Os.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            134  
 4922
 4923                          Instead of using the REBLD option whenever
 4924                          creating (or updating) a keyed file, it is
 4925                          advisable to have File Management (re)build
 4926                          the index pyramid whenever there would be a
 4927                          significant benefit from doing so.  File Management
 4928                          normally rebuilds the pyramid whenever there are
 4929                          at least 3 adjacent level-0 index granules which
 4930                          cannot be reached from level-1, or when there are
 4931                          at least 510 level-0 granules anywhere in the file
 4932                          which can't be reached.  For a file that is read
 4933                          and updated frequently, and not opened and closed
 4934                          often, then it might be advisable to change these
 4935                          figures.  The former (3) can be changed by
 4936                          specifying LRDL0=n, and the latter can be changed
 4937                          by specifying LSLIDE=n.  A value of LSLIDE=1 will
 4938                          cause the upper-level pyramid to be rebuilt at
 4939                          M$CLOSE time, if a new level-0 granule has been
 4940                          added anywhere in the file.  This will guarantee a
 4941                          high-quality pyramid but incurs the overhead
 4942                          involved in the frequent rebuilding of the pyramid
 4943                          at file-closure time.
 4944                          */
 4945              3 EFTOPER,
 4946                4 BACKUP# BIT(1) %INIT(BACKUP)%CHARTEXT('/**/') UNAL,
 4947                          /*K*  EFTOPER.BACKUP# is used by EFT to indicate that the
 4948                          file close should take the contents of the 0'th entry
 4949                          of the VLP_SN area described by the FPT.SN_ along with
 4950                          the file open time and merge them into the area of
 4951                          the file FIT described by the %CODE05 structure.  See
 4952                          Appendix C of CE75.
 4953                                                                                   */
 4954                4 ASTOW# BIT(1) %INIT(ASTOW)%CHARTEXT('/**/') UNAL,
 4955                          /*K*  EFTOPER.ASTOW# is used by EFT to indicate that the
 4956                          file close should take the contents of the 0'th entry
 4957                          of the VLP_SN area described by FPT.SN_ along with
 4958                          the file open time and merge them into the area of the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            135  
 4959                          file FIT described by the %CODE06 structure.
 4960                                                                                   */
 4961                4 ISTOW# BIT(1) %INIT(ISTOW)%CHARTEXT('/**/') UNAL,
 4962                          /*K*  EFTOPER.ISTOW# is used by EFT to indicate that
 4963                          the file close should result in the granules being
 4964                          released, and a special directory entry created that
 4965                          may later be accessed through an M$OPEN that asks
 4966                          for FPARAM data.  The %CODE06 macro may then be used
 4967                          to determine which tape the file resides upon.  See
 4968                          Appendix C of CE75.  ISTOW and ASTOW must both be
 4969                          used if the file is being stowed inactive the first
 4970                          time.
 4971                                                                                   */
 4972                4 UPDDESC# BIT(1) %INIT(UPDDESC)%CHARTEXT('/**/') UNAL,
 4973                          /*K*  EFTOPER.UPDDESC# is used by EFT to indicate that
 4974                          the file close should move the descriptor bits from
 4975                          the FPT into the appropriate areas of the file FIT and
 4976                          the file directory.
 4977                                                                                   */
 4978                4 DELFDE# BIT(1) %INIT(DELFDE)%CHARTEXT('/**/') UNAL,
 4979                          /*K*  EFTOPER.DELFDE# is used by EFT to indicate that
 4980                          the file directory entry describing the file should be
 4981                          removed, compacting the directory, and removing all
 4982                          knowledge of the file.
 4983                                                                                   */
 4984              3 TRUNCATE# BIT(1) %INIT(TRUNCATE)%CHARTEXT('/**/') UNAL,
 4985                          /*K* TRUNCATE = {YES|NO}  YES signifies that the
 4986                          tape file ends here.
 4987                          The default is NO.                                      */
 4988
 4989
 4990              3 DISP# UBIN(9) %INIT(DISP)%CHARTEXT('/**/') UNAL,
 4991                          /*K* DISP = {SAVE|RELEASE|CLRES}  Applies to disk and tape
 4992                          files created with DISP=NAMED, or to communication
 4993                          line (CL) resources.  On a close, DISP
 4994                          specifies whether the NAMED file is to be saved or
 4995                          released. (At open the DISP parameter specifies
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            136  
 4996                          NAMED if the user intends to retain the file and
 4997                          SCRATCH if the user does not intend to retain the
 4998                          file. Any file opened with SCRATCH disposition is
 4999                          always released at close. Thus the DISP parameter
 5000                          on the close is not meaningful for scratch files.)
 5001
 5002                          When DISP=SAVE the file is cataloged if it is
 5003                          not already represented in the file
 5004                          directory. If the file replaces an existing file
 5005                          (the file was opened with CTG=NO and
 5006                          EXIST=NEWFILE), the new file replaces the old file
 5007                          which is deleted from the file directory. The old
 5008                          file is released when all current file users close
 5009                          the associated DCBs. If a comgroup DCB station is
 5010                          closed SAVE and latching has been used, the latched
 5011                          input is deleted and the latched outputs are sent.
 5012
 5013                          When DISP=RELEASE, the file is deleted from the
 5014                          file directory (if it was previously
 5015                          cataloged). The file is released when all
 5016                          current file users close the associated DCBs.
 5017
 5018                          The default is SAVE for cataloged files and RELEASE
 5019                          for uncataloged files. (Any file declared as a
 5020                          SCRATCH file is always released.)
 5021
 5022                          For a DCB open with RES=CL by the AU of the resource,
 5023                          DISP can be used to reconnect a subchannel to a DCB in
 5024                          a different user who is waiting for such a thing to
 5025                          happen.
 5026
 5027                          When DISP=SAVE or if DISP is not specified, the circuit
 5028                          is simply disconnected.
 5029
 5030                          When DISP=RELEASE, the circuit is disconnected,
 5031                          the open pending for the DCB specified in CLDCB and
 5032                          CLSYSID is errored with E$CGORAU, and CGINFO is returned
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            137  
 5033                          in that DCB's ARS# field.
 5034
 5035                          When DISP=CLRES, the circuit is attached to the DCB
 5036                          specified in CLDCB and CLSYSID, the open for that DCB
 5037                          succeeds, and CLINFO is also returned in that DCB's
 5038                          ARS# field.                                             */
 5039
 5040              3 XTNSIZE# UBIN(18)UNAL %INIT(XTNSIZE)%CHARTEXT('/**/'),
 5041                          /*K* XTNSIZE = VALUE-DEC(1-?). Specifies a change in
 5042                          XTNSIZE if CHGATT is YES.  See XTNSIZE in M$OPEN.
 5043
 5044                          .INL 0
 5045                          A listing of additional fields in the V area
 5046                          follows.  These fields are not set via parameters
 5047                          for M$CLOSE.
 5048                                                                                  */
 5049              3 DESC REDEF XTNSIZE# UNAL,
 5050                     /*B* DESC. Specifies new descriptor bits if UPDDESC is yes.  */
 5051                4 DELF# BIT(1),
 5052                4 NOLIST# BIT(1),
 5053                4 BUF# BIT(1),
 5054                4 ODSTOW# BIT(1),
 5055                4 BAD# BIT(1),
 5056                4 QS# BIT(1),
 5057                4 * BIT(2),
 5058                4 ARCHIVE# BIT(1),
 5059                4 BUPM# BIT(1),
 5060                4 NBUF# BIT(1),
 5061                4 ACTIVE# BIT(1),
 5062                4 TPB# BIT(1),
 5063                4 TERMINATE# BIT(1),
 5064                4 FETCH# BIT(1),
 5065                4 * BIT(3),
 5066              3 CLSYSID# REDEF XTNSIZE# UBIN(18) UNAL,
 5067                          /*K* CLSYSID# is a REDEF of XTNSIZE# and is used by
 5068                          the AU of a CL resource.  See the DISP option.          */
 5069
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            138  
 5070              3 TYPE# CHAR(2) %INIT(TYPE)%CHARTEXT('/**/'),
 5071                          /*K* TYPE = VALUE-CHAR(2) is the
 5072                          processor-supplied file type. If CHGATT=YES and
 5073                          the user has the required permission, the type
 5074                          code becomes the new type code for the file. See
 5075                          M$OPEN for a list of the file type codes.
 5076                                                                                  */
 5077              3 CLDCB# REDEF TYPE# UBIN(18) UNAL,
 5078                          /*K* CLDCB# is a REDEF of TYPE# and is used by
 5079                          the AU of a CL resource.  See the DISP option.          */
 5080
 5081              3 POS# UBIN(9) %INIT(POS)%CHARTEXT('/**/') UNAL,
 5082                          /*K* POS = OPTION Specifies positioning for magnetic tape.
 5083                          IF POS is not specified, the default close
 5084                          positioning is retained with one exception.
 5085                          If DISP=RELEASE is specified
 5086                          for a CREATEd TAPE file, POS is assumed to
 5087                          be PTL.
 5088
 5089                          PTL: For labeled tapes, the volume (set) is positioned
 5090                          before the Header label group preceding  the file
 5091                          just closed.  For free tapes, the volume is
 5092                          left after the file mark preceding  the data section
 5093                          just closed.  A device data section includes the
 5094                          file mark immediately following.
 5095
 5096                          PTV: For labeled, managed, and free tapes, the tape
 5097                          is rewound.
 5098
 5099                          REM: For labeled, managed, and free tapes, the current
 5100                          volume is unloaded.  If the volume and drive were
 5101                          reserved with a RESOURCE command, the drive remains
 5102                          allocated to the user.
 5103
 5104                          REL: For labeled, managed, and free tapes, the current
 5105                          volume is unloaded and the drive is released to the
 5106                          system.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            139  
 5107
 5108                          The default for labeled tapes is to position following
 5109                          the file mark following the EOF label group.  The default
 5110                for free and managed tapes is to leave position unchanged unless
 5111                the file was modified in which case two file marks are
 5112                written and tape left positioned between them.                    */
 5113              3 BUPM# BIT(2) %INIT(BUPM)%CHARTEXT('/**/'),
 5114                          /*K* BUPM = {YES|NO} Specifies a change in BUPM if
 5115                          CHGATT is YES. See DESC.BUPM# in the macro M$DCB.       */
 5116              3 NOMARKS# BIT(1) %INIT(NOMARKS)%CHARTEXT('/**/'),
 5117                     /*K* NOMARKS = {YES|NO} For free tapes only.  YES specifies
 5118                     that file marks are not to be written on a free tape when
 5119                     it is closed after having been modified.  Normally, two
 5120                     file marks are written to indicate end of tape.
 5121                     YES specifies if tape is not to be positioned after the next
 5122                     file mark when it is closed after not having been modified.
 5123                     Normally, the tape is positioned to the beginning of the
 5124                     next free tape file.
 5125                     The default is NO.                                           */
 5126
 5127              3 ALTBLD# BIT(2) %INIT(ALTBLD)%CHARTEXT('/**/'),
 5128                          /*K* ALTBLD = {YES|NO} YES specifies that the
 5129                          alternate indices for this indexed or IREL file are
 5130                          to be rebuilt.  NO specifies that they are
 5131                          not to be rebuilt.  The default is to rebuild
 5132                          them only if necessary.
 5133
 5134                          In order to update the alternate indices on
 5135                          the close, the monitor initiates a load and
 5136                          link to ALTKEY.:SYS.  This processor uses
 5137                          X$SORT to sort the alternate indices into
 5138                          their proper order.  The new keys are then
 5139                          written to the file.  If any errors are
 5140                          detected during the process, an error is
 5141                          returned to the user.  Under some
 5142                          circumstances, errors may be written directly
 5143                          to the user through the M$DO DCB.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            140  
 5144                          */
 5145
 5146              3 GHSTACS# UBIN(4) %INIT(GHSTACS)%CHARTEXT('/**/')UNAL,
 5147                          /*K* GHSTACS = VALUE-DEC(0-15).  Specifies a change in
 5148                     GHSTACS if nonzero and CHGATT is yes.  See GHSTACS in M$OPEN.
 5149                     The value NONE specifies that GHSTACS is to be reset.
 5150                     If specified for a COMGROUP, the change does not have
 5151                     any effect until the COMGROUP is reinitialized (opened
 5152                     with no current users).                                      */
 5153              3 EXPIRE# SBIN(18)UNAL %INIT(EXPIRE)%CHARTEXT('/**/'),
 5154                          /*K* EXPIRE = {ddd|NEVER}  Specifies a change in EXPIRE
 5155                          if CHGATT is YES. See EXPIRE in M$OPEN.                 */
 5156              3 CLINFO# REDEF EXPIRE# UBIN(18) UNAL,
 5157                          /*K* CLINFO# is a REDEF of EXPIRE# and is used by
 5158                          the AU of a CL resource.  See the DISP option.          */
 5159
 5160              3 LSLIDE# UBIN(9)UNAL %INIT(LSLIDE)%CHARTEXT('/**/'),
 5161                          /*K* LSLIDE = VALUE-DEC(1-511).  Specifies a change
 5162                          in LSLIDE if CHGATT is YES.  See LSLIDE in M$OPEN.      */
 5163              3 LRDL0# UBIN(9)UNAL %INIT(LRDL0)%CHARTEXT('/**/'),
 5164                          /*K* LRDL0 = VALUE-DEC(1-511).  Specifies a change
 5165                          in LRDL0 if CHGATT is YES.  See LRDL0 in M$OPEN.        */
 5166              3 SPARE# UBIN(9)UNAL %INIT(SPARE)%CHARTEXT('/**/'),
 5167                          /*K* SPARE = VALUE-DEC(1-511).  Specifies a change
 5168                          in SPARE if CHGATT is YES.  See SPARE in M$OPEN.        */
 5169              3 * BIT(9) %INIT('0'B)%CHARTEXT('/**/');
 5170
 5171          %MEND;
 5172
 5173                          /*F* NAME: Unit Record Manipulation.
 5174
 5175                          The  monitor services described in this section
 5176                          provide control over output data with unit record
 5177                          organization. Unit record formatting generally applies
 5178                          to a group of records: printer page formatting or
 5179                          record sequencing for punch cards, for example. Such
 5180                          format options are be specified via the SET command,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            141  
 5181                          via M$DCB or M$OPEN, or by services discussed in this
 5182                          section.
 5183
 5184                          In addition the M$LDEV service provides extensive
 5185                          control over unit record data associated with logical
 5186                          devices. For logical devices identified by special
 5187                          name such as LP, LO, etc., the user accepts default
 5188                          attributes for the logical device. The M$LDEV service
 5189                          provides the capability to modify these attributes, to
 5190                          control the format, timing, and content of output to a
 5191                          logical device, and to define new logical device names.
 5192                          */
 5193                                    /*************************************/
 5194                                    /** M$LDEV- ASSIGN STREAM PROCEDURE **/
 5195                                    /*************************************/
 5196
 5197                          /*F* NAME: M$LDEV - Change Logical Device.
 5198
 5199                          The M$LDEV service permits the user to
 5200                          perform a variety of functions related to logical
 5201                          devices. Often the user can simply use special
 5202                          names listed in the CP-6 Programmer Reference Manual to
 5203                          access a logical device and bypass use of M$LDEV
 5204                          altogether. The M$LDEV service is only needed in the
 5205                          special cases which are described next.
 5206
 5207                          If the default attributes for a logical device are
 5208                          not appropriate to a user's needs, the user calls
 5209                          M$LDEV to modify the attributes.  The critical attributes
 5210                          associated with a logical device are:
 5211
 5212                          o Workstation of the destination device:  default
 5213                           is the user's workstation of origin.
 5214
 5215                          o Device type:  default is the first two characters
 5216                           of the name of the logical device.
 5217
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            142  
 5218                          o Form to be mounted on the device:  default is
 5219                           defined in the workstation definition file by the
 5220                           installation manager.
 5221
 5222                          o Number of copies to produce:  the system default
 5223                           is one copy.
 5224
 5225                          (If the defaults are satisfactory, M$LDEV is not
 5226                          called. The user assigns a DCB to a special name or
 5227                          logical device name via a SET command, or invokes
 5228                          M$OPEN specifying the special name or logical device
 5229                          name as the RES parameter.)
 5230
 5231                          The user may modify any of the attributes mentioned
 5232                          above by calling M$LDEV. Parameters on this call
 5233                          include: STREAMNAME set to a 4-character logical
 5234                          device name (for example, LP01 or CP01 which are
 5235                          logical devices that are always available to the user)
 5236                          and any one of these parameters: WSN, DEV, FORM,
 5237                          COPIES. If M$LDEV is called prior to writing any output to
 5238                          the logical device, the new symbiont file reflects the
 5239                          attribute modifications. If output has been written to
 5240                          the logical device within this job, the current output
 5241                     retains its attributes and subsequent output is created with
 5242                     the modified attributes. When modifying the attributes
 5243                     mentioned above, a user does not need to be concerned
 5244                     with the additional parameters available on the M$LDEV
 5245                     service with one exception: the default parameter
 5246                     CONTINUE=NO must be in effect when WSN, DEV, or FORM is
 5247                     modified.
 5248
 5249                     Because the most frequent use of M$LDEV is to
 5250                     modify attributes of LP01 or CP01, the other
 5251                     capabilities of M$LDEV are discussed separately below.
 5252                     The following list summarizes the capabilities provided
 5253                     to the user by the M$LDEV service and the concept of
 5254                     logical devices:
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            143  
 5255
 5256                     (1) Modify logical device attributes such as WSN,
 5257                     DEV, FORM, COPIES (when CONTINUE=NO).
 5258
 5259                     (2) Define new logical devices including
 5260                     formatting attributes.
 5261
 5262                     (3) Modify formatting attributes for a logical
 5263                     device.
 5264
 5265                     (4) Cancel logical device definitions except
 5266                     LP01 and CP01.
 5267
 5268                     (5) Control timing of transmission of output for a
 5269                     logical device.
 5270
 5271                     (6) Delete accumulated output for a logical
 5272                     device.
 5273
 5274                     (7) Create multiple symbiont files within one job
 5275                     for different device types or for the same
 5276                     device type.  (This usually involves calling
 5277                     M$LDEV to define new logical devices.)
 5278
 5279                     (8) Permits writing to one logical device via
 5280                     multiple DCBs. (This is an implicit capability and
 5281                     does not require calling M$LDEV.)
 5282
 5283                     The following paragraphs place these functions in the
 5284                     context in which they are likely to be used. The
 5285                     mandatory parameters required for each different
 5286                     function of M$LDEV are also discussed. The discussion
 5287                     is keyed by number to the preceding list of
 5288                     capabilities.
 5289
 5290                     Output to a logical device is accumulated in a
 5291                     symbiont file which, by default, is sent to the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            144  
 5292                     destination device when the job terminates. The
 5293                     process of preparing a symbiont file for transmission
 5294                     is called packaging and implies that the next time the
 5295                     user program writes to the logical device, that data is
 5296                     placed in a new symbiont file.
 5297
 5298                     The user may request (5) packaging of accumulated
 5299                     output for a logical device in advance of job
 5300                     termination by calling M$LDEV specifying only these
 5301                     parameters: an existing logical device name
 5302                     (STREAMNAME) and the default parameter CONTINUE=NO.
 5303                     However it is typical that the user requests packaging
 5304                     (1,3) in order to change logical device attributes on
 5305                     the same call to M$LDEV.
 5306
 5307                     The user may also request (6) that accumulated
 5308                     output for a logical device be deleted rather than sent
 5309                     to the destination device. The user deletes a symbiont
 5310                     file by calling M$LDEV specifying these parameters:  the
 5311                     logical device name (STREAMNAME) and DELETE=YES.
 5312                     (The next time the user program writes to the logical
 5313                     device, that data is output to a new symbiont file.)
 5314
 5315                     Formatting
 5316                     attributes are assigned to logical devices LP01 and
 5317                     CP01, and to any user-defined logical device.
 5318                     These attributes-- DVFC, HDR, LINES, SEQ, SEQCOL,
 5319                     SEQID, TAB --become the default format attributes
 5320                     for any DCB opened to the logical device. (3) The
 5321                     user may modify these formatting attributes by
 5322                     calling M$LDEV specifying STREAMNAME and any one of
 5323                     the formatting attributes listed above. If a DCB
 5324                     is open to the logical device when the user calls
 5325                     M$LDEV, the current symbiont file is packaged and a
 5326                     new symbiont file is started by default. If the
 5327                     user wishes to continue accumulating output in the
 5328                     same symbiont file, he may also specify the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            145  
 5329                     parameter CONTINUE=YES on the call to M$LDEV. (If
 5330                     CONTINUE=YES the following attributes cannot be
 5331                     changed: DEV, FPRG, WSN, FORM, COPIES.)  The user may
 5332                     override formatting attributes assigned to the
 5333                     logical device via identically-named parameters of M$DCB,
 5334                     M$OPEN, and M$DEVICE which always take precedence
 5335                     over formatting attributes specified via M$LDEV.
 5336
 5337                     The user may also establish new attributes for an
 5338                     existing logical device by calling M$LDEV with these
 5339                     parameters: STREAMNAME and SCRUB=YES; any new
 5340                     attributes specified on the same call to M$LDEV are
 5341                     applied after defaults are supplied by M$LDEV.
 5342
 5343                     If the user needs to access a device type other
 5344                     than the destination device types associated with LP01
 5345                     and CP01, the user can call M$LDEV to define a logical
 5346                     device name with attributes describing the device. (2)
 5347                     In this case, the user calls M$LDEV with these
 5348                     parameters:  a unique logical device name
 5349                     (STREAMNAME), device type (DEV), and workstation (WSN).
 5350                     Optionally, the user may specify any other appropriate
 5351                     attributes such as FORM, COPIES, and any of the
 5352                     formatting attributes. A total of 16
 5353                     logical device names can be defined for a job at one
 5354                     time. Two logical devices are always available to the
 5355                     user: LP01 and CP01.  Thus the user may define up to
 5356                     14 logical device names. (4) The user may cancel a
 5357                     logical device name by calling M$LDEV specifying the
 5358                     logical device name (STREAMNAME) and REMOVE=YES.
 5359
 5360                     The timesharing user may call M$LDEV specifying STREAMNAME='UC'
 5361                     to assign attributes to the timesharing terminal (3).
 5362                     Meaningful attributes include DVFC, HDR, LINES, and TAB.  In
 5363                     addition, the FORM attribute may be specified to "mount" a
 5364                     form on the terminal.  Note that this form "mounting" process
 5365                     does not involve the complex paper-change and alignment
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            146  
 5366                     processes required at line printer devices; the CP-6 system
 5367                     simply makes itself aware of the characteristics of the
 5368                     requested form.
 5369                     The user may define new logical device names (7) in
 5370                     order to create multiple, separate symbiont files which
 5371                     are sent separately to the destination device(s). By
 5372                     defining one or more logical devices, the user can
 5373                     assign a separate DCB to each logical device. The user
 5374                     program may then perform concurrent writes to the
 5375                     various logical devices. However, the logical device
 5376                     output is kept in separate symbiont files and appears
 5377                     separately when sent to the destination device(s).
 5378                     For example, the user may create two printer listings
 5379                     concurrently within one job. By using the logical
 5380                     device LP01 and defining another logical device name
 5381                     which could be LP02, the user can output through
 5382                     separate DCBs to the two logical devices. The
 5383                     attributes for LP01 and LP02 may be identical or
 5384                     different. Thus the listings could be directed to the
 5385                     same or to different destination devices; formatting
 5386                     may or may not be the same for the listings produced.
 5387
 5388                     The logical device concept also permits the user
 5389                     (8) to open multiple DCBs to the same logical device.
 5390                     When multiple DCBs are open to the same logical device
 5391                     concurrently, then data written through the DCBs is
 5392                     interleaved in one symbiont file; the output appears
 5393                     interleaved at the destination device also. The user
 5394                     program may also send output to the logical device
 5395                     first through one DCB and then through another DCB; the
 5396                     output appears at the destination device in the
 5397                     chronological sequence in which it was written by the
 5398                     user program.
 5399
 5400                     The service call is of the form:
 5401
 5402                     CALL M$LDEV (FPT_LDEV) [ALTRET (label)];
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            147  
 5403
 5404                     The parameters for this service are as follows:              */
 5405
 5406       %MACRO FPT_LDEV (FPTN=FPT_LDEV,
 5407              TAB=NIL,
 5408              HDR=NIL,
 5409              WSN=NIL,
 5410              FORM=NIL,
 5411              WINDOW=NIL,
 5412              FPRG=NIL,
 5413              STREAMNAME=' ',
 5414              CONTINUE(YES='1'B,NO='0'B)='0'B,
 5415              SCRUB(YES='1'B,NO='0'B)='0'B,
 5416              REMOVE(YES='1'B,NO='0'B)='0'B,
 5417              DELETE(YES='1'B,NO='0'B)='0'B,
 5418              LOGON(YES='1'B,NO='0'B)='0'B,
 5419             CONCURR(YES='1'B,NO='0'B)='0'B,
 5420             HOLD(YES='1'B,NO='0'B)='0'B,
 5421              COPIES=0,
 5422              DEV=' ',
 5423              DVFC="BINASC(0)",
 5424             HOLDCOPIES=0,
 5425              LINES=0,
 5426              SEQ(YES='1'B,NO='0'B)='01'B,
 5427              SEQCOL=73,
 5428              SEQID='    ',
 5429             WIDTH=0,
 5430              STCLASS=STATIC);
 5431
 5432       %LSET LISTDIR='0'B;
 5433       %LSET LISTEXP='1'B;
 5434       %LSET LISTCOM='0'B;
 5435       %LSET LISTSUB='1'B;
 5436       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5437      %LSET DEVTMP=CONCAT(DEV,'    ');
 5438       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5439       (SUBSTR(STR,0,8)='CONSTANT') OR
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            148  
 5440       (SUBSTR(STR,0,3)='EXT');
 5441       %LSET INIT=CHARTEXT('INIT');
 5442       %ELSE;
 5443       %LSET INIT=CHARTEXT('/*');
 5444       %ENDIF;
 5445
 5446
 5447      DCL 1 FPTN STCLASS,
 5448            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5449            2 TAB_ BIT(72) %INIT(VECTOR(TAB))%CHARTEXT('/**/'),
 5450                          /*K* TAB = VARIABLE     Locates an area containing
 5451                          horizontal tabulation settings for the logical
 5452                          device. This area may  be generated by invoking
 5453                          the VLP_TAB macro.                                      */
 5454
 5455            2 HDR_ BIT(72) %INIT(VECTOR(HDR))%CHARTEXT('/**/'),
 5456                          /*K* HDR = VARIABLE     Locates an area containing the
 5457                          page header definition.
 5458                          The area may be generated
 5459                          by invoking the VLP_HDR  macro.
 5460                          Page headings may be
 5461                          discontinued by specifying HDR=ERASE.                   */
 5462            2 WSN_ BIT(72) %INIT(VECTOR(WSN))%CHARTEXT('/**/'),
 5463                          /*K* WSN = VARIABLE     Locates an area containing a
 5464                          workstation name of the destination device.
 5465                          This area may be generated by invoking the
 5466                          VLP_WSN macro. WSN cannot be changed if
 5467                          CONTINUE=YES.                                           */
 5468            2 FORM_ BIT(72) %INIT(VECTOR(FORM))%CHARTEXT('/**/'),
 5469                          /*K* FORM = VARIABLE     Locates an area containing the
 5470                          name of the form to be mounted at the
 5471                          destination device. The area may  be generated
 5472                          by invoking the VLP_FORM macro. FORM cannot be
 5473                          changed if CONTINUE=YES.                                */
 5474            2 WINDOW_ BIT(72) %INIT(VECTOR(WINDOW))%CHARTEXT('/**/'),
 5475                          /*K* WINDOW = VARIABLE   Locates an area containing
 5476                          the description of the window to use.  The area may
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            149  
 5477                          be generated by the VLP_WINDOW macro.
 5478                          */
 5479            2 FPRG_ BIT(72) %INIT(VECTOR(FPRG))%CHARTEXT('/**/'),
 5480                          /*K* FPRG = FID          Specifies the fid of the
 5481                          FPRG to be run at the physical device when output
 5482                          from this logical device arrives there.
 5483                          */
 5484            2 V DALIGNED,
 5485              3 STREAMNAME# CHAR(4)UNAL %INIT(STREAMNAME)%CHARTEXT('/**/'),
 5486                          /*K* STREAMNAME = VALUE-CHAR(4) Specifies the name of
 5487                          the logical device to be defined or modified by
 5488                     this call to M$LDEV.  The name can be of the following forms:
 5489
 5490                1.  The name can consist of two alphabetic characters followed by
 5491                two numeric characters (the names 'LP01' and 'CP01' are always
 5492                defined).
 5493
 5494                2.  The name can be 'UC' which identifies the current timesharing
 5495                terminal.
 5496
 5497                3.  The name can be the word 'ALL' which identifies
 5498                all currently defined logical devices.
 5499
 5500                The default is blanks.                                            */
 5501
 5502              3 CONTINUE# BIT(1)UNAL %INIT(CONTINUE)%CHARTEXT('/**/'),
 5503                          /*K* CONTINUE = {YES|NO} CONTINUE=YES specifies that
 5504                          output to the logical device is to be continued,
 5505                          but with new formatting attributes such as
 5506                          tabstops (TAB), page headers (HDR), page length
 5507                          (LINES), default vertical format control (DVFC),
 5508                          or record sequencing (SEQ, SEQCOL, SEQID). If
 5509                          CONTINUE=YES the destination (WSN), device type
 5510                          (DEV), and form (FORM) must not be changed.
 5511                          CONTINUE=NO specifies that current output to the
 5512                          logical device is to be packaged and any new
 5513                          output to the logical device is sent to a new
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            150  
 5514                          symbiont file. The default is NO.                       */
 5515              3 SCRUB# BIT(1)UNAL %INIT(SCRUB)%CHARTEXT('/**/'),
 5516                          /*K* SCRUB = {YES|NO} SCRUB=YES specifies that any
 5517                          previously defined attributes for the logical
 5518                          device are to be scrubbed, that is, forgotten.
 5519                          New logical device attributes are taken from
 5520                          parameters on this call. In  the absence of DEV,
 5521                          WSN, or FORM parameters on this call, the
 5522                          following defaults are used: DEV= first two
 5523                          characters of STREAMNAME (which must correspond to
 5524                          an actual device type defined in the workstation
 5525                          definition file), WSN= user's workstation of
 5526                          origin, FORM= system default form (defined in
 5527                          the workstation definition file for this device
 5528                          type at the user's workstation of origin).              */
 5529              3 REMOVE# BIT(1)UNAL %INIT(REMOVE)%CHARTEXT('/**/'),
 5530                          /*K* REMOVE = {YES|NO} REMOVE=YES cancels the logical
 5531                          device definition.  No new output can be written
 5532                          to the logical device name; any DCB open to the
 5533                          logical device is closed automatically.
 5534                          Any parameters specified on this call to modify
 5535                          attributes are ignored when REMOVE=YES.  The default
 5536                          is NO.                                                  */
 5537              3 DELETE# BIT(1)UNAL %INIT(DELETE)%CHARTEXT('/**/'),
 5538                          /*K* DELETE = {YES|NO} DELETE is meaningful when
 5539                          CONTINUE=NO only.  DELETE=YES specifies that the
 5540                          accumulated output for the logical device is to
 5541                          be deleted instead of being sent to the
 5542                          destination device.                                     */
 5543              3 LOGON# BIT(1)UNAL %INIT(LOGON)%CHARTEXT('/**/'),
 5544                          /*K* LOGON = {YES|NO} LOGON is meaningful when
 5545                          STREAMNAME is UCnn.  LOGON=YES causes the specified
 5546                          stream to be disconnected from the current session and
 5547                          reconnected to CP-6 in the logon state.  LOGON=YES
 5548                          must not be specified on the same call to M$LDEV that
 5549                          creates the stream (i.e., the stream must already exist).
 5550                          The default is NO.                                      */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            151  
 5551              3 * BIT(2)UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5552              3 CONCURR# BIT(1)UNAL %INIT(CONCURR)%CHARTEXT('/**/'),
 5553                          /*K* CONCURR = {YES|NO} CONCURR=YES specifies that
 5554                          output to the logical device may start being transmitted
 5555                          concurrently with creation of later output.  This option
 5556                          is seldom useful, since the physical device to which the
 5557                          output is directed must stand idle when it has caught up
 5558                          to program output creation.  In specific cases with
 5559                          semi-dedicated devices, however, it may decrease the
 5560                          elapsed data processing time by overlapping physical
 5561                          output with internal computing time.                    */
 5562              3 HOLD# BIT(1)UNAL %INIT(HOLD)%CHARTEXT('/**/'),
 5563                          /*K* HOLD = {YES|NO} HOLD=YES specifies that output is
 5564                          not to be sent to the destination device, but is to be
 5565                          held for later delivery (see the UNHOLD option of
 5566                          M$JOBSTATS).  Multi-copy output may be held after one
 5567                          or more copies have been made; see the HOLDCOPIES
 5568                          option.
 5569                          */
 5570              3 COPIES# UBIN(9)UNAL %INIT(COPIES)%CHARTEXT('/**/'),
 5571                          /*K* COPIES = VALUE-DEC(1-511) Specifies the number
 5572                          of times that the output is to be transmitted to
 5573                          the destination device.  This option may be
 5574                          specified on any call to M$LDEV.  When
 5575                          CONTINUE=NO, the number of copies pertains to
 5576                          subsequent output to the logical device rather than
 5577                          to output currently being packaged for
 5578                          transmission to the destination device.                 */
 5579              3 DEV# CHAR(2)UNAL %INIT(%SUBSTR(DEVTMP,0,2))%CHARTEXT('/**/'),
 5580                          /*K* DEV = VALUE-CHAR(2) Specifies a destination
 5581                          device type.  Device type codes are defined by
 5582                          the installation manager in the workstation
 5583                          definition file; typical devices are 'LP' and 'CP'.
 5584                          DEV cannot be changed if CONTINUE=YES.                  */
 5585              3 DVFC# CHAR(1)UNAL %INIT(DVFC)%CHARTEXT('/**/'),
 5586                          /*K* DVFC = VALUE-CHAR(1) Specifies a default
 5587                          vertical format code character; e.g., 'A' for post-print
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            152  
 5588                          single spacing.  This parameter overrides
 5589                          the intrinsic vertical formatting defined in the
 5590                          forms definition file.                                  */
 5591              3 HOLDCOPIES# UBIN(9)UNAL %INIT(HOLDCOPIES)%CHARTEXT('/**/'),
 5592                          /*K* HOLDCOPIES = VALUE-DEC(0-511) Specifies, when
 5593                          HOLD=YES, that this number of copies of the output are
 5594                          to be transmitted to the destination device, and then any
 5595                          other untransmitted copies are to be held for later
 5596                          delivery.  This option might be useful if, for example,
 5597                          several copies of a report are to be created but the user
 5598                          wishes to check one copy for accuracy before printing the
 5599                          rest (HOLD=YES, HOLDCOPIES=1, COPIES=n).  The default
 5600                          value of HOLDCOPIES is 0.                               */
 5601              3 LINES# UBIN(18)UNAL %INIT(LINES)%CHARTEXT('/**/'),
 5602                          /*K* LINES = VALUE-DEC(1-32K) Specifies the number of
 5603                          printable lines per page and overrides the
 5604                          intrinsic page length from the form definition
 5605                          file.                                                   */
 5606              3 ATTR BIT(18) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5607              3 SEQ# BIT(2)UNAL %INIT(SEQ)%CHARTEXT('/**/'),
 5608                          /*K* SEQ = {YES|NO} SEQ=YES specifies that record
 5609                          sequencing is to be performed for output to the
 5610                          logical device according to the SEQCOL and SEQID
 5611                          parameters on this call.  Record sequencing is
 5612                          typically used on output to card punch devices.
 5613                          Record sequencing can be discontinued by
 5614                          specifying SEQ=NO.                                      */
 5615              3 * BIT(8) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5616              3 SEQCOL# UBIN(8) UNAL %INIT(SEQCOL)%CHARTEXT('/**/'),
 5617                          /*K* SEQCOL = VALUE-DEC(1-255) See M$OPEN. SEQCOL is
 5618                          meaningful only if SEQ=YES is specified on this
 5619                          call.                                                   */
 5620              3 SEQID# CHAR(4)UNAL %INIT(SEQID)%CHARTEXT('/**/'),
 5621                          /*K* SEQID = VALUE-CHAR(4).  See M$OPEN.
 5622                          SEQID is only used if SEQ=YES.                          */
 5623              3 WIDTH# UBIN(9)UNAL %INIT(WIDTH)%CHARTEXT('/**/'),
 5624                          /*K* WIDTH = VALUE-DEC(1-255)  When DCBs are
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            153  
 5625                          opened to a logical device defined by M$LDEV, the
 5626                          WIDTH field in those DCBs is usually the width
 5627                          of the forms that have been specified or defaulted
 5628                          to in the M$LDEV.  If it is desired to not print
 5629                          across the entire forms, a nonzero WIDTH value may
 5630                          be specified in M$LDEV; that WIDTH value is then
 5631                          inserted in DCBs if it is less than form width.
 5632                          The default for WIDTH is zero, which means form width
 5633                          is to become F$DCB.WIDTH#.                              */
 5634              3 FRMSTRM# CHAR(2) %INIT(%SUBSTR(DEVTMP,2,2))%CHARTEXT('/**/'),
 5635                          /*K* FRMSTRM = VALUE-CHAR(2) FRMSTRM is the stream
 5636                          number portion ('00' through '99') of the UC stream
 5637                          specified in DEV (as 'UCnn').  It specifies the window
 5638                          through which STREAMNAME is to be directed (or redirected,
 5639                          for an existing stream).  At compile time, this option
 5640                          is specified with the DEV option (DEV=UCnn).  At runtime,
 5641                          in order to keep the FPT compatible with previous
 5642                          versions of the system, it must be initialized in two
 5643                          parts (FPT_LDEV.DEV#='UC' and FPT_LDEV.FRMSTRM#='nn').
 5644                          The default is blanks, which uses the default window
 5645                          for this domain (or doesn't redirect an existing stream).
 5646                          */
 5647              3 * UBIN(9)UNAL %INIT(0)%CHARTEXT('/**/');
 5648          %MEND;
 5649
 5650                                    /*****************************************/
 5651                                    /** M$SETFMA- CHANGE FILE MANAGE ACCOUNT**/
 5652                                    /*****************************************/
 5653
 5654                          /*F* NAME: M$SETFMA - Set FM Account/Packset
 5655
 5656                          This service sets the packset name and account that
 5657                     file management services use when no packset name or account
 5658                     are specifically named.  These fields are initially set at
 5659                     logon time to "no packset name" and the user's logon account.
 5660
 5661                     The form of the call for this service is as follows:
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            154  
 5662
 5663                     CALL M$SETFMA(FPT_SETFMA) [ALTRET (label)];
 5664
 5665                     The parameters for this service are as follows:              */
 5666
 5667
 5668       %MACRO FPT_SETFMA  (FPTN=FPT_SETFMA,
 5669              STCLASS=STATIC,
 5670              PSN=NIL,
 5671              ACCT=NIL);
 5672
 5673       %LSET LISTDIR='0'B;
 5674       %LSET LISTEXP='1'B;
 5675       %LSET LISTCOM='0'B;
 5676       %LSET LISTSUB='1'B;
 5677       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5678       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5679       (SUBSTR(STR,0,8)='CONSTANT') OR
 5680       (SUBSTR(STR,0,3)='EXT');
 5681       %LSET INIT=CHARTEXT('INIT');
 5682       %ELSE;
 5683       %LSET INIT=CHARTEXT('/*');
 5684       %ENDIF;
 5685
 5686
 5687      DCL 1 FPTN STCLASS DALIGNED,
 5688            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 5689                          /*K* ACCT = VALUE-CHAR(1-8)  Locates an area containing
 5690                          the textual representation of the account to be
 5691                          used if one is not specified in an M$DCB, M$OPEN or
 5692                          !SET.
 5693                     If this parameter is NIL or ERASE, both the default account
 5694                     and packset name will be reset.                              */
 5695            2 PSN_ BIT(72) %INIT(VECTOR(PSN))%CHARTEXT('/**/');
 5696                          /*K* PSN = VALUE-CHAR(1-6)  Locates an area
 5697                          containing the textual representation of the
 5698                          pack set name to
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            155  
 5699                          be used in conjunction with the above account if neither
 5700                     an account nor packset name is specified in M$DCB, M$OPEN or
 5701                     !SET.
 5702                     If this parameter is NIL or ERASE, the default packset name
 5703                     will be reset.                                               */
 5704
 5705          %MEND;
 5706
 5707                                    /*********************************/
 5708                                    /** M$MADMUCK - MUCK WITH MAD   **/
 5709                                    /*********************************/
 5710
 5711                          /*F* NAME: M$MADMUCK - Read or Change MAD.
 5712
 5713                          The MAD (Master Account Directory)
 5714                is used by the CP-6 system to associate an account with the packset
 5715                on which it resides. M$MADMUCK may be used to read or update
 5716                the MAD. Update functions require FMDIAG privilege.
 5717
 5718                The form of the call for this service is as follows:
 5719
 5720                CALL M$MADMUCK (FPT_MADMUCK) [ALTRET (label)];
 5721
 5722                The parameters for this service are as follows:                   */
 5723
 5724       %MACRO FPT_MADMUCK (FPTN=FPT_MADMUCK,
 5725               STCLASS=STATIC,
 5726               DCB=NIL,
 5727               WRITE(YES='1'B,NO='0'B)='0'B,
 5728               READ(YES='1'B,NO='0'B)='0'B,
 5729               DELETE(YES='1'B,NO='0'B)='0'B,
 5730               ACCT=NIL,
 5731               SN=NIL);
 5732
 5733       %LSET LISTDIR='0'B;
 5734       %LSET LISTEXP='1'B;
 5735       %LSET LISTCOM='0'B;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            156  
 5736       %LSET LISTSUB='1'B;
 5737       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5738       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5739       (SUBSTR(STR,0,8)='CONSTANT') OR
 5740       (SUBSTR(STR,0,3)='EXT');
 5741       %LSET INIT=CHARTEXT('INIT');
 5742       %ELSE;
 5743       %LSET INIT=CHARTEXT('/*');
 5744       %ENDIF;
 5745
 5746
 5747      DCL 1 FPTN STCLASS,
 5748            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5749            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 5750                          /*K* ACCT = VARIABLE     Locates an area containing the
 5751                          account.  This area can be generated by invoking
 5752                          the VLP_ACCT macro.                                     */
 5753            2 SN_ BIT(72) %INIT(VECTOR(SN))%CHARTEXT('/**/'),
 5754                          /*K* SN = VARIABLE     Locates an area for the packset
 5755                          name.  This area can be generated by invoking
 5756                          the VLP_SN macro.                                       */
 5757            2 V DALIGNED,
 5758              3 DCB# UBIN(18)UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 5759                     /*K* DCB= DCBNAME Specifies, if present, the DCB to use (into
 5760                     which the PSN is returned if no SN is specified).
 5761                     If DCB is not specified, M$* is used.                        */
 5762              3 READ# BIT(1) %INIT(READ)%CHARTEXT('/**/'),
 5763                     /*K* READ = {YES|NO} Specifies whether a PSN is to be returned
 5764                     to the SN area (if present) or to the DCB specified
 5765                     by the DCB parameter.
 5766                     */
 5767              3 WRITE# BIT(1) %INIT(WRITE)%CHARTEXT('/**/'),
 5768                          /*K* WRITE = {YES|NO} YES specifies that a new MAD entry
 5769                          is to be made. The alternate return occurs if the entry
 5770                          already exists.                                         */
 5771              3 DELETE# BIT(1) %INIT(DELETE)%CHARTEXT('/**/'),
 5772                     /*K* DELETE = {YES|NO} Specifies that an existing MAD entry
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            157  
 5773                is to be deleted. READ occurs before DELETE if both are present.  */
 5774              3 * BIT(51) %INIT('0'B)%CHARTEXT('/**/');
 5775
 5776       %MEND;
 5777
 5778                          /*F* NAME: Data Record Manipulation.
 5779
 5780                          CP-6 file management provides a variety of monitor
 5781                          services to manipulate file data on the record level.
 5782                          In addition to read, write, and delete services which
 5783                          function on the record level, the monitor permits a
 5784                          user to check I/O completion, to position or extend a
 5785                          file, or to mark end-of-file.
 5786
 5787                The CP-6 system is designed to allow maximum flexibility in file
 5788                access and creation. Thus numerous options are
 5789                available via the M$READ and M$WRITE monitor services
 5790                to control such functions as:
 5791
 5792
 5793                o Record access method - The record access method
 5794                is  not limited by the DCB open process.  Instead
 5795                the  user may specify either sequential or direct
 5796                record access by key to KEYED, INDEXED, RANDOM,
 5797                IREL, RELATIVE, and IDS files.
 5798
 5799                o Data translation - The user can control
 5800                encryption/decryption and translation on the
 5801                record level.
 5802
 5803                o Data representation - The normal read/write
 5804                functions transfer ASCII data; however, the user
 5805                can request binary read/write functions for  data
 5806                stored in non-ASCII formats to transfer  9-bit
 5807                bytes without altering or checking the high-order
 5808                bit.
 5809
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            158  
 5810                The user supplies buffers for both read and write
 5811                functions. Buffer requirements are cited in Table 3-4.
 5812                For write functions, the user adjusts the buffer
 5813                boundary to control record length.  In addition, file
 5814                management permits reading and writing of partial
 5815                records under user control.
 5816                ..::TB "User I/O Buffer Requirements\ Type\#14\ORG\#7\Requirements"
 5817                }Disk/CP-6 Tape #Random  #Starts and ends on a word boundary
 5818                }
 5819                }               #IDS     #Starts and ends on a word boundary
 5820                }
 5821                }               #Other   #Starts and ends on a byte boundary
 5822                }
 5823                }Tape           #U       #Starts and ends on a word boundary
 5824                }
 5825                }ANS or Managed #D S F   #Starts and ends on a byte boundary
 5826                }
 5827                }EBCDIC         #F V     #Starts and ends on a byte boundary
 5828                }
 5829                }Free tape for  #        #Starts and ends on a word boundary
 5830                }ASCII write
 5831                }
 5832                }Free tape for  #        #Starts and ends on a double word
 5833                }binary writes  #        #boundary
 5834                }
 5835                }Other devices  #        #Starts and ends on a byte boundary
 5836                ..::TB
 5837                */
 5838                                    /************************************/
 5839                                    /**       M$READ- READ PROCEDURE   **/
 5840                                    /************************************/
 5841
 5842                          /*F* NAME: M$READ - Read Record.
 5843
 5844                          The M$READ service causes
 5845                          a specified data record to be read into a user  buffer
 5846                          in memory. The M$READ service is used for all types of
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            159  
 5847                          files and devices for which input is appropriate.
 5848
 5849                          The user normally provides a buffer that is large
 5850                          enough to contain the maximum length record. In the
 5851                          normal case if a record exceeds buffer size, the record
 5852                          is truncated and this condition is reported as an
 5853                          error. If a record is smaller than buffer size the
 5854                          remainder of the buffer is unchanged from its previous
 5855                          contents. The M$READ service also provides the option
 5856                          (CONT) to issue several calls to read successive
 5857                          portions of a single record.
 5858                          With continued M$READs there is virtually no maximum
 5859                          record size except for comgroups, communications
 5860                          devices or connections, and FPRGs, for which the
 5861                          limit is 4096 characters.
 5862
 5863                          Warning: Because of a hardware limitation, no
 5864                          'lost data' condition (E$LD) is reported when
 5865                          an attempt is made to read from freetape a
 5866                          record larger than the buffer size.
 5867
 5868                          Additional options provided by M$READ to accommodate a
 5869                          variety of record formats are as follows:
 5870
 5871                          o KEY, KEYR, and KEYS determine whether a file is
 5872                          read sequentially or directly by key. (The ACS
 5873                          parameter of M$DCB and M$OPEN does not restrict
 5874                          user access to the file on the record level.)
 5875
 5876                          o SEED determines whether encryption is performed.
 5877
 5878                          o FULL -- for random and IDS files -- determines
 5879                          whether the granule stamp is read into the user
 5880                          buffer.
 5881
 5882                          o TRANS requests transparency (no translation) on
 5883                          the record.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            160  
 5884
 5885                          o BIN requests a 'binary read' instead of the
 5886                          normal 'ASCII read'.
 5887
 5888                          o REREAD -- for input originating from a
 5889                          time-sharing  terminal -- allows the echoing of
 5890                          the previous  record.
 5891
 5892                          For most files the user expects read completion before
 5893                          processing continues. When the WAIT=YES parameter is
 5894                          specified or is assumed by default, the normal return
 5895                          is taken when the read completes successfully. If an
 5896                          error occurs, the alternate return is taken with an
 5897                          error code reported. If multiple errors occur, these
 5898                          conditions are reflected in the TYC field of the DCB.
 5899
 5900                          The user may specify WAIT=NO to request that
 5901                          processing continue at the next statement as soon as
 5902                          the read operation is started. In this case the user
 5903                          may call M$CHECK at a later point in the code. The
 5904                          user can also call M$EVENT prior to any I/O requests
 5905                          and specify the EVENT parameter on M$READ; as a result
 5906                          an asynchronous procedure named on M$EVENT takes
 5907                          control when I/O completes and receives the EVENT code
 5908                          specified on M$READ to identify the particular I/O
 5909                          operation. Using M$EVENT and the EVENT parameter
 5910                          allows the user program to be notified when each read
 5911                          or write completes, and the completion status for the
 5912                          individual operation. M$CHECK  allows the program to
 5913                          wait for all I/O to complete, and reports the combined
 5914                          completion status of all no-wait operations since the
 5915                          last M$CHECK.
 5916
 5917                          If M$READ specifies a closed DCB, the monitor attempts
 5918                          the M$OPEN service. If the open procedure is
 5919                          successful, the read operation is then performed.
 5920
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            161  
 5921                          The service call is of the form:
 5922
 5923                          CALL M$READ (FPT_READ) [ALTRET (label)];
 5924
 5925                          The parameters for this service are as follows:
 5926                          */
 5927
 5928
 5929       %MACRO FPT_READ  (FPTN=FPT_READ,
 5930              BUF=NIL,
 5931              KEY=NIL,
 5932              STATION=NIL,
 5933              IDBUF=NIL,
 5934              DCB=NIL,
 5935              WAIT(YES='1'B,NO='0'B)='1'B,
 5936              ID(YES='1'B,NO='0'B)='0'B,
 5937              IDS(YES='1'B,NO='0'B)='0'B,
 5938              KEYCHNG(YES='1'B,NO='0'B)='0'B,
 5939              CONT(YES='1'B,NO='0'B)='0'B,
 5940              FULL(YES='1'B,NO='0'B)='0'B,
 5941              KEYS(YES='1'B,NO='0'B)='0'B,
 5942              KEYR(YES='1'B,NO='0'B)='0'B,
 5943              IOERROK(YES='1'B,NO='0'B)='0'B,
 5944              EVENT=0,
 5945              INDX=0,
 5946              STRPVFC(YES='1'B,NO='0'B)='0'B,
 5947              RECNUM=0,
 5948              SEED="'0'B",
 5949              REREAD(YES='1'B,NO='0'B)='0'B,
 5950              BP(YES='1'B,NO='0'B)='0'B,
 5951              BIN(YES='1'B,NO='0'B)='0'B,
 5952              TRANS(YES='1'B,NO='0'B)='0'B,
 5953              NODAT(YES='1'B,NO='0'B)='0'B,
 5954              KEYTYPE (FLDID=1,COORD=2,NONE=0)= 0,
 5955              ODFNC(DATA=0,MAP=1)=0,
 5956              SINPUTSIZE = 0,
 5957              REREADPOS = 0,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            162  
 5958              STCLASS=STATIC);
 5959
 5960       %LSET LISTDIR='0'B;
 5961       %LSET LISTEXP='1'B;
 5962       %LSET LISTCOM='0'B;
 5963       %LSET LISTSUB='1'B;
 5964       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5965       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5966       (SUBSTR(STR,0,8)='CONSTANT') OR
 5967       (SUBSTR(STR,0,3)='EXT');
 5968       %LSET INIT=CHARTEXT('INIT');
 5969       %ELSE;
 5970       %LSET INIT=CHARTEXT('/*');
 5971       %ENDIF;
 5972      %IF (TEXTCHAR(STATION) ~= 'NIL');
 5973      %LSET IDSTATION=TEXTCHAR(STATION);
 5974      %ERROR (TEXTCHAR(IDBUF)~='NIL','IDBUF ILLEGAL - STATION SPECIFIED');
 5975      %ELSE;
 5976      %LSET IDSTATION=TEXTCHAR(IDBUF);
 5977      %ENDIF;
 5978
 5979
 5980      DCL 1 FPTN STCLASS,
 5981            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5982            2 KEY_,
 5983              3 BOUND UBIN(20) UNAL %INIT(SIZEV(KEY))%CHARTEXT('/**/'),
 5984              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 5985              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 5986              3 KEY$ PTR %INIT(ADDR(KEY))%CHARTEXT('/**/'),
 5987                          /*K* KEY = VARIABLE     Locates a key buffer associated
 5988                          with  this read operation.  The values of KEYS
 5989                          and KEYR indicate the purpose(s) of this buffer.
 5990                          For keyed files, the key may be up to 255 bytes long
 5991                          and must be preceded by a byte that contains the
 5992                          length  of the key in number of bytes.  For
 5993                          indexed files, the  key is 1 to 255 bytes with no
 5994                          length byte; therefore the  key buffer must
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            163  
 5995                          contain the exact number of bytes for  the key.
 5996                          For IREL disk files, the key is 1 to 511 bytes with
 5997                          no size byte.  The key is composed of fields, in
 5998                          the order that they were defined for the key.
 5999                          Each field begins on a byte boundary.  The size
 6000                          of the key buffer determines the
 6001                          size of the key.  If the M$READ call altreturns
 6002                          with the error E$BADIRKEY, then the bad segment
 6003                          number will be in F$DCB.ARS#.
 6004                          For random, IDS, relative, unit record and
 6005                          consecutive files, and IREL labeled tape files,
 6006                          the key is
 6007                          a 4-byte binary granule or record number.
 6008                          The default is NIL.
 6009                          */
 6010
 6011            2 BUF_,
 6012              3 BOUND UBIN(20) UNAL %INIT(SIZEV(BUF))%CHARTEXT('/**/'),
 6013              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 6014              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 6015              3 BUF$ PTR %INIT(ADDR(BUF))%CHARTEXT('/**/'),
 6016                          /*K* BUF = VARIABLE     Locates
 6017                          the user's buffer into which data is to be read.
 6018                          BUF_ contains two subfields:  BOUND and BUF$.
 6019                          BOUND contains the size in bytes of the buffer
 6020                          minus one; BUF$ is a pointer to the start of the
 6021                          buffer.  See REREAD and SINPUTSIZE.
 6022                          */
 6023
 6024
 6025            2 STATION_ BIT(72) %INIT(VECTOR(%CHARTEXT(IDSTATION)))%CHARTEXT('/**/'),
 6026                          /*K* STATION = VARIABLE.  Locates a VLP_STATION that
 6027                          describes the station(s) and message type(s) that may
 6028                          be returned on this read to a comgroup.  If STATION
 6029                          is not specified on the read or in the DCB, "any
 6030                          station-type" is assumed.
 6031                          */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            164  
 6032            2 IDBUF_ REDEF STATION_ BIT(72),
 6033                          /*K* IDBUF = VARIABLE    Locates an area into which
 6034                          record identifiers are to be returned.  This area
 6035                          must be double-word aligned.  The first word will
 6036                          contain the number of record identifiers returned,
 6037                          and each word following will contain one record
 6038                          identifier.  See ID.
 6039
 6040                          The VLP_ID macro may be used to generate this
 6041                          area.
 6042                          */
 6043
 6044
 6045            2 V DALIGNED,
 6046              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 6047                          /*K* DCB=DCBNAME specifies the name of the DCB
 6048                          associated with the file.
 6049                          */
 6050              3 WAIT# BIT(1) %INIT(WAIT)%CHARTEXT('/**/') UNAL,
 6051                          /*K* WAIT= {YES|NO} is meaningful for random and
 6052                          IDS disk files with FULL=YES, device tape, comgroups, and
 6053                          communications devices or connections.  WAIT=YES specifies
 6054                          that the operation is to be completed  before control is
 6055                          returned to the user program. WAIT=NO   requests
 6056                          the monitor to transfer control to the next user
 6057                          statement after the read operation is started. If
 6058                          WAIT=NO,  the user typically uses the M$CHECK
 6059                          monitor service to  check the termination of the
 6060                          I/O operation or uses EVENT
 6061                          to receive control when the I/O operation
 6062                     terminates.  During I/O operations, the monitor protects the
 6063                     buffer from user access until the granule stamp has been
 6064                     verified.  (If the buffer is not on a page boundary, the
 6065                     monitor protects the data on any pages containing the
 6066                     buffer.)  While the I/O operation is outstanding, any
 6067                     attempt to change the user's page table such as issuing
 6068                     a service request for M$FDS, M$OLAY, or similar Memory
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            165  
 6069                     Management services results in an error unless EXMM
 6070                     privilege is active.  If an error is encountered when
 6071                     WAIT=NO, the alternate return from M$READ is
 6072                     taken  for all errors that do not  appear in the
 6073                     TYC field of the  DCB; the  alternate return from
 6074                     M$CHECK is taken from all errors that do appear
 6075                     in the TYC field of the DCB.
 6076                     Many I/O media complete the operation before
 6077                     returning control to the user's program
 6078                     regardless of the value of WAIT.  However,
 6079                     M$CHECK EVENT processing always takes place
 6080                     as just described.
 6081
 6082                     When used with communications devices or connections, a
 6083                     WAIT=NO read does not actually start at the terminal
 6084                     until the first incoming character for it is received.
 6085                     At that time, unless TRANS=YES is also specified,
 6086                     further output from the application is temporarily
 6087                     stopped, the prompt is displayed, and the input
 6088                     editing process begins.  When the input message is
 6089                     completed or times out, output continues.
 6090                     The default is YES.                                          */
 6091
 6092              3 KEYS# BIT(1) %INIT(KEYS)%CHARTEXT('/**/') UNAL,
 6093                          /*K* KEYS = {YES|NO} YES indicates that the
 6094                          user has specified in KEY the key of the record
 6095                          that is to be read.  If there is no such key, an
 6096                          error of E$NOKEY is given and the file is
 6097                          positioned to the record with the next greater
 6098                          existing key.  If KEYR is specified, the next
 6099                          greater existing key is returned.
 6100                          If NO, the next sequential record is read.
 6101                          This parameter is ignored for consecutive files
 6102                          and IREL labeled tape files.
 6103                          Note that a read on an alternate index must
 6104                          specify a key if the file is open SHARE=ALL.
 6105                          For FORM access, specifying the key on M$READ with
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            166  
 6106                          KEYS=YES indicates the field at which to initially
 6107                          position the cursor.  It does not affect the order
 6108                          in which the fields will be returned to the user,
 6109                          which is unpredictable.
 6110                          The default is NO.
 6111                          */
 6112
 6113
 6114              3 KEYR# BIT(1) %INIT(KEYR)%CHARTEXT('/**/') UNAL,
 6115                          /*K* KEYR = {YES|NO} YES specifies that the key of
 6116                          the record read is to be returned to the user in
 6117                          the buffer described by KEY.  If no record was
 6118                          located by the operation, the key returned will be
 6119                          the next higher existing key.  If there is no next
 6120                          key, then for KEYED files the length byte will be
 6121                          zero and for INDEXED and IREL files the entire key
 6122                          will be zero.  The default is NO.
 6123                          */
 6124
 6125
 6126              3 ID# BIT(1) %INIT(ID)%CHARTEXT('/**/'),
 6127                          /*K* ID = {YES|NO} YES specifies that for keyed,
 6128                          indexed, and IREL files only, the record identifier of
 6129                          the record accessed is to be returned into
 6130                          the area framed by the IDBUF parameter.  This
 6131                          area must be double-word aligned and must be at least
 6132                          two words long.  The first word will be set to
 6133                          the count of the number of record identifiers
 6134                          returned; the second word will contain
 6135                          the record identifier.  Each record in a given file
 6136                          has a unique identifier which may be used for any
 6137                          purpose such as enqueuing.  The default is NO.
 6138                          */
 6139
 6140              3 KEYCHNG# BIT(1) UNAL %INIT(KEYCHNG)%CHARTEXT('/**/'),
 6141                          /*K* KEYCHNG = {YES|NO}  For indexed and IREL disk
 6142                          files only.  YES specifies that, when reading an
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            167  
 6143                          alternate index with KEYS=NO, an error (E$KEYCHNG)
 6144                          is to be given if an attempt is made to read a
 6145                          record which has a key that is different from the
 6146                          key of the last record read.  The default is NO.
 6147                          */
 6148
 6149              3 FULL# BIT(1) %INIT(FULL)%CHARTEXT('/**/') UNAL,
 6150                          /*K* FULL= {YES|NO} YES specifies that the 1-word
 6151                          granule  header on random and IDS disk files is
 6152                          to be read into the  user buffer, giving 1024
 6153                          words per block.  FULL=NO    specifies a block size of
 6154                          1023   words, which does not include the header word.
 6155                          The default is NO.
 6156                          */
 6157
 6158              3 IDS# BIT(1) UNAL %INIT(IDS)%CHARTEXT('/**/'),
 6159                          /*K* IDS = {YES|NO}  YES indicates that positioning
 6160                          within a set of duplicate keys is to be by record
 6161                          identifier (as returned by the ID option).
 6162                          RECNUM will be ignored.
 6163                          The default is NO.                                      */
 6164
 6165              3 IOERROK# BIT(1) UNAL %INIT(IOERROK)%CHARTEXT('/**/'),
 6166                          /*K* IOERROK = {YES|NO} specifies robust tape I/O
 6167                          error handling for this read.  If an I/O error is detected
 6168                          while performing a read operation, and IOERROK is set
 6169                          (either here or via the option on FPT_OPEN), the read will
 6170                          complete successfully, using data from the partial tape
 6171                          block that
 6172                          was hit by the error.  TYC.IOERR is set in the DCB, and
 6173                          TYC.DI will be set if there is a data inconsistency or
 6174                          lost data (due to the record being truncated).
 6175                          F$DCB.BADARS# will contain the amount of data returned in
 6176                          the buffer that was gotten from the bad block.  Subsequent
 6177                          reads will continue to use data from the partial block,
 6178                          until it is exhausted.  The read that exhausts the block
 6179                     will return with TYC.IOERR again set.  TYC.DI will be set if
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            168  
 6180                     the affected record was truncated.  The next read will use
 6181                     data from the next good tape block.  If the first record in
 6182                     the
 6183                     block was continued from the previous (bad) block, TYC.DI
 6184                     will be set.  Processing continues from this point as usual.
 6185                     Note that skipping to the next good block may result in
 6186                     skipping one or more tape marks, and therefore reaching
 6187                     end-of-file unexpectedly or reaching a subsequent
 6188                     file.  For more information, see the description of the
 6189                     IOERROK option of FPT_OPEN, and the description of the DCB
 6190                     field BADARS#.
 6191                     */
 6192
 6193              3 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6194
 6195
 6196      %IF %TEXTCHAR(INDX) = '0';
 6197      %LSET KEYTYPEINDX = %TEXTCHAR(KEYTYPE);
 6198      %ELSE;
 6199      %LSET KEYTYPEINDX = %TEXTCHAR(INDX);
 6200      %ENDIF;
 6201              3 INDX# UBIN(9) UNAL %INIT(%CHARTEXT(KEYTYPEINDX))%CHARTEXT('/**/'),
 6202                          /*K* INDX = VALUE-DEC(0-80).
 6203                          Specifies, for indexed and IREL files only, a
 6204                          number indicating the index to be read.  Zero
 6205                          indicates the same index as the last operation, or
 6206                          the primary index if this is the first
 6207                          operation since the file was opened.
 6208                          One specifies the primary index.  Two specifies
 6209                          the first alternate index, etc.
 6210                          The default is zero.
 6211
 6212                          Note:  For alternate keyed files, file management
 6213                          maintains a pointer to the next key for each
 6214                          alternate index.  Reading with a primary key
 6215                          alters the pointer to the primary index but has no
 6216                          effect on the pointers to the alternate key indices
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            169  
 6217                          and vice versa.
 6218                          */
 6219
 6220              3 KEYTYPE# REDEF INDX# UBIN BYTE CALIGNED,
 6221                          /*K* KEYTYPE = {FLDID | COORD | NONE}
 6222                          .xeq KI_CP6_C M$MDFFLD KEYTYPE
 6223                          */
 6224              3 EVENT# SBIN %INIT(EVENT)%CHARTEXT('/**/'),
 6225                          /*K* EVENT = VALUE-DEC(0-?).
 6226                          If non-zero, specifies an event number
 6227                          to be reported to this user when this
 6228                          operation completes.  If zero, no event
 6229                          is reported.  EVENT is ignored (treated
 6230                          as if zero) unless WAIT=NO.
 6231
 6232                          If EVENT is non-zero, the
 6233                          event procedure established by M$EVENT is given
 6234                          control at completion of the read operation
 6235                          whether  an error occurred or not.  If an event
 6236                          control procedure is not established at the time
 6237                          the I/O completes, the user is aborted. If
 6238                          M$CHECK is also called, the alternate  return
 6239                          specified on that call is taken if any
 6240                          errors were reported in the TYC field of the DCB
 6241                          since  the last M$CHECK function.
 6242                          The default is zero.
 6243                          */
 6244              3 SEED# BIT(36) %INIT(SEED)%CHARTEXT('/**/'),
 6245                          /*K* SEED = VALUE-BIT(36) Specifies an octal or bit
 6246                          string which is to be used as the seed for
 6247                          decrypting this record.  Encryption is permitted
 6248                          for disk files except for those with a file
 6249                          organization of INDEXED or IREL.  Specifying a seed here
 6250                          overrides any seed set when the file was opened.  The
 6251                          default is '0'B.
 6252                          */
 6253              3 DVBYTE,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            170  
 6254                          /*B* DVBYTE. (Usually set at lower level BIT(9).
 6255                          specifies information controlling the method of
 6256                          reading the record.                                     */
 6257                4 TOP# BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6258                                    /* NOT VISIBLE TO THE FRONTEND - BE CAREFUL   */
 6259                4 BP# BIT(1) UNAL %INIT(BP)%CHARTEXT('/**/'),
 6260                          /*K* BP = {YES|NO} YES specifies, for ORG=SE devices
 6261                          only, that trailing blanks are to be considered in
 6262                          determining whether a record has been updated.  The
 6263                          effect of this option is quite considerable when the
 6264                          user moves the cursor down the right side of a screen
 6265                          full of short records.  The default is NO.              */
 6266                4 REREAD# BIT(1) UNAL %INIT(REREAD)%CHARTEXT('/**/'),
 6267                          /*K* REREAD = {YES|NO} applies to input originating
 6268                          from a time-sharing terminal.  REREAD=YES
 6269                          specifies that the last input  line is to be
 6270                          echoed and set to be the current input line.  The
 6271                          line to be echoed is either the last line typed
 6272                          by a time-sharing user, the line referenced
 6273                          via a call to the  M$SINPUT service
 6274                          ..::HL "(see Section 5)"
 6275                          or the line being passed on this M$READ via
 6276                          SINPUTSIZE.  The FPT field name for this parameter is
 6277                          FPT_READ.V.DVBYTE.REREAD#.  The default is NO.          */
 6278                4 VFC# REDEF REREAD# BIT(1),
 6279                4 BIN# BIT(1) UNAL %INIT(BIN)%CHARTEXT('/**/'),
 6280                          /*K* BIN = {YES|NO}  YES specifies that the data
 6281                          is present on the media as a string of bits
 6282                          rather than one character per 9 bit byte.
 6283                          (Used primarily for free tape.) The FPT field name
 6284                          for this parameter is FPT_READ.V.DVBYTE.BIN#.
 6285                          The default is NO.                                      */
 6286                4 TRANS# BIT(1) UNAL %INIT(TRANS)%CHARTEXT('/**/'),
 6287                          /*K* TRANS= {YES|NO} YES specifies transparency,
 6288                          i.e., that data is to be
 6289                          placed in the user buffer  without translation.
 6290                          This option is useful primarily for  devices which
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            171  
 6291                          normally perform translation (for instance,
 6292                          time-sharing terminals). The FPT field name for this
 6293                     parameter is FPT_READ.V.DVBYTE.TRANS#. The default is NO.    */
 6294                4 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6295                4 NODAT# BIT(1) UNAL %INIT(NODAT)%CHARTEXT('/**/'),
 6296                          /*K* NODAT = {YES|NO}  specifies that the
 6297                          user is to be informed if there is no data available
 6298                          instead of waiting for the data. This option is useful
 6299                          for these ORGs:  DBGCG, DBGDCB, DBGSYSID, FPRG,
 6300                          HANDLER, and also TERMINAL if ASN=COMGROUP.  If
 6301                          the read cannot be completed immediately, an error
 6302                          is returned instead of waiting for the data.
 6303                          The default is NO.
 6304                                                                                  */
 6305                4 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6306                4 CONT# BIT(1) UNAL %INIT(CONT)%CHARTEXT('/**/'),
 6307                          /*K* CONT= {YES|NO} specifies a continuation
 6308                          read.  CONT=YES is applicable only to consecutive,
 6309                          keyed, indexed, and IREL disk files;
 6310                          labeled tape formats F, V, D, S, C and K;
 6311                          and comgroups.
 6312                          CONT=YES is illegal if the file is compressed,
 6313                          encrypted.  If SHARE=ALL for a keyed, indexed, or
 6314                          IREL disk file, KEYS must be specified.  To
 6315                          perform multiple reads on a record, the user
 6316                          specifies  CONT=NO  for the first read, and
 6317                          CONT=YES for subsequent reads on the same record.
 6318                          CONT=YES causes data to be   read into the buffer
 6319                          continuing from the end of the last   move.
 6320                          When CONT=YES and the 'lost data' error is not
 6321                          reported, the record has been completely read.
 6322                          CONT=NO causes data to be moved to the buffer
 6323                          from  the next record, not  the current record.
 6324                          The FPT field name for this parameter is
 6325                          FPT_READ.V.DVBYTE.CONT#. The default is NO.             */
 6326              3 STRPVFC# BIT(1) UNAL %INIT(STRPVFC)%CHARTEXT('/**/'),
 6327                          /*K* STRPVFC = {YES|NO}  specifies that the VFC
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            172  
 6328                               character from the record, if it exists, is
 6329                               to be stripped from the record and stored
 6330                               in VFCCHAR# in the DCB.  The first byte
 6331                               returned in the record buffer will be the
 6332                               character after the VFC character.  The
 6333                               default is NO.
 6334                          */
 6335              3 ODFNC# UBIN(8) UNAL %INIT(ODFNC)%CHARTEXT('/**/'),
 6336                          /*K* ODFNC = {DATA|MAP}.  Specifies, for device reads
 6337                          of optical disks, precisely what function is to be
 6338                          performed.  ODFNC=DATA, the default, is for data reads of
 6339                          an optical disk platter, and is not currently supported.
 6340                          ODFNC=MAP is meant to be used by a special processor, and
 6341                          allows reading of the library directory table from the
 6342                          optical disk controller.  ODFNC=MAP may only be used if
 6343                          the OD device was opened with ASN=DEVICE and no SN.
 6344                                                                                  */
 6345
 6346              3 RECNUM# UBIN(18) UNAL %INIT(RECNUM)%CHARTEXT('/**/'),
 6347                          /*K* RECNUM = VALUE-DEC(0-262143).
 6348                          Specifies, for indexed and IREL files only, the record
 6349                          number desired within a group of records with
 6350                          duplicate keys.  Zero indicates no record number
 6351                          specified, which will give either the first
 6352                          or next record, depending on whether or not
 6353                          a key is specified.  If RECNUM is greater than 0,
 6354                          a key must also be specified or RECNUM will be
 6355                          ignored.  Within a list of duplicates, record
 6356                          numbers begin with 1;  e.g., if KEYS=YES and
 6357                          RECNUM=5, the fifth record in the list of
 6358                          duplicates will be read.  If the key exists and
 6359                          the value of RECNUM is greater than the number of
 6360                          duplicates on that key, an error of E$NOREC will
 6361                          be returned.
 6362                          The default is zero.
 6363                          */
 6364              3 SINPUTSIZE# UBIN(18) UNAL %INIT(SINPUTSIZE)%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            173  
 6365                          /*K* SINPUTSIZE = VALUE-DEC(0-2048).
 6366                          Specifies, for terminal devices only, the size
 6367                          of the data contained in BUF (to set the
 6368                          input to) before the read is performed.  If this
 6369                          value is zero the input will not be set.
 6370                          This parameter only has effect if REREAD=YES.
 6371                          The default is zero.
 6372                          */
 6373              3 REREADPOS# UBIN(18) UNAL %INIT(REREADPOS)%CHARTEXT('/**/'),
 6374                          /*K* REREADPOS = VALUE-DEC(0-2048).
 6375                          Specifies, for terminal devices only, the position
 6376                          on the device the cursor is to be placed for this
 6377                          read.  This parameter only has effect if SINPUTSIZE
 6378                          is nonzero.
 6379                          The default is zero.
 6380                          */
 6381              3 * UBIN UNAL %INIT(0)%CHARTEXT('/**/');
 6382           %MEND;
 6383
 6384
 6385                                    /************************************/
 6386                                    /**   M$WRITE- WRITE PROCEDURE     **/
 6387                                    /************************************/
 6388
 6389
 6390
 6391                          /*F* NAME: M$WRITE - Write Record.
 6392
 6393                          The M$WRITE service
 6394                          causes a data record stored in a buffer in memory to
 6395                          be written. The M$WRITE service is used for all types
 6396                          of files and devices for which output is appropriate.
 6397
 6398                          The user normally provides a buffer that is large
 6399                          enough to accommodate the maximum length record. To
 6400                          write records of varying sizes, the user adjusts the
 6401                          FPT field BUF_ which contains a vector: BUF_.BUF$
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            174  
 6402                          points to the start of the buffer and BUF_.BOUND
 6403                          specifies the record length in bytes minus 1. The user
 6404                          typically adjusts the BOUND field before writing each
 6405                          variable-length record to the record length minus 1.
 6406                          M$WRITE provides options comparable to the options
 6407                          available on the M$READ service.
 6408                          With continued M$WRITEs there is virtually no maximum
 6409                          record size except for comgroups, communications
 6410                          devices or connections, and FPRGs, for which the
 6411                          limit is 4096 characters.
 6412
 6413                          In addition, M$WRITE
 6414                          can accommodate format options particular to output:
 6415
 6416                          o The system normally removes trailing blanks from
 6417                          unit record and TERMINAL record output.   BP
 6418                          allows the user to retain trailing blanks in such
 6419                          output.
 6420
 6421                          o VFC specifies where the vertical format control
 6422                          information is to be obtained for this write:  in
 6423                          the first byte  of the buffer or from the DCB.
 6424
 6425                          o NEWKEY specifies whether writing of a new record
 6426                          with an existing key is to be reported as an error,
 6427                          or whether writing of a record for which there is
 6428                          no existing key is to be reported as an error.
 6429                          ONEWKEY causes a temporary override of NEWKEY=YES.
 6430
 6431                          o REWRITE allows rewriting a record in a
 6432                          consecutive  disk file while retaining all
 6433                          subsequent records  in the file.
 6434
 6435                          If M$WRITE specifies a closed DCB, the monitor
 6436                          attempts the M$OPEN service. If the open procedure is
 6437                          successful, the write is then performed.
 6438
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            175  
 6439                          For most files the user expects write completion
 6440                          before processing continues. When the WAIT=YES
 6441                          parameter is specified or is assumed by default, the
 6442                          normal return is taken when the write completes
 6443                          successfully. If an error occurs, the alternate return
 6444                          is taken with an error code reported. The error code
 6445                          reflects the first bit set in the DCB TYC field, if the
 6446                          write operation was actually started. The user may
 6447                          perform further tests on the DCB TYC field in the
 6448                          alternate return code sequence.  The user may specify
 6449                          WAIT=NO to request that processing continue at the
 6450                          next statement as soon as the write operation is
 6451                          started. In this case the user may call M$CHECK at a
 6452                          later point in the code. The   user may also specify
 6453                          EVENT to cause a procedure to be called when the I/O
 6454                          completes.
 6455
 6456                          If a write to a file with a VLP_RECFIELD definition
 6457                          altreturns with the error E$BADRFIELD or E$PARTFIELD,
 6458                          then the index into the VLP_RECFIELD field array for
 6459                          the field in error may be found in F$DCB.ARS#.
 6460
 6461                          The service call is of the form:
 6462
 6463                          CALL M$WRITE (FPT_WRITE) [ALTRET (label)];
 6464
 6465                          The parameters for the services are as follows:
 6466                          */
 6467
 6468
 6469       %MACRO FPT_WRITE  (FPTN=FPT_WRITE,
 6470              BUF=NIL,
 6471              KEY=NIL,
 6472              STATION=NIL,
 6473              IDBUF=NIL,
 6474              DCB=NIL,
 6475              WAIT(YES='1'B,NO='0'B)='1'B,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            176  
 6476              ID(YES='1'B,NO='0'B)='0'B,
 6477              CONT(YES='1'B,NO='0'B)='0'B,
 6478               RRR(YES='1'B,NO='0'B)='0'B,
 6479               NODAT(YES='1'B,NO='0'B)='0'B,
 6480              FULL(YES='1'B,NO='0'B)='0'B,
 6481              ONEWKEY(YES='1'B,NO='0'B)='1'B,
 6482              NEWKEY(YES='1'B,NO='0'B)='0'B,
 6483              REWRITE(YES='1'B,NO='0'B)='0'B,
 6484              NOTIME(YES='1'B,NO='0'B)='0'B,
 6485              IOERROK(YES='1'B,NO='0'B)='0'B,
 6486              EVENT=0,
 6487              SEED="'0'B",
 6488              VFC(YES='1'B,NO='0'B)='0'B,
 6489              BIN(YES='1'B,NO='0'B)='0'B,
 6490              BP(YES='1'B,NO='0'B)='0'B,
 6491              TRANS(YES='1'B,NO='0'B)='0'B,
 6492                KEYTYPE(FLDID=1,COORD=2,NONE=0)=0,
 6493              ODFNC(DATA=0,LABEL=1,COPY=2)=0,
 6494              STCLASS=STATIC);
 6495
 6496       %LSET LISTDIR='0'B;
 6497       %LSET LISTEXP='1'B;
 6498       %LSET LISTCOM='0'B;
 6499       %LSET LISTSUB='1'B;
 6500       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 6501       %IF (SUBSTR(STR,0,6)='STATIC') OR
 6502       (SUBSTR(STR,0,8)='CONSTANT') OR
 6503       (SUBSTR(STR,0,3)='EXT');
 6504       %LSET INIT=CHARTEXT('INIT');
 6505       %ELSE;
 6506       %LSET INIT=CHARTEXT('/*');
 6507       %ENDIF;
 6508      %IF (TEXTCHAR(STATION)~='NIL');
 6509      %LSET IDSTATION=TEXTCHAR(STATION);
 6510      %ERROR (TEXTCHAR(IDBUF)~='NIL', 'IDBUF ILLEGAL - STATION SPECIFIED');
 6511      %ELSE;
 6512      %LSET IDSTATION=TEXTCHAR(IDBUF);
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            177  
 6513      %ENDIF;
 6514
 6515
 6516      DCL 1 FPTN STCLASS,
 6517            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 6518            2 KEY_ BIT(72) %INIT(VECTOR(KEY))%CHARTEXT('/**/'),
 6519                          /*K* KEY = VARIABLE     Locates a key buffer associated
 6520                          with this  write operation.  If KEY is not
 6521                          specified, the record  is written at the current
 6522                          file location.  For keyed files, the key may
 6523                          be up to 255 bytes long and must be preceded by a
 6524                          byte that contains the length of the key  in
 6525                          number of bytes. For indexed and IREL files, the
 6526                          key is extracted from the user's buffer.
 6527                          Therefore, no key
 6528                          buffer is required to perform indexed writes since
 6529                          it will not be used.  For random, IDS, and
 6530                          relative files, the key is a 4-byte binary granule
 6531                          or record number.  The default is NIL.
 6532                          */
 6533
 6534            2 BUF_,
 6535              3 BOUND UBIN(20) UNAL %INIT(SIZEV(BUF))%CHARTEXT('/**/'),
 6536              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 6537              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 6538              3 BUF$ PTR %INIT(ADDR(BUF))%CHARTEXT('/**/'),
 6539                          /*K* BUF = VARIABLE      Locates
 6540                          the user's buffer from which data is to be
 6541                          written.  BUF_ contains two fields:  BOUND and BUF$.
 6542                          BOUND, which specifies the buffer size in bytes minus one,
 6543                          must be adjusted by the user when variable-length
 6544                          records are written. BUF$ is a pointer to the
 6545                          start of the buffer.
 6546
 6547                          If the file has a VLP_RECFIELD (or CODE18)
 6548                          definition and the record written is too short
 6549                          to contain all the fields in the definition,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            178  
 6550                          then zeroes will be assumed for the fields that
 6551                          are not contained in the buffer.  In this case,
 6552                          the buffer must not end in the middle of a field.
 6553
 6554                          If the organization of the file is indexed or
 6555                          IREL, then the buffer must be long enough to
 6556                          contain all the defined keys.
 6557                                                                                  */
 6558
 6559
 6560            2 STATION_ BIT(72) %INIT(VECTOR(%CHARTEXT(IDSTATION)))%CHARTEXT('/**/'),
 6561                          /*K* STATION = VARIABLE.  Locates a VLP_STATION that
 6562                          describes the destination station and the message type
 6563                          to be used on a write to a comgroup.  If STATION is not
 6564                          specified either on the write or in the DCB, the
 6565                          default is to use the values from the last I/O.
 6566                                                                                  */
 6567
 6568            2 IDBUF_ REDEF STATION_ BIT(72),
 6569                          /*K* IDBUF = VARIABLE    Locates an area into which
 6570                          record identifiers are to be returned.  Must be
 6571                          double-word aligned and at least two words long.
 6572                          The first word will contain the number
 6573                          of record identifiers returned, and each word following
 6574                          will contain one record identifier.  See ID.
 6575
 6576                          The VLP_ID macro may be used to generate this
 6577                          area.
 6578                          */
 6579
 6580
 6581            2 V DALIGNED,
 6582              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 6583                          /*K* DCB = DCBNAME specifies the DCB associated with the
 6584                          file.
 6585                          */
 6586              3 WAIT# BIT(1) %INIT(WAIT)%CHARTEXT('/**/') UNAL,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            179  
 6587                          /*K* WAIT = {YES|NO}  See M$READ, but only for disk
 6588                          and tape accesses.                                      */
 6589
 6590              3 * BIT(2) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6591
 6592              3 ID# BIT(1) %INIT(ID)%CHARTEXT('/**/'),
 6593                          /*K* ID = {YES|NO} YES indicates that the record
 6594                          identifier for the record being written is to be
 6595                          returned into the area framed by IDBUF.  Each
 6596                          record in a file has a unique identifier which
 6597                          may be used for any purpose such as enqueuing.
 6598                          ID is meaningful for keyed, indexed, and IREL
 6599                          files only.
 6600                          The default is NO.
 6601                          */
 6602
 6603              3 * BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 6604
 6605              3 FULL# BIT(1) %INIT(FULL)%CHARTEXT('/**/') UNAL,
 6606                          /*K* FULL = {YES|NO} YES specifies that the
 6607                          random or IDS file block size is 1024 words
 6608                          and that the user  supplies the first  data word
 6609                          in word 1 and leaves word 0 for the granule
 6610                          stamp. FULL=NO specifies that the   block size is 1023
 6611                          words, all of which contains user data.  The default
 6612                          is NO.
 6613                          */
 6614
 6615              3 * BIT(3) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6616
 6617
 6618              3 ONEWKEY# BIT(1) %INIT(ONEWKEY)%CHARTEXT('/**/') UNAL,
 6619                          /*K* ONEWKEY = {YES|NO} applies to KEYED, INDEXED,
 6620                          IREL, or
 6621                          RELATIVE  files only.  ONEWKEY=YES specifies that
 6622                          the NEWKEY  option is to be overridden.  That is,
 6623                          a record is written  with the specified
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            180  
 6624                          key whether it existed previously or not.
 6625                          ONEWKEY=NO specifies that NEWKEY is applicable.
 6626                          The default is YES.
 6627                          */
 6628
 6629
 6630              3 NEWKEY# BIT(1) %INIT(NEWKEY)%CHARTEXT('/**/') UNAL,
 6631                          /*K* NEWKEY = {YES|NO} applies to KEYED, INDEXED,
 6632                          IREL, and
 6633                          RELATIVE disk files only and is meaningful only if
 6634                          ONEWKEY is NO. NEWKEY=YES   specifies that the
 6635                          key is a new key in the file. That is, the   key
 6636                          of the record to be written must not already exist;
 6637                          if it does exist, an error (E$OLDREC) is reported.
 6638                          NEWKEY=NO specifies that the key is an old key in
 6639                          the file.   That is, a record with this key must
 6640                          already exist; if it does not exist, an error
 6641                          (E$NEWREC) is reported. The default is NO.
 6642                          */
 6643
 6644              3 REWRITE# BIT(1) %INIT(REWRITE)%CHARTEXT('/**/') UNAL,
 6645                          /*K* REWRITE = {YES|NO} applies to consecutive disk
 6646                          files only.  REWRITE=YES specifies that a
 6647                          currently existing record is to be rewritten.
 6648                          The previous operation must have been a read or
 6649                          position operation.  This option is intended for
 6650                          use when rewriting a record of the same size.  If
 6651                          the new record is shorter than the existing
 6652                          record, the original record size is maintained
 6653                          and the original data occupies the excess area.
 6654                          If the new record is longer than the existing
 6655                          record, the excess is truncated. An error (E$LD)
 6656                          is returned if one of these conditions occurs.
 6657                          REWRITE=NO specifies that the new record is to
 6658                          be written at the current file position and any
 6659                          records from this position to the end of the file
 6660                          are to be deleted.  The default is NO.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            181  
 6661                          */
 6662
 6663
 6664              3 NOTIME# BIT(1) %INIT(NOTIME)%CHARTEXT('/**/') UNAL,
 6665                          /*K* NOTIME = {YES|NO} applies to IDS files only.
 6666                          NOTIME=YES  specifies that the placing of the
 6667                          time stamp in the granule  is to be inhibited.
 6668                          Thus the first word in the granule  is available
 6669                          for user data.  The default is NO.
 6670                          */
 6671
 6672              3 IOERROK# BIT(1) %INIT(IOERROK)%CHARTEXT('/**/') UNAL,
 6673                          /*K* IOERROK = {YES|NO} Specifies robust tape I/O
 6674                          error handling for this write.  This effectively means
 6675                          that if an I/O error is detected, CVOL to the next tape in
 6676                          the tape set, if any.  If the user has CVOL control, this
 6677                          parameter will be ignored.  Note that such a CVOL will not
 6678                          be possible in all cases, such as when writing the first
 6679                     data block on a tape.  For more information, see the IOERROK
 6680                     option of FPT_OPEN.
 6681                     */
 6682
 6683              3 KEYTYPE# UBIN(4) %INIT(KEYTYPE)%CHARTEXT('/**/') UNAL,
 6684                          /*K* KEYTYPE = {FLDID|COORD|BIN10|BINHLF|BIN521|STRING}.
 6685                          .xeq F_DCB_C M$DCB KEYTYPE
 6686                          */
 6687
 6688              3 EVENT# SBIN %INIT(EVENT)%CHARTEXT('/**/'),
 6689                          /*K* EVENT = VALUE-DEC(0-?).  See M$READ.               */
 6690
 6691              3 SEED# BIT(36) %INIT(SEED)%CHARTEXT('/**/'),
 6692                          /*K* SEED = VALUE-BIT(1-36).
 6693                          .xeq F_CP6_C M$READ SEED
 6694                          */
 6695
 6696              3 DVBYTE,
 6697                          /*B* DVBYTE. (Usually set at lower level BIT(9)).
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            182  
 6698                          Specifies the format of the record being written        */
 6699                4 TOP# BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6700                                    /* NOT VISIBLE TO THE FRONTEND - BE CAREFUL   */
 6701                4 BP# BIT(1) UNAL %INIT(BP)%CHARTEXT('/**/'),
 6702                          /*K* BP = {YES|NO}  YES specifies that trailing blanks
 6703                          are not to be removed on devices which perform this
 6704                          operation most notably the timesharing terminal.
 6705                          NO, the default, specifies that blank stripping
 6706                          is to be performed. The FPT field name for this
 6707                     parameter is FPT_WRITE.V.DVBYTE.BP#.  The default is NO.     */
 6708                4 VFC# BIT(1) UNAL %INIT(VFC)%CHARTEXT('/**/'),
 6709                          /*K* VFC={YES|NO}  YES specifies that the first character
 6710                          of the record is to be interpreted as a vertical format
 6711                          control character.  Refer to the CP-6 Programmer
 6712                          Reference Manual for a list of VFC codes.  The FPT field
 6713                          name for this parameter is FPT_WRITE.V.DVBYTE.VFC#.
 6714                          The default is NO.                                      */
 6715                4 REREAD# REDEF VFC# BIT(1) UNAL,
 6716                4 BIN# BIT(1) UNAL %INIT(BIN)%CHARTEXT('/**/'),
 6717                          /*K* BIN = {YES|NO}  YES specifies that the data is to be
 6718                          presented to the media as a string of bits rather than
 6719                          one character per 9 bit byte. The FPT field name for
 6720                          this parameter is FPT_WRITE.V.DVBYTE.BIN#.
 6721                          The default is NO.                                      */
 6722                4 TRANS# BIT(1) UNAL %INIT(TRANS)%CHARTEXT('/**/'),
 6723                          /*K* TRANS = {YES|NO} YES specifies transparency, i.e.,
 6724                          that data  written to the medium is to be sent
 6725                          without translation if it is legal for the medium.
 6726                          (E.g., if it is a symbiont device, the form in use
 6727                          must be TRANS LGL.)  However, if the write is to
 6728                          a non-TRANS LGL form, as specified by means of a
 6729                          SUPER attribute, the appropriate translation is
 6730                          performed.
 6731
 6732                          If TRANS=NO the data is
 6733                          sent with the normal translation,  which is as
 6734                          follows.  For magnetic tape, translation to EBCDIC
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            183  
 6735                          occurs if EBCDIC=YES or CNVRT=YES was specified
 6736                          when the file was opened.  For unit record
 6737                          devices, blanks  replace any non-printable
 6738                          characters.   For TERMINAL organization, the
 6739                          handler performs translation  appropriate to the
 6740                          terminal type. The FPT field name for this parameter
 6741                          is FPT_WRITE.V.DVBYTE.TRANS#.  The default is NO.       */
 6742                4 RRR# BIT(1) UNAL %INIT(RRR)%CHARTEXT('/**/'),
 6743                     /*K* RRR = {YES|NO}  specifies, if YES, Return Receipt Request.
 6744                     This option specifies that the function is not complete
 6745                     until it reaches its destination correctly.  Functions
 6746                     to a user terminal are normally considered complete
 6747                     when the data leaves the user buffer.  There is no
 6748                     way to know if the data reached the terminal correctly
 6749                     or if any errors occurred performing the function.
 6750                     If RRR is set, the function is not considered complete
 6751                     until the data reaches the terminal and any error
 6752                     status has been returned.  The default is NO.
 6753                     */
 6754                4 NODAT# BIT(1) UNAL %INIT(NODAT)%CHARTEXT('/**/'),
 6755                          /*K* NODAT = {YES|NO}  specifies that the
 6756                          user is to be informed if there is no throttling available
 6757                          instead of waiting for the throttling (i.e., the
 6758                          other end is not accepting data).  This option is useful
 6759                          when communicating to either a terminal or a FPRG to
 6760                          avoid giving up control to do a write.  If the write
 6761                          can not be completed immediately, an error is
 6762                          returned.  The default is NO.
 6763                                                                                  */
 6764                4 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6765                4 CONT# BIT(1) UNAL %INIT(CONT)%CHARTEXT('/**/'),
 6766                          /*K* CONT = {YES|NO} specifies a continuation write.
 6767                          This option  is useful for writing very long
 6768                          records or for writing  data stored in various
 6769                          parts of memory without collecting  the data in a
 6770                     contiguous memory area. CONT=YES is applicable to comgroups;
 6771                     consecutive, keyed, indexed, and IREL disk and labeled
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            184  
 6772                     tape files; labeled tape in V format; and labeled
 6773                     and managed tape in D, S, and F format.  CONT=YES
 6774                     is illegal if the
 6775                     file is compressed, encrypted, a journal,
 6776                     or if SHARE=ALL on a non-comgroup file.
 6777                     To perform multiple writes for the same record,
 6778                     the user  specifies CONT=YES for all writes
 6779                     except the last write for  this record which
 6780                     must specify CONT=NO. If CONT=YES was specified    on
 6781                     the previous M$WRITE, the contents of BUF are appended
 6782                     to the current record.   For KEYED and
 6783                     INDEXED files the KEY parameter must
 6784                     be specified and must be the same for all
 6785                     writes to a single record.  For writes to a file
 6786                     with a VLP_RECFIELD definition, the portions of the
 6787                     continued record written must contain only whole
 6788                     fields.  The record is not allowed to end in the
 6789                     middle of a field.  CONT=NO
 6790                     specifies that the data to be written is the
 6791                     last or only portion of a record. The FPT field name for
 6792                     this parameter is FPT_WRITE.V.DVBYTE.CONT#.
 6793                     The default is NO.                                           */
 6794
 6795              3 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 6796
 6797              3 ODFNC# UBIN(8) UNAL %INIT(ODFNC)%CHARTEXT('/**/'),
 6798                     /*K* ODFNC = {DATA|LABEL|COPY}.  Specifies, for device writes
 6799                     to optical disks, precisely what function is to be
 6800                     performed.  ODFNC=DATA, the default, is for data writes to
 6801                     an optical disk platter, and is not currently supported.
 6802                     ODFNC=LABEL is meant to be used by the LABEL processor, and
 6803                     indicates that this is a disk-labeling operation.
 6804                     The DCB must be currently opened to an unlabeled
 6805                     optical disc volume.
 6806                     ODFNC=LABEL requires special privilege to perform.
 6807                     ODFNC=COPY indicates that the optical disc volume
 6808                     whose serial number is specified in the user buffer
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            185  
 6809                     is to be copied onto the unlabeled optical disc
 6810                     volume to which the DCB is currently opened.
 6811                      The volume specified by the user buffer serial
 6812                      number must be mounted for the current user at
 6813                      the time of the copy operation.
 6814                                                                             */
 6815              3 * UBIN(18) UNAL %INIT(0)%CHARTEXT('/**/');
 6816
 6817          %MEND;
 6818
 6819                                    /*************************************/
 6820                                    /**M$TRUNC- TRUNCATE BUFFERS PROC   **/
 6821                                    /*************************************/
 6822
 6823
 6824
 6825                          /*F* NAME: M$TRUNC - Truncate Buffers.
 6826
 6827                          The M$TRUNC service
 6828                          releases any blocking (POOL) buffers associated with a
 6829                          DCB after completion of any outstanding I/O
 6830                operations.  The M$TRUNC service applies to disk files; consecutive,
 6831           keyed, indexed, IREL, relative, and unit record files on labeled tape;
 6832           labeled tapes in V format; and labeled and managed
 6833           tapes in D, S, and F formats.
 6834           For any subsequent read or write operations for the
 6835           DCB, the system assigns blocking buffers automatically
 6836           as needed.
 6837
 6838           The service call is of the form:
 6839
 6840           CALL M$TRUNC (FPT_TRUNC) [ALTRET (label)];
 6841
 6842           The parameter for this service is as follows:
 6843           */
 6844
 6845
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            186  
 6846       %MACRO FPT_TRUNC  (FPTN=FPT_TRUNC,
 6847              STCLASS=STATIC,
 6848              DCB=NIL);
 6849
 6850       %LSET LISTDIR='0'B;
 6851       %LSET LISTEXP='1'B;
 6852       %LSET LISTCOM='0'B;
 6853       %LSET LISTSUB='1'B;
 6854       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 6855       %IF (SUBSTR(STR,0,6)='STATIC') OR
 6856       (SUBSTR(STR,0,8)='CONSTANT') OR
 6857       (SUBSTR(STR,0,3)='EXT');
 6858       %LSET INIT=CHARTEXT('INIT');
 6859       %ELSE;
 6860       %LSET INIT=CHARTEXT('/*');
 6861       %ENDIF;
 6862
 6863
 6864      DCL 1 FPTN STCLASS,
 6865            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 6866            2 V DALIGNED,
 6867              3 DCB# UBIN(18) %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 6868                          /*K* DCB = DCBNAME  specifies the DCB associated with
 6869                          the file.
 6870                          */
 6871              3 * BIT(54) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 6872          %MEND;
 6873
 6874                                    /**************************************/
 6875                                    /**M$CHECK- CHECK IO COMPLETION PROC **/
 6876                                    /**************************************/
 6877
 6878
 6879
 6880                          /*F* NAME: M$CHECK - Check I/O Completion.
 6881
 6882                          The M$CHECK service is
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            187  
 6883                          used in conjunction with read or write operations
 6884                          specifying WAIT=NO. The M$CHECK service waits for all
 6885                          outstanding I/O on this DCB to complete, then returns
 6886                          the combined status of all no-wait reads and writes
 6887                          issued since the last M$CHECK was issued.
 6888
 6889                          If no errors occurred, or if no no-wait I/O has been
 6890                          done since the last M$CHECK on this DCB, the normal
 6891                          return is taken.  The alternate return from
 6892                          M$CHECK is taken and the appropriate error code is
 6893                          placed in the TCB, if the type of completion is other
 6894                          than normal.
 6895
 6896                          Note:  I/O errors which are not reflected
 6897                          in the DCB type of  completion code (TYC) cause the
 6898                          alternate return from  the M$READ or M$WRITE service
 6899                          that attempted to initiate the I/O operation.
 6900
 6901                          The service call is of the form:
 6902
 6903                          CALL M$CHECK (FPT_CHECK) [ALTRET (label)];
 6904
 6905                          The parameter for this service is as follows:
 6906                          */
 6907
 6908       %MACRO FPT_CHECK  (FPTN=FPT_CHECK,
 6909              STCLASS=STATIC,
 6910              DCB=NIL);
 6911
 6912       %LSET LISTDIR='0'B;
 6913       %LSET LISTEXP='1'B;
 6914       %LSET LISTCOM='0'B;
 6915       %LSET LISTSUB='1'B;
 6916       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 6917       %IF (SUBSTR(STR,0,6)='STATIC') OR
 6918       (SUBSTR(STR,0,8)='CONSTANT') OR
 6919       (SUBSTR(STR,0,3)='EXT');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            188  
 6920       %LSET INIT=CHARTEXT('INIT');
 6921       %ELSE;
 6922       %LSET INIT=CHARTEXT('/*');
 6923       %ENDIF;
 6924
 6925
 6926      DCL 1 FPTN STCLASS,
 6927            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 6928            2 V DALIGNED,
 6929              3 DCB# UBIN(18) %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 6930                          /*K* DCB = DCBNAME  specifies the DCB associated with
 6931                          the file or device for which I/O completion is to be
 6932                          checked.
 6933                          */
 6934              3 * BIT(54) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 6935          %MEND;
 6936
 6937                                    /*************************************/
 6938                                    /**M$DELREC- DELETE RECORD PROCEDURE **/
 6939                                    /*************************************/
 6940
 6941                          /*F* NAME: M$DELREC - Delete Record.
 6942
 6943                          The M$DELREC service deletes one or more records
 6944                          from a CONSECUTIVE, KEYED, INDEXED, IREL, RELATIVE,
 6945                          RANDOM, or IDS disk file.  The user must have
 6946                          DELR permission to perform record deletion on a file
 6947                          (see VLP_ACCESS or VLP_ACSVEH macros for a discussion
 6948                          of file access permissions).  The deletion may be
 6949                          performed at the current record or, for all but
 6950                          CONSECUTIVE files, at a record
 6951                          specified by key.  Once a record is deleted, it cannot
 6952                          be read.  In most cases, a deleted record
 6953                          continues to occupy physical space on the medium until
 6954                          the file is copied over itself or for KEYED,
 6955                     INDEXED, and IREL files until another record is written in that
 6956                     location of the file.  However, if the last record is
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            189  
 6957                     deleted from a KEYED, INDEXED, or IREL file and the
 6958                     file is not shared, the file is reinitialized as though
 6959                     it had been newly created with zero records.
 6960
 6961                     For KEYED, INDEXED, IREL, or RELATIVE files the user may
 6962                     call M$DELREC specifying DCB and KEY to request
 6963                     positioning and deletion of the record specified by
 6964                     KEY. In addition, the user may supply the LKEY (last
 6965                     key) parameter to specify that records in the range KEY
 6966                     to LKEY are to be deleted. For files with alternate indices
 6967                     the user may also specify an ID or RECNUM to locate
 6968                     a duplicate key in an alternate index.  The
 6969                     ALLDUPS option allows deletion of all or part of
 6970                     a list of duplicate keys within an alternate index.
 6971                     In all cases, the M$DELREC
 6972                     service sets the ARS# field in the DCB to the number of
 6973                     records deleted. If LKEY is NIL or is less than KEY,
 6974                     only the record identified by KEY is deleted. It is
 6975                     not considered an error if there are no records in the
 6976                     range defined by KEY and LKEY; the file remains
 6977                     positioned to the record with the next higher key. If
 6978                     there is no record with the specified KEY and LKEY is
 6979                     not specified, the alternate return is taken; the file
 6980                     remains positioned to the record with the next higher
 6981                     key. Unless the DELALL parameter is set, if KEY is not
 6982                     specified or the file is
 6983                     CONSECUTIVE, then the previous operation must have
 6984                     been a successful M$READ or M$PRECORD, and the record
 6985                     read or positioned to is deleted.
 6986
 6987                     DELALL may be used to delete all records in a file.  If
 6988                     DELALL is specified, KEY, LKEY, IDBUF, RECNUM, and
 6989                     ALLDUPS are ignored.
 6990
 6991                     BRK may be specified in order to allow a potentially
 6992                     lengthy delete with range to be interrupted by a
 6993                     <BREAK> interrupt.  If it is not specified, such
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            190  
 6994                     interrupts are ignored until the operation completes.
 6995
 6996                     If the user calls M$DELREC specifying a DCB that is
 6997                     closed, the DCB is opened automatically using
 6998                     information currently available in the DCB.
 6999
 7000                     If M$DELREC is issued to a RANDOM or IDS file, then the
 7001                     block number specified by KEY, to  the range of blocks
 7002                     specified by KEY and LKEY, is overwritten.  An attempt
 7003                     to read those blocks will result in
 7004                     the same error that occurs when an attempt is made to
 7005                     read a block that has never been written.
 7006
 7007                     M$DELREC is ignored for labeled, managed, and free tapes.
 7008
 7009                     The service call is of the form:
 7010
 7011                     CALL M$DELREC (FPT_DELREC) [ALTRET (label)];
 7012
 7013                     The parameters for this service call are as follows:
 7014                     */
 7015       %MACRO FPT_DELREC   (FPTN=FPT_DELREC,
 7016              STCLASS=STATIC,
 7017              KEY=NIL,
 7018              LKEY=NIL,
 7019              IDBUF=NIL,
 7020              INDX=0,
 7021              RECNUM=0,
 7022              ALLDUPS(YES='1'B,NO='0'B)='0'B,
 7023              BRK(YES='1'B,NO='0'B)='0'B,
 7024              DELALL(YES='1'B,NO='0'B)='0'B,
 7025              DCB=NIL);
 7026
 7027       %LSET LISTDIR='0'B;
 7028       %LSET LISTEXP='1'B;
 7029       %LSET LISTCOM='0'B;
 7030       %LSET LISTSUB='1'B;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            191  
 7031       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7032       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7033       (SUBSTR(STR,0,8)='CONSTANT') OR
 7034       (SUBSTR(STR,0,3)='EXT');
 7035       %LSET INIT=CHARTEXT('INIT');
 7036       %ELSE;
 7037       %LSET INIT=CHARTEXT('/*');
 7038       %ENDIF;
 7039
 7040
 7041      DCL 1 FPTN STCLASS,
 7042            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7043            2 KEY_,
 7044              3 BOUND UBIN(20) UNAL %INIT(SIZEV(KEY))%CHARTEXT('/**/'),
 7045              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 7046              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 7047              3 KEY$ PTR %INIT(ADDR(KEY))%CHARTEXT('/**/'),
 7048                          /*K* KEY = VARIABLE     Locates a buffer containing the
 7049                          key of the record to be deleted or the first
 7050                          record in a range of records to be deleted.
 7051                          */
 7052
 7053            2 LKEY_,
 7054              3 BOUND UBIN(20) UNAL %INIT(SIZEV(LKEY))%CHARTEXT('/**/'),
 7055              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 7056              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 7057              3 LKEY$ PTR %INIT(ADDR(LKEY))%CHARTEXT('/**/'),
 7058                          /*K* LKEY = VARIABLE   Locates a buffer containing the
 7059                          key of the  last of a series of records to be
 7060                          deleted.
 7061                          */
 7062            2 IDBUF_ BIT(72) %INIT(VECTOR(IDBUF))%CHARTEXT('/**/'),
 7063                          /*K* IDBUF = VARIABLE    Locates an area which specifies
 7064                          a record identifier to locate a specific record in a list
 7065                          of duplicates.  If an IDBUF is specified, then RECNUM is
 7066                          ignored.  The area must be double-word aligned
 7067                          and at least two words long.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            192  
 7068
 7069                          The VLP_ID macro may be used to generate this
 7070                          area.
 7071                          */
 7072
 7073
 7074            2 V DALIGNED,
 7075              3 DCB# UBIN(18) %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 7076                     /*K* DCB = DCBNAME    specifies the DCB associated with the
 7077                     file.
 7078                     */
 7079
 7080              3 * BIT(9) %INIT('0'B)%CHARTEXT('/**/'),
 7081
 7082              3 INDX# UBIN(9) UNAL %INIT(INDX)%CHARTEXT('/**/'),
 7083                          /*K* INDX = VALUE-DEC(0-80).
 7084                          For indexed and IREL files only, specifies the
 7085                          index number of the key to delete.
 7086                          See M$READ.  The default is zero.
 7087                          */
 7088
 7089              3 RECNUM# UBIN(18) UNAL %INIT(RECNUM)%CHARTEXT('/**/'),
 7090                          /*K* RECNUM = VALUE-DEC(0-262143).
 7091                          For indexed and IREL files only, specifies the
 7092                          record number within a set of duplicate
 7093                          keys of the record to be deleted.  See M$READ.
 7094                          The default is zero.
 7095                          */
 7096
 7097              3 ALLDUPS# BIT(1) UNAL %INIT(ALLDUPS)%CHARTEXT('/**/'),
 7098                          /*K* ALLDUPS = {YES|NO}.
 7099                          Specifies that all duplicates of an alternate key,
 7100                          from the specified position to the end of the list
 7101                          of duplicates are to be deleted.
 7102                          */
 7103
 7104              3 BRK# BIT(1) UNAL %INIT(BRK)%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            193  
 7105                          /*K* BRK = {YES|NO} YES specifies that an external
 7106                          interrupt (such as a <BREAK>, <CNTL-Y>,
 7107                          user-supplied event, or operator keyin) is to be
 7108                          honored during the processing of a potentially
 7109                          long operation such as the deletion of a range of
 7110                          records.  If BRK=YES and such an interrupt is
 7111                          detected, deletion ceases immediately and the
 7112                          operation altreturns with an error of E$PMMEINT.
 7113                          If BRK=NO, such interrupts are deferred until the
 7114                          deletion is finished.  The default is NO.
 7115                          */
 7116
 7117              3 DELALL# BIT(1) UNAL %INIT(DELALL)%CHARTEXT('/**/'),
 7118                          /*K* DELALL = {YES|NO} YES specifies that all the
 7119                          records in a disk file are to be deleted.  In this
 7120                          case, the KEY, LKEY, IDBUF, RECNUM, and ALLDUPS
 7121                          parameters are ignored.  For Keyed, Indexed, and
 7122                          IREL files which are not open in a shared mode and
 7123                          for Consecutive files, the file is initialized as
 7124                          though it had been newly created with zero
 7125                          records.  For Keyed, Indexed, and IREL files which
 7126                          are open in a shared mode and for
 7127                          Relative, Random, and IDS files, DELALL=YES
 7128                          behaves as though a delete with range has been
 7129                          requested where the range includes all records in
 7130                          the file.  Journal files (Consecutive files opened
 7131                          with ACS=JRNL) are not affected by DELALL.  The
 7132                          default is NO.
 7133                          */
 7134
 7135              3 * BIT(15) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 7136          %MEND;
 7137
 7138                                    /*************************************/
 7139                                    /** M$PFIL  POSITION FILE PROCEDURE **/
 7140                                    /*************************************/
 7141
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            194  
 7142                          /*F* NAME: M$PFIL - Position File.
 7143
 7144                          The M$PFIL service causes
 7145                          positioning of the medium to the beginning or the end
 7146                of the current file.  For disk and labeled and managed tape files,
 7147                the position is set before the first record or beyond
 7148                the last record in the file. Free tapes are
 7149                positioned beyond the next file mark in either the
 7150                forward or reverse direction. If the user calls M$PFIL
 7151                with a closed DCB, the DCB is opened automatically
 7152                using the information currently in the DCB.
 7153
 7154                The service call is of the form:
 7155
 7156                CALL M$PFIL (FPT_PFIL) [ALTRET (label)];
 7157
 7158                The parameters for this service are as follows:
 7159                */
 7160       %MACRO FPT_PFIL  (FPTN=FPT_PFIL,
 7161              STCLASS=STATIC,
 7162              DCB=NIL,
 7163              INDX=0,
 7164              BOF(YES='1'B,NO='0'B)='0'B);
 7165
 7166       %LSET LISTDIR='0'B;
 7167       %LSET LISTEXP='1'B;
 7168       %LSET LISTCOM='0'B;
 7169       %LSET LISTSUB='1'B;
 7170       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7171       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7172       (SUBSTR(STR,0,8)='CONSTANT') OR
 7173       (SUBSTR(STR,0,3)='EXT');
 7174       %LSET INIT=CHARTEXT('INIT');
 7175       %ELSE;
 7176       %LSET INIT=CHARTEXT('/*');
 7177       %ENDIF;
 7178
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            195  
 7179
 7180      DCL 1 FPTN STCLASS,
 7181            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7182            2 V DALIGNED,
 7183              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 7184                          /*K* DCB = DCBNAME  specifies the DCB associated with
 7185                          the file  or device.
 7186                          */
 7187              3 BOF# BIT(1) %INIT(BOF)%CHARTEXT('/**/') UNAL,
 7188                          /*K* BOF = {YES|NO} BOF=YES specifies that the file is
 7189                          to be positioned at its beginning.  For free
 7190                          tapes,  the monitor positions the tape
 7191                          immediately before  the previous file mark or to
 7192                          beginning-of-tape if there is no previous file
 7193                          mark.  BOF=NO specifies that the file is to
 7194                          be positioned  to its end.  For  free tapes,
 7195                          the monitor positions  the tape immediately
 7196                          following the next file mark. If the monitor does
 7197                          not encounter a file mark on the device  tape,
 7198                          the tape will run off the end of the reel.
 7199                          The default is NO.
 7200                          */
 7201
 7202              3 * BIT(8) %INIT('0'B)%CHARTEXT('/**/'),
 7203
 7204              3 INDX# UBIN(9) UNAL %INIT(INDX)%CHARTEXT('/**/'),
 7205                          /*K* INDX = VALUE-DEC(0-511).
 7206                          For indexed and IREL files only, specifies the index
 7207                          number in which the positioning is to occur.
 7208                          See M$READ.  The default is zero.
 7209                          */
 7210
 7211              3 * BIT(36) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 7212          %MEND;
 7213                                    /************************************/
 7214                                    /** M$CVOL- CLOSE VOLUME PROCEDURE **/
 7215                                    /************************************/
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            196  
 7216
 7217                          /*F* NAME: M$CVOL - Close Volume.
 7218
 7219                          The M$CVOL service causes the
 7220                          monitor to terminate the reading or writing of data in the
 7221                          magnetic tape reel currently associated with a specific
 7222                          DCB, and to advance to the next reel of the data set.
 7223
 7224                     For free and managed tapes the current reel is closed and the
 7225                     next reel positioned to its beginning.
 7226
 7227                     For input files on labeled tape, the current file
 7228                     section is positioned to its end and determination
 7229                     made (by reading the following label group)
 7230                     of the existence of a subsequent file section.  If
 7231                     no such file section exists, M$CVOL will ALTRET with
 7232                     and end-of-file error and leave the current file
 7233                     positioned to its end.  If a subsequent file section
 7234                     exists, the current volume is dismounted and the next
 7235                     mounted and positioned to the first record of
 7236                     the next file section.  Any UTLs following the EOV
 7237                     label group are returned if UTL is specified.  Any UHLs
 7238                     following the HDR label group of the next file section
 7239                     are returned if UHL is specified.  Both UTLs and UHLs
 7240                     are returned in VLP_ULBL format.
 7241
 7242                     For output files on labeled and managed tape, the current file
 7243                     section is truncated after the last whole record.
 7244
 7245                     In addition, for output files on labeled tape, an
 7246                     EOV label is written followed by any UTLs
 7247                     specified by UTL.  The current volume is dismounted
 7248                     and the next mounted and positioned ready to write the
 7249                     next record of the file (first of the next file
 7250                     section) after writing necessary VOL1, HDR and UHL
 7251                     labels as required or specified by UHL.
 7252
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            197  
 7253                     Note: On input, UTLs and UHLs are returned to their
 7254                     separate buffers contiguously packed.  The first
 7255                     word of the user label areas will contain the number
 7256                     of labels of that type returned.  On output, UTLs
 7257                     and UHLs are written from the user's label buffers
 7258                     which are contiguously packed.  The first word of the
 7259                     user label areas will contain the number of labels of
 7260                     that type to write.  Any labels not containing the
 7261                     proper first three characters will cause termination
 7262                     of user label writing.
 7263
 7264                     CVOL control should only be used with unspanned tape
 7265                     files since spanned tape files may have records which
 7266                     cross volume boundaries.  These records are difficult
 7267                     to process if the user takes CVOL control.
 7268
 7269
 7270                     The form of the call for this service is as follows:
 7271
 7272                     CALL M$CVOL (FPT_CVOL)  [ALTRET (label)];
 7273
 7274                     The parameters for this service are as follows:              */
 7275
 7276       %MACRO FPT_CVOL  (FPTN=FPT_CVOL,
 7277              STCLASS=STATIC,
 7278              UTL=NIL,
 7279              UHL=NIL,
 7280              DCB=NIL);
 7281
 7282       %LSET LISTDIR='0'B;
 7283       %LSET LISTEXP='1'B;
 7284       %LSET LISTCOM='0'B;
 7285       %LSET LISTSUB='1'B;
 7286       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7287       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7288       (SUBSTR(STR,0,8)='CONSTANT') OR
 7289       (SUBSTR(STR,0,3)='EXT');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            198  
 7290       %LSET INIT=CHARTEXT('INIT');
 7291       %ELSE;
 7292       %LSET INIT=CHARTEXT('/*');
 7293       %ENDIF;
 7294
 7295
 7296      DCL 1 FPTN STCLASS,
 7297            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7298            2 UTL_ BIT(72) %INIT(VECTOR(UTL))%CHARTEXT('/**/'),
 7299                          /*K* UTL = VARIABLE
 7300                          .xeq F_CP6_C M$CLOSE UTL
 7301                          */
 7302            2 UHL_ BIT(72) %INIT(VECTOR(UHL))%CHARTEXT('/**/'),
 7303                          /*K* UHL = VARIABLE
 7304                          .xeq F_CP6_C M$OPEN UHL
 7305                          */
 7306            2 V DALIGNED,
 7307              3 DCB# UBIN(18) %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 7308                          /*K* DCB = DCBNAME  Specifies the DCB associated with
 7309                          the file.                                               */
 7310              3 * BIT(54) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 7311          %MEND;
 7312                                    /************************************/
 7313                                    /**     M$REW- REWIND PROCEDURE    **/
 7314                                    /************************************/
 7315
 7316
 7317
 7318                          /*F* NAME: M$REW - Rewind.
 7319
 7320                          The M$REW service applies
 7321                     to disk and tape.  For disk and labeled and managed tape files,
 7322                     M$REW positions to the beginning-of-file (just the
 7323                     same as M$PFIL with BOF=YES). For free tapes, M$REW
 7324                     rewinds to beginning-of-tape. If the user calls M$REW
 7325                     with a closed DCB, the DCB is opened automatically
 7326                     using the information currently in the DCB.  If no DCB
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            199  
 7327                     is
 7328                     specified, the serial number parameter specifies which
 7329                     tape volume to rewind.  The volume
 7330                     must currently belong to the user and cannot be open.
 7331
 7332                     The service call is of the form:
 7333
 7334                     CALL M$REW (FPT_REW) [ALTRET (label)];
 7335
 7336                     The parameter for this service is as follows:
 7337                     */
 7338
 7339       %MACRO FPT_REW  (FPTN=FPT_REW,
 7340              STCLASS=STATIC,
 7341              PSN=' ',
 7342              INDX=0,
 7343              DCB=NIL);
 7344
 7345       %LSET LISTDIR='0'B;
 7346       %LSET LISTEXP='1'B;
 7347       %LSET LISTCOM='0'B;
 7348       %LSET LISTSUB='1'B;
 7349       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7350       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7351       (SUBSTR(STR,0,8)='CONSTANT') OR
 7352       (SUBSTR(STR,0,3)='EXT');
 7353       %LSET INIT=CHARTEXT('INIT');
 7354       %ELSE;
 7355       %LSET INIT=CHARTEXT('/*');
 7356       %ENDIF;
 7357
 7358
 7359      DCL 1 FPTN STCLASS,
 7360            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7361            2 V DALIGNED,
 7362              3 DCB# UBIN(18) %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 7363                          /*K* DCB = DCBNAME  specifies the DCB associated with
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            200  
 7364                          the  disk or labeled tape file or with the device
 7365                          tape.
 7366                          */
 7367
 7368              3 * BIT(9) %INIT('0'B)%CHARTEXT('/**/'),
 7369
 7370              3 INDX# UBIN(9) UNAL %INIT(INDX)%CHARTEXT('/**/'),
 7371                          /*K* INDX = VALUE-DEC(0-511).
 7372                          For indexed and IREL files only, specifies the index
 7373                          number that is to be positioned.  See M$READ.
 7374                          The default is zero.
 7375                          */
 7376
 7377              3 * BIT(18) %INIT('0'B)%CHARTEXT('/**/'),
 7378
 7379              3 PSN# CHAR(6) UNAL %INIT(PSN)%CHARTEXT('/**/');
 7380                          /*K* PSN = VALUE-CHAR(6) specifies the serial number of
 7381                          the tape volume to rewind if no DCB is specified.
 7382                          */
 7383          %MEND;
 7384                                    /************************************/
 7385                                    /** M$WEOF- WRITE END OF FILE PROC **/
 7386                                    /************************************/
 7387
 7388
 7389
 7390                          /*F* NAME: M$WEOF - Write End-of-file
 7391
 7392                          The M$WEOF service is
 7393                          appropriate for only certain devices that require
 7394                          special end-of-file procedures. The M$WEOF service
 7395                          causes a file mark to be written on device tape.
 7396                          (For managed tape, the current buffer is truncated
 7397                          before the file mark is written.)
 7398                          If the user calls M$WEOF with a closed DCB, the DCB is
 7399                          opened automatically using the information currently
 7400                          in the DCB.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            201  
 7401
 7402                          The service call is of the form:
 7403
 7404                          CALL M$WEOF (FPT_WEOF) [ALTRET (label)];
 7405
 7406                          The parameter for this service is as follows:
 7407                          */
 7408
 7409       %MACRO FPT_WEOF  (FPTN=FPT_WEOF,
 7410              STCLASS=STATIC,
 7411              DCB=NIL);
 7412
 7413       %LSET LISTDIR='0'B;
 7414       %LSET LISTEXP='1'B;
 7415       %LSET LISTCOM='0'B;
 7416       %LSET LISTSUB='1'B;
 7417       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7418       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7419       (SUBSTR(STR,0,8)='CONSTANT') OR
 7420       (SUBSTR(STR,0,3)='EXT');
 7421       %LSET INIT=CHARTEXT('INIT');
 7422       %ELSE;
 7423       %LSET INIT=CHARTEXT('/*');
 7424       %ENDIF;
 7425
 7426
 7427      DCL 1 FPTN STCLASS,
 7428            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7429            2 V DALIGNED,
 7430              3 DCB# UBIN(18) %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 7431                          /*K* DCB = DCBNAME  specifies the DCB associated with
 7432                          the file or device.
 7433                          */
 7434              3 * BIT(54) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 7435          %MEND;
 7436
 7437
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            202  
 7438                                    /***************************************/
 7439                                    /*** M$PRECORD- POSITION RECORD PROC  **/
 7440                                    /***************************************/
 7441
 7442
 7443
 7444                          /*F* NAME: M$PRECORD - Position to Record.
 7445
 7446                          The M$PRECORD
 7447                          service permits the user to change position within a
 7448                          disk or tape file.  Based on
 7449                          the parameters supplied, the monitor positions by key
 7450                          or positions forward or backward by a specified number
 7451                          of records.
 7452
 7453                          Positioning by key applies to all files, with
 7454                          these exceptions:  consecutive files, unit
 7455                          record files, and IREL labeled tape files.
 7456                          To position
 7457                          by key the user specifies these parameters:  DCB, KEY,
 7458                          KEYS=YES, and optionally KEYR=YES, NEXTKEY=YES,
 7459                          and N.  If KEYR=YES
 7460                          the monitor returns the key of the record found,
 7461                          or if the requested key does not exist, it returns
 7462                          the next larger key.
 7463                          If N is also specified, the file is
 7464                          positioned by key and then forward or backward by
 7465                          the number of records specified by N.  If N is
 7466                          non-zero or if NEXTKEY=YES and the specified key
 7467                          does not exist, the E$NOKEY alternate return is
 7468                          suppressed.
 7469
 7470                          NOTE:  For keyed and indexed labeled tape files
 7471                          opened with ACS=DIRECT, and for disk files the
 7472                          M$PRECORD service with KEYS=YES searches the  entire
 7473                          file for a record with the specified key. If the key
 7474                          is not found, the file remains positioned to the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            203  
 7475                          record with the next higher key.  For keyed and
 7476                          indexed labeled
 7477                          tape files opened with ACS=SEQUEN, the file is
 7478                          searched in the forward direction;  the search is
 7479                          terminated if a key of equal value is found  or if
 7480                          end-of-file is reached.
 7481
 7482                          The user may request relative positioning by
 7483                          specifying KEYS=NO and N as the number of records to
 7484                          skip from the current position. The number of records
 7485                          to skip may be a positive number to move forward or a
 7486                          negative number to move backward .   At the
 7487                          time the M$PRECORD is called, current position is
 7488                          considered to be (1) the next record to be read if the
 7489                          previous operation was a read, (2) end-of-file if the
 7490                          previous operation was a write for a consecutive disk
 7491                          file or tape file, (3) the
 7492                          next record if the previous operation was a write for
 7493                          other disk files, and (4) the record which would be
 7494                          read next if the previous operation was a call to
 7495                          M$PRECORD or M$PFIL.  If the N parameter specifies a
 7496                          value which would cause positioning to the end of the
 7497                          file, then a normal return will be taken, and the file
 7498                          will be positioned such that the next read would return
 7499                          an end of file condition; if KEYR was specified, then
 7500                          no key would be returned.  If the N parameter specifies a
 7501                          value which would cause positioning beyond the limits
 7502                          of the file, the alternate return is taken; the file
 7503                          remains positioned before the first record or after
 7504                          the last record depending on the value of N.
 7505
 7506                          NOTE:  If the same FPT is used to position by key
 7507                          at times and relatively by number of records at
 7508                          other times, N must be cleared before positioning
 7509                          by key.
 7510
 7511                          After the relative positioning operation, the number of
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            204  
 7512                          records actually skipped is returned in the ARS# field
 7513                          of the DCB.
 7514
 7515                          The service call is of the form:
 7516
 7517                          CALL M$PRECORD (FPT_PRECORD) [ALTRET (label)];
 7518
 7519                          The parameters for this service are as follows:
 7520                          */
 7521
 7522       %MACRO FPT_PRECORD  (FPTN=FPT_PRECORD,
 7523              STCLASS=STATIC,
 7524              KEY=NIL,
 7525              IDBUF=NIL,
 7526              INDX=0,
 7527              DCB=NIL,
 7528              KEYS(YES='1'B,NO='0'B)='0'B,
 7529              KEYR(YES='1'B,NO='0'B)='0'B,
 7530              NEXTKEY(YES='1'B,NO='0'B)='0'B,
 7531              RECNUM=0,
 7532              BRK(YES='1'B,NO='0'B)='0'B,
 7533              ID(YES='1'B,NO='0'B)='0'B,
 7534              IDS(YES='1'B,NO='0'B)='0'B,
 7535              IDALL(YES='1'B,NO='0'B)='0'B,
 7536              IOERROK(YES='1'B,NO='0'B)='0'B,
 7537              BOF(YES='1'B,NO='0'B)='0'B,
 7538              EOF(YES='1'B,NO='0'B)='0'B,
 7539              NOMARKS(YES='1'B,NO='0'B)='0'B,
 7540              N=0);
 7541
 7542       %LSET LISTDIR='0'B;
 7543       %LSET LISTEXP='1'B;
 7544       %LSET LISTCOM='0'B;
 7545       %LSET LISTSUB='1'B;
 7546       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7547       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7548       (SUBSTR(STR,0,8)='CONSTANT') OR
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            205  
 7549       (SUBSTR(STR,0,3)='EXT');
 7550       %LSET INIT=CHARTEXT('INIT');
 7551       %ELSE;
 7552       %LSET INIT=CHARTEXT('/*');
 7553       %ENDIF;
 7554
 7555
 7556      DCL 1 FPTN STCLASS,
 7557            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7558            2 KEY_,
 7559              3 BOUND UBIN(20) UNAL %INIT(SIZEV(KEY))%CHARTEXT('/**/'),
 7560              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 7561              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 7562              3 KEY$ PTR %INIT(ADDR(KEY))%CHARTEXT('/**/'),
 7563                          /*K* KEY = VARIABLE     Locates a buffer which contains
 7564                          the key of  the record to be found in the
 7565                          positioning operation. If   KEYR=YES the monitor
 7566                          returns in this buffer the key of the  record
 7567                          found as a result of the positioning operation.
 7568                          */
 7569            2 IDBUF_ BIT(72) %INIT(VECTOR(IDBUF))%CHARTEXT('/**/'),
 7570                          /*K* IDBUF = VARIABLE    Locates an area into which
 7571                          record identifiers are to be returned.  Must be
 7572                          double-word aligned and at least two words long.
 7573                          The first word will contain the number
 7574                          of record identifiers returned, and each word following
 7575                          will contain one record identifier.  See ID and IDALL.
 7576
 7577                          If the ID or IDS options are used, then VLP_ID
 7578                          should be used to generate the area used for IDs.
 7579                          If IDALL is specified, the VLR_ID macro should be
 7580                          be used to generate the area.
 7581                          */
 7582
 7583            2 V DALIGNED,
 7584              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 7585                          /*K* DCB = DCBNAME specifies the DCB associated with the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            206  
 7586                          file.
 7587                                                                                  */
 7588              3 KEYS# BIT(1) %INIT(KEYS)%CHARTEXT('/**/') UNAL,
 7589                          /*K* KEYS = {YES|NO}  YES specifies that the file is
 7590                          to be positioned to the record with the key equal to
 7591                          the key specified by the KEY buffer, or if there
 7592                          is no such record to the record with the next
 7593                          greater key.  If KEYS=YES and N is other than zero,
 7594                          positioning according to N occurs after positioning
 7595                          by key.  KEYS is ignored for consecutive files
 7596                          and IREL labeled tape files.
 7597                          The default is NO.                                      */
 7598
 7599
 7600              3 KEYR# BIT(1) %INIT(KEYR)%CHARTEXT('/**/') UNAL,
 7601                          /*K* KEYR = {YES|NO} KEYR=YES specifies that the key of
 7602                          the record  found as a result of the positioning
 7603                          operation is to be  returned in the KEY buffer.
 7604                               If no key was located by the positioning
 7605                               operations, the key returned will be the key
 7606                               of the next higher existing key.  If there
 7607                               is no next key, then for KEYED files the
 7608                               length byte will be zero and for INDEXED and IREL
 7609                               files the entire key will be zero.
 7610                               The default is NO.
 7611                          */
 7612
 7613              3 ID# BIT(1) %INIT(ID)%CHARTEXT('/**/') UNAL,
 7614                          /*K* ID = {YES|NO} YES specifies that for keyed,
 7615                          indexed, and IREL files only, the
 7616                          record identifier of
 7617                          the record accessed is to be returned into
 7618                          the area framed by the IDBUF parameter.  This
 7619                          area must be double-word aligned and must be at least
 7620                          two words long.  The first word will be set to
 7621                          the count of the number of record identifiers
 7622                          returned; the second word will contain
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            207  
 7623                          the record identifier.  Each record in a given file
 7624                          has a unique identifier which may be used for
 7625                          any purpose such as enqueuing.  The default is NO.
 7626                          */
 7627
 7628              3 IDS# BIT(1) %INIT(IDS)%CHARTEXT('/**/') UNAL,
 7629                          /*K* IDS = {YES|NO}  YES indicates that positioning
 7630                          within a set of duplicate keys is to be by record
 7631                          identifier (as returned by the ID option).
 7632                          RECNUM will be ignored.
 7633                          The default is NO.                                      */
 7634
 7635              3 BOF# BIT(1) %INIT(BOF)%CHARTEXT('/**/') UNAL,
 7636                          /*K* BOF = {YES|NO}  YES specifies that the file
 7637                          is to be positioned to beginning-of-file before
 7638                          any other operation is performed.  In this case,
 7639                          KEYS, IDS, and RECNUM are ignored.  The default is
 7640                          NO.
 7641                          */
 7642
 7643              3 EOF# BIT(1) %INIT(EOF)%CHARTEXT('/**/') UNAL,
 7644                          /*K* EOF = {YES|NO}  YES specifies that the file
 7645                          is to be positioned to end-of-file before any
 7646                          other operation is performed.  In this case, KEYS,
 7647                          IDS, and RECNUM are ignored.  The default is NO.
 7648                          */
 7649
 7650              3 BRK# BIT(1) %INIT(BRK)%CHARTEXT('/**/') UNAL,
 7651                          /*K* BRK = {YES|NO} YES specifies that an external
 7652                          interrupt (such as a <BREAK>, <CNTL-Y>,
 7653                          user-supplied event, or operator keyin) is to be
 7654                          honored during the processing of a potentially
 7655                          long operation such as N > 0.  If BRK=YES and such
 7656                          an interrupt is detected, positioning ceases
 7657                          at the last record positioned to by the current
 7658                          operation and an altreturn with an error of
 7659                          E$PMMEINT is given.  If KEYR and/or ID are
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            208  
 7660                          specified, information is returned from the last
 7661                          record positioned to.  If BRK=NO, such
 7662                          interrupts are deferred until the positioning is
 7663                          finished.  The default is NO.
 7664                          */
 7665
 7666              3 IOERROK# BIT(1) %INIT(IOERROK)%CHARTEXT('/**/') UNAL,
 7667                          /*K* IOERROK = {YES|NO} Specifies robust tape I/O
 7668                          error handling for this position operation.  IOERROK for
 7669                          M$PRECORD is essentially the same as for M$READ, with the
 7670                          exception that no data is returned to the user.  When an
 7671                          I/O error is detected, no error is returned, and the
 7672                     position operation continues, using the data in the partial,
 7673                     "hit" block.  TYC bits are set as for M$READ.  The DCB field
 7674                     BADARS# will contain the number of records positioned past
 7675                     that were in the partial block.  For more information, see
 7676                     the IOERROK options of M$OPEN and M$READ.
 7677                     */
 7678
 7679              3 IDALL# BIT(1) %INIT(IDALL)%CHARTEXT('/**/') UNAL,
 7680                          /*K* IDALL = {YES|NO}  YES specifies that record
 7681                          identifiers for all records with the specified key
 7682                          are to be returned, instead of just the current
 7683                          record identifier.  If all of the
 7684                          record identifiers will not fit in IDBUF, then
 7685                          the first word of IDBUF will be the number of
 7686                          duplicate records, not the number of identifiers
 7687                          returned.  The default is NO.
 7688                          */
 7689
 7690              3 INDX# UBIN(9) UNAL %INIT(INDX)%CHARTEXT('/**/'),
 7691                          /*K* INDX = VALUE-DEC(0-511).
 7692                          For indexed and IREL files only, specifies the index
 7693                          number in which the positioning is to occur.
 7694                          See M$READ.  The default is zero.
 7695                          */
 7696
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            209  
 7697              3 N# SBIN %INIT(N)%CHARTEXT('/**/'),
 7698                          /*K* N = VALUE-DEC(1-?) specifies the number of
 7699                          records to  be skipped.  A positive number causes
 7700                          the file to be  positioned forward; a negative
 7701                          number causes the file  to be positioned
 7702                          backward.
 7703                          The default is 0.
 7704                          */
 7705
 7706              3 RECNUM# UBIN(18) UNAL %INIT(RECNUM)%CHARTEXT('/**/'),
 7707                          /*K* RECNUM = VALUE-DEC(0-262143).
 7708                          See M$READ.  The default is zero.
 7709                                     */
 7710
 7711              3 NEXTKEY# BIT(1) UNAL %INIT(NEXTKEY)%CHARTEXT('/**/'),
 7712                          /*K* NEXTKEY = {YES|NO}  YES specifies that, for
 7713                          a position-by-key operation (KEYS is YES), the
 7714                          file is to be positioned to the record with the
 7715                          next key greater than that specified by the KEY
 7716                          buffer.  If a record with that key exists, it is
 7717                          skipped, and the file is positioned to the next
 7718                          record.  If the specified key does not exist, the
 7719                          file is positioned to the record with the next
 7720                          greater key, and the E$NOKEY error is suppressed.
 7721
 7722                          If KEYS is not specified, this parameter is ignored.
 7723
 7724                          The default is NO.                                      */
 7725
 7726
 7727              3 NOMARKS# BIT(1) UNAL %INIT(NOMARKS)%CHARTEXT('/**/'),
 7728                          /*K* NOMARKS = {YES|NO}  YES specifies that, after
 7729                          positioning a tape to the location specified
 7730                          an EOF label is not written.
 7731
 7732                          The default is NO.                                      */
 7733
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            210  
 7734
 7735              3 * BIT(16) UNAL %INIT('0'B)%CHARTEXT('/**/');
 7736
 7737
 7738          %MEND;
 7739                          /*F*  NAME:  VLP_ID
 7740
 7741                          The VLP_ID macro creates an area to be used
 7742                          to either specify or return record
 7743                          identifiers.
 7744
 7745                          A record identifier is used to uniquely
 7746                          identify a single record within a set of
 7747                          duplicate keys along an alternate index.  A
 7748                          record identifier is specified to file
 7749                          management as a double-word.  The first word
 7750                          is the count of the number of identifiers.
 7751                          This field is ignored when specified to file
 7752                          management.  It is only used in conjunction
 7753                          with the IDALL option on M$PRECORD.  The
 7754                          second word is a unique record identifier
 7755                          that may be obtained from file management
 7756                          through M$READ, M$WRITE, or M$PRECORD.
 7757                          It may be used for any purpose, such as enqueuing.
 7758                          */
 7759
 7760      %MACRO VLP_ID (FPTN=VLP_ID,
 7761                     COUNT=1,
 7762                     ID=0,
 7763                     STCLASS=STATIC);
 7764
 7765      %LSET LISTDIR='0'B;
 7766      %LSET LISTEXP='1'B;
 7767      %LSET LISTCOM='0'B;
 7768      %LSET LISTSUB='1'B;
 7769      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7770      %IF (SUBSTR(STR,0,6)='STATIC') OR
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            211  
 7771       (SUBSTR(STR,0,8)='CONSTANT') OR
 7772       (SUBSTR(STR,0,3)='EXT');
 7773       %LSET INIT=CHARTEXT('INIT');
 7774      %ELSE;
 7775       %LSET INIT=CHARTEXT('/*');
 7776      %ENDIF;
 7777
 7778      DCL 1 FPTN STCLASS DALIGNED,
 7779            2 COUNT# UBIN %INIT(COUNT)%CHARTEXT('/**/'),
 7780                          /*K* COUNT = VALUE-DEC(0-n) specifies the number of record
 7781                               identifiers.  This value should always be 1 when
 7782                               IDS=YES.  The default is 1.                        */
 7783            2 ID# UBIN %INIT(ID)%CHARTEXT('/**/');
 7784                          /*K* ID = VALUE-DEC(0-n) specifies the record identifier
 7785                               to search for.                                     */
 7786      %MEND;
 7787
 7788                          /*F*  NAME:  VLR_ID
 7789
 7790                                The VLR_ID macro is used to generate an
 7791                                area to describe the values returned by
 7792                                the IDALL option for M$PRECORD.  After a
 7793                                call to M$PRECORD, the first word of the
 7794                                structure will contain a count of all the
 7795                                duplicate records for a particular key and
 7796                                index. The second and subsequent words will
 7797                                contain as many of the unique record
 7798                                identifiers for the duplicate records as
 7799                                will fit in the defined area.  The order
 7800                                in which record identifiers are placed in
 7801                                the area corresponds to the order the
 7802                                records were written to the file.
 7803                                */
 7804
 7805      %MACRO VLR_ID (FPTN=VLR_ID,
 7806                     %N=1,
 7807                     STCLASS=STATIC);
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            212  
 7808
 7809      %LSET LISTDIR='0'B;
 7810      %LSET LISTEXP='1'B;
 7811      %LSET LISTCOM='0'B;
 7812      %LSET LISTSUB='1'B;
 7813      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7814      %IF (SUBSTR(STR,0,6)='STATIC') OR
 7815       (SUBSTR(STR,0,8)='CONSTANT') OR
 7816       (SUBSTR(STR,0,3)='EXT');
 7817       %LSET INIT=CHARTEXT('INIT');
 7818      %ELSE;
 7819       %LSET INIT=CHARTEXT('/*');
 7820      %ENDIF;
 7821
 7822      DCL 1 FPTN STCLASS DALIGNED,
 7823            2 COUNT# UBIN %INIT(N)%CHARTEXT('/**/'),
 7824                          /*K* N = VALUE-DEC(0-n).
 7825                          Specifies the number of record identifiers that
 7826                          exist for the key.  It is used to initialize
 7827                          VLR_ID.COUNT#.  The default is 1.
 7828                          */
 7829
 7830            2 ID#(0:%(N-1)) UBIN %INIT(0*0)%CHARTEXT('/**/');
 7831                          /*K* ID = ARRAY VALUE-DEC(0-n).
 7832                          Is the array for record identifiers to be returned
 7833                          by file management.  The size of the array is
 7834                          specified by N.  If the storage class permits,
 7835                          array elements are always initialized to zero.
 7836                          */
 7837
 7838      %MEND;
 7839
 7840                                    /*********************************/
 7841                                    /** M$EXTEND - EXTEND FILE PROC **/
 7842                                    /*********************************/
 7843
 7844
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            213  
 7845
 7846                          /*F* NAME: M$EXTEND - EXTEND File.
 7847
 7848                          The M$EXTEND service
 7849                          allows the user to increase the size of a RANDOM, IDS,
 7850                          or RELATIVE disk file, or a COMGROUP.  (The user
 7851                          must have WNEW permission.) If the user calls the M$EXTEND
 7852                          service with a closed DCB, the DCB is opened
 7853                          automatically using information currently in the DCB.
 7854
 7855                          The service call is of the form:
 7856
 7857                          CALL M$EXTEND (FPT_EXTEND) [ALTRET (label)];
 7858
 7859                          The parameters for this service are as follows:
 7860                          */
 7861       %MACRO FPT_EXTEND (FPTN=FPT_EXTEND,
 7862              DCB=NIL,
 7863              STCLASS=STATIC,
 7864              SIZ=0);
 7865
 7866       %LSET LISTDIR='0'B;
 7867       %LSET LISTEXP='1'B;
 7868       %LSET LISTCOM='0'B;
 7869       %LSET LISTSUB='1'B;
 7870       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7871       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7872       (SUBSTR(STR,0,8)='CONSTANT') OR
 7873       (SUBSTR(STR,0,3)='EXT');
 7874       %LSET INIT=CHARTEXT('INIT');
 7875       %ELSE;
 7876       %LSET INIT=CHARTEXT('/*');
 7877       %ENDIF;
 7878
 7879
 7880      DCL 1 FPTN STCLASS,
 7881            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            214  
 7882            2 V DALIGNED,
 7883              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 7884                          /*K* DCB = DCBNAME  specifies the DCB associated with
 7885                          the file.
 7886                                                                                  */
 7887              3 SIZ# UBIN(18) UNAL %INIT(SIZ)%CHARTEXT('/**/'),
 7888                          /*K* SIZ = VALUE-DEC(1-?) specifies the number of
 7889                          units by which  the file size is to be increased.
 7890                          The units are granules for RANDOM files, IDS
 7891                          files, and COMGROUPS,
 7892                          and records for RELATIVE files.   The default is
 7893                          zero.
 7894                          */
 7895
 7896              3 * BIT(36) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 7897          %MEND;
 7898                                    /*****************************************/
 7899                                    /** M$DEVICE- CHANGE DEV ATTR PROCEDURE **/
 7900                                    /*****************************************/
 7901
 7902                          /*F* NAME: M$DEVICE - Change Device Attributes.
 7903
 7904                          The M$DEVICE service allows modification
 7905                          of formatting attributes while output is being created.
 7906                          A number of the
 7907                          options available on M$DEVICE override options which
 7908                          can be specified by the SET command, by M$DCB, or
 7909                          M$OPEN. In addition, the PAGE parameter may be used to
 7910                          leave part of a line printer page blank.
 7911
 7912                          The M$DEVICE service is appropriate for unit record
 7913                          data; the DCB may be associated with a resource device,
 7914                          a logical device, or a unit record file destined only
 7915                          for disk.
 7916
 7917                          The M$DEVICE service, when called without other
 7918                          options for a DCB with ORG=FORM or ORG=SE,
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            215  
 7919                          causes the screen display to be updated to include
 7920                          any changes requested since the last update.
 7921                          (Otherwise such updates occur only when M$READ is
 7922                          performed.)  When ORG=SE, M$DEVICE may also be
 7923                          used with the HDR option to set an end-of-file
 7924                          marker.
 7925
 7926                          The service call is of the form:
 7927
 7928                          CALL M$DEVICE (FPT_DEVICE) [ALTRET (label)];
 7929
 7930                          The parameters for the call are as follows:             */
 7931
 7932       %MACRO FPT_DEVICE (FPTN=FPT_DEVICE,
 7933              STCLASS=STATIC,
 7934              DCB=NIL,
 7935              TAB=NIL,
 7936              HDR=NIL,
 7937              SEQ(YES='1'B,NO='0'B)='01'B,
 7938              PAGE(YES='1'B,NO='0'B)='0'B,
 7939              CLEAR(YES='1'B,NO='0'B)='0'B,
 7940              SEQCOL=73,
 7941              SEQID=' ',
 7942              LINES=0,
 7943              DVFC="BINASC(0)");
 7944
 7945       %LSET LISTDIR='0'B;
 7946       %LSET LISTEXP='1'B;
 7947       %LSET LISTCOM='0'B;
 7948       %LSET LISTSUB='1'B;
 7949       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 7950       %IF (SUBSTR(STR,0,6)='STATIC') OR
 7951       (SUBSTR(STR,0,8)='CONSTANT') OR
 7952       (SUBSTR(STR,0,3)='EXT');
 7953       %LSET INIT=CHARTEXT('INIT');
 7954       %ELSE;
 7955       %LSET INIT=CHARTEXT('/*');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            216  
 7956       %ENDIF;
 7957
 7958
 7959
 7960      DCL 1 FPTN STCLASS,
 7961            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 7962            2 TAB_ BIT(72) %INIT(VECTOR(TAB))%CHARTEXT('/**/'),
 7963                          /*K* TAB = VARIABLE  Locates an area that contains the
 7964                          settings for horizontal tabulation.  This area
 7965                          may be generated by invoking the VLP_TAB macro.
 7966                          Tabulation may be discontinued by specifying
 7967                          TAB=ERASE.                                              */
 7968            2 HDR_ BIT(72) %INIT(VECTOR(HDR))%CHARTEXT('/**/'),
 7969                          /*K* HDR = VARIABLE     Locates an area containing the
 7970                          page header definition.  This area may be
 7971                          generated by invoking the VLP_HDR macro.  Page
 7972                          headings may be discontinued by specifying
 7973                          HDR=ERASE.
 7974
 7975                          When ORG=SE, HDR may frame a VLP_HDR area in which
 7976                          the TITLE field contains a character string to be
 7977                          used as the end-of-file marker.  (Specifying HDR
 7978                          or HDR=ERASE suppresses the screen-update function
 7979                          normally performed by M$DEVICE when ORG=SE.)
 7980                          */
 7981            2 V DALIGNED,
 7982              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 7983                          /*K* DCB = DCBNAME specifies the DCB associated with
 7984                          the unit record data.
 7985                                                                                  */
 7986
 7987              3 SEQ# BIT(2) UNAL %INIT(SEQ)%CHARTEXT('/**/'),
 7988                          /*K* SEQ = {YES|NO}  See M$OPEN.
 7989                          */
 7990              3 PAGE# BIT(1) UNAL %INIT(PAGE)%CHARTEXT('/**/'),
 7991                          /*K* PAGE = {YES|NO} PAGE=YES specifies that the rest
 7992                          of the current page is to be left blank.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            217  
 7993                          */
 7994              3 CLEAR# BIT(1) UNAL %INIT(CLEAR)%CHARTEXT('/**/'),
 7995                          /*K* CLEAR = {YES|NO} CLEAR=YES specifies that the rest
 7996                          of the current page is to be left blank.  If
 7997                          the "page" is really a screen, CLEAR=YES clears the
 7998                          current window and positions to its home position,
 7999                          even if it occupies the entire screen.                  */
 8000              3 * BIT(5) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 8001              3 SEQCOL# UBIN(9) UNAL %INIT(SEQCOL)%CHARTEXT('/**/'),
 8002                          /*K* SEQCOL = VALUE-DEC(1-255).  See M$OPEN.
 8003                          */
 8004              3 SEQID# CHAR(4) UNAL %INIT(SEQID)%CHARTEXT('/**/'),
 8005                          /*K* SEQID = VALUE-CHAR(4).  See M$OPEN.
 8006                          */
 8007              3 DVFC# CHAR(1) UNAL %INIT(DVFC)%CHARTEXT('/**/'),
 8008                          /*K* DVFC = VALUE-CHAR(1).  See M$OPEN.
 8009                          */
 8010              3 * UBIN(9)UNAL %INIT(0)%CHARTEXT('/**/'),
 8011              3 LINES# UBIN(18) UNAL %INIT(LINES)%CHARTEXT('/**/'),
 8012                          /*K* LINES = VALUE-DEC(1-32K).  See M$OPEN.
 8013                          */
 8014
 8015              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 8016
 8017
 8018          %MEND;
 8019                                    /*****************************************/
 8020                                    /** M$CORRES - CHECK DCB CORRESPONDENCE **/
 8021                                    /*****************************************/
 8022
 8023                          /*F* NAME: M$CORRES - Check DCB Correspondence.
 8024
 8025                          The DCB correspondence-checking routine
 8026                          allows a user to determine whether or not two DCBs
 8027                          are assigned to the same file or device.
 8028                          The routine returns normally if the two
 8029                          DCBs are uniquely assigned and takes the
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            218  
 8030                          alternate return if the DCBs are assigned to the
 8031                          same file or device.
 8032
 8033                          The service can be used, for example, by compilers to
 8034                          determine whether the DCB for listing output
 8035                          (M$LO) and the DCB for diagnostic output (M$DO)
 8036                          correspond to the same device, for example. If
 8037                          not, the compiler may write listing output through
 8038                          M$LO only and may write diagnostic output through
 8039                          M$LO and M$DO.
 8040
 8041                          The service call is of the form:
 8042
 8043                          CALL M$CORRES (FPT_CORRES) [ALTRET (label)];
 8044
 8045                          The parameters for this service are as follows:
 8046
 8047                          */
 8048       %MACRO FPT_CORRES     (FPTN=FPT_CORRES,
 8049              DCB1=NIL,
 8050              DCB2=NIL,
 8051              STCLASS=STATIC);
 8052
 8053       %LSET LISTDIR='0'B;
 8054       %LSET LISTEXP='1'B;
 8055       %LSET LISTCOM='0'B;
 8056       %LSET LISTSUB='1'B;
 8057       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8058       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8059       (SUBSTR(STR,0,8)='CONSTANT') OR
 8060       (SUBSTR(STR,0,3)='EXT');
 8061       %LSET INIT=CHARTEXT('INIT');
 8062       %ELSE;
 8063       %LSET INIT=CHARTEXT('/*');
 8064       %ENDIF;
 8065
 8066
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            219  
 8067      DCL 1 FPTN STCLASS,
 8068            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8069            2 V DALIGNED,
 8070              3 DCB1# UBIN(18) UNAL %INIT(DCBNUM(DCB1))%CHARTEXT('/**/'),
 8071                          /*K* DCB1 = DCBNAME  Name of first DCB.
 8072                                                                                  */
 8073              3 DCB2# UBIN(18) UNAL %INIT(DCBNUM(DCB2))%CHARTEXT('/**/');
 8074                          /*K* DCB2 = DCBNAME  Name of second DCB.
 8075                                                                                  */
 8076            %MEND;
 8077                          /*F* NAME: Message Reporting
 8078
 8079                          Message reporting may include communication to the
 8080                          system operator or user, reporting monitor error
 8081                          messages, and providing HELP informational messages.
 8082                          The monitor services provided for these purposes
 8083                          discussed below.
 8084                          */
 8085                                    /*******************************************/
 8086                                    /** M$KEYIN - Operator/user communication **/
 8087                                    /*******************************************/
 8088
 8089                          /*F* NAME: M$KEYIN - Operator/User Communication.
 8090
 8091                     The CP-6 system can interact with multiple operator consoles
 8092                     at different locations and ensure both proper
 8093                     console message switching and system security.
 8094                     Various designations such as SYSTEM
 8095                     cause messages to be routed to consoles
 8096                     designated responsible for the corresponding
 8097                     activity.
 8098
 8099                     The following discussion of M$KEYIN provides
 8100                     adequate information to send user messages and
 8101                     receive text replies. For detailed information on
 8102                     input parsing, see CP-6 Host Library Services Reference.
 8103                     For a discussion of KEYIN operations, see the CP-6
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            220  
 8104                     Operations Reference Manual.
 8105
 8106                     The M$KEYIN service causes a write, read, or
 8107                     write-followed-by-read (keyin) operation to be
 8108                     performed on an operator's console, and is the
 8109                     only service by which a user may communicate with
 8110                     an operator's console.
 8111
 8112                     The M$KEYIN monitor service will altreturn when a results
 8113                     field and the no-wait option are specified.
 8114                     The reason being, on a no-wait operation the
 8115                     TYC and the ARS# can be found in the no-wait I-O
 8116                     frame of the Task Control Block.
 8117
 8118                     The form of the call for this service is as
 8119                     follows:
 8120
 8121                     CALL M$KEYIN (FPT_KEYIN) [ALTRET(label)];
 8122
 8123                     The parameters for this service are as follows:              */
 8124       %MACRO FPT_KEYIN (FPTN=FPT_KEYIN,
 8125                MESS=NIL,
 8126                REPLY=NIL,
 8127                RESULTS=NIL,
 8128                WSN=' ',
 8129                EVENT=0,
 8130                WHO(W=0,D=1)=0,
 8131                OCTYPE(ADMIN=0,SYSTEM=1,DEVICE=2,LIBRN=3,COMM=4,TAPE=5,DISK=6,UNITREC=7,ADCOM=8,TP=9)=0,
 8132                DCB=NIL,
 8133                WAIT(YES='1'B,NO='0'B)='1'B,
 8134                STCLASS=STATIC);
 8135
 8136       %LSET LISTDIR='0'B;
 8137       %LSET LISTEXP='1'B;
 8138       %LSET LISTCOM='0'B;
 8139       %LSET LISTSUB='1'B;
 8140       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            221  
 8141       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8142       (SUBSTR(STR,0,8)='CONSTANT') OR
 8143       (SUBSTR(STR,0,3)='EXT');
 8144       %LSET INIT=CHARTEXT('INIT');
 8145       %ELSE;
 8146       %LSET INIT=CHARTEXT('/*');
 8147       %ENDIF;
 8148
 8149
 8150
 8151      DCL 1 FPTN STCLASS,
 8152            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8153            2 MESS_,
 8154              3 BOUND UBIN(20) UNAL %INIT(SIZEV (MESS))%CHARTEXT('/**/'),
 8155              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 8156              3 BUF$ PTR %INIT(ADDR (MESS))%CHARTEXT('/**/'),
 8157                          /*K* MESS = VARIABLE locates a buffer containing the
 8158                          message to be output to an operator's console.
 8159                          MESS=NIL means "don't write".  A maximum of 92 bytes
 8160                          can be sent to a console in a single M$KEYIN.  The
 8161                          text to be displayed is run through the system unit
 8162                          record (UR) translation tables to prevent unprintables
 8163                          from reaching the console (sometimes with dire effects).
 8164
 8165                          NOTE:  All text sent to consoles is translated
 8166                          to the 96 ASCII graphics and TAB with all other characters
 8167                          outside this set translated to space.
 8168                          */
 8169            2 REPLY_,
 8170              3 BOUND UBIN(20) UNAL %INIT(SIZEV (REPLY))%CHARTEXT('/**/'),
 8171              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 8172              3 BUF$ PTR %INIT(ADDR (REPLY))%CHARTEXT('/**/'),
 8173                          /*K* REPLY = VARIABLE locates the buffer to receive
 8174                          the operator's reply.  The REPLY is NIL means do not
 8175                          read.
 8176                                                                                  */
 8177            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            222  
 8178                          /*K* RESULTS = VARIABLE     locates 2-word buffer
 8179                          where TYC and ARS# are returned.
 8180                                                                                  */
 8181            2 V DALIGNED,
 8182              3 WSN# CHAR(8) %INIT(WSN)%CHARTEXT('/**/') UNAL,
 8183                          /*K* WSN = VALUE-CHAR(8) specifies the workstation name
 8184                          of the workstation to which this message is
 8185                          directed. WSN=' ' or WSN='LOCAL' implies the
 8186                          main computer site.  This parameter is meaningful
 8187                          only if WHO=W.                                          */
 8188              3 EVENT# SBIN %INIT(EVENT)%CHARTEXT('/**/') UNAL,
 8189                          /*K* EVENT = VALUE-DEC(0-?)  if non-zero, specifies
 8190                          an event identification to be returned to the
 8191                          user when this operation is complete.  If zero,
 8192                          no event is reported.  EVENT is ignored
 8193                          (treated as if it were zero) unless WAIT=NO.
 8194                          The default is zero.                                    */
 8195              3 WAIT# BIT(1) %INIT(WAIT)%CHARTEXT('/**/'),
 8196                          /*K* WAIT = {YES|NO} indicates whether or not this is a
 8197                          wait operation.  The default is YES.                    */
 8198              3 * UBIN(4) UNAL %INIT(0)%CHARTEXT('/**/'),
 8199              3 OCTYPE# UBIN(4) UNAL %INIT(OCTYPE)%CHARTEXT('/**/'),
 8200                          /*K* OCTYPE = OPTION   specifies the type of operator
 8201                          console when WHO=W.  The options are as follows:
 8202
 8203                          DEVICE^^^^specifies a console which receives
 8204                          messages about devices (e.g., ERROR,
 8205                          MOUNTs) and is allowed to perform device
 8206                          keyins (e.g., RETRY, MOUNT).
 8207
 8208                          SYSTEM^^^^specifies a console which receives
 8209                          messages about central site operations
 8210                          (e.g., JACK,JSON LOGGED ON), and is allowed
 8211                          to perform keyins pertaining to central site
 8212                          operations (e.g., ZAP, START CPU 1).
 8213
 8214                          ADMIN^^^^specifies a console that controls a
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            223  
 8215                          workstation ADMIN consoles can display and
 8216                          alter (e.g., PRIO) only their own
 8217                          workstation's jobs and can control users
 8218                          whose workstation of origin matches this
 8219                          console's WSN.
 8220
 8221                          TAPE^^^^specifies console attributes which
 8222                          presently have the same meaning as DEVICE.
 8223
 8224                          DISK^^^^specifies console attributes which
 8225                          presently have the same meaning as DEVICE.
 8226
 8227                          UNITREC^^^^specifies console attributes which
 8228                          presently have the same meaning as DEVICE.
 8229
 8230                          ADCOM^^^^specifies a console with administrative
 8231                          and communications attributes.
 8232
 8233                          TP^^^^specifies a console that deals with
 8234                          transaction processing related functions.
 8235                          For example, sending messages to TPAs and
 8236                          receiving messages about TP stations.
 8237
 8238                          The default is ADMIN.                                   */
 8239              3 WHO# UBIN BYTE %INIT(WHO)%CHARTEXT('/**/') UNAL,
 8240                          /*K* WHO = {W|D}  indicates whether the addressed
 8241                          console is one associated with a workstation (W)
 8242                          or a device (D).  W is the default.                     */
 8243              3 DCB# UBIN HALF %INIT(DCBNUM(DCB))%CHARTEXT('/**/') UNAL,
 8244                          /*K* DCB = DCBNAME specifies the name of the DCB
 8245                          associated with the device to which this message
 8246                          applies. In order for a message to be sent to
 8247                          a console in charge of a particular device the
 8248                          user must have a DCB open to the device and
 8249                          specify WHO=D.                                          */
 8250              3 * BIT(72) %INIT('0'B)%CHARTEXT('/**/');
 8251                                    /* reserved for future use                    */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            224  
 8252       %MEND;
 8253                               /*************************************************/
 8254                               /** M$LINES - Return remaining print lines proc **/
 8255                               /*************************************************/
 8256
 8257                          /*F* NAME: M$LINES - Remaining Print Lines Information.
 8258
 8259                          The M$LINES service allows a user to
 8260                          determine the current position of the printer page.
 8261                          The monitor service returns both the current page
 8262                          number and the number of lines remaining on the page.
 8263                          (The Forms Definition File defines page dimensions.)
 8264                          The M$LINES service is appropriate for a DCB associated
 8265                          with unit record data with line printer
 8266                          characteristics; the DCB may be associated with a
 8267                          logical device (including a time-sharing terminal with
 8268                          ORG=UR), a resource device, or a unit record file
 8269                          destined for disk only.
 8270
 8271                          The service call is of the form:
 8272
 8273                          CALL M$LINES (FPT_LINES) [ALTRET (label)];
 8274
 8275                          The parameters for this service are as follows:         */
 8276       %MACRO FPT_LINES (FPTN=FPT_LINES,
 8277              STCLASS=STATIC,
 8278              LINES=NIL,
 8279              DCB=NIL);
 8280
 8281       %LSET LISTDIR='0'B;
 8282       %LSET LISTEXP='1'B;
 8283       %LSET LISTCOM='0'B;
 8284       %LSET LISTSUB='1'B;
 8285       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8286       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8287       (SUBSTR(STR,0,8)='CONSTANT') OR
 8288       (SUBSTR(STR,0,3)='EXT');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            225  
 8289       %LSET INIT=CHARTEXT('INIT');
 8290       %ELSE;
 8291       %LSET INIT=CHARTEXT('/*');
 8292       %ENDIF;
 8293
 8294
 8295      DCL 1 FPTN STCLASS,
 8296            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8297            2 LINES_ BIT(72) %INIT(VECTOR(LINES))%CHARTEXT('/**/'),
 8298                          /*K* LINES = VARIABLE
 8299                          locates an area which may be generated   via the
 8300                          VLR_LINES macro which is explained next. The
 8301                          printer page number and current page position are
 8302                          returned in this area.                                  */
 8303            2 V DALIGNED,
 8304              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 8305
 8306                          /*K* DCB = DCBNAME specifies the DCB associated with
 8307                          the unit record data.                                   */
 8308
 8309              3 * BIT(54)UNAL %INIT('0'B)%CHARTEXT('/**/');
 8310          %MEND;
 8311                          /*F* NAME:  VLR_LINES
 8312
 8313                          The VLR_LINES macro defines an area into which the
 8314                          M$LINES monitor service places the printer page
 8315                          position information. The area generated by this macro
 8316                          contains the following fields:                          */
 8317       %MACRO VLR_LINES (FPTN=VLR_LINES,STCLASS=STATIC);
 8318
 8319       %LSET LISTDIR='0'B;
 8320       %LSET LISTEXP='1'B;
 8321       %LSET LISTCOM='0'B;
 8322       %LSET LISTSUB='1'B;
 8323       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8324       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8325       (SUBSTR(STR,0,8)='CONSTANT') OR
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            226  
 8326       (SUBSTR(STR,0,3)='EXT');
 8327       %LSET INIT=CHARTEXT('INIT');
 8328       %ELSE;
 8329       %LSET INIT=CHARTEXT('/*');
 8330       %ENDIF;
 8331
 8332      DCL 1 FPTN STCLASS DALIGNED,
 8333            2 RLINES# SBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 8334                          /*K* RLINES = VALUE-DEC(0-?)  Contains
 8335                          the number of
 8336                          print lines remaining on the current page.
 8337                          RLINES is zero, if it is no longer possible to
 8338                          print on the current page, for instance, if the
 8339                          user called M$DEVICE with PAGE=YES.  If the DCB
 8340                          is not associated with a device with line
 8341                          printer characteristics, RLINES is set to minus
 8342                          one.                                                    */
 8343            2 PAGE# UBIN(18)UNAL %INIT(0)%CHARTEXT('/**/'),
 8344                          /*K* PAGE = VALUE-DEC(0-?)  Contains the current
 8345                          printer page number.  If nothing has yet been
 8346                          printed, this field is zero and RLINES is zero.         */
 8347            2 * UBIN %INIT(0)%CHARTEXT('/**/');
 8348       %MEND;
 8349                                    /************************************/
 8350                                    /**  M$GETDCB- BUILD DCB PROCEDURE **/
 8351                                    /************************************/
 8352
 8353                          /*F* NAME: M$GETDCB - Build DCB.
 8354
 8355                          The M$GETDCB service allocates a DCB.  The M$GETDCB
 8356                          service returns the DCB number for the DCB which
 8357                          is built. If a DCB of the name specified already
 8358                          exists, its DCB number is returned as if it had
 8359                          been built.
 8360
 8361                            The M$GETDCB service call is of the form:
 8362
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            227  
 8363                                CALL M$GETDCB (FPT_GETDCB) [ALTRET (label)];
 8364
 8365                          The parameters for this service are as follows:         */
 8366       %MACRO FPT_GETDCB (FPTN=FPT_GETDCB,
 8367              DCBNAME=NIL,
 8368              DCBNUM=NIL,
 8369              DCB=0,
 8370             STCLASS=STATIC,
 8371             TEST(YES='1'B,NO='0'B)='0'B,
 8372              MERGE(YES='1'B,NO='0'B)='0'B);
 8373
 8374       %LSET LISTDIR='0'B;
 8375       %LSET LISTEXP='1'B;
 8376       %LSET LISTCOM='0'B;
 8377       %LSET LISTSUB='1'B;
 8378       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8379       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8380       (SUBSTR(STR,0,8)='CONSTANT') OR
 8381       (SUBSTR(STR,0,3)='EXT');
 8382       %LSET INIT=CHARTEXT('INIT');
 8383       %ELSE;
 8384       %LSET INIT=CHARTEXT('/*');
 8385       %ENDIF;
 8386
 8387
 8388      DCL 1 FPTN STCLASS,
 8389            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8390            2 DCBNAME_ BIT(72) %INIT(VECTOR(DCBNAME))%CHARTEXT('/**/'),
 8391                     /*K* DCBNAME = VARIABLE  Locates an area containing the name
 8392                     of the DCB to be obtained. This area may be generated by
 8393                     invoking the VLP_NAME macro which is described later in this
 8394                     section.
 8395                          */
 8396            2 DCBNUM_ BIT(72) %INIT(VECTOR(DCBNUM))%CHARTEXT('/**/'),
 8397                /*K* DCBNUM = VARIABLE     Locates either a half-word or a 1-word
 8398                area into which the M$GETDCB service returns the number of the
 8399                DCB allocated for or
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            228  
 8400                corresponding to DCBNAME.
 8401                */
 8402            2 V DALIGNED,
 8403              3 DCB# UBIN(18) UNAL %INIT(DCB)%CHARTEXT('/**/'),
 8404                     /*K* DCB = VALUE-DEC(5-9). This parameter is used to request
 8405                     the allocation of a system DCB (5-9) by special shared
 8406                     processors only.
 8407                                                                                  */
 8408              3 MERGE# BIT(1) %INIT(MERGE)%CHARTEXT('/**/') UNAL,
 8409                          /*K* MERGE = {YES|NO} YES specifies that any assignment
 8410                          (!SET command) for this DCB is to be merged into it if it
 8411                          is created.  The default is NO.                         */
 8412              3 TEST# BIT(1) %INIT(TEST)%CHARTEXT('/**/') UNAL,
 8413                          /*K* TEST = {YES|NO} YES specifies that no DCB is to
 8414                          built if the specified DCB does not already exist.
 8415                          Instead, M$GETDCB returns a zero DCB number.
 8416                          The default is NO.                                      */
 8417              3 * BIT(52) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 8418          %MEND;
 8419                                    /********************************/
 8420                                    /** M$RELDCB- RELEASE DCB PROC **/
 8421                                    /********************************/
 8422
 8423                          /*F* NAME: M$RELDCB - Release Closed DCB.
 8424
 8425                          This service releases a DCB's Read-Only segment
 8426                          space and deletes the DCB from the DCB pointer
 8427                          table. Any user DCB may be released, regardless
 8428                          of how it was obtained. However, a DCB must be
 8429                          closed before M$RELDCB is called. Once released,
 8430                          the DCB and its DCB number are invalid for monitor
 8431                          service calls. The DCB number can be obtained by
 8432                          calling the M$GETDCB service.
 8433
 8434                            The service call is of the form:
 8435
 8436                            CALL M$RELDCB (FPT_RELDCB) [ALTRET (label)];
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            229  
 8437
 8438                          The parameter for the service is as follows:
 8439
 8440                                                                             */
 8441       %MACRO FPT_RELDCB (FPTN=FPT_RELDCB,
 8442              STCLASS=STATIC,
 8443              DCB=0);
 8444
 8445       %LSET LISTDIR='0'B;
 8446       %LSET LISTEXP='1'B;
 8447       %LSET LISTCOM='0'B;
 8448       %LSET LISTSUB='1'B;
 8449       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8450       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8451       (SUBSTR(STR,0,8)='CONSTANT') OR
 8452       (SUBSTR(STR,0,3)='EXT');
 8453       %LSET INIT=CHARTEXT('INIT');
 8454       %ELSE;
 8455       %LSET INIT=CHARTEXT('/*');
 8456       %ENDIF;
 8457
 8458
 8459      DCL 1 FPTN STCLASS,
 8460            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8461            2 V DALIGNED,
 8462              3 DCB# UBIN(18) UNAL %INIT(DCB)%CHARTEXT('/**/'),
 8463                          /*K* DCB = VALUE-DEC(5-?).  Specifies the number
 8464                          of the DCB to be released.  System DCBs(1-4)
 8465                          may not be released.  Only shared processors may
 8466                          release special DCBs (5-9).            Others
 8467                          may be released as desired.  A DCB need not have
 8468                          been defined via a GETDCB in order to be released.
 8469                          The DCB must be closed in order for it to be released.
 8470                          */
 8471              3 * BIT(54) %INIT('0'B)%CHARTEXT('/**/') UNAL;
 8472          %MEND;
 8473                                    /********************************************/
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            230  
 8474                                    /** M$REM - Remove or release tape volume **/
 8475                                    /********************************************/
 8476
 8477
 8478                          /*F* NAME: M$REM - Remove or Release Volume.
 8479
 8480                          The M$REM service permits
 8481                          a tape volume to be dismounted and optionally permits
 8482                          its respective resource to be released by its
 8483                          volume number.
 8484
 8485                          There is no DCB associated with an M$REM call.
 8486                          The specified tape volume must belong to the user
 8487                          and cannot currently be open.
 8488
 8489                          The form of the call for this service is as follows:
 8490
 8491                          CALL M$REM(FPT_REM) [ALTRET (label)];
 8492
 8493                          The parameters for this service are as follows:         */
 8494
 8495       %MACRO FPT_REM (FPTN=FPT_REM,
 8496                    STCLASS=STATIC,
 8497                    PSN=' ',
 8498                    DISP(REM=2,REL=3,PTV=4)=0);
 8499
 8500       %LSET LISTDIR='0'B;
 8501       %LSET LISTEXP='1'B;
 8502       %LSET LISTCOM='0'B;
 8503       %LSET LISTSUB='1'B;
 8504       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8505       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8506       (SUBSTR(STR,0,8)='CONSTANT') OR
 8507       (SUBSTR(STR,0,3)='EXT');
 8508       %LSET INIT=CHARTEXT('INIT');
 8509       %ELSE;
 8510       %LSET INIT=CHARTEXT('/*');
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            231  
 8511       %ENDIF;
 8512
 8513
 8514      DCL 1 FPTN STCLASS,
 8515            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8516            2 V DALIGNED,
 8517              3 DISP# UBIN BYTE UNAL %INIT(DISP)%CHARTEXT('/**/'),
 8518                          /*K* DISP = OPTION Specifies the action to be
 8519                          performed:
 8520
 8521                          REM   Remove specified volume.
 8522
 8523                          REL   Remove specified volume and release
 8524                           associated resource.
 8525
 8526                          PTV   Rewind volume only.
 8527
 8528                          The default is REM.                                     */
 8529              3 * BIT(9) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* Must look like M$REW FPT */
 8530              3 PSN# CHAR(6) UNAL %INIT(PSN)%CHARTEXT('/**/');
 8531                          /*K* PSN = VALUE-CHAR(6). The serial number of the volume
 8532                          to be removed.                                          */
 8533
 8534       %MEND;
 8535
 8536
 8537                          /*******************************************************/
 8538                          /** M$LIMIT - OBTAIN RESOURCES FOR THE CURRENT USER   **/
 8539                          /** M$MBS - OBTAIN RESOURCES FOR A NEW BATCH USER     **/
 8540                          /** M$DISPRES - RETURN CURRENTLY OWNED RESOURCES      **/
 8541                          /** M$RELRES - RELEASE RESOURCES OWNED BY THE USER    **/
 8542                          /** M$REQUIRE - REQUIRE USER TO HAVE PSEUDO RESOURCES **/
 8543                          /*******************************************************/
 8544
 8545
 8546                          /*F* NAME: M$LIMIT - Get RES for Current User.
 8547
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            232  
 8548                          The M$LIMIT service is usable
 8549                     only by command processors to obtain resources for a running
 8550                     user, usually as a result of an online or job-step
 8551                     !RESOURCE command.
 8552
 8553                     The form of the call for this service is as follows:
 8554
 8555                     CALL M$LIMIT (FPT_RESCTL) [ALTRET (label)];
 8556
 8557                     The parameters for this service are as follows:
 8558                     */
 8559                          /*K* PRES = VARIABLE   locates an area which describes
 8560                          the physical resources to be manipulated. This area
 8561                          can be generated by invoking the VLP_PRES macro.
 8562                          The default is NIL.                                     */
 8563                          /*K* PSEUDO = VARIABLE   locates an area which
 8564                          describes the pseudo resources to be manipulated.
 8565                          This area can be generated by invoking the VLP_PSEUDO
 8566                          macro. The default is NIL.                              */
 8567                          /*K* RPSN = VARIABLE   locates an area which
 8568                          describes the pack sets to be manipulated. This area
 8569                          can be generated by invoking the VLP_RPSN macro.
 8570                          The default is NIL.                                     */
 8571
 8572                          /*F* NAME: M$MBS - Get RES for New Batch User
 8573
 8574                          The M$MBS service is used only by the Multi-Batch
 8575                          Scheduler (MBS). This service obtains
 8576                          the specified resources if MBSDISP=NO. If
 8577                          MBSDISP=YES, available resources are returned
 8578                          in the areas specified by PRES, PSEUDO, and
 8579                          RPSN for the specified system.
 8580
 8581                          The form of the call for this service is:
 8582
 8583                          CALL M$MBS (FPT_RESCTL) [ALTRET(label)];
 8584
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            233  
 8585                          The parameters for this service are as follows:
 8586                          */
 8587                          /*K* MBSDISP = {YES|NO}   YES specifies that available
 8588                          resources are to be returned. NO specifies
 8589                          that the named resources are to be obtained.
 8590                          The default is NO.                                      */
 8591                          /*K* PRES = VARIABLE locates an area which describes
 8592                          the physical resources to be manipulated. This area
 8593                          can be generated by invoking the VLP_PRES macro.
 8594                          The default is NIL.                                     */
 8595                          /*K* PSEUDO = VARIABLE   locates an 8-byte array
 8596                          specifying how many of each pseudo resource are to be
 8597                          manipulated. This area can be generated by invoking
 8598                          the VLP_PSEUDO macro.  The default is NIL.              */
 8599                          /*K* RPSN = VARIABLE locates an area which describes
 8600                          the pack sets to be manipulated. This area can
 8601                          be generated by invoking the VLP_RPSN macro.
 8602                          The default is NIL.                                     */
 8603                          /*K* SYSID = VALUE-DEC(0-n)   specifies the SYSID
 8604                          for which to reserve resources.  The default is 0.      */
 8605
 8606                          /*F* NAME: M$DISPRES - Return Currently Owned RES.
 8607
 8608                          The M$DISPRES service
 8609                          may be used by any program to obtain a list of the
 8610                          resources it currently owns.
 8611
 8612                          The form of the call for this service is as follows:
 8613
 8614                          CALL M$DISPRES (FPT_RESCTL) [ALTRET(label)];
 8615
 8616                          The parameters for this service are as follows:
 8617                          */
 8618                          /*K* PRES = VARIABLE   locates an area where the
 8619                          list of physical resources owned is returned. This area
 8620                          can be generated by invoking the VLP_PRES macro.
 8621                          The default is NIL.                                     */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            234  
 8622                          /*K* PSEUDO = VARIABLE   locates an area where the
 8623                          description of currently owned pseudo resources is
 8624                          returned. The area can be generated by invoking the
 8625                          VLP_PSEUDO macro.  The default is NIL.                  */
 8626                          /*K* RPSN = VARIABLE   locates an area where the
 8627                          description of pack sets is returned. This area can be
 8628                          generated by invoking the VLP_RPSN macro.
 8629                          The default is NIL.                                     */
 8630
 8631                          /*F* NAME: M$RELRES - Release Resources.
 8632
 8633                          The M$RELRES service may
 8634                     be used by any program to dispose of resources it currently
 8635                     owns.  If resources cannot be released because they
 8636                     are in use, their names are returned as in M$DISPRES.
 8637
 8638                     The form of the call for this service is as follows:
 8639
 8640                     CALL M$RELRES (FPT_RESCTL) [ALTRET (label)];
 8641
 8642                     The parameters for this service are as follows:
 8643                     */
 8644                          /*K* PRES = VARIABLE   locates an area which describes
 8645                          the physical resources to be manipulated. This area
 8646                          can be generated by invoking the VLP_PRES macro.
 8647                          The default is NIL.                                     */
 8648                          /*K* PSEUDO = VARIABLE   locates an 8-byte array
 8649                          specifying how many of each pseudo resource are to be
 8650                          manipulated. The area can be generated by invoking the
 8651                          VLP_PSEUDO macro.  The default is NIL.                  */
 8652                          /*K* RELALL = {YES|NO}   YES specifies that all
 8653                          resources owned by this user are to be released.
 8654                          The default is NO.                                      */
 8655                          /*K* RPSN = VARIABLE   locates an area which
 8656                          describes the pack sets to be manipulated. This
 8657                          area can be generated by invoking the VLP_RPSN
 8658                          macro.  The default is NIL.                             */
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            235  
 8659
 8660                          /*F* NAME: M$REQUIRE - Require Pseudo Resources.
 8661
 8662                          The M$REQUIRE service
 8663                          is used typically by processors which require the user
 8664                          to have certain pseudo resources.  If the resources are
 8665                          not owned by the user, a severe error is given and the
 8666                          processor may abort.
 8667
 8668                          The form of the call for this service is as follows:
 8669
 8670                          CALL M$REQUIRE (FPT_RESCTL) [ALTRET (label)];
 8671
 8672                          The parameter for this service is as follows:
 8673                          */
 8674                          /*K* PSEUDO = VARIABLE   locates an area which
 8675                          describes the pseudo resources to be manipulated. This
 8676                          area can be generated by invoking the VLP_PSEUDO
 8677                          macro.  The default is NIL.                             */
 8678
 8679                          /*B*  NAME:  FPT_RESCTL.  A common FPT for
 8680                          resource management services.
 8681                          */
 8682
 8683       %MACRO FPT_RESCTL (FPTN=FPT_RESCTL,
 8684              PSEUDO=NIL,
 8685              PRES=NIL,
 8686              RPSN=NIL,
 8687              RELALL(YES='1'B,NO='0'B)='0'B,
 8688              MBSDISP(YES='1'B,NO='0'B)='0'B,
 8689              SYSID=0,
 8690              STCLASS=STATIC);
 8691
 8692       %LSET LISTDIR='0'B;
 8693       %LSET LISTEXP='1'B;
 8694       %LSET LISTCOM='0'B;
 8695       %LSET LISTSUB='1'B;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            236  
 8696       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8697       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8698       (SUBSTR(STR,0,8)='CONSTANT') OR
 8699       (SUBSTR(STR,0,3)='EXT');
 8700       %LSET INIT=CHARTEXT('INIT');
 8701       %ELSE;
 8702       %LSET INIT=CHARTEXT('/*');
 8703       %ENDIF;
 8704
 8705
 8706      DCL 1 FPTN STCLASS,
 8707            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 8708            2 PSEUDO_ BIT(72) %INIT(VECTOR(PSEUDO))%CHARTEXT('/**/'),
 8709                          /*B* PSEUDO = VARIABLE      Locates a VLP_PSEUDO which
 8710                          describes the pseudo resources to be manipulated.
 8711                          In the case of M$DISPRES, the description of currently
 8712                          owned pseudos is returned to this area.  For M$MBS this
 8713                          vector frames an 8 byte array containing the number of
 8714                          each pseudo to reserve.                                 */
 8715            2 PRES_ BIT(72) %INIT(VECTOR(PRES))%CHARTEXT('/**/'),
 8716                          /*B* PRES = VARIABLE      Locates a VLP_PRES which
 8717                          describes the physical resources to be manipulated.
 8718                          For M$DISPRES the list of physical resources owned is
 8719                          returned to this area.                                  */
 8720            2 RPSN_ BIT(72) %INIT(VECTOR(RPSN))%CHARTEXT('/**/'),
 8721                          /*B* RPSN = VARIABLE      Locates a VLP_RPSN which
 8722                          describes the pack sets to be manipulated.  For M$DISPRES
 8723                     the pack sets currently owned are returned to this area.     */
 8724            2 * BIT(72) %INIT(VECTOR(NIL))%CHARTEXT('/**/'),
 8725            2 * BIT(72) %INIT(VECTOR(NIL))%CHARTEXT('/**/'),
 8726            2 V DALIGNED,
 8727              3 * UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 8728              3 RELALL# BIT(1) UNAL %INIT(RELALL)%CHARTEXT('/**/'),
 8729                          /*B* RELALL = {YES|NO}  If RELALL is set on M$RELRES,
 8730                          all resources owned by this user are released           */
 8731              3 MBSDISP# BIT(1) UNAL %INIT(MBSDISP)%CHARTEXT('/**/'),
 8732                          /*B* MBSDISP = {YES|NO}  Used for M$MBS only.  YES
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            237  
 8733                          specifies that available resources are to be returned.  */
 8734              3 * BIT(16) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 8735              3 SYSID# UBIN(18) UNAL %INIT(SYSID)%CHARTEXT('/**/'),
 8736                     /*B* SYSID = VALUE-DEC(0-n).  Used only in M$MBS to specify
 8737                     the SYSID for which to reserve resources.                    */
 8738              3 * BIT(72) %INIT('0'B)%CHARTEXT('/**/'),
 8739              3 * BIT(72) %INIT('0'B)%CHARTEXT('/**/');
 8740       %MEND;
 8741
 8742
 8743                                    /****************************************/
 8744                                    /** VLPS FOR RESOURCE MANAGEMENT PMMES **/
 8745                                    /****************************************/
 8746
 8747
 8748                          /*F* NAME:  VLP_PSEUDO
 8749
 8750                          The VLP_PSEUDO structure is used to specify
 8751                          pseudo resources to be manipulated by the resource
 8752                          management monitor services. Pseudo resources
 8753                          are defined via the TIGR processor and
 8754                          manipulated via the CONTROL processor. For
 8755                          information on TIGR and CONTROL, refer to the
 8756                          CP-6 System Support Reference Manual. On
 8757                          M$DISPRES this structure is filled with the
 8758                          information on currently owned pseudo resources.
 8759                          On M$RELRES this VLP returns information on
 8760                          resources which could not be released.
 8761
 8762                          The area generated by VLP_PSEUDO often contains
 8763                          a single pseudo resource name, but may contain a
 8764                          list of up to eight names. Each entry in the list
 8765                          includes the pseudo resource name and the number
 8766                          of that type of pseudo resource to manipulate. For
 8767                          multiple list entries in the macro invocation, the
 8768                          form of the macro invocation is as shown in the
 8769                          following example. Double quotation marks are
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            238  
 8770                          required when multiple names and values are specified.
 8771                          In this example, the list generated contains these
 8772                          entries: 4 of pseudo resource A, 3 of B, 1 of C, and
 8773                          1 of D.
 8774
 8775                          Example:
 8776
 8777                          %VLP_PSEUDO (N=4,PSEUDO="'A','B','C','D'",NUM="4,3,1,1");
 8778
 8779                          The contents of the VLP_PSEUDO structure are as
 8780                          follows:                                                */
 8781
 8782       %MACRO VLP_PSEUDO (FPTN=VLP_PSEUDO,
 8783              MEMORY=0,
 8784              ENQBLOCKS=0,
 8785              PSEUDO=' ',
 8786              NUM=1,
 8787              %N=1,
 8788              STCLASS=STATIC);
 8789
 8790       %LSET LISTDIR='0'B;
 8791       %LSET LISTEXP='1'B;
 8792       %LSET LISTCOM='0'B;
 8793       %LSET LISTSUB='1'B;
 8794       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8795       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8796       (SUBSTR(STR,0,8)='CONSTANT') OR
 8797       (SUBSTR(STR,0,3)='EXT');
 8798       %LSET INIT=CHARTEXT('INIT');
 8799       %ELSE;
 8800       %LSET INIT=CHARTEXT('/*');
 8801       %ENDIF;
 8802
 8803
 8804      DCL 1 FPTN STCLASS DALIGNED,
 8805            2 NN# SBIN WORD %INIT(N)%CHARTEXT('/**/'),
 8806                          /*K* N = VALUE-DEC(1-8)   specifies the number of
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            239  
 8807                          pseudo resources contained in VLP_PSEUDO.PSLIST. The
 8808                          fully qualified name of this field is VLP_PSEUDO.NN#.
 8809                          The default is 1.                                       */
 8810            2 FAILX SBIN WORD %INIT(0)%CHARTEXT('/**/'),
 8811                          /*K* FAILX = VALUE-DEC(0-7)   contains the index of a
 8812                          list entry, when an error is returned on a monitor
 8813                          service involving an area generated by VLP_PSEUDO. If
 8814                          it is MEMORY that cannot be allocated, FAILX is set to
 8815                          -1.                                                     */
 8816            2 MEMORY# UBIN HALF UNAL %INIT(MEMORY)%CHARTEXT('/**/'),
 8817                          /*K* MEMORY = VALUE-DEC(0-n)   specifies the user's
 8818                          resource memory requirement in increments of 1K words.
 8819                          On M$DISPRES this value is returned.  The default is 0. */
 8820            2 ENQBLOCKS# UBIN HALF UNAL %INIT(ENQBLOCKS)%CHARTEXT('/**/'),
 8821                          /*K* ENQBLOCKS = VALUE-DEC(0-n)   specifies the user's
 8822                          ENQ/DEQ memory requirement in increments of 4-words.
 8823                          This facility is not yet implemented.
 8824                          On M$DISPRES this value is returned.  The default is 0. */
 8825            2 * UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 8826            2 PSLIST (0:N),
 8827              3 PSEUDO# CHAR(8) UNAL %INIT(PSEUDO,' '*0)%CHARTEXT('/**/'),
 8828                          /*K* PSEUDO = 1 to 8 VALUES-CHAR(8)   specifies the
 8829                          name(s) of the pseudo resource(s) being manipulated.
 8830                          These names are established via the TIGR processor by
 8831                          the system manager. The fully qualified name of this
 8832                          field is VLP_PSEUDO.PSLIST.PSEUDO#.  The default is blank.
 8833                          */
 8834              3 NUM# UBIN BYTE UNAL %INIT(NUM,0*0)%CHARTEXT('/**/'),
 8835                          /*K* NUM = 1 to 8 VALUES-DEC(1-n)  Represents how
 8836                          how many of the pseudo resources are to be obtained
 8837                          (M$MBS, M$LIMIT), released (M$RELRES), or required
 8838                          (M$REQUIRE). For M$DISPRES the number currently owned
 8839                          is returned here. The fully qualified name of this
 8840                          field is VLP_PSEUDO.PSLIST.NUM#.  The default is 1.     */
 8841              3 * UBIN(27) UNAL %INIT(0*0)%CHARTEXT('/**/');
 8842       %MEND;
 8843
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            240  
 8844
 8845                          /*F* NAME:  VLP_PRES
 8846
 8847                          This VLP is used to specify physical resources to be
 8848                          manipulated by the resource management monitor
 8849                          services. On M$DISPRES this structure is filled with
 8850                          the information on currently owned physical resources.
 8851                          This VLP must not be in CONSTANT storage since the
 8852                          monitor may store into this area (see RAT$ below).
 8853
 8854                          The VLP_PRES area often contains a single physical
 8855                          resource name, but may contain a list of physical
 8856                          resources. Each entry in the list includes the
 8857                          the physical resource name, attributes for the
 8858                          resource, and for M$LIMIT and M$MBS a pointer. For
 8859                          a list, the form of the macro invocation is as
 8860                          shown in the following example. Double quotation
 8861                          marks are required when multiple values are
 8862                          specified. In this example, the list generated
 8863                          contains these entries: MT03, LP02, PL01.
 8864
 8865                          Example:
 8866
 8867                          %VLP_PRES (N=3,RNAME="'MT03','LP02','PL01'");
 8868
 8869                          The contents of the VLP_PRES structure is as follows:
 8870                          */
 8871
 8872       %MACRO VLP_PRES (FPTN=VLP_PRES,
 8873              %N=1,
 8874              RNAME=' ',
 8875              ATTR='0'O,
 8876              STCLASS=STATIC);
 8877
 8878       %LSET LISTDIR='0'B;
 8879       %LSET LISTEXP='1'B;
 8880       %LSET LISTCOM='0'B;
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            241  
 8881       %LSET LISTSUB='1'B;
 8882       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8883       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8884       (SUBSTR(STR,0,8)='CONSTANT') OR
 8885       (SUBSTR(STR,0,3)='EXT');
 8886       %LSET INIT=CHARTEXT('INIT');
 8887       %ELSE;
 8888       %LSET INIT=CHARTEXT('/*');
 8889       %ENDIF;
 8890
 8891
 8892      DCL 1 FPTN STCLASS DALIGNED,
 8893            2 NN# SBIN WORD %INIT(N)%CHARTEXT('/**/'),
 8894                          /*K* N = VALUE-DEC(1-n)   specifies the number of
 8895                          physical resource descriptions contained in
 8896                          VLP_PRES.PRLIST. The fully qualified name of this
 8897                          field is VLP_PRES.NN#.  The default is 1.               */
 8898            2 FAILX UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 8899                          /*K* FAILX = VALUE-DEC(0-n)   contains the index
 8900                          of a list entry when an error is returned on a
 8901                          monitor service call as a result of this VLP.
 8902                          */
 8903            2 PRLIST (0:N),
 8904              3 RNAME# CHAR(4) UNAL %INIT(RNAME,' '*0)%CHARTEXT('/**/'),
 8905              3 RNME REDEF RNAME#,
 8906                4 TYP CHAR(2) UNAL,
 8907                4 NUM CHAR(2) UNAL,
 8908                          /*K* RNAME = 1 to n VALUES-CHAR(4)  specifies the
 8909                          name(s) of the physical resource(s) to be manipulated.
 8910                          The name(s) must be in text form: 'dvnn' where dv is a
 8911                          device type (e.g., MT, LP) and nn is a 2-digit
 8912                          number from 1 to 99. This name is used later to access
 8913                          the resource (C TO ME LP37#). The fully qualified
 8914                          name of this field is VLP_PRES.PRLIST.RNAME#.
 8915                          The default is blank.                                   */
 8916              3 * CHAR(2) UNAL %INIT(' '*0)%CHARTEXT('/**/'), /* REAL TYPE LATER  */
 8917              3 ATTR# BIT(18) UNAL %INIT(ATTR,'0'B*0)%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            242  
 8918                          /*K* ATTR = 1 to n VALUES-BIT   specify the attributes
 8919                          required on the physical device. Examples are DENSITY
 8920                          for tapes and lower-case print capability for printers.
 8921                          The bit strings for attributes are defined in the file
 8922                          CP_6_SUBS. This field has meaning only for M$LIMIT
 8923                          and M$MBS as a parameter and for M$DISPRES as a
 8924                          returned value. The fully qualified name of this
 8925                          field is VLP_PRES.PRLIST.ATTR#.  The default='0'B.
 8926                          */
 8927              3 RAT$ PTR %INIT(ADDR(NIL)*0)%CHARTEXT('/**/'),
 8928                          /*K* RAT$   is a pointer used by the monitor on
 8929                          M$LIMIT and M$MBS. Because the monitor stores a
 8930                          value into this PTR variable, VLP_PRES must not be
 8931                          in CONSTANT storage. The contents of this area
 8932                          are not significant to the caller of the monitor
 8933                          service.                                                */
 8934              3 * UBIN WORD %INIT(0*0)%CHARTEXT('/**/');
 8935       %MEND;
 8936
 8937
 8938                          /*F* NAME:  VLP_RPSN
 8939
 8940                          This structure is used to describe pack sets to be
 8941                          manipulated on resource management monitor
 8942                          services. On M$DISPRES the structure is filled
 8943                          with information on the pack sets currently reserved.
 8944
 8945                          The VLP_RPSN area often contains a single pack
 8946                          set name, but may contain a list of pack sets. Each
 8947                          entry in the list includes the pack set name and
 8948                          a usage field set to indicate that the pack
 8949                          set is either shared or for exclusive use.
 8950
 8951                          Example:
 8952
 8953                          %VLP_RPSN (N=1,PSN='PAC',USAGE=EXCLUSIVE);
 8954
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            243  
 8955                          The contents of the VLP_RPSN structure are as follows:
 8956                          */
 8957
 8958       %MACRO VLP_RPSN (FPTN=VLP_RPSN,
 8959            %N=1,
 8960            PSN=' ',
 8961           USAGE(SHARED=1,EXCLUSIVE=2)=1,
 8962           DISP(NOREL=0,RELEASE=1,REM=2,REL=3)=1,
 8963            STCLASS=STATIC);
 8964
 8965       %LSET LISTDIR='0'B;
 8966       %LSET LISTEXP='1'B;
 8967       %LSET LISTCOM='0'B;
 8968       %LSET LISTSUB='1'B;
 8969       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 8970       %IF (SUBSTR(STR,0,6)='STATIC') OR
 8971       (SUBSTR(STR,0,8)='CONSTANT') OR
 8972       (SUBSTR(STR,0,3)='EXT');
 8973       %LSET INIT=CHARTEXT('INIT');
 8974       %ELSE;
 8975       %LSET INIT=CHARTEXT('/*');
 8976       %ENDIF;
 8977
 8978
 8979      DCL 1 FPTN STCLASS DALIGNED,
 8980            2 NN# SBIN WORD %INIT(N)%CHARTEXT('/**/'),
 8981                          /*K* N = VALUE-DEC(1-n)   specifies the number of
 8982                          pack sets described in VLP_PRLIST. The fully qualified
 8983                          name of this field is VLP_RPSN.NN#. The default is 1.
 8984                          */
 8985            2 FAILX UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 8986                          /*K* FAILX = VALUE-DEC(0-7)   contains the index of
 8987                          a list entry when an error is returned on a resource
 8988                          management monitor service as a result of this VLP.
 8989                          */
 8990            2 RPLIST (0:N),
 8991              3 PSN# CHAR(6) UNAL %INIT(PSN,' '*0)%CHARTEXT('/**/'),
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            244  
 8992                          /*K* PSN = 1 to n VALUES-CHAR(6) specifies the pack set
 8993                          name(s) of the pack set(s) to be manipulated.
 8994                          The fully qualified name of this field is
 8995                          VLP_RPSN.RPLIST.PSN#.  The default is blank.            */
 8996              3 USAGE# UBIN BYTE UNAL %INIT(USAGE,0*0)%CHARTEXT('/**/'),
 8997                /*K* USAGE = {SHARED|EXCLUSIVE}  Is specified as a parameter for
 8998                M$LIMIT or M$MBS and is returned on M$DISPRES.  USAGE defines
 8999                whether the pack set is shared or for exclusive use
 9000                only. USAGE cannot be specified at compile time if
 9001                the N parameter is greater than 1 and must be specified at
 9002                run time instead.  The default is %SHARED#.
 9003                                                                                  */
 9004              3 DISP# UBIN BYTE UNAL %INIT(DISP*0)%CHARTEXT('/**/'),
 9005                          /*K* DISP = OPTION    applies to M$RELRES only.
 9006                          This parameter specifies the disposition
 9007                          for the specified resource(s) or set name(s). A
 9008                          tape volume set or pack set is always dismounted
 9009                          if it is in exclusive use. In addition,
 9010                          the options specify that these actions are
 9011                          to be taken:
 9012
 9013                          .INL 8
 9014                          .UNL 8
 9015                          REM     Release the set name(s) if the user has
 9016                              no files open.
 9017
 9018                          .UNL 8
 9019                          RELEASE Release the physical resource(s) if the set
 9020                             dismounts.
 9021
 9022                          .UNL 8
 9023                          REL     Release the set name(s) if the user has no
 9024                             files open, and release the physical resource(s)
 9025                             if the set dismounts.
 9026
 9027                          .UNL 8
 9028                          NOREL   No additional action.
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            245  
 9029
 9030                          .INL -8
 9031                          The default is RELEASE.                                 */
 9032              3 * BIT(72) %INIT('0'B*0)%CHARTEXT('/**/');
 9033       %MEND;
 9034
 9035
 9036
 9037
 9038
 9039
 9040
 9041
 9042                          /*F* NAME: M$RELSTARF - Release STAR Files.
 9043
 9044                          This service releases all of the star files
 9045                          for the user whose JIT is passed.  The service
 9046                          is legal only for the system ghost GHOST1 and the
 9047                          ALTKEY processor.
 9048
 9049                          The form of the call for this service is:
 9050
 9051                          CALL M$RELSTARF (FPT_RELSTARF) [ALTRET (label)];
 9052
 9053                          The parameter for this service is as follows:           */
 9054
 9055       %MACRO FPT_RELSTARF (FPTN=FPT_RELSTARF,
 9056                         STCLASS=STATIC,
 9057                          ALTKEYS=NIL,
 9058                         JIT=NIL);
 9059
 9060       %LSET LISTDIR='0'B;
 9061       %LSET LISTEXP='1'B;
 9062       %LSET LISTCOM='0'B;
 9063       %LSET LISTSUB='1'B;
 9064       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 9065       %IF (SUBSTR(STR,0,6)='STATIC') OR
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            246  
 9066       (SUBSTR(STR,0,8)='CONSTANT') OR
 9067       (SUBSTR(STR,0,3)='EXT');
 9068       %LSET INIT=CHARTEXT('INIT');
 9069       %ELSE;
 9070       %LSET INIT=CHARTEXT('/*');
 9071       %ENDIF;
 9072
 9073
 9074      DCL 1 FPTN STCLASS DALIGNED,
 9075            2 JIT_,
 9076              3 BOUND UBIN(20) UNAL %INIT(SIZEV(JIT))%CHARTEXT('/**/'),
 9077              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 9078              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 9079              3 JIT$ PTR %INIT(ADDR(JIT))%CHARTEXT('/**/'),
 9080                          /*K* JIT = VARIABLE      Locates an area
 9081                          containing a JIT.
 9082                          */
 9083
 9084            2 ALTKEYS_ BIT(72) %INIT(VECTOR(ALTKEYS))%CHARTEXT('/**/');
 9085                          /*K* ALTKEYS = VARIABLE  Locates an area used
 9086                          to communicate information between the ALTKEY
 9087                          processor and the monitor.
 9088                          */
 9089
 9090       %MEND;
 9091
 9092
 9093                               /***********************************************/
 9094                               /** M$XFLUSH Flushes one or all levels of XEQ **/
 9095                               /***********************************************/
 9096
 9097
 9098                     /*F* NAME: M$XFLUSH - Flush one or all levels in an XEQ stream.
 9099
 9100                     There is no DCB associated with an M$XFLUSH call.
 9101                     The interrupted stream is the one that is flushed.
 9102
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            247  
 9103                     The form of the call for this service is as follows:
 9104
 9105                     CALL M$REM (FPT_XFLUSH) [ALTRET (label)];
 9106
 9107                     The parameters for this service are as follows:              */
 9108
 9109       %MACRO FPT_XFLUSH (FPTN=FPT_XFLUSH,
 9110                          STCLASS=STATIC,
 9111                          ONELEVEL(YES='1'B,NO='0'B)='1'B);
 9112
 9113       %LSET LISTDIR='0'B;
 9114       %LSET LISTEXP='1'B;
 9115       %LSET LISTCOM='0'B;
 9116       %LSET LISTSUB='1'B;
 9117       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 9118       %IF (SUBSTR(STR,0,6)='STATIC') OR
 9119       (SUBSTR(STR,0,8)='CONSTANT') OR
 9120       (SUBSTR(STR,0,3)='EXT');
 9121       %LSET INIT=CHARTEXT('INIT');
 9122       %ELSE;
 9123       %LSET INIT=CHARTEXT('/*');
 9124       %ENDIF;
 9125
 9126
 9127      DCL 1 FPTN STCLASS,
 9128            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 9129            2 V DALIGNED,
 9130              3 ONELEVEL# BIT (1) UNAL %INIT(ONELEVEL)%CHARTEXT('/**/'),
 9131                          /*K* ONELEVEL = {YES|NO} if ONELEVEL is set on a
 9132                          call to M$XFLUSH then only one level of XEQ is
 9133                          flushed.  If ONELEVEL=NO then all levels of the
 9134                          XEQ stream are flushed.
 9135
 9136                          The default is YES.                                     */
 9137              3 * BIT(71) UNAL %INIT('0'B)%CHARTEXT('/**/');
 9138       %MEND;
 9139                          /*******************************************************
07:12 JUL 29 '97 F_CP6_C.:E05SI                                            248  
 9140                          ********************************************************
 9141                          SYSTEM CALLS
 9142                          ********************************************************
 9143                          ********************************************************
 9144                          */
 9145      DCL M$OPEN ENTRY(1) CONV(1,18,20480) ALTRET;
 9146      DCL M$CLOSE ENTRY(1) CONV(1,13,20481) ALTRET;
 9147      DCL M$LDEV ENTRY(1) CONV(1,7,24580) ALTRET;
 9148      DCL M$SETFMA ENTRY(1) CONV(1,2,24577) ALTRET;
 9149      DCL M$READ ENTRY(1) CONV(1,4,16384) ALTRET;
 9150      DCL M$WRITE ENTRY(1) CONV(1,4,16385) ALTRET;
 9151      DCL M$TRUNC ENTRY(1) CONV(1,1,20483) ALTRET;
 9152      DCL M$CHECK ENTRY(1) CONV(1,1,20482) ALTRET;
 9153      DCL M$DELREC ENTRY(1) CONV(1,4,16386) ALTRET;
 9154      DCL M$PFIL ENTRY(1) CONV(1,1,16388) ALTRET;
 9155      DCL M$CVOL ENTRY(1) CONV(1,3,20484) ALTRET;
 9156      DCL M$REW ENTRY(1) CONV(1,1,16390) ALTRET;
 9157      DCL M$WEOF ENTRY(1) CONV(1,1,16391) ALTRET;
 9158      DCL M$PRECORD ENTRY(1) CONV(1,3,16387) ALTRET;
 9159      DCL M$EXTEND ENTRY(1) CONV(1,1,16389) ALTRET;
 9160      DCL M$DEVICE ENTRY(1) CONV(1,3,20486) ALTRET;
 9161      DCL M$CORRES ENTRY(1) CONV(1,1,24576) ALTRET;
 9162      DCL M$KEYIN ENTRY(1) CONV(1,4,40960) ALTRET;
 9163      DCL M$LINES ENTRY(1) CONV(1,2,20485) ALTRET;
 9164      DCL M$GETDCB ENTRY(1) CONV(1,3,24578) ALTRET;
 9165      DCL M$RELDCB ENTRY(1) CONV(1,1,24579) ALTRET;
 9166      DCL M$LIMIT ENTRY(1) CONV(1,6,53248) ALTRET;
 9167      DCL M$MBS ENTRY(1) CONV(1,6,53249) ALTRET;
 9168      DCL M$DISPRES ENTRY(1) CONV(1,6,53250) ALTRET;
 9169      DCL M$RELRES ENTRY(1) CONV(1,6,53251) ALTRET;
 9170      DCL M$REQUIRE ENTRY(1) CONV(1,6,53252) ALTRET;
 9171      DCL M$RACST ENTRY CONV(1,0,53253) ALTRET;
 9172      DCL M$MADMUCK ENTRY(1) CONV(1,3,24581)ALTRET;
 9173      DCL M$REM ENTRY(1) CONV(1,1,24582) ALTRET;
 9174      DCL M$XFLUSH ENTRY(1) CONV(1,1,24583)ALTRET;
 9175      DCL M$RELSTARF ENTRY(1) CONV(1,2,24584)ALTRET;

