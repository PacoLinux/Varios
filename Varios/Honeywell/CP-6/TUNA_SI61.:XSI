/*M* TUNA - TUNE A TEXT file so it fits on a screen */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMR,PLM=5,IND=3,CTI=3,SDI=3,MCL=10,CSI=0,ECI=0 */
                                   /*
                                        Author: J.L.Joseph, LADC
                                        Date: 4/82
                                                                  */
%SET LISTSUB='1'B;
 
TUNA: PROC MAIN;
 
                                   /*
                                        Locally needed %SUBs
                                                                  */
%SUB TRUE#='1'B /*TRUE#*/;
%SUB FALSE#='0'B /*FALSE#*/;
%SUB MAX_EDIT_LINE#=69 /*MAX_EDIT_LINE#*/;
%SUB MAX_6EDIT_LINE#=79 /*MAX_6EDIT_LINE#*/;
%SUB LEN_LARGE#=2048/*LEN_LARGE#*/;
%SUB LEN_SMALL#=20/*LEN_SMALL#*/;
%SUB FIF#=5 /*FIF#*/;
%SUB FIN#=26 /*FIN#*/;
%SUB NOCH#=21 /*NOCH#*/;
%SUB WARN#=2 /*WARN#*/;
%SUB PUSH#=3 /*PUSH#*/;
%SUB PULL#=3 /*PULL#*/;
%SUB BBUFSIZ#=8192 /*BBUFSIZ#*/;
%SUB KBUFSIZ#=1024 /*KBUFSIZ#*/;
%SUB TOTALSIZ#=18432 /*TOTALSIZ#*/;
                                        /*odd, but very important*/
%SUB MAXDIR#=9 /*MAXDIR#*/;
                                   /*this is string length of
                                   longest macro to check in
                                   INTERNAL_CHECK*/
 
                                   /*
                                        INCLUDEs here
                                                                  */
     %INCLUDE CP_6;
     %INCLUDE CP_6_SUBS;
 
     %INCLUDE XU_MACRO_C;
     %INCLUDE XU_SUBS_C;
     %INCLUDE XU_PERR_C;
     %INCLUDE XU_FORMAT_C;
 
     %INCLUDE B$JIT_C;
     %INCLUDE B_ERRORS_C;
 
     %INCLUDE XS_MACRO_C;
                                   /*
                                        DCBs defined here
                                                                  */
DCL M$SI DCB;
 
     %M$DCB (DCBN=M$OUT);
 
DCL M$DO DCB;
 
                                   /*
                                        EXTERNALs
                                                                  */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL TUNA_NODES SBIN WORD SYMREF;
DCL X$PARSE ENTRY(1) ALTRET;
DCL XSA$OPEN ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
DCL XSA$READ ENTRY(2) ALTRET;
DCL XSA$WRITE ENTRY(2) ALTRET;
DCL X$WRITE ENTRY(22);
                                   /*
                                        CONSTANT definitions here
                                                                  */
 
                                   /* XLATE table for lc to uc conversion */
 
DCL XTAB1 (0:127) UBIN BYTE UNAL CONSTANT INIT (
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,
24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,
   45,46,47,ASCBIN('0'),ASCBIN('1'),ASCBIN('2'),ASCBIN('3'),
ASCBIN('4'),ASCBIN('5'),ASCBIN('6'),ASCBIN('7'),ASCBIN('8'),
ASCBIN('9'),ASCBIN(':'),ASCBIN(';'),ASCBIN('<'),ASCBIN('='),
ASCBIN('>'),ASCBIN('?'),ASCBIN('@'),ASCBIN('A'),ASCBIN('B'),
ASCBIN('C'),ASCBIN('D'),ASCBIN('E'),ASCBIN('F'),ASCBIN('G'),
ASCBIN('H'),ASCBIN('I'),ASCBIN('J'),ASCBIN('K'),ASCBIN('L'),
ASCBIN('M'),ASCBIN('N'),ASCBIN('O'),ASCBIN('P'),ASCBIN('Q'),
ASCBIN('R'),ASCBIN('S'),ASCBIN('T'),ASCBIN('U'),ASCBIN('V'),
ASCBIN('W'),ASCBIN('X'),ASCBIN('Y'),ASCBIN('Z'),ASCBIN('['),
ASCBIN('\'),ASCBIN(']'),ASCBIN('^'),ASCBIN('_'),ASCBIN('`'),
ASCBIN('A'),ASCBIN('B'),ASCBIN('C'),ASCBIN('D'),ASCBIN('E'),
ASCBIN('F'),ASCBIN('G'),ASCBIN('H'),ASCBIN('I'),ASCBIN('J'),
ASCBIN('K'),ASCBIN('L'),ASCBIN('M'),ASCBIN('N'),ASCBIN('O'),
ASCBIN('P'),ASCBIN('Q'),ASCBIN('R'),ASCBIN('S'),ASCBIN('T'),
ASCBIN('U'),ASCBIN('V'),ASCBIN('W'),ASCBIN('X'),ASCBIN('Y'),
ASCBIN('Z'),ASCBIN('{'),ASCBIN('|'),ASCBIN('}'),ASCBIN('~'),
127);
 
 
                                   /* XLATE table for uc to lc conversion */
 
DCL XTAB2 (0:127) UBIN BYTE UNAL CONSTANT INIT (
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,
24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,
   45,46,47,ASCBIN('0'),ASCBIN('1'),ASCBIN('2'),ASCBIN('3'),
ASCBIN('4'),ASCBIN('5'),ASCBIN('6'),ASCBIN('7'),ASCBIN('8'),
ASCBIN('9'),ASCBIN(':'),ASCBIN(';'),ASCBIN('<'),ASCBIN('='),
ASCBIN('>'),ASCBIN('?'),ASCBIN('@'),ASCBIN('a'),ASCBIN('b'),
ASCBIN('c'),ASCBIN('d'),ASCBIN('e'),ASCBIN('f'),ASCBIN('g'),
ASCBIN('h'),ASCBIN('i'),ASCBIN('j'),ASCBIN('k'),ASCBIN('l'),
ASCBIN('m'),ASCBIN('n'),ASCBIN('o'),ASCBIN('p'),ASCBIN('q'),
ASCBIN('r'),ASCBIN('s'),ASCBIN('t'),ASCBIN('u'),ASCBIN('v'),
ASCBIN('w'),ASCBIN('x'),ASCBIN('y'),ASCBIN('z'),ASCBIN('['),
ASCBIN('\'),ASCBIN(']'),ASCBIN('^'),ASCBIN('_'),ASCBIN('`'),
ASCBIN('a'),ASCBIN('b'),ASCBIN('c'),ASCBIN('d'),ASCBIN('e'),
ASCBIN('f'),ASCBIN('g'),ASCBIN('h'),ASCBIN('i'),ASCBIN('j'),
ASCBIN('k'),ASCBIN('l'),ASCBIN('m'),ASCBIN('n'),ASCBIN('o'),
ASCBIN('p'),ASCBIN('q'),ASCBIN('r'),ASCBIN('s'),ASCBIN('t'),
ASCBIN('u'),ASCBIN('v'),ASCBIN('w'),ASCBIN('x'),ASCBIN('y'),
ASCBIN('z'),ASCBIN('{'),ASCBIN('|'),ASCBIN('}'),ASCBIN('~'),
127);
 
DCL 1 FIF_TAB(0:FIF#) CONSTANT CALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(8,8,6,6,6,6),
       2 WORD_ CHAR(8) CALIGNED INIT('..::FG "','..::TB "',
               '..:MAT','..:FIG','..:HLP','..:HTP');
 
DCL 1 FIN_TAB(0:FIN#) CONSTANT CALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(6,6,6,6,6,6,6,6,6,6,6,6,
               6,6,8,8,6,6,6,6,6,6,6,6,6,6,6),
       2 WORD_ CHAR(8) CALIGNED INIT (
               '..::CH','..::IT','..::L1','..::L2','..::L3','..::L4',
               '..::L5','..::L6','..::L7','..::L8','..::L9','..::TT',
               '..::FM','..::TC','..::TB  ','..::FG  ',
               '..:L1H','..:L2H','..:L3H','..:L4H','..:L0H','..:ARF',
               '..:FND','..:END','..:FMT','..:L5H','..:L6H');
 
DCL 1 NO_CHANGE(0:NOCH#) CONSTANT CALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(6,6,6,6,6,6,6,6,6,6,9,
                                          9,9,9,9,9,9,9,9,9,9,9),
       2 WORD_ CHAR(10) CALIGNED INIT(
          '..::HL','..::IX','..::LS','..::PH','..::RF',
          '..::SB','..::GR','..:DBG','..:SRB','..:IDX',
          '..:L1H "^','..:L2H "^','..:L3H "^','..:L4H "^',
          '..:L1H ";','..:L2H ";','..:L3H ";','..:L4H ";',
          '..:L5H ";','..:L5H "^','..:L6H ";','..:L6H "^');
 
DCL 1 PUSH_TAB (0:PUSH#) CONSTANT ALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(4,4,4,4),
       2 WORD_ CHAR(8) CALIGNED INIT ('.HBB','.BBF','.FBB','.HTN');
 
DCL 1 PULL_TAB (0:PULL#) CONSTANT ALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(4,4,4,4),
       2 WORD_ CHAR(8) CALIGNED INIT('.HBE','.BEF','.FBE','.HTF');
 
DCL 1 WARN_ONLY(0:WARN#) CONSTANT ALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(4,2,3),
       2 WORD_ CHAR(8) CALIGNED INIT('.IFI','..','.GO');
 
DCL WARN_MSG CHAR(0) STATIC INIT
(' **** WARNING: Directive may have changed formatting: XXXXXX');
 
DCL FOUL_MSG CHAR(0) STATIC INIT
(' **** Detected non-CP-6 backspace sequence at line XXXXXXX.000');
 
DCL FOUL_MSG2 CHAR(0) STATIC INIT
(' **** NUSBS option automatically invoked.');
 
                                   /*
                                        Local STATIC storage
                                                                  */
DCL BUF1 CHAR(2052) STATIC INIT(' ');
DCL BUF1U CHAR(MAXDIR#) STATIC INIT(' ');
DCL BUF2 CHAR(2052) STATIC INIT(' ');
DCL BUFT CHAR(2052) STATIC INIT(' ');
DCL BUF1ARS UBIN WORD STATIC INIT(0);
DCL BUF2ARS UBIN WORD STATIC INIT(0);
DCL INDENT UBIN WORD STATIC INIT(0);
DCL UNDENT UBIN WORD STATIC INIT(0);
DCL 1 LASTWD STATIC,
       2 LGTH UBIN BYTE CALIGNED INIT(0),
       2 WORD_ CHAR(32) CALIGNED INIT(' ');
DCL 1 LASTWDT STATIC,
       2 LGTH UBIN BYTE CALIGNED INIT(0),
       2 WORD_ CHAR(32) CALIGNED INIT(' ');
DCL LASTWDU STATIC CHAR(32) INIT(' ');
 
DCL CHAR_SAVE CHAR(1) CALIGNED STATIC;
DCL WHEREBS SBIN WORD STATIC INIT(0);
DCL LAST_PL SBIN WORD STATIC INIT(0);
DCL WORDCOUNT_ SBIN WORD STATIC INIT(0);
DCL RECCOUNT_ SBIN WORD STATIC INIT(0);
DCL MY_ERROR_BUF CHAR(140) STATIC;
 
                              /*
                                   OPTIONS flags
                                                  */
DCL MAXCOMPRESS_ BIT(1) ALIGNED STATIC INIT(FALSE#);
DCL NUSBS_ BIT(1) ALIGNED STATIC INIT(FALSE#);
DCL NWARN_ BIT(1) ALIGNED STATIC INIT(FALSE#);
DCL SENTENCES_ BIT(1) ALIGNED STATIC SYMDEF INIT(FALSE#);
DCL PRUNE_ BIT(1) ALIGNED STATIC SYMDEF INIT(FALSE#);
DCL SUMLINE_ BIT(1) ALIGNED STATIC SYMDEF INIT(TRUE#);
DCL CNVRT_ BIT(1) ALIGNED STATIC SYMDEF INIT(FALSE#);
DCL HERMAN_ BIT(1) ALIGNED STATIC SYMDEF INIT(FALSE#);
 
                              /*
                                   internal status flags
                                                                  */
DCL FIN BIT(1) ALIGNED STATIC INIT(TRUE#); /* fill mode on */
DCL END_OF_FILE BIT(1) ALIGNED STATIC INIT(FALSE#);
DCL BS_FOUND BIT(1) ALIGNED STATIC INIT(FALSE#);
 
                              /*
                                   character constants for
                                   comparisons
                                                                  */
DCL 1 BS_USCORE STATIC CALIGNED,
       2 BS_ UBIN BYTE CALIGNED INIT(8),
       2 SCORE_ CHAR(1) CALIGNED INIT('_');
DCL BS_USCOREC REDEF BS_USCORE CHAR(2);
 
DCL 1 USCORE_BS STATIC CALIGNED,
       2 SCORE_ CHAR(1) CALIGNED INIT('_'),
       2 BS_ UBIN BYTE CALIGNED INIT(8);
DCL USCORE_BSC REDEF USCORE_BS CHAR(2);
 
DCL 1 BS_SPS STATIC CALIGNED,
       2 BS_ UBIN BYTE CALIGNED INIT(8),
       2 SP_ CHAR(1) CALIGNED INIT(' ');
DCL BS_SP REDEF BS_SPS CHAR(2);
 
DCL 1 BS_SPECS STATIC CALIGNED,
       2 BS_ UBIN BYTE CALIGNED INIT(8),
       2 SPEC_ UBIN BYTE CALIGNED INIT(127);
DCL BS_SPEC REDEF BS_SPECS CHAR(2);
 
DCL 1 SP_BSS STATIC CALIGNED,
       2 SP_ CHAR(1) CALIGNED INIT(' '),
       2 BS_ UBIN BYTE CALIGNED INIT(8);
DCL SP_BS REDEF SP_BSS CHAR(2);
 
DCL 1 SPEC_BSS STATIC CALIGNED,
       2 SPEC_ UBIN BYTE CALIGNED INIT(127),
       2 BS_ UBIN BYTE CALIGNED INIT(8);
DCL SPEC_BS REDEF SPEC_BSS CHAR(2);
 
DCL 1 DBL_BSS STATIC CALIGNED,
       2 BS1_ UBIN BYTE CALIGNED INIT(8),
       2 BS2_ UBIN BYTE CALIGNED INIT(8);
DCL DBL_BS REDEF DBL_BSS CHAR(2);
 
                              /*
                                   internal word table for scanned
                                   record
                                                                  */
DCL 1 WTABLE(0:1200) WALIGNED,
       2 START_ UBIN HALF HALIGNED,
       2 * UBIN HALF HALIGNED,
       2 ENDIT_ UBIN HALF HALIGNED,
       2 * UBIN HALF HALIGNED,
       2 NONBL_ UBIN HALF HALIGNED,
       2 * UBIN HALF HALIGNED;
 
DCL WORDS_ SBIN WORD STATIC ALIGNED INIT(0);
 
                              /*
                                   stack for push-pull nested macro
                                   junk
                                                                  */
DCL 1 STACK(0:600) CALIGNED,
       2 CURRENT_ BIT(1) CALIGNED,
       2 ENTRY_ SBIN(27)  CALIGNED;
 
DCL STACK_ SBIN WORD STATIC ALIGNED INIT(0);
 
                              /*
                                   mysterious and misused temps
                                                                  */
DCL I SBIN WORD STATIC ALIGNED INIT(0);
DCL J SBIN WORD STATIC ALIGNED INIT(0);
DCL K SBIN WORD STATIC ALIGNED INIT(0);
DCL L SBIN WORD STATIC ALIGNED INIT(0);
DCL M SBIN WORD STATIC ALIGNED;
DCL LOCATED SBIN WORD STATIC;
 
DCL MAX_PER_LINE SBIN WORD STATIC SYMDEF ALIGNED INIT(-1);
 
DCL TUNA_WORKSPACE(0:200) SBIN WORD STATIC SYMDEF;
 
DCL FPARAM_BUF (0:1024) SBIN STATIC ALIGNED;
 
DCL 1 FILE_KEY STATIC CALIGNED,
       2 COUNT_ UBIN BYTE CALIGNED INIT(3),
       2 KEY_ UBIN(27) CALIGNED INIT(1000);
DCL KEY_INCR SBIN WORD STATIC INIT(1000);
 
DCL M$SI$ PTR STATIC;
DCL M$OUT$ PTR STATIC;
 
%EJECT;
                                   /*
                                        I/O FPTs here
                                                                  */
     %FPT_OPEN      (FPTN=OPEN_SI_IN,
                         FUN=IN,
                         ACS=SEQUEN,
                         DCB=M$SI);
 
     %FPT_OPEN      (FPTN=OPEN_SI_TEST,
                         TEST=YES,
                         FPARAM=FPARAM_BUF,
                         DCB=M$SI);
     %FPT_READ      (FPTN=READ_BUF1,
                         DCB=M$SI,
                         BUF=BUF1,
                         WAIT=YES);
 
     %FPT_READ      (FPTN=READ_BUF2,
                         DCB=M$SI,
                         BUF=BUF2,
                         WAIT=YES);
 
     %FPT_WRITE     (FPTN=WRITE_OU_BUF2,
                         ONEWKEY=YES,
                         KEY=FILE_KEY,
                         DCB=M$OUT,
                         BUF=BUF2,
                         WAIT=YES);
 
     %FPT_WRITE     (FPTN=WRITE_OU_BUF1,
                         ONEWKEY=YES,
                         KEY=FILE_KEY,
                         DCB=M$OUT,
                         BUF=BUF1,
                         WAIT=YES);
 
     %FPT_CLOSE     (FPTN=CLOSE_SI_REL,
                         DISP=RELEASE,
                         DCB=M$SI);
 
     %FPT_CLOSE     (FPTN=CLOSE_SI_SAVE,
                         DISP=SAVE,
                         DCB=M$SI);
 
     %FPT_CLOSE     (FPTN=CLOSE_OU_SAVE,
                         DISP=SAVE,
                         DCB=M$OUT);
 
 
     %FPT_OPEN      (FPTN=OPEN_OU_OUT,
                         ASN=FILE,
                         EXIST=NEWFILE,
                         FUN=CREATE,
                         ACS=DIRECT,
                         ORG=KEYED,
                         IFPARAM=FPARAM_BUF,
                         DCB=M$OUT);
 
     %FPT_WRITE     (FPTN=WRITE_DO_MSG,
                         BUF=WARN_MSG,
                         DCB=M$DO,
                         WAIT=YES);
 
     %FPT_WRITE     (FPTN=WOULD_BE_FOUL_MSG,
                         BUF=FOUL_MSG,
                         DCB=M$DO,
                         WAIT=YES);
 
     %FPT_WRITE     (FPTN=WOULD_BE_FOUL_MSG2,
                         BUF=FOUL_MSG2,
                         DCB=M$DO,
                         WAIT=YES);
 
     %FPT_ERRMSG    (FPTN=ERROR_PRINT,
                         BUF=MY_ERROR_BUF,
                         OUTDCB1=M$DO,
                         CODE=NIL);
 
     %P_PCB         (NAME=TUNA_PCB,
                         STCLASS="STATIC SYMDEF",
                         R=NIL,
                         W=TUNA_WORKSPACE,
                         U$=NIL,
                         WSZ=50,
                         N#=0);
 
     %XSA_PARAM     (FPTN=SI_PARAM,
                         BBUF=NIL,
                         KBUF=NIL);
 
     %XSA_PARAM     (FPTN=OU_PARAM,
                         BBUF=NIL,
                         KBUF=NIL);
 
     %F_FDS         (NAME=XUFFER,
                         DCB=M$DO,
                         BUF=BUFT);     /* reused buffer */
 
     %FPT_GDS       (FPTN=GET_DATA,
                         RESULTS=DATA_VECTOR,
                         SEGSIZE=TOTALSIZ#);
 
          %VLP_VECTOR (FPTN=DATA_VECTOR);
 
 
 
                                   /*
                                        BASED definitions
                                                                  */
     %F$DCB;
 
     %PARSE$SYM     (NAME=TUNA$SYM,
                         STCLASS="BASED");
 
     %PARSE$OUT     (NAME=TUNA$OUTBLK,
                         STCLASS="BASED");
 
     %B$JIT0;
     %U$JIT1;
     %A$JIT6X;
 
     %B$TCB;
 
     %B$ALT;
 
%SUB B$ALT=B$TCB$->B$TCB.ALT$->B$ALT;
 
%EJECT;
 
/* ************************************************************
   ***                                                      ***
   ***  Begin   T U N A   main program                      ***
   ***                                                      ***
   ************************************************************ */
 
     M$SI$ = DCBADDR(DCBNUM(M$SI));
     M$OUT$ = DCBADDR(DCBNUM(M$OUT));
 
     TUNA_PCB.ROOT$ = ADDR(TUNA_NODES);
 
     IF B$JIT$->B$JIT.CCARS > B$JIT$->B$JIT.CCDISP
     THEN
     DO;                                /* MUST BE OPTIONS ON CMD LINE */
 
        TUNA_PCB.TEXT$ = PINCRC(ADDR(B$JIT.CCBUF),B$JIT.CCDISP+1);
        TUNA_PCB.NCHARS = B$JIT.CCARS - B$JIT.CCDISP - 1;
 
        CALL X$PARSE (TUNA_PCB) ALTRET (XPERR);
 
        DO WHILE (FALSE#);
XPERR:     ;
           CALL PARSE_ERROR(1);
           CALL MXXX;
           END;                         /* DO WHILE PARSE ERROR */
 
        DO I = 0 TO TUNA_PCB.OUT$ -> TUNA$OUTBLK.NSUBLKS - 1;
 
           DO CASE (TUNA_PCB.OUT$ -> TUNA$OUTBLK.SUBLK$(I) ->
              TUNA$OUTBLK.CODE);
 
           CASE (1);
              MAXCOMPRESS_ = TRUE#;
 
           CASE (3);
              NUSBS_ = TRUE#;
 
           CASE (4);
              NWARN_ = TRUE#;
 
           CASE (5);
 
           CASE (6);
              CALL CHARBIN (MAX_PER_LINE,
                 TUNA_PCB.OUT$ -> TUNA$OUTBLK.SUBLK$(I) ->
                 TUNA$OUTBLK.SUBLK$(0) -> TUNA$SYM.TEXT);
 
              IF MAX_PER_LINE > LEN_LARGE#
                 OR
                 MAX_PER_LINE < LEN_SMALL#
              THEN
              DO;
                 CALL PARSE_ERROR(3);
                 CALL MXXX;
                 END;                   /* DO IF NUMBER TOO BIG */
 
           CASE (7);
              SENTENCES_ = TRUE#;
 
           CASE (8);
              PRUNE_ = TRUE#;
 
           CASE (9);                    /* DIRECTIVE CONVERSION? */
              CNVRT_ = TRUE#;
 
           CASE (10);                   /* 6EDIT OPTION */
              FILE_KEY.KEY_ = 100000;
              KEY_INCR = 10000;
 
           CASE (11);                   /* NSUM OPTION */
              SUMLINE_ = FALSE#;
 
           CASE (12);                   /* HERMAN OPTION */
              HERMAN_ = TRUE#;
              KEY_INCR = 10000;
              OPEN_OU_OUT.V.ORG# = %CONSEC#;
 
           END;                         /* DO CASE ON PARSE.NCODE */
 
           END;                         /* DO I = 0 TO NSUBLKS - 1 */
 
        END;                            /* DO IF OPTIONS ON CMD LINE */
 
     IF PRUNE_ AND CNVRT_
     THEN
     DO;
        CALL PARSE_ERROR (2);
        CALL MXXX;
        END;                            /* DO IF CONFLICTING OPTIONS */
 
%EJECT;
                                   /*
                                        if the user has NOT specified
                                        a record width, we set the
                                        default according to whether
                                        or not the 6EDIT option has
                                        been picked `
                                   */
     IF MAX_PER_LINE = -1
     THEN
     DO;
        IF KEY_INCR = 10000             /* 6EDIT MODE */
        THEN
           MAX_PER_LINE = MAX_6EDIT_LINE#;
        ELSE
           MAX_PER_LINE = MAX_EDIT_LINE#;
        END;                            /* DO IF RECSIZE STILL DEFAULT */
 
%EJECT;
/* ************************************************************
   ***                                                      ***
   ***    SETUP XSA$FSF information                         ***
   ***                                                      ***
   ************************************************************ */
 
     CALL M$GDS (GET_DATA)
     WHENALTRETURN DO;
        CALL ABORTME;
        END;
 
     SI_PARAM.BBUF_.BUF$ = DATA_VECTOR.PTR$;
     SI_PARAM.BBUF_.BOUND = BBUFSIZ#*4 - 1;
     SI_PARAM.KBUF_.BUF$ = PINCRW(SI_PARAM.BBUF_.BUF$,BBUFSIZ#);
     SI_PARAM.KBUF_.BOUND = KBUFSIZ#*4-1;
     OU_PARAM.BBUF_.BUF$ = PINCRW(SI_PARAM.KBUF_.BUF$,KBUFSIZ#);
     OU_PARAM.BBUF_.BOUND = BBUFSIZ#*4 - 1;
     OU_PARAM.KBUF_.BUF$ = PINCRW(OU_PARAM.BBUF_.BUF$,BBUFSIZ#);
     OU_PARAM.KBUF_.BOUND = KBUFSIZ#*4-1;
 
%EJECT;
 
/* ************************************************************
   ***                                                      ***
   ***  Read the input file - assume .FIN                   ***
   ***                                                      ***
   ************************************************************ */
 
     CALL M$OPEN (OPEN_SI_TEST)
     WHENALTRETURN DO;
        CALL ABORTME;
        END;
 
     CALL XSA$OPEN (OPEN_SI_IN,SI_PARAM)
     WHENALTRETURN DO;
        CALL XSERR_SI;
        END;
 
     IF M$SI$->F$DCB.ASN# ~= %FILE#
     THEN
     DO;
        CALL PARSE_ERROR (4);
        CALL MXXX;
        END;                            /* DO IF INPUT ~ FILE */
 
 
     BUF2ARS = 0;
 
     IF NOT M$OUT$->F$DCB.AMR#
     THEN
     DO;
        OPEN_OU_OUT.NAME_ = VECTOR(M$SI$->F$DCB.NAME#);
        OPEN_OU_OUT.ACCT_ = VECTOR(M$SI$->F$DCB.ACCT#);
        END;
     ELSE
     DO;                                /* out dcb specified on cmd line */
        IF M$OUT$->F$DCB.ASN# ~= %FILE#
        THEN
        DO;
           CALL PARSE_ERROR(5);
           CALL MXXX;
           END;
        END;
     CALL XSA$OPEN (OPEN_OU_OUT,OU_PARAM)
     WHENALTRETURN
     DO;
        CALL XSERR_OU;
        END;
 
 
%EJECT;
 
/* ***************************************************************
   *                                                             *
   * Main processing loop:  if there are still words on the      *
   *      stack, then push the top one onto the output line.     *
   *      If not, go get a record.  The arriving record may      *
   *      cause the currently assembled record to be purged,     *
   *      depending on if it has a dot or space in column 1.     *
   *      If a purge is not done, the input record is broken     *
   *      down into its component words, and the stack           *
   *      processing continues unabated.                         *
   *                                                             *
   *************************************************************** */
 
 
     DO WHILE (NOT END_OF_FILE);
 
        IF WORDS_ <= 0
        THEN
        DO;
           CALL GET_BUF1;
 
           IF END_OF_FILE THEN
           DO;
              IF SI_PARAM.ERR.CODE ~= %E$EOF
              THEN
                 CALL XSERR_SI;
              CALL PURGE_BUF2;
              CALL XSA$CLOSE (CLOSE_OU_SAVE,OU_PARAM)
              WHENALTRETURN DO;
                 CALL XSERR_OU;
                 END;
              IF M$OUT$->F$DCB.AMR#
              THEN
              DO;
                 CALL XSA$CLOSE(CLOSE_SI_SAVE,SI_PARAM);
                 END;
              ELSE
              DO;
                 CALL XSA$CLOSE(CLOSE_SI_REL,SI_PARAM)
                 WHENALTRETURN DO;
                    CALL XSERR_SI;
                    END;
                 END;
              IF SUMLINE_
              THEN
                 CALL SUMLINE;
              CALL M$EXIT;
              END;
 
           IF SUBSTR(BUF1,0,1)='.' THEN
           DO;
              LASTWD.LGTH = 0;
              CALL PURGE_BUF2;
              CALL PURGE_BUF1;
              CALL INTERNAL_CHECK;
              IF BUF1U = '.FIN'
              THEN
                 FIN=TRUE#;
              IF BUF1U = '.FIF'
              THEN
                 FIN=FALSE#;
              END;                      /* DO IF A . */
 
           ELSE
           DO;
              IF SUBSTR(BUF1,0,1)=' '
              THEN DO;
                 CALL PURGE_BUF2;
                 LASTWD.LGTH = 0;
                 END;
              IF FIN THEN
              DO;
                 CALL BREAK_INTO_WORDS;
                 END;
              ELSE
              DO;
                 WORDS_=1;
                 END;
              END;                      /* DO IF NOT A . */
           END;                         /* do if nwords<=0  */
 
        IF WORDS_ > 0 THEN
        DO;
           IF FIN THEN
           DO;
              CALL INSERT_ONE;
              END;
           ELSE
           DO;
              CALL PURGE_BUF1;
              WORDS_ = 0;
              END;
           END;                         /* DO IF WORDS_ > 0 */
 
        END;                            /* DO WHILE ~END_OF_FILE */
 
%EJECT;
 
 
XSERR_SI: PROC;
     ERROR_PRINT.V.DCB# = DCBNUM(M$SI);
     ERROR_PRINT.CODE_ = VECTOR(SI_PARAM.ERR);
     CALL PRINTERR;
END XSERR_SI;
 
XSERR_OU: PROC;
     ERROR_PRINT.V.DCB# = DCBNUM(M$OUT);
     ERROR_PRINT.CODE_ = VECTOR(OU_PARAM.ERR);
     CALL PRINTERR;
END XSERR_OU;
 
ABORTME: PROC;
     ERROR_PRINT.CODE_ = VECTOR(B$ALT.ERR);
     CALL PRINTERR;
END ABORTME;
 
 
PRINTERR: PROC;
     CALL M$ERRMSG (ERROR_PRINT)
     WHENALTRETURN DO; END;
     CALL MXXX;
END PRINTERR;
 
 
MXXX: PROC;
     CALL M$XXX;
 
END MXXX;
 
%EJECT;
 
GET_BUF1: PROC;
 
     CALL XSA$READ (READ_BUF1,SI_PARAM)
     WHENALTRETURN
     DO;
        END_OF_FILE = TRUE#;
        RETURN;
        END;
     BUF1ARS = SI_PARAM.ARS#;
     CALL INSERT(BUF1,BUF1ARS,3,'   ');
     IF BUF1ARS = 0
     THEN
        BUF1ARS = 1;
 
     DO WHILE ((SUBSTR(BUF1,BUF1ARS-1,1) = ' ')
        AND
        (BUF1ARS > 1));
        BUF1ARS = BUF1ARS - 1;
        END;                            /* do while stripping trailing blanks */
 
                                   /* special code here to detect an
                                      underscored space, which cannot
                                      be treated as a space.  we sub
                                      a known constant here, and xlate
                                      it back on output */
 
     DO WHILE(TRUE#);
        CALL INDEX (LOCATED, BS_SP, BUF1, 0) ALTRET (NO_BS_SP);
        CALL INSERT (BUF1, LOCATED, 2, BS_SPEC);
        BS_FOUND = TRUE#;
        END;
 
NO_BS_SP: ;
 
     DO WHILE (TRUE#);
        CALL INDEX (LOCATED, SP_BS, BUF1, 0) ALTRET (NO_SP_BS);
        CALL INSERT(BUF1, LOCATED, 2, SPEC_BS);
        BS_FOUND = TRUE#;
        END;
 
NO_SP_BS: ;
 
     RETURN;
 
END GET_BUF1;
 
%EJECT;
 
INSERT_ONE : PROC;
 
DCL PUNC BIT(1) ALIGNED;
DCL ALFA BIT(1) ALIGNED;
DCL TCHARLB UBIN;
DCL TCHARL CHAR(1);
DCL TCHAR2L CHAR(1);
 
     M = WTABLE.NONBL_(1)-WTABLE.START_(1)+1;
 
     IF ((BUF2ARS+M) >= MAX_PER_LINE) AND (BUF2ARS>0)
     THEN
     DO;
        CALL PURGE_BUF2;
        RETURN;
        END;
 
     IF BUF2ARS>0
     THEN
     DO;
        CALL INSERT (BUF2, BUF2ARS, 1, ' ');
        BUF2ARS = BUF2ARS + 1;
        END;
     ELSE
     DO;                                /* beginning of line */
        IF HERMAN_ AND INDENT>UNDENT
        THEN
        DO;
           BUF2ARS = INDENT-UNDENT;
           SUBSTR(BUF2,0,BUF2ARS) = ' ';
           END;
        ELSE
           IF SUBSTR(BUF1,WTABLE.START_(1),1)='.'
           THEN
           DO;
              CALL INSERT (BUF2, BUF2ARS, 1, ' ');
              BUF2ARS = BUF2ARS + 1;
              END;
        UNDENT = 0;
        END;
 
     L = WTABLE.ENDIT_(1)-WTABLE.START_(1)+1;
     CALL INSERT (BUF2, BUF2ARS, L,
        SUBSTR(BUF1, WTABLE.START_(1), L));
 
     BUF2ARS = BUF2ARS + L;
 
     IF L>SIZEC(LASTWD.WORD_)
     THEN DO;
        LASTWD.WORD_=' ';
        LASTWD.LGTH=0;
        END;
     ELSE DO;
        LASTWDT.LGTH=L;
        LASTWDT.WORD_=SUBSTR(BUF1,WTABLE.START_(1),L);
        DO WHILE (LASTWDT.LGTH>0);
           IF SUBSTR(LASTWDT.WORD_,LASTWDT.LGTH-1,1) = ' '
           THEN
              LASTWDT.LGTH = LASTWDT.LGTH - 1;
           ELSE
              EXIT;
           END;                         /* DO WHILE STRIPPING SPACES */
        CALL XLATE (LASTWDU, XTAB1, LASTWDT.WORD_);
        LASTWDT.WORD_ = LASTWDU;
        IF LASTWDT.LGTH=LASTWD.LGTH  AND LASTWDT.LGTH~=0
        THEN DO;
           IF SUBSTR(LASTWD.WORD_,0,LASTWD.LGTH) =
              SUBSTR(LASTWDT.WORD_,0,LASTWD.LGTH)
           THEN DO;
              IF NWARN_=FALSE#
              THEN DO;
                 CALL DUPWORD;
                 END;                   /* DO IF OKAY TO WARN */
              END;                      /* DO IF WORDS SAME */
           END;                         /* DO IF SIZES EQUAL */
        LASTWD.LGTH = LASTWDT.LGTH;
        LASTWD.WORD_ = LASTWDT.WORD_;
        END;                            /* DO IF L<= SIZEC(LASTWD.WORD) */
 
 
     PUNC=FALSE#;
 
     IF L > 1
     THEN
     DO;
        TCHARL = SUBSTR(BUF1, WTABLE.NONBL_(1), 1);
        TCHAR2L = SUBSTR(BUF1, WTABLE.NONBL_(1)-1, 1);
        IF TCHARL = '.'
           OR
           TCHARL = '?'
           OR
           TCHARL = ':'
           OR
           TCHARL = '!'
        THEN
        DO;
           PUNC=TRUE#;
           END;                         /* do if :!?. found */
        END;                            /* do if L>2 */
 
     IF L>2
     THEN
     DO;
        IF TCHARL = '"'
           OR
           TCHARL = ')'
           OR
           TCHARL = ']'
           OR
           TCHARL = '}'
        THEN
        DO;
           IF TCHAR2L = '.'
              OR
              TCHAR2L = '?'
              OR
              TCHAR2L = ':'
              OR
              TCHAR2L = '!'
           THEN
           DO;
              PUNC=TRUE#;
              END;                      /* do if !.?: found */
           END;                         /* do if )]}" found */
        END;                            /* do if L> 3 */
 
     IF PUNC
        AND
        SUBSTR(BUF1,WTABLE.NONBL_(1)+1,2) = '  '
     THEN
     DO;
        IF SENTENCES_
        THEN
        DO;
           CALL PURGE_BUF2;
           END;
        ELSE
        DO;
           IF WORDS_ = 1           /* was it the last "word" on the input */
           THEN
           DO;
              CALL INSERT (BUF2, BUF2ARS, 1, ' ');
              BUF2ARS = BUF2ARS + 1;
              END;
           END;
        END;                            /* do if punc found and 2 spaces */
 
     DO I=1 TO WORDS_ - 1;              /* "pop" the word stack */
        WTABLE.START_(I)=WTABLE.START_(I+1);
        WTABLE.ENDIT_(I)=WTABLE.ENDIT_(I+1);
        WTABLE.NONBL_(I)=WTABLE.NONBL_(I+1);
        END;
 
     WORDS_ = WORDS_ - 1;
     RETURN;
 
END INSERT_ONE;
 
%EJECT;
 
BREAK_INTO_WORDS: PROC;
 
 
     I = 0;
     DO WHILE(I<BUF1ARS AND SUBSTR(BUF1,I,1)=' ');
        I=I+1;
        END;
 
     IF I=BUF1ARS
     THEN
     DO;
        IF NOT HERMAN_
        THEN
           CALL PURGE_BUF1;
        RETURN;
        END;                            /* do if a blank line */
 
     DO UNTIL (I>=BUF1ARS);
        WORDS_ = WORDS_ + 1;
        WORDCOUNT_ = WORDCOUNT_ + 1;
        WTABLE.START_(WORDS_)=I;
        DO WHILE (I <= BUF1ARS AND SUBSTR(BUF1,I,1)~=' ');
           I=I+1;
           END;
        WTABLE.NONBL_(WORDS_)=I-1;
        DO WHILE (I <= BUF1ARS AND SUBSTR(BUF1,I,1)=' ');
           I=I+1;
           END;
 
        IF MAXCOMPRESS_ AND WORDS_>1
        THEN
        DO;
           WTABLE.ENDIT_(WORDS_)=WTABLE.NONBL_(WORDS_);
           END;
        ELSE
        DO;
           WTABLE.ENDIT_(WORDS_)=I-2;
           END;
        END;                            /* do until ctr bigger than buffer */
 
     IF SUBSTR(BUF1,0,1) = ' '
     THEN
        WTABLE.START_(1)=0;
 
     RETURN;
 
END BREAK_INTO_WORDS;
 
%EJECT;
 
 
 
PURGE_BUF2: PROC;
 
     IF BUF2ARS <= 0
     THEN
        RETURN;
 
     DO WHILE (SUBSTR(BUF2,BUF2ARS-1,1) = ' ' AND BUF2ARS>1);
        BUF2ARS = BUF2ARS - 1;
        END;                            /* do while trailing blanks */
 
     IF BUF2ARS = 0
     THEN
        BUF2ARS = 1;
 
     IF NOT NUSBS_
     THEN
USBS_LOOP: DO;
        CALL INDEX (J, DBL_BS, BUF2)
        WHENRETURN
        DO;
           NUSBS_ = TRUE#;
           CALL BINCHAR(SUBSTR(BUFT,0,7), FILE_KEY.KEY_/1000);
           J=0;
           DO WHILE (SUBSTR(BUFT,J,1) = '0');
              CALL INSERT (BUFT,J,1,' ');
              J=J+1;
              END;                      /* DO WHILE BLANK PADDING */
           CALL INSERT (FOUL_MSG,51,7,SUBSTR(BUFT,0,7));
           CALL M$WRITE (WOULD_BE_FOUL_MSG)
           WHENALTRETURN DO; END;
           CALL M$WRITE (WOULD_BE_FOUL_MSG2)
           WHENALTRETURN DO; END;
           EXIT USBS_LOOP;
           END;                         /* do if double backspace found */
 
        WHEREBS = 0;
        LAST_PL = 0;
        DO WHILE (TRUE#);
           CALL INDEX (J, BS_USCOREC, BUF2, LAST_PL)
           WHENALTRETURN
           DO;
              EXIT USBS_LOOP;
              END;
           WHEREBS = WHEREBS + 1;
           IF WHEREBS > SIZEC(BUF2)
           THEN
           DO;
              LAST_PL = J + 1;
              WHEREBS = 0;
              END;                      /* DO IF LOOPING */
           IF J > 0
           THEN
           DO;
              CHAR_SAVE = SUBSTR(BUF2,J-1,1);
              CALL INSERT (BUF2, J-1, 2, USCORE_BSC);
              CALL INSERT (BUF2, J+1, 1, CHAR_SAVE);
              END;
           ELSE
           DO;
              BUF2 = SUBSTR(BUF2,1,BUF2ARS-1);
              BUF2ARS = BUF2ARS - 1;
              END;
           END;                         /* DO WHILE MORE */
 
        END;                  /* DO IF OKAY TO SWITCH
                                             US AND BS */
 
     IF BS_FOUND
     THEN
     DO;
BSSP1:  DO WHILE(TRUE#);
           CALL INDEX(LOCATED, BS_SPEC, BUF2, 0)
           WHENALTRETURN
           DO;
              EXIT BSSP1;
              END;
           CALL INSERT(BUF2, LOCATED, 2, BS_SP);
           END;
BSSP2:  DO WHILE(TRUE#);
           CALL INDEX(LOCATED, SPEC_BS, BUF2, 0)
           WHENALTRETURN
           DO;
              EXIT BSSP2;
              END;
           CALL INSERT(BUF2, LOCATED, 2, SP_BS);
           END;
        END;                       /* DO only if underscored backspace found */
 
 
     WRITE_OU_BUF2.BUF_.BOUND = BUF2ARS - 1;
 
     IF SUBSTR(BUF2,0,1)='.'
     THEN
     DO;
        IF CNVRT_
        THEN
CNVRT:  DO;
           IF SUBSTR(BUF2,0,2)='..' OR SUBSTR(BUF2,0,2)='.*'
           THEN
              EXIT CNVRT;
           I=0;
           DO WHILE(I<BUF2ARS AND SUBSTR(BUF2,I,1)~=' ');
              I=I+1;
              END;
           CALL XLATE (BUFT , XTAB2, SUBSTR(BUF2,0,I));
           CALL INSERT(BUF2,0,I,SUBSTR(BUFT ,0,I));
           END;                         /* do if converting directive case */
 
        IF PRUNE_ OR HERMAN_ AND SUBSTR(BUF2,1,1)~='*'
        THEN
        DO;
           BUF2ARS = 0;
           END;
        END;
     IF BUF2ARS>0
     THEN
     DO;
        CALL XSA$WRITE (WRITE_OU_BUF2,OU_PARAM)
        WHENALTRETURN
        DO;
           CALL XSERR_OU;
           END;
        FILE_KEY.KEY_ = FILE_KEY.KEY_ + KEY_INCR;
        RECCOUNT_ = RECCOUNT_ + 1;
        END;                            /* do if not pruning */
 
     BUF2ARS = 0;
 
     RETURN;
 
END PURGE_BUF2;
 
%EJECT;
PURGE_BUF1: PROC;
 
 
     IF BUF1ARS <= 0
     THEN
        RETURN;
 
     BUF2 = SUBSTR(BUF1,0,BUF1ARS);
     BUF2ARS = BUF1ARS;
     CALL PURGE_BUF2;
 
     RETURN;
 
END PURGE_BUF1;
 
%EJECT;
 
 
INTERNAL_CHECK: PROC;
 
DCL FILL_VAL BIT(1) ALIGNED;
 
     BUF1U = ' ';
     IF BUF1ARS<MAXDIR#
     THEN
        CALL XLATE (BUF1U, XTAB1, SUBSTR(BUF1,0,BUF1ARS));
     ELSE
        CALL XLATE (BUF1U, XTAB1, SUBSTR(BUF1,0,MAXDIR#));
 
     IF SUBSTR(BUF1U,0,2)='..'
     THEN
     DO;
        DO K = 0 TO NOCH#;
 
           IF SUBSTR(BUF1U,0,NO_CHANGE.COUNT_(K)) =
              SUBSTR(NO_CHANGE.WORD_(K),0,NO_CHANGE.COUNT_(K))
           THEN
              RETURN;
 
           END;                         /* DO K WHILE SEARCHING NO_CHANGES */
 
        DO K = 0 TO FIN#;
 
           IF SUBSTR(BUF1U,0,FIN_TAB.COUNT_(K)) =
              SUBSTR(FIN_TAB.WORD_(K),0,FIN_TAB.COUNT_(K))
           THEN
           DO;
              BUF1U = '.FIN';
              RETURN;
              END;                      /* DO IF ONE FOUND IN FIN TABLE */
           END;                         /* DO K WHILE SEARCHING FIN TABLE */
 
        DO K = 0 TO FIF#;
 
           IF SUBSTR(BUF1U,0,FIF_TAB.COUNT_(K)) =
              SUBSTR(FIF_TAB.WORD_(K),0,FIF_TAB.COUNT_(K))
           THEN
           DO;
              BUF1U = '.FIF';
              RETURN;
              END;                      /* DO IF ONE FOUND IN FIF TABLE */
           END;                         /* DO K WHILE SEARCHING FIF TABLE */
        END;                            /* DO IF .. IN CC1-2 */
 
     DO K = 0 TO WARN#;
 
        IF SUBSTR(BUF1U,0,WARN_ONLY.COUNT_(K)) =
           SUBSTR(WARN_ONLY.WORD_(K),0,WARN_ONLY.COUNT_(K))
        THEN
        DO;
           CALL INSERT (WARN_MSG,54,6,SUBSTR(BUF1,0,6));
           IF NOT NWARN_
           THEN
              CALL M$WRITE (WRITE_DO_MSG);
           RETURN;
           END;                         /* DO IF WARNING STRING FOUND */
        END;                            /* DO K WHILE SEARCHING FOR WARNINGS */
 
     DO K = 0 TO PUSH#;
 
        IF SUBSTR(BUF1U,0,PUSH_TAB.COUNT_(K)) =
           SUBSTR(PUSH_TAB.WORD_(K),0,PUSH_TAB.COUNT_(K))
        THEN
        DO;
           BUF1U = '.FIF';
           CALL PUSH_ONE (K);
           RETURN;
           END;                         /* DO IF PUSHING */
        END;                            /* DO WHILE LOOKING TO PUSH */
 
     DO K = 0 TO PULL#;
 
        IF SUBSTR(BUF1U,0,PULL_TAB.COUNT_(K)) =
           SUBSTR(PULL_TAB.WORD_(K),0,PULL_TAB.COUNT_(K))
        THEN
        DO;
           CALL PULL_ONE (K,FILL_VAL);
 
           IF FILL_VAL = TRUE#
           THEN
              BUF1U = '.FIN';
           ELSE
              BUF1U = '.FIF';
 
           RETURN;
           END;                         /* DO IF PULLING */
        END;                            /* DO WHILE LOOKING TO PULL */
 
     IF SUBSTR(BUF1U,0,4)='.INL' OR SUBSTR(BUF1U,0,4)='.UNL'
     THEN
     DO;
        I = 4;
        K = 0;
        DO WHILE SUBSTR(BUF1U,I,1)=' ';
           I = I+1;
           END;
        L = ASCBIN(SUBSTR(BUF1U,I,1));
        IF L < ASCBIN('0') THEN I = I+1;
        ELSE L = ASCBIN(',');
        L = ASCBIN(',')-L;
        DO WHILE I<BUF1ARS;
           J = ASCBIN(SUBSTR(BUF1U,I,1));
           IF J<48 OR J>57 THEN EXIT;
           K = K*10+J-48;
           I = I+1;
           END;
        IF L<0
        THEN
        DO;
           K = -K;
           L = 1;
           END;
        IF SUBSTR(BUF1U,1,1)='I' THEN INDENT = INDENT*L+K;
        ELSE UNDENT = K;
        END;
 
     RETURN;
 
END INTERNAL_CHECK;
 
%EJECT;
 
PUSH_ONE: PROC (INDEX_);
 
DCL INDEX_ SBIN WORD;
 
     STACK.CURRENT_(STACK_) = FIN;
     STACK.ENTRY_(STACK_) = INDEX_;
     STACK_ = STACK_ + 1;
 
     IF STACK_ > 599
     THEN
     DO;
        CALL STACK_ERROR;               /* BUT WE DON'T RETURN */
        END;                            /* DO IF ABORTING */
 
     RETURN;
 
END PUSH_ONE;
 
PULL_ONE: PROC (INDEX_, OLD_VALUE);
 
DCL INDEX_ SBIN WORD ALIGNED;
DCL OLD_VALUE BIT(1) ALIGNED;
 
     IF STACK_ = 0
     THEN
     DO;
        CALL STACK_ERROR;               /* WE NEVER RETURN! */
        END;                            /* DO IF ERROR IN INTERNAL STACK */
 
     IF STACK.ENTRY_(STACK_-1) ~= INDEX_
     THEN
     DO;
        CALL STACK_ERROR;               /* WE NEVER RETURN! */
        RETURN;
        END;                            /* DO IF ABORTING */
 
     OLD_VALUE = STACK.CURRENT_(STACK_-1);
 
     STACK_ = STACK_ - 1;
 
     RETURN;
 
END PULL_ONE;
 
 
%EJECT;
 
STACK_ERROR: PROC;
 
DCL STACK_ERROR_ CHAR(0) STATIC INIT
(' **** Error! Nesting too deep or directive out of place: XXXX');
 
     %FPT_WRITE     (FPTN=WRITE_STACK_ERROR,
                         DCB=M$DO,
                         BUF=STACK_ERROR_,
                         WAIT=YES);
 
 
     CALL INSERT (STACK_ERROR_, 57, 4, SUBSTR(BUF1,0,4));
     CALL M$WRITE (WRITE_STACK_ERROR);
 
     CALL MXXX;
 
     RETURN;
 
END STACK_ERROR;
 
%EJECT;
 
PARSE_ERROR: PROC (INDEX_);
 
DCL INDEX_ SBIN WORD;
 
     %FPT_WRITE     (FPTN=WRITE_PARSE_ERROR,
                         DCB=M$DO,
                         BUF=NIL,
                         WAIT=YES);
 
DCL STD_ERROR CHAR(0) STATIC INIT (' **** Bad option(s)');
DCL ADV_ERROR CHAR(0) STATIC INIT (' **** Conflicting options');
DCL SIZ_ERROR CHAR(0) STATIC INIT(' **** LEN/GTH is out of range');
DCL FIL_ERROR CHAR(0) STATIC INIT(' **** Input must be disk file');
DCL OUT_ERROR CHAR(0) STATIC INIT(' **** Output must be disk file');
 
     DO CASE (INDEX_);
     CASE(1);
        WRITE_PARSE_ERROR.BUF_ = VECTOR (STD_ERROR);
 
     CASE(2);
        WRITE_PARSE_ERROR.BUF_ = VECTOR (ADV_ERROR);
 
     CASE(3);
        WRITE_PARSE_ERROR.BUF_ = VECTOR(SIZ_ERROR);
 
     CASE(4);
        WRITE_PARSE_ERROR.BUF_ = VECTOR (FIL_ERROR);
 
     CASE(5);
        WRITE_PARSE_ERROR.BUF_ = VECTOR (OUT_ERROR);
     END;
     CALL M$WRITE (WRITE_PARSE_ERROR)
     WHENALTRETURN DO; END;
     RETURN;
 
END PARSE_ERROR;
 
 
%EJECT;
 
SUMLINE: PROC;
 
DCL SUMFMT CHAR(0) STATIC INIT
  ('...%D words in formatted passages; %D lines output (~%D pages)');
DCL PAGECOUNT_ UBIN WORD STATIC;
 
     PAGECOUNT_ = (RECCOUNT_ / 56) + 1;
 
     CALL X$WRITE (XUFFER,VECTOR(SUMFMT),VECTOR(WORDCOUNT_),
        VECTOR(RECCOUNT_),VECTOR(PAGECOUNT_));
     RETURN;
 
END SUMLINE;
 
%EJECT;
 
DUPWORD: PROC;
 
DCL DUPFMT CHAR(0) STATIC INIT
  ('...duplicate word: "%.32L>A" detected at record %D.000');
DCL MYRECNO_ UBIN WORD STATIC;
 
     MYRECNO_ = FILE_KEY.KEY_ /1000;
 
     CALL X$WRITE (XUFFER,VECTOR(DUPFMT),VECTOR(LASTWD.WORD_),
        VECTOR(MYRECNO_));
     RETURN;
 
END DUPWORD;
 
 
END TUNA;
