/*M* OX - fOrtran Xref program */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DDA */
OX: PROC MAIN  ALTRET;
 
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6;
  %B$ALT;
  %F$DCB;
  %B$TCB;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;                       /* For WILD_COMPARE macro              */
/* CLUDE OX_C1; */
/* CLUDE OX_C2; */
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE XU_SUBS_C;                           /* For %DEC#                    */
%EJECT;
/**********************************\
*                                  *
*   SUBs for X$PARSE tree access   *
*                                  *
\**********************************/
 
%SUB BLK1_NSUBLKS = "BLK1$->P_OUT.NSUBLKS";
%SUB BLK1_SUBLK$  = "BLK1$->P_OUT.SUBLK$";
 
%SUB BLK2_NSUBLKS = "BLK2$->P_OUT.NSUBLKS";
%SUB BLK2_SUBLK$  = "BLK2$->P_OUT.SUBLK$";
%SUB BLK2_CODE    = "BLK2$->P_SYM.CODE";
%SUB BLK2_COUNT   = "BLK2$->P_SYM.COUNT";
%SUB BLK2_CPOS    = "BLK2$->P_SYM.CPOS";
%SUB BLK2_TEXT    = "SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)";
 
%SUB BLK3_NSUBLKS = "BLK3$->P_OUT.NSUBLKS";
%SUB BLK3_SUBLK$  = "BLK3$->P_OUT.SUBLK$";
%SUB BLK3_CODE    = "BLK3$->P_SYM.CODE";
%SUB BLK3_COUNT   = "BLK3$->P_SYM.COUNT";
%SUB BLK3_CPOS    = "BLK3$->P_SYM.CPOS";
%SUB BLK3_NDTYPE  = "BLK3$->P_SYM.NDTYPE";
%SUB BLK3_TEXT    = "SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)";
%EJECT;
%LIST;
%INCLUDE OX_C61;
%EJECT;
%INCLUDE OX_C62;
%PLIST;
%EJECT;
/***************\
*               *
*   M$ME FPTs   *
*               *
\***************/
 
%FPT_OPEN    (FPTN                     = OPEN_ME,
              ASN=DEVICE,
              DCB=M$ME,
              RES='ME  ' );
%FPT_WRITE   (FPTN                     = WRITE_ME,
              BUF=LO_BUF,
              DCB=M$ME );
%EJECT;
/***************\
*               *
*   M$LO FPTs   *
*               *
\***************/
 
%FPT_OPEN    (FPTN                     = OPEN_LO2ME,
              ASN=DEVICE,
              DCB=M$LO,
              RES='ME  ' );
%FPT_OPEN    (FPTN                     = OPEN_LO,
              DCB=M$LO,
              FUN=CREATE,
              ORG=UR );
%FPT_WRITE   (FPTN                     = WRITE_LO,
              BUF=LO_BUF,
              DCB=M$LO );
 
%FPT_DEVICE  (FPTN                     = NEW_LO_PAGE,
              DCB=M$LO,
              HDR=VLP_HDR,
              PAGE=YES );
 
%VLP_HDR     (FPTN                     = VLP_HDR,
              HEADERHEIGHT=2,
              LEN=132 );
DCL 1 USR_HDR REDEF VLP_HDR,
      2 *                    UBIN(8)   UNAL,
      2 RESETPAGE#           BIT(1),
      2 *                    UBIN(5)   UNAL,
      2 HEADERHEIGHT#        UBIN(4)   UNAL,
      2 IDENT#               UBIN(9)   UNAL,
      2 COUNT#               UBIN(9)   UNAL,
      2 LEN                  UBIN(9)   UNAL,
      2 TITLE                CHAR(135);
%EJECT;
/***************\
*               *
*   M$SI FPTs   *
*               *
\***************/
 
%FPT_OPEN    (FPTN                     = OPEN_SI,
              DCB=M$SI,
              FUN=IN );
%FPT_READ    (FPTN                     = READ_SI,
              BUF=SI_BUF,
              DCB=M$SI,
              KEY=KEY,
              KEYR=YES );
 
 
/****************\
*                *
*   M$DUP FPTs   *
*                *
\****************/
 
%FPT_OPEN    (FPTN                     = OPEN_DUP,
              ASN=FILE,
              DCB=M$DUP,
              EXIST=NEWFILE,
              FUN=CREATE,
              NAME=DUP_NAME );
%VLP_NAME    (FPTN                     = DUP_NAME,
              NAME='*DUP_NAME' );
%FPT_WRITE   (FPTN                     = WRITE_DUP,
              BUF=SI_BUF,
              DCB=M$DUP );
DCL M$DUP                    DCB;
%EJECT;
/**/
/* MISCELLANEOUS FPTs */
/**/
 
%FPT_GDS     (FPTN                     = INFLATE );
 
%VLP_VECTOR  (FPTN                     = PACK_ );
 
%VLP_VECTOR  (FPTN                     = REF_ );
 
%VLP_VECTOR  (FPTN                     = SYMBOL_ );
 
%VLP_VECTOR  (FPTN                     = CMNT_ );
 
%FPT_FDS     (FPTN                     = FDS,
              RESULTS=PACK_,                   /* This will change dynamically*/
              SEGSIZE=8192 );                  /* This will change dynamically*/
 
%FPT_ERRMSG  (FPTN                     = ERRMSG,
              DCB=NIL,
              BUF=ERR_MESG,
              CODE=ERRCODE,
              OUTDCB1=M$ME );
%VLP_ERRCODE (FPTN                     = ERRCODE,
              STCLASS=STATIC );
 
%FPT_CLOSE   (FPTN                     = CLOSEF,
              DISP=SAVE );
 
%FPT_DEVICE  (FPTN                     = DEVICEF );
 
%FPT_WRITE   (FPTN                     = WRITEF );
 
%FPT_UNFID   (FPTN                     = UNFID_SI,
              DCB=M$SI,
              LEN=SI_FID_LEN,
              TEXTFID=SI_FID );
 
%FPT_TIME    (FPTN                     = GET_TIME,
              DATE=TYME.DATE,
              DAY=TYME.DAY,
              DEST=EXT,
              SOURCE=CLOCK,
              TIME=TYME.TIME );
 
%FPT_CORRES  (FPTN                     = LOVSME,
              DCB1=M$LO,
              DCB2=M$ME );
 
%FPT_PRECORD (FPTN                     = BACKUP,
              DCB=M$SI,
              N=-1 );
%EJECT;
/**********************\
*                      *
*     PARSEr stuff     *
*                      *
\**********************/
 
%P_PCB       (NAME                     = PARSE_OX,
              R=OX_NODES,
              W=WORK,
              WSZ="SIZEW(WORK)" );
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS="BASED" );
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS="BASED" );
DCL OX_NODES                 SBIN      SYMREF;
DCL WORK                     CHAR(1000)STATIC ALIGNED;
DCL X$PARSE                  ENTRY(1)  ALTRET;
 
 
/**/
/* FORMATer stuff */
/**/
%F_FDS       (NAME                     = F_FDS,
              BUF=LO_BUF,
              DCB=M$LO,
              STCLASS=STATIC );
%EJECT;
DCL 1 KEYWORDS  STATIC,
      2 NUM_1                UBIN(9)   UNAL   INIT(     LENGTHC('ABNORMAL')),
      2 WORD_1               CHAR(12)  UNAL   INIT('ABNORMAL    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ACCEPT')),
      2 *                    CHAR(12)  UNAL   INIT('ACCEPT      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ASSIGN')),
      2 *                    CHAR(12)  UNAL   INIT('ASSIGN      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ASSIGNMENT')),
      2 *                    CHAR(12)  UNAL   INIT('ASSIGNMENT  '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('BACKSPACE')),
      2 *                    CHAR(12)  UNAL   INIT('BACKSPACE   '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('BLOCKDATA')),
      2 *                    CHAR(12)  UNAL   INIT('BLOCKDATA   '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('CALL')),
      2 *                    CHAR(12)  UNAL   INIT('CALL        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('CHARACTER')),
      2 *                    CHAR(12)  UNAL   INIT('CHARACTER   '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('CLOSE')),
      2 *                    CHAR(12)  UNAL   INIT('CLOSE       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('COMMON')),
      2 *                    CHAR(12)  UNAL   INIT('COMMON      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('COMPLEX')),
      2 *                    CHAR(12)  UNAL   INIT('COMPLEX     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('CONSTANT')),
      2 *                    CHAR(12)  UNAL   INIT('CONSTANT    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('CONTINUE')),
      2 *                    CHAR(12)  UNAL   INIT('CONTINUE    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('DATA')),
      2 *                    CHAR(12)  UNAL   INIT('DATA        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('DECODE')),
      2 *                    CHAR(12)  UNAL   INIT('DECODE      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('DEFINEFILE')),
      2 *                    CHAR(12)  UNAL   INIT('DEFINEFILE  '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('DIMENSION')),
      2 *                    CHAR(12)  UNAL   INIT('DIMENSION   '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('DOUBLE')),
      2 *                    CHAR(12)  UNAL   INIT('DOUBLE      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('DO')),
      2 *                    CHAR(12)  UNAL   INIT('DO          '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ELSEIF')),
      2 *                    CHAR(12)  UNAL   INIT('ELSEIF      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ELSE')),
      2 *                    CHAR(12)  UNAL   INIT('ELSE        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ENCODE')),
      2 *                    CHAR(12)  UNAL   INIT('ENCODE      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ENDFILE')),
      2 *                    CHAR(12)  UNAL   INIT('ENDFILE     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ENDIF')),
      2 *                    CHAR(12)  UNAL   INIT('ENDIF       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('END')),
      2 *                    CHAR(12)  UNAL   INIT('END         '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('ENTRY')),
      2 *                    CHAR(12)  UNAL   INIT('ENTRY       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('EQUIVALENCE')),
      2 *                    CHAR(12)  UNAL   INIT('EQUIVALENCE '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('EXTERNAL')),
      2 *                    CHAR(12)  UNAL   INIT('EXTERNAL    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('FIND')),
      2 *                    CHAR(12)  UNAL   INIT('FIND        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('FORMAT')),
      2 *                    CHAR(12)  UNAL   INIT('FORMAT      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('FUNCTION')),
      2 *                    CHAR(12)  UNAL   INIT('FUNCTION    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('GLOBAL')),
      2 *                    CHAR(12)  UNAL   INIT('GLOBAL      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('GOTO')),
      2 *                    CHAR(12)  UNAL   INIT('GOTO        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('IF')),
      2 *                    CHAR(12)  UNAL   INIT('IF          '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('IMPLICIT')),
      2 *                    CHAR(12)  UNAL   INIT('IMPLICIT    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('INCLUDE')),
      2 *                    CHAR(12)  UNAL   INIT('INCLUDE     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('INPUT')),
      2 *                    CHAR(12)  UNAL   INIT('INPUT       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('INQUIRE')),
      2 *                    CHAR(12)  UNAL   INIT('INQUIRE     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('INTEGER')),
      2 *                    CHAR(12)  UNAL   INIT('INTEGER     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('INTRINSIC')),
      2 *                    CHAR(12)  UNAL   INIT('INTRINSIC   '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('LOGICAL')),
      2 *                    CHAR(12)  UNAL   INIT('LOGICAL     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('NAMELIST')),
      2 *                    CHAR(12)  UNAL   INIT('NAMELIST    '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('NORMAL')),
      2 *                    CHAR(12)  UNAL   INIT('NORMAL      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('OPEN')),
      2 *                    CHAR(12)  UNAL   INIT('OPEN        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('OUTPUT')),
      2 *                    CHAR(12)  UNAL   INIT('OUTPUT      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('PARAMETER')),
      2 *                    CHAR(12)  UNAL   INIT('PARAMETER   '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('PAUSE')),
      2 *                    CHAR(12)  UNAL   INIT('PAUSE       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('PRINT')),
      2 *                    CHAR(12)  UNAL   INIT('PRINT       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('PROGRAM')),
      2 *                    CHAR(12)  UNAL   INIT('PROGRAM     '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('PUNCH')),
      2 *                    CHAR(12)  UNAL   INIT('PUNCH       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('READ')),
      2 *                    CHAR(12)  UNAL   INIT('READ        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('REAL')),
      2 *                    CHAR(12)  UNAL   INIT('REAL        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('REPEAT')),
      2 *                    CHAR(12)  UNAL   INIT('REPEAT      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('RETURN')),
      2 *                    CHAR(12)  UNAL   INIT('RETURN      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('REWIND')),
      2 *                    CHAR(12)  UNAL   INIT('REWIND      '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('SAVE')),
      2 *                    CHAR(12)  UNAL   INIT('SAVE        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('SENSE')),
      2 *                    CHAR(12)  UNAL   INIT('SENSE       '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('STOP')),
      2 *                    CHAR(12)  UNAL   INIT('STOP        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('SUBROUTINE')),
      2 *                    CHAR(12)  UNAL   INIT('SUBROUTINE  '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('TYPE')),
      2 *                    CHAR(12)  UNAL   INIT('TYPE        '),
      2 *                    UBIN(9)   UNAL   INIT(     LENGTHC('WRITE')),
      2 *                    CHAR(12)  UNAL   INIT('WRITE       ');
DCL 1 KEYWORD(0:60) REDEF KEYWORDS,
      2 LEN                  UBIN(9)   UNAL,
      2 TEXT                 CHAR(12)  UNAL;
%EJECT;
/**/
/* BASED */
/**/
 
DCL 1 CMNT(0:0)  BASED(CMNT$),
      2 KEY                  SBIN      CALIGNED,
      2 LINCNT               SBIN      CALIGNED,
      2 TEXT                 CHAR(80)  CALIGNED;
 
DCL PACKBUF    BASED(PACK_.PTR$)  CHAR(PACKSIZE)  CALIGNED;
DCL PACK(0:0)  BASED(PACK_.PTR$)  CHAR(1)  CALIGNED;
DCL PACKU(0:0) BASED(PACK_.PTR$)  UBIN(9)  CALIGNED;
DCL PACKW(0:0) BASED(PACK_.PTR$)  UBIN     CALIGNED;
 
DCL REFBUF     BASED(REF$)   CHAR(REFSIZE)  ALIGNED;
DCL REFW(0:0)  BASED(REF$)   SBIN           ALIGNED;
DCL 1 REF(0:0) BASED(REF$),
      2 NEXT                 SBIN(18)  UNAL,
      2 LINE#                SBIN(18)  UNAL;
DCL REF_EDIT(0:0) BASED(REF1$) SBIN    UNAL;
 
DCL SYMBOLBUF  BASED(SYMBOL$) CHAR(SYMBOLSIZE) ALIGNED;
DCL 1 SYMBOL(0:0)  BASED(SYMBOL$),
      2 TEXT                 CHAR(32)  UNAL,
      2 FIRST_REF            SBIN(18)  UNAL,
      2 REF_DISP             SBIN(18)  UNAL;
%EJECT;
/**/
/* BITs */
/**/
 
DCL AT_EOF                   BIT(1);
DCL CROSKEYS                 BIT(1);
DCL EDIT_KEYED               BIT(1);
DCL END_OF_REFS              BIT(1);
DCL END_STMT                 BIT(1);
DCL JUST_ONE_TYPE            BIT(1);
DCL LABELS                   BIT(1);
DCL LISTING                  BIT(1);
DCL LO_NE_ME                 BIT(1);
DCL PREV_CMNT                BIT(1);
DCL SAV_SYNTAX               BIT(36);
DCL SKIPPING_THIS_PROC       BIT(1);
DCL SYMBOLS                  BIT(1);
DCL UNITS                    BIT(1);
DCL XREF_KEYS                BIT(1);
%EJECT;
/**/
/* CHARacter items */
/**/
 
DCL CHR                      CHAR(1)   STATIC;
DCL   CHRU REDEF CHR         UBIN(9)   CALIGNED;
DCL CHR10                    CHAR(10);
DCL CR                       CHAR(1)   STATIC INIT(BINASC(15));
DCL EOR                      CHAR(1)   STATIC INIT(BINASC(0));
DCL ERR_MESG                 CHAR(120) STATIC;
DCL FORMAT1                  CHAR(0)   STATIC INIT(
    'File %A contains %D source lines,');
DCL FORMAT2                  CHAR(0)   STATIC INIT(
    'File %A contains %D source lines (%D (%D%%) are comments),');
DCL FORMAT3                  CHAR(0)   STATIC INIT(
    'File %A contains %As %D source lines,');
DCL FORMAT4                  CHAR(0)   STATIC INIT(
    'File %A contains %As %D source lines (%D (%D%%) are comments)');
DCL FORMAT5                  CHAR(0)   STATIC INIT(
    '%A contains %D source lines and:');
DCL FORMAT6                  CHAR(0)   STATIC INIT(
    '%A contains %D source lines (%D (%D%%) are comments),');
DCL FORMAT7                  CHAR(0)   STATIC INIT(
    '%6D %A which is referenced a total of %D %A');
DCL FORMAT8                  CHAR(0)   STATIC INIT(
    '%6D %A which are referenced a total of %D %A');
DCL FORMAT9                  CHAR(0)   STATIC INIT(
    '%6D Subroutine(s), Function(s) and/or Main(s)');
DCL FORMAT10                 CHAR(0)   STATIC INIT(
    '%6D X-Line(s) encountered');
DCL FORMAT11                 CHAR(0)   STATIC INIT(
    '%6D X-Line(s) encountered and treated as comments');
DCL FORMAT12                 CHAR(0)   STATIC INIT(
    '%6D Y-Line(s) encountered');
DCL FORMAT13                 CHAR(0)   STATIC INIT(
    '%6D Y-Line(s) encountered and treated as comments');
DCL FORMAT14                 CHAR(0)   STATIC INIT(
    '%6D Z-Line(s) encountered');
DCL FORMAT15                 CHAR(0)   STATIC INIT(
    '%6D Z-Line(s) encountered and treated as comments');
DCL INT7                     CHAR(7);
DCL INT8                     CHAR(8);
DCL INT9                     CHAR(9);
DCL MODULE_NAME              CHAR(31);
DCL PREV_CHR                 CHAR(1);
DCL   PREV_CHRU REDEF PREV_CHR  UBIN(9)  CALIGNED;
DCL SAV_TOKEN                CHAR(31);
DCL SI_BUF                   CHAR(80)  STATIC;
DCL  CARD(0:79) REDEF SI_BUF CHAR(1);
DCL  CARDU(0:79) REDEF SI_BUF UBIN(9) CALIGNED;
DCL SEL_NAME(0:49)           CHAR(31);
DCL SI_FID                   CHAR(31)  STATIC;
DCL TIMES_LIT                CHAR(5);
DCL TMP_BUF                  CHAR(132);
DCL TMP_TOKEN                CHAR(31);
DCL TOKEN                    CHAR(31);
DCL TOKENU(0:30) REDEF TOKEN UBIN(9)   CALIGNED;
%EJECT;
/**/
/* DCBs */
/**/
 
DCL M$LO                     DCB;
DCL M$ME                     DCB;
DCL M$SI                     DCB;
 
 
/**/
/* ENTRYs */
/**/
DCL X$WRITE                  ENTRY(22);
 
 
/**/
/* PTRs */
/**/
 
DCL B$JIT$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
DCL BLK1$                    PTR;
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL CMNT$                    PTR;
DCL M$LO$                    PTR;
DCL M$SI$                    PTR;
DCL PACK$                    PTR;
DCL REF$                     PTR;
DCL REF1$                    PTR;
DCL SYMBOL$                  PTR;
%EJECT;
/**/
/* SBINs */
/**/
 
DCL AIFSW                    SBIN;
DCL BC_NUM(0:49)             SBIN;
DCL CMNT_SIZE                SBIN;
DCL CMNTS                    SBIN;
DCL CPOS                     SBIN;
DCL DIGIT1                   SBIN;
DCL DISP                     SBIN;
DCL EXTRA                    SBIN;
DCL FLAGSW                   SBIN;
DCL FOUND_PROCS              SBIN;
DCL GET_STMT#                SBIN;
DCL GETEXP_PRNS              SBIN;
DCL HIGHEST_LINE#            SBIN;
DCL HOLCNT                   SBIN;
DCL I                        SBIN;
DCL IF_PAREN#                SBIN;
DCL INDX                     SBIN;
DCL INT7_POS                 SBIN;
DCL J                        SBIN;
DCL KEYWORD#                 SBIN;
DCL LASTKEY                  SBIN;
DCL LINCNT                   SBIN;
DCL LINE#                    SBIN;
DCL LINECNT                  SBIN;
DCL LINES                    SBIN;
DCL LO_INDX                  SBIN;
DCL LO_LEN                   SBIN;
DCL LO_POS                   SBIN;
DCL M$LO#                    SBIN;
DCL M$ME#                    SBIN;
DCL MAX_CMNTS                SBIN;
DCL MAX_PER_LINE             SBIN;
DCL MAX_REFS                 SBIN;
DCL MAX_SYMBOLS              SBIN;
DCL MIDDLE                   SBIN;
DCL MODULE_LEN               SBIN;
DCL NAMEBGN                  SBIN;
DCL NUM_ITEMS                SBIN;
DCL NUM_KEYWORDS             SBIN;
DCL NUM_NAMES                SBIN;
DCL NUM_REFS                 SBIN;
DCL PACKSIZE                 SBIN;
DCL PAGE_NUM                 SBIN;
DCL PAGE_NUM_SIZE            SBIN;
DCL PAGE_SIZE                SBIN;
DCL PAREN#                   SBIN;
DCL PPOS                     SBIN;
DCL PROC_NUM                 SBIN;
DCL R6                       SBIN;
DCL R7                       SBIN;
DCL RECKEY                   SBIN;
DCL REF_WIDTH                SBIN;
DCL REF#                     SBIN;
DCL REFSIZE                  SBIN;
DCL RETURN_CODE              SBIN;
DCL SEL_CNT                  SBIN;
DCL SEMICNT                  SBIN;
DCL SI_CNT                   SBIN;
DCL SI_FID_LEN               SBIN      STATIC;
DCL SRCHBGN                  SBIN;
DCL SRCHLGTH                 SBIN;
DCL SYMBOLSIZE               SBIN;
DCL TABLEVAL                 SBIN;
DCL TMP1                     SBIN      STATIC;
DCL TMP2                     SBIN      STATIC;
DCL TMP3                     SBIN;
DCL TOKEN_CNT(0:2)           SBIN;
DCL 1 TOKEN_COUNTS REDEF TOKEN_CNT,
      2 *(0:2)               SBIN;
DCL TOKEN_REFS(0:2)          SBIN;
DCL 1 TOKEN_REFERENCES REDEF TOKEN_REFS,
      2 *(0:2)               SBIN;
DCL TOKEN_TYPE               SBIN;
DCL TPOS                     SBIN;
DCL VALID_STMTS              SBIN;
DCL WIDTH                    SBIN;
 
 
/**/
/* UBINs */
/**/
 
DCL ALPHA(0:255)             UBIN(9)   CALIGNED;
DCL   ALPHA_TBL REDEF ALPHA  CHAR(256) CALIGNED;
DCL   1 ALPHA_STR REDEF ALPHA          CALIGNED,
        2 *                  CHAR(256);
DCL COMMENT(0:255)           UBIN(9)   CALIGNED;
DCL   COMMENT_TBL REDEF COMMENT CHAR(256) CALIGNED;
DCL   1 COMMENT_STR REDEF COMMENT      CALIGNED,
        2 *                  CHAR(256);
DCL DIGIT(0:255)             UBIN(9)   CALIGNED;
DCL   DIGIT_TBL REDEF DIGIT  CHAR(256) CALIGNED;
DCL   1 DIGIT_STR REDEF DIGIT          CALIGNED,
        2 *                  CHAR(256);
DCL LETTER(0:255)            UBIN(9)   CALIGNED;
DCL   LETTER_TBL REDEF LETTER CHAR(256)CALIGNED;
DCL   1 LETTER_STR REDEF LETTER        CALIGNED,
        2 *                  CHAR(256);
%EJECT;
/**/
/* VECTORs */
/**/
DCL FMT_                     BIT(72)   DALIGNED;
DCL FMT1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT1));
DCL FMT2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT2));
DCL FMT3_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT3));
DCL FMT4_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT4));
DCL FMT5_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT5));
DCL FMT6_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT6));
DCL FMT7_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT7));
DCL FMT8_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT8));
DCL FMT9_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT9));
DCL FMT10_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT10));
DCL FMT11_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT11));
DCL FMT12_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT12));
DCL FMT13_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT13));
DCL FMT14_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT14));
DCL FMT15_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT15));
DCL TMP2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(TMP2));
DCL VEC1_                    BIT(72)   DALIGNED;
DCL VEC2_                    BIT(72)   DALIGNED;
DCL VEC3_                    BIT(72)   DALIGNED;
DCL VEC4_                    BIT(72)   DALIGNED;
DCL VEC5_                    BIT(72)   DALIGNED;
%EJECT;
/**/
/* STRUCTUREs */
/**/
 
DCL 1 BC,
      2 NUM(0:49)            SBIN(18),
      2 NUM_CNT              SBIN(18),
      2 NAME_CNT             SBIN(18),
      2 NAME(0:49)           CHAR(32);
 
DCL 1 CNT,
      2 COMMENTS             SBIN,
      2 X                    SBIN,
      2 Y                    SBIN,
      2 Z                    SBIN;
 
DCL 1 KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 EDIT                 UBIN(27)  UNAL,
      2 EXTRA                CHAR(252) UNAL;
 
DCL LO_BUF                   CHAR(132) STATIC;
DCL 1 LST REDEF LO_BUF,
      2 EDITKEY              CHAR(9)   UNAL,
      2 CAROT                CHAR(1)   UNAL,
      2 LINCNT               CHAR(6)   UNAL,
      2 COLON                CHAR(1)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 CARD                 CHAR(80)  UNAL,
      2 *                    CHAR(34)  UNAL;
DCL 1 XREF REDEF LO_BUF,
      2 *                    CHAR(5)   UNAL,
      2 REFS                 CHAR(127) UNAL;
 
DCL 1 SKIP_BLANKS  STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),
      2 BLANK                UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(95)  UNAL   INIT(' ');
 
DCL 1 SKIP_ZEROS  STATIC,
      2 *                    CHAR(48)  UNAL   INIT(' '),
      2 ZERO                 UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(79)  UNAL   INIT(' ');
 
DCL 1 TOT,
      2 COMMENTS             SBIN,
      2 LABEL_REFS           SBIN,
      2 LINECNT              SBIN,
      2 NUM_LABELS           SBIN,
      2 NUM_SYMBOLS          SBIN,
      2 NUM_UNITS            SBIN,
      2 SYMBOL_REFS          SBIN,
      2 UNIT_REFS            SBIN,
      2 X_CNT                SBIN,
      2 Y_CNT                SBIN,
      2 Z_CNT                SBIN;
 
DCL 1 TYME  STATIC,
      2 DAY                  CHAR(4)   UNAL   INIT('    '),
      2 DAYU(0:3) REDEF DAY  UBIN(9)   UNAL,
      2 DATE                 CHAR(11)  UNAL   INIT(' '),
      2 DATEU(0:10) REDEF DATE UBIN(9) UNAL,
      2 TIME                 CHAR(8)   UNAL   INIT(' ');
DCL DAY_DATE_TIME REDEF TYME CHAR(23);
 
DCL 1 SYNTAX  STATIC,
      2 EXP_COMMA            BIT(1)    UNAL,
      2 EXP_EQUAL            BIT(1)    UNAL,
      2 RITE_PAREN           BIT(1)    UNAL,
      2 *                    BIT(33)   UNAL;
 
DCL 1 OX,
      2 OPT(0:35)            BIT(1);
%EJECT;
OX_START:
    M$LO#= DCBNUM(M$LO);
    M$LO$= DCBADDR(DCBNUM(M$LO));
    M$SI$= DCBADDR(DCBNUM(M$SI));
 
    CALL M$OPEN( OPEN_ME )    ALTRET( CALL_ERRMSG );
    CALL M$OPEN( OPEN_LO )    ALTRET( CALL_ERRMSG );
    CALL M$OPEN( OPEN_SI )    ALTRET( CALL_ERRMSG );
    IF M$SI$->F$DCB.ASN# = %DEVICE# THEN
       CALL COPY_SI_TO_STARFILE  ALTRET( CALL_ERRMSG );
 
    CALL INIT_AUTO;
    CALL INIT_TABLES;
 
    CALL PARSE ALTRET( CLOSE_FILES );
 
    CALL GET_FID_AND_WIDTH  ALTRET( CALL_ERRMSG );
%EJECT;
    DO WHILE( NOT AT_EOF );
      LINCNT= 0;
      LINECNT= 0;
      IF NOT OX.OPT(IGNORE_ENDS#) THEN DO;
           NUM_NAMES= 0;
           HIGHEST_LINE#= 0;
           TOKEN_COUNTS= '0'B;
           TOKEN_REFERENCES= '0'B; END;
      SEMICNT= 73;
      CALL FIND_ID  ALTRET( QUIT );
      DO WHILE( NOT END_STMT  AND
                NOT AT_EOF );
        CALL INSERT( PACKBUF,0,PPOS+1,' ' );
        PPOS= 0;
        PACKW(0)= 0;
        FLAGSW= 0;
        GET_STMT#= 0;
        AIFSW= 0;
        PAREN#= 0;
        CPOS= SEMICNT;
        SEMICNT= 6;
        LINE#= LINCNT;
        RECKEY= LASTKEY;
        SYNTAX= '0'B;
        PREV_CHRU= 0;
NEXTCHAR:
        CALL GET_1ST_TOKEN;
        IF RETURN_CODE < 2 THEN
             CALL DECIDE_AND_PROCESS_STMT;
        IF CMNTS > 0 THEN
             IF VALID_STMTS > 0 THEN
                  CALL DUMP_CMNTS;
             ELSE IF CPOS >= 73 THEN
                       CALL STORE_CMNT;
        END;
      IF NOT OX.OPT(IGNORE_ENDS#) THEN
           CALL REPORT;
      TOT.LINECNT= TOT.LINECNT + LINECNT;
      END;
    IF OX.OPT(IGNORE_ENDS#) THEN DO;
         MODULE_NAME= 'everything';
         MODULE_LEN= LENGTHC('everything');
/*       TOKEN_CNT(0)= TOT.NUM_LABELS;
         TOKEN_CNT(1)= TOT.NUM_SYMBOLS;
         TOKEN_CNT(2)= TOT.NUM_UNITS;
         TOKEN_REFS(0)= TOT.LABEL_REFS;
         TOKEN_REFS(1)= TOT.SYMBOL_REFS;
         TOKEN_REFS(2)= TOT.UNIT_REFS; */
         CALL REPORT;
         END;
QUIT:
    IF NOT OX.OPT(BC#) THEN
         IF (OX.OPT(SELECT#) AND
             TOT.NUM_LABELS + TOT.NUM_SYMBOLS + TOT.NUM_UNITS > 25)  OR
            NOT OX.OPT(SELECT#) THEN DO;
              F_FDS.DCB#= M$LO#;
              CALL PUT_EOF_SUMMARY;
              IF LO_NE_ME THEN DO;
                   F_FDS.DCB#= M$ME#;
                   CALL PUT_EOF_SUMMARY;
                   END;
              END;
CLOSE_FILES:
    CLOSEF.V.DCB#= DCBNUM(M$SI);
    CALL M$CLOSE( CLOSEF );
    CLOSEF.V.DCB#= DCBNUM( M$ME );
    CALL M$CLOSE( CLOSEF );
    CLOSEF.V.DCB#= M$LO#;
    CALL M$CLOSE( CLOSEF );
    CALL M$EXIT;
 
CALL_ERRMSG:
    ERRCODE=       B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    ERRMSG.V.DCB#= B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
    CALL M$ERRMSG( ERRMSG );
    ALTRETURN;
%EJECT;
GET_1ST_TOKEN: PROC  ALTRET;
 
    DO WHILE('1'B);
      CALL GETCHAR  ALTRET( EOF );
      IF RETURN_CODE > 0 THEN
           GOTO BYE;         /* RETURN_CODE = 1 tells caller to call INTRFACE */
CHK_CHR:
      IF CHR = ' ' THEN/* Since there are lotsa blanks in FORTRAN,chk them 1st*/
        GOTO NEXT;
      ELSE
        IF CHR = '(' THEN
          PAREN#= PAREN# + 1;
        ELSE
          IF CHR = ')' THEN
            PAREN#= PAREN# - 1;
          ELSE
            IF LETTER(CHRU) ~= 0 THEN           /* Is byte a letter?          */
              IF PREV_CHR = ')' THEN            /* Yep.                       */
                SYNTAX.RITE_PAREN= %YES#;
              ELSE
                ;
            ELSE
              IF CHR = ',' THEN
                IF PAREN# = 0 THEN              /* Is the comma exposed?      */
                  SYNTAX.EXP_COMMA= %YES#;      /* Yep.                       */
                ELSE
                  ;
              ELSE
                IF DIGIT(CHRU) ~= 0 THEN        /* Is byte a digit(0-9)?      */
                  IF LETTER(PREV_CHRU) ~= 0 THEN/* Is prev char a letter?     */
                    ;                           /* Yep.                       */
                  ELSE DO;
                    CALL NUMERIC  ALTRET( CHK_CHR );  /* Looks like it's a    */
                    IF RETURN_CODE > 0 THEN           /* nnH? or nnO?         */
                         GOTO BYE;
                    GOTO NEXT;
                    END;
                ELSE
                  IF CHR = '=' THEN
                    IF PAREN# = 0 THEN          /* Is equal sign exposed?     */
                      SYNTAX.EXP_EQUAL= %YES#;  /* Yep.                       */
                    ELSE
                      ;
                  ELSE
                    IF CHR = '''' OR CHR = '"' THEN DO;
                      IF PAREN# ~= 0  AND       /* Are we inside parens?      */
                        (SUBSTR(PACKBUF,0,4) = 'READ'  OR    /* Yep.          */
                         SUBSTR(PACKBUF,0,4) = 'WRIT'  OR
                         SUBSTR(PACKBUF,0,4) = 'FIND') THEN
                        CALL IS_IT_DIRECT_ACCESS  ALTRET( STOR_CHAR );
                      CALL SKIP_QUOTED  ALTRET( NEXT );
                      GOTO BYE;    /* Just return; RETURN_CODE is already set */
                      END;
                    ELSE
                      IF CHR = CR THEN
                        GOTO BYE;
                      ELSE
                        IF CHR = ';' THEN DO;
                          SEMICNT= CPOS;
                          GOTO BYE;             /* Call INTRFACE upon return  */
                          END;
                        ELSE
                          IF CHR = '/'  AND
                             SUBSTR(PACKBUF,0,6) = 'DATA' THEN DO;
                            CALL SKIP_SLASHED  ALTRET( NEXT );
                            GOTO BYE;
                            END;
STOR_CHAR:
        PACK(PPOS)= CHR;
        PPOS= PPOS + 1;
        IF PPOS >= PACKSIZE THEN
             CALL EXPAND_PACK;
        PREV_CHR= CHR;
NEXT:
        END;
BYE:
    RETURN;
EOF:
    ALTRETURN;                                /* Indicate EOF was hit         */
 
 
SKIP_SLASHED: PROC  ALTRET;
 
    CALL GETCHAR  ALTRET( EOF );
    IF RETURN_CODE > 0 THEN
         GOTO EOF;
    PREV_CHR= BINASC(0);
    IF CHR = '*' THEN                           /* Is this a comment?         */
         GOTO SLASH_50;
 
FIND_NEXT_SLASH:
    DO WHILE( CHR ~= '/' );
      CALL GETCHAR  ALTRET( EOF );
      IF RETURN_CODE > 0 THEN
         GOTO EOF;
      END FIND_NEXT_SLASH;
    GOTO XIT;
SLASH_50:
    CALL GETCHAR  ALTRET( EOF );
    IF RETURN_CODE > 0 THEN                     /* Should we CALL INTRFACE?   */
        GOTO EOF;                               /* Yep.                       */
    IF CHR ~= '*' THEN                          /* Is it '*' of '* /'?        */
         GOTO SLASH_50;
SLASH_70:
    CALL GETCHAR  ALTRET( EOF );
    IF RETURN_CODE > 0 THEN
         GOTO EOF;
    IF CHR = '/' THEN
         GOTO XIT;                              /* Found '/' of '* /'         */
    IF CHR = ' ' THEN
         GOTO SLASH_70;
    ELSE GOTO SLASH_50; /* The '*' was false alarm; Go look for another '/ *' */
 
XIT:
    ALTRETURN;
EOF:
    RETURN;
 
END SKIP_SLASHED;
 
IS_IT_DIRECT_ACCESS: PROC  ALTRET;
DCL PAREN_LVL                SBIN;
 
    CALL INDEX( I,'(',SUBSTR(PACKBUF,0,PPOS-1) )  ALTRET( RE_TURN );
    PAREN_LVL= 1;
    DO J=I+1 TO PPOS-1;
       IF SUBSTR(PACKBUF,J,1) = '=' THEN
          GOTO RE_TURN;
       ELSE
          IF SUBSTR(PACKBUF,J,1) = '(' THEN
             PAREN_LVL= PAREN_LVL + 1;
          ELSE
             IF SUBSTR(PACKBUF,J,1) = ')' THEN
                PAREN_LVL= PAREN_LVL - 1;
             ELSE
                IF SUBSTR(PACKBUF,J,1) = ',' AND PAREN_LVL = 1 THEN
                   GOTO RE_TURN;
       END;
 
IT_IS_DIRECT_ACCESS_USE:
    ALTRETURN;
 
RE_TURN:
    RETURN;
 
END IS_IT_DIRECT_ACCESS;
%EJECT;
NUMERIC: PROC  ALTRET;
 
    TPOS= PPOS;
    DO WHILE( DIGIT(CHRU) ~= 0 );
      PACK(PPOS)= CHR;
      PPOS= PPOS + 1;
      IF PPOS >= PACKSIZE THEN
           CALL EXPAND_PACK;
      CALL GETCHAR  ALTRET( EOF );
      IF RETURN_CODE > 0 THEN
           RETURN;
      DO WHILE( CHR = ' ' );                    /* Skip any and all blanks    */
        CALL GETCHAR  ALTRET( EOF );
        IF RETURN_CODE > 0 THEN
             RETURN;
        END;
      END;
    IF CHR ~= 'H'  AND                 /* Is it a Holorith or                 */
       CHR ~= 'O' THEN                 /*         Octal constant?             */
         IF CHR = 'P' OR               /* Nope!  Then is it a P spec       or */
            CHR = 'X' THEN DO;         /*                     X spec?         */
              PACK(PPOS)= CHR;
              PPOS= PPOS + 1;
              IF PPOS >= PACKSIZE THEN
                   CALL EXPAND_PACK;
              PREV_CHR= BINASC(0);              /* Clear previous character   */
              RETURN;
              END;
         ELSE ALTRETURN;                        /* Return and check CHR       */
    CALL CHARBIN( HOLCNT,SUBSTR(PACKBUF,TPOS,PPOS-TPOS) );  /* Get holorith   */
    DO I=1 TO HOLCNT;                           /* count and skip that many   */
      CALL GETCHAR  ALTRET( EOF );              /* characters                 */
      IF RETURN_CODE > 0 THEN
           RETURN;
      END;
    PREV_CHR= BINASC(0);                        /* Clear previous character   */
    RETURN;
EOF:
    RETURN;                        /* Just return; RETURN_CODE is already set */
END NUMERIC;
 
 
SKIP_QUOTED: PROC  ALTRET;
 
    PREV_CHR= CHR;                     /* Remember which kind of quote we hit */
    CALL GETCHAR  ALTRET( EOF );
    IF RETURN_CODE > 0 THEN
         RETURN;
    DO WHILE( CHR ~= PREV_CHR );      /* Skip everything up to the next quote */
      CALL GETCHAR  ALTRET( EOF );
      IF RETURN_CODE > 0 THEN
           RETURN;
      END;
    ALTRETURN;
 
EOF:
    RETURN;             /* Just return; RETURN_CODE is already equals 2 (EOF) */
 
END SKIP_QUOTED;
 
END GET_1ST_TOKEN;
%EJECT;
DECIDE_AND_PROCESS_STMT: PROC;
 
    PACK(PPOS)= BINASC(0);
TYPE_STMT:
    IF SYNTAX.RITE_PAREN THEN DO;
       IF SUBSTR(PACKBUF,0,LENGTHC('IF(')) = 'IF(' THEN DO;
          KEYWORD#= IF## - 1;
          GOTO DO_CASE;
          END;
       ELSE
          IF SUBSTR(PACKBUF,0,LENGTHC('ELSEIF(')) = 'ELSEIF(' THEN DO;
             KEYWORD#= ELSEIF## - 1;
             GOTO DO_CASE;
             END;
       END;
    IF SYNTAX.EXP_COMMA   AND
       SUBSTR(PACKBUF,0,6) = 'REPEAT' THEN DO;
         KEYWORD#= REPEAT## - 1;
         GOTO DO_CASE;
         END;
    IF SYNTAX.EXP_EQUAL THEN DO;
         IF SYNTAX.EXP_COMMA  AND
            SUBSTR(PACKBUF,0,2) = 'DO' THEN
              KEYWORD#= DO## - 1;
         ELSE IF SUBSTR(PACKBUF,0,LENGTHC('CONSTANT')) = 'CONSTANT' THEN
                   KEYWORD#= CONSTANT## - 1;
              ELSE IF SUBSTR(PACKBUF,0,LENGTHC('PARAMETER')) = 'PARAMETER'  THEN
                        KEYWORD#= PARAMETER## - 1;
                   ELSE KEYWORD#= ASSIGNMENT## - 1;
         GOTO DO_CASE;
         END;
    IF SYNTAX.EXP_COMMA  THEN DO;
       IF SUBSTR(PACKBUF,0,LENGTHC('IF(')) = 'IF(' THEN
          KEYWORD#= IF## - 1;
       ELSE
          IF SUBSTR(PACKBUF,0,LENGTHC('ELSEIF(')) = 'ELSEIF(' THEN
             KEYWORD#= ELSEIF## - 1;
          ELSE
             GOTO KEY_SERCH;
       AIFSW= AIFSW + 1;
       GOTO DO_CASE;
       END;
 
KEY_SERCH:
    KEYWORD#= 0;
    DO WHILE( KEYWORD# < NUM_KEYWORDS  AND
              SUBSTR(PACKBUF,0,KEYWORD.LEN(KEYWORD#)) ~=
                       SUBSTR(KEYWORD.TEXT(KEYWORD#),0,KEYWORD.LEN(KEYWORD#)) );
      KEYWORD#= KEYWORD# + 1;
      END;
DO_CASE:
    IF KEYWORD# < NUM_KEYWORDS  AND
       KEYWORD# ~= END##-1 THEN
         VALID_STMTS= VALID_STMTS + 1;
    DO CASE( KEYWORD# + 1 );
 
/**/  CASE( ASSIGN## );                         /* ASSIGN s TO i              */
        PPOS= LENGTHC('ASSIGN');                /* Skip past ASSIGN           */
        CALL ACRUE#  ALTRET( DONE );
        CALL SERCH;
        PPOS= PPOS + LENGTHC('TO');             /* Skip past 'TO'             */
 
/**/  CASE( ASSIGNMENT## );                     /* var = exp                  */
        PPOS= 0;
 
/**/  CASE( ABNORMAL##,
            CALL##,
            COMMON##,
            CONSTANT##,
            DATA##,
            DIMENSION##,
            ENTRY##,
            EQUIVALENCE##,
            EXTERNAL##,
            GLOBAL##,
            NAMELIST##,
            PAUSE##,
            RETURN##,
            SAVE##,
            SENSE##,
            STOP## );
        PPOS= KEYWORD.LEN(KEYWORD#);
 
/**/  CASE( PARAMETER## );
        PPOS= LENGTHC('PARAMETER(');
        FLAGSW= FLAGSW + 1;                   /* Indicate to flag statement # */
 
/**/  CASE( BLOCKDATA## );
        MODULE_NAME= 'BLOCK DATA';
        RETURN;
 
/**/  CASE( CHARACTER## );
        PPOS= KEYWORD.LEN(KEYWORD#);
        FLAGSW= FLAGSW + 1;                   /* Indicate to flag statement#s */
 
/**/  CASE( COMPLEX##,
            DOUBLE##,
            INTEGER##,
            LOGICAL##,
            REAL## );
        IF KEYWORD#+1 = DOUBLE## THEN
           IF SUBSTR(PACKBUF,KEYWORD.LEN(KEYWORD#),LENGTHC('PRECISION')) =
                                       'PRECISION' THEN
              PPOS= KEYWORD.LEN(KEYWORD#) + LENGTHC('PRECISION');
           ELSE DO;
              PPOS= 0;                        /* Must be  a variable name     */
              KEYWORD#= ASSIGNMENT## - 1;
              GOTO DO_CROSS;
              END;
        ELSE
           PPOS= KEYWORD.LEN(KEYWORD#);         /* Skip past type keyword     */
        FLAGSW= FLAGSW + 1;
        IF SUBSTR(PACKBUF,PPOS,LENGTHC('FUNCTION')) = 'FUNCTION' THEN DO;
             PPOS= PPOS + LENGTHC('FUNCTION');
             CALL ACRUE  ALTRET( DONE );
             MODULE_NAME= TOKEN;                /* Remember module name       */
             CALL SERCH;                        /* Enter it into dictionary   */
             END;
 
/**/  CASE( DEFINEFILE## );
        PPOS= LENGTHC('DEFINEFILE');
        DO WHILE( PACKU(PPOS) ~= 0 );
          IF DIGIT(PACKU(PPOS)) ~= 0 THEN DO;
               CALL ACRUE#  ALTRET( DONE );
               CHR10= TOKEN;
               CALL CONCAT( TOKEN,'F$',CHR10 );
               END;
          ELSE CALL ACRUE  ALTRET( DONE );
          CALL SERCH;
          IF CHR ~= '(' THEN
               GOTO DONE;
          PPOS= PPOS + LENGTHC('(');
          CALL GETEXP;
          DO WHILE( CHR ~= ')'  AND
                    CHR ~= EOR );
            PPOS= PPOS + LENGTHC(',');
            CALL GETEXP;
            END;
          IF CHR ~= EOR THEN DO;
               PPOS= PPOS + LENGTHC(')');
               IF PACK(PPOS) ~= EOR THEN
                    PPOS= PPOS + LENGTHC(',');
               END;
          END;
 
/**/  CASE( DO## );
        PPOS= LENGTHC('DO');
        CALL ACRUE#  ALTRET( DONE );
        CALL SERCH;
 
/**/  CASE( ENCODE##,   /* ENCODE(characters,format,start[,count])[,] list    */
            DECODE## ); /* DECODE(characters,format,start[,count])[,] list    */
        PPOS= LENGTHC('ENCODE') + LENGTHC('(');
        IF LETTER(PACKU(PPOS)) ~= 0 THEN DO;
             CALL ACRUE  ALTRET( DONE );
             CALL SERCH;
             END;
        DO WHILE( PACKU(PPOS) ~= 0  AND
                  PACK(PPOS) ~= ',' );
          PPOS= PPOS + 1;
          END;
        IF PACKU(PPOS) = 0 THEN
             GOTO DONE;
        PPOS= PPOS + 1;                         /* Skip the delimiter         */
        IF DIGIT(PACKU(PPOS)) ~= 0 THEN
             CALL ACRUE#  ALTRET( DONE );
        ELSE CALL ACRUE   ALTRET( DONE );
        CALL SERCH;
 
/**/  CASE( END## );
        END_STMT= %YES#;
 
/**/  CASE( GOTO## );
        PPOS= LENGTHC('GOTO');                  /* Skip past keyword          */
        GET_STMT#= GET_STMT# + 1;
        CALL CROSS;
        GET_STMT#= GET_STMT# - 1;
        GOTO DONE;
 
/**/  CASE( BACKSPACE##,
            CLOSE##,
            ENDFILE##,
            FIND##,
            INPUT##,
            INQUIRE##,
            OPEN##,
            OUTPUT##,
            READ##,
            REWIND##,
            WRITE## );
        PPOS= KEYWORD.LEN(KEYWORD#);
        CALL PARSE_IO_OPTIONS;
 
/**/  CASE( IF##,
            ELSEIF## );
        PPOS= KEYWORD.LEN(KEYWORD#) - 1;
        IF_PAREN#= 0;
IF_NEXT:
        PPOS= PPOS + 1;
        CHR= PACK(PPOS);
        IF CHRU = 0 THEN
             GOTO DONE;
        IF CHR = '(' THEN DO;
             IF_PAREN#= IF_PAREN# + 1;
             GOTO IF_NEXT;
             END;
        IF CHR = ')' THEN DO;
             IF_PAREN#= IF_PAREN# - 1;
             IF IF_PAREN# ~= 0 THEN
                  GOTO IF_NEXT;
             ELSE;
             END;
        ELSE GOTO IF_NEXT;
        PACKU(PPOS)= 0;                   /* Replace ')' with 0 to stop CROSS */
        SAV_SYNTAX= SYNTAX;
        PPOS= KEYWORD.LEN(KEYWORD#);
        CALL CROSS;
        PPOS= PPOS + 1;
        IF AIFSW > 0 THEN DO;
             AIFSW= 0;
             GET_STMT#= GET_STMT# + 1;
             GOTO DO_CROSS;
             END;
        SYNTAX= SAV_SYNTAX;
        SYNTAX.RITE_PAREN= '0'B;
        TPOS= 0;
        CHR= PACK(PPOS);
        IF CHRU ~= 0 THEN DO;
LIFCHAR:
             PACK(TPOS)= CHR;
             PPOS= PPOS + 1;
             TPOS= TPOS + 1;
             IF CHR = ')' THEN DO;
                  CHR= PACK(PPOS);
                  IF CHRU ~= 0 THEN DO;
                       IF LETTER(CHRU) ~= 0 THEN
                            SYNTAX.RITE_PAREN= '1'B;
                       GOTO LIFCHAR;
                       END;
                  ELSE;
                  END;
             ELSE DO;
                  CHR= PACK(PPOS);
                  IF CHRU ~= 0 THEN
                       GOTO LIFCHAR;
                  END;
             END;
IFNULL:
        PACKU(TPOS)= 0;
        GOTO TYPE_STMT;
 
/**/  CASE( PRINT##,
            PUNCH## );
        PPOS= KEYWORD.LEN(KEYWORD#);
        IF DIGIT(PACKU(PPOS)) ~= 0 THEN
             CALL ACRUE#  ALTRET( DONE );
        ELSE CALL ACRUE   ALTRET( DONE );
        CALL SERCH;
 
/**/  CASE( PROGRAM##,
            FUNCTION##,
            SUBROUTINE## );
        FLAGSW= FLAGSW + 1;            /* Indicate to flag statement#s        */
GET_MODULE_NAME:
        PPOS= KEYWORD.LEN(KEYWORD#);
        IF DIGIT(PACKU(PPOS)) ~= 0 THEN
             CALL ACRUE#  ALTRET( DONE );
        ELSE CALL ACRUE   ALTRET( DONE );
        CALL SERCH;
        MODULE_NAME= TOKEN;
 
/**/  CASE( REPEAT## );
        PPOS= LENGTHC('REPEAT');
        CALL ACRUE  ALTRET( DONE );
        IF CHR ~= ',' THEN
             GOTO DONE;
        CALL SERCH;
        PPOS= PPOS + LENGTHC(',');
        CHR= PACK(PPOS);
        IF CHR = EOR THEN
             GOTO DONE;
        IF CHR = 'W' THEN
             TMP1= LENGTHC('WHILE');
        ELSE TMP1= LENGTHC('FOR');
        DO TMP2=0 TO TMP1-1;
          PPOS= PPOS + 1;
          IF PACK(PPOS) = EOR THEN
               GOTO DONE;
          END;
 
/**/  CASE( CONTINUE##,
            IMPLICIT## );
        RETURN;
 
/**/  CASE( ELSE );
        RETURN;
      END;
 
DO_CROSS:
    CALL CROSS;
DONE:
    RETURN;
 
 
CROSS: PROC;
 
    CALL GETEXP;
    DO WHILE( CHR ~= EOR );
      PPOS= PPOS + 1;                           /* Skip past the delimiter    */
      CALL GETEXP;
      END;
    RETURN;
 
END CROSS;
 
END DECIDE_AND_PROCESS_STMT;
%EJECT;
PUT_LIST_LINE: PROC;
 
    IF PAGE_NUM <= 0 THEN
         IF SKIPPING_THIS_PROC THEN
              GOTO XIT;
         ELSE DO;
              CALL DO_WE_WANT_THIS_PROC  ALTRET( XIT );
              FOUND_PROCS= FOUND_PROCS - 1;
              END;
    LINES= LINES + 1;
    IF LINES > PAGE_SIZE THEN
         CALL PUT_LIST_HEADING;
    LO_BUF= '         >      :';
    CALL BINCHAR( INT9,LASTKEY );
    IF EDIT_KEYED THEN DO;
         CALL EDITSTR( INT9,0,5,'105'O,INT9 );
         CALL INSERT( LST.EDITKEY,0, ,SUBSTR(INT9,1,5),
                                      '.',
                                      SUBSTR(INT9,6,3) );
         END;
    ELSE CALL EDITSTR( LST.EDITKEY,0,9,'111'O,INT9 );
    CALL BINCHAR( LST.LINCNT,LINECNT );
    CALL EDITSTR( LST.LINCNT,0,5,'105'O,LST.LINCNT );
    LST.CARD= SI_BUF;
    CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$LO# );
XIT:
    RETURN;
 
END PUT_LIST_LINE;
%EJECT;
PUT_LIST_HEADING: PROC;
 
    LINES= 3;
    PAGE_NUM= PAGE_NUM + 1;
    IF PAGE_NUM > 1  AND
       B$JIT.MODE ~= %M_BATCH#  AND
       M$LO$->F$DCB.DDEV.IC#  THEN
         RETURN;
    CALL SEARCHR( MODULE_LEN,TABLEVAL,SKIP_BLANKS,MODULE_NAME );
    MODULE_LEN= MODULE_LEN + 1;
    CALL BINCHAR( INT7,PAGE_NUM );
    CALL SEARCH( INT7_POS,TABLEVAL,SKIP_ZEROS,INT7 );
    PAGE_NUM_SIZE= LENGTHC(INT7) - INT7_POS;
    CALL CONCAT( LO_BUF, 'Source listing of ',
                         SUBSTR(MODULE_NAME,0,MODULE_LEN),
                         ' in ',
                         SI_FID );
    CALL SEARCHR( LO_INDX,TABLEVAL,SKIP_BLANKS,LO_BUF );
    LO_LEN= LO_INDX + LENGTHC('DAY MON nn ''YY HH:MM:SS') +
            LENGTHC('Page ') + PAGE_NUM_SIZE + LENGTHC(' ');
    IF WIDTH > LO_LEN + 1 THEN
         EXTRA= WIDTH - LO_LEN;
    ELSE EXTRA= 2;
    LO_INDX= LO_INDX + (EXTRA/2) + LENGTHC(' ');
    CALL INSERT( LO_BUF, LO_INDX, , DAY_DATE_TIME );
    LO_INDX= LO_INDX + LENGTHC(DAY_DATE_TIME) + (EXTRA - (EXTRA / 2));
    CALL INSERT( LO_BUF,LO_INDX, ,'Page ',
                                  SUBSTR(INT7,INT7_POS,PAGE_NUM_SIZE) );
    CALL L$WRITE( LO_BUF,LO_INDX+LENGTHC('Page ')+PAGE_NUM_SIZE+1,M$LO#,'r' );
    RETURN;
 
END PUT_LIST_HEADING;
%EJECT;
PUT_XREF_LINE: PROC;
 
    LINES= LINES + 1;
    IF LINES > PAGE_SIZE THEN
         CALL PUT_XREF_HEADING;
    CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$LO# );
    LO_INDX= 0;
    LO_BUF= ' ';
    RETURN;
 
END PUT_XREF_LINE;
%EJECT;
PUT_XREF_HEADING: PROC;
 
    LINES= 3;
    PAGE_NUM= PAGE_NUM + 1;
    IF (PAGE_NUM > 1  OR OX.OPT(SELECT#)) AND
       B$JIT.MODE ~= %M_BATCH#  AND
       M$LO$->F$DCB.DDEV.IC#    THEN
         RETURN;
    TMP_BUF= LO_BUF;
/*  CALL SEARCHR( MODULE_LEN,TABLEVAL,SKIP_BLANKS,MODULE_NAME ); */
    CALL ADD_MODULE_NUM;
    CALL BINCHAR( INT7,PAGE_NUM );
    CALL SEARCH( INT7_POS,TABLEVAL,SKIP_ZEROS,INT7 );
    PAGE_NUM_SIZE= LENGTHC(INT7) - INT7_POS;
    CALL CONCAT( LO_BUF, 'Cross reference of ',
                         SUBSTR(MODULE_NAME,0,MODULE_LEN),
                         ' in ',
                         SI_FID );
    CALL SEARCHR( LO_INDX,TABLEVAL,SKIP_BLANKS,LO_BUF );
    LO_LEN= LO_INDX + LENGTHC('DAY MON nn ''YY HH:MM:SS') +
            LENGTHC('Page ') + PAGE_NUM_SIZE + LENGTHC(' ');
    IF WIDTH > LO_LEN + 1 THEN
         EXTRA= WIDTH - LO_LEN;
    ELSE EXTRA= 2;
    LO_INDX= LO_INDX + (EXTRA/2) + LENGTHC(' ');
    CALL INSERT( LO_BUF,LO_INDX, ,DAY_DATE_TIME );
    LO_INDX= LO_INDX + LENGTHC(DAY_DATE_TIME) + (EXTRA - (EXTRA / 2));
    CALL INSERT( LO_BUF,LO_INDX, ,'Page ',
                                  SUBSTR(INT7,INT7_POS,PAGE_NUM_SIZE) );
    CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$LO#,'r' );
    LO_BUF= TMP_BUF;
    RETURN;
 
END PUT_XREF_HEADING;
%EJECT;
L$WRITE: PROC( BUF,SIZ,DCB#,DVFC,DCB2#,ECHO );
DCL BUF                      CHAR(SYZ);
DCL SIZ                      SBIN;
DCL DCB#                     UBIN;
DCL DVFC                     CHAR(1);  /* Optional parameter */
DCL DCB2#                    UBIN;     /* Optional parameter */
DCL ECHO                     BIT(1);   /* Optional parameter */
 
DCL ORIGVFC                  CHAR(1)   STATIC;
DCL SYZ                      SBIN      STATIC;
 
    WRITEF.BUF_.BUF$= ADDR(BUF);
    IF SIZ < 0 THEN DO;
         SYZ= -SIZ;
         CALL SEARCHR( SYZ,TABLEVAL,SKIP_BLANKS,BUF );
         IF SYZ = -SIZ THEN  /* WAS BUF BLANK? */
              SYZ= 1;
         ELSE SYZ= SYZ + 1;
         END;
    ELSE SYZ= SIZ;
    IF SYZ > 0 THEN
         WRITEF.BUF_.BOUND= SYZ - 1;
    ELSE WRITEF.BUF_= VECTOR(NIL);
    WRITEF.V.DCB#= DCB#;
    IF ADDR(DVFC) ~= ADDR(NIL) THEN DO;
         ORIGVFC= DCBADDR(DCB#)->F$DCB.DVFC#;   /* Save present DVFC          */
         DEVICEF.V.DVFC#= DVFC;
         DEVICEF.V.DCB#= DCB#;
         CALL M$DEVICE( DEVICEF );              /* Set specified DVFC         */
         CALL M$WRITE( WRITEF );                /* WRITE line with DVFC       */
         IF ADDR(DCB2#) ~= ADDR(NIL) THEN
              IF ADDR(ECHO) = ADDR(NIL) OR
                 ECHO  THEN DO;
                   DEVICEF.V.DCB#= DCB2#;
                   CALL M$DEVICE( DEVICEF );
                   WRITEF.V.DCB#= DCB2#;
                   CALL M$WRITE( WRITEF );
                   DEVICEF.V.DVFC#= ORIGVFC;
                   CALL M$DEVICE( DEVICEF );
                   END;
         DEVICEF.V.DCB#= DCB#;
         DEVICEF.V.DVFC#= ORIGVFC;
         CALL M$DEVICE( DEVICEF );              /* Restore previous DVFC      */
         END;
    ELSE DO;                                    /* WRITE the line             */
         CALL M$WRITE( WRITEF );
         IF ADDR(DCB2#) ~= ADDR(NIL) THEN
              IF ADDR(ECHO) = ADDR(NIL) OR
                   ECHO  THEN DO;
                   WRITEF.V.DCB#= DCB2#;
                   CALL M$WRITE( WRITEF );
                   END;
         END;
    RETURN;
 
END L$WRITE;
%EJECT;
GETCHAR: PROC  ALTRET;
 
    RETURN_CODE= 0;
    IF CPOS < 72 THEN DO;
         CHR= CARD(CPOS);
         CPOS= CPOS + 1;
         END;
    ELSE DO;
           IF SI_CNT > 0  AND
              VALID_STMTS > 0 THEN DO;
                LINECNT= LINECNT + 1;
                IF LISTING THEN
                     CALL PUT_LIST_LINE;
                END;
READ_AGN:
           SI_BUF= ' ';
           CALL M$READ( READ_SI )  ALTRET( CHECK_ERR );
CONTINUE:
           SI_CNT= SI_CNT + 1;
           IF EDIT_KEYED THEN
                IF KEY.LEN = 3 THEN
                     LASTKEY= KEY.EDIT;
                ELSE DO;
                     EDIT_KEYED= %NO#;
                     LASTKEY= SI_CNT;
                     END;
           ELSE LASTKEY= SI_CNT;
           IF LASTKEY > HIGHEST_LINE# THEN
              HIGHEST_LINE#= LASTKEY;
           IF LINCNT <= 0 THEN DO;
                LINE#= LINE# + 1;
                RECKEY= LASTKEY;
                END;
           LINCNT= LINCNT + 1;
           CHR= CARD(0);
           IF CARD(0) = 'X' THEN
                CNT.X= CNT.X + 1;
           ELSE IF CARD(0) = 'Y' THEN
                     CNT.Y= CNT.Y + 1;
                ELSE IF CARD(0) = 'Z' THEN
                          CNT.Z= CNT.Z + 1;
           IF COMMENT(CHRU) ~= 0 THEN DO;
                CNT.COMMENTS= CNT.COMMENTS + 1;
                IF END_STMT THEN
                     CPOS= 73;
                ELSE DO;
                     CALL STORE_CMNT;
                     VALID_STMTS= 0;
                     GOTO READ_AGN;
                     END;
                END;
           ELSE IF NOT END_STMT THEN DO;
                     IF DIGIT(CARDU(0)) ~= 0 THEN  /* Is first byte numeric?  */
                          CPOS= 0;
                     ELSE CPOS= 1;
                     CALL CROSS_STMT#;
                     CHR= CARD(5);
                     IF CHR ~= ' '  AND
                        CHR ~= '0' THEN DO;
                          RETURN_CODE= 0;
                          CHR= CARD(6);
                          CPOS= 7;
                          END;
                     ELSE CPOS= 5;
                     END;
           END;
DONE:
    RETURN;
 
CHECK_ERR:
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$LD THEN          /* Lost Data? */
         GOTO CONTINUE;
    AT_EOF= %YES#;
    RETURN_CODE= 2;
    ALTRETURN;
 
END GETCHAR;
 
 
CROSS_STMT#: PROC;
 
    RETURN_CODE= 1;
    IF SUBSTR(SI_BUF,CPOS,LENGTHC('12345')-CPOS) ~= ' ' THEN DO;
         TOKEN= ' ';
         TPOS= 0;
         DO I=CPOS TO 4;
           IF CARD(I) ~= ' ' THEN DO;
                SUBSTR(TOKEN,TPOS,1)= CARD(I);
                TPOS= TPOS + 1;
                END;
           END;
         FLAGSW= FLAGSW + 1;
         TMP1= LINE#;
         LINE#= LINCNT;
         TMP2= RECKEY;
         RECKEY= LASTKEY;
         CALL SERCH;
         LINE#= TMP1;
         RECKEY= TMP2;
         FLAGSW= FLAGSW - 1;
         END;
    RETURN;
 
END CROSS_STMT#;
%EJECT;
/******************************************************************************\
*                                                                              *
*   GETEXP is called to ACCRUE and XREF a sub-expression.  GETEXP stops when   *
*   it finds an unmatched close parenthesis or an exposed comma, equal sign or *
*   quote mark.                                                                *
*                                                                              *
\******************************************************************************/
 
GETEXP: PROC;
 
    CHR= PACK(PPOS);
    GETEXP_PRNS= 0;
    DO WHILE( CHR ~= EOR );
      IF CHR = '.' THEN DO;
           PPOS= PPOS + 1;
           DO WHILE( ALPHA(PACKU(PPOS)) ~= 0 );
             PPOS= PPOS + 1;
             END;
           CHR= PACK(PPOS);
           IF CHR = EOR THEN
                RETURN;
           ELSE IF CHR = '.' THEN DO;/* If another '.', chk logical operators */
                     IF SUBSTR(PACKBUF,PPOS,LENGTHC('.OR.')) = '.OR.'   OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.AND.')) = '.AND.' OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.NOT.')) = '.NOT.' OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.EOR.')) = '.EOR.' OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.LT.')) = '.LT.'   OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.LE.')) = '.LE.'   OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.EQ.')) = '.EQ.'   OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.NE.')) = '.NE.'   OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.GE.')) = '.GE.'   OR
                        SUBSTR(PACKBUF,PPOS,LENGTHC('.GT.')) = '.GT.'  THEN
                          GOTO GET_NEXT_BYTE;
                     PPOS= PPOS + 1;
                     END;
                ELSE PPOS= PPOS + 1;
           END;
      ELSE IF (CHR = '&'  OR  CHR = '*')  AND
               KEYWORD#+1=CALL##  AND         /* Is it a CALL statement?      */
               (PACK(PPOS-1)='(' OR PACK(PPOS-1)=',') THEN DO;
                PPOS= PPOS + 1;
                GET_STMT#= GET_STMT# + 1;
                CALL ACRUE;
                CALL SERCH;
                GET_STMT#= GET_STMT# - 1;
                END;
           ELSE IF LETTER(CHRU) ~= 0 THEN DO;
                     CALL ACRUE;
                     CALL SERCH;
                     END;
                ELSE IF DIGIT(CHRU) ~= 0 THEN
                          IF GET_STMT# > 0 THEN DO;
                               CALL ACRUE;
                               CALL SERCH;
                               END;
                          ELSE DO;
GET_DIGITS:
                               TPOS= PPOS;
                               PPOS= PPOS + 1;
                               DO WHILE( DIGIT(PACKU(PPOS)) ~= 0  OR
                                         PACK(PPOS) = 'E' );
                                 PPOS= PPOS + 1;
                                 END;
                               IF PACK(PPOS) = 'S' THEN DO;
                                 PPOS= TPOS;
                                 CALL ACRUE#;
                                 CALL SERCH;
                                 PPOS= PPOS + LENGTHC('S');
                                 END;
                               END;
                     ELSE IF CHR = '(' THEN DO;
                               GETEXP_PRNS= GETEXP_PRNS + 1;
                               PPOS= PPOS + 1;
                               END;
                          ELSE IF CHR = ')' THEN DO;
                                    GETEXP_PRNS= GETEXP_PRNS - 1;
                                    IF GETEXP_PRNS < 0 THEN
                                         RETURN;
                                    ELSE PPOS= PPOS + 1;
                                    END;
                               ELSE IF CHR = ','  OR
                                       CHR = '=' THEN
                                         IF GETEXP_PRNS > 0 THEN
                                              PPOS= PPOS + 1;
                                         ELSE RETURN;
                                    ELSE IF CHR = ''''  OR
                                            CHR = '"'   OR
                                            CHR = EOR  THEN
                                              RETURN;
                                         ELSE PPOS= PPOS + 1;
      CHR= PACK(PPOS);
GET_NEXT_BYTE:
      END;
    RETURN;
 
END GETEXP;
%EJECT;
ACRUE: PROC  ALTRET;
 
    TOKEN= ' ';
    IF GET_STMT# > 0 THEN
         DO WHILE( PACKU(PPOS) ~= 0  AND
                   ALPHA(PACKU(PPOS)) = 0 );
           PPOS= PPOS + 1;
           END;
    ELSE DO WHILE( PACKU(PPOS) ~= 0   AND
                   LETTER(PACKU(PPOS)) = 0 );
           PPOS= PPOS + 1;
           END;
    TPOS= 0;
    DO WHILE( ALPHA(PACKU(PPOS)) ~= 0 );
      IF TPOS < LENGTHC(TOKEN) THEN
           CALL INSERT( TOKEN,TPOS,1,PACK(PPOS) );
      TPOS= TPOS + 1;
      PPOS= PPOS + 1;
      END;
    CHR= PACK(PPOS);
    IF TOKEN = ' ' THEN
         ALTRETURN;
    ELSE RETURN;
 
END ACRUE;
%EJECT;
ACRUE#: PROC  ALTRET;
 
    TOKEN= ' ';
    TPOS= 0;
    DO WHILE( DIGIT(PACKU(PPOS)) ~= 0 );
      IF TPOS < LENGTHC(TOKEN) THEN
           CALL INSERT( TOKEN,TPOS,1,PACK(PPOS) );
      TPOS= TPOS + 1;
      PPOS= PPOS + 1;
      END;
    CHR= PACK(PPOS);
    IF TOKEN = ' ' THEN
         ALTRETURN;
    ELSE RETURN;
 
END ACRUE#;
%EJECT;
SERCH: PROC  ALTRET;
 
    IF SUBSTR(TOKEN,0,1) >= '0'  AND            /* Is this a statement label? */
       SUBSTR(TOKEN,0,1) <= '9' THEN
         IF LABELS THEN                         /* Yep!  Do we want Labels?   */
              TOKEN_TYPE= 0;                    /*    Yep!                    */
         ELSE GOTO SRCHEND;                     /*    Nope!  Forget this one! */
    ELSE IF SUBSTR(TOKEN,0,2) = 'F$' THEN       /* Is this a I/O unit number? */
              IF UNITS THEN                     /* Yep!  Do we want Units?    */
                   TOKEN_TYPE= 2;               /*    Yep!                    */
              ELSE GOTO SRCHEND;                /*    Nope!  Forget this one! */
         ELSE IF SUBSTR(TOKEN,0,1) >= 'A'  AND  /* Is this a SYMBOL and       */
                 SUBSTR(TOKEN,0,1) <= 'Z'  AND
                 SUBSTR(TOKEN,0,2) ~= 'F$' THEN /* not a UNIT?                */
                   IF SYMBOLS THEN              /* Yep!  Do we want SYMBOLs?  */
                        TOKEN_TYPE= 1;          /*    Yep!  Sure do!          */
                   ELSE GOTO SRCHEND;           /*    Nope! Forget this one!  */
    IF DIGIT(TOKENU(0)) ~= 0  THEN DO;          /* Is this a statement Label? */
         TMP_TOKEN= TOKEN;                      /* Yep!  Right justify it     */
         TOKEN= ' ';
         SUBSTR(TOKEN,LENGTHC('12345')-TPOS)= TMP_TOKEN;
         END;
    IF OX.OPT(SELECT#) THEN
         CALL CHK_SELECTED  ALTRET( SRCHEND );
    SRCHLGTH= NUM_NAMES;
    IF NUM_NAMES < 1 THEN                       /* Anything in symbol table?  */
         GOTO CLEAR_REFS;
    SRCHBGN= NAMEBGN;
TRY_AGAIN:
    R6= SRCHLGTH;
TRY_AGAIN1:
    IF R6 ~= 1 THEN DO;
         R6= R6 / 2;
         SRCHLGTH= R6;
         R6= R6 + SRCHBGN;
         MIDDLE= R6;
         IF TOKEN = SYMBOL.TEXT(MIDDLE) THEN
              GOTO FOUND_IT1;
         IF TOKEN < SYMBOL.TEXT(MIDDLE) THEN
              GOTO TRY_AGAIN;
         R6= (NUM_NAMES+1) - MIDDLE;
         SRCHBGN= MIDDLE;
         GOTO TRY_AGAIN1;
         END;
ONE_LEFT:
    IF TOKEN = SYMBOL.TEXT(SRCHBGN) THEN
         GOTO FOUND_IT2;
    IF TOKEN >= SYMBOL.TEXT(SRCHBGN) THEN
         SRCHBGN= SRCHBGN + 1;
ENTRTEST:
    IF NUM_NAMES >= MAX_SYMBOLS-1 THEN
         CALL EXPAND_SYMBOL;
    DO I=NUM_NAMES DOWNTO SRCHBGN BY -1;        /* If NUM_NAMES <= SRCHBGN    */
      SYMBOL.TEXT(I+1)= SYMBOL.TEXT(I);         /* then make room for the new */
      SYMBOL.FIRST_REF(I+1)= SYMBOL.FIRST_REF(I);
      SYMBOL.REF_DISP(I+1)= SYMBOL.REF_DISP(I);
      END;                                      /* symbol.                    */
ENTER_SYMBOL:
    TOKEN_CNT(TOKEN_TYPE)= TOKEN_CNT(TOKEN_TYPE) + 1;
    R6= REF#;
    NUM_NAMES= NUM_NAMES + 1;
    SYMBOL.TEXT(SRCHBGN)= TOKEN;
    SYMBOL.REF_DISP(SRCHBGN)= REF#;
    GOTO NEWREF;
FOUND_IT1:
    SRCHBGN= MIDDLE;
FOUND_IT2:
    R6= REF#;
    R7= SYMBOL.FIRST_REF(SRCHBGN);           /* Get index to last ref on list */
    IF CROSKEYS THEN                            /* Cross reference on keys?   */
         IF REF_EDIT(R7) = RECKEY THEN          /* Last key entered = cur key?*/
              GOTO SRCHEND;                     /* Yep.  Don't enter it again.*/
         ELSE;
    ELSE IF REF.LINE#(R7) = LINE# THEN          /* Last reference = cur LINE#?*/
              GOTO SRCHEND;                     /* Yep.  Don't enter it again */
NOTEQ:
    REF.NEXT(R7)= REF#;                         /* Store new reference        */
NEWREF:
    TOKEN_REFS(TOKEN_TYPE)= TOKEN_REFS(TOKEN_TYPE) + 1;
    SYMBOL.FIRST_REF(SRCHBGN)= REF#;            /* Store new reference in     */
    REF#= REF# + 1;                             /* SYMBOL reference area      */
    IF REF# >= MAX_REFS THEN
         CALL EXPAND_REF;
NEWREF5:
    IF CROSKEYS THEN DO;                        /* Cross reference on keys?   */
         REF#= REF# + 1;                        /* Each reference requires 2  */
         R6= R6 + 1;                            /* words for keyed cross ref  */
         IF REF# >= MAX_REFS THEN
              CALL EXPAND_REF;
         IF FLAGSW > 0 THEN
              R7= -RECKEY;
         ELSE R7= RECKEY;
         GOTO SRCHSTVL;
         END;
SRCHNOKY:
    IF FLAGSW > 0 THEN
         R7= -LINE#;
    ELSE R7= LINE#;
SRCHSTVL:
    REFW(R6)= R7;                               /* Zero NEXT with high order  */
SRCHEND:
    RETURN;
 
CLEAR_REFS:
    DO I=0 TO MAX_REFS-1;
      REFW(I)= 0;
      END;
    DO I=0 TO MAX_SYMBOLS-1;
      SYMBOL.TEXT(I)= ' ';
      SYMBOL.FIRST_REF(I)= 0;
      SYMBOL.REF_DISP(I)= 0;
      END;
    NAMEBGN= 1;
    SRCHBGN= 1;
    REF#= 1;
    GOTO ENTRTEST;
 
END SERCH;
%EJECT;
REPORT: PROC;
 
    CALL DO_WE_WANT_THIS_PROC  ALTRET( XIT );
    PAGE_NUM= 0;
    LINES= PAGE_SIZE + 1;                     /* Force headings               */
 
    CALL BINCHAR( INT9,HIGHEST_LINE# );
    IF EDIT_KEYED THEN DO;
       CALL EDITSTR( INT9,0,5,'105'O,INT9 );
       CALL INDEX1R( DIGIT1,' ',INT9 );
       REF_WIDTH= LENGTHC(INT9) - DIGIT1;
       END;
    ELSE DO;
       CALL EDITSTR( INT9,0,8,'110'O,INT9 );
       CALL INDEX1R( DIGIT1,' ',INT9 );
       REF_WIDTH= LENGTHC(INT9) - DIGIT1 - LENGTHC(' ');
       END;
    DIGIT1= DIGIT1 + LENGTHC(' ');
    MAX_PER_LINE= (WIDTH - LENGTHC('     ')) / (REF_WIDTH + LENGTHC('* '));
 
    DO I=1 TO NUM_NAMES;
      LO_INDX= 0;
      LO_BUF= SYMBOL.TEXT(I);
      CALL PUT_XREF_LINE;
      END_OF_REFS= %NO#;
      INDX= SYMBOL.REF_DISP(I);
      DO WHILE( NOT END_OF_REFS );
        LO_POS= LO_INDX * (REF_WIDTH + LENGTHC('* '));
        IF CROSKEYS THEN DO;
             IF REF_EDIT(INDX) < 0 THEN DO;
                  SUBSTR(XREF.REFS,LO_POS+REF_WIDTH,1)= '*';
                  J= -REF_EDIT(INDX);
                  END;
             ELSE J= REF_EDIT(INDX);
             CALL BINCHAR( INT9,J );
             IF EDIT_KEYED THEN DO;
                  CALL EDITSTR( INT9,0,5,'105'O,INT9 );
                  CALL INSERT( XREF.REFS,LO_POS,REF_WIDTH,
                                  SUBSTR(INT9,DIGIT1,REF_WIDTH-LENGTHC('.000')),
                                  '.',
                                  SUBSTR(INT9,LENGTHC(' xxxxx')));
                  END;
             ELSE DO;
                  CALL EDITSTR( INT9,0,8,'110'O,INT9 );
                  CALL INSERT( XREF.REFS,LO_POS,REF_WIDTH,SUBSTR(INT9,DIGIT1) );
                  END;
             END;
        ELSE DO;
             IF REF.LINE#(INDX) >= 0 THEN
                  J= REF.LINE#(INDX);
             ELSE DO;
                  J= -REF.LINE#(INDX);
                  SUBSTR(XREF.REFS,LO_POS+REF_WIDTH,1)= '*';
                  END;
             CALL BINCHAR( INT9,J );
             CALL EDITSTR( INT9,0,8,'110'O,INT9 );
             END;
        LO_INDX= LO_INDX + 1;
        IF LO_INDX >= MAX_PER_LINE THEN
             CALL PUT_XREF_LINE;
        IF REF.NEXT(INDX) = 0 THEN
             END_OF_REFS= %YES#;
        ELSE INDX= REF.NEXT(INDX);
        END;
      IF LO_INDX > 0 THEN
           CALL PUT_XREF_LINE;
      END;
    IF MODULE_NAME = 'everything' THEN
         GOTO TALLY_TOTS;
    NUM_ITEMS= TOKEN_CNT(0) + TOKEN_CNT(1) + TOKEN_CNT(2);
    IF NUM_ITEMS <= 0 THEN
         GOTO XIT;
    NUM_REFS= TOKEN_REFS(0) + TOKEN_REFS(1) + TOKEN_REFS(2);
    IF NUM_ITEMS = TOKEN_CNT(0)  OR
       NUM_ITEMS = TOKEN_CNT(1)  OR
       NUM_ITEMS = TOKEN_CNT(2)  THEN
         JUST_ONE_TYPE= %YES#;
    ELSE JUST_ONE_TYPE= %NO#;
    F_FDS.DCB#= M$LO#;
    IF NOT OX.OPT(SUMMARIZE#)  AND
       M$LO$->F$DCB.DDEV.IC#  THEN
         ;
    ELSE CALL PUT_REPORT_SUMMARY;
CHK_ME:
    IF LO_NE_ME  AND
       OX.OPT(SUMMARIZE#) THEN DO;
         F_FDS.DCB#= M$ME#;
         CALL PUT_REPORT_SUMMARY;
         END;
TALLY_TOTS:
    TOT.COMMENTS= TOT.COMMENTS + CNT.COMMENTS;
    TOT.X_CNT= TOT.X_CNT + CNT.X;
    TOT.Y_CNT= TOT.Y_CNT + CNT.Y;
    TOT.Z_CNT= TOT.Z_CNT + CNT.Z;
    CNT= '0'B;
    TOT.NUM_LABELS= TOT.NUM_LABELS + TOKEN_CNT(0);
    TOT.NUM_SYMBOLS= TOT.NUM_SYMBOLS + TOKEN_CNT(1);
    TOT.NUM_UNITS= TOT.NUM_UNITS + TOKEN_CNT(2);
    TOT.LABEL_REFS= TOT.LABEL_REFS + TOKEN_REFS(0);
    TOT.SYMBOL_REFS= TOT.SYMBOL_REFS + TOKEN_REFS(1);
    TOT.UNIT_REFS= TOT.UNIT_REFS + TOKEN_REFS(2);
XIT:
    RETURN;
 
END REPORT;
%EJECT;
PARSE_IO_OPTIONS: PROC  ALTRET;
 
    IF PACK(PPOS) = '(' THEN DO;                /* Skip '(' after keyword     */
         PPOS= PPOS + 1;
         CHR= PACK(PPOS);
         END;
    PAREN#= 1;
    IF DIGIT(CHRU) ~= 0 THEN DO;
         CALL ACRUE#  ALTRET( OOPS );
         CHR10= TOKEN;
         CALL CONCAT( TOKEN, 'F$', CHR10 );
         CALL SERCH;
         END;
    GET_STMT#= GET_STMT# + 1;
    DO WHILE( CHRU ~= 0  AND
              PAREN# > 0 );
      CALL ACRUE  ALTRET( OOPS );
      IF CHR = '=' THEN DO;
TRY_AGAIN:
           SAV_TOKEN= TOKEN;
           CALL ACRUE  ALTRET( OOPS );
           IF CHR = '=' THEN
                GOTO TRY_AGAIN;
           ELSE
              IF CHR = ')' THEN
                 PAREN#= PAREN# - 1;
              ELSE
                 IF CHR = '(' THEN
                    PAREN#= PAREN# + 1;
           IF DIGIT(TOKENU(0)) ~= 0 THEN
                IF SAV_TOKEN = 'UNIT' THEN DO;
                     CHR10= TOKEN;
                     CALL CONCAT( TOKEN, 'F$', CHR10 );
                     END;
                ELSE
                     IF SAV_TOKEN = 'RECL' THEN /* Is it the RECL clause?     */
                          GOTO NEXT_PHRASE;     /* Yep, ignore any constants. */
           END;
      ELSE
         IF CHR = ')' THEN
            PAREN#= PAREN# - 1;
         ELSE
            IF CHR = '(' THEN
               PAREN#= PAREN# + 1;
      IF PAREN#>0  AND  SUBSTR(TOKEN,0,1)>='0' AND SUBSTR(TOKEN,0,1)<='9' THEN
         GOTO NEXT_PHRASE;
      CALL SERCH;
NEXT_PHRASE:
      END;
    GET_STMT#= GET_STMT# - 1;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_IO_OPTIONS;
%EJECT;
EXPAND_PACK: PROC;
 
    CALL EXPAND( PACK_,1 );
    PACK$= PACK_.PTR$;
    PACKSIZE= PACK_.W1.VSIZE# + 1;
    RETURN;
 
END EXPAND_PACK;
%EJECT;
EXPAND_REF: PROC;
 
    CALL EXPAND( REF_,1 );
    REF$= REF_.PTR$;
    REFSIZE= REF_.W1.VSIZE# + 1;
    DO TMP1=MAX_REFS TO (REFSIZE/LENGTHC(REF))-1;
      REFW(TMP1)= 0;
      END;
    IF M$SI$->F$DCB.ORG# = %KEYED#  AND
       XREF_KEYS  THEN
         CROSKEYS= %YES#;
    MAX_REFS= REFSIZE / LENGTHC(REF);
    RETURN;
 
END EXPAND_REF;
%EJECT;
EXPAND_SYMBOL: PROC;
 
    CALL EXPAND( SYMBOL_,1 );
    SYMBOL$= SYMBOL_.PTR$;
    SYMBOLSIZE= SYMBOL_.W1.VSIZE# + 1;
    DO TMP1=MAX_SYMBOLS TO (SYMBOLSIZE / LENGTHC(SYMBOL))-1;
      SYMBOL.TEXT(TMP1)= ' ';
      SYMBOL.FIRST_REF(TMP1)= 0;
      SYMBOL.REF_DISP(TMP1)= 0;
      END;
    MAX_SYMBOLS= SYMBOLSIZE / LENGTHC(SYMBOL);
    RETURN;
 
END EXPAND_SYMBOL;
%EJECT;
EXPAND_CMNT: PROC;
 
    CALL EXPAND( CMNT_,1 );
    CMNT_SIZE= CMNT_.W1.VSIZE# + 1;
    CMNT$= CMNT_.PTR$;
    DO TMP1=MAX_CMNTS TO (CMNT_SIZE / LENGTHC(CMNT(0)))-1;
      CMNT.KEY(TMP1)= 0;
      CMNT.LINCNT(TMP1)= 0;
      CMNT.TEXT(TMP1)= ' ';
      END;
    MAX_CMNTS= CMNT_SIZE / LENGTHC(CMNT(0));
    RETURN;
 
END EXPAND_CMNT;
%EJECT;
EXPAND: PROC( TABLE_,NUM_PAGES );
DCL NUM_PAGES                SBIN;
%VLP_VECTOR  (FPTN                     = TABLE_,
              STCLASS=);
 
    INFLATE.V.SEGSIZE#= 1024 * NUM_PAGES;
    INFLATE.RESULTS_= VECTOR(TABLE_);
    CALL M$GDS( INFLATE )  ALTRET( NO_MEM );
    RETURN;
 
NO_MEM:
    LO_BUF= '* Oh no!  Scenility is setting in!  No more memory! *';
    CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$LO# );
    CALL M$XXX;
 
END EXPAND;
%EJECT;
FIND_ID: PROC  ALTRET;
 
    IF BC.NUM_CNT + BC.NAME_CNT > 0  AND
       BC.NUM_CNT + BC.NAME_CNT <= FOUND_PROCS THEN
         GOTO OOPS;
    PROC_NUM= PROC_NUM + 1;
    PAGE_NUM= 0;
    LINES= PAGE_SIZE + 1;
    VALID_STMTS= 0;
    IF SI_CNT = 0 THEN DO;
         CPOS= 73;
         CALL GETCHAR  ALTRET( OOPS );
         END;
    DO WHILE( COMMENT(CARDU(0)) ~= 0  OR  SI_BUF = ' ' );
      CALL STORE_CMNT;
      CPOS= 73;
      CALL GETCHAR  ALTRET( OOPS );
      END;
    TMP1= SI_CNT-1;
ANOTHER:
    CALL STORE_CMNT;
    CPOS= 73;  /* Force reading another record */
    CALL GETCHAR  ALTRET( OOPS );
    IF COMMENT(CARDU(0)) = 0 THEN             /* If it's NOT a comment        */
       IF CARD(5) ~= ' '  AND                 /* AND it's not                 */
          CARD(5) ~= '0'  THEN                /* continuation line            */
          GOTO ANOTHER;
       ELSE
          ;
    ELSE
       IF CMNTS = 1 THEN
          CNT.COMMENTS= CNT.COMMENTS - 1;     /* Don't count first stmt as cmt*/
    BACKUP.V.N#= TMP1-SI_CNT;
    IF CMNTS > 0 THEN DO;
         CALL M$PRECORD( BACKUP )  ALTRET( OOPS );
         SI_CNT= SI_CNT + (TMP1-SI_CNT);
         CPOS= 73;
         END;
    MODULE_NAME= 'MAIN';
    MODULE_LEN= LENGTHC('MAIN');
    END_STMT= %NO#;
    SKIPPING_THIS_PROC= %NO#;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END FIND_ID;
%EJECT;
DUMP_CMNTS: PROC;
 
    IF LISTING THEN DO;
         TMP1= LASTKEY;
         TMP3= LINCNT;
         TMP_BUF= SI_BUF;
         DO TMP2=1 TO CMNTS;
           LASTKEY= CMNT.KEY(TMP2);
           LINCNT= CMNT.LINCNT(TMP2);
           SI_BUF= CMNT.TEXT(TMP2);
           LINECNT= LINECNT + 1;
           CALL PUT_LIST_LINE;
         END;
         LASTKEY= TMP1;
         LINCNT= TMP3;
         SI_BUF= TMP_BUF;
         END;
    ELSE LINECNT= LINECNT + CMNTS;
    CMNTS= 0;
    RETURN;
 
END DUMP_CMNTS;
%EJECT;
STORE_CMNT: PROC;
 
    CMNTS= CMNTS + 1;
    IF CMNTS >= MAX_CMNTS THEN
         CALL EXPAND_CMNT;
    CMNT.KEY(CMNTS)= LASTKEY;
    CMNT.LINCNT(CMNTS)= LINCNT;
    CMNT.TEXT(CMNTS)= SI_BUF;
    RETURN;
 
END STORE_CMNT;
%EJECT;
PARSE: PROC  ALTRET;
 
    DISP= B$JIT.CCDISP;
    IF SUBSTR(B$JIT.CCBUF,DISP,1) ~= '(' THEN
         IF B$JIT.CCDISP ~= B$JIT.CCARS THEN DO;  /* Were we M$LINKed to?     */
              DO DISP=0 TO B$JIT.CCARS-1;
                IF SUBSTR(B$JIT.CCBUF,DISP,1) = '(' THEN
                     GOTO SET_UP_PARSE;
                END;
              GOTO SET_DEFAULTS;
              END;
         ELSE GOTO SET_DEFAULTS;               /* No options; Go set defaults */
SET_UP_PARSE:
    IF SUBSTR(B$JIT.CCBUF,DISP) = '(' THEN
         GOTO SET_DEFAULTS;
    PARSE_OX.NCHARS= B$JIT.CCARS - DISP + 1;
    PARSE_OX.TEXT$ = PINCRC( ADDR(B$JIT.CCBUF),DISP );
    CALL X$PARSE( PARSE_OX )  ALTRET( PARSE_ERR );
    OX= '0'B;
    BLK1$= PARSE_OX.OUT$;
    DO I=0 TO BLK1_NSUBLKS-1;
      BLK2$= BLK1_SUBLK$(I);
      OX.OPT(BLK2_CODE)= %YES#;
      DO CASE( BLK2_CODE );
 
        CASE( BC# );
          DO J=0 TO BLK2_NSUBLKS-1;
            BLK3$= BLK2_SUBLK$(J);
            IF BLK3_NDTYPE = %DEC# THEN DO;
                 BC.NUM_CNT= BC.NUM_CNT + 1;
                 CALL CHARBIN( BC_NUM(BC.NUM_CNT),BLK3_TEXT );
                 END;
            ELSE DO;
                 BC.NAME_CNT= BC.NAME_CNT + 1;
                 BC.NAME(BC.NAME_CNT)= BLK3_TEXT;
                 END;
            END;
          IF BLK2_NSUBLKS = 1  AND
             BC.NAME(1) = 'ALL' THEN DO;
               LO_BUF= ' ';
               SUBSTR(LO_BUF,LENGTHC('!')+DISP+BLK3_CPOS,1)= '^';
               CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
               LO_BUF= '.. If this ALL isn''t a subroutine name, Don''t specify the BC param';
               CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
               END;
 
        CASE( IGNORE_ENDS# );
 
        CASE( LABELS# );
          LABELS= %YES#;
          IF NOT OX.OPT(UNITS#) THEN
               UNITS= %NO#;
          IF NOT OX.OPT(SYMBOLS#) THEN
               SYMBOLS= %NO#;
 
        CASE( LISTING# );
          LISTING= %YES#;
 
        CASE( NO_LABELS# );
          LABELS= %NO#;
 
        CASE( NO_LISTING# );
          LISTING= %NO#;
 
        CASE( NO_SYMBOLS# );
          SYMBOLS= %NO#;
 
        CASE( NO_UNITS# );
          UNITS= %NO#;
        CASE( NO_X# );
          OX.OPT(X#)= %NO#;
          CALL INSERT( COMMENT_TBL,ASCBIN('X'),1,' ' );/* X-Lines are comments*/
 
        CASE( NO_Y# );
          OX.OPT(Y#)= %NO#;
          CALL INSERT( COMMENT_TBL,ASCBIN('Y'),1,' ' );/* Y-Lines are comments*/
 
        CASE( NO_Z# );
          OX.OPT(Z#)= %NO#;
          CALL INSERT( COMMENT_TBL,ASCBIN('Z'),1,' ' );/* Z-Lines are comments*/
 
        CASE( PUT_TOTALS# );
 
        CASE( SELECT# );
          DO J=0 TO BLK2_NSUBLKS-1;
            BLK3$= BLK2_SUBLK$(J);
            SEL_CNT= SEL_CNT + 1;
            IF BLK3_NDTYPE = %DEC# THEN
                 IF BLK3_COUNT > LENGTHC('12345') THEN DO;
                      LO_BUF= ' ';
                      SUBSTR(LO_BUF,LENGTHC('!')+DISP+BLK3_CPOS,1)= '^';
                      CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
                      LO_BUF= '.. Statement label too long. Five digit maximum';
                      CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
                      GOTO OOPS;
                      END;
                 ELSE DO;
                      SEL_NAME(SEL_CNT)= ' ';
                      SUBSTR(SEL_NAME(SEL_CNT),LENGTHC('12345')-BLK3_COUNT)=
                                                                      BLK3_TEXT;
                      END;
            ELSE SEL_NAME(SEL_CNT)= BLK3_TEXT;
            END;
 
        CASE( SUMMARIZE# );
          OX.OPT(PUT_TOTALS#)= %YES#;
 
        CASE( SYMBOLS# );
          SYMBOLS= %YES#;
          IF NOT OX.OPT(UNITS#) THEN
               UNITS= %NO#;
          IF NOT OX.OPT(LABELS#) THEN
               LABELS= %NO#;
 
        CASE( UNITS# );
          UNITS= %YES#;
          IF NOT OX.OPT(LABELS#) THEN
               LABELS= %NO#;
          IF NOT OX.OPT(SYMBOLS#) THEN
               SYMBOLS= %NO#;
 
        CASE( WIDTH## );
          BLK3$= BLK2_SUBLK$(0);
          CALL CHARBIN( WIDTH,BLK3_TEXT );
 
        CASE( X# );
          TOT.X_CNT= 0;
          COMMENT(ASCBIN('X'))= 0;              /* X commands aren't comments */
 
        CASE( Y# );
          TOT.Y_CNT= 0;
          COMMENT(ASCBIN('Y'))= 0;              /* Y commands aren't comments */
 
        CASE( Z# );
          TOT.Z_CNT= 0;
          COMMENT(ASCBIN('Z'))= 0;              /* Z commands aren't comments */
 
        CASE( ELSE );
          LO_BUF= '.. Oops!  PARTRGE knows of an option that OX doesn''t';
          CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
          GOTO OOPS;
        END;
      END;
    RETURN;
 
PARSE_ERR:
    LO_BUF= ' ';
    SUBSTR(LO_BUF,LENGTHC('!')+DISP+PARSE_OX.HI_CHAR,1)= '^';
    CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
    LO_BUF= '.. Invalid OX option specified; Parsing stopped about here';
    CALL L$WRITE( LO_BUF,-LENGTHC(LO_BUF),M$ME# );
OOPS:
    ALTRETURN;
 
SET_DEFAULTS:
    OX= '0'B;
    OX.OPT(PUT_TOTALS#)= %YES#;
    LISTING= %NO#;
    LABELS= %YES#;
    UNITS= %YES#;
    SYMBOLS= %YES#;
    RETURN;
 
END PARSE;
%EJECT;
CHK_SELECTED: PROC  ALTRET;
 
    DO I=1 TO SEL_CNT;
      IF TOKEN = SEL_NAME(I) THEN
           RETURN;
      END;
    ALTRETURN;
 
END CHK_SELECTED;
%EJECT;
PUT_SUMMARY: PROC( CNT,WHAT,REFS );
DCL CNT                      UBIN;
DCL WHAT                     CHAR(8);
DCL REFS                     UBIN;
 
DCL LEN                      SBIN;
 
    IF CNT = 0  AND
       REFS = 0  THEN
         GOTO XIT;
    CALL INDEX( LEN,' ',WHAT );
    VEC1_= VECTOR(CNT);
    IF CNT = 1 THEN
         VEC2_= VECTOR(SUBSTR(WHAT,0,LEN-1));
    ELSE VEC2_= VECTOR(SUBSTR(WHAT,0,LEN));
    VEC3_= VECTOR(REFS);
    IF REFS = 1 THEN
         VEC4_= VECTOR(SUBSTR(TIMES_LIT,0,LENGTHC('time')));
    ELSE VEC4_= VECTOR(TIMES_LIT);
    IF CNT = 1 THEN
         FMT_= FMT7_;
    ELSE FMT_= FMT8_;
    CALL X$WRITE( F_FDS,FMT_,VEC1_,VEC2_,VEC3_,VEC4_ );
XIT:
    RETURN;
 
END PUT_SUMMARY;
%EJECT;
DO_WE_WANT_THIS_PROC: PROC  ALTRET;
 
    IF BC.NUM_CNT + BC.NAME_CNT > 0 THEN DO;
         DO J=1 TO BC.NUM_CNT;
           IF PROC_NUM = BC_NUM(J) THEN
                GOTO XIT;
           END;
         DO J=1 TO BC.NAME_CNT;
           IF MODULE_NAME = BC.NAME(J) THEN
                GOTO XIT;
           END;
         SKIPPING_THIS_PROC= %YES#;
         ALTRETURN;
         END;
XIT:
    FOUND_PROCS= FOUND_PROCS + 1;
    RETURN;
 
END DO_WE_WANT_THIS_PROC;
%EJECT;
INIT_AUTO: PROC;
 
/**/
/* Initialize BIT items */
/**/
    AT_EOF= %NO#;
    CROSKEYS= %YES#;
    IF M$SI$->F$DCB.ORG# = %KEYED# THEN
       EDIT_KEYED= %YES#;
    ELSE
       EDIT_KEYED= %NO#;
    END_STMT= %YES#;
    LABELS= %YES#;
    LISTING= %NO#;
    SYMBOLS= %YES#;
    UNITS= %YES#;
    XREF_KEYS= %YES#;
 
/**/
/* Initialize CHARacter items */
/**/
    TIMES_LIT= 'times';
 
/**/
/* Initialize SBIN items */
/**/
    BC.NUM_CNT= 0;
    BC.NAME_CNT= 0;
    CMNTS= 0;
    FOUND_PROCS= 0;
    LINCNT= 0;
    LINE#= 0;
    LINECNT= 0;
    M$ME#= DCBNUM(M$ME);
    MAX_CMNTS= 0;
    MAX_REFS= 0;
    MAX_SYMBOLS= 0;
    NUM_KEYWORDS= LENGTHC(KEYWORDS) /
                     (LENGTHC(KEYWORDS.NUM_1)+LENGTHC(KEYWORDS.WORD_1));
    NUM_NAMES= 0;
    PPOS= 0;
    PROC_NUM= 0;
    SEL_CNT= 0;
    SI_CNT= 0;
    TOKEN_COUNTS= '0'B;
    TOKEN_REFERENCES= '0'B;
    WIDTH= 0;
 
/**/
/* Initialize STRUCTURES */
/**/
    CNT= '0'B;
    TOT= '0'B;
    RETURN;
 
END INIT_AUTO;
%EJECT;
INIT_TABLES: PROC;
 
    COMMENT_STR= '0'B;
    CALL INSERT( COMMENT_TBL,ASCBIN('C'),1,' ' );
    CALL INSERT( COMMENT_TBL,ASCBIN('*'),1,' ' );
    CALL INSERT( COMMENT_TBL,ASCBIN('/'),1,' ' );
    CALL INSERT( COMMENT_TBL,ASCBIN('$'),1,' ' );
    CALL INSERT( COMMENT_TBL,ASCBIN('S'),1,' ' );
    CALL INSERT( COMMENT_TBL,ASCBIN('X'),1,' ' );/* X-Lines are comments*/
    CALL INSERT( COMMENT_TBL,ASCBIN('Y'),1,' ' );/* Y-Lines are comments*/
    CALL INSERT( COMMENT_TBL,ASCBIN('Z'),1,' ' );/* Z-Lines are comments*/
 
    LETTER_STR= '0'B;
    CALL INSERT( LETTER_TBL,ASCBIN('A'),26,' ' );   /* A-Z                    */
    CALL INSERT( LETTER_TBL,ASCBIN('$'),1,' ' );    /*     $                  */
    CALL INSERT( LETTER_TBL,ASCBIN('_'),1,' ' );    /*       _                */
 
    DIGIT_STR= '0'B;
    CALL INSERT( DIGIT_TBL,ASCBIN('0'),10,' ' );    /* 0-9                    */
 
    ALPHA_TBL= LETTER_TBL;                          /* A-Z $ _                */
    CALL INSERT( ALPHA_TBL,ASCBIN('0'),10,' ' );    /*     0-9                */
 
    CMNT_= VECTOR(NIL);
    CALL EXPAND_CMNT;
 
    PACK_= VECTOR(NIL);
    CALL EXPAND_PACK;
    PACKBUF= ' ';
 
    REF_= VECTOR(NIL);
    CALL EXPAND_REF;
    REF1$= PINCRW(REF$,1);
 
    SYMBOL_= VECTOR(NIL);
    CALL EXPAND_SYMBOL;
    RETURN;
 
END INIT_TABLES;
%EJECT;
GET_FID_AND_WIDTH: PROC  ALTRET;
 
    IF M$LO$->F$DCB.LINES# ~= 0 THEN
         PAGE_SIZE= M$LO$->F$DCB.LINES#;
    ELSE PAGE_SIZE= 39;
    IF WIDTH = 0 THEN
         IF M$LO$->F$DCB.WIDTH# < 80 THEN
              IF M$LO$->F$DCB.ASN# = %DEVICE# THEN
                   WIDTH= 80;
              ELSE WIDTH= 108;
         ELSE IF M$LO$->F$DCB.WIDTH# = 132  AND
                 M$LO$->F$DCB.LINES# = 39  THEN
                   WIDTH= 108;
              ELSE WIDTH= M$LO$->F$DCB.WIDTH#;
    ELSE IF WIDTH < 80 THEN
              WIDTH= 80;
    IF WIDTH > 132 THEN
         WIDTH= 132;
    LO_NE_ME= %NO#;
    CALL M$CORRES(LOVSME)  ALTRET( LO_IS_ME );
    LO_NE_ME= %YES#;
 
LO_IS_ME:
    CALL M$UNFID( UNFID_SI )  ALTRET( CALL_ERRMSG );
 
    CALL M$TIME( GET_TIME )   ALTRET( CALL_ERRMSG );
    TYME.DAYU(1)=  TYME.DAYU(1) + (ASCBIN('a')-ASCBIN('A')); /* DAY -> Day    */
    TYME.DAYU(2)=  TYME.DAYU(2) + (ASCBIN('a')-ASCBIN('A'));
    TYME.DATEU(1)= TYME.DATEU(1) + (ASCBIN('a')-ASCBIN('A'));/* MON -> Mon    */
    TYME.DATEU(2)= TYME.DATEU(2) + (ASCBIN('a')-ASCBIN('A'));
 
    RETURN;
 
CALL_ERRMSG:
    ALTRETURN;
 
END GET_FID_AND_WIDTH;
%EJECT;
PUT_EOF_SUMMARY: PROC;
 
    IF SI_CNT < 1 THEN
         GOTO RET;
    TMP1= F_FDS.DCB#;
    CALL L$WRITE( ' ',LENGTHC(' '),TMP1 );
    VEC1_= VECTOR(SUBSTR(SI_FID,0,SI_FID_LEN));
    VEC2_= VECTOR(M$SI$->F$DCB.NRECS#);
    VEC3_= VECTOR(TOT.COMMENTS);
    TMP2= ((1000*TOT.COMMENTS)/M$SI$->F$DCB.NRECS#+5)/10;
    IF NOT OX.OPT(BC#)  AND
       PROC_NUM = 1  THEN DO;
         VEC4_= VECTOR(SUBSTR(MODULE_NAME,0,MODULE_LEN));
         IF TOT.COMMENTS > 0 THEN
              CALL X$WRITE( F_FDS,FMT4_,VEC1_,VEC4_,VEC2_,VEC3_,TMP2_ );
         ELSE CALL X$WRITE( F_FDS,FMT3_,VEC1_,VEC4_,VEC2_ );
         END;
    ELSE IF TOT.COMMENTS > 0 THEN
              CALL X$WRITE( F_FDS,FMT2_,VEC1_,VEC2_,VEC3_,TMP2_ );
         ELSE CALL X$WRITE( F_FDS,FMT1_,VEC1_,VEC2_ );
    CALL PUT_SUMMARY( TOT.NUM_LABELS, 'Labels  ',TOT.LABEL_REFS );
    CALL PUT_SUMMARY( TOT.NUM_SYMBOLS,'Symbols ',TOT.SYMBOL_REFS );
    CALL PUT_SUMMARY( TOT.NUM_UNITS,  'Units   ',TOT.UNIT_REFS );
    NUM_ITEMS= TOT.NUM_LABELS + TOT.NUM_SYMBOLS + TOT.NUM_UNITS;
    IF NUM_ITEMS ~= TOT.NUM_LABELS AND
       NUM_ITEMS ~= TOT.NUM_SYMBOLS AND
       NUM_ITEMS ~= TOT.NUM_UNITS   THEN DO;
         CALL L$WRITE( '------',LENGTHC('------'),TMP1 );
         NUM_REFS= TOT.LABEL_REFS + TOT.SYMBOL_REFS + TOT.UNIT_REFS;
         CALL PUT_SUMMARY( NUM_ITEMS,'items   ',NUM_REFS );
         END;
    IF TOT.X_CNT + TOT.Y_CNT + TOT.Z_CNT + PROC_NUM-1 > 0 THEN DO;
         CALL L$WRITE( ' ',LENGTHC(' '),TMP1 );
         IF PROC_NUM > 1 THEN
              CALL X$WRITE( F_FDS,FMT9_,VECTOR(PROC_NUM) );
         IF TOT.X_CNT > 0 THEN
              IF COMMENT(ASCBIN('X')) = 0 THEN
                   CALL X$WRITE( F_FDS,FMT10_,VECTOR(TOT.X_CNT) );
              ELSE CALL X$WRITE( F_FDS,FMT11_,VECTOR(TOT.X_CNT) );
         IF TOT.Y_CNT > 0 THEN
              IF COMMENT(ASCBIN('Y')) = 0 THEN
                   CALL X$WRITE( F_FDS,FMT12_,VECTOR(TOT.Y_CNT) );
              ELSE CALL X$WRITE( F_FDS,FMT13_,VECTOR(TOT.Y_CNT) );
         IF TOT.Z_CNT > 0 THEN
              IF COMMENT(ASCBIN('Z')) = 0 THEN
                   CALL X$WRITE( F_FDS,FMT14_,VECTOR(TOT.Z_CNT) );
              ELSE CALL X$WRITE( F_FDS,FMT15_,VECTOR(TOT.Z_CNT) );
         END;
RET:
    RETURN;
 
END PUT_EOF_SUMMARY;
%EJECT;
PUT_REPORT_SUMMARY: PROC;
 
    TMP1= F_FDS.DCB#;
    CALL L$WRITE( ' ',LENGTHC(' '),TMP1 );
    VEC1_= VECTOR(SUBSTR(MODULE_NAME,0,MODULE_LEN));
    VEC2_= VECTOR(LINECNT);
    VEC3_= VECTOR(CNT.COMMENTS);
    TMP2= ((1000*CNT.COMMENTS)/LINECNT+5)/10;
    IF CNT.COMMENTS > 0 THEN
         CALL X$WRITE( F_FDS,FMT6_,VEC1_,VEC2_,VEC3_,TMP2_ );
    ELSE CALL X$WRITE( F_FDS,FMT5_,VEC1_,VEC2_ );
    CALL PUT_SUMMARY( TOKEN_CNT(0),'Labels  ',TOKEN_REFS(0) );
    CALL PUT_SUMMARY( TOKEN_CNT(1),'Symbols ',TOKEN_REFS(1) );
    CALL PUT_SUMMARY( TOKEN_CNT(2),'Units   ',TOKEN_REFS(2) );
    IF NOT JUST_ONE_TYPE THEN DO;
         CALL L$WRITE( ' -----',LENGTHC(' -----'),TMP1 );
         CALL PUT_SUMMARY( NUM_ITEMS,'items   ',NUM_REFS );
         END;
    IF CNT.X + CNT.Y + CNT.Z > 0 THEN DO;
         CALL L$WRITE( ' ',LENGTHC(' '),TMP1 );
         IF CNT.X > 0 THEN
              CALL X$WRITE( F_FDS,FMT10_,VECTOR(CNT.X) );
         IF CNT.Y > 0 THEN
              CALL X$WRITE( F_FDS,FMT12_,VECTOR(CNT.Y) );
         IF CNT.Z > 0 THEN
              CALL X$WRITE( F_FDS,FMT14_,VECTOR(CNT.Z) );
         END;
    RETURN;
 
END PUT_REPORT_SUMMARY;
%EJECT;
ADD_MODULE_NUM: PROC;
 
    CALL INDEX( J,'(',MODULE_NAME );
    IF J < LENGTHC(MODULE_NAME)  OR
       MODULE_NAME = 'everything' THEN
         GOTO XIT;
    CALL SEARCHR( MODULE_LEN,TABLEVAL,SKIP_BLANKS,MODULE_NAME );
    CALL BINCHAR( INT7,PROC_NUM );
    CALL SEARCH( J,TABLEVAL,SKIP_ZEROS,INT7 );
    CALL INSERT( MODULE_NAME,MODULE_LEN+1,,' (#',
                                           SUBSTR(INT7,J),
                                           ')' );
    MODULE_LEN= MODULE_LEN + LENGTHC(' (#) ') + LENGTHC(INT7) - J;
XIT:
    RETURN;
 
END ADD_MODULE_NUM;
%EJECT;
COPY_SI_TO_STARFILE: PROC  ALTRET;
 
    CALL M$OPEN( OPEN_DUP )  ALTRET( CALL_ERRMSG );
 
COPY_IT:
    DO WHILE('1'B);
       SI_BUF= ' ';
       CALL M$READ( READ_SI )     ALTRET( EOF_HIT );
       IF M$SI$->F$DCB.ARS# > 0 THEN
          WRITE_DUP.BUF_.BOUND= M$SI$->F$DCB.ARS# - 1;
       ELSE
          WRITE_DUP.BUF_.BOUND= 0;
       CALL M$WRITE( WRITE_DUP )  ALTRET( CALL_ERRMSG );
NEXT:
       END COPY_IT;
 
EOF_HIT:
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$LD THEN  /* Lost Data?         */
       GOTO NEXT;
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOF THEN DO;  /* Was EOF hit   */
       CLOSEF.V.DCB#= DCBNUM(M$SI);
       CALL M$CLOSE( CLOSEF );
       CLOSEF.V.DCB#= DCBNUM(M$DUP);
       CALL M$CLOSE( CLOSEF );
       OPEN_SI.NAME_= VECTOR(DUP_NAME);
       OPEN_SI.V.ASN#= %FILE#;
       CALL M$OPEN( OPEN_SI )  ALTRET( CALL_ERRMSG );
       RETURN;
       END;
 
CALL_ERRMSG:
    ALTRETURN;
 
END COPY_SI_TO_STARFILE;
 
END OX;
