/*M* SDUMP - PROGRAM TO OUTPUT DEBUG SCHEMA OF OBJECT UNIT OR
             RUN UNIT IN A READABLE FORM.  */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMR,PLM=5,IND=5,CSU=3,EXM=0,ECU=3,MOC,DCI=5,CRT=5,CCC */
SDUMP: PROC MAIN;
/* Include files */
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE XU_PERR_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE B$OBJECT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE SDUMP_C1;
%INCLUDE XUR_ENTRY;
%B$DNAME;
%B$LBNTRY0;
%B$LBNTRY1;
%B$LOGBLK;
%B$INTNTRY;
%B$EXST;
%B$COMPILER_ID;
%B$VREBL;
%B$VREBLC;
%VREBL_DATATYPES;
%B$STXTYPESUBS;
%F$DCB;
%B$TCB;
%B$ALT;
%B$EXCFR;
%B$HEAD;
%B$EDEF;
%SUB_LINKFLAGS;
%B$TREE_TABLE;
%B$OUHEAD(STCLASS=BASED);
DCL SDUMP_BREAK ENTRY ASYNC;
DCL HEAD$ PTR;
DCL B$TCB$ PTR SYMREF;
DCL B$JIT$ PTR SYMREF;
DCL M$SI$ PTR;
DCL M$ME$ PTR;
DCL ROSEG$ PTR;
DCL R$ PTR;
DCL TREE$ PTR;
DCL T$ PTR;
DCL LBLK$ PTR;
DCL LB$ PTR;
DCL NAME$ PTR;
DCL N$ PTR;
DCL IENT$ PTR;
DCL IE$ PTR;
DCL VAR$ PTR;
DCL V$ PTR;
DCL EXST$ PTR;
DCL ES$ PTR;
DCL DEFN$ PTR;
DCL ENT$ PTR;
DCL E$ PTR;
DCL PTR$ PTR;
DCL 1 POINTER REDEF PTR$ ALIGNED,
      2 LH UBIN HALF UNAL,
      2 RH UBIN HALF UNAL;
DCL M$SI DCB;
DCL M$ME DCB;
DCL M$LO DCB;
DCL M$DO DCB;
%EJECT;
/* Variables for parsing commands. */
DCL SDUMP_ROOT BIT(1) SYMREF;
%PARSE$OUT(STCLASS=BASED);
%PARSE$SYM(STCLASS=BASED);
DCL OUT$ PTR;
DCL XERRCODE BIT(36) STATIC;
DCL CMD$ REDEF XERRCODE PTR;
DCL PROMPT_ BIT(72) CONSTANT DALIGNED INIT(VECTOR(PROMPT_BUFFER));
%EJECT;
/* Variables to get information from fit. */
DCL FPARAM_BUF (0:1023) UBIN WORD STATIC INIT (0*1024);
DCL FP$ PTR STATIC INIT ( ADDR( FPARAM_BUF ) );
DCL XSF$LOCCODE ENTRY (2) ALTRET;
%INCLUDE FM$FIT;
%CODE04;
DCL CODE04$ PTR;
%CODE03;
DCL CODE03$ PTR;
DCL CODE UBIN WORD;
DCL CODE04_TIME UBIN WORD;
/* Sizes of debug schema records and pages. */
DCL LB_SIZE SBIN WORD ALIGNED;
DCL NAME_SIZE SBIN WORD ALIGNED;
DCL IE_SIZE SBIN WORD ALIGNED;
DCL ES_SIZE SBIN WORD ALIGNED;
DCL VAR_SIZE SBIN WORD ALIGNED;
DCL NAMEP_SIZE SBIN WORD ALIGNED;
DCL IEP_SIZE SBIN WORD ALIGNED;
DCL ESP_SIZE SBIN WORD ALIGNED;
DCL VARP_SIZE SBIN WORD ALIGNED;
DCL DEFNAME_SIZE SBIN WORD ALIGNED;
DCL ENTDEF_SIZE SBIN WORD ALIGNED;
DCL ROSEG_SIZE SBIN WORD ALIGNED;
DCL ROSEG_BUFFER_SIZE SBIN WORD ALIGNED;
DCL TREE_DISP UBIN WORD ALIGNED;
DCL MAX_PRECSIZE SBIN WORD ALIGNED;
DCL SAVE_ENTDEFSIZE SBIN WORD ALIGNED;
/* Flags set by command issued so know what to print. */
DCL BREAK_FLAG BIT(1) STATIC SYMDEF INIT ('0'B);
DCL LO_DO_SAME BIT(1) STATIC CALIGNED INIT('0'B);
DCL NO_TOP BIT(1) STATIC ALIGNED;
DCL BAD_FILE BIT(1) STATIC CALIGNED INIT('0'B);
DCL FROMJIT BIT(1) STATIC CALIGNED;
DCL FILE_FROM_JIT BIT(1) STATIC CALIGNED;
DCL OPENFLAG BIT(1) STATIC CALIGNED INIT('0'B);
DCL LOGBLK BIT(1) STATIC CALIGNED INIT('0'B);
DCL EXECSTMT BIT(1) STATIC CALIGNED INIT('0'B);
DCL INTENT BIT(1) STATIC CALIGNED INIT('0'B);
DCL VARS BIT(1) STATIC CALIGNED INIT('0'B);
DCL ALLOU BIT(1) STATIC CALIGNED INIT('1'B);
DCL ALL_ENTDEFS BIT(1) STATIC CALIGNED INIT('0'B);
DCL LIST BIT(1) STATIC CALIGNED INIT('0'B);
DCL ENDFLAG BIT(1) STATIC CALIGNED INIT('0'B);
DCL NO_SCHEMA BIT(1) STATIC CALIGNED INIT('0'B);
DCL CONTINUE BIT(1) STATIC CALIGNED INIT('0'B);
DCL FOUND_NODE BIT(1) STATIC CALIGNED INIT('0'B);
DCL FEP_RUNUNIT BIT(1) STATIC CALIGNED INIT('0'B);
DCL LEMUR BIT(1) STATIC CALIGNED INIT('0'B);
DCL OVRL_BIT BIT(1) STATIC ALIGNED;
DCL LIB_BIT BIT(1) STATIC ALIGNED;
DCL GOTDEFS BIT(1) STATIC ALIGNED;
DCL GOT_TREE_TABLE BIT(1) STATIC ALIGNED;
%EJECT;
/* Fpt's */
DCL 1 DATE_TIME STATIC,
      2 DATEX_ CHAR(8),
      2 TIMEX_ CHAR(11),
      2 DAYX_ CHAR(3);
DCL 1 CDATE_TIME STATIC,
      2 DATEX_ CHAR(8),
      2 TIMEX_ CHAR(11),
      2 DAYX_ CHAR(3);
DCL TSTAMP_BUF UBIN WORD STATIC;
DCL OUTBUF CHAR(108) STATIC;
DCL FILE_BUF CHAR(30) STATIC CALIGNED;
DCL HEAD_BUF (0:47) UBIN WORD ALIGNED STATIC;
DCL REC_BUF (0:30) UBIN WORD STATIC ALIGNED;
DCL ERR_BUF CHAR(360) STATIC CALIGNED;
DCL 1 KEY_BUF STATIC ALIGNED,
      2 KEY_LEN UBIN BYTE UNAL INIT(1),
      2 KEY CHAR(255) UNAL INIT('"');
DCL 1 REC_KEY STATIC ALIGNED,
      2 KEY_LEN UBIN BYTE CALIGNED INIT(7),
      2 NOTH BIT(9) INIT('777'O),
      2 UTS UBIN UNAL,                  /* For ou */
      2 NAMEPTR REDEF UTS UBIN UNAL,    /* For ru */
      2 TYPE UBIN BYTE CALIGNED,
      2 PAGE UBIN BYTE CALIGNED INIT (0);
DCL 1 HEADKEY CONSTANT ALIGNED,
      2 KEYSIZ UBIN BYTE INIT (4) UNAL,
      2 TEXT CHAR(4) INIT ('HEAD');
DCL 1 RECORD_KEY STATIC ALIGNED,
      2 KEYSIZ UBIN BYTE INIT (5) UNAL,
      2 REC_TYPE UBIN BYTE UNAL,
      2 NODE# UBIN HALF UNAL,
      2 OFFSET UBIN HALF UNAL;
DCL 1 TEXT BASED ALIGNED,
      2 COUNT UBIN BYTE UNAL,
      2 STRING CHAR(TEXT.COUNT) UNAL;
DCL JUNK CHAR(20) STATIC CALIGNED;
DCL FID_BUFFER CHAR(72) STATIC CALIGNED;
DCL PROMPT_BUFFER CHAR(7) CONSTANT CALIGNED INIT('Option:');
%VLP_ACCT;
%VLP_NAME;
%VLP_PASS;
%VLR_FID(FPTN=FID_RESULTS);
%VLP_VECTOR(FPTN=GET_SEG);
%VLP_VECTOR(FPTN=FREE_SEG);
%VLP_ERRCODE(FPTN=ERR_CODE,
             STCLASS=STATIC);
%VLP_HDR(LEN=120);
%FPT_FID(FPTN=FID_FPT,
         ACCT=VLP_ACCT,
         ASN=OPEN_FPT.V.ASN#,
         NAME=VLP_NAME,
         PASS=VLP_PASS,
         RES=OPEN_FPT.V.RES#,
         RESULTS=FID_RESULTS,
         SN=JUNK,
         TEXTFID=FID_BUFFER,
         WSN=JUNK,
         STCLASS=STATIC);
%FPT_UNFID(FPTN=UNFID_FPT,
           DCB=M$SI,
           TEXTFID=FID_BUFFER,
           STCLASS=STATIC);
%FPT_OPEN(FPTN=OPENFPT,
          DCB=M$SI,
          ACS=DIRECT,
          ASN=FILE,
          FUN=IN,
          FPARAM=FPARAM_BUF,
          STCLASS=STATIC);
%FPT_OPEN(FPTN=OPEN_FPT,
          DCB=M$SI,
          ACS=DIRECT,
          ASN=FILE,
          ACCT=VLP_ACCT,
          NAME=VLP_NAME,
          PASS=VLP_PASS,
          FUN=IN,
          FPARAM=FPARAM_BUF,
          STCLASS=STATIC);
%FPT_OPEN(FPTN=OPENME_FPT,
          DCB=M$ME,
          FUN=IN,
          STCLASS=CONSTANT);
%FPT_TIME(FPTN=TIME_FPT,
          SOURCE=UTS,
          DEST=LOCAL,
          DATE=DATE_TIME.DATEX_,
          TIME=DATE_TIME.TIMEX_,
          DAY=DATE_TIME.DAYX_,
          TSTAMP=TSTAMP_BUF);
%FPT_TIME(FPTN=FPT_TIME,
          SOURCE=UTS,
          DEST=LOCAL,
          DATE=CDATE_TIME.DATEX_,
          TIME=CDATE_TIME.TIMEX_,
          DAY=CDATE_TIME.DAYX_,
          TSTAMP=TSTAMP_BUF);
%F_FDS(NAME=F_FDS,
       DCB=M$LO,
       TRUNC=YES,
       STCLASS=STATIC,
       BUF=OUTBUF);
%FPT_READ(FPTN=READ_FPT,
          BIN=YES,
          BUF=HEAD_BUF,
          CONT=NO,
          DCB=M$SI,
          KEY=KEY_BUF,
          KEYR=YES);
%FPT_CLOSE(FPTN=CLOSESI_FPT,
           DCB=M$SI,
           DISP=SAVE);
%FPT_CLOSE(FPTN=CLOSELO_FPT,
           DCB=M$LO,
           DISP=SAVE);
%FPT_CLOSE(FPTN=CLOSEME_FPT,
           DCB=M$ME,
           DISP=SAVE);
%FPT_WRITE(FPTN=WRITE_FPT,
           DCB=M$LO,
           BUF=MSG_BUF);
%FPT_WRITE(FPTN=WRITEDO_FPT,
           DCB=M$DO,
           BUF=MSG_BUF);
%FPT_GDS(FPTN=GDS_FPT,
         FREE=YES,
         RESULTS=GET_SEG);
%FPT_READ(FPTN=READREC_FPT,
          DCB=M$SI,
          KEY=REC_KEY,
          KEYR=NO,
          KEYS=YES);
%FPT_READ(FPTN=READRU_FPT,
          BUF=REC_BUF,
          DCB=M$SI,
          KEY=REC_KEY,
          KEYR=NO,
          KEYS=YES);
%FPT_FDS(FPTN=FDS_FPT,
         RESULTS=FREE_SEG);
%FPT_PRECORD(FPTN=PRECORD_FPT,
             DCB=M$SI,
             KEY=KEY_BUF,
             KEYR=YES,
             NEXTKEY=YES,
             KEYS=YES);
%FPT_ERRMSG(FPTN=ERRMSG_FPT,
            STCLASS=STATIC,
            OUTDCB1=M$LO,
            OUTDCB2=M$DO,
            BUF=ERR_BUF,
            SUBMESS=YES,
            CODE=ERR_CODE);
%FPT_INT(FPTN=INT_FPT,
         STCLASS=CONSTANT,
         UENTRY=SDUMP_BREAK);
%FPT_DEVICE(FPTN=DEVICE_FPT,
            DCB=M$LO,
            HDR=VLP_HDR,
            PAGE=NO);
%FPT_DEVICE(FPTN=DEVICE_ERASE_FPT,
            DCB=M$LO,
            HDR=ERASE,
            PAGE=NO);
%FPT_CORRES(FPTN=CORRES_FPT,
            DCB1=M$LO,
            DCB2=M$DO);
%EJECT;
/* Variable declarations */
DCL MSG_BUF CHAR(108) STATIC;
DCL OU_NAME_ CHAR(256) STATIC CALIGNED;
DCL NAME_ CHAR(256) STATIC;
DCL NODE_ CHAR(31) STATIC CALIGNED ;
DCL NAME_POINTER UBIN ALIGNED;
DCL RUNUNIT BIT(1) STATIC CALIGNED;
DCL HEX BIT(1) STATIC CALIGNED;
DCL CMDNUM SBIN STATIC ALIGNED;
DCL CMDNUM1 SBIN STATIC ALIGNED;
DCL CMDSIZE SBIN STATIC ALIGNED;
DCL I SBIN STATIC ALIGNED;
DCL II SBIN STATIC ALIGNED;
DCL NUMBER_NODES UBIN WORD ALIGNED;
DCL NODE_LEVEL UBIN WORD ALIGNED;
%EJECT;
/* Formatter variables */
%INCLUDE XUF_ENTRY;
DCL 1 IE_PGHDR_OCT STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(IE_PGHDR_OCT.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  LB ENTRY   OCT LOC   PRI   ALT'),
        3 * CHAR(0) INIT('   CHK   CST   # PARAM   NAME');
DCL 1 IE_PGHDR_HEX STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(IE_PGHDR_HEX.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  LB ENTRY   HEX LOC   PRI   ALT'),
        3 * CHAR(0) INIT('   CHK   CST   # PARAM   NAME');
DCL 1 ES_PGHDR_OCT STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(ES_PGHDR_OCT.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  ENTRY  OCT LOC   LINE #   LB #'),
        3 * CHAR(0) INIT('   LA  COS   TYPE            LABEL');
DCL 1 ES_PGHDR_HEX STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(ES_PGHDR_HEX.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  ENTRY  HEX LOC   LINE #   LB #'),
        3 * CHAR(0) INIT('   LA  COS   TYPE            LABEL');
DCL 1 VAR_PGHDR_OCT STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(VAR_PGHDR_OCT.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT(' ENT# OCT LOC C B ATYP DTYP R M S'),
        3 * CHAR(0) INIT('  SIZE ST ARTYP   IMPLIED PTR ESIZ'),
        3 * CHAR(0) INIT(' SCL  DIMS LEV NAME');
DCL 1 VAR_PGHDR_HEX STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(VAR_PGHDR_HEX.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT(' ENT# HEX LOC C B ATYP DTYP R M S'),
        3 * CHAR(0) INIT('  SIZE ST ARTYP   IMPLIED PTR ESIZ'),
        3 * CHAR(0) INIT(' SCL  DIMS LEV NAME');
DCL 1 PENT_PGHDR_OCT STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(PENT_PGHDR_OCT.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  SRC DEF MULT USED FTAG OCT LOC'),
        3 * CHAR(0) INIT(' PRI ALT CHK CST   NP NAME');
DCL 1 PENT_PGHDR_HEX STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(PENT_PGHDR_HEX.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  SRC DEF MULT USED FTAG HEX LOC'),
        3 * CHAR(0) INIT(' PRI ALT CHK CST   NP NAME');
DCL 1 NODES_PGHDR STATIC ALIGNED,
      2 SIZE UBIN BYTE UNAL INIT(SIZEC(NODES_PGHDR.TEXT)),
      2 TEXT,
        3 * CHAR(0) INIT('  NODE# PARENT# DGHTER# OLINK  '),
        3 * CHAR(0) INIT('DATAL  DATAH DATASZ  PROCL  PROCH'),
        3 * CHAR(0) INIT(' PROCSZ NAME');
DCL TOP_OF_PAGE_ CHAR(0) CONSTANT INIT
     ('%!');
DCL FILE_OUT_MSG_ CHAR(0) CONSTANT INIT
     ('  %>A  Last Modified=%A %A %A  Created=%A %A %A');
DCL OU_SEV_OUT1_ CHAR(0) CONSTANT INIT
     ('  Object Unit=%>A  Compiler=%18NA  Severity Level=%D');
DCL OU_SEV_OUT2_ CHAR(0) CONSTANT INIT
     ('  Object Unit=%>A  Severity Level=%D');
DCL OU_OUT_ CHAR(0) CONSTANT INIT
     (' Object Unit=%>A');
DCL RU_SEV_OUT_ CHAR(0) CONSTANT INIT
     ('  Severity Level=%D');
DCL ENTDEF_HEAD_OUT_ CHAR(0) CONSTANT INIT
     ('%10XENTDEFS');
DCL ENTDEF_HEADING_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ENTDEF_HEADING_OCT));
DCL ENTDEF_HEADING_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ENTDEF_HEADING_HEX));
DCL ENTDEF_HEADING_OCT CHAR(0) CONSTANT INIT
      ('  SRC DEF MULT USED FTAG OCT LOC PRI ALT CHK CST   NP NAME');
DCL ENTDEF_HEADING_HEX CHAR(0) CONSTANT INIT
      ('  SRC DEF MULT USED FTAG HEX LOC PRI ALT CHK CST   NP NAME');
DCL ENTDEF_OUT_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ENTDEF_OUT_OCT));
DCL ENTDEF_OUT_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ENTDEF_OUT_HEX));
DCL ENTDEF_OUT_OCT CHAR(0) CONSTANT INIT
     ('%4X%D%3X%D%4X%D%4X%D%4X%D .%6ZO%3X%D%3X%D%3X%D  %2D %4D %>A');
DCL ENTDEF_OUT_HEX CHAR(0) CONSTANT INIT
     ('%4X%D%3X%D%4X%D%4X%D%4X%D  .%5ZH%3X%D%3X%D%3X%D  %2D %4D %>A');
DCL NODE_HEAD_OUT_ CHAR(0) CONSTANT INIT
     ('%10XNODES');
DCL NODE_HEADING1_ CHAR(0) CONSTANT INIT
     ('%15XLINKS%17XDATA%15XPROCEDURE');
DCL NODE_HEADING2_ CHAR(0) CONSTANT INIT
     ('  NODE# PARENT DGHTER OVLAY%5XLOW%4XHIGH%4XSIZE%5XLOW%4XHIGH%4XSIZE NAME');
DCL NODE_OUT_ CHAR(0) CONSTANT INIT
     ('  %5D%2X%+5D%2X%+5D %+5D .%6ZO .%6ZO .%6ZO .%6ZO .%6ZO .%6ZO %>A');
DCL LB_HEAD_OUT_ CHAR(0) CONSTANT INIT ('%10XLOGICAL BLOCKS');
DCL LB_HEADING1_ CHAR (0) CONSTANT INIT
     ('  UTS%25XCOMPILER    VERSION%4XNOAUTO ADDR');
DCL LB_HEADING2_ CHAR(0) CONSTANT INIT
     ('  NAME SZ   PG SIZE   STMNT SZ   PG SIZE   VAR SZ   PG SIZE   IENT SZ   PG SIZE');
DCL LB_HEADING3_ CHAR(0) CONSTANT INIT
     ('%2XENTRY%7XLINE #S   LEVEL   STMT ENTS   VARS ENTS   NAME');
DCL LB_OUT1_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(LB_OUT1_OCT));
DCL LB_OUT1_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(LB_OUT1_HEX));
DCL LB_OUT1_OCT CHAR(0) CONSTANT INIT
     ('%2X%A %A %A.   %A   %D%11X.%6ZO');
DCL LB_OUT1_HEX CHAR(0) CONSTANT INIT
     ('%2X%A %A %A.   %A   %D%11X .%5ZH');
DCL LB_OUT_OCT1 CHAR(0) CONSTANT INIT
     ('%2X%A %A %A.   %A   %A%2ZD%11X.%6ZO');
DCL LB_OUT_HEX1 CHAR(0) CONSTANT INIT
     ('%2X%A %A %A.   %A   %A%2ZD%11X .%5ZH');
DCL LB_OUT_OCT2 CHAR(0) CONSTANT INIT
     ('%2X%A %A %A.   %A   %A%3ZD%11X.%6ZO');
DCL LB_OUT_HEX2 CHAR(0) CONSTANT INIT
     ('%2X%A %A %A.   %A   %A%3ZD%11X .%5ZH');
DCL LB_OUT_T1_ BIT(72) STATIC DALIGNED;
DCL LB_OUT_T2_ BIT(72) STATIC DALIGNED;
DCL TEMPMSG_ BIT(72) STATIC DALIGNED;
DCL LB_OUT2_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(LB_OUT2_OCT));
DCL LB_OUT2_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(LB_OUT2_HEX));
DCL LB_OUT2_OCT CHAR(0) CONSTANT INIT
     ('%3X%6D   .%6ZO%5X%6D   .%6ZO   %6D   .%6ZO%4X%6D   .%6ZO');
DCL LB_OUT2_HEX CHAR(0) CONSTANT INIT
     ('%3X%6D     .%4ZH%5X%6D     .%4ZH   %6D     .%4ZH%4X%6D     .%4ZH');
DCL LB_OUT3_ CHAR(0) CONSTANT INIT
     ('%3X%4D   %5D-%5LD%7X%1D   %4D-%4LD   %4D-%4LD   %>A');
DCL IE_HEAD_OUT_ CHAR(0) CONSTANT INIT
     ('%10XINTERNAL ENTRIES');
DCL IE_HEADING_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(IE_HEADING_OCT));
DCL IE_HEADING_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(IE_HEADING_HEX));
DCL IE_HEADING_OCT CHAR(0) CONSTANT INIT
     ('%2XLB ENTRY   OCT LOC   PRI   ALT   CHK   CST   # PARAM   NAME');
DCL IE_HEADING_HEX CHAR(0) CONSTANT INIT
     ('%2XLB ENTRY   HEX LOC   PRI   ALT   CHK   CST   # PARAM   NAME');
DCL IE_OUT_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(IE_OUT_OCT));
DCL IE_OUT_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(IE_OUT_HEX));
DCL IE_OUT_OCT CHAR(0) CONSTANT INIT
     ('%7X%3D   .%6ZO%5X%D%5X%D%5X%D%4X%2D%7X%3D   %>A');
DCL IE_OUT_HEX CHAR(0) CONSTANT INIT
     ('%7X%3D     .%4ZH%5X%D%5X%D%5X%D%4X%2D%7X%3D   %>A');
DCL ES_HEAD_OUT_ CHAR(0) CONSTANT INIT
     ('%10XEXECUTABLE STATEMENTS');
DCL ES_HEADING_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ES_HEADING_OCT));
DCL ES_HEADING_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ES_HEADING_HEX));
DCL ES_HEADING_OCT CHAR(0) CONSTANT INIT
     ('  ENTRY  OCT LOC   LINE #   LB #   LA  COS   TYPE             LABEL');
DCL ES_HEADING_HEX CHAR(0) CONSTANT INIT
     ('  ENTRY  HEX LOC   LINE #   LB #   LA  COS   TYPE             LABEL');
DCL ES_OUT_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ES_OUT_OCT));
DCL ES_OUT_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(ES_OUT_HEX));
DCL ES_OUT_OCT CHAR(0) CONSTANT INIT
     ('%2X%5D%2X.%6ZO   %6D%4X%3D%2X%+3D%4X%1D   %16A %>A');
DCL ES_OUT_HEX CHAR(0) CONSTANT INIT
     ('%2X%5D%2X .%5ZH   %6D%4X%3D%2X%+3D%4X%1D   %16A %>A');
DCL VAR_HEAD_OUT_ CHAR(0) CONSTANT INIT
     ('%10XVARIABLES');
DCL VAR_HEADING_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(VAR_HEADING_OCT));
DCL VAR_HEADING_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(VAR_HEADING_HEX));
DCL VAR_HEADING_OCT CHAR(0) CONSTANT INIT
     (' ENT# OCT LOC C B ATYP DTYP R M S  SIZE ST ARY  IMPTR ESIZ SCL DIM LV NAME');
DCL VAR_HEADING_HEX CHAR(0) CONSTANT INIT
     (' ENT# HEXLOC C B ATYP DTYP R M S BITSZ ST ARY IMPTR ESIZ SCL DIM LV NAME');
DCL ARR_HEADING_ BIT(72) STATIC DALIGNED
      INIT(VECTOR(ARR_HEADING));
DCL ARR_HEADING CHAR(0) CONSTANT INIT
   ('%6XOFFSET DATATYP ELEMENTS MULTP1 MULTP2 MULTP3 MULTP4 MULTP5 MULTP6');
DCL ARR_OUT_ BIT(72) STATIC DALIGNED
   INIT(VECTOR(ARR_OUT));
DCL ARR_OUT CHAR(0) CONSTANT INIT
   ('%12+D %7A %8D %6D %6D %6D %6D %6D %6D');
DCL VAR_OUT_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(VAR_OUT_OCT));
DCL VAR_OUT_HEX_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(VAR_OUT_HEX));
DCL VAR_OUT_OCT CHAR(0) CONSTANT INIT
     (' %4D .%6ZO-%1D-%1D %4A %4A %1D %1D %1D %5D %1D %5A %+*5D %4D%+4D %3D %1.N:=[1 %?%2.#KD%] %>A');
DCL VAR_OUT_HEX CHAR(0) CONSTANT INIT
     (' %4D .%5ZH-%1D-%1D %4A %4A %1D %1D %1D %5D %1D %5A %+*4D %4D%+4D %3D %1.N:=[1 %?%2.#KD%] %>A');
DCL VAR_OUT1_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(VAR_OUT1_OCT));
DCL VAR_OUT1_OCT CHAR(0) CONSTANT INIT
     (' %4D .%6ZO-%1D-%1D %4A %4A %1D %1D %1D %5D %1D %5A  $LS%2LD%4D%+4D %3D %1.N:=[1 %?%2.#KD%] %>A');
DCL VAR_OUT2_OCT_ BIT(72) STATIC DALIGNED
     INIT(VECTOR(VAR_OUT2_OCT));
DCL VAR_OUT2_OCT CHAR(0) CONSTANT INIT
     (' %4D .%6ZO-%1D-%1D %4A %4A %1D %1D %1D %5D %1D %5A.%Z6O%4D%+4D %3D %1.N:=[1 %?%2.#KD%] %>A');
DCL VAR_OUT2_HEX_ VECTOR CONSTANT DALIGNED
     INIT(VECTOR(VAR_OUT2_HEX));
DCL VAR_OUT2_HEX CHAR(0) CONSTANT INIT
     (' %4D .%5ZH-%1D-%1D %4A %4A %1D %1D %1D %5D %1D %5A.%Z5H%4D%+4D %3D %1.N:=[1 %?%2.#KD%] %>A');
DCL BLANK_LINE_ CHAR(0) CONSTANT INIT
     ('%108X');
DCL ASTERISK_LINE_ CHAR(0) CONSTANT INIT
     ('==================================================');
DCL BAD_NAME_POINTER_ CHAR(0) CONSTANT INIT
     ('*****Bad Name Pointer in Next Record. - NPOINTER=%D');
DCL BAD_NAME_ENTRY_ CHAR(0) CONSTANT INIT
     ('*****Bad Name Pointer - Points to textc > 31 Characters. - NPOINTER=%D');
/* Tables for outputting text to make output more readable. */
DCL COMP_ID(0:13) CHAR(9) CONSTANT INIT
     ('ASSEMBLER','PL-6','FORTRAN','COBOL','PL/I','RPG','PASCAL','MOMUS','FPL','PARTRGE','IDL','ELSIE','CALF','C');
DCL ST_TYPE_ CHAR(16) STATIC;
DCL ADR_TYPE_(0:15) CHAR(4) CONSTANT INIT
     ('0','STAT','AUTO','BASE','DCB','PARM','CONS','SPAR',
      'ADEF','9','10','11','12','13','14','15');
DCL DATA_TYPE_(0:63) CHAR(4) CONSTANT INIT
     ('0','Sbin','DFix','SFlt','DFlt','SCFx','DCFx','Cplx','DCpx','PDLA',
      'PDFl','PDCA','PDCF','Ptr','Ofst','Lbl','Ent','Strc','Area','Bit','VBit',
      'Char','VChr','File','Ubin','PDTA','AChr','ABit','EPtr','Cmp1',
      'Cmp2','PDTE','Idx1','Idx2','Evry','Lgcl','FAny','FLbl','FUCB','ICns',
      'PDNS','UDNS','UDLS','UDTS','UDLO','UDTO','AStc','Vect','Rmbr',
      'Dscr','UDFL','PDLE','Enum','Set','Date','UTS','Txth','Time','58','59',
      'Null','VAry','RAry','63');
DCL ARRAY_TYPE_(0:5) CHAR(5) CONSTANT INIT
     ('NONE','1DM0','1DM1','OTHER','VIRT','ADIM');
%EQU HIGH_ST_TYPE = 104;
DCL ST_TEXT(0:%HIGH_ST_TYPE) CHAR(16) CONSTANT INIT
     (%T@NULL, %T@ASSIGNMENT, %T@CALL, %T@MONITOR_CALL, %T@ASL_CALL, %T@IF,
      %T@ELSE, %T@CASE, %T@GOTO, %T@RETURN, %T@ALTRETURN, %T@REMEMBER,
      %T@UNWIND, %T@REPORT_WRITER, %T@ALTER, %T@EVALUATE, %T@INTRINSIC_CALL,
      %T@SPOIL, %T@GOTO_SUBSCRIPTED, %T@ASSIGNED_GOTO, %T@IF_LOGICAL,
      %T@IF_ARITHMETIC, %T@PAUSE, %T@PERFORM, %T@STOP, %T@I_O, %T@ELSE_IF,
      %T@ASSIGNED, %T@DO_SELECT, %T@DO_SELECT_END, %T@SELECT, %T@DO_UNINHIBIT,
      %T@INSPECT, %T@DO_UNTIL, %T@DO_INDEX, %T@DO_WHILE, %T@DO_CASE, %T@DO,
      %T@DO_INHIBIT, %T@SET, %T@EXIT, %T@DO_UNINHIBIT_END, %T@PURGE,
      %T@DO_UNTIL_END, %T@DO_INDEX_END, %T@DO_WHILE_END, %T@DO_CASE_END,
      %T@DO_END, %T@DO_INHIBIT_END, %T@RELEASE, %T@SEND, %T@DATA_BASE,
      %T@CANCEL, %T@INITIALIZE, %T@MERGE, %T@RECEIVE, %T@SEARCH,
      %T@SORT, %T@STRING, %T@UNSTRING, %T@USE,
      %T@LOAD, 'UNKNOWN'*39, %T@PROC, %T@PROC_END, %T@ENTRY, %T@MISC);
%EJECT;
SDUMP_OBJECT: PROC;
/* SDUMP_OBJECT - procedure to process object unit files. */
     IF ALLOU
     THEN CALL ALL_OBJECT;
     ELSE DO;
          CALL SET_UP_OU;
          CALL M$READ (READ_FPT) WHENRETURN DO;
               CALL PROCESS_OBJECT;
             END; WHENALTRETURN DO;
               CALL ERROR;
             END;
        END;
END SDUMP_OBJECT;
%EJECT;
LIST_OU: PROC;
/* LIST_OU - procedure to list object units in file. */
DCL SEVLEV_TEMP_ UBIN ALIGNED;
     DO WHILE (SUBSTR(KEY_BUF.KEY, 0, 1) = '"');
                         /* Write out this object unit name and severity. */
          SUBSTR(KEY_BUF.KEY,KEY_BUF.KEY_LEN) = ' ';
          HEAD$ = ADDR(HEAD_BUF);
          SEVLEV_TEMP_ = HEAD$ -> B$OUHEAD.SEVLEV;
          CALL X$WRITE (F_FDS, VECTOR(OU_SEV_OUT2_),
            VECTOR(SUBSTR(KEY_BUF.KEY,1)),
            VECTOR(SEVLEV_TEMP_) );
                    /* Position to object unit head record just processed. */
          CALL M$PRECORD (PRECORD_FPT) ALTRET (BAD_PRECORD);
                                        /* Read next head record. */
          CALL M$READ (READ_FPT) ALTRET (BAD_READ);
OKAY:     ;
        END;
     DO WHILE ('0'B);
BAD_PRECORD: ;
          CALL ERROR;
          GOTO DONE;
BAD_READ: ;
          IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$LD
          THEN GOTO OKAY;
          CALL ERROR;
        END;
DONE: ;
END LIST_OU;
%EJECT;
ALL_OBJECT: PROC;
/* Procedure to dump schema records for all object units. */
     DO WHILE ((SUBSTR(KEY_BUF.KEY, 0, 1) = '"') AND (NOT BREAK_FLAG));
                                        /*Process this object unit. */
          OU_NAME_ = SUBSTR(KEY_BUF.KEY, 1, KEY_BUF.KEY_LEN - 1);
          CALL PROCESS_OBJECT;
                    /* Position to object unit head record just processed. */
          CALL M$PRECORD (PRECORD_FPT) ALTRET (BAD_PRECORD);
                                        /* Read next head record. */
          CALL M$READ (READ_FPT) ALTRET (BAD_READ);
OKAY:     ;
        END;
     DO WHILE ('0'B);
BAD_PRECORD: ;
          CALL ERROR;
          GOTO DONE;
BAD_READ: ;
          IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$LD
          THEN GOTO OKAY;
          CALL ERROR;
        END;
DONE: ;
END ALL_OBJECT;
%EJECT;
PROCESS_OBJECT: PROC;
DCL I UBIN ALIGNED;
DCL TEMP UBIN ALIGNED;
DCL SEVLEV_TEMP_ UBIN ALIGNED;
DCL UTS_TEMP_ UBIN ALIGNED;
DCL SAVE_LB_SIZE SBIN WORD ALIGNED;
DCL COMPILER_NAME_ CHAR(100) CALIGNED;
DCL CNAME$ PTR ALIGNED;
DCL GOTLB BIT(1) STATIC CALIGNED INIT('0'B);
DCL GOTES BIT(1) STATIC CALIGNED INIT('0'B);
DCL GOTIE BIT(1) STATIC CALIGNED INIT('0'B);
DCL GOTVAR BIT(1) STATIC CALIGNED INIT('0'B);
DCL GOTNAMES BIT(1) STATIC CALIGNED INIT('0'B);
/*Procedure to process an object unit and dump its schema records. */
     GOTLB = '0'B;
     GOTES = '0'B;
     GOTIE = '0'B;
     GOTVAR = '0'B;
     GOTNAMES = '0'B;
     READREC_FPT.V.KEYS#='1'B;
     IF NOT RUNUNIT
     THEN DO;
          HEAD$ = ADDR(HEAD_BUF);
 /* Get severity level, uts, and size of logical block record from head record. */
          SEVLEV_TEMP_ = HEAD$ -> B$OUHEAD.SEVLEV;
          UTS_TEMP_ = HEAD$ -> B$OUHEAD.UTS;
          LB_SIZE = HEAD$ -> B$OUHEAD.LOGBLKSIZ;
               /* Check if 16-bit object unit so can output values in hex. */
          IF HEAD$ -> B$OUHEAD.WORDSIZE = 16
          THEN FEP_RUNUNIT = '1'B;
          ELSE FEP_RUNUNIT = '0'B;
                         /* Write out object unit name and severity level. */
          IF NOT(LB_SIZE <= 0 AND NO_TOP)
          THEN CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(ASTERISK_LINE_) );
                    /* Look for a compiler name record.  If there, write it. */
          REC_KEY.UTS = UTS_TEMP_;
          REC_KEY.TYPE = 23;
          REC_KEY.PAGE = 0;
          REC_KEY.NOTH = '777'O;
          READREC_FPT.KEY_ = VECTOR(REC_KEY);
          READREC_FPT.V.KEYR#='0'B;
          READREC_FPT.BUF_.BOUND = 99;
          READREC_FPT.BUF_.BUF$ = ADDR(COMPILER_NAME_);
          CNAME$ = READREC_FPT.BUF_.BUF$;
          CALL M$READ(READREC_FPT) WHENRETURN DO;
               CALL X$WRITE(F_FDS,VECTOR(OU_SEV_OUT1_),VECTOR(OU_NAME_),
                 VECTOR(CNAME$->B$COMPILER_ID),
                 VECTOR(SEVLEV_TEMP_));
             END;
          WHENALTRETURN DO;
               IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOKEY THEN DO;
                    GOTO BAD_READ;
                  END;
               CALL X$WRITE (F_FDS, VECTOR(OU_SEV_OUT2_),
                 VECTOR(OU_NAME_),
                 VECTOR(SEVLEV_TEMP_) );
             END;
          CALL X$WRITE (F_FDS, VECTOR(BLANK_LINE_) );
        END;
     ELSE DO;
                                        /* Write out object unit name. */
          IF NOT(LB_SIZE <= 0 AND NO_TOP)
          THEN CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(ASTERISK_LINE_) );
          CALL X$WRITE (F_FDS, VECTOR(OU_OUT_),
            VECTOR(OU_NAME_) );
                                        /* Set up logical block record size. */
          LB_SIZE = 1000;
        END;
     READREC_FPT.KEY_ = VECTOR(REC_KEY);
LBLOOP: ;
/* Get data segment for logical block record and read it into memory. */
     IF LB_SIZE = 0
     THEN DO;
          MSG_BUF = ' *** No debug schema. ***';
          CALL M$WRITE (WRITE_FPT);
          IF NOT LO_DO_SAME
          THEN CALL M$WRITE (WRITEDO_FPT);
          NO_TOP = '1'B;
          NO_SCHEMA = '1'B;
          GOTO DONE;
        END;
     NO_TOP = '0'B;
     GDS_FPT.V.SEGSIZE# = LB_SIZE;
     GET_SEG = VECTOR(NIL);
     CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
     GOTLB = '1'B;
     IF RUNUNIT
     THEN SAVE_LB_SIZE = LB_SIZE;
     LBLK$ = GET_SEG.PTR$;
     READREC_FPT.BUF_.BOUND = (LB_SIZE * 4)-1;
     READREC_FPT.BUF_.BUF$ = LBLK$;
     IF RUNUNIT
     THEN REC_KEY.NAMEPTR = NAME_POINTER;
     ELSE REC_KEY.UTS = UTS_TEMP_;
     REC_KEY.TYPE = 11;
     REC_KEY.PAGE = 0;
     REC_KEY.NOTH = '777'O;
     CALL M$READ (READREC_FPT) ALTRET (BAD_READ);
     IF RUNUNIT
     THEN IF (MOD(M$SI$->F$DCB.ARS#,4)=0)
          THEN LB_SIZE = M$SI$ -> F$DCB.ARS# / 4;
          ELSE LB_SIZE = (M$SI$ -> F$DCB.ARS# / 4) + 1;
/* Get sizes of other records, get data segments for them,
   and read them into memory.                              */
     LB$ = PINCRW(LBLK$, SIZEW(B$LBNTRY0) );
     NAME_SIZE = LB$ -> B$LBNTRY1.NAMESIZ;
     IE_SIZE = LB$ -> B$LBNTRY1.INTRYSIZ;
     ES_SIZE = LB$ -> B$LBNTRY1.STMNTSIZ;
     VAR_SIZE = LB$ -> B$LBNTRY1.VREBLSIZ;
     NAMEP_SIZE = LB$ -> B$LBNTRY1.NAMPSIZ;
     IEP_SIZE = LB$ -> B$LBNTRY1.INTRYPSIZ;
     ESP_SIZE = LB$ -> B$LBNTRY1.STMNTPSIZ;
     VARP_SIZE = LB$ -> B$LBNTRY1.VREBLPSIZ;
/* Debug names */
     IF NAME_SIZE > 0 AND
       (IE_SIZE > 0) AND INTENT
     THEN DO;
          GDS_FPT.V.SEGSIZE# = NAME_SIZE + IE_SIZE;
          GET_SEG = VECTOR(NIL);
          CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
          GOTNAMES = '1'B;
          NAME$ = GET_SEG.PTR$;
          IENT$ = PINCRW(NAME$, NAME_SIZE);
          IE$ = IENT$;
          GOTIE = '1'B;
          N$ = NAME$;
          READREC_FPT.BUF_.BUF$ = N$;
          REC_KEY.TYPE = 15;
          IF (NAME_SIZE >= NAMEP_SIZE) AND (NAMEP_SIZE ~= 0)
          THEN DO;
               READREC_FPT.BUF_.BOUND = (NAMEP_SIZE * 4)-1;
               TEMP = NAME_SIZE/NAMEP_SIZE;
               DO I = 1 TO TEMP;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.V.KEYS# = '0'B;
                    N$ = PINCRW(N$, NAMEP_SIZE);
                    READREC_FPT.BUF_.BUF$ = N$;
                  END;
               IF MOD(NAME_SIZE,NAMEP_SIZE) ~= 0
               THEN DO;
                    READREC_FPT.BUF_.BOUND = ((NAME_SIZE-(NAMEP_SIZE*TEMP))*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
          ELSE DO;
               READREC_FPT.BUF_.BOUND = (NAME_SIZE*4)-1;
               CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
             END;
                                        /* Internal entries */
          READREC_FPT.V.KEYS# = '1'B;
          READREC_FPT.BUF_.BUF$ = IE$;
          REC_KEY.TYPE = 12;
          IF (IE_SIZE >= IEP_SIZE) AND (IEP_SIZE ~= 0)
          THEN DO;
               READREC_FPT.BUF_.BOUND = (IEP_SIZE * 4)-1;
               TEMP = IE_SIZE/IEP_SIZE;
               DO I = 1 TO TEMP;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.V.KEYS# = '0'B;
                    IE$ = PINCRW(IE$, IEP_SIZE);
                    READREC_FPT.BUF_.BUF$ = IE$;
                  END;
               IF MOD(IE_SIZE,IEP_SIZE) ~= 0
               THEN DO;
                    READREC_FPT.BUF_.BOUND = ((IE_SIZE-(IEP_SIZE*TEMP))*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
          ELSE DO;
               READREC_FPT.BUF_.BOUND = (IE_SIZE*4)-1;
               CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
             END;
        END;
     ELSE DO;
          IF NAME_SIZE > 0
          THEN DO;
               GDS_FPT.V.SEGSIZE# = NAME_SIZE;
               GET_SEG = VECTOR(NIL);
               CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
               GOTNAMES = '1'B;
               NAME$ = GET_SEG.PTR$;
               N$ = NAME$;
               READREC_FPT.BUF_.BUF$ = N$;
               REC_KEY.TYPE = 15;
               IF (NAME_SIZE >= NAMEP_SIZE) AND (NAMEP_SIZE ~= 0)
               THEN DO;
                    READREC_FPT.BUF_.BOUND = (NAMEP_SIZE * 4)-1;
                    TEMP = NAME_SIZE/NAMEP_SIZE;
                    DO I = 1 TO TEMP;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                         READREC_FPT.V.KEYS# = '0'B;
                         N$ = PINCRW(N$, NAMEP_SIZE);
                         READREC_FPT.BUF_.BUF$ = N$;
                       END;
                    IF MOD(NAME_SIZE,NAMEP_SIZE) ~= 0
                    THEN DO;
                         READREC_FPT.BUF_.BOUND = ((NAME_SIZE-(NAMEP_SIZE*TEMP))*4)-1;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                       END;
                  END;
               ELSE DO;
                    READREC_FPT.BUF_.BOUND = (NAME_SIZE*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
/* Internal entries. */
          IF (IE_SIZE > 0) AND INTENT
          THEN DO;
               GDS_FPT.V.SEGSIZE# = IE_SIZE;
               GET_SEG = VECTOR(NIL);
               CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
               GOTIE = '1'B;
               IENT$ = GET_SEG.PTR$;
               IE$ = IENT$;
               READREC_FPT.V.KEYS# = '1'B;
               READREC_FPT.BUF_.BUF$ = IE$;
               REC_KEY.TYPE = 12;
               IF (IE_SIZE >= IEP_SIZE) AND (IEP_SIZE ~= 0)
               THEN DO;
                    READREC_FPT.BUF_.BOUND = (IEP_SIZE * 4)-1;
                    TEMP = IE_SIZE/IEP_SIZE;
                    DO I = 1 TO TEMP;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                         READREC_FPT.V.KEYS# = '0'B;
                         IE$ = PINCRW(IE$, IEP_SIZE);
                         READREC_FPT.BUF_.BUF$ = IE$;
                       END;
                    IF MOD(IE_SIZE,IEP_SIZE) ~= 0
                    THEN DO;
                         READREC_FPT.BUF_.BOUND = ((IE_SIZE-(IEP_SIZE*TEMP))*4)-1;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                       END;
                  END;
               ELSE DO;
                    READREC_FPT.BUF_.BOUND = (IE_SIZE*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
        END;
/* Executable statements and variables. */
     IF (ES_SIZE > 0) AND EXECSTMT AND
       (VAR_SIZE > 0) AND VARS
     THEN DO;
          GDS_FPT.V.SEGSIZE# = ES_SIZE + VAR_SIZE;
          GET_SEG = VECTOR(NIL);
          CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
          GOTVAR = '1'B;
          EXST$ = GET_SEG.PTR$;
          VAR$ = PINCRW(EXST$, ES_SIZE);
                                        /* Executable statements. */
          ES$ = EXST$;
          READREC_FPT.V.KEYS# = '1'B;
          READREC_FPT.BUF_.BUF$ = ES$;
          REC_KEY.TYPE = 13;
          IF (ES_SIZE >= ESP_SIZE) AND (ESP_SIZE ~= 0)
          THEN DO;
               READREC_FPT.BUF_.BOUND = (ESP_SIZE * 4)-1;
               TEMP = ES_SIZE/ESP_SIZE;
               DO I = 1 TO TEMP;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.V.KEYS# = '0'B;
                    ES$ = PINCRW(ES$, ESP_SIZE);
                    READREC_FPT.BUF_.BUF$ = ES$;
                  END;
               IF MOD(ES_SIZE,ESP_SIZE) ~= 0
               THEN DO;
                    READREC_FPT.BUF_.BOUND = ((ES_SIZE-(ESP_SIZE*TEMP))*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
          ELSE DO;
               READREC_FPT.BUF_.BOUND = (ES_SIZE*4)-1;
               CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
             END;
                                        /* Variables. */
          V$ = VAR$;
          READREC_FPT.V.KEYS# = '1'B;
          READREC_FPT.BUF_.BUF$ = V$;
          REC_KEY.TYPE = 14;
          IF (VAR_SIZE >= VARP_SIZE) AND (VARP_SIZE ~= 0)
          THEN DO;
               READREC_FPT.BUF_.BOUND = (VARP_SIZE * 4)-1;
               TEMP = VAR_SIZE/VARP_SIZE;
               DO I = 1 TO TEMP;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.V.KEYS# = '0'B;
                    V$ = PINCRW(V$, VARP_SIZE);
                    READREC_FPT.BUF_.BUF$ = V$;
                  END;
               IF MOD(VAR_SIZE,VARP_SIZE) ~= 0
               THEN DO;
                    READREC_FPT.BUF_.BOUND = ((VAR_SIZE-(VARP_SIZE*TEMP))*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
          ELSE DO;
               READREC_FPT.BUF_.BOUND = (VAR_SIZE*4)-1;
               CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
             END;
        END;
     ELSE DO;
                                        /* Executable statements. */
          IF (ES_SIZE > 0) AND EXECSTMT
          THEN DO;
               GDS_FPT.V.SEGSIZE# = ES_SIZE;
               GET_SEG = VECTOR(NIL);
               CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
               GOTES = '1'B;
               EXST$ = GET_SEG.PTR$;
               ES$ = EXST$;
               READREC_FPT.V.KEYS# = '1'B;
               READREC_FPT.BUF_.BUF$ = ES$;
               REC_KEY.TYPE = 13;
               IF (ES_SIZE >= ESP_SIZE) AND (ESP_SIZE ~= 0)
               THEN DO;
                    READREC_FPT.BUF_.BOUND = (ESP_SIZE * 4)-1;
                    TEMP = ES_SIZE/ESP_SIZE;
                    DO I = 1 TO TEMP;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                         READREC_FPT.V.KEYS# = '0'B;
                         ES$ = PINCRW(ES$, ESP_SIZE);
                         READREC_FPT.BUF_.BUF$ = ES$;
                       END;
                    IF MOD(ES_SIZE,ESP_SIZE) ~= 0
                    THEN DO;
                         READREC_FPT.BUF_.BOUND = ((ES_SIZE-(ESP_SIZE*TEMP))*4)-1;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                       END;
                  END;
               ELSE DO;
                    READREC_FPT.BUF_.BOUND = (ES_SIZE*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
                                        /* Variables. */
          IF (VAR_SIZE > 0) AND VARS
          THEN DO;
               GDS_FPT.V.SEGSIZE# = VAR_SIZE;
               GET_SEG = VECTOR(NIL);
               CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
               GOTVAR = '1'B;
               VAR$ = GET_SEG.PTR$;
               V$ = VAR$;
               READREC_FPT.V.KEYS# = '1'B;
               READREC_FPT.BUF_.BUF$ = V$;
               REC_KEY.TYPE = 14;
               IF (VAR_SIZE >= VARP_SIZE) AND (VARP_SIZE ~= 0)
               THEN DO;
                    READREC_FPT.BUF_.BOUND = (VARP_SIZE * 4)-1;
                    TEMP = VAR_SIZE/VARP_SIZE;
                    DO I = 1 TO TEMP;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                         READREC_FPT.V.KEYS# = '0'B;
                         V$ = PINCRW(V$, VARP_SIZE);
                         READREC_FPT.BUF_.BUF$ = V$;
                       END;
                    IF MOD(VAR_SIZE,VARP_SIZE) ~= 0
                    THEN DO;
                         READREC_FPT.BUF_.BOUND = ((VAR_SIZE-(VARP_SIZE*TEMP))*4)-1;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                       END;
                  END;
               ELSE DO;
                    READREC_FPT.BUF_.BOUND = (VAR_SIZE*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
        END;
/* Dump out schema records for this object unit. */
     CALL SDUMP_DUMP;
/* Release data segments for this object unit. */
/* Logical block. */
DONE: ;
     IF (LB_SIZE > 0) AND GOTLB
     THEN DO;
          IF RUNUNIT
          THEN LB_SIZE = SAVE_LB_SIZE;
          FDS_FPT.V.SEGSIZE# = LB_SIZE;
          FREE_SEG.PTR$ = LBLK$;
          CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
          GOTLB = '0'B;
        END;
/* Executable statements and variables. */
     IF (ES_SIZE > 0) AND EXECSTMT AND
       (VAR_SIZE > 0) AND VARS AND GOTVAR
     THEN DO;
          FDS_FPT.V.SEGSIZE# = ES_SIZE + VAR_SIZE;
          FREE_SEG.PTR$ = EXST$;
          CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
          GOTVAR = '0'B;
          GOTES = '0'B;
        END;
     ELSE DO;
                                        /* Executable statements. */
          IF (ES_SIZE > 0) AND EXECSTMT AND GOTES
          THEN DO;
               FDS_FPT.V.SEGSIZE# = ES_SIZE;
               FREE_SEG.PTR$ = EXST$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
               GOTES = '0'B;
             END;
                                        /* Variables. */
          IF (VAR_SIZE > 0) AND VARS AND GOTVAR
          THEN DO;
               FDS_FPT.V.SEGSIZE# = VAR_SIZE;
               FREE_SEG.PTR$ = VAR$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
               GOTVAR = '0'B;
             END;
        END;
/* Debug names and internal entries */
     IF (NAME_SIZE > 0) AND GOTNAMES AND
       (IE_SIZE > 0) AND INTENT AND GOTIE
     THEN DO;
          FDS_FPT.V.SEGSIZE# = NAME_SIZE + IE_SIZE;
          FREE_SEG.PTR$ = NAME$;
          CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
          GOTNAMES = '0'B;
          GOTIE = '0'B;
        END;
     ELSE DO;
                                        /* Internal entries. */
          IF (IE_SIZE > 0) AND INTENT AND GOTIE
          THEN DO;
               FDS_FPT.V.SEGSIZE# = IE_SIZE;
               FREE_SEG.PTR$ = IENT$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
               GOTIE = '0'B;
             END;
          IF (NAME_SIZE > 0) AND GOTNAMES
          THEN DO;
               FDS_FPT.V.SEGSIZE# = NAME_SIZE;
               FREE_SEG.PTR$ = NAME$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
               GOTNAMES = '0'B;
             END;
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
          GOTO DONE;
BAD_READ: ;
          IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$NOKEY
          THEN DO;
               MSG_BUF = ' *** No debug schema. ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
               IF (LB_SIZE > 0) AND GOTLB
               THEN DO;
                    IF RUNUNIT
                    THEN LB_SIZE = SAVE_LB_SIZE;
                    FDS_FPT.V.SEGSIZE# = LB_SIZE;
                    FREE_SEG.PTR$ = LBLK$;
                    CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
                    GOTLB = '0'B;
                  END;
               NO_TOP = '1'B;
               LB_SIZE = 0;
               NO_SCHEMA = '1'B;
               GOTO DONE;
             END;
          IF RUNUNIT
          THEN DO;
               IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$LD
               THEN DO;
                    FDS_FPT.V.SEGSIZE# = LB_SIZE;
                    FREE_SEG.PTR$ = LBLK$;
                    CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME);
                    LB_SIZE = LB_SIZE + 1000;
                    GOTO LBLOOP;
                  END;
             END;
          CALL ERROR;
          GOTO DONE;
        END;
END PROCESS_OBJECT;
%EJECT;
SET_UP_OU: PROC;
/* SET_UP_OU - procedure to make sure ou is valid and set up things correctly. */
DCL CHECK_SIZE UBIN HALF ALIGNED;
DCL FOUND BIT(1) STATIC CALIGNED;
     IF RUNUNIT
     THEN DO;
     /* Get data segment for defnames and entdefs and read them into memory. */
          IF OVRL_BIT THEN GOTO DONE;
          IF NOT GOTDEFS
          THEN DO;
               GOTDEFS = '0'B;
               IF DEFNAME_SIZE > 0
               THEN DO;
                    GDS_FPT.V.SEGSIZE# = DEFNAME_SIZE + ENTDEF_SIZE;
                    GET_SEG = VECTOR(NIL);
                    CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
                    GOTDEFS = '1'B;
                    DEFN$ = GET_SEG.PTR$;
                    ENT$ = PINCRW(DEFN$, DEFNAME_SIZE);
                    READREC_FPT.BUF_.BOUND = (DEFNAME_SIZE * 4) - 1;
                    READREC_FPT.BUF_.BUF$ = DEFN$;
                    READREC_FPT.V.KEYS# = '1'B;
                    READREC_FPT.V.KEYR# = '0'B;
                    READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
                    RECORD_KEY.REC_TYPE = 1;
                    RECORD_KEY.NODE# = 0;
                    RECORD_KEY.OFFSET = 0;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.BUF_.BOUND = (ENTDEF_SIZE * 4) - 1;
                    READREC_FPT.BUF_.BUF$ = ENT$;
                    RECORD_KEY.REC_TYPE = 4;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    SAVE_ENTDEFSIZE = ENTDEF_SIZE;
                    IF (MOD(M$SI$->F$DCB.ARS#,4)=0)
                    THEN ENTDEF_SIZE = M$SI$ -> F$DCB.ARS# / 4;
                    ELSE ENTDEF_SIZE = (M$SI$ -> F$DCB.ARS# / 4) + 1;
                  END;
               ELSE DO;
                    MSG_BUF = ' *** No defnames for run unit. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                  END;
             END;
          /* Go through primary entdefs until find object unit looking for. */
          IF ALLOU THEN GOTO DONE;
          E$ = ENT$;
          CHECK_SIZE = 0;
          FOUND = '0'B;
          DO WHILE ((CHECK_SIZE < ENTDEF_SIZE) AND NOT FOUND);
               IF E$ -> B$EDEF.PRI AND (E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_OBJECT# OR
                 E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_ULIB# OR
                 E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_REMOVED# AND LIB_BIT)
               THEN DO;
                    IF (OU_NAME_ = (PINCRW(DEFN$,E$->B$EDEF.NPOINTER)->B$DNAME.TEXT))
                    THEN FOUND = '1'B;
                    ELSE DO;
                         E$ = PINCRW(E$, SIZEW(B$EDEF));
                         CHECK_SIZE = CHECK_SIZE + SIZEW(B$EDEF);
                       END;
                  END;
               ELSE DO;
                    E$ = PINCRW(E$, SIZEW(B$EDEF));
                    CHECK_SIZE = CHECK_SIZE + SIZEW(B$EDEF);
                  END;
             END;
          IF NOT FOUND
          THEN DO;
               MSG_BUF = ' *** Object unit not in specified run unit. ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
             END;
        END;
     ELSE DO;
                              /* Get object unit name and see if one want. */
          KEY_BUF = %CONCAT('001'O,ASCBIT('"'));
          DO UNTIL (OU_NAME_ = SUBSTR(KEY_BUF.KEY, 1, KEY_BUF.KEY_LEN - 1));
               CALL M$PRECORD (PRECORD_FPT) ALTRET (BAD_PMME);
               IF SUBSTR(KEY_BUF.KEY, 0, 1) ~= '"'
               THEN GOTO NOT_IN_FILE;
             END;
          DO WHILE ('0'B);
NOT_IN_FILE:   ;
               MSG_BUF = ' *** Object unit not in specified file. ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
             END;
DONE:     ;
          DO WHILE('0'B);
BAD_PMME:      ;
               CALL ERROR;
             END;
        END;
END SET_UP_OU;
     %EJECT;
SDUMP_RUN: PROC;
/* SDUMP_RUN - procedure to process run unit files. */
     IF OVRL_BIT
     THEN CALL OVERLAY_RU;
     ELSE CALL REGULAR_RU;
END SDUMP_RUN;
%EJECT;
SEARCH_TREE: PROC;
/* SEARCH_TREE - procedure to search tree table for NODE_ */
DCL I UBIN WORD ALIGNED;
     FOUND_NODE = '0'B;
     I=0;
     PTR$ = T$ -> B$TREE_NODE.NAME$;
     DO WHILE (I < NUMBER_NODES );
          IF NODE_ = PINCRW(TREE$, POINTER.LH) -> TEXT.STRING
          THEN DO;
               FOUND_NODE = '1'B;
               NODE_LEVEL = I;
               EXIT;
             END;
          T$ = PINCRW(T$, SIZEW(B$TREE_NODE) );
          I = I + 1;
          PTR$ = T$ -> B$TREE_NODE.NAME$;
        END;
END SEARCH_TREE;
%EJECT;
GET_TREE_TABLE: PROC;
/* GET_TREE_TABLE - procedure to read read only segment into memory
                    so can get tree table for overlayed run unit.  */
DCL I UBIN ALIGNED;
DCL TEMP UBIN ALIGNED;
     IF ROSEG_SIZE > 0
     THEN DO;
                                        /* Get data segment for roseg. */
          IF (MOD(ROSEG_SIZE, 1024) = 0)
          THEN ROSEG_BUFFER_SIZE = ROSEG_SIZE;
          ELSE ROSEG_BUFFER_SIZE = 1024 * ((ROSEG_SIZE / 1024) + 1);
          GDS_FPT.V.SEGSIZE# = ROSEG_BUFFER_SIZE;
          GET_SEG = VECTOR(NIL);
          CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
          ROSEG$ = GET_SEG.PTR$;
          TREE$ = PINCRW(ROSEG$, TREE_DISP);
                                        /* Read roseg into memory. */
          READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
          READREC_FPT.BUF_.BUF$ = ROSEG$;
          READREC_FPT.V.KEYS# = '1'B;
          READREC_FPT.V.KEYR# = '0'B;
          RECORD_KEY.REC_TYPE = 30;
          RECORD_KEY.NODE# = 0;
          RECORD_KEY.OFFSET = 0;
          R$ = ROSEG$;
          IF (ROSEG_BUFFER_SIZE > MAX_PRECSIZE) AND (MAX_PRECSIZE ~= 0)
          THEN DO;
               READREC_FPT.BUF_.BOUND = (MAX_PRECSIZE * 4) -1;
               TEMP = ROSEG_BUFFER_SIZE / MAX_PRECSIZE;
               DO I = 1 TO TEMP;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.V.KEYS# = '0'B;
                    R$ = PINCRW(R$, MAX_PRECSIZE);
                    READREC_FPT.BUF_.BUF$ = R$;
                  END;
               IF MOD(ROSEG_BUFFER_SIZE,MAX_PRECSIZE) ~= 0
               THEN DO;
                    READREC_FPT.BUF_.BOUND = ((ROSEG_BUFFER_SIZE -(MAX_PRECSIZE*TEMP))*4)-1;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                  END;
             END;
          ELSE DO;
               READREC_FPT.BUF_.BOUND = (ROSEG_BUFFER_SIZE * 4) -1;
               CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
             END;
          T$ = PINCRW(TREE$, SIZEW(B$TREE_HEADER) );
          NUMBER_NODES = TREE$ -> B$TREE_HEADER.NODES;
          GOT_TREE_TABLE = '1'B;
        END;
     ELSE DO;
          MSG_BUF = ' *** No read only segment. ***';
          CALL M$WRITE (WRITE_FPT);
          IF NOT LO_DO_SAME
          THEN CALL M$WRITE (WRITEDO_FPT);
          BAD_FILE = '1'B;
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
        END;
END GET_TREE_TABLE;
%EJECT;
LIST_RU: PROC;
DCL SEVLEV_TEMP_ UBIN ALIGNED;
DCL SAVE_ENTDEF_SIZE SBIN WORD ALIGNED;
DCL GOTENTDEFS BIT(1) STATIC CALIGNED INIT('0'B);
/* LIST_RU - procedure to list primary entdefs within a run unit. */
/*           Default is level zero if no node is specified.       */
     GOTENTDEFS = '0'B;
     SEVLEV_TEMP_ = HEAD$ -> B$HEAD.SEV;
/* Write out severity level. */
     CALL X$WRITE (F_FDS, VECTOR(RU_SEV_OUT_),
       VECTOR(SEVLEV_TEMP_) );
     IF NODE_ = ' '
     THEN DO;
          IF DEFNAME_SIZE > 0
          THEN DO;
               IF GOTDEFS THEN GOTO DUMPIT;
               /* Get data segment for defnames and read them into memory. */
               GDS_FPT.V.SEGSIZE# = DEFNAME_SIZE;
               GET_SEG = VECTOR(NIL);
               CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
               GOTDEFS = '1'B;
               DEFN$ = GET_SEG.PTR$;
               READREC_FPT.BUF_.BOUND = (DEFNAME_SIZE * 4) -1;
               READREC_FPT.BUF_.BUF$ = DEFN$;
               READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
               READREC_FPT.V.KEYS# = '1'B;
               READREC_FPT.V.KEYR# = '0'B;
               RECORD_KEY.REC_TYPE = 1;
               RECORD_KEY.NODE# = 0;
               RECORD_KEY.OFFSET = 0;
               CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
               IF ENTDEF_SIZE > 0
               THEN DO;
               /* Get data segment for entdefs and read them into memory. */
                    GDS_FPT.V.SEGSIZE# = ENTDEF_SIZE;
                    GET_SEG = VECTOR(NIL);
                    CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
                    GOTENTDEFS = '1'B;
                    ENT$ = GET_SEG.PTR$;
                    READREC_FPT.BUF_.BOUND = (ENTDEF_SIZE * 4) -1;
                    READREC_FPT.BUF_.BUF$ = ENT$;
                    READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
                    RECORD_KEY.REC_TYPE = 4;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    SAVE_ENTDEF_SIZE = ENTDEF_SIZE;
                    IF (MOD(M$SI$ -> F$DCB.ARS#, 4) = 0)
                    THEN ENTDEF_SIZE = M$SI$ -> F$DCB.ARS# / 4;
                    ELSE ENTDEF_SIZE = (M$SI$ -> F$DCB.ARS# / 4) + 1;
                                        /* Dump out entdefs. */
DUMPIT:
                    IF ALL_ENTDEFS
                    THEN CALL DUMP_ALL_ENTDEFS;
                    ELSE CALL DUMP_ENTDEFS;
                  END;
               ELSE DO;
                    MSG_BUF = ' *** No entdefs for file specified. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                  END;
             END;
          ELSE DO;
               MSG_BUF = ' *** No defnames for file specified. ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
             END;
                                        /* Release data segment from entdefs. */
        END;
     ELSE DO;
          IF NOT GOT_TREE_TABLE
          THEN CALL GET_TREE_TABLE;
          ELSE T$ = PINCRW(TREE$, SIZEW(B$TREE_HEADER));
          IF NOT BAD_FILE
          THEN DO;
               CALL SEARCH_TREE;
                    /* If found NODE_ in tree table, list primary entdefs. */
               IF FOUND_NODE
               THEN DO;
                    IF DEFNAME_SIZE > 0
                    THEN DO;
                         IF GOTDEFS
                         THEN DO;
                              FDS_FPT.V.SEGSIZE# = DEFNAME_SIZE + ENTDEF_SIZE;
                              FREE_SEG.PTR$ = DEFN$;
                              CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME1);
                              GOTDEFS = '0'B;
                            END;
               /* Get data segment for defnames and read them into memory. */
                         GDS_FPT.V.SEGSIZE# = DEFNAME_SIZE;
                         GET_SEG = VECTOR(NIL);
                         CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
                         GOTDEFS = '1'B;
                         DEFN$ = GET_SEG.PTR$;
                         READREC_FPT.BUF_.BOUND = (DEFNAME_SIZE * 4) -1;
                         READREC_FPT.BUF_.BUF$ = DEFN$;
                         READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
                         READREC_FPT.V.KEYS# = '1'B;
                         READREC_FPT.V.KEYR# = '0'B;
                         RECORD_KEY.REC_TYPE = 1;
                         RECORD_KEY.NODE# = NODE_LEVEL;
                         RECORD_KEY.OFFSET = 0;
                         CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                         IF ENTDEF_SIZE > 0
                         THEN DO;
               /* Get data segment for entdefs and read them into memory. */
                              GDS_FPT.V.SEGSIZE# = ENTDEF_SIZE;
                              GET_SEG = VECTOR(NIL);
                              CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
                              GOTENTDEFS = '1'B;
                              ENT$ = GET_SEG.PTR$;
                              READREC_FPT.BUF_.BOUND = (ENTDEF_SIZE * 4) -1;
                              READREC_FPT.BUF_.BUF$ = ENT$;
                              READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
                              RECORD_KEY.REC_TYPE = 4;
                              CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                              SAVE_ENTDEF_SIZE = ENTDEF_SIZE;
                              IF (MOD(M$SI$ -> F$DCB.ARS#, 4) = 0)
                              THEN ENTDEF_SIZE = M$SI$ -> F$DCB.ARS# / 4;
                              ELSE ENTDEF_SIZE = (M$SI$ -> F$DCB.ARS# / 4) + 1;
                                        /* Dump out entdefs. */
                              IF ALL_ENTDEFS
                              THEN CALL DUMP_ALL_ENTDEFS;
                              ELSE CALL DUMP_ENTDEFS;
                            END;
                         ELSE DO;
                              MSG_BUF = ' *** No entdefs for node specified. ***';
                              CALL M$WRITE (WRITE_FPT);
                              IF NOT LO_DO_SAME
                              THEN CALL M$WRITE (WRITEDO_FPT);
                            END;
                       END;
                    ELSE DO;
                         MSG_BUF = ' *** No defnames for node specified. ***';
                         CALL M$WRITE (WRITE_FPT);
                         IF NOT LO_DO_SAME
                         THEN CALL M$WRITE (WRITEDO_FPT);
                       END;
                                        /* Release data segment from entdefs. */
                  END;
               ELSE DO;
                    MSG_BUF = ' *** Specified node not in overlayed run unit. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                  END;
             END;
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
                                        /* Release data segment from entdefs. */
          IF (ENTDEF_SIZE > 0) AND GOTENTDEFS
          THEN DO;
               ENTDEF_SIZE = SAVE_ENTDEF_SIZE;
               FDS_FPT.V.SEGSIZE# = ENTDEF_SIZE;
               FREE_SEG.PTR$ = ENT$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME1);
               GOTENTDEFS = '0'B;
             END;
                                        /* Release data segment for defnames. */
          IF (DEFNAME_SIZE > 0) AND GOTDEFS
          THEN DO;
               FDS_FPT.V.SEGSIZE# = DEFNAME_SIZE;
               FREE_SEG.PTR$ = DEFN$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME1);
               GOTDEFS = '0'B;
             END;
        END;
DONE: ;
     DO WHILE ('0'B);
BAD_PMME1: ;
          CALL ERROR;
        END;
END LIST_RU;
%EJECT;
OVERLAY_RU: PROC;
/* OVERLAY_RU - procedure to handle overlayed run units. */
DCL SAVE_ENTDEF_SIZE SBIN WORD ALIGNED;
     IF NODE_ = ' '
     THEN DO;
          MSG_BUF = ' *** No node specified for overlayed run unit. ***';
          CALL M$WRITE (WRITE_FPT);
          IF NOT LO_DO_SAME
          THEN CALL M$WRITE (WRITEDO_FPT);
        END;
     ELSE DO;
                              /* If found NODE_ in tree table, process it. */
          IF FOUND_NODE
          THEN DO;
/* Get data segment for defnames and entdefs and read them into memory. */
               IF DEFNAME_SIZE > 0
               THEN DO;
                    IF GOTDEFS
                    THEN DO;
                         FDS_FPT.V.SEGSIZE# = DEFNAME_SIZE + ENTDEF_SIZE;
                         FREE_SEG.PTR$ = DEFN$;
                         CALL M$FDS (FDS_FPT) ALTRET(BAD_PMME1);
                         GOTDEFS = '0'B;
                       END;
                    GDS_FPT.V.SEGSIZE# = DEFNAME_SIZE + ENTDEF_SIZE;
                    GET_SEG = VECTOR(NIL);
                    CALL M$GDS (GDS_FPT) ALTRET (BAD_PMME);
                    GOTDEFS = '1'B;
                    DEFN$ = GET_SEG.PTR$;
                    ENT$ = PINCRW(DEFN$, DEFNAME_SIZE);
                    READREC_FPT.BUF_.BOUND = (DEFNAME_SIZE * 4) - 1;
                    READREC_FPT.BUF_.BUF$ = DEFN$;
                    READREC_FPT.V.KEYS# = '1'B;
                    READREC_FPT.V.KEYR# = '0'B;
                    READREC_FPT.KEY_ = VECTOR(RECORD_KEY);
                    RECORD_KEY.REC_TYPE = 1;
                    RECORD_KEY.NODE# = NODE_LEVEL;
                    RECORD_KEY.OFFSET = 0;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    READREC_FPT.BUF_.BOUND = (ENTDEF_SIZE * 4) - 1;
                    READREC_FPT.BUF_.BUF$ = ENT$;
                    RECORD_KEY.REC_TYPE = 4;
                    CALL M$READ (READREC_FPT) ALTRET (BAD_PMME);
                    SAVE_ENTDEF_SIZE = ENTDEF_SIZE;
                    IF (MOD(M$SI$->F$DCB.ARS#,4)=0)
                    THEN ENTDEF_SIZE = M$SI$ -> F$DCB.ARS# / 4;
                    ELSE ENTDEF_SIZE = (M$SI$ -> F$DCB.ARS# / 4) + 1;
                    IF ALLOU
                    THEN CALL ALL_RUOBJECT;
                    ELSE DO;
                         NAME_POINTER = E$ -> B$EDEF.NPOINTER;
                         CALL PROCESS_OBJECT;
                       END;
                  END;
               ELSE DO;
                    MSG_BUF = ' *** No defnames for node specified. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                  END;
                                   /* Release data segment from defnames. */
             END;
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
                                   /* Release data segment from defnames. */
          IF (DEFNAME_SIZE > 0) AND GOTDEFS
          THEN DO;
               ENTDEF_SIZE = SAVE_ENTDEF_SIZE;
               FDS_FPT.V.SEGSIZE# = DEFNAME_SIZE + ENTDEF_SIZE;
               FREE_SEG.PTR$ = DEFN$;
               CALL M$FDS (FDS_FPT) ALTRET (BAD_PMME1);
               GOTDEFS = '0'B;
             END;
        END;
     DO WHILE ('0'B);
BAD_PMME1: ;
          CALL ERROR;
        END;
END OVERLAY_RU;
%EJECT;
REGULAR_RU: PROC;
/* REGULAR_RU - procedure to handle nonoverlayed run units. */
     IF ALLOU
     THEN CALL ALL_RUOBJECT;
     ELSE DO;
          NAME_POINTER = E$ -> B$EDEF.NPOINTER;
          CALL PROCESS_OBJECT;
        END;
END REGULAR_RU;
%EJECT;
DUMP_ALL_ENTDEFS: PROC;
/* DUMP_ALL_ENTDEFS - procedure to dump out all entdefs. */
DCL CHECK_SIZE UBIN HALF ALIGNED;
DCL NPOINTER_TEMP_ UBIN ALIGNED;
DCL SOURCE_TEMP_ UBIN ALIGNED;
DCL DEFINED_TEMP_ UBIN ALIGNED;
DCL MULTIPLE_TEMP_ UBIN ALIGNED;
DCL USED_TEMP_ UBIN ALIGNED;
DCL FAULTAGS_TEMP_ UBIN ALIGNED;
DCL ISADDR_TEMP_ UBIN ALIGNED;
DCL PRI_TEMP_ UBIN ALIGNED;
DCL ALT_TEMP_ UBIN ALIGNED;
DCL CHECK_TEMP_ UBIN ALIGNED;
DCL CST_TEMP_ UBIN ALIGNED;
DCL NPARAM_TEMP_ UBIN ALIGNED;
/* Write out all entdefs. */
     CHECK_SIZE = 0;
     IF ENTDEF_SIZE > 0
     THEN DO;
          CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(ENTDEF_HEAD_OUT_) );
          IF FEP_RUNUNIT
          THEN DO;
               TEMPMSG_ = ENTDEF_HEADING_HEX_;
               VLP_HDR.TITL = PENT_PGHDR_HEX;
             END;
          ELSE DO;
               TEMPMSG_ = ENTDEF_HEADING_OCT_;
               VLP_HDR.TITL = PENT_PGHDR_OCT;
             END;
          CALL X$WRITE (F_FDS, TEMPMSG_ );
          CALL M$DEVICE (DEVICE_FPT) ALTRET (BAD_PMME);
          E$ = ENT$;
          DO WHILE ((CHECK_SIZE < ENTDEF_SIZE) AND (NOT BREAK_FLAG));
               IF E$ -> B$EDEF.NPOINTER > DEFNAME_SIZE
               THEN DO;
                    NPOINTER_TEMP_ = E$ -> B$EDEF.NPOINTER;
                    CALL X$WRITE (F_FDS, VECTOR(BAD_NAME_POINTER_),
                      VECTOR(NPOINTER_TEMP_) );
                    NAME_ = '     ';
                    GOTO ENTOUTO;
                  END;
               IF E$ -> B$EDEF.NPOINTER < 0
               THEN NAME_ = '     ';
               ELSE NAME_ = PINCRW(DEFN$,E$->B$EDEF.NPOINTER)->B$DNAME.TEXT;
ENTOUTO:       ;
               SOURCE_TEMP_ = E$ -> B$EDEF.LFLAGS.SOURCE;
               DEFINED_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.DEFINED);
               MULTIPLE_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.MULTIPLE);
               USED_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.USED);
               FAULTAGS_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.FAULTAGS);
               ISADDR_TEMP_ = E$ -> B$EDEF.ISADDR;
               PRI_TEMP_ = BITBIN(E$ -> B$EDEF.PRI);
               ALT_TEMP_ = BITBIN(E$ -> B$EDEF.ALT);
               CHECK_TEMP_ = BITBIN(E$ -> B$EDEF.CHECK);
               CST_TEMP_ = E$ -> B$EDEF.CST;
               NPARAM_TEMP_ = E$ -> B$EDEF.NPARAM;
               IF FEP_RUNUNIT
               THEN TEMPMSG_ = ENTDEF_OUT_HEX_;
               ELSE TEMPMSG_ = ENTDEF_OUT_OCT_;
               CALL X$WRITE (F_FDS, TEMPMSG_,
                 VECTOR(SOURCE_TEMP_),
                 VECTOR(DEFINED_TEMP_),
                 VECTOR(MULTIPLE_TEMP_),
                 VECTOR(USED_TEMP_),
                 VECTOR(FAULTAGS_TEMP_),
                 VECTOR(ISADDR_TEMP_),
                 VECTOR(PRI_TEMP_),
                 VECTOR(ALT_TEMP_),
                 VECTOR(CHECK_TEMP_),
                 VECTOR(CST_TEMP_),
                 VECTOR(NPARAM_TEMP_),
                 VECTOR(NAME_) );
               E$ = PINCRW(E$, SIZEW(B$EDEF) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$EDEF);
             END;
          CALL M$DEVICE (DEVICE_ERASE_FPT) ALTRET (BAD_PMME);
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
        END;
END DUMP_ALL_ENTDEFS;
%EJECT;
DUMP_ENTDEFS: PROC;
/* DUMP_ENTDEFS - procedure to dump out primary entdefs. */
DCL CHECK_SIZE UBIN HALF ALIGNED;
DCL NPOINTER_TEMP_ UBIN ALIGNED;
DCL SOURCE_TEMP_ UBIN ALIGNED;
DCL DEFINED_TEMP_ UBIN ALIGNED;
DCL MULTIPLE_TEMP_ UBIN ALIGNED;
DCL USED_TEMP_ UBIN ALIGNED;
DCL FAULTAGS_TEMP_ UBIN ALIGNED;
DCL ISADDR_TEMP_ UBIN ALIGNED;
DCL PRI_TEMP_ UBIN ALIGNED;
DCL ALT_TEMP_ UBIN ALIGNED;
DCL CHECK_TEMP_ UBIN ALIGNED;
DCL CST_TEMP_ UBIN ALIGNED;
DCL NPARAM_TEMP_ UBIN ALIGNED;
/* Write out all primary entdefs. */
     CHECK_SIZE = 0;
     IF ENTDEF_SIZE > 0
     THEN DO;
          CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(ENTDEF_HEAD_OUT_) );
          IF FEP_RUNUNIT
          THEN DO;
               TEMPMSG_ = ENTDEF_HEADING_HEX_;
               VLP_HDR.TITL = PENT_PGHDR_HEX;
             END;
          ELSE DO;
               TEMPMSG_ = ENTDEF_HEADING_OCT_;
               VLP_HDR.TITL = PENT_PGHDR_OCT;
             END;
          CALL X$WRITE (F_FDS, TEMPMSG_ );
          CALL M$DEVICE (DEVICE_FPT) ALTRET (BAD_PMME);
          E$ = ENT$;
          DO WHILE ((CHECK_SIZE < ENTDEF_SIZE) AND (NOT BREAK_FLAG));
               IF E$ -> B$EDEF.PRI AND (E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_OBJECT# OR
                 E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_ULIB# OR
                 E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_REMOVED# AND LIB_BIT)
               THEN DO;
                    IF E$ -> B$EDEF.NPOINTER > DEFNAME_SIZE
                    THEN DO;
                         NPOINTER_TEMP_ = E$ -> B$EDEF.NPOINTER;
                         CALL X$WRITE (F_FDS, VECTOR(BAD_NAME_POINTER_),
                           VECTOR(NPOINTER_TEMP_) );
                         NAME_ = '     ';
                         GOTO ENTOUTO;
                       END;
                    IF E$ -> B$EDEF.NPOINTER < 0
                    THEN NAME_ = '     ';
                    ELSE NAME_ = PINCRW(DEFN$,E$->B$EDEF.NPOINTER)->B$DNAME.TEXT;
ENTOUTO:            ;
                    SOURCE_TEMP_ = E$ -> B$EDEF.LFLAGS.SOURCE;
                    DEFINED_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.DEFINED);
                    MULTIPLE_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.MULTIPLE);
                    USED_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.USED);
                    FAULTAGS_TEMP_ = BITBIN(E$ -> B$EDEF.LFLAGS.FAULTAGS);
                    ISADDR_TEMP_ = E$ -> B$EDEF.ISADDR;
                    PRI_TEMP_ = BITBIN(E$ -> B$EDEF.PRI);
                    ALT_TEMP_ = BITBIN(E$ -> B$EDEF.ALT);
                    CHECK_TEMP_ = BITBIN(E$ -> B$EDEF.CHECK);
                    CST_TEMP_ = E$ -> B$EDEF.CST;
                    NPARAM_TEMP_ = E$ -> B$EDEF.NPARAM;
                    IF FEP_RUNUNIT
                    THEN TEMPMSG_ = ENTDEF_OUT_HEX_;
                    ELSE TEMPMSG_ = ENTDEF_OUT_OCT_;
                    CALL X$WRITE (F_FDS, TEMPMSG_,
                      VECTOR(SOURCE_TEMP_),
                      VECTOR(DEFINED_TEMP_),
                      VECTOR(MULTIPLE_TEMP_),
                      VECTOR(USED_TEMP_),
                      VECTOR(FAULTAGS_TEMP_),
                      VECTOR(ISADDR_TEMP_),
                      VECTOR(PRI_TEMP_),
                      VECTOR(ALT_TEMP_),
                      VECTOR(CHECK_TEMP_),
                      VECTOR(CST_TEMP_),
                      VECTOR(NPARAM_TEMP_),
                      VECTOR(NAME_) );
                  END;
               E$ = PINCRW(E$, SIZEW(B$EDEF) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$EDEF);
             END;
          CALL M$DEVICE (DEVICE_ERASE_FPT) ALTRET (BAD_PMME);
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
        END;
END DUMP_ENTDEFS;
%EJECT;
ALL_RUOBJECT: PROC;
/* ALL_RUOBJECT - procedure to process all object units from a run unit. */
DCL CHECK_SIZE UBIN HALF ALIGNED;
/* Process all object units which are primary entdefs. */
     E$ = ENT$;
     CHECK_SIZE = 0;
     DO WHILE ((CHECK_SIZE < ENTDEF_SIZE) AND (NOT BREAK_FLAG));
          IF E$ -> B$EDEF.PRI AND (E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_OBJECT# OR
            E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_ULIB# OR
            E$ -> B$EDEF.LFLAGS.SOURCE = %SOURCE_REMOVED# AND LIB_BIT)
          THEN DO;
               NAME_POINTER = E$ -> B$EDEF.NPOINTER;
               OU_NAME_ = PINCRW(DEFN$, NAME_POINTER) -> B$DNAME.TEXT;
               CALL PROCESS_OBJECT;
             END;
          E$ = PINCRW(E$, SIZEW(B$EDEF));
          CHECK_SIZE = CHECK_SIZE + SIZEW(B$EDEF);
        END;
END ALL_RUOBJECT;
%EJECT;
LIST_NODES: PROC;
/* LIST_NODES - procedure to write out all nodes in overlayed rununit. */
DCL I UBIN WORD ALIGNED;
DCL NODE#_TEMP_ UBIN WORD ALIGNED;
DCL BACK#_TEMP_ SBIN WORD ALIGNED;
DCL FORWARD#_TEMP_ SBIN WORD ALIGNED;
DCL OVERLAY#_TEMP_ SBIN WORD ALIGNED;
DCL DADDR_TEMP_ UBIN WORD ALIGNED;
DCL DATAH_TEMP_ UBIN WORD ALIGNED;
DCL DSIZE_TEMP_ UBIN WORD ALIGNED;
DCL PADDR_TEMP_ UBIN WORD ALIGNED;
DCL PROCH_TEMP_ UBIN WORD ALIGNED;
DCL PSIZE_TEMP_ UBIN WORD ALIGNED;
/* Get roseg so can get at tree table. */
     IF NOT GOT_TREE_TABLE
     THEN CALL GET_TREE_TABLE;
     ELSE T$ = PINCRW(TREE$, SIZEW(B$TREE_HEADER));
     IF NOT BAD_FILE
     THEN DO;
          CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(NODE_HEAD_OUT_) );
          CALL X$WRITE (F_FDS, VECTOR(NODE_HEADING1_) );
          CALL X$WRITE (F_FDS, VECTOR(NODE_HEADING2_) );
          VLP_HDR.TITL = NODES_PGHDR;
          CALL M$DEVICE (DEVICE_FPT) ALTRET (BAD_PMME);
          I = 0;
          DO WHILE ((I < NUMBER_NODES) AND (NOT BREAK_FLAG));
               NODE#_TEMP_ = I;
               IF T$ -> B$TREE_NODE.BACK# < 0
               THEN BACK#_TEMP_ = -1;
               ELSE BACK#_TEMP_ = T$ -> B$TREE_NODE.BACK#;
               IF T$ -> B$TREE_NODE.FORWARD# < 0
               THEN FORWARD#_TEMP_ = -1;
               ELSE FORWARD#_TEMP_ = T$ -> B$TREE_NODE.FORWARD#;
               IF T$ -> B$TREE_NODE.OVERLAY# < 0
               THEN OVERLAY#_TEMP_ = -1;
               ELSE OVERLAY#_TEMP_ = T$ -> B$TREE_NODE.OVERLAY#;
               DADDR_TEMP_ = T$ -> B$TREE_NODE.DADDR;
               DATAH_TEMP_ = (T$ -> B$TREE_NODE.DADDR + T$ -> B$TREE_NODE.DSIZE)-1;
               DSIZE_TEMP_ = T$ -> B$TREE_NODE.DSIZE;
               PADDR_TEMP_ = T$ -> B$TREE_NODE.PADDR;
               PROCH_TEMP_ = (T$ -> B$TREE_NODE.PADDR + T$ -> B$TREE_NODE.PSIZE)-1;
               PSIZE_TEMP_ = T$ -> B$TREE_NODE.PSIZE;
               PTR$ = T$ -> B$TREE_NODE.NAME$;
               NAME_ = PINCRW(TREE$, POINTER.LH)->TEXT.STRING;
               CALL X$WRITE (F_FDS, VECTOR(NODE_OUT_),
                 VECTOR(NODE#_TEMP_),
                 VECTOR(BACK#_TEMP_),
                 VECTOR(FORWARD#_TEMP_),
                 VECTOR(OVERLAY#_TEMP_),
                 VECTOR(DADDR_TEMP_),
                 VECTOR(DATAH_TEMP_),
                 VECTOR(DSIZE_TEMP_),
                 VECTOR(PADDR_TEMP_),
                 VECTOR(PROCH_TEMP_),
                 VECTOR(PSIZE_TEMP_),
                 VECTOR(NAME_) );
               T$ = PINCRW(T$, SIZEW(B$TREE_NODE) );
               I = I + 1;
             END;
          CALL M$DEVICE (DEVICE_ERASE_FPT) ALTRET (BAD_PMME);
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
        END;
END LIST_NODES;
%EJECT;
SET_UP_NODE: PROC;
/* SET_UP_NODE - procedure to make sure node specified is valid and set up ptrs correctly. */
     IF NOT GOT_TREE_TABLE
     THEN CALL GET_TREE_TABLE;
     ELSE T$ = PINCRW(TREE$, SIZEW(B$TREE_HEADER));
     IF NOT BAD_FILE
     THEN DO;
          CALL SEARCH_TREE;
          IF NOT FOUND_NODE
          THEN DO;
               MSG_BUF = ' *** Specified node not in overlayed run unit. ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
             END;
        END;
END SET_UP_NODE;
     %EJECT;
SDUMP_DUMP: PROC;
/* SDUMP_DUMP - procedure to dump schema in readable format. */
/* LBLK$ - pointer to beginning of logical block record. */
/* LB$ - pointer incremented through logical block record. */
/* NAME$ - pointer to beginning of debug names pool. */
/* IENT$ - pointer to beginning of internal entries record. */
/* IE$ - pointer incremented through internal entries record. */
/* VAR$ - pointer to beginning of variables record. */
/* V$ - pointer incremented through variables record. */
/* EXST$ - pointer to beginning of executable statements record. */
/* ES$ - pointer incremented through executable statements record. */
DCL TEMP UBIN ALIGNED;
DCL CHECK_SIZE UBIN HALF ALIGNED;
DCL I UBIN ALIGNED;
DCL COMP_TEMP_ UBIN ALIGNED;
DCL VERSION_TEMP_ UBIN ALIGNED;
DCL VERS_TEMP_ UBIN ALIGNED;
DCL 1 OU$VERS BASED ALIGNED,
      2 L CHAR(1),
      2 N UBIN BYTE CALIGNED;
DCL OFFSET_TEMP_ UBIN ALIGNED;
DCL NSIZ_TEMP_ UBIN ALIGNED;
DCL NPSIZ_TEMP_ UBIN ALIGNED;
DCL STSIZ_TEMP_ UBIN ALIGNED;
DCL STPSIZ_TEMP_ UBIN ALIGNED;
DCL VSIZ_TEMP_ UBIN ALIGNED;
DCL VPSIZ_TEMP_ UBIN ALIGNED;
DCL IESIZ_TEMP_ UBIN ALIGNED;
DCL IEPSIZ_TEMP_ UBIN ALIGNED;
DCL STLINE_TEMP_ UBIN ALIGNED;
DCL ENLINE_TEMP_ UBIN ALIGNED;
DCL LEXLVL_TEMP_ UBIN ALIGNED;
DCL STOFFST_TEMP_ UBIN ALIGNED;
DCL VAOFFST_TEMP_ UBIN ALIGNED;
DCL ST_TEMP_ UBIN ALIGNED;
DCL VA_TEMP_ UBIN ALIGNED;
DCL LBE_TEMP_ UBIN ALIGNED;
DCL ISADDR_TEMP_ UBIN ALIGNED;
DCL PRI_TEMP_ UBIN ALIGNED;
DCL ALT_TEMP_ UBIN ALIGNED;
DCL CHECK_TEMP_ UBIN ALIGNED;
DCL CST_TEMP_ UBIN ALIGNED;
DCL NPARAM_TEMP_ UBIN ALIGNED;
DCL LINENUM_TEMP_ UBIN ALIGNED;
DCL COS_TEMP_ UBIN ALIGNED;
DCL LARRAY_ SBIN WORD ALIGNED;
DCL ADRW_TEMP_ UBIN ALIGNED;
DCL ADRC_TEMP_ UBIN ALIGNED;
DCL ADRB_TEMP_ UBIN ALIGNED;
DCL ADDRTYP_TEMP_ UBIN ALIGNED;
DCL DATATYP_TEMP_ UBIN ALIGNED;
DCL REF_TEMP_ UBIN ALIGNED;
DCL MODF_TEMP_ UBIN ALIGNED;
DCL STATUS_TEMP_ UBIN ALIGNED;
DCL LOGSIZ_TEMP_ UBIN ALIGNED;
DCL SZTYP_TEMP_ UBIN ALIGNED;
DCL ARRAYTYP_TEMP_ UBIN ALIGNED;
DCL IMPTR_TEMP_ SBIN WORD ALIGNED;
DCL ELMNTSIZ_TEMP_ UBIN ALIGNED;
DCL SCALE_TEMP_ UBIN ALIGNED;
DCL DIMS_TEMP_ UBIN ALIGNED;
DCL LEVEL_TEMP_ UBIN ALIGNED;
DCL NPOINTER_TEMP_ UBIN ALIGNED;
DCL ELEMENTS_TEMP_ UBIN ALIGNED;
DCL OPNDTYP_TEMP_ UBIN ALIGNED;
DCL MULTIPLIER1_TEMP_ UBIN ALIGNED;
DCL MULTIPLIER2_TEMP_ UBIN ALIGNED;
DCL MULTIPLIER3_TEMP_ UBIN ALIGNED;
DCL MULTIPLIER4_TEMP_ UBIN ALIGNED;
DCL MULTIPLIER5_TEMP_ UBIN ALIGNED;
DCL MULTIPLIER6_TEMP_ UBIN ALIGNED;
DCL HEADERMSG_ BIT(72) STATIC DALIGNED;
%EJECT;
/* Write out headings for logical block entries. */
/* Write out entry 0 of logical block record. */
     CHECK_SIZE = 0;
     IF (LB_SIZE > 0) AND LOGBLK
     THEN DO;
          IF NOT BREAK_FLAG
          THEN DO;
               CALL X$WRITE (F_FDS, VECTOR(LB_HEAD_OUT_) );
               CALL X$WRITE (F_FDS, VECTOR(LB_HEADING1_ ) );
               LB$ = LBLK$;
               TSTAMP_BUF = LB$ -> B$LBNTRY0.UTS;
               CALL M$TIME (TIME_FPT) ALTRET (BAD_PMME);
               COMP_TEMP_ = LB$ -> B$LBNTRY0.COMPILER;
               VERSION_TEMP_ = LB$ -> B$LBNTRY0.VERSION;
               VERS_TEMP_ = ADDR(LB$ -> B$LBNTRY0.VERSION) -> OU$VERS.N;
               OFFSET_TEMP_ = LB$ -> B$LBNTRY0.NO_AUTO.OFFSET;
               IF ASCBIN(ADDR(LB$ -> B$LBNTRY0.VERSION)->OU$VERS.L) < ASCBIN('A')
               THEN DO;
                    IF FEP_RUNUNIT
                    THEN TEMPMSG_ = LB_OUT1_HEX_;
                    ELSE TEMPMSG_ = LB_OUT1_OCT_;
                    CALL X$WRITE (F_FDS, TEMPMSG_,
                      VECTOR(DATE_TIME.TIMEX_),
                      VECTOR(DATE_TIME.DATEX_),
                      VECTOR(DATE_TIME.DAYX_),
                      VECTOR(COMP_ID (COMP_TEMP_) ),
                      VECTOR(VERSION_TEMP_),
                      VECTOR(OFFSET_TEMP_) );
                  END;
               ELSE DO;
                    IF FEP_RUNUNIT
                    THEN DO;
                         LB_OUT_T1_ = VECTOR(LB_OUT_HEX1);
                         LB_OUT_T2_ = VECTOR(LB_OUT_HEX2);
                       END;
                    ELSE DO;
                         LB_OUT_T1_ = VECTOR(LB_OUT_OCT1);
                         LB_OUT_T2_ = VECTOR(LB_OUT_OCT2);
                       END;
                    IF VERS_TEMP_ < 100
                    THEN TEMPMSG_ = LB_OUT_T1_;
                    ELSE TEMPMSG_ = LB_OUT_T2_;
                    CALL X$WRITE (F_FDS, TEMPMSG_,
                      VECTOR(DATE_TIME.TIMEX_),
                      VECTOR(DATE_TIME.DATEX_),
                      VECTOR(DATE_TIME.DAYX_),
                      VECTOR(COMP_ID (COMP_TEMP_) ),
                      VECTOR(ADDR(LB$ -> B$LBNTRY0.VERSION)-> OU$VERS.L),
                      VECTOR(VERS_TEMP_),
                      VECTOR(OFFSET_TEMP_) );
                  END;
               CALL X$WRITE (F_FDS, VECTOR(BLANK_LINE_) );
                              /* Write out entry 1 of logical block record. */
               CALL X$WRITE (F_FDS, VECTOR(LB_HEADING2_) );
               LB$ = PINCRW(LB$, SIZEW(B$LBNTRY0) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$LBNTRY0);
               NSIZ_TEMP_ = LB$ -> B$LBNTRY1.NAMESIZ;
               NPSIZ_TEMP_ = LB$ -> B$LBNTRY1.NAMPSIZ;
               STSIZ_TEMP_ = LB$ -> B$LBNTRY1.STMNTSIZ;
               STPSIZ_TEMP_ = LB$ -> B$LBNTRY1.STMNTPSIZ;
               VSIZ_TEMP_ = LB$ -> B$LBNTRY1.VREBLSIZ;
               VPSIZ_TEMP_ = LB$ -> B$LBNTRY1.VREBLPSIZ;
               IESIZ_TEMP_ = LB$ -> B$LBNTRY1.INTRYSIZ;
               IEPSIZ_TEMP_ = LB$ -> B$LBNTRY1.INTRYPSIZ;
               IF FEP_RUNUNIT
               THEN TEMPMSG_ = LB_OUT2_HEX_;
               ELSE TEMPMSG_ = LB_OUT2_OCT_;
               CALL X$WRITE (F_FDS, TEMPMSG_,
                 VECTOR(NSIZ_TEMP_),
                 VECTOR(NPSIZ_TEMP_),
                 VECTOR(STSIZ_TEMP_),
                 VECTOR(STPSIZ_TEMP_),
                 VECTOR(VSIZ_TEMP_),
                 VECTOR(VPSIZ_TEMP_),
                 VECTOR(IESIZ_TEMP_),
                 VECTOR(IEPSIZ_TEMP_) );
               CALL X$WRITE (F_FDS, VECTOR(BLANK_LINE_) );
                    /* Write out all other entries of logical block record. */
               CALL X$WRITE (F_FDS, VECTOR(LB_HEADING3_) );
               LB$ = PINCRW(LB$, SIZEW(B$LBNTRY1) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$LBNTRY1);
               I = 0;
             END;
          DO WHILE ((CHECK_SIZE < LB_SIZE) AND (NOT BREAK_FLAG)) ;
               STOFFST_TEMP_ = LB$ -> B$LOGBLK.STOFFST / SIZEW(B$EXST);
               VAOFFST_TEMP_ = LB$ -> B$LOGBLK.VAOFFST / SIZEW(B$VREBL);
               ST_TEMP_ = STOFFST_TEMP_ + LB$ -> B$LOGBLK.STSIZE - 1;
               VA_TEMP_ = VAOFFST_TEMP_ + LB$ -> B$LOGBLK.VASIZE - 1;
               IF LB$ -> B$LOGBLK.NPOINTER > NAME_SIZE
               THEN DO;
                    NPOINTER_TEMP_ = LB$ -> B$LOGBLK.NPOINTER;
                    CALL X$WRITE (F_FDS, VECTOR(BAD_NAME_POINTER_),
                      VECTOR(NPOINTER_TEMP_) );
                    NAME_ = '     ';
                    GOTO OUTLB;
                  END;
               IF LB$ -> B$LOGBLK.NPOINTER < 0
               THEN NAME_ = '     ';
               ELSE NAME_ = PINCRW(NAME$, LB$ -> B$LOGBLK.NPOINTER) -> B$DNAME.TEXT;
OUTLB:         ;
               STLINE_TEMP_ = LB$ -> B$LOGBLK.STLINE;
               ENLINE_TEMP_ = LB$ -> B$LOGBLK.ENLINE;
               LEXLVL_TEMP_ = LB$ -> B$LOGBLK.LEXLVL;
               CALL X$WRITE (F_FDS, VECTOR(LB_OUT3_),
                 VECTOR(I),
                 VECTOR(STLINE_TEMP_),
                 VECTOR(ENLINE_TEMP_),
                 VECTOR(LEXLVL_TEMP_),
                 VECTOR(STOFFST_TEMP_),
                 VECTOR(ST_TEMP_),
                 VECTOR(VAOFFST_TEMP_),
                 VECTOR(VA_TEMP_),
                 VECTOR(NAME_) );
               LB$ = PINCRW(LB$, SIZEW(B$LOGBLK) );
               I = I + 1;
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$LOGBLK);
             END;
          CHECK_SIZE = 0;
        END;
%EJECT;
/* Write out internal entries record entries. */
     IF (IE_SIZE > 0) AND INTENT AND (NOT BREAK_FLAG)
     THEN DO;
          CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(IE_HEAD_OUT_) );
          IF FEP_RUNUNIT
          THEN DO;
               VLP_HDR.TITL = IE_PGHDR_HEX;
               TEMPMSG_ = IE_HEADING_HEX_;
             END;
          ELSE DO;
               TEMPMSG_ = IE_HEADING_OCT_;
               VLP_HDR.TITL = IE_PGHDR_OCT;
             END;
          CALL X$WRITE (F_FDS, TEMPMSG_ );
          CALL M$DEVICE (DEVICE_FPT) ALTRET (BAD_PMME);
          IE$ = IENT$;
          DO WHILE ((CHECK_SIZE < IE_SIZE) AND (NOT BREAK_FLAG)) ;
               IF IE$ -> B$INTNTRY.NPOINTER > NAME_SIZE
               THEN DO;
                    NPOINTER_TEMP_ = IE$ -> B$INTNTRY.NPOINTER;
                    CALL X$WRITE (F_FDS, VECTOR(BAD_NAME_POINTER_),
                      VECTOR(NPOINTER_TEMP_) );
                    NAME_ = '     ';
                    GOTO OUTIEO;
                  END;
               IF IE$ -> B$INTNTRY.NPOINTER < 0
               THEN NAME_ = '     ';
               ELSE NAME_ = PINCRW(NAME$, IE$ -> B$INTNTRY.NPOINTER) -> B$DNAME.TEXT;
OUTIEO:        ;
               LBE_TEMP_ = IE$ -> B$INTNTRY.LBE;
               ISADDR_TEMP_ = IE$ -> B$INTNTRY.ISADDR;
               PRI_TEMP_ = BITBIN(IE$ -> B$INTNTRY.PRI);
               ALT_TEMP_ = BITBIN(IE$ -> B$INTNTRY.ALT);
               CHECK_TEMP_ = BITBIN(IE$ -> B$INTNTRY.CHECK);
               CST_TEMP_ = IE$ -> B$INTNTRY.CST;
               NPARAM_TEMP_ = IE$ -> B$INTNTRY.NPARAM;
               IF FEP_RUNUNIT
               THEN TEMPMSG_ = IE_OUT_HEX_;
               ELSE TEMPMSG_ = IE_OUT_OCT_;
               CALL X$WRITE (F_FDS, TEMPMSG_,
                 VECTOR(LBE_TEMP_),
                 VECTOR(ISADDR_TEMP_),
                 VECTOR(PRI_TEMP_),
                 VECTOR(ALT_TEMP_),
                 VECTOR(CHECK_TEMP_),
                 VECTOR(CST_TEMP_),
                 VECTOR(NPARAM_TEMP_),
                 VECTOR(NAME_) );
               IE$ = PINCRW(IE$, SIZEW(B$INTNTRY) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$INTNTRY);
             END;
          CHECK_SIZE = 0;
          CALL M$DEVICE (DEVICE_ERASE_FPT) ALTRET (BAD_PMME);
        END;
%EJECT;
/* Write out executable statements record entries. */
     IF (ES_SIZE > 0) AND EXECSTMT AND (NOT BREAK_FLAG)
     THEN DO;
          CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(ES_HEAD_OUT_) );
          IF FEP_RUNUNIT
          THEN DO;
               TEMPMSG_ = ES_HEADING_HEX_;
               VLP_HDR.TITL = ES_PGHDR_HEX;
             END;
          ELSE DO;
               TEMPMSG_ = ES_HEADING_OCT_;
               VLP_HDR.TITL = ES_PGHDR_OCT;
             END;
          CALL X$WRITE (F_FDS, TEMPMSG_ );
          CALL M$DEVICE (DEVICE_FPT) ALTRET (BAD_PMME);
          ES$ = EXST$;
          I = 0;
          DO WHILE ((CHECK_SIZE < ES_SIZE) AND (NOT BREAK_FLAG)) ;
               TEMP = ES$ -> B$EXST.STTYPE;
               IF TEMP > %HIGH_ST_TYPE
               THEN ST_TYPE_ = 'UNKNOWN';
               ELSE ST_TYPE_ = ST_TEXT(TEMP);
               IF ES$ -> B$EXST.NPOINTER > NAME_SIZE
               THEN DO;
                    NPOINTER_TEMP_ = ES$ -> B$EXST.NPOINTER;
                    CALL X$WRITE (F_FDS, VECTOR(BAD_NAME_POINTER_),
                      VECTOR(NPOINTER_TEMP_) );
                    NAME_ = '     ';
                    GOTO OUTESO;
                  END;
               IF ES$ -> B$EXST.NPOINTER < 0
               THEN NAME_ = '     ';
               ELSE NAME_ = PINCRW(NAME$, ES$ -> B$EXST.NPOINTER) -> B$DNAME.TEXT;
OUTESO:        ;
               ISADDR_TEMP_ = ES$ -> B$EXST.ISADDR;
               LINENUM_TEMP_ = ES$ -> B$EXST.LINENUM;
               LBE_TEMP_ = ES$ -> B$EXST.LBE;
               COS_TEMP_ = BITBIN(ES$ -> B$EXST.COS);
               IF ES$ -> B$EXST.LA
               THEN LARRAY_ = ES$ -> B$EXST.SUBSCRIPT;
               ELSE LARRAY_ = -1;
               IF FEP_RUNUNIT
               THEN TEMPMSG_ = ES_OUT_HEX_;
               ELSE TEMPMSG_ = ES_OUT_OCT_;
               CALL X$WRITE (F_FDS, TEMPMSG_,
                 VECTOR(I),
                 VECTOR(ISADDR_TEMP_),
                 VECTOR(LINENUM_TEMP_),
                 VECTOR(LBE_TEMP_),
                 VECTOR(LARRAY_),
                 VECTOR(COS_TEMP_),
                 VECTOR(ST_TYPE_),
                 VECTOR(NAME_) );
               ES$ = PINCRW(ES$, SIZEW(B$EXST) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$EXST);
               I = I+ 1;
             END;
          CHECK_SIZE = 0;
          CALL M$DEVICE (DEVICE_ERASE_FPT) ALTRET (BAD_PMME);
        END;
%EJECT;
/* Write out variables record entries. */
     IF (VAR_SIZE > 0) AND VARS AND (NOT BREAK_FLAG)
     THEN DO;
          CALL X$WRITE (F_FDS, VECTOR(TOP_OF_PAGE_) );
          CALL X$WRITE (F_FDS, VECTOR(VAR_HEAD_OUT_) );
          IF FEP_RUNUNIT
          THEN DO;
               TEMPMSG_ = VAR_HEADING_HEX_;
               VLP_HDR.TITL = VAR_PGHDR_HEX;
             END;
          ELSE DO;
               TEMPMSG_ = VAR_HEADING_OCT_;
               VLP_HDR.TITL = VAR_PGHDR_OCT;
             END;
          CALL X$WRITE (F_FDS, TEMPMSG_ );
          CALL M$DEVICE (DEVICE_FPT) ALTRET (BAD_PMME);
          HEADERMSG_ = TEMPMSG_;
          IF FEP_RUNUNIT
          THEN DO;
               HEX = '1'B;
               IF ~RUNUNIT THEN FEP_RUNUNIT = '0'B;
             END;
          ELSE HEX = '0'B;
          V$ = VAR$;
          I = 0;
          DO WHILE ((CHECK_SIZE < VAR_SIZE) AND (NOT BREAK_FLAG)) ;
               IF V$ -> B$VREBL.ADDRTYP = 0 OR
                 V$ -> B$VREBL.DATATYP = %VIRTUAL_ARRAY_DATATYPE OR
                 V$ -> B$VREBL.DATATYP = %REAL_ARRAY_DATATYPE
               THEN GOTO NEXT_VAR;
               IF V$ -> B$VREBL.NPOINTER > NAME_SIZE
               THEN DO;
                    NPOINTER_TEMP_ = V$ -> B$VREBL.NPOINTER;
                    CALL X$WRITE (F_FDS, VECTOR(BAD_NAME_POINTER_),
                      VECTOR(NPOINTER_TEMP_) );
                    NAME_ = '     ';
                    GOTO OUTVARO;
                  END;
               IF V$ -> B$VREBL.NPOINTER < 0
               THEN NAME_ = '     ';
               ELSE NAME_ = PINCRW(NAME$, V$ -> B$VREBL.NPOINTER) -> B$DNAME.TEXT;
OUTVARO:       ;
               IF FEP_RUNUNIT
               THEN DO;
                    ADRW_TEMP_ = V$ -> B$VREBL.ADR6.W;
                    ADRC_TEMP_ = V$ -> B$VREBL.ADR6.C;
                    ADRB_TEMP_ = V$ -> B$VREBL.ADR6.B;
                  END;
               ELSE DO;
                    ADRW_TEMP_ = V$ -> B$VREBL.ADR.W;
                    ADRC_TEMP_ = V$ -> B$VREBL.ADR.C;
                    ADRB_TEMP_ = V$ -> B$VREBL.ADR.B;
                  END;
               ADDRTYP_TEMP_ = V$ -> B$VREBL.ADDRTYP;
               DATATYP_TEMP_ = V$ -> B$VREBL.DATATYP;
               REF_TEMP_ = BITBIN(V$ -> B$VREBL.REF);
               MODF_TEMP_ = BITBIN(V$ -> B$VREBL.MODF);
               STATUS_TEMP_ = BITBIN(V$ -> B$VREBL.STATUS_EXISTS);
               LOGSIZ_TEMP_ = V$ -> B$VREBL.LOGSIZ;
               SZTYP_TEMP_ = BITBIN(V$ -> B$VREBL.SZTYP);
               ARRAYTYP_TEMP_ = V$ -> B$VREBL.ARRAYTYP;
               IMPTR_TEMP_ = V$ -> B$VREBL.IMPTR;
               ELMNTSIZ_TEMP_ = V$ -> B$VREBL.ELMNTSIZ;
               SCALE_TEMP_ = V$ -> B$VREBL.SCALE;
               DIMS_TEMP_ = V$ -> B$VREBL.DIMS;
               LEVEL_TEMP_ = V$ -> B$VREBL.LEVEL;
               IF HEX
               THEN TEMPMSG_ = VAR_OUT_HEX_;
               ELSE TEMPMSG_ = VAR_OUT_OCT_;
               IF ADDRTYP_TEMP_ = 8     /* Areadef */
               THEN DO;
                    TEMPMSG_ = VAR_OUT1_OCT_;
                    ADRW_TEMP_ = ADRW_TEMP_ + IMPTR_TEMP_;
                    IMPTR_TEMP_ = V$ -> B$VREBL.OPERAND - 3072;
                  END;
               ELSE IF ADDRTYP_TEMP_ = 7 /* Static parameter */
                    THEN IF NOT HEX
                         THEN TEMPMSG_ = VAR_OUT2_OCT_;
                         ELSE TEMPMSG_ = VAR_OUT2_HEX_;
                    ELSE IF IMPTR_TEMP_ < 0
                         THEN IMPTR_TEMP_ = -1;
               CALL X$WRITE (F_FDS, TEMPMSG_,
                 VECTOR(I),
                 VECTOR(ADRW_TEMP_),
                 VECTOR(ADRC_TEMP_),
                 VECTOR(ADRB_TEMP_),
                 VECTOR(ADR_TYPE_(ADDRTYP_TEMP_) ),
                 VECTOR(DATA_TYPE_(DATATYP_TEMP_) ),
                 VECTOR(REF_TEMP_),
                 VECTOR(MODF_TEMP_),
                 VECTOR(STATUS_TEMP_),
                 VECTOR(LOGSIZ_TEMP_),
                 VECTOR(SZTYP_TEMP_),
                 VECTOR(ARRAY_TYPE_(ARRAYTYP_TEMP_) ),
                 VECTOR(IMPTR_TEMP_),
                 VECTOR(ELMNTSIZ_TEMP_),
                 VECTOR(SCALE_TEMP_),
                 VECTOR(DIMS_TEMP_),
                 VECTOR(LEVEL_TEMP_),
                 VECTOR(NAME_) );
               IF ARRAYTYP_TEMP_ = 3
               THEN DO;
                    V$ = PINCRW(V$,SIZEW(B$VREBL));
                    CHECK_SIZE = CHECK_SIZE + SIZEW(B$VREBL);
                    OFFSET_TEMP_ = V$ -> B$VREBLC.OFFSET;
                    DATATYP_TEMP_ = V$ -> B$VREBLC.DATATYP;
                    ELEMENTS_TEMP_ = V$ -> B$VREBLC.ELEMENTS;
                    OPNDTYP_TEMP_ = V$ -> B$VREBLC.OPNDTYP;
                    MULTIPLIER1_TEMP_ = V$ -> B$VREBLC.MULT_62(0);
                    MULTIPLIER2_TEMP_ = V$ -> B$VREBLC.MULT_62(1);
                    MULTIPLIER3_TEMP_ = V$ -> B$VREBLC.MULT_62(2);
                    MULTIPLIER4_TEMP_ = V$ -> B$VREBLC.MULT_62(3);
                    MULTIPLIER5_TEMP_ = V$ -> B$VREBLC.MULT_62(4);
                    MULTIPLIER6_TEMP_ = V$ -> B$VREBLC.MULT_62(5);
                    TEMPMSG_ = ARR_HEADING_;
                    CALL X$WRITE(F_FDS,TEMPMSG_);
                    TEMPMSG_ = ARR_OUT_;
 
                    CALL X$WRITE(F_FDS,TEMPMSG_,
                      VECTOR(OFFSET_TEMP_),
                      VECTOR(DATA_TYPE_(DATATYP_TEMP_)),
                      VECTOR(ELEMENTS_TEMP_),
                      VECTOR(MULTIPLIER1_TEMP_),
                      VECTOR(MULTIPLIER2_TEMP_),
                      VECTOR(MULTIPLIER3_TEMP_),
                      VECTOR(MULTIPLIER4_TEMP_),
                      VECTOR(MULTIPLIER5_TEMP_),
                      VECTOR(MULTIPLIER6_TEMP_));
                    CALL X$WRITE (F_FDS, HEADERMSG_);
                  END;
NEXT_VAR:
               V$ = PINCRW(V$, SIZEW(B$VREBL) );
               CHECK_SIZE = CHECK_SIZE + SIZEW(B$VREBL);
               I = I + 1;
             END;
          CALL M$DEVICE (DEVICE_ERASE_FPT) ALTRET (BAD_PMME);
        END;
     DO WHILE ('0'B);
BAD_PMME: ;
          CALL ERROR;
        END;
END SDUMP_DUMP;
%EJECT;
OUTPUT_FILE_INFO: PROC;
/* OUTPUT_FILE_INFO - procedure to output informaton on specified file. */
DCL FILE_TYPE CHAR(2) STATIC INIT('  ');
/* Get last time modified and creation time and convert to chars. */
     CODE04$ = FP$;
     CODE = 4;
     CALL XSF$LOCCODE (CODE04$, CODE) ALTRET (CODE04_ERR);
     CODE04_TIME = CODE04$ -> CODE04.MODIFY.TIME;
     DO WHILE ('0'B);
CODE04_ERR: ;
          CODE04_TIME = 0;
        END ;
     TSTAMP_BUF = CODE04_TIME;
     CALL M$TIME (TIME_FPT) ALTRET (BAD_PMME);
     CODE04_TIME = CODE04$ -> CODE04.CREATION.TIME;
     TSTAMP_BUF = CODE04_TIME;
     CALL M$TIME (FPT_TIME) ALTRET (BAD_PMME);
                              /* Get file type so can see if 16-bit run unit.
                                 If so, output values in hex.                 */
     CODE03$ = FP$;
     CODE = 3;
     CALL XSF$LOCCODE (CODE03$, CODE) ALTRET (CODE03_ERR);
     FILE_TYPE = CODE03$ -> CODE03.TYPE;
     DO WHILE ('0'B);
CODE03_ERR: ;
          FILE_TYPE = '  ';
        END;
     IF FILE_TYPE = 'Rf'
     THEN FEP_RUNUNIT = '1'B;
     ELSE FEP_RUNUNIT = '0'B;
/* Write out file name, account, and last modified time and date,
   and creation date and time.                                     */
     CALL X$WRITE (F_FDS, VECTOR(FILE_OUT_MSG_),
       VECTOR(FID_BUFFER),
       VECTOR(DATE_TIME.TIMEX_),
       VECTOR(DATE_TIME.DATEX_),
       VECTOR(DATE_TIME.DAYX_),
       VECTOR(CDATE_TIME.TIMEX_),
       VECTOR(CDATE_TIME.DATEX_),
       VECTOR(CDATE_TIME.DAYX_) );
     ALLOU = '1'B;
     LEMUR = '0'B;
     LIB_BIT = '0'B;
                                   /* Determine if object unit or run unit */
     READ_FPT.V.KEYR# = '1'B;
     READ_FPT.V.KEYS# = '0'B;
     READ_FPT.KEY_ = VECTOR(KEY_BUF);
                              /* Make sure positioned at beginning of file. */
     IF OPENFLAG
     THEN CALL M$CLOSE (CLOSESI_FPT) ALTRET (BAD_PMME);
     IF FILE_FROM_JIT
     THEN CALL M$OPEN (OPENFPT) ALTRET (BAD_PMME);
     ELSE CALL M$OPEN (OPEN_FPT) ALTRET (BAD_PMME);
     CALL M$READ (READ_FPT) ALTRET (BAD_READ1);
CHECK: ;
     IF SUBSTR(KEY_BUF.KEY, 0, 1) = '"'
     THEN RUNUNIT = '0'B;
     ELSE IF SUBSTR(KEY_BUF.KEY, 0, 1) = '!'
          THEN DO;
               CALL M$READ (READ_FPT) ALTRET (BAD_READ1);
               RUNUNIT = '0'B;
               LEMUR = '1'B;
             END;
          ELSE DO;
               RUNUNIT = '1'B;
     /* Read head record of run unit to get sizes of defnames and entdefs. */
               READ_FPT.KEY_ = VECTOR(HEADKEY);
               READ_FPT.V.KEYS# = '1'B;
               READ_FPT.V.KEYR# = '0'B;
               CALL M$READ (READ_FPT) ALTRET (BAD_READ);
               HEAD$ = ADDR(HEAD_BUF);
               DEFNAME_SIZE = HEAD$ -> B$HEAD.NRECSIZE;
               ENTDEF_SIZE = HEAD$ -> B$HEAD.EPRECSIZE;
               ROSEG_SIZE = HEAD$ -> B$HEAD.ROSIZE;
               TREE_DISP = HEAD$ -> B$HEAD.TREEDISP;
               MAX_PRECSIZE = HEAD$ -> B$HEAD.PRECSIZE;
               OVRL_BIT = HEAD$ -> B$HEAD.OVRL;
               LIB_BIT = HEAD$ -> B$HEAD.LIB;
             END;
     DO WHILE ('0'B);
BAD_READ1: ;
          IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$LD
          THEN GOTO CHECK;
          CALL ERROR;
          GOTO DONE;
BAD_READ: ;
          IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$NOKEY
          THEN DO;
               MSG_BUF = ' *** File specified is not an object unit or run unit ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
               BAD_FILE = '1'B;
               IF OPENFLAG
               THEN DO;
                    CALL M$CLOSE (CLOSESI_FPT) ALTRET (BAD_PMME);
                    OPENFLAG = '0'B;
                  END;
               GOTO DONE;
             END;
          CALL ERROR;
          GOTO DONE;
BAD_PMME: ;
          CALL ERROR;
        END;
DONE: ;
END  OUTPUT_FILE_INFO;
%EJECT;
ERROR: PROC;
 
     ERRMSG_FPT.V.DCB# = B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
     ERR_CODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
     GOTO ERRORGO;
 
ERROR1: ENTRY;
     ERRMSG_FPT.V.DCB# = 0;
ERRORGO: ;
     ERR_CODE.SEV = 0;
     CALL M$ERRMSG (ERRMSG_FPT);
 
     RETURN;
 
END ERROR;
%EJECT;
/* Main program. */
/* Initialization. */
     NODE_ = ' ';
     GOT_TREE_TABLE = '0'B;
/* See if M$LO and M$DO are the same. */
     CALL M$CORRES (CORRES_FPT) ALTRET (DCB_SAME);
     LO_DO_SAME = '0'B;
     DO WHILE ('0'B);
DCB_SAME: ;
          LO_DO_SAME = '1'B;
        END;
/* Set up break routine. */
     CALL M$INT (INT_FPT);
/* Set up dcb's for XUR$GETCMD. M$ME - input, M$LO - output. */
     CALL XUR$SETDCBS (DCBNUM(M$ME), DCBNUM(M$LO) );
/*Open M$ME file. */
     CALL M$OPEN (OPENME_FPT) ALTRET (BAD_PMME);
     M$ME$ = DCBADDR( DCBNUM (M$ME) );
/* See if anything in ccbuf */
     IF B$JIT.CCDISP < B$JIT.CCARS
     THEN DO;
          FILE_FROM_JIT = '1'B;
          CONTINUE = '0'B;
                                        /* Open M$SI file. */
          CALL M$OPEN (OPENFPT) ALTRET (BAD_PMME_CONTINUE);
          OPENFLAG = '1'B;
          CALL M$UNFID (UNFID_FPT) ALTRET (BAD_PMME_CONTINUE);
          M$SI$ = DCBADDR( DCBNUM (M$SI) );
          IF M$SI$ -> F$DCB.ORG# ~= %KEYED#
          THEN GOTO BAD_FILE;
                                        /* Output file information. */
          CALL OUTPUT_FILE_INFO;
          IF RUNUNIT
          THEN CALL SET_UP_OU;
                                        /* Something present in ccbuf. */
                                        /* Get rid of '(' */
          CMDSIZE = B$JIT.CCARS - B$JIT.CCDISP - 1;
          IF SUBSTR(B$JIT.CCBUF,B$JIT.CCARS-1,1) = ')'
                                        /* Get rid of ')' */
          THEN CMDSIZE = CMDSIZE - 1;
          IF CMDSIZE = 0
          THEN DO;
               LOGBLK = '1'B;
               EXECSTMT = '1'B;
               INTENT = '1'B;
               VARS = '1'B;
               ALLOU = '1'B;
               ENDFLAG = '1'B;
               GOTO CHECK;
             END;
          CALL XUR$GETCMD(SDUMP_ROOT,CMD$,PROMPT_,
            SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1),CMDSIZE)
            ALTRET (BAD_GETCMD2);
          GOTO COMMAND_GO;
        END;
     CONTINUE = '1'B;
     IF B$JIT.PRFLAGS.SI
     THEN DO;
          FILE_FROM_JIT = '1'B;
                                        /* Open M$SI file. */
          CALL M$OPEN (OPENFPT) ALTRET (BAD_PMME_CONTINUE);
          OPENFLAG = '1'B;
          CALL M$UNFID (UNFID_FPT) ALTRET (BAD_PMME_CONTINUE);
          M$SI$ = DCBADDR( DCBNUM (M$SI) );
          IF M$SI$ -> F$DCB.ORG# ~= %KEYED#
          THEN GOTO BAD_FILE;
                                        /* Output file information. */
          CALL OUTPUT_FILE_INFO;
          IF RUNUNIT
          THEN CALL SET_UP_OU;
        END;
GET_COMMAND: ;
     BREAK_FLAG = '0'B;
     CALL XUR$GETCMD(SDUMP_ROOT,CMD$,PROMPT_) ALTRET (BAD_GETCMD1);
COMMAND_GO: ;
     CMDNUM = CMD$ -> OUT$BLK.NSUBLKS - 1;
     DO I = 0 TO CMDNUM;
          OUT$ = CMD$ -> OUT$BLK.SUBLK$(I);
          DO CASE (OUT$ -> OUT$BLK.CODE);
            CASE (%FILE@);
               NODE_ = ' ';
               IF GOT_TREE_TABLE
               THEN DO;
                                        /* Free space from roseg */
                    FDS_FPT.V.SEGSIZE# = ROSEG_BUFFER_SIZE;
                    FREE_SEG.PTR$ = ROSEG$;
                    CALL M$FDS (FDS_FPT) ALTRET(BAD_PMME_CONTINUE);
                    GOT_TREE_TABLE = '0'B;
                  END;
               IF GOTDEFS
               THEN DO;
                                        /* Free space from defs */
                    FDS_FPT.V.SEGSIZE# = DEFNAME_SIZE + ENTDEF_SIZE;
                    FREE_SEG.PTR$ = DEFN$;
                    CALL M$FDS (FDS_FPT) ALTRET(BAD_PMME_CONTINUE);
                    GOTDEFS = '0'B;
                  END;
               FILE_FROM_JIT = '0'B;
               IF OPENFLAG
               THEN DO;
                    CALL M$CLOSE (CLOSESI_FPT) ALTRET (BAD_PMME);
                    OPENFLAG = '0'B;
                  END;
               FID_BUFFER = OUT$ -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXTC$ -> TEXT.STRING;
               CALL M$FID (FID_FPT) ALTRET (BAD_PMME_CONTINUE);
               IF (FID_RESULTS.SN) OR (FID_RESULTS.WSN)
               THEN DO;
                    MSG_BUF = '*** Bad FID. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                    GOTO GET_COMMAND;
                  END;
                                        /* Open M$SI file */
               CALL M$OPEN (OPEN_FPT) ALTRET (BAD_PMME_CONTINUE);
               OPENFLAG = '1'B;
               ALLOU = '1'B;
               M$SI$ = DCBADDR (DCBNUM (M$SI) );
               IF M$SI$ -> F$DCB.ORG# ~= %KEYED#
               THEN GOTO BAD_FILE;
                                        /* Output file information. */
               CALL OUTPUT_FILE_INFO;
               IF RUNUNIT
               THEN CALL SET_UP_OU;
               GOTO NEXT_COMMAND;
                                        /* Listnodes option. */
            CASE (%LISTNODES@);
               IF RUNUNIT
               THEN DO;
                    IF OVRL_BIT
                    THEN CALL LIST_NODES;
                    ELSE DO;
                         MSG_BUF = ' *** Cannot list nodes for nonoverlayed run unit. ***';
                         CALL M$WRITE (WRITE_FPT);
                         IF NOT LO_DO_SAME
                         THEN CALL M$WRITE (WRITEDO_FPT);
                       END;
                  END;
               ELSE DO;
                    MSG_BUF = ' *** Cannot list nodes for an object unit or lemur library. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                  END;
               GOTO NEXT_COMMAND;
                                   /* Display option - display schema parts. */
            CASE (%DISPLAY@);
               CMDNUM1 = OUT$ -> OUT$BLK.NSUBLKS - 1;
               DO II = 0 TO CMDNUM1;
                    DO CASE (OUT$ -> OUT$BLK.SUBLK$(II) -> OUT$BLK.CODE);
                      CASE (%DLOGBLK@);
                         LOGBLK = '1'B;
                      CASE (%DEXECSTMT@);
                         EXECSTMT = '1'B;
                      CASE (%DINTENT@);
                         INTENT = '1'B;
                      CASE (%DVARS@);
                         VARS = '1'B;
                      CASE (%DALL@);
                         LOGBLK = '1'B;
                         EXECSTMT = '1'B;
                         INTENT = '1'B;
                         VARS = '1'B;
                      END;
                  END;
                                   /* Select option - select ou within file. */
            CASE (%SELECT@);
               DO CASE (OUT$ -> OUT$BLK.SUBLK$(0) -> OUT$BLK.CODE);
                 CASE (%SALLOU@);
                    ALLOU = '1'B;
                    IF RUNUNIT
                    THEN CALL SET_UP_OU;
                    GOTO NEXT_COMMAND;
                 CASE (%SOU@);
                    ALLOU = '0'B;
                    OU_NAME_ = OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
                    CALL SET_UP_OU;
                    GOTO NEXT_COMMAND;
                 END;
               /*Usingnode option - select node within overlayed rununit. */
            CASE (%USINGNODE@);
               NODE_ = OUT$ -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
               IF RUNUNIT
               THEN DO;
                    IF OVRL_BIT
                    THEN CALL SET_UP_NODE;
                    ELSE DO;
                         MSG_BUF = ' *** Use Node command not legal for nonoverlayed run unit. ***';
                         CALL M$WRITE (WRITE_FPT);
                         IF NOT LO_DO_SAME
                         THEN CALL M$WRITE (WRITEDO_FPT);
                       END;
                  END;
               ELSE DO;
                    MSG_BUF = ' *** Use Node command not legal for an object unit or lemur library. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                  END;
               GOTO NEXT_COMMAND;
                                        /* For ru only - list all entdefs */
            CASE (%LISTALL@);
               IF RUNUNIT
               THEN DO;
                    ALL_ENTDEFS = '1'B;
                    LIST = '1'B;
                  END;
               ELSE DO;
                    IF NOT OPENFLAG
                    THEN GOTO NOFILE;
                    MSG_BUF = ' *** Command not valid for object unit or lemur library. ***';
                    CALL M$WRITE (WRITE_FPT);
                    IF NOT LO_DO_SAME
                    THEN CALL M$WRITE (WRITEDO_FPT);
                    GOTO NEXT_COMMAND;
                  END;
                              /* List option - list ou's for object unit and
                                 primary entdefs for rununit.                */
            CASE (%LIST@);
               ALL_ENTDEFS = '0'B;
               LIST = '1'B;
                                        /* End option - get out. */
            CASE (%END@);
               ENDFLAG = '1'B;
                                   /* Nullcmd - ignore, get another command. */
            CASE (%NULLCMD@);
               GOTO GET_COMMAND;
            END;
          IF ENDFLAG
          THEN GOTO QUIT;
CHECK:    ;
          IF NOT OPENFLAG
          THEN DO;
NOFILE:        MSG_BUF = ' *** No file specified. ***';
               CALL M$WRITE (WRITE_FPT);
               IF NOT LO_DO_SAME
               THEN CALL M$WRITE (WRITEDO_FPT);
               GOTO GET_COMMAND;
             END;
          IF OPENFLAG
          THEN DO;
               KEY_BUF = %CONCAT('001'O,ASCBIT('"'));
               CALL M$PRECORD (PRECORD_FPT) ALTRET (BAD_PMME);
               CALL M$READ (READ_FPT) ALTRET (BAD_READ1);
             END;
OKAY:     ;
          IF RUNUNIT
                                        /* Ru file */
          THEN DO;
               IF LIST
               THEN CALL LIST_RU;
               ELSE CALL SDUMP_RUN;
             END;
                                        /* Ou file */
          ELSE DO;
               IF LIST
               THEN CALL LIST_OU;
               ELSE CALL SDUMP_OBJECT;
             END;
NEXT_COMMAND: ;
          IF BAD_FILE
          THEN DO;
               BAD_FILE = '0'B;
               GOTO GET_COMMAND;
             END;
          IF ENDFLAG
          THEN GOTO QUIT;
          LOGBLK = '0'B;
          EXECSTMT = '0'B;
          INTENT = '0'B;
          VARS = '0'B;
          ALL_ENTDEFS = '0'B;
          LIST = '0'B;
          ENDFLAG = '0'B;
        END;
     IF CONTINUE
     THEN GOTO GET_COMMAND;
/* Close dcb's */
QUIT: ;
     IF OPENFLAG
     THEN CALL M$CLOSE (CLOSESI_FPT) ALTRET (BAD_PMME);
     CALL M$CLOSE (CLOSELO_FPT) ALTRET (BAD_PMME);
     CALL M$CLOSE (CLOSEME_FPT) ALTRET (BAD_PMME);
     DO WHILE ('0'B);
BAD_READ1: ;
          IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.ERR# = %E$LD
          THEN GOTO OKAY;
          CALL ERROR;
          GOTO DONE;
BAD_GETCMD1: ;
          FROMJIT = '0'B;
          DO WHILE ('0'B);
BAD_GETCMD2:   ;
               FROMJIT = '1'B;
             END;
          ERR_CODE = XERRCODE;
          IF ERR_CODE.MON
          THEN IF ERR_CODE.ERR# = %E$EOF
               THEN GOTO QUIT;
               ELSE CALL ERROR;
          ELSE IF ERR_CODE.ERR# = %E$SYNERR
               THEN DO;
                    IF FROMJIT
                    THEN CALL XUR$ECHO(DCBNUM(M$LO));
                    IF NOT LO_DO_SAME
                    THEN DO;
                         CALL XUR$ECHO(DCBNUM(M$DO));
                         CALL XUR$ERRPTR(,DCBNUM(M$DO));
                       END;
                    CALL XUR$ERRPTR(,DCBNUM(M$LO));
                  END;
               ELSE CALL ERROR1;
          GOTO GET_COMMAND;
        END;
     DO WHILE ('0'B);
BAD_PMME_CONTINUE: ;
          CALL ERROR;
          IF CONTINUE
          THEN GOTO GET_COMMAND;
          ELSE GOTO DONE;
BAD_PMME: ;
          CALL ERROR;
          GOTO DONE;
BAD_FILE: ;
          MSG_BUF = ' *** Specified file is not a keyed file. ***';
          CALL M$WRITE (WRITE_FPT);
          IF NOT LO_DO_SAME
          THEN CALL M$WRITE (WRITEDO_FPT);
          IF OPENFLAG
          THEN DO;
               CALL M$CLOSE (CLOSESI_FPT) ALTRET (BAD_PMME);
               OPENFLAG = '0'B;
             END;
          GOTO GET_COMMAND;
        END ;
DONE: ;
END SDUMP;
%EJECT;
