

14:54 JUL 28 '97 KV$USR.:E05SI                                             1    
    1      /*M* KV$USR VDH to VDH-user request structures */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*F* NAME: KV_NAMTXT_USR_FNC Names (in CHAR data type) of the KV_USR_FNC EQUs */
    9      %MACRO KV_NAMTXT_USR_FNC (NAME = KV_NAMTXT_USR_FNC, LAST = ";", STCLASS = CONSTANT);
   10      %LSET LISTDIR = '0'B;
   11      %LSET LISTEXP = '1'B;
   12      %LSET LISTCOM = '0'B;
   13      %LSET LISTSUB = '1'B;
   14      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   15      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   16      %IF STC = 1;
   17      %LSET INIT = CHARTEXT(' INIT');
   18      %LSET ENIT = CHARTEXT('');
   19      %ELSE;
   20      %LSET INIT = CHARTEXT('/*');
   21      %LSET ENIT = CHARTEXT('*/');
   22      %ENDIF;
   23      DCL 1 NAME STCLASS,
   24      2 TXT_INT CALIGNED,
   25      3 * CHAR(26) %INIT('KV_USR_FNC: none (0)')%ENIT  CALIGNED,
   26      3 * CHAR(26) %INIT('KV_USR_FNC_DAT')%ENIT  CALIGNED,
   27      3 * CHAR(26) %INIT('KV_USR_FNC: none')%ENIT  CALIGNED,
   28      3 * CHAR(26) %INIT('KV_USR_FNC_ERS')%ENIT  CALIGNED,
   29      3 * CHAR(26) %INIT('KV_USR_FNC_EVT')%ENIT  CALIGNED,
   30      3 * CHAR(26) %INIT('KV_USR_FNC_EXTINPTRN')%ENIT  CALIGNED,
   31      3 * CHAR(26) %INIT('KV_USR_FNC_EXTOTPTRN')%ENIT  CALIGNED,
   32      3 * CHAR(26) %INIT('KV_USR_FNC_GETOTPBFR')%ENIT  CALIGNED,
   33      3 * CHAR(26) %INIT('KV_USR_FNC_GETPRM')%ENIT  CALIGNED,
   34      3 * CHAR(26) %INIT('KV_USR_FNC_INPPRC')%ENIT  CALIGNED,
   35      3 * CHAR(26) %INIT('KV_USR_FNC_OTPMRK')%ENIT  CALIGNED,
   36      3 * CHAR(26) %INIT('KV_USR_FNC_OTPRPTCHR')%ENIT  CALIGNED,
   37      3 * CHAR(26) %INIT('KV_USR_FNC_PST')%ENIT  CALIGNED,
14:54 JUL 28 '97 KV$USR.:E05SI                                             2    
   38      3 * CHAR(26) %INIT('KV_USR_FNC_RQSDAT')%ENIT  CALIGNED,
   39      3 * CHAR(26) %INIT('KV_USR_FNC_SETATR')%ENIT  CALIGNED,
   40      3 * CHAR(26) %INIT('KV_USR_FNC_SETPRM')%ENIT  CALIGNED,
   41      2 TXT(0:%KV_USR_FNC_HI) REDEF TXT_INT CHAR(26) CALIGNED LAST
   42      %MEND;
   43      /*F* NAME: KV_NAMTXT_USR_EVT_ID Names (in CHAR data type) of the KV_USR_EVT_ID EQUs */
   44      %MACRO KV_NAMTXT_USR_EVT_ID (NAME = KV_NAMTXT_USR_EVT_ID, LAST = ";", STCLASS = CONSTANT);
   45      %LSET LISTDIR = '0'B;
   46      %LSET LISTEXP = '1'B;
   47      %LSET LISTCOM = '0'B;
   48      %LSET LISTSUB = '1'B;
   49      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   50      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   51      %IF STC = 1;
   52      %LSET INIT = CHARTEXT(' INIT');
   53      %LSET ENIT = CHARTEXT('');
   54      %ELSE;
   55      %LSET INIT = CHARTEXT('/*');
   56      %LSET ENIT = CHARTEXT('*/');
   57      %ENDIF;
   58      DCL 1 NAME STCLASS,
   59      2 TXT_INT CALIGNED,
   60      3 * CHAR(26) %INIT('KV_USR_EVT_ID: none (0)')%ENIT  CALIGNED,
   61      3 * CHAR(26) %INIT('KV_USR_EVT_ID_BGNSETPRM')%ENIT  CALIGNED,
   62      3 * CHAR(26) %INIT('KV_USR_EVT_ID_CLS')%ENIT  CALIGNED,
   63      3 * CHAR(26) %INIT('KV_USR_EVT_ID_DLTOTP')%ENIT  CALIGNED,
   64      3 * CHAR(26) %INIT('KV_USR_EVT_ID_DSC')%ENIT  CALIGNED,
   65      3 * CHAR(26) %INIT('KV_USR_EVT_ID_ENDSETPRM')%ENIT  CALIGNED,
   66      3 * CHAR(26) %INIT('KV_USR_EVT_ID_GETSTR')%ENIT  CALIGNED,
   67      3 * CHAR(26) %INIT('KV_USR_EVT_ID_HLTOTP')%ENIT  CALIGNED,
   68      3 * CHAR(26) %INIT('KV_USR_EVT_ID_LGNACP')%ENIT  CALIGNED,
   69      3 * CHAR(26) %INIT('KV_USR_EVT_ID_LGNRJC')%ENIT  CALIGNED,
   70      3 * CHAR(26) %INIT('KV_USR_EVT_ID_OPN')%ENIT  CALIGNED,
   71      3 * CHAR(26) %INIT('KV_USR_EVT_ID_RLSSTR')%ENIT  CALIGNED,
   72      3 * CHAR(26) %INIT('KV_USR_EVT_ID_SCH')%ENIT  CALIGNED,
   73      3 * CHAR(26) %INIT('KV_USR_EVT_ID_TRMUSRRQSDAT')%ENIT  CALIGNED,
   74      3 * CHAR(26) %INIT('KV_USR_EVT_ID_VDHEXT')%ENIT  CALIGNED,
14:54 JUL 28 '97 KV$USR.:E05SI                                             3    
   75      3 * CHAR(26) %INIT('KV_USR_EVT_ID_RLSVDI')%ENIT  CALIGNED,
   76      3 * CHAR(26) %INIT('KV_USR_EVT_ID_CLKEXP')%ENIT  CALIGNED,
   77      3 * CHAR(26) %INIT('KV_USR_EVT_ID_INHDLTOTP')%ENIT  CALIGNED,
   78      3 * CHAR(26) %INIT('KV_USR_EVT_ID_OTP1_CHR')%ENIT  CALIGNED,
   79      2 TXT(0:%KV_USR_EVT_ID_HI) REDEF TXT_INT CHAR(26) CALIGNED LAST
   80      %MEND;
   81      /*F* NAME:  VDH_to_VDH_user Request Overview
   82
   83      To invoke the VDH-user, VDH calls a single VDH-user routine, passing
   84      as the only argument an FPT generated by a macro named KV$USR_xx.  The
   85      address of the VDH-user routine is in KV$USRPRM.USRSBR$ (user
   86      parameters, user subroutine pointer).  The KV$USR_xx FPTs and their
   87      functions are describe in this subsection.  All of the KV$USR_xx FPTs
   88      have as the first byte a field named FNC, whose contents should be
   89      interrogated by the user subroutine to determine which of the KV$USR_xx
   90      FPTs is being passed.  The EQUs for the values in KV$USR_xx.FNC are
   91      defined in the KV_USR_FNC_E macro in the KV_GLBCNS_E macro file.  If
   92      the KV$USR_xx FPT is being passed, then the name of the EQU whose value is
   93      in KV$USR_xx.FNC is spelled KV_USR_FNC_xx.  For example, KV$USR_DAT.FNC
   94      would contain %KV_USR_FNC_DAT.
   95      ..::IX "KV_USR_FNC_E"
   96
   97      Certain functions discussed in this subsection are performed internally by VDH via
   98      KV$ERD-driven routines, unless VDH is directed otherwise by various flag
   99      settings.  Other flag settings provide the
  100      option for user intervention for the processing of specific events or
  101      the setting of specific parameters.
  102      These functions and the
  103      corresponding flags are as follows:
  104
  105      .inl 1
  106      .brn 11
  107      .fif
  108      }Function                        Flag or Array of Flags
  109      }--------                        ----------------------
  110      .spf
  111      }KV$USR_ERS - Erase              KV$MRD.CALUSR_ERS
14:54 JUL 28 '97 KV$USR.:E05SI                                             4    
  112      }KV$USR_EVT - Event              KV$VDI.USREVTENB
  113      }KV$USR_PST - Position           KV$MRD.CALUSR_PST
  114      }KV$USR_OTPRPTCHR - Output       KV$MRD.CALUSR_OTPRPTCHR
  115      }             Repeated Character
  116      }KV$USR_SETATR - Set Attributes  KV$MRD.CALUSR_SETATR
  117      }KV$USR_SETPRM - Set Parameters  KV$USRPRM.SETPRMPREPRC and
  118      }                                KV$USRPRM.SETPRMPSTPRC
  119      .fin
  120      .inl 0
  121      */
  122      /*F* NAME:  KV$USR_DAT - Data
  123
  124      The VDH-user processes the indicated output data.
  125      Optionally specified (as appropriate) are a vector to the data,
  126      error status, activation character, record identifier, VFC, etc.
  127      VDH will take care of the release of the buffer
  128      containing the data when the VDH-user returns.
  129      */
  130      /*K* CNTFNCCHRS = {YES|NO}.
  131      .xeq KV$VDH KV$VDH_DAT CNTFNCCHRS
  132      */
  133      /*K* CTN = VALUE-BIT(1).
  134      .xeq KV$VDH KV$VDH_DAT CTN
  135      */
  136      /*K* DATCTRCHRTYP = VALUE-DEC(0-3).
  137      .xeq KV$VDH KV$VDH_DAT DATCTRCHRTYP
  138      */
  139      /*K* DATMOD = VALUE-DEC(0-3).
  140      .xeq KV$VDH KV$VDH_DAT DATMOD
  141      */
  142      /*K* DAT__ = KV$BFRDSC substructure.
  143      .xeq KV$VDH KV$VDH_DAT DAT__
  144      */
  145      /*K* CMPCOD = VALUE-DEC(0-255).
  146      .xeq KV$VDH KV$VDH_DAT CMPCOD
  147      */
  148      /*K* DATCTRCHR = VALUE-CHAR(1).
14:54 JUL 28 '97 KV$USR.:E05SI                                             5    
  149      .xeq KV$VDH KV$VDH_DAT DATCTRCHR
  150      */
  151      */
  152
  153      %MACRO KV$USR_DAT(NAME = KV$USR_DAT, LAST = ";", STCLASS = BASED, LVL = 1);
  154      %LSET LISTDIR = '0'B;
  155      %KV$USR_FNCHDR (NAME=NAME, STCLASS=STCLASS, FNC=KV_USR_FNC_DAT, LVL=LVL);
  156      %KV$VDH_DAT (HDR=NO, STCLASS=STCLASS, LAST=LAST, LVL=LVL);
  157      %MEND;
  158
  159      /*F* NAME:  KV$USR_ERS - Erase
  160
  161      VDH erases the specified area.  A rectangular physical area and
  162      a starting and ending position are specified.  Erasure occurs
  163      beginning with and including the starting position, through to, and
  164      including, the ending position.  If the specified area includes more than
  165      one line, the second through last lines are completely erased,
  166      from the left through the right area boundaries.
  167      Erasure occurs through (inclusive) the ending column
  168      on the bottom line of the rectangular area.
  169
  170      The following diagram depicts a rectangular area delimited
  171      by coordinates TOPLFT and BTMRHT.  The erasure starts at
  172      the BGNPHSCLM column and continues through the ENDPHSCLM column, erasing the column
  173      positions marked with 'X's.
  174      .FIF
  175
  176
  177      .brn 12
  178      }   TOPLFT  BGNPHSCLM
  179      }     |         |
  180      }     | V         | V
  181      }    |----------------------------------|
  182      }    |          XXXXXXXXXXXXXXXXXXXXXXXX|
  183      }    |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX|
  184      }    |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX|
  185      }    |XXXXXXXXXXXXXXXXXXXX              |
14:54 JUL 28 '97 KV$USR.:E05SI                                             6    
  186      }    |----------------------------------|
  187      }                        | ^             | ^
  188      }                        |             |
  189      }                    ENDPHSCLM       BTMRHT
  190      .FIN
  191
  192      Note:  KV$USR_ERS is performed internally by VDH via KV$ERD-driven
  193      routines, unless the KV$MRD.CALUSR_ERS flag is set.
  194      */
  195
  196
  197      %MACRO KV$USR_ERS(NAME = KV$USR_ERS, LAST = ";", STCLASS = BASED);
  198      %LSET LISTDIR = '0'B;
  199      %LSET LISTEXP = '1'B;
  200      %LSET LISTCOM = '0'B;
  201      %LSET LISTSUB = '1'B;
  202      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  203      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  204      %LSET INIT = CHARTEXT(' INIT');
  205      %LSET ENIT = CHARTEXT('');
  206      %ELSE;
  207      %LSET INIT = CHARTEXT('/*');
  208      %LSET ENIT = CHARTEXT('*/');
  209      %ENDIF;
  210      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_ERS);
  211            2 DLTATR BIT(1) %INIT('0'B)%ENIT,
  212      /*K* DLTATR = VALUE-BIT(1).  Delete attributes.  All attribute declarations in the area to
  213      be erased should be deleted.
  214      */
  215            2 NO_RE_PST BIT(1) %INIT('0'B)%ENIT,
  216      /*K* NO_RE_PST = VALUE-BIT(1).  If set, it is not necessary to
  217      reposition after the erasing.
  218      */
  219      %KV$PST (LVL = 2, NAME = TOPLFT, STCLASS = STCLASS, LAST = ",");
  220      /*K* TOPLFT = position (KV$PST substructure).  Top left physical position.  This is the top left corner
  221      of the box to be erased.
  222      */
14:54 JUL 28 '97 KV$USR.:E05SI                                             7    
  223      %KV$PST (LVL = 2, NAME = BTMRHT, STCLASS = STCLASS, LAST = ",");
  224      /*K* BTMRHT = position (KV$PST substructure).  Bottom right physical position.  This is the bottom right corner
  225      of the box to be erased.
  226      */
  227            2 BGNPHSCLM UBIN WORD %INIT(1)%ENIT,
  228      /*K* BGNPHSCLM = VALUE-DEC(0-65535).  Beginning physical column.  This is the column (on the line
  229      described in TOPLFT) to begin the erasure.
  230      */
  231            2 ENDPHSCLM UBIN WORD %INIT(1)%ENIT LAST
  232      /*K* ENDPHSCLM = VALUE-DEC(0-65535).  Ending physical column.  This is the column (on the line
  233      described above) to end the erasure.
  234      */
  235      %MEND;
  236
  237      /*F* NAME:  KV$USR_EVT - Event
  238
  239      VDH informs the VDH-user of the occurrence of the event in ID.
  240
  241      Note:  An event is only reported if the corresponding bit is set
  242      in KV$VDI.USREVTENB.
  243      */
  244
  245      %MACRO KV$USR_EVT(NAME = KV$USR_EVT, LAST = ";", STCLASS = BASED);
  246      %LSET LISTDIR = '0'B;
  247      %LSET LISTEXP = '1'B;
  248      %LSET LISTCOM = '0'B;
  249      %LSET LISTSUB = '1'B;
  250      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  251      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  252      %LSET INIT = CHARTEXT(' INIT');
  253      %LSET ENIT = CHARTEXT('');
  254      %ELSE;
  255      %LSET INIT = CHARTEXT('/*');
  256      %LSET ENIT = CHARTEXT('*/');
  257      %ENDIF;
  258      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_EVT);
  259            2 ACT BIT(1) %INIT('0'B)%ENIT,
14:54 JUL 28 '97 KV$USR.:E05SI                                             8    
  260      /*K* ACT = VALUE-BIT(1).  Action.  If ACT is set, this indicates that
  261      the VDH-user took some action as a
  262      result of receiving this event.  This flag should only be
  263      set if the KV_USR_EVT_ID_... description specifies that it
  264      should.  It should never be reset; it is initialized that way,
  265      and may have been set intentionally on the way to the VDH-user
  266      if VDH also took some action.  The VDH-user may alternatively indicate the
  267      failure to take any action by ALTRETURNing to VDH.  If RETURN is used, it
  268      is assumed that some action has been taken.
  269      */
  270            2 ID UBIN(7) UNAL %INIT(0)%ENIT,
  271      /*K* ID = VALUE-DEC(0-127).  Event ID.  ID identifies what event is being
  272      reported.  EQUate identifiers for Event IDs are listed in the following table.
  273      ..::TB "^\Event ID\#5\Meaning\#"
  274      ..::IT "KV_USR_EVT_ID_BGNSETPRM"
  275      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_BGNSETPRM
  276      ..::IT "KV_USR_EVT_ID_CLKEXP"
  277      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_CLKEXP
  278      ..::IT "KV_USR_EVT_ID_CLS"
  279      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_CLS
  280      ..::IT "KV_USR_EVT_ID_DLTOTP"
  281      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_DLTOTP
  282      ..::IT "KV_USR_EVT_ID_DSC"
  283      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_DSC
  284      ..::IT "KV_USR_EVT_ID_ENDSETPRM"
  285      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_ENDSETPRM
  286      ..::IT "KV_USR_EVT_ID_GETSTR"
  287      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_GETSTR
  288      ..::IT "KV_USR_EVT_ID_HLTOTP"
  289      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_HLTOTP
  290      ..::IT "KV_USR_EVT_ID_INHDLTOTP"
  291      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_INHDLTOTP
  292      ..::IT "KV_USR_EVT_ID_LGNACP"
  293      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_LGNACP
  294      ..::IT "KV_USR_EVT_ID_LGNRJC"
  295      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_LGNRJC
  296      ..::IT "KV_USR_EVT_ID_OPN"
14:54 JUL 28 '97 KV$USR.:E05SI                                             9    
  297      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_OPN
  298      ..::IT "KV_USR_EVT_ID_OTP1_CHR"
  299      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_OTP1_CHR
  300      ..::IT "KV_USR_EVT_ID_RLSSTR"
  301      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_RLSSTR
  302      ..::IT "KV_USR_EVT_ID_RLSVDI"
  303      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_RLSVDI
  304      ..::IT "KV_USR_EVT_ID_SCH"
  305      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_SCH
  306      ..::IT "KV_USR_EVT_ID_TRMUSRRQSDAT"
  307      .xeq KV_GLBCNS_E KV_USR_EVT TRMUSRRQSDAT
  308      ..::IT "KV_USR_EVT_ID_VDHEXT"
  309      .xeq KV_GLBCNS_E KV_USR_EVT KV_USR_EVT_ID_VDHEXT
  310      ..::TB
  311      */
  312            2 PRM SBIN WORD %INIT(0)%ENIT LAST
  313      /*K* PRM = VALUE-DEC(-32768-32767).  Parameter.  The meaning of this optional
  314      parameter is defined in the description of the KV_USR_EVT_ID...s.
  315      */
  316      %MEND;
  317
  318      /*F* NAME:  KV$USR_EXTINPTRN - Extended Input Translation
  319
  320      VDH attempted input translation of a character for which the
  321      translation table indicates no simple translation or some real device
  322      protocol implication.  An input ID code from the translation table
  323      (which only the VDH-user understands) is passed.
  324      The only currently implemented use of this facility is the "special-escape"
  325      one,  whereby certain characters are sometimes used for control functions
  326      instead of part of the input data.  In such cases, e.g., the CR that "CR TO GO"
  327      waits for, the VDH-user should ALTRETURN if the character is to be treated
  328      normally (usually because there is no control function pending).
  329      */
  330
  331      %MACRO KV$USR_EXTINPTRN(NAME = KV$USR_EXTINPTRN, LAST = ";", STCLASS = BASED);
  332      %LSET LISTDIR = '0'B;
  333      %LSET LISTEXP = '1'B;
14:54 JUL 28 '97 KV$USR.:E05SI                                             10   
  334      %LSET LISTCOM = '0'B;
  335      %LSET LISTSUB = '1'B;
  336      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  337      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  338      %LSET INIT = CHARTEXT(' INIT');
  339      %LSET ENIT = CHARTEXT('');
  340      %ELSE;
  341      %LSET INIT = CHARTEXT('/*');
  342      %LSET ENIT = CHARTEXT('*/');
  343      %ENDIF;
  344      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_EXTINPTRN);
  345            2 SPCESC BIT(1) %INIT('0'B)%ENIT,
  346      /*K* SPCESC = VALUE-BIT(1).  Special escape.
  347      If SPCESC is set, an escape (from normal processing) has been
  348      requested early in the character processing cycle.
  349      */
  350            2 IMD BIT(1) %INIT('0'B)%ENIT,
  351      /*K* IMD = VALUE-BIT(1).  If set, the Immediate phase is active.
  352      */
  353            2 RED BIT(1) %INIT('0'B)%ENIT,
  354      /*K* RED = VALUE-BIT(1).  If set, the Read phase is active.
  355      */
  356            2 * BIT(5) %INIT('0'B)%ENIT,
  357            2 ID UBIN BYTE CALIGNED %INIT(0)%ENIT,
  358      /*K* ID = VALUE-DEC(0-255).  Translation token ID.
  359      ID identifies which token of a given type
  360      this instance is (typically one for each translation input
  361      character yielding a token).  ID is not used for SPCESCs.
  362      */
  363            2 ORGCHR CHAR(1) %INIT(BINASC(0))%ENIT LAST
  364      /*K* ORGCHR = VALUE-CHAR(1).  Contains the original (untranslated) character.
  365      */
  366      %MEND;
  367
  368      /*F* NAME:  KV$USR_EXTOTPTRN - Extended Output Translation
  369
  370      VDH attempted output translation of a character for which the
14:54 JUL 28 '97 KV$USR.:E05SI                                             11   
  371      translation table indicates no simple translation or some real device
  372      protocol implication.  An output
  373      ID code (which only the VDH-user understands) is passed.
  374      */
  375
  376      %MACRO KV$USR_EXTOTPTRN(NAME = KV$USR_EXTOTPTRN, LAST = ";", STCLASS = BASED);
  377      %LSET LISTDIR = '0'B;
  378      %LSET LISTEXP = '1'B;
  379      %LSET LISTCOM = '0'B;
  380      %LSET LISTSUB = '1'B;
  381      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  382      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  383      %LSET INIT = CHARTEXT(' INIT');
  384      %LSET ENIT = CHARTEXT('');
  385      %ELSE;
  386      %LSET INIT = CHARTEXT('/*');
  387      %LSET ENIT = CHARTEXT('*/');
  388      %ENDIF;
  389      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_EXTOTPTRN);
  390            2 OTPLCLFLGS BIT(8) %INIT('0'B)%ENIT,
  391      /*K* OTPLCLFLGS = VALUE-BIT(8).  Contains the OTPLCL flags to be
  392      passed back on KV$VDH_OTPLCL with the translated characters.
  393      */
  394            2 ID UBIN BYTE CALIGNED %INIT(0)%ENIT,
  395      /*K* ID = VALUE-DEC(0-255).  Translation token ID.
  396      ID identifies which token of a given type
  397      this instance is (typically one for each translation input
  398      character yielding a token).
  399      */
  400            2 ORGCHR CHAR(1) %INIT(BINASC(0))%ENIT,
  401      /*K* ORGCHR = VALUE-CHAR(1).  Contains the original (untranslated) character.
  402      */
  403            2 EXTTRN$ PTR %INIT(ADDR(NIL))%ENIT LAST
  404      /*K* EXTTRN$ = PTR.  Extended translation pointer.  EXTTRN$ points to a table declared
  405      in the translate table (KV$TRNTBL.EXTTRN$).  The contents
  406      of this table are not understood by VDH.
  407      */
14:54 JUL 28 '97 KV$USR.:E05SI                                             12   
  408      %MEND;
  409
  410      /*F* NAME:  KV$USR_GETOTPBFR - Get Output Buffer
  411
  412      For most display-type real devices, the VDH-user
  413      allocates output buffer space for use by VDH and the VDH-user.
  414      The VDH-user owns the space, and is responsible for releasing it.
  415      A vector in VDI context (KV$VDI.OTPBFR_) frames the remaining portion of the last
  416      buffer.  VDH stores translated output characters into the
  417      buffer.  VDH passes a rough estimate of the expected size of
  418      the buffer needed.
  419      If the VDH-user uses the KV$TRNTBL.OTPESCCHR mechanism,
  420      then the VDH-user must allocate at least 2 bytes.
  421      */
  422
  423      %MACRO KV$USR_GETOTPBFR(NAME = KV$USR_GETOTPBFR, LAST = ";", STCLASS = BASED);
  424      %LSET LISTDIR = '0'B;
  425      %LSET LISTEXP = '1'B;
  426      %LSET LISTCOM = '0'B;
  427      %LSET LISTSUB = '1'B;
  428      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  429      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  430      %LSET INIT = CHARTEXT(' INIT');
  431      %LSET ENIT = CHARTEXT('');
  432      %ELSE;
  433      %LSET INIT = CHARTEXT('/*');
  434      %LSET ENIT = CHARTEXT('*/');
  435      %ENDIF;
  436      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_GETOTPBFR);
  437            2 ESTBYTSIZ UBIN WORD %INIT(0)%ENIT LAST
  438      /*K* ESTBYTSIZ = VALUE-DEC(0-65535).  Estimated byte size of the buffer.  This is VDH's estimate of
  439      the space required, given what VDH knows about the
  440      current operation.  This is only an estimate, and may be
  441      ignored.
  442      */
  443      %MEND;
  444
14:54 JUL 28 '97 KV$USR.:E05SI                                             13   
  445      /*F* NAME:  KV$USR_GETPRM - Get Parameters
  446
  447      The VDH-user is to return the value of the specified parameter item
  448      or structure.  This structure must be accepted, but no returned
  449      information is required.
  450      */
  451
  452      %MACRO KV$USR_GETPRM(NAME = KV$USR_GETPRM, LAST = ";", STCLASS = BASED);
  453      %LSET LISTDIR = '0'B;
  454      %LSET LISTEXP = '1'B;
  455      %LSET LISTCOM = '0'B;
  456      %LSET LISTSUB = '1'B;
  457      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  458      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  459      %LSET INIT = CHARTEXT(' INIT');
  460      %LSET ENIT = CHARTEXT('');
  461      %ELSE;
  462      %LSET INIT = CHARTEXT('/*');
  463      %LSET ENIT = CHARTEXT('*/');
  464      %ENDIF;
  465      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_GETPRM);
  466            2 PRMID UBIN WORD %INIT(0)%ENIT,
  467      /*K* PRMID = VALUE-DEC(0-65535).  Parameter ID.  Values are KV_PRMID_parameter-name.
  468      */
  469            2 VAL UBIN WORD %INIT(0)%ENIT,
  470      /*K* VAL = VALUE-DEC(0-65535).  Value of parameter.
  471      VAL is used for parameters that are not
  472      structures and not arrays.
  473      */
  474      %KV$VECTOR (LVL = 2, NAME = VAL_, STCLASS = STCLASS, LAST = LAST);
  475      /*K* VAL_ = VDH-vector (KV$VECTOR).  Vector to value of parameter.
  476      VAL_ is used for parameters that
  477      are structures or byte arrays.
  478      */
  479      %MEND;
  480
  481      /*F* NAME:  KV$USR_INPPRC - Input Procedure
14:54 JUL 28 '97 KV$USR.:E05SI                                             14   
  482
  483      VDH interpreted the input function tables and encountered
  484      an input operator whose type was KV_INPOPR_TYP_USRINPPRC.
  485      The purpose of this input operator is to give control to the
  486      VDH user during the interpretation process.
  487      */
  488
  489      %MACRO KV$USR_INPPRC(NAME = KV$USR_INPPRC, LAST = ";", STCLASS = BASED);
  490      %LSET LISTDIR = '0'B;
  491      %LSET LISTEXP = '1'B;
  492      %LSET LISTCOM = '0'B;
  493      %LSET LISTSUB = '1'B;
  494      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  495      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  496      %LSET INIT = CHARTEXT(' INIT');
  497      %LSET ENIT = CHARTEXT('');
  498      %ELSE;
  499      %LSET INIT = CHARTEXT('/*');
  500      %LSET ENIT = CHARTEXT('*/');
  501      %ENDIF;
  502      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_INPPRC);
  503            2 IMD BIT(1) %INIT('0'B)%ENIT,
  504      /*K* IMD = VALUE-BIT(1).  If set, the Immediate phase is active.
  505      */
  506            2 RED BIT(1) %INIT('0'B)%ENIT,
  507      /*K* RED = VALUE-BIT(1).  If set, the Read phase is active.
  508      */
  509            2 * BIT(6) %INIT('0'B)%ENIT,
  510            2 CHR UBIN WORD %INIT(0)%ENIT,
  511      /*K* CHR = VALUE-DEC(0-65535).  Contains the character invoking this input function.
  512      */
  513            2 ID UBIN BYTE CALIGNED %INIT(0)%ENIT,
  514      /*K* ID = VALUE-DEC(0-255).  Identifies which input procedure is to be executed.
  515      This is the value specified on the USRINPPRC macro.  (See KV$INPFNC.)
  516      */
  517            2 ORGCHR CHAR(1) %INIT(BINASC(0))%ENIT LAST
  518      /*K* ORGCHR = VALUE-CHAR(1).  Contains the original (untranslated) character.
14:54 JUL 28 '97 KV$USR.:E05SI                                             15   
  519      */
  520      %MEND;
  521
  522      /*F* NAME:  KV$USR_OTPMRK - Output Marker
  523
  524      The VDH-user saves the marker data until all currently queued
  525      output data has been sent or otherwise disposed of.
  526      Then the VDH-user returns
  527      (via KV$VDH_OTPMRK) the marker data.
  528      */
  529
  530      %MACRO KV$USR_OTPMRK(NAME = KV$USR_OTPMRK, LAST = ";", STCLASS = BASED,
  531      CMPOTP(YES = '1'B, NO = '0'B) = '0'B,
  532      MSTRTR(YES = '1'B, NO = '0'B) = '0'B,
  533      TYP = 0);
  534      %LSET LISTDIR = '0'B;
  535      %LSET LISTEXP = '1'B;
  536      %LSET LISTCOM = '0'B;
  537      %LSET LISTSUB = '1'B;
  538      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  539      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  540      %LSET INIT = CHARTEXT(' INIT');
  541      %LSET ENIT = CHARTEXT('');
  542      %ELSE;
  543      %LSET INIT = CHARTEXT('/*');
  544      %LSET ENIT = CHARTEXT('*/');
  545      %ENDIF;
  546      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_OTPMRK);
  547              2 %CHARTEXT('CMPOTP') BIT(1) %INIT(CMPOTP)%ENIT,
  548      /*K* CMPOTP = {YES|NO}.  Complete output.
  549      If CMPOTP=YES, upon receipt of the output marker, the VDH-user
  550      must complete its output and return the marker data (via
  551      KV$VDH_OTPMRK).  (VDH may not give the VDH-user any more output
  552      until the marker data is returned.)
  553      */
  554      %KV$OTPMRK (LVL = 2, NAME = DAT, STCLASS = STCLASS, LAST = LAST,
  555      MSTRTR = MSTRTR, TYP = TYP);
14:54 JUL 28 '97 KV$USR.:E05SI                                             16   
  556      /*K* DAT = KV$OTPMRK substructure.  Output marker data.  This is the data to be passed back to
  557      VDH on the KV$VDH_OTPMRK.
  558      Later, after the preceding data has been output or otherwise
  559      disposed of, copy the saved version to KV$VDH_OTPMRK.DAT,
  560      fill in KV$VDH_OTPMRK.CMPCOD, and call VDH.
  561      */
  562      /*K* MSTRTR = {YES|NO}.  Must return.  Unless set, markers in deleted
  563      output may be ignored.
  564      */
  565      /*K* TYP = VALUE-DEC(0-15).  Specifies marker type.  EQUate
  566      identifiers for TYP are listed in the following table.
  567      ..::TB "^\Identifier\#20\Meaning"
  568      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_ACK
  569      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_LOW
  570      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_MRK
  571      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_REDTIMOUT
  572      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_SAVLSTRCRID
  573      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_SNDLSTRCRID
  574      ..::TB
  575      */
  576      %MEND;
  577
  578      /*F* NAME:  KV$USR_OTPRPTCHR - Output Repeated Character
  579
  580      VDH is about to output a string of repeated characters (single
  581      character repeated > 3 times), and KV$VDI.CALUSR_OTPRPTCHR
  582      is set.  The VDH-user should buffer the specified character
  583      the specified number of times.
  584
  585      Note:  KV$MRD.CALUSR_OTPRPTCHR should be set only if the handler
  586      can buffer or send repeated characters more efficiently than one character
  587      per byte.
  588      */
  589
  590      %MACRO KV$USR_OTPRPTCHR(NAME = KV$USR_OTPRPTCHR, LAST = ";", STCLASS = BASED);
  591      %LSET LISTDIR = '0'B;
  592      %LSET LISTEXP = '1'B;
14:54 JUL 28 '97 KV$USR.:E05SI                                             17   
  593      %LSET LISTCOM = '0'B;
  594      %LSET LISTSUB = '1'B;
  595      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  596      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  597      %LSET INIT = CHARTEXT(' INIT');
  598      %LSET ENIT = CHARTEXT('');
  599      %ELSE;
  600      %LSET INIT = CHARTEXT('/*');
  601      %LSET ENIT = CHARTEXT('*/');
  602      %ENDIF;
  603      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_OTPRPTCHR);
  604                2 CHR CHAR(1) %INIT(BINASC(0))%ENIT,
  605      /*K* CHR = VALUE-CHAR(1).  Contains the character.
  606      */
  607                2 CNT UBIN WORD %INIT(0)%ENIT LAST
  608      /*K* CNT = VALUE-DEC(0-65535).  Contains the count of occurrences to buffer.
  609      */
  610      %MEND;
  611
  612      /*F* NAME:  KV$USR_PST - Position
  613
  614      VDH positions to the specified physical position, using the specified
  615      positioning mode (skipping or blanking).
  616
  617      Note:  KV$USR_PST is performed internally by VDH via KV$ERD-driven
  618      routines, unless the KV$MRD.CALUSR_PST flag is set.
  619      */
  620
  621      %MACRO KV$USR_PST (NAME=KV$USR_PST, LAST=";", STCLASS=BASED,
  622                         TOPPAGCNT=0, LIN=1, CLM=1, SCRCNT=0,
  623                         PHSPSTMOD(SKP=1,BLN=2,ANY=3,VRTSCR=4,HRZSCR=5)=0);
  624      %LSET LISTDIR = '0'B;
  625      %LSET LISTEXP = '1'B;
  626      %LSET LISTCOM = '0'B;
  627      %LSET LISTSUB = '1'B;
  628      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  629      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
14:54 JUL 28 '97 KV$USR.:E05SI                                             18   
  630      %LSET INIT = CHARTEXT(' INIT');
  631      %LSET ENIT = CHARTEXT('');
  632      %ELSE;
  633      %LSET INIT = CHARTEXT('/*');
  634      %LSET ENIT = CHARTEXT('*/');
  635      %ENDIF;
  636      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_PST);
  637                2 %CHARTEXT('TOPPAGCNT') UBIN BYTE CALIGNED %INIT(TOPPAGCNT)%ENIT,
  638      /*K* TOPPAGCNT = VALUE-DEC(0-255).  Top page count.  For devices that have multiple pages
  639      (which is probably only line printers and similar
  640      hardcopy printing devices), TOPPAGCNT is the number of times to top
  641      the page (go through the perforation on the paper).
  642      */
  643      %KV$PST (LVL=2, NAME=PHSPST, STCLASS=STCLASS, LAST=",", LIN=LIN, CLM=CLM);
  644      /*K* PHSPST = position (KV$PST substructure).  Position to position to.  This is a physical position,
  645      where the first line and column on the page or device
  646      are line 1 and column 1.
  647      The real device's current line and column are in KV$MRD.DVCLIN and
  648      KV$MRD.DVCCLM.  The VDH-user should copy its updated
  649      line and column to the KV$MRD items after effecting the
  650      positioning.  The KV$MRD items would then (normally) match
  651      the requested position values.
  652      If the device or window is being operated in scrolling mode,
  653      KV$SRD.DVCLINBIS is used to keep track of the logical top-of-page
  654      for the page-halt facility.  In this case, the actual device line
  655      (KV$MRD.DVCLIN) is offset from values in PHSPST.LIN and
  656      KV$SRD.CRT.LIN by the value in KV$SRD.DVCLINBIS.  If PHSPST.LIN
  657      and KV$SRD.DVCLINBIS indicate a position outside the window,
  658      the VDH-user should cause the device to scroll the data in the
  659      appropriate direction and adjust KV$SRD.DVCLINBIS instead of
  660      KV$MRD.DVCLIN to indicate the new position.
  661      */
  662                2 %CHARTEXT('PHSPSTMOD') UBIN BYTE CALIGNED %INIT(PHSPSTMOD)%ENIT,
  663      /*K* PHSPSTMOD = VALUE-DEC(0-255).  Physical positioning mode.
  664      PHSPSTMOD indicates (for screens) whether to blank out or skip over
  665      existing characters when positioning forward.  This parameter
  666      has no meaning for hardcopy devices.  EQUate identifiers for the
14:54 JUL 28 '97 KV$USR.:E05SI                                             19   
  667      VRTPSTMOD values are listed in the following table.
  668      ..::TB "^\Identifier\#19\Meaning"
  669      KV_PHSPSTMOD_ANY             Any.
  670      KV_PHSPSTMOD_BLN             Blank.
  671      KV_PHSPSTMOD_HRZSCR          Horizontal scroll.
  672      KV_PHSPSTMOD_SKP             Skip.
  673      KV_PHSPSTMOD_VRTSCR          Vertical scroll.
  674      ..::TB
  675      */
  676                2 %CHARTEXT('SCRCNT') SBIN BYTE CALIGNED %INIT(SCRCNT)%ENIT LAST
  677      /*K* SCRCNT = VALUE-DEC(-128-127).  Scroll count.  If PHSPSTMOD is VRTSCR
  678      or HRZSCR, specifies the number of lines or columns to be inserted at PHSPST.
  679      The following data in the window is thus scrolled SCRCNT towards the bottom
  680      or right edge.  A negative SCRCNT causes deletion of lines or characters
  681      at PHSPST, scrolling following data up or to the left, and inserting spaces
  682      at the window edge.  This facility will only be used if KV$MRD.VRTSCR
  683      or KV$MRD.HRZSCR is set. */
  684      %MEND;
  685
  686      /*F* NAME:  KV$USR_RQSDAT - Request Data
  687
  688      The VDH-user should do whatever is necessary to collect data
  689      (logical records, e.g., a field or a line).  The KV$USR_RQSDAT
  690      function is used only for record-mode devices.  Following this
  691      function, a KV$VDH_DAT function will be accepted.
  692      */
  693
  694
  695      %MACRO KV$USR_RQSDAT(NAME = KV$USR_RQSDAT, LAST = ";", STCLASS = BASED,
  696      RE_RED (YES = '1'B, NO = '0'B) = '0'B,
  697      DATMOD(NRM = %KV#DATMOD_NRM, TRN = %KV#DATMOD_TRN,
  698             BNR = %KV#DATMOD_BNR, ANY = %KV#DATMOD_ANY) = 0,
  699      EOFNO_DAT (YES = '1'B, NO = '0'B) = '0'B);
  700      %LSET LISTDIR = '0'B;
  701      %LSET LISTEXP = '1'B;
  702      %LSET LISTCOM = '0'B;
  703      %LSET LISTSUB = '1'B;
14:54 JUL 28 '97 KV$USR.:E05SI                                             20   
  704      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  705      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  706      %LSET INIT = CHARTEXT(' INIT');
  707      %LSET ENIT = CHARTEXT('');
  708      %ELSE;
  709      %LSET INIT = CHARTEXT('/*');
  710      %LSET ENIT = CHARTEXT('*/');
  711      %ENDIF;
  712      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_RQSDAT);
  713                2 %CHARTEXT('RE_RED') BIT(1) %INIT(RE_RED)%ENIT UNAL,
  714      /*K* RE_RED = {YES|NO}.  Indicates, if YES, that the input edit buffer for
  715      this stream should be copied to the current read buffer and
  716      displayed as input.
  717      */
  718                2 %CHARTEXT('DATMOD') UBIN(2) %INIT(DATMOD)%ENIT UNAL,
  719      /*K* DATMOD = VALUE-DEC(0-3).  Specifies the mode of the data:  binary,
  720      transparent, 'normal' (not binary or transparent,
  721      or 'any' (for data requests where no specific mode is
  722      required).  EQUate identifiers for data modes are as follows:
  723      ..::TB "^\Identifier\#15\Meaning"
  724      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_ANY
  725      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_BNR
  726      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_NRM
  727      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_TRN
  728      ..::TB
  729      */
  730                2 %CHARTEXT('EOFNO_DAT') BIT(1) %INIT(EOFNO_DAT)%ENIT UNAL,
  731      /*K* EOFNO_DAT = {YES|NO}. Specifies, if YES, that if there is no data to
  732      send, an immediate EOF (end of file) should be reported.
  733      */
  734      %KV$VECTOR (LVL = 2, NAME = BFR_, STCLASS = STCLASS, LAST = ",");
  735      /*K* BFR_ = VDH-vector (KV$VECTOR).  Vector to buffer to place data in.
  736      This may be null, in which case the VDH-user must supply
  737      the buffer.  If BFR_ is not null, the specified buffer must be used.
  738      */
  739                2 MAXRCRBYTSIZ UBIN WORD %INIT(0)%ENIT LAST
  740      /*K* MAXRCRBYTSIZ = VALUE-DEC(0-65535).
14:54 JUL 28 '97 KV$USR.:E05SI                                             21   
  741      Contains the maximum size of data to be returned.
  742      */
  743      %MEND;
  744
  745      /*F* NAME:  KV$USR_SETATR - Set Attributes
  746
  747      The VDH-user does whatever is necessary to declare the field
  748      on the real device.  The physical position, input qualification
  749      criteria, and graphic rendition are specified.
  750
  751      Note:  KV$USR_SETATR is performed internally by VDH via KV$ERD-driven
  752      routines, unless the KV$MRD.CALUSR_SETATR flag is set.
  753      */
  754
  755      %MACRO KV$USR_SETATR(NAME = KV$USR_SETATR, LAST = ";", STCLASS = BASED);
  756      %LSET LISTDIR = '0'B;
  757      %LSET LISTEXP = '1'B;
  758      %LSET LISTCOM = '0'B;
  759      %LSET LISTSUB = '1'B;
  760      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  761      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  762      %LSET INIT = CHARTEXT(' INIT');
  763      %LSET ENIT = CHARTEXT('');
  764      %ELSE;
  765      %LSET INIT = CHARTEXT('/*');
  766      %LSET ENIT = CHARTEXT('*/');
  767      %ENDIF;
  768      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_SETATR);
  769                2 RTRDAT BIT(1) %INIT('0'B)%ENIT,
  770      /*K* RTRDAT = VALUE-BIT(1).  Return data.
  771      For block mode devices, when the device sends input data back, return
  772      the data contained in this field whether or not it was changed by the device.
  773      */
  774            2 DLTFLD BIT(1) %INIT('0'B)%ENIT,
  775      /*K* DLTFLD = VALUE-BIT(1).  If set, indicates that the "delete field" character
  776      sequence, if any, is to be sent to the device.
  777      */
14:54 JUL 28 '97 KV$USR.:E05SI                                             22   
  778            2 * BIT(6) %INIT('0'B)%ENIT,
  779      %KV$PST (LVL = 2, NAME = PHSPST, STCLASS = STCLASS, LAST = ",");
  780      /*K* PHSPST = position (KV$PST substructure).
  781      Specifies the physical position, at start of field (first data character, or
  782      attribute character if attribute occupies a display position).
  783      */
  784      %KV$QLF (LVL = 2, NAME = QLF, STCLASS = STCLASS, LAST = ",");
  785      /*K* QLF = qualification (KV$QLF substructure).  Specifies qualification
  786      parameters for the attributes being declared.
  787      */
  788      %KV$GRPRND (LVL = 2, NAME = GRPRND, STCLASS = STCLASS, LAST = LAST);
  789      /*K* GRPRND = graphic rendition (KV$GRPRND substructure).  Specifies
  790      graphic rendition parameters for the attributes being declared.
  791      */
  792      %MEND;
  793
  794      /*F* NAME:  KV$USR_SETPRM - Set Parameters
  795
  796      The VDH-user sets the specified parameter item(s) to the specified
  797      value(s) passed, if the parameter is contained in the
  798      VDH-user's context.  If the parameter is not contained
  799      in the VDH-user's context, this call is being made
  800      before and/or after the parameter is stored in VDH
  801      context.  Whether pre-processing and post-processing
  802      calls are made is determined by the KV$USRPRM.SETPRMPREPRC
  803      and KV$USRPRM.SETPRMPSTPRC tables, which are built by the
  804      VDH-user and interpreted by VDH.  If this is a pre-processing call, the
  805      VDH-user may abort any further processing of this parameter by ALTRETURNing
  806      to VDH, or may change the value if desired.  Note that, for parameters
  807      contained in the VDH-user's context, this function will still only
  808      be invoked if the corresponding KV$USRPRM.SETPRMxxxPRC flag is set.
  809      */
  810
  811      %MACRO KV$USR_SETPRM(NAME = KV$USR_SETPRM, LAST = ";", STCLASS = BASED);
  812      %LSET LISTDIR = '0'B;
  813      %LSET LISTEXP = '1'B;
  814      %LSET LISTCOM = '0'B;
14:54 JUL 28 '97 KV$USR.:E05SI                                             23   
  815      %LSET LISTSUB = '1'B;
  816      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  817      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  818      %LSET INIT = CHARTEXT(' INIT');
  819      %LSET ENIT = CHARTEXT('');
  820      %ELSE;
  821      %LSET INIT = CHARTEXT('/*');
  822      %LSET ENIT = CHARTEXT('*/');
  823      %ENDIF;
  824      %KV$USR_FNCHDR (NAME = NAME, STCLASS = STCLASS, FNC = KV_USR_FNC_SETPRM);
  825                2 PREPRC BIT(1) %INIT('0'B)%ENIT,
  826      /*K* PREPRC = VALUE-BIT(1).  Pre-processing.  This call is being made by VDH so the
  827      VDH-user can do pre-processing on the parameter about to be
  828      set, or so the VDH-user can store the parameter in its
  829      own context (if this is a parameter not contained in VDH
  830      context).
  831      If PREPRC is not set, this call is being made
  832      for post-processing (the value to be set has already been
  833      moved).
  834      */
  835                2 * BIT(7) UNAL %INIT('0'B)%ENIT,
  836                2 PRMID UBIN WORD %INIT(0)%ENIT,
  837      /*K* PRMID = VALUE-DEC(0-65535).  Parameter ID.  Values are KV_PRMID_parameter-name.
  838      */
  839                2 VAL UBIN WORD %INIT(0)%ENIT,
  840      /*K* VAL = VALUE-DEC(0-65535).  Value of parameter.
  841      VAL is used for parameters that are not
  842      structures and not arrays.
  843      */
  844      %KV$VECTOR (LVL = 2, NAME = VAL_, STCLASS = STCLASS, LAST = ",");
  845      /*K* VAL_ = VDH-vector (KV$VECTOR).  Vector to value of parameter.
  846      VAL_ is used for parameters that
  847      are structures or byte arrays.
  848      */
  849                2 SCP UBIN BYTE CALIGNED %INIT(0)%ENIT,
  850      /*K* SCP = VALUE-DEC(0-255).
  851      .xeq KV$VDH KV$VDH_SETPRM SCP
14:54 JUL 28 '97 KV$USR.:E05SI                                             24   
  852      */
  853                2 DMN UBIN BYTE CALIGNED %INIT(0)%ENIT LAST
  854      /*K* DMN = VALUE-DEC(0-255).
  855      .xeq KV$VDH KV$VDH_SETPRM DMN
  856      */
  857      %MEND;
  858      /*M* KV$USR_FNCHDR VDI function header substructure */
  859
  860      /* VDI function header substructure. */
  861
  862      /* Function.  Specifies the function being performed. */
  863      /* The value for KV$USR_function is KV_USR_FNC_function. */
  864      /* The value for KV$VDH_function is KV_VDH_FNC_function. */
  865
  866      %MACRO KV$USR_FNCHDR(NAME = KV$USRFNCHDR, LVL = 1, LAST = ",", STCLASS = BASED,
  867                           FNC(KV_USR_FNC_DAT = 1,
  868                           KV_USR_FNC_ERS = 3,
  869                           KV_USR_FNC_EVT = 4,
  870                           KV_USR_FNC_EXTINPTRN = 5,
  871                           KV_USR_FNC_EXTOTPTRN = 6,
  872                           KV_USR_FNC_GETOTPBFR = 7,
  873                           KV_USR_FNC_GETPRM = 8,
  874                           KV_USR_FNC_INPPRC = 9,
  875                           KV_USR_FNC_OTPMRK = 10,
  876                           KV_USR_FNC_OTPRPTCHR = 11,
  877                           KV_USR_FNC_PST = 12,
  878                           KV_USR_FNC_RQSDAT = 13,
  879                           KV_USR_FNC_SETATR = 14,
  880                           KV_USR_FNC_SETPRM = 15) = 0);
  881      %LSET LISTDIR = '0'B;
  882      %LSET LISTEXP = '1'B;
  883      %LSET LISTCOM = '0'B;
  884      %LSET LISTSUB = '1'B;
  885      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  886      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  887      %LSET INIT = CHARTEXT(' INIT');
  888      %LSET ENIT = CHARTEXT('');
14:54 JUL 28 '97 KV$USR.:E05SI                                             25   
  889      %ELSE;
  890      %LSET INIT = CHARTEXT('/*');
  891      %LSET ENIT = CHARTEXT('*/');
  892      %ENDIF;
  893      %IF LVL = 1;
  894      DCL 1 NAME STCLASS ALIGNED,
  895      %ELSE;
  896      %(LVL) NAME,
  897      %ENDIF;
  898            %(LVL+1) %CHARTEXT('FNC UBIN BYTE CALIGNED')%INIT(FNC)%ENIT LAST
  899      %MEND;

