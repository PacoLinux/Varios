C*T***********************************************************  
C*T*                                                         *  
C*T* Copyright (c) Bull HN Information Systems Inc., 1989    *  
C*T*                                                         *  
C*T***********************************************************  
      SUBROUTINE EVE(IVAL)
C
C     EVALUATE THE EXPRESSION AT CURPOS IN INPBUF AND RETURN THE
C     RESULT IN IVAL; IF LEGAL, RETURN A VALUE FROM 0-65535; ELSE
C     IF A TEXT STRING, RETURN IN TEXT, -LEN IN IVAL; ELSE 99999.
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION STACK(256),VALUE(64),ACTION(18,18)
C
C     DEFINE ACTION BASED ON PAIRS OF SYMBOLS
C
C                  *  /  \  +  - << >>  < <=  = <> >=  >  ~  &  | || |-
      DATA ACTION/ 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     1             1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2             1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     3             1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     4             1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     5             1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     6             1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     7             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
     8             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
     9             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
     A             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
     1             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
     2             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
     3             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2,
     4             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 2,
     5             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 2,
     6             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 2,
     7             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4/
C
C     CLEAR THE STACK, TEXT STORAGE, AND VALUE STORAGE
C
      STKPTR=1
      STACK(STKPTR)=KEOC
      TXTPTR=0
      VALPTR=0
C
C     FETCH A CHARACTER AND LOOK FOR SYMBOL/VALUE START
C
1000  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1010  IF (CH.NE.1H+)GOTO 1020 
      STKPTR=STKPTR-1
      GOTO 1000 
1020  IF (CH.NE.1H-)GOTO 1030 
      STACK(STKPTR)=KPMI
      GOTO 1000 
1030  IF (CH.NE.1H~)GOTO 1040 
      STACK(STKPTR)=KNOT
      GOTO 1000 
1040  IF (CH.NE.1H[)GOTO 1050 
      STACK(STKPTR)=KLPR
      GOTO 1000 
1050  IF (CH.NE.1H*)GOTO 1060 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=LOCCTR
      STACK(STKPTR)=VALPTR+63
      IF (IAND(OPTION,OPTREL).EQ.0)GOTO 2080 
      VALUE(VALPTR)=VALUE(VALPTR)+ISL(1,NBITS3)
      IF (LOCCTR.LT.256)GOTO 2080 
      VALUE(VALPTR)=VALUE(VALPTR)+ISL(1,NBITS2)
      GOTO 2080 
1060  IF (CH.EQ.1H$)GOTO 1130 
      IF (CH.NE.1H%)GOTO 1070 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      STACK(STKPTR)=VALPTR+63
      GOTO 1300 
1070  IF (CH.NE.1H@)GOTO 1080 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      STACK(STKPTR)=VALPTR+63
      GOTO 1350 
1080  IF (CH.NE.1H')GOTO 1090 
      TXTPTR=TXTPTR+1
      STACK(STKPTR)=256*TXTPTR
      GOTO 1170 
1090  IF (CH.NE.1H")GOTO 1100 
      TXTPTR=TXTPTR+1
      STACK(STKPTR)=256*TXTPTR
      GOTO 1420 
1100  IF (TY.NE.2)GOTO 1110 
      TXTPTR=TXTPTR+1
      TEXT(TXTPTR)=CH
      STACK(STKPTR)=256*TXTPTR+1
      TXTPTR=TXTPTR+1
      GOTO 1480 
1110  IF (CH.EQ.1HB)GOTO 1630 
      IF (CH.EQ.1HC)GOTO 1850 
      IF (CH.EQ.1HO)GOTO 1690 
      IF (CH.EQ.1HP)GOTO 1750 
      IF (CH.EQ.1HX)GOTO 1750 
      IF (TY.NE.1)GOTO 1120 
      HISYM=HISYM+1
      IF (HISYM.GT.1000)GOTO 2550 
      SYMBOL(1,HISYM)=0
      SYMBOL(2,HISYM)=0
      SYMBOL(3,HISYM)=0
      SYMBOL(4,HISYM)=0
      SYMBOL(5,HISYM)=0
      CALL PACK(SYMBOL(1,HISYM),CH)
      STACK(STKPTR)=HISYM+16383
      GOTO 1960 
1120  IVAL=99999
      RETURN
C
C     WE PUSHED A $ INTO THE STACK; IF IT IS FOLLOWED BY A NUMBER,
C     OR THE LETTERS A-F, IT IS A HEX STRING; OTHERWISE IT IS THE
C     LOCATION COUNTER.
C
1130  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1140  IF (TY.NE.2)GOTO 1150 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=CVB(CH)
      STACK(STKPTR)=VALPTR+63
      GOTO 1400 
1150  IF (CH.NE.1HA.AND.CH.NE.1HB.AND.CH.NE.1HC.AND.CH.NE.1HD.AND.CH.NE.
     11HE.AND.CH.NE.1HF)GOTO 1160 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=CVB(CH)
      STACK(STKPTR)=VALPTR+63
      GOTO 1400 
1160  VALPTR=VALPTR+1
      VALUE(VALPTR)=LOCCTR
      STACK(STKPTR-1)=VALPTR+63
      IF (IAND(OPTION,OPTREL).EQ.0)GOTO 2090 
      VALUE(VALPTR)=VALUE(VALPTR)+ISL(1,NBITS3)
      IF (LOCCTR.LT.256)GOTO 2090 
      VALUE(VALPTR)=VALUE(VALPTR)+ISL(1,NBITS2)
      GOTO 2090 
C
C     WE PUSHED A SINGLE QUOTE ' INTO THE STACK; FIND THE REST OF
C     THE STRING AND ONE MORE CHARACTER TO DETERMINE ITS TYPE.
C
1170  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1180  IF (CH.NE.1H')GOTO 1190 
      STKPTR=STKPTR-1
      GOTO 1210 
1190  IF (CH.NE.KEOC)GOTO 1200 
      IVAL=99999
      RETURN
1200  TEXT(TXTPTR)=CH
      TXTPTR=TXTPTR+1
      STKPTR=STKPTR-1
      STACK(STKPTR)=STACK(STKPTR)+1
      GOTO 1170 
C
C     WE ENCOUNTERED A ', POSSIBLY THE CLOSING QUOTE OR A DOUBLED
C     QUOTE-IN-QUOTE CONSTRUCT.
C
1210  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1220  IF (CH.EQ.1H')GOTO 1200 
      TXTPTR=TXTPTR-1
      PTR=STACK(STKPTR-1)/256
      LEN=MOD(STACK(STKPTR-1),256)
      IF (LEN.LE.0)GOTO 1260 
      IF (CH.NE.1HB)GOTO 1230 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR)=VALPTR+63
      GOTO 1280 
1230  IF (CH.NE.1HC)GOTO 1240 
      STKPTR=STKPTR-1
      GOTO 2000 
1240  IF (CH.NE.1HO)GOTO 1250 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR)=VALPTR+63
      GOTO 1330 
1250  IF (CH.NE.1HX.AND.CH.NE.1HP)GOTO 2040 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR)=VALPTR+63
      GOTO 1380 
1260  IVAL=99999
      RETURN
C
C     WE GOT A BIT STRING OF THE FORM '...'B, BUT WE STOWED IT AS
C     A TEXT STRING.  CORRECT THAT MISTAKE.
C
1270  PTR=PTR+1
      LEN=LEN-1
      IF (LEN.LE.0)GOTO 2080 
1280  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.1)GOTO 1290 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*2+VAL,6O177777)
      GOTO 1270 
1290  IVAL=99999
      RETURN
C
C     WE GOT A % TO INTRODUCE A BIT STRING (THIS TIME WE DO IT
C     RIGHT THE FIRST TIME).
C
1300  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1310  VAL=CVB(CH)
      IF (VAL.LT.0.OR.VAL.GT.1)GOTO 2090 
      STKPTR=STKPTR-1
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*2+VAL,6O177777)
      GOTO 1300 
C
C     WE GOT AN OCTAL STRING OF THE FORM '...'O, BUT WE STOWED IT
C     AS A TEXT STRING.  CORRECT THAT MISTAKE.
C
1320  PTR=PTR+1
      LEN=LEN-1
      IF (LEN.LE.0)GOTO 2080 
1330  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.7)GOTO 1340 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*8+VAL,6O177777)
      GOTO 1320 
1340  IVAL=99999
      RETURN
C
C     WE GOT A @ TO INTRODUCE AN OCTAL STRING (THIS TIME WE DO IT
C     RIGHT THE FIRST TIME).
C
1350  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1360  VAL=CVB(CH)
      IF (VAL.LT.0.OR.VAL.GT.7)GOTO 2090 
      STKPTR=STKPTR-1
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*8+VAL,6O177777)
      GOTO 1350 
C
C     WE GOT A HEX/PACKED STRING OF THE FORM '...'X OR '...'P, BUT
C     WE STOWED IT AS A TEXT STRING.  CORRECT THAT MISTAKE.
C
1370  PTR=PTR+1
      LEN=LEN-1
      IF (LEN.LE.0)GOTO 2080 
1380  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.15)GOTO 1390 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*16+VAL,6O177777)
      GOTO 1370 
1390  IVAL=99999
      RETURN
C
C     WE GOT A $ TO INTRODUCE A HEX/PACKED STRING (THIS TIME WE
C     DO IT RIGHT THE FIRST TIME).
C
1400  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1410  VAL=CVB(CH)
      IF (VAL.LT.0.OR.VAL.GT.15)GOTO 2090 
      STKPTR=STKPTR-1
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*16+VAL,6O177777)
      GOTO 1400 
C
C     WE GOT A DOUBLE QUOTE " TO START A CHARACTER STRING.  FIND
C     THE END OF THE STRING.
C
1420  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1430  IF (CH.NE.1H")GOTO 1440 
      STKPTR=STKPTR-1
      GOTO 1460 
1440  IF (CH.NE.KEOC)GOTO 1450 
      IVAL=99999
      RETURN
1450  TEXT(TXTPTR)=CH
      TXTPTR=TXTPTR+1
      STKPTR=STKPTR-1
      STACK(STKPTR)=STACK(STKPTR)+1
      GOTO 1420 
C
C     WE GOT A DOUBLE QUOTE WHICH MAY BE A QUOTE-IN-QUOTE OR
C     THE END OF THE STRING
C
1460  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1470  IF (CH.EQ.1H")GOTO 1450 
      TXTPTR=TXTPTR-1
      GOTO 2040 
C
C     WE STARTED WITH A NUMBER, 0-9.  COLLECT UP TO THE NEXT
C     NON-NUMERIC, NON-A-F CHARACTER TO DETERMINE THE TYPE.
C
1480  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1490  IF (TY.NE.2)GOTO 1500 
      TEXT(TXTPTR)=CH
      TXTPTR=TXTPTR+1
      STKPTR=STKPTR-1
      STACK(STKPTR)=STACK(STKPTR)+1
      GOTO 1480 
1500  IF (CH.NE.1HA.AND.CH.NE.1HB.AND.CH.NE.1HC.AND.CH.NE.1HD.AND.CH.NE.
     11HE.AND.CH.NE.1HF)GOTO 1510 
      TEXT(TXTPTR)=CH
      TXTPTR=TXTPTR+1
      STKPTR=STKPTR-1
      STACK(STKPTR)=STACK(STKPTR)+1
      GOTO 1480 
1510  IF (CH.NE.1HK)GOTO 1520 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      PTR=STACK(STKPTR)/256
      LEN=MOD(STACK(STKPTR),256)
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR)=VALPTR+63
      GOTO 1330 
1520  IF (CH.NE.1HP.AND.CH.NE.1HH)GOTO 1530 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      PTR=STACK(STKPTR)/256
      LEN=MOD(STACK(STKPTR),256)
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR)=VALPTR+63
      GOTO 1380 
1530  IF (TEXT(TXTPTR-1).NE.1HB)GOTO 1540 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      PTR=STACK(STKPTR-1)/256
      LEN=MOD(STACK(STKPTR-1),256)-1
      TXTPTR=TXTPTR-LEN-1
      STACK(STKPTR-1)=VALPTR+63
      GOTO 1580 
1540  IF (TEXT(TXTPTR-1).NE.1HD)GOTO 1550 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      PTR=STACK(STKPTR-1)/256
      LEN=MOD(STACK(STKPTR-1),256)-1
      TXTPTR=TXTPTR-LEN-1
      STACK(STKPTR-1)=VALPTR+63
      GOTO 1610 
1550  IF (CH.NE.1HO)GOTO 1560 
      STKPTR=STKPTR-1
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      PTR=STACK(STKPTR)/256
      LEN=MOD(STACK(STKPTR),256)
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR)=VALPTR+63
      GOTO(1810,1830,1820),MOD(LEN,3)+1
1560  VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      PTR=STACK(STKPTR-1)/256
      LEN=MOD(STACK(STKPTR-1),256)
      TXTPTR=TXTPTR-LEN
      STACK(STKPTR-1)=VALPTR+63
      GOTO 1610 
C
C     WE GOT A BIT STRING OF THE FORM ...B, BUT WE STOWED IT AS
C     A TEXT STRING.  CORRECT THAT MISTAKE.
C
1570  PTR=PTR+1
      LEN=LEN-1
      IF (LEN.LE.0)GOTO 2090 
1580  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.1)GOTO 1590 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*2+VAL,6O177777)
      GOTO 1570 
1590  IVAL=99999
      RETURN
C
C     WE GOT A DECIMAL CONSTANT (FANCY THAT!), BUT WE STOWED IT
C     AS A TEXT STRING.  FIX THAT.
C
1600  PTR=PTR+1
      LEN=LEN-1
      IF (LEN.LE.0)GOTO 2090 
1610  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.9)GOTO 1620 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*10+VAL,6O177777)
      GOTO 1600 
1620  IVAL=99999
      RETURN
C
C     WE GOT A B AS A STARTING CHARACTER.  IF THE NEXT CHARACTER
C     IS A ', WE START A BIT STRING; OTHERWISE, WE START A SYMBOL.
C
1630  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1640  IF (CH.NE.1H')GOTO 1930 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      STKPTR=STKPTR-1
      STACK(STKPTR)=VALPTR+63
      LEN=0
C
C     COLLECT THE REST OF THIS BIT STRING, UP TO THE CLOSE '
C
1650  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1660  IF (TY.NE.2)GOTO 1680 
      VAL=CVB(CH)
      IF (VAL.NE.0.AND.VAL.NE.1)GOTO 1670 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*2+VAL,6O177777)
      LEN=LEN+1
      STKPTR=STKPTR-1
      GOTO 1650 
1670  IVAL=99999
      RETURN
1680  IF (CH.NE.1H')GOTO 1670 
      STKPTR=STKPTR-1
      IF (LEN.LE.0)GOTO 1670 
      GOTO 2080 
C
C     WE GOT AN O AS A STARTING CHARACTER.  IF THE NEXT CHARACTER
C     IS A ', WE START AN OCTAL STRING; OTHERWISE, WE START A SYMBOL.
C
1690  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1700  IF (CH.NE.1H')GOTO 1930 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      STKPTR=STKPTR-1
      STACK(STKPTR)=VALPTR+63
      LEN=0
C
C     COLLECT THE REST OF THIS OCTAL STRING, UP TO THE CLOSE '
C
1710  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1720  IF (TY.NE.2)GOTO 1740 
      VAL=CVB(CH)
      IF (VAL.LT.0.OR.VAL.GT.7)GOTO 1730 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*8+VAL,6O177777)
      LEN=LEN+1
      STKPTR=STKPTR-1
      GOTO 1710 
1730  IVAL=99999
      RETURN
1740  IF (CH.NE.1H')GOTO 1730 
      STKPTR=STKPTR-1
      IF (LEN.LE.0)GOTO 1730 
      GOTO 2080 
C
C     WE GOT AN X OR A P AS A STARTING CHARACTER.  IF THE NEXT IS
C     A ', WE START A HEX CONSTANT, OTHERWISE WE START A SYMBOL.
C
1750  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1760  IF (CH.NE.1H')GOTO 1930 
      VALPTR=VALPTR+1
      VALUE(VALPTR)=0
      STKPTR=STKPTR-1
      STACK(STKPTR)=VALPTR+63
      LEN=0
C
C     COLLECT THE REST OF THIS HEX CONSTANT, UP TO THE '
C
1770  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1780  VAL=CVB(CH)
      IF (VAL.LT.0.OR.VAL.GT.15)GOTO 1790 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*16+VAL,6O177777)
      LEN=LEN+1
      STKPTR=STKPTR-1
      GOTO 1770 
1790  IF (CH.NE.1H')GOTO 1800 
      STKPTR=STKPTR-1
      IF (LEN.LE.0)GOTO 1800 
      GOTO 2080 
1800  IVAL=99999
      RETURN
C
C     WE GOT A SPLIT OCTAL CONSTANT, STOWED AS TEXT
C
1810  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.3)GOTO 1840 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*4+VAL,6O177777)
      PTR=PTR+1
      LEN=LEN-1
1820  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.7)GOTO 1840 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*8+VAL,6O177777)
      PTR=PTR+1
      LEN=LEN-1
1830  VAL=CVB(TEXT(PTR))
      IF (VAL.LT.0.OR.VAL.GT.7)GOTO 1840 
      VALUE(VALPTR)=IAND(VALUE(VALPTR)*8+VAL,6O177777)
      PTR=PTR+1
      LEN=LEN-1
      IF (LEN.LE.0)GOTO 2080 
      GOTO 1810 
1840  IVAL=99999
      RETURN
C
C     WE GOT A C AS A STARTING CHARACTER.  IF THE NEXT CHARACTER
C     IS A ', WE START A TEXT CONSTANT; OTHERWISE, WE START A SYMBOL.
C
1850  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1860  IF (CH.NE.1H')GOTO 1930 
      TXTPTR=TXTPTR+1
      STKPTR=STKPTR-1
      STACK(STKPTR)=256*TXTPTR
C
C     COLLECT THE REST OF THE TEXT, UP TO THE CLOSING '
C
1870  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1880  IF (CH.NE.1H')GOTO 1890 
      STKPTR=STKPTR-1
      GOTO 1910 
1890  IF (CH.NE.KEOC)GOTO 1900 
      IVAL=99999
      RETURN
1900  TEXT(TXTPTR)=CH
      TXTPTR=TXTPTR+1
      STKPTR=STKPTR-1
      STACK(STKPTR)=STACK(STKPTR)+1
      GOTO 1870 
C
C     WE GOT A ', WHICH MAY BE THE CLOSE ' OR A QUOTE-IN-QUOTE
C
1910  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1920  IF (CH.EQ.1H')GOTO 1900 
      GOTO 2040 
C
C     WE HAVE TWO CHARACTERS OF A SYMBOL, SO STOW IT IN THE
C     SYMBOL TABLE.
C
1930  HISYM=HISYM+1
      IF (HISYM.GT.1000)GOTO 2550 
      SYMBOL(1,HISYM)=0
      SYMBOL(2,HISYM)=0
      SYMBOL(3,HISYM)=0
      SYMBOL(4,HISYM)=0
      SYMBOL(5,HISYM)=0
      CALL PACK(SYMBOL(1,HISYM),STACK(STKPTR-1))
      STACK(STKPTR-1)=HISYM+16383
      IF (TY.NE.1.AND.TY.NE.2)GOTO 1940 
      CALL PACK(SYMBOL(1,HISYM),CH)
      STKPTR=STKPTR-1
      GOTO 1960 
1940  VALPTR=VALPTR+1
      PTR=LOOKUP(SYMBOL(1,HISYM))
      IF (PTR.LT.HISYM)HISYM=HISYM-1
      IF (PASS.GT.0.AND.IAND(SYMBOL(3,PTR),11).EQ.0)ERRORS=IOR(ERRORS,
     1ERRU)
      VALUE(VALPTR)=SYMBOL(4,PTR)
      STACK(STKPTR-1)=VALPTR+63
      IF (IAND(SYMBOL(3,PTR),OPTREL).EQ.0)GOTO 1950 
      VALUE(VALPTR)=VALUE(VALPTR)+ISL(1,NBITS3)+IAND(SYMBOL(3,PTR),ISL(
     1-1,NBITS2))
1950  IF (PASS.NE.2.OR.IAND(OPTION,OPTXR).EQ.0)GOTO 2090 
      XRBUF(1)=LNCNT
      XRBUF(2)=IUNIT
      XRBUF(3)=SYMBOL(5,PTR)
      XRBUF(4)=OPCODE(1)
      XRBUF(5)=OPCODE(2)
      SYMBOL(5,PTR)=XRREC
      WRITE (XRUNIT,REC=XRREC)XRBUF
      XRREC=XRREC+1
      GOTO 2090 
C
C     WE HAVEN'T FOUND THE END OF THE SYMBOL YET
C
1960  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
1970  IF (TY.NE.1.AND.TY.NE.2)GOTO 1980 
      CALL PACK(SYMBOL(1,HISYM),CH)
      STKPTR=STKPTR-1
      GOTO 1960 
1980  VALPTR=VALPTR+1
      PTR=LOOKUP(SYMBOL(1,HISYM))
      IF (PTR.LT.HISYM)HISYM=HISYM-1
      IF (PASS.GT.0.AND.IAND(SYMBOL(3,PTR),11).EQ.0)ERRORS=IOR(ERRORS,
     1ERRU)
      VALUE(VALPTR)=SYMBOL(4,PTR)
      STACK(STKPTR-1)=VALPTR+63
      IF (IAND(SYMBOL(3,PTR),OPTREL).EQ.0)GOTO 1990 
      VALUE(VALPTR)=VALUE(VALPTR)+ISL(1,NBITS3)+IAND(SYMBOL(3,PTR),ISL(
     1-1,NBITS2))
1990  IF (PASS.NE.2.OR.IAND(OPTION,OPTXR).EQ.0)GOTO 2090 
      XRBUF(1)=LNCNT
      XRBUF(2)=IUNIT
      XRBUF(3)=SYMBOL(5,PTR)
      XRBUF(4)=OPCODE(1)
      XRBUF(5)=OPCODE(2)
      SYMBOL(5,PTR)=XRREC
      WRITE (XRUNIT,REC=XRREC)XRBUF
      XRREC=XRREC+1
      GOTO 2090 
C
C     VALIDATE/EVALUATE THE TEXT STRING ON THE TOP OF THE STACK.
C     IF IT IS ONE OR TWO CHARACTERS LONG, TREAT IT LIKE A VALUE.
C
2000  PTR=STACK(STKPTR)/256
      LEN=MOD(STACK(STKPTR),256)
      IF (LEN.GE.3)GOTO 2020 
      IF (LEN.GT.0)GOTO 2010 
      IVAL=99999
      RETURN
2010  VALPTR=VALPTR+1
      STACK(STKPTR)=VALPTR+63
      VALUE(VALPTR)=IAND(ISL(ASCII(TEXT(PTR)),MBITS3),255)
      IF (LEN.EQ.2)VALUE(VALPTR)=VALUE(VALPTR)*256+IAND(ISL(ASCII(TEXT
     1(PTR+1)),MBITS3),255)
      TXTPTR=TXTPTR-LEN
      GOTO 2080 
2020  DO 2030 PTR=PTR,PTR+LEN-1
2030  TEXT(PTR)=ASCII(TEXT(PTR))
      GOTO 2080 
C
C     DO THE SAME AS ABOVE, ONLY WITH THE STRING ONE LEVEL BELOW
C     TOP OF THE STACK.
C
2040  PTR=STACK(STKPTR-1)/256
      LEN=MOD(STACK(STKPTR-1),256)
      IF (LEN.GE.3)GOTO 2060 
      IF (LEN.GT.0)GOTO 2050 
      IVAL=99999
      RETURN
2050  VALPTR=VALPTR+1
      STACK(STKPTR-1)=VALPTR+63
      VALUE(VALPTR)=IAND(ISL(ASCII(TEXT(PTR)),MBITS3),255)
      IF (LEN.EQ.2)VALUE(VALPTR)=VALUE(VALPTR)*256+IAND(ISL(ASCII(TEXT
     1(PTR+1)),MBITS3),255)
      TXTPTR=TXTPTR-LEN
      GOTO 2090 
2060  DO 2070 PTR=PTR,PTR+LEN-1
2070  TEXT(PTR)=ASCII(TEXT(PTR))
      GOTO 2090 
C
C     EVALUATE THE PARTIAL EXPRESSION ON THE TOP OF THE STACK,
C     IF POSSIBLE.
C
2080  CALL NXTCHR(CH,TY)
      STKPTR=STKPTR+1
      STACK(STKPTR)=CH
2090  IF (STKPTR.LE.2)GOTO 2100 
      IF (STACK(STKPTR-2).NE.KPMI.OR.STACK(STKPTR-1).LT.64)GOTO 2100 
      STKPTR=STKPTR-1
      STACK(STKPTR-1)=STACK(STKPTR)
      PTR=STACK(STKPTR-1)-63
      A=IAND(VALUE(PTR),6O177777)
      B=IAND(VALUE(PTR),ISL(-1,NBITS2))
      A=IAND(-A,6O177777)
      IF (B.NE.0)B=ISL(-ISL(B,MBITS3),NBITS3)+ISL(ISL(B,NBITS),MBITS)
      VALUE(PTR)=A+B
      STACK(STKPTR)=STACK(STKPTR+1)
      GOTO 2090 
2100  IF (CH.EQ.1H<)GOTO 2120 
      IF (CH.EQ.1H>)GOTO 2160 
      IF (CH.EQ.1H~)GOTO 2200 
      IF (CH.EQ.1H|)GOTO 2220 
      IF (CH.EQ.1H])STACK(STKPTR)=KRPR
      IF (CH.EQ.1H*)STACK(STKPTR)=KMLT
      IF (CH.EQ.1H/)STACK(STKPTR)=KDIV
      IF (CH.EQ.1H\)STACK(STKPTR)=KMOD
      IF (CH.EQ.1H+)STACK(STKPTR)=KADD
      IF (CH.EQ.1H-)STACK(STKPTR)=KSUB
      IF (CH.EQ.1H=)STACK(STKPTR)=KEQL
      IF (CH.EQ.1H&)STACK(STKPTR)=KAND
      IF (STKPTR.LE.2)GOTO 1000 
      IF (STACK(STKPTR-2).NE.KLPR.OR.STACK(STKPTR-1).LT.64.OR.STACK(
     1STKPTR).NE.KRPR)GOTO 2110 
      STKPTR=STKPTR-2
      STACK(STKPTR)=STACK(STKPTR+1)
      GOTO 2080 
2110  IF (STACK(STKPTR).EQ.KRPR)GOTO 2250 
      IF (STACK(STKPTR-2).GT.KEOC.OR.STACK(STKPTR-1).LT.64.OR.STACK
     1(STKPTR).GT.KEOC)GOTO 1000 
      GOTO 2240 
C
C     GET CHARACTER FOLLOWING < FOR POSSIBLE COMPOUND
C
2120  CALL NXTCHR(CH,TY)
      IF (CH.NE.1H<)GOTO 2130 
      STACK(STKPTR)=KASL
      CH=0
      GOTO 2110 
2130  IF (CH.NE.1H=)GOTO 2140 
      STACK(STKPTR)=KLEQ
      CH=0
      GOTO 2110 
2140  IF (CH.NE.1H>)GOTO 2150 
      STACK(STKPTR)=KNEQ
      CH=0
      GOTO 2110 
2150  STACK(STKPTR)=KLSS
      CURPOS=CURPOS-1
      GOTO 2110 
C
C     GET CHARACTER FOLLOWING > FOR POSSIBLE COMPOUND
C
2160  CALL NXTCHR(CH,TY)
      IF (CH.NE.1H>)GOTO 2170 
      STACK(STKPTR)=KASR
      CH=0
      GOTO 2110 
2170  IF (CH.NE.1H=)GOTO 2180 
      STACK(STKPTR)=KGEQ
      CH=0
      GOTO 2110 
2180  IF (CH.NE.1H<)GOTO 2190 
      STACK(STKPTR)=KNEQ
      CH=0
      GOTO 2110 
2190  STACK(STKPTR)=KGTR
      CURPOS=CURPOS-1
      GOTO 2110 
C
C     GET CHARACTER FOLLOWING ~ FOR POSSIBLE COMPOUND
C
2200  CALL NXTCHR(CH,TY)
      IF (CH.NE.1H=)GOTO 2210 
      STACK(STKPTR)=KNEQ
      CH=0
      GOTO 2110 
2210  IVAL=99999
      RETURN
C
C     GET CHARACTER FOLLOWING | FOR POSSIBLE COMPOUND
C
2220  CALL NXTCHR(CH,TY)
      IF (CH.NE.1H|)GOTO 2230 
      STACK(STKPTR)=KEOR
      CH=0
      GOTO 2110 
2230  STACK(STKPTR)=KIOR
      CURPOS=CURPOS-1
      GOTO 2110 
C
C     GO TO ROUTINE BASED ON TOP TWO OPERANDS ON STACK
C
2240  GOTO(2250,2260,2270,2280,2300),ACTION(STACK(STKPTR-2),STACK(STKPT
     1R))
C
C     EXECUTE A OP B
C
2250  PTR=STACK(STKPTR-1)-63
      IF (PTR.LE.0.OR.PTR.GT.64)GOTO 2300 
      B=IAND(VALUE(PTR),6O177777)
      BREL=ISL(VALUE(PTR),MBITS3)
      BBAS=ISL(ISL(VALUE(PTR),NBITS),MBITS3)
      OP=STACK(STKPTR-2)
      STACK(STKPTR-2)=STACK(STKPTR)
      STKPTR=STKPTR-2
      PTR=STACK(STKPTR-1)-63
      IF (PTR.LE.0.OR.PTR.GT.64)GOTO 2300 
      A=IAND(VALUE(PTR),6O177777)
      AREL=ISL(VALUE(PTR),MBITS3)
      ABAS=ISL(ISL(VALUE(PTR),NBITS),MBITS3)
      GOTO(2310,2320,2340,2360,2380,2400,2410,2420,2430,2440,2450,2460,
     12470,2480,2490,2500,2510,2520),OP
C
C     WE NEED MORE INFORMATION
C
2260  GOTO 1000 
C
C     EXECUTE OP B (~ IS THE ONLY CASE)
C
2270  STACK(STKPTR-2)=STACK(STKPTR-1)
      STACK(STKPTR-1)=STACK(STKPTR)
      STKPTR=STKPTR-1
      PTR=STACK(STKPTR-1)-63
      IF (PTR.LE.0.OR.PTR.GT.64)GOTO 2300 
      A=IAND(VALUE(PTR),6O177777)
      B=IAND(VALUE(PTR),ISL(-1,NBITS2))
      IF (B.NE.0)ERRORS=IOR(ERRORS,ERRR)
      VALUE(PTR)=IEOR(A,6O177777)
      GOTO 2090 
C
C     DONE; RETURN VALUE AT TOP OF STACK
C
2280  IF (STACK(STKPTR-1).GT.256)GOTO 2290 
      IVAL=IAND(VALUE(STACK(STKPTR-1)-63),6O177777)
      RELOC=ISA(VALUE(STACK(STKPTR-1)-63),MBITS3)
      RELBAS=ISL(ISL(VALUE(STACK(STKPTR-1)-63),NBITS),MBITS3)
      IF (RELOC.GE.-1.AND.RELOC.LE.1)RETURN
      ERRORS=IOR(ERRORS,ERRR)
      RELOC=0
      RELBAS=0
      RETURN
2290  IVAL=-MOD(STACK(STKPTR-1),128)
      RELOC=0
      RELBAS=0
      RETURN
C
C     ERROR
C
2300  IVAL=99999
      RETURN
C
C     A * B
C
2310  VALUE(PTR)=IAND(A*B,6O177777)
      GOTO 2530 
C
C     A / B
C
2320  IF (B.NE.0)GOTO 2330 
      B=1
      IF (PASS.EQ.2)ERRORS=IOR(ERRORS,ERRT)
2330  VALUE(PTR)=IAND(A/B,6O177777)
      GOTO 2530 
C
C     A \ B (MOD)
C
2340  IF (B.NE.0)GOTO 2350 
      B=1
      IF (PASS.EQ.2)ERRORS=IOR(ERRORS,ERRT)
2350  VALUE(PTR)=IAND(A-B*(A/B),6O177777)
      GOTO 2530 
C
C     A + B
C
2360  VALUE(PTR)=IAND(A+B,6O177777)
      IF (AREL.EQ.0.OR.BREL.EQ.0)GOTO 2370 
      IF (ABAS.EQ.BBAS)GOTO 2370 
      ERRORS=IOR(ERRORS,ERRR)
      AREL=0
      BREL=0
2370  AREL=AREL+BREL
      IF (ABAS.EQ.0)ABAS=BBAS
      IF (AREL.EQ.0)ABAS=0
      VALUE(PTR)=VALUE(PTR)+ISL(AREL,NBITS3)+ISL(ABAS,NBITS2)
      GOTO 2090 
C
C     A - B
C
2380  VALUE(PTR)=IAND(A-B,6O177777)
      IF (AREL.EQ.0.OR.BREL.EQ.0)GOTO 2390 
      IF (ABAS.EQ.BBAS)GOTO 2390 
      ERRORS=IOR(ERRORS,ERRR)
      AREL=0
      BREL=0
2390  AREL=AREL-BREL
      IF (ABAS.EQ.0)ABAS=BBAS
      IF (AREL.EQ.0)ABAS=0
      VALUE(PTR)=VALUE(PTR)+ISL(AREL,NBITS3)+ISL(ABAS,NBITS2)
      GOTO 2090 
C
C     A << B (SHIFT LEFT)
C
2400  VALUE(PTR)=IAND(ISL(A,B),6O177777)
      GOTO 2530 
C
C     A >> B (SHIFT RIGHT)
C
2410  VALUE(PTR)=IAND(ISL(A,-B),6O177777)
      GOTO 2530 
C
C     A < B
C
2420  VALUE(PTR)=0
      IF (TRUVAL(A).LT.TRUVAL(B))VALUE(PTR)=65535
      GOTO 2540 
C
C     A <= B
C
2430  VALUE(PTR)=0
      IF (TRUVAL(A).LE.TRUVAL(B))VALUE(PTR)=65535
      GOTO 2540 
C
C     A = B
C
2440  VALUE(PTR)=0
      IF (A.EQ.B)VALUE(PTR)=65535
      GOTO 2540 
C
C     A <> B
C
2450  VALUE(PTR)=0
      IF (A.NE.B)VALUE(PTR)=65535
      GOTO 2540 
C
C     A >= B
C
2460  VALUE(PTR)=0
      IF (TRUVAL(A).GE.TRUVAL(B))VALUE(PTR)=65535
      GOTO 2540 
C
C     A > B
C
2470  VALUE(PTR)=0
      IF (TRUVAL(A).GT.TRUVAL(B))VALUE(PTR)=65535
      GOTO 2540 
C
C     (ERROR)
C
2480  GOTO 2300 
C
C     A & B
C
2490  VALUE(PTR)=IAND(A,B)
      GOTO 2530 
C
C     A | B
C
2500  VALUE(PTR)=IOR(A,B)
      GOTO 2530 
C
C     A || B (EXCLUSIVE OR)
C
2510  VALUE(PTR)=IEOR(A,B)
      GOTO 2530 
C
C     (ERROR)
C
2520  GOTO 2300 
C
C     EVALUATE RELOCATABILITY FOR ALL BUT + - AND RELATIONS
C
2530  IF (AREL.NE.0.OR.BREL.NE.0)ERRORS=IOR(ERRORS,ERRR)
      GOTO 2090 
C
C     EVALUATE RELOCATABILITY FOR RELATIONS
C
2540  IF (AREL.NE.BREL.OR.ABAS.NE.BBAS)ERRORS=IOR(ERRORS,ERRR)
      GOTO 2090 
C
C     SYMBOL TABLE OVERFLOW - ABORT EVALUATION
C
2550  WRITE (LOUINT,9000)
      IVAL=99999
      RETURN
C
C     END OF MODULE
C
9000  FORMAT(' ***LABEL TABLE OVERFLOW***')
      END 
      SUBROUTINE PACK(INAME,ICH)
C
C     PACK CHARACTER ICH INTO CELL INAME
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION INAME(1)
      CH=ISL(ICH,MBITS3)
      MASK=2**NBITS-1
      DO 1000 I=1,4
         IF (IAND(INAME(1),ISL(MASK,NBITS*(4-I))).EQ.0)GOTO 1020 
1000  CONTINUE 
      DO 1010 I=1,4
         IF (IAND(INAME(2),ISL(MASK,NBITS*(4-I))).EQ.0)GOTO 1030 
1010  CONTINUE 
      RETURN
1020  INAME(1)=INAME(1)+ISL(CH,NBITS*(4-I))
      RETURN
1030  INAME(2)=INAME(2)+ISL(CH,NBITS*(4-I))
      RETURN
      END 
      FUNCTION CVB(ICH)
C
C     CONVERT THE CHARACTER ICH TO ITS NUMERIC VALUE, 0-15, OR -1
C
      IMPLICIT INTEGER(A-Z)
      DIMENSION DEC(16)
      DATA DEC/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,
     1         1H8,1H9,1HA,1HB,1HC,1HD,1HE,1HF/
      DO 1000 I=1,16
         IF (ICH.EQ.DEC(I))GOTO 1010 
1000  CONTINUE 
      CVB=-1
      RETURN
1010  CVB=I-1
      RETURN
      END 
      SUBROUTINE NXTCHR(ICH,ITY)
C
C     FETCH THE NEXT CHARACTER FROM INPBUF @CURPOS AND RETURN
C     IT IN ICH; LOOK IT UP IN CH AND RETURN ITS TYPE IN ITY.
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION CH(95),TY(95)
      DATA CH/1H ,1HA,1HB,1HC,1HD,1HE,1HF,1HG,
     1        1HH,1HI,1HJ,1HK,1HL,1HM,1HN,1HO,
     2        1HP,1HQ,1HR,1HS,1HT,1HU,1HV,1HW,
     3        1HX,1HY,1HZ,1H0,1H1,1H2,1H3,1H4,
     4        1H5,1H6,1H7,1H8,1H9,1H.,1H:,1H_,
     5        1H+,1H-,1H*,1H/,1H\,1H&,1H|,1H',
     6        1H",1H#,1H$,1H%,1H(,1H),1H,,1H;,
     7        1H<,1H=,1H>,1H@,1H[,1H],1H~,1Ha,
     8        1Hb,1Hc,1Hd,1He,1Hf,1Hg,1Hh,1Hi,
     9        1Hj,1Hk,1Hl,1Hm,1Hn,1Ho,1Hp,1Hq,
     A        1Hr,1Hs,1Ht,1Hu,1Hv,1Hw,1Hx,1Hy,
     1        1Hz,1H{,1H},1H`,1H^,1H?,1H!/
      DATA TY/  0,  1,  1,  1,  1,  1,  1,  1,
     1          1,  1,  1,  1,  1,  1,  1,  1,
     2          1,  1,  1,  1,  1,  1,  1,  1,
     3          1,  1,  1,  2,  2,  2,  2,  2,
     4          2,  2,  2,  2,  2,  1,  1,  1,
     5          3,  3,  3,  3,  3,  3,  3,  3,
     6          3,  4,  3,  3,  5,  5,  6,  7,
     7          3,  3,  3,  3,  3,  3,  3,  1,
     8          1,  1,  1,  1,  1,  1,  1,  1,
     9          1,  1,  1,  1,  1,  1,  1,  1,
     A          1,  1,  1,  1,  1,  1,  1,  1,
     1          1,  9,  9,  9,  9,  9,  9/
      IF (CURPOS.LE.ARS.AND.CURPOS.GE.1)GOTO 1000 
      ICH=KEOC
      ITY=-1
      CURPOS=CURPOS+1
      RETURN
1000  JCH=INPBUF(CURPOS)
      ICH=JCH
      CURPOS=CURPOS+1
      DO 1010 I=1,95
         IF (JCH.EQ.CH(I))GOTO 1020 
1010  CONTINUE 
      ITY=-1
      ICH=KEOC
      RETURN
1020  ITY=TY(I)
      RETURN
      END 
      FUNCTION TRUVAL(I)
C
C     EXTEND THE SIGN OF I TO MAKE IT A TRUE VALUE
C
      IMPLICIT INTEGER(A-Z)
      IF (IAND(I,65535).LE.32767)GOTO 1000 
      TRUVAL=IAND(I,65535)-65536
      RETURN
1000  TRUVAL=IAND(I,65535)
      RETURN
      END 
      FUNCTION LOOKUP(ISYM)
C
C     LOOK UP SYMBOL ISYM IN SYMBOL TABLE AND RETURN INDEX
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION ISYM(4)
      DO 1000 I=1,HISYM
         IF (SYMBOL(1,I).EQ.ISYM(1).AND.SYMBOL(2,I).EQ.ISYM(2))GOTO 101
     1      0 
1000  CONTINUE 
      LOOKUP=-1
      RETURN
1010  LOOKUP=I
      IF (IAND(SYMBOL(3,I),11).EQ.0)ERRORS=IAND(ERRORS,ERRU)
      RETURN
      END 
      SUBROUTINE READSI
      IMPLICIT INTEGER (A-Z)
C
C     READ AN IMAGE FROM EITHER SI, THE INTERMEDIATE FILE, AN INCLUDE
C     FILE, OR A MACRO EXPANSION.  IF READING FROM THE MACRO FILE, DO
C     ARGUMENT SUBSTITUTION.  RETURN THE LINE IN INPBUF AND THE LENGTH
C     IN ARS.  SET ARS TO 0 ON EOF ON SI OR TM; TO -1 ON AN ERROR.
C
      INCLUDE ASM6502_C1
      DIMENSION LOCBUF(256)
C
C     PROCESSING A MACRO?
C
      IF (IUNIT.NE.MCUNIT)GOTO 1200 
C
C     READ FROM THE MACRO (INTERMEDIATE) FILE
C
      MCREC=MCREC+1
      READ (IUNIT,9000,REC=MCREC,ERR=1190)INPBUF
      LNCNT=LNCNT+1
      ARS=256
      I=11
1000  I=I-1
      IF (I.LT.1)GOTO 1160 
      IF (IUSTK(I).EQ.0)GOTO 1000 
      IF (I.EQ.1.AND.IUSTK(2).EQ.INUNIT)GOTO 1160 
      PTR=1
      CURPOS=1
      CALL NXTCHR(CH,TY)
      IF (CH.EQ.1H*)GOTO 1090 
1010  IF (CH.EQ.KEOC)GOTO 1140 
      IF (CH.EQ.1H;.OR.CH.EQ.1H!)GOTO 1090 
      IF (CH.EQ.1H')GOTO 1100 
      IF (CH.EQ.1H")GOTO 1110 
      IF (TY.EQ.2.OR.CH.EQ.1H$.OR.CH.EQ.1H%.OR.CH.EQ.1H@)GOTO 1130 
      IF (TY.NE.1)GOTO 1070 
      J=CURPOS-1
      LABEL(1)=0
      LABEL(2)=0
1020  CALL PACK(LABEL(1),CH)
      CALL NXTCHR(CH,TY)
      IF (CH.NE.1H:.OR.LABEL(1).EQ.0)GOTO 1030 
      K=CH
      CALL NXTCHR(CH,TY)
      IF (TY.NE.1.AND.TY.NE.2)GOTO 1030 
      CALL PACK(LABEL(1),K)
      GOTO 1020 
1030  IF (TY.EQ.1.OR.TY.EQ.2)GOTO 1020 
      IF (CH.EQ.1H'.OR.CH.EQ.1H".OR.CH.EQ.1H$.OR.CH.EQ.1H%.OR.CH.EQ.1H@)
     1GOTO 1080 
      DO 1040 K=1,7
1040  CALL PACK(LABEL(1),BLANK)
      K=0
1050  K=K+1
      IF (K.GT.32)GOTO 1120 
      IF (MCPTR(K,I).EQ.0)GOTO 1120 
      IF (MCDUM(1,K,I).NE.LABEL(1).OR.MCDUM(2,K,I).NE.LABEL(2))GOTO 10
     150 
      M=MCPTR(K,I)
      L=MCLEN(K,I)
1060  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=MCHEAD(M,I)
      PTR=PTR+1
      M=M+1
      L=L-1
      IF (L.GT.0)GOTO 1060 
1070  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=CH
      PTR=PTR+1
      CALL NXTCHR(CH,TY)
      GOTO 1010 
1080  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=INPBUF(J)
      PTR=PTR+1
      J=J+1
      IF (J.LT.CURPOS-1)GOTO 1080 
      GOTO 1010 
1090  IF (PTR.GT.256.OR.CH.EQ.KEOC)GOTO 1140 
      LOCBUF(PTR)=CH
      PTR=PTR+1
      CALL NXTCHR(CH,TY)
      GOTO 1090 
1100  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=CH
      PTR=PTR+1
      CALL NXTCHR(CH,TY)
      IF (CH.EQ.KEOC)GOTO 1140 
      IF (CH.NE.1H')GOTO 1100 
      GOTO 1130 
1110  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=CH
      PTR=PTR+1
      CALL NXTCHR(CH,TY)
      IF (CH.EQ.KEOC)GOTO 1140 
      IF (CH.NE.1H")GOTO 1110 
      GOTO 1130 
1120  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=INPBUF(J)
      PTR=PTR+1
      J=J+1
      IF (J.LT.CURPOS-1)GOTO 1120 
      GOTO 1070 
1130  IF (PTR.GT.256)GOTO 1140 
      LOCBUF(PTR)=CH
      PTR=PTR+1
      CALL NXTCHR(CH,TY)
      IF (CH.EQ.KEOC)GOTO 1140 
      IF (CH.EQ.1H!.OR.CH.EQ.1H;)GOTO 1090 
      IF (CH.EQ.1H')GOTO 1100 
      IF (CH.EQ.1H")GOTO 1110 
      IF (TY.EQ.1.OR.TY.EQ.2.OR.CH.EQ.1H$.OR.CH.EQ.1H%.OR.CH.EQ.1H@)
     1GOTO 1130 
      GOTO 1070 
1140  DO 1150 PTR=1,256
1150  INPBUF(PTR)=LOCBUF(PTR)
      GOTO 1000 
1160  LABEL(1)=0
      LABEL(2)=0
      I=257
1170  I=I-1
      IF (I.LE.1)GOTO 1180 
      IF (INPBUF(I).EQ.1H )GOTO 1170 
1180  ARS=I
      RETURN
C
C     UNEXPECTED END-OF-FILE
C
1190  ARS=-1
      RETURN
C
C     READ FROM SI, IN, OR TM FILE
C
1200  READ (IUNIT,9000,END=1230)INPBUF
      LNCNT=LNCNT+1
      I=257
1210  I=I-1
      IF (I.LE.1)GOTO 1220 
      IF (INPBUF(I).EQ.1H )GOTO 1210 
1220  ARS=I
      RETURN
C
C     IF EOF ON INCLUDE UNIT, SWITCH BACK TO SI
C
1230  IF (IUNIT.NE.INUNIT)GOTO 1240 
      CLOSE (IUNIT)
      IUNIT=IUSTK(1)
      LNCNT=LNSTK(1)
      IUSTK(1)=0
      LNSTK(1)=0
      GOTO 1200 
C
C     END OF FILE ON SI OR TM FILE
C
1240  ARS=0
      RETURN
9000  FORMAT(256A1)
      END 
      SUBROUTINE GETOPT
C
C     ACQUIRE THE OPTIONS FROM THE USER'S INPUT LINE, SET THE TIME
C     AND DATE, AND RECORD THE CURRENT CPU TIME.  THIS ROUTINE IS
C     HIGHLY MACHINE-DEPENDENT.
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION OPTLST(128)
      CALL ACPU(CPU1)
      CALL CLK$(TIME)
      CALL DAT$(DATE)
      CALL PEEKAT(OPTLST,LOWID,LOLIM)
      CALL STOWOP(OPTLST,128)
      RETURN
      END 
      SUBROUTINE STOWOP(OPTLST,NCH)
C
C     DECODE AND STOW OPTIONS
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION OPTLST(1)
      PTR=0
      SRIDX=0
1000  PTR=PTR+1
      IF (PTR.GT.NCH)RETURN
      IF (OPTLST(PTR).EQ.1H )GOTO 1000 
      NO=0
      IF (OPTLST(PTR).NE.1HN)GOTO 1010 
      NO=1
      PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1060 
1010  IF (OPTLST(PTR).LT.1HA.OR.OPTLST(PTR).GT.1HZ)GOTO 1060 
      CH1=OPTLST(PTR)
1020  PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1040 
      IF ((OPTLST(PTR).LT.1HA.OR.OPTLST(PTR).GT.1HZ).AND.(OPTLST(PTR)
     1.LT.1H0.OR.OPTLST(PTR).GT.1H9))GOTO 1060 
      CH2=OPTLST(PTR)
1030  PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1040 
      IF (OPTLST(PTR).GE.1HA.AND.OPTLST(PTR).LE.1HZ)GOTO 1030 
1040  IF (CH1.EQ.1HL.AND.CH2.EQ.1HS)GOTO 1070 
      IF (CH1.EQ.1HX.AND.CH2.EQ.1HR)GOTO 1080 
      IF (CH1.EQ.1HO.AND.CH2.EQ.1HU)GOTO 1090 
      IF (CH1.EQ.1HS.AND.CH2.EQ.1HC)GOTO 1100 
      IF (CH1.EQ.1HA.AND.CH2.EQ.1HB)GOTO 1110 
      IF (CH1.EQ.1HR.AND.CH2.EQ.1HE)GOTO 1120 
      IF (CH1.EQ.1HS.AND.CH2.EQ.1HR)GOTO 1130 
      IF (CH1.EQ.1HH.AND.CH2.EQ.1HE)GOTO 1220 
      IF (CH1.EQ.1HO.AND.CH2.EQ.1HC)GOTO 1230 
      IF (CH1.EQ.1HA.AND.CH2.EQ.1HO)GOTO 1240 
      IF (CH1.EQ.1HC.AND.CH2.EQ.1HL)GOTO 1260 
      IF (CH1.EQ.1HC)GOTO 1200 
      IF (CH1.EQ.1HP)GOTO 1210 
1050  IF (PASS.LT.0)WRITE (LOUNIT,9000)NO,CH1,CH2
      ERRORS=IOR(ERRORS,ERRS)
      GOTO 1000 
1060  IF (PASS.LT.0)WRITE (LOUNIT,9010)PTR
      ERRORS=IOR(ERRORS,ERRS)
      GOTO 1000 
1070  OPTION=IOR(OPTION,OPTLS)
      IF (NO.EQ.1)OPTION=IEOR(OPTION,OPTLS)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1080  OPTION=IOR(OPTION,OPTXR)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1090  OPTION=IOR(OPTION,OPTOU)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1100  OPTION=IOR(OPTION,OPTSC)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1110  IF (NO.NE.0)GOTO 1050 
      OPTION=IEOR(IOR(OPTION,OPTREL),OPTREL)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1120  IF (NO.NE.0)GOTO 1050 
      OPTION=IOR(OPTION,OPTREL)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1130  IF (NO.NE.0)GOTO 1050 
      SRIDX=SRIDX+1
1140  IF (OPTLST(PTR).EQ.1H()GOTO 1150 
      IF (OPTLST(PTR).NE.1H )GOTO 1060 
      PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1060 
      GOTO 1140 
1150  SRACCT(1,SRIDX)=0
      SRACCT(2,SRIDX)=0
1160  PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1060 
      IF (OPTLST(PTR).EQ.1H..OR.OPTLST(PTR).EQ.1H )GOTO 1160 
      IF (OPTLST(PTR).EQ.1H,)GOTO 1170 
      IF (OPTLST(PTR).EQ.1H))GOTO 1190 
      CALL PACK(SRACCT(1,SRIDX),OPTLST(PTR))
      GOTO 1160 
1170  DO 1180 I=1,7
1180  CALL PACK(SRACCT(1,SRIDX),1H )
      SRIDX=SRIDX+1
      IF (SRIDX.GT.8)GOTO 1060 
      GOTO 1150 
1190  PTR=PTR+1
      IF (PTR.GT.NCH)RETURN
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1200  IF (CH2.LT.1H0.OR.CH2.GT.1H4)GOTO 1050 
      IF (NO.NE.0)GOTO 1050 
      IF (CH2.EQ.1H0)CLOCK=0
      IF (CH2.EQ.1H1)CLOCK=100
      IF (CH2.EQ.1H2)CLOCK=200
      IF (CH2.EQ.1H3)CLOCK=300
      IF (CH2.EQ.1H4)CLOCK=400
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1210  IF (CH2.NE.1H0.AND.CH2.NE.1H1.AND.CH2.NE.1H2.AND.CH2.NE.1H3.AND
     1.CH2.NE.1HS.AND.CH2.NE.1HN.AND.CH2.NE.1HE.AND.CH2.NE.1HO.AND.CH2
     2.NE.1HM)GOTO 1050 
      IF (NO.NE.0)GOTO 1050 
      IF (CH2.EQ.1H0.OR.CH2.EQ.1HS.OR.CH2.EQ.1HN)PARITY=0
      IF (CH2.EQ.1H1.OR.CH2.EQ.1HE)PARITY=1
      IF (CH2.EQ.1H2.OR.CH2.EQ.1HO)PARITY=2
      IF (CH2.EQ.1H3.OR.CH2.EQ.1HM)PARITY=3
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1220  IF (NO.NE.0)GOTO 1050 
      OPTION=IEOR(IOR(OPTION,OPTOC),OPTOC)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1230  IF (NO.NE.0)GOTO 1050 
      OPTION=IOR(OPTION,OPTOC)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1240  IF (NO.EQ.0)GOTO 1250 
      OPTION=IEOR(IOR(OPTION,OPTAO),OPTAO)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1250  OPTION=IOR(OPTION,OPTAO)
      IF (OPTLST(PTR).EQ.1H,.OR.OPTLST(PTR).EQ.1H )GOTO 1000 
      GOTO 1060 
1260  IF (NO.NE.0)GOTO 1050 
      IP=0
      FP=0
      FD=1
      CH=OPTLST(PTR)
1270  IF (CH.EQ.1H=)GOTO 1280 
      IF (CH.NE.1H )GOTO 1060 
      PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1060 
      CH=OPTLST(PTR)
      GOTO 1270 
1280  PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1060 
      CH=OPTLST(PTR)
      IF (CH.EQ.1H )GOTO 1280 
1290  IF (CH.EQ.1H.)GOTO 1300 
      IF (CH.EQ.1H,.OR.CH.EQ.1H )GOTO 1310 
      IF (CH.LT.1H0.OR.CH.GT.1H9)GOTO 1060 
      IP=IP*10+CVB(CH)
      PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1310 
      CH=OPTLST(PTR)
      GOTO 1290 
1300  PTR=PTR+1
      IF (PTR.GT.NCH)GOTO 1310 
      CH=OPTLST(PTR)
      IF (CH.EQ.1H,.OR.CH.EQ.1H )GOTO 1310 
      IF (CH.LT.1H0.OR.CH.GT.1H9)GOTO 1060 
      FP=10*FP+CVB(CH)
      FD=FD*10
      GOTO 1300 
1310  CLOCK=100*IP+(100*FP+FD/2)/FD
      GOTO 1000 
9000  FORMAT(' ***ERROR, "',N('N'),2A1,'" IS NOT A LEGAL OPTION***'/)
9010  FORMAT(' ***SYNTACTICAL ERROR IN OPTION LIST AT COLUMN ',I,'***'/)
      END 
      FUNCTION ASCII(VAL)
C
C     CONVERT VAL INTO ASCII VALUE (LEFT JUSTIFIED, BLANK FILLED)
C
      IMPLICIT INTEGER(A-Z)
      DIMENSION ASCTAB(128),PARBIT(128)
      INCLUDE ASM6502_C1
      DATA ASCTAB/
     1  000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015,
     2  016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031,
     3  1H ,1H!,1H",1H#,1H$,1H%,1H&,1H',1H(,1H),1H*,1H+,1H,,1H-,1H.,1H/,
     4  1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H:,1H;,1H<,1H=,1H>,1H?,
     5  1H@,1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,1HK,1HL,1HM,1HN,1HO,
     6  1HP,1HQ,1HR,1HS,1HT,1HU,1HV,1HW,1HX,1HY,1HZ,1H[,1H\,1H],1H^,1H_,
     7  1H`,1Ha,1Hb,1Hc,1Hd,1He,1Hf,1Hg,1Hh,1Hi,1Hj,1Hk,1Hl,1Hm,1Hn,1Ho,
     8  1Hp,1Hq,1Hr,1Hs,1Ht,1Hu,1Hv,1Hw,1Hx,1Hy,1Hz,1H{,1H|,1H},1H~,127/
      DATA PARBIT/
     1    0,128,128,  0,128,  0,  0,128,128,  0,  0,128,  0,128,128,  0,
     2  128,  0,  0,128,  0,128,128,  0,  0,128,128,  0,128,  0,  0,128,
     3  128,  0,  0,128,  0,128,128,  0,  0,128,128,  0,128,  0,  0,128,
     4    0,128,128,  0,128,  0,  0,128,128,  0,  0,128,  0,128,128,  0,
     5  128,  0,  0,128,  0,128,128,  0,  0,128,128,  0,128,  0,  0,128,
     6    0,128,128,  0,128,  0,  0,128,128,  0,  0,128,  0,128,128,  0,
     7    0,128,128,  0,128,  0,  0,128,128,  0,  0,128,  0,128,128,  0,
     8  128,  0,  0,128,  0,128,128,  0,  0,128,128,  0,128,  0,  0,128/
      DO 1000 I=33,127
         IF (VAL.EQ.ASCTAB(I))GOTO 1020 
1000  CONTINUE 
      J=ISL(VAL,MBITS3)
      DO 1010 I=1,32
         IF (J.EQ.ASCTAB(I))GOTO 1020 
1010  CONTINUE 
      I=128
1020  GOTO (1030,1040,1050,1060),PARITY+1
1030  ASCII=ISL(I-1,NBITS3)
      RETURN
1040  ASCII=ISL(I+PARBIT(I)-1,NBITS3)
      RETURN
1050  ASCII=ISL(I+127-PARBIT(I),NBITS3)
      RETURN
1060  ASCII=ISL(I+127,NBITS3)
      RETURN
C$$   RETURN
      END 
      FUNCTION DULBL(VAL)
C
C     LOOKUP LABEL IN SYMBOL TABLE AND GENERATE ERROR IF REQUIRED.
C     ALSO GENERATE CROSS REFERENCE IF ON PASS 2.
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
C
C     RETURN IF NO LABEL TO PROCESS.
C
      IF (LABEL(1).EQ.0)GOTO 1090 
C
C     TACK LABEL AT END OF TABLE AND GO LOOK IT UP.
C
      HISYM=HISYM+1
      IF (HISYM.GT.1000)GOTO 1110 
      SYMBOL(1,HISYM)=LABEL(1)
      SYMBOL(2,HISYM)=LABEL(2)
      SYMBOL(3,HISYM)=0
      SYMBOL(4,HISYM)=0
      SYMBOL(5,HISYM)=0
      PTR=LOOKUP(LABEL)
C
C     IF PASS 0, JUST ENTER THE LABEL IN THE SYMBOL TABLE
C
      IF (PASS.NE.0)GOTO 1010 
      IF (PTR.EQ.HISYM)GOTO 1000 
      HISYM=HISYM-1
      IF (IAND(SYMBOL(3,PTR),1).NE.0)ERRORS=IOR(ERRORS,ERRD)
      IF (VAL.LT.0)GOTO 1100 
      GOTO 1080 
1000  IF (VAL.LT.0)GOTO 1100 
      SYMBOL(3,PTR)=IOR(SYMBOL(3,PTR),1)
      IF (RELOC.NE.0)SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),ISL(-1,MBITS2)
     1),OPTREL)+ISL(IAND(RELBAS,127),NBITS2)
      SYMBOL(4,PTR)=VAL
      GOTO 1080 
C
C     IF PASS 1, SYMBOL MUST BE ENTERED, BUT NOT DEFINED
C
1010  IF (PASS.NE.1)GOTO 1040 
      IF (PTR.NE.HISYM)GOTO 1020 
      ERRORS=IOR(ERRORS,ERRP)
      IF (VAL.LT.0)GOTO 1100 
      SYMBOL(3,PTR)=IOR(SYMBOL(3,PTR),1)
      IF (RELOC.NE.0)SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),ISL(-1,MBITS2)
     1),OPTREL)+ISL(IAND(RELBAS,127),NBITS2)
      SYMBOL(4,PTR)=VAL
      GOTO 1080 
1020  HISYM=HISYM-1
      IF (VAL.LT.0)GOTO 1080 
      IF (IAND(SYMBOL(3,PTR),1).EQ.0)GOTO 1030 
      IF (IAND(SYMBOL(3,PTR),2).NE.0)GOTO 1030 
      ERRORS=IOR(ERRORS,ERRD)
      GOTO 1090 
1030  SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),-3),1)
      IF (RELOC.NE.0)SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),ISL(-1,MBITS2)
     1),OPTREL)+ISL(IAND(RELBAS,127),NBITS2)
      SYMBOL(4,PTR)=VAL
      GOTO 1080 
C
C     IF PASS 2, SYMBOL MUST BE ENTERED AND DEFINED
C
1040  IF (PTR.NE.HISYM)GOTO 1050 
      ERRORS=IOR(ERRORS,ERRP)
      IF (VAL.LT.0)GOTO 1100 
      SYMBOL(3,PTR)=IOR(SYMBOL(3,PTR),1)
      IF (RELOC.NE.0)SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),ISL(-1,MBITS2)
     1),OPTREL)+ISL(IAND(RELBAS,127),NBITS2)
      SYMBOL(4,PTR)=VAL
      GOTO 1080 
1050  HISYM=HISYM-1
      IF (VAL.LT.0)GOTO 1080 
      IF (IAND(SYMBOL(3,PTR),1).NE.0)GOTO 1060 
      ERRORS=IOR(ERRORS,ERRP)
      SYMBOL(3,PTR)=IOR(SYMBOL(3,PTR),1)
      IF (RELOC.NE.0)SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),ISL(-1,MBITS2)
     1),OPTREL)+ISL(IAND(RELBAS,127),NBITS2)
      SYMBOL(4,PTR)=VAL
      GOTO 1080 
1060  IF (SYMBOL(4,PTR).EQ.VAL)GOTO 1080 
      IF (IAND(SYMBOL(3,PTR),2).EQ.0)GOTO 1070 
      SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),-3),1)
      IF (RELOC.NE.0)SYMBOL(3,PTR)=IOR(IAND(SYMBOL(3,PTR),ISL(-1,MBITS2)
     1),OPTREL)+ISL(IAND(RELBAS,127),NBITS2)
      SYMBOL(4,PTR)=VAL
      GOTO 1080 
1070  ERRORS=IOR(ERRORS,ERRD)
      GOTO 1090 
C
C     RETURN THE VALUE OF PTR
C
1080  DULBL=PTR
      IF (PASS.NE.2.OR.IAND(OPTION,OPTXR).EQ.0)RETURN
C
C     DO XREF
C
      XRBUF(1)=-LNCNT
      XRBUF(2)=IUNIT
      XRBUF(3)=SYMBOL(5,PTR)
      XRBUF(4)=OPCODE(1)
      XRBUF(5)=OPCODE(2)
      SYMBOL(5,PTR)=XRREC
      WRITE (XRUNIT,REC=XRREC)XRBUF
      XRREC=XRREC+1
      RETURN
C
C     RETURN ZERO
C
1090  DULBL=0
      RETURN
C
C     RETURN VALUE OF PTR, BUT DON'T DO XREF
C
1100  DULBL=PTR
      RETURN
C
C     LABEL TABLE OVERFLOW!
C
1110  IF (PASS.EQ.2)WRITE (LOUNIT,9000)
      GOTO 1090 
9000  FORMAT(' ***LABEL TABLE OVERFLOW***')
      END 
      SUBROUTINE CVA(DST,SRC)
C
C     SUBROUTINE TO CONVERT SRC FIELD TO ASCII IN DST
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION RESULT(2),ACHAR(26)
      DATA ACHAR/
     1  1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,1HK,1HL,1HM,
     2  1HN,1HO,1HP,1HQ,1HR,1HS,1HT,1HU,1HV,1HW,1HX,1HY,1HZ/
      RESULT(1)=0
      RESULT(2)=0
      IF (SRC.NE.0)ERRCNT=ERRCNT+1
      J=1
      DO 1000 I=1,26
         IF (IAND(SRC,J).EQ.0)GOTO 1000 
         CALL PACK(RESULT(1),ACHAR(I))
1000  J=2*J
      DO 1010 I=1,4
1010  CALL PACK(RESULT(1),BLANK)
      DST=RESULT(1)
      RETURN
      END 
      SUBROUTINE LIST
C
C     PRINT CONTENTS OF LOBUF VIA LOUNIT, PAGING IF NECESSARY
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      IF (LOLINE.LT.LOLIM)GOTO 1000 
      LOPAGE=LOPAGE+1
      N=80
      IF (LOWID.LT.107)N=LOWID-27
      WRITE (LOUNIT,9000)TIME,DATE,LOPAGE,(TITLE(I),I=1,N)
      WRITE (LOUNIT,9010)
      LOLINE=2
1000  N=33
      IF (LOWID.LT.132)N=LOWID/4
      WRITE (LOUNIT,9020)(LOBUF(I),I=1,N)
      LOLINE=LOLINE+1
      RETURN
9000  FORMAT('1',2A4,1X,2A4,1X,'PAGE',I4,1X,80A1)
9010  FORMAT(' ')
9020  FORMAT(1X,33A4)
      END 
      SUBROUTINE CVH(DST,SRC)
C
C     CONVERT SRC TO PRINTABLE HEX IN DST
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION HEX(16)
      DATA HEX/
     1  1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1HA,1HB,1HC,1HD,1HE,1HF/
      DST=0
      TMP=SRC
      DO 1000 I=1,4
         J=IAND(TMP,15)+1
         TMP=TMP/16
         DST=IOR(DST,ISL(ISL(HEX(J),MBITS3),NBITS*(I-1)))
1000  CONTINUE 
      RETURN
      END 
      SUBROUTINE CVO(DST1,DST2,SRC)
C
C     CONVERT SRC TO PRINTABLE OCTAL IN DST1, DST2
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION OCT(8),TMPO(2)
      DATA OCT/
     1  1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7/
      TMPO(1)=0
      TMPO(2)=0
      CALL PACK(TMPO(1),BLANK)
      CALL PACK(TMPO(1),BLANK)
      TMPI=IAND(SRC,262143)
      DO 1000 I=1,6
         J=IAND(ISL(TMPI,3*(I-6)),7)+1
         CALL PACK(TMPO(1),OCT(J))
1000  CONTINUE 
      DST1=TMPO(1)
      DST2=TMPO(2)
      RETURN
      END 
      SUBROUTINE CVD(DST,SRC)
C
C     CONVERT SRC TO PRINTABLE DECIMAL IN DST
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION DEC(10)
      DATA DEC/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
      DST=0
      TMP=SRC
      DO 1000 I=1,4
         J=TMP-10*(TMP/10)+1
         TMP=TMP/10
         DST=IOR(DST,ISL(ISL(DEC(J),MBITS3),NBITS*(I-1)))
         IF (TMP.EQ.0)GOTO 1010 
1000  CONTINUE 
      RETURN
1010  IF (I.EQ.4)RETURN
      DO 1020 J=1,4-I
1020  CALL PACK(DST,BLANK)
      RETURN
      END 
      SUBROUTINE OBJOUT(CODE,LOC,NO,BYTE)
C
C     SUBROUTINE OBJOUT WRITES OBJECT UNIT CODE INTO THE OU BUFFERS,
C     WRITING FILLED BUFFERS TO DISK WHEN FULL OR WHEN A FLUSH
C     COMMAND IS ENCOUNTERED.
C
C     CODE: IDENTIFIES THE TYPE OF RECORD TO BE FORMED:
C       -1 - FLUSH REQUEST, CLOSE ALL BUFFERS
C        0 - DATA BUFFER (GENERATED CODE); LOC DEFINES THE LOCATION
C            (IN MEMORY) TO WHICH "NO" BYTES FROM "BYTE" ARRAY ARE
C            TO BE LOADED.
C        1 - DEFINE ENTRY POINT AS LOC; "NO", AND "BYTE" IGNORED.
C        3 - RELOCATE (LONG) "LOC" BY THE CODE BYTE IN "BYTE"
C        4 - RELOCATE (SHORT) "LOC" BY THE CODE BYTE IN "BYTE"
C        5 - RESERVE MEMORY
C      128 - DEFINE SYMBOL PACKED (8 BYTES) INTO "BYTE" AS "LOC"
C      129 - DEFINE SYMBOL PACKED (8 BYTES) INTO "BYTE" AS "LOC"
C      130 - DEFINE EXTERNAL SYMBOL NUMBER "LOC" TO REFER TO
C            SYMBOL PACKED (8 BYTES) INTO "BYTE".
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION BYTE(1)
C
C     MAKE SURE THIS IS PASS 2 AND THAT OPTOU IS IN EFFECT
C
      IF (PASS.LT.2.OR.IAND(OPTION,OPTOU).EQ.0)RETURN
C
C     CHECK FOR LOAD DATA REQUEST
C
      IF (CODE.NE.0.AND.CODE.NE.OPTREL)GOTO 1030 
      IF (A0+B0.EQ.LOC.AND.C0.EQ.CODE)GOTO 1000 
      IF (A0.GT.0)CALL FLUSH(OUBUF0,A0,B0,C0)
      B0=LOC
      C0=CODE
1000  I=0
1010  I=I+1
      IF (I.GT.NO)RETURN
      IF (A0.LT.34)GOTO 1020 
      CALL FLUSH(OUBUF0,A0,B0,C0)
      B0=LOC+I-1
1020  A0=A0+1
      CALL CVH(X,BYTE(I))
      OUBUF0(A0+4)=ISL(X,NBITS2)
      GOTO 1010 
C
C     CHECK FOR A BOUND REQUEST
C
1030  IF (CODE.NE.2.AND.CODE.NE.OPTREL+2)GOTO 1040 
      IF (A0.GT.0)CALL FLUSH(OUBUF0,A0,B0,C0)
      B0=LOC
      C0=CODE
      A0=1
      CALL CVH(X,BYTE(1))
      OUBUF0(A0+4)=IAND(X,ISL(-1,NBITS2))
      OUBUF0(A0+5)=ISL(X,NBITS2)
      A0=A0+1
      CALL FLUSH(OUBUF0,A0,B0,C0)
      B0=-1
      RETURN
C
C     CHECK FOR A DEFINE ENTRY REQUEST
C
1040  IF (CODE.NE.1)GOTO 1050 
      IF (A0.GT.0)CALL FLUSH(OUBUF0,A0,B0,C0)
      C0=1
      B0=LOC
      CALL FLUSH(OUBUF0,A0,B0,C0)
      C0=0
      B0=-1
      RETURN
C
C     CHECK FOR A RELOCATE LONG REQUEST
C
1050  IF (CODE.NE.3)GOTO 1070 
      IF (A3.LT.33)GOTO 1060 
      CALL FLUSH(OUBUF3,A3,B3,C3)
      B3=0
1060  A3=A3+1
      CALL CVH(X,LOC)
      OUBUF3(A3+4)=IAND(X,ISL(-1,NBITS2))
      OUBUF3(A3+5)=ISL(X,NBITS2)
      CALL CVH(X,BYTE(1))
      OUBUF3(A3+6)=ISL(X,NBITS2)
      A3=A3+2
      RETURN
C
C     CHECK FOR A RELOCATE SHORT REQUEST
C
1070  IF (CODE.NE.4)GOTO 1090 
      IF (A4.LT.33)GOTO 1080 
      CALL FLUSH(OUBUF4,A4,B4,C4)
      B4=0
1080  A4=A4+1
      CALL CVH(X,LOC)
      OUBUF4(A4+4)=IAND(X,ISL(-1,NBITS2))
      OUBUF4(A4+5)=ISL(X,NBITS2)
      CALL CVH(X,BYTE(1))
      OUBUF4(A4+6)=ISL(X,NBITS2)
      A4=A4+2
      RETURN
C
C     CHECK FOR A RESERVE MEMORY REQUEST
C
1090  IF (CODE.NE.5.AND.CODE.NE.OPTREL+5)GOTO 1120 
      IF (B5.EQ.-1)OUBUF5(7)=0
      IF (CODE.EQ.C5.AND.B5+OUBUF5(7).EQ.LOC)GOTO 1100 
      IF (A5.GT.0)CALL FLUSH(OUBUF5,A5,B5,C5)
      B5=LOC
      C5=CODE
      OUBUF5(7)=BYTE(1)
      GOTO 1110 
1100  OUBUF5(7)=IAND(OUBUF5(7)+BYTE(1),65535)
1110  A5=2
      CALL CVH(X,OUBUF5(7))
      OUBUF5(5)=ISL(ISL(X,MBITS2),NBITS2)
      OUBUF5(6)=ISL(X,NBITS2)
      RETURN
C
C     CHECK FOR A SYMBOL DEFINITION REQUEST
C
1120  IF (CODE.LT.128.OR.CODE.GT.130)GOTO 1150 
      IF (A0.GT.0)CALL FLUSH(OUBUF0,A0,B0,C0)
      C0=CODE
      B0=LOC
      A0=9
      DO 1140 I=1,2
         DO 1130 J=1,4
            Y=IAND(ISL(BYTE(I),(J-4)*NBITS),255)
            CALL CVH(X,Y)
            OUBUF0(4*I+J)=ISL(X,NBITS2)
1130     CONTINUE 
1140  CONTINUE 
      CALL CVH(X,IAND(BYTE(3),255))
      OUBUF0(13)=ISL(X,NBITS2)
      CALL FLUSH(OUBUF0,A0,B0,C0)
      C0=0
      RETURN
C
C     CHECK FOR FLUSH REQUEST
C
1150  IF (CODE.NE.-1)GOTO 1160 
      IF (A0.GT.0)CALL FLUSH(OUBUF0,A0,B0,C0)
      IF (A3.GT.0)CALL FLUSH(OUBUF3,A3,B3,C3)
      IF (A4.GT.0)CALL FLUSH(OUBUF4,A4,B4,C4)
      IF (A5.GT.0)CALL FLUSH(OUBUF5,A5,B5,C5)
      RETURN
C
C     ILLEGAL REQUEST...IGNORE THE DUMMY
C
1160  RETURN
      END 
      SUBROUTINE FLUSH(BUF,A,B,C)
C
C     FLUSH BUFFER 'BUF', SUPPLYING CHECKSUM AND FORMATTING INFORMATION
C
C     A -> HEX IN BUF(1)
C     B -> HEX IN BUF(2-3)
C     C -> HEX IN BUF(4)
C     CHECKSUM -> HEX IN BUF A+4
C     WRITE OUT ':', BUF(0-A+4)
C
C     SET A BACK TO ZERO, THEN RETURN.
C
      IMPLICIT INTEGER(A-Z)
      INCLUDE ASM6502_C1
      DIMENSION BUF(1)
      CALL CVH(X,A)
      BUF(1)=ISL(X,NBITS2)
      CALL CVH(X,B)
      BUF(2)=IAND(X,ISL(-1,NBITS2))
      BUF(3)=ISL(X,NBITS2)
      CALL CVH(X,C)
      BUF(4)=ISL(X,NBITS2)
      X=0
      DO 1000 I=1,A+4
         Y=IAND(BUF(I),ISL(-1,NBITS3))+ISL(BLANK,MBITS)
         X=X+16*CVB(Y)
         Y=IAND(ISL(BUF(I),NBITS),ISL(-1,NBITS3))+ISL(BLANK,MBITS)
         X=X+CVB(Y)
1000  CONTINUE 
      CALL CVH(Y,IAND(-X,255))
      X=ISL(Y,NBITS2)
      WRITE (OUUNIT,9000)(BUF(I),I=1,A+4),X
      A=0
      RETURN
9000  FORMAT(':',39A2)
      END 
