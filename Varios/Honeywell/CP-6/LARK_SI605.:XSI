/*M* LARK_SI605 LARK_DISPLAY Comgroup information display processing */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_DISPLAY_CMD
   PURPOSE:       Process the DISPLAY command
   DESCRIPTION:   This module receives the parse tree for a DISPLAY command
                  and displays the requested information about the selected
                  comgroup.
*/
/*D*
   NAME:          LARK_DISPLAY_CMD
   CALL:          CALL LARK_DISPLAY_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_CGINFO_WITH_DATASEGS
                  LARK_CLOSE_TEMPSTATION
                  LARK_INTERNAL_ERROR
                  LARK_PROCESS_FID
                  LARK_REPORT_PMME_ERROR
   INTPUT:        PARSE$OUT
                  VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SETSTA_LARK
                  VLP$SN_CG
                  VLP$WSN_CG
   OUTPUT:        VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
   DESCRIPTION:   DISPLAY_CMD syntax =
                     'DI/SPLAY' ;
                     [ CG_FID ] ;
                     [ DISPLAY_OPTION_LIST ]
*/
 
%EJECT ;
LARK_DISPLAY_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
%INCLUDE B_MICROPS_C ;
%INCLUDE FM$FIT ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_FORMAT_C ;
%INCLUDE XU_MACRO_C ;
%INCLUDE XUF_ENTRY ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_CGINFO_WITH_DATASEG ;
%LARK_CLOSE_TEMPSTATION ;
%LARK_INTERNAL_ERROR ;
%LARK_PROCESS_FID ;
%LARK_REPORT_PMME_ERROR ;
DCL         XSF$LOCCODP          ENTRY ( 2 ) ALTRET ;
DCL         XSF$LOCCODE          ENTRY ( 2 ) ALTRET ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME           = P_OUT$BLK,
         STCLASS        = "" ) ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_CGINFO ;
%LARK_PARSEBLKS ;
%LARK_FPRGLIST ;
%LARK_NAMELIST ;
 
%EQU_CG;
 
%B$ALT ;
 
%B$TCB ;
 
%CODE03
       ( BASED          = "BASED ( CODE03$ )" ) ;
 
%CODE09
       ( BASED          = "BASED ( CODE09$ )" ) ;
 
%F$DCB ;
 
%F_FDS
       ( NAME           = FDS,
         BUF            = LOBUF,
         DCB            = M$LO ) ;
 
%FM$FIT
       ( BASED          = "BASED ( FIT$ )" ) ;
 
%FPT_OPEN
       ( FPTN           = FPT_OPEN_DISPLAY_CG,
         STCLASS        = CONSTANT,
         ASN            = COMGROUP,
         DCB            = M$CG,
         FPARAM         = FPARAMBUF,
         FUN            = UPDATE,
         JRNLBYPASS     = YES,
         SCRUB          = YES,
         SHARE          = ALL ) ;
 
%FPT_OPEN
       ( FPTN           = FPTOPEN_DISPLAY_CG,
         STCLASS        = AUTO ) ;
 
/*
   Formats
*/
 
DCL    FMTERR  CONSTANT CHAR(0) INIT('%0A');
DCL    FMTBLNK CONSTANT CHAR(0) INIT(' ');
DCL    FMT00   CONSTANT CHAR(0) INIT('%1/%0A%2/');
DCL    FMT01   CONSTANT CHAR(0) INIT('%3(%10LA%8>A| %)%10LA%8>A');
DCL    FMT02   CONSTANT CHAR(0) INIT('%3(%10LA%8>A| %)%10LA%8D');
DCL    FMT03   CONSTANT CHAR(0) INIT('%10LA%8A| %10LA%8D| %10LA%8A| %10LA%8A');
DCL    FMT04   CONSTANT CHAR(0) INIT('%2(%10LA%8A| %)%10LA%8D| %10LA%8D');
DCL    FMT05   CONSTANT CHAR(0) INIT('%10LA%8>A| %2(%10LA%8A| %)%10LA%8O');
DCL    FMT07   CONSTANT CHAR(0) INIT('%10LA%8D| %10LA%8A| %10LA%8D| %10LA%8D');
DCL    FMT09   CONSTANT CHAR(0) INIT('%3(%10LA%8A| %)%10LA%8D');
DCL    FMT10   CONSTANT CHAR(0) INIT('%3(%10LA%8A| %)%10LA%8>A');
DCL    FMT11   CONSTANT CHAR(0) INIT('%10LA%8A| %2(%10LA%8D| %)%10LA%8A');
DCL    FMT111  CONSTANT CHAR(0) INIT('%10LA%8D| %10LA%8D|');
DCL    FMT12   CONSTANT CHAR(0) INIT('%10LA%8A| %10LA%8D| %10LA%8A| ');
DCL    FMT13   CONSTANT CHAR(0) INIT('%2(%1/%0A%)');
DCL    FMT14   CONSTANT CHAR(0) INIT('%8A %5D %6D %4D %4D %16A');
DCL    FMT15   CONSTANT CHAR(0) INIT('%3(%1/%0A%)');
DCL    FMT18   CONSTANT CHAR(0) INIT('%2D %5D %5D  %2D %5D %5D  %4D %4D  %5D %5D %4D %4D %6D %6D');
DCL    FMT19   CONSTANT CHAR(0) INIT('%17A%3D%9A%3D%27A%3D%12A%3D)');
DCL    FMT20   CONSTANT CHAR(0) INIT('%8>A|%3(%6D|%) %3D|%6D|%2(%8LA|%)%4D|%14..3U');
DCL    FMT21   CONSTANT CHAR(0) INIT('%31( %)%3D|%6D|%2(%8LA|%)%4D|%14..3U');
DCL    FMT22   CONSTANT CHAR(0) INIT('%5..4U %0A%0A<>%D<>%0A,%0A%0A');
DCL    FMT23   CONSTANT CHAR(0) INIT('%0A = %A');
DCL    FMT24   CONSTANT CHAR(0) INIT('%0A = %D');
DCL    FMT25   CONSTANT CHAR(0) INIT('%0A = %O');
DCL    FMT26   CONSTANT CHAR(0) INIT('%2(%10LA%8>A| %)');
DCL    FMT27   CONSTANT CHAR(0) INIT('%8A %4D %15A %6D');
DCL    FMT28   CONSTANT CHAR(0) INIT('%0A');
DCL    FMT29   CONSTANT CHAR(0) INIT('%8A%2/');
DCL    FMT31   CONSTANT CHAR(0) INIT('%4A %8A %4A %4A %8D %8D %8D %40A');
DCL    FMT32   CONSTANT CHAR(0) INIT('%2(%8A %)%3(%8D %)');
DCL    FMT33   CONSTANT CHAR(0) INIT('%8A %60A');
DCL    FMT34   CONSTANT CHAR(0) INIT('%1/%0A');
DCL    FMT35   CONSTANT CHAR(0) INIT('%8A%8A %8A');
DCL    FMT36   CONSTANT CHAR(0) INIT('%31LA %8LA %8A');
DCL    FMT37   CONSTANT CHAR(0) INIT('%11LA %10A %10D');
DCL    TXT00   CONSTANT CHAR(0) INIT('CG Control Parameters');
DCL    TXT01   CONSTANT CHAR(0) INIT('AUConDCB');
DCL    TXT02   CONSTANT CHAR(0) INIT('AUConTerm');
DCL    TXT03   CONSTANT CHAR(0) INIT('AUDConDCB');
DCL    TXT04   CONSTANT CHAR(0) INIT('AUDConTerm');
DCL    TXT05   CONSTANT CHAR(0) INIT('AutoRcvr');
DCL    TXT06   CONSTANT CHAR(0) INIT('BigMXt');
DCL    TXT07   CONSTANT CHAR(0) INIT('Bin');
DCL    TXT08   CONSTANT CHAR(0) INIT('CarryOSta');
DCL    TXT09   CONSTANT CHAR(0) INIT('ConMsg');
DCL    TXT10   CONSTANT CHAR(0) INIT('DataPgs');
DCL    TXT11   CONSTANT CHAR(0) INIT('DCBConAU');
DCL    TXT12   CONSTANT CHAR(0) INIT('DCBConLgl');
DCL    TXT13   CONSTANT CHAR(0) INIT('DCBConNAU');
DCL    TXT14   CONSTANT CHAR(0) INIT('DCBConWA');
DCL    TXT15   CONSTANT CHAR(0) INIT('DeferBlks');
DCL    TXT16   CONSTANT CHAR(0) INIT('DiskWarn');
DCL    TXT17   CONSTANT CHAR(0) INIT('DMTyp');
DCL    TXT18   CONSTANT CHAR(0) INIT('DRML');
DCL    TXT19   CONSTANT CHAR(0) INIT('DscReq');
DCL    TXT20   CONSTANT CHAR(0) INIT('DVByte');
DCL    TXT21   CONSTANT CHAR(0) INIT('Input');
DCL    TXT22   CONSTANT CHAR(0) INIT('Journal');
DCL    TXT23   CONSTANT CHAR(0) INIT('MaxMC');
DCL    TXT24   CONSTANT CHAR(0) INIT('MaxPg');
DCL    TXT245  CONSTANT CHAR(0) INIT('MaxRd');
DCL    TXT25   CONSTANT CHAR(0) INIT('MemWarn');
DCL    TXT26   CONSTANT CHAR(0) INIT('MemWarnP');
DCL    TXT27   CONSTANT CHAR(0) INIT('MinPg');
DCL    TXT275  CONSTANT CHAR(0) INIT('MinRd');
DCL    TXT28   CONSTANT CHAR(0) INIT('MxAct');
DCL    TXT29   CONSTANT CHAR(0) INIT('Output');
DCL    TXT30   CONSTANT CHAR(0) INIT('QRML');
DCL    TXT31   CONSTANT CHAR(0) INIT('RAS');
DCL    TXT32   CONSTANT CHAR(0) INIT('Redundant');
DCL    TXT33   CONSTANT CHAR(0) INIT('Reread');
DCL    TXT34   CONSTANT CHAR(0) INIT('Secure');
DCL    TXT35   CONSTANT CHAR(0) INIT('SMD');
DCL    TXT36   CONSTANT CHAR(0) INIT('StaPrio');
DCL    TXT37   CONSTANT CHAR(0) INIT('TermConAU');
DCL    TXT38   CONSTANT CHAR(0) INIT('TermConLgl');
DCL    TXT39   CONSTANT CHAR(0) INIT('TermConNAU');
DCL    TXT40   CONSTANT CHAR(0) INIT('TMTyp');
DCL    TXT41   CONSTANT CHAR(0) INIT('Trans');
DCL    TXT42   CONSTANT CHAR(0) INIT('TrmRdSiz');
DCL    TXT43   CONSTANT CHAR(0) INIT('TypPrio');
DCL    TXT44   CONSTANT CHAR(0) INIT('UnlaMsg');
DCL    TXT45   CONSTANT CHAR(0) INIT('WAS');
DCL    TXT46   CONSTANT CHAR(0) INIT('WriteTime');
DCL    TXT47   CONSTANT CHAR(0) INIT('XStaLgl');
DCL    TXT475  CONSTANT CHAR(0) INIT('XTypLgl');
DCL    TXT48   CONSTANT CHAR(0) INIT('CG Stations');
DCL    TXT49   CONSTANT CHAR(0)
       INIT('Name     Reads Writes Prio Msgs Act Con Prm AUP');
DCL    TXT50   CONSTANT CHAR(0) INIT('CG Statistics');
DCL    TXT51   CONSTANT CHAR(0)
       INIT(' DCB Stations | Term Stations |   Disk   |  Messages  |Dfr |Garb| Words| Words');
DCL    TXT52   CONSTANT CHAR(0)
       INIT(' # Reads Write|  # Reads Write| Read Writ| AnonQ DrctQ|Unav|Coll| Used | Free ');
DCL    TXT59   CONSTANT CHAR(0) INIT('Default SETSTA Parameters');
DCL    TXT60   CONSTANT CHAR(0) INIT('AllAbsent');
DCL    TXT61   CONSTANT CHAR(0) INIT('AllDCBS');
DCL    TXT62   CONSTANT CHAR(0) INIT('AllTrmS');
DCL    TXT63   CONSTANT CHAR(0) INIT('AnyDCB');
DCL    TXT64   CONSTANT CHAR(0) INIT('DirOnly');
DCL    TXT65   CONSTANT CHAR(0) INIT('EOFNone');
DCL    TXT66   CONSTANT CHAR(0) INIT('EOFOne');
DCL    TXT665  CONSTANT CHAR(0) INIT('EOFTime');
DCL    TXT67   CONSTANT CHAR(0) INIT('ILatch');
DCL    TXT68   CONSTANT CHAR(0) INIT('ILock');
DCL    TXT69   CONSTANT CHAR(0) INIT('IMsgTyp');
DCL    TXT70   CONSTANT CHAR(0) INIT('IStation');
DCL    TXT71   CONSTANT CHAR(0) INIT('MyStation');
DCL    TXT72   CONSTANT CHAR(0) INIT('OLatch');
DCL    TXT73   CONSTANT CHAR(0) INIT('OLock');
DCL    TXT74   CONSTANT CHAR(0) INIT('OMsgTyp');
DCL    TXT75   CONSTANT CHAR(0) INIT('OStation');
DCL    TXT76   CONSTANT CHAR(0) INIT('WAS');
DCL    TXT77   CONSTANT CHAR(0) INIT('CG Message Types');
DCL    TXT78   CONSTANT CHAR(0)
       INIT('Name     Prio Jrnl OneR Perm Writes');
DCL    TXT79   CONSTANT CHAR(0) INIT('CG Journal FID');
DCL    TXT81   CONSTANT CHAR(0) INIT('CG HoldSta');
DCL    TXT84   CONSTANT CHAR(0) INIT('CG JrnlSta');
DCL    TXT85   CONSTANT CHAR(0) INIT('CG DCB Parameters');
DCL    TXT86   CONSTANT CHAR(0)
       INIT('Org    Expire QISS Jrnl IxtnSize   NGAval   UGrans Comgroup');
DCL    TXT87   CONSTANT CHAR(0)
               INIT ('Account   AU  AURd Crea DelF DelR Exec Nlst Read ReAt TCtl Upd  WNew');
DCL    TXT88   CONSTANT CHAR(0) INIT('CG Anonymous Queue');
DCL    TXT89   CONSTANT CHAR(0)
               INIT ('Station  AutoRcvr    CNAct   MsgCnt    MxAct');
DCL    TXT90   CONSTANT CHAR(0)
               INIT ('MsgType  AutoRcvr    CNAct   MsgCnt    MxAct');
DCL    TXT91   CONSTANT CHAR(0) INIT ('Selection Values');
DCL    TXT92   CONSTANT CHAR(0) INIT ('AUForce  TempSta ContSta');
DCL    TXT93   CONSTANT CHAR(0) INIT ('FPRG Stations');
DCL    TXT94   CONSTANT CHAR(0)
           INIT ('FPRG                            Station  DevPres');
DCL    TXT95   CONSTANT CHAR(0) INIT('Functional Stations') ;
DCL    TXT96   CONSTANT CHAR(0) INIT('FunctionSta ControlSta GhostSysid') ;
DCL     TXT97   CONSTANT CHAR(0) INIT ('B$CGAURD.EVENT Codes');
DCL     TXT100  CONSTANT CHAR(0) INIT('DCB Open') ;
DCL     TXT101  CONSTANT CHAR(0) INIT('DCB Close') ;
DCL     TXT102  CONSTANT CHAR(0) INIT('TERM Conn') ;
DCL     TXT103  CONSTANT CHAR(0) INIT('TERM Disc') ;
DCL     TXT104  CONSTANT CHAR(0) INIT('TERM Break') ;
DCL     TXT105  CONSTANT CHAR(0) INIT('UNLA Rerun') ;
DCL     TXT106  CONSTANT CHAR(0) INIT('UNLA Hold') ;
DCL     TXT107  CONSTANT CHAR(0) INIT('UNLA Del') ;
DCL     TXT108  CONSTANT CHAR(0) INIT('Warn') ;
DCL     TXT109  CONSTANT CHAR(0) INIT('FWCG') ;
DCL     TXT110  CONSTANT CHAR(0) INIT('Jrnl Dele') ;
DCL     TXT111  CONSTANT CHAR(0) INIT('Disc Requ') ;
DCL     TXT112  CONSTANT CHAR(0) INIT('FPRG Exit') ;
DCL     TXT113  CONSTANT CHAR(0) INIT('FPRG Abrt') ;
DCL     TXT114  CONSTANT CHAR(0) INIT('FPRG Ldtrc') ;
DCL    EMSG01  CONSTANT CHAR(0) INIT('No stations currently connected');
DCL    EMSG02  CONSTANT CHAR(0) INIT('No message types are defined');
DCL    EMSG03  CONSTANT CHAR(0) INIT('No journal FID exists');
DCL    EMSG04  CONSTANT CHAR(0) INIT('No HOLDSTA exists');
DCL    EMSG05  CONSTANT CHAR(0) INIT('No JRNLSTA exists');
DCL    EMSG06  CONSTANT CHAR(0) INIT('No anonymous queue nodes exist');
DCL    EMSG07  CONSTANT CHAR(0) INIT('No FPRG stations exist');
DCL    EMSG08  CONSTANT CHAR(0) INIT('No Functional Stations exist') ;
 
DCL    PARM1   CHAR(4);
DCL    PARM2   CHAR(4);
DCL    PARM3   CHAR(4);
DCL    PARM4   CHAR(4);
DCL    PARM5   CHAR(8);
DCL    PARM6   CHAR(8);
DCL    PARM7   CHAR(8);
DCL    PARM8   CHAR(8);
DCL    PARM9   CHAR(40);
DCL    DPARM1  UBIN;
DCL    DPARM2  UBIN;
DCL    DPARM3  UBIN;
DCL    DPARM4  UBIN;
DCL    DPARM5  UBIN;
DCL    DPARM6  UBIN;
DCL    DPARM7  UBIN;
 
/*
   Local data
*/
 
DCL      1  AUCON                ( 0:3 ) STATIC,
            2  TXT               CHAR ( 4 )
                                 INIT ( '  NC', 'ACTV', 'DEAC', 'DISC' ) ;
DCL         B$TCB$               PTR SYMREF ;
DCL         BLK$                 PTR ;
DCL         CODE03$              PTR STATIC ;
DCL         CODE09$              PTR STATIC ;
DCL         CODE09_EXISTS        BIT ( 1 ) ;
DCL         CODE09_INDEX         SBIN ;
DCL         I                    SBIN ;
DCL         FIT$                 PTR STATIC INIT ( ADDR ( FPARAMBUF ) ) ;
DCL      1  FPARAMBUF            STATIC,
            2  *                 ( 0:4 ) UBIN,
            2  STUFF,
               3  *              ( 0:1018 ) UBIN ;
DCL         GOODINFO             BIT ( 1 ) ;
DCL         LOBUF                STATIC CHAR ( 80 ) INIT ( ' ' ) ;
DCL         OPTIONS_EXIST        BIT ( 1 ) ;
DCL         SUBLK$               PTR ;
DCL         SYM$                 PTR ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %DISPLAY_CMD ) OR
   ( P_OUT$BLK.NSUBLKS > 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
/*
   Processing the optional parameters:  CG_FID and OPTION_LIST.
   If a CG_FID is not specified, the last FID supplied is used.
*/
 
OPTIONS_EXIST = %FALSE ;
 
IF ( P_OUT$BLK.NSUBLKS > 0 ) THEN DO ;
 
   BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
   IF ( BLK$->OUT$SYM.CODE ~= %CG_FID ) THEN DO ;
      IF ( P_OUT$BLK.NSUBLKS > 1 ) OR
         ( BLK$->OUT$BLK.CODE ~= %DISPLAY_OPTION_LIST ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT;
      END ; ELSE DO ;
         OPTIONS_EXIST = %TRUE ;
      END ;
   END ; ELSE DO ;
      /*
         Processing the CG_FID if it was included in the command.
      */
      CALL LARK_PROCESS_FID ( VECTOR ( BLK$->OUT$SYM.TEXT ) )
            ALTRET ( ALT ) ;
   END ;
 
END ;
 
/*
   Make sure it's a comgroup file now.  Doing normal comgroup open
   on it returns a virtual segment error instead of 'not a comgroup'
   because the SETSTA is specified.
*/
 
FPTOPEN_DISPLAY_CG = FPT_OPEN_DISPLAY_CG ;
FPTOPEN_DISPLAY_CG.V_ = VECTOR ( FPTOPEN_DISPLAY_CG.V ) ;
FPTOPEN_DISPLAY_CG.V.AU# = AU_FORCE ;
FPTOPEN_DISPLAY_CG.V.OPER.TEST# = %YES# ;
FPTOPEN_DISPLAY_CG.ACCT_ = VECTOR ( VLP$ACCT_CG ) ;
FPTOPEN_DISPLAY_CG.NAME_ = VECTOR ( VLP$NAME_CG ) ;
FPTOPEN_DISPLAY_CG.PASS_ = VECTOR ( VLP$PASS_CG ) ;
FPTOPEN_DISPLAY_CG.SN_ = VECTOR ( VLP$SN_CG ) ;
FPTOPEN_DISPLAY_CG.WSN_ = VECTOR ( VLP$WSN_CG ) ;
CALL M$OPEN ( FPTOPEN_DISPLAY_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
 
                                      M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
 
FPTOPEN_DISPLAY_CG.V.OPER.TEST# = %NO# ;
FPTOPEN_DISPLAY_CG.SETSTA_ = VECTOR ( VLP$SETSTA_LARK ) ;
CALL M$OPEN ( FPTOPEN_DISPLAY_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                      M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
CODE03$ = FIT$ ;
CALL XSF$LOCCODP ( CODE03$,
                   3 )
      WHENALTRETURN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
      END ;
CODE09$ = FIT$ ;
CODE09_INDEX = 9 ;
CALL XSF$LOCCODE ( CODE09$,
                   CODE09_INDEX )
      WHENRETURN DO ;
         CODE09_EXISTS = %TRUE ;
      END ;
      WHENALTRETURN DO ;
         CODE09_EXISTS = %FALSE ;
      END ;
 
/*
   Processing the DISPLAY_OPTION_LIST if it was included in the command.
*/
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) OR OPTIONS_EXIST THEN DO ;
 
   IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
      BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
   END ; ELSE DO ;
      BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
   END ;
 
   IF ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   /*
      Uses previously allocated data segment to store all the CGINFO data
      from this CGINFO call.
   */
 
   CALL LARK_CGINFO_WITH_DATASEG
         ALTRET ( ALT ) ;
   /*
      Processing the option list.
   */
 
   DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
      SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
      DO CASE SUBLK$->OUT$BLK.CODE ;
 
         CASE ( %ALL_OPT ) ;
            CALL DCB_DISPLAY ;
            CALL CGCP_DISPLAY ;
            CALL EVENT_DISPLAY ;
            CALL FPRGS_DISPLAY ;
            CALL FSTA_DISPLAY ;
            CALL HOLDSTA_DISPLAY ;
            CALL JRNLFID_DISPLAY ;
            CALL JRNLSTA_DISPLAY ;
            CALL SETSTA_DISPLAY ;
            CALL STALIST_DISPLAY ;
            CALL TYPLIST_DISPLAY ;
            CALL QLIST_DISPLAY ;
            CALL STATS_DISPLAY ;
 
         CASE ( %CGCP_OPT ) ;
            CALL CGCP_DISPLAY ;
 
         CASE ( %DCB_OPT ) ;
            CALL DCB_DISPLAY ;
 
         CASE ( %EVENT_OPT ) ;
            CALL EVENT_DISPLAY ;
 
         CASE ( %FPRGS_OPT ) ;
            CALL FPRGS_DISPLAY ;
 
         CASE ( %FSTA_OPT ) ;
            CALL FSTA_DISPLAY ;
 
         CASE ( %HOLDSTA_OPT ) ;
            CALL HOLDSTA_DISPLAY ;
 
         CASE ( %JRNLFID_OPT ) ;
            CALL JRNLFID_DISPLAY ;
 
         CASE ( %JRNLSTA_OPT ) ;
            CALL JRNLSTA_DISPLAY ;
 
         CASE ( %QLIST_OPT ) ;
            CALL QLIST_DISPLAY ;
 
         CASE ( %SETSTA_OPT ) ;
            CALL SETSTA_DISPLAY ;
 
         CASE ( %STALIST_OPT ) ;
            CALL STALIST_DISPLAY ;
 
         CASE ( %STATS_OPT ) ;
            CALL STATS_DISPLAY ;
 
         CASE ( %TYPLIST_OPT ) ;
            CALL TYPLIST_DISPLAY ;
 
         CASE ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
 
      END ;
 
   END ;
 
END ; ELSE DO ;
 
   CALL DCB_DISPLAY ;
 
END ;
 
CALL LARK_CLOSE_TEMPSTATION
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
%EJECT ;
/*I*
   NAME:          CGCP_DISPLAY
   PURPOSE:       To display the CGCP parameters of the selected comgroup.
   CALL:          CALL CGCP_DISPLAY
   DESCRIPTION:   Outputs a table displaying all CGCP parameters
*/
 
%EJECT ;
CGCP_DISPLAY:  PROC;
 
DCL         CGCP$                PTR ;
 
CGCP$ = VBASE ( BITVECT ( FPT$CGINFO.CGCP_ ) ) ;
CALL X$WRITE(FDS, VECTOR(FMT00),
                VECTOR(TXT00));
PARM1 = AUCON.TXT(CGCP$->VLP_CGCP_CGINFO.AUCONDCB#);
PARM2 = AUCON.TXT(CGCP$->VLP_CGCP_CGINFO.AUCONTERM#);
PARM3 = AUCON.TXT(CGCP$->VLP_CGCP_CGINFO.AUDCONDCB#);
PARM4 = AUCON.TXT(CGCP$->VLP_CGCP_CGINFO.AUDCONTERM#);
CALL X$WRITE(FDS, VECTOR(FMT01),
                 VECTOR(TXT01), VECTOR(PARM1),
                 VECTOR(TXT02), VECTOR(PARM2),
                 VECTOR(TXT03), VECTOR(PARM3),
                 VECTOR(TXT04), VECTOR(PARM4));
IF CGCP$->VLP_CGCP_CGINFO.AUTORCVR# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.BIGMXT# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.DVBYTE.BIN# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.CARRYOSTA# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                VECTOR(TXT05), VECTOR(PARM1),
                VECTOR(TXT06), VECTOR(PARM2),
                VECTOR(TXT07), VECTOR(PARM3),
                VECTOR(TXT08), VECTOR(PARM4));
IF CGCP$->VLP_CGCP_CGINFO.CONMSG# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
DPARM2 = CGCP$->VLP_CGCP_CGINFO.DATAPGS#;
IF CGCP$->VLP_CGCP_CGINFO.DCBCONAU# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.DCBCONLGL# = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT03),
                VECTOR(TXT09), VECTOR(PARM1),
                VECTOR(TXT10), VECTOR(DPARM2),
                VECTOR(TXT11), VECTOR(PARM3),
                VECTOR(TXT12), VECTOR(PARM4));
IF CGCP$->VLP_CGCP_CGINFO.DCBCONNAU# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.DCBCONWA# = %YES#  THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
DPARM3 = CGCP$->VLP_CGCP_CGINFO.DEFERBLKS#;
DPARM4 = CGCP$->VLP_CGCP_CGINFO.DISKWARN#;
CALL X$WRITE(FDS, VECTOR(FMT04),
                VECTOR(TXT13), VECTOR(PARM1),
                VECTOR(TXT14), VECTOR(PARM2),
                VECTOR(TXT15), VECTOR(DPARM3),
                VECTOR(TXT16), VECTOR(DPARM4));
IF CGCP$->VLP_CGCP_CGINFO.DMTYP# = ' ' THEN
    PARM8 = 'None';
ELSE
    PARM8 = CGCP$->VLP_CGCP_CGINFO.DMTYP#;
IF CGCP$->VLP_CGCP_CGINFO.DRML# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.DSCREQ# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT05),
                VECTOR(TXT17), VECTOR(PARM8),
                VECTOR(TXT18), VECTOR(PARM2),
                VECTOR(TXT19), VECTOR(PARM3),
                VECTOR(TXT20), VECTOR(CGCP$->VLP_CGCP_CGINFO.DVBYTE));
IF CGCP$->VLP_CGCP_CGINFO.INPUT# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.JOURNAL# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
DPARM3 = CGCP$->VLP_CGCP_CGINFO.MAXMC#;
DPARM4 = CGCP$->VLP_CGCP_CGINFO.MAXPG#;
CALL X$WRITE(FDS, VECTOR(FMT04),
                VECTOR(TXT21), VECTOR(PARM1),
                VECTOR(TXT22), VECTOR(PARM2),
                VECTOR(TXT23), VECTOR(DPARM3),
                VECTOR(TXT24), VECTOR(DPARM4));
DPARM1 = CGCP$->VLP_CGCP_CGINFO.MEMWARN#;
IF CGCP$->VLP_CGCP_CGINFO.MEMWARNP# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
DPARM3 = CGCP$->VLP_CGCP_CGINFO.MINPG#;
DPARM4 = CGCP$->VLP_CGCP_CGINFO.MXACT#;
CALL X$WRITE(FDS, VECTOR(FMT07),
                VECTOR(TXT25), VECTOR(DPARM1),
                VECTOR(TXT26), VECTOR(PARM2),
                VECTOR(TXT27), VECTOR(DPARM3),
                VECTOR(TXT28), VECTOR(DPARM4));
IF CGCP$->VLP_CGCP_CGINFO.OUTPUT# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.QRML# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.RAS# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.REDUNDANT# = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                VECTOR(TXT29), VECTOR(PARM1),
                VECTOR(TXT30), VECTOR(PARM2),
                VECTOR(TXT31), VECTOR(PARM3),
                VECTOR(TXT32), VECTOR(PARM4));
IF CGCP$->VLP_CGCP_CGINFO.DVBYTE.REREAD# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.SECURE# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.SMD# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
DPARM4 = CGCP$->VLP_CGCP_CGINFO.STAPRIO#;
CALL X$WRITE(FDS, VECTOR(FMT09),
                VECTOR(TXT33), VECTOR(PARM1),
                VECTOR(TXT34), VECTOR(PARM2),
                VECTOR(TXT35), VECTOR(PARM3),
                VECTOR(TXT36), VECTOR(DPARM4));
IF CGCP$->VLP_CGCP_CGINFO.TERMCONAU# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.TERMCONLGL# = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.TERMCONNAU# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
    IF CGCP$->VLP_CGCP_CGINFO.TMTYP# = ' ' THEN
        PARM8 = 'None';
    ELSE
        PARM8 = CGCP$->VLP_CGCP_CGINFO.TMTYP#;
CALL X$WRITE(FDS, VECTOR(FMT10),
                VECTOR(TXT37), VECTOR(PARM1),
                VECTOR(TXT38), VECTOR(PARM2),
                VECTOR(TXT39), VECTOR(PARM3),
                VECTOR(TXT40), VECTOR(PARM8));
IF CGCP$->VLP_CGCP_CGINFO.DVBYTE.TRANS# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
DPARM2 = CGCP$->VLP_CGCP_CGINFO.TRMRDSIZ#;
DPARM3 = CGCP$->VLP_CGCP_CGINFO.TYPPRIO#;
IF CGCP$->VLP_CGCP_CGINFO.UNLAMSG# = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT11),
                VECTOR(TXT41), VECTOR(PARM1),
                VECTOR(TXT42), VECTOR(DPARM2),
                VECTOR(TXT43), VECTOR(DPARM3),
                VECTOR(TXT44), VECTOR(PARM4));
IF CGCP$->VLP_CGCP_CGINFO.WAS# = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
DPARM2 = CGCP$->VLP_CGCP_CGINFO.WRITETIME#;
IF CGCP$->VLP_CGCP_CGINFO.XSTALGL# = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF CGCP$->VLP_CGCP_CGINFO.XTYPLGL# = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT03),
                VECTOR(TXT45), VECTOR(PARM1),
                VECTOR(TXT46), VECTOR(DPARM2),
                VECTOR(TXT47), VECTOR(PARM3),
                VECTOR(TXT475), VECTOR(PARM4));
DPARM1 = CGCP$->VLP_CGCP_CGINFO.MAXRD#;
DPARM2 = CGCP$->VLP_CGCP_CGINFO.MINRD#;
CALL X$WRITE(FDS, VECTOR(FMT111),
                VECTOR(TXT245), VECTOR(DPARM1),
                VECTOR(TXT275), VECTOR(DPARM2));
RETURN;
 
END CGCP_DISPLAY;
 
%EJECT ;
/*I*
   NAME:          DCB_DISPLAY
   PURPOSE:       To display appropriate DCB parameters associated with the
                  selected comgroup.
   CALL:          CALL DCB_DISPLAY
   DESCRIPTION:   Outputs a table displaying the DCB parameters
*/
 
%EJECT ;
DCB_DISPLAY : PROC ;
 
DCL         CG_NAME              CHAR ( 40 ) ;
DCL      1  MOPSTR               STATIC,
            2  MOP1              BIT ( 9 ) INIT ( %MVZB7 ),
            2  MOP2              BIT ( 9 ) INIT ( %MVC1 ) ;
DCL         MORE_ACCTS           BIT ( 1 ) ;
DCL         YNS                  CHAR ( 60 ) ;
DCL      1  YN ( 0:11 )          REDEF YNS,
            2  V                 CHAR ( 5 ) ;
 
%EJECT ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT13 ),
               VECTOR ( TXT85 ),
               VECTOR ( TXT86 ) ) ;
CALL CONCAT ( CG_NAME,
              SUBSTR ( M$CG$->F$DCB.NAME#.C,
                       0,
                       M$CG$->F$DCB.NAME#.L ),
              '.',
              M$CG$->F$DCB.ACCT# ) ;
IF ( M$CG$->F$DCB.ORG# = %FPRG# ) THEN DO ;
   PARM1 = 'FPRG' ;
END ; ELSE DO ;
   PARM1 = 'TERM' ;
END ;
IF ( M$CG$->F$DCB.EXPIRE# = %NEVER# ) THEN DO ;
   PARM5 = '   NEVER' ;
END ; ELSE DO ;
   CALL BINCHAR ( PARM6,
                  M$CG$->F$DCB.EXPIRE# ) ;
   CALL EDITCHAR ( PARM5,
                   0, 8,
                   MOPSTR,
                   PARM6 ) ;
END ;
IF ( M$CG$->F$DCB.QISS# = %YES# ) THEN DO ;
   PARM2 = ' YES' ;
END ; ELSE DO ;
   PARM2 = ' NO ' ;
END ;
IF ( M$CG$->F$DCB.GHSTACS# = %JRNLOPN# ) THEN DO ;
   PARM3 = ' YES' ;
END ; ELSE DO ;
   PARM3 = ' NO ' ;
END ;
DPARM1 = M$CG$->F$DCB.IXTNSIZE# ;
DPARM2 = CODE03.NGAVAL ;
DPARM3 = CODE03.UGRANS ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT31 ),
               VECTOR ( PARM1 ),
               VECTOR ( PARM5 ),
               VECTOR ( PARM2 ),
               VECTOR ( PARM3 ),
               VECTOR ( DPARM1 ),
               VECTOR ( DPARM2 ),
               VECTOR ( DPARM3 ),
               VECTOR ( CG_NAME ) ) ;
 
IF CODE09_EXISTS THEN DO ;
  CALL X$WRITE ( FDS,
                 VECTOR ( FMTBLNK ) ) ;
  CALL X$WRITE ( FDS,
                 VECTOR ( FMT28 ),
                 VECTOR ( TXT87 ) ) ;
END ;
DO I = 1 TO ( FM$FIT.CODES.NDW ( CODE09_INDEX ) * 4 / SIZEC ( CODE09 ) ) ;
   YNS = ' NO   NO   NO   NO   NO   NO   NO   NO   NO   NO   NO   NO  ';
   IF ( CODE09.FFLG.AU = %YES# ) THEN DO ;
      YN.V ( 0 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.AURD = %YES# ) THEN DO ;
      YN.V ( 1 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.CREATE = %YES# ) THEN DO ;
      YN.V ( 2 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.DELF = %YES# ) THEN DO ;
      YN.V ( 3 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.DELR = %YES# ) THEN DO ;
      YN.V ( 4 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.EXEC = %YES# ) THEN DO ;
      YN.V ( 5 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.NOLIST = %YES# ) THEN DO ;
      YN.V ( 6 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.READ = %YES# ) THEN DO ;
      YN.V ( 7 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.REATTR = %YES# ) THEN DO ;
      YN.V ( 8 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.TCTL = %YES# ) THEN DO ;
      YN.V ( 9 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.UPD = %YES# ) THEN DO ;
      YN.V ( 10 ) = ' YES ' ;
   END ;
   IF ( CODE09.FFLG.WNEW = %YES# ) THEN DO ;
      YN.V ( 11 ) = ' YES ' ;
   END ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT33 ),
                  VECTOR ( CODE09.ACCT ),
                  VECTOR ( YNS ) ) ;
   CODE09$ = PINCRC ( CODE09$, SIZEC ( CODE09 ) ) ;
END ;
 
CALL X$WRITE ( FDS,
               VECTOR ( FMT13 ),
               VECTOR ( TXT91 ),
               VECTOR ( TXT92 ) ) ;
IF AU_FORCE THEN DO ;
   PARM5 = '  YES    ' ;
END ; ELSE DO ;
   PARM5 = '   NO    ' ;
END ;
PARM6 = VLP$SETSTA_LARK.MYSTATION# ;
PARM7 = VLP$SETSTA_CONTROL.MYSTATION# ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT35 ),
               VECTOR ( PARM5 ),
               VECTOR ( PARM6 ),
               VECTOR ( PARM7 ) ) ;
END DCB_DISPLAY ;
 
%EJECT ;
/*I*
   NAME:          EVENT_DISPLAY
   PURPOSE:       To display the types of events that an AU can be
                  notified of, and whether or not, LARK is currently
                  monitoring them.
   CALL:          CALL EVENT_DISPLAY
   DESCRIPTION:   Outputs a table displaying all *AUEV message events
                  and whether LARK is currently monitoring them.
*/
 
%EJECT ;
EVENT_DISPLAY:  PROC;
 
DCL         LOOP                 SBIN ;
 
 
CALL X$WRITE(FDS, VECTOR(FMT00),
                VECTOR(TXT97));
IF RPT_AU_EVNT( %CG_DOPN# ) = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF RPT_AU_EVNT( %CG_DCLS# ) = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF RPT_AU_EVNT( %CG_TCON# ) = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF RPT_AU_EVNT( %CG_TDSC# ) = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                VECTOR(TXT100), VECTOR(PARM1),
                VECTOR(TXT101), VECTOR(PARM2),
                VECTOR(TXT102), VECTOR(PARM3),
                VECTOR(TXT103), VECTOR(PARM4));
IF RPT_AU_EVNT( %CG_TBRK# ) = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF RPT_AU_EVNT( %CG_UNLR# ) = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF RPT_AU_EVNT( %CG_UNLH# ) = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF RPT_AU_EVNT( %CG_UNLD# ) = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                VECTOR(TXT104), VECTOR(PARM1),
                VECTOR(TXT105), VECTOR(PARM2),
                VECTOR(TXT106), VECTOR(PARM3),
                VECTOR(TXT107), VECTOR(PARM4));
IF RPT_AU_EVNT( %CG_WARN# ) = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF RPT_AU_EVNT( %CG_FWCG# ) = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF RPT_AU_EVNT( %CG_JNLD# ) = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF RPT_AU_EVNT( %CG_TDRQ# ) = %YES# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                VECTOR(TXT108), VECTOR(PARM1),
                VECTOR(TXT109), VECTOR(PARM2),
                VECTOR(TXT110), VECTOR(PARM3),
                VECTOR(TXT111), VECTOR(PARM4));
IF RPT_AU_EVNT( %CG_FPEXIT# ) = %YES# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF RPT_AU_EVNT( %CG_FPABORT# ) = %YES# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF RPT_AU_EVNT( %CG_FPLDTRC# ) = %YES# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                VECTOR(TXT112), VECTOR(PARM1),
                VECTOR(TXT113), VECTOR(PARM2),
                VECTOR(TXT114), VECTOR(PARM3),
                VECTOR(FMTBLNK), VECTOR(FMTBLNK));
RETURN;
 
END EVENT_DISPLAY;
 
%EJECT ;
/*I*
   NAME:          HOLDSTA_DISPLAY
   PURPOSE:       To display the HOLDSTA parameters associated with the
                  selected comgroup.
   CALL:          CALL HOLDSTA_DISPLAY
   DESCRIPTION:   Outputs the HOLDSTA station.
*/
 
%EJECT ;
HOLDSTA_DISPLAY : PROC ;
 
DCL         HOLDSTA$             PTR ;
 
HOLDSTA$ = VBASE ( BITVECT ( FPT$CGINFO.HOLDSTA_ ) ) ;
IF ( HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# = ' ' ) THEN DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT00 ),
                  VECTOR ( EMSG04 ) ) ;
END ; ELSE DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT34 ),
                  VECTOR ( TXT81 ) ) ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT29 ),
                  VECTOR ( HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# ) ) ;
END ;
 
RETURN;
 
END HOLDSTA_DISPLAY ;
 
%EJECT ;
/*I*
   NAME:          JRNLFID_DISPLAY
   PURPOSE:       To display the JRNLFID associated with the selected comgroup,
                  if one exists.
   CALL:          CALL JRNLFID_DISPLAY
   DESCRIPTION:   Outputs the JRNLFID
*/
 
%EJECT ;
JRNLFID_DISPLAY : PROC ;
 
DCL         JRNLFID$             PTR ;
 
JRNLFID$ = VBASE ( BITVECT ( FPT$CGINFO.JRNLFID_ ) ) ;
IF ( JRNLFID$->VLP_JRNLFID_CGINFO.L# = 0 ) THEN DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT00 ),
                  VECTOR ( EMSG03 ) ) ;
END ; ELSE DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT34 ),
                  VECTOR ( TXT79 ) ) ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT28 ),
                  VECTOR ( SUBSTR ( JRNLFID$->VLP_JRNLFID_CGINFO.JRNLFID#,
                                    0,
                                    JRNLFID$->VLP_JRNLFID_CGINFO.L# ) ) ) ;
END ;
 
END JRNLFID_DISPLAY ;
 
%EJECT ;
/*I*
   NAME:          JRNLSTA_DISPLAY
   PURPOSE:       To display the JRNLSTA parameters associated with the
                  selected comgroup.
   CALL:          CALL JRNLSTA_DISPLAY
   DESCRIPTION:   Outputs the JRNLSTA station.
*/
 
%EJECT ;
JRNLSTA_DISPLAY : PROC ;
 
DCL         JRNLSTA$             PTR ;
 
JRNLSTA$ = VBASE ( BITVECT ( FPT$CGINFO.JRNLSTA_ ) ) ;
IF ( JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# = ' ' ) THEN DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT00 ),
                  VECTOR ( EMSG05 ) ) ;
END ; ELSE DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT34 ),
                  VECTOR ( TXT84 ) ) ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT29 ),
                  VECTOR ( JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# ) ) ;
END ;
 
RETURN;
 
END JRNLSTA_DISPLAY ;
 
%EJECT ;
/*I*
   NAME:          QLIST_DISPLAY
   PURPOSE:       To display the anonymous queue nodes of the selected
                  comgroup.
   CALL:          CALL QLIST_DISPLAY
   DESCRIPTION:   Outputs a list of the anonymous queue nodes
*/
 
%EJECT ;
QLIST_DISPLAY:   PROC;
 
DCL         IX                   SBIN ;
DCL         Q$                   PTR ;
DCL         FOUND                UBIN ;
DCL         STA$                 PTR ;
DCL         TYP$                 PTR ;
DCL         QISS                 BIT ( 1 ) ;
 
Q$ = VBASE ( BITVECT ( FPT$CGINFO.QLIST_ ) ) ;
STA$ = VBASE ( BITVECT ( FPT$CGINFO.STALIST_ ) ) ;
TYP$ = VBASE ( BITVECT ( FPT$CGINFO.TYPLIST_ ) ) ;
QISS = M$CG$->F$DCB.QISS# ;
 
IF ( ( STA$->VLP_CGSTAL_CGINFO.FOUND# = 1 ) AND ( QISS = %YES# ) ) OR
   ( ( TYP$->VLP_CGTYPL_CGINFO.FOUND# = 0 ) AND ( QISS = %NO# ) ) THEN DO ;
    CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(EMSG06));
    GOTO PASS_USR_REPORT;
    END;
IF ( QISS = %YES# ) THEN DO ;
   CALL X$WRITE(FDS, VECTOR(FMT13),
                   VECTOR(TXT88), VECTOR(TXT89));
   FOUND = STA$->VLP_CGSTAL_CGINFO.FOUND# ;
END ; ELSE DO ;
   CALL X$WRITE(FDS, VECTOR(FMT13),
                   VECTOR(TXT88), VECTOR(TXT90));
   FOUND = TYP$->VLP_CGTYPL_CGINFO.FOUND# ;
END ;
DO IX = 0 TO ( FOUND - 1 ) ;
    IF ( QISS = %YES# ) AND
       ( VLP$SETSTA_LARK.MYSTATION# = STA$->VLP_CGSTAL_CGINFO.LIST.NAME#(IX) ) THEN DO ;
      /*
         Skipping the node associated with LARK.
         Note that this IF statement depends on the ordering of the
         expressions - partial evaluation of the expression is necessary
         to avoid a memory fault.
      */
   END ; ELSE DO ;
       IF ( QISS = %YES# ) THEN DO ;
          PARM5 = STA$->VLP_CGSTAL_CGINFO.LIST.NAME# ( IX ) ;
       END ; ELSE DO ;
          PARM5 = TYP$->VLP_CGTYPL_CGINFO.LIST.NAME# ( IX ) ;
       END ;
       IF ( Q$->VLP_CGQL_CGINFO.LIST.AUTORCVR# ( IX ) = %YES# ) THEN DO ;
          PARM6 = '   YES  ' ;
       END ; ELSE DO ;
          PARM6 = '   NO   ' ;
       END ;
       DPARM1 = Q$->VLP_CGQL_CGINFO.LIST.CNACT# ( IX ) ;
       DPARM2 = Q$->VLP_CGQL_CGINFO.LIST.MSGCNT# ( IX ) ;
       DPARM3 = Q$->VLP_CGQL_CGINFO.LIST.MXACT# ( IX );
       CALL X$WRITE(FDS, VECTOR(FMT32),
                       VECTOR(PARM5), VECTOR(PARM6),
                       VECTOR(DPARM1), VECTOR(DPARM2),
                       VECTOR(DPARM3));
    END ;
END ;
 
PASS_USR_REPORT: ;
 
RETURN;
 
END QLIST_DISPLAY;
 
%EJECT ;
/*I*
   NAME:          SETSTA_DISPLAY
   PURPOSE:       To display the SETSTA parameters of the selected comgroup.
   CALL:          CALL SETSTA_DISPLAY
   DESCRIPTION:   Outputs a table displaying all SETSTA parameters.
*/
 
%EJECT ;
SETSTA_DISPLAY : PROC ;
 
DCL         SETSTA$              PTR ;
 
SETSTA$ = VBASE ( BITVECT ( FPT$CGINFO.SETSTA_ ) ) ;
CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(TXT59));
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.ALLABSENT# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.ALLDCBS# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.ALLTRMS# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.ANYDCB# THEN
    PARM4 = ' YES';
ELSE
    PARM4 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT01),
                  VECTOR(TXT60), VECTOR(PARM1),
                  VECTOR(TXT61), VECTOR(PARM2),
                  VECTOR(TXT62), VECTOR(PARM3),
                  VECTOR(TXT63), VECTOR(PARM4));
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.DIRONLY# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.EOFNONE# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.EOFONE# THEN
    PARM3 = ' YES';
ELSE
    PARM3 = '  NO';
DPARM1 = SETSTA$->VLP_SETSTA_CGINFO.ISTA.EOFTIME# ;
CALL X$WRITE(FDS, VECTOR(FMT02),
                  VECTOR(TXT64), VECTOR(PARM1),
                  VECTOR(TXT65), VECTOR(PARM2),
                  VECTOR(TXT66), VECTOR(PARM3),
                  VECTOR(TXT665), VECTOR(DPARM1));
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.ILATCH# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.ILOCK# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.IMSGTYP# = ' ' THEN
    PARM6 = 'None';
ELSE
    PARM6 = SETSTA$->VLP_SETSTA_CGINFO.ISTA.IMSGTYP#;
IF SETSTA$->VLP_SETSTA_CGINFO.ISTA.ISTATION# = ' ' THEN
    PARM7 = 'None';
ELSE
    PARM7 = SETSTA$->VLP_SETSTA_CGINFO.ISTA.ISTATION#;
CALL X$WRITE(FDS, VECTOR(FMT01),
                  VECTOR(TXT67), VECTOR(PARM1),
                  VECTOR(TXT68), VECTOR(PARM2),
                  VECTOR(TXT69), VECTOR(PARM6),
                  VECTOR(TXT70), VECTOR(PARM7));
IF SETSTA$->VLP_SETSTA_CGINFO.MYSTATION# = ' ' THEN
    PARM6 = 'None';
ELSE
    PARM6 = SETSTA$->VLP_SETSTA_CGINFO.MYSTATION#;
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.OLATCH# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.OLOCK# THEN
    PARM2 = ' YES';
ELSE
    PARM2 = '  NO';
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.OMSGTYP# = ' ' THEN
    PARM7 = 'None';
ELSE
    PARM7 = SETSTA$->VLP_SETSTA_CGINFO.OSTA.OMSGTYP#;
CALL X$WRITE(FDS, VECTOR(FMT01),
                  VECTOR(TXT71), VECTOR(PARM6),
                  VECTOR(TXT72), VECTOR(PARM1),
                  VECTOR(TXT73), VECTOR(PARM2),
                  VECTOR(TXT74), VECTOR(PARM7));
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.OSTATION# = ' ' THEN
    PARM6 = 'None';
ELSE
    PARM6 = SETSTA$->VLP_SETSTA_CGINFO.OSTA.OSTATION#;
IF SETSTA$->VLP_SETSTA_CGINFO.OSTA.WAS# THEN
    PARM1 = ' YES';
ELSE
    PARM1 = '  NO';
CALL X$WRITE(FDS, VECTOR(FMT26),
                  VECTOR(TXT75), VECTOR(PARM6),
                  VECTOR(TXT76), VECTOR(PARM1));
RETURN ;
 
END SETSTA_DISPLAY ;
 
%EJECT ;
/*I*
   NAME:          STALIST_DISPLAY
   PURPOSE:       To display the currently known stations of the selected
                  comgroup.
   CALL:          CALL STALIST_DISPLAY
   DESCRIPTION:   Outputs a list of the currently known stations
*/
 
%EJECT ;
STALIST_DISPLAY:   PROC;
 
DCL         IX                   SBIN ;
DCL         STA$                 PTR ;
DCL         YNS                  CHAR ( 16 ) ;
DCL      1  YN ( 0:3 )           REDEF YNS,
            2  V                 CHAR ( 4 ) ;
 
STA$ = VBASE ( BITVECT ( FPT$CGINFO.STALIST_ ) ) ;
IF ( STA$->VLP_CGSTAL_CGINFO.FOUND# = 1 ) THEN DO;
    CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(EMSG01));
    GOTO PASS_USR_REPORT;
    END;
CALL X$WRITE(FDS, VECTOR(FMT13),
                VECTOR(TXT48), VECTOR(TXT49));
DO IX = 0 TO ( STA$->VLP_CGSTAL_CGINFO.FOUND# - 1 ) ;
    IF ( VLP$SETSTA_LARK.MYSTATION# ~= STA$->VLP_CGSTAL_CGINFO.LIST.NAME#(IX) ) THEN DO ;
       DPARM1 = STA$->VLP_CGSTAL_CGINFO.LIST.READS ( IX ) ;
       DPARM2 = STA$->VLP_CGSTAL_CGINFO.LIST.WRITES ( IX ) ;
       DPARM3 = STA$->VLP_CGSTAL_CGINFO.LIST.PRIO# ( IX );
       DPARM4 = STA$->VLP_CGSTAL_CGINFO.LIST.MSGCNT# ( IX );
       YNS = ' NO  NO  NO  NO ';
       IF STA$->VLP_CGSTAL_CGINFO.LIST.ACTIVE# ( IX ) = %YES# THEN
           YN.V(0) = 'YES ';
       IF STA$->VLP_CGSTAL_CGINFO.LIST.CON# ( IX ) = %YES# THEN
           YN.V(1) = 'YES ';
       IF STA$->VLP_CGSTAL_CGINFO.LIST.PERM# ( IX ) = %YES# THEN
           YN.V(2) = 'YES ';
       IF STA$->VLP_CGSTAL_CGINFO.LIST.AUP# ( IX ) = %YES# THEN
           YN.V(3) = 'YES ';
       CALL X$WRITE(FDS, VECTOR(FMT14),
                       VECTOR(STA$->VLP_CGSTAL_CGINFO.LIST.NAME# ( IX )),
                       VECTOR(DPARM1), VECTOR(DPARM2), VECTOR(DPARM3),
                       VECTOR(DPARM4), VECTOR(YNS));
    END ;
END ;
 
PASS_USR_REPORT: ;
 
RETURN;
 
END STALIST_DISPLAY;
%EJECT ;
/*I*
   NAME:          STATS_DISPLAY
   PURPOSE:       To display the global comgroup statistics of the selected
                  comgroup.
   CALL:          CALL STATS_DISPLAY
   DESCRIPTION:   Outputs a table of comgroup statistics.  Statistics are
                  modified to not include LARK's temporary station.
*/
 
%EJECT ;
STATS_DISPLAY:   PROC;
 
DCL         STATS$               PTR ;
 
STATS$ = VBASE ( BITVECT ( FPT$CGINFO.STATS_ ) ) ;
STATS$->VLR_STATS_CGINFO.NUMDCBS = STATS$->VLR_STATS_CGINFO.NUMDCBS - 1 ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT15 ),
               VECTOR ( TXT50 ),
               VECTOR ( TXT51 ),
               VECTOR ( TXT52 ) ) ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT18 ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.NUMDCBS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.READS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.WRITES ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.NUMTERMS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.GETS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.PUTS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.DISCRDS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.DISCWRS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.CCMQ ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.CCMS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.NODFRS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.GARBCOLLS ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.WRDSUSED  ),
               VECTOR ( STATS$->VLR_STATS_CGINFO.WRDSFREE  ) ) ;
 
RETURN;
 
END STATS_DISPLAY;
 
%EJECT ;
/*I*
   NAME:          TYPLIST_DISPLAY
   PURPOSE:       To display the defined message types of the selected
                  comgroup.
   CALL:          CALL TYPLIST_DISPLAY
   DESCRIPTION:   Outputs a list of message types
*/
 
%EJECT ;
TYPLIST_DISPLAY : PROC ;
 
DCL         IX                   SBIN ;
DCL         TYP$                 PTR ;
DCL         YNS                  CHAR ( 15 ) ;
DCL      1  YN ( 0:2 )           REDEF YNS,
            2  V                 CHAR ( 5 ) ;
 
TYP$ = VBASE ( BITVECT ( FPT$CGINFO.TYPLIST_ ) ) ;
IF ( TYP$->VLP_CGTYPL_CGINFO.FOUND# = 0 ) THEN DO;
    CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(EMSG02));
    GOTO PASS_USR_REPORT;
    END;
CALL X$WRITE(FDS, VECTOR(FMT13),
                VECTOR(TXT77), VECTOR(TXT78));
DO IX = 0 TO ( TYP$->VLP_CGTYPL_CGINFO.FOUND# - 1 ) ;
    DPARM1 = TYP$->VLP_CGTYPL_CGINFO.LIST.PRIO# ( IX );
    DPARM2 = TYP$->VLP_CGTYPL_CGINFO.LIST.NUMWRITES# ( IX );
    YNS = ' NO   NO   NO  ';
    IF TYP$->VLP_CGTYPL_CGINFO.LIST.JOURNAL# ( IX ) = %YES# THEN
        YN.V(0) = ' YES ';
    IF TYP$->VLP_CGTYPL_CGINFO.LIST.ONEREPORT# ( IX ) = %YES# THEN
        YN.V(1) = ' YES ';
    IF TYP$->VLP_CGTYPL_CGINFO.LIST.PERM# ( IX ) = %YES# THEN
        YN.V(2) = ' YES ';
    CALL X$WRITE(FDS, VECTOR(FMT27),
                    VECTOR(TYP$->VLP_CGTYPL_CGINFO.LIST.NAME# ( IX )),
                    VECTOR(DPARM1), VECTOR(YNS),VECTOR(DPARM2));
END ;
 
PASS_USR_REPORT: ;
 
RETURN;
 
END TYPLIST_DISPLAY ;
%EJECT ;
/*I*
   NAME:          FPRGS_DISPLAY
   PURPOSE:       To display fprg stations connected to the comgroup.
   CALL:          CALL FPRGS_DISPLAY
   DESCRIPTION:   Outputs a list of fprg stations
*/
%EJECT ;
 
FPRGS_DISPLAY : PROC ;
 
DCL DEVPRES        CHAR (  8 ) ;
DCL COUNT          SBIN ;
 
IF ( FPRGLIST_CT = 0 )  THEN DO ;
   CALL X$WRITE ( FDS, VECTOR ( FMT00 ), VECTOR ( EMSG07 ) );
   GOTO PASS_USR_REPORT ;
END ;
 
CALL X$WRITE ( FDS, VECTOR ( FMT13 ), VECTOR ( TXT93 ), VECTOR ( TXT94 ) );
 
DO COUNT = 0 TO  %MAX_FPRGS - 1 ;
   IF FPRGLIST.IN_USE# ( COUNT ) THEN DO ;
      IF FPRGLIST.DEVPRES# ( COUNT ) THEN DO ;
         DEVPRES = '    YES' ;
         END ;
      ELSE DO ;
         DEVPRES = '     NO' ;
      END ;
      CALL X$WRITE ( FDS,
                     VECTOR ( FMT36 ),
                     VECTOR ( FPRGLIST.FID# ( COUNT ) ),
                     VECTOR ( FPRGLIST.STATION# ( COUNT ) ),
                     VECTOR ( DEVPRES ) ) ;
    END;
END ;
 
PASS_USR_REPORT : ;
 
RETURN ;
 
END FPRGS_DISPLAY ;
 
%EJECT ;
/*I*
   NAME:          FSTA_DISPLAY
   PURPOSE:       To display function stations connected to the comgroup.
   CALL:          CALL FSTA_DISPLAY
   DESCRIPTION:   Outputs a list of function stations
*/
%EJECT ;
FSTA_DISPLAY : PROC ;
 
DCL COUNT SBIN ;
DCL OUTPUT_HEADER BIT ( 1 ) ;
 
OUTPUT_HEADER = %FALSE ;
 
 
DO COUNT = 0 TO NAMELIST_CT - 1 ;
 
   IF NAMELIST.FUNCTION_STA# ( COUNT ) ~= ' ' THEN DO ;
      IF ~ OUTPUT_HEADER THEN DO ;
         OUTPUT_HEADER = %TRUE ;
         CALL X$WRITE ( FDS, VECTOR ( FMT13 ),
                        VECTOR ( TXT95 ),
                        VECTOR ( TXT96 ) );
       END ;
 
       CALL X$WRITE ( FDS, VECTOR ( FMT37 ),
                      VECTOR ( NAMELIST.FUNCTION_STA# ( COUNT ) ),
                      VECTOR ( NAMELIST.CONTROL_STA# ( COUNT ) ),
                      VECTOR ( NAMELIST.GHOST_SYSID# ( COUNT ) ) ) ;
      END ;
END ;
 
IF  ~ OUTPUT_HEADER THEN DO ;
   CALL X$WRITE ( FDS, VECTOR ( FMT00 ), VECTOR ( EMSG08 ) );
   GOTO PASS_USR_REPORT ;
END ;
 
PASS_USR_REPORT: ;
   RETURN ;
 
END FSTA_DISPLAY ;
 
END LARK_DISPLAY_CMD ;
