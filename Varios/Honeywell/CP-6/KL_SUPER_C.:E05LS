

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         1    
    1      /*M* KL_SUPER_C Subs and structures for HLP files built by SUPER */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*DMC,PLM=6,IND=2,ENU=2,DCI=4,CSU=2,ECU=2,THI=2,DTI=0*/
    8
    9
   10      /* SUBS FOR KL$PHDR.TTYP AND KL_RDBF.TYP  */
   11
   12                   /*F* NAME:  KLTY_E
   13                     The values of the profile types (async, rbt, rbtd, urp,
   14                     link, 3270, vircir, and any new ones) used in these
   15                     EQUates is duplicated for the subs in LISTing the
   16                     various profiles.  If these get changed, then the LISP_?
   17                     subs in AS_SUBS_C must get updated.
   18                  */
   19      %EQU KLTY_PROG#=0;    /* L6 PROGRAM - NO PROFILE  */
   20      /*K* KLTY_PROG#
   21      .trf ]#
   22      KLTY_PROG]                    FEP Program - No PROFILE.
   23      .trf ]]
   24      */
   25      %EQU KLTY_SDEV#=1;    /* TERMINAL TYPE SYNC DEVICE (SUB-DEV) */
   26      /*K* KLTY_SDEV#
   27      .trf ]#
   28      KLTY_SDEV]                    Terminal type SYNC device (SUB-DEV).
   29      .trf ]]
   30      */
   31      %EQU KLTY_TTY#=2;      /* TERMINAL TYPE TTY */
   32      /*K* KLTY_TTY#
   33      .trf ]#
   34      KLTY_TTY]                     Terminal type TTY.
   35      .trf ]]
   36      */
   37      %EQU KLTY_STRM#=3;    /* TERMINAL TYPE SYNC TERMINAL */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         2    
   38      /*K* KLTY_STRM#
   39      .trf ]#
   40      KLTY_STRM]                    Terminal type SYNC terminal.
   41      .trf ]]
   42      */
   43      %EQU KLTY_LINK#=4;    /* X25 - LINK LINE */
   44      /*K* KLTY_LINK#
   45      .trf ]#
   46      KLTY_LINK]                    X25 - Link Line.
   47      .trf ]]
   48      */
   49      %EQU KLTY_FEP#=5 ;
   50      /*K* KLTY_FEP#
   51      .trf ]#
   52      KLTY_FEP]                     FEP node.
   53      .trf ]]
   54      */
   55      %EQU KLTY_URP#=6 ;    /* L6 UNIT RECORD PERIPHERAL */
   56      /*K* KLTY_URP#
   57      .trf ]#
   58      KLTY_URP]                     FEP Unit Record Peripheral.
   59      .trf ]]
   60      */
   61      %EQU KLTY_3270#=7 ;  /* 3270 DEVICE */
   62      /*K* KLTY_3270#
   63      .trf ]#
   64      KLTY_3270]                    3270 Line.
   65      .trf ]]
   66      */
   67      %EQU KLTY_VIRCIR#=8 ;  /* VIRTUAL CIRCUIT DEVICE */
   68      /*K* KLTY_VIRCIR#
   69      .trf ]#
   70      KLTY_VIRCIR]                  Virtual Circuit Device.
   71      .trf ]]
   72      */
   73      %EQU KLTY_CONT#=9 ;  /* CONTROLLER FOR 3270 */
   74      /*K* KLTY_CONT#
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         3    
   75      .trf ]#
   76      KLTY_CONT]                    Controller for 3270.
   77      .trf ]]
   78      */
   79      %EQU KLTY_LINEDEV# = 10 ;  /* DEVICE FOR 3270  */
   80      /*K* KLTY_LINEDEV#
   81      .trf ]#
   82      KLTY_LINEDEV]                 Device for 3270.
   83      .trf ]]
   84      */
   85      %EQU KLTY_LINKDEV# = 11 ;  /* COMM LINE DEVICE FOR LINK  */
   86      /*K* KLTY_LINKDEV#
   87      .trf ]#
   88      KLTY_LINKDEV]                 Communication Line Device for LINK.
   89      .trf ]]
   90      */
   91      %EQU KLTY_HIP_CONT# = 12 ; /* CONTROLLER FOR POLLED VIP */
   92      /*K* KLTY_HIP_CONT#
   93      .trf ]#
   94      KLTY_HIP_CONT]                Controller for Polled VIP.
   95      .trf ]]
   96      */
   97      %EQU KLTY_HIP_LINE# = 13 ; /* COMM LINE FOR POLLED VIP */
   98      /*K* KLTY_HIP_LINE#
   99      .trf ]#
  100      KLTY_HIP_LINE]                Communication Line for Polled VIP.
  101      .trf ]]
  102      */
  103      %EQU KLTY_HIP_DEV# = 14 ; /* DEVICE FOR POLLED VIP */
  104      /*K* KLTY_HIP_DEV#
  105      .trf ]#
  106      KLTY_HIP_DEV]                 Device for Polled VIP.
  107      .trf ]]
  108      */
  109
  110
  111      /*   EQUS FOR PROFILE LINE DEVICES                       */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         4    
  112
  113      %EQU KL_PRMID_SGON=12 ;                  /* SIGNON TO REMOTE HOST */
  114      %EQU KL_PRMID_TRMD=13 ;                  /* MULTIDEV TERM DESC BLOCK */
  115      %EQU KL_PRMID_LINK=23 ;                  /* LINK PROFILE TYPE */
  116      %EQU KL_PRMID_VIRCIR=27 ;                  /* VIRTUAL CIRCUIT PROFILE TYPE */
  117
  118
  119      /*F* NAME: KL_PHDR
  120
  121      The KL_PHDR macro defines the structure for the header
  122      portion of the :PRO profile records.
  123      */
  124
  125      %MACRO KL_PHDR (NAME=KL_PHDR,STCLASS=STATIC,TYP=%KLTY_TTY#,
  126                    WID=80,LIN=38,A='0'B,BN='0'B,TOP='1'B,LC='1'B,
  127                    UC='1'B,NTL='0'B,NOX='0'B,GR='0'B,TR='0'B,
  128                    IN='1'B,OUT='1'B,INF='0'B,DLP='1'B,DCP='0'B,
  129                    DIC='1'B,DGR='0'B,GRFPRG=' ',LAST=";");
  130
  131       %LSET LISTDIR='0'B;
  132       %LSET LISTEXP='1'B;
  133       %LSET LISTCOM='0'B;
  134       %LSET LISTSUB='1'B;
  135       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  136       %IF (SUBSTR(STR,0,6)='STATIC') OR
  137       (SUBSTR(STR,0,8)='CONSTANT') OR
  138       (SUBSTR(STR,0,3)='EXT');
  139       %LSET INIT=CHARTEXT('INIT');
  140       %ELSE;
  141       %LSET INIT=CHARTEXT('/*');
  142       %ENDIF;
  143
  144      DCL 1 NAME STCLASS,
  145            2 TTYP UBIN BYTE UNAL %INIT(TYP)%CHARTEXT('/**/'),      /*TERM TYPE*/
  146            2 WIDTH UBIN BYTE UNAL %INIT(WID)%CHARTEXT('/**/'),     /*CARRIAGE WIDTH*/
  147            2 LINES UBIN HALF UNAL %INIT(LIN)%CHARTEXT('/**/'),     /*LINES PER PAGE*/
  148            2 ATTR,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         5    
  149              3 * BIT(9) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  150              3 GRLGL BIT(1) UNAL %INIT(GR)%CHARTEXT('/**/'),  /*GRAPHIC LEGAL*/
  151              3 TRANSLGL BIT(1) UNAL %INIT(TR)%CHARTEXT('/**/'),  /*TRANS LEGAL*/
  152              3 NOXLATE BIT(1) UNAL %INIT(NOX)%CHARTEXT('/**/'),  /* NOXLATE */
  153              3 UPPERCASE BIT(1) UNAL %INIT(UC)%CHARTEXT('/**/'),  /*UPPERCASE*/
  154              3 NATL BIT(1) UNAL %INIT(NTL)%CHARTEXT('/**/'),  /*NATL*/
  155              3 TRUOVRPRT BIT(1) UNAL %INIT(TOP)%CHARTEXT('/**/'),  /*TRULY OVERPRINTS*/
  156              3 APL BIT(1) UNAL %INIT(A)%CHARTEXT('/**/'),          /* APL CHAR SET*/
  157              3 BIN BIT(1) UNAL %INIT(BN)%CHARTEXT('/**/'),         /*BINARY LEGAL*/
  158              3 LCASE BIT(1) UNAL %INIT(LC)%CHARTEXT('/**/'),       /*LOWERCASE PRINTS*/
  159            2 IO UNAL,
  160              3 INPUT BIT(1) %INIT(IN)%CHARTEXT('/**/'),            /*INPUT IS LEGAL*/
  161              3 OUTPUT BIT(1) %INIT(OUT)%CHARTEXT('/**/'),          /*OUTPUT IS LEGAL*/
  162            2 IMP# UBIN(7) UNAL %INIT(0)%CHARTEXT('/**/'), /* Number of IMP records */
  163            2 DDEV,
  164              3 LP BIT(1) UNAL %INIT(DLP)%CHARTEXT('/**/'),         /*LIKE LP - VFC WORKS*/
  165              3 CP BIT(1) UNAL %INIT(DCP)%CHARTEXT('/**/'),         /*LIKE CP - RECS NOT FORMS*/
  166              3 IC BIT(1) UNAL %INIT(DIC)%CHARTEXT('/**/'),         /*LIKE TS TERM ECHOS*/
  167              3 GRAPHICS_OK BIT(1) UNAL %INIT(DGR)%CHARTEXT('/**/'),
  168              3 * BIT(5) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  169            2 GR_FPRG CHAR(64) UNAL %INIT(GRFPRG)%CHARTEXT('/**/'),
  170            2 INFO BIT(72) %INIT(INF)%CHARTEXT('/**/')LAST
  171      %MEND;
  172      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         6    
  173
  174
  175      /* SUBS FOR KL$DREC.ATYP  */
  176
  177      %EQU KLAT_STA#=0;      /* STATION - CANNOT LOG ON */
  178      %EQU KLAT_TS#=1;        /* TIMESHARING                                */
  179      %EQU KLAT_CG#=2;        /* COMGROUP                                   */
  180      %EQU KLAT_RES#=3;      /* RESOURCE                                   */
  181      %EQU KLAT_TRM#=4;      /* TERMINAL                                   */
  182      %EQU KLAT_LINE#=5;    /* POLLED LINE (3270-TYPE)                     */
  183      %EQU KLAT_LNKLINE#=6;      /*  LINK LINE  */
  184      %EQU KLAT_NETWORK#=7;         /* Network Connection */
  185      %EQU KLAT_NULL#=511;         /* Not a logon record */
  186
  187
  188      /* SUBS FOR CONSOLE INFO DEFAULTS */
  189
  190      %EQU KLOC_DFPRI=7;    /* DEFAULT MAXPRI (TEMP) */
  191      %EQU KLIS_DFNAC=':NCTL';   /* DEFAULT NACCT */
  192      %EQU KLIS_DFPRI=511;  /* DEFAULT FOR IS MX AND DFLT PRIO */
  193      %EQU KLOS_DFFMLP='STDLP';  /* DEFAULT OS FNAME IF TYP=LP */
  194      %EQU KLOS_DFFMXX='STD**';   /* DEFAULT OS FNAME IF TYP~=LP */
  195
  196
  197
  198      /*F* NAME: KL_DREC - Device Logon Structure
  199
  200      The KL_DREC macro in file KL_SUPER_C defines the structure
  201      for device logon records in :HLP.
  202
  203      This is the structure that is passed to the handler's
  204      administrative routine when the value of KH$ADMIN_FPT.FNC
  205      is %KHA_FNC_BLDCTX and the value in KHA$ADMIN_FPT.TERMID.LEV is 1.
  206
  207      */
  208
  209      %MACRO KL_DREC (NAME=KL_DREC,TYP = %KLAT_TS#, RN = '0'B, GOK = '0'B, TOK='0'B,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         7    
  210                    GJ='0'B,OOK='1'B,BOK='1'B, SUPR = 0, WSN = '0000', PASS = ' ',
  211                    PRO = ' ', WORG = 'LOCAL', RNAME = 'SYS', CLASS = 0,
  212                    STCLASS = STATIC,LAST=",",NWI=0,TNM='LOCAL') ;
  213
  214       %LSET LISTDIR='0'B;
  215       %LSET LISTEXP='1'B;
  216       %LSET LISTCOM='0'B;
  217       %LSET LISTSUB='1'B;
  218       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  219       %IF (SUBSTR(STR,0,6)='STATIC') OR
  220       (SUBSTR(STR,0,8)='CONSTANT') OR
  221       (SUBSTR(STR,0,3)='EXT');
  222       %LSET INIT=CHARTEXT('INIT');
  223       %ELSE;
  224       %LSET INIT=CHARTEXT('/*');
  225       %ENDIF;
  226
  227      DCL 1 NAME STCLASS ALIGNED,
  228      /*K* ATYP - UBIN BYTE.
  229      Contains the attachment type.  See the KLAT_? EQUs in the KL_SUPER_C
  230      INCLUDE file.
  231      */
  232            2 ATYP UBIN BYTE UNAL %INIT(TYP)%CHARTEXT('/**/'), /* ATTACHMENT TYPE */
  233      /*K* FLAGS.
  234      Contains the following flags.*/
  235            2 FLAGS,
  236      /*K* FLAGS.RNME - BIT(1).
  237      If set, indicates RENAME is present.*/
  238              3 RNME BIT(1) UNAL %INIT(RN)%CHARTEXT('/**/'), /* RENAME PRESENT */
  239      /*K* FLAGS.GHOSTOK - BIT(1).
  240      If set, indicates that ghost access is legal for this user.  Permitted
  241      for time-sharing only.*/
  242              3 GHOSTOK BIT(1) UNAL %INIT(GOK)%CHARTEXT('/**/'), /* GHOST CAN RUN HERE (TS ONLY) */
  243      /*K* FLAGS.OLOK - BIT(1).
  244      If set, indicates that online is legal.*/
  245              3 OLOK BIT(1) %INIT(OOK)%CHARTEXT('/**/'),     /* ONLINE LEGAL */
  246      /*K* FLAGS.BATOK - BIT(1).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         8    
  247      If set, indicates that batch mode is legal for this user.  (Not used.)
  248      */
  249              3 BATOK BIT(1) %INIT(BOK)%CHARTEXT('/**/'),    /* BATCH LEGAL (UNUSED) */
  250      /*K* FLAGS.GJOB - BIT(1).
  251      If set, indicates that a ghost job starts when the terminal connects.
  252      This flag is meaningful for HASP, 2780, and 3780.*/
  253              3 GJOB BIT(1) %INIT(GJ)%CHARTEXT('/**/'),      /* TERMINAL HAS GJOB */
  254      /*K* FLAGS.USETP - BIT(1).
  255      If set, indicates that USE=TP.*/
  256              3 USETP BIT(1) %INIT('0'B)%CHARTEXT('/**/'),  /* IF USE=TP */
  257      /*K* FLAGS.NOCGREJ - BIT(1).
  258      If set, indicates that the device's logon is to be rejected if the
  259      comgroup is not open, or that the device is to be disconnected if the
  260      device is connected when the comgroup closes.*/
  261              3 NOCGREJ BIT(1) %INIT('0'B)%CHARTEXT('/**/'),  /* REJECT IF NO CG */
  262      /*K* FLAGS.NOCGINF - BIT(1).
  263      If set, indicates that the device is to be kept connected and informed
  264      that it cannot operate, if the comgroup is not open when the device
  265      logs on or if the comgroup closes while the device is connected.*/
  266              3 NOCGINF BIT(1) %INIT('0'B)%CHARTEXT('/**/'),  /* INFORM IF NO CG */
  267      /*K* FLAGS.TPOK - BIT(1).
  268      If set, indicates that TP is legal.*/
  269              3 TPOK BIT(1) %INIT(TOK)%CHARTEXT('/**/'),      /* TP LEGAL */
  270      /*K* FLAGS.FEOK - BIT(1).
  271      If set, indicates that front-end processing access is legal for this
  272      user. */
  273              3 FEOK BIT(1) %INIT('0'B)%CHARTEXT('/**/'),  /* FE LEGAL */
  274      /*K* COS - UBIN(8).
  275      Contains the class of service.  Not currently used.*/
  276            2 COS UBIN(8)  UNAL %INIT(CLASS)%CHARTEXT('/**/'), /* Class of service */
  277      /*K* SUPER - UBIN(9).
  278      Is reserved for use by SUPER.*/
  279            2 SUPER UBIN(9) UNAL %INIT(SUPR)%CHARTEXT('/**/'), /* RESERVED FOR SUPER*/
  280      /*K* TWSN# - CHAR(4).
  281      Contains the terminal's Work Station number.*/
  282            2 TWSN# CHAR(4) %INIT(WSN)%CHARTEXT('/**/'),   /* TERMINAL / WSN NUMBER  */
  283      /*K* PASSWORD - CHAR(8).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         9    
  284      Contains the password.*/
  285            2 PASSWORD CHAR(8) %INIT(PASS)%CHARTEXT('/**/'), /* PASSWORD */
  286      /*K* ENCODPW - BIT(72).
  287      Contains the encoded password.*/
  288      %IF NOT(MODE_FEP);
  289            2 ENCODPW REDEF PASSWORD BIT(72), /* ENCODED PASSWORD  */
  290      %ENDIF;
  291            2 PNAME,                /* DEFAULT PROFILE */
  292      %IF PRO=' ';
  293      %SET PROCNT = CHARTEXT('0');
  294      %ELSE;
  295      %SET PROCNT = CHARTEXT(BINCHAR(LENGTHC(PRO)));
  296      %ENDIF;
  297      /*K* PNAME.CNT - UBIN BYTE.
  298      Contains the length of the default profile name.*/
  299              3 CNT UBIN BYTE UNAL %INIT(%PROCNT)%CHARTEXT('/**/'),
  300      /*K* PNAME.TXT - CHAR(11).
  301      Contains the default profile name.*/
  302              3 TXT CHAR(11) UNAL %INIT(PRO)%CHARTEXT('/**/'),
  303      /*K* WOO - CHAR(8).
  304      Contains the Workstation of origin.*/
  305            2 WOO CHAR(8) %INIT(WORG)%CHARTEXT('/**/'),    /* WSN-OF-ORIGON */
  306      /*K* RENAME - CHAR(8).
  307      Contains the new logon name.*/
  308            2 RENAME CHAR(8) %INIT(RNAME)%CHARTEXT('/**/'), /* NEW LOGON NAME  */
  309            2 HPS REDEF RENAME,     /* HOME PACKSET */
  310      /*K* HPS.N - CHAR(6).
  311      Contains the home packset name.  KL_DREC.HPS is a redefinition
  312      of KL_DREC.RENAME.*/
  313              3 N CHAR(6) UNAL,
  314              3 * CHAR(2) UNAL,
  315      /*K* TNAME - CHAR(8).
  316      Contains the 'FOR' station name specified in the SUPER command.
  317      CREATE TERMINAL. */
  318            2 TNAME CHAR(8) %INIT(' ')%CHARTEXT('/**/'),  /* 'FOR' TERMINAL NAME */
  319      /*K* SNAME - CHAR(8).
  320      Contains the 'FOR' station name specified in the SUPER command
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         10   
  321      CREATE DEVICE. */
  322            2 SNAME CHAR(8) %INIT(TNM)%CHARTEXT('/**/'),  /* 'FOR' STATION NAME */
  323      /*K* NWINFO - UBIN WORD.
  324      Contains the number of words of information the KL_DREC structure.*/
  325            2 NWINFO UBIN WORD %INIT(NWI)%CHARTEXT('/**/')LAST
  326      %MEND;
  327
  328
  329      /*F* NAME: KL_FEBLK
  330
  331      The KL_FEBLK macro defines the structure for the
  332      FE User record in :HLP.
  333      */
  334
  335      %MACRO KL_FEBLK (NAME=KL_FEBLK,STCLASS=BASED,LVL=1,RCNT=0,LAST=";");
  336
  337       %LSET LISTDIR='0'B;
  338       %LSET LISTEXP='1'B;
  339       %LSET LISTCOM='0'B;
  340       %LSET LISTSUB='1'B;
  341       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  342       %IF (SUBSTR(STR,0,6)='STATIC') OR
  343       (SUBSTR(STR,0,8)='CONSTANT') OR
  344       (SUBSTR(STR,0,3)='EXT');
  345       %LSET INIT=CHARTEXT('INIT');
  346       %ELSE;
  347       %LSET INIT=CHARTEXT('/*');
  348       %ENDIF;
  349
  350       %IF LVL=1;
  351      DCL 1 NAME STCLASS,
  352       %ELSE;
  353            %LVL NAME,
  354       %ENDIF;
  355              %(LVL+1) BILL(0:3) CHAR(6) UNAL %INIT('1','1','1','1')%CHARTEXT('/**/'),
  356              %(LVL+1) DBACCN CHAR(8) UNAL %INIT(' ')%CHARTEXT('/**/'),
  357              %(LVL+1) MINTS(0:3) UBIN BYTE UNAL %INIT(0*0)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         11   
  358              %(LVL+1) MFPRG UBIN BYTE UNAL %INIT(255)%CHARTEXT('/**/'),
  359              %(LVL+1) MACCTMEM UBIN HALF UNAL %INIT(9999)%CHARTEXT('/**/'),
  360              %(LVL+1) FLAGS,
  361              %(LVL+2) STEPACCT BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
  362              %(LVL+2) * BIT(8) %INIT('0'B*0)%CHARTEXT('/**/'),
  363              %(LVL+1) PRIV(0:3) BIT(36) ALIGNED %INIT('0'B*0)%CHARTEXT('/**/'),
  364              %(LVL+1) PPRIV(0:3) BIT(36) ALIGNED %INIT('0'B*0)%CHARTEXT('/**/'),
  365              %(LVL+1) MTIME(0:3) SBIN WORD UNAL %INIT(59999400, 59999400, 59999400, 59999400)%CHARTEXT('/**/'),
  366              %(LVL+1) MMEM(0:3) UBIN HALF UNAL %INIT(128,128,128,128)%CHARTEXT('/**/'),
  367              %(LVL+1) CXTMEM(0:7) ,
  368              %(LVL+2) UMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  369              %(LVL+2) CMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  370              %(LVL+2) HMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  371              %(LVL+2) GMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  372              %(LVL+1) PSDOL(0:7) ,
  373              %(LVL+2) PSDO_NAME CHAR(8) UNAL %INIT(' '*0)%CHARTEXT('/**/'),
  374              %(LVL+2) UMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  375              %(LVL+2) CMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  376              %(LVL+2) HMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  377              %(LVL+2) GMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  378              %(LVL+1) RESL_CNT UBIN HALF UNAL %INIT(RCNT)%CHARTEXT('/**/'),
  379              %(LVL+1) RESL(0:RCNT),
  380              %(LVL+2) RNAME CHAR(2) UNAL %INIT(' '*0)%CHARTEXT('/**/'),
  381              %(LVL+2) UMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  382              %(LVL+2) CMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  383              %(LVL+2) HMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
  384              %(LVL+2) GMAX UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/')LAST
  385      %MEND ;
  386
  387
  388      /*F* NAME: KL_GJOB
  389
  390      The KL_GJOB macro defines the structure for
  391      GJOB information for terminals.
  392      */
  393
  394      %MACRO KL_GJOB( NAME=KL_GJOB,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         12   
  395                      STCLASS=STATIC,
  396                      UNAME#=' ',
  397                      ACCT#=' ',
  398                      PASS#=' ',
  399                      LVL=1,
  400                      CMDCNT#=0,
  401                      CMD#=' ',
  402                      LAST=";" );
  403       %LSET LISTDIR='0'B;
  404       %LSET LISTEXP='1'B;
  405       %LSET LISTCOM='0'B;
  406       %LSET LISTSUB='1'B;
  407       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  408       %IF (SUBSTR(STR,0,6)='STATIC') OR
  409       (SUBSTR(STR,0,8)='CONSTANT') OR
  410       (SUBSTR(STR,0,3)='EXT');
  411       %LSET INIT=CHARTEXT('INIT');
  412       %ELSE;
  413       %LSET INIT=CHARTEXT('/*');
  414       %ENDIF;
  415       %IF LVL=1;
  416      DCL 1 NAME STCLASS ALIGNED,
  417       %ELSE;
  418            %LVL NAME ALIGNED,
  419       %ENDIF;
  420              %(LVL+1) ACCT CHAR(8) UNAL %INIT(ACCT#)%CHARTEXT('/**/'),
  421              %(LVL+1) UNAME CHAR(12) UNAL %INIT(UNAME#)%CHARTEXT('/**/'),
  422              %(LVL+1) PASS CHAR(8) UNAL %INIT(PASS#)%CHARTEXT('/**/'),
  423              %(LVL+1) CMDCNT UBIN WORD  %INIT(CMDCNT#)%CHARTEXT('/**/'),
  424              %(LVL+1) CMD CHAR(80) UNAL %INIT(CMD#)%CHARTEXT('/**/')LAST
  425      %MEND;
  426      /*F* NAME: KL_SS
  427
  428      The KL_SS nmacro defines the structure for
  429      sign on blocks in terminal default records.
  430      */
  431
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         13   
  432      %MACRO KL_SS (  NAME = KL_SS ,
  433                    STCLASS = STATIC ,
  434                    TY=' ',
  435                    NUMB=' ',
  436                    TWSN#=' ',
  437                    LVL = 1,
  438                    NM = 0,
  439                    LAST = ";",
  440                    PRO=' ') ;
  441
  442       %LSET LISTDIR='0'B;
  443       %LSET LISTEXP='1'B;
  444       %LSET LISTCOM='0'B;
  445       %LSET LISTSUB='1'B;
  446       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  447       %IF (SUBSTR(STR,0,6)='STATIC') OR
  448       (SUBSTR(STR,0,8)='CONSTANT') OR
  449       (SUBSTR(STR,0,3)='EXT');
  450       %LSET INIT=CHARTEXT('INIT');
  451       %ELSE;
  452       %LSET INIT=CHARTEXT('/*');
  453       %ENDIF;
  454      %IF NM=0;
  455      %LSET ARY=CHARTEXT('/**/');
  456      %ELSE;
  457      %LSET ARY=CHARTEXT(CONCAT('(0:',TEXTCHAR(NM),')'));
  458      %ENDIF;
  459
  460       %IF LVL=1;
  461      DCL 1 NAME %ARY STCLASS,
  462       %ELSE;
  463            %LVL NAME %ARY,
  464       %ENDIF;
  465              %(LVL+1) CNT UBIN BYTE UNAL %INIT(26)%CHARTEXT('/**/'),
  466              %(LVL+1) SGN ,
  467              %(LVL+2) TYPE CHAR(2) UNAL %INIT( TY )%CHARTEXT('/**/'),
  468              %(LVL+2) NUM CHAR(2) UNAL %INIT( NUMB )%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         14   
  469              %(LVL+2) TWSN CHAR(4) UNAL %INIT( TWSN# )%CHARTEXT('/**/'),
  470              %(LVL+2) * CHAR(1) UNAL %INIT( ',' )%CHARTEXT('/**/'),
  471              %(LVL+2) * CHAR(1) UNAL %INIT('*')%CHARTEXT('/**/'),
  472              %(LVL+2) * CHAR(1) UNAL %INIT( ' ' )%CHARTEXT('/**/'),
  473              %(LVL+2) * CHAR(4) UNAL %INIT( 'PRO=' )%CHARTEXT('/**/'),
  474              %(LVL+2) PNAME CHAR(11) UNAL %INIT( PRO ) %CHARTEXT('/**/'),
  475              %(LVL+1) SGN_R REDEF SGN CHAR(26) LAST
  476      %MEND ;
  477
  478      %EQU KL_DEVMODE_INCOMING# = 1;
  479      %EQU KL_DEVMODE_OUTGOING# = 2;
  480      %EQU KL_DEVMODE_FIXED#    = 3;
  481      /*F* NAME:  KL_RES_CL_DEV - Resource Communication Line Structure
  482
  483      The KL_RES_CL_DEV macro in the file KL_SUPER_C defines the structure
  484      for comm line resource devices.
  485
  486
  487      */
  488
  489      %MACRO KL_RES_CL_DEV (NAME=KL_REC_CL_DEV,STCLASS=BASED,LVL=1,LAST=";");
  490
  491       %LSET LISTDIR='0'B;
  492       %LSET LISTEXP='1'B;
  493       %LSET LISTCOM='0'B;
  494       %LSET LISTSUB='1'B;
  495       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  496       %IF (SUBSTR(STR,0,6)='STATIC') OR
  497       (SUBSTR(STR,0,8)='CONSTANT') OR
  498       (SUBSTR(STR,0,3)='EXT');
  499       %LSET INIT=CHARTEXT('INIT');
  500       %LSET ENIT=CHARTEXT(' ');
  501       %ELSE;
  502       %LSET INIT=CHARTEXT('/*');
  503       %LSET ENIT=CHARTEXT('*/');
  504       %ENDIF;
  505
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         15   
  506       %IF LVL=1;
  507      DCL 1 NAME STCLASS,
  508       %ELSE;
  509            %LVL NAME,
  510       %ENDIF;
  511
  512      /*K* MODE - UBIN BYTE.
  513      Options available - INCOMING | OUTGOING | FIXED.
  514
  515        INCOMING describes the possible appearance of some number of
  516        incoming "lines" whose existence is to be reported to the attached
  517        Host user (if any), so that the host user can then connect to
  518        the "lines" individually.
  519
  520        OUTGOING describes the availability of some number of "lines"
  521        that can be created as needed when so requested by Host users.
  522
  523        FIXED describes a single facility like an Async modem, which is
  524        entirely controlled by a single Host user at a time.
  525      */
  526              %(LVL+1) MODE UBIN BYTE UNAL %INIT(%KL_DEVMODE_OUTGOING#)%ENIT,
  527
  528      /*K* ATTR - UBIN HALF.
  529      Contains the attribute list for the device.  */
  530              %(LVL+1) ATTR,
  531              %(LVL+2) B300# BIT(1) UNAL %INIT('0'B)%ENIT,
  532              %(LVL+2) B1200# BIT(1) UNAL %INIT('0'B)%ENIT,
  533              %(LVL+2) B2400# BIT(1) UNAL %INIT('0'B)%ENIT,
  534              %(LVL+2) HAYES# BIT(1) UNAL %INIT('0'B)%ENIT,
  535              %(LVL+2) X28# BIT(1) UNAL %INIT('0'B)%ENIT,
  536              %(LVL+2) RFU13# BIT(1) UNAL %INIT('0'B)%ENIT,
  537              %(LVL+2) TCPIP# BIT(1) UNAL %INIT('0'B)%ENIT,
  538              %(LVL+2) RFU11# BIT(1) UNAL %INIT('0'B)%ENIT,
  539              %(LVL+2) RFU10# BIT(1) UNAL %INIT('0'B)%ENIT,
  540              %(LVL+2) RFU9# BIT(1) UNAL %INIT('0'B)%ENIT,
  541              %(LVL+2) RFU8# BIT(1) UNAL %INIT('0'B)%ENIT,
  542              %(LVL+2) RFU7# BIT(1) UNAL %INIT('0'B)%ENIT,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         16   
  543              %(LVL+2) RFU6# BIT(1) UNAL %INIT('0'B)%ENIT,
  544              %(LVL+2) RFU5# BIT(1) UNAL %INIT('0'B)%ENIT,
  545              %(LVL+2) RFU4# BIT(1) UNAL %INIT('0'B)%ENIT,
  546              %(LVL+2) RFU3# BIT(1) UNAL %INIT('0'B)%ENIT,
  547              %(LVL+2) RFU2# BIT(1) UNAL %INIT('0'B)%ENIT,
  548              %(LVL+2) RFU1# BIT(1) UNAL %INIT('0'B)%ENIT,
  549
  550      /*K* RNAME - CHAR(6).
  551      Contains the name of this specific resource.  */
  552              %(LVL+1) RNAME CHAR(6) UNAL %INIT(' ')%ENIT,
  553
  554      /*K* AUACCOUNT - CHAR(8).
  555      Contains the account permitted to act as the administrative  */
  556              %(LVL+1) AUACCOUNT CHAR(8) UNAL %INIT(' ')%ENIT LAST
  557
  558      %MEND;
  559      /*F* NAME: KL_WSNCVT
  560
  561      The KL_WSNCVT macro defines the structure for WSN-TWSN
  562      conversion records.
  563      */
  564
  565      %MACRO KL_WSNCVT (NAME=KL_WSNCVT,STCLASS=BASED);
  566      DCL 1 NAME STCLASS ALIGNED ,
  567            2 ATYPE UBIN (9) CALIGNED ,
  568            2 * UBIN                                         (27) CALIGNED ,
  569            2 LTWSN UBIN WORD ALIGNED ,  /* LARGEST TWSN USED */
  570            2 WSN(0:0) CHAR(8) ALIGNED ;  /* WSN INDEXED BY CHARBIN(TWSN) */
  571      %MEND ;
  572
  573
  574      /*F* NAME: KL_TWSNREC
  575
  576      */
  577
  578      /*F* NAME: KL_WSNDEV
  579
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         17   
  580      The KL_WSNDEV macro defines the structure for the
  581      WSN record with all the device names.
  582      */
  583
  584      %MACRO KL_WSNDEV (NAME=KL_WSNDEV,STCLASS=BASED);
  585      DCL 1 NAME STCLASS ALIGNED ,
  586            2 NDEV UBIN WORD ALIGNED,     /* TOTAL NUMBER OF DEVICES  */
  587            2 DEV(0:0) CHAR(8) ALIGNED ;  /* DEVICE NAMES FOR THIS WSN */
  588      %MEND ;
  589
  590      %MACRO KL_TWSNREC  (NAME=KL_TWSNREC,STCLASS=BASED);
  591      DCL 1 NAME STCLASS ALIGNED,
  592            2 WSN CHAR(8),          /* WSN name if any assigned   */
  593            2 STATION CHAR(8),      /* Station name */
  594            2 NDEV UBIN WORD,         /* NUMBER OF DEVICES IN DEVS */
  595            2 DEVS (0:0),             /* DEVICE INFORMATION */
  596              3 TYP CHAR(2) UNAL,     /* DEVICE TYPE ('LP') */
  597              3 NUM CHAR(2) UNAL,     /* NUMBER WITHIN TYPE ('01') */
  598              3 ATTR BIT(18) UNAL,    /* ATTRS FROM PROFILE HEADER */
  599              3 DDEV BIT(9) UNAL,     /* FROM PROFILE HEADER.DDEV */
  600              3 IO,            /* FROM PROFILE HEADER.IO */
  601                4 INPUT BIT(1),
  602                4 OUTPUT BIT(1),
  603              3 TDEV BIT(1),        /* IF SET, IT IS SUBDEV FOR TERMINAL */
  604              3 IOM_CONNECTED BIT(1), /* This is an IOM connect device */
  605              3 RESOUCE_DEVICE BIT(1),   /* This is a resource device */
  606              3 * BIT(4),
  607              3 FNAME CHAR(6),   /* FNAME FROM DREC.OSINFO OR BLANKS */
  608              3 * CHAR(2),
  609              3 ACCT CHAR(8) UNAL,    /* LOGON ACCOUNT IF ANY */
  610              3 TERM CHAR(8) UNAL,   /* TERMINAL OR STATION NAME */
  611              3 PNAME,                /* DEFAULT PROFILE */
  612                4 CNT UBIN BYTE UNAL,
  613                4 TXT CHAR(11) UNAL;
  614      %MEND;
  615      /*F* NAME: KL_WSNHDR
  616
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         18   
  617      The KL_WSNHDR macro defines the header portion of the
  618      WSN record.
  619      */
  620
  621      %MACRO KL_WSNHDR (NAME=KL_WSNHDR,STCLASS=BASED);
  622      DCL 1 NAME STCLASS ALIGNED,
  623            2 INDIRECT#  BIT(1),        /* FLAG FOR INDIRECTNESS */
  624            2  *       BIT(17),        /*  UNUSED  */
  625            2 ACCSDISP UBIN HALF UNAL,   /* DISP TO KL_ACBLK 0 = NONE */
  626            2 TNAME CHAR(8),            /* TERM NAME WSN CREATED "FOR" */
  627            2 NTYP UBIN WORD,         /* NUMBER OF DEVICE TYPES PRESENT */
  628            2 TYPS (0:0),             /* DEVICE TYPE INFORMATION */
  629              3 TYP CHAR(2) UNAL,     /* DEVICE TYPE ('LP') */
  630              3 DISP UBIN(18) UNAL;   /* DISP INTO REC OF KL_WTBLK */
  631      %MEND;
  632
  633      /*F* NAME: KL_INDIRECT_WSN
  634
  635      The KL_INDIRECT_WSN macro defines the header portion of an
  636      INDIRECT WSN record.
  637      */
  638
  639      %MACRO KL_INDIRECT_WSN (NAME=KL_INDIRECT_WSN,STCLASS=BASED);
  640      DCL 1 NAME STCLASS ALIGNED,
  641            2 INDIRECT#  BIT(1),        /* FLAG FOR INDIRECTNESS */
  642            2  *       BIT(17),        /*  UNUSED  */
  643            2 ACCSDISP UBIN HALF UNAL,   /* DISP TO KL_ACBLK 0 = NONE */
  644            2 NODE CHAR(8),         /* NODE OF INDIRECT WSN */
  645            2 INDIRECT_WSN CHAR(8);   /* ACTUAL WSN NAME ON NODE */
  646      %MEND;
  647
  648
  649      /*F* NAME: KL_ACBLK
  650
  651      The KL_ACBLK macro defines the structure for the
  652      account access block in the WSN record.
  653      */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         19   
  654
  655
  656      %MACRO KL_ACBLK (NAME=KL_ACBLK,STCLASS=BASED);
  657      DCL 1 NAME STCLASS ALIGNED,
  658            2 ACCTS UBIN WORD,          /* NUMBER OF ACCOUNTS IN LIST */
  659            2 LIST (0:0) CHAR(8);       /* WILD CARDED ACCOUNTS */
  660      %MEND;
  661
  662
  663      /*F* NAME: KL_WTBLK
  664
  665      The KL_WTBLK macro defines the structure for the
  666      type blocks in WSN records.
  667      */
  668
  669      %MACRO KL_WTBLK (NAME=KL_WTBLK,STCLASS=BASED,
  670              TTNAME=' ',FFNAME=' ',DDDEV='0'B,IINPUT='0'B,OOUTPUT='0'B,
  671              NNATR=0,AATTRS="'0'B*0",PROFILE='TTY',RESOURCE(YES='1'B,NO='0'B)='0'B);
  672       %LSET LISTDIR='0'B;
  673       %LSET LISTEXP='1'B;
  674       %LSET LISTCOM='0'B;
  675       %LSET LISTSUB='1'B;
  676       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  677       %IF (SUBSTR(STR,0,6)='STATIC') OR
  678       (SUBSTR(STR,0,8)='CONSTANT') OR
  679       (SUBSTR(STR,0,3)='EXT');
  680       %LSET INIT=CHARTEXT('INIT');
  681       %ELSE;
  682       %LSET INIT=CHARTEXT('/*');
  683       %ENDIF;
  684      DCL 1 NAME STCLASS ALIGNED,
  685            2 TNAME CHAR(8)         /* FROM KL_WSNHDR.TNAME */
  686                 %INIT(TTNAME)%CHARTEXT('/**/'),
  687            2 FNAME CHAR(6)         /* FROM DFORM CMD OR ANY FROM TWSN REC */
  688                 %INIT(FFNAME)%CHARTEXT('/**/'),
  689            2 DDEV BIT(9)           /* FROM TWSN REC.DDEV (ANY) */
  690                 %INIT(DDDEV)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         20   
  691            2 IO,                    /* FROM TWSN REC.IO (ANY) */
  692              3 INPUT BIT(1) %INIT(IINPUT)%CHARTEXT('/**/'),
  693              3 OUTPUT BIT(1) %INIT(OOUTPUT)%CHARTEXT('/**/'),
  694            2 %CHARTEXT('RESOURCE') BIT(1) %INIT(RESOURCE)%CHARTEXT('/**/'),
  695            2 * BIT(6) %INIT('0'B)%CHARTEXT('/**/'),
  696            2 NATR UBIN WORD        /* NUMBER OF ENTRIES IN ATTRS */
  697                 %INIT(NNATR)%CHARTEXT('/**/'),
  698            2 ATTRS (0:15) BIT(18)   /* LIST OF UNIQUES FROM TWSN REC.ATTR */
  699                 %INIT(AATTRS)%CHARTEXT('/**/'),
  700            2 PNAME, /* PROFILE FOR TWSN RECORD */
  701              %SET PROCNT = CHARTEXT(BINCHAR(LENGTHC(PROFILE)));
  702              3 CNT UBIN BYTE UNAL %INIT(%PROCNT)%CHARTEXT('/**/'),
  703              3 TXT CHAR(11) UNAL %INIT(PROFILE)%CHARTEXT('/**/');
  704      %MEND;
  705
  706
  707      /*F* NAME: KL_KLPT_E   */
  708      /* STRUCTURES FOR KLTY_STRM PROFILE BLOCK */
  709
  710      /*K* KLPT_2780#
  711      .trf ]#
  712      KLPT_2780]          2780 terminal.
  713      .trf ]]
  714      */
  715      %EQU KLPT_2780#=1;   /* 2780 TERMINAL */
  716      /*K* KLPT_3780#
  717      .trf ]#
  718      KLPT_3780]          3780 terminal.
  719      .trf ]]
  720      */
  721      %EQU KLPT_3780#=2;   /* 3780 TERMINAL */
  722      /*K* KLPT_HASP#
  723      .trf ]#
  724      KLPT_HASP]          HASP (IRBT) terminal.
  725      .trf ]]
  726      */
  727      %EQU KLPT_HASP#=3;   /* HASP (IRBT) TERMINAL */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         21   
  728      /*K* KLPT_POLL#
  729      .trf ]#
  730      KLPT_POLL]          Polling protocol (3270-type terminal).
  731      .trf ]]
  732      */
  733      %EQU KLPT_POLL#=4;
  734      /*K* KLPT_3275#
  735      .trf ]#
  736      KLPT_3275]          3275 terminal.
  737      .trf ]]
  738      */
  739      %EQU KLPT_3275#=5;
  740      /*K* KLPT_HIP#
  741      .trf ]#
  742      KLPT_HIP]           Polled Vip terminal.
  743      .trf ]]
  744      */
  745      %EQU KLPT_HIP#=6;   /* Polled Vip Terminal */
  746      /*K* KLPT_NJE#
  747      .trf ]#
  748      KLPT_NJE]           NJE terminal.
  749      .trf ]]
  750      */
  751      %EQU KLPT_NJE#=7;
  752
  753      /*F* NAME: KLCO_E   */
  754      /*K* KLCO_NO#
  755      .trf ]#
  756      KLCO_NO]            COMPRESS = NO.
  757      .trf ]]
  758      */
  759      %EQU KLCO_NO#=0;              /* COMPRESS = NO */
  760      /*K* KLCO_YES#
  761      .trf ]#
  762      KLCO_YES]           COMPRESS = YES.
  763      .trf ]]
  764      */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         22   
  765      %EQU KLCO_YES#=1;            /* COMPRESS = YES */
  766      /*K* KLCO_LINE#
  767      .trf ]#
  768      KLCO_LINE]          COMPRESS = LINE.
  769      .trf ]]
  770      */
  771      %EQU KLCO_LINE#=2;          /* COMPRESS = LINE */
  772      /*K* KLCO_BLANKS#
  773      .trf ]#
  774      KLCO_BLANKS]        COMPRESS = BLANKS.
  775      .trf ]]
  776      */
  777      %EQU KLCO_BLANKS#=3;      /* COMPRESS = BLANKS */
  778
  779      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         23   
  780      /*F* NAME: KL_TRMD - Terminal Device Profile
  781
  782      The KL_TRMD macro defines the structure for the terminal device profile.
  783      This macro is passed to the handler via handler common BLDCTX
  784      calls.  See ADMIN_FPT.CTX$ description in FEP Library Services.
  785      */
  786      %MACRO KL_TRMD (NAME=KL_TRMD,STCLASS=STATIC,
  787                      PROTYP=%KLPT_HASP#,
  788                      BLKRECS=255,
  789                      BBB=656,
  790                      MULSTRM='1'B,
  791                      INTERVAL=10,
  792                      COMPRESS=%KLCO_LINE#,
  793                      RETRYS=15,
  794                      DELAYS=3,
  795                      EMCHR = 25,
  796                      IRSCHR = 30,
  797                      LSTRECCTN(YES='1'B,NO='0'B) = '0'B,
  798                      ERRDUPBLK(YES='1'B,NO='0'B) = '1'B,
  799                      RRR(YES='1'B,NO='0'B) = '1'B,
  800                      SLC(YES='1'B,NO='0'B) = '1'B,
  801                      SLCALLBLK(YES='1'B,NO='0'B) = '0'B,
  802                      PADSIGNON(YES='1'B,NO='0'B) = '1'B,
  803                      LVL=1,
  804                      LAST=";");
  805
  806       %LSET LISTDIR='0'B;
  807       %LSET LISTEXP='1'B;
  808       %LSET LISTCOM='0'B;
  809       %LSET LISTSUB='1'B;
  810       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  811       %IF (SUBSTR(STR,0,6)='STATIC') OR
  812       (SUBSTR(STR,0,8)='CONSTANT') OR
  813       (SUBSTR(STR,0,3)='EXT');
  814       %LSET INIT=CHARTEXT('INIT');
  815       %ELSE;
  816       %LSET INIT=CHARTEXT('/*');
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         24   
  817       %ENDIF;
  818
  819       %IF LVL=1;
  820      DCL 1 NAME STCLASS,
  821       %ELSE;
  822            %LVL NAME,
  823       %ENDIF;
  824              %(LVL+1) PROTYP# UBIN BYTE UNAL %INIT(PROTYP)%CHARTEXT('/**/'), /* PROTOCOL TYPE (KLPT_) */
  825      /*K* PROTYP# - UBIN BYTE.
  826           Specifies the protocol type to use with the terminal.
  827           EQUate identifiers for PROTYP# are listed in the following table.
  828           ..::TB "^\Identifier\#10\Meaning\#"
  829           .xeq KL_SUPER_C KL_KLPT_E KLPT_2780#
  830           .xeq KL_SUPER_C KL_KLPT_E KLPT_3275#
  831           .xeq KL_SUPER_C KL_KLPT_E KLPT_3780#
  832           .xeq KL_SUPER_C KL_KLPT_E KLPT_HASP#
  833           .xeq KL_SUPER_C KL_KLPT_E KLPT_POLL#
  834           .xeq KL_SUPER_C KL_KLPT_E KLPT_HIP#
  835           ..::TB
  836      */
  837              %(LVL+1) BLKRECS# UBIN BYTE UNAL %INIT(BLKRECS)%CHARTEXT('/**/'), /* MAX RECORDS PER BLOCK */
  838      /*K* BLKRECS# - UBIN BYTE.
  839           Specifies the maximum
  840           number of records per block that may be sent to the terminal.
  841      */
  842              %(LVL+1) BLKBYTES# UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(BBB)%CHARTEXT('/**/'), /* MAX BYTES PER BLOCK */
  843      /*K* BLKBYTES# - UBIN WORD.
  844           Specifies the maximum number of bytes per block that may be sent
  845           to the terminal.
  846      */
  847              %(LVL+1) RETRYS# UBIN BYTE UNAL %INIT(RETRYS)%CHARTEXT('/**/'), /* MAX RETRIES OF LINE ERROR */
  848      /*K* RETRYS# - UBIN BYTE.
  849           Specifies the maximum number of retries to attempt on a line error.
  850      */
  851              %(LVL+1) DELAYS# UBIN BYTE UNAL %INIT(DELAYS)%CHARTEXT('/**/'), /* DELAY PADS FOLLOWING MESSAGES */
  852      /*K* DELAYS# - UBIN BYTE.
  853           Specifies the number of delay pads preceding messages.  The
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         25   
  854           default is 3.
  855      */
  856      %IF NOT (MODE_FEP) ;
  857              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
  858      %ENDIF ;
  859              %(LVL+1) MULSTRM# BIT(2) UNAL %INIT(MULSTRM)%CHARTEXT('/**/'), /* YES -> LP,OC,ETC IN SAME BLOCK */
  860      /*K* MULSTRM# - BIT(2).
  861           If set to 1, indicates data for multiple devices.
  862      */
  863              %(LVL+1) * BIT(6) UNAL %INIT('010101'B)%CHARTEXT('/**/'),
  864      %IF   NOT (MODE_FEP) ;
  865              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
  866      %ENDIF ;
  867              %(LVL+1) * BIT(8) UNAL %INIT('01010101'B)%CHARTEXT('/**/'),
  868      /*K* INTERVAL# - UBIN BYTE.
  869           Specifies the time in 1/10 seconds between general polls of
  870           active controllers.
  871      */
  872              %(LVL+1) INTERVAL# UBIN BYTE UNAL %INIT(INTERVAL)%CHARTEXT('/**/'),
  873      %IF   NOT (MODE_FEP) ;
  874              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
  875      %ENDIF ;
  876              %(LVL+1) * BIT(2) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  877              %(LVL+1) COMPRESS# UBIN(6) UNAL %INIT(COMPRESS)%CHARTEXT('/**/'),
  878      /*K* COMPRESS# - UBIN(6).
  879           For HASP only, indicates repeating blanks will be compressed.
  880           EQUate identifiers for COMPRESS# are listed in the following table.
  881           ..::TB "^\Identifier\#10\Meaning\#"
  882           .xeq KL_SUPER_C KLCO_E KLCO_BLANKS#
  883           .xeq KL_SUPER_C KLCO_E KLCO_LINE#
  884           .xeq KL_SUPER_C KLCO_E KLCO_NO#
  885           .xeq KL_SUPER_C KLCO_E KLCO_YES#
  886          ..::TB
  887      */
  888              %(LVL+1) EMCHR# UBIN BYTE UNAL %INIT(EMCHR)%CHARTEXT('/**/'),
  889      /*K* EMCHR# - BYTE.
  890           For 2780 stations,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         26   
  891           defines the value of the EM (End of Media)
  892           character to be expected in incoming data, and to be used for
  893           outbound data.  The default is '19'X.
  894      */
  895              %(LVL+1) IRSCHR# UBIN BYTE UNAL %INIT(IRSCHR)%CHARTEXT('/**/'),
  896      /*K* IRSCHR# - BYTE.
  897           For 3780 stations,
  898           defines the value of the IRS (Interchange Record Separator)
  899           character to be expected in incoming data, and to be used for
  900           outbound data.  The default is '1E'X.
  901      */
  902      %IF   NOT (MODE_FEP) ;
  903              %(LVL+1) * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  904      %ENDIF ;
  905              %(LVL+1) LSTRECCTN# BIT(1) UNAL %INIT(LSTRECCTN)%CHARTEXT('/**/'),
  906      /*K* LSTRECCTN# - BIT(1).
  907           For 2780 and 3780 stations.
  908           If set to 1, this flag means that incoming blocks which end in
  909           "<record text> ETB", but not "<record text> IRS ETB", are to
  910           be considered as containing "broken records".  In this case
  911           the partial record from the block in question will be "cut"
  912           from its block and "pasted" onto the front of the first record
  913           of the next block from the input device.  The default is NO ('0'B).
  914      */
  915              %(LVL+1) ERRDUPBLK# BIT(1) UNAL %INIT(ERRDUPBLK)%CHARTEXT('/**/'),
  916      /*K* ERRDUPBLK# - BIT(1).
  917           For 2780, 3780 and HASP stations.  If set to 1,
  918           this flag means that duplicate blocks should be sent to output
  919           devices on the station if an error condition is thought to have
  920           occurred.  'NO' should only be specified if the RBT cannot accept
  921           duplicate blocks at all, since retransmission of blocks occurs
  922           quite often.  The default is YES ('1'B).
  923      */
  924              %(LVL+1) RRR# BIT(1) UNAL %INIT(RRR)%CHARTEXT('/**/'),
  925      /*K* RRR# - BIT(1).
  926           For 2780, 3780 and HASP stations.  If set to 1,
  927           this flag means that the CP-6 host should be notified of
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         27   
  928           the successful transmission of outbound data only after a
  929           positive acknowledgement has been received from the RBT
  930           concerning that data.  RRR being set will result in the CP-6 FEP
  931           waiting for an ACK or a block of incoming data from the RBT
  932           before sending a "successful completion" code to the CP-6
  933           host; this results in added data security.  RRR being reset
  934           will result in the CP-6 FEP sending a "successful completion"
  935           code to the CP-6 host immediately, without waiting for a positive
  936           acknowledgement from the RBT;  this results in enhanced data
  937           throughput speeds at the expense of some data security.  (For
  938           example, an irrecoverable line error near the end of a file's
  939           transmission may result in the RBT not receiving the entire file,
  940           and the CP-6 host also not requeueing the file for later
  941           transmission.)  The default is YES ('1'B).
  942      */
  943              %(LVL+1) SLC# BIT(1) UNAL %INIT(SLC)%CHARTEXT('/**/'),
  944      /*K* SLC# - BIT(1).
  945           For 2780 and 3780 stations.  If set to 1,
  946           this flag means that all blocks of incoming data for SLAVE
  947           stations will contain device selection bytes, and that the first
  948           block of outbound data for MASTER stations should select devices.
  949           The default is YES ('1'B).
  950      */
  951              %(LVL+1) SLCALLBLK# BIT(1) UNAL %INIT(SLCALLBLK)%CHARTEXT('/**/'),
  952      /*K* SLCALLBLK# - BIT(1).
  953           For 2780 and 3780 stations.  If set to 1,
  954           this flag, means that all blocks of outbound data for MASTER
  955           stations should select devices.  If this flag is reset, then SLC#
  956           is checked.  The default is YES ('1'B).
  957      */
  958              %(LVL+1) PADSIGNON# BIT(1) UNAL %INIT(PADSIGNON)%CHARTEXT('/**/'),
  959      /*K* PADSIGNON# - BIT(1).
  960           For 2780, 3780 and HASP stations operating in SLAVE mode.
  961           If set to 1, this flag means the SIGNON string sent to remote
  962           hosts is to be extended to 80 characters with blanks.  The
  963           default is YES ('1'B).
  964      */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         28   
  965              %(LVL+1) * BIT(2) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  966              %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/')LAST
  967      %MEND;
  968
  969
  970      /*F* NAME: KL_3270
  971
  972      The KL_3270 macro defines the structure for the 3270 profile block.
  973      */
  974      /* STRUCTURE FOR KLTY_3270 PROFILE BLOCK */
  975
  976
  977      %MACRO KL_3270( NAME=KL_3270, STCLASS=STATIC,
  978                      EWALT(YES='10'B,NO='00'B,DC='01'B)='01'B,
  979                      SIOPT(YES='1'B,NO='0'B)='0'B,
  980                      FORMFEED(YES='1'B,NO='0'B)='0'B,
  981                      DVCBFRSIZ_ = 0,
  982                      LVL=1, LAST=";" );
  983
  984       %LSET LISTDIR='0'B;
  985       %LSET LISTEXP='1'B;
  986       %LSET LISTCOM='0'B;
  987       %LSET LISTSUB='1'B;
  988       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  989       %IF (SUBSTR(STR,0,6)='STATIC') OR
  990       (SUBSTR(STR,0,8)='CONSTANT') OR
  991       (SUBSTR(STR,0,3)='EXT');
  992       %LSET INIT=CHARTEXT('INIT');
  993       %ELSE;
  994       %LSET INIT=CHARTEXT('/*');
  995       %ENDIF;
  996
  997       %IF LVL=1;
  998      DCL 1 NAME STCLASS,
  999       %ELSE;
 1000            %LVL NAME,
 1001       %ENDIF;
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         29   
 1002              %(LVL+1) * BIT(%(4-BITBIN(MODE_FEP))) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1003              %(LVL+1) FRMFED BIT(1) UNAL %INIT(FORMFEED)%CHARTEXT('/**/'),
 1004              %(LVL+1) EWALT# BIT(2) UNAL %INIT(EWALT)%CHARTEXT('/**/'),
 1005              %(LVL+1) SIOPT# BIT(2) UNAL %INIT(SIOPT)%CHARTEXT('/**/'),
 1006              %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1007              %(LVL+1) DVCBFRSIZ UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(DVCBFRSIZ_)%CHARTEXT('/**/')LAST    /* DEVICE BUFFER SIZE */
 1008      %MEND;
 1009
 1010
 1011      /*F* NAME: KL_ABSGRPRND
 1012
 1013      */
 1014
 1015      %MACRO KL_ABSGRPRND( NAME=KL_ABSGRPRND, STCLASS=STATIC,
 1016             ID(EMPHASIS=3,ERROR=6,HIDDEN=2,INPUT=4,NULL=1,OUTPUT=5,WARNING=7)=1,
 1017             HDN(YES='1'B,NO='0'B)='0'B,    INCINT(YES='1'B,NO='0'B)='0'B,
 1018             DCRINT(YES='1'B,NO='0'B)='0'B, UNDSCR(YES='1'B,NO='0'B)='0'B,
 1019             SLWBLN(YES='1'B,NO='0'B)='0'B, FSTBLN(YES='1'B,NO='0'B)='0'B,
 1020             RVRVID(YES='1'B,NO='0'B)='0'B, LVL=1, LAST=";" );
 1021
 1022       %LSET LISTDIR='0'B;
 1023       %LSET LISTEXP='1'B;
 1024       %LSET LISTCOM='0'B;
 1025       %LSET LISTSUB='1'B;
 1026       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1027       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1028       (SUBSTR(STR,0,8)='CONSTANT') OR
 1029       (SUBSTR(STR,0,3)='EXT');
 1030       %LSET INIT=CHARTEXT('INIT');
 1031       %ELSE;
 1032       %LSET INIT=CHARTEXT('/*');
 1033       %ENDIF;
 1034
 1035       %IF LVL=1;
 1036      DCL 1 NAME STCLASS,
 1037       %ELSE;
 1038            %LVL NAME,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         30   
 1039       %ENDIF;
 1040              %(LVL+1) * BIT(%(2-BITBIN(MODE_FEP))) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1041              %(LVL+1) ID# UBIN(7) UNAL %INIT(ID)%CHARTEXT('/**/'),
 1042              %(LVL+1) *   UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1043      %IF NOT (MODE_FEP) ;
 1044              %(LVL+1) * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1045      %ENDIF ;
 1046              %(LVL+1) FLAGS,
 1047              %(LVL+2) * BIT(1) UNAL %INIT('0'B )%CHARTEXT('/**/'),
 1048              %(LVL+2) HDN# BIT(1) UNAL %INIT(HDN )%CHARTEXT('/**/'),
 1049              %(LVL+2) INCINT# BIT(1) UNAL %INIT(INCINT)%CHARTEXT('/**/'),
 1050              %(LVL+2) DCRINT# BIT(1) UNAL %INIT(DCRINT)%CHARTEXT('/**/'),
 1051              %(LVL+2) UNDSCR# BIT(1) UNAL %INIT(UNDSCR)%CHARTEXT('/**/'),
 1052              %(LVL+2) SLWBLN# BIT(1) UNAL %INIT(SLWBLN)%CHARTEXT('/**/'),
 1053              %(LVL+2) FSTBLN# BIT(1) UNAL %INIT(FSTBLN)%CHARTEXT('/**/'),
 1054              %(LVL+2) RVRVID# BIT(1) UNAL %INIT(RVRVID)%CHARTEXT('/**/'),
 1055              %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/')LAST
 1056      %MEND;
 1057      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         31   
 1058
 1059      /* STRUCTURES FOR STORING WORDS INTO 1,8,1,8 FIELDS */
 1060
 1061      %MACRO KL$UWORD (NAME=KL$UWORD,STCLASS=BASED);
 1062      DCL 1 NAME STCLASS ALIGNED,
 1063            2 T UBIN(28) UNAL,  /* FOR TOP 8 BITS (E.G. KL_TRMD.BLKBYTES) */
 1064            2 B UBIN(8) UNAL;   /* BOTTOM 8 BITS */
 1065      %MEND;
 1066      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         32   
 1067
 1068      %MACRO KL$BWORD (NAME=KL$BWORD,STCLASS=BASED);
 1069      DCL 1 NAME STCLASS,
 1070            2 * UBIN(20) UNAL,  /* UNUSED PORTION */
 1071            2 T BIT(8) UNAL,    /* TOP 8 BITS (E.G. KL_DADR.DEVCTL) */
 1072            2 B BIT(8) UNAL;    /* BOTTOM 8 BITS */
 1073      %MEND;
 1074      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         33   
 1075
 1076      %MACRO KL$UBWORD (NAME=KL$UBWORD, STCLASS=BASED) ;
 1077      DCL 1 NAME STCLASS ALIGNED,
 1078            2 * UBIN(18) UNAL,        /* UNUSED PORTION */
 1079            2 NUM UBIN(18) UNAL,      /* ACTUAL VALUE WITH EXTRA BITS */
 1080            2 REPLACE REDEF NUM,      /* PART TO BE REPLACED*/
 1081              3 *  UBIN(1) UNAL,
 1082              3 T  UBIN(8) UNAL,      /* TOP 8 BITS */
 1083              3 *  UBIN(1) UNAL,
 1084              3 B  UBIN(8) UNAL;      /* BOTTOM 8 BITS */
 1085      %MEND ;
 1086      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         34   
 1087
 1088
 1089
 1090      /* STRUCTURES FOR KLTY_SDEV# DEVICE ADDRESS PROFILE BLOCK */
 1091
 1092      %EQU KLDN_HASPLP#='224'O;  /* DEVNUM FOR HASP LP ('94'H) */
 1093      %EQU KLDN_HASPCP#='225'O;  /* DEVNUM FOR HASP CP ('95'H) */
 1094      %EQU KLDN_HASPOC#='221'O; /* DEVNUM FOR HASP OC ('91'H) */
 1095      %EQU KLDN_HASPOCS#='222'O; /* SDNUM FOR HASP OC ('92'H) */
 1096      %EQU KLDN_HASPCR#='223'O;  /* DEVNUM FOR HASP CR ('93'H) */
 1097      %EQU KLDN_2780LP#='003'O;  /* DEVNUM FOR 2780 LP */
 1098      %EQU KLDN_2780CP#='004'O;  /* DEVNUM FOR 2780 CP */
 1099      %EQU KLDN_2780CR#='006'O;  /* DEVNUM FOR 2780 CR */
 1100      %EQU KLDN_3780LP#='021'O;  /* DEVNUM FOR 3780 LP */
 1101      %EQU KLDN_3780CP#='022'O;  /* DEVNUM FOR 3780 CP */
 1102      %EQU KLDN_3780CR#='000'O;  /* DEVNUM FOR 378 CR */
 1103      %EQU KLDN_HASPLP2#='244'O;  /* DEVNUM FOR HASP LP2 ('A4'H) */
 1104      %EQU KLDN_HASPLP3#='264'O;  /* DEVNUM FOR HASP LP3 ('B4'H) */
 1105      %EQU KLDN_IBMCR#='223'O;  /* DEVNUM FOR IBM CR ('93'H) */
 1106
 1107      %EQU KLDCT_HASPLP#='00001000'B; /* DEVCTL.T (8BITS) FOR HASP LP SUSBIT='800'H */
 1108      %EQU KLDCT_HASPLP2#='00000100'B; /* DEVCTL.T (8BITS) FOR HASP LP2 SUSBIT='400'H */
 1109      %EQU KLDCT_HASPLP3#='00000010'B; /* DEVCTL.T (8BITS) FOR HASP LP3 SUSBIT='200'H */
 1110      %EQU KLDCT_IBMCR#='00001000'B; /* DEVCTL.T (8BITS) FOR IBM CR SUSBIT='800'H */
 1111      %EQU KLDCB_HASPOC#='01000000'B; /* DEVCTL.B (8BITS) FOR HASP OC SUSBIT='40'H */
 1112      %EQU KLDCB_HASPCP#='00000001'B; /* DEVCTL.B (8BITS) FOR HASP CP SUSBIT=1 */
 1113      %EQU KLDCB_HASPCR#='00000001'B; /* DEVCTL.B (8BITS) FOR HASP CR SUSBIT=1 */
 1114
 1115
 1116
 1117
 1118      /*F* NAME: KL_DADR
 1119      */
 1120      %MACRO KL_DADR (NAME=KL_DADR,STCLASS=STATIC,DEVNUM=%KLDN_HASPLP#,
 1121                    SDNUM='000'O,DVCT=%KLDCT_HASPLP#,DVCB='0'B,
 1122                    LVL=1,LAST=";");
 1123
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         35   
 1124       %LSET LISTDIR='0'B;
 1125       %LSET LISTEXP='1'B;
 1126       %LSET LISTCOM='0'B;
 1127       %LSET LISTSUB='1'B;
 1128       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1129       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1130       (SUBSTR(STR,0,8)='CONSTANT') OR
 1131       (SUBSTR(STR,0,3)='EXT');
 1132       %LSET INIT=CHARTEXT('INIT');
 1133       %ELSE;
 1134       %LSET INIT=CHARTEXT('/*');
 1135       %ENDIF;
 1136
 1137       %IF LVL=1;
 1138      DCL 1 NAME STCLASS,
 1139       %ELSE;
 1140            %LVL NAME,
 1141       %ENDIF;
 1142      /*K* DEVNUM# - BIT(8).
 1143      Contains the device number of an RBTD device.
 1144      If the device is an IRBT, the value of DEVNUM is equivalent to the
 1145      HASP IRBT RCB4 (record control byte) for the device.
 1146      See the CP-6 System Support Reference (HA21), SUPER, TERMINAL Command
 1147      Options, DEVNUM for details.
 1148      */
 1149              %(LVL+1) DEVNUM# BIT(%(9-BITBIN(MODE_FEP))) UNAL %INIT(DEVNUM)%CHARTEXT('/**/'), /* DEVICE NUMBER (KLDN_) */
 1150      /*K* SDNUM# - BIT(8).
 1151      Contains the HASP record control byte for operator-console input if
 1152      DEVNUM specifies the value for output to an operator console.
 1153      See the CP-6 System Support Reference (HA21), SUPER, TERMINAL Command
 1154      Options, SDNUM for details.
 1155      */
 1156              %(LVL+1) SDNUM# BIT(%(9-BITBIN(MODE_FEP))) UNAL %INIT(SDNUM)%CHARTEXT('/**/'), /* SUB DEVICE NUMBER (KLDN_) */
 1157      %IF NOT (MODE_FEP) ;
 1158              %(LVL+1) DEVCTL, /* DEVICE CONTROL (SUSBIT) (AS 2 8OF9 BYTES) */
 1159              %(LVL+2) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1160      /*K* DEVCTL - BIT(16).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         36   
 1161      Contains the susbit value for a HASP device.  See the CP-6 System
 1162      Support Reference (HA21), SUPER, TERMINAL Command Options, DEVCTL,
 1163      for details.
 1164      */
 1165              %(LVL+2) T BIT(8) UNAL %INIT(DVCT)%CHARTEXT('/**/'), /* TOP 8 BITS (USE KL$BWORD) */
 1166              %(LVL+2) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1167              %(LVL+2) B BIT(8) UNAL %INIT(DVCB)%CHARTEXT('/**/')LAST /* BOTTOM 8 BITS */
 1168      %ELSE ;
 1169              %(LVL+1) DEVCTL BIT(16) UNAL %INIT('0'B*0)%CHARTEXT('/**/') LAST
 1170      %ENDIF ;
 1171      %MEND;
 1172
 1173
 1174      /*F* NAME: KL_CCHR
 1175
 1176      */
 1177      /* STRUCTURES FOR CONTROL CHARACTER BLOCK OF KLTY_TTY PROFILE */
 1178
 1179      %MACRO KL_CCHR (NAME=KL_CCHR,STCLASS=STATIC,LVL=1,LAST=";",
 1180                      SGR_ALG(NONE=0,ANS=1,TWO=2,THREE=3)=0,
 1181                      DAQ_ALG(NONE=0,ANS=1,TWO=2,THREE=3)=0,
 1182                      SGRINCDAQ(YES='1'B,NO='0'B)='0'B,
 1183                      DFLTPRTMODE(PROTECTED='1'B,UNPROTECTED='0'B)='1'B,
 1184                      DCLFLD_ALG(NONE=0,ANS=1,TWO=2,THREE=3)=0,
 1185                      SGRHDN_CHR=0, SGRINCINT_CHR=0,
 1186                      SGRDCRINT_CHR=0, SGRUNDSCR_CHR=0,
 1187                      SGRSLWBLN_CHR=0, SGRFSTBLN_CHR=0,
 1188                      SGRRVRVID_CHR=0, SGRPRT_CHR=0,
 1189                      SGRINP_CHR=0, SGRPRTGRD_CHR=0,
 1190                      DAQPRT_CHR=0, DAQINP_CHR=0,
 1191                      DAQPRTGRD_CHR=0);
 1192
 1193       %LSET LISTDIR='0'B;
 1194       %LSET LISTEXP='1'B;
 1195       %LSET LISTCOM='0'B;
 1196       %LSET LISTSUB='1'B;
 1197       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         37   
 1198       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1199       (SUBSTR(STR,0,8)='CONSTANT') OR
 1200       (SUBSTR(STR,0,3)='EXT');
 1201       %LSET INIT=CHARTEXT('INIT');
 1202       %ELSE;
 1203       %LSET INIT=CHARTEXT('/*');
 1204       %ENDIF;
 1205
 1206       %IF LVL=1;
 1207      DCL 1 NAME STCLASS,
 1208       %ELSE;
 1209            %LVL NAME,
 1210       %ENDIF;
 1211      /* FIRST IS THE TIMING ALGORYTHM BLOCK OF KLTY_TTY PROFILE */
 1212      /* ALL ALGORYTHM NUMBERS ARE NUMBERS */
 1213      /* ALL TIMES ARE IN 100 MICSECS UNITS AS 2 8OF9 BYTES - USE KL$UWORD */
 1214              %(LVL+1) TMNALG_AFTCR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* TIMING ALGORYTHM NUMBER AFTER CR */
 1215              %(LVL+1) TMNALG_BFRCR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* BEFORE CR */
 1216              %(LVL+1) TMNALG_AFTLF UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* AFTER LF */
 1217              %(LVL+1) TMNALG_BFRLF UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* BEFORE LF */
 1218              %(LVL+1) TMNALG_AFTHT UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* AFTER TAB */
 1219              %(LVL+1) TMNALG_AFTCUP UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),/* AFTER CURSOR POSITION */
 1220              %(LVL+1) TMNALG_AFTHPA UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* AFTER HORIZONTAL POSITION ABSOLUTE */
 1221              %(LVL+1) TMNALG_FILCHR UBIN BYTE UNAL %INIT(127)%CHARTEXT('/**/'),
 1222                                /* TIME DELAY AFTER CONTROL FUNCTION IN 100 MICSECS */
 1223              %(LVL+1) CTRFNCTIM UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1224                               /* TIME DELAY AFTER BACKSPACE (USE KL$UWORD) */
 1225              %(LVL+1) BS_TIM UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1226                               /* AFTER SCREEN ERASE ( AS 2 8OF9 BYTES ) */
 1227              %(LVL+1) ERSTIM UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1228                                  /* TIMING ALGORYTHM PARAMETER 1 (AS 2 8OF9 BYTES) */
 1229              %(LVL+1) TMNALG_PRM1 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1230                                  /* TIMING ALGORYTHM PARAMETER 2 (AS 2 8OF9 BYTES) */
 1231              %(LVL+1) TMNALG_PRM2 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1232                                  /* TIMING ALGORYTHM PARAMETER 3 (AS 2 8OF9 BYTES) */
 1233              %(LVL+1) TMNALG_PRM3 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1234                                  /* TIMING ALGORYTHM PARAMETER 4 (AS 2 8OF9 BYTES) */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         38   
 1235              %(LVL+1) TMNALG_PRM4 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1236                                  /* TIMING ALGORYTHM PARAMETER 5 (AS 2 8OF9 BYTES) */
 1237              %(LVL+1) TMNALG_PRM5 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1238                                  /* TIMING ALGORYTHM PARAMETER 6 (AS 2 8OF9 BYTES) */
 1239              %(LVL+1) TMNALG_PRM6 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1240                                  /* TIMING ALGORYTHM PARAMETER 7 (AS 2 8OF9 BYTES) */
 1241              %(LVL+1) TMNALG_PRM7 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1242                                  /* TIMING ALGORYTHM PARAMETER 8 (AS 2 8OF9 BYTES) */
 1243              %(LVL+1) TMNALG_PRM8 UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1244                                     /* DEVICE BUFFER SIZE (2 8OF9 BYTES - USE KL$UWORD) */
 1245              %(LVL+1) DVCOTPBFRSIZ UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/'),
 1246              %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1247              %(LVL+1) HPA_ALG UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* HORIZONTAL POSITION ABSOLUTE ALG NUMBER */
 1248              %(LVL+1) CUP_ALG UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* CURSOR POSITIONING ALG */
 1249              %(LVL+1) CUP_BIS UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* BIAS TO ADD TO LINE AND COLUMN */
 1250      %IF NOT (MODE_FEP) ;
 1251              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1252      %ENDIF ;
 1253              %(LVL+1) CUP_CLMFRS BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* COLUMN IS SEND FIRST */
 1254              %(LVL+1) CUP_CMP BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* COMPLEMENT ROW AND COLUMN */
 1255              %(LVL+1) ICHRQRDCH# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1256              %(LVL+1) ILNRQRDLN# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1257              %(LVL+1) SGRINCDAQ# BIT(1) %INIT(SGRINCDAQ)%CHARTEXT('/**/'),
 1258              %(LVL+1) DFLTPRTMODE# BIT(1) %INIT(DFLTPRTMODE)%CHARTEXT('/**/'),
 1259              %(LVL+1) FRSCLMFLD# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1260              %(LVL+1) SPCDLTFLD# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1261              %(LVL+1) * BIT(%(5-BITBIN(MODE_FEP))) %INIT('0'B)%CHARTEXT('/**/'),
 1262              %(LVL+1) RGNSCROLL# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1263              %(LVL+1) EL0DLTFLD# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1264              %(LVL+1) ED0DLTFLD# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1265              %(LVL+1) ED2DLTFLD# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1266              %(LVL+1) SGR_ALG# UBIN BYTE UNAL %INIT(SGR_ALG)%CHARTEXT('/**/'),
 1267              %(LVL+1) DAQ_ALG# UBIN BYTE UNAL %INIT(DAQ_ALG)%CHARTEXT('/**/'),
 1268              %(LVL+1) DCLFLD_ALG# UBIN BYTE UNAL %INIT(DCLFLD_ALG)%CHARTEXT('/**/'),
 1269              %(LVL+1) SGRHDN_CHR# UBIN BYTE UNAL %INIT(SGRHDN_CHR)%CHARTEXT('/**/'),
 1270              %(LVL+1) SGRINCINT_CHR# UBIN BYTE UNAL %INIT(SGRINCINT_CHR)%CHARTEXT('/**/'),
 1271              %(LVL+1) SGRDCRINT_CHR# UBIN BYTE UNAL %INIT(SGRDCRINT_CHR)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         39   
 1272              %(LVL+1) SGRUNDSCR_CHR# UBIN BYTE UNAL %INIT(SGRUNDSCR_CHR)%CHARTEXT('/**/'),
 1273              %(LVL+1) SGRSLWBLN_CHR# UBIN BYTE UNAL %INIT(SGRSLWBLN_CHR)%CHARTEXT('/**/'),
 1274              %(LVL+1) SGRFSTBLN_CHR# UBIN BYTE UNAL %INIT(SGRFSTBLN_CHR)%CHARTEXT('/**/'),
 1275              %(LVL+1) SGRRVRVID_CHR# UBIN BYTE UNAL %INIT(SGRRVRVID_CHR)%CHARTEXT('/**/'),
 1276              %(LVL+1) SGRPRT_CHR# UBIN BYTE UNAL %INIT(SGRPRT_CHR)%CHARTEXT('/**/'),
 1277              %(LVL+1) SGRINP_CHR# UBIN BYTE UNAL %INIT(SGRINP_CHR)%CHARTEXT('/**/'),
 1278              %(LVL+1) SGRPRTGRD_CHR# UBIN BYTE UNAL %INIT(SGRPRTGRD_CHR)%CHARTEXT('/**/'),
 1279              %(LVL+1) DAQPRT_CHR# UBIN BYTE UNAL %INIT(DAQPRT_CHR)%CHARTEXT('/**/'),
 1280              %(LVL+1) DAQINP_CHR# UBIN BYTE UNAL %INIT(DAQINP_CHR)%CHARTEXT('/**/'),
 1281              %(LVL+1) DAQPRTGRD_CHR# UBIN BYTE UNAL %INIT(DAQPRTGRD_CHR)%CHARTEXT('/**/'),
 1282      /* THE REMAINDER OT THE STRUCTURE CONSISTS OF ONE BYTE PER ITEM, */
 1283      /* FOLLOWWED BY A TEXT BUFFER. */
 1284      /* THE BYTE CONTAINS THE INDEX INTO THE TEXT BUFFER OF THE COUNT BYTE */
 1285      /* OF A TEXTC STRING, WHICH REPRESENTS THE INDICATED CONTROL STRING. */
 1286      /* AN INDEX OF ZERO IMPLIES THAT THE FUNCTION DOESN'T EXIST. */
 1287      /* THE TEXT BUFFER SHOULD BE KEPT PACKED TOGETHER, THUS MAINTAINING */
 1288      /* A TOTAL AVAILABILITY IF 255 CHARACTERS OF CONTROL STRINGS, INCLUDING */
 1289      /* COUNT BYTES. */
 1290              %(LVL+1) CCHR_ARY(0:0) UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* DEFINED AS ARRAY FOR CONVENIENCE */
 1291              %(LVL+1) ICH_CHR REDEF CCHR_ARY UBIN BYTE UNAL,
 1292              %(LVL+1) DCH_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* DELETE CHARACTER FIXED SEQUENCE */
 1293              %(LVL+1) RSTINSMOD_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* RESET INSERT MODE */
 1294              %(LVL+1) CUP_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* POSITION CURSOR */
 1295              %(LVL+1) ED0_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* ERASE DISPLAY */
 1296              %(LVL+1) EL0_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* ERASE LINE */
 1297              %(LVL+1) CUB_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* CURSOR BACK */
 1298              %(LVL+1) CUF_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* CURSOR FORWARD */
 1299              %(LVL+1) CUU_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* CURSOR UP */
 1300              %(LVL+1) CUD_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* CURSOR DOWN */
 1301              %(LVL+1) ED2_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* ERASE SCREEN */
 1302              %(LVL+1) HOM_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* HOM_CHRE CURSOR */
 1303              %(LVL+1) HTS_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* SET DEVICE TAB */
 1304              %(LVL+1) TBC3_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* CLEAR DEVICE TABS */
 1305              %(LVL+1) SETFRMLNG_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* SET PAGE LENGTH */
 1306              %(LVL+1) FRMFED_CHR UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'), /* SKIP TO TOP-OF-FORM */
 1307              %(LVL+1) SGRINTRO_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1308              %(LVL+1) DAQINTRO_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         40   
 1309              %(LVL+1) DCLFRM_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1310              %(LVL+1) ENDDCLFRM_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1311              %(LVL+1) RESTORE_DFLTSCRN_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1312              %(LVL+1) DLTALLFLDS_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1313              %(LVL+1) INSLIN_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1314              %(LVL+1) DLTLIN_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1315              %(LVL+1) ERASEFLD_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1316              %(LVL+1) MSGLIN_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1317              %(LVL+1) ENDMSGLIN_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1318              %(LVL+1) DLTFLD_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1319              %(LVL+1) EXTSRD_CHR# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1320              %(LVL+1) TXT_CHR REDEF EXTSRD_CHR# CHAR(1),
 1321              %(LVL+1) TXT_CHRA(0:0) REDEF EXTSRD_CHR# CHAR(1),
 1322              %(LVL+1) TXT_UBIN(0:0) REDEF EXTSRD_CHR# UBIN BYTE UNAL LAST
 1323      /* THE TEXT BUFFER ID DEFINED IN SEVERAL WAYS TO EASE ITS USE */
 1324      /* NOTE THAT THE FIRST CHARACTER OF IT REDEFS THE LAST OF THE INDEX BYTES */
 1325      /* NOTE ALSO THAT THE ENTIRE CCHR STRUCTURE IS "VARIABLE" IN LENGTH */
 1326      /* AS SUCH, IT SHOULD BE LAST IN THE PROFILE PORTIONS */
 1327      /* ALSO NOTE THAT IT MAY WELL BE LARGER THAN 255 BYTES - A NORMALLY INVALID */
 1328      /* CIRCUMSTANCE. HOWEVER, BEING LAST, ITS SIZE CAN BE DETERMINED BY OTHER MEANS */
 1329      /* IN THE CASE WHERE IT IS >255, ITS T-L BYTES SHOULD CONTAIN:
 1330         KV_PRMID_BIGTL, KV_PRMID_CTRCHR, LENGTH/256, AND MOD(LENGTH,256)
 1331               INSTEAD OF:
 1332         KV_PRMID_CTRCHR, LENGTH. */
 1333      %MEND;
 1334      %EJECT;

14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         41   
 1335
 1336      /*  Equates for X25 and Circuit definitions  */
 1337
 1338      /*       Equates for the X25 CALLS parameter  */
 1339
 1340      /*F* NAME:  KLX25_CLS_E  */
 1341      /*K* KLX25_CLS_NONE#
 1342      .trf ]#
 1343      KLX25_CLS_NONE]     None.
 1344      .trf ]]
 1345      */
 1346      %EQU KLX25_CLS_NONE# = 0;
 1347      /*K* KLX25_CLS_X25#
 1348      .trf ]#
 1349      KLX25_CLS_X25]      X25.
 1350      .trf ]]
 1351      */
 1352      %EQU KLX25_CLS_X25#  = 1;
 1353      /*K* KLX25_CLS_X29#
 1354      .trf ]#
 1355      KLX25_CLS_X29]      X29.
 1356      .trf ]]
 1357      */
 1358      %EQU KLX25_CLS_X29#  = 2;
 1359      /*K* KLX25_CLS_ALL#
 1360      .trf ]#
 1361      KLX25_CLS_ALL]      All.
 1362      .trf ]]
 1363      */
 1364      %EQU KLX25_CLS_ALL#  = 3;
 1365
 1366      /*F* NAME: KLX25_SIZ_E
 1367               Equates for the X25 and Circuit SIZE parameters  */
 1368
 1369      /*K* KLX25_SIZ_128#
 1370      .trf ]#
 1371      KLX25_SIZ_128]      128 bytes.
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         42   
 1372      .trf ]]
 1373      */
 1374      %EQU KLX25_SIZ_128#  = 0;
 1375      /*K* KLX25_SIZ_256#
 1376      .trf ]#
 1377      KLX25_SIZ_256]      256 bytes.
 1378      .trf ]]
 1379      */
 1380      %EQU KLX25_SIZ_256#  = 1;
 1381      /*K* KLX25_SIZ_512#
 1382      .trf ]#
 1383      KLX25_SIZ_512]      512 bytes.
 1384      .trf ]]
 1385      */
 1386      %EQU KLX25_SIZ_512#  = 2;
 1387      /*K* KLX25_SIZ_1024#
 1388      .trf ]#
 1389      KLX25_SIZ_1024]     1024 bytes.
 1390      .trf ]]
 1391      */
 1392      %EQU KLX25_SIZ_1024# = 3;
 1393      /*K* KLX25_SIZ_2048#
 1394      .trf ]#
 1395      KLX25_SIZ_2048]     2048 bytes.
 1396      .trf ]]
 1397      */
 1398      %EQU KLX25_SIZ_2048# = 4;
 1399      /*K* KLX25_SIZ_4096#
 1400      .trf ]#
 1401      KLX25_SIZ_4096]     4096 bytes.
 1402      .trf ]]
 1403      */
 1404      %EQU KLX25_SIZ_4096# = 5;
 1405
 1406      /*F* NAME: KLX25_MOD_E
 1407               Equates for the X25 MODE parameter  */
 1408
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         43   
 1409      /*K* KLX25_MOD_DTE#
 1410      .trf ]#
 1411      KLX25_MOD_DTE]      Data terminal equipment.
 1412      .trf ]]
 1413      */
 1414      %EQU KLX25_MOD_DTE# = 0;
 1415      /*K* KLX25_MOD_DCE#
 1416      .trf ]#
 1417      KLX25_MOD_DCE]      Data circuit terminating equipment.
 1418      .trf ]]
 1419      */
 1420      %EQU KLX25_MOD_DCE# = 1;
 1421
 1422      /*F* NAME: KLX25_THR_E
 1423               Equates for the Circuit THROUGHPUT parameters  */
 1424
 1425      /*K* KLX25_THR_NONE#
 1426      .trf ]#
 1427      KLX25_THR_NONE]     None.
 1428      .trf ]]
 1429      */
 1430      %EQU KLX25_THR_NONE#  = 0;
 1431      /*K* KLX25_THR_75#
 1432      .trf ]#
 1433      KLX25_THR_75]       75 bits per second.
 1434      .trf ]]
 1435      */
 1436      %EQU KLX25_THR_75#    = 1;
 1437      /*K* KLX25_THR_150#
 1438      .trf ]#
 1439      KLX25_THR_150]      150 bits per second.
 1440      .trf ]]
 1441      */
 1442      %EQU KLX25_THR_150#   = 2;
 1443      /*K* KLX25_THR_300#
 1444      .trf ]#
 1445      KLX25_THR_300]      300 bits per second.
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         44   
 1446      .trf ]]
 1447      */
 1448      %EQU KLX25_THR_300#   = 3;
 1449      /*K* KLX25_THR_600#
 1450      .trf ]#
 1451      KLX25_THR_600]      600 bits per second.
 1452      .trf ]]
 1453      */
 1454      %EQU KLX25_THR_600#   = 4;
 1455      /*K* KLX25_THR_1200#
 1456      .trf ]#
 1457      KLX25_THR_1200]     1200 bits per second.
 1458      .trf ]]
 1459      */
 1460      %EQU KLX25_THR_1200#  = 5;
 1461      /*K* KLX25_THR_2400#
 1462      .trf ]#
 1463      KLX25_THR_2400]     2400 bits per second.
 1464      .trf ]]
 1465      */
 1466      %EQU KLX25_THR_2400#  = 6;
 1467      /*K* KLX25_THR_4800#
 1468      .trf ]#
 1469      KLX25_THR_4800]     4800 bits per second.
 1470      .trf ]]
 1471      */
 1472      %EQU KLX25_THR_4800#  = 7;
 1473      /*K* KLX25_THR_9600#
 1474      .trf ]#
 1475      KLX25_THR_9600]     9600 bits per second.
 1476      .trf ]]
 1477      */
 1478      %EQU KLX25_THR_9600#  = 8;
 1479      /*K* KLX25_THR_19200#
 1480      .trf ]#
 1481      KLX25_THR_19200]    19200 bits per second.
 1482      .trf ]]
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         45   
 1483      */
 1484      %EQU KLX25_THR_19200# = 9;
 1485      /*K* KLX25_THR_48000#
 1486      .trf ]#
 1487      KLX25_THR_48000]    48000 bits per second.
 1488      .trf ]]
 1489      */
 1490      %EQU KLX25_THR_48000# = 10;
 1491
 1492      /*F* NAME: KLX25_TYP_E
 1493                Equates for the circuit TYPE parameters    */
 1494
 1495      /*K* KLX25_TYP_PRM#
 1496      .trf ]#
 1497      KLX25_TYP_PRM]      Primary.
 1498      .trf ]]
 1499      */
 1500      %EQU KLX25_TYP_PRM# = 0;
 1501      /*K* KLX25_TYP_SEC#
 1502      .trf ]#
 1503      KLX25_TYP_SEC]      Secondary.
 1504      .trf ]]
 1505      */
 1506      %EQU KLX25_TYP_SEC# = 1;
 1507      %EQU KLX25_TYP_BCK# = 2;
 1508
 1509      /*F* NAME: KLX25_RVR_E
 1510                Equates for the circuit REVERSE parameters  */
 1511
 1512      /*K* KLX25_RVR_TRY#
 1513      .trf ]#
 1514      KLX25_RVR_TRY]      If reverse charging is rejected, retry call with
 1515                          no reverse charging.
 1516      .trf ]]
 1517      */
 1518      %EQU KLX25_RVR_TRY# = 0;
 1519      /*K* KLX25_RVR_YES#
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         46   
 1520      .trf ]#
 1521      KLX25_RVR_YES]      Yes.
 1522      .trf ]]
 1523      */
 1524      %EQU KLX25_RVR_YES# = 1;
 1525      /*K* KLX25_RVR_NO#
 1526      .trf ]#
 1527      KLX25_RVR_NO]       No.
 1528      .trf ]]
 1529      */
 1530      %EQU KLX25_RVR_NO# = 2;
 1531
 1532
 1533      /*F* NAME: KL_LINK - LINK Profile
 1534
 1535      The KL_LINK macro contains the structure for the KLTY_LINK# profile block.
 1536      */
 1537
 1538      %MACRO KL_LINK ( NAME = KL_LINK, STCLASS = STATIC, ALGN = CALIGNED,
 1539                CALLS = %KLX25_CLS_ALL#,
 1540                CHARGE_INFO ( YES = '1'B, NO = '0'B ) = '0'B,
 1541                EXTEND_SEQ ( YES = '1'B, NO = '0'B ) = '0'B,
 1542                FAST_SELECT_ACCEPT ( YES = '1'B, NO = '0'B ) = '1'B,
 1543                FRAME_SIZE = %KLX25_SIZ_1024#,
 1544                IDLE_TIMEOUT = 4,
 1545                MAXIMUM_WINDOW = 7,
 1546                RESPONSE_DELAY = 4,
 1547                RESTART_RETRYS = 1,
 1548                RESTART_TIMEOUT = 20,
 1549                RETRANSMISSIONS = 20,
 1550                REVERSE ( YES = '1'B, NO = '0'B ) = '1'B,
 1551                TIMEOUT = 3,
 1552                WINDOW = 7,
 1553                      LVL=1, LAST=";" );
 1554
 1555       %LSET LISTDIR='0'B;
 1556       %LSET LISTEXP='1'B;
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         47   
 1557       %LSET LISTCOM='0'B;
 1558       %LSET LISTSUB='1'B;
 1559       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1560       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1561       (SUBSTR(STR,0,8)='CONSTANT') OR
 1562       (SUBSTR(STR,0,3)='EXT');
 1563       %LSET INIT=CHARTEXT('INIT');
 1564       %ELSE;
 1565       %LSET INIT=CHARTEXT('/*');
 1566       %ENDIF;
 1567
 1568       %IF LVL=1;
 1569      DCL 1 NAME STCLASS ALGN,
 1570       %ELSE;
 1571            %LVL NAME ALGN,
 1572       %ENDIF;
 1573      %IF NOT( MODE_FEP ) ;
 1574              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1575      %ENDIF ;
 1576              %(LVL+1) CLS# UBIN(2) UNAL %INIT(CALLS)%CHARTEXT('/**/'),
 1577      /*K* CLS# - UBIN(2).
 1578           Specifies the class of service.  EQUate identifiers for CLS# are
 1579           listed in the following table.
 1580           ..::TB "^\Identifier\#10\Meaning\#"
 1581           .xeq KL_SUPER_C KLX25_CLS_E KLX25_CLS_ALL#
 1582           .xeq KL_SUPER_C KLX25_CLS_E KLX25_CLS_NONE#
 1583           .xeq KL_SUPER_C KLX25_CLS_E KLX25_CLS_X25#
 1584           .xeq KL_SUPER_C KLX25_CLS_E KLX25_CLS_X29#
 1585          ..::TB
 1586      */
 1587              %(LVL+1) FRMSIZ# UBIN(4) UNAL %INIT(FRAME_SIZE)%CHARTEXT('/**/'),
 1588      /*K* FRMSIZ# - UBIN(4).
 1589           Specifies the maximum number of bytes a frame can contain.
 1590           EQUate identifiers for FRMSIZ# are listed in the following table.
 1591           ..::TB "^\Identifier\#10\Meaning\#"
 1592           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_128#
 1593           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_256#
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         48   
 1594           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_512#
 1595           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_1024#
 1596           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_2048#
 1597           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_4096#
 1598          ..::TB
 1599      */
 1600              %(LVL+1) RVR# BIT(1) UNAL %INIT(REVERSE)%CHARTEXT('/**/'),
 1601      /*K* RVR# - BIT(1).
 1602           Specifies whether or not to accept incoming calls.
 1603      */
 1604              %(LVL+1) FSA# BIT(1) UNAL %INIT(FAST_SELECT_ACCEPT)%CHARTEXT('/**/'),
 1605      /*K* FSA# - BIT(1).
 1606           Specifies whether or not to accept outgoing calls.
 1607      */
 1608      %IF   NOT( MODE_FEP ) ;
 1609              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1610      %ENDIF ;
 1611              %(LVL+1) CHARGE# BIT(1) UNAL %INIT(CHARGE_INFO)%CHARTEXT('/**/'),
 1612      /*K* CHARGE# - BIT(1).
 1613           Specifies whether or not to request charging information
 1614           for incoming calls.
 1615      */
 1616              %(LVL+1) RSPDLY# UBIN(7) UNAL %INIT(RESPONSE_DELAY)%CHARTEXT('/**/'),
 1617      /*K* RSPDLY# - UBIN(7).
 1618           Specifies the number (0-127) of unacknowledged information frames
 1619           received before an acknowledgement frame is generated.
 1620      */
 1621      %IF   NOT( MODE_FEP ) ;
 1622              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1623      %ENDIF ;
 1624              %(LVL+1) EXTSEQ# BIT(1) UNAL %INIT(EXTEND_SEQ)%CHARTEXT('/**/'),
 1625      /*K* EXTSEQ# - BIT(1).
 1626           Specifies whether or not to allow frame window sizes to 127.
 1627      */
 1628              %(LVL+1) MAXWND# UBIN(7) UNAL %INIT(MAXIMUM_WINDOW)%CHARTEXT('/**/'),
 1629      /*K* MAXWND# - UBIN(7).
 1630           Specifies the size of the maximum send window (2-127) on incoming
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         49   
 1631           calls for circuits on this link.
 1632      */
 1633              %(LVL+1) RTR# UBIN BYTE UNAL %INIT(RETRANSMISSIONS)%CHARTEXT('/**/'),
 1634      /*K* RTR# - UBIN BYTE.
 1635           Specifies the number of retransmissions.
 1636      */
 1637              %(LVL+1) TMT# UBIN BYTE UNAL %INIT(TIMEOUT)%CHARTEXT('/**/'),
 1638      /*K* TMT# - UBIN BYTE.
 1639           Specifies the time interval in seconds that should expire before
 1640           taking corrective action.
 1641      */
 1642              %(LVL+1) WND# UBIN BYTE UNAL %INIT(WINDOW)%CHARTEXT('/**/'),
 1643      /*K* WND# - UBIN BYTE.
 1644           Specifies the frame transmission window size (1-127).
 1645      */
 1646              %(LVL+1) RESTIM# UBIN BYTE UNAL %INIT(RESTART_TIMEOUT)%CHARTEXT('/**/'),
 1647              %(LVL+1) RESRTY# UBIN BYTE UNAL %INIT(RESTART_RETRYS)%CHARTEXT('/**/'),
 1648              %(LVL+1) IDLTIM# UBIN BYTE UNAL %INIT(IDLE_TIMEOUT)%CHARTEXT('/**/'),
 1649              %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/') LAST
 1650      %MEND;
 1651
 1652
 1653      /*F* NAME: KL_VIRCIR - Virtual Circuit Profile
 1654
 1655      The KL_VIRCIR macro contains the structure for the
 1656      virtual circuit profile block.
 1657        This structure is passed to the handler via handler common
 1658        BLDCTX calls.  See ADMIN_FPT.CTX$ in FEP Library Services.
 1659      */
 1660
 1661      %MACRO KL_VIRCIR ( NAME = KL_VIRCIR, STCLASS = BASED, ALGN = CALIGNED,
 1662                CALL_DELAY = 60,
 1663                CALL_RETRIES = 3,
 1664                CALL_TIMEOUT = 200,
 1665                CHARGE_INFO ( YES = '1'B, NO = '0'B ) = '0'B,
 1666                CLEAR_RETRIES = 3,
 1667                CLEAR_TIMEOUT = 20,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         50   
 1668                DATA_RETRIES = 1,
 1669                DATA_TIMEOUT = 0,
 1670                EXTEND_SEQ ( YES = '1'B, NO = '0'B ) = '0'B,
 1671                IDLE_TIMEOUT = 0,
 1672                INTERRUPT_TIMEOUT = 20,
 1673                RECEIVE_SIZE = %KLX25_SIZ_1024#,
 1674                RECEIVE_THROUGHPUT = %KLX25_THR_NONE#,
 1675                RECEIVE_WINDOW = 7,
 1676                RESET_RETRIES = 1,
 1677                RESET_TIMEOUT = 20,
 1678                RESP_TIMER = 1,
 1679                RESPOND_TO_COMPLETE ( YES = '1'B, NO = '0'B ) = '1'B,
 1680                RESPONSE_DELAY = 1,
 1681                REVERSE = %KLX25_RVR_NO#,
 1682                SEND_SIZE = %KLX25_SIZ_1024#,
 1683                SEND_THROUGHPUT = %KLX25_THR_NONE#,
 1684                SEND_WINDOW = 7,
 1685                TRANSIT_DELAY_B = 0,
 1686                TRANSIT_DELAY_T = 0,
 1687                   LVL = 1, LAST = ";" );
 1688
 1689
 1690       %LSET LISTDIR='0'B;
 1691       %LSET LISTEXP='1'B;
 1692       %LSET LISTCOM='0'B;
 1693       %LSET LISTSUB='1'B;
 1694       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1695       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1696       (SUBSTR(STR,0,8)='CONSTANT') OR
 1697       (SUBSTR(STR,0,3)='EXT');
 1698       %LSET INIT=CHARTEXT('INIT');
 1699       %ELSE;
 1700       %LSET INIT=CHARTEXT('/*');
 1701       %ENDIF;
 1702
 1703              %IF LVL=1;
 1704      DCL 1 NAME STCLASS ALGN,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         51   
 1705       %ELSE;
 1706            %LVL NAME ALGN,
 1707       %ENDIF;
 1708              %(LVL+1) TRADEL,
 1709      %IF NOT( MODE_FEP ) ;
 1710              %(LVL+2) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1711      %ENDIF ;
 1712              %(LVL+2) T# UBIN(8) UNAL %INIT(TRANSIT_DELAY_T)%CHARTEXT('/**/'),
 1713      %IF   NOT( MODE_FEP ) ;
 1714              %(LVL+2) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1715      %ENDIF ;
 1716              %(LVL+2) B# UBIN(8) UNAL %INIT(TRANSIT_DELAY_B)%CHARTEXT('/**/'),
 1717      %IF   ( MODE_FEP ) ;
 1718              %(LVL+1) TRADEL# REDEF TRADEL UBIN(16),
 1719      %ENDIF ;
 1720              %(LVL+1) RESTIM# UBIN BYTE UNAL %INIT(RESET_TIMEOUT)%CHARTEXT('/**/'),
 1721      /*K* RESTIM# - UBIN BYTE.
 1722           Specifies the amount of time (0-255) in seconds to wait before
 1723           attempting to reconnect a virtual circuit.
 1724      */
 1725              %(LVL+1) RESRET# UBIN BYTE UNAL %INIT(RESET_RETRIES)%CHARTEXT('/**/'),
 1726      /*K* RESRET# - UBIN BYTE.
 1727           Specifies number (0-10) of consecutive unsuccessful call packets
 1728           that will be attempted before the circuit is declared dead.
 1729      */
 1730              %(LVL+1) CLRTIM# UBIN BYTE UNAL %INIT(CLEAR_TIMEOUT)%CHARTEXT('/**/'),
 1731      /*K* CLRTIM# - UBIN BYTE.
 1732           Specifies the interval in seconds (1-255) that should expire
 1733           after a frame has been transmitted before corrective action is taken.
 1734      */
 1735              %(LVL+1) CLRRET# UBIN BYTE UNAL %INIT(CLEAR_RETRIES)%CHARTEXT('/**/'),
 1736      /*K* CLRRET# - UBIN BYTE.
 1737           Specifies the number of seconds (0-255) to wait after deciding to
 1738           send an explicit flow control message.
 1739      */
 1740              %(LVL+1) DATTIM# UBIN BYTE UNAL %INIT(DATA_TIMEOUT)%CHARTEXT('/**/'),
 1741      /*K* DATTIM# - UBIN BYTE.
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         52   
 1742           Specifies the amount of time (0-255) in seconds to wait before
 1743           attempting to reconnect a virtual circuit.
 1744      */
 1745              %(LVL+1) DATRET# UBIN BYTE UNAL %INIT(DATA_RETRIES)%CHARTEXT('/**/'),
 1746      /*K* DATRET# - UBIN BYTE.
 1747           Specifies the number (0-10) of consecutive unsuccessful call
 1748           packets that will be attempted before the circuit is declared dead.
 1749      */
 1750              %(LVL+1) INTTIM# UBIN BYTE UNAL %INIT(INTERRUPT_TIMEOUT)%CHARTEXT('/**/'),
 1751      /*K* INTTIM# - UBIN BYTE.
 1752           Specifies the interval in seconds (1-255) that should expire
 1753           after a frame has been transmitted before corrective action is taken.
 1754      */
 1755              %(LVL+1) IDLTIM# UBIN BYTE UNAL %INIT(IDLE_TIMEOUT)%CHARTEXT('/**/'),
 1756      /*K* IDLTIM# - UBIN BYTE.
 1757           Specifies the number of seconds (0-255) to wait after deciding to
 1758           send an explicit flow control message.
 1759      */
 1760              %(LVL+1) CDLY# UBIN BYTE UNAL %INIT(CALL_DELAY)%CHARTEXT('/**/'),
 1761      /*K* DLY# - UBIN BYTE.
 1762           Specifies the amount of time (0-255) in seconds to wait before
 1763           attempting to reconnect a virtual circuit.
 1764      */
 1765              %(LVL+1) CRTR# UBIN BYTE UNAL %INIT(CALL_RETRIES)%CHARTEXT('/**/'),
 1766      /*K* RTR# - UBIN BYTE.
 1767           Specifies number (0-10) of consecutive unsuccessful call packets
 1768           that will be attempted before the circuit is declared dead.
 1769      */
 1770              %(LVL+1) CTMT# UBIN BYTE UNAL %INIT(CALL_TIMEOUT)%CHARTEXT('/**/'),
 1771      /*K* TMT# - UBIN BYTE.
 1772           Specifies the interval in seconds (1-255) that should expire
 1773           after a frame has been transmitted before corrective action is taken.
 1774      */
 1775              %(LVL+1) RSPTMR# UBIN BYTE UNAL %INIT(RESP_TIMER)%CHARTEXT('/**/'),
 1776      /*K* RSPTMR# - UBIN BYTE.
 1777           Specifies the number of seconds (0-255) to wait after deciding to
 1778           send an explicit flow control message.
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         53   
 1779      */
 1780      %IF   NOT( MODE_FEP ) ;
 1781              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1782      %ENDIF ;
 1783              %(LVL+1) RCVSIZ# UBIN(4) UNAL %INIT(RECEIVE_SIZE)%CHARTEXT('/**/'),
 1784      /*K* RCVSIZ# - UBIN(4).
 1785           Specifies the maximum date size of packets for the call recipient.
 1786           EQUate identifiers for RCVSIZ# are listed in the following table.
 1787           ..::TB "^\Identifier\#10\Meaning\#"
 1788           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_128#
 1789           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_256#
 1790           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_512#
 1791           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_1024#
 1792           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_2048#
 1793           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_4096#
 1794           ..::TB
 1795      */
 1796              %(LVL+1) RCVTHR# UBIN(4) UNAL %INIT(RECEIVE_THROUGHPUT)%CHARTEXT('/**/'),
 1797      /*K* RCVTHR# - UBIN(4).
 1798           Specifies the throughput class of the virtual circuit from the
 1799           call recipient.
 1800           ..::TB "^\Identifier\#10\Meaning\#"
 1801           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_NONE#
 1802           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_75#
 1803           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_150#
 1804           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_300#
 1805           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_600#
 1806           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_1200#
 1807           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_2400#
 1808           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_4800#
 1809           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_9600#
 1810           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_19200#
 1811           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_48000#
 1812           ..::TB
 1813      */
 1814      %IF   NOT( MODE_FEP ) ;
 1815              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         54   
 1816      %ENDIF ;
 1817              %(LVL+1) RSPTOCMP# BIT(1) UNAL %INIT(RESPOND_TO_COMPLETE)%CHARTEXT('/**/'),
 1818      /*K* RSPTOCOMP# - BIT(1).
 1819           If set, means any complete data packet sequence should be ack'd immediately.
 1820      */
 1821              %(LVL+1) RCVWND# UBIN(7) UNAL %INIT(RECEIVE_WINDOW)%CHARTEXT('/**/'),
 1822      /*K* RCVWND# - UBIN(7).
 1823           Specifies the transmission window size (2-127).
 1824      */
 1825      %IF   NOT( MODE_FEP ) ;
 1826              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1827      %ENDIF ;
 1828              %(LVL+1) EXTSEQ# BIT(1) UNAL %INIT(EXTEND_SEQ)%CHARTEXT('/**/'),
 1829      /*K* EXTSEQ# - BIT(1).  Specifies whether or not to allow packet
 1830      window sizes to 127.
 1831      */
 1832              %(LVL+1) RSPDLY# UBIN(7) UNAL %INIT(RESPONSE_DELAY)%CHARTEXT('/**/'),
 1833      /*K* RSPDLY# - UBIN(7).
 1834           Specifies the number (1-127) of unacknowledged packets that should
 1835           be received before an acknowledgement packet is generated.
 1836      */
 1837      %IF   NOT( MODE_FEP ) ;
 1838              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1839      %ENDIF ;
 1840              %(LVL+1) SNDTHR# UBIN(4) UNAL %INIT(SEND_THROUGHPUT)%CHARTEXT('/**/'),
 1841      /*K* SNDTHR# - UBIN(4).
 1842           Specifies the throughput class of the virtual circuit to the call
 1843           recipient.  EQUate identifiers for SNDTHR# are listed in the
 1844           following table.
 1845           ..::TB "^\Identifier\#10\Meaning\#"
 1846           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_NONE#
 1847           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_75#
 1848           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_150#
 1849           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_300#
 1850           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_600#
 1851           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_1200#
 1852           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_2400#
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         55   
 1853           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_4800#
 1854           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_9600#
 1855           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_19200#
 1856           .xeq KL_SUPER_C KLX25_THR_E KLX25_THR_48000#
 1857           ..::TB
 1858      */
 1859              %(LVL+1) SNDSIZ# UBIN(4) UNAL %INIT(SEND_SIZE)%CHARTEXT('/**/'),
 1860      /*K* SNDSIZ# - UBIN(4).
 1861           Specifies the maximum data size of packets sent to the call recipient.
 1862           EQUate identifiers for SNDSIZ# are listed in the following table.
 1863           ..::TB "^\Identifier\#10\Meaning\#"
 1864           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_128#
 1865           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_256#
 1866           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_512#
 1867           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_1024#
 1868           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_2048#
 1869           .xeq KL_SUPER_C KLX25_SIZ_E KLX25_SIZ_4096#
 1870           ..::TB
 1871      */
 1872
 1873      %IF   NOT( MODE_FEP ) ;
 1874              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1875      %ENDIF ;
 1876              %(LVL+1) CHARGE# BIT(1) UNAL %INIT(CHARGE_INFO)%CHARTEXT('/**/'),
 1877      /*K* CHARGE# - BIT(1).
 1878           Specifies whether or not to request charging information
 1879           for incoming calls.
 1880      */
 1881              %(LVL+1) SNDWND# UBIN(7) UNAL %INIT(SEND_WINDOW)%CHARTEXT('/**/'),
 1882      /*K* SNDWND# - UBIN(7).
 1883           Specifies the transmit window size (2-127).
 1884      */
 1885      %IF   NOT( MODE_FEP ) ;
 1886              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
 1887      %ENDIF ;
 1888              %(LVL+1) RVR# UBIN(2) UNAL %INIT(REVERSE)%CHARTEXT('/**/'),
 1889      /*K* RVR# - UBIN(2).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         56   
 1890           Specifies whether or not reverse charging should be specified
 1891           in the call packet.
 1892           EQUate identifiers for RVR# are listed in the following table.
 1893           ..::TB "^\Identifier\#10\Meaning\#"
 1894           .xeq KL_SUPER_C KLX25_RVR_E KLX25_RVR_NO#
 1895           .xeq KL_SUPER_C KLX25_RVR_E KLX25_RVR_YES#
 1896           ..::TB
 1897      */
 1898              %(LVL+1) * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/') LAST
 1899      %MEND;
 1900      /*F* NAME: KL_CONTROLLER - Polled Line Record Definition
 1901
 1902      The KL_CONTROLLER macro defines the structure for polled line
 1903      controller records in the :HLP file.
 1904
 1905      This is the structure that is passed to the handler's
 1906      administrative routine when the value of KH$ADMIN_FPT.FNC
 1907      is %KHA_FNC_BLDCTX and the value in KHA$ADMIN_FPT.TERMID.LEV is
 1908      TERMINAL_ID_LEV_SUBCHAN#.
 1909
 1910      The fields within this structure are as follows:
 1911      */
 1912
 1913      %MACRO KL_CONTROLLER (NAME=KL_CONTROLLER,STCLASS=BASED,LVL=1,LAST=";");
 1914
 1915       %LSET LISTDIR='0'B;
 1916       %LSET LISTEXP='1'B;
 1917       %LSET LISTCOM='0'B;
 1918       %LSET LISTSUB='1'B;
 1919       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1920       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1921       (SUBSTR(STR,0,8)='CONSTANT') OR
 1922       (SUBSTR(STR,0,3)='EXT');
 1923       %LSET INIT=CHARTEXT('INIT');
 1924       %ELSE;
 1925       %LSET INIT=CHARTEXT('/*');
 1926       %ENDIF;
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         57   
 1927      %LSET LEVP1=%(LVL+1);
 1928
 1929       %IF LVL=1;
 1930      DCL 1 NAME STCLASS,
 1931       %ELSE;
 1932            %LVL NAME,
 1933       %ENDIF;
 1934      /*K* BLKHDR.LEV - UBIN BYTE.
 1935      Contains TERMINAL_ID_LEV_SUBCHAN#, meaning that this is the
 1936      controller portion of the line profile.
 1937      */
 1938      /*K* BLKHDR.NSUBS - UBIN BYTE.
 1939      .xeq KL_SUPER_C KL_BLKHDR NSUBS
 1940      */
 1941      /*K* BLKHDR.LEN - UBIN WORD.
 1942      .xeq KL_SUPER_C KL_BLKHDR LEN
 1943      */
 1944      /*K* BLKHDR.BLKTYP - UBIN BYTE.
 1945      Contains KLTY_CONT# (Controller for 3270) or KLTY_HIP_CONT#
 1946      (Controller for Polled VIP) to identify this piece of the line
 1947      profile.
 1948      */
 1949              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=CALIGNED,LAST=",");
 1950      /*K* CONT# - UBIN BYTE.
 1951      Contains the controller number.
 1952      */
 1953            %(LVL+1) CONT# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1954      /*K* ROWS - UBIN BYTE.
 1955      Contains the number of rows on the screen.
 1956      */
 1957            %(LVL+1) ROWS UBIN BYTE UNAL %INIT(24)%CHARTEXT('/**/'),
 1958      /*K* COLUMNS - UBIN BYTE.
 1959      Contains the number of columns on the screen.
 1960      */
 1961            %(LVL+1) COLUMNS UBIN BYTE UNAL %INIT(80)%CHARTEXT('/**/'),
 1962            %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 1963      /*K* TYPE - UBIN(16).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         58   
 1964      Contains the type of controller:  2780, 3271, 3274, 3275, 3276,
 1965      7700, or 7804.
 1966      */
 1967            %(LVL+1) TYPE UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(6348)%CHARTEXT('/**/'),
 1968            %(LVL+1) * UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/') LAST
 1969      %MEND;
 1970
 1971
 1972      /*F* NAME: KL_LINEDEV - 3270 Device Record Definition
 1973
 1974      The KL_LINEDEV macro defines the structure for device records
 1975      in the :HLP file.
 1976
 1977      This is the structure that is passed to the handler's
 1978      administrative routine when the value of KH$ADMIN_FPT.FNC
 1979      is %KHA_FNC_BLDCTX and the value in KHA$ADMIN_FPT.TERMID.LEV is
 1980      TERMINAL_ID_LEV_SUBSUBCHAN#.
 1981
 1982      The fields within this structure are as follows:
 1983      */
 1984      %MACRO KL_LINEDEV (NAME=KL_LINEDEV,STCLASS=BASED,LVL=1,LAST=";");
 1985
 1986       %LSET LISTDIR='0'B;
 1987       %LSET LISTEXP='1'B;
 1988       %LSET LISTCOM='0'B;
 1989       %LSET LISTSUB='1'B;
 1990       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1991       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1992       (SUBSTR(STR,0,8)='CONSTANT') OR
 1993       (SUBSTR(STR,0,3)='EXT');
 1994       %LSET INIT=CHARTEXT('INIT');
 1995       %ELSE;
 1996       %LSET INIT=CHARTEXT('/*');
 1997       %ENDIF;
 1998      %LSET LEVP1=%(LVL+1);
 1999
 2000       %IF LVL=1;
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         59   
 2001      DCL 1 NAME STCLASS,
 2002       %ELSE;
 2003            %LVL NAME,
 2004       %ENDIF;
 2005      /*K* BLKHDR.LEV - UBIN BYTE.
 2006      Contains TERMINAL_ID_LEV_SUBSUBCHAN#, meaning that this portion
 2007      of the line profile represents a device connected to a controller.
 2008      */
 2009      /*K* BLKHDR.NSUBS - UBIN BYTE.
 2010      .xeq KL_SUPER_C KL_BLKHDR NSUBS
 2011      */
 2012      /*K* BLKHDR.LEN - UBIN WORD.
 2013      .xeq KL_SUPER_C KL_BLKHDR LEN
 2014      */
 2015      /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2016      Contains KLTY_LINEDEV# (Device for 3270) or KLTY_HIP_DEV# (Device
 2017      for Polled VIP) to identify this piece of the line profile.
 2018      */
 2019              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=CALIGNED,LAST=",");
 2020      /*K* CONTROLLER# - UBIN BYTE.
 2021      Contains the controller number.*/
 2022            %(LVL+1) CONTROLLER# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2023      /*K* DEVICE# - UBIN BYTE.
 2024      Contains the device number. */
 2025            %(LVL+1) DEVICE# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2026      /*K* TYPE - UBIN(16).
 2027      Contains the type of device:  3275, 3277, 3278, 3279, 3284, 3287,
 2028      3288, 3289 (and perhaps others).
 2029      */
 2030            %(LVL+1) TYPE UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(6350)%CHARTEXT('/**/'),
 2031      /*K* ROWS - UBIN BYTE.
 2032      Contains the number of rows on the screen.
 2033      */
 2034            %(LVL+1) ROWS UBIN BYTE UNAL %INIT(24)%CHARTEXT('/**/'),
 2035      /*K* COLUMNS - UBIN BYTE.
 2036      Contains the number of columns on the screen.
 2037      */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         60   
 2038            %(LVL+1) COLUMNS UBIN BYTE UNAL %INIT(80)%CHARTEXT('/**/'),
 2039            %(LVL+1) * UBIN(%(18-BITBIN(MODE_FEP)*2)) UNAL %INIT(0)%CHARTEXT('/**/') LAST
 2040      %MEND;
 2041
 2042
 2043      /*F* NAME: KL_LNKVC - Virtual Circuit Level Definition
 2044
 2045      The KL_LNKVC macro defines the structure for the
 2046      virtual circuit record.
 2047        This structure is passed to the handler in ADMIN_FPT.CTX$
 2048        via handler common BLDCTX calls.
 2049      */
 2050      %MACRO KL_LNKVC ( NAME = KL_LNKVC, STCLASS = BASED,
 2051                  VCPRO=' ',
 2052                DESTINATION = '        ',
 2053                ALGN=WALIGNED,
 2054                   LVL = 1, LAST = ";" );
 2055
 2056
 2057       %LSET LISTDIR='0'B;
 2058       %LSET LISTEXP='1'B;
 2059       %LSET LISTCOM='0'B;
 2060       %LSET LISTSUB='1'B;
 2061       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2062       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2063       (SUBSTR(STR,0,8)='CONSTANT') OR
 2064       (SUBSTR(STR,0,3)='EXT');
 2065       %LSET INIT=CHARTEXT('INIT');
 2066       %ELSE;
 2067       %LSET INIT=CHARTEXT('/*');
 2068       %ENDIF;
 2069      %LSET LEVP1=%(LVL+1);
 2070
 2071       %IF LVL=1;
 2072      DCL 1 NAME STCLASS ALGN,
 2073       %ELSE;
 2074            %LVL NAME ALGN,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         61   
 2075       %ENDIF;
 2076              %KL_BLKHDR(NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=CALIGNED,LAST=",");
 2077            %(LVL+1) CUG,
 2078        /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2079             Contains KLTY_VIRCIR# to identify this piece of the line
 2080             profile.
 2081        */
 2082        /*K* BLKHDR.LEV - UBIN BYTE.
 2083             Contains TERMINAL_ID_LEV_SUBCHAN#, meaning that this portion
 2084             of the line profile represents a subdevice.
 2085        */
 2086        /*K* BLKHDR.PROOFFSET - UBIN BYTE.
 2087             .xeq KL_SUPER_C KL_BLKHDR PROOFFSET
 2088        */
 2089        %IF NOT (MODE_FEP);
 2090            %(LVL+2) * BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
 2091           %ENDIF;
 2092            %(LVL+2) LNG# UBIN(2) UNAL %INIT(0)%CHARTEXT('/**/'),
 2093      /*K* LNG# - UBIN(2).
 2094           Specifies the number of digits in the closed user
 2095           group identifier.  This will be either 0, 2, or 4
 2096           digits.
 2097      */
 2098            %(LVL+2) * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/'),
 2099        %IF NOT (MODE_FEP);
 2100            %(LVL+2) * BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
 2101           %ENDIF;
 2102            %(LVL+2) BCD1# UBIN(4) UNAL %INIT(0)%CHARTEXT('/**/'),
 2103      /*K* BCD1# - UBIN(4).
 2104           Specifies the closed user group identifier (in binary coded decimal).
 2105      */
 2106            %(LVL+2) BCD2# UBIN(4) UNAL %INIT(0)%CHARTEXT('/**/'),
 2107      /*K* BCD2# - UBIN(4).
 2108           Specifies the closed user group identifier (in binary coded decimal).
 2109      */
 2110        %IF NOT (MODE_FEP);
 2111            %(LVL+2) * BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         62   
 2112           %ENDIF;
 2113            %(LVL+2) BCD3# UBIN(4) UNAL %INIT(0)%CHARTEXT('/**/'),
 2114      /*K* BCD3# - UBIN(4).
 2115           Specifies the closed user group identifier (in binary coded decimal).
 2116      */
 2117            %(LVL+2) BCD4# UBIN(4) UNAL %INIT(0)%CHARTEXT('/**/'),
 2118      /*K* BCD4# - UBIN(4).
 2119           Specifies the closed user group identifier (in binary coded decimal).
 2120      */
 2121            %(LVL+1) CUG_REDEF REDEF CUG,
 2122            %(LVL+2) * UBIN BYTE UNAL,
 2123            %(LVL+2) BCDS UBIN(%(18-2*BITBIN(MODE_FEP))) UNAL,
 2124            %(LVL+1) ADR,
 2125            %(LVL+2) LNG# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2126            %(LVL+2) ADR(0:6),
 2127      /*K* ADR - ARRAY (0:6).
 2128           Contains the 14 binary coded digit address of the destination circuit.
 2129           Array elements are in the following format:
 2130           .spf
 2131           .fif
 2132              BCD1# UBIN(4)
 2133              BCD2# UBIN(4)
 2134              BCD3# UBIN(4)
 2135              BCD4# UBIN(4)
 2136           .fin
 2137      */
 2138      %IF   NOT( MODE_FEP ) ;
 2139            %(LVL+3) * UBIN(1) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 2140      %ENDIF ;
 2141            %(LVL+3) BCD1# UBIN(4) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 2142            %(LVL+3) BCD2# UBIN(4) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 2143            %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2144            %(LVL+1) DST# CHAR(8) UNAL %INIT(DESTINATION)%CHARTEXT('/**/'),
 2145      /*K* DST# - CHAR(8).
 2146           Specifies the destination node name as defined in NETCON.
 2147      */
 2148            %(LVL+1) PRONM,               /* VIRTUAL CIRCUIT PROFILE */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         63   
 2149      %IF   VCPRO=' ';
 2150      %SET VCPROCNT = CHARTEXT('0');
 2151      %ELSE;
 2152      %SET VCPROCNT = CHARTEXT(BINCHAR(LENGTHC(VCPRO)));
 2153      %ENDIF;
 2154            %(LVL+2) CNT UBIN BYTE UNAL %INIT(%VCPROCNT)%CHARTEXT('/**/'),
 2155      /*K* CNT - UBIN BYTE.
 2156           Contains the length in bytes of the profile string.
 2157      */
 2158            %(LVL+2) TXT CHAR(11) UNAL %INIT(VCPRO)%CHARTEXT('/**/'),
 2159      /*K* TXT - CHAR(11).
 2160           Contains the profile name for this virtual circuit.
 2161      */
 2162            %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2163      /*  need for backward compatability with D00. */
 2164            %(LVL+1) NODE# UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2165      /*K* NODE# - UBIN BYTE.
 2166           Specifies the node number corresponding to DST#.
 2167      */
 2168        %IF NOT (MODE_FEP);
 2169            %(LVL+1) VIRCIR# UBIN(18) UNAL %INIT(0)%CHARTEXT('/**/'),
 2170           %ELSE ;
 2171            %(LVL+1) VIRCIR# UBIN(16) UNAL %INIT(0)%CHARTEXT('/**/'),
 2172           %ENDIF;
 2173
 2174      /*K* VIRCIR# - UBIN(12)
 2175           Specifies the number of the virtual circuit.
 2176      */
 2177            %(LVL+1) QOS# UBIN BYTE UNAL %INIT(2)%CHARTEXT('/**/'),
 2178      /*K* QOS# - UBIN BYTE.
 2179           Specifies the Quality of Service for this virtual circuit.
 2180      */
 2181        %IF NOT (MODE_FEP);
 2182            %(LVL+1) * BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
 2183          %ENDIF;
 2184            %(LVL+1) PERMANENT BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
 2185            %(LVL+1) * UBIN(7) UNAL %INIT(0)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         64   
 2186            %(LVL+1) * (0:1) UBIN BYTE UNAL %INIT(0*0)%CHARTEXT('/**/') LAST
 2187      %MEND;
 2188
 2189      /*F* NAME: KL_LINKDEV - Communication Line Resource Structure
 2190
 2191      The KL_LINKDEV macro defines the structure for a Communication Line
 2192      resource record.  This structure is passed to the handler in
 2193      ADMIN_FPT.CTX$ via handler common BLDCTX calls.
 2194      */
 2195      %MACRO KL_LINKDEV (NAME=KL_LINKDEV,STCLASS=BASED,LVL=1,LAST=";");
 2196
 2197       %LSET LISTDIR='0'B;
 2198       %LSET LISTEXP='1'B;
 2199       %LSET LISTCOM='0'B;
 2200       %LSET LISTSUB='1'B;
 2201       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2202       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2203       (SUBSTR(STR,0,8)='CONSTANT') OR
 2204       (SUBSTR(STR,0,3)='EXT');
 2205       %LSET INIT=CHARTEXT('INIT');
 2206       %LSET ENIT=CHARTEXT(' ');
 2207       %ELSE;
 2208       %LSET INIT=CHARTEXT('/*');
 2209       %LSET ENIT=CHARTEXT('*/');
 2210       %ENDIF;
 2211      %LSET LEVP1=%(LVL+1);
 2212
 2213       %IF LVL=1;
 2214      DCL 1 NAME STCLASS,
 2215       %ELSE;
 2216            %LVL NAME,
 2217       %ENDIF;
 2218      /*K* BLKHDR.LEV - UBIN BYTE.
 2219      Contains TERMINAL_ID_LEV_SUBCHAN#, meaning that this portion of
 2220      the line profile represents a subdevice.
 2221      */
 2222      /*K* BLKHDR.NSUBS - UBIN BYTE.
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         65   
 2223      .xeq KL_SUPER_C KL_BLKHDR NSUBS
 2224      */
 2225      /*K* BLKHDR.LEN - UBIN WORD.
 2226      .xeq KL_SUPER_C KL_BLKHDR LEN
 2227      */
 2228      /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2229      Contains KLTY_LINKDEV# to identify this piece of the line profile.
 2230      */
 2231      /*K* BLKHDR.USE - UBIN BYTE.
 2232      .xeq KL_SUPER_C KL_BLKHDR USE
 2233      */
 2234              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=CALIGNED,LAST=",");
 2235      /*K* CIRCUITS# - UBIN HALF.
 2236      Contains the limit of circuits for OUTGOING resources.  */
 2237           %IF NOT (MODE_FEP);
 2238            %(LVL+1) CIRCUITS# UBIN(18) UNAL %INIT(0)%ENIT,
 2239           %ELSE ;
 2240            %(LVL+1) CIRCUITS# UBIN(16) UNAL %INIT(0)%ENIT,
 2241           %ENDIF;
 2242
 2243      /*K* PROTOCOL# - UBIN BYTE.
 2244      Contains the incoming call identifier for INCOMING resources.  */
 2245            %(LVL+1) PROTOCOL# UBIN BYTE UNAL %INIT(0)%ENIT,
 2246
 2247      /*K* SUBADDR# - UBIN BYTE.
 2248      Contains the incoming call identifier for INCOMING resources.  */
 2249            %(LVL+1) SUBADDR# UBIN BYTE UNAL %INIT(0)%ENIT,
 2250
 2251      /*K* MODE - UBIN BYTE.
 2252      Contains one of these options:  INCOMING, OUTGOING, FIXED.
 2253      Contains one of these options:  INCOMING, OUTGOING, FIXED.
 2254
 2255        INCOMING describes the possible appearance of some number of
 2256        incoming "lines" whose existence is to be reported to the attached
 2257        Host user (if any), so that the host user can then connect to
 2258        the "lines" individually.
 2259
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         66   
 2260        OUTGOING describes the availability of some number of "lines"
 2261        that can be created as needed when so requested by Host users.
 2262
 2263        FIXED describes a single facility like an Async modem, which is
 2264        entirely controlled by a single Host user at a time.
 2265      */
 2266        %IF NOT (MODE_FEP);
 2267            %(LVL+1) * UBIN(1) UNAL %INIT(0)%ENIT,
 2268           %ENDIF;
 2269            %(LVL+1) MODE UBIN(8) UNAL %INIT(0)%ENIT,
 2270
 2271        %IF NOT (MODE_FEP);
 2272            %(LVL+1) * UBIN(27) UNAL %INIT(0)%ENIT,
 2273           %ELSE ;
 2274            %(LVL+1) * UBIN(24) UNAL %INIT(0)%ENIT,
 2275           %ENDIF;
 2276      /*K* LOGON# - CHAR(8).
 2277      Contains the logon devicename for this link device.
 2278      */
 2279            %(LVL+1) LOGON# CHAR(8) UNAL %INIT(' ')%ENIT LAST
 2280      %MEND;
 2281
 2282      /*F* NAME: KLUS_E
 2283           Equs for kl$blkhdr.use field.  */
 2284      %SUB KLUS_UNDEF# = 0;
 2285      /*K* KLUS_UNDEF#
 2286      .trf ]#
 2287      KLUS_UNDEF]                Undefined.
 2288      .trf ]]
 2289      */
 2290      %SUB KLUS_TS# = 1;
 2291      /*K* KLUS_TS#
 2292      .trf ]#
 2293      KLUS_TS]                   Time-share.
 2294      .trf ]]
 2295      */
 2296      %SUB KLUS_STAT# = 2;
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         67   
 2297      /*K* KLUS_STAT#
 2298      .trf ]#
 2299      KLUS_STAT]                 Station.
 2300      .trf ]]
 2301      */
 2302      %SUB KLUS_TERM# = 3;
 2303      /*K* KLUS_TERM#
 2304      .trf ]#
 2305      KLUS_TERM]                 Terminal.
 2306      .trf ]]
 2307      */
 2308      %SUB KLUS_CON# = 4;
 2309      /*K* KLUS_CON#
 2310      .trf ]#
 2311      KLUS_CON]                  Console.
 2312      .trf ]]
 2313      */
 2314      %SUB KLUS_IN_DEV# = 5;
 2315      /*K* KLUS_IN_DEV#
 2316      .trf ]#
 2317      KLUS_IN_DEV]               INSYM device.
 2318      .trf ]]
 2319      */
 2320      %SUB KLUS_OUT_DEV# = 6;
 2321      /*K* KLUS_OUT_DEV#
 2322      .trf ]#
 2323      KLUS_OUT_DEV]              OUTSYM device.
 2324      .trf ]]
 2325      */
 2326      %SUB KLUS_TP_DEV# = 7;
 2327      /*K* KLUS_TP_DEV#
 2328      .trf ]#
 2329      KLUS_TP_DEV]               TP device.
 2330      .trf ]]
 2331      */
 2332      %SUB KLUS_LINE# = 8;
 2333      /*K* KLUS_LINE#
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         68   
 2334      .trf ]#
 2335      KLUS_LINE]                 Line.
 2336      .trf ]]
 2337      */
 2338      %SUB KLUS_LNK# = 9;
 2339      /*K* KLUS_LNK#
 2340      .trf ]#
 2341      KLUS_LNK]                  Link.
 2342      .trf ]]
 2343      */
 2344      %SUB KLUS_VC# = 10;
 2345      /*K* KLUS_VC#
 2346      .trf ]#
 2347      KLUS_VC]                   Virtual circuit.
 2348      .trf ]]
 2349      */
 2350      %SUB KLUS_CG_DEV# = 11;
 2351      /*K* KLUS_CG_DEV#
 2352      .trf ]#
 2353      KLUS_CG_DEV]               CG device.
 2354      .trf ]]
 2355      */
 2356      %SUB KLUS_RES_DEV# = 12;
 2357      /*K* KLUS_RES_DEV#
 2358      .trf ]#
 2359      KLUS_RES_DEV]              RES device.
 2360      .trf ]]
 2361      */
 2362
 2363
 2364      /*F* NAME: KL_BLKHDR - Block Header for Line Profiles
 2365
 2366      The KL_BLKHDR macro is be used to define the header portion
 2367      of the records which are part of line profile definitions.
 2368      */
 2369      %MACRO KL_BLKHDR (NAME=KL_BLKHDR,
 2370                        STCLASS=BASED,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         69   
 2371                        LVL=1,
 2372                        ALGN=WALIGNED,
 2373                        LAST=";");
 2374
 2375       %LSET LISTDIR='0'B;
 2376       %LSET LISTEXP='1'B;
 2377       %LSET LISTCOM='0'B;
 2378       %LSET LISTSUB='1'B;
 2379       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2380       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2381       (SUBSTR(STR,0,8)='CONSTANT') OR
 2382       (SUBSTR(STR,0,3)='EXT');
 2383       %LSET INIT=CHARTEXT('INIT');
 2384       %ELSE;
 2385       %LSET INIT=CHARTEXT('/*');
 2386       %ENDIF;
 2387
 2388      %IF LVL=1;
 2389      DCL 1 NAME STCLASS ALGN,
 2390      %ELSE;
 2391            %LVL NAME ALGN,
 2392      %ENDIF;
 2393              %(LVL+1) LEV UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2394      /*K* LEV - UBIN BYTE.
 2395      Contains the level of this piece of the line profile.  EQUate
 2396      identifiers for LEV are listed in the following table.
 2397      ..::TB "^\Identifier\#20\Meaning"
 2398      .xeq CP_6_SUBS TERMINAL_ID_LEV_E  ID_LEV_CHAN#
 2399      .xeq CP_6_SUBS TERMINAL_ID_LEV_E  ID_LEV_NONE#
 2400      .xeq CP_6_SUBS TERMINAL_ID_LEV_E  ID_LEV_SUBCHAN#
 2401      .xeq CP_6_SUBS TERMINAL_ID_LEV_E  ID_SUBSUBCHAN#
 2402      ..::TB
 2403      */
 2404              %(LVL+1) NSUBS UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2405      /*K* NSUBS - UBIN BYTE.
 2406      Contains the number of sub blocks following this piece.*/
 2407      %IF NOT(MODE_FEP);
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         70   
 2408              %(LVL+1) LEN (0:1),
 2409              %(LVL+2) * BIT(1) UNAL %INIT('0'B*0)%CHARTEXT('/**/'),
 2410              %(LVL+2) BYT UBIN(8) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 2411      %ELSE;
 2412              %(LVL+1) LEN UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 2413      %ENDIF;
 2414      /*K* LEN - UBIN WORD.
 2415      Contains the size in bytes of this piece of the line profile
 2416      including the KL_BLKHDR structure. */
 2417              %(LVL+1) BLKTYP UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2418      /*K* BLKTYP - UBIN BYTE.
 2419      Contains the type of this piece of the line profile
 2420      i.e., 3270, HASP, LINK, etc.  The EQUate identifiers for BLKTYP
 2421      are listed in the following table.
 2422      ..::TB "^\Identifier\#20\Meaning\#"
 2423      .xeq KL_SUPER_C KLTY_E KLTY_3270#
 2424      .xeq KL_SUPER_C KLTY_E KLTY_CONT#
 2425      .xeq KL_SUPER_C KLTY_E KLTY_FEP#
 2426      .xeq KL_SUPER_C KLTY_E KLTY_HIP_CONT#
 2427      .xeq KL_SUPER_C KLTY_E KLTY_HIP_DEV#
 2428      .xeq KL_SUPER_C KLTY_E KLTY_HIP_LINE#
 2429      .xeq KL_SUPER_C KLTY_E KLTY_LINEDEV#
 2430      .xeq KL_SUPER_C KLTY_E KLTY_LINK#
 2431      .xeq KL_SUPER_C KLTY_E KLTY_LINKDEV#
 2432      .xeq KL_SUPER_C KLTY_E KLTY_PROG#
 2433      .xeq KL_SUPER_C KLTY_E KLTY_SDEV#
 2434      .xeq KL_SUPER_C KLTY_E KLTY_STRM#
 2435      .xeq KL_SUPER_C KLTY_E KLTY_TTY#
 2436      .xeq KL_SUPER_C KLTY_E KLTY_URP#
 2437      .xeq KL_SUPER_C KLTY_E KLTY_VIRCIR#
 2438      ..::TB
 2439      */
 2440              %(LVL+1) PROOFFSET UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2441      /*K* PROOFFSET - UBIN BYTE.
 2442      Contains the byte offset from the top of KL_BLKHDR
 2443      to the profile structure for this piece of the line profile.*/
 2444              %(LVL+1) DEVNUM UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         71   
 2445      /*K* DEVNUM - UBIN BYTE.
 2446           Contains the controller or device
 2447      number to which this piece of context is to be associated. */
 2448              %(LVL+1) USE UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/') LAST
 2449      /*K* USE - UBIN BYTE.
 2450           Contains the USE field as defined in SUPER.
 2451           Substitution identifiers for this field are listed in the
 2452           following table.
 2453           ..::TB "^\Identifier\#17\Meaning\#"
 2454           .xeq KL_SUPER_C KLUS_E KLUS_CG_DEV#
 2455           .xeq KL_SUPER_C KLUS_E KLUS_CON#
 2456           .xeq KL_SUPER_C KLUS_E KLUS_IN_DEV#
 2457           .xeq KL_SUPER_C KLUS_E KLUS_LINE#
 2458           .xeq KL_SUPER_C KLUS_E KLUS_LNK#
 2459           .xeq KL_SUPER_C KLUS_E KLUS_OUT_DEV#
 2460           .xeq KL_SUPER_C KLUS_E KLUS_RES_DEV#
 2461           .xeq KL_SUPER_C KLUS_E KLUS_STAT#
 2462           .xeq KL_SUPER_C KLUS_E KLUS_TERM#
 2463           .xeq KL_SUPER_C KLUS_E KLUS_TP_DEV#
 2464           .xeq KL_SUPER_C KLUS_E KLUS_TS#
 2465           .xeq KL_SUPER_C KLUS_E KLUS_UNDEF#
 2466           .xeq KL_SUPER_C KLUS_E KLUS_VC#
 2467           ..::TB
 2468           */
 2469      %MEND;
 2470
 2471      /*F* NAME: KL_LN3270 - Line Level 3270 Definition
 2472
 2473      The KL_LN3270 macro contains the structure for the
 2474      line level 3270 or polled VIP definition.
 2475      This macro is passed to the handler via handler common BLDCTX
 2476      calls.  See the KH$ADMIN_FPT.CTX$ description.
 2477      */
 2478
 2479      %MACRO KL_LN3270 (NAME=KL_LN3270,
 2480                      STCLASS=BASED,
 2481                      SLAVE(YES='1'B,NO='0'B)='0'B,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         72   
 2482                      LVL=1,
 2483                      ALGN=WALIGNED);
 2484
 2485       %LSET LISTDIR='0'B;
 2486       %LSET LISTEXP='1'B;
 2487       %LSET LISTCOM='0'B;
 2488       %LSET LISTSUB='1'B;
 2489       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2490       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2491       (SUBSTR(STR,0,8)='CONSTANT') OR
 2492       (SUBSTR(STR,0,3)='EXT');
 2493       %LSET INIT=CHARTEXT('INIT');
 2494       %ELSE;
 2495       %LSET INIT=CHARTEXT('/*');
 2496       %ENDIF;
 2497      %LSET LEVP1=%(LVL+1);
 2498
 2499      %IF LVL=1;
 2500      DCL 1 NAME STCLASS ALGN,
 2501      %ELSE;
 2502            %LVL NAME ALGN,
 2503      %ENDIF;
 2504              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=ALGN,LAST=",");
 2505      /*K* BLKHDR.LEV - UBIN BYTE.
 2506      Contains TERMINAL_ID_LEV_CHAN# to identify the level of this portion
 2507      of the line profile.
 2508      */
 2509      /*K* BLKHDR.NSUBS - UBIN BYTE.
 2510      .xeq KL_SUPER_C KL_BLKHDR NSUBS
 2511      */
 2512      /*K* BLKHDR.LEN - UBIN WORD.
 2513      .xeq KL_SUPER_C KL_BLKHDR LEN
 2514      */
 2515      /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2516      Contains KLTY_3270# (3270 Line) or KLTY_HIP_LINE# (Communication
 2517      Line for Polled VIP) to identify this piece of the line profile.
 2518      */
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         73   
 2519      /*K* BLKHDR.PROOFFSET - UBIN BYTE.
 2520      .xeq KL_SUPER_C KL_BLKHDR PROOFFSET
 2521      */
 2522          %IF NOT (MODE_FEP);
 2523            %(LVL+1) * BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
 2524          %ENDIF;
 2525            %(LVL+1) SLAVE# BIT(2) UNAL %INIT(SLAVE)%CHARTEXT('/**/'),
 2526      /*K* SLAVE# - BIT(2).
 2527           If set to 1, means the host is to send the initial bid and
 2528           possibly the logon string for the line.
 2529      */
 2530            %(LVL+1) * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/'),
 2531            %(LVL+1) * UBIN(%(27-(3*BITBIN(MODE_FEP)))) UNAL %INIT(0)%CHARTEXT('/**/');
 2532      %MEND;
 2533
 2534
 2535      /*F* NAME: KL_HASP_ - Line Level HASP Definition
 2536
 2537      The KL_HASP macro defines the structure for the line level
 2538      HASP definition.
 2539      This macro is passed to the handler via handler common BLDCTX
 2540      calls.  See the KH$ADMIN_FPT.CTX$ description.
 2541      */
 2542
 2543      %MACRO KL_HASP (NAME=KL_HASP,
 2544                      STCLASS=BASED,
 2545                      SLAVE(YES='1'B,NO='0'B)='0'B,
 2546                      RLS = ' ',
 2547                      LVL=1,
 2548                      ALGN=WALIGNED);
 2549
 2550       %LSET LISTDIR='0'B;
 2551       %LSET LISTEXP='1'B;
 2552       %LSET LISTCOM='0'B;
 2553       %LSET LISTSUB='1'B;
 2554       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2555       %IF (SUBSTR(STR,0,6)='STATIC') OR
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         74   
 2556       (SUBSTR(STR,0,8)='CONSTANT') OR
 2557       (SUBSTR(STR,0,3)='EXT');
 2558       %LSET INIT=CHARTEXT('INIT');
 2559       %ELSE;
 2560       %LSET INIT=CHARTEXT('/*');
 2561       %ENDIF;
 2562      %LSET LEVP1=%(LVL+1);
 2563
 2564      %IF LVL=1;
 2565      DCL 1 NAME STCLASS ALGN,
 2566      %ELSE;
 2567            %LVL NAME ALGN,
 2568      %ENDIF;
 2569              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=ALGN,LAST=",");
 2570      /*K* BLKHDR.LEV - UBIN BYTE.
 2571      Contains TERMINAL_ID_LEV_CHAN# meaning that this portion of the line
 2572      profile represents a terminal device.
 2573      */
 2574      /*K* BLKHDR.NSUBS - UBIN BYTE.
 2575      .xeq KL_SUPER_C KL_BLKHDR NSUBS
 2576      */
 2577      /*K* BLKHDR.LEN - UBIN WORD.
 2578      .xeq KL_SUPER_C KL_BLKHDR LEN
 2579      */
 2580      /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2581      Contains KLTY_STRM# to identify this piece of the line profile.
 2582      identifiers for BLKTYP are listed under the description of
 2583      KL_BLKHDR.BLKTYP.
 2584      */
 2585      /*K* BLKHDR.PROOFFSET - UBIN BYTE.
 2586      .xeq KL_SUPER_C KL_BLKHDR PROOFFSET
 2587      */
 2588          %IF NOT (MODE_FEP);
 2589            %(LVL+1) * BIT(1) UNAL %INIT('0'B) %CHARTEXT ('/**/'),
 2590          %ENDIF;
 2591            %(LVL+1) SLAVE# BIT(2) UNAL %INIT(SLAVE)%CHARTEXT('/**/'),
 2592      /*K* SLAVE# - BIT(2).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         75   
 2593           If set to 1, means the host is to send the initial bid and
 2594           possibly the logon string for the line.
 2595      */
 2596            %(LVL+1) * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/'),
 2597            %(LVL+1) * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2598            %(LVL+1) RLS# CHAR(80) UNAL %INIT(RLS)%CHARTEXT('/**/'),
 2599      /*K* RLS# - CHAR(80).
 2600           Contains the remote logon string which is to be sent to a remote
 2601           master site in order to identify the CP-6 system as a HASP
 2602           terminal.
 2603      */
 2604            %(LVL+1) * UBIN(%(18-(BITBIN(MODE_FEP)*2))) UNAL %INIT(0)%CHARTEXT('/**/');
 2605      %MEND;
 2606
 2607
 2608      /*F* NAME: KL_LNK_ - X.25 Line Level LINK Definition
 2609
 2610      The KL_LNK macro defines the structure for the line
 2611      level LINK definition.
 2612      */
 2613
 2614      %MACRO KL_LNK (NAME=KL_LNK,
 2615                       LAST=";",
 2616                      STCLASS=BASED,
 2617                      LVL=1,
 2618                      VCPRO = '$VIRCIR',
 2619                      ALGN=WALIGNED);
 2620
 2621       %LSET LISTDIR='0'B;
 2622       %LSET LISTEXP='1'B;
 2623       %LSET LISTCOM='0'B;
 2624       %LSET LISTSUB='1'B;
 2625       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2626       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2627       (SUBSTR(STR,0,8)='CONSTANT') OR
 2628       (SUBSTR(STR,0,3)='EXT');
 2629       %LSET INIT=CHARTEXT('INIT');
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         76   
 2630       %LSET ENIT=CHARTEXT(' ');
 2631       %ELSE;
 2632       %LSET INIT=CHARTEXT('/*');
 2633       %LSET ENIT=CHARTEXT('*/');
 2634       %ENDIF;
 2635      %LSET LEVP1=%(LVL+1);
 2636
 2637      %IF LVL=1;
 2638      DCL 1 NAME STCLASS ALGN,
 2639      %ELSE;
 2640            %LVL NAME ALGN,
 2641      %ENDIF;
 2642              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=ALGN,LAST=",");
 2643        /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2644             Contains KLTY_LINK# to identify this piece of the line profile.
 2645        */
 2646        /*K* BLKHDR.LEV - UBIN BYTE.
 2647             Contains TERMINAL_ID_LEV_CHAN# to identify the level of this
 2648             portion of the line profile.
 2649        */
 2650        /*K* BLKHDR.PROOFFSET - UBIN BYTE.
 2651             .xeq KL_SUPER_C KL_BLKHDR PROOFFSET
 2652        */
 2653            %(LVL+1) ADR,       /* ADDRESS FOR LINK */
 2654            %(LVL+2) LNG# UBIN BYTE UNAL,  /* COUNT FOR ADDRESS */
 2655            %(LVL+2) ADR(0:6),
 2656      /*K* ADR - ARRAY(0:6).
 2657           Comprises 14 binary code digit address of the link.
 2658           Array elements are in the following format:
 2659           .spf
 2660           .fif
 2661              BCD1# UBIN(4)
 2662              BCD2# UBIN(4)
 2663           .fin
 2664      */
 2665      %IF   NOT(MODE_FEP);
 2666            %(LVL+3) * UBIN(1) UNAL,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         77   
 2667      %ENDIF;
 2668            %(LVL+3) BCD1# UBIN(4) UNAL,
 2669      /*K* BCD1# - UBIN(4).
 2670           Specifies the closed user group identifier (in binary coded decimal).
 2671      */
 2672            %(LVL+3) BCD2# UBIN(4) UNAL,
 2673      /*K* BCD2# - UBIN(4).
 2674           Specifies the closed user group identifier (in binary coded decimal).
 2675      */
 2676        %IF NOT (MODE_FEP);
 2677            %(LVL+1) LIC UBIN(18) UNAL %INIT(1)%ENIT,
 2678           %ELSE ;
 2679            %(LVL+1) LIC UBIN(16) UNAL %INIT(1)%ENIT,
 2680           %ENDIF;
 2681
 2682           %IF NOT (MODE_FEP);
 2683            %(LVL+1) HIC UBIN(18) UNAL %INIT(4095)%ENIT,
 2684           %ELSE ;
 2685            %(LVL+1) HIC UBIN(16) UNAL %INIT(4095)%ENIT,
 2686           %ENDIF;
 2687
 2688           %IF NOT (MODE_FEP);
 2689            %(LVL+1) LOC UBIN(18) UNAL %INIT(1)%ENIT,
 2690           %ELSE ;
 2691            %(LVL+1) LOC UBIN(16) UNAL %INIT(1)%ENIT,
 2692           %ENDIF;
 2693
 2694           %IF NOT (MODE_FEP);
 2695            %(LVL+1) HOC UBIN(18) UNAL %INIT(4095)%ENIT,
 2696           %ELSE ;
 2697            %(LVL+1) HOC UBIN(16) UNAL %INIT(4095)%ENIT ,
 2698           %ENDIF;
 2699           %IF NOT (MODE_FEP);
 2700            %(LVL+1) * BIT(1) UNAL %INIT('0'B)%ENIT,
 2701           %ENDIF;
 2702            %(LVL+1) MODE# UBIN(1) UNAL %INIT(0)%ENIT,
 2703      /*K* MODE# - UBIN(1).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         78   
 2704           Specifies the mode.  EQUate identifiers for MODE# are listed in
 2705           the following table.
 2706           ..::TB "^\Identifier\#10\Meaning\#"
 2707           .xeq KL_SUPER_C KLX25_MOD_E KLX25_MOD_DCE#
 2708           .xeq KL_SUPER_C KLX25_MOD_E KLX25_MOD_DTE#
 2709           ..::TB
 2710      */
 2711            %(LVL+1) * UBIN(7) UNAL %INIT(0)%ENIT,
 2712            %(LVL+1) DFLTVCPRO,
 2713      %IF   VCPRO=' ';
 2714      %SET PROCNT = CHARTEXT('0');
 2715      %ELSE;
 2716      %SET PROCNT = CHARTEXT(BINCHAR(LENGTHC(VCPRO)));
 2717      %ENDIF;
 2718            %(LVL+2) CNT UBIN BYTE UNAL %INIT(%PROCNT)%ENIT,
 2719      /*K* DFLTVCPRO.CNT - UBIN BYTE.
 2720      Contains the length of the default profile name.*/
 2721            %(LVL+2) TXT CHAR(11) UNAL %INIT(VCPRO)%ENIT,
 2722      /*K* DFLTVCPRO.TXT - CHAR(11).
 2723      Contains the default profile name.*/
 2724        %IF (MODE_FEP);
 2725            %(LVL+1) * UBIN(8) UNAL %INIT(0)%ENIT,
 2726             %ELSE;
 2727            %(LVL+1) * UBIN(9) UNAL %INIT(0)%ENIT,
 2728             %ENDIF;
 2729            %(LVL+1) DEST ,
 2730            %(LVL+2) LEN UBIN BYTE CALIGNED %INIT(0)%ENIT,
 2731      /*K* LEN - UBIN BYTE.
 2732           Contains the length of the following address, including a count
 2733           for AFI and TYPE, one count for each BCD digit in an X121 type
 2734           address, plus one count for each BCD digit in the DSP portion of
 2735           of the X121 address.
 2736      */
 2737
 2738            %(LVL+2) ADR(0:6),
 2739        %IF NOT(MODE_FEP);
 2740            %(LVL+3) * UBIN(1) UNAL %INIT(0*0)%ENIT,
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         79   
 2741                   %ENDIF;
 2742            %(LVL+3) BCD0 UBIN(4) UNAL %INIT(0*0)%ENIT,
 2743            %(LVL+3) BCD1 UBIN(4) UNAL %INIT(0*0)%ENIT,
 2744            %(LVL+1) QOS# UBIN BYTE UNAL %INIT(2)%ENIT,
 2745      /*K* QOS# - UBIN BYTE.
 2746           Specifies the Quality of Service for this virtual circuit.
 2747           The range is for QOS# is 2 to 255.  The default is 2.
 2748      */
 2749        %IF (MODE_FEP);
 2750            %(LVL+1) * UBIN(8) UNAL %INIT(0)%ENIT LAST
 2751             %ELSE;
 2752            %(LVL+1) * UBIN(9) UNAL %INIT(0)%ENIT LAST
 2753             %ENDIF;
 2754      %MEND;
 2755
 2756
 2757      /*F* NAME: KL_HASPDEV - HASP Subdevice Definition
 2758
 2759      The KL_HASPDEV macro defines the structure for a HASP subdevice.
 2760      */
 2761
 2762      %MACRO KL_HASPDEV (NAME=KL_HASPDEV,
 2763                      STCLASS=BASED,
 2764                      LVL=1,
 2765                      ALGN=WALIGNED);
 2766
 2767       %LSET LISTDIR='0'B;
 2768       %LSET LISTEXP='1'B;
 2769       %LSET LISTCOM='0'B;
 2770       %LSET LISTSUB='1'B;
 2771       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2772       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2773       (SUBSTR(STR,0,8)='CONSTANT') OR
 2774       (SUBSTR(STR,0,3)='EXT');
 2775       %LSET INIT=CHARTEXT('INIT');
 2776       %ELSE;
 2777       %LSET INIT=CHARTEXT('/*');
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         80   
 2778       %ENDIF;
 2779      %LSET LEVP1=%(LVL+1);
 2780
 2781      %IF LVL=1;
 2782      DCL 1 NAME STCLASS ALGN,
 2783      %ELSE;
 2784            %LVL NAME ALGN,
 2785      %ENDIF;
 2786      /*K* BLKHDR.BLKTYP - UBIN BYTE.
 2787      Contains KLTY_SDEV#, meaning that this piece of the line profile
 2788      represents a terminal type SYNC device.
 2789      */
 2790      /*K* BLKHDR.LEV - UBIN BYTE.
 2791      Contains TERMINAL_ID_LEV_SUBCHAN# to indicate that this portion
 2792      of the line profile represents a subdevice.
 2793      */
 2794      /*K* BLKHDR.USE - UBIN BYTE.
 2795      .xeq KL_SUPER_C KL_BLKHDR USE
 2796      */
 2797              %KL_BLKHDR (NAME=BLKHDR,LVL=LEVP1,STCLASS=STCLASS,ALGN=ALGN,LAST=",");
 2798      /*K* TERMID.TTYP - OPTION.
 2799      Contains KLTY_SDEV# to indicate that this is a terminal type SYNC device
 2800      (sub-device).
 2801      */
 2802      /*K* TERMID.LEV - UBIN BYTE.
 2803      Contains TERMINAL_ID_LEV_SUBCHAN# to indicate that this is a subdevice definition.
 2804      */
 2805      /*K* TERMID.TERM.CHANNEL - VALUE-DEC(0-65535).
 2806      .xeq KI_CP6_C B$TERMINAL_ID TERM.CHANNEL
 2807      */
 2808      /*K* TERMID.TERM.SUBDEVICE - VALUE-DEC(0-65535).
 2809      .xeq KI_CP6_C B$TERMINAL_ID TERM.SUBDEVICE
 2810      */
 2811      /*K* TERMID.TERM.SUBSUBDEVICE - VALUE-DEC(0-65535).
 2812      Is not meaningful for HASP subdevices.
 2813      */
 2814      /*K* TERMID.TERM.TERM_NAME - VALUE-CHAR(8).
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         81   
 2815      .xeq KI_CP6_C B$TERMINAL_ID TERM.TERM_NAME
 2816      */
 2817      /*K* TERMID.TERMID - VALUE-CHAR(14).
 2818      Is not meaningful for HASP subdevices.
 2819      */
 2820            %B$TERMINAL_ID (FPTN=TERMID,LVL=LEVP1,STCLASS=STCLASS,ALGN=CALIGNED,LAST=",");
 2821      /*K* DADR.DEVNUM# - BIT(8).
 2822      .xeq KL_SUPER_C KL_DADR DEVNUM#
 2823      */
 2824      /*K* DADR.SDNUM# - BIT(8).
 2825      .xeq KL_SUPER_C KL_DADR SDNUM#
 2826      */
 2827      /*K* DADR.DEVCTL - BIT(16).
 2828      .xeq KL_SUPER_C KL_DADR DEVCTL
 2829      */
 2830            %KL_DADR (NAME=DADR,LVL=LEVP1,STCLASS=STCLASS,LAST=";");
 2831      %MEND;
 2832
 2833
 2834      /*F* NAME: KL_NETWORK
 2835
 2836      The KL_NETWORK macro defines a network connection.
 2837      */
 2838
 2839      %MACRO KL_NETWORK (FPTN=KL_NETWORK,
 2840                          DESTNODE=0,
 2841                          QOS=1,
 2842                          STCLASS=STATIC,
 2843                          ALGN=ALIGNED,
 2844                          LVL=1);
 2845
 2846       %LSET LISTDIR='0'B;
 2847       %LSET LISTEXP='1'B;
 2848       %LSET LISTCOM='0'B;
 2849       %LSET LISTSUB='1'B;
 2850       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2851       %IF (SUBSTR(STR,0,6)='STATIC') OR
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         82   
 2852       (SUBSTR(STR,0,8)='CONSTANT') OR
 2853       (SUBSTR(STR,0,3)='EXT');
 2854       %LSET INIT=CHARTEXT('INIT');
 2855       %LSET EINIT=CHARTEXT('');
 2856       %ELSE;
 2857       %LSET INIT=CHARTEXT('/*');
 2858       %LSET EINIT=CHARTEXT('*/');
 2859       %ENDIF;
 2860
 2861      %IF LVL=1;
 2862      DCL 1 FPTN STCLASS ALGN,
 2863      %ELSE;
 2864           %(LVL) FPTN ALGN,
 2865      %ENDIF;
 2866
 2867                %(LVL+1) %CHARTEXT('DESTNODE') UBIN BYTE CALIGNED %INIT(DESTNODE)%EINIT,
 2868                %(LVL+1) %CHARTEXT('QOS') UBIN BYTE CALIGNED %INIT(QOS)%EINIT,
 2869                %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%EINIT,
 2870                %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%EINIT;
 2871
 2872      %MEND;
 2873
 2874
 2875      /*F* NAME: KL_SETUP_CHR
 2876
 2877      */
 2878
 2879      %MACRO KL_SETUP_CHR (NAME=KL_SETUP_CHR,
 2880                           SIZE# = 0,
 2881                           TYPE# = %KV_PRMID_SETUP_CHR,
 2882                           STCLASS=BASED);
 2883
 2884      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2885      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2886          (SUBSTR(STR,0,8)='CONSTANT') OR
 2887          (SUBSTR(STR,0,3)='EXT');
 2888
14:50 JUL 28 '97 KL_SUPER_C.:E05SI                                         83   
 2889      DCL 1 NAME STCLASS,
 2890            2 TYPE UBIN BYTE UNAL INIT (TYPE#),
 2891            2 SIZE UBIN BYTE UNAL INIT (SIZE#);
 2892
 2893      %ELSE;
 2894      DCL 1 NAME STCLASS,
 2895            2 TYPE UBIN BYTE UNAL,
 2896            2 SIZE UBIN BYTE UNAL,
 2897            2 CHRS (0:0) REDEF SIZE UNAL,
 2898              3 NUM SBIN BYTE UNAL;
 2899
 2900      %ENDIF;
 2901      %MEND;

