/*M* CMLOAD_SI61 - PL-6 source file for the CMLOAD program         */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           .*A*
 
The CMLOAD program is used to examine and load firmware in the
IPC-IPI channels and CMs associated with MDS disks.
 
.*B*
For additional information, enter:
 
.       HELP (CMLOAD) INVOKING
.       HELP (CMLOAD) COMMANDS
.       HELP (CMLOAD) TOPICS
                                                                   */
/*F*
NAME:           INVOCATION INVOKE INVOKING SYNTAX
 
Syntax:
 
!CMLOAD.X
 
.*B*            PARAMETERS  options
Parameters:     None
 
.*B*            DESCRIPTION
Description:
 
The CMLOAD program is used to READ the CM firmware tape into memory,
LOAD the CM firmware into CM(s), and REPORT the configuration of
the IPC-IPI channel or the MDS disk subsystem.
 
.*B*
The READ command is used to read the CM firmware tape into memory.
The firmware must be read into memory before it can be loaded into
the CM(s) on the MDS disk subsystem.
 
.*B*
The LOAD command is used to load the CM firmware into the selected
CM.  The READ command must have been used prior to using the LOAD
command.  The load command must be repeated for each CM connected
to the disk controller (DCnn).
 
.*B*
The REPORT command is used to report the configuration of either
IPC-IPI channel or the entire MDS disk subsystem.  This command
can be used to determine the current IPC-IPI configuration and
the CM and device numbers attached to the IPC-IPI.
 
.*K*            ENVIRONMENT
Environment:
 
The CMLOAD program runs as a user program.  It requires the EXMM,
IOQ, IOQw, and TND privileges.
 
For the REPORT command, nothing needs to be partitioned.  For the
LOAD command, the controller MUST BE partitioned, but the channels
to the controller MUST NOT BE partitioned.
 
.*K*            INPUT
Input:
 
The input to the CMLOAD program is CMLOAD commands and the CM firmware
tape.  The CM firmware tape is distributed to CP-6 sites as a free form
(i.e., unlabeled) tape.  The contents of the CM firmware tape can be
copied to a disk file using the following PCL command:
 
   COPY FT#CM3(DEOD) TO filename
 
This file can then be optionally used as input to CMLOAD.
 
.*K*            OUTPUT
Output:
 
The CMLOAD program loads the firmware into the CM controller.
The CMLOAD programs also produces reports on the users terminal.
 
.*K*            DCBS
DCBS:
 
The CMLOAD program uses the following DCBS:
 
DCB             Usage:
-----           ---------------------------
F$FIRMWARE      To read CM firmware tape.
F$IOQ           To do M$IOQ requests.
F$TDIO          To do T&D IO requests.
M$DO            To output error messages.
M$LM            To get run unit name.
M$LO            To output reports and messages.
M$ME            To output the greeting.
M$SI            To read commands.
 
.*K*            INSTALLATION
Installation:
 
The CMLOAD processor can be installed in any account. The CMLOAD_CRU
batch job can be used to install the processor and its related files
from the source account into any other (or the same) account.  The
following files must be installed in the same account as the CMLOAD
run unit for proper operation of this processor:
 
.        File Name          Description
.        ---------          ------------------------------------
.        HELP:CMLOAD:       Help file
.        CMLOAD             Run unit
.        CMLOAD:ERRMSG:     Error message file
 
.*K*            OWNER
Owner:  Janice Bittner, Gordon Guenthner, Kirk Dixon,LADC
 
.*K*            XINDEX
CMLOAD.X
AID = SUPPORT
AID = SYSTEM MANAGEMENT
AID = UTILITY
.*K*            XINDEX_ABSTRACT
TOOL = CMLOAD
 
A tool to load firmware in MDS disk Control Modules (CMs).
.*K*            CHANGES Changes changes
910903
.*R*
Changed the LOAD command so that only one CM could be loaded at once.
This change was required because (1) LADC did not have more than
one CM cabinet to do testing of CM firmware loading, and (2) a
customer found that loiading multiple CMs with a single LOAD command
did not work. (Star #40592).  So now a LOAD command must be repeated
for each CM connected to a disk controller (DCnn).
Version changed to A03.
.*B*
901220
.*R*
Added checks to determine whether all channels to controller are
partitioned.  If all channels are partitioned, no I/O operations
are possible.  An error message is output to report this condition.
(Star #40586).
Version changed to A02.
.*B*
901217
.*R*
Fixed problem of CMLOAD not recognizing MDS disk cabinets with
less than 8 drives as being configured.  (Star #40583).
Version changed to A01.
.*R*
891207
.*R*
Submitted CMLOAD to LADC X account.  Version A00.
.*R*
890814
.*R*
Began developing the CMLOAD program.
 
                                                                   */
        %EJECT ;
/*M* TCM$MAIN - Main procedure for CMLOAD program.                 */
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCM$MAIN
 
                                                                   */
/*D*
NAME:           TCM$MAIN
 
CALL:           None.
 
PARAMETERS:     None.
 
DESCRIPTION:
 
The TCM$MAIN procedure is the main procedure for the CMLOAD program.
TCM$MAIN controls the execution of the CMLOAD program. TCM$MAIN
calls other procedures to initialize the CMLOAD program, to calculate
the deferred time, to output the deferred time, and to exit the
CMLOAD program.
 
REFERENCE:      CP-6 Host Library Services Reference Manual
                CP-6 Host Monitor Services Reference Manual
                CP-6 Programmer Reference Manual
                MDS EPS-1 (58014370)
                MDS PS FOR DRIVES (64400400)
                MDS PS FOR CM (***?????****)
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCM$MAIN:       PROC MAIN ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCI$INIT          ENTRY ALTRET ;
        DCL 1 TCC$COMMANDS      ENTRY ALTRET ;
        DCL 1 TCQ$QUIT          ENTRY ;
        DCL 1 TCY$XCONREST         ENTRY ;
        %INCLUDE                XUG_ENTRY ;
/********************** PROCEDURE **********************************/
/*
Initialize the CMLOAD program variables, DCBs, and library service
routines.  If the procedure ALTRETURNs, go to abort the program.
                                                                   */
        CALL TCI$INIT                           ALTRET ( RESET ) ;
/*
Read and process commands entered by the user.
                                                                   */
        CALL TCC$COMMANDS                       ALTRET ( RESET ) ;
/*
Reset user environment and exit control.
                                                                   */
RESET:  CALL TCY$XCONREST ;
/*
Exit the program.
                                                                   */
        CALL TCQ$QUIT ;
        END TCM$MAIN ;
        %EOD ;
/*M* TCB$BLOCK_DATA - Data definition procedure for CMLOAD program. */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCB$BLOCK_DATA
 
PURPOSE:        To define all external data definitions.
                                                                   */
/*D*
NAME:           TCB$BLOCK_DATA
 
CALL:           Not allowed.
 
PARAMETERS:     None.
 
DESCRIPTION:
 
THe TCB$BLOCK_DATA procedure is a noncallable procedure that
defines all DCB definitions/references, external procedure
references, and external data definitions/references.  Documentation
for all of these definitions/references is taken from the
TCB$BLOCK_DATA procedure.  The documentation for these definitions/
references are not repeated elsewhere in the CMLOAD program.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCB$BLOCK_DATA:         PROC ;
/********************** INCLUDE FILES ******************************/
/*B*
CP_6            is a PL-6 INCLUDE file that defines the CP-6
        macros.
                                                                   */
        %INCLUDE                CP_6 ;
/*B*
CMLOAD_C62  is a PL-6 INCLUDE file that defines the error codes
        for the CMLOAD program.
                                                                   */
        %INCLUDE                CMLOAD_C62 ;
/*B*
CMLOAD_C63  is a PL-6 INCLUDE file that defines the macros
        for the CMLOAD program.
                                                                   */
        %INCLUDE                CMLOAD_C63 ;
/*B*
XU_MACRO_C      is a PL-6 INCLUDE file that defines the macros for
        the XUG library services.
                                                                   */
        %INCLUDE                XU_MACRO_C ;
/*B*
N_FC_C          is a PL-6 INCLUDE file that defines the values for
        the function code for the M$IOQ monitor services.
                                                                   */
        %INCLUDE        N_FC_C ;
/*B*
TD$STRUCT       is a PL-6 INCLUDE file that defines the macros that
        define the structure of the records in the :CONFIG.:SYS file.
                                                                   */
        %INCLUDE        TD$STRUCT ;
/********************** DCB DEFINITIONS ****************************/
/********************** DCB REFERENCES *****************************/
/*B*
F$FIRMWARE      is the DCB that is used to read the CM firmware tape.
                                                                   */
        DCL 1 F$FIRMWARE        DCB ;
/*B*
F$IOQ           is the DCB that is used to do M$IOQ requests.
                                                                   */
        DCL 1 F$IOQ             DCB ;
/*B*
F$TDIO          is the DCB that is used to do T&D IO requests.
                                                                   */
        DCL 1 F$TDIO            DCB ;
/*B*
M$DO            is the DCB that is used to print error messages.
                                                                   */
        DCL 1 M$DO              DCB ;
/*B*
M$LM            is the DCB that is used to get the run unit name.
                                                                   */
        DCL 1 M$LM              DCB ;
/*B*
M$LO            is the DCB that is used to print reports.
                                                                   */
        DCL 1 M$LO              DCB ;
/*B*
M$ME            is the DCB that is used to print the greeting.
                                                                   */
        DCL 1 M$ME              DCB ;
/*B*
M$SI            is the DCB that is used to read commands.
                                                                   */
        DCL 1 M$SI              DCB ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
/********************** EXTERNAL DATA DEFINITIONS ******************/
/*B*
B$TCB$          is an external pointer to the B$TCB structure.
                                                                   */
        DCL 1 B$TCB$            PTR SYMREF ;
/*
TCC#COMMANDS    is a structure built by PARTRGE for commands
        accepted by the CMLOAD program.
                                                                   */
        DCL 1 TCC#COMMANDS      UBIN SYMREF ;
/*B*
TCM_X_ACCT      is a flag indicating whether or not X account conventions
        are being followed.  If set, the run unit will reside in the X
        account and the error messages will be merged into the run unit.
                                                                    */
        DCL 1 TCM_X_ACCT        BIT(1) STATIC SYMDEF INIT('1'B);
/*B*
TCM_PIT         is the structure that is used to control the
        execution of the CMLOAD program.
                                                                   */
        %TCM_PIT                ( FPTN = TCM_PIT
                                , STCLASS = "STATIC SYMDEF"
                                , ERRFID = TCM_ERRFID
                                , RUFID = TCM_RUFID
                                                                ) ;
/*B*
XUG_GETCMD      is a XUG_GETCMD structure that is used with the
        XUG library services to read commands and report errors.
                                                                   */
        %XUG_GETCMD             ( NAME = XUG_GETCMD
                                , STCLASS = "STATIC SYMDEF"
                                , DCB_PARAM = M$DO
                                , DCB2_PARAM = M$LO
                                , DISP = 0
                                , ERRMFID = TCM_ERRFID
                                , INDCB = NIL
                                , NODES = TCC#COMMANDS
                                , OUTDCB = M$ME
                                , PROMPT = PROMPT
                                , PROMPT_VFC = NO
                                                                ) ;
/*B*
XUG_INIT        is a XUG_INIT structure that is used in the call
        to the XUG$INIT procedure to initialize the XUG library
        services.
                                                                   */
        %XUG_INIT               ( NAME = XUG_INIT
                                , STCLASS = "STATIC SYMDEF"
                                , ALWAYS_SET_PROMPT = NO
                                , COMMANDS = YES
                                , ECHO = HONOR_FLAG
                                , GOODCMD = YES
                                , PP_DCB = NIL
                                , PREPROCESS = YES
                                , PREPROCESSOR = NIL
                                , SPELLING = YES
                                , WORK = NIL
                                , WSEG = 0
                                                                ) ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*B*
TCM_ERRFID      is a VLP_NAME structure that contains the fid
        of the error message file.
                                                                   */
        %VLP_NAME               ( FPTN = TCM_ERRFID
                                , STCLASS = STATIC
                                , LEN = 59
                                                                ) ;
/*B*
TCM_RUFID       is a VLP_NAME structure that contains the fid
        of the run unit file.
                                                                   */
        %VLP_NAME               ( FPTN = TCM_RUFID
                                , STCLASS = STATIC
                                , LEN = 59
                                                                ) ;
/*B*
PROMPT          is a CHAR variable that contains the prompt
        that is presented to the user when reading commands.
                                                                   */
        DCL 1 PROMPT            CHAR(0) CALIGNED CONSTANT
                                INIT('CMLOAD???:  ') ;
/*
Return statement was added because of confusion in DELTA when
trying to debug the program.  Without the return statement,
DELTA overlaid the schema for the TCB$BLOCK_DATA procedure
with the TCI$INIT procedure.  Hence, debugging of the TCI$INIT
procedure was virtually impossible.  When the return statement
was added, the problem went away.
                                                                   */
        RETURN ;
        END TCB$BLOCK_DATA ;
        %EOD ;
/*M* TCC$COMMANDS - Command processing procedure.                  */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCC$COMMANDS
 
PURPOSE:        To process the commands that are entered.
                                                                   */
/*D*
NAME:           TCC$COMMANDS
 
CALL:           CALL TCC$COMMANDS  ALTRET ( error ) ;
 
PARAMETERS:
                                                                   */
/*K*
error           is a statement label to which TCC$COMMANDS will
        make an altreturn if an error is detected.
                                                                   */
/*D*
DESCRIPTION:
 
The TCC$COMMANDS procedure processes commands as they are entered.
The TCC$COMMANDS procedure sets flags and values in the
TCM_PIT structure based upon the commands that are processed.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCC$COMMANDS:   PROC  ALTRET ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XU_MACRO_C ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
        DCL 1 TCL$LOAD          ENTRY ;
        DCL 1 TCN$NOT_IMPLEMENTED ENTRY(3) ;
        DCL 1 TCP$REPORT        ENTRY ;
        DCL 1 TCR$RESET         ENTRY ;
        DCL 1 TCT$READ          ENTRY ;
        %INCLUDE                XUG_ENTRY ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %B$ALT ;
        %B$TCB                  ( NAME = B$TCB
                                , STCLASS = "BASED(B$TCB$)"
                                                                ) ;
        DCL 1 B$TCB$            PTR SYMREF ;
        DCL 1 TCC#COMMANDS       UBIN SYMREF ;
        %TCM_PIT ;
        %XUG_GETCMD             ( NAME = XUG_GETCMD
                                , STCLASS = SYMREF
                                                                ) ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*
ERRTEXT         is a structure that defines the substitution values
        for the error messages.  The entries in
        this structure are of the form ERRTEXT.nnnnnn and
        ERRTEXT.nnnnnn_ where "nnnnnn" is the name of an option
        accepted by the TOOL program. The ERRTEXT.nnnnnn entries
        are TEXTC constants.  The ERRTEXT.nnnnnn_ entries are
        VECTOR constants framing the appropriate TEXTC constant.
        The vector entries are passed to the error message routine
        as vector framing the substitution character strings.
                                                                   */
        %TCM_ERRTEXT            ( FPTN = command, FIRST = YES
                                , LAST = YES ) ;
/*
OUT$BLK         is a structure that is used to represent the
        X$PARSE output for literals, concatenation, alternatives,
        lists, and end-of-text.
                                                                   */
        %PARSE$OUT              ( NAME = OUT$BLK
                                , STCLASS = "BASED(XUG_GETCMD.OUT$)"
                                                                ) ;
/*
OUT$SYM         is a structure that is used to represent the
        X$PARSE output for symbols, delimited strings, etc.
                                                                   */
        %PARSE$SYM              ( NAME = OUT$SYM
                                , STCLASS = "BASED(XUG_GETCMD.OUT$)"
                                                                ) ;
/*
TEXTC           is a based VLP_NAMEV structure that is used to
        convert the values specified with some options from
        character to binary.
                                                                   */
        %VLP_NAMEV              ( FPTN = TEXTC
                                , STCLASS = BASED
                                                                ) ;
/********************** PROCEDURE **********************************/
/*
Loop until the TCM_PIT.QUIT# flag is set.
                                                                   */
        TCM_PIT.FLAGS.QUIT# = %NO# ;
        DO WHILE ( TCM_PIT.FLAGS.QUIT# = %NO# ) ;
/*
Get the next command from the user.  XUG$GETCMD will not return
until a good command has been received.
                                                                   */
            CALL XUG$GETCMD ( XUG_GETCMD )
            WHENALTRETURN DO ;
                CALL TCE$ERRMSG ( XUG_GETCMD.ERR#, XUG_GETCMD.ERRDCB# ) ;
                ALTRETURN ;
                END ;
/*
Process the command that was just read and parsed.
                                                                   */
            DO  CASE  ( OUT$BLK.CODE ) ;
 
            CASE ( TCC#LOAD ) ;         /***    LOAD COMMAND     ***/
                CALL TCL$LOAD ;
 
            CASE ( TCC#READ ) ;         /***    READ COMMAND     ***/
                CALL TCT$READ ;
 
            CASE ( TCC#REPORT ) ;       /***    REPORT COMMAND   ***/
                CALL TCP$REPORT ;
 
 
            CASE ( TCC#RESET ) ;         /***    RESET COMMAND    ***/
                CALL TCR$RESET ;
            CASE ( TCC#END ) ;          /***    END COMMAND      ***/
                TCM_PIT.FLAGS.QUIT# = '1'B ;
 
            CASE ( ELSE ) ;
NOT_IMPLEMENTED: CALL TCN$NOT_IMPLEMENTED ( ADDR ( TCC#COMMANDS ),
                                            XUG_GETCMD.OUT$,
                                            ERRTEXT.COMMAND_    ) ;
                END /* DO CASE */ ;
            END /* DO WHILE */ ;
/*
Return to calling procedure.
                                                                   */
        RETURN ;
 
        END TCC$COMMANDS ;
        %EOD ;
/*M* TCE$ERRMSG - Error message processing procedure.              */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCE$ERRMSG
 
PURPOSE:        To output error messages.
                                                                   */
/*D*
NAME:           TCE$ERRMSG
 
CALL:           CALL TCE$ERRMSG ( errcode, [errdcb#], [f1_], [f2_],
                                  [f3_], [flag] ) ;
 
PARAMETERS:
                                                                   */
/*K*
errcode         is a VLP_ERRCODE structure that defines the error
        message to be output.
                                                                   */
/*K*
errdcb#         is a UBIN WORD that specifies the DCB number of the
        DCB associated with the error code.
                                                                   */
/*K*
f1_             is a VECTOR that frames the character string that
        is to be used for the U1 substitution parameter.  The
        character string must be in TEXTC format.  The default is NIL.
                                                                   */
/*K*
f2_             is a VECTOR that frames the character string that
        is to be used for the U2 substitution parameter.  The
        character string must be in TEXTC format.  The default is NIL.
                                                                   */
/*K*
f3_             is a VECTOR that frames the character string that
        is to be used for the U3 substitution parameter.  The
        character string must be in TEXTC format.  The default is NIL.
 
                                                                   */
/*K*
flag            is a UBIN WORD that specifies the number of leading
        asterisks that are to be printed before the error message.
        The default is 0.
                                                                   */
/*D*
DESCRIPTION:
 
The TCE$ERRMSG procedure is used to report error messages.
The errcode parameter specifies which error message is to be
reported.  The f1_, f2_, and f3_ parameters specify the
appropriate string substitution vectors (if any).  The flag
parameter specifies the number of leading asterisks (if any).
 
If the severity of the errcode (ERRCODE.SEV) is greater than 0,
TCE$ERRMSG moves the errcode to TCM_PIT.ERRCODE, the severity
to TCM_PIT.STEPCC, and sets TCM_PIT.FLAGS.ERRCODE.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCE$ERRMSG:  PROC ( ERRCODE, ERRDCB#, F1_, F2_, F3_, FLAG ) ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XUG_ENTRY ;
        %INCLUDE                XU_MACRO_C ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %TCM_PIT ;
        %XUG_GETCMD             ( NAME = XUG_GETCMD
                                , STCLASS = SYMREF ) ;
/********************** PARAMETER DEFINITIONS **********************/
        %VLP_ERRCODE            ( FPTN = ERRCODE
                                , STCLASS = PARAM
                                                                ) ;
        DCL 1 ERRDCB#           UBIN WORD ALIGNED PARAM ;
        DCL 1 F1_               VECTOR ALIGNED PARAM ;
        DCL 1 F2_               VECTOR ALIGNED PARAM ;
        DCL 1 F3_               VECTOR ALIGNED PARAM ;
        DCL 1 FLAG              UBIN WORD PARAM ;
/********************** PROCEDURE **********************************/
/*
Move the error code into the XUG_GETCMD structure.  If they have
been specified, move the DCB number, character substitution vectors,
and number of asterisks into the structure so that the error can
be reported correctly.
                                                                   */
        XUG_GETCMD.ERR_CODE = ERRCODE ;
        IF  ADDR ( ERRDCB# ) ~= ADDR ( NIL )  THEN
            XUG_GETCMD.ERRDCB# = ERRDCB# ;
        ELSE
            XUG_GETCMD.ERRDCB# = DCBNUM ( NIL ) ;
        IF  ADDR ( F1_ ) ~= ADDR ( NIL )  THEN
            XUG_GETCMD.F1_ = F1_ ;
        ELSE
            XUG_GETCMD.F1_ = VECTOR ( NIL ) ;
        IF  ADDR ( F2_ ) ~= ADDR ( NIL )  THEN
            XUG_GETCMD.F2_ = F2_ ;
        ELSE
            XUG_GETCMD.F2_ = VECTOR ( NIL ) ;
        IF  ADDR ( F3_ ) ~= ADDR ( NIL )  THEN
            XUG_GETCMD.F3_ = F3_ ;
        ELSE
            XUG_GETCMD.F3_ = VECTOR ( NIL ) ;
        IF  ADDR ( FLAG ) ~= ADDR ( NIL )  THEN
            XUG_GETCMD.FLGLEV# = FLAG ;
        ELSE
            XUG_GETCMD.FLGLEV# = 0 ;
/*
If the severity of the errcode is greater than 0, move the errcode
and severity to TCM_PIT.  Also set the flag to indicate that
an error has been detected.  (Do this before calling XUG$ERRMSG
because ERRCODE may be on the altret stack and XUG$ERRMSG will
change the altret stack.)
                                                                   */
        IF  ERRCODE.SEV > 0  THEN DO ;
            TCM_PIT.ERRCODE = ERRCODE ;
            TCM_PIT.FLAGS.ERRCODE# = %YES# ;
            TCM_PIT.STEPCC# = ERRCODE.SEV ;
            END ;
/*
Call the XUG$ERRMSG routine to report the error message.
                                                                   */
        CALL XUG$ERRMSG ( XUG_GETCMD ) ;
/*
Return to the calling procedure.
                                                                   */
        RETURN ;
        END TCE$ERRMSG ;
        %EOD ;
/*M* TCH$CONFIG - Get hardware configuration information.          */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCH$CONFIG
 
PURPOSE:        To get the hardware configuration information.
                                                                   */
/*D*
NAME:           TCH$CONFIG
 
CALL:           CALL TCH$CONFIG  ALTRET ( error ) ;
 
PARAMETERS:
 
                                                                   */
/*K*
error           specifies a statement label to which TCH$CONFIG will
        make an altreturn if an error is detected.
                                                                   */
/*D*
DESCRIPTION:
 
The TCH$CONFIG procedure is used to get the hardware configuration
information for the TCM_PIT.DCNN.NAME controller.  TCH$CONFIG uses
the TCM_PIB.DCNN information to determine which controller to
interrogate.  The information that TCH$CONFIG gets back from the
controller is placed in the TCM_PIT.CM and TCM_PIT.DEV structures.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCH$CONFIG:             PROC ALTRET ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE        B_SEGIDS_C ;
        %INCLUDE        CP_6 ;
        %INCLUDE        CMLOAD_C62 ;
        %INCLUDE        CMLOAD_C63 ;
        %INCLUDE        N_FC_C ;
        %INCLUDE        NI$TABLES ;
/********************** DCB REFERENCES *****************************/
        DCL 1 F$IOQ              DCB ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %B$ALT ;
        %B$TCB                  ( NAME = B$TCB
                                , STCLASS = "BASED(B$TCB$)"
                                                                ) ;
        DCL B$TCB$              PTR SYMREF ;
        %F$DCB ;
        %TCM_PIT ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*
CM$WORD         is a based structure that is used to define the format
        of the CM word in the configuration table returned by the
        hardware.
                                                                   */
        DCL 1 CM$WORD           BASED(WORD$) ALIGNED,
              2 CLASS           UBIN BYTE CALIGNED,
              2 NUMDEVS         UBIN BYTE CALIGNED,
              2 *               UBIN BYTE CALIGNED,
              2 *               UBIN BYTE CALIGNED ;
/*
DCT$            is a PTR variable that is used to base the DCT
        structures.
                                                                   */
        DCL 1 DCT$              PTR ALIGNED AUTO ;
/*
DEV$WORD        is a based structure that is used to define the format
        of the device words in the configuration table returned by
        the hardware.
                                                                   */
        DCL 1 DEV$WORD          BASED(WORD$) ALIGNED,
              2 STATUS          UBIN BYTE CALIGNED,
              2 TYPE            UBIN BYTE CALIGNED,
              2 FORMAT          UBIN BYTE CALIGNED,
              2 *               UBIN BYTE CALIGNED ;
/*b*
EPROM$WORD      is a based structure that is used to define the
        format of the IPC EPROM word returned by the hardware.
                                                                   */
        DCL 1 EPROM$WORD        BASED(WORD$) ALIGNED,
              2 ID              UBIN BYTE UNAL,
              2 XFRMRID         UBIN BYTE UNAL,
              2 REV             CHAR(2) UNAL ;
/*
FPT_IOQ         is a FPT_IOQ structure that is used to do M$IOQ IO.
                                                                   */
        %FPT_IOQ                ( FPTN = FPT_IOQ
                                , STCLASS = STATIC
                                , BPMIR = YES
                                , BUF = IOQBUF
                                , DCB = F$IOQ
                                , DRELADDR = 0
                                , FC = %N_DCWLIST
                                , WAIT = YES
                                                                ) ;
/*
FPT_MONINFO     is a FPT_MONINFO structure used with the M$MONINFO
        PMME to return information about the monitors pointers.
                                                                   */
        %FPT_MONINFO            ( FPTN = FPT_MONINFO
                                , STCLASS = CONSTANT
                                , MONPTRS = VLR_MONPTRS
                                                                ) ;
/*
FPT_SAD         is a FPT_SAD structure that is used to map the
        user special access descriptor %SPCL1SID onto the monitors
        TIGR descriptor %TIGRSID.
                                                                   */
        %FPT_SAD                ( FPTN = FPT_SAD
                                , STCLASS = CONSTANT
                                , MONSID = %TIGRSID
                                , USERSID = %SPCL1SID
                                                                ) ;
/*B*
FW$WORD         is a based structure that is used to define the format
        of the IPC FW words returned by the hardware.
                                                                   */
        DCL 1 FW$WORD           BASED(WORD$) ALIGNED,
              2 CLASS           UBIN BYTE CALIGNED,
              2 MODEL           UBIN BYTE CALIGNED,
              2 REV             CHAR(2) CALIGNED ;
/*
I               is a SBIN WORD that is used a counter.
                                                                   */
        DCL 1 I                 SBIN WORD ALIGNED AUTO ;
/*
IOQBUF          is a structure that is used as the M$IOQ DCW list
        and buffer.
                                                                   */
        DCL 1 IOQBUF            DALIGNED STATIC,
              %TCM_IDCW         ( NAME = IDCW
                                , LVL = 2 ) ;
              %TCM_DCW          ( NAME = DCW
                                , LVL = 2 ) ;
              2 DATA(0:140)     UBIN WORD ALIGNED ;
/*
J               is a SBIN WORD that is used a counter.
                                                                   */
        DCL 1 J                 SBIN WORD ALIGNED AUTO ;
/*
K               is a SBIN WORD that is used a counter.
                                                                   */
        DCL 1 K                 SBIN WORD ALIGNED AUTO ;
/*
N$DCT$(0:0)     is a PTR array that points to the monitors DCT tables.
                                                                   */
        DCL 1 N$DCT$(0:0)       PTR BASED(N$DCT$$) ;
/*
N$DCT$$         is a PTR variable that points to the monitors N$DCT$
        pointer array.
                                                                   */
        DCL 1 N$DCT$$           PTR ALIGNED AUTO ;
/*
NI$DCT          is a based structure for the monitors DCT table
        entries.
                                                                   */
        %NI$DCT                 ( NAME = DCT
                                , STCLASS = "BASED(DCT$)"
                                                                ) ;
/*B*
TCH#DCT_NOT_FOUND       is a VLP_ERRCODE structure used to report
        the error if TCM_PIT.DPNN.NAME is not found in the monitors
        DCT.DEVNM table entries.
                                                                   */
/*E*
ERROR:  TCH-E$TCM#DCT_NOT_FOUND-7
MESSAGE:  Internal error:  %U1 not found in monitor's DCT table.
                                                                   */
        %VLP_ERRCODE            ( FPTN = TCH#DCT_NOT_FOUND
                                , STCLASS = CONSTANT
                                , ERR# = %E$TCM#DCT_NOT_FOUND
                                , FCG = %TCM#FCG
                                , MID = 'H'
                                , MON = %NO#
                                , SEV = 7
                                                                ) ;
/*B*
TCH#NO_SW_CONFIG        is a VLP_ERRCODE structure used to print
        the "No Software Configuration Done" error message.
                                                                   */
/*E*
ERROR:  TCH-E$TCM#NO_SW_CONFIG-7
MESSAGE:  Internal Error:  Software Configuration has not been done.
MESSAGE1:  The Software Configuration must be successfully done
           before the Hardware Configuration can be done.
                                                                   */
        %VLP_ERRCODE            ( FPTN = TCH#NO_SW_CONFIG
                                , STCLASS = CONSTANT
                                , ERR# = %E$TCM#NO_SW_CONFIG
                                , FCG  = 'H'
                                , MID  = 'H'
                                , MON = %NO#
                                , SEV = 7
                                                                ) ;
/*
VLR_MONPTRS     is a VLR_MONPTRS structure that is used to receive the
        value of the monitors points from the M$MONINFO PMME.
                                                                   */
        %VLR_MONPTRS            ( FPTN = VLR_MONPTRS
                                , STCLASS = STATIC
                                                                ) ;
/*
WORD$           is a PTR variable that is used to base the CM$WORD
        and DEV$WORD structures.
                                                                   */
        DCL 1 WORD$             PTR ALIGNED AUTO ;
        DCL 1 POINTER$          REDEF WORD$,
              2 OFFSET          UBIN(18) UNAL,
              2 SID             UBIN(18) UNAL ;
        %EJECT;
/********************** PROCEDURE **********************************/
/*
Determine if the software configuration of the disk controller has
been obtained.  If not, output an error message and altreturn to the
calling procedure.
                                                                   */
        IF  TCM_PIT.DCNN.NAME = ' '  THEN DO ;
            CALL TCE$ERRMSG ( TCH#NO_SW_CONFIG ) ;
            ALTRETURN ;
            END ;
/*
Find the DCTX entry of this DCNN in the monitor DCT tables.
                                                                   */
        CALL M$MONINFO ( FPT_MONINFO )
        WHENALTRETURN DO ;
MONERR:     CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR ) ;
            ALTRETURN ;
            END ;
        CALL M$SAD ( FPT_SAD )  ALTRET ( MONERR ) ;
        CALL CONVERT$ ( VLR_MONPTRS.N$DCT$$, N$DCT$$ ) ;
        I = 1 ;
        TCM_PIT.DCNN.DCTX = 0 ;
        DO  WHILE  ( TCM_PIT.DCNN.DCTX = 0 ) ;
            CALL CONVERT$ ( N$DCT$(I), DCT$ )
            WHENALTRETURN DO ;
FINDERR:        CALL TCE$ERRMSG ( TCH#DCT_NOT_FOUND, ,
                                  VECTOR ( TCM_PIT.DCNN.NAME ) ) ;
                ALTRETURN ;
                END ;
            IF  TCM_PIT.DCNN.NAME = DCT.DEVNM  THEN
                TCM_PIT.DCNN.DCTX = I ;
            I = I + 1 ;
            END ;
/*
Build the IOQ FPT to do the Read Subsystem Configuration command.
And then call M$IOQ to pass the FPT to the IO system.
                                                                   */
        IOQBUF.IDCW = %IDCWBITS ;
        IOQBUF.IDCW.DC = BITBIN ( '24'O ) ;
        IOQBUF.IDCW.CC = BITBIN ( '21'O ) ;
        IOQBUF.DCW = %IOTDDCW ;
        IOQBUF.DCW.FWA = POFFW ( ADDR(IOQBUF.DATA), ADDR(IOQBUF) );
        IOQBUF.DCW.TALLY = SIZEW ( IOQBUF.DATA ) ;
        FPT_IOQ.V.DLA.DCTX# = TCM_PIT.DCNN.DCTX ;
        CALL M$IOQ ( FPT_IOQ )  ALTRET ( MONERR ) ;
/*
Move the information from the hardware configuration table into
the TCM_PIT structure.
                                                                   */
CM:     DO  I = 0 TO 7 ;
 
            WORD$ = PINCRW ( ADDR(IOQBUF.DATA), I*17 ) ;
 
            IF  CM$WORD = '0'B  THEN DO ;
                TCM_PIT.CM.FLAGS.PRESENT(I) = '0'B ;
                TCM_PIT.CM.CLASS(I)   = 0 ;
                TCM_PIT.CM.NUMDEVS(I) = 0 ;
                END ;
            ELSE DO ;
                TCM_PIT.CM.FLAGS.PRESENT(I) = '1'B ;
                TCM_PIT.CM.CLASS(I)   = CM$WORD.CLASS ;
                TCM_PIT.CM.NUMDEVS(I) = CM$WORD.NUMDEVS ;
                END ;
 
DEV:        DO J = 0 TO 7 ;
 
                WORD$ = PINCRW ( WORD$, 1 ) ;
                K = I * 8 + J ;
 
                IF  DEV$WORD = '0'B  THEN DO ;
                    TCM_PIT.DEV.FLAGS.PRESENT(K) = '0'B ;
                    TCM_PIT.DEV.STATUS(K) = 0 ;
                    TCM_PIT.DEV.TYPE(K)   = 0 ;
                    TCM_PIT.DEV.FORMAT(K) = 0 ;
                    END ;
                ELSE DO ;
                    TCM_PIT.DEV.FLAGS.PRESENT(K) = '1'B ;
                    TCM_PIT.DEV.STATUS(K) = DEV$WORD.STATUS ;
                    TCM_PIT.DEV.TYPE(K)   = DEV$WORD.TYPE ;
                    TCM_PIT.DEV.FORMAT(K) = DEV$WORD.FORMAT ;
                    TCM_PIT.CM.FLAGS.CONFIGED(I) = '1'B ;
                    END ;
 
                TCM_PIT.DEV.FLAGS.CONFIGED(K) = TCM_PIT.DPNN.FLAGS.CONFIGED(K) ;
 
                END DEV ;
            END CM ;
/*********************************************************************
 
NOTE:  The following code will not be implemented until the READ IPC
       Configuration command ('21'O) is implemented in the firmware.
 
Build the IOQ FPT to do the Read IPC Configuration command.
And then call M$IOQ to pass the FPT to the IO system.
 
        IOQBUF.IDCW.DC = BITBIN ( '21'O ) ;
        CALL M$IOQ ( FPT_IOQ )  ALTRET ( MONERR ) ;
 
Move the information from the IPC configuration words into the
TCM_PIT structure.
 
        WORD$ = ADDR ( IOQBUF.DATA ) ;
        TCM_PIT.IPC.EPROM.ID     = EPROM$WORD.ID ;
        TCM_PIT.IPC.EPROM.XFMRID = EPROM$WORD.ID ;
        TCM_PIT.IPC.EPROM.REV    = EPROM$WORD.REV ;
 
        DO  I = 0 TO 1 ;
            WORD$ = PINCRW ( WORD$, 1 ) ;
            TCM_PIT.IPC.FW.CLASS(I) = FW$WORD.CLASS ;
            TCM_PIT.IPC.FW.MODEL(I) = FW$WORD.MODEL ;
            TCM_PIT.IPC.FW.REV(I)   = FW$WORD.REV ;
            END ;
 
********************************************************************/
 
/*
Return to the calling procedure.
                                                                   */
        RETURN ;
        %EJECT ;
/*F*
NAME:           CONVERT$
 
PURPOSE:        To convert a pointer from one SID to another.
 
                                                                   */
/*D*
NAME:           CONVERT$
 
CALL:           CALL CONVERT$ ( in$, out$ ) [ ALTRET ( error ) ] ;
 
PARAMETERS:
                                                                   */
/*K*
in$             specifies the input PTR value.
                                                                   */
/*K*
out$            specifies the output PTR value.
                                                                   */
/*K*
error           specifies a statement label to which CONVERT$ will
        make an altreturn if an error is detected.
                                                                   */
/*D*
DESCRIPTION:
 
The CONVERT$ routine is used to convert pointers from one SID to
another.  In this case, monitor pointers using %TIGRSID are converted
to use the user %SPCL1SID.
                                                                   */
/********************** ENTRY POINT ********************************/
CONVERT$:       PROC ( IN$, OUT$ ) ALTRET ;
/********************** PARAMETERS *********************************/
        DCL 1 IN$               ALIGNED PARAM,
              2 OFFSET          UBIN(24) UNAL,
              2 SID             BIT(12)  UNAL ;
        DCL 1 OUT$              ALIGNED PARAM,
              2 OFFSET          UBIN(24) UNAL,
              2 SID             BIT(12)  UNAL ;
/********************** PROCEDURE **********************************/
/*
If the input pointer has the correct SID, convert it to an output
pointer.  Otherwise, altreturn.
                                                                   */
        IF  IN$.SID ~= %TIGRSID  THEN
            ALTRETURN ;
        ELSE DO ;
            OUT$ = IN$ ;
            OUT$.SID = %SPCL1SID ;
            END ;
 
        RETURN ;
        END CONVERT$ ;
 
END TCH$CONFIG ;
%EOD ;
/*M* TCI$INIT - Initialization procedure for CMLOAD program.       */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCI$INIT
 
PURPOSE:        To initialize the CMLOAD program
                                                                   */
/*D*
NAME:           TCI$INIT
 
CALL:           CALL TCI$INIT ALTRET ( error ) ;
 
PARAMETERS:
                                                                   */
/*K*
error           specifies a statement label to which TCI$INIT will
        make an altreturn if an error is detected.
                                                                   */
/*D*
DESCRIPTION:
 
The TCI$INIT procedure is used to initialize the variables, DCBs,
and library services routines for the CMLOAD program.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCI$INIT:               PROC ALTRET ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                B$JIT ;
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XUG_ENTRY ;
        %INCLUDE                XU_MACRO_C ;
/********************** DCB REFERENCES *****************************/
        DCL 1 M$LM              DCB ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
        DCL 1 TCX$XCON          ENTRY ASYNC ;
        DCL 1 XUF$MERGE_FID     ENTRY(3) ALTRET ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %B$ALT ;
        %B$TCB                  ( NAME = B$TCB
                                , STCLASS = "BASED ( B$TCB$ )"
                                                                ) ;
        DCL 1 B$JIT$            PTR SYMREF ;
        DCL 1 B$TCB$            PTR SYMREF ;
        DCL 1 TCM_X_ACCT        SYMREF BIT(1);
        DCL 1 B_VERSION         UBIN BYTE CALIGNED SYMREF ;
        DCL 1 B_VERSION$        PTR ALIGNED CONSTANT
                                INIT ( ADDR ( B_VERSION ) ) ;
        %F$DCB ;
        DCL 1 TCC#COMMANDS       UBIN SYMREF ;
        %TCM_PIT ;
        %VLP_NAMEV              ( FPTN = TCM$ERRFID
                                , STCLASS = "BASED ( TCM_PIT.ERRFID$ )"
                                                                ) ;
        %VLP_NAMEV              ( FPTN = TCM$NAME
                                , STCLASS = BASED
                                                                ) ;
        %VLP_NAMEV              ( FPTN = TCM$RUFID
                                , STCLASS = "BASED ( TCM_PIT.RUFID$ )"
                                                                ) ;
        %VLP_NAMEV              ( FPTN = TCM$VERSION
                                , STCLASS = "BASED ( B_VERSION$ )"
                                                                ) ;
        %XUG_GETCMD             ( NAME = XUG_GETCMD
                                , STCLASS = SYMREF
                                                                ) ;
        %XUG_INIT               ( NAME = XUG_INIT
                                , STCLASS = SYMREF
                                                                ) ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*
ERRFID          is a VLP_NAME structure that defines the filename
        portion of the error message fid.
                                                                   */
        %VLP_NAME               ( FPTN = ERRFID
                                , STCLASS = CONSTANT
                                , NAME = %TCM#ERRFID
                                                                ) ;
/*
LEN             is a UBIN WORD that is used to return the length
        of the run unit fid.
                                                                   */
        DCL 1 LEN               UBIN WORD STATIC ;
/*
PRIV            is a FPT_PRIV structure used to require the user
        to have EXMM, IOQ, IOQW, and TND privileges.
*/
        %EQU PRIV               = %( PR_IOQ# | PR_IOQW# | PR_TND# | PR_SPCLMM# ) ;
        %FPT_PRIV               ( FPTN = PRIV
                                , STCLASS = CONSTANT
                                , AUTH = YES
                                , PRIV = %PRIV
                                                                ) ;
/*B*
TCI#GREETING            is a VLP_ERRCODE use to print the greeting
        message.
                                                                   */
/*E*
ERROR:  TCI-E$TCM#GREETING-0
MESSAGE0:%U1 %U2 here
                                                                   */
        %VLP_ERRCODE            ( FPTN = TCI#GREETING
                                , STCLASS = CONSTANT
                                , ERR# = %E$TCM#GREETING
                                , FCG = %TCM#FCG
                                , MID = 'I'
                                , MON = %NO#
                                , SEV = 0
                                                                ) ;
/*
UNFID           is a FPT_UNFID structure that is used to convert
        the run unit name in M$LM into a fid in TCM$RUFID.
                                                                   */
        %FPT_UNFID              ( FPTN = UNFID
                                , STCLASS = STATIC
                                , DCB = M$LM
                                , LEN = LEN
                                                                ) ;
/*
XCON_SET        is an FPT_XCON structure that is used to establish
        the exit control procedure for the CMLOAD program. The
        previous exit control procedure (if any) is saved for
        later restoration.
                                                                   */
        %FPT_XCON               ( FPTN = XCON_SET
                                , STCLASS = CONSTANT
                                , PXCON = TCM_PIT.PXCON$$
                                , UENTRY = TCX$XCON
                                                                ) ;
/********************** PROCEDURE **********************************/
/*
Get the fid of the run unit.
                                                                   */
        UNFID.TEXTFID_ = VECTOR ( TCM$RUFID.NAME# ) ;
        CALL M$UNFID ( UNFID )                  ALTRET ( ALTERR ) ;
        TCM$RUFID.L# = LEN ;
/*
Change the error message fid to the current RU account.
                                                                   */
        IF TCM_X_ACCT                      /* CHECK IF WE'RE RUNNING IN THE X ACCT */
           THEN TCM$ERRFID = TCM$RUFID ;
           ELSE CALL XUF$MERGE_FID ( VECTOR ( TCM$ERRFID ),
                             TCM_PIT.RUFID$, ADDR ( ERRFID ) )
                                                ALTRET ( ALTERR ) ;
/*
Initialize the XUG library service routines.  These routines will
be used to report error messages.
                                                                   */
        CALL XUG$INIT ( XUG_GETCMD, XUG_INIT )  ALTRET ( ALTERR ) ;
        CALL XUG$SETERRMSG ( XUG_GETCMD )       ALTRET ( ALTERR ) ;
/*
Output the greeting to the user.
                                                                   */
        CALL TCE$ERRMSG ( TCI#GREETING, ,
                          VECTOR ( ADDR ( DCBADDR ( DCBNUM ( M$LM) ) ->
                                   F$DCB.NAME# ) -> TCM$NAME ),
                          VECTOR ( TCM$VERSION )                ) ;
/*
Establish an exit control procedure fo the CMLOAD program. Set the
flag and pointer to indicate that this has been done.
                                                                   */
        CALL M$XCON ( XCON_SET )                ALTRET ( ALTERR ) ;
        TCM_PIT.FLAGS.XCON# = %YES# ;
/*
Force the user to have IOQ, IOQW, SPCLMM, and TND privileges to
run CMLOAD.
*/
        CALL M$SPRIV ( PRIV )                   ALTRET ( ALTERR ) ;
/*
Return to the calling procedure.
                                                                   */
        RETURN ;
/*
An error has been detected.  Output the error message for the
error code in the altret stack.
                                                                   */
ALTERR: CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR,
                          B$TCB.ALT$ -> B$ALT.DCB# ) ;
/*
Make an altreturn to the calling procedure.
                                                                   */
ERROR:  ALTRETURN ;
        END TCI$INIT ;
        %EOD ;
/*M* TCL$LOAD - Procedure to load firmware into CM controller      */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCL$LOAD
 
PURPOSE:        To load firmware into the CM controller
                                                                   */
/*D*
NAME:           TCL$LOAD
 
CALL:           CALL TCL$LOAD ;
 
PARAMETERS:     None
                                                                   */
/*D*
DESCRIPTION:
 
The TCL$LOAD procedure is called to load firmware into a CM controller.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCL$LOAD:               PROC ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XU_MACRO_C ;
        %INCLUDE                XUG_ENTRY ;
/********************** DCB REFERENCES *****************************/
        DCL F$TDIO               DCB;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL TCE$ERRMSG          ENTRY(6) ;
        DCL TCS$CONFIG          ENTRY(1) ALTRET;
/********************** EXTERNAL DATA REFERENCES *******************/
        DCL B$TCB$               PTR SYMREF;
        %B$TCB                   (NAME=B$TCB,STCLASS="BASED (B$TCB$)");
        %B$ALT;
        %F$DCB;
        %TCM_PIT;
        %XUG_GETCMD              (NAME=XUG_GETCMD,
                                  STCLASS=SYMREF);
        %PARSE$OUT               (NAME=OUT$BLK,
                                  STCLASS= "BASED(XUG_GETCMD.OUT$)");
        %PARSE$SYM               (NAME=OUT$SYM,
                                  STCLASS= "BASED(XUG_GETCMD.OUT$)");
        %EJECT ;
/********************** LOCAL DATA REFERENCES **********************/
        DCL 1 WORD$              PTR ALIGNED;
        DCL 1 PTR$               REDEF WORD$,
            2 OFFSET UBIN(18) UNAL,
            2 SEGID UBIN(18) UNAL;
        DCL IDCW1 BIT(36) ALIGNED;
        DCL IDCW2 BIT(36) ALIGNED;
        DCL I UBIN;
        DCL J UBIN;
        DCL K SBIN WORD ;
        DCL AVAIL_CHANS UBIN;
        DCL DCW$ PTR;            /* POINTER TO DCWLIST */
        DCL PACKET$ PTR;         /* POINTER TO CM PACKET LIST */
        DCL RDBUF$ PTR;          /* POINTER TO CM RESPONSE BUFFER */
        DCL FW$ PTR;             /* POINTER TO FIRMWARE */
        DCL STAT$ PTR;           /* POINTER TO IO STATUS */
        DCL DCB$ PTR;
        DCL CM_COUNT UBIN;       /* COUNT OF CMs TO LOAD */
        DCL 1 CM_NUMBER STATIC,
            2 ASCII CHAR(16) UNAL INIT('0123456789ABCDEF'),
            2 N(0:15) REDEF ASCII CHAR(1) UNAL;
        DCL 1 FW_REVISION(0:1) STATIC,
            2 LEN UBIN BYTE CALIGNED INIT(9),
            2 MON CHAR(2) UNAL,
            2 DAY CHAR(2) UNAL,
            2 YR CHAR(2) UNAL,
            2 * CHAR(1) UNAL INIT(' '),
            2 REV CHAR(2) UNAL;
        DCL 1 CM_NN,
            2 LEN UBIN BYTE CALIGNED,
            2 NAME CHAR(1);
        DCL 1 DCNN,
            2 LEN UBIN BYTE CALIGNED,
            2 NAME CHAR(2);
        DCL 1 ERROR_TEXT,
            2 LEN UBIN BYTE CALIGNED,
            2 ASCII CHAR(4) UNAL;
        DCL 1 MASTER_STATUS STATIC,
            2 LEN UBIN BYTE CALIGNED INIT(2),
            2 STATUS CHAR(2) UNAL;
        DCL 1 SLAVE_STATUS STATIC,
            2 LEN UBIN BYTE CALIGNED INIT(2),
            2 STATUS CHAR(2) UNAL;
        DCL 1 STATUS_TEXT STATIC,
            2 LEN UBIN BYTE CALIGNED INIT(25),
            2 ASCII CHAR(25);
        DCL 1 CM,
            2 VALID UBIN,
            2 VLD REDEF VALID,      /* VALID CM NUMBERS ON DCnn */
              3 NUM(0:7) BIT(1) UNAL,
              3 * BIT(28) UNAL,
            2 TO_LOAD UBIN,
            2 LOAD REDEF TO_LOAD,      /* CMs TO LOAD ON DCnn */
              3 NUM(0:7) BIT(1) UNAL,
              3 * BIT(28) UNAL;
        %VLP_VECTOR              (FPTN=SEG_);
        %TCM_STATUS              (NAME=IO_STATUS, LVL=1,
                                  STCLASS="BASED(STAT$)");
        DCL 1 STATUS REDEF IO_STATUS,
            2 WORD1 UBIN,
            2 WORD2 UBIN;
        %FPT_TDOPEN              (FPTN=FPT_TDOPEN,DCB=F$TDIO,
                                  TEST=ITR);
        %FPT_TDCLOSE             (FPTN=FPT_TDCLOSE,DCB=F$TDIO);
        %FPT_TDIO                 (FPTN=FPT_TDIO, DCB=F$TDIO);
        %FPT_WAIT                (FPTN=FPT_WAIT, UTYPE=SEC, UNITS=10);
%EJECT;
/*
*********************** CM PACKETS *********************************
                                                                   */
DCL 1 CMD_PACKET STATIC ALIGNED,                 /*  IPI CMD PACKET  */
    2 MSG CHAR(8) UNAL INIT('IPI CMD ');
DCL 1 RES_PACKET STATIC ALIGNED,                  /*  RESERVE PACKET  */
    2 MSG CHAR(0) UNAL INIT('RESERVE LOGCHAN SLAVE '),
    2 CM CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) UNAL INIT(' ');
DCL 1 RESP_PACKET STATIC ALIGNED,                /*  IPI RESPONSE PACKET */
    2 MSG CHAR(0) UNAL INIT('IPI RESP '),
    2 CM CHAR(1) UNAL INIT('0'),
    2 * CHAR(2) UNAL INIT('  ');
DCL 1 REL_PACKET STATIC ALIGNED,                 /*  RELEASE PACKET  */
    2 MSG CHAR(0) UNAL INIT('RELEASE LOGCHAN SLAVE '),
    2 CM CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) UNAL INIT(' ');
DCL 1 WRT_PACKET STATIC ALIGNED,                /*  IPI WRITE PACKET  */
    2 MSG CHAR(0) UNAL INIT('IPI WRITE '),
    2 CM CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) INIT(' ');
DCL 1 RESET_PACKET STATIC ALIGNED,             /* CM RESET PACKET */
    2 PACKET_TYPE CHAR(2) UNAL INIT('04'),
    2 CM CHAR(1) UNAL INIT('8'),
    2 RESET_TYPE CHAR(1) UNAL INIT('2');
DCL 1 CM_CMD_PACKET1 ALIGNED STATIC,           /*  CM COMMAND MSG PACKET  */
    2 PACKET_TYPE CHAR(2) UNAL INIT('01'),
    2 CM CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) UNAL INIT(' '),
    2 LENGTH CHAR(4) UNAL INIT('000A'),
    2 * CHAR(1) UNAL INIT(' '),
    2 REF_NO CHAR(4) UNAL INIT('0014'),
    2 * CHAR(1) UNAL INIT(' '),
    2 OP_CODE CHAR(2) UNAL INIT('02'),      /* ATTRIBUTES */
    2 CMD_MOD CHAR(2) UNAL INIT('00'),
    2 * CHAR(1) UNAL INIT(' '),
    2 SLAVE_ADDR UNAL,
      3 * CHAR(1) UNAL INIT('0'),
      3 CM CHAR(1) UNAL INIT('0'),
    2 DRIVE_ADDR CHAR(2) UNAL INIT('FF'),
    2 * CHAR(1) UNAL INIT(' '),
    2 PARAM1 UNAL,
      3 LENGTH CHAR(2) UNAL INIT('03'),
      3 ID CHAR(2) UNAL INIT('6C'),     /* REQUEST PARAMETERS */
      3 * CHAR(1) UNAL INIT(' '),
      3 OCTETS CHAR(4) UNAL INIT('4050'),
      3 * CHAR(2) UNAL INIT('  ');
DCL 1 CM_CMD_PACKET2 ALIGNED STATIC,           /*  CM COMMAND MSG PACKET  */
    2 PACKET_TYPE CHAR(2) UNAL INIT('01'),
    2 CM CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) UNAL INIT('0'),
    2 * CHAR(1) UNAL INIT(' '),
    2 LENGTH CHAR(4) UNAL INIT('001B'),
    2 * CHAR(1) UNAL INIT(' '),
    2 REF_NO CHAR(4) UNAL INIT('0014'),
    2 * CHAR(1) UNAL INIT(' '),
    2 OP_CODE CHAR(2) UNAL INIT('66'),      /* LOAD CONTROLLER IML */
    2 CMD_MOD CHAR(2) UNAL INIT('00'),
    2 * CHAR(1) UNAL INIT(' '),
    2 SLAVE_ADDR UNAL,
      3 * CHAR(1) UNAL INIT('0'),
      3 CM CHAR(1) UNAL INIT('0'),
    2 DRIVE_ADDR CHAR(2) UNAL INIT('FF'),
    2 * CHAR(1) UNAL INIT(' '),
    2 PARAM1 UNAL,
      3 LENGTH CHAR(2) UNAL INIT('05'),
      3 ID CHAR(2) UNAL INIT('31'),         /* CMD EXTENT PARAMETER */
      3 OCTETS CHAR(11) UNAL INIT(' 0002 FA8E '),
    2 PARAM2 UNAL,
      3 LENGTH CHAR(2) UNAL INIT('09'),
      3 ID CHAR(2) UNAL INIT('51'),       /* INFORMATION TRANSFER PARAMETER */
      3 OCTETS CHAR(21) UNAL INIT(' 0000 0120 0000 0120 '),
    2 PARAM3 UNAL,
      3 LENGTH CHAR(2) UNAL INIT('04'),
      3 ID CHAR(2) UNAL INIT('6E'),
      3 OCTETS CHAR(11) UNAL INIT(' 0280 0000 ');
DCL 1 CM_RESP_PACKET ALIGNED BASED(RDBUF$),        /* CM RESPONSE PACKET */
    2 PACKET_TYPE CHAR(2) UNAL,
    2 CM CHAR(1) UNAL,
    2 * CHAR(1) UNAL,
    2 * CHAR(1) UNAL,
    2 LENGTH CHAR(4) UNAL,
    2 * CHAR(1) UNAL,
    2 REF_NO CHAR(4) UNAL,
    2 * CHAR(1) UNAL,
    2 OP_CODE CHAR(2) UNAL,
    2 CMD_MOD CHAR(2) UNAL,
    2 * CHAR(1) UNAL,
    2 SLAVE_ADDR UNAL,
      3 * CHAR(1) UNAL,
      3 CM CHAR(1) UNAL,
    2 DRIVE_ADDR CHAR(2) UNAL,
    2 * CHAR(1) UNAL,
    2 MAJOR_STATUS CHAR(2) UNAL,
    2 RESP_TYPE CHAR(1) UNAL,
    2 M_STATUS CHAR(1) UNAL,
    2 * CHAR(1) UNAL,
    2 PARAMS CHAR(226) UNAL,
    2 XNP_PACKET REDEF PARAMS,
      3 MASTER_STATUS CHAR(2) UNAL,
      3 SLAVE_STATUS CHAR(2) UNAL,
      3 * CHAR(222) UNAL,
    2 VENDOR_ID REDEF PARAMS,
      3 LTH CHAR(2) UNAL,
      3 ID CHAR(2) UNAL,
      3 * CHAR(61) UNAL,
      3 MON CHAR(2) UNAL,
      3 DAY CHAR(2) UNAL,
      3 * CHAR(1) UNAL,
      3 YR CHAR(2) UNAL,
      3 REV_NUM CHAR(2) UNAL,
      3 * CHAR(152) UNAL,
    2 SUBSTATUS_PARAMS REDEF PARAMS,
      3 LTH CHAR(2) UNAL,
      3 ID CHAR(2) UNAL,
      3 * CHAR(1) UNAL,
      3 SUBSTATUS CHAR(2) UNAL,
      3 * CHAR(18) UNAL,
      3 MICRO_ERR CHAR(4) UNAL,
      3 * CHAR(197) UNAL;
DCL 1 UNEXP_PACKET REDEF CM_RESP_PACKET CHAR(256);
DCL 1 FW_BUFFER(0:40959) UBIN ALIGNED BASED(FW$);  /* FW BUFFER */
%EJECT;
/*
*********************** ERROR MESSAGES ********************************
                                                                    */
/*B*
TCL#WRONG_CM     is a VLP_ERRCODE structure used to print the
                      "Received CM F/W RESPONSE from wrong CM" error message.
                                                                   */
/*E*
ERROR:  TCL-E$TCL#WRONG_CM-4
MESSAGE:  Received CM F/W RESPONSE from wrong CM before self-test.
                                                                 */
%VLP_ERRCODE (FPTN = TCL#WRONG_CM, STCLASS = CONSTANT,
              ERR# = %E$TCL#WRONG_CM, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=4);
/*B*
TCL#DCNN_NOT_PART     is a VLP_ERRCODE structure used to print the
                      "DCnn must be partitioned before FW LOAD" error message.
                                                                   */
/*E*
ERROR:  TCL-E$TCL#DCNN_NOT_PART-4
MESSAGE:  DC%U1 must be partitioned before FW LOAD.
                                                                 */
%VLP_ERRCODE (FPTN = TCL#DCNN_NOT_PART, STCLASS = CONSTANT,
              ERR# = %E$TCL#DCNN_NOT_PART, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=4);
/*B*
TCL#FW_NOT_IN_MEMORY      is a VLP_ERRCODE structure used to print the
                          "READ FW from tape before LOAD" error message.
                                                                   */
/*E*
ERROR:  TCL-E$TCL#FW_NOT_IN_MEMORY-4
MESSAGE:  READ FW from tape before LOAD.
                                                                 */
%VLP_ERRCODE (FPTN = TCL#FW_NOT_IN_MEMORY, STCLASS = CONSTANT,
              ERR# = %E$TCL#FW_NOT_IN_MEMORY, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=4);
/*B*
TCL#CM_NOT_CONFIGED     is a VLP_ERRCODE structure used to print the
                        "CMn is not configured on DCnn" error message.
                                                                   */
/*E*
ERROR:  TCL-E$TCL#CM_NOT_CONFIGED-4
MESSAGE:  CM%U1 is not configured on DC%U2.
                                                                 */
%VLP_ERRCODE (FPTN = TCL#CM_NOT_CONFIGED, STCLASS = CONSTANT,
              ERR# = %E$TCL#CM_NOT_CONFIGED, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=4);
/*B*
TCL#NO_CMS_LOADED       is a VLP_ERRCODE structure used to print the
                        "No CMs loaded on DCnn" error message.
                                                                   */
/*E*
ERROR:  TCL-E$TCL#NO_CMS_LOADED-4
MESSAGE:  No CMs loaded on DC%U1.  Do a REPORT DC%U1 to check if CMs
          are configured and present.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#NO_CMS_LOADED, STCLASS = CONSTANT,
              ERR# = %E$TCL#NO_CMS_LOADED, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=4);
        %EJECT ;
/*B*
TCL#UNABLE_TO_SUSPEND   is a VLP_ERRCODE structure used to print the
                        "Returned bad status = xxxxxxxxxxxx on SUSPEND DCnn" error msg.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#UNABLE_TO_SUSPEND-6
MESSAGE:  Returned bad STATUS = %U1 on SUSPEND DC%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#UNABLE_TO_SUSPEND, STCLASS = CONSTANT,
              ERR# = %E$TCL#UNABLE_TO_SUSPEND, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#RESERVE_ERROR       is a VLP_ERRCODE structure used to print the
                        "CMn is already reserved" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#RESERVE_ERROR-4
MESSAGE: CM%U1 is already reserved.  Unable to LOAD F/W to CM%U1 at this time.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#RESERVE_ERROR, STCLASS = CONSTANT,
              ERR# = %E$TCL#RESERVE_ERROR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=4);
/*B*
TCL#BAD_STATUS_RES          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx on RESERVE CMn" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_STATUS_RES-6
MESSAGE:  BAD STATUS = %U1 on RESERVE CM%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_STATUS_RES, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_STATUS_RES, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#BAD_STATUS_RESP          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx on READ RESPONSE" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_STATUS_RESP-6
MESSAGE:  BAD STATUS =%U1 on READ RESPONSE to CM%U2 and devices
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_STATUS_RESP, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_STATUS_RESP, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#CM_NOT_BUSY          is a VLP_ERRCODE structure used to print the
                        "CMn did not go busy after all responses were read"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#CM_NOT_BUSY-6
MESSAGE:  CM%U1 did not go busy after all CM & device responses were read,
          I/O STATUS = %U2.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#CM_NOT_BUSY, STCLASS = CONSTANT,
              ERR# = %E$TCL#CM_NOT_BUSY, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#NO_RESPONSE          is a VLP_ERRCODE structure used to print the
                        "No response from CMn.  Check if power off."
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#NO_RESPONSE-6
MESSAGE:  No RESPONSE from CM%U1.  Check if power off.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#NO_RESPONSE, STCLASS = CONSTANT,
              ERR# = %E$TCL#NO_RESPONSE, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#BAD_STATUS_REV          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx on CM REV packet"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_STATUS_REV-6
MESSAGE:  BAD STATUS =%U1 when sending CM REV packet to CM%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_STATUS_REV, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_STATUS_REV, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#BAD_REV_RESP          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx detected when CM
                        RESPONSE packet was sent to read CM F/W REV"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_REV_RESP-6
MESSAGE:  BAD STATUS =%U1 when CM RESPONSE packet was sent to
           read CM F/W revision on CM%U2.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_REV_RESP, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_REV_RESP, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#NOT_STD_COMP          is a VLP_ERRCODE structure used to print the
                        "Did not get Standard Completion on F/W REV
                        response from CMn" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#NOT_STD_COMP-6
MESSAGE:  Did not get Std Completion on F/W REV response from CM%U1
                                                                   */
%VLP_ERRCODE (FPTN = TCL#NOT_STD_COMP, STCLASS = CONSTANT,
              ERR# = %E$TCL#NOT_STD_COMP, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#NO_SUCCESS          is a VLP_ERRCODE structure used to print the
                        "Did not get MAJOR CODE = 8 (Successful) in
                        CM F/W REV response" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#NO_SUCCESS-6
MESSAGE:  Did not get MAJOR CODE = 8 (Successful) in F/W REV response
           from CM%U1.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#NO_SUCCESS, STCLASS = CONSTANT,
              ERR# = %E$TCL#NO_SUCCESS, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#IML_LOAD_ERROR          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx detected on CM F/W Load Packet."
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#IML_LOAD_ERROR-6
MESSAGE:  BAD STATUS = %U1 detected on CM%U2 F/W Load Packet.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#IML_LOAD_ERROR, STCLASS = CONSTANT,
              ERR# = %E$TCL#IML_LOAD_ERROR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#BAD_IML_LOAD          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx when READ for response
                        was issued to CMn after IML LOAD" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_IML_LOAD-6
MESSAGE:  BAD STATUS =%U1 when READ for response was issued to CM%U2
           after IML LOAD.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_IML_LOAD, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_IML_LOAD, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#NOT_TYPE04          is a VLP_ERRCODE structure used to print the
                        "Did not get type 04 (Data Expected) response
                        packet from CMn" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#NOT_TYPE04-6
MESSAGE:  Did not get TYPE = 04 (Data Expected) response packet from CM%U1.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#NOT_TYPE04, STCLASS = CONSTANT,
              ERR# = %E$TCL#NOT_TYPE04, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#RESPONSE_ERROR          is a VLP_ERRCODE structure used to print the
                        "RESPONSE packet from CMn indicates an error
                         occurred" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#RESPONSE_ERROR-6
MESSAGE:  RESPONSE packet from CM%U1 indicates an error occurred.
          Master status = %U2      Slave status = %U3
                                                                   */
%VLP_ERRCODE (FPTN = TCL#RESPONSE_ERROR, STCLASS = CONSTANT,
              ERR# = %E$TCL#RESPONSE_ERROR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#FW_WRITE_ERROR          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx detected during IPI WRT
                         of F/W data transfer" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#FW_WRITE_ERROR-6
MESSAGE:  BAD STATUS = %U1 detected during IPI WRT or F/W data
          transfer.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#FW_WRITE_ERROR, STCLASS = CONSTANT,
              ERR# = %E$TCL#FW_WRITE_ERROR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#IML_LOAD_FAILURE          is a VLP_ERRCODE structure used to print the
                             "IML LOAD did not start" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#IML_LOAD_FAILURE-6
MESSAGE:  IML LOAD did not start.  STATUS = %U1
                                                                   */
%VLP_ERRCODE (FPTN = TCL#IML_LOAD_FAILURE, STCLASS = CONSTANT,
              ERR# = %E$TCL#IML_LOAD_FAILURE, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#LOAD_IN_PROCESS          is a VLP_ERRCODE structure used to print the
                        "IML LOADing firmware to CMn" message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#LOAD_IN_PROCESS-0
MESSAGE:  IML LOADing firmware to CM%U1....
                                                                   */
%VLP_ERRCODE (FPTN = TCL#LOAD_IN_PROCESS, STCLASS = CONSTANT,
              ERR# = %E$TCL#LOAD_IN_PROCESS, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=0);
/*B*
TCL#IPC_REBOOT          is a VLP_ERRCODE structure used to print the
                        "IPC firmware is loading..."  message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#IPC_REBOOT-0
MESSAGE:  IPC firmware is loading ...
                                                                   */
%VLP_ERRCODE (FPTN = TCL#IPC_REBOOT, STCLASS = CONSTANT,
              ERR# = %E$TCL#IPC_REBOOT, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=0);
/*B*
TCL#IML_TIMEOUT          is a VLP_ERRCODE structure used to print the
                        "IML LOAD did not complete in 5 minutes"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#IML_TIMEOUT-6
MESSAGE:  IML LOAD to CM%U1 did not complete in 5 minutes.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#IML_TIMEOUT, STCLASS = CONSTANT,
              ERR# = %E$TCL#IML_TIMEOUT, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#IML_LOAD_INCOMPLETE          is a VLP_ERRCODE structure used to print the
                        "Did not receive an IML LOAD completion"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#IML_LOAD_INCOMPLETE-6
MESSAGE:  Did not receive an IML LOAD completion response from CM%U1
           after F/W was loaded. Suspect data not accepted by CM%U1.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#IML_LOAD_INCOMPLETE, STCLASS = CONSTANT,
              ERR# = %E$TCL#IML_LOAD_INCOMPLETE, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#RELEASE_ERR          is a VLP_ERRCODE structure used to print the
                        "Error trying to RELEASE CMn" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#RELEASE_ERR-6
MESSAGE:  Error trying to RELEASE CM%U1.  STATUS = %U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#RELEASE_ERR, STCLASS = CONSTANT,
              ERR# = %E$TCL#RELEASE_ERR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#BAD_RESET_STATUS          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx on RESET of CMn"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_RESET_STATUS-6
MESSAGE:  BAD STATUS = %U1 on RESET of CM%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_RESET_STATUS, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_RESET_STATUS, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#REV_MESSAGE          is a VLP_ERRCODE structure used to print the
                        "CM F/W REV after firmware load: mmddyy rev"
                         message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#REV_MESSAGE-0
MESSAGE:  CM F/W REV before firmware load:  %U1
          CM F/W REV after firmware load:   %U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#REV_MESSAGE, STCLASS = CONSTANT,
              ERR# = %E$TCL#REV_MESSAGE, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=0);
/*B*
TCL#UNABLE_TO_RELEASE          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx on RELEASE DCnn"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#UNABLE_TO_RELEASE-6
MESSAGE:  BAD STATUS = %U1 when trying to RELEASE DC%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCL#UNABLE_TO_RELEASE, STCLASS = CONSTANT,
              ERR# = %E$TCL#UNABLE_TO_RELEASE, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#CONFIG_ERR          is a VLP_ERRCODE structure used to print the
                        "Error in :CONFIG file " error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#CONFIG_ERR-6
MESSAGE:  Error in :CONFIG file - No IOM channels assigned to DC%U1
                                                                   */
%VLP_ERRCODE (FPTN = TCL#CONFIG_ERR, STCLASS = CONSTANT,
              ERR# = %E$TCL#CONFIG_ERR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#RESET_MSG          is a VLP_ERRCODE structure used to print the
                        "Power-on RESET issued to CMn..." message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#RESET_MSG-0
MESSAGE:  Power-on RESET issued to CM%U1...
                                                                   */
%VLP_ERRCODE (FPTN = TCL#RESET_MSG, STCLASS = CONSTANT,
              ERR# = %E$TCL#RESET_MSG, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=0);
/*B*
TCL#BAD_POWER_ON          is a VLP_ERRCODE structure used to print the
                        "Bad STATUS = xxxxxxxxxxxx when attempting power-on
                         RESET to CMn" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#BAD_POWER_ON-6
MESSAGE:  Bad STATUS = %U1 when attempting power-on RESET to CM%U2
          RESET of CM%U2 through program control impossible.
          Perform manual power-down and power-up of CM%U2 before attempting
          to reload CM firmware.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#BAD_POWER_ON, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_POWER_ON, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#CMD_REJECT          is a VLP_ERRCODE structure used to print the
                        "Command REJECT reported by CMn" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#CMD_REJECT-6
MESSAGE:  Command REJECT reported by CM%U1.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#CMD_REJECT, STCLASS = CONSTANT,
              ERR# = %E$TCL#CMD_REJECT, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#MICRO_ERROR          is a VLP_ERRCODE structure used to print the
                        "A microcode exception error has occurred on CMn"
                         error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#MICRO_ERROR-6
MESSAGE:  A microcode exception error has occurred on CM%U1.  CODE = %U2.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#MICRO_ERROR, STCLASS = CONSTANT,
              ERR# = %E$TCL#MICRO_ERROR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#RESET_COMPLETE          is a VLP_ERRCODE structure used to print the
                        "Power-on RESET to CMn complete" message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#RESET_COMPLETE-0
MESSAGE:  Power-on RESET to CM%U1 complete.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#RESET_COMPLETE, STCLASS = CONSTANT,
              ERR# = %E$TCL#RESET_COMPLETE, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=0);
/*B*
TCL#INTERNAL_ERR          is a VLP_ERRCODE structure used to print the
                        "Internal error - DCW list overflow" error message.
                                                                    */
/*E*
ERROR:  TCL-E$TCL#INTERNAL_ERR-6
MESSAGE:  INTERNAL ERROR - DCW list overflow.
          Probably bad input data from F/W tape/file.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#INTERNAL_ERR, STCLASS = CONSTANT,
              ERR# = %E$TCL#INTERNAL_ERR, FCG = %TCM#FCG,
              MID = 'L', MON = %NO#, SEV=6);
/*B*
TCL#SYSCON_ERR            is a VLP_ERRCODE structure used to print
                       "SYSCON error - All channels to DCnn are partitioned"
                        error message.
                                                                   */
/*E*
ERROR:  TCL-E$TCL#SYSCON_ERR-6
MESSAGE:  SYSCON error - All channels to DC%U1 are partitioned.
          Unable to proceed with firmware load.
                                                                   */
%VLP_ERRCODE (FPTN = TCL#SYSCON_ERR, STCLASS = CONSTANT,
             ERR# = %E$TCL#SYSCON_ERR, FCG = %TCM#FCG,
             MID = 'L', MON = %NO#, SEV = 6);
%EJECT;
/********************** PROCEDURE **********************************/
/*
              ******************************************
              *                                        *
              *     CHECK IF FIRMWARE HAS BEEN READ    *
              *        FROM FIRMWARE TAPE/FILE         *
              *                                        *
              ******************************************
 
                                                                    */
   TCM_PIT.FLAGS.FWLIP# = '0'B;                   /* RESET FW LIP FLAG */
   IF NOT TCM_PIT.FLAGS.FWREAD#
      THEN DO;
         CALL TCE$ERRMSG ( TCL#FW_NOT_IN_MEMORY ) ;
         RETURN;
      END;
/*
   GET DCnn FROM PARSED COMMAND
                                                                    */
   DCNN.LEN = OUT$BLK.SUBLK$(0) -> OUT$SYM.COUNT;
   DCNN.NAME = OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
   CALL TCS$CONFIG(DCNN) ALTRET(ERR_CONFIG);
   IF TCM_PIT.DCNN.NAME = ' '
      THEN RETURN;
   IF NOT TCM_PIT.DCNN.FLAGS.DOWN
      THEN DO;
        CALL TCE$ERRMSG ( TCL#DCNN_NOT_PART,,VECTOR(DCNN));
        TCM_PIT.DCNN.NAME = ' ';
        RETURN;
      END;
/*
        GET VALID CM NUMBERS FROM PIT
                                                                    */
   CM.VALID = 0;
   CM.TO_LOAD = 0;
   DO I = 0 TO 7;
      IF TCM_PIT.CM.FLAGS.PRESENT(I) AND TCM_PIT.CM.FLAGS.CONFIGED(I)
         THEN CM.VLD.NUM(I) = '1'B;
   END;
%EJECT;
/*
              ******************************************
              *                                        *
              *    GET CM NUMBERS FROM LOAD COMMAND    *
              *                                        *
              *                                        *
              ******************************************
                                                                    */
   DO CASE (OUT$BLK.NSUBLKS);
      CASE(1);                /* NO OPTIONS */
        CM.TO_LOAD = CM.VALID;
      CASE(2);
                              /* OPTIONS */
        DO CASE (OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE);
           CASE (TCO#ALL);
              CM.TO_LOAD = CM.VALID;
           CASE (TCO#ONE);
              CM_NN.LEN = OUT$BLK.SUBLK$(1) -> OUT$SYM.COUNT;
              CM_NN.NAME = OUT$BLK.SUBLK$(1) ->OUT$SYM.TEXT;
              CALL CHARBIN (I,CM_NN.NAME);
              IF CM.VLD.NUM(I) THEN
                 CM.LOAD.NUM(I) = '1'B;
                 ELSE DO;
                   CALL TCE$ERRMSG (TCL#CM_NOT_CONFIGED,,
                                    VECTOR(CM_NN),
                                    VECTOR(DCNN));
                 END;
           CASE (TCO#LIST);
                DO J = 1 TO OUT$BLK.SUBLK$(1) -> OUT$BLK.NSUBLKS;
                   CM_NN.LEN = OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(J-1) ->
                               OUT$SYM.COUNT;
                   CM_NN.NAME = OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(J-1) ->
                                OUT$SYM.TEXT;
                   CALL CHARBIN (I,CM_NN.NAME);
                   IF CM.VLD.NUM(I) THEN
                      CM.LOAD.NUM(I) = '1'B;
                      ELSE DO;
                        CALL TCE$ERRMSG (TCL#CM_NOT_CONFIGED,,
                                         VECTOR(CM_NN),
                                         VECTOR(DCNN));
                      END;
                END; /* DO J = 1 */
        END;  /* DO CASE (OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE) */
   END;  /* DO CASE (OUT$BLK.NSUBLKS) */
   CM_COUNT = 0;
   DO J = 0 TO 7;
        IF CM.LOAD.NUM(J)
           THEN CM_COUNT = CM_COUNT +1;
   END;
   IF CM_COUNT = 0
        THEN DO;
           CALL TCE$ERRMSG(TCL#NO_CMS_LOADED,,VECTOR(DCNN));
           TCM_PIT.DCNN.NAME = ' ';
           RETURN;
        END;
        %EJECT ;
/*
              ******************************************
              *                                        *
              *       PREPARE TO DO TDIO TO IPC        *
              *             CONTROLLER                 *
              *                                        *
              ******************************************
                                                                    */
   DCB$ = DCBADDR(DCBNUM(F$TDIO));
   STAT$ = ADDR(DCB$->F$DCB.TDSTAT#);
   AVAIL_CHANS = 0;
   DO J = 0 TO 15;
      IF NOT TCM_PIT.DCNN.IOCHAN.DOWN(J)
         THEN AVAIL_CHANS = AVAIL_CHANS + 1;
   END;
   IF AVAIL_CHANS = 0 THEN
      DO;
        CALL TCE$ERRMSG(TCL#SYSCON_ERR,,VECTOR(DCNN));
        RETURN;
      END;
   DO J = 0 TO 15;
      IF TCM_PIT.DCNN.IOCHAN.PRESENT(J) AND
         (NOT TCM_PIT.DCNN.IOCHAN.DOWN(J))
         THEN DO;
            FPT_TDOPEN.V.DEVICE.IOM# = TCM_PIT.DCNN.IOCHAN.IOM(J);
            FPT_TDOPEN.V.DEVICE.CHAN# = TCM_PIT.DCNN.IOCHAN.CHAN(J);
            GOTO OPEN_TDIO_DCB;
         END;
   END;
   CALL TCE$ERRMSG(TCL#CONFIG_ERR,, VECTOR(DCNN));
   RETURN;
OPEN_TDIO_DCB:
   CALL M$TDOPEN (FPT_TDOPEN) ALTRET(ERR_RTN);
/*
   FRAME DATA AREA FOR M$TDIO
                                                                   */
   FPT_TDIO.DATA_ = TCM_PIT.FW.SEG_;
   SEG_ = TCM_PIT.FW.SEG_;
   DCW$ = SEG_.PTR$;                 /* START OF DCWLIST AREA */
   PACKET$ = PINCRW(SEG_.PTR$,20);   /* START OF CM PACKET AREA */
   RDBUF$ = PINCRW(SEG_.PTR$,56);    /* START OF CM RESPONSE BUFFER */
   FW$ = TCM_PIT.FW.P$;              /* FIRMWARE AREA */
   TCM_PIT.FLAGS.FWLIP# = '1'B;        /* SET F/W LOAD IN PROGRESS FLAG */
   CALL XUG$DISABLE (XUG_GETCMD);          /* DISABLE BREAKS */
    DO J = 0 TO 7 ;
        IF  CM.LOAD.NUM(J)
        THEN DO ;
/*
   CHECK IF CHANNEL HAS ALREADY BEEN SUSPENDED
                                                           */
   IF NOT TCM_PIT.DCNN.FLAGS.SUSPEND
      THEN DO;
         IDCW1 = %IDCWSPND;
         CALL BUILD_DCWLST(IDCW1);   /* ISSUE SUSPEND */
         IF IO_STATUS.MAJOR = BITBIN('00'O) AND  /* STATUS = READY? */
            IO_STATUS.MINOR = '000000'B AND
            IO_STATUS.IOM = '00'O
            THEN TCM_PIT.DCNN.FLAGS.SUSPEND = '1'B;
            ELSE DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCL#UNABLE_TO_SUSPEND,,
                                VECTOR(STATUS_TEXT),
                                VECTOR(DCNN));
               RETURN;
               END;
      END;  /* IF NOT TCM_PIT.DCNN.FLAGS.SUSPEND */
            TCM_PIT.CM.FLAGS.FW_LOADED(J) = '0'B;
            CM_NN.NAME = CM_NUMBER.N(J);
            CM_NN.LEN = 1;
/*
   INITIALIZE CM PACKETS WITH CM#
                                                                  */
            RESP_PACKET.CM = CM_NUMBER.N(J);
            REL_PACKET.CM = CM_NUMBER.N(J);
            RES_PACKET.CM = CM_NUMBER.N(J);
            WRT_PACKET.CM = CM_NUMBER.N(J);
            RESET_PACKET.CM = CM_NUMBER.N(J+8);
%EJECT;
/*
              ******************************************
              *                                        *
              *           RESERVE SLAVE CM             *
              *                                        *
              *                                        *
              ******************************************
                                                                    */
RESERVE_SLAVE:
            IDCW1 = %IDCWMPF;                 /* MPF COMMAND */
            CALL BUILD_DCWLST (IDCW1, VECTOR(RES_PACKET));
            IF IO_STATUS.MAJOR = BITBIN('00'O) AND    /* STATUS = READY? */
               IO_STATUS.MINOR = '000000'B AND
               IO_STATUS.IOM = '00'O
               THEN GOTO RESPONSE_CHECK;
               ELSE DO;
                  IF IO_STATUS.MAJOR = BITBIN('05'O) AND   /* CM ALREADY RESERVED? */
                     IO_STATUS.MINOR = '001000'B
                     THEN DO;
                        CALL TCE$ERRMSG (TCL#RESERVE_ERROR,,
                                         VECTOR(CM_NN));
                        GOTO NEXT_CM;
                     END;
                  CALL CONVERT_STATUS (STATUS, STATUS_TEXT) ;
                  CALL TCE$ERRMSG (TCL#BAD_STATUS_RES,,
                                   VECTOR(STATUS_TEXT),
                                   VECTOR(CM_NN));
                  GOTO RELEASE_CM;
               END;
%EJECT;
/*
 
              ******************************************
              *                                        *
              *     READ STATUS AFTER RESERVE OF CM    *
              *                                        *
              *       CM SHOULD BE READY AND BUSY      *
              ******************************************
                                                                  */
RESPONSE_CHECK:
            IDCW1 = %IDCWMPF;               /* MPF COMMAND */
            IDCW2 = %IDCWREAD;              /* READ COMMAND */
/*
               READ RESPONSES FOR THE CM AND FOR EACH DEVICE IN
               ORDER TO CLEAR OUT ANY OLD MESSAGES FROM THE CM's
               STACK.  THE CM WILL GO BUSY WHEN ALL ARE READ.
                                                                  */
            DO I = 0 TO 9;
               CALL BUILD_DCWLST (IDCW1, VECTOR(RESP_PACKET), IDCW2,
                            VECTOR(CM_RESP_PACKET));
               IF NOT (IO_STATUS.MAJOR = BITBIN('00'O) AND
                       IO_STATUS.MINOR = '000000'B AND
                       IO_STATUS.IOM = '00'O)
                       THEN DO;
                          IF IO_STATUS.MAJOR = BITBIN('01'O) AND
                             IO_STATUS.MINOR = '000001'B
                             THEN DO;
                                CALL READ_FW_REV (FW_REVISION(0)) ALTRET(RELEASE_CM);
                                GOTO FIRMWARE_LOAD;
                             END;
                             ELSE DO;
                                CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
                                CALL TCE$ERRMSG(TCL#BAD_STATUS_RESP,,
                                                VECTOR(STATUS_TEXT),
                                                VECTOR(CM_NN));
                                GOTO RELEASE_CM;    /* BR TO RELEASE CM & EXIT */
                             END;
                       END;
            END;  /* DO I */
            CALL CONVERT_STATUS (STATUS, STATUS_TEXT) ;
            CALL TCE$ERRMSG(TCL#CM_NOT_BUSY,, VECTOR(CM_NN),    /* CM FAILED TO GO BUSY */
                            VECTOR(STATUS_TEXT));
            GOTO RELEASE_CM;   /* BR TO RELEASE CM & EXIT */
%EJECT;
/*
              ******************************************
              *            FIRMWARE LOAD               *
              *                                        *
              *    THIS ROUTINE ISSUES THE IPI IML     *
              *    LOAD PACKET FOR THE SELECTED CM     *
              ******************************************
                                                                   */
FIRMWARE_LOAD:
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWWRT;
         CM_CMD_PACKET2.CM = CM_NN.NAME;
         CM_CMD_PACKET2.SLAVE_ADDR.CM = CM_NN.NAME;
         CALL BUILD_DCWLST(IDCW1, VECTOR(CMD_PACKET), IDCW2,
                     VECTOR(CM_CMD_PACKET2));      /* ISSUE IML LOAD TO CM */
         IF IO_STATUS.MAJOR = BITBIN('00'O) AND    /* STATUS = READY? */
            IO_STATUS.MINOR = '000000'B
            THEN GOTO READ_RESPONSE;
            ELSE DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG(TCL#IML_LOAD_ERROR,, VECTOR(STATUS_TEXT),
                               VECTOR(CM_NN));
               GOTO RELEASE_CM;                  /* READ RESPONSES & REL CM */
            END;
%EJECT;
/*
              ******************************************
              *                                        *
              *            READ RESPONSE               *
              *                                        *
              *   CHECK STATUS AFTER ISSUING THE IPI   *
              *           IML LOAD PACKET              *
              ******************************************
                                                                   */
READ_RESPONSE:
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWREAD;
         DO I = 1 TO 10;                      /* ALLOW FOR 10 RETRIES */
            CALL BUILD_DCWLST(IDCW1, VECTOR(RESP_PACKET), IDCW2,
                        VECTOR(CM_RESP_PACKET));    /* ISSUE READ FOR RESPONSE PACKET */
            IF IO_STATUS.MAJOR = BITBIN('00'O) AND
               IO_STATUS.MINOR = '000000'B
               THEN GOTO CHECK_RESPONSE_PACKET;    /* READY STATUS */
         END;
         CALL CONVERT_STATUS (STATUS, STATUS_TEXT) ;
         CALL TCE$ERRMSG(TCL#BAD_IML_LOAD,, VECTOR(STATUS_TEXT),
                         VECTOR(CM_NN));
         GOTO RELEASE_CM;
CHECK_RESPONSE_PACKET:
         IF (CM_RESP_PACKET.PACKET_TYPE = '04' AND     /* TYPE 04 = DATA EXPECTED */
             CM_RESP_PACKET.OP_CODE = CM_CMD_PACKET2.OP_CODE)
             THEN GOTO CHECK_STATUS;
             ELSE DO;
                CALL ANALYZE_PACKET;
                CALL TCE$ERRMSG(TCL#NOT_TYPE04,, VECTOR(CM_NN));
                GOTO RELEASE_CM;    /* READ REM RESPONSES & REL CM */
             END;
%EJECT;
CHECK_STATUS:
         IF CM_RESP_PACKET.XNP_PACKET.MASTER_STATUS = '80' AND
            CM_RESP_PACKET.XNP_PACKET.SLAVE_STATUS = '80'
               THEN GOTO CHECK_CM_NUM;
               ELSE DO;
                  MASTER_STATUS.STATUS = CM_RESP_PACKET.XNP_PACKET.MASTER_STATUS;
                  SLAVE_STATUS.STATUS = CM_RESP_PACKET.XNP_PACKET.SLAVE_STATUS;
                  CALL TCE$ERRMSG(TCL#RESPONSE_ERROR,,VECTOR(CM_NN),
                                  VECTOR(MASTER_STATUS), VECTOR(SLAVE_STATUS));
                  GOTO RELEASE_CM;               /* READ REM RESPONSES & REL CM*/
               END;
CHECK_CM_NUM:
/*
         MAKE SURE CM# IN RESPONSE PACKET IS THE SAME AS IN THE
         READ COMMAND.
                                                                   */
         IF CM_RESP_PACKET.SLAVE_ADDR ~= CM_CMD_PACKET2.SLAVE_ADDR
            THEN DO;
              CALL TCE$ERRMSG(TCL#WRONG_CM);
              GOTO RELEASE_CM;    /* BR TO RELEASE CM */
            END;
%EJECT;
/*
              ******************************************
              *                                        *
              *    THIS ROUTINE SENDS THE FIRMWARE     *
              *        DATA TO THE SELECTED CM         *
              *                                        *
              ******************************************
                                                                   */
LOAD_CM_FIRMWARE:
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWWRT;
         CALL BUILD_DCWLST (IDCW1, VECTOR(WRT_PACKET), IDCW2,
                            VECTOR(FW_BUFFER))  ALTRET(RELEASE_CM);
         IF IO_STATUS.MAJOR = BITBIN('00'O) AND
            IO_STATUS.MINOR = '000000'B
            THEN GOTO READ_LOAD_RESPONSE;
            ELSE DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT) ;
               CALL TCE$ERRMSG(TCL#FW_WRITE_ERROR,, VECTOR(STATUS_TEXT),
                               VECTOR(CM_NN));
               GOTO RELEASE_CM;         /* READ REM RESPONSES & RELEASE CM */
            END;
%EJECT;
/*
              ******************************************
              *                                        *
              *           READ LOAD RESPONSE           *
              *                                        *
              *   CHECK THE STATUS AFTER THE IML FW    *
              * LOAD SEQUENCE HAS BEEN INITIATED.  THE *
              *    INITIAL STATUS SHOULD BE BUSY.      *
              ******************************************
                                                                   */
READ_LOAD_RESPONSE:
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWREAD;
         CALL BUILD_DCWLST (IDCW1, VECTOR(RESP_PACKET), IDCW2,
                            VECTOR(CM_RESP_PACKET));
         IF IO_STATUS.MAJOR = BITBIN('01'O) AND   /* STATUS = BUSY? */
            IO_STATUS.MINOR = '000001'B
            THEN GOTO SET_TIMEOUT;
         IF (IO_STATUS.MAJOR = BITBIN('00'O) AND IO_STATUS.MINOR = '000000'B)
            THEN GOTO CHECK_PACKET;
            ELSE DO;
              CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
              CALL TCE$ERRMSG(TCL#IML_LOAD_FAILURE,, VECTOR(STATUS_TEXT),
                              VECTOR(CM_NN));
              GOTO RELEASE_CM;  /* READ REM RESPONSES & RELEASE CM */
            END;
%EJECT;
/*
              ******************************************
              *                                        *
              *    SET TIMEOUT & READ FOR RESPONSES    *
              *                                        *
              *   READ FOR CM RESPONSE EVERY 10 SECS   *
              *  UNTIL IML LOAD IS COMPLETE (IO_STATUS *
              *    ~= BUSY). LOAD SHOULD COMPLETE IN   *
              *              < 5 MINS                  *
              ******************************************
                                                                   */
SET_TIMEOUT:
         CALL TCE$ERRMSG(TCL#LOAD_IN_PROCESS,, VECTOR(CM_NN));
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWREAD;
         FPT_WAIT.V.UNITS# = 10 ;
         DO I = 1 TO 30;
            CALL M$WAIT (FPT_WAIT);        /* WAIT FOR 10 SECS */
            CALL BUILD_DCWLST(IDCW1, VECTOR(RESP_PACKET), IDCW2,
                              VECTOR(CM_RESP_PACKET));
            IF (IO_STATUS.MAJOR = BITBIN('00'O) AND
                    IO_STATUS.MINOR = '000000'B)
               THEN GOTO CHECK_PACKET;
         END;  /* DO I */
         CALL TCE$ERRMSG (TCL#IML_TIMEOUT,, VECTOR(CM_NN));
         GOTO RELEASE_CM;    /* READ REM RESPONSES & RELEASE CM */
CHECK_PACKET:
/*
           DETERMINE IF AN ASYNCHRONOUS INTERRUPT WAS RECEIVED
           FROM THE CM
                                                                    */
           IF CM_RESP_PACKET.PACKET_TYPE = '02' AND     /* TYPE 02 = ASYNC INT */
              CM_RESP_PACKET.OP_CODE = 'FF' AND
              CM_RESP_PACKET.RESP_TYPE = '4'
              THEN DO;
/*               AN ASYNCHRONOUS EVENT HAS OCCURRED- NOW CHECK CM's MAJOR
                 STATUS AND SUBSTATUS TO SEE IF CM IS "READY"
                                                                    */
                 IF CM_RESP_PACKET.MAJOR_STATUS = '40' AND
                    CM_RESP_PACKET.SUBSTATUS_PARAMS.ID = '16' AND
                    CM_RESP_PACKET.SUBSTATUS_PARAMS.SUBSTATUS = '60'
                    THEN GOTO READ_REMAINING;    /* BR IF IML LOAD COMPLETE */
              END;
           CALL ANALYZE_PACKET;               /* ANALYZE UNEXPECTED PACKET TYPE */
           CALL TCE$ERRMSG(TCL#IML_LOAD_INCOMPLETE,, VECTOR(CM_NN));
           GOTO RELEASE_CM;
%EJECT;
/*
              ******************************************
              *                                        *
              *        READ REMAINING RESPONSES        *
              *                                        *
              *            READ REPONSES FOR           *
              *    EACH DEVICE (TO CLEAR THE STACK).   *
              * THE CM WILL GO BUSY WHEN ALL ARE READ. *
              ******************************************
                                                                    */
READ_REMAINING:
        FPT_WAIT.V.UNITS# = 4 ;
        CALL M$WAIT ( FPT_WAIT ) ;
           IDCW1 = %IDCWMPF;
           IDCW2 = %IDCWREAD;
            DO  I = 0 TO 9 ;
                DO  K = 0 TO 4 ;
                    CALL BUILD_DCWLST ( IDCW1, VECTOR(RESP_PACKET),
                                        IDCW2, VECTOR(CM_RESP_PACKET) ) ;
                    IF  IO_STATUS.MAJOR = BITBIN('00'O)
                    AND IO_STATUS.MINOR =        '00'O
                    THEN
                        GOTO NEXT_RESPONSE ;
                    ELSE IF  IO_STATUS.MAJOR = BITBIN('01'O)
                         AND IO_STATUS.MINOR =        '01'O
                    THEN DO ;
                        FPT_WAIT.V.UNITS# = 4 ;
                        CALL M$WAIT ( FPT_WAIT ) ;
                        END ;
                    ELSE DO ;
                        CALL CONVERT_STATUS ( STATUS, STATUS_TEXT ) ;
                        CALL TCE$ERRMSG ( TCL#BAD_STATUS_RESP, ,
                                          VECTOR(STATUS_TEXT),
                                          VECTOR(CM_NN) ) ;
                        GOTO RELEASE_CM ;
                        END ;
                    END ;
 
 
NEXT_RESPONSE:
                END ;
            IF  IO_STATUS.MAJOR ~= BITBIN('01'O)
            OR  IO_STATUS.MINOR ~=        '01'O
            THEN DO ;
                CALL CONVERT_STATUS ( STATUS, STATUS_TEXT ) ;
                CALL TCE$ERRMSG ( TCL#CM_NOT_BUSY, ,
                                  VECTOR(CM_NN),
                                  VECTOR(STATUS_TEXT) ) ;
                GOTO RELEASE_CM ;
                END ;
%EJECT;
/*
              ******************************************
              *                                        *
              *        ISSUE CM F/W REV IPI CMD        *
              *             AFTER IML LOAD             *
              *                                        *
              *     REQUEST TO CM FOR F/W REVISION     *
              ******************************************
                                                                    */
READ_CURRENT_FW_REV:
         CALL READ_FW_REV (FW_REVISION(1)) ALTRET(RELEASE_CM);
         IF TCM_PIT.FW.LABEL.REV = FW_REVISION.REV(1)
            THEN TCM_PIT.CM.FLAGS.FW_LOADED(J) = '1'B;  /* F/W LOAD SUCCESSFUL */
%EJECT;
/*
              ******************************************
              *                                        *
              *               RELEASE CM               *
              *                                        *
              *         CHECK FOR READY STATUS         *
              ******************************************
                                                                    */
RELEASE_CM:
         IDCW1 = %IDCWMPF;
         CALL BUILD_DCWLST(IDCW1, VECTOR(REL_PACKET));
         IF NOT (IO_STATUS.MAJOR = BITBIN('00'O) AND
                 IO_STATUS.MINOR = '000000'B AND
                 IO_STATUS.IOM = '00'O)    /* STATUS ~= READY? */
                 THEN DO;
                    CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
                    CALL TCE$ERRMSG (TCL#RELEASE_ERR,, VECTOR(CM_NN),
                                     VECTOR(STATUS_TEXT));
                 END;
%EJECT;
/*
              ******************************************
              *                                        *
              *          LOGICAL RESET TO CM           *
              *                                        *
              ******************************************
                                                                    */
EXECUTE_RESET:
         IF NOT TCM_PIT.CM.FLAGS.FW_LOADED(J)
            THEN GOTO POWER_ON_RESET;
         CALL TCE$ERRMSG(TCL#REV_MESSAGE,, VECTOR(FW_REVISION(0)),
                           VECTOR(FW_REVISION(1)));
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWWRT;
         RESET_PACKET.RESET_TYPE = '2';        /* LOGICAL RESET */
         CALL BUILD_DCWLST (IDCW1, VECTOR(CMD_PACKET), IDCW2,
                            VECTOR(RESET_PACKET));
         IF NOT (IO_STATUS.MAJOR = BITBIN('00'O) AND
                 IO_STATUS.MINOR = '000000'B)
            THEN DO;                       /* STATUS ~= READY */
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCL#BAD_RESET_STATUS,, VECTOR(STATUS_TEXT),
                                VECTOR(CM_NN));
            END;
            FPT_WAIT.V.UNITS# = 10 ;
            CALL M$WAIT ( FPT_WAIT ) ;
         GOTO NEXT_CM;
%EJECT;
/*
              ******************************************
              *                                        *
              *         POWER-ON RESET TO CM           *
              *                                        *
              ******************************************
                                                                    */
POWER_ON_RESET:                         /* F/W NOT LOADED */
         CALL TCE$ERRMSG (TCL#RESET_MSG,, VECTOR(CM_NN));
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWWRT;
         RESET_PACKET.RESET_TYPE = '4';        /* POWER-ON RESET */
         CALL BUILD_DCWLST (IDCW1, VECTOR(CMD_PACKET), IDCW2,
                            VECTOR(RESET_PACKET));
         IF (IO_STATUS.MAJOR = BITBIN('00'O) AND
                 IO_STATUS.MINOR = '000000'B)
            THEN CALL TCE$ERRMSG (TCL#RESET_COMPLETE,, VECTOR(CM_NN));
            ELSE DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCL#BAD_POWER_ON,, VECTOR(STATUS_TEXT),
                                VECTOR(CM_NN));
            END;
NEXT_CM:
        ;
%EJECT;
/*
              ******************************************
              *                                        *
              *           RELEASE IPC CHANNEL          *
              *          (OPPOSITE OF SUSPEND)         *
              *                                        *
              *         CHECK FOR READY STATUS         *
              ******************************************
                                                                    */
RELEASE_IPC:
   IF TCM_PIT.DCNN.FLAGS.SUSPEND       /* IS SUSPEND FLAG SET? */
      THEN DO;
         IDCW1 = %IDCWREL;             /* YES */
         CALL BUILD_DCWLST (IDCW1);           /* GO TO RELEASE THE IPC */
         IF NOT (IO_STATUS.MAJOR = BITBIN('00'O) AND
                 IO_STATUS.MINOR = '000000'B AND
                 IO_STATUS.IOM = '00'O)
            THEN DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCL#UNABLE_TO_RELEASE,, VECTOR(STATUS_TEXT),
                                VECTOR(DCNN));
               END;
            ELSE TCM_PIT.DCNN.FLAGS.SUSPEND = '0'B;   /* CLEAR FLAG */
      END;
            FPT_WAIT.V.UNITS# = 120 ;
            CALL M$WAIT ( FPT_WAIT ) ;
            END ; /* IF CM.LOAD.NUM(J) */
        END ; /* DO J = 0 TO 7 */
   TCM_PIT.FLAGS.FWLIP# = '0'B;        /* RESET F/W LOAD IN PROGRESS FLAG */
   CALL TCE$ERRMSG(TCL#IPC_REBOOT);
   CALL M$TDCLOSE(FPT_TDCLOSE) ALTRET(ERR_RTN);
   CALL XUG$ENABLE (XUG_GETCMD);       /* ENABLE BREAKS */
   RETURN;
ERR_CONFIG:
   RETURN;
ERR_RTN:
   CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR, B$TCB.ALT$ -> B$ALT.DCB#);
   RETURN;
%EJECT;
/*F*
NAME:           CONVERT_STATUS
 
PURPOSE:        To convert I/O Termination status to ASCII format
                                                                   */
/*D*
NAME:           CONVERT_STATUS
 
CALL:           CALL CONVERT_STATUS ( param1, param2 );
 
PARAMETERS:
                                                                   */
/*K*
param1           is the 2-word I/O status in octal format
                                                                   */
/*K*
param2           is a TEXTC string containing the converted ASCII status
                                                                   */
/*D*
DESCRIPTION:
 
The CONVERT_STATUS procedure is used to convert the I/O termination
status from octal to ASCII format.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
CONVERT_STATUS:  PROC ( STATUS_OCT, STATUS_TEXT );
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 STATUS_OCT        PARAM ALIGNED,
            2 WORD1(0:11)       UBIN(3) UNAL,
            2 WORD2(0:11)       UBIN(3) UNAL;
        DCL 1 STATUS_TEXT       PARAM,
            2 LEN               UBIN BYTE CALIGNED,
            2 TEXT              CHAR(25) UNAL,
            2 ASCII(0:24)       REDEF TEXT CHAR(1) UNAL;
/********************** LOCAL DATA REFERENCES ***********************/
        DCL I                   UBIN;
        DCL K                   UBIN;
        DCL 1 NUMBER            STATIC,
            2 ASCII             CHAR(8) UNAL INIT('01234567'),
            2 N(0:7)            REDEF ASCII CHAR(1) UNAL;
%EJECT;
/********************** PROCEDURE **********************************/
/*
              ******************************************
              *                                        *
              *   CONVERT I/O STATUS IN OCTAL FORMAT   *
              *                                        *
              *            TO ASCII FORMAT             *
              ******************************************
                                                                    */
         STATUS_TEXT.TEXT = ' ';
         DO I = 0 TO 11;
            K = STATUS_OCT.WORD1(I);
            STATUS_TEXT.ASCII(I) = NUMBER.N(K);
         END;
         DO I = 0 TO 11;
            K = STATUS_OCT.WORD2(I);
            STATUS_TEXT.ASCII (I+13) = NUMBER.N(K);
         END;
         STATUS_TEXT.LEN = SIZEC(STATUS_TEXT.ASCII);
         RETURN;
END CONVERT_STATUS;
%EJECT;
/*F*
NAME:           READ_FW_REV
 
PURPOSE:        To issue a read request to the CM for its F/W revision
                                                                   */
/*D*
NAME:           READ_FW_REV
 
CALL:           CALL READ_FW_REV ( buf ) ALTRET ( addr );
 
PARAMETERS:
                                                                   */
/*K*
buf              is a TEXTC string which will contain the F/W revision
                                                                   */
/*D*
DESCRIPTION:
 
The READ_FW_REV procedure issues a read (for attributes) to the CM
for its F/W revision.  The F/W date and revision number are returned
to the calling program in a TEXTC string.  READ_FW_REV calls
BUILD_DCWLST to do the I/O, but does its own examination of the
termination status.  If an unexpected status is returned, READ_FW_REV
does an ALTRETURN to the calling program.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
READ_FW_REV:  PROC ( FW_REV ) ALTRET;
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 FW_REV            PARAM,
            2 LEN               UBIN BYTE CALIGNED,
            2 ASCII             CHAR(9) UNAL,
            2 TEXT              REDEF ASCII,
              3 MON             CHAR(2) UNAL,
              3 DAY             CHAR(2) UNAL,
              3 YR              CHAR(2) UNAL,
              3 *               CHAR(1) UNAL,
              3 REV             CHAR(2) UNAL;
%EJECT;
/********************** PROCEDURE **********************************/
/*
              ******************************************
              *                                        *
              *      ISSUE CM F/W REVISION IPI CMD     *
              *                                        *
              *   READ REQUEST TO CM FOR F/W REVISION  *
              ******************************************
                                                                    */
         CM_CMD_PACKET1.CM = CM_NN.NAME;
         CM_CMD_PACKET1.SLAVE_ADDR.CM = CM_NN.NAME;
         IDCW1 =%IDCWMPF;
         IDCW2 = %IDCWWRT;
         CALL BUILD_DCWLST(IDCW1, VECTOR(CMD_PACKET), IDCW2,
                     VECTOR(CM_CMD_PACKET1));
         IF IO_STATUS.MAJOR = BITBIN('00'O) AND   /* STATUS = READY? */
            IO_STATUS.MINOR = '000000'B AND
            IO_STATUS.IOM = '00'O
            THEN GOTO READ_REVISION;
            ELSE DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCL#BAD_STATUS_REV,,
                                VECTOR(STATUS_TEXT),
                                VECTOR(CM_NN));
               ALTRETURN;                  /* BR TO RELEASE CM & EXIT */
            END;
%EJECT;
/*
              ******************************************
              *                                        *
              *    READ CM FIRMWARE REVISION           *
              *                                        *
              *  AND STORE IN ENDTEST MESSAGE          *
              ******************************************
                                                                   */
READ_REVISION:
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWREAD;
/*
         ISSUE IPI PACKET TO READ CM REV
                                                                    */
         CALL BUILD_DCWLST (IDCW1, VECTOR(RESP_PACKET), IDCW2,
                      VECTOR(CM_RESP_PACKET));
         IF IO_STATUS.MAJOR = BITBIN('00'O) AND   /* STATUS = READY? */
            IO_STATUS.MINOR = '000000'B AND
            IO_STATUS.IOM = '00'O
            THEN GOTO CHECK_PACKET_TYPE;
            ELSE DO;
              CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
              CALL TCE$ERRMSG (TCL#BAD_REV_RESP,,
                               VECTOR(STATUS_TEXT),
                               VECTOR(CM_NN));
              ALTRETURN;            /* BR TO RELEASE CM */
            END;
%EJECT;
/*
              ******************************************
              *           CHECK PACKET TYPE            *
              *                                        *
              *    IF PACKET_TYPE = '02' THIS IS A     *
              *          RESPONSE PACKET.              *
              ******************************************
                                                                     */
CHECK_PACKET_TYPE:
         IF (CM_RESP_PACKET.PACKET_TYPE = '02' AND
             CM_RESP_PACKET.OP_CODE = CM_CMD_PACKET1.OP_CODE)  /* EXPECTED PACKET TYPE */
            THEN GOTO CHECK_CM_NUMBER;
            ELSE DO;
               CALL ANALYZE_PACKET;
               CALL TCE$ERRMSG(TCL#NO_RESPONSE,,VECTOR(CM_NN));
               ALTRETURN;           /* BR TO RELEASE CM */
            END;
%EJECT;
CHECK_CM_NUMBER:
/*
         MAKE SURE CM# IN RESPONSE PACKET IS THE SAME AS IN THE
         READ COMMAND.
                                                                   */
         IF CM_RESP_PACKET.SLAVE_ADDR ~= CM_CMD_PACKET1.SLAVE_ADDR
            THEN DO;
              CALL TCE$ERRMSG(TCL#WRONG_CM);
              ALTRETURN;    /* BR TO RELEASE CM */
            END;
         IF CM_RESP_PACKET.MAJOR_STATUS = '00' AND
            CM_RESP_PACKET.RESP_TYPE = '1'    /* STANDARD COMPLETION TYPE = 1 */
            THEN GOTO CHECK_MAJOR_STATUS;
               ELSE DO;
                  CALL TCE$ERRMSG(TCL#NOT_STD_COMP,, VECTOR(CM_NN));
                  ALTRETURN;  /*  BR TO RELEASE CM  */
               END;
CHECK_MAJOR_STATUS:
         IF CM_RESP_PACKET.M_STATUS = '8'     /* MAJOR STATUS = 8 (SUCCESSFUL) */
            THEN GOTO GET_REV_DATE;
            ELSE DO;
               CALL TCE$ERRMSG(TCL#NO_SUCCESS,, VECTOR(CM_NN));
               ALTRETURN;     /*  BR TO RELEASE CM   */
            END;
GET_REV_DATE:
         FW_REV.ASCII = ' ';
         FW_REV.TEXT.MON = CM_RESP_PACKET.VENDOR_ID.MON;
         FW_REV.TEXT.DAY = CM_RESP_PACKET.VENDOR_ID.DAY;
         FW_REV.TEXT.YR = CM_RESP_PACKET.VENDOR_ID.YR;
         FW_REV.TEXT.REV = CM_RESP_PACKET.VENDOR_ID.REV_NUM;
         FW_REV.LEN = SIZEC(FW_REV.TEXT);
         RETURN;
END READ_FW_REV;
%EJECT;
/*F*
NAME:           ANALYZE_PACKET
 
PURPOSE:        To analyze a non-standard packet returned from the CM
                                                                   */
/*D*
NAME:           ANALYZE_PACKET
 
CALL:           CALL ANALYZE_PACKET ;
 
                                                                   */
/*D*
DESCRIPTION:
 
ANALYZE_PACKET attempts to analyze a packet returned by the CM
for error conditions.  The packet is checked for a microcode exception
error code or a command reject.  If neither are detected, the packet
is dumped to the user's terminal for manual analysis.
                                                                   */
/********************** ENTRY POINT ********************************/
ANALYZE_PACKET:  PROC ;
/********************** INCLUDE FILES *****************************/
        %INCLUDE                XU_FORMAT_C;
/**********************DCB REFERENCES *****************************/
        DCL 1 M$LO              DCB;
/********************** EXTERNAL PROCEDURE REFERENCES *************/
        %INCLUDE                XUF_ENTRY;
/********************** LOCAL DATA REFERENCES *********************/
        DCL 1 BUF               CHAR(81) CALIGNED STATIC;
        DCL 1 P_BUF1            CHAR(50);
        DCL 1 P_BUF2            CHAR(50);
        DCL 1 P_BUF3            CHAR(50);
        %F_FDS                  (NAME=FDS, STCLASS=STATIC, BUF=BUF,
                                DCB=M$LO);
        DCL 1 PACKET_FMT        CALIGNED CONSTANT,
            2 * CHAR(0) INIT('%2/UNEXPECTED PACKET: %A%/'),
            2 * CHAR(0) INIT('%19X%A%/'),
            2 * CHAR(0) INIT('%19X%A%/');
        %EJECT ;
/********************** PROCEDURE **********************************/
/*
              ******************************************
              *                                        *
              *      CHECK THE RETURNED PACKET FOR     *
              *                                        *
              *  COMMAND REJECT OR MICROCODE EXCEPTION *
              ******************************************
                                                                    */
         IF (CM_RESP_PACKET.PACKET_TYPE = '01' AND    /* TYPE 01 = CMD REJECT */
             CM_RESP_PACKET.CM = CM_NUMBER.N(J+8))
             THEN DO;
                CALL TCE$ERRMSG(TCL#CMD_REJECT,, VECTOR(CM_NN));
                RETURN;
             END;
          IF (CM_RESP_PACKET.PACKET_TYPE = '02' AND
              CM_RESP_PACKET.OP_CODE = 'FF' AND
              CM_RESP_PACKET.RESP_TYPE = '4')      /* TYPE 02 = ASYNC INT */
              THEN DO;
/*
              CHECK FOR A MICROCODE EXCEPTION ERROR
                                                                    */
                 IF ( CM_RESP_PACKET.MAJOR_STATUS = '08' AND     /* MICROCODE EXCEPTION */
                    CM_RESP_PACKET.SUBSTATUS_PARAMS.ID = '13')
                    THEN DO;
                       ERROR_TEXT.ASCII = CM_RESP_PACKET.SUBSTATUS_PARAMS.MICRO_ERR;
                       ERROR_TEXT.LEN = SIZEC(ERROR_TEXT.ASCII);
                       CALL TCE$ERRMSG (TCL#MICRO_ERROR,, VECTOR(CM_NN),
                                        VECTOR(ERROR_TEXT));
                       RETURN;
                    END;
              END;
           P_BUF1 = SUBSTR(UNEXP_PACKET, 0, 50);
           P_BUF2 = SUBSTR(UNEXP_PACKET, 50, 50);
           P_BUF3 = SUBSTR(UNEXP_PACKET, 100, 50);
           CALL X$WRITE(FDS, VECTOR(PACKET_FMT), VECTOR(P_BUF1),
                        VECTOR(P_BUF2), VECTOR(P_BUF3));
           RETURN;
END ANALYZE_PACKET;
%EJECT;
/*F*
NAME:           BUILD_DCWLST
 
PURPOSE:        To build IDCW lists and issue M$TDIO
                                                                   */
/*D*
NAME:           BUILD_DCWLST
 
CALL:           CALL BUILD_DCWLST ( idcw1, [d1_], [idcw2], [d2_] );
 
PARAMETERS:
                                                                   */
/*K*
idcw1            is a UBIN WORD containing the first IDCW command
        to be issued.
                                                                   */
/*K*
d1_             is a VECTOR that frames the data to be specified in
        the first DCW word.  The default is NIL.
                                                                   */
/*K*
idcw2            is a UBIN WORD containing the second IDCW command
        to be issued.
                                                                   */
/*K*
d2_             is a VECTOR that frames the data to be specified in
        the second DCW word.  The default is NIL.
                                                                   */
/*D*
DESCRIPTION:
 
The BUILD_DCWLST procedure is used to build the IDCW lists and issue the
M$TDIO monitor call to perform I/O to the IPC controller and its
slave CMs.  The IDCW words passed will contain the op codes and
the basic IDCW structure.  The M$TDIO call is issued with a wait.
Upon completion of the M$TDIO, control is returned to the calling
routine where checking of termination status is performed.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
BUILD_DCWLST:  PROC ( IDCW1, DATA1_, IDCW2, DATA2_ ) ALTRET;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
/********************** DCB REFERENCES ****************************/
        DCL F$TDIO              DCB;
/********************** EXTERNAL DATA REFERENCES *******************/
        %TCM_PIT ;
        %TCM_IDCW               (NAME=IDCW, LVL=1, STCLASS="BASED(D$)");
        %TCM_DCW                (NAME=DCW, LVL=1, STCLASS="BASED(D$)");
        DCL DCWLIST(0:19)       UBIN BASED(DCW$);
        DCL PACKET_DATA CHAR(400) BASED;
/********************** LOCAL DATA REFERENCES **********************/
        %VLP_VECTOR             (FPTN=DCWLIST_);  /* VECTOR TO PASS TO TDIO */
        %VLP_VECTOR             (FPTN=PACKET_);  /* VECTOR FRAMING PACKETS */
        DCL D$                  PTR;  /* POINTS TO CURRENT ENTRY IN DCWLIST */
        DCL P$                  PTR;  /* POINTS TO CURRENT PACKET ENTRY IN STK */
        DCL BYTE_CNT            SBIN;
        DCL I                   UBIN;
        DCL 1 POINTER$ PTR;
        DCL 1 WORD$ REDEF POINTER$,
            2 OFFSET UBIN(18) UNAL,
            2 SEGID UBIN(18) UNAL;
        DCL 1 LEN UBIN;
        DCL 1 LEN_SBIN REDEF LEN SBIN;
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 IDCW1             BIT(36) DALIGNED PARAM;
        DCL 1 DATA1_            VECTOR ALIGNED PARAM ;
        DCL 1 IDCW2             BIT(36) ALIGNED PARAM;
        DCL 1 DATA2_            VECTOR ALIGNED PARAM ;
%EJECT;
/********************** PROCEDURE **********************************/
   D$ =DCW$;                 /* INITIALIZE PTRS TO BEGINNING OF AREAS */
   P$ = PACKET$;
   DO I = 0 TO 19;           /* CLEAR STACKS */
      DCWLIST(I) = 0;
   END;
   PACKET$ -> PACKET_DATA = ' ';
   DCWLIST_ = TCM_PIT.FW.SEG_;    /* INITIALIZE VECTOR FRAMING DCWLIST */
   BYTE_CNT = 0;
   IDCW = IDCW1;                 /* PUT 1ST IDCW INTO LIST */
   BYTE_CNT = BYTE_CNT + 4;
   IF ADDR(IDCW2) ~= ADDR(NIL)
      THEN IDCW.CONT = '1'B;     /* SET CONTINUE BIT */
   D$ = PINCRW(D$, 1);           /* BUMP PTR TO NEXT WORD IN DCWLIST */
   IF ADDR(DATA1_) ~= ADDR(NIL)
      THEN DO;
         PACKET_ = DATA1_;
         LEN = PACKET_.W1.VSIZE# + 1;      /* LENGTH OF PACKET IN BYTES */
/*
         MOVE PACKET INTO STACK IN DATA SEGMENT
                                                                     */
         SUBSTR(P$ -> PACKET_DATA, 0, LEN) =
               SUBSTR(PACKET_.PTR$ -> PACKET_DATA, 0, LEN);
         POINTER$ = P$;                    /* CURRENT LOCATION IN STK */
         DCW.FWA = WORD$.OFFSET;
         LEN_SBIN = LEN_SBIN/4;
         DCW.TALLY = LEN;
         P$ = PINCRW(P$, LEN);          /* BUMP POINTER TO NEXT ENTRY IN STK */
         END;
      ELSE DCW = '000000000000'O;
      BYTE_CNT = BYTE_CNT +4;
      D$ = PINCRW(D$, 1);               /* BUMP POINTER TO NEXT ENTRY IN DCWLIST */
   IF ADDR(IDCW2) ~= ADDR(NIL)
      THEN DO;
        IDCW = IDCW2;                  /* MOVE IDCW 2 INTO DCWLIST */
        BYTE_CNT = BYTE_CNT + 4;
        D$ = PINCRW(D$, 1);
        IF ADDR(DATA2_) ~= ADDR(NIL)
           THEN DO;
             PACKET_ = DATA2_;
             POINTER$ = PACKET_.PTR$;
             IF POINTER$ = FW$
                THEN DO;                          /* THIS IS THE FW BUFFER */
                  LEN = TCM_PIT.FW.NWORDS;
                  DO WHILE LEN > 4096;
                     POINTER$ = FW$;
                     DCW.FWA = WORD$.OFFSET;
                     DCW.TYPE = BITBIN('1'O);     /* CONTINUE BIT */
                     BYTE_CNT = BYTE_CNT + 4;
                     D$ = PINCRW(D$, 1);
                     IF POFFW( D$, PACKET$ ) >= 0       /* TEST D$ FOR OVERFLOW */
                        THEN DO;
                           CALL TCE$ERRMSG (TCL#INTERNAL_ERR);
                           ALTRETURN;
                        END;
                     FW$ =PINCRW(FW$, 4096);
                     LEN = LEN - 4096;
                  END;  /* DO WHILE */
                  POINTER$ = FW$;
                  DCW.FWA = WORD$.OFFSET;
                  DCW.TALLY = LEN;
                  BYTE_CNT = BYTE_CNT + 4;
                  GOTO ISSUE_IO;
                END;   /* IF POINTER$ = FW$ */
             IF POINTER$ = RDBUF$
                THEN DO;                          /* THIS IS THE RESPONSE BUFFER */
                  DCW.FWA = WORD$.OFFSET;
                  DCW.TALLY = 64;
                  BYTE_CNT = BYTE_CNT + 4;
                END;
                ELSE DO;                          /* THIS IS A CMD PACKET */
                  LEN = PACKET_.W1.VSIZE# + 1;
                  SUBSTR(P$ -> PACKET_DATA, 0, LEN) =
                       SUBSTR(PACKET_.PTR$ -> PACKET_DATA,0,LEN);
                  POINTER$ = P$;
                  DCW.FWA = WORD$.OFFSET;
                  LEN_SBIN = LEN_SBIN/4;
                  DCW.TALLY = LEN;
                  BYTE_CNT = BYTE_CNT + 4;
                END;
           END;  /* IF ADDR(DATA2_) */
      END;  /* IF ADDR(IDCW2) */
ISSUE_IO:
   DCWLIST_.W1.VSIZE# = BYTE_CNT - 1 ;
   FPT_TDIO.DCWLIST_ = DCWLIST_;
   CALL M$TDIO(FPT_TDIO) ALTRET(ERR_RTN2);
   RETURN;
ERR_RTN2:
   CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR, B$TCB.ALT$ -> B$ALT.DCB#);
   RETURN;
END BUILD_DCWLST;
END TCL$LOAD;
%EOD;
/*M* TCN$NOT_IMPLEMENTED - Not implemented error processing        */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCN$NOT_IMPLEMENTED
 
PURPOSE:        To report the not implemented error message.
                                                                   */
/*D*
NAME:           TCN$NOT_IMPLEMENTED
 
CALL:           CALL TCN$NOT_IMPLEMENTED ( node$, out$, f2_ ) ;
 
PARAMETERS:
                                                                   */
/*K*
node$           is a PTR constant that points to the root node
        of the nodes that are defined for this parse operation.
                                                                   */
/*K*
out$            is a PTR to a parse output block of the node that
        has been parsed but has not been implemented yet.
                                                                   */
/*K*
f2_             is a VECTOR constant that frames the second string
        replacement for the "not yet implemented" error message.
                                                                   */
/*D*
DESCRIPTION:
 
The TCN$NOT_IMPLMENETED procedure is used to report the "not yet
implemented" error message.  This error message is used for both
commands and options.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCN$NOT_IMPLEMENTED:    PROC ( NODE$, OUT$, F2_ ) ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CP_6_SUBS ;
        %INCLUDE                CMLOAD_C61 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                XU_SUBS_C ;
        %INCLUDE                XU_MACRO_C ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %PARSE$OUT              ( NAME = OUT$BLK
                                , STCLASS = BASED
                                                                ) ;
        %P$LIT                  ( NAME = P$LIT
                                , STCLASS = BASED
                                                                ) ;
        %P$NODE                 ( NAME = P$NODE
                                , STCLASS = BASED
                                                                ) ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*
F1              is a VLP_NAME structure that is used to build the
        first error message substitution value.
                                                                   */
        %VLP_NAME               ( FPTN = F1
                                , STCLASS = AUTO
                                , LEN = 256
                                                                ) ;
/*
F1_             is a VECTOR that is used to frame the first error
        substitution value.  This value is derived from the input
        that was parsed.
                                                                   */
        DCL 1 F1_               VECTOR ALIGNED AUTO ;
/*
I               is a UBIN WORD that is used as a DO loop index.
                                                                   */
        DCL 1 I                 UBIN WORD ALIGNED AUTO ;
/*
J               is a UBIN WORD that is used as a DO loop index.
                                                                   */
        DCL 1 J                 UBIN WORD ALIGNED AUTO ;
/*
N1              is a UBIN WORD that is used as a DO loop limit.
                                                                   */
        DCL 1 N1                UBIN WORD ALIGNED AUTO ;
/*
N2              is a UBIN WORD that is used as a DO loop limit.
                                                                   */
        DCL 1 N2                UBIN WORD ALIGNED AUTO ;
/*
SUB1$           is a PTR that is used to base the first level of
        subnodes.
                                                                   */
        DCL 1 SUB1$             PTR ALIGNED AUTO ;
/*
SUB2$           is a PTR that isused to base the second level of
        subnodes.
                                                                   */
        DCL 1 SUB2$             PTR ALIGNED AUTO ;
/*
TEXTC           is a based VLP_NAMEV structure that is used to
        calculate the length of the first substitution vector.
                                                                   */
        %VLP_NAMEV              ( FPTN = TEXTC
                                , STCLASS = BASED
                                                                ) ;
/*B*
TCN#NOT_IMPLEMENTED     is a VLP_ERRCODE that is used to report the
        "not yet implemented" error message.
                                                                   */
/*E*
ERROR:  TCN-E$TCM#NOT_IMPLEMENTED-3
MESSAGE0:"%U1" %U2 not implemented yet.
                                                                   */
        %VLP_ERRCODE            ( FPTN = TCN#NOT_IMPLEMENTED
                                , STCLASS = CONSTANT
                                , ERR# = %E$TCM#NOT_IMPLEMENTED
                                , FCG = %TCM#FCG
                                , MID = 'N'
                                , MON = %NO#
                                , SEV = 3
                                                                ) ;
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 NODE$             PTR PARAM ;
        DCL 1 OUT$              PTR PARAM ;
        DCL 1 F2_               VECTOR ALIGNED PARAM ;
/********************** PROCEDURE **********************************/
/*
Initialize the first substitution vector to VECTOR ( NIL ) in case
the substitution vector cannot be found in the node structure.
                                                                   */
        F1_ = VECTOR ( NIL ) ;
/*
Determine the number of nodes in this node structure.  Then
loop thru all nodes.
                                                                   */
        N1 = NODE$ -> P$NODE.NSUBNDS - 1 ;
N1:     DO  I = 0 TO N1 BY +1 ;
/*
Search for a node with a code equal to the node that has been
parsed but not implemented yet.
                                                                   */
            SUB1$ = NODE$ -> P$NODE.SUBNDS$(I) ;
            IF  SUB1$ -> P$NODE.CODE = OUT$ -> OUT$BLK.CODE  THEN DO ;
/*
Determine if this node is a concatentation node.  If so, concatenate
all of the literal subnodes as the first substitution value.  Set
the vector to frame this literal and exit this loop to report the
error message.
                                                                   */
                IF  SUB1$ -> P$NODE.TYPE = %TYPE_KONCAT#  AND
                    SUB1$ -> P$NODE.NSUBNDS > 0           THEN DO ;
                    N2 = SUB1$ -> P$NODE.NSUBNDS - 1 ;
                    F1.L# = 0 ;
N2:                 DO  J = 0 TO N2 BY +1 ;
                        SUB2$ = SUB1$ -> P$NODE.SUBNDS$(J) ;
                        IF  SUB2$ -> P$NODE.TYPE = %TYPE_LITERAL#
                        THEN DO ;
                            SUBSTR ( F1.NAME#, F1.L# ) =
                            SUBSTR ( SUB2$ -> P$LIT.TEXT,
                                     0,
                                     SUB2$ -> P$LIT.COUNT ) ;
                            F1.L# = F1.L# + SUB2$ -> P$LIT.COUNT ;
                            END ;
                        END N2 ;
                    IF  F1.L# > 0  THEN
                        F1_ = VECTOR ( ADDR ( F1 ) -> TEXTC ) ;
                    EXIT N1 ;
                    END ;
/*
If this node is a literal node, use the literal as the first
substitution value.  Set the vector to frame this literal and exit
this loop to report the error message.
                                                                   */
                ELSE IF  SUB1$ -> P$NODE.TYPE = %TYPE_LITERAL#
                THEN DO ;
                    F1_ = VECTOR ( ADDR ( SUB1$ -> P$LIT.COUNT ) ->
                                   TEXTC                        ) ;
                    EXIT N1 ;
                    END ;
/*
Otherwise, this node is malformed in the PARTRGE metalanguage.
Merely exit the loop and use the null vector as the first
substitution vector.
                                                                   */
                ELSE
                    EXIT N1 ;
            END ;
        END N1 ;
/*
Output the error message with the subsitution string that was
(or maybe wasn't) found.
                                                                   */
        CALL TCE$ERRMSG ( TCN#NOT_IMPLEMENTED, , F1_, F2_ ) ;
/*
Return to the calling procedure.
                                                                   */
        RETURN ;
        END  TCN$NOT_IMPLEMENTED ;
        %EOD ;
/*M* TCP$REPORT - Procedure to process REPORT command.             */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCP$REPORT
 
PURPOSE:        To process the REPORT command.
                                                                   */
/*D*
NAME:           TCP$REPORT
 
CALL:           CALL TCP$REPORT ;
 
PARAMETERS:     None
                                                                   */
/*D*
DESCRIPTION:
 
The TCP$REPORT procedure is used to process the REPORT command.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCP$REPORT:               PROC ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XU_FORMAT_C ;
        %INCLUDE                XU_MACRO_C ;
/********************** DCB REFERENCES *****************************/
        DCL 1 M$LO              DCB ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
        DCL 1 TCS$CONFIG        ENTRY(1) ALTRET ;
        DCL 1 TCN$NOT_IMPLEMENTED  ENTRY(3);
        %INCLUDE                XUF_ENTRY ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %B$ALT ;
        %B$TCB                  ( NAME = B$TCB
                                , STCLASS = "BASED(B$TCB$)"
                                                                ) ;
        DCL 1 B$TCB$            PTR SYMREF ;
        %TCM_PIT ;
        %XUG_GETCMD             ( NAME = XUG_GETCMD
                                , STCLASS = SYMREF
                                                                ) ;
/********************** LOCAL DATA REFERENCES **********************/
/*
BUF             is a CHAR(81) structure that is used as a buffer
        by X$WRITE/X$FORMAT to format the reports.
                                                                   */
        DCL 1 BUF               CHAR(81) CALIGNED STATIC ;
/*
DEBUG           is a BIT(1) constant that is used to specify
        whether ('1'B) or not ('0'B) all CMs and DEVs are to be
        reported.  If set, ALL CMs and DEVs are reported.  If reset,
        only the devices present or configured are reported.
                                                                   */
        DCL 1 DEBUG             BIT(1) ALIGNED CONSTANT INIT('0'B) ;
/*
FDS             is a F_FDS structure that is used in calling the
        X$WRITE host library service to format the reports.
                                                                   */
        %F_FDS                  ( NAME = FDS
                                , STCLASS = STATIC
                                , BUF = BUF
                                , DCB = M$LO
                                                                ) ;
/*
I               is a UBIN WORD that is used as a counter.
                                                                   */
        DCL 1 I                 UBIN WORD ALIGNED AUTO ;
/*
IPC_EPROM_FMT           is a CHAR(0) variable that specifies the
        formatting information for the IPC EPROM configuration
        report.
                                                                   */
        DCL 1 IPC_EPROM_FMT     CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%/IPC-IPI Configuration for %A%2/'),
              2 * CHAR(0) INIT('%2XEPROM Configuration%/'),
              2 * CHAR(0) INIT('%4XIPC-IPI id     ''%2ZY''H%/'),
              2 * CHAR(0) INIT('%4XTransformer id ''%2ZY''H%/'),
              2 * CHAR(0) INIT('%4XFirmware Rev    %2A'         ) ;
/*
IPC_FW_FMT0             is a CHAR(0) variable that specifies the
        formatting information for the IPC firmware configuration
        report if the firmware is not present.
                                                                   */
        DCL 1 IPC_FW_FMT0       CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%/%2XFirmware #%1D Not Present' ) ;
/*
IPC_FW_FMT1             is a CHAR(0) variable that specifies the
        formatting information for the IPC firmware configuration
        report if the firmware is present.
                                                                   */
        DCL 1 IPC_FW_FMT1       CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%/%2XFirmware #%1D Present:%/'),
              2 * CHAR(0) INIT('%4XClass          ''%2ZY''H%/'),
              2 * CHAR(0) INIT('%4XModel          ''%2ZY''H%/'),
              2 * CHAR(0) INIT('%4XRevision        %2A       '  ) ;
/*
OPT                     is a SBIN WORD variable that is used in the
        processing of the options on the REPORT command.
                                                                   */
        DCL 1 OPT               SBIN WORD ALIGNED ;
/*
OUT$BLK         is a PARSE$OUT structure that is used to process the
        parsed nodes of the REPORT command.
                                                                   */
        %PARSE$OUT              ( NAME = OUT$BLK
                                , STCLASS = "BASED(XUG_GETCMD.OUT$)"
                                                                ) ;
/*
OUT$SYM         is a PARSE$SYM structure that is used to process the
        parsed nodes of the REPORT command.
                                                                   */
        %PARSE$SYM              ( NAME = OUT$SYM
                                , STCLASS = "BASED(XUG_GETCMD.OUT$)"
                                                                ) ;
/*
SS_CM_FMT0      is a CHAR(0) variable that specifies the formatting
        information for the SS CM configuration report heading.
                                                                   */
        DCL 1 SS_CM_FMT0        CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%/Subsystem Configuration for %A%2/'),
              2 * CHAR(0) INIT('%2XControl Module Configuration%/'),
              2 * CHAR(0) INIT('%4X                                  Number%/'),
              2 * CHAR(0) INIT('%4XCM                                  of%/'),
              2 * CHAR(0) INIT('%4XNo  Present  Configured   Class   Devices%/'),
              2 * CHAR(0) INIT('%4X--  -------  ----------  -------  -------%/') ;
/*
SS_CM_FMT1      is a CHAR(0) variable that specifies the formatting
        information for the SS CM configuration report body.
                                                                   */
        DCL 1 SS_CM_FMT1        CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%4X%2D'),
              2 * CHAR(0) INIT('%4X%1.1N[Yes%?No %]'),
              2 * CHAR(0) INIT('%7X%1.1N[Yes%?No %]%0.0S'),
              2 * CHAR(0) INIT('%6X%1.9N[  Disk  %2?  Tape  %?Unknown %]'),
              2 * CHAR(0) INIT('%3X%2D%/') ;
/*
SS_DEV_FMT0     is a CHAR(0) variable that specifies the formatting
        information for the SS DEV configuration report heading.
                                                                   */
        DCL 1 SS_DEV_FMT0       CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%/%2XDevice Configuration%2/'),
              2 * CHAR(0) INIT('%4XDev   Dev%/'),
              2 * CHAR(0) INIT('%4XName  No   Present  Configured  Status    Type    Format%/'),
              2 * CHAR(0) INIT('%4X----  ---  -------  ----------  -------  -------  -------%/') ;
/*
SS_DEV_FMT1     is a CHAR(0) constant that specifies the formatting
        information for the SS DEV configuration report body.
                                                                   */
        DCL 1 SS_DEV_FMT1       CALIGNED CONSTANT,
              2 * CHAR(0) INIT('%4X%4A'),
              2 * CHAR(0) INIT('%2X%2D'),
              2 * CHAR(0) INIT('%5X%1.1N[Yes%?No %]'),
              2 * CHAR(0) INIT('%7X%1.1N[Yes%?No %]%0.0S'),
              2 * CHAR(0) INIT('%6X%255.9N[Online %?Unknown%]'),
              2 * CHAR(0) INIT('%2X%5.9N[MDS I %7?MDS II%?Unknown%]'),
              2 * CHAR(0) INIT('%2X%1.9N[  64%2? 512%?Unknown%]%/') ;
/********************** ERROR MESSAGES *****************************/
/*B*
TCP#FW_NOT_IMPL    is a VLP_ERRCODE structure used to print the
                   "REPORT DCnn(IPC) command will not be implemented"
                    error message.
                                                                   */
/*E*
ERROR:  TCP-E$TCP#FW_NOT_IMPL-0
MESSAGE:  REPORT DCnn(IPC) command will not be implemented until the
          READ IPC Configuration command ('21'O) is implemented in the
          firmware.
                                                                    */
%VLP_ERRCODE (FPTN= TCP#FW_NOT_IMPL, STCLASS = CONSTANT,
              ERR# = %E$TCP#FW_NOT_IMPL, FCG = %TCM#FCG,
              MID = 'P', MON = %NO#, SEV=0);
        %EJECT ;
/********************** PROCEDURE **********************************/
/*
Obtain software and hardware configurations for the requested
controller.
                                                                   */
        CALL TCS$CONFIG ( OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT )
                                           ALTRET ( ERRRET ) ;
/*
Generate the requested report.
                                                                   */
        IF  OUT$BLK.NSUBLKS = 1  THEN
            OPT = TCO#SS ;
        ELSE
            OPT = OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE ;
 
        DO CASE ( OPT ) ;
 
           CASE ( TCO#IPC ) ;              /***  REPORT IPC        ***/
/*             **********************************
NOTE:          The following code will not be implemented until the
               READ IPC Configuration command ('21'O) is implemented
               in the firmware.
 
               CALL X$WRITE ( FDS, VECTOR(IPC_EPROM_FMT),
                              VECTOR(TCM_PIT.DCNN.NAME),
                              VECTOR(TCM_PIT.IPC.EPROM.ID),
                              VECTOR(TCM_PIT.IPC.EPROM.XFMRID),
                              VECTOR(TCM_PIT.IPC.EPROM.REV)        ) ;
               DO  I = 0 TO 1 ;
                   IF  TCM_PIT.IPC.FW(I) = '0'B  THEN
                       CALL X$WRITE ( FDS, VECTOR(IPC_FW_FMT0) ) ;
                   ELSE
                       CALL X$WRITE ( FDS, VECTOR(IPC_FW_FMT1),
                                      VECTOR(I),
                                      VECTOR(TCM_PIT.IPC.FW.CLASS(I)),
                                      VECTOR(TCM_PIT.IPC.FW.MODEL(I)),
                                      VECTOR(TCM_PIT.IPC.FW.REV(I))  ) ;
                   END ;
               **********************************           */
 
               CALL TCE$ERRMSG ( TCP#FW_NOT_IMPL );
 
           CASE ( TCO#SS ) ;               /*** REPORT SUBSYSTEM   ***/
                CALL X$WRITE ( FDS, VECTOR(SS_CM_FMT0),
                               VECTOR(TCM_PIT.DCNN.NAME) );
                DO  I = 0 TO 7 ;
                    IF  TCM_PIT.CM.FLAGS.PRESENT(I)   OR
                        TCM_PIT.CM.FLAGS.CONFIGED(I)  OR
                        DEBUG                         THEN
                        CALL X$WRITE ( FDS, VECTOR(SS_CM_FMT1),
                                       VECTOR(I),
                                       VECTOR(TCM_PIT.CM.FLAGS(I)),
                                       VECTOR(TCM_PIT.CM.CLASS(I)),
                                       VECTOR(TCM_PIT.CM.NUMDEVS(I)) ) ;
                    END ;
                CALL X$WRITE ( FDS, VECTOR(SS_DEV_FMT0) ) ;
                DO  I = 0 TO 63 ;
                    IF  TCM_PIT.DEV.FLAGS.PRESENT(I)   OR
                        TCM_PIT.DEV.FLAGS.CONFIGED(I)  OR
                        DEBUG                          THEN
                        CALL X$WRITE ( FDS, VECTOR(SS_DEV_FMT1),
                                       VECTOR(SUBSTR(TCM_PIT.DPNN.NAME(I),0,4)),
                                       VECTOR(I),
                                       VECTOR(TCM_PIT.DEV.FLAGS(I)),
                                       VECTOR(TCM_PIT.DEV.STATUS(I)),
                                       VECTOR(TCM_PIT.DEV.TYPE(I)),
                                       VECTOR(TCM_PIT.DEV.FORMAT(I)) ) ;
                    END ;
                END  /* DO CASE ( OPT ) */ ;
/*
Return to the calling procedure.
                                                                   */
ERRRET: RETURN ;
 
        END TCP$REPORT ;
        %EOD ;
/*M* TCQ$QUIT - Termination procedure                              */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCQ$QUIT
 
PURPOSE:        To terminate the CMLOAD program.
 
DESCRIPTION:
 
The TCQ$QUIT procedure is used to terminate the CMLOAD program.
                                                                   */
/*D*
NAME:           TCQ$QUIT
 
CALL:           CALL TCQ$QUIT ;
 
PARAMETERS:     None.
 
DESCRIPTION:
 
The TCQ$QUIT procedure is used to terminate the CMLOAD program.
TCQ$QUIT steps the step condition code to the value specified in
TCM_PIT.STEPCC#.  TCQ$QUIT also sets B$JIT.ERR to the error
error code in TCM_PIT if an error was detected.  If no error
was detected or the severity of the error was 3 or less, TCQ$QUIT
does an M$EXIT.  If an error was detected whose severity was
between 4 and 5, TCQ$QUIT does an M$ERR.  If an error was detected
whose severity was 6 or greater, TCQ$QUIT does an M$XXX.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCQ$QUIT:       PROC ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C63 ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %TCM_PIT ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*
ERR             is a FPT_ERR structure that is used when doing a
        M$ERR to terminate the CMLOAD program.
                                                                   */
        %FPT_ERR                ( FPTN = ERR
                                , STCLASS = STATIC
                                , CODE = TCM_PIT.ERRCODE
                                , STEPCC = ERROR
                                                                ) ;
/*
XIT             is a FPT_EXIT structure that is used when doing a
        M$EXIT to terminate the CMLOAD program.
                                                                   */
        %FPT_EXIT               ( FPTN = XIT
                                , STCLASS = STATIC
                                , CODE = TCM_PIT.ERRCODE
                                , STEPCC = OK
                                                                ) ;
/*
XXX             is a FPT_XXX structure that is used when doing a
        M$XXX to terminate the CMLOAD program.
                                                                   */
        %FPT_XXX                ( FPTN = XXX
                                , CODE = TCM_PIT.ERRCODE
                                , STEPCC = ABORT
                                , STCLASS = STATIC
                                                                ) ;
/********************** PROCEDURE **********************************/
/*
Determine if an error has been detected.  If an error has not been
detected, merely do a M$EXIT without specifying a FPT_EXIT FPT.
                                                                   */
        IF  TCM_PIT.FLAGS.ERRCODE# = %NO#  THEN
            CALL M$EXIT ;
/*
If the severity of the error was less than 4, do a M$EXIT that
sets the step condition code and the JIT error code.
                                                                   */
        ELSE
            IF  TCM_PIT.ERRCODE.SEV < 4  THEN DO ;
                XIT.V.STEPCC# = TCM_PIT.STEPCC# ;
                CALL M$EXIT ( XIT ) ;
                END ;
/*
If the severity of the error was between 4 and 5, do a M$ERR that
sets the step condition code and the JIT error code.
                                                                   */
            ELSE IF  TCM_PIT.ERRCODE.SEV < 6  THEN DO ;
                ERR.V.STEPCC# = TCM_PIT.STEPCC# ;
                CALL M$ERR ( ERR ) ;
                END ;
/*
If the severity of the error was 6 or greater, do a M$XXX that
sets the step condition code and the JIT error code.
                                                                   */
            ELSE DO ;
                XXX.V.STEPCC# = TCM_PIT.STEPCC# ;
                CALL M$XXX ( XXX ) ;
                END ;
        END TCQ$QUIT ;
        %EOD ;
/*M* TCR$RESET - Procedure to process RESET command                 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCR$RESET
 
PURPOSE:        To issue a power-on RESET to a CM controller
                                                                   */
/*D*
NAME:           TCR$RESET
 
CALL:           CALL TCR$RESET ;
 
PARAMETERS:     None
                                                                   */
/*D*
DESCRIPTION:
 
The TCR$RESET procedure is called to issue a power-on RESET to a CM controller.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCR$RESET:               PROC ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XU_MACRO_C ;
        %INCLUDE                XUG_ENTRY ;
/********************** DCB REFERENCES *****************************/
        DCL F$TDIO               DCB;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL TCE$ERRMSG          ENTRY(6) ;
        DCL TCS$CONFIG          ENTRY(1) ALTRET;
/********************** EXTERNAL DATA REFERENCES *******************/
        DCL B$TCB$               PTR SYMREF;
        %B$TCB                   (NAME=B$TCB,STCLASS="BASED (B$TCB$)");
        %B$ALT;
        %F$DCB;
        %TCM_PIT;
        %XUG_GETCMD              (NAME=XUG_GETCMD,
                                  STCLASS=SYMREF);
        %PARSE$OUT               (NAME=OUT$BLK,
                                  STCLASS= "BASED(XUG_GETCMD.OUT$)");
        %PARSE$SYM               (NAME=OUT$SYM,
                                  STCLASS= "BASED(XUG_GETCMD.OUT$)");
        %EJECT ;
/********************** LOCAL DATA REFERENCES **********************/
        DCL 1 DCW_AREA(0:77)     UBIN DALIGNED STATIC;
        DCL 1 WORD$              PTR ALIGNED;
        DCL 1 PTR$               REDEF WORD$,
            2 OFFSET UBIN(18) UNAL,
            2 SEGID UBIN(18) UNAL;
        DCL IDCW1 BIT(36) ALIGNED;
        DCL IDCW2 BIT(36) ALIGNED;
        DCL I UBIN;
        DCL J UBIN;
        DCL AVAIL_CHANS UBIN;
        DCL DCW$ PTR;            /* POINTER TO DCWLIST */
        DCL PACKET$ PTR;         /* POINTER TO CM PACKET LIST */
        DCL RDBUF$ PTR;          /* POINTER TO CM RESPONSE BUFFER */
        DCL STAT$ PTR;           /* POINTER TO IO STATUS */
        DCL DCB$ PTR;
        DCL CM_COUNT UBIN;       /* COUNT OF CMs TO RESET */
        DCL 1 CM_NUMBER STATIC,
            2 ASCII CHAR(16) UNAL INIT('0123456789ABCDEF'),
            2 N(0:15) REDEF ASCII CHAR(1) UNAL;
        DCL 1 CM_NN,
            2 LEN UBIN BYTE CALIGNED,
            2 NAME CHAR(1);
        DCL 1 DCNN,
            2 LEN UBIN BYTE CALIGNED,
            2 NAME CHAR(2);
        DCL 1 ERROR_TEXT,
            2 LEN UBIN BYTE CALIGNED,
            2 ASCII CHAR(4) UNAL;
        DCL 1 STATUS_TEXT STATIC,
            2 LEN UBIN BYTE CALIGNED INIT(25),
            2 ASCII CHAR(25);
        DCL 1 CM,
            2 VALID UBIN,
            2 VLD REDEF VALID,      /* VALID CM NUMBERS ON DCnn */
              3 NUM(0:7) BIT(1) UNAL,
              3 * BIT(28) UNAL,
            2 TO_RESET UBIN,
            2 RESET REDEF TO_RESET,      /* CMs TO RESET ON DCnn */
              3 NUM(0:7) BIT(1) UNAL,
              3 * BIT(28) UNAL;
        %VLP_VECTOR              (FPTN=SEG_);
        %TCM_STATUS              (NAME=IO_STATUS, LVL=1,
                                  STCLASS="BASED(STAT$)");
        DCL 1 STATUS REDEF IO_STATUS,
            2 WORD1 UBIN,
            2 WORD2 UBIN;
        %FPT_TDOPEN              (FPTN=FPT_TDOPEN,DCB=F$TDIO,
                                  TEST=ITR);
        %FPT_TDCLOSE             (FPTN=FPT_TDCLOSE,DCB=F$TDIO);
        %FPT_TDIO                 (FPTN=FPT_TDIO, DCB=F$TDIO);
%EJECT;
/*
*********************** CM PACKETS *********************************
                                                                   */
DCL 1 CMD_PACKET STATIC ALIGNED,                 /*  IPI CMD PACKET  */
    2 MSG CHAR(8) UNAL INIT('IPI CMD ');
DCL 1 RESET_PACKET STATIC ALIGNED,             /* CM RESET PACKET */
    2 PACKET_TYPE CHAR(2) UNAL INIT('04'),
    2 CM CHAR(1) UNAL INIT('8'),
    2 RESET_TYPE CHAR(1) UNAL INIT('4');
%EJECT;
/*
*********************** ERROR MESSAGES ********************************
                                                                    */
/*B*
TCR#DCNN_NOT_PART     is a VLP_ERRCODE structure used to print the
                      "DCnn must be partitioned before RESET" error message.
                                                                   */
/*E*
ERROR:  TCR-E$TCR#DCNN_NOT_PART-4
MESSAGE:  DC%U1 must be partitioned before RESET.
                                                                 */
%VLP_ERRCODE (FPTN = TCR#DCNN_NOT_PART, STCLASS = CONSTANT,
              ERR# = %E$TCR#DCNN_NOT_PART, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=4);
/*B*
TCR#CM_NOT_CONFIGED     is a VLP_ERRCODE structure used to print the
                        "CMn is not configured on DCnn" error message.
                                                                   */
/*E*
ERROR:  TCR-E$TCL#CM_NOT_CONFIGED-4
MESSAGE:  CM%U1 is not configured on DC%U2.
                                                                 */
%VLP_ERRCODE (FPTN = TCR#CM_NOT_CONFIGED, STCLASS = CONSTANT,
              ERR# = %E$TCL#CM_NOT_CONFIGED, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=4);
/*B*
TCR#NO_CMS_RESET        is a VLP_ERRCODE structure used to print the
                       "No CMs RESET on DCnn" error message.
                                                                   */
/*E*
ERROR:  TCR-E$TCR#NO_CMS_RESET-4
MESSAGE:  No CMs RESET on DC%U1.  Do a REPORT DC%U1 to check if CMs
          are configured.
                                                                   */
%VLP_ERRCODE (FPTN = TCR#NO_CMS_RESET, STCLASS = CONSTANT,
              ERR# = %E$TCR#NO_CMS_RESET, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=4);
/*B*
TCR#UNABLE_TO_SUSPEND   is a VLP_ERRCODE structure used to print the
                        "Returned bad status = xxxxxxxxxxxx on SUSPEND DCnn" error msg.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#UNABLE_TO_SUSPEND-6
MESSAGE:  Returned bad STATUS = %U1 on SUSPEND DC%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCR#UNABLE_TO_SUSPEND, STCLASS = CONSTANT,
              ERR# = %E$TCL#UNABLE_TO_SUSPEND, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=6);
/*B*
TCR#IPC_REBOOT          is a VLP_ERRCODE structure used to print the
                        "IPC firmware is loading..."  message.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#IPC_REBOOT-0
MESSAGE:  IPC firmware is loading ...
                                                                   */
%VLP_ERRCODE (FPTN = TCR#IPC_REBOOT, STCLASS = CONSTANT,
              ERR# = %E$TCL#IPC_REBOOT, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=0);
/*B*
TCR#UNABLE_TO_RELEASE          is a VLP_ERRCODE structure used to print the
                        "BAD STATUS = xxxxxxxxxxxx on RELEASE DCnn"
                         error message.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#UNABLE_TO_RELEASE-6
MESSAGE:  BAD STATUS = %U1 when trying to RELEASE DC%U2
                                                                   */
%VLP_ERRCODE (FPTN = TCR#UNABLE_TO_RELEASE, STCLASS = CONSTANT,
              ERR# = %E$TCL#UNABLE_TO_RELEASE, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=6);
/*B*
TCR#CONFIG_ERR          is a VLP_ERRCODE structure used to print the
                        "Error in :CONFIG file " error message.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#CONFIG_ERR-6
MESSAGE:  Error in :CONFIG file - No IOM channels assigned to DC%U1
                                                                   */
%VLP_ERRCODE (FPTN = TCR#CONFIG_ERR, STCLASS = CONSTANT,
              ERR# = %E$TCL#CONFIG_ERR, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=6);
/*B*
TCR#RESET_MSG          is a VLP_ERRCODE structure used to print the
                        "Power-on RESET issued to CMn..." message.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#RESET_MSG-0
MESSAGE:  Power-on RESET issued to CM%U1...
                                                                   */
%VLP_ERRCODE (FPTN = TCR#RESET_MSG, STCLASS = CONSTANT,
              ERR# = %E$TCL#RESET_MSG, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=0);
/*B*
TCR#BAD_POWER_ON          is a VLP_ERRCODE structure used to print the
                        "Bad STATUS = xxxxxxxxxxxx when attempting power-on
                         RESET to CMn" error message.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#BAD_POWER_ON-6
MESSAGE:  Bad STATUS = %U1 when attempting power-on RESET to CM%U2
          RESET of CM%U2 through program control impossible.
          Perform manual power-down and power-up of CM%U2 before attempting
          to reload CM firmware.
                                                                   */
%VLP_ERRCODE (FPTN = TCR#BAD_POWER_ON, STCLASS = CONSTANT,
              ERR# = %E$TCL#BAD_POWER_ON, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=6);
/*B*
TCR#RESET_COMPLETE          is a VLP_ERRCODE structure used to print the
                        "Power-on RESET to CMn complete" message.
                                                                    */
/*E*
ERROR:  TCR-E$TCL#RESET_COMPLETE-0
MESSAGE:  Power-on RESET to CM%U1 complete.
                                                                   */
%VLP_ERRCODE (FPTN = TCR#RESET_COMPLETE, STCLASS = CONSTANT,
              ERR# = %E$TCL#RESET_COMPLETE, FCG = %TCM#FCG,
              MID = 'R', MON = %NO#, SEV=0);
/*B*
TCR#SYSCON_ERR              is a VLP_ERRCODE structure used to print
                        "All channels to DCnn are partitioned"
                            error message.
                                                                   */
/*E*
ERROR:  TCR-E$TCL#SYSCON_ERR-6
MESSAGE:  SYSCON error - All channels to DC%U1 are partitioned.
          Unable to proceed with RESET.
                                                                   */
%VLP_ERRCODE ( FPTN = TCR#SYSCON_ERR, STCLASS = CONSTANT,
               ERR# = %E$TCL#SYSCON_ERR, FCG = %TCM#FCG,
               MID = 'R', MON = %NO#, SEV = 6);
%EJECT;
/********************** PROCEDURE **********************************/
/*
   GET DCnn FROM PARSED COMMAND
                                                                    */
   DCNN.LEN = OUT$BLK.SUBLK$(0) -> OUT$SYM.COUNT;
   DCNN.NAME = OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
   CALL TCS$CONFIG(DCNN) ALTRET(ERR_CONFIG);
   IF TCM_PIT.DCNN.NAME = ' '
      THEN RETURN;
   IF NOT TCM_PIT.DCNN.FLAGS.DOWN
      THEN DO;
        CALL TCE$ERRMSG ( TCR#DCNN_NOT_PART,,VECTOR(DCNN));
        TCM_PIT.DCNN.NAME = ' ';
        RETURN;
      END;
/*
        GET VALID CM NUMBERS FROM PIT
                                                                    */
   CM.VALID = 0;
   CM.TO_RESET = 0;
   DO I = 0 TO 7;
      IF  TCM_PIT.CM.FLAGS.CONFIGED(I)
         THEN CM.VLD.NUM(I) = '1'B;
   END;
%EJECT;
/*
              ******************************************
              *                                        *
              *    GET CM NUMBERS FROM RESET COMMAND    *
              *                                        *
              *                                        *
              ******************************************
                                                                    */
        DO CASE (OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE);  /* GET CMD OPTIONS */
           CASE (TCO#ALL);
              CM.TO_RESET = CM.VALID;
           CASE (TCO#ONE);
              CM_NN.LEN = OUT$BLK.SUBLK$(1) -> OUT$SYM.COUNT;
              CM_NN.NAME = OUT$BLK.SUBLK$(1) ->OUT$SYM.TEXT;
              CALL CHARBIN (I,CM_NN.NAME);
              IF CM.VLD.NUM(I) THEN
                 CM.RESET.NUM(I) = '1'B;
                 ELSE DO;
                   CALL TCE$ERRMSG (TCR#CM_NOT_CONFIGED,,
                                    VECTOR(CM_NN),
                                    VECTOR(DCNN));
                 END;
           CASE (TCO#LIST);
                DO J = 1 TO OUT$BLK.SUBLK$(1) -> OUT$BLK.NSUBLKS;
                   CM_NN.LEN = OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(J-1) ->
                               OUT$SYM.COUNT;
                   CM_NN.NAME = OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(J-1) ->
                                OUT$SYM.TEXT;
                   CALL CHARBIN (I,CM_NN.NAME);
                   IF CM.VLD.NUM(I) THEN
                      CM.RESET.NUM(I) = '1'B;
                      ELSE DO;
                        CALL TCE$ERRMSG (TCR#CM_NOT_CONFIGED,,
                                         VECTOR(CM_NN),
                                         VECTOR(DCNN));
                      END;
                END; /* DO J = 1 */
        END;  /* DO CASE (OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE) */
   CM_COUNT = 0;
   DO J = 0 TO 7;
        IF CM.RESET.NUM(J)
           THEN CM_COUNT = CM_COUNT +1;
   END;
   IF CM_COUNT = 0
        THEN DO;
           CALL TCE$ERRMSG(TCR#NO_CMS_RESET,,VECTOR(DCNN));
           TCM_PIT.DCNN.NAME = ' ';
           RETURN;
        END;
        %EJECT ;
/*
              ******************************************
              *                                        *
              *       PREPARE TO DO TDIO TO IPC        *
              *             CONTROLLER                 *
              *                                        *
              ******************************************
                                                                    */
   DCB$ = DCBADDR(DCBNUM(F$TDIO));
   STAT$ = ADDR(DCB$->F$DCB.TDSTAT#);
   AVAIL_CHANS = 0;
   DO J = 0 TO 15;
      IF NOT TCM_PIT.DCNN.IOCHAN.DOWN(J)
         THEN AVAIL_CHANS = AVAIL_CHANS + 1;
   END;
   IF AVAIL_CHANS = 0 THEN
      DO;
        CALL TCE$ERRMSG(TCR#SYSCON_ERR,,VECTOR(DCNN));
        RETURN;
      END;
   DO J = 0 TO 15;
      IF TCM_PIT.DCNN.IOCHAN.PRESENT(J) AND
         (NOT TCM_PIT.DCNN.IOCHAN.DOWN(J))
         THEN DO;
            FPT_TDOPEN.V.DEVICE.IOM# = TCM_PIT.DCNN.IOCHAN.IOM(J);
            FPT_TDOPEN.V.DEVICE.CHAN# = TCM_PIT.DCNN.IOCHAN.CHAN(J);
            GOTO OPEN_TDIO_DCB;
         END;
   END;
   CALL TCE$ERRMSG(TCR#CONFIG_ERR,, VECTOR(DCNN));
   RETURN;
OPEN_TDIO_DCB:
   CALL M$TDOPEN (FPT_TDOPEN) ALTRET(ERR_RTN);
/*
   FRAME DATA AREA FOR M$TDIO
                                                                   */
   FPT_TDIO.DATA_ = VECTOR(DCW_AREA);
   DCW$ = ADDR(DCW_AREA);            /* START OF DCWLIST AREA */
   PACKET$ = PINCRW(DCW$, 4 );         /* START OF CM PACKET AREA */
   RDBUF$ = PINCRW(DCW$, 14);        /* START OF CM RESPONSE BUFFER */
   CALL XUG$DISABLE (XUG_GETCMD);          /* DISABLE BREAKS */
/*
   CHECK IF CHANNEL HAS ALREADY BEEN SUSPENDED
                                                           */
   IF NOT TCM_PIT.DCNN.FLAGS.SUSPEND
      THEN DO;
         IDCW1 = %IDCWSPND;
         CALL BUILD_DCWLST(IDCW1);   /* ISSUE SUSPEND */
         IF IO_STATUS.MAJOR = BITBIN('00'O) AND  /* STATUS = READY? */
            IO_STATUS.MINOR = '000000'B AND
            IO_STATUS.IOM = '00'O
            THEN TCM_PIT.DCNN.FLAGS.SUSPEND = '1'B;
            ELSE DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCR#UNABLE_TO_SUSPEND,,
                                VECTOR(STATUS_TEXT),
                                VECTOR(DCNN));
               RETURN;
               END;
      END;  /* IF NOT TCM_PIT.DCNN.FLAGS.SUSPEND */
   DO J = 0 TO 7;
      IF CM.RESET.NUM(J)
         THEN DO;
            CM_NN.NAME = CM_NUMBER.N(J);
            CM_NN.LEN = 1;
/*
   INITIALIZE CM PACKETS WITH CM#
                                                                  */
            RESET_PACKET.CM = CM_NUMBER.N(J+8);
%EJECT;
/*
              ******************************************
              *                                        *
              *         POWER-ON RESET TO CM           *
              *                                        *
              ******************************************
                                                                    */
POWER_ON_RESET:
         CALL TCE$ERRMSG (TCR#RESET_MSG,, VECTOR(CM_NN));
         IDCW1 = %IDCWMPF;
         IDCW2 = %IDCWWRT;
         CALL BUILD_DCWLST (IDCW1, VECTOR(CMD_PACKET), IDCW2,
                            VECTOR(RESET_PACKET));
         IF (IO_STATUS.MAJOR = BITBIN('00'O) AND
                 IO_STATUS.MINOR = '000000'B)
            THEN CALL TCE$ERRMSG (TCR#RESET_COMPLETE,, VECTOR(CM_NN));
            ELSE DO;                       /* STATUS ~= READY */
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCR#BAD_POWER_ON,, VECTOR(STATUS_TEXT),
                                VECTOR(CM_NN));
            END;
NEXT_CM:
         END;  /* IF CM.RESET.NUM(J) */
   END;   /* DO J = 0 TO 7 */
%EJECT;
/*
              ******************************************
              *                                        *
              *           RELEASE IPC CHANNEL          *
              *          (OPPOSITE OF SUSPEND)         *
              *                                        *
              *         CHECK FOR READY STATUS         *
              ******************************************
                                                                    */
RELEASE_IPC:
   IF TCM_PIT.DCNN.FLAGS.SUSPEND       /* IS SUSPEND FLAG SET? */
      THEN DO;
         IDCW1 = %IDCWREL;             /* YES */
         CALL BUILD_DCWLST (IDCW1);           /* GO TO RELEASE THE IPC */
         IF NOT (IO_STATUS.MAJOR = BITBIN('00'O) AND
                 IO_STATUS.MINOR = '000000'B AND
                 IO_STATUS.IOM = '00'O)
            THEN DO;
               CALL CONVERT_STATUS (STATUS, STATUS_TEXT);
               CALL TCE$ERRMSG (TCR#UNABLE_TO_RELEASE,, VECTOR(STATUS_TEXT),
                                VECTOR(DCNN));
               END;
            ELSE TCM_PIT.DCNN.FLAGS.SUSPEND = '0'B;   /* CLEAR FLAG */
      END;
   CALL TCE$ERRMSG(TCR#IPC_REBOOT);
   CALL M$TDCLOSE(FPT_TDCLOSE) ALTRET(ERR_RTN);
   CALL XUG$ENABLE (XUG_GETCMD);       /* ENABLE BREAKS */
   RETURN;
ERR_CONFIG:
   RETURN;
ERR_RTN:
   CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR, B$TCB.ALT$ -> B$ALT.DCB#);
   RETURN;
%EJECT;
/*F*
NAME:           CONVERT_STATUS
 
PURPOSE:        To convert I/O Termination status to ASCII format
                                                                   */
/*D*
NAME:           CONVERT_STATUS
 
CALL:           CALL CONVERT_STATUS ( param1, param2 );
 
PARAMETERS:
                                                                   */
/*K*
param1           is the 2-word I/O status in octal format
                                                                   */
/*K*
param2           is a TEXTC string containing the converted ASCII status
                                                                   */
/*D*
DESCRIPTION:
 
The CONVERT_STATUS procedure is used to convert the I/O termination
status from octal to ASCII format.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
CONVERT_STATUS:  PROC ( STATUS_OCT, STATUS_TEXT );
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 STATUS_OCT        PARAM ALIGNED,
            2 WORD1(0:11)       UBIN(3) UNAL,
            2 WORD2(0:11)       UBIN(3) UNAL;
        DCL 1 STATUS_TEXT       PARAM,
            2 LEN               UBIN BYTE CALIGNED,
            2 TEXT              CHAR(25) UNAL,
            2 ASCII(0:24)       REDEF TEXT CHAR(1) UNAL;
/********************** LOCAL DATA REFERENCES ***********************/
        DCL I                   UBIN;
        DCL K                   UBIN;
        DCL 1 NUMBER            STATIC,
            2 ASCII             CHAR(8) UNAL INIT('01234567'),
            2 N(0:7)            REDEF ASCII CHAR(1) UNAL;
%EJECT;
/********************** PROCEDURE **********************************/
/*
              ******************************************
              *                                        *
              *   CONVERT I/O STATUS IN OCTAL FORMAT   *
              *                                        *
              *            TO ASCII FORMAT             *
              ******************************************
                                                                    */
         STATUS_TEXT.TEXT = ' ';
         DO I = 0 TO 11;
            K = STATUS_OCT.WORD1(I);
            STATUS_TEXT.ASCII(I) = NUMBER.N(K);
         END;
         DO I = 0 TO 11;
            K = STATUS_OCT.WORD2(I);
            STATUS_TEXT.ASCII (I+13) = NUMBER.N(K);
         END;
         STATUS_TEXT.LEN = SIZEC(STATUS_TEXT.ASCII);
         RETURN;
END CONVERT_STATUS;
%EJECT;
/*F*
NAME:           BUILD_DCWLST
 
PURPOSE:        To build IDCW lists and issue M$TDIO
                                                                   */
/*D*
NAME:           BUILD_DCWLST
 
CALL:           CALL BUILD_DCWLST ( idcw1, [d1_], [idcw2], [d2_] );
 
PARAMETERS:
                                                                   */
/*K*
idcw1            is a UBIN WORD containing the first IDCW command
        to be issued.
                                                                   */
/*K*
d1_             is a VECTOR that frames the data to be specified in
        the first DCW word.  The default is NIL.
                                                                   */
/*K*
idcw2            is a UBIN WORD containing the second IDCW command
        to be issued.
                                                                   */
/*K*
d2_             is a VECTOR that frames the data to be specified in
        the second DCW word.  The default is NIL.
                                                                   */
/*D*
DESCRIPTION:
 
The BUILD_DCWLST procedure is used to build the IDCW lists and issue the
M$TDIO monitor call to perform I/O to the IPC controller and its
slave CMs.  The IDCW words passed will contain the op codes and
the basic IDCW structure.  The M$TDIO call is issued with a wait.
Upon completion of the M$TDIO, control is returned to the calling
routine where checking of termination status is performed.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
BUILD_DCWLST:  PROC ( IDCW1, DATA1_, IDCW2, DATA2_ ) ALTRET;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
/********************** DCB REFERENCES ****************************/
        DCL F$TDIO              DCB;
/********************** EXTERNAL DATA REFERENCES *******************/
        %TCM_PIT ;
        %TCM_IDCW               (NAME=IDCW, LVL=1, STCLASS="BASED(D$)");
        %TCM_DCW                (NAME=DCW, LVL=1, STCLASS="BASED(D$)");
        DCL DCWLIST(0:3)        UBIN BASED(DCW$);
        DCL PACKET_DATA CHAR(312) BASED;
/********************** LOCAL DATA REFERENCES **********************/
        %VLP_VECTOR             (FPTN=DCWLIST_);  /* VECTOR TO PASS TO TDIO */
        %VLP_VECTOR             (FPTN=PACKET_);  /* VECTOR FRAMING PACKETS */
        DCL D$                  PTR;  /* POINTS TO CURRENT ENTRY IN DCWLIST */
        DCL P$                  PTR;  /* POINTS TO CURRENT PACKET ENTRY IN STK */
        DCL BYTE_CNT            SBIN;
        DCL I                   UBIN;
        DCL 1 POINTER$ PTR;
        DCL 1 WORD$ REDEF POINTER$,
            2 OFFSET UBIN(18) UNAL,
            2 SEGID UBIN(18) UNAL;
        DCL 1 LEN UBIN;
        DCL 1 LEN_SBIN REDEF LEN SBIN;
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 IDCW1             BIT(36) DALIGNED PARAM;
        DCL 1 DATA1_            VECTOR ALIGNED PARAM ;
        DCL 1 IDCW2             BIT(36) ALIGNED PARAM;
        DCL 1 DATA2_            VECTOR ALIGNED PARAM ;
%EJECT;
/********************** PROCEDURE **********************************/
   D$ =DCW$;                 /* INITIALIZE PTRS TO BEGINNING OF AREAS */
   P$ = PACKET$;
   DO I = 0 TO 3 ;           /* CLEAR STACKS */
      DCWLIST(I) = 0;
   END;
   PACKET$ -> PACKET_DATA = ' ';
   DCWLIST_ = VECTOR(DCW_AREA);   /* INITIALIZE VECTOR FRAMING DCWLIST */
   BYTE_CNT = 0;
   IDCW = IDCW1;                 /* PUT 1ST IDCW INTO LIST */
   BYTE_CNT = BYTE_CNT + 4;
   IF ADDR(IDCW2) ~= ADDR(NIL)
      THEN IDCW.CONT = '1'B;     /* SET CONTINUE BIT */
   D$ = PINCRW(D$, 1);           /* BUMP PTR TO NEXT WORD IN DCWLIST */
   IF ADDR(DATA1_) ~= ADDR(NIL)
      THEN DO;
         PACKET_ = DATA1_;
         LEN = PACKET_.W1.VSIZE# + 1;      /* LENGTH OF PACKET IN BYTES */
/*
         MOVE PACKET INTO STACK IN DATA SEGMENT
                                                                     */
         SUBSTR(P$ -> PACKET_DATA, 0, LEN) =
               SUBSTR(PACKET_.PTR$ -> PACKET_DATA, 0, LEN);
         DCW.FWA = POFFW(P$, DCW$);
         LEN_SBIN = LEN_SBIN/4;
         DCW.TALLY = LEN;
         P$ = PINCRW(P$, LEN);          /* BUMP POINTER TO NEXT ENTRY IN STK */
         END;
      ELSE DCW = '000000000000'O;
      BYTE_CNT = BYTE_CNT +4;
      D$ = PINCRW(D$, 1);               /* BUMP POINTER TO NEXT ENTRY IN DCWLIST */
   IF ADDR(IDCW2) ~= ADDR(NIL)
      THEN DO;
        IDCW = IDCW2;                  /* MOVE IDCW 2 INTO DCWLIST */
        BYTE_CNT = BYTE_CNT + 4;
        D$ = PINCRW(D$, 1);
        IF ADDR(DATA2_) ~= ADDR(NIL)
           THEN DO;
             PACKET_ = DATA2_;
             LEN = PACKET_.W1.VSIZE# + 1;
             SUBSTR(P$ -> PACKET_DATA, 0, LEN) =
                  SUBSTR(PACKET_.PTR$ -> PACKET_DATA,0,LEN);
             DCW.FWA = POFFW(P$, DCW$);
             LEN_SBIN = LEN_SBIN/4;
             DCW.TALLY = LEN;
             BYTE_CNT = BYTE_CNT + 4;
           END;  /* IF ADDR(DATA2_) */
      END;  /* IF ADDR(IDCW2) */
   DCWLIST_.W1.VSIZE# = BYTE_CNT - 1 ;
   FPT_TDIO.DCWLIST_ = DCWLIST_;
   CALL M$TDIO(FPT_TDIO) ALTRET(ERR_RTN2);
   RETURN;
ERR_RTN2:
   CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR, B$TCB.ALT$ -> B$ALT.DCB#);
   RETURN;
END BUILD_DCWLST;
END TCR$RESET;
%EOD;
/*M* TCS$CONFIG - Procedure to read :CONFIG file and put software configuration
                  information into the PIT                           */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCS$CONFIG
 
PURPOSE:        To put software configuration into PIT
                                                                   */
/*D*
NAME:           TCS$CONFIG
 
CALL:           CALL TCS$CONFIG (dcnn) ALTRET ;
 
PARAMETERS:
                                                                   */
/*K*
dcnn            is the channel number specified in the LOAD or REPORT
                command.  dcnn must be in TEXTC format.
                                                                   */
/*D*
DESCRIPTION:
 
The TCS$CONFIG procedure is called to obtain the software configuration
from the :CONFIG file.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCS$CONFIG:               PROC (DCNN) ALTRET ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XU_MACRO_C ;
        %INCLUDE                TD$STRUCT ;
/********************** DCB REFERENCES *****************************/
        DCL F$CONFIG DCB;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL TCE$ERRMSG          ENTRY(6) ;
        DCL TCH$CONFIG          ENTRY ALTRET;
/********************** PARAMETERS *********************************/
        DCL 1 DCNN,
            2 LEN UBIN BYTE UNAL,
            2 NAME CHAR(DCNN.LEN);
/********************** EXTERNAL DATA REFERENCES *******************/
        DCL B$TCB$               PTR SYMREF;
        %B$TCB                   (NAME=B$TCB,STCLASS="BASED (B$TCB$)");
        %B$ALT;
        %TCM_PIT;
        %F$DCB;
/********************** LOCAL DATA REFERENCES **********************/
        %EJECT ;
        %TD$HEAD                 (NAME=TD$HEAD,STCLASS="BASED(HEAD$)");
        %TD$MPC                  (NAME=TD$MPC,NUMDEV#=64,STCLASS="BASED(MPC$)");
        %TD$DEV                  (NAME=TD$DEV,STCLASS="BASED(DEV$)");
        DCL DEV$ PTR;
        DCL HEAD$ PTR;
        DCL MPC$ PTR;
        %FPT_OPEN                (FPTN=OPEN_CONFIG,STCLASS=STATIC,
                                  DCB=F$CONFIG,NAME=CONFIG,ACCT=SYSACCT,
                                  FUN=IN,ASN=FILE,SHARE=ALL,ORG=KEYED);
        %FPT_READ                (FPTN=READ_CONFIG,DCB=F$CONFIG,
                                  BUF=CONFIG_BUF,STCLASS=STATIC,
                                  KEYS=YES);
        %FPT_CLOSE               (FPTN=CLOSE_CONFIG,DCB=F$CONFIG);
        %VLP_NAME                (FPTN=CONFIG,STCLASS=CONSTANT,
                                  NAME=':CONFIG');
        %VLP_ACCT                (FPTN=SYSACCT,STCLASS=CONSTANT,
                                  ACCT=':SYS');
%FPT_SYSCON                 (FPTN = SYSCON_FPT, RESULT = SYSCON_RESULTS,
                             FUNCTION = DISPLAY, COMPONENT = CHANNEL);
%VLR_SYSCON                 (FPTN = SYSCON_RESULTS);
        DCL CONFIG_BUF (0:1028) STATIC UBIN WORD;
        DCL DEV_BUF (0:10) STATIC UBIN WORD;
        DCL HEAD_KEY             BIT(18) CONSTANT INIT('001000'O);
        DCL 1 CONFIG_KEY STATIC,
            2 CNT UBIN BYTE UNAL,
            2 DEVID CHAR(8);
        DCL I UBIN;
        DCL J UBIN;
        DCL K UBIN;
%EJECT;
/*
*********************** ERROR MESSAGES *****************************
                                                                   */
/*B*
TCS#NOT_MDS     is a VLP_ERRCODE structure used to print the
                "DCnn not an MDS disk controller" error message.
                                                                   */
/*E*
ERROR:  TCS-E$TCS#NOT_MDS-4
MESSAGE:  DC%U1 is not an MDS disk controller.
MESSAGE1:  The specified disk controller is not a model MSS8080
           or MSS8090 disk controller.
DESCRIPTION:  CMLOAD only works on MDS disk controllers which
              have model numbers of either MSS8080 or MSS8090.
                                                                 */
%VLP_ERRCODE (FPTN = TCS#NOT_MDS, STCLASS = CONSTANT,
              ERR# = %E$TCS#NOT_MDS, FCG = %TCM#FCG,
              MID = 'S', MON = %NO#, SEV=4);
/*B*
TCS#DCNN_DOESNT_EXIST     is a VLP_ERRCODE structure used to print the
                          "DCnn not configured on system" error message.
                                                                   */
/*E*
ERROR:  TCS-E$TCS#DCNN_DOESNT_EXIST-4
MESSAGE:  DC%U1 is not configured on system.
                                                                 */
%VLP_ERRCODE (FPTN = TCS#DCNN_DOESNT_EXIST, STCLASS = CONSTANT,
              ERR# = %E$TCS#DCNN_DOESNT_EXIST, FCG = %TCM#FCG,
              MID = 'S', MON = %NO#, SEV=4);
%EJECT;
/*
*********************** PROCEDURE ***********************************
                                                                    */
   TCM_PIT.DCNN.NAME = ' ';                       /* CLEAR PIT */
   TCM_PIT.DCNN.MODEL = ' ';
   TCM_PIT.DCNN.NUMDEV = 0;
   TCM_PIT.DCNN.FLAGS = '000000000'B;
   DO I = 0 TO 15;
      TCM_PIT.DCNN.IOCHAN.PRESENT(I) = '0'B;
      TCM_PIT.DCNN.IOCHAN.DOWN(I) = '0'B;
      TCM_PIT.DCNN.IOCHAN.TDOK(I) = '0'B;
      TCM_PIT.DCNN.IOCHAN.IOM(I) = 0;
      TCM_PIT.DCNN.IOCHAN.CHAN(I) = 0;
   END;
   DO I = 0 TO 63;
      TCM_PIT.DPNN.NAME(I) = ' ';
      TCM_PIT.DPNN.FLAGS(I) = '0000'B;
   END;
        CALL M$OPEN(OPEN_CONFIG) ALTRET (ERR_RTN );
        READ_CONFIG.KEY_ = VECTOR(HEAD_KEY);
        READ_CONFIG.BUF_ = VECTOR(CONFIG_BUF);
        CALL M$READ(READ_CONFIG) ALTRET (ERR_RTN);  /*READ HEAD RECORD*/
        HEAD$ = ADDR (CONFIG_BUF);
        CONFIG_KEY.CNT = 8;
        CALL CONCAT(CONFIG_KEY.DEVID,'DC',DCNN.NAME,'0000');
        DO I = TD$HEAD.DISKMPC_INDX TO ( TD$HEAD.DISKMPC_INDX +
               TD$HEAD.NUMDISKMPCS - 1 );
           IF CONFIG_KEY.DEVID = TD$HEAD.DEVNAME(I)
              THEN DO;
              READ_CONFIG.KEY_ = VECTOR(CONFIG_KEY);
              CALL M$READ(READ_CONFIG) ALTRET(ERR_RTN );  /* READ MPC RECORD */
              MPC$ = ADDR(CONFIG_BUF);
              IF TD$MPC.MODEL = 'MSS8080 ' OR TD$MPC.MODEL = 'MSS8090 '
                 THEN DO;
                    TCM_PIT.DCNN.NAME = CONFIG_KEY.DEVID;
                    TCM_PIT.DCNN.MODEL = TD$MPC.MODEL;
                    DO J = 0 TO 7;
                      TCM_PIT.DCNN.IOCHAN.PRESENT(2 * J) =
                        TD$MPC.IOCHAN.PRESENCE(J);
                      TCM_PIT.DCNN.IOCHAN.IOM(2 * J) = TD$MPC.IOCHAN.IOM(J);
                      TCM_PIT.DCNN.IOCHAN.CHAN(2 * J) =
                        TD$MPC.IOCHAN.LOCHAN(J);
                      SYSCON_FPT.V.IOM# = TD$MPC.IOCHAN.IOM(J);
                      SYSCON_FPT.V.CHAN# = TD$MPC.IOCHAN.LOCHAN(J);
                      CALL M$SYSCON(SYSCON_FPT) ALTRET(NEXT_CHAN1);
                      TCM_PIT.DCNN.IOCHAN.DOWN(2 * J) =
                          SYSCON_RESULTS.PART#;
                      TCM_PIT.DCNN.IOCHAN.TDOK(2 * J) =
                          SYSCON_RESULTS.TDOK#;
NEXT_CHAN1:
                      TCM_PIT.DCNN.IOCHAN.PRESENT(2 * J + 1) =
                        TD$MPC.IOCHAN.PRESENCE(J);
                      TCM_PIT.DCNN.IOCHAN.IOM(2 * J + 1) = TD$MPC.IOCHAN.IOM(J);
                      TCM_PIT.DCNN.IOCHAN.CHAN(2 * J + 1) =
                        TD$MPC.IOCHAN.HICHAN(J);
                      SYSCON_FPT.V.CHAN# = TD$MPC.IOCHAN.HICHAN(J);
                      CALL M$SYSCON(SYSCON_FPT) ALTRET(NEXT_CHAN2);
                      TCM_PIT.DCNN.IOCHAN.DOWN(2 * J + 1) =
                          SYSCON_RESULTS.PART#;
                      TCM_PIT.DCNN.IOCHAN.TDOK(2 * J + 1) =
                          SYSCON_RESULTS.TDOK#;
NEXT_CHAN2:
                    END;  /* DO J = 0 TO 7 */
                    TCM_PIT.DCNN.NUMDEV = TD$MPC.NUMDEVS;
                    TCM_PIT.DCNN.FLAGS.DOWN = TD$MPC.FLAGS.DOWN;
                    TCM_PIT.DCNN.FLAGS.TDOK = TD$MPC.FLAGS.TDOK;
                    DEV$ = ADDR(DEV_BUF);
                    READ_CONFIG.BUF_ = VECTOR(DEV_BUF);
                    DO J = 0 TO TD$MPC.NUMDEVS - 1;
                       CONFIG_KEY.DEVID = TD$MPC.DEVNAME(J);
/*
                             READ DEVICE RECORD
                                                                    */
                       CALL M$READ(READ_CONFIG) ALTRET(ERR_RTN);
                       K = TD$DEV.DEVNUM;
                       TCM_PIT.DPNN.NAME(K) = TD$MPC.DEVNAME(J);
                       TCM_PIT.DPNN.FLAGS.CONFIGED(K) = '1'B;
                       TCM_PIT.DPNN.FLAGS.DOWN(K) = TD$DEV.FLAGS.DOWN;
                       TCM_PIT.DPNN.FLAGS.TDOK(K) = TD$DEV.FLAGS.TDOK;
                       TCM_PIT.DPNN.FLAGS.CHECKWRITE(K) =
                               TD$DEV.FLAGS.CHECKWRITE;
                    END;
                    CALL M$CLOSE(CLOSE_CONFIG);
                    CALL TCH$CONFIG
                       WHENALTRETURN DO;
                         TCM_PIT.DCNN.NAME = ' ';
                         ALTRETURN;
                       END;
                    RETURN;
                 END;
                 ELSE DO;  /* DCnn not an MDS disc type */
                    CALL TCE$ERRMSG ( TCS#NOT_MDS,,VECTOR(DCNN));
                   TCM_PIT.DCNN.NAME = ' ';
                    CALL M$CLOSE(CLOSE_CONFIG);
                    ALTRETURN;
                 END;
              END;  /* IF CONFIG_KEY.DEVID */
        END;  /* DO I */
        CALL TCE$ERRMSG (TCS#DCNN_DOESNT_EXIST,,VECTOR(DCNN));
        TCM_PIT.DCNN.NAME = ' ';
        CALL M$CLOSE(CLOSE_CONFIG);
        ALTRETURN;
ERR_RTN:
        CALL TCE$ERRMSG ( B$TCB.ALT$ -> B$ALT.ERR, B$TCB.ALT$ -> B$ALT.DCB# );
        CALL M$CLOSE(CLOSE_CONFIG);
        ALTRETURN;
        END TCS$CONFIG ;
%EOD;
/*M* TCT$READ - Procedure to process READ command.                 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCT$READ
 
PURPOSE:        To process the READ command.
                                                                   */
/*D*
NAME:           TCT$READ
 
CALL:           CALL TCT$READ ;
 
PARAMETERS:     None
                                                                   */
/*D*
DESCRIPTION:
 
The TCT$READ procedure is used to process the READ command.
                                                                   */
%EJECT;
/********************** ENTRY POINT ********************************/
TCT$READ:               PROC ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                B_ERRORS_C ;
        %INCLUDE                CMLOAD_C62 ;
        %INCLUDE                CMLOAD_C63 ;
        %INCLUDE                XU_MACRO_C ;
/********************** DCB REFERENCES *****************************/
DCL F$FIRMWARE DCB;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
        DCL 1 TCN$NOT_IMPLEMENTED  ENTRY(3) ;
/********************** EXTERNAL DATA REFERENCES *******************/
%XUG_GETCMD (NAME=XUG_GETCMD, STCLASS = SYMREF);
%B$TCB        (NAME = B$TCB,
               STCLASS = "BASED(B$TCB$)");
%B$ALT;
DCL 1 B$TCB$ PTR SYMREF;
%F$DCB;
%TCM_PIT;
%TCM_DCW;  /* DCW STRUCTURE  */
%TCM_IDCW;
%TCM_TDCW;
/********************** LOCAL DATA REFERENCES **********************/
%FPT_GDS(FPTN = FPT_GDS, RESULTS = VLP_VECTOR);
%PARSE$OUT    ( NAME = OUT$BLK, STCLASS = "BASED(XUG_GETCMD.OUT$)") ;
%PARSE$SYM    (NAME = OUT$SYM, STCLASS = "BASED(XUG_GETCMD.OUT$)") ;
/* FPT REFRERENCES */
%VLP_VECTOR;
%FPT_READ(FPTN = READ_TAPE, BIN = NO, DCB=F$FIRMWARE, WAIT=YES, BUF = CM_HEADER);
 
/*B*
TCT#INVALID_FW_TAPE   is a VLP_ERRCODE used to print the message:
                      "Invalid CM Firmware Tape/File"  */
 
/*E*
ERROR: TCT-E$TCT#INVALID_FW_TAPE-4
MESSAGE: Invalid CM Firmware Tape/File.
                                                        */
%VLP_ERRCODE (FPTN = TCT#INVALID_FW_TAPE, STCLASS = CONSTANT,
              ERR# = %E$TCT#INVALID_FW_TAPE, FCG = %TCM#FCG,
              MID = 'T', MON = %NO#, SEV=4);
 
/*B*
TCT#MISSING_TM   is a VLP_ERRCODE used to print the message:
                      "Expected tape mark missing following header" */
 
/*E*
ERROR: TCT-E$TCT#MISSING_TM-4
MESSAGE: Expected tape mark missing following header on %U1
                                                        */
%VLP_ERRCODE (FPTN = TCT#MISSING_TM, STCLASS = CONSTANT,
              ERR# = %E$TCT#MISSING_TM, FCG = %TCM#FCG,
              MID = 'T', MON = %NO#, SEV=4);
 
/*B*
TCT#NO_MEMORY_AVAIL   is a VLP_ERRCODE used to print the message:
                      "No system memory available, retry later." */
 
/*E*
ERROR: TCT-E$TCT#NO_MEMORY_AVAIL-4
MESSAGE: No system memory available, retry later.
                                                           */
%VLP_ERRCODE (FPTN=TCT#NO_MEMORY_AVAIL, STCLASS = CONSTANT,
              ERR# = %E$TCT#NO_MEMORY_AVAIL, FCG = %TCM#FCG,
              MID = 'T', MON = %NO#, SEV=4);
/*B*
TCT#HEADER_INFO   is a VLP_ERRCODE used to print the message:
                      "F/W header information from FT#IFAD:"     */
 
/*E*
ERROR: TCT-E$TCT#HEADER_INFO-0
MESSAGE: F/W header information from %U1:
         LABEL = %U2   CHECKSUM = %U3
                                                           */
%VLP_ERRCODE (FPTN=TCT#HEADER_INFO, STCLASS = CONSTANT,
              ERR# = %E$TCT#HEADER_INFO, FCG = %TCM#FCG,
              MID = 'T', MON = %NO#, SEV=0);
/*B*
TCT#INVLD_REC_SIZE   is a VLP_ERRCODE used to print the message:
                      "Invalid Rec Size = nnn from FT#IFAD:"     */
 
/*E*
ERROR: TCT-E$TCT#INVLD_REC_SIZE-6
MESSAGE: Invalid Rec Size = %U1 from %U2
         Bad firmware tape/file.
                                                           */
%VLP_ERRCODE (FPTN=TCT#INVLD_REC_SIZE, STCLASS = CONSTANT,
              ERR# = %E$TCT#INVLD_REC_SIZE, FCG = %TCM#FCG,
              MID = 'T', MON = %NO#, SEV=6);
 
DCL DCB$ PTR;
DCL MEM_SEG_PTR$ PTR;
DCL 1 PARSE_STRING STATIC,
    2 LEN UBIN BYTE CALIGNED,
    2 CHARS CHAR(80) INIT (' ');
DCL 1 CM_HEADER ALIGNED STATIC,
    2 CM3_FLAG     CHAR(6),
    2 REV          CHAR(2),
    2 *            CHAR(8),
    2 CKSUM        CHAR(8),
    2 HEX_FW_SIZE  CHAR(8),
    2 *            CHAR(49);
DCL 1 HEADER_INFO_1 STATIC,
    2 LEN UBIN BYTE CALIGNED,
    2 TEXT,
      3 PREFIX CHAR(6) UNAL,
      3 * CHAR(3) UNAL INIT(' '),
      3 * CHAR(6) UNAL INIT('REV = '),
      3 REV CHAR(2) UNAL;
DCL 1 HEADER_INFO_2 STATIC,
    2 LEN UBIN BYTE CALIGNED,
    2 TEXT,
      3 CKSUM CHAR(8) UNAL,
      3 * CHAR(3) UNAL INIT(' '),
      3 * CHAR(11) UNAL INIT('F/W SIZE = '),
      3 FW_SIZE CHAR(8) UNAL;
DCL 1 ARS_TEXT STATIC,
    2 LEN UBIN BYTE CALIGNED INIT(5),
    2 ASCII CHAR(5) UNAL;
DCL 1 EOF_FLAG BIT(1) UNAL;
DCL 1 NCHARS UBIN ALIGNED ;
DCL 1 ARS UBIN ALIGNED;
DCL 1 I UBIN;
DCL BLKSZ UBIN ALIGNED;
DCL 1 BUFF (0:0) UBIN ALIGNED BASED;
%EJECT;
/********************** PROCEDURE **********************************/
/* *** LOGIC WILL GO SOMETHING LIKE THIS:
   INITIALIZE FLAGS AND NECESSARY VARIABLES
   CALL ROUTINE TO OPEN THE TAPE (OR DISK FILE)
              THIS WILL ALSO
              DO ERROR PROCESSING
   CALL ROUTINE TO READ THE HEADER, THIS WILL ALSO
              VALIDATE THIS IS CM FIRMWARE
              CONVERT SIZE FIELD
   CALL M$GDS TO GET MEMORY SEGMENT
   ISUUE READ TO STEP OVER THE EOF TAPE MARK (IF TAPE)
   SET UP PTRS TO INTERNAL BUFFERS FOR THE F/W DATA
   SET UP DO WHILE LOOP TO READ REMAINDER OF F/W DATA
   SET FLAG THAT FW IS READ AND IN BUFFER
   RETURN  */
 
TCM_PIT.FLAGS.FWREAD# = '0'B;
EOF_FLAG = '0'B;
IF TCM_PIT.FW.P$ ~= ADDR(NIL) THEN DO;
   CALL M$FDS(FPT_GDS) WHENALTRETURN DO;
      CALL TCE$ERRMSG (B$TCB.ALT$ ->
         B$ALT.ERR);
      END; /* WHENALTRETURN DO */
   END; /* IF ... */
 
   TCM_PIT.FLAGS.FWREAD# = '0'B;
DCB$ = DCBADDR(DCBNUM(F$FIRMWARE));
CALL MT$OPEN WHENALTRETURN DO;
   TCM_PIT.FLAGS.FWREAD# = '0'B;
   RETURN;
   END;  /* WHENALTRETURN DO */
CALL MT$READ_HEADER WHENALTRETURN DO;
   RETURN;
   END; /* WHENALTRETURN DO */
 
CALL GET_MEMORY WHENALTRETURN DO;
   CALL TCE$ERRMSG (TCT#NO_MEMORY_AVAIL,,);
   RETURN;
   END;  /* WHENALTRETURN */
 
/* SEE IF TAPE OR DISK */
IF DCB$ -> F$DCB.ASN# = %DEVICE#
   THEN DO;
      /* SKIP OVER EOF MARK */
      CALL M$READ(READ_TAPE) WHENALTRETURN DO;
         IF DCB$-> F$DCB.TYC.EOF# THEN GOTO READ_FW_RECS;
            ELSE DO;
            CALL TCE$ERRMSG (B$TCB.ALT$ -> B$ALT.ERR,
               DCBNUM(F$FIRMWARE)) ;
            RETURN;
            END; /* ELSE DO */
         END; /* WHENALTRETURN */
      CALL TCE$ERRMSG(TCT#MISSING_TM,, VECTOR(PARSE_STRING));
      RETURN;
   END;  /* THEN DO */
 
/* NOW MOVE ALL FW RECORDS */
READ_FW_RECS:
EOF_FLAG = '0'B;
NCHARS = 0;
READ_TAPE.BUF_ = VLP_VECTOR; /* PUT FIRST RECORD HERE */
READ_TAPE.BUF_.BOUND = READ_TAPE.BUF_.BOUND - 4096 ;
 
LOOP: DO WHILE (NOT EOF_FLAG);
   CALL M$READ(READ_TAPE)
      WHENRETURN DO;
         ARS = DCB$ -> F$DCB.ARS#;
         IF ARS >= 512
            THEN ARS = 512;
         NCHARS = NCHARS + ARS;
        /* ADJUST VECTOR BY # CHARS READ */
        READ_TAPE.BUF_.BUF$ = PINCRC(READ_TAPE.BUF_.BUF$, ARS);
        /* THEN SHRINK REMAINING MEM BY WHAT WE JUST READ */
        READ_TAPE.BUF_.BOUND = READ_TAPE.BUF_.BOUND - ARS;
         END; /* WHENRETURN DO */
      WHENALTRETURN DO;
      IF B$TCB.ALT$ -> B$ALT.ERR.ERR# = %E$EOF THEN DO;
         EOF_FLAG = '1'B ; /* EOD REACHED ON FW   */
         TCM_PIT.FLAGS.FWREAD# = '1'B ; /* FW IS IN MEMORY OK */
         END; /* IF ... THEN DO */
      ELSE DO;
         CALL TCE$ERRMSG(B$TCB.ALT$ -> B$ALT.ERR,
              DCBNUM(F$FIRMWARE));
         RETURN;
         END; /* ELSE DO */
      END; /* WHENALTRETURN DO */
END; /* LOOP */
TCM_PIT.FW.NWORDS = (NCHARS +3) / 4;
 
CALL MT$CLOSE WHENALTRETURN DO;
   CALL TCE$ERRMSG(B$TCB.ALT$ -> B$ALT.ERR,
      DCBNUM(F$FIRMWARE));
   END; /* WHENALTRETURN DO */
RETURN; /* RETURN FROM MAIN */
%EJECT;
/* *** SUBROUTINES FOLLOW *** */
 
GET_MEMORY: PROC  ALTRET;
/* ALLOCATE THE MEMORY SEGMENT FOR THE DCWLISTS AND FOR THE
FIRMWARE. THE FIRMWARE WILL BE STORED AT ONE PAGE (1024 WORDS)
OFFSET IN THIS SEGMENT. PERTINENT DATA REFERENCES ARE;
   TCM_PIT.FW.SEG_ POINTS TO BEGINNING OF ENTIRE SEGMENT,
   TCM_PIT.FW.P$   POINTS TO START OF FIRMWARE DATA.
THIS ENTIRE SEGMENT IS INITIALIZED TO ZEROES.
*/
 
DCL FW_OFFSET UBIN;
   FW_OFFSET = 1024; /* 1ST PAGE IS FOR TCL$LOAD */
   FPT_GDS.V.SEGSIZE# =
   (((BLKSZ + 512 + 4095) / 4096) * 1024) + FW_OFFSET ;
   CALL M$GDS(FPT_GDS) ALTRET(MON_ERR);
   /* PASS TCL$LOAD BEGIN OF SEGMENT */
   TCM_PIT.FW.SEG_ = VLP_VECTOR;
   MEM_SEG_PTR$ = VLP_VECTOR.PTR$; /* STRT OF MEM SEG */
 
   /* SAVE PTR TO START OF FIRMWARE AREA */
   VLP_VECTOR.PTR$ = PINCRW(VLP_VECTOR.PTR$, FW_OFFSET);
   TCM_PIT.FW.P$ = VLP_VECTOR.PTR$;
   DO I = 0 TO FPT_GDS.V.SEGSIZE# - 1 ;
      MEM_SEG_PTR$ -> BUFF(I) = 0 ; /* CLEAR WHOLE SEGMENT */
      END;
RETURN;
        DO WHILE('0'B);
MON_ERR:
          ALTRETURN;
          END;
END GET_MEMORY;
%EJECT;
MT$CLOSE: PROC  ALTRET;
%FPT_CLOSE(FPTN=TAPE_CLOSE, DCB=F$FIRMWARE);
CALL M$CLOSE(TAPE_CLOSE) WHENALTRETURN DO;
   CALL TCE$ERRMSG(B$TCB.ALT$ -> B$ALT.ERR,
      DCBNUM(F$FIRMWARE));
   END; /* WHENALTRETURN DO */
RETURN;
END MT$CLOSE;
 
%EJECT;
MT$OPEN: PROC  ALTRET;
/* IF TAPE THE DEFAULT DENSITY, IF NONE SPECIFIED IS 1600. IF THE
NUMBER OF SUBBLOCKS IS > 1, THEN A DENSITY WAS PROVIDED AND THE CASE
STATEMENT WILL SUBSTITUTE THE CORRECT DENSITY.
THIS ROUTINE OPENS THE TAPE (OR FILE) AND RETURNS.                */
 
%VLP_NAMEV (FPTN = FID);
%FPT_OPEN(FPTN=TAPE_OPEN, ACCT=SYSACCT, NAME=FNAME, SN=TAPE_SN,
          DCB = F$FIRMWARE, FUN = IN, SCRUB=YES, REASSIGN=YES) ;
%VLP_SN (FPTN = TAPE_SN, N=1);
%VLP_NAME (FPTN = FNAME, STCLASS=STATIC);
%VLP_ACCT (FPTN = SYSACCT);
%FPT_FID (FPTN = FPT_FID, ACCT = SYSACCT, ASN = TAPE_OPEN.V.ASN#,
          RES = TAPE_OPEN.V.RES#, SN = TAPE_SN,
          TEXTFID = PARSE_STRING, NAME = FNAME);
 
PARSE_STRING.LEN = OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
PARSE_STRING.CHARS = OUT$BLK.SUBLK$(0)-> OUT$SYM.TEXT;
FPT_FID.TEXTFID_ = VECTOR(ADDR(PARSE_STRING) -> FID.NAME#);
CALL M$FID(FPT_FID);
IF TAPE_OPEN.V.ASN# = %DEVICE# THEN DO;  /* INPUT IS TAPE */
   TAPE_OPEN.V.DENSITY# = TCO#D1600 ;
IF OUT$BLK.NSUBLKS > 1 THEN  /* DENSITY OPTION IS PRESENT */
   DO CASE (OUT$BLK.SUBLK$(1) -> OUT$SYM.CODE) ;
      CASE (TCO#D800);
         TAPE_OPEN.V.DENSITY# = TCO#D800;
      CASE (TCO#D1600);
         TAPE_OPEN.V.DENSITY# = TCO#D1600;
      CASE (TCO#D6250);
         TAPE_OPEN.V.DENSITY# = TCO#D6250;
      CASE (ELSE);
         CALL TCN$NOT_IMPLEMENTED ( ADDR ( OUT$BLK ),
            XUG_GETCMD.OUT$,) ;
      END; /* CASE */
   END; /* IF TAPE_OPEN.V.ASN# = DEVICE */
 
CALL M$OPEN(TAPE_OPEN) WHENALTRETURN DO;
    CALL TCE$ERRMSG(B$TCB.ALT$ -> B$ALT.ERR,
       DCBNUM(F$FIRMWARE));
    TCM_PIT.FLAGS.FWREAD# = '0'B;
    ALTRETURN;
    END; /* WHENALTRETURN DO */
 
RETURN;
END MT$OPEN;
 
%EJECT;
MT$READ_HEADER: PROC   ALTRET;
/*  THIS ROUTINE WILL
   VALIDATE THAT WE HAVE A CM TAPE/FILE,
   SAVE HEADER VARIABLES IN THE PIT,
   CONVERT THE HEX SIZE TO BINARY,
   */
 
READ_TAPE.BUF_ = VECTOR(CM_HEADER);
CALL M$READ(READ_TAPE) WHENALTRETURN DO;
   CALL TCE$ERRMSG(B$TCB.ALT$ -> B$ALT.ERR,
      DCBNUM(F$FIRMWARE));
      END; /* WHENALTRETURN */
IF CM_HEADER.CM3_FLAG ~= 'CM3COS' THEN DO;
   CALL TCE$ERRMSG (TCT#INVALID_FW_TAPE,,);
   ALTRETURN;
   END; /* IF CM_HEADER */
TCM_PIT.FW.LABEL.PREFIX = CM_HEADER.CM3_FLAG;
HEADER_INFO_1.TEXT.PREFIX = CM_HEADER.CM3_FLAG;
TCM_PIT.FW.LABEL.REV =    CM_HEADER.REV;   /* SAVE REVISION ALSO */
HEADER_INFO_1.TEXT.REV = CM_HEADER.REV;
HEADER_INFO_2.TEXT.CKSUM = CM_HEADER.CKSUM;
CALL HEX_BIN (CM_HEADER.CKSUM, BLKSZ);
TCM_PIT.FW.LABEL.CKSUM = BLKSZ;
HEADER_INFO_2.TEXT.FW_SIZE = CM_HEADER.HEX_FW_SIZE;
CALL HEX_BIN (CM_HEADER.HEX_FW_SIZE, BLKSZ);
TCM_PIT.FW.LABEL.LEN = BLKSZ; /* NUM BYTES */
HEADER_INFO_1.LEN = SIZEC(HEADER_INFO_1.TEXT);
HEADER_INFO_2.LEN = SIZEC(HEADER_INFO_2.TEXT);
CALL TCE$ERRMSG (TCT#HEADER_INFO,, VECTOR(PARSE_STRING),
                 VECTOR(HEADER_INFO_1), VECTOR(HEADER_INFO_2));
RETURN;
%EJECT;
/* CONVERT HEX NUMBER TO BINARY */
HEX_BIN: PROC (STRING, BLKSZ);
DCL BLKSZ UBIN;
DCL SUM UBIN;
DCL J SBIN;
DCL K UBIN;
DCL P16 UBIN;
DCL 1 WORK,
    2 WORDS CHAR(8),
    2 CHARS REDEF WORDS,
      3 X (0:7) CHAR(1);
DCL STRING CHAR(8) ; /* HEX NUMBER INPUT VALUE */
DCL 1 TABLE CALIGNED,
    2 WORD2 CHAR(16),
    2 CHARS REDEF WORD2,
      3 N (0:15) CHAR(1);
/******************************************************************/
SUM = 0;
WORK.WORDS = STRING;
TABLE.WORD2 = '0123456789abcdef';
DO J = 0 TO 7;  /* FOR THE ENTIRE BYTE */
  DO K = 0 TO 15;
    IF WORK.CHARS.X(J) = TABLE.CHARS.N(K)
      THEN DO;
        SUM = (SUM * 16) + K;
      END;
  END;
END;
BLKSZ = SUM;  /* BLKSZ = NUM OF BYTES */
RETURN;
END HEX_BIN;
END MT$READ_HEADER;
 
END TCT$READ;
%EOD;
/*M* TCX$XCON - Exit control procedure                             */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCX$XCON
 
PURPOSE:        To provide the exit control procedure for the
                CMLOAD program.
                                                                   */
/*D*
NAME:           TCX$XCON
 
CALL:           None.
 
PARAMETERS:     None.
 
DESCRIPTION:
 
The TCX$XCON procedure is the exit control procedure for the CMLOAD
program.  TCX$XCON calls the TCY$XCONREST procedure to reset the
user environment modified by the CMLOAD program.
Finally, TCX$XCON calls TCQ$QUIT to terminate the CMLOAD program.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCX$XCON:       PROC ASYNC ;
/********************** INCLUDE FILES *****************************/
        %INCLUDE                CMLOAD_C63;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCQ$QUIT          ENTRY ;
        DCL 1 TCY$XCONREST         ENTRY ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %TCM_PIT;
/********************** PROCEDURE **********************************/
/*
If the Firmware Load in is progress, do not user to interrupt.
                                                                   */
        IF TCM_PIT.FLAGS.FWLIP# = '1'B
           THEN RETURN;
/*
Call the TCY$XCONREST procedure to reset the user environment
that may have been modified by the CMLOAD program.
                                                                   */
        CALL TCY$XCONREST ;
/*
Call the TCQ$QUIT procedure to terminate the CMLOAD program.
                                                                   */
        CALL TCQ$QUIT ;
        END TCX$XCON ;
        %EOD ;
/*M* TCY$XCONREST - Exit Control Reset procedure                                   */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
NAME:           TCY$XCONREST
 
PURPOSE:        To reset user environment and exit control.
                                                                   */
/*D*
NAME:           TCY$XCONREST
 
CALL:           CALL TCY$XCONREST ALTRET ( error ) ;
 
PARAMETERS:     None.
                                                                   */
/*D*
DESCRIPTION:
 
The TCY$XCONREST procedure is used to reset the user environment and
exit control that were modified for the CMLOAD program.
                                                                   */
        %EJECT ;
/********************** ENTRY POINT ********************************/
TCY$XCONREST:      PROC ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CMLOAD_C63 ;
/********************** EXTERNAL PROCEDURE REFERENCES **************/
        DCL 1 TCE$ERRMSG        ENTRY(6) ;
/********************** EXTERNAL DATA REFERENCES *******************/
        %TCM_PIT ;
/********************** LOCAL DATA DEFINITIONS *********************/
/*
XCON_RESET      specifies a FPT_XCON structure that is used to
        reset the exit control procedure to the previous level
        if a previous level was specified.
                                                                   */
        %FPT_XCON               ( FPTN = XCON_RESET
                                , STCLASS = STATIC
                                                                ) ;
/********************** PROCEDURE **********************************/
/*
Re-establish the previous exit control procedure if one had been
established.  Reset the exit control procedure flag in TCM_PIT.
Do a M$XCON to either establish the previous exit control procedure
or to remove the last exit control procedure.
                                                                   */
        IF  TCM_PIT.FLAGS.XCON# = %YES#  THEN DO ;
            XCON_RESET.V.UENTRY# = TCM_PIT.PXCON$$ ;
            CALL M$XCON ( XCON_RESET ) ;
            TCM_PIT.FLAGS.XCON# = %NO# ;
            END ;
/*
Return to the calling procedure.
                                                                   */
        RETURN ;
        END TCY$XCONREST ;
        %EOD ;
/*M* XUF$MERGE_FID - Routine to merge two fids.                    */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*F*
Name:           XUF$MERGE_FID
 
Call:           CALL XUF$MERGE_FID ( fid_, fid1$, fid2$ )
.                    [ ALTRET ( error ) ] ;
 
.*B*            PARAMETERS fid
Parameters:
 
fid_            is a VECTOR that frames the TEXTC structure that is
      returned with the full fid generated from the contents of the
      merger of the two fids.
 
.*B*            fid1$
fid1$           is aPTR to a TEXTC structure that specifies the
        base fid to be used in the merger.
 
.*B*            fid2$
fid2$           is a PTR to a TEXTC structure that specifies the
        second fid to be used in the merger.  All fields present in
        the fid point to by fid2$ will replace the respective field
        in the fid pointed to by fid1$.
 
.*B*            error
error           is a label to which XUF$MERGE_FID will be an
        ALTRETURN if an error is detected.  The error code will
        be in the ALTRET frame of the TCB.
 
.*B*            DESCRIPTION
Description:
 
The XUF$MERGE_FID procedure is sued to merge one fid (or a portion
of one fid) into another fid to generate a new fid.  A full fid
is of the form:
 
.       [dev[nn]#sn][/]filename[.[account].[password]]@wsn]
 
(A complete description of the full fid can be found in the CP-6
Programmer Reference Manual.)  Generally, the first fid is a
complete (valid) fid and the second fid is a parital (and maybe
invalid) fid made up of the fields that are to be replaced in the
first fid.
 
.*B*            ENVIRONMENT
Environment:    Unprivileged user procedure.
 
                                                                   */
        %EJECT ;
XUF$MERGE_FID:  PROC ( FID_, FID1$, FID2$ ) ALTRET ;
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6 ;
        %INCLUDE                CP_6_SUBS ;
/*********************  LOCAL DATA DEFINITIONS *********************/
/*
ACCT            is an array of VLP_ACCT structures used in the
        M$FID processing of the TEXTFIDS pointed to by FID1$ and
        FID2$.
                                                                   */
        %VLP_ACCT               ( FPTN = "ACCT(0:1)"
                                , STCLASS = STATIC
                                                                ) ;
/*
LEN             is a UBIN WORD that is used to receive the length
        of the newly created fid.
                                                                   */
        DCL 1 LEN               UBIN WORD ALIGNED STATIC ;
/*
ASN             is an aray of UBIN BYTE variables used in the
        M$FID processing on the TEXTFIDs pointed to by FID1$ and
        FID2$.
                                                                   */
        DCL 1 ASN(0:1)          UBIN BYTE CALIGNED STATIC ;
/*
FID$            is a PTR variable that is used to form the correct
        vector for UNFID.TEXTFID_.
                                                                   */
        DCL 1 FID$              PTR ALIGNED AUTO ;
/*
FID1            is a FPT_FID structure used to do the M$FID
        processing on the TEXTFID pointed to by FID1$.
                                                                   */
        %FPT_FID                ( FPTN = FID1
                                , STCLASS = STATIC
                                , ACCT = "ACCT(0)"
                                , ASN = "ASN(0)"
                                , PASS = "PASS(0)"
                                , RES = "RES(0)"
                                , WSN = "WSN(0)"
                                                                ) ;
/*
FID2            is a FPT_FID structure used to do the M$FID
        processing on the TEXTFID pointed to by FID2$.
                                                                   */
        %FPT_FID                ( FPTN = FID2
                                , STCLASS = STATIC
                                , ACCT = "ACCT(1)"
                                , ASN = "ASN(1)"
                                , PASS = "PASS(1)"
                                , RES = "RES(1)"
                                , WSN = "WSN(1)"
                                                                ) ;
/*
NAME@           is an array of VLP_NAME structures used in the
        M$FID processing of the TEXTFIDs pointed to by FID1$ and
        FID2$.
                                                                   */
        %VLP_NAME               ( FPTN = "NAME@(0:1)"
                                , STCLASS = AUTO
                                , LEN = 31
                                                                ) ;
/*
PASS           is an array of VLP_PASS structures used in the
        M$FID processing of the TEXTFIDs pointed to by FID1$ and
        FID2$.
                                                                   */
        %VLP_PASS               ( FPTN = "PASS(0:1)"
                                , STCLASS = STATIC
                                                                ) ;
/*
RES             is an array of CHAR(4) variables used in the
        M$FID processing of the TEXTFIDs pointed to by FID1$ and
        FID2$.
                                                                   */
        DCL 1 RES(0:1)          CHAR(4) CALIGNED STATIC ;
/*
RESULTS@        is an array of VLR_FID structures that are the
        results returned from the M$FID processing of the TEXTFIDs
        pointed to by FID1$ and FID2$.
                                                                   */
        %VLR_FID                ( FPTN = "RESULTS@(0:1)"
                                , STCLASS = AUTO
                                                                ) ;
/*
SN@             is an array of VLP_SN structures that are used in
        the M$FID processing of the TEXTFIDs pointed to by FID1$ and
        FID2$.   (The VLP_SN macro could not be used because it
        generates an array of sn's.  And an array of arrays is not
        allowed!)
                                                                   */
        DCL 1 SN@(0:1)          ALIGNED AUTO,
              2 NUM#            SBIN WORD,
              2 SN1             CHAR(6) CALIGNED,
              2 SN2             CHAR(6) CALIGNED,
              2 SN3             CHAR(6) CALIGNED ;
/*
UNFID           is a FPT_UNFID structure that is used to merge the
        two fids to produce the output fid.
                                                                   */
        %FPT_UNFID              ( FPTN = UNFID
                                , STCLASS = STATIC
                                , LEN = LEN
                                                                ) ;
/*
VLP$NAME        is a based VLP_NAMEV structure that is used to
        access the various TEXTC structures.
                                                                   */
        %VLP_NAMEV              ( FPTN = VLP$NAME
                                , STCLASS = BASED
                                                                ) ;
/*
WSN             is an array of VLP_WSN structures used in the
        M$FID processing of the TEXTFIDs pointed to by FID1$ and
        FID2$.
                                                                   */
        %VLP_WSN                ( FPTN = "WSN(0:1)"
                                , STCLASS = STATIC
                                                                ) ;
/********************** PARAMETER DEFINITIONS **********************/
        DCL 1 FID1$             PTR PARAM ;
        DCL 1 FID2$             PTR PARAM ;
        DCL 1 FID_              VECTOR PARAM ;
        %EJECT ;
/********************** PROCEDURE **********************************/
/*
Do a M$FID on the TEXTFID pointed to by FID1$.  If an error is
detected, go to make an altreturn to the calling procedure.
                                                                   */
        FID1.NAME_    = VECTOR ( NAME@(0) ) ;
        FID1.RESULTS_ = VECTOR ( RESULTS@(0) ) ;
        FID1.SN_      = VECTOR ( SN@(0) ) ;
        FID1.TEXTFID_ = VECTOR ( FID1$ -> VLP$NAME.NAME# ) ;
        CALL M$FID ( FID1 )                     ALTRET ( ERROR ) ;
/*
Do a M$FID on the TEXTFID pointed to by FID2$.  If an error is
detected, go to make an altreturn to the calling procedure.
                                                                   */
        FID2.NAME_    = VECTOR ( NAME@(1) ) ;
        FID2.RESULTS_ = VECTOR ( RESULTS@(1) ) ;
        FID2.SN_      = VECTOR ( SN@(1) ) ;
        FID2.TEXTFID_ = VECTOR ( FID2$ -> VLP$NAME.NAME# ) ;
        CALL M$FID ( FID2 )                     ALTRET ( ERROR ) ;
/*
Build the FPT_UNFID to merge the second fid into the first fid.
                                                                   */
/*                                              ACCT               */
        IF  RESULTS@.ACCT(1) = %YES#  THEN
            UNFID.ACCT_ = VECTOR ( ACCT(1) ) ;
        ELSE  IF  RESULTS@.ACCT(0) = %YES#  THEN
            UNFID.ACCT_ = VECTOR ( ACCT(0) ) ;
        ELSE
            UNFID.ACCT_ = VECTOR ( NIL ) ;
/*                                              ASN                */
        IF  RESULTS@.ASN(1) = %YES#  THEN
            UNFID.ASN_ = VECTOR ( ASN(1) ) ;
        ELSE  IF  RESULTS@.ASN(0) = %YES#  THEN
            UNFID.ASN_ = VECTOR ( ASN(0) ) ;
        ELSE
            UNFID.ASN_ = VECTOR ( NIL ) ;
/*                                              NAME               */
        IF  RESULTS@.NAME(1) = %YES#  THEN
            UNFID.NAME_ = VECTOR ( NAME@(1) ) ;
        ELSE  IF  RESULTS@.NAME(0) = %YES#  THEN
            UNFID.NAME_ = VECTOR ( NAME@(0) ) ;
        ELSE
            UNFID.NAME_ = VECTOR ( NIL ) ;
/*                                              PASS               */
        IF  RESULTS@.PASS(1) = %YES#  THEN
            UNFID.PASS_ = VECTOR ( PASS(1) ) ;
        ELSE  IF  RESULTS@.PASS(0) = %YES#  THEN
            UNFID.PASS_ = VECTOR ( PASS(0) ) ;
        ELSE
            UNFID.PASS_ = VECTOR ( NIL ) ;
/*                                              RES                */
        IF  RESULTS@.RES(1) = %YES#  THEN
            UNFID.RES_ = VECTOR ( RES(1) ) ;
        ELSE  IF  RESULTS@.RES(0) = %YES#  THEN
            UNFID.RES_ = VECTOR ( RES(0) ) ;
        ELSE
            UNFID.RES_ = VECTOR ( NIL ) ;
/*                                              SN                 */
        IF  RESULTS@.SN(1) = %YES#  THEN
            UNFID.SN_ = VECTOR ( SN@(1) ) ;
        ELSE  IF  RESULTS@.SN(0) = %YES#  THEN
            UNFID.SN_ = VECTOR ( SN@(0) ) ;
        ELSE
            UNFID.SN_ = VECTOR ( NIL ) ;
/*                                              WSN                */
        IF  RESULTS@.WSN(1) = %YES#  THEN
            UNFID.WSN_ = VECTOR ( WSN(1) ) ;
        ELSE  IF  RESULTS@.WSN(0) = %YES#  THEN
            UNFID.WSN_ = VECTOR ( WSN(0) ) ;
        ELSE
            UNFID.WSN_ = VECTOR ( NIL ) ;
/*
Define the TEXTFID area where the merged fid is to be built.  Then
call m$UNFID to build the merged fid and set the length of the
merged fid to the value returned by M$UNFID.
                                                                   */
        FID$ = VBASE ( FID_ ) ;
        FID$ -> VLP$NAME.L# = VBOUND ( FID_ ) ;
        UNFID.TEXTFID_ = VECTOR ( FID$ -> VLP$NAME.NAME# ) ;
        CALL M$UNFID ( UNFID )                  ALTRET ( ERROR )  ;
        FID$ -> VLP$NAME.L# = LEN ;
/*
Return to the calling procedure.
                                                                   */
        RETURN ;
/*
An error has been detected.  Make an altreturn to the calling
procedure.
                                                                   */
ERROR:  ALTRETURN ;
        END XUF$MERGE_FID ;
