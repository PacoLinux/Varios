/*M* FILER_SI3 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* THI=1,PLM=3,IND=3 */
%EJECT;
/*********************************************************************/
/**
***   UT_FLUSH_BUF   3 OCT 77   (PRY)   FLUSHES THE OUTPUT BUFFER.
**/
 
UT_FLUSH_BUF: PROC;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   WRITE THE OUTPUT BUFFER   ***/
DCL   UT_WRITE_BUF           ENTRY(2);
 
/********************
***   IF ANYTHING TO OUTPUT, PRINT IT.
**/
   IF OUT_CHARX > 0                     /* ANYTHING TO OUTPUT?                */
    THEN DO;                            /* YES                                */
      OUT_BUF$ -> UBIN9#(OUT_CHARX) = CT_CR; /* PUT CR IN BUFFER              */
      OUT_CHARX        = OUT_CHARX + 1; /* INCLUDE IN CHAR COUNT              */
      CALL UT_WRITE_BUF( OUT_BUF$, OUT_CHARX );
      OUT_CHARX = 0;                    /* RESET CHAR IX                      */
                                        /* WRITE THE BUFFER                   */
      END;
 
   RETURN;
 
END UT_FLUSH_BUF;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/**********************************************************************/
/*
***   EV_FPT_RANGE   8 OCT 77   (PRY)   EVALUATE RANGE SPECIFIED BY
***   FPT FIELD QUALIFICATION.
*/
 
EV_FPT_RANGE: PROC( RANGE_STRT#, RANGE_SIZE# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%INCLUDE FILER_II1;
%INCLUDE FILER_II0;
/***   LOOK UP A NAME   ***/
DCL   UT_LOOKUP              ENTRY(3);
 
/***   GET AN SBIN WORD VALUE   ***/
DCL   UT_SBIN_VALUE          ENTRY(1);
/***   INCREMENT THE CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   GET THE NEXT NAME   ***/
DCL   UT_GET_NAME            ENTRY;
 
/***   IGNORE BLANKS   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
/***************
***   PARAMETERS:
*/
DCL   RANGE_STRT#    SBIN WORD ALIGNED; /* RETURNED RANGE START BIT           */
DCL   RANGE_SIZE#    SBIN WORD ALIGNED; /* RETURNED RANGE SIZE                */
 
/*******************
***   LOCALS:
**/
DCL  NAME_FOUND SBIN WORD ALIGNED AUTO; /* FLAG SET IF NAME FOUND             */
DCL   TBL_IX    SBIN WORD ALIGNED AUTO; /* NAME TABLE INDEX                   */
DCL   FPTPTR_TBL$       PTR       ALIGNED   AUTO;
                                        /* POINTER TO FPT POINTER TABLE       */
DCL   PREV_IX           SBIN WORD ALIGNED   AUTO;
                                        /* INDEX OF PREVIOUS FPT ITEM         */
DCL   FPTINFO$          PTR       ALIGNED   AUTO;
                                        /* POINTER TO FPT INFO TABLE          */
DCL   LOOKING           SBIN WORD ALIGNED   AUTO;
                                        /* LOOKING FOR FPT NAME FLAG          */
DCL   SUBIX               SBIN WORD ALIGNED   AUTO;
                                        /* INDEX OF SUB ITEM                  */
DCL   CMNDPTR_TBL$        PTR       ALIGNED   AUTO;
                                        /* POINTER TO COMMAND POINTER TABLE   */
DCL   DIM_MULT  SBIN WORD ALIGNED AUTO; /* DIMENSION MULTIPLIER               */
DCL   NBR_DIMS  SBIN WORD ALIGNED AUTO; /* # ELEMENTS IN VECTOR               */
DCL   LEV_LIM           SBIN WORD ALIGNED   AUTO;
                                        /* STRUCTURE TREE SEARCH DEPTH LIMIT  */
DCL   STK_IX    SBIN WORD ALIGNED AUTO; /* TREE SEARCH STACK INDEX            */
DCL   SUBIX_STK(0:10)   SBIN WORD ALIGNED   AUTO;
          /* TREE SEARCH STACK: SAVES IX OF PREVIOUSLY CHECKED ITEM (NODE)    */
/***************
***   SKIP OVER THE INITIAL '.'; GET THE FPT NAME AND IDENTIFY IT.
*/
   CALL UT_INC_CHARX;                   /* SKIP OVER THE .                    */
   CALL UT_GET_NAME;                    /* GET THE FPT NAME                   */
   IF CRNT_NAME.LENGTH <= 0             /* GET ANY?                           */
    THEN DO;                            /* NO                                 */
      VAL_FAULT = 58;
                    /*E* 58V EV_FPT_RANGE: THE EXPECTED FPT NAME IS MISSING   */
      RETURN;
      END;
 
   CMNDPTR_TBL$ = ADDR( CMNDPTR_TBL );
                                        /* GET POINTER TO COMMAND TABLE       */
                                        /* I.E. FPT NAME TABLE                */
   TBL_IX = -1;                         /* START SEARCH WITH FIRST ITEM       */
   CALL UT_LOOKUP( CMNDPTR_TBL$, TBL_IX );
   IF TBL_IX < 0                        /* FIND IT ?                          */
    THEN DO;
      VAL_FAULT = 59; /*E* 59V EV_FPT_RANGE: THIS FPT NAME IS UNKNOWN */
      RETURN;
      END;
 
/********************
***   NOW LOOK UP EACH ADDITIONAL NAME TO GET THE FIELD
***   LOCATION AND SIZE.
**/
   FPTPTR_TBL$ = CMNDPTR_TBL.FPT_PTR -> PTR#$(TBL_IX);
                              /* GET THE POINTER TO THE FPT POINTER TABLE     */
   PREV_IX     = FPTPTR_TBL$ -> FPT_TBL.MAJOR;
                                        /* GET INDEX OF THE MAJOR ITEM        */
   FPTINFO$    = FPTPTR_TBL$ -> FPT_TBL.INFO;
                                   /* GET THE POINTER TO THE FPT INFO TABLE   */
   DIM_MULT    = 0;                     /* INITIALIZE DIM MULTIPLIER          */
   CALL UT_IGNORE_BLANKS;               /* FIND THE NEXT . (IF ANY)           */
   DO WHILE (CHARX <= CHARX_MAX  AND  C = CT_PERIOD);
      CALL UT_INC_CHARX;                /* SKIP OVER THE PERIOD               */
         /**
         ***  GET THE NEXT SUBORDINATE NAME AND IDENTIFY IT.
         **/
      CALL UT_GET_NAME;                 /* GET THE SUBORDINATE NAME           */
      IF CRNT_NAME.LENGTH <= 0          /* NAME THERE?                        */
       THEN DO;                         /* NO                                 */
         VAL_FAULT = 60;
          /*E* 60V EV_FPT_RANGE: THE EXPECTED SUBORDINATE NAME IS MISSING     */
         RETURN;
         END;
      TBL_IX  = -1;                     /* INITIALIZE SEARCH FOR NAME         */
      LOOKING = 1;
      NAME_FOUND = 0;                   /* ASSUME NAME NOT FOUND              */
         /**
         ***   SINCE THE SAME NAME MAY BE USED AT A NUMBER OF DIFFERENT
         ***   LEVELS, WE NEED TO KEEP TRYING TO FIND THE NAME (AGAIN)
         ***   UNTIL IT EITHER CAN'T BE FOUND (AGAIN) OR THE PROPER
         ***   FPT FIELD (NAME) HAS BEEN IDENTIFIED.
         **/
      DO WHILE (LOOKING = 1);           /* SEARCH UNTIL FOUND                 */
         CALL UT_LOOKUP( FPTPTR_TBL$, TBL_IX );
                                        /* FIND NAME                          */
         IF TBL_IX < 0                  /* ?                                  */
          THEN DO;                      /* NOT FOUND                          */
            IF NAME_FOUND = 0
             THEN VAL_FAULT = 61;
                    /*E* 61V EV_FPT_RANGE: THIS SUBORDINATE NAME IS UNKNOWN   */
             ELSE VAL_FAULT = 65;
                              /*E* 65V EV_FPT_RANGE: THIS IS NOT SUBORDINATE  */
            RETURN;
            END;
          ELSE NAME_FOUND = 1;          /* NAME IS FOUND                      */
              /**
              ***   FIND THE NAMED ITEM IN THE STRUCTURE TREE.
              ***   THE ITEM MUST BE A SUBORDINATE OF THE PREVIOUS
              ***   ITEM.  THE TREE IS SEARCHED BY LEVELS TO AVOID
              ***   AMBIGUITY PROBLEMS OCCURING DUE TO SUBORDINATE
              ***   ITEMS WITH THE SAME NAMES BUT AT DIFFERENT LEVELS.
              ***   THE SUBORDINATE AT THE NEAREST LEVEL IS FOUND
              ***   FIRST.
              **/
         LEV_LIM = -1;                  /* INIT SEARCH LEVEL DEPTH            */
         SUBIX   = -1;                  /* INIT SEARCH IX WITH 'NONE'         */
         DO WHILE (LEV_LIM < 5  AND
           (SUBIX < 0  OR  SUBIX > MASKR(17)) );
                         /* SEARCH SUCCESSIVE LEVELS WHILE ITEM NOT FOUND     */
            SUBIX = FPTINFO$ -> FPT_INFO.SUBSIX(PREV_IX);
                         /* START SEARCH WITH FIRST SUBORDINATE OF PREVIOUS   */
            STK_IX = -1;                /* INIT STACK INDEX                   */
            DO WHILE (SUBIX ~= TBL_IX  AND
              SUBIX >= 0  AND  SUBIX <= MASKR(17));
                              /* SEARCH CURRENT PATH WHILE ITEM NOT FOUND AND */
                                        /* ITEMS REMAIN TO BE SEARCHED        */
               IF LEV_LIM <= STK_IX     /* SEARCH DEPTH LIMIT HIT?            */
                THEN DO;                /* YES: TRY FELLOW AT SAME LEVEL      */
                  SUBIX = FPTINFO$ -> FPT_INFO.FELLOIX(SUBIX);
                                   /* GET IX OF FELLOW ITEM AT SAME LEVEL     */
                  CALL UT_BACKUP;
                                   /* BACK UP TO PREVIOUS ITEM IF NO MORE     */
                                   /* REMAIN TO BE SEARCHED AT THIS LEVEL     */
                  END;
                ELSE DO;                /* DEPTH LIMIT WAS NOT HIT            */
                  STK_IX = STK_IX + 1;
                                        /* PUSH CURRENT POSITION IN TREE ON   */
                                   /* THE STACK SO WE KNOW WHERE TO RESUME    */
                                        /* SEARCH IF THIS PATH IS FRUITLESS   */
                  SUBIX_STK(STK_IX) = SUBIX;
                  SUBIX = FPTINFO$ -> FPT_INFO.SUBSIX(SUBIX);
          /* GET IX OF FIRST ITEM OF SUBTREE (BEGIN SEARCH OF LOWER LEVEL)    */
                  CALL UT_BACKUP;
                                   /* BACK UP TO PREVIOUS ITEM IF NO MORE     */
                                   /* REMAIN TO BE SEARCHED ALONG THIS PATH   */
                  END;
               END;
            LEV_LIM = LEV_LIM + 1;      /* INCREMENT SEARCH DEPTH             */
            END;
         IF SUBIX = TBL_IX THEN LOOKING = 0;
                                        /* IF FOUND, WE'RE DONE LOOKING       */
         END;
         /**
         ***   GET READY TO FIND NEXT SUBORDINATE NAME.
         **/
      PREV_IX = SUBIX;                  /* FOUND IX IS NEW PREVIOUS           */
         /**
         ***   IF ITEM IS A VECTOR, CALCULATE UNIT SIZE.
         **/
      TEMP1 = FPTINFO$ -> FPT_INFO.DIMS(PREV_IX) + 1;
                                        /* GET SIZE OF VECTOR (IF VECTOR)     */
      IF TEMP1 > 1                      /* VECTOR?                            */
       THEN DIM_MULT = FPTINFO$ -> FPT_INFO.SIZE(PREV_IX)  / TEMP1;
                                        /* YES: SAVE DIMENSION MULTIPLIER     */
      CALL UT_IGNORE_BLANKS;            /* FIND NEXT . (IF ANY)               */
      END;
 
/********************
***   FPT RANGE SPECIFICATION WAS CORRECT.
**/
   RANGE_STRT# = FPTINFO$ -> FPT_INFO.LOC(PREV_IX);
                                        /* RETURN START OF RANGE              */
   NBR_DIMS    = FPTINFO$ -> FPT_INFO.DIMS(PREV_IX) + 1;
                                        /* GET NUMBER OF ELEMENTS IN VECTOR   */
   RANGE_SIZE# = FPTINFO$ -> FPT_INFO.SIZE(PREV_IX) / NBR_DIMS;
                                        /* AND SIZE                           */
   DO CASE(FPTINFO$ -> FPT_INFO.TYPE(PREV_IX));
                                        /* SET DEFAULT DISPLAY TYPE           */
    CASE(4);                            /* CHARACTER                          */
      DFLT_DT = DT_TEXT;
    CASE(6,7);                          /* UBIN, SBIN                         */
      DFLT_DT = DT_DECIMAL;
    CASE(ELSE);                         /* BIT, ETC.                          */
      DFLT_DT = DT_MACHINE;
    END;
   IF DIM_MULT = 0 THEN DIM_MULT = RANGE_SIZE#;
                                        /* SET DEFAULT MULTIPLIER             */
    ELSE IF CHARX <= CHARX_MAX AND  C = CT_LPAREN
                                        /* DIMENSIONED?                       */
       THEN DO;                         /* YES                                */
         CALL UT_INC_CHARX;             /* SKIP OVER (                        */
         CALL UT_SBIN_VALUE( NBR_DIMS ); /* GET ELEMENT INDEX                 */
         IF VAL_FAULT ~= 0 THEN RETURN; /* RETURN IF ERROR                    */
         CALL UT_IGNORE_BLANKS;         /* MAKE SURE ) FOLLOWS                */
         IF CHARX > CHARX_MAX OR C ~= CT_RPAREN
                                        /* RIGHT PAREN MUST FOLLOW            */
          THEN DO;                      /* ERROR IF NOT                       */
            VAL_FAULT = 45;
                              /*E* 45V XQC_FPT_RANGE: EXPECTED ) IS MISSING   */
            RETURN;
            END;
         CALL UT_INC_CHARX;             /* SKIP OVER )                        */
         RANGE_STRT# = RANGE_STRT# + NBR_DIMS * DIM_MULT;
                                        /* INCLUDE DIMS IN RANGE START        */
         END;
       ELSE IF NBR_DIMS > 1
                                        /* NO DIM SPEC'D, ONLY BOTTOM DIM'D   */
          THEN DO;                      /* USE ALL OF IT                      */
            RANGE_SIZE# = RANGE_SIZE# * NBR_DIMS;
            DFLT_DT = DT_MACHINE;       /* AND DISPLAY IN BITS                */
            END;
          ELSE                          /* NO DIM SPEC'D, BUT INTERMED DIM'D  */
            VAL_FAULT = 91;             /* DIM SPEC REQUIRED                  */
 
 
   RETURN;
 
/*********************************************************************/
/**
***   UT_BACKUP   5 DEC 77   (PRY)   BACK UP TO PREVIOUS ITEM.
**/
 
UT_BACKUP: PROC;
 
   DO WHILE ( STK_IX > -1  AND  (SUBIX < 0  OR  SUBIX > MASKR(17)) );
                              /* BACK UP WHILE ITEMS REMAIN ON THE STACK AND  */
                                        /* CURRENT PATH IS A DEAD END         */
      SUBIX  = SUBIX_STK(STK_IX);
                              /* GET IX OF PREVIOUSLY CHECKED ITEM FROM STACK */
      STK_IX = STK_IX - 1;
      SUBIX  = FPTINFO$ -> FPT_INFO.FELLOIX(SUBIX);
                              /* SINCE ITEM WAS PREVIOUSLY CHECKED, GO ON     */
                              /* TO ITS FELLOW ITEM (NEXT ITEM AT SAME LEVEL) */
      END;
 
   RETURN;
 
END UT_BACKUP;
 
 
END EV_FPT_RANGE;
 
/**********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_FREE_PAGES 12 AUG 77  (PRY)  FREES DYNAMIC PAGES USING THE
***   M$FDP CALL.
*/
 
AM_FREE_PAGES: PROC( NBR_PAGES# ) NOAUTO;
%INCLUDE FILER_II5;
%INCLUDE CP_6;
%FPT_FDP ( FPTN=M$FDP_FPT, STCLASS=STATIC, RESULTS=FPT_RESULTSV, PAGES=0 );
 
/***************
***   PARAMETERS:
*/
DCL   NBR_PAGES#     SBIN WORD ALIGNED; /* NUMBER OF PAGES DESIRED            */
 
/***************
***   SET UP FDP FPT.
*/
   TEMP1   = NBR_PAGES#;                /* LOCALIZE ARGUMENT                  */
   IF TEMP1 = 0 THEN RETURN;
   M$FDP_FPT.V.PAGES# = TEMP1;          /* SET # PAGES DESIRED IN FPT         */
/*
***   FREE PAGES.
*/
   IF LOCAL_PAGES = 0                   /* M$FDP WORKING TODAY?               */
    THEN CALL M$FDP( M$FDP_FPT ) ALTRET ( AM_FDP_ALTRET );
                                        /* YES                                */
   LAST_FREE_IX   = LAST_FREE_IX - (1024 * TEMP1);
   NBR_PAGES_USED = NBR_PAGES_USED - TEMP1; /* KEEP TRACK OF PAGES            */
 
AM_FDP_ALTRET:
   RETURN;
 
END AM_FREE_PAGES;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_GET_CMND   13 SEP 77   (PRY)   GETS A FREE VALUE DESCRIPTOR
***   AND READS THE NEXT COMMAND INTO ITS ASSOCIATED BLOCK.
**/
 
UT_GET_CMND: PROC( CMND_BUF$#, CMND_LEN#, CMND_PT# ) NOAUTO;
 
%INCLUDE CP_6;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   GET A VALUE DESCRIPTOR   ***/
DCL   EV_GET_VALUE_DESC      ENTRY(1);
 
/***   ALLOCATE A BLOCK   ***/
DCL   AM_ALLOC_BLK           ENTRY(3);
 
/***   READ IN A SINGLE COMMAND LINE   ***/
DCL   UT_READ_CMND           ENTRY(4);
 
/***   EXPAND A BLOCK   ***/
DCL   AM_EXPAND_BLK          ENTRY(2);
 
/***   DEALLOCATE A DESCRIPTOR AND ASSOCIATED BLOCK   ***/
DCL   UT_DEALLOC_BUF         ENTRY(1);
 
/***   SPLIT A USED BLOCK INTO USED AND UNUSED SECTIONS   ***/
DCL   AM_SPLIT_BLK           ENTRY(2);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF                ENTRY;
 
/***   WRITE AN OUTPUT BUFFER   ***/
DCL   UT_WRITE_BUF                ENTRY(2);
 
/***   OUTPUT A SINGLE CHARACTER   ***/
DCL   UT_OUTPUT_CHAR              ENTRY(1);
 
/***   OUTPUT A CHARACTER STRING   ***/
DCL   UT_OUTPUT_CHARS             ENTRY(2);
 
/***   DISPLAY ITEM IN SPECIFIED FORMAT   ***/
DCL   UT_DISPLAY                  ENTRY(3);
 
/********************
***   PARAMETERS:
**/
DCL   CMND_BUF$#        PTR       ALIGNED;
                                        /* RETURNED BUFFER DESCRIPTOR POINTER */
DCL   CMND_LEN#         SBIN WORD ALIGNED;
                                        /* RETURNED LENGTH OF COMMAND         */
DCL   CMND_PT#          SBIN WORD ALIGNED;
                                        /* FLAG TO PROMPT FIRST LINE          */
/*********
*** FPTs:
***/
%FPT_PROMPT( FPTN=PROMPT_FPT, STCLASS=STATIC );
/********************
***   LOCALS:
**/
DCL CMND_BUF_IX SBIN WORD ALIGNED AUTO; /* IX OF BUFFER DESCRIPTOR            */
DCL   CMND_BUF$         PTR       ALIGNED   AUTO;
                                        /* LOCAL POINTER TO BUFFER DESCRIPTOR */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* INDEX OF BLOCK                     */
DCL   BLK_SIZE  SBIN WORD ALIGNED AUTO; /* SIZE OF BLOCK                      */
DCL   CHAR_IX   SBIN WORD ALIGNED AUTO; /* INDEX OF NEXT CHARACTER            */
DCL   CMND_LEN          SBIN WORD ALIGNED   AUTO;
                                        /* LENGTH OF CURRENT COMMAND SEGMENT  */
DCL   CHR       SBIN WORD ALIGNED AUTO; /* A CHARACTER                        */
DCL   ACCEPTING_CMND    SBIN WORD ALIGNED   AUTO;
                                        /* FLAG CONTROLLING COMMAND LOOP      */
DCL   CMND_LINE_NBR     SBIN WORD ALIGNED   AUTO;
                                        /* COUNT COMMAND LINES ENTERED        */
DCL   CMND_LINE_NBR$    PTR       ALIGNED   AUTO;
                                        /* POINT TO COUNT FOR DISPLAY         */
DCL   CONTINUING        SBIN WORD ALIGNED   AUTO;
                                        /* FLAG IF COMMAND CONTINUED          */
DCL   REC_SIZE  SBIN WORD ALIGNED AUTO; /* MAX RECORD PER READ                */
 
/********************
***   GET DESCRIPTOR AND BLOCK FOR INCOMING COMMAND.
**/
   VAL_FAULT = 0;                       /* NO ERRORS YET                      */
   CALL EV_GET_VALUE_DESC( CMND_BUF_IX ); /* GET A BUFFER DESCRIPTOR          */
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF PROBLEMS                 */
   CMND_BUF$ = PINCRW( DATA_BASE$, CMND_BUF_IX );
                                        /* POINT TO THE DESCRIPTOR            */
   REC_SIZE  = 139;
   CALL AM_ALLOC_BLK( CMND_BUF$, (REC_SIZE+4)/4, BLK_IX );
                                        /* GET AN 139 CHARACTER BUFFER        */
                    /* BLOCK SIZE MUST ALLOW FOR INCLUSION OF TRAILING CR     */
   IF VAL_FAULT ~= 0                    /* IF WE DIDN'T GET THE LARGER BUFFER */
    THEN DO;                            /* TRY FOR THREE CHAR BUF             */
      VAL_FAULT = 0;                    /* RESET FAULT INDICATOR              */
      REC_SIZE  = 7;
      CALL AM_ALLOC_BLK( CMND_BUF$, (REC_SIZE+4)/4, BLK_IX );
                                        /* TRY TO GET SEVEN CHAR BUFFER       */
      IF VAL_FAULT = 0                  /* IF OBTAINED                        */
       THEN DO;                         /* WARN USER                          */
         CALL UT_FLUSH_BUF;
         CALL UT_OUTPUT_CHARS(
           '(Warning: low on space; reading 7 chars; deallocate something)', 62 );
         END;
      END;
 
   IF VAL_FAULT ~= 0                    /* PROBLEMS?                          */
    THEN DO;                            /* YES                                */
      CMND_BUF$ -> BUF.TYPE = BT_UNUSED; /* RELEASE DESCRIPTOR                */
      RETURN;
      END;
 
/*********************
***   INITIALIZE TO ACCEPT THE NEXT COMMAND.
**/
   CMND_BUF$ -> BUF.TYPE = BT_CMND_BUF; /* MARK AS COMMAND BUFFER             */
   CHAR_IX               = 0;           /* READ INTO FIRST BYTE OF BLOCK      */
   CMND_LINE_NBR  = 0;                  /* READY TO ACCEPT FIRST COMMAND LINE */
   CMND_LINE_NBR$ = ADDR( CMND_LINE_NBR ); /* POINT TO NUMBER                 */
   CONTINUING     = 0;                  /* NOT A CONTINUATION                 */
                                   /* CHANGE PROMPT CHAR TO COMMAND PROMPT    */
   ACCEPTING_CMND = 1;                  /* BEGIN TO ACCEPT THE NEXT COMMAND   */
   CALL UT_FLUSH_BUF;                   /* READY TO SET UP PROMPT             */
 
/********************
***   READ SUCCESSIVE COMMAND SEGMENTS UNTIL END OF COMMAND
***   IS DETECTED.
**/
   DO WHILE (ACCEPTING_CMND = 1);
      IF READ_FILE = 0
       THEN DO;
                                        /* Only prompt for SI input           */
         IF CONTINUING = 1              /* CONTINUATION PROMPT IS BLANKS      */
          THEN BLK_SIZE = 8;
          ELSE DO;            /* PRINT LINE NUMBER FOR NEXT COMMAND  LINE     */
            CMND_LINE_NBR = CMND_LINE_NBR + 1;
                                        /* INCREMENT LINE NUMBER              */
            IF CMND_LINE_NBR = 1   AND  CMND_PT# ~= 1
                                        /* ONLY BLANKS FOR FIRST LINE         */
             THEN BLK_SIZE = 8;
             ELSE DO;
               CALL UT_OUTPUT_CHAR( CT_LBRACKET );
               CALL UT_DISPLAY( CMND_LINE_NBR$, 36, -DT_DECIMAL);
               CALL UT_OUTPUT_CHAR( CT_RBRACKET );
               BLK_SIZE      = 8 - OUT_CHARX;
                                        /* BLANK TO COLUMN 7                  */
               END;
            END;
         CALL UT_OUTPUT_CHARS( '         ', BLK_SIZE );
         FPT_RESULTSV = VECTOR(OUT_CHARX); /* To set flags                    */
         FPT_RESULTS.BOUND = OUT_CHARX - 1;
         FPT_RESULTS.DATA$ = OUT_BUF$;
         PROMPT_FPT.PROMPT_ = FPT_RESULTSV;
         CALL M$PROMPT( PROMPT_FPT ) ALTRET(TOUGH);
TOUGH:   ;
                                        /* PRINT THE PROMPT                   */
         OUT_CHARX = 0;                 /* INDICATE BUFFER PRINTED            */
         END;
      CALL UT_READ_CMND( CMND_BUF$, CHAR_IX, REC_SIZE, CMND_LEN );
      IF VAL_FAULT ~= 0 THEN RETURN;    /* RETURN IF READ PROBLEMS            */
      IF ECHO > 0 AND ECHO_XEQ_FLAG ~= 0 AND READ_FILE = 0
       THEN DO;                         /* XEQ file or batch...echo input     */
         TEMP1=CMND_LEN;
         TPTR1$ = PINCRC (CMND_BUF$->BUF.BLK$, CHAR_IX);
                                        /* CALC INDEX TO NEXT COMMAND TO ECHO */
         CALL UT_OUTPUT_CHARS(TPTR1$->CHARS,CMND_LEN);
         CALL UT_FLUSH_BUF;
         END;
       ELSE OUT_CHARX = 0;              /* Don't retain prompt                */
      IF CMND_LEN > 0                   /* ANY COMMAND READ?                  */
       THEN DO;                         /* SURE 'NUF!                         */
         CHAR_IX = CHAR_IX + CMND_LEN;
                                        /* CALC IX OF NEXT COMMAND SEGMENT    */
         CHR     = CMND_BUF$ -> BUF.BLK$ -> UBIN9#(CHAR_IX-1);
                              /* GET LAST CHAR OF CURRENT COMMAND SEGMENT     */
         IF CHR = CT_SEMI_COLON  OR  CHR = CT_AMPERSAND
                                        /* ';' OR '&'? (CONTINUATION?)        */
          THEN DO;                      /* CONTINUE COMMAND                   */
            BLK_SIZE = (CHAR_IX + REC_SIZE + 4) / 4 + 3;
                    /* CALC NUMBER OF WORDS NEEDED TO CONTAIN ALL CURRENT     */
                                   /* SEGMENT PLUS CRS AND THE NEXT SEGMENT   */
            BLK_IX   = CMND_BUF$ -> BUF.IX;
                                        /* GET IX OF THE BLOCK                */
            CALL AM_EXPAND_BLK( BLK_IX, BLK_SIZE );
                                        /* MAKE ROOM FOR THE NEXT SEGMENT     */
            IF VAL_FAULT ~= 0           /* PROBLEMS?                          */
             THEN DO;                   /* YES                                */
               CALL UT_DEALLOC_BUF( CMND_BUF$ );
                                   /* FREE THE DESCRIPTOR AND BLOCK SPACE     */
               RETURN;
               END;
            IF CHR = CT_AMPERSAND
                                        /* '&'? (CONTINUATION MARK?)          */
             THEN DO;                   /* NEXT SEGMENT CONTINUES             */
               CHAR_IX = CHAR_IX - 1;
               CONTINUING = 1;
               END;                     /* NEXT SEGMENT STARTS ON IT          */
            END;
          ELSE ACCEPTING_CMND = 0;      /* DON'T CONTINUE COMMAND             */
         IF CHR ~= CT_AMPERSAND
                                        /* SHOULD CR BE PUT ON LINE?          */
          THEN DO;                 /* PUT CR INTO BUFFER TO MARK END OF LINE  */
            TPTR1$ = CMND_BUF$ -> BUF.BLK$;
                                        /* GET POINTER TO BUFFER              */
            TPTR1$ -> UBIN9#(CHAR_IX) = CT_CR;
                                        /* PUT CR IN BUFFER                   */
            CHAR_IX = CHAR_IX + 1;      /* COUNT CR                           */
            CONTINUING = 0;             /* NOT A CONTINUATION                 */
            END;
         END;
       ELSE ACCEPTING_CMND = 0;
                                        /* ZERO LENGTH SEGMENT ENDS COMMAND   */
      END;
 
/********************
***   COMMAND HAS BEEN BROUGHT INTO A BLOCK.  RETURN DESCRIPTOR
***   POINTER AND COMMAND LENGTH; SPLIT OFF UNUSED WORDS FROM THE
***   BLOCK; SET CORRECT WIDTH IN THE DESCRIPTOR.
**/
   CMND_BUF$# = CMND_BUF$;              /* RETURN DESC PTR                    */
   CMND_LEN#  = CHAR_IX;                /* RETURN LENGTH OF COMMAND           */
   BLK_SIZE   = (CHAR_IX + 3) / 4 + 3;
                                        /* CALC # WORDS NECESSARY FOR COMMAND */
   BLK_IX     = CMND_BUF$ -> BUF.IX;
                                        /* GET THE IX OF THE COMMAND BLOCK    */
   CALL AM_SPLIT_BLK( BLK_IX, BLK_SIZE ); /* SPLIT OFF UNUSED WORDS           */
   CMND_BUF$ -> BUF.WIDTH = CHAR_IX * 9;
                                        /* COMPUTE AND SET COMMAND WIDTH      */
 
   RETURN;
 
END UT_GET_CMND;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_GET_NAME   19 SEP 77   (PRY)   GET THE NEXT NAME FROM THE
***   CURRENT STRING AND MAKES IT THE CURRENT NAME.
**/
 
UT_GET_NAME: PROC NOAUTO;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS STARTING WITH THE CURRENT CHARACTER   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
/********************
***   LOCALS:
**/
DCL   NAME_IX   SBIN WORD ALIGNED AUTO; /* COUNTS CHARS IN NAME               */
 
/********************
***   IGNORE ANY LEADING BLANKS; ACCEPT CHARS 'TIL END OF NAME.
**/
   NAME_IX = -1;                        /* INITIALIZE NAME LENGTH             */
   CALL UT_IGNORE_BLANKS;
   IF CHARX <= CHARX_MAX  AND  ( C >= CT_A AND C <= CT_Z
     OR C = CT_COLON )
                                   /* NAME MUST BEGIN WITH ALPHA OR COLON     */
    THEN DO;
      DO WHILE (CHARX <= CHARX_MAX  AND  NAME_IX < 79  AND
        ( (C >= CT_A  AND  C <= CT_Z)  OR  C = CT_POUND
        OR C = CT_AT  OR  (C >= CT_0  AND  C <= CT_9)
        OR C = CT_COLON OR C = CT_DOLLAR OR C = CT_UNDERSCORE ) );
                                   /* BUILD NAME WHILE LEGAL CHARS APPEAR     */
         NAME_IX                = NAME_IX + 1;
                                        /* INCREMENT INDEX                    */
         CRNT_NAME.CHR(NAME_IX) = C;    /* ADD NEW CHAR TO NAME               */
         CALL UT_INC_CHARX;             /* GET THE NEXT CHARACTER             */
         END;
      END;
 
/********************
***   IF NAME WAS TOO LONG, ERROR CONDITION.
**/
   NAME_IX = NAME_IX + 1;               /* CALC LENGTH FROM INDEX             */
   IF NAME_IX > 79                      /* NAME TOO LONG?                     */
    THEN DO;
      VAL_FAULT = 36; /*E* 36V UT_GET_NAME: THAT NAME IS TOO LONG     */
      RETURN;
      END;
 
/********************
***   SET NAME IN CRNT_NAME AND RETURN.
**/
   CRNT_NAME.LENGTH = NAME_IX;          /* RETURN NAME LENGTH                 */
   RETURN;
 
END UT_GET_NAME;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/*
***   AM_GET_PAGES  12 AUG 77  (PRY)  GETS DYNAMIC PAGES USING THE
***   M$GDP CALL.
*/
 
AM_GET_PAGES: PROC( NBR_PAGES# ) NOAUTO;
%INCLUDE FILER_II5;
%INCLUDE CP_6;
%FPT_GDP ( FPTN=M$GDP_FPT, STCLASS=STATIC, RESULTS=FPT_RESULTSV, PAGES=0 );
%FPT_FDP ( FPTN=M$FDP_FPT, STCLASS=STATIC, RESULTS=FPT_RESULTSV, PAGES=0 );
 
/***************
***   PARAMETERS:
*/
DCL   NBR_PAGES#     SBIN WORD ALIGNED; /* NUMBER OF PAGES DESIRED            */
 
/***************
***   SET UP GDP FPT.
*/
   TEMP1   = NBR_PAGES#;                /* LOCALIZE ARGUMENT                  */
   IF TEMP1 + NBR_PAGES_USED > 255      /* LIMIT IS .777777/1024 PAGES        */
    THEN DO;
      VAL_FAULT = 7;
      RETURN;
      END;
   IF TEMP1 = 0 THEN RETURN;
   M$GDP_FPT.V.PAGES# = TEMP1;          /* SET # PAGES DESIRED IN FPT         */
/*
***   GET PAGES.
*/
   IF LOCAL_PAGES = 0                   /* IS M$GDP WORKING TODAY?            */
    THEN CALL M$GDP( M$GDP_FPT ) ALTRET ( AM_GDP_ALTRET );
                                        /* YES                                */
    ELSE DO;                            /* NO: FAKE IT                        */
      IF LAST_FREE_IX + (1024 * TEMP1) > LAST_FREE_PAGE_IX
                                        /* ENOUGH SPACE?                      */
       THEN GOTO AM_GDP_FDP_ALTRET;     /* NOPE                               */
      END;
   LAST_FREE_IX   = LAST_FREE_IX + (1024 * TEMP1);
   NBR_PAGES_USED = NBR_PAGES_USED + TEMP1; /* KEEP TRACK OF PAGES            */
   VAL_FAULT      = 0;                  /* INDICATE SUCCESS                   */
 
   RETURN;
 
/**
***   IF REQUEST WAS ONLY PARTIALLY FULFILLED, OBTAINED
***   PAGES MUST BE FREED.
**/
 
AM_GDP_ALTRET:
   TEMP1 = (FPT_RESULTS.BOUND+1) / (1024 * 4);
     /* CALC NUMBER OF PAGES OBTAINED WHICH MUST BE FREED FROM #BYTES - 1     */
   IF TEMP1 > 0                         /* ONLY M$FDP IF NECESSARY            */
    THEN DO;
      M$FDP_FPT.V.PAGES# = TEMP1;       /* SET # PAGES TO FREE                */
      CALL M$FDP( M$FDP_FPT ) ALTRET ( AM_GDP_FDP_ALTRET );
                                        /* FREE PAGES OBTAINED                */
      END;
 
AM_GDP_FDP_ALTRET:
   VAL_FAULT = 7;       /*E* 7V AM_GET_PAGES: COULDN'T GET PAGES        */
   RETURN;
 
END AM_GET_PAGES;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_GET_OFFSET   24 AUG 77   (PRY)   INTERPRETS OFFSET/SIZE.
*/
 
EV_GET_OFFSET: PROC( INITIAL_RES#, SIZE_FLAG#, FINAL_RES#, OFFSET#, GOT_OFS# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   DEALLOCATE A DESCRIPTOR AND ASSOCIATED BLOCK   ***/
DCL   UT_DEALLOC_BUF         ENTRY(1);
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS STARTING WITH THE CURRENT CHARACTER   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
/***   CONVERT A BLOCKED VALUE TO AN SBIN WORD   ***/
DCL   UT_ONE_WORD_VALUE      ENTRY(3);
 
 
/***   GET VALUE   ***/
DCL   EV_GET_VALUE           ENTRY(2);
 
/***   CONVERT BUFFER VALUE STRING TO VALUE   ***/
 
/***************
***   PARAMETERS:
*/
DCL   INITIAL_RES#      SBIN WORD ALIGNED;
                         /* INITIAL RESOLUTION, RETURNED SPECIFIED RESOLUTION */
DCL   SIZE_FLAG#     SBIN WORD ALIGNED; /* 1 IF SIZE, 0 IF NOT                */
DCL   FINAL_RES#        SBIN WORD ALIGNED;
                                        /* RETURNED FINAL RESOLUTION          */
DCL   OFFSET#        SBIN WORD ALIGNED; /* RETURNED OFFSET OR SIZE            */
DCL   GOT_OFS#          SBIN WORD ALIGNED;
                                        /* RETURNED FLAG: 1 IF TRUE, 0 IF NOT */
 
/***************
***   LOCALS:
*/
DCL INITIAL_RES SBIN WORD ALIGNED AUTO; /* INITIAL RESOLUTION                 */
DCL   NBR_UNITS(0:2)    SBIN WORD ALIGNED   AUTO;
                                        /* DEPOSITORY FOR RESOLUTION TERMS    */
DCL   RES       SBIN WORD ALIGNED AUTO; /* CURRENT RESOLUTION                 */
DCL   OFFSET    SBIN WORD ALIGNED AUTO; /* CONTROLS CONVERSION LOOP           */
DCL   SAV_DESC$         PTR       ALIGNED   AUTO;
                                        /* SAVES CURRENT DESCRIPTOR POINTER   */
DCL   SAV_DWIDTH        SBIN WORD ALIGNED   AUTO;
                                        /* SAVES CURRENT VALUE WIDTH          */
DCL   SIZE_FLAG SBIN WORD ALIGNED AUTO; /* LOCALIZES SIZE_FLAG#               */
DCL   BLK_IX            SBIN WORD ALIGNED   AUTO;
                                        /* INDEX OF TERM VALUE BLOCK          */
DCL   GOT_OFS   SBIN WORD ALIGNED AUTO; /* LOCALIZES GOT_OFS#                 */
DCL  LOCAL_TEMP SBIN WORD ALIGNED AUTO; /* USED FOR RETURNED ARGS             */
DCL   LOCAL_TPTR$    PTR DALIGNED AUTO; /* USED TO PASS POINTER PARAM         */
 
/***************
***   INITIALIZE; DETERMINE INITIAL RESOLUTION.
*/
   SIZE_FLAG   = SIZE_FLAG#;            /* LOCALIZE PARM                      */
   GOT_OFS     = 0;                     /* ASSUME NO OFFSET WILL APPEAR       */
   INITIAL_RES = -1;                    /* ASSUME NO RESOLUTION SPECIFIED     */
 
   IF C = CT_W                          /* 'W'? (WORD)                        */
    THEN INITIAL_RES = 2;
    ELSE
      IF C = CT_C                       /* 'C'? (CHAR)                        */
       THEN INITIAL_RES = 1;
       ELSE
         IF C = CT_B                    /* 'B'? (BIT)                         */
          THEN INITIAL_RES = 0;
 
/*
***   USE DEFAULT INITIAL RESOLUTION IF NONE WAS SPECIFIED.
*/
   IF INITIAL_RES = -1                  /* ANY RES SPECIFIED?                 */
    THEN INITIAL_RES = INITIAL_RES#;    /* NO: USE DEFAULT                    */
    ELSE DO;                            /* YES                                */
      CALL UT_INC_CHARX;                /* GET NEXT CHARACTER                 */
      GOT_OFS = 1;                      /* GOT AN OFFSET                      */
      END;
/*
***   SAVE THE CURRENT VALUE POINTER AND WIDTH--WE'LL HAVE TO
***   GET SOME NEW VALUES.
*/
   SAV_DESC$  = DESC$;                  /* SAVE THE DESCRIPTOR POINTER        */
   SAV_DWIDTH = DWIDTH;                 /* SAVE THE CURRENT WIDTH             */
/*
***   INITIALIZE TERM VECTOR.
*/
   DO TIX1 = 0 TO 2;
      NBR_UNITS(TIX1) = 0;              /* ASSUME NO TERMS                    */
      END;
   IF SIZE_FLAG = 1 THEN NBR_UNITS(INITIAL_RES) = 1;
               /* IF TERM FOR INITIAL SIZE RESOLUTION NOT SPECIFIED, USE 1    */
/*
***   INITIALIZE OFFSET CONVERSION.
*/
   RES    = INITIAL_RES;
   OFFSET = 1;                          /* BEGIN OFFSET CONVERSION            */
/*
***   CONVERT OFFSET TO # OF BITS.
*/
   DO WHILE (RES>=0  AND  CHARX <= CHARX_MAX  AND  OFFSET = 1);
     /* CONVERT TILL FINEST RESOLUTION ATTAINED OR END OF OFFSET DETECTED     */
      CALL EV_GET_VALUE( LOCAL_TPTR$, BLK_IX );
                                        /* GET NEXT TERM                      */
      IF VAL_FAULT ~= 0                 /* PROBLEMS?                          */
       THEN DO;                         /* YES                                */
         CALL EV_RSTR_DESC;             /* RESTORE CURRENT VALUE DESCRIPTORS  */
         RETURN;
         END;
      IF DWIDTH = 0                     /* NULL VALUE?                        */
       THEN CALL UT_DEALLOC_BUF( DESC$ );
                                   /* YES: DEALLOCATE BLOCK AND DESCRIPTOR    */
       ELSE DO;                         /* NOT A NULL VALUE                   */
         CALL UT_ONE_WORD_VALUE( DWIDTH, BLK_IX, LOCAL_TEMP );
                                        /* CONVERT VALUE TO SBIN WORD         */
         CALL UT_DEALLOC_BUF( DESC$ );  /* GET RID OF VALUE                   */
         IF VAL_FAULT ~= 0              /*  RETURN IF PROBLEMS                */
          THEN DO;
            CALL EV_RSTR_DESC;          /* RESTORE CURRENT VALUE DESCRIPTOR   */
            RETURN;
            END;
         NBR_UNITS(RES) = LOCAL_TEMP;   /* SAVE TERM                          */
         GOT_OFS = 1;                   /* GOT AN OFFSET                      */
         END;
         /*
         ***   THE NEXT TERM HAS BEEN CONVERTED.   LOOK FOR ANOTHER.
         */
      CALL UT_IGNORE_BLANKS;
      IF CHARX <= CHARX_MAX             /* MIGHT ANOTHER OFFSET TERM FOLLOW?  */
       THEN DO;                         /* YES                                */
         IF C = CT_COMMA                /* ','?                               */
          THEN DO;                      /* YES: ANOTHER TERM FOLLOWS          */
            CALL UT_INC_CHARX;          /* SKIP OVER ','                      */
            CALL UT_IGNORE_BLANKS;
            GOT_OFS = 1;                /* GOT AN OFFSET                      */
            RES = RES - 1;              /* FINER RESOLUTION                   */
            END;
          ELSE OFFSET = 0;              /* DONE WITH OFFSET                   */
         END;
      END;
/***************
***   OFFSET CONVERSION IS DONE.
*/
   IF RES < 0                           /* TOO MANY TERMS?                    */
    THEN DO;                            /* YES                                */
      VAL_FAULT = 14;
                    /*E* 14V EV_GET_OFFSET: TOO MANY TERMS FOR OFFSET OR SIZE */
      CALL EV_RSTR_DESC;                /* RESTORE CURRENT VALUE DESCRIPTORS  */
      END;
    ELSE DO;                            /* NO                                 */
      FINAL_RES#   = RES;               /* RETURN FINAL RESOLUTION            */
      INITIAL_RES# = INITIAL_RES;
                                        /* RETURN INITIAL RESOLUTION          */
      DESC$        = SAV_DESC$;
                                        /* RESTORE CURRENT VALUE              */
      DWIDTH       = SAV_DWIDTH;
      TEMP1        = 0;                 /* ACCUMULATE OFFSET                  */
      DO TIX1=RES TO INITIAL_RES;
         TEMP1 = TEMP1 +
                                   /* NUMBER OF BITS DUE TO PREVIOUS TERMS    */
           NBR_UNITS(TIX1) * RES_WIDTH(TIX1);
                                        /* PLUS NUMBER OF BITS DUE TO TERM    */
         END;
      IF TEMP1 < 0       /* ASSURE THAN OFFSET/SIZE IS WITHIN VALID LIMITS    */
       THEN VAL_FAULT = 71;
         /*E* 71V EV_GET_OFFSET: AN OFFSET OR SIZE CAN NOT BE LESS THAN ZERO */
       ELSE DO;
 
         GOT_OFS# = GOT_OFS;            /* INDICATE SUCCESS                   */
         OFFSET#  = TEMP1;              /* RETURN OFFSET VALUE                */
         END;
      END;
 
   RETURN;
 
/*********************************************************************/
/**
***   EV_RSTR_DESC   17 OCT 77   (PRY) RESTORE CURRENT VALUE DESCRIPTORS.
**/
 
EV_RSTR_DESC: PROC;
 
   DESC$  = SAV_DESC$;
   DWIDTH = SAV_DWIDTH;
 
   RETURN;
 
END EV_RSTR_DESC;
 
END EV_GET_OFFSET;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_GET_RANGE   24 AUG 77   (PRY)   CONVERTS A RANGE SPECIFICATION
***   TO A RANGE START RNG_STRT# AND A RANGE SIZE RNG_SIZE#.
*/
 
EV_GET_RANGE: PROC( RNG_STRT#, RNG_SIZE# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS STARTING WITH THE CURRENT CHARACTER   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
 
/***   CONVERT OFFSET SPECIFICATION TO BIT OFFSET   ***/
DCL   EV_GET_OFFSET          ENTRY(5);
 
 
/***   CONVERT FPT RANGE SPECIFICATION TO BIT OFFSET AND BIT SIZE   ***/
DCL   EV_FPT_RANGE           ENTRY(2);
 
 
/***************
***   PARAMETERS:
*/
DCL   RNG_STRT#      SBIN WORD ALIGNED; /* RETURNED RANGE START               */
DCL   RNG_SIZE#      SBIN WORD ALIGNED; /* RETURNED RANGE SIZE                */
 
/***************
***   LOCALS:
*/
DCL   SAVE_DT   SBIN WORD ALIGNED AUTO; /* SAVED DISPLAY TYPE                 */
DCL   RES       SBIN WORD ALIGNED AUTO; /* RESOLUTION OF RANGE                */
DCL   FRES              SBIN WORD ALIGNED   AUTO;
                                        /* FINAL RESOLUTION OF RANGE          */
DCL   GOT_OFS   SBIN WORD ALIGNED AUTO; /* FLAG                               */
DCL   SIZE_FLAG SBIN WORD ALIGNED AUTO; /* FLAG INDICATING WHETHER            */
                                   /* FOLLOWING OFFSET IS ACTUALLY A SIZE     */
DCL   TERM_TWO  SBIN WORD ALIGNED AUTO; /* SECOND TERM OF RANGE               */
DCL   RNG_STRT  SBIN WORD ALIGNED AUTO; /* Local START                        */
 
/***************
***   IF NO RANGE IS SPECIFIED, INDICATE SO.
*/
   RNG_STRT# = -1;                      /* ASSUME NO RANGE SPECIFIED          */
   RNG_SIZE# = MASKR(35);
   CALL UT_IGNORE_BLANKS;
   SAVE_DT = DT_MACHINE;                /* ASSUME NOT FPT RANGE SPECIFICATION */
   IF CHARX <= CHARX_MAX                /* POSSIBLE FOR A RANGE TO FOLLOW?    */
    THEN DO;                            /* YES                                */
      IF C = CT_PERIOD                  /* '.'?                               */
       THEN DO;                    /* '.' MARKS BEGINNING OF FPT RANGE SPEC   */
         CALL EV_FPT_RANGE( RNG_STRT#, RNG_SIZE# );
         SAVE_DT = DFLT_DT;             /* SAVE DEFAULT DISPLAY TYPE          */
                                        /* GET FPT SPECIFIED RANGE            */
         IF VAL_FAULT ~=0 THEN RETURN;  /* RETURN IF ERROR                    */
         CALL UT_IGNORE_BLANKS;
                                        /* FIND NEXT - OR : OR NEITHER        */
         TERM_TWO = 1;                  /* SET FPT RANGE FLAG                 */
         RES      = 1;
         END;
       ELSE DO;                         /* EXPECT ORDINARY BUFFER RANGE       */
         RES = 1;                       /* DEFAULT OFFSET IS CHAR             */
         CALL EV_GET_OFFSET( RES, 0, FRES, RNG_STRT#, GOT_OFS );
                                        /* CHAR DEFAULT, OFFSET               */
         IF VAL_FAULT ~= 0 THEN RETURN; /* RETURN IF ERROR                    */
         IF GOT_OFS = 0                 /* DID WE GET AN OFFSET?              */
          THEN RNG_STRT# = -1;          /* NO: DEFAULT START                  */
         TERM_TWO = 0;                  /* SET NOT FPT RANGE FLAG             */
                              /* INITIAL RES FOR FPT RANGE IS ALWAYS BYTE     */
         END;
         /**
         ***   CHECK IF SECOND TERM (OFFSET OR SIZE) CAN FOLLOW.
         **/
      IF CHARX > CHARX_MAX
                                   /* POSSIBLE FOR SECOND TERM TO FOLLOW?     */
        OR  ( C ~= CT_MINUS AND C ~= CT_COLON )
                                        /* NOT '-' OR ':'?                    */
       THEN DO;                         /* NO SECOND TERM; USE DEFAULT        */
         IF TERM_TWO = 0  AND  RNG_STRT# >= 0
          THEN RNG_SIZE# = RES_WIDTH(FRES);
                                   /* DEFAULT IS WIDTH OF FINAL RESOLUTION    */
         RETURN;
         END;
         /*
         ***   SECOND TERM FOLLOWS.
         */
      IF C = CT_COLON                   /* EXPECT SIZE (:) ?                  */
       THEN SIZE_FLAG = 1;              /* YES                                */
       ELSE SIZE_FLAG = 0;              /* NO                                 */
      CALL UT_INC_CHARX;                /* SKIP TO NEXT CHAR                  */
      CALL UT_IGNORE_BLANKS;
      GOT_OFS = 0;                      /* ASSUME NO SECOND TERM              */
      IF CHARX <= CHARX_MAX             /* IF POSSIBLE FOR SECOND TERM        */
       THEN CALL EV_GET_OFFSET( RES, SIZE_FLAG, FRES, TERM_TWO, GOT_OFS );
      IF VAL_FAULT ~= 0 THEN RETURN;    /* RETURN IF ERROR DETECTED           */
      IF SIZE_FLAG = 1                  /* EXPECTED SIZE?                     */
       THEN DO;                         /* YES                                */
         IF GOT_OFS = 1                 /* GET ONE?                           */
          THEN RNG_SIZE# = TERM_TWO;    /* YES--RETURN IT                     */
          ELSE DO;                      /* NO--ERROR                          */
            VAL_FAULT = 15;
                    /*E* 15V EV_GET_RANGE: SIZE SPECIFICATION MISSING         */
            RETURN;
            END;
         END;
       ELSE DO;                         /* EXPECTED AN OFFSET                 */
         IF RNG_STRT# <= 0
          THEN RNG_STRT = 0;            /* Default RNG_STRT# would be -1      */
          ELSE RNG_STRT = RNG_STRT#;
         IF GOT_OFS = 1                 /* GET THE OFFSET?                    */
          THEN DO;                      /* YES                                */
            IF TERM_TWO >= RNG_STRT
                         /* THE SECOND TERM MUST NOT BE LESS THAN THE FIRST   */
             THEN RNG_SIZE# = TERM_TWO - RNG_STRT
                 + RES_WIDTH(FRES);
                                        /* SIZE INCLUDES LAST UNIT SPECIFIED  */
             ELSE DO;                   /* ERROR                              */
               VAL_FAULT = 16;
          /*E* 16V EV_GET_RANGE: SECOND TERM OF RANGE LESS THAN FIRST         */
               RETURN;
               END;
            END;
          ELSE RNG_SIZE# = MASKR(35);
                                        /* THE DEFAULT SIZE IS MAXIMUM        */
         END;
      END;
/********************
***   RANGE HAS BEEN CONVERTED.
*/
 
   DFLT_DT = SAVE_DT;                   /* SET DEFAULT DISPLAY TYPE           */
   RETURN;
 
END EV_GET_RANGE;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_GET_VALUE_DESC  23 AUG 77  (PRY)  FINDS A FREE VALUE DESCRIPTOR
***   OR CALLS EV_NEW_VALUE_DESCS TO ALLOCATE NEW VALUE DESCRIPTOR(S).
*/
 
EV_GET_VALUE_DESC: PROC( VAL_DESC# );
%INCLUDE FILER_II5;
 
/***   CREATE NEW VALUE DESCRIPTORS   ***/
DCL   EV_NEW_VALUE_DESCS     ENTRY(2);
 
/***************
***   PARAMETER:
*/
DCL   VAL_DESC#         SBIN WORD ALIGNED;
                                   /* RETURNED IX OF VALUE DESCRIPTOR OR -1   */
 
/***************
***   LOCALS:
*/
DCL   VAL_IX            SBIN WORD ALIGNED   AUTO;
                                        /* USED TO SEARCH VALUE DESCRIPTORS   */
DCL   LOOKING           SBIN WORD ALIGNED   AUTO;
                    /* RESET IF AND WHEN AN UNUSED VALUE DESCRIPTOR IS FOUND  */
DCL   VAL$              PTR       ALIGNED   AUTO;
                                        /* USED TO SEARCH VALUE DESCRIPTORS   */
 
/***************
***   INITIALIZE SEARCH.
*/
   VAL_IX  = STRT_VAL_DESC_IX;
   LOOKING = 1;
/*
***   LOOK FOR FIRST UNUSED VALUE DESCRIPTOR.
*/
   DO WHILE (LOOKING = 1  AND  VAL_IX <= END_VAL_DESC_IX);
      VAL$ = PINCRW( DATA_BASE$, VAL_IX );
                                        /* POINT TO NEXT DESCRIPTOR           */
      IF VAL$ -> BUF.TYPE = BT_UNUSED   /* UNUSED DESCRIPTOR?                 */
       THEN LOOKING = 0;                /* YES: SEARCH DONE                   */
       ELSE VAL_IX = VAL_IX + BUF_DESC_SIZE;
                                        /* NO: TRY NEXT DESC                  */
      END;
/*
***   IF WE DIDN'T FIND ONE WE'LL HAVE TO ALLOCATE A NEW ONE.
*/
   IF LOOKING = 1                       /* STILL LOOKING?                     */
    THEN DO;                            /* YES:                               */
      CALL EV_NEW_VALUE_DESCS( 10, VAL_IX );
                              /* ALLOCATE NEW VALUE DESCRIPTORS: WE ASSUME    */
                                   /* THAT A FEW MORE WILL ALSO BE NEEDED     */
      IF VAL_FAULT ~= 0                 /* DID WE GET SOME?                   */
       THEN DO;                         /* NO: WELL WE ONLY NEEDED ONE ANYWAY */
         CALL EV_NEW_VALUE_DESCS( 1, VAL_IX );
                                        /* TRY FOR ONE ONLY                   */
         IF VAL_FAULT ~= 0 THEN RETURN; /* RETURN IF PROBLEMS                 */
         END;
      VAL$ = PINCRW( DATA_BASE$, VAL_IX );
                                        /* POINT TO DESCRIPTOR                */
      END;
/*
***   SET UP VALUE DESCRIPTOR.
*/
   VAL_DESC#         = VAL_IX;          /* RETURN IX OF DESCRIPTOR            */
   VAL$ -> BUF.TYPE  = BT_VALUE;        /* TYPE IS 'VALUE'                    */
   VAL$ -> BUF.IX    = 0;               /* NO BLOCK ASSOCIATED YET            */
   VAL$ -> BUF.WIDTH = 0;               /* NO SIZE KNOWN YET                  */
   VAL$ -> BUF.LOCK  = 0;               /* JUST BORN!                         */
   VAL$ -> BUF.BLK$  = ADDR(NIL);       /* NO DATA POINTER                    */
 
   RETURN;
 
END EV_GET_VALUE_DESC;
 
/*********************************************************************/
