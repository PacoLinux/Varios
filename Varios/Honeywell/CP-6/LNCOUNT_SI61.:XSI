/*M* CP6-LNCOUNT_S1 - Source # 1.                                 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* AND  */
/***
***/
/******************************************************************/
/*M*     LNCOUNT   July 31, 1979       GWJ                        */
/***/
/*P*     NAME: LNCOUNT
         PURPOSE: Mainline of LNCOUNT. This procedure gets the
                   command, defines the command and intiates the
                   proper routines to produce the users request.
                                                                  */
 
LNCOUNT : PROC MAIN;
 
/******************************************************************/
/***               SYMDEFS OF GLOBAL DATA                       ***/
/******************************************************************/
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%F$DCB(DCBN=F$DCB);
 
/*******/                               /* I/O UNITS                          */
DCL M$DO           DCB;                 /* LOUNIT                             */
DCL F$SI           DCB;                 /* SIUNIT                             */
DCL M$SI           DCB;                 /* SAUNIT                             */
DCL M$UI           DCB;                 /* UAUNIT                             */
DCL M$LO           DCB;                 /* OPUNIT                             */
DCL F$LIST         DCB;                 /* LSUNIT                             */
DCL F$DATA         DCB;                 /* DATUNT                             */
 
DCL DOUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$DO));
DCL SIUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$SI));
DCL SAUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$SI));
DCL UAUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$UI));
DCL OPUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$LO));
DCL LSUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$LIST));
DCL DATUNT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$DATA));
 
DCL UNUM#(0:6) UBIN CONSTANT SYMDEF INIT(DCBNUM(M$DO)
                                   ,DCBNUM(F$SI)
                                   ,DCBNUM(M$SI)
                                   ,DCBNUM(M$UI)
                                   ,DCBNUM(M$LO)
                                   ,DCBNUM(F$LIST)
                                   ,DCBNUM(F$DATA));
 
DCL INUNIT UBIN STATIC SYMDEF INIT(DCBNUM(M$UC));
 
/*******/                               /* INPUT RECORD DATA                  */
DCL 1 TOKEN STATIC SYMDEF ALIGNED,      /* TOKEN IS THE CURRENT TOKEN         */
      2 CHR CHAR(77) UNAL,              /* ACTUAL CHARACTER STRING            */
      2 LEN UBIN BYTE UNAL,             /* LENGHT OF STRING                   */
      2 VAL SBIN BYTE UNAL,             /* -1 IF UNDEFINED, n IF IN CMD_TBL   */
      2 ID  UBIN BYTE UNAL;             /* 0 = SPLCHR, 1 = NAME, 2 = DIGIT    */
 
DCL TCHAR CHAR(TOKEN.LEN) BASED UNAL;
DCL TPTR$ PTR CONSTANT SYMDEF INIT(ADDR(TOKEN.CHR));
 
DCL RECORD(0:255) CHAR(1) STATIC SYMDEF;
DCL REC_DATA REDEF RECORD CHAR(256);
 
DCL RECNBR UBIN STATIC SYMDEF INIT(0);
DCL RECPOS SBIN STATIC SYMDEF INIT(0);
DCL RECLEN SBIN STATIC SYMDEF;
DCL 1 RECKEY ALIGNED STATIC SYMDEF,
      2 DEC CHAR(5) UNAL,
      2 PT  CHAR(1) INIT('.') UNAL,
      2 FRC CHAR(3) UNAL;
 
DCL 1 TITLE_NAME STATIC SYMDEF ALIGNED,
      2 L UBIN BYTE UNAL INIT(0),
      2 C CHAR(77) UNAL;
 
DCL NUMRECS SBIN STATIC SYMDEF INIT(0);
/*******/                               /* FLAGS                              */
DCL TRUE     BIT(1) CONSTANT SYMDEF INIT('1'B);
DCL FALSE    BIT(1) CONSTANT SYMDEF INIT('0'B);
 
DCL BRKFLG    BIT(1) STATIC SYMDEF INIT('0'B);
DCL BASOPN    BIT(1) STATIC SYMDEF INIT('0'B);
DCL OLDFIL    BIT(1) STATIC SYMDEF INIT('0'B);
DCL LSTFIL    BIT(1) STATIC SYMDEF INIT('0'B);
DCL EORFLG    BIT(1) STATIC SYMDEF INIT('0'B);
DCL EOFFLG    BIT(1) STATIC SYMDEF INIT('0'B);
DCL OK        BIT(1) STATIC SYMDEF INIT('0'B);
DCL OUTFLG    BIT(1) STATIC SYMDEF INIT('0'B);
DCL UPDFLG    BIT(1) STATIC SYMDEF INIT('0'B);
DCL IFLG(0:1) BIT(1) STATIC SYMDEF INIT('0'B*2);
 
DCL WRTFLG    BIT(1) STATIC SYMDEF INIT('1'B);
/*******/                               /* POINTERS AND BASED STRUCTURES      */
DCL C1 CHAR(1) BASED UNAL;
DCL C2 CHAR(2) BASED UNAL;
DCL C3 CHAR(3) BASED UNAL;
DCL C4 CHAR(4) BASED UNAL;
DCL C5 CHAR(5) BASED UNAL;
DCL C7 CHAR(7) BASED UNAL;
 
DCL U1 UBIN BYTE BASED UNAL;
 
DCL W1 UBIN WORD BASED ALIGNED;
 
/*******/                               /* FILE INFO                          */
DCL SIACCT CHAR(8) STATIC SYMDEF;
DCL UIACCT CHAR(8) STATIC SYMDEF;
 
DCL TAG_NAME_1 CHAR(4) STATIC SYMDEF;
DCL TAG_NAME_2 CHAR(4) STATIC SYMDEF;
 
DCL CHAR_LEN UBIN;
DCL CCHAR CHAR(CHAR_LEN) BASED;
DCL PTR1$ PTR;
DCL PTR2$ PTR;
 
DCL BUFFER CHAR(4096) STATIC SYMDEF;
DCL OUT_BUFFER CHAR(256) STATIC SYMDEF;
 
%LIST;
 
%INCLUDE LNCOUNT_C2;
 
%PLIST;
 
/*******/                               /* COMMANDS                           */
%EQU DA = 1;                            /* DATA                               */
%EQU SO = 2;                            /* SOURCE                             */
%EQU UP = 3;                            /* UPDATE                             */
%EQU SR = 4;                            /* SREPORT                            */
%EQU UR = 5;                            /* UREPORT                            */
%EQU LI = 6;                            /* LIST                               */
%EQU TI = 7;                            /* TITLE                              */
%EQU DE = 8;                            /* DELETE                             */
%EQU DF = 9;                            /* DFILE                              */
%EQU XE = 10;                           /* XEQ                                */
%EQU QU = 11;                           /* QUIT, END, or X                    */
%EQU ON = 1;                            /* ON                                 */
%EQU IN = 2;                            /* INTO                               */
%EQU OV = 3;                            /* OVER                               */
%EQU ACCT = 100;                        /* ACCOUNT SUB                        */
%EQU FID  = 101;                        /* FID SUB                            */
%EQU TAG  = 102;                        /* TAG SUB                            */
 
DCL SCRTYP UBIN BYTE STATIC SYMDEF INIT(3);
DCL PL6    UBIN BYTE CONSTANT SYMDEF INIT(1);
DCL BASIC  UBIN BYTE CONSTANT SYMDEF INIT(2);
DCL NONPL6 UBIN BYTE CONSTANT SYMDEF INIT(3);
 
%VLP_NAME(FPTN=FILE_NAME,LEN=31,STCLASS="STATIC SYMDEF");
%VLP_ACCT(FPTN=FILE_ACCT,STCLASS="STATIC SYMDEF");
%VLP_PASS(FPTN=FILE_PASS,STCLASS="STATIC SYMDEF");
%VLP_WSN(FPTN=FILE_WSN,STCLASS="STATIC SYMDEF");
%VLP_SN(FPTN=FILE_SN,N=10,STCLASS="STATIC SYMDEF");
 
DCL FILE_RES CHAR(4) STATIC SYMDEF INIT('ME  ');
DCL FILE_ASN UBIN BYTE STATIC SYMDEF INIT(%DEVICE#);
 
%XUU_PARAM(FPTN=XUDATA,STCLASS="STATIC SYMDEF",BASE=YES,CLOSE_ALL=YES);
%XUU$ENTRY;
 
%FPT_DELREC(FPTN=DEL_TAG,DCB=F$DATA,KEY=DELETE_KEY1,LKEY=DELETE_KEY2);
 
%FPT_REW(FPTN=REW_LIST,DCB=F$LIST);
 
DCL 1 DELETE_KEY1 STATIC ALIGNED,
      2 TAG CHAR(4),
      2 C(0:30) CHAR(1) INIT(' '*31);
 
DCL 1 DELETE_KEY2 STATIC ALIGNED,
      2 TAG CHAR(4),
      2 C(0:30) CHAR(1) INIT('z'*31);
 
DCL STAT UBIN;
DCL KEEP# UBIN;
DCL I SBIN; DCL J SBIN; DCL K SBIN; DCL L SBIN;
DCL M SBIN; DCL N SBIN;
 
%EQU ONE  = 1;
%EQU ZERO = 0;
 
DCL INITIAL ENTRY;
DCL NXTTKN ENTRY;
DCL CLSFIL ENTRY(2);
DCL TELLER ENTRY(1);
DCL GETFID ENTRY;
DCL OPNFIL ENTRY(4);
DCL COUNT ENTRY(1);
DCL REPORT ENTRY(1);
/**************** START **************************************/
/* INITIALIZE FLAGS, DCBS, AND DATA */
        CALL INITIAL;
GET_CMD:
        INUNIT = SIUNIT;
        RECPOS = RECLEN + 1;
        BRKFLG = FALSE;
        CALL NXTTKN;
        IF EOFFLG OR TOKEN.VAL = %QU
        THEN DO; /* EOF OR 'END' FOUND *//* STOP                              */
           IF NOT BASOPN THEN CALL M$EXIT;
           IF NUMRECS < 1 THEN KEEP# = %RELEASE#;
           ELSE KEEP# = %SAVE#;
           CALL CLSFIL(DATUNT,KEEP#);
           IF KEEP# = %SAVE# THEN CALL TELLER(%DB_SAVED);
           ELSE CALL TELLER(%DB_DELETED);
           CALL M$EXIT;
        END;
        OK = TRUE;
        DO CASE(TOKEN.VAL);
         CASE(%DA);                     /* DATA FID                           */
           IF BASOPN
           THEN DO;
              IF NUMRECS < 1 THEN KEEP# = %RELEASE#;
              ELSE KEEP# = %SAVE#;
              CALL CLSFIL(DATUNT,KEEP#);
              IF KEEP# = %SAVE# THEN CALL TELLER(%DB_SAVED);
              ELSE CALL TELLER(%DB_DELETED);
              BASOPN = FALSE; WRTFLG = TRUE;
           END;
           CALL GETFID;
           IF OK
           THEN DO;
              IF FILE_NAME.L# > 26 THEN FILE_NAME.L# = 26;
              CHAR_LEN = FILE_NAME.L#;
              CALL INSERT(FILE_NAME.NAME#,FILE_NAME.L#,5,'$$LNC');
              FILE_NAME.L# = FILE_NAME.L# + 5;
              OLDFIL = FALSE;
              CALL OPNFIL(DATUNT,%CREATE#,%OLDFILE#,%INDEXED#);
              IF OK
              THEN DO;
                 IF OLDFIL
                 THEN DO;
                    NUMRECS = DCBADDR(DATUNT)->F$DCB.NRECS#;
                    CALL TELLER(%OLD_DB);
                 END;
                 ELSE DO;
                    NUMRECS = 0;
                    CALL TELLER(%NEW_DB);
                 END;
                 BASOPN = TRUE;
                 IF NOT WRTFLG THEN CALL TELLER(%NO_ACCESS);
              END;
           END;
         CASE(%SO,%UP);                 /* SOURCE ACCT,TAG or                 */
                                        /* UPDATE ACCT,ACCT,TAG               */
           IF NOT WRTFLG THEN CALL TELLER(%NO_ACCESS);
           ELSE DO;
              IF NOT BASOPN THEN CALL TELLER(%NO_DB);
              ELSE DO;
                 IF NOT LSTFIL THEN CALL TELLER(%NO_LST);
                 ELSE DO;
                    I = TOKEN.VAL - %SO;
                    CALL NXTTKN;
                    IF OK
                    THEN DO;
                       SIACCT = TPTR$->TCHAR;
                       IF I = %ONE
                       THEN DO;
                          CALL NXTTKN;
                          IF OK THEN UIACCT = TPTR$->TCHAR;
                       END;
                    END;
                    IF OK THEN CALL NXTTKN;
                    IF OK
                    THEN DO;
/* NOW GET TAGS */
                       TAG_NAME_1 = TPTR$->TCHAR;
                       CALL COUNT(I);
                       LSTFIL = TRUE;
                       CALL M$REW(REW_LIST);
                    END;
                 END;
              END;
           END;
         CASE(%SR,%UR);            /* SREPORT [(ON|INTO|OVER) FID],TAG,TAG    */
                                   /* UREPORT [(ON|INTO|OVER) FID],TAG,TAG    */
           IF NOT BASOPN THEN CALL TELLER(%NO_DB);
           ELSE DO;
              IF NUMRECS < 1 THEN CALL TELLER(%DB_EMPTY);
              ELSE DO;
                 I = TOKEN.VAL - %SR;
                 CALL NXTTKN;
                 IF OK
                 THEN DO;
                    IF TOKEN.VAL = %TAG
                    THEN DO;
                       FILE_RES = 'ME  ';
                       FILE_ASN = %DEVICE#;
                       FILE_NAME.NAME# = ' ';
                       FILE_NAME.L# = 0;
                       FILE_PASS.PASS# = ' ';
                       FILE_ACCT.ACCT# = ' ';
                       FILE_WSN.WSN# = ' ';
                       FILE_SN.NUM# = 0;
                       CALL OPNFIL(OPUNIT,%CREATE#,0,%UR#);
                    END;
                    ELSE DO;
                       STAT = TOKEN.VAL - %ON + 1;
                       CALL GETFID;
                       IF OK THEN CALL OPNFIL(OPUNIT,%CREATE#,STAT,%UR#);
                       IF OK THEN CALL NXTTKN;
                    END;
                    IF OK
                    THEN DO;
                       TAG_NAME_1 = TPTR$->TCHAR;
                       CALL NXTTKN;
                       IF OK THEN TAG_NAME_2 = TPTR$->TCHAR;
                    END;
                 END;
                 IF OK
                 THEN DO;
                    CALL REPORT(I);
                    CALL CLSFIL(OPUNIT,%SAVE#);
                 END;
              END;
           END;
         CASE(%LI);                     /* LIST FID                           */
           IF DCBADDR(LSUNIT)->F$DCB.FCD# THEN CALL CLSFIL(LSUNIT,%SAVE#);
           LSTFIL = FALSE;
           CALL GETFID;
           IF OK THEN CALL OPNFIL(LSUNIT,%IN#,0,0);
           IF OK THEN LSTFIL = TRUE;
           ELSE LSTFIL = FALSE;
         CASE(%TI);                     /* TITLE ={STRING}                    */
           CALL NXTTKN;
           IF OK
           THEN DO;
              TITLE_NAME.L = TOKEN.LEN;
              TITLE_NAME.C = TPTR$->TCHAR;
           END;
         CASE(%DE);                     /* DELETE  TAG                        */
           CALL NXTTKN;
           IF OK
           THEN DO;
              DELETE_KEY1.TAG = TPTR$->TCHAR;
              DELETE_KEY2.TAG = TPTR$->TCHAR;
              CALL M$DELREC(DEL_TAG);
              I = NUMRECS;
              NUMRECS = DCBADDR(DATUNT)->F$DCB.ARS#;
              CALL TELLER(%N_DELETED);
              NUMRECS = I - NUMRECS;
           END;
         CASE(%DF);                     /* DFILE                              */
           IF NOT WRTFLG THEN CALL TELLER(%NO_ACCESS);
           ELSE DO;
              CALL CLSFIL(DATUNT,%RELEASE#);
              CALL TELLER(%DB_DELETED);
              BASOPN = FALSE;
           END;
        END;
        GOTO GET_CMD;
END LNCOUNT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/******************************************************************/
/*M*     COUNT     Feb. 5, 1980        GWJ                        */
/***/
/*P*     NAME: COUNT
         PURPOSE: COUNT opens the source file and then counts the
                   number of source line and the number of comment
                   lines and writes the information to the Data Base.
*/
 
COUNT : PROC (ACCT_TYPE);
 
%INCLUDE LNCOUNT_C1;
 
DCL ACCT_TYPE UBIN;
%EQU NOCODE = 0;
%EQU PL6CODE = 1;
%EQU NONPL6CODE = 2;
 
DCL 1 DATA_REC ALIGNED BASED,
      2 NAME CHAR(4) UNAL,
      2 MODUAL CHAR(31) UNAL,
      2 OWNER CHAR(13) UNAL,
      2 TYPE CHAR(3) UNAL,
      2 PROCESSOR CHAR(13) UNAL,
      2 COMMENT SBIN,
      2 SOURCE  SBIN,
      2 TOTAL,
        3 COMMENT SBIN,
        3 SOURCE  SBIN;
 
%FPT_WRITE(FPTN=WR_DATA,BUF=OU_REC,NEWKEY=YES,ONEWKEY=NO);
 
DCL OU_REC CHAR(80) STATIC ALIGNED;
 
DCL OREC$ PTR CONSTANT INIT(ADDR(OU_REC));
 
DCL CREC CHAR(256) BASED UNAL;
DCL IS UBIN; DCL US UBIN;
DCL IC UBIN; DCL UC UBIN;
 
DCL GETFID ENTRY;
DCL OPNFIL ENTRY(4);
DCL CLSFIL ENTRY(2);
DCL NXTTKN ENTRY;
DCL TELLER ENTRY(1);
DCL READ_FILE ENTRY(2) ALTRET;
 
/***** ** ** ** *****/
 
        INUNIT = LSUNIT;
        LSTFIL = TRUE;
        RECPOS = RECLEN + 1;
        CALL GETFID;
        DO WHILE(LSTFIL AND NOT BRKFLG);
           FILE_ACCT.ACCT# = SIACCT;
           CALL OPNFIL(SAUNIT,%IN#,0,0);
           IF OK
           THEN DO;
              XUDATA.FLAGS.BASE# = %YES#;
              IF ACCT_TYPE = %ONE
              THEN DO;
                 FILE_ACCT.ACCT# = UIACCT;
                 CALL OPNFIL(UAUNIT,%IN#,0,0);
                 IF OK THEN XUDATA.FLAGS.UP_DATE# = %YES#;
                 ELSE XUDATA.FLAGS.UP_DATE# = %NO#;
              END;
              OK = TRUE;
              CALL XUU$OPEN(XUDATA) ALTRET(XOPN_ERR);
              DO WHILE(FALSE);
XOPN_ERR:
                 CALL TELLER(-2);
                 OK = FALSE;
              END;
              IF OK
              THEN DO;
                 RECNBR = 0;
                 INUNIT = SAUNIT;
                 OU_REC = ' ';
                 CALL GETTYPE;
                 CALL GETOWNER;
                 CALL GETPRO;
                 OREC$->DATA_REC.NAME = TAG_NAME_1;
                 OREC$->DATA_REC.MODUAL = FILE_NAME.NAME#;
                 IS = 0; US = 0; IC = 0; UC = 0;
                 IF DCBADDR(UAUNIT)->F$DCB.FCD# = %YES#
                 THEN DO;
                    TOKEN.LEN = 8;
                    TOKEN.CHR = DCBADDR(UAUNIT)->F$DCB.ACCT#;
                 END;
                 ELSE TOKEN.LEN = 0;
                 CALL TELLER(%COUNTING);
                 SCRTYP = %NOCODE;
                 DO WHILE(TRUE);
                    CALL READ_FILE(SAUNIT,RECORD) ALTRET(END_OF_FILE);
                    DO CASE(SCRTYP);
                     CASE(%NOCODE);
                       PTR1$ = ADDR(RECORD);
                       CHAR_LEN = RECLEN;
                       I = 0;
                       DO WHILE(RECORD(I) = ' ' AND I < RECLEN);
                          I = I + 1;
                       END;
                       IF ADDR(RECORD(I))->C2 = '/*'
                       THEN DO;
                          SCRTYP = %PL6CODE;
                          GOTO PL6LINE;
                       END;
                       IF PINCRC(PTR1$,I)->C1 = '!' OR
                         PINCRC(PTR1$,I)->C1 = '*' OR
                         PINCRC(PTR1$,I)->C2 = 'C ' OR
                         PINCRC(PTR1$,I)->C3 = 'REM' OR
                         PINCRC(PTR1$,I)->C4 = '$COM'
                       THEN DO;
                          SCRTYP = %NONPL6CODE;
                          GOTO NONPL6LINE;
                       END;
                       IS = IS + 1;
                       IF UPDFLG THEN US = US + 1;
                     CASE(%PL6CODE);
                       PTR1$ = ADDR(RECORD);
                       CHAR_LEN = RECLEN;
                       I = 0;
                       DO WHILE(RECORD(I) = ' ' AND I < RECLEN);
                          I = I + 1;
                       END;
                       IF ADDR(RECORD(I))->C2 = '/*'
                       THEN DO;
                          DO WHILE(TRUE);
PL6LINE:                     ;
                             IC = IC + 1;
                             IF UPDFLG THEN UC = UC + 1;
                             CALL INDEX2(I,'*/',PTR1$->CCHAR) ALTRET(NXT_C);
                             GOTO END_COMMENT;
NXT_C:
                             RECPOS = RECLEN + 1;
                             CALL READ_FILE(SAUNIT,RECORD) ALTRET(END_OF_FILE);
                             IF EOFFLG THEN GOTO END_OF_FILE;
                             CHAR_LEN = RECLEN;
                          END;
                       END;
                       ELSE DO;
                          IS = IS + 1;
                          IF UPDFLG THEN US = US + 1;
                       END;
END_COMMENT:           ;
                     CASE(%NONPL6CODE);
                       PTR1$ = ADDR(RECORD);
                       I = 0;
                       DO WHILE(PINCRC(PTR1$,I)->C1 = ' ' AND I < RECLEN);
                          I = I + 1;
                       END;
                       IF PINCRC(PTR1$,I)->C1 = '!' OR
                         PINCRC(PTR1$,I)->C1 = '*' OR
                         PINCRC(PTR1$,I)->C2 = 'C ' OR
                         PINCRC(PTR1$,I)->C3 = 'REM' OR
                         PINCRC(PTR1$,I)->C4 = '$COM'
                       THEN DO;
NONPL6LINE:               ;
                          IC = IC + 1;
                          IF UPDFLG THEN UC = UC + 1;
                       END;
                       ELSE DO;
                          IS = IS + 1;
                          IF UPDFLG THEN US = US + 1;
                       END;
                    END;
                 END;
END_OF_FILE:
                 IF ACCT_TYPE = %ZERO
                 THEN DO;
                    OREC$->DATA_REC.COMMENT = IC;
                    OREC$->DATA_REC.SOURCE = IS;
                 END;
                 ELSE DO;
                    OREC$->DATA_REC.COMMENT = UC;
                    OREC$->DATA_REC.SOURCE = US;
                 END;
                 OREC$->DATA_REC.TOTAL.COMMENT = IC;
                 OREC$->DATA_REC.TOTAL.SOURCE  = IS;
                 CALL WRDATA ALTRET(NO_WRITE);
              END;
           END;
NO_WRITE:
           INUNIT = LSUNIT;
           RECPOS = RECLEN + 1;
           CALL XUU$CLOSE(XUDATA);
           CALL GETFID;
        END;
        RETURN;
/** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/
 
/*F*     NAME: GETTYPE
         PURPOSE: To get the Source type of the file
*/
 
GETTYPE : PROC;
 
        I = 0;
        CALL INDEX1(I,':',ADDR(RECORD)->CREC);
        K = I + 1; L = K;
        CALL INDEX1(I,',',ADDR(RECORD)->CREC,L);
        CHAR_LEN = I - K;
        OREC$->DATA_REC.TYPE = ADDR(RECORD(K))->CCHAR;
        IF OREC$->DATA_REC.TYPE = 'PL6'
          OR OREC$->DATA_REC.TYPE = 'FMT'
        THEN SCRTYP = PL6;
        ELSE SCRTYP = NONPL6;
        RETURN;
END GETTYPE;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: GETPRO
         PURPOSE: To get the name of the Processor that this file
                   helps create
*/
 
GETPRO : PROC;
 
        I = 0;
        CALL INDEX1(I,',',ADDR(RECORD)->CREC); L = I + 1;
        CALL INDEX1(I,',',ADDR(RECORD)->CREC,L);
        K = I + 1; L = K;
        CALL INDEX1(I,',',ADDR(RECORD)->CREC,L);
        CHAR_LEN = I - K;
        OREC$->DATA_REC.PROCESSOR = ADDR(RECORD(K))->CCHAR;
        RETURN;
END GETPRO;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: GETOWNER
         PURPOSE: To get the Programers name
*/
 
GETOWNER : PROC;
 
        I = RECLEN - 1;
        K = 0;
        DO WHILE(RECORD(I) > ' ');
           I = I - 1;
           K = K + 1;
        END;
        CHAR_LEN = K;
        OREC$->DATA_REC.OWNER = ADDR(RECORD(I + 1))->CCHAR;
        RETURN;
END GETOWNER;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: WRDATA
         PURPOSE: To write out the DATA_REC to the Data Base
*/
 
WRDATA : PROC ALTRET;
 
        WR_DATA.V.DCB# = DATUNT;
        CALL M$WRITE(WR_DATA) ALTRET(NO_WR);
        NUMRECS = NUMRECS + 1;
        RETURN;
NO_WR:
        TOKEN.CHR = FILE_NAME.NAME#;
        TOKEN.LEN = FILE_NAME.L#;
        CALL TELLER(%REC_EXISTS);
        ALTRETURN;
END WRDATA;
/** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/
END COUNT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/******************************************************************/
/*M*     REPORT    Feb. 5, 1980        GWJ                        */
/***/
/*P*     NAME: REPROT
         PURPOSE: REPORT will take the information in tha Data Base
                   and Report it to the OPUNIT dcb as a UR file.
*/
 
REPORT : PROC(ACCT_TYPE);
 
DCL ACCT_TYPE UBIN;
 
%INCLUDE LNCOUNT_C1;
 
%FPT_WRITE(FPTN=WR_UR,VFC=YES,BUF=URBUF.DATA);
 
DCL 1 URBUF ALIGNED STATIC,
      2 DATA,
        3 VFC CHAR(1) UNAL,
        3 CHARS CHAR(109) UNAL,
      2 * CHAR(2) INIT('  ') UNAL;
 
DCL 1 FORMAT_HEADER STATIC ALIGNED,
      2 DATA,
        3 TITLE CHAR(99) UNAL,
        3 *   CHAR(5)  UNAL INIT('Page '),
        3 PG# CHAR(5) UNAL,
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_LAN CONSTANT ALIGNED,
      2 DATA,
        3 B1(0:40) CHAR(1) INIT(' '*41),
        3 * CHAR(18) INIT('Totals by Language'),
        3 B2(0:49) CHAR(1) INIT(' '*50),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_PRO CONSTANT ALIGNED,
      2 DATA,
        3 B1(0:39) CHAR(1) INIT(' '*40),
        3 * CHAR(19) INIT('Totals by Processor'),
        3 B2(0:49) CHAR(1) INIT(' '*50),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_TOTAL CONSTANT ALIGNED,
      2 DATA,
        3 B1(0:43) CHAR(1) INIT(' '*44),
        3 * CHAR(11) INIT('Grand Total'),
        3 B2(0:53) CHAR(1) INIT(' '*54),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_INFO_SS ALIGNED STATIC,
      2 DATA,
        3 MOD_NAME CHAR(16),
        3 *        CHAR(3) INIT(' | '),
        3 LANGUAGE CHAR(3),
        3 *        CHAR(3) INIT(' | '),
        3 OWNER    CHAR(13),
        3 *        CHAR(4) INIT('  | '),
        3 SI_1     CHAR(9),
        3 *        CHAR(3) INIT(' | '),
        3 SI_2     CHAR(9),
        3 *        CHAR(3) INIT(' | '),
        3 CI_1     CHAR(9),
        3 *        CHAR(3) INIT(' | '),
        3 CI_2     CHAR(9),
        3 *        CHAR(3) INIT(' | '),
        3 SIGN_1   CHAR(1),
        3 DIF_S    CHAR(7),
        3 *        CHAR(3) INIT(' | '),
        3 SIGN_2   CHAR(1),
        3 DIF_C    CHAR(7),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_INFO_SU ALIGNED STATIC,
      2 DATA,
        3 MOD_NAME CHAR(16),
        3 *        CHAR(3) INIT(' | '),
        3 LANGUAGE CHAR(3),
        3 *        CHAR(3) INIT(' | '),
        3 OWNER    CHAR(13),
        3 *        CHAR(3) INIT(' | '),
        3 SI_S     CHAR(8),
        3 *        CHAR(3) INIT(' | '),
        3 UI_S     CHAR(7),
        3 *        CHAR(3) INIT(' | '),
        3 SI_C     CHAR(8),
        3 *        CHAR(3) INIT(' | '),
        3 UI_C     CHAR(7),
        3 *        CHAR(3) INIT(' | '),
        3 UI_SI    CHAR(3),
        3 *        CHAR(4) INIT('% | '),
        3 TOT_S    CHAR(8),
        3 *        CHAR(3) INIT(' | '),
        3 TOT_C    CHAR(8),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_TITLE_SS1 ALIGNED STATIC,
      2 DATA,
        3 FIELD1(0:39) CHAR(1) INIT(' '*40),
        3 *        CHAR(9) INIT('         '),
        3 *        CHAR(6) INIT('Source'),
        3 *        CHAR(18) INIT('                  '),
        3 *        CHAR(7)  INIT('Comment'),
        3 *        CHAR(14) INIT('              '),
        3 *        CHAR(10) INIT('Difference'),
        3 *        CHAR(5) INIT('     '),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_TITLE_SS2 ALIGNED STATIC,
      2 DATA,
        3 FIELD1 CHAR(40),
        3 *        CHAR(5) INIT('     '),
        3 TAG11    CHAR(4),
        3 *        CHAR(8) INIT('        '),
        3 TAG12    CHAR(4),
        3 *        CHAR(8) INIT('        '),
        3 TAG21    CHAR(4),
        3 *        CHAR(8) INIT('        '),
        3 TAG22    CHAR(4),
        3 *        CHAR(24) INIT('      Source    Comment '),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_TITLE_SU1 ALIGNED STATIC,
      2 DATA,
        3 FIELD1(0:38) CHAR(1) INIT(' '*39),
        3 *        CHAR(4) INIT('    '),
        3 *        CHAR(11) INIT('Source For '),
        3 TAG11    CHAR(4),
        3 *        CHAR(5)  INIT('     '),
        3 *        CHAR(12) INIT('Comment for '),
        3 TAG21    CHAR(4),
        3 *        CHAR(9) INIT('  UI/SI  '),
        3 *        CHAR(4)  INIT('    '),
        3 *        CHAR(11) INIT('Totals For '),
        3 TAG2     CHAR(4),
        3 *        CHAR(2)  INIT('  '),
      2 RECORD REDEF DATA CHAR(109);
 
DCL 1 FORMAT_TITLE_SU2 ALIGNED STATIC,
      2 DATA,
        3 FIELD1 CHAR(39),
        3 *        CHAR(11) INIT('     SI    '),
        3 *        CHAR(10) INIT('    UI    '),
        3 *        CHAR(11) INIT('     SI    '),
        3 *        CHAR(10) INIT('    UI    '),
        3 *        CHAR(7)  INIT('Source '),
        3 *        CHAR(11) INIT('   Source  '),
        3 *        CHAR(10) INIT('  Comment '),
      2 RECORD REDEF DATA CHAR(109);
 
DCL FORMAT_LINES(0:108) CHAR(1) CONSTANT INIT('='*109);
DCL FORMAT_LINE REDEF FORMAT_LINES CHAR(109);
 
DCL FORMAT_BLANKS(0:108) CHAR(1) CONSTANT INIT(' '*109);
DCL FORMAT_BLANK REDEF FORMAT_BLANKS CHAR(109);
DCL BLANK UBIN;
DCL BLK$ PTR CONSTANT INIT(ADDR(FORMAT_BLANK));
DCL BCHAR CHAR(BLANK) BASED;
 
%FPT_OPEN(FPTN=OPN_STAR,ORG=KEYED,DCB=F$STAR,FUN=CREATE,
               EXIST=NEWFILE,ASN=FILE,ACS=DIRECT,NAME=STAR);
%VLP_NAME(FPTN=STAR,NAME='*TOTALS');
%FPT_CLOSE(FPTN=CLS_STAR,DISP=SCRATCH,DCB=F$STAR);
 
%FPT_READ(FPTN=RD_DATA,BUF=DATA_REC,KEY=KEY_BUF.KEY,KEYS=YES,KEYR=NO);
 
%FPT_REW(FPTN=REW);
 
%FPT_PRECORD(FPTN=POS_REC,KEYS=YES,KEYR=YES,KEY=KEY_BUF.KEY);
 
DCL F$STAR DCB;
 
DCL PAGE# UBIN;
DCL LINE# UBIN;
DCL FCG   CHAR(2);
 
DCL 1 KEY_BUF ALIGNED STATIC,
      2 KEY,
        3 TAG_NAME CHAR(4) UNAL,
        3 MOD_NAME CHAR(31) UNAL,
      2 * CHAR(1) INIT(' ') UNAL;
 
DCL 1 DATA_REC ALIGNED STATIC,
      2 NAME CHAR(4) UNAL,
      2 MODUAL CHAR(31) UNAL,
      2 OWNER CHAR(13) UNAL,
      2 TYPE CHAR(3) UNAL,
      2 PROCESSOR CHAR(13) UNAL,
      2 COMMENT SBIN,
      2 SOURCE  SBIN,
      2 TOTAL,
        3 COMMENT SBIN,
        3 SOURCE  SBIN;
 
DCL 1 STAR_REC ALIGNED STATIC,
      2 SI,
        3 COMMENT SBIN,
        3 SOURCE  SBIN,
      2 UI,
        3 COMMENT SBIN,
        3 SOURCE  SBIN,
      2 TOTAL,
        3 COMMENT SBIN,
        3 SOURCE  SBIN,
      2 NUM UBIN;
 
%FPT_READ(FPTN=RD_STAR,BUF=STAR_REC,DCB=F$STAR,KEYS=YES);
%FPT_WRITE(FPTN=WR_STAR,BUF=STAR_REC,DCB=F$STAR);
 
DCL 1 FCG_TOTAL STATIC ALIGNED,
      2 SI,
        3 COMMENT SBIN,
        3 SOURCE  SBIN,
      2 UI,
        3 COMMENT SBIN,
        3 SOURCE  SBIN,
      2 TOTAL,
        3 COMMENT SBIN,
        3 SOURCE  SBIN,
      2 NUM UBIN;
 
DCL 1 PRO_KEY STATIC ALIGNED,
      2 * UBIN BYTE INIT(11) UNAL,
      2 * SBIN BYTE INIT(0) UNAL,
      2 C CHAR(10) UNAL;
 
DCL 1 LAN_KEY STATIC ALIGNED,
      2 * UBIN BYTE INIT(7) UNAL,
      2 * SBIN BYTE INIT(-1) UNAL,
      2 C CHAR(6) UNAL;
 
DCL TELLER ENTRY(1);
DCL CHANG  ENTRY(3);
 
%FPT_TIME(FPTN=GET_DAY,DATE=TO_DAY,DEST=EXT,SOURCE=CLOCK);
 
DCL TO_DAY CHAR(10) STATIC;
 
/*********************/
 
        INUNIT = DATUNT;
        BLANK = 41;
        IF TITLE_NAME.L = 0
        THEN CALL CONCAT(FORMAT_HEADER.DATA.TITLE,BLK$->BCHAR,
             'Line Count Report',BLK$->BCHAR);
        ELSE DO;
           CHAR_LEN = TITLE_NAME.L;
           BLANK = (99 - (23 + CHAR_LEN)) / 2;
           CALL CONCAT(FORMAT_HEADER.DATA.TITLE,BLK$->BCHAR,
             'Line Count Report For ',
             ADDR(TITLE_NAME.C)->CCHAR,
             BLK$->BCHAR);
        END;
        CALL M$OPEN(OPN_STAR);
        REW.V.DCB# = DATUNT;
        CALL M$REW(REW);
        RD_DATA.V.DCB# = DATUNT;
        POS_REC.V.DCB# = DATUNT;
        PAGE# = 0;
        FCG = '  ';
        LINE# = 33; /* IF PAGE EJECT DESIRED AT END OF NEW 'FCG' THEN
                       MOVE THIS LINE TO REPLACE THE LINE
                    'LINE# = LINE# + 2;' MARKED BY THE 'XXXX'S */
        FCG_TOTAL = '0'B;
        WR_UR.V.DCB# = OPUNIT;
        CALL M$TIME(GET_DAY);
 
/* OK NOW POSTION IN THE FILE TO THE FIRST RECORD OF THE TAG GROUP */
        POS_REC.V.N# = 0;
        KEY_BUF.KEY.TAG_NAME = TAG_NAME_1;
        KEY_BUF.KEY.MOD_NAME = BLK$->BCHAR;
        CALL M$PRECORD(POS_REC) ALTRET(ALT_EXP);
        DO WHILE(FALSE);
ALT_EXP:
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$NOKEY
           THEN DO;
              CALL TELLER(-1);
              CALL TELLER(%DATA_BASE_ERROR);
              BRKFLG = TRUE;
           END;
        END;
 
        DO WHILE(NOT BRKFLG);
           CALL M$READ(RD_DATA) ALTRET(OK_ALTRET);
           IF DATA_REC.NAME = TAG_NAME_1
           THEN DO;
              IF ADDR(DATA_REC.MODUAL)->C2 ~= FCG
              THEN DO;
                 IF FCG_TOTAL ~= '0'B
                 THEN DO;
                    LINE# = LINE# + 2;  /* XXXX                               */
                    CALL PRINT_FCG_TOTALS;
                    IF LINE# < 28
                    THEN DO;
                       URBUF.DATA.VFC = 'A';
                       URBUF.DATA.CHARS = FORMAT_BLANK;
                       CALL M$WRITE(WR_UR);
                       URBUF.DATA.CHARS = FORMAT_LINE;
                       CALL M$WRITE(WR_UR);
                       LINE# = LINE# + 2;
                    END;
                    ELSE LINE# = 33;
                 END;
                 FCG_TOTAL = '0'B;
                 FCG = ADDR(DATA_REC.MODUAL)->C2;
              END;
              IF LINE# >= 32 THEN CALL PRINT_TITLES(%ZERO);
              CALL PRINT_INFO;
              LINE# = LINE# + 1;
           END;
           POS_REC.V.N# = 1;
           KEY_BUF.KEY.TAG_NAME = TAG_NAME_1;
           CALL M$PRECORD(POS_REC) ALTRET(OK_ALTRET);
           DO WHILE(FALSE);
OK_ALTRET:
              IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$NOKEY
              THEN GOTO END_OF_DATA;
           END;
           IF KEY_BUF.KEY.TAG_NAME ~= TAG_NAME_1 THEN BRKFLG = TRUE;
        END;
END_OF_DATA:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$EOF AND
          NOT BRKFLG
        THEN CALL TELLER(-1);
        ELSE DO;
           CALL PRINT_FCG_TOTALS;
           FCG_TOTAL = '0'B;
           CALL PRINT_LAN_TOTALS;
           CALL PRINT_PRO_TOTALS;
           CALL PRINT_GRAND_TOTALS;
           URBUF.DATA.VFC = 'A';
           CHAR_LEN = 99 - (2 * BLANK);
           CALL CONCAT(URBUF.DATA.CHARS,'End of ',
             PINCRC(ADDR(FORMAT_HEADER.DATA.TITLE),BLANK)->CCHAR,
             ' ',TO_DAY,'.');
           WR_UR.BUF_.BOUND = 18 + CHAR_LEN;
           CALL M$WRITE(WR_UR);
           WR_UR.BUF_.BOUND = 109;
           RD_STAR.V.KEYR# = %NO#; RD_STAR.V.KEYS# = %YES#;
        END;
        CALL M$CLOSE(CLS_STAR);
        RETURN;
/******************************************************************/
%EJECT;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: PRINT_INFO
         PURPOSE: To print the data record to the OPUNIT using the
                   format line FORMAT_INFO
*/
 
PRINT_INFO: PROC;
 
        IF ACCT_TYPE = %ZERO
        THEN DO;
           FORMAT_INFO_SS.DATA.MOD_NAME = DATA_REC.MODUAL;
           FORMAT_INFO_SS.DATA.LANGUAGE = DATA_REC.TYPE;
           FORMAT_INFO_SS.DATA.OWNER    = DATA_REC.OWNER;
           CALL CHANG(DATA_REC.TOTAL.SOURCE,FORMAT_INFO_SS.DATA.SI_1,9);
           CALL CHANG(DATA_REC.TOTAL.COMMENT,FORMAT_INFO_SS.DATA.CI_1,9);
           I = DATA_REC.TOTAL.SOURCE; J = DATA_REC.TOTAL.COMMENT;
        END;
        ELSE DO;
           FORMAT_INFO_SU.DATA.MOD_NAME = DATA_REC.MODUAL;
           FORMAT_INFO_SU.DATA.LANGUAGE = DATA_REC.TYPE;
           FORMAT_INFO_SU.DATA.OWNER    = DATA_REC.OWNER;
           CALL CHANG(DATA_REC.SOURCE,FORMAT_INFO_SU.DATA.SI_S,8);
           CALL CHANG(DATA_REC.COMMENT,FORMAT_INFO_SU.DATA.SI_C,8);
           I = DATA_REC.SOURCE; J = DATA_REC.COMMENT;
        END;
        PRO_KEY.C = DATA_REC.PROCESSOR;
        LAN_KEY.C = DATA_REC.TYPE;
        KEY_BUF.KEY.TAG_NAME = TAG_NAME_2;
        CALL M$READ(RD_DATA) ALTRET(NO_REC);
        DO WHILE(FALSE);
NO_REC:
           DATA_REC = '0'B;
        END;
        IF ACCT_TYPE = %ZERO
        THEN DO;
           CALL CHANG(DATA_REC.TOTAL.SOURCE,FORMAT_INFO_SS.DATA.SI_2,9);
           CALL CHANG(DATA_REC.TOTAL.COMMENT,FORMAT_INFO_SS.DATA.CI_2,9);
           K = DATA_REC.TOTAL.SOURCE; L = DATA_REC.TOTAL.COMMENT;
           M = K - I; N = L - J;
           IF M < 0
           THEN DO;
              FORMAT_INFO_SS.DATA.SIGN_1 = '-';
              M = M * -1;
           END;
           ELSE FORMAT_INFO_SS.DATA.SIGN_1 = '+';
           IF N < 0
           THEN DO;
              FORMAT_INFO_SS.DATA.SIGN_2 = '-';
              N = N * -1;
           END;
           ELSE FORMAT_INFO_SS.DATA.SIGN_2 = '+';
           CALL CHANG(M,FORMAT_INFO_SS.DATA.DIF_S,7);
           CALL CHANG(N,FORMAT_INFO_SS.DATA.DIF_C,7);
        END;
        ELSE DO;
           CALL CHANG(DATA_REC.SOURCE,FORMAT_INFO_SU.DATA.UI_S,7);
           K = DATA_REC.SOURCE;
           CALL CHANG(DATA_REC.COMMENT,FORMAT_INFO_SU.DATA.UI_C,7);
           CALL CHANG(DATA_REC.TOTAL.SOURCE,FORMAT_INFO_SU.DATA.TOT_S,8);
           CALL CHANG(DATA_REC.TOTAL.COMMENT,FORMAT_INFO_SU.DATA.TOT_C,8);
           M = 0;
           DO WHILE(K > I AND I ~= 0);
              M = M + 100;
              K = K - I;
           END;
           IF I = 0 THEN I = 1;M = M + ((K * 100) / I);
           CALL CHANG(M,FORMAT_INFO_SU.DATA.UI_SI,3);
           K = DATA_REC.SOURCE; L = DATA_REC.COMMENT;
           M = DATA_REC.TOTAL.SOURCE; N = DATA_REC.TOTAL.COMMENT;
        END;
        URBUF.DATA.VFC = 'A';           /* PRINT SPACE 1                      */
        IF ACCT_TYPE = %ZERO THEN URBUF.DATA.CHARS = FORMAT_INFO_SS.RECORD;
        ELSE URBUF.DATA.CHARS = FORMAT_INFO_SU.RECORD;
        CALL M$WRITE(WR_UR);
/* RECORD NOW WRITTEN */                /* NOW INCR TOTALS                    */
        FCG_TOTAL.SI.COMMENT =
          FCG_TOTAL.SI.COMMENT + J;
        FCG_TOTAL.UI.COMMENT =
          FCG_TOTAL.UI.COMMENT + L;
        FCG_TOTAL.SI.SOURCE  =
          FCG_TOTAL.SI.SOURCE  + I;
        FCG_TOTAL.UI.SOURCE  =
          FCG_TOTAL.UI.SOURCE  + K;
        FCG_TOTAL.NUM = FCG_TOTAL.NUM + 1;
        FCG_TOTAL.TOTAL.SOURCE =
          FCG_TOTAL.TOTAL.SOURCE + M;
        FCG_TOTAL.TOTAL.COMMENT =
          FCG_TOTAL.TOTAL.COMMENT + N;
/* NOW TRY TO READ PROCESSOR TOTALS */
        RD_STAR.KEY_ = VECTOR(PRO_KEY);
        CALL M$READ(RD_STAR) ALTRET(OK1);
        DO WHILE(FALSE);
OK1:
           STAR_REC = '0'B;
        END;
        STAR_REC.SI.COMMENT =
          STAR_REC.SI.COMMENT + J;
        STAR_REC.UI.COMMENT =
          STAR_REC.UI.COMMENT + L;
        STAR_REC.SI.SOURCE  =
          STAR_REC.SI.SOURCE  + I;
        STAR_REC.UI.SOURCE  =
          STAR_REC.UI.SOURCE  + K;
        STAR_REC.NUM = STAR_REC.NUM + 1;
        STAR_REC.TOTAL.SOURCE =
          STAR_REC.TOTAL.SOURCE + M;
        STAR_REC.TOTAL.COMMENT =
          STAR_REC.TOTAL.COMMENT + N;
        WR_STAR.KEY_ = VECTOR(PRO_KEY);
        CALL M$WRITE(WR_STAR);
 
/* NOW TRY TO READ LANGUAGE TOTALS */
        RD_STAR.KEY_ = VECTOR(LAN_KEY);
        CALL M$READ(RD_STAR) ALTRET(OK2);
        DO WHILE(FALSE);
OK2:
           STAR_REC = '0'B;
        END;
        STAR_REC.SI.COMMENT =
          STAR_REC.SI.COMMENT + J;
        STAR_REC.UI.COMMENT =
          STAR_REC.UI.COMMENT + L;
        STAR_REC.SI.SOURCE  =
          STAR_REC.SI.SOURCE  + I;
        STAR_REC.UI.SOURCE  =
          STAR_REC.UI.SOURCE  + K;
        STAR_REC.NUM = STAR_REC.NUM + 1;
        STAR_REC.TOTAL.SOURCE =
          STAR_REC.TOTAL.SOURCE + M;
        STAR_REC.TOTAL.COMMENT =
          STAR_REC.TOTAL.COMMENT + N;
        WR_STAR.KEY_ = VECTOR(LAN_KEY);
        CALL M$WRITE(WR_STAR);
        RETURN;
END PRINT_INFO;
%EJECT;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: PRINT_LAN_TOTALS
         PURPOSE: Print the Language Totals using the format line
                   FORMAT_INFO
*/
PRINT_LAN_TOTALS: PROC;
 
DCL 1 STAR_KEY ALIGNED STATIC,
      2 LEN UBIN BYTE UNAL,
      2 TYPE SBIN BYTE UNAL,
      2 C   CHAR(10) UNAL;
 
 
        LINE# = 32;
        RD_STAR.V.KEYR# = %YES#; RD_STAR.V.KEYS# = %NO#;
        RD_STAR.KEY_ = VECTOR(STAR_KEY);
        REW.V.DCB# = DCBNUM(F$STAR);
        CALL M$REW(REW);
        DO WHILE(TRUE);
           CALL M$READ(RD_STAR) ALTRET(END_OF_STAR);
           IF STAR_KEY.TYPE = %ZERO - 1
           THEN DO;
              IF LINE# >= 31 THEN CALL PRINT_TITLES(%ONE);
              IF ACCT_TYPE = %ZERO
              THEN DO;
                 CALL CHANG(STAR_REC.NUM,FORMAT_INFO_SS.DATA.MOD_NAME,16);
                 M = STAR_REC.TOTAL.SOURCE;
                 N = STAR_REC.TOTAL.COMMENT;
                 IF M < 0
                 THEN DO;
                    FORMAT_INFO_SS.DATA.SIGN_1 = '-';
                    M = M * -1;
                 END;
                 ELSE FORMAT_INFO_SS.DATA.SIGN_1 = '+';
                 IF N < 0
                 THEN DO;
                    FORMAT_INFO_SS.DATA.SIGN_2 = '-';
                    N = N * - 1;
                 END;
                 ELSE FORMAT_INFO_SS.DATA.SIGN_2 = '+';
                 CALL CHANG(M,FORMAT_INFO_SS.DATA.DIF_S,7);
                 CALL CHANG(N,FORMAT_INFO_SS.DATA.DIF_C,7);
                 FORMAT_INFO_SS.DATA.LANGUAGE = ADDR(STAR_KEY.C)->C3;
                 FORMAT_INFO_SS.DATA.OWNER    = '     ALL     ';
                 CALL CHANG(STAR_REC.SI.SOURCE,FORMAT_INFO_SS.DATA.SI_1,9);
                 CALL CHANG(STAR_REC.UI.SOURCE,FORMAT_INFO_SS.DATA.SI_2,9);
                 CALL CHANG(STAR_REC.SI.COMMENT,FORMAT_INFO_SS.DATA.CI_1,9);
                 CALL CHANG(STAR_REC.UI.COMMENT,FORMAT_INFO_SS.DATA.CI_2,9);
                 URBUF.DATA.CHARS = FORMAT_INFO_SS.RECORD;
              END;
              ELSE DO;
                 CALL CHANG(STAR_REC.NUM,FORMAT_INFO_SU.DATA.MOD_NAME,16);
                 CALL CHANG(STAR_REC.TOTAL.SOURCE,FORMAT_INFO_SU.DATA.TOT_S,8);
                 CALL CHANG(STAR_REC.TOTAL.COMMENT,FORMAT_INFO_SU.DATA.TOT_C,8);
                 FORMAT_INFO_SU.DATA.LANGUAGE = ADDR(STAR_KEY.C)->C3;
                 FORMAT_INFO_SU.DATA.OWNER    = '     ALL     ';
                 CALL CHANG(STAR_REC.SI.SOURCE,FORMAT_INFO_SU.DATA.SI_S,8);
                 CALL CHANG(STAR_REC.UI.SOURCE,FORMAT_INFO_SU.DATA.UI_S,7);
                 CALL CHANG(STAR_REC.SI.COMMENT,FORMAT_INFO_SU.DATA.SI_C,8);
                 CALL CHANG(STAR_REC.UI.COMMENT,FORMAT_INFO_SU.DATA.UI_C,7);
                 URBUF.DATA.CHARS = FORMAT_INFO_SU.RECORD;
              END;
              URBUF.DATA.VFC = 'A';
              CALL M$WRITE(WR_UR);
/* RECORD NOW WRITTEN */                /* NOW INCR TOTALS                    */
              FCG_TOTAL.SI.COMMENT =
                FCG_TOTAL.SI.COMMENT + STAR_REC.SI.COMMENT;
              FCG_TOTAL.UI.COMMENT =
                FCG_TOTAL.UI.COMMENT + STAR_REC.UI.COMMENT;
              FCG_TOTAL.SI.SOURCE  =
                FCG_TOTAL.SI.SOURCE  + STAR_REC.SI.SOURCE;
              FCG_TOTAL.UI.SOURCE  =
                FCG_TOTAL.UI.SOURCE  + STAR_REC.UI.SOURCE;
              FCG_TOTAL.TOTAL.SOURCE =
                FCG_TOTAL.TOTAL.SOURCE + STAR_REC.TOTAL.SOURCE;
              FCG_TOTAL.TOTAL.COMMENT =
                FCG_TOTAL.TOTAL.COMMENT + STAR_REC.TOTAL.COMMENT;
              FCG_TOTAL.NUM = FCG_TOTAL.NUM + STAR_REC.NUM;
           END;
        END;
END_OF_STAR:
        CALL PRINT_TOTALS;
        RETURN;
END PRINT_LAN_TOTALS;
%EJECT;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: PRINT_PRO_TOTALS
         PURPOSE: Print the Language Totals using the format line
                   FORMAT_INFO
*/
PRINT_PRO_TOTALS: PROC;
 
DCL 1 STAR_KEY ALIGNED STATIC,
      2 LEN UBIN BYTE UNAL,
      2 TYPE SBIN BYTE UNAL,
      2 C   CHAR(10) UNAL;
 
DCL C10 CHAR(10) BASED;
 
%SUB TWO = 2;
 
        LINE# = 32;
        RD_STAR.V.KEYR# = %YES#; RD_STAR.V.KEYS# = %NO#;
        RD_STAR.KEY_ = VECTOR(STAR_KEY);
        REW.V.DCB# = DCBNUM(F$STAR);
        CALL M$REW(REW);
        DO WHILE(TRUE);
           CALL M$READ(RD_STAR) ALTRET(END_OF_STAR);
           IF STAR_KEY.TYPE = %ZERO
           THEN DO;
              IF LINE# >= 31 THEN CALL PRINT_TITLES(%TWO);
              IF ACCT_TYPE = %ZERO
              THEN DO;
                 CALL CHANG(STAR_REC.NUM,FORMAT_INFO_SS.DATA.MOD_NAME,16);
                 M = STAR_REC.TOTAL.SOURCE;
                 N = STAR_REC.TOTAL.COMMENT;
                 IF M < 0
                 THEN DO;
                    FORMAT_INFO_SS.DATA.SIGN_1 = '-';
                    M = M * -1;
                 END;
                 ELSE FORMAT_INFO_SS.DATA.SIGN_1 = '+';
                 IF N < 0
                 THEN DO;
                    FORMAT_INFO_SS.DATA.SIGN_2 = '-';
                    N = N * - 1;
                 END;
                 ELSE FORMAT_INFO_SS.DATA.SIGN_2 = '+';
                 CALL CHANG(M,FORMAT_INFO_SS.DATA.DIF_S,7);
                 CALL CHANG(N,FORMAT_INFO_SS.DATA.DIF_C,7);
                 FORMAT_INFO_SS.DATA.LANGUAGE = 'ALL';
                 FORMAT_INFO_SS.DATA.OWNER    = ADDR(STAR_KEY.C)->C10;
                 CALL CHANG(STAR_REC.SI.SOURCE,FORMAT_INFO_SS.DATA.SI_1,9);
                 CALL CHANG(STAR_REC.UI.SOURCE,FORMAT_INFO_SS.DATA.SI_2,9);
                 CALL CHANG(STAR_REC.SI.COMMENT,FORMAT_INFO_SS.DATA.CI_1,9);
                 CALL CHANG(STAR_REC.UI.COMMENT,FORMAT_INFO_SS.DATA.CI_2,9);
                 URBUF.DATA.CHARS = FORMAT_INFO_SS.RECORD;
              END;
              ELSE DO;
                 CALL CHANG(STAR_REC.NUM,FORMAT_INFO_SU.DATA.MOD_NAME,16);
                 CALL CHANG(STAR_REC.TOTAL.SOURCE,FORMAT_INFO_SU.DATA.TOT_S,8);
                 CALL CHANG(STAR_REC.TOTAL.COMMENT,FORMAT_INFO_SU.DATA.TOT_C,8);
                 FORMAT_INFO_SU.DATA.LANGUAGE = 'ALL';
                 FORMAT_INFO_SU.DATA.OWNER    = ADDR(STAR_KEY.C)->C10;
                 CALL CHANG(STAR_REC.SI.SOURCE,FORMAT_INFO_SU.DATA.SI_S,8);
                 CALL CHANG(STAR_REC.UI.SOURCE,FORMAT_INFO_SU.DATA.UI_S,7);
                 CALL CHANG(STAR_REC.SI.COMMENT,FORMAT_INFO_SU.DATA.SI_C,8);
                 CALL CHANG(STAR_REC.UI.COMMENT,FORMAT_INFO_SU.DATA.UI_C,7);
                 URBUF.DATA.CHARS = FORMAT_INFO_SU.RECORD;
              END;
              URBUF.DATA.VFC = 'A';
              CALL M$WRITE(WR_UR);
           END;
        END;
END_OF_STAR:
        CALL PRINT_TOTALS;
        RETURN;
END PRINT_PRO_TOTALS;
%EJECT;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: PRINT_GRAND_TOTALS
         PURPOSE: Print the Grand Totals. The data is in FCG_TOTAL
                   put there by PRINT_LAN_TOTAL. Print using format
                   line FORMAT_INFO
*/
 
PRINT_GRAND_TOTALS: PROC;
 
%SUB THREE = 3;
 
        CALL PRINT_TITLES(%THREE);
/** ** ** **/
 
PRINT_TOTALS: ENTRY;
 
        CALL PRINT_FCG_TOTALS;
        URBUF.DATA.VFC = 'A';
        URBUF.DATA.CHARS = FORMAT_LINE;
        CALL M$WRITE(WR_UR);
        CALL M$WRITE(WR_UR);
        RETURN;
END PRINT_GRAND_TOTALS;
%EJECT;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: PRINT_TITLES
         PURPOSE: Print the Header and Titles for each page.
*/
 
PRINT_TITLES: PROC(NUM);
 
DCL NUM UBIN;                           /* 0 = NORMAL TITLES
                                           1 = LANGUAGE TITLES
                                           2 = PROCESSOR TITLES
                                           3 = TOTALS TITLES   */
 
        PAGE# = PAGE# + 1;
        LINE# = 0;
        URBUF.DATA.VFC = 'r';           /* TOP OF FORM, PRINT, SPACE 2 LINES  */
        CALL CHANG(PAGE#,FORMAT_HEADER.DATA.PG#,5);
        URBUF.DATA.CHARS = FORMAT_HEADER.RECORD;
        CALL M$WRITE(WR_UR);
        URBUF.DATA.VFC = 'A';
        DO CASE(NUM);
         CASE(0); URBUF.DATA.CHARS = FORMAT_BLANK;
         CASE(1); URBUF.DATA.CHARS = FORMAT_LAN.RECORD;
         CASE(2); URBUF.DATA.CHARS = FORMAT_PRO.RECORD;
         CASE(3); URBUF.DATA.CHARS = FORMAT_TOTAL.RECORD;
        END;
        CALL M$WRITE(WR_UR);
        IF ACCT_TYPE = %ZERO
        THEN DO;
           URBUF.DATA.CHARS = FORMAT_TITLE_SS1.RECORD;
           CALL M$WRITE(WR_UR);
           FORMAT_TITLE_SS2.DATA.TAG11 = TAG_NAME_1;
           FORMAT_TITLE_SS2.DATA.TAG12 = TAG_NAME_2;
           FORMAT_TITLE_SS2.DATA.TAG21 = TAG_NAME_1;
           FORMAT_TITLE_SS2.DATA.TAG22 = TAG_NAME_2;
           IF NUM = %ZERO THEN FORMAT_TITLE_SS2.DATA.FIELD1 =
                ' Name of Module  Language    Owner     ';
           ELSE FORMAT_TITLE_SS2.DATA.FIELD1 =
                '  # of Modules   Language   Processor  ';
           URBUF.DATA.CHARS = FORMAT_TITLE_SS2.RECORD;
           CALL M$WRITE(WR_UR);
        END;
        ELSE DO;
           FORMAT_TITLE_SU1.DATA.TAG11 = TAG_NAME_1;
           FORMAT_TITLE_SU1.DATA.TAG21 = TAG_NAME_1;
           FORMAT_TITLE_SU1.DATA.TAG2 = TAG_NAME_2;
           URBUF.DATA.CHARS = FORMAT_TITLE_SU1.RECORD;
           CALL M$WRITE(WR_UR);
           IF NUM = %ZERO THEN FORMAT_TITLE_SU2.DATA.FIELD1 =
                ' Name of Module  Language     Owner     ';
           ELSE FORMAT_TITLE_SU2.DATA.FIELD1 =
                '  # of Modules   Language   Processor   ';
           URBUF.DATA.CHARS = FORMAT_TITLE_SU2.RECORD;
           CALL M$WRITE(WR_UR);
        END;
        URBUF.DATA.CHARS = FORMAT_LINE;
        CALL M$WRITE(WR_UR);
        RETURN;
END PRINT_TITLES;
%EJECT;
/** ** ** ** ** ** ** **/
 
/*F*     NAME: PRINT_FCG_TOTALS
         PURPOSE: Print the FCG Totals using the format line
                   FORMAT_INFO
*/
PRINT_FCG_TOTALS: PROC;
 
        URBUF.DATA.VFC = 'A';
        URBUF.DATA.CHARS = FORMAT_LINE;
        CALL M$WRITE(WR_UR);
 
        IF ACCT_TYPE = %ZERO
        THEN DO;
           CALL CHANG(FCG_TOTAL.NUM,FORMAT_INFO_SS.DATA.MOD_NAME,16);
           FORMAT_INFO_SS.DATA.LANGUAGE = 'ALL';
           FORMAT_INFO_SS.DATA.OWNER    = '     ALL     ';
           CALL CHANG(FCG_TOTAL.SI.SOURCE,FORMAT_INFO_SS.DATA.SI_1,9);
           CALL CHANG(FCG_TOTAL.SI.COMMENT,FORMAT_INFO_SS.DATA.CI_1,9);
           CALL CHANG(FCG_TOTAL.UI.SOURCE,FORMAT_INFO_SS.DATA.SI_2,9);
           CALL CHANG(FCG_TOTAL.UI.COMMENT,FORMAT_INFO_SS.DATA.CI_2,9);
           M = FCG_TOTAL.TOTAL.SOURCE;
           N = FCG_TOTAL.TOTAL.COMMENT;
           IF M < 0
           THEN DO;
              FORMAT_INFO_SS.DATA.SIGN_1 = '-';
              M = M * -1;
           END;
           ELSE FORMAT_INFO_SS.DATA.SIGN_1 = '+';
           IF N < 0
           THEN DO;
              FORMAT_INFO_SS.DATA.SIGN_2 = '-';
              N = N * - 1;
           END;
           ELSE FORMAT_INFO_SS.DATA.SIGN_2 = '+';
           CALL CHANG(M,FORMAT_INFO_SS.DATA.DIF_S,7);
           CALL CHANG(N,FORMAT_INFO_SS.DATA.DIF_C,7);
        END;
        ELSE DO;
           CALL CHANG(FCG_TOTAL.NUM,FORMAT_INFO_SU.DATA.MOD_NAME,16);
           FORMAT_INFO_SU.DATA.LANGUAGE = 'ALL';
           FORMAT_INFO_SU.DATA.OWNER    = '     ALL     ';
           CALL CHANG(FCG_TOTAL.SI.SOURCE,FORMAT_INFO_SU.DATA.SI_S,8);
           I = FCG_TOTAL.SI.SOURCE;
           CALL CHANG(FCG_TOTAL.SI.COMMENT,FORMAT_INFO_SU.DATA.SI_C,8);
           CALL CHANG(FCG_TOTAL.UI.SOURCE,FORMAT_INFO_SU.DATA.UI_S,7);
           K = FCG_TOTAL.UI.SOURCE;
           CALL CHANG(FCG_TOTAL.UI.COMMENT,FORMAT_INFO_SU.DATA.UI_C,7);
           CALL CHANG(FCG_TOTAL.TOTAL.SOURCE,FORMAT_INFO_SU.DATA.TOT_S,8);
           CALL CHANG(FCG_TOTAL.TOTAL.COMMENT,FORMAT_INFO_SU.DATA.TOT_C,8);
           M = 0;
           DO WHILE(K > I AND I ~= 0);
              M = M + 100;
              K = K - I;
           END;
           IF I = 0 THEN I = 1;M = M + ((K * 100) / I);
           CALL CHANG(M,FORMAT_INFO_SU.DATA.UI_SI,3);
        END;
        URBUF.DATA.VFC = 'A';           /* PRINT SPACE 1                      */
        IF ACCT_TYPE = %ZERO THEN URBUF.DATA.CHARS = FORMAT_INFO_SS.RECORD;
        ELSE URBUF.DATA.CHARS = FORMAT_INFO_SU.RECORD;
        CALL M$WRITE(WR_UR);
        RETURN;
END PRINT_FCG_TOTALS;
END REPORT;
