/*M* WEASEL - Main routine for WEASEL                             */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
WEASEL:   PROC MAIN;
/**/
/* INCLUDES FILES */
/**/
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE XS_MACRO_C;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6_SUBS;
%INCLUDE WEASEL_C61;
%INCLUDE WEASEL_C62;
%INCLUDE EL$TABLES;
%INCLUDE EL_SUBS_C;
%INCLUDE ES_TABLES_M;
%INCLUDE ES_SUBS_E;
%INCLUDE UD_EQU_E;
%INCLUDE XUD_UTS_M;
/**/
/* SYMDEFS */
DCL 1 SL_CONSTRAINTS STATIC SYMDEF DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN BYTE ALIGNED INIT(0*0),
     2 START UBIN WORD ALIGNED INIT(0),
     2 STOP UBIN WORD ALIGNED INIT(BITBIN('377777777777'O));
DCL 1 SL_SAVE STATIC SYMDEF DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN BYTE ALIGNED INIT(0*0),
     2 START UBIN WORD ALIGNED INIT(0),
     2 STOP UBIN WORD ALIGNED INIT(BITBIN('377777777777'O));
DCL SL_ERR_RETURN REMEMBER STATIC SYMDEF;
DCL SL_BRKMSG BIT(1) ALIGNED STATIC SYMDEF INIT('0'B);
DCL SL_LASTTYPE SBIN WORD STATIC SYMDEF ALIGNED INIT(-1);
DCL SL_DATE CHAR(10) STATIC SYMDEF INIT(' ');
DCL SL_TIME CHAR(11) STATIC SYMDEF INIT(' ');
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL SL_CMD SBIN SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$INIT ENTRY(3) ALTRET;
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$SETDCBS ENTRY(4) ALTRET;
DCL XUR$SETERRMSG ENTRY(1) ALTRET;
DCL XUR$ERRMSG ENTRY(7) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL WEASEL_BRKMSG ENTRY;
DCL WEASEL_BREAK ENTRY;
DCL XUR$BREAK ENTRY ASYNC;
%XUD$UTS_ENTRIES;
/**/
/* DCBS */
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$SECLOG DCB;
/**/
/* CONSTANT DATA */
/**/
/*             CONSTANT FPTS               */
/**/
%FPT_TIME (FPTN=LOCAL,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           DEST=LOCAL,
           DATE=DBUF,
           TIME=TBUF);
%FPT_TIME (FPTN=CUR_DATE,
           STCLASS=CONSTANT,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=CURDATE);
%FPT_TIME (FPTN=ANS_DATE,
           STCLASS=CONSTANT,
           DEST=ANS,
           SOURCE=UTS,
           TSTAMP=CURDATE,
           DATE=ANSDATE);
%FPT_OPEN (FPTN=FIND_FIRST,
           STCLASS=CONSTANT,
           TEST=YES,
           DCB=M$SECLOG,
           NAME=SECLOG,
           ACCT=VLP_SYS,
           NXTF=YES,
           THISF=NO,
           ASN=FILE,
           FUN=IN,
           SHARE=ALL);
%XSA_PARAM (FPTN=SL_XSA_PARAM,
            STCLASS=STATIC);
%FPT_READ (FPTN=READ_CMD,
           STCLASS=CONSTANT,
           BUF=CMD_BUF,
           DCB=M$SI);
%FPT_WRITE (FPTN=ECHO_FPT,
            STCLASS=CONSTANT,
            BUF=CMD_BUF,
            DCB=M$LO);
%FPT_CLOSE (FPTN=CLOSE_LO,
            STCLASS=CONSTANT,
            DCB=M$LO);
%FPT_CLOSE (FPTN=SL_CLOSE_SECLOG,
            STCLASS=CONSTANT,
            DCB=M$SECLOG,
            DISP=SAVE);
%VLP_NAME (FPTN=SECLOG,
           STCLASS=CONSTANT,
           NAME=':SECLOG19780101');
%FPT_MONINFO(FPTN=FPT_MONINFO,
           STCLASS=CONSTANT,
           SITEINFO=VLR_SITEINFO);
%FPT_INT(UENTRY=XUR$BREAK,
         STCLASS=CONSTANT);
/**/
/*           CONSTANT VARIABLES            */
/**/
DCL PRMT CHAR(0) CONSTANT INIT(':');
DCL HI_FMT CHAR(0) CONSTANT INIT(
    '%A is the first available security log %10P');
/**/
/* STATIC DATA */
/**/
/*             STATIC FPTS                  */
/**/
%VLR_SITEINFO;
%FPT_TIME (FPTN=CUR_TIME,
           SOURCE=UTS,
           DEST=EXT,
           TSTAMP=CURDATE,
           TIME=SL_TIME,
           DATE=SL_DATE);
%FPT_TIME (FPTN=FIRST_SECLG,
           DEST=UTS,
           TIME=TIME_BUF,
           TSTAMP=SL_FIRST_SECLG,
           SOURCE=ANS);
%FPT_OPEN (FPTN=OPEN_LO,
           DCB=M$LO,
           SCRUB=YES,
           REASSIGN=YES,
           STCLASS=STATIC);
%FPT_OPEN (FPTN=SL_OPEN_SECLOG,
           STCLASS=STATIC,
           ACS=SEQUEN,
           NAME=SL_VLP_SECLOG,
           ACCT=VLP_SYS,
           ASN=FILE,
           FUN=IN,
           DCB=M$SECLOG,
           SHARE=ALL);
%VLP_NAME (FPTN=SL_VLP_SECLOG,
           STCLASS=STATIC,
           NAME=':SECLOGyyyymmdd',
           LEN=15);
%FPT_UNFID(FPTN=ERRMSG_UNFID,
           TEXTFID=SL_SITE_NAME.C,
           LEN=CURDATE);
/**/
/*           STATIC VARIABLES              */
/**/
DCL P_PCB$ PTR STATIC INIT(ADDR(P_PCB));
DCL 1 SL_DEFAULT STATIC DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN BYTE ALIGNED INIT(%ALL,0*0),
     2 START UBIN WORD ALIGNED INIT(0),
     2 STOP UBIN WORD ALIGNED INIT(BITBIN('377777777777'O));
DCL 1 SL_ERRCODE STATIC ALIGNED,
     2 FCG BIT(18) UNAL,
     2 MON BIT(1)  UNAL,
     2 CODE UBIN(14) UNAL,
     2 SEV UBIN(3) UNAL;
DCL SL_CPOS SBIN STATIC INIT(-1);
DCL SL_ENDFLAG BIT(1) ALIGNED STATIC INIT('0'B);
DCL SL_CURDATE UBIN WORD STATIC ALIGNED INIT(0);
DCL SL_FIRST_SECLG UBIN WORD STATIC ALIGNED INIT(0);
DCL SL_BOF BIT(1) ALIGNED STATIC INIT('1'B);
DCL SL_LASTUTS UBIN WORD STATIC ALIGNED INIT(0);
DCL SL_DAY CHAR(3) STATIC;
DCL SL_SITE_ID CHAR(6) STATIC ALIGNED INIT(' ');
DCL 1 SL_SITE_NAME STATIC ALIGNED,
      2 L UBIN BYTE UNAL INIT(0),
      2 C CHAR(119) UNAL INIT(' ');
DCL SL_XSA_BUF_VECTOR BIT(72) STATIC INIT(VECTOR(NIL));
DCL 1 SL_XSA_BUF REDEF SL_XSA_BUF_VECTOR,
      2 * UBIN,
      2 P$ PTR;
DCL SL_M$SECLOG$ PTR STATIC;
%VLP_ACCT(FPTN=VLP_SYS,
          ACCT=':SYS',
          STCLASS=STATIC);
DCL SL_CHANGE_ACCOUNT BIT(1) ALIGNED STATIC INIT('1'B);
DCL ANSDATE CHAR(6) STATIC;
DCL CURDATE UBIN WORD STATIC;
DCL FIRST_DATE CHAR(6) STATIC;
DCL TIME_BUF CHAR(8) STATIC INIT('00000000');
DCL TBUF CHAR(5) STATIC;
DCL DBUF CHAR(8) STATIC;
DCL CMD_BUF CHAR(256) STATIC;
DCL HI_VEC BIT(72) STATIC INIT(VECTOR(HI_FMT));
DCL SL_OUTBUF CHAR(100) STATIC INIT(' ');
/**/
/* AUTO DATA */
/**/
DCL I UBIN;
DCL INDX UBIN;
DCL CODE UBIN;
DCL NDAYS UBIN WORD;
DCL START_DATE UBIN WORD;
DCL STOP_DATE UBIN WORD;
DCL NAMEBUF CHAR(15);
DCL TOP$ PTR;
DCL PARSE_CODE REDEF TOP$ BIT(36);
DCL LMDCB$ PTR;
/**/
/* MACRO INVOCATIONS */
%P_PCB (STCLASS=STATIC);
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(TOP$)");
%F$DCB;
%B$TCB;
%B$ALT;
%XUR_INIT (ABORT=WEASEL_BREAK,BRKMSG=WEASEL_BRKMSG,PCB=P_PCB);
%EL$HDR(NAME=SL_RECORD_BUF,STCLASS=STATIC,HDRONLY=YES,FILE=FILENUM);
%ES$SECLOG(DCLNAME=NO,STCLASS=STATIC);
%XUD_UTS_EQU;
/**/
%EJECT;
        CALL XUR$INIT(XUR_INIT,P_PCB$);
        CALL XUR$SETDCBS(,DCBNUM(M$LO));
        /* The errmsg file is part of the run unit. But this RU may
           not always be run from the .X account, so we need to
           find out where we're coming from. Also reusing some
           variables to do this for convenience.                  */
        LMDCB$ = DCBADDR(%M$LM#);
        ERRMSG_UNFID.V.DCB# = %M$LM#;
        CALL M$UNFID(ERRMSG_UNFID);
        SL_SITE_NAME.L = CURDATE;
        CALL XUR$SETERRMSG(SL_SITE_NAME);
        CALL M$TIME(CUR_DATE);
        CALL M$TIME(CUR_TIME);
        SL_CURDATE = CURDATE;
        CALL XUD$UTS_DIFF_25TH (NDAYS, CURDATE, 0);
        NDAYS = NDAYS / %UTS_25TH_DAY#;
        CALL XUD$UTS_ADJ_25TH (SL_DEFAULT.START, 0, NDAYS * %UTS_25TH_DAY#);
        CALL XUD$UTS_ADJUST (SL_DEFAULT.STOP, SL_DEFAULT.START, %UTS_CSEC_DAY# - 1);
        SL_CONSTRAINTS = SL_DEFAULT;
        CALL M$MONINFO(FPT_MONINFO);
        SL_SITE_ID = VLR_SITEINFO.SITE_ID#;
        SL_SITE_NAME = VLR_SITEINFO.SITE_NAME#;
        SL_ENDFLAG = %NO;
        REMEMBER RET_LBL IN SL_ERR_RETURN;
        CALL M$INT(FPT_INT);
                                        /* CALL COMMAND DRIVER                */
        DO WHILE(NOT SL_ENDFLAG);
           IF SL_CHANGE_ACCOUNT THEN
           DO;
              CALL M$TIME(ANS_DATE);
              IF SUBSTR (ANSDATE,0,2) >= '78'
                THEN CALL CONCAT(NAMEBUF,':SECLOG19',ANSDATE);
                ELSE CALL CONCAT(NAMEBUF,':SECLOG20',ANSDATE);
              SL_OPEN_SECLOG.V.SHARE# = %ALL#;
              SL_VLP_SECLOG.NAME# = NAMEBUF;
              SL_M$SECLOG$ = DCBADDR(DCBNUM(M$SECLOG));
              CALL M$OPEN(SL_OPEN_SECLOG) ALTRET(OPEN_ERR);
              DO NEVER;                 /* OPEN ERROR HANDLING                */
OPEN_ERR:        CALL ERRMSG;
                 END;                   /* DO NEVER                           */
              CALL M$CLOSE(SL_CLOSE_SECLOG);
 
                                        /* LOOK FOR FIRST AVAIL. :SECLOG FILE */
              CALL M$OPEN(FIND_FIRST) ALTRET(NO_SECLOG_FILES);
              IF SL_M$SECLOG$->F$DCB.NAME#.L ~= LENGTHC( ':SECLOGyyyymmdd' )
                 THEN GOTO NO_SECLOG_FILES;
              NAMEBUF = SL_M$SECLOG$->F$DCB.NAME#.C;
              IF SUBSTR(NAMEBUF,0,7) ~= ':SECLOG' THEN GOTO NO_SECLOG_FILES;
              FIRST_DATE = SUBSTR(NAMEBUF,9,6);
              FIRST_SECLG.DATE_ = VECTOR(FIRST_DATE);
              CALL M$TIME(FIRST_SECLG) ALTRET(NO_SECLOG_FILES);
              CALL WRITE_IT(HI_VEC,VECTOR(NAMEBUF));
              SL_CHANGE_ACCOUNT = '0'B;
 
              DO NEVER;
NO_SECLOG_FILES: ;
                 CALL ERRMSG( %E$NO_SECLOG_FILES );
                 /*E* ERROR:   SL-E$NO_SECLOG_FILES-0
                      MESSAGE: The USE account contains no security log files
                 */
                 END;
              END;
              CALL XUR$GETCMD(SL_CMD,TOP$,VECTOR(PRMT)) ALTRET(PARSE_ERR);
              DO CASE(OUT$BLK.CODE);
               CASE(%END_CMD);
                 SL_ENDFLAG = %YES;
               CASE(%REPORT_CMD);
                 CALL REPORT;
               CASE(%SPAN_CMD);
                 CALL SPAN ALTRET(RET_LBL);
               CASE(%NULL_CMD);
               CASE(%USE_CMD);
                 IF OUT$BLK.NSUBLKS <= 0
                 THEN DO;
                    VLP_SYS.ACCT# = B$JIT.FACCN;
                    SL_CHANGE_ACCOUNT = '1'B;
                    END;
                 ELSE DO;
                    IF OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT > 8
                    THEN DO;
                       CALL ERRMSG(%E$BAD_ACCT);
                       /*E* ERROR:   SL-E$BAD_ACCT-0
                            MESSAGE: Bad account specification
                       */
                       SL_CHANGE_ACCOUNT = '0'B;
                       END;
                    ELSE DO;
                       VLP_SYS.ACCT# = OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
                       SL_CHANGE_ACCOUNT = '1'B;
                       END;
                    END;
               CASE(%TYPE_CMD);
                 SL_CONSTRAINTS.TYPES='0'B;
                 DO I = 0 TO OUT$BLK.NSUBLKS-1;
                    CODE=OUT$BLK.SUBLK$(I)->OUT$BLK.CODE;
                    INDX=CODE-%TYPE_LO;
                    SL_CONSTRAINTS.TYPES(INDX)=CODE;
                    END;
               CASE(%RESET_CMD);
                 IF OUT$BLK.NSUBLKS=0 OR OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%ALL
                 THEN DO;
                    SL_CONSTRAINTS=SL_DEFAULT;
                    VLP_SYS.ACCT#=':SYS';
                    SL_CHANGE_ACCOUNT='1'B;
                    END;
                 ELSE DO I=0 TO OUT$BLK.NSUBLKS-1;
                    DO CASE(OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
                     CASE(%USE);
                       VLP_SYS.ACCT#=':SYS';
                       SL_CHANGE_ACCOUNT='1'B;
                     CASE(%SPAN);
                       SL_CONSTRAINTS.START=SL_DEFAULT.START;
                       SL_CONSTRAINTS.STOP=SL_DEFAULT.STOP;
                     CASE(%TYPE);
                       SL_CONSTRAINTS.TYPES = SL_DEFAULT.TYPES;
                     END;
                    END;
               END;                     /* DO CASE                            */
RET_LBL:
           CALL CLOSEXSA;
           DO NEVER;                    /* PARSE ERROR HANDLING               */
PARSE_ERR:    SL_ERRCODE = PARSE_CODE;
              IF NOT SL_ERRCODE.MON
                 THEN SL_CPOS = P_PCB.HI_CHAR;
                 ELSE SL_ENDFLAG = %YES;
              IF SL_ERRCODE.FCG = '302522'O  /* 'XUR' */ AND SL_ERRCODE.CODE = 1
              THEN DO;
                 SL_ERRCODE = '231400000000'O;
                 IF SL_CPOS = 0
                 THEN DO;
                    SL_ERRCODE.CODE = %E$CMD_ERR;
                    SL_CPOS = -1;
                    /*E* ERROR:   SL-E$CMD_ERR-0
                         MESSAGE: Unknown command
                    */
                    END;
                 ELSE DO;
                    SL_ERRCODE.CODE = %E$SYNTAX_ERR;
                    /*E* ERROR:   SL-E$SYNTAX_ERR-0
                         MESSAGE: Syntax error
                    */
                    END;
                 END;                   /* IF FCG = 'XUR' AND CODE = 1        */
              IF SL_CPOS >= 0 THEN
                 CALL XUR$ERRPTR(SL_CPOS,DCBNUM(M$DO));
              SL_CPOS = -1;
              CALL XUR$ERRMSG(SL_ERRCODE,DCBNUM(M$SI),DCBNUM(M$DO));
              END;                      /* DO NEVER                           */
           END;                         /* DO WHILE NOT SL_ENDFLAG            */
        CALL M$EXIT;
%EJECT;
REPORT: PROC;
/**/
/* VARIABLES */
/**/
DCL LO_REASSIGNED BIT(1) ALIGNED STATIC INIT('0'B);
DCL TEXT$ PTR;
DCL TEXTBUF CHAR(132) STATIC INIT(' ');
DCL 1 TVEC_,
      2 BOUND UBIN(20) UNAL,
      2 * BIT(16),
      2 PTR$ PTR;
DCL TEMP_BUF CHAR(132) STATIC INIT(' ');
DCL TEMP_BUF2 CHAR(132);
DCL BUF_COUNT UBIN;
DCL DBUF2 CHAR(8) STATIC;
DCL TBUF2 CHAR(11) STATIC;
DCL LOC_UTS UBIN WORD STATIC;
DCL SYM$ PTR;
DCL M$LO$ PTR;
DCL I UBIN;
DCL K SBIN;
DCL SUM_CLAUSE_FLG BIT(1) ALIGNED;
DCL NUM_RECS SBIN;
DCL NUM_TYPES SBIN;
DCL TYPES(0:%MAX_TYPES) UBIN BYTE;
DCL RECORD_TYPE UBIN;
DCL TYPE_CNT(0:%MAX_TYPES) UBIN;
DCL COUNT UBIN WORD;
DCL REPORT_CODE UBIN;
DCL LO_ASN UBIN(9) STATIC;
DCL LO_RES CHAR(4) STATIC;
DCL SECLOG_DATE UBIN WORD STATIC;
DCL DAY_BUF CHAR(3) STATIC;
DCL EOF_FLAG BIT(1) ALIGNED;
DCL DATE_BUF CHAR(10) STATIC;
DCL TYPE_FMT CHAR(0) CONSTANT INIT(
'TYPES: %T%10P');
DCL SUM_FMT CHAR(0) CONSTANT INIT(
'%2/SUMMARY%2/TYPE  (MNEMONIC)%38-COUNT%/------------------------------------ -----%10P');
DCL SUM_ENTRY CHAR(0) CONSTANT INIT(
'%T%38-%2P%5D%10P');
DCL SUM_TOT  CHAR(0) CONSTANT INIT(
'%2/TOTAL: %D%10P');
DCL RAW_HDR CHAR(0) CONSTANT INIT(
'Security Log Listing for %2P%T from %3P%14.36.2U to %4P%14.36.2U%10P');
DCL SUM_HDR CHAR(0) CONSTANT INIT(
'Security Log Summary for %2P%T from %3P%14.36.2U to %4P%14.36.2U%10P');
DCL HDR_VEC_ VECTOR;
DCL DATE_HDR CHAR(0) CONSTANT INIT('%2/ ***** %A %2P%A ***** %/%10P');
DCL DATE_FMT BIT(72) STATIC INIT(VECTOR(DATE_HDR));
/**/
/* MACRO INVOCATIONS */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=RECORD_DATE,
           SOURCE=UTS,
           DEST=EXT,
           DATE=SL_DATE,
           TIME=SL_TIME,
           DAY=SL_DAY,
           TSTAMP=SL_LASTUTS,
           STCLASS=CONSTANT);
%FPT_TIME (FPTN=EXT_DATE,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           TSTAMP=SECLOG_DATE,
           DEST=EXT,
           DATE=DATE_BUF,
           DAY=DAY_BUF);
%FPT_TIME (FPTN=LOC_DATE,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           TSTAMP=LOC_UTS,
           DATE=DBUF2,
           TIME=TBUF2,
           DEST=LOCAL);
%FPT_OPEN (FPTN=REP_LO_UR,
           STCLASS=CONSTANT,
           DCB=M$LO,
            HDR=LO_HEADER,
           FUN=CREATE,
           SCRUB=YES,
           ORG=UR,
           REASSIGN=YES);
%FPT_OPEN (FPTN=REP_LO_CONSEC,
           STCLASS=CONSTANT,
           DCB=M$LO,
           FUN=CREATE,
           SCRUB=YES,
           ORG=CONSEC,
           REASSIGN=YES);
%FPT_OPEN (FPTN=REP_LO);
%FPT_CLOSE (FPTN=CLOSE_LO,
            STCLASS=CONSTANT,
            DISP=SAVE,
            DCB=M$LO);
%FPT_FID (NAME=LO_NAME,
          ACCT=LO_ACCT,
          PASS=LO_PASS,
          WSN=LO_WSN,
          SN=LO_SN,
          ASN=LO_ASN,
          RES=LO_RES,
          RESULTS=LO_RESULTS);
%VLP_NAME (FPTN=LO_NAME,LEN=31);
%VLP_ACCT (FPTN=LO_ACCT);
%VLP_PASS (FPTN=LO_PASS);
%VLP_WSN (FPTN=LO_WSN);
%VLP_SN (FPTN=LO_SN);
%VLR_FID (FPTN=LO_RESULTS);
%VLP_HDR (FPTN=LO_HEADER,
         STCLASS=STATIC,
         COUNT=107,
         HEADERHEIGHT=2,
         TITLE=' ',
         RESETPAGE=YES,
         LEN=106);
%EJECT;
        M$LO$ = DCBADDR(DCBNUM(M$LO));
        LO_REASSIGNED = %NO;
        IF M$LO$->F$DCB.FCD# THEN
           CALL M$CLOSE(CLOSE_LO);
        SUM_CLAUSE_FLG = %NO;
        REPORT_CODE = OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
        DO I = 1 TO OUT$BLK.NSUBLKS - 1;
           DO CASE(OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
            CASE(%SUM_CLAUSE);
              SUM_CLAUSE_FLG = %YES;
            CASE(%ON_CLAUSE);
              SYM$ = OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(1);
              FPT_FID.TEXTFID_ = VECTOR(OUT$SYM.TEXT);
              CALL M$FID(FPT_FID) ALTRET(FID_ERR);
              IF REPORT_CODE = %DATA THEN DO;
                 IF LO_ASN ~= %FILE# OR NOT LO_RESULTS.NAME THEN DO;
                    CALL ERRMSG(%E$FILE_REQUIRED);
                    GOTO NO_REPORT;
                    /*E* ERROR:  SL-E$FILE_REQUIRED-0
                         MESSAGE: Data reports must specify a disk file
                    */
                    END;
                 REP_LO = REP_LO_CONSEC;
                 END;
              ELSE REP_LO = REP_LO_UR;
              REP_LO.V_ = VECTOR(REP_LO.V);
              REP_LO.V.EXIST# = OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
              REP_LO.NAME_ = VECTOR(LO_NAME);
              REP_LO.ACCT_ = VECTOR(LO_ACCT);
              REP_LO.PASS_ = VECTOR(LO_PASS);
              REP_LO.SN_ = VECTOR(LO_SN);
              IF REPORT_CODE ~= %DATA THEN DO;
                 REP_LO.WSN_ = VECTOR(LO_WSN);
                 REP_LO.V.RES# = LO_RES;
                 REP_LO.V.ASN# = LO_ASN;
                 END;
              LO_REASSIGNED = %YES;
            END;                        /* CASE                   */
           END;                         /* DO I                               */
        IF REPORT_CODE ~= %DATA THEN DO;
           IF REPORT_CODE = %SUM
              THEN HDR_VEC_ = VECTOR(SUM_HDR);
              ELSE HDR_VEC_ = VECTOR(RAW_HDR);
           CALL WRITE_IT(HDR_VEC_,
                         VECTOR(SL_SITE_ID),
                         VECTOR(SL_SITE_NAME),
                         VECTOR(SL_CONSTRAINTS.START),
                         VECTOR(SL_CONSTRAINTS.STOP));
           END;
        IF LO_REASSIGNED THEN DO;
           IF REPORT_CODE ~= %DATA THEN DO;
              SL_OUTBUF=SUBSTR(SL_OUTBUF,1);
              CALL INSERT(LO_HEADER.TITL.TITLE#,0,100,SL_OUTBUF);
              CALL INSERT(LO_HEADER.TITL.TITLE#,101, ,'PAGE');
              LO_HEADER.TITL.L# = LENGTHC(LO_HEADER.TITL.TITLE#);
              END;
           CALL M$CLOSE(CLOSE_LO);
           CALL M$OPEN(REP_LO) ALTRET(OPN_ERR);
           END;
        SL_SAVE = SL_CONSTRAINTS;
        IF REPORT_CODE ~= %DATA THEN DO;
           TEXT$ = ADDR(TEXTBUF);
           BUF_COUNT = 0;
           DO I = 0 TO %MAX_TYPES;
              IF SL_CONSTRAINTS.TYPES(I) ~= 0 THEN DO;
                 IF BUF_COUNT > 0 THEN DO;
                    CALL INSERT(TEMP_BUF2,BUF_COUNT,2,', ');
                    BUF_COUNT = BUF_COUNT + 2;
                    END;
                 CALL TYPENAME(SL_CONSTRAINTS.TYPES(I),TEMP_BUF,COUNT);
                 CALL INSERT(TEMP_BUF2,BUF_COUNT,COUNT,SUBSTR(TEMP_BUF,0,COUNT));
                 BUF_COUNT = BUF_COUNT + COUNT;
                 END;
              END;
           CALL ADD_TEXTC(TEXT$,TEMP_BUF2,BUF_COUNT);
           TVEC_ = VECTOR(TEXTBUF);
           TVEC_.BOUND = BUF_COUNT;
           CALL WRITE_IT(VECTOR(TYPE_FMT),TVEC_);
           END;
        DO CASE(REPORT_CODE);
         CASE(%RAW,%DETAIL,%DATA);
           SL_BRKMSG = '1'B;
           /* SECLOG_DATE = ROUND (SL_CONSTRAINTS.START, DAY); */
           CALL XUD$UTS_DIFF_25TH (START_DATE, SL_CONSTRAINTS.START, 0);
           CALL XUD$UTS_ADJ_25TH (SECLOG_DATE, 0, (START_DATE / %UTS_25TH_DAY#) * %UTS_25TH_DAY#);
           STOP_DATE = SL_CONSTRAINTS.STOP;
           DO WHILE (SECLOG_DATE <= STOP_DATE);
              NUM_RECS = 0;
              NUM_TYPES = 0;
              CALL OPENXSA(SECLOG_DATE) ALTRET(NO_FILE);
              CALL M$TIME(EXT_DATE);
              EOF_FLAG = %NO;
              CALL PRECORDXSA(SL_CONSTRAINTS.START);
              DO WHILE(NOT EOF_FLAG);
                 CALL GETREC ALTRET(EOF_LBL);
                 IF NUM_RECS = 0
                 THEN CALL WRITE_IT(DATE_FMT,VECTOR(DAY_BUF),VECTOR(DATE_BUF));
                 NUM_RECS = NUM_RECS + 1;
                 IF SUM_CLAUSE_FLG THEN DO;
                    RECORD_TYPE = SL_RECORD_BUF.TYPE;
                    DO K = 1 TO NUM_TYPES;
                       IF TYPES(K) = RECORD_TYPE THEN DO;
                          TYPE_CNT(K) = TYPE_CNT(K) + 1;
                          GOTO FOUND_TYP;
                          END;             /* IF                                 */
                       END;                /* DO K                               */
                    NUM_TYPES = NUM_TYPES + 1;
                    TYPES(NUM_TYPES) = RECORD_TYPE;
                    TYPE_CNT(NUM_TYPES) = 1;
FOUND_TYP:;
                    END;
                 CALL M$TIME(RECORD_DATE);
                 CALL REPORT_ONE ALTRET(EOF_LBL);
                 DO NEVER;
EOF_LBL:            EOF_FLAG = %YES;
                    END;
                 END;                   /* DO WHILE NOT EOF_FLG   */
NO_FILE:
              CALL XUD$UTS_ADJ_25TH (SECLOG_DATE, SECLOG_DATE, %UTS_25TH_DAY#);
              END;                      /* DO WHILE (SECLOG_DATE <= STOP)     */
           CALL CLOSEXSA;
           SL_LASTTYPE = -1;
           IF SUM_CLAUSE_FLG THEN
              GOTO PRINT_SUM;
         CASE(%SUM);
           SL_BRKMSG = '0'B;
           NUM_TYPES = 0;
           NUM_RECS = 0;
           /* SECLOG_DATE = ROUND (SL_CONSTRAINTS.START, DAY); */
           CALL XUD$UTS_DIFF_25TH (START_DATE, SL_CONSTRAINTS.START, 0);
           CALL XUD$UTS_ADJ_25TH (SECLOG_DATE, 0, (START_DATE * %UTS_25TH_DAY#) / %UTS_25TH_DAY#);
           STOP_DATE = SL_CONSTRAINTS.STOP;
           DO WHILE (SECLOG_DATE <= STOP_DATE);
              CALL OPENXSA(SECLOG_DATE) ALTRET(NO_FILE2);
              EOF_FLAG = %NO;
              CALL PRECORDXSA(SL_CONSTRAINTS.START);
              DO WHILE(NOT EOF_FLAG);
                 CALL GETREC ALTRET(EOF);
                 NUM_RECS = NUM_RECS + 1;
                 RECORD_TYPE = SL_RECORD_BUF.TYPE;
                 DO K = 1 TO NUM_TYPES;
                    IF TYPES(K) = RECORD_TYPE THEN DO;
                       TYPE_CNT(K) = TYPE_CNT(K) + 1;
                       GOTO FOUND_TYPE;
                       END;             /* IF                                 */
                    END;                /* DO K                               */
                 NUM_TYPES = NUM_TYPES + 1;
                 TYPES(NUM_TYPES) = RECORD_TYPE;
                 TYPE_CNT(NUM_TYPES) = 1;
FOUND_TYPE:      ;
                 DO NEVER;
EOF:                EOF_FLAG = %YES;
                    END;                /* DO NEVER                           */
                 END;                   /* DO WHILE NOT EOF_FLAG              */
NO_FILE2:
              CALL XUD$UTS_ADJ_25TH (SECLOG_DATE, SECLOG_DATE, %UTS_25TH_DAY#);
              END;                      /* DO WHILE (SECLOG_DATE <= STOP)     */
           CALL CLOSEXSA;
PRINT_SUM:;
           IF NUM_TYPES > 0 THEN DO;
              CALL WRITE_IT(VECTOR(SUM_FMT));
              DO I = 1 TO NUM_TYPES;
                 TEXT$ = ADDR(TEXTBUF);
                 CALL TYPENAME(TYPES(I),TEMP_BUF,COUNT);
                 CALL ADD_TEXTC(TEXT$,TEMP_BUF,COUNT);
                 TVEC_ = VECTOR(TEXTBUF);
                 TVEC_.BOUND = COUNT;
                 CALL WRITE_IT(VECTOR(SUM_ENTRY),
                   TVEC_,
                   VECTOR(TYPE_CNT(I)));
                 END;                   /* DO I                               */
              END;                      /* IF NUM_TYPES > 0                   */
           CALL WRITE_IT(VECTOR(SUM_TOT),VECTOR(NUM_RECS));
         END;                           /* CASE REPORT CODE                   */
        SL_CONSTRAINTS = SL_SAVE;
        CALL M$CLOSE(CLOSE_LO);
        DO NEVER;
FID_ERR: ;
OPN_ERR:
           CALL ERRMSG;
           END;                         /* DO NEVER                           */
NO_REPORT:
        IF LO_REASSIGNED THEN
           CALL M$OPEN(OPEN_LO) ALTRET(OPN_ERR);
        RETURN;
%EJECT;
TYPENAME: PROC(TYPE,TEXT,COUNT);
/**/
DCL TYPE UBIN BYTE;
DCL TEXT CHAR(63);
DCL COUNT UBIN WORD;
/**/
%EQU ALL_TYPES        = 'ALL';
%EQU FILE_ACCESS      = 'FILE ACCESS';
%EQU PRIV_CHANGE      = 'PRIVILEGE CHANGE';
%EQU MON_SRV          = 'MONITOR SERVICE';
%EQU SYS_ACCESS       = 'SYSTEM ACCESS';
%EQU SYS_EXIT         = 'SYSTEM EXIT';
%EQU ARES_BYPASS      = 'ARES CHECKS BYPASSED';
DCL 1 TBL(0:%MAX_TYPES) CONSTANT ALIGNED,
      2 TYPE UBIN BYTE UNAL INIT(%ALL,
                                 %EL_FILE_ACCESS,
                                 %EL_PRIV_CHANGE,
                                 %EL_MON_SRV,
                                 %EL_SYS_ACCESS,
                                 %EL_SYS_EXIT,
                                 %EL_ARES_BYPASS),
      2 TEXT CHAR(23)  UNAL INIT(%ALL_TYPES,
                                 %FILE_ACCESS,
                                 %PRIV_CHANGE,
                                 %MON_SRV,
                                 %SYS_ACCESS,
                                 %SYS_EXIT,
                                 %ARES_BYPASS),
      2 COUNT UBIN WORD     INIT(%(LENGTHC(ALL_TYPES)),
                                 %(LENGTHC(FILE_ACCESS)),
                                 %(LENGTHC(PRIV_CHANGE)),
                                 %(LENGTHC(MON_SRV)),
                                 %(LENGTHC(SYS_ACCESS)),
                                 %(LENGTHC(SYS_EXIT)),
                                 %(LENGTHC(ARES_BYPASS)) );
DCL INDX SBIN;
/**/
     DO INDX = 0 TO %MAX_TYPES;
        IF TYPE = TBL.TYPE(INDX) THEN DO;
           TEXT = TBL.TEXT(INDX);
           COUNT = TBL.COUNT(INDX);
           RETURN;
           END;
        END;
     CALL BINCHAR(SUBSTR(TEXT,0,3),TYPE);
     COUNT = 3;
     RETURN;
END TYPENAME;
%EJECT;
ADD_TEXTC: PROC(PTR$,TXT,SIZE);
/**/
DCL PTR$ PTR;
DCL TXT CHAR(SIZE);
DCL SIZE SBIN;
/**/
DCL 1 TIMEBUF BASED(PTR$),
      2 N UBIN BYTE UNAL,
      2 C CHAR(SIZE);
/**/
     TIMEBUF.N = SIZE;
     TIMEBUF.C = TXT;
     PTR$ = PINCRC(PTR$,SIZE+1);
     RETURN;
END ADD_TEXTC;
%EJECT;
REPORT_ONE: PROC ALTRET;
/**/
/* SUBS */
/**/
%SUB LOGON_DET_HDR1  = 'ATIME  SEQ#    REASON  G             LOGON               MODE OMODE';
%SUB LOGON_DET_UND1  = 'A----- ------ -------- - ------------------------------- ---- -----';
%SUB LOGON_DET_HDR2  = 'A                                  PRIV        PPRIV';
%SUB LOGON_DET_UND2  = 'A----------------------------  ------------ ------------';
%SUB LOGON_DET_HDR3  = 'A     IMMEDIATE PREDECESSOR';
%SUB LOGON_DET_HDR4  = 'AMODE SYSID    ACCN      UNAME';
%SUB LOGON_DET_UND4  = 'A---- ------ -------- ------------';
%SUB COMMON_DET_HDR1 = 'ATIME  SEQ#    REASON  G MODE USER#  SYSID    ACCN       UNAME';
%SUB TPEXIT_DET_HDR1 = 'ATIME  SEQ#    REASON  G MODE USER#  SYSID   STATION     LOGON';
%SUB COMMON_DET_UND1 = 'A----- ------ -------- - ---- ------ ------ -------- ------------';
%SUB COMMON_DET_HDR2 = 'A FACCN     WOO        PRIV         PPRIV    PRIV ACTIVE    PRIV PRC';
%SUB COMMON_DET_UND2 = 'A-------- -------- ------------ ------------ ------------ ------------';
%SUB COMMON_DET_HDR3 = 'ADOMAIN  PROC SN             PROC NAME              PROC ACCT  OMODE';
%SUB COMMON_DET_UND3 = 'A------  --------  -------------------------------  ---------  -----';
%SUB TPEXIT_DET_HDR3 = 'ACOMGROUP:  SN                  NAME                  ACCT';
%SUB TPEXIT_DET_UND3 = 'A        --------  -------------------------------  ---------';
%SUB FILE_ACCESS_HDR5= 'AFILE';
%SUB FILE_ACCESS_UND5= 'A----------------';
%SUB ARES_BYPASS_HDR5= 'AMODEL';
%SUB LOGON_RAW_HDR   = 'FEX  PORT  LOGON                            PASSWORD';
%SUB LOGON_RAW_UND   = '---  ----  -------------------------------  --------';
%SUB COMMON_RAW_HDR  = 'ATIME   REASON  G SYSID    ACCN      UNAME    ';
%SUB COMMON_RAW_UND  = 'A----- -------- - ------ -------- ------------';
/**/
/* CONSTANT DATA */
/**/
DCL SL_OUTBUF$ PTR CONSTANT INIT(ADDR(SL_OUTBUF));
DCL HDR(0:%(MAX_TYPES-1)) CHAR(37) CONSTANT INIT(
                       'B<<<< FILE ACCESS >>>> (501)',
                       'B<<<< PRIVILEGE CHANGE >>>> (502)',
                       'B<<<< MONITOR SERVICE >>>> (503)',
                       'B<<<< SYSTEM ACCESS >>>> (504)',
                       'B<<<< SYSTEM EXIT >>>> (505)',
                       'B<<<< ARES CHECKS BYPASSED >>>> (506)');
DCL RAW_REST_HDR(0:%(MAX_TYPES-1)) CHAR(16) CONSTANT INIT(
            'FILE',
            'PRIVS REQUESTED',
            'PMME TYPE',
            ' ',                /* logon done otherwise */
            'PRIV ACTIVE',
            'MODEL');
DCL RAW_REST_UND(0:%(MAX_TYPES-1)) CHAR(16) CONSTANT INIT(
            '----------------',
            '---------------',
            '----------',
            ' ',
            '------------',
            '----------------');
DCL DET_DEV_HDR(0:7) CHAR(28) CONSTANT INIT(
               'FEX  PORT  LEV  SUB   SUBSUB',
               'DEVICE TNAME',
               'ORIGINATOR SYSID',
               'FEX  PORT  LEV  SUB   SUBSUB',
               ' TP',
               ' CG',
               ' RES',
               'FEX  PORT  LEV  SUB  SUBSUB');
DCL DET_TYPE_HDR(0:%(MAX_TYPES-1)) CHAR(24) CONSTANT INIT(
               'FUN ASN  FFLG   RES',
               'PRIVS REQUESTED',
               'PRIVS REQUIRED PMME TYPE',
               ' ',
               ' ',
               'FUN ASN');
DCL DET_TYPE_UND(0:%(MAX_TYPES-1)) CHAR(26) CONSTANT INIT(
               '--- ---- ------ ----',
               '---------------',
               '-------------- -----------',
               ' ',
               ' ',
               '--- ----');
DCL SYS_ACCESS_REASONS(0:4) CHAR(8) CONSTANT INIT(' ',
                                                  '   ALL  ',
                                                  'BAD PASS',
                                                  'NO LOGON',
                                                  '  JUNK  ');
DCL SYS_EXIT_REASONS(0:1)   CHAR(8) CONSTANT INIT(' ',
                                                  '   ALL  ');
DCL PRIV_CHNG_REASONS(0:2)  CHAR(8) CONSTANT INIT(' ',
                                                  ' DENIED ',
                                                  ' GRANTED');
DCL FILE_ACCESS_REASONS(0:2) CHAR(8) CONSTANT INIT(' ',
                                                  ' DENIED ',
                                                  'PRIV USR');
DCL REASON$(0:%(MAX_TYPES-1)) PTR CONSTANT INIT(
                                   ADDR(FILE_ACCESS_REASONS),
                                   ADDR(PRIV_CHNG_REASONS),
                                   ADDR(PRIV_CHNG_REASONS),
                                   ADDR(SYS_ACCESS_REASONS),
                                   ADDR(SYS_EXIT_REASONS),
                                   ADDR(FILE_ACCESS_REASONS));
DCL MODES(0:7) CHAR(4) ALIGNED CONSTANT INIT(' ',
                                    ' BA ',
                                    ' GH ',
                                    ' INT',
                                    ' TP ',
                                    ' CG ',
                                    ' RES',
                                    ' TP ');
DCL DOMAINS(0:7) CHAR(6) CALIGNED CONSTANT INIT(' ',
                                    '      ',
                                    '      ',
                                    '      ',
                                    '  CP  ',
                                    '  DB  ',
                                    '  ASL ',
                                    ' USER ');
DCL FILE_FUN(0:3) CHAR(3) CONSTANT INIT(' ',
                                    'UPD',
                                    'IN',
                                    'CR');
DCL FILE_ASN(0:9) CHAR(4) CONSTANT INIT(' ',
                                    'FILE',
                                    'TAPE',
                                    'DEV',
                                    'CG',
                                    'STRM',
                                    'T@D',
                                    'FMD',
                                    'FPRG',
                                    'FPAP');
DCL 1 MONSER_TBL ALIGNED CONSTANT,
      2 FCG$(0:%MAX_FCG#) PTR INIT(ADDR(JS_TBL),   /*  0 - JS  */
                                   ADDR(NIL),      /*  1 - UE  */
                                   ADDR(UM_TBL),   /*  2 - UM  */
                                   ADDR(MM_TBL),   /*  3 - MM  */
                                   ADDR(NIL),      /*  4 - FM1 */
                                   ADDR(NIL),      /*  5 - FM2 */
                                   ADDR(FM3_TBL),  /*  6 - FM3 */
                                   ADDR(TD_TBL),   /*  7 - TD  */
                                   ADDR(NIL),      /*  8 - KC  */
                                   ADDR(NIL),      /*  9 - OT  */
                                   ADDR(OC_TBL),   /* 10 - OC  */
                                   ADDR(NIL),      /* 11 - KL  */
                                   ADDR(PH_TBL),   /* 12 - PH  */
                                   ADDR(FR_TBL),   /* 13 - FR  */
                                   ADDR(KI_TBL),   /* 14 - KI  */
                                   ADDR(NIL)*0),   /* 15 - FO  */
                                                   /* new ones? */
      2 CNT (0:%MAX_FCG#) UBIN BYTE UNAL INIT(1,   /*  0 - JS  */
                                              0,   /*  1 - UE  */
                                              3,   /*  2 - UM  */
                                              11,  /*  3 - MM  */
                                              0,   /*  4 - FM1 */
                                              0,   /*  5 - FM2 */
                                              1,   /*  6 - FM3 */
                                              8,   /*  7 - TD  */
                                              0,   /*  8 - KC  */
                                              0,   /*  9 - OT  */
                                              1,   /* 10 - OC  */
                                              0,   /* 11 - KL  */
                                              4,   /* 12 - PH  */
                                              1,   /* 13 - FR  */
                                              3,   /* 14 - KI  */
                                              0*0);/* 15 - FO  */
                                                   /* new ones? */
/**/
/* FCG tables */
/**/
DCL 1 JS_TBL CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$SCREECH#),
      2 TEXT    CHAR(11)  UNAL INIT('M$SCREECH');
 
DCL 1 UM_TBL(0:2) CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$SPRIV#,
                                    %C$RUE#,
                                    %C$GJOB#),
      2 TEXT    CHAR(11)  UNAL INIT('M$SPRIV',
                                    'M$RUE',
                                    'M$GJOB');
 
DCL 1 MM_TBL(0:10) CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$STLPP#,
                                    %C$RSPP#,
                                    %C$CVM#,
                                    %C$SMPRT#,
                                    %C$SSC#,
                                    %C$SAD#,
                                    %C$BADPP#,
                                    %C$GOODPP#,
                                    %C$GBPL#,
                                    %C$MPL#,
                                    %C$UMPL#),
      2 TEXT    CHAR(11)  UNAL INIT('M$STLPP',
                                    'M$RSPP',
                                    'M$CVM',
                                    'M$SMPRT',
                                    'M$SSC',
                                    'M$SAD',
                                    'M$BADPP',
                                    'M$GOODPP',
                                    'M$GBPL',
                                    'M$MPL',
                                    'M$UMPL');
 
DCL 1 FM3_TBL CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$MADMUCK#),
      2 TEXT    CHAR(11)  UNAL INIT('M$MADMUCK');
 
DCL 1 TD_TBL(0:7) CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$RDSYSLOG#,
                                    %C$WRSYSLOG#,
                                    %C$TDOPEN#,
                                    %C$TDCLOSE#,
                                    %C$TDIO#,
                                    %C$TDREQCPU#,
                                    %C$IOQ#,
                                    %C$SYSCON#),
      2 TEXT    CHAR(11)  UNAL INIT('M$RDSYSLOG',
                                    'M$WRSYSLOG',
                                    'M$TDOPEN',
                                    'M$TDCLOSE',
                                    'M$TDIO',
                                    'M$TDREQCPU',
                                    'M$IOQ',
                                    'M$SYSCON');
 
DCL 1 OC_TBL CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$OCMSG#),
      2 TEXT    CHAR(11)  UNAL INIT('M$OCMSG');
 
DCL 1 PH_TBL(0:3) CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$SMOUSE#,
                                    %C$XMOUSE#,
                                    %C$GETMOUSE#,
                                    %C$GETPM#),
      2 TEXT    CHAR(11)  UNAL INIT('M$SMOUSE',
                                    'M$XMOUSE',
                                    'M$GETMOUSE',
                                    'M$GETPM');
 
DCL 1 FR_TBL CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$LIMIT#),
      2 TEXT   CHAR(11)  UNAL INIT('M$LIMIT');
 
DCL 1 KI_TBL(0:2) CONSTANT ALIGNED,
      2 CODE    UBIN BYTE UNAL INIT(%C$FEBOOT#,
                                    %C$FEDUMP#,
                                    %C$FECTL#),
      2 TEXT    CHAR(11)  UNAL INIT('M$FEBOOT',
                                    'M$FEDUMP',
                                    'M$FECTL');
/**/
/* BASED STRUCTURES */
/**/
DCL REASONS(0:0) CHAR(8) BASED;
DCL 1 FCG_TBL(0:0) ALIGNED BASED,
      2 CODE    UBIN BYTE UNAL,
      2 TEXT    CHAR(11)  UNAL;
DCL 1 COMMON_RAW_REC BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 TIME CHAR(5) UNAL,
      2 * CHAR(1) UNAL,
      2 REA  CHAR(8) UNAL,
      2 * CHAR(1) UNAL,
      2 GRANTED CHAR(1) UNAL,
      2 * CHAR(1) UNAL,
      2 SYSID CHAR(6) UNAL,
      2 * CHAR(1) UNAL,
      2 REST CHAR(72) UNAL,
      2 ACCESS REDEF REST,
        3 FEX CHAR(3) UNAL,
        3 *   CHAR(2) UNAL,
        3 PORT CHAR(4) UNAL,
        3 *   CHAR(2) UNAL,
        3 LOGON CHAR(31) UNAL,
        3 *   CHAR(2) UNAL,
        3 PW    CHAR(28) UNAL,
      2 OTHERS REDEF REST,
        3 ACCN  CHAR(9)  UNAL,
        3 UNAME CHAR(13) UNAL,
        3 FILE  CHAR(50) UNAL,
        3 PRIV_CHNG REDEF FILE,
          4 *     CHAR(2)  UNAL,
          4 PRIV  CHAR(12) UNAL,
          4 *     CHAR(36) UNAL,
        3 MON_SRV REDEF FILE,
          4 PMME  CHAR(50) UNAL,
        3 EX REDEF FILE,
          4 PRIV  CHAR(12) UNAL,
          4 *     CHAR(38) UNAL;
DCL 1 LOGON_DET_REC1 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 TIME CHAR(5) UNAL,
      2 *    CHAR(1) UNAL,
      2 SEQ# CHAR(6) UNAL,
      2 *    CHAR(1) UNAL,
      2 REA  CHAR(8) UNAL,
      2 *    CHAR(1) UNAL,
      2 GRANTED CHAR(1) UNAL,
      2 *    CHAR(1) UNAL,
      2 LOGON CHAR(31) UNAL,
      2 *    CHAR(1) UNAL,
      2 MODE CHAR(4) UNAL,
      2 *    CHAR(1) UNAL,
      2 OMODE CHAR(4) UNAL;
DCL 1 LOGON_DET_REC2 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 DEV CHAR(28) UNAL,
      2 TSLINE REDEF DEV,
        3 FEX CHAR(3) UNAL,
        3 *   CHAR(2) UNAL,
        3 PORT CHAR(4) UNAL,
        3 *   CHAR(2) UNAL,
        3 LEV CHAR(3) UNAL,
        3 *   CHAR(1) UNAL,
        3 SUB CHAR(6) UNAL,
        3 *   CHAR(1) UNAL,
        3 SUBSUB CHAR(6) UNAL,
      2 BATCH REDEF DEV,
        3 DEVICE CHAR(4) UNAL,
        3 *   CHAR(1) UNAL,
        3 TNAME  CHAR(6) UNAL,
        3 *   CHAR(17) UNAL,
      2 GHOST REDEF DEV,
        3 *   CHAR(5) UNAL,
        3 SYSID CHAR(6) UNAL,
        3 *   CHAR(17) UNAL,
      2 *    CHAR(2) UNAL,
      2 PRIV CHAR(12) UNAL,
      2 *    CHAR(1) UNAL,
      2 PPRIV CHAR(12) UNAL;
DCL 1 LOGON_DET_REC3 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 MODE CHAR(4) UNAL,
      2 * CHAR(1) UNAL,
      2 SYSID CHAR(6) UNAL,
      2 * CHAR(1) UNAL,
      2 ACCN CHAR(8) UNAL,
      2 * CHAR(1) UNAL,
      2 UNAME CHAR(12) UNAL;
DCL 1 COMMON_DET_REC1 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 TIME CHAR(5) UNAL,
      2 * CHAR(1) UNAL,
      2 SEQ# CHAR(6) UNAL,
      2 * CHAR(1) UNAL,
      2 REA  CHAR(8) UNAL,
      2 * CHAR(1) UNAL,
      2 GRANTED CHAR(1) UNAL,
      2 * CHAR(1) UNAL,
      2 MODE CHAR(4) UNAL,
      2 * CHAR(2) UNAL,
      2 DOT CHAR(1) UNAL,
      2 USER# CHAR(3) UNAL,
      2 * CHAR(2) UNAL,
      2 SYSID CHAR(6) UNAL,
      2 * CHAR(1) UNAL,
      2 ACCN  CHAR(8) UNAL,
      2 * CHAR(1) UNAL,
      2 UNAME CHAR(12) UNAL;
DCL 1 COMMON_DET_REC2 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 FACCN CHAR(8) UNAL,
      2 * CHAR(1) UNAL,
      2 WOO   CHAR(8) UNAL,
      2 * CHAR(1) UNAL,
      2 PRIV  CHAR(12) UNAL,
      2 * CHAR(1) UNAL,
      2 PPRIV CHAR(12) UNAL,
      2 * CHAR(1) UNAL,
      2 PRIV_ACTIVE CHAR(12) UNAL,
      2 * CHAR(1) UNAL,
      2 PRIV_PRC CHAR(12) UNAL;
DCL 1 COMMON_DET_REC3 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 DOMAYN CHAR(6) UNAL,
      2 * CHAR(2) UNAL,
      2 PROC_SN CHAR(8) UNAL,
      2 * CHAR(2) UNAL,
      2 PROC_NAME CHAR(31) UNAL,
      2 * CHAR(2) UNAL,
      2 PROC_ACCT CHAR(8) UNAL,
      2 * CHAR(3) UNAL,
      2 OMODE CHAR(4) UNAL;
DCL 1 COMMON_DET_REC4 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 DEV CHAR(28) UNAL,
      2 TSLINE REDEF DEV,
        3 FEX CHAR(3) UNAL,
        3 *   CHAR(2) UNAL,
        3 PORT CHAR(4) UNAL,
        3 *   CHAR(2) UNAL,
        3 LEV CHAR(3) UNAL,
        3 *   CHAR(1) UNAL,
        3 SUB CHAR(6) UNAL,
        3 *   CHAR(1) UNAL,
        3 SUBSUB CHAR(6) UNAL,
      2 BATCH REDEF DEV,
        3 DEVICE CHAR(4) UNAL,
        3 *   CHAR(1) UNAL,
        3 TNAME  CHAR(6) UNAL,
        3 *   CHAR(17) UNAL,
      2 GHOST REDEF DEV,
        3 *   CHAR(5) UNAL,
        3 SYSID CHAR(6) UNAL,
        3 *   CHAR(17) UNAL,
      2 * CHAR(2) UNAL,
      2 REST CHAR(26) UNAL,
      2 FILE REDEF REST,
        3 FUN  CHAR(3) UNAL,
        3 *    CHAR(1) UNAL,
        3 ASN  CHAR(4) UNAL,
        3 *    CHAR(1) UNAL,
        3 FFLG CHAR(6) UNAL,
        3 *    CHAR(1) UNAL,
        3 RES  CHAR(4) UNAL,
        3 *    CHAR(6) UNAL,
      2 PRIV_CHNG REDEF REST,
        3 *    CHAR(2) UNAL,
        3 PRIV CHAR(12) UNAL,
        3 *    CHAR(12) UNAL,
      2 MON_SRV REDEF REST,
        3 *    CHAR(1) UNAL,
        3 PRIV CHAR(12) UNAL,
        3 *    CHAR(2) UNAL,
        3 PMME CHAR(11) UNAL;
DCL 1 FILE_ACCESS_REC5 BASED(SL_OUTBUF$),
      2 VFC CHAR(1) UNAL,
      2 FILE CHAR(50) UNAL;
/**/
/* STATIC DATA */
/**/
%FPT_UNFID(FPTN=FPT_UNFID,
           ACCT=SL_RECORD_BUF.FILE.ACCT,
           ASN =SL_RECORD_BUF.FILE.ASN,
           NAME=SL_RECORD_BUF.FILE.NAME#,
           RES =SL_RECORD_BUF.FILE.RES,
           SN  =FILE_SN);
%VLP_SN(FPTN=FILE_SN);
%FPT_WRITE(FPTN=WRITE_RECORD,
           DCB=M$LO,
           BUF=SL_OUTBUF,
           VFC=YES);
/**/
/* AUTO DATA */
/**/
DCL FCG$ PTR;
DCL PASS_FLG BIT(1) ALIGNED;
DCL PRINT_HDR BIT(1) ALIGNED;
DCL I UBIN;
DCL PMME UBIN HALF ALIGNED;
DCL 1 PMME1 REDEF PMME ALIGNED,
      2 FCG UBIN(6) UNAL,
      2 CODE UBIN(12) UNAL;
DCL NUMBER UBIN;
%EJECT;
  I = SL_RECORD_BUF.TYPE - %TYPE_LO - 1;
  IF SL_LASTTYPE ~= SL_RECORD_BUF.TYPE THEN DO;
     IF REPORT_CODE = %RAW THEN DO;
        SL_OUTBUF = 'A';
        CALL WRITE_REC ALTRET(WRITE_ERR);
        END;
     SL_OUTBUF = HDR(I);
     CALL WRITE_REC ALTRET(WRITE_ERR);
     PRINT_HDR = %YES;
     SL_LASTTYPE = SL_RECORD_BUF.TYPE;
     END;
  ELSE PRINT_HDR = %NO;
  DO CASE(REPORT_CODE);
     CASE(%RAW);
       IF PRINT_HDR THEN DO;
          SL_OUTBUF = %COMMON_RAW_HDR;
          IF SL_RECORD_BUF.TYPE = %EL_SYS_ACCESS THEN
             COMMON_RAW_REC.REST = %LOGON_RAW_HDR;
          ELSE COMMON_RAW_REC.OTHERS.FILE = RAW_REST_HDR(I);
          CALL WRITE_REC ALTRET(WRITE_ERR);
          SL_OUTBUF = %COMMON_RAW_UND;
          IF SL_RECORD_BUF.TYPE = %EL_SYS_ACCESS THEN
             COMMON_RAW_REC.REST = %LOGON_RAW_UND;
          ELSE COMMON_RAW_REC.OTHERS.FILE = RAW_REST_UND(I);
          CALL WRITE_REC ALTRET(WRITE_ERR);
          END;
       COMMON_RAW_REC.VFC = 'A';
       COMMON_RAW_REC.TIME = SL_TIME;
       IF SL_RECORD_BUF.GRANTED THEN
          COMMON_RAW_REC.GRANTED = 'Y';
       ELSE COMMON_RAW_REC.GRANTED = 'N';
       NUMBER=SL_RECORD_BUF.SYSID;
       CALL DECIMAL(COMMON_RAW_REC.SYSID,6,NUMBER);
       COMMON_RAW_REC.REA = REASON$(I)->REASONS(SL_RECORD_BUF.REASON);
       DO CASE(SL_RECORD_BUF.TYPE);
         CASE(%EL_SYS_ACCESS);
           IF SL_RECORD_BUF.LOGON.L > 0 THEN DO;
              COMMON_RAW_REC.ACCESS.LOGON = SL_RECORD_BUF.LOGON.C;
              COMMON_RAW_REC.ACCESS.PW = ' ';
              END;
           ELSE DO;
              COMMON_RAW_REC.ACCESS.LOGON = SL_RECORD_BUF.ACCN;
              CALL INDEX(I,' ',COMMON_RAW_REC.ACCESS.LOGON);
              CALL INSERT(COMMON_RAW_REC.ACCESS.LOGON,I,13,',',
                          SL_RECORD_BUF.UNAME);
              COMMON_RAW_REC.ACCESS.PW = SL_RECORD_BUF.PASSWORD;
              END;
              NUMBER = SL_RECORD_BUF.TSLINE.FEX;
              CALL DECIMAL(COMMON_RAW_REC.ACCESS.FEX,3,NUMBER);
              CALL HEX(2,SL_RECORD_BUF.TSLINE.PORT,4,
                          COMMON_RAW_REC.ACCESS.PORT);
         CASE(ELSE);
           COMMON_RAW_REC.OTHERS.ACCN = SL_RECORD_BUF.ACCN;
           COMMON_RAW_REC.OTHERS.UNAME = SL_RECORD_BUF.UNAME;
           DO CASE(SL_RECORD_BUF.TYPE);
             CASE(%EL_FILE_ACCESS,%EL_ARES_BYPASS);
               FILE_SN.SN#(0) = SL_RECORD_BUF.FILE.SN;
               FPT_UNFID.TEXTFID_=VECTOR(COMMON_RAW_REC.OTHERS.FILE);
               CALL M$UNFID(FPT_UNFID);
             CASE(%EL_PRIV_CHANGE);
               CALL OCTAL(36,SL_RECORD_BUF.PRIVS_REQUIRED,12,
                          COMMON_RAW_REC.OTHERS.PRIV_CHNG.PRIV);
             CASE(%EL_MON_SRV);
               PMME = SL_RECORD_BUF.PMME_TYPE;
               FCG$ = MONSER_TBL.FCG$(PMME1.FCG);
    PMME_LOOP1:
               DO I = 0 TO MONSER_TBL.CNT(PMME1.FCG)-1;
                  IF PMME1.CODE = FCG$->FCG_TBL.CODE(I) THEN DO;
                     COMMON_RAW_REC.OTHERS.MON_SRV.PMME = FCG$->FCG_TBL.TEXT(I);
                     EXIT PMME_LOOP1;
                     END;
                  END;
             CASE(%EL_SYS_EXIT);
               IF SL_RECORD_BUF.SYSID=0 AND SL_RECORD_BUF.MODE=%M_TP# THEN
                  COMMON_RAW_REC.SYSID = ' CGTRM';
               ELSE CALL OCTAL(36,SL_RECORD_BUF.PRIV_ACTIVE,12,
                          COMMON_RAW_REC.OTHERS.EX.PRIV);
             END;
         END;
       CALL WRITE_REC ALTRET(WRITE_ERR);
     CASE(%DETAIL);
       DO CASE(SL_RECORD_BUF.TYPE);
         CASE(%EL_SYS_ACCESS);
           SL_OUTBUF = %LOGON_DET_HDR1;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %LOGON_DET_UND1;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           LOGON_DET_REC1.VFC = 'B';
           LOGON_DET_REC1.TIME = SL_TIME;
           NUMBER = SL_RECORD_BUF.SEQ_NUM;
           CALL DECIMAL(LOGON_DET_REC1.SEQ#,6,NUMBER);
           LOGON_DET_REC1.REA = REASON$(I)->REASONS(SL_RECORD_BUF.REASON);
           IF SL_RECORD_BUF.GRANTED THEN
              LOGON_DET_REC1.GRANTED = 'Y';
           ELSE LOGON_DET_REC1.GRANTED = 'N';
           IF SL_RECORD_BUF.LOGON.L > 0 THEN
              LOGON_DET_REC1.LOGON = SL_RECORD_BUF.LOGON.C;
           ELSE DO;
              LOGON_DET_REC1.LOGON = SL_RECORD_BUF.ACCN;
              CALL INDEX(I,' ',LOGON_DET_REC1.LOGON);
              CALL INSERT(LOGON_DET_REC1.LOGON,I,13,',',
                          SL_RECORD_BUF.UNAME);
              CALL INDEX(I,' ',LOGON_DET_REC1.LOGON);
              CALL INSERT(LOGON_DET_REC1.LOGON,I,9,',',
                          SL_RECORD_BUF.PASSWORD);
              END;
           LOGON_DET_REC1.MODE = MODES(SL_RECORD_BUF.MODE);
           LOGON_DET_REC1.OMODE = MODES(SL_RECORD_BUF.ORIG_MODE);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %LOGON_DET_HDR2;
           IF SL_RECORD_BUF.ORIG_MODE = 0 THEN
              LOGON_DET_REC2.DEV = DET_DEV_HDR(SL_RECORD_BUF.MODE);
           ELSE
              LOGON_DET_REC2.DEV = DET_DEV_HDR(SL_RECORD_BUF.ORIG_MODE);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %LOGON_DET_UND2;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           LOGON_DET_REC2.VFC = 'B';
           DO CASE(SL_RECORD_BUF.ORIG_MODE);
             CASE(0);
               DO CASE(SL_RECORD_BUF.MODE);
                 CASE(%M_BATCH#);
                   GOTO BATCH;
                 CASE(%M_GHOST#);
                   NUMBER = SL_RECORD_BUF.SYSID;
                   GOTO GHOST;
                 CASE(ELSE);
                   GOTO TSLINE;
                 END;
             CASE(%M_BATCH#);
BATCH:;
               LOGON_DET_REC2.BATCH.DEVICE = SL_RECORD_BUF.DEVICE;
               LOGON_DET_REC2.BATCH.TNAME = SL_RECORD_BUF.DEVICE_TNAME;
             CASE(%M_GHOST#);
               NUMBER = SL_RECORD_BUF.ORIG_SYSID;
GHOST:;
               CALL DECIMAL(LOGON_DET_REC2.GHOST.SYSID,6,NUMBER);
             CASE(%M_INT#);
TSLINE:;
               NUMBER = SL_RECORD_BUF.TSLINE.FEX;
               CALL DECIMAL(LOGON_DET_REC2.TSLINE.FEX,3,NUMBER);
               CALL HEX(2,SL_RECORD_BUF.TSLINE.PORT,4,
                            LOGON_DET_REC2.TSLINE.PORT);
               NUMBER = SL_RECORD_BUF.TSLINE.LEV;
               CALL DECIMAL(LOGON_DET_REC2.TSLINE.LEV,3,NUMBER);
               NUMBER = SL_RECORD_BUF.TSLINE.SUBDEVICE;
               CALL DECIMAL(LOGON_DET_REC2.TSLINE.SUB,6,NUMBER);
               NUMBER = SL_RECORD_BUF.TSLINE.SUBSUBDEVICE;
               CALL DECIMAL(LOGON_DET_REC2.TSLINE.SUBSUB,6,NUMBER);
             CASE(ELSE);
               LOGON_DET_REC2.DEV = MODES(SL_RECORD_BUF.ORIG_MODE);
             END;
           CALL OCTAL(36,SL_RECORD_BUF.PRIV,12,LOGON_DET_REC2.PRIV);
           CALL OCTAL(36,SL_RECORD_BUF.PPRIV,12,LOGON_DET_REC2.PPRIV);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           IF SL_RECORD_BUF.MODE = %M_BATCH# AND
              SL_RECORD_BUF.ORIG_MODE ~= %M_BATCH# AND
              SL_RECORD_BUF.ORIG_MODE ~= 0 THEN DO;
              SL_OUTBUF = %LOGON_DET_HDR3;
              CALL WRITE_REC ALTRET(WRITE_ERR);
              SL_OUTBUF = %LOGON_DET_HDR4;
              CALL WRITE_REC ALTRET(WRITE_ERR);
              SL_OUTBUF = %LOGON_DET_UND4;
              CALL WRITE_REC ALTRET(WRITE_ERR);
              LOGON_DET_REC3.VFC = 'B';
              LOGON_DET_REC3.MODE = MODES(SL_RECORD_BUF.PREV_USER.MODE);
              NUMBER = SL_RECORD_BUF.PREV_USER.SYSID;
              CALL DECIMAL(LOGON_DET_REC3.SYSID,6,NUMBER);
              LOGON_DET_REC3.ACCN = SL_RECORD_BUF.PREV_USER.ACCT;
              LOGON_DET_REC3.UNAME = SL_RECORD_BUF.PREV_USER.UNAME.C;
              CALL WRITE_REC ALTRET(WRITE_ERR);
              END;
         CASE(ELSE);
           IF SL_RECORD_BUF.SYSID=0 AND SL_RECORD_BUF.MODE=%M_TP# THEN DO;
              SL_RECORD_BUF.MODE=7;
              SL_OUTBUF = %TPEXIT_DET_HDR1;
              END;
           ELSE SL_OUTBUF = %COMMON_DET_HDR1;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %COMMON_DET_UND1;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           COMMON_DET_REC1.VFC = 'B';
           COMMON_DET_REC1.TIME = SL_TIME;
           NUMBER = SL_RECORD_BUF.SEQ_NUM;
           CALL DECIMAL(COMMON_DET_REC1.SEQ#,6,NUMBER);
           COMMON_DET_REC1.REA = REASON$(I)->REASONS(SL_RECORD_BUF.REASON);
           IF SL_RECORD_BUF.GRANTED THEN
              COMMON_DET_REC1.GRANTED = 'Y';
           ELSE COMMON_DET_REC1.GRANTED = 'N';
           COMMON_DET_REC1.MODE = MODES(SL_RECORD_BUF.MODE);
           COMMON_DET_REC1.ACCN = SL_RECORD_BUF.ACCN;
           COMMON_DET_REC1.UNAME = SL_RECORD_BUF.UNAME;
           IF SL_RECORD_BUF.MODE~=7 THEN DO;
              COMMON_DET_REC1.DOT = '.';
              CALL OCTAL(9,SL_RECORD_BUF.USER,3,COMMON_DET_REC1.USER#);
              NUMBER = SL_RECORD_BUF.SYSID;
              CALL DECIMAL(COMMON_DET_REC1.SYSID,6,NUMBER);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %COMMON_DET_HDR2;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %COMMON_DET_UND2;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           COMMON_DET_REC2.VFC = 'B';
           COMMON_DET_REC2.FACCN = SL_RECORD_BUF.FACCN;
           COMMON_DET_REC2.WOO = SL_RECORD_BUF.WOO;
           CALL OCTAL(36,SL_RECORD_BUF.PRIV,12,COMMON_DET_REC2.PRIV);
           CALL OCTAL(36,SL_RECORD_BUF.PPRIV,12,COMMON_DET_REC2.PPRIV);
           CALL OCTAL(36,SL_RECORD_BUF.PRIV_ACTIVE,12,
                      COMMON_DET_REC2.PRIV_ACTIVE);
           CALL OCTAL(36,SL_RECORD_BUF.PRIV_PRC,12,
                      COMMON_DET_REC2.PRIV_PRC);
              END;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           IF SL_RECORD_BUF.MODE=7 THEN
              SL_OUTBUF = %TPEXIT_DET_HDR3;
           ELSE SL_OUTBUF = %COMMON_DET_HDR3;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           IF SL_RECORD_BUF.MODE=7 THEN
              SL_OUTBUF = %TPEXIT_DET_UND3;
           ELSE SL_OUTBUF = %COMMON_DET_UND3;
           CALL WRITE_REC ALTRET(WRITE_ERR);
           COMMON_DET_REC3.VFC = 'B';
           COMMON_DET_REC3.DOMAYN = DOMAINS(SL_RECORD_BUF.DOMAYN);
           COMMON_DET_REC3.PROC_SN = SL_RECORD_BUF.PROC_PSN;
           COMMON_DET_REC3.PROC_NAME = SL_RECORD_BUF.PROC_NAME.C;
           COMMON_DET_REC3.PROC_ACCT = SL_RECORD_BUF.PROC_ACCT;
           COMMON_DET_REC3.OMODE = MODES(SL_RECORD_BUF.ORIG_MODE);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           COMMON_DET_REC4.VFC = 'A';
           IF SL_RECORD_BUF.ORIG_MODE = 0 THEN
              COMMON_DET_REC4.DEV = DET_DEV_HDR(SL_RECORD_BUF.MODE);
           ELSE
              COMMON_DET_REC4.DEV = DET_DEV_HDR(SL_RECORD_BUF.ORIG_MODE);
           COMMON_DET_REC4.REST = DET_TYPE_HDR(I);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           SL_OUTBUF = %LOGON_DET_UND2;
           COMMON_DET_REC4.REST = DET_TYPE_UND(I);
           CALL WRITE_REC ALTRET(WRITE_ERR);
           COMMON_DET_REC4.VFC = 'B';
           DO CASE(SL_RECORD_BUF.ORIG_MODE);
             CASE(0);
               DO CASE(SL_RECORD_BUF.MODE);
                 CASE(%M_BATCH#);
                   GOTO BATCH2;
                 CASE(%M_GHOST#);
                   NUMBER = SL_RECORD_BUF.SYSID;
                   GOTO GHOST2;
                 CASE(ELSE);
                   GOTO TSLINE2;
                 END;
             CASE(%M_BATCH#);
BATCH2:;
               COMMON_DET_REC4.BATCH.DEVICE = SL_RECORD_BUF.DEVICE;
               COMMON_DET_REC4.BATCH.TNAME = SL_RECORD_BUF.DEVICE_TNAME;
             CASE(%M_GHOST#);
               NUMBER = SL_RECORD_BUF.ORIG_SYSID;
GHOST2:;
               CALL DECIMAL(COMMON_DET_REC4.GHOST.SYSID,6,NUMBER);
             CASE(%M_INT#);
TSLINE2:;
               NUMBER = SL_RECORD_BUF.TSLINE.FEX;
               CALL DECIMAL(COMMON_DET_REC4.TSLINE.FEX,3,NUMBER);
               CALL HEX(2,SL_RECORD_BUF.TSLINE.PORT,4,
                            COMMON_DET_REC4.TSLINE.PORT);
               NUMBER = SL_RECORD_BUF.TSLINE.LEV;
               CALL DECIMAL(COMMON_DET_REC4.TSLINE.LEV,3,NUMBER);
               NUMBER = SL_RECORD_BUF.TSLINE.SUBDEVICE;
               CALL DECIMAL(COMMON_DET_REC4.TSLINE.SUB,6,NUMBER);
               NUMBER = SL_RECORD_BUF.TSLINE.SUBSUBDEVICE;
               CALL DECIMAL(COMMON_DET_REC4.TSLINE.SUBSUB,6,NUMBER);
             CASE(ELSE);
               COMMON_DET_REC4.DEV = MODES(SL_RECORD_BUF.ORIG_MODE);
             END;
           DO CASE(SL_RECORD_BUF.TYPE);
             CASE(%EL_FILE_ACCESS,%EL_ARES_BYPASS);
               COMMON_DET_REC4.FILE.FUN = FILE_FUN(SL_RECORD_BUF.FILE.FUN);
               COMMON_DET_REC4.FILE.ASN = FILE_ASN(SL_RECORD_BUF.FILE.ASN);
               IF SL_RECORD_BUF.TYPE = %EL_FILE_ACCESS THEN DO;
                  CALL OCTAL(18,SL_RECORD_BUF.FILE.FFLG,6,
                             COMMON_DET_REC4.FILE.FFLG);
                  COMMON_DET_REC4.FILE.RES = SL_RECORD_BUF.FILE.RES;
                  END;
               CALL WRITE_REC ALTRET(WRITE_ERR);
               IF SL_RECORD_BUF.TYPE = %EL_FILE_ACCESS THEN
                  SL_OUTBUF = %FILE_ACCESS_HDR5;
               ELSE
                  SL_OUTBUF = %ARES_BYPASS_HDR5;
               CALL WRITE_REC ALTRET(WRITE_ERR);
               SL_OUTBUF = %FILE_ACCESS_UND5;
               CALL WRITE_REC ALTRET(WRITE_ERR);
               FILE_ACCESS_REC5.VFC = 'B';
               FILE_SN.SN#(0) = SL_RECORD_BUF.FILE.SN;
               FPT_UNFID.TEXTFID_ = VECTOR(FILE_ACCESS_REC5.FILE);
               CALL M$UNFID(FPT_UNFID);
             CASE(%EL_PRIV_CHANGE);
               CALL OCTAL(36,SL_RECORD_BUF.PRIVS_REQUIRED,12,
                          COMMON_DET_REC4.PRIV_CHNG.PRIV);
             CASE(%EL_MON_SRV);
               CALL OCTAL(36,SL_RECORD_BUF.PRIVS_REQUIRED,12,
                          COMMON_DET_REC4.MON_SRV.PRIV);
               PMME = SL_RECORD_BUF.PMME_TYPE;
               FCG$ = MONSER_TBL.FCG$(PMME1.FCG);
PMME_LOOP2:
               DO I = 0 TO MONSER_TBL.CNT(PMME1.FCG)-1;
                  IF PMME1.CODE = FCG$->FCG_TBL.CODE(I) THEN DO;
                     COMMON_DET_REC4.MON_SRV.PMME = FCG$->FCG_TBL.TEXT(I);
                     EXIT PMME_LOOP2;
                     END;
                  END;
             CASE(%EL_SYS_EXIT);
             END;
           CALL WRITE_REC ALTRET(WRITE_ERR);
         END; /* Do Case SL_RECORD_BUF.TYPE */
       SL_OUTBUF = 'A';
       CALL WRITE_REC ALTRET(WRITE_ERR);
     END; /* Do Case REPORT_CODE */
  RETURN;
WRITE_ERR:;
  CALL ERRMSG;
  RETURN;
 
%EJECT;
OCTAL: PROC(BITSIZE,BITS,CHARSIZE,CHARS);
/**/
DCL BITSIZE UBIN;
DCL BITS BIT(BITSIZE);
DCL BIN3(0:0) REDEF BITS UBIN(3) UNAL;
DCL CHARSIZE UBIN;
DCL CHARS CHAR(CHARSIZE);
DCL CHAR1(0:0) REDEF CHARS CHAR(1) CALIGNED;
/**/
DCL I UBIN;
DCL NCHARS UBIN;
DCL TMP UBIN BYTE;
/**/
  NCHARS = BITSIZE/3;
  IF NCHARS > CHARSIZE THEN
     NCHARS = CHARSIZE;
  DO I = 0 TO NCHARS-1;
     TMP = BIN3(I)+48; /* Add octal .060 to make char value */
     CHAR1(I) = BINASC(TMP);
     END;
  RETURN;
END OCTAL;
%EJECT;
HEX: PROC(NUM_BYTES,PORT,NUM_CHARS,CHARS);
/**/
DCL NUM_BYTES UBIN;
DCL PORT CHAR(NUM_BYTES);
DCL NUM_CHARS UBIN;
DCL CHARS CHAR(NUM_CHARS);
DCL CHAR1(0:0) REDEF CHARS CHAR(1);
/**/
DCL PORT$ PTR;
DCL HEX_NUM(0:0) UBIN(4) UNAL BASED(PORT$);
DCL HEX_CHARS(0:15) CHAR(1) CONSTANT CALIGNED INIT(
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
DCL I UBIN;
/**/
  IF NUM_BYTES*2 > NUM_CHARS THEN DO;
     CHARS='******';
     RETURN;
     END;
  PORT$ = PINCRB(ADDR(PORT),NUM_BYTES);
  DO I = 0 TO NUM_BYTES*2-1;
     CHAR1(I) = HEX_CHARS(HEX_NUM(I));
     END;
  RETURN;
END HEX;
%EJECT;
DECIMAL: PROC(CHARS,NUM_CHARS,NUMBER);
/**/
DCL CHARS CHAR(NUM_CHARS);
DCL NUM_CHARS UBIN;
DCL NUMBER UBIN;
/**/
DCL I UBIN;
DCL CHAR1(0:0) CHAR(1) CALIGNED BASED(C$);
DCL C$ PTR;
/**/
  C$ = ADDR(CHARS);
  CALL BINCHAR(CHARS,NUMBER);
I_LOOP:
  DO I = 0 TO NUM_CHARS-2;
     IF CHAR1(I) = '0' THEN
        CHAR1(I) = ' ';
     ELSE EXIT I_LOOP;
     END;
  RETURN;
END DECIMAL;
%EJECT;
WRITE_REC: PROC ALTRET;
/**/
  CALL M$WRITE(WRITE_RECORD) ALTRET(ERR);
  SL_OUTBUF = ' ';
  RETURN;
ERR:;
  ALTRETURN;
END WRITE_REC;
END REPORT_ONE;
END REPORT;
%EJECT;
SPAN:   PROC ALTRET;
/**/
/* VARS */
DCL I UBIN;
DCL VALUE UBIN;
DCL STOP UBIN WORD ;
DCL TEMP UBIN WORD STATIC;
DCL START UBIN WORD;
/**/
/* FPT DEFS */
%FPT_TIME (FPTN=CUR_TIME,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TEMP);
%EJECT;
        START = SL_CONSTRAINTS.START;
        STOP = SL_CONSTRAINTS.STOP;
        DO CASE(OUT$BLK.SUBLK$(0)->OUT$BLK.CODE);
         CASE (%TIME_X);
           CALL M$TIME (CUR_TIME);
           CALL CHARBIN(I,OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
             OUT$SYM.TEXT);
           DO CASE (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(1)->OUT$BLK.CODE);
            CASE (%DAYS);
              CALL XUD$UTS_ADJ_25TH (START, SL_DEFAULT.START, -I * %UTS_25TH_DAY#);
              STOP = SL_DEFAULT.STOP;
            CASE (%WEEKS);
              CALL XUD$UTS_ADJ_25TH (START, SL_DEFAULT.START, -I * 7 * %UTS_25TH_DAY#);
              STOP = SL_DEFAULT.STOP;
            CASE (%MONTHS);
              CALL XUD$UTS_ADJ_25TH (START, SL_DEFAULT.START, -I * 30 * %UTS_25TH_DAY#);
              STOP = SL_DEFAULT.STOP;
            CASE (%YEAR);
              CALL XUD$UTS_ADJ_25TH (START, SL_DEFAULT.START, -I * 365 * %UTS_25TH_DAY#);
              STOP = SL_DEFAULT.STOP;
            CASE (%MINUTES);
              CALL XUD$UTS_ADJ_25TH (START, TEMP, -I * %UTS_25TH_MIN#);
              STOP = TEMP;
            CASE (%HOURS);
              CALL XUD$UTS_ADJ_25TH (START, TEMP, -I * %UTS_25TH_HOUR#);
              STOP = TEMP;
            END;                        /* OF DO CASE TIME_X                  */
         CASE (%TIME_N);
           DO I = 0 TO OUT$BLK.SUBLK$(0)->OUT$BLK.NSUBLKS - 1;
              DO CASE (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(I)->
                OUT$BLK.CODE);
               CASE(%START);
                 CALL CVTUTS(OUT$BLK.SUBLK$(0)->
                   OUT$BLK.SUBLK$(I),-1,VALUE) ALTRET(ERR_LBL);
                 START = VALUE;
               CASE(%STOP);
                 CALL CVTUTS(OUT$BLK.SUBLK$(0)->
                   OUT$BLK.SUBLK$(I),1,VALUE) ALTRET(ERR_LBL);
                 STOP = VALUE;
               END;                     /* CASE CODE                          */
              END;                      /* DO I                               */
         CASE (%TODAY);
           DO;
              START = SL_DEFAULT.START;
              STOP  = SL_DEFAULT.STOP;
              END;
         END;                           /* OF DO CASE TIME_X OR TIME_N        */
        IF STOP < START
        THEN                            /* BAD TIME CONSTRAINTS               */
        DO;
           CALL ERRMSG(%E$BAD_TIME_RANGE);
           ALTRETURN;
           /*E* ERROR:   SL-E$BAD_TIME_RANGE-0
                MESSAGE: Bad time span: start > stop
           */
           END;                         /* IF BAD TIME RANGE                  */
        SL_CONSTRAINTS.START = START;
        SL_CONSTRAINTS.STOP = STOP;
        RETURN;
ERR_LBL:
        CALL ERRMSG(%E$BADTIME);
        ALTRETURN;
        /*E* ERROR:   SL-E$BADTIME-0
             MESSAGE: Illegal format for time or date
        */
%EJECT;
CVTUTS: PROC(TOP$,DAYFLG,UTS) ALTRET;
/**/
/* PARAMS */
DCL TOP$ PTR;
DCL DAYFLG SBIN;
DCL UTS UBIN;
/**/
/* VARS */
DCL I UBIN;
DCL 1 TBUF3 STATIC,
      2 HH CHAR(2),
      2 * CHAR(1),
      2 MM CHAR(2),
      2 * CHAR(1),
      2 SS CHAR(2),
      2 * CHAR(1),
      2 SM CHAR(2);
DCL 1 DBUF3 STATIC,
      2 MM CHAR(2),
      2 * CHAR(1),
      2 DD CHAR(2),
      2 * CHAR(1),
      2 YY CHAR(2);
DCL TIMECHARS CHAR(4);
DCL 1 TIMECHAR REDEF TIMECHARS,
      2 HH CHAR(2),
      2 MM CHAR(2);
DCL SYM$ PTR;
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=FPT_GETTIME,
           DATE=DBUF3,
           TIME=TBUF3,
           SOURCE=CLOCK,
           DEST=LOCAL);
%FPT_TIME (FPTN=FPT_GETUTS,
           DATE=DBUF3,
           TIME=TBUF3,
           SOURCE=LOCAL,
           DEST=UTS);
/**/
/* MACRO INVOCATIONS */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
%EJECT;
        CALL M$TIME(FPT_GETTIME);
        IF DAYFLG > 0
        THEN                            /* DEFAULT TIME = 23:59               */
        DO;
           TBUF3.HH = '23';
           TBUF3.MM = '59';
           TBUF3.SS = '59';
           TBUF3.SM = '99';
           END;
        ELSE                            /* DEFAULT TIME = 00:00               */
        DO;
           TBUF3.HH = '00';
           TBUF3.MM = '00';
           TBUF3.SS = '00';
           TBUF3.SM = '00';
           END;
        DO I = 0 TO OUT$BLK.NSUBLKS - 1;
           DO CASE(OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
            CASE(%DATE_P);
              CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0),DBUF3.MM) ALTRET(BAD_TIME);
              CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(1),DBUF3.DD) ALTRET(BAD_TIME);
              IF OUT$BLK.SUBLK$(I)->OUT$BLK.NSUBLKS = 3 THEN
                 CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(2),DBUF3.YY) ALTRET(BAD_TIME);
            CASE(%TIME_P);
              IF OUT$BLK.SUBLK$(I)->OUT$BLK.NSUBLKS = 1
              THEN
              DO;
                 SYM$=OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0);
                 IF OUT$SYM.COUNT ~= 4
                 THEN
                    ALTRETURN;
                 TIMECHARS = OUT$SYM.TEXT;
                 TBUF3.HH = TIMECHAR.HH;
                 TBUF3.MM = TIMECHAR.MM;
                 END;
              ELSE
              DO;
                 CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0),TBUF3.HH) ALTRET(BAD_TIME);
                 CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(1),TBUF3.MM) ALTRET(BAD_TIME);
                 END;
            END;                        /* CASE CODE                          */
           END;                         /* DO I                               */
        FPT_GETUTS.TSTAMP_ = VECTOR(UTS);
        CALL M$TIME(FPT_GETUTS) ALTRET(BAD_TIME);
        RETURN;
BAD_TIME:
        ALTRETURN;
%EJECT;
FILL_FIELD: PROC(SYM$,FIELD) ALTRET;
/**/
/* PARAMS */
DCL SYM$ PTR;
DCL FIELD CHAR(2);
DCL RFIELD(0:1) REDEF FIELD CHAR(1);
/**/
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
        IF OUT$SYM.COUNT = 2
        THEN FIELD = OUT$SYM.TEXT;
        ELSE
           IF OUT$SYM.COUNT = 1
           THEN
           DO;
              RFIELD(0) = '0';
              RFIELD(1) = OUT$SYM.TEXT;
              END;
           ELSE                         /* ERROR                              */
           DO;
              ALTRETURN;
              END;                      /* IF                                 */
        RETURN;
END FILL_FIELD;
END CVTUTS;
END SPAN;
%EJECT;
GETREC: PROC(KEY_NAME,UTS,DONT_CLOSE) ALTRET;
/**/
/* PARAMS */
DCL KEY_NAME CHAR(8);
DCL UTS UBIN WORD;
DCL DONT_CLOSE SBIN;
/**/
/**/
/* ENTRY DEFS */
DCL XSA$READ ENTRY(2) ALTRET;
DCL XSA$OPEN ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
DCL XUR$ERRMSG ENTRY(7) ALTRET;
/**/
/* VARS */
DCL I SBIN;
DCL PASSED_FLAG BIT(1) ALIGNED;
/**/
/**/
/* FPT DEFINITIONS */
%FPT_READ (FPTN=READ_SECLOG,
           STCLASS=CONSTANT,
           DCB=M$SECLOG,
           BUF=SL_RECORD_BUF);
%FPT_PFIL (DCB=M$SECLOG,
           STCLASS=CONSTANT,
           BOF=YES);
/**/
%EJECT;
           PASSED_FLAG = %NO;
           IF SL_BOF
           THEN DO;
              SL_BOF = %NO;
              CALL XSA$CLOSE(SL_CLOSE_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
              CALL XSA$OPEN(SL_OPEN_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
              END;                      /* IF SL_BOF                          */
           DO WHILE(NOT(PASSED_FLAG));
              CALL XSA$READ(READ_SECLOG,SL_XSA_PARAM) ALTRET(READ_ERR);
              PASSED_FLAG = %YES;
              IF SL_RECORD_BUF.UTS < SL_CONSTRAINTS.START THEN
                 GOTO NOT_PASSED;
              IF SL_RECORD_BUF.UTS > SL_CONSTRAINTS.STOP THEN
                 GOTO SECLOG_EOF;
              IF SL_CONSTRAINTS.TYPES(0) = %ALL THEN
                 GOTO FOUND_NTYPES;
              DO I = 1 TO %MAX_TYPES;
                 IF SL_RECORD_BUF.TYPE = SL_CONSTRAINTS.TYPES(I)
                    THEN GOTO FOUND_NTYPES;
                 END;
NOT_PASSED:      ;
              PASSED_FLAG = %NO;
FOUND_NTYPES: ;
              END;
           SL_LASTUTS = SL_RECORD_BUF.UTS;
           RETURN;
XSA_ERR:   CALL XUR$ERRMSG(SL_XSA_PARAM.ERR);
           RETURN;
READ_ERR:  IF SL_XSA_PARAM.ERR.CODE ~= %E$EOF
           THEN DO;
              CALL XUR$ERRMSG(SL_XSA_PARAM.ERR);
              RETURN;
              END;
SECLOG_EOF: ;
           ALTRETURN;
END GETREC;
%EJECT;
OPENXSA: PROC(SECLOG_DATE) ALTRET;
DCL SECLOG_DATE UBIN;
/**/
/* ENTRY DEFS */
DCL XSA$OPEN ENTRY(2) ALTRET;
DCL XSA$PRECORD ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
/**/
/* VARIABLES */
DCL UTS_MOD_DAY SBIN;
DCL SECLOGDATE UBIN STATIC;
DCL ANSDATE2 CHAR(6) STATIC;
DCL TODAYDATE CHAR(6) STATIC;
DCL 1 FSF_BUF BASED(SL_XSA_BUF.P$),
      2 KEYS (0:1023) UBIN,
      2 DATA (0:1023) UBIN;
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=ANS_DATE,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           TSTAMP=SECLOGDATE,
           DEST=ANS,
           DATE=ANSDATE2);
%FPT_TIME (FPTN=TODAY_DATE,
           STCLASS=CONSTANT,
           SOURCE=CLOCK,
           DEST=ANS,
           DATE=TODAYDATE);
%FPT_PRECORD (FPTN=POSITION_SECLOG,
              DCB=M$SECLOG,
              KEY=SL_CONSTRAINTS.START,
              KEYS=YES,
              STCLASS=CONSTANT);
%FPT_GDS (FPTN=GET_XSA_BUF,
          FREE=YES,
          RESULTS=SL_XSA_BUF_VECTOR,
          SEGSIZE="SIZEW(FSF_BUF)",
          STCLASS=CONSTANT);
%EJECT;
        SECLOGDATE = SECLOG_DATE;
        IF SL_XSA_BUF.P$ = ADDR(NIL)
        THEN DO;
           CALL M$GDS(GET_XSA_BUF) ALTRET(PMME_ERR);
           SL_XSA_PARAM.KBUF_ = VECTOR(FSF_BUF.KEYS);
           SL_XSA_PARAM.BBUF_ = VECTOR(FSF_BUF.DATA);
           END;
        IF SL_M$SECLOG$->F$DCB.FCD#
        THEN CALL XSA$CLOSE(SL_CLOSE_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
        CALL M$TIME(ANS_DATE);
        IF (SUBSTR (ANSDATE2, 0, 2) >= '78')
          THEN CALL INSERT(SL_VLP_SECLOG.NAME#,7,8,'19',ANSDATE2);
          ELSE CALL INSERT(SL_VLP_SECLOG.NAME#,7,8,'20',ANSDATE2);
        CALL M$TIME(TODAY_DATE);
        IF TODAYDATE = ANSDATE2 THEN
           SL_OPEN_SECLOG.V.SHARE# = %ALL#;
        ELSE SL_OPEN_SECLOG.V.SHARE# = %IN#;
        CALL XSA$OPEN(SL_OPEN_SECLOG,SL_XSA_PARAM) ALTRET(OPEN_ERR);
        RETURN;
OPEN_ERR: ;
        ALTRETURN;
PMME_ERR: ;
        CALL ERRMSG;
        RETURN;
%EJECT;
PRECORDXSA: ENTRY(SECLOG_DATE) ALTRET;
        CALL XUD$UTS_DIFF_25TH (UTS_MOD_DAY, SECLOG_DATE, 0);
        IF SECLOG_DATE = SL_CONSTRAINTS.START
          AND MOD(UTS_MOD_DAY, %UTS_25TH_DAY#) ~= 0
        THEN DO;
           CALL XSA$PRECORD(POSITION_SECLOG,SL_XSA_PARAM) ALTRET(KEY_ERR);
KEY_ERR:   ;
           SL_BOF = %NO;
           END;
        ELSE SL_BOF = %YES;
        RETURN;
%EJECT;
CLOSEXSA: ENTRY ALTRET;
        IF SL_M$SECLOG$->F$DCB.FCD#
        THEN CALL XSA$CLOSE(SL_CLOSE_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
        IF SL_XSA_BUF.P$ ~= ADDR(NIL)
        THEN CALL M$FDS(GET_XSA_BUF) ALTRET(PMME_ERR);
        RETURN;
XSA_ERR: ;
        CALL XUR$ERRMSG(SL_XSA_PARAM.ERR);
        RETURN;
END OPENXSA;
%EJECT;
WRITE_IT: PROC(FORMAT_VEC,DV1,DV2,DV3,DV4,DV5,DV6,DV7,DV8,DV9,DV10);
/**/
/* PARAMS */
DCL FORMAT_VEC BIT(72);
DCL DV1 BIT(72);
DCL DV2 BIT(72);
DCL DV3 BIT(72);
DCL DV4 BIT(72);
DCL DV5 BIT(72);
DCL DV6 BIT(72);
DCL DV7 BIT(72);
DCL DV8 BIT(72);
DCL DV9 BIT(72);
DCL DV10 BIT(72);
/**/
/* VARIABLES */
DCL I UBIN;
DCL M$LO$ PTR;
DCL DATA_VEC(0:9) BIT(72) STATIC INIT(VECTOR(NIL)*0);
/**/
/* ENTRY DEFS */
DCL X$FORMAT ENTRY(1);
/**/
/* MACROS */
%F_FDS (NAME=FDS,
        DCB=M$LO,
        TRUNC=NO,
        BUF=SL_OUTBUF,
        VECTR=DATA_VEC);
/**/
/* FPT DEFINITIONS */
/**/
%EJECT;
        M$LO$ = DCBADDR(DCBNUM(M$LO));
        FDS.FMT_ = FORMAT_VEC;
        IF ADDR(DV1) ~= ADDR(NIL)
        THEN DATA_VEC(0) = DV1;
        IF ADDR(DV2) ~= ADDR(NIL)
        THEN DATA_VEC(1) = DV2;
        IF ADDR(DV3) ~= ADDR(NIL)
        THEN DATA_VEC(2) = DV3;
        IF ADDR(DV4) ~= ADDR(NIL)
        THEN DATA_VEC(3) = DV4;
        IF ADDR(DV5) ~= ADDR(NIL)
        THEN DATA_VEC(4) = DV5;
        IF ADDR(DV6) ~= ADDR(NIL)
        THEN DATA_VEC(5) = DV6;
        IF ADDR(DV7) ~= ADDR(NIL)
        THEN DATA_VEC(6) = DV7;
        IF ADDR(DV8) ~= ADDR(NIL)
        THEN DATA_VEC(7) = DV8;
        IF ADDR(DV9) ~= ADDR(NIL)
        THEN DATA_VEC(8) = DV9;
        IF ADDR(DV10) ~= ADDR(NIL)
        THEN DATA_VEC(9) = DV10;
        I = 0;
        DO WHILE(DATA_VEC(I) ~= VECTOR(NIL) AND I < 10);
           I = I + 1;
           END;                         /* DO WHILE                           */
        FDS.NVECS# = I;
        FDS.BUF_.BOUND = M$LO$->F$DCB.WIDTH#;
        IF (FDS.BUF_.BOUND = 0 OR FDS.BUF_.BOUND > 100)
        THEN FDS.BUF_.BOUND = 100;
        CALL X$FORMAT(FDS);
END WRITE_IT;
%EJECT;
ERRMSG: PROC(CODE);
/**/
/* PARAMS */
DCL CODE UBIN WORD;
/**/
/* LOCALS */
DCL DCB# UBIN;
%EJECT;
        IF ADDR(CODE) = ADDR(NIL)
        THEN DO;
           SL_ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
           SL_ERRCODE.SEV = 0;
           DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
           CALL XUR$ERRMSG(SL_ERRCODE,DCB#);
           END;
        ELSE DO;
           SL_ERRCODE = '231400000000'O;
           SL_ERRCODE.CODE = CODE;
           CALL XUR$ERRMSG(SL_ERRCODE);
           END;
        RETURN;
END ERRMSG;
END WEASEL;
