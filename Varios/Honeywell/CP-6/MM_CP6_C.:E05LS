

07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          1    
    1       /*M* MM_CP6_C Memory Management FPT macros.                                */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7       /*X* MEC,MOC,EXM=1,CLM=30,CRM=78               */
    8      /****************************************************************/
    9      /*                                                              */
   10      /*                 ***  CP6MM  ***                              */
   11      /*                                                              */
   12      /*       MEMORY MANAGEMENT MONITOR SERVICE CALLS                */
   13      /*                                                              */
   14      /****************************************************************/
   15       /*F* NAME: Memory Control
   16
   17       CP-6 memory management fully utilizes the Virtual
   18       Memory and Security feature of the hardware.  The
   19       CP-6 Concepts and Facilities Manual section
   20       entitled Memory Management describes memory
   21       protection, virtual address calculation, hardware
   22       registers associated with specific portions of the
   23       virtual work space, and the concept of domain
   24       which derives from the VM&S feature. Instead of
   25       reiterating that information, the following
   26       discussion focuses on concepts necessary to
   27       perform dynamic memory allocations.
   28
   29       Memory is managed as a number of work spaces.
   30       Each user runs in a separate work space as do the
   31       monitor, the command processor, the debugger, and
   32       the alternate shared library. Each work space is
   33       a 2048K word virtual address space protected by the
   34       NSA hardware at two levels:
   35
   36       o  At the page level - The Page Table in the JIT
   37          contains an entry for each possible 1K word
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          2    
   38          page in the virtual space. The Page Table
   39          entries indicate whether a physical page
   40          corresponds to the page table entry and
   41          contain flags which control access to the
   42          page.
   43
   44       o  At the segment level - The work space is
   45          organized in segments, that is, contiguous
   46          virtual spaces framed by structures called
   47          descriptors. The descriptors (stored in the
   48          Linkage Segment) contain flags to indicate if
   49          the segment is present and to control access
   50          to the segment. A SEGID, which is part of a
   51          PL-6 pointer variable, identifies a particular
   52          descriptor.
   53
   54       A map of the user work space included in Table 4-1
   55       shows the segments into which the virtual memory
   56       space is divided. Segments are reserved for
   57       job-related tables and structures managed by the
   58       monitor, and for the Instruction Segment which
   59       contains user data, user procedure, and overlays
   60       and also library data and procedure (if used). In
   61       addition, virtual space is available for dynamic
   62       allocation in the course of program execution.
   63       This space may be used for tables, user buffers,
   64       etc.
   65
   66       The virtual memory available for dynamic
   67       allocation is located in the Instruction Segment
   68       and in separate, individual Data Segments in the
   69       high-address portion of the virtual work space.
   70       The characteristics of the two sources of dynamic
   71       memory are described below:
   72
   73         .inl 4
   74         .unl 4
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          3    
   75         1.  Dynamic Data Area of the Instruction Segment.
   76             The size of this area is dependent on the size
   77             of the user program and on whether a memory-resident
   78             library is associated with the program. Because
   79             the Dynamic Data Area resides in the same segment
   80             as the user program, dynamic pages in this
   81             area can be referenced within the user
   82             program by use of name references or simply by
   83             their Instruction Segment address.  The M$GDP/M$FDP
   84             services permit the user to allocate pages as
   85             a stack appended to the user procedure.  The
   86             M$GVP/M$FVP services permit the user to allocate
   87             and deallocate pages anywhere in the Dynamic
   88             Data Area. The user is responsible for
   89             managing the Dynamic Data Area, although monitor
   90             services prevent reallocation of pages that are
   91             already allocated.  Pages can be used for
   92             read, write, or execute functions.
   93
   94         .unl 4
   95         2.  Data Segments.    Each user and each special
   96             shared processor may request up to eight data
   97             segments at run-time. These data segments are
   98             virtual spaces which may be created, enlarged, and
   99             deallocated under programmer control. Generally,
  100             managing a data segment requires less user
  101             coding than managing space in the Dynamic Data
  102             Area. The monitor determines the location of
  103             the segments within the virtual work space. Since
  104             data segments are independently addressable
  105             segments, the user must reference Data
  106             Segments via PL-6 pointer (PTR) variables.
  107             Pages can be used for read or write
  108             functions but not for execution.
  109         .inl 0
  110
  111       The virtual memory map in Table 4-1 gives the
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          4    
  112       maximum sizes of the Dynamic Data Area in the
  113       Instruction Segment and the combined maximum sizes
  114       of the Data Segments for each domain. Dynamically
  115       allocated pages are set to allow read and write
  116       access.
  117
  118
  119       This table can be viewed as the layout of pages
  120       in virtual memory or as the layout of words in the page table.
  121       Some of the choices have been made to attempt to minimize the
  122       collisions within the Page Table Word Associative
  123       Memory (PTWAM). These are shown below:
  124       .fif
  125       .spb 1
  126       .bbk
  127       Field     V.P.#     AM row #
  128       JIT       .13       .13
  129       HJIT      .15       .15
  130       ROSEG     .57       .17
  131       IS        .100      .0
  132       UDS       .1130     .10
  133       .fin
  134       .bek
  135       .spb 1
  136       The more important parts of the structure include the following:
  137       .spb
  138       .inl 5
  139       .unl 5
  140       PAGE_TABLE    is a page containing the user page table.
  141       .spb 1
  142       .unl 5
  143       JIT_PAGE    is a page containing JIT and monitor AUTO.
  144       .spb 1
  145       .unl 5
  146       .bbk
  147       HJIT    is the HJIT page (housekeeping) containing:
  148       .fif
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          5    
  149       .spf
  150       User Linkage Segment
  151       Command Program Linkage Segment
  152       Debugger Linkage Segment
  153       ASL Linkage Segment
  154       Special Descriptor Storage
  155       Safe Store Stack
  156       Argument Segment
  157       Parameter Segment
  158       .fin
  159       .bek
  160       .unl 5
  161       .spb 1
  162       ROSEG    contains DCBs, TCB, and tree table.
  163       .spb 1
  164       .unl 5
  165       INSTRUCTION_SEGMENT contains the following:
  166       .fif
  167       .spb 1
  168       Library data
  169       Program data
  170       Program procedure
  171       Dynamic data
  172       Shared library procedure
  173
  174       .fin
  175       .INL 0
  176       Several of the monitor services discussed next
  177       return a vector to the user. The vector is a
  178       structure which conforms to the requirements of
  179       the NSA hardware. The vector is said to "frame"
  180       an area of virtual memory, that is, the 2-word
  181       vector contains the bound of the area (byte size
  182       minus one) in the first word along with control
  183       information which is not of concern to the user
  184       program, and in the second word a PL-6 pointer to
  185       the start of the framed area. To access an area
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          6    
  186       allocated by the M$GDP or M$GDS service, the user
  187       may simply use the PL-6 pointer from the returned
  188       vector. The pointer contains both an offset and a
  189       segment identifier (SEGID). For details on the
  190       format of the vector, see the discussion of the
  191       VLP_VECTOR macro included in this section.
  192       .INL 0
  193       .BRN 11
  194       ..::TB "User Virtual Memory"
  195       }       012345678 012345678 012345678 012345678
  196       }     +---------+---------+---------+---------+DCL
  197       }   .0|         |         |         |         |1 USER_VIRTUAL_MEMORY,
  198       }   .0|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 PAGE_TABLE(0:0) UBIN,
  199       }   .1|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 RFU1(0:9)       UBIN,
  200       }     Z         Z         Z         Z         Z
  201       }  .13|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 JIT_PAGE(0:0)   UBIN,
  202       }  .14|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 RFU2(0:0)       UBIN,
  203       }  .15|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 HJIT(0:0)       UBIN,
  204       }  .16|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 RFU3(0:1)       UBIN,
  205       }  .20|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 FPOOL(0:30)     UBIN,
  206       }     Z         Z         Z         Z         Z
  207       }  .57|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 ROSEG(0:13)     UBIN,
  208       }     Z         Z         Z         Z         Z
  209       }  .75|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 RFU4(0:2)       UBIN,
  210       }     Z         Z         Z         Z         Z
  211       } .100|         |         |         |         |  2 INSTRUCTION_SEGMENT
  212       } .100|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|     (0:255)        UBIN,
  213       }     Z         Z         Z         Z         Z
  214       } .500|         |         |         |         |  2 STEP_BUFFER_1(0:0)
  215       } .500|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|                    UBIN,
  216       } .501|         |         |         |         |  2 STEP_BUFFER_2(0:0)
  217       } .501|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|                    UBIN,
  218       } .502|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 RFU5(0:5)       UBIN,
  219       }     Z         Z         Z         Z         Z
  220    *  } .510|         |         |         |         |  2 DEBUGGER_DATA_
  221    *  } .510|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|     SEGMENTS(0:63) UBIN,
  222    *  }     Z         Z         Z         Z         Z
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          7    
  223    *  } .610|         |         |         |         |  2 ASL_DATA_SEGMENTS
  224    *  } .610|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|     (0:127)        UBIN,
  225       }     Z         Z         Z         Z         Z
  226       }.1010|         |         |         |         |  2 COMMAND_PROGRAM_DATA_
  227       }.1010|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|     SEGMENTS(0:31) UBIN,
  228       }     Z         Z         Z         Z         Z
  229       }.1050|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|  2 VIRT_PT(0:47)   UBIN;
  230       }     Z         Z         Z         Z         Z
  231    *  }.1130|         |         |         |         |  2 USER_DATA_SEGMENTS
  232    *  }.1130|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|uuuuuuuuu|     (0:1447)       UBIN,
  233       }     Z         Z         Z         Z         Z
  234       }     +---------+---------+---------+---------+
  235       }      012345678 012345678 012345678 012345678 .4000-0-0 total length
  236       ..::TB
  237       */
  238
  239
  240
  241
  242
  243       /*X* MEC,MOC,EXM=20,CLM=30,CRM=78                                          */
  244                                    /* MONITOR GET DYNAMIC SEGMENT SPACE PROCEDURE  */
  245                          /*F* NAME: M$GDS - Get/Enlarge Data Segment.
  246
  247                          The M$GDS service allocates or enlarges a
  248                          data segment based on the pointer variable passed
  249                          to it by the user. The pointer variable is stored
  250                          in the second word of a 2-word area called the
  251                          RESULTS area which can be generated by the
  252                          VLP_VECTOR macro (discussed later).
  253
  254                          Allocating a New Data Segment
  255
  256                          The next available data segment is allocated if
  257                          the pointer passed to M$GDS in RESULTS contains
  258                          zero or ADDR(NIL).  The first such available user
  259                          data segment is always data segment #3.  Automatic
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          8    
  260                          (data segment #1) and common (data segment #2)
  261                          must be requested explicitly.  Since special
  262                          shared processors do not have the common data
  263                          segment, their first available data segment is
  264                          always data segment #2.
  265
  266                          A particular Data Segment can be requested in the
  267                          case of Common and Automatic data by setting the
  268                          appropriate bit in the FPT or, for all data
  269                          segments, by specifying the SEGID of an
  270                          unallocated Data Segment in the second word of the
  271                          RESULTS area.
  272
  273                          A data segment is always created beginning on a
  274                          page boundary.  (For accounting billing purposes, the
  275                          charge is based on the number of pages allocated.)
  276                          The requested number of words is always rounded up
  277                          to the nearest double word (due to NSA hardware
  278                          restrictions) before being
  279                          allocated from the appropriate Data Segment area.
  280                          The area is determined by the domain of the executing
  281                          program, and a descriptor for the Data Segment is
  282                          placed in the user's Linkage Segment.
  283
  284                          Enlarging a Data Segment
  285
  286                          If the 2-word field named with the RESULTS
  287                          parameter contains the SEGID of an allocated Data
  288                          Segment, this is interpreted as a request to
  289                          increase the size of that Data Segment by the
  290                          number of words indicated by the SEGSIZE
  291                          parameter.  If either AUTOSEG=YES or COMMON=YES,
  292                          the SEGID is ignored and, should those segments
  293                          exist, their size is increased.
  294
  295                          NOTE:  The AUTOMATIC and COMMON segments have
  296                          certain conventional uses.  The AUTOMATIC data
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          9    
  297                          segment is used by most Bull language processors.
  298                          User programs should therefore avoid use of this segment
  299                          unless it is known to be unused.  The COMMON
  300                          segment is so named because it is the only data
  301                          segment which can be common to programs which
  302                          call one another via the M$LINK monitor service; the
  303                          COMMON data segment can thus be used to pass data.
  304
  305                          On successful completion of M$GDS, the vector
  306                          returned into the field named by RESULTS frames
  307                          the entire allocated Data Segment.  (Specifying
  308                          SEGSIZE=0 results in a returned vector framing the
  309                          currently allocated Data Segment.)  If no
  310                          allocation can be made, the RESULTS area is set to
  311                          VECTOR(NIL) and the alternate return is taken.
  312
  313                          NOTE:  As the size of some Data Segments
  314                          increases, it may be necessary to modify the base
  315                          addresses of other segments. Therefore any data
  316                          segment descriptors which the user has in
  317                          descriptor registers may be invalidated following
  318                          a call to M$GDS (or M$FDS).  Such descriptors
  319                          should be reloaded from the Linkage Segment
  320                          following every call to M$GDS or M$FDS.
  321                          (This function is handled automatically for programs
  322                          using PL-6 and the Bull-supplied macro library.)
  323                          A new M$GDS option, VIRTONLY, allows only virtual
  324                          segment space to be allocated, without assigning
  325                          physical pages to the allocated virtual space.
  326                          First, M$CVM can be used to map the virtual pages
  327                          in the segment onto physical pages in the system,
  328                          if SPMM privilege is active.  Next, the pages can
  329                          be allocated by reference.  When a virtual page is
  330                          referenced that has no physical page assigned, a
  331                          physical page will be acquired and mapped in, if
  332                          it would not exceed the user's authorization.
  333                          This option can be particularly useful in
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          10   
  334                          conjunction with data segments allocated in a run
  335                          unit.  The storage will not actually be allocated
  336                          until used (or unless initialized).  This can
  337                          provide, for example, a method for dynamic
  338                          allocation in FORTRAN.  In such a case, simply
  339                          allocate a large common section (uninitialized)
  340                          in a data segment; then, when the program is
  341                          executed, only the pages actually used will be
  342                          allocated and charged.
  343
  344                          The form of the call for this service is:
  345
  346                          CALL M$GDS (FPT_GDS) [ALTRET (label)];
  347
  348                          The parameters for this service are:                    */
  349
  350
  351       %MACRO FPT_GDS(FPTN=FPT_GDS,
  352                   STCLASS=STATIC,
  353                   RESULTS=NIL,
  354                   SEGSIZE=0,
  355                   VIRTONLY(YES='1'B,NO='0'B)='0'B,
  356                  PROTECTION(DSREAD='400'O,DSWRITE='600'O)='600'O,
  357                   AUTOSEG(YES='1'B,NO='0'B)='0'B,
  358                   COMMON(YES='1'B,NO='0'B)='0'B,
  359                   FREE(YES='1'B,NO='0'B)='0'B);
  360
  361       %LSET LISTDIR='0'B;
  362       %LSET LISTEXP='1'B;
  363       %LSET LISTCOM='0'B;
  364       %LSET LISTSUB='1'B;
  365       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  366       %IF (SUBSTR(STR,0,6)='STATIC') OR
  367       (SUBSTR(STR,0,8)='CONSTANT') OR
  368       (SUBSTR(STR,0,3)='EXT');
  369       %LSET INIT=CHARTEXT('INIT');
  370       %ELSE;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          11   
  371       %LSET INIT=CHARTEXT('/*');
  372       %ENDIF;
  373
  374
  375      DCL 1 FPTN STCLASS,
  376            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  377            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
  378                          /*K* RESULTS = VARIABLE specifies the location of a
  379                          2-word area in which the returned vector is to be
  380                          stored. The VLP_VECTOR macro can be used to
  381                          generate this area. The contents of the SEGID
  382                          field in this area at the call to M$GDS
  383                          determines whether an existing segment is
  384                          enlarged or a new segment is allocated as
  385                          described above.  The default is NIL.                   */
  386            2 V DALIGNED,
  387              3 AUTOSEG# BIT(1) %INIT(AUTOSEG)%CHARTEXT('/**/') UNAL, /* AUTOMATIC SEGMENT DESIRED */
  388                     /*K* AUTOSEG = {YES|NO}  specifies, if YES, that the Automatic
  389                     Segment is desired.  The default is NO.                      */
  390              3 COMMON# BIT(1) %INIT(COMMON)%CHARTEXT('/**/') UNAL, /* COMMON SEGMENT DESIRED */
  391                          /*K* COMMON = {YES|NO}  specifies, if YES, that the Common
  392                          Segment is desired.  The default is NO.                 */
  393              3 FREE# BIT(1) UNAL %INIT(FREE)%CHARTEXT('/**/'),
  394                          /*K* FREE = {YES|NO} specifies, if YES, that if the
  395                          requested memory is not available (user or
  396                          installation page limit reached), then no memory
  397                          at all is to be allocated.  The default (FREE=NO)
  398                          allocates as much memory to the segment as
  399                          possible before returning an error code
  400                          indicating that the entire requested amount was
  401                          unavailable.                                            */
  402              3 VIRTONLY# BIT(1) UNAL %INIT(VIRTONLY)%CHARTEXT('/**/'),
  403                     /*K* VIRTONLY = {YES|NO} specifies that no pages are to
  404                          be allocated to the virtual space created.  This is
  405                          done to allow M$CVM to map the virtual space
  406                          onto real pages in memory.  The default is NO. */
  407
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          12   
  408              3 * BIT(5) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  409              3 PROTECTION# BIT(9) UNAL %INIT(PROTECTION)%CHARTEXT('/**/'),
  410                          /*K* PROTECTION = {DSREAD|DSWRITE} specifies the
  411                          access protection to be placed on the entire data
  412                          segment.  The protection on an existing data segment
  413                          may not be changed by M$GDS, however M$PDS may be
  414                          used for this purpose.                                  */
  415              3 SEGSIZE# UBIN HALF UNAL %INIT(SEGSIZE)%CHARTEXT('/**/'); /* # OF WDS IN DATA SEG */
  416                          /*K* SEGSIZE = VALUE-DEC(1-n) specifies the number of
  417                          words to get or to add to an existing data segment.
  418                          The default is 0.
  419                          */
  420       %MEND;
  421
  422
  423
  424
  425
  426
  427                                    /* MONITOR FREE DYNAMIC SEGMENT SPACE PROCEDURE */
  428                          /*F* NAME: M$FDS - Free/Diminish Data Segment.
  429
  430                          The M$FDS service frees space from a previously
  431                          allocated Data Segment. The SEGSIZE parameter is
  432                          interpreted as the number of words to release from
  433                          the Data Segment, indicated either by the SEGID
  434                          field of the passed RESULTS variable, by AUTOSEG=YES or by
  435                          COMMON=YES.  The SEGSIZE parameter is rounded up to
  436                          the nearest doubleword, as for M$GDS.
  437
  438                          As with M$GDS, specifying a zero size results in
  439                          a returned vector framing the currently allocated
  440                          portion of the Data Segment. This vector is
  441                          inserted into a two-word field named by the
  442                          RESULTS parameter.
  443
  444                          When all the space allocated to a Data Segment
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          13   
  445                          has been released, the returned vector will be
  446                          VECTOR(NIL).
  447
  448                          If any input-output operation is outstanding when
  449                          M$FDS is called, the user is aborted.
  450
  451                          The form of the call for this service is:
  452
  453                          CALL M$FDS (FPT_FDS) [ALTRET (label)];
  454
  455                          The parameters for this service are as follows:         */
  456
  457
  458       %MACRO FPT_FDS(FPTN=FPT_FDS,
  459                   STCLASS=STATIC,
  460                   RESULTS=NIL,
  461                   SEGSIZE=0,
  462                   AUTOSEG(YES='1'B,NO='0'B)='0'B,
  463                   COMMON(YES='1'B,NO='0'B)='0'B);
  464
  465       %LSET LISTDIR='0'B;
  466       %LSET LISTEXP='1'B;
  467       %LSET LISTCOM='0'B;
  468       %LSET LISTSUB='1'B;
  469       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  470       %IF (SUBSTR(STR,0,6)='STATIC') OR
  471       (SUBSTR(STR,0,8)='CONSTANT') OR
  472       (SUBSTR(STR,0,3)='EXT');
  473       %LSET INIT=CHARTEXT('INIT');
  474       %ELSE;
  475       %LSET INIT=CHARTEXT('/*');
  476       %ENDIF;
  477
  478
  479      DCL 1 FPTN STCLASS,
  480            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  481            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          14   
  482                          /*K* RESULTS = VARIABLE specifies the location of a
  483                          2-word area in which the returned vector is to be
  484                          stored. Prior to that, RESULTS specifies the
  485                          SEGID of the area to be freed or diminished.
  486
  487                          The default is NIL.
  488                          */
  489            2 V DALIGNED,
  490              3 AUTOSEG# BIT(1) %INIT(AUTOSEG)%CHARTEXT('/**/') UNAL, /* AUTOMATIC SEG DESIRED */
  491                          /*K* AUTOSEG = {YES|NO} specifies that the Automatic
  492                          Segment is desired.  The default is NO.                 */
  493              3 COMMON# BIT(1) %INIT(COMMON)%CHARTEXT('/**/') UNAL, /* COMMON SEG DESIRED */
  494                          /*K* COMMON = {YES|NO} specifies that the Common Segment
  495                          is desired.  The default is NO.                         */
  496              3 * BIT(16) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  497              3 SEGSIZE# UBIN HALF UNAL %INIT(SEGSIZE)%CHARTEXT('/**/'); /* # OF WDS IN DATA SEG */
  498                          /*K* SEGSIZE = VALUE-DEC(1-n) specifies the number of
  499                          words to free, or if 0, that a vector framing the
  500                          segment is to be returned in RESULTS.
  501
  502                          The default is 0.
  503                          */
  504       %MEND;
  505
  506
  507
  508
  509
  510
  511                          /*F* NAME: M$PDS - Protect Data Segment.
  512
  513                          The M$PDS procedure allows a user to change the
  514                          access protection on an entire data segment. The
  515                          options are to limit the data segment to read-only
  516                          access or to grant it full read/write access.
  517
  518                          The form of the call for this service is:
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          15   
  519
  520                          CALL M$PDS (FPT_PDS) [ALTRET (label)];
  521
  522                          The parameters for this service are as follows:         */
  523
  524
  525      %MACRO FPT_PDS(FPTN=FPT_PDS,
  526                  STCLASS=STATIC,
  527                  RESULTS=NIL,
  528                  PROTECTION(DSREAD='400'O,DSWRITE='600'O)='600'O);
  529
  530      %LSET LISTDIR='0'B;
  531      %LSET LISTEXP='1'B;
  532      %LSET LISTCOM='0'B;
  533      %LSET LISTSUB='1'B;
  534       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  535       %IF (SUBSTR(STR,0,6)='STATIC') OR
  536       (SUBSTR(STR,0,8)='CONSTANT') OR
  537       (SUBSTR(STR,0,3)='EXT');
  538       %LSET INIT=CHARTEXT('INIT');
  539       %ELSE;
  540       %LSET INIT=CHARTEXT('/*');
  541       %ENDIF;
  542
  543
  544      DCL 1 FPTN STCLASS,
  545            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  546            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
  547                          /*K* RESULTS = VARIABLE specifies the location of a
  548                          2-word area in which the vector describing the
  549                          data segment to have its protection modified is
  550                          to be stored.  For this service, the SEGID is the
  551                          only portion of the vector examined.
  552                          The default is NIL.
  553                          */
  554
  555            2 V DALIGNED,
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          16   
  556              3 * BIT(27) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  557              3 PROTECTION# BIT(9) UNAL %INIT(PROTECTION)%CHARTEXT('/**/');
  558                          /*K* PROTECTION = {DSREAD|DSWRITE} specifies the
  559                          access protection to be placed on the entire data
  560                          segment.  The default is DSWRITE.                      */
  561      %MEND;
  562
  563
  564
  565
  566
  567
  568                                              /* MONITOR GET DYNAMIC PAGE PROCEDURE */
  569                          /*F* NAME: M$GDP - Get Dynamic Pages.
  570
  571                          The M$GDP service allocates a specified number of
  572                          pages beginning with the next higher page
  573                          of the Dynamic Data Area within the user's
  574                          Instruction Segment. It also increments that page
  575                          number until one of the following events takes
  576                          place:
  577
  578                          TU
  579                          1.  The requested number of pages is allocated.
  580
  581                          2.  The installation-set or user-set limit on the
  582                              number of physical pages is reached.
  583
  584                          3.  The instruction segment is full.
  585
  586                          4.  A page allocated by M$GVP or M$CVM is encountered.
  587                          TF
  588
  589                          Cases 2-4 result in an alternate return.
  590                          In all cases, a vector is returned framing the
  591                          pages that were allocated.  Note that requesting
  592                          zero pages will
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          17   
  593                          return VECTOR(NIL).
  594
  595                          NOTE: This service is restricted to user-mode
  596                          programs. Attempted use by a debugger, command
  597                          processor, or Alternate Shared Library results in
  598                          an alternate return.
  599
  600                          The form of the call for this service is:
  601
  602                          CALL M$GDP (FPT_GDP) [ALTRET (label)];
  603
  604                          The parameters for this service are as follows:         */
  605
  606
  607       %MACRO FPT_GDP(FPTN=FPT_GDP,
  608                   STCLASS=STATIC,
  609                   RESULTS=NIL,
  610                   PAGES=0);
  611
  612       %LSET LISTDIR='0'B;
  613       %LSET LISTEXP='1'B;
  614       %LSET LISTCOM='0'B;
  615       %LSET LISTSUB='1'B;
  616       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  617       %IF (SUBSTR(STR,0,6)='STATIC') OR
  618       (SUBSTR(STR,0,8)='CONSTANT') OR
  619       (SUBSTR(STR,0,3)='EXT');
  620       %LSET INIT=CHARTEXT('INIT');
  621       %ELSE;
  622       %LSET INIT=CHARTEXT('/*');
  623       %ENDIF;
  624
  625
  626      DCL 1 FPTN STCLASS,
  627            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  628            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
  629                          /*K* RESULTS = VARIABLE specifies the location of a
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          18   
  630                          2-word area in which the returned vector is to be
  631                          stored.  The VLP_VECTOR macro is used to
  632                          generate this area.  The default is NIL.                */
  633            2 V DALIGNED,
  634              3 PAGES# UBIN %INIT(PAGES)%CHARTEXT('/**/'); /* # OF PAGES TO GET     */
  635                          /*K* PAGES = VALUE-DEC(1-n) specifies the number of
  636                          pages to be obtained.  The default is 0.                */
  637       %MEND;
  638
  639
  640
  641
  642
  643
  644                                         /* MONITOR FREE DYNAMIC PAGE PROCEDURE     */
  645                                    /* NOTE THAT THIS CAN USE SAME FPT AS M$GDP     */
  646                          /*F* NAME: M$FDP - Free Dynamic Pages.
  647
  648                          The M$FDP service releases a specified number of
  649                          pages at successively lower addresses of the
  650                          Dynamic Data Area within the user's Instruction
  651                          Segment, beginning with the current highest page.
  652                          It also decrements that page number
  653                          until one of the following events takes place:
  654
  655                          TU
  656                          1.  The requested number of pages has been released.
  657
  658                          2.  The first available virtual page is released.
  659                          TF
  660
  661                          The second case results in an ALTRET. In either
  662                          case, a vector is returned framing the remaining
  663                          allocated Dynamic Data Area. If all dynamic pages
  664                          have been released, the returned vector will be
  665                          VECTOR(NIL).
  666
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          19   
  667                          Pages released are marked as "not in memory" and
  668                          any subsequent reference to these pages results in
  669                          a fault.
  670
  671                          NOTE: This service is restricted to user-mode
  672                          programs. Attempted use by a debugger, command
  673                          processor, or Alternate Shared Library results in
  674                          an alternate return.
  675
  676                          The form of the call for this service is:
  677
  678                          CALL M$FDP (FPT_FDP) [ALTRET (label)];
  679
  680                          The parameters for this service are as follows:         */
  681
  682
  683       %MACRO FPT_FDP(FPTN=FPT_FDP,
  684                   STCLASS=STATIC,
  685                   RESULTS=NIL,
  686                   PAGES=0);
  687
  688       %LSET LISTDIR='0'B;
  689       %LSET LISTEXP='1'B;
  690       %LSET LISTCOM='0'B;
  691       %LSET LISTSUB='1'B;
  692       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  693       %IF (SUBSTR(STR,0,6)='STATIC') OR
  694       (SUBSTR(STR,0,8)='CONSTANT') OR
  695       (SUBSTR(STR,0,3)='EXT');
  696       %LSET INIT=CHARTEXT('INIT');
  697       %ELSE;
  698       %LSET INIT=CHARTEXT('/*');
  699       %ENDIF;
  700
  701
  702      DCL 1 FPTN STCLASS,
  703            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          20   
  704            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
  705                          /*K* RESULTS = VARIABLE specifies the location of a
  706                          2-word area in which the returned vector is to be
  707                          stored.  The VLP_VECTOR macro is used to
  708                          generate this area.  The default is NIL.                */
  709            2 V DALIGNED,
  710              3 PAGES# UBIN %INIT(PAGES)%CHARTEXT('/**/'); /* # OF PAGES TO FREE    */
  711                          /*K* PAGES = VALUE-DEC(1-n) specifies the number of
  712                          pages to be freed.  The default is 0.                   */
  713       %MEND;
  714
  715
  716
  717
  718
  719
  720                                              /* MONITOR GET VIRTUAL PAGE PROCEDURE */
  721                          /*F* NAME: M$GVP - Get Virtual Page.
  722
  723                          The M$GVP service allocates a specific page of
  724                          virtual memory within the Instruction Segment of
  725                          the user program. If the request is allowed,
  726                          access to the page is set to write-allowed. The
  727                          ALTRET is taken if one of the following events
  728                          takes place:
  729
  730                          TU
  731                          1.  The installation-set or user-set limit on the
  732                              number of physical pages allowed would be
  733                              exceeded.
  734
  735                          2.  The page has already been allocated.
  736
  737                          3.  The page requested is outside the user
  738                              Instruction Segment.
  739                          TF
  740
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          21   
  741                          No results are returned by this service.
  742
  743                          NOTE: This service is restricted to user-mode
  744                          programs. Attempted use by a debugger, command
  745                          processor, or Alternate Shared Library results in
  746                          an alternate return.
  747
  748                          The form of the call for this service is:
  749
  750                          CALL M$GVP (FPT_GVP) [ALTRET (label)];
  751
  752                          The parameter for this service is as follows:           */
  753
  754
  755       %MACRO FPT_GVP(FPTN=FPT_GVP,
  756                   STCLASS=STATIC,
  757                     WSQ=0,
  758                   PNO=0);
  759
  760       %LSET LISTDIR='0'B;
  761       %LSET LISTEXP='1'B;
  762       %LSET LISTCOM='0'B;
  763       %LSET LISTSUB='1'B;
  764       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  765       %IF (SUBSTR(STR,0,6)='STATIC') OR
  766       (SUBSTR(STR,0,8)='CONSTANT') OR
  767       (SUBSTR(STR,0,3)='EXT');
  768       %LSET INIT=CHARTEXT('INIT');
  769       %ELSE;
  770       %LSET INIT=CHARTEXT('/*');
  771       %ENDIF;
  772
  773
  774      DCL 1 FPTN STCLASS,
  775            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  776            2 V DALIGNED,
  777              3 WSQ# UBIN(9) UNAL %INIT(WSQ)%CHARTEXT('/**/'),
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          22   
  778                          /*K* WSQ = VALUE-DEC(0-511).  This specifies the working space
  779                     quarter in which the page is to be allocated.  Zero specifies
  780                     the caller's instruction segment, non-zero specifies a WSQ
  781                     previously returned on an open of a Virtual Segment.
  782                     */
  783              3 * UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
  784              3 PNO# UBIN(18) UNAL %INIT(PNO)%CHARTEXT('/**/'); /* VIRTUAL PG # TO GET */
  785       %MEND;
  786
  787
  788
  789                          /*K* PNO = VALUE-DEC(0-255) specifies the
  790                          Instruction-Segment-relative virtual page number
  791                          to obtain.  The default is 0.                           */
  792
  793
  794
  795                                         /* MONITOR FREE VIRTUAL PAGE PROCEDURE     */
  796                          /*F* NAME: M$FVP - Free Virtual Page.
  797
  798                          The M$FVP service releases a specific page of
  799                          virtual memory within the Instruction Segment of
  800                          the user program. The indicated page is released
  801                          except when the request is for a page that was not
  802                          allocated via M$GVP or M$GDP, in which case the
  803                          ALTRET is taken. Pages of data or procedure that
  804                          are linked with the program (those assembled or
  805                          compiled with the program) may not be released
  806                          using this mechanism. No results are returned by
  807                          this service.
  808
  809                          NOTE: This service is restricted to user-mode
  810                          programs. Attempted use by a debugger, command
  811                          processor, or Alternate Shared Library results in
  812                          an alternate return.
  813
  814                          The form of the call for this service is:
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          23   
  815
  816                          CALL M$FVP (FPT_FVP)) [ALTRET (label)];
  817
  818                          The parameter for this service is as follows:           */
  819
  820
  821       %MACRO FPT_FVP(FPTN=FPT_FVP,
  822                   STCLASS=STATIC,
  823                     WSQ=0,
  824                   PNO=0);
  825
  826       %LSET LISTDIR='0'B;
  827       %LSET LISTEXP='1'B;
  828       %LSET LISTCOM='0'B;
  829       %LSET LISTSUB='1'B;
  830       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  831       %IF (SUBSTR(STR,0,6)='STATIC') OR
  832       (SUBSTR(STR,0,8)='CONSTANT') OR
  833       (SUBSTR(STR,0,3)='EXT');
  834       %LSET INIT=CHARTEXT('INIT');
  835       %ELSE;
  836       %LSET INIT=CHARTEXT('/*');
  837       %ENDIF;
  838
  839
  840      DCL 1 FPTN STCLASS,
  841            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  842            2 V DALIGNED,
  843              3 WSQ# UBIN(9) UNAL %INIT(WSQ)%CHARTEXT('/**/'),
  844                          /*K* WSQ = VALUE-DEC(0-511).  This specifies the working space
  845                          quarter from which the page is to be freed.  Zero specifies
  846                          the caller's instruction segment, non-zero specifies a WSQ
  847                          previously returned on an open of a Virtual Segment.
  848                          */
  849              3 * UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
  850              3 PNO# UBIN(18) UNAL %INIT(PNO)%CHARTEXT('/**/'); /* VIRTUAL PG # TO FREE */
  851                          /*K* PNO = VALUE-DEC(0-255) specifies the
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          24   
  852                          Instruction-Segment-relative page number to free.
  853                          The default is 0.                                       */
  854       %MEND;
  855
  856
  857
  858
  859
  860
  861                                         /* MONITOR GET DYNAMIC LIMITS PROCEDURE    */
  862                          /*F* NAME: M$GDDL - Get Dynamic Data Limits.
  863
  864                          The M$GDDL service returns several limiting
  865                          values of the Dynamic Data Area. The Dynamic Data
  866                          Area is the region of memory in the Instruction
  867                          Segment from which dynamic and sometimes virtual
  868                          pages are allocated. This is the only memory
  869                          management service routine which returns more than
  870                          the usual NSA vector to the area named by the
  871                          RESULTS parameter. M$GDDL returns three words of
  872                          information. The first two are an NSA vector
  873                          framing the entire Dynamic Data Area available to
  874                          the calling program. The third word returned
  875                          contains the number of pages (right-justified)
  876                          which the program may yet obtain through any of
  877                          the "get" monitor services. For a user with a
  878                          large memory allocation, this value may be greater
  879                          than the number of unallocated pages in the
  880                          Dynamic Data Area, as pages allocated to the Data
  881                          Segments will also be counted against this value.
  882
  883                          NOTE: This service is restricted to user-mode
  884                          programs. Attempted use by a debugger, command
  885                          processor, or Alternate Shared Library results in
  886                          an alternate return.
  887
  888                          The form of the call for this service is:
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          25   
  889
  890                          CALL M$GDDL (FPT_GDDL) [ALTRET (label)];
  891
  892                          The parameter for this service is as follows:           */
  893
  894
  895       %MACRO FPT_GDDL(FPTN=FPT_GDDL,
  896                    STCLASS=STATIC,
  897                   RESULTS=NIL);
  898
  899       %LSET LISTDIR='0'B;
  900       %LSET LISTEXP='1'B;
  901       %LSET LISTCOM='0'B;
  902       %LSET LISTSUB='1'B;
  903       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  904       %IF (SUBSTR(STR,0,6)='STATIC') OR
  905       (SUBSTR(STR,0,8)='CONSTANT') OR
  906       (SUBSTR(STR,0,3)='EXT');
  907       %LSET INIT=CHARTEXT('INIT');
  908       %ELSE;
  909       %LSET INIT=CHARTEXT('/*');
  910       %ENDIF;
  911
  912
  913      DCL 1 FPTN STCLASS DALIGNED,
  914            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/');
  915                          /*K* RESULTS = VARIABLE specifies the location of a
  916                          three-word area which may be generated by invoking
  917                          the VLP_GDDL macro.  The use of this parameter is
  918                          described above.
  919
  920                          The default is NIL.
  921                          */
  922       %MEND;
  923
  924
  925
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          26   
  926
  927
  928
  929
  930                                         /* MONITOR STEAL PHYSICAL PAGE PROCEDURE   */
  931                          /*F* NAME: M$STLPP - Steal Physical Page.
  932                          The M$STLPP service acquires a physical memory page
  933                          from the monitor's free page pool without explicitly
  934                          assigning it to any process. This service can be
  935                          requested only by a process with Extended MM privilege.
  936                          The capability to "steal" physical pages from the
  937                          monitor is a carefully controlled method for obtaining
  938                          additional memory. Only a limited number of pages
  939                          can be obtained in this manner (as defined by the
  940                          STEALPAGES option furnished by the TIGR processor and
  941                          described in the CP-6 System Support Reference Manual).
  942
  943                          Another mode of M$STLPP is available to any user having
  944                          the Get Physical Page privilege. If this privilege is
  945                          active in the calling program, then physical pages are
  946                          allocated directly from the system free page pool with
  947                          no limit set on the number which can be obtained other
  948                          than that imposed by the number of free memory pages in
  949                          the system. Pages allocated in this mode are truly lost
  950                          to the system; it is entirely the user's responsibility
  951                          to keep track of their usage. The only method of
  952                          returning pages acquired in this mode is to call M$RSPP
  953                          with the Get Physical Page privilege active. This mode
  954                          of M$STLPP is intended solely for the use of certain
  955                          system maintenance processors.
  956
  957                          If a "stealable" physical page is available, the BASE
  958                          field of the returned vector will contain the page
  959                          number of the allocated page. (The M$CVM service must
  960                          be called in order to access the page.) If no physical
  961                          pages are available, the returned vector will be
  962                          VECTOR(NIL).
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          27   
  963
  964                          The form of the call for this service is:
  965
  966                          CALL M$STLPP (FPT_STLPP) [ALTRET (label)];
  967
  968                          The parameter for M$STLPP is:                           */
  969
  970
  971       %MACRO FPT_STLPP(FPTN=FPT_STLPP,
  972                     STCLASS=STATIC,
  973                     RESULTS=NIL);
  974
  975       %LSET LISTDIR='0'B;
  976       %LSET LISTEXP='1'B;
  977       %LSET LISTCOM='0'B;
  978       %LSET LISTSUB='1'B;
  979       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  980       %IF (SUBSTR(STR,0,6)='STATIC') OR
  981       (SUBSTR(STR,0,8)='CONSTANT') OR
  982       (SUBSTR(STR,0,3)='EXT');
  983       %LSET INIT=CHARTEXT('INIT');
  984       %ELSE;
  985       %LSET INIT=CHARTEXT('/*');
  986       %ENDIF;
  987
  988
  989      DCL 1 FPTN STCLASS DALIGNED,
  990            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/');
  991                          /*K* RESULTS = VARIABLE specifies the location of a
  992                          two-word area in which the stolen physical page
  993                          number is returned, right-justified, in the second
  994                          word.  The default is NIL.
  995                          */
  996       %MEND;
  997
  998
  999
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          28   
 1000
 1001
 1002
 1003                                         /* MONITOR RELEASE STOLEN PAGE PROCEDURE   */
 1004                          /*F* NAME: M$RSPP - Release Stolen Page.
 1005
 1006                          The M$RSPP service returns stolen physical pages
 1007                          to the monitor.  It returns the page to the
 1008                          monitor's free page pool, ensuring first that the
 1009                          returned page was, in fact, a stolen page.  The
 1010                          physical page number of the page being released is
 1011                          passed to M$RSPP in the BASE field of the vector
 1012                          in the area named by the RESULTS parameter.
 1013
 1014                          The form of the call for this service is:
 1015
 1016                          CALL M$RSPP (FPT_RSPP) [ALTRET (label)];
 1017
 1018                          The parameter for this service is as follows:
 1019                          */
 1020
 1021
 1022       %MACRO FPT_RSPP(FPTN=FPT_RSPP,
 1023                    STCLASS=STATIC,
 1024                    RESULTS=NIL);
 1025
 1026       %LSET LISTDIR='0'B;
 1027       %LSET LISTEXP='1'B;
 1028       %LSET LISTCOM='0'B;
 1029       %LSET LISTSUB='1'B;
 1030       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1031       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1032       (SUBSTR(STR,0,8)='CONSTANT') OR
 1033       (SUBSTR(STR,0,3)='EXT');
 1034       %LSET INIT=CHARTEXT('INIT');
 1035       %ELSE;
 1036       %LSET INIT=CHARTEXT('/*');
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          29   
 1037       %ENDIF;
 1038
 1039
 1040      DCL 1 FPTN STCLASS DALIGNED,
 1041            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/');
 1042                          /*K* RESULTS = VARIABLE specifies the location of a
 1043                          2-word area in which the stolen physical page
 1044                          number is passed, right-justified, in the second
 1045                          word.  The default is NIL.
 1046                          */
 1047       %MEND;
 1048
 1049
 1050
 1051
 1052
 1053
 1054                                         /* MONITOR CHANGE VIRTUAL MAP PROCEDURE    */
 1055                          /*F* NAME: M$CVM - Change Virtual Map.
 1056
 1057                          The M$CVM service allows a privileged processor or
 1058                          program to examine, display or modify a real physical
 1059                          memory page after mapping it into its working space
 1060                          quarter (WSQ). Users with Special MM privilege can map
 1061                          real pages into the Instruction Segment. Users with
 1062                          Extended MM privilege can map pages anywhere in their
 1063                          virtual space and thus can effect a change in their
 1064                          overall virtual structure unknown to the monitor. M$CVM
 1065                          must be used with exceedingly great care.
 1066
 1067                          A typical case of M$CVM involves mapping a
 1068                          physical memory page onto a previously unallocated
 1069                          virtual page in the user's Instruction Segment.
 1070                          In this case, the WSQFLAG bit in the FPT is off.
 1071                          The number of the specified physical page is
 1072                          placed in the specified Instruction
 1073                          Segment-relative virtual page entry in the user's
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          30   
 1074                          Page Table.  Access to the page is set to
 1075                          read-only for a user with the Special MM
 1076                          Privilege, and to full read/write access for a
 1077                          user with the Extended MM Privilege.
 1078
 1079                          By setting the WSQFLAG, the user (assuming
 1080                          Extended MM Privilege) can map a particular page
 1081                          of physical memory to any previously unassigned
 1082                          virtual page within the user's WSQ.  The
 1083                          virtual page number in this case is interpreted as
 1084                          WSQ-relative, and access to the page will always
 1085                          be set to read/write.
 1086
 1087                          Physical pages made accessible in this way are not
 1088                          considered as being assigned to the user, unless
 1089                          this was initially the case.
 1090
 1091                          Specifying a physical page number of -1 results
 1092                          in effectively removing the specified virtual
 1093                          page from the user's working space. Its access
 1094                          is set to "not in memory", provided that the
 1095                          page was established as a result of an M$CVM
 1096                          operation.
 1097                          .SPB 0
 1098                          NOTE: M$CVM may be used to change the physical page
 1099                          previously mapped to a virtual page via M$CVM without
 1100                          first freeing the virtual page.
 1101
 1102
 1103                          The form of the call for this service is:
 1104
 1105                          CALL M$CVM (FPT_CVM) [ALTRET (label)];
 1106
 1107                          Parameters for M$CVM are:                               */
 1108
 1109
 1110       %MACRO FPT_CVM(FPTN=FPT_CVM,
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          31   
 1111                   STCLASS=STATIC,
 1112                     WSQ=0,
 1113                   VPNO=0,
 1114                   PPNO=0,
 1115                   PHYSICAL(YES='1'B,NO='0'B)='1'B,
 1116                   WSQFLG(YES='1'B,NO='0'B)='0'B);
 1117
 1118       %LSET LISTDIR='0'B;
 1119       %LSET LISTEXP='1'B;
 1120       %LSET LISTCOM='0'B;
 1121       %LSET LISTSUB='1'B;
 1122       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1123       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1124       (SUBSTR(STR,0,8)='CONSTANT') OR
 1125       (SUBSTR(STR,0,3)='EXT');
 1126       %LSET INIT=CHARTEXT('INIT');
 1127       %ELSE;
 1128       %LSET INIT=CHARTEXT('/*');
 1129       %ENDIF;
 1130
 1131
 1132      DCL 1 FPTN STCLASS,
 1133            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1134            2 V DALIGNED,
 1135              3 WSQFLG# BIT(1) %INIT(WSQFLG)%CHARTEXT('/**/') UNAL, /* WHETHER TO USE WSQ OR ISR VPNO */
 1136                          /*K* WSQFLG = {YES|NO}   specifies, if YES, that the
 1137                          virtual page number is relative to the start of the
 1138                          caller's working space. If WSQFLG=NO, the virtual page
 1139                          number is relative to the start of the Instruction
 1140                          Segment.  The default is NO.                            */
 1141              3 PHYSICAL# BIT(1) UNAL %INIT(PHYSICAL)%CHARTEXT('/**/'),
 1142                          /*K* PHYSICAL = {YES|NO}   specifies, if NO, that the
 1143                          physical page number is relative to the start of
 1144                          working-space quarter 0.  If PHYSICAL=YES, the
 1145                          physical page number
 1146                          is placed directly in the user's page table without
 1147                          being mapped through the WSQ0 map.  This option is
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          32   
 1148                          meaningful only on a DPS90.  The default is YES.        */
 1149              3 * BIT(34) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1150              3 PPNO# SBIN %INIT(PPNO)%CHARTEXT('/**/'), /* PHYS. PG TO MAP FROM    */
 1151                          /*K* PPNO = VALUE-DEC(0-n)   specifies the physical page
 1152                          to map from. The default is 0.                          */
 1153              3 WSQ# UBIN(9) UNAL %INIT(WSQ)%CHARTEXT('/**/'),
 1154                          /*K* WSQ = VALUE-DEC(0-511).  This specifies the working space
 1155                          quarter in which the page is to be mapped.  Zero
 1156                          specifies the caller's WSQ; otherwise WSQ should contain
 1157                          a WSQ that was returned on an open of a Virtual Segment.
 1158                          */
 1159              3 * UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
 1160              3 VPNO# UBIN(18) UNAL %INIT(VPNO)%CHARTEXT('/**/'); /* VIRT. PG. TO MAP ONTO */
 1161                          /*K* VPNO = VALUE-DEC(0-n)   specifies the virtual page
 1162                          to map onto. The default is 0.                          */
 1163       %MEND;
 1164
 1165
 1166
 1167
 1168
 1169
 1170                                         /* MONITOR SET MEMORY PROTECT PROCEDURE    */
 1171                          /*F* NAME: M$SMPRT - Set Memory Protection.
 1172
 1173                          The M$SMPRT service sets or resets the Page Table
 1174                          word control field bits for a specified range of
 1175                          virtual pages, based upon the privilege available
 1176                          to the program making the request.  The six
 1177                          control flag bits have the following significance:
 1178
 1179                          }
 1180                          }FLAGS-Binary Value PTW Bit    Meaning
 1181                          }------------------ -------    -------
 1182                          }
 1183                          }'100000'           30         Page in memory (read access)
 1184                          }
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          33   
 1185                          }'010000'           31         Page may be written
 1186                          }
 1187                          }'001000'           32         Housekeeping page
 1188                          }
 1189                          }'000100'           33         Page available for I/O
 1190                          }
 1191                          }'000010'           34         Page has been modified (set
 1192                          }                              by hardware)
 1193                          }
 1194                          }'000001'           35         Page has been accessed (set
 1195                          }                              by hardware)
 1196                          }
 1197
 1198                          For the user without the Extended MM Privileges,
 1199                          this procedure call cannot be used to reduce the
 1200                          amount of protection on a given page or pages from
 1201                          their initial value, and these pages must lie
 1202                          within the user's Instruction Segment (i.e., the
 1203                          WSQ-FLAG bit may not be set, and the virtual page
 1204                          numbers affected are interpreted as Instruction
 1205                          Segment-relative).  Thus a user can mark his data
 1206                          pages as "read-only" or even "no access", and can
 1207                          mark his procedure pages "no access".  He can also
 1208                          restore these pages to their initial protection
 1209                          values.
 1210
 1211                          In order to affect the other Page Table control
 1212                          bits in any manner, the user program or processor
 1213                          must have the Extended MM Privilege.  Such a
 1214                          privileged process has almost complete control
 1215                          over the setting and resetting of the Page Table
 1216                          control information, and one must therefore
 1217                          exercise exceedingly great caution when attempting
 1218                          any such manipulation.
 1219
 1220                          The form of the call for this service is:
 1221
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          34   
 1222                          CALL M$SMPRT (FPT_SMPRT) [ALTRET (label)];
 1223
 1224                          The parameters for this service are as follows:         */
 1225
 1226
 1227       %MACRO FPT_SMPRT(FPTN=FPT_SMPRT,
 1228                     STCLASS=STATIC,
 1229                    VPNO=0,
 1230                    NUMPGS=0,
 1231                    FLAGS='000000'B,
 1232                     WSQFLG(YES='1'B,NO='0'B)='0'B);
 1233
 1234       %LSET LISTDIR='0'B;
 1235       %LSET LISTEXP='1'B;
 1236       %LSET LISTCOM='0'B;
 1237       %LSET LISTSUB='1'B;
 1238       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1239       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1240       (SUBSTR(STR,0,8)='CONSTANT') OR
 1241       (SUBSTR(STR,0,3)='EXT');
 1242       %LSET INIT=CHARTEXT('INIT');
 1243       %ELSE;
 1244       %LSET INIT=CHARTEXT('/*');
 1245       %ENDIF;
 1246
 1247
 1248      DCL 1 FPTN STCLASS,
 1249            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1250            2 V DALIGNED,
 1251              3 WSQFLG# BIT(1) %INIT(WSQFLG)%CHARTEXT('/**/') UNAL, /* WHETHER VPNO IS WSQ OR ISR */
 1252                          /*K* WSQFLG = {YES|NO}  specifies, if YES, that VPNO is
 1253                          relative to the work space; if NO, that VPNO is relative
 1254                          to the Instruction Segment.  The default is NO.         */
 1255              3 * BIT(29) %INIT('0'B)%CHARTEXT('/**/') UNAL, /* FILLER SPACE        */
 1256              3 FLAGS# BIT(6) %INIT(FLAGS)%CHARTEXT('/**/') UNAL, /* PAGE ACCESS CONTROL FLAGS */
 1257                          /*K* FLAGS = VALUE-BIT(6)    specifies a 6-bit value
 1258                          that is used to set or reset the Page Table word
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          35   
 1259                          control field bits. The significance of these flags is
 1260                          shown above. The default is '000000'B.                  */
 1261              3 NUMPGS# UBIN(18) UNAL %INIT(NUMPGS)%CHARTEXT('/**/'), /* # OF PGS   */
 1262                          /*K* NUMPGS = VALUE-DEC(0-n)  specifies number of pages.
 1263                          The default is 0.                                       */
 1264              3 VPNO# UBIN(18) UNAL %INIT(VPNO)%CHARTEXT('/**/'); /* STARTING PG #  */
 1265                          /*K* VPNO = VALUE-DEC(0-n)   specifies starting page
 1266                          number. The default is 0.                               */
 1267       %MEND;
 1268
 1269
 1270
 1271
 1272
 1273
 1274                                    /* MONITOR SET SOFTWARE CONTROL FLAGS PROCEDURE */
 1275                          /*F* NAME: M$SSC - Set Software Control Flags.
 1276
 1277                          The M$SSC service allows a processor with Extended MM
 1278                          privilege to alter the setting of the 10-bit software
 1279                          control flags field in the Page Table for a specified
 1280                          range of virtual pages.  Several of these software
 1281                          control flags are reserved for internal MM use only,
 1282                          while the others are available for other software
 1283                          controlled functions, as indicated in the following
 1284                          table.
 1285
 1286                          }
 1287                          }FLAGS-Binary Value PTW Bit    Meaning
 1288                          }------------------ -------    -------
 1289                          }
 1290                          }'1000000000'       18         Page was write-protected
 1291                          }                              for data breakpoint
 1292                          }
 1293                          }'0100000000'       19         Page is in recovery dump
 1294                          }
 1295                          }'0011111000'       20-24      Reserved
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          36   
 1296                          }
 1297                          }'0000000100'       25         Virtual page is used as
 1298                          }                              FPOOL buffer
 1299                          }
 1300                          }'0000000010'       26         Page was established via M$CVM
 1301                          }
 1302                          }'0000000001'       27         Page is owned by the user
 1303                     }
 1304
 1305                     The form of the call for this service is:
 1306
 1307                     CALL M$SSC (FPT_SSC) [ALTRET (label)];
 1308
 1309                     The parameters for this service are as follows:              */
 1310
 1311
 1312       %MACRO FPT_SSC(FPTN=FPT_SSC,
 1313                    STCLASS=STATIC,
 1314                    VPNO=0,
 1315                    NUMPGS=0,
 1316                    FLAGS='0000000000'B,
 1317                   WSQFLG(YES='1'B,NO='0'B)='0'B,
 1318                   SEGFLG(YES='1'B,NO='0'B)='0'B,
 1319                   SEGID='0'B);
 1320
 1321       %LSET LISTDIR='0'B;
 1322       %LSET LISTEXP='1'B;
 1323       %LSET LISTCOM='0'B;
 1324       %LSET LISTSUB='1'B;
 1325       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1326       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1327       (SUBSTR(STR,0,8)='CONSTANT') OR
 1328       (SUBSTR(STR,0,3)='EXT');
 1329       %LSET INIT=CHARTEXT('INIT');
 1330       %ELSE;
 1331       %LSET INIT=CHARTEXT('/*');
 1332       %ENDIF;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          37   
 1333
 1334
 1335      DCL 1 FPTN STCLASS,
 1336            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1337            2 V DALIGNED,
 1338              3 WSQFLG# BIT(1) %INIT(WSQFLG)%CHARTEXT('/**/') UNAL, /* WHETHER VPNO IS WSQ OR ISR */
 1339                          /*K* WSQFLG = {YES|NO}  specifies, if YES, that VPNO is
 1340                          relative to the work space; if NO, that VPNO is relative
 1341                          to the Instruction Segment.  The default is NO.         */
 1342              3 SEGFLG# BIT(1) %INIT(SEGFLG)%CHARTEXT('/**/') UNAL, /* WHETHER VPNO IS SEG RELATIVE */
 1343                          /*K*  SEGFLG = {YES|NO}.  Specifies, if YES, that VPNO is
 1344                          relative to the SEGID; if NO, that WSQFLG specifies
 1345                          what VPNO is relative to. The default is NO.
 1346                                */
 1347              3 * BIT(12) %INIT('0'B)%CHARTEXT('/**/') UNAL, /* FILLER SPACE        */
 1348              3 SEGID# BIT(12) %INIT(SEGID)%CHARTEXT('/**/') UNAL, /* SEGID         */
 1349                          /*K* SEGID = VALUE-BIT(12)   specifies the 12-bit
 1350                          user's SEGID that the VPNO is relative to if SEGFLG=yes.
 1351                          The default is '0'B.                                    */
 1352              3 FLAGS# BIT(10) %INIT(FLAGS)%CHARTEXT('/**/') UNAL, /* PAGE ACCESS CONTROL FLAGS */
 1353                          /*K* FLAGS = VALUE-BIT(10)    specifies a 10-bit value
 1354                          that is used to alter the setting of certain bits in
 1355                the software control flags field.  The default is '0000000000'B.
 1356                */
 1357              3 NUMPGS# UBIN(18) UNAL %INIT(NUMPGS)%CHARTEXT('/**/'), /* # OF PGS   */
 1358                          /*K* NUMPGS = VALUE-DEC(1-n)    specifies number of
 1359                          pages.  The default is 0.                               */
 1360              3 VPNO# UBIN(18) UNAL %INIT(VPNO)%CHARTEXT('/**/'); /* STARTING PG #  */
 1361                          /*K* VPNO = VALUE-DEC(0-n)   specifies starting page
 1362                          number.  The default is 0.                              */
 1363       %MEND;
 1364
 1365
 1366
 1367
 1368
 1369
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          38   
 1370                                              /* MONITOR MAKE-NEW-USER PROCEDURE    */
 1371
 1372
 1373       %MACRO FPT_MAKUSER(FPTN=FPT_MAKUSER,
 1374                       STCLASS = STATIC,
 1375                       JITPP = 0,
 1376                       HJITPP = 0,
 1377                       ROPP = 0);
 1378
 1379       %LSET LISTDIR='0'B;
 1380       %LSET LISTEXP='1'B;
 1381       %LSET LISTCOM='0'B;
 1382       %LSET LISTSUB='1'B;
 1383       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1384       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1385       (SUBSTR(STR,0,8)='CONSTANT') OR
 1386       (SUBSTR(STR,0,3)='EXT');
 1387       %LSET INIT=CHARTEXT('INIT');
 1388       %ELSE;
 1389       %LSET INIT=CHARTEXT('/*');
 1390       %ENDIF;
 1391
 1392
 1393      DCL 1 FPTN STCLASS,
 1394            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1395            2 V DALIGNED,
 1396              3 JITPP# UBIN %INIT(JITPP)%CHARTEXT('/**/'), /* PPNO OF NEW USER'S JIT */
 1397              3 HJITPP# UBIN %INIT(HJITPP)%CHARTEXT('/**/'), /* PPNO OF NEW USER'S HJIT */
 1398              3 ROPP# UBIN %INIT(ROPP)%CHARTEXT('/**/'); /* PPNO OF NEW USER'S ROSEG */
 1399       %MEND;
 1400
 1401
 1402
 1403
 1404
 1405                                    /* MONITOR STORE ACCESS DESCRIPTOR PROCEDURE    */
 1406                          /*F* NAME: M$SAD - Store Access Descriptor.
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          39   
 1407
 1408                          The M$SAD service fills in any of the user's eight
 1409                          special access descriptors with any of the
 1410                          descriptors of the monitor linkage segment,
 1411                          allowing the user to view anything visible to the
 1412                          monitor.  The M$SAD service is only available to
 1413                          users with Special or Extended MM privilege.
 1414                          Write access is granted to users with Extended MM
 1415                          privilege.  Segment identifiers are available in the
 1416                          file B_SEGIDS_C in the system account.
 1417
 1418                          The form of the call for this service is:
 1419
 1420                          CALL M$SAD (FPT_SAD) [ALTRET (label)];
 1421
 1422                          The parameters for this service are as follows:         */
 1423
 1424
 1425       %MACRO FPT_SAD(FPTN=FPT_SAD,
 1426                      STCLASS=STATIC,
 1427                      USERSID='0'O,
 1428                      MONSID='0'O);
 1429
 1430       %LSET LISTDIR='0'B;
 1431       %LSET LISTEXP='1'B;
 1432       %LSET LISTCOM='0'B;
 1433       %LSET LISTSUB='1'B;
 1434       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1435       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1436       (SUBSTR(STR,0,8)='CONSTANT') OR
 1437       (SUBSTR(STR,0,3)='EXT');
 1438       %LSET INIT=CHARTEXT('INIT');
 1439       %ELSE;
 1440       %LSET INIT=CHARTEXT('/*');
 1441       %ENDIF;
 1442
 1443
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          40   
 1444      DCL 1 FPTN STCLASS,
 1445            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1446            2 V DALIGNED,
 1447              3 * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/'),
 1448              3 USERSID# BIT(12) UNAL %INIT(USERSID)%CHARTEXT('/**/'), /* SEGID TO FILL IN */
 1449                          /*K* USERSID = VALUE-BIT(12)    specifies the user's
 1450                          SEGID of the special access descriptor that is to be
 1451                          filled.  The default is '0'B.                           */
 1452              3 * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/'),
 1453              3 MONSID# BIT(12) UNAL %INIT(MONSID)%CHARTEXT('/**/'); /* SEGID OF MON DESCRIPTOR */
 1454                          /*K* MONSID = VALUE-BIT(12)   specifies the SEGID
 1455                          of any monitor linkage segment descriptor.
 1456                          The default is '0'B.                                    */
 1457       %MEND;
 1458
 1459
 1460
 1461
 1462
 1463
 1464                          /* MONITOR STORE DESCRIPTOR IN LINKAGE SEGMENT PROCEDURE  */
 1465                          /*F* NAME: M$STD - Store Descriptor.
 1466
 1467                          The M$STD service allows a user to store a
 1468                          descriptor, shrunk from those available to him,
 1469                          into any of his eight special access descriptors.
 1470                          This allows him to establish independently
 1471                          addressable segments within the virtual space
 1472                          visible to him via those descriptors already in
 1473                          his linkage segment.  The access rights for the
 1474                          new descriptor are identical to those of the
 1475                          descriptor being shrunk.
 1476
 1477                          The form of the call for this service is:
 1478
 1479                          CALL M$STD (FPT_STD) [ALTRET (label)];
 1480
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          41   
 1481                          Parameters for M$STD are:
 1482                          */
 1483
 1484
 1485       %MACRO FPT_STD(FPTN=FPT_STD,
 1486                   STCLASS=STATIC,
 1487                   USERSID='0'O,
 1488                   AREA=NIL);
 1489
 1490       %LSET LISTDIR='0'B;
 1491       %LSET LISTEXP='1'B;
 1492       %LSET LISTCOM='0'B;
 1493       %LSET LISTSUB='1'B;
 1494       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1495       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1496       (SUBSTR(STR,0,8)='CONSTANT') OR
 1497       (SUBSTR(STR,0,3)='EXT');
 1498       %LSET INIT=CHARTEXT('INIT');
 1499       %ELSE;
 1500       %LSET INIT=CHARTEXT('/*');
 1501       %ENDIF;
 1502
 1503
 1504      DCL 1 FPTN STCLASS DALIGNED,
 1505            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1506            2 AREA_,                          /* AREA TO BUILD DESCRIPTOR FOR       */
 1507              3 BOUND UBIN(20) UNAL %INIT(SIZEV(AREA))%CHARTEXT('/**/'),
 1508              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 1509              3 AREA$ PTR %INIT(ADDR(AREA))%CHARTEXT('/**/'),
 1510                          /*K* AREA = VARIABLE    specifies the area (PL-6
 1511                          structure) for which a descriptor is to be built
 1512                          (shrunken).  The default is NIL.
 1513                          */
 1514            2 V DALIGNED,
 1515              3 * UBIN(24) UNAL %INIT(0)%CHARTEXT('/**/'),
 1516              3 USERSID# BIT(12) UNAL %INIT(USERSID)%CHARTEXT('/**/'); /* WHERE IN LS TO PUT DESCRIPTOR */
 1517                          /*K* USERID = VALUE-BIT(12)    specifies the 12-bit
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          42   
 1518                          user's SEGID of the special access descriptor
 1519                          where the new descriptor is to be stored.
 1520                          The default is 0.
 1521                          */
 1522       %MEND;
 1523
 1524
 1525
 1526
 1527
 1528
 1529                          /*F* NAME: M$PAS - POP Argument Stack.
 1530
 1531                          The M$PAS service removes one or more descriptors
 1532                          from the hardware Argument Stack.  If there are no
 1533                          descriptors on the Argument Stack, the alternate
 1534                          return is taken.
 1535
 1536                          To remove one descriptor in the stack, the form of
 1537                          the call to this service is as follows:
 1538
 1539                          CALL M$PAS [ALTRET (label)];
 1540
 1541                          To remove more that one descriptor, the form of the call
 1542                          for this service is as follows:
 1543
 1544                          CALL M$PAS (FPT_PAS) [ALTRET (label)];
 1545
 1546                          The parameter for this service is then as follows:
 1547
 1548                          */
 1549
 1550      %MACRO FPT_PAS (FPTN=FPT_PAS,
 1551         STCLASS=STATIC,
 1552         DESCRIPTORS=1);
 1553
 1554      %LSET LISTDIR='0'B;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          43   
 1555      %LSET LISTEXP='1'B;
 1556      %LSET LISTCOM='0'B;
 1557      %LSET LISTSUB='1'B;
 1558      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1559      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1560       (SUBSTR(STR,0,8)='CONSTANT') OR
 1561       (SUBSTR(STR,0,3)='EXT');
 1562       %LSET INIT=CHARTEXT('INIT');
 1563      %ELSE;
 1564       %LSET INIT=CHARTEXT('/*');
 1565      %ENDIF;
 1566
 1567
 1568      DCL 1 FPTN STCLASS DALIGNED,
 1569            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1570            2 V DALIGNED,
 1571              3 DESCRIPTORS# UBIN(36) %INIT(DESCRIPTORS)%CHARTEXT('/**/'),
 1572                          /*K* DESCRIPTORS = VALUE-DEC(1-n)    specifies the
 1573                          number of descriptors to remove from the Argument
 1574                          Stack.  If the value specified is equal
 1575                          to or greater than the number of descriptors currently
 1576                          on the stack, all descriptors are removed and the stack
 1577                          is marked empty.  Default = 1.*/
 1578
 1579              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1580      %MEND;
 1581
 1582
 1583
 1584
 1585
 1586                          /* MONITOR DECLARE SUSPECTED BAD PHYSICAL PAGE PROCEDURE  */
 1587                          /*F* NAME: M$BADPP - Declare Bad Physical Page.
 1588
 1589                          The M$BADPP service allows a user with diagnostic
 1590                          privilege to declare a particular physical page as
 1591                          suspected of being bad (e.g., because of a high
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          44   
 1592                          incidence of reported parity errors).  The
 1593                          physical page is removed from normal use as soon
 1594                          as it becomes unused (freed) by whatever CP-6
 1595                          process may currently own it.  It is then placed
 1596                          on the "bad" page list and made available to test
 1597                          and diagnostic programs (see M$GBPL).
 1598
 1599                          Note that it may not be possible for a "suspect"
 1600                          page to be removed from active use during normal
 1601                          CP-6 operation (e.g., it may be part of the
 1602                          monitor or a resident ghost or command program).
 1603                          However, during a system recovery all "suspect"
 1604                          pages are removed from the available page list and
 1605                          placed on the "bad" page list before the monitor
 1606                          is brought back into memory.  Thus, recovery from
 1607                          failing memory pages should be possible in all
 1608                          cases except when the failing pages are located in
 1609                          the first few pages of real memory occupied by
 1610                          fault and interrupt locations, the IOM control
 1611                          data, and the AARDVARK boot program.
 1612
 1613                          The form of the call for this service is:
 1614
 1615                          CALL M$BADPP (FPT_BADPP) [ ALTRET (label)];
 1616
 1617                          The parameter for M$BADPP is:
 1618                          */
 1619
 1620
 1621       %MACRO FPT_BADPP(FPTN=FPT_BADPP,
 1622                     STCLASS=STATIC,
 1623                     PPNO=0);
 1624
 1625       %LSET LISTDIR='0'B;
 1626       %LSET LISTEXP='1'B;
 1627       %LSET LISTCOM='0'B;
 1628       %LSET LISTSUB='1'B;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          45   
 1629       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1630       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1631       (SUBSTR(STR,0,8)='CONSTANT') OR
 1632       (SUBSTR(STR,0,3)='EXT');
 1633       %LSET INIT=CHARTEXT('INIT');
 1634       %ELSE;
 1635       %LSET INIT=CHARTEXT('/*');
 1636       %ENDIF;
 1637
 1638
 1639      DCL 1 FPTN STCLASS DALIGNED,
 1640            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1641            2 V DALIGNED,
 1642              3 PPNO# UBIN %INIT(PPNO)%CHARTEXT('/**/');
 1643                          /*K* PPNO = VALUE-DEC(0-n)    specifies the physical page
 1644                          number of the suspect page.  The default is 0.
 1645                          */
 1646       %MEND;
 1647
 1648
 1649
 1650
 1651
 1652
 1653                     /* MONITOR RETURN BAD PHYSICAL PAGE TO NORMAL USE PROCEDURE    */
 1654                          /*F* NAME: M$GOODPP - Return Page to Normal Use.
 1655
 1656                          The M$GOODPP service allows a user with diagnostic
 1657                          privilege to return to normal use a page which was
 1658                          on the "bad" page list and has presumably been
 1659                          determined to be good by memory test and
 1660                          diagnostics.  If the page is marked "still in
 1661                          test" (see M$MPL), an alternate return results.
 1662
 1663                          The form of the call for this service is:
 1664
 1665                          CALL M$GOODPP (FPT_GOODPP) [ALTRET (label)];
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          46   
 1666
 1667                          Parameters for M$GOODPP are:
 1668                          */
 1669
 1670
 1671       %MACRO FPT_GOODPP(FPTN=FPT_GOODPP,
 1672                     STCLASS=STATIC,
 1673                     PPNO=0);
 1674
 1675       %LSET LISTDIR='0'B;
 1676       %LSET LISTEXP='1'B;
 1677       %LSET LISTCOM='0'B;
 1678       %LSET LISTSUB='1'B;
 1679       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1680       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1681       (SUBSTR(STR,0,8)='CONSTANT') OR
 1682       (SUBSTR(STR,0,3)='EXT');
 1683       %LSET INIT=CHARTEXT('INIT');
 1684       %ELSE;
 1685       %LSET INIT=CHARTEXT('/*');
 1686       %ENDIF;
 1687
 1688
 1689      DCL 1 FPTN STCLASS DALIGNED,
 1690            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1691            2 V DALIGNED,
 1692              3 PPNO# UBIN %INIT(PPNO)%CHARTEXT('/**/');
 1693                          /*K* PPNO =  VALUE-DEC(0-n)    specifies the physical page
 1694                          number of the page which is to be returned to
 1695                          normal use.  The default is 0.
 1696                          */
 1697       %MEND;
 1698
 1699
 1700
 1701
 1702
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          47   
 1703
 1704                                         /* MONITOR GET BAD PAGE LIST PROCEDURE     */
 1705                          /*F* NAME: M$GBPL - Get Bad Page List.
 1706
 1707                          The M$GBPL service allows a user with diagnostic
 1708                          privilege to obtain a list of physical page
 1709                     numbers which have been removed from use by the CP-6 system
 1710                     (i.e., are on an internal "bad" page list).  The
 1711                     user specifies a range of physical page numbers
 1712                     within which he is interested in locating any bad
 1713                     pages, as well as the maximum number of bad pages
 1714                     within that range whose page numbers he wants
 1715                     returned.  The page numbers, as well as a count of
 1716                     the number actually returned, are passed back to
 1717                     the user in a structure defined by the VLP_PGLIST
 1718                     macro (see the description of VLP_PGLIST in this
 1719                     section).
 1720
 1721                     The form of the call for this service is:
 1722
 1723                     CALL M$GBPL (FPT_GBPL) [ALTRET (label)];
 1724
 1725                     Parameters for M$GBPL are:
 1726                     */
 1727
 1728
 1729       %MACRO FPT_GBPL(FPTN=FPT_GBPL,
 1730                    STCLASS=STATIC,
 1731                    HIGHPP=0,
 1732                    LOWPP=0,
 1733                    MAXPGS=0,
 1734                    PGLIST=NIL);
 1735
 1736       %LSET LISTDIR='0'B;
 1737       %LSET LISTEXP='1'B;
 1738       %LSET LISTCOM='0'B;
 1739       %LSET LISTSUB='1'B;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          48   
 1740       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1741       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1742       (SUBSTR(STR,0,8)='CONSTANT') OR
 1743       (SUBSTR(STR,0,3)='EXT');
 1744       %LSET INIT=CHARTEXT('INIT');
 1745       %ELSE;
 1746       %LSET INIT=CHARTEXT('/*');
 1747       %ENDIF;
 1748
 1749
 1750      DCL 1 FPTN STCLASS DALIGNED,
 1751            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1752            2 PGLIST_,
 1753              3 BOUND UBIN(20) UNAL %INIT(SIZEV(PGLIST))%CHARTEXT('/**/'),
 1754              3 * BIT(12) UNAL %INIT('7772'O)%CHARTEXT('/**/'),
 1755              3 PGLIST$ PTR %INIT(ADDR(PGLIST))%CHARTEXT('/**/'),
 1756                          /*K* PGLIST = VARIABLE    specifies an area into which
 1757                          M$GBPL returns the list of bad page numbers which
 1758                          it finds, as well as the number of pages that it
 1759                          found.  The VLP_PGLIST macro described later in
 1760                          this section is provided to generate the structure
 1761                          for the area.  The default is NIL.
 1762                          */
 1763            2 V DALIGNED,
 1764              3 HIGHPP# UBIN(18) UNAL %INIT(HIGHPP)%CHARTEXT('/**/'),
 1765                          /*K* HIGHPP = VALUE-DEC(0-n)    specifies the high physical
 1766                          page number of the range to be searched.
 1767                          The default is 0.
 1768                          */
 1769              3 LOWPP# UBIN(18) UNAL %INIT(LOWPP)%CHARTEXT('/**/'),
 1770                          /*K* LOWPP = VALUE-DEC(0-n)    specifies the low physical
 1771                          page number of the range to be searched.
 1772                          The default is 0.
 1773                          */
 1774              3 MAXPGS# UBIN %INIT(MAXPGS)%CHARTEXT('/**/');
 1775                          /*K* MAXPGS = VALUE-DEC(0-n)    specifies the maximum number
 1776                          of physical page numbers to be returned.
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          49   
 1777                          The default is 0.
 1778                          */
 1779       %MEND;
 1780
 1781
 1782
 1783
 1784
 1785
 1786
 1787
 1788
 1789                               /* MONITOR MARK PAGE LIST IN TEST MODE PROCEDURE     */
 1790
 1791                          /*F* NAME: M$MPL - Mark Pages as in Test Mode.
 1792
 1793                          The M$MPL service allows a user with diagnostic
 1794                          privilege to mark a list of previously obtained
 1795                          "bad" physical pages (see M$GBPL) as in test mode.
 1796                          This prevents other diagnostic users from
 1797                          accessing or releasing to normal use any of the
 1798                          pages so marked.
 1799
 1800                          The form of the call for this service is:
 1801
 1802                          CALL M$MPL (FPT_MPL) [ALTRET (label)];
 1803
 1804                          The parameter for M$MPL is:
 1805                          */
 1806
 1807
 1808       %MACRO FPT_MPL(FPTN=FPT_MPL,
 1809                   STCLASS=STATIC,
 1810                   PGLIST=NIL);
 1811
 1812       %LSET LISTDIR='0'B;
 1813       %LSET LISTEXP='1'B;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          50   
 1814       %LSET LISTCOM='0'B;
 1815       %LSET LISTSUB='1'B;
 1816       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1817       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1818       (SUBSTR(STR,0,8)='CONSTANT') OR
 1819       (SUBSTR(STR,0,3)='EXT');
 1820       %LSET INIT=CHARTEXT('INIT');
 1821       %ELSE;
 1822       %LSET INIT=CHARTEXT('/*');
 1823       %ENDIF;
 1824
 1825
 1826      DCL 1 FPTN STCLASS DALIGNED,
 1827            2 PGLIST_,
 1828              3 BOUND UBIN(20) UNAL %INIT(SIZEV(PGLIST))%CHARTEXT('/**/'),
 1829              3 * BIT(12) UNAL %INIT('7772'O)%CHARTEXT('/**/'),
 1830              3 * BIT(4) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1831              3 PGLIST$ PTR %INIT(ADDR(PGLIST))%CHARTEXT('/**/');
 1832                          /*K* PGLIST = VARIABLE    specifies the list of
 1833                          physical pages to be marked as in test mode, as
 1834                          well as the number of pages in this list.  (The
 1835                          VLP_PGLIST macro described later in this section
 1836                          is provided to generate the structure for this
 1837                          area).
 1838                          */
 1839       %MEND;
 1840
 1841
 1842
 1843
 1844
 1845
 1846
 1847
 1848                          /* MONITOR UN-MARK PAGE LIST (FROM TEST MODE) PROCEDURE   */
 1849
 1850                          /*F* NAME: M$UMPL - Remove Pages from Test Mode.
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          51   
 1851
 1852                          The M$UMPL service allows a user with diagnostic
 1853                          privilege to "un-mark" a list of physical pages so
 1854                          that they are no longer in test mode.  This allows
 1855                          access to these pages by other diagnostic programs
 1856                          as well as allowing their return to normal service
 1857                          via the M$GOODPP service.
 1858
 1859                          The form of the call for this service is:
 1860
 1861                          CALL M$UMPL (FPT_UMPL) [ALTRET (label)];
 1862
 1863                          The parameter for M$UMPL is:
 1864                          */
 1865
 1866
 1867       %MACRO FPT_UMPL(FPTN=FPT_UMPL,
 1868                   STCLASS=STATIC,
 1869                   PGLIST=NIL);
 1870
 1871       %LSET LISTDIR='0'B;
 1872       %LSET LISTEXP='1'B;
 1873       %LSET LISTCOM='0'B;
 1874       %LSET LISTSUB='1'B;
 1875       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1876       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1877       (SUBSTR(STR,0,8)='CONSTANT') OR
 1878       (SUBSTR(STR,0,3)='EXT');
 1879       %LSET INIT=CHARTEXT('INIT');
 1880       %ELSE;
 1881       %LSET INIT=CHARTEXT('/*');
 1882       %ENDIF;
 1883
 1884
 1885      DCL 1 FPTN STCLASS DALIGNED,
 1886            2 PGLIST_,
 1887              3 BOUND UBIN(20) UNAL %INIT(SIZEV(PGLIST))%CHARTEXT('/**/'),
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          52   
 1888              3 * BIT(12) UNAL %INIT('7772'O)%CHARTEXT('/**/'),
 1889              3 * BIT(4) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1890              3 PGLIST$ PTR %INIT(ADDR(PGLIST))%CHARTEXT('/**/');
 1891                          /*K* PGLIST = VARIABLE    specifies the list of
 1892                          physical pages to be marked as no longer in test
 1893                          mode, as well as the number of pages in this list.
 1894                          The VLP_PGLIST macro described later in this
 1895                          section is provided to generate the structure for
 1896                          this area.
 1897                          */
 1898       %MEND;
 1899
 1900
 1901
 1902
 1903                          /*F* NAME: VLP_PGLIST
 1904
 1905                          The VLP_PGLIST macro creates the list of physical
 1906                          page numbers used by the M$GBPL, M$MPL, and M$UMPL
 1907                          services.  It has one parameter, NPAGES,
 1908                          which specifies the maximum number of physical
 1909                          page numbers which may be stored in the structure.
 1910                          */
 1911
 1912       %MACRO VLP_PGLIST(FPTN=VLP_PGLIST,
 1913                      STCLASS=STATIC,
 1914                      NPAGES=0);
 1915
 1916       %LSET LISTDIR='0'B;
 1917       %LSET LISTEXP='1'B;
 1918       %LSET LISTCOM='0'B;
 1919       %LSET LISTSUB='1'B;
 1920       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1921       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1922       (SUBSTR(STR,0,8)='CONSTANT') OR
 1923       (SUBSTR(STR,0,3)='EXT');
 1924       %LSET INIT=CHARTEXT('INIT');
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          53   
 1925       %ELSE;
 1926       %LSET INIT=CHARTEXT('/*');
 1927       %ENDIF;
 1928
 1929
 1930      DCL 1 FPTN STCLASS DALIGNED,
 1931            2 NPAGES# UBIN(18) UNAL %INIT(NPAGES)%CHARTEXT('/**/'),
 1932                          /*K* NPAGES = VALUE-DEC(0-n)  Specifies the
 1933                          actual number of physical page numbers in
 1934                          VLP_PGLIST.PGLIST (see below).  It is set by the
 1935                          M$GBPL service, and may be modified by the user to
 1936                          reflect changes made to the page number list.
 1937                          */
 1938            2 PGLIST(0:NPAGES) UBIN(18) UNAL %INIT(0*0)%CHARTEXT('/**/');
 1939                          /*K* PGLIST (0:NPAGES) UBIN(18)  Is an array containing
 1940                          the list of page numbers used by the M$GBPL,
 1941                          M$MPL, and M$UMPL services.  PGLIST (0) is never
 1942                          used:  the first physical page number in the list
 1943                          in VLP_PGLIST.PGLIST(1).
 1944                          */
 1945       %MEND;
 1946
 1947
 1948
 1949
 1950                               /* MACRO FOR BUILDING A VECTOR (MM 'RESULTS' AREA)   */
 1951                          /*F* NAME: VLP_VECTOR
 1952
 1953                          The VLP_VECTOR macro creates a vector which may be
 1954                          used as the RESULTS area for the M$GDS, M$FDS,
 1955                          M$GDP and M$FDP services, as well as for any other
 1956                          situations in which a vector is desired.
 1957
 1958                          For M$GDS and M$FDS, the SEGID field in the
 1959                          VLP_VECTOR area can contain a parameter for the
 1960                          monitor service.  For M$GDP and M$FDP, the
 1961                          VLP_VECTOR is submitted to the monitor with the
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          54   
 1962                          fields set to the defaults.  On return from the
 1963                          monitor services, the VLP_VECTOR area contains a
 1964                          vector framing the allocated memory.  The fields
 1965                          of interest to the user are the second word, BASE
 1966                          and SEGID, which form a PL-6 pointer by which the
 1967                          user can access the allocated memory.  (The
 1968                          monitor also stores values in the VLP_VECTOR area
 1969                          before returning the resulting vector to the user.
 1970                          These fields are used by the monitor in
 1971                          maintaining the user's segment descriptors.)
 1972
 1973                          Fields in the VLP_VECTOR area are as follows:           */
 1974
 1975       %MACRO VLP_VECTOR(FPTN=VLP_VECTOR,
 1976                      STCLASS=STATIC,
 1977                      VSIZE=0,
 1978                      FLAGS='777'O,
 1979                      TYP(COPY='00'B,SHRINK='01'B,XSHRINK='10'B,DSHRINK='11'B)='01'B,
 1980                      BASE=0,
 1981                      SEGID='6014'O);
 1982
 1983       %LSET LISTDIR='0'B;
 1984       %LSET LISTEXP='1'B;
 1985       %LSET LISTCOM='0'B;
 1986       %LSET LISTSUB='1'B;
 1987       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1988       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1989       (SUBSTR(STR,0,8)='CONSTANT') OR
 1990       (SUBSTR(STR,0,3)='EXT');
 1991       %LSET INIT=CHARTEXT('INIT');
 1992       %ELSE;
 1993       %LSET INIT=CHARTEXT('/*');
 1994       %ENDIF;
 1995
 1996
 1997      DCL 1 FPTN STCLASS DALIGNED,
 1998            2 W1,
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          55   
 1999              3 VSIZE# UBIN(20) UNAL %INIT(VSIZE)%CHARTEXT('/**/'),
 2000                          /*K* VSIZE = VALUE-DEC(0-n)   specifies the byte size
 2001                          minus one (PL-6 SIZEV built-in function) of the
 2002                          area.  (If TYP=SHRINK, VSIZE is used in modifying
 2003                          the descriptor identified by SEGID.)  The default is 0. */
 2004              3 FLAGS# BIT(9) UNAL %INIT(FLAGS)%CHARTEXT('/**/'),
 2005                          /*K* FLAGS = VALUE-BIT(9)   specifies the bit mask.
 2006                          This bit mask is logically ANDed with the
 2007                          existing flags in the descriptor to update the
 2008                          descriptor.  The default is '777'O.                     */
 2009              3 TYP# BIT(2) UNAL %INIT(TYP)%CHARTEXT('/**/'),
 2010                          /*K* TYP = {COPY|SHRINK} specifies whether the
 2011                          descriptor identified by SEGID is to be copied or
 2012                          modified.  When modified (by SHRINK)  its BASE
 2013                          and/or BOUND are modified by VSIZE and BASE stored
 2014                          in VLP_VECTOR.  The default is SHRINK.                  */
 2015              3 * UBIN(5) UNAL %INIT(0)%CHARTEXT('/**/'),
 2016            2 W2,
 2017              3 BASE# UBIN(20) UNAL %INIT(BASE)%CHARTEXT('/**/'),
 2018                          /*K* BASE = VALUE-DEC(0-n)   specifies the byte
 2019                          offset from the start of the segment identified
 2020                          by SEGID. (BASE is used in modifying  the
 2021                          descriptor when TYP=SHRINK.)  The default is 0.         */
 2022              3 * UBIN(4) UNAL %INIT(0)%CHARTEXT('/**/'),
 2023              3 SEGID# BIT(12) UNAL %INIT(SEGID)%CHARTEXT('/**/'),
 2024                          /*K* SEGID = VALUE-BIT(12)   specifies the SEGID of
 2025                          the segment descriptor.  Segment identifiers are
 2026                          defined in the file B_SEGIDS_C in the :LIBRARY
 2027                          account.  The default is '6014'O.                       */
 2028            2 PTR$ REDEF W2 PTR;
 2029                          /*K* PTR$ is an alternate method of referring to
 2030                          word two of the vector as a pointer, as its structure
 2031                          is identical to that of an NSA pointer.                 */
 2032       %MEND;
 2033
 2034
 2035
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          56   
 2036
 2037
 2038                          /*F* NAME: VLP_GDDL
 2039
 2040                          The VLP_GDDL macro creates the three-word structure used
 2041                          as the RESULTS area for the M$GDDL service.             */
 2042
 2043      %MACRO VLP_GDDL(FPTN=VLP_GDDL,
 2044                      STCLASS=STATIC);
 2045
 2046       %LSET LISTDIR='0'B;
 2047       %LSET LISTEXP='1'B;
 2048       %LSET LISTCOM='0'B;
 2049       %LSET LISTSUB='1'B;
 2050       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2051       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2052       (SUBSTR(STR,0,8)='CONSTANT') OR
 2053       (SUBSTR(STR,0,3)='EXT');
 2054       %LSET INIT=CHARTEXT('INIT');
 2055       %ELSE;
 2056       %LSET INIT=CHARTEXT('/*');
 2057       %ENDIF;
 2058
 2059
 2060      DCL 1 FPTN STCLASS DALIGNED,
 2061            2 DDL_,
 2062              3 DDSIZE# UBIN(20) UNAL %INIT(0)%CHARTEXT('/**/'),
 2063                          /*K* VLP_GDDL.DDL_.DDSIZE# will be set to the byte
 2064                          size minus one of the currently allocated dynamic
 2065                          data area.                                              */
 2066              3 * UBIN(16) UNAL %INIT(0)%CHARTEXT('/**/'),
 2067              3 DD$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 2068                          /*K* VLP_GDDL.DDL_.DD$ will be set to point to the
 2069                          first word of the currently allocated dynamic data
 2070                          area.                                                   */
 2071            2 AVAIL_PGS# UBIN WORD %INIT(0)%CHARTEXT('/**/');
 2072                          /*K* VLP_GDDL.AVAIL_PGS# will be set to the remaining
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          57   
 2073                          number of physical pages of memory which may yet
 2074                          be allocated to the program issuing the call to the
 2075                          M$GDDL service.                                         */
 2076      %MEND;
 2077                /*F* NAME: M$VIRTUAL - Control a Virtual Segment.
 2078
 2079                The M$VIRTUAL monitor service allows the user to control a
 2080                virtual segment and obtain statistical information
 2081                about a segment.  The virtual segment must have been
 2082                established at a prior call to M$OPEN that specified the
 2083                VIRTUAL parameter.
 2084
 2085                The form of the call for this service is:
 2086
 2087                CALL M$VIRTUAL (FPT_VIRTUAL) [ALTRET(label)];
 2088
 2089                The parameters for the M$VIRTUAL are:
 2090       */
 2091
 2092      %MACRO FPT_VIRTUAL (FPTN=FPT_VIRTUAL,
 2093                          STCLASS=STATIC,
 2094                          SEGNUM(VS1=1,VS2=2,VS3=3)=0,
 2095                          VIRTUAL=NIL,
 2096                          CURRENT_VIRTUAL=NIL);
 2097
 2098       %LSET LISTDIR='0'B;
 2099       %LSET LISTEXP='1'B;
 2100       %LSET LISTCOM='0'B;
 2101       %LSET LISTSUB='1'B;
 2102       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2103       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2104       (SUBSTR(STR,0,8)='CONSTANT') OR
 2105       (SUBSTR(STR,0,3)='EXT');
 2106       %LSET INIT=CHARTEXT('INIT');
 2107       %ELSE;
 2108       %LSET INIT=CHARTEXT('/*');
 2109       %ENDIF;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          58   
 2110
 2111      DCL 1 FPTN STCLASS DALIGNED,
 2112            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2113            2 VIRTUAL_ VECTOR %INIT(VECTOR(VIRTUAL))%CHARTEXT('/**/'),
 2114                /*K* VIRTUAL = VARIABLE    specifies the parameters to which
 2115                the virtual segment should be changed.  This structure
 2116                is described under VLP_VIRTUAL.  This parameter is optional.
 2117       */
 2118            2 CURRENT_VIRTUAL_ VECTOR %INIT(VECTOR(CURRENT_VIRTUAL))%CHARTEXT('/**/'),
 2119           /*K* CURRENT_VIRTUAL = VARIABLE   specifies where the virtual
 2120           segment information is to be returned.  This structure is described
 2121           under VLP_VIRTUAL.  This parameter is optional.
 2122       */
 2123            2 V DALIGNED,
 2124              3 SEGNUM# UBIN(9) UNAL %INIT(SEGNUM)%CHARTEXT('/**/'),
 2125                          /*K* SEGNUM = {VS1|VS2|VS3}  Specifies which of
 2126                          the three large virtual segments is to be used for
 2127                          this file.  This parameter is required.
 2128       */
 2129              3 * (0:6) UBIN BYTE UNAL %INIT(0*0)%CHARTEXT('/**/');
 2130      %MEND;
 2131      DCL M$VIRTUAL ENTRY(1) CONV(1,3,12310) ALTRET;
 2132
 2133                                              /****************************/
 2134                                              /*    SYSTEM  CALLS                   */
 2135                                              /****************************/
 2136
 2137      DCL M$GDS ENTRY(1) CONV(1,2,12289) ALTRET;
 2138      DCL M$FDS ENTRY(1) CONV(1,2,12290) ALTRET;
 2139      DCL M$PDS ENTRY(1) CONV(1,2,12308) ALTRET;
 2140      DCL M$GDP ENTRY(1) CONV(1,2,12291) ALTRET;
 2141      DCL M$FDP ENTRY(1) CONV(1,2,12292) ALTRET;
 2142      DCL M$GVP ENTRY(1) CONV(1,1,12293) ALTRET;
 2143      DCL M$FVP ENTRY(1) CONV(1,1,12294) ALTRET;
 2144      DCL M$GDDL ENTRY(1) CONV(1,1,12300) ALTRET;
 2145      DCL M$STLPP ENTRY(1) CONV(1,1,12295) ALTRET;
 2146      DCL M$RSPP ENTRY(1) CONV(1,1,12296) ALTRET;
07:29 JUL 29 '97 MM_CP6_C.:E05SI/MM_CP6_C.:E05TUI                          59   
 2147      DCL M$CVM ENTRY(1) CONV(1,1,12297) ALTRET;
 2148      DCL M$SMPRT ENTRY(1) CONV(1,1,12298) ALTRET;
 2149      DCL M$SSC ENTRY(1) CONV(1,1,12299) ALTRET;
 2150      DCL M$MAKUSER ENTRY(1) CONV(1,1,12288) ALTRET;
 2151      DCL M$SAD ENTRY(1) CONV(1,1,12301) ALTRET;
 2152      DCL M$STD ENTRY(1) CONV(1,2,12302) ALTRET;
 2153      DCL M$BADPP ENTRY(1) CONV(1,1,12303) ALTRET;
 2154      DCL M$GOODPP ENTRY(1) CONV(1,1,12304) ALTRET;
 2155      DCL M$GBPL ENTRY(1) CONV(1,2,12305) ALTRET;
 2156      DCL M$MPL ENTRY(1) CONV(1,1,12306) ALTRET;
 2157      DCL M$UMPL ENTRY(1) CONV(1,1,12307) ALTRET;
 2158      DCL M$PAS ENTRY(1) CONV(1,1,12309) ALTRET;

