/*M* Modmove - a processor to aid in handling controlled updating */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMR,PLM=5,IND=5,CTI=5,SDI=5,MCL=10,CSI=0,ECI=0 */
MODMOVE_DRIVER: PROC MAIN;
/**/
    %INCLUDE CP_6_SUBS;
    %INCLUDE CP_6;
    %F$DCB;
    %INCLUDE B_ERRORS_C;
    %B$TCB;
    %B$EXCFR;
    %B$ALT;
    %INCLUDE U$JIT_C;
    %INCLUDE FM$FIT;
    %FM$FIT;
    %CODE04;
    %CODE09;
     %INCLUDE MODMOVE_C61;
     %INCLUDE XU_MACRO_C;
/**/
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$INPUT DCB;
DCL M$OUTPUT DCB;
DCL M$LIST DCB;
DCL CTL DCB;
/**/
DCL FORCE_MSC UBIN CONSTANT SYMDEF INIT(0);
DCL FORCE_CONTROLLED UBIN CONSTANT SYMDEF INIT(0);
/**/
DCL ACCTNAME CHAR(8) STATIC;
/**/
DCL TRACKER_BUF CHAR(80);
DCL USER_ACCN CHAR(8) STATIC;
DCL COMMANDBUF CHAR(256) STATIC;
DCL CTLBUF CHAR(80) STATIC;
DCL CONTROLLED_FLAG UBIN HALF STATIC;
DCL USER_IN_MSC UBIN STATIC;
DCL ERR_CODE BIT(36) STATIC;
DCL ERR_BUF CHAR(120) STATIC;
DCL FPARAM_BUF (0:1023) UBIN WORD STATIC;
DCL TRKBUFC CHAR(138) STATIC;
DCL 1 TRKBUF REDEF TRKBUFC,
         2 * CHAR(26),
         2 NAME CHAR(31),
         2 * CHAR(81);
DCL RD_ASN UBIN(18) STATIC;
DCL RD_RES CHAR(4) STATIC;
DCL READ_FLG BIT(1) STATIC;
DCL SAVE_VECTR VECTOR STATIC;
DCL A_VECTOR VECTOR BASED;
DCL PROT_FLG BIT(1) STATIC;
/**/
DCL ERROR UBIN HALF;
DCL FLG UBIN;
DCL BUF_LEN UBIN HALF;
DCL TRACKER_FLAG UBIN HALF;
DCL NRECS UBIN WORD;
DCL CODE UBIN;
DCL ACC_NO SBIN;
DCL ACC_LEN UBIN;
DCL LIST_ACCN CHAR(8);
/**/
DCL ACCTLEN UBIN;
/**/
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL FIT$ PTR;
/**/
    %FPT_READ(FPTN=RD_SI,DCB=M$SI,BUF=COMMANDBUF,WAIT=YES,
              STCLASS=STATIC);
/**/
     %FPT_WRITE(FPTN=WRITE_FILENAMES,DCB=M$LIST,BUF=WRITE_FILENAMES_MSG,KEY=LIST_KEY);
/**/
    %FPT_ERRMSG(CODE=ERR_CODE,BUF=ERR_BUF,OUTDCB1=M$LO,
                INCLCODE=YES,STCLASS=STATIC);
/**/
    %FPT_PROMPT(FPTN=CMD_PROMPT,PROMPT=CMDPROMPT);
    %FPT_PROMPT(FPTN=SEC_PROMPT,PROMPT=SECPROMPT);
/**/
    %FPT_PRIV(FPTN=FMSEC_PRIV,PRIV=%PR_FMSEC#);
    %FPT_PRIV(FPTN=FMEFT_PRIV,PRIV=%PR_FMEFT#);
    %FPT_PRIV(FPTN=FMREAD_PRIV,PRIV=%PR_FMREAD#);
/**/
    %FPT_FID(FPTN=WR_FID,
             TEXTFID=COMMANDBUF,
             ACCT=RD_ACCT,
             NAME=RD_FID,
             PASS=RD_PASS,
             SN=RD_SN,
             WSN=RD_WSN,
             ASN=RD_ASN,
             RES=RD_RES,
             RESULTS=RES_WR_FID,
             STCLASS=STATIC);
/**/
    %FPT_OPEN(FPTN=OPEN_TUI,
              DCB=M$INPUT,
              FUN=UPDATE,
              SHARE=IN,
              DISP=NAMED,
              NAME=RD_FID,
              ACCT=TUI_ACCT,
              ASN=FILE,
              FPARAM=FPARAM_BUF,
              STCLASS=STATIC);
/**/
  %FPT_OPEN(FPTN=OPEN_INPUT_FILE,
           DCB=M$INPUT,
           NAME=RD_FID,
           ACCT=TUI_ACCT,
           PASS=RD_PASS,
           ASN=FILE,
           FUN=UPDATE,
           FPARAM=FPARAM_BUF,
           STCLASS=STATIC);
/**/
    %FPT_OPEN(FPTN=OPEN_TEST,
              DCB=M$INPUT,
              FUN=IN,
              NAME=RD_FID,
              ASN=FILE,
              TEST=YES,
              FPARAM=FPARAM_BUF,
              STCLASS=STATIC);
/**/
     %FPT_OPEN(FPTN=OPEN_LIST_FILE,
                 DCB=M$LIST,
                 FUN=CREATE,
                 NAME=RD_FID,
                 ACCT=RD_ACCT,
                 PASS=RD_PASS,
                 CTG=YES,
                 ASN=FILE,
                 ORG=KEYED,
                 STCLASS=STATIC);
/**/
     %FPT_OPEN(FPTN=OPEN_LIST_DEV,
                 DCB=M$LIST,
                 ASN=DEVICE,
                 RES='ME',
                 FUN=UPDATE,
                 STCLASS=STATIC);
/**/
     %FPT_OPEN(FPTN=OPEN_NEXT_FILE,
                 DCB=M$INPUT,
                 FUN=IN,
                 TEST=YES,
                 NAME=RD_FID,
                 ACCT=RD_ACCT,
                 NXTF=YES,
                 FPARAM=FPARAM_BUF,
                 ASN=FILE,
                 STCLASS=STATIC);
/**/
     %FPT_OPEN(FPTN=OPEN_THIS_FILE,
                 DCB=M$INPUT,
                 FUN=IN,
                 TEST=YES,
                 NAME=RD_FID,
                 ACCT=RD_ACCT,
                 FPARAM=FPARAM_BUF,
                 ASN=FILE);
/**/
    %FPT_CLOSE(FPTN=CLOSE_TUI,
               DCB=M$INPUT,
               CHGATT=YES,
               RELG=YES,
               DISP=SAVE,
               STCLASS=STATIC);
/**/
    %FPT_CLOSE(FPTN=CLOSE_RELEASE,
               DCB=M$OUTPUT,
               DISP=RELEASE);
/**/
     %FPT_CLOSE(FPTN=CLOSE_LIST,
                 DCB=M$LIST,
                 STCLASS=STATIC);
/**/
    %VLP_ACCT(FPTN=RD_ACCT,STCLASS=STATIC);
    %VLP_NAME(FPTN=RD_FID,STCLASS=STATIC);
    %VLP_PASS(FPTN=RD_PASS,STCLASS=STATIC);
    %VLP_SN(FPTN=RD_SN,STCLASS=STATIC);
    %VLP_WSN(FPTN=RD_WSN,STCLASS=STATIC);
    %VLP_NAME(FPTN=TRACKER_NAME,NAME='$$TRACKER');
/**/
    %VLP_ACCT(FPTN=TUI_ACCT,STCLASS=STATIC);
    %VLP_ACCT(FPTN=MSC_ACCT,STCLASS=STATIC);
/**/
    %VLP_ATTR(FPTN=ACCESS_LIST);
    %VLP_ACCESS(FPTN=ACC_PARMS,
              READ=YES,
              DELR=YES,
              WNEW=YES,
              UPD=YES,
              LAST=";");
/**/
    %VLR_FID(FPTN=RES_WR_FID,STCLASS=STATIC);
/**/
DCL BADFID_MSG CHAR(0) STATIC
         INIT('Please give me a simple filename');
DCL BAD_TUI_OPEN_MSG CHAR(0) STATIC
         INIT('Following error occurred while trying to open file in TUI acct');
DCL BAD_TUI_CLOSE_MSG CHAR(0) STATIC
         INIT('Following error occurred while trying to close file in TUI acct');
DCL NO_WAY_MSG CHAR(0) STATIC
         INIT('You can''t have access to this file');
DCL NO_SUCH_FILE_MSG CHAR(0) STATIC INIT('That file''s not in TUI');
DCL BAD_RD_UI_MSG CHAR(0) STATIC
         INIT('Following error occurred while trying to read file in UI acct');
DCL 1 GOOD_MOVE_MSG STATIC,
         2 * CHAR(12) INIT('Moved from .'),
         2 MOVED_FROM CHAR(8);
DCL BAD_OPEN_WR_TUI_MSG CHAR(0) STATIC
         INIT('Following error occurred while trying to open-create file in TUI');
DCL BAD_OPEN_UI_MSG CHAR(0) STATIC
         INIT('Following error occurred while trying to open file in UI acct');
DCL NO_CODE04_MSG CHAR (0) STATIC INIT('!!!NO CODE04 IN FPARAM BUF!!!');
DCL TELL_PLUSEND_MSG CHAR(0) STATIC INIT('+END built');
DCL NO_SI_MSG CHAR(0) STATIC
         INIT('File doesn''t exist in TUI, UI, or SI - please see the Control Group');
DCL TELL_BAD_OPEN_SI_MSG CHAR(0) STATIC
         INIT('Following error occurred while trying to open file in SI acct');
DCL ALREADY_THERE_MSG CHAR(0) STATIC INIT
         ('You already have write access');
DCL NOT_THERE_MSG CHAR(0) STATIC
         INIT('Your write access wasn''t there');
DCL WAIT_TRACKER_MSG CHAR(0) STATIC INIT('. . waiting to write to tracker file');
DCL CANT_WRITE_MSG CHAR(0) STATIC INIT('Can''t write to tracker file - please tell Control Group');
DCL FILE_BUSY_MSG CHAR(0) STATIC INIT('Tracker file busy, so tracker record not written. pls tell Control Group');
DCL BAD_OPEN_MSG CHAR(0) STATIC INIT('Can''t open tracker file, so tracker record not written.  Please tell Control Group.');
DCL BAD_CLOSE_MSG CHAR(0) STATIC INIT('Following error occurred while trying to close tracker file');
DCL WRITE_FILENAMES_MSG CHAR(31) STATIC;
DCL 1 FILES_LOCKED_MSG STATIC,
         2 * CHAR(4) INIT(' ...'),
         2 NUMBER CHAR(4),
         2 * CHAR(0) INIT(' Files locked');
DCL 1 FILES_LISTED_MSG STATIC,
         2 * CHAR(4) INIT(' ...'),
         2 NUMBER CHAR(4),
         2 * CHAR(0) INIT(' Files listed');
DCL NO_ACCOUNT_SPEC_MSG CHAR(0) STATIC
        INIT('You must specify an account.');
DCL NO_LIST_FID_SPEC_MSG CHAR(0) STATIC
        INIT('You must specify a file name for the list file');
DCL LIST_OPEN_DEV_ERROR_MSG CHAR(0) STATIC
        INIT('Following error occured while opening list file to ME');
DCL LIST_OPEN_FILE_ERROR_MSG CHAR(0) STATIC
        INIT('Following error occured while opening M$LIST to a file');
DCL BAD_OPEN_ERROR_MSG CHAR(0) STATIC
        INIT('Following error occured while opening file to check for DONE access');
DCL BAD_CLOSE_ERROR_MSG CHAR(0) STATIC
        INIT('Following error occured while trying to change access attributes on a file');
DCL MUST_BE_MSC_MSG CHAR(0) STATIC
        INIT('You must be the owning MSC user to LOCK, UNLOCK, or STRIP files');
DCL 1 FILES_STRIPD_MSG STATIC,
         2 * CHAR(4) INIT(' ...'),
         2 NUMBER CHAR(4),
         2 * CHAR(0) INIT(' Files stripped');
DCL NOT_SOLE_ACCESS_MSG CHAR(0) STATIC
        INIT('You don''t have sole write access to that file -- can''t delete it.');
DCL MUST_SPEC_FILE_MSG CHAR(0) STATIC
        INIT('You must specify a file name for DELETE or UNLOCK');
DCL CANT_DELETE_MSG CHAR(0) STATIC
      INIT('Can''t delete that file -- either it doesn''t exist, or you don''t have write access to it');
DCL CTL_OPN_MSG CHAR(0) STATIC
       INIT('Following error occurred while opening control file:');
DCL CTL_BAD_MSG CHAR(0) STATIC
       INIT('Control file contains invalid record:');
DCL CTL_RD_MSG CHAR(0) STATIC
       INIT('Error reading control file:');
DCL FILE_EXISTS_MSG CHAR(0) STATIC
       INIT('Uncontrolled account - file already exists');
DCL UNC_DONE_MSG CHAR(0) STATIC
       INIT('Cannot use DONE command for uncontrolled accounts');
DCL NO_EFT_PRIV_MSG CHAR(0) STATIC
       INIT('MODMOVE doesn''t have EFT priv - won''t work right');
DCL CANT_LOCK_MSG CHAR(0) STATIC
       INIT('Can''t LOCK that file');
DCL CANT_UNLOCK_MSG CHAR(0) STATIC
       INIT('Can''t UNLOCK that file');
DCL FMSEC_MSG CHAR(0) STATIC
       INIT('Warning - your FMSEC privilege is being left on!');
DCL MSC_DONE_MSG CHAR(0) STATIC
       INIT('All user access removed, changed to DONE');
DCL LOCKED_MSG CHAR(0) STATIC
       INIT('File is locked - can''t give you access');
DCL INUSE_MSG CHAR(0) STATIC
       INIT('Access denied - someone else is using that file');
/**/
DCL 1 LIST_KEY STATIC,
         2 LENGTH UBIN BYTE UNAL INIT(3),
         2 LINE_NUMBER UBIN(27) UNAL INIT(0);
/**/
DCL CMDPROMPT CHAR(5) CONSTANT UNAL INIT('CMD: ');
DCL SECPROMPT CHAR(5) CONSTANT UNAL INIT('FID: ');
/**/
DCL XSF$LOCCODE ENTRY(2) ALTRET;
DCL XSF$LOCCODP ENTRY(2) ALTRET;
DCL WORK_BUF(0:255) STATIC UBIN WORD;
DCL X$PARSE ENTRY(1) ALTRET;
DCL MODMOVE_CMD UBIN(36) SYMREF;
     %PARSE$OUT(STCLASS="BASED");
     %PARSE$SYM(STCLASS="BASED");
     %P_PCB(NAME=COMMANDS,
            R=MODMOVE_CMD,
            W=WORK_BUF,
            WSZ=256,
            STCLASS=STATIC,
            T=COMMANDBUF);
DCL BAD_SYNTAX_MSG CHAR(0) STATIC
        INIT('Syntax error in above command -- retype.');
DCL PTR$ PTR;
DCL FILE_ALREADY_SPECIFIED BIT(1) STATIC;
/**/
    %EJECT;
     CALL M$RPRIV(FMEFT_PRIV);
     CALL M$RPRIV(FMREAD_PRIV);
     IF B$JIT$->B$JIT.PRIV.JOB&%PR_FMSEC# THEN DO;
          FMSEC_PRIV.V.PRIV#=FMSEC_PRIV.V.PRIV#&(~%PR_FMSEC#);
          CALL MYWRITE(FMSEC_MSG,LENGTHC(FMSEC_MSG));
        END;
     ELSE
          CALL M$RPRIV(FMSEC_PRIV);
     IF NOT (B$JIT.PRIV.PRC&%PR_FMEFT#) THEN
          CALL MYWRITE(NO_EFT_PRIV_MSG,LENGTHC(NO_EFT_PRIV_MSG));
/**/
     USER_ACCN=B$JIT$->B$JIT.ACCN;
/**/
     IF B$JIT.CCARS-B$JIT.CCDISP>2 THEN DO;
          COMMANDS.NCHARS=B$JIT.CCARS-B$JIT.CCDISP-2;
          IF SUBSTR(B$JIT.CCBUF,B$JIT.CCARS-1,1)~=')' THEN
               COMMANDS.NCHARS=COMMANDS.NCHARS+1;
          COMMANDBUF=SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1,COMMANDS.NCHARS);
          READ_FLG='0'B;
          GOTO PARSE;
        END;
     ELSE
          READ_FLG='1'B;
/**/
     DO WHILE('1'B);
          IF NOT READ_FLG THEN
               RETURN;
          COMMANDBUF=' ';
          CALL M$PROMPT(CMD_PROMPT);
          CALL M$READ(RD_SI);
          COMMANDS.NCHARS = DCBADDR(DCBNUM(M$SI))->F$DCB.ARS#;
          CALL ECHO_INPUT(CMD_PROMPT,COMMANDBUF);
/**/
/*Look at what's typed in.  If CR or blank, get out (same as END).                 */
/**/
          IF DCBADDR(DCBNUM(M$SI))->F$DCB.ARS#=0 THEN RETURN;
          IF COMMANDBUF=' ' THEN RETURN;
/**/
/*Something was typed in - but what??                         */
/**/
PARSE:
          CALL X$PARSE(COMMANDS) ALTRET(SYNTAX_ERROR);
          PTR$ = COMMANDS.OUT$ -> OUT$BLK.SUBLK$(0);
          CALL M$RPRIV(FMSEC_PRIV);
          CALL M$RPRIV(FMEFT_PRIV);
          DO CASE (COMMANDS.OUT$ -> OUT$BLK.CODE);
          CASE(WRITE_CMD#, DONE_CMD#, DELETE_CMD#, UNLOCK_CMD#);
             CALL GET_LIST;
          CASE(QUIT_CMD#);
             RETURN;
          CASE(LOCK_CMD#);
             CALL LOCK(0);
          CASE(TRACK_CMD#);
             CALL TRACK;
          CASE(LIST_CMD#);
             CALL LOCK(1);
          CASE(STRIP_CMD#);
             CALL LOCK(2);
          CASE(ELSE);
SYNTAX_ERROR:;
             CALL MYWRITE(BAD_SYNTAX_MSG,LENGTHC(BAD_SYNTAX_MSG));
          END;
CASE_END: ;
        END;                            /* End Do Forever                     */
/**/
    %EJECT;
GET_LIST: PROC;
/**/
     COMMANDBUF = PTR$ -> OUT$SYM.TEXT;
     CALL FID_PARSE ALTRET(DONE);
     DO;
          IF COMMANDS.OUT$ -> OUT$BLK.CODE=DONE_CMD# AND CONTROLLED_FLAG=0
          THEN CALL MYWRITE(UNC_DONE_MSG,LENGTHC(UNC_DONE_MSG));
          ELSE IF COMMANDS.OUT$ -> OUT$BLK.CODE=UNLOCK_CMD# AND USER_IN_MSC=0
               THEN CALL MYWRITE(MUST_BE_MSC_MSG,LENGTHC(MUST_BE_MSC_MSG));
               ELSE EXIT;
DONE:     RETURN;
        END;
/**/
     IF NOT FILE_ALREADY_SPECIFIED
     THEN DO;
NXT_LIST: COMMANDBUF=' ';
          CALL M$PROMPT(SEC_PROMPT);
          CALL M$READ(RD_SI) WHENALTRETURN DO; END;
          CALL ECHO_INPUT(SEC_PROMPT,COMMANDBUF);
/*  If CR or blanks, return to CMD level                     */
          IF COMMANDBUF=' ' THEN RETURN;
          CALL M$FID(WR_FID) ALTRET(TROUBLE_FID);
          IF RES_WR_FID.ACCT OR RES_WR_FID.PASS OR RES_WR_FID.SN OR RES_WR_FID.WSN
          THEN DO;
               CALL MYWRITE(BADFID_MSG,LENGTHC(BADFID_MSG));
               GOTO NXT_LIST;
TROUBLE_FID:   ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
               FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
               CALL M$ERRMSG(FPT_ERRMSG);
               GOTO NXT_LIST;
             END;
        END;
/**/
     DO CASE (COMMANDS.OUT$ -> OUT$BLK.CODE);
     CASE(WRITE_CMD#);
        CALL USER_WRITE;
     CASE(DONE_CMD#);
        CALL USER_NOWRITE;
     CASE(DELETE_CMD#);
        CALL DELETE;
     CASE(UNLOCK_CMD#);
        CALL UNLOCK;
     END;
/**/
     IF NOT FILE_ALREADY_SPECIFIED THEN GOTO NXT_LIST;
     RETURN;
END GET_LIST;
    %EJECT;
USER_WRITE: PROC;
/**/
DCL LASTFLG UBIN;
/**/
     CALL OPEN_CTL ALTRET(DONE);
     LASTFLG=0;
     ERROR=0;
     CALL CHECK_TUI_ACCT(FLG);
     IF FLG=1
     THEN DO WHILE('1'B);
          CALL GET_CTL_REC(FLG,ACCTNAME) ALTRET(GET_CTL_ERR);
          LASTFLG=FLG;
          IF FLG~=2 THEN DO;
               IF FLG=0 THEN
                    IF SUBSTR(RD_FID.NAME#,0,1)=':' THEN
                         CALL BLD_END(FLG) ALTRET(DONE);
                    ELSE
                         CALL CHECK_SI_ACCT(FLG) ALTRET(DONE);
               ELSE
                    CALL CHECK_UI_ACCT(FLG) ALTRET(DONE);
             END;
        END;
DONE: ;
     CALL CLOSE_CTL;
     RETURN;
/**/
GET_CTL_ERR: ;
     IF FLG=0 AND LASTFLG~=2 THEN
          CALL MYWRITE(NO_SI_MSG,LENGTHC(NO_SI_MSG));
     GOTO DONE;
/**/
    %EJECT;
CHECK_TUI_ACCT: PROC(NOT_TUI_FLAG);
/**/
DCL NOT_TUI_FLAG UBIN;
DCL MY_TEMP UBIN;
/**/
     NOT_TUI_FLAG=0; /* Indicates file in TUI or error in accessing
                          file and don't want to proceed */
     ERROR=0;
     OPEN_TUI.NAME_=VECTOR(RD_FID);
     OPEN_TEST.ACCT_=VECTOR(TUI_ACCT);
     CALL M$OPEN(OPEN_TEST) ALTRET(OPEN_TEST_ALTRET);
     IF CONTROLLED_FLAG=0 THEN DO;
          CALL MYWRITE(FILE_EXISTS_MSG,LENGTHC(FILE_EXISTS_MSG));
          RETURN;
        END;
     CALL M$SPRIV(FMSEC_PRIV);
     CALL M$OPEN(OPEN_TUI) ALTRET(OPEN_TUI_ALTRET);
     MY_TEMP = 0;
     DO WHILE('1'B);
          CALL GET_CTL_REC (NOT_TUI_FLAG,ACCTNAME)
          WHENALTRETURN
          DO;
               IF NOT_TUI_FLAG ~= 0
               THEN
                    CALL MYWRITE (NO_SI_MSG,LENGTHC(NO_SI_MSG));
               RETURN;
             END;
          IF NOT_TUI_FLAG = 2 THEN
               MY_TEMP = 2;
 
          IF NOT_TUI_FLAG = 0
          THEN
               EXIT;
 
        END;                            /* DO FOREVER */
 
     IF MY_TEMP = 2
     THEN
     DO;
          NOT_TUI_FLAG = 2;
          RETURN;
        END;
     ELSE
          NOT_TUI_FLAG = 0;
     CALL PFIL_CTL_BOF;
     CALL ADD_WR_ACCESS(BUF_LEN,TRACKER_BUF,TRACKER_FLAG);
     NRECS=DCBADDR(DCBNUM(M$INPUT))->F$DCB.NRECS#;
     IF TRACKER_FLAG=0 THEN DO;
          CLOSE_TUI.V.OPER.CHGATT#='0'B;
          CLOSE_TUI.V.OPER.RELG#='0'B;
        END;
     ELSE DO;
          CLOSE_TUI.V.OPER.CHGATT#='1'B;
          CLOSE_TUI.V.OPER.RELG#='1'B;
        END;
     CALL M$CLOSE(CLOSE_TUI) ALTRET(CLOSE_TUI_ALTRET);
     IF TRACKER_BUF~=USER_ACCN AND BUF_LEN~=0 THEN DO;
          CALL CONCAT(CTLBUF,'Access:  ',TRACKER_BUF);
          CALL MYWRITE(CTLBUF,BUF_LEN+9);
        END;
     CLOSE_TUI.V.OPER.RELG#='1'B;
     CLOSE_TUI.V.OPER.CHGATT#='1'B; /* In case ADD_WR_ACCESS turned
                                      it off, want to turn it back on
                                      for next iteration. */
     IF TRACKER_FLAG=1
     THEN CALL TRACKER(NRECS,BUF_LEN,TRACKER_BUF);
/**/
     DO WHILE('0'B);
OPEN_TEST_ALTRET:;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN IF (DCBADDR(DCBNUM(M$INPUT))->F$DCB.FFLG.READ#)='1'B
               THEN NOT_TUI_FLAG=1;
               ELSE CALL MYWRITE(NO_WAY_MSG,LENGTHC(NO_WAY_MSG));
          ELSE DO;
               ERROR=1;
               CALL MYWRITE(BAD_TUI_OPEN_MSG,LENGTHC(BAD_TUI_OPEN_MSG));
             END;
        END;
/**/
     DO WHILE ('0'B);
OPEN_TUI_ALTRET:
          ERROR=1;
          CALL MYWRITE(BAD_TUI_OPEN_MSG,LENGTHC(BAD_TUI_OPEN_MSG));
        END;
/**/
     DO WHILE('0'B);
CLOSE_TUI_ALTRET:;
          ERROR=1;
          CALL MYWRITE(BAD_TUI_CLOSE_MSG,LENGTHC(BAD_TUI_CLOSE_MSG));
        END;
/**/
     IF ERROR=1
     THEN DO;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
     CALL M$RPRIV(FMSEC_PRIV);
     RETURN;
/**/
    %EJECT;
ADD_WR_ACCESS: PROC(BUF_LEN,TRACKER_BUF,TRACKER_FLAG);
/**/
DCL 1 NEW_ACCESS CONSTANT UNAL,
         2 *,
    %VLP_ACCESS(READ=YES,
              DELR=YES,
              WNEW=YES,
              UPD=YES,
              LAST=";");
/**/
DCL 1 ACCESSES BASED,
         2 SIZ UBIN,
         2 LIST CHAR(NEW_BYTE_NO);
/**/
DCL 1 FIRST_ACCESS STATIC UNAL,
         2 * UBIN INIT(3),
         2 LIST,
    %VLP_ACCESS(FPTN=ATTR,
              READ=YES,
              DELR=YES,
              WNEW=YES,
              UPD=YES,
              LAST=";");
/**/
DCL LIST$ PTR;
DCL ACCESS$ PTR;
DCL COUNT UBIN WORD;
DCL START UBIN HALF;
DCL I UBIN HALF;
DCL TYPE UBIN HALF;
DCL NEW_BYTE_NO UBIN STATIC;
DCL BUF_LEN UBIN HALF;
DCL TRACKER_BUF CHAR(80);
DCL TRACKER_FLAG UBIN HALF;
/**/
    %EJECT;
     IF CONTROLLED_FLAG=0 THEN
          RETURN;
     FIT$=ADDR(FPARAM_BUF);
     LIST$=FIT$;
     CODE=9;
     TRACKER_FLAG=1;
     CALL XSF$LOCCODE(LIST$,CODE) ALTRET(NO_ACC_LIST);
     ACCESS$=LIST$;
     ACC_LEN=LENGTHC(ACCESS$->CODE09);
     ACC_NO=FIT$->FM$FIT.CODES.NDW(CODE)*4/ACC_LEN;
     COUNT=0;
     START=0;
     TRACKER_BUF=' ';
     I=1;
     DO WHILE(I~=0);
          IF ACCESS$->CODE09.ACCT='?MSC'
               OR
               ACCESS$->CODE09.ACCT='?MISC'
          THEN
          DO;
               TYPE=5;
               I=0;
             END;
          ELSE
               IF ACCESS$->CODE09.ACCT='DONE'
/**/
/*  Replace DONE with this new guy                          */
/**/
               THEN DO;
                    TYPE=1;
                    I=0;
                  END;
               ELSE IF ACCESS$->CODE09.ACCT=USER_ACCN
                    THEN IF ACCESS$->CODE09.FFLG=FIRST_ACCESS.LIST.ATTR.FFLG
/**/
/*  This guy was already there.  Tell him so and don't do anything  */
/**/
                         THEN DO;
                              TYPE=3;
                              I=0;
                            END;
/**/
/*  Guy was there, but didn't have all Attr's he needed.     */
/**/
                         ELSE DO;
                              TYPE=4;
                              I=0;
                              ACCESS$->CODE09.FFLG=FIRST_ACCESS.LIST.ATTR.FFLG;
                            END;
/**/
/*  List searched & he wasn't there, so add him to end of list in
    FPARAM_BUF to prepare for new access list.                 */
/**/
                    ELSE IF I=ACC_NO
                         THEN DO;
                              IF PROT_FLG AND ACC_NO~=0 THEN DO;
                                   TYPE=6;
                                   I=0;
                                 END;
                              ELSE DO;
                                   TYPE=2;
                                   I=0;
                                   ACCESS$=PINCRC(ACCESS$,ACC_LEN);
                                   ACC_NO=ACC_NO+1;
                                   ACCESS$->CODE09=NEW_ACCESS;
                                   ACCESS$->CODE09.ACCT=USER_ACCN;
                                 END;
                            END;
/**/
/*  Haven't found him yet, so keep looking.                 */
/**/
                         ELSE DO;
                              ACCESS$=PINCRC(ACCESS$,ACC_LEN);
                              I=I+1;
                            END;
        END;                            /* END DO WHILE                       */
     ACCESS$=LIST$;
     IF TYPE=2 OR TYPE=4
     THEN DO I=1 TO ACC_NO;
          CALL INDEX(COUNT,' ',ACCESS$->CODE09.ACCT);
          IF I=1 THEN DO;
               CALL INSERT(TRACKER_BUF,START,COUNT,ACCESS$->CODE09.ACCT);
               START=COUNT;
             END;
          ELSE DO;
               CALL INSERT(TRACKER_BUF,START,COUNT+1,',',ACCESS$->CODE09.ACCT);
               START=START+COUNT+1;
             END;
          ACCESS$=PINCRC(ACCESS$,ACC_LEN);
        END;
/**/
/*  There was no access list, so this must be the 1st guy     */
/**/
     DO WHILE('0'B);
NO_ACC_LIST:;
          TYPE=1;
        END;
/**/
     DO CASE(TYPE);
     CASE(1);
        TRACKER_BUF=USER_ACCN;
        BUF_LEN=8;
        FIRST_ACCESS.LIST.ATTR.ACCT#=USER_ACCN;
        CLOSE_TUI.ACCESS_=VECTOR(FIRST_ACCESS);
     CASE(2,4);
        BUF_LEN=START;
        LIST$=PINCRW(LIST$,-1);
        LIST$->ACCESSES.SIZ=(ACC_NO*ACC_LEN+3)/4;
        NEW_BYTE_NO=(LIST$->ACCESSES.SIZ)*4;
        CLOSE_TUI.ACCESS_=VECTOR(LIST$->ACCESSES);
     CASE(3);
        CALL MYWRITE(ALREADY_THERE_MSG,LENGTHC(ALREADY_THERE_MSG));
CLNUP:
        TRACKER_FLAG=0;
        BUF_LEN=0;
     CASE(5);                           /* File is locked */
        CALL MYWRITE(LOCKED_MSG,LENGTHC(LOCKED_MSG));
        GOTO CLNUP;
     CASE(6);                      /* Protected and someone else has access */
        CALL MYWRITE(INUSE_MSG,LENGTHC(INUSE_MSG));
        GOTO CLNUP;
     END;
     RETURN;
END ADD_WR_ACCESS;
END CHECK_TUI_ACCT;
    %EJECT;
CHECK_UI_ACCT: PROC(FLG) ALTRET;
/**/
DCL FLG UBIN;
DCL CON_FILE UBIN HALF;
DCL REC_LEN UBIN WORD;
DCL TEXTC CHAR(REC_LEN) BASED;
DCL UI_BUF CHAR(256) STATIC;
DCL REC$ PTR STATIC;
DCL TIME_NOW UBIN(36) STATIC ALIGNED;
DCL FILE_KEY (0:63) UBIN WORD STATIC;
DCL 1 CON_KEY STATIC,
         2 * UBIN BYTE UNAL INIT(3),
         2 NUM UBIN(27) UNAL;
/**/
    %FPT_READ(FPTN=RD_UI,DCB=M$INPUT,BUF=UI_BUF,KEY=FILE_KEY,KEYR=YES);
/**/
    %FPT_WRITE(FPTN=WR_TO_TUI,DCB=M$OUTPUT);
/**/
    %FPT_TIME(FPTN=RIGHT_NOW,SOURCE=CLOCK,DEST=UTS,TSTAMP=TIME_NOW);
/**/
    %FPT_OPEN(FPTN=OPEN_UI,
              DCB=M$INPUT,
              FUN=IN,
              NAME=RD_FID,
              ACCT=ACCTNAME,
              ASN=FILE,
              FPARAM=FPARAM_BUF,
              STCLASS=STATIC);
 
    %FPT_OPEN(FPTN=OPEN_WR_TUI,
              DCB=M$OUTPUT,
              FUN=CREATE,
              NAME=RD_FID,
              ACCT=TUI_ACCT,
              ORG=KEYED,
              ACS=DIRECT,
              ASN=FILE,
              IFPARAM=FPARAM_BUF,
              DISP=NAMED,
              EXIST=NEWFILE,
              EXPIRE=NEVER,
              STCLASS=STATIC);
 
    %FPT_CLOSE(FPTN=CLOSE_UI,
              DCB=M$INPUT,
              DISP=SAVE);
 
    %FPT_CLOSE(FPTN=CLOSE_WR_TUI,
              DCB=M$OUTPUT,
              CHGATT=YES,
              RELG=YES,
              DISP=SAVE);
 
    %FPT_CLOSE(FPTN=CLOSE_WR_TUI_NOCHNG,
              DCB=M$OUTPUT,
              RELG=YES,
              DISP=SAVE);
/**/
    %EJECT;
/**/
     FLG=0;                             /* indicates that process to to stop */
     ERROR=0;
     OPEN_TEST.ACCT_=VECTOR(ACCTNAME);
     CALL M$OPEN(OPEN_TEST) ALTRET(OPEN_TEST_ALTRET);
     IF CONTROLLED_FLAG~=0 THEN DO;
          CALL M$SPRIV(FMSEC_PRIV);
          CALL M$SPRIV(FMEFT_PRIV);
          CALL M$OPEN(OPEN_UI) ALTRET(OPEN_UI_ALTRET);
          FIT$=ADDR(FPARAM_BUF);
          NRECS=FIT$->FM$FIT.CODES.CODE(0); /* # Control words in FIT             */
/* If the code isn't 4, then we don't need it for the new file */
          DO CODE=1 TO NRECS;
               IF FIT$->FM$FIT.CODES.CODE(CODE)~=4
               THEN FIT$->FM$FIT.CODES(CODE)='0'B;
             END;
          CODE=4;
          CALL XSF$LOCCODE(FIT$,CODE) ALTRET(CODE04_ALTRET);
          CALL M$TIME(RIGHT_NOW);
          FIT$->CODE04.ACCESS.TIME=TIME_NOW;
          FIT$->CODE04.MODIFY.TIME=TIME_NOW;
          FIT$->CODE04.CREATION.TIME=TIME_NOW;
          FIT$->CODE04.CREATOR.ACCT=MSC_ACCT.ACCT#;
          FIT$->CODE04.CREATOR.NAME='100CONTROL';
          CALL M$OPEN(OPEN_WR_TUI) ALTRET(OPEN_WR_TUI_ALTRET);
          CALL M$RPRIV(FMEFT_PRIV);
        END;
     ELSE DO;
          CALL M$OPEN(OPEN_UI) ALTRET(OPEN_UI_ALTRET);
          FPARAM_BUF(0)=0;              /* Invalidate IFPARAM */
          CALL M$OPEN(OPEN_WR_TUI) ALTRET(OPEN_WR_TUI_ALTRET);
        END;
/**/
     NRECS=0;
     REC$=DCBADDR(DCBNUM(M$INPUT));
     IF REC$->F$DCB.ORG#=%CONSEC#
     THEN DO;
          CON_FILE=1;
          CON_KEY.NUM=1000;
          WR_TO_TUI.KEY_=VECTOR(CON_KEY);
        END;
     ELSE DO;
          WR_TO_TUI.KEY_=VECTOR(FILE_KEY);
          CON_FILE=0;
        END;
     DO WHILE ('1'B);
          CALL M$READ(RD_UI) ALTRET(RD_UI_ALTRET);
          REC_LEN=REC$->F$DCB.ARS#;
          IF REC_LEN=0
          THEN WR_TO_TUI.BUF_=VECTOR(NIL);
          ELSE WR_TO_TUI.BUF_=VECTOR(ADDR(UI_BUF)->TEXTC);
          CALL M$WRITE(WR_TO_TUI);
          CON_KEY.NUM=CON_KEY.NUM+1000;
          NRECS=NRECS+1;
        END;
/**/
OPEN_TEST_ALTRET:;
     IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
     THEN DO;
          IF (DCBADDR(DCBNUM(M$INPUT))->F$DCB.FFLG.READ#)='1'B
/**/
/*  He can read the acct, but the file's not there.  Continue
    looking.  */
/**/
          THEN
               FLG=1;
/**/
/*  He can't read the acct.  Check to see if this is because the acct
    isn't there or because he doesn't have access.        */
/**/
          ELSE DO;
               CALL M$SPRIV(FMSEC_PRIV);
               CALL M$OPEN(OPEN_TEST) ALTRET (OPEN_TEST2_ALT);
/**/
/*  The file is there, so he didn't have access.  Throw 'im out.   */
/**/
               CALL MYWRITE(NO_WAY_MSG,LENGTHC(NO_WAY_MSG));
             END;
        END;
     ELSE DO;
          ERROR=1;
          CALL MYWRITE(BAD_OPEN_UI_MSG,LENGTHC(BAD_OPEN_UI_MSG));
        END;
/**/
     DO WHILE('0'B);
OPEN_TEST2_ALT:;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN IF (DCBADDR(DCBNUM(M$INPUT))->F$DCB.FFLG.READ#)='0'B
/**/
/*  There is no such UI acct. So, keep looking. */
/**/
               THEN
                    FLG=1;
/**/
/*  The file's not here, but the acct exists. Therefore, he must not
    have had access to it on his own. Throw 'im out.     */
               ELSE CALL MYWRITE(NO_WAY_MSG,LENGTHC(NO_WAY_MSG));
          ELSE DO;
               CALL MYWRITE(BAD_OPEN_UI_MSG,LENGTHC(BAD_OPEN_UI_MSG));
               ERROR=1;
             END;
        END;
/**/
     DO WHILE ('0'B);
OPEN_UI_ALTRET:;
          CALL MYWRITE(BAD_OPEN_UI_MSG,LENGTHC(BAD_OPEN_UI_MSG));
          ERROR=1;
        END;
/**/
     DO WHILE('0'B);
RD_UI_ALTRET: IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$EOF
          THEN DO;
               IF CONTROLLED_FLAG~=0 THEN DO;
                    ACCESS_LIST.Q.ACC_PARMS.ACCT#=USER_ACCN;
                    CLOSE_WR_TUI.ACCESS_=VECTOR(ACCESS_LIST);
                    CALL M$CLOSE(CLOSE_WR_TUI) ALTRET(CLOSE_ALTRET);
                    TRACKER_BUF=USER_ACCN;
                    BUF_LEN=8;
                    CALL TRACKER(NRECS,BUF_LEN,TRACKER_BUF);
                  END;
               ELSE
                    CALL M$CLOSE(CLOSE_WR_TUI_NOCHNG) ALTRET(CLOSE_ALTRET);
               GOOD_MOVE_MSG.MOVED_FROM = ACCTNAME;
               CALL MYWRITE(GOOD_MOVE_MSG,LENGTHC(GOOD_MOVE_MSG));
             END;
          ELSE DO;
               CALL MYWRITE(BAD_RD_UI_MSG,LENGTHC(BAD_RD_UI_MSG));
               ERROR=1;
               CALL M$CLOSE(CLOSE_RELEASE) ALTRET(CLOSE_ALTRET);
             END;
          CALL M$CLOSE(CLOSE_UI) ALTRET(CLOSE_ALTRET);
        END;
     DO WHILE('0'B);
OPEN_WR_TUI_ALTRET:;
          ERROR=1;
          CALL MYWRITE(BAD_OPEN_WR_TUI_MSG,LENGTHC(BAD_OPEN_WR_TUI_MSG));
        END;
/**/
     DO WHILE ('0'B);
CLOSE_ALTRET:;
          ERROR=1;
        END;
     IF ERROR=1
     THEN DO;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
/**/
     DO WHILE('0'B);
CODE04_ALTRET:;
          CALL MYWRITE(NO_CODE04_MSG,LENGTHC(NO_CODE04_MSG));
        END;
/**/
     CALL M$RPRIV(FMSEC_PRIV);
     CALL M$RPRIV(FMEFT_PRIV);
     IF FLG=0 THEN
          ALTRETURN;                    /* Done */
     ELSE
          RETURN;                       /* Keep looking */
/**/
END CHECK_UI_ACCT;
    %EJECT;
CHECK_SI_ACCT: PROC(FLG) ALTRET;
/**/
    %FPT_OPEN(FPTN=OPEN_TEST_PLUSEND,
              DCB=M$OUTPUT,
              FUN=IN,
              NAME=RD_FID,
              ACCT=TUI_ACCT,
              ASN=FILE,
              FPARAM=FPARAM_BUF,
              TEST=YES);
 
    %FPT_OPEN(FPTN=OPEN_PLUSEND,
              DCB=M$OUTPUT,
              FUN=CREATE,
              NAME=RD_FID,
              ACCT=TUI_ACCT,
              ASN=FILE,
              ORG=KEYED,
              ACS=DIRECT,
              DISP=NAMED,
              SPARE=50,
              EXIST=NEWFILE);
 
    %FPT_CLOSE(FPTN=CLOSE_PLUSEND,
              DCB=M$OUTPUT,
              CHGATT=YES,
              RELG=YES,
              DISP=SAVE);
 
    %FPT_CLOSE(FPTN=CLOSE_PLUSEND_NOCHNG,
              DCB=M$OUTPUT,
              DISP=SAVE,
              RELG=YES);
/**/
    %FPT_WRITE(FPTN=WR_PLUSEND,
              DCB=M$OUTPUT,
              BUF=PLUS_END,
              KEY=MANY_NINES);
/**/
DCL FLG UBIN;
DCL PLUS_END CHAR(0) CONSTANT INIT('+END');
DCL 1 MANY_NINES STATIC,
         2 * UBIN BYTE UNAL INIT(3),
         2 * UBIN(27) UNAL INIT(99998000);
/**/
    %EJECT;
     ERROR=0;
     FLG=0;
     OPEN_TEST.ACCT_=VECTOR(ACCTNAME);
     CALL M$OPEN(OPEN_TEST) ALTRET(OPEN_TEST_ALTRET);
     GOTO COMMON;
/**/
BLD_END: ENTRY(FLG) ALTRET;
/**/
     ERROR=0;
     FLG=0;
/**/
COMMON: ;
/* Give +END   */
     OPEN_PLUSEND.IFPARAM_=VECTOR(ERASE);
     IF CONTROLLED_FLAG~=0 THEN DO;
          CALL M$SPRIV(FMSEC_PRIV);
          CALL M$OPEN(OPEN_PLUSEND) ALTRET(TROUBLE);
          CALL M$CLOSE(CLOSE_PLUSEND) ALTRET (CLOSE_PLUSEND_ALT);
          CALL M$SPRIV(FMEFT_PRIV);
          CALL M$OPEN(OPEN_TEST_PLUSEND) ALTRET(TROUBLE);
          FIT$=ADDR(FPARAM_BUF);
          CODE=4;
          CALL XSF$LOCCODE(FIT$,CODE) ALTRET(CODE04_ALTRET);
          FIT$->CODE04.CREATOR.ACCT=MSC_ACCT.ACCT#;
          FIT$->CODE04.CREATOR.NAME='100CONTROL';
          OPEN_PLUSEND.IFPARAM_=VECTOR(FPARAM_BUF);
          CALL M$OPEN(OPEN_PLUSEND) ALTRET(TROUBLE);
          CALL M$RPRIV(FMEFT_PRIV);
          CALL M$WRITE(WR_PLUSEND) ALTRET(CLOSE_PLUSEND_ALT);
          ACCESS_LIST.Q.ACC_PARMS.ACCT#=USER_ACCN;
          CLOSE_PLUSEND.ACCESS_=VECTOR(ACCESS_LIST);
          CALL M$CLOSE(CLOSE_PLUSEND) ALTRET(CLOSE_PLUSEND_ALT);
          TRACKER_BUF=USER_ACCN;
          NRECS=1;
          BUF_LEN=8;
          CALL TRACKER(NRECS,BUF_LEN,TRACKER_BUF);
        END;
     ELSE DO;
          CALL M$OPEN(OPEN_PLUSEND) ALTRET(TROUBLE);
          CALL M$WRITE(WR_PLUSEND) ALTRET(CLOSE_PLUSEND_ALT);
          CALL M$CLOSE(CLOSE_PLUSEND_NOCHNG) ALTRET(CLOSE_PLUSEND_ALT);
        END;
     CALL MYWRITE(TELL_PLUSEND_MSG,LENGTHC(TELL_PLUSEND_MSG));
     DO WHILE('0'B);
OPEN_TEST_ALTRET:;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN IF (DCBADDR(DCBNUM(M$INPUT))->F$DCB.FFLG.READ#)='1'B
/**/
/*  He can read the acct, but the file's not there.  Keep looking. */
/**/
               THEN
                    FLG=1;
/**/
/*  He can't read acct.  Either he doesn't have access or the acct
    doesn't exist.  Check to see which.                            */
/**/
               ELSE DO;
                    CALL M$SPRIV(FMSEC_PRIV);
                    CALL M$OPEN(OPEN_TEST) ALTRET(OPEN_TEST2_ALT);
/**/
/*  He really didn't have access.  Tell him so.               */
/**/
                    CALL MYWRITE(NO_WAY_MSG,LENGTHC(NO_WAY_MSG));
                  END;
          ELSE DO;
               ERROR=1;
               CALL MYWRITE(TELL_BAD_OPEN_SI_MSG,LENGTHC(TELL_BAD_OPEN_SI_MSG));
             END;
        END;
/**/
     DO WHILE('0'B);
OPEN_TEST2_ALT:;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN IF (DCBADDR(DCBNUM(M$INPUT))->F$DCB.FFLG.READ#)='0'B
/**/
/*  SI acct doesn't exist.  Keep looking.  */
/**/
               THEN
                    FLG=1;
/**/
/*  Acct exists, but he couldn't get to it by himself.  Tell him no.  */
/**/
               ELSE CALL MYWRITE(NO_WAY_MSG,LENGTHC(NO_WAY_MSG));
          ELSE DO;
               ERROR=1;
               CALL MYWRITE(TELL_BAD_OPEN_SI_MSG,LENGTHC(TELL_BAD_OPEN_SI_MSG));
             END;
        END;
/**/
     DO WHILE('0'B);
CLOSE_PLUSEND_ALT:;
          ERROR=1;
          CALL M$CLOSE(CLOSE_RELEASE) ALTRET(TROUBLE);
        END;
/**/
     DO WHILE('0'B);
TROUBLE:  ;
          ERROR=1;
        END;
/**/
     DO WHILE('0'B);
CODE04_ALTRET:;
          CALL MYWRITE(NO_CODE04_MSG,LENGTHC(NO_CODE04_MSG));
        END;
/**/
     CALL M$RPRIV(FMSEC_PRIV);
     CALL M$RPRIV(FMEFT_PRIV);
/**/
     IF ERROR=1
     THEN DO;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
     IF FLG=0 THEN
          ALTRETURN;
     ELSE
          RETURN;
/**/
END CHECK_SI_ACCT;
%EJECT;
OPEN_CTL: PROC ALTRET;
/**/
DCL I UBIN;
/**/
        %FPT_OPEN(FPTN=OPN_CTL,
                  DCB=CTL,
                  FUN=IN,
                  NAME=CTL_NAME,
                  ACCT=TUI_ACCT.ACCT#,
                  ASN=FILE,
                  SCRUB=YES);
/**/
    %VLP_NAME(FPTN=CTL_NAME,
              STCLASS=CONSTANT,
              NAME='$$MODMOVE_CTL');
/**/
    %FPT_READ(FPTN=RD_CTL,
              DCB=CTL,
              BUF=CTLBUF);
/**/
    %FPT_CLOSE(FPTN=CLS_CTL,
               DCB=CTL);
/**/
     CALL M$OPEN(OPN_CTL) ALTRET(ERR);
     CALL M$READ(RD_CTL) ALTRET(ERR);
     I=DCBADDR(DCBNUM(CTL))->F$DCB.ARS#;
     IF SUBSTR(CTLBUF,0,I)='PROTECT' THEN
          PROT_FLG='1'B;
     ELSE DO;
          PROT_FLG='0'B;
          CALL PFIL_CTL_BOF;
        END;
     RETURN;
/**/
ERR: ;
     ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
     CALL MYWRITE(CTL_OPN_MSG,LENGTHC(CTL_OPN_MSG));
     CALL M$ERRMSG(FPT_ERRMSG);
     ALTRETURN;
/**/
CLOSE_CTL: ENTRY ALTRET;
/**/
     IF DCBADDR(DCBNUM(CTL))->F$DCB.FCD# THEN
          CALL M$CLOSE(CLS_CTL) ALTRET(ERR);
     RETURN;
END OPEN_CTL;
%EJECT;
PFIL_CTL_BOF: PROC;
 
    %FPT_PFIL(FPTN=PFIL_CTL,
              DCB=CTL,
              BOF=YES);
/**/
 
     CALL M$PFIL (PFIL_CTL)
     WHENALTRETURN
     DO;
          CALL M$MERC;
        END;
 
     RETURN;
 
END PFIL_CTL_BOF;
%EJECT;
GET_CTL_REC: PROC(FLG,ACCT) ALTRET;
/**/
DCL FLG UBIN;
DCL ACCT CHAR(8);
DCL I UBIN;
/**/
    %FPT_READ(FPTN=RD_CTL,
              DCB=CTL,
              BUF=CTLBUF);
/**/
     CALL M$READ(RD_CTL) ALTRET(RD_ERR);
     I=DCBADDR(DCBNUM(CTL))->F$DCB.ARS#;
     IF I<3 THEN GOTO CTLBAD;
     IF SUBSTR(CTLBUF,0,1)='*' THEN DO;
          CALL MYWRITE(SUBSTR(CTLBUF,1,I-1),I-1);
          FLG=2;
          RETURN;
        END;
     IF SUBSTR(CTLBUF,I-2,2)='SI' THEN
          FLG=0;
     ELSE
          IF SUBSTR(CTLBUF,I-2,2)='UI' THEN
               FLG=1;
          ELSE
               GOTO CTLBAD;
     CALL INDEX(I,' ',SUBSTR(CTLBUF,0,I));
     ACCT=SUBSTR(CTLBUF,0,I);
     RETURN;
/**/
RD_ERR: ;
     IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$EOF THEN
          FLG=0;
     ELSE DO;
          FLG=1;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL MYWRITE(CTL_RD_MSG,LENGTHC(CTL_RD_MSG));
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
     ALTRETURN;
/**/
CTLBAD: ;
     CALL MYWRITE(CTL_BAD_MSG,LENGTHC(CTL_BAD_MSG));
     IF I~=0 THEN
          CALL MYWRITE(CTLBUF,I);
     FLG=1;
     ALTRETURN;
END GET_CTL_REC;
END USER_WRITE;
%EJECT;
USER_NOWRITE: PROC;
/**/
     OPEN_TUI.NAME_=VECTOR(RD_FID);
     OPEN_TEST.ACCT_=VECTOR(TUI_ACCT);
     CALL M$OPEN(OPEN_TEST) ALTRET(OPEN_TEST_ALTRET);
     CALL M$SPRIV(FMSEC_PRIV);
     CALL M$OPEN(OPEN_TUI) ALTRET(OPEN_ALTRET);
     CALL CHANGE_TO_DONE(BUF_LEN,TRACKER_BUF,TRACKER_FLAG);
     NRECS=DCBADDR(DCBNUM(M$INPUT))->F$DCB.NRECS#;
     CALL M$CLOSE(CLOSE_TUI) ALTRET(CLOSE_ALTRET);
     IF TRACKER_BUF~='DONE' THEN DO;
          CALL CONCAT(CTLBUF,'Access:  ',TRACKER_BUF);
          CALL MYWRITE(CTLBUF,BUF_LEN+9);
        END;
     CLOSE_TUI.V.OPER.CHGATT#='1'B;
     IF TRACKER_FLAG=1
     THEN CALL TRACKER(NRECS,BUF_LEN,TRACKER_BUF);
/**/
     DO WHILE('0'B);
OPEN_TEST_ALTRET: ;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN DO;
               CALL M$SPRIV(FMSEC_PRIV);
               CALL M$OPEN(OPEN_TEST) ALTRET(OPEN_ALTRET);
               CALL M$RPRIV(FMSEC_PRIV);
               CALL MYWRITE(NO_WAY_MSG,LENGTHC(NO_WAY_MSG));
             END;
          ELSE DO;
               ERROR=1;
               CALL MYWRITE(BAD_TUI_OPEN_MSG,LENGTHC(BAD_TUI_OPEN_MSG));
             END;
        END;
/**/
     DO WHILE('0'B);
OPEN_ALTRET: ;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN CALL MYWRITE(NO_SUCH_FILE_MSG,LENGTHC(NO_SUCH_FILE_MSG));
/**/
          ELSE DO;
               ERROR=1;
               CALL MYWRITE(BAD_TUI_OPEN_MSG,LENGTHC(BAD_TUI_OPEN_MSG));
             END;
        END;
/**/
     DO WHILE('0'B);
CLOSE_ALTRET: ;
          ERROR=1;
          CALL MYWRITE(BAD_TUI_CLOSE_MSG,LENGTHC(BAD_TUI_CLOSE_MSG));
        END;
     IF ERROR=1
     THEN DO;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
/**/
    %EJECT;
CHANGE_TO_DONE: PROC(START,TRACKER_BUF,TRACKER_FLAG);
/**/
DCL 1 DONE_ACCESS CONSTANT UNAL,
         2 *,
    %VLP_ACCESS(READ=NO,
              DELR=NO,
              WNEW=NO,
              UPD=NO,
              DELF=NO,
              REATTR=NO,
              ACCT='DONE',
              LAST=";");
/**/
DCL 1 ACCESSES BASED,
         2 SIZ UBIN,
         2 LIST CHAR(BYTE_NO);
/**/
DCL LIST$ PTR;
DCL ACCESS$ PTR;
DCL NEXT$ PTR;
DCL COUNT UBIN WORD;
DCL START UBIN HALF;
DCL SIZE UBIN;
DCL ACC_FLAG UBIN HALF;
DCL I UBIN HALF;
DCL J UBIN HALF;
DCL BYTE_NO UBIN STATIC;
DCL TRACKER_BUF CHAR(80);
DCL TRACKER_FLAG UBIN HALF;
/**/
    %EJECT;
     IF CONTROLLED_FLAG=0 THEN
          RETURN;
/**/
/*  Set the flag to 1 cause we'll probably change something.  Then
    find the start of the access list in the fit buffer so we can
    start looking for this guy.                         */
/**/
     ACC_FLAG=1;
     FIT$=ADDR(FPARAM_BUF);
     LIST$=FIT$;
     CODE=9;
     TRACKER_FLAG=1;
     ACC_LEN=LENGTHC(ACCESS$->CODE09);
     ACC_NO=0;
     TRACKER_BUF='DONE'; /* suppress the access: message if there is none */
     COUNT=0;
     START=0;
     CALL XSF$LOCCODE(LIST$,CODE) ALTRET(NO_SUCH_GUY);
     SIZE=FIT$->FM$FIT.CODES.NDW(CODE);
     ACCESS$=LIST$;
     ACC_NO=SIZE*4/ACC_LEN;
/**/
     I=1;
     DO WHILE(I~=0);
          NEXT$=PINCRC(ACCESS$,ACC_LEN);
          IF ACCESS$->CODE09.ACCT=USER_ACCN
          THEN IF ACC_NO=1
/**/
/*  If he's here and is the only one in the list, change him to DONE */
/**/
               THEN DO;
                    ACCESS$->CODE09=DONE_ACCESS;
                    I=0;
                  END;
               ELSE DO;
/**/
/*  If he's here but not the only one, get rid of him by scootching
    everybody else up one over him and decrementing the # of accts
    by 1.                                                     */
/**/
                    DO J=1 TO ACC_NO-I;
                         ACCESS$->CODE09=NEXT$->CODE09;
                         ACCESS$=PINCRC(ACCESS$,ACC_LEN);
                         NEXT$=PINCRC(NEXT$,ACC_LEN);
                       END;
                    ACC_NO=ACC_NO-1;
                    SIZE=(ACC_NO*ACC_LEN+3)/4;
                    I=0;
                  END;
          ELSE IF I=ACC_NO
/**/
/*  If it's the end of the list and he wasn't found, set the flag
    to 0 so he'll get a msg and nothing will be written to TRACKER   */
/**/
               THEN DO;
NO_SUCH_GUY_5:      ;
                    I=0;
                    IF USER_IN_MSC~=0 THEN DO;
                         CALL MYWRITE(MSC_DONE_MSG,
                              LENGTHC(MSC_DONE_MSG));
                         SIZE=(ACC_LEN+3)/4;
                         LIST$->CODE09=DONE_ACCESS;
                         ACC_FLAG=1;
                         ACC_NO=1;
                       END;
                    ELSE
                         ACC_FLAG=0;
                  END;
/**/
/*  Otherwise, keep looking.                              */
/**/
               ELSE I=I+1;
          ACCESS$=PINCRC(ACCESS$,ACC_LEN);
        END;                            /* End Do While                       */
/**/
/**/
/*  Set ACCESS$ back to front of access list to start making
    TRACKER list.                                        */
/**/
     ACCESS$=LIST$;
     LIST$=PINCRW(LIST$,-1);
     DO I=1 TO ACC_NO;
          CALL INDEX(COUNT,' ',ACCESS$->CODE09.ACCT);
          IF I=1 THEN DO;
               CALL INSERT(TRACKER_BUF,START,COUNT,ACCESS$->CODE09.ACCT);
               START=COUNT;
             END;
          ELSE DO;
               CALL INSERT(TRACKER_BUF,START,COUNT+1,',',ACCESS$->CODE09.ACCT);
               START=START+COUNT+1;
             END;
          ACCESS$=PINCRC(ACCESS$,ACC_LEN);
        END;
     IF ACC_FLAG=1
     THEN DO;
          CALL INDEX(COUNT,' ',USER_ACCN);
          CALL INSERT(TRACKER_BUF,START,COUNT+2,' (',USER_ACCN);
          START=START+COUNT+2;
          CALL INSERT(TRACKER_BUF,START,1,')');
          START=START+1;
          BYTE_NO=SIZE*4;
          LIST$->ACCESSES.SIZ=SIZE;
          CLOSE_TUI.ACCESS_=VECTOR(LIST$->ACCESSES);
          RETURN;
        END;
/**/
     CALL MYWRITE(NOT_THERE_MSG,LENGTHC(NOT_THERE_MSG));
     TRACKER_FLAG=0;
     CLOSE_TUI.V.OPER.CHGATT#='0'B;
     RETURN;
/**/
NO_SUCH_GUY: ;
     LIST$=ADDR(FPARAM_BUF(1));
     GOTO NO_SUCH_GUY_5;
END CHANGE_TO_DONE;
END USER_NOWRITE;
%EJECT;
TRACKER: PROC(NRECS,BUF_LEN,TRACKER_BUF);
/**/
DCL I UBIN HALF STATIC;
DCL NRECS UBIN;
DCL BUF_LEN UBIN HALF;
DCL TRACKER_BUF CHAR(80);
DCL WRITE_LEN UBIN HALF;
DCL WRITE_BUF CHAR(WRITE_LEN) BASED;
DCL 1 TRACKER_RECORD STATIC,
         2 RECS CHAR(6) INIT(' '),
         2 *    CHAR(2) INIT(' '),
         2 DATE CHAR(10) INIT(' '),
         2 *    CHAR(1) INIT(' '),
         2 TIME CHAR(5) INIT(' '),
         2 *    CHAR(2) INIT(' '),
         2 NAME CHAR(31) INIT(' '),
         2 *    CHAR(2) INIT(' '),
         2 ACCESS CHAR(79);
/**/
    %FPT_WRITE(FPTN=WR_TRACKER,DCB=M$OUTPUT);
    %FPT_WRITE(FPTN=WR_HEADER,DCB=M$OUTPUT,BUF=HEADER);
    %FPT_WRITE(FPTN=WR_UNDERLINES,DCB=M$OUTPUT,BUF=UNDERLINES);
/**/
DCL HEADER CHAR(0) CONSTANT INIT('#RECS   ACCESS MODIFIED   NAME                             WR ACCESS');
DCL UNDERLINES CHAR(0) CONSTANT INIT('------  ----------------  -------------------------------  ---------');
/**/
    %FPT_WAIT(UNITS=6);
/**/
    %FPT_TIME(FPTN=NOW,SOURCE=CLOCK,DEST=EXT,DATE=TRACKER_RECORD.DATE,TIME=TRACKER_RECORD.TIME);
/**/
    %FPT_OPEN(FPTN=OPEN_TRACKER_TEST,
              DCB=M$OUTPUT,
              FUN=IN,
              NAME=TRACKER_NAME,
              ASN=FILE,
              ACCT=MSC_ACCT,
              TEST=YES);
 
    %FPT_OPEN(FPTN=OPEN_TRACKER,
              DCB=M$OUTPUT,
              FUN=CREATE,
              NAME=TRACKER_NAME,
              ACCT=MSC_ACCT,
              ORG=CONSEC,
              ASN=FILE,
              DISP=NAMED,
              EXIST=OLDFILE);
/**/
    %FPT_CLOSE(FPTN=CLOSE_TRACKER,
              DCB=M$OUTPUT,
              RELG=YES,
              DISP=SAVE);
/**/
%EJECT;
/**/
     IF CONTROLLED_FLAG=0 THEN
          RETURN;
     CALL M$TIME(NOW);
     TRACKER_RECORD.NAME=RD_FID.NAME#;
     CALL BINCHAR(TRACKER_RECORD.RECS,NRECS);
     TRACKER_RECORD.ACCESS=TRACKER_BUF;
     WRITE_LEN=BUF_LEN + 59;
     WR_TRACKER.BUF_=VECTOR(ADDR(TRACKER_RECORD)->WRITE_BUF);
     I=1;
     CALL M$OPEN(OPEN_TRACKER_TEST) ALTRET(OPEN_ALTRET);
TRY_AGAIN:;
     I=I + 1;
     CALL M$OPEN(OPEN_TRACKER) ALTRET(OPEN_ALTRET);
/**/
     DO WHILE ('0'B);
OPEN_ALTRET:;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOFILE
          THEN DO;
               CALL M$OPEN(OPEN_TRACKER) ALTRET(OPEN_ALTRET);
               CALL M$CLOSE(CLOSE_TRACKER) ALTRET(CLOSE_ALTRET);
               CALL M$SPRIV(FMEFT_PRIV);
               OPEN_TRACKER.FPARAM_=VECTOR(FPARAM_BUF);
               CALL M$OPEN(OPEN_TRACKER) ALTRET(OPEN_ALTRET);
               CALL M$RPRIV(FMEFT_PRIV);
               CALL M$CLOSE(CLOSE_RELEASE) ALTRET(CLOSE_ALTRET);
               FIT$=ADDR(FPARAM_BUF);
               CODE=4;
               CALL XSF$LOCCODE(FIT$,CODE) ALTRET(CODE04_ALTRET);
               FIT$->CODE04.CREATOR.ACCT=MSC_ACCT.ACCT#;
               FIT$->CODE04.CREATOR.NAME='100CONTROL';
               OPEN_TRACKER.FPARAM_=VECTOR(ERASE);
               OPEN_TRACKER.IFPARAM_=VECTOR(FPARAM_BUF);
               CALL M$SPRIV(FMEFT_PRIV);
               CALL M$OPEN(OPEN_TRACKER) ALTRET(OPEN_ALTRET);
               CALL M$RPRIV(FMEFT_PRIV);
               OPEN_TRACKER.IFPARAM_=VECTOR(ERASE);
               CALL M$WRITE(WR_HEADER) ALTRET(BAD_WRITE_ALTRET);
               CALL M$WRITE(WR_UNDERLINES) ALTRET (BAD_WRITE_ALTRET);
             END;
          ELSE GOTO BUSY_MAYBE;
        END;
/**/
     CALL M$WRITE(WR_TRACKER) ALTRET(BAD_WRITE_ALTRET);
     CALL M$CLOSE(CLOSE_TRACKER) ALTRET(CLOSE_ALTRET);
/**/
     DO WHILE('0'B);
BUSY_MAYBE:;
          IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$FILEBUSY
          THEN DO;
               CALL MYWRITE(WAIT_TRACKER_MSG,LENGTHC(WAIT_TRACKER_MSG));
               CALL M$WAIT(FPT_WAIT);
               IF I<=10 THEN GOTO TRY_AGAIN;
               ELSE CALL MYWRITE(FILE_BUSY_MSG,LENGTHC(FILE_BUSY_MSG));
             END;
          ELSE DO;
               ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
               FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
               CALL MYWRITE(BAD_OPEN_MSG,LENGTHC(BAD_OPEN_MSG));
               CALL M$ERRMSG(FPT_ERRMSG);
             END;
        END;                            /* end do while                       */
/**/
     DO WHILE('0'B);
CLOSE_ALTRET:;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL MYWRITE(BAD_CLOSE_MSG,LENGTHC(BAD_CLOSE_MSG));
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
/**/
     DO WHILE('0'B);
BAD_WRITE_ALTRET:;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL MYWRITE(CANT_WRITE_MSG,LENGTHC(CANT_WRITE_MSG));
          CALL M$ERRMSG(FPT_ERRMSG);
        END;
/**/
     DO WHILE('0'B);
CODE04_ALTRET:;
          CALL MYWRITE(NO_CODE04_MSG,LENGTHC(NO_CODE04_MSG));
        END;
/**/
     RETURN;
END TRACKER;
  %EJECT;
ECHO_INPUT: PROC(PROMPT_CHAR,BUFFER);
/**/
DCL PROMPT_CHAR CHAR(5) UNAL;
DCL BUFFER CHAR(256);
DCL OUTPUT_LINE CHAR(145) STATIC;
/**/
  %FPT_WRITE(FPTN=ECHO_WRITE,DCB=M$LO,BUF=OUTPUT_LINE);
/**/
     IF DCBADDR(DCBNUM(M$SI))->F$DCB.DDEV.IC# OR NOT (B$JIT.CPFLAGS1&%CP_ECHO#)
     THEN RETURN;
     ELSE DO;
          CALL CONCAT(OUTPUT_LINE,PROMPT_CHAR,BUFFER);
          CALL M$WRITE(ECHO_WRITE);
        END;
     RETURN;
END ECHO_INPUT;
/**/
  %EJECT;
FID_PARSE: PROC ALTRET;
/**/
%FPT_OPEN  (FPTN=OPN_TST,DCB=M$INPUT,NAME=ERASE,
            ACCT=MSC_ACCT,FUN=IN,TEST=YES,ASN=FILE);
/**/
     CALL M$FID(WR_FID) ALTRET(BAD_FID);
     IF RES_WR_FID.ACCT
     THEN DO;
          ACCTNAME = RD_ACCT.ACCT#;
          CALL INDEX(ACCTLEN,' ',ACCTNAME,1);
          TUI_ACCT.ACCT# = ACCTNAME;
          IF SUBSTR(ACCTNAME,ACCTLEN-2,2)='UI' THEN DO;
               CONTROLLED_FLAG=1;
               MSC_ACCT.ACCT#=TUI_ACCT.ACCT#;
               IF SUBSTR(ACCTNAME,ACCTLEN-3,1)='T' THEN
                    CALL INSERT(MSC_ACCT.ACCT#,ACCTLEN-3,3,'MSC');
               ELSE
                    IF ACCTLEN<8 THEN
                         CALL INSERT(MSC_ACCT.ACCT#,ACCTLEN-2,3,'MSC');
                    ELSE
                         GOTO NOT_CONTROLLED;
               IF MSC_ACCT.ACCT# = ':XMSC'
               THEN
                    MSC_ACCT.ACCT# = ':XMISC';
               FPARAM_BUF(0)=0;
               CALL M$OPEN(OPN_TST) ALTRET(OPN_TST_ERR);
OPN_TST_ERR:
               IF NOT DCBADDR(DCBNUM(M$INPUT))->F$DCB.FFLG.READ# THEN
                    GOTO NOT_CONTROLLED; /* No MSC acct or can't see it */
               IF USER_ACCN=MSC_ACCT.ACCT# THEN
                    USER_IN_MSC=1;
               ELSE
                    USER_IN_MSC=0;
             END;
          ELSE DO;
NOT_CONTROLLED:
               MSC_ACCT.ACCT#=' ';
               CONTROLLED_FLAG=0;
               USER_IN_MSC=0;
             END;
          IF RES_WR_FID.NAME
          THEN FILE_ALREADY_SPECIFIED = '1'B;
          ELSE FILE_ALREADY_SPECIFIED = '0'B;
        END;
     ELSE DO;
          CALL MYWRITE(NO_ACCOUNT_SPEC_MSG,LENGTHC(NO_ACCOUNT_SPEC_MSG));
          ALTRETURN;
        END;
/**/
     IF FORCE_MSC~=0 THEN
          USER_IN_MSC=1;                /* For debugging */
     IF FORCE_CONTROLLED~=0 THEN
          CONTROLLED_FLAG=1;            /* For debugging */
     RETURN;
BAD_FID: CALL MYWRITE(BADFID_MSG,LENGTHC(BADFID_MSG));
     ALTRETURN;
END FID_PARSE;
  %EJECT;
/**/
LOCK: PROC(FLG);
/**/
DCL FLG UBIN;
/**/
DCL LOCKED UBIN;
/**/
     LOCKED=0;
     LIST_KEY.LINE_NUMBER = 0;
     COMMANDBUF=PTR$->OUT$SYM.TEXT;
     CALL FID_PARSE ALTRET(LOCK_END);
     IF FLG=1 THEN DO;
          RD_FID.NAME#=' ';             /* ignore any name specified */
          IF USER_IN_MSC=0 THEN
               LIST_ACCN=USER_ACCN;
          ELSE
               LIST_ACCN='DONE';
        END;
     IF USER_IN_MSC=0 AND FLG~=1 THEN DO;
          CALL MYWRITE(MUST_BE_MSC_MSG,LENGTHC(MUST_BE_MSC_MSG));
          RETURN;
        END;
     CALL CHECK_LIST_FILE ALTRET(LOCK_END);
     DO WHILE ('1'B);
          IF NOT FILE_ALREADY_SPECIFIED OR FLG=1 THEN
OPN_AGAIN:
               CALL M$OPEN(OPEN_NEXT_FILE) ALTRET(OPN_NXT_ERR);
          ELSE
               CALL M$OPEN(OPEN_THIS_FILE) ALTRET(OPN_ERR);
          RD_FID.L# = DCBADDR(DCBNUM(M$INPUT))->F$DCB.NAME#.L;
          RD_FID.NAME# = DCBADDR(DCBNUM(M$INPUT))->F$DCB.NAME#.C;
          NRECS=DCBADDR(DCBNUM(M$INPUT))->F$DCB.NRECS#;
          IF FLG~=1 THEN
               CALL CHECK_FOR_DONE(FLG) WHENALTRETURN DO;
                    IF NOT FILE_ALREADY_SPECIFIED THEN
                         GOTO OPN_AGAIN;
                    CALL MYWRITE(CANT_LOCK_MSG,LENGTHC(CANT_LOCK_MSG));
                    RETURN;
                  END;
          ELSE
               CALL CHECK_FOR_LIST ALTRET(OPN_AGAIN);
          WRITE_FILENAMES_MSG=RD_FID.NAME#;
          LOCKED=LOCKED+1;
          LIST_KEY.LINE_NUMBER = LIST_KEY.LINE_NUMBER + 1000;
          IF DCBADDR(DCBNUM(M$LIST))->F$DCB.ASN# = %FILE#
          THEN
          DO;
               CALL M$WRITE(WRITE_FILENAMES);
             END;
          ELSE
          DO;
               SAVE_VECTR = ADDR(WRITE_FILENAMES.KEY_)->A_VECTOR;
               WRITE_FILENAMES.KEY_ = VECTOR(NIL);
               CALL M$WRITE (WRITE_FILENAMES);
               ADDR(WRITE_FILENAMES.KEY_)->A_VECTOR = SAVE_VECTR;
             END;
          BUF_LEN=12;
          IF FLG=0 THEN
               CALL TRACKER(NRECS,BUF_LEN,'** LOCKED **');
          IF FILE_ALREADY_SPECIFIED THEN GOTO END_OF_ACCOUNT;
        END;                            /*DO WHILE('1'B)*/
OPN_NXT_ERR: ;
     RD_FID=DCBADDR(DCBNUM(M$INPUT))->F$DCB.NAME#;
     IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOACCESS THEN
          GOTO OPN_AGAIN;
     IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$FDEOF THEN
          GOTO END_OF_ACCOUNT;
     GOTO ERR;
END_OF_ACCOUNT:;
     CALL M$CLOSE(CLOSE_LIST);
     CALL BINCHAR(FILES_LOCKED_MSG.NUMBER,LOCKED);
     IF FLG=0 THEN DO;
          CALL BINCHAR(FILES_LOCKED_MSG.NUMBER,LOCKED);
          CALL MYWRITE(FILES_LOCKED_MSG,LENGTHC(FILES_LOCKED_MSG));
        END;
     ELSE IF FLG=1 THEN DO;
               CALL BINCHAR(FILES_LISTED_MSG.NUMBER,LOCKED);
               CALL MYWRITE(FILES_LISTED_MSG,LENGTHC(FILES_LISTED_MSG));
             END;
          ELSE DO;
               CALL BINCHAR(FILES_STRIPD_MSG.NUMBER,LOCKED);
               CALL MYWRITE(FILES_STRIPD_MSG,LENGTHC(FILES_STRIPD_MSG));
             END;
LOCK_END:;
     RETURN;
/**/
/**/
OPN_ERR: ;
     IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$FDEOF THEN
          GOTO END_OF_ACCOUNT;
ERR: ;
     ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
     CALL M$ERRMSG(FPT_ERRMSG);
     CALL M$CLOSE(CLOSE_LIST);
     RETURN;
END LOCK;
%EJECT;
/**/
/* Unlock a previously locked file */
/**/
UNLOCK: PROC;
/**/
    %FPT_CLOSE(FPTN=CLOSE_REM_ACCESS,
               DCB=M$INPUT,
               CHGATT=YES,
               UPDDESC=YES,
               IFPARAM=FPARAM_BUF,
               DISP=SAVE,
               ACCESS=ZEROS);
/**/
    %FPT_CLOSE(FPTN=FPT_CLOSE,
               DCB=M$INPUT,
               DISP=SAVE);
/**/
DCL ZEROS UBIN CONSTANT INIT(0);
/**/
     FIT$=ADDR(FPARAM_BUF);
     CALL M$SPRIV(FMSEC_PRIV);          /* Make sure we get a full CODE04 */
     CALL M$OPEN(OPEN_INPUT_FILE) ALTRET(OPN_ERR);
     CALL M$RPRIV(FMSEC_PRIV);
     CALL XSF$LOCCODP(FIT$,9) ALTRET(CANT_UNLOCK);
     IF FIT$->CODE09.ACCT~='?MSC' THEN
          GOTO CANT_UNLOCK;
     NRECS=DCBADDR(DCBNUM(M$INPUT))->F$DCB.NRECS#;
     CALL M$SPRIV(FMEFT_PRIV);
     CALL M$CLOSE(CLOSE_REM_ACCESS) ALTRET(CLS_ERR);
     CALL M$RPRIV(FMEFT_PRIV);
     BUF_LEN=14;
     CALL TRACKER(NRECS,BUF_LEN,'** UNLOCKED **');
/**/
UNLOCK_END: ;
     RETURN;
/**/
CANT_UNLOCK: ;
     CALL MYWRITE(CANT_UNLOCK_MSG,LENGTHC(CANT_UNLOCK_MSG));
     CALL M$CLOSE(FPT_CLOSE);
     RETURN;
/**/
OPN_ERR: ;
CLS_ERR: ;
     ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
     CALL M$ERRMSG(FPT_ERRMSG);
     CALL M$RPRIV(FMEFT_PRIV);
     CALL M$RPRIV(FMSEC_PRIV);
     RETURN;
/**/
END UNLOCK;
  %EJECT;
/**/
CHECK_LIST_FILE: PROC ALTRET;
DCL SAVE_ACCOUNT CHAR(8);
/**/
     ERROR=0;
     SAVE_ACCOUNT = RD_ACCT.ACCT#;
     IF COMMANDS.OUT$->OUT$BLK.NSUBLKS=1
     THEN CALL M$OPEN(OPEN_LIST_DEV) ALTRET(BAD_OPEN_DEV);
     ELSE DO;
          DO CASE(COMMANDS.OUT$->OUT$BLK.SUBLK$(1)->OUT$BLK.CODE);
          CASE(ON#);
             OPEN_LIST_FILE.V.EXIST#=%ERROR#;
          CASE(INTO#);
             OPEN_LIST_FILE.V.EXIST#=%OLDFILE#;
          CASE(OVER#);
             OPEN_LIST_FILE.V.EXIST#=%NEWFILE#;
          END;                          /*CASE*/
          COMMANDBUF=COMMANDS.OUT$->OUT$BLK.SUBLK$(2)->OUT$SYM.TEXT;
          CALL M$FID(WR_FID);
          IF RES_WR_FID.NAME
          THEN CALL M$OPEN(OPEN_LIST_FILE) ALTRET(BAD_OPEN_FILE);
          ELSE DO;
               CALL MYWRITE(NO_LIST_FID_SPEC_MSG,LENGTHC(NO_LIST_FID_SPEC_MSG));
               ALTRETURN;
             END;
          RD_ACCT.ACCT# = SAVE_ACCOUNT;
          RD_FID.NAME# = ' ';
          RETURN;
        END;
     DO WHILE('0'B);
BAD_OPEN_DEV:;
          CALL MYWRITE(LIST_OPEN_DEV_ERROR_MSG,LENGTHC(LIST_OPEN_DEV_ERROR_MSG));
          ERROR=1;
        END;
     DO WHILE('0'B);
BAD_OPEN_FILE:;
          CALL MYWRITE(LIST_OPEN_FILE_ERROR_MSG,LENGTHC(LIST_OPEN_FILE_ERROR_MSG));
          ERROR=1;
        END;
     IF ERROR=1
     THEN DO;
          ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
          FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
          CALL M$ERRMSG(FPT_ERRMSG);
          ALTRETURN;
        END;
END CHECK_LIST_FILE;
  %EJECT;
/**/
CHECK_FOR_DONE: PROC(FLG) ALTRET;
 
DCL FLG UBIN;                           /* nonzero for STRIP command */
/**/
DCL ACCESS$ PTR;
/**/
  %FPT_CLOSE(FPTN=CLOSE_INPUT_FILE,
           DCB=M$INPUT,
           CHGATT=YES,
           UPDDESC=YES,
           IFPARAM=FPARAM_BUF,
           ACCESS=NEW_ATTR,
           STCLASS=STATIC);
/**/
  %VLP_ATTR(FPTN=NEW_ATTR,STCLASS=STATIC);
  %VLP_ACCESS(READ=YES,
              DELR=YES,
              WNEW=YES,
              UPD=YES,
              DELF=YES,
              REATTR=YES,
              ACCT='?MSC');
  %VLP_ACCESS(READ=YES,
              DELR=YES,
              WNEW=YES,
              UPD=YES,
              DELF=YES,
              REATTR=YES,
              ACCT='?MISC');
  %VLP_ACCESS(READ=YES,
              DELR=NO,
              WNEW=NO,
              UPD=NO,
              DELF=NO,
              REATTR=NO,
              ACCT='?',
              LAST=";");
/**/
     ERROR=0;
     FIT$=ADDR(FPARAM_BUF);
     ACCESS$=FIT$;
     CODE=9;
     CALL XSF$LOCCODE(ACCESS$,CODE) ALTRET(NO_ACCESS_LIST);
     IF ACCESS$->CODE09.ACCT='DONE' AND FLG=0
          AND FIT$->FM$FIT.CODES.NDW(CODE)*4/LENGTHC(ACCESS$->CODE09)=1
          OR FIT$->FM$FIT.CODES.NDW(CODE)>0 AND FLG>0
     THEN DO;
          CALL M$SPRIV(FMSEC_PRIV);     /* Get a complete CODE04 */
          CALL M$OPEN(OPEN_INPUT_FILE) ALTRET(BAD_OPEN);
          CALL M$SPRIV(FMEFT_PRIV);
          IF FLG>0 THEN NEW_ATTR.SIZ#=0;
          ELSE NEW_ATTR.SIZ#=SIZEW(NEW_ATTR.Q);
          CALL M$CLOSE(CLOSE_INPUT_FILE) ALTRET(BAD_CLOSE);
          CALL M$RPRIV(FMEFT_PRIV);
          CALL M$RPRIV(FMSEC_PRIV);
        END;
     ELSE DO;
NO_ACCESS_LIST:;
          ALTRETURN;
        END;
     RETURN;
BAD_OPEN:;
     CALL MYWRITE(BAD_OPEN_ERROR_MSG,LENGTHC(BAD_OPEN_ERROR_MSG));
     DO WHILE('0'B);
BAD_CLOSE:;
          CALL MYWRITE(BAD_CLOSE_ERROR_MSG,LENGTHC(BAD_CLOSE_ERROR_MSG));
        END;
     ERROR=1;
     ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
     CALL M$ERRMSG(FPT_ERRMSG);
     CALL M$RPRIV(FMEFT_PRIV);
     CALL M$RPRIV(FMSEC_PRIV);
     ALTRETURN;
END CHECK_FOR_DONE;
%EJECT;
/**/
CHECK_FOR_LIST: PROC ALTRET;
/**/
     FIT$=ADDR(FPARAM_BUF);
     CODE=9;
     CALL XSF$LOCCODE(FIT$,CODE) ALTRET(NO_ACCESS_LIST);
     ACC_LEN=LENGTHC(CODE09);
     ACC_NO=(ADDR(FPARAM_BUF)->FM$FIT.CODES.NDW(CODE)*4)/ACC_LEN;
     DO WHILE(ACC_NO~=0);
          IF FIT$->CODE09.ACCT=LIST_ACCN THEN
               RETURN;
          FIT$=PINCRC(FIT$,ACC_LEN);
          ACC_NO=ACC_NO-1;
        END;
NO_ACCESS_LIST: ;
     ALTRETURN;
END CHECK_FOR_LIST;
  %EJECT;
/**/
DELETE: PROC;
/**/
/**/
  %FPT_OPEN(FPTN=OPEN_INPUT,
              DCB=M$INPUT,
              ASN=FILE,
              NAME=RD_FID,
              ACCT=TUI_ACCT,
              PASS=RD_PASS,
              FPARAM=FPARAM_BUF,
              FUN=UPDATE,
              TEST=YES,
              STCLASS=STATIC);
/**/
  %FPT_OPEN(FPTN=OPEN_INPUT_DELETE,
              DCB=M$INPUT,
              ASN=FILE,
              NAME=RD_FID,
              ACCT=TUI_ACCT,
              PASS=RD_PASS,
              DELETE=YES,
              STCLASS=STATIC);
/**/
  %FPT_WRITE(FPTN=DELETED,DCB=M$LO,BUF=DELETED_MSG);
/**/
DCL 1 DELETED_MSG STATIC,
         2 * CHAR(0) INIT('Deleted: '),
         2 FILE CHAR(32);
DCL ACCESS$ PTR;
DCL NUMBER_ACCOUNTS UBIN(18);
/**/
     CALL M$RPRIV(FMSEC_PRIV);
     DELETED_MSG.FILE=RD_FID.NAME#;
/**/
     IF CONTROLLED_FLAG=0 THEN DO;
          CALL M$OPEN(OPEN_INPUT_DELETE) ALTRET(DEL_ERR);
          CALL M$WRITE(DELETED);
          RETURN;
        END;
/**/
     CALL M$OPEN(OPEN_INPUT) ALTRET(SORRY_BUDDY);
     FIT$=ADDR(FPARAM_BUF);
     ACCESS$=FIT$;
     CODE=9;
     CALL XSF$LOCCODE(ACCESS$,CODE) ALTRET(SORRY_BUDDY);
     NUMBER_ACCOUNTS=FIT$->FM$FIT.CODES.NDW(CODE)*4/
          LENGTHC(ACCESS$->CODE09);
     IF NUMBER_ACCOUNTS=1
     THEN IF ACCESS$->CODE09.ACCT=USER_ACCN
          THEN DO;
               CALL M$SPRIV(FMSEC_PRIV);
               CALL M$OPEN(OPEN_INPUT_DELETE) ALTRET(SORRY_BUDDY);
               CALL M$WRITE(DELETED);
               NRECS = DCBADDR(DCBNUM(M$INPUT))->F$DCB.NRECS#;
               TRACKER_BUF = '*** DELETED BY          ***';
               CALL INSERT(TRACKER_BUF,15,8,USER_ACCN);
               BUF_LEN = 27;
               CALL TRACKER(NRECS,BUF_LEN,TRACKER_BUF);
             END;
          ELSE DO;
SORRY_BUDDY:   CALL MYWRITE(CANT_DELETE_MSG,LENGTHC(CANT_DELETE_MSG));
             END;
     ELSE DO;
          CALL MYWRITE(NOT_SOLE_ACCESS_MSG,LENGTHC(NOT_SOLE_ACCESS_MSG));
        END;
     RETURN;
/**/
DEL_ERR: ;
     ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
     CALL M$ERRMSG(FPT_ERRMSG);
     RETURN;
/**/
END DELETE;
/**/
%EJECT;
TRACK: PROC;
/**/
DCL FLEN UBIN;
/**/
%FPT_OPEN (FPTN=OPENTRACK,
           DCB=M$OUTPUT,
           SCRUB=YES,
           FUN=IN,
           ASN=FILE,
           NAME=RD_FID,
           PASS=RD_PASS,
           ACCT=RD_ACCT,
           SN=RD_SN);
%FPT_PFIL (FPTN=PFILTRACK,
           DCB=M$OUTPUT,
           BOF=NO);
%FPT_READ (FPTN=READTRACK,
           DCB=M$OUTPUT,
           BUF=TRKBUF);
%FPT_PRECORD (FPTN=PRECTRACK,
           DCB=M$OUTPUT,
           N=-2);
%FPT_CLOSE (FPTN=CLOSETRACK,
           DCB=M$OUTPUT);
%FPT_WRITE (FPTN=WRITETRACK,
           DCB=M$LO,
           BUF=TRKBUF);
/**/
     COMMANDBUF=PTR$->OUT$SYM.TEXT;
     CALL M$FID(WR_FID);
     IF NOT RES_WR_FID.NAME THEN
          RD_FID=TRACKER_NAME;
     CALL M$OPEN(OPENTRACK) ALTRET(OPN_ERR);
     CALL M$PFIL(PFILTRACK) ALTRET(OPN_ERR);
     IF COMMANDS.OUT$->OUT$BLK.NSUBLKS>1 THEN DO;
          PTR$=COMMANDS.OUT$->OUT$BLK.SUBLK$(1);
          COMMANDBUF=PTR$->OUT$SYM.TEXT;
          CALL INDEX(FLEN,'?',COMMANDBUF);
          IF FLEN=SIZEC(COMMANDBUF) THEN
               FLEN=31;
        END;
     ELSE
          FLEN=0;
/**/
     PRECTRACK.V.N#=-1;
     CALL M$PRECORD(PRECTRACK) ALTRET(PREC_ERR);
     PRECTRACK.V.N#=-2;
     GOTO READ;
/**/
LOOP:
     CALL M$PRECORD(PRECTRACK) ALTRET(PREC_ERR);
/**/
READ:
     TRKBUFC=' ';
     CALL M$READ(READTRACK) ALTRET(OPN_ERR);
     IF TRKBUF.NAME='NAME' THEN
          GOTO LOOP;
     IF SUBSTR(TRKBUF.NAME,0,FLEN)=SUBSTR(COMMANDBUF,0,FLEN) THEN
          CALL M$WRITE(WRITETRACK);
     GOTO LOOP;
/**/
OPN_ERR:
     ERR_CODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     FPT_ERRMSG.V.DCB#=B$TCB$->B$TCB.ALT$->B$EXCFR.DCB#;
     CALL M$ERRMSG(FPT_ERRMSG);
XIT: CALL M$CLOSE(CLOSETRACK);
     RETURN;
/**/
PREC_ERR:
     IF B$TCB$->B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$BOF THEN
          GOTO XIT;
     GOTO OPN_ERR;
/**/
END TRACK;
%EJECT;
MYWRITE: PROC(MESSAGE,MESSAGE_LENGTH) ALTRET;
/**/
DCL MESSAGE CHAR(256);
DCL MESSAGE_LENGTH UBIN(36);
/**/
  %FPT_WRITE(FPTN=LO_WRITE,
              DCB=M$LO);
/**/
     LO_WRITE.BUF_ = VECTOR(MESSAGE);
     LO_WRITE.BUF_.BOUND = MESSAGE_LENGTH-1;
     CALL M$WRITE(LO_WRITE) ALTRET(ERROR_ON_WRITE);
     RETURN;
ERROR_ON_WRITE: ALTRETURN;
END MYWRITE;
END MODMOVE_DRIVER;
