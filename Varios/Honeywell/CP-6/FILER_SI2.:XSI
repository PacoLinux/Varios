/*M* FILER_SI2 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* THI=1,PLM=3,IND=3 */
%EJECT;
/*********************************************************************/
/*
***   AM_COMPRESS_FWD  22 AUG 77  (PRY)  COMPRESSES THE BLOCKS IN THE
***   BLOCK SPACE REGION FROM LOW_IX# TO HIGH_IX# BY MOVING USED PORTIONS
***   OF USED BLOCKS FORWARD.  UNUSED SPACE IS LEFT COALESCED AT THE
***   END OF THE REGION.
*/
 
 
AM_COMPRESS_FWD: PROC( LOW_IX#, HIGH_IX#, FREE_IX# );
%INCLUDE FILER_II5;
 
/***   MOVE A BLOCK   ***/
DCL   AM_MOVE_BLK            ENTRY(3);
 
/***   INDICATE THAT BLOCKS HAVE BEEN MOVED   ***/
DCL   UT_INDICATE_COMPACTION ENTRY(2);
 
/***************
***   PARAMETERS:
*/
DCL   LOW_IX#        SBIN WORD ALIGNED; /* INDEX OF LOWEST BLOCK              */
DCL   HIGH_IX#       SBIN WORD ALIGNED; /* INDEX OF HIGHEST BLOCK             */
DCL   FREE_IX#          SBIN WORD ALIGNED;
                                        /* RETURNED IX OF FIRST FREE WORD     */
 
/***************
***   LOCALS:
*/
DCL   SCAN_IX   SBIN WORD ALIGNED AUTO; /* BLOCK SCANNING IX                  */
DCL   SIZE      SBIN WORD ALIGNED AUTO; /* SIZE OF CURRENT BLOCK              */
DCL  MOVE_TO_IX SBIN WORD ALIGNED AUTO; /* NEXT FREE WORD                     */
DCL MOVE_FROM_IX SBIN WORD ALIGNED AUTO; /* IX OF MOVE FROM BLOCK             */
DCL   MOVE_SIZE SBIN WORD ALIGNED AUTO; /* COUNTS # WORDS TO MOVE             */
DCL   HIGH_IX   SBIN WORD ALIGNED AUTO; /* LOCALIZES HIGH_IX#                 */
DCL   BLK_PTR$        PTR ALIGNED AUTO; /* POINTER TO CURRENT BLOCK           */
DCL   NUNUSED   SBIN WORD ALIGNED AUTO; /* NUMBER UNUSED                      */
DCL   NSIZE             SBIN WORD ALIGNED   AUTO;
                                        /* NEW SIZE OF CURRENT BLOCK          */
DCL   MOVE_THEM SBIN WORD ALIGNED AUTO; /* FLAG IF MOVE NECESSARY             */
 
/***************
***   INITIALIZE COMPRESSION.
*/
   SCAN_IX    = LOW_IX#;                /* START SCAN AT LOW IX               */
   MOVE_TO_IX = SCAN_IX;                /* COMPRESS TO LOW IX                 */
   MOVE_SIZE  = 0;                      /* NOTHING TO MOVE YET                */
   HIGH_IX    = HIGH_IX#;               /* LOCALIZE FOR CHECKING              */
   MOVE_THEM  = 0;                      /* Nothing to move                    */
/*
***   COMPRESS BLOCKS.
*/
   DO WHILE (SCAN_IX <= HIGH_IX);
      BLK_PTR$ = PINCRW( DATA_BASE$, SCAN_IX );
                                        /* POINT TO CURRENT BLOCK             */
      SIZE     = BLK_PTR$ -> BLK.SIZE;  /* GET SIZE OF BLOCK                  */
         /*
         ***   IF BLOCK IS IN USE REMOVE ANY UNUSED WORDS AND MOVE IT.
         */
      IF BLK_PTR$ -> BLK.ID < UNUSED_BUF_ID
                                        /* BLOCK IN USE?                      */
       THEN DO;                         /* SURE IS!                           */
         IF MOVE_THEM = 1               /* ANYTHING TO MOVE?                  */
          THEN DO;                      /* YES                                */
            CALL AM_MOVE_BLK( MOVE_FROM_IX, MOVE_TO_IX, MOVE_SIZE );
                                        /* MOVE ACCUMULATED BLOCKS            */
            MOVE_THEM  = 0;             /* RESET MOVE FLAG                    */
            MOVE_TO_IX = MOVE_TO_IX + MOVE_SIZE;
                                        /* IX NEXT FREE WORD                  */
            MOVE_SIZE  = 0;             /* NOTHING ELSE TO MOVE NOW           */
            END;
         TPTR1$  = PINCRW( BLK_PTR$, SIZE-2 );
                                        /* POINT TO BLOCK FOOTER              */
         NUNUSED = ( (TPTR1$ -> BLK_FTR.NUNUSED) / 2) * 2;
                                        /* GET # UNUSED WORDS                 */
              /*
              ***   IF ANY UNUSED WORDS, MODIFY BLOCK INFO WORDS.
              */
         IF NUNUSED > 0                 /* ANY UNUSED?                        */
          THEN DO;                      /* YES                                */
                   /*
                   */
            TPTR2$                    = PINCRW( TPTR1$, -NUNUSED );
                                        /* POINT TO NEW BLOCK FOOTER          */
            TPTR2$ -> BLK_FTR.ID      = BLK_PTR$ -> BLK.ID;
                                        /* XFER ID                            */
            NSIZE                     = SIZE - NUNUSED;
                                        /* CALC NEW SIZE                      */
            BLK_PTR$ -> BLK.SIZE      = NSIZE;
                                        /* SET NEW SIZE IN HDR                */
            TPTR2$ -> BLK_FTR.SIZE    = NSIZE;
                                        /* AND IN FTR                         */
            TPTR2$ -> BLK_FTR.NUNUSED = 0;
                                        /* NOTHING UNUSED NOW                 */
            MOVE_THEM                 = 1;
                         /* BLOCK MUST BE MOVED BEFORE ANY OTHERS ARE ADDED   */
            END;
          ELSE NSIZE = SIZE;            /* BLOCK ENTIRELY USED                */
         IF MOVE_SIZE = 0               /* NEW BLOCK TO MOVE?                 */
          THEN MOVE_FROM_IX = SCAN_IX;  /* YES: SAVE ITS IX                   */
         MOVE_SIZE = MOVE_SIZE + NSIZE;
                                        /* ADD SIZE OF BLOCK TO #WDS TO MOVE  */
         END;
 
       ELSE IF MOVE_SIZE > 0 THEN MOVE_THEM = 1;
                                        /* BLOCK IS NOT IN USE                */
      SCAN_IX   = SCAN_IX + SIZE;
                                        /* MOVE SCAN IX TO NEXT BLOCK         */
      END;
/*
***   MOVE ANY REMAINING UNMOVED BLOCKS.
*/
   IF MOVE_SIZE > 0                     /* ANYTHING ELSE TO MOVE?             */
    THEN DO;                            /* YES                                */
      CALL AM_MOVE_BLK( MOVE_FROM_IX, MOVE_TO_IX, MOVE_SIZE );
                                        /* MOVE THE LAST CHUNK OF BLOCKS      */
      MOVE_TO_IX = MOVE_TO_IX + MOVE_SIZE;
      END;
/*
***   RETURN IX OF FIRST UNUSED BLOCK OF COMPACTED REGION; INDICATE
***   COMPACTION OF BLOCKS TOOK PLACE.
*/
   FREE_IX#   = MOVE_TO_IX;             /* RETURN IX OF FIRST UNUSED BLOCK    */
   MOVE_TO_IX = MOVE_TO_IX - 1;
                                   /* CALC IX OF LAST USED WORD OF REGION     */
   CALL UT_INDICATE_COMPACTION( LOW_IX#, MOVE_TO_IX );
 
   RETURN;
 
END AM_COMPRESS_FWD;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_COMPACT  18 AUG 77  (PRY)  COMPACTS THE BLOCK SPACE BY
***   ELIMINATING UNUSED BLOCKS AND UNUSED WORDS FROM USED BLOCKS.
***   BUFFER/VALUE DESCRIPTORS ARE ADJUSTED TO REFLECT COMPACTION.
*/
 
AM_COMPACT: PROC( WORDS_FREED# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***   FREE DYNAMIC PAGES   ***/
DCL   AM_FREE_PAGES          ENTRY(1);
 
 
/***   COMPRESS A REGION OF BLOCK SPACE TOWARD THE FRONT   ***/
DCL   AM_COMPRESS_FWD        ENTRY(3);
 
/***   OUTPUT A STRING OF CHARACTERS   ***/
DCL   UT_OUTPUT_CHARS        ENTRY(2);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
 
/***   PRINT A SIZE SPECIFICATION   ***/
DCL   UT_PRINT_SIZE          ENTRY(1);
 
/***************
***   PARAMETERS:
*/
DCL   WORDS_FREED#      SBIN WORD ALIGNED;
                                   /* RETURNED NUMBER OF WORDS ACTUALLY FREED */
 
/***************
***   LOCALS:
*/
DCL   NEW_END_BLK_IX    SBIN WORD ALIGNED   AUTO;
                         /* USED TO CALC IX OF END BLOCK AFTER COMPACTION     */
DCL   NBR_PAGES_UNUSED  SBIN WORD ALIGNED   AUTO;
                              /* USED TO CALC THE NUMBER OF PAGES UNUSED A.C. */
DCL   LOCAL_TEMP        SBIN WORD ALIGNED   AUTO;
                                        /* USED TO PASS COMPUTED ARG          */
 
 
/********************
***   TELL USER THAT COMPACTION IS TAKING PLACE.
**/
   CALL UT_FLUSH_BUF;                   /* GET BUFFER READY FOR NEW MESSAGE   */
/***************
***   COMPRESS THE ENTIRE BLOCK SPACE FORWARD.
*/
   LOCAL_TEMP = END_BLK_IX - 1;         /* CALC IX OF LAST USED WORD          */
   CALL AM_COMPRESS_FWD( LOWEST_DEALLOC_IX, LOCAL_TEMP,
     NEW_END_BLK_IX );
   WORDS_FREED# = END_BLK_IX - NEW_END_BLK_IX;
                                        /* CALC THE NUMBER OF WORDS FREED     */
   LOCAL_TEMP   = WORDS_FREED# * 36;    /* CONVERT # WORDS TO SIZE            */
/***F LOCAL_TEMP > 0               /* ONLY TELL OF COMPACTION IF WORDS FREED  */
/***THEN DO;
/***  CALL UT_OUTPUT_CHARS( '*** ', 4 );
/***  CALL UT_PRINT_SIZE( LOCAL_TEMP ); /* PRINT THE SIZE                     */
/***  CALL UT_OUTPUT_CHARS( ' freed during compaction ***', 28 );
/***  CALL UT_FLUSH_BUF;
/***  END;
/***/
/*
***   SET UP THE END BLOCK.
*/
   END_BLK_IX    = NEW_END_BLK_IX;      /* SAVE ITS NEW IX                    */
   TPTR1$        = PINCRW( DATA_BASE$, END_BLK_IX );
                                        /* POINT TO IT                        */
   TPTR1$ -> BLK = END_BLK;             /* SET IT UP                          */
/*
***   FREE ANY UNUSED PAGES.
*/
   NBR_PAGES_UNUSED = (LAST_FREE_IX - END_BLK_IX) / 1024;
   CALL AM_FREE_PAGES( NBR_PAGES_UNUSED );
/*
***   RESET THE INDEX OF THE LOWEST BLOCK DEALLOCATED.
*/
   LOWEST_DEALLOC_IX = END_BLK_IX;
 
   RETURN;
 
END AM_COMPACT;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   CTABLE   3 OCT 77   (PRY)   COMMAND, FPT AND OPTION
***   TABLE CODES.
**/
 
CTABLE: PROC;
 
/*** SYMDEF    INITIALIZATION FUNCTIONS ***/
DCL   IF_NONE           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(0);
DCL   IF_ADDR           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(1);
DCL   IF_SIZEB          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(2);
DCL   IF_SIZEC          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(3);
DCL   IF_SIZEV          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(4);
DCL   IF_SIZEW          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(5);
DCL   IF_VECTOR         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(7);
DCL   IF_LENGTHB        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(8);
DCL   IF_LENGTHC        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(9);
DCL   IF_LENGTHV        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(10);
DCL   IF_LENGTHW        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(11);
DCL   IF_DCBNUM         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(6);
DCL   IF_INTEGER        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(7);
DCL   IF_STRING         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(13);
%EJECT;
 
/*** ITEM TYPES ***/
DCL   IT_NONE           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(0);
DCL   IT_EPTR           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(1);
DCL   IT_DCB            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(2);
DCL   IT_PTR            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(3);
DCL   IT_CHAR           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(4);
DCL   IT_BIT            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(5);
DCL   IT_UBIN           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(6);
DCL   IT_SBINWORD       SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(7);
DCL   IT_SBINHALF       SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(8);
 
/*** VALUE TYPES ***/
DCL   VT_NONE           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(0);
DCL   VT_NAME           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(1);
DCL   VT_INTEGER        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(2);
DCL   VT_STRING         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(3);
DCL   VT_BINSTRING      SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(4);
DCL   VT_OCTSTRING      SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(5);
 
END CTABLE;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_CONTRACT_BLK  12 AUG 77  (PRY)  CONTRACTS BLOCK WITH INDEX
***   BLK_IX# TO BLK_SIZE# WORDS.
*/
 
AM_CONTRACT_BLK: PROC( BLK_IX#, BLK_SIZE# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***   SPLIT OFF UNUSED AREA FROM A USED BLOCK   ***/
DCL   AM_SPLIT_BLK           ENTRY(2);
 
 
/***   DEALLOCATE A BLOCK   ***/
DCL   AM_DEALLOC_BLK         ENTRY(1);
 
 
/*
***   PARAMETERS:
*/
DCL   BLK_IX#           SBIN WORD ALIGNED;
                                        /* INDEX OF BLOCK TO CONTRACT         */
DCL   BLK_SIZE#         SBIN WORD ALIGNED;
                                   /* SIZE BLOCK SHOULD BE AFTER CONTRACTION  */
 
/***************
***   LOCALS:
*/
DCL   BLK_PTR$        PTR ALIGNED AUTO; /* POINTS TO BLOCK                    */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* LOCALIZES BLK_IX#                  */
DCL   SIZE      SBIN WORD ALIGNED AUTO; /* HOLDS SIZE OF BLOCK                */
DCL   NBR_UNUSED        SBIN WORD ALIGNED   AUTO;
                                   /* HOLDS NUMBER OF UNUSED WORDS IN BLOCK   */
 
/***************
***   GET BLOCK INFO.
*/
   BLK_IX   = BLK_IX#;
   BLK_PTR$ = PINCRW( DATA_BASE$, BLK_IX ); /* POINT TO BLOCK'S HEADER        */
   SIZE     = BLK_PTR$ -> BLK.SIZE;     /* GET BLOCK'S CURRENT SIZE           */
   TPTR1$   = PINCRW( BLK_PTR$, SIZE ); /* POINT TO NEXT BLOCK                */
/*
***   IF NEXT BLOCK IS IN USE, JUST SPLIT CURRENT BLOCK.  OTHERWISE
***   ADD WORDS TO NEXT BLOCK.
*/
   IF TPTR1$ -> BLK.ID < UNUSED_BUF_ID  /* IN USE?                            */
    THEN CALL AM_SPLIT_BLK( BLK_IX, BLK_SIZE# );
                                        /* YES: JUST SPLIT BLOCK              */
    ELSE DO;                       /* NOT IN USE: ADD WORDS TO NEXT BLOCK     */
      TPTR1$                    = PINCRW( TPTR1$, -2 );
                                        /* POINT TO CURRENT BLK'S FOOTER      */
      NBR_UNUSED                = SIZE - BLK_SIZE#;
                                   /* CALC # WORDS UNUSED IN CURRENT BLOCK    */
      TPTR1$ -> BLK_FTR.NUNUSED = NBR_UNUSED;
                                        /* PUT IN FOOTER                      */
      BLK_IX                    = BLK_IX + SIZE;
                                        /* CALC IX OF FOLLOWING UNUSED BLOCK  */
      CALL AM_DEALLOC_BLK( BLK_IX );
     /* 'DEALLOCATE' FOLLOWING UNUSED BLOCK TO COMBINE UNUSED WORDS WITH IT   */
      END;
 
   RETURN;
 
END AM_CONTRACT_BLK;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_DEALLOC_BLK  12 AUG 77  (PRY)  DEALLOCATES BLOCK WITH
***   INDEX BLK_IX#.
*/
 
AM_DEALLOC_BLK: PROC( BLK_IX# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   BLK_IX#           SBIN WORD ALIGNED;
                                        /* INDEX OF BLOCK TO DEALLOCATE       */
 
/***************
***   LOCALS:
*/
DCL   BLK_PTR$          PTR       ALIGNED   AUTO;
                                        /* POINTS TO BLOCK_TO_DEALLOCATE      */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* LOCALIZE BLK_IX#                   */
DCL   SIZE              SBIN WORD ALIGNED   AUTO;
                                        /* HOLDS SIZE OF BLOCK TO DEALLOCATE  */
DCL   BUF$              PTR       ALIGNED   AUTO;
                                        /* POINTER TO ASSOCIATED DESCRIPTOR   */
DCL   BID               SBIN WORD ALIGNED   AUTO;
                                        /* ID OF ASSOCIATED DESCRIPTOR        */
DCL   NBR_UNUSED        SBIN WORD ALIGNED   AUTO;
                                        /* HOLDS NUMBER OF WORDS UNUSED       */
DCL   SIZE_PREV SBIN WORD ALIGNED AUTO; /* SIZE OF PREVIOUS BLOCK             */
 
/***************
***   GET BLOCK INFO.
*/
   BLK_IX   = BLK_IX#;
   BLK_PTR$ = PINCRW( DATA_BASE$, BLK_IX ); /* POINT TO BLOCK                 */
   SIZE     = BLK_PTR$ -> BLK.SIZE;     /* GET SIZE                           */
   BID      = BLK_PTR$ -> BLK.ID;       /* AND ID                             */
/*
***   DISASSOCIATE DESCRIPTOR IF ANY.
*/
   IF BID < SPL_BUF_ID                  /* DESCRIPTOR ID?                     */
    THEN DO;                            /* YES                                */
      BUF$ = PINCRW( STRT_BUF_DESC$, BID*BUF_DESC_SIZE );
                                        /* POINT TO DESCRIPTOR                */
      BUF$ -> BUF.BLK$ = ADDR(NIL);     /* DATA POINTER CLEARED               */
      BUF$ -> BUF.IX   = 0;             /* ASSOCIATED BLOCK IX CLEARED        */
      BUF$ -> BUF.TYPE = BT_UNUSED;     /* DESC IS NOW UNUSED                 */
      END;
/*
***   CHECK IF PREVIOUS BLOCK CAN BE COMBINED WITH THIS.
*/
   TPTR1$ = PINCRW( BLK_PTR$, -2 );
                                        /* POINT TO PREVIOUS BLK FOOTER       */
   IF TPTR1$ -> BLK_FTR.ID < UNUSED_BUF_ID /* IS BLOCK IN USE?                */
    THEN DO;                            /* YES:                               */
      NBR_UNUSED = ( (TPTR1$ -> BLK_FTR.NUNUSED) / 2) * 2;
                                        /* GET NUMBER OF AVAILABLE WORDS      */
         /*
         ***   IF ANY UNUSED, COMBINE UNUSED WORDS WITH BLOCK.
         */
      IF NBR_UNUSED > 0
       THEN DO;                         /* SHRINK PREVIOUS BLOCK              */
         SIZE_PREV                 = TPTR1$ -> BLK_FTR.SIZE;
                                        /* GET PREV'S SIZE                    */
         TPTR2$                    = PINCRW( BLK_PTR$, -SIZE_PREV );
                                        /* POINT TO PREVIOUS BLOCK'S HEADER   */
         SIZE_PREV                 = SIZE_PREV - NBR_UNUSED;
                                        /* CALC ITS NEW SIZE                  */
         TPTR2$ -> BLK.SIZE        = SIZE_PREV;
                                        /* SET SIZE IN HEADER                 */
         TPTR1$                    = PINCRW( TPTR2$, SIZE_PREV-2 );
                                        /* POINT TO NEW FOOTER                */
         TPTR1$ -> BLK_FTR.SIZE    = SIZE_PREV;
                                        /* SET FOOTER SIZE                    */
         TPTR1$ -> BLK_FTR.ID      = TPTR2$ -> BLK.ID;
                                        /* SET ID                             */
         TPTR1$ -> BLK_FTR.NUNUSED = 0; /* NO WORDS UNUSED NOW                */
         BLK_IX                    = BLK_IX - NBR_UNUSED;
                                        /* CALC IX OF ENTIRE UNUSED AREA      */
         SIZE                      = SIZE + NBR_UNUSED;
                                        /* CALC UNUSED BLOCK TOTAL SIZE       */
         BLK_PTR$                  = PINCRW( DATA_BASE$, BLK_IX );
                                        /* POINT TO UNUSED BLOCK'S NEW HEADER */
         END;
      END;
    ELSE DO;                            /* PREVIOUS BLOCK UNUSED--COMBINE     */
      SIZE_PREV = TPTR1$ -> BLK_FTR.NUNUSED;
                                        /* GET PREVIOUS UNUSED BLOCK'S SIZE   */
      BLK_IX    = BLK_IX - SIZE_PREV;   /* CALC IX OF ENTIRE BLOCK            */
      BLK_PTR$  = PINCRW( DATA_BASE$, BLK_IX );
                                        /* POINT TO BLOCK                     */
      SIZE      = SIZE + SIZE_PREV;     /* CALC NEW SIZE                      */
      END;
/*
***   TRY TO COMBINE NEXT BLOCK.
*/
   TPTR1$ = PINCRW( BLK_PTR$, SIZE );   /* POINT TO NEXT BLOCK                */
   IF TPTR1$ -> BLK.ID = UNUSED_BUF_ID  /* IF BLOCK ISN'T IN USE              */
    THEN SIZE = SIZE + TPTR1$ -> BLK.SIZE; /* INCLUDE ITS SIZE                */
/********************
***   IF THE DEALLOCATED BLOCK IS THE LAST IN THE BLOCK
***   SPACE, JUST MOVE THE END BLOCK.  OTHERWISE SET UP THE
***   DEALLOCATED BLOCK'S HEADER AND FOOTER.
**/
   IF TPTR1$ -> BLK = END_BLK           /* DOES THE END BLOCK FOLLOW ?        */
    THEN DO;                            /* YES                                */
      BLK_PTR$ -> BLK = END_BLK;        /* MOVE THE END BLOCK                 */
      END_BLK_IX      = BLK_IX;
      END;
    ELSE DO;                       /* NO: WE NEED TO SET UP AN UNUSED BLOCK   */
      BLK_PTR$ -> BLK.ID   = UNUSED_BUF_ID;
                                        /* UNUSED BLOCKS DON'T HAVE ID        */
      BLK_PTR$ -> BLK.SIZE = SIZE;      /* SET SIZE                           */
      TPTR1$               = PINCRW( BLK_PTR$, SIZE-1 );
                                        /* POINT TO UNUSED BLOCK FOOTER       */
      TPTR1$ -> WRD#       = BLK_PTR$ -> WRD#;
                                        /* FTR = HDR FOR UNUSED BLK           */
      END;
/*
***   SAVE IX OF LOWEST BLOCK DEALLOCATED FOR COMPACTION
*/
   IF BLK_IX < LOWEST_DEALLOC_IX THEN LOWEST_DEALLOC_IX = BLK_IX;
 
   RETURN;
 
END AM_DEALLOC_BLK;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/**********************************************************************/
/*
***   UT_DEALLOC_BUF   24 AUG 77   (PRY)  DEALLOCATES BUFFER DESCRIPTOR
***   AND ASSOCIATED BLOCK.
*/
 
UT_DEALLOC_BUF: PROC( BUF$# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   DEALLOCATE A BLOCK   ***/
DCL   AM_DEALLOC_BLK         ENTRY(1);
 
/***************
***   PARAMETERS:
*/
DCL   BUF$#             PTR       ALIGNED;
                                        /* POINTER TO BUFFER DESCRIPTOR       */
 
/***************
***   LOCALS:
*/
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* IX OF ASSOCIATED BLOCK             */
/********************
***   DCB AND MAPPED ALLOC BUFFERS ARE JUST SET UNUSED.
**/
   TPTR1$ = BUF$#;                      /* LOCALIZE POINTER                   */
   TEMP1  = TPTR1$ -> BUF.TYPE;         /* GET BUFFER'S TYPE                  */
   IF TEMP1 = BT_MAPPED OR TEMP1 = BT_DCB /* MAPPED OR DCB?                   */
    THEN DO;                            /* YES                                */
      TPTR1$ -> BUF.TYPE = BT_UNUSED;   /* MAKE IT UNUSED                     */
      TPTR1$ -> BUF.BLK$ = ADDR( NIL ); /* MAKE IT POINT NOWHERE              */
      TPTR1$ -> BUF.IX   = 0;           /* ZERO OUT DCB NUMBER                */
      RETURN;
      END;
 
/***************
***   GET BLOCK IX AND PASS TO BLOCK DEALLOCATOR.
*/
   BLK_IX =  TPTR1$ -> BUF.IX;          /* GET IX OF BLOCK                    */
   CALL AM_DEALLOC_BLK( BLK_IX );
                                   /* DEALLOC BLOCK AND DISASSOCIATE DESC     */
 
   RETURN;
 
END UT_DEALLOC_BUF;
 
/**********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_DECIMAL   24 AUG 77   (PRY)   CONVERTS THE DECIMAL SUBSTRING
***   WHOSE FIRST CHARACTER IS THE CURRENT CHARACTER INTO A 36 BIT VALUE
***   AND CONCATENATES THE VALUE ONTO THE CURRENT VALUE.
*/
 
EV_DECIMAL: PROC;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   ADD BITS TO THE CURRENT VALUE   ***/
DCL   EV_ADD_VAL_BITS        ENTRY(2);
 
/***************
***   LOCALS:
*/
DCL   NEW_VAL           SBIN WORD ALIGNED   AUTO;
                                   /* USED TO ACCUMULATE THE DECIMAL VALUE    */
DCL   SAW_ANY   SBIN WORD ALIGNED AUTO; /* SAW DIGIT FLAG                     */
DCL   SIGNED    SBIN WORD ALIGNED AUTO; /* FLAG SET IF NUMBER IS SIGNED       */
 
/***************
***   CURRENT CHAR MUST BE IN THE STRING.
*/
   IF CHARX > CHARX_MAX
    THEN DO;                            /* NO DECIMAL STRING IS PRESENT       */
      VAL_FAULT = 10; /*E* 10V EV_DECIMAL: DECIMAL STRING MISSING     */
      RETURN;
      END;
/********************
***   PICK UP SIGN (IF ANY).
**/
   IF C = CT_MINUS                      /* NEGATIVE?                          */
    THEN DO;                            /* YES                                */
      CALL UT_INC_CHARX;                /* SKIP OVER SIGN                     */
      SIGNED = 1;                       /* SET SIGN FLAG                      */
      END;
    ELSE DO;
      SIGNED = 0;                       /* POSITIVE                           */
      IF C = CT_PLUS                    /* PLUS SIGN?                         */
       THEN CALL UT_INC_CHARX;          /* YES: SKIP OVER IT                  */
      END;
/*
***   INITIALIZE ACCUMULATOR AND CONVERT THE STRING.
*/
   NEW_VAL = 0;
   SAW_ANY = 0;                         /* HAVEN'T SEEN ANY DIGITS YET        */
   DO WHILE (C >= CT_0 AND C <= CT_9 AND CHARX <= CHARX_MAX );
      IF NEW_VAL > MASKR(35) / 10
                         /* IMPENDING LOSS OF SIGNIFICANCE? > (2**35-1)/10?   */
       THEN DO;                         /* YES                                */
         VAL_FAULT = 9;
                    /*E* 9V EV_DECIMAL: IMPENDING LOSS OF SIGNIFICANCE        */
         RETURN;
         END;
      NEW_VAL   = NEW_VAL * 10  +  C - CT_0;
                                        /* ACCUMULATE NEXT DECIMAL DIGIT      */
      SAW_ANY   = 1;                    /* FOUND AT LEAST ONE GOOD CHAR       */
      CALL UT_INC_CHARX;                /* GET NEXT CHAR                      */
      END;
/*
***   IF WE DIDN'T GET ANY GOOD CHARS, JUST RETURN WITH VAL_FAULT SET.
*/
   IF SAW_ANY = 1                       /* SEE ANY GOOD CHARS?                */
    THEN DO;                            /* YES                                */
      VAL_FAULT = 0;                    /* NORMAL END OF DECIMAL              */
      IF SIGNED = 1 THEN NEW_VAL = - NEW_VAL; /* INVERT IF SIGNED             */
      CALL EV_ADD_VAL_BITS( NEW_VAL, 36 );
                                        /* ADD ALL 36 BITS                    */
      END;
    ELSE VAL_FAULT = 10;
 
   RETURN;
 
END EV_DECIMAL;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_DISPLAY   14 SEP 77   (PRY)   DISPLAY BITS POINTED TO
***   BY THE ARGUMENT BIT POINTER IN THE FORMAT SPECIFIED.
**/
 
UT_DISPLAY: PROC( PTR$#, NBR_BITS#, FMT# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
 
/***   OUTPUT A STRING OF CHARACTERS   ***/
DCL   UT_OUTPUT_CHARS        ENTRY(2);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
 
/***   PRINT A SIZE SPECIFICATION   ***/
DCL   UT_PRINT_SIZE               ENTRY(1);
 
/********************
***   PARAMETERS:
**/
DCL   PTR$#             PTR    ALIGNED; /* POINTER TO BIT STRING              */
DCL   NBR_BITS#         SBIN WORD ALIGNED;
                                        /* THE NUMBER OF BITS TO DISPLAY      */
DCL   FMT#           SBIN WORD ALIGNED; /* SPECIFIED FORMAT                   */
 
/********************
***   LOCALS:
**/
DCL   PTR$            PTR ALIGNED AUTO; /* LOCALIZES PTR$#                    */
DCL   NBR_BITS  SBIN WORD ALIGNED AUTO; /* LOCALIZES NBR_BITS#                */
DCL   FMT       SBIN WORD ALIGNED AUTO; /* LOCALIZES FMT#                     */
DCL   NBR_CHARS         SBIN WORD ALIGNED   AUTO;
                                        /* NUMBER OF CHARS IN BIT STRING      */
DCL   OUT_CHAR  SBIN WORD ALIGNED AUTO; /* NEXT CHAR TO OUTPUT                */
DCL   COUNT             SBIN WORD ALIGNED   AUTO;
                                        /* USED TO COUNT OUTPUT CHARS/BITS    */
DCL   VAL$            PTR ALIGNED AUTO; /* USED AS TEMP PTR                   */
DCL   VALUE     SBIN WORD ALIGNED AUTO; /* USED AS TEMP VALUE                 */
DCL   END_PTR$          PTR       ALIGNED   AUTO;
                                   /* POINTER TO LAST BIT OF FIELD TO DISPLAY */
DCL   OUT_PTR$          PTR       ALIGNED   AUTO;
                                        /* POINTER TO NEXT BIT TO SET         */
DCL   BIT_COUNT SBIN WORD ALIGNED AUTO; /* COUNT OF DISPLAYED BITS            */
DCL   SEP_CHAR  SBIN WORD ALIGNED AUTO; /* WORD SEPARATOR CHAR                */
DCL FOUR_WORDS CHAR(16) BASED UNAL;
 
DCL 1 PRINTABLE_XLATE_TBL CONSTANT ALIGNED,
      2 XTBL(0:511) BIT(9) UNAL INIT(
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '040'O,'041'O,'042'O,'043'O,'044'O,'045'O,'046'O,'047'O,
        '050'O,'051'O,'052'O,'053'O,'054'O,'055'O,'056'O,'057'O,
        '060'O,'061'O,'062'O,'063'O,'064'O,'065'O,'066'O,'067'O,
        '070'O,'071'O,'072'O,'073'O,'074'O,'075'O,'076'O,'077'O,
        '100'O,'101'O,'102'O,'103'O,'104'O,'105'O,'106'O,'107'O,
        '110'O,'111'O,'112'O,'113'O,'114'O,'115'O,'116'O,'117'O,
        '120'O,'121'O,'122'O,'123'O,'124'O,'125'O,'126'O,'127'O,
        '130'O,'131'O,'132'O,'133'O,'134'O,'135'O,'136'O,'137'O,
        '140'O,'141'O,'142'O,'143'O,'144'O,'145'O,'146'O,'147'O,
        '150'O,'151'O,'152'O,'153'O,'154'O,'155'O,'156'O,'157'O,
        '160'O,'161'O,'162'O,'163'O,'164'O,'165'O,'166'O,'167'O,
        '170'O,'171'O,'172'O,'173'O,'174'O,'175'O,'176'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O);
/********************
***   LOCALIZE ARGUMENTS; CALC NUMBER OF CHARS IN BIT STRING.
**/
   IF BRK_FLAG ~= 0 THEN RETURN;        /* STOP OUTPUT IF BREAK PENDING       */
   PTR$      = PTR$#;
   NBR_BITS  = NBR_BITS#;
   FMT       = FMT#;
   NBR_CHARS = NBR_BITS / 9 - 1;        /* CALC IX OF LAST CHAR IN BIT STRING */
 
/********************
***   IF FORMAT IS TEXT, JUST MOVE CHARS TO OUTPUT BUFFER.
**/
   IF FMT = DT_TEXT OR FMT = DT_NTEXT OR FMT = -DT_NTEXT /* TEXT?             */
    THEN DO;                            /* YES                                */
      IF FMT = DT_TEXT THEN CALL UT_OUTPUT_CHAR( CT_SQUOTE ); /* OUTPUT OPENING SQUOTE */
         DO COUNT=0 TO NBR_CHARS;       /* MOVE CHARS TO BUFFER               */
            OUT_CHAR = PTR$ -> UBIN9#(COUNT);
                                        /* GET NEXT CHAR                      */
            IF FMT = -DT_NTEXT THEN OUT_CHAR = BITBIN(PRINTABLE_XLATE_TBL.XTBL(OUT_CHAR));
            CALL UT_OUTPUT_CHAR( OUT_CHAR );
                                        /* PRINT IT                           */
            IF BRK_FLAG ~= 0 THEN RETURN; /* STOP OUTPUT IF BREAK PENDING     */
            IF OUT_CHAR = CT_SQUOTE
                                        /* IF IT'S A SQUOTE, DOUBLE IT        */
             THEN IF FMT = DT_TEXT THEN CALL UT_OUTPUT_CHAR( CT_SQUOTE );
            END;
      IF FMT = DT_TEXT THEN CALL UT_OUTPUT_CHAR( CT_SQUOTE ); /* OUTPUT CLOSING SQUOTE */
      CALL UT_CHK_LEFTOVER( 9 );
      RETURN;
      END;
 
/********************
***   IF FORMAT IS TEXTC, OUTPUT THE NUMBER OF BYTES SPECIFIED BY
***   THE COUNT BYTE BUT NO MORE THAN THE WIDTH OF THE FIELD.
**/
   IF FMT = DT_TEXTC                    /* TEXTC?                             */
    THEN DO;                            /* YES                                */
      IF NBR_CHARS >= 0                 /* GET COUNT BYTE IF IT EXISTS        */
       THEN TEMP1 = PTR$ -> UBN9#;
       ELSE TEMP1 = 0;
      IF TEMP1 < NBR_CHARS
                              /* DON'T OUTPUT MORE THAN COUNT BYTE SPECIFIES  */
       THEN NBR_CHARS = TEMP1;
       ELSE IF TEMP1 > NBR_CHARS
                                   /* DON'T OUTPUT MORE THAN SPECIFIED FIELD  */
          THEN FMT = -1;                /* FLAG ATTEMPT                       */
      CALL UT_OUTPUT_CHAR( CT_DQUOTE ); /* OUTPUT OPENING DQUOTE              */
      DO COUNT=1 TO NBR_CHARS;
         OUT_CHAR = PTR$ -> UBIN9#(COUNT);
                                        /* GET NEXT CHAR                      */
         CALL UT_OUTPUT_CHAR( OUT_CHAR );
                                        /* PRINT IT                           */
         IF BRK_FLAG ~= 0 THEN RETURN;  /* STOP OUTPUT IF BREAK PENDING       */
         IF OUT_CHAR = CT_DQUOTE        /* DOUBLE DQUOTES                     */
          THEN CALL UT_OUTPUT_CHAR( CT_DQUOTE );
         END;
      IF FMT = -1                  /* IF ATTEMPT TO PRINT MORE THAN FIELD     */
       THEN DO COUNT=1 TO 3;            /* INDICATE WITH ELLIPSES             */
         CALL UT_OUTPUT_CHAR( CT_PERIOD );
         END;
      CALL UT_OUTPUT_CHAR( CT_DQUOTE ); /* OUTPUT CLOSING DQUOTE              */
      CALL UT_CHK_LEFTOVER( 9 );        /* DISPLAY ANY LEFTOVER               */
      RETURN;
      END;
 
/********************
***   IF FORMAT IS COMMAND, WE NEED TO PRINT LINE NUMBERS.
**/
   IF FMT = DT_COMMAND                  /* COMMAND?                           */
    THEN DO;                            /* YES                                */
      VALUE = 1;                        /* INITIALIZE LINE NUMBER             */
      VAL$  = ADDR( VALUE );            /* GET ADDR FOR DISPLAY               */
      FMT   = 1;                   /* USE FMT AS LINE NUMBER DISPLAYED FLAG   */
      DO COUNT=0 TO NBR_CHARS;          /* DISPLAY ALL CHARS                  */
         IF FMT = 1                     /* DISPLAY LINE NUMBER?               */
          THEN DO;                      /* YES                                */
            CALL UT_FLUSH_BUF;          /* FLUSH PREVIOUS CONTENTS            */
            CALL UT_OUTPUT_CHAR( CT_LBRACKET ); /* [                          */
            CALL UT_DISPLAY( VAL$, 36, -DT_DECIMAL );
            IF BRK_FLAG ~= 0 THEN RETURN; /* STOP OUTPUT IF BREAK PENDING     */
            CALL UT_OUTPUT_CHAR( CT_RBRACKET ); /* ]                          */
            BIT_COUNT = 8 - OUT_CHARX;  /* CALC NUMBER OF SPACES NEEDED       */
            CALL UT_OUTPUT_CHARS( '        ', BIT_COUNT );
            VALUE = VALUE + 1;          /* COUNT LINE PRINTED                 */
            FMT   = 0;                  /* RESET FLAG                         */
            END;
         OUT_CHAR = PTR$ -> UBIN9#(COUNT); /* GET NEXT CHAR TO LIST           */
         IF OUT_CHAR = CT_CR            /* RETURN?                            */
          THEN FMT = 1;                 /* YES: DISPLAY NEXT LINE NUMBER      */
          ELSE CALL UT_OUTPUT_CHAR( OUT_CHAR );
                                        /* NOT CR: JUST DISPLAY CHAR          */
         IF BRK_FLAG ~= 0 THEN RETURN;  /* STOP OUTPUT IF BREAK PENDING       */
         END;
      CALL UT_FLUSH_BUF;                /* FLUSH ANY REMAINDER                */
      RETURN;
      END;
 
/********************
***   DO NOTHING FOR NOTHING OUTPUT TYPE.
**/
   IF FMT = DT_NOTHING THEN RETURN;
 
 /**********
  *** Dump format.
  **/
 
   IF FMT = DT_DUMP
    THEN DO;
      CALL UT_FLUSH_BUF;                /* Ready new line                     */
      COUNT = 0;
      SEP_CHAR = 0;                     /* No duplicate yet                   */
      DO WHILE( NBR_BITS > 0 );
         IF NBR_BITS > 4*36
          THEN BIT_COUNT = 4*36;        /* Full four words                    */
          ELSE BIT_COUNT = NBR_BITS;
         IF NBR_BITS > BIT_COUNT AND BIT_COUNT >= 4*36 AND COUNT > 0
          THEN DO;                      /* Check if duplicate                 */
            IF PTR$->FOUR_WORDS = PINCRW( PTR$, -4 )->FOUR_WORDS
             THEN SEP_CHAR = 2;    /* Indicate duplicate line not printed     */
             ELSE IF SEP_CHAR = 2
                THEN SEP_CHAR = 1;
                ELSE SEP_CHAR = 0;
            END;
          ELSE IF SEP_CHAR = 2
             THEN SEP_CHAR = 1;
             ELSE SEP_CHAR = 0;
         IF SEP_CHAR < 2
          THEN DO;                      /* Line must be printed               */
            CALL UT_DISPLAY( PINCRB(ADDR(COUNT),24), 12, -DT_MACHINE ); /* Word count */
            IF SEP_CHAR = 0
             THEN CALL UT_OUTPUT_CHAR( CT_SPACE );
             ELSE CALL UT_OUTPUT_CHAR( CT_ASTERISK );
            CALL UT_DISPLAY( PTR$, BIT_COUNT, -DT_MACHINE );
            CALL UT_OUTPUT_CHARS( ' *', 2 );
            CALL UT_DISPLAY( PTR$, BIT_COUNT, -DT_NTEXT );
            CALL UT_OUTPUT_CHAR( CT_ASTERISK );
            CALL UT_FLUSH_BUF;
            END;
         IF BRK_FLAG > 0 THEN RETURN;
         PTR$ = PINCRB( PTR$, BIT_COUNT ); /* To next group                   */
         NBR_BITS = NBR_BITS - BIT_COUNT;
         COUNT = COUNT + BIT_COUNT / 36;
         END;
      RETURN;
      END;
/********************
***   CONVERT BIT GROUPS TO OUTPUT CHARS IF MACHINE OR BASED FORMAT.
**/
   IF FMT = -DT_MACHINE OR FMT = DT_MACHINE OR FMT = DT_BASED /* MACHINE OR BASED */
    THEN DO;                            /* YES                                */
      IF FMT = DT_MACHINE
       THEN DO;
         SEP_CHAR = CT_PERIOD;
                                        /* MACHINE .                          */
         FMT = 3;                       /* USE FORMAT AS BASE WIDTH           */
         END;
       ELSE DO;
         IF FMT = -DT_MACHINE
          THEN DO;
            SEP_CHAR = CT_SPACE;
            FMT = 3;
            END;
          ELSE DO;
            SEP_CHAR = CT_POUND;
                                        /* BASED #                            */
            FMT = DFLT_BASE_WIDTH;
            END;
         END;
      END_PTR$ = PINCRB( PTR$, NBR_BITS );
                                        /* CALC END OF DISPLAY POINTER        */
      OUT_PTR$ = PINCRB( ADDR(OUT_CHAR), 36-FMT );
                              /* POINT TO LEADING BIT OF OUTPUT FIELD - 1     */
      NBR_CHARS = NBR_BITS / FMT;
                                        /* CALC NUMBER OF CHARS TO OUTPUT     */
      DO COUNT=1 TO NBR_CHARS;
         OUT_CHAR = 0;                  /* CLEAR FIELD                        */
         TEMP1 = FMT;
         OUT_PTR$->BITS = PTR$->BITS;   /* MOVE BITS TO OUTPUT FIELD          */
         PTR$ = PINCRB( PTR$, FMT );
                                        /* POINT TO NEXT BIT GROUP            */
         IF OUT_CHAR >= 10              /* CONVERT TO BASED DIGIT             */
          THEN OUT_CHAR = OUT_CHAR + CT_A - 10;
          ELSE OUT_CHAR = OUT_CHAR + CT_0;
         TEMP1 = (COUNT - 1) * FMT; /* CALC NUMBER OF BITS  ALREADY DISPLAYED */
         IF TEMP1 = (TEMP1/36)*36       /* MARK WORD ENDS                     */
          THEN CALL UT_OUTPUT_CHAR( SEP_CHAR );
         CALL UT_OUTPUT_CHAR( OUT_CHAR );
                                        /* PRINT THE NEXT CHAR                */
         IF BRK_FLAG ~= 0 THEN RETURN;  /* STOP OUTPUT IF BREAK PENDING       */
         END;
      CALL UT_CHK_LEFTOVER( FMT );
      RETURN;
      END;
 
/********************
***   MIXED MACHINE, TEXT NOT IMPLEMENTED YET.
**/
   IF FMT = DT_MIXED
    THEN DO;
      VAL_FAULT = 21;
                    /*E* 21V UT_DISPLAY: MIXED FORMAT OUTPUT NOT IMPLEMENTED  */
      RETURN;
      END;
 
/********************
***   REMAINING FORMATS ARE DECIMAL, DECIMAL WITH NO $ AND WIDTH.
**/
   IF FMT = DT_WIDTH  OR  FMT = DT_DECIMAL OR FMT = - DT_DECIMAL
                                        /* DECIMAL OR WIDTH?                  */
    THEN DO;                            /* YES                                */
      IF NBR_BITS < 1  OR NBR_BITS > 36 /* LEGAL DECIMAL VALUE?               */
       THEN DO;                         /* NO                                 */
         VAL_FAULT = 8;
          /*E* 8V UT_DISPLAY: DECIMAL VALUES ARE >0 AND <37 BITS LONG         */
         RETURN;
         END;
      VALUE = 0;                   /* INITIALIZE WORD FOR RECEPTION OF BITS   */
      VAL$  = PINCRB( ADDR(VALUE), 36-NBR_BITS );
                                        /* POINT TO TARGET BITS               */
      TEMP1 = NBR_BITS;                 /* SET LENGTH OF BIT STRING TO MOVE   */
      VAL$ -> BITS = PTR$ -> BITS;
      IF FMT = DT_DECIMAL THEN CALL UT_OUTPUT_CHAR( CT_DOLLAR ); /* PRINT DECIMAL $ */
      IF VALUE < 0                      /* NEGATIVE?                          */
       THEN DO;
         VALUE = - VALUE;               /* INVERT VALUE                       */
         IF VALUE < 0 THEN VALUE = 0;   /* HANDLE .4000000000000              */
         CALL UT_OUTPUT_CHAR( CT_MINUS );
                                        /* PRINT MINUS SIGN                   */
         END;
      IF FMT = DT_WIDTH                 /* JUST PRINT SIZE IF WIDTH           */
       THEN DO;
         CALL UT_PRINT_SIZE( VALUE );
         RETURN;
         END;
      COUNT = 0;                        /* INITIALIZE CHARACTER COUNT         */
      DO WHILE (COUNT < 1  OR  VALUE > 0);
               /* CONVERT TO DECIMAL (MAKE SURE WE GET AT LEAST ONE ZERO)     */
         TEMP1      = VALUE / 10;       /* CALC NUMBER OF TENS                */
         OUT_CHAR   = VALUE - TEMP1 * 10 + CT_0;
                                        /* CONVERT ONES TO CHARACTER          */
         VALUE      = TEMP1;
         CRNT_NAME$ -> UBIN9#(COUNT) = OUT_CHAR;
                                        /* MOVE TO TEMP BUFFER                */
         COUNT      = COUNT + 1;        /* READY FOR NEXT CHAR                */
         END;
      DO WHILE (COUNT > 0);             /* PRINT CHARS                        */
         COUNT    = COUNT - 1;          /* GET NEXT OUTPUT CHAR               */
         OUT_CHAR = CRNT_NAME$ -> UBIN9#(COUNT);
         CALL UT_OUTPUT_CHAR( OUT_CHAR );
                                        /* PRINT IT                           */
         END;
         /**
         ***   IF THE WIDTH IS NOT EXACTLY 36, DISPLAY ITS WIDTH.
         **/
      IF NBR_BITS ~= 36                 /* 36 BITS?                           */
       THEN DO;                         /* NO                                 */
         CALL UT_OUTPUT_CHAR( CT_LPAREN ); /* DISPLAY (                       */
         CALL UT_PRINT_SIZE( NBR_BITS );
         CALL UT_OUTPUT_CHAR( CT_RPAREN );
         END;
      RETURN;
      END;
/********************
***   WE SHOULD NEVER GET HERE BUT IF WE DO...
**/
   RETURN;
 
/********************************************************************/
/**
***   UT_CHK_LEFTOVER   8 OCT 77   (PRY) DISPLAY LEFTOVER.
**/
 
UT_CHK_LEFTOVER: PROC( BITS_AT_A_TIME# );
 
/********************
***   PARAMETERS:
**/
DCL   BITS_AT_A_TIME#        SBIN WORD ALIGNED;
                                        /* NUMBER OF BITS DISPLAY AS A UNIT   */
 
/********************
***   CALC LEFT OVER;  IF ANY, DISPLAY IT WITH A WIDTH.
**/
   TEMP1 = BITS_AT_A_TIME#;             /* LOCALIZE ARGUMENT                  */
   TEMP2 = NBR_BITS - (NBR_BITS / TEMP1) * TEMP1; /* CALC LEFTOVER            */
   IF TEMP2 > 0                         /* ANY?                               */
    THEN DO;                            /* YES: DISPLAY IT                    */
      PTR$ = PINCRB( PTR$#, NBR_BITS-TEMP2 ); /* POINT TO LEFTOVER            */
      NBR_BITS = TEMP2;                 /* DISPLAY IT                         */
      CALL UT_DISPLAY( PTR$, NBR_BITS, DT_DECIMAL );
      END;
 
   RETURN;
 
END UT_CHK_LEFTOVER;
UT_OUTPUT_CHAR: PROC( OUT_CHAR# );
 
/********************
***   PARAMETERS:
**/
DCL   OUT_CHAR#      SBIN WORD ALIGNED; /* CHARACTER TO OUTPUT                */
 
 
/********************
***   IF OUTPUT BUFFER IS FULL, FLUSH IT.
**/
   IF OUT_CHARX >= LINE_WID-2           /* FULL?                              */
    THEN DO;                  /* YES: INDICATE CONTINUATION AND FLUSH BUFFER  */
      OUT_BUF$ -> UBIN9#(OUT_CHARX) = CT_AMPERSAND;
      OUT_CHARX                     = OUT_CHARX + 1;
                                   /* INDICATE CONTINUATION WITH AMPERSAND    */
      CALL UT_FLUSH_BUF;                /* FLUSH THE OUTPUT BUFFER            */
      END;
 
   OUT_BUF$ -> UBIN9#(OUT_CHARX) = OUT_CHAR#; /* PUT CHAR IN BUFFER           */
   OUT_CHARX           = OUT_CHARX + 1; /* INC CHAR INDEX                     */
 
   RETURN;
 
END UT_OUTPUT_CHAR;
 
END UT_DISPLAY;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***   XQC_EDIT   18 NOV 77   (PRY)   SUPPLIES EDIT FUNCTION TO FILER
***   PROGRAM.   EDIT COMMAND FORMAT IS:
***           E B [OCCUR] [:LINE] / VALUE1 / VALUE2 / [SIZE]
***   'E' - EDIT, B = BUFFER ID SPECIFICATION, OCCUR = OCCURANCE
***   NUMBER TO SUBSTITUTE--'ALL' IF UNSPECIFIED, LINE = LINE
***   NUMBER TO START SEARCH ON--FIRST (1) IF UNSPECIFIED, VALUE1 =
***   BIT PATTERN TO SEARCH FOR, VALUE2 = BIT PATTERN TO SUBSTITUTE
***   FOR VALUE1 IF VALUE1 IS FOUND, SIZE = BIT GROUPINGS
**/
 
XQC_EDIT: PROC;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IDENTIFY BUFFER BY BUFFER SPECIFICATION   ***/
DCL   UT_IDENTIFY_BUFFER     ENTRY(2);
 
/***   IGNORE BLANKS   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
/***   CONVERT VALUE SPECIFICATION TO SBIN WORD   ***/
DCL   UT_SBIN_VALUE          ENTRY(1);
 
/***   CONVERT VALUE SPECIFICATION TO VALUE   ***/
DCL   EV_GET_VALUE           ENTRY(2);
 
/***   DEALLOCATE A BUFFER AND ITS ASSOCIATED BLOCK   ***/
DCL   UT_DEALLOC_BUF         ENTRY(1);
 
/***   ADJUST SIZE OF BUFFER AND ASSOCIATED BLOCK   ***/
DCL   UT_NEW_SIZE            ENTRY(2);
 
/***   DISPLAY A VALUE IN SPECIFIED FORMAT   ***/
DCL   UT_DISPLAY             ENTRY(3);
 
/***   OUTPUT A STRING OF CHARACTERS   ***/
DCL   UT_OUTPUT_CHARS        ENTRY(2);
 
/***   MOVE A BIT STRING REARWARD   ***/
DCL   UT_MOVE_BITS_RWD       ENTRY(3);
 
/***   MOVE A BIT STRING FORWARD   ***/
DCL   UT_MOVE_BITS_FWD       ENTRY(3);
 
/***   CHECK FOR ILLEGAL JUNK AFTER LEGAL COMMAND   ***/
DCL   UT_JUNK_CHK            ENTRY;
 
/***   EVALUATE A SIZE SPECIFICATION   ***/
DCL   EV_EVAL_SIZE           ENTRY(2);
 
/********************
***  LOCALS:
**/
DCL   OCCURANCE SBIN WORD ALIGNED AUTO; /* OCCURANCE TO CHANGE                */
DCL   LINE_NBR  SBIN WORD ALIGNED AUTO; /* LINE NUMBER TO SELECT              */
DCL   BUF$            PTR ALIGNED AUTO; /* BUFFER TO EDIT                     */
DCL   FIND_VAL$       PTR ALIGNED AUTO; /* VALUE TO FIND                      */
DCL   FV_BLK_IX SBIN WORD ALIGNED AUTO; /* FIND VAL BLOCK INDEX               */
DCL   FV_BLK$           PTR       ALIGNED   AUTO;
                                        /* POINTER TO SEARCHED FOR VALUE DATA */
DCL   FV_WIDTH          SBIN WORD ALIGNED   AUTO;
                                   /* NUMBER OF BITS IN SEARCHED FOR VALUE    */
DCL   SUBS_VAL$       PTR ALIGNED AUTO; /* VALUE TO SUBSTITUTE                */
DCL   SV_BLK_IX         SBIN WORD ALIGNED   AUTO;
                                        /* SUBSTITUTE VAL BLOCK INDEX         */
DCL   SV_BLK$           PTR       ALIGNED   AUTO;
                                        /* POINTER TO SUBSTITUTION VALUE DATA */
DCL   SV_WIDTH          SBIN WORD ALIGNED   AUTO;
                                   /* NUMBER OF BITS IN SUBSTITUTION VALUE    */
DCL GROUP_WIDTH SBIN WORD ALIGNED AUTO; /* COMPARISON GROUP SIZE              */
DCL   GOT_SIZE          SBIN WORD ALIGNED   AUTO;
                                   /* FLAG INDICATING IF SIZE WAS ENCOUNTERED */
DCL   BWIDTH            SBIN WORD ALIGNED   AUTO;
                                        /* CURRENT WIDTH OF THE BUFFER        */
DCL   NBR_CHARS         SBIN WORD ALIGNED   AUTO;
                                   /* NUMBER OF CHARS THAT BUFFER CONTAINS    */
DCL   BBLK$             PTR       ALIGNED   STATIC;
                                   /* POINTER TO CURRENT BUFFER DATA FIELD    */
DCL   SIZE_DIF          SBIN WORD ALIGNED   AUTO;
                         /* DIFFERENCE BETWEEN SIZE OF SEARCHED FOR VALUE     */
                                   /* AND SIZE OF VALUE TO BE SUBSTITUTED     */
DCL   NOT_FOUND         SBIN WORD ALIGNED   AUTO;
                                        /* FLAG INDICATING IF VALUE WAS FOUND */
DCL   FROM$           PTR ALIGNED AUTO; /* SOURCE BITS POINTER                */
DCL   TO$             PTR ALIGNED AUTO; /* DESTINATION BITS POINTER           */
DCL   SWIDTH            SBIN WORD ALIGNED   AUTO;
                              /* NUMBER OF BITS OF BUFFER ALREADY SEARCHED    */
DCL   TO_MOVE   SBIN WORD ALIGNED AUTO; /* NUMBER OF BITS TO MOVE             */
DCL FOUND_COUNT SBIN WORD ALIGNED AUTO; /* NUMBER OF SUBS MADE                */
 
/********************
***   SKIP OVER 'E' AND GET THE BUFFER ID.  THE BUFFER MUST BE
***   USED AND NOT LOCKED.
**/
   CALL UT_INC_CHARX;                   /* SKIP OVER THE 'E'                  */
   CALL UT_IDENTIFY_BUFFER( BUF$, OCCURANCE );
                                        /* IDENTIFY THE BUFFER                */
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF ERRORS                   */
   IF BUF$ -> BUF.TYPE = BT_UNUSED
                                        /* BUFFER MUST BE USED TO EDIT        */
    THEN DO;
      VAL_FAULT = 27;           /*E* 27V XQC_EDIT: BUFFER IS UNUSED   */
      RETURN;
      END;
 
   IF BUF$ -> BUF.LOCK > 0              /* BUFFER CAN'T BE LOCKED             */
    THEN DO;
      VAL_FAULT = 70;           /*E* 70V XQC_EDIT: BUFFER LOCKED      */
      RETURN;
      END;
 
/********************
***   LOOK AT THE NEXT CHAR.
***   IF :, DEFAULT OCCURANCE AND LINE NUMBER FOLLOWS.
***   IF /, DEFAULT OCCURANCE AND DEFAULT LINE NUMBER.
***   IF OTHERWISE, THE OCCURANCE NUMBER MUST FOLLOW.
**/
   CALL UT_IGNORE_BLANKS;               /* SKIP BLANKS                        */
   IF CHARX <= CHARX_MAX  AND  (C ~= CT_COLON
     AND  C ~= CT_SLASH)                /* DETERMINE IF OCCURANCE FOLLOWS     */
    THEN DO;                            /* IT MUST                            */
      CALL UT_SBIN_VALUE( OCCURANCE );  /* CET OCCURANCE NUMBER               */
      IF VAL_FAULT ~= 0 THEN RETURN;    /* RETURN IF ERROR                    */
      CALL UT_IGNORE_BLANKS;            /* SKIP BLANKS                        */
      IF OCCURANCE < 0 THEN OCCURANCE = 0;
                                        /* MIN OCCURANCE IS ZERO              */
      END;
    ELSE OCCURANCE = 1;                 /* USE DEFAULT OCCURANCE              */
 
   IF CHARX <= CHARX_MAX AND C = CT_COLON
                                        /* GET LINE NUMBER (IF IT FOLLOWS)    */
    THEN DO;                            /* IT SHOULD                          */
      CALL UT_INC_CHARX;                /* SKIP OVER :                        */
      CALL UT_SBIN_VALUE( LINE_NBR );   /* GET THE LINE NUMBER                */
      IF VAL_FAULT ~= 0 THEN RETURN;    /* RETURN IF ERRORS                   */
      CALL UT_IGNORE_BLANKS;            /* SKIP BLANKS                        */
      IF LINE_NBR < 0 THEN LINE_NBR = 0; /* MIN LINE_NBR IS ZERO              */
      END;
    ELSE LINE_NBR = 0;                  /* SET DEFAULT LINE NUMBER            */
 
/********************
***   NOW WE MUST GET THE STRINGS.
**/
   IF CHARX > CHARX_MAX OR C ~= CT_SLASH /* SLASH MUST FOLLOW                 */
    THEN DO;
      VAL_FAULT = 74;           /*E* 74V XQC_EDIT: EXPECTED / MISSING */
      RETURN;
      END;
/**
***   FOUND THE /. SKIP OVER IT AND GET THE VALUE.
**/
   CALL UT_INC_CHARX;
   CALL EV_GET_VALUE( FIND_VAL$, FV_BLK_IX );
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF ERRORS                   */
   IF FIND_VAL$ -> BUF.WIDTH <= 0       /* MUST HAVE SOME WIDTH               */
    THEN DO;                            /* DOESN'T                            */
      CALL UT_DEALLOC_BUF( FIND_VAL$ );
      VAL_FAULT = 40;
 /*E* 40V XQC_EDIT: A VALUE OF MORE THAN 0 BIT WIDTH MUST BE SPECIFIED        */
      RETURN;
      END;
   CALL UT_IGNORE_BLANKS;               /* SKIP BLANKS                        */
/**
***   THE TERMINATING / SHOULD FOLLOW.
**/
   IF CHARX > CHARX_MAX OR C ~= CT_SLASH /* DOES SLASH FOLLOW?                */
    THEN DO;                            /* NO                                 */
      CALL UT_DEALLOC_BUF( FIND_VAL$ ); /* GET RID OF THE VALUE               */
      VAL_FAULT = 74;
      RETURN;
      END;
/**
***   / FOLLOWED...SKIP IT AND GET THE NEXT VALUE.
**/
   CALL UT_INC_CHARX;                   /* SKIP OVER SLASH                    */
   CALL EV_GET_VALUE( SUBS_VAL$, SV_BLK_IX );
   IF VAL_FAULT ~= 0                    /* RETURN IF ERRORS                   */
    THEN DO;
      CALL UT_DEALLOC_BUF( FIND_VAL$ ); /* GET RID OF FIRST VALUE             */
      RETURN;
      END;
/**
***   CLOSING SLASH SHOULD FOLLOW.
**/
   CALL UT_IGNORE_BLANKS;               /* SKIP TO / (IF THERE)               */
   IF CHARX > CHARX_MAX OR C ~= CT_SLASH /* DOES SLASH FOLLOW?                */
    THEN DO;                            /* NOPE                               */
      CALL UT_DEALLOC_BUF( FIND_VAL$ );
      CALL UT_DEALLOC_BUF( SUBS_VAL$ );
      VAL_FAULT = 74;
      RETURN;
      END;
 
/**
***   FOR FIXED TYPE BUFFERS BOTH VALUES MUST BE OF
***   EQUAL SIZE.
**/
   TEMP1 = BUF$ -> BUF.TYPE;            /* GET TYPE OF BUFFER                 */
   FV_WIDTH = FIND_VAL$ -> BUF.WIDTH;
   SV_WIDTH = SUBS_VAL$ -> BUF.WIDTH;   /* GET WIDTHS                         */
   IF TEMP1 ~= BT_VAR_BUF  AND  TEMP1 ~= BT_CMND_BUF
                                        /* IS BUFFER OF FIXED TYPE?           */
     AND FV_WIDTH ~= SV_WIDTH           /* AND VALUES AREN'T OF EQUAL WIDTH?  */
    THEN DO;                            /* ERROR                              */
      CALL UT_DEALLOC_BUF( FIND_VAL$ );
      CALL UT_DEALLOC_BUF( SUBS_VAL$ );
      VAL_FAULT = 76; /*E* 76V XQC_EDIT: FOR THIS TYPE OF BUFFER BOTH */
                                        /* VALUES MUST BE OF EQUAL WIDTH      */
      RETURN;
      END;
 
/**
***   SKIP OVER / AND SEE IF ANY SIZE IS SPECIFIED.
**/
   CALL UT_INC_CHARX;                   /* SKIP /                             */
   CALL EV_EVAL_SIZE( GROUP_WIDTH, GOT_SIZE );
                                        /* GET COMPARE GROUP SIZE             */
   IF VAL_FAULT = 0 THEN CALL UT_JUNK_CHK;
                                        /* CHECK FOR JUNK IF NO ERRORS        */
   IF VAL_FAULT ~= 0                    /* RETURN IF ERRORS                   */
    THEN DO;
      CALL UT_DEALLOC_BUF( FIND_VAL$ );
      CALL UT_DEALLOC_BUF( SUBS_VAL$ );
      RETURN;
      END;
 
   IF GOT_SIZE = 0 THEN GROUP_WIDTH = 9;
                                        /* DEFAULT GROUP SIZE IS 9 (CHAR)     */
/********************
***   HAVE ALL NECESSARY INFORMATION.   THE VALUE TO BE FOUND MUST
***   HAVE A WIDTH WHICH CAN BE EVENLY DIVIDED BY THE GROUP WIDTH.
**/
/**IF GROUP_WIDTH > 0                   /* CHECK GROUP WIDTH                  */
/** THEN DO;
/**   TEMP1 = FIND_VAL$ -> BUF.WIDTH;
/**                                     /* GET THE WIDTH OF THE FIRST VALUE   */
/**   IF TEMP1 ~= (TEMP1/GROUP_WIDTH)*GROUP_WIDTH
/**    THEN GROUP_WIDTH = 0;            /* FLAG BAD GROUP WIDTH               */
/**   END;
/**/
 
   IF GROUP_WIDTH <= 0                  /* CHECK IF ILLEGAL WIDTH             */
    THEN DO;
      CALL UT_DEALLOC_BUF( FIND_VAL$ );
      CALL UT_DEALLOC_BUF( SUBS_VAL$ );
      VAL_FAULT = 75;           /*E* 75V XQC_EDIT: ILLEGAL GROUP SIZE */
      RETURN;
      END;
 
/********************
***   FIND THE BEGINNING OF THE SPECIFIED LINE.
**/
   BWIDTH    = BUF$ -> BUF.WIDTH;       /* GET THE BUFFER WIDTH               */
   NBR_CHARS = BWIDTH / 9;              /* CALC # CHARS IN BUFFER             */
   BBLK$     = BUF$ -> BUF.BLK$;        /* GET POINTER TO BUFFER DATA         */
   SIZE_DIF  = SV_WIDTH - FV_WIDTH;
                                        /* CALC DIFFERENCE IN BUFFER SIZE     */
                                        /* EACH SUBSTITUTION WILL REQUIRE     */
   IF LINE_NBR > 0                      /* SUPPOSED TO FIND A LINE?           */
    THEN DO;                            /* YES                                */
      TIX1   = 0;                       /* INIT CHAR INDEX                    */
      DO WHILE (LINE_NBR > 1  AND  TIX1 < NBR_CHARS);
                                        /* FIND BEGINNING OF SPECIFIED LINE   */
         IF BBLK$  -> UBIN9#(TIX1) = CT_CR
                                        /* LINE SEPARATOR??                   */
          THEN LINE_NBR = LINE_NBR - 1;
                                        /* INDICATE ANOTHER LINE END FOUND    */
         TIX1 = TIX1 + 1;               /* INC CHAR INDEX                     */
         END;
      IF TIX1 >= NBR_CHARS              /* DID WE FIND THE CORRECT LINE?      */
       THEN DO;                         /* NOPE                               */
         CALL UT_DEALLOC_BUF( FIND_VAL$ );
                                        /* GET RID OF VALUES                  */
         CALL UT_DEALLOC_BUF( SUBS_VAL$ );
         VAL_FAULT = 77;
                    /*E* 78V XQC_EDIT: SPECIFIED LINE DOES NOT EXIST          */
         RETURN;
         END;
      BBLK$ = PINCRC( BBLK$,  TIX1 );
                    /* MAKE DATA POINTER POINT TO FIRST BIT OF PROPER LINE    */
      SWIDTH = TIX1 * 9;                /* CALC WIDTH OF BUFFER TO LINE       */
      END;
    ELSE SWIDTH = 0;                    /* BEGIN AT BUFFER'S FIRST BIT        */
 
/********************
***   FIND THE SPECIFIED OCCURANCE OF THE SPECIFIED VALUE.
**/
   SV_BLK$     = SUBS_VAL$ -> BUF.BLK$; /* GET POINTERS                       */
   FV_BLK$     = FIND_VAL$ -> BUF.BLK$;
 
   NOT_FOUND   = 0;                     /* INIT FOUND FLAG                    */
   FOUND_COUNT = 0;                     /* AND COUNT OF # SUBS MADE           */
 
/**
***   FIND OCCURANCES OF FIRST VALUE AND SUBSTITUTE SECOND.
**/
   IF OCCURANCE <= 0 THEN OCCURANCE = -1;
                                        /* ADJUST OCCURANCE FOR 'ALL'         */
   DO WHILE (OCCURANCE ~= 0  AND  NOT_FOUND = 0);
      NOT_FOUND = 1;                    /* ASSUME NOT FOUND                   */
      DO WHILE (NOT_FOUND = 1  AND  SWIDTH+FV_WIDTH <= BWIDTH);
                    /* SEARCH WHILE UNSUCCESSFUL AND BUFFER AREA UNSEARCHED   */
              /**
              ***   DETERMINE IF NEXT GROUP MATCHES.
              **/
         TIX1 = 0;                      /* INIT BIT MATCH INDEX               */
         TEMP1 = FV_WIDTH;              /* SET BIT STRING WIDTH FOR COMPARE   */
         IF FV_BLK$ -> BITS = BBLK$ -> BITS /* DO WE HAVE A MATCH?            */
          THEN DO;                      /* YES                                */
            NOT_FOUND = 0;              /* FOUND THE STRING                   */
            OCCURANCE = OCCURANCE - 1;
                                        /* INDICATE OCCURANCE OF VALUE FOUND  */
            END;
          ELSE DO;                      /* DIDN'T MATCH--TRY NEXT             */
            SWIDTH = SWIDTH + GROUP_WIDTH;
                                        /* SKIP OVER CURRENT GROUP            */
            BBLK$ = PINCRB( BBLK$, GROUP_WIDTH );
            END;
         END;
 
         /**
         ***   DO SUBSTITUTION IF PROPER OCCURANCE FOUND.
         **/
      IF OCCURANCE <= 0  AND  NOT_FOUND = 0
                                        /* PROPER OCCURANCE FOUND??           */
       THEN DO;                         /* YES: DO SUBSTITUTION               */
         TO_MOVE = BWIDTH - SWIDTH - FV_WIDTH;
                                   /* CALC NUMBER OF BITS THAT MUST BE MOVED  */
         BWIDTH = BWIDTH + SIZE_DIF;
                                        /* CALC NEW SIZE OF THE BUFFER        */
         IF SIZE_DIF > 0
                              /* VALUE TO SUBSTITUTE WIDER THAN FOUND VALUE   */
          THEN DO;                      /* YES                                */
                   /**
                   ***   MAKE ROOM FOR THE SUBSTITUTION FIELD.
                   **/
            CALL UT_NEW_SIZE( BUF$, BWIDTH );
                                        /* EXPAND THE BUFFER                  */
            IF VAL_FAULT ~= 0           /* IF ERROR                           */
             THEN DO;                   /* TELL USER # SUBS                   */
               CALL UT_DEALLOC_BUF( FIND_VAL$ );
               CALL UT_DEALLOC_BUF( SUBS_VAL$ );
               BBLK$ = ADDR( FOUND_COUNT );
               CALL UT_DISPLAY( BBLK$, 36, -DT_DECIMAL );
               CALL UT_OUTPUT_CHARS( ' found...', 9 );
               RETURN;
               END;
                   /**
                   ***   MOVE EXISTING BITS OUT OF THE WAY.
                   **/
            SV_BLK$ = SUBS_VAL$->BUF.BLK$; /* Get data ptr in case moved      */
            FV_BLK$ = FIND_VAL$->BUF.BLK$;
            BBLK$ = PINCRB( BUF$ -> BUF.BLK$, SWIDTH
              + SV_WIDTH );
                                   /* POINT TO TARGET AREA FOR MOVED BITS     */
            FROM$ = PINCRB( BBLK$, -SIZE_DIF );
                                        /* POINT TO SOURCE AREA               */
            CALL UT_MOVE_BITS_RWD( FROM$, SIZE_DIF, TO_MOVE  );
                   /**
                   ***   MOVE IN THE NEW BITS.
                   **/
            TO$ = PINCRB( BBLK$, -SV_WIDTH );
                                        /* POINT TO FIRST BIT OF DESTINATION  */
            CALL UT_MOVE_BITS_FWD( SV_BLK$, TO$, SV_WIDTH );
            SWIDTH = SWIDTH + SV_WIDTH;
                                        /* INCREASE SEARCHED WIDTH            */
            END;
          ELSE DO;                      /* SUBS FIELD SMALLER THAN FIND FIELD */
            IF SIZE_DIF = 0             /* EQUAL SIZE?                        */
             THEN DO;                   /* YES                                */
               CALL UT_MOVE_BITS_FWD( SV_BLK$, BBLK$, SV_WIDTH );
                                        /* MOVE IN REPLACEMENT                */
               END;
             ELSE DO;
                        /**
                        ***   JUST MOVE BITS FORWARD.
                        **/
               TO$   = PINCRB( BBLK$, SV_WIDTH );
                                        /* POINT TO TARGET AREA               */
               FROM$ = PINCRB( BBLK$, FV_WIDTH );
                                        /* POINT TO SOURCE AREA               */
               CALL UT_MOVE_BITS_FWD( FROM$, TO$, TO_MOVE   );
                                        /* SQUEEZE OUT UNUSED SPACE           */
               CALL UT_MOVE_BITS_FWD( SV_BLK$, BBLK$, SV_WIDTH );
                                        /* MOVE IN THE SUBSTITUTION VALUE     */
               CALL UT_NEW_SIZE( BUF$, BWIDTH );
                                        /* ADJUST WIDTH OF THE BUFFER         */
               END;
            SWIDTH = SWIDTH + SV_WIDTH;
            BBLK$  = PINCRB( BUF$ -> BUF.BLK$, SWIDTH );
                                        /* INCREASE SEARCHED WIDTH            */
            END;
         FOUND_COUNT = FOUND_COUNT + 1; /* INC NUMBER SUBSTITUTIONS           */
         END;
       ELSE DO;                         /* MIGHT HAVE FOUND WRONG OCCURANCE   */
         IF NOT_FOUND = 0               /* FIND AN OCCURANCE?                 */
          THEN DO;                      /* YES                                */
            SWIDTH = SWIDTH + GROUP_WIDTH; /* SKIP OVER IT                    */
            BBLK$  = PINCRB( BBLK$, GROUP_WIDTH );
            END;
         END;
      END;
 
/********************
***   TELL USER HOW MANY SUBSTITUTIONS WERE MADE.
**/
   CALL UT_DEALLOC_BUF( FIND_VAL$ );    /* DEALLOCATE THE VALUES              */
   CALL UT_DEALLOC_BUF( SUBS_VAL$ );
   BBLK$ = ADDR( FOUND_COUNT );
   IF NOT (ZY$->BT36# & ZYF_DONT_GOSSIP)
    THEN DO;
      CALL UT_DISPLAY( BBLK$, 36, -DT_DECIMAL );
      CALL UT_OUTPUT_CHARS( ' found', 6 );
      END;
   RETURN;
 
END XQC_EDIT;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***   EV_EVAL_SIZE   16 SEP 77   (PRY)   EVALUATES SIZE SPECIFICATION.
**/
 
EV_EVAL_SIZE: PROC( SIZE#, GOT_SIZE# );
 
/***   CONVERT SIZE SPECIFICATION TO NUMBER OF BITS   ***/
DCL   EV_GET_OFFSET          ENTRY(5);
 
/********************
***   PARAMETERS:
**/
DCL   SIZE#          SBIN WORD ALIGNED; /* RETURNED SIZE IN BITS              */
DCL   GOT_SIZE#         SBIN WORD ALIGNED;
                                   /* FLAG INDICATING IF SIZE WAS SPECIFIED   */
 
/********************
***   LOCALS:
**/
DCL   RES       SBIN WORD ALIGNED AUTO; /* INITIAL RESOLUTION                 */
DCL   FRES      SBIN WORD ALIGNED AUTO; /* FINAL RESOLUTION                   */
 
/********************
***   INITIAL RESOLUTION IS CHARACTER.
**/
   RES = 1;                             /* SET INITIAL RESOLUTION             */
   CALL EV_GET_OFFSET( RES, 1, FRES, SIZE#, GOT_SIZE# );
                                        /* CONVERT SIZE SPECIFICATION         */
 
   RETURN;
 
END EV_EVAL_SIZE;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
 
/**
***   EXEC_DATA 14 SEP 77  (PRY)   DATA MORE CONCERNED WITH
***   EXECUTION THAN MEMORY MANAGEMENT.
**/
 
 
UT_EXEC_DATA: PROC;
/*** FLAG SET IF A NON-X BUFFER IS MODIFIED ***/
DCL   NOT_X_ONLY        SBIN WORD ALIGNED   STATIC    SYMDEF;
 
/*** FLAG RESET WHEN AN EXIT CONDITION OR COMMAND IS ENCOUNTERED ***/
DCL   USER_WANTS_FILER_TO_RUN SBIN WORD ALIGNED STATIC SYMDEF;
 
/*** BASED VALUE CONVERSION ***/
DCL BASE(0:3) SBIN WORD ALIGNED CONSTANT SYMDEF INIT( 2, 4, 8, 16 );
DCL BASE_WIDTH(0:3) SBIN WORD ALIGNED CONSTANT SYMDEF INIT( 1, 2, 3, 4 );
DCL MAX_BASE_IX SBIN WORD ALIGNED CONSTANT SYMDEF INIT( 3 );
 
END UT_EXEC_DATA;
/*********************************************************************/
