/*M* PATCH - Put commentary on patch card decks */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
PATCH: PROC MAIN ALTRET NOAUTO;
 
/****
*
*   PATCH provides patch formatting capability for submission of
*   patches to the Control Group.  Basicly, it takes input in the
*   form of a patch file created by the programmer and applies
*   commentary to the "cards", including the programmer's initials,
*   system (or product) version, date the patch was prepared, the
*   STAR number, and sequential numbers ("n of m").
*
*   This, the C00 version of PATCH, provides some enhancements
*   over the original version:  Multiple patches may be presented
*   in a single file, options may be presented on the command line
*   or in the patch file, and some new defaults apply.  See the
*   file PATCH_HELP.X for details.
*
*   Overall program operation is as follows:
*
*   1.  Decode the command line, stowing the input and output
*       filenames and global options (if any).
*   2.  Open the input file and read one record, looking for
*       "sub" options (which temporarily override the global ones).
*   3.  Print the "sub" option line (if found) and query the user
*       for any missing options.
*   4.  After reading (and possibly stowing) comments from the
*       input file, prompt the user for (additional) comments.
*   5.  Read the remainder of the patch, up to the next "sub"
*       option line or EOF and stow it in dynamic memory.
*   6.  Produce a "title" card indicating the number of cards in
*       the patch and the number of non-comments, for use by the
*       Control Group in placing the patch.
*   7.  "Punch" the patch from memory, appending the commentary
*       mentioned above.
*   8.  Repeat steps 3-7 until EOF.
*
*   Since the user has the option of specifying the output file as
*   being the input file ("OVER"), any error severe enough to
*   cause a patch to be skipped forces PATCH to scratch the output
*   file.  Terminal errors include syntax errors on the command
*   or sub-option lines, patches which exceed 80 characters after
*   reformatting, and all non-accountable I/O errors.
*
****/
 
%EJECT;
/****
*
*   %INCLUDEs
*
****/
 
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE XU_MACRO_C;
%INCLUDE PATCH_C61;
 
%EJECT;
/****
*
*   FPTs and other macros
*
****/
 
%FPT_OPEN(FPTN=OPEN_SI,
          DCB=M$SI,
          FUN=IN);
 
%FPT_READ(FPTN=READ_SI,
          DCB=M$SI,
          BUF=SIBUF);
 
%FPT_CLOSE(FPTN=CLOSE_SI,
           DCB=M$SI,
           DISP=SAVE);
 
%FPT_OPEN(FPTN=OPEN_ME,
          DCB=M$ME,
          FUN=UPDATE);
 
%FPT_READ(FPTN=READ_ME,
          DCB=M$ME,
          BUF=MEBUF);
 
%FPT_WRITE(FPTN=WRITE_ME,
           DCB=M$ME,
           BUF=MOBUF);
 
%FPT_CLOSE(FPTN=CLOSE_ME,
           DCB=M$ME,
           DISP=SAVE);
 
%FPT_OPEN(FPTN=OPEN_OPT,
          DCB=F$OPT,
          FUN=IN,
          NAME=NAME_OPT,
          ASN=FILE);
 
%FPT_READ(FPTN=READ_OPT,
          DCB=F$OPT,
          BUF=OPTBUF);
 
%FPT_CLOSE(FPTN=CLOSE_OPT,
           DCB=F$OPT,
           DISP=SAVE);
 
%VLP_NAME(FPTN=NAME_OPT,
          LEN=22,
          NAME=':PATCH_DEFAULT_OPTIONS');
 
%FPT_OPEN(FPTN=OPEN_LO,
          DCB=M$LO,
          FUN=CREATE,
          EXIST=OLDFILE);
 
%FPT_WRITE(FPTN=WRITE_LO,
           DCB=M$LO,
           BUF=LOBUF);
 
%FPT_CLOSE(FPTN=CLOSE_LO,
           DCB=M$LO,
           DISP=SAVE);
 
%FPT_OPEN(FPTN=OPEN_DONE,
          DCB=M$DONE,
          FUN=CREATE,
          ORG=CONSEC,
          EXIST=NEWFILE,
          NAME=NAME_DONE,
          ACCESS=ACCESS_DONE,
          ACCT=ACCT_DONE,
          ASN=FILE,
          TYPE='PF');
 
%FPT_WRITE(FPTN=WRITE_DONE,
           DCB=M$DONE,
           BUF=OUBUF);
 
%FPT_CLOSE(FPTN=CLOSE_DONE,
           DCB=M$DONE,
           DISP=SAVE);
 
%VLP_NAME(FPTN=NAME_DONE,
          LEN=31,
          NAME='                               ');
 
%VLP_ACCT(FPTN=ACCT_DONE,
          ACCT='PATCH');
 
%VLP_ATTR(FPTN=ACCESS_DONE);
%VLP_ACCESS(ACCT='?',
            READ=YES,
            DELF=YES,
            DELR=NO,
            REATTR=NO,
            UPD=NO,
            WNEW=NO,
            LAST=";");
 
%FPT_OPEN(FPTN=OPEN_OU,
          DCB=M$OU,
          FUN=CREATE,
          ORG=KEYED,
          EXIST=NEWFILE,
          NAME=NAME_OU,
          ACCT=ACCT_OU,
          ASN=FILE,
          SN=SN_OU,
          WSN=WSN_OU,
          PASS=PASS_OU);
 
%FPT_WRITE(FPTN=WRITE_OU,
           DCB=M$OU,
           BUF=OUBUF,
           KEY=KEYBUF,
           ONEWKEY=YES);
 
%FPT_CLOSE(FPTN=CLOSE_OU,
           DCB=M$OU,
           DISP=SAVE);
 
%VLP_NAME(FPTN=NAME_OU,
          LEN=31,
          NAME='                               ');
 
%VLP_ACCT(FPTN=ACCT_OU,
          ACCT='        ');
 
%VLP_PASS(FPTN=PASS_OU,
          PASS='        ');
 
%VLP_WSN(FPTN=WSN_OU,
         WSN='        ');
 
%VLP_SN(FPTN=SN_OU,
        N=3);
 
%FPT_PROMPT(VFC=NO);
 
%FPT_SINPUT;
 
%FPT_TIME(FPTN=GET_TIME,
          SOURCE=CLOCK,
          DEST=LOCAL,
          TIME=TICTOC,
          DATE=MMDDYY);
 
%FPT_TIME(FPTN=CVT_UTS,
          SOURCE=UTS,
          DEST=LOCAL,
          DATE=UTS.DATE,
          TIME=UTS.TIME,
          TSTAMP=T);
 
%FPT_GDP(RESULTS=VLP_VECTOR,
         PAGES=1);
 
%VLP_VECTOR;
 
%FPT_FID(NAME=NAME_OU,
         ACCT=ACCT_OU,
         PASS=PASS_OU,
         SN=SN_OU,
         WSN=WSN_OU,
         ASN=OPEN_OU.V.ASN#,
         RES=OPEN_OU.V.RES#,
         RESULTS=VLR_FID);
 
%VLR_FID;
 
%FPT_ERRMSG(FPTN=PCH_ERROR,
            CODE=ERRCODE,
            BUF=LOBUF,
            RESULTS=VLR_ERRMSG,
            OUTDCB1=M$LO,
            INCLCODE=NO);
 
%FPT_ERRMSG(FPTN=SYS_ERROR,
            CODE=ERRCODE,
            BUF=LOBUF,
            RESULTS=VLR_ERRMSG,
            OUTDCB1=M$LO,
            INCLCODE=YES);
 
%VLR_ERRMSG;
 
%F$DCB(DCBN=DUMMY);
 
%B$TCB;
 
%B$ALT;
 
%P_PCB;
 
%PARSE$OUT;
 
%PARSE$SYM;
 
%EJECT;
/****
*
*   DCBs
*
****/
 
    DCL M$SI                           DCB;
    DCL M$ME                           DCB;
    DCL F$OPT                          DCB;
    DCL M$LO                           DCB;
    DCL M$OU                           DCB;
    DCL M$LM                           DCB;
    DCL M$DONE                         DCB;
 
%EJECT;
/****
*
*   Working storage.
*
****/
 
    DCL SIBUF STATIC                   CHAR(256);
    DCL MEBUF STATIC                   CHAR(256);
    DCL OPTBUF STATIC                  CHAR(256);
    DCL LOBUF STATIC                   CHAR(132);
    DCL OUBUF STATIC                   CHAR(80);
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
    DCL L                              SBIN;
    DCL M                              SBIN;
    DCL T STATIC                       UBIN;
    DCL WRKSIZ                         SBIN;
    DCL CLSQUOTE                       SBIN;
    DCL CMTCHARS                       SBIN;
    DCL PCHCHARS                       SBIN;
    DCL NXTCELL                        SBIN;
    DCL CURCELL                        SBIN;
    DCL LSTCELL                        SBIN;
    DCL CMTWRDS                        SBIN;
    DCL NXTCOL                         SBIN;
    DCL NOF                            SBIN;
    DCL OFN                            SBIN;
 
    DCL 1 JOBOPT STATIC,
          2 S# UNAL                    BIT(1),
          2 PT UNAL                    BIT(1),
          2 AI UNAL                    BIT(1),
          2 SV UNAL                    BIT(1),
          2 RU UNAL                    BIT(1),
          2 CC UNAL                    BIT(1),
          2 PC UNAL                    BIT(1),
          2 UTS UNAL                   BIT(1),
          2 NC UNAL                    BIT(1),
          2 GL UNAL                    BIT(1),
          2 DF UNAL                    BIT(1),
          2 DN UNAL                    BIT(1),
          2 TY UNAL                    BIT(1),
          2 LIB UNAL                   BIT(1),
          2 OU UNAL                    BIT(1);
 
    DCL 1 SUBOPT STATIC,
          2 S# UNAL                    BIT(1),
          2 PT UNAL                    BIT(1),
          2 AI UNAL                    BIT(1),
          2 SV UNAL                    BIT(1),
          2 RU UNAL                    BIT(1),
          2 CC UNAL                    BIT(1),
          2 PC UNAL                    BIT(1),
          2 UTS UNAL                   BIT(1),
          2 NC UNAL                    BIT(1),
          2 GL UNAL                    BIT(1),
          2 DF UNAL                    BIT(1),
          2 DN UNAL                    BIT(1),
          2 TY UNAL                    BIT(1),
          2 LIB UNAL                   BIT(1),
          2 OU UNAL                    BIT(1);
 
    DCL 1 JOB STATIC,
          2 S#,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(9),
          2 PT                         CHAR(1),
          2 AI,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(3),
          2 SV,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(7),
          2 RU,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(31),
          2 OU,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(31),
          2 CC                         BIT(1),
          2 PC                         BIT(1),
          2 NC                         BIT(1),
          2 TY                         BIT(1),
          2 DF                         BIT(1),
          2 DN                         BIT(1),
          2 GL                         UBIN BYTE,
          2 UTS,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(20);
 
    DCL 1 SUB STATIC,
          2 S#,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(9),
          2 PT                         CHAR(1),
          2 AI,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(3),
          2 SV,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(7),
          2 RU,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(31),
          2 OU,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(31),
          2 CC                         BIT(1),
          2 PC                         BIT(1),
          2 NC                         BIT(1),
          2 TY                         BIT(1),
          2 DF                         BIT(1),
          2 DN                         BIT(1),
          2 GL                         UBIN BYTE,
          2 UTS,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(20);
 
    DCL 1 KEYBUF STATIC,
          2 L UNAL                     UBIN BYTE,
          2 C UNAL                     UBIN(27);
 
    DCL 1 MOBUF STATIC,
          2 INTG UNAL                  CHAR(5),
          2 * UNAL                     CHAR(1) INIT('.'),
          2 FRAC UNAL                  CHAR(3),
          2 * UNAL                     CHAR(1) INIT(' '),
          2 PTCH UNAL                  CHAR(80);
 
    DCL 1 OF_N,
          2 L UNAL                     UBIN BYTE,
          2 C UNAL                     CHAR(7);
 
    DCL 1 TICTOC STATIC,
          2 HR UNAL                    CHAR(2),
          2 * UNAL                     CHAR(9);
 
    DCL 1 UTS STATIC,
          2 * UNAL                     UBIN BYTE INIT(20),
          2 DATE UNAL                  CHAR(8),
          2 * UNAL                     CHAR(1) INIT(' '),
          2 TIME UNAL                  CHAR(11);
 
    DCL B$JIT$ SYMREF                  PTR;
    DCL B$TCB$ SYMREF                  PTR;
    DCL PATCHCMD SYMREF                UBIN WORD;
    DCL OPTIONLIST SYMREF              UBIN WORD;
    DCL X$PARSE                        ENTRY(1) ALTRET;
 
    DCL FCG CONSTANT                   UBIN INIT(%(BITBIN('200310000000'O)));
    DCL ERRCODE STATIC                 UBIN;
    DCL BITCODE REDEF ERRCODE          BIT(36);
 
    DCL I_GOT_PROBS                    BIT(72);
 
    DCL DWORK                          CHAR(8);
    DCL MMDDYY STATIC                  CHAR(8);
    DCL LOW_VALUES(0:3) CONSTANT       BIT(72) INIT('0'B*0);
    DCL LV REDEF LOW_VALUES            CHAR(32);
 
    DCL BUF_FULL                       BIT(1);
    DCL AI_PRINTED                     BIT(1) STATIC INIT ('0'B);
 
    DCL BLK$                           PTR;
    DCL P                              PTR;
    DCL PCH BASED(P)                   CHAR(256);
 
    DCL PROMPT_PATCH CONSTANT          CHAR(0) INIT
        ('Patch? ');
    DCL PROMPT_COMMENT CONSTANT        CHAR(0) INIT
        ('Comment? ');
    DCL PROMPT_S# CONSTANT             CHAR(0) INIT
        ('STAR #? ');
    DCL PROMPT_PT CONSTANT             CHAR(0) INIT
        ('Aard/Xdel/Mon/PLOVER/FEP/RUM? ');
    DCL PROMPT_AI CONSTANT             CHAR(0) INIT
        ('Author''s initials? ');
    DCL PROMPT_SV CONSTANT             CHAR(0) INIT
        ('System version? ');
    DCL PROMPT_PV CONSTANT             CHAR(0) INIT
        ('Processor version? ');
    DCL PROMPT_RU CONSTANT             CHAR(0) INIT
        ('Module to RUM? ');
    DCL PROMPT_GL CONSTANT             CHAR(0) INIT
        ('What GLOM? ');
    DCL PROMPT_LIB CONSTANT            CHAR(0) INIT
        ('Library name? ');
    DCL PROMPT_OU CONSTANT             CHAR(0) INIT
        ('Module (in library) to PLOVER? ');
 
    DCL GLOM(0:14) CONSTANT            CHAR(12) INIT(
        '************','ASYNC       ','BSC         ','DISKETTE    ',
        'FORMS       ','HOST_LINK   ','KERNEL      ','MULE        ',
        'PIGLET      ','RBT         ','URP         ','X25         ',
        '3270        ','7700        ','            ');
 
    DCL 1 UPPERS CONSTANT,
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT(' !"#$%&''()*+,-./0123456789:;<=>?'),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'),
          2 * CHAR(32) INIT('`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~ '),
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT(' !"#$%&''()*+,-./0123456789:;<=>?'),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'),
          2 * CHAR(32) INIT('`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~ '),
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT(' !"#$%&''()*+,-./0123456789:;<=>?'),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'),
          2 * CHAR(32) INIT('`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~ '),
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT(' !"#$%&''()*+,-./0123456789:;<=>?'),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'),
          2 * CHAR(32) INIT('`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~ ');
 
    DCL 1 SCANBACK CONSTANT,
          2 *(0:31) UNAL BIT(9) INIT('123'O*32),
          2 *(0:31) UNAL BIT(9) INIT('000'O,'123'O*2,'000'O,'123'O*9,'000'O*2,
            '123'O,'000'O*10,'123'O*4,'000'O,'123'O),
          2 *(0:31) UNAL BIT(9) INIT('123'O,'000'O*26,'123'O*5),
          2 *(0:31) UNAL BIT(9) INIT('123'O*32);
 
%EJECT;
/****
*
*   Open M$LO (error commentary) and M$ME (interactive input).  Then
*   initialize working storage.  Get the date from the clock.  Set
*   up the first page of patch storage space.  Then parse the
*   command line from B$JIT.CCBUF.  If the parse is successful,
*   get the output file name from "dest" (if specified) or "source"
*   if "dest" wasn't specified (and change the open mode to "over").
*   Decode the option list into the JOB cells; provide defaults for
*   System Version (A00) and Author's Initials ("xxx" from the
*   logon account if it is of the form "xxxHOST ").  Then open the
*   input file (M$SI) and output file (M$OU) and announce program
*   initiation and version via M$LO.
*
****/
 
    PCH_ERROR.FILENAME_=VECTOR(DCBADDR(DCBNUM(M$LM))->DUMMY.NAME#);
    PCH_ERROR.FILEACCT_=VECTOR(DCBADDR(DCBNUM(M$LM))->DUMMY.ACCT#);
    CALL M$OPEN(OPEN_LO) ALTRET(BAD_LO);
    CALL M$OPEN(OPEN_ME) ALTRET(BAD_ME);
    IF DCBADDR(DCBNUM(M$ME))->DUMMY.WIDTH#<90 THEN DO;
        WRITE_ME.BUF_.BUF$=ADDR(MOBUF.PTCH);
        WRITE_ME.BUF_.BOUND=79;
    END;
    BUF_FULL='0'B;
    JOBOPT='0'B;
    SUBOPT='0'B;
    JOB='0'B;
    SUB='0'B;
    KEYBUF.L=3;
    KEYBUF.C=1000;
    REMEMBER BAD_GDP IN I_GOT_PROBS;
    CALL M$TIME(GET_TIME);
    CALL M$GDP(FPT_GDP) ALTRET(BAD_GDP);
    LSTCELL=15;
    P_PCB.WORK$=VLP_VECTOR.PTR$;
    P_PCB.WKSZ=1024;
    OPTBUF=' ';
    CALL M$OPEN(OPEN_OPT) ALTRET(GET_JOB_OPTIONS);
    CALL M$READ(READ_OPT) ALTRET(GET_JOB_OPTIONS);
    CALL M$CLOSE(CLOSE_OPT);
    P_PCB.ROOT$=ADDR(OPTIONLIST);
    P_PCB.TEXT$=ADDR(OPTBUF);
    P_PCB.NCHARS=256;
    CALL X$PARSE(P_PCB) ALTRET(BAD_DEF);
    IF P_PCB.HI_CHAR<256 THEN
        GOTO BAD_DEF;
    BLK$=P_PCB.OUT$;
    CALL OPTIONS(SUBOPT,JOB);
 
GET_JOB_OPTIONS:
    P_PCB.ROOT$=ADDR(PATCHCMD);
    P_PCB.TEXT$=ADDR(B$JIT.CCBUF);
    P_PCB.NCHARS=B$JIT.CCARS;
    CALL X$PARSE(P_PCB) ALTRET(BAD_JOB);
    BLK$=P_PCB.OUT$;
    IF OUT$BLK.NSUBLKS<=3 THEN DO;
        OPEN_OU.V.EXIST#=3 /* NEWFILE */;
        BLK$=OUT$BLK.SUBLK$(1);
        FPT_FID.TEXTFID_=VECTOR(OUT$SYM.TEXT);
        CALL M$FID(FPT_FID) ALTRET(BAD_FID);
    END;
    ELSE DO;
        OPEN_OU.V.EXIST#=OUT$BLK.SUBLK$(2)->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE-1;
        IF OPEN_OU.V.EXIST#=0 THEN
            OPEN_OU.V.EXIST#=1 /* ERROR */;
        BLK$=OUT$BLK.SUBLK$(3);
        FPT_FID.TEXTFID_=VECTOR(OUT$SYM.TEXT);
        CALL M$FID(FPT_FID) ALTRET(BAD_FID);
    END;
    DO CASE(P_PCB.OUT$->OUT$BLK.NSUBLKS);
        CASE(3);
            BLK$=P_PCB.OUT$->OUT$BLK.SUBLK$(2);
            CALL OPTIONS(JOBOPT,JOB);
        CASE(5);
            BLK$=P_PCB.OUT$->OUT$BLK.SUBLK$(4);
            CALL OPTIONS(JOBOPT,JOB);
    END;
    JOBOPT=JOBOPT|SUBOPT;
    IF NOT JOBOPT.AI AND (SUBSTR(B$JIT.ACCN,3,5)='HOST ' OR
        SUBSTR(B$JIT.ACCN,3,5)='FEP  ') THEN DO;
        JOBOPT.AI='1'B;
        JOB.AI.L=3;
        JOB.AI.C=SUBSTR(B$JIT.ACCN,0,3);
    END;
    IF NOT JOBOPT.CC THEN DO;
        JOBOPT.CC='1'B;
        JOB.CC='1'B;
    END;
    IF NOT JOBOPT.PC THEN DO;
        JOBOPT.PC='1'B;
        JOB.PC='1'B;
    END;
    IF NOT JOBOPT.NC THEN DO;
        JOBOPT.NC='1'B;
        JOB.NC='0'B;
    END;
    IF NOT JOBOPT.TY THEN DO;
        JOBOPT.TY='1'B;
        JOB.TY='0'B;
    END;
    CALL M$OPEN(OPEN_SI) ALTRET(BAD_SI);
    CALL M$OPEN(OPEN_OU) ALTRET(BAD_OU);
    IF TICTOC.HR<'06' THEN
        LOBUF='Yawn!  PATCH C06 here (03/30/84)';
    ELSE IF TICTOC.HR<'12' THEN
        LOBUF='Good morning, PATCH C06 here (03/30/84)';
    ELSE IF TICTOC.HR<'18' THEN
        LOBUF='Good afternoon, PATCH C06 here (03/30/84)';
    ELSE
        LOBUF='Good evening, PATCH C06 here (03/30/84)';
    CALL M$WRITE(WRITE_LO);
 
%EJECT;
/****
*
*   Read one record from M$SI and determine if it is a sub-option
*   line.  If it is, pass it to the parser for decoding, and, if
*   successful, stow these options in the SUB cells.  Then cascade
*   the JOB options into missing SUB options.  Finally, walk through
*   the SUB options, prompting the user via M$LO for missing ones,
*   and reading and decoding his replies via M$ME.
*
****/
 
CHECK_FOR_OPTIONS:
    FPT_PROMPT.PROMPT_=VECTOR(PROMPT_PATCH);
    CALL M$PROMPT(FPT_PROMPT);
    SIBUF=' ';
    CALL M$READ(READ_SI) ALTRET(BAD_SI);
    IF SIBUF=' ' THEN
        GOTO CHECK_FOR_OPTIONS;
 
FETCH_SUB_OPTIONS:
    BUF_FULL='1'B;
    SUBOPT='0'B;
    IF (SUBSTR(SIBUF,0,1)='#' AND SUBSTR(SIBUF,1,1)>='0' AND
        SUBSTR(SIBUF,1,1)<='9') OR SUBSTR(SIBUF,0,5)='#LADC' THEN DO;
        BUF_FULL='0'B;
        LOBUF=SIBUF;
        CALL M$WRITE(WRITE_LO);
        P_PCB.ROOT$=ADDR(OPTIONLIST);
        P_PCB.TEXT$=ADDR(SIBUF);
        P_PCB.NCHARS=256;
        CALL X$PARSE(P_PCB) ALTRET(BAD_SUB);
        IF P_PCB.HI_CHAR<256 THEN
            GOTO BAD_SUB;
        BLK$=P_PCB.OUT$;
        CALL OPTIONS(SUBOPT,SUB);
    END;
    IF NOT SUBOPT.S# THEN DO;
        SUBOPT.S#=JOBOPT.S#;
        SUB.S#=JOB.S#;
    END;
    IF NOT SUBOPT.PT THEN DO;
        SUBOPT.PT=JOBOPT.PT;
        SUB.PT=JOB.PT;
    END;
    IF NOT SUBOPT.AI THEN DO;
        SUBOPT.AI=JOBOPT.AI;
        SUB.AI=JOB.AI;
    END;
    IF NOT SUBOPT.SV THEN DO;
        SUBOPT.SV=JOBOPT.SV;
        SUB.SV=JOB.SV;
    END;
    IF NOT SUBOPT.RU THEN DO;
        SUBOPT.RU=JOBOPT.RU;
        SUB.RU=JOB.RU;
    END;
    IF NOT SUBOPT.CC THEN DO;
        SUBOPT.CC=JOBOPT.CC;
        SUB.CC=JOB.CC;
    END;
    IF NOT SUBOPT.PC THEN DO;
        SUBOPT.PC=JOBOPT.PC;
        SUB.PC=JOB.PC;
    END;
    IF NOT SUBOPT.UTS THEN DO;
        SUBOPT.UTS=JOBOPT.UTS;
        SUB.UTS=JOB.UTS;
    END;
    IF NOT SUBOPT.NC THEN DO;
        SUBOPT.NC=JOBOPT.NC;
        SUB.NC=JOB.NC;
    END;
    IF NOT SUBOPT.TY THEN DO;
        SUBOPT.TY=JOBOPT.TY;
        SUB.TY=JOB.TY;
    END;
    IF NOT SUBOPT.GL THEN DO;
        SUBOPT.GL=JOBOPT.GL;
        SUB.GL=JOB.GL;
    END;
    IF NOT SUBOPT.DF THEN DO;
        SUBOPT.DF=JOBOPT.DF;
        SUB.DF=JOB.DF;
    END;
    IF NOT SUBOPT.DN THEN DO;
        SUBOPT.DN=JOBOPT.DN;
        SUB.DN=JOB.DN;
    END;
    IF NOT SUBOPT.LIB THEN DO;
        SUBOPT.LIB=JOBOPT.LIB;
        SUB.RU=JOB.RU;
    END;
    IF NOT SUBOPT.OU THEN DO;
        SUBOPT.OU=JOBOPT.OU;
        SUB.OU=JOB.OU;
    END;
    IF NOT SUBOPT.PT AND (SUBOPT.OU OR SUBOPT.LIB) THEN DO;
        SUBOPT.PT='1'B;
        SUB.PT='P';
    END;
    IF NOT SUBOPT.PT AND SUBOPT.RU THEN DO;
        SUBOPT.PT='1'B;
        SUB.PT='R';
    END;
    IF NOT SUBOPT.PT AND SUBOPT.GL THEN DO;
        SUBOPT.PT='1'B;
        SUB.PT='F';
    END;
 
%EJECT;
/****
*
*   Read from M$SI until a non-comment card is found.  Note that
*   there may already be a record in the buffer from above.  If
*   the user has specified to keep old comments, stow them in the
*   memory pages for patches, acquiring more memory as needed.
*   Then prompt the user for new or additional comments for this
*   patch and stow them (always) in memory, terminating when the
*   user types a blank line.  Note that comments are compressed
*   into a minimum number of "cards" by removing extraneous blanks
*   and packing words tightly into the buffer.
*
****/
 
    P=P_PCB.WORK$;
    NXTCELL=0;
    NXTCOL=0;
    OFN=0;
    CMTWRDS=0;
    IF SUB.S#.L=0 THEN
        SUB.S#.L=5;
 
    IF BUF_FULL THEN
        GOTO CHECK_FOR_COMMENT;
 
READ_OLD_COMMENTS:
    FPT_PROMPT.PROMPT_=VECTOR(PROMPT_PATCH);
    CALL M$PROMPT(FPT_PROMPT);
    SIBUF=' ';
    CALL M$READ(READ_SI) ALTRET(BAD_SI);
    IF SIBUF=' ' THEN
        GOTO READ_OLD_COMMENTS;
 
CHECK_FOR_COMMENT:
    CALL COMMENT('0'B) ALTRET(READ_NEW_COMMENTS);
    IF SUBSTR(SIBUF,0,7)='"REPQRY' OR SUBSTR(SIBUF,0,7)='"REMQRY' THEN DO;
        I=7;
        DO WHILE(I<256 AND SUBSTR(SIBUF,0,1)=' ');
            I=I+1;
        END;
        IF I>255 OR SUBSTR(SIBUF,I,1)~='#' THEN
            GOTO NOT_GOOD;
        CALL INDEX(I,' ',SIBUF,I);
        SIBUF=SUBSTR(SIBUF,1,I-1);
        CALL STOWCMT(SIBUF);
        GOTO READ_OLD_COMMENTS;
    END;
 
NOT_GOOD:
    I=255;
    DO WHILE(SUBSTR(SIBUF,I,1)=' ');
        I=I-1;
    END;
    IF I>=4 AND SUBSTR(SIBUF,I-4,5)='#LADC' THEN
        CALL INSERT(SIBUF,I-4,5,' ');
    ELSE DO;
        J=0;
        K=0;
        L=0;
        DO WHILE(I>0 AND (SUBSTR(SIBUF,I,1)='.' OR (SUBSTR(SIBUF,I,1)>='0'
            AND SUBSTR(SIBUF,I,1)<='9')));
            IF SUBSTR(SIBUF,I,1)='.' THEN
                J=J+1;
            ELSE IF J=0 THEN
                K=K+1;
            ELSE L=L+1;
            I=I-1;
        END;
        IF I>=0 AND SUBSTR(SIBUF,I,1)='#' AND ((J=1 AND K>0 AND K<6 AND
            L>0 AND L<3) OR (J=0 AND K>0 AND K<7 AND L=0)) THEN
            CALL INSERT(SIBUF,I,J+K+L+1,' ');
    END;
    IF SUB.CC THEN
        CALL STOWCMT(SIBUF);
    GOTO READ_OLD_COMMENTS;
 
READ_NEW_COMMENTS:
    IF NOT SUB.NC AND CMTWRDS>1 THEN
        GOTO CHECK_FOR_EOP;
    FPT_PROMPT.PROMPT_=VECTOR(PROMPT_COMMENT);
    CALL M$PROMPT(FPT_PROMPT);
    MEBUF=' ';
    CALL M$READ(READ_ME) ALTRET(CHECK_FOR_EOP);
    IF MEBUF=' ' THEN
        GOTO CHECK_FOR_EOP;
    CALL STOWCMT(MEBUF);
    GOTO READ_NEW_COMMENTS;
 
%EJECT;
/****
*
*   Check for finding a sub-option card in the patch file, and exit
*   to the write routine if found.  Otherwise, read the patch file
*   and stow the patches in memory.  If reformatting is allowed,
*   remove all old comments from the patch card; otherwise, stow the
*   patch as is.  If a comment image is found when reading for
*   patches, it is either packed into memory or discarded, in
*   accordance with the setting of the "keep old comments" flag.
*
****/
 
CHECK_FOR_EOP:
    IF (SUBSTR(SIBUF,0,1)='#' AND SUBSTR(SIBUF,1,1)>='0' AND
        SUBSTR(SIBUF,1,1)<='9') OR SUBSTR(SIBUF,0,5)='#LADC' THEN
        GOTO WRITE_PATCH;
    IF SUBSTR(SIBUF,0,6)='!MINI ' THEN DO;
        IF SUB.PT=BINASC(0) THEN
            SUB.PT='A';
        CALL UNPARSE;
        GOTO READ_PATCH;
    END;
    IF SUBSTR(SIBUF,0,6)='!XDEL ' THEN DO;
        CALL INDEX(I,' XDELTA PATCHES ',SIBUF,7);
        IF I<79 THEN DO;
            IF SUB.PT=BINASC(0) THEN
                SUB.PT='X';
            CALL UNPARSE;
            GOTO READ_PATCH;
        END;
        CALL INDEX(I,' MONITOR PATCHES ',SIBUF,7);
        IF I<79 THEN DO;
            IF SUB.PT=BINASC(0) THEN
                SUB.PT='M';
            CALL UNPARSE;
            GOTO READ_PATCH;
        END;
    END;
    IF SUBSTR(SIBUF,0,5)='!FEP ' THEN DO;
        IF SUB.PT=BINASC(0) THEN
            SUB.PT='F';
        CALL UNPARSE;
        GOTO READ_PATCH;
    END;
    IF SUBSTR(SIBUF,0,5)='!RUM ' THEN DO;
        IF SUB.PT=BINASC(0) THEN
            SUB.PT='R';
        CALL UNPARSE;
        GOTO READ_PATCH;
    END;
    IF SUBSTR(SIBUF,0,8)='!PLOVER ' THEN DO;
        IF SUB.PT=BINASC(0) THEN
            SUB.PT='P';
        CALL UNPARSE;
        GOTO READ_PATCH;
    END;
    IF SUBSTR(SIBUF,0,3)='IF ' AND SUB.PT='F' THEN DO;
        I=3;
        DO WHILE(I<256 AND SUBSTR(SIBUF,I,1)=' ');
            I=I+1;
        END;
        IF I<256 THEN DO;
            CALL INDEX(J,' ',SIBUF,I);
            J=J-I;
            K=0;
            DO WHILE(GLOM(K)~=' ' AND SUBSTR(GLOM(K),0,J)~=SUBSTR(SIBUF,I,J));
                K=K+1;
            END;
            IF GLOM(K)~=' ' THEN DO;
                SUB.GL=K;
                GOTO READ_PATCH;
            END;
        END;
    END;
    IF SUBSTR(SIBUF,0,4)='RUM ' AND SUB.PT='R' THEN DO;
        I=3;
        DO WHILE(I<256 AND SUBSTR(SIBUF,I,1)=' ');
            I=I+1;
        END;
        IF I<256 THEN DO;
            CALL INDEX(J,' ',SIBUF,I);
            CALL INDEX(K,',',SIBUF,I);
            IF K<J THEN
                J=K;
            J=J-I;
            SUB.RU.L=MINIMUM(J,31);
            SUB.RU.C=SUBSTR(SIBUF,I,J);
            J=J+I;
            IF SUBSTR(SIBUF,J,1)~=',' THEN DO;
                I=J+1;
                CALL INDEX(J,' ',SIBUF,I);
                IF J-I>4 THEN
                    CALL INDEX(J,' ',SIBUF,J+1);
                J=J-I;
                SUB.UTS.L=MINIMUM(J,20);
                SUB.UTS.C=SUBSTR(SIBUF,I,J);
            END;
            GOTO READ_PATCH;
        END;
    END;
    IF SUBSTR(SIBUF,0,7)='PLOVER ' AND SUB.PT='P' THEN DO;
        I=6;
        DO WHILE(I<256 AND SUBSTR(SIBUF,I,1)=' ');
            I=I+1;
        END;
        IF I<256 THEN DO;
            CALL INDEX(J,'(',SIBUF,I);
            IF J=0 THEN
                J=I;
            J=J-I;
            SUB.RU.L=MINIMUM(J,31);
            SUB.RU.C=SUBSTR(SIBUF,I,J);
            CALL INDEX(I,'(OU=',SIBUF,I);
            IF I>0 THEN DO;
                I=I+4;
                CALL INDEX(J,',',SIBUF,I);
                IF J=0 THEN
                    J=I;
                J=J-I;
                SUB.OU.L=MINIMUM(J,31);
                SUB.OU.C=SUBSTR(SIBUF,I,J);
                CALL INDEX(I,',UTS=',SIBUF,I);
                IF I>0 THEN DO;
                    I=I+5;
                    CALL INDEX(J,')',SIBUF,I);
                    IF J=0 THEN
                        J=I;
                    J=J-I;
                    SUB.UTS.L=MINIMUM(J,20);
                    SUB.UTS.C=SUBSTR(SIBUF,I,J);
                END;
            END;
            GOTO READ_PATCH;
        END;
    END;
    IF SUBSTR(SIBUF,0,5)='QUIT ' OR SUBSTR(SIBUF,0,4)='END ' OR
        SUBSTR(SIBUF,0,2)='Q ' OR SUBSTR(SIBUF,0,3)='EN ' OR
        (SUB.PT='X' AND (SUBSTR(SIBUF,0,7)='U XDEL ' OR
        SUBSTR(SIBUF,0,6)='UXDEL ')) OR (SUBSTR(SIBUF,0,4)='RUM '
        AND SUBOPT.UTS) OR SUBSTR(SIBUF,0,1)='!' OR (SUB.PT='F' AND
        (SUBSTR(SIBUF,0,3)='IF ' OR SUBSTR(SIBUF,0,6)='ENDIF '))
        THEN
        GOTO READ_PATCH;
    CALL COMMENT(~SUB.PC) ALTRET(STOWPCH);
 
STOWPCH:
    IF NXTCOL~=0 THEN
        CALL GETSPACE;
    I=255;
    DO WHILE(SUBSTR(SIBUF,I,1)=' ');
        I=I-1;
    END;
    IF I>=4 AND SUBSTR(SIBUF,I-4,5)='#LADC' THEN
        I=I-4;
    ELSE DO;
        J=0;
        K=0;
        L=0;
        DO WHILE(I>=0 AND (SUBSTR(SIBUF,I,1)='.' OR
            (SUBSTR(SIBUF,I,1)>='0' AND SUBSTR(SIBUF,I,1)<='9')));
            IF SUBSTR(SIBUF,I,1)='.' THEN
                J=J+1;
            ELSE IF J=0 THEN
                K=K+1;
            ELSE
                L=L+1;
            I=I-1;
        END;
        IF NOT (I>=0 AND SUBSTR(SIBUF,I,1)='#' AND ((J=1 AND K>0 AND K<6
            AND L>0 AND L<3) OR (J=0 AND K>0 AND K<7 AND L=0))) THEN
            GOTO CANT_ZAP;
    END;
    CALL INSERT(SIBUF,I,256-I,' ');
    IF I>0 AND SUBSTR(SIBUF,I-1,1)='"' THEN DO;
        CALL INSERT(SIBUF,I-1,1,' ');
        GOTO CANT_ZAP;
    END;
    I=I-2;
    IF I<2 THEN
        GOTO CANT_ZAP;
    J=0;
    K=0;
    L=0;
    DO WHILE(I>=0 AND (SUBSTR(SIBUF,I,1)='-' OR
        (SUBSTR(SIBUF,I,1)>='0' AND SUBSTR(SIBUF,I,1)<='9')));
        IF SUBSTR(SIBUF,I,1)='-' THEN
            J=J+1;
        ELSE IF J=0 THEN
            K=K+1;
        ELSE
            L=L+1;
        I=I-1;
    END;
    IF I<0 OR (SUBSTR(SIBUF,I,1)~=' ' AND SUBSTR(SIBUF,I,1)~='"') OR
        J~=1 OR K~=L OR K<1 THEN
        GOTO CANT_ZAP;
    CALL INSERT(SIBUF,I+1,J+K+L,' ');
    IF SUBSTR(SIBUF,I,1)='"' THEN DO;
        CALL INSERT(SIBUF,I,1,' ');
        GOTO CANT_ZAP;
    END;
    I=I-1;
    IF I<7 THEN
        GOTO CANT_ZAP;
    J=0;
    DO WHILE(I>=0 AND ((SUBSTR(SIBUF,I,1)>='0' AND SUBSTR(SIBUF,I,1)<=
        '9') OR SUBSTR(SIBUF,I,1)='/'));
        J=J+1;
        I=I-1;
    END;
    IF I<0 OR (SUBSTR(SIBUF,I,1)~=' ' AND SUBSTR(SIBUF,I,1)~='"') OR
        J~=6 AND J~=8 THEN
        GOTO CANT_ZAP;
    CALL INSERT(SIBUF,I+1,J,' ');
    IF SUBSTR(SIBUF,I,1)='"' THEN DO;
        CALL INSERT(SIBUF,I,1,' ');
        GOTO CANT_ZAP;
    END;
    I=I-1;
    IF I<1 THEN
        GOTO CANT_ZAP;
    J=0;
    DO WHILE(I>=0 AND (SUBSTR(SIBUF,I,1)='>' OR
        SUBSTR(SIBUF,I,1)='-' OR SUBSTR(SIBUF,I,1)='.' OR
        (SUBSTR(SIBUF,I,1)>='0' AND SUBSTR(SIBUF,I,1)<='9') OR
        (SUBSTR(SIBUF,I,1)>='A' AND SUBSTR(SIBUF,I,1)<='Z')));
        J=J+1;
        I=I-1;
    END;
    IF I<0 OR (SUBSTR(SIBUF,I,1)~=' ' AND SUBSTR(SIBUF,I,1)~='"') OR
        J<1 OR J>7 THEN
        GOTO CANT_ZAP;
    CALL INSERT(SIBUF,I+1,J,' ');
    IF SUBSTR(SIBUF,I,1)='"' THEN DO;
        CALL INSERT(SIBUF,I,1,' ');
        GOTO CANT_ZAP;
    END;
    I=I-1;
    IF I<2 THEN
        GOTO CANT_ZAP;
    J=0;
    DO WHILE(I>=0 AND SUBSTR(SIBUF,I,1)>='A' AND SUBSTR(SIBUF,I,1)<='Z');
        J=J+1;
        I=I-1;
    END;
    IF I<0 OR (SUBSTR(SIBUF,I,1)~=' ' AND SUBSTR(SIBUF,I,1)~='"') OR
        J<2 OR J>3 THEN
        GOTO CANT_ZAP;
    CALL INSERT(SIBUF,I+1,J,' ');
    IF SUBSTR(SIBUF,I,1)='"' THEN
        CALL INSERT(SIBUF,I,1,' ');
 
CANT_ZAP:
    PCH=SIBUF;
    NXTCOL=256;
    OFN=OFN+1;
 
READ_PATCH:
    FPT_PROMPT.PROMPT_=VECTOR(PROMPT_PATCH);
    CALL M$PROMPT(FPT_PROMPT);
    SIBUF=' ';
    CALL M$READ(READ_SI) ALTRET(BAD_SI);
    IF SIBUF=' ' THEN
        GOTO READ_PATCH;
    CALL COMMENT('0'B) ALTRET(CHECK_FOR_EOP);
    I=255;
    DO WHILE(SUBSTR(SIBUF,I,1)=' ');
        I=I-1;
    END;
    IF I>=4 AND SUBSTR(SIBUF,I-4,5)='#LADC' THEN
        CALL INSERT(SIBUF,I-4,5,' ');
    ELSE DO;
        J=0;
        K=0;
        L=0;
        DO WHILE(I>0 AND (SUBSTR(SIBUF,I,1)='.' OR (SUBSTR(SIBUF,I,1)>='0'
            AND SUBSTR(SIBUF,I,1)<='9')));
            IF SUBSTR(SIBUF,I,1)='.' THEN
                J=J+1;
            ELSE IF J=0 THEN
                K=K+1;
            ELSE L=L+1;
            I=I-1;
        END;
        IF I>=0 AND SUBSTR(SIBUF,I,1)='#' AND ((J=1 AND K>0 AND K<6 AND
            L>0 AND L<3) OR (J=0 AND K>0 AND K<7 AND L=0)) THEN
            CALL INSERT(SIBUF,I,J+K+L+1,' ');
    END;
    IF SUB.CC THEN
        CALL STOWCMT(SIBUF);
    GOTO READ_PATCH;
 
%EJECT;
/****
*
*   Now replay the core buffer into patch images, providing the
*   required commentary on the cards.  The output file is EDIT-
*   keyed, provided it is written to a file or tape.  If there are
*   no valid patches in the file (OFN is non-positive), nothing is
*   written.  The footwork with SIBUF and MEBUF is done to save the
*   contents of SIBUF, since it is used by the COMMENT subroutine
*   to determine if an image is a comment or patch and to set the
*   value of CLSQUOTE, the column number of the last closing quote.
*   A title card is prepared which indicates what type of patch
*   this is (Aardvark, RUM, etc.), which module it is to (if a RUM
*   patch), and how many cards and patches (non-comments) it has.
*   Note that "U" cards are not commented if this is an Aardvark
*   patch and that a "U XDEL" card is provided automatically if
*   this is an XDELTA patch.  If the user has specified that this
*   is a RUM patch and has supplied a UTS, a RUM card is produced.
*   Note that commentary gives way to patch contents, but that old
*   commentary is deleted (if present) to make room for the new
*   comments.
*
****/
 
WRITE_PATCH:
    MEBUF=SIBUF;
    IF OFN=-1 THEN
        GOTO EOJ_CHECK;
    IF NXTCOL~=0 THEN
        NXTCELL=NXTCELL+1;
    NOF=NXTCELL+1;
    DO WHILE(NOT SUBOPT.S#);
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_S#);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.S#.C~=SUBSTR(LV,0,9) THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.S#.C);
            FPT_SINPUT.BUF_.BOUND=SUB.S#.L-1;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL XLATE(MEBUF,UPPERS,MEBUF);
        IF MEBUF='LADC' OR MEBUF='#LADC' THEN DO;
            SUBOPT.S#='1'B;
            SUB.S#.L=5;
            SUB.S#.C='#LADC';
        END;
        ELSE DO;
            IF SUBSTR(MEBUF,0,1)='#' THEN DO;
                LOBUF=SUBSTR(MEBUF,1,255);
                MEBUF=LOBUF;
            END;
            CALL VERIFY_S# ALTRET(UGH_S#);
            CALL INDEX(I,' ',MEBUF,0);
            SUBOPT.S#='1'B;
            SUB.S#.L=I+1;
            CALL CONCAT(SUB.S#.C,'#',SUBSTR(MEBUF,0,I));
        END;
        GOTO DO_S#_FOOT;
 
UGH_S#:
        ERRCODE=FCG+8*3;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -003-0
      MESSAGE:Syntax is [#]LADC or [#]dddddd.  Try again.
*/
 
DO_S#_FOOT:
    END;
    DO WHILE(NOT SUBOPT.PT);
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_PT);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.PT~=BINASC(0) THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.PT);
            FPT_SINPUT.BUF_.BOUND=0;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL XLATE(MEBUF,UPPERS,MEBUF);
        SUB.PT=SUBSTR(MEBUF,0,1);
        IF SUB.PT~='A' AND SUB.PT~='X' AND SUB.PT~='F' AND SUB.PT~='R'
            AND SUB.PT~='M' AND SUB.PT~='P' THEN DO;
            ERRCODE=FCG+8*4;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -004-0
      MESSAGE:Try A or X or M or F or P or R, please.
*/
        END;
        ELSE
            SUBOPT.PT='1'B;
    END;
    DO WHILE(NOT SUBOPT.AI);
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_AI);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.AI.C~=SUBSTR(LV,0,3) THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.AI.C);
            FPT_SINPUT.BUF_.BOUND=SUB.AI.L-1;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL XLATE(MEBUF,UPPERS,MEBUF);
        CALL INDEX(I,' ',MEBUF,0);
        IF I<2 OR I>3 THEN DO;
            ERRCODE=FCG+8*5;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -005-0
      MESSAGE:Enter 2 or 3 characters, please.
*/
        END;
        ELSE DO;
            SUBOPT.AI='1'B;
            SUB.AI.L=I;
            SUB.AI.C=SUBSTR(MEBUF,0,I);
        END;
    END;
     IF NOT SUBOPT.RU THEN DO;
    DO WHILE(SUB.PT='R' AND NOT SUBOPT.RU);
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_RU);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.RU.C~=SUBSTR(LV,0,31) AND SUB.RU.C ~=' ' THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.RU.C);
            FPT_SINPUT.BUF_.BOUND=SUB.RU.L-1;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL INDEX(I,' ',MEBUF,0);
        IF I<1 OR I>31 THEN DO;
            ERRCODE=FCG+8*7;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -007-0
      MESSAGE:I want a 1-31 character run unit name.
*/
        END;
        ELSE DO;
            SUBOPT.RU='1'B;
            SUB.RU.L=I;
            SUB.RU.C=SUBSTR(MEBUF,0,I);
        END;
    END;                      /* DO WHILE */
     END;                          /* DO IF RU NOT SET */
     ELSE DO;
                              /* Dont care what the current patch says
                                   .... put the cmdline RU there! */
          SUB.RU.L = JOB.RU.L;
          SUB.RU.C = JOB.RU.C;
          END;
    DO WHILE(SUB.PT='P' AND NOT SUBOPT.LIB);
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_LIB);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.RU.C~=SUBSTR(LV,0,31) THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.RU.C);
            FPT_SINPUT.BUF_.BOUND=SUB.RU.L-1;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL INDEX(I,' ',MEBUF,0);
        IF I<1 OR I>31 THEN DO;
            ERRCODE=FCG+8*35;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -035-0
      MESSAGE:I want a 1-31 character library name.
*/
        END;
        ELSE DO;
            SUBOPT.LIB='1'B;
            SUB.RU.L=I;
            SUB.RU.C=SUBSTR(MEBUF,0,I);
        END;
    END;
    DO WHILE(SUB.PT='P' AND NOT SUBOPT.OU);
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_OU);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.OU.C~=SUBSTR(LV,0,31) THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.OU.C);
            FPT_SINPUT.BUF_.BOUND=SUB.OU.L-1;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL INDEX(I,' ',MEBUF,0);
        IF I<1 OR I>31 THEN DO;
            ERRCODE=FCG+8*36;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -036-0
      MESSAGE:I want a 1-31 character object unit name.
*/
        END;
        ELSE DO;
            SUBOPT.OU='1'B;
            SUB.OU.L=I;
            SUB.OU.C=SUBSTR(MEBUF,0,I);
        END;
    END;
    DO WHILE(NOT SUBOPT.SV);
        IF SUB.PT='R' THEN
            FPT_PROMPT.PROMPT_=VECTOR(PROMPT_PV);
        ELSE
            FPT_PROMPT.PROMPT_=VECTOR(PROMPT_SV);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.SV.C~=SUBSTR(LV,0,7) THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(SUB.SV.C);
            FPT_SINPUT.BUF_.BOUND=SUB.SV.L-1;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL XLATE(MEBUF,UPPERS,MEBUF);
        CALL INDEX(I,' ',MEBUF,0);
        IF I<1 OR I>7 THEN DO;
            ERRCODE=FCG+8*29;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -029-0
      MESSAGE:Enter 1 to 7 characters, please.
*/
        END;
        ELSE DO;
       IF I ~= 3 THEN DO;
           ERRCODE=FCG+8*40;
           CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -040-0
      MESSAGE:WARNING: Processor version should be exactly three characters.
*/
        END;
            SUBOPT.SV='1'B;
            SUB.SV.L=I;
            SUB.SV.C=SUBSTR(MEBUF,0,I);
        END;
    END;
    IF NOT SUBOPT.NC THEN DO;
        SUBOPT.NC='1'B;
        SUB.NC='1'B;
    END;
    IF (SUB.PT='R' OR SUB.PT='F' OR SUB.PT='P') AND NOT SUBOPT.UTS THEN DO;
        SUBOPT.UTS='1'B;
        IF SUB.SV.L>=4 THEN DO;
            SUB.UTS.L=4;
            SUB.UTS.C=SUBSTR(SUB.SV.C,0,4);
        END;
        ELSE DO;
            SUB.UTS.L=SUB.SV.L;
            SUB.UTS.C=SUB.SV.C;
        END;
    END;
    DO WHILE(SUB.PT='F' AND NOT SUBOPT.GL AND SUB.SV.C>='B01');
        FPT_PROMPT.PROMPT_=VECTOR(PROMPT_GL);
        CALL M$PROMPT(FPT_PROMPT);
        MEBUF=' ';
        READ_ME.V.DVBYTE.REREAD#='0'B;
        IF SUB.GL~=0 THEN DO;
            FPT_SINPUT.BUF_.BUF$=ADDR(GLOM(SUB.GL));
            FPT_SINPUT.BUF_.BOUND=11;
            CALL M$SINPUT(FPT_SINPUT);
            READ_ME.V.DVBYTE.REREAD#='1'B;
        END;
        CALL M$READ(READ_ME) ALTRET(BAD_EOF);
        CALL INDEX(I,' ',MEBUF,0);
        J=1;
        DO WHILE(I>=1 AND I<=12 AND GLOM(J)~=' ' AND
            SUBSTR(GLOM(J),0,I)~=SUBSTR(MEBUF,0,I));
            J=J+1;
        END;
        IF I<1 OR I>12 OR GLOM(J)=' ' THEN DO;
            ERRCODE=FCG+8*30;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -030-0
      MESSAGE:I need one of the following (one letter will suffice):
              ASYNC, BSC, DISKETTE, FORMS, HOST_LINK, KERNEL, MULE,
              PIGLET, RBT, URP, X25, 3270, or 7700.
*/
        END;
        ELSE DO;
            SUBOPT.GL='1'B;
            SUB.GL=J;
        END;
    END;
    IF SUB.PT='F' AND SUB.SV.C>='C00' THEN DO;
        ERRCODE=FCG+8*37;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -037-0
      MESSAGE:**Warning!  FEP/GLOM is valid only for host releases
                prior to C00.
*/
    END;
    READ_ME.V.DVBYTE.REREAD#='0'B;
    IF SUB.PT='A' THEN DO;
        CALL CONCAT(OUBUF,'!MINI "',SUBSTR(SUB.SV.C,0,SUB.SV.L));
        I=SUB.SV.L+8;
        NAME_DONE.NAME#='AARDVARK';
    END;
    ELSE IF SUB.PT='X' THEN DO;
        CALL CONCAT(OUBUF,'!XDEL "',SUBSTR(SUB.SV.C,0,SUB.SV.L),
            ' XDELTA PATCHES - ');
        I=SUB.SV.L+25;
        NOF=NOF+1;
        OFN=OFN+1;
        NAME_DONE.NAME#='XDELTA';
    END;
    ELSE IF SUB.PT='M' THEN DO;
        CALL CONCAT(OUBUF,'!XDEL "',SUBSTR(SUB.SV.C,0,SUB.SV.L),
            ' MONITOR PATCHES - ');
        I=SUB.SV.L+26;
        NAME_DONE.NAME#='MONITOR';
    END;
    ELSE IF SUB.PT='F' THEN DO;
        CALL CONCAT(OUBUF,'!FEP "',SUBSTR(SUB.SV.C,0,SUB.SV.L));
        I=SUB.SV.L+7;
        IF SUBOPT.GL THEN
            NOF=NOF+2;
    END;
    ELSE IF SUB.PT='R' THEN DO;
        CALL CONCAT(OUBUF,'!RUM "',SUBSTR(SUB.SV.C,0,SUB.SV.L),' ',
            SUBSTR(SUB.RU.C,0,SUB.RU.L),' - ');
        I=SUB.RU.L+SUB.SV.L+10;
        NOF=NOF+1;
        NAME_DONE.NAME#=SUBSTR(SUB.RU.C,0,SUB.RU.L);
    END;
    ELSE IF SUB.PT='P' THEN DO;
        CALL CONCAT(OUBUF,'!PLOVER "',SUBSTR(SUB.SV.C,0,SUB.SV.L),' ',
            SUBSTR(SUB.RU.C,0,SUB.RU.L),'(');
        I=SUB.SV.L+SUB.RU.L+11;
        CALL INSERT(OUBUF,I,,SUBSTR(SUB.OU.C,0,SUB.OU.L),') - ');
        I=I+SUB.OU.L+4;
        NOF=NOF+1;
        NAME_DONE.NAME#=SUBSTR(SUB.RU.C,0,SUB.RU.L);
    END;
    IF SUB.DN THEN DO;
        CALL INDEX(K,' ',NAME_DONE.NAME#);
        K=MINIMUM(K,30-SUB.S#.L-SUB.SV.L);
        CALL INSERT(NAME_DONE.NAME#,K,,'_',SUBSTR(SUB.S#.C,1,
            SUB.S#.L-1),'_',SUBSTR(SUB.SV.C,0,SUB.SV.L));
        NAME_DONE.L#=K+SUB.S#.L+SUB.SV.L+1;
        CALL CONCAT(OPEN_DONE.V.TYPE#,BINASC(7),BINASC(127));
        CALL M$OPEN(OPEN_DONE) WHENALTRETURN DO;
            SYS_ERROR.V.DCB#=DCBNUM(M$DONE);
            BITCODE=B$TCB$->B$TCB.ALT$->B$ALT.ERR;
            ERRCODE=8*(ERRCODE/8);
            CALL M$ERRMSG(SYS_ERROR);
            ERRCODE=FCG+8*31;
            CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -031-0
      MESSAGE:**DONE option ignored.
*/
            SUB.DN='0'B;
        END;
    END;
    CALL CVD(NOF,DWORK,J);
    CALL INSERT(OUBUF,I,,SUBSTR(DWORK,J,8-J),' CARDS/');
    I=I+15-J;
    CALL CVD(OFN,DWORK,J);
    CALL INSERT(OUBUF,I,,SUBSTR(DWORK,J,8-J),' PATCHES');
    I=I+17-J;
    IF OFN=1 THEN DO;
        CALL INSERT(OUBUF,I-3,2,'  ');
        I=I-2;
    END;
    OF_N.L=8-J;
    OF_N.C=SUBSTR(DWORK,J,8-J);
    J=80-SUB.S#.L;
    IF I<=J THEN DO;
        CALL INSERT(OUBUF,J,SUB.S#.L,SUBSTR(SUB.S#.C,0,SUB.S#.L));
        J=J-9;
        IF I<=J THEN DO;
            CALL INSERT(OUBUF,J,8,MMDDYY);
            J=J-SUB.SV.L-1;
            IF I<=J THEN DO;
                CALL INSERT(OUBUF,J,SUB.SV.L,SUBSTR(SUB.SV.C,0,SUB.SV.L));
                J=J-SUB.AI.L-1;
                IF I<=J THEN
                    CALL INSERT(OUBUF,J,SUB.AI.L,SUBSTR(SUB.AI.C,0,
                        SUB.AI.L));
            END;
        END;
    END;
    CALL M$WRITE(WRITE_OU) ALTRET(BAD_OU);
    IF SUB.DN THEN
        CALL M$WRITE(WRITE_DONE) ALTRET(BAD_DONE);
    IF SUB.TY THEN
        CALL ECHO;
    KEYBUF.C=KEYBUF.C+1000;
    NOF=1;
    P=PINCRC(P_PCB.WORK$,-256);
    CURCELL=-1;
    IF SUB.PT='X' THEN DO;
        OUBUF='U XDEL';
        GOTO APPEND_COMMENTARY;
    END;
    IF SUB.PT='R' AND SUBOPT.UTS THEN DO;
        CALL CONCAT(OUBUF,'RUM ',SUBSTR(SUB.RU.C,0,SUB.RU.L),',UTS=',
            SUBSTR(SUB.UTS.C,0,SUB.UTS.L),' "');
        GOTO JUST_STARNO;
    END;
    IF SUB.PT='F' AND SUBOPT.GL THEN DO;
        CALL CONCAT(OUBUF,'IF ',GLOM(SUB.GL));
        CALL INDEX(I,' ',OUBUF,3);
        CALL INSERT(OUBUF,I,,' (UTS=',SUBSTR(SUB.UTS.C,0,SUB.UTS.L),') "');
        GOTO JUST_STARNO;
    END;
    IF SUB.PT='P' THEN DO;
        CALL CONCAT(OUBUF,'PLOVER ',SUBSTR(SUB.RU.C,0,SUB.RU.L),'(OU=',
            SUBSTR(SUB.OU.C,0,SUB.OU.L),',UTS=');
        I=SUB.RU.L+SUB.OU.L+16;
        CALL INSERT(OUBUF,I,,SUBSTR(SUB.UTS.C,0,SUB.UTS.L),') "');
        GOTO JUST_STARNO;
    END;
 
NEXT_PATCH:
    CURCELL=CURCELL+1;
    IF CURCELL>=NXTCELL THEN
        GOTO EOJ_CHECK;
    P=PINCRC(P,256);
    OUBUF=PCH;
 
APPEND_COMMENTARY:
    SIBUF=OUBUF;
    CALL COMMENT('0'B) ALTRET(PROCESS_PATCH);
    IF SUB.PT='A' OR SUB.PT='X' THEN
        SUBSTR(OUBUF,0,2)='C ';
 
JUST_STARNO:
    CALL INSERT(OUBUF,80-SUB.S#.L,SUB.S#.L,SUBSTR(SUB.S#.C,0,SUB.S#.L));
    CALL M$WRITE(WRITE_OU) ALTRET(BAD_OU);
    IF SUB.DN THEN
        CALL M$WRITE(WRITE_DONE) ALTRET(BAD_DONE);
    IF SUB.TY THEN
        CALL ECHO;
    KEYBUF.C=KEYBUF.C+1000;
    GOTO NEXT_PATCH;
 
PROCESS_PATCH:
    L=2*OF_N.L+SUB.S#.L+SUB.SV.L+SUB.AI.L+12;
    IF PCHCHARS+SUB.S#.L+1>80 THEN DO;
        ERRCODE=FCG+8*28;
        CALL CVD(NOF,DWORK,K);
        SUB.S#.C=SUBSTR(DWORK,K,8-K);
        SUB.S#.L=8-K;
        PCH_ERROR.FIELD1_=VECTOR(SUB.S#);
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -028-0
      MESSAGE:**Error! Card %U1 won't fit in 80 columns!
*/
        PCH_ERROR.FIELD1_=VECTOR(NIL);
        NXTCOL=0;
        OFN=-1;
        GOTO FLUSH;
    END;
    IF (SUB.PT='A' OR SUB.PT='X') AND OUBUF='U' THEN
        GOTO OUTPUT_OUBUF;
 
SEARCH_FOR_LAST_CHAR:
    I=255;
    DO WHILE(I>0 AND SUBSTR(SIBUF,I,1)=' ');
        I=I-1;
    END;
    IF CLSQUOTE>255 AND I<255 THEN DO;
        I=I+1;
        CALL INSERT(SIBUF,I,1,'"');
        CALL COMMENT('0'B) ALTRET(WHO_CARES);
    END;
 
WHO_CARES:
    I=I+2;
    IF PCHCHARS+CMTCHARS+L<80 OR CMTCHARS=0 THEN
        GOTO WILL_IT_FIT;
    J=CLSQUOTE-1;
    DO WHILE(PCHCHARS+CMTCHARS+L>79 AND SUBSTR(SIBUF,J,1)~='"');
        CALL INSERT(SIBUF,J,2,'" ');
        J=J-1;
        CMTCHARS=CMTCHARS-1;
    END;
    IF SUBSTR(SIBUF,J,1)='"' THEN
        CALL INSERT(SIBUF,J,2,'  ');
    CALL COMMENT('0'B) ALTRET(SEARCH_FOR_LAST_CHAR);
 
WILL_IT_FIT:
    OUBUF=SIBUF;
    IF I+L<=80 THEN
        GOTO ADD_MY_2_CENTS;
    IF SUB.PT='A' OR SUB.PT='X' THEN
        PCHCHARS=I;
    I=I-2;
    IF PCHCHARS+CMTCHARS>79-L THEN
        K=PCHCHARS+CMTCHARS;
    ELSE
        K=79-L;
    IF SUBSTR(SIBUF,I,1)~='"' THEN
        K=K-1;
    CALL INSERT(OUBUF,K,80-K,' ');
    K=K-1;
    DO WHILE(K>=0 AND I>K);
        IF SUBSTR(SIBUF,I,1)=' ' THEN
            I=I-1;
        ELSE IF SUBSTR(SIBUF,I,1)='"' THEN DO;
            CALL INDEX1R(J,'"',SIBUF,I-1);
            K=K-I+J;
            CALL INSERT(OUBUF,K,I-J+1,SUBSTR(SIBUF,J,I-J+1));
            I=J-1;
            K=K-1;
            IF I>=0 AND K>=0 AND SUBSTR(SIBUF,I,1)=' ' THEN DO;
                CALL INSERT(OUBUF,K,1,' ');
                K=K-1;
            END;
        END;
        ELSE DO;
            J=I;
            DO WHILE(J>=0 AND SUBSTR(SIBUF,J,1)~='"' AND
                SUBSTR(SIBUF,J,1)~=' ');
                IF SUBSTR(SIBUF,J,1)='''' THEN DO;
                    IF J>0 THEN DO;
                        CALL INDEX1R(M,'''',SIBUF,J-1);
                        IF M<J THEN
                            J=M;
                        ELSE
                            J=J-1;
                    END;
                    IF J>=I THEN
                        J=0;
                END;
                J=J-1;
            END;
            IF J<-1 THEN
                J=-1;
            K=K-I+J+1;
            CALL INSERT(OUBUF,K,I-J,SUBSTR(SIBUF,J+1,I-J));
            K=K-1;
            I=J;
            IF I>=0 AND K>=0 AND SUBSTR(SIBUF,I,1)=' ' THEN DO;
                CALL INSERT(OUBUF,K,1,' ');
                K=K-1;
            END;
        END;
    END;
    SIBUF=OUBUF;
    CALL COMMENT('0'B) ALTRET(ADD_MY_2_CENTS);
 
ADD_MY_2_CENTS:
    I=79;
    DO WHILE(I>=0 AND SUBSTR(OUBUF,I,1)=' ');
        I=I-1;
    END;
    IF CLSQUOTE=I AND I>0 THEN DO;
        CALL INSERT(OUBUF,CLSQUOTE,1,' ');
        CLSQUOTE=256;
    END;
    I=I+2;
    J=80-SUB.S#.L;
    CALL CVD(NOF,DWORK,K);
/*  IF SUB.PT~='A' AND SUB.PT~='X' AND CLSQUOTE<256 THEN */
    IF CLSQUOTE<256 THEN
        IF I<J THEN DO;
            CALL INSERT(OUBUF,J,SUB.S#.L,SUBSTR(SUB.S#.C,0,SUB.S#.L));
            J=J-2*OF_N.L-2;
            IF I<J THEN DO;
                CALL INSERT(OUBUF,J,2*OF_N.L+1,SUBSTR(DWORK,8-OF_N.L,
                    OF_N.L),'-',SUBSTR(OF_N.C,0,OF_N.L));
                J=J-9;
                IF I<J THEN DO;
                    CALL INSERT(OUBUF,J,8,MMDDYY);
                    J=J-SUB.SV.L-1;
                    IF I<J THEN DO;
                        CALL INSERT(OUBUF,J,SUB.SV.L,SUBSTR(SUB.SV.C,0,
                            SUB.SV.L));
                        J=J-SUB.AI.L-1;
                        IF I<J THEN DO;
                            CALL INSERT(OUBUF,J-1,SUB.AI.L+1,'"',
                                SUBSTR(SUB.AI.C,0,SUB.AI.L));
                            AI_PRINTED = '1'B;
                            END;
                        ELSE
                            CALL INSERT(OUBUF,J+SUB.AI.L,1,'"');
                    END;
                    ELSE
                        CALL INSERT(OUBUF,J+SUB.SV.L,1,'"');
                END;
                ELSE
                    CALL INSERT(OUBUF,J+8,1,'"');
            END;
            ELSE
                CALL INSERT(OUBUF,J+2*OF_N.L+1,1,'"');
        END;
        ELSE
            ;
    ELSE
        IF I<=J THEN DO;
            CALL INSERT(OUBUF,J,SUB.S#.L,SUBSTR(SUB.S#.C,0,SUB.S#.L));
            J=J-2*OF_N.L-2;
            IF I<=J THEN DO;
                CALL INSERT(OUBUF,J,2*OF_N.L+1,SUBSTR(DWORK,8-OF_N.L,
                    OF_N.L),'-',SUBSTR(OF_N.C,0,OF_N.L));
                J=J-9;
                IF I<=J THEN DO;
                    CALL INSERT(OUBUF,J,8,MMDDYY);
                    J=J-SUB.SV.L-1;
                    IF I<=J THEN DO;
                        CALL INSERT(OUBUF,J,SUB.SV.L,SUBSTR(SUB.SV.C,0,
                            SUB.SV.L));
                        J=J-SUB.AI.L-1;
                        IF I<=J THEN DO;
                            CALL INSERT(OUBUF,J,SUB.AI.L,
                                SUBSTR(SUB.AI.C,0,SUB.AI.L));
                            AI_PRINTED = '1'B;
                            END;
                    END;
                END;
            END;
        END;
 
OUTPUT_OUBUF:
    CALL M$WRITE(WRITE_OU) ALTRET(BAD_OU);
    IF SUB.DN THEN
        CALL M$WRITE(WRITE_DONE) ALTRET(BAD_DONE);
    IF SUB.TY THEN
        CALL ECHO;
    KEYBUF.C=KEYBUF.C+1000;
    NOF=NOF+1;
    GOTO NEXT_PATCH;
 
%EJECT;
/****
*
*   Put SIBUF back the way it was, then check to see if M$SI is
*   open; if it is, what's in SIBUF is a sub-option line, and more
*   patching needs to be done.  Otherwise, close all the files and
*   go to EOJ.  Note that the close of M$OU may result in the file
*   being released if a previous error occurred; PATCH will try to
*   scan all patches in a file before aborting, if this is possible.
*
****/
 
EOJ_CHECK:
    IF SUB.PT='F' AND SUBOPT.GL AND OFN~=-1 THEN DO;
        OUBUF='ENDIF "';
        CALL INSERT(OUBUF,80-SUB.S#.L,SUB.S#.L,SUBSTR(SUB.S#.C,0,SUB.S#.L));
        CALL M$WRITE(WRITE_OU) ALTRET(BAD_OU);
        IF SUB.DN THEN
            CALL M$WRITE(WRITE_DONE) ALTRET(BAD_DONE);
        IF SUB.TY THEN
            CALL ECHO;
        KEYBUF.C=KEYBUF.C+1000;
    END;
    IF NOT AI_PRINTED THEN DO;
        ERRCODE=FCG+8*38;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -038-0
      MESSAGE:**Your initials have not been put in the patch, you should
                reformat your patch so that they will fit (ie. use DEFs).
*/
        END;
    AI_PRINTED = '0'B;
    IF SUB.DN THEN
        CALL M$CLOSE(CLOSE_DONE);
    SIBUF=MEBUF;
    IF DCBADDR(DCBNUM(M$SI))->DUMMY.FCD# THEN
        GOTO FETCH_SUB_OPTIONS;
    CALL M$CLOSE(CLOSE_OU);
    CALL M$CLOSE(CLOSE_ME);
    CALL M$CLOSE(CLOSE_LO);
    RETURN;
 
%EJECT;
/****
*
*   If an error occurred in processing a patch, it is flushed from
*   processing.  The disposition of M$OU is changed to SCRATCH.
*
****/
 
FLUSH:
    ERRCODE=FCG+8*9;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -009-0
      MESSAGE:**Flushing to next patch, if any; output will not be saved.
*/
    OFN=-1;
    CLOSE_OU.V.DISP#=1;
    FPT_PROMPT.PROMPT_=VECTOR(PROMPT_PATCH);
    CALL M$PROMPT(FPT_PROMPT);
 
PULL_THE_CHAIN:
    IF (SUBSTR(SIBUF,0,1)='#' AND SUBSTR(SIBUF,1,1)>='0' AND
        SUBSTR(SIBUF,1,1)<='9') OR SUBSTR(SIBUF,I,5)='#LADC' THEN
        GOTO FETCH_SUB_OPTIONS;
    SIBUF=' ';
    CALL M$READ(READ_SI) ALTRET(BAD_SI);
    GOTO PULL_THE_CHAIN;
 
%EJECT;
/****
*
*   Error handlers.  Most simply comment and go to EOJ, especially
*   on I/O errors.  M$SI may have gotten EOF or EOD, in which case
*   it is closed and control is passed to the write routine.
*
****/
 
BAD_LO:
    ALTRETURN;
 
BAD_ME:
    SYS_ERROR.V.DCB#=DCBNUM(M$ME);
    GOTO COMMON_ERROR;
 
BAD_GDP:
    ERRCODE=FCG+8*23;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -023-0
      MESSAGE:**Insufficient memory to contain patch.  Increase MEM
              **resource and try again.  PATCH aborts.
*/
    ALTRETURN;
 
BAD_JOB:
    IF P_PCB.HI_CHAR<255 THEN DO;
        LOBUF=' ';
        CALL INSERT(LOBUF,P_PCB.HI_CHAR+1,1,'^');
        CALL M$WRITE(WRITE_LO);
    END;
    ERRCODE=FCG+8*24;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -024-0
      MESSAGE:**Syntax error on command line.  PATCH aborts.
*/
    ALTRETURN;
 
BAD_FID:
    ERRCODE=FCG+8*25;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -025-0
      MESSAGE:**Illegal source or destination FID.  PATCH aborts.
*/
    ALTRETURN;
 
BAD_SI:
    IF DCBADDR(DCBNUM(M$SI))->DUMMY.TYC.EOF# OR
        DCBADDR(DCBNUM(M$SI))->DUMMY.TYC.EOD# THEN DO;
        CALL M$CLOSE(CLOSE_SI);
        GOTO WRITE_PATCH;
    END;
    SYS_ERROR.V.DCB#=DCBNUM(M$SI);
    GOTO COMMON_ERROR;
 
BAD_OU:
    SYS_ERROR.V.DCB#=DCBNUM(M$OU);
    GOTO COMMON_ERROR;
 
BAD_DONE:
    SYS_ERROR.V.DCB#=DCBNUM(M$DONE);
    GOTO COMMON_ERROR;
BAD_DEF:
    LOBUF=OPTBUF;
    CALL M$WRITE(WRITE_LO);
    IF P_PCB.HI_CHAR<255 THEN DO;
        LOBUF=' ';
        CALL INSERT(LOBUF,P_PCB.HI_CHAR+1,1,'^');
        CALL M$WRITE(WRITE_LO);
    END;
    ERRCODE=FCG+8*2;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -002-0
      MESSAGE:**Syntax error on default option line.  PATCH aborts.
*/
    ALTRETURN;
 
BAD_SUB:
    IF P_PCB.HI_CHAR<255 THEN DO;
        LOBUF=' ';
        CALL INSERT(LOBUF,P_PCB.HI_CHAR+1,1,'^');
        CALL M$WRITE(WRITE_LO);
    END;
    ERRCODE=FCG+8*26;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -026-0
      MESSAGE:**Syntax error on sub-option line.  This patch skipped.
*/
    SIBUF=' ';
    GOTO FLUSH;
 
BAD_EOF:
    ERRCODE=FCG+8*27;
    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -027-0
      MESSAGE:**Unexpected EOF on M$SI.  PATCH aborts.
*/
    ALTRETURN;
 
COMMON_ERROR:
    BITCODE=B$TCB$->B$TCB.ALT$->B$ALT.ERR;
    ERRCODE=8*(ERRCODE/8);
    CALL M$ERRMSG(SYS_ERROR);
    ALTRETURN;
 
 
%EJECT;
/****
*
*   The OPTIONS subroutine pulls the option list from the parser
*   nodes and stows it in the tables passed to it, either JOB or
*   SUB.  Duplicate options are ignored, and illegal option values
*   are ignored (both with appropriate bitching, of course).
*
****/
 
OPTIONS: PROC(OPTFLG,OPT);
 
    DCL 1 OPTFLG,
          2 S# UNAL                    BIT(1),
          2 PT UNAL                    BIT(1),
          2 AI UNAL                    BIT(1),
          2 SV UNAL                    BIT(1),
          2 RU UNAL                    BIT(1),
          2 CC UNAL                    BIT(1),
          2 PC UNAL                    BIT(1),
          2 UTS UNAL                   BIT(1),
          2 NC UNAL                    BIT(1),
          2 GL UNAL                    BIT(1),
          2 DF UNAL                    BIT(1),
          2 DN UNAL                    BIT(1),
          2 TY UNAL                    BIT(1),
          2 LIB UNAL                   BIT(1),
          2 OU UNAL                    BIT(1);
 
    DCL 1 OPT,
          2 S#,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(9),
          2 PT                         CHAR(1),
          2 AI,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(3),
          2 SV,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(7),
          2 RU,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(31),
          2 OU,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(31),
          2 CC                         BIT(1),
          2 PC                         BIT(1),
          2 NC                         BIT(1),
          2 TY                         BIT(1),
          2 DF                         BIT(1),
          2 DN                         BIT(1),
          2 GL                         UBIN BYTE,
          2 UTS,
            3 L UNAL                   UBIN BYTE,
            3 C UNAL                   CHAR(20);
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL P                              PTR;
    DCL Q                              PTR;
 
    DO I=0 TO OUT$BLK.NSUBLKS-1;
        P=OUT$BLK.SUBLK$(I);
        DO SELECT(P->OUT$BLK.CODE);
            SELECT(%SNOPT);
                IF OPTFLG.S# THEN DO;
                    ERRCODE=FCG+8*10;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -010-0
      MESSAGE:**Duplicate STAR number ignored.
*/
                END;
                ELSE IF P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%STARLADC THEN DO;
                    OPTFLG.S#='1'B;
                    OPT.S#.L=5;
                    OPT.S#.C='#LADC';
                END;
                ELSE DO;
                    P=P->OUT$BLK.SUBLK$(0);
                    MEBUF=SUBSTR(P->OUT$SYM.TEXT,0,P->OUT$SYM.COUNT);
                    CALL VERIFY_S# ALTRET(ILL_S#);
                    OPTFLG.S#='1'B;
                    OPT.S#.L=P->OUT$SYM.COUNT+1;
                    CALL CONCAT(OPT.S#.C,'#',SUBSTR(P->OUT$SYM.TEXT,0,
                        P->OUT$SYM.COUNT));
                END;
            SELECT(%PTOPT);
                IF OPTFLG.PT THEN DO;
                    ERRCODE=FCG+8*11;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -011-0
      MESSAGE:**Duplicate Patch Type ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.PT='1'B;
                    DO CASE(P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE);
                        CASE(%PTYPEA);
                            OPT.PT='A';
                        CASE(%PTYPEX);
                            OPT.PT='X';
                        CASE(%PTYPEM);
                            OPT.PT='M';
                        CASE(%PTYPEF);
                            OPT.PT='F';
                        CASE(%PTYPER);
                            OPT.PT='R';
                        CASE(%PTYPEP);
                            OPT.PT='P';
                    END;
                END;
            SELECT(%AIOPT);
                IF OPTFLG.AI THEN DO;
                    ERRCODE=FCG+8*12;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -012-0
      MESSAGE:**Duplicate Author's Initials ignored.
*/
                END;
                ELSE DO;
                    P=P->OUT$BLK.SUBLK$(0);
                    IF P->OUT$SYM.COUNT<2 OR P->OUT$SYM.COUNT>3 THEN
                        GOTO ILL_AI;
                    OPTFLG.AI='1'B;
                    OPT.AI.L=P->OUT$SYM.COUNT;
                    OPT.AI.C=SUBSTR(P->OUT$SYM.TEXT,0,P->OUT$SYM.COUNT);
                    CALL XLATE(OPT.AI.C,UPPERS,OPT.AI.C);
                END;
            SELECT(%SVOPT);
                IF OPTFLG.SV THEN DO;
                    ERRCODE=FCG+8*13;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -013-0
      MESSAGE:**Duplicate System/Processor Version ignored.
*/
                END;
                ELSE DO;
                    P=P->OUT$BLK.SUBLK$(0);
                    IF P->OUT$SYM.COUNT<1 OR P->OUT$SYM.COUNT>7 THEN
                        GOTO ILL_SV;
                    OPTFLG.SV='1'B;
                    OPT.SV.L=P->OUT$SYM.COUNT;
                    OPT.SV.C=SUBSTR(P->OUT$SYM.TEXT,0,P->OUT$SYM.COUNT);
                    CALL XLATE(OPT.SV.C,UPPERS,OPT.SV.C);
                END;
            SELECT(%RUOPT,%LIBOPT);
                IF OPTFLG.RU OR OPTFLG.LIB THEN DO;
                    ERRCODE=FCG+8*14;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -014-0
      MESSAGE:**Duplicate RU/LIB ignored.
*/
                END;
                ELSE DO;
                    IF P->OUT$BLK.CODE=%RUOPT THEN
                        OPTFLG.RU='1'B;
                    ELSE
                        OPTFLG.LIB='1'B;
                    P=P->OUT$BLK.SUBLK$(0);
                    IF P->OUT$SYM.COUNT<1 OR P->OUT$SYM.COUNT>31 THEN
                        GOTO ILL_RU;
                    OPT.RU.L=P->OUT$SYM.COUNT;
                    OPT.RU.C=SUBSTR(P->OUT$SYM.TEXT,0,P->OUT$SYM.COUNT);
                END;
            SELECT(%OCOPT);
                IF OPTFLG.CC THEN DO;
                    ERRCODE=FCG+8*15;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -015-0
      MESSAGE:**Duplicate CC option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.CC='1'B;
                    OPT.CC=BINBIT(P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE-1,1);
                END;
            SELECT(%PCOPT);
                IF OPTFLG.PC THEN DO;
                    ERRCODE=FCG+8*16;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -016-0
      MESSAGE:**Duplicate PC option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.PC='1'B;
                    OPT.PC=BINBIT(P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE-1,1);
                END;
            SELECT(%NCOPT);
                IF OPTFLG.NC THEN DO;
                    ERRCODE=FCG+8*1;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -001-0
      MESSAGE:**Duplicate NC option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.NC='1'B;
                    OPT.NC=BINBIT(P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE-1,1);
                END;
            SELECT(%UTOPT);
                IF OPTFLG.UTS THEN DO;
                    ERRCODE=FCG+8*17;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -017-0
      MESSAGE:**Duplicate UTS option ignored.
*/
                END;
                ELSE DO;
                    P=P->OUT$BLK.SUBLK$(0);
                    IF P->OUT$BLK.NSUBLKS>7 THEN
                        GOTO ILL_UTS;
                    IF P->OUT$BLK.NSUBLKS=0 THEN DO;
                        OPT.UTS.L=4;
                        OPT.UTS.C='NUTS';
                    END;
                    ELSE IF P->OUT$BLK.NSUBLKS=1 THEN DO;
                        P=P->OUT$BLK.SUBLK$(0);
                        IF P->OUT$SYM.COUNT<1 OR P->OUT$SYM.COUNT>12 THEN
                            GOTO ILL_UTS;
                        T=0;
                        DO J=0 TO P->OUT$SYM.COUNT;
                            T=8*T+ASCBIN(SUBSTR(P->OUT$SYM.TEXT,J,1))-
                                ASCBIN('0');
                        END;
                        CALL M$TIME(CVT_UTS);
                        OPT.UTS=UTS;
                    END;
                    ELSE IF P->OUT$BLK.NSUBLKS=2 THEN DO;
                        OPT.UTS.L=3;
                        OPT.UTS.C='A00';
                        CALL INSERT(OPT.UTS.C,0,1,P->OUT$BLK.SUBLK$(0)
                            ->OUT$SYM.TEXT);
                        Q=P->OUT$BLK.SUBLK$(1);
                        IF Q->OUT$SYM.COUNT=1 THEN
                            CALL INSERT(OPT.UTS.C,2,1,Q->OUT$SYM.TEXT);
                        ELSE
                            CALL INSERT(OPT.UTS.C,1,2,Q->OUT$SYM.TEXT);
                    END;
                    ELSE DO;
                        OPT.UTS.L=20;
                        OPT.UTS.C='00/00/00 00:00:00.00';
                        DO J=0 TO 6;
                            Q=P->OUT$BLK.SUBLK$(J);
                            IF Q->OUT$SYM.COUNT=2 THEN
                                CALL INSERT(OPT.UTS.C,3*J,2,Q->
                                    OUT$SYM.TEXT);
                            ELSE IF J<6 THEN
                                CALL INSERT(OPT.UTS.C,3*J+1,1,Q->
                                    OUT$SYM.TEXT);
                            ELSE
                                CALL INSERT(OPT.UTS.C,18,1,Q->
                                    OUT$SYM.TEXT);
                        END;
                    END;
                    OPTFLG.UTS='1'B;
                END;
            SELECT(%TYOPT);
                IF OPTFLG.TY THEN DO;
                    ERRCODE=FCG+8*6;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -006-0
      MESSAGE:**Duplicate TY option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.TY='1'B;
                    OPT.TY=BINBIT(P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE-1,1);
                END;
            SELECT(%GLOPT);
                IF OPTFLG.GL THEN DO;
                    ERRCODE=FCG+8*8;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -008-0
      MESSAGE:**Duplicate GL option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.GL='1'B;
                    OPT.GL=P->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
                END;
            SELECT(%DFOPT);
                IF OPTFLG.DF THEN DO;
                    ERRCODE=FCG+8*32;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -032-0
      MESSAGE:**Duplicate DFWMC option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.DF='1'B;
                    OPT.DF='1'B;
                END;
            SELECT(%DNOPT);
                IF OPTFLG.DN THEN DO;
                    ERRCODE=FCG+8*33;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -033-0
      MESSAGE:**Duplicate DONE option ignored.
*/
                END;
                ELSE DO;
                    OPTFLG.DN='1'B;
                    OPT.DN='1'B;
                END;
            SELECT(%OUOPT);
                IF OPTFLG.OU THEN DO;
                    ERRCODE=FCG+8*34;
                    CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -034-0
      MESSAGE:**Duplicate OU option ignored.
*/
                END;
                ELSE DO;
                    P=P->OUT$BLK.SUBLK$(0);
                    IF P->OUT$SYM.COUNT<1 OR P->OUT$SYM.COUNT>31 THEN
                        GOTO ILL_RU;
                    OPTFLG.OU='1'B;
                    OPT.OU.L=P->OUT$SYM.COUNT;
                    OPT.OU.C=SUBSTR(P->OUT$SYM.TEXT,0,P->OUT$SYM.COUNT);
                END;
        END;
        GOTO DO_FOOT;
 
ILL_S#:
        ERRCODE=FCG+8*18;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -018-0
      MESSAGE:**Illegal STAR number ignored.
*/
        GOTO DO_FOOT;
 
ILL_AI:
        ERRCODE=FCG+8*19;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -019-0
      MESSAGE:**Illegal Author's Initials ignored.
*/
        GOTO DO_FOOT;
 
ILL_SV:
        ERRCODE=FCG+8*20;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -020-0
      MESSAGE:**Illegal System/Processor Version ignored.
*/
        GOTO DO_FOOT;
 
ILL_RU:
        ERRCODE=FCG+8*21;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -021-0
      MESSAGE:**Illegal RU/OU/LIB name ignored.
*/
        GOTO DO_FOOT;
 
ILL_UTS:
        ERRCODE=FCG+8*22;
        CALL M$ERRMSG(PCH_ERROR);
/*E*    ERROR:    -022-0
      MESSAGE:**Illegal UTS ignored.
*/
        GOTO DO_FOOT;
 
DO_FOOT:
    END;
    RETURN;
END;
 
%EJECT;
/****
*
*   VERIFY_S# is used to validate a STAR number format.
*
****/
 
VERIFY_S#: PROC ALTRET;
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
    DCL L                              SBIN;
 
    I=0;
    J=0;
    K=0;
    L=0;
    DO WHILE(I<256 AND SUBSTR(MEBUF,I,1)~=' ');
        IF SUBSTR(MEBUF,I,1)='.' THEN
            K=K+1;
        ELSE IF SUBSTR(MEBUF,I,1)>='0' AND SUBSTR(MEBUF,I,1)<='9' THEN
            IF K=0 THEN
                J=J+1;
            ELSE
                L=L+1;
        ELSE
            ALTRETURN;
        I=I+1;
    END;
    IF I>1 AND I<9 AND J>0 AND J<3 AND K=1 AND L>0 AND L<6 THEN
        RETURN;
    IF I>0 AND I<7 AND J>0 AND J<7 AND K=0 AND L=0 THEN
        RETURN;
    ALTRETURN;
END;
 
%EJECT;
/****
*
*   UNPARSE extracts old commentary from ! cards and places it
*   in the SUB fields, but does not set the SUBOPT flags.
*
****/
 
UNPARSE: PROC;
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
 
    CALL INDEX1R(I,'#',SIBUF);
    I=I+1;
    IF I>80 THEN
        RETURN;
    CALL INDEX(J,' ',SIBUF,I);
    J=J-I;
    IF SUB.S#.C=SUBSTR(LV,0,9) THEN DO;
        SUB.S#.L=MINIMUM(J,9);
        SUB.S#.C=SUBSTR(SIBUF,I,J);
    END;
    J=I-2;
    CALL INDEX1R(I,' ',SIBUF,J);
    IF I>=J THEN
        RETURN;
    J=I;
    CALL INDEX1R(I,' ',SIBUF,J);
    IF I>=J THEN
        RETURN;
    I=I+1;
    J=J-I;
    IF SUB.SV.C=SUBSTR(LV,0,7) THEN DO;
        SUB.SV.L=MINIMUM(J,7);
        SUB.SV.C=SUBSTR(SIBUF,I,J);
    END;
    J=I-1;
    CALL INDEX1R(I,' ',SIBUF,J);
    IF I>=J THEN
        RETURN;
    I=I+1;
    J=J-I;
    IF SUB.AI.C=SUBSTR(LV,0,3) THEN DO;
        SUB.AI.L=MINIMUM(J,3);
        SUB.AI.C=SUBSTR(SIBUF,I,J);
    END;
    RETURN;
END;
 
%EJECT;
/****
*
*   COMMENT scans SIBUF and determines if it contains a comment or
*   patch text, ALTRETURNing if patch text is found.  Additionally,
*   if the parameter passed is TRUE, embedded comments are deleted.
*
****/
 
COMMENT: PROC(CLR) ALTRET;
    DCL CLR                            BIT(1);
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
    DCL CMT                            BIT(1);
 
    CLSQUOTE=0;
    CMTCHARS=0;
    PCHCHARS=0;
    CMT='1'B;
    IF SUBSTR(SIBUF,0,2)='C ' THEN
        RETURN;
    I=0;
    DO WHILE(I<256);
        IF SUBSTR(SIBUF,I,1)=' ' THEN
            I=I+1;
        ELSE IF SUBSTR(SIBUF,I,1)='"' THEN DO;
            IF I<255 THEN
                CALL INDEX(J,'"',SIBUF,I+1);
            ELSE
                J=256;
            IF CLR THEN
                IF J<256 THEN
                    CALL INSERT(SIBUF,I,J-I+1,' ');
                ELSE
                    CALL INSERT(SIBUF,I,256-I,' ');
            ELSE DO;
                CLSQUOTE=J;
                IF J<256 THEN DO;
                    CMTCHARS=CMTCHARS+J-I+1;
                    IF J<255 AND SUBSTR(SIBUF,J+1,1)=' ' THEN
                        CMTCHARS=CMTCHARS+1;
                END;
                ELSE
                    CMTCHARS=CMTCHARS+256-I;
            END;
            I=J+1;
        END;
        ELSE DO;
            CMT='0'B;
            J=I;
            DO WHILE(J<256 AND SUBSTR(SIBUF,J,1)~='"' AND
                SUBSTR(SIBUF,J,1)~=' ');
                IF SUBSTR(SIBUF,J,1)='''' THEN
                    IF J<255 THEN DO;
                        CALL INDEX(K,'''',SIBUF,J+1);
                        IF K>255 THEN
                            J=J+1;
                        ELSE
                            J=K;
                    END;
                    ELSE
                        J=256;
                J=J+1;
            END;
            IF J<256 AND SUBSTR(SIBUF,J,1)=' ' THEN
                PCHCHARS=PCHCHARS+J-I+1;
            ELSE
                PCHCHARS=PCHCHARS+J-I;
            I=J;
        END;
    END;
    IF CMT THEN
        RETURN;
    ALTRETURN;
END;
 
%EJECT;
/****
*
*   STOWCMT packs commentary into the memory pages, acquiring more
*   space as needed.  Room is left for only the STAR number
*   at the end of the comment.
*
****/
 
STOWCMT: PROC(BFR);
    DCL BFR                            CHAR(256);
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
 
    IF SUB.DF THEN DO;
        I=0;
        DO WHILE(I<256);
            CALL INDEX(I,'"',BFR,I);
            IF I<256 THEN
                CALL INSERT(BFR,I,1,' ');
        END;
        IF SUBSTR(BFR,0,2)~='C' THEN
            CALL INSERT(BFR,0,1,'"');
        IF NXTCOL~=0 THEN
            CALL GETSPACE;
        PCH=SUBSTR(BFR,0,78-SUB.S#.L);
        NXTCOL=80;
        CMTWRDS=CMTWRDS+2;
    END;
    ELSE DO;
        I=0;
        IF SUBSTR(BFR,0,2)='C' THEN
            I=2;
        DO WHILE(I<256);
            IF SUBSTR(BFR,I,1)=' ' THEN
                I=I+1;
            ELSE IF SUBSTR(BFR,I,1)='"' THEN DO;
                CALL INSERT(BFR,I,1,' ');
                CALL INDEX(J,'"',BFR,I);
                IF J<256 THEN
                    CALL INSERT(BFR,J,1,' ');
            END;
            ELSE DO;
                J=I;
                DO WHILE(J<256 AND SUBSTR(BFR,J,1)~='"' AND
                    SUBSTR(BFR,J,1)~=' ');
                    IF SUBSTR(BFR,J,1)='''' THEN
                        IF J<255 THEN DO;
                            CALL INDEX(K,'''',BFR,J+1);
                            IF K>255 THEN
                                J=J+1;
                            ELSE
                                J=K;
                        END;
                        ELSE
                            J=256;
                    J=J+1;
                END;
                IF J>=256 THEN DO;
                    J=255;
                    DO WHILE(SUBSTR(BFR,J,1)=' ');
                        J=J-1;
                    END;
                    J=J+1;
                END;
                IF J-I>76-SUB.S#.L THEN
                    J=I+76-SUB.S#.L;
                IF J-I>5 AND (SUBSTR(BFR,I,J-I)='REPQRY' OR
                    SUBSTR(BFR,I,J-I)='REMQRY') AND NXTCOL>0 THEN
                    NXTCOL=80;
                IF NXTCOL=0 THEN DO;
                    PCH='"';
                    NXTCOL=2;
                    CALL INSERT(PCH,80-SUB.S#.L,SUB.S#.L,SUB.S#.C);
                END;
                IF J-I>79-SUB.S#.L-NXTCOL THEN DO;
                    CALL GETSPACE;
                    PCH='"';
                    NXTCOL=2;
                    CALL INSERT(PCH,80-SUB.S#.L,SUB.S#.L,SUB.S#.C);
                END;
                CALL INSERT(PCH,NXTCOL,J-I,SUBSTR(BFR,I,J-I));
                CMTWRDS=CMTWRDS+1;
                NXTCOL=NXTCOL+J-I+1;
                I=J;
            END;
        END;
        IF SUBSTR(PCH,0,8)='C REPQRY' OR SUBSTR(PCH,0,7)='"REPQRY' OR
            SUBSTR(PCH,0,8)='C REMQRY' OR SUBSTR(PCH,0,7)='"REMQRY' THEN DO;
            IF SUBSTR(PCH,0,1)='C' THEN
                CALL INSERT(PCH,0,NXTCOL,'"',SUBSTR(PCH,2,NXTCOL-2));
            NXTCOL=80;
        END;
    END;
    RETURN;
END;
 
%EJECT;
/****
*
*   GETSPACE acquires an additional page of memory, if necessary,
*   and increments top pointers.  In either case, the next patch
*   "cell" is returned in NXTCELL and P and NXTCOL is reset.
*
****/
 
GETSPACE: PROC;
 
    NXTCELL=NXTCELL+1;
    P=PINCRC(P,256);
    IF NXTCELL>LSTCELL THEN DO;
        CALL M$GDP(FPT_GDP) ALTRET(OUCH);
        LSTCELL=LSTCELL+16;
    END;
    NXTCOL=0;
    RETURN;
 
OUCH:
    UNWIND TO I_GOT_PROBS;
END;
 
%EJECT;
/****
*
*   CVD converts SBIN WORD V to ASCII in CHAR(8) R and suppresses
*   leading zeros; SBIN WORD P is left pointing at the high-order
*   significant digit.
*
****/
 
CVD: PROC(V,R,P);
    DCL V                              SBIN;
    DCL R                              CHAR(8);
    DCL P                              SBIN;
 
    CALL BINCHAR(R,V);
    P=0;
    DO WHILE(P<7 AND SUBSTR(R,P,1)='0');
        P=P+1;
    END;
    RETURN;
END;
 
%EJECT;
/****
*
*   ECHO writes the contents of OUBUF on ME after converting the
*   EDIT key to printable ASCII.  If the user's terminal isn't wide
*   enough to print both the key and the patch, only the patch is
*   printed.
*
****/
 
ECHO: PROC;
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL DWORK                          CHAR(8);
 
    I=KEYBUF.C/1000;
    CALL CVD(I,DWORK,J);
    IF J>0 THEN
        CALL INSERT(DWORK,0,J,' ');
    MOBUF.INTG=SUBSTR(DWORK,3,5);
    I=MOD(KEYBUF.C,1000);
    CALL CVD(I,DWORK,J);
    MOBUF.FRAC=SUBSTR(DWORK,5,3);
    MOBUF.PTCH=OUBUF;
    CALL M$WRITE(WRITE_ME);
    RETURN;
END;
 
END;
