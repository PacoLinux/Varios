VERSION E05

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:1    
        1        1        /*M* XUR$GETCMD - COMMAND READING AND ERROR REPORTING ROUTINES */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
        8        8        /**/
        9        9        /*D*    NAME: XUR$GETCMD
       10       10                CALL: CALL XUR$GETCMD(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
       11       11                INPUT:   NODES - INPUT NODES FOR X$PARSE
       12       12                         OUT$ - CELL INTO WHICH P_PCB.OUT$ IS STORED OR ERROR
       13       13                                CODE IN CASE OF ALTRET.
       14       14                         PROMPT - VECTOR FRAMING PROMPT STRING OR TEXTC PROMPT
       15       15                                  STRING.  IF TEXTC PROMPT STRING THEN BIT 0
       16       16                                  OF THE LENGTH MAY BE SET TO INDICATE THE FIRST
       17       17                                  CHARACTER OF THE PROMPT STRING IS VFC.
       18       18                         TXT - TEXT STRING TO BE USED AS FIRST LINE OF INPUT TO
       19       19                               PARSER.  MAY BE USED IF IT IS DESIRED TO PARSE
       20       20                               JIT.CCBUF FOR EXAMPLE.  (OPTIONAL)
       21       21                         TSIZ - SIZE OF TXT IN CHARACTERS.  IF OMITTED USE P_PCB.NCHARS.
       22       22                         ROUTINE - EPTR TO ROUTINE TO BE CALLED FOR SUCCESS AND
       23       23                                   FAILURE NODES.  (OPTIONAL)
       24       24                DESCRIPTION:
       25       25                   This routine sets up the appropriate fields in the XUG$GETCMD
       26       26                structure and calls XUG$GETCMD. XUG$GETCMD calls the common
       27       27                code of XUG$GETCMD and CXG$GETCMD, XUG$COMMON, that does
       28       28                the actual work.
       29       29                The following are the important fields:
       30       30                  XUG_GETCMD.WORK$ - indicates that XUR$INIT has been called.
       31       31                                      If not, call XUR$INIT passing the constant
       32       32                                      XUG_INIT structure.
       33       33                  XUG_GETCMD.NODES$ - Set this to the ADDR(NODES).
       34       34                  XUG_GETCMD.PROMPT_ - Set this equal to PROMPT.
       35       35                  XUG_GETCMD.SFROUTINE$ - Set to ROUTINE if specified.
       36       36                  XUG_GETCMD.TEXT_      - If TXT is specified, use it for
       37       37                                          the the text.
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:2    
       38       38                                          If TSIZ is specified, use it for the
       39       39                                          the size of TXT, else use
       40       40                                          XUG_GETCMD.PCB$->P_PCB.NCHARS.
       41       41
       42       42                  Upon RETURN set OUT$ to XUG_GETCMD.OUT$.
       43       43                  Upon ALTRETURN set ERR to XUG_GETCMD.ERR#.
       44       44
       45       45                NOTE: The include file XUR_ENTRY contains ENTRY DCLs for all
       46       46                      the routines documented here for the XUR routines.
       47       47                NOTE: The include file XU_MACRO_C contains a macro, XUR_INIT,
       48       48                      which allows one to specify SYNTAX, as well as EPTR's for
       49       49                      routines for command abort (ABORT), command continue (CONTINUE),
       50       50                      special break message (BRKMSG), and/or a vector (WORK_) framing
       51       51                      a block of memory (even # of doublewords >= 500 words in size)
       52       52                      which XUR$GETCMD is to use for its parse control block, input
       53       53                      command buffer, and X$PARSE work area.  If break control is to be
       54       54                      given to XUR$BREAK, an ABORT EPTR *must* be specified.
       55       55                                                                           */
       56       56        /*D*    NAME: XUR$SETDCBS
       57       57                CALL: CALL XUR$SETDCBS(INDCB,OUTDCB,[ERROUTDCB],[ERRDCB])
       58       58                INPUT:   INDCB - DCB NUMBER OF INPUT DCB.
       59       59                         OUTDCB - DCB NUMBER OF OUTPUT DCB.
       60       60                         ERROUTDCB - DCB NUMBER OF THE OUTPUT DCB FOR XUR$ERRMSG
       61       61                                      TO OUTPUT THE ERRORS THROUGH.
       62       62                         ERRDCB - DCB NUMBER ON WHICH THE ERROR OCCURRED.
       63       63                                      THIS IS USED BY XUR$ERRMSG.
       64       64                DESCRIPTION:
       65       65                   This routine changes the input and output DCBs.  Either
       66       66                argument may be omitted if that DCB is not to be changed.
       67       67                If a given parameter is specified then the corresponding
       68       68                field will be changed:
       69       69                XUG_GETCMD.INDCB# = INDCB
       70       70                XUG_GETCMD.OUTDCB# = OUTDCB
       71       71                XUG_GETCMD.DCB_PARAM# = ERROUTDCB
       72       72                XUG_GETCMD.ERRDCB# = ERRDCB
       73       73                                                                           */
       74       74        /*D*    NAME: XUR$INIT
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:3    
       75       75                CALL: CALL XUR$INIT(XUR_INIT , P_PCB$ , PARAM$ ) ALTRET;
       76       76                INPUT:   XUR_INIT - THE STRUCTURE XUR_INIT TO INIT VARIOUS THINGS.
       77       77                OUTPUT:  P_PCB$ - PTR TO THE PARSE CONTROL BLOCK (OPTIONAL).
       78       78                          PARAM$ - PTR TO THE PARAMETER BLOCK.
       79       79                DESCRIPTION:
       80       80                    This routine may be called to initialize various aspects of XUR$GETCMD.
       81       81                EPTR's may be specified for ABORT, CONTINUE, and BRKMSG;  the SYNTAX
       82       82                flag may be set or reset;  the WORK_ vector may be used to require
       83       83                XUR$GETCMD to use a specific block of memory rather than acquiring a
       84       84                data segment for its own use; and the PCB$ pointer may be set to
       85       85                indicate that XUR$GETCMD is to use a user-provided parse control block
       86       86                in its calls to X$PARSE rather than constructing a PCB of its own in
       87       87                the work area.
       88       88                P_PCB$, if present, will receive the address of the PCB actually used
       89       89                (whether user-provided or built in the work area by XUR$INIT).
       90       90                PARAM$ will receive the PTR to the PARAM block (optional).
       91       91                An ABORT routine must be supplied if XUR$BREAK is used.
       92       92                XUR$INIT may be called more than once, if desired;  the settings of
       93       93                the ABORT, CONTINUE, and BRKMSG EPTR's and the SYNTAX flag will be
       94       94                updated on each call;  the PCB$ pointer will be honored on each call
       95       95                (whether NIL or non-NIL) and the P_PCB$ pointer, if present, will be
       96       96                set to the actual PCB address used.  The WORK_ vector will be honored
       97       97                only on the first call to XUR$INIT and only of XUR$INIT is called before
       98       98                the first call to XUR$GETCMD.  Other information (current error message,
       99       99                DCB identifies, etc.) will not be affected by calls to XUR$INIT.
      100      100                but the other information (ERRMSG,etc.) will be remembered.
      101      101                                                                           */
      102      102        /*D*    NAME: XUR$ERRPTR
      103      103                CALL: XUR$ERRPTR(CPOS,OUTDCB);
      104      104                INPUT:   CPOS - CHARACTER POSTITION AT WHICH ERROR OCCURED.
      105      105                                MOST LIKELY OBTAINED FROM P_PCB.HI_CHAR OR
      106      106                                OUT$BLK.CPOS.
      107      107                         OUTDCB - DCB TO OUTPUT THROUGH.
      108      108                DESCRIPTION:
      109      109                   XUR$ECHOIF is called with OUTDCB as the parameter.  Then,
      110      110                if CPOS is within the last line of the command a '^' is
      111      111                printed under the character at CPOS.  Otherwise fifteen characters
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:4    
      112      112                on either side of CPOS are printed through OUTDCB and a '^' is
      113      113                printed under the offending character.  The CPOS argument
      114      114                may be omitted in which case P_PCB.HI_CHAR is used.
      115      115                                                                           */
      116      116        /*D*    NAME: XUR$ECHO
      117      117                CALL: CALL XUR$ECHO(OUTDCB);
      118      118                INPUT:   OUTDCB - OUTPUT DCB NUMBER.
      119      119                DESCRIPTION:
      120      120                   Writes the last command through OUTDCB.
      121      121                                                                           */
      122      122        /*D*    NAME: XUR$ECHOIF
      123      123                CALL: CALL XUR$ECHOIF(OUTDCB);
      124      124                INPUT:   OUTDCB - DCB NUMBER OF OUTPUT DCB.
      125      125                DESCRIPTION:
      126      126                   If the last command has not already been written to
      127      127                the place to which OUTDCB is assigned the last command is
      128      128                written through OUTDCB.
      129      129                                                                           */
      130      130        /*D*    NAME: XUR$ECHOLAST
      131      131                CALL: CALL XUR$ECHOLAST(OUTDCB);
      132      132                INPUT:   OUTDCB - DCB TO OUTPUT THROUGH
      133      133                DESCRIPTION:
      134      134                   Echos the last input line through OUTDCB.
      135      135                                                                           */
      136      136        /*D*    NAME: XUR$CORRES
      137      137                CALL: XUR$CORRES(DCB1,DCB2) ALTRET;
      138      138                INPUT:   DCB1 AND DCB2 ARE DCB NUMBERS.
      139      139                DESCRIPTION:
      140      140                   A default open is done on the DCBs if they are not open
      141      141                and the ALTRETURN is taken if the assignments of the DCBs
      142      142                correspond.
      143      143                                                                           */
      144      144        /*D*    NAME: XUR$BREAK
      145      145                CALL: ASYNC ENTRY ON BREAK
      146      146                DESCRIPTION:
      147      147                   XUR$BREAK is a generalized break handler for programs that
      148      148                use XUR$GETCMD.  When XUR$BREAK is entered the user routine
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:5    
      149      149                pointed to by XUR_BRKMSG is called if it is not NIL,  otherwise
      150      150                the message "Break!  C to continue" is output.  (Breaks are
      151      151                ignored from the time XUR$BREAK is entered until it exits.)
      152      152                Then input is read through M$UC.  A null input will cause the
      153      153                current command to be aborted.  The single character 'C' or 'c'
      154      154                will cause the current command to be continued.  Any other
      155      155                input will be parsed as a new command on the next call to
      156      156                XUR$GETCMD.
      157      157
      158      158                If it is desireable to exit from the BREAK process without printing
      159      159                the "Break!  C to continue" message and inputing a response, the user
      160      160                of XUR$BREAK may opt to "bail out" from his BRKMSG routine by issuing
      161      161                a call to X66_TRTN;  this call will release the auto frame(s) for
      162      162                XUR$BREAK and the BRKMSG routine, and will then return control to the
      163      163                interrupted code with breaks disabled (a la XUR$DISABLE).  If it is
      164      164                desirable to continue at the point of interruption with breaks enabled,
      165      165                XUR$CLRENABLE should be called before X66_TRTN.
      166      166
      167      167                XUR$BREAK is to be establised as the break routine by the user
      168      168                with an M$INT call.  The routine pointed to by XUR_ABORT is
      169      169                called to abort the current command after doing an M$CLRSTK.
      170      170                This routine must be present and should not return.  An optional
      171      171                routine pointed to by XUR_CONTINUE is called to continue
      172      172                commands.  If this routine returns or is not present an M$TRTN
      173      173                will be executed.
      174      174
      175      175                Breaks are ignored if input while reading a command.
      176      176                                                                           */
      177      177        /*D*    NAME: XUR$DISABLE
      178      178                CALL: CALL XUR$DISABLE
      179      179                DESCRIPTION:
      180      180                   Disables breaks for critical code.  Calls to XUR$DISABLE
      181      181                may be nested.
      182      182                                                                           */
      183      183        /*D*    NAME: XUR$ENABLE
      184      184                CALL: CALL XUR$ENABLE
      185      185                DESCRIPTION:
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:6    
      186      186                   Counterpart to XUR$DISABLE.  If a break occured during
      187      187                disabled execution,  it will be processed at enable time.
      188      188                                                                           */
      189      189        /*D*    NAME: XUR$CLRENABLE
      190      190                CALL: CALL XUR$CLRENABLE
      191      191                DESCRIPTION:
      192      192                   Just like XUR$ENABLE except any breaks that occured while
      193      193                disabled will be ignored.
      194      194                                                                           */
      195      195        /*D*    NAME: XUR$ERRMSG
      196      196                CALL: CALL XUR$ERRMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      197      197                INPUT:   CODE - ERROR CODE.  (OPTIONAL.  IF THIS ARGUMENT
      198      198                                IS OMITTED THE SEVERITY FIELD OF THE LAST
      199      199                                CODE IS INCREMENTED.  IN THIS CASE THE
      200      200                                ALTRETURN IS TAKEN IF THE SEVERITY FIELD
      201      201                                EXCEEDS 7 OR NO MESSAGE IS FOUND.)
      202      202                         DCB# - DCB ON WHICH ERROR OCCURED. (OPTIONAL)
      203      203                         OUTDCB - DCB THAT ERROR MESSEAGE IS TO BE WRITTEN
      204      204                                  THROUGH.  (OPTIONAL.  DEFAULT IS M$DO.)
      205      205                         F1 - VECTOR FRAMING TEXTC TO BE USED FOR %U1 SUBSTITUTION.
      206      206                         F2 - VECTOR FRAMING TEXTC TO BE USED FOR %U2 SUBSTITUTION.
      207      207                         F3 - VECTOR FRAMING TEXTC TO BE USED FOR %U3 SUBSTITUTION.
      208      208                         FLGLEV - Number of asterisks to print in front of the
      209      209                                  message (0-4).  Default is 0.
      210      210                         F1, F2, F3 AND FLGLEV ARE OPTIONAL.
      211      211                DESCRIPTION:
      212      212                   A call is made to M$ERRMSG using the parameters passed by
      213      213                the caller.
      214      214                                                                           */
      215      215        /*D*    NAME: XUR$INFOMSG
      216      216                CALL: CALL XUR$INFOMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      217      217                DESCRIPTION:
      218      218                   Identical to XUR$ERRMSG, except that the error code is not
      219      219                saved for subseqent internal use.  Intended for one-level
      220      220                informational messages.
      221      221                                                                           */
      222      222        /*D*    NAME: XUR$SETERRMSG
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:7    
      223      223                CALL: CALL XUR$SETERRMSG(FID) ALTRET;
      224      224                INPUT:   FID - TEXTC FID OF ERROR MESSAGE FILE TO BE USED
      225      225                               ON SUBSEQUENT CALLS TO XUR$ERRMSG.
      226      226                DESCRIPTION:
      227      227                   If the FID argument is passed then M$FID is called to
      228      228                obtain the name, account and password of the error message
      229      229                file to be used on subsequent calls to XUR$ERRMSG.  If the
      230      230                FID argument is omitted then the M$ERRMSG default file will
      231      231                be used.  If the altreturn is taken then M$FID altreted and
      232      232                the error code may be found in the altret frame.
      233      233                                                                           */
      234      234        /*D*    NAME: XUR$HELP
      235      235                CALL: CALL XUR$HELP(XUH_PARAM) ALTRET;
      236      236                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      237      237                DESCRIPTION:
      238      238                   This routine calls X$HELP.  The purpose of XUR$HELP is
      239      239                to keep track of whether the last message operation was
      240      240                M$ERRMSG or M$HELP.  If X$HELP altreturns then XUR$HELP
      241      241                will call XUR$ERRMSG with the error code in XUH_PARAM and
      242      242                then altreturn.  Otherwise the normal return will be taken.
      243      243                                                                           */
      244      244        /*D*    NAME: XUR$MOREMSG
      245      245                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      246      246                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      247      247                DESCRIPTION:
      248      248                   XUR$ERRMSG or X$HELP is called to get the next level of
      249      249                messages.  Trust me.  The altreturn is taken if no messages
      250      250                are available.
      251      251                                                                           */
      252      252        /*D*    NAME: XUR$ALLMSG
      253      253                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      254      254                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      255      255                DESCRIPTION:
      256      256                   XUR$ERRMSG or X$HELP is called to get all remaining
      257      257                messages.  Trust me.  The altreturn is taken if no messages
      258      258                are available.
      259      259                                                                           */
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:8    
      260      260        /*D*    NAME: XUR$FINDDCB
      261      261                CALL: CALL XUR$FINDDCB(DCBNAME,DCB#) ALTRET;
      262      262                INPUT:   DCBNAME - TEXTC DCB NAME
      263      263                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      264      264                DESCRIPTION:
      265      265                   Searches DCB table for DCB specified by DCBNAME.  If it
      266      266                is found, DCB number is returned in DCB#.  If not present
      267      267                the altreturn will be taken.
      268      268                                                                           */
      269      269        /*D*    NAME: XUR$GETDCB
      270      270                CALL: CALL XUR$GETDCB(DCBNAME,DCB#) ALTRET;
      271      271                INPUT:   DCBNAME - TEXTC DCB NAME
      272      272                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      273      273                DESCRIPTION:
      274      274                   Searches DCB table for DCB specified by DCBNAME.  If it
      275      275                is found, DCB number is returned in DCB#.  If not present
      276      276                M$GETDCB will be called to get it.  If M$GETDCB altreturns
      277      277                then XUR$GETDCB will altreturn and the error code may be
      278      278                found in the altret frame.
      279      279                                                                           */
      280      280        /*D*    NAME: XUR$CLOSE_DCBS;
      281      281                CALL: CALL XUR$CLOSE_DCBS;
      282      282                DESCRIPTION:
      283      283                   Closes all open dcbs with SAVE.
      284      284                                                                           */
      285      285        /*D*     NAME: XUR$ERRCNVRT
      286      286                 CALL: CALL XUR$ERRCNVRT (LCP6_ERROR_CODE, ERROR_CODE);
      287      287                 INPUT: LCP6_ERROR_CODE - an LCP-6 error code (fcg/mid/m/err/sev) as
      288      288                       passed through the coupler.
      289      289                 OUTPUT: ERROR_CODE - error code converted to CP-6 standard format.
      290      290                 DESCRIPTION: This routine will convert an LCP-6 error code (32 bits,
      291      291                             stored in 36 bits with the high-order bit in each byte
      292      292                             being zero) into the equivalent CP-6 standard error code
      293      293                             format (36 bits).
      294      294        */
      295      295
      296      296        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:9    
      297      297        XUR$GETCMD: PROC(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
      298      298        /**/
      299      299        %INCLUDE CP_6 ;
      300     5858    1   DCL NODES SBIN;
      301     5859    1   DCL 1 VECBASE BASED,                    /* USED AS REDEF OF NODES */
      302     5860    1         2 BOUND UBIN(20) UNAL,
      303     5861    1         2 FLAGS BIT(16),
      304     5862    1         2 P$ PTR;
      305     5863    1   DCL OUT$ PTR;
      306     5864        %VLP_ERRCODE (FPTN=ERR, STCLASS="REDEF OUT$") ;
      307     5909    1   DCL PROMPT VECTOR PARAM ;
      308     5910    1   DCL TXT CHAR(CSIZE);
      309     5911    1   DCL TSIZ SBIN;
      310     5912    1   DCL ROUTINE EPTR;
      311     5913        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:10   
      312     5914    1   DCL XUG$ERRPTR ENTRY(1) ALTRET ;
      313     5915    1   DCL XUG$ERRMSG ENTRY(1) ALTRET ;
      314     5916    1   DCL XUG$INIT ENTRY(2) ALTRET ;
      315     5917    1   DCL XUG$ECHOIF ENTRY(1) ALTRET ;
      316     5918    1   DCL XUG$ECHO ENTRY(1) ALTRET ;
      317     5919    1   DCL XUG$GETCMD ENTRY(1) ALTRET ;
      318     5920        /**/
      319     5921        %INCLUDE XU_MACRO_C;
      320     9027        %INCLUDE XUH_MACRO_C ;
      321     9111        %INCLUDE XU_PERR_C;
      322     9302        %P_PCB (STCLASS=BASED);
      323     9501        /*    CP_6 included above. */
      324     9502        %INCLUDE CP_6_SUBS;
      325    10042        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:11   
      326    10043        /*
      327    10044        */
      328    10045    1   DCL GDSVEC VECTOR STATIC SYMDEF DALIGNED INIT(VECTOR(NIL)) ;
      329    10046
      330    10047        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:12   
      331    10048        %XUG_PARAMS (NAME=XUG, STCLASS=BASED) ;
      332    10492        %XUG_GETCMD (NAME=GETCMD, STCLASS="STATIC SYMDEF") ;
      333    10830        %XUG_INIT (NAME=XUG_INIT, STCLASS=AUTO) ;
      334    11243        %XUG_INIT (NAME=XUG_INIT_C, STCLASS=SYMREF) ;
      335    11656        %XUR_INIT (STCLASS="BASED(XUR_INIT$)");
      336    11755        %XUR_INIT (NAME = XUR_INIT_C, STCLASS="CONSTANT SYMDEF") ;
      337    11854        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:13   
      338    11855    1   DCL XUR_INIT$ PTR ;
      339    11856    1   DCL CSIZE SBIN;
      340    11857    1   DCL PR$ PTR;
      341    11858    1   DCL PSIZ UBIN WORD ;
      342    11859    1   DCL 1 PROMPTC CALIGNED BASED(PR$),
      343    11860    1         2 B1,
      344    11861    1           3 VFC BIT(1) UNAL,
      345    11862    1           3 L UBIN(8) UNAL,
      346    11863    1         2 C CHAR(PSIZ);
      347    11864        /*
      348    11865        */
      349    11866    1   DCL P$ PTR BASED;
      350    11867        %B$TCB (STCLASS="BASED(B$TCB$)") ;
      351    11870        %B$ALT;
      352    11878    1   DCL B$TCB$ PTR SYMREF;
      353    11879    1   DCL OPT$DCB# UBIN WORD BASED ;
      354    11880        %VLP_ERRCODE (FPTN=ERR$CODE, STCLASS=BASED) ;
      355    11925        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:14   
      356    11926    1   GETCMD:
      357    11927    1       IF GETCMD.WORK$ = ADDR(NIL)
      358    11928    1       THEN
      359    11929    1           CALL XUR$INIT (XUR_INIT_C) ALTRET(MALT) ;
      360    11930    1       GETCMD.NODES$ = ADDR(NODES) ;
      361    11931    1       PR$=ADDR(PROMPT) ;
      362    11932    2       IF PR$~=ADDR(NIL) THEN DO;
      363    11933    3           IF VBOUND(PROMPT) > 94 THEN DO; /* MUST BE TEXTC PROMPT */
      364    11934    3               IF PROMPTC.B1.VFC
      365    11935    3               THEN
      366    11936    3                   GETCMD.PROMPT_VFC# = '1'B ;
      367    11937    3               PSIZ = PROMPTC.B1.L ;
      368    11938    3               GETCMD.PROMPT_=VECTOR(PROMPTC.C);
      369    11939    3           END ;                     /* Then Do */
      370    11940    2           ELSE
      371    11941    2               GETCMD.PROMPT_ = PROMPT ;
      372    11942    2       END ;                        /* Then Do */
      373    11943    1       ELSE
      374    11944    1           GETCMD.PROMPT_ = VECTOR(ERASE) ;
      375    11945    1       IF ADDR(ROUTINE)=ADDR(NIL) THEN GETCMD.SFROUTINE$=ENTADDR(NIL);
      376    11946    1       ELSE GETCMD.SFROUTINE$=ROUTINE;
      377    11947    1       IF ADDR(TXT)=ADDR(NIL)
      378    11948    1       THEN GETCMD.TEXT_ = VECTOR(NIL) ;
      379    11949    2       ELSE DO;
      380    11950    2           IF ADDR(TSIZ)=ADDR(NIL) THEN CSIZE=GETCMD.PCB$->P_PCB.NCHARS;
      381    11951    2           ELSE CSIZE=TSIZ;
      382    11952    2           IF CSIZE = 0
      383    11953    2           THEN
      384    11954    2               GETCMD.TEXT_ = VECTOR(ERASE);
      385    11955    2           ELSE
      386    11956    2               GETCMD.TEXT_ = VECTOR(TXT);
      387    11957    2       END ;                        /* Else Do */
      388    11958    1       CALL XUG$GETCMD (GETCMD) ALTRET(GETCMD_ALT) ;
      389    11959    1       OUT$=GETCMD.OUT$;
      390    11960    1       RETURN;
      391    11961    1   GETCMD_ALT: ERR=GETCMD.ERR#;
      392    11962    1       CALL XUR$XUGERR2XUR (ERR) ;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:15   
      393    11963    1       ALTRETURN;
      394    11964    1   MALT: ERR=B$TCB.ALT$->B$ALT.ERR;
      395    11965    1       ALTRETURN ;
      396    11966        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:16   
      397    11967    1   XUR$ERRPTR: ENTRY(NODES,OUT$) ALTRET;
      398    11968        /**/
      399    11969    1       IF GETCMD.WORK$ = ADDR(NIL)
      400    11970    1       THEN
      401    11971    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);
      402    11972    1       IF ADDR(NODES) ~= ADDR(NIL)
      403    11973    1       THEN
      404    11974    2       DO ;
      405    11975    2           GETCMD.EPOS# = NODES ;
      406    11976    2           GETCMD.USE_EPOS# = %YES# ;
      407    11977    2       END ;                        /* Then Do */
      408    11978    1       ELSE GETCMD.USE_EPOS# = %NO# ;
      409    11979    1       IF ADDR(ERR) ~= ADDR(NIL)
      410    11980    1       THEN
      411    11981    1           GETCMD.DCB_PARAM# = BITBIN(ERR) ;
      412    11982    1       ELSE
      413    11983    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;
      414    11984    1       CALL XUG$ERRPTR(GETCMD) ;
      415    11985    1       RETURN ;
      416    11986        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:17   
      417    11987    1   XUR$ECHOIF: ENTRY(NODES) ALTRET;
      418    11988    1       IF GETCMD.WORK$ = ADDR(NIL)
      419    11989    1       THEN
      420    11990    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);
      421    11991    1       IF ADDR(NODES) ~= ADDR(NIL)
      422    11992    1       THEN
      423    11993    1           GETCMD.DCB_PARAM# = NODES ;
      424    11994    1       ELSE
      425    11995    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;
      426    11996    1       CALL XUG$ECHOIF (GETCMD) ;
      427    11997    1       RETURN;
      428    11998        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:18   
      429    11999    1   XUR$ECHO: ENTRY(NODES) ALTRET;
      430    12000    1       IF GETCMD.WORK$ = ADDR(NIL)
      431    12001    1       THEN
      432    12002    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);
      433    12003    1       IF ADDR(NODES) ~= ADDR(NIL)
      434    12004    1       THEN
      435    12005    1           GETCMD.DCB_PARAM# = NODES ;
      436    12006    1       ELSE
      437    12007    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;
      438    12008    1       CALL XUG$ECHO (GETCMD) ;
      439    12009    1       RETURN;
      440    12010        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:19   
      441    12011    1   XUR$SETDCBS: ENTRY(NODES,OUT$,PROMPT, TXT) ALTRET;
      442    12012    1       IF GETCMD.WORK$ = ADDR(NIL)
      443    12013    1       THEN
      444    12014    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);
      445    12015    1       IF ADDR(NODES)~=ADDR(NIL)
      446    12016    1       THEN GETCMD.INDCB# = NODES ;
      447    12017    1       IF ADDR(OUT$)~=ADDR(NIL)
      448    12018    1       THEN GETCMD.OUTDCB# = BITBIN(ERR);
      449    12019    1       IF ADDR(PROMPT) ~= ADDR(NIL)
      450    12020    1       THEN
      451    12021    1           GETCMD.DCB_PARAM# = ADDR(PROMPT)->OPT$DCB# ;
      452    12022    1       IF ADDR(TXT) ~= ADDR(NIL)
      453    12023    1       THEN
      454    12024    1           GETCMD.ERRDCB# = ADDR(TXT)->OPT$DCB# ;
      455    12025    1       RETURN;
      456    12026        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:20   
      457    12027    1   XUR$INIT: ENTRY (NODES , OUT$ , PROMPT) ALTRET;
      458    12028    1       XUR_INIT$ = ADDR (NODES);
      459    12029    1       XUG_INIT = XUG_INIT_C ;
      460    12030    1       XUG_INIT.WORK_ = XUR_INIT.WORKR_ ;
      461    12031    1       XUG_INIT.SYNTAX# = XUR_INIT.SYNTAX# ;
      462    12032    1       XUG_INIT.PREPROCESS# = XUR_INIT.PREPROCESS#;
      463    12033    1       XUG_INIT.COMMANDS# = XUR_INIT.COMMANDS#;
      464    12034    1       XUG_INIT.INHIBITS = XUR_INIT.INHIBITS;
      465    12035    1       XUG_INIT.GOODCMD# = XUR_INIT.GOODCMD#;
      466    12036    1       XUG_INIT.SPELLING# = XUR_INIT.SPELLING#;
      467    12037    1       XUG_INIT.DONT_REREAD_CCBUF# = XUR_INIT.DONT_REREAD_CCBUF#;
      468    12038    1       XUG_INIT.DONT_STRIP_PROMPT# = XUR_INIT.DONT_STRIP_PROMPT#;
      469    12039    1       XUG_INIT.ECHO# = XUR_INIT.ECHO#;
      470    12040    1       XUG_INIT.PASS# = XUR_INIT.PASS# ;
      471    12041    1       XUG_INIT.ABORT$ = XUR_INIT.ABORT$;
      472    12042    1       XUG_INIT.CONTINUE$ = XUR_INIT.CONTINUE$;
      473    12043    1       XUG_INIT.BRKMSG$ = XUR_INIT.BRKMSG$;
      474    12044    1       XUG_INIT.PRE_EXEC$$ = XUR_INIT.PRE_EXEC$$;
      475    12045    1       XUG_INIT.POST_EXEC$$ = XUR_INIT.POST_EXEC$$;
      476    12046    1       XUG_INIT.PREPROCESSOR$$ = XUR_INIT.PREPROCESSOR$$;
      477    12047    1       XUG_INIT.ADAPT$$ = XUR_INIT.ADAPT$$;
      478    12048    1       XUG_INIT.MOREMEM$$ = XUR_INIT.MOREMEM$$;
      479    12049    1       XUG_INIT.PPCB$ = XUR_INIT.PPCB$;
      480    12050    1       XUG_INIT.PP_DCB# = XUR_INIT.PP_DCB#;
      481    12051    1       XUG_INIT.PCB$ = XUR_INIT.PCB$ ;
      482    12052    1       XUG_INIT.PROCACCT_ = XUR_INIT.PROCACCT_ ;
      483    12053    1       XUG_INIT.PROCNAME_ = XUR_INIT.PROCNAME_ ;
      484    12054    1       CALL XUG$INIT (GETCMD, XUG_INIT) WHENALTRETURN
      485    12055    2       DO ;
      486    12056    2           CALL XUR$XUGERR2XUR (GETCMD.ERR#) ;
      487    12057    2           GETCMD.ERR_CODE = GETCMD.ERR# ;
      488    12058    2           CALL XUG$ERRMSG (GETCMD) ALTRET(MALT) ;
      489    12059    2           ALTRETURN ;
      490    12060    2       END ;                        /* Whenaltreturn Do */
      491    12061    1       IF ADDR(OUT$) ~= ADDR(NIL)
      492    12062    1       THEN
      493    12063    1           OUT$ = GETCMD.PCB$ ;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:21   
      494    12064    1       IF ADDR(PROMPT) ~= ADDR(NIL)
      495    12065    1       THEN
      496    12066    1           ADDR(PROMPT) -> P$ = ADDR(GETCMD) ;
      497    12067    1       GDSVEC = GETCMD.WORK$ -> XUG.GDSVEC ;
      498    12068    1       RETURN;
      499    12069        /**/
      500    12070        %EJECT ;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:22   
      501    12071    1   XUR$XUGERR2XUR: ENTRY(NODES) ALTRET;
      502    12072
      503    12073    1       PR$ = ADDR(NODES) ;
      504    12074    1       IF PR$->ERR$CODE.FCG = '3025'O AND PR$->ERR$CODE.MID = '07'O
      505    12075    1       THEN
      506    12076    2       DO ;
      507    12077    2           PR$->ERR$CODE.MID = '22'O ;
      508    12078    3           DO SELECT(PR$->ERR$CODE.ERR#) ;
      509    12079
      510    12080    3               SELECT(%E$SYNERR) ;
      511    12081
      512    12082        /*E*  ERROR:   XUR-E$SYNERR
      513    12083                MESSAGE: Your command was not processed because it contains something
      514    12084                         unexpected (a mis-spelled word, incorrect punctuation, or some
      515    12085                         other input which does not match this program's requirements).
      516    12086                         You may obtain a brief description of the expected input by
      517    12087                         entering as much of the command as you are sure of, followed
      518    12088                         by a single "?".
      519    12089        */
      520    12090    3               SELECT(%E$XUG#SMALLWORK) ;
      521    12091    3               PR$->ERR$CODE.ERR# = %E$XUR#SMALLWORK ;
      522    12092
      523    12093        /*E*  ERROR:   XUR-E$XUR#SMALLWORK
      524    12094              MESSAGE0: Work area too small for XUR$INIT to initialize.  Unable
      525    12095                        to continue.
      526    12096        */
      527    12097    3               SELECT(%E$XUG#NOTCONTIGAREA) ;
      528    12098    3               PR$->ERR$CODE.ERR# = %E$XUR#NOTCONTIGAREA ;
      529    12099
      530    12100        /*E*  ERROR:   XUR-E$XUR#NOTCONTIGAREA
      531    12101              MESSAGE: Not a contiguous work area.
      532    12102              MESSAGE1: The data expansion received from the user program is
      533    12103                          not contiguous with the present work area.
      534    12104        */
      535    12105    3               SELECT(%E$XUG#AREANOTRTSZ) ;
      536    12106    3               PR$->ERR$CODE.ERR# = %E$XUR#AREANOTRTSZ ;
      537    12107
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:23   
      538    12108        /*E*  ERROR:   XUR-E$XUR#AREANOTRTSZ
      539    12109              MESSAGE: Data area not the right size.
      540    12110              MESSAGE1: The data expansion received from the user program is
      541    12111                          not the amount that XUR$GETCMD requested.
      542    12112        */
      543    12113    3               SELECT(%E$XUG#BDIRFID) ;
      544    12114    3               PR$->ERR$CODE.ERR# = %E$XUR#BDIRFID ;
      545    12115
      546    12116        /*E*  ERROR:   XUR-E$XUR#BDIRFID
      547    12117              MESSAGE0: FID may only consist of DP#SN.ACCOUNT or .ACCOUNT.
      548    12118        */
      549    12119    3               SELECT(%E$XUG#DOCMD2BIG) ;
      550    12120    3               PR$->ERR$CODE.ERR# = %E$XUR#DOCMD2BIG ;
      551    12121
      552    12122        /*E*  ERROR:   XUR-E$XUR#DOCMD2BIG
      553    12123              MESSAGE0: DO command too big.
      554    12124              MESSAGE1: The DO command can be at most 256 characters long.
      555    12125        */
      556    12126    3               SELECT(%E$XUG#BIG4CHAR) ;
      557    12127    3               PR$->ERR$CODE.ERR# = %E$XUR#BIG4CHAR ;
      558    12128
      559    12129        /*E*  ERROR:   XUR-E$XUR#BIG4CHAR
      560    12130              MESSAGE0: Only four or less characters allowed.
      561    12131        */
      562    12132    3               SELECT(%E$XUG#NO_MORE) ;
      563    12133    3               PR$->ERR$CODE.ERR# = %E$XUR#NO_MORE ;
      564    12134
      565    12135        /*E*  ERROR:   XUR-E$XUR#NO_MORE
      566    12136              MESSAGE: No messages available.
      567    12137              MESSAGE1: Th Th Th That's all fffolks!
      568    12138        */
      569    12139    3               SELECT(%E$XUG#NWALIGNED) ;
      570    12140    3               PR$->ERR$CODE.ERR# = %E$XUR#NWALIGNED ;
      571    12141
      572    12142        /*E*  ERROR:   XUR-E$XUR#NWALIGNED
      573    12143              MESSAGE: Work area is not WORD ALIGNED and XUR$INIT can not continue.
      574    12144                        Initialization aborted.
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:24   
      575    12145        */
      576    12146    3               SELECT(%E$XUG#NO_ADAPT) ;
      577    12147    3               PR$->ERR$CODE.ERR# = %E$XUR#NO_ADAPT ;
      578    12148
      579    12149        /*E*  ERROR:   XUR-E$XUR#NO_ADAPT
      580    12150              MESSAGE: The ADAPT dialog manager is not available.
      581    12151              MESSAGE1: The ENTER command cannot be used because the Alternate Shared
      582    12152                        Library (ADAPT_ASL) for the dialog manager is not installed.
      583    12153        */
      584    12154    3           END ;                       /* Do Select */
      585    12155    2       END ;                        /* Then Do */
      586    12156        /**/
      587    12157    1       RETURN ;
      588    12158        /**/
      589    12159    1   END XUR$GETCMD;
      590    12160        %EOD;

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:25   
--  Include file information  --

   CP_6_SUBS.:E05TOU  is referenced.
   XU_PERR_C.:E05TOU  is referenced.
   XUH_MACRO_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
   CP_6_C.:E05TOU  is referenced.
   CP_6.:E05TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure XUR$GETCMD.

   Procedure XUR$GETCMD requires 435 words for executable code.
   Procedure XUR$GETCMD requires 52 words of local(AUTO) storage.

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:26   

 Object Unit name= XUR$GETCMD                                 File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:42:22.52 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   DCB   even  none     0      0  M$UC
    1   Data  even  none    44     54  XUR$GETCMD
    2  RoData even  UTS     40     50  XUR$GETCMD
    3   Proc  even  none   435    663  XUR$GETCMD
    4  RoData even  none     9     11  XUR$GETCMD

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     3      0   yes    yes     yes      Std        6  XUR$GETCMD
     3    144          yes     yes      Std        2  XUR$ERRPTR
     3    205          yes     yes      Std        1  XUR$ECHOIF
     3    233          yes     yes      Std        1  XUR$ECHO
     3    261          yes     yes      Std        4  XUR$SETDCBS
     3    323          yes     yes      Std        3  XUR$INIT
     3    507          yes     yes      Std        1  XUR$XUGERR2XUR

  ****  Data defs  ****

 Sect OctLoc  Name                           Sect OctLoc  Name
    1      0  GDSVEC                             1      2  GETCMD
    2      0  XUR_INIT_C
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:27   

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XTX$ADAPT
 yes     yes           Std       1 XUG$ECHOIF
 yes     yes           Std       1 XUG$GETCMD
 yes     yes           Std       1 XUG$ERRPTR
 yes     yes           Std       1 XUG$ECHO
 yes     yes           Std       1 XUG$ERRMSG
 yes     yes           Std       2 XUG$INIT
                       nStd      0 X66_AUTO_N
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     M$UC                                  XUG_INIT_C                            B$TCB$
     B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     NULLSID                               ISSID
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:28   


        1        1        /*M* XUR$GETCMD - COMMAND READING AND ERROR REPORTING ROUTINES */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
        8        8        /**/
        9        9        /*D*    NAME: XUR$GETCMD
       10       10                CALL: CALL XUR$GETCMD(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
       11       11                INPUT:   NODES - INPUT NODES FOR X$PARSE
       12       12                         OUT$ - CELL INTO WHICH P_PCB.OUT$ IS STORED OR ERROR
       13       13                                CODE IN CASE OF ALTRET.
       14       14                         PROMPT - VECTOR FRAMING PROMPT STRING OR TEXTC PROMPT
       15       15                                  STRING.  IF TEXTC PROMPT STRING THEN BIT 0
       16       16                                  OF THE LENGTH MAY BE SET TO INDICATE THE FIRST
       17       17                                  CHARACTER OF THE PROMPT STRING IS VFC.
       18       18                         TXT - TEXT STRING TO BE USED AS FIRST LINE OF INPUT TO
       19       19                               PARSER.  MAY BE USED IF IT IS DESIRED TO PARSE
       20       20                               JIT.CCBUF FOR EXAMPLE.  (OPTIONAL)
       21       21                         TSIZ - SIZE OF TXT IN CHARACTERS.  IF OMITTED USE P_PCB.NCHARS.
       22       22                         ROUTINE - EPTR TO ROUTINE TO BE CALLED FOR SUCCESS AND
       23       23                                   FAILURE NODES.  (OPTIONAL)
       24       24                DESCRIPTION:
       25       25                   This routine sets up the appropriate fields in the XUG$GETCMD
       26       26                structure and calls XUG$GETCMD. XUG$GETCMD calls the common
       27       27                code of XUG$GETCMD and CXG$GETCMD, XUG$COMMON, that does
       28       28                the actual work.
       29       29                The following are the important fields:
       30       30                  XUG_GETCMD.WORK$ - indicates that XUR$INIT has been called.
       31       31                                      If not, call XUR$INIT passing the constant
       32       32                                      XUG_INIT structure.
       33       33                  XUG_GETCMD.NODES$ - Set this to the ADDR(NODES).
       34       34                  XUG_GETCMD.PROMPT_ - Set this equal to PROMPT.
       35       35                  XUG_GETCMD.SFROUTINE$ - Set to ROUTINE if specified.
       36       36                  XUG_GETCMD.TEXT_      - If TXT is specified, use it for
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:29   
       37       37                                          the the text.
       38       38                                          If TSIZ is specified, use it for the
       39       39                                          the size of TXT, else use
       40       40                                          XUG_GETCMD.PCB$->P_PCB.NCHARS.
       41       41
       42       42                  Upon RETURN set OUT$ to XUG_GETCMD.OUT$.
       43       43                  Upon ALTRETURN set ERR to XUG_GETCMD.ERR#.
       44       44
       45       45                NOTE: The include file XUR_ENTRY contains ENTRY DCLs for all
       46       46                      the routines documented here for the XUR routines.
       47       47                NOTE: The include file XU_MACRO_C contains a macro, XUR_INIT,
       48       48                      which allows one to specify SYNTAX, as well as EPTR's for
       49       49                      routines for command abort (ABORT), command continue (CONTINUE),
       50       50                      special break message (BRKMSG), and/or a vector (WORK_) framing
       51       51                      a block of memory (even # of doublewords >= 500 words in size)
       52       52                      which XUR$GETCMD is to use for its parse control block, input
       53       53                      command buffer, and X$PARSE work area.  If break control is to be
       54       54                      given to XUR$BREAK, an ABORT EPTR *must* be specified.
       55       55                                                                           */
       56       56        /*D*    NAME: XUR$SETDCBS
       57       57                CALL: CALL XUR$SETDCBS(INDCB,OUTDCB,[ERROUTDCB],[ERRDCB])
       58       58                INPUT:   INDCB - DCB NUMBER OF INPUT DCB.
       59       59                         OUTDCB - DCB NUMBER OF OUTPUT DCB.
       60       60                         ERROUTDCB - DCB NUMBER OF THE OUTPUT DCB FOR XUR$ERRMSG
       61       61                                      TO OUTPUT THE ERRORS THROUGH.
       62       62                         ERRDCB - DCB NUMBER ON WHICH THE ERROR OCCURRED.
       63       63                                      THIS IS USED BY XUR$ERRMSG.
       64       64                DESCRIPTION:
       65       65                   This routine changes the input and output DCBs.  Either
       66       66                argument may be omitted if that DCB is not to be changed.
       67       67                If a given parameter is specified then the corresponding
       68       68                field will be changed:
       69       69                XUG_GETCMD.INDCB# = INDCB
       70       70                XUG_GETCMD.OUTDCB# = OUTDCB
       71       71                XUG_GETCMD.DCB_PARAM# = ERROUTDCB
       72       72                XUG_GETCMD.ERRDCB# = ERRDCB
       73       73                                                                           */
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:30   
       74       74        /*D*    NAME: XUR$INIT
       75       75                CALL: CALL XUR$INIT(XUR_INIT , P_PCB$ , PARAM$ ) ALTRET;
       76       76                INPUT:   XUR_INIT - THE STRUCTURE XUR_INIT TO INIT VARIOUS THINGS.
       77       77                OUTPUT:  P_PCB$ - PTR TO THE PARSE CONTROL BLOCK (OPTIONAL).
       78       78                          PARAM$ - PTR TO THE PARAMETER BLOCK.
       79       79                DESCRIPTION:
       80       80                    This routine may be called to initialize various aspects of XUR$GETCMD.
       81       81                EPTR's may be specified for ABORT, CONTINUE, and BRKMSG;  the SYNTAX
       82       82                flag may be set or reset;  the WORK_ vector may be used to require
       83       83                XUR$GETCMD to use a specific block of memory rather than acquiring a
       84       84                data segment for its own use; and the PCB$ pointer may be set to
       85       85                indicate that XUR$GETCMD is to use a user-provided parse control block
       86       86                in its calls to X$PARSE rather than constructing a PCB of its own in
       87       87                the work area.
       88       88                P_PCB$, if present, will receive the address of the PCB actually used
       89       89                (whether user-provided or built in the work area by XUR$INIT).
       90       90                PARAM$ will receive the PTR to the PARAM block (optional).
       91       91                An ABORT routine must be supplied if XUR$BREAK is used.
       92       92                XUR$INIT may be called more than once, if desired;  the settings of
       93       93                the ABORT, CONTINUE, and BRKMSG EPTR's and the SYNTAX flag will be
       94       94                updated on each call;  the PCB$ pointer will be honored on each call
       95       95                (whether NIL or non-NIL) and the P_PCB$ pointer, if present, will be
       96       96                set to the actual PCB address used.  The WORK_ vector will be honored
       97       97                only on the first call to XUR$INIT and only of XUR$INIT is called before
       98       98                the first call to XUR$GETCMD.  Other information (current error message,
       99       99                DCB identifies, etc.) will not be affected by calls to XUR$INIT.
      100      100                but the other information (ERRMSG,etc.) will be remembered.
      101      101                                                                           */
      102      102        /*D*    NAME: XUR$ERRPTR
      103      103                CALL: XUR$ERRPTR(CPOS,OUTDCB);
      104      104                INPUT:   CPOS - CHARACTER POSTITION AT WHICH ERROR OCCURED.
      105      105                                MOST LIKELY OBTAINED FROM P_PCB.HI_CHAR OR
      106      106                                OUT$BLK.CPOS.
      107      107                         OUTDCB - DCB TO OUTPUT THROUGH.
      108      108                DESCRIPTION:
      109      109                   XUR$ECHOIF is called with OUTDCB as the parameter.  Then,
      110      110                if CPOS is within the last line of the command a '^' is
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:31   
      111      111                printed under the character at CPOS.  Otherwise fifteen characters
      112      112                on either side of CPOS are printed through OUTDCB and a '^' is
      113      113                printed under the offending character.  The CPOS argument
      114      114                may be omitted in which case P_PCB.HI_CHAR is used.
      115      115                                                                           */
      116      116        /*D*    NAME: XUR$ECHO
      117      117                CALL: CALL XUR$ECHO(OUTDCB);
      118      118                INPUT:   OUTDCB - OUTPUT DCB NUMBER.
      119      119                DESCRIPTION:
      120      120                   Writes the last command through OUTDCB.
      121      121                                                                           */
      122      122        /*D*    NAME: XUR$ECHOIF
      123      123                CALL: CALL XUR$ECHOIF(OUTDCB);
      124      124                INPUT:   OUTDCB - DCB NUMBER OF OUTPUT DCB.
      125      125                DESCRIPTION:
      126      126                   If the last command has not already been written to
      127      127                the place to which OUTDCB is assigned the last command is
      128      128                written through OUTDCB.
      129      129                                                                           */
      130      130        /*D*    NAME: XUR$ECHOLAST
      131      131                CALL: CALL XUR$ECHOLAST(OUTDCB);
      132      132                INPUT:   OUTDCB - DCB TO OUTPUT THROUGH
      133      133                DESCRIPTION:
      134      134                   Echos the last input line through OUTDCB.
      135      135                                                                           */
      136      136        /*D*    NAME: XUR$CORRES
      137      137                CALL: XUR$CORRES(DCB1,DCB2) ALTRET;
      138      138                INPUT:   DCB1 AND DCB2 ARE DCB NUMBERS.
      139      139                DESCRIPTION:
      140      140                   A default open is done on the DCBs if they are not open
      141      141                and the ALTRETURN is taken if the assignments of the DCBs
      142      142                correspond.
      143      143                                                                           */
      144      144        /*D*    NAME: XUR$BREAK
      145      145                CALL: ASYNC ENTRY ON BREAK
      146      146                DESCRIPTION:
      147      147                   XUR$BREAK is a generalized break handler for programs that
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:32   
      148      148                use XUR$GETCMD.  When XUR$BREAK is entered the user routine
      149      149                pointed to by XUR_BRKMSG is called if it is not NIL,  otherwise
      150      150                the message "Break!  C to continue" is output.  (Breaks are
      151      151                ignored from the time XUR$BREAK is entered until it exits.)
      152      152                Then input is read through M$UC.  A null input will cause the
      153      153                current command to be aborted.  The single character 'C' or 'c'
      154      154                will cause the current command to be continued.  Any other
      155      155                input will be parsed as a new command on the next call to
      156      156                XUR$GETCMD.
      157      157
      158      158                If it is desireable to exit from the BREAK process without printing
      159      159                the "Break!  C to continue" message and inputing a response, the user
      160      160                of XUR$BREAK may opt to "bail out" from his BRKMSG routine by issuing
      161      161                a call to X66_TRTN;  this call will release the auto frame(s) for
      162      162                XUR$BREAK and the BRKMSG routine, and will then return control to the
      163      163                interrupted code with breaks disabled (a la XUR$DISABLE).  If it is
      164      164                desirable to continue at the point of interruption with breaks enabled,
      165      165                XUR$CLRENABLE should be called before X66_TRTN.
      166      166
      167      167                XUR$BREAK is to be establised as the break routine by the user
      168      168                with an M$INT call.  The routine pointed to by XUR_ABORT is
      169      169                called to abort the current command after doing an M$CLRSTK.
      170      170                This routine must be present and should not return.  An optional
      171      171                routine pointed to by XUR_CONTINUE is called to continue
      172      172                commands.  If this routine returns or is not present an M$TRTN
      173      173                will be executed.
      174      174
      175      175                Breaks are ignored if input while reading a command.
      176      176                                                                           */
      177      177        /*D*    NAME: XUR$DISABLE
      178      178                CALL: CALL XUR$DISABLE
      179      179                DESCRIPTION:
      180      180                   Disables breaks for critical code.  Calls to XUR$DISABLE
      181      181                may be nested.
      182      182                                                                           */
      183      183        /*D*    NAME: XUR$ENABLE
      184      184                CALL: CALL XUR$ENABLE
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:33   
      185      185                DESCRIPTION:
      186      186                   Counterpart to XUR$DISABLE.  If a break occured during
      187      187                disabled execution,  it will be processed at enable time.
      188      188                                                                           */
      189      189        /*D*    NAME: XUR$CLRENABLE
      190      190                CALL: CALL XUR$CLRENABLE
      191      191                DESCRIPTION:
      192      192                   Just like XUR$ENABLE except any breaks that occured while
      193      193                disabled will be ignored.
      194      194                                                                           */
      195      195        /*D*    NAME: XUR$ERRMSG
      196      196                CALL: CALL XUR$ERRMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      197      197                INPUT:   CODE - ERROR CODE.  (OPTIONAL.  IF THIS ARGUMENT
      198      198                                IS OMITTED THE SEVERITY FIELD OF THE LAST
      199      199                                CODE IS INCREMENTED.  IN THIS CASE THE
      200      200                                ALTRETURN IS TAKEN IF THE SEVERITY FIELD
      201      201                                EXCEEDS 7 OR NO MESSAGE IS FOUND.)
      202      202                         DCB# - DCB ON WHICH ERROR OCCURED. (OPTIONAL)
      203      203                         OUTDCB - DCB THAT ERROR MESSEAGE IS TO BE WRITTEN
      204      204                                  THROUGH.  (OPTIONAL.  DEFAULT IS M$DO.)
      205      205                         F1 - VECTOR FRAMING TEXTC TO BE USED FOR %U1 SUBSTITUTION.
      206      206                         F2 - VECTOR FRAMING TEXTC TO BE USED FOR %U2 SUBSTITUTION.
      207      207                         F3 - VECTOR FRAMING TEXTC TO BE USED FOR %U3 SUBSTITUTION.
      208      208                         FLGLEV - Number of asterisks to print in front of the
      209      209                                  message (0-4).  Default is 0.
      210      210                         F1, F2, F3 AND FLGLEV ARE OPTIONAL.
      211      211                DESCRIPTION:
      212      212                   A call is made to M$ERRMSG using the parameters passed by
      213      213                the caller.
      214      214                                                                           */
      215      215        /*D*    NAME: XUR$INFOMSG
      216      216                CALL: CALL XUR$INFOMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      217      217                DESCRIPTION:
      218      218                   Identical to XUR$ERRMSG, except that the error code is not
      219      219                saved for subseqent internal use.  Intended for one-level
      220      220                informational messages.
      221      221                                                                           */
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:34   
      222      222        /*D*    NAME: XUR$SETERRMSG
      223      223                CALL: CALL XUR$SETERRMSG(FID) ALTRET;
      224      224                INPUT:   FID - TEXTC FID OF ERROR MESSAGE FILE TO BE USED
      225      225                               ON SUBSEQUENT CALLS TO XUR$ERRMSG.
      226      226                DESCRIPTION:
      227      227                   If the FID argument is passed then M$FID is called to
      228      228                obtain the name, account and password of the error message
      229      229                file to be used on subsequent calls to XUR$ERRMSG.  If the
      230      230                FID argument is omitted then the M$ERRMSG default file will
      231      231                be used.  If the altreturn is taken then M$FID altreted and
      232      232                the error code may be found in the altret frame.
      233      233                                                                           */
      234      234        /*D*    NAME: XUR$HELP
      235      235                CALL: CALL XUR$HELP(XUH_PARAM) ALTRET;
      236      236                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      237      237                DESCRIPTION:
      238      238                   This routine calls X$HELP.  The purpose of XUR$HELP is
      239      239                to keep track of whether the last message operation was
      240      240                M$ERRMSG or M$HELP.  If X$HELP altreturns then XUR$HELP
      241      241                will call XUR$ERRMSG with the error code in XUH_PARAM and
      242      242                then altreturn.  Otherwise the normal return will be taken.
      243      243                                                                           */
      244      244        /*D*    NAME: XUR$MOREMSG
      245      245                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      246      246                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      247      247                DESCRIPTION:
      248      248                   XUR$ERRMSG or X$HELP is called to get the next level of
      249      249                messages.  Trust me.  The altreturn is taken if no messages
      250      250                are available.
      251      251                                                                           */
      252      252        /*D*    NAME: XUR$ALLMSG
      253      253                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      254      254                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      255      255                DESCRIPTION:
      256      256                   XUR$ERRMSG or X$HELP is called to get all remaining
      257      257                messages.  Trust me.  The altreturn is taken if no messages
      258      258                are available.
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:35   
      259      259                                                                           */
      260      260        /*D*    NAME: XUR$FINDDCB
      261      261                CALL: CALL XUR$FINDDCB(DCBNAME,DCB#) ALTRET;
      262      262                INPUT:   DCBNAME - TEXTC DCB NAME
      263      263                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      264      264                DESCRIPTION:
      265      265                   Searches DCB table for DCB specified by DCBNAME.  If it
      266      266                is found, DCB number is returned in DCB#.  If not present
      267      267                the altreturn will be taken.
      268      268                                                                           */
      269      269        /*D*    NAME: XUR$GETDCB
      270      270                CALL: CALL XUR$GETDCB(DCBNAME,DCB#) ALTRET;
      271      271                INPUT:   DCBNAME - TEXTC DCB NAME
      272      272                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      273      273                DESCRIPTION:
      274      274                   Searches DCB table for DCB specified by DCBNAME.  If it
      275      275                is found, DCB number is returned in DCB#.  If not present
      276      276                M$GETDCB will be called to get it.  If M$GETDCB altreturns
      277      277                then XUR$GETDCB will altreturn and the error code may be
      278      278                found in the altret frame.
      279      279                                                                           */
      280      280        /*D*    NAME: XUR$CLOSE_DCBS;
      281      281                CALL: CALL XUR$CLOSE_DCBS;
      282      282                DESCRIPTION:
      283      283                   Closes all open dcbs with SAVE.
      284      284                                                                           */
      285      285        /*D*     NAME: XUR$ERRCNVRT
      286      286                 CALL: CALL XUR$ERRCNVRT (LCP6_ERROR_CODE, ERROR_CODE);
      287      287                 INPUT: LCP6_ERROR_CODE - an LCP-6 error code (fcg/mid/m/err/sev) as
      288      288                       passed through the coupler.
      289      289                 OUTPUT: ERROR_CODE - error code converted to CP-6 standard format.
      290      290                 DESCRIPTION: This routine will convert an LCP-6 error code (32 bits,
      291      291                             stored in 36 bits with the high-order bit in each byte
      292      292                             being zero) into the equivalent CP-6 standard error code
      293      293                             format (36 bits).
      294      294        */
      295      295
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:36   
      296      296        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:37   
      297      297        XUR$GETCMD: PROC(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;

    297  3 000000   000000 700200 xent  XUR$GETCMD   TSX0  ! X66_AUTO_N
         3 000001   000064 000006                    ZERO    52,6

      298      298        /**/
      299      299        %INCLUDE CP_6 ;
      300     5858    1   DCL NODES SBIN;
      301     5859    1   DCL 1 VECBASE BASED,                    /* USED AS REDEF OF NODES */
      302     5860    1         2 BOUND UBIN(20) UNAL,
      303     5861    1         2 FLAGS BIT(16),
      304     5862    1         2 P$ PTR;
      305     5863    1   DCL OUT$ PTR;
      306     5864        %VLP_ERRCODE (FPTN=ERR, STCLASS="REDEF OUT$") ;
      307     5909    1   DCL PROMPT VECTOR PARAM ;
      308     5910    1   DCL TXT CHAR(CSIZE);
      309     5911    1   DCL TSIZ SBIN;
      310     5912    1   DCL ROUTINE EPTR;
      311     5913        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:38   
      312     5914    1   DCL XUG$ERRPTR ENTRY(1) ALTRET ;
      313     5915    1   DCL XUG$ERRMSG ENTRY(1) ALTRET ;
      314     5916    1   DCL XUG$INIT ENTRY(2) ALTRET ;
      315     5917    1   DCL XUG$ECHOIF ENTRY(1) ALTRET ;
      316     5918    1   DCL XUG$ECHO ENTRY(1) ALTRET ;
      317     5919    1   DCL XUG$GETCMD ENTRY(1) ALTRET ;
      318     5920        /**/
      319     5921        %INCLUDE XU_MACRO_C;
      320     9027        %INCLUDE XUH_MACRO_C ;
      321     9111        %INCLUDE XU_PERR_C;
      322     9302        %P_PCB (STCLASS=BASED);
      323     9501        /*    CP_6 included above. */
      324     9502        %INCLUDE CP_6_SUBS;
      325    10042        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:39   
      326    10043        /*
      327    10044        */
      328    10045    1   DCL GDSVEC VECTOR STATIC SYMDEF DALIGNED INIT(VECTOR(NIL)) ;
      329    10046
      330    10047        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:40   
      331    10048        %XUG_PARAMS (NAME=XUG, STCLASS=BASED) ;
      332    10492        %XUG_GETCMD (NAME=GETCMD, STCLASS="STATIC SYMDEF") ;
      333    10830        %XUG_INIT (NAME=XUG_INIT, STCLASS=AUTO) ;
      334    11243        %XUG_INIT (NAME=XUG_INIT_C, STCLASS=SYMREF) ;
      335    11656        %XUR_INIT (STCLASS="BASED(XUR_INIT$)");
      336    11755        %XUR_INIT (NAME = XUR_INIT_C, STCLASS="CONSTANT SYMDEF") ;
      337    11854        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:41   
      338    11855    1   DCL XUR_INIT$ PTR ;
      339    11856    1   DCL CSIZE SBIN;
      340    11857    1   DCL PR$ PTR;
      341    11858    1   DCL PSIZ UBIN WORD ;
      342    11859    1   DCL 1 PROMPTC CALIGNED BASED(PR$),
      343    11860    1         2 B1,
      344    11861    1           3 VFC BIT(1) UNAL,
      345    11862    1           3 L UBIN(8) UNAL,
      346    11863    1         2 C CHAR(PSIZ);
      347    11864        /*
      348    11865        */
      349    11866    1   DCL P$ PTR BASED;
      350    11867        %B$TCB (STCLASS="BASED(B$TCB$)") ;
      351    11870        %B$ALT;
      352    11878    1   DCL B$TCB$ PTR SYMREF;
      353    11879    1   DCL OPT$DCB# UBIN WORD BASED ;
      354    11880        %VLP_ERRCODE (FPTN=ERR$CODE, STCLASS=BASED) ;
      355    11925        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:42   
      356    11926    1   GETCMD:
      357    11927    1       IF GETCMD.WORK$ = ADDR(NIL)

  11927  3 000002   000006 236000 1     GETCMD       LDQ     GETCMD+4
         3 000003   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000004   000011 601000 3                  TNZ     s:11930

      358    11928    1       THEN
      359    11929    1           CALL XUR$INIT (XUR_INIT_C) ALTRET(MALT) ;

  11929  3 000005   000000 630400 4                  EPPR0   0
         3 000006   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000007   000323 701000 3                  TSX1    s:12027
         3 000010   000136 702000 3                  TSX2    MALT

      360    11930    1       GETCMD.NODES$ = ADDR(NODES) ;

  11930  3 000011   200003 236100                    LDQ     @NODES,,AUTO
         3 000012   000002 756000 1                  STQ     GETCMD

      361    11931    1       PR$=ADDR(PROMPT) ;

  11931  3 000013   200005 236100                    LDQ     @PROMPT,,AUTO
         3 000014   200060 756100                    STQ     PR$,,AUTO

      362    11932    2       IF PR$~=ADDR(NIL) THEN DO;

  11932  3 000015   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000016   000052 600000 3                  TZE     s:11944

      363    11933    3           IF VBOUND(PROMPT) > 94 THEN DO; /* MUST BE TEXTC PROMPT */

  11933  3 000017   200005 470500                    LDP0    @PROMPT,,AUTO
         3 000020   000000 236100                    LDQ     0,,PR0
         3 000021   000034 376000 xsym               ANQ     B_VECTNIL+28
         3 000022   000001 116000 4                  CMPQ    1
         3 000023   000046 602000 3                  TNC     s:11941
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:43   

      364    11934    3               IF PROMPTC.B1.VFC

  11934  3 000024   200060 471500                    LDP1    PR$,,AUTO
         3 000025   000000 066500                    CMPB    filb='0'B
         3 000026   100000 000001                    BDSC    0,,PR1                   by=0,bit=0,n=1
         3 000027   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         3 000030   000033 600000 3                  TZE     s:11937

      365    11935    3               THEN
      366    11936    3                   GETCMD.PROMPT_VFC# = '1'B ;

  11936  3 000031   010000 236003                    LDQ     4096,DU
         3 000032   000010 256000 1                  ORSQ    GETCMD+6

      367    11937    3               PSIZ = PROMPTC.B1.L ;

  11937  3 000033   003100 061500                    CSR     bolr='003'O
         3 000034   100000 010010                    BDSC    0,,PR1                   by=0,bit=1,n=8
         3 000035   200061 000044                    BDSC    PSIZ,,AUTO               by=0,bit=0,n=36

      368    11938    3               GETCMD.PROMPT_=VECTOR(PROMPTC.C);

  11938  3 000036   200061 235100                    LDA     PSIZ,,AUTO
         3 000037   000020 735000                    ALS     16
         3 000040   000140 135007                    SBLA    96,DL
         3 000041   200060 236100                    LDQ     PR$,,AUTO
         3 000042   200000 036007                    ADLQ    65536,DL
         3 000043   000027 755000 1                  STA     GETCMD+21
         3 000044   000030 756000 1                  STQ     GETCMD+22

      369    11939    3           END ;                     /* Then Do */

  11939  3 000045   000055 710000 3                  TRA     s:11945

      370    11940    2           ELSE
      371    11941    2               GETCMD.PROMPT_ = PROMPT ;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:44   

  11941  3 000046   000000 237100                    LDAQ    0,,PR0
         3 000047   000027 755000 1                  STA     GETCMD+21
         3 000050   000030 756000 1                  STQ     GETCMD+22

      372    11942    2       END ;                        /* Then Do */

  11942  3 000051   000055 710000 3                  TRA     s:11945

      373    11943    1       ELSE
      374    11944    1           GETCMD.PROMPT_ = VECTOR(ERASE) ;

  11944  3 000052   000002 237000 4                  LDAQ    2
         3 000053   000027 755000 1                  STA     GETCMD+21
         3 000054   000030 756000 1                  STQ     GETCMD+22

      375    11945    1       IF ADDR(ROUTINE)=ADDR(NIL) THEN GETCMD.SFROUTINE$=ENTADDR(NIL);

  11945  3 000055   200010 236100                    LDQ     @ROUTINE,,AUTO
         3 000056   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000057   000063 601000 3                  TNZ     s:11946

  11945  3 000060   000002 236000 xsym               LDQ     B_VECTNIL+2
         3 000061   000035 756000 1                  STQ     GETCMD+27
         3 000062   000066 710000 3                  TRA     s:11947

      376    11946    1       ELSE GETCMD.SFROUTINE$=ROUTINE;

  11946  3 000063   200010 470500                    LDP0    @ROUTINE,,AUTO
         3 000064   000000 236100                    LDQ     0,,PR0
         3 000065   000035 756000 1                  STQ     GETCMD+27

      377    11947    1       IF ADDR(TXT)=ADDR(NIL)

  11947  3 000066   200006 236100                    LDQ     @TXT,,AUTO
         3 000067   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000070   000074 601000 3                  TNZ     s:11950
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:45   

      378    11948    1       THEN GETCMD.TEXT_ = VECTOR(NIL) ;

  11948  3 000071   000004 237000 4                  LDAQ    4
         3 000072   000036 757000 1                  STAQ    GETCMD+28
         3 000073   000116 710000 3                  TRA     s:11958

      379    11949    2       ELSE DO;

      380    11950    2           IF ADDR(TSIZ)=ADDR(NIL) THEN CSIZE=GETCMD.PCB$->P_PCB.NCHARS;

  11950  3 000074   200007 236100                    LDQ     @TSIZ,,AUTO
         3 000075   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000076   000103 601000 3                  TNZ     s:11951

  11950  3 000077   000005 470400 1                  LDP0    GETCMD+3
         3 000100   000011 235100                    LDA     9,,PR0
         3 000101   200057 755100                    STA     CSIZE,,AUTO
         3 000102   000106 710000 3                  TRA     s:11952

      381    11951    2           ELSE CSIZE=TSIZ;

  11951  3 000103   200007 470500                    LDP0    @TSIZ,,AUTO
         3 000104   000000 235100                    LDA     0,,PR0
         3 000105   200057 755100                    STA     CSIZE,,AUTO

      382    11952    2           IF CSIZE = 0

  11952  3 000106   000112 601000 3                  TNZ     s:11956

      383    11953    2           THEN
      384    11954    2               GETCMD.TEXT_ = VECTOR(ERASE);

  11954  3 000107   000002 237000 4                  LDAQ    2
         3 000110   000036 757000 1                  STAQ    GETCMD+28
         3 000111   000116 710000 3                  TRA     s:11958

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:46   
      385    11955    2           ELSE
      386    11956    2               GETCMD.TEXT_ = VECTOR(TXT);

  11956  3 000112   000020 735000                    ALS     16
         3 000113   000140 135007                    SBLA    96,DL
         3 000114   200006 236100                    LDQ     @TXT,,AUTO
         3 000115   000036 757000 1                  STAQ    GETCMD+28

      387    11957    2       END ;                        /* Else Do */

      388    11958    1       CALL XUG$GETCMD (GETCMD) ALTRET(GETCMD_ALT) ;

  11958  3 000116   000006 630400 4                  EPPR0   6
         3 000117   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000120   000000 701000 xent               TSX1    XUG$GETCMD
         3 000121   000126 702000 3                  TSX2    GETCMD_ALT

      389    11959    1       OUT$=GETCMD.OUT$;

  11959  3 000122   000003 236000 1                  LDQ     GETCMD+1
         3 000123   200004 470500                    LDP0    @OUT$,,AUTO
         3 000124   000000 756100                    STQ     0,,PR0

      390    11960    1       RETURN;

  11960  3 000125   000000 702200 xent               TSX2  ! X66_ARET

      391    11961    1   GETCMD_ALT: ERR=GETCMD.ERR#;

  11961  3 000126   000003 236000 1     GETCMD_ALT   LDQ     GETCMD+1
         3 000127   200004 470500                    LDP0    @OUT$,,AUTO
         3 000130   000000 756100                    STQ     0,,PR0

      392    11962    1       CALL XUR$XUGERR2XUR (ERR) ;

  11962  3 000131   200004 630500                    EPPR0   @OUT$,,AUTO
         3 000132   000017 631400 xsym               EPPR1   B_VECTNIL+15
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:47   
         3 000133   000507 701000 3                  TSX1    s:12071
         3 000134   000000 011000                    NOP     0

      393    11963    1       ALTRETURN;

  11963  3 000135   000000 702200 xent               TSX2  ! X66_AALT

      394    11964    1   MALT: ERR=B$TCB.ALT$->B$ALT.ERR;

  11964  3 000136   000000 470400 xsym  MALT         LDP0    B$TCB$
         3 000137   000000 471500                    LDP1    0,,PR0
         3 000140   100102 236100                    LDQ     66,,PR1
         3 000141   200004 473500                    LDP3    @OUT$,,AUTO
         3 000142   300000 756100                    STQ     0,,PR3

      395    11965    1       ALTRETURN ;

  11965  3 000143   000000 702200 xent               TSX2  ! X66_AALT

      396    11966        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:48   
      397    11967    1   XUR$ERRPTR: ENTRY(NODES,OUT$) ALTRET;

  11967  3 000144   000000 700200 xent  XUR$ERRPTR   TSX0  ! X66_AUTO_N
         3 000145   000064 000006                    ZERO    52,6

      398    11968        /**/
      399    11969    1       IF GETCMD.WORK$ = ADDR(NIL)

  11969  3 000146   000006 236000 1                  LDQ     GETCMD+4
         3 000147   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000150   000155 601000 3                  TNZ     s:11972

      400    11970    1       THEN
      401    11971    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);

  11971  3 000151   000000 630400 4                  EPPR0   0
         3 000152   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000153   000323 701000 3                  TSX1    s:12027
         3 000154   000136 702000 3                  TSX2    MALT

      402    11972    1       IF ADDR(NODES) ~= ADDR(NIL)

  11972  3 000155   200003 236100                    LDQ     @NODES,,AUTO
         3 000156   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000157   000166 600000 3                  TZE     s:11978

      403    11973    1       THEN
      404    11974    2       DO ;

      405    11975    2           GETCMD.EPOS# = NODES ;

  11975  3 000160   200003 470500                    LDP0    @NODES,,AUTO
         3 000161   000000 720100                    LXL0    0,,PR0
         3 000162   000010 440000 1                  SXL0    GETCMD+6

      406    11976    2           GETCMD.USE_EPOS# = %YES# ;

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:49   
  11976  3 000163   400000 236003                    LDQ     -131072,DU
         3 000164   000010 256000 1                  ORSQ    GETCMD+6

      407    11977    2       END ;                        /* Then Do */

  11977  3 000165   000170 710000 3                  TRA     s:11979

      408    11978    1       ELSE GETCMD.USE_EPOS# = %NO# ;

  11978  3 000166   000031 236000 xsym               LDQ     B_VECTNIL+25
         3 000167   000010 356000 1                  ANSQ    GETCMD+6

      409    11979    1       IF ADDR(ERR) ~= ADDR(NIL)

  11979  3 000170   200004 236100                    LDQ     @OUT$,,AUTO
         3 000171   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000172   000177 600000 3                  TZE     s:11983

      410    11980    1       THEN
      411    11981    1           GETCMD.DCB_PARAM# = BITBIN(ERR) ;

  11981  3 000173   200004 470500                    LDP0    @OUT$,,AUTO
         3 000174   000000 235100                    LDA     0,,PR0
         3 000175   000016 755000 1                  STA     GETCMD+12
         3 000176   000200 710000 3                  TRA     s:11984

      412    11982    1       ELSE
      413    11983    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;

  11983  3 000177   000016 450000 1                  STZ     GETCMD+12

      414    11984    1       CALL XUG$ERRPTR(GETCMD) ;

  11984  3 000200   000006 630400 4                  EPPR0   6
         3 000201   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000202   000000 701000 xent               TSX1    XUG$ERRPTR
         3 000203   000000 011000                    NOP     0
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:50   

      415    11985    1       RETURN ;

  11985  3 000204   000000 702200 xent               TSX2  ! X66_ARET

      416    11986        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:51   
      417    11987    1   XUR$ECHOIF: ENTRY(NODES) ALTRET;

  11987  3 000205   000000 700200 xent  XUR$ECHOIF   TSX0  ! X66_AUTO_N
         3 000206   000064 000006                    ZERO    52,6

      418    11988    1       IF GETCMD.WORK$ = ADDR(NIL)

  11988  3 000207   000006 236000 1                  LDQ     GETCMD+4
         3 000210   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000211   000216 601000 3                  TNZ     s:11991

      419    11989    1       THEN
      420    11990    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);

  11990  3 000212   000000 630400 4                  EPPR0   0
         3 000213   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000214   000323 701000 3                  TSX1    s:12027
         3 000215   000136 702000 3                  TSX2    MALT

      421    11991    1       IF ADDR(NODES) ~= ADDR(NIL)

  11991  3 000216   200003 236100                    LDQ     @NODES,,AUTO
         3 000217   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000220   000225 600000 3                  TZE     s:11995

      422    11992    1       THEN
      423    11993    1           GETCMD.DCB_PARAM# = NODES ;

  11993  3 000221   200003 470500                    LDP0    @NODES,,AUTO
         3 000222   000000 235100                    LDA     0,,PR0
         3 000223   000016 755000 1                  STA     GETCMD+12
         3 000224   000226 710000 3                  TRA     s:11996

      424    11994    1       ELSE
      425    11995    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;

  11995  3 000225   000016 450000 1                  STZ     GETCMD+12
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:52   

      426    11996    1       CALL XUG$ECHOIF (GETCMD) ;

  11996  3 000226   000006 630400 4                  EPPR0   6
         3 000227   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000230   000000 701000 xent               TSX1    XUG$ECHOIF
         3 000231   000000 011000                    NOP     0

      427    11997    1       RETURN;

  11997  3 000232   000000 702200 xent               TSX2  ! X66_ARET

      428    11998        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:53   
      429    11999    1   XUR$ECHO: ENTRY(NODES) ALTRET;

  11999  3 000233   000000 700200 xent  XUR$ECHO     TSX0  ! X66_AUTO_N
         3 000234   000064 000006                    ZERO    52,6

      430    12000    1       IF GETCMD.WORK$ = ADDR(NIL)

  12000  3 000235   000006 236000 1                  LDQ     GETCMD+4
         3 000236   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000237   000244 601000 3                  TNZ     s:12003

      431    12001    1       THEN
      432    12002    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);

  12002  3 000240   000000 630400 4                  EPPR0   0
         3 000241   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000242   000323 701000 3                  TSX1    s:12027
         3 000243   000136 702000 3                  TSX2    MALT

      433    12003    1       IF ADDR(NODES) ~= ADDR(NIL)

  12003  3 000244   200003 236100                    LDQ     @NODES,,AUTO
         3 000245   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000246   000253 600000 3                  TZE     s:12007

      434    12004    1       THEN
      435    12005    1           GETCMD.DCB_PARAM# = NODES ;

  12005  3 000247   200003 470500                    LDP0    @NODES,,AUTO
         3 000250   000000 235100                    LDA     0,,PR0
         3 000251   000016 755000 1                  STA     GETCMD+12
         3 000252   000254 710000 3                  TRA     s:12008

      436    12006    1       ELSE
      437    12007    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;

  12007  3 000253   000016 450000 1                  STZ     GETCMD+12
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:54   

      438    12008    1       CALL XUG$ECHO (GETCMD) ;

  12008  3 000254   000006 630400 4                  EPPR0   6
         3 000255   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000256   000000 701000 xent               TSX1    XUG$ECHO
         3 000257   000000 011000                    NOP     0

      439    12009    1       RETURN;

  12009  3 000260   000000 702200 xent               TSX2  ! X66_ARET

      440    12010        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:55   
      441    12011    1   XUR$SETDCBS: ENTRY(NODES,OUT$,PROMPT, TXT) ALTRET;

  12011  3 000261   000000 700200 xent  XUR$SETDCBS  TSX0  ! X66_AUTO_N
         3 000262   000064 000006                    ZERO    52,6

      442    12012    1       IF GETCMD.WORK$ = ADDR(NIL)

  12012  3 000263   000006 236000 1                  LDQ     GETCMD+4
         3 000264   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000265   000272 601000 3                  TNZ     s:12015

      443    12013    1       THEN
      444    12014    1           CALL XUR$INIT (XUR_INIT_C) ALTRET (MALT);

  12014  3 000266   000000 630400 4                  EPPR0   0
         3 000267   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000270   000323 701000 3                  TSX1    s:12027
         3 000271   000136 702000 3                  TSX2    MALT

      445    12015    1       IF ADDR(NODES)~=ADDR(NIL)

  12015  3 000272   200003 236100                    LDQ     @NODES,,AUTO
         3 000273   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000274   000300 600000 3                  TZE     s:12017

      446    12016    1       THEN GETCMD.INDCB# = NODES ;

  12016  3 000275   200003 470500                    LDP0    @NODES,,AUTO
         3 000276   000000 235100                    LDA     0,,PR0
         3 000277   000014 755000 1                  STA     GETCMD+10

      447    12017    1       IF ADDR(OUT$)~=ADDR(NIL)

  12017  3 000300   200004 236100                    LDQ     @OUT$,,AUTO
         3 000301   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000302   000306 600000 3                  TZE     s:12019

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:56   
      448    12018    1       THEN GETCMD.OUTDCB# = BITBIN(ERR);

  12018  3 000303   200004 470500                    LDP0    @OUT$,,AUTO
         3 000304   000000 235100                    LDA     0,,PR0
         3 000305   000015 755000 1                  STA     GETCMD+11

      449    12019    1       IF ADDR(PROMPT) ~= ADDR(NIL)

  12019  3 000306   200005 236100                    LDQ     @PROMPT,,AUTO
         3 000307   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000310   000314 600000 3                  TZE     s:12022

      450    12020    1       THEN
      451    12021    1           GETCMD.DCB_PARAM# = ADDR(PROMPT)->OPT$DCB# ;

  12021  3 000311   200005 470500                    LDP0    @PROMPT,,AUTO
         3 000312   000000 235100                    LDA     0,,PR0
         3 000313   000016 755000 1                  STA     GETCMD+12

      452    12022    1       IF ADDR(TXT) ~= ADDR(NIL)

  12022  3 000314   200006 236100                    LDQ     @TXT,,AUTO
         3 000315   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000316   000322 600000 3                  TZE     s:12025

      453    12023    1       THEN
      454    12024    1           GETCMD.ERRDCB# = ADDR(TXT)->OPT$DCB# ;

  12024  3 000317   200006 470500                    LDP0    @TXT,,AUTO
         3 000320   000000 235100                    LDA     0,,PR0
         3 000321   000013 755000 1                  STA     GETCMD+9

      455    12025    1       RETURN;

  12025  3 000322   000000 702200 xent               TSX2  ! X66_ARET

      456    12026        %EJECT;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:57   
      457    12027    1   XUR$INIT: ENTRY (NODES , OUT$ , PROMPT) ALTRET;

  12027  3 000323   000000 700200 xent  XUR$INIT     TSX0  ! X66_AUTO_N
         3 000324   000064 000006                    ZERO    52,6

      458    12028    1       XUR_INIT$ = ADDR (NODES);

  12028  3 000325   200003 236100                    LDQ     @NODES,,AUTO
         3 000326   200056 756100                    STQ     XUR_INIT$,,AUTO

      459    12029    1       XUG_INIT = XUG_INIT_C ;

  12029  3 000327   000100 100400                    MLR     fill='000'O
         3 000330   000000 000220 xsym               ADSC9   XUG_INIT_C               cn=0,n=144
         3 000331   200012 000220                    ADSC9   XUG_INIT,,AUTO           cn=0,n=144

      460    12030    1       XUG_INIT.WORK_ = XUR_INIT.WORKR_ ;

  12030  3 000332   200056 470500                    LDP0    XUR_INIT$,,AUTO
         3 000333   000100 100500                    MLR     fill='000'O
         3 000334   000005 000010                    ADSC9   5,,PR0                   cn=0,n=8
         3 000335   200027 000010                    ADSC9   XUG_INIT+13,,AUTO        cn=0,n=8

      461    12031    1       XUG_INIT.SYNTAX# = XUR_INIT.SYNTAX# ;

  12031  3 000336   000000 236100                    LDQ     0,,PR0
         3 000337   000003 772000                    QRL     3
         3 000340   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000341   040000 376003                    ANQ     16384,DU
         3 000342   200040 656100                    ERSQ    XUG_INIT+22,,AUTO

      462    12032    1       XUG_INIT.PREPROCESS# = XUR_INIT.PREPROCESS#;

  12032  3 000343   000000 236100                    LDQ     0,,PR0
         3 000344   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000345   200000 376003                    ANQ     65536,DU
         3 000346   200040 656100                    ERSQ    XUG_INIT+22,,AUTO
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:58   

      463    12033    1       XUG_INIT.COMMANDS# = XUR_INIT.COMMANDS#;

  12033  3 000347   000000 236100                    LDQ     0,,PR0
         3 000350   000002 736000                    QLS     2
         3 000351   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000352   400000 376003                    ANQ     -131072,DU
         3 000353   200040 656100                    ERSQ    XUG_INIT+22,,AUTO

      464    12034    1       XUG_INIT.INHIBITS = XUR_INIT.INHIBITS;

  12034  3 000354   000023 236100                    LDQ     19,,PR0
         3 000355   777600 376003                    ANQ     -128,DU
         3 000356   200052 756100                    STQ     XUG_INIT+32,,AUTO

      465    12035    1       XUG_INIT.GOODCMD# = XUR_INIT.GOODCMD#;

  12035  3 000357   000000 236100                    LDQ     0,,PR0
         3 000360   000001 772000                    QRL     1
         3 000361   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000362   020000 376003                    ANQ     8192,DU
         3 000363   200040 656100                    ERSQ    XUG_INIT+22,,AUTO

      466    12036    1       XUG_INIT.SPELLING# = XUR_INIT.SPELLING#;

  12036  3 000364   000000 236100                    LDQ     0,,PR0
         3 000365   000001 772000                    QRL     1
         3 000366   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000367   010000 376003                    ANQ     4096,DU
         3 000370   200040 656100                    ERSQ    XUG_INIT+22,,AUTO

      467    12037    1       XUG_INIT.DONT_REREAD_CCBUF# = XUR_INIT.DONT_REREAD_CCBUF#;

  12037  3 000371   000000 236100                    LDQ     0,,PR0
         3 000372   000003 772000                    QRL     3
         3 000373   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000374   001000 376003                    ANQ     512,DU
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:59   
         3 000375   200040 656100                    ERSQ    XUG_INIT+22,,AUTO

      468    12038    1       XUG_INIT.DONT_STRIP_PROMPT# = XUR_INIT.DONT_STRIP_PROMPT#;

  12038  3 000376   000000 236100                    LDQ     0,,PR0
         3 000377   000003 772000                    QRL     3
         3 000400   200040 676100                    ERQ     XUG_INIT+22,,AUTO
         3 000401   000400 376003                    ANQ     256,DU
         3 000402   200040 656100                    ERSQ    XUG_INIT+22,,AUTO

      469    12039    1       XUG_INIT.ECHO# = XUR_INIT.ECHO#;

  12039  3 000403   000016 236100                    LDQ     14,,PR0
         3 000404   000033 736000                    QLS     27
         3 000405   200037 552140                    STBQ    XUG_INIT+21,'40'O,AUTO

      470    12040    1       XUG_INIT.PASS# = XUR_INIT.PASS# ;

  12040  3 000406   000017 236100                    LDQ     15,,PR0
         3 000407   200037 552120                    STBQ    XUG_INIT+21,'20'O,AUTO

      471    12041    1       XUG_INIT.ABORT$ = XUR_INIT.ABORT$;

  12041  3 000410   000001 236100                    LDQ     1,,PR0
         3 000411   200012 756100                    STQ     XUG_INIT,,AUTO

      472    12042    1       XUG_INIT.CONTINUE$ = XUR_INIT.CONTINUE$;

  12042  3 000412   000002 236100                    LDQ     2,,PR0
         3 000413   200013 756100                    STQ     XUG_INIT+1,,AUTO

      473    12043    1       XUG_INIT.BRKMSG$ = XUR_INIT.BRKMSG$;

  12043  3 000414   000003 236100                    LDQ     3,,PR0
         3 000415   200014 756100                    STQ     XUG_INIT+2,,AUTO

      474    12044    1       XUG_INIT.PRE_EXEC$$ = XUR_INIT.PRE_EXEC$$;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:60   

  12044  3 000416   000007 236100                    LDQ     7,,PR0
         3 000417   200016 756100                    STQ     XUG_INIT+4,,AUTO

      475    12045    1       XUG_INIT.POST_EXEC$$ = XUR_INIT.POST_EXEC$$;

  12045  3 000420   000011 236100                    LDQ     9,,PR0
         3 000421   200017 756100                    STQ     XUG_INIT+5,,AUTO

      476    12046    1       XUG_INIT.PREPROCESSOR$$ = XUR_INIT.PREPROCESSOR$$;

  12046  3 000422   000022 236100                    LDQ     18,,PR0
         3 000423   200021 756100                    STQ     XUG_INIT+7,,AUTO

      477    12047    1       XUG_INIT.ADAPT$$ = XUR_INIT.ADAPT$$;

  12047  3 000424   000024 236100                    LDQ     20,,PR0
         3 000425   200041 756100                    STQ     XUG_INIT+23,,AUTO

      478    12048    1       XUG_INIT.MOREMEM$$ = XUR_INIT.MOREMEM$$;

  12048  3 000426   000012 236100                    LDQ     10,,PR0
         3 000427   200020 756100                    STQ     XUG_INIT+6,,AUTO

      479    12049    1       XUG_INIT.PPCB$ = XUR_INIT.PPCB$;

  12049  3 000430   000010 236100                    LDQ     8,,PR0
         3 000431   200032 756100                    STQ     XUG_INIT+16,,AUTO

      480    12050    1       XUG_INIT.PP_DCB# = XUR_INIT.PP_DCB#;

  12050  3 000432   000016 236100                    LDQ     14,,PR0
         3 000433   000011 772000                    QRL     9
         3 000434   200037 552110                    STBQ    XUG_INIT+21,'10'O,AUTO

      481    12051    1       XUG_INIT.PCB$ = XUR_INIT.PCB$ ;

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:61   
  12051  3 000435   000004 236100                    LDQ     4,,PR0
         3 000436   200031 756100                    STQ     XUG_INIT+15,,AUTO

      482    12052    1       XUG_INIT.PROCACCT_ = XUR_INIT.PROCACCT_ ;

  12052  3 000437   000020 237100                    LDAQ    16,,PR0
         3 000440   200024 757100                    STAQ    XUG_INIT+10,,AUTO

      483    12053    1       XUG_INIT.PROCNAME_ = XUR_INIT.PROCNAME_ ;

  12053  3 000441   000014 237100                    LDAQ    12,,PR0
         3 000442   200022 757100                    STAQ    XUG_INIT+8,,AUTO

      484    12054    1       CALL XUG$INIT (GETCMD, XUG_INIT) WHENALTRETURN

  12054  3 000443   200012 631500                    EPPR1   XUG_INIT,,AUTO
         3 000444   200063 451500                    STP1    PSIZ+2,,AUTO
         3 000445   000006 236000 4                  LDQ     6
         3 000446   200062 756100                    STQ     PSIZ+1,,AUTO
         3 000447   200062 630500                    EPPR0   PSIZ+1,,AUTO
         3 000450   000020 631400 xsym               EPPR1   B_VECTNIL+16
         3 000451   000000 701000 xent               TSX1    XUG$INIT
         3 000452   000454 702000 3                  TSX2    s:12056
         3 000453   000467 710000 3                  TRA     s:12061

      485    12055    2       DO ;

      486    12056    2           CALL XUR$XUGERR2XUR (GETCMD.ERR#) ;

  12056  3 000454   000007 630400 4                  EPPR0   7
         3 000455   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000456   000507 701000 3                  TSX1    s:12071
         3 000457   000000 011000                    NOP     0

      487    12057    2           GETCMD.ERR_CODE = GETCMD.ERR# ;

  12057  3 000460   000003 236000 1                  LDQ     GETCMD+1
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:62   
         3 000461   000012 756000 1                  STQ     GETCMD+8

      488    12058    2           CALL XUG$ERRMSG (GETCMD) ALTRET(MALT) ;

  12058  3 000462   000006 630400 4                  EPPR0   6
         3 000463   000017 631400 xsym               EPPR1   B_VECTNIL+15
         3 000464   000000 701000 xent               TSX1    XUG$ERRMSG
         3 000465   000136 702000 3                  TSX2    MALT

      489    12059    2           ALTRETURN ;

  12059  3 000466   000000 702200 xent               TSX2  ! X66_AALT

      490    12060    2       END ;                        /* Whenaltreturn Do */
      491    12061    1       IF ADDR(OUT$) ~= ADDR(NIL)

  12061  3 000467   200004 236100                    LDQ     @OUT$,,AUTO
         3 000470   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000471   000475 600000 3                  TZE     s:12064

      492    12062    1       THEN
      493    12063    1           OUT$ = GETCMD.PCB$ ;

  12063  3 000472   000005 236000 1                  LDQ     GETCMD+3
         3 000473   200004 470500                    LDP0    @OUT$,,AUTO
         3 000474   000000 756100                    STQ     0,,PR0

      494    12064    1       IF ADDR(PROMPT) ~= ADDR(NIL)

  12064  3 000475   200005 236100                    LDQ     @PROMPT,,AUTO
         3 000476   000001 116000 xsym               CMPQ    B_VECTNIL+1
         3 000477   000503 600000 3                  TZE     s:12067

      495    12065    1       THEN
      496    12066    1           ADDR(PROMPT) -> P$ = ADDR(GETCMD) ;

  12066  3 000500   000006 236000 4                  LDQ     6
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:63   
         3 000501   200005 470500                    LDP0    @PROMPT,,AUTO
         3 000502   000000 756100                    STQ     0,,PR0

      497    12067    1       GDSVEC = GETCMD.WORK$ -> XUG.GDSVEC ;

  12067  3 000503   000006 470400 1                  LDP0    GETCMD+4
         3 000504   000006 237100                    LDAQ    6,,PR0
         3 000505   000000 757000 1                  STAQ    GDSVEC

      498    12068    1       RETURN;

  12068  3 000506   000000 702200 xent               TSX2  ! X66_ARET

      499    12069        /**/
      500    12070        %EJECT ;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:64   
      501    12071    1   XUR$XUGERR2XUR: ENTRY(NODES) ALTRET;

  12071  3 000507   000000 700200 xent  XUR$XUGERR2* TSX0  ! X66_AUTO_N
         3 000510   000064 000006                    ZERO    52,6

      502    12072
      503    12073    1       PR$ = ADDR(NODES) ;

  12073  3 000511   200003 236100                    LDQ     @NODES,,AUTO
         3 000512   200060 756100                    STQ     PR$,,AUTO

      504    12074    1       IF PR$->ERR$CODE.FCG = '3025'O AND PR$->ERR$CODE.MID = '07'O

  12074  3 000513   200060 470500                    LDP0    PR$,,AUTO
         3 000514   000000 236100                    LDQ     0,,PR0
         3 000515   777700 376003                    ANQ     -64,DU
         3 000516   302500 116003                    CMPQ    99648,DU
         3 000517   000662 601000 3                  TNZ     s:12157
         3 000520   000000 236100                    LDQ     0,,PR0
         3 000521   000077 376003                    ANQ     63,DU
         3 000522   000007 116003                    CMPQ    7,DU
         3 000523   000662 601000 3                  TNZ     s:12157

      505    12075    1       THEN
      506    12076    2       DO ;

      507    12077    2           PR$->ERR$CODE.MID = '22'O ;

  12077  3 000524   000022 236003                    LDQ     18,DU
         3 000525   000000 752110                    STCQ    0,'10'O,PR0

      508    12078    3           DO SELECT(PR$->ERR$CODE.ERR#) ;

  12078  3 000526   000000 236100                    LDQ     0,,PR0
         3 000527   000003 772000                    QRL     3
         3 000530   037777 376007                    ANQ     16383,DL
         3 000531   000623 116007                    CMPQ    403,DL
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:65   
         3 000532   000572 602000 3                  TNC     s:12078+36
         3 000533   000625 600000 3                  TZE     s:12114
         3 000534   000627 116007                    CMPQ    407,DL
         3 000535   000553 602000 3                  TNC     s:12078+21
         3 000536   000620 600000 3                  TZE     s:12106
         3 000537   000631 116007                    CMPQ    409,DL
         3 000540   000546 602000 3                  TNC     s:12078+16
         3 000541   000651 600000 3                  TZE     s:12140
         3 000542   000003 736000                    QLS     3
         3 000543   006510 116007                    CMPQ    3400,DL
         3 000544   000662 601000 3                  TNZ     s:12157
         3 000545   000656 710000 3                  TRA     s:12147
         3 000546   000000 236100                    LDQ     0,,PR0
         3 000547   377770 376007                    ANQ     131064,DL
         3 000550   006300 116007                    CMPQ    3264,DL
         3 000551   000662 601000 3                  TNZ     s:12157
         3 000552   000613 710000 3                  TRA     s:12098
         3 000553   000000 236100                    LDQ     0,,PR0
         3 000554   000003 772000                    QRL     3
         3 000555   037777 376007                    ANQ     16383,DL
         3 000556   000625 116007                    CMPQ    405,DL
         3 000557   000565 602000 3                  TNC     s:12078+31
         3 000560   000637 600000 3                  TZE     s:12127
         3 000561   000003 736000                    QLS     3
         3 000562   006260 116007                    CMPQ    3248,DL
         3 000563   000662 601000 3                  TNZ     s:12157
         3 000564   000644 710000 3                  TRA     s:12133
         3 000565   000000 236100                    LDQ     0,,PR0
         3 000566   377770 376007                    ANQ     131064,DL
         3 000567   006240 116007                    CMPQ    3232,DL
         3 000570   000662 601000 3                  TNZ     s:12157
         3 000571   000632 710000 3                  TRA     s:12120
         3 000572   000000 236100                    LDQ     0,,PR0
         3 000573   000003 772000                    QRL     3
         3 000574   037777 376007                    ANQ     16383,DL
         3 000575   000621 116007                    CMPQ    401,DL
         3 000576   000601 602000 3                  TNC     s:12078+43
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:66   
         3 000577   000606 600000 3                  TZE     s:12091
         3 000600   000662 710000 3                  TRA     s:12157
         3 000601   000003 736000                    QLS     3
         3 000602   000010 116007                    CMPQ    8,DL
         3 000603   000662 601000 3                  TNZ     s:12157
         3 000604   000605 710000 3                  TRA     s:12080

      509    12079
      510    12080    3               SELECT(%E$SYNERR) ;

  12080  3 000605   000662 710000 3                  TRA     s:12157

      511    12081
      512    12082        /*E*  ERROR:   XUR-E$SYNERR
      513    12083                MESSAGE: Your command was not processed because it contains something
      514    12084                         unexpected (a mis-spelled word, incorrect punctuation, or some
      515    12085                         other input which does not match this program's requirements).
      516    12086                         You may obtain a brief description of the expected input by
      517    12087                         entering as much of the command as you are sure of, followed
      518    12088                         by a single "?".
      519    12089        */
      520    12090    3               SELECT(%E$XUG#SMALLWORK) ;

      521    12091    3               PR$->ERR$CODE.ERR# = %E$XUR#SMALLWORK ;

  12091  3 000606   000000 236100                    LDQ     0,,PR0
         3 000607   000010 376000 4                  ANQ     8
         3 000610   007020 276007                    ORQ     3600,DL
         3 000611   000000 756100                    STQ     0,,PR0
         3 000612   000662 710000 3                  TRA     s:12157

      522    12092
      523    12093        /*E*  ERROR:   XUR-E$XUR#SMALLWORK
      524    12094              MESSAGE0: Work area too small for XUR$INIT to initialize.  Unable
      525    12095                        to continue.
      526    12096        */
      527    12097    3               SELECT(%E$XUG#NOTCONTIGAREA) ;
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:67   

      528    12098    3               PR$->ERR$CODE.ERR# = %E$XUR#NOTCONTIGAREA ;

  12098  3 000613   000000 236100                    LDQ     0,,PR0
         3 000614   000010 376000 4                  ANQ     8
         3 000615   007100 276007                    ORQ     3648,DL
         3 000616   000000 756100                    STQ     0,,PR0
         3 000617   000662 710000 3                  TRA     s:12157

      529    12099
      530    12100        /*E*  ERROR:   XUR-E$XUR#NOTCONTIGAREA
      531    12101              MESSAGE: Not a contiguous work area.
      532    12102              MESSAGE1: The data expansion received from the user program is
      533    12103                          not contiguous with the present work area.
      534    12104        */
      535    12105    3               SELECT(%E$XUG#AREANOTRTSZ) ;

      536    12106    3               PR$->ERR$CODE.ERR# = %E$XUR#AREANOTRTSZ ;

  12106  3 000620   000000 236100                    LDQ     0,,PR0
         3 000621   000010 376000 4                  ANQ     8
         3 000622   007070 276007                    ORQ     3640,DL
         3 000623   000000 756100                    STQ     0,,PR0
         3 000624   000662 710000 3                  TRA     s:12157

      537    12107
      538    12108        /*E*  ERROR:   XUR-E$XUR#AREANOTRTSZ
      539    12109              MESSAGE: Data area not the right size.
      540    12110              MESSAGE1: The data expansion received from the user program is
      541    12111                          not the amount that XUR$GETCMD requested.
      542    12112        */
      543    12113    3               SELECT(%E$XUG#BDIRFID) ;

      544    12114    3               PR$->ERR$CODE.ERR# = %E$XUR#BDIRFID ;

  12114  3 000625   000000 236100                    LDQ     0,,PR0
         3 000626   000010 376000 4                  ANQ     8
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:68   
         3 000627   007030 276007                    ORQ     3608,DL
         3 000630   000000 756100                    STQ     0,,PR0
         3 000631   000662 710000 3                  TRA     s:12157

      545    12115
      546    12116        /*E*  ERROR:   XUR-E$XUR#BDIRFID
      547    12117              MESSAGE0: FID may only consist of DP#SN.ACCOUNT or .ACCOUNT.
      548    12118        */
      549    12119    3               SELECT(%E$XUG#DOCMD2BIG) ;

      550    12120    3               PR$->ERR$CODE.ERR# = %E$XUR#DOCMD2BIG ;

  12120  3 000632   000000 236100                    LDQ     0,,PR0
         3 000633   000010 376000 4                  ANQ     8
         3 000634   007040 276007                    ORQ     3616,DL
         3 000635   000000 756100                    STQ     0,,PR0
         3 000636   000662 710000 3                  TRA     s:12157

      551    12121
      552    12122        /*E*  ERROR:   XUR-E$XUR#DOCMD2BIG
      553    12123              MESSAGE0: DO command too big.
      554    12124              MESSAGE1: The DO command can be at most 256 characters long.
      555    12125        */
      556    12126    3               SELECT(%E$XUG#BIG4CHAR) ;

      557    12127    3               PR$->ERR$CODE.ERR# = %E$XUR#BIG4CHAR ;

  12127  3 000637   000000 236100                    LDQ     0,,PR0
         3 000640   000010 376000 4                  ANQ     8
         3 000641   007050 276007                    ORQ     3624,DL
         3 000642   000000 756100                    STQ     0,,PR0
         3 000643   000662 710000 3                  TRA     s:12157

      558    12128
      559    12129        /*E*  ERROR:   XUR-E$XUR#BIG4CHAR
      560    12130              MESSAGE0: Only four or less characters allowed.
      561    12131        */
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:69   
      562    12132    3               SELECT(%E$XUG#NO_MORE) ;

      563    12133    3               PR$->ERR$CODE.ERR# = %E$XUR#NO_MORE ;

  12133  3 000644   000000 236100                    LDQ     0,,PR0
         3 000645   000010 376000 4                  ANQ     8
         3 000646   007060 276007                    ORQ     3632,DL
         3 000647   000000 756100                    STQ     0,,PR0
         3 000650   000662 710000 3                  TRA     s:12157

      564    12134
      565    12135        /*E*  ERROR:   XUR-E$XUR#NO_MORE
      566    12136              MESSAGE: No messages available.
      567    12137              MESSAGE1: Th Th Th That's all fffolks!
      568    12138        */
      569    12139    3               SELECT(%E$XUG#NWALIGNED) ;

      570    12140    3               PR$->ERR$CODE.ERR# = %E$XUR#NWALIGNED ;

  12140  3 000651   000000 236100                    LDQ     0,,PR0
         3 000652   000010 376000 4                  ANQ     8
         3 000653   007110 276007                    ORQ     3656,DL
         3 000654   000000 756100                    STQ     0,,PR0
         3 000655   000662 710000 3                  TRA     s:12157

      571    12141
      572    12142        /*E*  ERROR:   XUR-E$XUR#NWALIGNED
      573    12143              MESSAGE: Work area is not WORD ALIGNED and XUR$INIT can not continue.
      574    12144                        Initialization aborted.
      575    12145        */
      576    12146    3               SELECT(%E$XUG#NO_ADAPT) ;

      577    12147    3               PR$->ERR$CODE.ERR# = %E$XUR#NO_ADAPT ;

  12147  3 000656   000000 236100                    LDQ     0,,PR0
         3 000657   000010 376000 4                  ANQ     8
         3 000660   007120 276007                    ORQ     3664,DL
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:70   
         3 000661   000000 756100                    STQ     0,,PR0

      578    12148
      579    12149        /*E*  ERROR:   XUR-E$XUR#NO_ADAPT
      580    12150              MESSAGE: The ADAPT dialog manager is not available.
      581    12151              MESSAGE1: The ENTER command cannot be used because the Alternate Shared
      582    12152                        Library (ADAPT_ASL) for the dialog manager is not installed.
      583    12153        */
      584    12154    3           END ;                       /* Do Select */

      585    12155    2       END ;                        /* Then Do */

      586    12156        /**/
      587    12157    1       RETURN ;

  12157  3 000662   000000 702200 xent               TSX2  ! X66_ARET
      588    12158        /**/
      589    12159    1   END XUR$GETCMD;
      590    12160        %EOD;

PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:71   
--  Include file information  --

   CP_6_SUBS.:E05TOU  is referenced.
   XU_PERR_C.:E05TOU  is referenced.
   XUH_MACRO_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
   CP_6_C.:E05TOU  is referenced.
   CP_6.:E05TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure XUR$GETCMD.
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:72   

 **** Variables and constants ****

  ****  Section 001  Data  XUR$GETCMD

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d VECT        r     1 GDSVEC                     2-0-0/d STRC(1512)  r     1 GETCMD

  ****  Section 002 RoData XUR$GETCMD

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1404)  r     1 XUR_INIT_C

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @NODES                     4-0-0/w PTR         r     1 @OUT$
     5-0-0/w PTR         r     1 @PROMPT                   10-0-0/w PTR         r     1 @ROUTINE
     7-0-0/w PTR         r     1 @TSIZ                      6-0-0/w PTR         r     1 @TXT
    57-0-0/w SBIN        r     1 CSIZE                     *0-0-0/w STRC        r     1 ERR
    *0-0-0/w SBIN        r     1 NODES                     *0-0-0/w PTR         r     1 OUT$
    60-0-0/w PTR         r     1 PR$                       *0-0-0/d VECT        r     1 PROMPT
    61-0-0/w UBIN        r     1 PSIZ                      *0-0-0/w EPTR        r     1 ROUTINE
    *0-0-0/w SBIN        r     1 TSIZ                      *0-0-0/c ACHR        r     1 TXT
    12-0-0/d STRC(1296)  r     1 XUG_INIT                  56-0-0/w PTR         r     1 XUR_INIT$

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 B$TCB$                     0-0-0/d STRC(1296)  r     1 XUG_INIT_C
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:73   

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(2448)  r     1 B$ALT                      0-0-0/w STRC(144)   r     1 B$TCB
     0-0-0/w STRC        r     1 ERR$CODE                   0-0-0/w UBIN        r     1 OPT$DCB#
     0-0-0/w PTR         r     1 P$                         0-0-0/c ASTR(9)     r     1 PROMPTC
     0-0-0/w STRC(504)   r     1 P_PCB                      0-0-0/d STRC(9612)  r     1 XUG
     0-0-0/d STRC(1404)  r     1 XUR_INIT


   Procedure XUR$GETCMD requires 435 words for executable code.
   Procedure XUR$GETCMD requires 52 words of local(AUTO) storage.
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:74   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:75   
          MINI XREF LISTING

B$ALT.CODE
     11872**DCL     11872--REDEF   11873--REDEF   11873--REDEF
B$ALT.ERR
     11873**DCL     11964>>ASSIGN
B$ALT.ERR.ERR#
     11874**DCL     11874--REDEF
B$ALT.EVID
     11873**DCL     11873--REDEF   11873--REDEF
B$TCB.ALT$
     11868**DCL     11964>>ASSIGN
B$TCB$
     11878**DCL     11868--IMP-PTR 11964>>ASSIGN
CSIZE
     11856**DCL      5910--IMP-SIZ 11950<<ASSIGN  11951<<ASSIGN  11952>>IF      11956>>ASSIGN
ERR
      5876**DCL     11961<<ASSIGN  11962<>CALL    11964<<ASSIGN  11979--IF      11981>>ASSIGN  12018>>ASSIGN
ERR$CODE.ERR#
     11922**DCL     12078>>DOSELCT 12091<<ASSIGN  12098<<ASSIGN  12106<<ASSIGN  12114<<ASSIGN  12120<<ASSIGN
     12127<<ASSIGN  12133<<ASSIGN  12140<<ASSIGN  12147<<ASSIGN
ERR$CODE.FCG
     11908**DCL     12074>>IF
ERR$CODE.MID
     11921**DCL     12074>>IF      12077<<ASSIGN
GDSVEC
     10045**DCL     12067<<ASSIGN
GETCMD
     11927**LABEL   11958<>CALL    11984<>CALL    11996<>CALL    12008<>CALL    12054<>CALL    12058<>CALL
     12066--ASSIGN
GETCMD.DCB_PARAM#
     10685**DCL     11981<<ASSIGN  11983<<ASSIGN  11993<<ASSIGN  11995<<ASSIGN  12005<<ASSIGN  12007<<ASSIGN
     12021<<ASSIGN
GETCMD.EPOS#
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:76   
     10615**DCL     11975<<ASSIGN
GETCMD.ERR#
     10516**DCL     11961>>ASSIGN  12056<>CALL    12057>>ASSIGN
GETCMD.ERRDCB#
     10664**DCL     12024<<ASSIGN
GETCMD.ERR_CODE
     10653**DCL     12057<<ASSIGN
GETCMD.INDCB#
     10676**DCL     12016<<ASSIGN
GETCMD.NODES$
     10506**DCL     11930<<ASSIGN
GETCMD.OUT$
     10510**DCL     10516--REDEF   11959>>ASSIGN
GETCMD.OUTDCB#
     10681**DCL     12018<<ASSIGN
GETCMD.PCB$
     10530**DCL     11950>>ASSIGN  12063>>ASSIGN
GETCMD.PROMPT_
     10714**DCL     11938<<ASSIGN  11941<<ASSIGN  11944<<ASSIGN
GETCMD.PROMPT_VFC#
     10580**DCL     11936<<ASSIGN
GETCMD.SFROUTINE$
     10755**DCL     11945<<ASSIGN  11946<<ASSIGN
GETCMD.TEXT_
     10768**DCL     11948<<ASSIGN  11954<<ASSIGN  11956<<ASSIGN
GETCMD.USE_EPOS#
     10548**DCL     11976<<ASSIGN  11978<<ASSIGN
GETCMD.WORK$
     10538**DCL     11927>>IF      11969>>IF      11988>>IF      12000>>IF      12012>>IF      12067>>ASSIGN
GETCMD_ALT
     11961**LABEL   11958--CALLALT
MALT
     11964**LABEL   11929--CALLALT 11971--CALLALT 11990--CALLALT 12002--CALLALT 12014--CALLALT 12058--CALLALT
NODES
      5858**DCL       297--PROC    11930--ASSIGN  11967--ENTRY   11972--IF      11975>>ASSIGN  11987--ENTRY
     11991--IF      11993>>ASSIGN  11999--ENTRY   12003--IF      12005>>ASSIGN  12011--ENTRY   12015--IF
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:77   
     12016>>ASSIGN  12027--ENTRY   12028--ASSIGN  12071--ENTRY   12073--ASSIGN
OPT$DCB#
     11879**DCL     12021>>ASSIGN  12024>>ASSIGN
OUT$
      5863**DCL       297--PROC     5876--REDEF   11959<<ASSIGN  11967--ENTRY   12011--ENTRY   12017--IF
     12027--ENTRY   12061--IF      12063<<ASSIGN
P$
     11866**DCL     12066<<ASSIGN
PR$
     11857**DCL     11859--IMP-PTR 11931<<ASSIGN  11932>>IF      11934>>IF      11937>>ASSIGN  11938>>ASSIGN
     12073<<ASSIGN  12074>>IF      12074>>IF      12077>>ASSIGN  12078>>DOSELCT 12091>>ASSIGN  12098>>ASSIGN
     12106>>ASSIGN  12114>>ASSIGN  12120>>ASSIGN  12127>>ASSIGN  12133>>ASSIGN  12140>>ASSIGN  12147>>ASSIGN
PROMPT
      5909**DCL       297--PROC    11931--ASSIGN  11933>>IF      11941>>ASSIGN  12011--ENTRY   12019--IF
     12021--ASSIGN  12027--ENTRY   12064--IF      12066--ASSIGN
PROMPTC.B1.L
     11862**DCL     11937>>ASSIGN
PROMPTC.B1.VFC
     11861**DCL     11934>>IF
PROMPTC.C
     11863**DCL     11938--ASSIGN
PSIZ
     11858**DCL     11863--IMP-SIZ 11937<<ASSIGN  11938>>ASSIGN
P_PCB.NCHARS
      9467**DCL     11950>>ASSIGN
ROUTINE
      5912**DCL       297--PROC    11945--IF      11946>>ASSIGN
TSIZ
      5911**DCL       297--PROC    11950--IF      11951>>ASSIGN
TXT
      5910**DCL       297--PROC    11947--IF      11956--ASSIGN  12011--ENTRY   12022--IF      12024--ASSIGN
XTX$ADAPT
     11772**DCL-ENT 11851--DCLINIT
XUG.BUF
     10487**DCL     10490--REDEF
XUG.GDSVEC
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:78   
     10062**DCL     12067>>ASSIGN
XUG$ECHO
      5918**DCL-ENT 12008--CALL
XUG$ECHOIF
      5917**DCL-ENT 11996--CALL
XUG$ERRMSG
      5915**DCL-ENT 12058--CALL
XUG$ERRPTR
      5914**DCL-ENT 11984--CALL
XUG$GETCMD
      5919**DCL-ENT 11958--CALL
XUG$INIT
      5916**DCL-ENT 12054--CALL
XUG_INIT
     10852**DCL     12029<<ASSIGN  12054<>CALL
XUG_INIT.ABORT$
     10853**DCL     12041<<ASSIGN
XUG_INIT.ADAPT$$
     11163**DCL     12047<<ASSIGN
XUG_INIT.BRKMSG$
     10868**DCL     12043<<ASSIGN
XUG_INIT.COMMANDS#
     11060**DCL     12033<<ASSIGN
XUG_INIT.CONTINUE$
     10861**DCL     12042<<ASSIGN
XUG_INIT.DONT_REREAD_CCBUF#
     11146**DCL     12037<<ASSIGN
XUG_INIT.DONT_STRIP_PROMPT#
     11154**DCL     12038<<ASSIGN
XUG_INIT.ECHO#
     11023**DCL     12039<<ASSIGN
XUG_INIT.GOODCMD#
     11114**DCL     12035<<ASSIGN
XUG_INIT.INHIBITS
     11184**DCL     12034<<ASSIGN
XUG_INIT.MOREMEM$$
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:79   
     10926**DCL     12048<<ASSIGN
XUG_INIT.PASS#
     11033**DCL     12040<<ASSIGN
XUG_INIT.PCB$
     10985**DCL     12051<<ASSIGN
XUG_INIT.POST_EXEC$$
     10908**DCL     12045<<ASSIGN
XUG_INIT.PPCB$
     10992**DCL     12049<<ASSIGN
XUG_INIT.PP_DCB#
     11041**DCL     12050<<ASSIGN
XUG_INIT.PREPROCESS#
     11095**DCL     12032<<ASSIGN
XUG_INIT.PREPROCESSOR$$
     10948**DCL     12046<<ASSIGN
XUG_INIT.PRE_EXEC$$
     10890**DCL     12044<<ASSIGN
XUG_INIT.PROCACCT_
     10962**DCL     12052<<ASSIGN
XUG_INIT.PROCNAME_
     10957**DCL     12053<<ASSIGN
XUG_INIT.SPELLING#
     11126**DCL     12036<<ASSIGN
XUG_INIT.SYNTAX#
     11109**DCL     12031<<ASSIGN
XUG_INIT.WORK_
     10972**DCL     12030<<ASSIGN
XUG_INIT_C
     11265**DCL     12029>>ASSIGN
XUR$INIT
     12027**ENTRY   11929--CALL    11971--CALL    11990--CALL    12002--CALL    12014--CALL
XUR$XUGERR2XUR
     12071**ENTRY   11962--CALL    12056--CALL
XUR_INIT.ABORT$
     11688**DCL     12041>>ASSIGN
XUR_INIT.ADAPT$$
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:80   
     11752**DCL     12047>>ASSIGN
XUR_INIT.BRKMSG$
     11690**DCL     12043>>ASSIGN
XUR_INIT.COMMANDS#
     11681**DCL     12033>>ASSIGN
XUR_INIT.CONTINUE$
     11689**DCL     12042>>ASSIGN
XUR_INIT.DONT_REREAD_CCBUF#
     11684**DCL     12037>>ASSIGN
XUR_INIT.DONT_STRIP_PROMPT#
     11685**DCL     12038>>ASSIGN
XUR_INIT.ECHO#
     11703**DCL     12039>>ASSIGN
XUR_INIT.GOODCMD#
     11682**DCL     12035>>ASSIGN
XUR_INIT.INHIBITS
     11708**DCL     12034>>ASSIGN
XUR_INIT.MOREMEM$$
     11700**DCL     12048>>ASSIGN
XUR_INIT.PASS#
     11704**DCL     12040>>ASSIGN
XUR_INIT.PCB$
     11691**DCL     12051>>ASSIGN
XUR_INIT.POST_EXEC$$
     11699**DCL     12045>>ASSIGN
XUR_INIT.PPCB$
     11698**DCL     12049>>ASSIGN
XUR_INIT.PP_DCB#
     11702**DCL     12050>>ASSIGN
XUR_INIT.PREPROCESS#
     11680**DCL     12032>>ASSIGN
XUR_INIT.PREPROCESSOR$$
     11707**DCL     12046>>ASSIGN
XUR_INIT.PRE_EXEC$$
     11697**DCL     12044>>ASSIGN
XUR_INIT.PROCACCT_
PL6.E3A0      #001=XUR$GETCMD File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:81   
     11706**DCL     12052>>ASSIGN
XUR_INIT.PROCNAME_
     11701**DCL     12053>>ASSIGN
XUR_INIT.SPELLING#
     11683**DCL     12036>>ASSIGN
XUR_INIT.SYNTAX#
     11679**DCL     12031>>ASSIGN
XUR_INIT.WORKR_
     11692**DCL     11693--REDEF   12030>>ASSIGN
XUR_INIT$
     11855**DCL     11678--IMP-PTR 12028<<ASSIGN  12030>>ASSIGN  12031>>ASSIGN  12032>>ASSIGN  12033>>ASSIGN
     12034>>ASSIGN  12035>>ASSIGN  12036>>ASSIGN  12037>>ASSIGN  12038>>ASSIGN  12039>>ASSIGN  12040>>ASSIGN
     12041>>ASSIGN  12042>>ASSIGN  12043>>ASSIGN  12044>>ASSIGN  12045>>ASSIGN  12046>>ASSIGN  12047>>ASSIGN
     12048>>ASSIGN  12049>>ASSIGN  12050>>ASSIGN  12051>>ASSIGN  12052>>ASSIGN  12053>>ASSIGN
XUR_INIT_C
     11777**DCL     11929<>CALL    11971<>CALL    11990<>CALL    12002<>CALL    12014<>CALL
XUR_INIT_C.WORKR_
     11791**DCL     11792--REDEF

PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:82   
      591        1        /*T***********************************************************/
      592        2        /*T*                                                         */
      593        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      594        4        /*T*                                                         */
      595        5        /*T***********************************************************/
      596        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      597        7        /* ROUTINE TO DO CORRESPONDENCE CHECKING, ECHOING, ETC. */
      598        8        XUR$CORRES: PROC(DCB1,DCB2) ALTRET;
      599        9        /**/
      600       10    1   DCL DCB1 SBIN WORD ;
      601       11    1   DCL DCB2 SBIN WORD ;
      602       12        %EJECT;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:83   
      603       13        %INCLUDE XU_MACRO_C;
      604     3119        %INCLUDE XU_SUBS_C;
      605     3211    1   DCL XUG$CORRES ENTRY(2) ALTRET ;
      606     3212    1   DCL XUG$ECHOLAST ENTRY(1) ALTRET ;
      607     3213        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF);
      608     3551        /**/
      609     3552        %EJECT;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:84   
      610     3553    1       CALL XUG$CORRES(DCB1,DCB2) ALTRET(CORRES) ;
      611     3554    1       RETURN;
      612     3555    1   CORRES: ALTRETURN;
      613     3556        %EJECT;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:85   
      614     3557    1   XUR$ECHOLAST: ENTRY(DCB1) ALTRET;
      615     3558    1       IF ADDR(DCB1) ~= ADDR(NIL)
      616     3559    1       THEN
      617     3560    1           GETCMD.DCB_PARAM# = DCB1 ;
      618     3561    1       ELSE
      619     3562    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;
      620     3563    1       CALL XUG$ECHOLAST (GETCMD) ALTRET(ECHOLAST) ;
      621     3564    1   ECHOLAST:
      622     3565    1       RETURN;
      623     3566
      624     3567    1   END XUR$CORRES;
      625     3568        %EOD;

PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:86   
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$CORRES.

   Procedure XUR$CORRES requires 23 words for executable code.
   Procedure XUR$CORRES requires 6 words of local(AUTO) storage.

PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:87   

 Object Unit name= XUR$CORRES                                 File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:42:53.00 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    23     27  XUR$CORRES
    1  RoData even  none     1      1  XUR$CORRES

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  XUR$CORRES
     0     10          yes     yes      Std        1  XUR$ECHOLAST

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$CORRES
 yes     yes           Std       1 XUG$ECHOLAST
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     GETCMD                                B_VECTNIL
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:88   

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:89   


      591        1        /*T***********************************************************/
      592        2        /*T*                                                         */
      593        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      594        4        /*T*                                                         */
      595        5        /*T***********************************************************/
      596        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      597        7        /* ROUTINE TO DO CORRESPONDENCE CHECKING, ECHOING, ETC. */
      598        8        XUR$CORRES: PROC(DCB1,DCB2) ALTRET;

      8  0 000000   000000 700200 xent  XUR$CORRES   TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      599        9        /**/
      600       10    1   DCL DCB1 SBIN WORD ;
      601       11    1   DCL DCB2 SBIN WORD ;
      602       12        %EJECT;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:90   
      603       13        %INCLUDE XU_MACRO_C;
      604     3119        %INCLUDE XU_SUBS_C;
      605     3211    1   DCL XUG$CORRES ENTRY(2) ALTRET ;
      606     3212    1   DCL XUG$ECHOLAST ENTRY(1) ALTRET ;
      607     3213        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF);
      608     3551        /**/
      609     3552        %EJECT;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:91   
      610     3553    1       CALL XUG$CORRES(DCB1,DCB2) ALTRET(CORRES) ;

   3553  0 000002   200003 630500                    EPPR0   @DCB1,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$CORRES
         0 000005   000007 702000 0                  TSX2    CORRES

      611     3554    1       RETURN;

   3554  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      612     3555    1   CORRES: ALTRETURN;

   3555  0 000007   000000 702200 xent  CORRES       TSX2  ! X66_AALT

      613     3556        %EJECT;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:92   
      614     3557    1   XUR$ECHOLAST: ENTRY(DCB1) ALTRET;

   3557  0 000010   000000 700200 xent  XUR$ECHOLAST TSX0  ! X66_AUTO_2
         0 000011   000006 000002                    ZERO    6,2

      615     3558    1       IF ADDR(DCB1) ~= ADDR(NIL)

   3558  0 000012   200003 236100                    LDQ     @DCB1,,AUTO
         0 000013   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000014   000021 600000 0                  TZE     s:3562

      616     3559    1       THEN
      617     3560    1           GETCMD.DCB_PARAM# = DCB1 ;

   3560  0 000015   200003 470500                    LDP0    @DCB1,,AUTO
         0 000016   000000 235100                    LDA     0,,PR0
         0 000017   000014 755000 xsym               STA     GETCMD+12
         0 000020   000022 710000 0                  TRA     s:3563

      618     3561    1       ELSE
      619     3562    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;

   3562  0 000021   000014 450000 xsym               STZ     GETCMD+12

      620     3563    1       CALL XUG$ECHOLAST (GETCMD) ALTRET(ECHOLAST) ;

   3563  0 000022   000000 630400 1                  EPPR0   0
         0 000023   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000024   000000 701000 xent               TSX1    XUG$ECHOLAST
         0 000025   000026 702000 0                  TSX2    ECHOLAST

      621     3564    1   ECHOLAST:
      622     3565    1       RETURN;

   3565  0 000026   000000 702200 xent  ECHOLAST     TSX2  ! X66_ARET
      623     3566
      624     3567    1   END XUR$CORRES;
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:93   
      625     3568        %EOD;

PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:94   
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$CORRES.
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:95   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @DCB1                      4-0-0/w PTR         r     1 @DCB2
    *0-0-0/w SBIN        r     1 DCB1                      *0-0-0/w SBIN        r     1 DCB2

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$CORRES requires 23 words for executable code.
   Procedure XUR$CORRES requires 6 words of local(AUTO) storage.
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:96   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=XUR$CORRES File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:42 Page:97   
          MINI XREF LISTING

CORRES
      3555**LABEL    3553--CALLALT
DCB1
        10**DCL         8--PROC     3553<>CALL     3557--ENTRY    3558--IF       3560>>ASSIGN
DCB2
        11**DCL         8--PROC     3553<>CALL
ECHOLAST
      3565**LABEL    3563--CALLALT
GETCMD
      3226**DCL      3563<>CALL
GETCMD.DCB_PARAM#
      3406**DCL      3560<<ASSIGN   3562<<ASSIGN
GETCMD.OUT$
      3231**DCL      3237--REDEF
XUG$CORRES
      3211**DCL-ENT  3553--CALL
XUG$ECHOLAST
      3212**DCL-ENT  3563--CALL

PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:98   
      626        1        /*T***********************************************************/
      627        2        /*T*                                                         */
      628        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      629        4        /*T*                                                         */
      630        5        /*T***********************************************************/
      631        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      632        7        XUR$BREAK: PROC ASYNC;
      633        8        /**/
      634        9        %INCLUDE XU_MACRO_C ;
      635     3115        /**/
      636     3116        %XUG_GETCMD (NAME=GETCMD,STCLASS=SYMREF);
      637     3454    1   DCL XUG$BREAK_COMMON ENTRY(1) ;
      638     3455        /**/
      639     3456        %EJECT;
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:99   
      640     3457    2       DO INHIBIT;
      641     3458    2           CALL XUG$BREAK_COMMON (GETCMD.WORK$) ;
      642     3459    2           RETURN;
      643     3460    2       END;
      644     3461    1   END XUR$BREAK;
      645     3462        %EOD;

PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:100  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$BREAK.

   Procedure XUR$BREAK requires 8 words for executable code.
   Procedure XUR$BREAK requires 4 words of local(AUTO) storage.

PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:101  

 Object Unit name= XUR$BREAK                                  File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:42:58.20 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     8     10  XUR$BREAK
    1  RoData even  none     1      1  XUR$BREAK

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes     Async       0  XUR$BREAK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$BREAK_COMMON
                       nStd      0 X66_AAUTO
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     GETCMD                                B_VECTNIL
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:102  

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:103  


      626        1        /*T***********************************************************/
      627        2        /*T*                                                         */
      628        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      629        4        /*T*                                                         */
      630        5        /*T***********************************************************/
      631        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      632        7        XUR$BREAK: PROC ASYNC;

      7  0 000000   000000 700200 xent  XUR$BREAK    TSX0  ! X66_AAUTO
         0 000001   000004 000000                    ZERO    4,0

      633        8        /**/
      634        9        %INCLUDE XU_MACRO_C ;
      635     3115        /**/
      636     3116        %XUG_GETCMD (NAME=GETCMD,STCLASS=SYMREF);
      637     3454    1   DCL XUG$BREAK_COMMON ENTRY(1) ;
      638     3455        /**/
      639     3456        %EJECT;
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:104  
      640     3457    2       DO INHIBIT;

      641     3458    2           CALL XUG$BREAK_COMMON (GETCMD.WORK$) ;

   3458  0 000002   000000 630600 1                  EPPR0 ! 0
         0 000003   000017 631600 xsym               EPPR1 ! B_VECTNIL+15
         0 000004   000000 701200 xent               TSX1  ! XUG$BREAK_COMMON
         0 000005   000000 011200                    NOP   ! 0

      642     3459    2           RETURN;

   3459  0 000006   000000 702200 xent               TSX2  ! X66_AARET

      643     3460    2       END;

      644     3461    1   END XUR$BREAK;

   3461  0 000007   000000 702200 xent               TSX2  ! X66_AARET
      645     3462        %EOD;

PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:105  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$BREAK.
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:106  

 **** Variables and constants ****

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$BREAK requires 8 words for executable code.
   Procedure XUR$BREAK requires 4 words of local(AUTO) storage.
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:107  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=XUR$BREAK File=XUR$GETCMD.:E05TSI                             WED 07/30/97 09:42 Page:108  
          MINI XREF LISTING

GETCMD.OUT$
      3134**DCL      3140--REDEF
GETCMD.WORK$
      3162**DCL      3458<>CALL
XUG$BREAK_COMMON
      3454**DCL-ENT  3458--CALL

PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:109  
      646        1        /*T***********************************************************/
      647        2        /*T*                                                         */
      648        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      649        4        /*T*                                                         */
      650        5        /*T***********************************************************/
      651        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      652        7        XUR$DISABLE: PROC;
      653        8    1   DCL XUG$DISABLE ENTRY(1) ;
      654        9    1   DCL XUG$CLRENABLE ENTRY(1) ;
      655       10    1   DCL XUG$ENABLE ENTRY(1) ;
      656       11    1   DCL XUG$SIMULATE_BREAK ENTRY (1);
      657       12        /**/
      658       13        %INCLUDE XU_MACRO_C ;
      659     3119        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF) ;
      660     3457        /**/
      661     3458        %EJECT;
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:110  
      662     3459    1       CALL XUG$DISABLE(GETCMD) ;
      663     3460    1       RETURN ;
      664     3461
      665     3462    1   XUR$CLRENABLE: ENTRY;
      666     3463    1       CALL XUG$CLRENABLE(GETCMD) ;
      667     3464    1       RETURN ;
      668     3465
      669     3466    1   XUR$ENABLE: ENTRY;
      670     3467    1       CALL XUG$ENABLE(GETCMD) ;
      671     3468    1       RETURN;
      672     3469    1   XUR$SIMULATE_BREAK: ENTRY;
      673     3470    1       CALL XUG$SIMULATE_BREAK(GETCMD);
      674     3471    1       RETURN;
      675     3472        /**/
      676     3473    1   END XUR$DISABLE;
      677     3474        %EOD;

PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:111  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$DISABLE.

   Procedure XUR$DISABLE requires 28 words for executable code.
   Procedure XUR$DISABLE requires 4 words of local(AUTO) storage.

PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:112  

 Object Unit name= XUR$DISABLE                                File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:02.68 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    28     34  XUR$DISABLE
    1  RoData even  none     1      1  XUR$DISABLE

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        0  XUR$DISABLE
     0      7                  yes      Std        0  XUR$CLRENABLE
     0     16                  yes      Std        0  XUR$ENABLE
     0     25                  yes      Std        0  XUR$SIMULATE_BREAK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$DISABLE
         yes           Std       1 XUG$CLRENABLE
         yes           Std       1 XUG$SIMULATE_BREAK
         yes           Std       1 XUG$ENABLE
                       nStd      0 X66_AUTO_0
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:113  

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     GETCMD                                B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:114  


      646        1        /*T***********************************************************/
      647        2        /*T*                                                         */
      648        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      649        4        /*T*                                                         */
      650        5        /*T***********************************************************/
      651        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      652        7        XUR$DISABLE: PROC;

      7  0 000000   000000 700200 xent  XUR$DISABLE  TSX0  ! X66_AUTO_0
         0 000001   000004 000000                    ZERO    4,0

      653        8    1   DCL XUG$DISABLE ENTRY(1) ;
      654        9    1   DCL XUG$CLRENABLE ENTRY(1) ;
      655       10    1   DCL XUG$ENABLE ENTRY(1) ;
      656       11    1   DCL XUG$SIMULATE_BREAK ENTRY (1);
      657       12        /**/
      658       13        %INCLUDE XU_MACRO_C ;
      659     3119        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF) ;
      660     3457        /**/
      661     3458        %EJECT;
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:115  
      662     3459    1       CALL XUG$DISABLE(GETCMD) ;

   3459  0 000002   000000 630400 1                  EPPR0   0
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$DISABLE
         0 000005   000000 011000                    NOP     0

      663     3460    1       RETURN ;

   3460  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      664     3461
      665     3462    1   XUR$CLRENABLE: ENTRY;

   3462  0 000007   000000 700200 xent  XUR$CLRENAB* TSX0  ! X66_AUTO_0
         0 000010   000004 000000                    ZERO    4,0

      666     3463    1       CALL XUG$CLRENABLE(GETCMD) ;

   3463  0 000011   000000 630400 1                  EPPR0   0
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$CLRENABLE
         0 000014   000000 011000                    NOP     0

      667     3464    1       RETURN ;

   3464  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      668     3465
      669     3466    1   XUR$ENABLE: ENTRY;

   3466  0 000016   000000 700200 xent  XUR$ENABLE   TSX0  ! X66_AUTO_0
         0 000017   000004 000000                    ZERO    4,0

      670     3467    1       CALL XUG$ENABLE(GETCMD) ;

   3467  0 000020   000000 630400 1                  EPPR0   0
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:116  
         0 000021   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000022   000000 701000 xent               TSX1    XUG$ENABLE
         0 000023   000000 011000                    NOP     0

      671     3468    1       RETURN;

   3468  0 000024   000000 702200 xent               TSX2  ! X66_ARET

      672     3469    1   XUR$SIMULATE_BREAK: ENTRY;

   3469  0 000025   000000 700200 xent  XUR$SIMULAT* TSX0  ! X66_AUTO_0
         0 000026   000004 000000                    ZERO    4,0

      673     3470    1       CALL XUG$SIMULATE_BREAK(GETCMD);

   3470  0 000027   000000 630400 1                  EPPR0   0
         0 000030   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000031   000000 701000 xent               TSX1    XUG$SIMULATE_BREAK
         0 000032   000000 011000                    NOP     0

      674     3471    1       RETURN;

   3471  0 000033   000000 702200 xent               TSX2  ! X66_ARET
      675     3472        /**/
      676     3473    1   END XUR$DISABLE;
      677     3474        %EOD;

PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:117  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$DISABLE.
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:118  

 **** Variables and constants ****

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$DISABLE requires 28 words for executable code.
   Procedure XUR$DISABLE requires 4 words of local(AUTO) storage.
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:119  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=XUR$DISABLE File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:120  
          MINI XREF LISTING

GETCMD
      3132**DCL      3459<>CALL     3463<>CALL     3467<>CALL     3470<>CALL
GETCMD.OUT$
      3137**DCL      3143--REDEF
XUG$CLRENABLE
         9**DCL-ENT  3463--CALL
XUG$DISABLE
         8**DCL-ENT  3459--CALL
XUG$ENABLE
        10**DCL-ENT  3467--CALL
XUG$SIMULATE_BREAK
        11**DCL-ENT  3470--CALL

PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:121  
      678        1        /*T***********************************************************/
      679        2        /*T*                                                         */
      680        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      681        4        /*T*                                                         */
      682        5        /*T***********************************************************/
      683        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      684        7        /* XUR$ERRMSG - ERROR MESSAGE HANDLING ROUTINES FOR DEF */
      685        8        /**/
      686        9        XUR$ERRMSG: PROC (CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      687       10        /**/
      688       11    1   DCL CODE BIT(36) ALIGNED;
      689       12    1   DCL 1 ERR_CODE REDEF CODE,
      690       13    1         2 FCG# BIT(18),
      691       14    1         2 MON# BIT(1),
      692       15    1         2 CODE# UBIN(14) UNAL,
      693       16    1         2 SEV# UBIN(3) UNAL ;
      694       17    1   DCL DCB# SBIN;
      695       18    1   DCL OUTDCB UBIN;
      696       19    1   DCL F1 VECTOR ALIGNED;
      697       20    1   DCL F2 VECTOR ALIGNED;
      698       21    1   DCL F3 VECTOR ALIGNED;
      699       22    1   DCL FLGLEV SBIN;
      700       23        /**/
      701       24    1   DCL XUG$ERRMSG ENTRY(1) ALTRET;
      702       25    1   DCL XUG$SETERRMSG ENTRY(1) ALTRET ;
      703       26        /**/
      704       27        %INCLUDE XU_MACRO_C;
      705     3133        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF) ;
      706     3471    1   DCL FID$ PTR ;
      707     3472        %EJECT;
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:122  
      708     3473    1       GETCMD.INFOMSG# = '0'B ;
      709     3474    1   ERRMSG: ;
      710     3475    1       IF ADDR(CODE)=ADDR(NIL)
      711     3476    1       THEN
      712     3477    1           GETCMD.ERR_CODE = '0'B ;
      713     3478    1       ELSE
      714     3479    1           GETCMD.ERR_CODE = ERR_CODE ;
      715     3480    1       IF ADDR(DCB#) = ADDR(NIL)
      716     3481    1       THEN
      717     3482    1           GETCMD.ERRDCB# = DCBNUM(NIL) ;
      718     3483    1       ELSE
      719     3484    1           GETCMD.ERRDCB# = DCB# ;
      720     3485    1       IF ADDR(OUTDCB)=ADDR(NIL)
      721     3486    1       THEN
      722     3487    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;
      723     3488    1       ELSE
      724     3489    1           GETCMD.DCB_PARAM# = OUTDCB;
      725     3490    1       GETCMD.DCB2_PARAM# = DCBNUM(NIL);
      726     3491    1       IF ADDR(F1) = ADDR(NIL)
      727     3492    1       THEN
      728     3493    1           GETCMD.F1_ = VECTOR(NIL) ;
      729     3494    1       ELSE
      730     3495    1           GETCMD.F1_ = F1;
      731     3496    1       IF ADDR(F2) = ADDR(NIL)
      732     3497    1       THEN
      733     3498    1           GETCMD.F2_ = VECTOR(NIL) ;
      734     3499    1       ELSE
      735     3500    1           GETCMD.F2_ = F2;
      736     3501    1       IF ADDR(F3) = ADDR(NIL)
      737     3502    1       THEN
      738     3503    1           GETCMD.F3_ = VECTOR(NIL) ;
      739     3504    1       ELSE
      740     3505    1           GETCMD.F3_ = F3;
      741     3506    1       IF ADDR(FLGLEV) = ADDR(NIL)
      742     3507    1       THEN
      743     3508    1           GETCMD.FLGLEV# = 0 ;
      744     3509    1       ELSE
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:123  
      745     3510    1           GETCMD.FLGLEV# = FLGLEV ;
      746     3511    1       CALL XUG$ERRMSG (GETCMD) ALTRET(ALT) ;
      747     3512
      748     3513    1       RETURN;
      749     3514    1   XUR$INFOMSG: ENTRY (CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      750     3515    1       GETCMD.INFOMSG# = '1'B ;
      751     3516    1       GOTO ERRMSG ;
      752     3517        %EJECT;
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:124  
      753     3518    1   XUR$SETERRMSG: ENTRY(CODE) ALTRET;
      754     3519    1       FID$=ADDR(CODE);
      755     3520    1       IF FID$=ADDR(NIL)
      756     3521    1       THEN
      757     3522    1           GETCMD.ERRMFID$ = ADDR(NIL) ;
      758     3523    1       ELSE
      759     3524    1           GETCMD.ERRMFID$ = FID$ ;
      760     3525    1       CALL XUG$SETERRMSG (GETCMD) ALTRET (ALT) ;
      761     3526    1       RETURN;
      762     3527    1   ALT: ALTRETURN;
      763     3528    1   END XUR$ERRMSG;
      764     3529        %EOD;

PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:125  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$ERRMSG.

   Procedure XUR$ERRMSG requires 98 words for executable code.
   Procedure XUR$ERRMSG requires 12 words of local(AUTO) storage.

PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:126  

 Object Unit name= XUR$ERRMSG                                 File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:07.52 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    98    142  XUR$ERRMSG
    1  RoData even  none     4      4  XUR$ERRMSG

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        7  XUR$ERRMSG
     0    115          yes     yes      Std        7  XUR$INFOMSG
     0    122          yes     yes      Std        1  XUR$SETERRMSG

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$ERRMSG
 yes     yes           Std       1 XUG$SETERRMSG
                       nStd      0 X66_AUTO_N
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:127  

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     GETCMD                                B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     NULLSID                               ISSID
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:128  


      678        1        /*T***********************************************************/
      679        2        /*T*                                                         */
      680        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      681        4        /*T*                                                         */
      682        5        /*T***********************************************************/
      683        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      684        7        /* XUR$ERRMSG - ERROR MESSAGE HANDLING ROUTINES FOR DEF */
      685        8        /**/
      686        9        XUR$ERRMSG: PROC (CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;

      9  0 000000   000000 700200 xent  XUR$ERRMSG   TSX0  ! X66_AUTO_N
         0 000001   000014 000007                    ZERO    12,7

      687       10        /**/
      688       11    1   DCL CODE BIT(36) ALIGNED;
      689       12    1   DCL 1 ERR_CODE REDEF CODE,
      690       13    1         2 FCG# BIT(18),
      691       14    1         2 MON# BIT(1),
      692       15    1         2 CODE# UBIN(14) UNAL,
      693       16    1         2 SEV# UBIN(3) UNAL ;
      694       17    1   DCL DCB# SBIN;
      695       18    1   DCL OUTDCB UBIN;
      696       19    1   DCL F1 VECTOR ALIGNED;
      697       20    1   DCL F2 VECTOR ALIGNED;
      698       21    1   DCL F3 VECTOR ALIGNED;
      699       22    1   DCL FLGLEV SBIN;
      700       23        /**/
      701       24    1   DCL XUG$ERRMSG ENTRY(1) ALTRET;
      702       25    1   DCL XUG$SETERRMSG ENTRY(1) ALTRET ;
      703       26        /**/
      704       27        %INCLUDE XU_MACRO_C;
      705     3133        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF) ;
      706     3471    1   DCL FID$ PTR ;
      707     3472        %EJECT;
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:129  
      708     3473    1       GETCMD.INFOMSG# = '0'B ;

   3473  0 000002   000000 236000 1                  LDQ     0
         0 000003   000006 356000 xsym               ANSQ    GETCMD+6

   3473  0 000004                       ERRMSG       null
      709     3474    1   ERRMSG: ;
      710     3475    1       IF ADDR(CODE)=ADDR(NIL)

   3475  0 000004   200003 236100                    LDQ     @CODE,,AUTO
         0 000005   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000006   000011 601000 0                  TNZ     s:3479

      711     3476    1       THEN
      712     3477    1           GETCMD.ERR_CODE = '0'B ;

   3477  0 000007   000010 450000 xsym               STZ     GETCMD+8
         0 000010   000014 710000 0                  TRA     s:3480

      713     3478    1       ELSE
      714     3479    1           GETCMD.ERR_CODE = ERR_CODE ;

   3479  0 000011   200003 470500                    LDP0    @CODE,,AUTO
         0 000012   000000 236100                    LDQ     0,,PR0
         0 000013   000010 756000 xsym               STQ     GETCMD+8

      715     3480    1       IF ADDR(DCB#) = ADDR(NIL)

   3480  0 000014   200004 236100                    LDQ     @DCB#,,AUTO
         0 000015   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000016   000021 601000 0                  TNZ     s:3484

      716     3481    1       THEN
      717     3482    1           GETCMD.ERRDCB# = DCBNUM(NIL) ;

   3482  0 000017   000011 450000 xsym               STZ     GETCMD+9
         0 000020   000024 710000 0                  TRA     s:3485
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:130  

      718     3483    1       ELSE
      719     3484    1           GETCMD.ERRDCB# = DCB# ;

   3484  0 000021   200004 470500                    LDP0    @DCB#,,AUTO
         0 000022   000000 235100                    LDA     0,,PR0
         0 000023   000011 755000 xsym               STA     GETCMD+9

      720     3485    1       IF ADDR(OUTDCB)=ADDR(NIL)

   3485  0 000024   200005 236100                    LDQ     @OUTDCB,,AUTO
         0 000025   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000026   000031 601000 0                  TNZ     s:3489

      721     3486    1       THEN
      722     3487    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;

   3487  0 000027   000014 450000 xsym               STZ     GETCMD+12
         0 000030   000034 710000 0                  TRA     s:3490

      723     3488    1       ELSE
      724     3489    1           GETCMD.DCB_PARAM# = OUTDCB;

   3489  0 000031   200005 470500                    LDP0    @OUTDCB,,AUTO
         0 000032   000000 235100                    LDA     0,,PR0
         0 000033   000014 755000 xsym               STA     GETCMD+12

      725     3490    1       GETCMD.DCB2_PARAM# = DCBNUM(NIL);

   3490  0 000034   000015 450000 xsym               STZ     GETCMD+13

      726     3491    1       IF ADDR(F1) = ADDR(NIL)

   3491  0 000035   200006 236100                    LDQ     @F1,,AUTO
         0 000036   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000037   000044 601000 0                  TNZ     s:3495

PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:131  
      727     3492    1       THEN
      728     3493    1           GETCMD.F1_ = VECTOR(NIL) ;

   3493  0 000040   000002 237000 1                  LDAQ    2
         0 000041   000017 755000 xsym               STA     GETCMD+15
         0 000042   000020 756000 xsym               STQ     GETCMD+16
         0 000043   000050 710000 0                  TRA     s:3496

      729     3494    1       ELSE
      730     3495    1           GETCMD.F1_ = F1;

   3495  0 000044   200006 470500                    LDP0    @F1,,AUTO
         0 000045   000000 100500                    MLR     fill='000'O
         0 000046   000000 000010                    ADSC9   0,,PR0                   cn=0,n=8
         0 000047   000017 000010 xsym               ADSC9   GETCMD+15                cn=0,n=8

      731     3496    1       IF ADDR(F2) = ADDR(NIL)

   3496  0 000050   200007 236100                    LDQ     @F2,,AUTO
         0 000051   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000052   000057 601000 0                  TNZ     s:3500

      732     3497    1       THEN
      733     3498    1           GETCMD.F2_ = VECTOR(NIL) ;

   3498  0 000053   000002 237000 1                  LDAQ    2
         0 000054   000021 755000 xsym               STA     GETCMD+17
         0 000055   000022 756000 xsym               STQ     GETCMD+18
         0 000056   000063 710000 0                  TRA     s:3501

      734     3499    1       ELSE
      735     3500    1           GETCMD.F2_ = F2;

   3500  0 000057   200007 470500                    LDP0    @F2,,AUTO
         0 000060   000000 100500                    MLR     fill='000'O
         0 000061   000000 000010                    ADSC9   0,,PR0                   cn=0,n=8
         0 000062   000021 000010 xsym               ADSC9   GETCMD+17                cn=0,n=8
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:132  

      736     3501    1       IF ADDR(F3) = ADDR(NIL)

   3501  0 000063   200010 236100                    LDQ     @F3,,AUTO
         0 000064   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000065   000072 601000 0                  TNZ     s:3505

      737     3502    1       THEN
      738     3503    1           GETCMD.F3_ = VECTOR(NIL) ;

   3503  0 000066   000002 237000 1                  LDAQ    2
         0 000067   000023 755000 xsym               STA     GETCMD+19
         0 000070   000024 756000 xsym               STQ     GETCMD+20
         0 000071   000076 710000 0                  TRA     s:3506

      739     3504    1       ELSE
      740     3505    1           GETCMD.F3_ = F3;

   3505  0 000072   200010 470500                    LDP0    @F3,,AUTO
         0 000073   000000 100500                    MLR     fill='000'O
         0 000074   000000 000010                    ADSC9   0,,PR0                   cn=0,n=8
         0 000075   000023 000010 xsym               ADSC9   GETCMD+19                cn=0,n=8

      741     3506    1       IF ADDR(FLGLEV) = ADDR(NIL)

   3506  0 000076   200011 236100                    LDQ     @FLGLEV,,AUTO
         0 000077   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000100   000104 601000 0                  TNZ     s:3510

      742     3507    1       THEN
      743     3508    1           GETCMD.FLGLEV# = 0 ;

   3508  0 000101   000000 236003                    LDQ     0,DU
         0 000102   000006 552020 xsym               STBQ    GETCMD+6,'20'O
         0 000103   000110 710000 0                  TRA     s:3511

      744     3509    1       ELSE
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:133  
      745     3510    1           GETCMD.FLGLEV# = FLGLEV ;

   3510  0 000104   200011 470500                    LDP0    @FLGLEV,,AUTO
         0 000105   000000 236100                    LDQ     0,,PR0
         0 000106   000022 736000                    QLS     18
         0 000107   000006 552020 xsym               STBQ    GETCMD+6,'20'O

      746     3511    1       CALL XUG$ERRMSG (GETCMD) ALTRET(ALT) ;

   3511  0 000110   000001 630400 1                  EPPR0   1
         0 000111   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000112   000000 701000 xent               TSX1    XUG$ERRMSG
         0 000113   000141 702000 0                  TSX2    ALT

      747     3512
      748     3513    1       RETURN;

   3513  0 000114   000000 702200 xent               TSX2  ! X66_ARET

      749     3514    1   XUR$INFOMSG: ENTRY (CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;

   3514  0 000115   000000 700200 xent  XUR$INFOMSG  TSX0  ! X66_AUTO_N
         0 000116   000014 000007                    ZERO    12,7

      750     3515    1       GETCMD.INFOMSG# = '1'B ;

   3515  0 000117   001000 236003                    LDQ     512,DU
         0 000120   000006 256000 xsym               ORSQ    GETCMD+6

      751     3516    1       GOTO ERRMSG ;

   3516  0 000121   000004 710000 0                  TRA     ERRMSG

      752     3517        %EJECT;
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:134  
      753     3518    1   XUR$SETERRMSG: ENTRY(CODE) ALTRET;

   3518  0 000122   000000 700200 xent  XUR$SETERRM* TSX0  ! X66_AUTO_N
         0 000123   000014 000007                    ZERO    12,7

      754     3519    1       FID$=ADDR(CODE);

   3519  0 000124   200003 236100                    LDQ     @CODE,,AUTO
         0 000125   200012 756100                    STQ     FID$,,AUTO

      755     3520    1       IF FID$=ADDR(NIL)

   3520  0 000126   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000127   000133 601000 0                  TNZ     s:3524

      756     3521    1       THEN
      757     3522    1           GETCMD.ERRMFID$ = ADDR(NIL) ;

   3522  0 000130   000001 236000 xsym               LDQ     B_VECTNIL+1
         0 000131   000002 756000 xsym               STQ     GETCMD+2
         0 000132   000134 710000 0                  TRA     s:3525

      758     3523    1       ELSE
      759     3524    1           GETCMD.ERRMFID$ = FID$ ;

   3524  0 000133   000002 756000 xsym               STQ     GETCMD+2

      760     3525    1       CALL XUG$SETERRMSG (GETCMD) ALTRET (ALT) ;

   3525  0 000134   000001 630400 1                  EPPR0   1
         0 000135   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000136   000000 701000 xent               TSX1    XUG$SETERRMSG
         0 000137   000141 702000 0                  TSX2    ALT

      761     3526    1       RETURN;

   3526  0 000140   000000 702200 xent               TSX2  ! X66_ARET
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:135  

      762     3527    1   ALT: ALTRETURN;

   3527  0 000141   000000 702200 xent  ALT          TSX2  ! X66_AALT
      763     3528    1   END XUR$ERRMSG;
      764     3529        %EOD;

PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:136  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$ERRMSG.
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:137  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @CODE                      4-0-0/w PTR         r     1 @DCB#
     6-0-0/w PTR         r     1 @F1                        7-0-0/w PTR         r     1 @F2
    10-0-0/w PTR         r     1 @F3                       11-0-0/w PTR         r     1 @FLGLEV
     5-0-0/w PTR         r     1 @OUTDCB                   *0-0-0/w BIT         r     1 CODE
    *0-0-0/w SBIN        r     1 DCB#                      *0-0-0/w STRC        r     1 ERR_CODE
    *0-0-0/w VECT        r     1 F1                        *0-0-0/w VECT        r     1 F2
    *0-0-0/w VECT        r     1 F3                        12-0-0/w PTR         r     1 FID$
    *0-0-0/w SBIN        r     1 FLGLEV                    *0-0-0/w UBIN        r     1 OUTDCB

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$ERRMSG requires 98 words for executable code.
   Procedure XUR$ERRMSG requires 12 words of local(AUTO) storage.
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:138  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:139  
          MINI XREF LISTING

ALT
      3527**LABEL    3511--CALLALT  3525--CALLALT
CODE
        11**DCL         9--PROC       12--REDEF    3475--IF       3514--ENTRY    3518--ENTRY    3519--ASSIGN
DCB#
        17**DCL         9--PROC     3480--IF       3484>>ASSIGN   3514--ENTRY
ERRMSG
      3473**LABEL    3516--GOTO
ERR_CODE
        12**DCL      3479>>ASSIGN
F1
        19**DCL         9--PROC     3491--IF       3495>>ASSIGN   3514--ENTRY
F2
        20**DCL         9--PROC     3496--IF       3500>>ASSIGN   3514--ENTRY
F3
        21**DCL         9--PROC     3501--IF       3505>>ASSIGN   3514--ENTRY
FID$
      3471**DCL      3519<<ASSIGN   3520>>IF       3524>>ASSIGN
FLGLEV
        22**DCL         9--PROC     3506--IF       3510>>ASSIGN   3514--ENTRY
GETCMD
      3146**DCL      3511<>CALL     3525<>CALL
GETCMD.DCB2_PARAM#
      3331**DCL      3490<<ASSIGN
GETCMD.DCB_PARAM#
      3326**DCL      3487<<ASSIGN   3489<<ASSIGN
GETCMD.ERRDCB#
      3305**DCL      3482<<ASSIGN   3484<<ASSIGN
GETCMD.ERRMFID$
      3165**DCL      3522<<ASSIGN   3524<<ASSIGN
GETCMD.ERR_CODE
      3294**DCL      3477<<ASSIGN   3479<<ASSIGN
PL6.E3A0      #005=XUR$ERRMSG File=XUR$GETCMD.:E05TSI                            WED 07/30/97 09:43 Page:140  
GETCMD.F1_
      3343**DCL      3493<<ASSIGN   3495<<ASSIGN
GETCMD.F2_
      3347**DCL      3498<<ASSIGN   3500<<ASSIGN
GETCMD.F3_
      3351**DCL      3503<<ASSIGN   3505<<ASSIGN
GETCMD.FLGLEV#
      3251**DCL      3508<<ASSIGN   3510<<ASSIGN
GETCMD.INFOMSG#
      3242**DCL      3473<<ASSIGN   3515<<ASSIGN
GETCMD.OUT$
      3151**DCL      3157--REDEF
OUTDCB
        18**DCL         9--PROC     3485--IF       3489>>ASSIGN   3514--ENTRY
XUG$ERRMSG
        24**DCL-ENT  3511--CALL
XUG$SETERRMSG
        25**DCL-ENT  3525--CALL

PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:141  
      765        1        /*T***********************************************************/
      766        2        /*T*                                                         */
      767        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      768        4        /*T*                                                         */
      769        5        /*T***********************************************************/
      770        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      771        7        XUR$HELP: PROC(XUH_PARAM) ALTRET;
      772        8        %INCLUDE XUH_MACRO_C;
      773       92        %XUH_PARAM (STCLASS="");
      774      153        /*
      775      154        */
      776      155        %INCLUDE XU_MACRO_C;
      777     3261        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF) ;
      778     3599        /**/
      779     3600    1   DCL XUG$HELP ENTRY(1) ALTRET ;
      780     3601    1   DCL XUG$MOREMSG ENTRY(1) ALTRET ;
      781     3602    1   DCL XUG$ALLMSG ENTRY(1) ALTRET ;
      782     3603        /**/
      783     3604        %EJECT;
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:142  
      784     3605    1       GETCMD.XUH$ = ADDR(XUH_PARAM) ;
      785     3606    1       CALL XUG$HELP (GETCMD) ALTRET(ALT) ;
      786     3607    1       RETURN ;
      787     3608
      788     3609    1   XUR$MOREMSG: ENTRY(XUH_PARAM) ALTRET;
      789     3610    1       GETCMD.XUH$ = ADDR(XUH_PARAM) ;
      790     3611    1       CALL XUG$MOREMSG (GETCMD) ALTRET(ALT) ;
      791     3612    1       RETURN ;
      792     3613        /**/
      793     3614    1   XUR$ALLMSG: ENTRY(XUH_PARAM) ALTRET;
      794     3615    1       GETCMD.XUH$ = ADDR(XUH_PARAM) ;
      795     3616    1       CALL XUG$ALLMSG (GETCMD) ALTRET(ALT) ;
      796     3617    1       RETURN ;
      797     3618        /**/
      798     3619    1   ALT: ALTRETURN;
      799     3620    1   END XUR$HELP;
      800     3621        %EOD;

PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:143  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   XUH_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$HELP.

   Procedure XUR$HELP requires 28 words for executable code.
   Procedure XUR$HELP requires 4 words of local(AUTO) storage.

PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:144  

 Object Unit name= XUR$HELP                                   File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:14.00 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    28     34  XUR$HELP
    1  RoData even  none     1      1  XUR$HELP

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  XUR$HELP
     0     11          yes     yes      Std        1  XUR$MOREMSG
     0     22          yes     yes      Std        1  XUR$ALLMSG

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$HELP
 yes     yes           Std       1 XUG$MOREMSG
 yes     yes           Std       1 XUG$ALLMSG
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:145  

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     GETCMD                                B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:146  


      765        1        /*T***********************************************************/
      766        2        /*T*                                                         */
      767        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      768        4        /*T*                                                         */
      769        5        /*T***********************************************************/
      770        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      771        7        XUR$HELP: PROC(XUH_PARAM) ALTRET;

      7  0 000000   000000 700200 xent  XUR$HELP     TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      772        8        %INCLUDE XUH_MACRO_C;
      773       92        %XUH_PARAM (STCLASS="");
      774      153        /*
      775      154        */
      776      155        %INCLUDE XU_MACRO_C;
      777     3261        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF) ;
      778     3599        /**/
      779     3600    1   DCL XUG$HELP ENTRY(1) ALTRET ;
      780     3601    1   DCL XUG$MOREMSG ENTRY(1) ALTRET ;
      781     3602    1   DCL XUG$ALLMSG ENTRY(1) ALTRET ;
      782     3603        /**/
      783     3604        %EJECT;
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:147  
      784     3605    1       GETCMD.XUH$ = ADDR(XUH_PARAM) ;

   3605  0 000002   200003 236100                    LDQ     @XUH_PARAM,,AUTO
         0 000003   000005 756000 xsym               STQ     GETCMD+5

      785     3606    1       CALL XUG$HELP (GETCMD) ALTRET(ALT) ;

   3606  0 000004   000000 630400 1                  EPPR0   0
         0 000005   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000006   000000 701000 xent               TSX1    XUG$HELP
         0 000007   000033 702000 0                  TSX2    ALT

      786     3607    1       RETURN ;

   3607  0 000010   000000 702200 xent               TSX2  ! X66_ARET

      787     3608
      788     3609    1   XUR$MOREMSG: ENTRY(XUH_PARAM) ALTRET;

   3609  0 000011   000000 700200 xent  XUR$MOREMSG  TSX0  ! X66_AUTO_1
         0 000012   000004 000001                    ZERO    4,1

      789     3610    1       GETCMD.XUH$ = ADDR(XUH_PARAM) ;

   3610  0 000013   200003 236100                    LDQ     @XUH_PARAM,,AUTO
         0 000014   000005 756000 xsym               STQ     GETCMD+5

      790     3611    1       CALL XUG$MOREMSG (GETCMD) ALTRET(ALT) ;

   3611  0 000015   000000 630400 1                  EPPR0   0
         0 000016   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000017   000000 701000 xent               TSX1    XUG$MOREMSG
         0 000020   000033 702000 0                  TSX2    ALT

      791     3612    1       RETURN ;

   3612  0 000021   000000 702200 xent               TSX2  ! X66_ARET
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:148  

      792     3613        /**/
      793     3614    1   XUR$ALLMSG: ENTRY(XUH_PARAM) ALTRET;

   3614  0 000022   000000 700200 xent  XUR$ALLMSG   TSX0  ! X66_AUTO_1
         0 000023   000004 000001                    ZERO    4,1

      794     3615    1       GETCMD.XUH$ = ADDR(XUH_PARAM) ;

   3615  0 000024   200003 236100                    LDQ     @XUH_PARAM,,AUTO
         0 000025   000005 756000 xsym               STQ     GETCMD+5

      795     3616    1       CALL XUG$ALLMSG (GETCMD) ALTRET(ALT) ;

   3616  0 000026   000000 630400 1                  EPPR0   0
         0 000027   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000030   000000 701000 xent               TSX1    XUG$ALLMSG
         0 000031   000033 702000 0                  TSX2    ALT

      796     3617    1       RETURN ;

   3617  0 000032   000000 702200 xent               TSX2  ! X66_ARET

      797     3618        /**/
      798     3619    1   ALT: ALTRETURN;

   3619  0 000033   000000 702200 xent  ALT          TSX2  ! X66_AALT
      799     3620    1   END XUR$HELP;
      800     3621        %EOD;

PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:149  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   XUH_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$HELP.
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:150  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @XUH_PARAM                *0-0-0/d STRC(2052)  r     1 XUH_PARAM

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$HELP requires 28 words for executable code.
   Procedure XUR$HELP requires 4 words of local(AUTO) storage.
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:151  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #006=XUR$HELP File=XUR$GETCMD.:E05TSI                              WED 07/30/97 09:43 Page:152  
          MINI XREF LISTING

ALT
      3619**LABEL    3606--CALLALT  3611--CALLALT  3616--CALLALT
GETCMD
      3274**DCL      3606<>CALL     3611<>CALL     3616<>CALL
GETCMD.OUT$
      3279**DCL      3285--REDEF
GETCMD.XUH$
      3312**DCL      3605<<ASSIGN   3610<<ASSIGN   3615<<ASSIGN
XUG$ALLMSG
      3602**DCL-ENT  3616--CALL
XUG$HELP
      3600**DCL-ENT  3606--CALL
XUG$MOREMSG
      3601**DCL-ENT  3611--CALL
XUH_PARAM
       112**DCL         7--PROC     3605--ASSIGN   3609--ENTRY    3610--ASSIGN   3614--ENTRY    3615--ASSIGN

PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:153  
      801        1        /*T***********************************************************/
      802        2        /*T*                                                         */
      803        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      804        4        /*T*                                                         */
      805        5        /*T***********************************************************/
      806        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      807        7        XUR$FINDDCB: PROC(DCBNAME,DCB#) ALTRET;
      808        8    1   DCL 1 DCBNAME,
      809        9    1         2 L UBIN BYTE UNAL,
      810       10    1         2 C CHAR(DCBNAME.L);
      811       11    1   DCL DCB# SBIN;
      812       12        /**/
      813       13    1   DCL XUG$FINDDCB ENTRY(2) ALTRET ;
      814       14    1   DCL XUG$GETDCB ENTRY(2) ALTRET ;
      815       15        %EJECT;
PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:154  
      816       16    1       CALL XUG$FINDDCB (DCBNAME, DCB#) ALTRET(ALT) ;
      817       17    1       RETURN ;
      818       18    1   XUR$GETDCB: ENTRY(DCBNAME,DCB#) ALTRET;
      819       19    1       CALL XUG$GETDCB (DCBNAME, DCB#) ALTRET(ALT) ;
      820       20    1       RETURN;
      821       21    1   ALT: ALTRETURN;
      822       22    1   END XUR$FINDDCB;
      823       23        %EOD;

PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:155  
      No diagnostics issued in procedure XUR$FINDDCB.

   Procedure XUR$FINDDCB requires 15 words for executable code.
   Procedure XUR$FINDDCB requires 6 words of local(AUTO) storage.

PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:156  

 Object Unit name= XUR$FINDDCB                                File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:19.24 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  XUR$FINDDCB

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  XUR$FINDDCB
     0      7          yes     yes      Std        2  XUR$GETDCB

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$FINDDCB
 yes     yes           Std       2 XUG$GETDCB
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:157  


      801        1        /*T***********************************************************/
      802        2        /*T*                                                         */
      803        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      804        4        /*T*                                                         */
      805        5        /*T***********************************************************/
      806        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      807        7        XUR$FINDDCB: PROC(DCBNAME,DCB#) ALTRET;

      7  0 000000   000000 700200 xent  XUR$FINDDCB  TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      808        8    1   DCL 1 DCBNAME,
      809        9    1         2 L UBIN BYTE UNAL,
      810       10    1         2 C CHAR(DCBNAME.L);
      811       11    1   DCL DCB# SBIN;
      812       12        /**/
      813       13    1   DCL XUG$FINDDCB ENTRY(2) ALTRET ;
      814       14    1   DCL XUG$GETDCB ENTRY(2) ALTRET ;
      815       15        %EJECT;
PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:158  
      816       16    1       CALL XUG$FINDDCB (DCBNAME, DCB#) ALTRET(ALT) ;

     16  0 000002   200003 630500                    EPPR0   @DCBNAME,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$FINDDCB
         0 000005   000016 702000 0                  TSX2    ALT

      817       17    1       RETURN ;

     17  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      818       18    1   XUR$GETDCB: ENTRY(DCBNAME,DCB#) ALTRET;

     18  0 000007   000000 700200 xent  XUR$GETDCB   TSX0  ! X66_AUTO_2
         0 000010   000006 000002                    ZERO    6,2

      819       19    1       CALL XUG$GETDCB (DCBNAME, DCB#) ALTRET(ALT) ;

     19  0 000011   200003 630500                    EPPR0   @DCBNAME,,AUTO
         0 000012   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000013   000000 701000 xent               TSX1    XUG$GETDCB
         0 000014   000016 702000 0                  TSX2    ALT

      820       20    1       RETURN;

     20  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      821       21    1   ALT: ALTRETURN;

     21  0 000016   000000 702200 xent  ALT          TSX2  ! X66_AALT
      822       22    1   END XUR$FINDDCB;
      823       23        %EOD;

PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:159  
      No diagnostics issued in procedure XUR$FINDDCB.
PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:160  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @DCB#                      3-0-0/w PTR         r     1 @DCBNAME
    *0-0-0/w SBIN        r     1 DCB#                      *0-0-0/c ASTR(9)     r     1 DCBNAME


   Procedure XUR$FINDDCB requires 15 words for executable code.
   Procedure XUR$FINDDCB requires 6 words of local(AUTO) storage.
PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:161  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #007=XUR$FINDDCB File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:162  
          MINI XREF LISTING

ALT
        21**LABEL      16--CALLALT    19--CALLALT
DCB#
        11**DCL         7--PROC       16<>CALL       18--ENTRY      19<>CALL
DCBNAME
         8**DCL         7--PROC       16<>CALL       18--ENTRY      19<>CALL
DCBNAME.L
         9**DCL        10--IMP-SIZ    16>>CALL       19>>CALL
XUG$FINDDCB
        13**DCL-ENT    16--CALL
XUG$GETDCB
        14**DCL-ENT    19--CALL

PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:163  
      824        1        /*T***********************************************************/
      825        2        /*T*                                                         */
      826        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      827        4        /*T*                                                         */
      828        5        /*T***********************************************************/
      829        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      830        7        XUR$CLOSE_DCBS: PROC(DCB#, DISP) ;
      831        8        /**/
      832        9    1   DCL DCB# UBIN WORD ;
      833       10    1   DCL DISP UBIN WORD ;
      834       11
      835       12    1   DCL XUG$CLOSE_DCBS ENTRY(1) ;
      836       13        %INCLUDE XU_MACRO_C ;
      837     3119        %XUG_GETCMD(NAME=GETCMD, STCLASS=SYMREF) ;
      838     3457        /**/
      839     3458    1       IF ADDR(DCB#) ~= ADDR(NIL)
      840     3459    1       THEN
      841     3460    1           GETCMD.DCB_PARAM# = DCB# ;
      842     3461    1       ELSE
      843     3462    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;
      844     3463    1       IF ADDR(DISP) ~= ADDR(NIL)
      845     3464    1       THEN
      846     3465    1           GETCMD.DISP# = DISP ;
      847     3466    1       ELSE
      848     3467    1           GETCMD.DISP# = 0 ;
      849     3468    1       CALL XUG$CLOSE_DCBS(GETCMD) ;
      850     3469    1       RETURN;
      851     3470    1   END XUR$CLOSE_DCBS;
      852     3471        %EOD;

PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:164  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$CLOSE_DCBS.

   Procedure XUR$CLOSE_DCBS requires 23 words for executable code.
   Procedure XUR$CLOSE_DCBS requires 6 words of local(AUTO) storage.

PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:165  

 Object Unit name= XUR$CLOSE_DCBS                             File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:20.76 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    23     27  XUR$CLOSE_DCBS
    1  RoData even  none     1      1  XUR$CLOSE_DCBS

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUR$CLOSE_DCBS

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$CLOSE_DCBS
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     GETCMD                                B_VECTNIL
PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:166  

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:167  


      824        1        /*T***********************************************************/
      825        2        /*T*                                                         */
      826        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      827        4        /*T*                                                         */
      828        5        /*T***********************************************************/
      829        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      830        7        XUR$CLOSE_DCBS: PROC(DCB#, DISP) ;

      7  0 000000   000000 700200 xent  XUR$CLOSE_D* TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      831        8        /**/
      832        9    1   DCL DCB# UBIN WORD ;
      833       10    1   DCL DISP UBIN WORD ;
      834       11
      835       12    1   DCL XUG$CLOSE_DCBS ENTRY(1) ;
      836       13        %INCLUDE XU_MACRO_C ;
      837     3119        %XUG_GETCMD(NAME=GETCMD, STCLASS=SYMREF) ;
      838     3457        /**/
      839     3458    1       IF ADDR(DCB#) ~= ADDR(NIL)

   3458  0 000002   200003 236100                    LDQ     @DCB#,,AUTO
         0 000003   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000004   000011 600000 0                  TZE     s:3462

      840     3459    1       THEN
      841     3460    1           GETCMD.DCB_PARAM# = DCB# ;

   3460  0 000005   200003 470500                    LDP0    @DCB#,,AUTO
         0 000006   000000 235100                    LDA     0,,PR0
         0 000007   000014 755000 xsym               STA     GETCMD+12
         0 000010   000012 710000 0                  TRA     s:3463

      842     3461    1       ELSE
      843     3462    1           GETCMD.DCB_PARAM# = DCBNUM(NIL) ;

PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:168  
   3462  0 000011   000014 450000 xsym               STZ     GETCMD+12

      844     3463    1       IF ADDR(DISP) ~= ADDR(NIL)

   3463  0 000012   200004 236100                    LDQ     @DISP,,AUTO
         0 000013   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000014   000021 600000 0                  TZE     s:3467

      845     3464    1       THEN
      846     3465    1           GETCMD.DISP# = DISP ;

   3465  0 000015   200004 470500                    LDP0    @DISP,,AUTO
         0 000016   000000 235100                    LDA     0,,PR0
         0 000017   000016 755000 xsym               STA     GETCMD+14
         0 000020   000022 710000 0                  TRA     s:3468

      847     3466    1       ELSE
      848     3467    1           GETCMD.DISP# = 0 ;

   3467  0 000021   000016 450000 xsym               STZ     GETCMD+14

      849     3468    1       CALL XUG$CLOSE_DCBS(GETCMD) ;

   3468  0 000022   000000 630400 1                  EPPR0   0
         0 000023   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000024   000000 701000 xent               TSX1    XUG$CLOSE_DCBS
         0 000025   000000 011000                    NOP     0

      850     3469    1       RETURN;

   3469  0 000026   000000 702200 xent               TSX2  ! X66_ARET
      851     3470    1   END XUR$CLOSE_DCBS;
      852     3471        %EOD;

PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:169  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUR$CLOSE_DCBS.
PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:170  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @DCB#                      4-0-0/w PTR         r     1 @DISP
    *0-0-0/w UBIN        r     1 DCB#                      *0-0-0/w UBIN        r     1 DISP

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$CLOSE_DCBS requires 23 words for executable code.
   Procedure XUR$CLOSE_DCBS requires 6 words of local(AUTO) storage.
PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:171  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #008=XUR$CLOSE_DCBS File=XUR$GETCMD.:E05TSI                        WED 07/30/97 09:43 Page:172  
          MINI XREF LISTING

DCB#
         9**DCL         7--PROC     3458--IF       3460>>ASSIGN
DISP
        10**DCL         7--PROC     3463--IF       3465>>ASSIGN
GETCMD
      3132**DCL      3468<>CALL
GETCMD.DCB_PARAM#
      3312**DCL      3460<<ASSIGN   3462<<ASSIGN
GETCMD.DISP#
      3323**DCL      3465<<ASSIGN   3467<<ASSIGN
GETCMD.OUT$
      3137**DCL      3143--REDEF
XUG$CLOSE_DCBS
        12**DCL-ENT  3468--CALL

PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:173  
      853        1        /*T***********************************************************/
      854        2        /*T*                                                         */
      855        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      856        4        /*T*                                                         */
      857        5        /*T***********************************************************/
      858        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      859        7        /*P*  NAME:       XUR$ERRCNVRT
      860        8              PURPOSE:    Convert LCP-6 error code to CP-6 equivalent
      861        9        */
      862       10
      863       11        XUR$ERRCNVRT: PROC (LCP6_ERR, CP6_ERR);
      864       12
      865       13    1   DCL 1 LCP6_ERR ALIGNED,
      866       14    1         2 F1,
      867       15    1           3 * BIT (1),
      868       16    1           3 PART1 BIT (5),
      869       17    1         2 F2,
      870       18    1           3 PART1 BIT (3),
      871       19    1           3 * BIT (1),
      872       20    1           3 PART2 BIT (2),
      873       21    1         2 MID BIT (5),
      874       22    1         2 M BIT (1),
      875       23    1         2 * BIT (1),
      876       24    1         2 ERR#,
      877       25    1           3 PART1 BIT (8),
      878       26    1           3 * BIT (1),
      879       27    1           3 PART2 BIT (5),
      880       28    1         2 SEV BIT (3);
      881       29
      882       30    1   DCL 1 CP6_ERR ALIGNED,
      883       31    1         2 F1,
      884       32    1           3 * BIT (1),
      885       33    1           3 PART1 BIT (5),
      886       34    1         2 F2,
      887       35    1           3 * BIT (1),
      888       36    1           3 PART1 BIT (3),
      889       37    1           3 PART2 BIT (2),
PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:174  
      890       38    1         2 MID,
      891       39    1           3 * BIT (1),
      892       40    1           3 PART1 BIT (5),
      893       41    1         2 M BIT (1),
      894       42    1         2 ERR#,
      895       43    1           3 * BIT (1),
      896       44    1           3 PART1 BIT (8),
      897       45    1           3 PART2 BIT (5),
      898       46    1         2 SEV BIT (3);
      899       47    1   DCL XUG$ERRCNVRT ENTRY(2) ;
      900       48
      901       49    1       CALL XUG$ERRCNVRT (LCP6_ERR, CP6_ERR) ;
      902       50
      903       51    1       RETURN;
      904       52
      905       53    1   END XUR$ERRCNVRT;
      906       54        %EOD;

PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:175  
      No diagnostics issued in procedure XUR$ERRCNVRT.

   Procedure XUR$ERRCNVRT requires 7 words for executable code.
   Procedure XUR$ERRCNVRT requires 6 words of local(AUTO) storage.

PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:176  

 Object Unit name= XUR$ERRCNVRT                               File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:25.56 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  XUR$ERRCNVRT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUR$ERRCNVRT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUG$ERRCNVRT
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:177  


      853        1        /*T***********************************************************/
      854        2        /*T*                                                         */
      855        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      856        4        /*T*                                                         */
      857        5        /*T***********************************************************/
      858        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      859        7        /*P*  NAME:       XUR$ERRCNVRT
      860        8              PURPOSE:    Convert LCP-6 error code to CP-6 equivalent
      861        9        */
      862       10
      863       11        XUR$ERRCNVRT: PROC (LCP6_ERR, CP6_ERR);

     11  0 000000   000000 700200 xent  XUR$ERRCNVRT TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      864       12
      865       13    1   DCL 1 LCP6_ERR ALIGNED,
      866       14    1         2 F1,
      867       15    1           3 * BIT (1),
      868       16    1           3 PART1 BIT (5),
      869       17    1         2 F2,
      870       18    1           3 PART1 BIT (3),
      871       19    1           3 * BIT (1),
      872       20    1           3 PART2 BIT (2),
      873       21    1         2 MID BIT (5),
      874       22    1         2 M BIT (1),
      875       23    1         2 * BIT (1),
      876       24    1         2 ERR#,
      877       25    1           3 PART1 BIT (8),
      878       26    1           3 * BIT (1),
      879       27    1           3 PART2 BIT (5),
      880       28    1         2 SEV BIT (3);
      881       29
      882       30    1   DCL 1 CP6_ERR ALIGNED,
      883       31    1         2 F1,
      884       32    1           3 * BIT (1),
PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:178  
      885       33    1           3 PART1 BIT (5),
      886       34    1         2 F2,
      887       35    1           3 * BIT (1),
      888       36    1           3 PART1 BIT (3),
      889       37    1           3 PART2 BIT (2),
      890       38    1         2 MID,
      891       39    1           3 * BIT (1),
      892       40    1           3 PART1 BIT (5),
      893       41    1         2 M BIT (1),
      894       42    1         2 ERR#,
      895       43    1           3 * BIT (1),
      896       44    1           3 PART1 BIT (8),
      897       45    1           3 PART2 BIT (5),
      898       46    1         2 SEV BIT (3);
      899       47    1   DCL XUG$ERRCNVRT ENTRY(2) ;
      900       48
      901       49    1       CALL XUG$ERRCNVRT (LCP6_ERR, CP6_ERR) ;

     49  0 000002   200003 630500                    EPPR0   @LCP6_ERR,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$ERRCNVRT
         0 000005   000000 011000                    NOP     0

      902       50
      903       51    1       RETURN;

     51  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      904       52
      905       53    1   END XUR$ERRCNVRT;
      906       54        %EOD;

PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:179  
      No diagnostics issued in procedure XUR$ERRCNVRT.
PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:180  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @CP6_ERR                   3-0-0/w PTR         r     1 @LCP6_ERR
    *0-0-0/w STRC        r     1 CP6_ERR                   *0-0-0/w STRC        r     1 LCP6_ERR


   Procedure XUR$ERRCNVRT requires 7 words for executable code.
   Procedure XUR$ERRCNVRT requires 6 words of local(AUTO) storage.
PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:181  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #009=XUR$ERRCNVRT File=XUR$GETCMD.:E05TSI                          WED 07/30/97 09:43 Page:182  
          MINI XREF LISTING

CP6_ERR
        30**DCL        11--PROC       49<>CALL
LCP6_ERR
        13**DCL        11--PROC       49<>CALL
XUG$ERRCNVRT
        47**DCL-ENT    49--CALL

PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:183  
      907        1        /*T***********************************************************/
      908        2        /*T*                                                         */
      909        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      910        4        /*T*                                                         */
      911        5        /*T***********************************************************/
      912        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      913        7        /*P*  NAME:       XUR$ERRTOLCP6
      914        8              PURPOSE:    Convert CP-6 error code to LCP-6 equivalent
      915        9        */
      916       10
      917       11        XUR$ERRTOLCP6: PROC (LCP6_ERR, CP6_ERR);
      918       12
      919       13    1   DCL 1 LCP6_ERR ALIGNED,
      920       14    1         2 F1,
      921       15    1           3 * BIT (1),
      922       16    1           3 PART1 BIT (5),
      923       17    1         2 F2,
      924       18    1           3 PART1 BIT (3),
      925       19    1           3 * BIT (1),
      926       20    1           3 PART2 BIT (2),
      927       21    1         2 MID BIT (5),
      928       22    1         2 M BIT (1),
      929       23    1         2 * BIT (1),
      930       24    1         2 ERR#,
      931       25    1           3 PART1 BIT (8),
      932       26    1           3 * BIT (1),
      933       27    1           3 PART2 BIT (5),
      934       28    1         2 SEV BIT (3);
      935       29
      936       30    1   DCL 1 CP6_ERR ALIGNED,
      937       31    1         2 F1,
      938       32    1           3 * BIT (1),
      939       33    1           3 PART1 BIT (5),
      940       34    1         2 F2,
      941       35    1           3 * BIT (1),
      942       36    1           3 PART1 BIT (3),
      943       37    1           3 PART2 BIT (2),
PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:184  
      944       38    1         2 MID,
      945       39    1           3 * BIT (1),
      946       40    1           3 PART1 BIT (5),
      947       41    1         2 M BIT (1),
      948       42    1         2 ERR#,
      949       43    1           3 * BIT (1),
      950       44    1           3 PART1 BIT (8),
      951       45    1           3 PART2 BIT (5),
      952       46    1         2 SEV BIT (3);
      953       47    1   DCL XUG$ERRTOLCP6 ENTRY(2) ;
      954       48
      955       49    1       CALL XUG$ERRTOLCP6(LCP6_ERR, CP6_ERR) ;
      956       50
      957       51    1       RETURN;
      958       52
      959       53    1   END XUR$ERRTOLCP6;
      960       54        %EOD;

PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:185  
      No diagnostics issued in procedure XUR$ERRTOLCP6.

   Procedure XUR$ERRTOLCP6 requires 7 words for executable code.
   Procedure XUR$ERRTOLCP6 requires 6 words of local(AUTO) storage.

PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:186  

 Object Unit name= XUR$ERRTOLCP6                              File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:27.28 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  XUR$ERRTOLCP6

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUR$ERRTOLCP6

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUG$ERRTOLCP6
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:187  


      907        1        /*T***********************************************************/
      908        2        /*T*                                                         */
      909        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      910        4        /*T*                                                         */
      911        5        /*T***********************************************************/
      912        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      913        7        /*P*  NAME:       XUR$ERRTOLCP6
      914        8              PURPOSE:    Convert CP-6 error code to LCP-6 equivalent
      915        9        */
      916       10
      917       11        XUR$ERRTOLCP6: PROC (LCP6_ERR, CP6_ERR);

     11  0 000000   000000 700200 xent  XUR$ERRTOLC* TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      918       12
      919       13    1   DCL 1 LCP6_ERR ALIGNED,
      920       14    1         2 F1,
      921       15    1           3 * BIT (1),
      922       16    1           3 PART1 BIT (5),
      923       17    1         2 F2,
      924       18    1           3 PART1 BIT (3),
      925       19    1           3 * BIT (1),
      926       20    1           3 PART2 BIT (2),
      927       21    1         2 MID BIT (5),
      928       22    1         2 M BIT (1),
      929       23    1         2 * BIT (1),
      930       24    1         2 ERR#,
      931       25    1           3 PART1 BIT (8),
      932       26    1           3 * BIT (1),
      933       27    1           3 PART2 BIT (5),
      934       28    1         2 SEV BIT (3);
      935       29
      936       30    1   DCL 1 CP6_ERR ALIGNED,
      937       31    1         2 F1,
      938       32    1           3 * BIT (1),
PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:188  
      939       33    1           3 PART1 BIT (5),
      940       34    1         2 F2,
      941       35    1           3 * BIT (1),
      942       36    1           3 PART1 BIT (3),
      943       37    1           3 PART2 BIT (2),
      944       38    1         2 MID,
      945       39    1           3 * BIT (1),
      946       40    1           3 PART1 BIT (5),
      947       41    1         2 M BIT (1),
      948       42    1         2 ERR#,
      949       43    1           3 * BIT (1),
      950       44    1           3 PART1 BIT (8),
      951       45    1           3 PART2 BIT (5),
      952       46    1         2 SEV BIT (3);
      953       47    1   DCL XUG$ERRTOLCP6 ENTRY(2) ;
      954       48
      955       49    1       CALL XUG$ERRTOLCP6(LCP6_ERR, CP6_ERR) ;

     49  0 000002   200003 630500                    EPPR0   @LCP6_ERR,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$ERRTOLCP6
         0 000005   000000 011000                    NOP     0

      956       50
      957       51    1       RETURN;

     51  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      958       52
      959       53    1   END XUR$ERRTOLCP6;
      960       54        %EOD;

PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:189  
      No diagnostics issued in procedure XUR$ERRTOLCP6.
PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:190  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @CP6_ERR                   3-0-0/w PTR         r     1 @LCP6_ERR
    *0-0-0/w STRC        r     1 CP6_ERR                   *0-0-0/w STRC        r     1 LCP6_ERR


   Procedure XUR$ERRTOLCP6 requires 7 words for executable code.
   Procedure XUR$ERRTOLCP6 requires 6 words of local(AUTO) storage.
PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:191  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #010=XUR$ERRTOLCP6 File=XUR$GETCMD.:E05TSI                         WED 07/30/97 09:43 Page:192  
          MINI XREF LISTING

CP6_ERR
        30**DCL        11--PROC       49<>CALL
LCP6_ERR
        13**DCL        11--PROC       49<>CALL
XUG$ERRTOLCP6
        47**DCL-ENT    49--CALL

PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:193  
      961        1        /*T***********************************************************/
      962        2        /*T*                                                         */
      963        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      964        4        /*T*                                                         */
      965        5        /*T***********************************************************/
      966        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      967        7        XUR$OPENOUT:PROC( DCB#, OUT$BLK, FPT_OPEN, ERR#) ALTRET;
      968        8        /*F*
      969        9             NAME: XUR$OPENOUT
      970       10             DESCRIPTION: Opens a DCB.  See XUG$OPENOUT for more detail.
      971       11             CALL:   CALL XUR$OPENOUT( DCB#, OUT$BLK, FPT_OPEN, ERR#) ALTRET(ERR);
      972       12             INPUT:
      973       13        */
      974       14
      975       15        %INCLUDE CP_6;
      976     5574        %INCLUDE XU_MACRO_C; /* XUR MACROs */
      977     8680        %INCLUDE XU_SUBS_C; /* Parse node EQUs */
      978     8772    1   DCL XUG$OPENOUT_COMMON ENTRY(1) ALTRET;
      979     8773
      980     8774    1   DCL DCB# UBIN;
      981     8775        /*K* DCB# - The number of the DCB to be opened.
      982     8776        */
      983     8777
      984     8778        %PARSE$OUT (STCLASS="");
      985     8823        /*K* OUT$BLK - The output block returned by X$PARSE.
      986     8824        */
      987     8825
      988     8826        %FPT_OPEN (STCLASS="");
      989     8935        /*K* FPT_OPEN - A FPT for M$OPEN.
      990     8936        */
      991     8937        %VLP_ERRCODE(FPTN=ERR#,STCLASS="");
      992     8982        /*K* ERR# - Error code returned to caller on altreturn.
      993     8983        */
      994     8984        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF);
      995     9322
      996     9323    1       IF ADDR(DCB#) = ADDR(NIL)
      997     9324    1       THEN GETCMD.DCB_PARAM# = DCBNUM(NIL);
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:194  
      998     9325    1       ELSE GETCMD.DCB_PARAM# = DCB#;
      999     9326
     1000     9327    1       GETCMD.UTIL$ = ADDR(OUT$BLK);
     1001     9328    1       GETCMD.FPT$ = ADDR(FPT_OPEN);
     1002     9329
     1003     9330    1       CALL XUG$OPENOUT_COMMON(GETCMD)
     1004     9331    2       WHENALTRETURN DO;
     1005     9332    2           IF ADDR(ERR#) ~= ADDR(NIL)
     1006     9333    2           THEN
     1007     9334    2               ERR# = GETCMD.ERR#;
     1008     9335    2           ALTRETURN;
     1009     9336    2       END;
     1010     9337
     1011     9338    1       RETURN;
     1012     9339
     1013     9340    1   END /* XUR$OPENOUT */;

PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:195  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
   CP_6_C.:E05TOU  is referenced.
   CP_6.:E05TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure XUR$OPENOUT.

   Procedure XUR$OPENOUT requires 27 words for executable code.
   Procedure XUR$OPENOUT requires 8 words of local(AUTO) storage.

    No errors detected in file XUR$GETCMD.:E05TSI    .

PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:196  

 Object Unit name= XUR$OPENOUT                                File name= XUR$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:43:29.04 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   DCB   even  none     0      0  M$UC
    1   Proc  even  none    27     33  XUR$OPENOUT
    2  RoData even  none     1      1  XUR$OPENOUT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes    yes     yes      Std        4  XUR$OPENOUT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$OPENOUT_COMMON
                       nStd      0 X66_AUTO_4
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AALT
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     M$UC                                  GETCMD                                B_VECTNIL
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:197  

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:198  


      961        1        /*T***********************************************************/
      962        2        /*T*                                                         */
      963        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      964        4        /*T*                                                         */
      965        5        /*T***********************************************************/
      966        6        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      967        7        XUR$OPENOUT:PROC( DCB#, OUT$BLK, FPT_OPEN, ERR#) ALTRET;

      7  1 000000   000000 700200 xent  XUR$OPENOUT  TSX0  ! X66_AUTO_4
         1 000001   000010 000004                    ZERO    8,4

      968        8        /*F*
      969        9             NAME: XUR$OPENOUT
      970       10             DESCRIPTION: Opens a DCB.  See XUG$OPENOUT for more detail.
      971       11             CALL:   CALL XUR$OPENOUT( DCB#, OUT$BLK, FPT_OPEN, ERR#) ALTRET(ERR);
      972       12             INPUT:
      973       13        */
      974       14
      975       15        %INCLUDE CP_6;
      976     5574        %INCLUDE XU_MACRO_C; /* XUR MACROs */
      977     8680        %INCLUDE XU_SUBS_C; /* Parse node EQUs */
      978     8772    1   DCL XUG$OPENOUT_COMMON ENTRY(1) ALTRET;
      979     8773
      980     8774    1   DCL DCB# UBIN;
      981     8775        /*K* DCB# - The number of the DCB to be opened.
      982     8776        */
      983     8777
      984     8778        %PARSE$OUT (STCLASS="");
      985     8823        /*K* OUT$BLK - The output block returned by X$PARSE.
      986     8824        */
      987     8825
      988     8826        %FPT_OPEN (STCLASS="");
      989     8935        /*K* FPT_OPEN - A FPT for M$OPEN.
      990     8936        */
      991     8937        %VLP_ERRCODE(FPTN=ERR#,STCLASS="");
      992     8982        /*K* ERR# - Error code returned to caller on altreturn.
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:199  
      993     8983        */
      994     8984        %XUG_GETCMD (NAME=GETCMD, STCLASS=SYMREF);
      995     9322
      996     9323    1       IF ADDR(DCB#) = ADDR(NIL)

   9323  1 000002   200003 236100                    LDQ     @DCB#,,AUTO
         1 000003   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 000004   000007 601000 1                  TNZ     s:9325

      997     9324    1       THEN GETCMD.DCB_PARAM# = DCBNUM(NIL);

   9324  1 000005   000014 450000 xsym               STZ     GETCMD+12
         1 000006   000012 710000 1                  TRA     s:9327

      998     9325    1       ELSE GETCMD.DCB_PARAM# = DCB#;

   9325  1 000007   200003 470500                    LDP0    @DCB#,,AUTO
         1 000010   000000 235100                    LDA     0,,PR0
         1 000011   000014 755000 xsym               STA     GETCMD+12

      999     9326
     1000     9327    1       GETCMD.UTIL$ = ADDR(OUT$BLK);

   9327  1 000012   200004 236100                    LDQ     @OUT$BLK,,AUTO
         1 000013   000044 756000 xsym               STQ     GETCMD+36

     1001     9328    1       GETCMD.FPT$ = ADDR(FPT_OPEN);

   9328  1 000014   200005 236100                    LDQ     @FPT_OPEN,,AUTO
         1 000015   000043 756000 xsym               STQ     GETCMD+35

     1002     9329
     1003     9330    1       CALL XUG$OPENOUT_COMMON(GETCMD)

   9330  1 000016   000000 630400 2                  EPPR0   0
         1 000017   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000020   000000 701000 xent               TSX1    XUG$OPENOUT_COMMON
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:200  
         1 000021   000023 702000 1                  TSX2    s:9332
         1 000022   000032 710000 1                  TRA     s:9338

     1004     9331    2       WHENALTRETURN DO;

     1005     9332    2           IF ADDR(ERR#) ~= ADDR(NIL)

   9332  1 000023   200006 236100                    LDQ     @ERR#,,AUTO
         1 000024   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 000025   000031 600000 1                  TZE     s:9335

     1006     9333    2           THEN
     1007     9334    2               ERR# = GETCMD.ERR#;

   9334  1 000026   000001 236000 xsym               LDQ     GETCMD+1
         1 000027   200006 470500                    LDP0    @ERR#,,AUTO
         1 000030   000000 756100                    STQ     0,,PR0

     1008     9335    2           ALTRETURN;

   9335  1 000031   000000 702200 xent               TSX2  ! X66_AALT

     1009     9336    2       END;
     1010     9337
     1011     9338    1       RETURN;

   9338  1 000032   000000 702200 xent               TSX2  ! X66_ARET
     1012     9339
     1013     9340    1   END /* XUR$OPENOUT */;

PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:201  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
   CP_6_C.:E05TOU  is referenced.
   CP_6.:E05TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure XUR$OPENOUT.
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:202  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @DCB#                      6-0-0/w PTR         r     1 @ERR#
     5-0-0/w PTR         r     1 @FPT_OPEN                  4-0-0/w PTR         r     1 @OUT$BLK
    *0-0-0/w UBIN        r     1 DCB#                      *0-0-0/w STRC        r     1 ERR#
    *0-0-0/d STRC(2088)  r     1 FPT_OPEN                  *0-0-0/w STRC(144)   r     1 OUT$BLK

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUR$OPENOUT requires 27 words for executable code.
   Procedure XUR$OPENOUT requires 8 words of local(AUTO) storage.

    No errors detected in file XUR$GETCMD.:E05TSI    .
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:203  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:204  
          MINI XREF LISTING

DCB#
      8774**DCL         7--PROC     9323--IF       9325>>ASSIGN
ERR#
      8949**DCL         7--PROC     9332--IF       9334<<ASSIGN
FPT_OPEN
      8891**DCL         7--PROC     9328--ASSIGN
FPT_OPEN.ACSVEH_
      8893**DCL      8894--REDEF
FPT_OPEN.ALTKEYS_
      8899**DCL      8900--REDEF    8900--REDEF
FPT_OPEN.HDR_
      8898**DCL      8899--REDEF
FPT_OPEN.TAB_
      8897**DCL      8898--REDEF
FPT_OPEN.UHL_
      8891**DCL      8892--REDEF    8892--REDEF
FPT_OPEN.V.FSN#
      8931**DCL      8931--REDEF    8931--REDEF
FPT_OPEN.WSN_
      8897**DCL      8897--REDEF
GETCMD
      8997**DCL      9330<>CALL
GETCMD.DCB_PARAM#
      9177**DCL      9324<<ASSIGN   9325<<ASSIGN
GETCMD.ERR#
      9008**DCL      9334>>ASSIGN
GETCMD.FPT$
      9294**DCL      9328<<ASSIGN
GETCMD.OUT$
      9002**DCL      9008--REDEF
GETCMD.UTIL$
      9298**DCL      9327<<ASSIGN
PL6.E3A0      #011=XUR$OPENOUT File=XUR$GETCMD.:E05TSI                           WED 07/30/97 09:43 Page:205  
OUT$BLK
      8784**DCL         7--PROC     9327--ASSIGN
XUG$OPENOUT_COMMON
      8772**DCL-ENT  9330--CALL
