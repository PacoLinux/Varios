/*M* LONGFELLOW - Routine to find and print long Fortran names. */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*P*
      NAME: LONGFELLOW
      PURPOSE: This routine checks for long Fortran source names,
               and when it finds one, saves it with its line numbe
               to be printed in a report form. A Fortran long name
               is defined as being greater then 8 characters in
               length.
      DESCRIPTION: The records are read in one record at a time.
               If it is a comment record, it is skipped and the record
               count is incremented. A valid id is searched for,and
               when found, it is check to see if it's length is
               greater than 8 characters in length. If so, it is
               added to the hold table, along with its line number.
      REFERENCES: See CE31-03, for the description of the Fortran
               identifier(31 characters long).
*/
LONGFELLOW: PROC MAIN;
/*
      INCLUDE FILES THAT ARE USED
*/
      %INCLUDE CP_6;
      %INCLUDE B$JIT_C;
      %INCLUDE XU_MACRO_C;
      %INCLUDE XU_PERR_C;
      %INCLUDE XU_SUBS_C;
      %INCLUDE B_ERRORS_C;
      DCL B$JIT$ PTR SYMREF;
         %B$JIT0;
         %U$JIT1;
         %A$JIT6X;
      DCL B$TCB$ PTR SYMREF;
/*  external and macro refs   */
      DCL XUU$OPEN ENTRY (1) ALTRET ;
      DCL XUU$READ ENTRY (2) ALTRET ;
      %XUU_PARAM(FPTN=READ_PARAM );
      %FPT_OPEN(FPTN=OPEN_FPT, STCLASS=CONSTANT);
      %FPT_OPEN(FPTN=OPEN$FPT, STCLASS=AUTO);
      %FPT_EXIT(FPTN=EXIT$FPT, STCLASS=AUTO);
      %FPT_EXIT(FPTN=EXIT_FPT, STCLASS=CONSTANT);
      %FPT_GDS(FPTN=GDS$FPT, STCLASS=AUTO);
      %FPT_GDS(FPTN=GDS_FPT, STCLASS=CONSTANT);
      %XUU_PARAM(FPTN=OPEN_PARAM);
      %FPT_WRITE (FPTN=WRITE_REC, STCLASS=CONSTANT);
      %FPT_WRITE (FPTN=WRITE$REC, STCLASS=AUTO);
/*
*/
/*
      local data
*/
      DCL M$LO DCB ;
      DCL M$SI DCB ;
      DCL M$UI DCB ;
/*
      local data
*/
      DCL CHR$ PTR ;
      DCL CURR_CHR CHAR(1) BASED(CHR$);
      DCL IN_BUFF (0:199) CHAR(1) ;
      DCL INPUT_BUFF REDEF IN_BUFF CHAR(200) ;
      DCL 1 RESULT_VECTOR DALIGNED,
            2 SIZE UBIN(18) UNAL,
            2 * BIT(18) UNAL,
            2 PTR$ PTR ALIGNED;
      DCL EOF_FLAG BIT(1) ALIGNED;
      DCL ID_NAME CHAR(31) ;
      DCL 1 NAME_TBL ALIGNED,
            2 BASE_PTR$ PTR,
            2 PTR$      PTR,
            2 LAST_PTR$ PTR,
            2 TOP_PTR$  PTR,
            2 SEG_SIZE  UBIN;
      DCL SCAN_LEN SBIN WORD;
      DCL SOURCE_FILE_KEY CHAR(9) ALIGNED;
      DCL SOURCE_KEY CHAR(9) ALIGNED;
      DCL LONG_NAME_COUNT SBIN WORD ;
      DCL DONT_READ BIT(1) ALIGNED ;
      DCL DATA_INIT_FLAG BIT(1) ALIGNED ;
      DCL LENGTH SBIN WORD ;
      DCL SET_REC_KEY_FLAG BIT(1) ALIGNED ;
      DCL 1 NAME_ITEM ALIGNED BASED(NAME_TBL.PTR$),
            2 F_LINK  UBIN HALF HALIGNED,
            2 B_LINK  UBIN HALF HALIGNED,
            2 LENGTH   UBIN WORD,
            2 SOURCE_KEY  CHAR(9),
            2 TEXT        CHAR(31);
      DCL 1 SYSTEM_ERROR          ALIGNED ,
            2 END_OF_FILE            BIT(1) UNAL,
            2 LOST_DATA              BIT(1) UNAL,
            2 FILE_NOT_PRESENT       BIT(1) UNAL,
            2 FILE_INACCESSABLE      BIT(1) UNAL,
            2 DCB_SLOTS              BIT(1) UNAL,
            2 *                      BIT(31) UNAL;
 
/*
*/
      %SUB #TRUE    = '1'B ;
      %SUB #FALSE   = '0'B ;
/*
*/
%EJECT;
/*  procedure code follows     */
       DCL I UBIN STATIC INIT(0);
       DCL LEN UBIN STATIC INIT(8);
      IF B$JIT.CCDISP ~= B$JIT.CCARS THEN DO;
         I = B$JIT.CCDISP + 1;
         DO WHILE (I < B$JIT.CCARS) AND (SUBSTR(B$JIT.CCBUF,I,1) = ' ');
            I = I + 1;
         END;
         /* I = POSITION OF 'L' */
         IF SUBSTR(B$JIT.CCBUF,I,4) = 'LEN=' THEN DO;
            I = I + 4;
            DO WHILE(I<B$JIT.CCARS AND SUBSTR(B$JIT.CCBUF,I,1)=' ');
              I = I + 1;
            END;
            IF I<B$JIT.CCARS AND (SUBSTR(B$JIT.CCBUF,I,1) >='0' AND
                  SUBSTR(B$JIT.CCBUF,I,1)<='9') THEN LEN = 0;
            DO WHILE(I<B$JIT.CCARS AND (SUBSTR(B$JIT.CCBUF,I,1) >='0'
                                   AND SUBSTR(B$JIT.CCBUF,I,1)<='9'));
              LEN = (LEN * 10) + ASCBIN(SUBSTR(B$JIT.CCBUF,I,1)) -
                                 %ASCBIN('0');
              I = I + 1;
              END;
        END;  /* END THE IF CLAUSE */
      END;   /* END THE ELSE CLAUSE */
      WRITE$REC = WRITE_REC ;
      WRITE$REC.V_ = VECTOR(WRITE$REC.V);
      WRITE$REC.V.DCB# = DCBNUM(M$LO);
      LONG_NAME_COUNT = 0 ;
      EXIT$FPT = EXIT_FPT ;
      EXIT$FPT.V_ = VECTOR(EXIT$FPT.V);
      DONT_READ = #FALSE ;
      CALL OPEN_FILES ;
      CALL SET_DATA_SEGS ;
      SET_REC_KEY_FLAG = #TRUE ;
      EOF_FLAG = #FALSE ;
      DATA_INIT_FLAG = #FALSE ;
      /*  at this point scan the records for long ids */
      DO WHILE (NOT EOF_FLAG );
         IF DONT_READ THEN
            DO;
               SOURCE_FILE_KEY = SOURCE_KEY ;
            END;
         CALL GET_RECORD WHENALTRETURN
               DO;
                  EOF_FLAG = #TRUE ;
                  GOTO FINISH_LOOP ;
               END;
         CALL COMMENT_RECORD_CHECK WHENALTRETURN
              DO;
                 SET_REC_KEY_FLAG = #TRUE;
                 GOTO FINISH_LOOP ;
              END;
         CALL GET_ID ALTRET(FINISH_LOOP) ;
         IF ID_NAME = 'FORMAT' THEN
            DO;
               CALL SKIP_OVER_FORMAT ;
               GOTO FINISH_LOOP ;
            END;
/*
*/
CHECK_ID_LENGTH:
         IF LENGTH > LEN THEN
            DO;
               CALL PUT_ON_STACK ;
            END;
         IF DONT_READ OR EOF_FLAG THEN
            DO;
               GOTO FINISH_LOOP ;
            END;
         CALL GET_ID  WHENRETURN
            DO;
               GOTO CHECK_ID_LENGTH ;
            END;
FINISH_LOOP:
      END; /* end of the do while loop */
      CALL SORT_RECORDS ;
      CALL PRINT_RESULTS ;
/*
*/
      EXIT$FPT.V.STEPCC# = 0 ;
      CALL M$EXIT(EXIT$FPT);
%EJECT;
/*I*
      NAME: OPEN_FILES
      PURPOSE: This routine is used to open the si and ui
               files for the inputing of the fortran source
               pograms.
      CALL: Simple call with no passed parameters
      INTERFACT: XUU$OPEN
                 M$OPEN
*/
OPEN_FILES: PROC ;
      DCL ERR_MESS1 CHAR(34) STATIC INIT(
          ' Error on open of the input file ');
/*
*/
      OPEN_PARAM.FLAGS.BASE# = #TRUE ;
      OPEN_PARAM.FLAGS.UP_DATE# = B$JIT$->B$JIT.PRFLAGS.UI ;
      OPEN_PARAM.DCB# = DCBNUM(M$LO) ;
      OPEN$FPT = OPEN_FPT ;
      OPEN$FPT.V_ = VECTOR(OPEN$FPT.V);
      OPEN$FPT.V.DCB# = DCBNUM(M$SI);
/*    CALL M$OPEN(OPEN$FPT) ALTRET(BAD_OPEN);
      IF B$JIT$->B$JIT.PRFLAGS.UI THEN
         DO;
            OPEN$FPT.V.DCB# = DCBNUM(M$UI);
            CALL M$OPEN(OPEN$FPT) ALTRET(BAD_OPEN);
         END;  */  /*  comment out for the present time */
      CALL XUU$OPEN(OPEN_PARAM) ALTRET(BAD_OPEN);
      RETURN;
BAD_OPEN:
      EXIT$FPT.V.STEPCC# = 11 ;
      WRITE$REC.BUF_=VECTOR(ERR_MESS1);
      CALL M$WRITE(WRITE$REC);
      CALL M$EXIT (EXIT$FPT);
END OPEN_FILES ;
%EJECT ;
/*I*
      NAME: SET_DATA_SEGS
      PURPOSE: This routine is used to get the data segment area
               to be used as the buffer holding area for the
               long program names.
      CALL: Simple call with no passed parameters
      INTERFACE:
                 M$GDS
*/
SET_DATA_SEGS: PROC ;
      DCL ERR_MESS2 CHAR(41) STATIC INIT(
          ' Error on the getting of a data segment ');
/*
*/
      RESULT_VECTOR = '0'B ;
      GDS$FPT = GDS_FPT ;
      GDS$FPT.RESULTS_ = VECTOR(RESULT_VECTOR);
      GDS$FPT.V_ = VECTOR(GDS$FPT.V);
      GDS$FPT.V.SEGSIZE# = 3063;
      CALL M$GDS(GDS$FPT) ALTRET (BAD_SEGMENT);
      NAME_TBL.BASE_PTR$ = RESULT_VECTOR.PTR$ ;
      NAME_TBL.PTR$ = RESULT_VECTOR.PTR$ ;
      NAME_TBL.LAST_PTR$ = RESULT_VECTOR.PTR$ ;
      NAME_TBL.TOP_PTR$ = PINCRW(RESULT_VECTOR.PTR$,3062);
      RETURN ;
BAD_SEGMENT:
      EXIT$FPT.V.STEPCC# = 11 ;
      WRITE$REC.BUF_=VECTOR(ERR_MESS2);
      CALL M$WRITE(WRITE$REC);
      CALL M$EXIT(EXIT$FPT) ;
END SET_DATA_SEGS ;
%EJECT ;
/*I*
      NAME: GET_RECORD
      PURPOSE: This routine is used to read the next source input
               record into the input buffer for the searching of the
               long program names.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 XUU$READ
*/
GET_RECORD: PROC ALTRET ;   /* altret on eof condition */
      DCL CURRENT_RECORD_LENGTH SBIN WORD ;
      IF DONT_READ THEN
         DO;
            DONT_READ = #FALSE;
            CHR$ = ADDR(INPUT_BUFF) ;
            RETURN;
         END;
      CALL XUU$READ(READ_PARAM,VECTOR(INPUT_BUFF)) ALTRET(READ_ALTRET);
      IF SYSTEM_ERROR.LOST_DATA THEN
         DO;
LOST_DATA_SET:
            CURRENT_RECORD_LENGTH = 73 ;
            SYSTEM_ERROR.LOST_DATA = #FALSE ;
         END;
      ELSE
         DO;
            CURRENT_RECORD_LENGTH = READ_PARAM.ARS ;
            IF CURRENT_RECORD_LENGTH > 73 THEN
               DO;
                  CURRENT_RECORD_LENGTH = 73 ;
               END;
         END;
      CALL INSERT(INPUT_BUFF,CURRENT_RECORD_LENGTH,200 - CURRENT_RECORD_LENGTH,
                 ' ');
      IN_BUFF(CURRENT_RECORD_LENGTH) = BITASC('77'O);
      CHR$ = ADDR(INPUT_BUFF);
      SOURCE_KEY = READ_PARAM.RE_ASCII_KEY.CHAR1_9 ;
      IF SET_REC_KEY_FLAG THEN
         DO;
            SOURCE_FILE_KEY = SOURCE_KEY ;
            SET_REC_KEY_FLAG = #FALSE ;
         END;
      RETURN;
READ_ALTRET:
      CALL MAP_SYSTEM_ERROR(READ_PARAM.ERRCODE.ERR#);
      IF SYSTEM_ERROR.END_OF_FILE THEN
         DO;
            ALTRETURN ;
         END;
      IF SYSTEM_ERROR.LOST_DATA THEN
         DO;
            GOTO LOST_DATA_SET ;
         END;
/*   error code output should go here */
      ALTRETURN ;
END GET_RECORD ;
%EJECT ;
/*                                                                    */
/*I* NAME:               MAP_SYSTEM_ERROR                         *
 *   FUNCTION:           THIS PROCEDURE TAKES A SYSTEM ERROR NUMBER   *
 *                          AND SETS A BIT REPRESENTING IT IN         *
 *                          SYSTEM_ERROR.                          *
 *   PRECONDITIONS:      <NONE>                                       *
 *   POSTCONDITIONS:     <NONE>                                       *
 *   INPUTS:             STANDARD_ERROR_CODE_ERR                      *
 *                          THIS CONTAINS THE ERR# FIELD OF A         *
 *                          STANDARD ERROR CODE.                      *
 *   OUTPUTS:            SYSTEM_ERROR                              *
 *                          ONE BIT IS SET; ALL OTHERS ARE RESET.     *
 *   PROCEDURES CALLED:  <NONE>                                       *
 *
*/
MAP_SYSTEM_ERROR:
   PROC(STANDARD_ERROR_CODE_ERR);
/* */
   DCL STANDARD_ERROR_CODE_ERR UBIN(14) UNAL;
/*       THIS IS THE SYSTEM ERROR NUMBER AS PLUCKED FROM THE
            STANDARD ERROR CODE FORMAT.
*/
   DCL SYSTEM_ERROR_CODE UBIN(36) ALIGNED;
/*       THIS IS STANDARD_ERROR_CODE_ERR, IN A WORD BY ITSELF AND
            ALIGNED.
*/
   SYSTEM_ERROR = '000000000000'O;
   SYSTEM_ERROR_CODE = STANDARD_ERROR_CODE_ERR;
   IF SYSTEM_ERROR_CODE = %E$EOF THEN
      DO;
         SYSTEM_ERROR.END_OF_FILE = #TRUE;
         RETURN;
      END;
   IF SYSTEM_ERROR_CODE = %E$LD THEN
      DO;
         SYSTEM_ERROR.LOST_DATA = #TRUE;
         RETURN;
      END;
   IF SYSTEM_ERROR_CODE = %E$NOACCESS OR
      SYSTEM_ERROR_CODE = %E$FILEBUSY THEN
      DO;
         SYSTEM_ERROR.FILE_INACCESSABLE = #TRUE;
         RETURN;
      END;
   IF SYSTEM_ERROR_CODE = %E$NOSLOTS THEN
      DO;
         SYSTEM_ERROR.DCB_SLOTS = #TRUE;
         RETURN;
      END;
   SYSTEM_ERROR.FILE_NOT_PRESENT = #TRUE;
   RETURN;
END MAP_SYSTEM_ERROR;
%EJECT ;
/*I*
      NAME: COMMENT_RECORD_CHECK
      PURPOSE: This routine is used to check if the current record
               is a comment record. That is, a record that will not
               be searched for long id names.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
COMMENT_RECORD_CHECK: PROC ALTRET;  /* altret if comment record is found */
      DCL COMMENT_CHR CHAR(1) BASED ;
      DO CASE(ASCBIN(CHR$->COMMENT_CHR));
         CASE (%ASCBIN('C'),%ASCBIN('*'),
               %ASCBIN('D'),
               %ASCBIN('!'),
               %ASCBIN('/'),
               %ASCBIN('#'),
               %ASCBIN('"'));
            ALTRETURN;
         CASE(%ASCBIN('X'),
              %ASCBIN('Y'),
              %ASCBIN('Z'));
            CHR$->COMMENT_CHR = ' ';
      END;  /* end of the do case stmt */
      RETURN;
END COMMENT_RECORD_CHECK ;
%EJECT ;
/*I*
      NAME: GET_ID
      PURPOSE: This routine is used to get the identifier and
               return it to the calling routine. That is, the
               next identifier in the string is found and returned.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 INSERT
                 SCAN_TO_ALPHA_CHAR
                 GET_RECORD
                 COMMENT_RECORD_CHECKS
                 CHECK_FOR_CONTINUATION
*/
GET_ID: PROC ALTRET ;
 
      SCAN_LEN = 0 ;
      CALL SCAN_TO_ALPHA_CHAR WHENALTRETURN
         DO;
            ALTRETURN ;
         END;
      CALL CHECK_FOR_KEY_WORD WHENALTRETURN
         DO;
            CALL SCAN_TO_ALPHA_CHAR WHENALTRETURN
               DO;
                  ALTRETURN;
               END;
         END;
      ID_NAME =' ';
      LENGTH = 0 ;
      SET_REC_KEY_FLAG = #TRUE ;
SCAN_ID:
      DO WHILE(CURR_CHR = '$' OR CURR_CHR = '_' OR
         (CURR_CHR >= 'A' AND CURR_CHR <= 'Z') OR
         (CURR_CHR >= '0' AND CURR_CHR <= '9'));
         IF LENGTH < 31 THEN
            DO;
               SET_REC_KEY_FLAG = #FALSE ;
               CALL INSERT(ID_NAME,LENGTH,1,CURR_CHR);
               LENGTH = LENGTH + 1;
            END;
         SCAN_LEN = SCAN_LEN + 1 ;
         CHR$ = PINCRC(CHR$,1);
         DO WHILE (CURR_CHR = ' ');
            CHR$ = PINCRC(CHR$,1);
            SCAN_LEN = SCAN_LEN + 1 ;
         END;
      END; /* end of the do while */
      IF CURR_CHR = BITASC ('77'O) THEN
         DO;
GET_ANOTHER_RECORD:
            CALL GET_RECORD WHENALTRETURN
               DO;
                  EOF_FLAG = #TRUE ;
                  RETURN ;
               END;
            CALL COMMENT_RECORD_CHECK WHENALTRETURN
               DO;
                  GOTO GET_ANOTHER_RECORD ;
               END;
            CALL CHECK_FOR_CONTINUATION WHENRETURN
               DO;
                  DONT_READ = #TRUE ;
                  RETURN ;
               END;
            SCAN_LEN = 6 ;
            CHR$ = PINCRC(CHR$,6);
            DO WHILE( CURR_CHR = ' ' );
               DO;
                  SCAN_LEN = SCAN_LEN + 1 ;
                  CHR$ = PINCRC(CHR$,1);
               END;
            END;
            IF SCAN_LEN > 72 THEN
               DO;
                  GOTO GET_ANOTHER_RECORD ;
               END;
            IF (CURR_CHR >= 'A' AND CURR_CHR <= 'Z') OR
                CURR_CHR  = '$' OR  CURR_CHR  = '_'  THEN
               DO;
                  GOTO SCAN_ID ;
               END;
            RETURN ;
         END;
      RETURN ;
END GET_ID ;
%EJECT ;
/*I*
      NAME: CHECK_FOR_CONTINUATION
      PURPOSE: This routine is used to check if the current
               record is a continuation of the previous record.
               An alternate return is taken if it is a continuation
               record.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
CHECK_FOR_CONTINUATION: PROC ALTRET ;
      IF IN_BUFF(5) ~= ' ' AND
         IN_BUFF(5) ~= '0' THEN
         DO;
            ALTRETURN ;
         END;
      DATA_INIT_FLAG = #FALSE ;
      RETURN ;
END CHECK_FOR_CONTINUATION ;
%EJECT ;
/*I*
      NAME: SKIP_OVER_FORMAT
      PURPOSE: This routine is used to check if the next record
               is a continuation of the previous Format record.
               If it is a continuation record, then it is skipped,
               and onther record is read. This is continued until
               A non continuation,non comment or eof condition
               is encountered.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 GET_RECORD
                 COMMENT_RECORD_CHECK
                 CHECK_FOR_CONTINUATION
*/
SKIP_OVER_FORMAT: PROC ;
      DCL EXIT_FLAG BIT(1) ALIGNED ;
/*
*/
      EXIT_FLAG = #FALSE ;
      DO WHILE (NOT EXIT_FLAG);
         CALL GET_RECORD WHENALTRETURN
            DO;
               EOF_FLAG = #TRUE ;
               EXIT_FLAG = #TRUE ;
               GOTO LOOP_END ;
            END;
         CALL COMMENT_RECORD_CHECK WHENALTRETURN
            DO;
               GOTO LOOP_END;
            END;
         CALL CHECK_FOR_CONTINUATION WHENRETURN
            DO;
               DONT_READ = #TRUE ;
               EXIT_FLAG = #TRUE ;
            END;
LOOP_END:
      END; /*  end of the do while loop */
      RETURN ;
END SKIP_OVER_FORMAT ;
%EJECT ;
/*I*
      NAME: PUT_ON_STACK
      PURPOSE: This routine is used to put the current id onto
               the name table stack. That is, it is used to
               save the current id and its line number for printing
               in a report at the end of the source file search.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
PUT_ON_STACK: PROC ;
      DCL ERR_MESS2 CHAR(42) STATIC INIT(
      'Error on attempted extent of data segment' );
      IF PINCRW(NAME_TBL.PTR$,SIZEW(NAME_ITEM)) > NAME_TBL.TOP_PTR$ THEN
         DO;
            GDS$FPT.V.SEGSIZE# = 1024 ;
            CALL M$GDS(GDS$FPT) ALTRET(BAD_SEGMENT);
            NAME_TBL.TOP_PTR$ = PINCRW(NAME_TBL.TOP_PTR$, 1024);
         END;
      NAME_ITEM = '0'B ;
      IF NAME_TBL.PTR$ ~= NAME_TBL.BASE_PTR$ THEN
         DO;
            NAME_TBL.LAST_PTR$->NAME_ITEM.F_LINK = POFFW(NAME_TBL.PTR$,
                     NAME_TBL.BASE_PTR$);
            NAME_ITEM.B_LINK = POFFW(NAME_TBL.LAST_PTR$,NAME_TBL.BASE_PTR$);
         END;
      NAME_ITEM.LENGTH = LENGTH ;
      NAME_ITEM.SOURCE_KEY = SOURCE_FILE_KEY ;
      NAME_ITEM.TEXT = ID_NAME ;
      NAME_TBL.LAST_PTR$ = NAME_TBL.PTR$ ;
      NAME_TBL.PTR$ = PINCRW(NAME_TBL.PTR$ ,SIZEW(NAME_ITEM));
      LONG_NAME_COUNT = LONG_NAME_COUNT + 1 ;
      IF SOURCE_KEY ~= SOURCE_FILE_KEY THEN
         DO;
            SOURCE_FILE_KEY = SOURCE_KEY ;
         END;
      RETURN ;
BAD_SEGMENT:
      EXIT$FPT.V.STEPCC# = 11 ;
      WRITE$REC.BUF_=VECTOR(ERR_MESS2);
      CALL M$WRITE(WRITE$REC);
      CALL M$EXIT(EXIT$FPT) ;
END PUT_ON_STACK ;
%EJECT ;
/*I*
      NAME: SCAN_TO_ALPHA_CHAR
      PURPOSE: This routine is used to scan to the next alpha
               character. This is used as the setup for the
               get id routine.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 FETCH_RECORD
                 SCAN_OVER_LITERAL
*/
SCAN_TO_ALPHA_CHAR: PROC ALTRET ;
CONTINUE_SCAN:
      DO WHILE ((CURR_CHR < 'A' OR CURR_CHR > 'Z') AND CURR_CHR ~= '''' AND CURR_CHR ~= '/' );
         SCAN_LEN = SCAN_LEN + 1 ;
         IF SCAN_LEN > 72 OR CURR_CHR = BITASC('77'O) THEN
            DO;
               SET_REC_KEY_FLAG = #TRUE ;
               CALL FETCH_RECORD WHENALTRETURN
                  DO;
                     ALTRETURN ;
                  END;
               SCAN_LEN = 6 ;
               GOTO CONTINUE_SCAN ;
            END;
         CHR$ = PINCRC(CHR$,1) ;
         SCAN_LEN = SCAN_LEN + 1 ;
      END;  /*  end of the do while */
      IF CURR_CHR = '''' THEN
         DO;
            CALL SCAN_OVER_LITERAL WHENALTRETURN
               DO;
                  ALTRETURN;
               END;
            GOTO CONTINUE_SCAN ;
         END;
      IF CURR_CHR = '/' THEN
         DO;
            CALL SCAN_OVER_DATA_INIT WHENALTRETURN
               DO;
                  ALTRETURN;
               END;
            GOTO CONTINUE_SCAN ;
         END;
      RETURN ;
END SCAN_TO_ALPHA_CHAR ;
%EJECT ;
/*I*
      NAME: SCAN_OVER_LITERAL
      PURPOSE: This routine is used to scan over the current
               literal string. The string is just discarded.
               An altreturn is taken if eof condition is encountered.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 FETCH_RECORD
*/
SCAN_OVER_LITERAL: PROC ALTRET ;
      DO WHILE ('1'B);
         CHR$ = PINCRC(CHR$,1);
         IF CURR_CHR = BITASC('77'O) THEN
            DO;
               CALL FETCH_RECORD WHENALTRETURN
                  DO;
                     ALTRETURN ;
                  END;
            END;
         DO WHILE (CURR_CHR ~= '''');
            CHR$ = PINCRC(CHR$,1);
            IF CURR_CHR = BITASC('77'O) THEN
               DO;
                  CALL FETCH_RECORD WHENALTRETURN
                     DO;
                        ALTRETURN ;
                     END;
               END;
         END; /* end of the do while */
         CHR$ = PINCRC(CHR$,1);
         IF CURR_CHR ~= '''' THEN
            DO;
               RETURN ;
            END;
      END ;  /* end of do while */
END SCAN_OVER_LITERAL ;
%EJECT ;
/*I*
      NAME: SCAN_OVER_DATA_INIT
      PURPOSE: This routine is used to scan over the current
               data init string. The string is just discarded.
               An altreturn is taken if eof condition is encountered.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 FETCH_RECORD
*/
SCAN_OVER_DATA_INIT: PROC ALTRET ;
      IF NOT DATA_INIT_FLAG THEN
         DO;
            CHR$ = PINCRC(CHR$,1);
            RETURN ;
         END;
      CHR$ = PINCRC(CHR$,1);
      IF CURR_CHR = BITASC('77'O) THEN
         DO;
            CALL FETCH_RECORD WHENALTRETURN
               DO;
                  ALTRETURN ;
               END;
         END;
      DO WHILE (CURR_CHR ~= '/');
         CHR$ = PINCRC(CHR$,1);
         IF CURR_CHR = BITASC('77'O) THEN
            DO;
               CALL FETCH_RECORD WHENALTRETURN
                  DO;
                     ALTRETURN ;
                  END;
            END;
      END; /* end of the do while */
      CHR$ = PINCRC(CHR$,1);
      RETURN ;
END SCAN_OVER_DATA_INIT ;
%EJECT ;
/*I*
      NAME: FETCH_RECORD
      PURPOSE: This routine is used to read to the next active
               record.  Routine altreturns if not continuation
               record is encountered.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 GET_RECORD
                 COMMENT_RECORD_CHECK
                 CHECK_FOR_CONTINUATION
*/
FETCH_RECORD: PROC ALTRET ;
RETRY_READ:
      CALL GET_RECORD WHENALTRETURN
         DO;
            EOF_FLAG = #TRUE ;
            ALTRETURN ;
         END;
      CALL COMMENT_RECORD_CHECK  WHENALTRETURN
         DO;
            GOTO RETRY_READ ;
         END;
      CALL CHECK_FOR_CONTINUATION WHENRETURN
         DO;
            DONT_READ = #TRUE ;
            ALTRETURN;
         END;
      RETURN ;
END FETCH_RECORD ;
%EJECT ;
/*I*
      NAME: SORT_RECORDS
      PURPOSE: This routine is used to sort the records into
               a nice alphabetic order. The bubble sort technique
               is used.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
SORT_RECORDS: PROC ;
      DCL HOLD_AREA (0:12) BIT(36) ;
      DCL TOP_PTR$ PTR;
      DCL NEXT_PTR$ PTR ;
      DCL START_PTR$ PTR;
      DCL CHANGE_COUNT SBIN ;
/*
*/
      IF LONG_NAME_COUNT <= 1 THEN
         DO;
            RETURN ;
         END;
      CHANGE_COUNT = 1 ;
      TOP_PTR$ = NAME_TBL.LAST_PTR$ ;
      DO WHILE (CHANGE_COUNT ~= 0);
         START_PTR$ = NAME_TBL.BASE_PTR$ ;
         NEXT_PTR$ = PINCRW(START_PTR$,SIZEW(NAME_ITEM));
         CHANGE_COUNT = 0 ;
         DO WHILE (NEXT_PTR$ <= TOP_PTR$);
            IF START_PTR$->NAME_ITEM.TEXT > NEXT_PTR$->NAME_ITEM.TEXT THEN
               DO;
                  HOLD_AREA = START_PTR$->NAME_ITEM ;
                  START_PTR$->NAME_ITEM = NEXT_PTR$->NAME_ITEM ;
                  NEXT_PTR$->NAME_ITEM = HOLD_AREA ;
                  CHANGE_COUNT = CHANGE_COUNT + 1 ;
               END;
            START_PTR$ = NEXT_PTR$ ;
            NEXT_PTR$ = PINCRW(NEXT_PTR$,SIZEW(NAME_ITEM));
         END; /* end of do while */
         TOP_PTR$ = PINCRW(TOP_PTR$, -SIZEW(NAME_ITEM));
      END;
END SORT_RECORDS ;
%EJECT ;
/*I*
      NAME: PRINT_RESULTS
      PURPOSE: This routine is used to print the records out
               in a nice alphabetic order. The sorted records
               are picked up one at a time and are checked to
               see if the record is the same as the last record
               that was processed. If yes, simply add record number
               to the print buffer. If not, then doump the current
               print buffer, and start a new print buffer image.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 M$LO
      INTERNAL PROCEDURES:
                 PRINT_BUFFER (routine to do the actual M$LO call.)
*/
PRINT_RESULTS: PROC ;
      DCL 1 BUF ALIGNED,
            2 NAME CHAR(31),
            2 * CHAR(2),
            2 L (0:4),
               3 LINE  CHAR(9),
               3 *     CHAR(2);
      DCL BUFFER REDEF BUF CHAR(88) ALIGNED ;
      DCL NAME_COUNT SBIN ;
      DCL LINE_INDEX SBIN ;
      DCL CURR_ITEM  CHAR(31) ;
      DCL PREV_ITEM  CHAR(31) ;
      DCL MESSAGE1 CHAR(66) STATIC INIT(
        ' No long ids where found in the Fortran source file.');
      DCL MESSAGE2 CHAR(66) STATIC INIT(
        '      The following are the ids with a length greater ' );
      DCL MESSAGE3 CHAR(66) STATIC INIT(
        '   than 8 characters, and the lines on which they appear ');
/*
*/
/*  procedure code follows */
      IF LONG_NAME_COUNT <= 0 THEN
         DO;
            WRITE$REC.BUF_ = VECTOR(MESSAGE1);
            CALL PRINT_BUFFER ;
            RETURN;
         END;
      WRITE$REC.BUF_ = VECTOR(MESSAGE2);
      CALL PRINT_BUFFER ;
      WRITE$REC.BUF_ = VECTOR(MESSAGE3);
      CALL PRINT_BUFFER ;
      BUFFER = ' ' ;
      WRITE$REC.BUF_ = VECTOR(BUF);
      CALL PRINT_BUFFER ;
      NAME_COUNT = LONG_NAME_COUNT ;
      LINE_INDEX = 0 ;
      NAME_TBL.PTR$ = NAME_TBL.BASE_PTR$ ;
      BUF.NAME = NAME_ITEM.TEXT ;
      CURR_ITEM = NAME_ITEM.TEXT ;
      PREV_ITEM = NAME_ITEM.TEXT ;
      DO WHILE (NAME_COUNT ~= 0 );
         IF CURR_ITEM ~= PREV_ITEM THEN
            DO;
               IF LINE_INDEX ~= 0 THEN
                  DO;
                     CALL PRINT_BUFFER ;
                  END;
               PREV_ITEM = CURR_ITEM ;
               BUF.NAME = CURR_ITEM ;
            END;
         BUF.L.LINE(LINE_INDEX) = NAME_ITEM.SOURCE_KEY ;
         LINE_INDEX = LINE_INDEX + 1 ;
         IF LINE_INDEX > 3 THEN
            DO;
               CALL PRINT_BUFFER ;
            END;
         NAME_TBL.PTR$ = PINCRW(NAME_TBL.PTR$,SIZEW(NAME_ITEM));
         CURR_ITEM = NAME_ITEM.TEXT ;
         NAME_COUNT = NAME_COUNT - 1 ;
      END; /* endof the do while loop */
      IF LINE_INDEX ~= 0 THEN
         DO;
            CALL PRINT_BUFFER ;
         END;
      RETURN;
%EJECT ;
/*I*
      NAME: PRINT_BUFFER
      PURPOSE: This routine is used to output the contents of
               the current print buffer onto the M$LO device.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 M$LO
*/
PRINT_BUFFER: PROC ;
/*
*/
      CALL M$WRITE (WRITE$REC) ALTRET(ERROR);
      BUFFER = ' ';
      LINE_INDEX = 0;
      RETURN;
ERROR:
      RETURN;
END PRINT_BUFFER;
END PRINT_RESULTS;
/*
*/
%EJECT ;
/*I*
      NAME: CHECK_FOR_KEY_WORD
      PURPOSE: This routine is used to check if the current text
               string is a Fortran key word(starting key word).
               If it is a fortran key word, the string is simply skipped.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
CHECK_FOR_KEY_WORD: PROC ALTRET ;
      DCL TEXT2 CHAR(2)  BASED(CHR$);
      DCL TEXT4 CHAR(4)  BASED(CHR$);
      DCL TEXT5 CHAR(5)  BASED(CHR$);
      DCL TEXT6 CHAR(6)  BASED(CHR$);
      DCL TEXT7 CHAR(7)  BASED(CHR$);
      DCL TEXT8 CHAR(8)  BASED(CHR$);
      DCL TEXT9 CHAR(9)  BASED(CHR$);
      DCL TEXT10 CHAR(10) BASED(CHR$);
      DCL TEXT11 CHAR(11) BASED(CHR$);
      DCL TEXT12 CHAR(12) BASED(CHR$);
      DCL TEXT13 CHAR(13) BASED(CHR$);
      DCL TEXT14 CHAR(14) BASED(CHR$);
      DCL TEXT15 CHAR(15) BASED(CHR$);
      DCL TEXT16 CHAR(16) BASED(CHR$);
      DCL TEXT18 CHAR(18) BASED(CHR$);
      DCL TEXT23 CHAR(23) BASED(CHR$);
      DCL TEXT25 CHAR(25) BASED(CHR$);
/*  */
      DO CASE(ASCBIN(CURR_CHR));
         CASE(%ASCBIN('A'));
            IF TEXT8 = 'ABNORMAL' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
            IF TEXT6 = 'ASSIGN' THEN
               DO;
                  CALL CHECK_ASSIGN_STMT ;
               END;
         CASE(%ASCBIN('B'));
            IF TEXT9 = 'BACKSPACE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,9);
                  ALTRETURN;
               END;
            IF TEXT9 = 'BLOCKDATA' THEN
               DO;
                  CHR$ = PINCRC(CHR$,9);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('C'));
            IF TEXT18 = 'CHARACTER FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,18);
                  ALTRETURN;
               END;
            IF TEXT9 = 'CHARACTER' THEN
               DO;
                  CHR$ = PINCRC(CHR$,9);
                  ALTRETURN;
               END;
            IF TEXT8 = 'CONSTANT' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
            IF TEXT8 = 'CONTINUE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
            IF TEXT16 = 'COMPLEX FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,16);
                  ALTRETURN;
               END;
            IF TEXT7 = 'COMPLEX' THEN
               DO;
                  CHR$ = PINCRC(CHR$,7);
                  ALTRETURN;
               END;
            IF TEXT6 = 'COMMON' THEN
               DO;
                  CHR$ = PINCRC(CHR$,6);
                  ALTRETURN;
               END;
            IF TEXT4 = 'CALL' THEN
               DO;
                  CHR$ = PINCRC(CHR$,4);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('D'));
            IF TEXT4 = 'DATA' THEN
               DO;
                  CALL CHECK_DATA_STMT WHENALTRETURN
                     DO;
                        RETURN ;
                     END;
                  CHR$ = PINCRC(CHR$,4);
                  DATA_INIT_FLAG = #TRUE ;
                  ALTRETURN;
               END;
            IF TEXT9 = 'DIMENSION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,9);
                  ALTRETURN;
               END;
            IF TEXT13 = 'DOUBLECOMPLEX' THEN
               DO;
                  CHR$ = PINCRC(CHR$,13);
                  ALTRETURN;
               END;
            IF TEXT23 = 'DOUBLE COMPLEX FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,23);
                  ALTRETURN;
               END;
            IF TEXT14 = 'DOUBLE COMPLEX' THEN
               DO;
                  CHR$ = PINCRC(CHR$,14);
                  ALTRETURN;
               END;
            IF TEXT15= 'DOUBLEPRECISION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,15);
                  ALTRETURN;
               END;
            IF TEXT25= 'DOUBLE PRECISION FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,25);
                  ALTRETURN;
               END;
            IF TEXT16= 'DOUBLE PRECISION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,16);
                  ALTRETURN;
               END;
            IF TEXT2 = 'DO' THEN
               DO;
                  CALL CHECK_DO_STMT WHENRETURN
                     DO;
                        CHR$ = PINCRC(CHR$,2);
                        ALTRETURN;
                     END;
               END;
         CASE(%ASCBIN('E'));
            IF TEXT5 = 'ENTRY' THEN
               DO;
                  CHR$ = PINCRC(CHR$,5);
                  ALTRETURN;
               END;
            IF TEXT8 = 'EXTERNAL' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
            IF TEXT11 = 'EQUIVALENCE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,11);
                  ALTRETURN;
               END;
            IF TEXT8 = 'END FILE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
            IF TEXT7 = 'ENDFILE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,7);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('F'));
            IF TEXT8 = 'FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('G'));
            IF TEXT4 = 'GOTO' THEN
               DO;
                  CHR$ = PINCRC(CHR$,4);
                  ALTRETURN;
               END;
            IF TEXT5 = 'GO TO' THEN
               DO;
                  CHR$ = PINCRC(CHR$,5);
                  ALTRETURN;
               END;
            IF TEXT6 = 'GLOBAL' THEN
               DO;
                  CHR$ = PINCRC(CHR$,6);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('I'));
            IF TEXT7 = 'INCLUDE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,7);
                  ALTRETURN;
               END;
            IF TEXT8 = 'IMPLICIT' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
            IF TEXT5 = 'INPUT' THEN
               DO;
                  CHR$ = PINCRC(CHR$,5);
                  ALTRETURN;
               END;
            IF TEXT16 = 'INTEGER FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,16);
                  ALTRETURN;
               END;
            IF TEXT7 = 'INTEGER' THEN
               DO;
                  CHR$ = PINCRC(CHR$,7);
                  ALTRETURN;
               END;
            IF TEXT9 = 'INTRINSIC' THEN
               DO;
                  CHR$ = PINCRC(CHR$,9);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('L'));
            IF TEXT16 = 'LOGICAL FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,16);
                  ALTRETURN;
               END;
            IF TEXT7 = 'LOGICAL' THEN
               DO;
                  CHR$ = PINCRC(CHR$,7);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('N'));
            IF TEXT8 = 'NAMELIST' THEN
               DO;
                  CHR$ = PINCRC(CHR$,8);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('O'));
            IF TEXT6 = 'OUTPUT' THEN
               DO;
                  CHR$ = PINCRC(CHR$,6);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('P'));
            IF TEXT5 = 'PAUSE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,5);
                  ALTRETURN;
               END;
            IF TEXT5 = 'PRINT' THEN
               DO;
                  CHR$ = PINCRC(CHR$,5);
                  ALTRETURN;
               END;
            IF TEXT5 = 'PUNCH' THEN
               DO;
                  CHR$ = PINCRC(CHR$,5);
                  ALTRETURN;
               END;
            IF TEXT7 = 'PROGRAM' THEN
               DO;
                  CHR$ = PINCRC(CHR$,7);
                  ALTRETURN;
               END;
            IF TEXT9 = 'PARAMETER' THEN
               DO;
                  CHR$ = PINCRC(CHR$,9);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('R'));
            IF TEXT4 = 'READ' THEN
               DO;
                  CHR$ = PINCRC(CHR$,4);
                  ALTRETURN;
               END;
            IF TEXT13 = 'REAL FUNCTION' THEN
               DO;
                  CHR$ = PINCRC(CHR$,13);
                  ALTRETURN;
               END;
            IF TEXT4 = 'REAL' THEN
               DO;
                  CHR$ = PINCRC(CHR$,4);
                  ALTRETURN;
               END;
            IF TEXT6 = 'REPEAT' THEN
               DO;
                  CHR$ = PINCRC(CHR$,6);
                  ALTRETURN;
               END;
            IF TEXT6 = 'RETURN' THEN
               DO;
                  CHR$ = PINCRC(CHR$,6);
                  ALTRETURN;
               END;
            IF TEXT6 = 'REWIND' THEN
               DO;
                  CHR$ = PINCRC(CHR$,6);
                  ALTRETURN;
               END;
         CASE(%ASCBIN('S'));
            IF TEXT4 = 'SAVE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,4);
                  ALTRETURN;
               END;
            IF TEXT4 = 'STOP' THEN
               DO;
                  CHR$ = PINCRC(CHR$,4);
                  ALTRETURN;
               END;
            IF TEXT10 = 'SUBROUTINE' THEN
               DO;
                  CHR$ = PINCRC(CHR$,10);
                  ALTRETURN;
               END;
      END; /* end of the do case construct */
      RETURN ;
%EJECT ;
/*I*
      NAME: CHECK_ASSIGN_STMT
      PURPOSE: This routine is used to check if the current text
               string is the ASSIGN statement. If so, it then
               simply skips over the ASSIGN statement.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
CHECK_ASSIGN_STMT: PROC ;
      DCL P$ PTR;
      DCL CUR_CHR CHAR(1) BASED(P$);
/* */
      P$ = PINCRC(CHR$,6);
      DO WHILE (CUR_CHR = ' ');
         P$ = PINCRC(P$,1);
      END;
      IF CUR_CHR < '0' OR CUR_CHR > '9' THEN
         RETURN ;
      DO WHILE ((CUR_CHR >= '0' AND CUR_CHR <= '9') OR CUR_CHR = ' ');
         P$ = PINCRC(P$,1);
      END;
      IF P$->TEXT2 ~= 'TO' THEN
         RETURN;
      CHR$ = PINCRC(P$,2);
      RETURN;
END CHECK_ASSIGN_STMT ;
%EJECT ;
/*I*
      NAME: CHECK_DO_STMT
      PURPOSE: This routine is used to check if the current text
               string is a DO statement. If so, the DO syntax is
               skipped.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
CHECK_DO_STMT: PROC ALTRET ;
      DCL P$ PTR ;
      DCL CUR_CHR CHAR(1) BASED(P$);
/* */
      P$ = PINCRC(CHR$ ,2);
      DO WHILE (CUR_CHR = ' ');
         P$=PINCRC(P$,1);
      END;
      IF CUR_CHR < '0' OR CUR_CHR > '9' THEN
         ALTRETURN ;
      DO WHILE ((CUR_CHR >= '0' AND CUR_CHR <= '9') OR CUR_CHR = ' ');
         P$=PINCRC(P$,1);
      END;
      IF (CUR_CHR < 'A' OR CUR_CHR > 'Z') AND CUR_CHR ~= '$' AND
         CUR_CHR ~= '_' THEN
         ALTRETURN ;
      DO WHILE((CUR_CHR >= 'A' AND CUR_CHR <= 'Z') OR
               (CUR_CHR >= '0' AND CUR_CHR <= '9') OR
               CUR_CHR = '$' OR CUR_CHR = '_' OR CUR_CHR = ' ');
         P$ = PINCRC(P$,1);
      END;
      IF CUR_CHR ~= '=' THEN
         ALTRETURN;
      RETURN ;
END CHECK_DO_STMT ;
%EJECT ;
/*I*
      NAME: CHECK_DATA_STMT
      PURPOSE: This routine is used to check if the current text
               string is the DATA statement. If so, it then
               simply skips over the DATA statement text.
      CALL: Simple call with no passed parameters.
      INTERFACE:
                 none
*/
CHECK_DATA_STMT: PROC ALTRET ;
      DCL P$ PTR;
      DCL CUR_CHR CHAR(1) BASED(P$);
/* */
      P$ = PINCRC(CHR$,4);
      DO WHILE (CUR_CHR = ' ');
         P$ = PINCRC(P$,1);
      END;
      IF (CUR_CHR < 'A' OR CUR_CHR > 'Z' ) AND CUR_CHR ~= '(' THEN
         ALTRETURN ;
      RETURN;
END CHECK_DATA_STMT ;
END CHECK_FOR_KEY_WORD ;
/*
*/
END LONGFELLOW ;
