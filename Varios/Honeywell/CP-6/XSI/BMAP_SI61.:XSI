/*M* BMAP - The Conrad Bjerke Memorial Assembler Program */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* AIC,CLM=39,DMR,PLM=7,IND=4,DCI=4,THI=2,DTI=4,AND */
/**/
BMAP:  PROC MAIN;
/**/
%INCLUDE B$OBJECT_C;
%INCLUDE BMAP_C;
%INCLUDE CP_6_C;
%INCLUDE XUO$OBJ_C;
/**/
%M$DCB (DCBN=M$OU,ASN=FILE,ACS=DIRECT,ORG=KEYED,NAME='*G',
        FUN=CREATE,EXIST=NEWFILE,DISP=NAMED,TYPE='OG');
/**/
DCL ANSYM ENTRY (4);
DCL BITINSERT ENTRY (6) ALTRET;
DCL BREAK ENTRY ASYNC;
DCL CLOSE ENTRY ALTRET;
DCL CTLCRD ENTRY;
DCL DELSCAN ENTRY;
DCL ERROR ENTRY (1);
DCL EJECT ENTRY (3);
DCL GEN ENTRY (4);
DCL GENLOC ENTRY (2);
DCL GENVAL ENTRY (4);
DCL GETMAC ENTRY (1) ALTRET;
DCL GETSYM ENTRY (1) ALTRET;
DCL INST ENTRY ALTRET;
DCL KEYVAL ENTRY (1);
DCL LIST ENTRY (3);
DCL LISTCLOSE ENTRY;
DCL LISTOPEN ENTRY;
DCL LODM ENTRY (2) ALTRET;
DCL NEXTFLD ENTRY ALTRET;
DCL OCTAL ENTRY (3);
DCL OUERR ENTRY (3);
DCL PRINT ENTRY;
DCL PRINTO ENTRY;
DCL READCARD ENTRY (1);
DCL SYMTAB ENTRY (5);
DCL TEST ENTRY (5);
DCL TREESRCH ENTRY (6);
DCL TREESTEP ENTRY (2);
DCL VARSCAN ENTRY (3);
DCL XLATEV ENTRY (7) ALTRET;
%INCLUDE XUO$ENTRIES;
%INCLUDE XUD_UTS_M;
    %XUD$UTS_ENTRIES;
    %XUD_UTS_EQU;
/**/
%B$RELOCSUBS;
%B$SECTIONSUBS;
%BMAP_COMMON;
%COMPILERIDSUBS;
%CP6$ENTS;
/**/
DCL ATYPE(0:15) UBIN(9) UNAL CONSTANT INIT(3,1,0,1,0*12); /* VREBL types indexed by REL.OPNDTYP */
%B$SECTION(STCLASS="BASED(B$SECTION$)"); /* Control section table */
DCL B$SECTION$ PTR;                    /* -> control section table */
DCL BOUND(0:3) CHAR(5) CONSTANT INIT('EVEN','ODD','EIGHT','PAGE');
%B_SECTION_POINTERS;
DCL ENDTIME SBIN;                      /* Time of end of assembly */
DCL 1 ENDXTIME DALIGNED,               /* End time VLR for FPT_XEQTIME */
      2 * UBIN,
      2 USER UBIN,
      2 * UBIN,
      2 MON UBIN;
DCL F BIT(2);
DCL FB SBIN;                           /* First bit */
%FPT_EXIT;
%FPT_INT(UENTRY=BREAK);
%FPT_TIME(SOURCE=CLOCK,DEST=UTS);
%FPT_XEQTIME;
DCL I SBIN;
DCL IFORM(0:6) UBIN CONSTANT INIT(3,15,12,6,18,12,6); /* Non-EIS instruction format */
DCL II SBIN;
DCL IMN SBIN;
DCL IMN$ PTR;
DCL IND SBIN;
DCL J SBIN;
DCL JJ SBIN;
DCL K SBIN;
%LIT(STCLASS="BASED(T$)");             /* Literal packet */
DCL LVL SBIN;
%MAP;                                  /* Macro actual parameter */
DCL MC SBIN;
DCL MC$ PTR;
DCL MLACCT CHAR(8) ALIGNED;            /* LODM account */
DCL 1 MLNAME ALIGNED,                  /* LODM file name */
      2 LEN UBIN(9) UNAL,              /* Length of TEXT */
      2 TEXT CHAR(31);
DCL 1 NAMEO ALIGNED,                   /* Object unit name format */
      2 LEN UBIN(18) UNAL,             /* Length of TEXT */
      2 TEXT CHAR(30);
DCL NC SBIN;
DCL NSYM SBIN;
DCL NW SBIN;
DCL PREVIOUS SBIN;                     /* Previous control section number */
DCL R SBIN;
DCL R$ PTR;
%REL(NAME="REL(0:36)");                /* Relocation words for VAL */
DCL S SBIN;
DCL SECTYPE(0:%ROSECTION) CHAR(6) CONSTANT INIT('DATA','CODE','UCOM','LCOM','RLCOM','DCB','RODATA');
DCL STARTTIME SBIN;                    /* Time of start of assembly */
DCL 1 STARTXTIME DALIGNED,             /* Start time VLR for FPT_XEQTIME */
      2 * UBIN,
      2 USER UBIN,
      2 * UBIN,
      2 MON UBIN;
%SYM;                                  /* Symbol table packet */
DCL T$ PTR;
DCL TEMP SBIN;
DCL TSYM(0:5) UBIN;                    /* Internal name format */
DCL TV SBIN;
DCL VAL(0:36) SBIN;                    /* Values of fields of instruction */
DCL 1 VERSION CONSTANT SYMDEF,         /* BMAP Version */
%EQU VERSION='B00';
      2 LEVC CHAR(2) INIT(%SUBSTR(VERSION,1)),
      2 RELC CHAR(1) INIT(%SUBSTR(VERSION,0,1)),
      2 LEV UBIN(9)UNAL INIT(%CHARBIN(SUBSTR(VERSION,1)));
DCL W(0:36) UBIN;                      /* Widths (bits) of VALs */
DCL CARD_COUNT SBIN STATIC SYMDEF;
DCL CRD_COUNT SBIN;
%EJECT;
/* INITIALIZATION
*/
       FPT_XEQTIME.BUF_=VECTOR(STARTXTIME);
       CALL M$XEQTIME(FPT_XEQTIME);
       FPT_TIME.TSTAMP_=VECTOR(STARTTIME);
       CALL M$TIME(FPT_TIME);
       CALL CTLCRD;
       TITLEF=%F;
       TTLDAT=BITBIN('454620636343'O); /* BCD'NO TTL' */
       TERRCT=0;
       ERRSEV=0;
       PASS2 = 0;
       KEY=' ';
       CALL M$INT(FPT_INT);
       CALL LISTOPEN;
       SYMX=0;
       SYMTOP=0;
       SYMROOT=0;
       CALL XUO$OUINIT(DCBNUM(M$OU),OPTIONS.OU,~OPTIONS.ND,%GMAPID,VERSION,,,ENTADDR(OUERR));
       IF NOT OPTIONS.ND THEN DO;
               CALL XUO$LOGBLKALLOC(LOGBLK); /* Initialize debug schema */
               CALL XUO$LOGBLKEXSTINIT(LOGBLK,0,0,-1,1);
               CALL XUO$LOGBLKVREBLINIT(LOGBLK,0);
           END;
       MPOOL(0)=0; MCX=0; MACBOT=0; MMAX=0;
       CALL XUO$SECTBUILD(%CODESECTION,0,I,'10'B);
       CALL XUO$SECTBUILD(%ROSECTION,%LITERALS,I,'10'B);
       OUNAME.TEXT='NO-NAME';
       OUNAME.LEN=SIZEC('NO-NAME');
       OUNAMESW=0;
       PRIMENT=0;
       RECORDCT=0;
       STMNTCT=0;
       CRD_COUNT=-1;
%EJECT;
/* INITIALIZATION FOR EACH PASS
*/
L5:
       LITLOC=0;
       LITSECT=1;
       LITROOT=0;
       LIT$=ADDR(NIL);
       ERRCT=0;
       INHIB=%F;
       IDS=4;
       NDS=0;
       DO I=0 TO 3;
           MF(I)='0'B;
       END;
       MLVL=1; MAC$=ADDR(MPOOL(MLVL));
       MAC='0'B;
       MACSV=%F;
       PC=0;
       PCREL='0'B; PCREL.OPNDTYP=%OPERSECT; PCREL.RELOCOP=%RELOCOPADD;
       OLDREL=%T;
       PREVIOUS=0;
       B$SECTION$=B_SECTION_BASE$;
       DO WHILE (B$SECTION$<B_SECTION_CUR$);
           B$SECTION.MBZ=0;
           B$SECTION$=PINCRW(B$SECTION$,SIZEW(B$SECTION));
       END;
       LINES=' ';
       LINECT=0;
       LISTING(0)='777777777777'O;     /* DETAIL ON */
       LISTING(1)='777777777777'O;     /* LIST ON */
       LISTING(2)='0'B;                /* PMC OFF */
       LISTING(3)='777777777777'O;     /* HEXFP ON */
       LISTING(4)='0'B;                /* CRSM OFF */
       LISTING(5)='0'B;                /* FLOAT OFF */
       LISTING(6)='777777777777'O;     /* PCC ON */
       LISTING(7)='777777777777'O;     /* REF ON */
       LISTING(8)='777777777777'O;     /* REFMA ON */
       CRSMNO=0;
       LINEF='0'B;
       CARD_COUNT=0;
%EJECT;
/* PROCESS STATEMENT
*/
L10:
       CARD_COUNT=CARD_COUNT + 1 ;
       CALL READCARD(%F);
       IF 34<=OP.TYPE AND OP.TYPE<=36 THEN CALL BOUNDARY(2,0,%F);
       IF OP.PRFS&'01'B AND LOC(0)~=0 THEN DO;
               CALL SYMTAB(LOC,PC,PCREL,%T);
               CALL GENLOC;
           END;
       DO CASE(OP.TYPE);
%EJECT;
/* USE, BLOCK
*/
        CASE(7);
           STMNTCT=STMNTCT+1;
           J=PCREL.OPERAND;
           B$SECTION$=PINCRW(B_SECTION_BASE$,J*SIZEW(B$SECTION));
           B$SECTION.MBZ=PC;
           IF PC>B$SECTION.SIZE THEN B$SECTION.SIZE=PC;
           IF OP.MASK~=0 THEN
               DO I=0 TO LOC(0);
                   TSYM(I)=LOC(I); END;
             ELSE DO;
                   IF LOC(0)~=0 THEN CALL PRINT;
                   TSYM(0)=0;
                   CALL NEXTFLD ALTRET(L730);
                   IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='PREVIOUS' THEN DO;
                           J=PREVIOUS;
                           B$SECTION$=PINCRW(B_SECTION_BASE$,J*SIZEW(B$SECTION));
                           K=B$SECTION.NPOINTER;
                           IF K<0 THEN K=262144+K;
                           IF K=0 THEN TSYM(0)=0;
                             ELSE DO I=0 TO SPOOL(K);
                                   TSYM(I)=SPOOL(K+I); END;
                       END/* IF SUBSTR(XCARDS, */;
                     ELSE
                       %CONSYM(#SYM=TSYM);
L730:
                   CURRCH=NEXTCH;
               END/* IF OP.MASK ELSE */;
           PREVIOUS=J;
           B$SECTION$=B_SECTION_BASE$;
           J=0;
           DO WHILE (B$SECTION$<B_SECTION_CUR$);
               K=B$SECTION.NPOINTER;
               IF K<0 THEN K=262144+K;
               IF K=0 THEN DO;
                       IF B$SECTION.SIZE=0 THEN DO;
                               B$SECTION.TYPE=OP.VAL;
                               GOTO L750;
                           END;
                       IF TSYM(0)=0 THEN GOTO L760;
                   END/* IF K */;
                 ELSE DO;
                       CALL TEST(TSYM(1),TSYM(0),SPOOL(K+1),SPOOL(K),IND);
                       IF IND=0 THEN GOTO L760;
                   END;
               B$SECTION$=PINCRW(B$SECTION$,SIZEW(B$SECTION));
               J=J+1;
           END;
           IF PASS2>0 THEN CALL ERROR(6);
           CALL XUO$SECTBUILD(BINBIT(OP.VAL,36),0,J,'10'B);
L750:
           IF B$SECTION.TYPE=%RLCOMSECTION AND TSYM(0)=0 THEN B$SECTION.TYPE=%UCOMSECTION;
L760:
           K=B$SECTION.MBZ;
           CALL GENLOC(K,J);
           IF DEL=%COMMA THEN DO;
                   CALL VARSCAN(VAL(0),REL(0),'0'O);
                   IF REL(0) THEN CALL ERROR(-5);
                   B$SECTION.TYPE=VAL(0);
               END/* IF DEL */;
           IF TSYM(0)=0 THEN DO;
                   K=B$SECTION.TYPE;
                   IF K>=%LCOMSECTION AND K<=%DCBSECTION THEN CALL ERROR(7);
               END;
             ELSE IF B$SECTION.NPOINTER=0 THEN DO;
                       CALL GETSYM(TSYM(0)+1) ALTRET(L90);
                       DO I=0 TO TSYM(0);
                           SPOOL(SYMX+I)=TSYM(I); END;
                       B$SECTION.NPOINTER=SYMX;
                   END;
%EJECT;
/* EJECT, TTL, TTLS
*/
        CASE(8);
           IF PASS2=0 THEN GOTO L90;
           STMNTCT=STMNTCT+1;
           IF NOT (LISTF AND (MLVL=1 OR PMC AND MLVL~=1)) THEN GOTO L90;
           TITLEF=%T;
           IF OP.VAL~=0 THEN DO;
                   CALL SEARCH(CURRCH,K,NONBLK,XCARDS,NEXTCH);
                   IF NEXTCH<=13 AND CURRCH>15 THEN CURRCH=15;
                   CALL EJECT(SUBSTR(XCARDS,CURRCH),XCARDL-CURRCH,%T);
                   IF OP.VAL=1 THEN CALL XLATEV(6,TTLDAT,0,6,ASCII.BCD,SUBSTR(XCARDS,CURRCH+47),6);
               END;
             ELSE CALL EJECT(,,%F);
%EJECT;
/* END
*/
        CASE(9);
L900:
           STMNTCT=STMNTCT+1;
           IF PASS2=0 THEN DO;
                                       /* END PASS 1 */
                   CALL CLOSE;
                   PASS2=1;
                   CRD_COUNT=CARD_COUNT;
                   GOTO L5;
               END;
                                       /* END PASS 2 */
           IF CRD_COUNT ~= CARD_COUNT THEN
               DO ;
                   IF CARD_COUNT < 3 THEN
                       IF CRD_COUNT >= 0 THEN
                           CALL ERROR( 20) ;
               END ;
 
           CALL XUO$HEADNAME(OUNAME);
           IF SYMX=0 THEN CALL GETSYM(1);
                                       /* PROCESS START ADDRESS */
           CALL VARSCAN(VAL(0),REL(0),'0'O);
           CALL CLOSE;
           IF REL.OPNDTYP(0)~=0 THEN DO;
                   IF REL.OPNDTYP(0)=%OPERUNDEF OR REL.RELOCOP(0)~=%RELOCOPADD OR REL.EVALOP(0)~=0 OR REL.S(0) THEN
                       CALL ERROR(5);  /* RELOCATION ERROR */
                     ELSE
                       CALL XUO$HEADSTART(BINBIT(REL.OPNDTYP(0),36),BINBIT(REL.OPERAND(0),36),VAL(0));
                   CALL GENVAL(1,18,VAL,REL);
               END;
           CALL PRINT;
           J=PCREL.OPERAND;
           B$SECTION$=PINCRW(B_SECTION_BASE$,J*SIZEW(B$SECTION));
           IF PC>B$SECTION.SIZE THEN B$SECTION.SIZE=PC;
           CALL GENLITS;               /* GENERATE LITERALS */
           LINES='*';
           S=SYMROOT;
           LVL=SYMX;
L960:                                  /* PRINT UNDEFINED SYMBOLS */
           CALL TREESTEP(S,LVL);
           IF S=0 THEN GOTO L965;
           SYM$=ADDR(SPOOL(S));
           IF SYM.R.OPNDTYP~=%OPERUNDEF THEN GOTO L960;
           CALL ANSYM(SYM.BOL,BINBIT(SYM.LEN,36),SUBSTR(LINES,4),NC);
           IF SUBSTR(LINES,0,1)='*' THEN DO; CALL INSERT(LINES,0,1,' ');
                   CALL LIST(LINE,1,%F);
                   CALL LIST('  UNDEFINED SYMBOLS:',20,%T);
                   CALL LIST(LINE,1,%F);
               END;
           IF NC=0 THEN DO; CALL INSERT(LINES,4,7,'(BLANK)'); NC=7; END;
           CALL LIST(LINE,NC+4,%T);
           TERRCT=TERRCT+1; IF ERRSEV<4 THEN ERRSEV=4;
           GOTO L960;
/**/
L965:              /* PRINT CONTROL SECTION TABLE AND INSERT NAME POINTERS */
           CALL INSERT(LINES,0,1,' ');
           CALL LIST(LINE,1,%F);
           CALL LIST('  CONTROL SECTION TABLE',23,%F);
           CALL LIST(LINE,1,%F);
           B$SECTION$=B_SECTION_BASE$;
           J=0;
           DO WHILE (B$SECTION$<B_SECTION_CUR$);
               LINES=' ';
               CALL DECIMAL(J,SUBSTR(LINES,1),3,0);
               CALL INSERT(LINES,5,6,SECTYPE(B$SECTION.TYPE));
               CALL INSERT(LINES,12,5,BOUND(B$SECTION.BOUND));
               CALL OCTAL(BINBIT(B$SECTION.SIZE,36),SUBSTR(LINES,18),6);
               IF B$SECTION.NPOINTER=0 THEN DO;
                       NC=0;
                       B$SECTION.NPOINTER=-1;
                   END;
                 ELSE DO;
                       K=B$SECTION.NPOINTER;
                       IF K<0 THEN K=262144+K;
                       CALL ANSYM(SPOOL(K+1),SPOOL(K),SUBSTR(LINES,25),NC);
                       %OBJSYM(#S="SUBSTR(LINES,25,NC)",#SYM=NAMEO);
                       CALL XUO$DNAME(NAMEO,K);
                       B$SECTION.NPOINTER=K;
                   END;
               CALL LIST(LINE,25+NC,%F);
               B$SECTION.MBZ=0;
               B$SECTION$=PINCRW(B$SECTION$,SIZEW(B$SECTION));
               J=J+1;
           END/* WHILE B$SECTION$ */;
           CALL XUO$HEAD_SEVERITY(ERRSEV);
           IF PRIMENT=0 THEN DO;
                   CALL XUO$DNAME(OUNAME,I); /* NO ENTDEF: CREATE ONE OF OUNAME */
                   CALL XUO$EDEF(0,0,I,%T,%F,%F,1,0);
               END;
%EJECT;
/* GENERATE VARIABLE DEBUG SCHEMA AND PRINT SYMBOL CROSS-REFERENCE TABLE
*/
           IF OPTIONS.XR THEN OPTIONS.LS=%T;
           S=SYMROOT;
           LVL=SYMX;
           NSYM=0;
L981:
           CALL TREESTEP(S,LVL);
           IF S~=0 THEN DO;
                   NSYM=NSYM+1;
                   SYM$=ADDR(SPOOL(S));
                   LINES=' ';
                   CALL ANSYM(SYM.BOL,BINBIT(SYM.LEN,36),SUBSTR(LINES,23),NC);
                   J=SYM.R.OPERAND;
                   IF SYM.R.OPNDTYP=%OPERSECT THEN DO;
                           B$SECTION$=PINCRW(B_SECTION_BASE$,J*SIZEW(B$SECTION));
                           IF B$SECTION.TYPE=%CODESECTION THEN K=0;
                             ELSE IF B$SECTION.TYPE=%DCBSECTION THEN K=4;
                                 ELSE K=1;
                       END/* IF SYM.R.OPNDTYP=%OPERSECT */;
                     ELSE K=ATYPE(SYM.R.OPNDTYP);
                   IF K~=0 AND NOT SYM.R.F.SET THEN DO;
                           %OBJSYM(#S="SUBSTR(LINES,23,NC)",#SYM=NAMEO);
                           CALL XUO$DBGNAME(NAMEO,I);
                           CALL XUO$VREBL(SYM.VAL*36,K,1,SYM.R.F.REFED,%F,36,1,1,%F,0,BINBIT(SYM.R.OPNDTYP,36),-1,J,0,0,0,I);
                       END;
                   IF OPTIONS.XR THEN DO;
                           IF NSYM=1 THEN CALL EJECT('SYMBOL TABLE',SIZEC('SYMBOL TABLE'),%T);
                           CALL OCTAL(BITBIN(SYM.R.F),SUBSTR(LINES,1),2);
                           CALL BINCHAR(SUBSTR(LINES,3,1),SYM.R.OPNDTYP);
                           CALL BINCHAR(SUBSTR(LINES,4,1),SYM.R.EVALOP);
                           CALL BINCHAR(SUBSTR(LINES,5,1),SYM.R.RELOCOP);
                           CALL BINCHAR(SUBSTR(LINES,6,3),J);
                           CALL OCTAL(SYM.VAL,SUBSTR(LINES,10),12);
                           R=SYM.REFLINK;
                           NC=((NC+36)/10)*10-5;
                           IF NC<35 THEN NC=35;
                           IF R~=0 THEN DO;
                                   REF$=ADDR(SPOOL(R));
                                   DO WHILE (ADDR(SPOOL(REF.LINK))->REF.KEY>REF.KEY);
                                       REF$=ADDR(SPOOL(REF.LINK));
                                   END;
                                   T$=REF$;
L984:
                                   REF$=ADDR(SPOOL(REF.LINK));
                                   IF NC>100 THEN DO;
                                           CALL LIST(LINE,NC,%F);
                                           LINES=' ';
                                           NC=35;
                                       END;
                                   CALL UNPACKEY(REF.KEY,SUBSTR(LINES,NC+1));
                                   IF REF.DEF THEN DO;
                                           CALL SEARCH(I,J,NONBLK,LINES,NC+1);
                                           CALL INSERT(LINES,I-1,1,'*');
                                       END;
                                   NC=NC+10;
                                   IF REF$~=T$ THEN GOTO L984;
                               END/* IF R */;
                           CALL LIST(LINE,NC,%F);
                       END/* IF OPTIONS.XR */;
                   GOTO L981;
               END/* IF S */;
           IF NOT OPTIONS.ND THEN DO;
                   CALL XUO$EXSTNUM(I); /* Terminate debug schema */
                   CALL KEYVAL(J);
                   CALL XUO$LOGBLKEXSTTERM(LOGBLK,I,J);
                   CALL XUO$VREBLNUM(I);
                   CALL XUO$LOGBLKVREBLTERM(LOGBLK,I);
               END;
           CALL XUO$OUTERM;
           LINES='         SYMBOLS';
           IF NSYM=1 THEN CALL INSERT(LINES,15,1,' ');
           CALL LIST(LINE,1,%F);
           CALL DECIMAL(NSYM,SUBSTR(LINES,4),4,0);
           CALL LIST(LINE,16,%F);
%EJECT;
/* PRINT MACRO CROSS-REFERENCE TABLE
*/
           S=OPROOT;
           LVL=SYMX;
           NSYM=0;
           F=%T;
L9981:
           CALL TREESTEP(S,LVL);
           IF S~=0 THEN DO;
                   OP$=ADDR(SPOOL(S));
                   IF OP.TYPE~=21 THEN GOTO L9981;
                   NSYM=NSYM+1;
                   IF OPTIONS.XR THEN DO;
                           R=MP.REF(OP.VAL);
                           IF R=0 THEN GOTO L9981;
                           IF F THEN DO;
                                   CALL EJECT('MACRO TABLE',SIZEC('MACRO TABLE'),%T);
                                   F=%F;
                               END;
                           LINES=' ';
                           CALL ANSYM(OP.SYM,BINBIT(OP.LEN,36),SUBSTR(LINES,1),NC);
                           NC=((NC+16)/10)*10-7;
                           IF NC<13 THEN NC=13;
                           REF$=ADDR(SPOOL(R));
                           DO WHILE (ADDR(SPOOL(REF.LINK))->REF.KEY>REF.KEY);
                               REF$=ADDR(SPOOL(REF.LINK));
                           END;
                           T$=REF$;
L9984:                     DO;
                               REF$=ADDR(SPOOL(REF.LINK));
                               IF NC>100 THEN DO;
                                       CALL LIST(LINE,NC,%F);
                                       LINES=' ';
                                       NC=13;
                                   END;
                               CALL UNPACKEY(REF.KEY,SUBSTR(LINES,NC+1));
                               NC=NC+10;
                               IF REF$~=T$ THEN GOTO L9984;
                           END L9984;
                           CALL LIST(LINE,NC,%F);
                       END/* IF OPTIONS.XR */;
                   GOTO L9981;
               END/* IF S */;
           LINES='         MACROS';
           IF NSYM=1 THEN CALL INSERT(LINES,14,1,' ');
           CALL LIST(LINE,1,%F);
           CALL DECIMAL(NSYM,SUBSTR(LINES,4),4,0);
           CALL LIST(LINE,15,%F);
%EJECT;
/* PRINT ASSEMBLY SUMMARY, CLOSE LIST FILE, AND EXIT
*/
           CALL LIST(LINE,1,%F);
           LINES='    SYMBOL SPACE USED       WORDS';
           CALL DECIMAL(SYMTOP-SYMX,SUBSTR(LINES,22),5,0);
           CALL LIST(LINE,33,%F);
           CALL INSERT(LINES,4,6,' MACRO');
           CALL DECIMAL(MMAX-MACBOT,SUBSTR(LINES,22),5,0);
           CALL LIST(LINE,33,%F);
           LINES='   INPUT RECORDS READ';
           CALL DECIMAL(RECORDCT,SUBSTR(LINES,22),5,0);
           CALL LIST(LINE,27,%F);
           LINES=' STATEMENTS PROCESSED';
           CALL DECIMAL(STMNTCT,SUBSTR(LINES,22),5,0);
           CALL LIST(LINE,27,%F);
           LINES='         ELAPSED TIME MM:SS.HH';
           FPT_TIME.TSTAMP_=VECTOR(ENDTIME);
           CALL M$TIME(FPT_TIME);
           CALL XUD$UTS_DIFF(ENDTIME,ENDTIME,STARTTIME);
           CALL DECIMAL(ENDTIME/6000,SUBSTR(LINES,22),2,0);
           CALL BINCHAR(SUBSTR(LINES,25,2),MOD(ENDTIME/100,60));
           CALL BINCHAR(SUBSTR(LINES,28,2),ENDTIME);
           CALL LIST(LINE,30,%F);
           LINES='             CPU TIME SSSSS.HH SEC.';
           FPT_XEQTIME.BUF_=VECTOR(ENDXTIME);
           CALL M$XEQTIME(FPT_XEQTIME);
           ENDTIME=(ENDXTIME.USER-STARTXTIME.USER)+(ENDXTIME.MON-STARTXTIME.MON);
           ENDTIME=(ENDTIME+5000)/10000;
           CALL DECIMAL(ENDTIME/100,SUBSTR(LINES,22),5,0);
           CALL BINCHAR(SUBSTR(LINES,28,2),ENDTIME);
           CALL LIST(LINE,35,%F);
           LINES='        ASSEMBLY RATE XXXXX STATEMENTS/CPU MIN.';
           IF ENDTIME=0 THEN ENDTIME=1;
           CALL DECIMAL(((STMNTCT*60000)/ENDTIME+5)/10,SUBSTR(LINES,22),5,0);
           CALL LIST(LINE,47,%F);
           LINES='      NO ERRORS';
           CALL LIST(LINE,1,%F);
           IF TERRCT~=0 THEN DO;
                   CALL DECIMAL(TERRCT,SUBSTR(LINES,4),4,0);
                   IF TERRCT=1 THEN CALL INSERT(LINES,14,1,' ');
               END;
           CALL LIST(LINE,15,%T);
           CALL EJECT(,,%F);
           CALL LISTCLOSE;
           IF ERRSEV>0 THEN FPT_EXIT.V.STEPCC#=(ERRSEV-1)/3;
           CALL M$EXIT(FPT_EXIT);
%EJECT;
/* EIGHT, EVEN, ODD, PAGE
*/
        CASE(11);
           STMNTCT=STMNTCT+1;
           CALL BOUNDARY(BINBIT(OP.VAL,36),BINBIT(OP.MASK,36),LOC(0)=0);
           IF LOC(0)~=0 THEN CALL SYMTAB(LOC,PC,PCREL,%T);
%EJECT;
/* ORG
*/
        CASE(12);
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL(0),REL(0),'0'O);
           B$SECTION$=PINCRW(B_SECTION_BASE$,PCREL.OPERAND*SIZEW(B$SECTION));
           IF PC>B$SECTION.SIZE THEN B$SECTION.SIZE=PC;
           IF REL.OPNDTYP(0)=%OPERUNDEF OR REL.EVALOP(0)~=0 AND REL.OPNDTYP(1)=%OPERUNDEF THEN CALL ERROR(-6);
           CALL GENLOC(VAL(0));
           IF LOC(0)~=0 THEN CALL SYMTAB(LOC,PC,PCREL,%T);
%EJECT;
/* MACRO DEFINITION
*/
        CASE(20);
           STMNTCT=STMNTCT+1;
           IF MAC.DUPSV OR MAC.DUP THEN DO; CALL ERROR(2); GOTO L90; END;
           DO I=0 TO 5;
               TSYM(I)=LOC(I); END;
           CALL GETMAC(1) ALTRET(L2018);
           MC=MCX;
           NC=0;
           MACSV=%T;
L2010:     CALL PRINT;
           CARD_COUNT=CARD_COUNT + 1 ;
           CALL READCARD(%F);
           IF IOP=%ENDM OR IOP=%ENDOP THEN GOTO L2020;
           IF PASS2>0 THEN GOTO L2010;
           IF NC<0 THEN GOTO L2010;
           CALL SEARCHR(XCARDL,K,NONBLK,XCARDS,XCARDL) ALTRET(L2010);
           XCARDL=XCARDL+1;
           CALL INDEX1(I,' ',XCARDS) ALTRET(SVMAC);
           CALL SEARCH(J,K,NONBLK,XCARDS,I) ALTRET(SVMAC);
           IF I<=6 AND J>=15 OR J>=I+15 THEN
               XCARDL=I;
             ELSE DO;
                   CALL INDEX1(II,' ',XCARDS,J) ALTRET(MVOP);
                   CALL SEARCH(JJ,K,NONBLK,XCARDS,II);
                   IF J=7 AND II<=13 AND JJ>15 OR JJ>II+16 THEN
                       XCARDL=II;
                     ELSE DO;
                           II=II+1;
                           IF JJ>II THEN DO;
                                   CALL INSERT(XCARDS,II,,SUBSTR(XCARDS,JJ));
                                   XCARDL=XCARDL+II-JJ;
                               END;
                       END/* IF J ELSE */;
MVOP:
                   I=I+1;
                   IF J>I THEN DO;
                           CALL INSERT(XCARDS,I,,SUBSTR(XCARDS,J));
                           XCARDL=XCARDL+I-J;
                       END;
               END/* IF I ELSE */;
SVMAC:
           NW=(XCARDL+4)/4;
           CALL GETMAC(NW) ALTRET(L2017);
           MC$=ADDR(MPOOL(MCX));
           MC$->MAP.LEN=XCARDL;
           MC$->MAP.TEXT=XCARDS;
           MCX=MCX+NW-1;
           NC=NC+1;
           GOTO L2010;
/**/
L2017:
           MCX=MC-1;
L2018:
           NC=-1;
           GOTO L2010;
/**/
L2020:
           MACSV=%F;
           IF NC<0 THEN GOTO L2040;
           IF TSYM(0)=0 THEN DO; CALL ERROR(7); MCX=MC; GOTO L2040; END;
           IF PASS2>0 THEN GOTO L2040;
           CALL TREESRCH(OPROOT,TSYM(1),TSYM(0),SIZEW(OP),%T,IMN);
           IF IMN=0 THEN DO; MCX=MC-1; GOTO L2040; END;
           IF IMN>0 THEN DO; CALL ERROR(-13); MCX=MC-1; GOTO L2040; END;
           IMN=-IMN;
           IMN$=ADDR(SPOOL(IMN));
           IMN$->OP.PRFS='01'B; IMN$->OP.TYPE=21;
           IMN$->OP.VAL=MC;
           MPOOL(MC)=NC;
L2040:
           IF IOP=%ENDOP THEN GOTO L900;
%EJECT;
/* BSS
*/
        CASE(24);
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL(0),REL(0),'0'O);
           IF REL(0) THEN CALL ERROR(-5);
           CALL GENLOC;
           CALL PRINT;
           PC=PC+VAL(0);
           IF NOT OP.PRFS&'01'B AND LOC(0)~=0 THEN CALL SYMTAB(LOC,PC,PCREL,%T); /* BFS */
           GOTO L10;
%EJECT;
/* OPSYN
*/
        CASE(38);
           IF PASS2>0 THEN GOTO L90;
           STMNTCT=STMNTCT+1;
           CALL NEXTFLD ALTRET(L3810);
           %CONSYM(#SYM=TSYM);
           CALL TREESRCH(OPROOT,TSYM(1),TSYM(0),SIZEW(OP),%F,J);
           IF J=0 THEN DO;
L3810:
                   CALL ERROR(-4);
                   GOTO L90;
               END;
           CALL TREESRCH(OPROOT,LOC(1),LOC(0),SIZEW(OP),%T,IMN);
           IF IMN=0 THEN GOTO L90;
           IF IMN>0 THEN DO; CALL ERROR(-13); GOTO L90; END;
           IMN=-IMN;
           ADDR(SPOOL(IMN))->OP1.TYPE=ADDR(SPOOL(J))->OP1.TYPE;
%EJECT;
/* DETAIL, LIST, PMC, HEXFP, CRSM, FLOAT, PCC, REF, REFMA
*/
        CASE(39);
           I=OP.VAL;
           DO CASE(I);
            CASE(0,1,2,6);
               IF PASS2=0 THEN GOTO L90;
           END;
           STMNTCT=STMNTCT+1;
L3910:
           CALL NEXTFLD ALTRET(L3990);
           IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='ON' THEN
               LISTING.F(I)=%T;
             ELSE IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='OFF' THEN
                   LISTING.F(I)=%F;
                 ELSE IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='SAVE' THEN
                       LISTING.STACK(I)=LISTING(I);
                     ELSE IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='RESTORE' THEN
                           LISTING(I)=LISTING.STACK(I)|'000000000001'O;
                         ELSE DO;
                               CALL ERROR(4);
L3990:
                               IF (I=1 AND NOT LISTF OR I=2 AND PMC) AND MLVL~=1 AND NOT CARDPR(0) THEN DO;
                                       J=MLVL;
                                       MLVL=1; IF I=1 THEN LISTF=%T;
                                       CALL PRINT;
                                       MLVL=J; IF I=1 THEN LISTF=%F;
                                   END;
                               GOTO L90;
                           END/* IF SUBSTR ELSE */;
           CURRCH=NEXTCH;
           GOTO L3910;
%EJECT;
/* OUNAME (OPERAND IS NAME OF 'NAME')
*/
        CASE(40);
           IF PASS2>0 THEN GOTO L90;
           STMNTCT=STMNTCT+1;
           IF OUNAMESW=3 THEN DO;
                   CALL ERROR(-15);
                   GOTO L90;
               END;
           IF XCARD(CURRCH+1)='''' THEN CURRCH=CURRCH+1;
           CALL NEXTFLD ALTRET(OUNAMERR);
           IF XCARD(CURRCH-1)='''' THEN DO;
                   CALL INDEX1(I,'''',XCARDS,CURRCH) ALTRET(OUNAMERR);
                   IF I=NEXTCH-1 THEN NEXTCH=I;
                     ELSE DO;
OUNAMERR:
                           CALL ERROR(-16);
                           GOTO L90;
                       END;
               END/* IF XCARD(CURRCH-1) */;
           OUNAMESW=3;
           %OBJSYM(#S="SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)",#SYM=OUNAME);
%EJECT;
/* LOAD MACRO LIBRARY
*/
        CASE(41);
           IF PASS2>0 THEN GOTO L90;
           STMNTCT=STMNTCT+1;
           CALL NEXTFLD ALTRET(L4190);
           CALL INDEX1(I,'.',SUBSTR(XCARDS,0,NEXTCH),CURRCH);
           MLNAME.TEXT=SUBSTR(XCARDS,CURRCH,I-CURRCH);
           MLNAME.LEN=I-CURRCH;
           IF MLNAME.LEN~=0 AND MLNAME.LEN<=31 AND NEXTCH-I-1<=8 THEN DO;
                   IF I<NEXTCH THEN MLACCT=SUBSTR(XCARDS,I+1,NEXTCH-I-1);
                     ELSE MLACCT=' ';
                   CALL LODM(MLNAME,MLACCT) ALTRET (L4180);
                   DO WHILE(%F);
L4180:                                 /* MACRO LIBRARY NOT FOUND */
                       CALL ERROR(-17);
                   END;
               END/* IF MLNAME.LEN */;
             ELSE DO;
L4190:                                 /* LODM SYNTAX ERROR */
                   CALL ERROR(-18);
               END;
%EJECT;
/* ORGCSM
*/
        CASE(43);
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL(0),REL(0),'0'O);
           IF REL(0) THEN CALL ERROR(-5);
           IF VAL(0)<0 OR VAL(0)>9999 THEN CALL ERROR(-4);
           CRSMNO=VAL(0);
           CALL DECIMAL(CRSMNO,SUBSTR(LINES,21),4,0);
           LINECT=26;
%EJECT;
/* LIT
*/
        CASE(45);
           IF PASS2~=0 THEN DO;
                   STMNTCT=STMNTCT+1;
                   IF LIT$~=ADDR(NIL) THEN CALL ERROR(2);
                     ELSE DO;
                           I=PC;
                           J=PCREL.OPERAND;
                           IF LOC(0)~=0 THEN DO;
                                   PCREL.OPERAND=LITSECT;
                                   CALL SYMTAB(LOC,0,PCREL,%T);
                               END;
                           CALL GENLITS;
                           LITLOC=0;
                           CALL XUO$SECTBUILD(%ROSECTION,%LITERALS,LITSECT,'10'B);
                           LITROOT=0;
                           PC=I;
                           PCREL.OPERAND=J;
                       END/* IF LIT$ ELSE */;
               END/* IF PASS2 */;
%EJECT;
/* OTHER OPERATION CODE
*/
        CASE(ELSE);
           CALL INST ALTRET(L10);
       END/* CASE OP.TYPE */;
L90:
       CALL PRINT;
       GOTO L10;
%EJECT;
/* FORCE BOUNDARY
*/
BOUNDARY: PROC (NW,ODD,CDF);
DCL NW SBIN;                           /* Boundary: 2, 8, or 1024 */
DCL ODD SBIN;                          /* Odd boundary if 1, even if 0 */
DCL CDF BIT(1) ALIGNED;                /* Print card */
/**/
DCL ATTR UBIN;                         /* Bound value for section table */
DCL NEWPC SBIN;                        /* New program counter value */
/**/
DCL NOP(0:2) BIT(36) ALIGNED STATIC INIT('0'B,'000000000110'O,'0'B);
DCL TRA(0:2) BIT(36) ALIGNED STATIC INIT('0'B,'000000007100'O,'000000000004'O);
DCL ZEROS(0:2) BIT(72) CONSTANT INIT('0'B*3);
/**/
       ATTR=%EVENBOUNDSECTION;
       IF NW=8 THEN ATTR=%EIGHTBOUNDSECTION;
       IF NW=1024 THEN ATTR=%PAGEBOUNDSECTION;
       IF ATTR~=%EVENBOUNDSECTION THEN DO;
               B$SECTION$=PINCRW(B_SECTION_BASE$,PCREL.OPERAND*SIZEW(B$SECTION));
               IF ATTR>B$SECTION.BOUND THEN B$SECTION.BOUND=ATTR;
           END;
       IF MOD(PC,NW)=ODD THEN RETURN;
       NEWPC=((PC+NW-1)/NW)*NW+ODD;
       IF NW=2 THEN DO;
               NOP(1)=NOP(1)&'777777777775'O|INHIB&'000000000002'O;
               CALL GEN(3,IFORM(4),NOP,ZEROS);
           END;
         ELSE DO;
               TRA(1)=TRA(1)&'777777777775'O|INHIB&'000000000002'O;
               TRA(0)=BINBIT(NEWPC-PC,36);
               CALL GEN(3,IFORM(4),TRA,ZEROS);
           END;
       IF CDF THEN CALL PRINT;
         ELSE CALL PRINTO;
       CALL GENLOC(NEWPC);
       RETURN;
END BOUNDARY;
%EJECT;
/* CONVERT DECIMAL INTEGER TO CHARACTER STRING
*/
DECIMAL: PROC (VAL,S,NC,NF);
DCL VAL SBIN;                          /* Value to be converted */
DCL S CHAR(12);                        /* (output) character string */
DCL NC SBIN;                           /* Length (characters) of S */
DCL NF SBIN;                           /* # digits to right of decimal point */
/**/
%INCLUDE B_MICROPS_C;
/**/
DCL I SBIN;
DCL MOP(0:3) BIT(9) STATIC INIT(%MVZB16,%MVC1,%INSP7,%MVC16); /* Edit microp string */
DCL 1 M(0:3) REDEF MOP,
      2 * BIT(5),
      2 N UBIN(4) UNAL;
DCL TS CHAR(11);
/**/
       CALL BINCHAR(TS,VAL);
       I=NC-BITBIN(NF~=0);
       M.N(0)=I-NF-1;
       M.N(3)=NF;
       CALL EDITSTR(S,0,NC,MOP,SUBSTR(TS,SIZEC(TS)-I));
       RETURN;
END DECIMAL;
%EJECT;
/* GENERATE LITERALS
*/
GENLITS: PROC;
/**/
DCL I SBIN;
DCL J SBIN;
/**/
       CALL GENLOC(0,LITSECT);
       LITLOC=0;
       LIT$=ADDR(NIL);
       DO WHILE (%T);
           S=LITROOT;
           LVL=SYMX;
           I=0;
           DO WHILE (%T);              /* GENERATE LITERAL CODE */
               CALL TREESTEP(S,LVL);
               IF S=0 THEN GOTO NEXTLIT;
               T$=ADDR(SPOOL(S));
               IF LIT.PC=LITLOC THEN GOTO NEXTLIT1;
                 ELSE IF LIT.PC>LITLOC AND LIT.PC<J THEN DO;
                           I=S;
                           J=LIT.PC;
                       END;
           END/* WHILE %T */;
NEXTLIT:
           IF I=0 THEN GOTO ENDLIT;
           T$=ADDR(SPOOL(I));
NEXTLIT1:
           R$=PINCRW(T$,LIT.RX);
           DO I=0 TO LIT.RX-1;
               K=0;
               FB=0;
               DO WHILE (R$<PINCRW(T$,LIT.LEN) AND R$->LIT.R.DISP(0)=I);
                   IF R$->LIT.R.STBIT(0)~=FB THEN DO;
                           W(K)=R$->LIT.R.STBIT(0)-FB;
                           REL(K)='0'B;
                       END;
                     ELSE DO;
                           W(K)=R$->LIT.R.ENDBIT(0)+1-R$->LIT.R.STBIT(J);
                           REL(K)=R$->LIT.R(0);
                           REL.VALUE(K)=R$->LIT.R.VALUE(0);
                           R$=PINCRW(R$,SIZEW(LIT.R));
                       END;
                   IF W(K)=36 THEN VAL(K)=LIT.V(I);
                     ELSE CALL BITINSERT(VAL(K),36-W(K),W(K),LIT.V(I),FB,36);
                   FB=FB+W(K);
                   K=K+1;
               END/* WHILE R$ */;
               IF FB~=36 THEN DO;
                       VAL(K)=LIT.V(I);
                       REL(K)='0'B;
                       W(K)=36-FB;
                       K=K+1;
                   END;
               CALL GEN(K,W,VAL,REL);
               CALL PRINT;
           END/* DO I */;
           LITLOC=LITLOC+LIT.RX;
       END/* WHILE %T */;
ENDLIT:
       CALL XUO$SECTSIZE(LITSECT,LITLOC);
       RETURN;
END GENLITS;
%EJECT;
/* INCREMENT CURRCH
*/
INCURR: PROC ALTRET;                   /* Alternate return: end of line */
       CURRCH=CURRCH+1;
L9010:
       IF CURRCH>NEXTCH THEN DO;
               CALL DELSCAN;
               GOTO L9010;
           END;
       IF CURRCH=NEXTCH AND DEL>=%COMMA THEN ALTRETURN;
       RETURN;
END INCURR;
%EJECT;
/* UNPACK KEY FROM 4-BIT TO ASCII
*/
UNPACKEY: PROC (V,S);
DCL 1 V ALIGNED,                       /* PACKED KEY */
      2 D(0:8) UBIN(4) UNAL;
DCL S(0:8) CHAR(1);                    /* ASCII KEY */
/**/
DCL I SBIN;
DCL TABLE CHAR(12) CONSTANT INIT(' .0123456789');
/**/
       DO I=0 TO 8;
           S(I)=SUBSTR(TABLE,V.D(I),1);
       END;
       RETURN;
END UNPACKEY;
END BMAP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* BREAK ROUTINE
/*
/* Called when a Break occurs
/* Prints the current pass and key through M$ME
*/
BREAK: PROC ASYNC;
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE BMAP_C;
%BMAP_COMMON;
DCL BREAKMSG CHAR(0) STATIC INIT(' PASS N, LINE XXXXXXXXXX');
%FPT_WRITE(DCB=M$ME,BUF=BREAKMSG);
DCL M$ME DCB;
/**/
       IF PASS2<=0 THEN CALL INSERT(BREAKMSG,6,1,'1');
         ELSE CALL INSERT(BREAKMSG,6,1,'2');
       CALL INSERT(BREAKMSG,14,10,KEY);
       CALL M$WRITE(FPT_WRITE);
       RETURN;
END BREAK;
%EOD;
/*M* CONVERT - Converts numeric character string to binary */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*
/* Convert input character stream (base BASE) to binary in VALUE
/* Return type in TYPE
*/
CONVERT: PROC (BASE,VALUE,TYPE);
DCL BASE SBIN;                         /* Base */
DCL 1 VALUE DALIGNED,                  /* (Output) binary value */
      2 I SBIN,                        /* Integer value */
      2 * SBIN;
DCL TYPE SBIN;                         /* Value type: 0=fixed, 1=SPFP, 2=DPFP */
/**/
%INCLUDE BMAP_C;
/**/
DCL CONVERTSTEP ENTRY (2);
DCL FIX ENTRY (2);
DCL SCALE ENTRY (2);
DCL ERROR ENTRY (1);
/**/
%BMAP_COMMON;
DCL DIGITPEDB(0:511) UBIN(9) UNAL CONSTANT INIT(0*32,
0*14,1,0,10,11,12,13,14,15,16,17,18,19,0*6, /* . digits */
       0,0,4,0,3,2,0*26,               /* B D E */
       0,0,4,0,3,2,0*26,               /* b d e */
       0*384);
DCL DP SBIN;                           /* Decimal scale factor */
DCL I SBIN;
DCL J SBIN;
DCL SF SBIN;                           /* Scale factor */
DCL SH SBIN;                           /* Binary scale factor */
/**/
       VALUE='0'B;
       TYPE=0;
       IF BASE~=10 THEN
           DO WHILE (%T);
               J=DIGITPEDB(ASCBIN(XCARD(CURRCH)));
               IF J<10 THEN GOTO ENDCONVERT;
               VALUE.I=VALUE.I*BASE+J-10;
               CURRCH=CURRCH+1;
           END;
         ELSE DO;
               DO WHILE (%T);
                   J=DIGITPEDB(ASCBIN(XCARD(CURRCH)));
                   DO CASE (J);
                    CASE(10,11,12,13,14,15,16,17,18,19);
                       CALL CONVERTSTEP(VALUE,J-10);
                       DP=DP-1;
                    CASE(1);           /* . */
                       IF TYPE>0 THEN CALL ERROR(9);
                         ELSE DO;
                               DP=0;
                               TYPE=1;
                           END;
                    CASE(2,3);         /* E, D */
                       CALL GETSF;
                       IF TYPE=2 OR TYPE=3 THEN CALL ERROR(9);
                         ELSE DO;
                               IF TYPE=0 THEN DP=0;
                               TYPE=J;
                               DP=DP+SF;
                           END;
                    CASE(4);           /* B */
                       CALL GETSF;
                       IF TYPE>=4 THEN CALL ERROR(9);
                         ELSE DO;
                               TYPE=TYPE+4;
                               SH=SF;
                           END;
                    CASE(ELSE);
                       GOTO ENDNUM;
                   END/* CASE J */;
                   CURRCH=CURRCH+1;
               END/* WHILE %T */;
ENDNUM:
               DO CASE(TYPE);
                CASE(0);               /* INTEGER */
                   CALL FIX(VALUE,35);
                CASE(1,2);             /* SINGLE-PRECISION FLOATING POINT */
                   CALL SCALE(VALUE,DP);
                   TYPE=1;
                CASE(3);               /* DOUBLE-PRECISION FLOATING POINT */
                   CALL SCALE(VALUE,DP);
                   TYPE=2;
                CASE(4);               /* FIXED POINT */
FIXV:
                   CALL FIX(VALUE,SH);
                   TYPE=0;
                CASE(5,6,7);
                   CALL SCALE(VALUE,DP);
                   GOTO FIXV;
               END/* CASE TYPE */;
           END/* IF BASE ELSE */;
ENDCONVERT:
       RETURN;
%EJECT;
/* GET SCALE FACTOR
*/
GETSF: PROC;
DCL SIGN SBIN;
       SIGN=1;
       CURRCH=CURRCH+1;
       IF XCARD(CURRCH)='+' THEN CURRCH=CURRCH+1;
         ELSE IF XCARD(CURRCH)='-' THEN DO;
                   SIGN=-1;
                   CURRCH=CURRCH+1;
               END;
       CALL SEARCH(I,SF,NONDGT,XCARDS,CURRCH);
       IF I>CURRCH THEN CALL CHARBIN(SF,SUBSTR(XCARDS,CURRCH,I-CURRCH));
         ELSE SF=0;
       CURRCH=I-1;
       SF=SF*SIGN;
       RETURN;
END GETSF;
END CONVERT;
%EOD;
/*M* NAME:         CTLCRD */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*   PURPOSE:      CONTROL CARD PROCESSING
/*   METHOD:       USES X$PARSE
/*                 GETS MORE INPUT (AS REQUIRED) FROM 'ME' DEVICE
/*   CALL:         CALL CTLCRD;
/*   DESCRIPTION:  CTLCRD IS DESIGNED TO BE A SELF-SUFFICIENT PROGRAM
/*                    WHICH SETS A SET OF OPTIONS FIELDS
*/
/*I* NAME:         CTLCRD
/*   PURPOSE:      CONTROL CARD PROCESSING FROM:
/*                    1) JIT.CCBUF AND
/*                    2) 'ME' DEVICE IF A TRAILING SEMICOLON IS FOUND
/*                 SETTING OPTIONS FIELDS
/*                 FLAGGING OPTIONS ERRORS
/*   CALL:         CALL CTLCRD;
/*   DATA:         OPTION BOOLEANS, ETC.
/*                 INTERNAL DATA
/*   DESCRIPTION:  SINCE X$PARSE CAN FIND ONLY ONE MEANINGFUL ERROR,
/*                    SCANNING IS ABORTED AT THE FIRST FAILURE.
/*                 READ_MORE_OPTIONS SOLICITS MORE INPUT ON 'ME'.
/*                 PARSE TREE IS BUILT BY PARSENODER AND RESIDES IN
/*                    IN AN OBJECT UNIT NAMED OPT_NODES WITH THE
/*                    SYMDEFED ROOT NAMED BMAP_SYNTAX.
/*                 WORKING SPACE AND DCB'S ARE PROCURED DYNAMICALLY.
/*                    SINCE GETTING ADDITIONAL OPTIONS SHOULD BE AN
/*                    EXCEPTION CONDITION, THE DCB WILL BE ALLOCATED
/*                    AND DEALLOCATED ON EACH INPUT.
/*                 1024 WORDS OF WORKING SPACE SHOULD BE MORE THAN
/*                    ENOUGH FOR ANY SELF-RESPECTING OPTIONS LIST.
*/
CTLCRD: PROC;
/**/
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE CP_6_SUBS;
%INCLUDE BMAP_C;
%BMAP_COMMON;
                                  /* Data structure for options booleans, etc */
%INCLUDE B$JIT_C;
%B$JIT0;
%U$JIT1;
%A$JIT6X;
DCL B$JIT$ PTR ALIGNED SYMREF;
%INCLUDE XU_MACRO_C;
/**/
DCL GETOPTIONS ENTRY(1);
DCL X$PARSE ENTRY(1) ALTRET;
/**/
DCL BMAP_SYNTAX BIT(36) ALIGNED SYMREF;
DCL ME_OPEN BIT(1) ALIGNED STATIC SYMDEF INIT(%F);
DCL HELP_OPEN BIT(1) ALIGNED STATIC SYMDEF INIT(%F);
/**/
DCL M$ME DCB;
DCL M$BMAP_HELP DCB;
/**/
                                       /* Input options parse tree */
%FPT_GDS(FPTN=OPTIONS_GDS_FPT,
            RESULTS=PARSE_WORK_,
            SEGSIZE=1000,
            STCLASS=STATIC);
DCL 1 PARSE_WORK_ DALIGNED STATIC,     /* Options work area */
      2 BOUND UBIN(20) UNAL INIT(0),   /* Delimiting */
      2 * BIT(12) INIT('7772'O),       /* Vector */
      2 PTR$ PTR ALIGNED INIT(ADDR(NIL));
%P_PCB(NAME=OPTION_PCB,
          T=PARSE_BUFR,
          R=BMAP_SYNTAX,
          U$=GETOPTIONS,
          WSZ=1000,
          STCLASS=STATIC SYMDEF);
/**/
DCL PARSE_BUFR             CHAR(500) SYMREF;
/**/
%FPT_CLOSE(FPTN=CLOSE_FILE_FPT,
              DISP=SAVE,
              STCLASS=STATIC);
/**/
                                        /*
                                        Turn off all options
                                        */
       OPTIONS=%F;
       OPTIONS.P2=%T;
                                        /*
                                        Get options from the jit first
                                        */
       IF B$JIT.PRFLAGS.UI THEN
           OPTIONS.UI=%T;
       IF B$JIT.PRFLAGS.OU THEN
           OPTIONS.OU=%T;
       IF B$JIT.PRFLAGS.LS THEN
           OPTIONS.LS=%T;
       OPTION_PCB.NCHARS = B$JIT.CCARS;
       IF OPTION_PCB.NCHARS-B$JIT.CCDISP=0
         OR SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP,B$JIT.CCARS-B$JIT.CCDISP)=' ' THEN
           DO /* Default options */;
DEFAULT:
               OPTIONS.LS=%T;
               OPTIONS.OU=%T;
           END /* Default options */;
         ELSE
           DO /* Parse options and set in parse exception handler */;
               PARSE_BUFR=' ';
               CALL INSERT(PARSE_BUFR,B$JIT.CCDISP,,SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP,B$JIT.CCARS-B$JIT.CCDISP));
               CALL M$GDS(OPTIONS_GDS_FPT);
               OPTION_PCB.WORK$ = PARSE_WORK_.PTR$;
               CALL X$PARSE(OPTION_PCB) ALTRET (OPTION_FATAL_ERROR);
               CALL M$FDS(OPTIONS_GDS_FPT);
               IF ME_OPEN THEN
                   DO;
                       CLOSE_FILE_FPT.V.DCB# = DCBNUM(M$ME);
                       CALL M$CLOSE(CLOSE_FILE_FPT);
                   END;
               IF HELP_OPEN THEN
                   DO;
                       CLOSE_FILE_FPT.V.DCB# = DCBNUM(M$BMAP_HELP);
                       CALL M$CLOSE(CLOSE_FILE_FPT);
                   END;
           END /* Parse options and set in parse exception handler */;
                                        /*
                                   Initialize all dcbs to null value regardless
                                   to how the user set them
                                   */
       RETURN;
OPTION_FATAL_ERROR:
       CALL M$FDS(OPTIONS_GDS_FPT);
                                       /* PRINT ERROR MESSAGE */
       GOTO DEFAULT;
END CTLCRD;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SCAN FOR DELIMITER
/*
/* Scans input line starting at CURRCH
/* Returns NEXTCH = index in XCARDS to the next delimiter
*/
DELSCAN: PROC;
/**/
%INCLUDE BMAP_C;
/**/
%BMAP_COMMON;
DCL DELTBL(0:511) UBIN(9) UNAL CONSTANT INIT(%BLANK*32,
%BLANK,0*7,%LPAR,%RPAR,%TIMES,%PLUS,%COMMA,%MINUS,0,%DIV,0*16, /* BLANK ( ) * + , - / */
      0*27,%LB,0,%RB,0*2,              /* [ ] */
      0*32,
      %BLANK*384);
/**/
       NEXTCH=CURRCH;
       IF XCARD(NEXTCH)='*' THEN NEXTCH=NEXTCH+1;
       IF NEXTCH<=SIZEC(XCARDS) THEN
           CALL SEARCH(NEXTCH,DEL,DELTBL,XCARDS,NEXTCH) ALTRET(EOL);
         ELSE DO;
EOL:
               DEL=%BLANK;
           END;
       RETURN;
END DELSCAN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SAVE ERROR
/*
/* Saves error number in ERRNUM and increments ERRCT and TERRCT
/* Error messages are printed by PRINT when the line is printed.
*/
ERROR: PROC (ERRCODE);
DCL ERRCODE SBIN;
%INCLUDE BMAP_C;
/**/
DCL PRINT ENTRY;
/**/
%BMAP_COMMON;
DCL I SBIN;
/**/
       IF PASS2~=0 OR ERRCODE<0 THEN DO;
               TERRCT=TERRCT+1;
               IF ERRSEV<4 THEN ERRSEV=4;
           END;
       IF ERRCT=0 AND MLVL>1 AND NOT PMC AND NOT CARDPR(0) THEN DO;
               I=MLVL;
               MLVL=1;
               CALL PRINT;
               MLVL=I;
           END;
       IF ERRCT=5 THEN RETURN;
       DO I=0 TO ERRCT-1;
           IF ERRNUM(I)=ERRCODE THEN RETURN;
       END;
       ERRNUM(ERRCT)=ERRCODE;
       ERRCT=ERRCT+1;
       RETURN;
END ERROR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* OUTPUT BINARY AND SET UP OCTAL LINE
*/
GEN:   PROC (NF,NB,VAL,REL);
DCL NF SBIN;                           /* # fields */
DCL NB(0:0) SBIN;                      /* Size(bits) of each field */
DCL VAL(0:0) SBIN;                     /* Value of each field */
%INCLUDE BMAP_C;
%REL(NAME="REL(0:0)");                 /* Relocation words for each field */
/**/
%INCLUDE B$OBJECT_C;
%BMAP_COMMON;
%B$RELOCSUBS;
DCL BITINSERT ENTRY (6) ALTRET;
DCL GENLOC ENTRY (2);
DCL GETSYM ENTRY (1) ALTRET;
DCL ERROR ENTRY (1);
DCL OCTAL ENTRY (3);
%INCLUDE XUO$ENTRIES;
DCL FB SBIN;                           /* First bit of next field */
DCL FRF BIT(1);                        /* Forward reference flag */
DCL I SBIN;
DCL I$ PTR;
DCL J$ PTR;
DCL K SBIN;
%LIT;
DCL NRELS UBIN;                        /* # relocated fields */
DCL R$ PTR;
%SYM;                                  /* Symbol table packet */
DCL TVAL SBIN;                         /* Accumulated value of word */
/**/
       IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
       FB=0;
       TVAL=0;
       FRF=%F;
       NRELS=0;
       DO I=0 TO NF-1;
           IF REL(I) THEN DO;
                   IF REL.OPNDTYP(I)=%OPERUNDEF OR REL.EVALOP(I)=0 AND REL.S.OPNDTYP(I)=%OPERUNDEF THEN FRF=%T;
                   NRELS=NRELS+1;
               END;
           FB=FB+NB(I);
           IF NB(I)=36 THEN TVAL=VAL(I);
             ELSE DO;
                   CALL BITINSERT(TVAL,0,36,TVAL,NB(I),36);
                   CALL BITINSERT(TVAL,36-NB(I),NB(I),VAL(I),36-NB(I),36);
               END;
       END/* DO I */;
       IF LIT$~=ADDR(NIL) THEN DO;
               IF LIT.RX<LIT.LEN THEN
                   IF LIT.LEN>62 THEN CALL ERROR(8);
                     ELSE DO;
                           I=LIT.LEN-1;
                           DO WHILE (I>=LIT.RX);
                               LIT.V(I+1)=LIT.V(I);
                               I=I-1;
                           END;
                       END/* IF LIT.LEN ELSE */;
               LIT.V(LIT.RX)=TVAL;
               LIT.RX=LIT.RX+1;
               LIT.LEN=LIT.LEN+1;
           END/* IF LIT$ */;
         ELSE IF FRF THEN DO;
                   CALL GETSYM(SIZEW(FR)+SIZEW(FR.R)*(NRELS-1)) ALTRET(NOFR);
                   FR$=ADDR(SPOOL(SYMX));
                   FR.LINK=0;
                   FR.LEN=NRELS;
                   FR.PC=PC;
                   FR.PCREL=PCREL.OPERAND;
                   FR.V=TVAL;
                   DO WHILE (%F);
NOFR:
                       FRF=%F;
                   END;
               END/* IF FRF */;
             ELSE CALL XUO$PRGM(BINBIT(PCREL.OPERAND,36),PC,TVAL);
       FB=0;
       NRELS=0;
       DO I=0 TO NF-1;
           IF REL(I) THEN
               IF LIT$~=ADDR(NIL) THEN
                   IF LIT.LEN>60 THEN CALL ERROR(8);
                     ELSE DO;
                           R$=PINCRW(LIT$,LIT.RX);
                           R$->LIT.R(0)=REL(I);
                           R$->LIT.R.DISP(0)=LIT.RX-1;
                           R$->LIT.R.STBIT(0)=FB;
                           R$->LIT.R.ENDBIT(0)=FB+NB(I)-1;
                           R$->LIT.R.VALUE(0)=REL.VALUE(I);
                           LIT.LEN=LIT.LEN+SIZEW(LIT.R(0));
                       END/* IF LIT.LEN */;
                 ELSE IF FRF THEN DO;
                           FR.R(NRELS)=REL(I);
                           FR.R.STBIT(NRELS)=FB;
                           FR.R.ENDBIT(NRELS)=FB+NB(I)-1;
                           FR.R.VALUE(NRELS)=REL.VALUE(I);
                           NRELS=NRELS+1;
                           IF FR.LINK=0 THEN
                               IF REL.OPNDTYP(I)=%OPERUNDEF THEN DO;
                                       I$=ADDR(SPOOL(REL.OPERAND(I)));
LINKFR:
                                       IF I$->SYM.FRROOT=0 THEN
                                           FR.LINK=SYMX;
                                         ELSE DO;
                                               J$=ADDR(SPOOL(I$->SYM.FRROOT));
                                               FR.LINK=J$->FR.LINK;
                                               J$->FR.LINK=SYMX;
                                           END;
                                       I$->SYM.FRROOT=SYMX;
                                   END/* IF REL.OPNDTYP(I) */;
                                 ELSE IF REL.EVALOP(I)=0 AND REL.S.OPNDTYP(I)=%OPERUNDEF THEN DO;
                                           I$=ADDR(SPOOL(REL.S.OPERAND(I)));
                                           GOTO LINKFR;
                                       END;
                       END/* IF FRF */;
                     ELSE IF REL.EVALOP(I)=0 THEN
                           CALL XUO$RELOC(BINBIT(PCREL.OPERAND,36),PC,
                             BINBIT(REL.OPNDTYP(I),36),BINBIT(REL.OPERAND(I),36),
                             BINBIT(REL.RELOCOP(I),36),FB,FB+NB(I)-1);
                         ELSE CALL XUO$RELOC(BINBIT(PCREL.OPERAND,36),PC,
                             BINBIT(REL.OPNDTYP(I),36),BINBIT(REL.OPERAND(I),36),
                             BINBIT(REL.RELOCOP(I),36),FB,FB+NB(I)-1,
                             BINBIT(REL.EVALOP(I),36),REL.VALUE(I));
           FB=FB+NB(I);
       END/* DO I */;
       IF LIT$=ADDR(NIL) THEN DO;
               CALL GENLOC;
               PC=PC+1;
               GOTO S100;
           END;
       RETURN;
/*
/* ENTER HERE TO ONLY SET UP OCTAL LINE
*/
GENVAL: ENTRY (NF,NB,VAL,REL);
       IF PASS2=0 THEN RETURN;
S100:
       LINECT=10;
       DO I=0 TO NF-1;
           K=(NB(I)+2)/3;
           DO CASE (REL.OPNDTYP(I));
            CASE(0);
               LINECT=LINECT+3*BITBIN(LINECT=10);
            CASE(%OPERSECT);
               CALL INSERT(LINES,LINECT,3,'(',BINASC(ASCBIN('0')+MOD(REL.OPERAND(I),10)),')');
               LINECT=LINECT+3;
            CASE(%OPERUNDEF);
               LINECT=LINECT+BITBIN(LINECT=10);
               CALL INSERT(LINES,LINECT,1,'F');
               LINECT=LINECT+2;
            CASE(ELSE);
               LINECT=LINECT+BITBIN(LINECT=10);
               CALL INSERT(LINES,LINECT,1,'X');
               LINECT=LINECT+2;
           END;
           CALL OCTAL(VAL(I),SUBSTR(LINES,LINECT),K);
           LINECT=LINECT+K+1;
       END/* DO I */;
       LINEF.CODE=%T;
       RETURN;
END GEN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SET UP LOCATION FIELD AND SET PC
*/
GENLOC: PROC (VAL,SECT);
DCL VAL SBIN;                          /* Program counter value */
DCL SECT SBIN;                         /* Program counter section number */
%INCLUDE BMAP_C;
/**/
%BMAP_COMMON;
DCL OCTAL ENTRY (3);
/**/
       IF ADDR(VAL)~=ADDR(NIL) THEN DO;
               PC=VAL;
               IF ADDR(SECT)~=ADDR(NIL) THEN PCREL.OPERAND=SECT;
           END;
       IF PASS2=0 THEN RETURN;
       IF PCREL~=OLDREL THEN CALL INSERT(LINES,1,1,BINASC(ASCBIN('0')+MOD(PCREL.OPERAND,10)));
       CALL OCTAL(PC,SUBSTR(LINES,3),6);
       LINECT=10;
       LINEF.LOC=%T;
       RETURN;
END GENLOC;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*I* NAME:         GETOPTIONS
/*   PURPOSE:      DOES MOST OF THE WORK OF CONTROL CARD PROCESSION
/*                    NOT HANDLED BY X$PARSE.
/*                 ALL CRITICAL PHASES OF PARSE ARE HOOKED INTO THIS
/*                    PROCESSOR VIA THE OPTIONS TREE INPUT TO X$PARSE.
/*   METHOD:       X$PARSE CALLS THIS PROCEDURE WHEN IT ENCOUNTERS:
/*                    (S) -- FLAGGED NODES SUCCESSFULLY PARSED
/*                            HELP
/*                            COMPLETE OPTIONS LINE
/*                    (F) -- SYNTAX ERROR
/*                    (I) -- ENDING SEMICOLON SIGNALING MORE INPUT
/*                 WHEN THE PROCEDURE HAS SUCCESSFULLY HANDLED THE
/*                    (INTERRUPT), IT RETURNS TO X$PARSE.
*/
GETOPTIONS: PROC (XU$PARAM);
/**/
%INCLUDE XU_MACRO_C;
%INCLUDE XU_SUBS_C;
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE CP_6_SUBS;
/**/
%INCLUDE BMAP_C;
%BMAP_COMMON;
%M$DCB(DCBN=M$ME,
          ASN=DEVICE,
       FUN=UPDATE,
          RES='ME');
%M$DCB(DCBN=M$BMAP_HELP,
          ASN=FILE,
          FUN=IN,
          NAME='BMAP_HELP',ACCT='X');
%F$DCB;
/**/
%PARSE$PARAM(NAME=XU$PARAM);
/**/
%P$PCB(NAME=OPTION_PCB,
          STCLASS=SYMREF);
%PARSE$OUT(NAME=OUT$BLK,
              STCLASS="BASED(OUT$BLK_PTR$)");
DCL OUT$BLK_PTR$           PTR ALIGNED STATIC;
%PARSE$SYM(NAME=OUT$SYM,
              STCLASS=BASED);
%PARSE$OUT(NAME=HDR$BLK,
              STCLASS="BASED(XU$PARAM.OUT$)");
                                  /* Codes for parse nodes in options X$PARSE */
%EQU HEADER_CODE=1;
%EQU HELP_CODE=2;
%EQU LS_CODE=3;
%EQU NLS_CODE=4;
%EQU OU_CODE=5;
%EQU NOU_CODE=6;
%EQU P2_CODE=7;
%EQU SC_CODE=8;
%EQU NSC_CODE=9;
%EQU SO_CODE=10;
%EQU AC_NAME_CODE=11;
%EQU UI_CODE=12;
%EQU NUI_CODE=13;
%EQU XR_CODE=14;
%EQU LU_CODE=15;
%EQU P1_CODE=16;
                                       /* Codes for option errors */
%EQU OPT_SYNTAX_ERROR=1;
%EQU OPT_KEYWORD_MISSING=2;
%EQU OPT_ACCOUNTS_OVERFLOW=3;
%EQU OPT_DUP_BC   =4;
%EQU OPT_BC_OVERFLOW=5;
%EQU OPT_BUFFER_OVERFLOW=6;
%EQU INVALID_FID_OPTION=7;
/**/
DCL ME_OPEN                BIT(1) ALIGNED SYMREF;
DCL HELP_OPEN              BIT(1) ALIGNED SYMREF;
/**/
%FPT_WRITE(FPTN=WRITE_ME_FPT,
              DCB=M$ME,
              BUF=IO_BUFR,
              STCLASS=STATIC);
%FPT_READ(FPTN=READ_FPT,
             BUF=PARSE_BUFR,
             STCLASS=STATIC);
%FPT_FID (FPTN=FID_FPT,STCLASS=CONSTANT,TEXTFID=FID_BUFFER,NAME=FID_TEMP.NAME_,
       ACCT=FID_TEMP.ACCT_,PASS=FID_TEMP.PASS_,SN=FID_TEMP.SN_,
       WSN=FID_TEMP.WSN_,ASN=FID_TEMP.ASN#,RES=FID_TEMP.RES#,
       RESULTS=FID_TEMP.F);
/**/
DCL 1 FID_TEMP STATIC,
      2 NAME_ CHAR(32),
      2 ACCT_ CHAR(8),
      2 PASS_ CHAR(8),
      2 SN_ CHAR(10) ALIGNED,
      2 WSN_ CHAR(8),
      2 ASN# UBIN(9),
      2 RES# CHAR(4),
      2 F DALIGNED,                    /* Flags */
        3 NAME BIT(1),
        3 ACCT BIT(1),
        3 PASS BIT(1),
        3 SN BIT(1),
        3 WSN BIT(1),
        3 ASN BIT(1),
        3 RES BIT(1);
/**/
DCL PARSE_BUFR             CHAR(500) STATIC SYMDEF;
DCL IO_BUFR                CHAR(120) STATIC;
DCL FID_BUFFER CHAR(140) STATIC;
/**/
DCL INDENT                 UBIN ALIGNED AUTO;
DCL KEYWORD_SEARCH         BIT(1) ALIGNED AUTO;
DCL KEYWORD                CHAR(10) AUTO;
DCL ACMAX_MAX_CHARS        CHAR(2) AUTO;
DCL SEL_MAX_CHARS          CHAR(2) AUTO;
DCL NODE_INDEX             UBIN ALIGNED AUTO;
DCL SUBBLKS                UBIN ALIGNED AUTO;
DCL BC_SUBBLKS             UBIN ALIGNED AUTO;
DCL ACSUBBLKS UBIN ALIGNED AUTO;
/**/
       XU$PARAM.ACCEPT = %F;
       XU$PARAM.REJECT = %F;
       XU$PARAM.RETRY  = %F;
/**/
       DO CASE(XU$PARAM.TYPE);
        CASE(%SUCC#);
           IF XU$PARAM.CODE = %HELP_CODE THEN
               DO;
                   CALL HELP_OPTION_PROCESSOR;
                   XU$PARAM.REJECT = %T;
               END;
                             /* Enter any other success node processing here */
             ELSE
               DO;
                   XU$PARAM.ACCEPT = %T;
                   IF XU$PARAM.CODE = %HEADER_CODE THEN
                       CALL PROCESS_OPTIONS_TREE;
               END;
        CASE(%FAIL#);
           CALL OPTION_ERROR(%OPT_SYNTAX_ERROR);
/*E* ERROR:        OPT_SYNTAX_ERROR
/*   MESSAGE:      OPTION SYNTAX ERROR
/*   DESCRIPTION:  PREVIOUS LINE POINTS TO IT.  CAN'T BE SPECIFIC.
*/
           XU$PARAM.REJECT = %T;
        CASE(%INPUT#);
           CALL READ_MORE_OPTIONS;
       END;
       RETURN;
                                        /*
                                   /*+++++++++++++++++++++++++++++++++++++++++++
                                   /* End of OPTIONS main code
                                   /*+++++++++++++++++++++++++++++++++++++++++++
                                   */
/*I* NAME:         READ_MORE_OPTIONS
/*   PURPOSE:      GET ADDITIONAL OPTIONS FROM DEVICE 'ME'.
/*   METHOD:       APPENDS TO END OF PREVIOUS INPUT.
*/
READ_MORE_OPTIONS: PROC;
/**/
       IF XU$PARAM.CHARPOS >= 380 THEN /* (500-120 = 380) */
           DO;
               CALL OPTION_ERROR(%OPT_BUFFER_OVERFLOW);
/*E* ERROR:        OPT_BUFFER_OVERFLOW
/*   MESSAGE:      OPTIONS LIST TOO LONG
/*   DESCRIPTION:  THE USER WAS LOOKING FOR TROUBLE--GIVE HIM THE
/*                    OPTIONS HE'S ALREADY INPUT
*/
               RETURN;
           END;
       READ_FPT.V.DCB# = DCBNUM(M$ME);
       READ_FPT.BUF_ = VECTOR(SUBSTR(PARSE_BUFR, XU$PARAM.CHARPOS, 120));
       CALL M$READ(READ_FPT);
       ME_OPEN = %T;
       OPTION_PCB.NCHARS = XU$PARAM.CHARPOS + DCBADDR(DCBNUM(M$ME))->F$DCB.ARS#;
       RETURN;
END READ_MORE_OPTIONS;
                                        /*
                                        /*++++++++++++++++
                                        */
/*I* NAME:         HELP_OPTION_PROCESSOR
/*   PURPOSE:      PROCESS THE 'HELP' OPTION
/*   METHOD:       THREE VERSIONS OF HELP ARE AVAILABLE:
/*                 1) HELP  -- PRINTS EVERYTHING IN THE HELPFILE.
/*                 2) HELP <KEYWORD>  -- PRINTS SELECTED PORTIONS OF
/*                            HELPFILE ON DEVICE 'ME'.
/*                 3) HELP KEYWORDS  -- LISTS ALL KEYWORDS IN HELPFILE.
/*                    HELPFILE KEYWORDS ARE FLAGGED BY PRECEEDING
/*                            ASTERISKS AT THE START OF A RECORD.
/*                            NO PRECEEDING BLANKS ARE ALLOWED.
/*                            TRAILING BLANKS ARE REQUIRED TO FILL THE
/*                            KEYWORD TO 10 CHARACTERS.
/*   CALL:         CALL HELP_OPTIONS_PROCESSOR;
/*   CALLS:        OPEN_ME
/*                 M$READ
/*                 M$WRITE
/*                 OPTION_ERROR
*/
HELP_OPTION_PROCESSOR: PROC;
/**/
%M$DCB(DCBN=M$BMAP_HELP,
          ASN=FILE,
          FUN=IN,
          NAME='HELPFILE');
%FPT_PFIL(FPTN=HELP_BOF_FPT,
             DCB=M$BMAP_HELP,
             BOF=YES,
             STCLASS=STATIC);
%FPT_OPEN(FPTN=OPEN_HELP_FPT,
             DCB=M$BMAP_HELP,
             ACS=SEQUEN,
             STCLASS=STATIC);
/**/
       IF HELP_OPEN THEN
           CALL M$PFIL(HELP_BOF_FPT);
         ELSE
           DO;
               CALL M$OPEN(OPEN_HELP_FPT);
               HELP_OPEN = %T;
           END;
       READ_FPT.V.DCB# = DCBNUM(M$BMAP_HELP);
       READ_FPT.BUF_ = VECTOR(IO_BUFR);
       WRITE_ME_FPT.BUF_.BUF$ = ADDR(IO_BUFR);
       KEYWORD_SEARCH = XU$PARAM.OUT$->OUT$BLK.NSUBLKS  > 0;
       IF KEYWORD_SEARCH THEN
           DO /* Find keyword text or keywords */;
               KEYWORD = XU$PARAM.OUT$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
               DO WHILE (KEYWORD_SEARCH);
                   IO_BUFR = ' ';
                   DO WHILE(SUBSTR(IO_BUFR,0,1) ~= '*');
                       IO_BUFR = ' ';
                       CALL M$READ(READ_FPT)  ALTRET (KEYWORD_MISSING);
                   END;
                   INDENT = 1;
                   DO WHILE (SUBSTR(IO_BUFR,INDENT,1) = '*');
                       INDENT = INDENT + 1;
                   END;
                   IF SUBSTR(IO_BUFR,INDENT,10) = KEYWORD THEN
                       DO /* Print this section */;
                           CALL M$READ(READ_FPT) ALTRET (EOF_ON_HELPFILE);
                           DO WHILE (SUBSTR(IO_BUFR,0,1) ~= '*');
                               WRITE_ME_FPT.BUF_.BOUND =
                                 DCBADDR(READ_FPT.V.DCB#)->F$DCB.ARS# - 1;
                               CALL M$WRITE(WRITE_ME_FPT);
                               CALL M$READ(READ_FPT) ALTRET (EOF_ON_HELPFILE);
                           END;
                           KEYWORD_SEARCH = %F;
                       END /* Print this section */;
                     ELSE
                       IF KEYWORD = 'KEYWORDS' THEN
                           DO /* Output keyword record */;
                               WRITE_ME_FPT.BUF_ =
                                 VECTOR(SUBSTR(IO_BUFR, INDENT, 10));
                               CALL M$WRITE(WRITE_ME_FPT);
                           END /* Output keyword record */;
               END;
           END /* Find keyword text or keywords */;
         ELSE
           DO WHILE (%T);
               CALL M$READ (READ_FPT) ALTRET (EOF_ON_HELPFILE);
               WRITE_ME_FPT.BUF_.BOUND =
                 DCBADDR(READ_FPT.V.DCB#)->F$DCB.ARS#  - 1;
               CALL M$WRITE(WRITE_ME_FPT);
           END;
EOF_ON_HELPFILE:
       RETURN;
KEYWORD_MISSING:
       IF KEYWORD = 'KEYWORD' THEN RETURN;
       CALL OPTION_ERROR(%OPT_KEYWORD_MISSING);
/*E* ERROR:        OPT_KEYWORD_MISSING
/*   MESSAGE:      HELP NOT FOUND FOR %U1
/*   DESCRIPTION:  WASN'T IN HELPFILE
/*                 %U1 = KEYWORD
*/
       RETURN;
END HELP_OPTION_PROCESSOR;
                                        /*
                                        /*++++++++++++++++++++++++
                                        */
/*I* NAME:         PROCESS_OPTIONS_TREE
/*   PURPOSE:      SET OPTIONS FIELDS ONCE PARSE IS SUCCESSFULLY
/*                    COMPLETED.
/*   METHOD:       A SUCCESS FLAG ON THE PRINCIPLE NODE ENSURES
/*                    THAT THE EXCEPTION HANDLER WILL BE CALLED.
/*                 THE TREE (A RATHER FLAT ONE) IS TRAVERSED,
/*                    SETTING THE BOOLEANS AND OTHER FIELDS.
*/
PROCESS_OPTIONS_TREE: PROC;
/**/
       NODE_INDEX = 0;
       SUBBLKS = HDR$BLK.NSUBLKS;
       IF SUBBLKS = 0 THEN
           DO /* Default options */;
               OPTIONS.LS=%T;
               OPTIONS.OU=%T;
           END /* Default options */;
       DO WHILE (NODE_INDEX < SUBBLKS);
           OUT$BLK_PTR$=HDR$BLK.SUBLK$(NODE_INDEX);
           DO CASE (OUT$BLK.CODE);
            CASE(%LS_CODE);
               OPTIONS.LS=%T;
            CASE(%NLS_CODE);
               OPTIONS.LS=%F;
            CASE(%OU_CODE);
               OPTIONS.OU=%T;
            CASE(%NOU_CODE);
               OPTIONS.OU=%F;
            CASE(%P2_CODE);
               OPTIONS.P2=%T;
            CASE(%SC_CODE);
               OPTIONS.ND=%F;
            CASE(%NSC_CODE);
               OPTIONS.ND=%T;
            CASE(%SO_CODE);
               OPTIONS.SO=%T;
            CASE(%AC_NAME_CODE);
               ACSUBBLKS=0;
               DO WHILE(ACSUBBLKS<OUT$BLK.NSUBLKS);
                   IF OPTIONS.NACS < %MAXACS THEN
                       DO;
                           FID_BUFFER=OUT$BLK.SUBLK$(ACSUBBLKS)->OUT$SYM.TEXT;
                           CALL M$FID(FID_FPT) ALTRET(INVALID_FID);
                                        /*
                                        For a valid fid specification
                                        the asn must be file or labeled
                                        tape.
                                        */
                           IF FID_TEMP.F.ACCT AND FID_TEMP.ASN#=%FILE# OR FID_TEMP.ASN#=%TAPE# THEN
                               DO;
                                   FID_SAVE(OPTIONS.NACS)=FID_TEMP;
                                   OPTIONS.NACS=OPTIONS.NACS+1;
                               END;
                             ELSE
                               DO;
INVALID_FID:                       ;
                                   CALL OPTION_ERROR(%INVALID_FID_OPTION);
/*E*     ERROR:    INVALID_FID_OPTION
         MESSAGE:  INVALID FID SPECIFIED ON  SRCH OPTION
         DESCRIPTION:  FID MUST BE ASSIGNED TO TAPE OR FILE AND
                        NOT HAVE FILE SPECIFIED
*/
                               END;
                       END;
                     ELSE
                       DO;
                           CALL BINCHAR(ACMAX_MAX_CHARS, %MAXACS);
                           CALL OPTION_ERROR(%OPT_ACCOUNTS_OVERFLOW);
/*E* ERROR:        OPT_ACCOUNTS_OVERFLOW
/*   MESSAGE:      TOO MANY OPTIONAL ACCOUNTS--MAX %U1
/*   DESCRIPTION:  GOTTA HAVE A LIMIT.
/*                 %UI = ACMAX_MAX_CHARS
*/
                           ACSUBBLKS=HDR$BLK.NSUBLKS;
                       END;
                   ACSUBBLKS=ACSUBBLKS+1;
               END;
            CASE(%UI_CODE);
               OPTIONS.UI=%T;
            CASE(%NUI_CODE);
               OPTIONS.UI=%F;
            CASE(%XR_CODE);
               OPTIONS.XR=%T;
            CASE(%LU_CODE);
               OPTIONS.LU=%T;
            CASE(%P1_CODE);
               OPTIONS.P2=%F;
           END;
           NODE_INDEX = NODE_INDEX + 1;
       END;
END PROCESS_OPTIONS_TREE;
                                        /*
                                        /*++++++++++++++++++++++++++++++
                                        */
/*I* NAME:         OPTION_ERROR
/*   PURPOSE:      INFORM USER (DEVICE 'ME') OF ERROR
/*   METHOD:       FOR NOW, JUST CASE ON ERROR_NUM
*/
OPTION_ERROR: PROC (ERROR_NUM);
/**/
DCL ERROR_NUM              UBIN ALIGNED;
/**/
       IO_BUFR = '**OPTIONS ERROR:';
       DO CASE(ERROR_NUM);
        CASE(%OPT_SYNTAX_ERROR);
           CALL INSERT(IO_BUFR, 18, 62, 'OPTION SYNTAX ERROR');
        CASE(%OPT_KEYWORD_MISSING);
           CALL INSERT(IO_BUFR, 18, 62, 'HELP NOT FOUND FOR ',
             KEYWORD);
        CASE(%OPT_ACCOUNTS_OVERFLOW);
           CALL INSERT(IO_BUFR, 18, 62,
             'MAXIMUM OPTIONAL ACCOUNTS EXCEEDED--MAX = ',
             ACMAX_MAX_CHARS);
        CASE(%OPT_DUP_BC);
           CALL INSERT(IO_BUFR, 18, 62, 'DUPLICATE ''BC'' OPTION');
        CASE(%OPT_BC_OVERFLOW);
           CALL INSERT(IO_BUFR, 18, 62,
             'MAXIMUM BATCH NUMBERS EXCEEDED--MAX = ',
             SEL_MAX_CHARS);
        CASE(%OPT_BUFFER_OVERFLOW);
           CALL INSERT(IO_BUFR,18, 62, 'OPTIONS LIST TOO LONG');
        CASE(%INVALID_FID_OPTION);
           CALL INSERT(IO_BUFR,18,62, 'INVALID FID SPECIFIED FOR SRCH');
       END;
       WRITE_ME_FPT.BUF_.BOUND = 79;
       CALL M$WRITE(WRITE_ME_FPT);
       ME_OPEN = %T;
       RETURN;
END OPTION_ERROR;
                                        /*
                                        /*++++++++++++++++++++++++++
                                        */
END GETOPTIONS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* GET SYMBOL TABLE SPACE
*/
GETSYM: PROC (NW) ALTRET;
DCL NW SBIN;
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE BMAP_C;
/**/
%BMAP_COMMON;
DCL ERROR ENTRY (1);
DCL I SBIN;
DCL REM SBIN;
/**/
DCL SYMFULL BIT(1) STATIC INIT(%F);
DCL MACFULL BIT(1) STATIC INIT(%F);
/**/
       REM=NW-SYMX+SPOOL(0);
       IF REM>0 THEN CALL GCP(REM) ALTRET(S10);
       IF SYMX=0 THEN DO; SYMTOP=SPOOL(0)+((NW+511)/512)*512; SYMX=SYMTOP; END;
       SYMX=SYMX-NW;
       RETURN;
/**/
S10:
       IF NOT SYMFULL THEN DO; CALL ERROR(-12); SYMFULL=%T; END;
       ALTRETURN;
/*
/* GET MACRO TABLE SPACE
*/
GETMAC: ENTRY (NW) ALTRET;
       REM=NW-MPOOL(0)+MCX;
       IF REM>0 THEN CALL GDP(REM) ALTRET(S20);
       IF MCX=0 THEN DO; MACBOT=MPOOL(0)-((NW+511)/512)*512; MCX=MACBOT; END;
       IF MMAX<MCX+NW THEN MMAX=MCX+NW;
       MCX=MCX+1;
       RETURN;
/**/
S20:
       IF NOT MACFULL THEN DO; CALL ERROR(-11); MACFULL=%T; END;
       ALTRETURN;
%EJECT;
/* GET PAGES FOR SYMBOL TABLE(SPOOL)
*/
GCP:   PROC(NW) ALTRET;
DCL NW SBIN;
/**/
DCL FIRST BIT(1) STATIC INIT (%T);
%FPT_GDDL (RESULTS=X);
%FPT_GDP(RESULTS=VLP_VECTOR);
%FPT_GVP;
DCL NUM_PAGES UBIN;
DCL PNO UBIN STATIC;
%VLP_VECTOR;
DCL 1 X STATIC ALIGNED,                /*Info from M$GDDL*/
      2 BOUND UBIN(18),
      2 PTR$ PTR,
      2 PTR_ REDEF PTR$,
        3 BASE UBIN(18),
      2 * UBIN;
/**/
       IF FIRST THEN DO;
               CALL M$GDDL(FPT_GDDL);
               PNO=(X.PTR_.BASE+X.BOUND+1)/1024;
               FIRST=%F;
           END;
       NUM_PAGES=(NW+1023)/1024;       /*Pages needed*/
       DO WHILE (NUM_PAGES>0);
           PNO=PNO-1;
           FPT_GVP.V.PNO#=PNO;
           CALL M$GVP(FPT_GVP) ALTRET (NO_ROOM);
           NUM_PAGES=NUM_PAGES-1;
       END;
       X.PTR$=ADDR(SPOOL);
       SPOOL(0)=PNO*1024-X.PTR_.BASE;
       RETURN;
NO_ROOM: ALTRETURN;                    /*Out of pages*/
/*
/* GET PAGES FOR MACRO INFO AND TEXT(MPOOL)
*/
GDP:   ENTRY (NW) ALTRET;
       NUM_PAGES=(NW+1023)/1024;
       FPT_GDP.V.PAGES#=NUM_PAGES;
       CALL M$GDP(FPT_GDP) ALTRET (NO_ROOM);
       MPOOL(0)=POFFW(VLP_VECTOR.PTR$,ADDR(MPOOL))+1024*(NUM_PAGES-1)+1023;
       RETURN;
END GCP;
END GETSYM;
%EOD;
/*M* INST - BMAP instruction processing routine */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*
/* Called by BMAP to process most statements
/* Called by LITERAL to process =M literals
*/
INST:  PROC ALTRET;               /* Alternate return: Line has been printed. */
/**/
%INCLUDE B$OBJECT_C;
%INCLUDE BMAP_C;
%INCLUDE CP_6_C;
%CP6$ENTS;
/**/
DCL BITINSERT ENTRY (6) ALTRET;
DCL NEG ENTRY (1);
DCL XLATEV ENTRY (7) ALTRET;
DCL GEN ENTRY (4);
DCL GENVAL ENTRY (4);
DCL CONVERT ENTRY (3);
DCL DELSCAN ENTRY;
DCL ERROR ENTRY (1);
DCL GETMAC ENTRY (1) ALTRET;
DCL GETSYM ENTRY (1) ALTRET;
DCL PACKEY ENTRY (1);
DCL NEXTFLD ENTRY ALTRET;
DCL PRINT ENTRY;
DCL READCARD ENTRY (1);
DCL SYMTAB ENTRY (5);
DCL TREESRCH ENTRY (6);
DCL VARSCAN ENTRY (3);
DCL VFD ENTRY (2) ALTRET;
/**/
%B$RELOCSUBS;
%BMAP_COMMON;
/**/
DCL ADSCF(0:10) UBIN CONSTANT INIT(3,15,3,2,1,12,18,3,2,1,12); /* Formats for ADSC */
DCL VDSCF(0:8) UBIN CONSTANT INIT(3,15,13,1,4,18,13,1,4); /* Formats for VDSC */
DCL BTTBSD BIT(36) BASED ALIGNED;
DCL ASFORM(0:3) UBIN CONSTANT INIT(16,11,1,8); /* Format for ASCNT */
DCL BASE SBIN;
DCL BDSCF(0:8) UBIN CONSTANT INIT(3,15,2,4,12,18,2,4,12); /* Formats for BDSC */
DCL BLKCMA(0:511) UBIN(9) UNAL CONSTANT INIT(1*33,0*11,1,0*82,1*385);
DCL BSIGN BIT(9);
DCL CC SBIN;
DCL CL2FORM(0:4) UBIN CONSTANT INIT(1,9,8,6,12); /* Format for word 2 of CLIMB */
DCL 1 COND ALIGNED,                    /* Condition field for RPTs */
      2 * BIT(29),
      2 BT(0:6) BIT(1);
DCL CONDSYM(0:6) CHAR(3) CONSTANT INIT('TOV','TNC','TRC','TMI','TPL','TZE','TNZ'); /* Mnemonics for RPT conditions */
DCL CT SBIN;
DCL DBUF CHAR(8) STATIC;               /* DATE RETURNED BY M$TIME */
DCL DECTBL(0:511) UBIN(9) UNAL CONSTANT INIT(1*33,0*3,3,0*7,1,0,2,0,2*10,0*6,
       3*27,0*4,3,0,3*26,0*4,1*385);
DCL DIGITPMPE(0:511) UBIN(9) UNAL CONSTANT INIT(0*43,2,0,3,4,0,1*10,0*11,5,0*31,5,0*410);
DCL DP SBIN;
DCL DSCF(0:22) UBIN CONSTANT INIT(18,2,9,3,4,20,9,3,4,0, /* Formats for NSA descriptors */
           18,2,3,9,4,20,3,9,4,0,
           36,34,2);
DCL EDSCF(0:9) UBIN CONSTANT INIT(18,1,10,3,4,10,26,10,24,2); /* Formats for NSA entry descriptor */
DCL EFORM(0:41) UBIN CONSTANT INIT(0,0,9,1,8,12,6, /* Formats for EIS instructions */
           0*3,9,9,12,6,
           1,4,4,1,8,12,6,
           0,0,1,8,9,12,6,
           1,8,1,1,7,12,6,
           0,2,7,2,7,12,6);
DCL FB SBIN;                           /* First bit */
DCL FC SBIN;                           /* First character */
DCL FP BIT(1);                         /* EDEC: Floating-point number */
%FPT_TIME(SOURCE=UTS,DEST=ANS,TSTAMP=XUO_OU_UTS,DATE=DBUF,STCLASS=CONSTANT);
DCL I SBIN;
DCL IDCWFORM(0:4) UBIN CONSTANT INIT(6,12,6,6,6); /* Format for IDCW */
DCL IFORM(0:6) UBIN CONSTANT INIT(3,15,12,6,18,12,6); /* Formats for non-EIS instructions */
DCL IMN SBIN;
DCL IMN$ PTR;                          /* OPD: -> Op-code entry */
DCL IOFORM(0:2) UBIN CONSTANT INIT(18,6,12); /* Format for DCWs */
DCL J SBIN;
DCL K UBIN;
DCL K2 SBIN;
DCL K3 SBIN;
DCL L SBIN;
DCL LEFT BIT(1);
DCL M SBIN;
%MAP(STCLASS="BASED(MAP$)");
DCL MAP$ PTR;
DCL MINUS BIT(1);
DCL MOP(0:16) CHAR(4) CONSTANT INIT(   /* EDIT MICRO-OPERATIONS */
           'INSM','ENF','SES','MVZB','MVZA','MFLS','MFLC','INSB',
           'INSA','INSN','INSP','IGN','MVC','MSES','MORS','LTE',
           'CHT');
DCL N SBIN;
DCL NB SBIN;                           /* Number of bits */
DCL NC SBIN;                           /* Number of characters */
DCL NDSCF(0:12) UBIN CONSTANT INIT(3,15,3,1,2,6,6,18,3,1,2,6,6); /* Formats for NDSC */
DCL NMAC$ PTR;                         /* Macro call: -> new MAC packet */
DCL NMLVL UBIN;              /* Macro call: index in MPOOL to new MAC packet */
DCL NW SBIN;                           /* Number of words */
DCL QFORM(0:3) UBIN CONSTANT INIT(9*4); /* Format for MICROP */
DCL PCT SBIN;                          /* Macro call: parenthesis count */
DCL PLUS(0:9) BIT(9) CONSTANT INIT('0'B*4,'014'O,'0'B*4,ASCBIT('+'));
DCL R SBIN;
%REL(NAME="REL(0:36)",STCLASS=AUTO);
DCL RFORM(0:4) UBIN CONSTANT INIT(8,3,7,12,6); /* Format for RPT instructions */
DCL SF SBIN;
DCL SH SBIN;
DCL TREF$ PTR;
DCL TSYM(0:5) UBIN;                    /* Temporary packed symbol */
DCL TV SBIN;                           /* NSA flags temporary */
DCL TYPE SBIN;
DCL TYPE_ARG BIT(3) ALIGNED;
DCL 1 VAL DALIGNED,                    /* Values for fields */
      2 I(0:35) SBIN,                  /* Integer */
      2 B(0:35) REDEF I,               /* Boolean */
        3 BIT0 BIT(1),
        3 * BIT(35),
      2 OP(0:35) REDEF I,              /* OPD: description of value */
        3 VAL UBIN(12) UNAL,
        3 AR BIT(1),
        3 * BIT(16),
        3 MODF BIT(1),
        3 OCTMOD BIT(1),
        3 * BIT(5);
DCL VECFORM(0:29) UBIN CONSTANT INIT(18,2,9,2,5,20,9,2,5,0, /* Formats for NSA vectors */
           18,2,4,12,0,20,4,12,0,0,
           18,2,16,0,0,20,16,0,0,0);
DCL XFORM(0:10) UBIN CONSTANT INIT(3,15,6,3,3,6,18,6,3,3,6);
DCL XUO_OU_UTS UBIN SYMREF;
DCL ZFORM(0:1) UBIN CONSTANT INIT(18,18); /* Format for ZERO */
DCL CARD_COUNT SBIN SYMREF;
%EJECT;
       DO CASE(OP.TYPE);
        CASE(0);                       /* ignore */
           STMNTCT=STMNTCT+1;
%EJECT ;
/* NON-EIS INSTRUCTION
*/
        CASE(1);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           IDS=IDS+1;
           VAL.I(2)=OP.VAL+INHIB.BIT28;
           REL(2)='0'B;
L102:
           CALL VARSCAN(VAL.I(1),REL(1),'4'O);
           CALL VARSCAN(VAL.I(3),REL(3),BINBIT(OP.MASK,3));
           IF REL.OPNDTYP(3)=%OPERREL OR FLOATF AND VAL.I(3)=0 AND NOT REL(3)
             AND (REL(1)=PCREL OR REL.OPNDTYP(1)=%OPERUNDEF
             AND REL.RELOCOP(1)=%RELOCOPADD AND REL.EVALOP(1)=0
             AND NOT REL.S(1)) THEN DO;
                   VAL.I(1)=VAL.I(1)-PC;
                   IF REL(1)=PCREL THEN REL(1)='0'B;
                     ELSE IF REL.EVALOP(1)=0 AND NOT REL.S(1) THEN DO;
                               REL.S(1)=PCREL;
                               REL.S.RELOCOP(1)=%RELOCOPSUB;
                           END;
                         ELSE CALL ERROR(5);
                   VAL.I(3)=4;         /* IC */
                   REL(3)='0'B;
               END;
           IF DEL=%COMMA THEN DO;
                   K=0;
                   CALL VARSCAN(VAL.I(0),REL(0),'0'O);
                   IF NOT OP.AR THEN VAL.I(2)=VAL.I(2)+1;
               END/* IF DEL */;
             ELSE DO;
                   K=1;
                   IF OP.AR THEN CALL ERROR(14);
               END;
           CALL GEN(4-K,IFORM(4*K),VAL.I(K),REL(K));
%EJECT;
/* INDEX INSTRUCTION
*/
        CASE(2);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(2),REL(2),'0'O);
           IF NOT REL(2) THEN DO;
                   IF VAL.I(2) < 0 | VAL.I(2) > 7 THEN DO;
                           CALL ERROR(3);
                           VAL.I(2) = MOD(VAL.I(2),8);
                       END;
                   VAL.I(2)=8*VAL.I(2)+OP.VAL+INHIB.BIT28;
                   GOTO L102;
               END/* NOT REL(2) */;
           VAL.I(3)=VAL.I(2);
           REL(3)=REL(2);
           VAL.I(2)=OP.VAL/64;
           REL(2)='0'B;
           VAL.I(4)=OP.VAL;
           REL(4)='0'B;
           CALL VARSCAN(VAL.I(1),REL(1),'4'O);
           CALL VARSCAN(VAL.I(5),REL(5),BINBIT(OP.MASK,3));
           IF REL.OPNDTYP(5)=%OPERREL OR FLOATF AND VAL.I(5)=0 AND NOT REL(5)
             AND (REL(1)=PCREL OR REL.OPNDTYP(1)=%OPERUNDEF
             AND REL.RELOCOP(1)=%RELOCOPADD AND REL.EVALOP(1)=0
             AND NOT REL.S(1)) THEN DO;
                   VAL.I(1)=VAL.I(1)-PC;
                   IF REL(1)=PCREL THEN REL(1)='0'B;
                     ELSE IF REL.EVALOP(1)=0 AND NOT REL.S(1) THEN DO;
                               REL.S(1)=PCREL;
                               REL.S.RELOCOP(1)=%RELOCOPSUB;
                           END;
                         ELSE CALL ERROR(5);
                   VAL.I(5)=4;         /* IC */
                   REL(5)='0'B;
               END;
           IF DEL=%COMMA THEN DO;
                   K=0;
                   CALL VARSCAN(VAL.I(0),REL(0),'0'O);
                   IF NOT OP.AR THEN VAL.I(4)=VAL.I(4)+1;
               END/* IF DEL */;
             ELSE DO;
                   K=1;
                   IF OP.AR THEN CALL ERROR(14);
               END;
           CALL GEN(6-K,XFORM(6*K),VAL.I(K),REL(K));
%EJECT;
/* TALLY INDIRECT WORDS
*/
        CASE(3);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(0),REL(0),'4'O);
           CALL VARSCAN(VAL.I(1),REL(1),'0'O);
           CALL VARSCAN(VAL.I(2),REL(2),BINBIT(OP.MASK,3));
           VAL.I(2)=BITBIN(BINBIT(VAL.I(2),36)|BINBIT(OP.VAL,36));
           CALL GEN(3,IFORM(4),VAL.I,REL);
%EJECT;
/* REPEAT INSTRUCTIONS
*/
        CASE(4);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           IF OP.RPL THEN DO; VAL.I(4)=0; REL(4)='0'B; END;
             ELSE CALL VARSCAN(VAL.I(4),REL(4),'0'O);
           COND='0'B;
L408:
           CALL NEXTFLD ALTRET(L440);
           IF XCARD(CURRCH)<'0' OR XCARD(CURRCH)>'9' THEN GOTO L410;
           CALL CONVERT(8,VAL.I(2),TYPE);
           IF CURRCH~=NEXTCH THEN CALL ERROR(9);
           COND=COND|BINBIT(VAL.I(2),36);
           GOTO L430;
/**/
L410:
           DO K=0 TO 6;
               IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)=CONDSYM(K) THEN DO;
                       COND.BT(K)=%T; GOTO L430; END;
           END;
           CALL ERROR(4);
L430:
           CURRCH=NEXTCH;
           GOTO L408;
/**/
L440:
           VAL.I(1)=OP.MASK*2+BITBIN(OP.AR);
           REL(1)='0'B;
           VAL.I(2)=BITBIN(COND);
           REL(2)='0'B;
           VAL.I(3)=OP.VAL+INHIB.BIT28;
           REL(3)='0'B;
           CALL GEN(5,RFORM,VAL.I,REL);
%EJECT;
/* RPTX, RPDX
*/
        CASE(5);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           CALL VARSCAN(VAL.I(2),REL(2),'0'O);
           VAL.I(0)=0;
           REL(0)='0'B;
           VAL.I(1)=OP.VAL+INHIB.BIT28;
           REL(1)='0'B;
           CALL GEN(3,IFORM(4),VAL.I,REL);
%EJECT;
/* INSTRUCTIONS W/O VARIABLE FIELDS
*/
        CASE(6);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           VAL.I(0)=0;
           REL(0)='0'B;
           VAL.I(1)=OP.VAL+INHIB.BIT28;
           REL(1)='0'B;
           VAL.I(2)=0;
           REL(2)='0'B;
           CALL GEN(3,IFORM(4),VAL.I,REL);
%EJECT;
/* INHIB
*/
        CASE(10);
           IF PASS2=0 THEN RETURN;
           STMNTCT=STMNTCT+1;
           IF MAC.LIT THEN DO; CALL ERROR(2); RETURN; END;
L1010:
           CALL NEXTFLD ALTRET(L90);
           IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='ON' THEN
               INHIB.BIT28=2;
             ELSE IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='OFF' THEN
                   INHIB.BIT28=0;
                 ELSE IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='SAVE' THEN
                       INHIBI=INHIBI*2;
                     ELSE IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='RESTORE' THEN
                           INHIBI=INHIB.STACK*2;
                         ELSE DO;
                               CALL ERROR(4);
                               RETURN;
                           END;
           CURRCH=NEXTCH; GOTO L1010;
%EJECT;
/* EQU, BOOL, SET, SETB
/*
/*     OP.VAL = bits to insert in REL.F
*/
        CASE(13);
           STMNTCT=STMNTCT+1;
           IF MAC.LIT THEN DO; CALL ERROR(2); RETURN; END;
           CALL VARSCAN(VAL.I(0),REL(0),BINBIT(OP.MASK,3));
           IF DEL~=%BLANK THEN CALL ERROR(4);
           IF LOC(0)=0 THEN DO; CALL ERROR(7); RETURN; END;
           REL.F(0)=BINBIT(OP.VAL,SIZEB(OP.VAL));
           CALL SYMTAB(LOC,VAL.I(0),REL(0),%T);
           CALL GENVAL(1,36,VAL.I,REL);
%EJECT;
/* ENTDEF, ENTREF, SEGREF, SYMDEF, SYMREF
/*
/*     OP.VAL = 1st 18 bits of REL (F,OPNDTYP,EVALOP,RELOCOP)
*/
        CASE(14);
           IF PASS2>0 THEN RETURN;
           STMNTCT=STMNTCT+1;
           IF MAC.LIT THEN DO; CALL ERROR(-2); RETURN; END;
L1410:
           CALL NEXTFLD ALTRET(L90);
           %CONSYM(#SYM=TSYM);
           VAL.I(0)=0;
           REL(0)=BINBIT(OP.VAL,SIZEB(OP.VAL));
           REL.OPERAND(0)=BITBIN('777777'O);
           IF REL.F.EDEF(0) AND OUNAMESW<2 THEN DO;
                   OUNAMESW=2;
                   GOTO SAVEOUNAME;
               END/* IF REL.F.EDEF(0) */;
             ELSE IF REL.F.SDEF(0) AND OUNAMESW=0 THEN DO;
                       OUNAMESW=1;
SAVEOUNAME:
                       %OBJSYM(#S="SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)",#SYM=OUNAME);
                   END;
           CALL SYMTAB(TSYM,VAL.I(0),REL(0),OP.AR='1'B,OP.RPL='1'B);
           IF DEL=%COMMA THEN DO; CURRCH=NEXTCH; GOTO L1410; END;
%EJECT;
/* ASCII, BCI, EBCDIC, UASCI
/*
/*     OP.VAL = index of conversion table
*/
        CASE(15);
           CALL VARSCAN(NW,REL(0),'0'O);
           IF REL(0) THEN DO; CALL ERROR(5); RETURN; END;
           IF PASS2=0 THEN DO; PC=PC+NW; RETURN; END;
           STMNTCT=STMNTCT+1;
           M=4+2*BITBIN(OP.AR);
           CALL XLATEV(36/M,VAL.I,0,M*NW,ASCIIT(OP.VAL),SUBSTR(XCARDS,CURRCH+1),M*NW);
           DO J=0 TO NW-1;
               CALL GEN(1,36,VAL.I(J),'000000000000000000000000'O);
               CALL PRINT;
           END/* DO J */;
           ALTRETURN;
%EJECT;
/* DEC, OCT
*/
        CASE(16);
           STMNTCT=STMNTCT+1;
           BASE=10-2*OP.MASK;
           NW=0;
           DO WHILE(DEL<=%COMMA);
               CALL NEXTFLD ALTRET(DECEND);
               CALL SEARCH(I,J,DECTBL,SUBSTR(XCARDS,0,XCARDL),CURRCH);
               IF J=3 THEN DO;
                       CURRCH=CURRCH-1;
                       DEL=0;
                       CALL VARSCAN(VAL.I(0),REL(0),BINBIT(OP.MASK,3));
                       TYPE=0;
                   END;
                 ELSE DO;
                       MINUS=%F;
                       IF XCARD(CURRCH)='-' THEN DO;
                               MINUS=%T;
                               CURRCH=CURRCH+1;
                           END;
                         ELSE IF XCARD(CURRCH)='+' THEN CURRCH=CURRCH+1;
                       CALL CONVERT(BASE,VAL.I(0),TYPE);
                       IF MINUS THEN
                           IF TYPE~=0 THEN CALL NEG(VAL.I(0));
                             ELSE IF BASE=10 THEN VAL.I(0)=-VAL.I(0);
                                 ELSE VAL.B.BIT0(0)=~VAL.B.BIT0(0);
                       REL(0)='0'B;
                       REL(1)='0'B;
                   END/* IF J ELSE */;
               I=0;
DECGENWORD:
               CALL GEN(1,36,VAL.I(I),REL(I));
               CALL PRINT;
               NW=NW+1;
               I=I+1;
               IF I<TYPE THEN GOTO DECGENWORD;
DECENDFIELD:
               CALL DELSCAN;
               IF NEXTCH~=CURRCH OR DEL<%COMMA THEN CALL ERROR(9);
               IF DEL<%COMMA THEN DO;
                       CALL ERROR(9);
                       CURRCH=NEXTCH+1;
                       GOTO DECENDFIELD;
                   END;
           END/* WHILE DEL */;
DECEND:
           IF ERRCT=0 THEN DO;
                   IF NW~=0 THEN ALTRETURN;
                   CALL ERROR(14);
               END;
%EJECT;
/* ZERO
*/
        CASE(17);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           CALL VARSCAN(VAL.I(1),REL(1),'0'O);
           CALL GEN(2,ZFORM,VAL.I,REL);
%EJECT;
/* VFD, OPD
*/
        CASE(18);
           STMNTCT=STMNTCT+1;
           CALL VFD(BINBIT(OP.VAL,36),VAL.OP(0)) ALTRET(L90);
           IF OP.VAL=0 THEN ALTRETURN;
                                       /* OPD */
           IF PASS2>0 THEN RETURN;
           CALL TREESRCH(OPROOT,LOC(1),LOC(0),SIZEW(OP),%T,IMN);
           IF IMN=0 THEN RETURN;
           IF IMN>0 THEN DO; CALL ERROR(-13); RETURN; END;
           IMN$=ADDR(SPOOL(-IMN));
           IMN$->OP.VAL=VAL.OP.VAL(0);
           IMN$->OP.AR=VAL.OP.AR(0);
           J=0;
           IF VAL.OP.MODF(0) THEN J=2;
           IF VAL.OP.OCTMOD(0) THEN J=3;
           IMN$->OP.MASK=J;
           IMN$->OP.PRFS='11'B;
           IMN$->OP.TYPE=1;
%EJECT;
/* DUP
*/
        CASE(19);
           STMNTCT=STMNTCT+1;
           IF MAC.DUPSV OR MAC.DUP OR MAC.LIT THEN DO; CALL ERROR(2); RETURN; END;
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           CALL VARSCAN(VAL.I(1),REL(1),'0'O);
           IF REL(0) OR REL(1) THEN DO; CALL ERROR(5); RETURN; END;
           IF VAL.I(0)=0 OR VAL.I(1)=0 THEN RETURN;
           CALL GETMAC(1) ALTRET(L90);
           MCX=MCX-1;
           MAC.DUPFC=MCX+1;
           MAC.DUPIC=VAL.I(0); MAC.DUPNC=VAL.I(0);
           MAC.DUPNR=VAL.I(1)-1;
           MAC.DUPSV=%T;
%EJECT;
/* MACRO CALL
/*
/* OP.VAL = index in MPOOL to macro prototype
*/
        CASE(21);
           STMNTCT=STMNTCT+1;
           CALL GETMAC(SIZEW(MAC)) ALTRET(L90);
           NMAC$=ADDR(MPOOL(MCX));
           NMLVL=MCX;
           MCX=MCX+SIZEW(MAC)-1;
           NMAC$->MAC='0'B;
           NMAC$->MAC.DUP=%F; NMAC$->MAC.DUPSV=%F;
           NMAC$->MAC.RMCX=OP.VAL+1;
           NMAC$->MAC.RMCT=MP.NC(NMAC$->MAC.RMCX-1);
           IF PASS2~=0 AND OPTIONS.XR AND REFMAF THEN DO;
                   R=MP.REF(NMAC$->MAC.RMCX-1);
                   CALL PACKEY(K);
                   IF R=0 THEN DO;
                           CALL GETSYM(SIZEW(REF)) ALTRET(L2108);
                           REF$=ADDR(SPOOL(SYMX));
                           TREF$=REF$;
                       END;
                     ELSE DO;
                           REF$=ADDR(SPOOL(R));
                           DO WHILE (K~=REF.KEY);
                               IF REF.KEY=ADDR(SPOOL(REF.LINK))->REF.KEY
                                 OR REF.KEY>ADDR(SPOOL(REF.LINK))->REF.KEY
                                 AND (REF.KEY<K OR K<ADDR(SPOOL(REF.LINK))->REF.KEY)
                                 OR REF.KEY<K AND K<ADDR(SPOOL(REF.LINK))->REF.KEY THEN GOTO L2104;
                               REF$=ADDR(SPOOL(REF.LINK));
                           END;
                           GOTO L2108;
/**/
L2104:
                           CALL GETSYM(SIZEW(REF)) ALTRET(L2108);
                           TREF$=ADDR(SPOOL(SYMX));
                           TREF$->REF.LINK=REF.LINK;
                       END/* IF R=0 ELSE */;
                   REF.LINK=SYMX;
                   TREF$->REF.KEY=K;
                   MP.REF(NMAC$->MAC.RMCX-1)=SYMX;
L2108:
               END/* IF PASS2 */;
           CALL MACROPARAM(NMAC$->MAC.MPAR) ALTRET(L2190);
           IF PMC THEN CALL PRINT;
           NMAC$->MAC.LINK=MLVL;
           MLVL=NMLVL;
           MAC$=NMAC$;
           ALTRETURN;
/**/
L2190:
           MCX=NMLVL-1;
%EJECT;
/* IFE, IFG, IFL, INE
*/
        CASE(22);
           STMNTCT=STMNTCT+1;
           IF MAC.LIT THEN DO; CALL ERROR(2); RETURN; END;
           CALL NEXTFLD;
           IF XCARD(CURRCH)='''' THEN GOTO L2210;
           CALL INDEX1(NEXTCH,',',XCARDS,CURRCH) ALTRET(L2212);
           IF XCARD(NEXTCH+1)='''' THEN GOTO L2211;
           REL(0)='0'B; REL(1)='0'B;
           CURRCH=CURRCH-1;
           DEL=0;
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           CALL VARSCAN(VAL.I(1),REL(1),'0'O);
           DO CASE (OP.VAL);
            CASE(0);
               IF VAL.I(0)=VAL.I(1) AND REL(0)=REL(1)
                 AND REL(0)~=%UNDEF THEN RETURN;
            CASE(1);
               IF VAL.I(0)>VAL.I(1) AND REL(0)=REL(1) THEN RETURN;
            CASE(2);
               IF VAL.I(0)<VAL.I(1) AND REL(0)=REL(1) THEN RETURN;
            CASE(3);
               IF VAL.I(0)~=VAL.I(1) OR REL(0)~=REL(1) THEN RETURN;
           END;
           GOTO L2250;
/**/
L2210:
           CURRCH=CURRCH+1;
           CALL INDEX1(NEXTCH,'''',XCARDS,CURRCH) ALTRET(L2212);
           I=NEXTCH-CURRCH;
           NEXTCH=NEXTCH+2;
           GOTO L2213;
/**/
L2212:     CALL ERROR(4);
           RETURN;
/**/
L2211:     I=NEXTCH-CURRCH;
           NEXTCH=NEXTCH+1;
L2213:     IF XCARD(NEXTCH-1)~=',' THEN GOTO L2212;
           IF XCARD(NEXTCH)='''' THEN DO;
                   NEXTCH=NEXTCH+1;
                   CALL INDEX1(J,'''',XCARDS,NEXTCH) ALTRET(L2212);
               END;
             ELSE CALL SEARCH(J,K,BLKCMA,XCARDS,NEXTCH);
           J=J-NEXTCH;
           DO CASE (OP.VAL);
            CASE(0);
               IF SUBSTR(XCARDS,CURRCH,I)=SUBSTR(XCARDS,NEXTCH,J) THEN RETURN;
            CASE(1);
               IF SUBSTR(XCARDS,CURRCH,I)>SUBSTR(XCARDS,NEXTCH,J) THEN RETURN;
            CASE(2);
               IF SUBSTR(XCARDS,CURRCH,I)<SUBSTR(XCARDS,NEXTCH,J) THEN RETURN;
            CASE(3);
               IF SUBSTR(XCARDS,CURRCH,I)~=SUBSTR(XCARDS,NEXTCH,J) THEN RETURN;
           END;
           CURRCH=NEXTCH+J;
           IF XCARD(CURRCH)='''' THEN CURRCH=CURRCH+1;
L2250:
           VAL.I(2)=1;
           CALL NEXTFLD ALTRET(L2255);
           IF XCARD(CURRCH)='%' THEN
               %CONSYM(#FC=CURRCH+1,#L=NEXTCH-CURRCH-1,#SYM=MAC.SKIP);
             ELSE DO;
                   CURRCH=CURRCH-1;
                   DEL=0;
                   CALL VARSCAN(VAL.I(2),REL(2),'0'O);
                   IF VAL.I(2)<0 THEN DO; CALL ERROR(4); VAL.I(2)=0; END;
                   IF REL(2) THEN CALL ERROR(5);
L2255:
                   MAC.SKIP(0)=-VAL.I(2);
               END;
%EJECT;
/* I/O
*/
        CASE(23);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(0),REL(0),'4'O);
           CALL VARSCAN(VAL.I(2),REL(2),'0'O);
           VAL.I(1)=OP.VAL;
           REL(1)='0'B;
           CALL GEN(3,IOFORM,VAL.I,REL);
%EJECT;
/* IDCW
*/
        CASE(25);
%EJECT;
/* CLIMB
*/
        CASE(26);
           IF PASS2=0 THEN DO; PC=PC+2; RETURN; END;
           STMNTCT=STMNTCT+1;
           IF NOT OP.AR THEN DO;
                   VAL.I(8)=BITBIN('1760'O)*BITBIN(OP.RPL);
                   REL(8)='0'B;
                   GOTO L2610;
               END;
           CALL VARSCAN(VAL.I(8),REL(8),'0'O);
           CALL VARSCAN(VAL.I(5),REL(5),'0'O);
L2610:
           K=1;
           VAL.I(1)=0; REL(1)='0'B; VAL.I(3)=0; REL(3)='0'B;
           VAL.I(2)=BITBIN('7134'O);
           REL(2)='0'B;
           VAL.I(7)=OP.VAL;
           REL(7)='0'B;
           CALL NEXTFLD ALTRET(L2615);
           VAL.B(7)=VAL.B(7)|'000000000040'O;
           CURRCH=CURRCH-1;
           DEL=0;
           CALL VARSCAN(VAL.I(1),REL(1),'0'O);
           GOTO L2620;
/**/
L2615:
           IF DEL~=%LPAR THEN GOTO L2620;
           VAL.B(7)=VAL.B(7)|'000000000040'O;
           CALL VARSCAN(VAL.I(1),REL(1),'0'O);
           IF DEL~=%RPAR THEN CALL VARSCAN(VAL.I(3),REL(3),'2'O);
           IF DEL~=%RPAR THEN DO; K=0;
                   CALL VARSCAN(VAL.I(0),REL(0),'0'O);
                   VAL.I(2)=BITBIN('7135'O);
               END;
           IF DEL=%RPAR THEN DO; CURRCH=CURRCH+1; CALL DELSCAN; CURRCH=NEXTCH; END;
L2620:
           IF NOT OP.AR THEN CALL VARSCAN(VAL.I(5),REL(5),'0'O);
           VAL.I(4)=0; REL(4)='0'B;
           IF VAL.I(5)~=0 OR REL(5) THEN DO; VAL.I(4)=1; VAL.I(5)=VAL.I(5)-1; END;
           VAL.I(6)=0; REL(6)='0'B;
           CALL NEXTFLD ALTRET(L2630);
           IF NEXTCH=CURRCH+1 AND XCARD(CURRCH)='S' THEN
               VAL.B(7)=VAL.B(7)&'000000000057'O;
L2630:
           CALL GEN(4-K,IFORM(4*K),VAL.I(K),REL(K));
           CALL PRINT;
           CALL GEN(5,CL2FORM,VAL.I(4),REL(4));
%EJECT;
/* EIS INSTRUCTIONS & VECTOR INSTRUCTIONS
*/
        CASE(27);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           K=OP.MASK*2+BITBIN(OP.AR);
           CALL MFSCAN(MF(0));
           CALL MFSCAN(MF(1));
           L=BITBIN(OP.RPL);
           MF(2)='0'B;
           IDS=-1;
           NDS=2;
           DO CASE (K);
            CASE(1);
               CALL VARSCAN(VAL.I(2),REL(2),'1'O);
               CALL VARSCAN(VAL.I(3),REL(3),'1'O);
               L=2;
            CASE(2);
               CALL MFSCAN(MF(2));
               NDS=3;
               VAL.B(3)=MF.V(2);
               REL(3)=MF.REL(2);
               L=3;
            CASE(3);
               CALL VARSCAN(VAL.I(2),REL(2),'1'O);
               CALL VARSCAN(VAL.I(0),REL(0),'1'O);
               CALL VARSCAN(VAL.I(3),REL(3),'1'O);
               VAL.I(1)=0; REL(1)='0'B;
               L=0;
            CASE(4);
               IF L ~= 0 THEN
                   GOTO L2750;
               CALL VARSCAN(VAL.I(2),REL(2),'1'O);
               VAL.I(3)=0; REL(3)='0'B;
               L=2;
            CASE(6);
               CALL MFSCAN(MF(2));
               NDS=3;
               GOTO L2750;
            CASE(5);
L2750:
               VAL.B(1+L)=MF.V(2);
               REL(1+L)=MF.REL(2);
               IF L = 0 THEN
                   DO ;
                       CALL VARSCAN(VAL.I(3),REL(3),'1'O);
                       CALL VARSCAN(VAL.I(0),REL(0),'1'O);
                       CALL VARSCAN(VAL.I(2),REL(2),'1'O);
                   END ;
                 ELSE
                   DO ;
                       VAL.I(1)=OP.VAL/32768;
                       REL(1)='0'B;
                       VAL.I(3)=OP.VAL/4096;
                       REL(3)='0'B;
                   END ;
               K=5+L;
           END;
           VAL.B(4)=MF.V(1);
           REL(4)=MF.REL(1);
           VAL.I(5)=OP.VAL+INHIB.BIT28+MF.V.AR(0);
           REL(5)='0'B;
           VAL.B(6)=MF.V(0);
           REL(6)=MF.REL(0);
           CALL GEN(7-L,EFORM(7*K-7+L),VAL.I(L),REL(L));
%EJECT;
/* BDSC VDSC VDSCX
*/
        CASE(28);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           IDS=IDS+1;
           IF IDS>=NDS THEN IDS=3;
           K = OP.MASK ;
           IF K = 0 THEN
               DO ;
                   CALL VARSCAN(VAL.I(1),REL(1),'4'O);
                   TYPE_ARG = BINBIT(MF.V.RL(IDS)*2,3);
                   IF OP.AR = '1'B THEN
                       TYPE_ARG = '2'O ;
                   CALL VARSCAN(VAL.I(4),REL(4),TYPE_ARG);
                   CALL VARSCAN(VAL.I(2),REL(2),'0'O);
                   CALL VARSCAN(VAL.I(3),REL(3),'0'O);
                   K=1;
                   IF MF.V.AR(IDS)~=0 OR DEL=%COMMA THEN DO;
                           K=0; CALL VARSCAN(VAL.I(0),REL(0),'0'O);
                       END/* IF MF.V.AR */;
                   CALL GEN(5-K,BDSCF(5*K),VAL.I(K),REL(K));
               END ;
             ELSE
               DO ;
                   CALL VARSCAN(VAL.I(1),REL(1),'4'O);
                   CALL VARSCAN(VAL.I(2),REL(2),'0'O);
                   VAL.I(3)=K-1; REL(3)='0'B;
                   CALL VARSCAN(VAL.I(4),REL(4),'2'O);
                   IF K > 1 THEN
                       ADDR(VAL.I(2))->BTTBSD =
                         ADDR(VAL.I(2))->BTTBSD | '000000000010'O ;
                   K=1;
                   IF MF.V.AR(IDS)~=0 OR DEL=%COMMA THEN DO;
                           K=0; CALL VARSCAN(VAL.I(0),REL(0),'0'O);
                       END/* IF MF.V.AR */;
                   CALL GEN(5-K,VDSCF(5*K),VAL.I(K),REL(K));
               END ;
%EJECT;
/* ADSC
*/
        CASE(29);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           IDS=IDS+1;
           IF IDS>=NDS THEN IDS=3;
           CALL VARSCAN(VAL.I(1),REL(1),'4'O);
           CALL VARSCAN(VAL.I(2),REL(2),'0'O);
           IF OP.MASK~=0 THEN DO;
                   VAL.I(2)=VAL.I(2)*OP.MASK;
                   IF REL(2) THEN
                       IF REL.EVALOP(2)~=0 OR REL.S(2) THEN DO;
                               CALL ERROR(5);
                               REL(2)='0'B;
                           END;
                         ELSE DO;
                               REL.EVALOP(2)=%EVALOPMULT;
                               REL.VALUE(2)=OP.MASK;
                           END;
               END/* IF OP.MASK */;
           TYPE_ARG = BINBIT(MF.V.RL(IDS)*2,3);
           IF OP.AR = '1'B THEN
               TYPE_ARG = '2'O ;
           CALL VARSCAN(VAL.I(5),REL(5),TYPE_ARG);
           VAL.I(3)=OP.VAL;
           VAL.I(4)=0; REL(3)='0'B; REL(4)='0'B;
           K=1;
           IF MF.V.AR(IDS)~=0 OR DEL=%COMMA THEN DO;
                   K=0; CALL VARSCAN(VAL.I(0),REL(0),'0'O);
               END/* IF MF.V.AR */;
           CALL GEN(6-K,ADSCF(6*K),VAL.I(K),REL(K));
%EJECT;
/* NDSC
*/
        CASE(30);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           IDS=IDS+1;
           IF IDS>=NDS THEN IDS=3;
           CALL VARSCAN(VAL.I(1),REL(1),'4'O);
           CALL VARSCAN(VAL.I(2),REL(2),'0'O);
           TYPE_ARG = BINBIT(MF.V.RL(IDS)*2,3);
           IF OP.AR = '1'B THEN
               TYPE_ARG = '2'O ;
           CALL VARSCAN(VAL.I(6),REL(6),TYPE_ARG);
           CALL VARSCAN(VAL.I(4),REL(4),'0'O);
           CALL VARSCAN(VAL.I(5),REL(5),'0'O);
           VAL.I(3)=OP.VAL;
           REL(3)='0'B;
           K=1;
           IF MF.V.AR(IDS)~=0 OR DEL=%COMMA THEN DO;
                   K=0; CALL VARSCAN(VAL.I(0),REL(0),'0'O);
               END/* IF MF.V.AR */;
           CALL GEN(7-K,NDSCF(7*K),VAL.I(K),REL(K));
%EJECT;
/* MICROP
*/
        CASE(31);
           STMNTCT=STMNTCT+1;
L3100:
           DO K=0 TO 3;
               CALL NEXTFLD ALTRET(L3130);
               M=1;
               IF XCARD(CURRCH)>='0' AND XCARD(CURRCH)<='9' THEN DO;
                       M=ASCBIN(XCARD(CURRCH))-ASCBIN('0');
                       CURRCH=CURRCH+1;
                   END;
               IF XCARD(CURRCH)='H' THEN DO; J=1; SH=0; GOTO L3135; END;
               IF XCARD(CURRCH)='A' OR XCARD(CURRCH)='U' THEN DO; J=1; SH=2; GOTO L3135; END;
               IF XCARD(CURRCH)~='O' THEN CALL ERROR(4);
               J=0;
L3135:
               DO L=1 TO M;
                   IF J~=0 THEN DO; CURRCH=CURRCH+1;
                           VAL.I(K)=ASCBIN(SUBSTR(ASCIIT(SH),ASCBIN(XCARD(CURRCH)),1));
                       END;
                     ELSE DO N=1 TO 3;
                           IF XCARD(CURRCH+1)<'0' OR XCARD(CURRCH+1)>'7' THEN GOTO L3150;
                           CURRCH=CURRCH+1;
                           VAL.I(K)=8*VAL.I(K)+ASCBIN(XCARD(CURRCH))-ASCBIN('0');
                       END;
L3150:
                   REL(K)='0'B;
                   IF L<M THEN K=K+1;
                   IF K<=3 THEN GOTO L3160;
                   CALL GEN(4,QFORM,VAL.I,REL);
                   CALL PRINT;
                   K=0;
L3160:         END/* DO L */;
               CURRCH=CURRCH+1;
               GOTO L3180;
/**/
L3130:
               IF DEL~=%LPAR THEN GOTO L3170;
               CALL NEXTFLD ALTRET(L3170);
               DO M=1 TO 17;
                   IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)=MOP(M) THEN GOTO L3120;
               END;
               CALL ERROR(4);
               M=0;
L3120:
               CURRCH=NEXTCH;
               CALL VARSCAN(VAL.I(K),REL(K),'0'O);
               IF REL(K) THEN DO; CALL ERROR(5); REL(K)='0'B; END;
               VAL.I(K)=VAL.I(K)+M*16;
               IF DEL=%RPAR THEN DO; CURRCH=CURRCH+1; CALL DELSCAN; CURRCH=NEXTCH; END;
               GOTO L3180;
/**/
L3170:
               VAL.I(K)=0; REL(K)='0'B;
L3180:     END/* DO K */;
           CALL GEN(4,QFORM,VAL.I,REL);
           CALL PRINT;
           IF DEL~=%BLANK THEN GOTO L3100;
           ALTRETURN;
%EJECT;
/* ASCNT
*/
        CASE(32);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           VAL.I(1)=0; VAL.I(3)=0; REL(1)='0'B; REL(2)='0'B; REL(3)='0'B;
           VAL.I(2)=1;
           CALL NEXTFLD ALTRET(L3210);
           IF NEXTCH~=CURRCH+1 THEN GOTO L3210;
           IF XCARD(CURRCH)='N' THEN VAL.I(2)=0;
L3210:
           CALL GEN(4,ASFORM,VAL.I,REL);
%EJECT;
/* NSA POINTER
*/
        CASE(33);
           IF PASS2=0 THEN DO; PC=PC+1; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(3),REL(3),'0'O);
           DO J=0 TO 2;
               CALL VARSCAN(VAL.I(J),REL(J),'0'O); END;
           CALL GEN(4,BDSCF(5),VAL.I,REL);
%EJECT;
/* NSA VECTORS
*/
        CASE(34);
           IF PASS2=0 THEN DO; PC=PC+OP.VAL/256; RETURN; END;
           STMNTCT=STMNTCT+1;
           DO J=0 TO 11;
               VAL.I(J)=0; REL(J)='0'B; END;
           CALL VARSCAN(VAL.I(8),REL(8),'0'O);
           K=OP.MASK/2;
           K2=5+K;
           K3=9+K;
           IF NOT OP.AR THEN DO; K=0; GOTO L3420; END;
           CALL VARSCAN(VAL.I(K2),REL(K2),'0'O);
           IF K2=5 THEN GOTO L3420;
           IF REL(6) THEN GOTO L3420;
           VAL.I(5)=VAL.I(6)/4;
           VAL.I(6)=MOD(VAL.I(6),4);
           K2=5;
L3420:
           CALL VARSCAN(VAL.I(K),REL(K),'0'O);
           IF VAL.I(K)~=0 OR REL(K) THEN VAL.I(K)=VAL.I(K)-1;
           IF K=0 THEN DO; VAL.I(1)=3; GOTO L3430; END;
           IF REL(1) THEN GOTO L3430;
           VAL.I(0)=VAL.I(1)/4;
           VAL.I(1)=MOD(VAL.I(1),4);
           K=0;
L3430:
           IF MOD(OP.MASK,2)=0 THEN GOTO L3440;
           CALL VARSCAN(VAL.I(K3),REL(K3),'0'O);
           IF K3=9 THEN GOTO L3440;
           IF REL(10) THEN GOTO L3440;
           VAL.I(9)=VAL.I(10)/4;
           VAL.I(10)=MOD(VAL.I(10),4);
           K3=9;
L3440:
           TV=BITBIN('777'O);
           CALL FLAGS(TV);
           VAL.I(2)=TV;
           VAL.I(3)=MOD(OP.VAL,256);
           CALL GEN(5-K,VECFORM(5*K),VAL.I(K),REL(K));
           CALL PRINT;
           CALL GEN(9-K2,VECFORM(5*K2-15),VAL.I(K2),REL(K2));
           IF MOD(OP.MASK,2)=0 THEN RETURN;
           CALL PRINT;
           CALL GEN(12-K3,VECFORM(5*K3-25),VAL.I(K3),REL(K3));
           CALL PRINT;
           CALL GEN(1,36,VAL.I(11),REL(11));
%EJECT;
/* NSA DESCRIPTORS
*/
        CASE(35);
           IF PASS2=0 THEN DO; PC=PC+2; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(3),REL(3),'0'O);
           K=OP.MASK-1;
           K2=1-K;
           CALL VARSCAN(VAL.I(5),REL(5),'0'O);
           IF K2=0 THEN GOTO L3510;
           IF REL(5) THEN DO; VAL.I(6)=0; REL(6)='0'B; GOTO L3510; END;
           VAL.I(5)=4*VAL.I(5);
           K2=0;
L3510:
           CALL VARSCAN(VAL.I(K),REL(K),'0'O);
           IF VAL.I(K)~=0 OR REL(K) THEN VAL.I(K)=VAL.I(K)-1;
           IF K=0 THEN DO; VAL.I(1)=3; REL(1)='0'B; GOTO L3520; END;
           IF REL(1) THEN GOTO L3520;
           VAL.I(0)=VAL.I(1)/4;
           VAL.I(1)=MOD(VAL.I(1),4);
           REL(0)='0'B;
           K=0;
L3520:
           TV=BITBIN('043'O);
           CALL FLAGS(TV);
           VAL.I(2)=TV;
           L=K;
           IF OP.VAL/2=1 THEN DO; VAL.I(2)=VAL.I(2)/64; L=L+2; END;
           VAL.I(4)=OP.VAL;
           REL(4)='0'B;
           CALL GEN(5-K,DSCF(5*L),VAL.I(K),REL(K));
           CALL PRINT;
           CALL GEN(K2,DSCF(K2+19),VAL.I(5),REL(5));
%EJECT;
/* NSA ENTRY DESCRIPTORS
*/
        CASE(36);
           IF PASS2=0 THEN DO; PC=PC+2; RETURN; END;
           STMNTCT=STMNTCT+1;
           CALL VARSCAN(VAL.I(3),REL(3),'0'O);
           CALL VARSCAN(VAL.I(6),REL(6),'0'O);
           K=1;
           IF NOT REL(6) THEN DO; VAL.I(6)=VAL.I(6)*4; GOTO L3610; END;
           VAL.I(7)=0; REL(7)='0'B;
           K=2;
L3610:
           CALL VARSCAN(VAL.I(5),REL(5),'0'O);
           IF VAL.I(5)~=0 OR REL(5) THEN VAL.I(5)=VAL.I(5)-1;
           CALL VARSCAN(VAL.I(2),REL(2),'0'O);
           CALL VARSCAN(VAL.I(0),REL(0),'0'O);
           VAL.I(1)=0; REL(1)='0'B;
           CALL NEXTFLD ALTRET(L3620);
           IF NEXTCH=CURRCH+1 AND XCARD(CURRCH)='S' THEN VAL.I(1)=1;
L3620:
           VAL.I(4)=OP.VAL;
           REL(4)='0'B;
           CALL GEN(5,EDSCF,VAL.I,REL);
           CALL PRINT;
           CALL GEN(K+1,EDSCF(2*K+3),VAL.I(5),REL(5));
%EJECT;
/* IDRP
*/
        CASE(37);
           STMNTCT=STMNTCT+1;
           IF MLVL=1 OR MAC.LIT THEN DO; CALL ERROR(2); RETURN; END;
           IF MAC.IDRPP=0 THEN DO;
                   CALL MACROPARAM(MAC.IDRPP) ALTRET(IDRPFULL);
                   DO WHILE (%F);
IDRPFULL:
                       IF MAC.IDRPP=0 THEN RETURN;
                   END;
                   IF MPOOL(MAC.IDRPP)=0 THEN DO;
                           CALL ERROR(2);
                           GOTO L3790;
                       END;
                   MAC.IDRPX=MAC.IDRPP+1;
                   MAC.IDRPFC=MAC.RMCX;
                   MAC.IDRPCT=MAC.RMCT;
               END/* IF MAC.IDRPP */;
             ELSE DO;
                   MPOOL(MAC.IDRPP)=MPOOL(MAC.IDRPP)-1;
                   IF MPOOL(MAC.IDRPP)=0 THEN GOTO L3790;
                   MAC.IDRPX=MAC.IDRPX+(ADDR(MPOOL(MAC.IDRPX))->MAP.LEN+4)/4;
                   MAC.RMCX=MAC.IDRPFC;
                   MAC.RMCT=MAC.IDRPCT;
               END;
           RETURN;
/**/
L3790:
           MCX=MAC.IDRPP-1;
           MAC.IDRPP=0;
%EJECT;
/* EDEC
*/
        CASE(42);
           STMNTCT=STMNTCT+1;
           NW=0;
           FB=0;
           VAL.I(0)=0;
           DO WHILE (DEL<=%COMMA);
               FP=%F;
               CALL NEXTFLD ALTRET(EDECEND);
               CALL SEARCH(I,NB,NONDGT,XCARDS,CURRCH);
               IF I>CURRCH THEN CALL CHARBIN(NC,SUBSTR(XCARDS,CURRCH,I-CURRCH));
                 ELSE NC=0;
               IF NB=9 THEN FB=((FB+8)/9)*9;
                 ELSE IF NB~=4 THEN DO;
                           CALL ERROR(9);
                           GOTO EDECSCANNEXT;
                       END;
               CURRCH=I+1;
               LEFT=(XCARD(CURRCH)='L');
               IF LEFT THEN CURRCH=CURRCH+1;
               FC=CURRCH;
               CT=0;
               DO WHILE (%T);
                   DO CASE (DIGITPMPE(ASCBIN(XCARD(CURRCH))));
                    CASE(1);           /* DIGIT */
                       CT=CT+1;
                       DP=DP-1;
                    CASE(2,3);         /* +, - */
                       CT=CT+1;
                    CASE(4);           /* . */
                       FP=%T;
                       IF NB=4 THEN CT=CT+2;
                         ELSE CT=CT+1;
                       DP=0;
                    CASE(5);           /* E */
                       CURRCH=CURRCH+1;
                       MINUS=(XCARD(CURRCH)='-');
                       IF MINUS OR XCARD(CURRCH)='+' THEN CURRCH=CURRCH+1;
                       CALL SEARCH(I,SF,NONDGT,XCARDS,CURRCH);
                       IF I>CURRCH THEN CALL CHARBIN(SF,SUBSTR(XCARDS,CURRCH,I-CURRCH));
                         ELSE SF=0;
                       CURRCH=I;
                       IF NOT FP THEN DO;
                               FP=%T;
                               IF NB=4 THEN CT=CT+2;
                                 ELSE CT=CT+1;
                               DP=0;
                           END;
                       IF MINUS THEN DP=DP-SF;
                         ELSE DP=DP+SF;
                       IF DP>127 OR DP<-128 THEN CALL ERROR(9);
                       GOTO EDECENDSCAN;
                    CASE(ELSE);
                       GOTO EDECENDSCAN;
                   END/* CASE DIGITPMME(XCARD(CURRCH)) */;
                   CURRCH=CURRCH+1;
               END/* WHILE %T */;
EDECENDSCAN:
               IF CT>NC THEN CALL ERROR(9);
               CC=FC;
               DO WHILE(%T);
                   DO CASE (DIGITPMPE(ASCBIN(XCARD(CC))));
                    CASE(1);           /* DIGIT */
                       IF CC=FC THEN DO;
                               IF FP THEN CALL EDINS(PLUS(NB));
                               IF NOT LEFT THEN
                                   DO WHILE (NC>CT);
                                       CALL EDINS(0);
                                   END;
                           END/* IF CC */;
                       IF CT<=NC THEN CALL EDINS(XCARD(CC));
                       CT=CT-1;
                    CASE(2);           /* + */
                       BSIGN=PLUS(NB);
INSIGN:
                       CALL EDINS(BSIGN);
                       CT=CT-1;
                       IF NOT LEFT THEN
                           DO WHILE (NC>CT);
                               CALL EDINS(0);
                           END;
                    CASE(3);           /* - */
                       BSIGN=ASCBIT('-');
                       GOTO INSIGN;
                    CASE(4);           /* . */
                       IF CC=FC THEN DO;
                               IF FP THEN CALL EDINS(PLUS(NB));
                               IF NOT LEFT THEN
                                   DO WHILE (NC>CT);
                                       CALL EDINS(0);
                                   END;
                           END/* IF CC */;
                    CASE(ELSE);
                       GOTO EDECENDFIELD;
                   END/* CASE J */;
                   CC=CC+1;
                   IF CT<=0 THEN GOTO EDECENDFIELD;
               END/* WHILE %T */;
EDECENDFIELD:
               IF FP THEN DO;
                       IF NB=4 THEN CALL EDINS(BINBIT((DP+256)/16,9));
                       CALL EDINS(BINBIT(DP,9)&'377'O);
                   END;
               DO WHILE (NC>0);
                   CALL EDINS(0);
               END;
EDECSCANNEXT:
               CALL DELSCAN;
               IF NEXTCH~=CURRCH OR DEL<%COMMA THEN CALL ERROR(9);
               IF DEL<%COMMA THEN DO;
                       CALL ERROR(9);
                       CURRCH=NEXTCH+1;
                       GOTO EDECSCANNEXT;
                   END;
           END/* WHILE DEL */;
EDECEND:
           IF FB~=0 THEN DO;
                   CALL GEN(1,36,VAL.I,'000000000000000000000000'O);
                   CALL PRINT;
                   NW=NW+1;
               END;
           IF ERRCT=0 THEN DO;
                   IF NW~=0 THEN ALTRETURN;
                   CALL ERROR(14);
               END;
%EJECT;
/* DATE, TTLDAT
*/
        CASE(44);
           IF OP.VAL=0 THEN DO;
                   CALL M$TIME(FPT_TIME);
                   CALL INSERT(DBUF,6,2,DBUF);
                   CALL XLATEV(6,VAL.I(0),0,6,ASCII.BCD,SUBSTR(DBUF,2),6);
               END;
             ELSE VAL.I(0)=TTLDAT;
           CALL GEN(1,36,VAL.I,'000000000000000000000000'O);
%EJECT;
/* ILLEGAL INSTRUCTION TYPE
*/
        CASE(ELSE);
           STMNTCT=STMNTCT+1;
           CALL ERROR(2);
       END/* CASE OP.TYPE */;
L90:
       RETURN;
%EJECT;
/* EDEC INSERT CHARACTER
*/
EDINS: PROC (CH);
DCL CH BIT(9) UNAL;
       IF NC>0 THEN DO;
               IF NB=4 AND MOD(FB,9)=0 THEN FB=FB+1;
               CALL BITINSERT(VAL.I(0),FB,NB,CH,9-NB,9);
               NC=NC-1;
               FB=FB+NB;
               IF FB>=36 THEN DO;
                       CALL GEN(1,36,VAL.I,'000000000000000000000000'O);
                       CALL PRINT;
                       NW=NW+1;
                       VAL.I(0)=0;
                       FB=0;
                   END;
           END/* IF NC */;
       RETURN;
END EDINS;
%EJECT;
/* SCAN FLAGS
*/
FLAGS: PROC (TV);
DCL 1 TV ALIGNED,
      2 B(0:35) BIT(1);
/**/
DCL FLAG(0:11) CHAR(4) CONSTANT INIT('M','N','P','E','X','B','S','W','R','ALL','NONE','NOT');
/**/
DCL K SBIN;
DCL NOTF BIT(1);
/**/
       NOTF=%F;
       CALL NEXTFLD ALTRET(S5);
       TV=BINBIT(3,36);
       GOTO S15;
/**/
S5:
       IF DEL~=%LPAR THEN RETURN;
       TV=BINBIT(3,36);
S10:
       CALL NEXTFLD ALTRET(S40);
S15:
       DO K=1 TO 12;
           IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)=FLAG(K-1) THEN GOTO S30;
       END;
       CALL ERROR(4);
       GOTO S40;
/**/
S30:
       DO CASE(K);
        CASE(ELSE);
           K=36-K;
           TV.B(K)=(K>2)&~NOTF;
        CASE(10);                      /* ALL */
           TV='000000000777'O;
        CASE(11);                      /* NONE */
           TV=BINBIT(3,36);
           RETURN;
        CASE(12);                      /* NOT */
           NOTF=%T;
       END;
S40:
       CURRCH=NEXTCH;
       IF DEL=%COMMA THEN GOTO S10;
       RETURN;
END FLAGS;
%EJECT;
/* SAVE MACRO AND IDRP PARAMETERS
/*
/* RETURN MPOOL INDEX IN MPAR
/*
/* ALTRETURN IF INSUFFICIENT SPACE IN MPOOL
*/
MACROPARAM: PROC (MPAR) ALTRET;
DCL MPAR UBIN(18) UNAL;
/**/
DCL 1 BLK,
      2 OK(0:35) BIT(1);
DCL CPAR SBIN;
DCL K SBIN;
DCL NW SBIN;
DCL PCT SBIN;
/**/
       MPAR=0;
       CALL GETMAC(1) ALTRET(MPERR);
       MPAR=MCX;
       MPOOL(MPAR)=0;
       PCT=0;
       BLK=%F;
       CPAR=0;
MPNEXT:
       CURRCH=CURRCH+1;
       K=CURRCH;
       DO WHILE (%T);
           CALL DELSCAN;
           DO CASE (DEL);
            CASE(%LPAR,%LB);
               IF PCT=0 AND OP.TYPE=21 AND NEXTCH~=K THEN DO;
                       L=NEXTCH;
                       NEXTCH=NEXTCH-1;
                       GOTO MPSAVE1;
                   END;
               PCT=PCT+1;
               BLK.OK(PCT)=(DEL=%LPAR);
            CASE(%RPAR,%RB);
               IF PCT=0 OR BLK.OK(PCT)~=(DEL=%RPAR) THEN CALL ERROR(4);
               IF PCT>0 THEN PCT=PCT-1;
               IF PCT=0 AND OP.TYPE=21 AND XCARD(NEXTCH+1)~=',' THEN DO;
                       L=NEXTCH+1;
                       GOTO MPSAVE1;
                   END;
            CASE(%BLANK);
               IF NOT BLK.OK(PCT) THEN
                   IF NEXTCH=K AND (XCARD(K-1)=',' OR XCARD(K-1)=' ') THEN GOTO MPNOSAVE;
                     ELSE GOTO MPSAVE;
               L=NEXTCH;
               IF L<72 THEN L=72;
               IF L<XCARDL THEN L=XCARDL;
               IF SUBSTR(XCARDS,NEXTCH,L-NEXTCH)=' ' THEN GOTO MPSAVE1;
            CASE(%COMMA);
               IF PCT=0 THEN GOTO MPSAVE;
           END/* CASE DEL */;
           CURRCH=NEXTCH+1;
       END/* WHILE %T */;
MPSAVE:
       L=NEXTCH;
MPSAVE1:
       IF CPAR=0 THEN NW=(L-K+4)/4;
         ELSE NW=(MAP.LEN+L-K+4)/4-MCX+CPAR;
       CALL GETMAC(NW) ALTRET(MPERR);
       IF CPAR=0 THEN DO;
               MPOOL(MPAR)=MPOOL(MPAR)+1;
               MAP$=ADDR(MPOOL(MCX));
               MAP.LEN=L-K;
               MAP.TEXT=SUBSTR(XCARDS,K);
               CPAR=MCX;
           END;
         ELSE DO;
               CALL INSERT(MAP.TEXT,MAP.LEN,L-K,SUBSTR(XCARDS,K));
               MAP.LEN=MAP.LEN+L-K;
           END;
       MCX=MCX+NW-1;
       IF PCT=0 THEN DO;
               IF SUBSTR(MAP.TEXT,0,1)='(' AND SUBSTR(MAP.TEXT,MAP.LEN-1,1)=')'
                 OR SUBSTR(MAP.TEXT,0,1)='[' AND SUBSTR(MAP.TEXT,MAP.LEN-1,1)=']' THEN DO;
                       MAP.TEXT=SUBSTR(MAP.TEXT,1);
                       MAP.LEN=MAP.LEN-2;
                       IF MOD(MAP.LEN,4)>=2 THEN MCX=MCX-1;
                   END;
               CPAR=0;
           END/* IF PCT */;
MPNOSAVE:
       CURRCH=NEXTCH;
       IF DEL<=%COMMA THEN GOTO MPNEXT;
         ELSE IF PCT~=0 OR XCARD(NEXTCH-1)=',' THEN DO;
                   CARD_COUNT=CARD_COUNT + 1 ;
                   CALL READCARD(%T);
                   IF NOT MAC.CARDF THEN GOTO MPNEXT;
                   IF PCT=0 THEN DO;
                           IF CPAR = 0 THEN
                               RETURN ;
 
                           K=NEXTCH;
                           GOTO MPSAVE;
                       END;
               END/* ELSE IF PCT~=0 */;
       IF PCT~=0 THEN DO;
               CALL ERROR(4);
               DO WHILE(PCT~=0 AND (SUBSTR(MAP.TEXT,0,1)='(' OR SUBSTR(MAP.TEXT,0,1)='['));
                   MAP.TEXT=SUBSTR(MAP.TEXT,1);
                   MAP.LEN=MAP.LEN-1;
                   IF MOD(MAP.LEN,4)=3 THEN MCX=MCX-1;
                   PCT=PCT-1;
               END;
           END/* IF PCT */;
       RETURN;
/**/
MPERR:
       ALTRETURN;
END MACROPARAM;
%EJECT;
/* SCAN EIS MODIFIER FIELD
*/
MFSCAN: PROC (MF);
DCL 1 MF ALIGNED,                      /* (output) EIS modifier field */
      2 V,                             /* Value */
        3 * BIT(29),
        3 AR UBIN(1) UNAL,             /* Descriptor specifies AR. */
        3 RL UBIN(1) UNAL,             /* Record length in register */
        3 ID UBIN(1) UNAL,             /* Indirect address to descriptor */
        3 REG UBIN(4) UNAL,       /* Register containing bit/character offset */
       %REL(LVL=2);
/**/
DCL J SBIN;
DCL VAL SBIN;
/**/
       MF='0'B;
       CALL NEXTFLD ALTRET(S30);
       CURRCH=CURRCH-1;
       DEL=0;
       CALL VARSCAN(MF.V,MF.REL,'1'O);
       GOTO S15;
/**/
S30:
       IF DEL~=%LPAR THEN DO; CURRCH=NEXTCH; RETURN; END;
       DO J=0 TO 3;
           CALL VARSCAN(VAL,MF.REL,BINBIT(2*(J/3),3));
           IF MF.REL AND J<3 THEN CALL ERROR(5);
           DO CASE(J);
            CASE(0);
               MF.V.AR=VAL;
            CASE(1);
               MF.V.RL=VAL;
            CASE(2);
               MF.V.ID=VAL;
            CASE(3);
               MF.V.REG=VAL;
           END;
       END/* DO J */;
       IF DEL=%RPAR THEN DO; CURRCH=CURRCH+1; CALL DELSCAN; CURRCH=NEXTCH; END;
S15:
       RETURN;
END MFSCAN;
END INST;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* GET INTEGER PART OF KEY VALUE (LINE NUMBER) FOR DEBUG SCHEMA
*/
KEYVAL: PROC (VAL);
DCL VAL SBIN;
%INCLUDE BMAP_C;
/**/
%BMAP_COMMON;
DCL I SBIN;
DCL J SBIN;
/**/
       CALL INDEX1R(I,' ',KEY,8) ALTRET(NOBLK);
       I=I+1;
       DO WHILE (%F);
NOBLK:
           I=0;
       END;
       IF SUBSTR(KEY,5,1)='.' THEN J=5-I;
         ELSE J=9-I;
       IF J~=0 THEN CALL CHARBIN(VAL,SUBSTR(KEY,I,J));
         ELSE VAL=0;
       RETURN;
END KEYVAL;
%EOD;
/*M* LIST - Listing Routines for BMAP */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
LIST:  PROC (BUFFER,NCH,DIAG);
DCL BUFFER CHAR(140);                  /* LIST: Line buffer */
%SUB TITLE=BUFFER;                     /* EJECT: Title buffer */
DCL NCH SBIN;                          /* Length (characters) of BUFFER */
DCL DIAG BIT(1) ALIGNED;               /* LIST: Diagnostic output */
%SUB TITLEFLG=DIAG;                    /* EJECT: New title */
/**/
%INCLUDE B$JIT_C;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE BMAP_C;
/**/
DCL M$DO DCB;
DCL M$LO DCB;
DCL M$SI DCB;
DCL M$UI DCB;
/**/
DCL OUERR ENTRY (3);
/**/
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
%B$TCB;
%B$ALT;
%BMAP_COMMON;
DCL XUO_OU_UTS UBIN SYMREF;
DCL 1 VERSION SYMREF,
      2 LEVC CHAR(2),
      2 RELC CHAR(1),
      2 LEV BIT(9);
/**/
%B$JIT0;
%U$JIT1;
%A$JIT6X;
%F$DCB(BASED="BASED(DCB$)");
%FPT_CLOSE(DCB=M$LO,DISP=SAVE);
%FPT_CORRES(DCB1=M$DO,DCB2=M$LO,STCLASS=CONSTANT);
%FPT_DEVICE(DCB=M$LO,HDR=VLP_HDR,PAGE=YES,STCLASS=CONSTANT);
%FPT_OPEN(DCB=M$LO,FUN=CREATE,DISP=NAMED);
%FPT_TIME(SOURCE=UTS,DEST=LOCAL,DATE=DBUF,TIME=TBUF,TSTAMP=XUO_OU_UTS,STCLASS=CONSTANT);
%FPT_WRITE(DCB=M$LO);
%VLP_HDR(COUNT=106,LEN=125,HEADERHEIGHT=2,RESETPAGE=YES);
/**/
DCL DBUF CHAR(8) STATIC;               /* Date buffer for M$TIME */
DCL DOLO SBIN STATIC SYMDEF INIT(-1);  /* WRITE ERRORS TO:
                                       /* -1 M$DO
                                       /* 0  M$DO AND M$LO
                                       /* +1 M$LO */
DCL TBUF CHAR(5) STATIC;               /* Time buffer for M$TIME */
/**/
DCL DCB$ PTR;                          /* -> M$SI */
DCL I SBIN;
DCL J SBIN;
/**/
       FPT_WRITE.BUF_.BUF$=ADDR(BUFFER);
       FPT_WRITE.BUF_.BOUND=NCH-1;
       IF OPTIONS.LS AND B$JIT.PRFLAGS.LIST
         OR DIAG AND DOLO>0 AND B$JIT.PRFLAGS.COMMENT THEN DO;
               IF VLP_HDR.CTL.RESETPAGE# THEN DO;
                       CALL M$DEVICE(FPT_DEVICE) ALTRET(LOERR);
                       VLP_HDR.CTL.RESETPAGE#=%F;
                   END/* IF VLP_HDR.CTL.RESETPAGE# */;
               CALL M$WRITE(FPT_WRITE) ALTRET(LOERR);
           END/* IF OPTIONS.LS */;
       DO WHILE (%F);
LOERR:
           OPTIONS.LS='0'B;            /* ONLY DO THIS ONCE */
           DOLO=-1;
           CALL OUERR(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$LO),4);
       END;
       IF DOLO<=0 AND DIAG AND B$JIT.PRFLAGS.COMMENT THEN DO;
               FPT_WRITE.V.DCB#=DCBNUM(M$DO);
               CALL M$WRITE(FPT_WRITE) ALTRET(DOERR);
               DO WHILE (%F);
DOERR:
                   CALL OUERR(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DO),4);
               END;
               FPT_WRITE.V.DCB#=DCBNUM(M$LO);
           END;
       RETURN;
%EJECT;
/* EJECT PAGE AND SET NEW TITLE
*/
EJECT: ENTRY (TITLE,NCH,TITLEFLG);
       IF NOT OPTIONS.LS THEN RETURN;
EJECTLU: ENTRY(TITLE,NCH,TITLEFLG);
       IF VLP_HDR.CTL.RESETPAGE# THEN DO;
               VLP_HDR.TITL.L#=SIZEC(VLP_HDR.TITL.TITLE#);
               DCB$=DCBADDR(DCBNUM(M$SI));
               CALL INSERT(VLP_HDR.TITL.TITLE#,0,,'                 FILE=',F$DCB.NAME#.C);
               I=F$DCB.NAME#.L;
               IF I~=0 AND SUBSTR(F$DCB.NAME#.C,0,1)~='*' AND F$DCB.ACCT#~=B$JIT.FACCN THEN
                   CALL INSERT(VLP_HDR.TITL.TITLE#,22+I,9,'.',F$DCB.ACCT#);
               IF OPTIONS.UI THEN DO;
                       CALL INDEX1(I,' ',SUBSTR(VLP_HDR.TITL.TITLE#,22)) ALTRET(FLDFULL);
                       DCB$=DCBADDR(DCBNUM(M$UI));
                       CALL INSERT(VLP_HDR.TITL.TITLE#,22+I,32,',',F$DCB.NAME#.C);
                       J=F$DCB.NAME#.L;
                       IF J~=0 AND SUBSTR(F$DCB.NAME#.C,0,1)~='*' AND F$DCB.ACCT#~=B$JIT.FACCN THEN
                           CALL INSERT(VLP_HDR.TITL.TITLE#,22+I+1+J,9,'.',F$DCB.ACCT#);
FLDFULL:
                   END/* IF OPTIONS.UI */;
               CALL M$TIME(FPT_TIME);
               CALL INSERT(VLP_HDR.TITL.TITLE#,1,14,TBUF,' ',DBUF);
               CALL INSERT(VLP_HDR.TITL.TITLE#,110,,
                 'BMAP - ',VERSION.RELC,VERSION.LEVC);
           END/* IF VLP_HDR.CTL.RESETPAGE# */;
       IF TITLEFLG THEN DO;
               CALL INDEX1(I,' ',SUBSTR(VLP_HDR.TITL.TITLE#,22,24)) ALTRET(FILELONG);
               DO WHILE(%F);
FILELONG:
                   CALL INDEX1(I,',',SUBSTR(VLP_HDR.TITL.TITLE#,22,24)) ALTRET(SILONG);
                   DO WHILE(%F);
SILONG:
                       CALL INDEX1(I,'.',SUBSTR(VLP_HDR.TITL.TITLE#,22,24)) ALTRET(NAMELONG);
                   END;
                   CALL INSERT(VLP_HDR.TITL.TITLE#,22+I,24,' ');
NAMELONG:
               END/* FILELONG */;
               CALL INSERT(VLP_HDR.TITL.TITLE#,46,57,SUBSTR(TITLE,0,NCH));
           END/* IF TITLEFLG */;
       IF B$JIT.PRFLAGS.LIST THEN DO;
               CALL M$DEVICE(FPT_DEVICE) ALTRET(DEVERR1);
               DO WHILE (%F);
DEVERR1:
                   OPTIONS.LS='0'B;
                   DOLO=-1;
                   CALL OUERR(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$LO),4);
               END;
               VLP_HDR.CTL.RESETPAGE#=%F;
           END/* IF B$JIT.PRFLAGS.LIST */;
       RETURN;
%EJECT;
/* CLOSE LISTING FILES
*/
LISTCLOSE: ENTRY;
       CALL M$CLOSE(FPT_CLOSE);
       IF DOLO<=0 THEN DO;
               FPT_CLOSE.V.DCB#=DCBNUM(M$DO);
               CALL M$CLOSE(FPT_CLOSE);
           END;
       RETURN;
%EJECT;
/* OPEN LIST FILES
*/
LISTOPEN: ENTRY;
       IF OPTIONS.LS OR OPTIONS.XR OR OPTIONS.LU THEN DO;
               CALL M$OPEN (FPT_OPEN) ALTRET(LOERR1);
               DO WHILE (%F);
LOERR1:
                   OPTIONS.LS='0'B;
                   OPTIONS.LU='0'B;
                   OPTIONS.XR='0'B;
                   DOLO=-1;
                   CALL OUERR(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$LO),4);
                   RETURN;
               END;
               DOLO=1;                 /* Assume they correspond */
               CALL M$CORRES(FPT_CORRES) ALTRET (DOLO_ARE_SAME);
               DOLO=0;
           END/* IF OPTIONS.LS */;
         ELSE DOLO=-1;
       FPT_OPEN.V.DCB# = DCBNUM(M$DO);
       CALL M$OPEN(FPT_OPEN) ALTRET(DOERR1); /* Use the same open fpt */
       DO WHILE (%F);
DOERR1:
           DOLO=1;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE~=%E$DCBOPEN THEN CALL OUERR(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DO),4);
       END;
DOLO_ARE_SAME:
       RETURN;
END LIST;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SCAN LITERAL
/*
/* Called when an = is encountered in an expression
*/
LITERAL: PROC (VAL,REL,CONST);
DCL VAL SBIN;                     /* (Output) Value (location) of literal */
%INCLUDE BMAP_C;
%REL;                                  /* (Output) Relocation for VAL */
DCL CONST BIT(1) ALIGNED;              /* (Input) Return literal value */
DCL NEG ENTRY (1);
DCL XLATEV ENTRY (7) ALTRET;
DCL INST ENTRY ALTRET;
DCL CONVERT ENTRY (3);
DCL DELSCAN ENTRY;
DCL ERROR ENTRY (1);
DCL READCARD ENTRY (1);
DCL TREESRCH ENTRY (6);
DCL VFD ENTRY (2) ALTRET;
/**/
%BMAP_COMMON;
DCL BASE SBIN;
%LIT(NAME=CLIT,STCLASS="");
DCL CONTROLS(0:511) UBIN(9) UNAL CONSTANT INIT(0*64,
       0,2,0*6,3,0*4,5,0,1,0*2,7,0*2,2,4,0*3,6,0*5,
       0,2,0*6,3,0*4,5,0,1,0*2,7,0*2,2,4,0*3,6,0*5,
       0*384);
DCL F BIT(1);
DCL I SBIN;
DCL ILIT SBIN;
DCL J SBIN;
%LIT;
DCL M SBIN;
DCL 1 NC DALIGNED,
      2 I SBIN,
      2 B REDEF I,
        3 BIT0 BIT(1),
        3 * BIT(35),
      2 J UBIN;
DCL NCW SBIN;
DCL OPCODE(0:5) UBIN;
DCL SH SBIN;
DCL SVLIT$ PTR;
DCL SVOP$ PTR;
DCL TYPE SBIN;
DCL CARD_COUNT SBIN SYMREF;
/**/
       CURRCH=CURRCH+1;
       CALL DELSCAN;
       BASE=10;
       SVLIT$=LIT$;
       LIT$=ADDR(CLIT);
       F=%F;
       TYPE=0;
       J=CONTROLS(ASCBIN(XCARD(CURRCH)));
       DO CASE(J);
        CASE(1);                       /* O=OCTAL */
           BASE=8;
           CURRCH=CURRCH+1;
           GOTO NUMERIC;
        CASE(2);                       /* A=ASCII, U=UASCI */
           M=9;
           SH=2;
           NC.I=4;
           GOTO S170;
        CASE(3);                       /* H=BCD */
           M=6;
           SH=0;
           NC.I=6;
           GOTO S170;
        CASE(4);                       /* V=VFD */
           CLIT.LEN=0;
           CLIT.RX=0;
           CALL VFD(0);
        CASE(5);                       /* M=INSTRUCTION */
           CURRCH=CURRCH+1;
           CALL INDEX1(NEXTCH,' ',SUBSTR(XCARDS,0,XCARDL),CURRCH);
           %CONSYM(#SYM=OPCODE);
           CALL TREESRCH(OPROOT,OPCODE(1),OPCODE(0),SIZEW(OP),%F,IOP);
           IF IOP<=0 THEN DO;
                   IOP=%NONOP;
                   CALL ERROR(2);
               END;
           DEL=0;
           CURRCH=NEXTCH;
           CLIT.LEN=0;
           CLIT.RX=0;
           MAC.LIT=%T;
           SVOP$=OP$;
           OP$=ADDR(SPOOL(IOP));
NEXTINST:
           CALL INST;
           IF NOT MAC.LIT THEN DO;
                   CARD_COUNT=CARD_COUNT + 1 ;
                   CALL READCARD(%F);
                   GOTO NEXTINST;
               END;
           OP$=SVOP$;
           MAC.LIT=%F;
        CASE(6,7);                     /* Z, R ARE ERRORS HERE */
           GOTO LITERR;
        CASE(ELSE);
NUMERIC:
           M=0;
           IF XCARD(CURRCH)='-' THEN DO; M=-1; CURRCH=CURRCH+1; END;
           IF '0'>XCARD(CURRCH) OR XCARD(CURRCH)>'9' THEN DO;
LITERR:
                   CALL ERROR(4);
S125:
                   VAL=0;
                   REL='0'B;
                   LIT$=SVLIT$;
                   RETURN;
               END;
           CALL CONVERT(BASE,NC,TYPE);
           J=CONTROLS(ASCBIN(XCARD(CURRCH)));
           DO CASE(J);
            CASE(2);                   /* A=ASCII, U=UASCI */
               M=9;
               SH=2;
               GOTO S170;
            CASE(6);                   /* Z=RIGHT-JUSTIFIED ASCII */
               M=-9;
               SH=2;
               GOTO S170;
            CASE(3);                   /* H=BCD */
               M=6;
               SH=0;
               GOTO S170;
            CASE(7);                   /* R=RIGHT-JUSTIFIED BCD */
               M=-6;
               SH=0;
               GOTO S170;
            CASE(1,4,5);               /* O, V, M  ARE ERRORS HERE */
               GOTO LITERR;
           END/* CASE J */;
           IF CURRCH>NEXTCH THEN IF XCARD(CURRCH)='*' THEN NEXTCH=CURRCH; ELSE CALL DELSCAN;
           IF CURRCH~=NEXTCH THEN GOTO LITERR;
           CLIT.LEN=1;
           IF TYPE=2 THEN CLIT.LEN=2;
           CLIT.RX=CLIT.LEN;
           IF M~=0 THEN
               IF TYPE~=0 THEN CALL NEG(NC);
                 ELSE IF BASE=10 THEN NC.I=-NC.I;
                     ELSE NC.B.BIT0=~NC.B.BIT0;
           CLIT.V(0)=NC.I;
           IF TYPE=2 THEN CLIT.V(1)=NC.J;
           F=(TYPE~=0);
       END/* CASE J */;
S130:
       IF CONST OR DEL<=%COMMA THEN DO;
               IF F THEN VAL=CLIT.V(0)/262144;
                 ELSE VAL=CLIT.V(0);
               REL='0'B;
           END;
         ELSE DO;
               CALL TREESRCH(LITROOT,CLIT.V,BINBIT(CLIT.LEN,36),SIZEW(LIT)-SIZEW(LIT.V)+1,%T,ILIT);
               IF ILIT=0 THEN DO; CALL ERROR(8); GOTO S125; END;
               IF ILIT>0 THEN LIT$=ADDR(SPOOL(ILIT));
                 ELSE DO;
                       ILIT=-ILIT;
                       LIT$=ADDR(SPOOL(ILIT));
                       LIT.LEN=CLIT.LEN;
                       LIT.RX=CLIT.RX;
                       IF CLIT.LEN=2 AND BINBIT(LITLOC,1) THEN LITLOC=LITLOC+1;
                       LIT.PC=LITLOC;
                       LITLOC=LITLOC+CLIT.RX;
                   END;
               VAL=LIT.PC;
               REL='000401'O;
               REL.OPERAND=LITSECT;
           END/* IF CONST ELSE */;
       LIT$=SVLIT$;
       RETURN;
/**/
S170:
       IF TYPE~=0 THEN GOTO LITERR;
       IF NC.I<0 THEN DO; CALL ERROR(9); NC.I=-NC.I; END;
       CLIT.V(0)=0;
       F=(M>0);
       IF M<0 THEN DO; M=-M; NCW=36/M; J=NCW-NC.I;
               IF J<0 THEN DO; J=0;
                       CURRCH=CURRCH+NC.I-NCW;
                       NC.I=NCW;
                   END;
           END/* IF M */;
         ELSE DO; NCW=36/M;
               J=0;
               IF NC.I>NCW*SIZEW(CLIT.V) THEN NC.I=NCW*SIZEW(CLIT.V);
           END;
       CLIT.LEN=(J+NC.I+NCW-1)/NCW;
       CLIT.RX=CLIT.LEN;
       CALL XLATEV(M,CLIT.V,J,CLIT.LEN*NCW,ASCIIT(SH),SUBSTR(XCARDS,CURRCH+1),NC.I);
       CURRCH=CURRCH+NC.I+1;
       CALL DELSCAN;
       IF NEXTCH~=CURRCH THEN GOTO LITERR;
       GOTO S130;
END LITERAL;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SCAN FROM CURRCH TO NEXT VARIABLE FIELD
/*
/* LEAVE CURRCH AT BEGINNING OF FIELD
/* LEAVE NEXTCH AT FIRST DELIMITER IN FIELD
/*
/* ALTRETURN IF FIELD IS EMPTY
*/
NEXTFLD: PROC ALTRET;
%INCLUDE BMAP_C;
DCL DELSCAN ENTRY;
DCL READCARD ENTRY (1);
%BMAP_COMMON;
DCL CARD_COUNT SBIN SYMREF;
/**/
       IF DEL=%RPAR THEN ALTRETURN;
S10:
       IF MAC.CARDF THEN DO; DEL=%BLANK; ALTRETURN; END;
       IF DEL=%BLANK THEN ALTRETURN;
       CURRCH=CURRCH+1;
       CALL DELSCAN;
       IF NEXTCH~=CURRCH THEN RETURN;
       IF DEL<%LPAR THEN RETURN;
       IF XCARD(CURRCH-1)~=',' OR DEL~=%BLANK THEN ALTRETURN;
       CARD_COUNT=CARD_COUNT + 1 ;
       CALL READCARD(%T);
       GOTO S10;
END NEXTFLD;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* OUTPUT OCTAL TO LINE */
/**/
OCTAL: PROC (VAL,S,L);
DCL 1 VAL ALIGNED,
      2 O(0:11) UBIN(3) UNAL;
DCL S(0:0) CHAR(1);
DCL L SBIN;
/**/
DCL I SBIN;
/**/
       DO I=0 TO L-1;
           S(I)=BINASC(ASCBIN('0')+VAL.O(12-L+I));
       END;
       RETURN;
END OCTAL;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* PRINT OBJECT OUTPUT ERROR
*/
OUERR: PROC (ERRCODE,DCBN,SEV);
DCL ERRCODE UBIN;                      /* ERROR CODE */
DCL DCBN SBIN;                         /* DCB # */
DCL SEV SBIN;                          /* SEVERITY LEVEL */
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE BMAP_C;
DCL M$DO DCB;
DCL M$LO DCB;
DCL M$OU DCB;
%BMAP_COMMON;
%FPT_ERRMSG(BUF=ERRBUF,CODE=ERRCODE1,RESULTS=VLR_ERRMSG);
%VLR_ERRMSG;
DCL DOLO SBIN SYMREF;
DCL ERRBUF CHAR(120) STATIC;           /* BUFFER FOR M$ERRMSG */
DCL ERRCODE1 UBIN STATIC;
/**/
       ERRCODE1=ERRCODE;
       IF ADDR(DCBN)~=ADDR(NIL) THEN FPT_ERRMSG.V.DCB#=DCBN;
         ELSE FPT_ERRMSG.V.DCB#=DCBNUM(M$OU);
       IF DOLO<0 THEN FPT_ERRMSG.V.OUTDCB1#=DCBNUM(M$DO);
         ELSE FPT_ERRMSG.V.OUTDCB1#=DCBNUM(M$LO);
       IF DOLO~=0 THEN FPT_ERRMSG.V.OUTDCB2#=DCBNUM(NIL);
         ELSE FPT_ERRMSG.V.OUTDCB2#=DCBNUM(M$DO);
       CALL M$ERRMSG(FPT_ERRMSG);
       TERRCT=TERRCT+1;
       IF ADDR(SEV)=ADDR(NIL) THEN ERRSEV=15;
         ELSE IF ERRSEV<SEV THEN ERRSEV=SEV;
       RETURN;
END OUERR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* PACK KEY FOR CROSS-REFERENCE TABLE
*/
PACKEY: PROC (V);
DCL 1 V ALIGNED,                       /* PACKED VALUE */
      2 D(0:8) UBIN(4) UNAL;
/**/
%INCLUDE BMAP_C;
/**/
%BMAP_COMMON;
DCL I SBIN;
DCL J SBIN;
DCL TABLE(0:57) SBIN CONSTANT INIT(0*46,1,0,2,3,4,5,6,7,8,9,10,11);
/**/
       IF SUBSTR(KEY,5,1)='.' THEN I=0;
         ELSE I=4;
       V='0'B;
       DO J=I TO 8;
           V.D(J-I)=TABLE(ASCBIN(SUBSTR(KEY,J,1)));
       END;
       RETURN;
END PACKEY;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* PRINT LINE
*/
PRINT: PROC;
/**/
%INCLUDE BMAP_C;
/**/
DCL EJECT ENTRY (3);
DCL LIST ENTRY (3);
/**/
%BMAP_COMMON;
DCL CARDLVL SBIN;
DCL CF BIT(1);
DCL DIAG BIT(1) ALIGNED;
DCL E SBIN;
DCL I SBIN;
DCL J SBIN;
DCL MNP BIT(1);
DCL ERRMSG(0:21) CHAR(24) CONSTANT ALIGNED INIT(' ',
       'UNCLOSED DUP, IDRP OR IF',     /*  1 */
       'INVALID OPERATION       ',     /*  2 */
       'INVALID INDEX           ',     /*  3 */
       'INVALID ADDRESS         ',     /*  4 */
       'RELOCATION              ',     /*  5 */
       'UNDEFINED SYMBOL        ',     /*  6 */
       'INVALID LOCATION        ',     /*  7 */
       'INVALID LITERAL         ',     /*  8 */
       'INVALID CONSTANT        ',     /*  9 */
       'MULTIPLY-DEFINED SYMBOL ',     /* 10 */
       'MACRO TABLE FULL        ',     /* 11 */
       'SYMBOL TABLE FULL       ',     /* 12 */
       'MULTIPLY-DEFINED OP-CODE',     /* 13 */
       'MISSING FIELD           ',     /* 14 */
       'ONLY 1ST OUNAME ACCEPTED',     /* 15 */
       'INVALID OUNAME OPERAND  ',     /* 16 */
       'MACRO LIBRARY NOT FOUND ',     /* 17 */
       'LODM SYNTAX ERROR       ',     /* 18 */
       'LINE > 256 CHARACTERS   ',     /* 19 */
       '2 PASS INPUT UNBALANCED ',     /* 20 */
       'INVALID EXPRESSION      ');    /* 21 */
/**/
       DIAG=(ERRCT~=0);
       IF PASS2=0 THEN DO;
               DO I=0 TO ERRCT-1;
                   IF ERRNUM(I)<0 THEN GOTO P1ERR;
               END;
               DIAG=%F;
           END/* IF PASS2=0 */;
P1ERR:
       IF NOT DIAG THEN DO;
               IF PASS2=0 OR PASS2<0 AND LODMF THEN GOTO S80;
               IF MLVL>1 AND PMC THEN CARDLVL=1;
                 ELSE CARDLVL=0;
               MNP=MLVL>1&~PMC;
               IF MNP AND OP.TYPE=13 AND BINBIT(OP.VAL,SIZEB(OP.VAL))&'01'B THEN LINEF.CODE=%F; /* SET IN MACRO W/O PMC */
               CF=~CARDPR(CARDLVL);
               IF NOT LINEF AND (NOT CF OR MNP) THEN GOTO S80;
               IF MNP AND NOT LINEF.CODE THEN GOTO S80;
               IF NOT LISTF OR (NOT CF AND NOT DETAIL) THEN GOTO NOPRINT;
           END/* IF NOT DIAG */;
         ELSE DO;
               IF MLVL>1 THEN CARDLVL=1;
                 ELSE CARDLVL=0;
               CF=~CARDPR(CARDLVL);
           END/* IF NOT DIAG ELSE */;
       IF CF THEN
           IF CARDLVL=0 THEN DO;
                   IF LINECT>43 THEN LINECT=43;
                   IF LINECT<33 THEN LINECT=33;
                   CALL INSERT(LINES,LINECT-1,44-LINECT,' ',SUBSTR(KEY,LINECT-33));
                   LINECT=44+CARDL;
               END;
             ELSE DO;
                   CALL INSERT(LINES,43,,' ',XCARDS);
                   LINECT=44+XCARDL;
               END;
       GOTO PRINT1;
/*
/* ENTER HERE TO PRINT ONLY OCTAL INFORMATION
*/
PRINTO: ENTRY;
       IF NOT DETAIL THEN GOTO S80;
       CF=%F;
       DIAG=%F;
PRINT1:
       IF LINECT~=0 THEN DO;
               IF LINECT>128 THEN LINECT=128;
               IF NOT PCCF AND NOT DIAG AND NOT MACSV THEN DO CASE(OP.TYPE);
                    CASE(0);
                       IF OP.RPL THEN GOTO NOPRINT; /* LBL, MARK */
                    CASE(8,22,37);     /* TTL(S); IFE, ETC.; IDRP */
                       GOTO NOPRINT;
                    CASE(39);
                       DO CASE(OP.VAL);
                        CASE(0,1,2,4,7,8); /* DETAIL, LIST, PMC, CRSM, REF, REFMA */
                           GOTO NOPRINT;
                       END;
                   END/* IF NOT PCCF */;
               IF NOT TITLEF THEN DO; CALL EJECT(' ',1,%T); TITLEF=%T; END;
               CALL LIST(LINE,LINECT,DIAG);
               IF SUBSTR(LINES,1,1)~=' ' THEN OLDREL=PCREL;
NOPRINT:
               IF CF THEN CARDPR(CARDLVL)=%T;
           END/* IF LINECT */;
       IF DIAG THEN DO;
               DO I=0 TO ERRCT-1;
                   IF PASS2~=0 OR ERRNUM(I)<0 THEN DO;
                           E=ERRNUM(I);
                           IF E<0 THEN E=-E;
                           CALL INSERT(LINES,,,' **** ERROR @ ',SUBSTR(KEY,0,9),' ',ERRMSG(E));
                           IF NOT TITLEF THEN DO; CALL EJECT(' ',1,%T); TITLEF=%T; END;
                           CALL LIST(LINE,48,%T);
                       END/* IF PASS2 */;
               END/* DO I */;
               ERRCT=0;
           END/* IF DIAG */;
S80:
       LINE.OCTAL=' ';
       LINECT=0;
       LINEF='0'B;
       RETURN;
END PRINT;
%EOD;
/*M* BMAP READ ROUTINE */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
READ:  PROC(BUFFER,KEYPAR,ARS) ALTRET;
DCL BUFFER CHAR(140);                  /* Card input buffer */
DCL 1 NAME REDEF BUFFER,               /* File name for LODM */
      2 LEN UBIN(9) UNAL,
      2 TEXT CHAR(139);
DCL KEYPAR CHAR(10);                   /* Key for this input record */
DCL ACCT REDEF KEYPAR CHAR(10);        /* Account name for LODM */
DCL ARS UBIN;                          /* Actual record size (characters) */
/**/
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6_C;
%CP6$ENTS;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%INCLUDE BMAP_C;
/**/
DCL M$SI DCB;
DCL M$SO DCB;
DCL M$UI DCB;
DCL M$LO DCB;
%XUU$ENTRY;
DCL EJECTLU ENTRY(3);
DCL LIST ENTRY (3);
DCL OUERR ENTRY (3);
/**/
%BMAP_COMMON;
DCL DCBN SBIN;
DCL EOF BIT(36) STATIC ALIGNED INIT('0'B);
%F$DCB;
%FPT_EXIT(STEPCC=4);
%FPT_OPEN;
DCL I SBIN;
DCL SEV SBIN;
%VLP_ACCT(FPTN=SYS_ACCT,STCLASS=CONSTANT,ACCT=':SYS');
%XUU_PARAM(FPTN=XUU);
/**/
       IF EOF THEN DO;
               CALL OUERR(EOF,DCBNUM(M$SI));
               CALL M$EXIT(FPT_EXIT);
           END;
       IF NOT DCBADDR(DCBNUM(M$SI))->F$DCB.FCD# THEN DO;
               XUU.FLAGS='0'B;
               XUU.FLAGS.BASE#=%T;
               XUU.FLAGS.UP_DATE#=OPTIONS.UI;
               IF OPTIONS.UI THEN
                   XUU.FLAGS.OPT_UI#='1'B;
               IF OPTIONS.LU THEN IF PASS2=0 THEN XUU.FLAGS.LU_WHILE#=%T;
                     ELSE IF PASS2<0 THEN XUU.FLAGS.LU_FIRST#=%T;
               XUU.DCB#=DCBNUM(M$LO);
               IF XUU.FLAGS.LU_WHILE# OR XUU.FLAGS.LU_FIRST#
                 THEN CALL EJECTLU('UPDATES',7,%T);
               CALL XUU$OPEN(XUU) ALTRET(NOFILE);
               DO WHILE (%F);
NOFILE:                                /* OPEN ERROR ON INPUT */
                   IF XUU.FLAGS.BASE# THEN DO;
                           CALL OUERR(XUU.SI_ERRCODE,DCBNUM(M$SI));
                           CALL M$EXIT(FPT_EXIT);
                       END;
                     ELSE DO;
                           CALL OUERR(XUU.UI_ERRCODE,DCBNUM(M$UI));
                           OPTIONS.UI=%F;
                       END;
               END/* WHILE %F */;
           END;
       XUU.FLAGS='0'B;
       XUU.FLAGS.BLANK_FILL#=%T;
       XUU.FLAGS.SOURCE_OUT#=OPTIONS.SO;
       CALL XUU$READ(XUU,VECTOR(BUFFER)) ALTRET (ENDFILE);
       ARS=XUU.ARS;
       LODMF=XUU.FLAGS.INCLUDE#;
       IF NOT LODMF THEN KEYPAR=XUU.ASCII_KEY;
       RECORDCT=RECORDCT+1;
       RETURN;
/**/
ENDFILE:
       IF XUU.ERRCODE.ERR#~=%E$EOF THEN DO;
               IF XUU.FLAGS.SO_ERR# THEN SEV=4;
                 ELSE SEV=11;
               DCBN=XUU.DCB#;
               CALL OUERR(XUU.ERRCODE,DCBN,SEV);
           END/* IF XUU.ERRCODE.ERR# */;
       LODMF=%F;
       BUFFER='       END               ***END OF FILE***';
       KEYPAR='99999.999';
       ARS=SIZEC('       END               ***END OF FILE***');
       EOF=XUU.ERRCODE;
       RETURN;
%EJECT;
/* CLOSE SOURCE FILES
*/
CLOSE: ENTRY ALTRET;
       XUU.FLAGS='0'B;
       XUU.FLAGS.CLOSE_ALL#=%T;
       CALL XUU$CLOSE(XUU);
       EOF='0'B;
       RETURN;
%EJECT;
/* GET MACRO LIBRARY NAMES
*/
LODM:  ENTRY (BUFFER,KEYPAR) ALTRET;
       XUU.FLAGS='0'B;
       XUU.FLAGS.INCLUDE#=%T;
       XUU.O.FPT_PTR$=ADDR(FPT_OPEN);
       FPT_OPEN.NAME_=VECTOR(SUBSTR(BUFFER,0,NAME.LEN+1));
       IF SUBSTR(ACCT,0,8)~=' ' THEN
           FPT_OPEN.ACCT_=VECTOR(SUBSTR(ACCT,0,8));
         ELSE DO;
               DO I=0 TO OPTIONS.NACS-1;
                   FPT_OPEN.ACCT_=VECTOR(FID_SAVE.ACCT_(I));
                   IF FID_SAVE.F.PASS(I) THEN FPT_OPEN.PASS_=VECTOR(FID_SAVE.PASS_(I));
                     ELSE FPT_OPEN.PASS_=VECTOR(NIL);
                   IF FID_SAVE.F.SN(I) THEN FPT_OPEN.SN_=VECTOR(FID_SAVE.SN_(I));
                     ELSE FPT_OPEN.SN_=VECTOR(NIL);
                   IF FID_SAVE.F.WSN(I) THEN FPT_OPEN.WSN_=VECTOR(FID_SAVE.WSN_(I));
                     ELSE FPT_OPEN.WSN_=VECTOR(NIL);
                   FPT_OPEN.V.ASN#=FID_SAVE.ASN#(I);
                   IF FID_SAVE.F.RES(I) THEN FPT_OPEN.V.RES#=FID_SAVE.RES#(I);
                     ELSE FPT_OPEN.V.RES#=BINASC(0);
                   CALL XUU$OPEN(XUU) ALTRET(NEXT);
                   RETURN;
/**/
NEXT:
               END;
               FPT_OPEN.ACCT_=VECTOR(NIL);
               CALL LODMOPEN ALTRET(NOTUSER);
               RETURN;
/**/
NOTUSER:
               FPT_OPEN.ACCT_=VECTOR(SYS_ACCT);
           END/* IF ACCT ELSE */;
       CALL LODMOPEN ALTRET(NOTFOUND);
       RETURN;
/**/
NOTFOUND:
       ALTRETURN;
%EJECT;
/* ATTEMPT TO OPEN LODM FILE
*/
LODMOPEN: PROC ALTRET;
       FPT_OPEN.PASS_=VECTOR(NIL);
       FPT_OPEN.SN_=VECTOR(NIL);
       FPT_OPEN.WSN_=VECTOR(NIL);
       FPT_OPEN.V.ASN#=%FILE#;
       FPT_OPEN.V.RES#=BINASC(0);
       CALL XUU$OPEN(XUU) ALTRET(NOTFOUND);
       RETURN;
/**/
NOTFOUND:
       ALTRETURN;
END LODMOPEN;
END READ;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* READ CARD
*/
READCARD: PROC (CONT);
DCL CONT BIT(1) ALIGNED;
/**/
%INCLUDE BMAP_C;
DCL MRL ENTRY (6) ALTRET;
DCL XLATEV ENTRY (7) ALTRET;
DCL READ ENTRY (3) ALTRET;
DCL ERROR ENTRY (1);
DCL GETMAC ENTRY (1) ALTRET;
DCL PRINT ENTRY;
DCL TEST ENTRY (5);
DCL TREESRCH ENTRY (6);
/**/
%BMAP_COMMON;
DCL C SBIN;
DCL DIFF SBIN;
DCL I SBIN;
DCL J SBIN;
DCL JD SBIN;
DCL JL SBIN;
DCL JN SBIN;
DCL K SBIN;
DCL LOCSZ SBIN;
DCL LOP SBIN;
DCL M SBIN;
%MAP(STCLASS="BASED(MAP$)");
DCL MAP$ PTR;
DCL MC SBIN;
DCL MC$ PTR;
DCL NC SBIN;
DCL OPCODE(0:5) SBIN;
DCL SW SBIN;
DCL TCARDS CHAR(140) STATIC ALIGNED;
DCL TCARDL SBIN STATIC;
DCL TCURRCH SBIN STATIC;
DCL TKEY CHAR(10) STATIC;
DCL TLOCSZ SBIN STATIC;
DCL TNEXTCH SBIN STATIC;
DCL TOP SBIN STATIC;
/**/
S10:
       IF MAC.CARDF AND MLVL=1 THEN DO;
               KEY=TKEY;
               CARDL=TCARDL;
               LINE.CARD=TCARDS;
               CARDPR(0)=%F; MAC.CARDF=%F;
               IF SUBSTR(LINE.CARD,0,1)~='*' AND SUBSTR(LINE.CARD,0,16)~=' ' THEN DO;
                       XCARDL=CARDL;
                       XCARDS=SUBSTR(LINE.CARD,0,CARDL);
                       IOP=TOP;
                       LOCSZ=TLOCSZ;
                       CURRCH=TCURRCH;
                       NEXTCH=TNEXTCH;
                       GOTO S50;
                   END;
S20:
               OP$=ADDR(SPOOL(%NONOP));
S21:
               CALL PRINT;
           END/* IF MAC.CARDF */;
       IF MAC.DUP THEN DO;
               IF MAC.DUPIC<=0 THEN DO;
                       IF MAC.DUPNR<=0 THEN DO; MAC.DUP=%F; MCX=MAC.DUPFC-1; GOTO S40; END;
                       MAC.DUPNR=MAC.DUPNR-1;
                       MAC.DUPIC=MAC.DUPNC;
                       MAC.DUPX=MAC.DUPFC;
                   END/* IF MAC.DUPIC */;
               MC$=ADDR(MPOOL(MAC.DUPX));
               XCARDL=MC$->MAP.LEN; XCARDS=MC$->MAP.TEXT;
               MAC.DUPIC=MAC.DUPIC-1;
               MAC.DUPX=MAC.DUPX+(XCARDL+4)/4;
           END/* IF MAC.DUP */;
         ELSE DO;
S40:
               IF MLVL~=1 THEN GOTO S100;
               IF CONT THEN GOTO S80;
               CALL READ(LINE.CARD,KEY,CARDL);
               CARDPR(0)=%F;
               IF SUBSTR(LINE.CARD,0,1)='*' OR SUBSTR(LINE.CARD,0,16)=' ' THEN GOTO S20;
               XCARDL=CARDL;
               XCARDS=SUBSTR(LINE.CARD,0,CARDL);
           END/* IF MAC.DUP ELSE */;
S45:
       CALL SCANOP;
       IOP=LOP;
S50:
       IF IOP<=0 THEN DO; IOP=%NONOP;
               IF MAC.SKIP(0)=0 AND NOT MACSV THEN CALL ERROR(2);
           END;
       OP$=ADDR(SPOOL(IOP));
       IF NOT MACSV THEN DO;
               IF LOCSZ~=0 THEN
                   %CONSYM(#FC=0,#L=LOCSZ,#SYM=LOC);
                 ELSE LOC(0)=0;
               IF IOP=%REM THEN
                   IF MLVL=1 THEN CALL INSERT(LINE.CARD,CURRCH,NEXTCH-CURRCH,' ');
                     ELSE CALL INSERT(XCARDS,CURRCH,NEXTCH-CURRCH,' ');
S51:
               IF MAC.DUPSV THEN DO;
                       IF LOCSZ~=0 AND IOP~=%SET AND IOP~=%SETB THEN DO;
                               I=LOCSZ;
                               J=XCARDL-LOCSZ;
                           END;
                         ELSE DO;
                               I=0;
                               J=XCARDL;
                           END;
                       K=(J+4)/4;
                       CALL GETMAC(K) ALTRET(S57);
                       MC$=ADDR(MPOOL(MCX));
                       MC$->MAP.LEN=J;
                       MC$->MAP.TEXT=SUBSTR(XCARDS,I,J);
                       MCX=MCX+K-1;
S57:
                       MAC.DUPIC=MAC.DUPIC-1;
                       IF MAC.DUPIC<=0 THEN DO; MAC.DUPSV=%F; MAC.DUP=%T; END;
                   END/* IF MAC.DUPSV */;
               DEL=0;
               IF IOP=%TTL OR IOP=%TTLS THEN
                   IF CURRCH=7 AND NEXTCH<=13 THEN CURRCH=14;
                     ELSE CURRCH=NEXTCH;
                 ELSE DO;
                       CALL SEARCH(CURRCH,J,NONBLK,SUBSTR(XCARDS,1,NEXTCH+14),NEXTCH) ALTRET(VARNOTFOUND);
                       DO WHILE(%F);
VARNOTFOUND:
                           CURRCH=NEXTCH;
                           DEL=%BLANK;
                       END;
                   END/* IF IOP=%TTL ELSE */;
               IF IOP=%ENDOP THEN MAC.SKIP(0)=0;
               IF MAC.SKIP(0)=0 THEN RETURN;
               IF MAC.SKIP(0)<0 THEN DO; MAC.SKIP(0)=MAC.SKIP(0)+1; GOTO SKIPCARD; END;
               CALL TEST(LOC(1),LOC(0),MAC.SKIP(1),MAC.SKIP(0),SW);
               IF SW~=0 THEN GOTO SKIPCARD;
               MAC.SKIP(0)=0;
           END/* IF NOT MACSV */;
       RETURN;
/**/
SKIPCARD:
       IF IOP=%IDRP AND MAC.IDRPP~=0 THEN DO;
               MCX=MAC.IDRPP-1;
               MAC.IDRPP=0;
           END;
       OP$=ADDR(SPOOL(%MARK));
       GOTO S21;
/**/
S80:
       CALL READ(TCARDS,TKEY,TCARDL);
       IF SUBSTR(TCARDS,0,1)='*' OR SUBSTR(TCARDS,0,16)=' ' THEN GOTO S88;
       XCARDL=TCARDL;
       XCARDS=SUBSTR(TCARDS,0,TCARDL);
       CALL SCANOP;
       IF LOP~=%ETC THEN GOTO S88;
       CALL PRINT;
       LINE.CARD=TCARDS;
       CARDL=TCARDL;
       KEY=TKEY;
       CARDPR(BITBIN(MLVL>1&PMC))=%F;
       LOC(0)=0;
       GOTO S51;
/**/
S88:
       TCURRCH=CURRCH;
       TLOCSZ=LOCSZ;
       TNEXTCH=NEXTCH;
       TOP=LOP;
S89:
       MAC.CARDF=%T;
       RETURN;
%EJECT;
/* MACRO EXPANSION
*/
S100:
       MAC.CARDF=%F;
       IF MAC.RMCT=0 THEN GOTO S190;
       IF CONT AND NOT CARDPR(1) THEN CALL PRINT;
       CARDPR(1)=CONT;
       MC$=ADDR(MPOOL(MAC.RMCX));
       XCARDL=MC$->MAP.LEN; XCARDS=MC$->MAP.TEXT;
       C=0;
       DO WHILE (C<XCARDL);
           CALL INDEX1(C,'#',XCARDS,C) ALTRET(S180);
           CALL SEARCH(J,K,NONDGT,XCARDS,C+1);
           K=J-C;
           IF K>1 THEN CALL CHARBIN(M,SUBSTR(XCARDS,C+1,K-1));
             ELSE M=0;
           IF M=0 THEN C=J;
             ELSE DO;
                   IF M>MPOOL(MAC.MPAR) THEN
                       IF CRSM THEN DO;
                               CALL FINDPARAM(MPOOL(MAC.MPAR)+1);
                               CALL MAKESPACE(M-MPOOL(MAC.MPAR)+1) ALTRET(NOSPACE);
                               DO I=MPOOL(MAC.MPAR)+1 TO M-1;
                                   MAP.LEN=1;
                                   MAP.TEXT='#';
                                   MAP$=PINCRW(MAP$,1);
                               END;
                               CALL CREATESYMBOL;
                               MPOOL(MAC.MPAR)=M;
                               IF MAC.IDRPP=0 THEN MAC.IDRPN=M;
                               GOTO INSERTPARAM;
                           END/* IF CRSM */;
                         ELSE
NOSPACE:
                           DIFF=-K;
                     ELSE DO;
                           IF MAC.IDRPP=0 THEN DO; MAC.IDRPN=M; GOTO S130; END;
                           IF M=MAC.IDRPN THEN
                               MAP$=ADDR(MPOOL(MAC.IDRPX));
                             ELSE DO;
S130:
                                   CALL FINDPARAM(M);
                                   IF MAP.LEN=1 AND MAP.TEXT='#' AND CRSM THEN DO;
                                           CALL MAKESPACE(1) ALTRET(NOSPACE1);
                                           CALL CREATESYMBOL;
NOSPACE1:
                                       END;
                               END/* IF M=MAC.IDRPN ELSE */;
INSERTPARAM:
                           DIFF=MAP.LEN-K;
                       END/* IF M>MPOOL(MAC.MPAR) */;
                   JD=J+DIFF;
                   IF DIFF<0 THEN DO;
                           XCARDL=XCARDL+DIFF;
                           CALL INSERT(XCARDS,JD,,SUBSTR(XCARDS,J));
                           IF JD>C THEN CALL INSERT(XCARDS,C,JD-C,MAP.TEXT);
                       END;
                     ELSE DO;
                           IF DIFF>0 THEN DO;
                                   JL=XCARDL-J;
                                   IF JD+JL>SIZEC(XCARDS) THEN JL=SIZEC(XCARDS)-JD;
                                   XCARDL=XCARDL+DIFF;
                                   IF JL>0 THEN CALL MRL(XCARDS,JD,JL,XCARDS,J,JL);
                               END/* ELSE IF DIFF>0 */;
                           CALL INSERT(XCARDS,C,JD-C,MAP.TEXT);
                       END/* IF DIFF<0 ELSE */;
                   C=JD;
               END/* IF M=0 ELSE */;
       END/* WHILE C */;
S180:
       IF CONT THEN DO;
               CALL SCANOP;
               IF LOP~=%ETC THEN GOTO S89;
           END;
       CARDPR(1)=%F;
       MAC.RMCX=MAC.RMCX+(MC$->MAP.LEN+4)/4;
       MAC.RMCT=MAC.RMCT-1;
       IF CONT THEN GOTO S51;
       GOTO S45;
/**/
S190:
       IF CONT THEN GOTO S89;
       IF MAC.DUP OR MAC.DUPSV OR MAC.IDRPP~=0 OR
         MAC.SKIP(0)~=0 THEN CALL ERROR(1);
       MCX=MLVL-1;
       MLVL=MAC.LINK;
       MAC$=ADDR(MPOOL(MLVL));
       IF NOT CARDPR(BITBIN(MLVL>1&PMC))
         OR ERRCT~=0 THEN CALL PRINT;
       GOTO S10;
%EJECT;
/* CREATE SYMBOL
*/
CREATESYMBOL: PROC;
       MAP.LEN=6;
       MAP.TEXT='_0000_';
       CALL BINCHAR(SUBSTR(MAP.TEXT,1,4),CRSMNO);
       CRSMNO=CRSMNO+1;
       RETURN;
END CREATESYMBOL;
/*
/* FIND MACRO PARAMETER
/* RETURN MAP$->PARAMETER
*/
FINDPARAM: PROC (PARAMNO);
DCL PARAMNO SBIN;                      /* PARAMETER # TO FIND */
DCL I SBIN;
/**/
       MAP$=ADDR(MPOOL(MAC.MPAR+1));
       I=PARAMNO;
       DO WHILE (I>=2);
           MAP$=PINCRW(MAP$,(MAP.LEN+4)/4);
           I=I-1;
       END;
       RETURN;
END FINDPARAM;
%EJECT;
/* MAKE SPACE IN MACRO PARAMETER LIST
*/
MAKESPACE: PROC (NW) ALTRET;
DCL NW SBIN;                           /* # WORDS TO MAKE SPACE FOR */
DCL I SBIN;
/**/
       CALL GETMAC(NW) ALTRET(NOSPACE);
       I=(MCX-POFFW(MAP$,ADDR(MPOOL)))*4;
       IF I~=0 THEN DO;
               CALL MRL(MAP,NW*4,I,MAP,0,I);
               IF MAC.DUP OR MAC.DUPSV THEN DO;
                       MAC.DUPFC=MAC.DUPFC+NW;
                       MAC.DUPX=MAC.DUPX+NW;
                   END;
               IF MAC.IDRPP~=0 THEN DO;
                       MAC.IDRPP=MAC.IDRPP+NW;
                       MAC.IDRPX=MAC.IDRPX+NW;
                   END;
           END/* IF I */;
       MCX=MCX+NW-1;
       RETURN;
/**/
NOSPACE: ALTRETURN;
END MAKESPACE;
%EJECT;
/* SCAN LOCATION AND OPERATION FIELDS
/*
/* RETURN:
/*     LOP = Index in SPOOL to op-code
/*     LOCSZ = Size of location field
/*     CURRCH = Index to beginning of operation field
/*     NEXTCH = Index to end of operation field + 1
*/
SCANOP: PROC;
       LOP=0;
       OPCODE(0)=0;
       CALL INDEX1(LOCSZ,' ',XCARDS) ALTRET(EOL1);
       CALL SEARCH(CURRCH,J,NONBLK,SUBSTR(XCARDS,0,LOCSZ+15),LOCSZ) ALTRET(EOL2);
       CALL INDEX1(NEXTCH,' ',XCARDS,CURRCH);
       %CONSYM(#SYM=OPCODE);
       CALL TREESRCH(OPROOT,OPCODE(1),OPCODE(0),SIZEW(OP),%F,LOP);
       RETURN;
/**/
EOL1:
       CURRCH=LOCSZ;
EOL2:
       NEXTCH=LOCSZ;
       LOP=%NONOP;
       RETURN;
END SCANOP;
END READCARD;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SYMBOL TABLE SEARCH/ENTER
*/
SYMTAB: PROC (NAME,VAL,REL,DEF,SSRF);
DCL NAME(0:5) SBIN;                    /* Symbol name (internal 6-bit code) */
DCL VAL SBIN;                          /* Symbol value */
%INCLUDE BMAP_C;
%REL;                                  /* Relocation words */
DCL DEF BIT(1) ALIGNED;                /* This is a definition of the symbol */
DCL SSRF BIT(1) ALIGNED;          /* This is a secondary ref of the symbol */
/**/
%INCLUDE B$OBJECT_C;
%INCLUDE XUO$OBJ_C;
/**/
DCL ANSYM ENTRY (4);
DCL BITINSERT ENTRY (6) ALTRET;
DCL GEN ENTRY (4);
DCL ERROR ENTRY (1);
DCL GETSYM ENTRY (1) ALTRET;
DCL KEYVAL ENTRY (1);
DCL PACKEY ENTRY (1);
DCL PRINTO ENTRY;
DCL TREESRCH ENTRY (6);
DCL TREESTEP ENTRY (2);
%INCLUDE XUO$ENTRIES;
/**/
%B$RELOCSUBS;
%B$SECTION(STCLASS="BASED(B$SECTION$)");
DCL B$SECTION$ PTR;
%B$SECTIONSUBS;
%BMAP_COMMON;
%B_SECTION_POINTERS;
DCL FB SBIN;
DCL FRF BIT(1);
DCL I SBIN;
DCL I$ PTR;
DCL J SBIN;
DCL JU REDEF J UBIN;
DCL J$ PTR;
DCL K SBIN;
DCL K$ PTR;
DCL L SBIN;
%LIT(STCLASS="BASED(FR$)");
DCL LVL UBIN;
DCL 1 NAMEO ALIGNED,
      2 LEN UBIN(18) UNAL,
      2 TEXT CHAR(30);
DCL NAMES CHAR(30) ALIGNED;
DCL NB SBIN;
DCL R UBIN;
%REL(NAME="RL(0:36)");
DCL S SBIN;
DCL SAVPC SBIN;
DCL SAVPCREL SBIN;
%SYM;                                  /* Symbol table packet */
DCL TREF$ PTR;
%REL(NAME=TREL);
DCL 1 UREL STATIC, /* Temporary Relocation Field for updating SYMTAB entries */
      2 W1 BIT(36),
      2 W2 SBIN INIT(35),
      2 S BIT(36);
DCL V(0:36) UBIN;
DCL W(0:36) UBIN;
/**/
       CALL TREESRCH(SYMROOT,NAME(1),NAME(0),SIZEW(SYM),%T,S);
       IF S>0 THEN DO;
               SYM$=ADDR(SPOOL(S));
               GOTO S30;
           END;
       IF S=0 THEN RETURN;
       S=-S;
       SYM$=ADDR(SPOOL(S));
S19:
       SYM.VAL=0;
       SYM.R=%UNDEF;
       SYM.R.OPERAND=S;
S20:
       IF DEF THEN DO;
               SYM.VAL=VAL;
               REL.F=REL.F|SYM.R.F&'17'O; /* EDEF, SDEF, DEFED, REFED */
               SYM.R=REL;
           END;
         ELSE DO;
               VAL=SYM.VAL;
               IF NOT REL.F&%XDEF THEN SYM.R.F.REFED=%T;
                 ELSE SYM.R.F=SYM.R.F|REL.F&%XDEF;
           END;
       IF SYM.R.OPNDTYP~=%OPERUNDEF AND NOT SYM.R.F.SET AND SYM.R.RELOCOP<=%RELOCOPADD AND SYM.R.EVALOP=0 AND NOT SYM.R.S THEN DO;
               IF NOT SYM.R.F.DEFED THEN DO;
                       IF SYM.R.OPNDTYP>%OPERSECT AND NOT SYM.R.F.EQU THEN DO;
                               CALL ANSYM(NAME(1),NAME(0),NAMES,I);
                               %OBJSYM(#S="SUBSTR(NAMES,0,I)",#SYM=NAMEO);
                               CALL XUO$RNAME(NAMEO,I);
                               FRF=%F;
                               IF ADDR(SSRF)~=ADDR(NIL) THEN
                                   FRF = SSRF ;
                               DO CASE (SYM.R.OPNDTYP);
                                CASE(%OPEREREF);
                                   CALL XUO$EREF(I,FRF,%F,%F,1,0,J);
                                CASE(%OPERSREF);
                                   CALL XUO$SREF(I,FRF,J);
                                CASE(%OPERSEGREF);
                                   CALL XUO$SEGREF(I,J,,FRF);
                               END/* CASE SYM.R.OPNDTYP */;
                               SYM.R.OPERAND=J;
                               SYM.R.F.DEFED=%T;
                           END/* IF SYM.R.OPNDTYP */;
                       IF SYM.R.F.EDEF THEN
                           IF SYM.R.OPNDTYP=%OPERSECT THEN DO;
                                   IF PRIMENT=0 THEN PRIMENT=S;
                                   CALL ANSYM(NAME(1),NAME(0),NAMES,I);
                                   %OBJSYM(#S="SUBSTR(NAMES,0,I)",#SYM=NAMEO);
                                   CALL XUO$DNAME(NAMEO,I);
                                   CALL XUO$EDEF(BINBIT(SYM.R.OPERAND,36),SYM.VAL,I,S=PRIMENT,%F,%F,1,0);
                                   SYM.R.F.DEFED=%T;
                               END;
                             ELSE CALL ERROR(5);
                       IF SYM.R.F.SDEF THEN DO;
                               CALL ANSYM(NAME(1),NAME(0),NAMES,I);
                               %OBJSYM(#S="SUBSTR(NAMES,0,I)",#SYM=NAMEO);
                               CALL XUO$DNAME(NAMEO,I);
                               IF SYM.R.OPNDTYP=0 THEN CALL XUO$SDEF_CONST(I,SYM.VAL);
                                 ELSE IF SYM.R.OPNDTYP=%OPERSECT THEN CALL XUO$SDEF(I,BINBIT(SYM.R.OPERAND,36),SYM.VAL);
                                     ELSE CALL ERROR(5);
                               SYM.R.F.DEFED=%T;
                           END;
                   END/* IF NOT SYM.R.F.DEFED */;
               IF DEF THEN DO;
                       J=SYM.R.OPERAND;
                       IF SYM.R.OPNDTYP=%OPERSECT THEN DO;
                               B$SECTION$=PINCRW(B_SECTION_BASE$,J*SIZEW(B$SECTION));
                               IF B$SECTION.TYPE=%CODESECTION THEN DO;
                                       CALL ANSYM(NAME(1),NAME(0),NAMES,I);
                                       %OBJSYM(#S="SUBSTR(NAMES,0,I)",#SYM=NAMEO);
                                       CALL XUO$DBGNAME(NAMEO,I);
                                       CALL KEYVAL(K);
                                       CALL XUO$EXST(J,SYM.VAL,I,LOGBLK,%F,1,K);
                                   END;
                           END/* IF SYM.R.OPNDTYP=%OPERSECT */;
                   END/* IF DEF */;
           END/* IF SYM.R.OPNDTYP~=%OPERUNDEF */;
       IF DEF THEN DO;
               I$=SYM$;
               DO WHILE(I$->SYM.UREF~=0);
                   I$=ADDR(SPOOL(I$->SYM.UREF));
                   UREL.W1=I$->SYM.R;
                   UREL.S=I$->SYM.R.S;
                   CALL UFR(I$->SYM.VAL,UREL);
                   I$->SYM.R=UREL.W1;
                   I$->SYM.R.S=UREL.S;
               END;
               L=SYM.FRROOT;
               IF L~=0 THEN DO;
                       FR$=ADDR(SPOOL(L));
NEXTFR:
                       L=FR.LINK;
NEXTFR1:
                       FR$=ADDR(SPOOL(L));
                       FRF=%F;
                       DO J=0 TO FR.LEN-1;
                           CALL UFR(FR.V,FR.R(J));
                       END/* DO J */;
                       IF FRF THEN
                           DO J=0 TO FR.LEN-1;
                               IF FR.R.OPNDTYP(J)=%OPERUNDEF THEN DO;
                                       I$=ADDR(SPOOL(FR.R.OPERAND(J)));
LINKFR:
                                       I=FR.LINK;
                                       IF I$->SYM.FRROOT=0 THEN
                                           FR.LINK=L;
                                         ELSE DO;
                                               J$=ADDR(SPOOL(I$->SYM.FRROOT));
                                               FR.LINK=J$->FR.LINK;
                                               J$->FR.LINK=L;
                                           END;
                                       I$->SYM.FRROOT=L;
                                       IF L~=SYM.FRROOT THEN DO;
                                               L=I;
                                               GOTO NEXTFR1;
                                           END;
                                       GOTO ENDFR;
                                   END/* IF FR.R.OPNDTYP(J) */;
                                 ELSE IF FR.R.EVALOP(J)=0 AND FR.R.S.OPNDTYP(J)=%OPERUNDEF THEN DO;
                                           I$=ADDR(SPOOL(FR.R.S.OPERAND(J)));
                                           GOTO LINKFR;
                                       END;
                           END/* IF FRF */;
                         ELSE DO;
                               K=0;
                               FB=0;
                               J=0;
                               DO WHILE (J<FR.LEN);
                                   IF FR.R(J) THEN DO;
                                           IF FR.R.STBIT(J)~=FB THEN DO;
                                                   W(K)=FR.R.STBIT(J)-FB;
                                                   RL(K)='0'B;
                                               END;
                                             ELSE DO;
                                                   W(K)=FR.R.ENDBIT(J)+1-FR.R.STBIT(J);
                                                   RL(K)=FR.R(J);
                                                   RL.VALUE(K)=FR.R.VALUE(J);
                                                   J=J+1;
                                               END;
                                           IF W(K)=36 THEN V(K)=FR.V;
                                             ELSE CALL BITINSERT(V(K),36-W(K),W(K),FR.V,FB,36);
                                           FB=FB+W(K);
                                           K=K+1;
                                       END/* IF FR.R.OPNDTYP */;
                                     ELSE J=J+1;
                               END/* WHILE J */;
                               IF FB~=36 THEN DO;
                                       V(K)=FR.V;
                                       RL(K)='0'B;
                                       W(K)=36-FB;
                                       K=K+1;
                                   END;
                               SAVPC=PC;
                               SAVPCREL=PCREL.OPERAND;
                               PC=FR.PC;
                               PCREL.OPERAND=FR.PCREL;
                               CALL GEN(K,W,V,RL);
                               CALL PRINTO;
                               PC=SAVPC;
                               PCREL.OPERAND=SAVPCREL;
                           END/* IF FRF ELSE */;
                       IF L~=SYM.FRROOT THEN GOTO NEXTFR;
                   END/* IF L */;
ENDFR:
               SYM.FRROOT=0;
               L=LITROOT;
               LVL=SYMX;
NEXTL:
               CALL TREESTEP(L,LVL);
               IF L~=0 THEN DO;
                       FR$=ADDR(SPOOL(L));
                       J$=PINCRW(FR$,LIT.RX);
                       DO I=0 TO LIT.RX-1;
                           DO WHILE (POFFW(J$,FR$)<LIT.LEN AND J$->LIT.R.DISP(0)=I);
                               CALL UFR(LIT.V(I),J$->LIT.R(0));
                               J$=PINCRW(J$,SIZEW(LIT.R(0)));
                           END/* WHILE J */;
                       END/* DO I */;
                       GOTO NEXTL;
                   END/* IF L */;
           END/* IF DEF */;
         ELSE REL=SYM.R;
       REL.F='0'B;
       GOTO S60;
/**/
S30:
       IF REL.F.SET AND SYM.R.F.SET THEN GOTO S19;
       IF SYM.R.OPNDTYP=%OPERUNDEF THEN GOTO S20;
       IF NOT DEF THEN GOTO S20;
       REL.F='0'B;
       TREL=SYM.R;
       TREL.F='0'B;
       TREL.OPERAND=REL.OPERAND;
       IF REL.OPNDTYP>%OPERSECT AND REL=TREL THEN REL.OPERAND=SYM.R.OPERAND;
         ELSE DO;
               TREL.OPERAND=SYM.R.OPERAND;
               IF REL~=TREL OR VAL~=SYM.VAL THEN CALL ERROR(-10);
           END;
/**/
/* SET UP REFERENCE TABLE */
/**/
S60:
       IF OPTIONS.XR AND REFF THEN DO;
               R=SYM.REFLINK;
               CALL PACKEY(J);
               IF R=0 THEN DO;
                       CALL GETSYM(SIZEW(REF)) ALTRET(S90);
                       REF$=ADDR(SPOOL(SYMX));
                       TREF$=REF$;
                   END;
                 ELSE DO;
                       REF$=ADDR(SPOOL(R));
                       DO WHILE (JU~=REF.KEY);
                           IF REF.KEY=ADDR(SPOOL(REF.LINK))->REF.KEY
                             OR REF.KEY>ADDR(SPOOL(REF.LINK))->REF.KEY
                             AND (REF.KEY<JU OR JU<ADDR(SPOOL(REF.LINK))->REF.KEY)
                             OR REF.KEY<JU AND JU<ADDR(SPOOL(REF.LINK))->REF.KEY THEN GOTO S75;
                           REF$=ADDR(SPOOL(REF.LINK));
                       END/* WHILE J */;
                       REF.DEF=REF.DEF|DEF;
                       GOTO S90;
/**/
S75:
                       CALL GETSYM(SIZEW(REF)) ALTRET(S90);
                       TREF$=ADDR(SPOOL(SYMX));
                       TREF$->REF.LINK=REF.LINK;
                   END/* IF R=0 ELSE */;
               REF.LINK=SYMX;
               TREF$->REF.KEY=J;
               TREF$->REF.DEF=DEF;
               SYM.REFLINK=SYMX;
S90:
           END/* IF OPTIONS.XR */;
       IF DEF THEN DO;
               IF SYM.R.OPNDTYP=%OPERUNDEF THEN CALL INSREF(ADDR(SPOOL(SYM.R.OPERAND)));
               IF SYM.R.EVALOP=0 AND SYM.R.S.OPERAND=%OPERUNDEF THEN CALL INSREF(ADDR(SPOOL(SYM.R.S.OPERAND)));
           END;
       RETURN;
%EJECT;
/* INSERT REFERENCE TO UNDEFINED SYMBOL IN REF LIST
*/
INSREF: PROC (ISYM$);
DCL ISYM$ PTR;
%SYM(NAME=ISYM,STCLASS="BASED(ISYM$)");
/**/
       DO WHILE(ISYM.UREF~=0);
           ISYM$=ADDR(SPOOL(ISYM.UREF));
       END;
       ISYM.UREF=S;
       RETURN;
END INSREF;
%EJECT;
/* UPDATE FORWARD REFERENCES
*/
UFR:   PROC (VAL,REL);
DCL VAL SBIN;
%REL(W2=FLD);
DCL 1 RELA REDEF REL,
      2 F BIT(6),
      2 R BIT(30),
      2 *(0:1) UBIN;
DCL S$ PTR;
DCL S1 SBIN;
DCL TEMP SBIN;
DCL TEMP1 SBIN;
/**/
       S$=SYM$;
       S1=S;
       FB=REL.STBIT;
       NB=REL.ENDBIT+1-REL.STBIT;
NEXTR:
       IF REL.OPNDTYP=%OPERUNDEF THEN
           IF REL.OPERAND=S1 THEN DO;
                   TEMP=0;
                   CALL BITINSERT(TEMP,36-NB,NB,VAL,FB,36);
                   TEMP1=S$->SYM.VAL;
                   DO CASE (REL.EVALOP);
                    CASE(%EVALOPMULT);
                       TEMP1=TEMP1*REL.VALUE;
                    CASE(%EVALOPDIV);
                       TEMP1=TEMP1/REL.VALUE;
                   END;
                   DO CASE (REL.RELOCOP);
                    CASE(%RELOCOPADD);
                       TEMP=TEMP+TEMP1;
                    CASE(%RELOCOPSUB);
                       TEMP=TEMP-TEMP1;
                   END;
                   CALL BITINSERT(VAL,FB,NB,TEMP,36-NB,36);
                   IF S$->SYM.R.OPNDTYP=0 THEN
                       IF REL.EVALOP=0 AND REL.S THEN DO;
                               REL=REL.S;
                               GOTO NEXTR;
                           END;
                         ELSE REL='0'B;
                     ELSE DO;
                           REL.OPNDTYP=S$->SYM.R.OPNDTYP;
                           IF REL.OPNDTYP=%OPERUNDEF THEN FRF=%T;
                           REL.OPERAND=S$->SYM.R.OPERAND;
                           IF REL.RELOCOP=%RELOCOPADD THEN REL.RELOCOP=S$->SYM.R.RELOCOP;
                             ELSE IF S$->SYM.R.RELOCOP=%RELOCOPSUB THEN REL.RELOCOP=%RELOCOPADD;
                           DO CASE (REL.EVALOP);
                            CASE(0);
                               IF S$->SYM.R.EVALOP~=0 THEN
                                   IF REL.S THEN CALL ERROR(5);
                                     ELSE DO;
                                           REL.EVALOP=S$->SYM.R.EVALOP;
                                           REL.VALUE=S$->SYM.R.VALUE;
                                       END;
                            CASE(%EVALOPMULT);
                               DO CASE (S$->SYM.R.EVALOP);
                                CASE(%EVALOPMULT);
                                   REL.VALUE=REL.VALUE*S$->SYM.R.VALUE;
                                CASE(%EVALOPDIV);
                                   IF MOD(REL.VALUE,S$->SYM.R.VALUE)=0 THEN REL.VALUE=REL.VALUE/S$->SYM.R.VALUE;
                                     ELSE CALL ERROR(5);
                               END/* CASE S$->SYM.R.EVALOP */;
                            CASE(%EVALOPDIV);
                               DO CASE (S$->SYM.R.EVALOP);
                                CASE(%EVALOPMULT);
                                   IF MOD(S$->SYM.R.VALUE,REL.VALUE)=0 THEN DO;
                                           REL.EVALOP=%RELOCOPMULT;
                                           REL.VALUE=S$->SYM.R.VALUE/REL.VALUE;
                                       END;
                                     ELSE CALL ERROR(5);
                                CASE(%EVALOPDIV);
                                   CALL ERROR(5);
                               END/* CASE S$->SYM.R.EVALOP */;
                           END/* CASE REL.EVALOP */;
                           IF S$->SYM.R.EVALOP=0 AND S$->SYM.R.S THEN
                               IF REL.EVALOP~=0 OR REL.S THEN
                                   CALL ERROR(5);
                                 ELSE REL.S=S$->SYM.R.S;
                       END/* IF S$->SYM.R.OPNDTYP ELSE */;
               END/* IF REL.OPERAND */;
             ELSE FRF=%T;
       IF REL.EVALOP=0 AND REL.S.OPNDTYP=%OPERUNDEF THEN
           IF REL.S.OPERAND=S1 THEN DO;
                   TEMP=0;
                   CALL BITINSERT(TEMP,36-NB,NB,VAL,FB,36);
                   DO CASE (REL.S.RELOCOP);
                    CASE(%RELOCOPADD);
                       TEMP=TEMP+S$->SYM.VAL;
                    CASE(%RELOCOPSUB);
                       TEMP=TEMP-S$->SYM.VAL;
                   END;
                   CALL BITINSERT(VAL,FB,NB,TEMP,36-NB,36);
                   IF S$->SYM.R.OPNDTYP=0 THEN
                       REL.S='0'B;
                     ELSE DO;
                           REL.S.OPNDTYP=S$->SYM.R.OPNDTYP;
                           IF REL.S.OPNDTYP=%OPERUNDEF THEN FRF=%T;
                           REL.S.OPERAND=S$->SYM.R.OPERAND;
                           IF REL.S.RELOCOP=%RELOCOPADD THEN REL.S.RELOCOP=S$->SYM.R.RELOCOP;
                             ELSE IF S$->SYM.R.RELOCOP=%RELOCOPSUB THEN REL.S.RELOCOP=%RELOCOPADD;
                           IF S$->SYM.R.EVALOP~=0 OR S$->SYM.R.S THEN CALL ERROR(5);
                       END/* IF S$->SYM.R.OPNDTYP ELSE */;
               END/* IF REL.S.OPERAND */;
             ELSE FRF=%T;
       IF FRF THEN DO;
               IF REL.OPNDTYP=%OPERUNDEF THEN DO;
                       S1=REL.OPERAND;
NEXTS:
                       S$=ADDR(SPOOL(S1));
                       IF S$->SYM.R.OPNDTYP~=%OPERUNDEF THEN DO;
                               FRF=%F;
                               GOTO NEXTR;
                           END;
                   END/* IF REL.OPNDTYP */;
                 ELSE IF REL.EVALOP=0 AND REL.S.OPNDTYP=%OPERUNDEF THEN DO;
                           S1=REL.S.OPERAND;
                           GOTO NEXTS;
                       END;
           END/* IF FRF */;
         ELSE IF REL.EVALOP=0 AND REL.S.OPNDTYP=REL.OPNDTYP
             AND REL.S.OPERAND=REL.OPERAND
             AND REL.S.RELOCOP=%RELOCOPADD+%RELOCOPSUB-REL.RELOCOP THEN DO;
                   RELA.R='0'B;
                   REL.S='0'B;
               END;
       RETURN;
END UFR;
END SYMTAB;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* TEST=SIGN(A-B) (+1,0,-1) */
/**/
TEST:  PROC (A,LA,B,LB,SW);
DCL A(0:4) UBIN;                       /* 1st symbol */
DCL LA UBIN;                           /* Length (words) of A */
DCL B(0:4) UBIN;                       /* 2nd symbol */
DCL LB UBIN;                           /* Length (words) of B */
DCL SW SBIN;                           /* Return SIGN(A-B) */
/**/
DCL L SBIN;
DCL I SBIN;
/**/
       IF LA<LB THEN L=LA; ELSE L=LB;
       DO I=0 TO L-1;
           IF A(I)~=B(I) THEN DO;
                   SW=1-2*BITBIN(A(I)<B(I));
                   RETURN;
               END;
       END/* DO I */;
       IF LA=LB THEN SW=0;
         ELSE SW=1-2*BITBIN(LA<LB);
       RETURN;
END TEST;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SEARCH BINARY TREE
/*
/* IF INSERT, INSERT NEW SYMBOL ON TREE
/*
/* RETURN POINTER TO SYMBOL
/*     + = OLD SYMBOL
/*     0 = SYMBOL NOT FOUND
/*     - = NEW SYMBOL
*/
TREESRCH: PROC (ROOT,SYMBOL,SL,OFFSET,INSF,SPTR);
DCL ROOT SBIN;                         /* INDEX IN SPOOL OF ROOT OF TABLE */
DCL SYMBOL(0:5) UBIN;                  /* SYMBOL TO SEARCH FOR */
DCL SL SBIN;                           /* LENGTH(WORDS) OF SYMBOL */
DCL OFFSET SBIN;                       /* SIZEW OF TABLE ENTRY */
DCL INSF BIT(1) ALIGNED;               /* 1=INSERT NEW ENTRY */
DCL SPTR SBIN;                         /* (OUTPUT) INDEX IN SPOOL OF ENTRY: */
                                       /*   + = OLD ENTRY */
                                       /*   0 = ENTRY NOT FOUND (INSF=1) */
                                       /*   - = NEW ENTRY */
%INCLUDE BMAP_C;
DCL GETSYM ENTRY (1) ALTRET;
DCL TEST ENTRY (5);
/**/
%BMAP_COMMON;
DCL A SBIN;
DCL D SBIN;
DCL I SBIN;
DCL J SBIN;
DCL L SBIN;
%LIT(STCLASS=BASED);
DCL P SBIN;
DCL P$ PTR;
DCL Q SBIN;
DCL Q$ PTR;
DCL R SBIN;
DCL R$ PTR;
DCL S SBIN;
%SYM;                                  /* Symbol table packet */
DCL S$ PTR;
DCL T SBIN;
DCL T$ PTR;
/**/
       T=0;
       S=ROOT; P=ROOT;
       IF P=0 THEN GOTO S50;
S20:
       P$=ADDR(SPOOL(P));
       L=P$->SYM.LEN; IF L=0 THEN L=P$->LIT.LEN;
       CALL TEST(SYMBOL,SL,SPOOL(P+OFFSET-1),L,A);
       IF A~=0 THEN GOTO S30;
       SPTR=P;
       RETURN;
/**/
S30:
       Q=P$->SYM.LINKS((A+1)/2);
       IF Q=0 THEN GOTO S50;
       Q$=ADDR(SPOOL(Q));
       IF Q$->SYM.BAL~=0 THEN DO; T=P; S=Q; END;
       P=Q;
       GOTO S20;
/**/
S50:
       IF NOT INSF THEN GOTO S95;
       CALL GETSYM(OFFSET-1+SL) ALTRET(S95);
       Q=SYMX;
       SPTR=-Q;
       DO I=1 TO OFFSET-1;
           SPOOL(Q+I-1)=0;
       END;
       Q$=ADDR(SPOOL(Q));
       Q$->SYM.LEN=SL;
       DO I=0 TO SL-1;
           SPOOL(Q+OFFSET+I-1)=SYMBOL(I);
       END;
       IF P=0 THEN DO; P=Q; GOTO S90; END;
       P$->SYM.LINKS((A+1)/2)=Q;
       S$=ADDR(SPOOL(S));
       L=S$->SYM.LEN; IF L=0 THEN L=S$->LIT.LEN;
       CALL TEST(SYMBOL,SL,SPOOL(S+OFFSET-1),L,A);
       P=S$->SYM.LINKS((A+1)/2);
       R=P;
       DO WHILE (P~=Q);
           P$=ADDR(SPOOL(P));
           L=P$->SYM.LEN; IF L=0 THEN L=P$->LIT.LEN;
           CALL TEST(SYMBOL,SL,SPOOL(P+OFFSET-1),L,D);
           P$->SYM.BAL=D;
           P=P$->SYM.LINKS((D+1)/2);
       END;
       IF S$->SYM.BAL=0 THEN DO; S$->SYM.BAL=A; RETURN; END;
       IF S$->SYM.BAL~=A THEN DO; S$->SYM.BAL=0; RETURN; END;
       R$=ADDR(SPOOL(R));
       IF R$->SYM.BAL~=A THEN GOTO S80;
       P=R;
       S$->SYM.LINKS((A+1)/2)=R$->SYM.LINKS((1-A)/2);
       R$->SYM.LINKS((1-A)/2)=S;
       R$->SYM.BAL=0;
       S$->SYM.BAL=0;
       GOTO S90;
/**/
S80:
       P=R$->SYM.LINKS((1-A)/2);
       P$=ADDR(SPOOL(P));
       R$->SYM.LINKS((1-A)/2)=P$->SYM.LINKS((A+1)/2);
       P$->SYM.LINKS((A+1)/2)=R;
       S$->SYM.LINKS((A+1)/2)=P$->SYM.LINKS((1-A)/2);
       P$->SYM.LINKS((1-A)/2)=S;
       I=0; J=0;
       IF P$->SYM.BAL=A THEN DO; I=-A; GOTO S85; END;
       IF P$->SYM.BAL~=0 THEN J=A;
S85:
       S$->SYM.BAL=I;
       R$->SYM.BAL=J;
       P$->SYM.BAL=0;
S90:
       IF T=0 THEN DO; ROOT=P; RETURN; END;
       T$=ADDR(SPOOL(T));
       T$->SYM.LINKS(BITBIN(S=T$->SYM.LINK.R))=P;
       RETURN;
/**/
S95:
       SPTR=0;
       RETURN;
END TREESRCH;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* STEP THROUGH BINARY TREE
*/
TREESTEP: PROC (NODE,LVL);
DCL NODE SBIN;                    /* Index in SPOOL to current node of tree */
DCL LVL SBIN;                          /* Level in tree (distance from root) */
/**/
%INCLUDE BMAP_C;
/**/
DCL GETSYM ENTRY (1) ALTRET;
/**/
%BMAP_COMMON;
DCL NW SBIN;
DCL Q SBIN;
%SYM;                                  /* Symbol table packet */
/**/
       IF LVL~=SYMX THEN DO; NODE=ADDR(SPOOL(NODE))->SYM.LINK.R; LVL=LVL+1; END;
       Q=NODE;
       DO WHILE (Q~=0);
           NW=SYMX-LVL+1;
           CALL GETSYM(NW) ALTRET(S115);
           SYMX=SYMX+NW;
           LVL=LVL-1; SPOOL(LVL)=Q;
           NODE=Q;
           Q=ADDR(SPOOL(Q))->SYM.LINK.L;
       END;
       DO WHILE (%F);
S115:
           IF NODE=Q THEN NODE=0;
             ELSE NODE=Q;
       END;
       IF NODE=0 AND LVL<SYMX THEN NODE=SPOOL(LVL);
       RETURN;
END TREESTEP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/* SCAN VARIABLE FIELD
/*
/*     Return value of next subfield of input line
*/
VARSCAN: PROC (VAL,REL,TYPE);
DCL VAL SBIN;                          /* Value of subfield */
DCL BVAL REDEF VAL BIT(36);
%INCLUDE BMAP_C;
%REL;                                  /* Relocation words */
DCL TYPE BIT(3) ALIGNED;               /* Type of expression to scan */
/*
/*            TYPE:
/*              0 ADDRESS (DEC)
/*              1 ADDRESS (OCT)
/*              2 MODIFIER
/*              4 LITERAL ALLOWED
*/
%INCLUDE B$OBJECT_C;
%B$RELOCSUBS;
%BMAP_COMMON;
DCL XLATEV ENTRY (7) ALTRET;
DCL CONVERT ENTRY (3);
DCL DELSCAN ENTRY;
DCL ERROR ENTRY (1);
DCL LITERAL ENTRY (3);
DCL NEXTFLD ENTRY ALTRET;
DCL SYMTAB ENTRY (5);
/**/
/* ADDRESS MODIFICATION TABLE */
/**/
DCL TSTMOD CHAR(4);
DCL MODSYM(0:37) CHAR(4) CONSTANT INIT(
           '$ ','0 ','1 ','2 ','3  ','4 ','5  ','6  ',
           '7 ','A ','AD','AL','AU ','CI','DI ','DIC',
           'DL','DU','F ','I ','IC ','ID','IDC','N  ',
           'Q ','QL','QU','SC','SCR','SD','X0 ','X1 ',
           'X2','X3','X4','X5','X6 ','X7');
DCL MODVAL(0:37) SBIN CONSTANT INIT(
          4,8,9,10,11,12,13,14,
          15,5,43,5,1,40,44,45,
          7,3,32,41,4,46,47,0,
          6,6,2,42,37,36,8,9,
          10,11,12,13,14,15);
DCL BMODVAL(0:37) REDEF MODVAL BIT(36);
DCL OPSTK(0:20) SBIN STATIC INIT(12,0*20);
DCL PREC(0:14) SBIN CONSTANT INIT(0,1,1,2,2,1,1,2,2,3,0*5);
/**/
DCL BASE SBIN;
DCL COP SBIN;
DCL I SBIN;
DCL J SBIN;
DCL K SBIN;
DCL OPX SBIN;
%REL(NAME="R(0:19)");
DCL TSYM(0:5) UBIN;
DCL TUNARY BIT(1);
DCL UNARY(0:19) BIT(1);
DCL V(0:19) SBIN DALIGNED;
DCL BV(0:19) REDEF V BIT(36) DALIGNED;
DCL VX SBIN;
/**/
       VAL=0; REL='0'B;
       OPX=0; VX=-1;
       BASE=10-2*BITBIN(TYPE&'1'O);
       CALL NEXTFLD WHENALTRETURN DO;
               IF DEL=%LPAR THEN GOTO S20;
               GOTO S160;
           END;
       IF (TYPE&'3'O)='2'O THEN GOTO S60;
       IF XCARD(CURRCH)='=' THEN DO;   /* LITERAL */
               CALL LITERAL(VAL,REL,~TYPE&'4'O);
               IF DEL>=%LPAR THEN GOTO S160;
               VX=0;
               V(0)=VAL;
               R(0)=REL;
               TUNARY=%F;
           END;
         ELSE DO;
S20:
               TUNARY=(NEXTCH=CURRCH);
               IF NOT TUNARY THEN DO;
                       VX=VX+1;
                       IF SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH)='*' THEN DO;
                               V(VX)=PC;
                               R(VX)=PCREL;
                           END;
                         ELSE IF XCARD(CURRCH)='=' THEN DO;
                                   CALL LITERAL(V(VX),R(VX),%T);
                               END;
                             ELSE DO;
                                   CALL SEARCH(I,J,NONDGT,SUBSTR(XCARDS,0,NEXTCH),CURRCH) ALTRET(NUMBER);
                                   %CONSYM(#SYM=TSYM);
                                   V(VX)=0;
                                   R(VX)=%UNDEF;
                                   CALL SYMTAB(TSYM,V(VX),R(VX),%F);
                                   DO WHILE (%F);
NUMBER:
                                       CALL CONVERT(BASE,V(VX),I);
                                       IF I~=0 OR CURRCH~=NEXTCH THEN CALL ERROR(9);
                                       R(VX)='0'B;
                                   END;
                               END/* IF NEXTCH ELSE ELSE */;
                   END/* IF NOT TUNARY */;
           END/* IF XCARD(CURRCH) ELSE */;
S30:
       COP=DEL;
       IF TYPE&'1'O OR DEL>%DIV THEN COP=COP+4;
S40:
       IF PREC(OPSTK(OPX))<PREC(COP) THEN DO;
S41:
               IF OPX=SIZEW(OPSTK)-1 THEN GOTO S160;
               OPX=OPX+1;
               OPSTK(OPX)=COP;
               UNARY(OPX)=TUNARY;
               CURRCH=NEXTCH+1;
               CALL DELSCAN;
               GOTO S20;
           END;
       IF TUNARY THEN DO;
               VX=VX+1;
               V(VX)=0;
               R(VX)='0'B;
               TUNARY=%F;
           END;
       DO CASE(OPSTK(OPX));
        CASE(ELSE);
           BVAL=BVAL|BV(0); REL=R(0);
           IF (TYPE&'3'O)='2'O THEN GOTO S76;
           GOTO S160;
                                       /* + */
        CASE(1);
           IF UNARY(OPX) THEN GOTO S51;
           IF NOT R(VX-1) THEN R(VX-1)=R(VX);
             ELSE IF R(VX) THEN
                   IF R.OPNDTYP(VX-1)=R.OPNDTYP(VX) AND R.EVALOP(VX-1)=R.EVALOP(VX)
                     AND R.RELOCOP(VX-1)=%RELOCOPADD+%RELOCOPSUB-R.RELOCOP(VX)
                     AND R.OPERAND(VX-1)=R.OPERAND(VX) AND R.VALUE(VX-1)=R.VALUE(VX) THEN R(VX)='0'B;
                     ELSE IF R.EVALOP(VX-1)~=0 OR R.S(VX-1) OR R.EVALOP(VX)~=0 OR R.S(VX) THEN
                           CALL ERROR(5);
                         ELSE R.S(VX-1)=R(VX);
           V(VX-1)=V(VX-1)+V(VX);
                                       /* - */
        CASE(2);
           IF UNARY(OPX) THEN DO;
                   V(VX)=-V(VX);
                   IF R(VX) THEN DO;
                           R.RELOCOP(VX)=%RELOCOPADD+%RELOCOPSUB-R.RELOCOP(VX);
                           IF R.EVALOP(VX)=0 AND R.S(VX) THEN
                               R.S.RELOCOP(VX)=%RELOCOPADD+%RELOCOPSUB-R.S.RELOCOP(VX);
                       END;
                   GOTO S51;
               END;
           IF NOT R(VX-1) THEN DO;
                   R(VX-1)=R(VX);
                   IF R(VX-1) THEN DO;
                           R.RELOCOP(VX-1)=%RELOCOPADD+%RELOCOPSUB-R.RELOCOP(VX-1);
                           IF R.EVALOP(VX-1)=0 AND R.S(VX-1) THEN
                               R.S.RELOCOP(VX-1)=%RELOCOPADD+%RELOCOPSUB-R.S.RELOCOP(VX-1);
                       END;
               END/* IF NOT R(VX-1) */;
             ELSE IF R(VX) THEN
                   IF R(VX-1)=R(VX) THEN R(VX-1)='0'B;
                     ELSE IF R.EVALOP(VX-1)~=0 OR R.S(VX-1) OR R.EVALOP(VX)~=0 OR R.S(VX) THEN
                           CALL ERROR(5);
                         ELSE DO;
                               R.S(VX-1)=R(VX);
                               R.S.RELOCOP(VX-1)=%RELOCOPADD+%RELOCOPSUB-R.S.RELOCOP(VX-1);
                           END;
           V(VX-1)=V(VX-1)-V(VX);
                                       /* * */
        CASE(3);
           IF UNARY(OPX) THEN DO; V(VX)=0; R(VX)='0'B; GOTO S51; END;
           IF R(VX) THEN
               IF NOT R(VX-1) THEN DO;
                       R(VX-1)=R(VX);
                       I=V(VX-1);
                       V(VX-1)=V(VX);
                       V(VX)=I;
                   END;
                 ELSE CALL ERROR(5);
           IF V(VX)=0 THEN R(VX-1)='0'B;
           IF R(VX-1) AND V(VX)~=1 THEN
               IF R.EVALOP(VX-1)~=0 OR NOT R.S(VX-1) THEN
                   DO CASE (R.EVALOP(VX-1));
                    CASE(0);
                       R.EVALOP(VX-1)=%EVALOPMULT;
                       R.VALUE(VX-1)=V(VX);
                    CASE(%EVALOPMULT);
                       R.VALUE(VX-1)=R.VALUE(VX-1)*V(VX);
                    CASE(%EVALOPDIV);
                       IF MOD(V(VX),R.VALUE(VX-1))=0 THEN DO;
                               R.EVALOP(VX-1)=%EVALOPMULT;
                               R.VALUE(VX-1)=V(VX)/R.VALUE(VX-1);
                           END;
                         ELSE CALL ERROR(5);
                   END/* CASE R.EVALOP(VX-1) */;
                 ELSE CALL ERROR(5);
           IF R.EVALOP(VX-1)~=0 AND R.VALUE(VX-1)<0 THEN DO;
                   R.RELOCOP(VX-1)=%RELOCOPADD+%RELOCOPSUB-R.RELOCOP(VX-1);
                   R.VALUE(VX-1)=-R.VALUE(VX-1);
               END;
           V(VX-1)=V(VX-1)*V(VX);
                                       /* / */
        CASE(4);
           IF UNARY(OPX) THEN DO; V(VX)=0; R(VX)='0'B; GOTO S51; END;
           IF R(VX) THEN CALL ERROR(5);
           IF R(VX-1) AND (V(VX)<0 OR V(VX)>1) THEN
               IF R.EVALOP(VX-1)~=0 OR NOT R.S(VX-1) THEN
                   DO CASE (R.EVALOP(VX-1));
                    CASE(0);
                       R.EVALOP(VX-1)=%EVALOPDIV;
                       R.VALUE(VX-1)=V(VX);
                    CASE(%EVALOPMULT);
                       IF MOD(R.VALUE(VX-1),V(VX))=0 THEN
                           R.VALUE(VX-1)=R.VALUE(VX-1)/V(VX);
                         ELSE CALL ERROR(5);
                    CASE(%EVALOPDIV);
                       CALL ERROR(5);
                   END/* CASE R.EVALOP(VX-1) */;
                 ELSE CALL ERROR(5);
           IF R.EVALOP(VX-1)~=0 AND R.VALUE(VX-1)<0 THEN DO;
                   R.RELOCOP(VX-1)=%RELOCOPADD+%RELOCOPSUB-R.RELOCOP(VX-1);
                   R.VALUE(VX-1)=-R.VALUE(VX-1);
               END;
           IF V(VX)~=0 THEN V(VX-1)=V(VX-1)/V(VX);
                                       /* OR */
        CASE(5);
           IF UNARY(OPX) THEN GOTO S51;
           IF R(VX-1) AND R(VX) OR R(VX-1) AND V(VX)~=0 OR V(VX-1)~=0 AND R(VX) THEN DO;
                   CALL ERROR(5);
                   R(VX-1)='0'B;
               END;
             ELSE IF NOT R(VX-1) THEN R(VX-1)=R(VX);
           BV(VX-1)=BV(VX-1)|BV(VX);
                                       /* EOR */
        CASE(6);
           IF UNARY(OPX) THEN GOTO S51;
           IF R(VX-1) AND R(VX) OR R(VX-1) AND V(VX)~=0 OR V(VX-1)~=0 AND R(VX) THEN DO;
                   CALL ERROR(5);
                   R(VX-1)='0'B;
               END;
             ELSE IF NOT R(VX-1) THEN R(VX-1)=R(VX);
           BV(VX-1)=BV(VX-1)&~BV(VX)|~BV(VX-1)&BV(VX);
                                       /* AND */
        CASE(7);
           IF UNARY(OPX) THEN DO; V(VX)=0; R(VX)='0'B; GOTO S51; END;
           IF R(VX-1) OR V(VX-1)~=0 THEN
               IF NOT R(VX) AND V(VX)=0 THEN DO;
                       R(VX-1)='0'B;
                       V(VX-1)=0;
                   END;
                 ELSE IF R(VX-1) AND (R(VX) OR V(VX)~=-1) OR V(VX-1)~=-1 AND R(VX) THEN DO;
                           CALL ERROR(5);
                           R(VX-1)='0'B;
                       END;
                     ELSE IF NOT R(VX-1) THEN R(VX-1)=R(VX);
           BV(VX-1)=BV(VX-1)&BV(VX);
                                       /* NOT */
        CASE(8);
           IF UNARY(OPX) THEN DO;
                   IF R(VX) THEN DO; CALL ERROR(5); R(VX)='0'B; END;
                   BV(VX)=~BV(VX);
                   GOTO S51;
               END;
                                       /* BINARY NOT = X AND NOT Y */
           IF R(VX-1) OR V(VX-1)~=0 THEN
               IF NOT R(VX) AND V(VX)=-1 THEN DO;
                       R(VX-1)='0'B;
                       V(VX-1)=0;
                   END;
                 ELSE IF V(VX)~=0 THEN DO;
                           IF R(VX) OR R(VX-1) THEN CALL ERROR(5);
                           R(VX-1)='0'B;
                       END;
           BV(VX-1)=BV(VX-1)&~BV(VX);
                                       /* ( */
        CASE(9);
           IF NOT UNARY(OPX) THEN GOTO S160;
           IF COP<%RPAR+4 THEN GOTO S41;
           IF COP>%RPAR+4 THEN GOTO S160;
           CURRCH=NEXTCH+1;
           DEL=0;
           CALL DELSCAN;
           IF NEXTCH>CURRCH THEN DO;
                   IF XCARD(CURRCH)~='*' THEN GOTO S160;
                   NEXTCH=CURRCH;
                   DEL=%TIMES;
               END;
           OPX=OPX-1;
           TUNARY='0'B;
           IF OPX=0 AND (TYPE&'3'O)='2'O THEN GOTO S76;
           GOTO S30;
       END/* CASE OPSTK(OPX) */;
       VX=VX-1;
S51:
       OPX=OPX-1;
       GOTO S40;
/**/
/* MODIFIER */
/**/
S60:
       IF XCARD(CURRCH)='*' THEN DO;
               CURRCH=CURRCH+1;
               VAL=BITBIN('60'O);
               IF NEXTCH>CURRCH THEN EXIT;
               IF DEL=%LPAR THEN GOTO S20;
               VAL=BITBIN('20'O); GOTO S86;
           END/* IF XCARD(CURRCH) */;
       I=0;
       J=37;
       TSTMOD=SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH);
       IF NEXTCH-CURRCH<4
         THEN DO UNTIL (J<I);
               K=(I+J)/2;
               IF TSTMOD=MODSYM(K) THEN DO;
                       BVAL=BVAL|BMODVAL(K);
                       IF K=0 THEN REL.OPNDTYP=%OPERREL;
                       GOTO S85;
                   END;
               IF TSTMOD<MODSYM(K) THEN
                   J=K-1;
                 ELSE
                   I=K+1;
           END/* WHILE J */;
       DO I=CURRCH TO NEXTCH-1;
           IF XCARD(I)<'0' OR XCARD(I)>'9' THEN DO;
                   %CONSYM(#SYM=TSYM);
                   V(1)=0;
                   REL=%UNDEF;
                   CALL SYMTAB(TSYM,V(0),REL,%F);
                   GOTO S76;
               END;
       END/* DO I */;
       CALL CHARBIN(V(0),SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH));
S76:
       BVAL=BVAL|BV(0)|'000000000010'O;
S85:
       IF DEL=%TIMES THEN DO; BVAL=BVAL|'000000000020'O;
               CURRCH=NEXTCH+1; CALL DELSCAN; END;
S86:
       DO WHILE (DEL<%LPAR);
           CALL ERROR(3);
           CURRCH=NEXTCH+1;
           CALL DELSCAN;
       END;
S160:
       IF OPX>0 OR VX>0 THEN CALL ERROR(21);
       CURRCH=NEXTCH;
       RETURN;
END VARSCAN;
%EOD;
/*M* VFD - Process VFD pseudo-op */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*
/* Called by INST to process VFD pseudo-ops
/* Called by LITERAL to process =V literals
*/
VFD:   PROC (OPVAL,V0) ALTRET;
DCL OPVAL UBIN;                        /* 0=VFD, 1=OPD */
DCL V0 UBIN;                           /* Return value for OPD */
/**/
%INCLUDE BMAP_C;
/**/
DCL BITINSERT ENTRY (6) ALTRET;
DCL XLATEV ENTRY (7) ALTRET;
DCL GEN ENTRY (4);
DCL GENVAL ENTRY (4);
DCL DELSCAN ENTRY;
DCL ERROR ENTRY (1);
DCL NEXTFLD ENTRY ALTRET;
DCL PRINT ENTRY;
DCL VARSCAN ENTRY (3);
/**/
%BMAP_COMMON;
DCL B SBIN;
DCL BR UBIN;
DCL CONTROLS(0:511) UBIN(9) UNAL CONSTANT INIT(0*64,
       0,2,0*3,4,0,0,3,0*6,1,0,0,7,0,0,2,0*4,6,0*5,
       0,2,0*3,4,0,0,3,0*6,1,0,0,7,0,0,2,0*4,6,0*5,
       0*384);
DCL DT UBIN;
DCL DTB REDEF DT BIT(36);
DCL FB SBIN;
DCL FC SBIN;
DCL I SBIN;
DCL J SBIN;
DCL K SBIN;
DCL M SBIN;
DCL NC SBIN;
%LIST;
%REL(NAME="REL(0:36)");
%PLIST;
DCL TX UBIN;
DCL VAL(0:36) UBIN;
DCL W(0:36) UBIN;
/**/
       B=0;
       K=-1;
L1810:
       CALL NEXTFLD ALTRET(L1835);
       J=CONTROLS(ASCBIN(XCARD(CURRCH)));
       DO CASE (J);
        CASE(1);                       /* O = OCTAL */
           CURRCH=CURRCH+1;
           M=1;
        CASE(2);                       /* A, U = ASCII */
           CURRCH=CURRCH+1;
           M=9;
           TX=2;
        CASE(6);                       /* Z = RIGHT-JUSTIFIED ASCII */
           CURRCH=CURRCH+1;
           M=-9;
           TX=2;
        CASE(4);                       /* E = EBCDIC */
           CURRCH=CURRCH+1;
           M=9;
           TX=1;
        CASE(3);                       /* H = BCD */
           CURRCH=CURRCH+1;
           M=6;
           TX=0;
        CASE(7);                       /* R = RIGHT-JUSTIFIED BCD */
           CURRCH=CURRCH+1;
           M=-6;
           TX=0;
        CASE(ELSE);
           M=0;
       END;
       IF DEL~=%DIV THEN DO;
VFDERR:
               CALL ERROR(4);
               ALTRETURN;
           END;
       K=K+1;
       CALL SEARCH(I,J,NONDGT,XCARDS,CURRCH);
       IF I~=NEXTCH THEN GOTO VFDERR;
       CALL CHARBIN(W(K),SUBSTR(XCARDS,CURRCH,NEXTCH-CURRCH));
       IF W(K)=0 THEN CALL ERROR(4);
       IF M>1 OR M<0 THEN GOTO L1840;
       IF W(K)>36 THEN DO; CALL ERROR(4); W(K)=36; END;
       CURRCH=NEXTCH;
       CALL VARSCAN(VAL(K),REL(K),BINBIT(M+4,3));
L1815:
       BR=36-B;
       DO WHILE(W(K)>=BR);
           FB=72-W(K);
           IF FB>=36 THEN VAL(K+1)=VAL(K);
             ELSE IF FB<B THEN DO;
                       VAL(K+2)=VAL(K+1);
                       VAL(K+1)=VAL(K);
                       FB=FB+36;
                   END;
           CALL BITINSERT(VAL(K),B,BR,VAL(K),FB,36);
           W(K+1)=W(K)-BR;
           W(K)=BR;
           IF W(K+1)~=0 AND REL(K) THEN DO; CALL ERROR(5); REL(K)='0'B; END;
           IF OPVAL~=0 THEN GOTO L1860;
           CALL GEN(K+1,W,VAL,REL);
           IF LIT$=ADDR(NIL) THEN
               CALL PRINT;
           VAL(0)=VAL(K+1);
           VAL(1)=VAL(K+2);
           REL(0)='0'B;
           W(0)=W(K+1);
           K=0;
           B=0;
           BR=36;
       END/* WHILE W(K) */;
       B=B+W(K);
       IF W(K)=0 THEN K=-1;
L1830:
       IF DEL=%COMMA THEN GOTO L1810;
L1835:
       IF K>=0 THEN DO;
               IF B~=0 AND B~=36 THEN DO;
                       K=K+1;
                       VAL(K)=0; REL(K)='0'B;
                       W(K)=36-B;
                   END;
               W(K+1)=0;
               IF OPVAL~=0 THEN GOTO L1860;
               CALL GEN(K+1,W,VAL,REL);
           END;
       IF LIT$=ADDR(NIL) THEN CALL PRINT;
       RETURN;
/**/
L1840:
       VAL(K)=0; REL(K)='0'B;
       IF W(K)>36 THEN DO;
               IF W(K)>72 THEN DO; CALL ERROR(4); W(K)=72; END;
               VAL(K+1)=0;
           END;
       I=NEXTCH+1;
       DEL=0;
       DO WHILE (DEL~=%COMMA AND SUBSTR(XCARDS,NEXTCH)~=' ');
           CURRCH=NEXTCH+1;
           CALL DELSCAN;
       END;
       NC=NEXTCH-I;
       IF M>0 THEN
           J=(W(K)+M-1)/M;
         ELSE DO;
               M=-M;
               J=(W(K)+M-1)/M;
               IF NC>J THEN
                   I=I+NC-J;
                 ELSE J=NC;
           END;
       FC=(36+36*BITBIN(W(K)>36))/M-J;
       CALL XLATEV(M,VAL(K),FC,J,ASCIIT(TX),SUBSTR(XCARDS,I),NC);
       CURRCH=NEXTCH;
       GOTO L1815;
/**/
L1860:                                 /* OPD */
       CALL GENVAL(K+1,W,VAL,REL);
       IF W(K+1)~=0 THEN DO; CALL ERROR(-4); ALTRETURN; END;
       V0=0;
       B=36;
       DO WHILE(B>0);
           IF REL(K) THEN DO; CALL ERROR(-4); ALTRETURN; END;
           CALL BITINSERT(V0,0,B,VAL(K),36-B,36);
           B=B-W(K);
           K=K-1;
       END;
       RETURN;
END VFD;
