/*M* CRUNCHBIRD_SI61  Mail-folder compaction utility */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
CRUNCHBIRD: PROC MAIN;
 
%INCLUDE CRUNCHBIRD_C61;
 
%INCLUDE B_ERRORS_C;
%INCLUDE B_MICROPS_C;
%INCLUDE B$JIT;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;
%INCLUDE VM_MACRO_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUG_ENTRY;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
 
%B$ALT;
%B$TCB (STCLASS="BASED(B$TCB$)");
%CODE03;
%F$DCB;
%PARSE$OUT (STCLASS=BASED);
%PARSE$SYM (STCLASS=BASED);
 
%FPT_OPEN (FPTN=OPEN_IN,
           DCB=M$IN,
           FUN=IN,
           SHARE=NONE);
 
%FPT_OPEN (FPTN=OPEN_OUT,
           DCB=M$OUT,
           ASN=FILE,
           FUN=CREATE,
           EXIST=NEWFILE,
           ACS=DIRECT);
 
%FPT_READ (FPTN=READ_IN,
           DCB=M$IN,
           KEY=VM_INPUT_KEY,
           KEYS=NO,
           KEYR=YES);
 
%FPT_WRITE (FPTN=WRITE_OUT,
            DCB=M$OUT,
            KEY=VM_INPUT_KEY,
            NEWKEY=YES);
 
%FPT_CLOSE (FPTN=CLOSE_IN,
            DCB=M$IN,
            DISP=SAVE);
 
%FPT_CLOSE (FPTN=CLOSE_OUT,
            DCB=M$OUT);
 
%FPT_TIME (FPTN=GET_TIME_NOW,
           STCLASS=CONSTANT,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TIME_NOW);
 
%FPT_WRITE (FPTN=WRITE_STATUS,
            DCB=M$ME,
            BUF=STATUS);
 
%FPT_EXIT;
 
%FPT_ERRMSG (FPTN=REPORT_ERROR_MESSAGE_FROM_TCB,
             SOURCE=ALTRET,
             OUTDCB1=M$DO,
             BUF=ERRMSG_BUF,
             RESULTS=VLR_ERRMSG);
 
%VLR_ERRMSG;
 
 
%VM_BODYTYPES;
%VM_KEYTYPES;
%VM_PROFILE (STCLASS="BASED(VM_PROFILE$)");
%VM_HEADER (STCLASS=STATIC);
%VM_PROKEY (STCLASS=STATIC);
%VM_INFOKEY (STCLASS=STATIC);
%VM_BODYKEY (STCLASS=STATIC);
%VM_BODYREC;
%VM_ID;
%VM_LISTKEY (NAME=VM_INPUT_KEY, STCLASS=STATIC);
%XUG_GETCMD (NODES=CRUNCHBIRD_CMD);
%XUG_INIT (COMMANDS=NO, PREPROCESS=NO, SYNTAX=YES, SPELLING=YES, GOODCMD=YES);
 
DCL M$IN DCB;
DCL M$OUT DCB;
DCL M$DO DCB;
DCL M$ME DCB;
 
DCL B$TCB$ PTR SYMREF READONLY;
DCL B$JIT$ PTR SYMREF READONLY;
DCL CRUNCHBIRD_CMD BIT (36) SYMREF READONLY;
 
DCL XSF$LOCCODP ENTRY (2) ALTRET;
 
DCL M$IN$ PTR;
DCL M$OUT$ PTR;
DCL VM_PROFILE$ PTR;
 
DCL BAD_RECORDS BIT (1);
DCL CRUNCH_MAILBOX BIT (1);
DCL DAYS SBIN WORD;
DCL ERRMSG_BUF CHAR (120) STATIC;
DCL GRANULES_IN SBIN WORD;
DCL GRANULES_OUT SBIN WORD;
DCL MESSAGES_IN SBIN WORD;
DCL MESSAGES_OUT SBIN WORD;
DCL PROFILE_SIZE SBIN WORD;
DCL RECORDS_IN SBIN WORD;
DCL RECORDS_OUT SBIN WORD;
DCL TIME_NOW UBIN WORD STATIC;
DCL TEMP_DAY SBIN WORD;
 
DCL 1 DATA_BUFFER,
   2 * (0:4095) UBIN WORD;
 
DCL FPARAM_BUFFER (0:1023) UBIN WORD;
DCL MESSAGE_FLAGS (0:%(1024*36-1)) BIT (1) UNAL;
DCL PROFILE_BUFFER (0:4095) UBIN WORD;
 
DCL 1 STATUS STATIC,
   2 MESSAGES CHAR (8),
   2 * CHAR(0) INIT (' messages,'),
   2 RECORDS CHAR (8),
   2 * CHAR (0) INIT (' records, '),
   2 GRANULES CHAR (8),
   2 * CHAR (0) INIT (' granules '),
   2 DIRECTION CHAR (8) INIT (' ');
 
%EJECT;
HATCH_CRUNCHBIRD: PROC;
 
DCL I UBIN;
 
   CALL XUG$INIT (XUG_GETCMD, XUG_INIT)
     WHENALTRETURN DO;
      CALL EXIT_WITH_CODE (%STEPCC_XUG_ERROR);
      END;
 
   CALL M$TIME (GET_TIME_NOW);
 
   M$IN$ = DCBADDR(DCBNUM(M$IN));
   M$OUT$ = DCBADDR(DCBNUM(M$OUT));
   VM_PROFILE$ = ADDR(PROFILE_BUFFER);
   DAYS = %DEFAULT_DAYS;
   BAD_RECORDS = %NO#;
   CRUNCH_MAILBOX = %NO#;
   MESSAGE_FLAGS = '0'B;
   MESSAGES_IN = 0;
   MESSAGES_OUT = 0;
   RECORDS_IN = 0;
   RECORDS_OUT = 0;
 
   IF B$JIT.CCDISP < B$JIT.CCARS
     THEN DO;
 
      XUG_GETCMD.TEXT_ = VECTOR (SUBSTR(B$JIT.CCBUF, B$JIT.CCDISP, B$JIT.CCARS - B$JIT.CCDISP));
 
      CALL XUG$GETCMD (XUG_GETCMD)
        WHENALTRETURN DO;
         CALL EXIT_WITH_CODE (%STEPCC_XUG_ERROR);
         END;
 
      DO I = 0 TO XUG_GETCMD.OUT$ -> OUT$BLK.NSUBLKS - 1;
 
         DO CASE (XUG_GETCMD.OUT$ -> OUT$BLK.SUBLK$(I) -> OUT$BLK.CODE);
 
           CASE (%DAYS_OPTION);
 
            CALL CHARBIN (DAYS, XUG_GETCMD.OUT$ -> OUT$BLK.SUBLK$(I) ->
             OUT$SYM.TEXT);
 
           CASE (%CRUNCH_OPTION);
 
            CRUNCH_MAILBOX = %YES#;
 
           END;
 
         END;
 
      END;
 
   OPEN_IN.FPARAM_ = VECTOR (FPARAM_BUFFER);
 
   CALL M$OPEN (OPEN_IN) ALTRET (AIEE);
 
   CALL FIND_GRANULE_COUNT (GRANULES_IN);
 
   IF NOT B$JIT.PRFLAGS.OU
     THEN DO;
 
      OPEN_OUT.NAME_ = VECTOR (M$IN$ -> F$DCB.NAME#);
      OPEN_OUT.ACCT_ = VECTOR (M$IN$ -> F$DCB.ACCT#);
      OPEN_OUT.PASS_ = VECTOR (M$IN$ -> F$DCB.PASS#);
 
      END;
 
   OPEN_OUT.IFPARAM_ = VECTOR (FPARAM_BUFFER);
 
   CALL M$OPEN (OPEN_OUT) ALTRET (AIEE);
 
   READ_IN.BUF_ = VECTOR (DATA_BUFFER);
 
   RETURN;
 
AIEE:
 
   CALL REPORT_ERROR_IN_TCB;
 
END HATCH_CRUNCHBIRD;
 
%EJECT;
READ_PROFILE: PROC;
 
   CALL M$READ (READ_IN) ALTRET (AIEE);
 
   VM_PROKEY = VM_INPUT_KEY;
 
   IF VM_PROKEY.TYPE ~= %VM_TYPE_PRO
     THEN
      CALL EXIT_WITH_CODE (%STEPCC_NO_PROFILE);
 
   PROFILE_BUFFER = DATA_BUFFER;
   PROFILE_SIZE = M$IN$ -> F$DCB.ARS#;
   RECORDS_IN = RECORDS_IN + 1;
 
   RETURN;
 
AIEE:
 
   CALL REPORT_ERROR_IN_TCB;
 
END READ_PROFILE;
 
%EJECT;
READ_THROUGH_FILE: PROC;
 
DCL WRITE_RECORD BIT (1);
 
   DO WHILE '1'B;
 
      CALL M$READ (READ_IN) ALTRET (MAYBE_DONE);
 
      RECORDS_IN = RECORDS_IN + 1;
      WRITE_RECORD = %YES#;
 
      DO CASE (VM_INPUT_KEY.TYPE);
 
        CASE (%VM_TYPE_HEAD);
 
         VM_HEADER = DATA_BUFFER;
         VM_INFOKEY = VM_INPUT_KEY;
         MESSAGES_IN = MESSAGES_IN + 1;
 
         CALL XUD$UTS_DIFF_SEC (TEMP_DAY,TIME_NOW,VM_HEADER.DELIVERY_DATE);
         TEMP_DAY = TEMP_DAY/86400;
         IF NOT VM_HEADER.STATUS.DEL
          AND (VM_HEADER.STATUS.MARK OR DAYS < 0 OR
          TEMP_DAY < DAYS)
           THEN DO;
            MESSAGE_FLAGS(VM_INFOKEY.MESSAGE_NUMBER) = %YES#;
            MESSAGES_OUT = MESSAGES_OUT + 1;
            END;
           ELSE
            WRITE_RECORD = %NO#;
 
        CASE (%VM_TYPE_SITE,
              %VM_TYPE_TO,
              %VM_TYPE_ITO,
              %VM_TYPE_C,
              %VM_TYPE_IC,
              %VM_TYPE_BC,
              %VM_TYPE_IBC,
              %VM_TYPE_RTO);
 
         VM_INFOKEY = VM_INPUT_KEY;
 
         WRITE_RECORD = MESSAGE_FLAGS(VM_INFOKEY.MESSAGE_NUMBER) &
          ~ CRUNCH_MAILBOX;
 
        CASE (%VM_TYPE_LIST, %VM_TYPE_USER);
 
         WRITE_RECORD = %YES#;
 
        CASE (%VM_TYPE_BODY, %VM_TYPE_TRACE);
 
         VM_BODYKEY = VM_INPUT_KEY;
 
         WRITE_RECORD = MESSAGE_FLAGS(VM_BODYKEY.MESSAGE_NUMBER);
 
        CASE (%VM_TYPE_ID);
 
         VM_ID = DATA_BUFFER;
 
         WRITE_RECORD = MESSAGE_FLAGS(VM_ID.MESSAGE_NUMBER);
 
        CASE (ELSE);
 
         BAD_RECORDS = %YES#;
 
        END;
 
      IF WRITE_RECORD
        THEN DO;
 
         WRITE_OUT.BUF_ = VECTOR(DATA_BUFFER);
         WRITE_OUT.BUF_.BOUND = M$IN$ -> F$DCB.ARS# - 1;
 
         CALL M$WRITE (WRITE_OUT) ALTRET (AIEE);
 
         RECORDS_OUT = RECORDS_OUT + 1;
 
         END;
 
      END;
 
MAYBE_DONE:
 
   IF B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$EOF
     THEN
AIEE: CALL REPORT_ERROR_IN_TCB;
 
   RETURN;
 
END READ_THROUGH_FILE;
 
%EJECT;
WRITE_PROFILE: PROC;
 
   VM_PROFILE.NUM_MESSAGES = MESSAGES_OUT;
   VM_PROFILE.NUM_NEW_MESSAGES = 0;
   VM_PROFILE.NUM_DEL_MESSAGES = 0;
   VM_PROFILE.RECS_DELETED = 0;
   VM_PROFILE.HIGH_RECS = RECORDS_OUT;
 
   WRITE_OUT.BUF_ = VECTOR (VM_PROFILE);
   WRITE_OUT.BUF_.BOUND = PROFILE_SIZE - 1;
   WRITE_OUT.KEY_ = VECTOR(VM_PROKEY);
 
   CALL M$WRITE (WRITE_OUT) ALTRET (AIEE);
 
   RECORDS_OUT = RECORDS_OUT + 1;
 
   RETURN;
 
AIEE:
 
   CALL REPORT_ERROR_IN_TCB;
 
END WRITE_PROFILE;
 
%EJECT;
CLOSE_DCBS: PROC;
 
   CALL M$CLOSE (CLOSE_IN);
 
   CLOSE_OUT.V.DISP# = %SAVE#;
   CLOSE_OUT.V.OPER.REBLD# = %YES#;
   CLOSE_OUT.V.OPER.RELG# = %YES#;
 
   CALL M$CLOSE (CLOSE_OUT);
 
   RETURN;
 
END CLOSE_DCBS;
 
%EJECT;
PRINT_STATS: PROC;
 
   CALL STORE (STATUS.MESSAGES, MESSAGES_IN);
   CALL STORE (STATUS.RECORDS, RECORDS_IN);
   CALL STORE (STATUS.GRANULES, GRANULES_IN);
   STATUS.DIRECTION = 'read.';
   CALL M$WRITE (WRITE_STATUS);
 
   CALL STORE (STATUS.MESSAGES, MESSAGES_OUT);
   CALL STORE (STATUS.RECORDS, RECORDS_OUT);
   CALL STORE (STATUS.GRANULES, GRANULES_OUT);
   STATUS.DIRECTION = 'written.';
   CALL M$WRITE (WRITE_STATUS);
 
   RETURN;
 
   STORE: PROC (RESULT, INPUT);
 
   DCL RESULT CHAR (8);
   DCL INPUT UBIN;
   DCL TEMP CHAR (8);
   DCL MOPS (0:1) BIT (9) CALIGNED CONSTANT INIT (%MVZB7,%MVC1);
 
      CALL BINCHAR (TEMP, INPUT);
      CALL EDITCHAR (RESULT, , , MOPS, TEMP);
 
      RETURN;
 
   END STORE;
 
END PRINT_STATS;
 
%EJECT;
GET_OUTPUT_FILE_SIZE: PROC;
 
   OPEN_OUT.FPARAM_ = VECTOR (FPARAM_BUFFER);
   OPEN_OUT.IFPARAM_ = VECTOR (NIL);
   OPEN_OUT.V.FUN# = %IN#;
   OPEN_OUT.V.OPER.TEST# = %YES#;
 
   CALL M$OPEN (OPEN_OUT) ALTRET (AIEE);
 
   CALL FIND_GRANULE_COUNT (GRANULES_OUT);
 
   RETURN;
 
AIEE:
 
   CALL REPORT_ERROR_IN_TCB;
 
END GET_OUTPUT_FILE_SIZE;
 
%EJECT;
FIND_GRANULE_COUNT: PROC (GRANULES);
 
DCL GRANULES SBIN WORD;
DCL FIT$ PTR;
 
   FIT$ = ADDR(FPARAM_BUFFER);
 
   CALL XSF$LOCCODP (FIT$, 3)
     WHENRETURN DO;
      GRANULES = FIT$ -> CODE03.UGRANS;
      END;
     WHENALTRETURN DO;
      GRANULES = 0;
      END;
 
   RETURN;
 
END FIND_GRANULE_COUNT;
 
REPORT_ERROR_IN_TCB: PROC;
 
   REPORT_ERROR_MESSAGE_FROM_TCB.V.DCB# = B$TCB.ALT$ -> B$ALT.DCB#;
 
   CALL M$ERRMSG (REPORT_ERROR_MESSAGE_FROM_TCB);
 
   CALL EXIT_WITH_CODE (%STEPCC_IO_ERROR);
 
END REPORT_ERROR_IN_TCB;
 
EXIT_WITH_CODE: PROC (STEPCC);
 
DCL STEPCC UBIN;
 
   XUG_GETCMD.DCB_PARAM# = DCBNUM(NIL);
 
   CALL XUG$CLOSE_DCBS (XUG_GETCMD);
 
   FPT_EXIT.V.STEPCC# = STEPCC;
   CALL M$EXIT (FPT_EXIT);
 
END EXIT_WITH_CODE;
 
%EJECT;
   CALL HATCH_CRUNCHBIRD;
   CALL READ_PROFILE;
   CALL READ_THROUGH_FILE;
   CALL WRITE_PROFILE;
   CALL CLOSE_DCBS;
   CALL GET_OUTPUT_FILE_SIZE;
   CALL PRINT_STATS;
 
   IF BAD_RECORDS
     THEN
      CALL EXIT_WITH_CODE (%STEPCC_UNKNOWN_RECORD);
     ELSE
      CALL EXIT_WITH_CODE (%STEPCC_OK);
 
END CRUNCHBIRD;
