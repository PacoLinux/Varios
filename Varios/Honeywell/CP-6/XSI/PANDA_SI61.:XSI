/*M* PANDA - PROGRAM TO IDENTIFY CONTENTS OF DISK SECTORS */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
PANDA_MAIN:   PROC    MAIN;
/**/
%INCLUDE CP_6;
%INCLUDE XUG_ENTRY;
%INCLUDE XU_MACRO_C;
/**/
%XUG_INIT(NAME=XUGI, PCB=P_PCB, SYNTAX=YES, GOODCMD=YES,
          ABORT=PANDA_INT, ALWAYS_SET_PROMPT=NO);
%XUG_GETCMD(STCLASS=SYMREF);
%P_PCB(NAME=P_PCB, STCLASS=STATIC);
%FPT_INT(UENTRY=XUG$BREAK);
%FPT_XCON(UENTRY=PANDA_XCON);
/**/
DCL    PANDA      ENTRY;
DCL    PANDA_INT  ENTRY ASYNC;
DCL    PANDA_XCON ENTRY ASYNC;
/**/
/**/
       CALL M$INT(FPT_INT);
       CALL XUG$INIT(XUG_GETCMD, XUGI);
       CALL M$XCON(FPT_XCON);
       CALL PANDA;
END PANDA_MAIN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
PANDA:    PROC;
/*  Include files  */
%INCLUDE CP_6;
%INCLUDE XU_FORMAT_C;
%INCLUDE XUG_ENTRY;
%INCLUDE XU_MACRO_C;
%INCLUDE CP_6_SUBS;
%INCLUDE B_ERRORS_C;
%INCLUDE FM$GRAN;
%INCLUDE FM$SET;
%INCLUDE FM$FIT;
%INCLUDE FM$CFU;
%INCLUDE B$JIT;
%INCLUDE B_SEGIDS_C;
%INCLUDE NI$TABLES;
/*  Based structures  */
%FM$FIT(BASED="BASED(F$CFU$)");
%FM$SET(BASED="BASED(F$CFU$)");
%FM$DEV(BASED="BASED(F$CFU$)");
%FM$VOL(BASED="BASED(F$CFU$)");
%FM$CFUX(BASED="BASED(F$CFU$)");
%FM$GRAN(BASED="BASED(G$)");
%FM$GP(BASED="BASED(GP$)");
%FM$ADKEY(BASED="BASED(ADKEY$)");
%FM$KEYTBL(BASED="BASED(KT$)");
%NI$DCT(STCLASS="BASED(DCT$)");
%NI$DVT(STCLASS="BASED(DVT$)");
%B$TCB(STCLASS="BASED(B$TCB$)");
%B$ALT;
%F$DCB(STCLASS="BASED(DCB$)");
%PARSE$OUT(NAME=PARSOUT);
%PARSE$SYM(NAME=PARSYM, STCLASS="BASED(SBLK$)");
%CODE01(BASED="BASED(FIT$)");
DCL    N$DCT$(0:500)   BASED PTR;
DCL 1  DA(0:31)        BASED(DA$),
     2     LOCATED     BIT(1) UNAL,
     2     IX          UBIN(8) UNAL;
DCL    ACCT_7(0:7)     BASED(ACCT_7$) UBIN(7) UNAL;
/*  Static structures  */
%FPT_OPEN(FPTN=OPNDP, DCB=M$DP,
                      RES='DP',
                      FUN=IN,
                      SN=OPNSN,
                      ASN=DEVICE);
%FPT_CLOSE(FPTN=CLSDP, DCB=M$DP);
%FPT_READ(FPTN=RDDP, DCB=M$DP, BUF=BUF0,
                               WAIT=YES,
                               KEYS=YES,
                               KEY=GRAN#);
%FPT_SAD(MONSID=%DS1SID, USERSID=%SPCL1SID);
%FPT_OPEN(FPTN=OPNXT, DCB=M$EI,
                      FPARAM=BUF0,
                      ASN=FILE,
                      TEST=YES,
                      NXTF=YES,
                      ACS=BLOCK,
                      FUN=IN,
                      ACCT=VLP_ACCT,
                      SN=OPNXT_SN);
%VLP_ACCT;
%VLP_SN(FPTN=OPNXT_SN, N=1);
%FPT_PRIV(AUTH=YES);
%F_FDS(NAME=FDS, BUF=BUFL, DCB=M$LO);
%FPT_MONINFO(MONPTRS=VLR_MONPTRS);
%VLR_MONPTRS;
%FPT_PROMPT(DCB=M$SI, PROMPT=PROMPT0);
%FPT_ERRMSG(FPTN=DP_ERRMSG,SOURCE=ALTRET, RESULTS=VLR_ERRMSG,
            OUTDCB1=M$LO,BUF=BUFL, DCB=M$DP);
%FPT_ERRMSG(FPTN=EI_ERRMSG,SOURCE=ALTRET, RESULTS=VLR_ERRMSG,
            OUTDCB1=M$LO,BUF=BUFL, DCB=M$EI);
%VLR_ERRMSG;
%XUG_GETCMD(ALWAYS_SET_PROMPT=NO, STCLASS="STATIC SYMDEF");
/*  DCBs  */
DCL    M$DP            DCB;
DCL    M$LO            DCB;
DCL    M$EI            DCB;
DCL    M$SI            DCB;
/*  AUTO storage  */
DCL    CODE            UBIN;
DCL    ADKEY$          PTR;
DCL    KT$             PTR;
DCL    BLK$            PTR;
DCL    TBLK$           PTR;
DCL    SBLK$           PTR;
DCL    IX0             UBIN;
DCL    IX1             UBIN;
DCL    IX2             UBIN;
DCL    IX3             UBIN;
DCL    IX4             UBIN;
DCL    IX5             UBIN;
DCL    IX6             UBIN;
DCL    IX7             UBIN;
DCL    IX8             SBIN;
DCL    SUM             SBIN;
DCL    ADR             UBIN;
DCL    EADR            UBIN;
DCL    NN              UBIN;
DCL    GRAN            UBIN;
DCL    PADGRAN         UBIN;
DCL    PREV_GRAN       SBIN;
DCL    SIZE            UBIN;
DCL    FIT$            PTR;
DCL    CCC             UBIN;
DCL    HH              UBIN;
DCL    SS              UBIN;
DCL    SECT            UBIN;
DCL    TRACKS          UBIN;
DCL    DLA             UBIN;
DCL    TIME            UBIN;
DCL    ERR             UBIN;
DCL    WRVEC1      BIT(72);
DCL    WRVEC2      BIT(72);
DCL    WRVEC3      BIT(72);
DCL    WRVEC4      BIT(72);
DCL    DCT$            PTR;
DCL 1  DCT$_RDF        REDEF DCT$,
     2     *           UBIN(24) UNAL,
     2     SEGID       BIT(12) UNAL;
DCL    DVT$            PTR;
DCL 1  DVT$_RDF        REDEF DVT$,
     2     *           UBIN(24) UNAL,
     2     SEGID       BIT(12) UNAL;
DCL    DCB$            PTR;
DCL    DA$             PTR;
DCL    N$DCT$$         PTR;
DCL 1  N$DCT$$_RDF     REDEF N$DCT$$,
     2     *           UBIN(24) UNAL,
     2     SEGID       BIT(12) UNAL;
DCL    ACCT_7$         PTR;
DCL    ACCT_9(0:7)     UBIN(9) UNAL;
/*  Static storage  */
DCL 1  PSNTBL      STATIC,
     2     IX          UBIN UNAL,
     2     NSECTS      UBIN UNAL,
     2     VOL(0:31),
      3        NN          UBIN UNAL,
      3        FDA         UBIN UNAL,
      3        SRFDA       UBIN UNAL,
      3        SRLDA       UBIN UNAL,
      3        SIZE        UBIN UNAL;
DCL 1  DVCTBL      STATIC,         /* Device data                    */
     2     NN          UBIN UNAL,  /* Device number..DPNN            */
     2     VSN         UBIN UNAL,  /* Volume serial number           */
     2     DCTX        UBIN UNAL,  /* DCT index                      */
     2     NSECTS      UBIN(18) UNAL, /* Number of sections on device*/
     2     NDAS        UBIN(18) UNAL, /* Total# of disk addrs to find*/
     2     SECTS(0:35),            /* Section data                   */
      3        PSN         CHAR(6) UNAL, /* Packset name; blank means*/
                                         /* it is available          */
      3        RPSN        CHAR(6) UNAL, /* Real pack set name       */
      3        SIZE        UBIN UNAL,    /* Size in grans of section */
      3        FREE        UBIN UNAL,    /* Number of free grans     */
      3        FDA         UBIN UNAL,    /* Device relative 1st da   */
      3        LDA         UBIN UNAL,    /* Device relative last da  */
      3        VOL#        UBIN(18) UNAL, /* Which vol number of set */
      3        CHECK       BIT(1) UNAL,  /* Should full check be done*/
      3        *           BIT(17) UNAL,
      3        NDAS        UBIN(9) UNAL, /* # disk adrs to find in  */
      3        TNDAS       UBIN(9) UNAL, /* Total# of das this sect */
      3        HD          SBIN(9) UNAL,  /* Points to 1st section   */
                                          /* on the dev that's part  */
                                          /* of the psn.  -1->none.   */
      3        LINK        SBIN(9) UNAL,  /* Points to next section  */
                                          /* on dev that's part of   */
                                          /* the psn. -1->last piece  */
                                          /* this section            */
      3        NVIDS       UBIN(18) UNAL, /* Total# of VIDs processed*/
      3        NGPS        UBIN(18) UNAL, /* Total# of GPs processed */
      3        NPADS       UBIN(18) UNAL, /* Total# of PADs processed*/
      3        NMADS       UBIN(18) UNAL, /* Total# of MADs processed*/
      3        NFDS        UBIN UNAL,     /* Total# of FDs processed */
      3        NFILE       UBIN UNAL,     /* # file grans processed  */
      3        NFREE       UBIN UNAL,     /* # free grans processed  */
      3        DAS       CHAR(32) UNAL;   /* See based structure     */
                                          /* DA...IXs to dsk adrs    */
DCL 1  GDA(0:31) STATIC,
     2     GRAN        SBIN UNAL,
     2     RGN         SBIN UNAL,
     2     ADR,
      3        CCC         UBIN(18) UNAL,
      3        HH          UBIN(9) UNAL,
      3        SS          UBIN(9) UNAL;
DCL    BUFL            CHAR(120) STATIC;
DCL    BUF0            CHAR(4096) STATIC;
DCL    BUF1            CHAR(4096) STATIC;
DCL    PANDA_READ      REMEMBER STATIC SYMDEF;
DCL    PRIVSAV         BIT(36) STATIC SYMDEF;
DCL    PRIVS           BIT(36) STATIC;
DCL 1  PROMPT0         STATIC CHAR UNAL INIT('-');
DCL    PROMPT1     STATIC CHAR UNAL INIT('     Address>>');
DCL 1  OPNSN           STATIC,
     2     *           UBIN UNAL INIT(1),
     2     *           UBIN(9) UNAL INIT(0),
     2     *           CHAR(0) UNAL INIT('DP'),
     2     NN          CHAR(2) UNAL,
     2     *           CHAR(1) UNAL INIT(' ');
DCL    FLEN            UBIN STATIC;
DCL    F$CFU$X         BIT(36) STATIC INIT('000000006021'O);
DCL    F$CFU$          REDEF F$CFU$X PTR;
DCL    G$              PTR STATIC INIT(ADDR(BUF0));
DCL    GP$             PTR STATIC;
DCL    BUF1$           PTR STATIC INIT(ADDR(BUF1));
DCL    FM_SRZERO       UBIN STATIC INIT(67174400); /* '400200000'O */
DCL    FM_FRZERO       UBIN STATIC INIT(262144);  /* '1000000'O */
DCL    FM_GP           UBIN STATIC INIT(1);
DCL    FM_PAD          UBIN STATIC INIT(2);
DCL    FM_AD           UBIN STATIC INIT(3);
DCL    GRAN#           UBIN STATIC INIT(0);
DCL    CTYP(0:4)       STATIC CHAR(3) UNAL INIT('VID', 'GP ', 'PAD', 'MAD',
                                                'FD ');
DCL    ERRMSG(0:4) STATIC BIT(72) INIT(VECTOR(MSG2), VECTOR(MSG3),
                                       VECTOR(MSG13), VECTOR(MSG14),
                                       VECTOR(MSG15));
DCL    FMT0            CHAR(0) STATIC INIT('%0A');
DCL    FMT0_           CHAR(0) STATIC INIT('%/%0A%2/');
DCL    FMT1            CHAR(0) STATIC INIT('DP%2ZD%0A');
DCL    FMT2            CHAR(0) STATIC INIT(
       'DP%2ZD|%6D%3S%1A|%6>A-%2ZD|%6D|%6D%2(|%4ZD-%2ZD-%2ZD|%8D%)');
DCL    FMT3            CHAR(0) STATIC INIT(
       '%5X%6D%3S%1A|%6>A-%2ZD|%6D|%6D%2(|%4ZD-%2ZD-%2ZD|%8D%)');
DCL    FMT4            CHAR(0) STATIC INIT(
       'DP%2ZD|%6D%3S%1A|available|%6D|%6D%2(|%4ZD-%2ZD-%2ZD|%8D%)');
DCL    FMT5            CHAR(0) STATIC INIT(
       '%5X%6D%3S%1A|available|%6D|%6D%2(|%4ZD-%2ZD-%2ZD|%8D%)');
DCL    FMT6            CHAR(0) STATIC INIT(
'%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) not part of any of the %2ZD pack sections');
DCL    FMT7            CHAR(0) STATIC INIT(
       '%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) part of available %D%3S%1A');
DCL    FMT8            CHAR(0) STATIC INIT(
       '%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) part of free granule of #%6LA');
DCL    FMT9            CHAR(0) STATIC INIT(
       '%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) part of file %0.3F');
DCL    FMT10           CHAR(0) STATIC INIT(
       '%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) was not located');
DCL    FMT11           CHAR(0) STATIC INIT(
'Analysis of #%6L>A requires disk DP%2ZD which is currently unavailable');
DCL    FMT12           CHAR(0) STATIC INIT(
'%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) part of %3A for #%6LA');
DCL    FMT13           CHAR(0) STATIC INIT(
       '%3A checking prematurely terminated for #%6LA');
DCL    FMT14           CHAR(0) STATIC INIT(
       '%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) part of #CP-6''S');
DCL    FMT15           CHAR(0) STATIC INIT(
'%4.18ZD-%2.9ZD-%2.9ZD(%6ZD) part of file directory for account DP#%6L>A.%8LA');
DCL    FMT16           CHAR(0) STATIC INIT('%64A%10S');
DCL    FMT17           CHAR(0) STATIC INIT(
'%6D%3S%1A|%6>A-%2ZD|%4(%4.18D|%)%2(%8D|%)%8D');
DCL    FMT18           CHAR(0) STATIC INIT(
'%6D%3S%1A|available|%4(%4.18D|%)%2(%8D|%)%8D');
DCL    FMT19           CHAR(0) STATIC INIT(
'%12X|%6>A-%2ZD|%6X|%6X|%10X|%8X|%10X|%8X');
DCL    MSG0            CHAR(0) STATIC INIT(
                       'FMDIAG, SPCLMM and FMSEC required here');
DCL    MSG1            CHAR(0) STATIC INIT(
                       'FMSEC required to use SEARCH command');
DCL    MSG2            CHAR(0) STATIC INIT(' not spinning');
DCL    MSG3            CHAR(0) STATIC INIT(' does not exist');
DCL    MSG4            CHAR(0) STATIC INIT(
'DEV |       |Pack Set |      | Free |First Disk Address |Final Disk Address');
DCL    MSG5            CHAR(0) STATIC INIT(
'NAME|  VSN  |Name-vol#| Size | Grans|CCCC-HH-SS|Granule#|CCCC-HH-SS|Granule#');
DCL    MSG6            CHAR(0) STATIC INIT(
'--------------------------------------------------------------------------');
DCL    MSG7            CHAR(0) STATIC INIT('...not a valid disk address');
DCL    MSG8            CHAR(0) STATIC INIT(
'* * * *   Summary of Granules Processed during Search    * * * *');
DCL    MSG9            CHAR(0) STATIC INIT(
'       |Pack Set |       Number of Granules Checked');
DCL    MSG10           CHAR(0) STATIC INIT(
'  VSN  |Name-vol#|VIDs| GPs|PADs|MADs|  FDs   |  File  |  Free');
DCL    MSG11       CHAR(0) STATIC INIT(
'...granule number exceeds maximum for this device');
DCL    MSG12       CHAR(0) STATIC INIT(
'Enter addresses as CCCC-HH-SS or as device relative granule number(DLA).');
DCL    MSG13       CHAR(0) STATIC INIT(' mirror of device DP  ');
DCL    MSG14       CHAR(0) STATIC INIT(' awaiting mirror device');
DCL    MSG15       CHAR(0) STATIC INIT(' restoring from DP  ');
/*  External references */
DCL    B$JIT$          PTR SYMREF;
DCL    B$TCB$          PTR SYMREF;
DCL    PANDA_CMDS     UBIN SYMREF;
DCL    PANDA_DAS      UBIN SYMREF;
DCL    X$WRITE         ENTRY(22);
DCL    XSF$LOCCODT     ENTRY(2) ALTRET;
/*  Equates  */
%EQU   PDISPLAY# = 1;
%EQU   PSRCH#    = 2;
%EQU   PEND#     = 3;
%EQU   PDADR#   = 4;
%EQU   PDLA#    = 5;
/**/
       REMEMBER NXT_CMD IN PANDA_READ;
       PRIVS = %PR_FMSEC# | %PR_SPCLMM# | %PR_FMDIAG#;
       PRIVSAV = PRIVS & B$JIT.PRIV.ACTIVE;
       FPT_PRIV.V.PRIV# = PRIVS;
       CALL M$SPRIV(FPT_PRIV)
         WHENALTRETURN DO;
           IF ~(B$JIT.PRIV.ACTIVE & (%PR_SPCLMM# | %PR_FMDIAG#)) THEN DO;
               CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG0));
               CALL M$EXIT;
               END;
           CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG1));
           END;
       CALL M$SAD(FPT_SAD) ALTRET(PANDA_ABORT);
       CALL M$MONINFO(FPT_MONINFO) ALTRET(PANDA_ABORT);
       FPT_SAD.V.USERSID# = %SPCL2SID;
       FPT_SAD.V.MONSID# = %TIGRSID;
       CALL M$SAD(FPT_SAD) ALTRET(PANDA_ABORT);
       N$DCT$$ = VLR_MONPTRS.N$DCT$$;
       N$DCT$$_RDF.SEGID = %SPCL2SID;
       FPT_SAD.V.USERSID# = %SPCL3SID;
       FPT_SAD.V.MONSID# = %DVTTBLSID;
       CALL M$SAD(FPT_SAD) ALTRET(PANDA_ABORT);
       DCB$ = DCBADDR(DCBNUM(M$DP));
NXT_CMD:   ;
       XUG_GETCMD.NODES$ = ADDR(PANDA_CMDS);
       XUG_GETCMD.PROMPT_ = VECTOR(PROMPT0);
       CALL XUG$GETCMD(XUG_GETCMD) ALTRET(PANDA_ABORT);
       BLK$ = XUG_GETCMD.OUT$;
       CODE = PARSOUT.SUBLK$(0)->PARSOUT.CODE;
       BLK$ = PARSOUT.SUBLK$(0);
       IX0 = FM$CFUX.DSETH;
       DO CASE(CODE);
         CASE(%PDISPLAY#);
           TIME = 0;
           IF PARSOUT.NSUBLKS = 0 THEN DO;
               DO WHILE(IX0 ~= 0);
                   NN = 0; /* Indicate all devices */
                   CALL DEVICE;
                   CALL DEVICE_OUTPUT;
NXT_DVC:   ;
                   END; /* END DO WHILE */
               END; /* END IF */
           ELSE DO;
               DO IX7 = 0 TO PARSOUT.NSUBLKS - 1;
                   SBLK$ = PARSOUT.SUBLK$(IX7);
                   CALL CHARBIN(NN, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   IF NN = 0 THEN DO;
                       CALL X$WRITE(FDS, VECTOR(FMT1),
                                         VECTOR(NN), VECTOR(MSG3));
                       GOTO NXT_DPNN;
                       END;
                   CALL DEVICE;
                   CALL DEVICE_OUTPUT;
NXT_DPNN:  ;
               IX0 = FM$CFUX.DSETH;
                   END; /* END DO IX7 */
               END; /* END ELSE DO */
         CASE(%PSRCH#);
           IF PARSOUT.NSUBLKS = 2 THEN
               SUM = 0;  /* Indicate summary requested */
           ELSE
               SUM = -1; /* No summary */
           SBLK$ = PARSOUT.SUBLK$(0);
           CALL CHARBIN(NN,SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
           CALL DEVICE;
           IF ERR ~= 0 THEN DO;
               CALL DEVICE_OUTPUT;
               GOTO NXT_CMD;
               END; /* END IF */
           DCT$ = N$DCT$$->N$DCT$(DVCTBL.DCTX);
           DCT$_RDF.SEGID = %SPCL2SID;
           DVT$ = NI$DCT.DVT$;
           DVT$_RDF.SEGID = %SPCL3SID;
           GP$ = PINCRW(G$, 5);
           IX6 = 0;
           CALL X$WRITE(FDS, VECTOR(FMT0_), VECTOR(MSG12));
           DO WHILE(IX6 < 32);
NXT_DA:    ;
               XUG_GETCMD.NODES$ = ADDR(PANDA_DAS);
               XUG_GETCMD.PROMPT_ = VECTOR(PROMPT1);
               CALL XUG$GETCMD(XUG_GETCMD) ALTRET(PANDA_ABORT);
               BLK$ = XUG_GETCMD.OUT$;
               CODE = PARSOUT.SUBLK$(0)->PARSOUT.CODE;
               DO CASE(CODE);
                 CASE(%PEND#);
                   IF IX6 = 0 THEN
                       GOTO NXT_CMD;
                   ELSE
                       GOTO PROCESS_DAS;
                 CASE(%PDADR#);
                   SBLK$ = PARSOUT.SUBLK$(0)->PARSOUT.SUBLK$(0);
                   CALL CHARBIN(CCC, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   GDA.ADR.CCC(IX6) = CCC;
                   SBLK$ = PARSOUT.SUBLK$(0)->PARSOUT.SUBLK$(1);
                   CALL CHARBIN(HH, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   GDA.ADR.HH(IX6) = HH;
                   SBLK$ = PARSOUT.SUBLK$(0)->PARSOUT.SUBLK$(2);
                   CALL CHARBIN(SS, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   GDA.ADR.SS(IX6) = SS;
                   IF CCC > (NI$DVT.PACKSIZE  * NI$DVT.GRANSIZE)/NI$DVT.CYLSIZE |
                      HH > NI$DVT.CYLSIZE/NI$DVT.SPT | SS > NI$DVT.SPT - 1 THEN DO;
                       CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG7));
                       GOTO NXT_DA;
                       END; /* END IF */
                   GDA.GRAN(IX6) = (CCC*NI$DVT.CYLSIZE + HH*NI$DVT.SPT + SS)/
                                   NI$DVT.GRANSIZE;
                   GDA.RGN(IX6) = GDA.GRAN(IX6);
                 CASE(%PDLA#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   CALL CHARBIN(DLA, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   IF DLA > NI$DVT.PACKSIZE THEN DO;
                       CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG11));
                       GOTO NXT_DA;
                       END;
                   GDA.GRAN(IX6) = DLA;
                   GDA.RGN(IX6) = DLA;
                   SECT = DLA * NI$DVT.GRANSIZE;
                   CCC = SECT / NI$DVT.CYLSIZE;
                   GDA.ADR.CCC(IX6) = CCC;
                   TRACKS = MOD(SECT, NI$DVT.CYLSIZE);
                   HH = TRACKS / NI$DVT.SPT;
                   GDA.ADR.HH(IX6) = HH;
                   SS = MOD(TRACKS, NI$DVT.SPT);
                   GDA.ADR.SS(IX6) = SS;
                   END; /* END DO CASE */
               IX6 = IX6 + 1;
               END; /* END DO WHILE */
PROCESS_DAS:   ;
           CALL M$PROMPT(FPT_PROMPT);
           DO IX4 = 0 TO IX6 - 1;
               DO IX5 = 0 TO DVCTBL.NSECTS - 1;
                   IF GDA.GRAN(IX4) >= DVCTBL.SECTS.FDA(IX5) &
                      GDA.GRAN(IX4) <= DVCTBL.SECTS.LDA(IX5) THEN DO;
                       DA$ = ADDR(DVCTBL.SECTS.DAS(IX5));
                       DA.IX(DVCTBL.SECTS.NDAS(IX5)) = IX4;
                       DVCTBL.SECTS.TNDAS(IX5) = DVCTBL.SECTS.TNDAS(IX5) + 1;
                       DVCTBL.SECTS.NDAS(IX5) = DVCTBL.SECTS.NDAS(IX5) + 1;
                       DVCTBL.NDAS = DVCTBL.NDAS + 1;
                       GOTO DA_IN_SECT;
                       END; /* END IF */
                   END; /* DO IX5 */
               IX3 = DVCTBL.NSECTS;
               CALL X$WRITE(FDS, VECTOR(FMT6), VECTOR(GDA.ADR(IX4)),
                                 VECTOR(GDA.RGN(IX4)), VECTOR(IX3));
DA_IN_SECT:    ;
               END; /* END DO IX4 */
%EJECT;
           DO IX6 = 0 TO DVCTBL.NSECTS - 1;
/**/
/* First, check if granule is part of available section */
/**/
               CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
               DA$ = ADDR(DVCTBL.SECTS.DAS(IX6));
               GRAN# = 0;
               IF DVCTBL.SECTS.PSN(IX6) = ' ' |
                  DVCTBL.SECTS.PSN(IX6) = 'CP-6''S' THEN DO;
                   IX0 = IX6 + 65;
                   DO IX5 = 0 TO DVCTBL.SECTS.TNDAS(IX6) - 1;
                       DA.LOCATED(IX5) = %YES#;
                       GDA.GRAN(DA.IX(IX5)) = -1;
                       DVCTBL.NDAS = DVCTBL.NDAS - 1;
                       DVCTBL.SECTS.NDAS(IX6) = DVCTBL.SECTS.NDAS(IX6) - 1;
                       IF DVCTBL.SECTS.PSN(IX6) = ' ' THEN
                           CALL X$WRITE(FDS, VECTOR(FMT7),
                                             VECTOR(GDA.ADR(DA.IX(IX5))),
                                             VECTOR(GDA.RGN(DA.IX(IX5))),
                                             VECTOR(DVCTBL.VSN), VECTOR(IX0));
                       ELSE
                           CALL X$WRITE(FDS, VECTOR(FMT14),
                                       VECTOR(GDA.ADR(DA.IX(IX5))),
                                       VECTOR(GDA.RGN(DA.IX(IX5))));
                       END;    /* END DO IX5 */
                   GOTO SECTION_DONE;
                   END; /* END IF */
%EJECT;
/**/
/* Check VIDs of sections */
/**/
               PREV_GRAN = -1;
               DO IX2 = 0 TO DVCTBL.SECTS.TNDAS(IX6) - 1;
                   IF ~ DA.LOCATED(IX2) &
                        DVCTBL.SECTS.FDA(IX6) = GDA.GRAN(DA.IX(IX2)) THEN DO;
                       DA.LOCATED(IX2) = %YES#;
                       GDA.GRAN(DA.IX(IX2)) = -1;
                       DVCTBL.NDAS = DVCTBL.NDAS - 1;
                       DVCTBL.SECTS.NDAS(IX6) = DVCTBL.SECTS.NDAS(IX6) - 1;
                       CALL X$WRITE(FDS, VECTOR(FMT12),
                                         VECTOR(GDA.ADR(DA.IX(IX2))),
                                         VECTOR(GDA.RGN(DA.IX(IX2))),
                                         VECTOR(CTYP(0)),
                                         VECTOR(DVCTBL.SECTS.PSN(IX6)));
                       END; /* END IF */
                   END; /* END DO IX2 */
               DVCTBL.SECTS.NVIDS(IX6)=DVCTBL.SECTS.NVIDS(IX6)+1;
               CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
%EJECT;
/**/
/* Check Granule Pool (GP), PAD and MAD granules */
/**/
               IF ~ DVCTBL.SECTS.CHECK(IX6) THEN
                   GOTO SECTION_DONE;
               RDDP.BUF_ = VECTOR(BUF0);
               CALL PACKSET
                 WHENALTRETURN DO;
                   CALL X$WRITE(FDS, VECTOR(FMT11),
                                     VECTOR(DVCTBL.SECTS.PSN(IX6)),
                                     VECTOR(PSNTBL.VOL.NN(PSNTBL.IX)));
                   GOTO NXT_CMD;
                   END; /* END WHENALTRETURN */
               PSNTBL.IX = 0;
               DO IX0 = FM_GP TO FM_AD;
                   FM$GRAN.FLINK = PSNTBL.VOL.SRFDA(0) + IX0 + FM_SRZERO;
                   DO WHILE(FM$GRAN.FLINK ~= 0);
                       GRAN# = FM$GRAN.FLINK - FM_SRZERO;
CHK_GP0:   ;
                       CALL GRAN_CHECK ALTRET(NXT_GP0);
                       CALL X$WRITE(FDS, VECTOR(FMT12),
                           VECTOR(GDA.ADR(DA.IX(IX2))),
                           VECTOR(GDA.RGN(DA.IX(IX2))),
                           VECTOR(CTYP(IX0)),
                           VECTOR(DVCTBL.SECTS.PSN(IX8)));
                       GOTO CHK_GP0;
NXT_GP0:   ;
                       CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
                       DA$ = ADDR(DVCTBL.SECTS.DAS(IX6));
                       CALL READ_GRAN
                         WHENALTRETURN DO;
                           CALL X$WRITE(FDS, VECTOR(FMT13),
                                           VECTOR(CTYP(IX0)),
                                           VECTOR(DVCTBL.SECTS.PSN(IX6)));
                           GOTO NXT_GP1;
                           END; /* END WHENALTRETURN */
                       END; /* END DO WHILE */
NXT_GP1:   ;
                   END; /* END DO IX0 */
NXT_FREE0: ;
               CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
%EJECT;
/**/
/* Check to see if any of the granules are free in this section */
/**/
               GRAN# = PSNTBL.VOL.SRFDA(0) + FM_GP;
NXT_FREE1: ;
               CALL READ_GRAN
                 WHENALTRETURN DO;
                   CALL X$WRITE(FDS, VECTOR(FMT13), VECTOR(CTYP(1)),
                           VECTOR(DVCTBL.SECTS.PSN(IX6)));
                   GOTO NXT_PAD0;
                   END; /* END WHENALTRETURN DO */
               IX8 = IX6;
               DO WHILE(IX8 >= 0);
                   IF FM$GP.VOL = DVCTBL.SECTS.VOL#(IX8) THEN
                       GOTO CHK_FREE;
                   IX8 = DVCTBL.SECTS.LINK(IX8);
                   END; /* END DO WHILE */
               GOTO NXT_FREE3; /* Get another GP granule */
CHK_FREE:  ;
               IF DVCTBL.SECTS.NDAS(IX8) = 0 THEN
                   GOTO NXT_FREE3; /* Get another GP granule */
               DA$ = ADDR(DVCTBL.SECTS.DAS(IX8));
               DO IX4 = 0 TO FM$GP.XTNS - 1;
                   IF FM$GP.XTN.ADR(IX4) = 262143 THEN
                       GOTO NXT_FREE5;
                   ADR = FM$GP.XTN.ADR(IX4) + DVCTBL.SECTS.FDA(IX8);
                   EADR = FM$GP.XTN.EADR(IX4) + DVCTBL.SECTS.FDA(IX8);
                   DVCTBL.SECTS.NFREE(IX8)=DVCTBL.SECTS.NFREE(IX8)+EADR-ADR;
                   DO IX5 = 0 TO DVCTBL.SECTS.TNDAS(IX8) - 1;
                       IF ~ DA.LOCATED(IX5) &
                          GDA.GRAN(DA.IX(IX5)) >= ADR &
                          GDA.GRAN(DA.IX(IX5)) < EADR THEN DO;
                           CALL X$WRITE(FDS, VECTOR(FMT8),
                                   VECTOR(GDA.ADR(DA.IX(IX5))),
                                   VECTOR(GDA.RGN(DA.IX(IX5))),
                                   VECTOR(DVCTBL.SECTS.PSN(IX8)));
                           DA.LOCATED(IX5) = %YES#;
                           GDA.GRAN(DA.IX(IX5)) = -1;
                           DVCTBL.NDAS = DVCTBL.NDAS - 1;
                           DVCTBL.SECTS.NDAS(IX8) =
                               DVCTBL.SECTS.NDAS(IX8) - 1;
                           IF DVCTBL.SECTS.NDAS(IX8) = 0 THEN
                               GOTO NXT_FREE4;
                           END; /* END IF */
                       END; /* END DO IX5 */
NXT_FREE5: ;
                   END; /* END DO IX4 */
NXT_FREE4: ;
               DA$ = ADDR(DVCTBL.SECTS.DAS(IX6));
               IF FM$GP.N THEN DO;
NXT_FREE2: ;
                   CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
                   GRAN# = FM$GRAN.FLINK - FM_SRZERO;
                   GOTO NXT_FREE1;
                   END; /* END IF */
NXT_FREE3: ;
               IF FM$GRAN.FLINK ~= 0 THEN
                   GOTO NXT_FREE2;
NXT_PAD0:  ;
               CALL M$CLOSE(CLSDP) WHENALTRETURN DO; END;
%EJECT;
/**/
/* Check FDs for this packset */
/**/
               PADGRAN = PSNTBL.VOL.SRFDA(0) + FM_PAD + FM_SRZERO;
               DO WHILE(PADGRAN ~= 0);
                   GRAN# = PADGRAN - FM_SRZERO;
                   RDDP.BUF_ = VECTOR(BUF0);
                   CALL READ_GRAN
                     WHENALTRETURN DO;
                       CALL X$WRITE(FDS, VECTOR(FMT13), VECTOR(CTYP(2)),
                                         VECTOR(DVCTBL.SECTS.PSN(IX6)));
                       GOTO FILE_CHK;
                       END; /* END WHENALTRETURN DO */
                   KT$ = PINCRW(G$, FM$GRAN.FCEX);
                   DO IX4 = 1 TO FM$GRAN.KEYCNT;
                       IF FM$KEYTBL(0) > IX4 THEN
                           ADKEY$ = PINCRW(G$, FM$KEYTBL(IX4));
                       ELSE
                           ADKEY$ = PINCRW(G$, FM$KEYTBL(IX4) + 512);
                       GRAN# = FM$ADKEY.FDSDA - FM_SRZERO;
CHK_FD:    ;
                       IX0 = 4;
                       CALL GRAN_CHECK ALTRET(NXT_FLNKD_FD);
                       ACCT_7$ = ADDR(FM$ADKEY.ENCACCT);
                       DO IX0 = 0 TO 7;
                           ACCT_9(IX0) = ACCT_7(IX0);
                           END; /* END DO IX0 */
                       CALL X$WRITE(FDS, VECTOR(FMT15),
                                         VECTOR(GDA.ADR(DA.IX(IX2))),
                                         VECTOR(GDA.RGN(DA.IX(IX2))),
                                         VECTOR(DVCTBL.SECTS.PSN(IX6)),
                                         VECTOR(ACCT_9));
                       GOTO CHK_FD;
NXT_FLNKD_FD:  ;
                       CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
                       RDDP.BUF_ = VECTOR(BUF1);
                       CALL READ_GRAN
                         WHENALTRETURN DO;
                           CALL X$WRITE(FDS, VECTOR(FMT13), VECTOR(CTYP(4)),
                                             VECTOR(DVCTBL.SECTS.PSN(IX6)));
                           GOTO NXT_FD;
                           END; /* END WHENALTRETURN DO */
                       IF BUF1$ -> FM$GRAN.FLINK ~= 0 THEN DO;
                           GRAN# = BUF1$ -> FM$GRAN.FLINK - FM_SRZERO;
                           GOTO CHK_FD;
                           END; /* END IF */
NXT_FD:    ;
                       END; /* END DO IX4 */
                   PADGRAN = FM$GRAN.FLINK;
                   END; /* END DO WHILE */
%EJECT;
FILE_CHK:  ;
/**/
/* Check if remaining granules of this pack are allocated to any file */
/**/
               OPNXT_SN.SN#(0) = DVCTBL.SECTS.PSN(IX6);
               CODE = 1;
               VLP_ACCT.ACCT# = '$$$$$$$$';
               OPNXT.ACCT_ = VECTOR(VLP_ACCT);
NEXT_ACCT: ;
               CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
NEXT_ACCT0: ;
               OPNXT.V.OPER.NXTA# = %YES#;
               CALL M$OPEN(OPNXT)
                 WHENALTRETURN DO;
                   IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$ADEOF THEN
                       GOTO SECTION_DONE;
                   IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$FDEOF |
                      B$TCB.ALT$->B$ALT.ERR.CODE = %E$NOKEY THEN DO;
                       OPNXT.ACCT_ = VECTOR(NIL);
                       GOTO NEXT_ACCT;
                       END; /* END IF */
                   GOTO PANDA_ERR_EI;
                   END;
               OPNXT.ACCT_ = VECTOR(NIL);
               OPNXT.V.OPER.NXTA# = %NO#;
NEXT_FILE0:    ;
               FIT$ = PINCRW(G$, 5);
               CALL XSF$LOCCODT(FIT$, CODE) ALTRET(NEXT_FILE1);
               DO IX4 = 0 TO CODE01.NXTNTS - 1;
                   GRAN = CODE01.XTNT.XTNSDA(IX4) - FM_SRZERO;
/* Is extent in any section of the packset on this device */
                   IX8 = IX6;
                   DO WHILE(IX8 >= 0);
                       IX1 = DVCTBL.SECTS.VOL#(IX8) - 1;
                       IF GRAN >= PSNTBL.VOL.SRFDA(IX1) &
                          GRAN <= PSNTBL.VOL.SRLDA(IX1) THEN DO;
                           GRAN = GRAN - PSNTBL.VOL.SRFDA(IX1) +
                                  DVCTBL.SECTS.FDA(IX8);
                           GOTO CHK_XTNT;
                           END; /* END IF */
                       IX8 = DVCTBL.SECTS.LINK(IX8);
                       END; /* END DO WHILE */
                   GOTO NXT_XTNT;
CHK_XTNT:  ;
                   DA$ = ADDR(DVCTBL.SECTS.DAS(IX8));
                   IF CODE01.XTNT.XTNSIZE(IX4) = 0 THEN
                       SIZE = CODE01.EXTNT.XTNSIZE(IX4) - 1;
                   ELSE
                       SIZE = CODE01.XTNT.XTNSIZE(IX4) - 1;
                   DVCTBL.SECTS.NFILE(IX8) = DVCTBL.SECTS.NFILE(IX8) + SIZE+1;
                   IF DVCTBL.SECTS.NDAS(IX8) = 0 THEN
                       GOTO NXT_XTNT;
                   DO IX5 = 0 TO DVCTBL.SECTS.TNDAS(IX8) - 1;
                       IF ~ DA.LOCATED(IX5) &
                          GDA.GRAN(IX5) >= GRAN &
                          GDA.GRAN(IX5) <= GRAN + SIZE THEN DO;
                           NN = DCBNUM(M$EI);
                           CALL X$WRITE(FDS, VECTOR(FMT9),
                                        VECTOR(GDA.ADR(IX5)),
                                        VECTOR(GDA.RGN(IX5)),
                                        VECTOR(NN));
                           DA.LOCATED(IX5) = %YES#;
                           GDA.GRAN(DA.IX(IX5)) = -1;
                           DVCTBL.NDAS = DVCTBL.NDAS - 1;
                           DVCTBL.SECTS.NDAS(IX8) =
                               DVCTBL.SECTS.NDAS(IX8) - 1;
                           IF DVCTBL.SECTS.NDAS(IX8) = 0 THEN
                               GOTO NXT_XTNT;
                           END; /* END IF */
                       END; /* END DO IX5 */
NXT_XTNT:  ;
                   DA$ = ADDR(DVCTBL.SECTS.DAS(IX6));
                   END; /* END DO IX4 */
NEXT_FILE1:    ;
               CALL M$OPEN(OPNXT)
                 WHENALTRETURN DO;
                   IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$FDEOF THEN
                       GOTO NEXT_ACCT;
                   ELSE
                       GOTO PANDA_ERR_EI;
                   END; /* END WHENALTRETURN */
               CALL GRAN_LEFT_CHECK ALTRET(SECTION_DONE);
               GOTO NEXT_FILE0;
SECTION_DONE:  ;
               IF F$DCB.FCD# THEN
                   CALL M$CLOSE(CLSDP) ALTRET(PANDA_ERR_DP);
               END; /* END DO IX6 */
           IF DVCTBL.NDAS ~= 0 THEN DO;
               IX5 = 0;
               DO WHILE(DVCTBL.NDAS ~= 0);
                   IF GDA.GRAN(IX5) ~= -1 THEN DO;
                       CALL X$WRITE(FDS, VECTOR(FMT10),
                                          VECTOR(GDA.ADR(IX5)),
                                          VECTOR(GDA.RGN(IX5)));
                       DVCTBL.NDAS = DVCTBL.NDAS - 1;
                       END; /* END IF */
                   IX5 = IX5 + 1;
                   END; /* END DO WHILE */
               END; /* END IF */
           IF SUM = -1 THEN
               GOTO NXT_CMD;
/* Output summary information for various granules processed */
/**/
           CALL X$WRITE(FDS, VECTOR(FMT0_), VECTOR(MSG8));
           CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG9));
           CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG10));
           CALL X$WRITE(FDS, VECTOR(FMT16), VECTOR(MSG6));
           DO IX0 = 0 TO DVCTBL.NSECTS - 1;
               SECT = IX0 + 65;
               IX5 = DVCTBL.SECTS.VOL#(IX0);
               IF DVCTBL.SECTS.PSN(IX0) = ' ' THEN DO;
                   WRVEC1 = VECTOR(FMT18);
                   WRVEC2 = VECTOR(NIL);
                   WRVEC3 = VECTOR(NIL);
                   END; /* END IF */
               ELSE DO;
                   WRVEC1 = VECTOR(FMT17);
                   WRVEC2 = VECTOR(DVCTBL.SECTS.PSN(IX0));
                   WRVEC3 = VECTOR(IX5);
                   END;
               CALL X$WRITE(FDS, WRVEC1,
                   VECTOR(DVCTBL.VSN), VECTOR(SECT), WRVEC2, WRVEC3,
                   VECTOR(DVCTBL.SECTS.NVIDS(IX0)),
                   VECTOR(DVCTBL.SECTS.NGPS(IX0)),
                   VECTOR(DVCTBL.SECTS.NPADS(IX0)),
                   VECTOR(DVCTBL.SECTS.NMADS(IX0)),
                   VECTOR(DVCTBL.SECTS.NFDS(IX0)),
                   VECTOR(DVCTBL.SECTS.NFILE(IX0)),
                   VECTOR(DVCTBL.SECTS.NFREE(IX0)));
               END; /* END DO IX0 */
         END; /* END DO CASE */
       GOTO NXT_CMD;
PANDA_ABORT:  ;
       CALL M$XXX;
PANDA_ERR_DP:  ;
       CALL M$ERRMSG(DP_ERRMSG);
       GOTO NXT_CMD;
PANDA_ERR_EI:  ;
       CALL M$ERRMSG(EI_ERRMSG);
       GOTO NXT_CMD;
%EJECT;
GRAN_LEFT_CHECK:   PROC ALTRET;
/**/
       IX8 = IX6;
       DO WHILE(IX8 >= 0);
           IF DVCTBL.SECTS.NDAS(IX8) ~= 0 THEN
               RETURN;
           IX8 = DVCTBL.SECTS.LINK(IX8);
           END; /* END DO WHILE */
       ALTRETURN;
END GRAN_LEFT_CHECK;
%EJECT;
GRAN_CHECK:    PROC    ALTRET;
/**/
       IX8 = IX6;
       DO WHILE(IX8 >= 0);
           IX1 = DVCTBL.SECTS.VOL#(IX8) - 1;
           IF GRAN# >= PSNTBL.VOL.SRFDA(IX1) &
              GRAN# <= PSNTBL.VOL.SRLDA(IX1) THEN DO;
               IF GRAN# = PREV_GRAN THEN
                   GOTO GRAN_CHECK0;
               PREV_GRAN = GRAN#; /* Remember this gran# */
               DO CASE(IX0);
                 CASE(1); /* GP granule */
                   DVCTBL.SECTS.NGPS(IX8) = DVCTBL.SECTS.NGPS(IX8) + 1;
                 CASE(2); /* PAD granule */
                   DVCTBL.SECTS.NPADS(IX8) = DVCTBL.SECTS.NPADS(IX8) + 1;
                 CASE(3); /* MAD granule */
                   DVCTBL.SECTS.NMADS(IX8) = DVCTBL.SECTS.NMADS(IX8) + 1;
                 CASE(4); /* FD granule */
                   DVCTBL.SECTS.NFDS(IX8) = DVCTBL.SECTS.NFDS(IX8) + 1;
                   END; /* DO CASE */
GRAN_CHECK0:   ;
               GRAN = GRAN# - PSNTBL.VOL.SRFDA(IX1) +
                      DVCTBL.SECTS.FDA(IX8);
               DO IX2 = 0 TO DVCTBL.SECTS.TNDAS(IX8) - 1;
                   IF ~DA.LOCATED(IX2) &
                      GRAN = GDA.GRAN(DA.IX(IX2)) THEN DO;
                       DA.LOCATED(IX2) = %YES#;
                       GDA.GRAN(DA.IX(IX2)) = -1;
                       DVCTBL.NDAS = DVCTBL.NDAS - 1;
                       DVCTBL.SECTS.NDAS(IX8) =
                            DVCTBL.SECTS.NDAS(IX8) - 1;
                       RETURN;
                       END; /* END IF */
                   END; /* END DO IX2 */
               END; /* END IF */
           IX8 = DVCTBL.SECTS.LINK(IX8);
           DA$ = ADDR(DVCTBL.SECTS.DAS(IX8));
           END; /* END DO WHILE */
       DA$ = ADDR(DVCTBL.SECTS.DAS(IX6));
       ALTRETURN;
END GRAN_CHECK;
%EJECT;
READ_GRAN: PROC    ALTRET;
/**/
/* Reads set relative granule number in GRAN# for the set defined in  */
/* the table PSNTBL.                                                  */
/**/
DCL    IX1         UBIN;
/**/
       IF ~F$DCB.FCD# THEN DO;
           IX1 = 0;
READ_GRAN0:    ;
           CALL BINCHAR(OPNSN.NN, PSNTBL.VOL.NN(IX1));
           PSNTBL.IX = IX1;
           CALL M$OPEN(OPNDP)
             WHENALTRETURN DO;
READ_GRAN_ALT: ;
               CALL M$ERRMSG(DP_ERRMSG);
               ALTRETURN;
               END;
READ_GRAN1:    ;
           GRAN# = GRAN# - PSNTBL.VOL.SRFDA(IX1) + PSNTBL.VOL.FDA(IX1);
           CALL M$READ(RDDP) ALTRET(READ_GRAN_ALT);
           RETURN;
           END; /* END IF */
       ELSE DO;
           DO IX1 = 0 TO PSNTBL.NSECTS - 1;
               IF GRAN# >= PSNTBL.VOL.SRFDA(IX1) &
                  GRAN# <= PSNTBL.VOL.SRFDA(IX1) +
                           PSNTBL.VOL.SIZE(IX1) - 1 THEN DO;
                   IF PSNTBL.VOL.NN(IX1) ~= PSNTBL.VOL.NN(PSNTBL.IX) THEN DO;
                       CALL M$CLOSE(CLSDP) WHENALTRETURN DO; END;
                       GOTO READ_GRAN0;
                       END; /* END IF */
                   ELSE
                       GOTO READ_GRAN1;
                   END; /* END IF */
               END; /* END DO IX1 */
           END; /* END ELSE DO */
END READ_GRAN;
%EJECT;
PACKSET:   PROC    ALTRET;
/**/
/* Find all the sections of the packset identified by DVCTBL.SECTS.PSN(IX6) */
/* and complete the table PSNTBL.                                           */
/**/
DCL    IX1         UBIN;
DCL    IX2         UBIN;
DCL    IX3         UBIN;
/**/
       PSNTBL.IX = 511;
       PSNTBL.NSECTS = 0;
       IX0 = FM$CFUX.DSETH;
       DO WHILE(IX0 ~= 0);
           IX1 = FM$DEV.SECTL(IX0);
           DO WHILE(IX1 ~= 0);
               IF FM$VOL.SETX(IX1) ~= 0 THEN DO;
                   IX2 = FM$VOL.SETX(IX1);
                   IF FM$SET.PSN(IX2) = DVCTBL.SECTS.PSN(IX6) THEN DO;
                       PSNTBL.NSECTS = PSNTBL.NSECTS + 1;
                       IX3 = FM$VOL.VOL#(IX1) - 1;
                       IF IX3 = 0 THEN
                           PSNTBL.IX = 0; /* Found primary volume of set */
                       PSNTBL.VOL.NN(IX3) = FM$DEV.NN(IX0);
                       PSNTBL.VOL.FDA(IX3) = FM$VOL.DRZERO(IX1);
                       PSNTBL.VOL.SIZE(IX3) = FM$VOL.NXTSDA(IX1) - FM_SRZERO;
                       END; /* END IF */
                   IF ~ FM$DEV.SPIN(IX0) THEN DO;
                       PSNTBL.IX = IX3; /* Point to unavailable pack */
                       ALTRETURN;
                       END; /* END IF */
                   END; /* END IF */
               IX1 = FM$VOL.SECTL(IX1);
               END; /* DO WHILE */
           IX0 = FM$DEV.DEVL(IX0);
           END; /* END DO WHILE */
       IF PSNTBL.IX = 511 THEN
           ALTRETURN;
       PSNTBL.VOL.SRFDA(0) = 0;
       PSNTBL.VOL.SRLDA(0) = PSNTBL.VOL.SIZE(0) - 1;
       DO IX1 = 1 TO PSNTBL.NSECTS - 1;
           PSNTBL.VOL.SRFDA(IX1) = PSNTBL.VOL.SRFDA(IX1-1) +
                                    PSNTBL.VOL.SIZE(IX1-1);
           PSNTBL.VOL.SRLDA(IX1) = PSNTBL.VOL.SRFDA(IX1) +
                                   PSNTBL.VOL.SIZE(IX1) - 1;
           END; /* END DO IX1 */
       RETURN;
END PACKSET;
%EJECT;
DEVICE:    PROC;
/**/
       ERR = 0;
           DVCTBL.NN = NN;
       IF NN ~= 0 THEN DO; /* Find the device requested */
           DO WHILE(IX0 ~= 0);
               IF NN = FM$DEV.NN(IX0) THEN
                   GOTO PROCESS_DVC;
               IX0 = FM$DEV.DEVL(IX0);
               END; /* END DO WHILE */
           ERR = 2; /* Device does not exist */
           RETURN;
           END; /* END IF */
       DVCTBL.NN = FM$DEV.NN(IX0);
PROCESS_DVC:   ;
       IF ~FM$DEV.SPIN(IX0) THEN DO;
           ERR = 1;
           IX0 = FM$DEV.DEVL(IX0);
           RETURN;
           END;
       ELSE
           IF FM$DEV.MIRROR(IX0) AND FM$DEV.SECTL(IX0) = 0 THEN DO;
               IX8 = FM$DEV.MRRDCTX(IX0);
               IF IX8 = 0 THEN DO;
                   ERR = 3; /* Awaiting mirror device */
                   END;
               ELSE
                   IF IX8 < 0 THEN DO;
                       IX8 = -IX8;
                       ERR = 4; /* Restoring from DPnn */
                       DCT$ = N$DCT$$->N$DCT$(IX8);
                       DCT$_RDF.SEGID = %SPCL2SID;
                       IX1 = NI$DCT.DVN;
                       CALL BINCHAR(SUBSTR(MSG15,18, 2), IX1);
                       END;
                   ELSE DO;
                       ERR = 3; /* Mirror of device DPnn */
                       DCT$ = N$DCT$$->N$DCT$(IX8);
                       DCT$_RDF.SEGID = %SPCL2SID;
                       IX1 = NI$DCT.DVN;
                       CALL BINCHAR(SUBSTR(MSG13,20,2), IX1);
                       END;
               IX0 = FM$DEV.DEVL(IX0);
               RETURN;
               END;
       DO IX6 = 0 TO 31;
           DVCTBL.SECTS.HD(IX6) = -1;
           DVCTBL.SECTS.LINK(IX6) = -1;
           END; /* END DO IX6 */
       IX1 = 0;
       IX2 = FM$DEV.SECTL(IX0);
       DVCTBL.VSN = FM$DEV.VSN(IX0);
           IX1 = 0;
       DVCTBL.DCTX = FM$DEV.DCTX(IX0);
       DVCTBL.NDAS = 0;
       IX0 = FM$DEV.DEVL(IX0);
       DO WHILE(IX2 ~= 0);
           DVCTBL.SECTS.VOL#(IX1) = FM$VOL.VOL#(IX2);
           DVCTBL.SECTS.SIZE(IX1) = FM$VOL.NXTSDA(IX2) - FM_SRZERO;
           DVCTBL.SECTS.FREE(IX1) = FM$VOL.RGRANS(IX2);
           DVCTBL.SECTS.FDA(IX1) = FM$VOL.DRZERO(IX2);
           IF FM$VOL.SETX(IX2) = 0 THEN
               DVCTBL.SECTS.PSN(IX1) = ' ';
           ELSE DO;
               IX3 = FM$VOL.SETX(IX2);
               DVCTBL.SECTS.PSN(IX1) = FM$SET.PSN(IX3);
               DVCTBL.SECTS.RPSN(IX1) = FM$SET.REALPSN(IX3);
               END;
           DVCTBL.SECTS.LDA(IX1) = FM$VOL.DRZERO(IX2) + FM$VOL.NXTSDA(IX2)
                                   - FM_SRZERO - 1;
           IF CODE = %PSRCH# THEN DO;
               DVCTBL.SECTS.NDAS(IX1) = 0;
               DVCTBL.SECTS.TNDAS(IX1) = 0;
               DVCTBL.SECTS.CHECK(IX1) = %YES#;
               DA$ = ADDR(DVCTBL.SECTS.DAS(IX1));
               DO IX6 = 0 TO 31;
                   DA.LOCATED(IX6) = %NO#;
                   DA.IX(IX6) = 0;
                   END; /* END DO IX6 */
               END; /* END DO IF */
           DVCTBL.SECTS.NVIDS(IX1) = 0;
           DVCTBL.SECTS.NGPS(IX1) = 0;
           DVCTBL.SECTS.NPADS(IX1) = 0;
           DVCTBL.SECTS.NMADS(IX1) = 0;
           DVCTBL.SECTS.NFDS(IX1) = 0;
           DVCTBL.SECTS.NFILE(IX1) = 0;
           DVCTBL.SECTS.NFREE(IX1) = 0;
           IX1 = IX1 + 1;
           IX2 = FM$VOL.SECTL(IX2);
           END;
       DVCTBL.NSECTS = IX1;
       IF CODE = %PSRCH# THEN DO;
           DO IX6 = 1 TO DVCTBL.NSECTS - 1;
               IF DVCTBL.SECTS.PSN(IX6) = ' ' THEN
                   GOTO DEVICE0;
               DO IX5 = 0 TO IX6 - 1;
                   IF DVCTBL.SECTS.PSN(IX5) = DVCTBL.SECTS.PSN(IX6) THEN DO;
                       DVCTBL.SECTS.CHECK(IX6) = %NO#;
                       DVCTBL.SECTS.HD(IX6) = IX5;
                       IX4 = IX5;
                       DO WHILE(DVCTBL.SECTS.LINK(IX4) >= 0);
                           IX4 = DVCTBL.SECTS.LINK(IX4);
                           END; /* END DO WHILE */
                       DVCTBL.SECTS.LINK(IX4) = IX6;
                       END; /* END IF */
                   END; /* END DO IX5 */
DEVICE0:   ;
               END; /* END DO IX6 */
           END; /* END IF */
       RETURN;
END DEVICE;
%EJECT;
DEVICE_OUTPUT: PROC;
DCL    FCC         UBIN;
DCL    FHH         UBIN;
DCL    FSS         UBIN;
DCL    LCC         UBIN;
DCL    LHH         UBIN;
DCL    LSS         UBIN;
DCL    SECTOR      UBIN;
/**/
       IF NN = 0 THEN DO;
           IF TIME = 0 THEN DO;
               TIME = 1;
               CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG4));
               CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG5));
               CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG6));
               END;
           IF ERR ~= 0 THEN DO;
               CALL X$WRITE(FDS, VECTOR(FMT1), VECTOR(DVCTBL.NN),
                                 ERRMSG(ERR-1));
               RETURN;
               END;
           END;
       ELSE DO;
           IF ERR ~= 0 THEN DO;
               CALL X$WRITE(FDS, VECTOR(FMT1), VECTOR(DVCTBL.NN),
                                 ERRMSG(ERR-1));
               RETURN;
               END;
           ELSE DO;
               IF TIME = 0 THEN DO;
                   TIME = 1;
                   CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG4));
                   CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG5));
                   CALL X$WRITE(FDS, VECTOR(FMT0), VECTOR(MSG6));
                   END;
               END;
           END;
       IX1 = DVCTBL.NSECTS - 1;
       DCT$ = N$DCT$$->N$DCT$(DVCTBL.DCTX);
       DCT$_RDF.SEGID = %SPCL2SID;
       DVT$ = NI$DCT.DVT$;
       DVT$_RDF.SEGID = %SPCL3SID;
       DO IX2 = 0 TO IX1;
           SECT = IX2 + 65; /* Set section ... i.e., A, B, C,... */
           IX5 = DVCTBL.SECTS.VOL#(IX2);
           SECTOR = DVCTBL.SECTS.FDA(IX2) * NI$DVT.GRANSIZE;
           FCC = SECTOR/NI$DVT.CYLSIZE;
           IX6 = NI$DVT.CYLSIZE/NI$DVT.SPT;
           FHH = MOD(SECTOR/NI$DVT.SPT, IX6);
           FSS = MOD(SECTOR, NI$DVT.SPT);
           SECTOR = DVCTBL.SECTS.LDA(IX2) * NI$DVT.GRANSIZE;
           LCC = SECTOR/NI$DVT.CYLSIZE;
           LHH = MOD(SECTOR/NI$DVT.SPT, IX6);
           LSS = MOD(SECTOR, NI$DVT.SPT);
           IF IX2 = 0 THEN DO;
               IF DVCTBL.SECTS.PSN(IX2) = ' ' THEN DO;
                   WRVEC1 = VECTOR(FMT4);
                   WRVEC2 = VECTOR(NIL);
                   WRVEC3 = VECTOR(NIL);
                   WRVEC4 = VECTOR(DVCTBL.SECTS.SIZE(IX2));
                   END;
               ELSE DO;
                   WRVEC1 = VECTOR(FMT2);
                   WRVEC2 = VECTOR(DVCTBL.SECTS.PSN(IX2));
                   WRVEC3 = VECTOR(IX5);
                   WRVEC4 = VECTOR(DVCTBL.SECTS.FREE(IX2));
                   END;
               CALL X$WRITE(FDS, WRVEC1, VECTOR(DVCTBL.NN),
                                 VECTOR(DVCTBL.VSN), VECTOR(SECT),
                                 WRVEC2, WRVEC3,
                                 VECTOR(DVCTBL.SECTS.SIZE(IX2)), WRVEC4,
                                 VECTOR(FCC), VECTOR(FHH), VECTOR(FSS),
                                 VECTOR(DVCTBL.SECTS.FDA(IX2)), VECTOR(LCC),
                                 VECTOR(LHH), VECTOR(LSS),
                                 VECTOR(DVCTBL.SECTS.LDA(IX2)));
               END;
           ELSE DO;
               IF DVCTBL.SECTS.PSN(IX2) = ' ' THEN DO;
                   WRVEC1 = VECTOR(FMT5);
                   WRVEC2 = VECTOR(NIL);
                   WRVEC3 = VECTOR(NIL);
                   WRVEC4 = VECTOR(DVCTBL.SECTS.SIZE(IX2));
                   END;
               ELSE DO;
                   WRVEC1 = VECTOR(FMT3);
                   WRVEC2 = VECTOR(DVCTBL.SECTS.PSN(IX2));
                   WRVEC3 = VECTOR(IX5);
                                 WRVEC4 = VECTOR(DVCTBL.SECTS.FREE(IX2));
                   END;
               CALL X$WRITE(FDS, WRVEC1,
                                 VECTOR(DVCTBL.VSN), VECTOR(SECT),
                                 WRVEC2, WRVEC3,
                                 VECTOR(DVCTBL.SECTS.SIZE(IX2)), WRVEC4,
                                 VECTOR(FCC), VECTOR(FHH), VECTOR(FSS),
                                 VECTOR(DVCTBL.SECTS.FDA(IX2)), VECTOR(LCC),
                                 VECTOR(LHH), VECTOR(LSS),
                                 VECTOR(DVCTBL.SECTS.LDA(IX2)));
               END;
           IF DVCTBL.SECTS.RPSN(IX2) ~= ' ' &
              DVCTBL.SECTS.PSN(IX2) ~= ' ' THEN
               CALL X$WRITE(FDS, VECTOR(FMT19), VECTOR(DVCTBL.SECTS.RPSN(IX2)),
                                 VECTOR(IX5));
           END;
       RETURN;
END DEVICE_OUTPUT;
END PANDA;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
PANDA_XCON:   PROC    ASYNC;
%INCLUDE CP_6;
%FPT_PRIV;
%FPT_XCON;
DCL    PRIVSAV     BIT(36) SYMREF;
DCL    FLAG        SBIN STATIC INIT(-1);
DCL    FLAG_RDF    REDEF FLAG BIT(36);
DCL    PANDA_READ  REMEMBER SYMREF;
/**/
       PRIVSAV = PRIVSAV \ FLAG_RDF;
       FPT_PRIV.V.PRIV# = PRIVSAV;
       CALL M$RPRIV(FPT_PRIV)
         WHENALTRETURN DO; END;
       CALL M$XCON(FPT_XCON);
       CALL M$EXIT;
PANDA_INT: ENTRY   ASYNC;
       UNWIND TO PANDA_READ;
END PANDA_XCON;
