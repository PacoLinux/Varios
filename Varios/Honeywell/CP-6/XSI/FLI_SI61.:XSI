/*M* FLI_SI61:  Frame list integrator.  */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMC,PLM=4,IND=0,DCI=4,CSI=2,IAD=2,DTI=2,AND,ECI=0,DIN=2,STI=2 */
 
FLI: PROC MAIN;
 
  %INCLUDE CP_6;
  %INCLUDE CP_6_SUBS;
  %INCLUDE B$JIT;
  %INCLUDE B_ERRORS_C;
  %INCLUDE Q_MACRO_C;
  %INCLUDE XUG_ENTRY;
  %INCLUDE XU_MACRO_C;
  %INCLUDE XU_PERR_C;
  %INCLUDE XU_SUBS_C;
  %SET LISTINC = '1'B;
  %INCLUDE FLI_C61;
 
  %Q_FPABT ( FPTN = Q$FPABT, STCLASS = "BASED ( CG_IN$ )" );
 
  DCL B$JIT$ PTR SYMREF;
  DCL B$TCB$ PTR SYMREF;
 
  %B$TCB;
  %B$ALT;
 
  %FPT_TRMCTL ( TRMCTL = VLP_TRMCTL );
  %VLP_TRMCTL;
 
  %FPT_ERRMSG ( BUF = SYSTEM_ERROR_MESSAGE, CODE = VLP_ERRCODE );
  %FPT_ERRMSG ( FPTN = ERRMSG_FROM_FPL, BUF = SYSTEM_ERROR_MESSAGE,
                CODE = VLP_ERRCODE, /* L6_CODE = YES, */
                FILENAME = COLON_QQERRMSG, OUTDCB1 = M$LO );
  %VLP_NAME ( FPTN = COLON_QQERRMSG, NAME = ':QQERRMSG' );
  %VLP_ERRCODE;
  DCL SYSTEM_ERROR_MESSAGE CHAR(360) STATIC;
 
  %FPT_FID ( ACCT = FPL_SOURCE_ACCT, ASN = OPEN_FPL_SOURCE.V.ASN#,
             NAME = FPL_SOURCE_NAME, PASS = FPL_SOURCE_PASS,
             RES = OPEN_FPL_SOURCE.V.RES#, SN = FPL_SOURCE_SN,
             WSN = FPL_SOURCE_SN );
  %VLP_ACCT ( FPTN = FPL_SOURCE_ACCT );
  %VLP_NAME ( FPTN = FPL_SOURCE_NAME );
  %VLP_PASS ( FPTN = FPL_SOURCE_PASS );
  %VLP_SN ( FPTN = FPL_SOURCE_SN );
  %VLP_WSN ( FPTN = FPL_SOURCE_WSN );
 
  %FPT_OPEN ( FPTN = OPEN_SI_AS_TP_MONSTER,
              DCB = M$SI, FUN = UPDATE, EXIST = OLDFILE );
  %FPT_OPEN ( FPTN = OPEN_SI_AS_TIMESHARING_FORM,
              DCB = M$SI, FUN = CREATE, ORG = FPRG, RES = 'UC07' );
  %FPT_SETFP ( FPTN = SETFP_SI, DCB = M$SI, FPRG = VLP_FPRG );
  %VLP_FPRG ( NAME = 'FLI_FORM', ACCT = 'X' );
  %FPT_OPEN ( FPTN = OPEN_LO, DCB = M$LO, FUN = CREATE,
              EXIST = NEWFILE );
  %FPT_OPEN ( FPTN = OPEN_FPL_SOURCE, FUN = IN,
              EXIST = OLDFILE, DCB = M$EI,
              ACCT = FPL_SOURCE_ACCT,
              NAME = FPL_SOURCE_NAME, PASS = FPL_SOURCE_PASS,
              SN = FPL_SOURCE_SN,
              WSN = FPL_SOURCE_WSN );
  %FPT_OPEN ( FPTN = OPEN_MUSH_SOURCE, FUN = CREATE,
              EXIST = NEWFILE, DCB = M$EO, ASN = FILE, CTG = YES,
              NAME = MUSH_SOURCE_NAME, ORG = INDEXED,
              ACS = DIRECT, ALTKEYS = VLP_ALTKEYS );
  %FPT_OPEN ( FPTN = OPEN_MUSH_SOURCE_ERROR, FUN = CREATE,
              EXIST = NEWFILE, DCB = M$DO, ASN = FILE, CTG = YES,
              NAME = MUSH_SOURCE_NAME_ERROR, ORG = INDEXED,
              ACS = DIRECT, ALTKEYS = VLP_ALTKEYS );
  %VLP_NAME ( FPTN = MUSH_SOURCE_NAME_ERROR,
              NAME = 'FLI_ERROR_xxxxxxxx' );
  %VLP_NAME ( FPTN = MUSH_SOURCE_NAME, NAME = '*FLI' );
  %VLP_ALTKEYS ( N = 2 );
 
  %FPT_PFIL ( FPTN = PFIL_MUSH_SOURCE, DCB = M$EO, BOF = YES );
  %FPT_PRECORD ( FPTN = PRECORD_MUSH_SOURCE, DCB = M$EO, N = -1, KEYR = YES );
 
  %FPT_READ ( FPTN = READ_CG, DCB = M$SI );
  %FPT_READ ( FPTN = READ_FPL_SOURCE, DCB = M$EI );
  %FPT_READ ( FPTN = READ_MUSH_SOURCE, DCB = M$EO, KEYS = YES, KEYCHNG = YES );
 
  %FPT_WRITE ( FPTN = WRITE_CG, DCB = M$SI );
  %FPT_WRITE ( FPTN = WRITE_FPL_SOURCE, DCB = M$EI );
  %FPT_WRITE ( FPTN = WRITE_LO, DCB = M$LO );
  %FPT_WRITE ( FPTN = WRITE_MUSH_SOURCE, DCB = M$EO );
  %FPT_WRITE ( FPTN = WRITE_MUSH_SOURCE_ERROR, DCB = M$DO );
 
  %FPT_DELREC ( FPTN = DELETE_MUSH_SOURCE, DCB = M$EO );
 
  %FPT_CLOSE ( FPTN = CLOSE_SI, DCB = M$SI, DISP = SAVE );
  %FPT_CLOSE ( FPTN = CLOSE_LO, DCB = M$LO, DISP = SAVE );
  %FPT_CLOSE ( FPTN = CLOSE_FPL_SOURCE, DCB = M$EI, DISP = SAVE );
  %FPT_CLOSE ( FPTN = CLOSE_MUSH_SOURCE_ERROR, DCB = M$DO, DISP = SAVE );
  %FPT_CLOSE ( FPTN = CLOSE_MUSH_SOURCE, DCB = M$EO, DISP = RELEASE );
  %FPT_CLOSE ( FPTN = CLOSE_MUSH_SOURCE_SAVE, DCB = M$DO, DISP = SAVE );
 
  %FPT_GDS ( FPTN = GDS_FOR_FRAME_WORK,
             RESULTS = GDS_VECTOR_FRAME_WORK,
             SEGSIZE = 1000 );
  %VLP_VECTOR ( FPTN = GDS_VECTOR_FRAME_WORK );
  %FPT_GDS ( FPTN = GDS_FOR_PICTURE_STRING_WORK,
             RESULTS = GDS_VECTOR_PICTURE_STRING_WORK,
             SEGSIZE = 1000 );
  %VLP_VECTOR ( FPTN = GDS_VECTOR_PICTURE_STRING_WORK );
  %FPT_GDS ( FPTN = GDS_FOR_PARSE_INPUT, RESULTS = GDS_VECTOR_INPUT,
             SEGSIZE = 1000 );
  %VLP_VECTOR ( FPTN = GDS_VECTOR_INPUT );
 
  %P_PCB ( NAME = FRAME_PCB, R = A_FRAME );
  %P_PCB ( NAME = PICTURE_STRING_PCB, R = A_PICTURE_STRING );
  %PARSE$OUT ( STCLASS = BASED );
  %PARSE$SYM ( STCLASS = BASED );
  DCL A_FRAME UBIN SYMREF;
  DCL A_PICTURE_STRING UBIN SYMREF;
  DCL X$PARSE ENTRY (1) ALTRET;
 
  DCL M$SI DCB;
  DCL M$LO DCB;
  DCL M$EI DCB;
  DCL M$EO DCB;
  DCL M$DO DCB;
 
  DCL 1 STATION,
        2 MESSAGE_TYPE CHAR(8) UNAL,
        2 MAX_FRAME_INDEX SBIN,
        2 FRAME_A(0:99),
          3 IS_ACTIVE CHAR(1) UNAL,
          3 FRAME_NAME CHAR(30) UNAL,
        2 MAXIMUM_SEQUENCE# UBIN,
        2 LEVEL#_INCREMENT UBIN;
 
  DCL 1 CLAUSES CONSTANT,
        2 ORIGIN,
          3 TEXT CHAR(0) INIT('ORIGIN IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.ORIGIN.TEXT)),
        2 IO,
          3 TEXT CHAR(0) INIT('I-O'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.IO.TEXT)),
        2 INPUT,
          3 TEXT CHAR(0) INIT('INPUT'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.INPUT.TEXT)),
        2 OUTPUT,
          3 TEXT CHAR(0) INIT('OUTPUT'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.OUTPUT.TEXT)),
        2 ENTRY_REQUIRED,
          3 TEXT CHAR(0) INIT('ENTRY-REQUIRED'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.ENTRY_REQUIRED.TEXT)),
        2 VISUAL_ATTRIBUTE,
          3 TEXT CHAR(0) INIT('ATTRIBUTE IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.VISUAL_ATTRIBUTE.TEXT)),
        2 REPEATS,
          3 TEXT CHAR(0) INIT('REPEATS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.REPEATS.TEXT)),
        2 TIMES,
          3 TEXT CHAR(0) INIT(' TIMES'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.TIMES.TEXT)),
        2 SEPARATED,
          3 TEXT CHAR(0) INIT(' SEPARATED BY '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.SEPARATED.TEXT)),
        2 POSITION,
          3 TEXT CHAR(0) INIT('POSITION IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.POSITION.TEXT)),
        2 LINE,
          3 TEXT CHAR(0) INIT('LINE '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.LINE.TEXT)),
        2 COLUMN,
          3 TEXT CHAR(0) INIT(' COLUMN '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.COLUMN.TEXT)),
        2 PICTURE,
          3 TEXT CHAR(0) INIT('PICTURE IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.PICTURE.TEXT)),
        2 SIGN_LEADING_SEPARATE,
          3 TEXT CHAR(0) INIT('SIGN LEADING SEPARATE CHARACTER'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.SIGN_LEADING_SEPARATE.TEXT)),
        2 SIGN_TRAILING,
          3 TEXT CHAR(0) INIT('SIGN TRAILING'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.SIGN_TRAILING.TEXT)),
        2 SIGN_TRAILING_SEPARATE,
          3 TEXT CHAR(0) INIT('SIGN TRAILING SEPARATE'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.SIGN_TRAILING_SEPARATE.TEXT)),
        2 BWZ,
          3 TEXT CHAR(0) INIT('BLANK WHEN ZERO'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.BWZ.TEXT)),
        2 CLASS,
          3 TEXT CHAR(0) INIT('CLASS IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.CLASS.TEXT)),
        2 MINIMUM_SIZE,
          3 TEXT CHAR(0) INIT('MINIMUM SIZE IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.MINIMUM_SIZE.TEXT)),
        2 FILL_CHARACTER,
          3 TEXT CHAR(0) INIT('FILL CHARACTER IS "'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.FILL_CHARACTER.TEXT)),
        2 END_QUOTE,
          3 TEXT CHAR(0) INIT('"'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.END_QUOTE.TEXT)),
        2 JUSTIFIED_RIGHT,
          3 TEXT CHAR(0) INIT('JUSTIFIED RIGHT'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.JUSTIFIED_RIGHT.TEXT)),
        2 CONSTANT_VALUE,
          3 TEXT CHAR(0) INIT('CONSTANT VALUE IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.CONSTANT_VALUE.TEXT)),
        2 DEFAULT_VALUE,
          3 TEXT CHAR(0) INIT('DEFAULT VALUE IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.DEFAULT_VALUE.TEXT)),
        2 PROMPT,
          3 TEXT CHAR(0) INIT('PROMPT IS '),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.PROMPT.TEXT)),
        2 A_O_I_M,
          3 TEXT CHAR(0) INIT('A-O-I-M'),
          3 LENGTH UBIN INIT(LENGTHC(CLAUSES.A_O_I_M.TEXT));
 
  DCL 1 WHATEVER_RECORD BASED,
        2 FUNCTION CHAR(2) UNAL,
        2 ERROR_CODE REDEF FUNCTION CHAR(2) UNAL,
        2 ERROR_TEXT CHAR(80) UNAL;
 
  DCL 1 INITIALIZE_RECORD BASED,
        2 FUNCTION CHAR(2) UNAL,
        2 ERROR_CODE REDEF FUNCTION CHAR(2) UNAL,
        2 MESSAGE_TYPE CHAR(80) UNAL,
        2 ERROR_TEXT REDEF MESSAGE_TYPE CHAR(80) UNAL;
 
  DCL 1 FID_RECORD BASED,
        2 FUNCTION CHAR(2) UNAL,
        2 ERROR_CODE REDEF FUNCTION CHAR(2) UNAL,
        2 FID CHAR(136) UNAL,
        2 ERROR_TEXT REDEF FID CHAR(136) UNAL,
        2 OLD_NEW CHAR(1) UNAL;
 
  DCL 1 FRAME_RECORD BASED,
        2 FUNCTION CHAR(2) UNAL,
        2 ERROR_CODE REDEF FUNCTION CHAR(2) UNAL,
        2 FRAME_NAME CHAR(80) UNAL,
        2 ERROR_TEXT REDEF FRAME_NAME CHAR(80) UNAL,
        2 IS_ACTIVE CHAR(1) UNAL;
 
  DCL 1 FIELD_RECORD BASED,
        2 FUNCTION CHAR(2) UNAL,
        2 ERROR_CODE REDEF FUNCTION CHAR(2) UNAL,
        2 ERROR_TEXT CHAR(80) UNAL,
        2 PICTURE_STRING_TYPE CHAR(1) UNAL,
        2 PICTURE_STRING_LENGTH CHAR(3) UNAL,
        2 PICTURE_STRING CHAR(%MAXIMUM_FIELD_LENGTH) UNAL,
        2 PICTURE_CLAUSE CHAR(30) UNAL,
        2 GROUP_SEQUENCE# CHAR(10) UNAL,
        2 GROUP_SEQUENCE#_PARTS REDEF GROUP_SEQUENCE#,
          3 INTEGER CHAR(5) UNAL,
          3 FRACTION CHAR(5) UNAL,
        2 LIKE_SEQUENCE# CHAR(10) UNAL,
        2 LIKE_SEQUENCE#_PARTS REDEF LIKE_SEQUENCE#,
          3 INTEGER CHAR(5) UNAL,
          3 FRACTION CHAR(5) UNAL,
        2 SEQUENCE# CHAR(10) UNAL,
        2 SEQUENCE#_PARTS REDEF SEQUENCE#,
          3 INTEGER CHAR(5) UNAL,
          3 FRACTION CHAR(5) UNAL,
        2 POSITION_X CHAR(3) UNAL,
        2 POSITION_Y CHAR(3) UNAL,
        2 FRAME_NAME CHAR(30) UNAL,
        2 ORIGIN_X CHAR(3) UNAL,
        2 ORIGIN_Y CHAR(3) UNAL,
        2 IS_ORIGIN_VALID CHAR(1) UNAL,
        2 LEVEL# CHAR(2) UNAL,
        2 NAME CHAR(30) UNAL,
        2 IS_DOWN_NAME_FOR_ABOVE CHAR(1) UNAL,
        2 IS_DOWN_NAME_FROM_BELOW CHAR(1) UNAL,
        2 IO_VALUE CHAR(2) UNAL,
        2 IO_FLAGS REDEF IO_VALUE,
          3 IS_INPUT CHAR(1) UNAL,
          3 IS_OUTPUT CHAR(1) UNAL,
        2 IS_IO_INHERITED CHAR(1) UNAL,
        2 IS_ENTRY_REQUIRED CHAR(1) UNAL,
        2 IS_ENTRY_REQUIRED_INHERITED CHAR(1) UNAL,
        2 IS_A_O_I_M CHAR(1) UNAL,
        2 IS_A_O_I_M_INHERITED CHAR(1) UNAL,
        2 CLASS CHAR(30) UNAL,
        2 VISUAL_ATTRIBUTE CHAR(30) UNAL,
        2 IS_VISUAL_ATTRIBUTE_INHERITED CHAR(1) UNAL,
        2 MINIMUM_SIZE CHAR(3) UNAL,
        2 FILL_CHARACTER CHAR(1) UNAL,
        2 SIGN CHAR(2) UNAL,
        2 IS_SIGN_INHERITED CHAR(1) UNAL,
        2 IS_BWZ CHAR(1) UNAL,
        2 IS_JUSTIFIED_RIGHT CHAR(1) UNAL,
        2 REPEATS_X CHAR(3) UNAL,
        2 IS_REPEATS_X_INHERITED CHAR(1) UNAL,
        2 REPEATS_Y CHAR(3) UNAL,
        2 IS_REPEATS_Y_INHERITED CHAR(1) UNAL,
        2 SEPARATED_X CHAR(3) UNAL,
        2 SEPARATED_X_GROUP_DIFFERENCE CHAR(3) UNAL,
        2 SEPARATED_Y CHAR(3) UNAL,
        2 SEPARATED_Y_GROUP_DIFFERENCE CHAR(3) UNAL,
        2 IS_CONSTANT_DEFAULT CHAR(1) UNAL,
        2 CONSTANT_DEFAULT_TYPE CHAR(1) UNAL,
        2 CONSTANT_DEFAULT_LENGTH CHAR(3) UNAL,
        2 DEFAULT_VALUE CHAR(%MAXIMUM_FIELD_LENGTH) UNAL,
        2 CONSTANT_VALUE REDEF DEFAULT_VALUE CHAR(%MAXIMUM_FIELD_LENGTH) UNAL,
        2 IS_PROMPT CHAR(1) UNAL,
        2 PROMPT_TYPE CHAR(1) UNAL,
        2 PROMPT_LENGTH CHAR(3) UNAL,
        2 PROMPT CHAR(%MAXIMUM_FIELD_LENGTH) UNAL;
 
  DCL AN_FPL_RECORD CHAR(65) BASED;
  DCL A_PICTURE_CLAUSE CHAR(30) BASED;
  DCL MAXIMUM_FIELD_LENGTH_SCRAP CHAR(%MAXIMUM_FIELD_LENGTH);
  DCL WHOLE_LOTTA_CHAR(0:0) CHAR(1) UNAL BASED;
 
  DCL CG_IN_BUFFER CHAR(1200);
  DCL CG_OUT_BUFFER CHAR(1200);
  DCL FPL_BUFFER_STRING CHAR(100);
  DCL 1 FPL_BUFFER REDEF FPL_BUFFER_STRING,
        2 * CHAR(6) UNAL,
        2 COMMENT_COLUMN CHAR(1) UNAL,
        2 CONTINUATION_COLUMN REDEF COMMENT_COLUMN CHAR(1) UNAL,
        2 GOOD_STUFF_STRING CHAR(65) UNAL,
        2 GOOD_STUFF REDEF GOOD_STUFF_STRING,
          3 FR_COLUMNS CHAR(2) UNAL,
          3 * CHAR(63) UNAL,
        2 * CHAR(28) UNAL;
  DCL MUSH_IN_BUFFER CHAR(1200);
  DCL MUSH_OUT_BUFFER CHAR(1200);
 
  DCL 1 POSITION_AND_FRAME_NAME_KEY,
        2 POSITION_X CHAR(3) UNAL,
        2 POSITION_Y CHAR(3) UNAL,
        2 FRAME_NAME CHAR(30) UNAL;
 
  DCL DEBUGGING BIT(1) ALIGNED STATIC INIT('0'B);
  DCL CG_IN$ PTR;
  DCL CG_OUT$ PTR;
  DCL FPL_IN$ PTR;
  DCL FPL_OUT$ PTR;
  DCL MUSH_IN$ PTR;
  DCL MUSH_OUT$ PTR;
  DCL PARSE_BUFFER_SIZE UBIN;
  DCL I UBIN;
  DCL A_UBIN_WHATEVER UBIN;
  DCL A_UBIN_WHATEVER2 UBIN;
  DCL A_CHAR3_WHATEVER CHAR(3);
  DCL FRAME_INDEX UBIN;
  DCL LET_ER_RIP_FRAME_INDEX_SAVED UBIN;
  DCL LET_ER_RIP_SEQUENCE#_SAVED CHAR(10);
  DCL START_FRAME_INDEX UBIN;
  DCL LEADING_ZERO_COUNT UBIN;
  DCL PICTURE_CHARACTER CHAR(2);
  DCL PICTURE_CHARACTER_LENGTH UBIN;
  DCL PICTURE_STRING_POSITION UBIN;
  DCL REPEAT_COUNT UBIN;
  DCL BLANK_INDEX UBIN;
  DCL UNDERSCORE_INDEX UBIN;
  DCL LB_INDEX UBIN;
  DCL RB_INDEX UBIN;
  DCL AT_INDEX UBIN;
 
  %MACRO ABANDON_SHIP ( ERROR = EH,
                        INTERNAL_ERROR ( NO = '0'B,
                                         YES = '1'B ) = NO );
 
    DO;
      CG_OUT$ -> WHATEVER_RECORD.ERROR_CODE = %ERROR_ABANDON_SHIP;
    %IF INTERNAL_ERROR;
      CALL CONCAT ( CG_OUT$ -> WHATEVER_RECORD.ERROR_TEXT,
        'Internal error:  ',
        ERROR );
    %ELSE;
      CALL CONCAT ( CG_OUT$ -> WHATEVER_RECORD.ERROR_TEXT,
        ERROR );
    %ENDIF;
      CALL M$WRITE ( WRITE_CG )
      WHENALTRETURN
      DO;
      END;
    END;
 
  %MEND;
%EJECT;
    IF B$JIT.MODE = %M_INT#
    THEN
TIMESHARING_FORMS_STUFF:
      DO;
        CALL M$GTRMCTL ( FPT_TRMCTL );
        CALL M$OPEN ( OPEN_SI_AS_TIMESHARING_FORM );
        CALL M$SETFP ( SETFP_SI );
      END TIMESHARING_FORMS_STUFF;
    ELSE
TP_STUFF:
      DO;
        CALL M$OPEN ( OPEN_SI_AS_TP_MONSTER );
      END TP_STUFF;
 
    IF DEBUGGING
    THEN
      CALL M$OPEN ( OPEN_LO );
 
    WRITE_LO.BUF_ = VECTOR ( CG_IN_BUFFER );
    CG_IN$ = ADDR ( CG_IN_BUFFER );
    READ_CG.BUF_ = VECTOR ( CG_IN_BUFFER );
    CG_OUT$ = ADDR ( CG_OUT_BUFFER );
    WRITE_CG.BUF_ = VECTOR ( CG_OUT_BUFFER );
    FPL_IN$ = ADDR ( FPL_BUFFER );
    READ_FPL_SOURCE.BUF_ = VECTOR ( FPL_BUFFER );
    FPL_OUT$ = ADDR ( FPL_BUFFER );
    WRITE_FPL_SOURCE.BUF_ = VECTOR ( FPL_BUFFER );
    MUSH_IN$ = ADDR ( MUSH_IN_BUFFER );
    READ_MUSH_SOURCE.BUF_ = VECTOR ( MUSH_IN_BUFFER );
    MUSH_OUT$ = ADDR ( MUSH_OUT_BUFFER );
    WRITE_MUSH_SOURCE.BUF_ = VECTOR ( MUSH_OUT_BUFFER );
    WRITE_MUSH_SOURCE_ERROR.BUF_ = VECTOR ( MUSH_OUT_BUFFER );
 
    OPEN_MUSH_SOURCE.V.KEYL# = LENGTHC ( FIELD_RECORD.SEQUENCE# );
    OPEN_MUSH_SOURCE.V.KEYX# = POFFC ( ADDR ( CG_IN$ -> FIELD_RECORD.SEQUENCE# ),
      ADDR ( CG_IN$ -> FIELD_RECORD ) );
    VLP_ALTKEYS.K.KEYL# (0) = LENGTHC ( FIELD_RECORD.POSITION_X )
      + LENGTHC ( FIELD_RECORD.POSITION_Y )
      + LENGTHC ( FIELD_RECORD.FRAME_NAME );
    VLP_ALTKEYS.K.KEYX# (0) = POFFC ( ADDR ( CG_IN$ -> FIELD_RECORD.POSITION_X ),
      ADDR ( CG_IN$ -> FIELD_RECORD ) );
    VLP_ALTKEYS.K.KEYL# (1) = LENGTHC ( FIELD_RECORD.FRAME_NAME );
    VLP_ALTKEYS.K.KEYX# (1) = POFFC ( ADDR ( CG_IN$ -> FIELD_RECORD.FRAME_NAME ),
      ADDR ( CG_IN$ -> FIELD_RECORD ) );
 
    CALL M$GDS ( GDS_FOR_FRAME_WORK );
    FRAME_PCB.WORK$ = GDS_VECTOR_FRAME_WORK.PTR$;
    FRAME_PCB.WKSZ = 1000;
 
    CALL M$GDS ( GDS_FOR_PICTURE_STRING_WORK );
    PICTURE_STRING_PCB.WORK$ = GDS_VECTOR_PICTURE_STRING_WORK.PTR$;
    PICTURE_STRING_PCB.WKSZ = 1000;
 
    CALL M$GDS ( GDS_FOR_PARSE_INPUT );
    FRAME_PCB.TEXT$ = GDS_VECTOR_INPUT.PTR$;
    PICTURE_STRING_PCB.TEXT$ = GDS_VECTOR_INPUT.PTR$;
    PARSE_BUFFER_SIZE = 1000;
 
    FRAME_PCB.COMMENT.LEAD = %CONCAT ( BINASC (0), BINASC (0) );
    FRAME_PCB.COMMENT.TRAIL = %CONCAT ( BINASC (0), BINASC (0) );
    PICTURE_STRING_PCB.COMMENT.LEAD = %CONCAT ( BINASC (0), BINASC (0) );
    PICTURE_STRING_PCB.COMMENT.TRAIL = %CONCAT ( BINASC (0), BINASC (0) );
 
%EJECT;
    DO WHILE ( '1'B );
 
      CG_IN_BUFFER = ' ';
      CG_OUT_BUFFER = ' ';
 
      CALL M$READ ( READ_CG ) ALTRET ( BAD_READ );
 
      IF DEBUGGING
      THEN
        CALL M$WRITE ( WRITE_LO );
 
 
        DO SELECT ( CG_IN$ -> WHATEVER_RECORD.FUNCTION );
 
          SELECT ( %FUNCTION_INITIALIZE_STATION );
            CALL INITIALIZE_STATION ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_FIND_FPL_AND_MUSH_IT );
            CALL FPL_TO_MUSH ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_GET_FRAMES );
            CALL GET_FRAMES ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_SET_ACTIVATION );
            CALL SET_ACTIVATION ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_ADD_FRAME );
            CALL ADD_FRAME ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_LET_ER_RIP );
            CALL LET_ER_RIP ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_LET_ER_RIP_RESUME );
            CALL LET_ER_RIP_RESUME ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_GET_FIELD_DETAILS );
            CALL GET_FIELD_DETAILS ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_PUT_FIELD_DETAILS );
            CALL PUT_FIELD_DETAILS ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_DELETE_FIELD );
            CALL DELETE_FIELD ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_FIND_MUSH_AND_FPL_IT );
            CALL MUSH_TO_FPL ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_DEINITIALIZE_STATION );
            CALL DEINITIALIZE_STATION ALTRET ( NO_DICE );
 
          SELECT ( %FUNCTION_FPABT );
            CALL FPABT ALTRET ( BAIL_OUT );
 
          SELECT ( ELSE );
 
        END;
 
        DO WHILE ( '0'B );
NO_DICE:
          CG_OUT$ -> WHATEVER_RECORD.ERROR_CODE = %ERROR_NO_DICE;
          CALL M$WRITE ( WRITE_CG )
          WHENALTRETURN
          DO;
          END;
        END;
 
    END;
 
BAD_READ:;
BAIL_OUT:
    IF B$JIT.MODE = %M_INT#
    THEN
      CALL M$STRMCTL ( FPT_TRMCTL );
 
    IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
      OR B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$NOFPRG
    THEN
      DO;
        CALL M$CLOSE ( CLOSE_SI );
        CALL M$CLOSE ( CLOSE_LO );
        CALL M$EXIT;
      END;
    ELSE
      CALL M$XXX;
 
%EJECT;
INITIALIZE_STATION: PROC ALTRET;
 
    STATION.MESSAGE_TYPE = CG_IN$ -> INITIALIZE_RECORD.MESSAGE_TYPE;
    STATION.MAX_FRAME_INDEX = -1;
    STATION.MAXIMUM_SEQUENCE# = 0;
    STATION.LEVEL#_INCREMENT = 1;
 
    CALL FLUSH_THE_MUSH_SOURCE
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    CG_OUT$ -> INITIALIZE_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
    CALL M$WRITE ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
END INITIALIZE_STATION;
%EJECT;
FPL_TO_MUSH: PROC ALTRET;
 
  DCL GOOD_STUFF_INDEX UBIN;
  DCL PARSE_BUFFER_INSERT$ PTR;
  DCL THIS_IS_THE_FIRST_FR BIT(1) ALIGNED;
 
    CALL OPEN_THE_FPL_SOURCE_OUT_TEST
      ALTRET ( FPL_TO_MUSH_NO_DICE );
 
    CALL OPEN_THE_FPL_SOURCE_IN
      ALTRET ( FPL_TO_MUSH_NO_DICE );
 
    IF CG_IN$ -> FID_RECORD.OLD_NEW = 'O'
    THEN
MUSH_THAT_FPL:
      DO;
 
        PARSE_BUFFER_INSERT$ = FRAME_PCB.TEXT$;
        THIS_IS_THE_FIRST_FR = %YES;
 
FRAME_AFTER_FRAME:
        DO WHILE ( '1'B );
 
IGNORE_COMMENTS:
          FPL_BUFFER_STRING = ' ';
          GOOD_STUFF_INDEX = 0;
 
          CALL M$READ ( READ_FPL_SOURCE )
          WHENALTRETURN
          DO;
            IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
            THEN
              EXIT FRAME_AFTER_FRAME;
            ELSE
              DO;
                CALL INTERNAL_M$_ERROR ( READ_FPL_SOURCE.V.DCB# );
                GOTO FPL_TO_MUSH_NO_DICE;
              END;
          END;
 
          IF FPL_BUFFER.COMMENT_COLUMN = '*'
          THEN
            GOTO IGNORE_COMMENTS;
 
          IF FPL_BUFFER.CONTINUATION_COLUMN = '-'
          THEN
            DO;
 
STRIP_LEADING_BLANKS:
              DO WHILE ( SUBSTR ( FPL_BUFFER.GOOD_STUFF_STRING,
                GOOD_STUFF_INDEX,
                1 ) = ' ' );
 
                GOOD_STUFF_INDEX = GOOD_STUFF_INDEX + 1;
 
              END STRIP_LEADING_BLANKS;
 
              IF SUBSTR ( FPL_BUFFER.GOOD_STUFF_STRING, GOOD_STUFF_INDEX, 1 ) = '"'
              THEN
                GOOD_STUFF_INDEX = GOOD_STUFF_INDEX + 1;
 
            END;
          ELSE
            DO;
              PARSE_BUFFER_INSERT$ -> WHOLE_LOTTA_CHAR (0) = ' ';
              PARSE_BUFFER_INSERT$ = PINCRC ( PARSE_BUFFER_INSERT$, 1 );
            END;
 
          IF FPL_BUFFER.GOOD_STUFF.FR_COLUMNS = 'FR'
          THEN
            IF THIS_IS_THE_FIRST_FR
            THEN
              THIS_IS_THE_FIRST_FR = %NO;
            ELSE
              DO;
                CALL PARSE_A_FRAME
                  ALTRET ( FPL_TO_MUSH_NO_DICE );
 
                PARSE_BUFFER_INSERT$ = FRAME_PCB.TEXT$;
              END;
 
          PARSE_BUFFER_INSERT$ -> AN_FPL_RECORD =
            SUBSTR ( FPL_BUFFER.GOOD_STUFF_STRING, GOOD_STUFF_INDEX );
 
          PARSE_BUFFER_INSERT$ = PINCRC ( PARSE_BUFFER_INSERT$,
            LENGTHC (FPL_BUFFER.GOOD_STUFF_STRING) - GOOD_STUFF_INDEX );
 
          IF POFFW ( PARSE_BUFFER_INSERT$, FRAME_PCB.TEXT$ )
            + LENGTHW ( AN_FPL_RECORD ) + 1
            > PARSE_BUFFER_SIZE
          THEN
            DO;
              CALL M$GDS ( GDS_FOR_PARSE_INPUT );
              PARSE_BUFFER_SIZE = PARSE_BUFFER_SIZE + 1000;
            END;
 
        END FRAME_AFTER_FRAME;
 
        CALL PARSE_A_FRAME
          ALTRET ( FPL_TO_MUSH_NO_DICE );
 
      END MUSH_THAT_FPL;
 
    CALL CLOSE_THE_FPL_SOURCE;
 
    CG_OUT$ -> FID_RECORD = CG_IN$ -> FID_RECORD;
    CG_OUT$ -> FID_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
    CALL M$WRITE  ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
FPL_TO_MUSH_NO_DICE:
    CALL CLOSE_THE_FPL_SOURCE;
 
    ALTRETURN;
 
%EJECT;
/*
    Well, there's reportedly one FRame's worth of valid FPL source
    at FRAME_PCB.TEXT$.
    Let's attempt to parse the whole thing in one shot, writing
    a "mush" record to the *FLIxx file for each field.  The mush
    records consist of all kinds of details about their fields,
    and are passed back and forth when the FPL program queries or
    updates them.
    The wierdnesses associated with this procedure are:
    1)  The Inheritance of Attributes.
        Fields which are group items (i.e., those which have no
        PICture clauses) have certain characteristics which are
        inherited by their subordinate fields.
        The INHERITED.attribute.YUP flags determine whether
        the attribute_HAND_ME_DOWN flags are relevant.
    2)  THE_LAST_FIELD_CLAUSE.
        This item contains the EQUate for which of the *FIELD_CLAUSES*
        (see the nodes) was seen last.  It's checked when an OUT$BLK
        professes to be the first one for a field, i.e., a .DEC2
        was parsed.  Now, if THE_LAST_FIELD_CLAUSE was not a '.'
        (%END_OF_CLAUSES), then our FPL programmer either omitted
        a '.', or one too many '.'s were eaten by whatever
        THE_LAST_FIELD_CLAUSE was.  Like this:
               02  ICK-1 PIC 9..
               02  ICK-1 PIC 9. CONSTANT 0..
               02  ICK-1 PIC 9. DEFAULT 0..
        If this is the case, go back and strip the last '.' from
        the field's PICture or CONSTANT VALUE or DEFAULT VALUE clause
        before writing its mush record.
    3)  The PICture Clause.
        The FPL program is expecting an expanded PICture string of
        the form:  "PIC XXXXXXX", even if the definition is
        "PIC X(7)".  First, we'll save away the "X(7)" somewhere
        and then pass a WHOLE NEW PCB to the parser pointing at
        the "X(7)" to eventually get to "XXXXXXX".
    4)  The CONSTANT VALUE PICture string.
        Since non-alphanumeric CONSTANT VALUEs are a waste, we'll
        reduce them to "X" fields in all cases when re-FPLing the
        mush file.  In the meantime, the FPL program would rather
        see the real text (e.g., "Command:") than a bunch of "X"s,
        so we'll replace the PICture string with the real text
        before writing the mush record.
*/
PARSE_A_FRAME: PROC ALTRET;
 
  DCL I$ PTR;
  DCL J$ PTR;
  DCL K$ PTR;
  DCL L$ PTR;
  DCL I UBIN;
  DCL J UBIN;
  DCL K UBIN;
  DCL L UBIN;
  DCL 1 INHERITED,
        2 A_O_I_M,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 GROUPIEST_NON_01_LEVEL CHAR(2),
          3 STUFF CHAR(1),
        2 ATTRIBUTE,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 GROUPIEST_NON_01_LEVEL CHAR(2),
          3 STUFF CHAR(30),
        2 CONSTANT_VALUE,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 GROUPIEST_NON_01_LEVEL CHAR(2),
          3 STUFF CHAR(30),
          3 STUFF_INDEX UBIN,
        2 ENTRY_REQUIRED,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 GROUPIEST_NON_01_LEVEL CHAR(2),
          3 STUFF CHAR(1),
        2 IO,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 GROUPIEST_NON_01_LEVEL CHAR(2),
          3 STUFF CHAR(2),
        2 SIGN,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 GROUPIEST_NON_01_LEVEL CHAR(2),
          3 STUFF CHAR(2),
        2 REPEATS_Y,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 STUFF CHAR(3),
          3 SEPARATED CHAR(3),
          3 GROUP_MINIMUM CHAR(3),
          3 GROUP_MAXIMUM CHAR(3),
          3 GROUP_SEQUENCE# CHAR(10),
          3 GROUP_SEQUENCE#_PARTS REDEF GROUP_SEQUENCE#,
            4 INTEGER CHAR(5) UNAL,
            4 FRACTION CHAR(5) UNAL,
        2 REPEATS_X,
          3 YUP BIT(1) ALIGNED,
          3 LEVEL CHAR(2),
          3 STUFF CHAR(3),
          3 SEPARATED CHAR(3),
          3 GROUP_MINIMUM CHAR(3),
          3 GROUP_MAXIMUM CHAR(3),
          3 GROUP_RIGHTMOST_ITEM_LENGTH UBIN,
          3 GROUP_SEQUENCE# CHAR(10),
          3 GROUP_SEQUENCE#_PARTS REDEF GROUP_SEQUENCE#,
            4 INTEGER CHAR(5) UNAL,
            4 FRACTION CHAR(5) UNAL;
  DCL GROUP_SEQUENCE#(0:49) CHAR(10);
  DCL GROUP_SEQUENCE#_INDEX SBIN;
  DCL OUR_CURRENT_FRAME_NAME CHAR(30);
  DCL OUR_CURRENT_ORIGIN_X UBIN;
  DCL OUR_CURRENT_ORIGIN_Y UBIN;
  DCL THE_LAST_FIELD_CLAUSE UBIN;
  DCL THIS_IS_THE_FIRST_FIELD BIT(1) ALIGNED;
 
    A_UBIN_WHATEVER = POFFC ( PARSE_BUFFER_INSERT$, FRAME_PCB.TEXT$ );
    FRAME_PCB.NCHARS = A_UBIN_WHATEVER;
    IF A_UBIN_WHATEVER > %BITBIN ( '37777'O )
    THEN
      DO;
        %ABANDON_SHIP (
        ERROR = "'One of your FRames is too big to parse...'"
        );
        %ABANDON_SHIP (
        ERROR = "'...the last parseable 80 characters are:'"
        );
        SYSTEM_ERROR_MESSAGE = ADDR ( FRAME_PCB.TEXT$ -> WHOLE_LOTTA_CHAR ( %BITBIN ( '37777'O ) - 80 ) ) -> AN_FPL_RECORD;
        %ABANDON_SHIP (
        ERROR = SYSTEM_ERROR_MESSAGE
        );
        %ABANDON_SHIP (
        ERROR = "'(Also, make sure all FR definitions begin in column 8.)'"
        );
        ALTRETURN;
      END;
 
    CALL SO_PARSE_IT_ALREADY ( FRAME_PCB, GDS_FOR_FRAME_WORK )
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    I$ = FRAME_PCB.OUT$;
    THIS_IS_THE_FIRST_FIELD = %YES;
    INHERITED.ATTRIBUTE.YUP = %NO;
    INHERITED.CONSTANT_VALUE.YUP = %NO;
    INHERITED.ENTRY_REQUIRED.YUP = %NO;
    INHERITED.IO.YUP = %NO;
    INHERITED.SIGN.YUP = %NO;
    INHERITED.REPEATS_Y.YUP = %NO;
    INHERITED.REPEATS_X.YUP = %NO;
 
I_SUBLK_LOOP:
    DO I = 0 TO I$ -> OUT$BLK.NSUBLKS - 1;
 
I_SUBLK_CASE:
      DO CASE ( I$ -> OUT$BLK.SUBLK$ (I) -> OUT$BLK.CODE );
 
        CASE ( %FRAME_NAME );
          OUR_CURRENT_FRAME_NAME = ' ';
          OUR_CURRENT_FRAME_NAME = I$ -> OUT$BLK.SUBLK$ (I) -> OUT$SYM.TEXT;
          OUR_CURRENT_ORIGIN_X = 0;
          OUR_CURRENT_ORIGIN_Y = 0;
 
          CALL ADD_A_FRAME ( OUR_CURRENT_FRAME_NAME )
          WHENALTRETURN
          DO;
            ALTRETURN;
          END;
 
          MUSH_OUT_BUFFER = ' ';
 
          STATION.MAXIMUM_SEQUENCE# = STATION.MAXIMUM_SEQUENCE# + 100;
          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.INTEGER,
            STATION.MAXIMUM_SEQUENCE# );
          MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.FRACTION = '00000';
 
          MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME = OUR_CURRENT_FRAME_NAME;
          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_X,
            OUR_CURRENT_ORIGIN_X );
          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_Y,
            OUR_CURRENT_ORIGIN_Y );
          MUSH_OUT$ -> FIELD_RECORD.LEVEL# = '00';
          MUSH_OUT$ -> FIELD_RECORD.NAME = OUR_CURRENT_FRAME_NAME;
 
          CALL PUT_GROUP_SEQUENCE#;
 
        CASE ( %FRAME_CLAUSES );
          J$ = I$ -> OUT$BLK.SUBLK$ (I);
 
LITTLE_J_SUBLK_LOOP:
          DO J = 0 TO J$ -> OUT$BLK.NSUBLKS - 1;
 
LITTLE_J_SUBLK_CASE:
            DO CASE ( J$ -> OUT$BLK.SUBLK$ (J) -> OUT$BLK.CODE );
 
              CASE ( %ORIGIN_CLAUSE );
                MUSH_OUT$ -> FIELD_RECORD.IS_ORIGIN_VALID = 'Y';
 
                CALL CHARBIN ( OUR_CURRENT_ORIGIN_Y,
                  J$ -> OUT$BLK.SUBLK$ (J) ->
                  OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT );
                CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_Y,
                  OUR_CURRENT_ORIGIN_Y );
 
                CALL CHARBIN ( OUR_CURRENT_ORIGIN_X,
                  J$ -> OUT$BLK.SUBLK$ (J) ->
                  OUT$BLK.SUBLK$ (1) -> OUT$SYM.TEXT );
                CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_X,
                  OUR_CURRENT_ORIGIN_X );
 
              CASE ( %END_OF_CLAUSES );
                CALL M$WRITE ( WRITE_MUSH_SOURCE )
                WHENALTRETURN
                DO;
                  CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
                  ALTRETURN;
                END;
 
            END LITTLE_J_SUBLK_CASE;
 
          END LITTLE_J_SUBLK_LOOP;
 
        CASE ( %FIELD );
          IF THIS_IS_THE_FIRST_FIELD
          THEN
            THIS_IS_THE_FIRST_FIELD = %NO;
          ELSE
            CALL CLEANUP_THE_LAST_FIELD
            WHENALTRETURN
            DO;
              ALTRETURN;
            END;
 
          MUSH_OUT_BUFFER = ' ';
 
          STATION.MAXIMUM_SEQUENCE# = STATION.MAXIMUM_SEQUENCE# + 1;
          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.INTEGER,
            STATION.MAXIMUM_SEQUENCE# );
          MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.FRACTION = '00000';
 
          MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME = OUR_CURRENT_FRAME_NAME;
          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_X,
            OUR_CURRENT_ORIGIN_X );
          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_Y,
            OUR_CURRENT_ORIGIN_Y );
 
          J$ = I$ -> OUT$BLK.SUBLK$ (I);
 
J_SUBLK_LOOP:
          DO J = 0 TO J$ -> OUT$BLK.NSUBLKS - 1;
 
J_SUBLK_CASE:
            DO CASE ( J$ -> OUT$BLK.SUBLK$ (J) -> OUT$BLK.CODE );
 
              CASE ( %FIELD_LEVEL );
                CALL CHARBIN ( A_UBIN_WHATEVER,
                  J$ -> OUT$BLK.SUBLK$ (J) -> OUT$SYM.TEXT );
                CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.LEVEL#,
                  A_UBIN_WHATEVER );
 
              CASE ( %FIELD_NAME );
                MUSH_OUT$ -> FIELD_RECORD.NAME =
                  J$ -> OUT$BLK.SUBLK$ (J) -> OUT$SYM.TEXT;
 
              CASE ( %FIELD_CLAUSES );
                K$ = J$ -> OUT$BLK.SUBLK$ (J);
 
                THE_LAST_FIELD_CLAUSE = K$ ->
                  OUT$BLK.SUBLK$ ( K$ -> OUT$BLK.NSUBLKS - 1 ) ->
                  OUT$BLK.CODE;
 
K_SUBLK_LOOP:
                DO K = 0 TO K$ -> OUT$BLK.NSUBLKS - 1;
 
K_SUBLK_CASE:
                  DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) -> OUT$BLK.CODE );
 
                    CASE ( %PICTURE );
                      MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE =
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      PICTURE_STRING_PCB.TEXT$ -> A_PICTURE_CLAUSE =
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
                      PICTURE_STRING_PCB.NCHARS =
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT;
 
                      CALL SO_PARSE_IT_ALREADY ( PICTURE_STRING_PCB,
                        GDS_FOR_PICTURE_STRING_WORK )
                      WHENALTRETURN
                      DO;
                        ALTRETURN;
                      END;
 
                      L$ = PICTURE_STRING_PCB.OUT$;
                      PICTURE_STRING_POSITION = 0;
 
L_SUBLK_LOOP:
                      DO L = 0 TO L$ -> OUT$BLK.NSUBLKS - 1;
 
L_SUBLK_CASE:
                        DO CASE ( L$ -> OUT$BLK.SUBLK$ (L) ->
                          OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                          CASE ( %COMMA );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( ',', 1, REPEAT_COUNT );
 
                          CASE ( %X );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'X', 1, REPEAT_COUNT );
 
                          CASE ( %NINE );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '9', 1, REPEAT_COUNT );
 
                          CASE ( %P );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'P', 1, REPEAT_COUNT );
 
                          CASE ( %DOLLAR_SIGN );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '$', 1, REPEAT_COUNT );
 
                          CASE ( %PLUS_SIGN );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '+', 1, REPEAT_COUNT );
 
                          CASE ( %MINUS_SIGN );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '-', 1, REPEAT_COUNT );
 
                          CASE ( %Z );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'Z', 1, REPEAT_COUNT );
 
                          CASE ( %ASTERISK );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '*', 1, REPEAT_COUNT );
 
                          CASE ( %SLASH );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '/', 1, REPEAT_COUNT );
 
                          CASE ( %ZERO );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '0', 1, REPEAT_COUNT );
 
                          CASE ( %B );
                            CALL SETUP_REPEAT_COUNT;
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'B', 1, REPEAT_COUNT );
 
                          CASE ( %S );
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'S', 1, 1 );
 
                          CASE ( %V );
 
                          CASE ( %CR );
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'CR', 2, 1 );
 
                          CASE ( %DB );
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( 'DB', 2, 1 );
 
                          CASE ( %PERIOD );
                            CALL REPEAT_THE_PICTURE_CHARACTER
                              ( '.', 1, 1 );
 
                        END L_SUBLK_CASE;
 
                      END L_SUBLK_LOOP;
 
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH,
                        PICTURE_STRING_POSITION );
 
                    CASE ( %POSITION );
                      CALL CHARBIN ( A_UBIN_WHATEVER,
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT );
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.POSITION_Y,
                        A_UBIN_WHATEVER + OUR_CURRENT_ORIGIN_Y );
 
                      CALL CHARBIN ( A_UBIN_WHATEVER,
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (1) -> OUT$SYM.TEXT );
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.POSITION_X,
                        A_UBIN_WHATEVER + OUR_CURRENT_ORIGIN_X );
 
                    CASE ( %REPEATS );
                      CALL CHARBIN ( A_UBIN_WHATEVER,
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT );
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.REPEATS_X,
                        A_UBIN_WHATEVER );
 
                      IF K$ -> OUT$BLK.SUBLK$ (K) -> OUT$BLK.NSUBLKS > 1
                      THEN
                        DO;
                          CALL CHARBIN ( A_UBIN_WHATEVER,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (1) -> OUT$SYM.TEXT );
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X,
                            A_UBIN_WHATEVER );
                        END;
                      ELSE
                        DO;
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X,
                            1 );
                        END;
 
                      MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X_GROUP_DIFFERENCE = '000';
 
                    CASE ( %BWZ );
                      MUSH_OUT$ -> FIELD_RECORD.IS_BWZ = 'Y';
 
                    CASE ( %SIGN );
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %LEADING_SEPARATE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.SIGN = 'LS';
 
                        CASE ( %TRAILING_SEPARATE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.SIGN = 'TS';
 
                        CASE ( %TRAILING_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.SIGN = 'TO';
 
                      END;
 
                    CASE ( %IO_OPTION );
                      MUSH_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT = 'Y';
                      MUSH_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT = 'Y';
 
                    CASE ( %INPUT_OPTION );
                      MUSH_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT = 'Y';
 
                    CASE ( %OUTPUT_OPTION );
                      MUSH_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT = 'Y';
 
                    CASE ( %ENTRY_REQUIRED );
                      MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = 'Y';
 
                    CASE ( %ENTRY_OPTIONAL );
 
                    CASE ( %CLASS );
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
 
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %ALPHABETIC_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.CLASS =
                            'ALPHABETIC';
 
                        CASE ( %NUMERIC_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.CLASS =
                            'NUMERIC';
 
                        CASE ( ELSE );
                          MUSH_OUT$ -> FIELD_RECORD.CLASS =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      END;
 
                    CASE ( %ATTRIBUTE );
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %EMPHASIS_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'EMPHASIS-ATTRIBUTE';
 
                        CASE ( %ERROR_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'ERROR-ATTRIBUTE';
 
                        CASE ( %HIDDEN_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'HIDDEN-ATTRIBUTE';
 
                        CASE ( %INPUT_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'INPUT-ATTRIBUTE';
 
                        CASE ( %NULL_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'NULL-ATTRIBUTE';
 
                        CASE ( %OUTPUT_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'OUTPUT-ATTRIBUTE';
 
                        CASE ( %WARNING_ATTRIBUTE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            'WARNING-ATTRIBUTE';
 
                        CASE ( ELSE );
                          MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      END;
 
                    CASE ( %MINIMUM_SIZE );
                      CALL CHARBIN ( A_UBIN_WHATEVER,
                        K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT );
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.MINIMUM_SIZE,
                        A_UBIN_WHATEVER );
 
                    CASE ( %FILL_CHARACTER );
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %ZERO_OPTION,
                        %ZEROES_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.FILL_CHARACTER = '0';
 
                        CASE ( %HIGH_VALUE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.FILL_CHARACTER =
                            %BINCHAR ( BITBIN ( '77'O ) );
 
                        CASE ( %LOW_VALUE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.FILL_CHARACTER =
                            %BINCHAR ( BITBIN ( '00'O ) );
 
                        CASE ( %SPACE_OPTION );
 
                        CASE ( ELSE );
                          MUSH_OUT$ -> FIELD_RECORD.FILL_CHARACTER =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      END;
 
                    CASE ( %JUSTIFIED_RIGHT );
                      MUSH_OUT$ -> FIELD_RECORD.IS_JUSTIFIED_RIGHT = 'Y';
 
                    CASE ( %DEFAULT_VALUE );
                      MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D';
                      MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L';
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                        %MAXIMUM_FIELD_LENGTH );
 
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %ZERO_OPTION,
                        %ZEROES_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( '0', 1, MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE );
 
                        CASE ( %HIGH_VALUE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( %BINCHAR ( BITBIN ( '77'O ) ), 1, MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE );
 
                        CASE ( %LOW_VALUE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( %BINCHAR ( BITBIN ( '00'O ) ), 1, MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE );
 
                        CASE ( %SPACE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( ' ', 1, MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE );
 
                        CASE ( %ALL_VALUE_OPTION );
                          MAXIMUM_FIELD_LENGTH_SCRAP =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
                          A_UBIN_WHATEVER =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT;
                          CALL REPEAT_THE_LITERAL
                            ( MAXIMUM_FIELD_LENGTH_SCRAP,
                            A_UBIN_WHATEVER,
                            MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE );
 
                        CASE ( %ALPHANUMERIC_VALUE_OPTION );
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                        CASE ( %NUMERIC_VALUE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N';
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      END;
 
                    CASE ( %CONSTANT_VALUE );
                      MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C';
                      MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L';
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                        %MAXIMUM_FIELD_LENGTH );
 
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %ZERO_OPTION,
                        %ZEROES_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( '0', 1, MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE );
 
                        CASE ( %HIGH_VALUE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( %BINCHAR ( BITBIN ( '77'O ) ), 1, MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE );
 
                        CASE ( %LOW_VALUE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( %BINCHAR ( BITBIN ( '00'O ) ), 1, MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE );
 
                        CASE ( %SPACE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( ' ', 1, MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE );
 
                        CASE ( %ALL_VALUE_OPTION );
                          MAXIMUM_FIELD_LENGTH_SCRAP =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
                          A_UBIN_WHATEVER =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT;
                          CALL REPEAT_THE_LITERAL
                            ( MAXIMUM_FIELD_LENGTH_SCRAP,
                            A_UBIN_WHATEVER,
                            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE );
 
                        CASE ( %ALPHANUMERIC_VALUE_OPTION );
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                        CASE ( %NUMERIC_VALUE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N';
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      END;
 
                    CASE ( %PROMPT );
                      MUSH_OUT$ -> FIELD_RECORD.IS_PROMPT = 'Y';
                      MUSH_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'L';
                      CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT_LENGTH,
                        %MAXIMUM_FIELD_LENGTH );
 
                      DO CASE ( K$ -> OUT$BLK.SUBLK$ (K) ->
                        OUT$BLK.SUBLK$ (0) -> OUT$BLK.CODE );
 
                        CASE ( %ZERO_OPTION,
                        %ZEROES_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( '0', 1, MUSH_OUT$ -> FIELD_RECORD.PROMPT );
 
                        CASE ( %HIGH_VALUE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( %BINCHAR ( BITBIN ( '77'O ) ), 1, MUSH_OUT$ -> FIELD_RECORD.PROMPT );
 
                        CASE ( %LOW_VALUE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( %BINCHAR ( BITBIN ( '00'O ) ), 1, MUSH_OUT$ -> FIELD_RECORD.PROMPT );
 
                        CASE ( %SPACE_OPTION );
                          CALL REPEAT_THE_LITERAL
                            ( ' ', 1, MUSH_OUT$ -> FIELD_RECORD.PROMPT );
 
                        CASE ( %ALL_VALUE_OPTION );
                          MAXIMUM_FIELD_LENGTH_SCRAP =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
                          A_UBIN_WHATEVER =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT;
                          CALL REPEAT_THE_LITERAL
                            ( MAXIMUM_FIELD_LENGTH_SCRAP,
                            A_UBIN_WHATEVER,
                            MUSH_OUT$ -> FIELD_RECORD.PROMPT );
 
                        CASE ( %ALPHANUMERIC_VALUE_OPTION );
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.PROMPT =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                        CASE ( %NUMERIC_VALUE_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'N';
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.PROMPT =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                        CASE ( %DATANAME_OPTION );
                          MUSH_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'D';
                          CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT_LENGTH,
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.COUNT );
 
                          MUSH_OUT$ -> FIELD_RECORD.PROMPT =
                            K$ -> OUT$BLK.SUBLK$ (K) ->
                            OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT;
 
                      END;
 
                    CASE ( %A_O_I_M );
                      MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M = 'Y';
 
                    CASE ( %END_OF_CLAUSES );
 
                  END K_SUBLK_CASE;
 
                END K_SUBLK_LOOP;
 
            END J_SUBLK_CASE;
 
          END J_SUBLK_LOOP;
 
      END I_SUBLK_CASE;
 
    END I_SUBLK_LOOP;
 
    CALL CLEANUP_THE_LAST_FIELD
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    IF INHERITED.REPEATS_Y.YUP
    THEN
      CALL REINHERIT_Y_SEPARATEDNESS
      WHENALTRETURN
      DO;
        ALTRETURN;
      END;
    IF INHERITED.REPEATS_X.YUP
    THEN
      CALL REINHERIT_X_SEPARATEDNESS
      WHENALTRETURN
      DO;
        ALTRETURN;
      END;
 
    RETURN;
%EJECT;
SO_PARSE_IT_ALREADY: PROC ( P_PCB, FPT_GDS ) ALTRET;
 
  %P_PCB ( STCLASS = "" );
  %FPT_GDS ( STCLASS = "" );
 
SO_PARSE_IT_AGAIN:
    CALL X$PARSE ( P_PCB )
    WHENALTRETURN
    DO;
      DO CASE ( P_PCB.ERROR.CODE );
 
        CASE ( %E$SMALLWORK, %E$WKOVERFLOW );
          CALL M$GDS ( FPT_GDS )
          WHENALTRETURN
          DO;
            %ABANDON_SHIP (
            ERROR = "'One of your FRames is too big to parse...sheesh!'"
            );
            CALL FLUSH_THE_MUSH_SOURCE;
            CALL CLOSE_THE_FPL_SOURCE;
            ALTRETURN;
          END;
 
          P_PCB.WKSZ = P_PCB.WKSZ + 1000;
          GOTO SO_PARSE_IT_AGAIN;
 
        CASE ( %E$SYNERR );
          %ABANDON_SHIP (
          ERROR = "'Your FPL FRame section has a syntax error at:'"
          );
          SYSTEM_ERROR_MESSAGE = ADDR ( P_PCB.TEXT$ -> WHOLE_LOTTA_CHAR ( P_PCB.HI_CHAR ) ) -> AN_FPL_RECORD;
          %ABANDON_SHIP (
          ERROR = SYSTEM_ERROR_MESSAGE
          );
          CALL FLUSH_THE_MUSH_SOURCE;
          CALL CLOSE_THE_FPL_SOURCE;
          ALTRETURN;
 
        CASE ( ELSE );
          %ABANDON_SHIP (
          ERROR = "'unexpected X$PARSE altret.'",
          INTERNAL_ERROR = YES
          );
          CALL FLUSH_THE_MUSH_SOURCE;
          CALL CLOSE_THE_FPL_SOURCE;
          ALTRETURN;
 
      END;
    END;
 
    RETURN;
 
END SO_PARSE_IT_ALREADY;
%EJECT;
SETUP_REPEAT_COUNT: PROC;
 
    IF L$ -> OUT$BLK.SUBLK$ (L) ->
      OUT$BLK.SUBLK$ (0) -> OUT$BLK.NSUBLKS = 0
    THEN
      REPEAT_COUNT = 1;
    ELSE
      CALL CHARBIN ( REPEAT_COUNT,
        L$ -> OUT$BLK.SUBLK$ (L) ->
        OUT$BLK.SUBLK$ (0) ->
        OUT$BLK.SUBLK$ (0) -> OUT$SYM.TEXT );
 
    RETURN;
 
END SETUP_REPEAT_COUNT;
 
REPEAT_THE_PICTURE_CHARACTER: PROC ( PICTURE_CHARACTER,
      PICTURE_CHARACTER_LENGTH,
      REPEATS_COUNT );
 
  DCL PICTURE_CHARACTER CHAR( PICTURE_CHARACTER_LENGTH );
  DCL PICTURE_CHARACTER_LENGTH UBIN;
  DCL REPEATS_COUNT UBIN;
  DCL PICTURE_STRING_INDEX UBIN;
 
    DO PICTURE_STRING_INDEX = 0 TO REPEATS_COUNT - 1;
 
      SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING,
        PICTURE_STRING_POSITION,
        PICTURE_CHARACTER_LENGTH ) = PICTURE_CHARACTER;
 
      PICTURE_STRING_POSITION = PICTURE_STRING_POSITION
        + PICTURE_CHARACTER_LENGTH;
 
    END;
 
    RETURN;
 
END REPEAT_THE_PICTURE_CHARACTER;
 
REPEAT_THE_LITERAL: PROC ( LITERAL_CHARACTER,
      LITERAL_CHARACTER_LENGTH,
      LITERAL_BUFFER );
 
  DCL LITERAL_CHARACTER CHAR( LITERAL_CHARACTER_LENGTH );
  DCL LITERAL_CHARACTER_LENGTH UBIN;
  DCL LITERAL_BUFFER CHAR(%MAXIMUM_FIELD_LENGTH);
  DCL LITERAL_POSITION UBIN;
  DCL LITERAL_INDEX UBIN;
 
    LITERAL_POSITION = 0;
 
    DO LITERAL_INDEX = 1
      TO %MAXIMUM_FIELD_LENGTH / LITERAL_CHARACTER_LENGTH;
 
      SUBSTR ( LITERAL_BUFFER,
        LITERAL_POSITION,
        LITERAL_CHARACTER_LENGTH ) = LITERAL_CHARACTER;
 
      LITERAL_POSITION = LITERAL_POSITION
        + LITERAL_CHARACTER_LENGTH;
 
    END;
 
    SUBSTR ( LITERAL_BUFFER,
      LITERAL_POSITION,
      %MAXIMUM_FIELD_LENGTH - LITERAL_POSITION ) =
      LITERAL_CHARACTER;
 
    RETURN;
 
END REPEAT_THE_LITERAL;
%EJECT;
/*
    There's a few things we oughta check on before writing out
    this field:
    1)  THE_LAST_FIELD_CLAUSE.
        This tells us if the last clause swallowed up one-too-many
        '.'s.
    2)  The Inheritance of Attributes.
        A)  Get the ones we're supposed to from higher-level
            group items.
        B)  If we don't inherit any from higher-level groups,
            then shut off those attributes and, for REPEATS
            attributes, re-evaluate the SEPARATED clause for
            each elementary item within the now-terminated group.
            E.g.:
                02  02-ITEM REPEATS 2 I-O.
                    03  03-ITEM PIC XX POS 1 1.
                    03  03-ITEM-TOO PIC XX POS 2 1.
                02  02-ITEM-TOO.
            When 02-ITEM-TOO is found, the "REPEATS 2" inherited
            attribute is turned off, and the elementary items
            within that group (03-ITEM and 03-ITEM-TOO) are
            updated to reflect a SEPARATED BY clause of, in this
            case, 2, instead of the (default) 1.  Same deal applies
            to REPEATS in the x-direction.
        C)  If this is a group item, see if it has any inheritable
            attributes, and if it does, remember them for later.
        D)  Take care of group-level CONSTANT VALUE clauses.
    3)  Items With CONSTANT VALUE Clauses.
        Replace the stock "X" (or whatever) PICture string with
        the CONSTANT VALUE, and then replace any blanks with
        the filler-character.
        E.g.:
            02  02-ITEM PIC X(10) POS 1 1 I-O
                CONSTANT VALUE "File name:".
        ends up generating "File_name:" (by default) into
        FIELD_RECORD.PICTURE_STRING.
*/
CLEANUP_THE_LAST_FIELD: PROC ALTRET;
 
    DO CASE ( THE_LAST_FIELD_CLAUSE );
 
      CASE ( %DEFAULT_VALUE );
        IF MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N'
        THEN
          DO;
            CALL CHARBIN ( A_UBIN_WHATEVER,
              MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH );
            IF SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
              A_UBIN_WHATEVER - 1, 1 ) = '.'
            THEN
              DO;
                SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
                  A_UBIN_WHATEVER - 1, 1 ) = ' ';
                CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                  A_UBIN_WHATEVER - 1 );
              END;
          END;
 
      CASE ( %CONSTANT_VALUE );
        IF MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N'
        THEN
          DO;
            CALL CHARBIN ( A_UBIN_WHATEVER,
              MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH );
            IF SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE,
              A_UBIN_WHATEVER - 1, 1 ) = '.'
            THEN
              DO;
                SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE,
                  A_UBIN_WHATEVER - 1, 1 ) = ' ';
                CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH,
                  A_UBIN_WHATEVER - 1 );
              END;
          END;
 
      CASE ( %PROMPT );
        IF MUSH_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'N'
        THEN
          DO;
            CALL CHARBIN ( A_UBIN_WHATEVER,
              MUSH_OUT$ -> FIELD_RECORD.PROMPT_LENGTH );
            IF SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT,
              A_UBIN_WHATEVER - 1, 1 ) = '.'
            THEN
              DO;
                SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT,
                  A_UBIN_WHATEVER - 1, 1 ) = ' ';
                CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PROMPT_LENGTH,
                  A_UBIN_WHATEVER - 1 );
              END;
          END;
 
      CASE ( %PICTURE );
        CALL INDEX ( BLANK_INDEX,
          ' ',
          MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE );
        IF SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
          BLANK_INDEX - 1,
          1 ) = '.'
        THEN
          SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
            BLANK_INDEX - 1,
            1 ) = ' ';
 
        CALL CHARBIN ( A_UBIN_WHATEVER,
          MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
        IF SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING,
          A_UBIN_WHATEVER - 1,
          1 ) = '.'
        THEN
          DO;
            SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING,
              A_UBIN_WHATEVER - 1,
              1 ) = ' ';
            CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH,
              A_UBIN_WHATEVER - 1 );
          END;
 
      CASE ( %END_OF_CLAUSES );
 
      CASE ( ELSE );
 
    END;
 
    CALL GET_GROUP_SEQUENCE#;
 
    IF INHERITED.A_O_I_M.YUP
    THEN
      DO;
        IF INHERITED.A_O_I_M.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          INHERITED.A_O_I_M.YUP = %NO;
        ELSE
          DO;
            IF INHERITED.A_O_I_M.LEVEL = '01'
            THEN
              IF INHERITED.A_O_I_M.GROUPIEST_NON_01_LEVEL < MUSH_OUT$ -> FIELD_RECORD.LEVEL#
              THEN
                MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M_INHERITED = 'Y';
              ELSE
                INHERITED.A_O_I_M.GROUPIEST_NON_01_LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            ELSE
              MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M = INHERITED.A_O_I_M.STUFF;
          END;
      END;
    IF INHERITED.ATTRIBUTE.YUP
    THEN
      DO;
        IF INHERITED.ATTRIBUTE.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          INHERITED.ATTRIBUTE.YUP = %NO;
        ELSE
          DO;
            IF INHERITED.ATTRIBUTE.LEVEL = '01'
            THEN
              IF INHERITED.ATTRIBUTE.GROUPIEST_NON_01_LEVEL < MUSH_OUT$ -> FIELD_RECORD.LEVEL#
              THEN
                MUSH_OUT$ -> FIELD_RECORD.IS_VISUAL_ATTRIBUTE_INHERITED = 'Y';
              ELSE
                INHERITED.ATTRIBUTE.GROUPIEST_NON_01_LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            ELSE
              MUSH_OUT$ -> FIELD_RECORD.IS_VISUAL_ATTRIBUTE_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = INHERITED.ATTRIBUTE.STUFF;
          END;
      END;
    IF INHERITED.CONSTANT_VALUE.YUP
    THEN
      DO;
        IF INHERITED.CONSTANT_VALUE.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          INHERITED.CONSTANT_VALUE.YUP = %NO;
        ELSE
          DO;
            MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C';
            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L';
            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH =
              MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH;
 
            IF MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
            THEN
              DO;
                CALL CHARBIN ( A_UBIN_WHATEVER,
                  MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
 
                IF LENGTHC ( INHERITED.CONSTANT_VALUE.STUFF )
                  - INHERITED.CONSTANT_VALUE.STUFF_INDEX
                  > 0
                THEN
                  DO;
                    SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE,
                      0,
                      A_UBIN_WHATEVER ) =
                      SUBSTR ( INHERITED.CONSTANT_VALUE.STUFF,
                      INHERITED.CONSTANT_VALUE.STUFF_INDEX );
 
                    INHERITED.CONSTANT_VALUE.STUFF_INDEX = INHERITED.CONSTANT_VALUE.STUFF_INDEX
                      + A_UBIN_WHATEVER;
                  END;
              END;
          END;
      END;
    IF INHERITED.ENTRY_REQUIRED.YUP
    THEN
      DO;
        IF INHERITED.ENTRY_REQUIRED.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          INHERITED.ENTRY_REQUIRED.YUP = %NO;
        ELSE
          DO;
            IF INHERITED.ENTRY_REQUIRED.LEVEL = '01'
            THEN
              IF INHERITED.ENTRY_REQUIRED.GROUPIEST_NON_01_LEVEL < MUSH_OUT$ -> FIELD_RECORD.LEVEL#
              THEN
                MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED_INHERITED = 'Y';
              ELSE
                INHERITED.ENTRY_REQUIRED.GROUPIEST_NON_01_LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            ELSE
              MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = INHERITED.ENTRY_REQUIRED.STUFF;
          END;
      END;
    IF INHERITED.IO.YUP
    THEN
      DO;
        IF INHERITED.IO.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          INHERITED.IO.YUP = %NO;
        ELSE
          DO;
            IF INHERITED.IO.LEVEL = '01'
            THEN
              IF INHERITED.IO.GROUPIEST_NON_01_LEVEL < MUSH_OUT$ -> FIELD_RECORD.LEVEL#
              THEN
                MUSH_OUT$ -> FIELD_RECORD.IS_IO_INHERITED = 'Y';
              ELSE
                INHERITED.IO.GROUPIEST_NON_01_LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            ELSE
              MUSH_OUT$ -> FIELD_RECORD.IS_IO_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.IO_VALUE = INHERITED.IO.STUFF;
          END;
      END;
    IF INHERITED.SIGN.YUP
    THEN
      DO;
        IF INHERITED.SIGN.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          INHERITED.SIGN.YUP = %NO;
        ELSE
          DO;
            IF INHERITED.SIGN.LEVEL = '01'
            THEN
              IF INHERITED.SIGN.GROUPIEST_NON_01_LEVEL < MUSH_OUT$ -> FIELD_RECORD.LEVEL#
              THEN
                MUSH_OUT$ -> FIELD_RECORD.IS_SIGN_INHERITED = 'Y';
              ELSE
                INHERITED.SIGN.GROUPIEST_NON_01_LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            ELSE
              MUSH_OUT$ -> FIELD_RECORD.IS_SIGN_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.SIGN = INHERITED.SIGN.STUFF;
          END;
      END;
    IF INHERITED.REPEATS_Y.YUP
    THEN
      DO;
        IF INHERITED.REPEATS_Y.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          DO;
            CALL REINHERIT_Y_SEPARATEDNESS
            WHENALTRETURN
            DO;
              ALTRETURN;
            END;
            INHERITED.REPEATS_Y.YUP = %NO;
          END;
        ELSE
          DO;
            IF MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
            THEN
              DO;
                IF MUSH_OUT$ -> FIELD_RECORD.POSITION_Y < INHERITED.REPEATS_Y.GROUP_MINIMUM
                THEN
                  INHERITED.REPEATS_Y.GROUP_MINIMUM = MUSH_OUT$ -> FIELD_RECORD.POSITION_Y;
                IF MUSH_OUT$ -> FIELD_RECORD.POSITION_Y > INHERITED.REPEATS_Y.GROUP_MAXIMUM
                THEN
                  INHERITED.REPEATS_Y.GROUP_MAXIMUM = MUSH_OUT$ -> FIELD_RECORD.POSITION_Y;
              END;
            MUSH_OUT$ -> FIELD_RECORD.IS_REPEATS_Y_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y = INHERITED.REPEATS_Y.STUFF;
            MUSH_OUT$ -> FIELD_RECORD.SEPARATED_Y = INHERITED.REPEATS_Y.SEPARATED;
          END;
      END;
    IF INHERITED.REPEATS_X.YUP
    THEN
      DO;
        IF INHERITED.REPEATS_X.LEVEL >= MUSH_OUT$ -> FIELD_RECORD.LEVEL#
        THEN
          DO;
            CALL REINHERIT_X_SEPARATEDNESS
            WHENALTRETURN
            DO;
              ALTRETURN;
            END;
            INHERITED.REPEATS_X.YUP = %NO;
          END;
        ELSE
          DO;
            IF MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
            THEN
              DO;
                IF MUSH_OUT$ -> FIELD_RECORD.POSITION_X < INHERITED.REPEATS_X.GROUP_MINIMUM
                THEN
                  INHERITED.REPEATS_X.GROUP_MINIMUM = MUSH_OUT$ -> FIELD_RECORD.POSITION_X;
                IF MUSH_OUT$ -> FIELD_RECORD.POSITION_X > INHERITED.REPEATS_X.GROUP_MAXIMUM
                THEN
                  DO;
                    INHERITED.REPEATS_X.GROUP_MAXIMUM = MUSH_OUT$ -> FIELD_RECORD.POSITION_X;
                    CALL CHARBIN ( INHERITED.REPEATS_X.GROUP_RIGHTMOST_ITEM_LENGTH,
                      MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
                  END;
              END;
            MUSH_OUT$ -> FIELD_RECORD.IS_REPEATS_X_INHERITED = 'Y';
            MUSH_OUT$ -> FIELD_RECORD.REPEATS_X = INHERITED.REPEATS_X.STUFF;
            MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X = INHERITED.REPEATS_X.SEPARATED;
            MUSH_OUT$ -> FIELD_RECORD.SEPARATED_Y_GROUP_DIFFERENCE = '000';
          END;
      END;
 
    IF MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE = ' '
    THEN
      DO;
        CALL PUT_GROUP_SEQUENCE#;
 
        IF NOT INHERITED.A_O_I_M.YUP
          AND MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M ~= ' '
        THEN
          DO;
            INHERITED.A_O_I_M.YUP = %YES;
            INHERITED.A_O_I_M.STUFF = MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M;
            INHERITED.A_O_I_M.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            IF INHERITED.A_O_I_M.LEVEL = '01'
            THEN
              DO;
                INHERITED.A_O_I_M.GROUPIEST_NON_01_LEVEL = '99';
                MUSH_OUT$ -> FIELD_RECORD.IS_A_O_I_M = ' ';
              END;
          END;
        IF NOT INHERITED.ATTRIBUTE.YUP
          AND MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE ~= ' '
        THEN
          DO;
            INHERITED.ATTRIBUTE.YUP = %YES;
            INHERITED.ATTRIBUTE.STUFF = MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE;
            INHERITED.ATTRIBUTE.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            IF INHERITED.ATTRIBUTE.LEVEL = '01'
            THEN
              DO;
                INHERITED.ATTRIBUTE.GROUPIEST_NON_01_LEVEL = '99';
                MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = ' ';
              END;
          END;
        IF NOT INHERITED.CONSTANT_VALUE.YUP
          AND MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE ~= ' '
        THEN
          DO;
            INHERITED.CONSTANT_VALUE.YUP = %YES;
            INHERITED.CONSTANT_VALUE.STUFF = MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE;
            INHERITED.CONSTANT_VALUE.STUFF_INDEX = 0;
            INHERITED.CONSTANT_VALUE.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = ' ';
            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = ' ';
            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH = ' ';
            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE = ' ';
          END;
        IF NOT INHERITED.ENTRY_REQUIRED.YUP
          AND MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~= ' '
        THEN
          DO;
            INHERITED.ENTRY_REQUIRED.YUP = %YES;
            INHERITED.ENTRY_REQUIRED.STUFF = MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED;
            INHERITED.ENTRY_REQUIRED.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            IF INHERITED.ENTRY_REQUIRED.LEVEL = '01'
            THEN
              DO;
                INHERITED.ENTRY_REQUIRED.GROUPIEST_NON_01_LEVEL = '99';
                MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = ' ';
              END;
          END;
        IF NOT INHERITED.IO.YUP
          AND MUSH_OUT$ -> FIELD_RECORD.IO_VALUE ~= ' '
        THEN
          DO;
            INHERITED.IO.YUP = %YES;
            INHERITED.IO.STUFF = MUSH_OUT$ -> FIELD_RECORD.IO_VALUE;
            INHERITED.IO.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            IF INHERITED.IO.LEVEL = '01'
            THEN
              DO;
                INHERITED.IO.GROUPIEST_NON_01_LEVEL = '99';
                MUSH_OUT$ -> FIELD_RECORD.IO_VALUE = ' ';
              END;
          END;
        IF NOT INHERITED.SIGN.YUP
          AND MUSH_OUT$ -> FIELD_RECORD.SIGN ~= ' '
        THEN
          DO;
            INHERITED.SIGN.YUP = %YES;
            INHERITED.SIGN.STUFF = MUSH_OUT$ -> FIELD_RECORD.SIGN;
            INHERITED.SIGN.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
            IF INHERITED.SIGN.LEVEL = '01'
            THEN
              DO;
                INHERITED.SIGN.GROUPIEST_NON_01_LEVEL = '99';
                MUSH_OUT$ -> FIELD_RECORD.SIGN = ' ';
              END;
          END;
        IF MUSH_OUT$ -> FIELD_RECORD.REPEATS_X ~= ' '
          AND MUSH_OUT$ -> FIELD_RECORD.REPEATS_X ~= '000'
        THEN
          DO;
            IF NOT INHERITED.REPEATS_Y.YUP
            THEN
              DO;
                INHERITED.REPEATS_Y.YUP = %YES;
                INHERITED.REPEATS_Y.GROUP_MINIMUM = %BINCHAR ( MAXIMUM_FIELD_LENGTH + 1 );
                INHERITED.REPEATS_Y.GROUP_MAXIMUM = %BINCHAR ( 0 );
                INHERITED.REPEATS_Y.GROUP_SEQUENCE# = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
                INHERITED.REPEATS_Y.STUFF = MUSH_OUT$ -> FIELD_RECORD.REPEATS_X;
                INHERITED.REPEATS_Y.SEPARATED = MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X;
                INHERITED.REPEATS_Y.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
                IF INHERITED.REPEATS_Y.LEVEL = '01'
                THEN
                  DO;
                    %ABANDON_SHIP (
                    ERROR = "'Ick:  you have an 01-level field with a REPEATS clause.'"
                    );
                    ALTRETURN;
                  END;
              END;
            ELSE
              DO;
                INHERITED.REPEATS_X.YUP = %YES;
                INHERITED.REPEATS_X.GROUP_MINIMUM = %BINCHAR ( MAXIMUM_FIELD_LENGTH + 1 );
                INHERITED.REPEATS_X.GROUP_MAXIMUM = %BINCHAR ( 0 );
                INHERITED.REPEATS_X.GROUP_SEQUENCE# = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
                INHERITED.REPEATS_X.STUFF = MUSH_OUT$ -> FIELD_RECORD.REPEATS_X;
                INHERITED.REPEATS_X.SEPARATED = MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X;
                INHERITED.REPEATS_X.LEVEL = MUSH_OUT$ -> FIELD_RECORD.LEVEL#;
                IF INHERITED.REPEATS_X.LEVEL = '01'
                THEN
                  DO;
                    %ABANDON_SHIP (
                    ERROR = "'Ick:  you have an 01-level field with a REPEATS clause.'"
                    );
                    ALTRETURN;
                  END;
              END;
          END;
      END;
 
    IF MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
    THEN
      MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L';
    IF MUSH_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'N'
    THEN
      MUSH_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'L';
 
    IF MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT ~= ' '
    THEN
      DO;
        CALL CHARBIN ( A_UBIN_WHATEVER,
          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH );
        IF MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH ~= ' '
        THEN
          IF A_UBIN_WHATEVER = %MAXIMUM_FIELD_LENGTH
            OR MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
          THEN
            MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH =
              MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH;
      END;
 
    IF MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D'
      AND MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
    THEN
      DO;
 
        CALL CHARBIN ( A_UBIN_WHATEVER,
          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH );
        CALL REPLACE_DEFAULT_SPECIALS
          ( MUSH_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
          A_UBIN_WHATEVER );
 
      END;
 
    IF MUSH_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
      AND MUSH_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
    THEN
      DO;
 
        CALL CHARBIN ( A_UBIN_WHATEVER,
          MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
        SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING,
          0,
          A_UBIN_WHATEVER ) =
          MUSH_OUT$ -> FIELD_RECORD.CONSTANT_VALUE;
 
        CALL REPLACE_CONSTANT_SPECIALS
          ( MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING,
          A_UBIN_WHATEVER );
 
      END;
 
    CALL M$WRITE ( WRITE_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    RETURN;
 
END CLEANUP_THE_LAST_FIELD;
%EJECT;
GET_GROUP_SEQUENCE#: PROC;
 
    CALL CHARBIN ( A_UBIN_WHATEVER,
      MUSH_OUT$ -> FIELD_RECORD.LEVEL# );
 
GET_LAST_GROUPS_SEQUENCE#:
    DO GROUP_SEQUENCE#_INDEX = A_UBIN_WHATEVER - 1 DOWNTO 0;
 
      IF GROUP_SEQUENCE# ( GROUP_SEQUENCE#_INDEX ) ~= '0000000000'
      THEN
        DO;
          MUSH_OUT$ -> FIELD_RECORD.GROUP_SEQUENCE# =
            GROUP_SEQUENCE# ( GROUP_SEQUENCE#_INDEX );
          EXIT GET_LAST_GROUPS_SEQUENCE#;
        END;
 
    END GET_LAST_GROUPS_SEQUENCE#;
 
    RETURN;
 
END GET_GROUP_SEQUENCE#;
 
PUT_GROUP_SEQUENCE#: PROC;
 
    CALL CHARBIN ( A_UBIN_WHATEVER,
      MUSH_OUT$ -> FIELD_RECORD.LEVEL# );
 
    GROUP_SEQUENCE# ( A_UBIN_WHATEVER ) =
      MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
 
    DO GROUP_SEQUENCE#_INDEX = A_UBIN_WHATEVER + 1 TO 49;
 
      GROUP_SEQUENCE# ( GROUP_SEQUENCE#_INDEX ) = '0000000000';
 
    END;
 
    RETURN;
 
END PUT_GROUP_SEQUENCE#;
%EJECT;
REINHERIT_SEPARATEDNESS: PROC ALTRET;
 
  DCL GROUP_SEPARATION UBIN;
  DCL GROUP_SEPARATION_DIFFERENCE UBIN;
  DCL ITS_FOR_REPEATS_Y BIT(1) ALIGNED;
  DCL MAXIMUM_POSITION UBIN;
  DCL MINIMUM_POSITION UBIN;
  DCL OLD_SEPARATION UBIN;
  DCL SEQUENCE#_KEY CHAR(10);
  DCL 1 SEQUENCE#_KEY_PARTS REDEF SEQUENCE#_KEY,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
 
REINHERIT_Y_SEPARATEDNESS: ENTRY ALTRET;
 
    IF INHERITED.REPEATS_Y.GROUP_MINIMUM = INHERITED.REPEATS_Y.GROUP_MAXIMUM
    THEN
      RETURN;
 
    CALL CHARBIN ( MINIMUM_POSITION,
      INHERITED.REPEATS_Y.GROUP_MINIMUM );
    CALL CHARBIN ( MAXIMUM_POSITION,
      INHERITED.REPEATS_Y.GROUP_MAXIMUM );
    CALL CHARBIN ( OLD_SEPARATION,
      INHERITED.REPEATS_Y.SEPARATED );
 
    GROUP_SEPARATION =
      ( MAXIMUM_POSITION
      - MINIMUM_POSITION )
      + OLD_SEPARATION;
 
    GROUP_SEPARATION_DIFFERENCE =
      GROUP_SEPARATION
      - OLD_SEPARATION;
 
    CALL CHARBIN ( A_UBIN_WHATEVER,
      INHERITED.REPEATS_Y.GROUP_SEQUENCE#_PARTS.INTEGER );
 
    ITS_FOR_REPEATS_Y = %YES;
 
    GOTO SO_REINHERIT_IT_ALREADY;
 
REINHERIT_X_SEPARATEDNESS: ENTRY ALTRET;
 
    IF INHERITED.REPEATS_X.GROUP_MINIMUM = INHERITED.REPEATS_X.GROUP_MAXIMUM
    THEN
      RETURN;
 
    CALL CHARBIN ( MINIMUM_POSITION,
      INHERITED.REPEATS_X.GROUP_MINIMUM );
    CALL CHARBIN ( MAXIMUM_POSITION,
      INHERITED.REPEATS_X.GROUP_MAXIMUM );
    CALL CHARBIN ( OLD_SEPARATION,
      INHERITED.REPEATS_X.SEPARATED );
 
    GROUP_SEPARATION =
      ( ( MAXIMUM_POSITION
      + INHERITED.REPEATS_X.GROUP_RIGHTMOST_ITEM_LENGTH )
      - MINIMUM_POSITION )
      + OLD_SEPARATION;
 
    GROUP_SEPARATION_DIFFERENCE =
      GROUP_SEPARATION
      - OLD_SEPARATION;
 
    CALL CHARBIN ( A_UBIN_WHATEVER,
      INHERITED.REPEATS_X.GROUP_SEQUENCE#_PARTS.INTEGER );
 
    ITS_FOR_REPEATS_Y = %NO;
 
SO_REINHERIT_IT_ALREADY:
    A_UBIN_WHATEVER = A_UBIN_WHATEVER + 1;
    CALL BINCHAR ( SEQUENCE#_KEY_PARTS.INTEGER,
      A_UBIN_WHATEVER );
    SEQUENCE#_KEY_PARTS.FRACTION = '00000';
    READ_MUSH_SOURCE.KEY_ = VECTOR ( SEQUENCE#_KEY );
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
 
REINHERIT_THAT_PUPPY:
    DO WHILE ( '1'B );
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
        THEN
          EXIT REINHERIT_THAT_PUPPY;
        ELSE
          DO;
            CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
            ALTRETURN;
          END;
      END;
 
      IF MUSH_IN$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
      THEN
        DO;
          IF ITS_FOR_REPEATS_Y
          THEN
            DO;
              CALL BINCHAR ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y,
                GROUP_SEPARATION );
              CALL BINCHAR ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y_GROUP_DIFFERENCE,
                GROUP_SEPARATION_DIFFERENCE );
            END;
          ELSE
            DO;
              CALL CHARBIN ( A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
              CALL BINCHAR ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_X,
                GROUP_SEPARATION
                - A_UBIN_WHATEVER );
              CALL BINCHAR ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_X_GROUP_DIFFERENCE,
                GROUP_SEPARATION_DIFFERENCE
                - A_UBIN_WHATEVER );
            END;
 
          WRITE_MUSH_SOURCE.BUF_ = VECTOR ( MUSH_IN_BUFFER );
          CALL M$WRITE ( WRITE_MUSH_SOURCE )
          WHENALTRETURN
          DO;
            CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
            WRITE_MUSH_SOURCE.BUF_ = VECTOR ( MUSH_OUT_BUFFER );
            ALTRETURN;
          END;
          WRITE_MUSH_SOURCE.BUF_ = VECTOR ( MUSH_OUT_BUFFER );
        END;
 
      READ_MUSH_SOURCE.V.KEYS# = %NO;
 
    END REINHERIT_THAT_PUPPY;
 
    RETURN;
 
END REINHERIT_SEPARATEDNESS;
 
END PARSE_A_FRAME;
 
END FPL_TO_MUSH;
%EJECT;
GET_FRAMES: PROC ALTRET;
 
    CG_OUT$ -> FRAME_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
 
    DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
      CG_OUT$ -> FRAME_RECORD.IS_ACTIVE =
        STATION.FRAME_A.IS_ACTIVE ( FRAME_INDEX );
      CG_OUT$ -> FRAME_RECORD.FRAME_NAME =
        STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX );
      CALL M$WRITE ( WRITE_CG )
      WHENALTRETURN
      DO;
      END;
 
    END;
 
    CG_OUT$ -> FRAME_RECORD.ERROR_CODE = %ERROR_NO_MORE_FRAMES;
    CALL M$WRITE ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
END GET_FRAMES;
%EJECT;
SET_ACTIVATION: PROC ALTRET;
 
    DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
      IF STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX ) =
        CG_IN$ -> FRAME_RECORD.FRAME_NAME
      THEN
        DO;
          STATION.FRAME_A.IS_ACTIVE ( FRAME_INDEX ) =
            CG_IN$ -> FRAME_RECORD.IS_ACTIVE;
          RETURN;
        END;
 
    END;
 
    %ABANDON_SHIP (
    ERROR = "'can''t find FRame-name.'",
    INTERNAL_ERROR = YES
    );
 
    ALTRETURN;
 
END SET_ACTIVATION;
%EJECT;
ADD_FRAME: PROC ALTRET;
 
    CALL ADD_A_FRAME ( CG_IN$ -> FRAME_RECORD.FRAME_NAME )
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    CALL SET_ACTIVATION
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    MUSH_OUT_BUFFER = ' ';
 
    STATION.MAXIMUM_SEQUENCE# = STATION.MAXIMUM_SEQUENCE# + 100;
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.INTEGER,
      STATION.MAXIMUM_SEQUENCE# );
    MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.FRACTION = '00000';
 
    MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME =
      CG_IN$ -> FRAME_RECORD.FRAME_NAME;
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_X,
      0 );
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_Y,
      0 );
    MUSH_OUT$ -> FIELD_RECORD.LEVEL# = '00';
    MUSH_OUT$ -> FIELD_RECORD.NAME =
      CG_IN$ -> FRAME_RECORD.FRAME_NAME;
 
 
    CALL M$WRITE ( WRITE_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    MUSH_OUT_BUFFER = ' ';
 
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.GROUP_SEQUENCE#_PARTS.INTEGER,
      STATION.MAXIMUM_SEQUENCE# );
    MUSH_OUT$ -> FIELD_RECORD.GROUP_SEQUENCE#_PARTS.FRACTION = '00000';
    STATION.MAXIMUM_SEQUENCE# = STATION.MAXIMUM_SEQUENCE# + 1;
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.INTEGER,
      STATION.MAXIMUM_SEQUENCE# );
    MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.FRACTION = '00000';
 
    MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME =
      CG_IN$ -> FRAME_RECORD.FRAME_NAME;
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_X,
      0 );
    CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.ORIGIN_Y,
      0 );
    MUSH_OUT$ -> FIELD_RECORD.LEVEL# = '01';
 
    CALL INDEX ( BLANK_INDEX,
      ' ',
      CG_IN$ -> FRAME_RECORD.FRAME_NAME );
    MUSH_OUT$ -> FIELD_RECORD.NAME =
      SUBSTR ( CG_IN$ -> FRAME_RECORD.FRAME_NAME,
      0,
      MINIMUM ( BLANK_INDEX, LENGTHC ( FRAME_RECORD.FRAME_NAME ) - 7 ) );
    SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.NAME,
      MINIMUM ( BLANK_INDEX, LENGTHC ( FRAME_RECORD.FRAME_NAME ) - 7 ),
      7 ) = '-RECORD';
 
    CALL M$WRITE ( WRITE_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    CG_OUT$ -> FRAME_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
    CALL M$WRITE ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
END ADD_FRAME;
 
ADD_A_FRAME: PROC ( FRAME_NAME ) ALTRET;
 
  DCL FRAME_NAME CHAR(30);
 
    STATION.MAX_FRAME_INDEX = STATION.MAX_FRAME_INDEX + 1;
    IF STATION.MAX_FRAME_INDEX > 99
    THEN
      DO;
        %ABANDON_SHIP (
        ERROR = "'Your FRame section COPY file has > 100 FRames...I give up!'"
        );
        ALTRETURN;
      END;
 
    STATION.FRAME_A.FRAME_NAME ( STATION.MAX_FRAME_INDEX ) = FRAME_NAME;
    STATION.FRAME_A.IS_ACTIVE ( STATION.MAX_FRAME_INDEX ) = 'N';
 
    RETURN;
 
END ADD_A_FRAME;
%EJECT;
LET_ER_RIP: PROC ALTRET;
 
  DCL WERE_RESUMING BIT(1) ALIGNED;
  DCL WE_FOUND_AT_LEAST_ONE_ACTIVE BIT(1) ALIGNED;
 
    WERE_RESUMING = %NO;
    READ_MUSH_SOURCE.V.INDX# = 3;
    WE_FOUND_AT_LEAST_ONE_ACTIVE = %NO;
    GOTO START_RIP;
 
LET_ER_RIP_RESUME: ENTRY ALTRET;
 
    WERE_RESUMING = %YES;
    READ_MUSH_SOURCE.V.INDX# = 3;
    WE_FOUND_AT_LEAST_ONE_ACTIVE = %YES;
    FRAME_INDEX = LET_ER_RIP_FRAME_INDEX_SAVED;
    GOTO RESUME_RIP;
 
START_RIP:
    DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
RESUME_RIP:
      IF STATION.FRAME_A.IS_ACTIVE ( FRAME_INDEX ) = 'Y'
      THEN
LOOK_IN_THIS_ACTIVE_FRAME:
        DO;
 
          WE_FOUND_AT_LEAST_ONE_ACTIVE = %YES;
 
          READ_MUSH_SOURCE.V.KEYS# = %YES;
          READ_MUSH_SOURCE.KEY_ =
            VECTOR ( STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX ) );
 
READ_FIELDS_WITHIN_FRAME:
          DO WHILE ( '1'B );
 
            CALL M$READ ( READ_MUSH_SOURCE )
            WHENALTRETURN
            DO;
              IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$KEYCHNG
              THEN
                EXIT LOOK_IN_THIS_ACTIVE_FRAME;
              ELSE
                DO;
                  CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
                  ALTRETURN;
                END;
            END;
 
            IF WERE_RESUMING
              AND MUSH_IN$ -> FIELD_RECORD.SEQUENCE# > LET_ER_RIP_SEQUENCE#_SAVED
            THEN
              WERE_RESUMING = %NO;
 
            IF NOT WERE_RESUMING
              AND MUSH_IN$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
            THEN
WRITE_FIELD_TO_FEP:
              DO;
                CG_OUT$ -> FIELD_RECORD = MUSH_IN$ -> FIELD_RECORD;
                CG_OUT$ -> FIELD_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
                CALL M$WRITE ( WRITE_CG )
                WHENALTRETURN
                DO;
                END;
 
                CG_IN_BUFFER = ' ';
 
                CALL M$READ ( READ_CG )
                WHENALTRETURN
                DO;
                  ALTRETURN;
                END;
 
                DO SELECT ( CG_IN$ -> WHATEVER_RECORD.FUNCTION );
 
                  SELECT ( %FUNCTION_LET_ER_RIP_ACK );
 
                  SELECT ( %FUNCTION_LET_ER_RIP_NACK );
                    LET_ER_RIP_FRAME_INDEX_SAVED = FRAME_INDEX;
                    LET_ER_RIP_SEQUENCE#_SAVED = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
                    RETURN;
 
                END;
 
              END WRITE_FIELD_TO_FEP;
 
            READ_MUSH_SOURCE.V.KEYS# = %NO;
 
          END READ_FIELDS_WITHIN_FRAME;
 
        END LOOK_IN_THIS_ACTIVE_FRAME;
 
    END;
 
    IF WE_FOUND_AT_LEAST_ONE_ACTIVE
    THEN
      DO;
        CG_OUT$ -> FIELD_RECORD.ERROR_CODE = %ERROR_NO_MORE_FIELDS;
        CALL M$WRITE ( WRITE_CG )
        WHENALTRETURN
        DO;
        END;
        RETURN;
      END;
 
    %ABANDON_SHIP (
    ERROR = "'You don''t have any ACTIVE FRames to PAINT with.'"
    );
    ALTRETURN;
 
END LET_ER_RIP;
%EJECT;
GET_FIELD_DETAILS: PROC ALTRET;
 
    READ_MUSH_SOURCE.V.INDX# = 2;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
    READ_MUSH_SOURCE.KEY_ = VECTOR ( POSITION_AND_FRAME_NAME_KEY );
    POSITION_AND_FRAME_NAME_KEY.POSITION_X = CG_IN$ -> FIELD_RECORD.POSITION_X;
    POSITION_AND_FRAME_NAME_KEY.POSITION_Y = CG_IN$ -> FIELD_RECORD.POSITION_Y;
 
FIND_THAT_PUPPY:
    DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
      IF STATION.FRAME_A.IS_ACTIVE ( FRAME_INDEX ) = 'Y'
      THEN
LOOK_IN_THIS_ACTIVE_FRAME:
        DO;
 
          POSITION_AND_FRAME_NAME_KEY.FRAME_NAME = STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX );
 
          CALL M$READ ( READ_MUSH_SOURCE )
          WHENALTRETURN
          DO;
            IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$NOKEY
            THEN
              EXIT LOOK_IN_THIS_ACTIVE_FRAME;
            ELSE
              DO;
                CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
                ALTRETURN;
              END;
          END;
 
          CG_OUT$ -> FIELD_RECORD = MUSH_IN$ -> FIELD_RECORD;
          CG_OUT$ -> FIELD_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
          CALL M$WRITE ( WRITE_CG )
          WHENALTRETURN
          DO;
          END;
 
          RETURN;
 
        END LOOK_IN_THIS_ACTIVE_FRAME;
 
    END FIND_THAT_PUPPY;
 
    %ABANDON_SHIP (
    ERROR = "'POSition in mush file lost.'",
    INTERNAL_ERROR = YES
    );
 
    ALTRETURN;
 
END GET_FIELD_DETAILS;
%EJECT;
PUT_FIELD_DETAILS: PROC ALTRET;
 
  DCL NEW_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_LOWER_BOUND_PARTS REDEF NEW_SEQUENCE#_LOWER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_UPPER_BOUND_PARTS REDEF NEW_SEQUENCE#_UPPER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL OLD_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL OLD_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL NEW_LEVEL# CHAR(2);
  DCL NEW_GROUP_SEQUENCE# CHAR(10);
  DCL PETTY_COMPLAINT_ALTRET_FLAG BIT(1) ALIGNED;
  DCL 1 INHERITANCE_TO_CLAIM,
        2 FRAME,
          3 YUP BIT(1) ALIGNED,
        2 NAME,
          3 YUP BIT(1) ALIGNED,
        2 VISUAL_ATTRIBUTE,
          3 YUP BIT(1) ALIGNED,
        2 IS_ENTRY_REQUIRED,
          3 YUP BIT(1) ALIGNED,
        2 IO,
          3 YUP BIT(1) ALIGNED,
        2 SIGN,
          3 YUP BIT(1) ALIGNED,
        2 REPEATS_X,
          3 YUP BIT(1) ALIGNED,
        2 REPEATS_Y,
          3 YUP BIT(1) ALIGNED;
  DCL WERE_ADDING_THIS_PUPPY BIT(1) ALIGNED;
  DCL WERE_MOVING_THIS_PUPPY BIT(1) ALIGNED;
 
    PETTY_COMPLAINT_ALTRET_FLAG = %NO;
 
    CG_OUT$ -> FIELD_RECORD = CG_IN$ -> FIELD_RECORD;
 
    /*
        Get rid of stray marks in the details:  try to set up
        an easily-checkable menu.
    */
    IF CG_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT ~= 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT = ' ';
    IF CG_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT ~= 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT = ' ';
    IF CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~= 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = ' ';
    IF CG_OUT$ -> FIELD_RECORD.IS_A_O_I_M ~= 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IS_A_O_I_M ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IS_A_O_I_M = ' ';
    IF CG_OUT$ -> FIELD_RECORD.MINIMUM_SIZE = '000'
    THEN
      CG_OUT$ -> FIELD_RECORD.MINIMUM_SIZE = ' ';
    IF CG_OUT$ -> FIELD_RECORD.IS_BWZ ~= 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IS_BWZ ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IS_BWZ = ' ';
    IF CG_OUT$ -> FIELD_RECORD.IS_JUSTIFIED_RIGHT ~= 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IS_JUSTIFIED_RIGHT ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IS_JUSTIFIED_RIGHT = ' ';
    IF CG_OUT$ -> FIELD_RECORD.REPEATS_X = '000'
    THEN
      DO;
        CG_OUT$ -> FIELD_RECORD.REPEATS_X = ' ';
        CG_OUT$ -> FIELD_RECORD.SEPARATED_X = ' ';
      END;
    IF CG_OUT$ -> FIELD_RECORD.REPEATS_Y = '000'
    THEN
      DO;
        CG_OUT$ -> FIELD_RECORD.REPEATS_Y = ' ';
        CG_OUT$ -> FIELD_RECORD.SEPARATED_Y = ' ';
      END;
    IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT ~= 'C'
      AND CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT ~= 'D'
      AND CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = ' ';
    IF CG_OUT$ -> FIELD_RECORD.PROMPT_TYPE ~= 'D'
      AND CG_OUT$ -> FIELD_RECORD.PROMPT_TYPE ~= 'L'
      AND CG_OUT$ -> FIELD_RECORD.PROMPT_TYPE ~= ' '
    THEN
      CG_OUT$ -> FIELD_RECORD.IS_PROMPT = ' ';
 
    /*
        Expand any abbreviations.
    */
    DO SELECT ( CG_OUT$ -> FIELD_RECORD.CLASS );
 
      SELECT ( 'A' );
        CG_OUT$ -> FIELD_RECORD.CLASS = 'ALPHABETIC';
 
      SELECT ( 'N' );
        CG_OUT$ -> FIELD_RECORD.CLASS = 'NUMERIC';
 
    END;
 
    DO SELECT ( CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE );
 
      SELECT ( 'EM' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'EMPHASIS-ATTRIBUTE';
 
      SELECT ( 'ER' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'ERROR-ATTRIBUTE';
 
      SELECT ( 'H' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'HIDDEN-ATTRIBUTE';
 
      SELECT ( 'I' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'INPUT-ATTRIBUTE';
 
      SELECT ( 'N' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'NULL-ATTRIBUTE';
 
      SELECT ( 'O' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'OUTPUT-ATTRIBUTE';
 
      SELECT ( 'W' );
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE = 'WARNING-ATTRIBUTE';
 
    END;
 
    /*
        Given a picture string, make a picture clause.
    */
    CALL PICTURE_STRING_TO_CLAUSE
    WHENALTRETURN
    DO;
      PETTY_COMPLAINT_ALTRET_FLAG = %YES;
    END;
 
    /*
        Fix up the string stuff:  CONSTANT, DEFAULT VALUEs
        and PROMPTs.
    */
    IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
    THEN
      DO;
        CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH =
          CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH;
 
        CG_OUT$ -> FIELD_RECORD.CONSTANT_VALUE =
          CG_OUT$ -> FIELD_RECORD.PICTURE_STRING;
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D'
    THEN
      DO;
        CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH =
          CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH;
 
        CALL CHARBIN ( A_UBIN_WHATEVER,
          CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH );
 
        IF CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N'
        THEN
          DO;
            BLANK_INDEX = A_UBIN_WHATEVER;
STRIP_DEFAULT_TRAILING_BLANKS:
            DO WHILE ( SUBSTR ( CG_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
              BLANK_INDEX - 1,
              1 ) = ' '
              OR SUBSTR ( CG_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
              BLANK_INDEX - 1,
              1 ) = '_' );
 
              BLANK_INDEX = BLANK_INDEX - 1;
 
            END STRIP_DEFAULT_TRAILING_BLANKS;
 
            MAXIMUM_FIELD_LENGTH_SCRAP = CG_OUT$ -> FIELD_RECORD.DEFAULT_VALUE;
            CG_OUT$ -> FIELD_RECORD.DEFAULT_VALUE = ' ';
            SUBSTR ( CG_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
              A_UBIN_WHATEVER - BLANK_INDEX,
              BLANK_INDEX ) = MAXIMUM_FIELD_LENGTH_SCRAP;
          END;
 
        CALL REPLACE_DEFAULT_SPECIALS
          ( CG_OUT$ -> FIELD_RECORD.DEFAULT_VALUE,
          A_UBIN_WHATEVER );
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.PROMPT_TYPE ~= ' '
      OR CG_OUT$ -> FIELD_RECORD.PROMPT ~= ' '
    THEN
      DO;
        CG_OUT$ -> FIELD_RECORD.IS_PROMPT = 'Y';
 
        BLANK_INDEX = %( MAXIMUM_FIELD_LENGTH - 1 );
STRIP_PROMPT_TRAILING_BLANKS:
        DO WHILE ( SUBSTR ( CG_OUT$ -> FIELD_RECORD.PROMPT,
          BLANK_INDEX - 1,
          1 ) = ' ' );
 
          BLANK_INDEX = BLANK_INDEX - 1;
 
        END STRIP_PROMPT_TRAILING_BLANKS;
 
        CALL BINCHAR ( CG_OUT$ -> FIELD_RECORD.PROMPT_LENGTH,
          BLANK_INDEX );
 
        IF CG_OUT$ -> FIELD_RECORD.PROMPT_TYPE ~= 'D'
        THEN
          CG_OUT$ -> FIELD_RECORD.PROMPT_TYPE = 'L';
      END;
    ELSE
      CG_OUT$ -> FIELD_RECORD.IS_PROMPT = ' ';
 
    /*
        Complain about stuff that can't be left out:
        field-names, frame-names, and I-O clauses.
    */
    IF CG_OUT$ -> FIELD_RECORD.NAME = ' '
    THEN
      DO;
        %ABANDON_SHIP (
        ERROR = "'All fields must have a name.'"
        );
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
CHECK_FOR_A_LEGAL_FRAME_NAME:
    DO;
FIND_OUR_FRAME:
      DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
        IF STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX ) =
          CG_OUT$ -> FIELD_RECORD.FRAME_NAME
        THEN
          DO;
            IF STATION.FRAME_A.IS_ACTIVE ( FRAME_INDEX ) ~= 'Y'
            THEN
              DO;
                %ABANDON_SHIP (
                ERROR = "'The frame-name specified is not ACTIVE.'"
                );
                PETTY_COMPLAINT_ALTRET_FLAG = %YES;
              END;
            EXIT CHECK_FOR_A_LEGAL_FRAME_NAME;
          END;
 
      END FIND_OUR_FRAME;
      PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      IF CG_OUT$ -> FIELD_RECORD.FRAME_NAME = ' '
      THEN
        DO;
          %ABANDON_SHIP (
          ERROR = "'All fields must have a frame-name:  a list of ACTIVE FRames follows.'"
          );
        END;
      ELSE
        %ABANDON_SHIP (
          ERROR = "'The frame-name specified does not exist:  a list of ACTIVE FRames follows.'"
          );
LIST_ACTIVE_FRAMES:
      DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
        IF STATION.FRAME_A.IS_ACTIVE ( FRAME_INDEX ) = 'Y'
        THEN
          %ABANDON_SHIP (
            ERROR = "STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX )"
            );
 
      END LIST_ACTIVE_FRAMES;
    END CHECK_FOR_A_LEGAL_FRAME_NAME;
 
    IF CG_OUT$ -> FIELD_RECORD.IO_VALUE = '  '
    THEN
      DO;
        %ABANDON_SHIP (
        ERROR = "'All fields must be either INPUT, OUTPUT, or I-O.'"
        );
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
    /*
        Complain about conflicting clauses.
    */
    IF CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'N'
    THEN
      DO;
        IF CG_OUT$ -> FIELD_RECORD.IS_JUSTIFIED_RIGHT = 'Y'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'Numeric fields may not specify JUSTIFIED RIGHT.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.FILL_CHARACTER ~= ' '
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'Numeric fields may not specify a FILL CHARACTER.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.CLASS ~= ' '
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'Numeric fields may not specify a CLASS alphabet.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.IO_VALUE = ' Y'
    THEN
      DO;
        IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'OUTPUT fields may not specify a DEFAULT VALUE.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = 'Y'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'OUTPUT fields may not specify ENTRY-REQUIRED.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.MINIMUM_SIZE ~= ' '
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'OUTPUT fields may not specify a MINIMUM SIZE.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.CLASS ~= ' '
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'OUTPUT fields may not specify a CLASS alphabet.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.IS_PROMPT = 'Y'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'OUTPUT fields may not specify a PROMPT.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.IS_A_O_I_M = 'Y'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'OUTPUT fields may not specify A-O-I-M.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
      END;
    ELSE
      DO;
        IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'INPUT fields may not specify a CONSTANT VALUE.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
 
        IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D'
          AND CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = 'Y'
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'The DEFAULT VALUE and ENTRY-REQUIRED clauses are mutually exclusive.'"
            );
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
      END;
 
    IF PETTY_COMPLAINT_ALTRET_FLAG
    THEN
      ALTRETURN;
 
    NEW_LEVEL# = '02';
 
    IF CG_OUT$ -> FIELD_RECORD.SEQUENCE# = ' '
    THEN
      DO;
        WERE_ADDING_THIS_PUPPY = %YES;
        WERE_MOVING_THIS_PUPPY = %NO;
      END;
    ELSE
      DO;
        WERE_MOVING_THIS_PUPPY = %YES;
        WERE_ADDING_THIS_PUPPY = %NO;
      END;
 
    IF WERE_MOVING_THIS_PUPPY
    THEN
GOT_AN_OLD_SEQUENCE#:
      DO;
 
        CALL ESTABLISH_DESTRUCTION_BOUNDS
          ( CG_OUT$ -> FIELD_RECORD.SEQUENCE# )
        WHENRETURN
        DO;
          CALL REPAIR_CASUALTYS_FAMILY
            ( CG_OUT$ -> FIELD_RECORD.SEQUENCE# )
          WHENRETURN
          DO;
            GOTO PUT_FIELD_DETAILS_SOME_DICE;
          END;
          WHENALTRETURN
          DO;
            ALTRETURN;
          END;
        END;
        WHENALTRETURN
        DO;
          CALL REPAIR_CASUALTYS_FAMILY
            ( CG_OUT$ -> FIELD_RECORD.SEQUENCE# )
          WHENALTRETURN
          DO;
            ALTRETURN;
          END;
        END;
 
      END;
 
    IF WERE_ADDING_THIS_PUPPY
    THEN
      DO;
        CALL LAST_02_IN_FRAME
        WHENALTRETURN
        DO;
          NEW_SEQUENCE#_UPPER_BOUND = '0000000000';
        END;
 
        CALL ADD_MUSH_RECORDS
          ( NEW_SEQUENCE#_LOWER_BOUND,
          NEW_SEQUENCE#_UPPER_BOUND,
          NEW_GROUP_SEQUENCE#,
          NEW_LEVEL# )
        WHENALTRETURN
        DO;
          ALTRETURN;
        END;
      END;
 
    IF WERE_MOVING_THIS_PUPPY
    THEN
      DO;
        IF INHERITANCE_TO_CLAIM.FRAME.YUP
        THEN
          CALL LAST_02_IN_FRAME
          WHENALTRETURN
          DO;
            NEW_SEQUENCE#_UPPER_BOUND = '0000000000';
          END;
        ELSE
          CALL LAST_NEW_LEVEL#_IN_GROUP
          WHENALTRETURN
          DO;
            NEW_SEQUENCE#_UPPER_BOUND = '0000000000';
          END;
 
        CALL MOVE_MUSH_RECORDS
          ( OLD_SEQUENCE#_LOWER_BOUND,
          OLD_SEQUENCE#_UPPER_BOUND,
          NEW_SEQUENCE#_LOWER_BOUND,
          NEW_SEQUENCE#_UPPER_BOUND,
          NEW_GROUP_SEQUENCE#,
          NEW_LEVEL# )
        WHENALTRETURN
        DO;
          ALTRETURN;
        END;
      END;
 
    CG_OUT$ -> FIELD_RECORD = MUSH_OUT$ -> FIELD_RECORD;
 
PUT_FIELD_DETAILS_SOME_DICE:
    CG_OUT$ -> FIELD_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
    CALL M$WRITE ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
%EJECT;
/*
    A previously-existing record has been updated.
    If a change has been made which causes the record to be
    incompatible with one of its current group items, find
    out how far up the disease has spread (and so how much
    to remove).  E.g.:
         02  ICK INPUT.
             03  ICK03.
                 04  ICK04.
             03  ICK03-2.
                 04  ICK04-2 PIC X [OUTPUT].
             03  ICK03-3.
    If ICK04-2 was changed to be OUTPUT, it must be removed
    from the ICK group, and ICK03-2 should go with it.
    In this case, SEQUENCE#_LOWER_BOUND would be set to
    ICK03-2's SEQUENCE#, and SEQUENCE#_UPPER_BOUND would be
    set to ICK04-2's SEQUENCE#.
*/
ESTABLISH_DESTRUCTION_BOUNDS: PROC ( SEQUENCE# ) ALTRET;
 
  DCL GROUPIEST_GROUP_SEQUENCE# CHAR(10);
  DCL GROUPIEST_SEQUENCE# CHAR(10);
  DCL GROUP_CASUALTY_COUNT UBIN;
  DCL LEVEL_CASUALTY_COUNT UBIN;
  DCL LOWEST_CASUALTY_LEVEL# CHAR(2);
  DCL SEQUENCE# CHAR(10);
 
    OLD_SEQUENCE#_LOWER_BOUND = SEQUENCE#;
    OLD_SEQUENCE#_UPPER_BOUND = SEQUENCE#;
 
    GROUP_CASUALTY_COUNT = 0;
    LEVEL_CASUALTY_COUNT = 0;
 
    CALL ASSUME_INHERITANCE_IS_OK;
 
    READ_MUSH_SOURCE.KEY_ = VECTOR ( SEQUENCE# );
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
 
SEARCH_OUTWARD_TO_SAFETY:
    DO WHILE ( '1'B );
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      CALL CHECK_CONFLICTING_INHERITANCE
      WHENRETURN
      DO;
 
        NEW_LEVEL# = LOWEST_CASUALTY_LEVEL#;
        NEW_GROUP_SEQUENCE# = GROUPIEST_GROUP_SEQUENCE#;
        IF LEVEL_CASUALTY_COUNT = GROUP_CASUALTY_COUNT
        THEN
          RETURN;
        ELSE
          ALTRETURN;
 
      END;
      WHENALTRETURN
      DO;
 
        IF MUSH_IN$ -> FIELD_RECORD.LEVEL# <= '01'
        THEN
          ALTRETURN;
 
        GROUPIEST_SEQUENCE# = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
        GROUPIEST_GROUP_SEQUENCE# = MUSH_IN$ -> FIELD_RECORD.GROUP_SEQUENCE#;
        LEVEL_CASUALTY_COUNT = LEVEL_CASUALTY_COUNT + 1;
        LOWEST_CASUALTY_LEVEL# = MUSH_IN$ -> FIELD_RECORD.LEVEL#;
        GROUP_CASUALTY_COUNT = 0;
        READ_MUSH_SOURCE.V.KEYS# = %NO;
 
SEARCH_FOR_OTHER_CASUALTIES:
        DO UNTIL ( MUSH_IN$ -> FIELD_RECORD.LEVEL# <=
          LOWEST_CASUALTY_LEVEL# );
 
          GROUP_CASUALTY_COUNT = GROUP_CASUALTY_COUNT + 1;
 
          CALL M$READ ( READ_MUSH_SOURCE )
          WHENALTRETURN
          DO;
            IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
            THEN
              DO;
                EXIT SEARCH_FOR_OTHER_CASUALTIES;
              END;
            ELSE
              DO;
                CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
                EXIT SEARCH_FOR_OTHER_CASUALTIES;
              END;
          END;
 
        END SEARCH_FOR_OTHER_CASUALTIES;
 
        IF LEVEL_CASUALTY_COUNT = GROUP_CASUALTY_COUNT
        THEN
          DO;
            OLD_SEQUENCE#_LOWER_BOUND = GROUPIEST_SEQUENCE#;
          END;
 
        READ_MUSH_SOURCE.KEY_ = VECTOR ( GROUPIEST_GROUP_SEQUENCE# );
        READ_MUSH_SOURCE.V.KEYS# = %YES;
 
      END;
 
    END SEARCH_OUTWARD_TO_SAFETY;
 
END ESTABLISH_DESTRUCTION_BOUNDS;
%EJECT;
REPAIR_CASUALTYS_FAMILY: PROC ( SEQUENCE# ) ALTRET;
 
  DCL SEQUENCE# CHAR(10);
 
    READ_MUSH_SOURCE.KEY_ = VECTOR ( SEQUENCE# );
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
 
    MUSH_OUT$ -> FIELD_RECORD = CG_OUT$ -> FIELD_RECORD;
 
SEARCH_FOR_CASUALTYS_FAMILY:
    DO WHILE ( '1'B );
 
      IF MUSH_OUT$ -> FIELD_RECORD.SEQUENCE# = OLD_SEQUENCE#_LOWER_BOUND
      THEN
        CALL CLAIM_INHERITANCE;
 
      CALL M$WRITE ( WRITE_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      IF MUSH_OUT$ -> FIELD_RECORD.SEQUENCE# = OLD_SEQUENCE#_LOWER_BOUND
      THEN
        EXIT SEARCH_FOR_CASUALTYS_FAMILY;
 
      READ_MUSH_SOURCE.KEY_ = VECTOR ( MUSH_OUT$ -> FIELD_RECORD.GROUP_SEQUENCE# );
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      MUSH_OUT$ -> FIELD_RECORD = MUSH_IN$ -> FIELD_RECORD;
 
      CALL REPAIR_CONFLICTING_INHERITANCE;
 
    END SEARCH_FOR_CASUALTYS_FAMILY;
 
    RETURN;
 
END REPAIR_CASUALTYS_FAMILY;
%EJECT;
/*
    If WERE_ADDING_THIS_PUPPY
    then we have no idea quite where to put it.  Try it as the
    last 02-level item (in the last 01-level record) in the
    frame it's destined for.
*/
LAST_02_IN_FRAME: PROC ALTRET;
 
FIND_OUR_FRAME:
    DO FRAME_INDEX = 0 TO STATION.MAX_FRAME_INDEX;
 
      IF STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX ) =
        CG_OUT$ -> FIELD_RECORD.FRAME_NAME
      THEN
        EXIT FIND_OUR_FRAME;
 
    END FIND_OUR_FRAME;
 
    FRAME_INDEX = FRAME_INDEX
      + 1;
 
    IF FRAME_INDEX > STATION.MAX_FRAME_INDEX
    THEN
      DO;
 
        PFIL_MUSH_SOURCE.V.BOF# = %NO;
        PFIL_MUSH_SOURCE.V.INDX# = 1;
 
        CALL M$PFIL ( PFIL_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( PFIL_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
        PRECORD_MUSH_SOURCE.KEY_ = VECTOR ( NEW_SEQUENCE#_LOWER_BOUND );
        PRECORD_MUSH_SOURCE.V.INDX# = 1;
        PRECORD_MUSH_SOURCE.V.KEYR# = %YES;
        PRECORD_MUSH_SOURCE.V.N# = -1;
 
        CALL M$PRECORD ( PRECORD_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( PRECORD_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
        NEW_SEQUENCE#_UPPER_BOUND = '0000000000';
 
      END;
    ELSE
      DO;
 
        READ_MUSH_SOURCE.KEY_ = VECTOR ( STATION.FRAME_A.FRAME_NAME ( FRAME_INDEX ) );
        READ_MUSH_SOURCE.V.INDX# = 3;
        READ_MUSH_SOURCE.V.KEYS# = %YES;
 
        CALL M$READ ( READ_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
        NEW_SEQUENCE#_UPPER_BOUND = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
        NEW_SEQUENCE#_LOWER_BOUND = NEW_SEQUENCE#_UPPER_BOUND;
 
        PRECORD_MUSH_SOURCE.KEY_ = VECTOR ( NEW_SEQUENCE#_LOWER_BOUND );
        PRECORD_MUSH_SOURCE.V.INDX# = 1;
        PRECORD_MUSH_SOURCE.V.KEYR# = %YES;
        PRECORD_MUSH_SOURCE.V.KEYS# = %YES;
        PRECORD_MUSH_SOURCE.V.N# = -1;
 
        CALL M$PRECORD ( PRECORD_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( PRECORD_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
      END;
 
    READ_MUSH_SOURCE.KEY_ = VECTOR ( NEW_SEQUENCE#_LOWER_BOUND );
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
 
    CALL M$READ ( READ_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    CG_OUT$ -> FIELD_RECORD.ORIGIN_X =
      MUSH_IN$ -> FIELD_RECORD.ORIGIN_X;
    CG_OUT$ -> FIELD_RECORD.ORIGIN_Y =
      MUSH_IN$ -> FIELD_RECORD.ORIGIN_Y;
 
    IF MUSH_IN$ -> FIELD_RECORD.LEVEL# = '00'
      OR ( MUSH_IN$ -> FIELD_RECORD.LEVEL# = '01'
      AND MUSH_IN$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' ' )
    THEN
      DO;
 
        MUSH_OUT_BUFFER = ' ';
 
        CALL FIDDLE_WITH_SEQUENCE#S
          ( NEW_SEQUENCE#_LOWER_BOUND,
          NEW_SEQUENCE#_UPPER_BOUND )
        WHENALTRETURN
        DO;
          ALTRETURN;
        END;
 
        MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME =
          MUSH_IN$ -> FIELD_RECORD.FRAME_NAME;
        MUSH_OUT$ -> FIELD_RECORD.ORIGIN_X =
          MUSH_IN$ -> FIELD_RECORD.ORIGIN_X;
        MUSH_OUT$ -> FIELD_RECORD.ORIGIN_Y =
          MUSH_IN$ -> FIELD_RECORD.ORIGIN_Y;
        MUSH_OUT$ -> FIELD_RECORD.LEVEL# = '01';
 
        CALL INDEX ( BLANK_INDEX,
          ' ',
          MUSH_IN$ -> FIELD_RECORD.FRAME_NAME );
        MUSH_OUT$ -> FIELD_RECORD.NAME =
          SUBSTR ( MUSH_IN$ -> FIELD_RECORD.FRAME_NAME,
          0,
          MINIMUM ( BLANK_INDEX, LENGTHC ( FIELD_RECORD.FRAME_NAME ) - 7 ) );
        SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.NAME,
          MINIMUM ( BLANK_INDEX, LENGTHC ( FIELD_RECORD.FRAME_NAME ) - 7 ),
          7 ) = '-RECORD';
 
 
        CALL M$WRITE ( WRITE_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
        NEW_GROUP_SEQUENCE# = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
        NEW_SEQUENCE#_LOWER_BOUND = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
 
      END;
    ELSE
      DO;
 
        DO WHILE ( MUSH_IN$ -> FIELD_RECORD.LEVEL# > '01' );
 
          READ_MUSH_SOURCE.KEY_ = VECTOR ( MUSH_IN$ -> FIELD_RECORD.GROUP_SEQUENCE# );
 
          CALL M$READ ( READ_MUSH_SOURCE )
          WHENALTRETURN
          DO;
            CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
            ALTRETURN;
          END;
 
        END;
 
        NEW_GROUP_SEQUENCE# = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
 
      END;
 
    RETURN;
 
END LAST_02_IN_FRAME;
%EJECT;
/*
    If WERE_MOVING_THIS_PUPPY
    then we know what the NEW_LEVEL# is for the item we're PUTting,
    so stick it as the last group of level NEW_LEVEL#, e.g.:
       01  ICK-01.
           02  ICK-02 INPUT.
               03  ICK-03.
                   04  ICK-04 PIC X.
                   04  ICK-04-2 PIC X [OUTPUT].
               03  ICK-03-2 PIC X.
           02  ICK-02-2 I-O PIC X.
       01  ICK-01-2.
    if ICK-04-2 were changed to OUTPUT to conflict with ICK-02's
    INPUT, we'd be replacing it as the last 02-level item in ICK-01
    (NEW_SEQUENCE#_LOWER_BOUND = ICK-02-2's SEQUENCE#,
    and NEW_SEQUENCE#_UPPER_BOUND = ICK-01's SEQUENCE#).
*/
LAST_NEW_LEVEL#_IN_GROUP: PROC ALTRET;
 
    PRECORD_MUSH_SOURCE.KEY_ = VECTOR ( CG_OUT$ -> FIELD_RECORD.SEQUENCE# );
    PRECORD_MUSH_SOURCE.V.INDX# = 1;
    PRECORD_MUSH_SOURCE.V.KEYS# = %YES;
 
    CALL M$PRECORD ( PRECORD_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( PRECORD_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %NO;
 
    NEW_SEQUENCE#_UPPER_BOUND = CG_OUT$ -> FIELD_RECORD.SEQUENCE#;
 
FIND_LAST_NEW_LEVEL#_IN_GROUP:
    DO UNTIL ( MUSH_IN$ -> FIELD_RECORD.LEVEL# < NEW_LEVEL# );
 
      NEW_SEQUENCE#_LOWER_BOUND = NEW_SEQUENCE#_UPPER_BOUND;
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
        THEN
          DO;
            NEW_SEQUENCE#_UPPER_BOUND = '0000000000';
            EXIT FIND_LAST_NEW_LEVEL#_IN_GROUP;
          END;
        ELSE
          DO;
            CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
            ALTRETURN;
          END;
      END;
 
      NEW_SEQUENCE#_UPPER_BOUND = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
 
    END FIND_LAST_NEW_LEVEL#_IN_GROUP;
 
    RETURN;
 
END LAST_NEW_LEVEL#_IN_GROUP;
%EJECT;
ASSUME_INHERITANCE_IS_OK: PROC;
 
    INHERITANCE_TO_CLAIM.NAME.YUP = %NO;
    INHERITANCE_TO_CLAIM.FRAME.YUP = %NO;
    INHERITANCE_TO_CLAIM.VISUAL_ATTRIBUTE.YUP = %NO;
    INHERITANCE_TO_CLAIM.IS_ENTRY_REQUIRED.YUP = %NO;
    INHERITANCE_TO_CLAIM.IO.YUP = %NO;
    INHERITANCE_TO_CLAIM.SIGN.YUP = %NO;
    INHERITANCE_TO_CLAIM.REPEATS_X.YUP = %NO;
    INHERITANCE_TO_CLAIM.REPEATS_Y.YUP = %NO;
 
    RETURN;
 
END ASSUME_INHERITANCE_IS_OK;
 
CHECK_CONFLICTING_INHERITANCE: PROC ALTRET;
 
  DCL PETTY_COMPLAINT_ALTRET_FLAG BIT(1) ALIGNED;
 
    PETTY_COMPLAINT_ALTRET_FLAG = %NO;
 
    IF MUSH_IN$ -> FIELD_RECORD.FRAME_NAME ~=
      CG_OUT$ -> FIELD_RECORD.FRAME_NAME
    THEN
      DO;
        INHERITANCE_TO_CLAIM.FRAME.YUP = %YES;
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.IS_DOWN_NAME_FOR_ABOVE = 'Y'
      AND MUSH_IN$ -> FIELD_RECORD.IS_DOWN_NAME_FROM_BELOW = 'Y'
    THEN
      DO;
        CALL INDEX ( BLANK_INDEX,
          ' ',
          CG_OUT$ -> FIELD_RECORD.NAME );
        IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.NAME, 0, BLANK_INDEX ) ~=
          SUBSTR ( MUSH_IN$ -> FIELD_RECORD.NAME, 0, BLANK_INDEX )
        THEN
          IF NOT INHERITANCE_TO_CLAIM.NAME.YUP
          THEN
            DO;
              INHERITANCE_TO_CLAIM.NAME.YUP = %YES;
              PETTY_COMPLAINT_ALTRET_FLAG = %YES;
            END;
      END;
 
    IF ( CG_OUT$ -> FIELD_RECORD.IS_VISUAL_ATTRIBUTE_INHERITED = 'Y'
      AND MUSH_IN$ -> FIELD_RECORD.VISUAL_ATTRIBUTE ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.VISUAL_ATTRIBUTE ~=
      CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE )
    THEN
      DO;
        INHERITANCE_TO_CLAIM.VISUAL_ATTRIBUTE.YUP = %YES;
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
    IF ( CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED_INHERITED = 'Y'
      AND MUSH_IN$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~=
      CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED )
    THEN
      DO;
        INHERITANCE_TO_CLAIM.IS_ENTRY_REQUIRED.YUP = %YES;
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
    IF ( CG_OUT$ -> FIELD_RECORD.IS_IO_INHERITED = 'Y'
      AND MUSH_IN$ -> FIELD_RECORD.IO_VALUE ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.IO_VALUE ~=
      CG_OUT$ -> FIELD_RECORD.IO_VALUE )
    THEN
      DO;
        INHERITANCE_TO_CLAIM.IO.YUP = %YES;
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
    IF ( CG_OUT$ -> FIELD_RECORD.IS_SIGN_INHERITED = 'Y'
      AND MUSH_IN$ -> FIELD_RECORD.SIGN ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.SIGN ~=
      CG_OUT$ -> FIELD_RECORD.SIGN )
    THEN
      DO;
        INHERITANCE_TO_CLAIM.SIGN.YUP = %YES;
        PETTY_COMPLAINT_ALTRET_FLAG = %YES;
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.IS_REPEATS_X_INHERITED = 'Y'
      AND MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= '000'
      AND MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= '000'
    THEN
      DO;
        CALL CHARBIN ( A_UBIN_WHATEVER,
          CG_OUT$ -> FIELD_RECORD.SEPARATED_X );
        IF MUSH_IN$ -> FIELD_RECORD.SEQUENCE# =
          CG_OUT$ -> FIELD_RECORD.SEQUENCE#
        THEN
          A_UBIN_WHATEVER2 = 0;
        ELSE
          CALL CHARBIN ( A_UBIN_WHATEVER2,
            CG_OUT$ -> FIELD_RECORD.SEPARATED_X_GROUP_DIFFERENCE );
        CALL BINCHAR ( A_CHAR3_WHATEVER,
          MAXIMUM ( 0, A_UBIN_WHATEVER - A_UBIN_WHATEVER2 ) );
        IF MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~=
          CG_OUT$ -> FIELD_RECORD.REPEATS_X
          OR MUSH_IN$ -> FIELD_RECORD.SEPARATED_X ~=
          A_CHAR3_WHATEVER
        THEN
          DO;
            INHERITANCE_TO_CLAIM.REPEATS_X.YUP = %YES;
            PETTY_COMPLAINT_ALTRET_FLAG = %YES;
          END;
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.IS_REPEATS_Y_INHERITED = 'Y'
    THEN
      DO;
        IF MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= ' '
          AND MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= '000'
        THEN
          DO;
            CALL CHARBIN ( A_UBIN_WHATEVER,
              CG_OUT$ -> FIELD_RECORD.SEPARATED_Y );
            IF MUSH_IN$ -> FIELD_RECORD.SEQUENCE# =
              CG_OUT$ -> FIELD_RECORD.SEQUENCE#
            THEN
              A_UBIN_WHATEVER2 = 0;
            ELSE
              CALL CHARBIN ( A_UBIN_WHATEVER2,
                CG_OUT$ -> FIELD_RECORD.SEPARATED_Y_GROUP_DIFFERENCE );
            CALL BINCHAR ( A_CHAR3_WHATEVER,
              MAXIMUM ( 0, A_UBIN_WHATEVER - A_UBIN_WHATEVER2 ) );
            IF MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~=
              CG_OUT$ -> FIELD_RECORD.REPEATS_Y
              OR MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y ~=
              A_CHAR3_WHATEVER
            THEN
              DO;
                INHERITANCE_TO_CLAIM.REPEATS_Y.YUP = %YES;
                PETTY_COMPLAINT_ALTRET_FLAG = %YES;
              END;
          END;
        ELSE
          IF MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= ' '
            AND MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= '000'
          THEN
            DO;
              CALL CHARBIN ( A_UBIN_WHATEVER,
                CG_OUT$ -> FIELD_RECORD.SEPARATED_X );
              IF MUSH_IN$ -> FIELD_RECORD.SEQUENCE# =
                CG_OUT$ -> FIELD_RECORD.SEQUENCE#
              THEN
                A_UBIN_WHATEVER2 = 0;
              ELSE
                CALL CHARBIN ( A_UBIN_WHATEVER2,
                  CG_OUT$ -> FIELD_RECORD.SEPARATED_X_GROUP_DIFFERENCE );
              CALL BINCHAR ( A_CHAR3_WHATEVER,
                MAXIMUM ( 0, A_UBIN_WHATEVER - A_UBIN_WHATEVER2 ) );
              IF MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~=
                CG_OUT$ -> FIELD_RECORD.REPEATS_Y
                OR MUSH_IN$ -> FIELD_RECORD.SEPARATED_X ~=
                A_CHAR3_WHATEVER
              THEN
                DO;
                  INHERITANCE_TO_CLAIM.REPEATS_Y.YUP = %YES;
                  PETTY_COMPLAINT_ALTRET_FLAG = %YES;
                END;
            END;
      END;
 
    IF PETTY_COMPLAINT_ALTRET_FLAG
    THEN
      ALTRETURN;
    ELSE
      RETURN;
 
END CHECK_CONFLICTING_INHERITANCE;
 
REPAIR_CONFLICTING_INHERITANCE: PROC;
 
    IF MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME ~=
      CG_OUT$ -> FIELD_RECORD.FRAME_NAME
    THEN
      MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME =
        CG_OUT$ -> FIELD_RECORD.FRAME_NAME;
    IF MUSH_OUT$ -> FIELD_RECORD.IS_DOWN_NAME_FROM_BELOW = 'Y'
      AND CG_OUT$ -> FIELD_RECORD.IS_DOWN_NAME_FOR_ABOVE = 'Y'
    THEN
      DO;
        CALL INDEX ( BLANK_INDEX,
          ' ',
          CG_OUT$ -> FIELD_RECORD.NAME );
        MUSH_OUT$ -> FIELD_RECORD.NAME =
          SUBSTR ( CG_OUT$ -> FIELD_RECORD.NAME,
          0,
          MINIMUM ( BLANK_INDEX, LENGTHC ( FIELD_RECORD.NAME ) - 5 ) );
        SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.NAME,
          MINIMUM ( BLANK_INDEX, LENGTHC ( FIELD_RECORD.NAME ) - 5 ),
          5 ) = '-DOWN';
      END;
    IF ( MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE ~=
      CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE )
    THEN
      MUSH_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE =
        CG_OUT$ -> FIELD_RECORD.VISUAL_ATTRIBUTE;
    IF ( MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED ~=
      CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED )
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED =
        CG_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED;
    IF ( MUSH_OUT$ -> FIELD_RECORD.IO_VALUE ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.IO_VALUE ~=
      CG_OUT$ -> FIELD_RECORD.IO_VALUE )
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IO_VALUE =
        CG_OUT$ -> FIELD_RECORD.IO_VALUE;
    IF ( MUSH_OUT$ -> FIELD_RECORD.SIGN ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.SIGN ~=
      CG_OUT$ -> FIELD_RECORD.SIGN )
    THEN
      MUSH_OUT$ -> FIELD_RECORD.SIGN =
        CG_OUT$ -> FIELD_RECORD.SIGN;
    IF MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y ~= '000'
      AND MUSH_OUT$ -> FIELD_RECORD.REPEATS_X ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.REPEATS_X ~= '000'
    THEN
      DO;
        MUSH_OUT$ -> FIELD_RECORD.REPEATS_X =
          CG_OUT$ -> FIELD_RECORD.REPEATS_X;
        MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X =
          CG_OUT$ -> FIELD_RECORD.SEPARATED_X;
        MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X_GROUP_DIFFERENCE = '000';
      END;
    IF MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y ~= ' '
      AND MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y ~= '000'
    THEN
      DO;
        MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y =
          CG_OUT$ -> FIELD_RECORD.REPEATS_Y;
        MUSH_OUT$ -> FIELD_RECORD.SEPARATED_Y =
          CG_OUT$ -> FIELD_RECORD.SEPARATED_Y;
        MUSH_OUT$ -> FIELD_RECORD.SEPARATED_Y_GROUP_DIFFERENCE = '000';
      END;
    ELSE
      IF MUSH_OUT$ -> FIELD_RECORD.REPEATS_X ~= ' '
        AND MUSH_OUT$ -> FIELD_RECORD.REPEATS_X ~= '000'
      THEN
        DO;
          MUSH_OUT$ -> FIELD_RECORD.REPEATS_X =
            CG_OUT$ -> FIELD_RECORD.REPEATS_Y;
          MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X =
            CG_OUT$ -> FIELD_RECORD.SEPARATED_Y;
          MUSH_OUT$ -> FIELD_RECORD.SEPARATED_X_GROUP_DIFFERENCE = '000';
        END;
 
    RETURN;
 
END REPAIR_CONFLICTING_INHERITANCE;
 
CLAIM_INHERITANCE: PROC;
 
    IF INHERITANCE_TO_CLAIM.VISUAL_ATTRIBUTE.YUP
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_VISUAL_ATTRIBUTE_INHERITED = ' ';
    IF INHERITANCE_TO_CLAIM.IS_ENTRY_REQUIRED.YUP
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_ENTRY_REQUIRED_INHERITED = ' ';
    IF INHERITANCE_TO_CLAIM.IO.YUP
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_IO_INHERITED = ' ';
    IF INHERITANCE_TO_CLAIM.SIGN.YUP
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_SIGN_INHERITED = ' ';
    IF INHERITANCE_TO_CLAIM.REPEATS_X.YUP
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_REPEATS_X_INHERITED = ' ';
    IF INHERITANCE_TO_CLAIM.REPEATS_Y.YUP
    THEN
      MUSH_OUT$ -> FIELD_RECORD.IS_REPEATS_Y_INHERITED = ' ';
 
    RETURN;
 
END CLAIM_INHERITANCE;
 
%EJECT;
PICTURE_STRING_TO_CLAUSE: PROC ALTRET;
 
  DCL LAST_CHARACTER CHAR(4);
  DCL LAST_CHARACTER_COUNT UBIN;
  DCL LAST_CHARACTER_INDEX UBIN;
  DCL LAST_CHARACTER_LENGTH UBIN;
  DCL PICTURE_CLAUSE_INDEX UBIN;
  DCL PICTURE_CLAUSE_POSITION UBIN;
  DCL PICTURE_STRING_INDEX UBIN;
  DCL THIS_INDEX UBIN;
  DCL PRECEDENCE_INIT(0:27) CHAR(29) STATIC INIT (
    'XXXXXXX    XXXXXXXXXXXXX X XX',  /* 'B' */
    'XXXXXXX    XXXXXXXXXXXXX X XX',  /* '0' */
    'XXXXXXX    XXXXXXXXXXXXX X XX',  /* '/' */
    'XXXXXXX    XXXXXXXXXXXX  X XX',  /* ',' */
    'XXXX XX    XXX  XX  X X     X',  /* '.' */
    '                            X',  /* '+' (L) */
    '                            X',  /* '-' (L) */
    'XXXXX      XXXXX    XXX  XXXX',  /* '+' (R) */
    'XXXXX      XXXXX    XXX  XXXX',  /* '-' (R) */
    'XXXXX      XXXXX    XXX  XXXX',  /* 'CR' */
    'XXXXX      XXXXX    XXX  XXXX',  /* 'DB' */
    '     XX                     X',  /* '$' */
    'XXXX XX    XXX              X',  /* Floating 'Z' (L) */
    'XXXX XX    XXX              X',  /* Floating '*' (L) */
    'XXXXXXX    XXXXX         X XX',  /* Floating 'Z' (R) */
    'XXXXXXX    XXXXX         X XX',  /* Floating '*' (R) */
    'XXXX       X    XX          X',  /* Floating '+' (L) */
    'XXXX       X    XX          X',  /* Floating '-' (L) */
    'XXXXX      X    XXXX     X XX',  /* Floating '+' (R) */
    'XXXXX      X    XXXX     X XX',  /* Floating '-' (R) */
    'XXXX XX             X    X XX',  /* Floating '$' (L) */
    'XXXXXXX             XX   X XX',  /* Floating '$' (R) */
    'XXXXXXX    XXX  XX  X XXXX XX',  /* '9' */
    'XXX                   XX    X',  /* 'X' */
    '                            X',  /* 'S' */
    'XXXX XX    XXX  XX  X X   XXX',  /* 'V' */
    'XXXX XX    XXX  XX  X X X X X',  /* 'P' (L) */
    '     XX    X          XX   XX'   /* 'P' (R) */
    );
  DCL PRECEDENCE_TABLE(0:%((28*29)-1)) REDEF PRECEDENCE_INIT CHAR(1) UNAL;
  DCL WEVE_SEEN_A_PERIOD BIT(1) ALIGNED;
 
    PICTURE_CLAUSE_POSITION = 0;
    CG_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE = ' ';
 
    IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
    THEN
      DO;
        CALL CHARBIN ( A_UBIN_WHATEVER,
          CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
        CALL REPEAT_THE_PICTURE_CHARACTER
          ( 'X', 1, A_UBIN_WHATEVER )
          ALTRET ( STRING_TO_CLAUSE_NO_DICE );
      END;
    ELSE
      DO;
 
        LAST_CHARACTER = ' ';
        LAST_CHARACTER_LENGTH = 0;
        LAST_CHARACTER_COUNT = 0;
        LAST_CHARACTER_INDEX = %MAXIMUM_CHARACTER_INDEX - 1;
 
        PICTURE_STRING_INDEX = 0;
 
        CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'N';
        WEVE_SEEN_A_PERIOD = %NO;
 
UNSTUFF_PICTURE_STRING:
        DO WHILE ( '1'B );
 
          IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING,
            PICTURE_STRING_INDEX,
            1 ) = LAST_CHARACTER
          THEN
            LAST_CHARACTER_COUNT = LAST_CHARACTER_COUNT + 1;
          ELSE
            DO;
 
              DO SELECT ( SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING,
                PICTURE_STRING_INDEX,
                1 ) );
 
                SELECT ( ' ' );
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  EXIT UNSTUFF_PICTURE_STRING;
 
                SELECT ( 'B' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %B_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'B';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '0' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %ZERO_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '0';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '/' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %SLASH_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '/';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( ',' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %COMMA_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = ',';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '.' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  IF WEVE_SEEN_A_PERIOD
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  WEVE_SEEN_A_PERIOD = %YES;
 
                  THIS_INDEX = %PERIOD_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '.';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '+' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %PLUS_SIGN_INDEX;
                  IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) = '+'
                    OR ( SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) = '.'
                    AND SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 2, 1 ) = '+' )
                  THEN
                    THIS_INDEX = %FLOATING_PLUS_SIGN_INDEX;
 
                  IF WEVE_SEEN_A_PERIOD
                  THEN
                    THIS_INDEX = THIS_INDEX + 2;
 
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '+';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '-' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %MINUS_SIGN_INDEX;
                  IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) = '-'
                    OR ( SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) = '.'
                    AND SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 2, 1 ) = '-' )
                  THEN
                    THIS_INDEX = %FLOATING_MINUS_SIGN_INDEX;
 
                  IF WEVE_SEEN_A_PERIOD
                  THEN
                    THIS_INDEX = THIS_INDEX + 2;
 
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '-';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( 'C' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) ~= 'R'
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  THIS_INDEX = %CR_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'CR';
                  LAST_CHARACTER_LENGTH = 2;
                  LAST_CHARACTER_COUNT = 1;
 
                  PICTURE_STRING_INDEX = PICTURE_STRING_INDEX + 1;
 
                SELECT ( 'D' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) ~= 'B'
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  THIS_INDEX = %DB_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'DB';
                  LAST_CHARACTER_LENGTH = 2;
                  LAST_CHARACTER_COUNT = 1;
 
                  PICTURE_STRING_INDEX = PICTURE_STRING_INDEX + 1;
 
                SELECT ( '$' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %DOLLAR_SIGN_INDEX;
                  IF SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) = '$'
                    OR ( SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 1, 1 ) = '.'
                    AND SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_STRING, PICTURE_STRING_INDEX + 2, 1 ) = '$' )
                  THEN
                    DO;
                      THIS_INDEX = %FLOATING_DOLLAR_SIGN_INDEX;
 
                      IF WEVE_SEEN_A_PERIOD
                      THEN
                        THIS_INDEX = THIS_INDEX + 1;
                    END;
 
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '$';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( 'Z' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %FLOATING_Z_INDEX;
 
                  IF WEVE_SEEN_A_PERIOD
                  THEN
                    THIS_INDEX = THIS_INDEX + 2;
 
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'Z';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '*' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %FLOATING_ASTERISK_INDEX;
 
                  IF WEVE_SEEN_A_PERIOD
                  THEN
                    THIS_INDEX = THIS_INDEX + 2;
 
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '*';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( '9' );
                  THIS_INDEX = %NINE_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = '9';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( 'X' );
                  CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'A';
 
                  THIS_INDEX = %X_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'X';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( 'S' );
                  THIS_INDEX = %S_INDEX;
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'S';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
    /*          SELECT ( 'V' );
                  IF PRECEDENCE_TABLE ( %V_INDEX + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
         ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'V';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
    */
                SELECT ( 'P' );
                  THIS_INDEX = %P_INDEX;
 
                  IF WEVE_SEEN_A_PERIOD
                  THEN
                    THIS_INDEX = THIS_INDEX + 2;
 
                  IF PRECEDENCE_TABLE ( ( THIS_INDEX * %MAXIMUM_CHARACTER_INDEX ) + LAST_CHARACTER_INDEX ) = ' '
                  THEN
                    GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
                  CALL REPEAT_THE_PICTURE_CHARACTER
                    ( LAST_CHARACTER,
                    LAST_CHARACTER_LENGTH,
                    LAST_CHARACTER_COUNT )
                    ALTRET ( STRING_TO_CLAUSE_NO_DICE );
 
                  LAST_CHARACTER = 'P';
                  LAST_CHARACTER_LENGTH = 1;
                  LAST_CHARACTER_COUNT = 1;
 
                SELECT ( ELSE );
                  GOTO UNSTUFF_PICTURE_STRING_NO_DICE;
 
              END;
 
              LAST_CHARACTER_INDEX = THIS_INDEX;
 
            END;
 
          PICTURE_STRING_INDEX = PICTURE_STRING_INDEX + 1;
 
        END UNSTUFF_PICTURE_STRING;
 
      END;
 
    IF CG_OUT$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D'
    THEN
      IF CG_OUT$ -> FIELD_RECORD.PICTURE_STRING_TYPE = 'N'
      THEN
        CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N';
      ELSE
        CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L';
    ELSE
      CG_OUT$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L';
 
    RETURN;
 
UNSTUFF_PICTURE_STRING_NO_DICE:
    %ABANDON_SHIP (
    ERROR = "'The current PICture string is illegal.'"
    );
 
    ALTRETURN;
 
STRING_TO_CLAUSE_NO_DICE:
    %ABANDON_SHIP (
    ERROR = "'The current PICture string cannot be compacted into 30 characters.'"
    );
 
    ALTRETURN;
 
REPEAT_THE_PICTURE_CHARACTER: PROC ( PICTURE_CHARACTER,
      PICTURE_CHARACTER_LENGTH,
      REPEATS_COUNT ) ALTRET;
 
  DCL PICTURE_CHARACTER CHAR( PICTURE_CHARACTER_LENGTH );
  DCL PICTURE_CHARACTER_LENGTH UBIN;
  DCL REPEATS_COUNT UBIN;
 
    IF REPEATS_COUNT > 3
    THEN
      DO;
        IF PICTURE_CLAUSE_POSITION + PICTURE_CHARACTER_LENGTH > LENGTHC ( FIELD_RECORD.PICTURE_CLAUSE )
        THEN
          ALTRETURN;
        SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
          PICTURE_CLAUSE_POSITION,
          PICTURE_CHARACTER_LENGTH ) = PICTURE_CHARACTER;
        PICTURE_CLAUSE_POSITION = PICTURE_CLAUSE_POSITION
          + PICTURE_CHARACTER_LENGTH;
 
        IF PICTURE_CLAUSE_POSITION + 1 > LENGTHC ( FIELD_RECORD.PICTURE_CLAUSE )
        THEN
          ALTRETURN;
        SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
          PICTURE_CLAUSE_POSITION,
          1 ) = '(';
        PICTURE_CLAUSE_POSITION = PICTURE_CLAUSE_POSITION + 1;
 
        CALL BINCHAR ( A_CHAR3_WHATEVER,
          REPEATS_COUNT );
 
        CALL STRIP_LEADING_ZEROES ( A_CHAR3_WHATEVER,
          LEADING_ZERO_COUNT );
 
        IF PICTURE_CLAUSE_POSITION + ( 3 - LEADING_ZERO_COUNT ) > LENGTHC ( FIELD_RECORD.PICTURE_CLAUSE )
        THEN
          ALTRETURN;
        SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
          PICTURE_CLAUSE_POSITION,
          3 - LEADING_ZERO_COUNT ) =
          SUBSTR ( A_CHAR3_WHATEVER,
          LEADING_ZERO_COUNT,
          3 - LEADING_ZERO_COUNT );
        PICTURE_CLAUSE_POSITION = PICTURE_CLAUSE_POSITION
          + ( 3 - LEADING_ZERO_COUNT );
 
        IF PICTURE_CLAUSE_POSITION + 1 > LENGTHC ( FIELD_RECORD.PICTURE_CLAUSE )
        THEN
          ALTRETURN;
        SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
          PICTURE_CLAUSE_POSITION,
          1 ) = ')';
        PICTURE_CLAUSE_POSITION = PICTURE_CLAUSE_POSITION + 1;
 
      END;
    ELSE
      DO;
 
        DO PICTURE_CLAUSE_INDEX = 0 TO REPEATS_COUNT - 1;
 
          IF PICTURE_CLAUSE_POSITION + PICTURE_CHARACTER_LENGTH > LENGTHC ( FIELD_RECORD.PICTURE_CLAUSE )
          THEN
            ALTRETURN;
          SUBSTR ( CG_OUT$ -> FIELD_RECORD.PICTURE_CLAUSE,
            PICTURE_CLAUSE_POSITION,
            PICTURE_CHARACTER_LENGTH ) = PICTURE_CHARACTER;
 
          PICTURE_CLAUSE_POSITION = PICTURE_CLAUSE_POSITION
            + PICTURE_CHARACTER_LENGTH;
 
        END;
 
      END;
 
    RETURN;
 
END REPEAT_THE_PICTURE_CHARACTER;
 
END PICTURE_STRING_TO_CLAUSE;
 
END PUT_FIELD_DETAILS;
%EJECT;
DELETE_FIELD: PROC ALTRET;
 
  DCL OLD_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL OLD_SEQUENCE#_UPPER_BOUND CHAR(10);
 
    CG_OUT$ -> FIELD_RECORD = CG_IN$ -> FIELD_RECORD;
 
    IF CG_OUT$ -> FIELD_RECORD.SEQUENCE# ~= ' '
    THEN
      DO;
 
        CALL ESTABLISH_DESTRUCTION_BOUNDS
          ( CG_OUT$ -> FIELD_RECORD.SEQUENCE# )
        WHENALTRETURN
        DO;
          ALTRETURN;
        END;
 
        DELETE_MUSH_SOURCE.KEY_ = VECTOR ( OLD_SEQUENCE#_LOWER_BOUND );
        DELETE_MUSH_SOURCE.LKEY_ = VECTOR ( OLD_SEQUENCE#_UPPER_BOUND );
        DELETE_MUSH_SOURCE.V.INDX# = 1;
 
        CALL M$DELREC ( DELETE_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( DELETE_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
      END;
 
    CG_OUT$ -> FIELD_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
    CALL M$WRITE ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
%EJECT;
/*
    A previously-existing record has been deleted.
    Make sure we trash any group items above it which contain
    only it.
    OLD_SEQUENCE#_LOWER_BOUND and OLD_SEQUENCE#_UPPER_BOUND frame
    the group to be deleted.
    This is a semi-clone of a PROC of the same name in
    PUT_FIELD_DETAILS.  If one's busted, the other prob'ly is, too.
*/
ESTABLISH_DESTRUCTION_BOUNDS: PROC ( SEQUENCE# ) ALTRET;
 
  DCL GROUPIEST_GROUP_SEQUENCE# CHAR(10);
  DCL GROUPIEST_SEQUENCE# CHAR(10);
  DCL GROUP_CASUALTY_COUNT UBIN;
  DCL LEVEL_CASUALTY_COUNT UBIN;
  DCL LOWEST_CASUALTY_LEVEL# CHAR(2);
  DCL SEQUENCE# CHAR(10);
 
    OLD_SEQUENCE#_LOWER_BOUND = SEQUENCE#;
    OLD_SEQUENCE#_UPPER_BOUND = SEQUENCE#;
 
    GROUP_CASUALTY_COUNT = 0;
    LEVEL_CASUALTY_COUNT = 0;
 
    READ_MUSH_SOURCE.KEY_ = VECTOR ( SEQUENCE# );
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
 
SEARCH_OUTWARD_TO_SAFETY:
    DO WHILE ( '1'B );
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      GROUPIEST_SEQUENCE# = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
      GROUPIEST_GROUP_SEQUENCE# = MUSH_IN$ -> FIELD_RECORD.GROUP_SEQUENCE#;
      LEVEL_CASUALTY_COUNT = LEVEL_CASUALTY_COUNT + 1;
      LOWEST_CASUALTY_LEVEL# = MUSH_IN$ -> FIELD_RECORD.LEVEL#;
      GROUP_CASUALTY_COUNT = 0;
      READ_MUSH_SOURCE.V.KEYS# = %NO;
 
SEARCH_FOR_OTHER_CASUALTIES:
      DO UNTIL ( MUSH_IN$ -> FIELD_RECORD.LEVEL# <=
        LOWEST_CASUALTY_LEVEL# );
 
        GROUP_CASUALTY_COUNT = GROUP_CASUALTY_COUNT + 1;
 
        CALL M$READ ( READ_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
          THEN
            DO;
              EXIT SEARCH_FOR_OTHER_CASUALTIES;
            END;
          ELSE
            DO;
              CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
              EXIT SEARCH_FOR_OTHER_CASUALTIES;
            END;
        END;
 
      END SEARCH_FOR_OTHER_CASUALTIES;
 
      IF LEVEL_CASUALTY_COUNT = GROUP_CASUALTY_COUNT
      THEN
        IF MUSH_OUT$ -> FIELD_RECORD.LEVEL# = '01'
        THEN
          DO;
            IF MUSH_OUT$ -> FIELD_RECORD.PICTURE_STRING ~= ' '
            THEN
              OLD_SEQUENCE#_LOWER_BOUND = GROUPIEST_SEQUENCE#;
            RETURN;
          END;
        ELSE
          OLD_SEQUENCE#_LOWER_BOUND = GROUPIEST_SEQUENCE#;
      ELSE
        RETURN;
 
      READ_MUSH_SOURCE.KEY_ = VECTOR ( GROUPIEST_GROUP_SEQUENCE# );
      READ_MUSH_SOURCE.V.KEYS# = %YES;
 
    END SEARCH_OUTWARD_TO_SAFETY;
 
END ESTABLISH_DESTRUCTION_BOUNDS;
 
END DELETE_FIELD;
%EJECT;
MUSH_TO_FPL: PROC ALTRET;
 
  DCL CLAUSE_BUFFER CHAR(532);
  DCL CLAUSE_BUFFER_POSITION UBIN;
  DCL OPTION_POSITION UBIN;
  DCL LEFTMOST_OPTION_POSITION UBIN;
  DCL SUBCLAUSE_LENGTH UBIN;
  DCL 1 INDENTATION_POSITIONS(0:%MAXIMUM_INDENTATIONS),
        2 LEVEL# CHAR(2);
  DCL INDENTATION_POSITION UBIN;
  DCL UGLY_NO_CLAUSES_FLAG BIT(1) ALIGNED;
 
    CALL OPEN_THE_FPL_SOURCE_OUT
      ALTRET ( MUSH_TO_FPL_NO_DICE );
 
    PFIL_MUSH_SOURCE.V.BOF# = %YES;
    PFIL_MUSH_SOURCE.V.INDX# = 1;
 
    CALL M$PFIL ( PFIL_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( PFIL_MUSH_SOURCE.V.DCB# );
      GOTO MUSH_TO_FPL_NO_DICE;
    END;
 
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %NO;
 
    DO A_UBIN_WHATEVER = 0 TO %MAXIMUM_INDENTATIONS;
      INDENTATION_POSITIONS.LEVEL# ( A_UBIN_WHATEVER ) = '99';
    END;
 
UNMUSH_ALL_THE_FIELDS:
    DO WHILE ( '1'B );
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
        THEN
          EXIT UNMUSH_ALL_THE_FIELDS;
        ELSE
          DO;
            CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
            GOTO MUSH_TO_FPL_NO_DICE;
          END;
      END;
 
      FPL_BUFFER_STRING = ' ';
      UGLY_NO_CLAUSES_FLAG = %YES;
 
      IF MUSH_IN$ -> FIELD_RECORD.LEVEL# = '00'
      THEN
        DO;
 
          CALL M$WRITE ( WRITE_FPL_SOURCE )
          WHENALTRETURN
          DO;
            CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
            GOTO MUSH_TO_FPL_NO_DICE;
          END;
 
          INDENTATION_POSITION = 7;
          LEFTMOST_OPTION_POSITION = INDENTATION_POSITION;
 
          SUBSTR ( FPL_BUFFER_STRING,
            LEFTMOST_OPTION_POSITION,
            2 ) = 'FR';
          LEFTMOST_OPTION_POSITION = LEFTMOST_OPTION_POSITION
            + 4;
 
          CALL INDEX ( SUBCLAUSE_LENGTH,
            ' ',
            MUSH_IN$ -> FIELD_RECORD.FRAME_NAME );
          SUBSTR ( FPL_BUFFER_STRING,
            LEFTMOST_OPTION_POSITION,
            SUBCLAUSE_LENGTH ) = MUSH_IN$ -> FIELD_RECORD.FRAME_NAME;
          LEFTMOST_OPTION_POSITION = LEFTMOST_OPTION_POSITION
            + SUBCLAUSE_LENGTH
            + 2;
 
          OPTION_POSITION = LEFTMOST_OPTION_POSITION;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_ORIGIN_VALID = 'Y'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.ORIGIN.TEXT,
                CLAUSES.ORIGIN.LENGTH,
                0 );
              CALL STUFF_SUBCLAUSE ( CLAUSES.LINE.TEXT,
                CLAUSES.LINE.LENGTH,
                0 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.ORIGIN_X,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.ORIGIN_X,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( CLAUSES.COLUMN.TEXT,
                CLAUSES.COLUMN.LENGTH,
                0 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.ORIGIN_Y,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.ORIGIN_Y,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
        END;
      ELSE
        DO;
 
          CALL GET_INDENTATION_POSITION;
          LEFTMOST_OPTION_POSITION = INDENTATION_POSITION;
 
          SUBSTR ( FPL_BUFFER_STRING,
            LEFTMOST_OPTION_POSITION,
            2 ) = MUSH_IN$ -> FIELD_RECORD.LEVEL#;
          LEFTMOST_OPTION_POSITION = LEFTMOST_OPTION_POSITION
            + 4;
 
          CALL INDEX ( SUBCLAUSE_LENGTH,
            ' ',
            MUSH_IN$ -> FIELD_RECORD.NAME );
          SUBSTR ( FPL_BUFFER_STRING,
            LEFTMOST_OPTION_POSITION,
            SUBCLAUSE_LENGTH ) = MUSH_IN$ -> FIELD_RECORD.NAME;
          LEFTMOST_OPTION_POSITION = LEFTMOST_OPTION_POSITION
            + SUBCLAUSE_LENGTH
            + 2;
 
          OPTION_POSITION = LEFTMOST_OPTION_POSITION;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_IO_INHERITED = ' '
          THEN
            DO;
              IF MUSH_IN$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT = 'Y'
                AND MUSH_IN$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT = 'Y'
              THEN
                CALL STUFF_CLAUSE ( CLAUSES.IO.TEXT, CLAUSES.IO.LENGTH );
              ELSE
                IF MUSH_IN$ -> FIELD_RECORD.IO_FLAGS.IS_INPUT = 'Y'
                THEN
                  CALL STUFF_CLAUSE ( CLAUSES.INPUT.TEXT, CLAUSES.INPUT.LENGTH );
                ELSE
                  IF MUSH_IN$ -> FIELD_RECORD.IO_FLAGS.IS_OUTPUT = 'Y'
                  THEN
                    CALL STUFF_CLAUSE ( CLAUSES.OUTPUT.TEXT, CLAUSES.OUTPUT.LENGTH );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_ENTRY_REQUIRED_INHERITED = ' '
            AND MUSH_IN$ -> FIELD_RECORD.IS_ENTRY_REQUIRED = 'Y'
          THEN
            CALL STUFF_CLAUSE ( CLAUSES.ENTRY_REQUIRED.TEXT, CLAUSES.ENTRY_REQUIRED.LENGTH );
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_VISUAL_ATTRIBUTE_INHERITED = ' '
            AND MUSH_IN$ -> FIELD_RECORD.VISUAL_ATTRIBUTE ~= ' '
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.VISUAL_ATTRIBUTE.TEXT,
                CLAUSES.VISUAL_ATTRIBUTE.LENGTH,
                0 );
              CALL INDEX ( SUBCLAUSE_LENGTH,
                ' ',
                MUSH_IN$ -> FIELD_RECORD.VISUAL_ATTRIBUTE );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.VISUAL_ATTRIBUTE,
                SUBCLAUSE_LENGTH,
                0 );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_REPEATS_X_INHERITED = ' '
            AND MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= ' '
            AND MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= '000'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.REPEATS.TEXT,
                CLAUSES.REPEATS.LENGTH,
                0 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.REPEATS_X,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.REPEATS_X,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( CLAUSES.TIMES.TEXT,
                CLAUSES.TIMES.LENGTH,
                0 );
              IF MUSH_IN$ -> FIELD_RECORD.SEPARATED_X ~= ' '
                AND MUSH_IN$ -> FIELD_RECORD.SEPARATED_X ~= '000'
                AND MUSH_IN$ -> FIELD_RECORD.SEPARATED_X ~= '001'
              THEN
                DO;
                  CALL STUFF_SUBCLAUSE ( CLAUSES.SEPARATED.TEXT,
                    CLAUSES.SEPARATED.LENGTH,
                    0 );
                  CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_X,
                    LEADING_ZERO_COUNT );
                  CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_X,
                    3,
                    LEADING_ZERO_COUNT );
                END;
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_REPEATS_Y_INHERITED = ' '
            AND MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= ' '
            AND MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= '000'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.REPEATS.TEXT,
                CLAUSES.REPEATS.LENGTH,
                0 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.REPEATS_Y,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.REPEATS_Y,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( CLAUSES.TIMES.TEXT,
                CLAUSES.TIMES.LENGTH,
                0 );
              IF MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y ~= ' '
                AND MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y ~= '000'
                AND MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y ~= '001'
              THEN
                DO;
                  CALL STUFF_SUBCLAUSE ( CLAUSES.SEPARATED.TEXT,
                    CLAUSES.SEPARATED.LENGTH,
                    0 );
                  CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y,
                    LEADING_ZERO_COUNT );
                  CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y,
                    3,
                    LEADING_ZERO_COUNT );
                END;
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.POSITION_X ~= ' '
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.POSITION.TEXT,
                CLAUSES.POSITION.LENGTH,
                0 );
              CALL STUFF_SUBCLAUSE ( CLAUSES.LINE.TEXT,
                CLAUSES.LINE.LENGTH,
                0 );
              CALL CHARBIN ( A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.POSITION_Y );
              CALL CHARBIN ( A_UBIN_WHATEVER2,
                MUSH_IN$ -> FIELD_RECORD.ORIGIN_Y );
              CALL BINCHAR ( MUSH_IN$ -> FIELD_RECORD.POSITION_Y,
                A_UBIN_WHATEVER - A_UBIN_WHATEVER2 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.POSITION_Y,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.POSITION_Y,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( CLAUSES.COLUMN.TEXT,
                CLAUSES.COLUMN.LENGTH,
                0 );
              CALL CHARBIN ( A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.POSITION_X );
              CALL CHARBIN ( A_UBIN_WHATEVER2,
                MUSH_IN$ -> FIELD_RECORD.ORIGIN_X );
              CALL BINCHAR ( MUSH_IN$ -> FIELD_RECORD.POSITION_X,
                A_UBIN_WHATEVER - A_UBIN_WHATEVER2 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.POSITION_X,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.POSITION_X,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.PICTURE_CLAUSE ~= ' '
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.PICTURE.TEXT,
                CLAUSES.PICTURE.LENGTH,
                0 );
              CALL INDEX ( SUBCLAUSE_LENGTH,
                ' ',
                MUSH_IN$ -> FIELD_RECORD.PICTURE_CLAUSE );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.PICTURE_CLAUSE,
                SUBCLAUSE_LENGTH,
                0 );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.SIGN ~= ' '
          THEN
            DO;
              DO SELECT ( MUSH_IN$ -> FIELD_RECORD.SIGN );
 
                SELECT ( 'LS' );
                  CALL STUFF_CLAUSE ( CLAUSES.SIGN_LEADING_SEPARATE.TEXT,
                    CLAUSES.SIGN_LEADING_SEPARATE.LENGTH );
 
                SELECT ( 'TO' );
                  CALL STUFF_CLAUSE ( CLAUSES.SIGN_TRAILING.TEXT,
                    CLAUSES.SIGN_TRAILING.LENGTH );
 
                SELECT ( 'TS' );
                  CALL STUFF_CLAUSE ( CLAUSES.SIGN_TRAILING_SEPARATE.TEXT,
                    CLAUSES.SIGN_TRAILING_SEPARATE.LENGTH );
 
              END;
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_BWZ = 'Y'
          THEN
            DO;
              CALL STUFF_CLAUSE ( CLAUSES.BWZ.TEXT,
                CLAUSES.BWZ.LENGTH );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.CLASS ~= ' '
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.CLASS.TEXT,
                CLAUSES.CLASS.LENGTH,
                0 );
              CALL INDEX ( SUBCLAUSE_LENGTH,
                ' ',
                MUSH_IN$ -> FIELD_RECORD.CLASS );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.CLASS,
                SUBCLAUSE_LENGTH,
                0 );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.MINIMUM_SIZE ~= ' '
            AND MUSH_IN$ -> FIELD_RECORD.MINIMUM_SIZE ~= '000'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.MINIMUM_SIZE.TEXT,
                CLAUSES.MINIMUM_SIZE.LENGTH,
                0 );
              CALL STRIP_LEADING_ZEROES ( MUSH_IN$ -> FIELD_RECORD.MINIMUM_SIZE,
                LEADING_ZERO_COUNT );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.MINIMUM_SIZE,
                3,
                LEADING_ZERO_COUNT );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.FILL_CHARACTER ~= ' '
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.FILL_CHARACTER.TEXT,
                CLAUSES.FILL_CHARACTER.LENGTH,
                0 );
              CALL STUFF_SUBCLAUSE ( MUSH_IN$ -> FIELD_RECORD.FILL_CHARACTER,
                1,
                0 );
              CALL STUFF_SUBCLAUSE ( CLAUSES.END_QUOTE.TEXT,
                CLAUSES.END_QUOTE.LENGTH,
                0 );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_JUSTIFIED_RIGHT = 'Y'
          THEN
            DO;
              CALL STUFF_CLAUSE ( CLAUSES.JUSTIFIED_RIGHT.TEXT,
                CLAUSES.JUSTIFIED_RIGHT.LENGTH );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'C'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.CONSTANT_VALUE.TEXT,
                CLAUSES.CONSTANT_VALUE.LENGTH,
                0 );
 
              CALL CHARBIN ( A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.PICTURE_STRING_LENGTH );
 
              UNDERSCORE_INDEX = 0;
REPLACE__S_WITH_BLANKS:
              DO WHILE ( '1'B );
                CALL INDEX ( UNDERSCORE_INDEX,
                  '_',
                  MUSH_IN$ -> FIELD_RECORD.CONSTANT_VALUE );
 
                IF UNDERSCORE_INDEX > A_UBIN_WHATEVER - 1
                THEN
                  EXIT REPLACE__S_WITH_BLANKS;
 
                SUBSTR ( MUSH_IN$ -> FIELD_RECORD.CONSTANT_VALUE,
                  UNDERSCORE_INDEX,
                  1 ) = ' ';
              END REPLACE__S_WITH_BLANKS;
 
              CALL STUFF_LITERAL ( MUSH_IN$ -> FIELD_RECORD.CONSTANT_VALUE,
                A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_CONSTANT_DEFAULT = 'D'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.DEFAULT_VALUE.TEXT,
                CLAUSES.DEFAULT_VALUE.LENGTH,
                0 );
 
              CALL CHARBIN ( A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.CONSTANT_DEFAULT_LENGTH );
 
              UNDERSCORE_INDEX = 0;
REPLACE_DEFAULT__S_WITH_BLANKS:
              DO WHILE ( '1'B );
                CALL INDEX ( UNDERSCORE_INDEX,
                  '_',
                  MUSH_IN$ -> FIELD_RECORD.DEFAULT_VALUE );
 
                IF UNDERSCORE_INDEX >= A_UBIN_WHATEVER
                THEN
                  EXIT REPLACE_DEFAULT__S_WITH_BLANKS;
 
                SUBSTR ( MUSH_IN$ -> FIELD_RECORD.DEFAULT_VALUE,
                  UNDERSCORE_INDEX,
                  1 ) = ' ';
              END REPLACE_DEFAULT__S_WITH_BLANKS;
 
              BLANK_INDEX = 0;
 
              IF MUSH_IN$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'N'
              THEN
                DO;
 
STRIP_DEFAULT_LEADING_BLANKS:
                  DO WHILE ( SUBSTR ( MUSH_IN$ -> FIELD_RECORD.DEFAULT_VALUE,
                    BLANK_INDEX,
                    1 ) = ' ' );
 
                    BLANK_INDEX = BLANK_INDEX + 1;
                    IF BLANK_INDEX >= A_UBIN_WHATEVER
                    THEN
                      DO;
                        BLANK_INDEX = 0;
                        A_UBIN_WHATEVER = 1;
                        EXIT STRIP_DEFAULT_LEADING_BLANKS;
                      END;
 
                  END STRIP_DEFAULT_LEADING_BLANKS;
 
                END;
 
              CALL STUFF_LITERAL ( SUBSTR ( MUSH_IN$ -> FIELD_RECORD.DEFAULT_VALUE,
                BLANK_INDEX,
                A_UBIN_WHATEVER - BLANK_INDEX ),
                A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_PROMPT = 'Y'
          THEN
            DO;
              CLAUSE_BUFFER = ' ';
              CLAUSE_BUFFER_POSITION = 0;
              CALL STUFF_SUBCLAUSE ( CLAUSES.PROMPT.TEXT,
                CLAUSES.PROMPT.LENGTH,
                0 );
 
              CALL CHARBIN ( A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.PROMPT_LENGTH );
 
              UNDERSCORE_INDEX = 0;
REPLACE_PROMPT__S_WITH_BLANKS:
              DO WHILE ( '1'B );
                CALL INDEX ( UNDERSCORE_INDEX,
                  '_',
                  MUSH_IN$ -> FIELD_RECORD.PROMPT );
 
                IF UNDERSCORE_INDEX >= A_UBIN_WHATEVER
                THEN
                  EXIT REPLACE_PROMPT__S_WITH_BLANKS;
 
                SUBSTR ( MUSH_IN$ -> FIELD_RECORD.PROMPT,
                  UNDERSCORE_INDEX,
                  1 ) = ' ';
              END REPLACE_PROMPT__S_WITH_BLANKS;
 
              CALL STUFF_LITERAL ( MUSH_IN$ -> FIELD_RECORD.PROMPT,
                A_UBIN_WHATEVER,
                MUSH_IN$ -> FIELD_RECORD.PROMPT_TYPE );
              CALL STUFF_CLAUSE ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION );
            END;
 
          IF MUSH_IN$ -> FIELD_RECORD.IS_A_O_I_M_INHERITED = ' '
            AND MUSH_IN$ -> FIELD_RECORD.IS_A_O_I_M = 'Y'
          THEN
            CALL STUFF_CLAUSE ( CLAUSES.A_O_I_M.TEXT, CLAUSES.A_O_I_M.LENGTH );
 
        END;
 
      IF OPTION_POSITION ~= LEFTMOST_OPTION_POSITION
        OR UGLY_NO_CLAUSES_FLAG
      THEN
        OPTION_POSITION = OPTION_POSITION
          - 2;
 
      SUBSTR ( FPL_BUFFER_STRING, OPTION_POSITION, 1 ) = '.';
 
      CALL M$WRITE ( WRITE_FPL_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
        GOTO MUSH_TO_FPL_NO_DICE;
      END;
 
    END UNMUSH_ALL_THE_FIELDS;
 
    CG_OUT$ -> FID_RECORD.ERROR_CODE = %ERROR_EVERYTHINGS_PEACHY;
    CALL M$WRITE ( WRITE_CG )
    WHENALTRETURN
    DO;
    END;
 
    CALL CLOSE_THE_FPL_SOURCE;
    CALL FLUSH_THE_MUSH_SOURCE;
 
    STATION.MAX_FRAME_INDEX = -1;
 
    RETURN;
 
MUSH_TO_FPL_NO_DICE:
    CLOSE_FPL_SOURCE.V.DISP# = %RELEASE#;
    CALL CLOSE_THE_FPL_SOURCE;
    CLOSE_FPL_SOURCE.V.DISP# = %SAVE#;
 
    PFIL_MUSH_SOURCE.V.BOF# = %YES;
    CALL M$PFIL ( PFIL_MUSH_SOURCE )
    WHENALTRETURN
    DO;
    END;
 
    SUBSTR ( MUSH_SOURCE_NAME_ERROR.NAME#, 10 ) =
      STATION.MESSAGE_TYPE;
    CALL M$OPEN ( OPEN_MUSH_SOURCE_ERROR )
    WHENALTRETURN
    DO;
    END;
 
MOVE_MUSH_SOURCE_TO_FLI_ERROR:
    DO WHILE ( '1'B );
      CALL M$READ ( READ_MUSH_SOURCE )
        ALTRET ( MOVED_MUSH_SOURCE_TO_FLI_ERROR );
 
      MUSH_OUT$ -> FIELD_RECORD = MUSH_IN$ -> FIELD_RECORD;
 
      CALL M$WRITE ( WRITE_MUSH_SOURCE_ERROR )
      WHENALTRETURN
      DO;
      END;
    END MOVE_MUSH_SOURCE_TO_FLI_ERROR;
 
MOVED_MUSH_SOURCE_TO_FLI_ERROR:
    CALL M$CLOSE ( CLOSE_MUSH_SOURCE_ERROR )
    WHENALTRETURN
    DO;
    END;
 
    CALL FLUSH_THE_MUSH_SOURCE;
 
    STATION.MAX_FRAME_INDEX = -1;
 
    ALTRETURN;
 
%EJECT;
GET_INDENTATION_POSITION: PROC;
 
  DCL INDENTATION_INDEX UBIN;
  DCL THE_REST_INDEX UBIN;
 
    DO INDENTATION_INDEX = 0 TO %MAXIMUM_INDENTATIONS;
 
      IF MUSH_IN$ -> FIELD_RECORD.LEVEL# <=
        INDENTATION_POSITIONS.LEVEL# ( INDENTATION_INDEX )
      THEN
        DO;
          INDENTATION_POSITIONS.LEVEL# ( INDENTATION_INDEX ) =
            MUSH_IN$ -> FIELD_RECORD.LEVEL#;
          INDENTATION_POSITION = ( INDENTATION_INDEX * 4 )
            + 7;
 
          DO THE_REST_INDEX = INDENTATION_INDEX + 1 TO %MAXIMUM_INDENTATIONS;
            INDENTATION_POSITIONS.LEVEL# ( THE_REST_INDEX ) = '99';
          END;
 
          RETURN;
        END;
 
    END;
 
    INDENTATION_POSITION = ( %MAXIMUM_INDENTATIONS * 4 ) + 7;
 
    RETURN;
 
END GET_INDENTATION_POSITION;
 
STUFF_SUBCLAUSE: PROC ( SUBCLAUSE_STRING,
      SUBCLAUSE_STRING_LENGTH,
      SUBCLAUSE_STRING_INDEX );
 
  DCL SUBCLAUSE_STRING CHAR(SUBCLAUSE_STRING_LENGTH);
  DCL SUBCLAUSE_STRING_LENGTH UBIN;
  DCL SUBCLAUSE_STRING_INDEX UBIN;
 
    SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION ) =
      SUBSTR ( SUBCLAUSE_STRING, SUBCLAUSE_STRING_INDEX );
 
    CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION
      + SUBCLAUSE_STRING_LENGTH
      - SUBCLAUSE_STRING_INDEX;
 
    RETURN;
 
END STUFF_SUBCLAUSE;
 
STUFF_CLAUSE: PROC ( CLAUSE_STRING,
      CLAUSE_STRING_LENGTH );
 
  DCL CLAUSE_STRING CHAR(CLAUSE_STRING_LENGTH);
  DCL CLAUSE_STRING_LENGTH UBIN;
  DCL CLAUSE_SUBSTRING_LENGTH UBIN;
  DCL CLAUSE_STRING_POSITION UBIN;
 
    UGLY_NO_CLAUSES_FLAG = %NO;
    CLAUSE_STRING_POSITION = 0;
 
    IF OPTION_POSITION + CLAUSE_STRING_LENGTH > 72
    THEN
      DO;
        IF OPTION_POSITION ~= LEFTMOST_OPTION_POSITION
        THEN
          DO;
 
            CALL M$WRITE ( WRITE_FPL_SOURCE )
            WHENALTRETURN
            DO;
              CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
            END;
 
            FPL_BUFFER_STRING = ' ';
            OPTION_POSITION = LEFTMOST_OPTION_POSITION;
 
          END;
 
        DO WHILE ( ( OPTION_POSITION + CLAUSE_STRING_LENGTH )
          - CLAUSE_STRING_POSITION
          > 72 );
 
          IF SUBSTR ( CLAUSE_STRING, 0, 9 ) = 'CONSTANT '
            OR SUBSTR ( CLAUSE_STRING, 0, 8 ) = 'DEFAULT '
            OR SUBSTR ( CLAUSE_STRING, 0, 7 ) = 'PROMPT '
          THEN
            DO;
 
              SUBSTR ( FPL_BUFFER_STRING,
                OPTION_POSITION,
                72 - OPTION_POSITION ) =
                SUBSTR ( CLAUSE_STRING, CLAUSE_STRING_POSITION );
 
              CLAUSE_STRING_POSITION = CLAUSE_STRING_POSITION
                + ( 72 - OPTION_POSITION );
 
              CALL M$WRITE ( WRITE_FPL_SOURCE )
              WHENALTRETURN
              DO;
                CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
              END;
 
              FPL_BUFFER_STRING = ' ';
              FPL_BUFFER.CONTINUATION_COLUMN = '-';
              OPTION_POSITION = LEFTMOST_OPTION_POSITION;
              IF ( SUBSTR ( CLAUSE_STRING, 0, 7 ) = 'PROMPT '
                AND MUSH_IN$ -> FIELD_RECORD.PROMPT_TYPE = 'L' )
                OR ( SUBSTR ( CLAUSE_STRING, 0, 7 ) ~= 'PROMPT '
                AND MUSH_IN$ -> FIELD_RECORD.CONSTANT_DEFAULT_TYPE = 'L' )
              THEN
                DO;
                  SUBSTR ( FPL_BUFFER_STRING, OPTION_POSITION, 1 ) = '"';
                  OPTION_POSITION = OPTION_POSITION + 1;
                END;
 
            END;
          ELSE
            DO;
 
              CLAUSE_SUBSTRING_LENGTH = CLAUSE_STRING_LENGTH;
 
CHOP_OFF_CLAUSE_FROM_THE_RIGHT:
              DO WHILE ( ( OPTION_POSITION + CLAUSE_SUBSTRING_LENGTH )
                - CLAUSE_STRING_POSITION
                > 72 );
 
                CALL INDEX1R ( BLANK_INDEX,
                  ' ',
                  SUBSTR ( CLAUSE_STRING,
                  CLAUSE_STRING_POSITION,
                  CLAUSE_SUBSTRING_LENGTH - CLAUSE_STRING_POSITION ) );
 
                IF BLANK_INDEX = CLAUSE_SUBSTRING_LENGTH - CLAUSE_STRING_POSITION
                THEN
                  EXIT CHOP_OFF_CLAUSE_FROM_THE_RIGHT;
 
                CLAUSE_SUBSTRING_LENGTH = CLAUSE_STRING_POSITION
                  + BLANK_INDEX;
 
              END CHOP_OFF_CLAUSE_FROM_THE_RIGHT;
 
              IF CLAUSE_SUBSTRING_LENGTH = CLAUSE_STRING_LENGTH
              THEN
                DO;
 
                  SUBSTR ( FPL_BUFFER_STRING,
                    OPTION_POSITION,
                    72 - OPTION_POSITION ) =
                    SUBSTR ( CLAUSE_STRING, CLAUSE_STRING_POSITION );
 
                  CLAUSE_STRING_POSITION = CLAUSE_STRING_POSITION
                    + ( 72 - OPTION_POSITION );
 
                  CALL M$WRITE ( WRITE_FPL_SOURCE )
                  WHENALTRETURN
                  DO;
                    CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
                  END;
 
                  FPL_BUFFER_STRING = ' ';
                  FPL_BUFFER.CONTINUATION_COLUMN = '-';
                  OPTION_POSITION = LEFTMOST_OPTION_POSITION;
 
                END;
              ELSE
                DO;
 
                  SUBSTR ( FPL_BUFFER_STRING,
                    OPTION_POSITION,
                    CLAUSE_SUBSTRING_LENGTH - CLAUSE_STRING_POSITION ) =
                    SUBSTR ( CLAUSE_STRING,
                    CLAUSE_STRING_POSITION,
                    CLAUSE_SUBSTRING_LENGTH - CLAUSE_STRING_POSITION );
 
                  CLAUSE_STRING_POSITION = CLAUSE_STRING_POSITION
                    + ( CLAUSE_SUBSTRING_LENGTH - CLAUSE_STRING_POSITION )
                    + 1;
 
                  CALL M$WRITE ( WRITE_FPL_SOURCE )
                  WHENALTRETURN
                  DO;
                    CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
                  END;
 
                  FPL_BUFFER_STRING = ' ';
                  OPTION_POSITION = LEFTMOST_OPTION_POSITION;
 
                END;
 
            END;
 
        END;
 
      END;
 
    SUBSTR ( FPL_BUFFER_STRING, OPTION_POSITION ) =
      SUBSTR ( CLAUSE_STRING, CLAUSE_STRING_POSITION );
 
    OPTION_POSITION = OPTION_POSITION
      + CLAUSE_STRING_LENGTH
      - CLAUSE_STRING_POSITION;
 
    IF OPTION_POSITION + 1 > 72
    THEN
      DO;
        CALL M$WRITE ( WRITE_FPL_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( WRITE_FPL_SOURCE.V.DCB# );
        END;
        FPL_BUFFER_STRING = ' ';
        OPTION_POSITION = LEFTMOST_OPTION_POSITION;
      END;
    ELSE
      DO;
        SUBSTR ( FPL_BUFFER_STRING, OPTION_POSITION, 1 ) = ';';
        OPTION_POSITION = OPTION_POSITION
          + 2;
      END;
 
    RETURN;
 
END STUFF_CLAUSE;
 
STUFF_LITERAL: PROC ( LITERAL_STRING,
      LITERAL_LENGTH,
      LITERAL_TYPE );
 
  DCL LITERAL_STRING CHAR(LITERAL_LENGTH);
  DCL LITERAL_LENGTH UBIN;
  DCL LITERAL_TYPE CHAR(1);
  DCL LITERAL_POSITION UBIN;
  DCL QUOTE_POSITION UBIN;
 
    CALL CHECK_FOR_ALL_LITERAL
    WHENRETURN
    DO;
      RETURN;
    END;
 
STRIP_TRAILING_BLANKS:
    DO WHILE ( SUBSTR ( LITERAL_STRING,
      LITERAL_LENGTH - 1,
      1 ) = ' ' );
 
      LITERAL_LENGTH = LITERAL_LENGTH - 1;
 
    END STRIP_TRAILING_BLANKS;
 
    LITERAL_POSITION = 0;
 
    IF LITERAL_TYPE = 'L'
    THEN
      DO;
        SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 1 ) = '"';
        CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 1;
      END;
 
    /*
        If we let a " slip by in a numeric DEFAULT VALUE,
        or a DATANAME-type PROMPT,
        boy are we up a creek.
    */
    DO UNTIL ( LITERAL_POSITION >= LITERAL_LENGTH );
 
      IF LITERAL_POSITION > 0
      THEN
        DO;
          SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 2 ) = '""';
          CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 2;
        END;
 
      CALL INDEX ( QUOTE_POSITION,
        '"',
        SUBSTR ( LITERAL_STRING, LITERAL_POSITION ) );
 
      SUBSTR ( CLAUSE_BUFFER,
        CLAUSE_BUFFER_POSITION,
        QUOTE_POSITION ) = SUBSTR ( LITERAL_STRING,
        LITERAL_POSITION,
        QUOTE_POSITION );
 
      CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION
        + QUOTE_POSITION;
 
      LITERAL_POSITION = LITERAL_POSITION
        + QUOTE_POSITION
        + 1;
 
    END;
 
    IF LITERAL_TYPE = 'L'
    THEN
      DO;
        SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 1 ) = '"';
        CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 1;
      END;
 
    RETURN;
 
CHECK_FOR_ALL_LITERAL: PROC ALTRET;
 
    IF LITERAL_LENGTH > 1
    THEN
      DO;
        DO LITERAL_POSITION = 1 TO LITERAL_LENGTH - 1;
 
          IF SUBSTR ( LITERAL_STRING,
            LITERAL_POSITION,
            1 ) ~= SUBSTR ( LITERAL_STRING,
            LITERAL_POSITION - 1,
            1 )
          THEN
            ALTRETURN;
 
        END;
      END;
 
    DO SELECT ( SUBSTR ( LITERAL_STRING, 0, 1 ) );
 
      SELECT ( ' ' );
        IF LITERAL_LENGTH > 1
        THEN
          DO;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 6 ) = 'SPACES';
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 6;
          END;
        ELSE
          DO;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 5 ) = 'SPACE';
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 5;
          END;
 
      SELECT ( '0' );
        IF LITERAL_LENGTH > 1
        THEN
          DO;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 5 ) = 'ZEROS';
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 5;
          END;
        ELSE
          DO;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 4 ) = 'ZERO';
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 4;
          END;
 
      SELECT ( %BITASC ( '7F'X ) );
        SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 11 ) = 'HIGH-VALUES';
        CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 11;
 
      SELECT ( %BITASC ( '00'X ) );
        SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 10 ) = 'LOW-VALUES';
        CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 10;
 
      SELECT ( ELSE );
        IF LITERAL_LENGTH > 1
        THEN
          DO;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 5 ) = 'ALL "';
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 5;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 1 ) =
              SUBSTR ( LITERAL_STRING, 0, 1 );
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 1;
            IF SUBSTR ( LITERAL_STRING, 0, 1 ) = '"'
            THEN
              DO;
                SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 1 ) =
                  SUBSTR ( LITERAL_STRING, 0, 1 );
                CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 1;
              END;
            SUBSTR ( CLAUSE_BUFFER, CLAUSE_BUFFER_POSITION, 1 ) = '"';
            CLAUSE_BUFFER_POSITION = CLAUSE_BUFFER_POSITION + 1;
          END;
        ELSE
          ALTRETURN;
 
    END;
 
    RETURN;
 
END CHECK_FOR_ALL_LITERAL;
 
END STUFF_LITERAL;
 
END MUSH_TO_FPL;
%EJECT;
DEINITIALIZE_STATION: PROC ALTRET;
 
    CALL M$CLOSE ( CLOSE_MUSH_SOURCE_SAVE )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
END DEINITIALIZE_STATION;
%EJECT;
FPABT: PROC ALTRET;
 
    CALL M$CLOSE ( CLOSE_SI );
 
    VLP_ERRCODE = Q$FPABT.MSGS.ERR(0);
    CALL XUG$ERRCNVRT(Q$FPABT.MSGS.ERR(0),VLP_ERRCODE);
    IF Q$FPABT.MSGS.U1.LEN#(0) ~= 0
    THEN
      DO;
        ERRMSG_FROM_FPL.FIELD1_ = VECTOR(Q$FPABT.MSGS.U1(0));
      END;
    IF Q$FPABT.MSGS.U2.LEN#(0) ~= 0
    THEN
      DO;
        ERRMSG_FROM_FPL.FIELD2_ = VECTOR(Q$FPABT.MSGS.U2(0));
      END;
    IF Q$FPABT.MSGS.U3.LEN#(0) ~= 0
    THEN
      DO;
        ERRMSG_FROM_FPL.FIELD3_ = VECTOR(Q$FPABT.MSGS.U3(0));
      END;
    CALL M$ERRMSG ( ERRMSG_FROM_FPL ) ALTRET ( NO_SPEAKEE_FPL );
 
    VLP_ERRCODE = Q$FPABT.MSGS.ERR(1);
    CALL XUG$ERRCNVRT(Q$FPABT.MSGS.ERR(1),VLP_ERRCODE);
    IF Q$FPABT.MSGS.U1.LEN#(1) ~= 0
    THEN
      DO;
        ERRMSG_FROM_FPL.FIELD1_ = VECTOR(Q$FPABT.MSGS.U1(1));
      END;
    IF Q$FPABT.MSGS.U2.LEN#(1) ~= 0
    THEN
      DO;
        ERRMSG_FROM_FPL.FIELD2_ = VECTOR(Q$FPABT.MSGS.U2(1));
      END;
    IF Q$FPABT.MSGS.U3.LEN#(1) ~= 0
    THEN
      DO;
        ERRMSG_FROM_FPL.FIELD3_ = VECTOR(Q$FPABT.MSGS.U3(1));
      END;
    CALL M$ERRMSG ( ERRMSG_FROM_FPL ) ALTRET ( NO_SPEAKEE_FPL );
 
    IF Q$FPABT.MSGCNT# > 2
    THEN
      DO;
        VLP_ERRCODE = Q$FPABT.MSGS.ERR(2);
        CALL XUG$ERRCNVRT(Q$FPABT.MSGS.ERR(2),VLP_ERRCODE);
        IF Q$FPABT.MSGS.U1.LEN#(2) ~= 0
        THEN
          DO;
            ERRMSG_FROM_FPL.FIELD1_ = VECTOR(Q$FPABT.MSGS.U1(2));
          END;
        IF Q$FPABT.MSGS.U2.LEN#(2) ~= 0
        THEN
          DO;
            ERRMSG_FROM_FPL.FIELD2_ = VECTOR(Q$FPABT.MSGS.U2(2));
          END;
        IF Q$FPABT.MSGS.U3.LEN#(2) ~= 0
        THEN
          DO;
            ERRMSG_FROM_FPL.FIELD3_ = VECTOR(Q$FPABT.MSGS.U3(2));
          END;
        CALL M$ERRMSG ( ERRMSG_FROM_FPL ) ALTRET ( NO_SPEAKEE_FPL );
      END;
 
    ALTRETURN;
 
NO_SPEAKEE_FPL:
    SYSTEM_ERROR_MESSAGE = 'FPL abort:  no ERRMSG available!';
    WRITE_LO.BUF_ = VECTOR ( SYSTEM_ERROR_MESSAGE );
    CALL M$WRITE ( WRITE_LO );
    ALTRETURN;
 
END FPABT;
%EJECT;
/*
    Stuff that gets called from anywhere.
*/
ADD_MUSH_RECORDS: PROC ( NEW_SEQUENCE#_LOWER_BOUND,
      NEW_SEQUENCE#_UPPER_BOUND,
      NEW_GROUP_SEQUENCE#,
      NEW_LEVEL# ) ALTRET;
 
  DCL NEW_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_LOWER_BOUND_PARTS REDEF NEW_SEQUENCE#_LOWER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_UPPER_BOUND_PARTS REDEF NEW_SEQUENCE#_UPPER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_GROUP_SEQUENCE# CHAR(10);
  DCL NEW_LEVEL# CHAR(2);
 
    MUSH_IN$ -> FIELD_RECORD = CG_OUT$ -> FIELD_RECORD;
 
    CALL INCLUDE_MUSH_REPEATS_RECORDS
      ( NEW_SEQUENCE#_LOWER_BOUND,
      NEW_SEQUENCE#_UPPER_BOUND,
      NEW_GROUP_SEQUENCE#,
      NEW_LEVEL# )
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    MUSH_IN$ -> FIELD_RECORD.LEVEL# = NEW_LEVEL#;
    MUSH_IN$ -> FIELD_RECORD.GROUP_SEQUENCE# = NEW_GROUP_SEQUENCE#;
 
    MUSH_OUT$ -> FIELD_RECORD = MUSH_IN$ -> FIELD_RECORD;
 
    CALL FIDDLE_WITH_SEQUENCE#S
      ( NEW_SEQUENCE#_LOWER_BOUND,
      NEW_SEQUENCE#_UPPER_BOUND )
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
 
    CALL M$WRITE ( WRITE_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    RETURN;
 
END ADD_MUSH_RECORDS;
 
MOVE_MUSH_RECORDS: PROC ( OLD_SEQUENCE#_LOWER_BOUND,
      OLD_SEQUENCE#_UPPER_BOUND,
      NEW_SEQUENCE#_LOWER_BOUND,
      NEW_SEQUENCE#_UPPER_BOUND,
      NEW_GROUP_SEQUENCE#,
      NEW_LEVEL# ) ALTRET;
 
  DCL OLD_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL OLD_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL NEW_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_LOWER_BOUND_PARTS REDEF NEW_SEQUENCE#_LOWER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_UPPER_BOUND_PARTS REDEF NEW_SEQUENCE#_UPPER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_GROUP_SEQUENCE# CHAR(10);
  DCL NEW_LEVEL# CHAR(2);
  DCL THIS_IS_THE_FIRST_RECORD BIT(1) ALIGNED;
 
    THIS_IS_THE_FIRST_RECORD = %YES;
 
    READ_MUSH_SOURCE.KEY_ = VECTOR ( OLD_SEQUENCE#_LOWER_BOUND );
    READ_MUSH_SOURCE.V.INDX# = 1;
    READ_MUSH_SOURCE.V.KEYS# = %YES;
 
MOVE_THAT_MUSH:
    DO UNTIL ( OLD_SEQUENCE#_LOWER_BOUND = OLD_SEQUENCE#_UPPER_BOUND );
 
      CALL M$READ ( READ_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( READ_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      IF THIS_IS_THE_FIRST_RECORD
      THEN
        DO;
          THIS_IS_THE_FIRST_RECORD = %NO;
 
          CALL INCLUDE_MUSH_REPEATS_RECORDS
            ( NEW_SEQUENCE#_LOWER_BOUND,
            NEW_SEQUENCE#_UPPER_BOUND,
            NEW_GROUP_SEQUENCE#,
            NEW_LEVEL# )
          WHENALTRETURN
          DO;
            ALTRETURN;
          END;
        END;
 
      MUSH_IN$ -> FIELD_RECORD.LEVEL# = NEW_LEVEL#;
      CALL CHARBIN ( A_UBIN_WHATEVER,
        NEW_LEVEL# );
      A_UBIN_WHATEVER = A_UBIN_WHATEVER
        + STATION.LEVEL#_INCREMENT;
      CALL BINCHAR ( NEW_LEVEL#,
        A_UBIN_WHATEVER );
 
      MUSH_IN$ -> FIELD_RECORD.GROUP_SEQUENCE# = NEW_GROUP_SEQUENCE#;
 
      MUSH_OUT$ -> FIELD_RECORD = MUSH_IN$ -> FIELD_RECORD;
 
      CALL FIDDLE_WITH_SEQUENCE#S
        ( NEW_SEQUENCE#_LOWER_BOUND,
        NEW_SEQUENCE#_UPPER_BOUND )
      WHENALTRETURN
      DO;
        ALTRETURN;
      END;
 
 
      CALL M$WRITE ( WRITE_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      DELETE_MUSH_SOURCE.KEY_ = VECTOR ( MUSH_IN$ -> FIELD_RECORD.SEQUENCE# );
      DELETE_MUSH_SOURCE.V.INDX# = 1;
 
      CALL M$DELREC ( DELETE_MUSH_SOURCE )
      WHENALTRETURN
      DO;
        CALL INTERNAL_M$_ERROR ( DELETE_MUSH_SOURCE.V.DCB# );
        ALTRETURN;
      END;
 
      READ_MUSH_SOURCE.V.KEYS# = %NO;
 
      OLD_SEQUENCE#_LOWER_BOUND = MUSH_IN$ -> FIELD_RECORD.SEQUENCE#;
      NEW_SEQUENCE#_LOWER_BOUND = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
 
    END MOVE_THAT_MUSH;
 
    RETURN;
 
END MOVE_MUSH_RECORDS;
 
INCLUDE_MUSH_REPEATS_RECORDS: PROC ( NEW_SEQUENCE#_LOWER_BOUND,
      NEW_SEQUENCE#_UPPER_BOUND,
      NEW_GROUP_SEQUENCE#,
      NEW_LEVEL# ) ALTRET;
 
  DCL NEW_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_LOWER_BOUND_PARTS REDEF NEW_SEQUENCE#_LOWER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_UPPER_BOUND_PARTS REDEF NEW_SEQUENCE#_UPPER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_GROUP_SEQUENCE# CHAR(10);
  DCL NEW_LEVEL# CHAR(2);
 
    IF MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.REPEATS_Y ~= '000'
    THEN
      DO;
        MUSH_OUT_BUFFER = ' ';
 
        MUSH_OUT$ -> FIELD_RECORD.FRAME_NAME =
          MUSH_IN$ -> FIELD_RECORD.FRAME_NAME;
 
        MUSH_OUT$ -> FIELD_RECORD.LEVEL# = NEW_LEVEL#;
        CALL CHARBIN ( A_UBIN_WHATEVER,
          NEW_LEVEL# );
        A_UBIN_WHATEVER = A_UBIN_WHATEVER
          + STATION.LEVEL#_INCREMENT;
        CALL BINCHAR ( NEW_LEVEL#,
          A_UBIN_WHATEVER );
 
        CALL INDEX ( BLANK_INDEX,
          ' ',
          MUSH_IN$ -> FIELD_RECORD.NAME );
        MUSH_OUT$ -> FIELD_RECORD.NAME =
          SUBSTR ( MUSH_IN$ -> FIELD_RECORD.NAME,
          0,
          MINIMUM ( BLANK_INDEX, LENGTHC ( FIELD_RECORD.NAME ) - 5 ) );
        SUBSTR ( MUSH_OUT$ -> FIELD_RECORD.NAME,
          MINIMUM ( BLANK_INDEX, LENGTHC ( FIELD_RECORD.NAME ) - 5 ),
          5 ) = '-DOWN';
        MUSH_OUT$ -> FIELD_RECORD.IS_DOWN_NAME_FROM_BELOW = 'Y';
 
        MUSH_OUT$ -> FIELD_RECORD.REPEATS_Y =
          MUSH_IN$ -> FIELD_RECORD.REPEATS_Y;
        MUSH_OUT$ -> FIELD_RECORD.SEPARATED_Y =
          MUSH_IN$ -> FIELD_RECORD.SEPARATED_Y;
 
        MUSH_OUT$ -> FIELD_RECORD.GROUP_SEQUENCE# = NEW_GROUP_SEQUENCE#;
 
        CALL FIDDLE_WITH_SEQUENCE#S
          ( NEW_SEQUENCE#_LOWER_BOUND,
          NEW_SEQUENCE#_UPPER_BOUND )
        WHENALTRETURN
        DO;
          ALTRETURN;
        END;
 
 
        CALL M$WRITE ( WRITE_MUSH_SOURCE )
        WHENALTRETURN
        DO;
          CALL INTERNAL_M$_ERROR ( WRITE_MUSH_SOURCE.V.DCB# );
          ALTRETURN;
        END;
 
        NEW_GROUP_SEQUENCE# = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
        NEW_SEQUENCE#_LOWER_BOUND = MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#;
 
        MUSH_IN$ -> FIELD_RECORD.IS_REPEATS_Y_INHERITED = 'Y';
        MUSH_IN$ -> FIELD_RECORD.IS_DOWN_NAME_FOR_ABOVE = 'Y';
 
      END;
 
    IF MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= ' '
      AND MUSH_IN$ -> FIELD_RECORD.REPEATS_X ~= '000'
    THEN
      DO;
        MUSH_IN$ -> FIELD_RECORD.IS_REPEATS_X_INHERITED = ' ';
      END;
 
    RETURN;
 
END INCLUDE_MUSH_REPEATS_RECORDS;
 
FIDDLE_WITH_SEQUENCE#S: PROC ( NEW_SEQUENCE#_LOWER_BOUND,
      NEW_SEQUENCE#_UPPER_BOUND ) ALTRET;
 
  DCL NEW_SEQUENCE#_LOWER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_LOWER_BOUND_PARTS REDEF NEW_SEQUENCE#_LOWER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
  DCL NEW_SEQUENCE#_UPPER_BOUND CHAR(10);
  DCL 1 NU_SEQUENCE#_UPPER_BOUND_PARTS REDEF NEW_SEQUENCE#_UPPER_BOUND,
        2 INTEGER CHAR(5) UNAL,
        2 FRACTION CHAR(5) UNAL;
 
    IF NEW_SEQUENCE#_UPPER_BOUND = '0000000000'
    THEN
      DO;
        STATION.MAXIMUM_SEQUENCE# = STATION.MAXIMUM_SEQUENCE# + 1;
        CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.INTEGER,
          STATION.MAXIMUM_SEQUENCE# );
        MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#_PARTS.FRACTION = '00000';
      END;
    ELSE
      DO;
        CALL CHARBIN ( A_UBIN_WHATEVER,
          NEW_SEQUENCE#_LOWER_BOUND );
        CALL BINCHAR ( MUSH_OUT$ -> FIELD_RECORD.SEQUENCE#,
          A_UBIN_WHATEVER + 50 );
        IF MUSH_OUT$ -> FIELD_RECORD.SEQUENCE# >=
          NEW_SEQUENCE#_UPPER_BOUND
        THEN
          DO;
            %ABANDON_SHIP (
            ERROR = "'Sorry, the mush file is stuffed:  please exit and re-invoke FLI.'"
            );
            ALTRETURN;
          END;
      END;
 
    RETURN;
 
END FIDDLE_WITH_SEQUENCE#S;
 
REPLACE_DEFAULT_SPECIALS: PROC ( DEFAULT_STRING,
      DEFAULT_STRING_LENGTH );
 
  DCL DEFAULT_STRING CHAR(%MAXIMUM_FIELD_LENGTH);
  DCL DEFAULT_STRING_LENGTH UBIN;
 
    BLANK_INDEX = 0;
REPLACE_DEFAULT_BLANKS_WITH__S:
    DO WHILE ( '1'B );
      CALL INDEX ( BLANK_INDEX,
        ' ',
        DEFAULT_STRING );
 
      IF BLANK_INDEX > DEFAULT_STRING_LENGTH - 1
      THEN
        EXIT REPLACE_DEFAULT_BLANKS_WITH__S;
 
      SUBSTR ( DEFAULT_STRING,
        BLANK_INDEX,
        1 ) = '_';
    END REPLACE_DEFAULT_BLANKS_WITH__S;
 
    RETURN;
 
END REPLACE_DEFAULT_SPECIALS;
 
REPLACE_CONSTANT_SPECIALS: PROC ( CONSTANT_STRING,
      CONSTANT_STRING_LENGTH );
 
  DCL CONSTANT_STRING CHAR(%MAXIMUM_FIELD_LENGTH);
  DCL CONSTANT_STRING_LENGTH UBIN;
 
    BLANK_INDEX = 0;
REPLACE_BLANKS_WITH__S:
    DO WHILE ( '1'B );
      CALL INDEX ( BLANK_INDEX,
        ' ',
        CONSTANT_STRING );
 
      IF BLANK_INDEX > CONSTANT_STRING_LENGTH - 1
      THEN
        EXIT REPLACE_BLANKS_WITH__S;
 
      SUBSTR ( CONSTANT_STRING,
        BLANK_INDEX,
        1 ) = '_';
    END REPLACE_BLANKS_WITH__S;
 
    LB_INDEX = 0;
REPLACE_LBS_WITH_LESS_THANS:
    DO WHILE ( '1'B );
      CALL INDEX ( LB_INDEX,
        '[',
        CONSTANT_STRING );
 
      IF LB_INDEX >= %MAXIMUM_FIELD_LENGTH
      THEN
        EXIT REPLACE_LBS_WITH_LESS_THANS;
 
      SUBSTR ( CONSTANT_STRING,
        LB_INDEX,
        1 ) = '<';
    END REPLACE_LBS_WITH_LESS_THANS;
 
    RB_INDEX = 0;
REPLACE_RBS_WITH_GREATER_THANS:
    DO WHILE ( '1'B );
      CALL INDEX ( RB_INDEX,
        ']',
        CONSTANT_STRING );
 
      IF RB_INDEX >= %MAXIMUM_FIELD_LENGTH
      THEN
        EXIT REPLACE_RBS_WITH_GREATER_THANS;
 
      SUBSTR ( CONSTANT_STRING,
        RB_INDEX,
        1 ) = '>';
    END REPLACE_RBS_WITH_GREATER_THANS;
 
    AT_INDEX = 0;
REPLACE_ATS_WITH_AMPERSANDS:
    DO WHILE ( '1'B );
      CALL INDEX ( AT_INDEX,
        '@',
        CONSTANT_STRING );
 
      IF AT_INDEX >= %MAXIMUM_FIELD_LENGTH
      THEN
        EXIT REPLACE_ATS_WITH_AMPERSANDS;
 
      SUBSTR ( CONSTANT_STRING,
        AT_INDEX,
        1 ) = '&';
    END REPLACE_ATS_WITH_AMPERSANDS;
 
    RETURN;
 
END REPLACE_CONSTANT_SPECIALS;
 
STRIP_LEADING_ZEROES: PROC ( THREE_DIGIT_NUMBER,
      LEADING_ZERO_COUNT );
 
  DCL THREE_DIGIT_NUMBER CHAR(3);
  DCL LEADING_ZERO_COUNT UBIN;
  DCL DIGIT_INDEX UBIN;
 
    LEADING_ZERO_COUNT = 0;
 
    DO DIGIT_INDEX = 0 TO 1;
 
      IF SUBSTR ( THREE_DIGIT_NUMBER, DIGIT_INDEX, 1 ) = '0'
      THEN
        LEADING_ZERO_COUNT = LEADING_ZERO_COUNT + 1;
      ELSE
        RETURN;
 
    END;
 
    RETURN;
 
END STRIP_LEADING_ZEROES;
 
FLUSH_THE_MUSH_SOURCE: PROC ALTRET;
 
    CALL CLOSE_THE_MUSH_SOURCE;
 
    CALL OPEN_THE_MUSH_SOURCE
    WHENALTRETURN
    DO;
      ALTRETURN;
    END;
 
    RETURN;
 
END FLUSH_THE_MUSH_SOURCE;
 
OPEN_THE_MUSH_SOURCE: PROC ALTRET;
 
    CALL M$OPEN ( OPEN_MUSH_SOURCE )
    WHENALTRETURN
    DO;
      CALL INTERNAL_M$_ERROR ( OPEN_MUSH_SOURCE.V.DCB# );
      ALTRETURN;
    END;
 
    RETURN;
 
END OPEN_THE_MUSH_SOURCE;
 
CLOSE_THE_MUSH_SOURCE: PROC;
 
    CALL M$CLOSE ( CLOSE_MUSH_SOURCE )
    WHENALTRETURN
    DO;
    END;
 
END CLOSE_THE_MUSH_SOURCE;
 
OPEN_THE_FPL_SOURCE_IN: PROC ALTRET;
 
    IF CG_IN$ -> FID_RECORD.OLD_NEW = 'O'
    THEN
      DO;
        OPEN_FPL_SOURCE.V.FUN# = %IN#;
        OPEN_FPL_SOURCE.V.EXIST# = %OLDFILE#;
      END;
    ELSE
      DO;
        OPEN_FPL_SOURCE.V.FUN# = %CREATE#;
        OPEN_FPL_SOURCE.V.EXIST# = %ERROR#;
      END;
 
    GOTO SO_OPEN_THE_FPL_SOURCE_ALREADY;
 
OPEN_THE_FPL_SOURCE_OUT_TEST: ENTRY ALTRET;
 
    OPEN_FPL_SOURCE.V.OPER.TEST# = %YES;
 
OPEN_THE_FPL_SOURCE_OUT: ENTRY ALTRET;
 
    OPEN_FPL_SOURCE.V.ORG# = %CONSEC#;
    OPEN_FPL_SOURCE.V.FUN# = %CREATE#;
    OPEN_FPL_SOURCE.V.EXIST# = %NEWFILE#;
 
SO_OPEN_THE_FPL_SOURCE_ALREADY:
    FPT_FID.TEXTFID_ = VECTOR ( CG_IN$ -> FID_RECORD.FID );
/*  %ABANDON_SHIP (
    ERROR = "SUBSTR ( CG_IN$ -> FID_RECORD.FID, 0, 50 )"
    );
    %ABANDON_SHIP (
    ERROR = "SUBSTR ( CG_IN$ -> FID_RECORD.FID, 50, 50 )"
    );
    %ABANDON_SHIP (
    ERROR = "SUBSTR ( CG_IN$ -> FID_RECORD.FID, 100, 37 )"
    );  */
    CALL M$FID ( FPT_FID )
    WHENALTRETURN
    DO;
      CALL SOMEKINDA_M$_ERROR ( 0 );
      ALTRETURN;
    END;
 
    CALL M$OPEN ( OPEN_FPL_SOURCE )
    WHENALTRETURN
    DO;
      CALL SOMEKINDA_M$_ERROR ( OPEN_FPL_SOURCE.V.DCB# );
 
      CALL CLOSE_THE_FPL_SOURCE;
 
      ALTRETURN;
    END;
 
    RETURN;
 
END OPEN_THE_FPL_SOURCE_IN;
 
CLOSE_THE_FPL_SOURCE: PROC;
 
    CALL M$CLOSE ( CLOSE_FPL_SOURCE )
    WHENALTRETURN
    DO;
    END;
 
    RETURN;
 
END CLOSE_THE_FPL_SOURCE;
 
INTERNAL_M$_ERROR: PROC ( DCB_NUM );
 
  DCL DCB_NUM UBIN HALF;
  DCL INTERNAL_ERROR BIT(1) ALIGNED;
 
    INTERNAL_ERROR = %YES;
    GOTO SO_ERROR_IT_ALREADY;
 
SOMEKINDA_M$_ERROR: ENTRY ( DCB_NUM );
 
    INTERNAL_ERROR = %NO;
 
SO_ERROR_IT_ALREADY:
    VLP_ERRCODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    FPT_ERRMSG.V.DCB# = DCB_NUM;
    CALL M$ERRMSG ( FPT_ERRMSG )
    WHENALTRETURN
    DO;
      SYSTEM_ERROR_MESSAGE = 'No ERRMSG available!';
    END;
 
    IF INTERNAL_ERROR
    THEN
      %ABANDON_SHIP (
        ERROR = SYSTEM_ERROR_MESSAGE,
        INTERNAL_ERROR = YES
        );
    ELSE
      %ABANDON_SHIP (
        ERROR = SYSTEM_ERROR_MESSAGE
        );
 
    RETURN;
 
END INTERNAL_M$_ERROR;
 
END FLI;
