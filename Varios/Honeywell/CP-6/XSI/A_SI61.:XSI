/*M* A - Records & reports job status in/from a file. */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMR,PLM=5,IND=5,CSU=3,EXM=0,ECU=3,MOC,DCI=5,CRT=5 */
 
A:   PROC MAIN;
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE XSJ_MAC_C;
%INCLUDE XSJ_SUBS_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE A_C1;
 
DCL M$SI DCB;
DCL M$ME DCB;
%M$DCB (DCBN=M$$JOB,
        ACS=DIRECT,
        ASN=FILE,
        NAME='$$JOB',
        ORG=KEYED,
        TYPE='DA');
%M$DCB (DCBN=M$JS,
        ASN=FILE,
        ACCT=':SYS',
        NAME=':JOBSTATS');
 
%FPT_OPEN (FPTN=FPT_OPEN_ME,
           STCLASS=CONSTANT,
           DCB=M$ME);
%FPT_OPEN (FPTN=FPT_OPEN,
           STCLASS=CONSTANT,
           DCB=M$$JOB,
           CTG=YES,
           EXIST=OLDFILE,
           FUN=CREATE,
           SHARE=ALL,
           FPARAM=PARAMB);
%FPT_OPEN (FPTN=FPT_OPEN_READ,
           STCLASS=CONSTANT,
           DCB=M$$JOB,
           FUN=UPDATE,
           SHARE=ALL,
           FPARAM=PARAMB);
%FPT_OPEN (FPTN=FPT_OPEN_JOBSTATS,
           STCLASS=CONSTANT,
           DCB=M$JS,
           FUN=IN,
           SHARE=ALL);
%FPT_CLOSE (FPTN=FPT_CLOSE,
            STCLASS=STATIC,
            DCB=M$$JOB,
            DISP=SAVE);
%FPT_PFIL (FPTN=FPT_PFIL,
           STCLASS=CONSTANT,
           DCB=M$$JOB,
           BOF=YES);
%FPT_READ (FPTN=FPT_READ,
           STCLASS=CONSTANT,
           DCB=M$$JOB,
           BUF=BUFFER,
           KEY=KEYBUF,
           KEYR=YES);
%FPT_READ (FPTN=FPT_READ_CANCEL,
           STCLASS=CONSTANT,
           DCB=M$$JOB,
           BUF=FDS_BUFFER,
           KEY=KEYBUF,
           KEYR=YES);
%FPT_READ (FPTN=FPT_READ_JOBINFO,
           STCLASS=CONSTANT,
           DCB=M$JS,
           BUF=XSJ_JOBINFO,
           KEY=XSJ_INFOKEY,
           KEYS=YES);
%FPT_PRECORD (FPTN=FPT_PRECORD_CANCEL,
              STCLASS=CONSTANT,
              DCB=M$$JOB,
              KEY=KEYBUF,
              KEYS=YES);
%XSJ_JOBINFO (FPTN=XSJ_JOBINFO,
              STCLASS=STATIC);
%XSJ_INFOKEY (FPTN=XSJ_INFOKEY,
              STCLASS=STATIC);
%FPT_READ (FPTN=FPT_READ_JOBNAME,
           STCLASS=CONSTANT,
           DCB=M$JS,
           BUF=XSJ_NAMEREC,
           KEY=XSJ_NAMEKEY,
           KEYS=YES);
%XSJ_NAMEREC (FPTN=XSJ_NAMEREC,
              STCLASS=STATIC);
%XSJ_NAMEKEY (FPTN=XSJ_NAMEKEY,
              STCLASS=STATIC);
%FPT_WRITE (FPTN=FPT_WRITE,
            STCLASS=STATIC,
            DCB=M$$JOB,
            KEY=KEYBUF,
            ONEWKEY=YES);
%FPT_WRITE (FPTN=FPT_WRITE_BELL,
            STCLASS=CONSTANT,
            DCB=M$ME,
            BUF=BELLS,
            TRANS=YES,
            VFC=YES);
%FPT_YC (FPTN=FPT_YC,
         STCLASS=STATIC,
         ECHO=NO,
         NOERR=YES);
%FPT_JOBSTATS (FPTN=FPT_JOBSTATS_CHECK,
               STCLASS=STATIC,
               ORDER=CHECK,
               ACCT=VLP_ACCT,
               RESULTS=VLR_JOBSTATS_CHECK);
%VLP_ACCT (FPTN=VLP_ACCT,
           STCLASS=STATIC);
%VLP_JOBNAME (FPTN=VLP_JOBNAME,
              STCLASS=STATIC);
%VLR_JOBSTATS_CHECK (FPTN=VLR_JOBSTATS_CHECK,
                     STCLASS=STATIC);
%FPT_JOBSTATS (FPTN=FPT_JOBSTATS_CANCEL,
               STCLASS=STATIC,
               ORDER=CANCEL,
               OUTPUT=YES,
               RESULTS=VLR_JOBSTATS_CANCEL);
%VLR_JOBSTATS_CHECK (FPTN=VLR_JOBSTATS_CANCEL,
                     STCLASS=STATIC);
%FPT_JOBSTATS (FPTN=FPT_JOBSTATS_SRCH,
               STCLASS=CONSTANT,
               ORDER=SRCH,
               CRITERIA=VLP_CRITERIA,
               OUTPUT=NO,
               RESULTS=VLR_JOBSTATS_ISRCH);
%VLP_CRITERIA (FPTN=VLP_CRITERIA,
               STCLASS=STATIC);
%VLR_JOBSTATS_ISRCH (FPTN=VLR_JOBSTATS_ISRCH,
                     STCLASS=STATIC,
                     NJOB=0);
%VLA_JOBSTATS_ISRCH (FPTN=VLA$JOBSTATS_ISRCH,
                     STCLASS=BASED);
%FPT_DELREC (FPTN=FPT_DELREC,
            STCLASS=CONSTANT,
            DCB=M$$JOB);
%FPT_DELREC (FPTN=FPT_DELREC_RANGE,
            STCLASS=CONSTANT,
            DCB=M$$JOB,
            KEY=KEYBUF,
            LKEY=LKEYBUF);
%FPT_ERRMSG (FPTN=FPT_ERRMSG,
             STCLASS=STATIC,
             CODE=ERRCODE,
             BUF=ERRBUF,
             OUTDCB1=M$ME);
%FPT_WAIT (FPTN=FPT_WAIT,
           STCLASS=STATIC);
%FPT_INT (FPTN=FPT_INT,
          STCLASS=CONSTANT,
          UENTRY=ABREAK);
%FPT_PRIV (FPTN=FPT_PRIV,
           STCLASS=STATIC,
           AUTH=YES);
%FPT_FID (FPTN=FPT_FID,
          STCLASS=STATIC,
          NAME=VLP_NAME_FID,
          ACCT=VLP_ACCT_FID,
          PASS=VLP_PASS_FID,
          SN=VLP_SN_FID,
          ASN=FPT_OPEN_DUMMY.V.ASN#,
          RES=FPT_OPEN_DUMMY.V.RES#,
          WSN=VLP_WSN_FID,
          SNAME=YES,
          SACCT=NO,
          SPASS=YES,
          SSN=YES);
%VLP_NAME (FPTN=VLP_NAME_FID,
           STCLASS=STATIC);
%VLP_ACCT (FPTN=VLP_ACCT_FID,
           STCLASS=STATIC);
%VLP_PASS (FPTN=VLP_PASS_FID,
           STCLASS=STATIC);
%VLP_SN (FPTN=VLP_SN_FID,
         STCLASS=STATIC,
         N=1);
%VLP_WSN (FPTN=VLP_WSN_FID,
          STCLASS=STATIC);
%FPT_OPEN (FPTN=FPT_OPEN_DUMMY,
           STCLASS=STATIC);
%FPT_LINK (FPTN=FPT_LINK,
           STCLASS=STATIC,
           NAME=VLP_NAME_FID,
           ACCT=VLP_ACCT_FID,
           PASS=VLP_PASS_FID,
           PSID="VLP_SN_FID.SN#(0)");
%FPT_LDTRC (FPTN=FPT_LDTRC,
            STCLASS=STATIC,
            NAME=VLP_NAME_FID,
            ACCT=VLP_ACCT_FID,
            PASS=VLP_PASS_FID,
            PSID="VLP_SN_FID.SN#(0)");
%FPT_DISPLAY (FPTN=FPT_DISPLAY,
              STCLASS=CONSTANT,
              RESULTS=VLR_DISPLAY);
%VLR_DISPLAY (FPTN=VLR_DISPLAY,
              STCLASS=STATIC);
%FPT_TIME (FPTN=FPT_TIME_CLOCK,
           STCLASS=CONSTANT,
           DEST=LOCAL,
           SOURCE=CLOCK,
           DATE=LOCL.DATE,
           TIME=LOCL.TIME);
%FPT_TIME (FPTN=FPT_TIME_TSTAMP,
           STCLASS=CONSTANT,
           DEST=LOCAL,
           SOURCE=UTS,
           TSTAMP=TSTAMP,
           DATE=LOCL.DATE,
           TIME=LOCL.TIME);
DCL TSTAMP UBIN STATIC;
DCL 1 LOCL STATIC,
      2 TIME,
        3 HHMM CHAR(5) UNAL,
        3 * CHAR(6) UNAL,
      2 DATE,
        3 MMDD CHAR(5) UNAL,
        3 * CHAR(3) UNAL;
DCL HHMM_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( LOCL.TIME.HHMM ) );
DCL MMDD_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( LOCL.DATE.MMDD ) );
DCL MODD_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( LOCL.DATE ) );
%FPT_TRAP (FPTN=FPT_TRAP,
           STCLASS=CONSTANT,
           ARITHMETIC=ATRAP,
            DIVIDE_CHECK=TRAP,
            OVERFLOW=TRAP,
           ERRORS=ATRAP,
            COMMAND=TRAP,
            IPR=TRAP,
            LOCKUP=TRAP,
            MEMORY=TRAP,
            MISSING_PAGE=TRAP,
            MISSING_SEG=TRAP,
            SECURITY_1=TRAP,
            SECURITY_2=TRAP,
           PMME=ATRAP,
           PROGRAMMED=NIL);
/* FPTs, VLAs & VLPs & VLRs for ACCOUNT SRCH */
%FPT_JOBSTATS (FPTN=FPT_ISRCH_ACCT,
               CRITERIA=VLP_CRITERIA_ACCT,
               OUTPUT=NO,
               ORDER=SRCH);
%VLP_CRITERIA (FPTN=VLP_CRITERIA_ACCT);
%VLR_JOBSTATS_ISRCH (FPTN=VLR_ISRCH_ACCT,
                     NJOB=16,           /* This may get dynamically changed */
                     STCLASS=BASED);
%VLA_JOBSTATS_ISRCH (FPTN=IQ,
                     STCLASS=BASED);
 
%FPT_JOBSTATS (FPTN=FPT_OSRCH_ACCT,
               CRITERIA=VLP_CRITERIA_ACCT,
               OUTPUT=YES,
               ORDER=SRCH);
%VLR_JOBSTATS_OSRCH (FPTN=VLR_OSRCH_ACCT,
                     NFIL=64,           /* This may get dynamically changed */
                     STCLASS=BASED);
%VLA_JOBSTATS_OSRCH (FPTN=OQ,
                     STCLASS=BASED);
 
%FPT_PRECORD (FPTN=FPT_PRECORD_ACCOUNT,
              DCB=M$$JOB,
              KEY=KEYBUF,
              KEYR=YES,
              KEYS=YES,
              STCLASS=CONSTANT);
 
%FPT_GDS (FPTN=GET_SRCH_SEG,
          RESULTS=SRCH_GDS_RESULTS,
          SEGSIZE=1024);
%VLP_VECTOR (FPTN=SRCH_GDS_RESULTS);
%FPT_FDS (FPTN=REL_SRCH_SEG,
          RESULTS=SRCH_GDS_RESULTS);
 
%EQU USERWSR=7;
 
%VLP_ERRCODE (FPTN=ERRCODE,
              STCLASS=STATIC);
DCL XERRCODE BIT(36) STATIC;
DCL CMD$ REDEF XERRCODE PTR;
DCL OUT1$ PTR STATIC;
DCL SYSID$ PTR STATIC;
DCL OUT$ PTR STATIC;
DCL JIT$ PTR STATIC;
DCL CMDNUM SBIN STATIC;
DCL START SBIN STATIC;
DCL I SBIN STATIC;
DCL II SBIN STATIC;
DCL MINU UBIN STATIC;
DCL SECU UBIN STATIC;
DCL MINR UBIN STATIC;
DCL SECR UBIN STATIC;
DCL BUFFR UBIN STATIC;
DCL NFOLL UBIN STATIC;
DCL S(0:7) UBIN STATIC;
DCL BITSET UBIN STATIC;
DCL LIMIT_BUF CHAR(80) STATIC;
DCL CHR_POS UBIN STATIC;
DCL PARAMB(0:1023) UBIN STATIC;
DCL FIT$ PTR STATIC;
DCL CODE UBIN STATIC;
DCL FITCODES(0:1) UBIN CONSTANT INIT( 9, 10 );
DCL ERRBUF CHAR(120) STATIC;
DCL BUFFER CHAR(256) STATIC;
DCL FDS_BUFFER CHAR(256) STATIC;
DCL XUR_BUFFER(0:511) UBIN STATIC DALIGNED;
DCL 1 KEYBUF STATIC,
      2 KSIZ UBIN BYTE UNAL,
      2 SYSID UBIN UNAL,
      2 STATUS,
        3 CODE UBIN UNAL,
        3 PRIO UBIN UNAL,
        3 TORUN UBIN UNAL,
      2 ACCN CHAR(8) UNAL,
      2 UNAME CHAR(12) UNAL,
      2 * CHAR(216) UNAL;
DCL 1 LKEYBUF STATIC,
      2 KSIZ UBIN BYTE UNAL INIT( 8 ),
      2 SYSID UBIN UNAL,
      2 * SBIN UNAL INIT( -1 );
DCL 1 OLDSTATUS STATIC,
      2 CODE UBIN UNAL,
      2 PRIO UBIN UNAL,
      2 TORUN UBIN UNAL;
DCL KEYSIZE UBIN STATIC;
DCL SYSIDT UBIN STATIC;
DCL STEPCC UBIN STATIC;
DCL ARS UBIN STATIC;
DCL FDS_BUFSIZE UBIN STATIC;
DCL CMDSIZE SBIN STATIC;
DCL CPOS UBIN STATIC;
DCL CSIZ UBIN STATIC;
DCL KLUDGE_FACTOR UBIN STATIC;
DCL TESTING BIT(1) STATIC;
DCL EVERY BIT(1) STATIC;
DCL FROMJIT BIT(1) STATIC;
DCL DELETE_REC BIT(1) STATIC;
DCL ONECMD BIT(1) STATIC ALIGNED INIT( '0'B );
DCL READMORE BIT(1) STATIC ALIGNED INIT( '0'B );
DCL MINE BIT(1) STATIC ALIGNED INIT( '1'B );
DCL NOFIT BIT(1) STATIC ALIGNED INIT( '1'B );
DCL BUF$ PTR CONSTANT INIT( ADDR( BUFFER ) );
DCL FDS_BUF$ PTR CONSTANT INIT( ADDR( FDS_BUFFER ) );
DCL ORIG_DELETE_REC BIT(1) STATIC ALIGNED INIT( '1'B );
DCL WAIT_DONE BIT(1) STATIC ALIGNED INIT( '1'B );
DCL CHANGE_REC BIT(1) STATIC ALIGNED INIT( '1'B );
DCL CAN_MAP BIT(1) STATIC ALIGNED INIT( '0'B );
DCL U$$ EPTR CONSTANT INIT( ENTADDR( ASUCC ) );
DCL WAITING BIT(1) STATIC INIT( '0'B );
DCL EMPTY BIT(1) STATIC;
DCL WAITINT UBIN STATIC INIT( 15 );
DCL LIMIT_VEC_ (0:8) BIT(72) STATIC INIT(VECTOR(NIL)*0);
DCL M$$JOB$ PTR STATIC;
DCL M$JS$ PTR STATIC;
DCL M$ME$ PTR STATIC;
 
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL A@NODES UBIN SYMREF;
DCL A@IMMED BIT(1) STATIC SYMDEF INIT( '0'B );
DCL A@BREAK BIT(1) STATIC SYMDEF INIT( '0'B );
DCL A@TRAP BIT(1) STATIC SYMDEF INIT( '0'B );
DCL A@TRAPUNWIND BIT(72) DALIGNED STATIC SYMDEF;
 
DCL ABREAK ENTRY ASYNC;
DCL ATRAP ENTRY ASYNC;
DCL ASUCC ENTRY(1);
%P$PCB (NAME=P_PCB,
        STCLASS=STATIC);
%XUR_INIT (NAME=XUR_INIT,
           STCLASS=CONSTANT,
           PCB=P_PCB,
           WORK=XUR_BUFFER);
DCL XSF$LOCCODT ENTRY(2) ALTRET;
DCL DAM$INIT ENTRY(0) ALTRET;
DCL DAM$MAP ENTRY(5) ALTRET;
%INCLUDE XUF_ENTRY;
%INCLUDE XUR_ENTRY;
 
%B$ALT;
%B$TCB;
%F$DCB;
DCL CHAR$STRING CHAR( CSIZ ) BASED;
DCL 1 TEXT$C BASED UNAL,
      2 COUNT UBIN BYTE UNAL,
      2 TEXT CHAR( TEXT$C.COUNT ) UNAL;
%PARSE$OUT (STCLASS=BASED);
%PARSE$SYM (STCLASS=BASED);
DCL 1 BUFF$ER BASED( BUF$ ),
      2 * CHAR( ARS );
DCL 1 FDS_BUFF$ER BASED( FDS_BUF$ ),
      2 * CHAR( FDS_BUFSIZE );
%F_FDS (NAME=F_FDS,
        STCLASS=STATIC,
        DCB=M$ME,
        TRUNC=YES);
%F_FDS (NAME=LIM_FDS,
        STCLASS=STATIC,
        DCB=M$ME,
        FMT=LIMIT_BUF,
        TRUNC=YES,
        VECTR=LIMIT_VEC_);
 
DCL FMTVEC_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC ) );
DCL FMTVEC1_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC1 ) );
DCL FMTVEC2_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC2 ) );
DCL FMTVEC3_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC3 ) );
DCL FMTVEC5_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC5 ) );
DCL FMTVEC6_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC6 ) );
DCL FMTVEC7_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC7 ) );
DCL FMTVEC8_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC8 ) );
DCL FMTVEC9_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC9 ) );
DCL FMTVEC12_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC12 ) );
DCL FMTVEC13_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC13 ) );
DCL FMTVEC14_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FMTVEC14 ) );
DCL DI_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( DI ) );
DCL JNERR_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( JNERR ) );
DCL JNAERR_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( JNAERR ) );
DCL PROMPT_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( PROMPT ) );
DCL PRTNODEV_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( PRTNODEV ) );
DCL MINU_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( MINU ) );
DCL SECU_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( SECU ) );
DCL MINR_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( MINR ) );
DCL SECR_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( SECR ) );
DCL BUFFR_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( BUFFR ) );
DCL NFOLL_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( NFOLL ) );
DCL SYSID_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FPT_JOBSTATS_CHECK.V.SYSID# ) );
DCL AHEAD_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( VLR_JOBSTATS_CHECK.AHEAD ) );
DCL PRIO_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( VLR_JOBSTATS_CHECK.PRIO ) );
DCL LPXX_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( VLR_JOBSTATS_CHECK.DEVNAME ) );
DCL TWSN_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( VLR_JOBSTATS_CHECK.TNAME ) );
DCL RECNO_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( XSJ_JOBINFO.RECNO# ) );
DCL BUFF_ BIT(72) STATIC DALIGNED;
DCL CODETEXT_ BIT(72) STATIC DALIGNED;
DCL CODETEXT1_ BIT(72) STATIC DALIGNED;
DCL NERRVEC_ BIT(72) STATIC DALIGNED;
DCL NAERRVEC_ BIT(72) STATIC DALIGNED;
DCL CCBUF_ BIT(72) STATIC DALIGNED;
DCL ACCN_ BIT(72) STATIC DALIGNED;
DCL UNAME_ BIT(72) STATIC DALIGNED;
DCL STEPCC_ BIT(72) STATIC DALIGNED;
DCL S__(0:7) BIT(72) STATIC DALIGNED;
DCL FOLLOW_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FOLLOW ) );
DCL AFTER_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( AFTER ) );
DCL NONE_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( NONE ) );
DCL OTHER_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( OTHER ) );
DCL WPS_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( WPS ) );
DCL MBS_DELETED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( MBS_DELETED ) );
DCL MBS_CANCELED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( MBS_CANCELED ) );
DCL MBS_SHAFTED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( MBS_SHAFTED ) );
DCL MBS_FILERR_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( MBS_FILERR ) );
DCL PRE_PASSED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( PRE_PASSED ) );
DCL REJ_JOB_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_JOB ) );
DCL REJ_RES_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_RES ) );
DCL REJ_SYNTAX_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_SYNTAX ) );
DCL REJ_IO_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_IO ) );
DCL REJ_JOBIMBED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_JOBIMBED ) );
DCL REJ_BADID_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_BADID ) );
DCL REJ_NORES_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_NORES ) );
DCL REJ_PRESCAN_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_PRESCAN ) );
DCL REJ_RESIMBED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_RESIMBED ) );
DCL REJ_NOBATCH_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( REJ_NOBATCH ) );
DCL FIN_RECOVER_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FIN_RECOVER ) );
DCL FIN_ABNORMAL_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FIN_ABNORMAL ) );
DCL FIN_COMPLETED_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( FIN_COMPLETED ) );
DCL ARRAY__(0:6) BIT(72) CONSTANT DALIGNED INIT( VECTOR( WAIT ),
                                               VECTOR( RUN ),
                                               VECTOR( PWAIT ),
                                               VECTOR( PRT ),
                                               VECTOR( NOTF ),
                                               VECTOR( SPILLED ),
                                               VECTOR( AP ) );
DCL RS__(0:8) BIT(72) CONSTANT DALIGNED INIT( VECTOR( RS_ERR ),
                                            VECTOR( RS_XXX ),
                                            VECTOR( RS_SSP ),
                                            VECTOR( RS_ABRT ),
                                            VECTOR( RS_EKEY ),
                                            VECTOR( RS_OFF ),
                                            VECTOR( RS_LIMX ),
                                            VECTOR( RS_DROP ),
                                            VECTOR( RS_XKEY ) );
DCL XL__(0:8) BIT(72) CONSTANT DALIGNED INIT( VECTOR( XL_TIME ),
                                            VECTOR( XL_STACK ),
                                            VECTOR( XL_TAPE ),
                                            VECTOR( XL_TDISK ),
                                            VECTOR( XL_PDISK ),
                                            VECTOR( XL_DO ),
                                            VECTOR( XL_LO ),
                                            VECTOR( XL_PLO ),
                                            VECTOR( XL_PO ) );
DCL RS_CAN_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( RS_CAN ) );
DCL WAIT CHAR(0) CONSTANT INIT( 'Waiting' );
DCL RUN CHAR(0) CONSTANT INIT( 'Running' );
DCL PWAIT CHAR(0) CONSTANT INIT( 'Waiting to print' );
DCL PRT CHAR(0) CONSTANT INIT( 'Printing' );
DCL NOTF CHAR(0) CONSTANT INIT( 'Doesn''t exist' );
DCL SPILLED CHAR(0) CONSTANT INIT( 'All output SPILLed' );
DCL AP CHAR(0) CONSTANT INIT( 'Awaiting PRESCAN' );
DCL RS_ERR CHAR(0) CONSTANT INIT( 'M$ERR pmme' );
DCL RS_XXX CHAR(0) CONSTANT INIT( 'M$XXX pmme' );
DCL RS_SSP CHAR(0) CONSTANT INIT( 'Aborted by special shared processor' );
DCL RS_ABRT CHAR(0) CONSTANT INIT( 'Aborted by monitor (ABORTM)' );
DCL RS_EKEY CHAR(0) CONSTANT INIT( 'Errored by operator' );
DCL RS_OFF CHAR(0) CONSTANT INIT( 'Aborted by monitor (!X)' );
DCL RS_LIMX CHAR(0) CONSTANT INIT( 'Limit exceeded' );
DCL RS_DROP CHAR(0) CONSTANT INIT( 'Line disconnect' );
DCL RS_XKEY CHAR(0) CONSTANT INIT( 'Aborted by operator' );
DCL RS_CAN CHAR(0) CONSTANT INIT( 'Canceled by user' );
DCL XL_TIME CHAR(0) CONSTANT INIT( 'TIME' );
DCL XL_STACK CHAR(0) CONSTANT INIT( 'STACK' );
DCL XL_TAPE CHAR(0) CONSTANT INIT( 'TAPE' );
DCL XL_TDISK CHAR(0) CONSTANT INIT( 'TDIS' );
DCL XL_PDISK CHAR(0) CONSTANT INIT( 'PDIS' );
DCL XL_DO CHAR(0) CONSTANT INIT( 'DO' );
DCL XL_LO CHAR(0) CONSTANT INIT( 'LO' );
DCL XL_PLO CHAR(0) CONSTANT INIT( 'PLO' );
DCL XL_PO CHAR(0) CONSTANT INIT( 'PO' );
DCL PROMPT CHAR(0) CONSTANT INIT( ':' );
DCL PRTNODEV CHAR(0) CONSTANT INIT( 'Waiting NODEV to print' );
DCL FOLLOW CHAR(0) CONSTANT INIT( 'Waiting to follow ????' );
DCL AFTER CHAR(0) CONSTANT INIT( 'Deferred until ??:??' );
DCL NONE CHAR(0) CONSTANT INIT( 'No partition available' );
DCL OTHER CHAR(0) CONSTANT INIT( 'Stuck in some priority queue' );
DCL WPS CHAR(0) CONSTANT INIT( 'Waiting for disk packset' );
DCL MBS_DELETED CHAR(0) CONSTANT INIT( 'Deleted by operator' );
DCL MBS_CANCELED CHAR(0) CONSTANT INIT( 'Canceled by user' );
DCL MBS_SHAFTED CHAR(0) CONSTANT INIT( 'Deleted by MBS for FOLLOW condition' );
DCL MBS_FILERR CHAR(0) CONSTANT INIT( 'Cancelled or deleted by MBS due to file inconsistency' );
DCL PRE_PASSED CHAR(0) CONSTANT INIT( 'Passed PRESCAN successfully' );
DCL REJ_JOB CHAR(0) CONSTANT INIT( 'bad !JOB' );
DCL REJ_RES CHAR(0) CONSTANT INIT( 'bad !RESOURCE' );
DCL REJ_SYNTAX CHAR(0) CONSTANT INIT( 'syntax error' );
DCL REJ_IO CHAR(0) CONSTANT INIT( 'I/O error' );
DCL REJ_JOBIMBED CHAR(0) CONSTANT INIT( 'imbedded !JOB' );
DCL REJ_BADID CHAR(0) CONSTANT INIT( 'invalid ACCOUNT, USER, or PASSWORD on !JOB' );
DCL REJ_NORES CHAR(0) CONSTANT INIT( 'too many resources specified' );
DCL REJ_PRESCAN CHAR(0) CONSTANT INIT( 'PRESCAN problem' );
DCL REJ_RESIMBED CHAR(0) CONSTANT INIT( 'imbedded !RESOURCE' );
DCL REJ_NOBATCH CHAR(0) CONSTANT INIT( 'you are not authorized for BATCH' );
DCL FIN_RECOVER CHAR(0) CONSTANT INIT( 'Caught in RECOVERY' );
DCL FIN_ABNORMAL CHAR(0) CONSTANT INIT( 'Completed ABNORMALLY' );
DCL FIN_COMPLETED CHAR(0) CONSTANT INIT( 'Completed OK' );
DCL FMTVEC CHAR(0) CONSTANT INIT( '%D %A %A' );
DCL FMTVEC1 CHAR(0) CONSTANT INIT( '%D %A %D to run at prio %D %A' );
DCL FMTVEC2 CHAR(0) CONSTANT INIT( '%D %A on %A@%>A %A' );
DCL FMTVEC3 CHAR(0) CONSTANT INIT( '%D Rejected at record %D (%A) %A' );
DCL FMTVEC5 CHAR(0) CONSTANT INIT( '%D %>A,%>A %D:%2ZD/%D:%2ZD !%A' );
DCL FMTVEC6 CHAR(0) CONSTANT INIT( '%D Waiting to follow %D%N(,%D%) %A' );
DCL FMTVEC7 CHAR(0) CONSTANT INIT( '%D Deferred until %A %A %A' );
DCL FMTVEC8 CHAR(0) CONSTANT INIT( '%D %A on %A@%>A >%A< %A' );
DCL FMTVEC9 CHAR(0) CONSTANT INIT( '%D %A >%A< %A' );
DCL FMTVEC12 CHAR(0) CONSTANT INIT( '%D %A on %A@%>A >%A with STEPCC=%D< %A' );
DCL FMTVEC13 CHAR(0) CONSTANT INIT( '%D %A >%A with STEPCC=%D< %A' );
DCL FMTVEC14 CHAR(0) CONSTANT INIT( '%D %A with STEPCC=%D %A' );
DCL LIMIT_FMT1 CHAR(0) CONSTANT INIT('%D %<>A on %<>A >Limit %<>A');
DCL LIMIT_FMT2 CHAR(0) CONSTANT INIT('%D %<>A >Limit %<>A');
DCL LIMIT_FMT3 CHAR(0) CONSTANT INIT('%D Limit %<>A');
DCL LIMIT_END1 CHAR(0) CONSTANT INIT(' exceeded< %<>A');
DCL LIMIT_END2 CHAR(0) CONSTANT INIT(' exceeded< %<>A');
DCL LIMIT_END3 CHAR(0) CONSTANT INIT(' exceeded %<>A');
DCL EXTRA_LIMITS_FMT CHAR(0) CONSTANT INIT(',%<>A');
DCL DI CHAR(0) CONSTANT INIT( ' %A %A %D*%D<%D%S' );
DCL JNERR CHAR(0) CONSTANT INIT( 'NAME=%A Doesn''t exist' );
DCL JNAERR CHAR(0) CONSTANT INIT( 'NAME=%A.%A Doesn''t exist' );
DCL ERR0_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR0 ) );
DCL ERR0 CHAR(0) CONSTANT INIT( 'Your $$JOB fid is not a keyed file' );
DCL ERR1_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR1 ) );
DCL ERR1 CHAR(0) CONSTANT INIT( 'Specified SYSID is > 262143' );
DCL ERR2_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR2 ) );
DCL ERR2 CHAR(0) CONSTANT INIT( 'Specified Job NAME is too big' );
DCL ERR3_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR3 ) );
DCL ERR3 CHAR(0) CONSTANT INIT( 'Specified Job NAME account is to big' );
DCL ERR4_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR4 ) );
DCL ERR4 CHAR(0) CONSTANT INIT( 'Your $$JOB file was not created by this version of A.X' );
DCL ERR5_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR5 ) );
DCL ERR5 CHAR(0) CONSTANT INIT( 'You can''t change this $$JOB file' );
DCL ERR6_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR6 ) );
DCL ERR6 CHAR(0) CONSTANT INIT( 'Implied LAST aborted because:' );
DCL ERR7_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR7 ) );
DCL ERR7 CHAR(0) CONSTANT INIT( 'WAIT/SLEEP/EVERY command ignored because:' );
DCL ERR8_ BIT(72) STATIC DALIGNED INIT( VECTOR( ERR8 ) );
DCL ERR8 CHAR(0) STATIC INIT( 'Specified ACCOUNT is too big' );
DCL ERR9_ BIT(72) CONSTANT DALIGNED INIT( VECTOR( ERR9 ) );
DCL ERR9 CHAR(0) CONSTANT INIT( 'You haven''t BATCHed any jobs yet' );
DCL BELLS CHAR(0) CONSTANT INIT( '@' );
 
%SUB VLA$JOBSTATS_ISRCH="ADDR(VLR_JOBSTATS_ISRCH.J(0))->VLA$JOBSTATS_ISRCH";
%EQU INTMSG@='->This terminal''s output';
%EQU BATCHMSG@='->This BATCH job';
%EQU GHOSTMSG@='->This GHOST job';
%EQU TPMSG@='->This TP job';
%EQU KLUDGE1=1;
%EQU KLUDGE2=2;
%EQU KLUDGE3=3;
%EQU KLUDGE4=4;
%EQU KLUDGE5=5;
 
/* Initialization */
     CALL XUR$INIT( XUR_INIT );
     KEYSIZE = LENGTHC( KEYBUF.SYSID ) + LENGTHC( KEYBUF.STATUS ) +
       LENGTHC( KEYBUF.UNAME ) + LENGTHC( KEYBUF.ACCN );
     M$ME$ = DCBADDR( DCBNUM( M$ME ) );
     M$$JOB$ = DCBADDR( DCBNUM( M$$JOB ) );
     CALL SET_FDS;
     CALL M$INT( FPT_INT );
     CALL M$OPEN( FPT_OPEN_ME ) ALTRET( ARETO );
     DO WHILE ( '0'B );
ARETO:    CALL ERROR;
          CALL M$EXIT;
        END;
     PARAMB(0) = 0;
     CALL M$OPEN( FPT_OPEN ) ALTRET( ARETRYUP );
     DO WHILE ( '0'B );
ARETRYUP: PARAMB(0) = 0;
          IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOACCESS
          THEN GOTO ARETO;
          CALL M$OPEN( FPT_OPEN_READ ) ALTRET( ARETO );
        END;
     DO I = 0 TO ( SIZEW( FITCODES ) - 1 );
          FIT$ = ADDR( PARAMB );
          CODE = FITCODES( I );
          CALL XSF$LOCCODT( FIT$, CODE ) ALTRET( NOCODE );
          NOFIT = '0'B;
NOCODE:   ;
        END;
     IF NOT M$$JOB$ -> F$DCB.FFLG.DELR# OR
       NOT M$$JOB$ -> F$DCB.FFLG.WNEW# OR
       NOT M$$JOB$ -> F$DCB.FFLG.UPD#
     THEN CHANGE_REC = '0'B;
     IF NOT M$$JOB$ -> F$DCB.FFLG.DELF# OR NOT CHANGE_REC
     THEN ORIG_DELETE_REC = '0'B;
     DELETE_REC = ORIG_DELETE_REC;
     IF ( M$$JOB$ -> F$DCB.ASN# ~= %FILE# ) OR
       ( M$$JOB$ -> F$DCB.ORG# ~= %KEYED# )
     THEN CALL ERRXXX( ERR0_ );
     M$JS$ = DCBADDR( DCBNUM( M$JS ) );
     CALL M$OPEN( FPT_OPEN_JOBSTATS ) ALTRET( ARETOJ );
     DO WHILE ( '0'B );
ARETOJ:   CALL ERROR;
        END;
     FPT_PRIV.V.PRIV# = %PR_SPCLMM#;
     CALL M$SPRIV( FPT_PRIV ) ALTRET( NOPRIV0 );
     DO WHILE ( '0'B );
NOPRIV0:  FPT_PRIV.V.PRIV# = %PR_EXMM#;
          CALL M$SPRIV( FPT_PRIV ) ALTRET( NOPRIV1 );
        END;
     CAN_MAP = '1'B;
     CALL DAM$INIT;
     CALL M$TRAP( FPT_TRAP );
     REMEMBER KLUDGE IN A@TRAPUNWIND;
     DO WHILE ( '0'B );
KLUDGE:   CALL REPORT_KLUDGE ALTRET( KLUDGEA );
          DO CASE ( KLUDGE_FACTOR );
 
            CASE ( %KLUDGE1 );
               GOTO KLUDGE1;
 
            CASE ( %KLUDGE2 );
               GOTO KLUDGE2;
 
            CASE ( %KLUDGE3 );
               GOTO KLUDGE3;
 
            CASE ( %KLUDGE4 );
               GOTO KLUDGE4;
 
            CASE ( %KLUDGE5 );
               GOTO KLUDGE5;
 
            CASE ( ELSE );
KLUDGEA:       IF KLUDGE_FACTOR = %KLUDGE3
               THEN GOTO KLUDGE3;
               ELSE GOTO LWAIT_DONE;
KLUDGEB:    END;
        END;
NOPRIV1: ;
     FPT_PRIV.V.PRIV# = %PR_DISPJOB#;
     CALL M$SPRIV( FPT_PRIV ) ALTRET( NOPRIV2 );
NOPRIV2: ;
/* Read & process commands */
     IF SUBSTR( B$JIT.CCBUF, B$JIT.CCDISP, 1 ) = '('
     THEN DO;                           /* Something present in CCBUF */
          CMDSIZE = B$JIT.CCARS - B$JIT.CCDISP - 1; /* Get rid of "(" */
          IF SUBSTR( B$JIT.CCBUF, B$JIT.CCARS - 1, 1 ) = ')'
          THEN CMDSIZE = CMDSIZE - 1;   /* Get rid of ")" */
          CALL SET_FDS;
          IF CMDSIZE = 0
          THEN GOTO LGO0;
          CALL XUR$GETCMD( A@NODES, CMD$, PROMPT_,
            SUBSTR( B$JIT.CCBUF, B$JIT.CCDISP + 1 ),
            CMDSIZE, U$$ ) ALTRET( XURERRJ );
          ONECMD = '1'B;
          GOTO CMDGO0;
        END;                            /* Something present in CCBUF */
     DO WHILE( '1'B );
CMDLOOP:  ;
          CALL SET_FDS;
          IF ONECMD AND NOT READMORE
          THEN GOTO LGO0;
          CALL XUR$GETCMD( A@NODES, CMD$, PROMPT_, , , U$$ ) ALTRET( XURERR );
CMDGO0:   ;
          WAITING = '0'B;
          A@BREAK = '0'B;
          A@IMMED = '0'B;
          CMDNUM = CMD$ -> OUT$BLK.NSUBLKS - 1;
          DO I = 0 TO CMDNUM;
               EVERY = '0'B;
               OUT$ = CMD$ -> OUT$BLK.SUBLK$( I );
               DO CASE ( OUT$ -> OUT$BLK.CODE );
 
                 CASE ( %END@ );
                    CALL M$CLOSE( FPT_CLOSE );
                    CALL M$EXIT;
 
                 CASE ( %EVERY@ );
                    EVERY = '1'B;
                    GOTO LWAIT_WAIT;
 
                 CASE ( %WAIT@ );
LWAIT_WAIT:         ;
                    IF NOT CHANGE_REC
                    THEN GOTO ERROR7;
                    I = CMDNUM + 1;     /* Inhibit processing input */
                    READMORE = '1'B;
                    DO II = 0 TO OUT$ -> OUT$BLK.NSUBLKS - 1;
                         DO CASE ( OUT$ -> OUT$BLK.SUBLK$( II ) -> OUT$BLK.CODE );
 
                           CASE ( %WAIT_DONE@ );
                              WAIT_DONE = '1'B;
 
                           CASE ( %WAIT_PRINT@ );
                              WAIT_DONE = '0'B;
 
                           CASE ( %WAIT_DEC@ );
 
                              CALL CHARBIN( WAITINT, OUT$ -> OUT$BLK.SUBLK$( II ) -> OUT$SYM.TEXT );
                           END;
                       END;
                    FPT_WAIT.V.UNITS# = WAITINT;
                    WAITING = '1'B;
                    CALL FORCE_REPORT( %KLUDGE4 ) ALTRET( LWAIT_DONE );
KLUDGE4:            ;
                    DO WHILE ( '1'B );
                         IF A@BREAK
                         THEN GOTO CMDLOOP;
                         CALL M$WAIT( FPT_WAIT );
                         IF A@IMMED
                         THEN GOTO CMDLOOP;
                         IF A@BREAK
                         THEN DO;
                              A@BREAK = '0'B;
                              CALL FORCE_REPORT( %KLUDGE5 ) ALTRET( LWAIT_DONE );
KLUDGE5:                      ;
                            END;
                         ELSE CALL REPORT( %KLUDGE1 ) ALTRET( LWAIT_DONE );
KLUDGE1:                 ;
                       END;
LWAIT_DONE:         ;
                    IF DELETE_REC AND EMPTY AND NOFIT
                    THEN FPT_CLOSE.V.DISP# = %RELEASE#;
                    CALL M$CLOSE( FPT_CLOSE ) ALTRET( ARETC );
                    DO WHILE ( '0'B );
ARETC:                   CALL ERROR;
                       END;
                    CALL M$EXIT;
 
                 CASE ( %SYSID@ );
                    IF NOT CHANGE_REC
                    THEN GOTO ERROR5;
                    CALL GETSYSID;
 
                 CASE ( %GO@ );
LGO0:               CALL REPORT( %KLUDGE2 ) ALTRET( LWAIT_DONE );
KLUDGE2:            ;
                    CALL M$CLOSE( FPT_CLOSE );
                    CALL M$EXIT;
 
                 CASE ( %REPORT@ );
                    READMORE = '1'B;
                    CALL REPORT( %KLUDGE3 );
KLUDGE3:            ;
 
                 CASE ( %NDELETE@ );
                    DELETE_REC = '0'B;
 
                 CASE ( %DELETE@ );
                    DELETE_REC = ORIG_DELETE_REC;
 
                 CASE ( %CANCEL@ );
                    IF NOT CHANGE_REC
                    THEN GOTO ERROR5;
                    CALL GETSYSID;
                    FPT_JOBSTATS_CANCEL.V.SYSID# = SYSIDT;
                    CALL M$JOBSTATS( FPT_JOBSTATS_CANCEL ) ALTRET( ARETJC );
                    DO WHILE ( '0'B );
ARETJC:                  CALL ERROR;
                       END;
 
                 CASE ( %IBEX@ );
                    OUT1$ = OUT$ -> OUT$BLK.SUBLK$( 0 );
                    IF OUT1$ -> OUT$SYM.COUNT > 0
                    THEN FPT_YC.CMD_ = VECTOR( OUT1$ -> OUT$SYM.TEXT );
                    ELSE FPT_YC.CMD_ = VECTOR( NIL );
                    CALL M$YC( FPT_YC ) ALTRET( ARETYC );
                    DO WHILE ( '0'B );
ARETYC:                  CALL ERROR;
                       END;
 
                 CASE ( %BATCH@ );
                    CPOS = OUT$ -> OUT$BLK.CPOS;
                    CSIZ = OUT$ -> OUT$BLK.SCRITCH - CPOS;
                    FPT_YC.CMD_ = VECTOR( PINCRC( P_PCB.TEXT$, CPOS ) -> CHAR$STRING );
                    CALL M$YC( FPT_YC ) ALTRET( ARETYCB );
                    TESTING = '0'B;
                    DO II = 0 TO OUT$ -> OUT$BLK.NSUBLKS - 1;
                         DO CASE ( OUT$ -> OUT$BLK.SUBLK$( II ) -> OUT$BLK.CODE );
 
                           CASE ( %BATCHT@ );
                              TESTING = '1'B;
 
                           CASE ( %BATCHA@, %BATCHR@ );
 
                           CASE ( %BATCHX@ );
                              OUT1$ = OUT$ -> OUT$BLK.SUBLK$( II ) -> OUT$BLK.SUBLK$( 0 );
 
                           CASE ( ELSE ); /* FID to be batched */
                              OUT1$ = OUT$ -> OUT$BLK.SUBLK$( II );
                           END;
                       END;
                    IF NOT TESTING
                    THEN DO;
                         IF NOT CHANGE_REC
                         THEN GOTO ERROR6;
                         SYSIDT = B$JIT.LBJID;
                         KEYBUF.KSIZ = KEYSIZE;
                         KEYBUF.SYSID = SYSIDT;
                         KEYBUF.STATUS = '0'B;
                         KEYBUF.UNAME = B$JIT.UNAME;
                         KEYBUF.ACCN = B$JIT.ACCN;
                         LKEYBUF.SYSID = SYSIDT;
                         CALL M$DELREC( FPT_DELREC_RANGE ) ALTRET( ARETDRRB );
                         DO WHILE ( '0'B );
ARETDRRB:                     CALL ERROR;
                            END;
                         ARS = OUT1$ -> OUT$SYM.COUNT;
                         IF ARS > LENGTHC( BUFFER )
                         THEN ARS = LENGTHC( BUFFER );
                         FPT_WRITE.BUF_ = VECTOR( SUBSTR( OUT1$ -> OUT$SYM.TEXT, 0, ARS ) );
                         CALL M$WRITE( FPT_WRITE ) ALTRET( ARETWB );
                       END;
                    DO WHILE ( '0'B );
ARETYCB:                 ;
ARETWB:                  CALL ERROR;
                       END;
 
                 CASE ( %LINK@ );
                    VLP_ACCT_FID.ACCT# = ':SYS';
                    FPT_FID.TEXTFID_ = VECTOR( OUT$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.TEXT );
                    CALL M$FID( FPT_FID ) ALTRET( ARETLIF );
                    IF OUT$ -> OUT$BLK.NSUBLKS = 1
                    THEN FPT_LINK.CMD_ = VECTOR( OUT$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.TEXTC$ -> TEXT$C );
                    ELSE FPT_LINK.CMD_ = VECTOR( OUT$ -> OUT$BLK.SUBLK$( 1 ) -> OUT$SYM.TEXTC$ -> TEXT$C );
                    CALL M$LINK( FPT_LINK ) ALTRET( ARETLI );
                    DO WHILE ( '0'B );
ARETLIF:                 ;
ARETLI:                  CALL ERROR;
                       END;
 
                 CASE ( %LDTRC@ );
                    VLP_ACCT_FID.ACCT# = ':SYS';
                    FPT_FID.TEXTFID_ = VECTOR( OUT$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.TEXT );
                    CALL M$FID( FPT_FID ) ALTRET( ARETLDF );
                    IF OUT$ -> OUT$BLK.NSUBLKS = 1
                    THEN FPT_LDTRC.CMD_ = VECTOR( OUT$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.TEXTC$ -> TEXT$C );
                    ELSE FPT_LDTRC.CMD_ = VECTOR( OUT$ -> OUT$BLK.SUBLK$( 1 ) -> OUT$SYM.TEXTC$ -> TEXT$C );
                    CALL M$LDTRC( FPT_LDTRC ) ALTRET( ARETLD );
                    DO WHILE ( '0'B );
ARETLDF:                 ;
ARETLD:                  CALL ERROR;
                       END;
                 CASE ( %MINE@ );
                    MINE = '1'B;
                 CASE ( %ALL@ );
                    MINE = '0'B;
                 CASE ( %ACCOUNT@ );
                    CALL SRCH_ACCTS;
                 END;
               DO WHILE ( '0'B );
ERROR5:
                    DO WHILE ( '0'B );
ERROR6:                  CALL ERRINT( ERR6_ );
                       END;
                    DO WHILE ( '0'B );
ERROR7:                  CALL ERRINT( ERR7_ );
                       END;
                    CALL ERRINT( ERR5_ );
                  END;
             END;
          DO WHILE ( '0'B );
XURERR:        ;
               FROMJIT = '0'B;
               DO WHILE ( '0'B );
XURERRJ:            FROMJIT = '1'B;
                  END;
               ERRCODE = XERRCODE;
               IF ERRCODE.MON
               THEN IF ERRCODE.ERR# = %E$EOF
                    THEN GOTO LGO0;
                    ELSE CALL ERROR;
               ELSE IF ERRCODE.ERR# = %E$SYNERR
                    THEN DO;
                         IF FROMJIT
                         THEN CALL XUR$ECHO( DCBNUM( M$ME ) );
                         CALL XUR$ERRPTR( , DCBNUM( M$ME ) );
                       END;
                    ELSE CALL ERROR1;
             END;
        END;
%EJECT;
 
GETSYSID: PROC;
 
DCL TEMP UBIN;
DCL CANCEL_MSG BIT(1) ALIGNED;
DCL MY_OUTPUT BIT(1) ALIGNED;
 
     ARS = 0;
     CANCEL_MSG = '0'B;
     MY_OUTPUT = '0'B;
     SYSID$ = OUT$ -> OUT$BLK.SUBLK$( 0 );
     DO CASE ( SYSID$ -> OUT$BLK.CODE - %SYSID_DECIMAL@ );
 
       CASE ( %(%SYSID_NAME@ - %SYSID_DECIMAL@) );
          VLP_ACCT.ACCT# = B$JIT.ACCN;
          XSJ_NAMEKEY.ACCT# = VLP_ACCT.ACCT#;
          TEMP = SYSID$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.COUNT;
          IF TEMP > LENGTHC( VLP_JOBNAME.JOBNAME# )
          THEN GOTO GET_ERR2;
          VLP_JOBNAME.JOBNAME# = SYSID$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.TEXT;
          XSJ_NAMEKEY.JOBNAME# = VLP_JOBNAME.JOBNAME#;
          CALL CONCAT( BUFFER, 'NAME=', VLP_JOBNAME.JOBNAME# );
          ARS = TEMP + LENGTHC( 'NAME=' );
          IF SYSID$ -> OUT$BLK.NSUBLKS > 1
          THEN DO;                      /* Account specified */
               TEMP = SYSID$ -> OUT$BLK.SUBLK$( 1 ) -> OUT$SYM.COUNT;
               IF TEMP > LENGTHC( VLP_ACCT.ACCT# )
               THEN GOTO GET_ERR3;
               VLP_ACCT.ACCT# = SYSID$ -> OUT$BLK.SUBLK$( 1 ) -> OUT$SYM.TEXT;
               XSJ_NAMEKEY.ACCT# = VLP_ACCT.ACCT#;
               CALL INSERT( BUFFER, ARS, , '.', VLP_ACCT.ACCT# );
               ARS = ARS + TEMP + LENGTHC( '.' );
             END;
          FPT_JOBSTATS_CHECK.JOBNAME_ = VECTOR( VLP_JOBNAME );
          CALL M$JOBSTATS( FPT_JOBSTATS_CHECK ) ALTRET( ARETJN );
          FPT_JOBSTATS_CHECK.JOBNAME_ = VECTOR( NIL );
          SYSIDT = VLR_JOBSTATS_CHECK.SYSID;
          IF VLR_JOBSTATS_CHECK.CODE = %JS_NOTF#
          THEN DO;
               IF M$JS$ -> M$JS.FCD#
               THEN DO;                 /* Read :JOBSTATS file */
                    CALL M$READ( FPT_READ_JOBNAME ) ALTRET( ARETRJN );
                    SYSIDT = XSJ_NAMEREC.SYSID#;
                    GOTO GOTSYSID;
ARETRJN:            IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOKEY
                    THEN CALL ERROR;
                  END;
               NERRVEC_ = VECTOR( SYSID$ -> OUT$BLK.SUBLK$( 0 ) -> OUT$SYM.TEXT );
               IF SYSID$ -> OUT$BLK.NSUBLKS > 1
               THEN DO;
                    NAERRVEC_ = VECTOR( SYSID$ -> OUT$BLK.SUBLK$( 1 ) -> OUT$SYM.TEXT );
                    CALL X$WRITE( F_FDS, JNAERR_, NERRVEC_, NAERRVEC_ );
                  END;
               ELSE CALL X$WRITE( F_FDS, JNERR_, NERRVEC_ );
               CALL RING_BELL;
               GOTO RETN;
             END;
 
       CASE ( %(%SYSID_ME@ - %SYSID_DECIMAL@) );
          SYSIDT = B$JIT.SYSID;
          MY_OUTPUT = '1'B;
 
       CASE ( %(%SYSID_LAST@ - %SYSID_DECIMAL@) );
          SYSIDT = B$JIT.LBJID;
          IF SYSIDT = 0
          THEN GOTO GET_ERR9;
 
       CASE ( %(%SYSID_DECIMAL@ - %SYSID_DECIMAL@) );
          IF SYSID$ -> OUT$SYM.COUNT > LENGTHC( '262143' )
          THEN GOTO GET_ERR1;
          CALL CHARBIN( SYSIDT, SYSID$ -> OUT$SYM.TEXT );
          IF SYSIDT > 262143
          THEN GOTO GET_ERR1;
       END;
GOTSYSID: ;
     KEYBUF.KSIZ = KEYSIZE;
     KEYBUF.SYSID = SYSIDT;
     KEYBUF.STATUS = '0'B;
     KEYBUF.UNAME = B$JIT.UNAME;
     KEYBUF.ACCN = B$JIT.ACCN;
     LKEYBUF.SYSID = SYSIDT;
     IF OUT$ -> OUT$BLK.CODE = %CANCEL@
     THEN DO;                           /* Get previous message */
          CALL M$PRECORD( FPT_PRECORD_CANCEL ) ALTRET( ARETPRC );
ARETPRC:
          CALL M$READ( FPT_READ_CANCEL ) ALTRET( ARETRCA );
          DO WHILE( '0'B );
ARETRCA:       IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$EOF
               THEN CALL ERROR;
               KEYBUF.KSIZ = 0;
             END;
          IF KEYBUF.KSIZ = KEYSIZE
            AND ( KEYBUF.SYSID = SYSIDT )
          THEN DO;
               TEMP = M$$JOB$ -> F$DCB.ARS#;
               IF TEMP > 0
               THEN CANCEL_MSG = '1'B;
               CALL M$DELREC( FPT_DELREC_RANGE ) ALTRET( ARETDRRC );
               DO WHILE ( '0'B );
ARETDRRC:           CALL ERROR;
                  END;
             END;
          ELSE DO;
               KEYBUF.KSIZ = KEYSIZE;
               KEYBUF.SYSID = SYSIDT;
             END;
          KEYBUF.STATUS = '0'B;
        END;
     ELSE DO;
          CALL M$DELREC( FPT_DELREC_RANGE ) ALTRET( ARETDRR );
          DO WHILE ( '0'B );
ARETDRR:       CALL ERROR;
             END;
        END;
     OUT1$ = OUT$ -> OUT$BLK.SUBLK$( 1 );
     IF OUT$ -> OUT$BLK.NSUBLKS > 1
     THEN DO;
          IF ARS > 0
          THEN ARS = ARS + 1;
          CALL INSERT( BUFFER, ARS, , OUT1$ -> OUT$SYM.TEXT ) ALTRET( OVFL );
          ARS = ARS + OUT1$ -> OUT$SYM.COUNT;
        END;
     ELSE IF CANCEL_MSG
          THEN DO;
               BUFFER = FDS_BUFFER;
               ARS = TEMP;
             END;
          ELSE IF MY_OUTPUT
               THEN DO CASE ( B$JIT.MODE );
 
                 CASE ( %M_INT# );
                    BUFFER = %INTMSG@;
                    ARS = LENGTHC( %INTMSG@ );
 
                 CASE ( %M_BATCH# );
                    BUFFER = %BATCHMSG@;
                    ARS = LENGTHC( %BATCHMSG@ );
 
                 CASE ( %M_GHOST# );
                    BUFFER = %GHOSTMSG@;
                    ARS = LENGTHC( %GHOSTMSG@ );
 
                 CASE ( %M_TP# );
                    BUFFER = %TPMSG@;
                    ARS = LENGTHC( %TPMSG@ );
                 END;
     DO WHILE ( '0'B );
OVFL:     ARS = LENGTHC( BUFFER );
        END;
     IF ARS > 0
     THEN FPT_WRITE.BUF_ = VECTOR( BUFF$ER );
     ELSE FPT_WRITE.BUF_ = VECTOR( NIL );
     CALL M$WRITE( FPT_WRITE ) ALTRET( ARETW );
 
     GOTO RETN;
 
GET_ERR1: ;
     CALL ERRINT( ERR1_ );
     GOTO RETN;
 
GET_ERR2: ;
     CALL ERRINT( ERR2_ );
     GOTO RETN;
 
GET_ERR3: ;
     CALL ERRINT( ERR3_ );
     GOTO RETN;
GET_ERR9: ;
     CALL ERRINT( ERR9_ );
     GOTO RETN;
 
ARETJN: ;
     FPT_JOBSTATS_CHECK.JOBNAME_ = VECTOR( NIL );
ARETW: ;
     CALL ERROR;
     GOTO RETN;
 
RETN: ;
     RETURN;
 
END GETSYSID;
%EJECT;
 
SRCH_ACCTS: PROC;
 
DCL I SBIN;
DCL Q$ PTR;
DCL 1 SKIP_BLANK_TABLE  STATIC,
      2 *      CHAR(32)  UNAL INIT( ' ' ),
      2 BLANK  BIT(9)    UNAL INIT( '000'O ),
      2 *      CHAR(95)  UNAL INIT( ' ' );
DCL TABLEVAL   UBIN;
DCL TEMP UBIN;
 
     IF OUT$ -> OUT$BLK.NSUBLKS < 1
     THEN VLP_CRITERIA_ACCT.ACCT# = B$JIT.ACCN;
     ELSE DO;
          SYSID$ = OUT$ -> OUT$BLK.SUBLK$( 0 );
          TEMP = SYSID$ -> OUT$SYM.COUNT;
          IF TEMP > LENGTHC( VLP_CRITERIA_ACCT.ACCT# )
          THEN GOTO GET_ERR8;
          VLP_CRITERIA_ACCT.ACCT# = SYSID$ -> OUT$SYM.TEXT;
        END;
     SRCH_GDS_RESULTS = VECTOR( NIL );
GET_SRCH_SEGMENT:
     CALL M$GDS( GET_SRCH_SEG )  ALTRET( ARETGDSI );
     DO WHILE('0'B);
ARETGDSI:
          CALL ERROR;
        END;
     FPT_ISRCH_ACCT.RESULTS_ = SRCH_GDS_RESULTS;
     CALL M$JOBSTATS( FPT_ISRCH_ACCT ) ALTRET( ARETJS );
     DO WHILE('0'B);
ARETJS:
          IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOTFND
          THEN IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$JSIRAS
               THEN GOTO GET_SRCH_SEGMENT;
               ELSE CALL ERROR;
        END;
     Q$ = PINCRW( SRCH_GDS_RESULTS.PTR$ , 2 ); /* = ADDR(VLR_ISRCH_ACCT.J(0)) */
     DO I = 0 TO SRCH_GDS_RESULTS.PTR$ -> VLR_ISRCH_ACCT.FOUND - 1;
          KEYBUF.KSIZ = KEYSIZE;
          SYSIDT = Q$ -> IQ.SYSID;
          KEYBUF.SYSID = SYSIDT;
          KEYBUF.STATUS = '0'B;
          KEYBUF.UNAME  = B$JIT.UNAME;
          KEYBUF.ACCN   = B$JIT.ACCN;
          LKEYBUF.SYSID = SYSIDT;
          CALL M$PRECORD( FPT_PRECORD_ACCOUNT ) ALTRET( ARETPRC );
          DO WHILE('0'B);
ARETPRC:
               IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOKEY
               THEN CALL ERROR;
               IF KEYBUF.SYSID = SYSIDT
               THEN IF KEYBUF.STATUS = '0'B
                    THEN KEYBUF.KSIZ = 0;
                    ELSE ;
               ELSE KEYBUF.KSIZ = 0;
             END;
          IF KEYBUF.KSIZ = 0       /* No record for SYSID exists; build one   */
          THEN DO;
               IF Q$ -> IQ.JNAME = ' '  /* If no JOBNAME, insert ACCT as  */
                                        /* a comment                      */
               THEN IF Q$ -> IQ.ACCT ~= B$JIT.ACCN
                    THEN DO;
                         BUFFER = 'ACCT=';
                         ARS = LENGTHC( 'ACCT=' );
                       END;
                    ELSE ARS = 0;
               ELSE DO;            /* Else insert JOBNAME.ACCOUNT           */
                    CALL CONCAT(BUFFER, 'NAME=', Q$ -> IQ.JNAME);
                    TEMP = LENGTHC( 'NAME=' ) + LENGTHC( Q$ -> IQ.JNAME );
                    CALL SEARCHR(ARS, TABLEVAL, SKIP_BLANK_TABLE,
                      SUBSTR(BUFFER,0,TEMP));
                    IF Q$ -> IQ.ACCT ~= B$JIT.ACCN
                    THEN DO;
                         CALL INSERT(BUFFER, ARS+1, 1, '.');
                         ARS = ARS + 2; /* Point past the period */
                       END;
                    ELSE ARS = ARS + 1; /* Make displacement a length */
                  END;
               IF Q$ -> IQ.ACCT ~= B$JIT.ACCN
               THEN DO;
                    TEMP = LENGTHC( Q$ -> IQ.ACCT );
                    CALL INSERT(BUFFER, ARS, TEMP, Q$ -> IQ.ACCT);
                    TEMP = TEMP + ARS;
                    CALL SEARCHR(ARS, TABLEVAL, SKIP_BLANK_TABLE,
                      SUBSTR(BUFFER,0,TEMP));
                    ARS = ARS + 1;      /* Make displacement a length */
                  END;
               SYSIDT = Q$ -> IQ.SYSID;
               KEYBUF.KSIZ = KEYSIZE;
               KEYBUF.SYSID = SYSIDT;
               KEYBUF.STATUS = '0'B;
               KEYBUF.UNAME  = B$JIT.UNAME;
               KEYBUF.ACCN   = B$JIT.ACCN;
               IF ARS > 0
               THEN FPT_WRITE.BUF_ = VECTOR( BUFF$ER );
               ELSE FPT_WRITE.BUF_ = VECTOR( NIL );
               CALL M$WRITE( FPT_WRITE ) ALTRET( ARETW );
             END;
          Q$ = PINCRW( Q$, SIZEW(Q$->IQ) );/* = ADDR( VLR_ISRCH_ACCT.J(I+1) ) */
        END;
 
     DO WHILE('0'B);
GET_OSRCH_SEGMENT:
          CALL M$GDS( GET_SRCH_SEG )  ALTRET( ARETGDSO );
          DO WHILE('0'B);
ARETGDSO:
               CALL ERROR;
             END;
        END;
     FPT_OSRCH_ACCT.RESULTS_ = SRCH_GDS_RESULTS;
     CALL M$JOBSTATS( FPT_OSRCH_ACCT ) ALTRET( ARETJSO );
     DO WHILE('0'B);
ARETJSO:
          IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOTFND
          THEN IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$JSIRAS
               THEN GOTO GET_OSRCH_SEGMENT;
               ELSE CALL ERROR;
        END;
     Q$ = PINCRW( SRCH_GDS_RESULTS.PTR$ , 2 ); /* = ADDR(VLR_OSRCH_ACCT.F(0)) */
     DO I = 0 TO SRCH_GDS_RESULTS.PTR$ -> VLR_OSRCH_ACCT.FOUND - 1;
          KEYBUF.KSIZ = KEYSIZE;
          SYSIDT = Q$ -> OQ.SYSID;
          KEYBUF.SYSID = SYSIDT;
          KEYBUF.STATUS = '0'B;
          KEYBUF.UNAME  = B$JIT.UNAME;
          KEYBUF.ACCN   = B$JIT.ACCN;
          LKEYBUF.SYSID = SYSIDT;
          CALL M$PRECORD( FPT_PRECORD_ACCOUNT ) ALTRET( ARETPRCO );
          DO WHILE('0'B);
ARETPRCO:
               IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOKEY
               THEN CALL ERROR;
               IF KEYBUF.SYSID = SYSIDT
               THEN IF KEYBUF.STATUS = '0'B
                    THEN KEYBUF.KSIZ = 0;
                    ELSE ;
               ELSE KEYBUF.KSIZ = 0;
             END;
          IF KEYBUF.KSIZ = 0       /* No record for SYSID exists; build one   */
          THEN DO;
               IF Q$ -> OQ.JNAME = ' '  /* If no JOBNAME, insert ACCT as  */
                                        /* a comment                      */
               THEN IF Q$ -> OQ.ACCT ~= B$JIT.ACCN
                    THEN DO;
                         BUFFER = 'ACCT=';
                         ARS = LENGTHC( 'ACCT=' );
                       END;
                    ELSE ARS = 0;
               ELSE DO;            /* Else insert JOBNAME.ACCOUNT           */
                    CALL CONCAT(BUFFER, 'NAME=', Q$ -> OQ.JNAME);
                    TEMP = LENGTHC( 'NAME=' ) + LENGTHC( Q$ -> OQ.JNAME );
                    CALL SEARCHR(ARS, TABLEVAL, SKIP_BLANK_TABLE,
                      SUBSTR(BUFFER,0,TEMP));
                    IF Q$ -> OQ.ACCT ~= B$JIT.ACCN
                    THEN DO;
                         CALL INSERT(BUFFER, ARS+1, 1, '.');
                         ARS = ARS + 2; /* Point past the period */
                       END;
                    ELSE ARS = ARS + 2; /* Make displacement a length */
                  END;
               IF Q$ -> OQ.ACCT ~= B$JIT.ACCN
               THEN DO;
                    TEMP = LENGTHC( Q$ -> OQ.ACCT );
                    CALL INSERT(BUFFER, ARS, TEMP, Q$ -> OQ.ACCT);
                    TEMP = TEMP + ARS;
                    CALL SEARCHR(ARS, TABLEVAL, SKIP_BLANK_TABLE,
                      SUBSTR(BUFFER,0,TEMP));
                    ARS = ARS + 1;      /* Make displacement a length */
                  END;
               SYSIDT = Q$ -> OQ.SYSID;
               KEYBUF.KSIZ = KEYSIZE;
               KEYBUF.SYSID = SYSIDT;
               KEYBUF.STATUS = '0'B;
               KEYBUF.UNAME  = B$JIT.UNAME;
               KEYBUF.ACCN   = B$JIT.ACCN;
               IF ARS > 0
               THEN FPT_WRITE.BUF_ = VECTOR( BUFF$ER );
               ELSE FPT_WRITE.BUF_ = VECTOR( NIL );
               CALL M$WRITE( FPT_WRITE ) ALTRET( ARETW );
             END;
          Q$ = PINCRW( Q$, SIZEW(VLR_OSRCH_ACCT.F(0)) );/* = ADDR( VLR_OSRCH_ACCT.F(I+1) ) */
        END;
     GOTO RETN;
 
ARETW: ;
     CALL ERROR;
     GOTO RETN;
 
GET_ERR8: ;
     CALL ERRINT( ERR8_ );              /* Specified ACCOUNT is too big */
 
RETN: ;
     IF SRCH_GDS_RESULTS.W1.VSIZE# > 0
     THEN DO;       /* Release segment(s) acquired for JOBSTATS results area */
          REL_SRCH_SEG.V.SEGSIZE# = (SRCH_GDS_RESULTS.W1.VSIZE# + 1) / 4;
          CALL M$FDS( REL_SRCH_SEG )  ALTRET( ARETFDS );
          DO WHILE('0'B);
ARETFDS:
               CALL ERROR;
             END;
        END;
     RETURN;
 
END SRCH_ACCTS;
%EJECT;
REPORT: PROC( KLUDGE_PARM ) ALTRET;
 
DCL KLUDGE_PARM UBIN;
DCL READ UBIN STATIC;
DCL DELE UBIN STATIC;
DCL COUN UBIN STATIC;
DCL CHANGES BIT(1) STATIC ALIGNED;
DCL FORCE BIT(1) STATIC ALIGNED;
DCL USER_DELETE BIT(1) STATIC ALIGNED;
 
     KLUDGE_FACTOR = KLUDGE_PARM;
     FORCE = '0'B;
     GOTO REPORT0;
 
FORCE_REPORT: ENTRY( KLUDGE_PARM ) ALTRET;
 
     KLUDGE_FACTOR = KLUDGE_PARM;
     FORCE = '1'B;
     GOTO REPORT0;
 
REPORT_KLUDGE: ENTRY ALTRET;
     GOTO MAPERR;
 
REPORT0: ;
/* Report on SYSIDs in file */
     READ = 0;
     DELE = 0;
     COUN = 0;
     EMPTY = '0'B;
     CHANGES = '0'B;
     CALL M$PFIL( FPT_PFIL );
     DO WHILE( '1'B );
READAGAIN: ;
          USER_DELETE = '0'B;
          CALL M$READ( FPT_READ ) ALTRET( ARETR );
          READ = READ + 1;
          IF A@BREAK
          THEN RETURN;
          IF KEYBUF.KSIZ ~= KEYSIZE
          THEN DO;
               CALL ERRINT( ERR4_ );
               CALL M$EXIT;
             END;
          IF KEYBUF.UNAME = B$JIT.UNAME AND KEYBUF.ACCN = B$JIT.ACCN
          THEN USER_DELETE = '1'B;
          IF MINE AND NOT USER_DELETE
          THEN DO;
               DELE = DELE + 1;         /* Treat not mine as not found */
               GOTO READAGAIN;
             END;
          FPT_JOBSTATS_CHECK.V.SYSID# = KEYBUF.SYSID;
          ARS = M$$JOB$ -> F$DCB.ARS#;
          IF ARS = 0
          THEN DO;
               BUFFR = 0;
               BUFF_ = VECTOR( NIL );
             END;
          ELSE DO;
               BUFFR = 1;
               BUFF_ = VECTOR( BUFF$ER );
             END;
STATUS_CHANGED: ;
          CALL M$JOBSTATS( FPT_JOBSTATS_CHECK ) ALTRET( ARETJ );
          DO WHILE( '0'B );
ARETJ:         CALL ERROR;
               CALL M$EXIT;
             END;
          OLDSTATUS = KEYBUF.STATUS;
          KEYBUF.STATUS = '0'B;
          KEYBUF.STATUS.CODE = VLR_JOBSTATS_CHECK.CODE;
          CODETEXT_ = ARRAY__( VLR_JOBSTATS_CHECK.CODE -1 );
          IF ( VLR_JOBSTATS_CHECK.CODE = %JS_PWAIT# ) AND
            ( NOT VLR_JOBSTATS_CHECK.DEVAVAIL )
          THEN CODETEXT_ = PRTNODEV_;
          CODETEXT1_ = CODETEXT_;
          DO CASE ( VLR_JOBSTATS_CHECK.CODE );
 
            CASE ( %JS_WAIT# );
               KEYBUF.STATUS.PRIO = VLR_JOBSTATS_CHECK.PRIO;
               IF ( VLR_JOBSTATS_CHECK.PRIO <= 15 )
               THEN KEYBUF.STATUS.TORUN = VLR_JOBSTATS_CHECK.AHEAD;
               VLP_CRITERIA.SYSID# = FPT_JOBSTATS_CHECK.V.SYSID#;
               VLP_CRITERIA.SYSID1# = FPT_JOBSTATS_CHECK.V.SYSID#;
               IF VLR_JOBSTATS_CHECK.PRIO = %JP_RUNAFTER#
               THEN DELE = DELE + 1;    /* Don't wait for deferred jobs */
               IF ( FORCE ) OR ( NOT WAITING ) OR
                 ( WAITING AND KEYBUF.STATUS ~= OLDSTATUS )
               THEN DO CASE ( VLR_JOBSTATS_CHECK.PRIO );
 
                 CASE ( %JP_FOLL# );
                    CALL M$JOBSTATS( FPT_JOBSTATS_SRCH ) ALTRET( ARETJSSF );
                    IF NOT VLA$JOBSTATS_ISRCH.FLG.O3
                    THEN GOTO STATUS_CHANGED;
                    NFOLL = VLA$JOBSTATS_ISRCH.NFOLL - 1;
                    DO II = 0 TO NFOLL;
                         S( II ) = VLA$JOBSTATS_ISRCH.JDID.SYSID( II );
                         S__( II ) = VECTOR( S( II ) );
                       END;
                    DO II = NFOLL+1 TO 7;
                         S__( II ) = VECTOR( NIL );
                       END;
                    CALL X$WRITE( F_FDS, FMTVEC6_, SYSID_, S__(0), NFOLL_,
                      S__(1), S__(2), S__(3), S__(4), S__(5),
                      S__(6), S__(7), BUFF_ );
                    DO WHILE ( '0'B );
ARETJSSF:                CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, FOLLOW_, BUFF_ );
                       END;
 
                 CASE ( %JP_RUNAFTER# );
                    CALL M$JOBSTATS( FPT_JOBSTATS_SRCH ) ALTRET( ARETJSSR );
                    IF NOT VLA$JOBSTATS_ISRCH.FLG.RA
                    THEN GOTO STATUS_CHANGED;
                    TSTAMP = VLA$JOBSTATS_ISRCH.RATIM;
                    CALL M$TIME( FPT_TIME_TSTAMP ) ALTRET( ARETTR );
                    DO WHILE ( '0'B );
ARETTR:                  CALL ERROR;
                       END;
                    CALL X$WRITE( F_FDS, FMTVEC7_, SYSID_, HHMM_, MODD_, BUFF_ );
                    DO WHILE ( '0'B );
ARETJSSR:                CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, AFTER_, BUFF_ );
                       END;
 
                 CASE ( %JP_WPART# );
                    CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, NONE_, BUFF_ );
 
                 CASE ( %JP_OTHER# );
                    CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, OTHER_, BUFF_ );
 
                 CASE ( %JP_WPS# );
                    CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, WPS_, BUFF_ );
 
                 CASE ( ELSE );
                    CALL X$WRITE( F_FDS, FMTVEC1_, SYSID_, CODETEXT_,
                      AHEAD_, PRIO_, BUFF_ );
                 END;
 
            CASE ( ELSE );    /* JS_PRT#, JS_NOTF#, JS_PWAIT#, JS_SPILLED# */
               IF ( VLR_JOBSTATS_CHECK.CODE ~= %JS_NOTF# ) AND
                 ( NOT WAIT_DONE )
               THEN DELE = DELE + 1;    /* Wait until printing */
               IF ( FORCE ) OR ( NOT WAITING ) OR
                 ( WAITING AND KEYBUF.STATUS ~= OLDSTATUS )
               THEN IF M$JS$ -> M$JS.FCD#
                    THEN DO;            /* Read :JOBSTATS file */
                         XSJ_INFOKEY.SYSID# = FPT_JOBSTATS_CHECK.V.SYSID#;
                         CALL M$READ( FPT_READ_JOBINFO ) ALTRET( ARETRJI );
                         STEPCC = XSJ_JOBINFO.STEPCC#;
                         STEPCC_ = VECTOR( NIL );
                         DO CASE ( XSJ_JOBINFO.STATUS# );
 
                           CASE ( %MBS_DELETED# );
                              CODETEXT_ = MBS_DELETED_;
 
                           CASE ( %MBS_CANCELED# );
                              CODETEXT_ = MBS_CANCELED_;
 
                           CASE ( %MBS_SHAFTED# );
                              CODETEXT_ = MBS_SHAFTED_;
 
                           CASE ( %PRE_PASSED# );
                              CODETEXT_ = PRE_PASSED_;
 
                           CASE ( %MBS_FILERR# );
                              CODETEXT_ = MBS_FILERR_;
 
                           CASE ( %REJ_JOB# );
                              CODETEXT_ = REJ_JOB_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_RES# );
                              CODETEXT_ = REJ_RES_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_SYNTAX# );
                              CODETEXT_ = REJ_SYNTAX_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_IO# );
                              CODETEXT_ = REJ_IO_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_JOBIMBED# );
                              CODETEXT_ = REJ_JOBIMBED_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_BADID# );
                              CODETEXT_ = REJ_BADID_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_NORES# );
                              CODETEXT_ = REJ_NORES_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_PRESCAN# );
                              CODETEXT_ = REJ_PRESCAN_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_RESIMBED# );
                              CODETEXT_ = REJ_RESIMBED_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %REJ_NOBATCH# );
                              CODETEXT_ = REJ_NOBATCH_;
                              GOTO REJECTED_MSG;
 
                           CASE ( %FIN_RECOVER# );
                              CODETEXT_ = FIN_RECOVER_;
 
                           CASE ( %FIN_ABNORMAL# );
                              IF XSJ_JOBINFO.FRS# = %RS_CAN# THEN
                                   CODETEXT_ = RS_CAN_;
                              ELSE DO;
                                   START = 0;
                                   CALL GETBIT(XSJ_JOBINFO.FRS#,START) ALTRET(NOFRS);
                                   CODETEXT_ = RS__( BITSET );
                                   IF CODETEXT_ = VECTOR(RS_LIMX) THEN
                                        GOTO LIMIT_MSG;
                                 END;
 
                           CASE ( %FIN_COMPLETED# );
                              CODETEXT_ = FIN_COMPLETED_;
                              IF STEPCC ~= 0
                              THEN STEPCC_ = VECTOR( STEPCC );
                           END;
 
                         DO WHILE ( '0'B );
NOFRS:                        CODETEXT_ = FIN_ABNORMAL_;
                              IF STEPCC ~= 0
                              THEN STEPCC_ = VECTOR( STEPCC );
                            END;
 
SIMPLE_MSG:              ;
                         DO CASE ( VLR_JOBSTATS_CHECK.CODE );
 
                           CASE ( %JS_PRT# );
                              IF STEPCC_ = VECTOR( NIL )
                              THEN CALL X$WRITE( F_FDS, FMTVEC8_, SYSID_, CODETEXT1_, LPXX_, TWSN_, CODETEXT_, BUFF_ );
                              ELSE CALL X$WRITE( F_FDS, FMTVEC12_, SYSID_, CODETEXT1_, LPXX_, TWSN_, CODETEXT_, STEPCC_, BUFF_ );
 
                           CASE ( %JS_PWAIT#, %JS_SPILLED# );
                              IF STEPCC_ = VECTOR( NIL )
                              THEN CALL X$WRITE( F_FDS, FMTVEC9_, SYSID_, CODETEXT1_, CODETEXT_, BUFF_ );
                              ELSE CALL X$WRITE( F_FDS, FMTVEC13_, SYSID_, CODETEXT1_, CODETEXT_, STEPCC_, BUFF_ );
 
                           CASE ( ELSE );
                              IF STEPCC_ = VECTOR( NIL )
                              THEN CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, CODETEXT_, BUFF_ );
                              ELSE CALL X$WRITE( F_FDS, FMTVEC14_, SYSID_, CODETEXT_, STEPCC_, BUFF_ );
                           END;
 
                         DO WHILE ( '0'B );
REJECTED_MSG:                 ;
                              CALL X$WRITE( F_FDS, FMTVEC3_, SYSID_, RECNO_, CODETEXT_, BUFF_ );
                            END;
 
                         DO WHILE ( '0'B );
LIMIT_MSG:                    DO CASE ( VLR_JOBSTATS_CHECK.CODE );
 
                                CASE ( %JS_PRT# );
                                   LIMIT_VEC_(0) = SYSID_;
                                   LIMIT_VEC_(1) = CODETEXT1_;
                                   LIMIT_VEC_(2) = LPXX_;
                                   LIMIT_VEC_(3) = TWSN_;
                                   I = 4;
                                   LIMIT_BUF = LIMIT_FMT1;
                                   CHR_POS = SIZEC(LIMIT_FMT1);
                                   CALL SETUP_LIMIT_VECTOR(XSJ_JOBINFO.XLIMFLG#,4);
                                   SUBSTR(LIMIT_BUF,CHR_POS) = LIMIT_END1;
                                   LIMIT_VEC_(I) = BUFF_;
                                   LIM_FDS.NVECS# = I + 1;
                                   LIM_FDS.FMT_ = VECTOR(LIMIT_BUF);
                                   CALL X$FORMAT(LIM_FDS);
 
                                CASE ( %JS_PWAIT#, %JS_SPILLED# );
                                   LIMIT_VEC_(0) = SYSID_;
                                   LIMIT_VEC_(1) = CODETEXT1_;
                                   I = 2;
                                   LIMIT_BUF = LIMIT_FMT2;
                                   CHR_POS = SIZEC(LIMIT_FMT2);
                                   CALL SETUP_LIMIT_VECTOR(XSJ_JOBINFO.XLIMFLG#,2);
                                   SUBSTR(LIMIT_BUF,CHR_POS) = LIMIT_END2;
                                   LIMIT_VEC_(I) = BUFF_;
                                   LIM_FDS.NVECS# = I + 1;
                                   LIM_FDS.FMT_ = VECTOR(LIMIT_BUF);
                                   CALL X$FORMAT(LIM_FDS);
 
                                CASE ( ELSE );
                                   LIMIT_VEC_(0) = SYSID_;
                                   I = 1;
                                   LIMIT_BUF = LIMIT_FMT3;
                                   CHR_POS = SIZEC(LIMIT_FMT3);
                                   CALL SETUP_LIMIT_VECTOR(XSJ_JOBINFO.XLIMFLG#,1);
                                   SUBSTR(LIMIT_BUF,CHR_POS) = LIMIT_END3;
                                   LIMIT_VEC_(I) = BUFF_;
                                   LIM_FDS.NVECS# = I + 1;
                                   LIM_FDS.FMT_ = VECTOR(LIMIT_BUF);
                                   CALL X$FORMAT(LIM_FDS);
                                END;
                            END;
                       END;
                    ELSE DO;            /* Can't access :JOBSTATS file */
                         DO WHILE ( '0'B );
ARETRJI:                      IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOKEY
                              THEN CALL ERROR;
                            END;
                         IF VLR_JOBSTATS_CHECK.CODE = %JS_PRT#
                         THEN CALL X$WRITE( F_FDS, FMTVEC2_, SYSID_, CODETEXT_, LPXX_, TWSN_, BUFF_ );
                         ELSE CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, CODETEXT_, BUFF_ );
                       END;
               IF VLR_JOBSTATS_CHECK.CODE = %JS_NOTF#
               THEN DO;
                    DELE = DELE + 1;
                    IF CHANGE_REC
                    THEN DO;
                         IF DELETE_REC AND USER_DELETE
                         THEN DO;
                              IF KEYBUF.STATUS ~= OLDSTATUS
                              THEN CHANGES = '1'B;
                              CALL M$DELREC( FPT_DELREC ) ALTRET( ARETD );
                              COUN = COUN + 1; /* Actually deleted */
                            END;
                         ELSE IF KEYBUF.STATUS ~= OLDSTATUS
                              THEN DO;
                                   CHANGES = '1'B;
                                   CALL M$DELREC( FPT_DELREC ) ALTRET( ARETD );
                                   IF ARS ~= 0
                                   THEN FPT_WRITE.BUF_ = VECTOR( BUFF$ER );
                                   ELSE FPT_WRITE.BUF_ = VECTOR( NIL );
                                   CALL M$WRITE( FPT_WRITE ) ALTRET( ARETD );
                                 END;
                       END;
                    DO WHILE ( '0'B );
ARETD:                   CALL ERROR;
                       END;
                  END;
 
            CASE ( %JS_RUN# );
               IF ( FORCE ) OR ( NOT WAITING ) OR
                 ( WAITING AND ( ( KEYBUF.STATUS ~= OLDSTATUS ) OR ( EVERY ) ) )
               THEN DO;
                    IF CAN_MAP
                    THEN DO;
                         A@TRAP = '1'B;
                         CALL DAM$MAP( B$JIT$, JIT$, FPT_JOBSTATS_CHECK.V.SYSID#, %USERWSR ) ALTRET( MAPERR );
                         SECU = ( JIT$->B$JIT.TPEXT + JIT$->B$JIT.TPSVT
                           + JIT$->B$JIT.TUEXT + JIT$->B$JIT.TUSVT
                           + 50 ) / 100;
                         MINU = SECU / 60;
                         SECU = MOD( SECU, 60 );
                         SECR = ( JIT$->B$JIT.MRT + 50 ) / 100;
                         MINR = SECR / 60;
                         SECR = MOD( SECR, 60 );
                         ACCN_ = VECTOR( JIT$->B$JIT.ACCN );
                         UNAME_ = VECTOR( JIT$->B$JIT.UNAME );
                         IF JIT$->B$JIT.CCARS = 0
                         THEN CCBUF_ = VECTOR( NIL );
                         ELSE CCBUF_ = VECTOR( SUBSTR( JIT$->B$JIT.CCBUF, 0, JIT$->B$JIT.CCARS ) );
                         CALL X$WRITE( F_FDS, FMTVEC5_, SYSID_, ACCN_, UNAME_, MINU_, SECU_, MINR_, SECR_, CCBUF_ );
                         A@TRAP = '0'B;
                       END;
                    ELSE
MAPERR:             DO;
                         A@TRAP = '0'B;
                         CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, CODETEXT_, BUFF_ );
                       END;
                  END;
 
            CASE ( %JS_AP# );
               IF ( FORCE ) OR ( NOT WAITING ) OR
                 ( WAITING AND KEYBUF.STATUS ~= OLDSTATUS )
               THEN CALL X$WRITE( F_FDS, FMTVEC_, SYSID_, CODETEXT_, BUFF_ );
            END;
          IF ( KEYBUF.STATUS ~= OLDSTATUS ) AND
            ( KEYBUF.STATUS.CODE ~= %JS_NOTF# ) AND
            ( CHANGE_REC )
          THEN DO;
               CHANGES = '1'B;
               CALL M$DELREC( FPT_DELREC ) ALTRET( ARETDC );
               IF ARS ~= 0
               THEN FPT_WRITE.BUF_ = VECTOR( BUFF$ER );
               ELSE FPT_WRITE.BUF_ = VECTOR( NIL );
               CALL M$WRITE( FPT_WRITE ) ALTRET( ARETW );
               DO WHILE ( '0'B );
ARETDC:             ;
ARETW:              ;
                    CALL ERROR;
                  END;
             END;
        END;
 
ARETR: ;
     IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$EOF
     THEN DO;
          CALL ERROR;
          CALL M$EXIT;
        END;
     IF CHANGES
     THEN CALL RING_BELL;
     IF WAITING AND ( CHANGES OR FORCE )
     THEN DO;
          CALL M$TIME( FPT_TIME_CLOCK ) ALTRET( ARETT );
          DO WHILE ( '0'B );
ARETT:         CALL ERROR;
             END;
          CALL M$DISPLAY( FPT_DISPLAY ) ALTRET( AREDI );
          DO WHILE ( '0'B );
AREDI:         CALL ERROR;
             END;
          CALL X$WRITE( F_FDS, DI_, HHMM_, MMDD_, FPT_DISPLAY.RESULTS_ );
        END;
     IF READ = COUN
     THEN EMPTY = '1'B;
     IF READ = DELE
     THEN ALTRETURN;
     ELSE RETURN;
 
END REPORT;
%EJECT;
 
ERROR: PROC;
 
     FPT_ERRMSG.V.DCB# = B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
     ERRCODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
     GOTO ERRL;
 
ERROR1: ENTRY;
 
     FPT_ERRMSG.V.DCB# = 0;
ERRL: ;
     ERRCODE.SEV = 0;
     CALL M$ERRMSG( FPT_ERRMSG );
 
     RETURN;
 
END ERROR;
%EJECT;
 
ERRINT: PROC( ARG ) ALTRET;
 
DCL ARG BIT(72) DALIGNED;
 
     CALL X$WRITE( F_FDS, ARG );
 
     ALTRETURN;
 
ERRXXX: ENTRY( ARG ) ALTRET;
 
     CALL X$WRITE( F_FDS, ARG );
     CALL M$EXIT;
 
END ERRINT;
%EJECT;
 
RING_BELL: PROC;
 
     CALL M$WRITE( FPT_WRITE_BELL ) ALTRET( ARETWB );
     DO WHILE ( '0'B );
ARETWB:   CALL ERROR;
        END;
 
     RETURN;
 
END RING_BELL;
%EJECT;
 
GETBIT: PROC(MASK,START) ALTRET;
 
DCL MASK(0:8) BIT(1) UNAL;
DCL START UBIN WORD;
 
     DO BITSET = START TO 8;
          IF MASK(8 - BITSET) THEN
               RETURN;
        END;
 
     ALTRETURN;
 
END GETBIT;
 
%EJECT;
 
SETUP_LIMIT_VECTOR: PROC(MASK,ISTRT) ALTRET;
 
DCL MASK BIT(9) UNAL;
DCL ISTRT UBIN WORD;
DCL EXTRA_SZ UBIN WORD;
DCL NOT_DONE BIT(1);
 
     EXTRA_SZ = SIZEC(EXTRA_LIMITS_FMT);
     NOT_DONE = '1'B;
 
     DO WHILE(NOT_DONE);
          CALL GETBIT(MASK,START) WHENRETURN DO;
               LIMIT_VEC_(I) = XL__(BITSET);
               IF I > ISTRT THEN DO;
                    SUBSTR(LIMIT_BUF,CHR_POS,EXTRA_SZ) = EXTRA_LIMITS_FMT;
                    CHR_POS = CHR_POS + EXTRA_SZ;
                  END;
               START = BITSET + 1;
               IF START > 8 THEN
                    NOT_DONE = '0'B;
               I = I + 1;
             END;
          WHENALTRETURN DO;
               NOT_DONE = '0'B;
             END;
        END;
     RETURN;
 
END SETUP_LIMIT_VECTOR;
 
%EJECT;
 
SET_FDS: PROC;
 
     FDS_BUFSIZE = M$ME$ -> F$DCB.WIDTH#;
     IF ( FDS_BUFSIZE = 0 ) OR ( FDS_BUFSIZE > LENGTHC( FDS_BUFFER ) )
     THEN FDS_BUFSIZE = LENGTHC( FDS_BUFFER );
     F_FDS.BUF_ = VECTOR( FDS_BUFF$ER );
     LIM_FDS.BUF_ = VECTOR( FDS_BUFF$ER );
 
     RETURN;
 
END SET_FDS;
 
END A;
