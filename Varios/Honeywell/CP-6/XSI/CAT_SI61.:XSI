/*M* CAT.X - a processor that copies other system's labelled tapes */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CAT:    PROC MAIN NOAUTO;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%INCLUDE XUR_ENTRY;
%INCLUDE CAT_C61;
%EQU DB_UNPARSE#=1;
/*
\
DCBs:
/
*/
%M$DCB(DCBN=M$EI,ASN=DEVICE,ORG=FREE,FUN=IN,CNVRT=NO);
%M$DCB(DCBN=M$EO,ASN=FILE);
DCL M$DO DCB;
DCL M$SI DCB;
DCL M$LO DCB;
/*
\
External Procedures:
/
*/
DCL ENLARGE_BUFFER ENTRY (2) ALTRET;
DCL GP ENTRY (5);
DCL UNPARSE ENTRY (1);
DCL ALTERRMSG ENTRY;
 
DCL CPV_OPEN_TAPE ENTRY ALTRET;
DCL GCOS_OPEN_TAPE ENTRY ALTRET;
 
DCL CPV_OPEN_TAPE_FILE ENTRY ALTRET;
DCL GCOS_OPEN_TAPE_FILE ENTRY ALTRET;
 
DCL CPV_SKIP_TAPE_FILE ENTRY ALTRET;
DCL GCOS_SKIP_TAPE_FILE ENTRY ALTRET;
 
DCL CPV_COPY_TAPE_FILE ENTRY ALTRET;
DCL GCOS_COPY_TAPE_FILE ENTRY ALTRET;
 
DCL CPV_CLOSE_TAPE_FILE ENTRY ALTRET;
DCL GCOS_CLOSE_TAPE_FILE ENTRY ALTRET;
/*
\
SYMREFs:
/
*/
DCL CAT_NODES UBIN SYMREF;
/*
\
Static SYMDEFs:
/
*/
DCL DEBUG (0:35) BIT(1) UNAL STATIC SYMDEF INIT ('0'B*36);
DCL CAT_FUN UBIN STATIC SYMDEF INIT (%CAT_LIST#);
DCL CAT_RES UBIN STATIC SYMDEF INIT (%CAT__XT#);
%VLP_NAME(FPTN=MEOW,NAME='Meow: ');
%FPT_OPEN(FPTN=EI_OPEN,DCB=M$EI,SN=TSN,ORG=FREE,RES='FT',
  REASSIGN=NO,STCLASS="STATIC SYMDEF");
%FPT_CLOSE(FPTN=EI_CLOSE,DCB=M$EI,DISP=SAVE,STCLASS="STATIC SYMDEF");
%FPT_REW(FPTN=EI_REWIND,DCB=M$EI,STCLASS="STATIC SYMDEF");
%FPT_PFIL(FPTN=EI_PFILE,DCB=M$EI,BOF=NO,STCLASS="STATIC SYMDEF");
%FPT_PRECORD(FPTN=EI_PRECORD,DCB=M$EI,N=1,STCLASS="STATIC SYMDEF");
%FPT_READ(FPTN=EI_READ,DCB=M$EI,STCLASS="STATIC SYMDEF");
%FPT_OPEN(FPTN=EO_OPEN,DCB=M$EO,FUN=CREATE,NAME=FNAMEO,
  REASSIGN=NO,STCLASS="STATIC SYMDEF");
%FPT_WRITE(FPTN=EO_WRITE,DCB=M$EO,STCLASS="STATIC SYMDEF");
%FPT_CLOSE(FPTN=EO_CLOSE,DCB=M$EO,DISP=SAVE,STCLASS="STATIC SYMDEF");
%FPT_WRITE(FPTN=DO_WRITE,DCB=M$DO,BUF=DO_BUF,STCLASS="STATIC SYMDEF");
%FPT_WRITE(FPTN=LO_WRITE,DCB=M$LO,BUF=LO_BUF,STCLASS="STATIC SYMDEF");
%FPT_WRITE(FPTN=LO_WRITE_SPACE,DCB=M$LO,BUF=SPACE,STCLASS="STATIC SYMDEF");
DCL EI_DCB$ PTR STATIC SYMDEF;
DCL EO_DCB$ PTR STATIC SYMDEF;
DCL SI_DCB$ PTR ALIGNED STATIC SYMDEF;
%VLP_VECTOR(FPTN=EI_BUF$$,STCLASS="STATIC SYMDEF");
%VLP_VECTOR(FPTN=EO_BUF$$,STCLASS="STATIC SYMDEF");
DCL COMMAND_LEVEL BIT(72) DALIGNED STATIC SYMDEF;
DCL LABEL_DO_ABORT BIT(72) DALIGNED STATIC SYMDEF;
DCL LABEL_IO_ERROR BIT(72) DALIGNED STATIC SYMDEF;
DCL LABEL_CANT_GET_MEMORY BIT(72) DALIGNED STATIC SYMDEF;
%VLP_SN(FPTN=TSN,STCLASS="STATIC SYMDEF");
DCL FSN UBIN ALIGNED STATIC SYMDEF;
DCL SN CHAR(6) ALIGNED STATIC SYMDEF;
DCL ACCT CHAR(8) ALIGNED STATIC SYMDEF;
DCL 1 FNAME ALIGNED STATIC SYMDEF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL ACCTO CHAR(8) ALIGNED STATIC SYMDEF;
DCL 1 FNAMEO ALIGNED STATIC SYMDEF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL 1 KEY ALIGNED STATIC SYMDEF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31) UNAL,
      2 V REDEF C,
        3 U27 UBIN(27) UNAL,
        3 * CHAR(28);
DCL DO_BUF CHAR(120) ALIGNED STATIC SYMDEF;
DCL LO_BUF CHAR(120) ALIGNED STATIC SYMDEF;
DCL EOF_IS_NEXT BIT(1) STATIC SYMDEF INIT (%NO#);
DCL KEEP_ON_LOOKING BIT(1) STATIC SYMDEF INIT (%YES#);
DCL SKIP_FILE BIT(1) STATIC SYMDEF;
DCL SKIP_COPY BIT(1) STATIC SYMDEF;
DCL CHECK_DATA BIT(1) STATIC SYMDEF;
DCL COPY_DATA BIT(1) STATIC SYMDEF;
DCL DONT_REWIND BIT(1) STATIC SYMDEF;
DCL PPTRS$(0:63) PTR STATIC SYMDEF;
DCL PVALS(0:63) REDEF PPTRS$ SBIN;
DCL PPTRP(0:63) BIT(1) UNAL STATIC SYMDEF;
DCL PVALP(0:63) REDEF PPTRP BIT(1) UNAL;
DCL PBITS(0:63) BIT(1) UNAL STATIC SYMDEF;
DCL PBITP(0:63) BIT(1) UNAL STATIC SYMDEF;
/*
\
Constant Storage:
/
*/
DCL OPEN_TAPE (0:2) EPTR CONSTANT
 INIT (ENTADDR(CPV_OPEN_TAPE),
       ENTADDR(CPV_OPEN_TAPE),
       ENTADDR(GCOS_OPEN_TAPE));
DCL OPEN_TAPE_FILE (0:2) EPTR CONSTANT
 INIT (ENTADDR(CPV_OPEN_TAPE_FILE),
       ENTADDR(CPV_OPEN_TAPE_FILE),
       ENTADDR(GCOS_OPEN_TAPE_FILE));
DCL SKIP_TAPE_FILE (0:2) EPTR CONSTANT
 INIT (ENTADDR(CPV_SKIP_TAPE_FILE),
       ENTADDR(CPV_SKIP_TAPE_FILE),
       ENTADDR(GCOS_SKIP_TAPE_FILE));
DCL COPY_TAPE_FILE (0:2) EPTR CONSTANT
 INIT (ENTADDR(CPV_COPY_TAPE_FILE),
       ENTADDR(CPV_COPY_TAPE_FILE),
       ENTADDR(GCOS_COPY_TAPE_FILE));
DCL CLOSE_TAPE_FILE (0:2) EPTR CONSTANT
 INIT (ENTADDR(CPV_CLOSE_TAPE_FILE),
       ENTADDR(CPV_CLOSE_TAPE_FILE),
       ENTADDR(GCOS_CLOSE_TAPE_FILE));
DCL DEFAULT_TYPE (0:2) CHAR(2) CONSTANT INIT ('  ','C5','G3');
DCL SPACE CHAR(1) CONSTANT INIT (' ');
/*
\
Static Storage:
/
*/
DCL XOPEN_TAPE EPTR STATIC;
DCL XOPEN_TAPE_FILE EPTR STATIC;
DCL XSKIP_TAPE_FILE EPTR STATIC;
DCL XCOPY_TAPE_FILE EPTR STATIC;
DCL XCLOSE_TAPE_FILE EPTR STATIC;
%XUR_INIT(PCB=PCB_COMMANDS);
%FPT_GDP(FPTN=GET_PARSE_MEMORY,PAGES=1,RESULTS=XUR_INIT.WORK_);
%P_PCB(NAME=PCB_COMMANDS);
DCL BLK$ PTR STATIC;
DCL P$ PTR STATIC;
DCL I SBIN STATIC;
DCL L SBIN STATIC;
/*
\
Based References:
/
*/
%F$DCB(DCBN=EI_DCB,BASED="BASED(EI_DCB$)");
%F$DCB(DCBN=EO_DCB,BASED="BASED(EO_DCB$)");
%F$DCB(DCBN=SI_DCB,BASED="BASED(SI_DCB$)");
DCL B$EI_BUF CHAR(4096) BASED (EI_BUF$$.PTR$);
DCL B$EI_BUF_U9 (0:4095) UBIN(9) UNAL BASED (EI_BUF$$.PTR$);
DCL B$C CHAR(4096) BASED;
DCL 1 B$TXC BASED (P$),
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
/*
\
Procedure:
/
*/
        EI_DCB$ = DCBADDR(DCBNUM(M$EI));
        EO_DCB$ = DCBADDR(DCBNUM(M$EO));
        SI_DCB$ = DCBADDR(DCBNUM(M$SI));
        CALL M$GDP (GET_PARSE_MEMORY) ALTRET (CANT_GET_MEMORY);
        CALL XUR$INIT (XUR_INIT);
        EI_BUF$$ = '0'O;
        CALL ENLARGE_BUFFER (EI_BUF$$,8) ALTRET (CANT_GET_MEMORY);
        EO_BUF$$ = '0'O;
        CALL ENLARGE_BUFFER (EO_BUF$$,8) ALTRET (CANT_GET_MEMORY);
        EI_READ.BUF_ = EI_BUF$$;
        EO_WRITE.BUF_ = EO_BUF$$;
        REMEMBER READ_A_COMMAND IN COMMAND_LEVEL;
        REMEMBER DO_ABORT IN LABEL_DO_ABORT;
        REMEMBER IO_ERROR IN LABEL_IO_ERROR;
        REMEMBER CANT_GET_MEMORY IN LABEL_CANT_GET_MEMORY;
 
READ_A_COMMAND:
 
        KEEP_ON_LOOKING = %YES#;
 
        DO I = 0 TO 63;
           PVALP(I) = %NO#;
           PVALS(I) = 0;
           PBITP(I) = %NO#;
           PBITS(I) = %NO#;
           END;
 
        CALL XUR$GETCMD (CAT_NODES,BLK$,MEOW) ALTRET (PARSE_ERROR);
        IF DEBUG(%DB_UNPARSE#)
          THEN
           CALL UNPARSE (PCB_COMMANDS);
        CALL GP (PCB_COMMANDS,PVALP,PVALS,PBITP,PBITS);
 
        CAT_FUN = PVALS(%CAT_FUN#);
        COPY_DATA = %NO#;
        CHECK_DATA = %NO#;
        DONT_REWIND = %NO#;
        DO CASE (CAT_FUN);
         CASE (%CAT_END#);
           GOTO CAT_EXIT;
         CASE (%CAT_LIST#);
           CHECK_DATA = %YES#;
         CASE (%CAT_COPY#, %CAT_COPYALL#);
           CHECK_DATA = %YES#;
           COPY_DATA = %YES#;
         END;
        IF PVALP(%CAT_RES#)
          THEN DO;
           CAT_RES = PVALS(%CAT_RES#);
           XOPEN_TAPE = OPEN_TAPE(CAT_RES);
           XOPEN_TAPE_FILE = OPEN_TAPE_FILE(CAT_RES);
           XSKIP_TAPE_FILE = SKIP_TAPE_FILE(CAT_RES);
           XCOPY_TAPE_FILE = COPY_TAPE_FILE(CAT_RES);
           XCLOSE_TAPE_FILE = CLOSE_TAPE_FILE(CAT_RES);
           END;
        IF PVALP(%CAT__TYPEO#)
          THEN
           EO_OPEN.V.TYPE# = SUBSTR(ADDR(PVALS(%CAT__TYPEO#))->B$C,0,2);
          ELSE
           EO_OPEN.V.TYPE# = DEFAULT_TYPE(CAT_RES);
        IF PPTRP(%CAT_SN#)
          THEN DO;
           P$ = PPTRS$(%CAT_SN#);
           TSN.SN#(0) = SUBSTR(B$TXC.C,0,B$TXC.L);
           END;
        IF PVALP(%CAT__DEN#)
          THEN
           EI_OPEN.V.DENSITY# = PVALS(%CAT__DEN#);
          ELSE
           EI_OPEN.V.DENSITY# = 0;
        IF PVALP(%CAT__SFSN#)
          THEN
           FSN = PVALS(%CAT__SFSN#);
          ELSE
           FSN = 1;
        IF PVALP(%CAT__NREW#)
          THEN
           DONT_REWIND = %YES#;
 
        CALL XOPEN_TAPE;
        DO WHILE (KEEP_ON_LOOKING);
           SKIP_FILE = %NO#;
           SKIP_COPY = %NO#;
           CALL XOPEN_TAPE_FILE ALTRET (READ_A_COMMAND);
           IF SKIP_COPY OR SKIP_FILE
             THEN
              CALL XSKIP_TAPE_FILE;
             ELSE
              CALL XCOPY_TAPE_FILE;
           CALL XCLOSE_TAPE_FILE;
           END;
 
        GOTO READ_A_COMMAND;
 
CAT_EXIT:
        IF EI_DCB.FCD# THEN DO; /* If the tape DCB is OPEN, close & rewind */
           EI_CLOSE.V.NOMARKS# = %YES#;
           EI_CLOSE.V.POS# = %PTV#;
           CALL M$CLOSE( EI_CLOSE );
           END;
 
        CALL M$EXIT;
 
 
PARSE_ERROR:
        DO_BUF = ' ';
        CALL INSERT (DO_BUF,PCB_COMMANDS.HI_CHAR+LENGTHC(MEOW.NAME#),1,'^');
        CALL M$WRITE (DO_WRITE);
        GOTO READ_A_COMMAND;
 
 
CANT_GET_MEMORY:
        CALL ALTERRMSG;
        CALL M$ERR;
 
 
IO_ERROR:
        CALL ALTERRMSG;
        CALL M$ERR;
 
 
DO_ABORT:
        CALL M$WRITE (DO_WRITE);
        CALL M$ERR;
 
END CAT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
OPEN_PHY_IN: PROC ALTRET;
%INCLUDE CP_6;
/*
\
SYMREFs:
/
*/
DCL DONT_REWIND BIT(1) SYMREF;
DCL EI_DCB$ PTR SYMREF;
%FPT_OPEN(FPTN=EI_OPEN,STCLASS=SYMREF);
%FPT_REW(FPTN=EI_REWIND,STCLASS=SYMREF);
/*
\
Based References:
/
*/
%F$DCB(DCBN=EI_DCB,BASED="BASED(EI_DCB$)");
/*
\
Procecure:
/
*/
        IF NOT EI_DCB.FCD#
          THEN
           CALL M$OPEN (EI_OPEN) ALTRET (IO_ERROR);
        IF NOT DONT_REWIND
          THEN
           CALL M$REW (EI_REWIND) ALTRET (IO_ERROR);
        RETURN;
IO_ERROR:
        ALTRETURN;
END OPEN_PHY_IN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
READ_PHY: PROC ALTRET;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B_ERRORS_C;
/*
\
External Procedures:
/
*/
DCL ENLARGE_BUFFER ENTRY (2) ALTRET;
/*
\
SYMREFs:
/
*/
DCL EI_DCB$ PTR SYMREF;
%F$DCB(DCBN=EI_DCB,STCLASS="BASED(EI_DCB$)");
DCL B$TCB$ PTR SYMREF;
%VLP_VECTOR(FPTN=EI_BUF$$,STCLASS=SYMREF);
%FPT_READ(FPTN=EI_READ,STCLASS=SYMREF);
%FPT_PRECORD(FPTN=EI_PRECORD,STCLASS=SYMREF);
DCL LABEL_DO_ABORT BIT(72) DALIGNED SYMREF;
DCL DO_BUF CHAR(120) ALIGNED SYMREF;
DCL EOF_IS_NEXT BIT(1) SYMREF;
/*
\
Based Structures:
/
*/
%B$TCB(STCLASS="BASED(B$TCB$)");
%B$ALT;
%VLP_VECTOR(FPTN=B$VECTOR,STCLASS=BASED);
/*
\
Procedure:
/
*/
READ_PHY_AGAIN:
        CALL M$READ (EI_READ) ALTRET (ERROR_EI_READ);
        IF EOF_IS_NEXT
          THEN DO;
           DO_BUF = 'A physical tape mark should have been next.';
           UNWIND TO LABEL_DO_ABORT;
           END;
        IF EI_DCB.ARS# > EI_READ.BUF_.BOUND
          THEN
           IF ADDR(EI_READ.BUF_)->B$VECTOR.W2.SEGID# ~= EI_BUF$$.W2.SEGID#
             THEN
              ALTRETURN;
             ELSE DO;
              EI_PRECORD.V.N# = -1;
              CALL M$PRECORD (EI_PRECORD) ALTRET (IO_ERROR);
              CALL ENLARGE_BUFFER (EI_BUF$$,1) ALTRET (CANT_GET_MEMORY);
              EI_READ.BUF_.BOUND = EI_READ.BUF_.BOUND + 4096;
              GOTO READ_PHY_AGAIN;
              END;
        RETURN;
ERROR_EI_READ:
        IF EOF_IS_NEXT
          THEN DO;
           EOF_IS_NEXT = %NO#;
           GOTO READ_PHY_AGAIN;
           END;
IO_ERROR:
        ALTRETURN;
CANT_GET_MEMORY:
        ALTRETURN;
END READ_PHY;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
WRITE_PHY: PROC ALTRET;
%INCLUDE CP_6;
/*
\
SYMREFs:
/
*/
        %FPT_WRITE(FPTN=EO_WRITE,STCLASS=SYMREF);
DCL EO_DCB$ PTR ALIGNED SYMREF;
/*
\
Based Structures:
/
*/
%F$DCB(DCBN=EO_DCB,BASED="BASED(EO_DCB$)");
/*
\
Procedure:
/
*/
        IF EO_DCB.FCD#
          THEN
           CALL M$WRITE (EO_WRITE) ALTRET (ERROR_EO_WRITE);
        RETURN;
ERROR_EO_WRITE:
        ALTRETURN;
END WRITE_PHY;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
EBC2ASC: PROC (P$BUFO,P$BUFI,P$L);
/*
\
Parameters:
/
*/
DCL P$BUFO CHAR(P$L);
DCL P$BUFI CHAR(P$L);
DCL P$L UBIN;
/*
\
SYMREFs:
/
*/
DCL T_EBC2ASC (0:511) UBIN(9) UNAL SYMREF;
/*
\
Static Storage:
/
*/
DCL I$ PTR STATIC;
DCL O$ PTR STATIC;
DCL L SBIN STATIC;
DCL I SBIN STATIC;
/*
\
Based Structures:
/
*/
DCL B$C CHAR(4096) BASED;
/*
\
Procedure:
/
*/
        O$ = ADDR(P$BUFO);
        I$ = ADDR(P$BUFI);
        I = 0;
        DO WHILE (I < P$L);
           L = MINIMUM(P$L-I,131072);
           CALL XLATE (SUBSTR(O$->B$C,0,L),T_EBC2ASC,
             SUBSTR(I$->B$C,0,L));
           O$ = PINCRC(O$,L);
           I$ = PINCRC(I$,L);
           I = I + L;
           END;
        RETURN;
END EBC2ASC;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
BCD2ASC: PROC (P$BUFO,P$BUFI,P$L);
/*
\
Parameters:
/
*/
DCL P$BUFO (0:0) CHAR(1);
DCL P$BUFI (0:0) UBIN(6) UNAL;
DCL P$L SBIN;
/*
\
Constant Data:
/
*/
DCL T_BCD2ASC (0:63) CONSTANT CHAR(1) INIT
    ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
     '[', '#', '@', ':', '>', '?', ' ', 'A', 'B', 'C',
     'D', 'E', 'F', 'G', 'H', 'I', '&', '.', ']', '(',
     '<', '\', '^', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
     'Q', 'R', '-', '$', '*', ')', ';', '''', '+', '/',
     'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', ',',
     '%', '=', '"', '!');
/*
\
Static Data:
/
*/
DCL II SBIN STATIC;
DCL I SBIN STATIC;
DCL L SBIN STATIC;
DCL I$ PTR STATIC;
DCL O$ PTR STATIC;
/*
\
Based Structures:
/
*/
DCL B$BUFO (0:131071) CHAR(1) BASED (O$);
DCL B$BUFI (0:131071) UBIN(6) UNAL BASED (I$);
/*
\
Procedure:
/
*/
        O$ = ADDR(P$BUFO);
        I$ = ADDR(P$BUFI);
        I = 0;
        DO WHILE (I < P$L);
           L = MINIMUM(P$L-I,131072);
           DO II = 0 TO L-1;
              P$BUFO(II) = T_BCD2ASC(P$BUFI(II));
              END;
           O$ = PINCRC(O$,L);
           I$ = PINCRB(I$,L*6);
           I = I + L;
           END;
        RETURN;
 
END BCD2ASC;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
ENLARGE_BUFFER: PROC (P$VECTOR,P$PAGES) ALTRET;
%INCLUDE CP_6;
/*
\
Parameters:
/
*/
%VLP_VECTOR(FPTN=P$VECTOR,STCLASS="");
DCL P$PAGES UBIN;
/*
\
Static Data:
/
*/
%FPT_GDS(FPTN=GET_MEMORY,FREE=YES);
/*
\
Procedure:
/
*/
        GET_MEMORY.RESULTS_ = VECTOR(P$VECTOR);
        GET_MEMORY.V.SEGSIZE# = P$PAGES * 1024;
        CALL M$GDS (GET_MEMORY) ALTRET (CANT_GET_MEMORY);
        RETURN;
CANT_GET_MEMORY:
        ALTRETURN;
 
END ENLARGE_BUFFER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
GET_ENOUGH_MEMORY: PROC (P$L) ALTRET;
%INCLUDE CP_6;
/*
\
Parameters:
/
*/
DCL P$L UBIN;
/*
\
External Procedures:
/
*/
DCL ENLARGE_BUFFER ENTRY (2) ALTRET;
/*
\
SYMREFs:
/
*/
%VLP_VECTOR(FPTN=EO_BUF$$,STCLASS=SYMREF);
/*
\
Procedure:
/
*/
        DO WHILE (P$L > EO_BUF$$.W1.VSIZE#+1);
           CALL ENLARGE_BUFFER (EO_BUF$$,1) ALTRET (CANT_GET_MEMORY);
           END;
        RETURN;
 
CANT_GET_MEMORY:
        ALTRETURN;
 
END GET_ENOUGH_MEMORY;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
SELECT_BY_FSN: PROC (P$FSN,P$LABEL_FAR_ENOUGH) ALTRET;
%INCLUDE CP_6_SUBS;
%INCLUDE CAT_C61;
/*
\
Parameters:
/
*/
DCL P$FSN UBIN;
DCL P$LABEL_FAR_ENOUGH BIT(72) DALIGNED;
/*
\
SYMREFs:
/
*/
DCL SKIP_FILE BIT(1) SYMREF;
DCL PPTRS$(0:63) PTR ALIGNED SYMREF;
DCL PVALS(0:63) REDEF PPTRS$ SBIN;
DCL PPTRP(0:63) BIT(1) UNAL SYMREF;
DCL PVALP(0:63) REDEF PPTRP BIT(1) UNAL;
DCL PBITS(0:63) BIT(1) UNAL SYMREF;
DCL PBITP(0:63) BIT(1) UNAL SYMREF;
/*
\
Static Data:
/
*/
DCL I SBIN STATIC;
DCL MAX_FSN UBIN STATIC;
/*
\
Procedure:
/
*/
        MAX_FSN = 0;
        IF PVALP(%CAT__FSN#)
          THEN DO;
           I = %CAT__FSN#;
           DO WHILE (PVALP(I));
              IF PVALP(I+1)
                THEN
                 IF PVALS(I) <= P$FSN AND P$FSN <= PVALS(I+1)
                   THEN
                    GOTO SELECT_THIS_FILE;
                   ELSE
                    MAX_FSN = MAXIMUM(MAX_FSN,PVALS(I+1));
                ELSE
                 IF PVALS(I) = P$FSN
                   THEN
                    GOTO SELECT_THIS_FILE;
                   ELSE
                    MAX_FSN = MAXIMUM(MAX_FSN,PVALS(I));
              I = I + 2;
              END;
           SKIP_FILE = %YES#;
           IF P$FSN > MAX_FSN
             THEN
              UNWIND TO P$LABEL_FAR_ENOUGH;
           ALTRETURN;
           END;
SELECT_THIS_FILE:
        RETURN;
END SELECT_BY_FSN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
MOVE9X8:   PROC (P$BUFO,P$BUFI,P$L);
/*
\
Parameters:
/
*/
DCL P$BUFO (0:0) UBIN(8) UNAL;
DCL P$BUFI (0:0) UBIN(9) UNAL;
DCL P$L UBIN;
/*
\
Static Data:
/
*/
DCL I UBIN STATIC;
/*
\
Procedure:
/
*/
        DO I = 0 TO P$L-1;
           P$BUFO(I) = P$BUFI(I);
           END;
        RETURN;
END MOVE9X8;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CPV_OPEN_TAPE: PROC ALTRET;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE CAT_C61;
%INCLUDE B_MICROPS_C;
%INCLUDE XUW_MACRO_C;
%EQU CPVCONSEC#=1;
%EQU CPVKEYED#=2;
%EQU CPVRANDOM#=3;
/*
\
DCBs:
/
*/
DCL M$LO DCB;
/*
\
External Procedures:
/
*/
DCL OPEN_PHY_IN ENTRY ALTRET;
DCL READ_PHY ENTRY ALTRET;
DCL WRITE_PHY ENTRY ALTRET;
DCL SELECT_BY_FSN ENTRY (2) ALTRET;
DCL GET_ENOUGH_MEMORY ENTRY (1) ALTRET;
DCL ALTERRMSG ENTRY;
DCL X$WILDFMT ENTRY (1) ALTRET;
DCL CPV_LOCCODE ENTRY (2) ALTRET;
DCL CPV_LD16X ENTRY (2);
DCL CPV_LD24X ENTRY (2);
DCL CPV_DCOM ENTRY (4) ALTRET;
DCL EBC2ASC ENTRY (3);
DCL MOVE9X8 ENTRY (3);
/*
\
SYMREFs:
/
*/
DCL T_EBC2ASC (0:511) UBIN(9) UNAL SYMREF;
DCL CAT_FUN UBIN ALIGNED SYMREF;
%FPT_OPEN(FPTN=EI_OPEN,STCLASS=SYMREF);
%FPT_REW(FPTN=EI_REWIND,STCLASS=SYMREF);
%FPT_PFIL(FPTN=EI_PFILE,STCLASS=SYMREF);
%FPT_PRECORD(FPTN=EI_PRECORD,STCLASS=SYMREF);
%FPT_READ(FPTN=EI_READ,STCLASS=SYMREF);
%FPT_OPEN(FPTN=EO_OPEN,STCLASS=SYMREF);
%FPT_WRITE(FPTN=EO_WRITE,STCLASS=SYMREF);
%FPT_CLOSE(FPTN=EO_CLOSE,STCLASS=SYMREF);
%FPT_WRITE(FPTN=DO_WRITE,STCLASS=SYMREF);
%FPT_WRITE(FPTN=LO_WRITE,STCLASS=SYMREF);
%FPT_WRITE(FPTN=LO_WRITE_SPACE,STCLASS=SYMREF);
DCL EI_DCB$ PTR ALIGNED SYMREF;
DCL EO_DCB$ PTR ALIGNED SYMREF;
%VLP_VECTOR(FPTN=EI_BUF$$,STCLASS=SYMREF);
%VLP_VECTOR(FPTN=EO_BUF$$,STCLASS=SYMREF);
DCL COMMAND_LEVEL BIT(72) DALIGNED SYMREF;
DCL LABEL_DO_ABORT BIT(72) DALIGNED SYMREF;
DCL LABEL_IO_ERROR BIT(72) DALIGNED SYMREF;
DCL LABEL_CANT_GET_MEMORY BIT(72) DALIGNED SYMREF;
DCL DO_BUF CHAR(120) ALIGNED SYMREF;
DCL FSN UBIN ALIGNED SYMREF;
DCL LO_BUF CHAR(120) ALIGNED SYMREF;
DCL SN CHAR(6) ALIGNED SYMREF;
DCL ACCT CHAR(8) ALIGNED SYMREF;
DCL 1 FNAME ALIGNED SYMREF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL ACCTO CHAR(8) ALIGNED SYMREF;
DCL 1 FNAMEO ALIGNED SYMREF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL 1 KEY ALIGNED SYMREF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31) UNAL,
      2 V REDEF C,
        3 U27 UBIN(27) UNAL,
        3 * CHAR(28);
DCL EOF_IS_NEXT BIT(1) SYMREF;
DCL KEEP_ON_LOOKING BIT(1) SYMREF;
DCL SKIP_FILE BIT(1) SYMREF;
DCL SKIP_COPY BIT(1) SYMREF;
DCL CHECK_DATA BIT(1) SYMREF;
DCL COPY_DATA BIT(1) SYMREF;
DCL DONT_REWIND BIT(1) SYMREF;
DCL PPTRS$(0:63) PTR ALIGNED SYMREF;
DCL PVALS(0:63) REDEF PPTRS$ SBIN;
DCL PPTRP(0:63) BIT(1) UNAL SYMREF;
DCL PVALP(0:63) REDEF PPTRP BIT(1) UNAL;
DCL PBITS(0:63) BIT(1) UNAL SYMREF;
DCL PBITP(0:63) BIT(1) UNAL SYMREF;
/*
\
Constant Storage:
/
*/
DCL MOP_5 (0:1) BIT(9) CONSTANT INIT (%MVZB4,%MVC1);
DCL CPVORG2CP6ORG (0:3) UBIN(9) UNAL CONSTANT
   INIT (0,%CONSEC#,%KEYED#,%RELATIVE#);
DCL CPV_HEADER CHAR(0) CONSTANT INIT ('ORG NRECS   FSN File Name');
DCL 1 TXC_Q STATIC,
      2 L UBIN(9) UNAL INIT (1),
      2 C CHAR(1) INIT ('?');
/*
\
Static Storage:
/
*/
%XUW_WILDCARD(FPTN=WILD_CMP_FMT,
               INPUT=FNAME.C,
               OUTPUT=FNAMEO.C,
               OUTPUT_LEN=511,
               CONTAINS=NO);
DCL PATT CHAR(31) STATIC;
DCL INPUT CHAR(31) STATIC;
%VLP_VECTOR(FPTN=EO_WRITE_KEY_,STCLASS="BASED(EWK$)");
%FPT_WRITE(FPTN=LO_WRITE_CPV_HEADER,DCB=M$LO,BUF=CPV_HEADER);
DCL LABEL_THATS_FAR_ENOUGH BIT(72) DALIGNED STATIC;
DCL LABEL_READ_ANOTHER_RECORD BIT(72) DALIGNED STATIC;
DCL CDATE CHAR(8) STATIC;
DCL P$ PTR STATIC;
DCL PTR$ PTR STATIC;
DCL KEY$ PTR STATIC;
DCL EO_BUF$ PTR STATIC;
DCL EWK$ PTR STATIC INIT (ADDR(EO_WRITE.BUF_));
DCL ORG UBIN STATIC;
DCL KEYM UBIN STATIC;
DCL NRECS UBIN STATIC;
DCL I SBIN STATIC;
DCL L SBIN STATIC;
DCL NKY SBIN STATIC;
DCL RWS SBIN STATIC;
DCL ARS SBIN STATIC;
DCL ARSC SBIN STATIC;
DCL WORK5 CHAR(5) STATIC;
DCL WORK9 CHAR(9) STATIC;
DCL WORK64 CHAR(64) STATIC;
DCL WORK512 CHAR(512) STATIC;
DCL ORG_TX(0:3) CHAR(3) STATIC INIT ('BAD','CON','KEY','RAN');
DCL 1 FLG STATIC,
      2 U9 UBIN(9) UNAL,
      2 P REDEF U9,
        3 * BIT(6) UNAL,
        3 UNBLOCKED BIT(1) UNAL,
        3 CONTINUED BIT(1) UNAL,
        3 SEGMENT_1 BIT(1) UNAL;
DCL INFILE_OPENED BIT(1) STATIC INIT (%NO#);
DCL BINARY BIT(1) STATIC INIT (%NO#);
DCL COMPRESSED BIT(1) STATIC INIT (%NO#);
DCL CONTINUED BIT(1) STATIC;
DCL FIRST_TAPE_ACCESS BIT(1) STATIC INIT(%YES#);
DCL REWOUND BIT(1) STATIC INIT (%NO#);
DCL CPVFSAVE BIT(1) STATIC INIT (%NO#);
DCL PRINT_HEADER BIT(1) STATIC INIT (%YES#);
DCL ONLY_ONE_FILE BIT(1) STATIC;
/*
\
Based References:
/
*/
%F$DCB(DCBN=EI_DCB,BASED="BASED(EI_DCB$)");
%F$DCB(DCBN=EO_DCB,BASED="BASED(EO_DCB$)");
DCL B$EI_BUF CHAR(4096) BASED (EI_BUF$$.PTR$);
DCL B$EO_BUF CHAR(4096) BASED (EO_BUF$$.PTR$);
DCL B$EI_BUF_U9 (0:4095) UBIN(9) UNAL BASED (EI_BUF$$.PTR$);
DCL B$EO_BUF_U9 (0:4095) UBIN(9) UNAL BASED (EO_BUF$$.PTR$);
DCL B$U9 (0:2047) UBIN(9) UNAL BASED (PTR$);
DCL B$C CHAR(2048) UNAL BASED (PTR$);
DCL 1 B$TXC BASED (P$),
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
/*
\
Procedure:
/
*/
        REMEMBER THATS_FAR_ENOUGH IN LABEL_THATS_FAR_ENOUGH;
        CALL OPEN_PHY_IN ALTRET (IO_ERROR);
        DO WHILE (%NO#);
TEST_REWOUND:
           IF REWOUND
             THEN
              GOTO IO_ERROR;
TRY_REWINDING:
           IF NOT DONT_REWIND
             THEN
              CALL M$REW (EI_REWIND) ALTRET (IO_ERROR);
           EI_PFILE.V.BOF# = %NO#;
           CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
           EI_PRECORD.V.N# = -1;
           CALL M$PRECORD (EI_PRECORD) ALTRET (NOW_SKIP_BACK_2);
NOW_SKIP_BACK_2:
           EI_PRECORD.V.N# = -2;
           CALL M$PRECORD (EI_PRECORD) ALTRET (IO_ERROR);
           REWOUND = %YES#;
           END;
        EI_READ.V.DVBYTE.BIN# = %NO#;
        CALL READ_PHY ALTRET (TEST_REWOUND);
        CALL XLATE (WORK64,T_EBC2ASC,SUBSTR(B$EI_BUF,0,12));
        IF SUBSTR(WORK64,0,4) ~= ':LBL'
          THEN DO;
           IF NOT REWOUND
             THEN
              GOTO TRY_REWINDING;
           DO_BUF = 'First record of a Xerox labeled tape should be :LBL';
           UNWIND TO LABEL_DO_ABORT;
           END;
        SN = SUBSTR(WORK64,4,6);
        CALL READ_PHY ALTRET (IO_ERROR);
        CALL XLATE (WORK64,T_EBC2ASC,SUBSTR(B$EI_BUF,0,28));
        IF SUBSTR(WORK64,0,4) ~= ':ACN'
          THEN DO;
           DO_BUF = 'Second record of a Xerox labeled tape should be :ACN';
           UNWIND TO LABEL_DO_ABORT;
           END;
        ACCT = SUBSTR(WORK64,4,8);
        IF FIRST_TAPE_ACCESS THEN DO;
           FIRST_TAPE_ACCESS= %NO#;
           CALL CONCAT (CDATE,SUBSTR(WORK64,20,2),'/',SUBSTR(WORK64,22,2),
             '/',SUBSTR(WORK64,26,2));
           CALL INDEX1 (L,' ',SN);
           CALL CONCAT (LO_BUF,'XT#',SUBSTR(SN,0,L),'.',ACCT,
             '  creation date=',CDATE);
           CALL M$WRITE (LO_WRITE_SPACE);
           CALL M$WRITE (LO_WRITE);
           END;
        EI_PFILE.V.BOF# = %NO#;
        CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
        PRINT_HEADER = %YES#;
        RETURN;
%EJECT;
CPV_OPEN_TAPE_FILE: ENTRY ALTRET;
        CALL READ_PHY ALTRET (IO_ERROR);
        CALL XLATE (WORK64,T_EBC2ASC,SUBSTR(B$EI_BUF,0,4));
        IF SUBSTR(WORK64,0,4) ~= ':BOF'
          THEN
           ALTRETURN;
        PTR$ = PINCRW(EI_BUF$$.PTR$,1);
        CALL CPV_LOCCODE (PTR$,01) ALTRET (NO_FILE_NAME);
        DO WHILE (%NO#);
NO_FILE_NAME:
           DO_BUF = 'No file name in :BOF sentinel';
           UNWIND TO LABEL_DO_ABORT;
           END;
        PTR$ = PINCRW(PTR$,1);
        FNAME.L = B$U9(0);
        CALL XLATE (FNAME.C,T_EBC2ASC,SUBSTR(B$C,1,FNAME.L));
        IF PPTRP(%CAT_FNAME#)
          THEN DO;
           WILD_CMP_FMT.PATTERN_ = VECTOR(PPTRS$(%CAT_FNAME#)->B$TXC.C);
           WILD_CMP_FMT.PATTERN_.BOUND = PPTRS$(%CAT_FNAME#)->B$TXC.L - 1;
           END;
          ELSE DO;
           WILD_CMP_FMT.PATTERN_.PATTERN$ = ADDR(TXC_Q.C);
           WILD_CMP_FMT.PATTERN_.BOUND = 0;
           PPTRS$(%CAT_FNAME#) = ADDR(TXC_Q.C);
          END;
        ONLY_ONE_FILE = %NO#;
        P$ = WILD_CMP_FMT.PATTERN_.PATTERN$;
        CALL INDEX1 (I,'?',SUBSTR(PPTRS$(%CAT_FNAME#)->B$TXC.C,0,
          PPTRS$(%CAT_FNAME#)->B$TXC.L))
          ALTRET (NOT_WILD_CARDED);
        DO WHILE (%NO#);
NOT_WILD_CARDED:
           ONLY_ONE_FILE = %YES#;
           END;
        IF PPTRP(%CAT_FNAMEO#)
          THEN
           WILD_CMP_FMT.TEMPLATE_ = VECTOR(PPTRS$(%CAT_FNAMEO#)->B$TXC.C);
          ELSE
           WILD_CMP_FMT.TEMPLATE_ = VECTOR(FNAME.C);
        FNAMEO.L = FNAME.L;
        PTR$ = PINCRW(EI_BUF$$.PTR$,1);
        CALL CPV_LOCCODE (PTR$,09) ALTRET (NO_CODE_09);
        DO WHILE (%NO#);
NO_CODE_09:
           DO_BUF = 'No code 09 entry in :BOF record';
           UNWIND TO LABEL_DO_ABORT;
           END;
        BINARY = %NO#;
        COMPRESSED = %NO#;
        PTR$ = PINCRW(PTR$,1);
        ORG = B$U9(0);
        IF ORG ~= %CPVKEYED# AND ORG ~= %CPVRANDOM#
          THEN
           ORG = %CPVCONSEC#;
      /*IF ORG = %CPVKEYED#
          THEN */
           KEYM = B$U9(1);
       /* ELSE
           KEYM = 3; */
        IF ORG = %CPVKEYED# AND KEYM = 0
          THEN
           KEYM = 11;
        EO_OPEN.V.ORG# = CPVORG2CP6ORG(ORG);
        IF ORG = %CPVCONSEC#
          THEN DO;
           EO_OPEN.V.ACS# = %SEQUEN#;
           EO_WRITE.KEY_ = VECTOR(NIL);
           END;
          ELSE DO;
           EO_OPEN.V.ACS# = %DIRECT#;
           EO_WRITE.KEY_ = VECTOR(KEY);
           EO_WRITE_KEY_.W1.VSIZE# = KEYM;
           END;
        IF B$U9(2) = 1                  /* File VOL                           */
          THEN
           CONTINUED = %NO#;
          ELSE
           CONTINUED = %YES#;
        CALL READ_PHY ALTRET (NO_USER_LABEL);
        CALL XLATE (ACCT,T_EBC2ASC,SUBSTR(B$EI_BUF,3,8));
        IF ACCT < ' '
          THEN
           ACCT = ' ';
        CPVFSAVE = %YES#;
/* Position to the beginning of the data for this file */
        EI_PFILE.V.BOF# = %NO#;
        CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
NO_USER_LABEL:
        IF NOT INFILE_OPENED
          THEN DO;
           INFILE_OPENED = %YES#;
           NRECS = 0;
           NKY = 0;
           EO_BUF$ = EO_BUF$$.PTR$;
           ARS = -1;
           IF CONTINUED AND COPY_DATA
             THEN
              GOTO RETURN_SKIPPING;
           IF CPVFSAVE AND PPTRP(%CAT_ACCT#)
             THEN DO;
              P$ = PPTRS$(%CAT_ACCT#);
              IF ACCT ~= SUBSTR(B$TXC.C,0,B$TXC.L)
                THEN
                 GOTO RETURN_SKIPPING;
              END;
           WILD_CMP_FMT.OUTPUT_.BOUND = 511;
           WILD_CMP_FMT.INPUT_.BOUND = FNAME.L - 1;
           CALL X$WILDFMT (WILD_CMP_FMT) ALTRET (RETURN_SKIPPING);
           CALL SELECT_BY_FSN (FSN,LABEL_THATS_FAR_ENOUGH)
             ALTRET (RETURN_SKIPPING);
SELECT_THIS_FILE:
           DO CASE (CAT_FUN);
            CASE (%CAT_COPY#, %CAT_COPYALL#);
              IF PPTRP(%CAT_ACCTO#)
                THEN DO;
                 P$ = PPTRS$(%CAT_ACCTO#);
                 ACCTO = SUBSTR(B$TXC.C,0,B$TXC.L);
                 EO_OPEN.ACCT_ = VECTOR(ACCTO);
                 END;
                ELSE
                 EO_OPEN.ACCT_ = VECTOR(ERASE);
              IF PVALP(%CAT_EXIST#)
                THEN
                 EO_OPEN.V.EXIST# = PVALS(%CAT_EXIST#);
                ELSE
                 EO_OPEN.V.EXIST# = %ERROR#;
              CALL M$OPEN (EO_OPEN) ALTRET (CANT_OUTPUT);
            END;
           END;
        RETURN;
CANT_OUTPUT:
        CALL ALTERRMSG;
RETURN_SKIPPING:
        SKIP_FILE = %YES#;
        RETURN;
%EJECT;
CPV_SKIP_TAPE_FILE: ENTRY ALTRET;
        EI_PFILE.V.BOF# = %NO#;
        CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
        RETURN;
%EJECT;
CPV_COPY_TAPE_FILE: ENTRY ALTRET;
 
        IF ONLY_ONE_FILE
          THEN
           KEEP_ON_LOOKING = %NO#;
        REMEMBER READ_ANOTHER_RECORD IN LABEL_READ_ANOTHER_RECORD;
READ_UNTIL_EOF:
        ARSC = -1;
READ_ANOTHER_RECORD:
        IF NKY = 0
          THEN DO;
           EI_READ.BUF_ = EI_BUF$$;
           CALL READ_PHY ALTRET (GOT_AN_END_OF_FILE);
           CALL CPV_LD16X (NKY,B$EI_BUF_U9(2));
           PTR$ = PINCRW(EI_BUF$$.PTR$,1);
           END;
        DO WHILE (NKY > 0);
           KEY$ = PTR$;
           PTR$ = PINCRW(PTR$,KEYM/4+1);
           FLG.U9 = B$U9(0);
           IF FLG.P.SEGMENT_1
             THEN
              ARS = 0;
           CALL CPV_LD16X (RWS,B$U9(2));
           PTR$ = PINCRW(PTR$,1);
           IF COPY_DATA
             THEN DO;
              CALL GET_ENOUGH_MEMORY (ARS+RWS) ALTRET (CANT_GET_MEMORY);
              IF FLG.P.SEGMENT_1
                THEN DO;
                 EO_BUF$ = EO_BUF$$.PTR$;
                 IF ORG = %CPVKEYED#
                   THEN
                    KEY.L = KEY$->B$U9(0);
                   ELSE
                    KEY.L = 0;
                 IF KEYM = 3
                   THEN DO;
                    CALL CPV_LD24X (I,KEY$->B$U9(1));
                    KEY.V.U27 = I;
                    END;
                   ELSE
                    CALL XLATE (KEY.C,T_EBC2ASC,SUBSTR(KEY$->B$C,1,KEY.L));
                 END;
              IF FLG.P.UNBLOCKED
                THEN DO;
                 EI_READ.BUF_ = EO_BUF$$;
                 EI_READ.BUF_.BUF$ = EO_BUF$;
                 EI_READ.BUF_.BOUND = EI_READ.BUF_.BOUND - ARS;
                 CALL READ_PHY ALTRET (IO_ERROR);
                 END;
                ELSE
                 CALL INSERT (EO_BUF$->B$C,0,RWS,SUBSTR(B$C,0,RWS));
              ARS = ARS + RWS;
              EO_BUF$ = PINCRC(EO_BUF$,RWS);
              END;
             ELSE
              IF FLG.P.UNBLOCKED
                THEN DO;
                 EI_PRECORD.V.N# = 1;
                 CALL M$PRECORD (EI_PRECORD) ALTRET (IO_ERROR);
                 END;
           PTR$ = PINCRW(PTR$,(RWS+3)/4);
           NKY = NKY - 1;
           IF NOT FLG.P.CONTINUED AND CHECK_DATA AND ARS >= 0
             THEN DO;
              IF ARS = 108 AND
                 (B$EO_BUF_U9(0) = 24 OR B$EO_BUF_U9(0) = 56)
                THEN
                 COMPRESSED = %YES#;
                ELSE
                 COMPRESSED = %NO#;
              IF COPY_DATA
                THEN DO;
                 IF ARS > 0
                   THEN DO;
                    EO_WRITE.BUF_ = EO_BUF$$;
                    IF COMPRESSED OR BINARY
                      THEN DO;
                       CALL MOVE9X8 (B$EO_BUF,B$EO_BUF,ARS);
                       ARS = (ARS * 8 + 8) / 9;
                       END;
                      ELSE
                       CALL EBC2ASC (B$EO_BUF,B$EO_BUF,ARS);
                    EO_WRITE.BUF_.BOUND = ARS - 1;
                    END;
                   ELSE
                    EO_WRITE.BUF_ = VECTOR(NIL);
                 IF NOT COMPRESSED
                   THEN
                    CALL WRITE_PHY ALTRET (IO_ERROR);
                 END;
              IF COMPRESSED AND COPY_DATA
                THEN DO;
                 DO WHILE (%YES#);
                    CALL CPV_DCOM (ARSC,WORK512,B$EO_BUF,
                      LABEL_READ_ANOTHER_RECORD)
                      ALTRET (READ_UNTIL_EOF);
                    IF ARSC > 0
                      THEN DO;
                       EO_WRITE.BUF_ = VECTOR(SUBSTR(WORK512,0,ARSC));
                       CALL WRITE_PHY ALTRET (IO_ERROR);
                       NRECS = NRECS + 1;
                       END;
                    ARSC = -1;
                    END;
                 END;
              NRECS = NRECS + 1;
              ARS = -1;
              END;
           END;
        GOTO READ_ANOTHER_RECORD;
GOT_AN_END_OF_FILE:
        ALTRETURN;
%EJECT;
CPV_CLOSE_TAPE_FILE: ENTRY ALTRET;
        EI_READ.BUF_ = EI_BUF$$;
        CALL READ_PHY ALTRET (IO_ERROR);
        CALL XLATE (WORK64,T_EBC2ASC,SUBSTR(B$EI_BUF,0,4));
        IF SUBSTR(WORK64,0,4) = ':EOF'
          THEN DO;
           EI_PFILE.V.BOF# = %NO#;
           CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
           END;
          ELSE DO;
           EI_PRECORD.V.N# = -1;
           CALL M$PRECORD (EI_PRECORD) ALTRET (IO_ERROR);
           END;
        IF SUBSTR(WORK64,0,4) ~= ':EOV'
          THEN DO;
           INFILE_OPENED = %NO#;
           IF EO_DCB.FCD#
             THEN
              CALL M$CLOSE (EO_CLOSE) ALTRET (IO_ERROR);
           END;
        IF NOT SKIP_FILE
          THEN DO;
           IF ORG = %CPVKEYED#
             THEN
              CALL BINCHAR(SUBSTR(ORG_TX(2),1,2),KEYM);
           WORK64 = ORG_TX(ORG);
           CALL BINCHAR (WORK5,NRECS);
           CALL EDITCHAR (WORK64,4,5,MOP_5,WORK5);
           CALL BINCHAR(WORK5,FSN);
           CALL EDITCHAR (WORK64,10,5,MOP_5,WORK5);
           IF CPVFSAVE
             THEN
              CALL CONCAT (WORK9,'.',ACCT);
             ELSE
              WORK9 = ' ';
           CALL CONCAT (LO_BUF,SUBSTR(WORK64,0,16),
             SUBSTR(FNAME.C,0,FNAME.L),WORK9);
           IF SUBSTR(FNAME.C,0,FNAME.L) ~= SUBSTR(FNAMEO.C,0,FNAMEO.L)
             THEN DO;
              CALL INDEX1 (L,' ',LO_BUF,16);
              CALL INSERT (LO_BUF,L,,' -> ',SUBSTR(FNAMEO.C,0,FNAMEO.L));
              END;
           IF PRINT_HEADER
             THEN DO;
              CALL M$WRITE (LO_WRITE_SPACE);
              CALL M$WRITE (LO_WRITE_CPV_HEADER);
              PRINT_HEADER = %NO#;
              END;
           CALL M$WRITE (LO_WRITE);
           IF CONTINUED
             THEN DO;
              LO_BUF = ' ';
              CALL INSERT (LO_BUF,16,,'^ file continued from previous reel');
              CALL M$WRITE (LO_WRITE);
              END;
           IF INFILE_OPENED
             THEN DO;
              LO_BUF = ' ';
              CALL INSERT (LO_BUF,16,,'^ file continued on next reel');
              CALL M$WRITE (LO_WRITE);
              END;
           END;
        IF INFILE_OPENED
          THEN
           CONTINUED= %YES#;
          ELSE DO;
           CONTINUED = %NO#;
           FSN = FSN + 1;
           END;
        RETURN;
 
 
IO_ERROR:
        UNWIND TO LABEL_IO_ERROR;
CANT_GET_MEMORY:
        UNWIND TO LABEL_CANT_GET_MEMORY;
THATS_FAR_ENOUGH:
        EI_PFILE.V.BOF# = %YES#;
        CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
        CALL M$PFIL (EI_PFILE) ALTRET (IO_ERROR);
        EI_PRECORD.V.N# = 1;
        CALL M$PRECORD (EI_PRECORD) ALTRET (ITS_OK);
ITS_OK: UNWIND TO COMMAND_LEVEL;
 
END CPV_OPEN_TAPE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CPV_LOCCODE: PROC (P$PTR$,P$CODE) ALTRET;
/*
\
Parameters:
/
*/
DCL P$PTR$ PTR;
DCL P$CODE UBIN;
/*
\
Based Structures:
/
*/
DCL B$U9 (0:3) UBIN(9) UNAL BASED;
/*
\
Procedure:
/
*/
LOOK_AGAIN:
        IF P$PTR$->B$U9(0) = P$CODE
          THEN
           RETURN;
        IF P$PTR$->B$U9(1) = 0
          THEN DO;
           P$PTR$ = PINCRW(P$PTR$,P$PTR$->B$U9(3)+1);
           GOTO LOOK_AGAIN;
           END;
        ALTRETURN;
END CPV_LOCCODE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CPV_LD16X: PROC (P$VAL,P$U9);
DCL 1 P$VAL,
      2 * BIT(20) UNAL,
      2 U8 (0:1) UBIN(8) UNAL;
DCL P$U9 (0:1) UBIN(9) UNAL;
        P$VAL = '0'O;
        P$VAL.U8(0) = P$U9(0);
        P$VAL.U8(1) = P$U9(1);
        RETURN;
END CPV_LD16X;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CPV_LD24X: PROC (P$VAL,P$U9);
DCL 1 P$VAL,
      2 * BIT(12) UNAL,
      2 U8 (0:2) UBIN(8) UNAL;
DCL P$U9 (0:2) UBIN(9) UNAL;
        P$VAL = '0'O;
        P$VAL.U8(0) = P$U9(0);
        P$VAL.U8(1) = P$U9(1);
        P$VAL.U8(2) = P$U9(2);
        RETURN;
END CPV_LD24X;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CPV_DCOM:   PROC (P$L,PBUFO,P$BUFI,P$LABEL_NEED_MORE) ALTRET;
%EQU NO#='0'B;
%EQU YES#='1'B;
DCL P$L SBIN;
DCL PBUFO (0:0) UBIN(9) UNAL;
DCL 1 P$BUFI ALIGNED,
      2 IDENTIFICATION UBIN(8) UNAL,
      2 SEQUENCE UBIN(8) UNAL,
      2 CHECKSUM UBIN(8) UNAL,
      2 NBYTES UBIN(8) UNAL;
DCL P$LABEL_NEED_MORE BIT(72) DALIGNED;
DCL XCOM (0:63) CHAR(1) CONSTANT INIT
 (' ',' ',' ',' ',' ',' ',' ',' ',
  '0','1','2','3','4','5','6','7',
  '8','9','A','B','C','D','E','F',
  'G','H','I','J','K','L','M','N',
  'O','P','Q','R','S','T','U','V',
  'W','X','Y','Z','.','<','(','+',
  '|','&','$','*',')',';','~','-',
  '/',',','%','_','>',':','''','=');
DCL T_EBC2ASC (0:511) UBIN(9) UNAL SYMREF;
DCL BUF$ PTR STATIC;
DCL BUFBITS SBIN STATIC SYMDEF INIT (-1);
DCL C UBIN STATIC;
DCL I UBIN STATIC;
DCL N UBIN STATIC;
DCL X UBIN STATIC;
DCL REPROCESS BIT(1) STATIC INIT (%NO#);
DCL B$6 UBIN(6) UNAL BASED (BUF$);
DCL B$8 UBIN(8) UNAL BASED (BUF$);
        IF BUFBITS < 0
          THEN DO;
           BUF$ = PINCRB(ADDR(P$BUFI),32);
           BUFBITS = P$BUFI.NBYTES * 8 - 32;
           END;
        IF REPROCESS
          THEN
           GOTO PROCESS_IT;
NEXT_6:
        REPROCESS = %NO#;
        CALL GET6 (X);
PROCESS_IT:
        DO CASE (X);
         CASE (0,1);  /* Ignore, Not assigned */
           GOTO NEXT_6;
         CASE (2);  /* End of line */
           RETURN;
         CASE (3);  /* End of file */
           BUFBITS = -1;
           ALTRETURN;
         CASE (4);  /* Use 8-bit character that follows */
           REPROCESS = %YES#;
           CALL GET8 (C);
           N = 1;
           C = T_EBC2ASC(C);
         CASE (5);  /* Use n+1 blanks */
           REPROCESS = %YES#;
           CALL GET6 (N);
           N = N + 1;
           C = ASCBIN(' ');
         CASE (6);  /* Use n+65 blanks */
           REPROCESS = %YES#;
           CALL GET6 (N);
           N = N + 65;
           C = ASCBIN(' ');
         CASE (ELSE);  /* Translate from table */
           C = ASCBIN(XCOM(X));
           N = 1;
         END;
        IF P$L < 0
          THEN
           P$L = 0;
        DO I = 1 TO N;
           PBUFO(P$L) = C;
           P$L = P$L + 1;
           END;
 
        GOTO NEXT_6;
 
GET6:   PROC (P$C);
DCL P$C UBIN;
        BUFBITS = BUFBITS - 6;
        IF BUFBITS < 0
          THEN
           UNWIND TO P$LABEL_NEED_MORE;
        P$C = B$6;
        BUF$ = PINCRB(BUF$,6);
        REPROCESS = %NO#;
        RETURN;
END GET6;
 
GET8:   PROC (P$C);
DCL P$C UBIN;
        BUFBITS = BUFBITS - 8;
        IF BUFBITS < 0
          THEN
           UNWIND TO P$LABEL_NEED_MORE;
        P$C = B$8;
        BUF$ = PINCRB(BUF$,8);
        REPROCESS = %NO#;
        RETURN;
END GET8;
 
END CPV_DCOM;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
GCOS_OPEN_TAPE: PROC ALTRET;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE CAT_C61;
%INCLUDE B_MICROPS_C;
%INCLUDE XUW_MACRO_C;
/*
\
DCBs:
/
*/
DCL M$LO DCB;
/*
\
External Procedures:
/
*/
DCL OPEN_PHY_IN ENTRY ALTRET;
DCL READ_PHY ENTRY ALTRET;
DCL WRITE_PHY ENTRY ALTRET;
DCL SELECT_BY_FSN ENTRY (2) ALTRET;
DCL GET_ENOUGH_MEMORY ENTRY (1) ALTRET;
DCL ALTERRMSG ENTRY;
DCL X$WILDFMT ENTRY (1) ALTRET;
DCL BCD2ASC ENTRY (3);
DCL DUMP ENTRY (4);
/*
\
SYMREFs:
/
*/
DCL CAT_FUN UBIN ALIGNED SYMREF;
%FPT_OPEN(FPTN=EI_OPEN,STCLASS=SYMREF);
%FPT_REW(FPTN=EI_REWIND,STCLASS=SYMREF);
%FPT_PFIL(FPTN=EI_PFILE,STCLASS=SYMREF);
%FPT_PRECORD(FPTN=EI_PRECORD,STCLASS=SYMREF);
%FPT_READ(FPTN=EI_READ,STCLASS=SYMREF);
%FPT_OPEN(FPTN=EO_OPEN,STCLASS=SYMREF);
%FPT_WRITE(FPTN=EO_WRITE,STCLASS=SYMREF);
%FPT_CLOSE(FPTN=EO_CLOSE,STCLASS=SYMREF);
%FPT_WRITE(FPTN=DO_WRITE,STCLASS=SYMREF);
%FPT_WRITE(FPTN=LO_WRITE,STCLASS=SYMREF);
%FPT_WRITE(FPTN=LO_WRITE_SPACE,STCLASS=SYMREF);
DCL EI_DCB$ PTR ALIGNED SYMREF;
DCL EO_DCB$ PTR ALIGNED SYMREF;
%VLP_VECTOR(FPTN=EI_BUF$$,STCLASS=SYMREF);
%VLP_VECTOR(FPTN=EO_BUF$$,STCLASS=SYMREF);
DCL COMMAND_LEVEL BIT(72) DALIGNED SYMREF;
DCL LABEL_DO_ABORT BIT(72) DALIGNED SYMREF;
DCL LABEL_IO_ERROR BIT(72) DALIGNED SYMREF;
DCL LABEL_CANT_GET_MEMORY BIT(72) DALIGNED SYMREF;
DCL DO_BUF CHAR(120) ALIGNED SYMREF;
DCL LO_BUF CHAR(120) ALIGNED SYMREF;
DCL FSN UBIN ALIGNED SYMREF;
DCL SN CHAR(6) ALIGNED SYMREF;
DCL 1 FNAME ALIGNED SYMREF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL ACCTO CHAR(8) ALIGNED SYMREF;
DCL 1 FNAMEO ALIGNED SYMREF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL 1 KEY ALIGNED SYMREF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31) UNAL,
      2 V REDEF C,
        3 U27 UBIN(27) UNAL,
        3 * CHAR(28);
DCL EOF_IS_NEXT BIT(1) SYMREF;
DCL SKIP_FILE BIT(1) SYMREF;
DCL SKIP_COPY BIT(1) SYMREF;
DCL CHECK_DATA BIT(1) SYMREF;
DCL COPY_DATA BIT(1) SYMREF;
DCL DONT_REWIND BIT(1) SYMREF;
DCL PPTRS$(0:63) PTR ALIGNED SYMREF;
DCL PVALS(0:63) REDEF PPTRS$ SBIN;
DCL PPTRP(0:63) BIT(1) UNAL SYMREF;
DCL PVALP(0:63) REDEF PPTRP BIT(1) UNAL;
DCL PBITS(0:63) BIT(1) UNAL SYMREF;
DCL PBITP(0:63) BIT(1) UNAL SYMREF;
DCL T_XFID (0:127) UBIN(9) UNAL SYMREF;
/*
\
Constant Storage:
/
*/
DCL MOP_5 (0:1) BIT(9) CONSTANT INIT (%MVZB4,%MVC1);
DCL GCOS_HEADER CHAR(0) CONSTANT INIT ('ORG NRECS   FSN File Name');
DCL 1 TXC_Q CONSTANT  ALIGNED,
      2 L UBIN(9) UNAL INIT (1),
      2 C CHAR(1) UNAL INIT ('?');
/*
\
Static Data:
/
*/
%XUW_WILDCARD(FPTN=WILD_CMP_FMT,
               INPUT=FNAME.C,
               OUTPUT=FNAMEO.C,
               OUTPUT_LEN=511,
               CONTAINS=NO);
%FPT_WRITE(FPTN=LO_WRITE_GCOS_HEADER,DCB=M$LO,BUF=GCOS_HEADER);
DCL EO_BUF$ PTR STATIC;                 /* pointer to output record           */
DCL H$ PTR STATIC;                      /* pointer to file header area        */
DCL BCW$ PTR STATIC;          /* Pointer to first file block control word     */
DCL B$ PTR STATIC;                      /* pointer to file block control word */
DCL R$ PTR STATIC;                      /* pointer to record control word     */
DCL D$ PTR STATIC;                      /* pointer to data area               */
DCL P$ PTR STATIC;                      /* temporary parse pointer            */
DCL I SBIN STATIC;
DCL L SBIN STATIC;
DCL FL SBIN STATIC;
DCL ARS SBIN STATIC;
DCL TARS SBIN STATIC;
DCL LL UBIN STATIC;                     /* little link number                 */
DCL NBSN SBIN STATIC;              /* next block sequence number expected     */
DCL RECN UBIN STATIC;              /* input record number of current file     */
DCL NRECS SBIN STATIC;
DCL FLAG BIT(1);
DCL 1 TAPE_LABEL STATIC,
      2 LID CHAR(12),                   /* label identifier (GE 600 BTL )     */
      2 IID CHAR(6),                    /* installation identification        */
      2 * CHAR(1),
      2 TSN CHAR(5),                    /* tape reel serial number            */
      2 * CHAR(1),
      2 FSN CHAR(5),                    /* file serial number                 */
      2 * CHAR(2),
      2 RSN CHAR(4),                    /* reel sequence number               */
      2 * CHAR(1),
      2 JDT CHAR(5),                    /* creation date YYDDD                */
      2 * CHAR(6),                      /* retention days                     */
      2 FNAME CHAR(12),                 /* file name                          */
      2 * CHAR(18),
      2 * CHAR(6);
DCL 1 FILE_HEADER STATIC,               /* save tape file content header      */
      2 RECORD_CODE UBIN(4) UNAL,       /* record code                        */
      2 * BIT(32) UNAL,
      2 * (0:2) BIT(36) UNAL,           /* user name                          */
      2 CREATION_DATE UBIN(36),         /* creation date                      */
      2 * BIT(36),
      2 CONTINUATION BIT(1) UNAL INIT(%YES#),
      2 LL_IN_REC UBIN(4) UNAL INIT (1),
      2 * BIT(31) UNAL,
      2 PARTIAL_FILE BIT(1) UNAL INIT (%NO#),
      2 * BIT(11) UNAL,
      2 TOTAL_FILE_SIZE UBIN(24) UNAL,  /* total file size                    */
      2 * (0:1) BIT(36),
      2 FILE_NAME (0:11) UBIN(6) UNAL INIT (52,37,34,37,38,54,37,16*5);
DCL WORK5 CHAR(5) STATIC;
DCL WORK6 CHAR(6) STATIC;
DCL CDATE CHAR(8) STATIC;
DCL FILESYS_TAPE BIT(1) STATIC;
DCL MASTER_SAVE BIT(1) STATIC;
DCL CONTINUED BIT(1) STATIC;
DCL PARTIAL_FILE BIT(1) STATIC;
DCL PRINT_HEADER BIT(1) STATIC INIT (%YES#);
DCL REWOUND BIT(1) STATIC INIT (%NO#);
DCL NEXT_RECORD_IN_BUF BIT(1) STATIC;
DCL EOF_PASSED BIT(1) STATIC INIT (%NO#);
DCL EOT_PASSED BIT(1) STATIC INIT (%NO#);
DCL BCD BIT(1);
DCL FORMATTED BIT(1) STATIC;
DCL UNFORMATTED BIT(1) STATIC;
/*
\
Based Structures:
/
*/
DCL B$EI_BUF CHAR(4096) BASED (EI_BUF$$.PTR$);
DCL B$EI_BUF_U18 (0:2047) UBIN(18) UNAL BASED (EI_BUF$$.PTR$);
DCL B$C CHAR(4096) BASED;
DCL B$VCHAR CHAR(I) BASED CALIGNED;
DCL 1 B$TXC BASED (P$),
      2 L UBIN(9) UNAL,
      2 C CHAR(31) UNAL;
DCL 1 B$HEADER BASED (H$),              /* save tape file content header      */
      2 RECORD_CODE UBIN(4) UNAL,       /* record code                        */
      2 * BIT(32) UNAL,
      2 * (0:2) BIT(36) UNAL,           /* user name                          */
      2 CREATION_DATE UBIN(36),         /* creation date                      */
      2 * BIT(36),
      2 CONTINUATION BIT(1) UNAL,       /* continued from previous record     */
      2 LL_IN_REC UBIN(4) UNAL,         /* llinks in this record              */
      2 * BIT(31) UNAL,
      2 PARTIAL_FILE BIT(1) UNAL,       /* entire file not saved              */
      2 * BIT(11) UNAL,
      2 TOTAL_FILE_SIZE UBIN(24) UNAL,  /* total file size                    */
      2 * (0:1) BIT(36),
      2 FILE_NAME (0:11) UBIN(6) UNAL,  /* file name                          */
      2 * (0:51) BIT(36);
DCL 1 B$BCW BASED (B$),                 /* block control word                 */
      2 BSN UBIN(18) UNAL,              /* block serial number                */
      2 BSZ UBIN(18) UNAL;              /* block size                         */
DCL 1 B$RCW BASED (R$),                 /* record control word                */
      2 RSZ UBIN(18) UNAL,              /* record size                        */
      2 NAC UBIN(2) UNAL,               /* next available character position  */
      2 EOF BIT(4) UNAL,                /* EOF marker ('17'O)                 */
      2 SEG UBIN(2) UNAL,               /* segment code                       */
      2 LRM UBIN(4) UNAL,               /* logical record media code          */
      2 RPC BIT(6) UNAL;                /* report code                        */
DCL 1 B$FC6 BASED(D$) UNAL,
    2 FL UBIN(6) UNAL,
    2 SL UBIN(6) UNAL;
DCL 1 B$FC9 BASED(D$) CALIGNED,
    2 FL UBIN(9) CALIGNED,
    2 SL UBIN(9) CALIGNED;
DCL 1 B$COMDK BASED(D$) ALIGNED,
    2 W1,
        3 TYPE UBIN(3) UNAL,
        3 BCD UBIN(6) UNAL,
        3 * BIT(3) UNAL,
        3 SN UBIN(24) UNAL,
    2 CKSUM UBIN WORD ALIGNED;
DCL B$320 (0:15) CHAR(1280) BASED (BCW$);
%F$DCB(DCBN=EI_DCB,BASED="BASED(EI_DCB$)");
%F$DCB(DCBN=EO_DCB,BASED="BASED(EO_DCB$)");
/*
\
Procedure:
/
*/
        REWOUND = %NO#;
        EOT_PASSED = %NO#;
        CALL OPEN_PHY_IN ALTRET (IO_ERROR);
        DO WHILE (%NO#);
TEST_REWOUND:
           IF REWOUND
             THEN
              GOTO IO_ERROR;
TRY_REWINDING:
           IF NOT DONT_REWIND
             THEN
              CALL M$REW (EI_REWIND) ALTRET (IO_ERROR);
           REWOUND = %YES#;
           END;
        EI_READ.V.DVBYTE.BIN# = %YES#;
        CALL READ_PHY ALTRET (TEST_REWOUND);
        CALL BCD2ASC (TAPE_LABEL,B$EI_BUF,74);
        IF TAPE_LABEL.LID ~= 'GE  600 BTL '
          THEN DO;
           IF NOT REWOUND
             THEN
              GOTO TRY_REWINDING;
           DO_BUF = 'First record of a GCOS save tape should be GE  600 BTL ';
           UNWIND TO LABEL_DO_ABORT;
           END;
        SN = TAPE_LABEL.TSN;
        CALL INDEX1 (L,' ',SN);
        CALL INDEX1 (I,' ',TAPE_LABEL.FSN);
        CALL CONCAT (LO_BUF,'GT#',SUBSTR(SN,0,L),
          '(',SUBSTR(TAPE_LABEL.FSN,0,I),') ',TAPE_LABEL.FNAME);
        EOF_IS_NEXT = %YES#;
        IF TAPE_LABEL.RSN ~= '0001'
          THEN DO;
           DO WHILE (EI_DCB.ARS# ~= 264);
              CALL READ_PHY ALTRET (IO_ERROR);
              END;
           CALL CONCAT(CDATE,SUBSTR(TAPE_LABEL.JDT,0,2),'/',
                             SUBSTR(TAPE_LABEL.JDT,2,3));
           CALL INSERT(LO_BUF,55,,'(Not 1st Reel)');
           END;
          ELSE
           CALL READ_PHY ALTRET (IO_ERROR);
        IF EI_DCB.ARS# = 264
          THEN DO;
           FILESYS_TAPE = %YES#;
           MASTER_SAVE = %NO#;
           IF TAPE_LABEL.RSN = '0001'
             THEN DO;
              CALL READ_PHY ALTRET (IO_ERROR);
              CALL BCD2ASC (WORK6,SUBSTR(B$EI_BUF,8),6);
              IF SUBSTR(WORK6,0,6) ~= 'SAVHDR'
                THEN DO;
                 DO_BUF = 'This tape is not a GCOS save tape.';
                 UNWIND TO LABEL_DO_ABORT;
                 END;
              CALL BCD2ASC (WORK6,SUBSTR(B$EI_BUF,12),6);
              CALL CONCAT (CDATE,SUBSTR(WORK6,0,2),'/',SUBSTR(WORK6,2,2),
                '/',SUBSTR(WORK6,4,2));
              IF B$EI_BUF_U18(22) = 1
                THEN DO;
                 MASTER_SAVE = %YES#;
                 CALL INSERT (LO_BUF,55,,'(master save)');
                 END;
                ELSE
                 CALL INSERT (LO_BUF,55,,'(user save)');
              END;
           END;
          ELSE DO;
           FILESYS_TAPE = %NO#;
           MASTER_SAVE = %NO#;
           CALL CONCAT (CDATE,SUBSTR(TAPE_LABEL.JDT,0,2),'-',
             SUBSTR(TAPE_LABEL.JDT,2,3));
           CALL INSERT (LO_BUF,55,,'(utility save)');
           END;
        CALL INSERT (LO_BUF,31,22,'creation date=',CDATE);
        CALL M$WRITE (LO_WRITE_SPACE);
        CALL M$WRITE (LO_WRITE);
        IF FILESYS_TAPE
          THEN DO;
           IF MASTER_SAVE
             THEN                       /* Skip SMC records                   */
              CALL GCOS_SKIP_TO_LOGICAL_EOF ALTRET (IO_ERROR);
                                        /* Skip Substructure records          */
           IF TAPE_LABEL.RSN = '0001' THEN
              CALL GCOS_SKIP_TO_LOGICAL_EOF ALTRET (IO_ERROR);
           H$ = PINCRW(EI_BUF$$.PTR$,2);
           BCW$ = PINCRW(EI_BUF$$.PTR$,66);
           NEXT_RECORD_IN_BUF = %NO#;
           END;
          ELSE DO;
           H$ = ADDR(FILE_HEADER);
           BCW$ = EI_BUF$$.PTR$;
           NEXT_RECORD_IN_BUF = %YES#;
           END;
        PRINT_HEADER = %YES#;
 
        RETURN;
%EJECT;
GCOS_OPEN_TAPE_FILE: ENTRY ALTRET;
        IF EOT_PASSED
          THEN
           IF FILESYS_TAPE
             THEN
              GOTO NO_MORE_FILES;
             ELSE DO;
              CALL READ_PHY ALTRET (NO_MORE_FILES);
              CALL BCD2ASC (TAPE_LABEL,B$EI_BUF,74);
              IF SUBSTR(TAPE_LABEL.LID,0,4) ~= ' EOF'
                THEN
                 GOTO NO_MORE_FILES;
                ELSE DO;
                 EOF_IS_NEXT = %YES#;
                 CALL READ_PHY ALTRET (NO_MORE_FILES);
                 CALL BCD2ASC (TAPE_LABEL,B$EI_BUF,74);
                 IF TAPE_LABEL.LID ~= 'GE  600 BTL '
                   THEN
                    GOTO NO_MORE_FILES;
                   ELSE DO;
                    EOT_PASSED = %NO#;
                    NEXT_RECORD_IN_BUF = %NO#;
                    EOF_IS_NEXT = %YES#;
                    END;
                 END;
              END;
        IF NOT NEXT_RECORD_IN_BUF
          THEN
           CALL READ_PHY ALTRET (NO_MORE_FILES);
        CONTINUED = B$HEADER.CONTINUATION;
        PARTIAL_FILE = B$HEADER.PARTIAL_FILE;
        FNAME.C = ' ';
        CALL BCD2ASC (FNAME.C,B$HEADER.FILE_NAME,12);
        CALL XLATE (FNAME.C,T_XFID,FNAME.C);
        IF NOT FILESYS_TAPE AND FNAME.C = 'UNKNOWN'
          THEN DO;
           CALL BINCHAR (WORK5,FSN);
           CALL CONCAT (FNAME.C,'UNKNOWN-',WORK5);
           END;
        CALL INDEX (L,' ',FNAME.C);
        FNAME.L = L;
        IF PPTRP(%CAT_FNAME#)
          THEN DO;
           WILD_CMP_FMT.PATTERN_ = VECTOR(PPTRS$(%CAT_FNAME#)->B$TXC.C);
           WILD_CMP_FMT.PATTERN_.BOUND = PPTRS$(%CAT_FNAME#)->B$TXC.L - 1;
           END;
          ELSE DO;
           WILD_CMP_FMT.PATTERN_ = VECTOR ( TXC_Q.C ) ;
           END;
        IF PPTRP(%CAT_FNAMEO#)
          THEN
           WILD_CMP_FMT.TEMPLATE_ = VECTOR(PPTRS$(%CAT_FNAMEO#)->B$TXC.C);
          ELSE
           WILD_CMP_FMT.TEMPLATE_ = VECTOR(FNAME.C);
        FNAMEO.L = FNAME.L;
        EO_OPEN.V.ORG# = %CONSEC#;
        EO_OPEN.V.ACS# = %SEQUEN#;
        EO_WRITE.KEY_ = VECTOR(NIL);
         WILD_CMP_FMT.OUTPUT_ = VECTOR ( FNAMEO.C ) ;
         WILD_CMP_FMT.INPUT_.BOUND = FNAME.L - 1;
        CALL X$WILDFMT (WILD_CMP_FMT) ALTRET (RETURN_SKIPPING);
        CALL SELECT_BY_FSN (FSN,COMMAND_LEVEL) ALTRET (RETURN_SKIPPING);
SELECT_THIS_FILE:
        DO CASE (CAT_FUN);
         CASE (%CAT_COPY#, %CAT_COPYALL#);
           IF PPTRP(%CAT_ACCTO#)
             THEN DO;
              P$ = PPTRS$(%CAT_ACCTO#);
              ACCTO = SUBSTR(B$TXC.C,0,B$TXC.L);
              EO_OPEN.ACCT_ = VECTOR(ACCTO);
              END;
             ELSE
              EO_OPEN.ACCT_ = VECTOR(ERASE);
           IF PVALP(%CAT_EXIST#)
             THEN
              EO_OPEN.V.EXIST# = PVALS(%CAT_EXIST#);
             ELSE
              EO_OPEN.V.EXIST# = %ERROR#;
           CALL M$OPEN (EO_OPEN) ALTRET (CANT_OUTPUT);
         END;
        NEXT_RECORD_IN_BUF = %YES#;
        RECN = 1;
        NRECS = 0;
        RETURN;
CANT_OUTPUT:
        CALL ALTERRMSG;
RETURN_SKIPPING:
        SKIP_FILE = %YES#;
        RETURN;
NO_MORE_FILES:
        ALTRETURN;
%EJECT;
GCOS_SKIP_TAPE_FILE: ENTRY ALTRET;
        SKIP_FILE = %YES#;
%EJECT;
GCOS_COPY_TAPE_FILE: ENTRY ALTRET;
        NEXT_RECORD_IN_BUF = %NO#;
        EOF_PASSED = %NO#;
        UNFORMATTED = %NO#;
                             /*   Reset output buffer   */
              ARS = 0;
              TARS=0;
              EO_BUF$ = EO_BUF$$.PTR$;
        EO_BUF$ = EO_BUF$$.PTR$;
        NBSN = 1;                  /* next block sequence number expected     */
        DO WHILE (%YES#);
           IF NOT SKIP_FILE AND PBITS(%CAT__DUMP#)
             THEN DO;
              L = EI_DCB.ARS#;
              CALL DUMP (FSN,RECN,B$EI_BUF,L);
              END;
           IF NOT SKIP_FILE AND NOT EOF_PASSED
             THEN DO;
              DO LL = 0 TO B$HEADER.LL_IN_REC-1;
                 B$ = PINCRW(BCW$,320*LL);
                 IF NOT UNFORMATTED AND
                  (B$BCW.BSN = 1 OR B$BCW.BSN = NBSN)
                   THEN DO;
                    FORMATTED = %YES#;
                    NBSN = B$BCW.BSN;
                    END;
                   ELSE DO;
                    FORMATTED = %NO#;
                    UNFORMATTED = %YES#;
                    NBSN = -1;
                    END;
                 IF FORMATTED
                   THEN DO;
                    NBSN = NBSN + 1;
                    R$ = PINCRW(B$,1);
PROCESS_NEXT_REC_IN_BLOCK:
                    IF B$RCW.RSZ > 0
                      THEN DO;
                       D$ = PINCRW(R$,1); /* pointer to data                  */
                       DO CASE (B$RCW.LRM); /* logical record media code      */
                        CASE (0, 2, 3, 9); /* BCD records                     */
                          IF NOT SKIP_COPY
                            THEN DO;
                             L = B$RCW.RSZ * 6;
                             CALL GET_ENOUGH_MEMORY (ARS+L)
                               ALTRET (CANT_GET_MEMORY);
                             CALL BCD2ASC (EO_BUF$->B$C,D$->B$C,L);
                             EO_BUF$ = PINCRC(EO_BUF$,L);
                             ARS = ARS + L;
                             END;
                        CASE (1);       /* BIN records                        */
                    BCD=(B$COMDK.W1.BCD=0);
                    D$=PINCRW(D$,SIZEW(B$COMDK));
                    FLAG='0'B;
                    DO WHILE (NOT FLAG);
                        IF BCD THEN
                        FL=B$FC6.FL;
                        ELSE
                        FL=B$FC9.FL;
                        DO CASE(FL);
                        CASE(0,62);
                            FLAG='1'B;
                        CASE(63);
                            IF NOT SKIP_COPY THEN DO;
                                IF TARS=0 THEN DO;
                                    TARS=1;
                                    I=1;
                                    EO_BUF$$.PTR$->B$VCHAR=' ';
                                    END;
                                EO_WRITE.BUF_=EO_BUF$$;
                                EO_WRITE.BUF_.BOUND=TARS-1;
                                CALL WRITE_PHY ALTRET(IO_ERROR);
                                TARS=0;
                                EO_BUF$=EO_BUF$$.PTR$;
                                END;
                            NRECS=NRECS+1;
                            IF BCD THEN
                            D$=PINCRB(D$,SIZEB(B$FC6.FL));
                            ELSE
                            D$=PINCRB(D$,SIZEB(B$FC9.FL));
                        CASE(ELSE);
                            IF BCD THEN DO;
                            L=B$FC6.SL;
                            D$=PINCRB(D$,SIZEB(B$FC6));
                            END;
                            ELSE DO;
                            L=B$FC9.SL;
                            D$=PINCRB(D$,SIZEB(B$FC9));
                            END;
                            IF NOT SKIP_COPY THEN DO;
                                CALL GET_ENOUGH_MEMORY(FL)
                                   ALTRET(CANT_GET_MEMORY);
                                IF FL>L THEN DO;
                                    I=FL-L;
                                    EO_BUF$->B$VCHAR=' ';
                                    EO_BUF$=PINCRC(EO_BUF$,I);
                                    END;
                                IF BCD THEN
                                CALL BCD2ASC(EO_BUF$->B$C,D$->B$C,L);
                                    ELSE
                                        SUBSTR(EO_BUF$->B$C,0,L)=SUBSTR(D$->B$C,0,L);
                                EO_BUF$=PINCRC(EO_BUF$,L);
                                TARS=TARS+FL;
                                END;
                            IF BCD THEN
                            D$=PINCRB(D$,L*6);
                            ELSE
                            D$=PINCRB(D$,L*9);
                            END;
                        END; /* WHILE */
                    GOTO SKIP_TO_NEXT_RCW;
                        CASE (8);       /* TSS information records (ignore)   */
                          GOTO SKIP_TO_NEXT_RCW;
                        CASE (ELSE);
                          IF NOT SKIP_COPY
                            THEN DO;
                             L = B$RCW.RSZ * 4;
                             CALL GET_ENOUGH_MEMORY (ARS+L)
                               ALTRET (CANT_GET_MEMORY);
                             CALL INSERT (EO_BUF$->B$C,0,L,D$->B$C);
                             ARS = ARS + L;
                             EO_BUF$ = PINCRC(EO_BUF$,L);
                             END;
                        END;
                       IF B$RCW.SEG = 0 OR B$RCW.SEG = 3
                         THEN DO;
                          IF NOT SKIP_COPY
                            THEN DO;
                             ARS = ARS - MOD(4-B$RCW.NAC,4);
                             IF ARS > 0
                               THEN DO;
                                EO_WRITE.BUF_ = EO_BUF$$;
                                EO_WRITE.BUF_.BOUND = ARS - 1;
                                CALL WRITE_PHY ALTRET (IO_ERROR);
                                END;
                               ELSE
                                NRECS = NRECS - 1; /* adjust for add later    */
                             ARS = 0;
                             EO_BUF$ = EO_BUF$$.PTR$;
                             END;
                          NRECS = NRECS + 1;
                          END;
                       END;
SKIP_TO_NEXT_RCW:
                    R$ = PINCRW(R$,B$RCW.RSZ+1);
                    IF POFFW(R$,B$) <= B$BCW.BSZ
                      THEN
                       IF B$RCW.EOF
                         THEN DO;
                          EOF_PASSED = %YES#;
                          GOTO SKIP_TO_NEXT_RECORD;
                          END;
                         ELSE
                          GOTO PROCESS_NEXT_REC_IN_BLOCK;
                    END;
                   ELSE DO;
                    IF NOT SKIP_COPY
                      THEN DO;
                       EO_WRITE.BUF_ = VECTOR(B$320(LL));
                       CALL WRITE_PHY ALTRET (IO_ERROR);
                       END;
                    NRECS = NRECS + 1;
                    END;
                 END;
              END;
SKIP_TO_NEXT_RECORD:
           CALL READ_PHY ALTRET (AT_EOT);
           RECN = RECN + 1;
           IF NOT B$HEADER.CONTINUATION
             THEN DO;
              NEXT_RECORD_IN_BUF = %YES#;
              RETURN;
              END;
           END;
AT_EOT:
        EOT_PASSED = %YES#;
        RETURN;
%EJECT;
GCOS_CLOSE_TAPE_FILE: ENTRY ALTRET;
        IF NOT SKIP_FILE
          THEN DO;
           IF EO_DCB.FCD#
             THEN
              CALL M$CLOSE (EO_CLOSE) ALTRET (IO_ERROR);
           LO_BUF = 'CON';
           CALL BINCHAR (WORK5,NRECS);
           CALL EDITCHAR (LO_BUF,4,5,MOP_5,WORK5);
           CALL BINCHAR (WORK5,FSN);
           CALL EDITCHAR (LO_BUF,10,5,MOP_5,WORK5);
           CALL INSERT (LO_BUF,16,,SUBSTR(FNAME.C,0,FNAME.L));
           IF SUBSTR(FNAME.C,0,FNAME.L) ~= SUBSTR(FNAMEO.C,0,FNAMEO.L)
             THEN
              CALL INSERT (LO_BUF,16+FNAME.L,,' -> ',
                SUBSTR(FNAMEO.C,0,FNAMEO.L));
           IF PRINT_HEADER
             THEN DO;
              CALL M$WRITE (LO_WRITE_SPACE);
              CALL M$WRITE (LO_WRITE_GCOS_HEADER);
              PRINT_HEADER = %NO#;
              END;
           CALL M$WRITE (LO_WRITE);
           IF UNFORMATTED
             THEN DO;
              LO_BUF = ' ';
              CALL INSERT (LO_BUF,16,,'^ file contains unformatted data');
              CALL M$WRITE (LO_WRITE);
              END;
           END;
        FSN = FSN + 1;
        RETURN;
%EJECT;
GCOS_SKIP_TO_LOGICAL_EOF: PROC ALTRET;
        DO WHILE (%YES#);
           CALL READ_PHY ALTRET (IO_ERROR);
           CALL GCOS_IF_EOF_RECORD ALTRET (PROG_RETURN);
           END;
PROG_RETURN:
        RETURN;
IO_ERROR:
        ALTRETURN;
END GCOS_SKIP_TO_LOGICAL_EOF;
 
 
GCOS_IF_EOF_RECORD: PROC ALTRET;
        IF EI_DCB.ARS# = 264 AND
          B$EI_BUF_U18(3) = BITBIN('170017'O)
          THEN
           ALTRETURN;
        RETURN;
END GCOS_IF_EOF_RECORD;
 
IO_ERROR:
        UNWIND TO LABEL_IO_ERROR;
CANT_GET_MEMORY:
        UNWIND TO LABEL_CANT_GET_MEMORY;
 
END GCOS_OPEN_TAPE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DUMP:  PROC (P$F#,P$R#,P$BUF,P$L) NOAUTO;
%INCLUDE CP_6;
DCL P$F# UBIN;
DCL P$R# UBIN;
DCL P$BUF (0:1) CHAR(1) UNAL;
DCL P$BUF6 (0:2) REDEF P$BUF UBIN(6) UNAL;
DCL P$BUF3 (0:5) REDEF P$BUF UBIN(3) UNAL;
DCL P$L UBIN;
DCL M$LO DCB;
DCL OD (0:7) CHAR(1) CONSTANT INIT ('0','1','2','3','4','5','6','7');
DCL BC (0:63) CONSTANT CHAR(1) INIT
    ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
     '[', '#', '@', ':', '>', '?', ' ', 'A', 'B', 'C',
     'D', 'E', 'F', 'G', 'H', 'I', '&', '.', ']', '(',
     '<', '\', '^', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
     'Q', 'R', '-', '$', '*', ')', ';', '''', '+', '/',
     'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', ',',
     '%', '=', '"', '!');
%FPT_WRITE(FPTN=LO_WRITE,DCB=M$LO,BUF=LO_BUF);
DCL LO_BUF CHAR(132) STATIC;
DCL LB CHAR(132) STATIC;
DCL I UBIN;
DCL X UBIN;
DCL I3 UBIN;
DCL II3 UBIN;
DCL X3 UBIN;
DCL L3 UBIN;
DCL I6 UBIN;
DCL X6 UBIN;
DCL L6 UBIN;
DCL K UBIN;
DCL W UBIN;
DCL XW UBIN;
DCL C CHAR(1);
        C = ' ';
        LB = ' ';
        L3 = P$L * 3;
        L6 = (L3 + 1) / 2;
        LO_BUF = ' ';
        CALL M$WRITE (LO_WRITE);
        LO_BUF = 'file# = xxxxx; record# = xxxxx; ARS = xxxxx';
        CALL BINCHAR (SUBSTR(LO_BUF,8,5),P$F#);
        CALL BINCHAR (SUBSTR(LO_BUF,25,5),P$R#);
        CALL BINCHAR (SUBSTR(LO_BUF,38,5),P$L);
        CALL M$WRITE (LO_WRITE);
        X = 0;
        X3 = 0;
        X6 = 0;
        XW = ((P$L - 1) / 16) * 4;
        DO W = 0 TO XW BY 4;
           LO_BUF = ' ';
           K = 7;
           DO I3 = X3 TO X3+47 BY 12;
              DO II3 = I3 TO I3+5;
                 IF II3 >= L3
                   THEN
                    GOTO FMT_BCD;
                 CALL INSERT (LO_BUF,K,1,OD(P$BUF3(II3)));
                 K = K + 1;
                 END;
              CALL INSERT (LO_BUF,K,1,'.');
              K = K + 1;
              DO II3 = I3+6 TO I3+11;
                 IF II3 >= L3
                   THEN
                    GOTO FMT_BCD;
                 CALL INSERT (LO_BUF,K,1,OD(P$BUF3(II3)));
                 K = K + 1;
                 END;
              K = K + 2;
              END;
           X3 = X3 + 48;
FMT_BCD:
           K = 80;
           DO I6 = X6 TO X6+23;
              IF I6 >= L6
                THEN
                 GOTO FMT_ASC;
              CALL INSERT (LO_BUF,K,1,BC(P$BUF6(I6)));
              K = K + 1;
              END;
           X6 = X6 + 24;
FMT_ASC:
           K = 110;
           DO I = X TO X+15;
              IF I >= P$L
                THEN
                 GOTO WRITE_IT;
              IF P$BUF(I) < ' ' OR P$BUF(I) >= BITASC('177'O)
                THEN
                 CALL INSERT (LO_BUF,K,1,'.');
                ELSE
                 CALL INSERT (LO_BUF,K,1,P$BUF(I));
              K = K + 1;
              END;
           X = X + 16;
WRITE_IT:
           IF LB ~= LO_BUF OR W = XW
             THEN DO;
              LB = LO_BUF;
              CALL BINCHAR (SUBSTR(LO_BUF,0,5),W);
              CALL INSERT (LO_BUF,5,1,C);
              CALL M$WRITE (LO_WRITE);
              C = ' ';
              END;
             ELSE
              C = '*';
           END;
        RETURN;
END DUMP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
GP:     PROC (P$PCB,P$PARAMP,P$PARAM,P$BPARAMP,P$BPARAM);
%INCLUDE CP_6_SUBS;
%INCLUDE CAT_C62;
%INCLUDE XU_MACRO_C;
/*
\
Parameters:
/
*/
%P$PCB(NAME=P$PCB,STCLASS=" ");
DCL P$PARAMP (0:0) BIT(1) UNAL;
DCL P$PARAM (0:0) UBIN UNAL;
DCL P$PTR$ (0:0) REDEF P$PARAM PTR;
DCL P$BPARAMP (0:0) BIT(1) UNAL;
DCL P$BPARAM (0:0) BIT(1) UNAL;
/*
\
External Procedures:
/
*/
DCL GPX ENTRY (4);
/*
\
Static Data:
/
*/
DCL 1 GP_PTRS ALIGNED STATIC SYMDEF,
      2 PTR$ (0:4) PTR ALIGNED,
      2 P (0:4) BIT(1) UNAL;
DCL I SBIN ALIGNED STATIC;
/*
\
Procedure:
/
*/
        GP_PTRS.PTR$(0) = ADDR(P$PCB);
        GP_PTRS.PTR$(1) = ADDR(P$PARAMP);
        GP_PTRS.PTR$(2) = ADDR(P$PARAM);
        GP_PTRS.PTR$(3) = ADDR(P$BPARAMP);
        GP_PTRS.PTR$(4) = ADDR(P$BPARAM);
        DO I = 0 TO 4;
           IF GP_PTRS.PTR$(I) = ADDR(NIL)
             THEN
              GP_PTRS.P(I) = %NO#;
             ELSE
              GP_PTRS.P(I) = %YES#;
           END;
        IF P$PCB.OUT$ = ADDR(NIL)
          THEN
           RETURN;
        CALL GPX (P$PCB.OUT$,0,0,1);
        RETURN;
END GP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
 
GPX:    PROC (P$BLK$,P$CODE,P$BIAS,P$SIGN);
%INCLUDE CP_6_SUBS;
%INCLUDE CAT_C62;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_SUBS_C;
/*
\
Parameters:
/
*/
DCL P$BLK$ PTR ALIGNED;
DCL 1 P$CODE,
      2 VAL UBIN(10) UNAL,
      2 V REDEF VAL,
        3 TYPE UBIN(3) UNAL,
        3 T REDEF TYPE,
          4 STOP BIT(1) UNAL,
          4 VAL REDEF STOP BIT(1) UNAL,
          4 TYPE UBIN(2) UNAL,
        3 INDX UBIN(7) UNAL,
        3 BIAS REDEF INDX UBIN(7) UNAL;
DCL P$BIAS UBIN ALIGNED;
DCL P$SIGN SBIN ALIGNED;
/*
\
External Procedures:
/
*/
DCL PVALUE ENTRY (3);
/*
\
Constants:
/
*/
DCL END_NODE (0:35) BIT(1) UNAL CONSTANT
   INIT ('0'B,'0'B*3,'1'B*4,'0'B,'1'B*27);
/*
\
SYMREFs:
/
*/
DCL 1 GP_PTRS ALIGNED SYMREF,
      2 PTR$ (0:4) PTR ALIGNED,
      2 P (0:4) BIT(1) UNAL;
/*
\
Static Data:
/
*/
DCL STOP BIT(1) STATIC;
DCL TBIT BIT(1) STATIC;
/*
\
Auto Data:
/
*/
DCL 1 CODE UNAL,
      2 VAL UBIN(10) UNAL,
      2 V REDEF VAL UNAL,
        3 TYPE UBIN(3) UNAL,
        3 T REDEF TYPE UNAL,
          4 STOP BIT(1) UNAL,
          4 VAL REDEF STOP BIT(1) UNAL,
          4 TYPE UBIN(2) UNAL,
        3 INDX UBIN(7) UNAL,
        3 BIAS REDEF INDX UBIN(7) UNAL;
DCL I SBIN;
DCL TYPE SBIN;
DCL BIAS UBIN;
DCL INDX UBIN;
DCL SIGN SBIN;
/*
\
Based Structures:
/
*/
%PARSE$OUT(NAME=N_BLK,STCLASS=BASED);
%PARSE$SYM(NAME=T_BLK,STCLASS=BASED);
DCL B$BIT (0:0) BIT(1) UNAL BASED;
DCL B$PTR$ (0:0) PTR ALIGNED BASED;
DCL B$UBIN (0:0) UBIN ALIGNED BASED;
DCL B$SBIN (0:0) SBIN ALIGNED BASED;
/*
\
Procedure:
/
*/
        BIAS = P$BIAS;
        SIGN = P$SIGN;
        INDX = P$CODE.V.INDX;
        P$BLK$->N_BLK.TEMP = %NO#;
        CODE.VAL = P$BLK$->N_BLK.CODE;
        IF CODE.V.TYPE ~= %GP#PASS AND
          CODE.V.TYPE ~= %GP#BIAS
          THEN
           INDX = CODE.V.INDX;
        INDX = INDX + BIAS;
        DO CASE (CODE.V.TYPE);
         CASE (%GP#PASS);
           IF CODE.VAL >= 121           /* 121 - 127 Reserved                 */
             THEN DO;
              P$BLK$->N_BLK.TEMP = %YES#; /* We're done with this one         */
              SIGN = CODE.VAL - 122; P$SIGN = SIGN;
              IF SIGN = 5               /* Reset SIGN and BIAS                */
                THEN DO;
                 SIGN = 1; P$SIGN = 1;
                 BIAS = 0; P$BIAS = 0;
                 END;
              END;
           CODE.VAL = P$CODE.VAL;
         CASE (%GP#BLK$, %GP#STOPBLK$);
           P$BLK$->N_BLK.TEMP = %YES#;  /* We're done with this one           */
           IF GP_PTRS.P(1)
             THEN
              GP_PTRS.PTR$(1)->B$BIT(INDX) = %YES#;
           IF GP_PTRS.P(2)
             THEN
              GP_PTRS.PTR$(2)->B$PTR$(INDX) = P$BLK$;
           IF CODE.V.T.STOP
             THEN
              RETURN;
         CASE (%GP#BIT0#, %GP#BIT1#);
           P$BLK$->N_BLK.TEMP = %YES#;  /* We're done with this one           */
           IF GP_PTRS.P(3)
             THEN
              GP_PTRS.PTR$(3)->B$BIT(INDX) = %YES#;
           IF SIGN = 0
             THEN
              TBIT = ~CODE.V.T.VAL;
             ELSE
              TBIT = CODE.V.T.VAL;
           IF GP_PTRS.P(4)
             THEN
              GP_PTRS.PTR$(4)->B$BIT(INDX) = TBIT;
         CASE (%GP#BIAS);
           P$BLK$->N_BLK.TEMP = %YES#;  /* We're done with this one           */
           BIAS = BIAS + CODE.V.BIAS; P$BIAS = BIAS;
           CODE.VAL = P$CODE.VAL;
         END;
        IF END_NODE(P$BLK$->N_BLK.NDTYPE) OR P$BLK$->N_BLK.NSUBLKS = 0
          THEN
           IF P$BLK$->N_BLK.TEMP
             THEN
              RETURN;              /* We did all we wanted with this node     */
             ELSE
           DO CASE (CODE.V.TYPE);
            CASE (%GP#BIT0#, %GP#BIT1#);
              IF GP_PTRS.P(4)
                THEN DO;
                 CALL PVALUE (I,P$BLK$,1);
                 IF I > 1
                   THEN
                    I = 1;
                 IF SIGN ~= 0
                   THEN
                    SIGN = 1;
                 IF I = 1
                   THEN
                    TBIT = CODE.V.T.VAL; /* =yes                              */
                   ELSE
                    TBIT = ~CODE.V.T.VAL; /* =no                              */
                 GP_PTRS.PTR$(4)->B$BIT(INDX) = ~BINBIT(SIGN,1) \ TBIT;
                 END;
            CASE (%GP#TXC$);
              DO CASE (P$BLK$->T_BLK.NDTYPE);
               CASE (%DSTRING#,%NULL#,%OCT#,%DEC#,%ALPHA#,
                %ALNUM#,%SYM#,%FID#,%ASYM#,%PL6SYM#);
                 IF GP_PTRS.P(1)
                   THEN
                    GP_PTRS.PTR$(1)->B$BIT(INDX) = %YES#;
                 IF GP_PTRS.P(2)
                   THEN
                    GP_PTRS.PTR$(2)->B$PTR$(INDX) = P$BLK$->T_BLK.TEXTC$;
               END;
            CASE (%GP#VAL#);
              IF GP_PTRS.P(1)
                THEN
                 GP_PTRS.PTR$(1)->B$BIT(INDX) = %YES#;
              IF GP_PTRS.P(2)
                THEN
                 CALL PVALUE (GP_PTRS.PTR$(2)->B$UBIN(INDX),P$BLK$,SIGN);
            END;
          ELSE
        DO I = 0 TO P$BLK$->N_BLK.NSUBLKS-1;
           CALL GPX (P$BLK$->N_BLK.SUBLK$(I),CODE,BIAS,SIGN);
           END;
        RETURN;
END GPX;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
 
PVALUE: PROC (P$VALUE,P$BLK$,P$SIGN);
%INCLUDE XU_MACRO_C;
%INCLUDE XU_SUBS_C;
/*
|
Parameters:
|
*/
DCL 1 P$VALUE ALIGNED,
      2 VOCT (0:11) BIT(3) UNAL,
      2 VDEC REDEF VOCT UBIN(36),
      2 VDECS REDEF VOCT SBIN(36),
      2 VTXT REDEF VOCT CHAR(4);
DCL P$BLK$ PTR ALIGNED;
DCL P$SIGN SBIN ALIGNED;
/*
|
Local Data:
|
*/
DCL BLK$ PTR;
/*
|
Auto Data:
|
*/
DCL L SBIN;
DCL TS SBIN;
DCL BS SBIN;
DCL I SBIN;
DCL 1 BUF,
      2 OCT (0:11),
        3 * BIT(6) UNAL,
        3 LOW BIT(3) UNAL,
      2 C REDEF OCT CHAR(12);
/*
|
Based Structures:
|
*/
%PARSE$OUT(NAME=N_BLK);
%PARSE$SYM(NAME=T_BLK);
/*
|
Proceedure:
|
*/
        P$VALUE = '0'O;
        BLK$ = P$BLK$;
        L = T_BLK.COUNT;
        DO CASE (T_BLK.NDTYPE);
         CASE (%OCT#);
           IF L > 12 THEN L = 12;
           TS = T_BLK.COUNT - L;
           BS = 12 - L;
           IF BS < 0 THEN BS = 0;
           BUF = '0'O;
           CALL INSERT (BUF.C,BS,,SUBSTR(T_BLK.TEXT,TS,L));
           DO I = BS TO 11;
              P$VALUE.VOCT(I) = BUF.OCT.LOW(I);
              END;
         CASE (%DEC#);
           I = 0;
           IF SUBSTR(T_BLK.TEXT,0,1) = '-' OR
             SUBSTR(T_BLK.TEXT,0,1) = '+'
             THEN DO;
              I = 1;
              L = L - 1;
              END;
           CALL CHARBIN (P$VALUE.VDEC,SUBSTR(T_BLK.TEXT,I,L));
           IF SUBSTR(T_BLK.TEXT,0,1) = '-'
             THEN
              P$VALUE.VDECS = -P$VALUE.VDECS;
         CASE (%DSTRING#,%NULL#,%ALPHA#,%ALNUM#,%SYM#,%FID#,%ASYM#,%PL6SYM#);
           P$VALUE.VTXT = SUBSTR(T_BLK.TEXT,0,T_BLK.COUNT);
         CASE (ELSE);
           P$VALUE.VDEC = T_BLK.CODE;
         END;
        IF P$SIGN = -1
          THEN
           P$VALUE.VDECS = -P$VALUE.VDECS;
          ELSE
           IF P$SIGN = 0
             THEN
              P$VALUE = ~P$VALUE;
        RETURN;
END PVALUE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
t_ebc2asc: PROC NOAUTO;
DCL T_EBC2ASC (0:511) UBIN(9) UNAL CONSTANT SYMDEF INIT
 (0,1,2,3,4,9,6,7,8,5,21,11,12,13,14,15,
  16,17,18,19,20,10,22,23,24,25,26,27,28,29,30,31,
  160,161,162,163,164,165,166,167,167,169,170,171,172,173,174,175,
  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
  32,193,194,195,196,197,198,199,200,201,96,46,60,40,43,124,
  38,209,210,211,212,213,214,215,216,217,33,36,42,41,59,126,
  45,47,226,227,228,229,230,231,232,233,94,44,37,95,62,63,
  240,241,242,243,244,245,246,247,248,249,58,35,64,39,61,34,
  256,97,98,99,100,101,102,103,104,105,266,267,268,269,270,271,
  272,106,107,108,109,110,111,112,113,114,282,283,284,285,286,287,
  288,289,115,116,117,118,119,120,121,122,298,299,300,301,302,303,
  304,92,123,125,91,93,310,311,312,313,314,315,316,317,318,319,
  320,65,66,67,68,69,70,71,72,73,330,331,332,333,334,335,
  336,74,75,76,77,78,79,80,81,82,346,347,348,349,350,351,
  352,353,83,84,85,86,87,88,89,90,362,363,364,365,366,367,
  48,49,50,51,52,53,54,55,56,57,378,379,380,381,382,127,
  0,1,2,3,4,9,6,7,8,5,21,11,12,13,14,15,
  16,17,18,19,20,10,22,23,24,25,26,27,28,29,30,31,
  160,161,162,163,164,165,166,167,167,169,170,171,172,173,174,175,
  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
  32,193,194,195,196,197,198,199,200,201,96,46,60,40,43,124,
  38,209,210,211,212,213,214,215,216,217,33,36,42,41,59,126,
  45,47,226,227,228,229,230,231,232,233,94,44,37,95,62,63,
  240,241,242,243,244,245,246,247,248,249,58,35,64,39,61,34,
  256,97,98,99,100,101,102,103,104,105,266,267,268,269,270,271,
  272,106,107,108,109,110,111,112,113,114,282,283,284,285,286,287,
  288,289,115,116,117,118,119,120,121,122,298,299,300,301,302,303,
  304,92,123,125,91,93,310,311,312,313,314,315,316,317,318,319,
  320,65,66,67,68,69,70,71,72,73,330,331,332,333,334,335,
  336,74,75,76,77,78,79,80,81,82,346,347,348,349,350,351,
  352,353,83,84,85,86,87,88,89,90,362,363,364,365,366,367,
  48,49,50,51,52,53,54,55,56,57,378,379,380,381,382,127);
END;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
goodfid:   PROC NOAUTO;
DCL 1 T_XFID CONSTANT SYMDEF,
      2 FID000031 CHAR (32) INIT
         ('________________________________'),
      2 FID032063 CHAR (32) INIT
         (' ___$________-__0123456789:_____'),
      2 FID064095 CHAR (32) INIT
         ('_ABCDEFGHIJKLMNOPQRSTUVWXYZ_____'),
      2 FID096127 CHAR (32) INIT
         ('_abcdefghijklmnopqrstuvwxyz_____');
END goodfid;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
ALTERRMSG: PROC;
DCL M$DO DCB;
%INCLUDE CP_6;
%B$TCB;
%B$ALT;
DCL B$TCB$ PTR SYMREF;
%FPT_ERRMSG(BUF=ERROR_BUF,CODE=ERROR_CODE,OUTDCB1=M$DO);
DCL ERROR_BUF CHAR(120) STATIC;
DCL 1 ERROR_CODE STATIC,
    2 FCG BIT(12) UNAL,
    2 MID BIT(6) UNAL,
    2 MON BIT(1) UNAL,
    2 CODE UBIN(14) UNAL,
    2 SEV UBIN(3) UNAL;
 
AERRMSG: ENTRY;
 
        ERROR_CODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
        FPT_ERRMSG.V.DCB# = B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
        CALL M$ERRMSG (FPT_ERRMSG);
        RETURN;
END ALTERRMSG;
%EOD;
/*M* UNPARSE - Format and Display Parse Blocks */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
UNPARSE: PROC (P$PCB);
DCL M$DO DCB;
DCL UNPARSEB ENTRY (3);
%INCLUDE CP_6;
%INCLUDE XU_MACRO_C;
%P$PCB(NAME=P$PCB,STCLASS=" ");
%FPT_WRITE(FPTN=DO_WRITE,DCB=M$DO,BUF=DO_BUF);
DCL DO_BUF CHAR(120) STATIC;
DCL 1 FMT_PCB STATIC,
      2 * CHAR(0) INIT('NCHARS='),
      2 NCHARS CHAR(3),
      2 * CHAR(0) INIT(', WK_USED='),
      2 WK_USED CHAR(4),
      2 * CHAR(0) INIT(', HI_CHAR='),
      2 HI_CHAR CHAR(3);
DCL 1 FMT_PCB_C REDEF FMT_PCB CHAR(37);
DCL BLK$ PTR STATIC;
DCL INDENT UBIN WORD STATIC;
DCL L UBIN WORD;
DCL B$CS CHAR(CSL) BASED;
DCL CSL UBIN WORD;
        DO_BUF = ' ';
        CALL M$WRITE (DO_WRITE);
        CALL BINCHAR (FMT_PCB.NCHARS,P$PCB.NCHARS);
        CALL BINCHAR (FMT_PCB.WK_USED,P$PCB.WK_USED);
        CALL BINCHAR (FMT_PCB.HI_CHAR,P$PCB.HI_CHAR);
        DO_BUF = FMT_PCB_C;
        CALL M$WRITE (DO_WRITE);
        CSL = P$PCB.NCHARS;
        DO_BUF = P$PCB.TEXT$ -> B$CS;
        CALL M$WRITE (DO_WRITE);
        DO_BUF = ' ';
        CALL M$WRITE (DO_WRITE);
        BLK$ = P$PCB.OUT$;
        IF BLK$ = ADDR(NIL) THEN GOTO PROG_RETURN;
        DO_BUF = 'CPOS CODE TY NS CNT TEXT';
        CALL M$WRITE (DO_WRITE);
        INDENT = 0;
        CALL UNPARSEB (P$PCB,BLK$,INDENT);
        DO_BUF = ' ';
        CALL M$WRITE (DO_WRITE);
PROG_RETURN:
        RETURN;
END UNPARSE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*
*
*       FORMAT BLOCK
*
*/
UNPARSEB: PROC (P$PCB,P$BLK$,P$INDENT);
DCL P$PCB$ PTR;
DCL P$BLK$ PTR;
DCL P$INDENT UBIN WORD;
DCL M$DO DCB;
%INCLUDE CP_6;
%INCLUDE XU_MACRO_C;
%P$PCB(NAME=P$PCB,STCLASS=" ");
%PARSE$OUT(NAME=N_BLK);
%PARSE$SYM(NAME=T_BLK);
%FPT_WRITE(FPTN=DO_WRITE,DCB=M$DO,BUF=DO_BUF);
DCL DO_BUF CHAR(120) STATIC;
DCL BLK$ PTR STATIC;
DCL IBLK UBIN WORD;
DCL NDTYPE UBIN WORD STATIC;
DCL NSUBLKS UBIN WORD;
DCL 1 FMT_BLK,
      2 CPOS CHAR(4),
      2 * CHAR(1),
      2 CODE CHAR(4),
      2 * CHAR(1),
      2 NDTYPE CHAR(2),
      2 * CHAR(1),
      2 NSUBLKS CHAR(2),
      2 * CHAR(1),
      2 COUNT CHAR(3),
      2 * CHAR(1),
      2 TEXT CHAR(100);
DCL 1 FMT_BLK_C REDEF FMT_BLK CHAR(120);
DCL B$CS CHAR(CSL) BASED;
DCL CSL UBIN WORD STATIC;
        BLK$ = P$BLK$;
        CSL = P$PCB.NCHARS;
        DO_BUF = '.............................';
        FMT_BLK_C = ' ';
        CALL BINCHAR (FMT_BLK.CPOS,N_BLK.CPOS);
        CALL BINCHAR (FMT_BLK.CODE,N_BLK.CODE);
        NDTYPE = N_BLK.NDTYPE;
        CALL BINCHAR (FMT_BLK.NDTYPE,NDTYPE);
        NSUBLKS = N_BLK.NSUBLKS;
        CALL BINCHAR (FMT_BLK.NSUBLKS,NSUBLKS);
        DO CASE (NDTYPE);
         CASE (5,16,17,18,19,20,21,22,23);
           CALL BINCHAR (FMT_BLK.COUNT,T_BLK.COUNT);
           FMT_BLK.TEXT = SUBSTR(T_BLK.TEXT,0,T_BLK.COUNT);
           NSUBLKS = 0;
         CASE (ELSE);
           FMT_BLK.COUNT = '---';
           FMT_BLK.TEXT = SUBSTR(P$PCB.TEXT$->B$CS,N_BLK.CPOS);
         END;
        CALL INSERT (DO_BUF,P$INDENT,,FMT_BLK_C);
        CALL M$WRITE (DO_WRITE);
        IF NSUBLKS = 0 THEN RETURN;
        IBLK = 0;
ANOTHER:
        P$INDENT = P$INDENT + 3;
        CALL UNPARSEB (P$PCB,N_BLK.SUBLK$(IBLK),P$INDENT);
        P$INDENT = P$INDENT - 3;
        BLK$ = P$BLK$;
        IBLK = IBLK + 1;
        IF IBLK < NSUBLKS THEN GOTO ANOTHER;
        RETURN;
END UNPARSEB;
