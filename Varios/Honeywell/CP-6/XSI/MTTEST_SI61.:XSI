/*M*   MTTEST_SI61 Source for tape exerciser. */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
TAPETEST: PROC ;
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE FM$FIT;
%INCLUDE CP_6_SUBS;
%INCLUDE MTTEST_C61;
%INCLUDE MTTEST_C62;
%INCLUDE XU_MACRO_C;
%INCLUDE XUH_MACRO_C;
%INCLUDE XUR_ENTRY;
%INCLUDE B_MICROPS_C;
 
/***
 External entries
 ***/
DCL RPT_ERR ENTRY(2);
DCL MT$BRK ENTRY ASYNC;
DCL REPORT ENTRY(12);
 
 /***
  Data control blocks
  ***/
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$TAPE_DCB DCB ;
DCL M$IN_DCB DCB ;
DCL M$OUT_DCB DCB ;
 
DCL BREAK_COUNT SBIN STATIC SYMDEF;
DCL BREAK_DCB$ PTR STATIC SYMDEF;
DCL BREAK_TASK CHAR(22) STATIC SYMDEF;
DCL MTTEST_COMMAND UBIN SYMREF;         /* Partrge root node                  */
DCL MTTEST_EDIT UBIN SYMREF;            /* Partrge root node for EDIT         */
DCL B$JIT$ PTR SYMREF;
DCL PRMPT CHAR(0) CONSTANT INIT('$');
DCL PRMPT2 CHAR(0) CONSTANT INIT('*');
DCL NODE$ PTR STATIC;
%VLP_ERRCODE( FPTN=ERR,
              STCLASS="REDEF NODE$" );
 
 
DCL LASTSZ UBIN ALIGNED STATIC;
DCL LAST_REEL CHAR(6);
 
DCL M$TAPE_DCB$ PTR STATIC INIT(ADDR(NIL));
DCL M$IN_DCB$ PTR STATIC INIT(ADDR(NIL));
DCL M$OUT_DCB$ PTR STATIC INIT(ADDR(NIL));
DCL M$IN_DCB# UBIN STATIC;
DCL M$OUT_DCB# UBIN STATIC;
DCL RETRY# UBIN ALIGNED STATIC INIT(0);
DCL 1 RETRYLOG(0:99),
      2 LOC CHAR(8) ALIGNED,
      2 CNT CHAR(4) ALIGNED;
DCL I SBIN ALIGNED;
DCL RECNBR UBIN WORD ALIGNED STATIC;
DCL REC# CHAR(8) ALIGNED;
DCL FILEMK UBIN ALIGNED;
DCL SQ_SUMNBR UBIN WORD ALIGNED STATIC;
DCL SUM_RECNBR UBIN ALIGNED STATIC INIT(0);
DCL ERR_COUNT UBIN ALIGNED STATIC INIT(0);
DCL EOT BIT(1) CALIGNED STATIC;         /* End ot tape flag                   */
 
 
DCL SUMRD UBIN ALIGNED;            /* Accumulative sum of word for every read */
DCL AVRDSZ UBIN ALIGNED;                /* = SUMRD / RECNBR                   */
DCL READWD UBIN ALIGNED;
DCL RDLARGE UBIN ALIGNED;               /* Largest chunk of words ever read   */
DCL RDSMALL UBIN ALIGNED;               /* Smallest chunk of words ever read  */
DCL READN UBIN ALIGNED;
 
DCL B$TCB$ PTR SYMREF;
%B$TCB( STCLASS="BASED(B$TCB$)" );
%B$ALT;
%F$DCB;
%PARSE$OUT( STCLASS=BASED );
%PARSE$SYM( STCLASS=BASED );
DCL 1 CMD STATIC ,
      2 FCODE UBIN HALF UNAL,
      2 VSN CHAR(6) UNAL,
      2 NREC UBIN WORD ALIGNED,         /* # of records to read               */
      2 BLKSZ UBIN WORD ALIGNED,        /* Block size in byte                 */
      2 DEN UBIN BYTE UNAL,
      2 PAT UBIN BYTE UNAL,
      2 REP UBIN BYTE UNAL,
      2 LOGRETRY BIT(1) UNAL,
      2 STOP BIT(8) UNAL,
      2 DCB# UBIN WORD ALIGNED;
 
DCL EOF BIT(1) CALIGNED STATIC SYMDEF;  /* End of file flag                   */
DCL DISP_OUT BIT(1) CALIGNED STATIC SYMDEF; /*   range out of data segment    */
DCL DISP_PAR BIT(1) CALIGNED STATIC SYMDEF; /*   range partial out of data    */
DCL 1 ECMD STATIC SYMDEF,
      2 COPYSUB$ PTR ALIGNED,
      2 SKIPSUB$ PTR ALIGNED,
      2 DISPSUB$ PTR ALIGNED,
      2 FCODE UBIN BYTE UNAL,
      2 IOTYPE UBIN BYTE UNAL,          /* input/output tape or both          */
      2 SIGN_RF UBIN BYTE UNAL,         /* + for forward, - for backward move */
      2 NUM_RF SBIN(18) UNAL,           /* # of record or file to move        */
      2 REC_FILE UBIN BYTE UNAL,        /* unit of movement ( record or file) */
      2 DISPREC SBIN(18) UNAL,     /* # of record to display for each file    */
      2 DISPOP BIT(1) UNAL,             /*  for display options               */
      2 DISPALL BIT(1) UNAL,            /*  for display all record options    */
      2 ALL_RF BIT(1) UNAL,             /*  all records/files on tape         */
      2 DISP_BACK BIT(1) UNAL,          /* back to where display starts       */
      2 DISP_OCT BIT(1) UNAL,           /* dump in binary format              */
      2 DISPFULL BIT(1) UNAL,           /* Disp full record                   */
      2 ERRCONT BIT(1) UNAL,            /* do not stop for error condition    */
      2 DEOD BIT(1) UNAL,          /* do things till hit double file marks    */
      2 COPYFULL BIT(1) UNAL,           /* Copy full record                   */
      2 COPYBYT(0:1) SBIN(18) UNAL,     /* # of bytes for each record to copy */
      2 DISPBYT(0:1) SBIN(18) UNAL,     /* # of bytes to dump for each record */
      2 VSN(0:1) CHAR(6) UNAL,     /* 0 for input tape #, 1 for output tape # */
      2 DEN(0:1) UBIN BYTE UNAL,
      2 DCB#(0:1) UBIN BYTE UNAL,
      2 READ_BIN BIT(1) UNAL,
      2 EOF(0:1) BIT(1) UNAL,
      2 EOT(0:1) BIT(1) UNAL;
DCL BACK_REC#(0:1) UBIN ALIGNED;
DCL BACK_FIL#(0:1) UBIN ALIGNED;
DCL EOD BIT(1) CALIGNED STATIC;         /* End of data flag                   */
DCL DEOD BIT(1) CALIGNED STATIC;        /* Double end of data flag            */
DCL WAS_DISP BIT(1) CALIGNED STATIC;    /* Was display ever specified?        */
DCL SUB_MODE BIT(1) CALIGNED STATIC;    /* Go in edit mode                    */
DCL IO_TYPE UBIN CALIGNED STATIC;       /* Preserve I/O type                  */
DCL READBYT UBIN ALIGNED STATIC SYMDEF; /* Number of bytes of each read       */
DCL CUR_REC# UBIN WORD STATIC SYMDEF;
DCL NEWVSN(0:1) CHAR(6);
DCL FOUND BIT(1) CALIGNED;
DCL LEFT_REC CHAR(6) CALIGNED;
 
DCL BUFF$ PTR STATIC INIT(ADDR(NIL));
DCL BUFFSZ UBIN STATIC ALIGNED;
DCL BUFF(0:0) UBIN WORD ALIGNED BASED(BUFF$);
DCL PATCODE UBIN ALIGNED;
DCL PATSEQ(0:4) UBIN BYTE ALIGNED STATIC INIT(
       %FLS_ONE, %FLS_ZERO, %FLS_EVEN, %FLS_ODD, %FLS_CHECKER );
 
DCL TEMPCHAR CHAR(4) ALIGNED;
DCL BLANK CHAR(80) ALIGNED STATIC INIT(' ');
 
DCL TIMEC CHAR(8) ALIGNED;
DCL START CHAR(8) ALIGNED STATIC;
DCL FIN CHAR(8) ALIGNED STATIC;
DCL TIME# UBIN ALIGNED STATIC;
DCL START# UBIN ALIGNED;
DCL FIN# UBIN ALIGNED;
DCL MT$UTS_TO_TIME ENTRY(2);
 
 /***
  *** FPT
  ***/
%VLR_FID;
 
%FPT_INT( FPTN=FPT_INT,
          UENTRY=MT$BRK,
          STCLASS=CONSTANT );
 
%P_PCB( NAME=MTTEST_CMD_PCB,
        STCLASS=STATIC );
 
%XUR_INIT( NAME=XUR_INIT,
           SYNTAX=YES,
           PCB=MTTEST_CMD_PCB );
 
%XUH_PARAM( NAME=XUH_PARAM,
            OUTDCB1=M$DO );
 
%VLP_VECTOR;
%FPT_GDS(FPTN=FPT_GDS,
         RESULTS=VLP_VECTOR);
 
%FPT_PRECORD(FPTN=BACKUP_FPT,
             DCB=M$TAPE_DCB,
             N=-1 );
 
%FPT_REM( DISP=PTV,
          PSN=' ' );
 
%FPT_TIME( FPTN=UTS_FPT,
           DEST=UTS,
           TSTAMP=TIME#);
%FPT_WRITE( FPTN=BLANK_WRT,
            DCB=M$LO,
            BUF=BLANK);
 
%FPT_CLOSE(FPTN=TAPE_CLSREW,
           NOMARKS=YES,
           DCB=M$TAPE_DCB);
 
%VLP_SN(FPTN=TAPE_SN,N=1,SN=' ');
 
%FPT_OPEN(FPTN=TAPE_OPEN,
               RES='MT',
               CVOL=YES,
               SN=TAPE_SN,
               SCRUB=YES,
               ASN=DEVICE,
               ORG=FREE,
               DCB=M$TAPE_DCB);
 
%FPT_OPEN(FPTN=TAPE_MOUNT,
               RES='MT',
               SN=TAPE_SN,
               SCRUB=YES,
               MNTONLY=YES,
               DCB=M$TAPE_DCB);
 
%FPT_PRECORD(FPTN=FPT_PRECORD,
             DCB=M$TAPE_DCB,
             N=-1 );
 
%FPT_PFIL(FPTN=FPT_PFIL,
             DCB=M$TAPE_DCB,
             BOF=YES );
 
%FPT_PFIL(FPTN=SKIP_1FIL,
             DCB=M$TAPE_DCB,
             BOF=NO );
 
%P_PCB( NAME=MTTEST_EDIT_PCB,
        STCLASS=STATIC );
 
%XUR_INIT( NAME=XUR_INIT2,
           SYNTAX=YES,
           PCB=MTTEST_EDIT_PCB );
%FPT_PROMPT( FPTN = SUB_PRMPT );
 
 
%XUH_PARAM( NAME=XUH_PARAM2,
            OUTDCB1=M$DO );
 
%FPT_REW( FPTN = FPT_REW,
          DCB = M$IN_DCB);
 
%FPT_READ(FPTN=READ_TAPE, BIN=NO,  DCB=M$TAPE_DCB, WAIT=YES);
 
%FPT_WEOF(DCB=M$OUT_DCB);
 
%VLP_VECTOR( FPTN=DISP_VEC,
             STCLASS= "STATIC SYMDEF" );
 
%FPT_CLOSE(FPTN=TAPE_CLOSE,
           NOMARKS=YES,
           DCB=M$TAPE_DCB);
 
/****************************************/
 
 
        BREAK_DCB$ = ADDR(NIL);
        BREAK_COUNT = 0;
        BREAK_TASK = 'Initialization';
        CALL XUR$INIT( XUR_INIT );
        CALL M$INT( FPT_INT );
 
        M$TAPE_DCB$=DCBADDR(DCBNUM(M$TAPE_DCB));
        BUFFSZ = 0;
        CMD.VSN = ' ';
 /***
  *** Main command parsing loop.
  ***/
 
        DO WHILE('1'B);
BEGIN:     BREAK_COUNT = 0;
           BREAK_DCB$ = ADDR(NIL);
           BREAK_TASK = 'Getting command';
           SUB_MODE = '0'B;
           LAST_REEL = CMD.VSN;
           CMD='0'B;                    /* Initialize command cell            */
           CMD.VSN = LAST_REEL;
           CMD.PAT=%FLS_CHECKER;        /* Default in command options         */
           CMD.BLKSZ = 4 * 1024 * 4;    /*  start with 4k buffer, size in byte*/
           CMD.REP=1;
           CMD.DCB# = DCBNUM(M$TAPE_DCB);
           M$TAPE_DCB$ = DCBADDR( CMD.DCB# );
           ECMD = '0'B;
           NEWVSN(0) = ' ';
           NEWVSN(1) = ' ';
 
           CALL XUR$GETCMD( MTTEST_COMMAND, NODE$ ,VECTOR(PRMPT) ) ALTRET( TELL_ERROR );
           CALL XUR$ECHOIF( DCBNUM(M$LO) );
/***
         INTPCMD is saving command and its options in CMD cell. DCB opened
    for read/write in MT$OPEN, DRIVER then execute function per user
    command, report statistics and prompt for next command. Tape
    stay at the position while the operation end.
 ***/
           CMD.FCODE = NODE$ -> OUT$BLK.CODE;
           IF CMD.FCODE = %A_EDIT THEN DO;
              SUB_MODE = '1'B;
              CALL INTPECMD ALTRET( BEGIN );
              CALL TAPEEDIT ALTRET( BEGIN );
              CMD.DCB# = DCBNUM( M$TAPE_DCB );
              BUFF$ = VLP_VECTOR.PTR$;
              CMD.VSN = ECMD.VSN(0);
              CMD = '0'B;
              END;
           IF NOT SUB_MODE
           THEN CALL INTPCMD ALTRET(TELL_ERROR);
           ELSE SUB_MODE = '0'B;
           DO CASE( CMD.FCODE );
            CASE( %FLC_HELP );
              BREAK_TASK = 'Helping you';
              XUH_PARAM.HELP$ = NODE$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXTC$;
              CALL XUR$HELP( XUH_PARAM );
 
            CASE( %FLC_HELP_MORE );
              BREAK_TASK = 'Helping you';
              CALL XUR$MOREMSG( XUH_PARAM );
 
            CASE( %FLC_HELP_ALL );
              BREAK_TASK = 'Helping you';
              CALL XUR$ALLMSG( XUH_PARAM );
 
            CASE( %FLC_END, %FLC_QUIT );
              IF BUFF$ ~= ADDR(NIL)
              THEN CALL M$FDS(FPT_GDS)ALTRET(MON_ERR);
              CALL M$EXIT;
 
            CASE( %FLC_REM );
              FPT_REM.V.DISP# = %REL#;  /* Remove tape from drive             */
              CALL MT$CLSREW;
 
            CASE( %FLC_REW );
              BREAK_TASK = 'Rewind tape ';
              FPT_REM.V.DISP# = %PTV#;  /* Rewind tape                        */
              CALL MT$CLSREW;
 
            CASE( %FLC_MOUNT );
              BREAK_TASK = 'Mounting tape ';
              TAPE_MOUNT.V.DENSITY# = CMD.DEN;
              TAPE_SN.SN#(0) = CMD.VSN;
              CALL M$OPEN(TAPE_MOUNT) ALTRET(MON_ERR);
              CMD.DEN = M$TAPE_DCB$->F$DCB.DENSITY#;
              DO CASE( CMD.DEN );
               CASE( %D800# );
                 TEMPCHAR = '800';
               CASE( %D1600# );
                 TEMPCHAR = '1600';
               CASE( %D6250# );
                 TEMPCHAR = '6250';
               END;
              DO CASE( M$TAPE_DCB$->F$DCB.ASN# );
               CASE(%TAPE#);
                 CALL CONCAT( BLANK, 'LT#',CMD.VSN,' ( DENSITY = ',
                   TEMPCHAR,' ) rewound');
               CASE(%DEVICE#);
                 CALL CONCAT( BLANK, 'FT#',CMD.VSN,' ( DENSITY = ',
                   TEMPCHAR,' ) rewound');
               END;
              CALL M$WRITE( BLANK_WRT ) ALTRET(MON_ERR);
              BLANK = ' ';
 
            CASE( %FLC_READ, %FLC_WRITE, %FLC_TEST );
              BREAK_TASK = 'Interpret command';
 
              BREAK_TASK = 'Open DCB for tape';
              CALL MT$OPEN ALTRET(BEGIN);
              BREAK_TASK = 'Do R/W operation';
              CALL MT$DRIVER ALTRET( TEST_ERR );
              CALL M$CLOSE(TAPE_CLSREW)ALTRET(MON_ERR);
            END;
           DO WHILE('0'B);
TELL_ERROR:   ;
              CALL XUR$ECHOIF( DCBNUM(M$LO) );
              IF NOT ERR.MON
              THEN DO;
                 IF MTTEST_CMD_PCB.HI_CHAR > 0
                 THEN CALL XUR$ERRPTR( ,DCBNUM(M$DO) );
                 END;
              CALL XUR$ERRMSG( ERR );
              END;
           DO WHILE( '0'B );
TEST_ERR:     ;
              AVRDSZ = SUMRD / RECNBR;
              CALL M$TIME(UTS_FPT);
              CALL MT$STAT ALTRET(MON_ERR);
MON_ERR:      CALL RPT_ERR;
              CALL M$WRITE( BLANK_WRT ) ALTRET(MON_ERR);
              END;
           END;                         /* main command parsing loop          */
 
%EJECT;
INTPCMD: PROC ALTRET;
 
DCL SUBNODEX UBIN ALIGNED;
DCL SUBNODE$ PTR ;
DCL SUBSUBNODE$ PTR ;
DCL BLKSZK CHAR(8);
DCL INDX UBIN ALIGNED;
DCL TEMP UBIN ALIGNED;
 
 
        DO SUBNODEX=0 TO NODE$->OUT$BLK.NSUBLKS - 1;
           SUBNODE$=NODE$->OUT$BLK.SUBLK$(SUBNODEX);
           SUBSUBNODE$=SUBNODE$->OUT$BLK.SUBLK$(0);
           DO CASE( SUBNODE$->OUT$BLK.CODE );
            CASE(%FLO_TAPE);
              CMD.VSN = SUBSUBNODE$->OUT$SYM.TEXT;
 
            CASE(%FLO_BLOCK);
              DO CASE( SUBSUBNODE$->OUT$BLK.CODE );
               CASE( %FLS_KWORD );
                 BLKSZK=SUBSUBNODE$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
                 INDX = SUBSUBNODE$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
                 CALL CHARBIN( TEMP, SUBSTR(BLKSZK,0,INDX ));
                 IF TEMP = 1 OR MOD(TEMP,2) = 0 /* size is 1k or even # to 62k*/
                 THEN CMD.BLKSZ = TEMP;
                 ELSE CMD.BLKSZ = TEMP + 1; /* blk size may be 1k more        */
                 IF CMD.BLKSZ > 62 THEN CMD.BLKSZ=62; /* Max block size is 62K*/
                 CMD.BLKSZ = CMD.BLKSZ * 1024 * 4; /* Block size in bytes     */
               CASE( %FLS_BYTE );
                 BLKSZK=SUBSUBNODE$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
                 INDX = SUBSUBNODE$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
                 CALL CHARBIN( CMD.BLKSZ, SUBSTR(BLKSZK,0,INDX ));
               END;
 
            CASE(%FLO_PATTERN);
              CMD.PAT = SUBSUBNODE$->OUT$BLK.CODE;
 
            CASE(%FLO_DENSITY);
              CMD.DEN = SUBSUBNODE$->OUT$BLK.CODE;
 
            CASE(%FLO_REPS);
              BLKSZK = SUBSUBNODE$->OUT$SYM.TEXT;
              INDX = SUBSUBNODE$->OUT$SYM.COUNT;
              CALL CHARBIN( TEMP, SUBSTR(BLKSZK,0,INDX) );
              CMD.REP = TEMP;
 
            CASE(%FLO_NREC);
              BLKSZK = SUBSUBNODE$->OUT$SYM.TEXT;
              INDX = SUBSUBNODE$->OUT$SYM.COUNT;
              CALL CHARBIN( TEMP, SUBSTR(BLKSZK,0,INDX) );
              CMD.NREC = TEMP;
 
            CASE(%FLO_LOG);             /* Log location of retry operations   */
              INDX = SUBSUBNODE$->OUT$BLK.CODE;
              IF INDX = %FLS_RETRY
              THEN CMD.LOGRETRY = '1'B;
              ELSE CMD.LOGRETRY = '0'B;
 
            CASE(%FLO_STOP);
              INDX = SUBSUBNODE$->OUT$BLK.CODE;
              IF INDX = %FLS_RETRY      /* STOP ON RETRY                      */
              THEN CMD.STOP = '1'B;
              ELSE CMD.STOP = '0'B;
 
            END;                        /* CMD OPTION INTERPRETATION          */
           END;
END INTPCMD;
%EJECT;
MT$CLSREW: PROC ALTRET;
/***
    Close DCB for tape to be rewind or released.
 ***/
        IF M$TAPE_DCB$ -> F$DCB.FCD#
        THEN CALL M$CLOSE(TAPE_CLSREW)ALTRET(MON_ERR);
        FPT_REM.V.PSN# = CMD.VSN;
        CALL M$REM( FPT_REM ) ALTRET( MON_ERR );
        DO WHILE( '0'B );
MON_ERR:   ;
           CALL RPT_ERR;
           ALTRETURN;
           END;
END MT$CLSREW;
 
MT$OPEN: PROC ALTRET;
DCL BLKSZ UBIN ALIGNED;
DCL RPT_ERR ENTRY(2);
DCL DCB$ PTR;
 
        DCB$ = DCBADDR( CMD.DCB# );
        TAPE_OPEN.V.DCB# = CMD.DCB#;
        TAPE_OPEN.V.DENSITY# = CMD.DEN;
        TAPE_SN.SN#(0) = CMD.VSN;
        IF DCB$ -> F$DCB.FCD#
        THEN CALL MT$CLOSE ALTRET(MON_ERR);
        DO CASE( CMD.FCODE );
         CASE( %FLC_READ );
           TAPE_CLSREW.V.NOMARKS# = %YES#;
           TAPE_OPEN.V.FUN# = %IN#;
         CASE( %FLC_WRITE, %FLC_TEST );
           TAPE_CLSREW.V.NOMARKS# = %NO#;
           TAPE_OPEN.V.FUN# = %UPDATE#;
         END;                           /* CASE of CMD.FCODE                  */
        CALL M$OPEN(TAPE_OPEN) ALTRET(MON_ERR);
 
        CALL GETBUF( CMD.BLKSZ ) ALTRET(MON_ERR);
        DO WHILE( '0'B );
MON_ERR:   ;
           CALL RPT_ERR;
           ALTRETURN;
           END;
END MT$OPEN;
 
 
GETBUF: PROC( BLKSZ ) ALTRET;
DCL BLKSZ UBIN ALIGNED;
        IF BLKSZ > BUFFSZ THEN DO;
           FPT_GDS.V.SEGSIZE# = ( BLKSZ - BUFFSZ ) / 4;
           CALL M$GDS(FPT_GDS) ALTRET(MON_ERR);
           BUFF$ = VLP_VECTOR.PTR$;
           BUFFSZ = BLKSZ;
           END;                    /* New blk size > existing buffer size     */
        DO WHILE( '0'B );
MON_ERR:   ALTRETURN;
           END;
END GETBUF;
%EJECT;
/***
     If PATTERN=SEQUENTIAL then write each of the 5 patterns from
BOT to EOT for each repetition.
 ***/
 
MT$DRIVER: PROC ALTRET;
 
DCL SEQNUM UBIN ALIGNED;
 
DCL BLKSZ UBIN ALIGNED;
DCL I SBIN ALIGNED;
DCL J UBIN ALIGNED;
DCL ERR UBIN ALIGNED;
 
 
        LASTSZ = 0;
        BLKSZ = CMD.BLKSZ;
        IF CMD.PAT = %FLS_SEQ
        THEN SEQNUM=4;
        ELSE SEQNUM = 0;
        ERR = 0;
 
        DO I = 1 TO CMD.REP;
           DO J = 0 TO SEQNUM;
              IF SEQNUM > 0             /* sequential pattern                 */
              THEN PATCODE = PATSEQ(J);
              ELSE PATCODE = CMD.PAT;
              IF CMD.FCODE ~= %FLC_READ
              THEN CALL MT$INITBUF(BLKSZ);
              IF I > 1 OR J > 0 THEN DO;
                 FPT_REM.V.DISP# = %PTV; /* Position to BOT                   */
                 CALL MT$CLSREW ALTRET(MON_ERR);
                 CALL M$OPEN(TAPE_OPEN) ALTRET(MON_ERR);
                 END;
              RETRY# = M$TAPE_DCB$ -> F$DCB.RETRYCNT#;
              SUM_RECNBR = 0;
              SQ_SUMNBR = 0;
              ERR_COUNT = 0;
              RECNBR = 0;               /*   TO REFLECT RELATIVE REC LOC      */
              SUMRD = 0;
              FILEMK = 0;
              EOT = '0'B;
              EOF = '0'B;
              CALL M$TIME(UTS_FPT);
              START# = TIME#;
              DO WHILE (NOT EOT);       /* 2 FILE-MARK SET EOT ON READ CMD    */
                 CALL BINCHAR( REC#, RECNBR );
                 DO CASE( CMD.FCODE );
                  CASE( %FLC_READ );
                    CALL CONCAT( BREAK_TASK, 'Reading rec ', REC# );
                    CALL MT$READ(BLKSZ,ERR) ALTRET(MON_ERR);
                    READWD = READBYT / 4;
                    IF RECNBR=1 THEN DO;
                       RDSMALL = READWD; /* READ BUFFER START WITH 4K         */
                       RDLARGE = READWD; /* READ BUFFER START WITH 4K         */
                       END;
                    IF NOT EOF
                      THEN SUMRD = SUMRD + READWD;
                    IF READWD > RDLARGE
                    THEN RDLARGE = READWD;
                    ELSE IF READWD < RDSMALL
                       THEN RDSMALL = READWD;
 
                  CASE( %FLC_WRITE );
                    CALL CONCAT( BREAK_TASK, 'Writing rec ', REC# );
                    CALL MT$WRITE(BLKSZ,ERR) ALTRET(MON_ERR);
                  CASE( %FLC_TEST );
                    CALL CONCAT( BREAK_TASK, 'Testing rec ', REC# );
                    CALL MT$WRITE(BLKSZ,ERR) ALTRET(MON_ERR);
                    CALL M$PRECORD(BACKUP_FPT) ALTRET(MON_ERR);
                    LASTSZ = BLKSZ;
                    CALL MT$READ(BLKSZ,ERR) ALTRET(MON_ERR);
                  END;                  /* DO CASE CMD.FCODE                  */
                 IF (CMD.NREC > 0 ) AND (RECNBR >= CMD.NREC)
                 THEN EOT = '1'B;       /* goto stop and report statistics    */
                 END;                   /*  WHILE NOT EOT                     */
              IF RECNBR = 0
                THEN AVRDSZ = 0;
                ELSE AVRDSZ = SUMRD / RECNBR;
              CALL M$TIME(UTS_FPT);
              CALL MT$STAT ALTRET(MON_ERR);
              END;                      /* DO J SEQUENCE NUMBER               */
           END;                         /* DO I COMMAND REPITITION            */
        DO WHILE('0'B );
MON_ERR:   ;
           ALTRETURN;
           END;
END MT$DRIVER;
 
MT$STAT: PROC ALTRET;
DCL LOGCNT SBIN ALIGNED;
 
        IF CMD.LOGRETRY THEN DO;
           IF ERR_COUNT > 99
           THEN LOGCNT = 99;
           ELSE LOGCNT = ERR_COUNT - 1;
           IF LOGCNT >= 0 THEN DO;
              BLANK = '  Record #     Retries';
              CALL M$WRITE( BLANK_WRT ) ALTRET(MON_ERR);
              DO I = 0 TO LOGCNT;
                 CALL CONCAT( BLANK, '      ',RETRYLOG.LOC(I),
                   '     ',RETRYLOG.CNT(I));
                 CALL M$WRITE( BLANK_WRT ) ALTRET(MON_ERR);
                 END;
              BLANK = ' ';
              END;                      /* LOGCNT >= 0                        */
           END;
        FIN# = TIME#;
        TIME# = FIN# - START#;
        CALL MT$UTS_TO_TIME( TIME#, TIMEC );
        IF CMD.FCODE = %FLC_READ
        THEN READN = 1;
        ELSE READN = 0;
        CALL REPORT(ERR_COUNT, SUM_RECNBR, SQ_SUMNBR, RECNBR,
          READN,RDSMALL,RDLARGE,AVRDSZ,TIME#,RETRY#,FILEMK,TIMEC);
        DO WHILE( '0'B );
MON_ERR:   ;
           ALTRETURN;
           END;
END MT$STAT;
%EJECT;
/***
     If STOP=RETRY then program will stop and prompt for next command
    before proper block size is found. if NREC specified, stop and prompt
    for next command after NREC records has been read.
 ***/
MT$READ: PROC(BLKSZ,ERR) ALTRET;
DCL BLKSZ UBIN WORD ALIGNED;
DCL ERR UBIN ALIGNED;
DCL LOOP BIT(1) ALIGNED;
%FPT_READ(FPTN=READ_TAPE, DCB=M$TAPE_DCB, WAIT=YES);
 
        READ_TAPE.BUF_.BUF$ = BUFF$;    /* Use the real buffer                */
        READ_TAPE.V.DCB# = CMD.DCB#;
       IF ECMD.READ_BIN
         THEN READ_TAPE.V.DVBYTE.BIN# = '1'B;
         ELSE READ_TAPE.V.DVBYTE.BIN# = '0'B;
        LOOP = '1'B;
        DO WHILE ( LOOP );
REREAD:    READ_TAPE.BUF_.BOUND = BLKSZ - 1;
           CALL M$READ(READ_TAPE)
           WHENRETURN DO;
              LOOP = '0'B;
              CALL CHKRETRY(ERR) ALTRET(MON_ERR);
              CALL CHECKSZ(BLKSZ,ERR,LOOP) ALTRET(MON_ERR);
              EOF = '0'B;
              END;
           WHENALTRETURN DO;
              IF B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF
              THEN DO;
                 IF EOF THEN DO;        /* Reading 2 file mark                */
                    EOT = '1'B;
                    DEOD = '1'B;
                    LOOP = '0'B;
                    END;                /* EOF SET                            */
                 ELSE EOF = '1'B;
                 IF SUB_MODE
                 THEN LOOP = '0'B;
                 FILEMK = FILEMK + 1;
                 END;                   /* B$ALT.ERR.CODE = %E$EOF            */
              ELSE DO;
                 ERR = 1;
                 LOOP = '0'B;
                 END;
              END;
           END;
        IF NOT EOT THEN RECNBR = RECNBR + 1;
        IF ERR > 0 THEN CALL CHKRETRY(ERR) ALTRET(MON_ERR); /*Log monitor error*/
        DO WHILE( '0'B );
MON_ERR:   ;
           ALTRETURN;
           END;
END MT$READ;
%EJECT;
MT$WRITE: PROC(BLKSZ,ERR) ALTRET;
 
DCL BLKSZ UBIN WORD ALIGNED;
DCL ERR UBIN ALIGNED;
 
%FPT_WRITE( FPTN=WR_TAPE, DCB=M$TAPE_DCB  );
 
        WR_TAPE.V.DCB# = CMD.DCB#;
        WR_TAPE.BUF_.BUF$ = BUFF$;
        WR_TAPE.BUF_.BOUND = BLKSZ - 1;
        CALL M$WRITE(WR_TAPE)
        WHENALTRETURN DO;
           IF B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOT
           THEN EOT = '1'B;
           ELSE DO;
              ERR = 1;
              END;
           END;                         /* WHEN ALTRET                        */
        IF CMD.FCODE = %FLC_WRITE THEN RECNBR = RECNBR + 1;
        CALL CHKRETRY(ERR) ALTRET(MON_ERR);
        RETURN;
MON_ERR: ;
        ALTRETURN;
END MT$WRITE;
%EJECT;
CHECKSZ: PROC(BLKSZ,ERR,LOOP) ALTRET;
 
DCL BLKSZ UBIN ALIGNED;
DCL BUFBYTE UBIN ALIGNED;
DCL ERR UBIN ALIGNED;
DCL LOOP BIT(1) ALIGNED;
DCL DCB$ PTR;
 
        DCB$ = DCBADDR( CMD.DCB# );
        READBYT = DCB$ -> F$DCB.ARS#;
        IF (READBYT >= BLKSZ) AND (LASTSZ ~= BLKSZ) /* BUF MAY .LT. RECSZ     */
        THEN DO;                        /* OR TAPE RECSZ ACTUAL = BUFSZ       */
           LASTSZ = BLKSZ;
           BLKSZ = ( BLKSZ + 62 * 1024 * 4) / 2; /* MAX BLKSZ = 62K words     */
           IF MOD( BLKSZ, 2 * 1024 * 4 ) > 0
           THEN BLKSZ = BLKSZ/4096*4096 + 1024 * 4; /* Size in even Kwords    */
           CALL GETBUF( BLKSZ ) ALTRET(MON_ERR);
           BACKUP_FPT.V.DCB# = CMD.DCB#;
           PATCODE = CMD.PAT;
           CALL MT$INITBUF(BLKSZ);
           CALL M$PRECORD(BACKUP_FPT) ALTRET(MON_ERR);
           LOOP = '1'B;
           END;
        DO WHILE( '0'B );
MON_ERR:   ;
           ERR = 1;
           ALTRETURN;
           END;
END CHECKSZ;
%EJECT;
CHKRETRY: PROC(ERR) ALTRET;
DCL RETRY UBIN ALIGNED;
DCL ERR UBIN ALIGNED;
DCL DCB$ PTR;
        DCB$ = DCBADDR( CMD.DCB# );
        RETRY = DCB$ -> F$DCB.RETRYCNT#;
        IF (ERR > 0) OR (RETRY > RETRY#) THEN DO;
           IF ERR_COUNT < 100 THEN DO;
              RETRYLOG.LOC(ERR_COUNT) = REC#;
              CALL BINCHAR( RETRYLOG.CNT(ERR_COUNT), RETRY - RETRY# );
              END;
           ERR_COUNT = ERR_COUNT + 1;
           RETRY# = RETRY;
           SUM_RECNBR = SUM_RECNBR + RECNBR;
           SQ_SUMNBR = SQ_SUMNBR + RECNBR * RECNBR;
           IF CMD.STOP THEN EOT = '1'B;
           IF ERR > 0 THEN ALTRETURN;
           END;
END CHKRETRY;
 
MT$INITBUF: PROC(BLKSZ) ALTRET;
DCL BLKSZ UBIN ALIGNED;
DCL PATTERN BIT(36) ALIGNED;
DCL I SBIN ALIGNED;
        IF CMD.FCODE = %FLC_READ THEN RETURN;
        DO CASE(PATCODE);
         CASE(%FLS_ONE);
           PATTERN='777777777777'O;
         CASE(%FLS_ZERO,0);
           PATTERN='000000000000'O;
         CASE(%FLS_EVEN);
           PATTERN='252525252525'O;
         CASE(%FLS_ODD);
           PATTERN='525252525252'O;
         CASE(%FLS_CHECKER);
           PATTERN='524526522532'O;
         END;
        DO I=0 TO BLKSZ/4 - 1;
           BUFF(I) = BITBIN(PATTERN);
           END;
END MT$INITBUF;
 
TAPEEDIT: PROC ALTRET;
 
        BREAK_TASK = 'Tape editor Initialization';
 
        M$IN_DCB# = DCBNUM(M$IN_DCB);
        M$OUT_DCB# = DCBNUM(M$OUT_DCB);
        M$IN_DCB$=DCBADDR(M$IN_DCB#);
        M$OUT_DCB$=DCBADDR(M$OUT_DCB#);
        ECMD.DCB#(0) = M$IN_DCB#;
        ECMD.DCB#(1) = M$OUT_DCB#;
        BUFFSZ = 0;
        CMD = '0'B;
        CALL MT$IO_TAPE ALTRET( JUSTALT );
        CALL XUR$INIT( XUR_INIT2 ) ALTRET(MON_ERR);
        CALL M$INT( FPT_INT ) ALTRET(MON_ERR);
        CALL M$PROMPT( SUB_PRMPT ) ALTRET(MON_ERR);
 /***
  *** Main command parsing loop.
  ***/
 
        DO WHILE('1'B);
BEGIN:     BREAK_COUNT = 0;
           BREAK_DCB$ = ADDR(NIL);
           BREAK_TASK = 'Getting command';
 
           CALL XUR$GETCMD( MTTEST_EDIT, NODE$ ,VECTOR(PRMPT2) ) ALTRET( TELL_ERROR );
           CALL XUR$ECHOIF( DCBNUM(M$LO) );
           ECMD='0'B;                   /* Initialize command cell            */
           ECMD.IOTYPE = %E_IN;
           ECMD.NUM_RF = 1;
           ECMD.REC_FILE = %F_REC;
           ECMD.DISPREC = 1;
           ECMD.DISPFULL = '1'B;
           ECMD.COPYFULL = '1'B;
           ECMD.DISPSUB$ = ADDR(NIL);
           ECMD.SKIPSUB$ = ADDR(NIL);
           ECMD.COPYSUB$ = ADDR(NIL);
           ECMD.DCB#(0) = M$IN_DCB#;
           ECMD.DCB#(1) = M$OUT_DCB#;
           IF M$IN_DCB$->F$DCB.FCD# THEN DO;
              ECMD.VSN(0) = M$IN_DCB$->F$DCB.PSN#;
              ECMD.DEN(0) = M$IN_DCB$->F$DCB.DENSITY#;
              END;
           ELSE ECMD.VSN(0) = ' ';
 
           IF M$OUT_DCB$->F$DCB.FCD# THEN DO;
              ECMD.VSN(1) = M$OUT_DCB$->F$DCB.PSN#;
              ECMD.DEN(1) = M$OUT_DCB$->F$DCB.DENSITY#;
              END;
           ELSE ECMD.VSN(1) = ' ';
           NEWVSN(0) = ' ';
           NEWVSN(1) = ' ';
           FOUND = '0'B;
           WAS_DISP = '0'B;
           DISP_VEC = VLP_VECTOR;
           ECMD.FCODE = NODE$ -> OUT$BLK.CODE;
           CALL INTPECMD ALTRET(TELL_ERROR);
           IF ECMD.SKIPSUB$ ~= ADDR(NIL) THEN DO;
              NODE$ = ECMD.SKIPSUB$;
              CALL INTPECMD ALTRET( TELL_ERROR );
              END;
           IF ECMD.COPYSUB$ ~= ADDR(NIL) THEN DO;
              NODE$ = ECMD.COPYSUB$;
              CALL INTPECMD ALTRET( TELL_ERROR );
              END;
           IF ECMD.DISPSUB$ = ADDR(NIL) THEN DO;
              ECMD.COPYBYT = ECMD.DISPBYT;
              ECMD.DISPBYT(0) = 0;
              ECMD.DISPBYT(1) = 0;
              END;
           ELSE DO;
              ECMD.COPYBYT = ECMD.DISPBYT;
              NODE$ = ECMD.DISPSUB$;
              CALL INTPECMD ALTRET( TELL_ERROR );
              END;
           DO CASE( ECMD.FCODE );
            CASE( %A_HELP );
              BREAK_TASK = 'Helping you';
              XUH_PARAM2.HELP$ = NODE$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXTC$;
              CALL XUR$HELP( XUH_PARAM2 );
 
            CASE( %A_HELP_MORE );
              BREAK_TASK = 'Helping you';
              CALL XUR$MOREMSG( XUH_PARAM2 );
 
            CASE( %A_HELP_ALL );
              BREAK_TASK = 'Helping you';
              CALL XUR$ALLMSG( XUH_PARAM2 );
 
            CASE( %A_END );
              DO I = 0 TO 1;
                 CMD.DCB# = ECMD.DCB#(I);
                 CALL MT$CLOSE;
                 END;
              RETURN;
 
            CASE( %A_REW );
              BREAK_TASK = 'Rewind tape ';
              CALL MT$REW ALTRET( MON_ERR );
 
            CASE( %A_EDIT );
              BREAK_TASK = 'OPEN in/out tapes';
              DO I = 0 TO 1;
                 BREAK_DCB$ = DCBADDR( ECMD.DCB#(I) );
                 CMD.DCB# = ECMD.DCB#(I);
                 CALL MT$CLOSE ALTRET( BEGIN );
                 END;
              CALL MT$IO_TAPE ALTRET( BEGIN );
 
            CASE( %A_SKIP );
              BREAK_TASK = 'SKIPing recs/files';
              IF ( ECMD.IOTYPE = %E_OUT OR ECMD.IOTYPE = %E_BOTH )
                AND NOT M$OUT_DCB$->F$DCB.FCD#
              THEN CALL MT$MSG ALTRET( MON_ERR );
              ELSE DO;
                 IF ECMD.DISPOP THEN DO;
                    BACK_FIL#(0) = ECMD.NUM_RF;
                    CALL MT$MOVE ALTRET( BEGIN );
                    ECMD.NUM_RF = BACK_FIL#(0);
                    END;
                 IF NOT WAS_DISP OR WAS_DISP AND ECMD.SIGN_RF = %G_M
                 THEN CALL MT$SKIP ALTRET( BEGIN );
                 END;
 
            CASE( %A_COPY );
              BREAK_TASK = 'COPYing recs/files';
              IF NOT M$OUT_DCB$->F$DCB.FCD#
              THEN CALL MT$MSG ALTRET(MON_ERR);
              ELSE DO;
                 CALL MT$MOVE ALTRET( BEGIN );
                 END;
 
            CASE( %A_DISP );
              BREAK_TASK = 'DISPLAYing rec/file';
              IF ( ECMD.IOTYPE = %E_OUT OR ECMD.IOTYPE = %E_BOTH )
                AND NOT M$OUT_DCB$->F$DCB.FCD#
              THEN CALL MT$MSG ALTRET( MON_ERR );
              ELSE DO;
                 ECMD.DISPOP = '1'B;
                 IO_TYPE = ECMD.IOTYPE;
                 IF ECMD.REC_FILE = %F_REC THEN DO;
                    IF ECMD.SIGN_RF = %G_M THEN DO;
                       ECMD.DISPREC = -ECMD.NUM_RF;
                       ECMD.DISP_BACK = '0'B;
                       END;
                    ELSE ECMD.DISPREC = ECMD.NUM_RF;
                    ECMD.DISPALL = ECMD.ALL_RF;
                    END;
                 DO I=0 TO 1;
                    BACK_REC#(I) = 0;
                    BACK_FIL#(I) = 0;
                    END;
                 CALL MT$MOVE ALTRET( BEGIN );
                 IF ECMD.DISP_BACK THEN DO;
                    ECMD.IOTYPE = IO_TYPE;
                    IF ECMD.REC_FILE = %F_REC THEN DO;
                       IF ECMD.ALL_RF THEN DO;
                          ECMD.NUM_RF = -1; /* BACK UP 1 FILE MARK            */
                          ECMD.REC_FILE = %F_FILE;
                          CALL MT$SKIP ALTRET( BEGIN );
                          ECMD.REC_FILE = %F_REC;
                          END;
                       DO I = 0 TO 1;
                          IF BACK_REC#(I) = 0
                          THEN BACK_REC#(I) = CUR_REC#;
                          END;
                       CALL MT$SKIP ALTRET( BEGIN );
                       END;
                    ELSE DO;
                       CALL MT$SKIP ALTRET( BEGIN );
                       ECMD.REC_FILE = %F_REC;
                       CALL MT$SKIP ALTRET( BEGIN );
                       END;
                    END;
                 END;
 
            END;
           DO WHILE('0'B);
TELL_ERROR:   ;
              CALL XUR$ECHOIF( DCBNUM(M$LO) );
              IF NOT ERR.MON
              THEN DO;
                 IF MTTEST_EDIT_PCB.HI_CHAR > 0
                 THEN CALL XUR$ERRPTR( ,DCBNUM(M$DO) );
                 END;
              CALL XUR$ERRMSG( ERR );
              END;
           DO WHILE( '0'B );
TEST_ERR:     ;
MON_ERR:      CALL RPT_ERR;
              CALL M$WRITE( BLANK_WRT ) ALTRET(MON_ERR);
              END;
           END;                         /* main command parsing loop          */
JUSTALT: ;
        ALTRETURN;
END TAPEEDIT;
 
MT$MSG: PROC ALTRET;
        CALL CONCAT(BLANK,'...Only input tape ',ECMD.VSN(0),'active.');
        CALL M$WRITE( BLANK_WRT ) ALTRET( MON_ERR );
        BLANK = ' ';
        RETURN;
MON_ERR: ;
        ALTRETURN;
END MT$MSG;
%EJECT;
MT$IO_TAPE:PROC ALTRET;
 
        BREAK_TASK = 'Open in/out tape';
        CMD.BLKSZ = 4096 * 4;           /* Start with 4k word buffer          */
        DO I = 0 TO 1;             /* Open both input/output tape for read    */
           BREAK_DCB$ = DCBADDR( ECMD.DCB#(I) );
           IF NEWVSN(I) = ' ' THEN DO;
              ECMD.VSN(I) = ' ';
              CMD.DCB# = ECMD.DCB#(I);
              CALL MT$CLOSE ALTRET(JUSTALT);
              ECMD.DCB#(I) = 0;
              END;
           ELSE DO;
              CMD.DEN = ECMD.DEN(I);
              CMD.VSN = NEWVSN(I);
              ECMD.VSN(I) = CMD.VSN;
              CMD.DCB# = ECMD.DCB#(I);
              IF I = 0
              THEN CMD.FCODE = %FLC_READ;
              ELSE CMD.FCODE = %FLC_WRITE;
              CALL MT$OPEN ALTRET( JUSTALT );
              END;
           IF BREAK_COUNT > 0
           THEN ALTRETURN;
           END;
        DO WHILE( '0'B );
JUSTALT:   ;
           ALTRETURN;
           END;
END MT$IO_TAPE;
%EJECT;
MT$REW: PROC ALTRET;
 
        IF NEWVSN(0) ~= ' ' THEN DO;
           DO I = 0 TO 1;
              IF NEWVSN(0) = ECMD.VSN(I) THEN DO;
                 FOUND = '1'B;
                 IF I = 0
                 THEN ECMD.IOTYPE = %E_IN;
                 ELSE ECMD.IOTYPE = %E_OUT;
                 END;
              END;
           IF NOT FOUND THEN DO;
              CALL CONCAT( BLANK, '...Tape ', NEWVSN(0), ' not active.');
              CALL M$WRITE( BLANK_WRT ) ALTRET( MON_ERR );
              BLANK = ' ';
              END;
           END;
        IF NEWVSN(0) = ' ' OR FOUND THEN DO;
           DO I= 0 TO 1;           /* 0 for input tape, 1 for output tape     */
              IF ECMD.IOTYPE = %E_OUT
              THEN I = 1;               /* DO output tape only                */
              BREAK_DCB$ = DCBADDR( ECMD.DCB#(I) );
              IF BREAK_DCB$->F$DCB.FCD# THEN DO;
                 FPT_REW.V.DCB# = ECMD.DCB#(I);
                 CALL M$REW( FPT_REW ) ALTRET( MON_ERR );
                 END;
              ELSE DO;
                 IF I = 0
                 THEN CALL CONCAT(BLANK,'...Input tape not active.');
                 ELSE CALL CONCAT(BLANK,'...Output tape not active.');
                 CALL M$WRITE( BLANK_WRT ) ALTRET( MON_ERR );
                 BLANK = ' ';
                 END;
              IF ECMD.IOTYPE = %E_IN
              THEN I=1;                 /* ONLY input tape want rewind        */
              END;
           END;
        RETURN;
MON_ERR:;
        ALTRETURN;
END MT$REW;
%EJECT;
INTPECMD: PROC ALTRET;
 
DCL SUBNODEX UBIN ALIGNED;
DCL SUB2X UBIN ALIGNED;
DCL SUBNODE$ PTR ;
DCL SUB2NODE$ PTR ;
DCL SUB3NODE$ PTR ;
DCL NBRC CHAR(8);
DCL INDX SBIN ALIGNED;
DCL TEMP$ PTR ALIGNED;
DCL I UBIN ALIGNED;
DCL VALUE UBIN ALIGNED;
 
        INDX = -1;
        DO SUBNODEX=0 TO NODE$->OUT$BLK.NSUBLKS - 1;
           SUBNODE$=NODE$->OUT$BLK.SUBLK$(SUBNODEX);
           DO SUB2X=0 TO SUBNODE$->OUT$BLK.NSUBLKS - 1;
              SUB2NODE$=SUBNODE$->OUT$BLK.SUBLK$(SUB2X);
              SUB3NODE$=SUB2NODE$->OUT$BLK.SUBLK$(0);
              DO CASE( SUB2NODE$->OUT$BLK.CODE );
               CASE(%B_TAPE);
                 INDX = INDX + 1;
                 NEWVSN(INDX) = SUB3NODE$->OUT$SYM.TEXT;
 
               CASE( %B_DENSITY );
                 ECMD.DEN(INDX) = SUB3NODE$->OUT$BLK.CODE;
 
               CASE(%D_BLOCK);
                 CALL BYT_RANGE;
                 IF ECMD.DISPOP
                 THEN ECMD.DISPFULL = '0'B;
                 ELSE ECMD.COPYFULL = '0'B;
 
               CASE(%D_IO);
                 ECMD.IOTYPE = SUB3NODE$->OUT$BLK.CODE;
 
               CASE(%E_NUM_S);
                 DO CASE( SUB3NODE$->OUT$BLK.CODE );
                  CASE( %G_P, %G_M );
                    ECMD.SIGN_RF = SUB3NODE$->OUT$BLK.CODE;
                    TEMP$ = SUB3NODE$;
                    SUB3NODE$ = SUB2NODE$->OUT$BLK.SUBLK$(1);
                    CALL TEXT_COUNT;
                    IF ECMD.SIGN_RF = %G_M
                    THEN ECMD.NUM_RF = -VALUE;
                    ELSE ECMD.NUM_RF = VALUE;
                  CASE( %F_N );
                    CALL TEXT_COUNT;
                    ECMD.NUM_RF = VALUE;
                  CASE( %F_ALL );
                    ECMD.ALL_RF = '1'B;
                  END;
 
               CASE(%E_REC_F);
                 ECMD.REC_FILE = SUB3NODE$->OUT$BLK.CODE;
 
               CASE( %B_NUM );
                 DO CASE( SUB3NODE$->OUT$BLK.CODE );
                  CASE( %F_N );
                    CALL TEXT_COUNT;
                    ECMD.DISPREC = VALUE;
                  CASE( %F_ALL );
                    ECMD.DISPALL = '1'B;
                  END;
 
               CASE( %D_RECS );
                 CALL TEXT_COUNT;
                 ECMD.DISPBYT(0) = 0;
                 ECMD.DISPBYT(1) = VALUE - 1;
                 ECMD.DISPFULL = '0'B;
 
               CASE( %D_BIN );
                 ECMD.READ_BIN = '1'B;
 
               CASE( %D_OCT );
                 ECMD.DISP_OCT = '1'B;
 
               CASE( %D_BACK );
                 IF ECMD.FCODE = %A_DISP
                 THEN ECMD.DISP_BACK = '1'B;
               CASE( %B_COPY_SUBL );
                 DO CASE( SUB3NODE$->OUT$BLK.CODE );
                  CASE( %A_DISP_OP );
                    ECMD.COPYSUB$ = SUB2NODE$;
                    ECMD.DISPOP = '1'B;
                  CASE( %D_DEOD );
                    ECMD.DEOD = '1'B;
                  CASE( %D_ERR );
                    IF SUB3NODE$->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE = %F_CONT
                    THEN ECMD.ERRCONT = '1'B;
                  CASE( %D_BLOCK );
                    TEMP$ = SUB3NODE$;
                    SUB3NODE$ = SUB3NODE$->OUT$BLK.SUBLK$(0);
                    CALL BYT_RANGE;
                    SUB3NODE$ = TEMP$;
                    ECMD.COPYFULL = '0'B;
                  END;
 
               CASE( %B_SKIP_SUBL );
                 ECMD.SKIPSUB$ = SUB2NODE$;
                 ECMD.DISPOP = '1'B;
 
               CASE( %C_DISP_LISTOP );
                 ECMD.DISPSUB$ = SUB2NODE$;
                 ECMD.DISPOP = '1'B;
               END;                     /* ECMD OPTION INTERPRETATION         */
              END;                      /* SUB2X                              */
           END;
 
 
TEXT_COUNT: PROC;
        NBRC = SUB3NODE$->OUT$SYM.TEXT;
        INDX = SUB3NODE$->OUT$SYM.COUNT;
        CALL CHARBIN( VALUE, SUBSTR( NBRC, 0, INDX ) );
END TEXT_COUNT;
 
BYT_RANGE: PROC;
DCL TEMP$ PTR;
        DO CASE( SUB3NODE$->OUT$BLK.CODE );
         CASE( %F_RANGE );
           DO I = 0 TO SUB3NODE$->OUT$BLK.NSUBLKS - 1;
              TEMP$ = SUB3NODE$;
              SUB3NODE$ = TEMP$->OUT$BLK.SUBLK$(I);
              CALL TEXT_COUNT;
              SUB3NODE$ = TEMP$;
              ECMD.DISPBYT(I) = VALUE;
              END;
         CASE( %F_NBYTE );
           TEMP$ = SUB3NODE$;
           SUB3NODE$ = TEMP$->OUT$BLK.SUBLK$(0);
           CALL TEXT_COUNT;
           IF TEMP$->OUT$BLK.NSUBLKS = 1 THEN DO;
              ECMD.DISPBYT(0) = 0;
              ECMD.DISPBYT(1) = VALUE;
              END;
           ELSE DO;
              ECMD.DISPBYT(0) = VALUE;
              SUB3NODE$ = TEMP$->OUT$BLK.SUBLK$(1);
              CALL TEXT_COUNT;
              ECMD.DISPBYT(1) = ECMD.DISPBYT(0) + VALUE;
              END;
         END;
 
END BYT_RANGE;
 
 
END INTPECMD;
%EJECT;
MT$CLOSE: PROC ALTRET;
/***
    Close DCB for tape
 ***/
DCL DCB$ PTR;
 
        DCB$ = DCBADDR( CMD.DCB# );
        TAPE_CLOSE.V.DCB# = CMD.DCB#;
        IF DCB$ -> F$DCB.FCD#
        THEN CALL M$CLOSE(TAPE_CLOSE)ALTRET(MON_ERR);
        DO WHILE( '0'B );
MON_ERR:   ;
           CALL RPT_ERR( ,CMD.DCB# );
           ALTRETURN;
           END;
END MT$CLOSE;
 
%EJECT;
MT$SKIP: PROC ALTRET;
/*** SKIP all files is implement as skip 1 file to keep from running
   off reel.
 ***/
DCL J SBIN WORD ALIGNED;
DCL SKIPFILE# SBIN WORD ALIGNED;
DCL CODE SBIN WORD ALIGNED;
 
        DO I = 0 TO 1;
           IF ECMD.IOTYPE = %E_OUT
           THEN I = 1;                  /* DO OUTPUT TAPE ONLY                */
           BREAK_DCB$ = DCBADDR( ECMD.DCB#(I) );
           CMD.DCB# = ECMD.DCB#(I);
           FPT_PFIL.V.DCB# = ECMD.DCB#(I);
           SKIP_1FIL.V.DCB# = ECMD.DCB#(I);
           IF ECMD.DISP_BACK THEN DO;
              IF ECMD.REC_FILE = %F_REC
              THEN ECMD.NUM_RF = -BACK_REC#(I);
              ELSE ECMD.NUM_RF = -BACK_FIL#(I);
              END;
           IF ECMD.REC_FILE = %F_FILE THEN DO;
              CUR_REC# = 0;
              IF ECMD.NUM_RF < 0 THEN DO;
                 IF ECMD.DISP_BACK
                 THEN SKIPFILE# = -ECMD.NUM_RF;
                 ELSE SKIPFILE# = -ECMD.NUM_RF + 1;
                 FPT_PFIL.V.BOF# = %YES#;
                 END;
              ELSE DO;
                 FPT_PFIL.V.BOF# = %NO#;
                 SKIPFILE# = ECMD.NUM_RF;
                 END;
              DO J = 1 TO SKIPFILE#;
                 CALL M$PFIL( FPT_PFIL )
                 WHENRETURN DO;
                    IF J = SKIPFILE# AND ECMD.DISPOP
                      AND ECMD.NUM_RF < 0 AND NOT ECMD.DISP_BACK
                    THEN CALL M$PFIL( SKIP_1FIL ) ALTRET( MON_ERR );
                    END;
                 WHENALTRETURN DO;
                    CODE = B$TCB.ALT$->B$ALT.ERR.CODE;
                    CALL RPT_ERR( ,CMD.DCB# );
                    IF J ~= SKIPFILE# OR CODE ~=%E$BOT
                    THEN ALTRETURN;
                    END;
                 IF BREAK_COUNT > 0
                 THEN ALTRETURN;
                 END;                   /* DO NUM_RF # OF FILES               */
              END;                      /* IOTYPE = %F_FILE                   */
           ELSE DO;
              CUR_REC# = CUR_REC# + ECMD.NUM_RF;
              FPT_PRECORD.V.N# = ECMD.NUM_RF;
              FPT_PRECORD.V.DCB# = CMD.DCB#;
              CALL M$PRECORD( FPT_PRECORD ) ALTRET( MON_ERR );
              END;
           DO WHILE( '0'B );
MON_ERR:      ;
              CODE = B$TCB.ALT$ -> B$ALT.ERR.CODE;
              CALL RPT_ERR( ,CMD.DCB#);
              IF ((ECMD.IOTYPE = %E_IN AND I=0 ) OR ( I=1 AND
                (ECMD.IOTYPE = %E_BOTH OR ECMD.IOTYPE = %E_OUT) ))
              THEN CUR_REC# = 0;
              IF ( CODE = %E$BOF ) OR ( CODE = %E$BOT )
              THEN ;                    /* KEEP GOING                         */
              ELSE ALTRETURN;
              END;
           IF ECMD.IOTYPE = %E_IN
           THEN I = 1;                  /* DO INPUT TAPE ONLY                 */
           IF BREAK_COUNT > 0
           THEN ALTRETURN;
           END;                         /* DO I                               */
END MT$SKIP;
%EJECT;
MT$MOVE: PROC ALTRET;
DCL ERR UBIN ALIGNED;
DCL DISP_REC_IN_FILE UBIN ALIGNED;
 
        ERR = 0;
        ERR_COUNT = 0;
        EOT = '0'B;
        EOF = '0'B;
        EOD = '0'B;
        DEOD = '0'B;
        CUR_REC# = 0;
        WAS_DISP = ECMD.DISPOP;
        CMD.FCODE = %FLC_READ;
        IF ECMD.SIGN_RF = %G_M THEN DO; /* DO previous n records/files*/
           CALL MT$SKIP ALTRET( JUSTALT );
           ECMD.NUM_RF = -ECMD.NUM_RF;
           END;
        IF ECMD.DISPOP AND NOT ECMD.DISPFULL THEN DO;
           DISP_VEC.PTR$ = PINCRC( BUFF$, ECMD.DISPBYT(0) );
           DISP_VEC.W1.VSIZE# = ECMD.DISPBYT(1) - ECMD.DISPBYT(0);
           END;
        IF ECMD.DISPOP AND ECMD.REC_FILE = %F_FILE
        THEN DISP_REC_IN_FILE = ECMD.DISPREC;
        DO WHILE( NOT EOT );
           CUR_REC# = CUR_REC# + 1;
           DO I = 0 TO 1;
              IF ECMD.IOTYPE = %E_OUT
              THEN I = 1;
              BREAK_DCB$ = DCBADDR( ECMD.DCB#(I) );
              CMD.DCB# = ECMD.DCB#(I);
              EOF = ECMD.EOF(I);
              CALL MT$READ( CMD.BLKSZ, ERR) ALTRET( MON_ERR );
              IF DEOD AND ECMD.DEOD
              THEN EOT = '1'B;
              IF EOF THEN DO;
                 IF ECMD.EOF(I)
                 THEN ECMD.EOT(I) = '1'B;
                 ELSE ECMD.EOF(I) = '1'B;
                 IF ECMD.EOT(I) AND ECMD.IOTYPE = %E_BOTH THEN DO;
                    IF I = 0 AND NOT ECMD.EOT(1) THEN DO;
                       ECMD.IOTYPE = %E_OUT;
                       EOT = '0'B;
                       END;
                    IF I = 1 AND NOT ECMD.EOT(0) THEN DO;
                       ECMD.IOTYPE = %E_IN;
                       EOT = '0'B;
                       END;
                    END;
                 IF ECMD.DISP_BACK THEN DO;
                    IF BACK_REC#(I) = 0 AND CUR_REC# ~= 0
                    THEN BACK_REC#(I) = CUR_REC# - 1; /* EOF is a rec cnt     */
                    BACK_FIL#(I) = BACK_FIL#(I) + 1;
                    END;
                 END;
              ELSE ECMD.EOF(I) = EOF;
              IF ECMD.DISPOP THEN DO;
                 CALL MT$DISP ALTRET( JUSTALT);
                 END;
              IF EOF AND ECMD.REC_FILE = %F_FILE THEN DO;
                 ECMD.DISPREC = DISP_REC_IN_FILE;
                 ECMD.DISPOP = WAS_DISP;
                 IF NOT ECMD.ALL_RF THEN DO;
                    ECMD.NUM_RF = ECMD.NUM_RF - 1;
                    IF ECMD.NUM_RF <= 0
                    THEN EOT = '1'B;
                    END;
                 END;
              IF ECMD.FCODE = %A_COPY THEN DO;
                 I = 1;
                 BREAK_DCB$ = DCBADDR( ECMD.DCB#(I) );
                 CALL MT$COPY(ERR) ALTRET(JUSTALT);
                 END;
              IF ECMD.REC_FILE=%F_REC
              THEN DO;
                 IF( (ECMD.IOTYPE = %E_IN AND I=0 ) OR ( I=1 AND
                   (ECMD.IOTYPE=%E_BOTH OR ECMD.IOTYPE=%E_OUT) ) )
                 THEN ECMD.NUM_RF = ECMD.NUM_RF - 1;
                 IF EOF OR(ECMD.NUM_RF <= 0 AND NOT ECMD.ALL_RF) THEN DO;
                    EOT = '1'B;
                    IF ECMD.NUM_RF > 0 THEN DO;
                       CALL BINCHAR( LEFT_REC, CUR_REC# - 1 );
                       CALL CONCAT( BLANK, 'Only ', LEFT_REC,' in current file.' );
                       CALL M$WRITE( BLANK_WRT ) ALTRET(MON_ERR);
                       BLANK= ' ';
                       END;
                    END;
                 END;
              IF EOF AND ( (ECMD.IOTYPE=%E_IN AND I=0 )OR( I=1 AND
                (ECMD.IOTYPE=%E_BOTH OR ECMD.IOTYPE=%E_OUT) )
                OR ECMD.FCODE=%A_COPY )
              THEN CUR_REC# = 0;
              IF ECMD.IOTYPE = %E_IN
              THEN I = 1;
              IF BREAK_COUNT > 0 AND NOT ECMD.DISPOP OR BREAK_COUNT > 1
              THEN ALTRETURN;
              END;                      /* DO I = 0 TO 1                      */
           DO WHILE( '0'B );
MON_ERR:      ;
              CALL RPT_ERR( ,CMD.DCB#);
JUSTALT:      ;
              IF ECMD.ERRCONT THEN DO;
                 IF CMD.FCODE = %FLC_WRITE /* KEEP FROM GOING TO NEXT RECORD  */
                 THEN ALTRETURN;
                 END;
              ELSE ALTRETURN;
              END;
           IF BREAK_COUNT > 0 AND NOT ECMD.DISPOP OR BREAK_COUNT > 1
           THEN ALTRETURN;
           END;                         /* DO WHILE NOT EOT                   */
END MT$MOVE;
%EJECT;
MT$DISP: PROC ALTRET;
        IF ECMD.DISPFULL
        THEN DISP_VEC.W1.VSIZE# = READBYT - 1;
        ELSE DO;
           IF ECMD.DISPBYT(0) > ( READBYT - 1 ) THEN DO;
              DISP_OUT = '1'B;
              END;
           IF ECMD.DISPBYT(1) > ( READBYT - 1 ) THEN DO;
              DISP_VEC.W1.VSIZE# = READBYT - 1 - ECMD.DISPBYT(0);
              DISP_PAR = '1'B;
              END;
           END;
        CALL MT$DUMP ALTRET( JUSTALT );
        IF DISP_PAR THEN DO;
           DISP_PAR = '0'B;
           DISP_VEC.W1.VSIZE# = ECMD.DISPBYT(1) - ECMD.DISPBYT(0);
           END;
        IF( (ECMD.IOTYPE = %E_IN AND I=0 ) OR ( I=1 AND
          (ECMD.IOTYPE=%E_BOTH OR ECMD.IOTYPE=%E_OUT ) ) )
          AND NOT(ECMD.FCODE=%A_DISP AND ECMD.REC_FILE=%F_FILE )
          OR (ECMD.FCODE = %A_COPY AND I=0 )
        THEN ECMD.DISPREC = ECMD.DISPREC - 1;
        IF ECMD.DISPREC <= 0 AND NOT ECMD.DISPALL THEN DO;
           ECMD.DISPOP = '0'B;
           IF ECMD.FCODE = %A_DISP
           THEN EOT = '1'B;
           END;
        RETURN;
JUSTALT:;
        ALTRETURN;
END MT$DISP;
%EJECT;
MT$COPY: PROC(ERR) ALTRET;
DCL ERR UBIN ALIGNED;
DCL TEMP$ PTR;
DCL WRTBYT SBIN ALIGNED;
        CMD.FCODE = %FLC_WRITE;
        CMD.DCB# = ECMD.DCB#(I);
        IF ECMD.COPYFULL
        THEN WRTBYT = READBYT;
        ELSE DO;
           IF ECMD.COPYBYT(1) > ( READBYT - 1 )
             OR ECMD.COPYBYT(0) > ( READBYT - 1 ) THEN DO;
              DISP_OUT = '1'B;
              CALL MT$DUMP ALTRET( JUSTALT );
              EOT = '1'B;
              END;
           TEMP$ = BUFF$;
           BUFF$ = PINCRC( BUFF$, ECMD.COPYBYT(0) );
           WRTBYT = ECMD.COPYBYT(1) - ECMD.COPYBYT(0) + 1;
           END;
        IF NOT EOF AND NOT DISP_OUT
        THEN CALL MT$WRITE( WRTBYT, ERR ) ALTRET( MON_ERR );
        ELSE IF EOF
           THEN CALL M$WEOF(FPT_WEOF) ALTRET( MON_ERR );
        IF NOT ECMD.COPYFULL
        THEN BUFF$ = TEMP$;
        RETURN;
MON_ERR:;
        CALL RPT_ERR( ,CMD.DCB#);
JUSTALT:;
        ALTRETURN;
END MT$COPY;
%EJECT;
MT$DUMP:PROC ALTRET;
DCL CHAR$32 CHAR(32) BASED;
DCL BUF_LEN SBIN WORD;
DCL CHR$ARY(0:0) CHAR(1) BASED;
DCL 1 PRINTABLE_XLATE_TBL CONSTANT ALIGNED,
      2 *(0:511) BIT(9) UNAL INIT(
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '040'O,'041'O,'042'O,'043'O,'044'O,'045'O,'046'O,'047'O,
        '050'O,'051'O,'052'O,'053'O,'054'O,'055'O,'056'O,'057'O,
        '060'O,'061'O,'062'O,'063'O,'064'O,'065'O,'066'O,'067'O,
        '070'O,'071'O,'072'O,'073'O,'074'O,'075'O,'076'O,'077'O,
        '100'O,'101'O,'102'O,'103'O,'104'O,'105'O,'106'O,'107'O,
        '110'O,'111'O,'112'O,'113'O,'114'O,'115'O,'116'O,'117'O,
        '120'O,'121'O,'122'O,'123'O,'124'O,'125'O,'126'O,'127'O,
        '130'O,'131'O,'132'O,'133'O,'134'O,'135'O,'136'O,'137'O,
        '140'O,'141'O,'142'O,'143'O,'144'O,'145'O,'146'O,'147'O,
        '150'O,'151'O,'152'O,'153'O,'154'O,'155'O,'156'O,'157'O,
        '160'O,'161'O,'162'O,'163'O,'164'O,'165'O,'166'O,'167'O,
        '170'O,'171'O,'172'O,'173'O,'174'O,'175'O,'176'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
        '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O);
DCL EOD_LIT CHAR(0) CONSTANT INIT('--EOD--ENCOUNTERED');
DCL OUT_LIT CHAR(0) CONSTANT INIT('--RANGE--out of data segment');
DCL 1 BUF_VECTOR,
      2 WBOUND UBIN(18) UNAL,
      2 * BIT(18) UNAL,
      2 PTR$ PTR UNAL;
DCL REC_LEN SBIN WORD;
DCL IN$REC CHAR(REC_LEN) BASED;
DCL DUMP_BUF CHAR(4096) STATIC;
DCL DUMP_BUF_ARY(0:4095) REDEF DUMP_BUF CHAR(1);
DCL 1 DMP_BUF REDEF DUMP_BUF,
      2 SEQ(0:5) CHAR(1),
      2 STAR CHAR(1),
      2 REST CHAR(4089);
DCL WORDS_TO_DUMP SBIN WORD;
DCL CHARS_TO_DUMP SBIN WORD;
DCL WORD_OFFSET SBIN WORD;
DCL CHAR_OFFSET SBIN WORD;
DCL J SBIN WORD;
DCL K SBIN WORD;
DCL L SBIN WORD;
DCL SAVE_BUF CHAR(128);
DCL SAVE_BUF_ARY(0:383) REDEF SAVE_BUF UBIN(3) UNAL;
DCL STAR_FLAG SBIN WORD;
DCL CHAR$ PTR;
DCL 1 TEXT$ PTR;
DCL LAST_WORD_OFFSET SBIN WORD;
DCL CHAR$ACTER CHAR(1) BASED;
DCL OUTPUT_PWIDTH SBIN ALIGNED;
DCL M$LO DCB;
DCL DCB$ PTR;
%F$DCB;
%FPT_WRITE( FPTN=DUMP_WRT,
            DCB=M$LO,
            BUF=DUMP_BUF);
        DCB$ = DCBADDR( DCBNUM( M$LO ) );
        BUF_VECTOR = DISP_VEC;
        REC_LEN = DISP_VEC.W1.VSIZE# + 1;
        OUTPUT_PWIDTH = DCB$->F$DCB.WIDTH#;
        IF EOF THEN DO;
           DUMP_BUF = EOD_LIT;
           CALL M$WRITE( DUMP_WRT );
           END;
        ELSE DO;
           CALL OUT_KEY;
           IF DISP_OUT THEN DO;
              DISP_OUT = '0'B;
              DUMP_BUF = OUT_LIT;
              CALL M$WRITE( DUMP_WRT );
              END;
           ELSE DO;
              IF DISP_PAR THEN DO;
                 DUMP_BUF = OUT_LIT;
                 CALL M$WRITE( DUMP_WRT );
                 END;
              CALL DUMP_OCT;
              END;
           END;
        RETURN;
%EJECT;
DUMP_OCT: PROC;
/*I* NAME: DUMP_OCT
     PURPOSE: To dump the current record in octal format.
     DESCRIPTION: This procedure dumps the current record in octal  format.
*/
DCL DISPWD UBIN ALIGNED;
 
        IF ECMD.DISPBYT(0) <= 0
        THEN DISPWD = 0;
        ELSE DISPWD = ECMD.DISPBYT(0) / 4;
        IF NOT ECMD.DISP_OCT            /* TEXT=DEFAULT                       */
        THEN
           WORDS_TO_DUMP = ((OUTPUT_PWIDTH - SIZEC(DMP_BUF.SEQ) -1)/18)*4;
        ELSE
           WORDS_TO_DUMP = ((OUTPUT_PWIDTH - SIZEC(DMP_BUF.SEQ) -2)/18/2)*2;
        IF WORDS_TO_DUMP=0
        THEN
           WORDS_TO_DUMP = 1;
        CHARS_TO_DUMP = WORDS_TO_DUMP*4;
        TEXT$ = PINCRC(ADDR(DUMP_BUF),SIZEC(DMP_BUF.SEQ) +2 + WORDS_TO_DUMP*14);
        STAR_FLAG = 0;
        LAST_WORD_OFFSET = ((REC_LEN-1)/4/WORDS_TO_DUMP)*WORDS_TO_DUMP+ DISPWD;
        DO WORD_OFFSET=DISPWD TO LAST_WORD_OFFSET BY WORDS_TO_DUMP;
           CHAR_OFFSET = ( WORD_OFFSET-DISPWD ) * 4;
           IF WORD_OFFSET=LAST_WORD_OFFSET
           THEN
              CHARS_TO_DUMP = REC_LEN- CHAR_OFFSET;
           IF (SUBSTR(BUF_VECTOR.PTR$->IN$REC,CHAR_OFFSET,CHARS_TO_DUMP)
             =SAVE_BUF)
             AND (WORD_OFFSET~=DISPWD)
             AND (WORD_OFFSET~=LAST_WORD_OFFSET)
           THEN
              STAR_FLAG = 1;
           ELSE
           DO;
              CHAR$ = ADDR(DMP_BUF.REST);
              SAVE_BUF = SUBSTR(BUF_VECTOR.PTR$->IN$REC,
                CHAR_OFFSET,
                CHARS_TO_DUMP);
              DUMP_BUF = ' ';
              J = WORD_OFFSET;
              DO K=0 TO SIZEC(DMP_BUF.SEQ) -1;
                 CALL BINCHAR(DMP_BUF.SEQ(SIZEC(DMP_BUF.SEQ) -1 -K),MOD(J,8));
                 J = J/8;
                 END;
              IF STAR_FLAG=1
              THEN
              DO;
                 DMP_BUF.STAR = '*';
                 STAR_FLAG = 0;
                 END;
              IF ECMD.DISP_OCT THEN DO;
                 DO J=0 TO CHARS_TO_DUMP-1;
                    DO CASE(MOD(J,4));
                     CASE(0);
                       CHAR$ = PINCRC(CHAR$,1);
                     CASE(2);
                       CHAR$->CHAR$ACTER = '.';
                       CHAR$ = PINCRC(CHAR$,1);
                     END;
                    L = J*3;
                    DO K=0 TO 2;
                       CALL BINCHAR(CHAR$->CHR$ARY(K),SAVE_BUF_ARY(L+K));
                       END;
                    CHAR$ = PINCRC(CHAR$,3);
                    END;
                 END;
              ELSE DO;
                 DO J = 0 TO CHARS_TO_DUMP - 1;
                    CHAR$->CHR$ARY(J) = SUBSTR( SAVE_BUF,J,1 );
                    END;
                 END;
              IF NOT ECMD.DISP_OCT      /*  TEXT=DEFAULT                      */
              THEN
              CALL M$WRITE( DUMP_WRT );
              ELSE DO;
                 CALL XLATE(TEXT$->CHAR$32,PRINTABLE_XLATE_TBL,SAVE_BUF);
                 CALL M$WRITE( DUMP_WRT );
                 END;
              END;
           IF BREAK_COUNT > 0 THEN DO;
             IF BREAK_COUNT = 1
             THEN BREAK_COUNT = 0;
             RETURN;
             END;
           END;
END DUMP_OCT;
%EJECT;
OUT_KEY: PROC ALTRET;
DCL 1 CONV_TBL(0:3) CONSTANT,
      2 MICROP BIT(9) INIT(%MVZB8,%MVZB8,%MVZB5,%MVZB6),
      2 DIV UBIN(18) UNAL INIT(9000,9000,36,180),
      2 UNITS CHAR(11) INIT(' BYTES',' BYTES',' WORDS(L66)',' WORDS(L6)');
DCL SEQ_BUF CHAR(6);
DCL IN_ARS UBIN ALIGNED;
DCL MOP_SEQNO(0:5) BIT(9) STATIC INIT(
                %MVZB5,                 /* MOVE 5 DIGITS WITH ZERO SUP.       */
              %SES10,                   /* RESET FLAG                         */
                %MVC1,                  /* MOVE LAST DIGIT                    */
                %INSB1,                 /* OUTPUT A BLANK                     */
                %INSB4,                 /* OUTPUT A DASH                      */
                %INSB1);                /* OUTPUT A BLANK                     */
DCL MOP_RECLEN(0:4) BIT(9) STATIC INIT(%MVZB1,%SES10,%MVC1,%INSB7,%MVC2);
    /* This MOP string is used to format the record length number. The first
    entry (%MVZB1) will be replaced by the correct MOP before EDITCHAR is
    called.                                                                   */
DCL RECLEN_BUF CHAR(9);
DCL START_IDX SBIN WORD;
DCL OCBX SBIN ALIGNED;
        START_IDX = 0;
        OCBX = 0;
        IN_ARS = READBYT;
        CALL INSERT(DUMP_BUF,0,132,' ');
        IF CUR_REC#>0                   /* PUT OUT A RECORD SEQUENCE          */
        THEN                            /* NUMBER IF KNOWN                    */
        DO;
           CALL BINCHAR(SEQ_BUF,CUR_REC#);
           CALL EDITCHAR(DUMP_BUF,
             START_IDX,
             9,
             MOP_SEQNO,
             SEQ_BUF);
           START_IDX = START_IDX+9;
           END;
        CALL BINCHAR(RECLEN_BUF,(IN_ARS*9000)/CONV_TBL.DIV(OCBX));
        MOP_RECLEN(0) = CONV_TBL.MICROP(OCBX);
        CALL EDITCHAR(DUMP_BUF,
          START_IDX,
          9,
          MOP_RECLEN,
          RECLEN_BUF);
        CALL INSERT(DUMP_BUF,
          START_IDX+9,
          11,
          CONV_TBL.UNITS(OCBX));
        START_IDX = START_IDX +23;      /* Point past the byte count          */
        CALL INSERT(DUMP_BUF,
          START_IDX-1,,
          '[');
        IF DCB$->F$DCB.DVBYTE.VFC#
        THEN                            /* Rec. has VFC                       */
        DO;
           CALL INSERT(DUMP_BUF,
             START_IDX,,
             'VFC,');                   /* Stuff in the notice                */
           START_IDX = START_IDX+4;
           END;
        IF DCB$->F$DCB.DVBYTE.BIN#
        THEN                            /* Rec. was created in BINary format  */
        DO;
           CALL INSERT(DUMP_BUF,
             START_IDX,,
             'BIN,');                   /* Stuff in the notice                */
           START_IDX = START_IDX+4;
           END;
        IF DCB$->F$DCB.DVBYTE.TRANS#
        THEN                            /* Rec. was created in TRANSparent    */
        DO;
           CALL INSERT(DUMP_BUF,
             START_IDX,,
             'TRANS,');                 /* Stuff in the notice                */
           START_IDX = START_IDX+6;
           END;
        IF SUBSTR (DUMP_BUF,START_IDX -1,1)=','
        THEN                            /* We left a hanging comma            */
        DO;                             /* Stomp on it                        */
           CALL INSERT (DUMP_BUF,
             START_IDX -1,,
             ']');
           END;
        ELSE                            /* No attributes, '[' is hanging      */
        DO;                             /* Stomp on it                        */
           CALL INSERT (DUMP_BUF,
             START_IDX -1,,
             ' ');
           END;
        CALL M$WRITE( DUMP_WRT ) ALTRET( JUSTALT );
        RETURN;
JUSTALT: ;
        ALTRETURN;
END OUT_KEY;
 
END MT$DUMP;
END TAPETEST;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
MT$BRK: PROC ASYNC;
/*F*  NAME: MT$BRK
      PURPOSE: Break handling routine.
*/
 
 /***
  *** INCLUDE
  ***/
 
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE XUR_ENTRY;
 
 /***
  *** DCB
  ***/
 
DCL M$LO DCB;
 
 /***
  *** SYMREF
  ***/
 
DCL BREAK_COUNT SBIN SYMREF;
DCL BREAK_DCB$ PTR SYMREF;
DCL BREAK_TASK CHAR(22) SYMREF;
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
 
 /***
  *** STATIC
  ***/
 
DCL 1 BRK_MSG STATIC,
      2 * CHAR(0) INIT('...'),
      2 TASK CHAR(22),
      2 * CHAR(0) INIT(' '),
      2 INFOCHARS CHAR(18),
      2 INFO REDEF INFOCHARS,
        3 DP# CHAR(3),
        3 PSN CHAR(6),
        3 DOT CHAR(1),
        3 ACCT CHAR(8);
 
 /***
  *** FPT
  ***/
 
%FPT_TRMPRG(FPTN = FPT_TRMPRG,
            RSTBRK = YES,
            STCLASS=CONSTANT );
 
%FPT_WRITE(FPTN = FPT_WRITE,
           DCB = M$LO,
           BUF = BRK_MSG,
           STCLASS=CONSTANT );
 
 /***
  *** BASED
  ***/
 
%F$DCB( BASED="BASED(BREAK_DCB$)" );
%B$TCB;
%B$EXCFR;
 
/****************************************/
 
        BREAK_COUNT = B$TCB$->B$TCB.STK$->B$EXCFR.BRKCNT;
        IF BREAK_DCB$ ~= ADDR(NIL)
        THEN DO;
           BRK_MSG.INFO.PSN = F$DCB.PSN#;
           BRK_MSG.INFO.ACCT = ' ';
           BRK_MSG.INFO.DP# = 'MT#';
           BRK_MSG.INFO.DOT = ' ';
           END;
        ELSE DO;
           BRK_MSG.INFOCHARS = ' ';
           END;
        BRK_MSG.TASK = BREAK_TASK;
        CALL M$WRITE(FPT_WRITE);
        CALL M$TRMPRG(FPT_TRMPRG);
 
END MT$BRK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
RPT_ERR: PROC( ERR, DCB# );
/*F*  NAME: RPT_ERR
      PURPOSE: Reports errors.
 */
 
DCL ERR BIT(36) ALIGNED;                /* Error word in standard format      */
DCL DCB# UBIN WORD ALIGNED;        /* Number of DCB associated with error     */
 
 /***
  *** INCLUDE
  ***/
 
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE XUR_ENTRY;
 
 /***
  *** SYMREF
  ***/
 
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
 
 /***
  *** AUTO
  ***/
 
DCL 1 ERRCODE AUTO,
      2 * BIT(33) UNAL,
      2 SEV UBIN(3) UNAL;
DCL THE_DCB# UBIN WORD AUTO;
 
 /***
  *** BASED
  ***/
 
%B$TCB;
%B$ALT;
 
/****************************************/
 
        IF ADDR(DCB#) ~= ADDR(NIL)
        THEN THE_DCB# = DCB#;
        ELSE THE_DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
 
        IF ADDR(ERR) ~= ADDR(NIL)
        THEN ERRCODE = ERR;
        ELSE ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
 
        IF B$JIT.MODE = %M_INT#
        THEN ERRCODE.SEV = 0;           /* Use one-liner                      */
 
        CALL XUR$ERRMSG( ERRCODE, THE_DCB# )
        WHENALTRETURN DO;
           CALL M$XXX;
           END;
 
        RETURN;
 
END RPT_ERR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
MT$UTS_TO_TIME: PROC( UTS, TIME );
/*F*  NAME: MT$UTS_TO_TIME
      PURPOSE: Converts elapsed UTS to textual time.
 */
 
%INCLUDE XUD_UTS_M;
%XUD$UTS_ENTRIES;
%XUD_UTS_EQU;
DCL UTS UBIN WORD ALIGNED;              /* Elapsed UTS                        */
DCL 1 TIME CALIGNED,                    /* Returned textual representation    */
      2 HH CHAR(2),
      2 COL1 CHAR(1),
      2 MM CHAR(2),
      2 COL2 CHAR(1),
      2 SS CHAR(2);
 
 /***
  *** AUTO
  ***/
 
DCL REMAINDER SBIN AUTO;
DCL QUOTIENT SBIN AUTO;
 
/****************************************/
 
        TIME.COL1 = ':';
        TIME.COL2 = ':';
 
        CALL XUD$UTS_DIFF_SEC(QUOTIENT,UTS,0);   /* Number of hours                    */
        QUOTIENT = QUOTIENT / 3600;
        CALL BINCHAR( TIME.HH, QUOTIENT );
        CALL XUD$UTS_DIFF_25TH(REMAINDER,UTS,QUOTIENT*%UTS_25TH_HOUR#);
        CALL XUD$UTS_DIFF_SEC(QUOTIENT,REMAINDER,0);    /* Number of minutes                  */
        QUOTIENT = QUOTIENT / 60;
        CALL BINCHAR( TIME.MM, QUOTIENT );
        CALL XUD$UTS_DIFF_25TH(REMAINDER,REMAINDER,QUOTIENT*%UTS_25TH_MIN#);
        CALL XUD$UTS_ADJ_25TH(REMAINDER,REMAINDER,%UTS_25TH_SEC#/2); /* Round up to nearest second         */
        CALL XUD$UTS_DIFF_SEC(QUOTIENT,REMAINDER,0);
        CALL BINCHAR( TIME.SS, QUOTIENT );
        RETURN;
 
END MT$UTS_TO_TIME;
