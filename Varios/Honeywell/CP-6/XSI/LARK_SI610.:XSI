/*M* LARK_SI610  LARK_STARTFPRG_CMD                          */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_STARTFPRG_CMD
   PURPOSE:       Process the STARTFPRG command
   DESCRIPTION:   This module receives the parse tree for a STARTFPRG command
                  and processes it into data structures used with the
                  M$ACTIVATE, M$SETFP, and M$OPEN monitor services
*/
/*D*
   NAME:          LARK_STARTFPRG_CMD
   CALL:          CALL LARK_STARTFPRG_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_PROCESS_FID
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
   INPUT:         PARSE$OUT
   OUTPUT:        LARK$GETCMD_ (information in structure is important for "?")
   SCRATCH:       VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   DESCRIPTION:   STARTFPRG_CMD syntax =
                     ( 'STARTF/PRG' | 'SF/PRG' ) ;
                     [ CG_FID ] ;
                     STOPFPRG_OPTION_LIST
*/
 
 
%EJECT ;
LARK_STARTFPRG_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
%INCLUDE B_ERRORS_C ;
 
%LARK_GLOBALS ;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
%LARK_PROCESS_FID ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_GET_SLOT ;
%LARK_CHECK_NWIO_ERRORS ;
%LARK_CHECK_AUEVENT ;
%LARK_READ_MESSAGE ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
/*E*
   ERROR:          LAR-E$LARK_NEED_FPRG_AND_STA#-3
   MESSAGE0:       Both an fprg fid and station name must be specified
   MESSAGE1:       The user didn't specify an fprg or a station name or both
   MESSAGE2:       Both the FPRG and SNAME options must be given
   DESCRIPTION:    User must specify both the FPRG and SNAME options
*/
 
/*E*
   ERROR:          LAR-E$LARK_FEP_WARNING#-1
   MESSAGE0:       The FEP option will be ignored when DEVPRES = YES
   MESSAGE1:       The FPRG must be in the same FEP as the device
   DESCRIPTION:    The FEP option is meeningless with DEVPRES = YES
*/
 
/*E*
   ERROR:          LAR-E$LARK_FPRG_DIDNT_START#-3
   MESSAGE0:       LARK was unable to start the fprg
   MESSAGE1:       LARK will give up on an fprg if it doesn't load in 5 minutes
   MESSAGE2:       LARK wiated for 5 minutes and the fprg wouldn't load into the
fep
   MESSAGE3:       There might be something wrong with the fep
   DESCRIPTION:    The fprg would not load in 5 minutes and LARK gave up
*/
 
/*E*
   ERROR:          LAR-E$LARK_NEED_AU#-2
   MESSAGE0:       You must be the AU to execute this command
   MESSAGE1:       To connect an fprg station, you must be the AU
   DESCRIPTION:    Fprgs can only be connected in the presence of an AU
*/
 
/*E*
   ERROR:           LAR-E$LARK_DEBUG_IGNORED#-1
   MESSAGE0:        With DEVPRES=NO, the DEBUG option is ignored
   MESSAGE1:        The DEBUG option is meaningful only when DEVPRES = YES
   DESCRIPTION:     DEBUG is for DEVPRES = YES
/*
   Structures
*/
 
%LARK_PARSEBLKS ;
%LARK_FPRGLIST ;
 
%B$ALT ;
%B$TCB ;
%F$DCB ;
%EJECT ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPT_STARTFPRG_ACT,
         STCLASS              = CONSTANT,
         DCB                  = M$CTRLCG,
         MAKEFPRG             = YES ) ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPTSTARTFPRG_ACT,
         STCLASS              = AUTO ) ;
 
%VLP_STATION
       ( FPTN                 = VLP_STARTFPRG_STA,
         STCLASS              = CONSTANT ) ;
 
%VLP_STATION
       ( FPTN                 = VLPSTARTFPRG_STA,
         STCLASS              = AUTO ) ;
 
%FPT_SETFP
       ( FPTN                 = FPT_STARTFPRG_SETFP,
         STCLASS              = CONSTANT,
         DCB                  = M$CTRLCG ) ;
 
%FPT_SETFP
       ( FPTN                 = FPTSTARTFPRG_SETFP,
         STCLASS              = AUTO ) ;
 
%FPT_OPEN
       ( FPTN                  = FPT_STARTFPRG_OPEN,
         STCLASS               = CONSTANT ) ;
 
%FPT_OPEN
       ( FPTN                  = FPTSTARTFPRG_OPEN,
         STCLASS               = AUTO ) ;
 
%FPT_CLOSE
       ( FPTN                  = FPT_STARTFPRG_CLOSE ) ;
 
%FPT_FID
       ( FPTN                  = FPT_STARTFPRG_FID,
        STCLASS                = STATIC ) ;
 
%VLP_NAME
       ( FPTN                  = VLP_STARTFPRG_NAME,
         STCLASS               = STATIC ) ;
 
%VLP_ACCT
       ( FPTN                  = VLP_STARTFPRG_ACCT ) ;
 
%VLP_PASS
       ( FPTN                  = VLP_STARTFPRG_PASS ) ;
 
%VLP_SN
       ( FPTN                  = VLP_STARTFPRG_SN ) ;
 
%VLP_FPRG
       ( FPTN                  = VLP_STARTFPRG_FPRG,
         STCLASS               = STATIC ) ;
 
%VLP_NAME
       ( FPTN                  = VLP_FPRG_NAME,
         STCLASS               = STATIC ) ;
 
%VLP_ACCT
       ( FPTN                  = VLP_FPRG_ACCT,
         STCLASS               = STATIC ) ;
 
%VLP_PASS
       ( FPTN                   = VLP_FPRG_PASS,
         STCLASS                = STATIC ) ;
 
%VLP_SN
       ( FPTN                   = VLP_FPRG_SN,
         STCLASS                = STATIC ) ;
%FPT_WAIT
 
       ( FPTN                   = WAIT_FOR_CONNECT,
         STCLASS                = STATIC ) ;
 
                                          /* This structure is used to
                                             to dynamically allocate DCBs.
                                             The DCBs are named M$FPRGxx
                                             where 'xx' will be replaced
                                             with the number of the position
                                             that the fprg occupies in
                                             FPRGLIST                   */
%VLP_NAME
       (FPTN                  = M$FPRG_DCB,
        NAME                  = 'M$FPRGxx' ) ;
%EJECT ;
 
/*
  Local data
*/
 
DCL B$TCB$            PTR SYMREF ;
DCL BLK$              PTR ;
DCL SUBLK$            PTR ;
DCL SYM$              PTR ;
DCL YES_NO            BIT  (  1 ) ;
DCL STA#              CHAR (  8 ) ;
DCL FPRG#             CHAR ( 52 ) ;
DCL FEP#              CHAR (  4 ) ;
DCL DEVPRES#          BIT  (  1 ) ;
DCL DEBUG#            BIT  (  1 ) ;
DCL 1  DCB#,
        2 *           BIT  ( 18 ) HALIGNED,
        2 DCB_NUM     UBIN ( 18 ) HALIGNED ;
DCL DCB_SBIN          REDEF DCB# SBIN ;
DCL FPRG_HERE#        BIT  (  1 ) ;
DCL STA_HERE#         BIT  (  1 ) ;
DCL FEP_HERE#         BIT  (  1 ) ;
DCL SLOT              SBIN ;
DCL SLOT_CHAR         CHAR (  2 ) ;
DCL I                 SBIN ;
DCL TIME_TO_WAIT      UBIN ;
DCL TIME_LEFT         UBIN STATIC INIT (0) ;
DCL JUNK              CHAR ( 12 ) ;
 
%EJECT ;
 
/*
   INIT SOME FLAGS
*/
 
FPRG_HERE# = %FALSE ;
STA_HERE#  = %FALSE ;
FEP_HERE#  = %FALSE ;
 
DEVPRES# = %FALSE ;
 
IF ( P_OUT$BLK.CODE ~= %STARTFPRG_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR (P_OUT$BLK.NSUBLKS >  2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ; /* IF */
 
IF  ~ M$CTRLCG$ -> F$DCB.AU# THEN DO ;
    CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NEED_AU#, 3 ) ;
    GOTO ALT ;
END ;
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
/*
   Process the CG_FID if it has been specified
*/
 
IF  ( BLK$ -> OUT$SYM.CODE = %CG_FID ) THEN DO ;
    CALL LARK_PROCESS_FID ( VECTOR ( BLK$ -> OUT$SYM.TEXT ) )  ALTRET ( ALT ) ;
END ;
 
/*
   Process the STARTFPRG_OPTION_LIST
*/
 
FPTSTARTFPRG_ACT = FPT_STARTFPRG_ACT ;
FPTSTARTFPRG_ACT.V_ = VECTOR ( FPTSTARTFPRG_ACT.V ) ;
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
   BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
END ;
 
IF ( BLK$ -> OUT$BLK.CODE ~= %STARTFPRG_OPTION_LIST ) OR
   ( BLK$ -> OUT$BLK.NSUBLKS < 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
DO I = 0 TO ( BLK$ -> OUT$BLK.NSUBLKS - 1 ) ;
   SUBLK$ = BLK$ -> OUT$BLK.SUBLK$ ( I ) ;
   IF ( SUBLK$ -> OUT$BLK.NSUBLKS > 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM$ = SUBLK$ -> OUT$BLK.SUBLK$ ( 0 ) ;
   DO SELECT ( SYM$ -> OUT$BLK.CODE ) ;
      SELECT ( %YES ) ;
         YES_NO = %YES# ;
      SELECT ( %NO ) ;
         YES_NO = %NO# ;
      SELECT (%FPRG_FID, %FEP_NAME, %FPRG_STATION ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
   DO SELECT (SUBLK$ -> OUT$BLK.CODE ) ;
      SELECT ( %DEVICEPRESENT_OPT ) ;
         DEVPRES# = YES_NO ;
      SELECT ( %FPRG_STATION_OPT ) ;
         STA_HERE#                   = %TRUE ;
         VLPSTARTFPRG_STA            = VLP_STARTFPRG_STA ;
         VLPSTARTFPRG_STA.STATION#   = SYM$ -> OUT$SYM.TEXT ;
         FPTSTARTFPRG_ACT.STATION_   = VECTOR ( VLPSTARTFPRG_STA ) ;
         STA# = VLPSTARTFPRG_STA.STATION# ;
      SELECT ( %FEP_OPT ) ;
         FEP_HERE#                   = %TRUE ;
         CALL CONCAT (FEP#, 'FE', SYM$ -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT ) ;
      SELECT ( %PURESTATION_OPT ) ;
         VLPSTARTFPRG_STA            = VLP_STARTFPRG_STA ;
         VLPSTARTFPRG_STA.STATION#   = SYM$ -> OUT$SYM.TEXT ;
         FPTSTARTFPRG_ACT.FPRGSTA_   = VECTOR ( VLPSTARTFPRG_STA ) ;
      SELECT ( %FPRG_OPT ) ;
          FPRG_HERE#                 = %TRUE ;
         /*
           Processing the FID.
         */
         FPRG#                        = SYM$ -> OUT$SYM.TEXT ;
         FPT_STARTFPRG_FID.TEXTFID_   = VECTOR ( FPRG# ) ;
         FPT_STARTFPRG_FID.ACCT_      = VECTOR ( VLP_FPRG_ACCT ) ;
         FPT_STARTFPRG_FID.PASS_      = VECTOR ( VLP_FPRG_PASS ) ;
         VLP_FPRG_NAME.L#             = 31 ;
         FPT_STARTFPRG_FID.NAME_      = VECTOR ( VLP_FPRG_NAME ) ;
         FPT_STARTFPRG_FID.WSN_       = VECTOR ( JUNK ) ;
         FPT_STARTFPRG_FID.RESULTS_   = VECTOR ( JUNK ) ;
         FPT_STARTFPRG_FID.SN_        = VECTOR ( VLP_FPRG_SN ) ;
         FPT_STARTFPRG_FID.ASN_       = VECTOR ( JUNK ) ;
         FPT_STARTFPRG_FID.RES_       = VECTOR ( JUNK ) ;
         FPT_STARTFPRG_FID.RESULTS_   = VECTOR ( JUNK ) ;
         CALL M$FID ( FPT_STARTFPRG_FID )
              WHENALTRETURN DO ;
                 CALL LARK_REPORT_PMME_ERROR
                         ( B$TCB$->B$TCB.ALT$->B$ALT.ERR, M$CTRLCG_DCBNUM ) ;
                 GOTO ALT ;
              END ;
            VLP_STARTFPRG_FPRG.NAME         =  VLP_FPRG_NAME ;
            VLP_STARTFPRG_FPRG.ACCT#        =  VLP_FPRG_ACCT.ACCT# ;
            VLP_STARTFPRG_FPRG.PASS#        =  VLP_FPRG_PASS.PASS# ;
 
      SELECT ( %DEBUG_OPT ) ;
            DEBUG#                          =  %TRUE ;
            VLP_STARTFPRG_FPRG.FLGS.DEBUG#  =  %YES# ;
 
      SELECT ( %USEAUACCT_OPT ) ;
            FPTSTARTFPRG_ACT.V.USEAUACCT# = YES_NO;
 
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
       END ; /* DO SELECT */
    END ; /* DO WHILE */
 
IF  ( NOT FPRG_HERE# OR NOT STA_HERE# ) THEN DO ;
    CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NEED_FPRG_AND_STA#, 3 ) ;
    GOTO ALT ;
END ;
 
                                             /* Whether or not the fprg is */
                                             /* being started with an M$OPEN */
                                             /* we will need a dcb, so we  */
                                             /* might as well do the dirty */
                                             /* work here                  */
 
                                             /* 1st, find an unused slot   */
CALL LARK_GET_SLOT ( SLOT ) ALTRET ( ALT ) ;
                                             /* Now lets load some info that*/
                                             /* is the same for both cases  */
FPRGLIST.STATION# ( SLOT ) = STA# ;
FPRGLIST.FID#     ( SLOT ) = VLP_STARTFPRG_FPRG.NAME.C# ;
FPRGLIST.IN_USE#  ( SLOT ) = %TRUE ;
FPRGLIST_CT                = FPRGLIST_CT + 1 ;
 
                                             /* Now lets make a dcb name */
CALL BINCHAR ( SLOT_CHAR, SLOT ) ;
 
SUBSTR (M$FPRG_DCB.NAME#,6,2) = SLOT_CHAR ;
 
                                             /* Time to get a dcb...     */
CALL XUG$GETDCB ( M$FPRG_DCB,DCB_SBIN ) WHENALTRETURN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO PRE_ALT ;
         END ;
 
                                             /* Get the structure ready */
                                             /* for the open of the dcb */
FPTSTARTFPRG_OPEN         = FPT_STARTFPRG_OPEN ;
FPTSTARTFPRG_OPEN.V_      = VECTOR ( FPTSTARTFPRG_OPEN.V ) ;
FPTSTARTFPRG_OPEN.V.DCB#  = DCB#.DCB_NUM ;
FPTSTARTFPRG_OPEN.V.INITZ.SCRUB# = %YES# ;
FPRGLIST.DCB# ( SLOT )    = DCB#.DCB_NUM ;
                                             /* Now comes the hard work */
                                             /* We have 2 cases starting*/
                                             /* the fprg: devpres = yes */
                                             /* or devpres = no         */
IF DEVPRES# THEN DO ;
   IF ( FEP_HERE# = %TRUE ) THEN DO ;
       CALL LARK_REPORT_CMD_ERROR ( %E$LARK_FEP_WARNING#, 1 ) ;
       END ;
 
                                             /* This is a devpres=yes case  */
                                             /* so...                       */
   FPRGLIST.DEVPRES# ( SLOT ) = %TRUE ;
 
 
                                             /* The station will be activated
                                                thru the AU's dcb - M$CTRLCG  */
   FPTSTARTFPRG_ACT.V.DCB# = M$CTRLCG_DCBNUM ;
 
                                             /* We must issue an FM$DEACTIVATE
                                                so that if the CG allows auto
                                                connects, we don't die  */
   FPTSTARTFPRG_ACT.V.DISCONNECT# = %NO# ;
   CALL M$DEACTIVATE ( FPTSTARTFPRG_ACT )
        WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR,
                                          M$CTRLCG_DCBNUM ) ;
            GOTO PRE_ALT ;
        END ;
 
                                          /* Now get ready to activate the
                                             station                      */
 
   FPTSTARTFPRG_ACT.V.DISCONNECT#  =  %NO# ;
   FPTSTARTFPRG_SETFP              =  FPT_STARTFPRG_SETFP ;
   FPTSTARTFPRG_SETFP.STATION_     =  VECTOR ( STA# ) ;
 
   FPTSTARTFPRG_SETFP.FPRG_        =  VECTOR ( VLP_STARTFPRG_FPRG ) ;
   CALL M$ACTIVATE ( FPTSTARTFPRG_ACT )
        WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR,
                                          M$CTRLCG_DCBNUM ) ;
            GOTO PRE_ALT ;
        END ;
 
 
 
   FPRGLIST.ACTIVE# ( SLOT ) = %TRUE ;
 
                           /* Now, time for some wierdness. Since we can't  */
                           /* issue an M$SETFP on a dcb with an outstanding */
                           /* NWIO, we have to load the fprg on a different */
                           /* dcb.   We will open the dcb owned by the      */
                           /* current slot in FPRGLIST.  When the fprg sta  */
                           /* connects, the dcb will be closed.  The close  */
                           /* will take place in LARK_CHECK_AUEVENT. We need*/
                           /* the name of the currently active CG.  Since   */
                           /* the  global VLPs do not necessarily correspond*/
                           /* to this, we will have to pull this info from  */
                           /* the AU's DCB                                  */
 
   VLP_STARTFPRG_NAME.L#     = M$CTRLCG$ -> F$DCB.NAME#.L ;
   VLP_STARTFPRG_NAME.NAME#  = M$CTRLCG$ -> F$DCB.NAME#.C ;
   FPTSTARTFPRG_OPEN.NAME_   = VECTOR ( VLP_STARTFPRG_NAME ) ;
   VLP_STARTFPRG_PASS.PASS#  = M$CTRLCG$ -> F$DCB.PASS# ;
   FPTSTARTFPRG_OPEN.PASS_   = VECTOR ( VLP_STARTFPRG_PASS ) ;
   VLP_STARTFPRG_ACCT.ACCT#  = M$CTRLCG$ -> F$DCB.ACCT# ;
   FPTSTARTFPRG_OPEN.ACCT_   = VECTOR ( VLP_STARTFPRG_ACCT ) ;
   VLP_STARTFPRG_SN.NUM#     = 1 ;
   VLP_STARTFPRG_SN.SN#(0)   = M$CTRLCG$ -> F$DCB.PSN# ;
   FPTSTARTFPRG_OPEN.SN_     = VECTOR ( VLP_STARTFPRG_SN ) ;
   FPTSTARTFPRG_OPEN.V.ASN#  = %COMGROUP# ;
   FPTSTARTFPRG_OPEN.V.ORG#  = %CG# ;
   FPTSTARTFPRG_OPEN.V.FUN#  = %UPDATE# ;
 
                                             /* Now let's open this DCB       */
   CALL M$OPEN ( FPTSTARTFPRG_OPEN ) WHENALTRETURN DO ;
               CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                             DCB#.DCB_NUM ) ;
               GOTO PRE_ALT ;
               END ;
 
                                             /* After all that, we can now */
                                             /* (finally) issue the M$SETFP*/
 
   CALL M$SETFP ( FPTSTARTFPRG_SETFP )
        WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR,
                                          M$CTRLCG_DCBNUM ) ;
            GOTO PRE_ALT ;
        END ;
 
 
   END ; /* THEN */
ELSE DO ;
 
   IF DEBUG# THEN DO ;
       CALL LARK_REPORT_CMD_ERROR ( %E$LARK_DEBUG_IGNORED#, 1 ) ;
   END ;
 
                                             /* Let's get ready to open  */
 
   FPTSTARTFPRG_OPEN.FPRG_   = VECTOR ( VLP_STARTFPRG_FPRG ) ;
   FPTSTARTFPRG_OPEN.V.ORG#  = %FPRG# ;
   FPTSTARTFPRG_OPEN.V.FUN#  = %CREATE# ;
 
   IF ( FEP_HERE# ) THEN DO ;
      FPTSTARTFPRG_OPEN.V.RES# = FEP# ;
   END ;
 
                                              /* Get the info ready for   */
                                              /* wait for connect         */
   TIME_LEFT    = 300 ;
   TIME_TO_WAIT = 300 ;
   WAIT_FOR_CONNECT.UETIME_  = VECTOR ( TIME_LEFT ) ;
   WAIT_FOR_CONNECT.V.UNITS# = TIME_TO_WAIT ;
 
                                              /* Update the FPRGLIST      */
   FPRGLIST.DEVPRES# ( SLOT ) = %FALSE ;
                                              /* Load the fprg via an     */
                                              /* M$OPEN call              */
   CALL M$OPEN ( FPTSTARTFPRG_OPEN ) WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR,
                                          DCB#.DCB_NUM ) ;
            GOTO PRE_ALT ;
            END ;
 
 
                                              /* Now, lets wait for the    */
                                              /* beast to load.  LARK will */
                                              /* wait for 5 minutes before */
                                              /* giving up in complete     */
                                              /* disgust                   */
   DO UNTIL  FPRGLIST.ACTIVE# (SLOT) OR ( TIME_LEFT = 0 ) ;
      DO INHIBIT ;
      IF NOT CONTROL_NWIO.COMPLETE THEN DO ;
         CALL M$WAIT (WAIT_FOR_CONNECT ) ALTRET ( PRE_ALT ) ;
      END ;
      END ; /* INHIBIT */
      IF CONTROL_NWIO.COMPLETE THEN DO ;
         CALL LARK_CHECK_NWIO_ERRORS
               ALTRET ( PRE_ALT ) ;
         IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
            CALL LARK_CHECK_AUEVENT
                  WHENALTRETURN DO ;
                     CALL LARK_INTERNAL_ERROR ;
                     GOTO PRE_ALT ;
                   END ;
         END ;
         VLP$STATION_CONTROL.STATION# = '?' ;
         CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                                  VECTOR ( VLP$STATION_CONTROL ),
                                  VECTOR ( CONTROL_BUFFER ) )
               WHENALTRETURN DO ;
                  CALL LARK_INTERNAL_ERROR ;
                  GOTO PRE_ALT ;
               END ;
      END ;
      IF (TIME_LEFT ~= 0) THEN DO ;
         TIME_TO_WAIT = TIME_LEFT ;
         WAIT_FOR_CONNECT.V.UNITS# = TIME_TO_WAIT ;
         END ;
   END ;
                                                 /* If we failed load the */
                                                 /* fprg in 5 minutes,    */
                                                 /* free the slot and     */
                                                 /* report an error and   */
                                                 /* altret                */
   IF NOT FPRGLIST.ACTIVE# ( SLOT )  AND ( TIME_LEFT = 0 ) THEN DO ;
      CALL LARK_REPORT_CMD_ERROR ( %E$LARK_FPRG_DIDNT_START#, 3 ) ;
      FPRGLIST.IN_USE# ( SLOT ) = %FALSE ;
      GOTO PRE_ALT ;
   END ;
 
 
                                              /* Now lets activate the fprg */
 
   CALL M$ACTIVATE ( FPTSTARTFPRG_ACT )
        WHENALTRETURN DO ;
          CALL LARK_REPORT_PMME_ERROR ( B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR,
                                        FPRGLIST.DCB# ( SLOT ) ) ;
          GOTO PRE_ALT ;
        END ;
 
END ;
 
RETURN ;
 
PRE_ALT: ;
    FPRGLIST_CT  = FPRGLIST_CT - 1 ;
    FPRGLIST.IN_USE# ( SLOT ) = %FALSE ;
    FPT_STARTFPRG_CLOSE.V.DCB# = FPRGLIST.DCB#( SLOT ) ;
    CALL M$CLOSE ( FPT_STARTFPRG_CLOSE ) WHENALTRETURN DO ;
         IF ( B$TCB$->B$TCB.ALT$->B$ALT.CODE ~= %E$DCBCLOSED ) THEN DO ;
             CALL LARK_REPORT_PMME_ERROR ( B$TCB$ -> B$TCB.ALT$->B$ALT.ERR,
                                           FPRGLIST.DCB#( SLOT ) ) ;
           END ;
         END ;
 
ALT: ;
 
    ALTRETURN ;
 
 
END LARK_STARTFPRG_CMD ;
 
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*D*
   NAME:          LARK_GET_SLOT
   CALL:          CALL LARK_GET_SLOT ( SLOT )
   PARAMETERS:    SLOT is an SBIN value representing the empty slot in FPRGLIST
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_REPORT_CMD_ERROR
   INPUT:         FPRGLIST
   OUTPUT:        SLOT
*/
 
LARK_GET_SLOT : PROC ( SLOT ) ALTRET ;
/*
  Includes
*/
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE CP_6 ;
%INCLUDE XU_MACRO_C ;
 
%LARK_GLOBALS ;
 
/*
   Structures
*/
 
%LARK_FPRGLIST ;
 
/*
   Entries
*/
 
%LARK_REPORT_CMD_ERROR ;
/*
   Parameters
*/
 
DCL SLOT  SBIN PARAM ;
 
/*
  Error Messages
*/
 
/*E*
   ERROR:          LAR-E$LARK_NO_ROOM_FOR_FPRGS#-3
   MESSAGE0:       LARK can't start anymore fprgs!!
   MESSAGE1:       The maximum number of fprgs has been started
   MESSAGE2:       LARK can only have 64 active fprgs
   DESCRIPTION:    LARK has 64 active fprgs and can't start anymore
*/
 
/*
   Local Data
*/
 
DCL FOUND BIT ( 1 ) ;
 
%EJECT ;
 
 
                                               /* Find a slot in the fprg
                                                  table for this fprg to
                                                  occupy  */
 
   SLOT = 0 ;
   FOUND = %FALSE ;
   DO WHILE ( SLOT < %MAX_FPRGS ) & ( ~ FOUND );
      FOUND = ~ FPRGLIST.IN_USE# ( SLOT ) ;
      SLOT  = SLOT + 1 ;
   END ;
 
                                               /* Get rid of the (regretable)
                                                  off-by-one-error w/slot */
   SLOT = SLOT - 1 ;
 
   IF NOT FOUND THEN DO ;
          CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_ROOM_FOR_FPRGS#, 3 );
          GOTO ALT ;
   END ;
 
RETURN ;
 
ALT: ;
    ALTRETURN ;
 
END LARK_GET_SLOT ;
%EJECT ;
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*F*
   NAME:          LARK_PAUSE_CMD
   PURPOSE:       Process the PAUSE command
   DESCRIPTION:   This module receives the parse tree for a PAUSE command
                  and processes it into data structures used with the M$WAIT
*/
/*D*
   NAME:          LARK_PAUSE_CMD
   CALL:          CALL LARK_PAUSE_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_REPORT_CMD_ERROR
   INPUT:         PARSE$OUT
   DESCRIPTION:   PAUSE_CMD syntax =
                     'PA/USE' ;
                     WAIT_TIME
*/
 
%EJECT ;
LARK_PAUSE_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_CMD_ERROR ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
 
/*E*
   ERROR:            LAR-E$LARK_NEED_TO_GIVE_TIME#-3
   MESSAGE0:         You must specify a time
   MESSAGE1:         LARK needs to be told how long to wait
   DESCRIPTION:      Time to wait must be given
*/
 
/*
   Structures
*/
 
 
%FPT_WAIT
       ( FPTN                  = FPT_PAUSECMD_WAIT,
         UETIME                = TIME_LEFT ) ;
 
 
%LARK_GLOBALS ;
 
%LARK_PARSEBLKS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
 
/*
   Local data
*/
 
DCL TIME_TO_WAIT  UBIN STATIC ;
DCL BLK$          PTR ;
DCL TIME_LEFT     UBIN STATIC ;
DCL BREAK_HIT#    BIT ( 1 ) STATIC SYMDEF ;
 
 
                                                /* BREAK_HIT# is set to true */
                                                /* by LARK_BREAK_HANDLER     */
                                                /* when/if the break key is  */
                                                /* hit                       */
BREAK_HIT# = %FALSE ;
 
IF ( P_OUT$BLK.CODE ~= %PAUSE_CMD ) OR
   ( P_OUT$BLK.NSUBLKS ~= 1 )  THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
IF ( BLK$ -> OUT$SYM.CODE ~= %PAUSE_TIME ) THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NEED_TO_GIVE_TIME#, 3 ) ;
   GOTO ALT ;
END ;
 
CALL CHARBIN ( TIME_TO_WAIT, BLK$ -> OUT$SYM.TEXT ) ;
 
FPT_PAUSECMD_WAIT.V.UNITS# = TIME_TO_WAIT;
 
DO UNTIL ( TIME_LEFT = 0 ) OR BREAK_HIT# ;
    CALL M$WAIT ( FPT_PAUSECMD_WAIT )   WHENALTRETURN DO ;
                                        CALL LARK_INTERNAL_ERROR ;
                                        GOTO ALT ;
                                        END ;
 
      IF (TIME_LEFT ~= 0) THEN DO ;
         TIME_TO_WAIT = TIME_LEFT ;
         FPT_PAUSECMD_WAIT.V.UNITS# = TIME_TO_WAIT ;
         END ;
END ;
 
RETURN ;
 
ALT: ;
   ALTRETURN ;
 
END LARK_PAUSE_CMD ;
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT ;
 
/*F*
   NAME:          LARK_STOPFPRG_CMD
   PURPOSE:       Process the STOPFPRG command
   DESCRIPTION:   This module receives the parse tree for a STOPFPRG command
                  and processes it into data structures used with the
                  M$DEACTIVATE, and M$CLOSE monitor services
*/
/*D*
   NAME:          LARK_STOPFPRG_CMD
   CALL:          CALL LARK_STOPFPRG_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
   INPUT:         PARSE$OUT
   OUTPUT:        LARK$GETCMD_ (information in structure is important for "?")
   DESCRIPTION:   STOPFPRG_CMD syntax =
                     ( 'STOPF/PRG' | 'STF/PRG' ) ;
                     STOPFPRG_OPTION_LIST
*/
 
%EJECT ;
 
LARK_STOPFPRG_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
%INCLUDE B_ERRORS_C ;
 
%LARK_GLOBALS ;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_FIND_SLOT ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
/*E*
   ERROR:          LAR-E$LARK_NO_SUCH_FPRG#-3
   MESSAGE0:       That FPRG station does not exist
   MESSAGE1:       I can't find an FPRG station of that name
   DESCRIPTION:    User specified an FPRG station that does not exist
*/
 
/*E*
   ERROR:          LAR-E$LARK_DISCON_IGNORED#-1
   MESSAGE0:       The DISCONNECT option will be igonored
   MESSAGE1:       DISCONNECT = NO is meaningful only when DEVPRES = YES
   DESCRIPTION:    The DISCONNECT only does something when DEVPRES = YES
*/
 
 
/*
   Structures
*/
 
%LARK_PARSEBLKS ;
%LARK_FPRGLIST ;
 
%B$ALT ;
%B$TCB ;
%F$DCB ;
%EJECT ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPT_STOPFPRG_DEACT,
         STCLASS              = CONSTANT,
         DCB                  = M$CTRLCG ) ;
 
 
%FPT_ACTIVATE
       ( FPTN                 = FPTSTOPFPRG_DEACT,
         STCLASS              = AUTO ) ;
 
%VLP_STATION
       ( FPTN                 = VLP_STOPFPRG_STA,
         STCLASS              = CONSTANT ) ;
 
%VLP_STATION
       ( FPTN                 = VLPSTOPFPRG_STA,
         STCLASS              = AUTO ) ;
 
%FPT_CLOSE ( FPTN             = FPT_STOPFPRG_CLOSE,
             STCLASS          = CONSTANT ) ;
 
%FPT_CLOSE ( FPTN             = FPTSTOPFPRG_CLOSE,
             STCLASS          = AUTO ) ;
 
 
DCL YES_NO                    BIT ( 1 ) ;
DCL DISCON#                   BIT ( 1 ) ;
DCL DISCON_HERE#              BIT ( 1 ) ;
DCL STA_HERE#                 BIT ( 1 ) ;
DCL BLK$                      PTR  ;
DCL SUBLK$                    PTR ;
DCL SYM$                      PTR ;
DCL STA#                      CHAR ( 8 ) ;
DCL SLOT                      SBIN ;
DCL I                         SBIN ;
 
IF ( P_OUT$BLK.CODE ~= %STOPFPRG_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR (P_OUT$BLK.NSUBLKS >  2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ; /* IF */
 
IF  ~ M$CTRLCG$ -> F$DCB.AU# THEN DO ;
    CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NEED_AU#, 3 ) ;
    GOTO ALT ;
END ;
 
DISCON#      = %FALSE ;
DISCON_HERE# = %FALSE ;
STA_HERE#    = %FALSE ;
YES_NO       = %FALSE ;
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
FPTSTOPFPRG_DEACT = FPT_STOPFPRG_DEACT ;
FPTSTOPFPRG_DEACT.V_ = VECTOR ( FPTSTOPFPRG_DEACT.V ) ;
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
   BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
END ;
 
IF ( BLK$ -> OUT$BLK.CODE ~= %STOPFPRG_OPTION_LIST ) OR
   ( BLK$ -> OUT$BLK.NSUBLKS < 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
DO I = 0 TO ( BLK$ -> OUT$BLK.NSUBLKS - 1 ) ;
   SUBLK$ = BLK$ -> OUT$BLK.SUBLK$ ( I ) ;
   IF ( SUBLK$ -> OUT$BLK.NSUBLKS > 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM$ = SUBLK$ -> OUT$BLK.SUBLK$ ( 0 ) ;
   DO SELECT ( SYM$ -> OUT$BLK.CODE ) ;
      SELECT ( %YES ) ;
         YES_NO = %YES# ;
      SELECT ( %NO ) ;
         YES_NO = %NO# ;
      SELECT (%STOP_STATION_OPT, %DISCONNECT_OPT, %STATION ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
   DO SELECT (SUBLK$ -> OUT$BLK.CODE ) ;
      SELECT ( %DISCONNECT_OPT ) ;
         DISCON#      = YES_NO ;
         DISCON_HERE# = %TRUE ;
      SELECT ( %STOP_STATION_OPT ) ;
         STA_HERE#                   = %TRUE ;
         VLPSTOPFPRG_STA             = VLP_STOPFPRG_STA ;
         VLPSTOPFPRG_STA.STATION#    = SYM$ -> OUT$SYM.TEXT ;
         FPTSTOPFPRG_DEACT.STATION_  = VECTOR ( VLPSTOPFPRG_STA ) ;
         STA# = VLPSTOPFPRG_STA.STATION# ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
       END ; /* DO SELECT */
    END ; /* DO WHILE */
 
IF ~ STA_HERE# THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_MUST_SPECIFY_STATION#, 3 ) ;
   GOTO ALT ;
END ;
 
CALL LARK_FIND_SLOT ( VLPSTOPFPRG_STA, SLOT ) WHENALTRETURN DO ;
    CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_SUCH_FPRG#, 3 ) ;
    GOTO ALT ;
END ;
 
IF ~ FPRGLIST.DEVPRES# ( SLOT ) & DISCON_HERE# THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_DISCON_IGNORED#, 1 ) ;
END ;
 
IF DISCON_HERE# THEN DO ;
   FPTSTOPFPRG_DEACT.V.DISCONNECT#  = DISCON# ;
END ;
 
CALL M$DEACTIVATE ( FPTSTOPFPRG_DEACT ) WHENALTRETURN DO ;
    CALL LARK_INTERNAL_ERROR ;
    GOTO ALT ;
    END ;
 
                                                       /* We have to close a */
                                                       /* dcb for both types */
                                                       /* of FPRG load       */
 
FPTSTOPFPRG_CLOSE          = FPT_STOPFPRG_CLOSE ;
FPTSTOPFPRG_CLOSE.V_       = VECTOR ( FPTSTOPFPRG_CLOSE.V ) ;
FPTSTOPFPRG_CLOSE.V.DCB#   = FPRGLIST.DCB# ( SLOT ) ;
 
CALL M$CLOSE ( FPTSTOPFPRG_CLOSE ) WHENALTRETURN DO ;
     CALL LARK_INTERNAL_ERROR ;
     GOTO ALT ;
     END ;
 
FPRGLIST.IN_USE# ( SLOT ) = %FALSE ;
FPRGLIST.ACTIVE# ( SLOT ) = %FALSE ;
FPRGLIST_CT               = FPRGLIST_CT - 1 ;
 
RETURN ;
 
ALT: ;
   ALTRETURN ;
 
END LARK_STOPFPRG_CMD ;
