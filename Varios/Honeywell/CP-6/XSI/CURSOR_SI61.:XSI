/*M* CURSOR - Routines to perform CRT cursor positioning (verion C00) */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMR */
/* This is a collection of utility routines designed to aid
   in the writing of programs that want to use the cursor positioning
   abilities of CRT's.  They are designed to be as device-independent
   as possible.  The were designed with the intention of being called
   from FORTRAN, but should work for other languages as well.  the
   routines and their functions are as follows:
INITCRT            This routine initializes the information
                  other routines make use of.  It determines the profile
                  the user has set, reads that profiles record, and
                  extracts the information nessecary.  For this
                  routine to perform properly, the use MUST have set
                  his profile correctly for the kind of CRT he is
                  using.  It is not nessesary to call this routine
                  explicity, as it will be called the first time
                  CURSOR or CRT are called.  If it is called by the user
                  it will return the width and height of the CRT.  Height
                  will be 0 for non-CRT terminals.
 
CURSOR            This routines moves the cursor to an absolute x,y
                  coordinate on the screen, with (0,0) being the upper
                  left corner of the screen.  If COPTON has been called,
                  it will buffer up chunks of information to write
                  to the terminal, and also keep track of the cursor
                  position.  This will cut down on the number of PMME's
                  done and substantialy speed up the program using CURSOR.
 
CRT               Also HAZEL, for compatability with older routines.
                  This routine performs various functions, according
                  to the number passed to it.  The numbers and their
                  corrisponding functions are:
                      1)  Home the cursor.
                      2)  Clear the screen.
                      5)  Erase to end of line.
                      On terminals that dont have and erase end of line
                          function, it is simulated by blanking out the
                          line.
                      There are a variety of commands that work ONLY for
                      the Bull VIP7800 series terminals:
                      10)  Set form mode
                      11)  Blinking
                      12)  Hide
                      13)  Inverse video
                      14)  Low intensity
                      15)  Underline
                      16)  Alpha only
                      17)  Digits only
                      18)  Entry required
                      19)  Fill required
                      20)  Jusify right
                      21)  Modify transmit unprotected
                      22)  Numerics only
                      23)  Transmit always protected
                      24)  Unprotected
                      25)  Protected
                      26)  Restore
                      27)  Character mode
                      28)  Echoplex
                      29)  Roll mode set
                      30)  Text mode
                      31)  Data space home
                      32)  Keybored lock
                      33)  Keyboard unlock
                      34)  Tab set
                  Can you guess what kind of terminal I have?
 
CRTFLUSH          This routines causes any buffered data to be
                  printed, and resets the saved cursor location to
                  unknown.  This is used when cursor optimization
                  is on.  It MUST be called before you do any I/O
                  to the terminal not using these routines, or do somthing
                  that will take a long amount of real time.
 
CRTFLSHX          This routine is just like CRTFLUSH, except that it
                  assumes that the cursor will not be moved by the user.
                  This routine allows more efficient use, but remember,
                  it is up to you to make sure the cursor is only moved
                  by calling these routines.
 
COPTON            These routines turn the cursor optimization on
COPTOFF           or off.  The optimization is heighly recomended.
 
WRITE             You pass this routine a text string and its length.
                  It is advisable to use this for all writes to
                  the terminal to prevent undisirable interaction
                  with the systems cursor postioning.
 
KEYIN             This one does a read from the terminal.  You pass it
                  the location to read into, and the size to read.  Note
                  that unlike FORTRAN I/O, when the user types
                  enough to complete the read, KEYIN will return to
                  the program, not waiting for a carriage return.  Example:
                  If you call KEYIN(I,1), the routine will return as soon
                  as the users types any character.
 
RBIN              Reads a single character in transparent mode.  The character
                  is not echoed to the users screen.
 
SCREECH           Flushes the buffer and then does an M$EXIT.
 
WAIT              Waits for the required number of seconds.
 
PROMPT            Sets the prompt character(s).  First char is vfc.
                  CALL PROMPT('ANYTHING')  also CALL PROMPTC('STRNG',LENGTH)
                  The PROMPT entry only work for FORTRAN programs.
 
BREAK             Returns 1 if the user hit break, 0 if not.
 
NOWAIT            Reads one character in transparent mode with a
                  ten millisecond time-out.  Returns 0 if it
                  didnt get a character.
 
ERROUT            You call this with a CP-6 error code, and it
                  writes it out, with the error message if it can
                  find it.  Very useful for displaying IOSTAT info
                  from OPEN statments, etc.  If you call it with a
                  zero argument, it will display the most recent error
                  in the ALT frame.
 
   The routines COPTOFF, WRITE, KEYIN, RBIN, SCREECH, WAIT, NOWAIT all
automaticaly call CRTFLUSH.  This insures that I/O will occurr in the
order the user output it in.  Note that if you are doing I/O to the CRT
other than through these routines, and cursor optimization is on, it is
your responsibility to call CRTFLUSH before you do that I/O.
Also, don't forget to call CRTFLUSH at the end of your program if you
don't call SCREECH, as otherwise some of your output will mysteriously
dissapear.
     These routines are designed to work with a wide range of CRT's.  The
ones that it will not handle are:
      1) Terminals that are not fully and correctly described by
          their profile records.
      2) Terminals that use a bizare type of direct cursor positioning
          that is not compatable with normal table driven cursor positioning,
          and do not support ANS x3.64 standard cursor positioning.
  Note that the terminal must have either direct cursor positioning
(CUP_ALG=ANS or CUP_ALG=TBL (2) with CUP_CHR etc described) or it must have
the full set of cursor movement commands (CUU_CHR,CUB_CHR,CUF_CHR,CUD_CHR).
These routines can even handle (to a limited point) hardcopy terminals
like the diablo 1620 that have reverse line-feed capabilities.
*/
%EJECT;
INITCRT: PROC (W,H);
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE KL_SUPER_C;               /* To get KL$CCHR, KL$TALG, and KL$PHDR    */
%F$DCB;
DCL I SBIN WORD;
DCL J SBIN WORD;
DCL W SBIN WORD;
DCL H SBIN WORD;
%KL_CCHR (NAME=KL$CCHR,STCLASS="BASED(TCCHR$)");
DCL INITL_CALLED BIT(1) STATIC SYMDEF INIT('0'B);
DCL RET_W_H BIT(1);
DCL BREAK_FLAG SBIN STATIC SYMDEF;
DCL CRT_OPT_WAS_ON BIT(1) STATIC SYMDEF INIT ('0'B);
DCL TCCHR$ PTR STATIC SYMDEF INIT(ADDR(NIL));
DCL TATR$ PTR STATIC SYMDEF INIT(ADDR(NIL));
DCL TTALG$ PTR STATIC SYMDEF INIT(ADDR(NIL));
DCL 1 CRT_PRO STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(11) UNAL INIT(' ');
DCL 1 CRT_PRO_B BASED,
      2 C UBIN BYTE UNAL,
      2 T CHAR(11) UNAL;
DCL CRT_CUP_ALG UBIN WORD STATIC SYMDEF;
DCL CRT_SPEED UBIN WORD STATIC SYMDEF;
DCL CRT_HEIGHT UBIN WORD STATIC SYMDEF;
DCL CRT_WIDTH UBIN WORD STATIC SYMDEF;
DCL CRT_ETIM SBIN WORD STATIC SYMDEF;
DCL CRT_CFUNCTIM SBIN WORD STATIC SYMDEF;
DCL 1 CRT_CUP STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(8) UNAL INIT(' ');
DCL 1 CRT_HOM STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(8) UNAL INIT(' ');
DCL 1 CRT_EL0 STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(8) UNAL INIT(' ');
DCL 1 CRT_ED2 STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(8) UNAL INIT(' ');
DCL 1 CRT_CUU STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(3) UNAL INIT(' ');
DCL 1 CRT_CUD STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(3) UNAL INIT(' ');
DCL 1 CRT_CUB STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(3) UNAL INIT(' ');
DCL 1 CRT_CUF STATIC SYMDEF,
      2 C UBIN BYTE UNAL INIT(0),
      2 T CHAR(3) UNAL INIT(' ');
DCL CRT_CR BIT(1) STATIC SYMDEF;
DCL CRT_NOP CHAR(1) SYMREF;
DCL CRT_NOPU REDEF CRT_NOP UBIN BYTE CALIGNED;
DCL 1 ERSTIM STATIC,
      2 * UBIN(20) UNAL INIT(0),
      2 T UBIN(8) UNAL INIT(0),
      2 B UBIN(8) UNAL INIT(0);
DCL ETIM REDEF ERSTIM SBIN WORD;
DCL 1 CRT_BLINK STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL 1 CRT_INVIS STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL 1 CRT_INVERSE STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL 1 CRT_DIM STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL 1 CRT_UNDERLINE STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL 1 CRT_RESET STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL 1 CRT_BOLD STATIC SYMDEF,
      2 C UBIN BYTE CALIGNED INIT(0),
      2 T CHAR (10) INIT (%(BINASC(0))*0);
DCL CRT_AUTOSCROLL BIT (1) STATIC SYMDEF INIT ('0'B);
DCL P$ PTR;
DCL PP$ PTR;
DCL PEND$ PTR;
DCL TBIT BIT(1);
DCL 1 TEXTC BASED CALIGNED,
      2 L UBIN BYTE CALIGNED,
      2 C CHAR (TEXTC.L);
%KL_PHDR (NAME=KL$PHDR,STCLASS="BASED(P$) ALIGNED");
%VLP_TRMATTR (FPTN=TRMATTR,STCLASS="BASED(TATR$)",ALGN=UNAL);
DCL M$PRO DCB;
DCL M$TERM DCB;
%FPT_OPEN (FPTN=OPEN_TERM,DCB=M$TERM,ASN=DEVICE);
%FPT_GLINEATTR (FPTN=GLATTR,DCB=M$UC,LINEATTR=LATTR);
%VLP_LINEATTR (FPTN=LATTR,STCLASS=STATIC);
%FPT_TRMCTL   (FPTN=GET_TERM_CONTROL, STCLASS=CONSTANT,
               TRMCTL=USERS_TRMCTL);
%FPT_TRMCTL   (FPTN=SET_NOOPT, STCLASS=CONSTANT,
               TRMCTL=SET_NOOPT_TRMCTL);
%VLP_TRMCTL   (FPTN=USERS_TRMCTL, STCLASS=STATIC);
%VLP_TRMCTL   (FPTN=SET_NOOPT_TRMCTL, STCLASS=CONSTANT, NOOPTMIZ=YES);
%FPT_OPEN (FPTN=OPEN_PRO,DCB=M$PRO,ACCT=SYS,ASN=FILE,
      NAME=PRO,SHARE=ALL,FUN=IN);
%VLP_ACCT (FPTN=SYS,ACCT=':SYS');
%VLP_NAME (FPTN=PRO,NAME=':PRO');
%FPT_CLOSE (FPTN=CLOSE_PRO,DISP=SAVE,DCB=M$PRO);
%FPT_READ (FPTN=READ_PRO,DCB=M$PRO,BUF=PRO_BUF,KEYS=YES,
      KEY=LATTR.PROFILE#);
%FPT_INT (UENTRY=BROKE);
%FPT_XCON  (UENTRY=CURSOR_XCON);
DCL BROKE ENTRY ASYNC;
DCL CURSOR_XCON ENTRY ASYNC ALTRET;
DCL PRO_BUF CHAR(1000) STATIC;
DCL 1 PP$STRCT BASED(PP$) CALIGNED,
      2 TYPE UBIN BYTE CALIGNED,
      2 SIZE UBIN BYTE CALIGNED;
DCL PP_TYPE UBIN BYTE;
DCL PP_SIZE UBIN BYTE;
DCL LINESPEEDS(0:15) UBIN HALF UNAL CONSTANT
      INIT(50,75,110,134,150,200,300,600,1050,1200,
           1800,2000,2400,4800,9600,19200);
        RET_W_H = '1'B;
        GOTO COMMON;
INITL:  ENTRY; /* INITL is like INITCRT, but doesnt return width + height     */
        RET_W_H = '0'B;
COMMON:
        CALL M$INT (FPT_INT);           /* Set up break control               */
        CALL M$XCON (FPT_XCON);
        BREAK_FLAG = 0;
        CALL M$GLINEATTR (GLATTR);
        CALL M$GTRMCTL (GET_TERM_CONTROL);
        IF USERS_TRMCTL.NOOPTMIZ# ~= %YES#
        THEN DO;
           CRT_OPT_WAS_ON = %YES#;
           CALL M$STRMCTL (SET_NOOPT);
           END;
        CRT_SPEED = LINESPEEDS(LATTR.LINESPEED#);
        CALL M$OPEN(OPEN_PRO);
        CALL M$READ(READ_PRO);
        P$=ADDR(PRO_BUF);
        PEND$=PINCRC(P$,DCBADDR(DCBNUM(M$PRO))->F$DCB.ARS#);
        CALL M$CLOSE(CLOSE_PRO);
        CALL M$OPEN(OPEN_TERM);
        PP$=PINCRW(P$,SIZEW(KL$PHDR));
        DO WHILE( POFFC(PEND$,PP$) > 0);
           PP_TYPE=PP$STRCT.TYPE;
           PP_SIZE=PP$STRCT.SIZE;
           PP$=PINCRC( PP$,2);
           DO CASE(PP_TYPE);
            CASE(3);
              CRT_PRO = PP$->CRT_PRO_B;
            CASE(7);
              TATR$ = PP$;
            CASE(15);
              TCCHR$ = PP$;
            CASE(16);
              TTALG$ = PP$;
            END;
           PP$ = PINCRC( PP$, ((PP_SIZE+1)/2)*2); /* next even byte */
           END;
        CRT_WIDTH=TRMATTR.WIDTH#;
        IF DCBADDR(DCBNUM(M$TERM))->F$DCB.WIDTH# > 0 AND
          DCBADDR(DCBNUM(M$TERM))->F$DCB.WIDTH# < CRT_WIDTH THEN
           CRT_WIDTH = DCBADDR(DCBNUM(M$TERM))->F$DCB.WIDTH#;
        CRT_HEIGHT=TRMATTR.HEIGHT#;
        CRT_AUTOSCROLL = TRMATTR.DEVSCROLL# & TRMATTR.AUTONL#;
        IF RET_W_H THEN DO;
           W = CRT_WIDTH;
           H = CRT_HEIGHT;
           END;
        TBIT = TRMATTR.DEVICEBS#;
        IF TBIT THEN DO;
           CRT_CUB.C = 1;
           CRT_CUB.T = BITASC('010'O);
           END;
        ELSE CALL FETCH_TEXTC (CRT_CUB, KL$CCHR.CUB_CHR);
        TBIT = TRMATTR.DEVICELF#;
        IF TBIT THEN DO;
           CRT_CUD.C = 1;
           CRT_CUD.T = BITASC('012'O);
           END;
        ELSE CALL FETCH_TEXTC (CRT_CUD, KL$CCHR.CUD_CHR);
        CRT_CUP_ALG = KL$CCHR.CUP_ALG;
        TBIT = TRMATTR.BLANKERASES#;
        IF KL$CCHR.CUF_CHR > 0 THEN
           CALL FETCH_TEXTC (CRT_CUF, KL$CCHR.CUF_CHR);
        ELSE IF ~TBIT THEN DO;
              CRT_CUF.C = 1;
              CRT_CUF.T = ' ';
              END;
        CALL FETCH_TEXTC (CRT_CUU, KL$CCHR.CUU_CHR);
        CALL FETCH_TEXTC (CRT_CUP, KL$CCHR.CUP_CHR);
        CALL FETCH_TEXTC (CRT_EL0, KL$CCHR.EL0_CHR);
        CRT_CR = TRMATTR.DEVICECR#;
        ERSTIM.T = KL$CCHR.ERSTIM / 256;
        ERSTIM.B = KL$CCHR.ERSTIM;
        CRT_ETIM = ETIM;
        ERSTIM.T = KL$CCHR.CTRFNCTIM / 512;
        ERSTIM.B = KL$CCHR.CTRFNCTIM;
        CRT_CFUNCTIM = ETIM;
        IF KL$CCHR.HOM_CHR > 0 THEN
           CALL FETCH_TEXTC (CRT_HOM, KL$CCHR.HOM_CHR);
        ELSE IF KL$CCHR.CUP_CHR > 0 THEN DO;
              CALL FETCH_TEXTC (CRT_HOM, KL$CCHR.CUP_CHR);
              CALL INSERT(CRT_HOM.T,CRT_HOM.C,2,BINASC(KL$CCHR.CUP_BIS+1),BINASC(KL$CCHR.CUP_BIS+1));
              CRT_HOM.C = CRT_HOM.C + 2;
              END;
        IF KL$CCHR.ED2_CHR > 0 THEN
           CALL FETCH_TEXTC (CRT_ED2, KL$CCHR.ED2_CHR);
        ELSE IF KL$CCHR.ED0_CHR > 0 AND CRT_HOM.C > 0 THEN DO;
              CRT_ED2.C = KL$CCHR.TXT_UBIN(KL$CCHR.ED0_CHR) + CRT_HOM.C;
              CRT_ED2.T = CRT_HOM.T;
              CALL INSERT(CRT_ED2.T,CRT_HOM.C,,
                ADDR(KL$CCHR.TXT_UBIN(KL$CCHR.ED0_CHR))->TEXTC.C);
              END;
           ELSE IF KL$CCHR.FRMFED_CHR > 0 THEN
                 CALL FETCH_TEXTC (CRT_ED2, KL$CCHR.FRMFED_CHR);
              ELSE IF CRT_PRO.T = 'DBL1620' OR CRT_PRO.T = 'DBL1610'
                   OR CRT_PRO.T = 'NEC5520' OR CRT_PRO.T = 'DBL1641'
                 THEN DO;
                    CRT_ED2.C = 1;
                    CRT_ED2.T = BITASC('014'O);
                    END;
        CRT_NOPU = KL$CCHR.TMNALG_FILCHR;
        DO CASE (KL$CCHR.SGR_ALG#);
         CASE (0);                      /* do nothing */
         CASE (1);
           CALL PACK_ANSII (CRT_RESET, '0');
           CALL PACK_ANSII (CRT_BLINK, '5');
           CALL PACK_ANSII (CRT_INVERSE, '7');
           CALL PACK_ANSII (CRT_DIM, '2');
           CALL PACK_ANSII (CRT_UNDERLINE, '4');
           CALL PACK_ANSII (CRT_BOLD, '1');
         CASE (2, 3);
           IF TRMATTR.NO_FLDTRM# = '0'B /* terminated by EOL, not EOP */
           THEN DO;
              CALL PACKUP (CRT_BLINK, KL$CCHR.SGRFSTBLN_CHR#);
              CALL PACKUP (CRT_BLINK, KL$CCHR.SGRSLWBLN_CHR#);
              CALL PACKUP (CRT_INVIS, KL$CCHR.SGRHDN_CHR#);
              CALL PACKUP (CRT_INVERSE, KL$CCHR.SGRRVRVID_CHR#);
              CALL PACKUP (CRT_DIM, KL$CCHR.SGRDCRINT_CHR#);
              CALL PACKUP (CRT_UNDERLINE, KL$CCHR.SGRUNDSCR_CHR#);
              CALL PACKUP (CRT_BOLD, KL$CCHR.SGRINCINT_CHR#);
              J = KL$CCHR.RESTORE_DFLTSCRN_CHR#;
              I = KL$CCHR.TXT_UBIN(J);
              CRT_RESET.C = I;
              DO WHILE (I > 0);
                 I = I - 1;
                 SUBSTR (CRT_RESET.T, I, 1) =
                   BINASC(KL$CCHR.TXT_UBIN(I + J + 1));
                 END;
              END;
         END;
        INITL_CALLED = '1'B;
%EJECT;
PACKUP: PROC (STRSEQ, ATTRCHAR);
DCL 1 STRSEQ ALIGNED,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL ATTRCHAR CHAR (1);
 
        IF ATTRCHAR = BINASC(0)
        THEN RETURN;
 
        STRSEQ.C = 0;
        CALL PACK (KL$CCHR.DCLFRM_CHR#);
        CALL PACK (KL$CCHR.SGRINTRO_CHR#);
        SUBSTR(STRSEQ.T,STRSEQ.C,1) = ATTRCHAR;
        STRSEQ.C = STRSEQ.C + 1;
        CALL PACK (KL$CCHR.ENDDCLFRM_CHR#);
 
        RETURN;
 
PACK_ANSII: ENTRY (STRSEQ, ATTRCHAR);
 
        STRSEQ.C = 4;
 
        CALL CONCAT (STRSEQ.T, BITASC('033'O), '[', ATTRCHAR,
          'm');
 
        RETURN;
 
PACK:   PROC (INDEX_IN);
DCL INDEX_IN UBIN BYTE CALIGNED;
 
        IF INDEX_IN = 0
        THEN
           RETURN;
        SUBSTR(STRSEQ.T, STRSEQ.C) = ADDR(KL$CCHR.TXT_UBIN(INDEX_IN))->TEXTC.C;
        STRSEQ.C = STRSEQ.C + KL$CCHR.TXT_UBIN(INDEX_IN);
 
        RETURN;
 
END PACK;
 
END PACKUP;
 
FETCH_TEXTC: PROC (TEXTC_OUT, INDEX_IN);
DCL 1 TEXTC_OUT,
      2 L UBIN BYTE CALIGNED,
      2 C CHAR (TEXTC_OUT.L);
DCL INDEX_IN UBIN BYTE CALIGNED;
        IF INDEX_IN = 0
        THEN
           TEXTC_OUT.L = 0;
        ELSE DO;
           TEXTC_OUT.L = KL$CCHR.TXT_UBIN(INDEX_IN);
           TEXTC_OUT.C = ADDR(KL$CCHR.TXT_UBIN(INDEX_IN))->TEXTC.C;
           END;
        RETURN;
END FETCH_TEXTC;
END INITCRT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CURSOR: PROC(X,Y);
%INCLUDE CP_6;
%INCLUDE KL_SUPER_C;
%F$DCB;
DCL X SBIN WORD;
DCL Y SBIN WORD;
DCL INITL_CALLED BIT(1) SYMREF;
DCL TCCHR$ PTR SYMREF;
DCL TATR$ PTR SYMREF;
DCL TTALG$ PTR SYMREF;
DCL 1 CRT_PRO SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(11) UNAL;
DCL CRT_SPEED UBIN WORD SYMREF;         /* Terminal baud rate                 */
DCL CRT_WIDTH UBIN WORD SYMREF;
DCL CRT_HEIGHT UBIN WORD SYMREF;
DCL CRT_OPTIMIZE BIT(1) STATIC SYMDEF INIT('0'B); /* '1'b if on               */
DCL CRT_CPOS_X SBIN WORD STATIC SYMDEF INIT(-1); /* Current cursor position, -1=unknown */
DCL CRT_CPOS_Y SBIN WORD STATIC SYMDEF INIT(-1);
DCL CRT_BCOUNT SBIN WORD STATIC SYMDEF INIT(0);
DCL DELTA_X SBIN WORD;
DCL CRT_CUP_ALG SBIN WORD SYMREF;
DCL CRT_ETIM SBIN WORD SYMREF;
DCL CRT_CFUNCTIM SBIN WORD SYMREF;
DCL CRT_CR BIT(1) SYMREF;
DCL 1 CRT_CUP SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(8) UNAL;
DCL 1 CRT_EL0 SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(8) UNAL;
DCL 1 CRT_HOM SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(5) UNAL;
DCL 1 CRT_ED2 SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(8) UNAL;
DCL 1 CRT_CUU SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(3) UNAL;
DCL 1 CRT_CUD SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(3) UNAL;
DCL 1 CRT_CUB SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(3) UNAL;
DCL 1 CRT_CUF SYMREF,
      2 C UBIN BYTE UNAL,
      2 T CHAR(3) UNAL;
DCL 1 CRT_BLINK SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL 1 CRT_INVIS SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL 1 CRT_INVERSE SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL 1 CRT_DIM SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL 1 CRT_UNDERLINE SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL 1 CRT_RESET SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL 1 CRT_BOLD SYMREF,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (10);
DCL CRT$ PTR STATIC SYMDEF INIT(ADDR(CUR_BUF));
DCL CUR$ PTR;
DCL P$ PTR;
DCL XP UBIN WORD;
DCL YP UBIN WORD;
DCL TP UBIN WORD;
DCL TBIT BIT(1);
DCL NUM SBIN WORD;
DCL ALG SBIN WORD;
DCL TEMP SBIN WORD;
DCL 1 ERSTIM STATIC,
      2 * UBIN(20) UNAL INIT(0),
      2 T UBIN(8) UNAL INIT(0),
      2 B UBIN(8) UNAL INIT(0);
DCL ETIM REDEF ERSTIM SBIN WORD;
DCL INITL ENTRY;
%KL_CCHR (NAME=KL$CCHR,STCLASS="BASED(TCCHR$)");
%VLP_TRMATTR (FPTN=TRMATTR,STCLASS="BASED(TATR$)",ALGN=UNAL);
%EQU ESCAPE = BINASC(27);
DCL CUR_BUF CHAR(644) STATIC DALIGNED;
DCL CURMOVE_BUF CHAR (4096) DALIGNED;
DCL CURMOVE_CNT SBIN WORD;
DCL CURMOVE_CHUNKSIZE UBIN;
DCL CHR CHAR(1) BASED UNAL;
DCL CHR3 CHAR(3) BASED UNAL;
DCL CHR5 CHAR(5) BASED UNAL;
DCL CHR8 CHAR(8) BASED UNAL;
DCL CHR10 CHAR (10) BASED UNAL;
DCL 1 BCHR8 BASED CALIGNED,
      2 * CHAR(8);
DCL CHR400 CHAR(400) BASED UNAL;
DCL CURMOVE_CHUNK CHAR (CURMOVE_CHUNKSIZE) BASED;
DCL CURMOVE_OFFSET UBIN;
DCL CRT_NOP CHAR(1) STATIC SYMDEF INIT(BITASC('377'O));
DCL BLANKS CHAR(132) CONSTANT INIT(' ');
DCL 1 ANS_POS STATIC,
      2 * CHAR(1) INIT(BITASC('033'O)),
      2 * CHAR(1) INIT('['),
      2 YP CHAR(2) INIT('00'),
      2 * CHAR(1) INIT(';'),
      2 XP CHAR(2) INIT('00'),
      2 * CHAR(1) INIT('H');
%FPT_WRITE (FPTN=WR_CUR,BUF=CUR_BUF,DCB=M$TERM,TRANS=YES,BP=YES);
%FPT_WRITE (FPTN=D_BLANK,BUF=BLANKS,DCB=M$TERM,TRANS=YES);
%M$DCB (ASN=DEVICE,FUN=UPDATE,RES='UC',ORG=TERMINAL,DCBN=M$TERM);
DCL 1 VIP(0:24) CONSTANT,
      2 L SBIN WORD INIT(3*17,2*3,3*0),
      2 CHRB BIT(27) UNAL INIT(
        '033133150'O,
        '033163102'O,
        '033163110'O,
        '033163111'O,
        '033163114'O,
        '033163137'O,
        '033163101'O,
        '033163104'O,
        '033163105'O,
        '033163106'O,
        '033163112'O,
        '033163115'O,
        '033163116'O,
        '033163124'O,
        '033163125'O,
        '033163120'O,
        '033163122'O,
        '033153377'O,
        '033155377'O,
        '033162377'O,
        '033133154'O,                   /* TEXT MODE */
        '033133110'O,                   /* DATA SPACE HOME */
        '033133130'O,                   /* KEYBORD LOCK */
        '033133127'O,                   /* KEYBORD UNLOCK */
        '033160177'O),                  /* TAB SET */
      2 CHR REDEF CHRB CHAR(3) UNAL;
DCL VIP2 BIT(45) CONSTANT INIT(
               '033133145033161'O);/* SPACE SUPPRESS SET, ROLL MODE RESET */
DCL VIP2_CHR REDEF VIP2 CHAR(5);
DCL VIP72_LOW_B BIT(18) CONSTANT INIT('033064'O);
DCL VIP72_LOW REDEF VIP72_LOW_B CHAR(2);
DCL VIP72_HIGH_B BIT(18) CONSTANT INIT('033063'O);
DCL VIP72_HIGH REDEF VIP72_HIGH_B CHAR(2);
        IF NOT INITL_CALLED THEN CALL INITL;
        XP=X+1;
        YP=Y+1;
        IF X>CRT_WIDTH THEN XP=CRT_WIDTH;
        IF X<1 THEN XP=1;
        IF Y>CRT_HEIGHT AND CRT_HEIGHT>0 THEN YP=CRT_HEIGHT;
        IF Y<1 THEN YP=1;
        IF CRT_OPTIMIZE AND CRT_CPOS_X = XP AND
          CRT_CPOS_Y = YP THEN RETURN;
        DELTA_X = CRT_CPOS_X - XP;
        IF DELTA_X < 0 THEN DELTA_X = - DELTA_X;
        CALL CURMOVE;
        IF CURMOVE_CNT = 0 THEN RETURN;
        IF (CRT_CUP_ALG<2 OR CRT_CUP.C=0 OR
          CRT_CUP.C+2>CURMOVE_CNT) AND CURMOVE_CNT>=0 THEN DO;
           CURMOVE_OFFSET = 0;
           DO UNTIL (CURMOVE_CNT = 0);
              CURMOVE_CHUNKSIZE = MINIMUM (CURMOVE_CNT, 510 - CRT_BCOUNT);
              CRT$ -> CURMOVE_CHUNK = SUBSTR (CURMOVE_BUF, CURMOVE_OFFSET,
                CURMOVE_CHUNKSIZE);
              CRT$ = PINCRC (CRT$, CURMOVE_CHUNKSIZE);
              CURMOVE_CNT = CURMOVE_CNT - CURMOVE_CHUNKSIZE;
              CURMOVE_OFFSET = CURMOVE_OFFSET + CURMOVE_CHUNKSIZE;
              CRT_BCOUNT = CRT_BCOUNT + CURMOVE_CHUNKSIZE;
              IF CRT_BCOUNT > 500
              THEN
                 CALL FLUSHC;
              END;
           CRT_CPOS_X = XP;
           CRT_CPOS_Y = YP;
           CALL INSERT(CRT$->CHR400,,CURMOVE_CNT,SUBSTR(CURMOVE_BUF,0,CURMOVE_CNT));
           CRT$ = PINCRC(CRT$,CURMOVE_CNT);
           CRT_BCOUNT = CRT_BCOUNT + CURMOVE_CNT;
           END;
        ELSE DO;
CURSOR_P:
           IF CRT_CUP.C = 0 OR KL$CCHR.CUP_ALG = 0 THEN RETURN;
           CRT_CPOS_X = XP;
           CRT_CPOS_Y = YP;
           IF KL$CCHR.CUP_CMP THEN DO;
              XP=CRT_WIDTH-XP;
              YP=CRT_HEIGHT-YP;
              END;
           XP=XP+KL$CCHR.CUP_BIS;
           YP=YP+KL$CCHR.CUP_BIS;
           TBIT=KL$CCHR.CUP_CLMFRS;
           IF NOT TBIT THEN DO;
              TP=YP;
              YP=XP;
              XP=TP;
              END;
           CRT$->CHR3 = CRT_CUP.T;
           CRT$=PINCRC(CRT$,CRT_CUP.C);
           CRT$->CHR = BINASC(XP);
           CRT$=PINCRC(CRT$,1);
           CRT$->CHR = BINASC(YP);
           CRT$ = PINCRC(CRT$,1);
           CRT_BCOUNT = CRT_BCOUNT + CRT_CUP.C + 2;
           END;
        IF KL$CCHR.TMNALG_AFTCUP > 0 THEN DO;
           ALG = KL$CCHR.TMNALG_AFTCUP;
           CALL DELAY_TIME(ALG,'1'B);
           END;
        IF NOT CRT_OPTIMIZE OR CRT_BCOUNT > 500 THEN
           CALL FLUSHC;
        RETURN;
%EJECT;
HAZEL:  ENTRY(X);
CRT:    ENTRY(X);
        IF NOT INITL_CALLED THEN CALL INITL;
        DO CASE(X);
         CASE(1 /* HOME*/);
           IF CRT_HOM.C > 0 THEN DO;
              CRT$->CHR5 = CRT_HOM.T;
              CRT$ = PINCRC(CRT$,CRT_HOM.C);
              CRT_BCOUNT = CRT_BCOUNT + CRT_HOM.C;
              IF CRT_CFUNCTIM > 0 THEN
                 CALL DELAY(CRT_CFUNCTIM);
              CRT_CPOS_X = 1;
              CRT_CPOS_Y = 1;
              END;
           ELSE CALL CURSOR(0,0);
         CASE(2 /*CLEAR SCREEN*/);
           IF CRT_ED2.C > 0 THEN DO;
              CRT$->CHR8 = CRT_ED2.T;
              CRT$ = PINCRC(CRT$,CRT_ED2.C);
              CRT_BCOUNT = CRT_BCOUNT + CRT_ED2.C;
              IF CRT_ETIM > 0 THEN
                 CALL DELAY(CRT_ETIM);
              CRT_CPOS_X = 1;
              CRT_CPOS_Y = 1;
              END;
           ELSE DO;
              TEMP = CRT_HEIGHT;
              IF TEMP <= 0 THEN
                 TEMP= DCBADDR(DCBNUM(M$TERM))->F$DCB.LINES#;
              IF TEMP = 0 THEN
                 TEMP = 24;
              CALL CURSOR(0,TEMP);
              CRT_CPOS_Y = 1;
              CALL CURSOR(0,1);         /* UGGH!  Sleaze! */
              CRT_CPOS_Y = 1;
              END;
         CASE(5 /*ERASE LINE*/);
           IF CRT_EL0.C > 0 THEN DO;
              CRT$->CHR3 = CRT_EL0.T;
              CRT$ = PINCRC(CRT$,CRT_EL0.C);
              CRT_BCOUNT = CRT_BCOUNT + CRT_EL0.C;
              IF CRT_CFUNCTIM > 0 THEN
                 CALL DELAY(CRT_CFUNCTIM);
              END;
           ELSE DO;
              CALL FLUSHC;
              D_BLANK.BUF_.BOUND = CRT_WIDTH - 2;
              IF CRT_CPOS_X >= 0 THEN D_BLANK.BUF_.BOUND = CRT_WIDTH - CRT_CPOS_X -1;
              IF D_BLANK.BUF_.BOUND >0 AND D_BLANK.BUF_.BOUND < CRT_WIDTH THEN DO;
                 CALL M$WRITE(D_BLANK);
                 XP = CRT_CPOS_X;
                 IF CRT_CPOS_X > 0 THEN
                    CRT_CPOS_X = CRT_CPOS_X + D_BLANK.BUF_.BOUND;
                 IF CRT_CPOS_X > 0 AND CRT_CPOS_Y > 0 THEN DO;
                    YP = CRT_CPOS_Y;
                    GOTO CURSOR_P;
                    END;
                 END;
              END;
         CASE(10,16,17,18,19,20,21,
                22,23,24,25,27,28,29,30,31,32,33,34);
           IF SUBSTR(CRT_PRO.T,0,5) = 'VIP78' THEN DO;
              CRT$->CHR5 = VIP.CHR(X-10);
              CRT$ = PINCRC(CRT$,VIP.L(X-10));
              CRT_BCOUNT = CRT_BCOUNT + VIP.L(X-10);
              IF X=10 OR X=30 THEN DO;
                 CRT$->CHR5 = VIP2_CHR;
                 CRT$ = PINCRC(CRT$,LENGTHC(VIP2_CHR));
                 CRT_BCOUNT = CRT_BCOUNT + LENGTHC(VIP2_CHR);
                 END;
              END;
         CASE (11);
           CALL PROVISIONAL_EMIT (CRT_BLINK);
         CASE (12);
           CALL PROVISIONAL_EMIT (CRT_INVIS);
         CASE (13);
           CALL PROVISIONAL_EMIT (CRT_INVERSE);
         CASE (14);
           CALL PROVISIONAL_EMIT (CRT_DIM);
         CASE (15);
           CALL PROVISIONAL_EMIT (CRT_UNDERLINE);
         CASE (26);
           CALL PROVISIONAL_EMIT (CRT_RESET);
         CASE (35);
           CALL PROVISIONAL_EMIT (CRT_BOLD);
         END;                           /* DO CASE                            */
        IF NOT CRT_OPTIMIZE OR CRT_BCOUNT > 500 THEN
           CALL FLUSHC;
        RETURN;
%EJECT;
/* FLUSHC is an internal routine to write out all buffered-up info */
FLUSHC: PROC;
        IF CRT_BCOUNT > 0 THEN DO;
           WR_CUR.BUF_.BOUND = CRT_BCOUNT - 1;
           CALL M$WRITE (WR_CUR);
           END;
        CRT_BCOUNT = 0;
        CRT$ = ADDR(CUR_BUF);
        IF NOT CRT_OPTIMIZE AND
          (CRT_HOM.C>0 OR CRT_CUP.C > 0) THEN
           CRT_CPOS_Y = -1;
        IF NOT CRT_OPTIMIZE THEN CRT_CPOS_X = -1;
END FLUSHC;
%EJECT;
/* CURMOVE is an internal proc to do realtive cursor positioning */
CURMOVE: PROC;
DCL CRT_MOVE_CHAR CHAR (1);
DCL NX SBIN WORD;
DCL NY SBIN WORD;
DCL T1 SBIN WORD;
DCL T2X SBIN WORD;
DCL T2Y SBIN WORD;
DCL USE_CR BIT(1);
        CURMOVE_CNT = -1;
        CUR$ = ADDR(CURMOVE_BUF);
        IF CRT_CUP_ALG = 1
        THEN ANS_POSITIONING: DO;       /* do effective ANS 3.64 positioning */
           IF CRT_CPOS_X = -1 OR CRT_CPOS_X ~= XP
             OR CRT_CPOS_Y = -1 OR CRT_CPOS_Y ~= YP
           THEN DO;      /* position unknown or distant; position directly */
              SUBSTR(CURMOVE_BUF, 0, 2) = %CONCAT(ESCAPE, '[');
              CURMOVE_CNT = 2;
              CALL STUFF_CURSOR_INTEGER (YP);
              SUBSTR(CURMOVE_BUF, CURMOVE_CNT, 1) = ';';
              CURMOVE_CNT = CURMOVE_CNT + 1;
              CALL STUFF_CURSOR_INTEGER (XP);
              SUBSTR(CURMOVE_BUF, CURMOVE_CNT, 1) = 'H';
              CURMOVE_CNT = CURMOVE_CNT + 1;
              RETURN;
              END;
           IF CRT_CPOS_X = X
           THEN
              IF CRT_CPOS_Y > YP
              THEN DO;
                 CRT_MOVE_CHAR = 'A';   /* cursor up */
                 T1 = CRT_CPOS_Y - YP;
                 END;
              ELSE DO;
                 CRT_MOVE_CHAR = 'B';   /* cursor down */
                 T1 = YP - CRT_CPOS_Y;
                 END;
           ELSE
              IF CRT_CPOS_X > XP
              THEN DO;
                 CRT_MOVE_CHAR = 'D';   /* cursor back */
                 T1 = CRT_CPOS_X - XP;
                 END;
              ELSE DO;
                 CRT_MOVE_CHAR = 'C';   /* cursor right */
                 T1 = XP - CRT_CPOS_X;
                 END;
           IF T1 = 1
           THEN DO;
              CALL INSERT (CURMOVE_BUF, 0, 3, %CONCAT(ESCAPE,'['),
                CRT_MOVE_CHAR);
              CURMOVE_CNT = 3;
              END;
           ELSE DO;
              SUBSTR(CURMOVE_BUF, 0, 2) = %CONCAT(ESCAPE,'[');
              CURMOVE_CNT = 2;
              CALL STUFF_CURSOR_INTEGER (T1);
              SUBSTR(CURMOVE_BUF, CURMOVE_CNT, 1) = CRT_MOVE_CHAR;
              CURMOVE_CNT = CURMOVE_CNT + 1;
              END;
           RETURN;
           END ANS_POSITIONING;
        IF CRT_CPOS_Y = -1 AND CRT_HOM.C = 0 THEN RETURN;
        IF CRT_CPOS_X = -1 AND NOT CRT_CR AND CRT_HOM.C=0 THEN RETURN;
        T1 = CRT_HOM.C + (XP-1)*CRT_CUF.C + (YP-1)*CRT_CUD.C;
        IF CRT_HOM.C = 0 OR (CRT_CUF.C = 0 AND XP>1) OR
          (CRT_CUD.C = 0 AND YP>1) THEN T1 = 9999;
        IF XP > CRT_CPOS_X THEN DO;
           T2X = (XP-CRT_CPOS_X)*CRT_CUF.C;
           IF CRT_CPOS_X = -1 OR CRT_CUF.C = 0 THEN T2X = 999;
           END;
        ELSE DO;
           T2X = (CRT_CPOS_X - XP) *CRT_CUB.C;
           IF CRT_CUB.C = 0 THEN T2X = 999;
           END;
        IF YP > CRT_CPOS_Y THEN DO;
           T2Y = (YP - CRT_CPOS_Y) * CRT_CUD.C;
           IF CRT_CPOS_Y = -1 OR CRT_CUD.C = 0 THEN T2Y = 999;
           END;
        ELSE DO;
           T2Y = (CRT_CPOS_Y - YP) * CRT_CUU.C;
           IF CRT_CUU.C = 0 THEN T2Y = 999;
           END;
        IF CRT_CR AND (1+(XP-1)*CRT_CUF.C)<T2X AND CRT_CUF.C > 0
        THEN DO;
           T2X = (1+(XP-1)*CRT_CUF.C);
           USE_CR = '1'B;
           END;
        ELSE USE_CR = '0'B;
        IF T1>500 AND T2X>500 AND T2Y>500 THEN RETURN;
        IF T1<=(T2X+T2Y) THEN DO;
           CUR$->CHR5 = CRT_HOM.T;
           CUR$= PINCRC(CUR$,CRT_HOM.C);
           NX = (XP-1);
           CURMOVE_CNT = CRT_HOM.C + (XP-1)*CRT_CUF.C + (YP-1)*CRT_CUD.C;
           IF CRT_CFUNCTIM > 0 THEN
              CALL DELAY2(CRT_CFUNCTIM);
           DO WHILE(NX>0);
              CUR$->CHR3 = CRT_CUF.T;
              CUR$ = PINCRC(CUR$,CRT_CUF.C);
              NX = NX -1;
              END;
           NY = (YP-1);
           DO WHILE(NY > 0);
              CUR$->CHR3 = CRT_CUD.T;
              CUR$ = PINCRC(CUR$,CRT_CUD.C);
              ALG= KL$CCHR.TMNALG_AFTLF;
              IF ALG > 0 THEN
                 CALL DELAY_TIME(ALG,'0'B);
              NY = NY - 1;
              END;
           RETURN;
           END;
        IF CRT_CUP.C >0 AND (T2X>99 OR T2Y>99) THEN RETURN;
        IF USE_CR THEN DO;
           CUR$->CHR = BITASC('015'O);
           CUR$ = PINCRC(CUR$,1);
           NX = XP -1;
           CURMOVE_CNT = NX*CRT_CUF.C + 1;
           ALG = KL$CCHR.TMNALG_AFTCR;
           IF ALG > 0 THEN CALL DELAY_TIME(ALG,'0'B);
           DO WHILE(NX>0);
              CUR$->CHR3 = CRT_CUF.T;
              CUR$ = PINCRC(CUR$,CRT_CUF.C);
              NX = NX -1;
              END;
           END;
        ELSE DO;
           IF XP>CRT_CPOS_X THEN DO;
              NX = XP-CRT_CPOS_X;
              CURMOVE_CNT = NX*CRT_CUF.C;
              DO WHILE(NX>0);
                 CUR$->CHR3 = CRT_CUF.T;
                 CUR$ = PINCRC(CUR$,CRT_CUF.C);
                 NX = NX - 1;
                 END;
              END;
           ELSE DO;
              NX = CRT_CPOS_X - XP;
              CURMOVE_CNT = NX * CRT_CUB.C;
              DO WHILE(NX>0);
                 CUR$->CHR3 = CRT_CUB.T;
                 CUR$ = PINCRC(CUR$,CRT_CUB.C);
                 ERSTIM.T = KL$CCHR.BS_TIM / 512;
                 ERSTIM.B = KL$CCHR.BS_TIM;
                 IF ETIM > 0 THEN
                    CALL DELAY2(ETIM);
                 NX = NX -1;
                 END;
              END;
           END;
        IF YP>CRT_CPOS_Y THEN DO;
           NY = YP-CRT_CPOS_Y;
           CURMOVE_CNT = CURMOVE_CNT + NY*CRT_CUD.C;
           DO WHILE(NY>0);
              CUR$->CHR3 = CRT_CUD.T;
              CUR$ = PINCRC(CUR$,CRT_CUD.C);
              ALG = KL$CCHR.TMNALG_AFTLF;
              IF ALG > 0 THEN CALL DELAY_TIME(ALG,'0'B);
              NY = NY - 1;
              END;
           END;
        ELSE DO;
           NY = CRT_CPOS_Y - YP;
           CURMOVE_CNT = CURMOVE_CNT + NY*CRT_CUU.C;
           DO WHILE(NY>0);
              CUR$->CHR3 = CRT_CUU.T;
              CUR$ = PINCRC(CUR$,CRT_CUU.C);
              IF CRT_CFUNCTIM > 0 THEN
                 CALL DELAY2(CRT_CFUNCTIM);
              ELSE IF KL$CCHR.TMNALG_AFTLF > 0 THEN DO;
                    ALG = KL$CCHR.TMNALG_AFTLF;
                    CALL DELAY_TIME(ALG,'0'B);
                    END;
              NY  = NY -1;
              END;
           END;
        RETURN;
END CURMOVE;
%EJECT;
STUFF_CURSOR_INTEGER: PROC (N);
DCL N SBIN;
DCL T1 SBIN;
DCL T2 SBIN;
 
        T1 = 0;
        T2 = N;
        DO UNTIL (T2 = 0);
           T1 = T1 + 1;
           T2 = T2 / 10;
           END;
        CALL BINCHAR (SUBSTR(CURMOVE_BUF, CURMOVE_CNT, T1), N);
        CURMOVE_CNT = CURMOVE_CNT + T1;
        RETURN;
 
END STUFF_CURSOR_INTEGER;
%EJECT;
PROVISIONAL_EMIT: PROC (CTLSTRING);
 
DCL 1 CTLSTRING ALIGNED,
      2 C UBIN BYTE CALIGNED,
      2 T CHAR (CTLSTRING.C);
 
        IF CTLSTRING.C = 0
        THEN
           RETURN;
 
        CURMOVE_CHUNKSIZE = CTLSTRING.C;
        CRT$ -> CURMOVE_CHUNK = CTLSTRING.T;
 
        CRT$ = PINCRC(CRT$, CURMOVE_CHUNKSIZE);
        CRT_BCOUNT = CRT_BCOUNT + CURMOVE_CHUNKSIZE;
 
        IF CRT_BCOUNT > 500
        THEN
           CALL FLUSHC;
 
        RETURN;
 
END PROVISIONAL_EMIT;
%EJECT;
DELAY_TIME: PROC(ALG,WHO);
DCL ALG SBIN WORD;
DCL WHO BIT(1) ALIGNED;
DCL TIME SBIN WORD;
        IF ALG = 1 THEN DO;
           ERSTIM.T = KL$CCHR.TMNALG_PRM1 / 512;
           ERSTIM.B = KL$CCHR.TMNALG_PRM1;
           IF CRT_CPOS_X < 0 THEN
              TIME = ETIM * CRT_WIDTH;
           ELSE
              TIME = ETIM * DELTA_X;
           ERSTIM.T = KL$CCHR.TMNALG_PRM2 / 512;
           ERSTIM.B = KL$CCHR.TMNALG_PRM2;
           TIME = TIME + ETIM;
           END;
        ELSE IF ALG = 2 THEN DO;
              ERSTIM.T = KL$CCHR.TMNALG_PRM6 / 512;
              ERSTIM.B = KL$CCHR.TMNALG_PRM6;
              TIME = ETIM;
              ERSTIM.T = KL$CCHR.TMNALG_PRM7 / 512;
              ERSTIM.B = KL$CCHR.TMNALG_PRM7;
              TIME = TIME + ETIM;
              END;
           ELSE RETURN;
        IF WHO THEN
           CALL DELAY(TIME);
        ELSE
           CALL DELAY2(TIME);
END DELAY_TIME;
DELAY:  PROC(TIME);
DCL TIME SBIN WORD;           /* TENTH OF MILLSECONDS TO DELAY (100 MICSECS)  */
DCL NUM SBIN WORD;
        NUM = (CRT_SPEED*TIME+99999)/100000;
        DO WHILE(NUM>0);
           IF CRT_BCOUNT+NUM > 510 THEN
              CALL FLUSHC;
           CRT$->CHR = CRT_NOP;
           CRT_BCOUNT = CRT_BCOUNT + 1;
           CRT$ = PINCRC(CRT$,1);
           NUM = NUM - 1;
           END;
        RETURN;
END DELAY;
DELAY2: PROC(TIME);
DCL TIME SBIN WORD;
DCL NUM SBIN WORD;
        NUM = (CRT_SPEED*TIME+99999)/100000;
        DO WHILE(NUM>0);
           CUR$->CHR = CRT_NOP;
           CURMOVE_CNT = CURMOVE_CNT + 1;
           CUR$ = PINCRC(CUR$,1);
           NUM = NUM - 1;
           END;
        RETURN;
END DELAY2;
/**/
CRTFLUSH: ENTRY;
        IF NOT INITL_CALLED THEN CALL INITL;
        CALL FLUSHC;
        CRT_CPOS_X = -1;
        IF CRT_HOM.C > 0 OR CRT_CUP.C >0 THEN
           CRT_CPOS_Y = -1;
        RETURN;
/**/
CRTFLSHX: ENTRY;
        IF NOT INITL_CALLED THEN CALL INITL;
        CALL FLUSHC;
END CURSOR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
COPTON: PROC NOAUTO;
DCL CRT_OPTIMIZE BIT(1) SYMREF;
DCL CRTFLUSH ENTRY;
        CRT_OPTIMIZE = '1'B;
        RETURN;
COPTOFF: ENTRY;
        CRT_OPTIMIZE = '0'B;
        CALL CRTFLUSH;
        RETURN;
END COPTON;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
WRITE:  PROC (TXT,CNT) NOAUTO;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%F$DCB;
DCL M$TERM DCB;
DCL INITL_CALLED BIT(1) SYMREF;
DCL INITL ENTRY;
DCL CRT_OPTIMIZE BIT(1) SYMREF;
DCL CRT$ PTR SYMREF;
DCL CRT_AUTOSCROLL BIT (1) SYMREF;
DCL CRT_CPOS_X SBIN WORD SYMREF;
DCL CRT_CPOS_Y SBIN WORD SYMREF;
DCL CRT_HEIGHT SBIN WORD SYMREF;
DCL CRT_WIDTH SBIN WORD SYMREF;
DCL CRTFLSHX ENTRY;
%FPT_WRITE (FPTN=WRITE_CR,DCB=M$TERM,VFC=YES,BUF=CRVFC,STCLASS=CONSTANT);
DCL CRVFC CHAR(0) CONSTANT INIT(%CONCAT('`',BITASC('015'O)));
%FPT_READ (FPTN=READ_TXT,DCB=M$TERM);
%FPT_READ (FPTN=READ_RBIN,DCB=M$TERM,TRANS=YES);
DCL I SBIN WORD;
DCL TESTC CHAR(1);
DCL T$ PTR;
DCL CHR4 CHAR(4) BASED UNAL;
DCL CHR132 CHAR(132) BASED UNAL;
DCL CRT_BCOUNT SBIN WORD SYMREF;
DCL MASK BIT(9) UNAL CONSTANT INIT('177'O);
DCL TXT CHAR (REALCOUNT);
DCL REALCOUNT UBIN;
DCL CNT SBIN WORD;
DCL COUNT SBIN WORD;
        IF CNT<= 0 THEN RETURN;
        IF NOT INITL_CALLED THEN CALL INITL;
        IF CRT_BCOUNT+CNT > 510 THEN
           CALL CRTFLSHX;
        COUNT = CNT;
        IF COUNT > CRT_WIDTH THEN COUNT = CRT_WIDTH;
        IF CRT_CPOS_X > 0 AND COUNT > CRT_WIDTH - CRT_CPOS_X THEN
           IF CRT_AUTOSCROLL AND CRT_CPOS_Y = CRT_HEIGHT - 1
           THEN
              COUNT = CRT_WIDTH - CRT_CPOS_X;
           ELSE
              COUNT = CRT_WIDTH - (CRT_CPOS_X-1);
        REALCOUNT = COUNT;
        SUBSTR(CRT$ -> CHR132, 0, COUNT) = TXT;
        CRT$ = PINCRC(CRT$,COUNT);
        CRT_BCOUNT = CRT_BCOUNT + COUNT;
        IF CRT_CPOS_X >0 THEN CRT_CPOS_X = CRT_CPOS_X + COUNT;
        IF CRT_CPOS_X > CRT_WIDTH THEN
           IF CRT_AUTOSCROLL THEN
           DO;
              CRT_CPOS_X = 1;
              CRT_CPOS_Y = CRT_CPOS_Y + 1;
              END;
           ELSE CRT_CPOS_X = -1;
        IF NOT CRT_OPTIMIZE OR CRT_BCOUNT > 500 THEN
           CALL CRTFLSHX;
        RETURN;
%EJECT;
KEYIN:  ENTRY (TXT,CNT);
        CALL CRTFLSHX;
        IF CNT<=0 OR CNT>132 THEN RETURN;
        REALCOUNT = CNT;
        READ_TXT.BUF_ = VECTOR(TXT);
        TXT = ' ';
        CALL M$READ(READ_TXT);
        DO I = 0 TO DCBADDR(DCBNUM(M$TERM))->F$DCB.ARS#;
           IF SUBSTR(TXT,I,1)<' ' OR SUBSTR(TXT,I,1)>'~' THEN
              CRT_CPOS_X = -1;
           END;
        TESTC = DCBADDR(DCBNUM(M$TERM))->F$DCB.EOMCHAR#;
        IF TESTC = BITASC('012'O) OR TESTC = BITASC('015'O) THEN DO;
           CRT_CPOS_X = -1;
           IF CRT_CPOS_Y > 0 THEN CRT_CPOS_Y = CRT_CPOS_Y + 1;
           END;
        ELSE DO;
           CALL M$WRITE(WRITE_CR);      /* Get VDH in sync with us again */
           CRT_CPOS_X = -1;
           CRT_CPOS_Y = -1;
           END;
        RETURN;
%EJECT;
RBIN:   ENTRY (TXT);
        CALL CRTFLSHX;
        REALCOUNT = 1;
        TXT = ' ';
        READ_RBIN.BUF_ = VECTOR(TXT);
        CALL M$READ(READ_RBIN);
        SUBSTR(TXT, 0, 1) = BITASC (ASCBIT(SUBSTR(TXT, 0, 1)) & MASK);
        RETURN;
END WRITE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
SCREECH: PROC NOAUTO;
DCL CRTFLUSH ENTRY;
DCL CURSOR ENTRY(2);
DCL CRT_HEIGHT UBIN WORD SYMREF;
%INCLUDE CP_6;
        CALL CURSOR(0,CRT_HEIGHT-1);
        CALL CRTFLUSH;
        CALL M$EXIT;
END SCREECH;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
WAIT:   PROC(I) NOAUTO;
%INCLUDE CP_6;
DCL CRTFLSHX ENTRY;
DCL I SBIN WORD;
%FPT_WAIT (FPTN=W);
        CALL CRTFLSHX;
        W.V.UNITS# = I;
        CALL M$WAIT(W);
END WAIT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
PROMPTC: PROC (CHR,LN) NOAUTO;
%INCLUDE CP_6;
%FPT_PROMPT (FPTN=PCHAR,DCB=M$UC,PROMPT=PCH,VFC=YES);
DCL NCHARS SBIN WORD;
DCL CHR CHAR(NCHARS);
DCL LN SBIN WORD;
DCL CHRB SBIN WORD BASED;
DCL PCH CHAR(1) STATIC INIT('@');
DCL NSIZE UBIN BYTE BASED CALIGNED;
        NCHARS = LN;
        PCHAR.PROMPT_ = VECTOR(CHR);
        GOTO OK;
PROMPT: ENTRY(CHR);
        IF ADDR(CHR)->CHRB = 0 THEN DO;
           PCHAR.PROMPT_ = VECTOR(PCH);
           END;
        ELSE DO;
           NCHARS = PINCRC(ADDR(CHR),-1)-> NSIZE;
           PCHAR.PROMPT_ = VECTOR(CHR);
           END;
OK:
        CALL M$PROMPT(PCHAR);
END PROMPTC;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
BROKE:  PROC ASYNC NOAUTO;
DCL CRT_CPOS_X SBIN WORD SYMREF;
DCL CRT_CPOS_Y SBIN WORD SYMREF;
DCL BREAK_FLAG SBIN SYMREF;
        CRT_CPOS_X = -1;
        CRT_CPOS_Y = -1;
        BREAK_FLAG = 1;
END BROKE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
BREAK:  PROC (FLG) NOAUTO;
DCL FLG SBIN WORD;
DCL BREAK_FLAG SBIN SYMREF;
DCL CRTFLUSH ENTRY;
        IF BREAK_FLAG ~= 0 THEN CALL CRTFLUSH;
        FLG = BREAK_FLAG;
        BREAK_FLAG = 0;
END BREAK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CURSOR_XCON: PROC ASYNC ALTRET NOAUTO;
%INCLUDE CP_6;
%FPT_TRMCTL   (FPTN=RESET_NOOPT, STCLASS=CONSTANT,
               TRMCTL=RESET_NOOPT_CONTROL);
%VLP_TRMCTL   (FPTN=RESET_NOOPT_CONTROL, STCLASS=CONSTANT,
               NOOPTMIZ=NO);
DCL CRT_OPT_WAS_ON BIT(1) SYMREF;
        IF CRT_OPT_WAS_ON
        THEN DO;
           CRT_OPT_WAS_ON = '0'B;
           CALL M$STRMCTL (RESET_NOOPT) ALTRET (IGNORE_ALT);
           END;
IGNORE_ALT: ALTRETURN;
END CURSOR_XCON;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
NOWAIT: PROC(TXT) NOAUTO;
%INCLUDE CP_6;
%F$DCB;
DCL TXT CHAR(4);
DCL TXB(0:3) REDEF TXT BIT(9) UNAL;
DCL MASK BIT(9) CONSTANT INIT('177'O);
DCL BIGBUF CHAR(500) STATIC;
DCL BIGINDEX SBIN WORD STATIC INIT(-1);
DCL CRT_CPOS_X SBIN WORD SYMREF;
DCL CRT_CPOS_Y SBIN WORD SYMREF;
DCL TX SBIN WORD;
DCL TY SBIN WORD;
DCL LASTARS SBIN WORD STATIC INIT(0);
DCL ZERO (0:3) BIT(9) UNAL CONSTANT INIT('000'O*0);
%FPT_EOM (FPTN=NOW,DCB=M$UC,TIMEOUT=1,UTYPE=MIL10);
%FPT_EOM (FPTN=W,DCB=M$UC,TIMEOUT=0);
%FPT_READ (FPTN=RD,DCB=M$TERM,BUF=BIGBUF,TRANS=YES);
%FPT_TRMPRG (FPTN=PURGE,DCB=M$UC,PURGEINPUT=YES,RSTBRK=YES);
DCL CRTFLSHX ENTRY;
DCL CRTFLUSH ENTRY;
DCL M$TERM DCB;
        CALL CRTFLSHX;
        TXT=' ';
        IF BIGINDEX >= 0 AND BIGINDEX < LASTARS THEN DO;
           TXB(0) = ASCBIT(SUBSTR(BIGBUF,BIGINDEX,1)) & MASK;
           BIGINDEX = BIGINDEX + 1;
           RETURN;
           END;
        CALL M$EOM(NOW);
        CALL M$READ(RD) ALTRET(DONT_CARE);
DONT_CARE:
        LASTARS = DCBADDR(DCBNUM(M$TERM))->F$DCB.ARS#;
        IF LASTARS > 0 THEN DO;
           TXB(0) = ASCBIT(SUBSTR(BIGBUF,0,1)) & MASK;
           BIGINDEX = 1;
           CALL M$EOM(W);
           RETURN;
           END;
NONE:   CALL M$EOM(W);
        TXB = ZERO;
        BIGINDEX = -1;
        RETURN;
FLUSH:  ENTRY;
        CALL CRTFLUSH;
        BIGINDEX = -1;
        CALL M$TRMPRG (PURGE);
        RETURN;
END NOWAIT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
ERROUT: PROC(ERR);
%INCLUDE CP_6;
DCL B$TCB$ PTR SYMREF;
%B$TCB;
%B$ALT;
DCL ERR SBIN WORD;
DCL F$108 DCB;
DCL M$DO DCB;
%FPT_ERRMSG (FPTN=EOUT,BUF=EBUF,CODE=ERRCODE,INCLCODE=YES,OUTDCB1=F$108);
DCL ERRCODE BIT(36) ALIGNED STATIC;
DCL EBUF CHAR(120) STATIC;
        ERRCODE = BINBIT(ERR,36);
        IF ERR=0 THEN ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR = ERRCODE THEN
           EOUT.V.DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
        ELSE EOUT.V.DCB# = 0;
        CALL M$ERRMSG(EOUT) ALTRET(BACK);
BACK:   RETURN;
END ERROUT;
