/*M* DABBLE -- Bulletin board reader  */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* CTI=1, THI=2 */
 
/*
         Contributed by
            The University of California
 
         Although this program has been tested by its contributor,
         no warranty, express or implied, is made by the
         contributor or the University of California, as to the
         accuracy and functioning of the program and related
         program materials, nor shall the fact of distribution
         constitute any such warranty, and no responsibility is
         assumed by the contributor or the University of California.
*/
 
/*X*    */
 
/*
    DABBLE reads the :MAIL_? file that is used as a bulletin board
    (similar to meetings, but better).  It is patterned after
    bbr and bbc, part of the Rand MH mail system for 4.2bsd UNIX(tm)
    systems.
*/
 
DABBLE: PROC MAIN;
 
/*
       INCLUDES
*/
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE DABBLE_C61;
%INCLUDE B_ERRORS_C;
%INCLUDE B_SEGIDS_C;
%INCLUDE B_MACROS_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE XU_SUBS_C;
%INCLUDE XUG_ENTRY;
%INCLUDE XUH_MACRO_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE XUF_ENTRY;
%INCLUDE VM_MACRO_C;
 
%F$DCB;
%B$TCB;
%B$ALT;
%B$EXCFR;
 
/*
   EXTERNAL ROUTINES
*/
DCL BBR_ABORT ENTRY;
DCL BBR_XCON ENTRY ASYNC;
 
/*
       DCBs
*/
DCL M$DABBLE DCB;
DCL M$DABBLERC DCB;
DCL M$LO DCB;
DCL M$NEXT DCB;
DCL M$LM DCB;
 
/*
       POINTERS
*/
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL DABBLE_CMDS PTR SYMREF;
DCL ATTACH_CMDS PTR SYMREF;
DCL OUT$ PTR;
%VLP_ERRCODE (FPTN=OUTERR, STCLASS="REDEF OUT$");
DCL BLK$ PTR AUTO;
DCL PTR1$ PTR AUTO;
DCL PTR2$ PTR AUTO;
 
/*
       PARSER STUFF
*/
%PARSE$OUT (NAME=P$B, STCLASS=BASED);
%PARSE$SYM (NAME=P$S, STCLASS=BASED);
 
%P_PCB (STCLASS=STATIC);
 
%XUG_GETCMD (NAME=XUG_GETCMD, STCLASS="STATIC SYMDEF");
%XUG_INIT (PCB=P_PCB, ABORT=BBR_ABORT, GOODCMD=YES, COMMANDS=YES,
           INHIBIT_NULL=YES);
 
%XUH_PARAM (OUTDCB1=M$LO);
 
%TEXTC (NAME=X$STRING,STCLASS=BASED);
 
DCL LAST_CMD UBIN;
 
DCL BBR_PROMPT CHAR(0) STATIC INIT ('>');
 
DCL 1 ATTACH_PROMPT STATIC,
      2 * CHAR(0) INIT('Attachment '),
      2 NUM CHAR(1) INIT('0'),
      2 * CHAR(0) INIT('>');
 
/*
       DATA
*/
DCL ABORT_REMEMBER REMEMBER STATIC SYMDEF;
DCL EXIT_REMEMBER REMEMBER STATIC SYMDEF;
 
DCL LOW_MESSAGE UBIN;
DCL HIGH_MESSAGE UBIN;
DCL CUR_MESSAGE UBIN;
DCL START_MESSAGE UBIN;
DCL BB_HIGH UBIN;
DCL BBRC_HIGH UBIN;
DCL BBRC_DATA UBIN;
 
DCL BASEDCHAR CHAR(80) BASED;
 
DCL VALUE UBIN;
DCL INDX UBIN;
DCL ATTACH_IDX UBIN;
 
%VLP_NAME (FPTN=BB_NAME, STCLASS=STATIC, LEN=70);
 
%VLP_NAME (FPTN=MODERATOR, STCLASS=STATIC, LEN=31);
 
DCL  MODERATOR$ PTR;
DCL 1 MODERATOR_TEST REDEF MODERATOR$,
      2 * BIT(24) UNAL,
      2 SEGID BIT(12) UNAL;
 
DCL 1 BB_NAME_TABLE(0:99) STATIC,
      2 L# UBIN(9),
      2 NAME# CHAR(70);
 
DCL 1 ATTACH_LIST STATIC,
      2 NUM UBIN,
      2 CMD (0:6),
        3 SIZE# UBIN(9) CALIGNED,
        3 CMD# CHAR(80);
 
DCL 1 ATTACH_KEY STATIC,
      2 L# UBIN(9) CALIGNED INIT(31),
      2 KEY# (0:30) CHAR(1) INIT(%BITASC('777'O)*0);
 
DCL BB_INDX SBIN STATIC INIT (0);
 
DCL NUM_BBS SBIN STATIC INIT (-1);
 
DCL BB_OPEN BIT(1) STATIC INIT ('0'B);
 
DCL WRITE_BBRC BIT(1) STATIC INIT ('0'B);
 
DCL ONE_SHOT BIT(1) STATIC;
 
DCL CMD_BFR CHAR(256) STATIC;
 
DCL CMD_SIZE UBIN STATIC SYMDEF INIT(0);
 
DCL FORCE_READ BIT(1) STATIC;
 
DCL EOF_ENCOUNTERED BIT (1) STATIC INIT (%NO#);
 
DCL LIST_NEW BIT(1) STATIC;
 
DCL DISPLAY_NEW BIT (1) STATIC;
 
DCL DO_ALL BIT(1) STATIC;
 
DCL DOING_USE BIT(1) STATIC;
 
DCL ATTACH_PRESENT BIT(1) STATIC;
 
DCL I UBIN ;
 
/*
       MAIL MACROS AND OTHER STUFF
*/
%VM_KEYTYPES;
 
DCL VM_HEADER$ PTR STATIC;
DCL 1 VM_HEADER_INIT$ REDEF VM_HEADER$,
      2 OFFSET UBIN(24) UNAL,
      2 SID BIT(12) UNAL;
 
DCL VM_PROFILE$ PTR STATIC;
DCL 1 VM_PROFILE_INIT$ REDEF VM_PROFILE$,
      2 OFFSET UBIN(24) UNAL,
      2 SID BIT(12) UNAL;
 
%VLP_VECTOR (FPTN=VM_HEADER_, STCLASS=STATIC, SEGID=%DS2SID);
%VLP_VECTOR (FPTN=VM_PROFILE_, STCLASS=STATIC, SEGID=%DS3SID);
 
/*
       STUFF FOR X$WRITE
*/
%F_FDS (NAME=BB_FDS, BUF=OUT_BFR, DCB=M$LO);
DCL OUT_BFR CHAR(255) STATIC;
 
DCL BB_SALUTATION_FMT CHAR (0) CONSTANT INIT ('DABBLE A02 here.');
 
/*
       FPTS
*/
%FPT_INT (UENTRY=XUG$BREAK, STCLASS=CONSTANT);
 
%FPT_XCON (UENTRY=BBR_XCON, STCLASS=CONSTANT);
%FPT_XCON (FPTN=DISABLE_EXIT_CONTROL, STCLASS=CONSTANT, UENTRY=NIL);
 
%FPT_TRMCTL (FPTN=GET_CTL, STCLASS=CONSTANT, TRMCTL=SAVE_CTL);
%FPT_TRMCTL (FPTN=SET_CTL, STCLASS=CONSTANT, TRMCTL=SET_PAGE);
 
%VLP_TRMCTL (FPTN=SAVE_CTL, STCLASS=STATIC);
%VLP_TRMCTL (FPTN=SET_PAGE, STCLASS=EXT, PAGEHALT=YES);
 
%FPT_CMDVAR (FPTN=GET_CMDVAR, FUN=FETCH, NAME=PAGEHALT,
             PRIVATE=NO, VALUE=PHVAL ) ;
%VLP_NAME (FPTN=PAGEHALT, NAME='DABBLE_X_PAGEHALT') ;
%VLP_NAME (FPTN=PHVAL, LEN=80) ;
 
%FPT_FID (STCLASS=CONSTANT, RESULTS=VLR_FID,
          ACCT=FID_ACCT,
          ASN=FID_ASN,
          NAME=FID_NAME,
          PASS=FID_PASS,
          RES=FID_RES,
          TEXTFID=FID_TEXT,
          SN=FID_SN,
          WSN=FID_WSN);
 
%VLR_FID;
%VLP_ACCT (FPTN=FID_ACCT);
%VLP_NAME (FPTN=FID_NAME);
%VLP_PASS (FPTN=FID_PASS);
%VLP_SN (FPTN=FID_SN);
%VLP_WSN (FPTN=FID_WSN);
DCL FID_TEXT CHAR(100) STATIC;
DCL FID_RES CHAR(4) STATIC;
DCL FID_ASN UBIN(9) STATIC;
DCL FID_EXIST UBIN STATIC;
 
%FPT_OPEN (FPTN=OPEN_LO_DEFAULT, STCLASS=CONSTANT,
           REASSIGN=YES,
           FUN=CREATE,
           EXIST=OLDFILE,
           SCRUB=YES,
           DCB=M$LO);
 
%FPT_OPEN (FPTN=OPEN_LO,
           REASSIGN=NO,
           SCRUB=YES,
           DCB=M$LO,
           FUN=CREATE,
           ORG=UR,
           ACS=SEQUEN);
 
%FPT_CLOSE (FPTN=CLOSE_LO, STCLASS=CONSTANT,
           DCB=M$LO,
           DISP=SAVE);
 
%FPT_EXIT (FPTN=SET_STEPCC, STCLASS=CONSTANT,
           STEPCC=2);
 
%VLP_ERRCODE (FPTN=OPEN_ERR, STCLASS=STATIC);
 
%FPT_READ (FPTN=READ_ATTACH,
           BUF=ATTACH_LIST,
           DCB=M$DABBLERC,
           KEY=ATTACH_KEY,
           KEYS=YES);
 
%FPT_WRITE (FPTN=WRITE_ATTACH,
            BUF=ATTACH_LIST,
            DCB=M$DABBLERC,
            KEY=ATTACH_KEY);
 
%EJECT;
 
/*
       DABBLE starts here.  Setup the data pages for the profile
       and header records.
*/
 
        REMEMBER EXIT_POINT IN EXIT_REMEMBER;
        CALL M$GTRMCTL (GET_CTL);
        CALL M$CMDVAR (GET_CMDVAR) WHENRETURN DO ;
           DO I = 0 TO PHVAL.L# - 1 ;
              SUBSTR(PHVAL.NAME#,I,1) =
                BITASC(ASCBIT(SUBSTR(PHVAL.NAME#,I,1))&'737'O);
              END ;
           DO SELECT (SUBSTR (PHVAL.NAME#, 0, PHVAL.L#) ) ;
              SELECT ('NO') ;
              SET_PAGE.PAGEHALT# = '0'B ;
              SELECT ('DC') ;
              SET_PAGE.PAGEHALT# = SAVE_CTL.PAGEHALT# ;
              SELECT (ELSE) ;
           SET_PAGE.PAGEHALT# = '1'B ;
              END ;
           END ;
        WHENALTRETURN DO ;
           SET_PAGE.PAGEHALT# = '1'B ;
           END ;
        CALL M$STRMCTL (SET_CTL);
        SET_PAGE.PAGEHALT# = SAVE_CTL.PAGEHALT#;
        CALL M$XCON (FPT_XCON);
        VM_HEADER_INIT$.OFFSET=0;
        VM_HEADER_INIT$.SID=%DS2SID;
        VM_PROFILE_INIT$.OFFSET=0;
        VM_PROFILE_INIT$.SID=%DS3SID;
        CALL GET_SEG (VM_HEADER_, 1024);
        CALL GET_SEG (VM_PROFILE_, 1024);
        CALL M$OPEN (OPEN_LO_DEFAULT);
        XUH_PARAM.PROCNAME_ = VECTOR(DCBADDR(DCBNUM(M$LM)) -> F$DCB.NAME#);
        XUH_PARAM.PROCACCT_ = VECTOR(DCBADDR(DCBNUM(M$LM)) -> F$DCB.ACCT#);
 
                                   /* Get any attachment in the :DABBLE file  */
        ATTACH_PRESENT = %NO#;
        INDX = %UPDATE#;
        CALL OPEN_BBRC(INDX) ALTRET(GIVUP);
        CALL M$READ(READ_ATTACH) WHENRETURN DO;
           ATTACH_PRESENT = %YES#;
           END;
        WHENALTRETURN DO;
           ATTACH_PRESENT = %NO#;
           END;
        CALL CLOSE_BBRC;
 
/* Set up the formatter to use the actual width of the terminal.  If width
   is less than 12, use full buffer */
 
GIVUP:  IF DCBADDR(DCBNUM(M$LO)) -> F$DCB.WIDTH# < 12
        THEN
           BB_FDS.BUF_ = VECTOR (OUT_BFR);
        ELSE
           BB_FDS.BUF_ = VECTOR (SUBSTR (OUT_BFR, 0,
             MINIMUM (DCBADDR(DCBNUM(M$LO)) -> F$DCB.WIDTH#, LENGTHC (OUT_BFR))));
 
/*     Setup the parser */
 
        CALL XUG$INIT(XUG_GETCMD, XUG_INIT);
 
/*     See if the command line that invoked BB has a command
       for BB on it.  */
 
        ONE_SHOT=%NO#;
        IF B$JIT.CCDISP < B$JIT.CCARS
        THEN
        DO;
           ONE_SHOT=%YES#;
           CALL INDEX1R (VALUE, ')', B$JIT.CCBUF, B$JIT.CCARS)
           WHENALTRETURN DO;
              VALUE = B$JIT.CCARS + 1;
              END;
           CMD_BFR=SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1,VALUE-B$JIT.CCDISP-1);
           CALL GETCMD(DABBLE_CMDS,OUT$,VECTOR(BBR_PROMPT),
             CMD_BFR,VALUE-B$JIT.CCDISP-1) ALTRET (CMD_ERR);
           CALL PROCESS_CMD;
 
               /*  If this is a specific one-shot command, clean up and exit  */
 
           IF ONE_SHOT AND
             (LAST_CMD=%CMD_CHECK OR
             LAST_CMD=%CMD_FORGET OR
             LAST_CMD=%CMD_SEND OR
             LAST_CMD=%CMD_STATUS) THEN
           DO;
              CALL CLOSE_BBRC;
              CALL M$EXIT;
              END;
 
 
           DO WHILE '0'B;
CMD_ERR:      CALL ERRPTR;
              CALL ERRPTR (,DCBNUM(M$LO));
              CALL ERRMSG(OUTERR);
              CALL M$EXIT (SET_STEPCC);
              END;
           END;
 
/* Announce invokation */
 
        CALL X$WRITE (BB_FDS, VECTOR (BB_SALUTATION_FMT));
 
/*     Process commands for BB  */
 
        REMEMBER END_LOOP IN ABORT_REMEMBER;
        CALL M$INT (FPT_INT);
        DO WHILE '1'B;                  /*  DO FOREVER                        */
           IF CMD_SIZE = 0 AND EOF_ENCOUNTERED
           THEN DO;
              CMD_BFR = 'GO';
              CMD_SIZE = LENGTHC('GO');
              END;
           IF CMD_SIZE = 0 THEN
           DO;
              CALL GETCMD(DABBLE_CMDS,OUT$,VECTOR(BBR_PROMPT))
                ALTRET (OOPS);
              CALL PROCESS_CMD;
              END;
           ELSE
           DO;
              CALL GETCMD(DABBLE_CMDS,OUT$,VECTOR(BBR_PROMPT),
                CMD_BFR,CMD_SIZE) ALTRET (OOPS);
              CMD_SIZE=0;
              CALL PROCESS_CMD ALTRET (EXIT_POINT);
              END;
 
OOPS_BLOCK:
           DO WHILE '0'B;
OOPS:
              IF OUTERR.MON
                AND OUTERR.ERR# = %E$EOF
                AND ONE_SHOT
                AND (LIST_NEW OR DISPLAY_NEW)
              THEN DO;
                 EOF_ENCOUNTERED = %YES#;
                 EXIT OOPS_BLOCK;
                 END;
              CALL ERRPTR;
              CALL ERRPTR(,DCBNUM(M$LO));
              CALL ERRMSG(OUTERR);
              CALL M$EXIT (SET_STEPCC);
              END OOPS_BLOCK;
END_LOOP:
           END;                         /* DO FOREVER                         */
 
EXIT_POINT:
 
/*  If we need to update :DABBLE, do it now  */
 
        IF WRITE_BBRC THEN
           CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  Close the :DABBLE file            */
        CALL CLOSE_BBRC;
                                        /*  Close M$LO                        */
        IF DCBADDR(DCBNUM(M$LO))->F$DCB.FCD# THEN
           CALL M$CLOSE (CLOSE_LO);
 
        CALL M$STRMCTL (SET_CTL);
 
        CALL M$XCON (DISABLE_EXIT_CONTROL);
 
        CALL M$EXIT;
 
%EJECT;
 
/**********************************************************************
 
   PROCESS_CMD handles the BB commands READ, CHECK, etc.
 
***********************************************************************/
PROCESS_CMD: PROC ALTRET;
 
/*
       Local data
*/
DCL CHECK_FMT CHAR(0) CONSTANT INIT (' %<>A - %D new entries');
DCL CHECK1_FMT CHAR(0) CONSTANT INIT (' %<>A - 1 new entry');
DCL REMEMBER_FMT CHAR(0) CONSTANT INIT ('  Bulletin board %<>A remembered');
DCL FORGET_FMT CHAR(0) CONSTANT INIT ('  Bulletin board %<>A forgotten');
DCL FORGET_ERR_FMT CHAR(0) CONSTANT
       INIT ('  You have no entry for %<>A');
DCL STAT_HDR_FMT CHAR(0) CONSTANT
       INIT ('  You have entries for the following bulletin boards');
DCL STATUS_FMT CHAR(0) CONSTANT INIT ('    %<>A');
DCL NEXT_DONE_FMT CHAR(0) CONSTANT INIT
   ('  No more entries in %<>A.  Use GO to go to the next bulletin board.');
DCL CATALOG_HDR_FMT CHAR(0) CONSTANT
       INIT ('  The following bulletin boards are available in %<>A');
DCL CATALOG_FMT CHAR(0) CONSTANT INIT ('    %<>A');
DCL CATALOG_NONE_FMT CHAR(0) CONSTANT
       INIT ('  No bulletin boards available in %<>A');
DCL ATTLIST1_FMT CHAR(0) CONSTANT INIT('  You have %D attachments:');
DCL ATTLIST2_FMT CHAR(0) CONSTANT INIT('            Attachment %D>%9N<>A%S');
DCL ATTLIST3_FMT CHAR(0) CONSTANT INIT('  You have no attachments.');
DCL ATTCMD_FMT CHAR(0) CONSTANT INIT('%D>%9N<>A%S');
%VLP_NAME (FPTN=CATALOG_FID, LEN=31);
%VLP_NAME (FPTN=CATALOG_NAME, LEN=31);
DCL I UBIN;
DCL S BIT(1);
DCL S1 BIT(1);
DCL FOUND BIT(1);
 
/*
       PROCESS_CMD starts here
*/
        LAST_CMD=OUT$->P$B.CODE;
        DO CASE (OUT$->P$B.CODE);
 
                                        /*  Handle the ANSWER command         */
         CASE (%CMD_ANSWER_MESSAGE);
           CALL CHECK_BB_OPEN ALTRET (END_CASE);
                              /*  Handle the parser output blocks, if any     */
           IF OUT$->P$B.NSUBLKS > 0 THEN
           DO;
              PTR1$=OUT$->P$B.SUBLK$(0);
              CALL GET_SELECT (PTR1$);
              END;
           CUR_MESSAGE=START_MESSAGE;
 
                                        /*  Initialize some stuff             */
           FOUND=%NO#;
                                   /*  Loop thru the message, answering them  */
           DO WHILE '1'B;               /*  DO FOREVER                        */
              CALL GET_MESSAGE ALTRET (ANSWER_DONE);
              FOUND=%YES#;
              CALL ANSWER_MESSAGE;
              END;                      /*  DO FOREVER                        */
 
                                        /*  Report if none were found         */
ANSWER_DONE: CALL REPORT_FOUND;
 
 
                                        /*  Handle null commands              */
         CASE (%CMD_BLANK);
 
           IF XUG_GETCMD.EOMCHAR# = BINASC(10)
           THEN DO;
 
              LAST_CMD = %CMD_NEXT;
              GOTO DO_NEXT;
 
              END;
 
                                        /*  Handle the CHECK command          */
         CASE (%CMD_CHECK);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  Get the bulletin board names      */
           CALL GET_BB_NAMES ALTRET (CHECK_END);
                              /*  Loop thru the list of bulletin board names  */
           DO I=0 TO NUM_BBS;
                              /*  Get the bulletin board name into BB_NAME    */
              BB_NAME.L#=BB_NAME_TABLE.L#(I);
              BB_NAME.NAME#=BB_NAME_TABLE.NAME#(I);
                                        /*  Try to open the bboard            */
              CALL OPEN_BB(BB_NAME,BB_HIGH) ALTRET (NEXT_C_BB);
              CALL GET_BBRC(BB_NAME,BBRC_HIGH) ALTRET (NEXT_C_BB);
                         /*  See if we need to say something about this one   */
              IF BB_HIGH > BBRC_HIGH THEN
              DO;
                 VALUE=BB_HIGH-BBRC_HIGH;
                 IF VALUE > 1 THEN
                    CALL X$WRITE(BB_FDS,VECTOR(CHECK_FMT),
                      VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)),
                      VECTOR(VALUE));
                 ELSE
                    CALL X$WRITE (BB_FDS,
                      VECTOR(CHECK1_FMT),
                      VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
                 END;
 
                                        /*  Close the bboard                  */
NEXT_C_BB:    CALL CLOSE_BB;
              END;                      /*  DO INDX ...                       */
 
CHECK_END:
           NUM_BBS=-1;        /*  So we don't use anything in BB_NAME_TABLE   */
 
 
                                   /*  Handle the DISPLAY MESSAGE command     */
         CASE (%CMD_DI_MESSAGE, %CMD_SKIP_MESSAGE);
           CALL CHECK_BB_OPEN ALTRET (END_CASE);
                              /*  Handle the parser output blocks, if any     */
           IF OUT$->P$B.NSUBLKS > 0 THEN
           DO;
              PTR1$=OUT$->P$B.SUBLK$(0);
              CALL GET_SELECT (PTR1$);
              END;
           CUR_MESSAGE=START_MESSAGE;
 
                                        /*  Initialize some stuff             */
           FOUND=%NO#;
                              /*  Loop thru the messages, displaying them     */
           DO WHILE '1'B;               /*  DO FOREVER                        */
              CALL GET_MESSAGE ALTRET (DI_DONE);
              FOUND=%YES#;
              IF OUT$->P$B.CODE = %CMD_DI_MESSAGE THEN
                 CALL DISPLAY_MESSAGE;
              END;                      /*  DO FOREVER                        */
 
                                        /*  Report if none were found         */
DI_DONE:   CALL REPORT_FOUND;
 
           /* Update highest-message-#-seen, even if we found none (so
              that a DI ALL of an empty folder will shut off the "new
              entries waiting" message for that meeting. */
 
           WRITE_BBRC=%YES#;
           IF FOUND=%YES# OR BB_HIGH=HIGH_MESSAGE THEN
              BBRC_HIGH=MAXIMUM(BBRC_HIGH, HIGH_MESSAGE);
           BBRC_DATA=BBRC_HIGH;
                                        /*  Do USE attachment, if any.        */
           IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN DO;
              CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                VECTOR(ATTACH_IDX),
                VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
              CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
              CMD_BFR = SUBSTR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX),0,CMD_SIZE);
              ATTACH_IDX = ATTACH_IDX + 1;
              END;
 
                                        /*  Handle the END command            */
         CASE (%CMD_END,%CMD_X);
EXIT_NOW:  ALTRETURN;
                                        /*  Handle the FORGET command         */
         CASE (%CMD_FORGET);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  Get the bulletin board names      */
           CALL GET_BB_NAMES ALTRET (FORGET_END);
                              /*  Loop thru the list of bulletin board names  */
           DO I=0 TO NUM_BBS;
              BB_NAME.L#=BB_NAME_TABLE.L#(I);
              BB_NAME.NAME#=BB_NAME_TABLE.NAME#(I);
                                        /* Delete the name from :DABBLE       */
              CALL DEL_BBRC(BB_NAME) WHENRETURN
              DO;
                 CALL X$WRITE (BB_FDS,
                   VECTOR(FORGET_FMT),
                   VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
                 END;
              WHENALTRETURN
              DO;
                 CALL X$WRITE (BB_FDS,
                   VECTOR(FORGET_ERR_FMT),
                   VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
                 END;
 
              END;
 
FORGET_END:
           NUM_BBS=-1;        /*  So we don't use anything in BB_NAME_TABLE   */
 
 
                                   /*  Handle the HELP, ?, and ?? commands    */
/* Code disabled... uses freebie logic in GETCMD
         CASE (%CMD_HELP);
           XUH_PARAM.HELP$=OUT$->P$B.SUBLK$(0)->P$S.TEXTC$;
           XUH_PARAM.MORE#=%NO#;
           CALL HELP(XUH_PARAM);
 
         CASE (%CMD_QUES1);
           CALL MOREMSG(XUH_PARAM);
         CASE (%CMD_QUES2);
           CALL ALLMSG(XUH_PARAM);
*/
 
                                        /*  Handle the LIST command           */
         CASE (%CMD_LIST_MESSAGE);
           CALL CHECK_BB_OPEN ALTRET (END_CASE);
                              /*  Handle the parser output blocks, if any     */
           IF OUT$->P$B.NSUBLKS > 0 THEN
           DO;
              PTR1$=OUT$->P$B.SUBLK$(0);
              CALL GET_SELECT (PTR1$);
              END;
           CUR_MESSAGE=START_MESSAGE;
 
                                        /*  Initialize some stuff             */
           FOUND=%NO#;
                                   /*  Loop thru the messages, listing them   */
           DO WHILE '1'B;               /*  DO FOREVER                        */
              CALL GET_MESSAGE ALTRET (LIST_DONE);
              FOUND=%YES#;
              CALL LIST_MESSAGE;
              END;                      /*  DO FOREVER                        */
 
                                        /*  Report if none were found         */
LIST_DONE: CALL REPORT_FOUND;
                                        /*  Do USE attachment, if any.        */
           IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN DO;
              CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                VECTOR(ATTACH_IDX),
                VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
              CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
              CMD_BFR = SUBSTR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX),0,CMD_SIZE);
              ATTACH_IDX = ATTACH_IDX + 1;
              END;
 
                                        /*  Handle the NEXT command           */
         CASE (%CMD_NEXT);
DO_NEXT:   CALL CHECK_BB_OPEN ALTRET (END_CASE);
                                        /*  Get the message, if it's there    */
           FOUND=%NO#;
           CALL GET_MESSAGE ALTRET (NEXT_DONE);
           FOUND=%YES#;
                                        /*  Display it                        */
           CALL DISPLAY_MESSAGE;
                         /*  If we displayed a new message, remember that     */
           IF CUR_MESSAGE > BBRC_HIGH THEN
           DO;
              WRITE_BBRC=%YES#;
              BBRC_DATA=CUR_MESSAGE;
              END;
NEXT_DONE: IF NOT FOUND THEN
              CALL X$WRITE (BB_FDS,
                VECTOR(NEXT_DONE_FMT),
                VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
 
           IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN DO;
              CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                VECTOR(ATTACH_IDX),
                VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
              CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
              CMD_BFR = SUBSTR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX),0,CMD_SIZE);
              ATTACH_IDX = ATTACH_IDX + 1;
              END;
 
         CASE (%CMD_OUTPUT);
           IF DCBADDR(DCBNUM(M$LO))->F$DCB.FCD# THEN
              CALL M$CLOSE (CLOSE_LO);
                                        /*  See if any options were specified */
           IF OUT$->P$B.NSUBLKS > 0 THEN
           DO;
              CALL GET_FID_OPTS(OUT$) ALTRET (OUTPUT_DONE);
              IF NOT VLR_FID.ACCT THEN
                 FID_ACCT.ACCT#=B$JIT.FACCN;
              OPEN_LO.NAME_=VECTOR(FID_NAME);
              OPEN_LO.ACCT_=VECTOR(FID_ACCT);
              IF VLR_FID.PASS THEN
                 OPEN_LO.PASS_=VECTOR(FID_PASS);
              IF VLR_FID.SN THEN
                 OPEN_LO.SN_=VECTOR(FID_SN);
              IF VLR_FID.WSN THEN
                 OPEN_LO.WSN_=VECTOR(FID_WSN);
              IF VLR_FID.RES THEN
                 OPEN_LO.V.RES#=FID_RES;
              IF VLR_FID.ASN THEN
                 OPEN_LO.V.ASN#=FID_ASN;
              OPEN_LO.V.INITZ.SCRUB#=%YES#;
              OPEN_LO.V.EXIST#=FID_EXIST;
              CALL M$OPEN (OPEN_LO) WHENALTRETURN
              DO;
                 CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                   DCBNUM(M$LO));
                 GOTO OPEN_DEFAULT;
                 END;
              END;
           ELSE
OPEN_DEFAULT:
              CALL M$OPEN (OPEN_LO_DEFAULT) WHENALTRETURN
              DO;
                 CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                   DCBNUM(M$LO));
                 END;
 
OUTPUT_DONE:;
 
 
                                        /*  Handle the PREVIOUS command       */
         CASE (%CMD_PREVIOUS);
           CALL CHECK_BB_OPEN ALTRET (END_CASE);
                                        /*  Get the message, if it's there    */
           FOUND=%NO#;
           CALL GET_MESSAGE ALTRET (PREV_DONE);
           FOUND=%YES#;
                                        /*  Display it                        */
           CALL DISPLAY_MESSAGE;
 
                                        /*  Report if none were found         */
PREV_DONE: CALL REPORT_FOUND;
 
           IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN DO;
              CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                VECTOR(ATTACH_IDX),
                VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
              CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
              CMD_BFR = SUBSTR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX),0,CMD_SIZE);
              ATTACH_IDX = ATTACH_IDX + 1;
              END;
                                        /*  Handle the GO command             */
         CASE (%CMD_GO);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  If doing USE, reset ATTACH index. */
           IF DOING_USE THEN
              ATTACH_IDX = 0;
 
           CALL GET_NEXT_BB WHENALTRETURN
           DO;
              IF ONE_SHOT THEN ALTRETURN;
              END;
 
 
                                   /*  Handle the READ, CASE, USE command     */
         CASE (%CMD_READ,%CMD_SELECT,%CMD_USE);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  Get the bulletin board names      */
           CALL GET_BB_NAMES ALTRET (READ_END);
           CALL GET_NEXT_BB WHENALTRETURN
           DO;
              IF ONE_SHOT THEN ALTRETURN;
              END;
READ_END:  ;
 
                                        /*  Handle the REMEMBER command       */
         CASE (%CMD_REMEMBER);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  Get the bulletin board names      */
           CALL GET_BB_NAMES ALTRET (REMEMBER_END);
                         /*  Loop thru the names, writing a :DABBLE record    */
           DO WHILE BB_INDX <= NUM_BBS;
                              /*  Get the bulletin board name into BB_NAME    */
              BB_NAME.L#=BB_NAME_TABLE.L#(BB_INDX);
              BB_NAME.NAME#=BB_NAME_TABLE.NAME#(BB_INDX);
              CALL PUT_BBRC(BB_NAME,0);
              CALL X$WRITE (BB_FDS,
                VECTOR(REMEMBER_FMT),
                VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
              BB_INDX=BB_INDX+1;
              END;                      /*  DO WHILE                          */
REMEMBER_END:;
 
                                        /*  Handle the SEND command           */
         CASE (%CMD_SEND);
           CALL SEND_MESSAGE;
 
 
                                        /*  Handle the STATUS command         */
         CASE (%CMD_STATUS);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
                                        /*  Init the header printed flag      */
           S=%NO#;
                                   /*  Force GET_BBRC_SEQ to open :DABBLE     */
           CALL CLOSE_BBRC;
 
           DO WHILE '1'B;
              CALL GET_BBRC_SEQ(BB_NAME,BBRC_HIGH) ALTRET (STATUS_END);
                                        /*  Print the header if necessary     */
              IF NOT S THEN
              DO;
                 CALL X$WRITE(BB_FDS,
                   VECTOR(STAT_HDR_FMT));
                 S=%YES#;
                 END;
              CALL X$WRITE(BB_FDS,
                VECTOR(STATUS_FMT),
                VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
 
              END;                      /*  DO WHILE ...                      */
 
STATUS_END:
           CALL CLOSE_BBRC;
 
           IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN DO;
              CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                VECTOR(ATTACH_IDX),
                VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
              CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
              CMD_BFR = SUBSTR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX),0,CMD_SIZE);
              ATTACH_IDX = ATTACH_IDX + 1;
              END;
                                        /*  Handle the CATALOG command        */
         CASE (%CMD_CATALOG);
                              /*  If we need to update :DABBLE, do it now     */
           IF WRITE_BBRC THEN
              CALL PUT_BBRC(BB_NAME,BBRC_DATA);
           IF OUT$->P$B.NSUBLKS > 0 THEN
           DO;
              CATALOG_FID.NAME#=OUT$->P$B.SUBLK$(0)->P$S.TEXT;
              CATALOG_FID.L#=OUT$->P$B.SUBLK$(0)->P$S.COUNT;
              END;
           ELSE
           DO;
              CATALOG_FID.NAME#='.:MEETING';
              CATALOG_FID.L#=SIZEC('.:MEETING');
              END;
                                        /*  Tell NEXT_CATALOG to init itself  */
           S=%YES#;
                                        /*  Init the header printed flag      */
           S1=%NO#;
                              /*  Get the next bulletin board name, if any    */
           DO WHILE '1'B;
              CALL NEXT_CATALOG(CATALOG_FID,CATALOG_NAME,S)
                ALTRET (CATALOG_DONE);
              IF NOT S1 THEN
              DO;
                 CALL X$WRITE (BB_FDS,
                   VECTOR (CATALOG_HDR_FMT),
                   VECTOR (SUBSTR(CATALOG_FID.NAME#,0,
                   CATALOG_FID.L#)));
                 S1=%YES#;
                 END;
              CALL X$WRITE (BB_FDS,
                VECTOR (CATALOG_FMT),
                VECTOR (SUBSTR(CATALOG_NAME.NAME#,0,
                CATALOG_NAME.L#)));
              S=%NO#;
              END;                      /*  DO FOREVER                        */
 
CATALOG_DONE:
           IF NOT S1 THEN
              CALL X$WRITE (BB_FDS,
                VECTOR (CATALOG_NONE_FMT));
 
           IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN DO;
              CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                VECTOR(ATTACH_IDX),
                VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
              CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
              CMD_BFR = SUBSTR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX),0,CMD_SIZE);
              ATTACH_IDX = ATTACH_IDX + 1;
              END;
                                        /*  Handle the ATTACH command         */
         CASE(%CMD_ATTACH);
 
           IF OUT$->P$B.SUBLK$(0)->P$B.CODE = %OPT_ATTDEL THEN DO;
              CALL DEL_BBRC(ATTACH_KEY) ALTRET(ATIGN);
ATIGN:        ATTACH_PRESENT = %NO#;
              END;
           ELSE IF OUT$->P$B.SUBLK$(0)->P$B.CODE = %OPT_ATTLIST THEN DO;
                 IF ATTACH_PRESENT THEN DO;
                    CALL X$WRITE(BB_FDS,VECTOR(ATTLIST1_FMT),
                      VECTOR(ATTACH_LIST.NUM));
                    DO INDX = 0 TO ATTACH_LIST.NUM - 1;
                       CALL X$WRITE(BB_FDS,VECTOR(ATTLIST2_FMT),
                         VECTOR(INDX),
                         VECTOR(ATTACH_LIST.CMD.SIZE#(INDX)),
                         VECTOR(ATTACH_LIST.CMD.CMD#(INDX)));
                       END;
                    END;
                 ELSE DO;
                    CALL X$WRITE(BB_FDS,VECTOR(ATTLIST3_FMT));
                    END;
                 END;
              ELSE DO;
                 INDX = OUT$->P$B.SUBLK$(0)->P$B.CODE;
                 ATTACH_IDX = 0;
ATTLOOP:         DO WHILE(ATTACH_IDX < 7);
                    CALL BINCHAR(ATTACH_PROMPT.NUM,ATTACH_IDX);
                    CALL GETCMD(ATTACH_CMDS,OUT$,VECTOR(ATTACH_PROMPT))
                      ALTRET(ATTOOPS);
                    DO CASE(OUT$->P$B.CODE);
                     CASE(%CMD_LIST_MESSAGE,%CMD_DI_MESSAGE,%CMD_GO,
                      %CMD_NEXT,%CMD_PREVIOUS,%CMD_STATUS,%CMD_CATALOG);
                       ATTACH_LIST.CMD.SIZE#(ATTACH_IDX) = P_PCB.NCHARS;
                       ATTACH_LIST.CMD.CMD#(ATTACH_IDX) = SUBSTR(P_PCB.TEXT$->BASEDCHAR,0,P_PCB.NCHARS);
                       ATTACH_IDX = ATTACH_IDX + 1;
                     CASE(%CMD_END,%CMD_X,%CMD_BLANK);
                       EXIT ATTLOOP;
                     CASE(ELSE);
                     END;
                    END ATTLOOP;
                 IF ATTACH_IDX > 0 THEN DO;
                    ATTACH_LIST.NUM = ATTACH_IDX;
                    ATTACH_PRESENT = %YES#;
                    IF INDX = %OPT_ATTSAVE THEN DO;
                       INDX = %UPDATE#;
                       CALL OPEN_BBRC(INDX) ALTRET(GIVUP2);
                       CALL M$WRITE(WRITE_ATTACH);
                       CALL CLOSE_BBRC;
                       END;
                    END;
                 ELSE DO;
                    ATTACH_PRESENT = %NO#;
                    END;
GIVUP2:          END;
 
ATTOOPSBLK:
           DO WHILE '0'B;
ATTOOPS:      IF OUTERR.MON AND OUTERR.ERR# = %E$EOF THEN DO;
                 ATTACH_PRESENT = %NO#;
                 EXIT ATTOOPSBLK;
                 END;
              CALL ERRPTR;
              CALL ERRPTR(,DCBNUM(M$LO));
              CALL ERRMSG(OUTERR);
              CALL M$EXIT (SET_STEPCC);
              END ATTOOPSBLK;
 
END_CASE:
         END;                           /* DO CASE                            */
 
                                        /*  Return to caller                  */
        RETURN;
 
/*
   CHECK_BB_OPEN prints a message if BB_OPEN = NO#
*/
 
CHECK_BB_OPEN: PROC ALTRET;
 
DCL NO_BB_OPEN_FMT CHAR(0) STATIC
   INIT ('  No bulletin board open.  SELECT or USE one first.');
 
        IF NOT BB_OPEN THEN
        DO;
           CALL X$WRITE (BB_FDS,
             VECTOR (NO_BB_OPEN_FMT));
           ALTRETURN;
           END;
        RETURN;
 
END CHECK_BB_OPEN;
 
 
/*
   REPORT_FOUND prints a message if no messages were found
*/
REPORT_FOUND: PROC;
 
DCL NF_FMT CHAR(0) STATIC INIT ('No new messages');
 
 
        IF CMD_SIZE = 0 THEN
           IF NOT FOUND THEN
              CALL X$WRITE (BB_FDS,
                VECTOR(NF_FMT));
 
END REPORT_FOUND;
 
END PROCESS_CMD;
 
%EJECT;
 
/***********************************************************************
   GET_FID_OPTS gets the fid options for the OUTPUT command.  It ALTRETs
   if something is wrong.
***********************************************************************/
GET_FID_OPTS: PROC(P$) ALTRET;
 
DCL P$ PTR;
DCL P1$ PTR;
DCL I UBIN;
 
                                        /*  Initialize stuff                  */
        FID_NAME.NAME#=' ';
        FID_NAME.L#=0;
        FID_ACCT.ACCT#=B$JIT.FACCN;
        FID_PASS.PASS#=' ';
        FID_WSN.WSN#=' ';
        VLR_FID='0'B;
 
                                        /*  Loop for each parse block         */
        DO I=0 TO P$->P$B.NSUBLKS-1;
 
           P1$=P$->P$B.SUBLK$(I);
           DO SELECT (P1$->P$B.CODE);
 
              SELECT (%OUTPUT_ON);
              FID_EXIST=%ERROR#;
              SELECT (%OUTPUT_INTO);
              FID_EXIST=%OLDFILE#;
              SELECT (%OUTPUT_OVER);
              FID_EXIST=%NEWFILE#;
              SELECT (%OUTPUT_FID);
              FID_TEXT=P1$->P$S.TEXT;
              CALL M$FID (FPT_FID) ALTRET (BAD_FID);
              END;                      /*DO SELECT*/
           END;                         /* DO I=...                           */
 
        RETURN;
 
BAD_FID:
        CALL ERRMSG(B$TCB$->B$TCB.ALT$->B$ALT.ERR);
        ALTRETURN;
 
END GET_FID_OPTS;
 
%EJECT;
 
/***********************************************************************
   GET_BB_NAMES gets the bulletin board names that were parsed by the
   parser, and any options for the READ command.
***********************************************************************/
GET_BB_NAMES: PROC ALTRET;
 
/*
   Local data
*/
DCL RI UBIN;
DCL R$ PTR;
DCL R1$ PTR;
DCL NO_BBS CHAR(0) CONSTANT INIT ('No bulletin boards selected');
 
/*
   GET_BB_NAMES starts here
*/
 
                                        /*  Initialize some stuff first       */
        CALL CLOSE_BB;
        FORCE_READ=%NO#;
        LIST_NEW=%YES#;
        DISPLAY_NEW=%NO#;
        NUM_BBS=0;
                                   /*  Loop for all the parser output blocks  */
        DO INDX=0 TO OUT$->P$B.NSUBLKS-1;
 
                              /*  Make a pointer to the current parse block   */
           R$=OUT$->P$B.SUBLK$(INDX);
                                        /*  Figure out what we got            */
           DO SELECT (R$->P$B.CODE);
 
                                        /*  A list of BB names or 'ALL'       */
              SELECT (%OPT_BB);
 
              DO_ALL=%NO#;
                                        /*  See what we got                   */
              DO SELECT (R$->P$B.SUBLK$(0)->P$B.CODE);
 
                                        /*  ALL option                        */
                 SELECT (%BB_ALL);
 
                                        /*  Init table index                  */
                 NUM_BBS=0;
 
                                   /*  Force GET_BBRC_SEQ to open :DABBLE     */
                 CALL CLOSE_BBRC;
 
                                        /*  Read each record in :DABBLE       */
                 DO WHILE '1'B;
 
                                        /*  Read a record from :DABBLE        */
                    CALL GET_BBRC_SEQ (BB_NAME, BBRC_HIGH) ALTRET (DONE);
 
                                        /*  Store the bb names in the table   */
                    BB_NAME_TABLE.L#(NUM_BBS)=BB_NAME.L#;
                    BB_NAME_TABLE.NAME#(NUM_BBS)=BB_NAME.NAME#;
 
                                        /*  Increment the table index         */
                    NUM_BBS=NUM_BBS+1;
 
                    END;                /*  DO WHILE                          */
 
DONE:
                 CALL CLOSE_BBRC;
                                        /*  See if we got any bb names        */
                 NUM_BBS=NUM_BBS-1;
                 IF NUM_BBS < 0 THEN
                 DO;
                    CALL X$WRITE (BB_FDS,
                      VECTOR (NO_BBS));
                    ALTRETURN;
                    END;
                                        /*  Indicate doing USE/SELECT/READ.   */
                 DOING_USE = %YES#;
                 ATTACH_IDX = 0;
 
                                        /*  A BB name                         */
                 SELECT (%BB_ID);
 
                 FORCE_READ = %YES#;
 
                 R1$=R$->P$B.SUBLK$(0);
 
                                        /*  Get all the names                 */
                 DO RI=0 TO R1$->P$B.NSUBLKS-1;
                    BB_NAME_TABLE.L#(RI)=R1$->P$B.SUBLK$(RI)->
                      P$S.COUNT;
                    BB_NAME_TABLE.NAME#(RI)=R1$->P$B.SUBLK$(RI)->
                      P$S.TEXT;
                    END;
 
                                        /*  Set up NUM_BBS                    */
                 NUM_BBS=RI-1;
 
                 END;                   /*  DO SELECT                         */
 
 
                                        /*  READ command option               */
              SELECT (%OPT_READ);
 
                                        /*  Get each option                   */
              DO RI=0 TO R$->P$B.NSUBLKS-1;
 
                                   /*  Figure out what we got and set flags   */
                 DO CASE (R$->P$B.SUBLK$(RI)->P$B.CODE);
 
                                        /* READ option                        */
                  CASE (%READ_READ);
                    FORCE_READ=%YES#;
 
                                        /* LIST option                        */
                  CASE (%READ_LIST);
                    LIST_NEW=%YES#;
                    DISPLAY_NEW = %NO#;
 
                                        /* NOLIST option                      */
                  CASE (%READ_NOLIST);
                    LIST_NEW=%NO#;
                    DISPLAY_NEW = %NO#;
 
                                        /* DISPLAY option                     */
                  CASE (%READ_DISPLAY);
                    LIST_NEW=%NO#;
                    DISPLAY_NEW=%YES#;
 
                  END;                  /*  DO CASE                           */
 
                 END;                   /*  DO RI ...                         */
 
              END;                      /*  DO SELECT                         */
 
           END;                         /*  DO INDX ...                       */
 
        BB_INDX=0;
        RETURN;
 
END GET_BB_NAMES;
 
%EJECT;
 
/***********************************************************************
   GET_NEXT_BB tries to get the next bulletin board from BB_NAME_TABLE
   for the READ and GO commands.  If there are no more bulletin
   boards, BB_OPEN is set to NO# and GET_NEXT_BB returns.  If there
   is a bulletin board that can be read, BB_OPEN is set to YES#.
***********************************************************************/
GET_NEXT_BB: PROC ALTRET;
 
DCL READ_FMT CHAR(0) CONSTANT
      INIT ('Reading %<>A, currently at message %D of %D');
DCL NO_NEW_FMT CHAR(0) CONSTANT
       INIT ('  No new entries in %<>A');
DCL FORGET_FMT CHAR(0) CONSTANT INIT ('  Bulletin board %<>A forgotten');
DCL FORGET_ERR_FMT CHAR(0) CONSTANT
       INIT ('  Unable to forget %<>A');
DCL NO_MORE_FMT CHAR(0) CONSTANT
    INIT ('  (End of SELECTed bulletin board list)');
DCL CANT_READ_FMT CHAR(0) CONSTANT
    INIT ('  Unable to read any of the %D messages in bulletin board %<>A.');
DCL ATTCMD_FMT CHAR(0) CONSTANT INIT('%D>%9N<>A%S');
DCL BB_FOUND BIT(1);
 
        BB_FOUND=%NO#;
        CALL CLOSE_BB;
        BB_OPEN=%NO#;
                                   /*  Loop thru the list of bulletin boards  */
DO_WHILE:
        DO WHILE BB_INDX <= NUM_BBS;
                              /*  Get the bulletin board name into BB_NAME    */
           BB_NAME.L#=BB_NAME_TABLE.L#(BB_INDX);
           BB_NAME.NAME#=BB_NAME_TABLE.NAME#(BB_INDX);
                                   /*  Get the :DABBLE record for this bboard */
           CALL GET_BBRC(BB_NAME,BBRC_HIGH) ALTRET (NEXT_BB);
                                        /*  Try to open the bboard            */
           CALL OPEN_BB(BB_NAME,BB_HIGH)
           WHENALTRETURN DO;            /*  Can't open - see if it went away  */
 
              IF OPEN_ERR.ERR# = %E$NOFILE
                AND BBRC_HIGH > 0
              THEN DO;
 
                 CALL DEL_BBRC(BB_NAME) WHENRETURN
                 DO;
                    CALL X$WRITE (BB_FDS,
                      VECTOR(FORGET_FMT),
                      VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
                    END;
                 WHENALTRETURN
                 DO;
                    CALL X$WRITE (BB_FDS,
                      VECTOR(FORGET_ERR_FMT),
                      VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
                    END;
 
                 END;
 
              GOTO NEXT_BB;
              END;
                                        /*  Set up the message pointers       */
           LOW_MESSAGE=1;
           HIGH_MESSAGE=BB_HIGH;
           CUR_MESSAGE=BBRC_HIGH;
           START_MESSAGE=CUR_MESSAGE;
 
                                   /*  See if we need to read this bboard     */
           IF BB_HIGH > BBRC_HIGH OR FORCE_READ THEN
           DO;
              IF BB_HIGH=BBRC_HIGH THEN
                 VALUE=BB_HIGH;
              ELSE
                 VALUE=CUR_MESSAGE+1;
                                        /*  More than one message?            */
              IF HIGH_MESSAGE > 1 AND BBRC_HIGH = 0 THEN DO;
                                        /*  Get the first message number      */
                 CALL GET_MESSAGE WHENALTRETURN DO;
                                        /*  Tell user we can't read anything. */
                    CALL X$WRITE(BB_FDS,
                      VECTOR(CANT_READ_FMT),
                      VECTOR(BB_HIGH),
                      VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
                    CMD_SIZE = 0;
                    BB_FOUND = %YES#;
                    WRITE_BBRC = %YES#;
                    BBRC_HIGH = BB_HIGH;
                    BBRC_DATA = BBRC_HIGH;
                    IF DOING_USE AND ATTACH_PRESENT THEN DO;
                       CMD_SIZE = 2;
                       CMD_BFR = 'GO';
                       END;
                    EXIT DO_WHILE;
                    END;
                 VALUE = CUR_MESSAGE;
                 END;
                                        /*  Tell the user we are reading      */
              CALL X$WRITE(BB_FDS,
                VECTOR(READ_FMT),
                VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)),
                VECTOR(VALUE),
                VECTOR(BB_HIGH));
                                        /*  Either set up a first command (if */
                                        /*  needed), or do the ATTACH command */
                                        /*  (if any).                         */
              CMD_SIZE=0;
              IF DOING_USE AND ATTACH_PRESENT AND ATTACH_IDX < ATTACH_LIST.NUM THEN
              DO;
                 CALL X$WRITE(BB_FDS,VECTOR(ATTCMD_FMT),
                   VECTOR(ATTACH_IDX),
                   VECTOR(ATTACH_LIST.CMD.SIZE#(ATTACH_IDX)),
                   VECTOR(ATTACH_LIST.CMD.CMD#(ATTACH_IDX)));
                 CMD_SIZE = ATTACH_LIST.CMD.SIZE#(ATTACH_IDX);
                 CMD_BFR = ATTACH_LIST.CMD.CMD#(ATTACH_IDX);
                 ATTACH_IDX = ATTACH_IDX + 1;
                 END;
              ELSE
              DO;
                 IF LIST_NEW THEN
                 DO;
                    CMD_BFR='LIST NEW';
                    CMD_SIZE=LENGTHC('LIST NEW');
                    END;
                 IF DISPLAY_NEW THEN
                 DO;
                    CMD_BFR='DISPLAY NEW';
                    CMD_SIZE=LENGTHC('DISPLAY NEW');
                    END;
                 END;
              BB_FOUND=%YES#;
              EXIT DO_WHILE;
              END;
           ELSE
              IF NOT ONE_SHOT THEN
                 CALL X$WRITE(BB_FDS,
                   VECTOR(NO_NEW_FMT),
                   VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)));
 
 
                                        /*  Close the bboard                  */
NEXT_BB:
           CALL CLOSE_BB;
           BB_INDX=BB_INDX+1;
 
           END;                         /*  DO WHILE ...                      */
 
        BB_INDX=BB_INDX+1;
 
        IF NOT BB_FOUND THEN
        DO;
           DOING_USE = %NO#;
           CALL X$WRITE (BB_FDS,
             VECTOR (NO_MORE_FMT));
           ALTRETURN;
           END;
 
        RETURN;
 
END GET_NEXT_BB;
 
%EJECT;
 
/***********************************************************************
   GET_MESSAGE returns the next with the next message header in
   VM_HEADER_.  It ALRETURNs if there are no more messages.
***********************************************************************/
GET_MESSAGE: PROC ALTRET;
 
DCL SAVE_CUR_MESSAGE UBIN;
 
        SAVE_CUR_MESSAGE=CUR_MESSAGE;
        DO WHILE '1'B;                  /*  DO FOREVER                        */
               /*  Increment CUR_MESSAGE unless this is a PREVIOUS command    */
           IF LAST_CMD ~= %CMD_PREVIOUS THEN
              CUR_MESSAGE=CUR_MESSAGE+1;
           ELSE
              CUR_MESSAGE=CUR_MESSAGE-1;
 
       /*  If this is a PREVIOUS or NEXT command, reset LOW_MESSAGE and
           HIGH_MESSAGE  */
           IF LAST_CMD = %CMD_PREVIOUS OR
             LAST_CMD = %CMD_NEXT THEN
           DO;
              LOW_MESSAGE=CUR_MESSAGE;
              HIGH_MESSAGE=CUR_MESSAGE;
              START_MESSAGE=LOW_MESSAGE-1;
              END;
 
                                        /*  See if we have hit the end        */
           IF CUR_MESSAGE > HIGH_MESSAGE THEN
           DO;
              CUR_MESSAGE=SAVE_CUR_MESSAGE;
              ALTRETURN;
              END;
           IF CUR_MESSAGE < 1 THEN
           DO;
              CUR_MESSAGE=SAVE_CUR_MESSAGE;
              ALTRETURN;
              END;
 
                              /*  Get the message header for this message     */
           CALL GET_HEADER ALTRET (NEXT_MSG);
           CALL SET_COMMAND_VARIABLES;
           RETURN;
 
                    /*  Come here if GET_HEADER can't find the message header */
NEXT_MSG:
           IF CUR_MESSAGE > BB_HIGH OR CUR_MESSAGE < 1 THEN
           DO;
              CUR_MESSAGE=SAVE_CUR_MESSAGE;
              ALTRETURN;
              END;
 
           END;                         /* DO FOREVER                         */
 
END GET_MESSAGE;
 
%EJECT;
/*********************************************************************
    SET_COMMAND_VARIABLES keeps them up-to-date with current
        message number and folder.
*********************************************************************/
SET_COMMAND_VARIABLES: PROC;
 
/*
    Local data
*/
%VLP_NAME (FPTN = CURRENT_MESSAGE_NAME,
        STCLASS = CONSTANT,
        NAME = 'DABBLE_CURRENT_MESSAGE');
%VLP_NAME (FPTN = CURRENT_FOLDER_NAME,
        STCLASS = CONSTANT,
        NAME = 'DABBLE_CURRENT_FOLDER');
%VLP_NAME (FPTN = CURRENT_MESSAGE_TEXT,
        NAME = '      ',
        L = 6,
        LEN = 6);             /* I really pity anyone with that many messages */
 
%FPT_CMDVAR (FPTN = STORE_VARIABLE,
        FUN = STORE);
 
                                        /* first store the folder name        */
        STORE_VARIABLE.NAME_ = VECTOR( CURRENT_FOLDER_NAME);
        STORE_VARIABLE.VALUE_ = VECTOR( BB_NAME);
        CALL M$CMDVAR( STORE_VARIABLE) WHENALTRETURN DO; END;
 
                                   /* and then the current message number     */
        STORE_VARIABLE.NAME_ = VECTOR( CURRENT_MESSAGE_NAME);
        STORE_VARIABLE.VALUE_ = VECTOR( CURRENT_MESSAGE_TEXT);
        CALL BINCHAR( CURRENT_MESSAGE_TEXT.NAME#, CUR_MESSAGE);
        CALL M$CMDVAR( STORE_VARIABLE) WHENALTRETURN DO; END;
 
        RETURN;
 
END SET_COMMAND_VARIABLES;
 
%EJECT;
 
 
/***********************************************************************
   LIST_MESSAGE lists the message in VM_HEADER_.
***********************************************************************/
LIST_MESSAGE: PROC;
 
/*
   Local data
*/
%VM_HEADER;
 
%F_FDS (NAME=LIST_FDS, BUF=OUT_BFR, DCB=M$LO);
 
DCL LIST_FMT CHAR(0) CONSTANT INIT ('%5D%1A %M5..1U %*4D %ML22.A %ML43.A');
 
DCL ATSIGN_INDEX UBIN;
 
DCL FLAG CHAR(1) STATIC;
 
DCL FROM CHAR (80);
 
DCL NETADDRESS_INDEX UBIN;
 
DCL SPACE CHAR(1) STATIC INIT (' ');
 
DCL VEC_FROM VECTOR STATIC;
DCL VEC_SUBJ VECTOR STATIC;
 
/*
   LIST_MESSAGE starts here
*/
 
/* Set up the formatter to use the actual width of the terminal.  If width
   is less than 12, use full buffer */
 
        IF DCBADDR(DCBNUM(M$LO)) -> F$DCB.WIDTH# < 12
        THEN
           LIST_FDS.BUF_ = VECTOR (OUT_BFR);
        ELSE
           LIST_FDS.BUF_ = VECTOR (SUBSTR (OUT_BFR, 0,
             MINIMUM (DCBADDR(DCBNUM(M$LO)) -> F$DCB.WIDTH#, LENGTHC (OUT_BFR))));
 
                                        /*  Flag if a new message             */
        IF CUR_MESSAGE > BBRC_HIGH THEN
           FLAG='n';
        ELSE
           FLAG=' ';
 
                    /*  Setup a vector for the subject field, if there is one */
        IF VM_HEADER.SUBJECT$=ADDR(NIL)
        THEN
           VEC_SUBJ=VECTOR(SPACE);
 
        ELSE DO;
 
           VEC_SUBJ = VECTOR (VM_HEADER.SUBJECT$ -> X$STRING.TEXT);
 
           IF SUBSTR (VM_HEADER.FROM$ -> X$STRING.TEXT, 0, 12) = 'Multics Mail'
             OR SUBSTR (VM_HEADER.FROM$ -> X$STRING.TEXT, 0, 12) = 'MULTICS MAIL'
           THEN DO;
 
              CALL INDEX1R (NETADDRESS_INDEX, '<',
                VM_HEADER.SUBJECT$->X$STRING.TEXT)
              WHENRETURN DO;
 
                 VEC_SUBJ=VECTOR(SUBSTR(VM_HEADER.SUBJECT$->X$STRING.TEXT, 0,
                   NETADDRESS_INDEX));
 
                 END;
 
              END;
 
           END;
 
                                        /*  Find the "@" in the sender's name */
 
        CALL INDEX (ATSIGN_INDEX, '@', VM_HEADER.FROM$ -> X$STRING.TEXT);
        VEC_FROM = VECTOR(SUBSTR(VM_HEADER.FROM$->X$STRING.TEXT,0,ATSIGN_INDEX));
 
        IF SUBSTR (VM_HEADER.FROM$ -> X$STRING.TEXT, 0, 12) = 'Multics Mail'
          OR SUBSTR (VM_HEADER.FROM$ -> X$STRING.TEXT, 0, 12) = 'MULTICS MAIL'
        THEN DO;
 
           CALL INDEX (NETADDRESS_INDEX, '"',
             VM_HEADER.REPLY_TO$ -> X$STRING.TEXT)
           WHENRETURN DO;
 
              FROM = SUBSTR (VM_HEADER.REPLY_TO$ -> X$STRING.TEXT,
                NETADDRESS_INDEX + 1);
 
              CALL INDEX1R (NETADDRESS_INDEX, '"', FROM)
              WHENRETURN DO;
                 SUBSTR (FROM, NETADDRESS_INDEX) = ' ';
                 END;
 
              VEC_FROM = VECTOR (FROM);
 
              END;
 
           END;
                                        /*  Print the list of the message     */
        CALL X$WRITE (LIST_FDS, VECTOR (LIST_FMT),
          VECTOR(CUR_MESSAGE),
          VECTOR(FLAG),
          VECTOR(VM_HEADER.CREATION_DATE),
          VECTOR(VM_HEADER.NUM_RECORDS),
          VEC_FROM,
          VEC_SUBJ);
 
        RETURN;
 
END LIST_MESSAGE;
 
%EJECT;
 
/***********************************************************************
   DISPLAY_MESSAGE displays the message whose header is in VM_HEADER_
***********************************************************************/
DISPLAY_MESSAGE: PROC;
 
/*
   Local data
*/
%VM_HEADER;
 
%VM_BODYTYPES;
 
%VM_BODYREC (VARYLEN=NO);
 
/*  FORMATTER DATA  */
%F_FDS (NAME=DI_FDS, BUF=MSG_BUF, DCB=M$LO);
 
DCL BBID_FMT CHAR(0) CONSTANT INIT ('%<>A: %D (sent %14..3U)');
 
DCL TO_FMT CHAR(0) CONSTANT INIT      ('To:       %A');
 
DCL COPY_FMT CHAR(0) CONSTANT INIT    ('Copy:     %A');
 
DCL FROM_FMT CHAR(0) CONSTANT INIT    ('From:     %A');
 
DCL REPLY_FMT CHAR(0) CONSTANT INIT   ('Reply-to: %A');
 
DCL SUBJECT_FMT CHAR(0) CONSTANT INIT ('Subject:  %A');
 
DCL REF_FMT CHAR(0) CONSTANT INIT     ('Re:       %A');
 
DCL BLANK_FMT CHAR(0) CONSTANT INIT (' ');
 
DCL ERROR_ADDRESS_FMT CHAR(0) CONSTANT INIT ('Error address -> %LA');
 
DCL BLANK CHAR(1) CONSTANT INIT (' ');
 
DCL MSG_BUF CHAR(512) STATIC;
 
DCL COUNT UBIN;
 
DCL VEC VECTOR;
 
%FPT_WRITE (DCB=M$LO);
 
%VLP_NAME (FPTN=MAIL_ERROR_FILE, NAME=':VMERRMSG.:MAILT');
 
 
/*
   DISPLAY_MESSAGE starts here
*/
 
                              /*  Print the bboard name, message number/date  */
        CALL X$WRITE(DI_FDS,
          VECTOR(BBID_FMT),
          VECTOR(SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#)),
          VECTOR(CUR_MESSAGE),
          VECTOR(VM_HEADER.CREATION_DATE));
 
                                        /*  Print who the message is to       */
        CALL X$WRITE(DI_FDS,
          VECTOR(TO_FMT),
          VECTOR(VM_HEADER.TO$->X$STRING.TEXT));
 
                                        /*  Print who got copies, if any did  */
        IF VM_HEADER.COPY$~=ADDR(NIL)
        THEN
           CALL X$WRITE(DI_FDS,
             VECTOR(COPY_FMT),
             VECTOR(VM_HEADER.COPY$->X$STRING.TEXT));
 
                                        /*  Print who the message is from     */
        CALL X$WRITE(DI_FDS,
          VECTOR(FROM_FMT),
          VECTOR(VM_HEADER.FROM$->X$STRING.TEXT));
 
                                        /*  Print the reply address, if any   */
        IF VM_HEADER.REPLY_TO$~=ADDR(NIL)
          AND VM_HEADER.REPLY_TO$ ~= VM_HEADER.FROM$
          AND VM_HEADER.REPLY_TO$->X$STRING.TEXT ~=
          VM_HEADER.FROM$->X$STRING.TEXT
        THEN
           CALL X$WRITE(DI_FDS,
             VECTOR(REPLY_FMT),
             VECTOR(VM_HEADER.REPLY_TO$->X$STRING.TEXT));
 
                                        /*  Print the subject                 */
        IF VM_HEADER.SUBJECT$~=ADDR(NIL)
        THEN
           CALL X$WRITE(DI_FDS,
             VECTOR(SUBJECT_FMT),
             VECTOR(VM_HEADER.SUBJECT$->X$STRING.TEXT));
        ELSE
           CALL X$WRITE(DI_FDS,
             VECTOR(SUBJECT_FMT),
             VECTOR(BLANK));
 
                                        /*  Print the reference, if any       */
        IF VM_HEADER.REFERENCE$~=ADDR(NIL)
        THEN
           CALL X$WRITE(DI_FDS,
             VECTOR(REF_FMT),
             VECTOR(VM_HEADER.REFERENCE$->X$STRING.TEXT));
 
                                        /*  Print a blank line                */
        CALL X$WRITE(DI_FDS,
          VECTOR(BLANK_FMT));
 
                                   /*  Print errors for this message if any   */
        IF VM_HEADER.STATUS.ERR THEN
        DO;
           CALL SETERRMSG (MAIL_ERROR_FILE);
           CALL ERRMSG (VM_HEADER.ERROR,,DCBNUM(M$LO));
           IF VM_HEADER.BAD_ADDRESS$~=ADDR(NIL) THEN
           DO;
              VEC=VECTOR(VM_HEADER.BAD_ADDRESS$->X$STRING.TEXT);
              CALL X$WRITE(DI_FDS,
                VECTOR(ERROR_ADDRESS_FMT),
                VEC);
              END;
           CALL SETERRMSG;
           RETURN;
           END;
 
                                        /*  Print the body of the message     */
        DO INDX=0 TO VM_HEADER.NUM_RECORDS-1;
           CALL GET_BODY(INDX,VM_BODYREC,COUNT,FPT_WRITE.V.DVBYTE)
             ALTRET (DONE);
           IF COUNT > 0 THEN
              FPT_WRITE.BUF_=VECTOR(SUBSTR(VM_BODYREC.VALUE.DATA,0,COUNT));
           ELSE
              FPT_WRITE.BUF_=VECTOR(BLANK);
           CALL M$WRITE(FPT_WRITE);
 
           END;
 
DONE:
                                        /*  Print a blank line                */
        CALL X$WRITE(DI_FDS,
          VECTOR(BLANK_FMT));
        RETURN;
 
END DISPLAY_MESSAGE;
 
%EJECT;
 
/***********************************************************************
   ANSWER_MESSAGE answers the message whose header is in VM_HEADER_
***********************************************************************/
ANSWER_MESSAGE: PROC;
 
/*
   Local data
*/
%VM_HEADER;
 
/*  PROMPT STUFF  */
%FPT_PROMPT;
 
DCL BODY_PROMPT CHAR(5) CONSTANT INIT ('Body:');
 
DCL BODY_PROMPT_1 CHAR(5) CONSTANT INIT ('     ');
 
DCL SUBJECT_PROMPT CHAR(9) CONSTANT INIT ('Subject: ');
 
/*  Read from M$UC  */
%FPT_READ (DCB=M$UC, STCLASS=CONSTANT,
           BUF=ANS_BUF);
 
/*  Open *BB  */
%FPT_OPEN (DCB=M$TEMP, STCLASS=CONSTANT,
           FUN=CREATE,
           EXIST=NEWFILE,
           ASN=FILE,
           NAME=VLP_NAME);
 
/*  Write *BB  */
%FPT_WRITE (DCB=M$TEMP,
           BUF=ANS_BUF);
 
/*  Close *BB  */
%FPT_CLOSE (DCB=M$TEMP, STCLASS=CONSTANT,
            DISP=SAVE);
 
%VLP_NAME (NAME='*BB');
 
/*  Link to SEND.:SYS  */
%FPT_LINK (CMD=CMD_BUF, STCLASS=CONSTANT,
           NAME=SEND_NAME,
           ACCT=SEND_ACCT);
 
%VLP_NAME (FPTN=CMD_BUF, STCLASS=CONSTANT,
           NAME="'SEND *BB(OPTIONS)'");
 
%VLP_NAME (FPTN=SEND_NAME, STCLASS=CONSTANT, NAME='SEND');
 
%VLP_ACCT (FPTN=SEND_ACCT, STCLASS=CONSTANT, ACCT=':SYS');
 
/*  Formatter stuff  */
DCL TO_FMT CHAR(0) CONSTANT INIT ('To: %<>A');
 
DCL COPY_FMT CHAR(0) CONSTANT INIT ('Copy: %<>A');
 
DCL SUBJECT_FMT CHAR(0) CONSTANT INIT ('Subject: %<>A');
 
DCL M$TEMP DCB;
 
DCL ANS_BUF CHAR(256) STATIC;
 
DCL ANS_BUF_A CHAR(256) STATIC;
 
DCL I UBIN;
 
%VLP_NAME (FPTN=BBN, LEN=31);
 
/*
   ANSWER_MESSAGE starts here
*/
 
        CALL INDEX1(I,'.',SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#));
        IF I < BB_NAME.L# THEN
        DO;
           CALL CONCAT(BBN.NAME#,
             '/', SUBSTR(BB_NAME.NAME#,0,BB_NAME.L#));
           BBN.L#=BB_NAME.L#+1;
           END;
        ELSE
           BBN=BB_NAME;
        IF MODERATOR.L# > 0 THEN BBN = MODERATOR;
 
 
                              /*  Print who we are sending the message to     */
        IF VM_HEADER.REPLY_TO$ = ADDR(NIL)
        THEN
           CALL X$WRITE (BB_FDS,
             VECTOR (TO_FMT),
             VECTOR (VM_HEADER.FROM$->X$STRING.TEXT));
        ELSE
           CALL X$WRITE (BB_FDS,
             VECTOR (TO_FMT),
             VECTOR (VM_HEADER.REPLY_TO$->X$STRING.TEXT));
 
                                        /*  ... with a copy to the bboard     */
        CALL X$WRITE (BB_FDS,
          VECTOR (COPY_FMT),
          VECTOR (SUBSTR(BBN.NAME#,0,BBN.L#)));
 
                                        /*  Open *BB                          */
        CALL M$OPEN (FPT_OPEN);
 
                                   /*  Make the TO: line and write it to *BB  */
        IF VM_HEADER.REPLY_TO$ = ADDR(NIL)
        THEN DO;
           CALL CONCAT (ANS_BUF,
             'TO:',
             SUBSTR(VM_HEADER.FROM$->X$STRING.TEXT,0,
             VM_HEADER.FROM$->X$STRING.SIZ));
           FPT_WRITE.BUF_.BOUND=VM_HEADER.FROM$->X$STRING.SIZ+2;
           END;
        ELSE DO;
           CALL CONCAT (ANS_BUF,
             'TO:',
             SUBSTR(VM_HEADER.REPLY_TO$->X$STRING.TEXT,0,
             VM_HEADER.REPLY_TO$->X$STRING.SIZ));
           FPT_WRITE.BUF_.BOUND=VM_HEADER.REPLY_TO$->X$STRING.SIZ+2;
           END;
        CALL M$WRITE (FPT_WRITE);
 
                                        /*  Get the subject for the message   */
        FPT_PROMPT.PROMPT_=VECTOR(SUBJECT_PROMPT);
        CALL M$PROMPT (FPT_PROMPT);
        CALL M$READ (FPT_READ) ALTRET (READ_ERR);
 
                                        /*  Write the SUBJECT: line to *BB    */
        IF DCBADDR(DCBNUM(M$UC))->F$DCB.ARS# ~= 0 THEN
        DO;
                                   /*  Do this if the user typed a subject    */
           CALL CONCAT(ANS_BUF_A,
             'SUBJECT:',
             ANS_BUF);
           ANS_BUF=ANS_BUF_A;
           FPT_WRITE.BUF_.BOUND=DCBADDR(DCBNUM(M$UC))->F$DCB.ARS#+7;
           END;
        ELSE
        DO;
                              /*  Do this if the user didn't type a subject   */
           IF VM_HEADER.SUBJECT$~=ADDR(NIL) THEN
           DO;
              CALL CONCAT (ANS_BUF,
                'SUBJECT:',
                SUBSTR(VM_HEADER.SUBJECT$->X$STRING.TEXT,0,
                VM_HEADER.SUBJECT$->X$STRING.SIZ));
              FPT_WRITE.BUF_.BOUND=VM_HEADER.SUBJECT$->X$STRING.SIZ+7;
              END;
           END;
        CALL M$WRITE (FPT_WRITE);
 
                              /*  Make the COPY: line and write it to *BB     */
        CALL CONCAT (ANS_BUF,
          'COPY:',
          SUBSTR(BBN.NAME#,0,BBN.L#));
        FPT_WRITE.BUF_.BOUND=BBN.L#+4;
        CALL M$WRITE (FPT_WRITE);
 
                         /*  Make the REFERENCE: line and write it to *BB     */
        IF VM_HEADER.SUBJECT$~=ADDR(NIL) THEN
        DO;
           CALL CONCAT (ANS_BUF,
             'REFERENCE:',
             SUBSTR(VM_HEADER.SUBJECT$->X$STRING.TEXT,0,
             VM_HEADER.SUBJECT$->X$STRING.SIZ));
           FPT_WRITE.BUF_.BOUND=VM_HEADER.SUBJECT$->X$STRING.SIZ+9;
           CALL M$WRITE (FPT_WRITE);
           END;
 
                                        /*  Now get the body records          */
        FPT_PROMPT.PROMPT_=VECTOR(BODY_PROMPT);
        CALL M$PROMPT (FPT_PROMPT);
        CALL M$READ (FPT_READ) ALTRET (READ_ERR);
          /*  Loop until we get a null line, writing the body records to *BB  */
        DO WHILE '1'B;
           IF DCBADDR(DCBNUM(M$UC))->F$DCB.ARS#=0 THEN GOTO READ_DONE;
           FPT_WRITE.BUF_.BOUND=DCBADDR(DCBNUM(M$UC))->F$DCB.ARS#-1;
           CALL M$WRITE (FPT_WRITE);
           FPT_PROMPT.PROMPT_=VECTOR(BODY_PROMPT_1);
           CALL M$PROMPT (FPT_PROMPT);
           CALL M$READ (FPT_READ);
           END;                         /* DO FOREVER                         */
 
                              /*  Come here when we are done with the body    */
READ_DONE:
                                        /*  Close *BB                         */
        CALL M$CLOSE (FPT_CLOSE);
                                        /*  Link to SEND                      */
        CALL M$LINK (FPT_LINK);
                                        /*  Reset the prompt                  */
        FPT_PROMPT.PROMPT_=VECTOR(BBR_PROMPT);
        CALL M$PROMPT (FPT_PROMPT);
                    /*  SEND destroys the VM_HEADER segment, so make it again */
        VM_HEADER_INIT$.OFFSET=0;
        VM_HEADER_INIT$.SID=%DS2SID;
        CALL GET_SEG(VM_HEADER_,1024);
                         /*  Get the header for the message we were reading   */
        CALL GET_HEADER;
 
        RETURN;
 
                                   /*  Come here on an error reading M$UC     */
READ_ERR:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR#=%E$EOF THEN GOTO READ_DONE;
        CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR);
        FPT_PROMPT.PROMPT_=VECTOR(BBR_PROMPT);
        CALL M$PROMPT (FPT_PROMPT);
        RETURN;
 
END ANSWER_MESSAGE;
 
%EJECT;
/***********************************************************************
   SEND_MESSAGE calls send to send a message
***********************************************************************/
SEND_MESSAGE: PROC;
 
/*  Link to SEND.:SYS  */
%FPT_LINK (CMD=CMD_BUF, STCLASS=CONSTANT,
           NAME=SEND_NAME,
           ACCT=SEND_ACCT);
 
%VLP_NAME (FPTN=CMD_BUF, LEN=256);
 
%VLP_NAME (FPTN=SEND_NAME, STCLASS=CONSTANT, NAME='SEND');
 
%VLP_ACCT (FPTN=SEND_ACCT, STCLASS=CONSTANT, ACCT=':SYS');
 
DCL CURRENT_LINE CHAR(P_PCB.NCHARS) CALIGNED BASED (P_PCB.TEXT$);
 
/*  Formatter stuff  */
DCL LINK_ERR_FMT CHAR(0) CONSTANT INIT (' Error during M$LINK -');
 
/*
   SEND_MESSAGE starts here
*/
 
        CMD_BUF.NAME#=CURRENT_LINE;
        CMD_BUF.L#=P_PCB.NCHARS;
        CALL M$LINK (FPT_LINK) WHENALTRETURN
        DO;
           IF NOT (B$JIT.STEPCC = 4) THEN /* errored the job ?                */
           DO;
              CALL X$WRITE (BB_FDS,
                VECTOR (LINK_ERR_FMT));
              CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                B$TCB$->B$TCB.ALT$->B$ALT.DCB#);
              END;
           END;
 
                    /*  SEND destroys the VM_HEADER segment, so make it again */
        VM_HEADER_INIT$.OFFSET=0;
        VM_HEADER_INIT$.SID=%DS2SID;
        CALL GET_SEG(VM_HEADER_,1024);
        RETURN;
 
END SEND_MESSAGE;
 
%EJECT;
 
/***********************************************************************
   GET_SELECT gets the message selection criteria for LIST, ANSWER, etc.
***********************************************************************/
GET_SELECT: PROC (GPTR$);
 
/*
   Local data
*/
DCL GPTR$ PTR;
DCL GPTR1$ PTR;
DCL GPTR2$ PTR;
 
DCL INDX UBIN;
 
/*
   GET_SELECT starts here
*/
 
                                   /*  Loop for all the parser output blocks  */
        DO INDX = 0 TO GPTR$->P$B.NSUBLKS-1;
                                        /*  Point at the parser block         */
           GPTR1$=GPTR$->P$B.SUBLK$(INDX);
                                        /*  Figure out what we got            */
           DO CASE (GPTR1$->P$B.CODE);
 
                                        /*  Handle the NEW option             */
            CASE (%SEL_NEW);
              LOW_MESSAGE=BBRC_HIGH+1;
              HIGH_MESSAGE=BB_HIGH;
 
                                        /*  Handle the ALL option             */
            CASE (%SEL_ALL);
              LOW_MESSAGE=1;
              HIGH_MESSAGE=BB_HIGH;
 
                                        /*  Handle the range option           */
            CASE (%SEL_RANGE);
                                        /*  Get the first number of the range */
              CALL CHARBIN(LOW_MESSAGE, GPTR1$->P$B.SUBLK$(0)->P$S.TEXT);
              HIGH_MESSAGE=LOW_MESSAGE;
                                        /*  See if we really have a range     */
              IF GPTR1$->P$B.NSUBLKS > 1 THEN
              DO;
                 CALL CHARBIN(HIGH_MESSAGE,
                   GPTR1$->P$B.SUBLK$(1)->P$S.TEXT);
                 IF HIGH_MESSAGE > BB_HIGH THEN
                    HIGH_MESSAGE=BB_HIGH;
                 END;
 
            CASE (%SEL_FIRST);
              LOW_MESSAGE = 1;
              HIGH_MESSAGE = LOW_MESSAGE;
              IF GPTR1$->P$B.NSUBLKS > 0 THEN DO;
                 CALL CHARBIN( HIGH_MESSAGE,
                   GPTR1$->P$B.SUBLK$(0)->P$S.TEXT);
                 IF HIGH_MESSAGE > BB_HIGH THEN
                    HIGH_MESSAGE = BB_HIGH;
                 END;
 
            CASE (%SEL_LAST);
              HIGH_MESSAGE = BB_HIGH;
              LOW_MESSAGE = HIGH_MESSAGE;
              IF GPTR1$->P$B.NSUBLKS > 0 THEN DO;
                 CALL CHARBIN( LOW_MESSAGE,
                   GPTR1$->P$B.SUBLK$(0)->P$S.TEXT);
                 IF LOW_MESSAGE <= HIGH_MESSAGE THEN
                    LOW_MESSAGE = HIGH_MESSAGE - LOW_MESSAGE + 1;
                 ELSE
                    LOW_MESSAGE = 1;
                 END;
 
            CASE (%SEL_NEXT);
              LOW_MESSAGE = BBRC_HIGH + 1;
              HIGH_MESSAGE = LOW_MESSAGE;
              IF GPTR1$->P$B.NSUBLKS > 0 THEN DO;
                 CALL CHARBIN( HIGH_MESSAGE,
                   GPTR1$->P$B.SUBLK$(0)->P$S.TEXT);
                 HIGH_MESSAGE = HIGH_MESSAGE + LOW_MESSAGE - 1;
                 IF HIGH_MESSAGE > BB_HIGH THEN
                    HIGH_MESSAGE = BB_HIGH;
                 END;
 
            END;                        /* DO CASE ...                        */
 
           END;                         /* DO INDX ...                        */
 
                                        /*  Setup where to start              */
        START_MESSAGE=LOW_MESSAGE-1;
        RETURN;
 
END GET_SELECT;
 
%EJECT;
 
/***********************************************************************
   NEXT_CATALOG returns the next bulletin board name in CATALOGNAME.
   If INIT=%YES#, then CATALOGFID is used to get the account to search.
   NEXT_CATALOG ALTRETURNs if no more bulletin boards are found.
***********************************************************************/
NEXT_CATALOG: PROC (CATALOGFID,CATALOGNAME,INITIALIZE) ALTRET;
 
/*
   Local data
*/
%VLP_NAME (FPTN=CATALOGFID, LEN=31, STCLASS=" ");
%VLP_NAME (FPTN=CATALOGNAME, LEN=31, STCLASS=" ");
DCL INITIALIZE BIT(1);
 
/*
   FPTs
*/
%FPT_FID (ACCT=FIND_ACCT,
          NAME=FIND_NAME,
          PASS=FIND_PASS,
          SN=FIND_SN,
          ASN=FIND_ASN,
          RES=FIND_RES,
          RESULTS=VLR_FID);
 
%FPT_OPEN (FPTN=FIND_NEXT, STCLASS=STATIC,
           ASN=FILE,
           DCB=M$NEXT,
           NXTF=YES,
           TEST=YES,
           FUN=IN,
           THISF=NO,
           NAME=START_NAME,
           ACCT=FIND_ACCT);
 
%VLP_NAME (FPTN=START_NAME, STCLASS=CONSTANT,
           NAME=':MAIL_');
 
%VLP_ACCT (FPTN=FIND_ACCT, STCLASS=STATIC,
           ACCT=':MEETING');
 
%VLP_NAME (FPTN=FIND_NAME, LEN=31);
%VLP_PASS (FPTN=FIND_PASS);
%VLP_SN (FPTN=FIND_SN, N=1, SN='      ');
DCL FIND_ASN UBIN STATIC;
DCL FIND_RES CHAR(4) STATIC;
%VLR_FID;
DCL M$NEXT$ PTR;
DCL BAD_FID_FMT CHAR(0) CONSTANT
   INIT ('  Bad bulletin board account specified (%<>A)');
 
 
        M$NEXT$=DCBADDR(DCBNUM(M$NEXT));
                                        /*  Initialize things if we need to   */
        IF INITIALIZE THEN
        DO;
           FPT_FID.TEXTFID_=VECTOR(SUBSTR(CATALOGFID.NAME#,0,CATALOGFID.L#));
           CALL M$FID (FPT_FID) ALTRET (BAD_FID);
           IF NOT VLR_FID.ACCT THEN GOTO BAD_FID;
           FIND_NEXT.NAME_=VECTOR(START_NAME);
           END;
 
   /*  Find the next file name that begins with :MAIL_ and is not
       :MAIL_CENTRAL  */
SCAN:   DO WHILE '1'B;
           CALL M$OPEN (FIND_NEXT)
           WHENALTRETURN DO;
              IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.ERR# = %E$FDEOF
              THEN
                 EXIT SCAN;
              ELSE
                 GOTO END_LOOP;
              END;
           FIND_NEXT.NAME_=VECTOR(NIL);
           IF M$NEXT$->F$DCB.NAME#.L < 6 THEN ALTRETURN;
           IF SUBSTR(M$NEXT$->F$DCB.NAME#.C,0,6) ~= ':MAIL_' THEN EXIT SCAN;
           IF M$NEXT$->F$DCB.NAME#.L = 13 AND
             SUBSTR(M$NEXT$->F$DCB.NAME#.C,0,13) = ':MAIL_CENTRAL' THEN
              GOTO END_LOOP;
           CATALOGNAME.L#=M$NEXT$->F$DCB.NAME#.L-6;
           CATALOGNAME.NAME#=SUBSTR(M$NEXT$->F$DCB.NAME#.C,6,CATALOGNAME.L#);
           RETURN;
END_LOOP:
           END;
 
                                   /*  Come here when we are out of files     */
        ALTRETURN;
 
                              /*  Come here when the fid is bad (no .ACCT)    */
BAD_FID:
        CALL X$WRITE (BB_FDS,
          VECTOR (BAD_FID_FMT),
          VECTOR (SUBSTR(CATALOGFID.NAME#,0,CATALOGFID.L#)));
        ALTRETURN;
END NEXT_CATALOG;
 
%EJECT;
 
/***********************************************************************
   OPEN_BB opens the bboard in BBNAME, returning the highest message
   number in HIGH_MESS_NO.  OPEN_BB ALTRETURNs if an error occurs.
***********************************************************************/
OPEN_BB: PROC (BBNAME, HIGH_MESS_NO) ALTRET;
 
/*
   Local data
*/
%VLP_NAME (FPTN=BBNAME, STCLASS=" ", LEN=70);
DCL HIGH_MESS_NO UBIN;
 
/*  Parse a FID  */
%FPT_FID (ACCT=BBACCT,
          NAME=BBNAME_F,
          PASS=BBPASS,
          SN=BBSN,
          ASN=BBASN,
          RES=BBRES,
          RESULTS=VLR_FID);
 
%VLP_NAME (FPTN=BBNAME_F, LEN=31);
%VLR_FID;
 
/*  Open the bboard  */
%FPT_OPEN (ASN=FILE,
           DCB=M$DABBLE,
           FUN=IN,
           NAME=BBNAME_O,
           ACCT=BBACCT,
           ACS=DIRECT,
           SHARE=ALL,
           ORG=KEYED);
 
%VLP_NAME (FPTN=BBNAME_O, LEN=31);
%VLP_ACCT (FPTN=BBACCT, ACCT=':MEETING');
%VLP_PASS (FPTN=BBPASS);
%VLP_SN (FPTN=BBSN, N=1, SN='      ');
DCL BBASN UBIN STATIC;
DCL BBRES CHAR(4) STATIC;
 
/* Enqueue on the file resource, to avoid conflicts between BB, MAIL, and
   MAILMAN. */
%FPT_ENQ   (FPTN=ENQ_ON_FILE,
            STCLASS=CONSTANT,
            DCB=M$DABBLE,
            RNAME=VM_FILERES,
            SHARE=ALL,
            WAIT_TIME=0);
 
/* ENQ on the profile record. */
%FPT_ENQ   (FPTN=ENQ_ON_PROFILE,
            STCLASS=CONSTANT,
            DCB=M$DABBLE,
            RNAME=VM_PRORES,
            SHARE=NONE);
 
%FPT_DEQ   (FPTN=DEQ_ON_PROFILE,
            STCLASS=CONSTANT,
            DCB=M$DABBLE,
            RNAME=VM_PRORES);
 
/*  Read the profile record  */
%FPT_READ (DCB=M$DABBLE,
           KEY=VM_PROFILEKEY,
           KEYS=YES);
 
%VM_PROFILE;
%VM_PRORES (STCLASS=CONSTANT);
%VM_PRORES (NAME=VM_FILERES, STCLASS=CONSTANT, RES='FILE');
%VM_PROKEY (NAME=VM_PROFILEKEY, STCLASS=STATIC);
 
/*  Formatter stuff  */
DCL FID_ERR_FMT CHAR(0) CONSTANT INIT
                ('  Error parsing file specification for %<>A');
 
DCL READ_ERR_FMT CHAR(0) CONSTANT INIT ('  %<>A is not a bulletin board');
 
DCL OPEN_ERR_FMT CHAR(0) CONSTANT
     INIT ('  Error accessing bulletin board %<>A');
 
DCL BUSY_BB_FMT CHAR(0) CONSTANT
     INIT ('  Bulletin board %<>A is busy;  try again later.');
 
DCL BAD_NAME_FMT CHAR(0) CONSTANT INIT
        ('  Bulletin board names cannot be more than 25 characters long');
 
/*
   OPEN_BB starts here
*/
 
        OPEN_ERR = '0'B;
 
        CALL CLOSE_BB;
                                        /*  Parse the FID given               */
        FPT_FID.TEXTFID_=VECTOR(SUBSTR(BBNAME.NAME#,0,BBNAME.L#));
        CALL M$FID (FPT_FID) ALTRET (BAD_FID);
 
                    /*  If the name is too long, gripe.  Otherwise, fix it up */
        IF BBNAME_F.L# > 25 THEN GOTO BAD_NAME;
        CALL CONCAT(BBNAME_O.NAME#,
          ':MAIL_',
          SUBSTR(BBNAME_F.NAME#,0,BBNAME_F.L#));
        BBNAME_O.L#=BBNAME_F.L#+6;
 
                    /*  Default the account to :MEETING if none was specified */
        IF NOT VLR_FID.ACCT THEN
           BBACCT.ACCT#=':MEETING';
 
                                   /*  Use the password if it was specified   */
        IF VLR_FID.PASS THEN
           FPT_OPEN.PASS_=VECTOR(BBPASS);
        ELSE
           FPT_OPEN.PASS_=VECTOR(NIL);
 
                                        /*  Use the SN if it was specifed     */
        IF VLR_FID.SN THEN
           FPT_OPEN.SN_=VECTOR(BBSN);
        ELSE
           FPT_OPEN.SN_=VECTOR(NIL);
 
PERFORM_OPEN:
        CALL M$OPEN (FPT_OPEN) ALTRET (OPEN_ERR);
 
   /* Issue an M$ENQ on the 'FILE' resource, SHARE=IN.  If altret, someone
      is using MAIL to fiddle with the BB;  close and try again later. */
 
        CALL M$ENQ (ENQ_ON_FILE)
        WHENALTRETURN DO;
 
           CALL X$WRITE (BB_FDS,
             VECTOR(BUSY_BB_FMT),
             VECTOR(SUBSTR(BBNAME.NAME#,0,BBNAME.L#)));
 
           CALL CLOSE_BB;
 
           ALTRETURN;
 
           END;
 
   /*  ENQ on the profile record before reading it - avoid obscure race
       conditions */
 
        CALL M$ENQ (ENQ_ON_PROFILE);
 
                                        /*  Read the profile record           */
        FPT_READ.BUF_=VM_PROFILE_;
        CALL M$READ (FPT_READ) ALTRET (READ_ERR);
 
                                        /*  Dequeue from the profile record   */
        CALL M$DEQ (DEQ_ON_PROFILE);
 
                              /*  Get the highest message number and return   */
        BB_OPEN=%YES#;
        HIGH_MESS_NO=VM_PROFILE.HI_MESSAGE_NUMBER;
                                   /*  Get REPLY-TO: for Moderator, if any    */
        MODERATOR.L# = 0;
        IF VM_PROFILE.REPLY_TO$ ~= ADDR(NIL) THEN DO;
           MODERATOR$ = VM_PROFILE.REPLY_TO$;
           IF MODERATOR_TEST.SEGID ~= %DS3SID THEN
              EXIT;
           IF MODERATOR$->X$STRING.SIZ <= 31
           THEN MODERATOR = MODERATOR$->X$STRING;
           END;
        RETURN;
 
                                        /*  Come here when M$FID ALTRETs      */
BAD_FID:
        CALL X$WRITE (BB_FDS,
          VECTOR(FID_ERR_FMT),
          VECTOR(SUBSTR(BBNAME.NAME#,0,BBNAME.L#)));
        CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR);
        ALTRETURN;
 
                    /*  Come here when the file name is > 25 characters long  */
BAD_NAME:
        CALL X$WRITE (BB_FDS,
          VECTOR(BAD_NAME_FMT));
        ALTRETURN;
 
                                        /*  Come here when M$OPEN ALTRETs     */
OPEN_ERR:
 
        OPEN_ERR = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
 
        IF OPEN_ERR.ERR# = %E$NOFILE
          AND NOT VLR_FID.ACCT
          AND BBACCT.ACCT# = ':MEETING'
        THEN DO;
 
           BBACCT.ACCT# = ':REVIEWS';
           GOTO PERFORM_OPEN;
 
           END;
 
        CALL X$WRITE (BB_FDS,
          VECTOR(OPEN_ERR_FMT),
          VECTOR(SUBSTR(BBNAME.NAME#,0,BBNAME.L#)));
        CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DABBLE));
        ALTRETURN;
 
                                        /*  Come here when M$READ ALTRETs     */
READ_ERR:
        CALL X$WRITE (BB_FDS,
          VECTOR(READ_ERR_FMT),
          VECTOR(SUBSTR(BBNAME.NAME#,0,BBNAME.L#)));
        CALL M$DEQ (DEQ_ON_PROFILE);
        ALTRETURN;
 
END OPEN_BB;
 
%EJECT;
 
/***********************************************************************
   GET_HEADER gets the header for the message in CUR_MESSAGE.  It
   ALTRETURNs if an error occurs.
***********************************************************************/
GET_HEADER: PROC ALTRET;
 
/*
   Local data
*/
 
/*  Read the header for a message  */
%FPT_READ (DCB=M$DABBLE,
           KEY=VM_HEADERKEY,
           KEYS=YES);
 
%VM_HEADER;
%VM_INFOKEY (NAME=VM_HEADERKEY, TYP=%VM_TYPE_HEAD);
 
/* ENQ on the header after reading it, to ensure that MAILMAN has finished
   delivering the message contents. */
%FPT_ENQ   (FPTN=ENQ_ON_HEADER,
            STCLASS=CONSTANT,
            DCB=M$DABBLE,
            RNAME=VM_HEADRES,
            SHARE=NONE);
 
%FPT_DEQ   (FPTN=DEQ_ON_HEADER,
            STCLASS=CONSTANT,
            DCB=M$DABBLE,
            RNAME=VM_HEADRES);
 
%VM_HEADRES;
 
/*
   GET_HEADER starts here
*/
 
                                        /*  Set up the key                    */
        VM_HEADERKEY.MESSAGE_NUMBER=CUR_MESSAGE;
        FPT_READ.BUF_=VM_HEADER_;
                                        /*  Read the header                   */
        CALL M$READ (FPT_READ) ALTRET (NO_MESSAGE);
                         /*  Use M$ENQ to ensure that delivery is complete.   */
        VM_HEADRES.RES# = CUR_MESSAGE;
        CALL M$ENQ (ENQ_ON_HEADER);
        CALL M$DEQ (DEQ_ON_HEADER);
 
        CALL CORRECT_PTR (VM_HEADER.BLIND$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.COPY$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.FILE_FOLDER$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.FROM$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.REFERENCE$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.REPLY_TO$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.RETURN_ADDRESS$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.SIGNED$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.SUBJECT$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.TO$, VM_HEADER);
        CALL CORRECT_PTR (VM_HEADER.BAD_ADDRESS$, VM_HEADER);
 
        RETURN;
 
                         /*  Come here if we get an error reading the header  */
NO_MESSAGE:
        ALTRETURN;
 
CORRECT_PTR: PROC (POINTER, BASE_LOCATION);
 
DCL 1 POINTER ALIGNED,
      2 OFFSET UBIN (18) HALIGNED,
      2 * BIT (18);
DCL POINTER$ REDEF POINTER PTR;
DCL BASE_LOCATION BIT (36);
 
        IF POINTER$ ~= ADDR(NIL)
        THEN
           POINTER$ = PINCRW(ADDR(BASE_LOCATION), POINTER.OFFSET);
 
        RETURN;
 
END CORRECT_PTR;
 
END GET_HEADER;
 
%EJECT;
 
 
/***********************************************************************
   GET_BODY gets the body record REC for the message in CUR_MESSAGE,
   returning the record in VM_BODYREC and the byte count in COUNT,
   and the DCB's DVBYTE in DVBYTE.
***********************************************************************/
GET_BODY: PROC (REC,VM_BODYREC,COUNT,DVBYTE) ALTRET;
 
/*
   Local data
*/
DCL REC UBIN;
%VM_BODYREC (STCLASS=" ");
DCL COUNT UBIN;
DCL DVBYTE BIT(8);
 
/*  Read a body record  */
%FPT_READ (DCB=M$DABBLE,
           KEY=VM_BODYKEY,
           KEYS=YES);
 
%VM_BODYKEY;
 
DCL ERROR_FMT CHAR(0) STATIC INIT ('  Error reading body record %D');
 
/*
   GET_BODY starts here
*/
 
                                        /* Set up the key                     */
        VM_BODYKEY.MESSAGE_NUMBER=CUR_MESSAGE;
        VM_BODYKEY.REC_NUMBER=REC;
                                        /*  Read the body record              */
        FPT_READ.BUF_=VECTOR(VM_BODYREC);
        CALL M$READ(FPT_READ) ALTRET (OOPS);
               /*  Make COUNT the number of bytes of body data in the record  */
        COUNT=DCBADDR(DCBNUM(M$DABBLE))->F$DCB.ARS#-
          (LENGTHC(VM_BODYREC) - LENGTHC(VM_BODYREC.VALUE.DATA));
        DVBYTE=DCBADDR(DCBNUM(M$DABBLE))->F$DCB.DVBYTE;
        RETURN;
 
                              /*  Come here if we can't read the body record  */
OOPS:
        CALL X$WRITE (BB_FDS,
          VECTOR(ERROR_FMT),
          VECTOR(REC));
        CALL ERRMSG(B$TCB$->B$TCB.ALT$->B$ALT.ERR);
        ALTRETURN;
 
END GET_BODY;
 
%EJECT;
 
/***********************************************************************
   CLOSE_BB closes the bboard.
***********************************************************************/
CLOSE_BB: PROC;
 
/*
   Local data
*/
%FPT_CLOSE (DCB=M$DABBLE, STCLASS=CONSTANT, DISP=SAVE);
 
/*
   CLOSE_BB starts here
*/
        IF DCBADDR(DCBNUM(M$DABBLE))->F$DCB.FCD# THEN
           CALL M$CLOSE (FPT_CLOSE) ALTRET (IGNORE);
 
                                        /*  Ignore ALTRETs on the close       */
IGNORE:
        BB_OPEN=%NO#;
        RETURN;
 
END CLOSE_BB;
 
%EJECT;
 
/***********************************************************************
   GET_SEG gets the segment that VECTOR_ points to of size SIZE
***********************************************************************/
GET_SEG:PROC (VECTOR_, SIZE);
 
/*
   Local data
*/
%VLP_VECTOR (FPTN=VECTOR_, STCLASS=" ");
DCL SIZE SBIN WORD;
 
%FPT_GDS;
 
/*
   GET_SEG starts here
*/
 
                                        /*  Set up the FPT                    */
        FPT_GDS.V.SEGSIZE#=SIZE;
        FPT_GDS.RESULTS_=VECTOR(VECTOR_);
        CALL M$GDS (FPT_GDS) ALTRET (OOPS);
        RETURN;
 
                                   /*  Come here if we can't get the segment  */
OOPS:
        CALL M$MERC;
 
END GET_SEG;
 
%EJECT;
 
/***********************************************************************
   OPEN_BBRC opens :DABBLE with FUN=F.  If it doesn't exit, it
   will be created.
***********************************************************************/
OPEN_BBRC: PROC(F) ALTRET;
 
/*
   Local Data
*/
DCL F UBIN;
DCL I UBIN;
 
/*  Open :DABBLE  */
%FPT_OPEN (DCB=M$DABBLERC,
           FUN=UPDATE,
           ASN=FILE,
           ACS=DIRECT,
           ORG=KEYED,
           ACCT=BBRC_ACCT);
 
%VLP_NAME (FPTN=BBRC_NAME, STCLASS=CONSTANT, NAME=':DABBLE');
%VLP_NAME (FPTN=BBRC_CUST, STCLASS=STATIC, LEN=31);
 
%VLP_ACCT (FPTN=BBRC_ACCT);
/*  Assume ZZZCUST mode */
%FPT_CMDVAR (FUN=FETCH,
             NAME=MODE_NAME,
             VALUE=MODE_VALUE);
 
%VLP_NAME (FPTN=MODE_NAME, STCLASS=CONSTANT, NAME='DABBLE_X_UNIQUE');
%VLP_NAME (FPTN=MODE_VALUE, LEN=31);
 
DCL NO_CREATE_FMT CHAR(0) CONSTANT INIT ('  Unable to open/create dabble file');
 
 
 
                                        /*  If it's already open, close it    */
        IF DCBADDR(DCBNUM(M$DABBLERC))->F$DCB.FCD# THEN
           CALL CLOSE_BBRC;
 
                                        /* Set up the name.                   */
 
        CALL M$CMDVAR (FPT_CMDVAR)
        WHENRETURN DO;
           IF Substr(MODE_VALUE.NAME#,0,1) = 'Y'
             | Substr(MODE_VALUE.NAME#,0,1) = 'y'
           THEN GOTO Act_Like_ZZZCUST;
           END;
        IF B$JIT.ACCN = 'ZZZCUST'
        THEN DO;
 
Act_Like_ZZZCUST:
           CALL CONCAT (BBRC_CUST.NAME#, ':DABBLE_', B$JIT.UNAME);
           CALL INDEX (I, ' ', BBRC_CUST.NAME#);
           BBRC_CUST.L# = I;
           FPT_OPEN.NAME_ = VECTOR (BBRC_CUST);
 
           END;
 
        ELSE
           FPT_OPEN.NAME_ = VECTOR (BBRC_NAME);
 
                                        /*  Setup the account for :DABBLE     */
        BBRC_ACCT.ACCT#=B$JIT.ACCN;
 
                                        /*  Setup the FUN of the open fpt     */
        FPT_OPEN.V.FUN#=F;
 
                                        /*  try to open :DABBLE               */
        CALL M$OPEN (FPT_OPEN) ALTRET (OOPS);
        RETURN;
 
/*  Come here if we can't open the file  */
OOPS:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# = %E$NOFILE THEN
        DO;
           FPT_OPEN.V.FUN#=%CREATE#;
           CALL M$OPEN (FPT_OPEN) ALTRET (OOPS1);
           CALL CLOSE_BBRC;
           FPT_OPEN.V.FUN#=F;
           CALL M$OPEN (FPT_OPEN) ALTRET (OOPS1);
           RETURN;
           END;
 
/*  Come here if we can't create the file  */
OOPS1:
        CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DABBLERC));
        CALL X$WRITE (BB_FDS,
          VECTOR (NO_CREATE_FMT));
        ALTRETURN;
 
END OPEN_BBRC;
 
%EJECT;
 
/***********************************************************************
   GET_BBRC gets the :DABBLE record for BBNAME and returns the data in
   HIGH_MESS_NO.
***********************************************************************/
GET_BBRC: PROC (BBNAME, HIGH_MESS_NO) ALTRET;
 
/*
   Local data
*/
%VLP_NAME (FPTN=BBNAME, STCLASS=" ", LEN=31);
DCL HIGH_MESS_NO UBIN;
 
/*  Read :DABBLE  */
%FPT_READ (DCB=M$DABBLERC, STCLASS=CONSTANT,
           BUF=RD_BFR,
           KEY=BBKEY,
           KEYS=YES);
 
DCL RD_BFR UBIN STATIC;
 
%VLP_NAME (FPTN=BBKEY, LEN=31);
 
DCL FUN UBIN;
 
 
                                   /*  Open the file if it's not already open */
        IF NOT DCBADDR(DCBNUM(M$DABBLERC))->F$DCB.FCD# THEN
        DO;
           FUN=%UPDATE#;
           CALL OPEN_BBRC (FUN) ALTRET (GIVE_UP);
           END;
 
                                        /*  Setup the key                     */
        BBKEY=BBNAME;
 
                                        /*  Read the record                   */
        CALL M$READ (FPT_READ) ALTRET (NO_REC);
 
                                        /*  Return the data in HIGH_MESS_NO   */
        HIGH_MESS_NO=RD_BFR;
        RETURN;
 
                         /*  Come here if no record exists for this bboard    */
NO_REC:
        HIGH_MESS_NO=0;
        RETURN;
 
/*  Come here if we can't open :DABBLE  */
GIVE_UP:
        ALTRETURN;
 
END GET_BBRC;
 
%EJECT;
 
/***********************************************************************
   GET_BBRC_SEQ reads the next record from :DABBLE.
***********************************************************************/
GET_BBRC_SEQ: PROC (BBNAME, HIGH_MESS_NO) ALTRET;
 
/*
   Local data
*/
%VLP_NAME (FPTN=BBNAME, STCLASS=" ", LEN=31);
DCL HIGH_MESS_NO UBIN;
 
/*  Read :DABBLE  */
%FPT_READ (DCB=M$DABBLERC, STCLASS=CONSTANT,
           BUF=RD_BFR,
           KEY=BBKEY,
           KEYR=YES);
 
DCL RD_BFR UBIN STATIC;
 
%VLP_NAME (FPTN=BBKEY, LEN=31);
 
DCL FUN UBIN;
 
%FPT_PFIL (DCB=M$DABBLERC,
           BOF=YES);
 
 
                                   /*  Open the file if it's not already open */
        IF NOT DCBADDR(DCBNUM(M$DABBLERC))->F$DCB.FCD# THEN
        DO;
           FUN=%UPDATE#;
           CALL OPEN_BBRC (FUN) ALTRET (GIVE_UP);
           CALL M$PFIL (FPT_PFIL);
           END;
 
                                        /*  Read the record                   */
        CALL M$READ (FPT_READ) ALTRET (NO_REC);
 
                                        /*  Return the key in BBNAME          */
        BBNAME=BBKEY;
 
                                        /*  Return the data in HIGH_MESS_NO   */
        HIGH_MESS_NO=RD_BFR;
        RETURN;
 
/*  Come here on a read error  */
NO_REC:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# = %E$EOF THEN
           ALTRETURN;
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# = %E$LD AND BBKEY = ATTACH_KEY THEN
           ALTRETURN;
        CALL ERRMSG (B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DABBLERC));
        ALTRETURN;
 
/*  Come here if we can't open :DABBLE  */
GIVE_UP:
        ALTRETURN;
 
END GET_BBRC_SEQ;
 
%EJECT;
 
/***********************************************************************
   PUT_BBRC writes the record for bboard BBNAME with data HIGH_MESS_NO
***********************************************************************/
PUT_BBRC: PROC (BBNAME,HIGH_MESS_NO) ALTRET;
 
/*
   Local data
*/
%VLP_NAME (FPTN=BBNAME, STCLASS=" ", LEN=31);
DCL HIGH_MESS_NO UBIN;
 
/*  Write :DABBLE  */
%FPT_WRITE (DCB=M$DABBLERC, STCLASS=CONSTANT,
            BUF=WR_BFR,
            KEY=BBKEY);
 
DCL WR_BFR UBIN STATIC;
 
%VLP_NAME (FPTN=BBKEY, LEN=31);
 
DCL FUN UBIN;
 
 
                                   /*  Open the file if it's not already open */
        IF NOT DCBADDR(DCBNUM(M$DABBLERC))->F$DCB.FCD# THEN
        DO;
           FUN=%UPDATE#;
           CALL OPEN_BBRC (FUN) ALTRET (GIVE_UP);
           END;
 
                                        /*  Set up the key                    */
        BBKEY=BBNAME;
 
        WR_BFR=HIGH_MESS_NO;
                                        /* Write the record                   */
        CALL M$WRITE (FPT_WRITE) ALTRET (OOPS);
        WRITE_BBRC=%NO#;
        RETURN;
 
/*  Come here if the write fails  */
OOPS:
        CALL ERRMSG(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DABBLERC));
 
/*  Come here if we can't open :DABBLE  */
GIVE_UP:
        WRITE_BBRC=%NO#;
        ALTRETURN;
 
END PUT_BBRC;
 
%EJECT;
 
/***********************************************************************
   DEL_BBRC deletes the specified key from the :DABBLE file
***********************************************************************/
DEL_BBRC: PROC (BBNAME) ALTRET;
 
/*
   Local data
*/
%VLP_NAME (FPTN=BBNAME, STCLASS=" ", LEN=31);
 
/*  Delrec :DABBLE  */
%FPT_DELREC (DCB=M$DABBLERC, STCLASS=CONSTANT,
            KEY=BBKEY);
 
%VLP_NAME (FPTN=BBKEY, LEN=31);
 
DCL FUN UBIN;
 
 
                                   /*  Open the file if it's not already open */
        IF NOT DCBADDR(DCBNUM(M$DABBLERC))->F$DCB.FCD# THEN
        DO;
           FUN=%UPDATE#;
           CALL OPEN_BBRC (FUN) ALTRET (GIVE_UP);
           END;
 
                                        /*  Set up the key                    */
        BBKEY=BBNAME;
 
                                        /* Delete the record                  */
        CALL M$DELREC (FPT_DELREC) ALTRET (OOPS);
        RETURN;
 
/*  Come here if the delrec fails  */
OOPS:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOKEY THEN
           CALL ERRMSG(B$TCB$->B$TCB.ALT$->B$ALT.ERR,DCBNUM(M$DABBLERC));
        ALTRETURN;
 
/*  Come here if we can't open :DABBLE  */
GIVE_UP:
        ALTRETURN;
 
END DEL_BBRC;
 
%EJECT;
 
/***********************************************************************
   CLOSE_BBRC closes the :DABBLE file
***********************************************************************/
CLOSE_BBRC: PROC;
 
/*
   Local data
*/
%FPT_CLOSE (DCB=M$DABBLERC, STCLASS=CONSTANT, DISP=SAVE);
 
/*
   CLOSE_BBRC starts here
*/
        IF DCBADDR(DCBNUM(M$DABBLERC))->F$DCB.FCD# THEN
           CALL M$CLOSE (FPT_CLOSE);
        RETURN;
 
END CLOSE_BBRC;
 
/**********************************************************************/
GETCMD: PROC (COMMANDS, OUT$, PROMPT_, TEXT, TSIZE) ALTRET;
 
DCL COMMANDS UBIN WORD;
DCL OUT$ PTR;
DCL ERR REDEF OUT$ BIT (36);
DCL PROMPT_ VECTOR;
DCL TEXT CHAR (TSIZE);
DCL TSIZE UBIN;
 
        XUG_GETCMD.NODES$ = ADDR(COMMANDS);
        XUG_GETCMD.PROMPT_ = PROMPT_;
 
        IF ADDR(TEXT) = ADDR(NIL)
        THEN
           XUG_GETCMD.TEXT_ = VECTOR(NIL);
        ELSE
           XUG_GETCMD.TEXT_ = VECTOR(TEXT);
 
        CALL XUG$GETCMD (XUG_GETCMD)
        WHENALTRETURN DO;
           ERR = XUG_GETCMD.ERR#;
           ALTRETURN;
           END;
 
        OUT$ = XUG_GETCMD.OUT$;
        RETURN;
 
END GETCMD;
 
ERRPTR: PROC (EPOS, DCB#);
 
DCL EPOS UBIN;
DCL DCB# UBIN;
 
        IF ADDR(EPOS) = ADDR(NIL)
        THEN
           XUG_GETCMD.USE_EPOS# = %NO#;
        ELSE DO;
           XUG_GETCMD.USE_EPOS# = %YES#;
           XUG_GETCMD.EPOS# = EPOS;
           END;
 
        IF ADDR(DCB#) = ADDR(NIL)
        THEN
           XUG_GETCMD.DCB_PARAM# = DCBNUM(NIL);
        ELSE
           XUG_GETCMD.DCB_PARAM# = DCB#;
 
        CALL XUG$ERRPTR (XUG_GETCMD);
 
        RETURN;
 
END ERRPTR;
 
ERRMSG: PROC (CODE, DCB#, OUTDCB) ALTRET;
 
DCL CODE BIT (36);
DCL DCB# UBIN;
DCL OUTDCB UBIN;
 
        IF ADDR(CODE) = ADDR(NIL)
        THEN
           XUG_GETCMD.ERR_CODE = '0'B;
        ELSE
           XUG_GETCMD.ERR_CODE = CODE;
 
        IF ADDR(DCB#) = ADDR(NIL)
        THEN
           XUG_GETCMD.ERRDCB# = DCBNUM(NIL);
        ELSE
           XUG_GETCMD.ERRDCB# = DCB#;
 
        IF ADDR(OUTDCB) = ADDR(NIL)
        THEN
           XUG_GETCMD.DCB_PARAM# = DCBNUM(NIL);
        ELSE
           XUG_GETCMD.DCB_PARAM# = OUTDCB;
 
        CALL XUG$ERRMSG (XUG_GETCMD)
        WHENALTRETURN DO;
           ALTRETURN;
           END;
 
        RETURN;
 
END ERRMSG;
 
SETERRMSG: PROC (FID) ALTRET;
 
%VLP_NAME (FPTN=FID, STCLASS=PARAM);
 
        XUG_GETCMD.ERRMFID$ = ADDR(FID);
 
        CALL XUG$SETERRMSG (XUG_GETCMD)
        WHENALTRETURN DO;
           ALTRETURN;
           END;
 
        RETURN;
 
END SETERRMSG;
 
END DABBLE;
 
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
/***********************************************************************
   BBR_ABORT Handles breaks.
***********************************************************************/
BBR_ABORT: PROC;
 
DCL ABORT_REMEMBER REMEMBER SYMREF;
DCL CMD_SIZE UBIN SYMREF;
 
        CMD_SIZE = 0;
        UNWIND TO ABORT_REMEMBER;
 
END BBR_ABORT;
 
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
/***********************************************************************
   BBR_XCON Handles exit control.
***********************************************************************/
BBR_XCON: PROC ASYNC;
 
%INCLUDE CP_6;
%F$DCB;
%B$TCB;
%B$ALT;
%B$EXCFR;
%INCLUDE XUG_ENTRY;
%INCLUDE XU_MACRO_C;
 
%FPT_TRMCTL (TRMCTL=SET_PAGE);
%VLP_TRMCTL (FPTN=SET_PAGE, STCLASS="EXT");
 
%FPT_ALIB (DLIB=YES,
           LIBNAME=VLP_NAME,
           CMD=DELTA_CMD,
           RETRN=YES);
DCL DELTA_CMD CHAR(45) STATIC
        INIT ('SC BB;DI B$TCB$->B$TCB.STK$->B$EXCFR.IC\R');
%VLP_NAME (NAME='DELTA');
 
%XUG_GETCMD (NAME=XUG_GETCMD, STCLASS=SYMREF);
 
DCL B$TCB$ PTR SYMREF;
 
DCL M$LO DCB;
 
%FPT_CLOSE (DCB=M$LO, DISP=SAVE);
 
DCL EXIT_REMEMBER REMEMBER SYMREF;
 
                                        /*  See if we got an error            */
        IF B$TCB$->B$TCB.STK$->B$EXCFR.ERR.ERR# = 0
        THEN DO;
 
           CALL M$CLRSTK;
           UNWIND TO EXIT_REMEMBER;
 
           END;
 
                                        /*  Close M$LO                        */
        IF DCBADDR(DCBNUM(M$LO))->F$DCB.FCD# THEN
           CALL M$CLOSE (FPT_CLOSE);
                                        /*  Reset the terminal stuff          */
        CALL M$STRMCTL (FPT_TRMCTL);
 
                                        /*  Print the error message           */
        XUG_GETCMD.ERR_CODE = B$TCB$->B$TCB.STK$->B$EXCFR.ERR;
        XUG_GETCMD.ERRDCB# = B$TCB$->B$TCB.STK$->B$EXCFR.DCB#;
        XUG_GETCMD.DCB_PARAM# = DCBNUM(NIL);
        CALL XUG$ERRMSG (XUG_GETCMD);
   /*  Call DELTA to tell how we got here
   CALL M$ALIB (FPT_ALIB);                 */
        CALL M$EXIT;
 
END BBR_XCON;
