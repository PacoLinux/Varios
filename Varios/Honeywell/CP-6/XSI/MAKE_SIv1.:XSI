\*{*M*  MAKE:cap    --    Manual for MAKE                         *}
\*{****************************************************************}
\*{**                                                            **}
\*{** Copyright (c) Bull HN Information Systems Inc., 1989       **}
\*{**                                                            **}
\*{****************************************************************}
\DS\MAKE{\TT{MAKE}}
\DS\Makefile{\IT{Makefile}}
\DS\CPSIX{\IT{CP-6}}
\DS\UNIX{\TT{UNIX}\FN{TR}\TT{UNIX} is a trademark of \TT{AT&T}.\FN}
\DS\IBEX{\TT{IBEX}\IX{\TT{IBEX}}}
\TP{CP-6 MAKE
     |
     | Bruce Frost
     | August 1, 1990
     | Bull HN Information Systems Inc., 1990}
 
\TOC
\CH{About this Manual||FRONT}   \HH{ABOUT_MAKE}
 
The \MAKE\ program is a \SL{case} tool that is used to maintain,
update and reproduce files whose base components have been
modified.
 
 
Computer programs are developed by combining a large number of
smaller source programs into a single large run-unit because
smaller programs are easier to develop and maintain.  Often these
pieces require different transformations or even simply different
options to produce the derived file (a derived file can be viewed
as an object unit, library or run-unit because it is produced by
a program that takes a different kind of input file and
produces a new file).  The resulting derived file often needs
more transformations, such as combining various object files to
produce a run-unit.
 
When a large system is being developed, many files
can be modified by a developers, or a single change to an
include file may invalidate the compilation of many modules.
 
\MAKE\ determines which pieces
of a large system need to be recreated by running the correct
\CPSIX\ \IBEX\ commands.  This manual uses C, \TT{PL6} and Fortran
programs to demonstrate the use of \MAKE, but \MAKE\ may be used with
any program that produces an output file that must be kept current
with its corresponding input file(s).
 
In order to use \MAKE, a file known as a \Makefile\ is
created which describes the relationships among the various
files and contains the commands required for creating the output
files (where \MAKE\ cannot infer the commands from the file type).
 
When a suitable \Makefile\ exists, the most up to date target files
can be created simply by using the command:
{
\FIF
\INL{5}
 
\TT{!MAKE.X -f}\IT{Makefile}
 
}
\IX{\TT{-f}}\IX{\Makefile\ option}\IX{file option}
\MAKE\ uses the \IT{Makefile} and the last modification
times of the various files to determine which of
the target files need to be recreated.  For each of those files
it runs a batch job to create it.
 
Invocation options can be used to control
the various phases of producing the targets including debugging
a \IT{Makefile}.
 
\CPSIX\ \MAKE\ provides a number of significant extensions beyond
the capabilities provided by other similar programs.
These extensions include:
 
\PL{BU}
\PI  building multiple targets in parallel using simultaneous
     batch jobs.  This significantly reduces the time
     required to produce the final target file.
 
\PI  additional built-in implicit rules for the
     following \CPSIX\ processors: \TT{PL6}, \TT{PARTRGE},
     \TT{BMAP}, \TT{LINK}, \TT{TEX} and \TT{HERMAN}.
 
\PI  looking for \CPSIX\ update files.
 
\PI  search paths for files in \TT{SI}, \TT{UI}, \TT{OU}, and \TT{GN}
     accounts.
 
\PI  a fake target ``\TT{.PHONY}'' whose dependents are not
     actual files.
 
\PI  a fake target ``\TT{.ONLINE}'' whose dependents are run in
     the same session as \MAKE.
 
\PI  support for \SL{diagnostic output} and
     \SL{listing output}.
 
\PI  the ability to indicate the source file type used to produce
     a target.
 
\PI  a command line option ``\TT{-c}'' which
     treats the following target as if it is out of date.
 
\PI  a command line option ``\TT{-o}'' which
     treats the following target as if it is up to date.
 
\PI  a command line option ``\TT{-a}'' to list the actions
     required to produce the target(s).
 
\PI  a command line option ``\TT{-w}'' to set the output width.
 
\PI  a command line option ``\TT{-j}'' to control the number
     of running batch jobs.
 
\PI  a command line option ``\TT{-u}'' which controls selecting
     update files based upon their access controls.
 
\PI  a command to indicate the electronic mail address of the owner
     of a file.
 
\PI  a command line option ``\TT{-e}'' to control sending
     electronic mail to owners when an error occurs.
 
\PI  directives to conditionally select portions of the \Makefile.
 
\PI  a directive to include other \Makefile's.
 
\PI  directives to display messages to the \MAKE\ user.
\PL
 
 
\SB{HELP}
For more information on \MAKE, try  \TT{!HELP (MAKE.X) TOPICS}.
The manual is the best way to learn how to use this tool.
To get one at \TT{LADC} (at other sites a \TT{TEX} \TT{dvi}
file print program and a laser printer must be available),
print the \TT{MAKE_dvi} file on the laser printer using \TT{DVILG}
with the following command:
{\TT\FIF
 
!dvilg MAKE_dvi.:XSI over LZ@UPSTAIRS (FORM=QMSCAP,DEV=800)
}
 
\SB{}
This manual is organized in the following manner:
 
\PL{BU}
\PI Section 1 presents a simple example of the use of \MAKE\ in a
tutorial style.
 
\PI Section 2 is an overview of \Makefile\ contents and requirements.
 
\PI Section 3 describes the rule section of a \Makefile.
 
\PI Section 4 describes how to write \Makefile\ commands
for building targets.
 
\PI Section 5 describes how to use and define variables.
 
\PI Section 6 describes how to invoke the \MAKE\ processor.
 
\PI Section 7 describes how to write new or replace built-in
implicit rules.
 
\PI Section 8 describes how to use electronic mail with \MAKE.
 
\PI Section 9 describes conditional inclusion of \Makefile
     records, include files and displaying messages.
 
\PI Section 10 describes the differences between \CPSIX\ \MAKE\ and
the \UNIX\ \TT{make} utility.
 
\PL
\SB
 
\CH{Example Use of MAKE|1|SE}   \HH{Examples}
 
In the following example,
a simple \Makefile\ is created for a hypothetical
program which uses Fortran and C include files and source files.
It consists of six C sources, one Fortran source and 3 header
(or include) files.
 
The first step in producing this program with \MAKE\ is to build
a \Makefile\ that shows how to compile and link the program.
All of the C source files include the file ``\TT{vars:h}'',
three include the file ``\TT{targets:h}'' and
four include the file ``\TT{tables:h}''.
 
To make the program, each source file must be recompiled
if  it has been changed,
if one of its include files has changed,
or if the object unit does not exist.
Finally, the program must be relinked if any of the object units
is newer than the current version of the program or if the program
does not exist.
 
\SB{HELP}  The following example shows
\SB{}      Figure 1--1 contains
\SB
a \Makefile\ that describes the above dependencies and
shows how to compile and link the program.
\IX{\Makefile}
\FG{Program example||COMPRFLOAT}       \INL{1}
!B Makefile
EDIT E00 here
    1.000 program :  main.o macros.o commands.o read.o symbols.o \\
    2.000            build.o files.o derive.o
    3.000   link main.o,macros.o,commands.o,read.o,symbols.o, \\
    4.000           build.o,files.o,derive.o over program
    5.000
    6.000 main.o     :  main.c    vars.h
    7.000   CC main.c over main.o (NLS)
    8.000
    9.000 macros.o   :  macros.c     vars.h targets.h
   10.000   CC macros.c over macros.o (NLS)
   11.000
   12.000 commands.o : commands.c vars.h targets.h
   13.000   CC commands.c over commands.o (NLS)
   14.000
   15.000 read.o     : read.c  vars.h commands.c
   16.000   CC read.c over read.o (NLS)
   17.000
   18.000 symbols.o  :  symbols.c  vars.h tables.h
   19.000   CC symbols.c over symbols.o (NLS)
   20.000
   21.000 build.o    :  build.c  vars.h tables.h
   22.000   CC build.c over build.o (NLS)
   23.000
   24.000 files.o    :  files.c   vars.h tables.h targets.h
   25.000   CC files.c over files.o (NLS)
   26.000
   27.000 derive.o   :  derive.f
   28.000   FORTRAN derive.c over derive.o (NLS)
   29.000
\FG
Notice that long lines were split into two lines using the backslash
character to terminate a line.  \MAKE\ sees these lines as a single
long line but it is easier to edit and read two shorter lines.
\IX{continuation}\IX{backslash}
 
In \MAKE\ terms, each file that is generated by a program
(that is to say, a non-source file)
is the \IT{``target''} of a \IT{``rule''.}
\IX{target}
\IX{rules}
In the preceding example, the targets are the individual object
files such as \TT{main.o}, \TT{macros.o}, etc., and the final target
\TT{program}.
Targets always appear at the beginning of a line before the colon.
After the colon, the target's \SL{``dependencies''} are listed;
\IX{dependencies}
that is, all of the files that are used as input when the target
file is updated.
\IX{dependencies}
A target file will need to be recompiled or relinked (or whatever)
if any of its dependent files are modified.
In addition, any dependent files that are themselves generated files
will be updated if its dependencies have been modified before
this step is invoked.
 
By default, \MAKE\ starts with the first rule that it finds within
a \Makefile\ (excluding rules whose target names begin with a ``.'').
This is known as the default \IT{``goal''}. \IX{Goals}
In the preceding \Makefile,  the target \TT{program} is the default
goal.  The other rules in the \Makefile\ are used because they
appear as dependencies of the goal.
 
After each line containing a target and associated dependencies,
the \Makefile\ contains zero or more lines of \IBEX\ commands
\IX{commands}
that indicate how to recreate the target file.
These lines start with one or more blanks to tell \MAKE\ that
they are in fact commands.
\MAKE\ does not know anything about how the commands actually
produce the target file, it is up to the writer of the \Makefile\ to
supply commands that will create the file correctly.
All that \MAKE\ does is execute the commands in the \Makefile\ in
the correct order when the target file needs to be created.
 
\L0{How Make Processes This Makefile} \HH{Makefile Processing}
\IX{processing a \Makefile}
 
After reading the entire makefile, \MAKE\ starts the real work by
processing the first rule,
the rule for relinking ``\TT{program}''.
Before that rule can be fully processed, it sees that it must
process the rules for the files that \TT{program} depends upon.
Each of the object files is processed at this point, according to
their own rules.
These rules show that the object file is recreated by compiling
its source file.
Each compilation must be done if the source file or any include
(header) file named as a dependency has been modified since the
object file was last created (or if the object file does not exist).
 
Before compiling a source file, \MAKE\ also looks for rules for
creating the source or include files.  Since this \Makefile\ does
not have any rules for them (there are no ``\TT{.c}'' and ``\TT{.h}''
\IX{\TT{.c}}\IX{\TT{.h}}
files that are targets of any rules), nothing needs to be done,
but automatically generated source files such as those made by
\TT{BISON.X}, would be updated by their own rules at this point.
 
After recompiling the object files which were out of date, \MAKE\ can
then decide whether to relink \TT{program}.
This will be done if the file \TT{program} does not exist, or if
any of the object files were more recent than it.
If any object files were just recompiled, they would be more recent,
so \TT{program} would be relinked.
 
\L0{Variables Can Make Makefiles More Simple} \HH{VARIABLE_EXAMPLE}
\IX{variables}
 
\SB{HELP}
In the \TT{HELP~TOPIC} ``\TT{EXAMPLES}'',
\SB{}
In the preceding example,
\SB
the object files were listed
twice in the rule for \TT{program}, the first time to show the
dependencies and the second to show the link command.
This duplication is extremely error prone; for example, if a new
object file is added to the program, it may be added to one list and
not both.
This risk can be eliminated and the \Makefile\ can be simplified
by using a variable.
Variables are used to define a text string once and have it
substituted in (possibly) multiple places later.
\SB{HELP}
(see topic \TT{VARIABLES}).
\SB{}
(See section 5: ``Variables'' for more information).
\SB
 
It is standard practice to have a \Makefile\ variable named
\TT{objects}, \TT{OBJECTS}, \TT{objs}, \TT{OBJS}, \TT{obj} or
\TT{OBJ} which is simply a list of all of the object file names.
Such a variable is defined in a \Makefile\ in the following manner:
{\TT\FIF\INL{10}
 
objects = main.o macros.o commands.o read.o symbols.o \\
          build.o files.o derive.o
 
}
Thereafter, if the same list of names is required, the \Makefile\ may
simply reference the variable \TT{objects} with the string
``\TT{$(objects)}''.  This is how the rule for \TT{program} would
look as a result of this change:
{\TT\FIF\INL{10}
 
program    : $(objects)
  link $(objects) over program
 
}
 
\L0{Letting MAKE Infer the Commands}  \HH{IMPLICIT_RULE_EXAMPLE}
 
It is not necessary to write the commands for compiling individual
C (or Fortran) source files as long as a consistent naming convention
is used which indicates the type of source file
\SB{HELP}
(see topic \TT{IMPLICIT_RULES}),
\SB{}
(see section 7, ``Implicit Rules''),
\SB
or each output file type has as an explicit dependency the
type of file used to produce it
\SB{HELP}
(see topic \TT{SOURCE_FILE_TYPING}).
\SB{}
(see section 3, ``Specifying Source File Type'').
\SB
\MAKE\ has built-in rules for producing object files corresponding
to C, Fortran, Pascal, \TT{PL6}, \TT{PARTRGE} and \TT{BMAP} source
files.
For example, it will
use the command ``\TT{CC main:c over main:o}'' to compile \TT{main.c}
into \TT{main.o}.
Therefore, the commands could be omitted from the rules for the
object files.
 
When a ``\TT{.c}'' file is used implicitly,the source file becomes
\IX{\TT{.c}}
an automatic dependency and is added to the list of dependencies.
Therefore, the ``\TT{.c}'' files (and ``\TT{.f}'' files) should
be omitted from the list of explicit dependencies.
 
At this point, the \Makefile{}
\SB{HELP}
created for \TT{HELP} \TT{TOPIC} ``\TT{EXAMPLES}'' is shown
\SB{}
in the figure 1--1 is shown in figure 1--2 ``Implicit Rule Example''
\SB
with the changes that could be made to this
point.
 
\FG{Implicit Rule Example||COMPRFLOAT}       \INL{1}
!B Makefile
EDIT E00 here
    1.000 objects = main.o macros.o commands.o read.o symbols.o \\
    1.000           build.o files.o derive.o
    3.000
    4.000 program      :  $(objects)
    5.000     link $(objects) over program
    6.000
    7.000 main.o       :  vars.h
    8.000 macros.o     :  vars.h targets.h
    9.000 commands.o   :  vars.h targets.h
   10.000 read.o       :  vars.h tables.h
   11.000 symbols.o    :  vars.h tables.h
   12.000 build.o      :  vars.h tables.h
   13.000 files.o      :  vars.h targets.h tables.h
   14.000
\FG
 
 
\L0{ Another Style of Makefile}       \HH{||X}
 
Since the rules for the object files specify only dependencies,
the preceding \Makefile\ could be written by combining dependencies
instead of targets.  This would produce a \Makefile\ like
\SB{HELP}  this:
\SB{}      Figure 1--3.
\SB
 
\FG{Alternate Makefile Style Example||COMPRFLOAT}       \INL{1}
!B Makefile
EDIT E00 here
    1.000 objects = main.o macros.o commands.o read.o symbols.o \\
    1.000           build.o files.o derive.o
    3.000
    4.000 program      :  $(objects)
    5.000     link $(objects) over program
    6.000
    7.000 $(objects)                        : vars.h
    8.000 macros.o commands.o files.o       : targets.h
    9.000 read.o symbols.o build.o files.o  : tables.h
   10.000
\FG
 
Here \TT{defs.h} is given as a dependency for producing all of the
object files;
\TT{commands.h} and \TT{buffer.h} are dependencies of the specific
object files listed for them.
 
Whether this is better is a matter of taste --  it is definitely more
compact, but some people would dislike it because it can be
clearer to put all the information about a particular target in
one place.
 
\L0{Sample Runs}                      \HH{Example runs}
 
Now it is time to show a complete example of \MAKE.
In order to keep the size of this example as small as possible,
a new program is going to be shown.
In this example, the default goal will be a run-unit called
\TT{RU} which is made up of two Fortran sources called \TT{MAIN.f}
and \TT{SUBR.f}.
\SB{HELP} The following sample \CPSIX\ session
\SB{}     Figure 1--4 ``Debug Output Example''
\SB
shows the \Makefile\ being
created and the \MAKE\ program run with the ``\SL{debug}'' and
``\SL{no-op}'' options (\TT{-d} and \TT{-n} respectively).
\IX{\TT{-d}}\IX{\TT{-n}}\IX{debug option}\IX{no-op}
\IX{\TT{$@}}
 
\FG{Debug Output Example||COMPRFLOAT}       \INL{1}
!b MakeRU
EDIT E00 here
    1.000 OBJS    =  MAIN.o SUBR.o
    2.000
    3.000 RU   :  $(OBJS)
    4.000   LINK $(OBJS) over $@
    6.000
!MAKE. -dnfMakeRU
 No Errors and No Warnings in Makefile
### MAKE: Target is "RU"
 
  *Deriving: MAIN.o RU
File: MAIN:o does not exist.
File: MAIN:f.MYACCT modified Mon May  8 15:36:43 1989
 
  *Deriving: SUBR.o RU
File: SUBR:o does not exist.
File: SUBR:f.MYACCT modified Mon May  8 15:36:49 1989
 
  *Deriving: RU
File: RU does not exist.
 
*  Dependency wait=3, Waiting to run=0, Running=0, Errored=0, Completed=0
*  Ready to run: MAIN.o SUBR.o
!FORTRAN MAIN:f.MYACCT over MAIN:o,NO
!FORTRAN SUBR:f.MYACCT over SUBR:o,NO
 
*  Ready to run: RU
*  Dependency wait=0, Waiting to run=1, Running=0, Errored=0, Completed=2
!LINK MAIN:o,SUBR:o over RU
 
*  Dependency wait=0, Waiting to run=0, Running=0, Errored=0, Completed=3
***
*** Build Complete!
***
\FG
 
If the ``\TT{-n}'' (\SL{no-op}) option had not been specified,
\IX{no-op}\IX{\TT{-n}}
\MAKE\ would have  run three batch jobs,
\PL{BL}
\PI the first job
would have compiled the \TT{MAIN} program,
\PI the second would
have compiled the \TT{SUBR} program (note that both of these
compilations would have taken place simultaneously),
\PI and finally \MAKE\ would have linked the final run unit with
the third batch job.
\PL
 
The output of the ``\TT{-d}'' option shows the steps that \MAKE\ uses
to generate the final \SL{goal} ``\TT{RU}''.
The first item of debug output is the line containing the
path to the target being derived ``\TT{*Deriving~MAIN.o~RU}''.
The line following this shows the current status of the target
file (in this case \TT{MAIN:o}).  When the target file exists,
its modification time is displayed.
The next line contains the input file used to produce this target
and its modification time (in this case \TT{MAIN:f}).
When the ``\TT{-v}'' option is specified in conjunction with
the ``\TT{-d}'' option, \MAKE\ displays the names of the implicit
rules that are tried while locating the input file.
Similar output appears for each of the targets that will be built
when trying to produce the goal(s).
 
\HH{||B}
\SB{HELP} The following example
\SB{}     Figure 1--5 ``No-Op Execution Example''
\SB
uses \MAKE\ without a \Makefile.
In this mode,
\MAKE\ tries to find a method to build the specified target using
only built-in rules.
Since no dependencies can be specified without a \Makefile,
only one file will be input to the final target.
This simple example uses a Fortran program
called \TT{main.f} which is compiled and linked to produce
the run-unit \TT{main}.
In order to use \MAKE\ in this simple case,
the only command line option necessary is the target name.
 
This command uses the ``\TT{-n}'' option to display the commands
\IX{no-op}\IX{\TT{-n}}
that will be executed before  running the batch job.
 
 
\FG{No-Op Execution Example||COMPRFLOAT}       \INL{1}
!b main:f
EDIT E00 here
    1.000            print *, 'Hello, world!'
    2.000            end
    3.000
!MAKE. main -n
 
*  Dependency wait=1, Waiting to run=0, Running=0, Errored=0, Completed=0
*  Ready to run: main.o
 
!FORTRAN main:f.MYACCT over main:o.MYACCT,NO
!LINK main:o.MYACCT over main.MYACCT
 
 
***
*** Build Complete!
***
\FG
 
Notice that the build commands show a Fortran compilation
followed by linking the object unit created by this compilation.
These commands would be run in one batch job.
\MAKE\ chose to use the Fortran compiler because the source file
used the default naming convention for Fortran source.
 
\IX{batch}
\SB{HELP} The following example
\SB{}     Figure 1--6 ``Sample \MAKE\ Execution''
\SB
runs \MAKE, which batches a job
named \TT{main} and issues the commands seen in the previous
example.
After creating the \TT{main} run-unit,
the program is run producing its output message ``\TT{Hello,~world!}''.
It should be noted that if the \MAKE\ program were immediately
re-run,
without modifying the file \TT{main:f},
the batch job would not be run because the \TT{main} run-unit
would be found to be up to date.
 
\FG{Sample MAKE Execution||COMPRFLOAT}       \INL{1}
!MAKE. main
 
*  Dependency wait=1, Waiting to run=0, Running=0, Errored=0, Completed=0
*  Ready to run: main.o
76597 main.MYACCT running 0:00/1:59
 
*  Dependency wait=0, Waiting to run=0, Running=1, Errored=0, Completed=0
 
***
*** Build Complete!
***
76597 main.MYACCT completed successfully at 23:28 06/11/89
!main.
 
Hello, world!
 *STOP*
!
\FG
 
 
 
 
\CH{Makefiles||SE}            \HH{Makefiles}
\IX{\Makefile}
\MAKE\ operates using the following sources of information:
\PL{BL}
\PI command line options,
\PI the \TT{MAKEFLGS} \TT{IBEX} variable,      \IX{\TT{MAKEFLGS}}
\PI a \Makefile\ database,
\PI files and their
last modification time from the file system,
\PI a number of built-in rules and variables to produce targets
not explicitly built.
\PL
 
\SB{HELP}
This topic
\SB{}
This section
\SB
introduces major components of the \Makefile\ database
file including the basic record types.
 
\L0{General Makefile Information}     \HH{General Information||S}
 
A \Makefile\ is a standard \CPSIX\ file possibly created by using
the \TT{EDIT}, \TT{6EDIT} or \TT{PULSE} editors and contains
a description of the relationships between the files of the system
being built.
The relationships include such things as the names of generated
files and the names of files used as input to the program
that produces them.
 
Individual records in the \Makefile\ may be of any length
although in practice it is best to break long lines into shorter
lines using a ``\TT{\\}'' character to end the line to be
continued.  Entirely blank lines in the \Makefile\ are treated as
comments as are lines beginning with the ``\TT{#}'' character.
\IX{comments}
 
\L0{Makefiles Contents}           \HH{Makefile contents||S}
 
\Makefile{}s\ contain five kinds of information: \IT{rules},
\IT{variable definitions}, \IT{directives}, \IT{ownership}
\IT{designations} and \IT{comments}.
\IX{rules}
\IX{variables}
\IX{directives}
\IX{comments}
 
\PL{BU}
\PI  A \IT{rule} says when and how to recreate one or more files
which are known as the rule's \IT{targets}. \IX{target} It lists the
other files that the targets depend upon, and may also provide
commands to use to create the target (See
\SB{HELP}
topic \TT{WRITING_RULES}).
\SB{}
section 3, ``Writing Rules'').
\SB
 
\PI  A \IT{Variable Definition} is a line that specifies a text
string value for a \IT{variable} that can be used to substitute
the string later in the \Makefile.  The simple \Makefile\ example in
\SB{HELP}
topic \TT{VARIABLE_EXAMPLE}
\SB{}
section 1 (``Variables Can Make Makefiles More Simple'')
\SB
used a variable called ``\TT{objects}'' as a
list of all of the object files
\SB{HELP}
(see topic \TT{VARIBLES}).
\SB{}
(See section 5, ``Variables'').
\SB
 
\PI An \IT{Ownership designation} indicates the electronic mail
address of the person (or persons) responsible for a list of
target files
\SB{HELP} (see topic \TT{EMAIL}).
\SB{} (see section 8, ``Using Electronic Mail'').
\SB
 
\PI  \IT{Directives} are used to:
     include other \Makefile{}s;
     conditionally select \Makefile\/ commands;
     or to display messages to the \MAKE\ user
\SB{HELP}  (See topic: DIRECTIVES).
\SB{}      (See section 9: ``Directives'').
\SB
 
 
\PI  A ``\TT{#}'' in a line of a \Makefile\ starts a comment.
It and the rest of the line are ignored.
\PL
 
\L0{Naming Makefiles}     \HH{Naming Makefiles||S}
 
Unlike other \MAKE\ programs, \CPSIX\ \MAKE\ requires that the
\Makefile\ name be specified if it is to be used.
It is a good idea to name \Makefile{}s
with appropriate names such as \TT{Makefile} or \TT{MakeRU} where
``\TT{RU}'' is the name of the default goal of the \Makefile.
 
The name of the \Makefile\ is provided to \MAKE\ by using the
\TT{-f} option.  The name of the file must immediately follow
the ``\TT{-f}'' with no intervening blanks.
\IX{\TT{-f}}\IX{\Makefile\ option}\IX{file option}
 
\L0{Avoiding Makefiles}     \HH{Omitting Makefiles||S}
 
A \Makefile\ may not be necessary to use \MAKE\ when there is only
a single file with no dependencies to be built using
the built-in implicit rules.
In this case,
simply invoke \MAKE\ with the name of the target file to be
produced.
If the file naming convention needs to be changed from the
built-in convention, or if the
built-in compiler options need to be changed,
both can be modified either by specifying the variable values on
the invocation line or by using \IBEX\ variables (see
\SB{HELP} topic \TT{ASSIGNMENT}).
\SB{} section 5, ``Assigning Values'').
\SB
 
\CH{Writing Rules||SE}                \HH{Writing Rules}
 
\IT{Rules} \IX{rules} appear in the \Makefile\ and indicate when and
how to recreate target files.
Each rule lists the other files that are required to be current
when the target(s) are created (known as \IT{dependencies}), and
are immediately followed by the \IT{commands}\ used to create
the target. \IX{dependencies}  \IX{Goals} \IX{commands}
 
The order of rules in a \Makefile\ are not significant, except
for the rule known as the \IT{default goal}  \IX{default goal}
which is the target \MAKE\ uses when a target is not explicitly
indicated.
The \IT{default goal}\ is the first rule whose target does not
begin with a period.
Traditionally, the default goal is normally the rule which
causes the entire program or all of the programs described by the
\Makefile\ to be created.
 
\L0{Rule Syntax}                      \HH{Rule Syntax||S}
 
In general, a rule has the following syntax:
{\FIF\IT\INL{10}
 
targets    :     dependencies
     command
     command
     ~~~\vdots
 
}
The \IT{targets} \IX{target}
are make file names, separated by spaces or by commas.
Usually there is only one target for each rule, but
in some cases more than one may be specified, particularly
where a single command generates
multiple files.
Dependencies are optional in rule definitions.
 
The command lines begin with at least one leading blank.  The
first command must appear on the line immediately following
the rule to which it is attached.  Blank lines in commands are not
permitted
\SB{HELP}
(see topic \TT{WRITING_COMMANDS} for more information).
\SB{}
(for more information see section 4, ``Writing Commands'').
\SB
 
Long lines may be split by terminating a line with a backslash
``\TT{\\}''  \IX{backslash} \IX{continuation}
but this is not required. There is no limit on the
length of a non-command line.
Command lines are limited to 256 characters as required by
\IBEX.
 
Rules are used to indicate two things:  first it tells \MAKE\ how
to determine if a target is out of date, and secondly, it
tells \MAKE\ how to create the file when it is out of date.
The criterion for being out of date is specified in terms of the
file's dependencies, which consist of make file names separated by
spaces or commas (for information on how make file names are mapped
into \CPSIX\ file names see
\SB{HELP}
topic \TT{CP6_FILENAMES}).
\SB{}
section 3, ``Make Filenames and \CPSIX\ Filenames'').
\SB
The basic concept is that the contents of the target file depends
only upon the contents of the specified dependent files, so
when one of the dependent files has been modified, \MAKE\ knows
that it is time to recreate the target file.
 
\L0{Make Filenames and CP-6 Filenames}\HH{CP6 Filenames|FILENAMES}
 
\MAKE\ filenames consist of two parts. \IX{filenames} \IX{suffix}
The first part is the base file name and the second part is a
suffix, which is used by \MAKE\ to determine the type of the file.
\MAKE\ needs to know the type of the file when it does not have
explicit rules for creating a target file.
In order to infer the file type, \MAKE\ requires the use of a
file naming convention to  help it recognize the type of
the file.
\MAKE\ never looks at the contents of a file, it only looks at the
file name, the rules which have been provided for creating
file names from file types
and the names of the files which actually exist.
 
By default, \MAKE\ knows about a number of file types
\SB{HELP}
(see topic \TT{BUILT_IN_RULES}).
\SB{}
(See section 7 ``Catalogue of Built-In Implicit Rules'').
\SB
\MAKE\ constructs a \CPSIX\ filename from the base file name and
suffix by using the variable definition with the same name as
the suffix (including the leading ``\TT{.}'').
So, for example, there is a variable ``\TT{.c}'' whose value is
\IX{\TT{.c}}
used to create the real \CPSIX\ filename for a make file name
such as ``\TT{blotto.c}''.
The default value of the ``\TT{.c}'' variable is ``\TT{:c}''
which would produce the \CPSIX\ file name ``\TT{blotto:c}'' when the
name ``\TT{blotto.c}'' is found in the \Makefile.
 
The actual rules for producing the \CPSIX\ file name from the
value of the variable is as follows:
 
\PL{BU}
\PI  If the value of the variable contains no ``\TT{?}'' characters,
     the \CPSIX\ file name is produced by appending the value of the
     variable to the base file name.
 
\PI  If the value of the variable contains a ``\TT{?}'' but it does
     not contain any ``\TT{*}'' characters,
     the \CPSIX\ file name is produced by replacing the ``\TT{?}''
     in the variable value with the base file name.
 
\PI  Finally, if the variable value contains both a ``\TT{?}'' and
     a ``\TT{*}'' character,
     then:
 
\PL{NU}
\PI  Each ``\TT{*}'' must be followed by a single digit that
     indicates the number of characters to remove from the base
     file name.  Each ``\TT{*}'' before the  ``\TT{?}'' removes
     characters from the beginning of the base file name and each
     ``\TT{*}'' after the ``\TT{?}'' removes characters from the
     end of the base file name.
 
\PI  Any characters in the base file name that were not used up by
     the ``\TT{*}'' rules replace the ``\TT{?}''.
 
\PL
\PL
 
The following examples show the use of some common variable
definitions for certain \CPSIX\ file types.
{\TT\INL{10}\FIF
 
.6      =  :6
.lib    =  :LIB_?
.help   =  HELP:?:
 
}
\IX{\TT{.6}}\IX{\TT{.help}}
The first variable definition in the preceding example is used
as the default for \TT{PL6} source files.  That is, the default naming
convention for \TT{PL6} files is to append ``\TT{:6}'' to the end of
the base file name.
For example, if the \Makefile\ referenced a file such as
\TT{pl6subr.6},
then this macro causes its \CPSIX\ file name to be
\TT{pl6subr:6}.
 
The second macro could be used to name \TT{LEMUR} libraries.
If the \Makefile\ referenced a library such as \TT{SYSTEM.lib},
then this variable definition would cause its \CPSIX\ file name
to become \TT{:LIB_SYSTEM}.
 
Finally, the third macro transforms a \Makefile\ file name
such as ``\TT{MAKE.help}'' into the \CPSIX\ file name
``\TT{HELP:MAKE:}''.
 
\L1{Default File Types}               \HH{File Types}
\MAKE\ provides a number of built-in file types that are associated
with its built-in rules.
The following table shows these file types, their implied meaning
and their default variable value.
 
\IX{file types}
\TB{Default File Types}
\TH{File Type \TC Variable Value \TC Meaning}
 
\TT{.c}       \TC   \TT{:c}           \TC \TT{CC} source file      \TX
\TT{.6}       \TC   \TT{:6}           \TC \TT{PL6} source file     \TX
\TT{.a}       \TC   \TT{:a}           \TC \TT{BMAP} source file    \TX
\TT{.y}       \TC   \TT{:y}           \TC \TT{YACC} source file    \TX
\TT{.l}       \TC   \TT{:l}           \TC \TT{LEX}  source file    \TX
\TT{.f}       \TC   \TT{:f}           \TC \TT{FORTRAN} source file \TX
\TT{.n}       \TC   \TT{:n}           \TC \TT{PARTRGE} source file \TX
\TT{.p}       \TC   \TT{:p}           \TC \TT{PASCAL} source file  \TX
\TT{.h}       \TC   \TT{:h}           \TC Include   source file    \TX
\TT{.o}       \TC   \TT{:o}           \TC Object file              \TX
\TT{.r}       \TC   \TT{~ }           \TC Run unit                 \TX
\TT{.herman}  \TC   \TT{:herman}      \TC \TT{HERMAN} source file  \TX
\TT{.help}    \TC   \TT{HELP:?:}      \TC \CPSIX\ Help  file       \TX
\TT{.tex}     \TC   \TT{:tex}         \TC \TT{TEX}    source file  \TX
\TT{.dvi}     \TC   \TT{:dvi}         \TC \TT{TEX} output    file  \TX
\TT{.web}     \TC   \TT{:web}         \TC Web source file          \TX
\TT{.cap}     \TC   \TT{:cap}         \TC \TT{CAPTEX} source file  \TX
\TT{.makefile}\TC   \TT{Make?}        \TC \TT{MAKE} file           \TX
\TT{.depends} \TC   \TT{:depends}     \TC \TT{MIDGET} dependencies \TX
\TT{DOPATH}   \TC   \TT{:do}          \TC \SL{diagnostic output}   \TX
\TT{LOPATH}   \TC   \TT{NO}           \TC \SL{listing output}      \TX
\TB
\IX{\TT{DOPATH}}\IX{\TT{LOPATH}}\IX{\TT{.r}}\IX{\TT{.o}}\IX{\TT{.h}}
\IX{\TT{.n}}\IX{\TT{.f}}\IX{\TT{.l}}\IX{\TT{.y}}\IX{\TT{.p}}
\IX{\TT{.a}}\IX{\TT{.6}}\IX{\TT{.c}}\IX{\TT{.cap}}\IX{\TT{.dvi}}
\IX{\TT{.web}}\IX{\TT{.herman}}\IX{\TT{.help}}\IX{\TT{.tex}}
\IX{\TT{YACC}}\IX{\TT{LEX}}\IX{\TT{PARTRGE}}\IX{\TT{BMAP}}
\IX{\TT{PASCAL}}\IX{\TT{FORTRAN}}\IX{\TT{TEX}}\IX{\TT{HERMAN}}
\IX{diagnostic output}
\IX{listing output}
 
In this table the two variables \TT{DOPATH} and \TT{LOPATH} are
special in that they are not true file suffixes and their
interpretation is slightly more robust.
These two variables are used as the patterns for generating the
diagnostic output and the compiler listings associated with the
target.
These patterns are not applied to the base file names, instead
they are applied to the full target name with the ``.'' characters
in the target name transformed into ``\TT{:}''.
The command line option ``\TT{-k}'' may be used to limit the
application of these patterns to the base target name.
Note that they may take on the value of a \CPSIX\ device which is
not treated as a target suffix.  Notice that the default value
for the listing output is the \TT{NO} output device (also known as
the old bit bucket).
 
From the previous table, it can be seen that there is actually
a file type associated with run-units although all of the examples
have not shown the file type in the \Makefile.
This is because when \MAKE\ finds a target name without a file type,
it gives the target an implicit file type of ``\TT{.r}''.
\IX{\TT{.r}}
This means that although the goal of your \Makefile\ may
appear as the program \TT{MUNGER}, its \CPSIX\ file name is
generated using the value of the variable ``\TT{.r}''.
If the suffix ``\TT{.r}'' is used, it must be used consistently --
it must always be specified or never specified within the
\Makefile\ or \MAKE\ will be unable to resolve one of the references.
\IX{implicit file type}
 
\L0{Searching Accounts for Files}     \HH{File_Searching|Search_accounts}
 
When working with large systems and multiple programmers, it is
often desirable to manage files in separate directories.
For example, the system may be integrated at certain predetermined
intervals to produce new ``controlled'' versions, which are not
modified until the next integration.
As work continues on the system, new sources, updates, objects and
run-units are generated by individual members who work with
the most recently controlled versions of the files, plus any
changes that they are making.
When it is time to make a new version of the controlled sources,
the new updates are used to produce a new working system.
 
\CPSIX\ \MAKE\ may be used in this environment by defining
a number of variables which indicate the \CPSIX\ directories
to search (and the order to search them)
when locating the target and dependent files.
The following table shows the macros which must be defined.
 
\IX{\TT{SIPATH}}\IX{\TT{OUPATH}}\IX{\TT{GNPATH}}\IX{\TT{UIPATH}}
\IX{\TT{SPATHS}}
\TB{Make Search List Variables|||2}
\TH{Variable \TC Meaning}
\TT{SIPATH}   \TC   A list of accounts to search for source files \TX
\TT{OUPATH}   \TC   A list of accounts to search for object files \TX
\TT{GNPATH}   \TC   A list of accounts to search for run-units    \TX
\TT{UIPATH}   \TC   A list of accounts to search for updates      \TX
\TT{SPATHS}   \TC   A list of variables containing search paths  \TX
\TB
 
Each of these variables must contain a list of \CPSIX\ accounts
separated by blanks.  The first account in which the file is found
becomes the version of the file \MAKE\ uses.
The variable ``\TT{SPATHS}'' is handled special.
Instead of containing a list of accounts, it contains a list
of variables which in turn contain the accounts to search.
There is a maximum of six additional search lists which may be
defined in this way.
 
The search list is only used if the rule for producing the
file name adds an account specification and that specification is
the first account in one of the search list variables.
The way \MAKE\ uses the search lists is:
 
\PL{BU}
\PI  \MAKE\ tries to open the file as indicated by the default
     rule for creating the \CPSIX\ file name.  If the file is found,
     no further action is taken.
 
\PI  \MAKE\ then looks at the \CPSIX\ file identifier that was
     generated by the rule.  If it has an account specification and
     that account is the same as one of the accounts in the search
     list, the remaining accounts in the matching search list are
     examined for the file.  The first account in which the file is
     found is used.
\PL
 
Updates will only be searched for if there is both an \TT{SIPATH}
(which may consist of only one account), a non-empty \TT{UIPATH}
value and the account in the file name that was found matches
the very first account in \TT{SIPATH}.
Therefore, the update file must have the same name as the source
file, but be in a different account.
 
Additionally, there are two additional rules associated with
using this mode of operation.
Certain files such as include or header files are strictly source
files, but may have updates to them.
For the purposes of \MAKE, files found in the \TT{SI} account and
have no rules to produce them, but
which other files depend upon, are moved into the \TT{OU} account.
By default,
this is done using either a \TT{PCL} copy command or by using the
tool \TT{FORMAT.X} if there are updates.
The actual commands used to create the files in the \TT{OU}
account may be controlled by modifying the special fake targets
\TT{.copy} and \TT{.fmt}.
\IX{\TT{.copy}}\IX{\TT{.fmt}}
 
Target files are produced in either the first account mentioned
in the \TT{OUPATH} variable or in the first account mentioned
in the \TT{GNPATH} variable, as indicated by the search list used
to locate the file.
Therefore, when an out-of-date file is found in the \TT{OUPATH} or
\TT{GNPATH}, \MAKE\ recreates the file in the very first account
mentioned in the appropriate search path.
 
\L1{Search Account Example}           \HH{Example||S}
 
The following example is how a large project with multiple developers
would use this search capability.
Assume for the purposes of this example that the development
accounts are as follows:
 
\PL{BL}
\PI The controlled accounts are for the ``\TT{F0}'' version of
the ``\TT{XYZ}'' family.
These accounts are:
source files are in \TT{XYZF0SI},
most recently integrated updates to source files are in \TT{XYZF0UI},
most recently integrated object unit files are in \TT{XYZF0OU},
and most recently integrated run unit files are in \TT{XYZF0GN}.
 
\PI As the developers work on their changes, they make their own
source updates in the \TT{XYZF0TUI} account, putting their
latest generated files in the \TT{XYZDVOU} and \TT{XYZDVGN}
accounts.
 
\PL
 
Assuming that the sources are all C sources and use the default
``\TT{:c}'' suffix,
here are the lines that would be necessary to add to the
\Makefile:
 
 
\FG{Search Account Example||COMPRFLOAT}       \INL{1}
SIPATH  =  .XYZF0SI
OUPATH  =  .XYZDVOU  .XYZF0OU
GNPATH  =  .XYZDVGN  .XYZF0GN
UIPATH  =  .XYZF0TUI .XYZF0UI
 
.c      =  :c.XYZF0SI
.o      =  :o.XYZDVOU
.r      =  .XYZDVGN
\FG
 
\IX{\TT{.c}}\IX{\TT{.o}}\IX{\TT{.r}}
\L0{Phony Targets}                    \HH{Phony_Targets}
 
 
A phony target is one that is not really the name of a file.
It is only a name for some commands to be executed when
this target is explicitly requested.
 
If a rule is written whose commands do not create the target file,
the commands will be executed every time the target must be
remade.  Here is an example:
{\TT\FIF\INL{10}
 
clean   :
  -del ?:o
 
}
Because the \TT{delete} command does not create a file named
``\TT{clean}'', no such file will ever exist and \MAKE\ will
be confused and think that the target rule failed when this
rule is run.
 
If the fake target is created by mistake, this command will then
fail to work because the file would be considered up to date since
it has no dependencies.
To avoid this problem,
a target can be explicitly declared to be phony by using the
special target \TT{.PHONY} and making \TT{clean} dependent upon
it as follows:
{\TT\FIF\INL{10}
 
.PHONY     : clean
 
}
\IX{\TT{.PHONY}}\IX{phony targets}\IX{fake targets}
Once this is done, \MAKE\ will run the commands regardless of whether
there is a file named ``\TT{clean}''.
 
A phony target should not be a dependency of a real target file;
otherwise, strange things will result.
Phony targets can have dependencies.
When a \Makefile\ is used to create multiple programs, it is most
convenient to use a phony target to create all of the programs.
This phony target is usually called \TT{all} and it has as
dependencies the individual programs which must be made.
For example:
 
\FG{Phony Target Example||FLOATING}       \INL{1}
all     :  prog1 prog2 prog3
.PHONY  :  all
 
prog1   :  prog1.o  utils.o
  link prog1.o,utils.o over prog1
 
prog2   :  prog2.o  utils.o
  link prog2.o,utils.o over prog2
 
prog3   :  prog3.o sort.o utils.o
  link prog3.o,utils.o,sort.o over prog3
\FG
 
Now \MAKE\ will remake all three programs simply by specifying
the name of the \Makefile.
Individual programs can be made by explicitly specifying the
target as in ``\TT{make -f\Makefile{} prog2}''.
 
\L0{Using Target Files to Record Events}\HH{||X}
 
Occasionally it is necessary to know which dependency files
have changed when executing the commands associated with a rule.
This is done using the ``\TT{$?}'' automatic variable
\IX{\TT{$?}|||@$?}
and a target file.
In some cases, it may not be necessary for the target file to
contain information, the rule simply creates an empty target
file whose only purpose is to contain a modification date
used to indicate which dependency files had changed since the
last time this command had been run.
 
Commands using the ``\TT{$?}'' variable must have some dependencies
(or the variable value is emtpy).
For example,
if you wanted to print the changed source files only after they
are working correctly,
the following commands could be used:
 
{\TT\FIF\INL{10}
 
make_listing  :  a.c b.c c.c
  -copy $(?: =,) to LP(K)
  -copy NO over $@
 
}
If \MAKE\ is invoked with ``\TT{make_listing}'' as one of its goals,
a \TT{PCL} copy command will copy the source files ``\TT{a.c}'',
``\TT{b.c}'' or ``\TT{c.c}'' to the line printer only if the
source file has been modified since the file ``\TT{make_listing}''
was last modified.
 
\L0{Specifying Source File Type}      \HH{Source File Typing}
 
By default \MAKE\ will locate the correct source file used to
generate a target file if no rules are specified by scanning
through all of the implicit rules that can generate the
required target file type.
This is the simplest mode to use and is preferred when a consistent
file naming convention has been used.
When a consistent naming convention has not been used,
\MAKE\ can be directed to use a particular input file type by
adding a dependency upon the input file type on the target file
type.
For example,
if the pattern for generating a Partrge file name is the
same as the pattern for generating a \TT{PL6} file name,
then \MAKE\ will always find the source file and treat it
as \TT{PL6} source.
In order to force \MAKE\ to treat it as a Partrge source,
the \Makefile\ must provide a dependency upon ``\TT{.n}'' for
the object unit created by Partrge.
\IX{\TT{.n}}
Therefore, if the object unit is \TT{nodes.o} then the following
\Makefile\ line will indicate to \MAKE\ that it should try to
generate this file with the ``\TT{.n.o}'' rule:
{\TT\FIF\INL{10}
 
nodes.o    :  .n
 
}
Two restrictions are associated with specifically typing the
input file type.  First, there must be a single rule to
generate the required output file type from the specified input
file type.
If such a one step rule does not exist,
\MAKE\ will consider it to be an error.
Secondly,
the pattern used to generate the input filename is based entirely
upon the specified input file type, so the variable must generate
the correct file name.
 
 
\L0{Special Built-In Target Names}    \HH{Special Targets}
 
\MAKE\ recognizes a number of target names as having special
meanings. The following special targets are recognized by
\MAKE.
 
\IX{\TT{.ONLINE}}
\PL{SYNTAX}
 
\PI{.ONLINE}  \HH{ONLINE} \SB{HELP}\TT{.ONLINE} ~~~~\SB
dependencies are created by executing commands by the current
session, not by submitting batch jobs.
This is the preferred method of recursively executing \MAKE.
This fake target uses the special targets \TT{.xeq} and \TT{.xeqend}
which must be defined (they are automatically defined built-in
targets).
Targets which are temporary files or which have dependencies which
are temporary files are implicit dependencies of \TT{.ONLINE}.
If the ``\TT{-j0}'' option is used to run \MAKE,
all targets implicitely depend upon \TT{.ONLINE}.
 
\PI{.PHONY}   \HH{PHONY}  \SB{HELP}\TT{.PHONY} ~~~~\SB
dependencies are considered to be phony targets.  When it is time
to consider such a target, \MAKE\ runs its commands
unconditionally, regardless of whether a file with that name exists
or what its last modification time is.
\IX{\TT{.PHONY}}\IX{phony targets}\IX{fake targets}
 
\PI{.PRECIOUS}\HH{PRECIOUS}\SB{HELP}\TT{.PRECIOUS} ~~~~\SB
dependencies of this target are given special treatment.  When
\MAKE\ is executing commands to create such a target, it is not
deleted if the operation fails.
\IX{\TT{.PRECIOUS}}\IX{deleting target files}
 
\PI{.jcl}  \HH{jcl} \SB{HELP}\TT{.jcl} ~~~~\SB
commands are used to create the batch jcl to build the targets
(see
\SB{HELP}
topic \TT{BATCH_JCL}).
\SB{}
section 4, ``How a Batch Job is Made'').
\SB
 
\PI{.end}  \HH{end} \SB{HELP}\TT{.end} ~~~~\SB
commands are used to create the batch jcl to build the targets
(see
\SB{HELP}
topic \TT{BATCH_JCL}).
\SB{}
section 4, ``How a Batch Job is Made'').
\SB
 
\PI{.xeq}  \HH{XEQ} \SB{HELP} \TT{.xeq} ~~~~\SB
commands are used to create the \IBEX\ commands to build the
targets which are dependent upon ``\TT{.ONLINE}'' (see
\SB{HELP}     topic \TT{ONLINE_JCL}).
\SB{}         section 4, ``How Online Commands are Made'').
\SB
 
\PI{.xeqend}  \HH{XEQEND} \SB{HELP} \TT{.xeqend} ~~~~\SB
commands are used to create the \IBEX\ commands to build the
targets which are dependent upon ``\TT{.ONLINE}'' (see
\SB{HELP}     topic \TT{ONLINE_JCL}).
\SB{}         section 4, ``How Online Commands are Made'').
\SB
 
\PI{.DEFAULT} \HH{DEFAULT}\SB{HELP}\TT{.DEFAULT} ~~~~\SB is not implemented.
 
\PI{.IGNORE}  \HH{IGNORE}\SB{HELP} \TT{.IGNORE} ~~~~\SB is not imlpemented.
 
\PI{.SILENT}  \HH{SILENT}\SB{HELP} \TT{.SILENT} ~~~~\SB is not implemented.
 
\PL
An entire class of special targets have names made up of the
concatenation of two file suffixes.  Such targets are implicit
rules, the way of defining the commands used to generate an
output file type from a given input file type
\SB{HELP}
(see topic \TT{IMPLICIT_RULES}).
\SB{}
(See section 7, ``Implicit Rules'').
\SB
 
\L0{Multiple Targets in a Rule}       \HH{Multiple Targets}
 
A rule with multiple targets is equivalent to writing many rules,
each with one target.
The same commands apply to all of the targets,
but their effects may vary because the actual target name is
substituted using the special ``\TT{$@}'' variable.
\IX{\TT{$@}}
The rule contributes the same dependencies to all of the targets
as well.
 
\CPSIX\ \MAKE\ allows the rule to be run once for each target file
or it may be run once to produce all of the target
files.
\MAKE\ decides which of these cases is involved based upon the
contents of the commands used to create the target.
If the commands reference one of the automatic variables ``\TT{$<}'',
``\TT{$(<D)}'', or ``\TT{$(<F)}'', the rule is run for every
\IX{\TT{$<}|||@$<}
\IX{\TT{$(<D)}|||@$(<D)}
\IX{\TT{$(<F)}|||@$(<F)}
target file, otherwise, \MAKE\ assumes that the rule should be
run once and that all of the target files will be produced.
 
This is useful in two cases:
 
\PL{BU}
\PI Adding common dependencies to a list of files.  No commands
are associated with the rule.  For example:
 
{\TT\FIF\INL{10}
 
kbd.o commands.o files.o : coms.h bufs.h
 
}
This provides two additional dependencies to each of the three
object files mentioned.
 
\PI Similar commands can work for all of the targets.
The commands do not need to be absolutely identical, since the
automatic variable ``\TT{$@}'' can be used to substitute the
particular target to be remade into the commands.  For example:
 
\IX{\TT{$@}}\IX{\TT{$(@F)}}
{\TT\FIF\INL{10}
 
big.c little.c :
  generate $< over $@ ( OPT=$(@F::c=) )
 
}
which is equivalent to:
{\TT\FIF\INL{10}
 
big.c  :
  generate $< over $@ ( OPT=big )
 
little.c :
  generate $< over $@ ( OPT=little )
 
}
In the preceding example, the program \TT{generate} is assumed to
prouced two types of output from the same input file, one if given
\TT{OPT=big}  and another if given \TT{OPT=little}.
 
\PL
\L0{Multiple Rules for One Target}    \HH{||B}
 
One file can be the target of several rules if at most one rule
has commands associated with it.
The other rules can only have dependencies.
All the dependencies mentioned in all of the rules are merged
into one list of dependencies for the target.
If the target is older than any of the dependencies from any of the
rules, the commands required to produce the target are executed.
 
An extra rule with just dependencies can be used to give a few
additional dependencies to many files at one time.
For example,
if there is a variable named \TT{objects} containing a list of all
of the compiler output files being made, an easy way to say that
all of them must be recompiled if the file ``\TT{config.h}''
has been changed is to write:
{\TT\FIF\INL{10}
 
objects = foo.o bar.o
 
foo.o : defs.h
bar.o : defs.h refs.h
$(objects) : config.h
 
}
This could be inserted or removed without changing the rules
that have commands for creating the object files,
making it a more convenient form to use when adding additional
dependencies.
 
Another possibility is that the additional dependencies could be
specified with a variable that is set with a command argument
to \MAKE\ (See
\SB{HELP}
topic \TT{INVOKING_MAKE}).
\SB{}
section 6, ``Overriding Variables'').
\SB
For example, with the following line in the \Makefile,
{\TT\FIF\INL{10}
 
$(objects) :  $(extradepends)
 
}
\MAKE\ could be invoked with the \IBEX\ command:
{\TT\FIF\INL{10}
 
!MAKE.X -f\Makefile{} 'extradepends=extra.h'
 
}
which will add an additional dependency to all of the files named
in the variable \TT{objects}.  If \MAKE\ is invoked without
the command line setting of the \TT{extradepends} variable,
no additional dependencies are added.
 
Finally,
if none of the rules for a target have explicit commands,
then \MAKE\ searches for an implicit rule for commands
to use to create the file (See
\SB{HELP}
topic \TT{IMPLICIT_RULES}).
\SB{}
section 7, ``Implicit Rules'').
\SB
\L0{Double Colon Rules}               \HH{Double Colon Rules}
 
Double Colon Rules are not implemented in \CPSIX\ \MAKE.
 
\CH{Writing Commands||SE}    \HH{Writing Commands}
 
The \SL{commands} associated with a rule consist of
\CPSIX\ \IBEX\ commands to be executed as part of the target
build command stream.
\IX{commands}
These commands are executed in one stream, in the order in which
they appear following the rule.
Each command must begin with an initial blank, and the commands
are terminated by the next blank line, comment or rule.
 
Commands are limited to 255 characters, but \MAKE\ will try continuing
the command with a ``\TT{;}'' if the command is longer.  This may
or may not work depending upon the program that is reading
the commands.
 
\L0{Command Echoing}                  \HH{Command echoing||S}
 
\IX{echoing}
Normally \MAKE\ does not print the commands before they are written
to the command stream.
However, when a command begins with a ``\TT{@}'' character, that
character is removed from the command and the command is printed
as the job is being batched.
Typically this is used to print a message indicating the state of
the \MAKE\  process.
 
Additionally, when \MAKE\ is given the command line option
``\TT{-n}'', echoing is all that happens, no jobs are batched
\IX{no-op}\IX{\TT{-n}}
\SB{HELP}
(see topic \TT{INVOKING_MAKE}).
\SB{}
(See section 6, ``Option Summary'').
\SB
This option is used to find out which commands \MAKE\ thinks are
necessary to build the target without actually doing them.
Typically, this option is used when writing a \Makefile\ to verify
that \MAKE\ is making all of the correct decisions.
 
The ``\TT{-s}'' option may be used to prevent any echoing, which
\IX{silent}\IX{\TT{-s}}
causes the commands beginning with ``\TT{@}'' to be treated as if
the special echo flag was not present.
 
\L0{Command Execution}                \HH{Command Execution||S}
 
When it is time to execute the commands required to create a target,
they are executed by \MAKE\ executing a single command stream
for all of the commands associated with the rule being used.
The command stream signals back to \MAKE\ that the target has
not been successfully built in one of two ways.
 
First,
\MAKE\ looks for a file with the same base file name as the target
being built, but formed using the variable ``\TT{DOPATH}'' as if
it were a suffix variable.  \IX{diagnostic output}
If this file exists
when the commands have completed execution, \MAKE\ assumes
that the target creation was unsuccessful.
This file is assumed to contain ``\SL{diagnostic output}'' associated
with the job so that the reason for the failure can be discerned.
\IX{diagnostic output}
 
Secondly,
\MAKE\ looks for the target file (if the file is not a
\TT{.PHONY} target).
\IX{\TT{.PHONY}}\IX{phony targets}\IX{fake targets}
If the target file does not exist, \MAKE\ reports
a failure to create the target.
 
When an error occurs,
\MAKE\ continues building all of the targets of the final goal
that can be built, as long as they do not
depend upon a failed target.
 
\CPSIX\ \MAKE\ knows how to build several targets simultaneously.
As it is building, every target remaining to be built
is examined to determine
if all of the targets upon which it depends
upon are already completely up to date.
If they are,
\MAKE\ marks that target as ready to run.
By default,
\MAKE\ tries to run up to 511 simultaneous jobs.
The ``\TT{-j}'' option may be used to limit the number of
\IX{\TT{-j}}\IX{batch jobs}\IX{limiting jobs}\IX{job option}
\IX{parallel building}\IX{execution in parallel}
simultaneous jobs that \MAKE\ submits.
If ``\TT{-j0}'' is specified, all jobs are run in the current
session, no batch jobs will be submitted.
 
Since the commands are usually run as batch jobs,
output from the commands being used to build the target is
not normally saved unless there is a fatal error producing the target.
Additionally,
input to the jobs must be supplied entirely by dependent files
or by the commands used to build the target.
 
\L1{Command Input}                    \HH{Command Input||S}
 
\MAKE\ normally inserts a ``\TT{!}'' in front of each command
as it is being batched,
to indicate that it is an \IBEX\ command.
If a command runs a program which will ask for input
(such as \TT{PCL} or \TT{EDIT}),
each non-\TT{IBEX} command must be preceded by a ``\TT{!}''
character.
This tells \MAKE\ to remove that ``\TT{!}''
and not to insert its own.
 
\L1{Step Condition Codes}             \HH{STEPCC||S}
 
\MAKE\ normally checks the condition codes after every command
that is executed.
\MAKE\ does this by inserting the following \TT{IBEX} command:
{\TT\FIF\INL{10}
 
!if STEPCC>0 then goto ABORT
 
}
where the \TT{ABORT} label defines the actions used to terminate
the command stream, leaving notification to \MAKE\ that the
target was not made successfully.
 
In some cases, this may not be appropriate because
\PL{BL}
\PI the program may not set the step condition codes,
\PI the command is followed by non-\TT{IBEX} input, which would cause
the program to terminate execution before reading all of its input,
\PI the step condition codes do not matter.
\PL
If a command begins with a ``\TT{-}'',
\MAKE\ will not check the step condition codes after that command.
The ``\TT{-}'' character is removed before the command is
added to the command stream.
 
When an error has been detected by a nonzero step condition code
result,
\MAKE\ marks the current target as errored, and continues trying
to build as many of the other targets required for the final target
as long as they do not depend upon any errored targets.
Finally, when \MAKE\ completes
execution, it produces a list of the remaining
targets to be built and the reason that they were not completed.
 
This mode allows the user to locate as many problems as possible
each time \MAKE\ is run, locating possibly independent problems.
 
\L1{Building Batch JCL}          \HH{BATCH JCL}
 
\IX{batch}
When \MAKE\ builds a batch job, it glues together
three separate pieces of \CPSIX\ jcl.
First, it locates the commands associated with the fake target
\TT{.jcl}. \IX{\TT{.jcl}}
These commands contain a \TT{!JOB} command,
a \TT{!RES} command,
issue a \TT{!DIR} command to set the current directory to
the file management directory that was associated with the
user running \MAKE,
sets \TT{M$DO} to the \MAKE\ file created by the base file name
with the value of the variable \TT{DOPATH} treated as a file suffix,
and finally the target is deleted if it is not a dependency of
\TT{.PRECIOUS}.
\IX{diagnostic output}
\IX{\TT{.PRECIOUS}}\IX{deleting target files}\IX{fake targets}
 
Next,
the commands provided for the target being built are inserted
into the job stream.
If these commands begin with \TT{!DEFAULT} commands,
those commands are actually inserted before the commands
associated with \TT{.jcl}, so that the default job time or name
can be overridden.
 
Finally,
\MAKE\ inserts the commands associated with the \TT{.end} target.
These commands set the \TT{M$DO} and \TT{M$LL} dcbs to \TT{NO},
delete the \SL{diagnostic output file},
and stop execution by default.
It also defines the label \TT{ABORT} which causes none of the above
actions to occur.
 
The default \TT{.jcl} and \TT{.end} target rules are shown
in the following two figures.
\IX{\TT{JOBOPTS}}
\IX{\TT{RESOPTS}}
\IX{\TT{$+}|||@$+}
\IX{\TT{$(*D)}|||@$(*D)}
 
\FG{Default \TT{.jcl} Rules||FLOATING}       \INL{1}
-JOB $(JOBOPTS)
-RES $(RESOPTS)
-Dir .$(*D)
-Set M$DO $+
-Let STEPCC = 0
\FG
 
 
 
\FG{Default \TT{.end} Rules||FLOATING}       \INL{1}
-Set M$DO NO
-Set M$LL NO
-Del $+
-ERASE
-Quit
-ABORT: OUTPUT '******** ERROR ***********'
\FG
 
These rules may be overridden by supplying them in your \Makefile.
 
\L1{Building XEQ Commands}     \HH{ONLINE JCL}
 
When a target to be built depends upon the fake target
\TT{.ONLINE}, \IX{\TT{.ONLINE}}
\MAKE\ does not submit a separate batch job to produce this target.
\MAKE\ builds a stream of \IBEX\ commands in the same manner
as the batch jcl is produced with the exception that the  build
commands are preceded by the commands in the fake target
\TT{.xeq} and are followed by the commands in the fake target
\TT{.xeqend}.
\IX{\TT{.xeq}}\IX{\TT{.xeqend}}\IX{\TT{.jcl}}\IX{\TT{.end}}
These commands provide the same functionality as the
fake targets \TT{.jcl} and \TT{.end}
but include commands to resume execution of a saved image of
\MAKE.
 
\MAKE\ runs an \TT{.ONLINE} target by producing the commands
to be executed, issuing an \TT{IBEX} ``\TT{XEQ}'' command specifying
the file containing the commands,
writes the current status to a star file,
and exits to execute the \TT{xeq} commands.
 
After the \TT{IBEX} commands have been executed,
the status is restored from the star file and the building
process continues.
 
The default \TT{.xeq} and \TT{.xeqend} target commands are
shown in the following two figures.
 
\IX{\TT{$(*D)}|||@$(*D)}
\IX{\TT{saved_image_MAKE}}
\IX{\TT{$@}}
\IX{\TT{$+}|||@$+}
 
 
\FG{Default \TT{.xeq} Rules||FLOATING}       \INL{1}
-dir .$(*D)
-Reset
-Set M$DO $+
-let STEPCC=0
-Echo
\FG
 
 
 
\FG{Default \TT{.xeqend} Target Commands||FLOATING}       \INL{1}
-dont echo
-reset
-if $fid_exist('$+') then del $+
-goto resume
-ABORT: dont echo
-output 'target $@ failed'
-Reset
-resume: dir .$(*D)
-$(saved_image_MAKE).
\FG
 
As with the default \TT{.jcl} and \TT{.end} rules,
the \TT{.xeq} and \TT{.xeqend} rules may be replaced simply
by defining them in the \Makefile.
 
 
\L0{File Name Substitution}
 
\IX{command expansion}
As \MAKE\ sends each command to the command stream to be executed,
it examines the command for the names of targets.
When a \Makefile\ target is found, \MAKE\ replaces the
name of the target with the real \CPSIX\ file identifier.
This permits the \Makefile\ to always refer to files by their
name and suffix and \MAKE\ provides the mechanism to turn these
names into real \CPSIX\ file names.
It also permits \MAKE\ to insert and modify the accounts in which
the files are found or are destined when using the file searching
capability outlined in
\SB{HELP}
topic \TT{FILE_SEARCHING}.
\SB{}
section 3, ``Searching Accounts for Files''.
\SB
 
The rules for the filename substitution are:
\PL{BL}
\PI If the command being processed is \TT{link} or \TT{copy},
\MAKE\ inserts commas between the file names up to the
\TT{ON}, \TT{OVER} or \TT{INTO} verb.
 
\PI \MAKE\ scans each command looking for the start of a target name
or a ``\TT{-}''.
 
\PI If a ``\TT{-}'' character was found, it and the next character
are skipped.
 
\PI If the current character could be the start of a target name,
the entire name is picked up and \MAKE\ checks to see if it has
generated this target.
 
\PI If \MAKE\ has generated this target (or it was a dependency
or something that was generated), then the text of the target name
is replaced with the actual \CPSIX\ file identifier.
 
\PI Finally, if this is not the name of a target, then the text
is moved into the command untouched.
\PL
 
 
\L0{JCL Command Flag Summary}         \HH{COMMAND FLAGS}
 
The following table summarizes the command flags which may appear
at the beginning of a command.  Any number of these flags may appear
on a command and they are removed before the command is sent to the
command stream.
 
\TB{JCL Command Flags|||2}
\TH{Flag \TC Meaning}
\TT{-} \TC Don't check step condition codes           \TX
\TT{@} \TC Echo this command before sending batch job \TX
\TT{!} \TC Don't prefix command with a ``\TT{!}''     \TX
\TB
 
\CH{Variables||SE} \HH{VARIABLES}
\IX{variables}
 
A \SL{variable} is a name used to represent a
string of text, called the variable's \SL{value}.
These values are substituted by explicit request into all subsequent
commands in the \Makefile.
Variables can be used to represent lists of file names,
options to compilers,
program names,
directories,
or any string of text that is required to be reproduced
in the \Makefile.
 
A variable name consists of any sequence of letters, numbers and
the following special characters ``\TT{_}'', ``\TT{.}'', ``\TT{$}'',
``\TT{?}'', and ``\TT{*}''.
It is traditional to use upper case letters in variable names,
but good style also suggests using lower case names for
internal purposes, reserving upper-case variables for those which
the user may override from the command line.
 
\L0{Referencing Variables}            \HH{REFERENCES||S}
 
To insert a variable's value into a command,
a single dollar sign is used followed by the name of the
variable within parenthesis.  For example,
\TT{$(FORMAT)} is a valid reference to the variable \TT{FORMAT}.
This special significance for ``\TT{$}'' is why the way to use
a real dollar sign in a command is to use \TT{$$}.
A dollar sign must be doubled if it is to begin or immediately
followed by zero or one characters legal in a target name or
an opening parenthesis ``\TT{(}''.
In all other cases, the dollar sign should not be doubled.
 
Variable references can be used in any context:
targets,
dependencies,
commands, directives
and new variable values.
Here is a common kind of example,
where a variable holds the names of all of the object
files in a program:
\IX{target} \IX{dependencies} \IX{commands} \IX{directives}
{\TT\FIF\INL{10}
 
objects =  program.o format.o utilities.o
 
program : $(objects)
  link $(objects) over program
 
$(objects) :  common.h
 
}
Variable references work by strict textual substitution.
Thus, the rule:
\IX{\TT{$@}}
{\TT\FIF\INL{10}
 
ac   = c
test.o : test.c
  $(ac)$(ac) test.c over $@
 
}
could be used to compile a C program \TT{test.c}.  This is because
spaces around the variable value are ignored in variable
assignments, therefore, the value of \TT{ac} is precisely ``\TT{c}''.
 
A dollar sign followed by a character other than a dollar sign,
open parenthesis or open brace is treated as a reference to a
single character variable name.  Thus, the variable ``\TT{x}'' could
be referenced by writing ``\TT{$x}''.
However, this is not good practice with the exception of referencing
the special built-in target name variables.
 
\L1{Modified References}              \HH{MODIFIED REFERENCES||S}
 
 
In addition to simple references,
variables may be referenced in a manner that modifies the
value of the reference but does not modify the value of the
variable being referenced.
Such a reference is known as a \SL{substitution reference}.
 
A \SL{substitution reference} has the form:
{\TT\FIF\INL{10}
 
$(var:a=b)
 
}
This means that it replaces every ``\TT{a}''
with  ``\TT{b}''.
Note that this is slightly different from the \UNIX\ \TT{make}
definition where the string ``\TT{a}'' is only found when it is
immediately followed by a blank.
For example:
{\TT\FIF\INL{10}
 
wom = a.o b.o c.o
bat = $(foo:.o=.c)
 
}
This example sets ``\TT{bat}'' to ``\TT{a.c b.c c.c}''.
 
\L0{Assigning Values}         \HH{ASSIGNMENT||S}
 
\IX{variable assignment}\IX{assignment of variables}
Variables may receive values in one of three ways:
\PL{BL}
\PI A value may be provided on the \MAKE\ command invocation,
\PI A value may be provided within the \Makefile,
\PI An initial value may be provided by an \IBEX\ command variable,
\PI Some variables have initial values provided by \MAKE.
\PL
 
Before \MAKE\ reads the \Makefile,
it provides initial values for a number of built-in variables
including the default patterns for file types, compiler names
and their default compiler options.
\IX{compiler options}\IX{file types}
These values may be overriden by specifying a command line
value, defining a corresponding \IBEX\ variable,
or they may be reassigned within the \Makefile.
Variables assigned a value on the command line override any
other definitions and may not be reassigned.
 
Variables are defined within a \Makefile\ by writing a variable
assignment of the form:
{\SL\FIF\INL{10}
 
  variable = replacement
 
}
When the value of a variable is specified in a \Makefile,
leading and trailing blanks
are removed before the first nonblank and after the last nonblank.
There is no limit to the length of the value of a variable
other than the amount of memory that is available.
When a definition is long, however, it is a good idea to break it into
several lines by terminating lines to be continued with a ``\TT{\\}''.
 
Variables that are not otherwise defined are assumed to contain
an empty string as their initial value.
There are a number of variables which have built-in initial
values, some of which may be assigned values.
 
Unlike other versions of \MAKE, \CPSIX\ \MAKE\ replaces a
variable reference with its current value.  Therefore, it is
important to order your variable assignments so that they
do not refer to variables defined later in the \Makefile.
This definition permits \MAKE\ to run faster and is also
easier to understand.
 
Variable values may be defined by an \IBEX\ \TT{let} command
which is a variable assignment that will be retained for the current
session.
Variables assigned initial values in this manner may be
reassigned within the \Makefile, however, \IBEX\ variable values
override the default \MAKE\ values listed for the file type
variables (see
\SB{HELP}
topic \TT{FILE_TYPES})
\SB{}
section 3, ``Default File Types'')
\SB
and compiler names and options (See
\SB{HELP}
topic \TT{BUILT_IN_RULES}).
\SB{}
section 7, ``Catalogue of Built-In Implicit Rules'').
\SB
Since the file type variables begin with a leading ``\TT{.}''
and this is not a legal character in an \IBEX\ variable,
the leading ``\TT{.}'' is replaced with the string ``\TT{f#}''
when \MAKE\ is looking for these \IBEX\ variables.
For example, to change the default pattern for Pascal
source files to the string ``\TT{:pas}'',
the following \IBEX\ command is required:
{\TT\FIF\INL{10}
 
!Let f#p = ':pas'
 
}
When \MAKE\ is subsequently run,
the variable ``\TT{.p}'' will have the value ``\TT{:pas}''.
\IX{\TT{PASCAL}}\IX{\TT{.p}}
 
\CH{Running MAKE||SE}                 \HH{RUNNING MAKE}
 
A \Makefile\ or target is all that is necessary to run \MAKE.
The files that are not up to date are determined by \MAKE\ and
built-in commands along with specific commands supplied in the
\Makefile\ are used to bring these files up to date.
 
\MAKE\ may be used to bring all of the files associated with the
default goal of the \Makefile\ up to date,
or to selectively bring some of the targets in
the \Makefile\ up to date.
By specifying the appropriate options to \MAKE\ the user
is able to control the operation of this processor.
 
\MAKE\/ obtains its options from the following sources:
 
\PL{BU}
\PI  the \TT{IBEX} command line
\PI  the \TT{MAKEFLGS} \TT{IBEX} variable,
\PI  the \TT{MAKEFLGS} after reading the \Makefile.
\PL
\IX{\TT{MAKEFLGS}}
 
When options are specified in the \TT{MAKEFLGS} variable,
they appear as they would be entered on the command line.  The only
restriction on the use of this variable to specify options is
that targets may not be specified and a \Makefile\/ name
option (``\TT{-f}'') may not be specified within the \Makefile.
Otherwise, macro definitions and options may appear within the
\TT{MAKEFLGS} variable in the same way as they would on the
\TT{IBEX} command line.
 
 
\L0{Arguments to Specify the Makefile}\HH{MAKEFILE OPTION||S}
 
The ``\TT{-f}'' option is used to specify the name of the
\Makefile.
\IX{\TT{-f}}\IX{\Makefile\ option}\IX{file option}
For example, ``\TT{-fMakeCEM}'' says to use the file
\TT{MakeCEM} as the \Makefile.
The ``\TT{-f}'' option may be specified only once per invocation
of \MAKE.
 
\L0{Goals}                            \HH{GOAL||S}
 
The \SL{goals} are the targets that \MAKE\ should strive
to ensure are up to date.
Other targets will be updated as well, if they appear as dependencies
of \SL{goals}.
By default,
the goal is the first target in the \Makefile, excluding any targets
which start with a period.
Therefore, \Makefile{}s are usually written so that the first
target is for compiling the entire program or library that
they represent.
 
A different goal or goals can be specified by using special
arguments to \MAKE.  In this case, simply specifying the
goals on the command line cause \MAKE\ to process each of those
goals in the order they are specified.
Any target in the \Makefile\ may be the goal when used this way.
For example, if the \Makefile\ contains:
{\TT\FIF\INL{10}
 
.PHONY  : all
all     : opt fe cgg
 
}
\IX{\TT{.PHONY}}\IX{phony targets}\IX{fake targets}
and if \TT{all} is the goal, then \TT{opt}, \TT{fe} and \TT{cgg}
will be brought up to date.
Alternatively,
if just \TT{cgg} is specified as the goal on the command line,
then \TT{opt} and \TT{fe} will only be brought up to date if
they are needed to produce \TT{cgg}.
 
\L0{Avoiding Recompilation}
 
Sometimes it is possible to make a change in a source file that
would otherwise cause all of the files that depend upon it to
be recompiled when only a few really need to be compiled.
For example, suppose a macro or a new declaration was added
to a header file.
Being very conservative,
\MAKE\ would assume that any change in the include file requires
recompilation of all of the dependent files.
 
If this situation has been anticipated,
it can be solved by using the ``\TT{-t}'' option.
\IX{touch}\IX{\TT{-t}}
This flag tells \MAKE\ not to run the commands in the rules,
but rather to mark the target up to date by changing
its last modification time.
The following procedure should be followed:
\PL{NU}
\PI  Use \MAKE\ to recompile any source files that really do
need compilation.
\PI  Make the change to the include files.
\PI  Use \MAKE\ with the ``\TT{-t}'' option \IX{touch}\IX{\TT{-t}}
to mark all of the object files as up to date.  The next time
\MAKE\ is run, the changes in the header files will not cause
any recompilation.
\PI  Make changes to the source files that need the new include file
changes.
\PI  Run \MAKE\ to recompile only the changed files.
\PL
If the include file has already been modified before the first step,
it is too late to do this.
In this case, the ``\TT{-o}'' option should be used to compile
\IX{old option}\IX{\TT{-o}}
everything that needs compilation with \MAKE\ treating the
include file as if it had not been modified.
The following procedure should be used:
 
\PL{NU}
\PI  Recompile the source files that need to be compiled independent
     of the modified include file with ``\TT{MAKE.X -oInclude ...}''.
     If more than one include file is involved in this, multiple
     ``\TT{-o}'' options should be specified, one for each include
     file.
     \IX{changed option}\IX{\TT{-c}}
     Use the ``\TT{-c}'' option to compile changed source files
     if the source files have been modified to use the new include
     file changes.
 
\PI  Now, touch all of the target files with the command
     ``\TT{MAKE.X -t ...}''.
 
\PI  Finally, make the changes to the source files that need the
     new include file changes.
 
\PI  Run \MAKE, compiling only the changed files.
\PL
 
\L0{Instead of Building the Targets}  \HH{NON_BUILD OPTIONS||S}
 
The \Makefile\ shows \MAKE\ how to tell if a file is up to date.
Unfortunately updating the targets is not always what is required.
There are a number of options available when using \MAKE\ that
do not cause the targets to be built.
 
\PL{SYNTAX}
\PI{-t} \HH{TOUCH}     \SB{HELP} \TT{-t} is \SB
``Touch''.  This use of \MAKE\ is to mark all of the targets
as up to date without actually changing them.
In other words, \MAKE\ pretends to compile the targets but does
not really change their contents.
\IX{touch}\IX{\TT{-t}}
 
\PI{-n} \HH{NO_OP}     \SB{HELP} \TT{-n} is \SB
``No-op''.  This use of \MAKE\ is to print the commands that
would be used to bring the targets up to date.  The commands are
not actually run.  This option is perhaps the best way to debug
a \Makefile.
\IX{no-op}\IX{\TT{-n}}
 
\PI{-q} \HH{QUESTION}  \SB{HELP} \TT{-q} is \SB
``Question''.  This use of \MAKE\ is to find out whether the
target is up to date already.  No commands will be executed, but
the step condition code will be 0 if the target is up to date.
\IX{question option}\IX{\TT{-q}}
 
\PL
 
\L0{Overriding Variables}             \HH{VARIABLE OPTIONS||S}
 
The value of a \Makefile\ variable can be set so that the
\Makefile\ assignments to that variable are ignored.
This is done by the enclosing the variable definition within
single quotes on the \MAKE\ invocation.
For example, \TT{'CC=CC.:SYSTEST'} may be specified on the
\MAKE\ command to cause the value of the variable \TT{CC} to
be ``\TT{CC.:SYSTEST}''. \IX{\TT{CC}}
 
One use for this is to pass extra options to compilers or to
even change the compiler to be used.
 
\L0{Option Summary}                   \HH{||A}
\IX{invoking \MAKE}
\IX{COMMAND_LINE_OPTIONS}
 
\SB{HELP} \MAKE\ is a case tool that is used to maintain, update
and reproduce files whose base components have been modified.
\SB
\HH{||B}
\MAKE\ is invoked with the following command:
{\TT\FIF\INL{5}
 
!MAKE.X [option [option...]] [target [target...]] ['var=repl']
 
}
where:
\PL{SYNTAX}
\PI{target}                  \SB{HELP} target \SB
is one of the targets found in the \Makefile.
\PI{'var=repl'}\HH{VARIABLES}\SB{HELP} 'var=repl' \SB
is a variable assignment (many variables may be
assigned a value this way).
\PI{option} \HH{OPTIONS||B}     \SB{HELP} option \SB
is one of the following options:
 
\PL{SYNTAX}
\*{ACTIONS||S}
\PI{-a}                      \SB{HELP} \TT{-a}    \SB
causes \MAKE\ to display all of the \SL{actions} that it has
determined are necessary to produce the \SL{goal}(s) and to indicate
the status of each \SL{target} before actually performing the
build (or touch) operation.
This information includes the names of the \CPSIX\ files used as
input and output,
and the number of the rule used to produce the target.
All of the target rule names are listed at the end of this summary.
\IX{\TT{-a}}\IX{actions}
\*{CHANGED|FORCE|S}
\PI{-ctarget}                \SB{HELP} \TT{-ctarget}    \SB
causes \MAKE\ to treat the following target as if it has
been modified (or needs to be built), regardless of the latest
modification time of the file provided by the operating system.
This option can be used in conjunction with the \TT{-n} option
to find out what would happen if that file was modified.
The target name should appear immediately after the ``\TT{-c}''
without an intervening blank.
\IX{\TT{-c}}\IX{changed option}
\*{DEBUG||S}
\PI{-d}                      \SB{HELP} \TT{-d}    \SB
causes \MAKE\ to display debugging information in addition
to normal processing messages.
This information includes the names of the targets being built,
the file names being considered and their most recent modification
times.
It also indicates the implicit rules being considered and displays
the action table that \MAKE\ uses to run the batch jobs to produce
the goals.
\IX{\TT{-d}}\IX{debug option}
\PI{-e}                      \SB{HELP} \TT{-e} \SB
causes \MAKE\ to send electronic mail to the target owner if an
error occurs producing the target.  Owners get a summary of all of
their errored targets, and if the option ``\TT{-ee}'' is provided
then as soon as the error occurs \MAKE\ sends a mailgram containing
the reason for the failure, the name of the \SL{diagnostic output}
file and the first 12 lines of diagnostics.
\IX{\TT{-e}}\IX{email option}
\*{FILE|MAKEFILE|S}
\PI{-ffid}                   \SB{HELP} \TT{-ffid} \SB
tells \MAKE\ the name of the \Makefile\ to use.
The name of the file should immediately follow the ``\TT{-f}''
with no intervening blanks.
\IX{\TT{-f}}\IX{\Makefile\ option}\IX{file option}
\*{GENERATE||S}
\PI{-gfid}                   \SB{HELP} \TT{-gfid} \SB
tells \MAKE\ to create a file containing a description of all
of the input and output files associated with each step of the
build process.  The file format contains the following fields
separated by a single blank: the input file name, the output file
name, the output target name and the rule name used to generate
the file.
\IX{actions}\IX{\TT{-g}}\IX{generate}
\*{INCLUDE|SEARCH_LIST|S}
\PI{-iACCOUNT}               \SB{HELP} \TT{-iACCOUNT} \SB
adds \TT{ACCOUNT} to the search list to use for \TT{:include}
files.
Up to 10 search accounts may be specified (by specifying
this option multiple times).
The ``\TT{ACCOUNT}'' may be a simple account name,
a filename and account or a wildcarded filename and account.
\IX{\TT{-i}}\IX{search list}
\*{JOBS|BATCH|S}
\PI{-jn}                     \SB{HELP} \TT{-jn}   \SB
specifies the maximum number of batch jobs that \MAKE\ will
have submitted to the system simultaneously.
The ``\TT{-j}'' must be followed by decimal digits with no intervening
blanks.  The number field ends on the first non-digit.
The number must be greater than zero.
If the number is zero, all jobs will be run by the current session,
no batch jobs will be submitted.
\IX{\TT{-j}}\IX{batch jobs}\IX{limiting jobs}\IX{job option}
\IX{parallel building}\IX{execution in parallel}
\IX{\TT{LOPATH}}\IX{\TT{DOPATH}}
\*{COMPRESS||S}
\PI{-k}                      \SB{HELP} \TT{-k}    \SB
is used to control the generation listing and diagnostic filenames.
When this option is used,
only the base target name is used to generate the listing
and diagnostic filenames by applying the \TT{LOPATH} and
\TT{DOPATH} patterns respectively.
Normally, \MAKE\ uses the entire target name for these
file names changing embedded ``\TT{.}'' characters into
``\TT{:}''.
\*{LIST||S}
\PI{-lcomponent,fid}         \SB{HELP} \TT{-l}    \SB
is used to create a fake ``\TT{:LIST}'' file from the current
\Makefile.  It is not suitable for use with \TT{FUMBLE.X} but is
close enough for use with some of the other tools which use the
\TT{:LIST} file such as \TT{LNCOUNT.X}.
\IX{\TT{:LIST}}\IX{list}\IX{\TT{-l}}
\*{MEMORY||S}
\PI{-m}                      \SB{HELP} \TT{-m}    \SB
causes make to display its memory usage.
\IX{memory}\IX{\TT{-m}}
\*{NO_OP||S}
\PI{-n}                      \SB{HELP} \TT{-n}    \SB
causes make to print the commands that would be executed
if it were to build the goal.
\IX{no-op}\IX{\TT{-n}}
\*{OLD||S}
\PI{-otarget}                \SB{HELP} \TT{-otarget}\SB
causes \MAKE\ to treat the following target as if it is
up to date, regardless of its dependencies, or the modification time
provided by the operating system.
This option can be used to avoid recompiling targets that would
otherwise be compiled.
The target name should appear immediately after the ``\TT{-o}''
without an intervening blank.
\IX{old option}\IX{\TT{-o}}
\*{PRINT|LIST|S}
\PI{-p}                      \SB{HELP} \TT{-p}    \SB
print the \Makefile, the variable definitions and summarize all
of the explicit dependencies.
\IX{\TT{-p}}\IX{print option}\IX{listing option}
\*{QUESTION||S}
\PI{-q}                      \SB{HELP} \TT{-q}    \SB
do not build the goal, set the step condition codes to 0 if
the target is up to date.
\IX{question option}\IX{\TT{-q}}
\*{NO_RULES||S}
\PI{-r}                      \SB{HELP} \TT{-r}    \SB
do not include the default rules.  The \Makefile\ must define
all of the implicit rules that are required.
\IX{\TT{-r}}\IX{rule option}\IX{no default rules}\IX{default rules}
\IX{built-in rules}
\*{SILENT||S}
\PI{-s}                      \SB{HELP} \TT{-s}    \SB
do not echo ``\TT{@}'' commands; if ``\TT{-ss}'' is specified,
the \IBEX\/ status check commands are not issued on running
batch jobs as well.
\IX{silent}\IX{\TT{-s}}
\*{TOUCH||S}
\PI{-t}                      \SB{HELP} \TT{-t}    \SB
do not build the goal, rather, touch all of the files making
them appear up to date.
\IX{touch}\IX{\TT{-t}}
\*{updates}\IX{\TT{-u}}
\PI{-u}                      \SB{HELP} \TT{-u}    \SB
causes update packets to be included if the access control list
for the update file is empty, contains the account ``\TT{DONE}''
or the account ``\TT{?MSC}''
or contains the current logon account.  If this option is specified
twice, then the update file is only included if the access control
list is empty or contains the account ``\TT{DONE}'' or ``\TT{?MSC}''.
\*{VERBOSE}
\PI{-v}                      \SB{HELP} \TT{-v}    \SB
print the version of \MAKE\ and additional information associated
with the ``\TT{-a}'' and ``\TT{-d}'' options.  If this option
is specified twice, even more output is provided for the
``\TT{-a}'' option.
\IX{\TT{-v}}\IX{verbose option}\IX{version}
\*{WIDTH}
\PI{-wn}                     \SB{HELP} \TT{-wn}   \SB
set \MAKE's output width to the decimal argument value (as in
\TT{-w80} to set the output width to 80).
\IX{\TT{-w}}\IX{width option}\IX{output width}
\PL
\PL
\HH{||B}
Finally,
output of \MAKE\ may be redirected using the syntax ``\TT{>fid}''.
A single dash ``\TT{-}'' may be used for more than one option
as long as the option does not take a filename or target name
parameter.  For example ``\TT{-vnw80d}'' may be used to request
the ``\TT{-v}'', ``\TT{-n}'', ``\TT{-w80}'' and ``\TT{-d}'' options.
 
\SB{HELP}
For more information on \MAKE, try \TT{!HELP (MAKE.X) TOPICS}.
The \MAKE\ manual is the best way to learn to use this tool.
To get one at \TT{LADC},
print the \TT{tex dvi} file \TT{MAKE_dvi.:XSI} on the laser printer
using the following command:
{\TT\FIF
 
  !dvilg MAKE_dvi.:XSI over LZ@UPSTAIRS (FORM=QMSCAP,DEV=800)
 
}
At other \CPSIX\ sites, the manual may be printed if you have
a \TT{tex dvi} file print program and a laser printer.
\SB
 
 
\CH{Implicit Rules||SE} \IX{rules} \HH{IMPLICIT RULES}
 
There are certain standard ways of remaking target files.
For example, one standard method is to make an object
file from a C source file using the C compiler.
\SL{Implicit rules} tell \MAKE\ how to use these standard
techniques so that the writer of the \Makefile\ does not have
to specify them for every such file. \IX{implicit rules}
 
For example, C compilation typically takes a ``\TT{.c}'' file
\IX{\TT{.c}}
and produces a ``\TT{.o}'' file.  \MAKE\ will apply its
\IX{\TT{.o}}
implicit rule when it sees this combination of file names
and there are no explicit rules specified.
A chain of implicit rules can apply in sequence; for example,
\MAKE\ knows how to remake a ``\TT{.o}'' file from a ``\TT{.y}''
file via a ``\TT{.c}'' file.
 
The built-in implicit rules use several predefined variables
in their commands so that, by changing the values of
the variables, the way the implicit rule works can be modified.
\IX{\TT{COPTS}}
For example, the variable \TT{COPTS} controls the options given
to the C compiler by the implicit rule for C compilation.
 
In addition to using the built-in rules, \Makefile{}s may define
new implicit rules.
 
\L0{Using Implicit Rules}             \HH{USING RULES||S}
 
To allow \MAKE\ to find a standard method for updating a target file,
the \Makefile\ merely has to refrain from associating commands
with the target rules, use a consistent naming convention (that
allows \MAKE\ to determine the file type from its file name),
and to communicate the naming convention through variable definitions
(for each of the file types that is different from \MAKE's default
naming conventions).
In the simplest sense,
the user should write a rule with no command lines or
even better, don't write a rule at all.
Then \MAKE\ will figure out which implicit rule to use based
upon the kinds of source files that it finds.
 
For example, suppose the \Makefile\ looks like this:
{\TT\FIF\INL{10}
 
foo  :  foo.o bar.o
  link foo.o,bar.o over foo
 
}
Because ``\TT{foo.o}'' is mentioned as a dependency with no rule to
produce it,
\MAKE\ looks for an implicit rule that will
create it.
This happens whether \TT{foo.o} currently exists or not.
\MAKE\ finds an implicit rule when an input file exists that
corresponds with an implicit rule (or chain of implicit rules)
that produces the required file type.
 
If an implicit rule is found, it supplies both the commands and
the input file type.  If the file \TT{foo.o} has dependencies,
they could be indicated in the \Makefile\ as long as no
commands were attached to those rules.
There are built-in implicit rules for many different input file
types producing a ``\TT{.o}'' file type.  \MAKE\ will look
at each of these rules for a file that exists.  So, if \MAKE\ finds
a file named \TT{foo.c}, it will use the C compiler; otherwise, if
it finds a file \TT{foo.6}, it would use the \TT{PL6} compiler.
\IX{\TT{PL6}}
 
Because \MAKE\ tries suffixes for the rules that it has that might
produce the target file,
care must be taken to ensure that only the correct suffix will
find an existing input file.
This is because \MAKE\ uses the first suffix that produces the
name of an existing file for input,
which could cause the wrong rule to be associated with a target.
 
The author of the \Makefile\ knows the implicit rule that should be
used and the actual choice can be verified by using the \TT{-d}
and \TT{-a} options.
\IX{\TT{-d}}\IX{debug option}
 
 
\L0{Explicit Rules}                   \HH{EXPLICIT TYPING||S}
 
The rule to use to produce a target may be specifically requested
by providing a dependency upon the input file type.
For example, if the object file \TT{build.o} is a produced by
a Pascal source file,
the following rule causes \MAKE\ to only look for the Pascal
file:
{\TT\FIF\INL{10}
 
build.o    :  .p
 
}
\IX{\TT{.p}}
This capability is provided so that \MAKE\ may be used when a
consistent file naming convention has not been used.
One restriction associated with this rule is that the target
file must be produced using the input file by a single
implicit rule.
If such a rule does not exist,
\MAKE\ considers it an error.
 
\L0{Writing Implicit Rules}           \HH{WRITING IMPLICIT RULES||S}
 
Implicit rules appear like other rules with the exception that
they contain two file types.
For example, the implicit rule to create an object file from
a Fortran source file is ``\TT{.f.o}'', which says that this
\IX{\TT{.f.o}}\IX{\TT{.f}}
rule transforms a Fortran source ``\TT{.f}'' into an object
file ``\TT{.o}''.
There are no dependencies allowed on such a definition, and
it must be followed by the commands to produce the appropriate
output file.
 
\L1{Automatic Variable Names}         \HH{AUTOMATIC VARIABLES}
 
Before writing any implicit rules, it is important to review
the names of the automatic variables that are available when
\MAKE\ is creating the jcl.
The following automatic variables are used to represent the
file names that \MAKE\ has found in order to produce the
target file.
 
\IX{\TT{$@}}
\IX{\TT{$<}|||@$<}
\IX{\TT{$*}|||@$*}
\IX{\TT{$+}|||@$+}
\IX{\TT{$&}|||@$&}
\IX{\TT{$!}|||@$!}
\IX{\TT{$?}|||@$?}
\IX{\TT{$^}|||@$^}
\IX{\TT{$(@F)}|||@$(@F)}
\IX{\TT{$(<F)}|||@$(<F)}
\IX{\TT{$(*F)}|||@$(*F)}
\IX{\TT{$(+F)}|||@$(+F)}
\IX{\TT{$(&F)}|||@$(&F)}
\IX{\TT{$(@D)}|||@$(@D)}
\IX{\TT{$(<D)}|||@$(<D)}
\IX{\TT{$(*D)}|||@$(*D)}
\IX{\TT{$(+D)}|||@$(+D)}
\IX{\TT{$(&D)}|||@$(&D)}
\PL{SYNTAX}
\PI{$!}    \HH{GEN_TARGETS}        \SB{HELP} $!   \SB
A blank separated list of the chain of targets which depended upon
this target being built (i.e. the chain of targets starting at the
primary goal target).
\PI{$?}    \HH{CHANGED_TARGETS}    \SB{HELP} $?   \SB
A blank separated list of the targets in the chain of dependents of
this target which are newer than this target
(i.e. the names of the targets
which caused this target to be produced).
\PI{$^}    \HH{DEPENDENT_TARGETS}  \SB{HELP} $^   \SB
A blank separated list of the names of dependents of the target
being built.
\PI{$@}    \HH{TARGET}            \SB{HELP} $@    \SB
The CP-6 file identifier of the target of the rule.
\PI{$<}    \HH{SOURCE_INPUT}      \SB{HELP} $<    \SB
The CP-6 file identifier of the input file (source file).
\PI{$*}    \HH{BASE_NAME}         \SB{HELP} $*    \SB
The CP-6 base file name (without a suffix).
\PI{$+}    \HH{DIAGNOSTICS}       \SB{HELP} $+    \SB
The CP-6 \SL{diagnostic output} file identifier.
\PI{$&}    \HH{LISTING}           \SB{HELP} $&    \SB
The CP-6 \SL{listing output} file identifier.
\PI{$(@F)} \HH{TARGET_FILE}       \SB{HELP} $(@F) \SB
The CP-6 target file name without account.
\PI{$(<F)} \HH{SOURCE_FILE}       \SB{HELP} $(<F) \SB
The CP-6 input file name without account.
\PI{$(*F)} \HH{BASE_FILE}         \SB{HELP} $(*F) \SB
The CP-6 base file name without account.
\PI{$(+F)} \HH{DIAGNOSTIC_FILE}   \SB{HELP} $(+F) \SB
The CP-6 \SL{diagnostic output} file name without account.
\PI{$(&F)} \HH{LISTING_FILE}      \SB{HELP} $(&F) \SB
The CP-6 \SL{listing output} file name without account.
\PI{$(@D)} \HH{TARGET_ACCOUNT}    \SB{HELP} $(@D) \SB
The CP-6 target file account.
\PI{$(<D)} \HH{SOURCE_ACCOUNT}    \SB{HELP} $(<D) \SB
The CP-6 input file account.
\PI{$(*D)} \HH{DIRECTORY_ACCOUNT} \SB{HELP} $(*D) \SB
The CP-6 directory associated with \MAKE\ user.
\PI{$(+D)}\HH{DIAGNOSTIC_ACCOUNT} \SB{HELP} $(+D) \SB
The CP-6 \SL{diagnostic output} file account.
\PI{$(&D)} \HH{LISTING_ACCOUNT}   \SB{HELP} $(&D) \SB
The CP-6 \SL{listing output} file account.
\PL
\IX{diagnostic output}
\IX{listing output}
 
\L1{Associating Commands with Implicit Rules}\HH{IMPLICIT RULE COMMANDS}
 
Implicit rule commands may reference any of the automatic
variables to produce their target file.
Most commands should be a single line such as this
rule for using the \TT{PL6} compiler to produce an object file:
\IX{\TT{.6.o}}
\IX{\TT{PL6}}
\IX{\TT{$<}|||@$<}
\IX{\TT{$&}|||@$&}
{\TT\FIF\INL{10}
 
.6.o :
  $(PL6) $< over $@,$& $(PL6OPTS)
 
}
Notice that the actual name of the \TT{PL6} compiler is not
provided, a variable (that can be modified by the \Makefile\ user)
is used to specify the compiler name and also its options.
Also notice that the rule does not care whether there is
\TT{SI} or both \TT{SI} and \TT{UI} input to the \TT{PL6} compiler.
This is because the ``\TT{$<}'' variable is setup by \MAKE\ to
contain both file names if there are updates provided.
 
When an implicit rule is used to generate a target,
the input file that is found (and is defined in ``\TT{$<}''
becomes an implicit dependency of the target.
It is not necessary therefore (and not recommended) to provide
an explicit dependency for the input file.
 
\L0{Catalogue of Built-In Implicit Rules}\HH{BUILT IN RULES}
 
\MAKE\ provides a number of predefined implicit rules which are
always available.
These rules are automatically defined if the \Makefile\ does not
define them, allowing them to be overridden easily by a \Makefile.
The following table shows these rules.
 
\IX{compiler options}\IX{options for compilers}\IX{jcl options}
\TB{Built-In Rules}
\TH{Rule \TC  Compiler Variable  \TC Option Variable }
\TT{.c.o} \TC \TT{CC~~~~~ = CC}        \TC \TT{COPTS~~~ =     }   \TX
\TT{.6.o} \TC \TT{PL6~~~~ = PL6}       \TC \TT{PL6OPTS~ = (SCH)}  \TX
\TT{.f.o} \TC \TT{FORTRAN = FORTRAN}   \TC \TT{FORTOPTS =     }   \TX
\TT{.y.c} \TC \TT{YACC~~~ = BISON.X}   \TC \TT{YACCOPTS = -d  }   \TX
\TT{.l.c} \TC \TT{LEX~~~~ = LEX.X}     \TC \TT{LEXOPTS~ = -t >$@} \TX
\TT{.n.o} \TC \TT{PARTRGE = PARTRGE}   \TC \TT{PARTOPTS =     }   \TX
\TT{.a.o} \TC \TT{BMAP~~~ = BMAP}      \TC \TT{BMAPOPTS =     }   \TX
\TT{.p.o} \TC \TT{PASCAL~ = PASCAL}    \TC \TT{PASCOPTS =     }   \TX
\TT{.o.r} \TC \TT{LINK~~~ = LINK}      \TC \TT{LINKOPTS =    }    \TX
\TT{.tex.dvi}\TC\TT{TEX~~~~ = TEX}     \TC \TT{TEXOPTS~ =     }   \TX
\TT{.web.tex}\TC\TT{WEAVE~~ = WEAVE}   \TC ~                      \TX
\TT{.web.p}  \TC\TT{TANGLE~ = TANGLE}  \TC ~                      \TX
\TT{.cap.dvi}\TC\TT{CAPFMT~ = }        \TC \TT{CAPDEV~~ =     }   \TX
\TT{.cap.herman}\TC\TT{CAP~~~~ = CAP}  \TC ~                      \TX
\TT{.herman.help}\TC\TT{HERMAN~ = HERMAN.X}\TC\TT{HERMOPTS = (NLS,NWA)} \TX
\TT{.makefile.depends}\TC\TT{MIDGET~ = MIDGET.X}\TC\TT{MIDGOPTS = -cvx} \TX
~                     \TC\TT{MAKE~~~ = MAKE.X}\TC\TT{MAKEFLGS =} \TX
\TT{.jcl} \TC \TT{JOBOPTS~ = Name=$(*F),ReRun}\TC\TT{RESOPTS~ = Mem=128,Time=2}\TX
\TT{.end}  \TC ~                 \TC ~                            \TX
\TT{.xeq}  \TC ~                 \TC ~                            \TX
\TT{.xeqend}\TC ~                \TC ~                            \TX
\TB
\IX{\TT{.jcl}}\IX{\TT{.end}}\IX{\TT{.xeq}}\IX{\TT{.xeqend}}
\IX{\TT{.c.o}}\IX{\TT{.6.o}}\IX{\TT{.f.o}}\IX{\TT{.y.c}}\IX{\TT{.l.c}}
\IX{\TT{.n.o}}\IX{\TT{.a.o}}\IX{\TT{.p.o}}\IX{\TT{.o.r}}
\IX{\TT{.tex.dvi}}\IX{\TT{.web.p}}\IX{\TT{.web.tex}}
\IX{\TT{.herman.help}}\IX{\TT{.cap.dvi}}\IX{\TT{.cap.herman}}
\IX{\TT{CC}}\IX{\TT{COPTS}}\IX{\TT{PL6}}\IX{\TT{PL6OPTS}}
\IX{\TT{FORTRAN}}\IX{\TT{FORTOPTS}}\IX{\TT{YACC}}\IX{\TT{YACCOPTS}}
\IX{\TT{LEX}}\IX{\TT{LEXOPTS}}\IX{\TT{PARTRGE}}\IX{\TT{PARTOPTS}}
\IX{\TT{BMAP}}\IX{\TT{BMAPOPTS}}\IX{\TT{PASCAL}}\IX{\TT{PASCOPTS}}
\IX{\TT{LINK}}\IX{\TT{LINKOPTS}}\IX{\TT{TEX}}\IX{\TT{TEXOPTS}}
\IX{\TT{HERMAN}}\IX{\TT{HERMOPTS}}
\IX{\TT{CAP}}\IX{\TT{TANGLE}}\IX{\TT{WEAVE}}\IX{\TT{CAPFMT}}
\IX{\TT{CAPDEV}}
\IX{\TT{JOBOPTS}}\IX{\TT{RESOPTS}}
 
\L0{Chaining Implicit Rules}          \HH{CHAINING RULES||S}
 
Sometimes a target is made by a series of implicit rules.
For example, the file ``\TT{gram.o}'' could by produced by
first using \TT{BISON.X} to translate a grammar file into
a C source file and then using \TT{CC} to translate the
C source file into the target object unit.
Such a series of operations is called a \SL{chain}.
\IX{chain}
By default, \MAKE\ looks for a ``\TT{.y}'' file before looking for
a ``\TT{.c}'' file because of the built-in rule ``.y.c'' which
tells \MAKE\ that a C source file can be produced.
In this case, when a ``\TT{.y}'' file is found
\MAKE\ automatically includes the
steps to use \TT{BISON.X}.
 
\MAKE\ recognizes an implicit rule appearing more than
once in a chain and stops following the chain,
preventing the possibility of an
infinite loop in the search for an implicit rule.
 
\CH{Using Electronic Mail||SE}\HH{EMAIL}
 
\MAKE\ can be requested to automatically send electronic mail
to owners of target files when running the commands to build a
target have failed.
The ``\TT{-e}'' option controls this feature and provides the
user of \MAKE\ with the ability to notify other project members
when problems occur.
If the ``\TT{-e}'' option is used,
when \MAKE\ completes execution and prints its summary of
errored targets,
it also sends mail to the owners of the targets (one mailgram for
each owner with all of their errors).
If the ``\TT{-ee}'' option is used,
in addition to the summary at the end of the \MAKE\ execution,
mailgrams are sent when the error is detected to the owner
of the failing target file with the name of the \SL{diagnostic file}
(including up to 12 lines of diagnostics)
or a message indicating that the target file was not created.
\IX{diagnostic output}\IX{\TT{-e}}
 
 
\L0{Controlling the Mailgram Contents}   \HH{MAILGRAMS}
 
\MAKE\ uses variables for various fields in the mailgram.
The following table indicates the names of the variables
and their use.
 
\TB{Mailgram Variables}
\TH{Variable \TC Use \TC Default Value}
\TT{MAIL_SUBJECT}   \TC Mailgram subject field    \TC \TT{Integration Failure!} \TX
\TT{MAIL_COPY}      \TC Summary mailgram copy list\TC                    ~      \TX
\TT{MAIL_BODY}      \TC Target failure mailgram body\TC\TT{~has failed!}        \TX
\TT{MAIL_SUMMARY}   \TC Summary mailgram body       \TC\TT{The following have failed:}
 
\TB
\IX{\TT{MAIL_SUBJECT}}\IX{\TT{MAIL_COPY}}\IX{\TT{MAIL_BODY}}
\IX{\TT{MAIL_SUMMARY}}
 
The variable \TT{MAIL_COPY} is used for the ``\TT{cc:}'' mail option
to send a copy of each of the summaries to a mail address (usually
the project leader).
The variable \TT{MAIL_BODY} is used to create a message of the form:
{\FIF\SL
 
  filename \TT{MAIL_BODY} problem
 
}
where \SL{filename} is the name of the failing target file and
\SL{problem} is the reason that it failed.
 
The variable \TT{MAIL_SUMMARY} is used to create a message of the
form:
{\FIF\SL
 
\TT{MAIL_SUMMARY}
filename
filename
\vdots
 
}
 
Figure 8--1 shows an example of a summary mailgram as received by
the owner of the files ``\TT{a.o}'' and ``\TT{b.o}''.
The owner of the files in this example is ``Bill Worker'' and the
person running \MAKE\ was ``Joe Control''.
The variables which control the mailgram contents had their
default values.
 
\FG{Electronic Mail Summary Mailgram||COMPRFLOAT}  \INL{1}
 
    Sent: 09/14/89 10:25  Rcvd: 09/14/89 10:25  Number: 147
      To: Bill Worker                             From: Joe Control
 Subject: Integration Failures!
 
The following have failed:
 a:o
 b:o
 
...MAKE.
 
\FG
 
Using this same example, if \MAKE\ had been run with the ``\TT{-ee}''
option,
then Bill Worker would have received two mailgrams before the summary
mailgram with specific information about the failures.
The mailgram that Bill Worker received for the failure of \TT{b.o}
would look like Figure 8-2.
 
\FG{Electronic Mail Error Mailgram||COMPRFLOAT} \INL{1}
 
    Sent: 09/14/89 10:25  Rcvd: 09/14/89 10:25  Number: 146
      To: Bill Worker                             From: Joe Control
 Subject: Integration Failures!
 
b:o has failed! See diagnostics file: b:o:do
 
Diagnostic file contents:
 
CC.B00 here at 10:25 Thu Sep 14 1989
    2.000         2               int c;
"*b:c", line 2: c not in parameter list
"*b:c", line 2: (warning) identifier "cc" is not used
 
...MAKE.
 
\FG
 
\L0{Owner Syntax}                        \HH{OWNERS}
 
To indicate the owner of a target file, a line with the following
form is written in the \Makefile:
 
{\SL\FIF
 
  email address  \TT{:=} targetlist
 
}
The \SL{email address} is a valid \CPSIX\ mail address.
There is only one owner permitted for any target file.
The \SL{targetlist} is zero or more make file names, separated
by blanks or commas.
 
\L0{Obtaining Ownership Information}     \HH{LISTING_OWNERS}
 
When the ``\TT{-e}'' option is used, the output of the ``\TT{-a}''
option is changed to indicate the owner of the file associated
with each action found in the \Makefile\/ in place of file timestamps.
This is sufficient to provide verification that for every possible
step in the \Makefile, that there is an owner.
 
The following figure shows a sample \Makefile\/ and an execution
of \MAKE\ demonstrating the output of the ``\TT{-a}'' option when
used in conjunction with the ``\TT{-e}'' option.
 
\FG{File Ownership Display||COMPR}    \INL{1}
 
!e MakeErrors
EDIT E00 here
*ty 1-10
    1.000 # Makefile to demonstrate electronic mail
    2.000
    2.100 RESOPTS    =  Mem=511,Time=3
    3.000 CC         = CC.:ZBDVGN
    4.000 COPTS      = (SR(.:LIBRARY))
    5.000 OBJS       = a.o b.o c.o
    6.000
    7.000 a    :  $(OBJS)
    8.000   link $^ over $@
    9.000
   10.000 Bill Worker :=  a $(OBJS)
*q
!MAKE. -aeenf MakeErrors
 
Target       State Cmd Output File       Input File           Owner
a.o          waiti   0 a:o               a:c.MYACCT           Bill Worker
b.o          waiti   0 b:o               b:c.MYACCT           Bill Worker
c.o          Compl   0 c:o.MYACCT        c:c.MYACCT           Bill Worker
a            waiti   1 a                                      Bill Worker
 
 
Commands:    .c.o a
 
*  Dependency wait=3, Waiting to run=0, Running=0, Errored=0, Completed=1
*  Ready to run: a.o b.o
 
!CC.:ZBDVGN a:c.MYACCT over a:o,NO (SR(.:LIBRARY))
 
!CC.:ZBDVGN b:c.MYACCT over b:o,NO (SR(.:LIBRARY))
 
*  Ready to run: a
*  Dependency wait=0, Waiting to run=1, Running=0, Errored=0, Completed=3
 
!link a:o,b:o,c:o.MYACCT over a
 
 
***
*** Build Complete!
***
!
 
\FG
 
 
 
 
 
 
\CH{Directives||SE} \HH{DIRECTIVES}
 
\IX{directives}
Directives appear in the \Makefile\/ and always begin with a
``\TT{:}'' as their first character, followed by the keyword
name of the directive and any arguments associated with the
directive.
Directives are executed by \MAKE\ as the \Makefile\/ is being
read.
There are three kinds of directives:
\PL{BL}
\PI \SL{Conditional Directives} allow portions of the
     \Makefile\/ to be skipped.
 
\PI \SL{Include Directives} cause other \Makefile{}s to
     be read.
 
\PI \SL{Message Directives} display messages to the
     \MAKE\ user.
\PL
 
\SB{HELP}
The following topics contain more information on directives:
\TT{CONDITIONAL_DIRECTIVES},
\TT{INCLUDE_DIRECTIVE},
and \TT{MESSAGE_DIRECTIVE}.
\SB
 
\L1{Conditional Directives}  \HH{CONDITIONAL_DIRECTIVES}
 
 
\SL{Conditionals} cause part of a \Makefile\/ to be obeyed
or ignored depending on the values of expressions.
Conditionals can compare the value of one variable
with another, or the value of a variable with a constant
string.
Conditionals control what \MAKE{} actually ``sees'' in the
\Makefile, but they do not control commands at the time of
execution.
 
 
\L2{Example of a Conditional}   \HH{EXAMPLE||S}
 
The following conditional is used to select one
library if the \TT{CC} variable is \TT{CC.:SYS}
and a different library otherwise.
It works by controlling which of two command lines will
be used as the command for a rule.
The result is that \TT{'CC=CC.:SYSTEST'} as an argument
to \MAKE{} not only changes which compiler is used but
also which shared library is used.
 
\FG{Conditional Example||COMPR}       \INL{1}
test_lib    = :SHARED_C
normal_lib  = :SHARED_C_TEST
 
foo: $(objects)
:if  CC != "CC" && CC != "CC.:SYS"
        link  $(objects) over $@ (sharelib=$(test_lib))
:else
        link  $(objects) over $@ (sharelib=$(normal_lib))
:endif
\FG
 
This conditional uses three directives: \TT{:if},  \TT{:else}
and \TT{:endif}.
 
The \TT{:if} directive contains an expression that is evaluated as
\MAKE{} reads the \Makefile.  If the expression's value is \SL{true}
then the \Makefile\/ records up to the \TT{:else} (in this
example) are included.
Otherwise the records following the \TT{:else} (in this example)
are included.
Variable substitution is performed on the conditional lines before
the expression is evaluated.
 
The \TT{:else} directive causes the following lines to be obeyed
if the previous conditional failed.  In the example above, this
means that the second \TT{link} command is used whenever the first
is not used.  It is optional to have an \TT{:else} in a conditional.
 
The \TT{:endif} directive ends the conditional.
Conditionals may not be continued across \TT{:include} files.
Unconditional \Makefile\/ text follows this command.
 
\HH{||B}
 
When the variable \TT{CC} has the value \TT{CC} or \TT{CC.:SYS}
the above example has this effect:
 
\FG{Conditional example: What \TT{MAKE} sees if False||COMPR}  \INL{1}
foo: $(objects)
        link  $(objects) over $@ (sharelib=$(normal_lib))
\FG
 
 
When the variable \TT{CC} has any other value, this effect
is this:
 
\FG{Conditional example: What \TT{MAKE} sees if True||COMPR}  \INL{1}
foo: $(objects)
        link  $(objects) over $@ (sharelib=$(test_lib))
\FG
 
Equivalent results can be obtained in another way by using a
conditional statements to affect variable assignment and
then using the variable unconditionally.
 
 
\L2{Conditional Blocks}   \HH{SYNTAX||B}
 
Many of the \SL{conditional}\/ commands have arguments which are
expressions.
Expressions are defined
\SB{HELP} under the topic \TT{EXPRESSION_EVALUATION}.
\SB{} later in this section under the heading ``\IT{Expression Evaluation}''.
\SB.
 
Portions of \Makefile{}s are conditionally skipped or included
by using the following directives:
 
\PL{BL}
\PI  \TT{:if} starts a conditional \Makefile\/ section,
\PI  \TT{:elif} conditionally includes section,
\PI  \TT{:else} includes section if nothing else has been included,
\PI  \TT{:endif} terminates the current block.
\PL
 
\FG{Conditional Body||COMPR}       \INL{1}
:if expression
~~~~\vdots
\SL{text-if-:if-true}
~~~~\vdots
:elif expression
~~~~\vdots
\SL{text-if-:elif-true}
~~~~\vdots
:else
~~~~\vdots
\SL{text-if-others-false}
~~~~\vdots
:endif
\FG
 
The \SL{text-if-:if-true} may be any lines of text,
to be considered as part of the \Makefile\/ if the condition
is \SL{true}.  If the condition is \SL{false}, lines within the
\Makefile\/ are skipped up to the next \TT{:elif}, \TT{:else}
or \TT{:endif}.
The remaining sections of a conditional body up through
the \SL{text-if-others-false} are optional.  The \TT{:else}
section (if any), must be the last section of the
conditional body.
Each of the conditional sections that is included may be any
number of lines as long as the conditional body ends before
the end of the file.
Only one section of a conditional body is ever included,
even if multiple \TT{:elif} expressions are \SL{true}, in fact,
\TT{:elif} expressions are not evaluated if a section has
already been included from the conditional body.
 
Conditionals work at the textual level.  The lines of the
\SL{text-if-true} are read as part of the \Makefile\/ if
the condition is \SL{true;}
if the condition is \SL{false,} those lines are ignored completely.
Syntactic units of the \Makefile,
such as rules, may safely be split across the beginning
or the end of the conditional.
 
An \TT{:include} directive may be used  within a conditional,
but it may not start a conditional in one file and end it in
another.
 
Extra spaces are allowed and ignored at the beginning of the
conditional directive line.
Aside from this, extra spaces
may be inserted with no effect anywhere except within the directive
name or within an argument.
Comments beginning with ``\TT{#}'' may appear at the end of the
\TT{:if}, \TT{:elif}, \TT{:else} and \TT{:endif} directives.
\SB{HELP} Specific information on each of the
\SL{conditional directives} can be found under the \TT{HELP}
topics:
\TT{IF_DIRECTIVE}, \TT{ELIF_DIRECTIVE}, \TT{ELSE_DIRECTIVE}
and \TT{ENDIF_DIRECTIVE}.
\SB
 
\L3{The \TT{:if} Directive}  \HH{IF_DIRECTIVE}
 
\PL{DE}
\PI{Syntax}
 
\TT{:if} \SL{expression}
 
\PI{Parameters}
 
\SL{expression} ~~~~ is an expression that is
evaluated for \SL{true} or \SL{false}.
 
\PI{Description}
 
If the expression \SL{expression} has the \SL{true} value, then
the lines following this directive are included up to the next
conditional: \TT{:elif} or \TT{:else}.
The \TT{:if} directives may be nested (to a depth of 99) and
\MAKE{} understands nested blocks that are being skipped or
included.
 
\PL
 
 
\L3{The \TT{:elif} Directive} \HH{ELIF_DIRECTIVE}
 
\PL{DE}
\PI{Syntax}
 
\TT{:elif} \SL{expression}
 
\PI{Parameters}
 
\SL{expression} ~~~~ is an expression that is
evaluated for \SL{true} or \SL{false}.
 
\PI{Description}
 
If no text has been inserted in the current conditional block
and if the expression \SL{expression} has a \SL{true} value,
then the lines following this directive up to the next \TT{:elif}
or \TT{:else} are included.
 
\PL
 
 
\L3{The \TT{:else} Directive} \HH{ELSE_DIRECTIVE}
 
\PL{DE}
\PI{Syntax}
 
\TT{:else}
 
\PI{Description}
 
If no text has been inserted in this conditional block already,
then the lines following this directive up to the next \TT{:elif}
or \TT{:else} are included.
 
\PL
 
 
\L3{The \TT{:endif} Directive}  \HH{ENDIF_DIRECTIVE}
 
\PL{DE}
\PI{Syntax}
 
\TT{:endif}
 
\PI{Description}
 
This directive signals the end of a conditional block and
stops the skipping of lines (if this is not a nested block).
If the block is nested, then the skipping or inclusion of
lines reflects the state of the next outer conditional block.
 
\PL
 
 
 
\L1{Include Directive} \HH{INCLUDE_DIRECTIVE}
 
The \TT{:include} directive may be used to request \MAKE{} to
suspend reading the current \Makefile\/ and read another file
before continuing.
This directive allows common \Makefile\/ lines to be shared
by more than one \Makefile.  Of course, the included file can
use the other conditional directives to tailor itself to the
current usage.
 
\IX{\TT{-i}}\IX{search list}
The ``\TT{-i}'' command line option affects the way in which
include files are located.
If an account is not specified in the \TT{:include} directive,
then \MAKE{} uses the search list set up by the ``\TT{-i}''
option to locate the file.
The last entry in the search list is always the current file
management account.
 
Up to 11 search paths may be specified on the \MAKE{} invocation.
The \TT{-i} option permits the search path to be specified in one
of three ways:
 
\PL{SYNTAX}
\PI{-iACCOUNT}   \HH{ACCOUNT} a simple account
     \SB{HELP} specification of the form \TT{-iACCOUNT}.
     \SB{} specification.
     \SB
     A \CPSIX\ fid is constructed by preceding the \TT{ACCOUNT}
     with the name of the include file and a ``\TT{.}''.
 
\PI{-iNAME.ACCOUNT} \HH{NAME_ACCOUNT} a file name and account
     \SB{HELP} specification of the form \TT{-iNAME.ACCOUNT}.
     \SB{}     specification.
     \SB
     A \CPSIX\ fid is constructed by inserting the name on the
     \TT{:include} command immediately before the ``\TT{.}''.
 
\PI{-iWILD?NAME.ACCOUNT}  \HH{WILD_ACCOUNT} a wild-carded file
     name and account
     \SB{HELP} specification of the form \TT{-iWILD?NAME.ACCOUNT}.
     \SB{}     specification.
     \SB
     A \CPSIX\ fid is constructed by replacing the ``\TT{?}''
     character with the file name on the \TT{:include}
     command.
\PL
 
 
\L3{The \TT{:include} Directive}  \HH{INCLUDE_DIRECTIVE||B}
 
\PL{DE}
\PI{Syntax}
 
\TT{:include} \SL{filename}
 
\PI{Parameters}
 
\SL{filename} ~~~~ is the name of the file to
be included.  If the \SL{filename} does not contain the
character ``\TT{.}'', then the search list (created by the
\TT{-i} option) is used to look for the file.
 
\PI{Description}
 
This directive causes \MAKE{} to suspend reading the current
\Makefile\/ and start reading the file located using the
\SL{filename} option.
When the end of that file is reached, \MAKE{} will continue
reading the current \Makefile.
\TT{:include} directives may be nested up to 10 files deep.
 
Uses for \TT{:include} directives include:
 
\PL{BL}
\PI  sharing common sets of variable definitions,
\PI  sharing common sets of rules,
\PI  reading automatically generated dependencies.
\PL
 
\PI{Example}
 
If a file named ``\TT{CommonRules}'' contained some rules that
were common to a number of projects, then the following
command in a \Makefile\/ would cause those rules to be
included.
 
{\FIF\INL{4}\TT
 
:include  CommonRules     # define some special implicit rules
 
}
\PL
 
 
 
\L1{Message Directives} \HH{MESSAGE_DIRECTIVES}
 
\CPSIX\/ \MAKE\ provides two directives which allow the
\Makefile\/ writer to communicate with the user of \MAKE.
The directives \TT{:error} and \TT{:print} may be used
when the \Makefile\/ has been used incorrectly (such as when
required variable definitions are missing).
 
These directives take \SL{expressions}\/ as their arguments
and display them to the user.
The only difference between the two directives is that the
\TT{:error} directive includes the linenumber and the name
of the file being read with the message (and incriments the
number of errors reported if the verbose option ``\TT{-v}''
is used).
The following figure demonstrates the use of the message
directives to display messages.
 
\FG{Message Directive Example||COMPR} \INL{1}
 
!MAKE.:ZBBJFGN -f MakeMyDay 'VERSION=E0A' -p
     1: :print "The variable YACC contains: """, YACC, """"
The variable YACC contains: "BISON.X"
     2:
     3: :error "Don't know how to link for version: """, VERSION, """"
"MakeMyDay" line 3: Don't know how to link for version: "E0A"
     4:
 
 One Error and No Warnings in Makefile
 
\FG
 
\SB{HELP}
For more information on the individual directives, see the
\TT{HELP} topics: \TT{PRINT_DIRECTIVE} and \TT{ERROR_DIRECTIVE}.
\SB
 
 
\L3{The \TT{:print} Directive}  \HH{PRINT_DIRECTIVE}
 
\PL{DE}
\PI{Syntax}
 
:print  \SL{expression},\SL{expression},\SL{expression},...
 
\PI{Parameters}
 
\SL{expression} ~~~~ is an expression that evaluates
to an integer, a string or a variable reference.
 
\PI{Description}
 
The text formed by joining all of the expression results
together is dislayed.
 
\PL
 
 
 
\L3{The \TT{:error} Directive}  \HH{ERROR_DIRECTIVE}
 
\PL{DE}
\PI{Syntax}
 
:error  \SL{expression},\SL{expression},\SL{expression},...
 
\PI{Parameters}
 
\SL{expression} ~~~~ is an expression that evaluates
to an integer, a string or a variable reference.
 
\PI{Description}
 
This message is created by joining the name of the file
being read in double quotes, followed by the line number
and finally the text formed by joining all of the
expression results together.
 
\PL
 
 
\L1{Expression Evaluation}      \HH{EXPRESSION_EVALUATION}
 
\MAKE\ evaluates expressions for the following directives:
\TT{:if}, \TT{:elif}, \TT{:error} and \TT{:print}.
These directives produce result values for two different
purposes.
The \TT{:if} and \TT{:elif} directives need a \SL{true} or
\SL{false} value to determine whether to conditionally
include statements from the \Makefile.
The \TT{:error} and \TT{:print} directives need a display
form of the expression result value.
 
 
\L2{Expression Values}          \HH{VALUES||S}
 
Expressions are always evaluated the same way.  Expressions
are made up of the following kinds of values:
 
\IX{integers} \IX{quoted integers} \IX{strings} \IX{variables}
\PL{BU}
\PI  \SL{Integers}\/ which consist of the digits 0 through 9.
 
\PI  \SL{Quoted Integers}\/ which consist of up to 4 characters
     within single quotes ``\TT{'}''.
 
\PI  \SL{Strings}\/ which consist of a string of characters
     started and terminated by a ``\TT{"}'' character.
     If the ``\TT{"}'' character is required within the
     string, it must be doubled.
 
\PI  \SL{Variables}\/ which are references to variables within
     the current \Makefile.
\PL
 
Expressions can use the above values to produce new values
through arithmetic operations, comparison operations,
logical operations or through existance testing for variables.
The operators provided by \MAKE\ are a subset of those
available in the C programming language and full details
about their meaning can be found in the C language manual.
 
\SL{Strings}\/ may only be used in comparison operations and
as display values.  Their logical value is always \SL{true}.
 
\SL{Integers}\/ and \SL{Quoted Integers}\/ may be used in
arithmetic and comparison operations.  Their logical value
is \SL{true} if their value is non-zero, otherwise it is
\SL{false}.
 
\SL{Variables} may be used in arithmetic, comparison and
existance testing.  A bare variable reference by itself
is an existance test, or the ``\TT{defined}'' operation
may be applied to a variable name when a more general
expression is required.
When a variable reference appears in an expression, it
is treated as a string if the other operand to the operation
is a string, or it is treated as an integer if the other
operand is a number.
 
 
\L2{Operators}                  \HH{OPERATORS||S}
 
Expressions may contain operators which a divided into
four general categories:
arithmetic operators,
relational operators,
logical operators,
and the variable existance testing operator.
 
The following table indicates the precedence of the
available operators.
 
\TB{Operator Precedence}
\TH{Operators                         \TC   Associativity }
 
\TT{ ()                          }    \TC   left to right        \TE
\TT{ ! \~~ - sizeof defined      }    \TC   right to left        \TE
\TT{ * / %                       }    \TC   left to right        \TE
\TT{ + -                         }    \TC   left to right        \TE
\TT{ << >>                       }    \TC   left to right        \TE
\TT{ < <= > >=                   }    \TC   left to right        \TE
\TT{ ==  !=                      }    \TC   left to right        \TE
\TT{ &                           }    \TC   left to right        \TE
\TT{ ^                           }    \TC   left to right        \TE
\TT{ |                           }    \TC   left to right        \TE
\TT{ &&                          }    \TC   left to right        \TE
\TT{ ||                          }    \TC   left to right
\TB
 
The \TT{sizeof} function when applied to a variable reference
returns the length of the variable replacement text.
When \TT{sizeof} is applied to a string, it returns the
length of the string.
 
\SB{HELP}
More information on the individual operators may be found under
the following \TT{HELP} topics:
\TT{ARITHMETIC_OPERATORS}, \TT{RELATIONAL_OPERATORS},
\TT{LOGICAL_OPERATORS} and \TT{EXISTANCE_OPERATOR}.
\SB
 
\L3{Arithmetic Operators}       \HH{ARITHMETIC_OPERATORS}
 
The following arithmetic operators take two arguments which
must both be integers.  The general syntax is:
``\TT{A}~\IT{op}~\TT{B}'' where \IT{op} is one of the
following operators:
 
\IX{addition operator} \IX{\TT{+} operator}
\IX{subtraction operator} \IX{\TT{-} operator}
\IX{multiplication operator} \IX{\TT{*} operator}
\IX{division operator} \IX{\TT{/} operator}
\IX{modulo operator} \IX{\TT{%} operator}
\IX{left shift operator} \IX{\TT{<<} operator} \IX{shift operator}
\IX{right shift operator} \IX{\TT{>>} operator}
\IX{bitwise and operator} \IX{\TT{&} operator} \IX{and operator}
\IX{bitwise or operator}  \IX{\TT{|} operator} \IX{or operator}
\IX{bitwise exclusive or operator} \IX{\TT{^} operator}
\IX{exclusive or operator}
\PL{SYNTAX}
\PI{+}  \HH{ADDITION}      \SB{HELP}\TT{+} \SB the sum of \TT{A} and \TT{B},
\PI{-}  \HH{SUBTRACTION}   \SB{HELP}\TT{-} \SB subtracts B from \TT{A},
\PI{*}  \HH{MULTIPLICATION} \SB{HELP}\TT{*} \SB multiplies \TT{A} and \TT{B},
\PI{/}  \HH{DIVISION}      \SB{HELP}\TT{/} \SB divides \TT{A} by \TT{B},
\PI{%}  \HH{MODULUS}       \SB{HELP}\TT{%} \SB returns integer remainder of
                           \TT{A} divided by \TT{B},
\PI{<<} \HH{LEFT_SHIFT}    \SB{HELP}\TT{<<} \SB shifts bits in \TT{A}
                           left by \TT{B} positions,
\PI{>>} \HH{RIGHT_SHIFT}   \SB{HELP}\TT{>>} \SB shifts bits in \TT{A}
                           right by \TT{B} positions,
\PI{&}  \HH{AND} \SB{HELP}\TT{&} \SB computes the bitwise and of
                           \TT{A} and \TT{B},
\PI{|}  \HH{OR}  \SB{HELP}\TT{|} \SB computes the bitwise or of \TT{A}
                           and \TT{B}, and
\PI{^}  \HH{EXCLUSIVE_OR} \SB{HELP}\TT{^} \SB computes the bitwise
                          exclusive or of \TT{A} and \TT{B}.
\PL
 
\HH{||B}
 
The following arithmetic operators take a single argument which
must be numeric (with the exception of the \TT{sizeof} function
whose argument must be a \IT{string}).  The general form syntax
is ``\IT{op}~\TT{B}'' where \IT{op} is one of the following
operators:
 
\IX{negation operator}
\IX{logical complement operator} \IX{\TT{!} operator}
\IX{bitwise inversion operator} \IX{\TT{\~~} operator}
\IX{not operator} \IX{invert operator} \IX{\TT{sizeof} operator}
\PL{SYNTAX}
\PI{-}  \HH{NEGATION} \SB{HELP}\TT{-} \SB subtracts \TT{B} from zero,
\PI{+}  \HH{NOP}      \SB{HELP}\TT{+} \SB leaves \TT{B} unchanged,
\PI{!}  \HH{LOGICAL_NOT} \SB{HELP}\TT{!} \SB if \TT{B} is 0, returns 1,
                      otherwise returns 0,
\PI{\~~}\HH{NOT}      \SB{HELP}\TT{\~~} \SB inverts all of the bits
                      in \TT{B}.
\PI{sizeof(B)} \HH{SIZEOF} \SB{HELP}\TT{sizeof(B)} \SB returns
                      the integer length of string \TT{B}.
\PL
 
With the exception of the \TT{sizeof} operator, the
arguments to these functions must also be numbers.
If a variable reference is one of the operands, it is
converted into an integer.  If it contains any non-digits,
the result is an error.
 
 
\L3{Relational Operators}          \HH{RELATIONAL_OPERATORS}
\IX{comparison operators}
 
All of the relational operations compare two arguments
which are both either integers or strings.  The general
syntax is: ``\TT{A}~\IT{op}~\TT{B}'', where \IT{op} is
one of the following operators:
\IX{less than operator}\IX{\TT{<} operator}
\IX{greater than operator}\IX{\TT{>} operator}
\IX{less than or equals operator}\IX{\TT{<=} operator}
\IX{greater than or equals operator}\IX{\TT{>=} operator}
\IX{equals operator} \IX{\TT{==} operator}
\IX{not equals operator} \IX{\TT{!=} operator}
\PL{SYNTAX}
\PI{<}  \HH{LESS} \SB{HELP}\TT{<} \SB returns 1 if A is less than B, otherwise 0.
\PI{>}  \HH{GREATER} \SB{HELP}\TT{>} \SB returns 1 if A is greater than B, otherwise, 0.
\PI{<=} \HH{LESS_EQUAL} \SB{HELP}\TT{<=} \SB returns 1 if A is less than or equal to B,
                        otherwise 0.
\PI{>=} \HH{GREATER_EQUAL} \SB{HELP}\TT{>=} \SB returns 1 if A is greater than or equal
                        to B, otherwise 0.
\PI{==} \HH{EQUALS}  \SB{HELP}\TT{==} \SB returns 1 if A is equal to B, otherwise 0.
\PI{!=} \HH{NOT_EQUALS} \SB{HELP}\TT{!=} \SB returns 1 if A is not equal to B, otherwise 0.
\PL
 
These operators work on arguments that are both
arithmetic or both strings.  An error is reported if
their types are mixed.
If one of the operands is a variable reference, the
variable is converted to the same type as the other
operand.  If both operands are variable references,
they are both treated as strings.
 
\L3{Logical Operators}             \HH{LOGICAL_OPERATORS}
 
The logical operators take operands of any type and return
either 1 if the logical relationship is \SL{true} or 0 if it
is \SL{false}.
The general syntax of the logical operators is
``\TT{A}~\IT{op}~\TT{B}'' where \IT{op} is one of the
following operators:
 
\IX{logical and} \IX{logical or} \IX{\TT{&&} operator}
\IX{\TT{||} operator}
\PL{SYNTAX}
\PI{&&}    \HH{AND} \SB{HELP}\TT{&&} \SB if both the left and right operands are \SL{true},
           then the result is 1, otherwise 0.
 
\PI{||}    \HH{OR}  \SB{HELP}\TT{||} \SB if either of the left or right operands is \SL{true},
           then the result is 1, otherwise 0.
\PL
 
\L3{Existance Operator}    \HH{EXISTANCE_OPERATOR}
 
\IX{variable}
\IX{\TT{defined} operator}
A variable reference by itself or as an argument to the
logical and (\TT{&&}) or logical or (\TT{||}) functions
is treated as an existance test.
An existance test returns the value 1 if the variable
has been defined, otherwise it returns 0.
 
If a more complex expression is required, the function
\TT{defined} is available which returns 1 if the
variable argument exists or 0 if it does not.
 
\L2{Expression Results}      \HH{EXPRESSION_RESULTS}
 
Expressions are used to control the inclusion of
\Makefile\/ records or to print messages to the user.
When the result of the expression is used to control
the inclusion of records, the expression is said to return
a \SL{true} or \SL{false} value according to the following
rules based upon the value type:
 
\PL{DI}
\PI{Integers} have the value \SL{true} if their value is non-zero,
              otherwise they have the value \SL{false}.
 
\PI{Strings}  always have the value \SL{true}.
 
\PI{Variables} have the value \SL{true} if they have a value,
               otherwise they are undefined and have the
               value \SL{false}.
\PL
 
When the result of the expression is used to display
a message,
the actual value of the expression is displayed, which
are strings or integer values.
Undefined variable references cause no addition to the
display at all, whereas defined variable references display
the value of the variable.
 
 
 
 
\CH{Non-Standard Features of CP-6 MAKE||SE}\HH{DIFFERENCES}
 
 
 
\UNIX\ \TT{make} has some features that are not
implemented or are implemented differently in \CPSIX\ \MAKE.
A summary of these follows:
 
\PL{BU}
\PI Features associated with access to \TT{SCCS} or \TT{RCS} are
not implemented in \CPSIX\ \MAKE.
 
\PI  Commands used to build targets are signified by leading blanks
     or tabs.  Most other \TT{make} programs insist upon leading tabs.
 
\PI Variables are not recursively defined.  Their current value is
simply expanded wherever it appears.  This means that \MAKE\ cannot
get into an infinite loop referencing a variable but it also
forces the \Makefile\ to be written without forward references
to variables.
 
\PI Commands to build targets are executed via batch jobs.
This prevents any interaction with the user of \MAKE\ within
the \Makefile, or the use of \CPSIX\ star files as targets.
 
\PI Recursive invocation of \MAKE\ may not work as expected.
This is because by default a batch job is used to run the next \MAKE.
 
\PI  The \TT{.IGNORE}, \TT{.DEFAULT}  and \TT{.SILENT} pseudo-targets
are not supported.
 
\PI Double colon rules are not supported.
 
\PI The meaning of modified variable references is slightly different.
A modified reference may replace a string anywhere it occurs within
the variable value.
 
\PI Commands must not be attached to the rule line via a ";".
Commands always follow the rule on the next line with one or
more leading blanks or tabs.
 
\PI When looking for implicit rules to build a target,
\CPSIX\ \MAKE\ finds the longest path of implicit rules
that will generate the target.  Many other \MAKE\ programs
require that all of the intermediate files exist for each
of the intervening steps.
 
\PL
 
 
\SB{HELP}
\L0{OWNER}
Bruce Frost, LADC
\L0{XINDEX}
\PL{STANDARD}
\PI{MAKE.X}
\PI AID=PROGRAMMING
\PI AID=INTEGRATION
\PI AID=UTILITY
\PI AID=PROJECT_MANAGEMENT
\PI BATCH_JOBS
\PI CONVERSION
\PI FILE_MANIPULATION
\PI RUNUNIT_MANIPULATION
\PI OBJECT_UNIT_MANIPULATION
\PI LINKING
\PI UNIX
\PL
\L0{XINDEX_ABSTRACT}
\MAKE\ uses a \Makefile\ database,
file timestamps,
\IBEX\ command variables
and file dependencies
to keep files up-to-date using built-in \IBEX\ commands
or \IBEX\ commands supplied in the \Makefile.
 
\L0{CHANGES}
07/16/90 \BRL Fixed a problem with the output of the \TT{-g} command.
Also, if this option is specified, \MAKE\ stops immediately after
generating the requested output file.  Additional information is
now printed when \MAKE\ is unable to create a temporary file
for its jcl.
 
Fixed a bug in the generation of the \TT{$^} variable.
 
Implemented implicit commands for the use of \TT{MIDGET.X}
to generate dependency files.
If MAKE has jit access, the current status line information
is maintained in CCBUF (for users equipped to be spies).
 
Changed the \TT{-t} option to check for failure to touch the
target.  In this case, \TT{MAKE} looks through the search
path for an existing version of the file and will copy it
or report an error.
\HH{||B}
05/21/90 \BRL Fixed a problem with replacing the default rules for
\TT{.jcl}, \TT{.xeq}, \TT{.end} and \TT{.xeqend}.
 
03/23/90 \BRL Fixed a problem with generating commands where a \UNIX\
style invokation option will not be broken until after at least
40 characters after the -? sequence.
 
Braces are now acceptable around variable references as in \UNIX\ (tm)
make.  Comments may be embedded in the build commands and are ignored.
Target names may contain a "-" character, although an initial "-"
will cause the name to be treated as a C style command line option
when creating jcl.
 
When multiple targets are specified as having the same build rule,
the treatment by MAKE has been clarified.  If the variable
$@ or $(@F) is referenced in the build rules, the rule is applied
separately to each target.  Otherwise, the rule is treated as though
every target is created by one application of the rule.
 
 
02/26/89 \BRL It is now permitted to set the number of concurrent
batch jobs to 0 which is interpreted as meaning run all targets
online.
Implemented the -l option to provide fake :LIST files.
When variables are assigned values from the command-line, they are
no longer required to be within quotes if the entire variable
assignment contains no white space characters.
 
01/25/89 \BRL Fixed a bug in modified references when the reference
was previously undefined.
Corrected the \TT{-u} option to work with integrations.
Permitted the default \TT{.copy} and \TT{.fmt} rules
to be over-riden.
 
12/14/89 \BRL Added the ``-g'' option.  Corrected manual and helpfile
to mention the ``-m'' option.  Changed the default value of the CC
variable to be CC.
 
Implemented the processing of options within the \TT{MAKEFLGS}
variable.  This variable allows \MAKE\ options to be specified
as \TT{IBEX} variables or within the \Makefile.
 
The order in which MAKE considers implicit rules when searching for
files has been changed to first consider through implicit rules
defined within the \Makefile\/ (in the order in which they appeared
in the \Makefile), and then through the built-in rules in the order
in which they appear in the topic \TT{BUILT_IN_RULES}.
 
A problem expanding the parse work area has been corrected.
 
Targets which have dependencies or are themselves temporary files
will now be run as if they were dependents of ``\TT{.ONLINE}''.
 
 
11/03/89 \BRL Fixed a bug with really longgggg file names.
Fixed a bug in the default ``\TT{.xeq}'' rule.
Corrected the summary mailgram copy option.
 
10/20/89 \BRL Modified .y.c rule to work with latest BISON.X and
modified .l.c rule to use FLEX.X.
 
Various improvements to the MAKE manual and help file.
 
Improved performance during derivation phase.
 
10/09/89 \BRL Improved decision of when to copy a file in the SIPATH
into the OUPATH.  Now MAKE will not do this when the targets default
account is the first account in SIPATH and the file type is used in
an input rule.
 
The \TT{-ss} option causes the \IBEX\/ \TT{check} command information
not to be displayed when a running job's status changes.
 
The default rule for \TT{.c.o} has changed to be compatible
with the new C compiler.  In addition, the default value of
the \TT{CC} variable is (temporarily) \TT{CC.:SYSTEST}.
 
Implemented the following new \Makefile\/ directives: \TT{:if},
\TT{:elif}, \TT{:else}, \TT{:endif}, \TT{:include},
\TT{:error} and \TT{:print}.
 
09/18/89 \BRL Corrected the -u option to work.
 
The electronic mail option \TT{-e} has been added in addition to
the ability to specify the owner of a target file.
 
08/08/89 \BRL Changed the way LOPATH and DOPATH are used to generate
their file names.  These file names are generated using the entire
target name with any ``.'' characters turned into ':'.
The ``\TT{-k}'' option may be used to obtain the old behaviour.
 
A bug in the handling of more than 9 -c or -o options has been
corrected.
 
When a built-in variable contained a filename with a $ in it,
macro substitutions would occasionally occur.
Now dollar signs within built-in variables are not changed.
 
07/21/89 \BRL Improved initial HELP file topic.
 
Fixed a bug in the $? variable which caused it to not produce
its value.
 
Modified the logic used to produce the \TT{.ONLINE} commands.
They no longer require an IBEX go command and Makefiles which
use online targets may be run in batch.
 
The commands associated with the ".xeqend" target have been
changed.
 
If a target depends upon a target with the same base name and that
dependent target could produce the correct file type,
then the built in rule which uses that target will be used.
 
When \MAKE\ is searching for a built-in rule to produce a target
and it locates a target that is already built as a possible input,
it is NOT used.
 
When a file which has no built-in rules to produce it also has
dependencies, and those dependencies have actions associated with
them,
\MAKE\ will assume that the target is produced as a side-effect of
one of its dependencies.
 
\HH{||B}
6/21/89 \BRL Submitted to \TT{X} account.
\SB
 
 
 
\CH{|*|INDEX}
\IDX
