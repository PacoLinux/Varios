/*M* CP6-EXTRACT_SI62 - REPORT and its subroutines                */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* AND */
/***
***/
/*****************************************************************/
/***/
/*F*     NAME: ERRWTR
         PURPOSE: ERRor WriTeR will take the error and write out
                   the error to the error file specified. REC$ is
                   the pointer to the data in the data area.
                                                                 */
ERRWTR : PROC (DT_LST);
 
DCL CMT_NAME CHAR(35);
 
%INCLUDE EXTRACT_C1;
 
DCL 1 ERR_KEY ALIGNED STATIC SYMDEF,
      2 LEN# UBIN(9) UNAL,
      2 FCG(0:2) BIT(6) UNAL,
      2 MON_BIT BIT(1) UNAL,
      2 CODE# BIT(14) UNAL,
      2 MESS# BIT(3) UNAL,
      2 SEQ# UBIN(9) UNAL;
 
DCL 1 ERR_HASH REDEF ERR_KEY ALIGNED,
      2 LEN# UBIN(9) UNAL,
      2 FCG  UBIN(18) UNAL,
      2 NAME UBIN(9) UNAL,
      2 SEV  UBIN(9) UNAL,
      2 SEQ# UBIN(9) UNAL;
 
DCL 1 ERR_MESS ALIGNED,
      2 C ,
        3 SUBS BIT(1) UNAL,
        3 NOT_LAST BIT(1) UNAL,
        3 NA BIT(7) UNAL,
      2 DATA CHAR(115) UNAL;
 
DCL 1 SUB_LST CONSTANT ALIGNED,
      2 NUM# UBIN BYTE INIT(8),
      2 N_(0:8) CHAR(3) INIT('%AC','%FN','%SN','%DC',
        '%U1','%U2','%U3','%TA','%UF'),
      2 L#(0:9) UBIN BYTE INIT(2,2,2,2,2,2,2,2,2,1);
 
DCL ERR# UBIN WORD;
DCL RECNBR UBIN SYMREF;
DCL TBKNBR UBIN;
DCL TBTNBR UBIN;
DCL TMON BIT(1);
DCL KEY_FLG BIT(1) STATIC SYMDEF;
DCL R2NAME CHAR(31) STATIC SYMDEF;
 
DCL TXT_LN CHAR(140);
DCL BUFFER CHAR (4096)SYMREF;
DCL BUFFERU(0:1023) REDEF BUFFER UBIN;
 
DCL APPFLG BIT(1)SYMREF;
DCL MON_BIT BIT(1) SYMREF;
DCL STAT UBIN SYMREF;
DCL TIP UBIN SYMREF;
DCL KOUNT UBIN SYMREF;
 
DCL 1 DT_LST ALIGNED,
      2 MUD CHAR(31) UNAL,
      2 * UBIN BYTE UNAL,
      2 NAM CHAR(35) UNAL,
      2 TYP UBIN BYTE UNAL,
      2 LINE UBIN(27) UNAL,
      2 BLK# UBIN(27) UNAL,
      2 BYT# UBIN(18) UNAL;
 
 
DCL SIX_BIT BIT(6) BASED UNAL;
 
DCL TP1$ PTR;
 
DCL DBREAD ENTRY(3);
DCL APPWTR ENTRY(2);
DCL TELLER ENTRY(1);
DCL CHANG  ENTRY(3);
DCL CLSFIL ENTRY(2);
DCL OPNFIL ENTRY(8);
 
%FPT_READ(FPTN = READ);
%FPT_REW(FPTN = REWIND);
%FPT_GDS(FPTN=GDS,SEGSIZE=1024,RESULTS=SUBSV,STCLASS=CONSTANT);
 
DCL 1 SUBSV STATIC DALIGNED,
      2 WSIZ UBIN(18)UNAL INIT(0),
      2 * BIT(18),
      2 P$ PTR;
DCL NSUBS UBIN STATIC;
DCL 1 TEXTC BASED(PTR2$)ALIGNED,
      2 L UBIN BYTE UNAL,
      2 T CHAR(TEXTC.L);
DCL 1 SUBX(0:0)BASED(SUBSV.P$) ALIGNED,
      2 USED BIT(1),
      2 VAL UBIN(17)UNAL,
      2 TXT UBIN(18)UNAL;
 
DCL 1 OUT_TTL STATIC ALIGNED,
      2 * CHAR(4) INIT('Ao  ') UNAL,
      2 MN CHAR(31) UNAL,
      2 LN CHAR(5)  UNAL,
      2 * CHAR(1) INIT(' ') UNAL,
      2 TP CHAR(1) UNAL,
      2 * CHAR(1) INIT(' ') UNAL,
      2 NM CHAR(35) UNAL;
 
DCL TITLE REDEF OUT_TTL CHAR(78) ALIGNED;
 
DCL LAST_MUD CHAR(32) SYMREF;
 
DCL CMTTBL(0:11) CHAR(1) SYMREF;
DCL TRANSTBL(0:511) CHAR(1) UNAL SYMREF;
 
        IF KOUNT=1 AND APPFLG THEN CALL APPWTR;
/* INITIALIZE FOR A NEW KEY */
 
        IF LAST_MUD ~= DT_LST.MUD THEN DO;
           LAST_MUD = DT_LST.MUD;
           CALL CONCAT(OUT_BUFFER,'A   - Building from module ',LAST_MUD);
           CALL TELLER(0);
        END;
        ERR_KEY = '0'B;
        ERR_KEY.LEN# = 5;
        ERR_KEY.MON_BIT = MON_BIT;
        ERR_MESS.C.SUBS = FALSE;
        ERR_MESS.C.NOT_LAST = TRUE;
        ERR_MESS.C.NA = FALSE;
 
/* OK. NOW LETS MAKE A KEY */
 
        CMT_NAME = DT_LST.NAM;
        RECNBR = DT_LST.LINE;
        CALL INDEX1(I,'-',CMT_NAME);
        CALL INDEX1(J,'-',CMT_NAME,I+1);
        CALL INDEX1(K,' ',CMT_NAME,I+1);
        IF J < K THEN K = J;
        CALL INSERT(CMT_NAME,K,1,'*');
        IF I ~= 0 THEN ERR_KEY.FCG(0) = BINBIT(ASCBIN(SUBSTR(CMT_NAME,0,1)),6);
        IF I > 1 THEN ERR_KEY.FCG(1) = BINBIT(ASCBIN(SUBSTR(CMT_NAME,1,1)),6);
        IF I > 2 THEN ERR_KEY.FCG(2) = BINBIT(ASCBIN(SUBSTR(CMT_NAME,2,1)),6);
        IF NOT MON_BIT AND STAT = %OLDFILE# THEN KEY_FLG = %YES#;
        ELSE KEY_FLG = %NO#;
        PTR1$ = ADDR(SUBSTR(CMT_NAME,I+1,1));
        CHAR_LEN = K-I-1;
        TOKEN.LEN = K;
        TOKEN.CHR = SUBSTR(CMT_NAME,0,K);
        IF TIP = 3
        THEN DO;
           CALL HASH_NAME ALTRET(DONE);
           TMON = FALSE;
           GOTO AGAIN;
        END;
        I = 0;
        DO WHILE I<CHAR_LEN;
           IF SUBSTR(PTR1$->C7,I,1)<'0' OR SUBSTR(PTR1$->C7,I,1)>'9'
           THEN DO;
/* THE ERROR IS NOT NUMERIC. MUST USE SUBS FILE */
/* FIRST LETS SEE IF A SUBS FILE EXISTS FOR USAGE */
TRY_FILE:
              IF DCBADDR(R2UNIT)->F$DCB.ASN# ~= %FILE#
              THEN DO;
NO_SUB:
                 CALL TELLER(%NO_ERR_SUB);
                 RETURN;
              END;
              IF R2NAME~=' '
                AND SUBSTR(DCBADDR(R2UNIT)->F$DCB.NAME#.C,0,2) ~=
                SUBSTR(DT_LST.MUD,0,2) THEN DO;
                 CALL UUSUBS;
                 CALL CLSFIL(R2UNIT,%SAVE#);
                 CALL INSERT(R2NAME,0,2,SUBSTR(DT_LST.MUD,0,2));
                 K=DCBADDR(R2UNIT)->F$DCB.NAME#.L;
                 CALL OPNFIL(R2UNIT,%IN#,,,R2NAME,K);
                 IF NOT OK THEN GOTO NO_SUB;
              END;
              IF NOT DCBADDR(R2UNIT)->F$DCB.FCD# THEN DO;
                 REWIND.V.DCB# = R2UNIT;
                 CALL M$REW(REWIND)ALTRET(NO_SUB);
                 READ.V.DCB# = R2UNIT;
                 READ.BUF_ = VECTOR(TXT_LN);
                 NSUBS=DCBADDR(R2UNIT)->F$DCB.NRECS#;
                 DO WHILE(SUBSV.WSIZ<NSUBS);
                    CALL M$GDS(GDS);
                 END;
                 PTR2$=PINCRW(SUBSV.P$,NSUBS);
                 NSUBS=0;
READAGAIN:       CALL M$READ(READ) ALTRET(ENDF);
                 I = DCBADDR(R2UNIT)->F$DCB.ARS#;
                 CALL XLATE (TXT_LN,TRANSTBL,TXT_LN);
                 CALL INDEX1(J,'%',SUBSTR(TXT_LN,0,I))ALTRET(READAGAIN);
                 IF SUBSTR(TXT_LN,J,4)~='%SUB'
                   AND SUBSTR(TXT_LN,J,4)~='%EQU'
                   AND SUBSTR(TXT_LN,J,4)~='%SET' THEN GOTO READAGAIN;
                 CALL INDEX1(J,'=',SUBSTR(TXT_LN,0,I))ALTRET(READAGAIN);
                 K=J;
                 DO WHILE(SUBSTR(TXT_LN,K,J-K)=' ');
                    L=K;
                    CALL INDEX1R(K,' ',SUBSTR(TXT_LN,0,K))ALTRET(READAGAIN);
                 END;
                 K=K+1;
                 TEXTC.L=L-K;
                 IF POFFW(PTR2$,SUBSV.P$)+SIZEW(TEXTC)>SUBSV.WSIZ
                 THEN CALL M$GDS(GDS);
                 TEXTC.T=SUBSTR(TXT_LN,K,63);
                 J=J+1;
                 DO WHILE(J<I AND (SUBSTR(TXT_LN,J,1)<'0'
                   OR SUBSTR(TXT_LN,J,1)>'9'));
                    J=J+1;
                    IF J>=I THEN GOTO READAGAIN; /* NO NUMBERS                */
                 END;
                 K=J+1;
                 DO WHILE(K < I AND SUBSTR(TXT_LN,K,1)>='0'
                   AND SUBSTR(TXT_LN,K,1)<='9');
                    K=K+1;
                 END;
                 CALL CHARBIN(I,SUBSTR(TXT_LN,J,K-J));
                 IF I>BITBIN('37777'O) THEN SUBX(NSUBS)='2'O;
                 ELSE SUBX(NSUBS)=BINBIT(I,18);
                 SUBX.TXT(NSUBS)=POFFW(PTR2$,SUBSV.P$);
                 PTR2$=PINCRW(PTR2$,SIZEW(TEXTC));
                 NSUBS=NSUBS+1;
                 GOTO READAGAIN;
              END;
ENDF:         ;
              I=0;
              DO WHILE(I<NSUBS AND PTR1$->CCHAR ~=
                PINCRW(SUBSV.P$,SUBX.TXT(I))->TEXTC.T);
                 I=I+1;
              END;
              IF (I = NSUBS)
              THEN GOTO NO_SUB;
              ERR# = SUBX.VAL(I);
              SUBX.USED(I)='1'B;
              I = CHAR_LEN;
           END;
           ELSE IF I=CHAR_LEN-1 THEN CALL CHARBIN(ERR#,PTR1$->CCHAR);
           I = I+1;
        END;
        ERR_KEY.CODE# = BINBIT(ERR#,14);
        IF ERR#>BITBIN('37777'O) THEN CALL TELLER(%BAD_ERROR);
/* */
/* OK. NOW LETS BUILD THE DATA PART OF MESSAGE */
        TMON = MON_BIT;
AGAIN:
        J = DT_LST.BYT#; TBKNBR = DT_LST.BLK#;
        IF BUFFERU(0) ~= TBKNBR THEN CALL DBREAD(TXTUNT,BUFFER,TBKNBR);
        N = 0;
        CALL GET_LN;
        CALL GET_LN;
        IF M=0 AND I~=CHAR_LEN THEN CALL TELLER(%BAD_ERROR);
L1:        DO CASE(M);                  /* WHAT KEYWORD DID WE GET*/
            CASE(1);                    /* MESSAGE                            */
              ERR_MESS.C.NOT_LAST = TRUE;
              ERR_KEY.SEQ# = 0;
              I = I + K;
              IF K = 7 THEN DO;
                 IF TIP < 3 THEN ERR_KEY.MESS# = BINBIT(ASCBIN(SUBSTR(TXT_LN,I,1)),3);
                 I=I+2;
              END;
              ELSE IF TIP < 3 THEN ERR_KEY.MESS# = '0'B;
              L = I;
              IF SUBSTR(TXT_LN,I,1) = ':'
              THEN DO;
                 CALL GET_LN ALTRET(L1);
                 L = 1;
                 I = 1;
              END;
BACK:         CALL INDEX1(K,'%',SUBSTR(TXT_LN,0,CHAR_LEN),I);
              IF CHAR_LEN - I > 115
              THEN DO;
                 CALL INDEX1R(N,' ',SUBSTR(TXT_LN,I,115));
                 IF N = 0 THEN J = 115;
                 IF K - I < N THEN ERR_MESS.C.SUBS = TRUE;
                 ERR_MESS.DATA = SUBSTR(TXT_LN,I,115);
                 CALL WR_IT;
                 I = I+N;
                 IF CHAR_LEN=0 THEN GOTO DONE;
                 GOTO BACK;
              END;
              IF K < CHAR_LEN THEN ERR_MESS.C.SUBS = TRUE;
              N = CHAR_LEN - I;
              ERR_MESS.DATA = SUBSTR(TXT_LN,I,N);
              CALL GET_LN;
              CALL WR_IT;
              IF M = 0 THEN DO;
                 IF I > L THEN I = L;
                 GOTO BACK;
              END;
            CASE(2,3,4);                /* REM, TYP, DESC                     */
              READ.BUF_.BUF$ = ADDR(ERR_MESS);
              READ.V.DCB# = M;
              I = I + K;
              DO WHILE(SUBSTR(TXT_LN,I,1)=' ' AND I < CHAR_LEN);
                 I = I + 1;
              END;
              M = 0;
              DO WHILE(M = 0);
                 ERR_MESS.DATA = SUBSTR(TXT_LN,I,CHAR_LEN-I);
                 READ.BUF_.BOUND = CHAR_LEN-I;
                 CALL APPWTR(CMT_NAME,READ);
                 CALL GET_LN;
              END;
            CASE(ELSE);
              M=0;
              DO WHILE(M = 0);
                 CALL GET_LN;
              END;
           END;
        IF CHAR_LEN ~= 0 THEN GOTO L1;
        IF ERR_KEY.SEQ# = 0 THEN DO;
           CALL TELLER(%NO_MESSAGE);
           RETURN;
        END;
        IF TMON AND ERR_KEY.FCG
        THEN DO;
           TMON = FALSE;
           ERR_KEY.FCG = '0'B;
           GOTO AGAIN;
        END;
DONE:
        RETURN;
%EJECT;
UUSUBS: ENTRY;
        IF NOT DCBADDR(R2UNIT)->F$DCB.FCD# THEN RETURN;
        CALL CONCAT(OUT_BUFFER,'A   - Unused subs in ',
          ADDR(DCBADDR(R2UNIT)->F$DCB.NAME#)->TEXTC.T,':');
        J = DCBADDR(LOUNIT)->F$DCB.WIDTH#;
        IF J=0 OR J>108 THEN J = 108;
        K=500;
        DO I=0 TO NSUBS-1;
           IF NOT SUBX.USED(I) THEN DO;
              IF K+PINCRW(SUBSV.P$,SUBX.TXT(I))->TEXTC.L > J THEN DO;
                 CALL TELLER(0);
                 K=6;
                 OUT_BUFFER='A   -';
              END;
              CALL INSERT(OUT_BUFFER,K,,PINCRW(SUBSV.P$,SUBX.TXT(I))->TEXTC.T);
              K=K+(PINCRW(SUBSV.P$,SUBX.TXT(I))->TEXTC.L+12)/12*12;
           END;
        END;
        IF K~=500 THEN CALL TELLER(0);
        IF APPFLG THEN CALL APPWTR;
        RETURN;
%EJECT;
/***/
/*I*     NAME: GET_LN
         PURPOSE: The purpose of the routine is to get the next
                 data line from the Data Base TXT file.
                                                                 */
 
GET_LN : PROC ALTRET;
 
DCL KWD_TXT CHAR(12);
DCL LOW_2_UP CHAR(256) SYMREF;
DCL KWD(0:3)CHAR(12)CONSTANT INIT(
'MESSAGE:','TYPE:','REMARKS:','DESCRIPTION:');
 
        CHAR_LEN = ASCBIN(SUBSTR(BUFFER,J,1));
        IF CHAR_LEN = 0
        THEN DO;
           M = 5;
           ALTRETURN;
        END;
        IF J+1+CHAR_LEN > 4095
        THEN DO;
           TBKNBR = TBKNBR+1;
           CALL DBREAD(TXTUNT,BUFFER,TBKNBR);
           J = 4;
           CHAR_LEN = ASCBIN(SUBSTR(BUFFER,4,1));
        END;
        CHAR_LEN = 1 + CHAR_LEN;
        TXT_LN = SUBSTR(BUFFER,J,CHAR_LEN);
        I = 1;
        DO WHILE((SUBSTR(TXT_LN,I,1) = ' ' OR
          SUBSTR(TXT_LN,I,1) = '*') AND I < CHAR_LEN);
           I = I + 1;
        END;
        CALL XLATE (KWD_TXT, LOW_2_UP, SUBSTR(TXT_LN,I,12));
        CALL INDEX1(K,':',KWD_TXT);
        IF SUBSTR(KWD_TXT,0,1)='M' AND K = 8 THEN K = 7;
        ELSE K = K +1;
        M = 0;
        DO WHILE (M < 4 AND SUBSTR(KWD_TXT,0,K) ~= SUBSTR(KWD(M),0,K));
           M = M + 1;
        END;
        M = M + 1;
        DO CASE(M);
         CASE(1);
         CASE(2,3,4);
           IF NOT APPFLG OR TMON ~= MON_BIT THEN M = 5;
         CASE(ELSE);
           M = 0;
        END;
        J = J + CHAR_LEN;
        RETURN;
END GET_LN;
%EJECT;
/***/
/*I*     NAME: WR_IT
         PURPOSE: This function will write to the R1UNIT file the
                   data in ERR_MESS of NUM# characters using the
                   key in ERR_KEY to located the record in the file
                                                                 */
 
WR_IT : PROC;
 
 
 
%FPT_WRITE(FPTN = WRITE,NEWKEY=YES,KEY=ERR_KEY);
 
        IF M ~= 0 THEN ERR_MESS.C.NOT_LAST = FALSE;
        WRITE.V.DCB# = R1UNIT;
        WRITE.V.ONEWKEY# = KEY_FLG;
        WRITE.BUF_.BOUND = N;
        WRITE.BUF_.BUF$ = ADDR(ERR_MESS);
TRY_AGAIN:
        CALL M$WRITE(WRITE) ALTRET(LETS_SEE);
TSTAPP: IF APPFLG AND MON_BIT=TMON THEN CALL APPWTR(CMT_NAME,WRITE);
        ERR_KEY.SEQ# = ERR_KEY.SEQ# + 1;
        ERR_MESS.C.SUBS = FALSE;
        RETURN;
LETS_SEE:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$OLDREC
        THEN IF TMON AND NOT ERR_KEY.FCG THEN DO;
              CALL DELDFLT;        /* Remove ALL the existing default msgs.   */
              GOTO TRY_AGAIN;           /* Oughta work this time, eh?         */
           END;
           ELSE IF STAT = %OLDFILE# AND MON_BIT THEN DO;
                 IF NOT ERR_KEY.FCG THEN RETURN;
                 CALL TSTFILE;
                 GOTO TRY_AGAIN;
              END;
              ELSE IF ERR_KEY.SEQ# = 0 AND TMON = MON_BIT THEN DO;
                    CALL TELLER(%DUP_ERR_MESS);
                 END;
                 ELSE IF TMON~=MON_BIT THEN DO;
                       CHAR_LEN=0;
                       M=5;
                    END;
        GOTO TSTAPP;
%EJECT;
/***/
/*I*     NAME: TSTFILE
         PURPOSE: This function will see if we should overwrite
                   the exsisting record and if we should overwrite
                   the default records
                                                                */
 
TSTFILE : PROC;
 
%FPT_READ(FPTN=READ1,KEYS=YES,KEY=TST_KEY1,BUF=TEMP_BUF1);
%FPT_READ(FPTN=READ2,KEYS=YES,KEY=TST_KEY2,BUF=TEMP_BUF2);
%FPT_DELREC(FPTN=DELREC,KEY=ERR_KEY,LKEY=TST_KEY1);
 
DCL 1 TST_KEY1 STATIC ALIGNED,
      2 LEN# UBIN BYTE UNAL,
      2 FCG(0:2) BIT(6) UNAL,
      2 MON_BIT BIT(1) UNAL,
      2 CODE# BIT(14) UNAL,
      2 MESS# BIT(3) UNAL,
      2 SEQ# UBIN BYTE UNAL;
 
DCL 1 TST_KEY2 STATIC ALIGNED,
      2 LEN# UBIN BYTE UNAL,
      2 FCG(0:2) BIT(6) UNAL,
      2 MON_BIT BIT(1) UNAL,
      2 CODE# BIT(14) UNAL,
      2 MESS# BIT(3) UNAL,
      2 SEQ# UBIN BYTE UNAL;
 
DCL TEMP_BUF1 CHAR(140) STATIC;
DCL 1 TBUF1 REDEF TEMP_BUF1,
      2 * BIT(1),
      2 NOT_LAST BIT(1),
      2 * CHAR(136)ALIGNED;
DCL TEMP_BUF2 CHAR(140) STATIC;
 
DCL I1 UBIN;
DCL I2 UBIN;
/* OK NOW LETS SET THE COMMON FLAGS */
 
 
        TST_KEY1 = ERR_KEY;
        TST_KEY2 = ERR_KEY;
        TST_KEY2.FCG = '0'B;
        READ1.V.DCB# = R1UNIT;
        READ2.V.DCB# = R1UNIT;
/* ALL SET UP NOW LETS GO COMPARE THE DATA */
 
CHECK_IT:
        CALL M$READ(READ1) ALTRET(AGAIN_NO);
        I1 = DCBADDR(R1UNIT)->F$DCB.ARS#;
        CALL M$READ(READ2) ALTRET(AGAIN_NO);
        I2 = DCBADDR(R1UNIT)->F$DCB.ARS#;
/* NOW COMPARE LENTGHS. IF SAME THEN DATA. IF SAME THEN NEXT LINE */
        IF I2 ~= I1 THEN RETURN;
        IF SUBSTR(TEMP_BUF1,0,I1) ~= SUBSTR(TEMP_BUF2,0,I2) THEN RETURN;
        TST_KEY1.SEQ# = TST_KEY1.SEQ# + 1;
        TST_KEY2.SEQ# = TST_KEY2.SEQ# + 1;
        IF TBUF1.NOT_LAST THEN GOTO CHECK_IT;
        KEY_FLG = TRUE;
        WRITE.V.ONEWKEY# = TRUE;
        RETURN;
DELDFLT : ENTRY;
        TST_KEY1 = ERR_KEY;
        TST_KEY1.MESS# = '7'O;
        TST_KEY1.SEQ# = 511;
        DELREC.V.DCB# = R1UNIT;
        CALL M$DELREC (DELREC) ALTRET (AGAIN_NO);
        KEY_FLG = '1'B;
AGAIN_NO:RETURN;
END TSTFILE;
END WR_IT;
%EJECT;
/***/
/*I*     NAME: HASH_NAME
         PURPOSE: This function will build an errkey for QUAC tests by
                hashing the error name into a UBIN(9) and putting it and
                 the severity instead of MONBIT,CODE, and MESS.
                                                                 */
 
HASH_NAME : PROC ALTRET;
 
DCL I SBIN;
DCL TABLE(0:127)SBIN(9)UNAL CONSTANT INIT(
-1*36,63,-1*11,0,1,2,3,4,5,6,7,8,9,62,  /* $,0-9,:                            */
-1*6,10,11,12,13,14,15,16,17,18,19,20,21,22, /* A-M                           */
23,24,25,26,27,28,29,30,31,32,33,34,35,-1*6, /* N-Z                           */
36,37,38,39,40,41,42,43,44,45,46,47,48, /* a-m                                */
49,50,51,52,53,54,55,56,57,58,59,60,61,-1*5);
DCL HASH(0:23) UBIN(9) UNAL;
DCL HASH_CODE UBIN WORD;
DCL 1 REHASH REDEF HASH_CODE,
      2 TOP_27 UBIN(27) UNAL,
      2 BOTTOM_9 UBIN(9) UNAL;
 
 
/* FIRST HASH THE PREFIX */
        I = 0;
        ERR_HASH.FCG = 0;
        DO WHILE(SUBSTR(CMT_NAME,I,1)~='-');
           ERR_HASH.FCG = ERR_HASH.FCG*113 +TABLE(ASCBIN(SUBSTR(CMT_NAME,I,1)));
           I = I + 1;
        END;
/* OK NOW LETS GET THE NAME */
        I = 0;
        DO WHILE(PTR1$->C1 ~= '*' AND I < 25);
           HASH(I) = TABLE(PTR1$->U1);
           IF HASH(I) > 63
           THEN DO;
              CALL TELLER(%BAD_TEST_ERR);
              ALTRETURN;
           END;
           PTR1$ = PINCRC(PTR1$,1);
           I = I + 1;
        END;
/* HASH IT NOW */
        HASH_CODE = 0;
        DO K = 0 TO I - 1;
           HASH_CODE = HASH_CODE * 113 + HASH(K);
           REHASH.TOP_27 = 0;
        END;
        ERR_HASH.NAME = REHASH.BOTTOM_9;
/* OK NOW LETS GET THE SEVERITY (STEPCC) */
        PTR1$ = ADDR(DT_LST.NAM);
        I = 0; K = 0;
        DO WHILE( K < 2);
           IF PINCRC(PTR1$,I)->C1 = '-' THEN K = K + 1;
           I = I + 1;
        END;
        PTR1$ = PINCRC(PTR1$,I);
        K = 0; I = 0;
        DO WHILE
          (PINCRC(PTR1$,I)->C1 >= '0' AND PINCRC(PTR1$,I)->C1 <='9');
           K = (K * 10) + (PINCRC(PTR1$,I)->U1 - 48);
           I = I + 1;
        END;
        ERR_HASH.SEV = K;
        ERR# = K;
        RETURN;
END HASH_NAME;
/***** *** ** *** *** ** *** *** ** *** *** *****/
END ERRWTR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*****************************************************************/
/***/
/*F*     NAME: APPWTR
         PURPOSE: APPendix WriTeR will take the error and write
                   out the appendix listings. It creates three kinds
                   of listings. A short one liner sorted by number,
                   a full listing (except DESCRIPTION), and a one liner
                   sorted by name.
                                                                 */
APPWTR : PROC (CMT_NAME, WRERR);
 
DCL CMT_NAME CHAR(35);
 
%INCLUDE EXTRACT_C1;
 
%FPT_WRITE(FPTN=WRERR,STCLASS=);
DCL KEY_FLG BIT(1) SYMREF;
DCL TIP UBIN SYMREF;
 
DCL 1 KEY1$ ALIGNED STATIC,
      2 LEN# UBIN BYTE UNAL INIT(3),
      2 CODE# UBIN(18) UNAL,
      2 SEQ# UBIN(9) UNAL;
DCL 1 KEY11$ STATIC,
      2 LEN# UBIN BYTE UNAL,
      2 TXT# CHAR(35);
DCL KEY11$_SEQ#(0:35) REDEF KEY11$ UBIN(9) UNAL;
 
DCL 1 FORMAT_11 ALIGNED STATIC,
      2 NAME   CHAR(20) UNAL,
      2 *      CHAR(1)  UNAL INIT(' '),
      2 CODE_D CHAR(4)  UNAL,
      2 *      CHAR(1)  UNAL INIT(' '),
      2 CODE_O CHAR(4)  UNAL,
      2 *      CHAR(1)  UNAL INIT(' '),
      2 MESS   CHAR(84) UNAL;
 
DCL FORMAT_12 REDEF FORMAT_11 CHAR(115) ALIGNED;
 
DCL 1 KEY2$ ALIGNED STATIC,
      2 LEN# UBIN BYTE UNAL INIT(7),
      2 CODE UBIN(27)INIT(0) UNAL,
      2 FCG BIT(18)INIT('0'B),
      2 TYP UBIN(6)INIT(0) UNAL,
      2 SEQ# UBIN(12)INIT(0) UNAL;
 
DCL 1 FORMAT_21 ALIGNED STATIC,
      2 CODE   CHAR(4)  UNAL,
      2 *      CHAR(3)  UNAL INIT('   '),
      2 FCG    CHAR(3)  UNAL,
      2 SEV    CHAR(2)  UNAL,
      2 *      CHAR(3)  UNAL INIT('   '),
      2 DATA   CHAR(100) UNAL;
 
DCL FORMAT_22 REDEF FORMAT_21 CHAR(115) ALIGNED;
 
DCL APPWID UBIN STATIC INIT(0);
DCL WRAP1 UBIN STATIC;
DCL WRAP2 UBIN STATIC;
 
DCL 1 ERR_KEY SYMREF,
      2 LEN UBIN BYTE UNAL,
      2 FCG BIT(18),
      2 MON BIT(1),
      2 CODE UBIN(14)UNAL,
      2 LEV UBIN(3)UNAL,
      2 SEQ UBIN BYTE UNAL;
DCL 1 ERR_HASH REDEF ERR_KEY,2 * BIT(36),2 SEV UBIN(9)UNAL,2 * BIT(9);
DCL 1 ERR_MESS BASED(WRERR.BUF_.BUF$)ALIGNED,
      2 F BIT(9),
      2 T CHAR(WRERR.BUF_.BOUND);
DCL 1 ERR# BASED ALIGNED,
      2 * BIT(24),
      2 CODE(0:3)UBIN(3)UNAL;
 
 
DCL F$112 DCB;
DCL F$113 DCB;
DCL F$114 DCB;
 
DCL TELLER ENTRY(1);
 
%FPT_WRITE(FPTN=WRITE_AP1,DCB=F$112,NEWKEY=YES,
                   KEY=KEY1$,BUF=FORMAT_11);
%FPT_READ(FPTN=READ1,DCB=F$112,KEYS=YES,KEY=KEY1$,BUF=OUT_BUFFER);
%FPT_DELREC(FPTN=DELREC1,DCB=F$112,KEY=KEY1$);
%FPT_WRITE(FPTN=WRITE_AP11,DCB=F$114,NEWKEY=YES,
                   KEY=KEY11$,BUF=FORMAT_11);
%FPT_READ(FPTN=READ11,DCB=F$114,KEYS=YES,KEY=KEY11$,BUF=OUT_BUFFER);
%FPT_DELREC(FPTN=DELREC11,DCB=F$114,KEY=KEY11$);
%FPT_WRITE(FPTN=WRITE_AP2,DCB=F$113,NEWKEY=YES,ONEWKEY=NO,
                   KEY=KEY2$,BUF=FORMAT_21);
/* OK LET'S GOooooooooooo........ */
 
        IF APPWID=0 THEN DO;
           APPWID = DCBADDR(DCBNUM(F$112))->F$DCB.RECL#;
           IF APPWID<50 THEN APPWID=300;
           WRAP1=0;
           WRAP2=0;
        END;
 
        IF ERR_KEY.SEQ=0 OR ADDR(CMT_NAME)=ADDR(NIL) THEN DO;
           IF WRAP1~=0 THEN CALL M$WRITE (WRITE_AP1) WHENALTRETURN DO; END;
           IF WRAP1~=0 THEN CALL M$WRITE (WRITE_AP11) WHENALTRETURN DO; END;
           WRAP1 = 0;
           KEY1$.SEQ# = 0;
           IF ADDR(CMT_NAME)=ADDR(NIL) THEN DO;
              IF WRAP2~=0 THEN CALL M$WRITE(WRITE_AP2) WHENALTRETURN DO; END;
              WRAP2 = 0;
              RETURN;
           END;
        END;
/* INITIALIZE LOW KEY */
 
        N = ERR_KEY.CODE;
        IF TIP = 3 THEN N = ERR_HASH.SEV;
        IF ERR_KEY.SEQ=0 THEN DO;
           KEY1$.CODE# = N;
           CALL INDEX1(I,'-',CMT_NAME);
           K=I+1;
           CALL INDEX1(J,'*',SUBSTR(CMT_NAME,K,34));
           KEY11$.LEN# = J+1;
           KEY11$.TXT# = SUBSTR(CMT_NAME,K,J);
           FORMAT_11.NAME = KEY11$.TXT#;
           CALL BINCHAR(FORMAT_11.CODE_D,N);
           DO L = 0 TO 3;               /* PUT ERROR# IN OCTAL                */
              CALL INSERT(FORMAT_11.CODE_O,L,1,
                BINASC(48+ADDR(N)->ERR#.CODE(L)));
           END;
 
/* NOW CREATE FULL MESSAGE */
           IF KEY2$.CODE~=N OR KEY2$.FCG~=ERR_KEY.FCG THEN DO;
              IF WRAP2~=0 THEN CALL M$WRITE(WRITE_AP2)WHENALTRETURN DO; END;
              WRAP2 = 0;
              WRITE_AP2.BUF_.BOUND = 0;
              KEY2$.TYP = 63;
              CALL M$WRITE(WRITE_AP2) WHENALTRETURN DO; END;
/* PUT FCG IN KEY AND INTO FORMAT */
              KEY2$.FCG = ERR_KEY.FCG;
              KEY2$.SEQ# = 0;
              KEY2$.CODE = N;
              FORMAT_21.FCG = SUBSTR(CMT_NAME,0,I);
/* PUT ERROR NAME INTO FORMAT */
              FORMAT_21.DATA = KEY11$.TXT#;
/* PUT ERROR NUMBER INTO FORMAT AND KEY */
              FORMAT_21.CODE = FORMAT_11.CODE_D;
/* NOW GET SEVERITY */
              FORMAT_21.SEV = SUBSTR(CMT_NAME,K+J,2);
              CALL INSERT(FORMAT_21.SEV,0,1,'-');
/* OK NOW LETS PRINT THE FIRST LINE OF THIS MESSAGE SET */
              WRITE_AP2.BUF_.BOUND = J + 14;
              KEY2$.TYP = 0;
              CALL M$WRITE(WRITE_AP2) WHENALTRETURN DO; END;
/* OK NOW LETS GET THE 'MESSAGES','REMARKS' AND THE 'TYPES' */
/* FIRST CLEAR OUT THE CODE,FCG AND SEVERITY */
              FORMAT_22 = ' ';
              KEY2$.SEQ# = 1;
           END;
        END;
        L = WRERR.BUF_.BOUND+30;
        DO WHILE(SUBSTR(ERR_MESS.T,0,1) = ' ' AND L > 30);
           ERR_MESS.T = SUBSTR(ERR_MESS.T,1);
           L = L - 1;
        END;
        IF ERR_KEY.LEV=0 AND WRERR.KEY_~=VECTOR(NIL) THEN DO;
           CALL INSERT (FORMAT_11.MESS,WRAP1,,ERR_MESS.T);
           IF L+WRAP1>=APPWID THEN DO;
NXTAP1:       CALL INDEX1R (M,' ',SUBSTR(FORMAT_12,1),APPWID);
           END;
           ELSE M = L+WRAP1;
           WRITE_AP1.BUF_.BOUND = M;
           WRITE_AP11.BUF_.BOUND = M;
           WRAP1 = L+WRAP1-M;
           IF KEY1$.SEQ#=0 THEN DO;
              WRITE_AP1.V.ONEWKEY# = KEY_FLG;
              WRITE_AP11.V.ONEWKEY# = KEY_FLG;
              CALL M$WRITE(WRITE_AP1)
              WHENRETURN DO;
                 CALL M$WRITE(WRITE_AP11)
                 WHENALTRETURN DO;
                    CALL M$READ(READ11)
                    WHENRETURN DO;
                       SUBSTR(OUT_BUFFER,80,4) = SUBSTR(OUT_BUFFER,21,4);
                       CALL CONCAT(OUT_BUFFER,'A *** ',
                         SUBSTR(FORMAT_12,0,J),' is both ',FORMAT_11.CODE_D,
                         ' and ',SUBSTR(OUT_BUFFER,80,4));
                       CALL TELLER(0);
                    END;
                 END;
              END;
              WHENALTRETURN DO;
                 CALL M$WRITE(WRITE_AP11)
                 WHENRETURN DO;
                    CALL M$READ(READ1)
                    WHENRETURN DO;
                       SUBSTR(OUT_BUFFER,35) = OUT_BUFFER;
                       CALL INDEX1(M,' ',OUT_BUFFER);
                       CALL CONCAT(OUT_BUFFER,'A *** ',
                         SUBSTR(OUT_BUFFER,35,M),' and ',SUBSTR(FORMAT_12,0,J),
                         ' are both ',FORMAT_11.CODE_D);
                       CALL TELLER(0);
                    END;
                 END;
                 KEY1$.CODE# = 0;
                 WRAP1 = 0;
              END;
           END;
           ELSE IF KEY1$.CODE#~=0 THEN DO;
                 CALL M$WRITE(WRITE_AP1) WHENALTRETURN DO; END;
                 CALL M$WRITE(WRITE_AP11) WHENALTRETURN DO; END;
              END; ELSE WRAP1 = 0;
           KEY1$.SEQ# = KEY1$.SEQ#+1;
           KEY11$_SEQ#(KEY11$.LEN#) = KEY11$_SEQ#(KEY11$.LEN#)+1;
           IF WRAP1~=0 THEN DO;
              FORMAT_12 = ' ';
              FORMAT_11.MESS = SUBSTR(ERR_MESS.T,L-29-WRAP1);
              WRITE_AP1.BUF_.BOUND = WRAP1+29;
              WRITE_AP11.BUF_ = WRITE_AP1.BUF_;
              IF WRAP1+29>=APPWID THEN DO;
                 WRAP1 = WRAP1+29-L;
                 GOTO NXTAP1;
              END;
           END;
           ELSE IF KEY_FLG THEN DO;
                 CALL M$DELREC(DELREC1) WHENALTRETURN DO; END;
                 CALL M$DELREC(DELREC11) WHENALTRETURN DO; END;
              END;
        END;
        IF WRERR.V.DCB#>4 AND ERR_KEY.SEQ=0 THEN DO;
           IF WRAP2~=0 THEN CALL M$WRITE (WRITE_AP2) WHENALTRETURN DO; END;
           WRAP2 = 0;
           KEY2$.TYP = ERR_KEY.LEV+1;
           IF ERR_KEY.LEV = 0 OR TIP = 3 THEN FORMAT_21.DATA = 'Message:';
           ELSE CALL CONCAT(FORMAT_21.DATA,'Message',BINASC(ERR_KEY.LEV+48),':');
        END;
        ELSE IF WRERR.V.DCB#~=0 AND WRERR.V.DCB#<=4 THEN DO;
              IF WRAP2~=0 THEN CALL M$WRITE (WRITE_AP2) WHENALTRETURN DO; END;
              WRAP2 = 0;
              IF WRERR.V.DCB# = 2
              THEN DO;
                 KEY2$.TYP = 0;
                 FORMAT_21.DATA = 'Type:';
              END;
              ELSE DO;
                 KEY2$.TYP = 15;
                 FORMAT_21.DATA = 'Remarks:';
              END;
              WRERR.V.DCB# = 0;
           END;
        CALL INSERT(FORMAT_21.DATA,WRAP2+10,,ERR_MESS.T);
        L = L-6;
        IF WRAP2+L>=APPWID THEN DO;
NXTAP2:    CALL INDEX1R(M,' ',SUBSTR(FORMAT_22,1),APPWID);
        END;
        ELSE M = WRAP2+L;
        WRITE_AP2.BUF_.BOUND = M;
        CALL M$WRITE(WRITE_AP2) WHENALTRETURN DO; END;
        KEY2$.SEQ# = KEY2$.SEQ# + 1;
        WRAP2 = WRAP2+L-M;
        FORMAT_21.DATA = ' ';
        IF WRAP2~=0 THEN DO;
           SUBSTR(FORMAT_21.DATA,10) = SUBSTR(ERR_MESS.T,L-23-WRAP2);
           WRITE_AP2.BUF_.BOUND = WRAP2+23;
           IF WRAP2+23>=APPWID THEN DO;
              WRAP2 = WRAP2+23-L;
              GOTO NXTAP2;
           END;
        END;
        RETURN;
END APPWTR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*****************************************************************/
/***/
/*F*     NAME: REPORT
         PURPOSE: REPORT is the primary 'searcher' for a record.
                   The input of OP_LST specifies what it is to
                   look for and a group of flags specifies what
                   to do with it when it's found it.
                                                                 */
REPORT : PROC;
 
%INCLUDE EXTRACT_C1;
 
DCL ERRWTR ENTRY(1);
DCL BLDMAN ENTRY(1);
DCL BLDDOC ENTRY(1);
DCL CHANG ENTRY(3);
DCL TELLER ENTRY(1);
DCL DBREAD ENTRY(3);
DCL RDYDB ENTRY;
DCL STPDB ENTRY;
 
DCL NUMRECS SBIN SYMREF;
DCL RECNBR UBIN SYMREF;
DCL BUFFER CHAR(4096) SYMREF;
DCL INDXED BIT(1) SYMREF;
 
DCL 1 OP_LST SYMREF,
      2 NAM(0:1) CHAR(35) UNAL,
      2 TYP,
        3 T# SBIN BYTE UNAL,
        3 T$(0:12) CHAR(1) UNAL,
      2 MUD(0:1) CHAR(31) UNAL,
      2 LINE(0:1) UBIN;
 
DCL CMTTBL(0:11) CHAR(1) SYMREF;
 
 
DCL FOUND BIT(1);
DCL FTYPE BIT(1);
 
DCL TEXT5 CHAR(5);
 
DCL KOUNT UBIN STATIC SYMDEF;
DCL LAST_MUD CHAR(32) STATIC SYMDEF;
 
DCL HEADER CHAR(56) CONSTANT INIT
('q   Module Name                    Line# T Comment Name.');
 
 
DCL 1 OUT_TTL STATIC ALIGNED,
      2 * CHAR(4) INIT('Ao  ') UNAL,
      2 MN CHAR(31) UNAL,
      2 LN CHAR(5)  UNAL,
      2 * CHAR(1) INIT(' ') UNAL,
      2 TP CHAR(1) UNAL,
      2 * CHAR(1) INIT(' ') UNAL,
      2 NM CHAR(35) UNAL;
 
DCL TITLE REDEF OUT_TTL CHAR(78) ALIGNED;
 
%FPT_READ(FPTN=READ_IND,DCB=F$108,BUF=IND_BUF,STCLASS=CONSTANT);
%FPT_PRECORD(FPTN=PREC_KEY,DCB=F$108,KEY=KEY_KEY,KEYR=YES,KEYS=YES,STCLASS=CONSTANT);
%FPT_READ(FPTN=PREC_IND,DCB=F$108,BUF=IND_BUF,KEYS=YES,KEY=IND_BUF,STCLASS=CONSTANT);
%FPT_PRECORD(FPTN=READ_KEY,DCB=F$108,KEY=KEY_KEY,KEYR=YES,KEYS=YES,N=1,STCLASS=CONSTANT);
DCL IND_BUF CHAR(76) ALIGNED STATIC;
DCL 1 DT_LST REDEF IND_BUF,
      2 MUD CHAR(32) UNAL,
      2 NAM CHAR(35) UNAL,
      2 TYP UBIN BYTE UNAL,
      2 LIN UBIN(27) UNAL,
      2 BLK# UBIN(27) UNAL,
      2 BYT# UBIN(18) UNAL;
 
DCL 1 IND_KEY REDEF IND_BUF,
      2 MUD CHAR(31) UNAL,
      2 REST,3 * CHAR(45);
DCL 1 IND_DEL REDEF IND_BUF,
      2 KEY CHAR(71),
      2 * CHAR(5);
DCL 1 KEY_KEY STATIC,
      2 L UBIN BYTE UNAL,
      2 T CHAR(79);
 
%FPT_DELREC(FPTN=DELKEY,DCB=F$108,KEY=KEY_KEY);
%FPT_DELREC(FPTN=DELIND,DCB=F$108,KEY=IND_DEL.KEY);
 
DCL F$108 DCB;
 
 
DCL TIP UBIN SYMREF;
 
/*******/
 
        KOUNT = 0;
        LAST_MUD = ' ';
        IF NOT HAVDAT THEN CALL RDYDB;
        IF NUMRECS < 0
        THEN DO;
           CALL TELLER(%DB_EMPTY);
           RETURN;
        END;
        IF NOT INDXED THEN DO;
           KEY_KEY.L = 35;
           KEY_KEY.T = OP_LST.MUD(0);
PRECKEY:   CALL M$PRECORD(PREC_KEY)ALTRET(OK_1);
        END;
        IND_KEY.MUD = OP_LST.MUD(0);
        IND_KEY.REST = '0'B;
        CALL M$READ(PREC_IND) ALTRET(OK_1);
        GOTO OK_2;
OK_1:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$NOKEY
        THEN DO;
           CALL TELLER(%DB_NO_GOOD);
           GOTO END_REPORT;
        END;
        IF INDXED THEN GOTO PASS_CHK;
        ELSE GOTO SPR_KEY;
OK_2:
        DO WHILE(NOT BRKFLG);
           FOUND = TRUE;
           IF OP_LST.NAM(0) > DT_LST.NAM OR
             OP_LST.NAM(1) < DT_LST.NAM
           THEN FOUND = FALSE;
           ELSE IF OP_LST.MUD(0) > DT_LST.MUD OR
                OP_LST.MUD(1) < DT_LST.MUD
              THEN FOUND = FALSE;
              ELSE IF OP_LST.LINE(0) > DT_LST.LIN OR
                   OP_LST.LINE(1) < DT_LST.LIN
                 THEN FOUND = FALSE;
                 ELSE DO;
                    IF OP_LST.TYP.T# < 0 THEN FTYPE = TRUE;
                    ELSE FTYPE = FALSE;
                    DO J = 0 TO OP_LST.TYP.T#;
                       IF CMTTBL(DT_LST.TYP) = OP_LST.TYP.T$(J)
                       THEN FTYPE = TRUE;
                    END;
                    FOUND = FTYPE;
                 END;
           IF FOUND
           THEN DO;
              KOUNT = KOUNT + 1;
              IF BLDFLG
              THEN DO;
                 IF PINCRC(ADDR(DT_LST.NAM),0)->C1 = '-' OR
                   PINCRC(ADDR(DT_LST.NAM),2)->C1 = '-' OR
                   PINCRC(ADDR(DT_LST.NAM),3)->C1 = '-' OR
                   (PINCRC(ADDR(DT_LST.NAM),4)->C1 = '-' AND
                   TIP = 3)
                 THEN CALL ERRWTR(DT_LST);
                 ELSE DO;
                    RECNBR = DT_LST.LIN;
                    CALL INDEX1(K,' ',DT_LST.NAM);
                    TOKEN.LEN = K;
                    TOKEN.CHR = DT_LST.NAM;
                    CALL TELLER(%BAD_ERROR);
                 END;
              END;
              ELSE IF MANFLG THEN CALL BLDMAN(DT_LST);
                 ELSE IF DOCFLG THEN CALL BLDDOC(DT_LST);
                    ELSE DO;
                       SUBFLG = FALSE;
                       IF KOUNT = 1
                       THEN DO;
                          OUT_BUFFER = HEADER;
                          CALL TELLER(0);
                       END;
                       OUT_TTL.MN = DT_LST.MUD;
                       OUT_TTL.NM = DT_LST.NAM;
                       J = DT_LST.LIN;
                       CALL CHANG( J, OUT_TTL.LN, 5);
                       OUT_TTL.TP = CMTTBL(DT_LST.TYP);
                       OUT_BUFFER = TITLE;
                       CALL TELLER(0);
                       IF NOT BRIEF
                       THEN DO;
                          J = DT_LST.BLK#;
                          K = DT_LST.BYT#;
                          IF ADDR(BUFFER)->W1 ~= J
                          THEN CALL DBREAD(TXTUNT,BUFFER,J);
                             DO WHILE (NOT BRKFLG AND SUBSTR(BUFFER,K,1) ~= BINASC(0));
                                L = ASCBIN(SUBSTR(BUFFER,K,1));
                                IF K + L + 1 > 4095
                                THEN DO;
                                   J = J + 1;
                                   K = 4;
                                   CALL DBREAD(TXTUNT,BUFFER,J);
                                END;
                                ELSE DO;
                                   CALL CONCAT(OUT_BUFFER,'A ',SUBSTR(BUFFER,K+1,L));
                                   CALL TELLER(0);
                                   K = K + L + 1;
                                END;
                             END;
                       END;
                       SUBFLG = TRUE;
                       IF DELFLG
                       THEN DO;
                          NUMRECS = NUMRECS - 1;
                          IF INDXED THEN CALL M$DELREC(DELIND);
                          ELSE DO;
                             CALL M$DELREC(DELKEY);
                             GOTO PRECKEY;
                          END;
                       END;
                    END;
           END;                         /* DO FOUND                           */
PASS_CHK:
           IF INDXED THEN CALL M$READ(READ_IND) ALTRET(END_REPORT);
           ELSE DO;
              CALL M$PRECORD(READ_KEY) ALTRET(END_REPORT);
SPR_KEY:      CALL INDEX1(J,' ',KEY_KEY.T);
              DT_LST.MUD = SUBSTR(KEY_KEY.T,0,J);
              K = KEY_KEY.L - 9;
              IF K < 0 THEN GOTO END_REPORT;
              J=J+1;
              DT_LST.NAM = SUBSTR(KEY_KEY.T,J,K-J);
              IF DT_LST.NAM < OP_LST.NAM(0) THEN DO;
                 SUBSTR(KEY_KEY.T,J) = OP_LST.NAM(0);
                 CALL INDEX(J,'  ',KEY_KEY.T,J);
                 KEY_KEY.L = J;
                 GOTO PRECKEY;
              END;
              IF DT_LST.NAM > OP_LST.NAM(1) THEN DO;
                 IF SUBSTR(KEY_KEY.T,J,1)<BINASC(511)
                 THEN SUBSTR(KEY_KEY.T,J,1) = BINASC(511);
                 GOTO PRECKEY;
              END;
              CALL INSERT(IND_BUF,67,9,SUBSTR(KEY_KEY.T,K,9));
           END;
           IF DT_LST.MUD > OP_LST.MUD(1) THEN GOTO END_REPORT;
        END;
END_REPORT:
        IF NOT (MANFLG OR DOCFLG) AND KOUNT ~= 0 THEN DO;
           IF NOT DELFLG THEN CALL TELLER(%N_FOUND);
           ELSE CALL TELLER(%N_DELETED);
        END;
        IF DELFLG AND KOUNT > 0 THEN CALL STPDB;
        SUBFLG = TRUE;
        RETURN;
END REPORT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*****************************************************************/
/***/
/*F*     NAME: BLDDOC
         PURPOSE: BLDDOC will create a TEXT input file for the
                   purpose of creating documentaion manuals from
                   the *P*, *F*, and *D* comment types.
                                                                 */
BLDDOC : PROC (DT_LST);
 
%INCLUDE EXTRACT_C1;
 
DCL DOC_NRECS UBIN SYMREF;
DCL 1 MD_HDR SYMREF,
      2 L UBIN BYTE CALIGNED,
      2 C CHAR(79);
DCL MAN_NRECS UBIN SYMREF;
DCL 1 SECT# SYMREF ALIGNED,
      2 L UBIN BYTE UNAL,
      2 C CHAR(15);
%SUB SECT#="ADDR(SECT#)->TXTLC";
%SUB MD_HDR="ADDR(MD_HDR)->TXTLC";
DCL 1 TXTLC BASED ALIGNED,2 L UBIN BYTE CALIGNED,2 C CHAR(TXTLC.L);
DCL 1 MD_PTRS SYMREF,
      2 A_PRE$ PTR,
      2 F_PRE$ PTR,
      2 K_PRE$ PTR,
      2 A_POST$ PTR,
      2 F_POST$ PTR,
      2 K_POST$ PTR;
DCL       TRANSTBL(0:511)   CHAR(1)  UNAL  CONSTANT SYMDEF INIT(
BINASC(0),BINASC(1),BINASC(2),BINASC(3), /* NUL SOH STX ETX                   */
BINASC(4),BINASC(5),BINASC(6),BINASC(7), /* EOT ENQ ACK BEL                   */
BINASC(8),BINASC(9),BINASC(10),BINASC(11), /* BS HT LF VT                     */
BINASC(12),BINASC(13),BINASC(14),BINASC(15), /* FF CR SO SI                   */
BINASC(16),BINASC(17),BINASC(18),BINASC(19), /* DLE DC1 DC2 DC3               */
BINASC(20),BINASC(21),BINASC(22),BINASC(23), /* DC4 NAK SYN ETB               */
BINASC(24),BINASC(25),BINASC(26),BINASC(27), /* CAN EM SUB ESC                */
BINASC(28),BINASC(29),BINASC(30),BINASC(31), /* FS GS RS US                   */
BINASC(32),BINASC(33),BINASC(34),BINASC(35), /* SP ! " #                      */
BINASC(36),BINASC(37),BINASC(38),BINASC(39), /* $ % & '                       */
BINASC(40),BINASC(41),BINASC(42),BINASC(43), /* ( ) * +                       */
BINASC(44),BINASC(45),BINASC(46),BINASC(47), /* , - . /                       */
BINASC(48),BINASC(49),BINASC(50),BINASC(51), /* 0 1 2 3                       */
BINASC(52),BINASC(53),BINASC(54),BINASC(55), /* 4 5 6 7                       */
BINASC(56),BINASC(57),BINASC(58),BINASC(59), /* 8 9 : ;                       */
BINASC(60),BINASC(61),BINASC(62),BINASC(63), /* < = > ?                       */
BINASC(64),BINASC(65),BINASC(66),BINASC(67), /* @ A B C                       */
BINASC(68),BINASC(69),BINASC(70),BINASC(71), /* D E F G                       */
BINASC(72),BINASC(73),BINASC(74),BINASC(75), /* H I J K                       */
BINASC(76),BINASC(77),BINASC(78),BINASC(79), /* L M N O                       */
BINASC(80),BINASC(81),BINASC(82),BINASC(83), /* P Q R S                       */
BINASC(84),BINASC(85),BINASC(86),BINASC(87), /* T U V W                       */
BINASC(88),BINASC(89),BINASC(90),BINASC(91), /* X Y Z [                       */
BINASC(92),BINASC(93),BINASC(94),BINASC(95), /* \ ] ^ _                       */
/*
    ***       THIS SECTION OF THE TABLE CONVERTS THE LOWER CASE
    ***       ALPHABET TO UPPER CASE WHEN USED WITH XLATE FUNCTION.
    ***       THE COMMENTARY REFLECTS THE NORMAL ASCII CHARACTER WHICH
    ***       USUALLY HOLDS THE POSITION IN THE TABLE.
*/
BINASC(96),BINASC(65),BINASC(66),BINASC(67), /* ' a b c                       */
BINASC(68),BINASC(69),BINASC(70),BINASC(71), /* d e f g                       */
BINASC(72),BINASC(73),BINASC(74),BINASC(75), /* h i j k                       */
BINASC(76),BINASC(77),BINASC(78),BINASC(79), /* l m n o                       */
BINASC(80),BINASC(81),BINASC(82),BINASC(83), /* p q r s                       */
BINASC(84),BINASC(85),BINASC(86),BINASC(87), /* t u v w                       */
BINASC(88),BINASC(89),BINASC(90),BINASC(123), /* x y z {                      */
BINASC(124),BINASC(125),BINASC(126),BINASC(127), /* | } ~ DEL                 */
                     BINASC(32)*384);   /* ALL ELSE BLANK                     */
/**/
 
%FPT_WRITE(FPTN=WR_DOC);
%FPT_WRITE(FPTN=WR_OUT);
%FPT_TIME(STCLASS=CONSTANT,DATE=LAST_MUD);
DCL COPYRIGHT CHAR(140) SYMREF;
%MACRO VEC (NAME=,T=,CONSTANT=CONSTANT);
DCL 1 NAME CONSTANT,
      2 V BIT(72)INIT(VECTOR(NAME.C)),
      2 C CHAR(0)INIT(T);
%MEND;
%VEC(NAME=ALL,T='.ALL');
%VEC(NAME=ALR,T='.ALR');
%VEC(NAME=INL,T='.INL 00',CONSTANT=STATIC);
%VEC(NAME=FIN,T='.FIN');
%VEC(NAME=FBB,T='.FBB');
%VEC(NAME=FBE,T='.FBE');
%VEC(NAME=HBB,T='.HBB');
%VEC(NAME=HBE,T='.HBE');
%VEC(NAME=BBK,T='.BBK');
%VEC(NAME=BEK,T='.BEK');
%VEC(NAME=BRP,T='.BRP');
%VEC(NAME=BRF,T='.BRF');
%VEC(NAME=SPB,T='.SPB');
%VEC(NAME=SPB7,T='.SPB 7');
%VEC(NAME=BBF,T='.BBF S');
%VEC(NAME=BEF,T='.BEF');
%VEC(NAME=UNL,T='.UNL 00',CONSTANT=STATIC);
%VEC(NAME=LINE,T='00000',CONSTANT=STATIC);
 
%MACRO WLINE (BUF=);
        WR_DOC.BUF_ = BUF.V; CALL M$WRITE(WR_DOC);
%MEND;
 
DCL OUT_BUF CHAR(140);
DCL BLKNBR UBIN;
DCL BYTNBR UBIN;
DCL DONE BIT(1);
 
DCL LAST_MUD CHAR(32)SYMREF;
 
DCL CMTTBL(0:11) CHAR(1) SYMREF;
DCL F_CMT UBIN SYMREF;
DCL P_CMT UBIN SYMREF;
DCL D_CMT UBIN SYMREF;
DCL I_CMT UBIN SYMREF;
 
DCL 1 DT_LST ALIGNED,
      2 MUD CHAR(31) UNAL,
      2 * UBIN BYTE UNAL,
      2 NAM CHAR(35) UNAL,
      2 TYP UBIN BYTE UNAL,
      2 LINE UBIN(27) UNAL,
      2 BLK# UBIN(27) UNAL,
      2 BYT# UBIN(18) UNAL;
 
DCL CONNECTS CHAR(0) CONSTANT INIT(
'IFFOOFTOA ANTHBY');
 
DCL BUFFER CHAR(4096)SYMREF;
DCL BUFFERU(0:1023)REDEF BUFFER UBIN;
DCL DBREAD ENTRY(3);
DCL TELLER ENTRY(1);
%SUB KEY_MAX = 11;
DCL 1 KEYWRD(0:KEY_MAX) ALIGNED CONSTANT CHAR(11)INIT('NAME',
        'PURPOSE',
        'DESCRIPTION',
        'ENTRY',
        'CALL',
        'INTERFACE',
        'ENVIRONMENT',
        'INPUT',
        'OUTPUT',
        'SCRATCH',
        'PARAMETERS',
        'REFERENCE');
 
DCL INL# UBIN;
DCL NBR# SBIN STATIC;
DCL 1 NBR REDEF NBR#,
      2 KWD SBIN(18)UNAL,2 * BIT(18);
DCL FL1 BIT(36);
DCL 1 FL2,
      2 N UBIN;
DCL F2I(0:15) CHAR(1);
DCL F2C(0:15) CHAR(1);
DCL FL3 BIT(36);
DCL COLON SBIN;
DCL LCFLG BIT(36);
DCL 1 LEVL(0:15),
      2 N UBIN,
      2 SAV REDEF N,
        3 BLK UBIN(18) UNAL,
        3 BYT UBIN(18) UNAL;
%FPT_PRECORD (FPTN=XEQ, DCB=F$108, KEYS=YES, KEYR=YES, KEY=OUT_BUFFER, STCLASS=CONSTANT);
DCL F$108 DCB;
DCL 1 XEQ_KEYB BASED ALIGNED,
      2 L UBIN BYTE CALIGNED,
      2 BLK UBIN(27) CALIGNED,
      2 BYT UBIN(18) CALIGNED;
%SUB XEQ_KEY = "ADDR(OUT_BUFFER)->XEQ_KEYB";
 
DCL XCLD BIT(1);
DCL XCLDPTR$ PTR STATIC;
DCL 1 XCL BASED(XCLDPTR$) ALIGNED,
      2 L UBIN(9)UNAL,
      2 CHRS CHAR(XCL.L);
DCL F$EXCLUDE DCB;
 
/*******/
 
        FL1 = FALSE;
        FL2 = FALSE;
        COLON = 0;
        LCFLG = '0'B;
        LEVL.N(0) = 0;
        WR_DOC.V.DCB# = R1UNIT;
        WR_OUT.BUF_.BUF$ = ADDR(OUT_BUF);
        WR_OUT.V.DCB# = R1UNIT;
 
        BLKNBR = DT_LST.BLK#;
        BYTNBR = DT_LST.BYT#;
        IF BUFFERU(0) ~= BLKNBR THEN CALL DBREAD(TXTUNT,BUFFER,BLKNBR);
        DOC_NRECS = DOC_NRECS + 1;
 
        IF DOC_NRECS = 1
        THEN DO;
 
           XCLDPTR$ = ADDR(NIL);
           %WLINE(BUF = FBB);
 
           CALL CONCAT(OUT_BUF,'||',SUBSTR(SECT#.C,0,SECT#.L),'%PAGENO%|');
           WR_OUT.BUF_.BOUND = SECT#.L+10;
           CALL M$WRITE(WR_OUT);
 
           %WLINE(BUF = FBE);
 
        END;
 
        IF LAST_MUD ~= DT_LST.MUD
        THEN DO;
 
           %WLINE(BUF = HBB);
 
           CALL CONCAT(OUT_BUF,'||',MD_HDR.C,'||');
           WR_OUT.BUF_.BOUND = MD_HDR.L + 3;
           IF MD_HDR.L ~= 0 THEN CALL M$WRITE(WR_OUT);
 
           CALL INDEX1(CHAR_LEN,' ',DT_LST.MUD);
           CALL CONCAT(OUT_BUF,'||',SUBSTR(DT_LST.MUD,0,CHAR_LEN),'||');
           WR_OUT.BUF_.BOUND = CHAR_LEN + 3;
           CALL M$WRITE(WR_OUT);
           LAST_MUD = DT_LST.MUD;
 
           %WLINE(BUF = HBE);
 
           IF DOC_NRECS ~= 1
           THEN DO;
              %WLINE(BUF = BRP);
           END;
        END;
        K = DT_LST.LINE;
        CALL BINCHAR(LINE.C,K);
        %WLINE(BUF = BBK);
 
        %WLINE(BUF = ALR);
 
        %WLINE(BUF = LINE);
 
        %WLINE(BUF = ALL);
        IF DOC_NRECS = 1 THEN DO;
           %WLINE(BUF = BBF);
           CALL M$TIME(FPT_TIME);
           OUT_BUF = COPYRIGHT;
           CALL INDEX2(I,'19',OUT_BUF);
           CALL INSERT(OUT_BUF,I+2,2,SUBSTR(LAST_MUD,8,2));
           LAST_MUD = DT_LST.MUD;
           WR_OUT.BUF_.BOUND = I+3;
           CALL M$WRITE(WR_OUT);
           %WLINE(BUF = BEF);
        END;
        NBR# = 0;
 
        IF DT_LST.TYP = F_CMT THEN INL# = 5;
        ELSE IF DT_LST.TYP = D_CMT THEN INL# = 10;
           ELSE IF DT_LST.TYP = I_CMT THEN INL# = 15;
              ELSE INL# = 0;
        CHAR_LEN = 0;
        CALL GET_LN;
        IF I = 0 THEN DO;
           J = M - BYTNBR + 2;
           GOTO NOKEYWRD;
        END;
 
        CALL BINCHAR(SUBSTR(INL.C,5,2),INL#);
        CALL INSERT(UNL.C,5,2,'00');
        NBR# = -1;
 
NEWKEYWRD:
        L = CHAR_LEN - M + BYTNBR;
 
        OUT_BUF = SUBSTR(BUFFER,M,L);
        WR_OUT.BUF_.BOUND = L - 1;
        IF L > K+1 AND SUBSTR(OUT_BUF,L-1,1) = ':' THEN COLON = -3;
/* KEYWORD LINE IS IN OUTBUF, READY TO WRITE */
/* WILL WRITE WHEN WE KNOW IF NEXT IS A KEYWORD TOO */
 
        J = K + M + 1;
        DO WHILE(SUBSTR(BUFFER,J,1) = ' ');
           J = J + 1;
        END;
        J = J - BYTNBR + 2;
 
        CALL GET_LN;
        DO WHILE(NOT DONE);
           IF I ~= 0 THEN DO;
              IF NBR# < 0 THEN DO;
                 IF NBR# ~= -1 THEN WR_DOC.BUF_ = UNL.V;
                 ELSE WR_DOC.BUF_ = INL.V;
                 CALL M$WRITE(WR_DOC);
                 NBR# = NBR# + 1;
                 CALL M$WRITE(WR_OUT);
              END;
              NBR.KWD = -2;
              GOTO NEWKEYWRD;
           END;
NOKEYWRD:  IF SUBSTR(BUFFER,M,1) = '.'
           THEN IF SUBSTR(BUFFER,M,4)= '.FIF' THEN FL1 = TRUE;
              ELSE IF SUBSTR(BUFFER,M,4)= '.FIN' THEN FL1 = FALSE;
                 ELSE IF SUBSTR(BUFFER,M,2)<'.A' THEN M = M - 1;
WR_LINE:   IF NBR# < 0 THEN DO;
              WR_DOC.BUF_ = INL.V;
              CALL BINCHAR(SUBSTR(INL.C,5,2),K+INL#);
              CALL M$WRITE(WR_DOC);
              CALL BINCHAR(SUBSTR(UNL.C,5,2),K);
              %WLINE(BUF = UNL);
              NBR.KWD = 0;
              NBR# = NBR# + 1;
              CALL M$WRITE(WR_OUT);
              CALL INSERT(OUT_BUF,0,K+1,' ');
           END;
           IF SUBSTR(BUFFER,M,4) = SUBSTR(BUFFER,M+1,4)
             OR SUBSTR(OUT_BUF,0,4) = SUBSTR(OUT_BUF,1,4)
             AND SUBSTR(OUT_BUF,0,1) ~= ' ' OR BYTNBR + CHAR_LEN - M < 4
             AND SUBSTR(BUFFER,BYTNBR+CHAR_LEN-1,1) > '@'
             OR SUBSTR(BUFFER,M,2) = 'o'
             OR SUBSTR(BUFFER,M,1) >= '0' AND SUBSTR(BUFFER,M,1) <= '9'
           THEN GOTO BURF;
           I = 0;
           DO WHILE(SUBSTR(OUT_BUF,I,4) = ' ');
              I = I + 4;
           END;
           CALL INDEX(I,'    ',OUT_BUF,I);
           IF I < WR_OUT.BUF_.BOUND THEN GOTO BURF;
           IF FL2 OR COLON < 0 THEN DO;
              IF SUBSTR(BUFFER,M,1) < '0'
                OR SUBSTR(BUFFER,BYTNBR+CHAR_LEN-1,1) = ':'
              THEN GOTO BURF;
              I = M;
              CALL SPCLWRD ALTRET(BURF);
              CALL SPCLWRD ALTRET(BURF);
              CALL SPCLWRD ALTRET(BURF);
              IF LCFLG AND SUBSTR(BUFFER,M+1,1) < 'a'
                AND SUBSTR(BUFFER,M+1,1) ~= ' ' THEN GOTO BURF;
           END;
           GOTO NOBURF;
BURF:      ;
           CALL INDEX1R(I,' ',OUT_BUF,WR_OUT.BUF_.BOUND);
           CALL XLATE(TOKEN.CHR,TRANSTBL,
             SUBSTR(OUT_BUF,I+1,WR_OUT.BUF_.BOUND-I));
           IF SUBSTR(TOKEN.CHR,3,1) = ' '
             AND (SUBSTR(TOKEN.CHR,2,1) = ' ' OR SUBSTR(TOKEN.CHR,2,1) > '@')
           THEN DO;
              CALL INDEX2(I,SUBSTR(TOKEN.CHR,0,2),CONNECTS);
              IF I < SIZEC(CONNECTS) THEN GOTO NOBURF;
           END;
           IF COLON < 0 THEN COLON = -4;
           IF M > BYTNBR + K THEN M = BYTNBR + K;
           ELSE IF SUBSTR(BUFFER,M,1) ~= ' ' AND NOT FL1
                AND SUBSTR(OUT_BUF,0,WR_OUT.BUF_.BOUND+1) ~= ' '
              THEN DO;
                 %WLINE(BUF = BRF);
              END;
NOBURF:    ;
           IF M > (BYTNBR + J) AND NOT FL2
           THEN DO;
              M = BYTNBR + J - 2;
              IF COLON < 0 THEN COLON = -4;
           END;
           L = CHAR_LEN - M + BYTNBR;
           OUT_BUF = SUBSTR(BUFFER,M,L);
           IF L = 0 THEN WR_OUT.BUF_.BOUND = 0;
           ELSE WR_OUT.BUF_.BOUND = L - 1;
           IF SUBSTR(OUT_BUF,WR_OUT.BUF_.BOUND,1) = ':' THEN COLON = -4;
           IF OUT_BUF = 'TU' OR OUT_BUF = 'tu' THEN DO;
              OUT_BUF = '.FIF';
              WR_OUT.BUF_.BOUND = 3;
              FL1 = '1'B;
           END;
           IF OUT_BUF = 'TF' OR OUT_BUF = 'tf' THEN DO;
              OUT_BUF = '.FIN';
              WR_OUT.BUF_.BOUND = 3;
              FL1 = '0'B;
           END;
           IF NOT DONE THEN CALL M$WRITE(WR_OUT);
           IF NBR# > 20 THEN DO;
              %WLINE(BUF = BEK);
              NBR# = 0;
           END;
           NBR# = NBR# + 1;
           COLON = COLON + 1;
 
           CALL GET_LN;
        END;
 
        IF FL1 THEN DO;
           %WLINE(BUF = FIN);
        END;
 
        IF NBR# <= 0 THEN GOTO WR_LINE;
        %WLINE(BUF = BEK);
        %WLINE(BUF = SPB);
        RETURN;
%EJECT;
/*****************************************************************/
/***/
/*F*     NAME: BLDMAN
         PURPOSE: BLDMAN will create a TEXT input file for the
                   purpose of creating manuals from the *F* and
                   *K* messages. (if other comment types are
                   desired then OP_LST is altered).
                                                                 */
BLDMAN: ENTRY (DT_LST);
        WR_DOC.V.DCB# = R1UNIT;
        WR_OUT.V.DCB# = R1UNIT;
        WR_OUT.BUF_.BUF$ = ADDR(OUT_BUF);
        IF ADDR(DT_LST)=ADDR(NIL) THEN DO;
           PTR1$ = MD_PTRS.A_POST$;
           CALL PUT_PAKET;
           RETURN;
        END;
        IF MAN_NRECS=0 THEN DO;
           XCLDPTR$ = DCBADDR(DCBNUM(F$EXCLUDE));
           IF XCLDPTR$->F$DCB.NAME#.C~=' '
           THEN XCLDPTR$ = ADDR(XCLDPTR$->F$DCB.NAME#);
           ELSE XCLDPTR$ = ADDR(NIL);
        END;
        BYTNBR = DT_LST.BYT#;
        BLKNBR = DT_LST.BLK#;
        IF BUFFERU(0) ~= BLKNBR THEN CALL DBREAD(TXTUNT,BUFFER,BLKNBR);
        CHAR_LEN = 0;
        CALL GET_LN;
        IF DONE OR XCLD THEN RETURN;
        MAN_NRECS = MAN_NRECS+1;
        IF DT_LST.TYP = 4 THEN PTR1$ = MD_PTRS.K_PRE$;
        ELSE DO;
           IF MAN_NRECS = 1 THEN PTR1$ = MD_PTRS.A_PRE$;
           ELSE PTR1$ = MD_PTRS.F_PRE$;
           M = M + 5;                   /* SKIP NAME:                         */
           DO WHILE(SUBSTR(BUFFER,M,1)=' ');
              M = M + 1;
           END;
           CALL INDEX1(J,'.',SUBSTR(BUFFER,M,CHAR_LEN+BYTNBR-M));
        END;
        CALL PUT_PAKET;
        FL1 = TRUE;
        FL2 = FALSE;
        FL3 = FALSE;
        LCFLG = FALSE;
        LEVL.N(0) = 0;
        DO WHILE(NOT DONE);
           L = CHAR_LEN + BYTNBR - M;
           IF L<0 THEN L=0;
           OUT_BUF = SUBSTR(BUFFER,M,L);
           IF SUBSTR(OUT_BUF,0,4) = 'TU'
             OR SUBSTR(OUT_BUF,0,4) = 'tu' THEN OUT_BUF = '.FIF';
           IF SUBSTR(OUT_BUF,0,4) = 'TF'
             OR SUBSTR(OUT_BUF,0,4) = 'tf' THEN OUT_BUF = '.FIN';
           IF SUBSTR(OUT_BUF,0,4) = 'T+99'
             OR SUBSTR(OUT_BUF,0,4) = 't+99' THEN OUT_BUF = '.BRP';
           CALL INDEX1(I,' ',OUT_BUF);
           IF SUBSTR(OUT_BUF,0,1) ~= '(' THEN F2C(0) = SUBSTR(OUT_BUF,0,1);
           ELSE F2C(0) = SUBSTR(OUT_BUF,1,1);
UNDCHK:    IF ((F2C(0) = 'a' OR F2C(0) = '1' OR F2C(0) = 'o') AND
             (FL1 OR FL3)
             OR FL2 AND F2C(FL2.N) = F2C(0))
             AND I<4 AND (I=1 OR SUBSTR(OUT_BUF,I-1,1)='.'
             OR SUBSTR(OUT_BUF,I-1,1)=')') THEN DO;
              DO WHILE(I<5 AND SUBSTR(OUT_BUF,I,1)=' ');
                 I=I+1;
              END;
              IF NOT FL2 OR F2C(FL2.N)~=F2C(0) AND FL2.N<15 THEN DO;
                 FL2.N = FL2.N+1;
                 CALL INSERT(INL.C,5,2,'+',BINASC(2*I-1+ASCBIN('0')));
                 CALL INSERT(UNL.C,5,2,'0',BINASC(I+ASCBIN('0')));
                 %WLINE(BUF = INL);
                 F2I(FL2.N) = SUBSTR(INL.C,6,1);
                 F2C(FL2.N) = F2C(0);
              END;
              FL3 = FALSE;
              %WLINE(BUF = UNL);
              IF F2C(0) ~= 'o' THEN F2C(FL2.N) = BINASC(ASCBIN(F2C(0))+1);
           END;
           ELSE IF FL2 AND FL1 THEN DO;
                 CALL INSERT(INL.C,5,2,'-',F2I(FL2.N));
                 %WLINE(BUF = INL);
                 FL2.N = FL2.N-1;
                 CALL INSERT(UNL.C,6,1,BINASC((ASCBIN(F2I(FL2.N))+49)/2));
                 IF FL2 THEN GOTO UNDCHK;
              END;
           IF OUT_BUF = ' ' THEN DO;
              FL1 = TRUE;
              FL3 = FALSE;
           END;
           ELSE FL1=FALSE;
           IF OUT_BUF = '.FIF' THEN LCFLG = TRUE;
           ELSE IF OUT_BUF = '.FIN' THEN LCFLG = FALSE;
           IF SUBSTR(OUT_BUF,0,1)='}' THEN DO;
              CALL INSERT(OUT_BUF,0,1,' ');
              IF OUT_BUF = ' ' THEN CALL INSERT(OUT_BUF,1,1,BINASC(8));/* BS  */
              FL3 = TRUE;
           END;
           ELSE IF FL3 THEN DO;
                 %WLINE(BUF = BRF);
                 FL3 = FALSE;
              END;
           IF L<4 THEN L=4;
           IF SUBSTR(OUT_BUF,L-1,1) = ':' THEN FL3 = TRUE;
           WR_OUT.BUF_.BOUND = L-1;
           CALL M$WRITE(WR_OUT);
           XCLD = TRUE;
           DO WHILE XCLD;
              CALL GET_LN;
           END;
        END;
        IF DT_LST.TYP=2 THEN PTR1$ = MD_PTRS.F_POST$;
        ELSE PTR1$ = MD_PTRS.K_POST$;
        CALL PUT_PAKET;
        RETURN;
/***** *** ** *** *** ** *** *** ** *** *** *****/
%EJECT;
 
GET_LN : PROC ALTRET;
DCL SPCLWRDS CHAR(0)CONSTANT INIT(
'-=+./:@_|"');
DCL CHAR4 CHAR(4);
DCL BIT36 REDEF CHAR4 BIT(36);
 
        XCLD = FALSE;
        BYTNBR = BYTNBR + CHAR_LEN;
NXT_LN: ;
        CHAR_LEN = ASCBIN(SUBSTR(BUFFER,BYTNBR,1));
        IF CHAR_LEN = 0 THEN DO;
           IF LEVL.N(0) ~= 0 THEN DO;
NXT_LVL:      ;
              BLKNBR = LEVL.SAV.BLK(LEVL.N(0));
              BYTNBR = LEVL.SAV.BYT(LEVL.N(0));
              IF BLKNBR ~= BUFFERU(0) THEN CALL DBREAD(TXTUNT,BUFFER,BLKNBR);
              LEVL.N(0) = LEVL.N(0)-1;
              GOTO NXT_LN;
           END;
           DONE = TRUE;
           RETURN;
        END;
        DONE = FALSE;
        IF (BYTNBR + CHAR_LEN + 1) > 4095
        THEN DO;
           BLKNBR = BLKNBR+1;
           CALL DBREAD(TXTUNT,BUFFER,BLKNBR);
           BYTNBR = 5;
           CHAR_LEN = ASCBIN(SUBSTR(BUFFER,4,1));
        END;
        ELSE BYTNBR = BYTNBR + 1;
        IF SUBSTR(BUFFER,BYTNBR,1) = BINASC(160)
        THEN CALL INSERT(BUFFER,BYTNBR,1,' ');
        M = BYTNBR;
        IF NOT MANFLG AND NOT LCFLG THEN DO;
           CALL INDEX1(I,'a',SUBSTR(BUFFER,M,CHAR_LEN),0,'037'O) ALTRET(NO_LC);
           LCFLG = '1'B;
NO_LC:     ;
        END;
        IF DOCFLG OR NOT LCFLG
        THEN DO WHILE(SUBSTR(BUFFER,M,1) = ' ' OR SUBSTR(BUFFER,M,1) = '*');
           M = M + 1;
        END;
        I = BYTNBR+CHAR_LEN-M-4;
        CHAR4 = SUBSTR(BUFFER,M,4);
        BIT36 = BIT36&'777737737737'O;  /* CONVERT TO UC                      */
        IF CHAR4 = '.XEQ' AND I>=0 THEN DO;
           M = M+4;
           IF I>3 AND SUBSTR(BUFFER,M,1)='~' THEN DO;
              IF XCLDPTR$~=ADDR(NIL)
              THEN CALL INDEX(N,SUBSTR(BUFFER,M+1,1),XCL.CHRS)
                 WHENRETURN DO; BYTNBR = M+I; GOTO NXT_LN; END;
              M = M+2; I = I-2;
           END;
           OUT_BUFFER = SUBSTR(BUFFER,M,I);
           BYTNBR = M+I; CHAR_LEN = I-1;
           M = 0;
           DO WHILE M<I;
              IF SUBSTR(OUT_BUFFER,M,2) = ' ' THEN DO;
                 SUBSTR(OUT_BUFFER,M) = SUBSTR(OUT_BUFFER,M+1);
                 I = I-1;
              END;
              CALL INDEX(M,'  ',OUT_BUFFER,M);
           END;
           IF I<=0 THEN IF LEVL.N(0)~=0 THEN GOTO NXT_LVL;
              ELSE GOTO NXT_LN;
           SUBSTR(BUFFER,BYTNBR-CHAR_LEN,CHAR_LEN) = SUBSTR(OUT_BUFFER,1);
           TOKEN.CHR = SUBSTR(OUT_BUFFER,1);
           XEQ_KEY.L = I-1;
           CALL M$PRECORD (XEQ) WHENRETURN DO; GOTO NO_XEQ; END;
           WHENALTRETURN DO;
              IF SUBSTR(OUT_BUFFER,1,I-1)~=SUBSTR(BUFFER,BYTNBR-CHAR_LEN,CHAR_LEN)
                OR XEQ_KEY.L<=I THEN DO;
NO_XEQ:          TOKEN.LEN = MINIMUM(35,I-1);
                 CALL TELLER(%NO_XEQ_CMT);
                 TOKEN.LEN = 0;
                 GOTO NXT_LN;
              END; END;
           OUT_BUFFER = SUBSTR(OUT_BUFFER,XEQ_KEY.L-5,6);
           LEVL.N(0) = LEVL.N(0)+1;
           LEVL.SAV.BLK(LEVL.N(0)) = BLKNBR;
           LEVL.SAV.BYT(LEVL.N(0)) = BYTNBR;
           BYTNBR = XEQ_KEY.BYT;
           BLKNBR = XEQ_KEY.BLK;
           IF BLKNBR~=BUFFERU(0) THEN CALL DBREAD(TXTUNT,BUFFER,BLKNBR);
           BYTNBR = BYTNBR+ASCBIN(SUBSTR(BUFFER,BYTNBR,1))+1;
           DO WHILE BYTNBR>=4095 OR SUBSTR(BUFFER,BYTNBR,2)=%CONCAT(BINASC(1),' ');
              IF BYTNBR>4095 THEN DO;
                 BLKNBR = BLKNBR+1;
                 CALL DBREAD(TXTUNT,BUFFER,BLKNBR);
                 BYTNBR = 4 + ASCBIN(SUBSTR(BUFFER,4,1)) + 1;
              END;
              ELSE IF BYTNBR=4095 AND SUBSTR(BUFFER,BYTNBR,1)=BINASC(0)
                 THEN EXIT;
                 ELSE BYTNBR = BYTNBR+2;
           END;
           GOTO NXT_LN;
        END;
        IF MANFLG THEN DO;
           IF CHAR_LEN>2 AND SUBSTR(BUFFER,BYTNBR+CHAR_LEN-2,1)='~' THEN DO;
              IF XCLDPTR$~=ADDR(NIL)
              THEN CALL INDEX(N, SUBSTR(BUFFER,BYTNBR+CHAR_LEN-1,1), XCL.CHRS)
                 WHENRETURN DO;
                    XCLD = TRUE;
                 END;
              CALL INSERT(BUFFER,BYTNBR+CHAR_LEN-2,2,' ');
           END;
           RETURN;
        END;
        IF M >= CHAR_LEN + BYTNBR THEN M = BYTNBR;
        CALL INDEX1(I,':',SUBSTR(BUFFER,M,12))ALTRET(NOKEYWORD);
        CALL XLATE(TOKEN.CHR,TRANSTBL,SUBSTR(BUFFER,M,I));
        N = 0;
        DO WHILE(N <= KEY_MAX AND TOKEN.CHR ~= KEYWRD(N));
           N = N + 1;
        END;
        IF N > KEY_MAX THEN DO;
NOKEYWORD: I = 0;
        END;
        ELSE DO;
           IF N >= 4 THEN FL2 = '1'B;
           ELSE FL2 = '0'B;
           K = I;
           COLON = 0;
        END;
        RETURN;
SPCLWRD: ENTRY ALTRET;
        L = BYTNBR + CHAR_LEN;
        CALL INDEX1(I,' ',SUBSTR(BUFFER,0,L),I);
        DO WHILE(SUBSTR(BUFFER,I,1) = ' ' AND I < L);
           I = I + 1;
        END;
        IF I = L THEN RETRET:RETURN;
        CALL INDEX1(L,SUBSTR(BUFFER,I,1),SPCLWRDS)ALTRET(RETRET);
        ALTRETURN;
END GET_LN;
%EJECT;
/* ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** */
 
PUT_PAKET: PROC;
 
DCL X UBIN;
DCL S SBIN;
DCL NW SBIN;
DCL 1 TXTC BASED(PTR1$),
      2 L UBIN BYTE CALIGNED,
      2 T CHAR(TL);
DCL TL UBIN;
 
        S = 0;                     /* FLAG FOR SKIP THE TEXT (IF %W0 OCCURS)  */
        TL = TXTC.L;
        DO WHILE(TL~=0);
           OUT_BUF = TXTC.T;
           K = 0;L = 0;NW = 0;
           IF ADDR(DT_LST)=ADDR(NIL) THEN K = TL;
           DO WHILE(K<TL);
              CALL INDEX1(K,'%',TXTC.T,K) ALTRET(FINISH);
              IF SUBSTR(TXTC.T,K,3) = '%SS' THEN DO;
                 CALL INSERT(OUT_BUF,L+K,,SECT#.C,SUBSTR(TXTC.T,K+3));
                 K = K + 3;
                 L = L + SECT#.L - 3;
              END;
              IF SUBSTR(TXTC.T,K,3) = '%HH' THEN DO;
                 CALL INSERT(OUT_BUF,L+K,,MD_HDR.C,SUBSTR(TXTC.T,K+3));
                 K = K + 3;
                 L = L + MD_HDR.L - 3;
                 IF MD_HDR.L=0 THEN GOTO NOWRITE;
              END;
              ELSE IF SUBSTR(TXTC.T,K+1,1) = 'W' THEN DO;
                    X = ASCBIN(SUBSTR(TXTC.T,K+2,1))-48;
                    I = M;
                    IF X<10 THEN DO;
                       DO WHILE(X>1);
                          CALL INDEX1(I,' ',SUBSTR(BUFFER,0,CHAR_LEN+BYTNBR),I);
                          X = X-1;
                          DO WHILE(SUBSTR(BUFFER,I,1)=' ');
                             I = I+1;
                          END;
                       END;
                       IF X=0 THEN DO;
                          CALL INDEX1(X,'.',SUBSTR(BUFFER,I,CHAR_LEN+BYTNBR-I));
                          S = S+1;
                       END;
                       ELSE CALL INDEX1(X,' ',
                            SUBSTR(BUFFER,I,CHAR_LEN+BYTNBR-I));
                       IF X=0 AND K>0 THEN IF SUBSTR(TXTC.T,K-1,1)=' '
                          THEN L=L-1;
                       CALL INSERT(OUT_BUF,L+K,,SUBSTR(BUFFER,I,X),
                         SUBSTR(TXTC.T,K+3));
                       IF NW<=0 THEN IF X=0 THEN NW = -1;
                          ELSE NW = 1;
                       K = K+3;
                       L = L+X-3;
                    END;
                    ELSE K = K+1;
                 END;
                 ELSE IF SUBSTR(TXTC.T,K+1,1) = 'N' THEN DO;
                       X = ASCBIN(SUBSTR(TXTC.T,K+2,1))-48;
                       I = 0;
                       IF X<3 THEN DO;
                          DO WHILE(X>1);
                             CALL INDEX1(I,' ',DT_LST.NAM,I);
                             X = X-1;I = I+1;
                          END;
                          IF SUBSTR(DT_LST.NAM,I,1)=BINASC(160) THEN I = I+1;
                          CALL INDEX1(X,' ',SUBSTR(DT_LST.NAM,I));
                          CALL INSERT(OUT_BUF,L+K,,SUBSTR(DT_LST.NAM,I,X),
                            SUBSTR(TXTC.T,K+3));
                          K = K+3;L = L+X-3;
                       END;
                       ELSE K = K+1;
                    END;
                    ELSE K=K+1;
           END;
FINISH:    WR_OUT.BUF_.BOUND = L+K-1;
           IF NW>=0 THEN CALL M$WRITE(WR_OUT);
NOWRITE:   ;
           PTR1$ = PINCRC(PTR1$,TL+1);
           TL = TXTC.L;
        END;
        IF S~=0 THEN DO;
           CALL GET_LN;
           IF SUBSTR(BUFFER,BYTNBR,CHAR_LEN)=' ' THEN CALL GET_LN;
        END;
        RETURN;
END PUT_PAKET;
END BLDDOC;
