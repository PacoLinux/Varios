/*M* PMERGE - a program to merge patch files together */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
PM$MAIN: PROC MAIN;
 
/* This is the main procedure of PMERGE2 */
 
DCL ERROR ENTRY(1);
DCL FIND$STAR ENTRY(1) ALTRET;
DCL SORT ENTRY(4);
DCL XSA$OPEN ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
DCL XSA$READ ENTRY(2) ALTRET;
DCL XSA$WRITE ENTRY(2) ALTRET;
DCL XSA$PFIL ENTRY(2) ALTRET;
DCL X$PARSE ENTRY(1) ALTRET;
DCL SUB$UTS ENTRY(4);
DCL LISTER ENTRY(3);
DCL VERSION ENTRY ALTRET;
 
DCL MINIVERS CHAR(8);
DCL XDELVERS CHAR(8);
DCL TIGRVERS CHAR(30);
DCL BOOTTIMEVERS CHAR(8);
DCL INSRT BIT(1) STATIC INIT('0'B) UNAL;
DCL INSRTRUM BIT(1) STATIC INIT('0'B) UNAL;
DCL INSRTPLO BIT(1) STATIC INIT('0'B) UNAL;
DCL STARNUM UBIN;
DCL DONTADD UBIN;
DCL BBLOCK CHAR(4096) STATIC SYMDEF;
DCL KBLOCK CHAR(1024) STATIC SYMDEF;
DCL OLDSTAR CHAR(10);
DCL NEWSTAR CHAR(10);
DCL INPUT CHAR(256) STATIC SYMDEF;
DCL TEMP CHAR(256);
DCL NCHARS UBIN;
DCL TEST CHAR(10);
DCL OUTPUT CHAR(80) STATIC SYMDEF;
DCL TOUTPUT CHAR(100) STATIC SYMDEF;
DCL BANGFEP CHAR(5) INIT('!FEP ') STATIC SYMDEF;
DCL STACK(0:499) SBIN STATIC SYMDEF;
DCL REPL (0:499) SBIN;
DCL RLID UBIN;
DCL LID UBIN STATIC SYMDEF;
DCL LID1 UBIN STATIC SYMDEF;
DCL X CHAR(10);
DCL Y UBIN;
DCL Z UBIN;
DCL ECHO BIT(1) UNAL;
DCL WARNING BIT(1) UNAL;
DCL VERIFY BIT(1) STATIC INIT('1'B) UNAL;
DCL FAST BIT(1) STATIC INIT('0'B) UNAL;
DCL FID_TEXT CHAR(60) STATIC;
DCL INFILE CHAR(60);
DCL UTSTD CHAR(60);
DCL PATCHFID CHAR(60);
DCL OUTFILE CHAR(60);
DCL OLDFILE CHAR(60);
DCL HEADING CHAR(90);
DCL TUTS CHAR(60);
/*
*/
DCL PROCC CHAR(30);
DCL FID_ASN UBIN(9) STATIC ALIGNED;
DCL FID_RES CHAR(4) STATIC;
DCL STATE CHAR(1);
DCL NUX# UBIN STATIC;
DCL START UBIN STATIC;
DCL ERRBUFFER CHAR(120) STATIC;    /* Error message construction    */
DCL 1 ERRCODE STATIC,
      2 * BIT(33) UNAL,
      2 SEV UBIN(3) UNAL;
 
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$IN DCB;
DCL M$IN1 DCB;
DCL M$OUT DCB;
DCL M$PART DCB;
DCL M$LADC DCB;
DCL M$UTS DCB;
 
%INCLUDE CP_6;
%B$TCB;
%B$ALT;
DCL B$TCB$ PTR SYMREF;
 
 
/**/
 
%INCLUDE XS_MACRO_C;
 
%XSA_PARAM(FPTN=XSA_PARAM,BBUF=BBLOCK,KBUF=KBLOCK,STCLASS=STATIC SYMDEF);
 
%VLP_NAME(FPTN=VLP_NAME,STCLASS=STATIC);
%VLR_FID(FPTN=VLR_FID);
%VLP_ACCT(FPTN=VLP_ACCT,STCLASS=STATIC);
%VLP_PASS(FPTN=VLP_PASS,STCLASS=STATIC);
%VLP_SN(FPTN=VLP_SN,STCLASS=STATIC);
%VLP_WSN(FPTN=VLP_WSN,STCLASS=STATIC);
 
%FPT_OPEN(FPTN=OPENSHARED,
         STCLASS=STATIC,
         FUN=IN,
         ACS=SEQUEN,
         ASN=FILE,
         NAME=VLP_NAME,
         ACCT=VLP_ACCT,
         PASS=VLP_PASS,
         SHARE=ALL,
         SN=VLP_SN,
         WSN=VLP_WSN);
 
%FPT_OPEN(FPTN=OPENEW,
         STCLASS=STATIC,
         FUN=CREATE,
         EXIST=NEWFILE,
         ACS=SEQUEN,
         ORG=CONSEC,
         ASN=FILE,
         DCB=M$PART,
         CTG=YES,
         NAME=VLP_NAME,
         ACCT=VLP_ACCT,
         PASS=VLP_PASS,
         SN=VLP_SN,
         WSN=VLP_WSN);
 
%FPT_OPEN(FPTN=OPENUP,
         STCLASS=STATIC,
         FUN=UPDATE,
         EXIST=OLDFILE,
         ACS=SEQUEN,
         ORG=CONSEC,
         ASN=FILE,
         NAME=VLP_NAME,
         ACCT=VLP_ACCT,
         PASS=VLP_PASS,
         SN=VLP_SN,
         WSN=VLP_WSN);
 
%FPT_FID(FPTN=FPT_FID,
         STCLASS=STATIC,
         ACCT=VLP_ACCT,
         ASN=FID_ASN,
         NAME=VLP_NAME,
         PASS=VLP_PASS,
         RES=FID_RES,
         RESULTS=VLR_FID,
         SN=VLP_SN,
         TEXTFID=FID_TEXT,
         WSN=VLP_WSN);
 
%FPT_OPEN(FPTN=OPEN_SCAN,
         STCLASS=STATIC,
         FUN=IN,
         DCB=M$IN1,
         EXIST=OLDFILE,
         ACS=SEQUEN,
         ASN=FILE,
         THISF=NO,
         TEST=YES,
         SN=VLP_SN,
         ACCT=VLP_ACCT,
         PASS=VLP_PASS,
         NXTF=YES,
         WSN=VLP_WSN);
 
%FPT_UNFID(FPTN=SCAN$UNFID,
         DCB=M$IN1,
         STCLASS=STATIC,
         ACCT=VLP_ACCT,
         NAME=VLP_NAME,
         PASS=VLP_PASS,
         RES=FID_RES,
         ASN=FID_ASN,
         SN=VLP_SN,
         TEXTFID=FID_TEXT,
         WSN=VLP_WSN);
 
%FPT_CLOSE(FPTN=CLOSE,DISP=SAVE);
 
%FPT_ERRMSG(FPTN=ERRBUFFERMSG,
   OUTDCB1=M$DO,
   BUF=ERRBUFFER,
   CODE=ERRCODE,
   INCLCODE=NO);
 
%FPT_READ(FPTN=READSI,DCB=M$SI,BUF=INPUT);
%FPT_WRITE(FPTN=WRITELO,DCB=M$LO,BUF=OUTPUT,STCLASS=STATIC SYMDEF);
%FPT_WRITE(FPTN=WRITEDO,BUF=OUTPUT,DCB=M$DO,STCLASS=STATIC SYMDEF);
%FPT_READ(FPTN=READPATCH,BUF=INPUT,STCLASS=STATIC SYMDEF);
%FPT_WRITE(FPTN=WRITEPATCH,BUF=OUTPUT,STCLASS=STATIC SYMDEF);
%FPT_PRECORD(FPTN=POSITION);
%FPT_DELREC(FPTN=PURGE,KEY=START,LKEY=NUX#);
%FPT_PFIL(FPTN=BOF,BOF=YES);
%FPT_PFIL(FPTN=EOF,BOF=NO);
%FPT_CLOSE(FPTN=RELEASE,DISP=RELEASE);
%FPT_CLOSE(FPTN=CL$LADC,DISP=RELEASE,DCB=M$LADC);
%FPT_CORRES(FPTN=CORRES,DCB1=M$LO,DCB2=M$SI);
%F$DCB;
 
%INCLUDE PMERGE_C62;
%INCLUDE PMERGE_C61;
 
DCL COMMAND UBIN SYMREF;
DCL BLOCK UBIN;
%INCLUDE XU_MACRO_C;
DCL PARSE_WORK               CHAR(1024) STATIC SYMDEF;
%P_PCB(T=INPUT,
         STCLASS="STATIC SYMDEF",
         R=COMMAND,
         W=PARSE_WORK,
         WSZ=256,
         N#=256);                       /* PARSE CONTOL BLOCK                 */
%PARSE$SYM(NAME=OUTSYM,
         STCLASS=BASED);                /* FOR SYMBOLS AND DELIM STRINGS      */
%PARSE$OUT(NAME=OUTBLK,
         STCLASS=BASED);                /* FOR OUTPUT BLOCKS                  */
 
/***********************
 *                     *
 *  Partition patches  *
 *                     *
 * This is step 1      *
 *                     *
 ***********************/
 
 
        OUTPUT=' ';
        CALL M$WRITE(WRITELO);
        OUTPUT=' -- PMERGE C00 --';
        CALL M$WRITE(WRITELO);
        OUTPUT=' ';
        CALL M$WRITE(WRITELO);
        UTSTD=':UTS_STD.SUPPORT';
        WARNING='1'B;
        CALL EXISTS(UTSTD,'1'B) ALTRET(NOUTS);
        GOTO START;
 
NOUTS:  UTSTD=' ';
 
START:  DO WHILE('1'B);
 
           ECHO='0'B;
           INPUT=' ';
           CALL M$READ(READSI) ALTRET(XXX);
           IF INPUT=' ' THEN GOTO START;
           CALL M$CORRES(CORRES) ALTRET(SKIPLO);
           CALL CONCAT(OUTPUT,'$',INPUT);
           CALL M$WRITE(WRITELO);
SKIPLO:
 
           P_PCB.NCHARS=DCBADDR(DCBNUM(M$SI))->F$DCB.ARS#;
           CALL X$PARSE(P_PCB) ALTRET(SYN);
 
           BLOCK=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE;
 
           DO CASE(BLOCK);
 
            CASE(RUM#);
 
              PROCC=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
              TUTS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
              IF UTSTD~=' ' THEN CALL SUB$UTS(UTSTD,PROCC,TUTS,'1'B);
 
 
            CASE(PLOVER#);
 
              PROCC=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
              TUTS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
              IF UTSTD~=' ' THEN CALL SUB$UTS(UTSTD,PROCC,TUTS,'1'B);
 
            CASE(CHECK#);
 
              Y=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS;
              Z=0;
              DO WHILE(Z<Y);
 
                 PATCHFID=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTBLK
                   .SUBLK$(Z)->OUTSYM.TEXT;
                 CALL CHECKFID('0'B) ALTRET(NOCHECK);
 
                 CLOSE.V.DCB#=DCBNUM(M$IN);
                 CALL XSA$CLOSE(CLOSE,XSA_PARAM) ALTRET(GOON);
GOON:            Z=Z+1;
                 OUTPUT=' ';
                 CALL M$WRITE(WRITELO);
                 END;
              DO WHILE('0'B);
 
NOCHECK:         CALL ERROR(NCHECK#);
 
                 END;
 
 
CASE(VERIFY#);
 
VERIFY = '1'B;
 
CASE(NVERIFY#);
 
VERIFY = '0'B;
 
 
CASE(FAST#);
 
FAST = '1'B;
 
CASE(NFAST#);
 
FAST = '0'B;
 
            CASE(IRUM#);
 
              INSRTRUM='1'B;
 
            CASE(IPLO#);
 
              INSRTPLO='1'B;
 
            CASE(INOFF#);
 
              INSRTPLO='0'B;
              INSRTPLO='0'B;
 
            CASE(PMERGE#);
 
 
              CALL OPENSCRATCH('*MINI');
              CALL OPENSCRATCH('*XDEL');
              CALL OPENSCRATCH('*TIGR');
              CALL OPENSCRATCH('*RUM ');
              CALL OPENSCRATCH('*PLOV ');
              CALL OPENSCRATCH('*BOOT ');
 
              Y=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS;
              Z=0;
 
              OLDFILE=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.
                TEXT;
              OUTFILE=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(2)->OUTSYM.
                TEXT;
              CALL EXISTS(OLDFILE,'1'B) ALTRET(BOTM);
              CALL EXISTS(OUTFILE,'0'B) ALTRET(BOTM);
 
              FID_TEXT=OLDFILE;
              CALL M$FID(FPT_FID);
              TEMP=INPUT;
              NCHARS=P_PCB.NCHARS;
              OPENSHARED.V.RES#=FID_RES;
              OPENSHARED.V.ASN#=FID_ASN;
              IF VERIFY='1'B THEN CALL SCANFILE('1'B) ALTRET(BOTM);
              P_PCB.NCHARS=NCHARS;
              INPUT=TEMP;
              CALL X$PARSE(P_PCB);
              DO WHILE(Z<Y);
 
                 P_PCB.NCHARS=NCHARS;
                 INPUT=TEMP;
                 CALL X$PARSE(P_PCB);
                 PATCHFID=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTBLK
                   .SUBLK$(Z)->OUTSYM.TEXT;
                 CALL CHECKFID('1'B);
 
NOPART:          Z=Z+1;
 
                 END;
 
              CALL MAINPROC;
              CLOSE.V.DCB#=DCBNUM(M$PART);
              CALL XSA$CLOSE(CLOSE,XSA_PARAM);
 
            CASE(FIXUTS#);
 
              Y=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS;
              Z=0;
              PATCHFID=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.
                TEXT;
              OUTFILE=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.
                TEXT;
              FID_TEXT=PATCHFID;
              CALL M$FID(FPT_FID);
              NCHARS=P_PCB.NCHARS;
              OPENSHARED.V.RES#=FID_RES;
              OPENSHARED.V.ASN#=FID_ASN;
              OPENSHARED.V.DCB#=DCBNUM(M$IN);
              CALL XSA$OPEN(OPENSHARED,XSA_PARAM);
              READPATCH.V.DCB#=DCBNUM(M$IN);
 
              FID_TEXT=OUTFILE;
              CALL M$FID(FPT_FID);
              OPENEW.V.ASN#=FID_ASN;
              OPENEW.V.RES#=FID_RES;
              OPENEW.V.DCB#=DCBNUM(M$OUT);
              CALL XSA$OPEN(OPENEW,XSA_PARAM) ALTRET(MONERR);
              WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
 
              CALL FIXUTS;
 
 
            CASE(MINIV#);
 
              MINIVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
 
            CASE(XDELV#);
 
              XDELVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
 
            CASE(TIGRV#);
 
              TIGRVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
            CASE(BOOTIMEV#);
 
              BOOTTIMEVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
            CASE(OPTIONS#);
 
              UTSTD=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
              CALL EXISTS(UTSTD,'1'B) ALTRET(CLEAR);
 
              DO WHILE('0'B);
 
CLEAR:           UTSTD=' ';
 
                 END;
 
            CASE(WARN#);
 
              WARNING='1'B;
 
            CASE(NWARN#);
 
              WARNING='0'B;
 
            CASE(QUIT#);
 
              CALL M$EXIT;
 
            END;
 
           DO WHILE('0'B);
 
BOTM:         OUTPUT=' ';
              CALL M$WRITE(WRITELO);
 
              END;
 
           DO WHILE('0'B);
 
MONERR: ;
             CALL FTX_RPTERR;
             CALL M$EXIT;
              END;
 
           END;
 
 
%EJECT;
 
MAINPROC: PROC;
 
 
/*******************************
 *                             *
 * Check for patches % section *
 *                             *
 * This is step 2              *
 *                             *
 *******************************/
 
 
        FID_TEXT=OUTFILE;
        OPENEW.V.DCB#=DCBNUM(M$OUT);
        CALL M$FID(FPT_FID);
        OPENEW.V.ASN#=FID_ASN;
        OPENEW.V.RES#=FID_RES;
        CALL XSA$OPEN(OPENEW,XSA_PARAM) ALTRET(MONERR);
        WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
        CALL CONCAT(OUTPUT,'!MINI   "',MINIVERS);
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
/* Check for Mini, if altret on first read dump all base file */
 
        CALL OPEN$OLD;
        READPATCH.V.DCB#=DCBNUM(M$IN);
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(MINERR);
        OUTPUT=INPUT;
        IF SUBSTR(OUTPUT,0,5)='!MINI' THEN ;
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No MINI section in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_MINI;
           END;
        STATE='$';
        FID_TEXT='*MINI';
        CALL OPEN$PATCH;
        CALL LOADSTARS;
        CALL CONCAT(HEADING,'*** MINI    v: ',MINIVERS);
        CALL LISTER(STACK,LID,HEADING);
        INPUT=' ';
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(R1);
        TOUTPUT=' ';
        CALL MXF;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
        GOTO NEXT;
 
R1:
 
        CALL DUMP;
SKIP_MINI:;
        IF SUBSTR(OUTPUT,0,5)='!XDEL' THEN ;
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No XDEL section in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_XDEL;
           END;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
NEXT:
 
        FID_TEXT='*XDEL';
        CALL OPEN$PATCH;
        INPUT=' ';
        CALL LOADSTARS;
        CALL CONCAT(HEADING,'*** XDEL    v: ',XDELVERS);
        CALL LISTER(STACK,LID,HEADING);
        READPATCH.V.DCB#=DCBNUM(M$PART);
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(R2);
        TOUTPUT=' ';
        CALL MXF;
SKIP_XDEL:;
        IF SUBSTR(OUTPUT,0,5)='!TIGR' THEN ;
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No TIGR section in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_TIGR;
           END;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
        GOTO NEXT1;
 
R2:
        CALL DUMP;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
NEXT1:
 
        FID_TEXT='*TIGR';
        CALL OPEN$PATCH;
        INPUT=' ';
        READPATCH.V.DCB#=DCBNUM(M$PART);
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(R3);
        CALL TIGER;
           TOUTPUT=OUTPUT;
        WRITELO.V.DVBYTE.VFC#='1'B;
        OUTPUT='p +++ New TIGR section.';
        CALL M$WRITE(WRITELO);
        OUTPUT='A';
        CALL M$WRITE(WRITELO);
        WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_TIGR;
 
R3:
 
        CALL DUMP;
SKIP_TIGR:;
        IF SUBSTR(OUTPUT,0,4)='!RUM' THEN ;
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No RUM section in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_RUM;
           END;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
NEXT2:
 
        CALL INIT$RUM('R')  ALTRET(DUMPIT);
 
        DO WHILE('0'B);
 
DUMPIT:    CALL DUMP;
 
           END;
SKIP_RUM:;
        IF SUBSTR(OUTPUT,0,4)=BANGFEP THEN DO ;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ Skipping FEP section.      ';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
 
        DO WHILE('1'B);                 /* SPIN PAST FEP                      */
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(NEXT5);
           OUTPUT=INPUT;
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO SKIP_FEP;
 
           END;
 
           END;
 
SKIP_FEP:;
        IF SUBSTR(OUTPUT,0,7)='!PLOVER' THEN ;
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No PLOVER section in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_PLOVER;
           END;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
        CALL INIT$RUM('P')  ALTRET(DUMPIT2);
 
        DO WHILE('0'B);
 
DUMPIT2:   CALL DUMP;
 
           END;
 
SKIP_PLOVER:;
        IF SUBSTR(OUTPUT,0,8)='!BOOTIME' THEN ;
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No BOOTIME section in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SKIP_BOOTTIME;
           END;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
NEXT4:
 
        FID_TEXT='*BOOT';
        CALL OPEN$PATCH;
        INPUT=' ';
        READPATCH.V.DCB#=DCBNUM(M$PART);
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(R4);
        CALL TIGER;
        WRITELO.V.DVBYTE.VFC#='1'B;
        OUTPUT='p +++ New BOOTIME section.';
        CALL M$WRITE(WRITELO);
        OUTPUT='A';
        CALL M$WRITE(WRITELO);
        WRITELO.V.DVBYTE.VFC#='0'B;
        GOTO NEXT5;
 
R4:
 
        CALL DUMP;
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
SKIP_BOOTTIME:;
NEXT5:;
           OUTPUT=INPUT;
        IF SUBSTR(INPUT,0,4)='!FIN' THEN CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
 
        ELSE DO;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ No !FIN card in template.';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT='!FIN';
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM) ALTRET(MONERR);
           END;
 
        ;                               /* ALL DONE AT THIS STEP              */
 
%EJECT;
 
 
NONE:   OUTPUT='* pmerged *';
        CALL M$WRITE(WRITELO);
        CLOSE.V.DCB#=DCBNUM(M$OUT);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        RETURN;
 
MINERR: CALL ERROR(MINERR#);
 
        CALL M$EXIT;
 
XDERR:  CALL ERROR(XDERR#);
 
        CALL M$EXIT;
 
TGERR:  CALL ERROR(TGERR#);
 
        CALL M$EXIT;
 
RUMERR: CALL ERROR(RUMERR#);
 
        CALL M$EXIT;
 
PLOVERERR: CALL ERROR(PLOVERERR#);
 
        CALL M$EXIT;
 
BOOTTIMEERR: CALL ERROR(BOOTIMEERR#);
 
        CALL M$EXIT;
 
EOF:    CALL ERROR(EOF#);
 
        CALL M$EXIT;
 
MONERR: ;
   CALL FTX_RPTERR;
   CALL M$EXIT;
 
END;
%EJECT;
FTX_RPTERR: PROC;
/*F*     NAME: FTX_RPTERR
         PURPOSE: Report ALTRET frame error.
 ***/
 
/********************/
 
   ERRBUFFERMSG.V.DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
   ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
   ERRCODE.SEV = 0;
   CALL M$ERRMSG(ERRBUFFERMSG);
   RETURN;
 
END FTX_RPTERR;
%EJECT;
OPEN$PATCH: PROC;
 
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM) ALTRET(OK);
OK:     CALL M$FID(FPT_FID);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        OPENUP.V.RES#=FID_RES;
        OPENUP.V.ASN#=FID_ASN;
        CALL XSA$OPEN(OPENUP,XSA_PARAM);
        READPATCH.V.DCB#=DCBNUM(M$PART);
        POSITION.V.DCB#=DCBNUM(M$PART);
        BOF.V.DCB#=DCBNUM(M$PART);
 
END;
%EJECT;
 
OPEN$OLD: PROC;
 
        FID_TEXT=OLDFILE;
        OPENSHARED.V.DCB#=DCBNUM(M$IN);
        CLOSE.V.DCB#=DCBNUM(M$IN);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM) ALTRET(OK);
 
OK:
 
        CALL M$FID(FPT_FID);
        OPENSHARED.V.ASN#=FID_ASN;
        OPENSHARED.V.RES#=FID_RES;
        CALL XSA$OPEN(OPENSHARED,XSA_PARAM);
 
END;
%EJECT;
PARTPATCH: PROC;
 
        WRITEPATCH.V.DCB#=DCBNUM(M$PART);
        READPATCH.V.DCB#=DCBNUM(M$IN);
        BOF.V.DCB#=DCBNUM(M$IN);
        CALL XSA$PFIL(BOF,XSA_PARAM);
TOP:    INPUT=' ';
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(NONE);
UP:     CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
 
        IF(SUBSTR(INPUT,0,1)~='!') THEN GOTO ERRCMND;
 
        IF(SUBSTR(INPUT,0,5)='!MINI') THEN FID_TEXT='*MINI';
 
        ELSE IF(SUBSTR(INPUT,0,5)='!XDEL') THEN FID_TEXT='*XDEL';
 
           ELSE IF(SUBSTR(INPUT,0,7)='!PLOVER')  THEN CALL RUM('P') ALTRET(TEST);
           ELSE IF(SUBSTR(INPUT,0,8)='!BOOTIME') THEN CALL TIGR ALTRET(TEST);
 
                 ELSE IF(SUBSTR(INPUT,0,5)='!TIGR') THEN CALL TIGR ALTRET(TEST);
 
                    ELSE IF(SUBSTR(INPUT,0,4)='!RUM') THEN CALL RUM('R') ALTRET(
                            TEST);
 
                       ELSE IF(SUBSTR(INPUT,0,4)='!FIN') THEN RETURN;
 
                          ELSE DO;
 
                            IF SUBSTR(INPUT,0,4)=BANGFEP THEN DO ;
 
                               WRITELO.V.DVBYTE.VFC#='1'B;
                               TOUTPUT=OUTPUT;
                               OUTPUT='p +++ Skipping FEP section.      ';
                               CALL M$WRITE(WRITELO);
                               OUTPUT='A';
                               CALL M$WRITE(WRITELO);
                               WRITELO.V.DVBYTE.VFC#='0'B;
                               OUTPUT=TOUTPUT;
                               READPATCH.V.DCB#=DCBNUM(M$IN);
                               GOTO SPIN;
                               END;
 
ERRCMND:                     IF SUBSTR(INPUT,0,1)='"' THEN GOTO TOP;
                             ELSE CALL ERROR(NCMND#);
                             RETURN;
 
                             END;
 
 
        IF SUBSTR(INPUT,0,5)='!MINI' OR
          SUBSTR(INPUT,0,5)='!XDEL' THEN CALL CH$VERS('0'B) ALTRET(SPIN);
 
        DO WHILE('0'B);
 
SPIN:      DO WHILE('1'B);
              INPUT=' ';
              CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(NONE);
              IF SUBSTR(INPUT,0,1)='!' THEN GOTO UP;
              END;
           END;
        VLP_NAME.NAME#=SUBSTR(FID_TEXT,0,5);
        CALL OPEN$PATCH;
        READPATCH.V.DCB#=DCBNUM(M$IN);  /* RESET DCB#, OPEN$PATCH TRASHES IT  */
        EOF.V.DCB#=DCBNUM(M$PART);
        CALL XSA$PFIL(EOF,XSA_PARAM);   /* DO THIS 'CAUSE OPEN$PATCH          */
                                        /* BOF'S AND WILL SCREW THIS WRITE UP */
 
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(EX);
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO UP;
           OUTPUT=INPUT;
 
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
 
 
           END;
 
NONE:   RETURN;
 
 
EX:     RETURN;
TEST:   IF SUBSTR(INPUT,0,1)='!' THEN GOTO UP;
        IF DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#=0 THEN RETURN;
END;
TIGR:   PROC ALTRET;
 
        READPATCH.V.DCB#=DCBNUM(M$IN);
        CALL CH$VERS('0'B) ALTRET(SPIN);
        DO WHILE('0'B);
 
SPIN:      DO WHILE('1'B);
              INPUT=' ';
              CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(OUT);
              IF SUBSTR(INPUT,0,1)='!' THEN GOTO OUT;
              END;
           END;
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
OK:     FID_TEXT='*TIGR';
        IF SUBSTR(INPUT,0,8)='!BOOTIME' THEN FID_TEXT='*BOOT';
        CALL M$FID(FPT_FID);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        OPENUP.V.RES#=FID_RES;
        OPENUP.V.ASN#=FID_ASN;
        CALL XSA$OPEN(OPENUP,XSA_PARAM);
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(OUT);
           IF SUBSTR(INPUT,0,1)='!' THEN ALTRETURN;
           OUTPUT=INPUT;
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           END;
OUT:    ALTRETURN;
 
END;
 
RUM:    PROC(TYPE) ALTRET;
 
DCL TYPE CHAR(1);
DCL UTS CHAR(60);
DCL PROCC CHAR(30);
DCL CODE UBIN;
DCL CCODE CHAR(3);
DCL COMPOSITE CHAR(90);
 
        WRITEPATCH.BUF_ = VECTOR(TOUTPUT);
        READPATCH.V.DCB#=DCBNUM(M$IN);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        IF TYPE='R' THEN FID_TEXT='*RUM';
        ELSE FID_TEXT='*PLOV';
 
        CALL M$FID(FPT_FID);
        CALL XSA$OPEN(OPENUP,XSA_PARAM);
 
 
NEXT:   INPUT=' ';
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO DONE;
 
TESTIT: IF ((SUBSTR(INPUT,0,3)='RUM' AND TYPE='R') OR
          (SUBSTR(INPUT,0,6)='PLOVER' AND TYPE='P')) THEN
           CALL BUST$RUM(PROCC,UTS) ALTRET(ERR);
        READPATCH.V.DCB#=DCBNUM(M$PART);
        BOF.V.DCB#=DCBNUM(M$PART);
        CALL XSA$PFIL(BOF,XSA_PARAM);
        CALL CONCAT(COMPOSITE,PROCC,UTS);
        CODE=1;
 
 
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(GOON);
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO DONE;
           IF COMPOSITE=SUBSTR(INPUT,5,90) THEN
              CALL OPEN$TEMP(CODE,'0'B) ALTRET(CHECKIT);
           CODE=CODE+1;
           END;
 
 
GOON:   CODE=CODE+1;
        CALL BINCHAR(CCODE,CODE);
        OUTPUT=' ';
        CALL CONCAT(TOUTPUT,' ',CCODE,' ',PROCC,UTS);
        WRITEPATCH.V.DCB#=DCBNUM(M$PART);
        CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
        WRITEPATCH.V.DCB#=DCBNUM(M$PART);
        CALL OPEN$TEMP(CODE,'1'B);
CHECKIT: IF SUBSTR(INPUT,0,3)='RUM' OR SUBSTR(INPUT,0,6)='PLOVER' THEN GOTO TESTIT;
        ELSE IF SUBSTR(INPUT,0,1)='"' THEN GOTO NEXT;
           ELSE GOTO DONE;
 
 
 
ERR:    ;
 
DONE:;
        WRITEPATCH.BUF_ = VECTOR(OUTPUT);
        ALTRETURN;
 
 
%EJECT;
BUST$RUM: PROC(T1,T2) ALTRET;
/***/
/*
    THIS PROCEDURE DETERMINES WHAT THE PROCESSOR AND THE UTS VALUE IS.
*/
/***/
DCL T1 CHAR(30);
DCL T2 CHAR(60);
DCL POS UBIN;
 
        P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
 
        CALL X$PARSE(P_PCB);
 
        DO CASE(P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE);
 
         CASE(RUM#);
 
           IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS=1 THEN T2='NUTS';
 
           ELSE T2=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
 
         CASE(PLOVER#);
 
           T2=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
 
         END;
 
        T1=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
        POS=0;
 
        DO WHILE(POS<60);
 
           IF SUBSTR(T2,POS,1)='"' THEN DO;
 
              SUBSTR(T2,POS,60-POS)=' ';
              END;
 
           POS=POS+1;
           END;
 
        IF UTSTD~=' ' THEN CALL SUB$UTS(UTSTD,T1,T2,'0'B);
 
 
END BUST$RUM;
 
 
OPEN$TEMP: PROC(R,TEST) ALTRET;
 
DCL K UBIN;
DCL R UBIN;
DCL C CHAR(3);
DCL TEST BIT(1);
 
        READPATCH.V.DCB#=DCBNUM(M$IN);
        CALL BINCHAR(C,R);
 
        FID_TEXT=' ';
        IF TYPE='R' THEN CALL CONCAT(FID_TEXT,'*r');
        ELSE CALL CONCAT(FID_TEXT,'*p');
        IF INPUT=' ' THEN SUBSTR(FID_TEXT,2,3)=C;
        ELSE SUBSTR(FID_TEXT,2,3)=SUBSTR(INPUT,1,3);
 
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
 
        CALL M$FID(FPT_FID);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        OPENEW.V.DCB#=DCBNUM(M$PART);
        IF TEST='1'B THEN CALL XSA$OPEN(OPENEW,XSA_PARAM);
        ELSE CALL XSA$OPEN(OPENUP,XSA_PARAM);
 
        EOF.V.DCB#=DCBNUM(M$PART);
        CALL XSA$PFIL(EOF,XSA_PARAM);
 
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
           IF SUBSTR(INPUT,0,1)='!' OR (SUBSTR(INPUT,0,3)='RUM' AND TYPE='R') OR
             (SUBSTR(INPUT,0,6)='PLOVER'AND TYPE='P') THEN GOTO DONE;
           TOUTPUT=INPUT;
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           END;
 
 
DONE:;
        READPATCH.V.DCB#=DCBNUM(M$PART);
 
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        IF TYPE='R' THEN FID_TEXT='*RUM';
        ELSE FID_TEXT='*PLOV';
        OPENUP.V.DCB#=DCBNUM(M$PART); CALL M$FID(FPT_FID);
        CALL XSA$OPEN(OPENUP,XSA_PARAM);
        ALTRETURN;
END;
END;
%EJECT;
DUMP:   PROC;
 
        READPATCH.V.DCB#=DCBNUM(M$IN);
        INPUT=' ';
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(OOF);
           IF FAST THEN DO;
           IF SUBSTR(INPUT,0,3)='RUM' OR SUBSTR(INPUT,0,6)='PLOVER' THEN DO;
CHECKNEXT:;
           OUTPUT=INPUT;
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(OOF);
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO DUMP10;
           IF SUBSTR(INPUT,0,3)~='RUM' AND SUBSTR(INPUT,0,6)~='PLOVER' THEN
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           ELSE GOTO CHECKNEXT;
           END;
           END;
DUMP10:;
           OUTPUT=INPUT;
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO OOF;
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           END;
 
OOF:    TEST=SUBSTR(INPUT,0,10);
        RETURN;
END;
 
 
%EJECT;
TIGER:  PROC;
 
        CALL XSA$PFIL(BOF,XSA_PARAM);
 
        DO WHILE('1'B);
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(OUT);
           OUTPUT=INPUT;
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           END;
OUT:    READPATCH.V.DCB#=DCBNUM(M$IN);
        INPUT=' ';
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(OOF);
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO OOF;
           END;
OOF:;
        OUTPUT=INPUT;
 
END;
%EJECT;
MXF:    PROC;
 
DCL TEMP CHAR(80);
 
        RLID=0;
        FID_TEXT='*LADC';
        CALL M$FID(FPT_FID);
        OPENEW.V.DCB#=DCBNUM(M$LADC);
        CALL XSA$OPEN(OPENEW,XSA_PARAM);
        READPATCH.V.DCB#=DCBNUM(M$IN);
        DO WHILE('1'B);
 
TOP:       INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
           IF SUBSTR(INPUT,0,1)='!' OR SUBSTR(INPUT,0,3)='RUM' THEN GOTO DONE;
           IF SUBSTR(INPUT,0,1)='!' OR SUBSTR(INPUT,0,6)='PLOVER' THEN GOTO DONE;
           IF TOUTPUT ~= ' ' THEN DO;
           /*WRITE RUM OR PLOVER CARD*/
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           TOUTPUT = ' ';
           END;
           OUTPUT=INPUT;
UP:        CALL FIND$STAR(NEWSTAR) ALTRET(SKIP);
           OLDSTAR=NEWSTAR;
           CALL CHARBIN(STARNUM,NEWSTAR);
 
           IF STARNUM=0 THEN DO;
 
              WRITEPATCH.V.DCB#=DCBNUM(M$LADC);
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
              WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
              GOTO TOP;
 
              END;
           DONTADD=1;
           CALL SORT(STACK,LID,DONTADD,STARNUM);
 
           IF(DONTADD=0) THEN DO;
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
              END;
 
           ELSE DO WHILE('1'B);
              OUTPUT=INPUT;
              CALL FIND$STAR(NEWSTAR) ALTRET(SKIP);
              IF OLDSTAR=NEWSTAR THEN ;
              ELSE GOTO UP;
              INPUT=' ';
              CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
              IF SUBSTR(INPUT,0,1)='!' OR SUBSTR(INPUT,0,3)='RUM' OR
                SUBSTR(INPUT,0,6)='PLOVER' THEN GOTO DONE;
              END;
           DO WHILE('0'B);
 
SKIP:;
 
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
 
 
              END;
           END;
 
DONE:   TEST=SUBSTR(INPUT,0,6);
 
        TEMP=INPUT;
 
        BOF.V.DCB#=DCBNUM(M$PART);
        CALL XSA$PFIL(BOF,XSA_PARAM);
        READPATCH.V.DCB#=DCBNUM(M$PART);
        INPUT=' ';
        DO WHILE(SUBSTR(INPUT,0,1)~='!');
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(QUIT);
           IF TOUTPUT ~= ' ' THEN DO;
           /*WRITE RUM OR PLOVER CARD*/
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           TOUTPUT = ' ';
           END;
           CALL FIND$STAR(NEWSTAR);
           OUTPUT=INPUT;
           IF NEWSTAR~='0' THEN CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           ELSE DO;
 
              WRITEPATCH.V.DCB#=DCBNUM(M$LADC);
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
              WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
 
              END;
           END;
 
QUIT:   BOF.V.DCB#=DCBNUM(M$LADC);
        CALL XSA$PFIL(BOF,XSA_PARAM);
        READPATCH.V.DCB#=DCBNUM(M$LADC);
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(STOPP);
           IF TOUTPUT ~= ' ' THEN DO;
           /*WRITE RUM OR PLOVER CARD*/
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
           TOUTPUT = ' ';
           END;
           OUTPUT=INPUT;
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
 
           END;
 
STOPP:;
        IF TOUTPUT ~= ' ' THEN DO;
        IF FAST THEN;
        ELSE CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
        TOUTPUT = ' ';
        END;
        CALL XSA$CLOSE(CL$LADC,XSA_PARAM);
 
        INPUT=TEMP;
        OUTPUT=TEMP;
        RELEASE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(RELEASE,XSA_PARAM);
        RETURN;
 
 
END;
%EJECT;
 
LOADSTARS: PROC;
 
DCL X UBIN;
        DONTADD=0;
        LID=0;
 
        OLDSTAR=' ';
        DONTADD=0;
        DO WHILE('1'B);
 
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(PFIL);
           CALL FIND$STAR(NEWSTAR);
           CALL CHARBIN(STARNUM,NEWSTAR);
           CALL SORT(STACK,LID,DONTADD,STARNUM);
           DONTADD=0;
 
           END;
 
PFIL:   CALL XSA$PFIL(BOF,XSA_PARAM);
 
END;
%EJECT;
 
XXX:    CALL M$EXIT;
 
SYN:    OUTPUT='eh?';
        CALL M$WRITE(WRITELO);
        GOTO START;
%EJECT;
CHECKFID: PROC(TEST) ALTRET;
 
DCL ACCT BIT(1) UNAL;
DCL ACCT# CHAR(8);
DCL TEST BIT(1) UNAL;
 
        OPEN_SCAN.V.INITZ.SCRUB#='1'B;
        IF SUBSTR(PATCHFID,0,1)='.' THEN VLP_ACCT.ACCT#=SUBSTR(PATCHFID,1,8);
        ELSE FID_TEXT=PATCHFID;
        IF SUBSTR(PATCHFID,0,1)='.' THEN ACCT#=SUBSTR(PATCHFID,1,8);
        IF SUBSTR(PATCHFID,0,1)='.' THEN DO WHILE('1'B);
 
           CALL M$OPEN(OPEN_SCAN) ALTRET(CODE);
           CALL M$UNFID(SCAN$UNFID);
           CALL M$FID(FPT_FID);
           CALL SCANFILE('0'B) ALTRET(NOPART);
           IF TEST='1'B THEN CALL PARTPATCH;
 
NOPART:    OPEN_SCAN.V.INITZ.SCRUB#='0'B;
           IF SUBSTR(PATCHFID,0,1)='.' THEN VLP_ACCT.ACCT#=ACCT#;
 
           END;
 
        CALL M$FID(FPT_FID);
        CALL SCANFILE('0'B) ALTRET(OOPS);
        IF TEST='1'B THEN CALL PARTPATCH;
        RETURN;
CODE:
        ;
OOPS:   ALTRETURN;
END;
 
%EJECT;
 
SCANFILE: PROC(STATUS) ALTRET;
DCL MODE CHAR(4);
DCL JUNK CHAR(10);
DCL STUFF CHAR(60);
DCL ICODE BIT(1) UNAL;
DCL STATUS BIT(1);
DCL X UBIN;
 
        ICODE='0'B;
 
        STUFF=FID_TEXT;
 
 
 
        CALL EXISTS(STUFF,'1'B) ALTRET(ERROR);
        CLOSE.V.DCB#=DCBNUM(M$IN);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM) ALTRET(OK);
OK:     OPENSHARED.V.DCB#=DCBNUM(M$IN);
        CALL XSA$OPEN(OPENSHARED,XSA_PARAM);
        READPATCH.V.DCB#=DCBNUM(M$IN);
        OUTPUT=' ';
        CALL M$WRITE(WRITELO);
        CALL CONCAT(OUTPUT,'file: ',FID_TEXT);
        CALL M$WRITE(WRITELO);
        X=0;                            /* LINE COUNT                         */
 
CBANG:  DO WHILE('1'B);
 
           X=X+1;
           INPUT=' ';
 
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
 
           IF X=1 AND SUBSTR(INPUT,0,1)~='!' THEN GOTO DANG;
 
           IF SUBSTR(INPUT,0,6)='PLOVER' AND MODE='PLOV' THEN DO;
 
              P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
              CALL X$PARSE(P_PCB) ALTRET(SYNX);
 
              IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE~=9 THEN GOTO SYNX;
 
              END;
 
           IF MODE='RUM' AND SUBSTR(INPUT,0,4)='RUM' THEN DO;
 
              P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
              CALL X$PARSE(P_PCB) ALTRET(SYNZ);
 
              END;
 
           IF ECHO='1'B THEN DO;
 
              OUTPUT=INPUT;
              CALL M$WRITE(WRITELO);
 
              END;
 
TRYAGN:    IF SUBSTR(INPUT,0,1)='!' THEN DO;
 
              IF SUBSTR(INPUT,0,5)='!MINI' THEN CALL CH$VERS(STATUS) ALTRET(WRVERS); ELSE IF
                   SUBSTR(INPUT,0,5)='!XDEL' THEN CALL CH$VERS(STATUS) ALTRET(WRVERS); ELSE IF
                      SUBSTR(INPUT,0,5)='!TIGR' THEN CALL CH$VERS(STATUS) ALTRET(WRVERS); ELSE IF
                         SUBSTR(INPUT,0,5)='!RUM' THEN; ELSE IF
                         SUBSTR(INPUT,0,7)='!PLOVER' THEN; ELSE IF
                            SUBSTR(INPUT,0,8)='!BOOTIME' THEN CALL CH$VERS(STATUS) ALTRET(WRVERS); ELSE IF
                               SUBSTR(INPUT,0,5)~='!FIN' THEN GOTO DANG;
              END;
           IF DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#>80 THEN GOTO TOOBIG;
 
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO BANG;
 
           CALL FIND$STAR(JUNK) ALTRET(NOSTAR);
 
           END;
 
DONE:   IF DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#>80 THEN GOTO TOOBIG;
 
        OUTPUT='status: *OK*';
        CALL M$WRITE(WRITELO);
        RETURN;
 
BANG:   MODE=SUBSTR(INPUT,1,4);
 
        IF MODE='XDEL' OR
          MODE='MINI' OR
          MODE='PLOV' OR
          MODE='RUM' OR
          MODE='FIN' THEN GOTO CBANG;
 
        ELSE IF MODE='TIGR' OR MODE='BOOT' THEN DO WHILE('1'B);
 
              INPUT=' ';
              CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
              IF SUBSTR(INPUT,0,1)='!' THEN GOTO BANG;
              END;
 
DANG:;
        IF SUBSTR(INPUT,0,4)=BANGFEP THEN DO ;
 
           WRITELO.V.DVBYTE.VFC#='1'B;
           TOUTPUT=OUTPUT;
           OUTPUT='p +++ Skipping FEP section.      ';
           CALL M$WRITE(WRITELO);
           OUTPUT='A';
           CALL M$WRITE(WRITELO);
           WRITELO.V.DVBYTE.VFC#='0'B;
           OUTPUT=TOUTPUT;
           GOTO SPIN;
           END;
        ELSE
        CALL ERROR(NCMND#);
ERROR:  ALTRETURN;
 
WRVERS: CALL ERROR(VCONFILCT#);
 
        DO WHILE('1'B);                 /* SPIN PAST BAD VERS                 */
SPIN:;
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
 
           IF SUBSTR(INPUT,0,1)='!' THEN GOTO TRYAGN;
 
           END;
 
 
NOSTAR:
 
        IF SUBSTR(INPUT,0,1)='"' THEN GOTO CBANG;
 
        IF MODE='MINI' AND INPUT='U' THEN GOTO CBANG;
 
        IF MODE='RUM' AND SUBSTR(INPUT,0,3)='RUM' THEN GOTO CBANG;
        IF MODE='PLOV' AND SUBSTR(INPUT,0,6)='PLOVER' THEN GOTO CBANG;
        CALL ERROR(NOSTAR#);
        ALTRETURN;
 
 
TOOBIG: CALL ERROR(TOOBIG#);
        ALTRETURN;
 
SYNX:   CALL ERROR(UTSX#);
        ALTRETURN;
SYNZ:   CALL ERROR(RUTS#);
        ALTRETURN;
 
END;
 
CH$VERS: PROC(STATUS) ALTRET;
DCL BLOCK UBIN;
DCL STATUS BIT(1);
 
        P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
 
        CALL VERSION ALTRET(BOMB);
 
        CALL X$PARSE(P_PCB) ALTRET(BOMB);
 
        BLOCK=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE;
 
        DO CASE(BLOCK);
 
         CASE(12);
 
           IF STATUS='1'B THEN DO;
 
              MINIVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->
                OUTSYM.TEXT;
 
              END;
           ELSE IF MINIVERS~=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT THEN ALTRETURN;
         CASE(13);
 
           IF STATUS='1'B THEN DO;
 
              XDELVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->
                OUTSYM.TEXT;
 
              END;
           ELSE IF XDELVERS~=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT THEN ALTRETURN;
         CASE(14);
 
           IF STATUS='1'B THEN DO;
 
              TIGRVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->
                OUTSYM.TEXT;
 
              END;
           ELSE IF TIGRVERS~=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT THEN ALTRETURN;
         CASE(19);
 
           IF STATUS='1'B THEN DO;
 
              BOOTTIMEVERS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->
                OUTSYM.TEXT;
 
              END;
           ELSE IF BOOTTIMEVERS~=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT THEN ALTRETURN;
 
         CASE(ELSE);
 
         END;
        RETURN;
 
BOMB:   ALTRETURN;
END;
%EJECT;
OPENSCRATCH: PROC(JUNK);
 
DCL JUNK CHAR(5);
 
        FID_TEXT=JUNK;
 
        OPENEW.V.DCB#=DCBNUM(M$PART);
        CALL M$FID(FPT_FID);
        CALL XSA$OPEN(OPENEW,XSA_PARAM);
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
 
END;
EXISTS: PROC(STUFF,STAT) ALTRET;
 
DCL STUFF CHAR(60);
DCL NUM UBIN;
DCL STAT BIT(1);
 
        NUM=111;
 
        FID_TEXT=STUFF;
        OPENSHARED.V.DCB#=DCBNUM(M$UTS);
        CALL M$FID(FPT_FID);
        OPENUP.V.ASN#=FID_ASN;
        OPENUP.V.RES#=FID_RES;
        CALL M$OPEN(OPENSHARED) ALTRET(OOPS);
        CLOSE.V.DCB#=DCBNUM(M$UTS);
        CALL M$CLOSE(CLOSE);
 
        IF STAT='0'B THEN GOTO OOPS1;
        RETURN;
 
OOPS:   NUM=B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE;
 
OOPS1:  NUM=NUM-108;
 
        OUTPUT=' ';
        CALL M$WRITE(WRITELO);
 
 
        DO CASE(NUM);
 
         CASE(1);
 
           CALL CONCAT(OUTPUT,'*** file is busy: ',STUFF);
 
         CASE(8);
 
           CALL CONCAT(OUTPUT,'*** access denied: ',STUFF);
 
         CASE(5);
 
           IF STAT='0'B THEN RETURN;
           CALL CONCAT(OUTPUT,'*** file does not exist: ',STUFF);
 
         CASE(3);
 
           CALL CONCAT(OUTPUT,'*** file exists: ',STUFF);
 
         CASE(ELSE);
 
           CALL CONCAT(OUTPUT,'*** fatal error, file: ',STUFF);
           CALL M$WRITE(WRITELO);
           CALL M$XXX;
 
         END;
 
        CALL M$WRITE(WRITELO);
        ALTRETURN;
END;
%EJECT;
FIXUTS: PROC(TX) ALTRET;
 
DCL SAVE CHAR(80);
DCL TX CHAR(1);
DCL RPAREN CHAR(1);
DCL PROCC CHAR(30);
DCL UTS CHAR(60);
DCL X UBIN;
DCL I UBIN;
DCL POS UBIN;
DCL Y UBIN;
 
 
        DO WHILE('1'B);
 
           READPATCH.V.DCB#=DCBNUM(M$IN); /* Read from orig patch file        */
           WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
START:;
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(FINISH);
           TOUTPUT=INPUT;
           IF SUBSTR(INPUT,0,3)='RUM' OR SUBSTR(INPUT,0,6)='PLOVER' THEN DO;
 
           P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
 
           CALL X$PARSE(P_PCB);
 
           DO CASE(P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE);
 
            CASE(RUM#);
 
              IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS=1 THEN UTS='NUTS';
 
              ELSE UTS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
              RPAREN=' ';
 
            CASE(PLOVER#);
 
              UTS=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
              RPAREN=')';
 
            END;
 
           PROCC=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
           POS=0;
 
           DO WHILE(POS<60);
 
              IF SUBSTR(UTS,POS,1)='"' THEN DO;
 
                 SUBSTR(UTS,POS,60-POS)=' ';
                 END;
 
              POS=POS+1;
              END;
 
           IF UTSTD~=' ' THEN CALL SUB$UTS(UTSTD,PROCC,UTS,'0'B);
           I = 0;
           CALL INDEX (I,'  ',UTS,I+2);
           IF I<SIZEC(UTS)-1
                 THEN DO;
                 CALL CONCAT(UTS,SUBSTR(UTS,0,I),RPAREN);
                 END;
           INPUT=TOUTPUT;
           I = 0;
           CALL INDEX (I,'OU=',INPUT,I+3);
           IF I<SIZEC(INPUT)-1
                 THEN DO;
                 I=I+3;
                 CALL CONCAT(OUTPUT,SUBSTR(INPUT,0,I),UTS);
                 END;
                 ELSE DO;
                 I = 0;
                 CALL INDEX (I,'UTS=',INPUT,I+4);
                 IF I<SIZEC(INPUT)-1
                    THEN DO;
                    I=I+4;
                    CALL CONCAT(OUTPUT,SUBSTR(INPUT,0,I),UTS);
                    END;
                    ELSE OUTPUT=INPUT;
                 END;
              READPATCH.V.DCB#=DCBNUM(M$IN);
              WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
              GOTO START;
              END;
           ELSE DO;
              OUTPUT=INPUT;
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
              GOTO START;
              END;
           END;
FINISH:;
        RETURN;
END;
%EJECT;
INIT$RUM: PROC(TX) ALTRET;
 
DCL SAVE CHAR(80);
DCL TX CHAR(1);
DCL PROCC CHAR(30);
DCL UTS CHAR(60);
DCL UTS1 CHAR(60);
DCL X UBIN;
DCL Y UBIN;
DCL I UBIN;
DCL RPAREN CHAR(1) STATIC INIT(')');
 
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        IF TX='R' THEN FID_TEXT='*RUM';
        ELSE FID_TEXT='*PLOV';
        CALL M$FID(FPT_FID);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        CALL XSA$OPEN(OPENUP,XSA_PARAM);
        INPUT=' ';
        READPATCH.V.DCB#=DCBNUM(M$PART);
        CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(NONE);
 
        DO WHILE('1'B);
 
           INPUT=' ';
           READPATCH.V.DCB#=DCBNUM(M$IN); /* Read from orig patch file        */
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(FINISH);
           OUTPUT=INPUT;
START:     IF SUBSTR(INPUT,0,1)='!' THEN GOTO FINISH;
           IF SUBSTR(INPUT,0,3)='RUM' OR SUBSTR(INPUT,0,6)='PLOVER' THEN DO;
 
              P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
              CALL CHECK$RUM ALTRET(SKIP);
 
           TOUTPUT=OUTPUT;
              IF TX='R' THEN CALL CONCAT(FID_TEXT,'*r',SUBSTR(INPUT,1,3));
              ELSE CALL CONCAT(FID_TEXT,'*p',SUBSTR(INPUT,1,3));
              CLOSE.V.DCB#=DCBNUM(M$PART);
              CALL XSA$CLOSE(CLOSE,XSA_PARAM);
              OPENUP.V.DCB#=DCBNUM(M$PART);
              CALL M$FID(FPT_FID);
              CALL XSA$OPEN(OPENUP,XSA_PARAM);
              READPATCH.V.DCB#=DCBNUM(M$PART);
              BOF.V.DCB#=DCBNUM(M$PART);
              CALL LOADSTARS;
              CALL LISTER(STACK,LID,HEADING);
              CALL MXF;
              READPATCH.V.DCB#=DCBNUM(M$IN);
              WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
              GOTO START;
 
              DO WHILE('0'B);
 
SKIP:;
                 IF FAST THEN;
                 ELSE
                 CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
                 GOTO BOTM;
 
                 END;
 
 
              END;
 
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
 
BOTM:      END;
 
 
FINISH: IF INSRTRUM~='1'B AND TX='R' OR INSRTPLO~='1'B AND TX='P'
           THEN GOTO FINIT1;
 
        IF TX='R' THEN FID_TEXT='*RUM';
        ELSE FID_TEXT='*PLOV';
        SAVE=INPUT;
 
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        CALL M$FID(FPT_FID);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        CALL XSA$OPEN(OPENUP,XSA_PARAM) ALTRET(FINIT);
 
        DO WHILE('1'B);
 
           INPUT=' ';
           READPATCH.V.DCB#=DCBNUM(M$PART);
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(FINIT);
 
           PROCC=SUBSTR(INPUT,5,30);
           UTS=SUBSTR(INPUT,35,60);
 
           X=0;
           DO WHILE(X<29);
              IF SUBSTR(PROCC,X,1)=' ' THEN GOTO STAGE1;
              X=X+1;
              END;
STAGE1:    Y=29;
           DO WHILE(Y>0);
              IF SUBSTR(UTS,Y,1)~=' ' THEN GOTO STAGE2;
              Y=Y-1;
              END;
STAGE2:    ;
 
           CLOSE.V.DCB#=DCBNUM(M$UTS);
           CALL XSA$CLOSE(CLOSE,XSA_PARAM);
 
           IF TX='R' THEN CALL CONCAT(FID_TEXT,'*r',SUBSTR(INPUT,1,3));
           ELSE CALL CONCAT(FID_TEXT,'*p',SUBSTR(INPUT,1,3));
 
           CALL M$FID(FPT_FID);
           OPENUP.V.DCB#=DCBNUM(M$UTS);
           CALL XSA$OPEN(OPENUP,XSA_PARAM) ALTRET(SKIPIT);
 
           READPATCH.V.DCB#=DCBNUM(M$UTS);
           BOF.V.DCB#=DCBNUM(M$UTS);
           I=0;
           CALL INDEX(I,'.',UTS,I+1);
           IF I>=SIZEC(UTS)-1 THEN GOTO SKIPIT;
 
           IF TX='R' THEN CALL CONCAT(OUTPUT,'RUM ',SUBSTR(PROCC,0,X),',UTS=',UTS);
           ELSE DO;
           I=0;
           CALL INDEX(I,',',UTS,I+1);
           IF SUBSTR(UTS,I+1,4) = 'UTS='
           THEN
           CALL CONCAT(UTS1,SUBSTR(UTS,0,I+1),SUBSTR(UTS,I+5,SIZEC(UTS)-I-5));
           ELSE
           UTS1=UTS;
           CALL CONCAT(OUTPUT,'PLOVER ',SUBSTR(PROCC,0,X),' (OU=',SUBSTR(UTS,0,I+1),'UTS=',SUBSTR(UTS1,I+1,SIZEC(UTS1)-I-1));
           Y=0;
           CALL INDEX(Y,'.',OUTPUT,Y+1);
           CALL CONCAT(OUTPUT,SUBSTR(OUTPUT,0,Y+3),')');
           END;
 
           CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
 
           IF TX='R' THEN CALL CONCAT(HEADING,'+++ RUM ',SUBSTR(PROCC,0,X),',UTS=',UTS);
           ELSE CALL CONCAT(HEADING,'+++ PLOVER ',SUBSTR(PROCC,0,X),',UTS=',UTS1);
           RLID=0;
           CALL LOADSTARS;
           CALL LISTER(STACK,LID,HEADING);
           DO WHILE('1'B);
 
              INPUT=' ';
              CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(NEXT);
              OUTPUT=INPUT;
              CALL XSA$WRITE(WRITEPATCH,XSA_PARAM);
 
              END;
 
NEXT:      RELEASE.V.DCB#=DCBNUM(M$UTS);
           CALL XSA$CLOSE(RELEASE,XSA_PARAM);
 
SKIPIT:    END;
 
FINIT:  OUTPUT=SAVE;
        INPUT=SAVE;
 
FINIT1: IF WARNING='1'B THEN CALL SKIPPED ALTRET(FINIT2);
FINIT2: RETURN;
 
NONE:   READPATCH.V.DCB#=DCBNUM(M$IN);
        WRITEPATCH.V.DCB#=DCBNUM(M$OUT);
        ALTRETURN;
 
%EJECT;
SKIPPED: PROC ALTRET;
 
DCL TOUT CHAR(90);
DCL TEMP CHAR(90);
DCL TEMP1 CHAR(90);
DCL I UBIN;
DCL OUTLINE BIT(1);
 
        TOUT=INPUT;
        OUTLINE='0'B;
 
        IF TX='R' THEN FID_TEXT='*RUM';
        ELSE FID_TEXT='*PLOV';
 
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        CALL M$FID(FPT_FID);
        OPENUP.V.DCB#=DCBNUM(M$PART);
        CALL XSA$OPEN(OPENUP,XSA_PARAM) ALTRET(DONE);
 
        READPATCH.V.DCB#=DCBNUM(M$PART);
        CLOSE.V.DCB#=DCBNUM(M$UTS);
        OPENUP.V.DCB#=DCBNUM(M$UTS);
 
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(DONE);
 
 
           TEMP=INPUT;
           IF TX='R' THEN CALL CONCAT(FID_TEXT,'*r',SUBSTR(INPUT,1,3));
           ELSE CALL CONCAT(FID_TEXT,'*p',SUBSTR(INPUT,1,3));
           CALL M$FID(FPT_FID);
 
           CALL XSA$OPEN(OPENUP,XSA_PARAM) ALTRET(SKIP);
 
           IF OUTLINE='0'B THEN DO;     /* WRITE HEADER                       */
 
              WRITELO.V.DVBYTE.VFC#='1'B;
              IF TX='R' THEN OUTPUT='p---- Skipped RUMs';
              ELSE OUTPUT='p---- Skipped OUs';
 
              CALL M$WRITE(WRITELO);
              OUTPUT='A';
              CALL M$WRITE(WRITELO);
              CALL M$WRITE(WRITELO);
              OUTPUT='A          Name                         Uts';
              CALL M$WRITE(WRITELO);
              OUTPUT='A';
              CALL M$WRITE(WRITELO);
              WRITELO.V.DVBYTE.VFC#='0'B;
              OUTLINE='1'B;
 
              END;
           I=0;
           CALL INDEX(I,',',TEMP,I+1);
           IF I<SIZEC(TEMP)-1 THEN DO;
              IF SUBSTR(TEMP,I+1,4) = 'UTS='
              THEN
              CALL CONCAT(TEMP1,SUBSTR(TEMP,0,I+1),SUBSTR(TEMP,I+5,SIZEC(TEMP)-I-5));
              ELSE
              TEMP1=TEMP;
              END;
           ELSE TEMP1=TEMP;
           CALL CONCAT(OUTPUT,'     ',SUBSTR(TEMP1,5,85));
           CALL M$WRITE(WRITELO);
           CALL XSA$CLOSE(CLOSE,XSA_PARAM);
SKIP:
           END;
 
DONE:   CLOSE.V.DCB#=DCBNUM(M$PART);
        READPATCH.V.DCB#=DCBNUM(M$IN);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        OUTPUT=TOUT;
        INPUT=TOUT;
        ALTRETURN;
 
END;
%EJECT;
CHECK$RUM: PROC ALTRET;
 
DCL PROCC CHAR(30);
DCL UTS CHAR(60);
DCL UTS1 CHAR(60);
DCL JUNK CHAR(60);
DCL JUNK1 CHAR(60);
DCL I UBIN;
 
        READPATCH.V.DCB#=DCBNUM(M$PART); /* read from *RUM                    */
        CLOSE.V.DCB#=DCBNUM(M$PART);
        CALL XSA$CLOSE(CLOSE,XSA_PARAM);
        IF TX='R' THEN FID_TEXT='*RUM';
        ELSE FID_TEXT='*PLOV';
        CALL M$FID(FPT_FID);
        CALL XSA$OPEN(OPENUP,XSA_PARAM);
        P_PCB.NCHARS=DCBADDR(DCBNUM(M$IN))->F$DCB.ARS#;
        CALL X$PARSE(P_PCB) ALTRET(NONE);
        BOF.V.DCB#=DCBNUM(M$PART);
        CALL XSA$PFIL(BOF,XSA_PARAM);
 
        DO WHILE('1'B);
 
           INPUT=' ';
           CALL XSA$READ(READPATCH,XSA_PARAM) ALTRET(NONE);
           PROCC=SUBSTR(INPUT,5,30);
           UTS=SUBSTR(INPUT,35,60);
           JUNK = P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT;
           UTS1 = UTS;
           JUNK1 = JUNK;
           I=0;
           CALL INDEX(I,',',JUNK,I+1);
           IF I<SIZEC(JUNK)-1 THEN DO;
           CALL CONCAT(JUNK1,SUBSTR(JUNK,0,I+1),SUBSTR(JUNK,I+5,SIZEC(JUNK)-I-5));
           END;
           I=0;
           CALL INDEX(I,',',UTS,I+1);
           IF I<SIZEC(UTS)-1 THEN DO;
           IF SUBSTR(UTS,I+1,4) = 'UTS='
           THEN
           CALL CONCAT(UTS1,SUBSTR(UTS,0,I+1),SUBSTR(UTS,I+5,SIZEC(UTS)-I-5));
           END;
           IF TX='R' THEN CALL CONCAT(HEADING,'*** RUM ',P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT,',UTS=',
                P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
           ELSE CALL CONCAT(HEADING,'*** PLOVER ',P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT,',UTS=',
                UTS1);
 
           IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT=PROCC
 
             AND
 
           JUNK1=UTS1
 
           THEN RETURN;
 
           END;
 
NONE:   ALTRETURN;
 
END;
 
END;
END;
