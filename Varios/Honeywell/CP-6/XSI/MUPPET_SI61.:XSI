/*M* MUPPET - program to start, stop, and control fprgs */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MUPPET: PROC MAIN;
 
      DCL RESTART_POINT                EXTROOT   REMEMBER;
 
      DCL ME_BUFFER                    CHAR(80)  STATIC;
      DCL LO_BUFFER                    CHAR(80)  STATIC;
      DCL DO_BUFFER                    CHAR(80)  STATIC;
 
      DCL M$ME                         DCB;
      DCL M$LO                         DCB;
      DCL M$DO                         DCB;
      DCL M$JUNK                       DCB;
 
      DCL M$PP_DCB                     DCB;
 
      DCL VERSION                      CHAR(3)   STATIC   INIT('A07');
 
      DCL PROMPT                       CHAR(31)  STATIC   INIT('=');
      DCL PROMPT_                      VECTOR    STATIC;
 
      DCL B$JIT$                       PTR       SYMREF;
      DCL B$TCB$                       PTR       SYMREF;
 
      DCL MUPPET_CMD                   BIT(36)   SYMREF;
 
%EJECT;
      DCL SLOT_UBIN                    UBIN;
      DCL SLOT_CHAR                    CHAR(2);
 
      DCL 1 ERROR_BUFFER               STATIC,
            2 *                        CHAR(4)   INIT('ERR:'),
            2 ERR                      BIT(36);
 
      DCL TIME_STAMP                   UBIN      STATIC;
 
      DCL BLK$                         PTR       STATIC;
      DCL 1 PARSE_ERRCODE              REDEF BLK$,
            2 *                        BIT(19)   UNAL,
            2 ERR#                     UBIN(14)  UNAL,
            2 *                        BIT(3)    UNAL;
 
      DCL MUPPET_BLANK_ZERO            ENTRY(2);
      DCL MUPPET_ERROR                 ENTRY(1);
      DCL MUPPET_BREAK_ABORT           ENTRY;
      DCL MUPPET_EVENT                 ENTRY     ASYNC;
      DCL MUPPET_XCON                  ENTRY     ASYNC;
      DCL X$PRE_PROCESS                ENTRY(1)  ALTRET;
 
%EJECT;
      %INCLUDE CP_6;
      %INCLUDE CP_6_SUBS;
      %INCLUDE B_ERRORS_C;
      %INCLUDE B$JIT;
      %INCLUDE XUR_ENTRY;
      %INCLUDE XUF_ENTRY;
      %INCLUDE XU_PERR_C;
      %INCLUDE XU_MACRO_C;
      %INCLUDE XU_FORMAT_C;
      %INCLUDE MUPPET_C61;
 
      %FPRG_INFO (STCLASS="STATIC SYMDEF");
      %LIST_FLAGS (STCLASS="STATIC SYMDEF");
 
      %B$TCB;
      %B$ALT;
      %B$NWIO;
 
      %F$DCB;
 
      %F_FDS(BUF=LO_BUFFER,
             DCB=M$LO);
 
      %PARSE$OUT;
      %PARSE$SYM;
 
%EJECT;
      %XUR_INIT (GOODCMD=YES,
                 SYNTAX=YES,
                 COMMANDS=YES,
                 PREPROCESS=YES,
                 PREPROCESSOR=X$PRE_PROCESS,
                 PP_DCB=M$PP_DCB,
                 PASS=MODE,
                 ABORT=MUPPET_BREAK_ABORT);
 
      %VLP_NAME (FPTN=M$DCB_FPRG,
                 NAME='M$DCB_FPRGxx');
 
      %VLP_NAME (FPTN=M$DCB_IN,
                 NAME='M$DCB_INxx');
 
      %VLP_NAME (FPTN=M$DCB_OUT,
                 NAME='M$DCB_OUTxx');
 
      %VLP_VECTOR;
 
%EJECT;
/*
**
**    FPTs for fprgs.
*/
      %VLP_FPRG;
 
      %VLP_NAME (FPTN=HANDLER_NAME,
                 NAME='           ');
 
      %FPT_FID (FPTN=FPRG_FID,
                NAME=VLP_FPRG.NAME,
                ACCT=VLP_FPRG.ACCT#,
                PASS=VLP_FPRG.PASS#,
/* Fix this!!!  SN=VLP_FPRG.PSN#,*/
                RES=JUNK_OPEN.V.RES#,
                ASN=JUNK_OPEN.V.ASN#);
 
      %FPT_OPEN (FPTN=JUNK_OPEN,
                 SETDCB=YES,
                 NAME=VLP_FPRG.NAME,
                 ACCT=VLP_FPRG.ACCT#,
                 PASS=VLP_FPRG.PASS#,
/* Fix this!!!   SN=VLP_FPRG.PSN#,*/
                 DCB=M$JUNK);
 
      %FPT_UNFID (FPTN=JUNK_UNFID,
                  DCB=M$JUNK);
 
      %FPT_SETFP (FPTN=FPRG_SETFP,
                  FPRG=VLP_FPRG);
 
      %FPT_OPEN (FPTN=FPRG_OPEN,
                 NAME=HANDLER_NAME,
                 FPRG=VLP_FPRG,
                 FUN=CREATE);
 
      %FPT_READ (FPTN=FPRG_READ,
                 WAIT=NO);
 
      %FPT_WRITE (FPTN=FPRG_WRITE,
                  WAIT=NO);
 
%EJECT;
/*
**
**    Misc FPTs.
*/
      %FPT_WRITE (FPTN=ME_WRITE,
                  BUF=ME_BUFFER,
                  DCB=M$ME);
 
      %FPT_WRITE (FPTN=LO_WRITE,
                  BUF=LO_BUFFER,
                  DCB=M$LO);
 
      %FPT_WRITE (FPTN=DO_WRITE,
                  BUF=DO_BUFFER,
                  DCB=M$DO);
 
      %FPT_GDP (PAGES=1,
                RESULTS=VLP_VECTOR);
 
      %FPT_TIME (FPTN=LOAD_TIME_STAMP,
                 TSTAMP=TIME_STAMP);
 
      %FPT_XCON (FPTN=SET_XCON,
                 UENTRY=MUPPET_XCON);
 
      %FPT_XCON (FPTN=RESET_XCON);
 
      %FPT_INT (UENTRY=XUR$BREAK);
 
      %FPT_EVENT (UENTRY=MUPPET_EVENT);
 
%EJECT;
/*
**
**    FPTs for the files that fprgs read/write.
*/
      %VLP_NAME (FPTN=FILE_NAME);
      %VLP_ACCT (FPTN=FILE_ACCT);
      %VLP_PASS (FPTN=FILE_PASS);
      %VLP_WSN (FPTN=FILE_WSN);
      %VLP_SN (FPTN=FILE_SN);
 
      %FPT_FID (FPTN=FILE_FID,
                NAME=FILE_NAME,
                ACCT=FILE_ACCT,
                PASS=FILE_PASS,
                WSN=FILE_WSN,
                SN=FILE_SN,
                RES=FILE_OPEN.V.RES#,
                ASN=FILE_OPEN.V.ASN#);
 
      %FPT_OPEN (FPTN=FILE_OPEN,
                 NAME=FILE_NAME,
                 ACCT=FILE_ACCT,
                 PASS=FILE_PASS,
                 WSN=FILE_WSN,
                 SN=FILE_SN,
                 CTG=YES,
                 EXIST=NEWFILE);
 
      %FPT_READ (FPTN=FILE_READ);
 
      %FPT_WRITE (FPTN=FILE_WRITE);
 
      %FPT_CLOSE (FPTN=FILE_CLOSE,
                  DISP=SAVE);
 
%EJECT;
/*
**
**    Initialize stuff.
*/
      CALL INITIALIZE;
      REMEMBER RESTART IN RESTART_POINT;
 
      CALL XUR$GETCMD (MUPPET_CMD, BLK$, PROMPT_) ALTRET (XUR_ALT);
/*
**
**    Now start the loop to determine what to do.
*/
      DO WHILE (BLK$->OUT$BLK.CODE ~= %END_CMD#);
         DO CASE (BLK$->OUT$BLK.CODE);
            CASE (%OPEN_CMD#);
               CALL DO_OPEN;
            CASE (%CLOSE_CMD#);
               CALL DO_CLOSE;
            CASE (%READ_CMD#);
               CALL DO_READ;
            CASE (%WRITE_CMD#);
               CALL DO_WRITE;
            CASE (%SETFP_CMD#);
               CALL MUPPET_ERROR (%XE$NOT_YET#);
            CASE (%LIST_CMD#);
               CALL DO_LIST;
            CASE (%WAIT_CMD#);
               CALL DO_WAIT;
            CASE (%PROMPT_CMD#);
               PROMPT = BLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
               PROMPT_ = VECTOR(SUBSTR(PROMPT,0,
                                       BLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
            CASE (ELSE);
               CALL MUPPET_ERROR (%XE$NOT_HERE#);
            END;
 
%EJECT;
RESTART: CALL XUR$GETCMD (MUPPET_CMD, BLK$, PROMPT_)
            WHENALTRETURN DO;
XUR_ALT:       CALL XUR$ERRMSG (PARSE_ERRCODE);
               IF PARSE_ERRCODE.ERR# = %E$EOF THEN GOTO ZAP;
               UNWIND TO RESTART_POINT;
               END;
         END;
/*
**
**    Zap all fprgs whilst closing any other dcbs.
*/
ZAP:  CALL XUR$CLOSE_DCBS;
/*
**
**    Get rid of exit control, then exit.
*/
      CALL M$XCON (RESET_XCON);
      CALL M$EXIT;
 
%EJECT;
INITIALIZE: PROC;
/*
**
**    This procedure does initializations that need to be done.
**
*/
/*
**
**    Init exit/break/event control.
*/
      CALL M$XCON (SET_XCON);
      CALL M$INT (FPT_INT);
      CALL M$EVENT (FPT_EVENT);
/*
**
**    Init XUR routines.
*/
      CALL XUR$INIT (XUR_INIT);
/*
**
**    Identify program to user.
*/
      CALL CONCAT (ME_BUFFER, 'MUPPET ', VERSION, ' here');
      CALL M$WRITE (ME_WRITE);
/*
**
**    Initialize the prompt.
*/
      PROMPT_ = VECTOR(SUBSTR(PROMPT,0,1));
 
END INITIALIZE;
%EJECT;
DO_OPEN: PROC;
/*
**
**    This procedure controls the starting of fprgs.
**
*/
      DCL I                            SBIN;
      DCL J                            SBIN;
 
      DCL P$                           PTR;
 
      DCL DCB#                         UBIN;
      DCL IGNORE#                      BIT(1)    ALIGNED;
      DCL CONT#                        BIT(1)    ALIGNED;
      DCL FEP_DEFAULTED#               BIT(1)    ALIGNED;
 
      DCL FEP$                         PTR;
      DCL FEP_UBIN                     UBIN;
      DCL FEP_CHAR                     CHAR(2);
 
      DCL INFILE_                      VECTOR;
      DCL OUTFILE_                     VECTOR;
      DCL TYPE_                        VECTOR;
 
      DCL HANDLER_CONSTANT             CHAR(0)   CONSTANT INIT('Handler');
      DCL FPRG_CONSTANT                CHAR(0)   CONSTANT INIT('Fprg');
 
      DCL START_FMT                    CHAR(0)   CONSTANT INIT
          ('%A in slot %D started');
 
%EJECT;
/*
**
**    Set up defaults.
*/
      IF B$JIT.MODE = %M_INT# THEN
         FEP_UBIN = B$JIT.TSLINE.FEX;
      ELSE
         FEP_UBIN = 0;
      CALL BINCHAR (FEP_CHAR, FEP_UBIN);
 
      FPRG_OPEN.V.RES# = 'FE  ';
      FPRG_OPEN.V.ORG# = %FPRG#;
      FPRG_OPEN.V.EVENT# = 0;
      IGNORE# = '0'B;
      CONT# = '0'B;
      FEP_DEFAULTED# = '1'B;
      HANDLER_NAME.NAME# = B$JIT.UNAME;
      TYPE_ = VECTOR(FPRG_CONSTANT);
 
      INFILE_ = VECTOR(NIL);
      OUTFILE_ = VECTOR(NIL);
/*
**
**    Set up default for slot.
*/
FIND_A_SLOT:
      DO;
         DO I = 1 TO %(NUMSLOTS#-1);
            IF ~FPRG_INFO.FULL_FLAG(I) THEN EXIT FIND_A_SLOT;
            END;
         CALL MUPPET_ERROR (%XE$NO_SLOTS#);
         RETURN;
         END;
      SLOT_UBIN = I;
      CALL BINCHAR (SLOT_CHAR, SLOT_UBIN);
 
%EJECT;
/*
**
**    Now find which options were specified.
*/
      IF BLK$->OUT$BLK.NSUBLKS ~= 1 THEN
         DO;
            DO I = 0 TO BLK$->OUT$BLK.SUBLK$(1)->OUT$BLK.NSUBLKS - 1;
               P$ = BLK$->OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(I);
               DO CASE (P$->OUT$BLK.CODE);
                  CASE (%READ_OPT#);
                     INFILE_ = VECTOR(SUBSTR(P$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,0,
                                             P$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
                  CASE (%WRITE_OPT#);
                     OUTFILE_ = VECTOR(SUBSTR(P$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,0,
                                              P$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
                  CASE (%MODE_OPT#);
                     DO CASE (P$->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE);
                        CASE (%MUPPET_GHOST#);
                           FPRG_OPEN.V.RES# = 'FE00';
                           FPRG_OPEN.V.ORG# = %FPRG#;
                        CASE (%MUPPET_USER#);
                           FPRG_OPEN.V.RES# = 'UC00';
                           FPRG_OPEN.V.ORG# = %FPRG#;
                        CASE (%MUPPET_HANDLER#);
                           IGNORE# = '1'B;
                           FPRG_OPEN.V.RES# = 'FE00';
                           FPRG_OPEN.V.ORG# = %HANDLER#;
                        CASE (%MUPPET_COMGROUP#);
                           CALL MUPPET_ERROR (%XE$NOCG#);
                           RETURN;
                        CASE (ELSE);
                           CALL MUPPET_ERROR (%XE$NOT_HERE#);
                           RETURN;
                        END;
                  CASE (%FEP_OPT#);
                     CALL CHARBIN (FEP_UBIN, SUBSTR(P$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,0,
                                                    P$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
                     CALL BINCHAR (FEP_CHAR, FEP_UBIN);
                     FEP_DEFAULTED# = '0'B;
                  CASE (%SLOT_OPT#);
                     CALL CHARBIN (SLOT_UBIN, SUBSTR(P$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,0,
                                                     P$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
                     CALL BINCHAR (SLOT_CHAR, SLOT_UBIN);
                     IF FPRG_INFO.FULL_FLAG(SLOT_UBIN) THEN
                        DO;
                           CALL MUPPET_ERROR (%XE$SLOT_FULL#);
                           RETURN;
                           END;
                  CASE (%IGNORE_OPT#);
                     IGNORE# = '1'B;
                  CASE (%CONT_OPT#);
                     CONT# = '1'B;
                  CASE (ELSE);
                     CALL MUPPET_ERROR (%XE$NOT_HERE#);
                  END;
               END;
            END;
 
%EJECT;
/*
**
**    Check against user-mode in another fep or non-timesharing.
*/
      IF (FEP_UBIN ~= B$JIT.TSLINE.FEX OR B$JIT.MODE ~= %M_INT#) AND
         SUBSTR(FPRG_OPEN.V.RES#,0,2) = 'UC' THEN
         DO;
            CALL MUPPET_ERROR (%XE$BAD_U_MODE#);
            RETURN;
            END;
/*
**
**    Check for no fep option in non-online.
*/
      IF FEP_DEFAULTED# THEN
         DO;
            CALL MUPPET_ERROR (%XE$NO_FEP_GB#);
            RETURN;
            END;
/*
**
**    Check for no fep option under delta.
*/
      IF FEP_DEFAULTED# AND (B$JIT.JUNK & %JJ_UDELTA#) THEN
         DO;
            CALL MUPPET_ERROR (%XE$NO_FEP_UDLT#);
            RETURN;
            END;
 
%EJECT;
/*
**
**    Put fep number or slot number in FPRG_OPEN.V.RES#.
*/
      IF SUBSTR(FPRG_OPEN.V.RES#,0,2) = 'FE' THEN
         SUBSTR(FPRG_OPEN.V.RES#,2,2) = FEP_CHAR;
      ELSE
         SUBSTR(FPRG_OPEN.V.RES#,2,2) = SLOT_CHAR;
/*
**
**    Now we need a dcb.
*/
      SUBSTR(M$DCB_FPRG.NAME#,10,2) = SLOT_CHAR;
      CALL XUR$GETDCB (M$DCB_FPRG, DCB#);
      FPRG_OPEN.V.DCB# = DCB#;
/*
**
**    M$FID into VLP_FPRG and then start the fprg.
*/
      FPRG_FID.TEXTFID_ = VECTOR(SUBSTR(BLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,0,
                                        BLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
      CALL M$FID (FPRG_FID) ALTRET (ERR);
      IF NOT IGNORE# THEN
         FPRG_OPEN.V.EVENT# = %(EV_STOP# * NUMSLOTS#) + SLOT_UBIN;
      CALL M$OPEN (FPRG_OPEN) ALTRET (ERR);
/*
**
**    Load the FPRG_INFO flags.
*/
      FPRG_INFO.RUN_FLAG(SLOT_UBIN) = '1'B;
      FPRG_INFO.FULL_FLAG(SLOT_UBIN) = '1'B;
      FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) = IGNORE#;
      FPRG_INFO.CONT_FLAG(SLOT_UBIN) = CONT#;
 
%EJECT;
/*
**
**    If IGNORE (default for handlers) we're just about done.
*/
      IF IGNORE# THEN
         DO;
            IF INFILE_ ~= VECTOR(NIL) OR OUTFILE_ ~= VECTOR(NIL) THEN
               DO;
                  OUTFILE_ = VECTOR(NIL);
                  INFILE_ = VECTOR(NIL);
                  CALL MUPPET_ERROR (%XE$IO_IGNORE#);
                  END;
            IF FPRG_OPEN.V.ORG# = %HANDLER# THEN
               TYPE_ = VECTOR(HANDLER_CONSTANT);
            IF LIST_FLAGS.START THEN
               CALL X$WRITE (F_FDS, VECTOR(START_FMT), TYPE_, VECTOR(SLOT_UBIN));
            RETURN;
            END;
 
%EJECT;
/*
**
**    Load rest of fprg info.
*/
      FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN) = FPRG_OPEN.V.DCB#;
      CALL M$TIME (LOAD_TIME_STAMP);
      FPRG_INFO.TIME(SLOT_UBIN) = TIME_STAMP;
      FPRG_INFO.FEP(SLOT_UBIN) = FEP_UBIN;
      IF SUBSTR(FPRG_OPEN.V.RES#,0,2) = 'FE' THEN
         FPRG_INFO.MODE(SLOT_UBIN) = 'G';
      ELSE
         FPRG_INFO.MODE(SLOT_UBIN) = 'U';
      FPRG_INFO.RECS.IN#(SLOT_UBIN) = 0;
      FPRG_INFO.RECS.OUT#(SLOT_UBIN) = 0;
      FPRG_INFO.IN_FLAG(SLOT_UBIN) = '0'B;
      FPRG_INFO.OUT_FLAG(SLOT_UBIN) = '0'B;
/*
**
**    Set the fprg info in a dcb, then M$UNFID to store full fprg fid.
*/
      CALL M$OPEN (JUNK_OPEN) ALTRET (ERR);
      JUNK_UNFID.TEXTFID_ = VECTOR(FPRG_INFO.FPRG_FID(SLOT_UBIN));
      CALL M$UNFID (JUNK_UNFID) ALTRET (ERR);
      IF LIST_FLAGS.START THEN
         CALL X$WRITE (F_FDS, VECTOR(START_FMT), TYPE_, VECTOR(SLOT_UBIN));
 
%EJECT;
/*
**
**    Get a dcb and buffer for input file if we need them.
*/
      IF FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN) = 0 AND INFILE_ ~= VECTOR(NIL) THEN
         DO;
            SUBSTR(M$DCB_IN.NAME#,8,2) = SLOT_CHAR;
            CALL XUR$GETDCB (M$DCB_IN, DCB#);
            FILE_OPEN.V.DCB# = DCB#;
            FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN) = DCB#;
            CALL M$GDP (FPT_GDP) ALTRET (ERR);
            FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN) = VLP_VECTOR.PTR$;
            END;
/*
**
**    Open the input file if we need it.
*/
      IF INFILE_ ~= VECTOR(NIL) THEN
         DO;
            FILE_FID.TEXTFID_ = INFILE_;
            CALL M$FID (FILE_FID) ALTRET (ERR);
            FILE_OPEN.V.FUN# = %IN#;
            CALL M$OPEN (FILE_OPEN) ALTRET (ERR);
            FPRG_INFO.IN_FLAG(SLOT_UBIN) = '1'B;
/*
**
**          Read first record from input file and
**          hang a no-wait write on the fprg.
*/
            FILE_READ.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN);
            FILE_READ.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN);
            FILE_READ.BUF_.BOUND = 1023;
            CALL M$READ (FILE_READ)
               WHENALTRETURN DO;
                  FILE_READ.BUF_ = VECTOR(ERROR_BUFFER);
                  END;
 
            FPRG_WRITE.V.EVENT# = %(EV_WRITE# * NUMSLOTS#) + SLOT_UBIN;
            FPRG_WRITE.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
            FPRG_WRITE.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN);
            FPRG_WRITE.BUF_.BOUND =
               DCBADDR(FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN))->F$DCB.ARS# - 1;
            CALL M$WRITE (FPRG_WRITE)
               WHENALTRETURN DO;
                  IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOFPRG THEN
                     CALL ALTRET_ERROR;
                  RETURN;
                  END;
            END;
 
%EJECT;
/*
**
**    Get a dcb and buffer for output file if we need them.
*/
      IF FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN) = 0 AND OUTFILE_ ~= VECTOR(NIL) THEN
         DO;
            SUBSTR(M$DCB_OUT.NAME#,9,2) = SLOT_CHAR;
            CALL XUR$GETDCB (M$DCB_OUT, DCB#);
            FILE_OPEN.V.DCB# = DCB#;
            FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN) = DCB#;
            CALL M$GDP (FPT_GDP) ALTRET (ERR);
            FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN) = VLP_VECTOR.PTR$;
            END;
/*
**
**    Open the output file if we need it.
*/
      IF OUTFILE_ ~= VECTOR(NIL) THEN
         DO;
            FILE_FID.TEXTFID_ = OUTFILE_;
            CALL M$FID (FILE_FID) ALTRET (ERR);
            FILE_OPEN.V.FUN# = %CREATE#;
            CALL M$OPEN (FILE_OPEN) ALTRET (ERR);
            FPRG_INFO.OUT_FLAG(SLOT_UBIN) = '1'B;
/*
**
**          Hang a no-wait read on the fprg.
*/
            FPRG_READ.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN);
            FPRG_READ.BUF_.BOUND = 1023;
            FPRG_READ.V.EVENT# = %(EV_READ# * NUMSLOTS#) + SLOT_UBIN;
            FPRG_READ.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
            CALL M$READ (FPRG_READ)
               WHENALTRETURN DO;
                  IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOFPRG THEN
                     CALL ALTRET_ERROR;
                  RETURN;
                  END;
            END;
 
%EJECT;
/*
**
**    That's it!
*/
      RETURN;
/*
**
**    Altret errors.
*/
ERR:  CALL ALTRET_ERROR;
      RETURN;
 
END DO_OPEN;
%EJECT;
DO_CLOSE: PROC;
/*
**
**    This procedure controls the stopping of fprgs.
**
*/
      DCL STOP_FMT                     CHAR(0)   CONSTANT INIT
          ('Fprg in slot %D stopped');
 
      %FPT_CLOSE (FPTN=FPRG_CLOSE);
/*
**
**    Get slot from parse tree.
*/
      CALL GET_SLOT;
/*
**
**    Check to see if IGNORE was specified.
*/
      IF FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) THEN
         DO;
            CALL MUPPET_ERROR (%XE$CLOSE_IGNORE#);
            RETURN;
            END;
/*
**
**    Check to make sure there is an fprg there, then close it.
*/
      DO INHIBIT;
         IF ~FPRG_INFO.FULL_FLAG(SLOT_UBIN) THEN
            DO;
               CALL MUPPET_ERROR (%XE$SLOT_EMPTY#);
               RETURN;
               END;
 
         FPRG_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
         CALL M$CLOSE (FPRG_CLOSE);
         END;
 
      IF LIST_FLAGS.STOP AND FPRG_INFO.RUN_FLAG(SLOT_UBIN) THEN
         CALL X$WRITE (F_FDS, VECTOR(STOP_FMT), VECTOR(SLOT_UBIN));
 
%EJECT;
/*
**
**    Zero out the slot so we can use it again.
*/
      FPRG_INFO.RUN_FLAG(SLOT_UBIN) = '0'B;
      FPRG_INFO.FULL_FLAG(SLOT_UBIN) = '0'B;
/*
**
**    Close any files that the fprg might have been using.
*/
      FILE_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN);
      CALL M$CLOSE (FILE_CLOSE) WHENALTRETURN DO; END;
      FILE_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN);
      CALL M$CLOSE (FILE_CLOSE) WHENALTRETURN DO; END;
 
END DO_CLOSE;
%EJECT;
DO_READ: PROC;
/*
**
**    This procedure sets the up reading of files by fprgs.
**
*/
      DCL FID$                         PTR;
 
      DCL DCB#                         UBIN;
/*
**
**    Get slot from parse tree, and check for fprg.
*/
      CALL GET_SLOT;
      IF ~FPRG_INFO.FULL_FLAG(SLOT_UBIN) THEN
         DO;
            CALL MUPPET_ERROR (%XE$SLOT_EMPTY#);
            RETURN;
            END;
/*
**
**    Make sure I/O is legal.
*/
      IF FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) THEN
         DO;
            CALL MUPPET_ERROR (%XE$IO_IGNORE#);
            RETURN;
            END;
/*
**
**    Now, get ready and do the M$FID.
*/
      FID$ = BLK$->OUT$BLK.SUBLK$(1);
      FILE_FID.TEXTFID_ = VECTOR(SUBSTR(FID$->OUT$SYM.TEXT,0,
                                        FID$->OUT$SYM.COUNT));
 
      CALL M$FID (FILE_FID)
         WHENALTRETURN DO;
            CALL ALTRET_ERROR;
            RETURN;
            END;
 
%EJECT;
/*
**
**    Get a dcb and a buffer, if we need them.
*/
      IF FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN) = 0 THEN
         DO;
            SUBSTR(M$DCB_IN.NAME#,8,2) = SLOT_CHAR;
            CALL XUR$GETDCB (M$DCB_IN, DCB#);
            FILE_OPEN.V.DCB# = DCB#;
            FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN) = DCB#;
 
            CALL M$GDP (FPT_GDP)
               WHENALTRETURN DO;
                  CALL ALTRET_ERROR;
                  RETURN;
                  END;
            FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN) = VLP_VECTOR.PTR$;
            END;
/*
**
**    Close any input file currently open by fprg.
*/
      IF FPRG_INFO.IN_FLAG(SLOT_UBIN) THEN
         DO;
            FILE_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN);
            CALL M$CLOSE (FILE_CLOSE) WHENALTRETURN DO; END;
            END;
 
%EJECT;
/*
**
**    Open the infile.
*/
      FILE_OPEN.V.FUN# = %IN#;
      CALL M$OPEN (FILE_OPEN)
         WHENALTRETURN DO;
            CALL ALTRET_ERROR;
            RETURN;
            END;
/*
**
**    Read first record from input file and,
**    hang a no-wait write on the fprg.
*/
      IF ~FPRG_INFO.IN_FLAG(SLOT_UBIN) THEN
         DO;
            FILE_READ.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN);
            FILE_READ.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN);
            FILE_READ.BUF_.BOUND = 1023;
            CALL M$READ (FILE_READ)
               WHENALTRETURN DO;
                  FILE_READ.BUF_ = VECTOR(ERROR_BUFFER);
                  END;
 
            FPRG_INFO.IN_FLAG(SLOT_UBIN) = '1'B;
            FPRG_WRITE.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN);
            FPRG_WRITE.BUF_.BOUND =
               DCBADDR(FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN))->F$DCB.ARS# - 1;
            FPRG_WRITE.V.EVENT# = %(EV_WRITE# * NUMSLOTS#) + SLOT_UBIN;
            FPRG_WRITE.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
            CALL M$WRITE (FPRG_WRITE)
               WHENALTRETURN DO;
                  IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOFPRG THEN
                     CALL M$MERC;
                  RETURN;
                  END;
            END;
 
 
END DO_READ;
%EJECT;
DO_WRITE: PROC;
/*
**
**    This procedure sets up the writing of files by fprgs.
**
*/
      DCL FID$                         PTR;
      DCL HOW_TO$                      PTR;
 
      DCL DCB#                         UBIN;
/*
**
**    Get slot from parse tree, and check for fprg.
*/
      CALL GET_SLOT;
      IF ~FPRG_INFO.FULL_FLAG(SLOT_UBIN) THEN
         DO;
            CALL MUPPET_ERROR (%XE$SLOT_EMPTY#);
            RETURN;
            END;
/*
**
**    Make sure I/O is legal.
*/
      IF FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) THEN
         DO;
            CALL MUPPET_ERROR (%XE$IO_IGNORE#);
            RETURN;
            END;
/*
**
**    Now, get ready and do the M$FID.
*/
      FID$ = BLK$->OUT$BLK.SUBLK$(2);
      FILE_FID.TEXTFID_ = VECTOR(SUBSTR(FID$->OUT$SYM.TEXT,0,
                                        FID$->OUT$SYM.COUNT));
 
      CALL M$FID (FILE_FID)
         WHENALTRETURN DO;
            CALL ALTRET_ERROR;
            RETURN;
            END;
 
%EJECT;
/*
**
**    Fix up the exist flag.
*/
      HOW_TO$ = BLK$->OUT$BLK.SUBLK$(1);
      IF HOW_TO$->OUT$BLK.CODE = %OVER# THEN
         FILE_OPEN.V.EXIST# = %NEWFILE#;
      ELSE
      IF HOW_TO$->OUT$BLK.CODE = %INTO# THEN
         FILE_OPEN.V.EXIST# = %OLDFILE#;
      ELSE
         FILE_OPEN.V.EXIST# = %ERROR#;
/*
**
**    Get a dcb and a buffer, if we need them.
*/
      IF FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN) = 0 THEN
         DO;
            SUBSTR(M$DCB_OUT.NAME#,9,2) = SLOT_CHAR;
            CALL XUR$GETDCB (M$DCB_OUT, DCB#);
            FILE_OPEN.V.DCB# = DCB#;
            FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN) = DCB#;
 
            CALL M$GDP (FPT_GDP)
               WHENALTRETURN DO;
                  CALL ALTRET_ERROR;
                  RETURN;
                  END;
            FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN) = VLP_VECTOR.PTR$;
            END;
 
%EJECT;
/*
**
**    Close any output file currently open by fprg.
*/
      IF FPRG_INFO.OUT_FLAG(SLOT_UBIN) THEN
         DO;
            FILE_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN);
            CALL M$CLOSE (FILE_CLOSE) WHENALTRETURN DO; END;
            END;
/*
**
**    Open the outfile.
*/
      FILE_OPEN.V.FUN# = %CREATE#;
      CALL M$OPEN (FILE_OPEN)
         WHENALTRETURN DO;
            CALL ALTRET_ERROR;
            RETURN;
            END;
/*
**
**    Hang a no-wait read on the fprg.
*/
      IF ~FPRG_INFO.OUT_FLAG(SLOT_UBIN) THEN
         DO;
            FPRG_INFO.OUT_FLAG(SLOT_UBIN) = '1'B;
            FPRG_READ.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN);
            FPRG_READ.BUF_.BOUND = 1023;
            FPRG_READ.V.EVENT# = %(EV_READ# * NUMSLOTS#) + SLOT_UBIN;
            FPRG_READ.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
            CALL M$READ (FPRG_READ)
               WHENALTRETURN DO;
                  IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOFPRG THEN
                     CALL M$MERC;
                  RETURN;
                  END;
            END;
 
END DO_WRITE;
%EJECT;
DO_SETFP: PROC;
/*
**
**    This procedure does the SETFP command.
**
*/
      DCL FID$                         PTR;
/*
**
**    Get slot from parse tree, and check to make sure CONT# was set.
*/
      CALL GET_SLOT;
      IF ~FPRG_INFO.CONT_FLAG(SLOT_UBIN) THEN
         DO;
            CALL MUPPET_ERROR (%XE$NO_CONT#);
            RETURN;
            END;
/*
**
**    M$FID into VLP_FPRG.
*/
      FID$ = BLK$->OUT$BLK.SUBLK$(1);
      FPRG_FID.TEXTFID_ = VECTOR(SUBSTR(FID$->OUT$SYM.TEXT,0,
                                        FID$->OUT$SYM.COUNT));
      CALL M$FID (FPRG_FID) ALTRET (ERR);
/*
**
**    Now M$SETFP the fprg.
*/
      FPRG_SETFP.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
      CALL M$SETFP (FPRG_SETFP) ALTRET (ERR);
      RETURN;
/*
**
**    Altret errors.
*/
ERR:  CALL ALTRET_ERROR;
      RETURN;
 
END DO_SETFP;
%EJECT;
DO_LIST: PROC;
/*
**
**    This procedure lists information about the fprgs.
*/
      DCL CLOCK_TIME                   UBIN;
 
      DCL IN_FID                       CHAR(50);
      DCL IN_FLAG                      SBIN;
 
      DCL OUT_FID                      CHAR(50);
      DCL OUT_FLAG                     SBIN;
 
      DCL LIST_FMT                     CHAR(80)  STATIC INIT
          ('  %2*D  %2*D%1*A  %..0.4U  %16LA%S %3*D%NE %16LA%S  %3*D%NE %16LA%S');
 
      DCL FIRST_TIME                   BIT(1)    ALIGNED;
 
      %FPT_UNFID;
/*
**
**    Setup.
*/
      CALL M$TIME (LOAD_TIME_STAMP);
      FIRST_TIME = '1'B;
      F_FDS.EDIT# = ENTADDR(MUPPET_BLANK_ZERO);
 
%EJECT;
/*
**
**    If we do all slots.
*/
      IF BLK$->OUT$BLK.NSUBLKS = 0 THEN
         DO;
            DO SLOT_UBIN = 1 TO %(NUMSLOTS#-1);
               IF FPRG_INFO.RUN_FLAG(SLOT_UBIN) AND
                  ~FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) THEN
                  CALL LIST_ONE (SLOT_UBIN, FIRST_TIME);
               END;
            IF FIRST_TIME THEN CALL MUPPET_ERROR (%XE$NO_FPRGS#);
            END;
      ELSE
         DO;
            CALL GET_SLOT;
            IF ~FPRG_INFO.RUN_FLAG(SLOT_UBIN) OR
               FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) THEN
               DO;
                  CALL MUPPET_ERROR (%XE$SLOT_NORUN#);
                  RETURN;
                  END;
            CALL LIST_ONE (SLOT_UBIN, FIRST_TIME);
            END;
/*
**
**    Cleanup.
*/
      F_FDS.EDIT# = ENTADDR(NIL);
      RETURN;
 
%EJECT;
LIST_ONE: PROC (I, FIRST_TIME);
/*
**
**    This procedure lists one fprg.
**
*/
      DCL I                            SBIN;
      DCL FIRST_TIME                   BIT(1)    ALIGNED;
/*
**
**    Print heading, if needed.
*/
      IF FIRST_TIME THEN
         DO;
            LO_BUFFER = ' Slot Fep Clock time Fprg fid         #in Input fid        #out Output fid';
            CALL M$WRITE (LO_WRITE);
            FIRST_TIME = '0'B;
            END;
/*
**
**    Compute clock time.
*/
      CLOCK_TIME = TIME_STAMP - FPRG_INFO.TIME(I);
 
%EJECT;
/*
**
**    Do input file.
*/
      IF FPRG_INFO.IN_FLAG(I) THEN
         DO;
            IN_FLAG = 1;
            FPT_UNFID.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(I);
            FPT_UNFID.TEXTFID_ = VECTOR(IN_FID);
            CALL M$UNFID (FPT_UNFID);
            END;
      ELSE
         DO;
            IN_FLAG = 0;
            IN_FID = '- none -';
            END;
/*
**
**    Do output file.
*/
      IF FPRG_INFO.OUT_FLAG(I) THEN
         DO;
            OUT_FLAG = 1;
            FPT_UNFID.V.DCB# = FPRG_INFO.DCB_NUMS.OUT#(I);
            FPT_UNFID.TEXTFID_ = VECTOR(OUT_FID);
            CALL M$UNFID (FPT_UNFID);
            END;
      ELSE
         DO;
            OUT_FLAG = 0;
            OUT_FID = '- none -';
            END;
 
%EJECT;
/*
**
**    Now we can write.
*/
      CALL X$WRITE (F_FDS, VECTOR(LIST_FMT), VECTOR(I),
                                        VECTOR(FPRG_INFO.FEP(I)),
                                        VECTOR(FPRG_INFO.MODE(I)),
                                        VECTOR(CLOCK_TIME),
                                        VECTOR(FPRG_INFO.FPRG_FID(I)),
                                        VECTOR(FPRG_INFO.RECS.IN#(I)),
                                        VECTOR(IN_FLAG),
                                        VECTOR(IN_FID),
                                        VECTOR(FPRG_INFO.RECS.OUT#(I)),
                                        VECTOR(OUT_FLAG),
                                        VECTOR(OUT_FID));
 
END LIST_ONE;
 
END DO_LIST;
%EJECT;
DO_WAIT: PROC;
/*
**
**    This procedure takes care of the WAIT command.
**
*/
      DCL ONE_RUNNING                  BIT(1);
      DCL I                            UBIN;
 
      %FPT_WAIT (UNITS=1);
/*
**
**    Are we going to wait for all of them or just one?
*/
      IF BLK$->OUT$BLK.NSUBLKS = 0 THEN
         DO UNTIL (~ONE_RUNNING);
            CALL M$WAIT (FPT_WAIT);
            ONE_RUNNING = '0'B;
            DO I = 0 TO %(NUMSLOTS#-1);
               IF FPRG_INFO.RUN_FLAG(I) THEN ONE_RUNNING = '1'B;
               END;
            END;
      ELSE
         DO;
            CALL GET_SLOT;
            IF ~FPRG_INFO.RUN_FLAG(SLOT_UBIN) THEN
               DO;
                  CALL MUPPET_ERROR (%XE$SLOT_NORUN#);
                  RETURN;
                  END;
            DO WHILE (FPRG_INFO.RUN_FLAG(SLOT_UBIN));
               CALL M$WAIT (FPT_WAIT);
               END;
            END;
/*
**
**    Now we can get another command.
*/
      RETURN;
 
END DO_WAIT;
%EJECT;
GET_SLOT: PROC;
/*
**
**    This procedure get the slot from the parse tree.
**
*/
      CALL CHARBIN (SLOT_UBIN, SUBSTR(BLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,0,
                                      BLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT));
      CALL BINCHAR (SLOT_CHAR, SLOT_UBIN);
 
END GET_SLOT;
%EJECT;
ALTRET_ERROR: PROC;
/*
**
**    This procedure prints the error message from the altret frame.
**
*/
      DCL DCB#                         UBIN;
 
      %VLP_ERRCODE;
/*
**
**    Set the error code and dcb.
*/
      DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
      VLP_ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
      VLP_ERRCODE.SEV = 0;
/*
**
**    Print the message.
*/
      CALL XUR$SETERRMSG;
      CALL XUR$ERRMSG (VLP_ERRCODE, DCB#);
 
END ALTRET_ERROR;
 
END MUPPET;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MUPPET_BLANK_ZERO: PROC (F_FDS, CNT);
/*
**
**    This is an edit routine that is called by the formatter
**    to blank out a zero.
**
*/
      DCL CNT(0:3)                     SBIN;
 
      DCL BUFFER                       CHAR(F_FDS.BUFSIZE) BASED(F_FDS.BUF_.BUF$);
 
      %INCLUDE XU_FORMAT_C;
 
      %F_FDS (STCLASS="");
 
      IF CNT(0) = 0 THEN SUBSTR(BUFFER, F_FDS.FIELDX, 3) = '   ';
 
END MUPPET_BLANK_ZERO;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MUPPET_EVENT: PROC ASYNC;
/*
**
**    This procedure takes control when an fprg has completed
**    an outstanding i/o operation.
**
*/
      DCL SLOT_UBIN                    UBIN;
      DCL SLOT_CHAR                    CHAR(2);
 
      DCL FILE_READ_ERROR              BIT(1)    STATIC;
      DCL 1 ERROR_BUFFER               STATIC,
            2 *                        CHAR(4)   INIT('ERR:'),
            2 ERR                      BIT(36);
 
      DCL 1 CHAR8                      BASED,
            2 W0                       CHAR(4),
            2 W1                       CHAR(4);
 
%EJECT;
      DCL B$TCB$                       PTR       SYMREF;
 
      DCL Q_FRONT                      UBIN      EXTROOT INIT(0);
      DCL Q_BACK                       UBIN      EXTROOT INIT(0);
      DCL Q_EVENTS                     BIT(1)    EXTROOT INIT('0'B);
 
      DCL LO_BUFFER                    CHAR(80)  STATIC;
 
      DCL M$LO                         DCB;
 
      DCL PROC_FMT                     CHAR(0)   CONSTANT INIT
          ('Event %D being processed - Error=%J');
 
      DCL Q_FMT                        CHAR(0)   CONSTANT INIT
          ('Event %D being Q''ed - Error=%J');
 
      DCL ERROR_FMT                    CHAR(0)   CONSTANT INIT
          ('Fprg %D returned the following error:');
 
      DCL MUPPET_ERROR                 ENTRY(1);
 
%EJECT;
      %INCLUDE CP_6;
      %INCLUDE CP_6_SUBS;
      %INCLUDE XUR_ENTRY;
      %INCLUDE XUF_ENTRY;
      %INCLUDE B_ERRORS_C;
      %INCLUDE XU_FORMAT_C;
      %INCLUDE MUPPET_C61;
 
      %FPRG_INFO (STCLASS=SYMREF);
      %LIST_FLAGS (STCLASS=SYMREF);
      %EVENT_Q (STCLASS=EXTROOT);
 
      %B$TCB;
      %B$ALT;
      %B$NWIO;
 
      %F$DCB;
 
      %F_FDS (BUF=LO_BUFFER,
              DCB=M$LO);
 
%EJECT;
/*
**
**    Fprg FPTs.
*/
      %FPT_READ (FPTN=FPRG_READ,
                 WAIT=NO);
 
      %FPT_WRITE (FPTN=FPRG_WRITE,
                  WAIT=NO);
/*
**
**    File FPTs.
*/
      %FPT_READ (FPTN=FILE_READ);
 
      %FPT_WRITE (FPTN=FILE_WRITE);
/*
**
**    Misc. FPTs.
*/
      %VLP_ERRCODE;
 
      %FPT_CLOSE;
 
      %FPT_XCON (FPTN=RESET_XCON);
 
%EJECT;
/*
**
**    Q the events.
*/
      DO INHIBIT;
         EVENT_Q.EVENT#(Q_BACK) = B$TCB$->B$TCB.STK$->B$NWIO.EVID;
         EVENT_Q.ERR   (Q_BACK) = B$TCB$->B$TCB.STK$->B$NWIO.ERR;
         EVENT_Q.ARS#  (Q_BACK) = B$TCB$->B$TCB.STK$->B$NWIO.ARS;
         EVENT_Q.DVBYTE(Q_BACK) = B$TCB$->B$TCB.STK$->B$NWIO.DVE.DVBYTE;
         IF LIST_FLAGS.Q_EVENTS THEN /* This is dangerous for INHIBIT! */
            CALL X$WRITE (F_FDS, VECTOR(Q_FMT), VECTOR(EVENT_Q.EVENT#(Q_BACK)),
                                                VECTOR(EVENT_Q.ERR(Q_BACK)));
         Q_BACK = MOD(Q_BACK+1,%NUMQS#);
         IF Q_EVENTS THEN RETURN;
         Q_EVENTS = '1'B;
         END;
/*
**
**    Now process the event queue.
*/
      DO FOREVER;
         IF LIST_FLAGS.PROC_EVENTS THEN
            CALL X$WRITE (F_FDS, VECTOR(PROC_FMT), VECTOR(EVENT_Q.EVENT#(Q_FRONT)),
                                                   VECTOR(EVENT_Q.ERR(Q_FRONT)));
/*
**
**       First, find out which slot.
*/
         SLOT_UBIN = MOD(EVENT_Q.EVENT#(Q_FRONT),%NUMSLOTS#);
         CALL BINCHAR (SLOT_CHAR, SLOT_UBIN);
/*
**
**       If IGNORE was on this, we're in trouble.
*/
         IF FPRG_INFO.IGNORE_FLAG(SLOT_UBIN) THEN
            CALL MUPPET_ERROR (%XE$NOT_HERE#);
 
%EJECT;
/*
**
**       Now separate the reads from the writes.
*/
         DO CASE ((EVENT_Q.EVENT#(Q_FRONT))/%NUMSLOTS#);
            CASE (%EV_READ#);
               CALL READ_PROC;
            CASE (%EV_WRITE#);
               CALL WRITE_PROC;
            CASE (%EV_STOP#);
               CALL STOP_PROC;
            CASE (ELSE);
               CALL MUPPET_ERROR (%XE$NOT_HERE#);
            END;
/*
**
**       All done with this one, go to next on queue.
*/
         DO INHIBIT;
            Q_FRONT = MOD(Q_FRONT+1,%NUMQS#);
            IF Q_FRONT = Q_BACK THEN
               DO;
                  Q_EVENTS = '0'B;
                  RETURN;
                  END;
            END;
         END;
 
%EJECT;
READ_PROC: PROC;
/*
**
**    This procedure is used if an outstanding read came back.
**
*/
/*
**
**    If the read altreturned or the slot is empty...
*/
      IF ~FPRG_INFO.FULL_FLAG(SLOT_UBIN) THEN RETURN;
      IF EVENT_Q.ERR.ERR#(Q_FRONT) ~= 0 THEN
         DO;
            IF EVENT_Q.ERR.ERR#(Q_FRONT) ~= %E$NOFPRG THEN
               CALL XUR$ERRMSG (EVENT_Q.ERR(Q_FRONT));
            RETURN;
            END;
/*
**
**    First, update counter & write out buffer to file.
*/
      FPRG_INFO.RECS.OUT#(SLOT_UBIN) = FPRG_INFO.RECS.OUT#(SLOT_UBIN) + 1;
      FILE_WRITE.V.DCB# = FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN);
      FILE_WRITE.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN);
      FILE_WRITE.BUF_.BOUND = EVENT_Q.ARS#(Q_FRONT) - 1;
      FILE_WRITE.V.DVBYTE = EVENT_Q.DVBYTE(Q_FRONT);
      CALL M$WRITE (FILE_WRITE);
/*
**
**    Check if the fprg is trying to tell us something.
*/
      IF FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN)->CHAR8.W0 = 'ERR:' THEN
         DO;
            CALL X$WRITE (F_FDS, VECTOR(ERROR_FMT), VECTOR(SLOT_UBIN));
            CALL XUR$ERRCNVRT (FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN)->CHAR8.W1, VLP_ERRCODE);
            CALL XUR$ERRMSG (VLP_ERRCODE);
            END;
 
%EJECT;
/*
**
**    Now re-issue the read.
*/
      FPRG_READ.V.EVENT# = EVENT_Q.EVENT#(Q_FRONT);
      FPRG_READ.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
      FPRG_READ.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.OUT$(SLOT_UBIN);
      FPRG_READ.BUF_.BOUND = 1023;
      CALL M$READ (FPRG_READ)
         WHENALTRETURN DO;
            IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOFPRG THEN
               CALL M$MERC;
            RETURN;
            END;
 
END READ_PROC;
%EJECT;
WRITE_PROC: PROC;
/*
**
**    This procedure is used if an outstanding write came back.
**
*/
/*
**
**    If the write altreturned or the slot is empty...
*/
      IF ~FPRG_INFO.FULL_FLAG(SLOT_UBIN) THEN RETURN;
      IF EVENT_Q.ERR.ERR#(Q_FRONT) ~= 0 THEN
         DO;
            IF EVENT_Q.ERR.ERR#(Q_FRONT) ~= %E$NOFPRG THEN
               CALL XUR$ERRMSG (EVENT_Q.ERR(Q_FRONT));
            RETURN;
            END;
/*
**
**    Update record counter.
*/
      FPRG_INFO.RECS.IN#(SLOT_UBIN) = FPRG_INFO.RECS.IN#(SLOT_UBIN) + 1;
/*
**
**    First, read next buffer from file.
*/
      FILE_READ.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN);
      FILE_READ.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN);
      FILE_READ.BUF_.BOUND = 1023;
      ERROR_BUFFER.ERR = '000000000000'O;
      CALL M$READ (FILE_READ)
         WHENALTRETURN DO;
            CALL XUR$ERRTOLCP6 (ERROR_BUFFER.ERR, B$TCB$->B$TCB.ALT$->B$ALT.ERR);
            END;
 
%EJECT;
/*
**
**    Now re-issue the write.
*/
      FPRG_WRITE.V.EVENT# = EVENT_Q.EVENT#(Q_FRONT);
      FPRG_WRITE.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
      IF ERROR_BUFFER.ERR THEN
         FPRG_WRITE.BUF_ = VECTOR(ERROR_BUFFER);
      ELSE
         DO;
            FPRG_WRITE.BUF_.BUF$ = FPRG_INFO.BUFFER_PTRS.IN$(SLOT_UBIN);
            FPRG_WRITE.BUF_.BOUND =
               DCBADDR(FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN))->F$DCB.ARS# - 1;
            END;
      CALL M$WRITE (FPRG_WRITE)
         WHENALTRETURN DO;
            IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOFPRG THEN
               CALL M$MERC;
            RETURN;
            END;
 
END WRITE_PROC;
%EJECT;
STOP_PROC: PROC;
/*
**
**    This procedure cleans-up after an fprg.
**
*/
      DCL STOP_FMT                     CHAR(0)   CONSTANT INIT
          ('Fprg in slot %D stopped');
 
      IF NOT FPRG_INFO.CONT_FLAG(SLOT_UBIN) THEN
         DO;
            FPT_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.IN#(SLOT_UBIN);
            CALL M$CLOSE (FPT_CLOSE) WHENALTRETURN DO; END;
            FPT_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.OUT#(SLOT_UBIN);
            CALL M$CLOSE (FPT_CLOSE) WHENALTRETURN DO; END;
            FPT_CLOSE.V.DCB# = FPRG_INFO.DCB_NUMS.FPRG#(SLOT_UBIN);
            CALL M$CLOSE (FPT_CLOSE) WHENALTRETURN DO; END;
            END;
 
      FPRG_INFO.RUN_FLAG(SLOT_UBIN) = '0'B;
      IF ~FPRG_INFO.CONT_FLAG(SLOT_UBIN) THEN FPRG_INFO.FULL_FLAG(SLOT_UBIN) = '0'B;
 
      IF LIST_FLAGS.STOP THEN
         CALL X$WRITE (F_FDS, VECTOR(STOP_FMT), VECTOR(SLOT_UBIN));
 
END STOP_PROC;
%EJECT;
ALTRET_ERROR: PROC;
/*
**
**    This procedure prints the error message from the altret frame.
**
*/
      DCL DCB#                         UBIN;
 
      %VLP_ERRCODE;
/*
**
**    Set the error code and dcb.
*/
      DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
      VLP_ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
      VLP_ERRCODE.SEV = 0;
/*
**
**    Print the message.
*/
      CALL XUR$SETERRMSG;
      CALL XUR$ERRMSG (VLP_ERRCODE, DCB#);
 
END ALTRET_ERROR;
 
END MUPPET_EVENT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MUPPET_ERROR: PROC (ERR#);
/*
**
**    This procedure prints error messages from the passed error.
**
*/
      DCL ERR#                         UBIN;
 
      DCL I                            SBIN;
 
      DCL M$LM                         DCB;
      DCL M$LM$                        PTR;
 
      %INCLUDE CP_6;
      %INCLUDE XUR_ENTRY;
 
      %F$DCB;
 
      %VLP_ERRCODE (FCG=MU,
                    MID=P);
 
      %VLP_NAME (FPTN=RU_NAME,
                 LEN=40);
 
      %FPT_ERR;
 
%EJECT;
/*
**
**    Fill in error code.
*/
      VLP_ERRCODE.ERR# = ERR#;
      VLP_ERRCODE.SEV = 0;
/*
**
**    Set error message file to run-unit file.
*/
      M$LM$ = DCBADDR(DCBNUM(M$LM));
      CALL CONCAT (RU_NAME.NAME#, SUBSTR(M$LM$->F$DCB.NAME#.C,0,M$LM$->F$DCB.NAME#.L),
                                  '.',M$LM$->F$DCB.ACCT#);
      CALL INDEX (I, ' ', RU_NAME.NAME#);
      RU_NAME.L# = I;
      CALL XUR$SETERRMSG (RU_NAME);
/*
**
**    Finally, we can print the error message.
*/
      CALL XUR$ERRMSG (VLP_ERRCODE);
/*
**
**    If the error code > 100, get out!
*/
      IF ERR# > 100 THEN
         DO;
            CALL XUR$CLOSE_DCBS;
            FPT_ERR.CODE_ = VECTOR(VLP_ERRCODE);
            CALL M$ERR (FPT_ERR);
            END;
 
END MUPPET_ERROR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MUPPET_XCON: PROC ASYNC;
 
      DCL ERROR_BUFFER                 CHAR(511) STATIC;
 
      DCL 1 EVAL_CMD                   STATIC,
            2 *                        CHAR(5)   INIT('EVAL '),
            2 IC                       CHAR(6),
            2 *                        CHAR(5)   INIT(' \REL');
 
      DCL PLUGH_CMD                    CHAR(5)   STATIC INIT('PLUGH');
 
      DCL UNSHARE_CMD                  CHAR(11)  STATIC INIT('UNSHARE ALL');
 
      DCL DO_BUFFER                    CHAR(80)  STATIC;
      DCL M$DO                         DCB;
 
      DCL B$TCB$                       PTR       SYMREF;
 
      DCL MUPPET_ERROR                 ENTRY(1);
 
%EJECT;
      %INCLUDE CP_6;
      %INCLUDE B_ERRORS_C;
      %INCLUDE XUR_ENTRY;
      %INCLUDE MUPPET_C61;
 
      %B$TCB;
      %B$XCON;
      %B$EXCFR;
 
      %VLP_NAME (FPTN=DELTA_NAME,
                 NAME='DELTA');
 
      %FPT_WRITE (FPTN=DO_WRITE,
                  BUF=DO_BUFFER,
                  DCB=M$DO);
 
      %FPT_ERRMSG (BUF=ERROR_BUFFER,
                   OUTDCB1=M$DO);
 
      %FPT_ALIB (ECHO=NO,
                 DLIB=YES,
                 LIBNAME=DELTA_NAME,
                 RETRN=YES);
 
      %FPT_XCON (FPTN=RESET_XCON);
 
      %FPT_ERR;
 
%EJECT;
/*
**
**    Sometimes when we get here it is not so serious.
*/
      IF B$TCB$->B$TCB.STK$->B$XCON.ERR.ERR# = %E$EKEY THEN
         DO;
            CALL MUPPET_ERROR (%XE$BYEBYE#);
            CALL XUR$CLOSE_DCBS;
            CALL M$XCON (RESET_XCON);
            CALL M$EXIT;
            END;
/*
**
**    Tell user we screwed up and what's to follow.
*/
      CALL MUPPET_ERROR (%XE$WOOPS#);
 
%EJECT;
/*
**
**    Print error message.
*/
      FPT_ERRMSG.CODE_ = VECTOR(B$TCB$->B$TCB.STK$->B$XCON.ERR);
      CALL M$ERRMSG (FPT_ERRMSG);
/*
**
**    Get delta to display the IC.
*/
      DO_BUFFER = ' ';
      CALL M$WRITE (DO_WRITE);
      CALL BINCHAR (EVAL_CMD.IC, B$TCB$->B$TCB.STK$->B$EXCFR.IC);
      FPT_ALIB.CMD_ = VECTOR(EVAL_CMD);
      CALL M$ALIB (FPT_ALIB);
/*
**
**    Now, the PLUGH, and an UNSHARE.
*/
      DO_BUFFER = ' ';
      CALL M$WRITE (DO_WRITE);
      FPT_ALIB.CMD_ = VECTOR(PLUGH_CMD);
      CALL M$ALIB (FPT_ALIB);
 
      FPT_ALIB.CMD_ = VECTOR(UNSHARE_CMD);
      CALL M$ALIB (FPT_ALIB);
/*
**
**    Close any dcbs so files are saved.
*/
      CALL XUR$CLOSE_DCBS;
/*
**
**    Now reset exit condition and exit.
*/
      CALL M$XCON (RESET_XCON);
      FPT_ERR.CODE_ = VECTOR(B$TCB$->B$TCB.STK$->B$XCON.ERR);
      CALL M$ERR (FPT_ERR);
 
END MUPPET_XCON;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MUPPET_BREAK_ABORT: PROC;
/*
**
**    This procedure UNWINDs to the XUR$GETCMD call.
*/
      DCL RESTART_POINT                EXTROOT   REMEMBER;
 
      UNWIND TO RESTART_POINT;
 
END MUPPET_BREAK_ABORT;
