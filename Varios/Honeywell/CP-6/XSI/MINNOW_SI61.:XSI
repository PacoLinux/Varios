/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MINNOW$BREAK: PROC  ASYNC;
 
%INCLUDE CP_6;
 
%FPT_TRMPRG  (FPTN                     = RESET_BRK_CNT,
              RSTBRK=YES );
 
DCL BRK_CNT                  SBIN      SYMREF;
 
    BRK_CNT= BRK_CNT + 1;
    CALL M$TRMPRG( RESET_BRK_CNT );
RE_TURN:
    RETURN;
 
END MINNOW$BREAK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MINNOW: PROC MAIN;
 
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
/* CLUDE MINNOW_C61; */
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;
  %CODE03(BASED="BASED(FIT$)");
  %FITALTKEYS(BASED="BASED(ALTKEY$)");
  %FITALTKEYS(BASED=STATIC,FITALTKEYS=STATIC_ALTKEYS);
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE XUH_MACRO_C;
  %XUH_PARAM;
%EJECT;
%LIST;
%INCLUDE MINNOW_C61;
%PLIST;
%EJECT;
/**/
/* EQUs used to access the PCB */
/**/
 
%EQU BLK1_NSUBLKS = %CHARTEXT('BLK1$->P_OUT.NSUBLKS');
%EQU BLK1_SUBLK$  = %CHARTEXT('BLK1$->P_OUT.SUBLK$');
 
%EQU BLK2_NSUBLKS = %CHARTEXT('BLK2$->P_OUT.NSUBLKS');
%EQU BLK2_SUBLK$  = %CHARTEXT('BLK2$->P_OUT.SUBLK$');
%EQU BLK2_CODE    = %CHARTEXT('BLK2$->P_SYM.CODE');
%EQU BLK2_COUNT   = %CHARTEXT('BLK2$->P_SYM.COUNT');
%EQU BLK2_TEXT    = %CHARTEXT('SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)');
 
%EQU BLK3_NSUBLKS = %CHARTEXT('BLK3$->P_OUT.NSUBLKS');
%EQU BLK3_SUBLK$  = %CHARTEXT('BLK3$->P_OUT.SUBLK$');
%EQU BLK3_CODE    = %CHARTEXT('BLK3$->P_SYM.CODE');
%EQU BLK3_CPOS    = %CHARTEXT('BLK3$->P_SYM.CPOS');
%EQU BLK3_COUNT   = %CHARTEXT('BLK3$->P_SYM.COUNT');
%EQU BLK3_TEXT    = %CHARTEXT('SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)');
 
%EQU BLK4_NSUBLKS = %CHARTEXT('BLK4$->P_OUT.NSUBLKS');
%EQU BLK4_SUBLK$  = %CHARTEXT('BLK4$->P_OUT.SUBLK$');
%EQU BLK4_CODE    = %CHARTEXT('BLK4$->P_SYM.CODE');
%EQU BLK4_COUNT   = %CHARTEXT('BLK4$->P_SYM.COUNT');
%EQU BLK4_TEXT    = %CHARTEXT('SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT)');
 
%EQU MONERR       = %CHARTEXT('B$TCB$->B$TCB.ALT$->B$ALT.ERR');
%EQU ERRDCB       = %CHARTEXT('B$TCB$->B$TCB.ALT$->B$ALT.DCB#');
 
%EJECT;
/**/
/* Miscellaneous FPTs */
/**/
 
%VLP_ACCT    (FPTN                     = A_ACCT );
 
%VLP_NAME    (FPTN                     = A_NAME );
 
%VLP_PASS    (FPTN                     = A_PASS );
 
%VLP_SN      (FPTN                     = A_SN );
 
%VLP_ALTKEYS (FPTN                     = ALTKEYS,
              N=20 );
 
%FPT_INT     (FPTN                     = BREAK_CNTRL,
              UENTRY=MINNOW$BREAK );
 
%FPT_TIME    (FPTN                     = CALC_ELAPSE,
              DATE=YYMMDD,
              DAY=YYMMM,
              DEST=ANS,
              SOURCE=UTS,
              TIME=HHMMSSSS,
              TSTAMP=ELAPSE_UTS );
 
%FPT_CLOSE   (FPTN                     = CLOSE_OUT,
              DCB=F$OUT );
 
%FPT_CLOSE   (FPTN                     = DEFAULT_CLOSE );
 
%FPT_OPEN    (FPTN                     = DEFAULT_OPEN );
 
%FPT_OPEN    (FPTN                     = OPEN_MOD );
 
%FPT_CLOSE   (FPTN                     = CLOSE_MOD );
 
%FPT_PFIL    (FPTN                     = DEFAULT_PFIL,
              BOF=YES,
              DCB=F$IN );
 
%FPT_PRECORD (FPTN                     = DEFAULT_PRECORD,
              DCB=F$IN,
              KEY=KEY_BUF,
              KEYR=YES );
 
%FPT_READ    (FPTN                     = DEFAULT_READ,
              DCB=F$IN,
              KEY=KEY_BUF,
              KEYR=YES );
%VLP_ERRCODE (FPTN                     = ERRCODE );
 
%FPT_CLOSE   (FPTN                     = FPT_CLOSE );
 
%FPT_FID     (FPTN                     = FPT_FID,
              ACCT=A_ACCT,
              ASN=FPT_OPEN.V.ASN#,
              NAME=A_NAME,
              PASS=A_PASS,
              RES=FPT_OPEN.V.RES#,
              SN=A_SN,
              RESULTS=VLR_FID );
 
%FPT_KEYIN   (FPTN                     = FPT_KEYIN,
              OCTYPE=ADMIN,
              WSN='LOCAL' );
 
%FPT_OPEN    (FPTN                     = FPT_OPEN );
 
%FPT_PFIL    (FPTN                     = FPT_PFIL );
 
%FPT_PRECORD (FPTN                     = FPT_PRECORD );
 
%FPT_READ    (FPTN                     = FPT_READ );
 
%FPT_GDS     (FPTN                     = GDS_IN,
              RESULTS=GDS_IN_ );
 
%VLP_VECTOR  (FPTN                     = GDS_IN_ );
 
%FPT_GDS     (FPTN                     = GDS_OUT,
              RESULTS=GDS_OUT_ );
 
%VLP_VECTOR  (FPTN                     = GDS_OUT_ );
 
%FPT_TIME    (FPTN                     = GET_TIME,
              DEST=UTS,
              SOURCE=CLOCK,
              TSTAMP=UTS_NOW );
 
%FPT_OPEN    (FPTN                     = OPEN_IN );
 
%FPT_OPEN    (FPTN                     = OPEN_OUT );
 
%FPT_READ    (FPTN                     = READ_IN,
              DCB=F$IN );
 
%FPT_EXIT    (FPTN                     = SET_STEPCC,
              STEPCC=OK );
 
%FPT_UNFID   (FPTN                     = UNFID_IN,
              DCB=F$IN,
              TEXTFID=IN_FID );
 
%VLR_FID    (FPTN                      = VLR_FID );
 
%FPT_WRITE   (FPTN                     = WRITE_OUT,
              DCB=F$OUT );
%EJECT;
/**/
/* XUR$GETCMD, X$PARSE & XUF$FORMAT stuff */
/**/
 
%XUR_INIT    (NAME                     = XUR_INIT,
              PCB=P_PCB,
              STCLASS=STATIC );
 
%P$PCB       (NAME                     = P_PCB,
              STCLASS=STATIC );
 
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS=BASED );
 
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS=BASED );
 
%F_FDS       (NAME                     = F_FDS,
              BUF=ME_BUF,
              DCB=M$LO,
              STCLASS=STATIC );
%EJECT;
/**/
/* BASED items, listed alphabetically */
/**/
 
DCL IN_REC                   CHAR(IN_ARS)     BASED(GDS_IN_.PTR$);
DCL OUT_REC                  CHAR(OUT_ARS)    BASED(GDS_OUT_.PTR$);
%EJECT;
/**/
/* BIT items, listed alphabetically */
/**/
 
DCL ANY_UNDEF_KEYS           BIT(1);
DCL CCBUF_CMD                BIT(1);
DCL CHECKING_DUPES           BIT(1);
DCL DONE                     BIT(1);
DCL DONE_PARSING             BIT(1);
DCL EOF                      BIT(1);
DCL INDEX_OPT(0:35)          BIT(1);
DCL INFORM_ON_OC             BIT(1);
DCL NO_HEADINGS_YET          BIT(1);
DCL OPTION(0:35)             BIT(1);
%EJECT;
/**/
/* CHARacter items, listed alphabetically */
/**/
 
DCL BOGUS_KEYX(0:127)        CHAR(2)   STATIC INIT(BITASC('777000'O));
DCL   BOGUS_KEY REDEF BOGUS_KEYX CHAR(256);
DCL CMD                      CHAR(80)  STATIC;
DCL HHMMSSSS                 CHAR(8)   STATIC;
DCL IN_FID                   CHAR(80)  STATIC INIT('fid');
DCL KEY_BUF                  CHAR(256) STATIC;
DCL LO_BUF                   CHAR(132) STATIC;
DCL ME_BUF                   CHAR(132) STATIC;
DCL NO_LIT                   CHAR(0)   STATIC INIT(' No');
DCL PREV_KEY                 CHAR(256);
DCL PREV_REC                 CHAR(1024);
DCL PROMPT                   CHAR(0)   STATIC INIT('MINNOW> ');
DCL YES_LIT                  CHAR(0)   STATIC INIT('Yes');
DCL YYMMDD                   CHAR(6)   STATIC INIT('yymmdd');
DCL YYMMM                    CHAR(5)   STATIC INIT('yymmm');
%EJECT;
/**/
/* DCBs */
/**/
 
DCL F$IN                     DCB;
DCL F$OUT                    DCB;
DCL M$LO                     DCB;
DCL M$ME                     DCB;
DCL M$SI                     DCB;
%EJECT;
/**/
/* ENTRYs, listed alphabetically */
/**/
 
DCL MINNOW$BREAK             ENTRY     ASYNC;
DCL X$WRITE                  ENTRY(22);
DCL XSF$LOCCODT              ENTRY(2)  ALTRET;
DCL XUR$ALLMSG               ENTRY(1)  ALTRET;
DCL XUR$BREAK                ENTRY     ASYNC;
DCL XUR$CLOSE_DCBS           ENTRY(2);
DCL XUR$ECHO                 ENTRY(1)  ALTRET;
DCL XUR$ECHOIF               ENTRY(1)  ALTRET;
DCL XUR$ERRMSG               ENTRY(7)  ALTRET;
DCL XUR$ERRPTR               ENTRY(2)  ALTRET;
DCL XUR$GETCMD               ENTRY(6)  ALTRET;
DCL XUR$HELP                 ENTRY(1)  ALTRET;
DCL XUR$INIT                 ENTRY(3)  ALTRET;
DCL XUR$MOREMSG              ENTRY(1)  ALTRET;
DCL XUR$SETDCBS              ENTRY(2)  ALTRET;
%EJECT;
/**/
/* X$WRITE formats */
/**/
 
DCL FMT                      CHAR(0)   STATIC INIT('%>A');
DCL FMT1                     CHAR(0)  STATIC INIT('MINNOW A00 Here (10/29/85)');
DCL FMT2                     CHAR(0)   STATIC INIT(
    '%>A has %D granules, %D records and NO alternate keys.');
DCL FMT3                     CHAR(0)   STATIC INIT(
    '%>A has %D granules, %D records and %D alternate keys.');
DCL FMT4                     CHAR(0)   STATIC INIT(
    'Key#  Start  Length  Duplicates');
DCL FMT5                     CHAR(0)   STATIC INIT(
    '%3D%7D%7D       %>A');
DCL FMT6                     CHAR(0)   STATIC INIT(
    '%3D%7D%7D        No    <- Primary key');
DCL FMT7                     CHAR(0)   STATIC INIT(
    '.. Index # too large; file only has %D indexes.');
DCL FMT8                     CHAR(0)   STATIC INIT(
    '.. The primary INDX (INDX 1) hasn''t been specified.');
DCL FMT9                     CHAR(0)   STATIC INIT(
    '.. INDX %D hasn''t been specified.');
DCL FMT10                    CHAR(0)   STATIC INIT(
    '%3D      ?      ?              <- Undefined index <-');
DCL FMT11                    CHAR(0)   STATIC INIT(
    '.. Specify END or LENGTH, but NOT both!');
DCL FMT12                    CHAR(0)   STATIC INIT(
    '.. START value must be between 0 and 262143, inclusive.');
DCL FMT13                    CHAR(0)   STATIC INIT(
    '.. INDX number must be between 1 and 20, inclusive.');
DCL FMT14                    CHAR(0)   STATIC INIT(
    '.. No START value was specified.');
DCL FMT15                    CHAR(0)   STATIC INIT(
    '.. LENGTH or END value MUST be specified.');
DCL FMT16                    CHAR(0)   STATIC INIT(
    '   Elapsed time: %<A.%2A Seconds.');
DCL FMT17                    CHAR(0)   STATIC INIT(
    '   Elapsed time: %<A Minutes, %<A.%2A Seconds.');
DCL FMT18                    CHAR(0)   STATIC INIT(
    '   Elapsed time: %<A Hours, %<A Minutes, %<A.%2A Seconds.');
DCL FMT19                    CHAR(0)   STATIC INIT(
    '>> Internal problem: X$PARSE knows of CODE %D but MINNOW doesn''t. <<');
DCL FMT20                    CHAR(0)   STATIC INIT(
    'F$DCB.BFR.DA(%D)=.%O');
DCL FMT21                    CHAR(0)   STATIC INIT(
    'Previous Primary Key=''%A''');
DCL FMT22                    CHAR(0)   STATIC INIT(
    'Previous Key #%D=''%A''');
DCL FMT23                    CHAR(0)   STATIC INIT(
    '.. %>A now has %D records.' );
DCL FMT24                    CHAR(0)   STATIC INIT(
    '.. %D records read so far%Q; %D remain.' );
DCL FMT25                    CHAR(0)   STATIC INIT(
    '.. Duplicates NOT allowed on the primary INDX; option ignored.' );
DCL FMT26                    CHAR(0)   STATIC INIT(
    '.. CLOSing %>A; now building ALTKEYs.' );
DCL FMT27                    CHAR(0)   STATIC INIT(
    '.. Nothing to display. %A doesn''t have alternate keys.');
DCL FMT28                    CHAR(0)   STATIC INIT(
    '.. The new ALTKEY''s cannot be longer than the old ones. MOD aborted.');
DCL FMT29                    CHAR(0)   STATIC INIT(
    '.. MODIFYing %A; now rebuilding ALTKEYS.');
%EJECT;
/**/
/* PTRs, listed alphabetically */
/**/
 
DCL ALTKEY$                  PTR;
DCL B$JIT$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
DCL BLK1$                    PTR;
DCL  PERRCODE REDEF BLK1$    BIT(36);
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL BLK4$                    PTR;
DCL CODE03$                  PTR;
DCL F$IN$                    PTR;
DCL FIT$                     PTR;
DCL M$LO$                    PTR;
DCL M$ME$                    PTR;
DCL M$SI$                    PTR;
%EJECT;
/**/
/* SBIN/UBIN items, listed alphabetically */
/**/
 
DCL BRK_CNT                  SBIN      STATIC SYMDEF;
DCL MINNOW_NODES             SBIN             SYMREF;
DCL CMD#                     SBIN;
DCL CMD_LEN                  SBIN;
DCL CMD_NUM                  SBIN;
DCL DUPES                    SBIN;
DCL ELAPSE_UTS               SBIN      STATIC;
DCL ERRDCB#                  SBIN;
DCL F$IN#                    SBIN      STATIC INIT(DCBNUM(F$IN));
DCL F$OUT#                   SBIN      STATIC INIT(DCBNUM(F$OUT));
DCL FIRST_KEY                SBIN;
DCL FPARAM(0:1023)           SBIN      STATIC;
DCL GRANS                    SBIN;
DCL I                        SBIN;
DCL IN_ARS                   SBIN;
DCL IN_CNT                   SBIN;
DCL INCR_CNT                 SBIN;
DCL INCREMENT                SBIN;
DCL INDX#                    SBIN;
DCL INFORM_INTERVAL          SBIN;
DCL J                        SBIN;
DCL K                        SBIN;
DCL KEY_LEN                  SBIN;
DCL KEYL                     SBIN;
DCL KEYX                     SBIN;
DCL LAST_KEY                 SBIN;
DCL M$LO#                    SBIN      STATIC INIT(DCBNUM(M$LO));
DCL M$ME#                    SBIN      STATIC INIT(DCBNUM(M$ME));
DCL M$SI#                    SBIN      STATIC INIT(DCBNUM(M$SI));
DCL MIN_ARS                  SBIN;
DCL NRECORDS                 SBIN;
DCL NUM_CMDS                 SBIN;
DCL NUM_KEYS_TO_LIST         SBIN;
DCL NUMKEYS                  SBIN;
DCL OFFSET                   SBIN;
DCL OUT_ARS                  SBIN;
DCL OUT_CNT                  SBIN;
DCL RECSIZE                  SBIN;
DCL SKIP_BLANKS(0:511)       UBIN(9)   CALIGNED CONSTANT INIT(
    1 * %ASCBIN(' '), 0, 1 * 0 );
DCL TMP                      SBIN;
DCL UNIQUES                  SBIN;
DCL UTS_NOW                  SBIN      STATIC;
DCL X                        SBIN;
%EJECT;
/**/
/* Structures */
/**/
 
DCL 1 DEST_FID,
      2 LEN                  UBIN,
      2 TEXT                 CHAR(76);
 
DCL 1 SRCE_FID,
      2 LEN                  UBIN,
      2 TEXT                 CHAR(76);
%EJECT;
/**/
/* VECTORs */
/**/
 
DCL FMT_                     BIT(72) STATIC DALIGNED INIT(VECTOR(FMT));
DCL FMT1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT1));
DCL FMT2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT2));
DCL FMT3_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT3));
DCL FMT4_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT4));
DCL FMT5_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT5));
DCL FMT6_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT6));
DCL FMT7_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT7));
DCL FMT8_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT8));
DCL FMT9_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FMT9));
DCL FMT10_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT10));
DCL FMT11_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT11));
DCL FMT12_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT12));
DCL FMT13_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT13));
DCL FMT14_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT14));
DCL FMT15_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT15));
DCL FMT16_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT16));
DCL FMT17_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT17));
DCL FMT18_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT18));
DCL FMT19_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT19));
DCL FMT20_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT20));
DCL FMT21_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT21));
DCL FMT22_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT22));
DCL FMT23_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT23));
DCL FMT24_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT24));
DCL FMT25_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT25));
DCL FMT26_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT26));
DCL FMT27_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT27));
DCL FMT28_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT28));
DCL FMT29_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FMT29));
 
DCL VEC1_                    BIT(72)        DALIGNED;
DCL VEC2_                    BIT(72)        DALIGNED;
DCL VEC3_                    BIT(72)        DALIGNED;
DCL VEC4_                    BIT(72)        DALIGNED;
DCL VEC5_                    BIT(72)        DALIGNED;
DCL VEC6_                    BIT(72)        DALIGNED;
%EJECT;
START_MINNOW:
 
    CALL INITIALIZE          ALTRET( PUT_ERR );
 
    CALL PARSE_CCBUF         ALTRET( PUT_ERR ); /* Check CCBUF for cmd(s)     */
 
    DO WHILE( NOT DONE );
       CALL DO_1_LINE_OF_CMDS  ALTRET( DONE_YET );
DONE_YET:
       END;
 
EOJ:
    CALL XUR$CLOSE_DCBS;
    GOTO QUIT;
 
PUT_ERR:
    ERRDCB#= %ERRDCB;
    IF NOT DONE THEN
       CALL XUR$ERRMSG( %MONERR,ERRDCB# );
SET_THE_STEPCC:
    SET_STEPCC.V.STEPCC#= 4;                  /* Indicate there was an error  */
QUIT:
    CALL M$EXIT( SET_STEPCC );                /* Set STEPCC upon exit         */
 
%EJECT;
INITIALIZE: PROC  ALTRET;
 
    F$IN$= DCBADDR(DCBNUM(F$IN));             /* Set up pointers to my DCBs   */
    M$LO$= DCBADDR(DCBNUM(M$LO));
    M$SI$= DCBADDR(DCBNUM(M$SI));
 
    CALL XUR$INIT( XUR_INIT );
 
    CALL M$INT( BREAK_CNTRL )          ALTRET( ALT_RETURN ); /* Take BREAK    */
    BRK_CNT= 0;                               /* control then zero BREAK count*/
    INFORM_INTERVAL= 9999999;                 /* A big number!                */
    RECSIZE= 0;
 
    DONE= '0'B;                               /* Assume we aren't done yet!   */
    OPTION= '0'B;
 
    ALTKEY$= ADDR(STATIC_ALTKEYS);
 
    CALL INIT_ALTKEY_TABLE;                   /* Clear ALTKEYS table          */
 
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END INITIALIZE;
%EJECT;
PARSE_CCBUF: PROC  ALTRET;
 
    CCBUF_CMD= %NO#;
    IF B$JIT.CCDISP < B$JIT.CCARS  AND        /* Anything in CCBUF?           */
       SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP) ~= '('  AND
       SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP) ~= '()' THEN DO;
       OFFSET= LENGTHC('!') + B$JIT.CCDISP;
       CMD= SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1);
       CMD_LEN= B$JIT.CCARS - B$JIT.CCDISP - 1;
       CCBUF_CMD= %YES#;
       CMD_NUM= 999;                        /* Force GET_A_CMD to look at CMD */
       NUM_CMDS= -1;
       CALL GET_A_CMD( SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1),/* Parse CCBUF cmds */
                       B$JIT.CCARS-B$JIT.CCDISP-1 ) ALTRET( OOPS );
 
       /* MINNOW A00 Here (mm/dd/yy) */
       CALL X$WRITE( F_FDS,FMT1_ );           /* MINNOW A00 here (mm/dd/yy)   */
       CMD_NUM= -1;
       CALL DO_1_LINE_OF_CMDS( SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1),
                               B$JIT.CCARS-B$JIT.CCDISP-1 );
       END;
    ELSE DO;
       CMD_NUM= 0;
       NUM_CMDS= 0;
       /* MINNOW A00 Here (mm/dd/yy) */
       CALL X$WRITE( F_FDS,FMT1_ );           /* MINNOW A00 here (mm/dd/yy)   */
       END;
    OFFSET= 0;                           /* Set OFFSET for PUT_ERROR's finger */
    GOTO RE_TURN;
 
OOPS:
    CALL PUT_ERROR;                           /* Go give user the finger!     */
    IF CCBUF_CMD THEN
       DONE= %YES#;                           /* Quit now if cmd was in CCBUF */
RE_TURN:
    RETURN;
 
END PARSE_CCBUF;
%EJECT;
DO_1_LINE_OF_CMDS: PROC( BUF,BUF_LEN )  ALTRET;
DCL BUF                      CHAR(BUF_LEN);
DCL BUF_LEN                  SBIN;
 
    DONE_PARSING= %NO#;
    DO WHILE( NOT DONE_PARSING );
       CALL GET_A_CMD( BUF,BUF_LEN )   ALTRET( END_OF_RECORD );
       IF NOT DONE_PARSING THEN
          CALL DO_A_CMD;
       END;
 
END_OF_RECORD:
    IF NOT DONE_PARSING THEN
       IF ERRCODE.ERR# = %E$EOF THEN
          DONE= %YES#;
       ELSE
          CALL PUT_ERROR;
    IF CCBUF_CMD THEN
       DONE= %YES#;
ALT_RETURN:
    ALTRETURN;
 
END DO_1_LINE_OF_CMDS;
%EJECT;
GET_A_CMD: PROC( CMD,CMD_LEN )  ALTRET;
DCL CMD                      CHAR(CMD_LEN);
DCL CMD_LEN                  UBIN;
 
    CMD_NUM= CMD_NUM + 1;                     /* Point to next command        */
    IF CMD_NUM >= NUM_CMDS THEN               /* Anything left?               */
       IF CMD_NUM >= 999 OR ADDR(CMD) = ADDR(NIL)  THEN DO;/* Nope. Get more. */
          CMD_NUM= 0;                         /* Set number of commands to 0  */
          IF ADDR(CMD) = ADDR(NIL) THEN       /* Get commands from user?      */
             CALL XUR$GETCMD( MINNOW_NODES,BLK1$,VECTOR(PROMPT) ) ALTRET( OOPS);
          ELSE                                /* Else: parse what was passed  */
             CALL XUR$GETCMD( MINNOW_NODES,BLK1$,,CMD,CMD_LEN )  ALTRET( OOPS );
          CALL XUR$ECHOIF( M$LO# );
          NUM_CMDS= %BLK1_NSUBLKS;            /* Remember number of commands  */
          END;
       ELSE DO;
          DONE_PARSING= %YES#;                /* Indicate we are done parsing */
          GOTO RE_TURN;
          END;
    BLK2$= %BLK1_SUBLK$(CMD_NUM);             /* Set up some PTRs to the PCB  */
    IF %BLK2_NSUBLKS > 0 THEN
       BLK3$= %BLK2_SUBLK$(0);
    CMD#= %BLK2_CODE;                         /* Remember the command we're on*/
RE_TURN:
    RETURN;
 
OOPS:                                         /* The label says it all!       */
    NUM_CMDS= 0;
    ERRCODE= PERRCODE;                        /* Load the error code returned */
ALT_RETURN:
    ALTRETURN;                                /* by XUR$GETCMD, then ALTRETURN*/
 
END GET_A_CMD;
%EJECT;
DO_A_CMD: PROC  ALTRET;
 
    OPTION= '0'B;
    OPTION(CMD#)= %YES#;               /* Remember they specified this option */
    DO CASE( CMD# );
       CASE( %ALL_HELP## );
          CALL XUR$ALLMSG( XUH_PARAM )  ALTRET( HELP_ERR );
 
       CASE( %COPY## );
          CALL PARSE_COPY              ALTRET( RE_TURN );
          CALL CHECK_INDEXES           ALTRET( RE_TURN );
          CALL OPEN_INPUT              ALTRET( RE_TURN );
          CALL GET_BUFFERS             ALTRET( RE_TURN );
          CALL OPEN_OUTPUT             ALTRET( RE_TURN );
          CALL BUILD_FILE;
          VEC1_= VECTOR(SUBSTR(DEST_FID.TEXT,0,DEST_FID.LEN));
          IF OPEN_OUT.V.LOAD#        AND
             CLOSE_OUT.V.ALTBLD#     AND
             FITALTKEYS.NUMENTS > 1  THEN
             /* CLOSing %>A; now building ALTKEYs. */
             CALL X$WRITE( F_FDS,FMT26_,VEC1_ );
          CALL CLOSE( F$IN#,%SAVE# );  /* Close F$IN                          */
          CALL CLOSE( F$OUT#,%SAVE#,CLOSE_OUT );
          DONE= %YES#;
          DONE_PARSING= %YES#;
 
       CASE( %CREATE## );
          CALL PARSE_CREATE            ALTRET( RE_TURN );
          CALL CHECK_INDEXES           ALTRET( RE_TURN );
          CALL OPEN_INPUT              ALTRET( RE_TURN );
          CALL GET_BUFFERS             ALTRET( RE_TURN );
          CALL OPEN_OUTPUT             ALTRET( RE_TURN );
          CALL BUILD_FILE;
          VEC1_= VECTOR(SUBSTR(DEST_FID.TEXT,0,DEST_FID.LEN));
          IF OPEN_OUT.V.LOAD#        AND
             CLOSE_OUT.V.ALTBLD#     AND
             FITALTKEYS.NUMENTS > 1  THEN
             /* CLOSing %>A; now building ALTKEYs. */
             CALL X$WRITE( F_FDS,FMT26_,VEC1_ );
          CALL CLOSE( F$IN#,%SAVE# );  /* Close F$IN                          */
          CALL CLOSE( F$OUT#,%SAVE#,CLOSE_OUT );
          DONE= %YES#;
          DONE_PARSING= %YES#;
 
       CASE( %DISPLAY## );
 
          CALL PARSE_FID               ALTRET ( RE_TURN );
          CALL OPEN_INPUT              ALTRET ( RE_TURN );
          CALL GET_BUFFERS             ALTRET ( RE_TURN );
          CALL GET_KEYS                ALTRET ( RE_TURN );
          CALL CLOSE(F$IN#,%SAVE#);
          %BLK3_TEXT = 'ALL';
          %BLK3_CODE = %ALL##;
          CALL LIST_KEYS;
 
       CASE( %END## );
          DONE= %YES#;
          DONE_PARSING= %YES#;
 
       CASE( %HELP## );
          XUH_PARAM.HELP$= BLK3$->P_SYM.TEXTC$;
          CALL XUR$HELP( XUH_PARAM )   ALTRET( HELP_ERR );
          DO WHILE('0'B);
HELP_ERR:
             IF XUH_PARAM.ERR.ERR# ~= %E$NOHPROC  AND
                XUH_PARAM.ERR.ERR# ~= %E$BDTOPIC THEN
                CALL XUR$ERRMSG( XUH_PARAM.ERR );
             END;
 
       CASE( %INDEX## );
          CALL PARSE_INDEX             ALTRET( RE_TURN );
 
       CASE( %INFORM## );
          IF %BLK2_NSUBLKS > 1 THEN DO;
             INFORM_ON_OC= %YES#;
             BLK3$= %BLK2_SUBLK$(1);
             END;
          ELSE
             INFORM_ON_OC= %NO#;
          CALL CHARBIN( INFORM_INTERVAL,%BLK3_TEXT );
          IF INFORM_INTERVAL < 1 THEN
             INFORM_INTERVAL= 1;
 
       CASE( %LIST## );
          CALL LIST_KEYS;
 
       CASE( %MODIFY## );
          CALL PARSE_FID                      ALTRET( RE_TURN );
 
          CALL CHECK_INDEXES                  ALTRET( RE_TURN );
 
          CALL CHECK_OLD_NEW                  ALTRET( RE_TURN );
 
          CALL MODIFY                         ALTRET( RE_TURN );
 
       CASE( %MORE_HELP## );
GET_MORE_HELP:
          CALL XUR$MOREMSG( XUH_PARAM )       ALTRET( HELP_ERR );
 
       CASE( %NULL## );
          IF M$SI$->F$DCB.EOMVAL#.VALUE# = BITBIN('012'O) THEN DO;
             CMD#= %MORE_HELP##;              /* Pretend they entered a '?'   */
             GOTO GET_MORE_HELP;
             END;
 
       CASE( %NUMBER## );
          CALL CHARBIN( X,%BLK3_TEXT );
          FITALTKEYS.NUMENTS= X;
 
       CASE( %RECSIZE## );
          CALL CHARBIN( X,%BLK3_TEXT );
          IF X >= MIN_ARS THEN
             RECSIZE= X;
 
       END;
 
RE_TURN:
    RETURN;
 
END DO_A_CMD;
%EJECT;
PUT_ERROR: PROC( FINGER_POS );
DCL FINGER_POS               SBIN;
 
    IF ERRCODE.ERR# = %E$SYNERR THEN DO;
       IF ADDR(FINGER_POS) = ADDR(NIL) THEN
          CALL XUR$ECHOIF( M$LO# );
       CALL XUR$ERRPTR( OFFSET+P_PCB.HI_CHAR,M$LO# );
       END;
    ELSE
       CALL XUR$ERRMSG( ERRCODE,ERRDCB# );
RE_TURN:
    RETURN;
 
END PUT_ERROR;
%EJECT;
PUT: PROC( BUF );
DCL BUF                      CHAR(132);
 
    CALL INDEX( K,'\',BUF )  WHENALTRETURN DO;
       K= LENGTHC(' ');
       END;
 
    /* %>A */
    CALL X$WRITE( F_FDS,FMT_,VECTOR(SUBSTR(BUF,0,K)) );
RE_TURN:
    RETURN;
 
END PUT;
%EJECT;
LIST_KEYS: PROC;
 
    IF %BLK2_NSUBLKS > 0  AND  %BLK3_CODE = %INDX## THEN
       CALL CHARBIN( K,%BLK3_TEXT );
    IF %BLK2_NSUBLKS>0 AND (%BLK3_CODE = %ALL##  OR  K = 0) THEN
       NUM_KEYS_TO_LIST= 0;
    ELSE
       NUM_KEYS_TO_LIST= %BLK2_NSUBLKS;
 
    NO_HEADINGS_YET= %YES#;
    VEC1_= VECTOR(I);
    MIN_ARS= 0;
    DO I=1 TO FITALTKEYS.NUMENTS;
       IF FITALTKEYS.K.KEYX(I-1) + FITALTKEYS.K.KEYL(I-1) > MIN_ARS THEN
          MIN_ARS= FITALTKEYS.K.KEYX(I-1) + FITALTKEYS.K.KEYL(I-1);
       IF NUM_KEYS_TO_LIST > 0 THEN DO;
          DO J=0 TO %BLK2_NSUBLKS-1;
             BLK3$= %BLK2_SUBLK$(J);
             CALL CHARBIN( K,%BLK3_TEXT );
             IF K > FITALTKEYS.NUMENTS THEN DO;
                LO_BUF= ' ';
                SUBSTR(LO_BUF,LENGTHC(PROMPT)+%BLK3_CPOS,2)= '^\';
                CALL PUT( LO_BUF );
                K= FITALTKEYS.NUMENTS;
                /* .. Index # too large; file only has %D indexes. */
                CALL X$WRITE( F_FDS,FMT7_,VECTOR(K) );
                GOTO RE_TURN;
                END;
             IF I = K THEN
                GOTO LIST_IT;
             END;
          GOTO NEXT_KEY;
          END;
LIST_IT:
       IF NO_HEADINGS_YET THEN DO;
          /* Key#  Start  Length  Duplicate */
          CALL X$WRITE( F_FDS,FMT4_ );
          NO_HEADINGS_YET= %NO#;
          END;
       VEC2_= VECTOR(FITALTKEYS.K.KEYX(I-1));
       VEC3_= VECTOR(FITALTKEYS.K.KEYL(I-1));
       IF FITALTKEYS.K.UNIQUE(I-1) THEN
          VEC4_= VECTOR(NO_LIT);
       ELSE
          VEC4_= VECTOR(YES_LIT);
       IF FITALTKEYS.K.KEYL(I-1)=0 THEN
          /* %3D      ?      ?              <- Undefined index <- */
          CALL X$WRITE( F_FDS,FMT10_,VEC1_ );
       ELSE
          IF I = 1 THEN
             /* %3D%7D%7D        No    <- Primary key */
             CALL X$WRITE( F_FDS,FMT6_,VEC1_,VEC2_,VEC3_ );
          ELSE
             /* %3D%7D%7D       %>A */
             CALL X$WRITE( F_FDS,FMT5_,VEC1_,VEC2_,VEC3_,VEC4_ );
NEXT_KEY:
       END;
RE_TURN:
    RETURN;
 
END LIST_KEYS;
%EJECT;
PUT_STATS: PROC;
 
    VEC1_= VECTOR(IN_CNT);
    VEC3_= VECTOR(SUBSTR(DEST_FID.TEXT,0,DEST_FID.LEN));
    VEC4_= VECTOR(OUT_CNT);
    IF EOF THEN
       /* .. %>A now has %D records. */
       CALL X$WRITE( F_FDS,FMT23_,VEC3_,VEC4_ );
    ELSE
       IF NRECORDS > -1 THEN DO;
          X= NRECORDS - IN_CNT;
          VEC2_= VECTOR(X);
          /* .. %D records read so far%Q; %D remain. */
          CALL X$WRITE( F_FDS,FMT24_,VEC1_,VEC2_ );
          END;
       ELSE
          /* .. %D records read so far%Q; %D remain. */
          CALL X$WRITE( F_FDS,FMT24_,VEC1_ );
    BRK_CNT= 0;
RE_TURN:
    RETURN;
 
END PUT_STATS;
%EJECT;
FIGURE_ELAPSED: PROC;
 
    CALL M$TIME( GET_TIME );
    ELAPSE_UTS= UTS_NOW - ELAPSE_UTS;
    CALL M$TIME( CALC_ELAPSE );
 
    CALL EDITSTR( HHMMSSSS,0,5,'105'O,HHMMSSSS );
    VEC1_= VECTOR(SUBSTR(HHMMSSSS,0,2));
    VEC2_= VECTOR(SUBSTR(HHMMSSSS,2,2));
    VEC3_= VECTOR(SUBSTR(HHMMSSSS,4,2));
    VEC4_= VECTOR(SUBSTR(HHMMSSSS,6,2));
    IF SUBSTR(HHMMSSSS,0,4)='    ' THEN
       /*    Elapsed time: %<A.%2A Seconds. */
       CALL X$WRITE( F_FDS,FMT16_,VEC3_,VEC4_ );
    ELSE
       IF SUBSTR(HHMMSSSS,0,2)='  ' THEN
          /*    Elapsed time: %<A Minutes, %<A.%2A Seconds. */
          CALL X$WRITE( F_FDS,FMT17_,VEC2_,VEC3_,VEC4_ );
       ELSE
          /*    Elapsed time: %<A Hours, %<A Minutes, %<A.%2A Seconds. */
          CALL X$WRITE( F_FDS,FMT18_,VEC1_,VEC2_,VEC3_,VEC4_ );
RE_TURN:
    RETURN;
 
END FIGURE_ELAPSED;
%EJECT;
PARSE_COPY: PROC  ALTRET;
 
    OPEN_IN= DEFAULT_OPEN;
    OPEN_IN.V_= VECTOR(OPEN_IN.V);
    OPEN_IN.FPARAM_= VECTOR(FPARAM);
    OPEN_IN.V.ASN#= %FILE#;
    OPEN_IN.V.DCB#= F$IN#;
 
    OPEN_OUT= DEFAULT_OPEN;
    OPEN_OUT.V_= VECTOR(OPEN_OUT.V);
    OPEN_OUT.IFPARAM_= VECTOR(FPARAM);
    OPEN_OUT.V.ACS#= %DIRECT#;
    OPEN_OUT.V.ASN#= %FILE#;
    OPEN_OUT.V.DCB#= F$OUT#;
    OPEN_OUT.V.FUN#= %CREATE#;
    OPEN_OUT.V.LOAD#= %YES#;
    OPEN_OUT.V.ORG#= %INDEXED#;
 
    CLOSE_OUT= DEFAULT_CLOSE;
    CLOSE_OUT.V_= VECTOR(CLOSE_OUT.V);
    CLOSE_OUT.V.OPER.RELG#= %YES#;     /* By default, release excess granules */
 
    DO I=0 TO %BLK2_NSUBLKS-1;
       BLK3$= %BLK2_SUBLK$(I);
       IF %BLK3_NSUBLKS>0 THEN
          BLK4$= %BLK3_SUBLK$(0);
       DO CASE( %BLK3_CODE );
          CASE( %COPY_ALTBLD## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN DO;
                CLOSE_OUT.V.ALTBLD#= %YES#;
                CLOSE_OUT.V.OPER.REBLD#= %YES#;
                END;
             ELSE DO;
                CLOSE_OUT.V.ALTBLD#= %NO#;
                CLOSE_OUT.V.OPER.REBLD#= %NO#;
                END;
          CASE( %COPY_CTG## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                OPEN_OUT.V.CTG#= %YES#;
             ELSE
                OPEN_OUT.V.CTG#= %NO#;
          CASE( %COPY_DEST## );
             DEST_FID.LEN=  %BLK3_COUNT;
             DEST_FID.TEXT= %BLK3_TEXT;
          CASE( %COPY_IXTN## );
             CALL CHARBIN( OPEN_OUT.V.IXTNSIZE#,%BLK4_TEXT );
          CASE( %COPY_LOAD## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                OPEN_OUT.V.LOAD#= %YES#;
             ELSE
                OPEN_OUT.V.LOAD#= %NO#;
          CASE( %COPY_ON## );
             OPEN_OUT.V.EXIST#= %ERROR#;
          CASE( %COPY_OVER## );
             OPEN_OUT.V.EXIST#= %NEWFILE#;
          CASE( %COPY_RELG## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                CLOSE_OUT.V.OPER.RELG#= %YES#;
             ELSE
                CLOSE_OUT.V.OPER.RELG#= %NO#;
          CASE( %COPY_SRCE## );
             SRCE_FID.LEN=  %BLK3_COUNT;
             SRCE_FID.TEXT= %BLK3_TEXT;
          CASE( %COPY_XTN## );
             CALL CHARBIN( X,%BLK4_TEXT );
             OPEN_OUT.V.XTNSIZE#= X;
          END;
       END;
RE_TURN:
    RETURN;
 
END PARSE_COPY;
%EJECT;
CHECK_INDEXES: PROC  ALTRET;
 
    ANY_UNDEF_KEYS= %NO#;                     /* Assume all keys areOK        */
    VEC1_= VECTOR(X);
    MIN_ARS= 0;
    DO X=1 TO FITALTKEYS.NUMENTS;
       IF FITALTKEYS.K.KEYL(X-1)=0 THEN DO;   /* Has this one been specified? */
          ANY_UNDEF_KEYS= %YES#;              /*  Oops!  No it hasn't!        */
          IF X = 1 THEN
             /* .. The primary INDX (INDX 1) hasn't been specified. */
             CALL X$WRITE( F_FDS,FMT8_ );
          ELSE
             /* .. INDX %D hasn't been specified. */
             CALL X$WRITE( F_FDS,FMT9_,VEC1_ );
          IF FITALTKEYS.K.KEYX(X-1) + FITALTKEYS.K.KEYL(X-1) > MIN_ARS THEN
             MIN_ARS= FITALTKEYS.K.KEYX(X-1) + FITALTKEYS.K.KEYL(X-1);
          END;
       IF FITALTKEYS.K.KEYX(X-1) + FITALTKEYS.K.KEYL(X-1) > MIN_ARS THEN
          MIN_ARS= FITALTKEYS.K.KEYX(X-1) + FITALTKEYS.K.KEYL(X-1);
       END;
    IF ANY_UNDEF_KEYS THEN                    /* Were any undefined keys found*/
ALT_RETURN:
       ALTRETURN;                             /* yep, looks that way.         */
 
MOVE_INDEXES:
    DO I=1 TO FITALTKEYS.NUMENTS-1;           /* Move ONLY alternate keys to  */
       ALTKEYS.K.UNIQUE#(I-1)= FITALTKEYS.K.UNIQUE(I);
       ALTKEYS.K.KEYL#(I-1)=   FITALTKEYS.K.KEYL(I);  /* ALTKEYS              */
       ALTKEYS.K.KEYX#(I-1)=   FITALTKEYS.K.KEYX(I);
       END;
    ALTKEYS.SIZ#= FITALTKEYS.NUMENTS-1;       /* Number of alternate keys     */
    OPEN_OUT.V.KEYL#= FITALTKEYS.K.KEYL(0);   /* Set up primary key info      */
    OPEN_OUT.V.KEYX#= FITALTKEYS.K.KEYX(0);
    IF FITALTKEYS.NUMENTS>1 THEN              /* Any alternate keys?          */
       OPEN_OUT.ALTKEYS_= VECTOR(ALTKEYS);    /* Yep, use them                */
    ELSE
       OPEN_OUT.ALTKEYS_= VECTOR(NIL);
RE_TURN:
    RETURN;
 
END CHECK_INDEXES;
%EJECT;
OPEN_INPUT: PROC  ALTRET;
 
    CALL OPEN_FID( F$IN#,SRCE_FID.TEXT,SRCE_FID.LEN,OPEN_IN )  ALTRET( OOPS );
    IF F$IN$->F$DCB.ASN# = %FILE# THEN
       NRECORDS= F$IN$->F$DCB.NRECS#;
    ELSE
       NRECORDS= -1;
RE_TURN:
    RETURN;
 
OOPS:
    ERRDCB#= %ERRDCB;
    CALL XUR$ERRMSG( %MONERR,ERRDCB# );       /* Print the error message      */
ALT_RETURN:
    ALTRETURN;
 
END OPEN_INPUT;
%EJECT;
OPEN_OUTPUT: PROC  ALTRET;
 
    CALL OPEN_FID( F$OUT#,DEST_FID.TEXT,DEST_FID.LEN,OPEN_OUT ) ALTRET( OOPS );
RE_TURN:
    RETURN;
 
OOPS:
    ERRDCB#= %ERRDCB;
    CALL XUR$ERRMSG( %MONERR,ERRDCB# );       /* Print the error message      */
ALT_RETURN:
    ALTRETURN;
 
END OPEN_OUTPUT;
%EJECT;
BUILD_FILE: PROC;
 
    IN_ARS= GDS_IN_.W1.VSIZE#+1;
    IN_CNT= 0;
    OUT_CNT= 0;
    CALL M$TIME( GET_TIME )            ALTRET( WAS_EOF_HIT );
    ELAPSE_UTS= UTS_NOW;
    DO WHILE('1'B);
       IN_REC= ' ';
       CALL M$READ( READ_IN )  ALTRET( WAS_EOF_HIT );
       IN_CNT= IN_CNT + 1;
       IN_ARS= F$IN$->F$DCB.ARS#;
       OUT_ARS= MAXIMUM( MIN_ARS,IN_ARS );
       OUT_REC= IN_REC;
       WRITE_OUT.BUF_.BOUND= MAXIMUM(MIN_ARS,IN_ARS) - 1;
       CALL M$WRITE( WRITE_OUT )       ALTRET( WAS_EOF_HIT );
       OUT_CNT= OUT_CNT + 1;
       IF BRK_CNT > 0 THEN                    /* Have they hit BREAK?         */
          CALL PUT_STATS;                     /* yep!                         */
       END;
 
WAS_EOF_HIT:
    EOF= %YES#;
    ERRCODE= %MONERR;
    CALL PUT_STATS;
    IF ERRCODE.ERR# ~= %E$EOF THEN DO;
       ERRDCB#= %ERRDCB;
       CALL XUR$ERRMSG( ERRCODE,ERRDCB# );
       IF IN_CNT >0 THEN
          CALL FIGURE_ELAPSED;
       END;
    ELSE
       CALL FIGURE_ELAPSED;
RE_TURN:
    RETURN;
 
END BUILD_FILE;
%EJECT;
PARSE_CREATE: PROC  ALTRET;
 
    OPEN_IN= DEFAULT_OPEN;
    OPEN_IN.V_= VECTOR(OPEN_IN.V);
    OPEN_IN.FPARAM_= VECTOR(FPARAM);
    OPEN_IN.V.ASN#= %FILE#;
    OPEN_IN.V.DCB#= F$IN#;
 
    OPEN_OUT= DEFAULT_OPEN;
    OPEN_OUT.V_= VECTOR(OPEN_OUT.V);
    OPEN_OUT.IFPARAM_= VECTOR(FPARAM);
    OPEN_OUT.V.ACS#= %DIRECT#;
    OPEN_OUT.V.ASN#= %FILE#;
    OPEN_OUT.V.DCB#= F$OUT#;
    OPEN_OUT.V.EXIST#= %ERROR#;
    OPEN_OUT.V.FUN#= %CREATE#;
    OPEN_OUT.V.LOAD#= %YES#;
    OPEN_OUT.V.ORG#= %INDEXED#;
 
    CLOSE_OUT= DEFAULT_CLOSE;
    CLOSE_OUT.V_= VECTOR(CLOSE_OUT.V);
 
    DO I=0 TO %BLK2_NSUBLKS-1;
       BLK3$= %BLK2_SUBLK$(I);
       IF %BLK3_NSUBLKS>0 THEN
          BLK4$= %BLK3_SUBLK$(0);
       DO CASE( %BLK3_CODE );
          CASE( %CREATE_ALTBLD## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN DO;
                CLOSE_OUT.V.ALTBLD#= %YES#;
                CLOSE_OUT.V.OPER.REBLD#= %YES#;
                END;
             ELSE DO;
                CLOSE_OUT.V.ALTBLD#= %NO#;
                CLOSE_OUT.V.OPER.REBLD#= %NO#;
                END;
          CASE( %CREATE_CTG## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                OPEN_OUT.V.CTG#= %YES#;
             ELSE
                OPEN_OUT.V.CTG#= %NO#;
          CASE( %CREATE_DEST## );
             DEST_FID.LEN=  %BLK3_COUNT;
             DEST_FID.TEXT= %BLK3_TEXT;
          CASE( %CREATE_IXTN## );
             CALL CHARBIN( OPEN_OUT.V.IXTNSIZE#,%BLK4_TEXT );
          CASE( %CREATE_LOAD## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                OPEN_OUT.V.LOAD#= %YES#;
             ELSE
                OPEN_OUT.V.LOAD#= %NO#;
          CASE( %CREATE_OVER## );
             OPEN_OUT.V.FUN#= %CREATE#;
             OPEN_OUT.V.EXIST#= %NEWFILE#;
          CASE( %CREATE_RELG## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                CLOSE_OUT.V.OPER.RELG#= %YES#;
             ELSE
                CLOSE_OUT.V.OPER.RELG#= %NO#;
          CASE( %CREATE_SRCE## );
             SRCE_FID.LEN=  %BLK3_COUNT;
             SRCE_FID.TEXT= %BLK3_TEXT;
          CASE( %CREATE_XTN## );
             CALL CHARBIN( X,%BLK4_TEXT );
             OPEN_OUT.V.XTNSIZE#= X;
          END;
       END;
RE_TURN:
    RETURN;
 
END PARSE_CREATE;
%EJECT;
INIT_ALTKEY_TABLE: PROC;
 
    MIN_ARS= 0;             /* Minimum output record size to hold all indexes */
    FITALTKEYS.NUMENTS= 1;
    DO I=0 TO 19;
       FITALTKEYS.K.UNIQUE(I)= %YES#;
       FITALTKEYS.K.KEYL(I)= 0;               /* An invalid key length        */
       FITALTKEYS.K.KEYX(I)= 262143;
       END;
RE_TRUN:
    RETURN;
 
END INIT_ALTKEY_TABLE;
%EJECT;
PARSE_INDEX: PROC  ALTRET;
 
    INDEX_OPT= '0'B;
    TMP= -1;
    DO I=0 TO %BLK2_NSUBLKS-1;
       BLK3$= %BLK2_SUBLK$(I);
       IF %BLK3_NSUBLKS>0 THEN
          BLK4$= %BLK3_SUBLK$(0);
       INDEX_OPT(%BLK3_CODE-%INDX_DUPES##)= %YES#;
       DO CASE( %BLK3_CODE );
          CASE( %INDX_DUPES## );
             IF %BLK3_NSUBLKS=0  OR  %BLK4_CODE=%YES##  THEN
                IF INDX# = 1 THEN DO;
                   CALL XUR$ERRPTR( OFFSET+%BLK3_CPOS,M$LO# );
                   /* .. Duplicates NOT allowed on the primary INDX; option ig*/
                   CALL X$WRITE( F_FDS,FMT25_ );
                   END;
                ELSE
                   FITALTKEYS.K.UNIQUE(INDX#-1)= %NO#;
             ELSE
                FITALTKEYS.K.UNIQUE(INDX#-1)= %YES#;
          CASE( %INDX_END## );
             IF INDEX_OPT(%INDX_LEN##-%INDX_DUPES##) THEN DO;
                CALL XUR$ERRPTR( OFFSET+%BLK3_CPOS,M$LO# );
                /* .. Specify END or LENGTH, but NOT both! */
                CALL X$WRITE( F_FDS,FMT11_ );
                GOTO RE_TURN;
                END;
             CALL CHARBIN( X,%BLK4_TEXT );
             IF FITALTKEYS.K.KEYX(INDX#-1) < 262143 THEN
                FITALTKEYS.K.KEYL(INDX#-1)= X - FITALTKEYS.K.KEYX(INDX#-1) + 1;
             ELSE
                TMP= X;
          CASE( %INDX_LEN## );
             IF INDEX_OPT(%INDX_END##-%INDX_DUPES##) THEN DO;
                CALL XUR$ERRPTR( OFFSET+%BLK3_CPOS,M$LO# );
                /* .. Specify END or LENGTH, but NOT both! */
                CALL X$WRITE( F_FDS,FMT11_ );
                GOTO RE_TURN;
                END;
             CALL CHARBIN( X,%BLK4_TEXT );
             FITALTKEYS.K.KEYL(INDX#-1)= X;
          CASE( %INDX_NUM## );
             CALL CHARBIN( INDX#,%BLK3_TEXT );
             IF INDX# = 0 THEN
                INDX#= 1;
             ELSE
                IF INDX# > 20 THEN DO;
                   CALL XUR$ERRPTR( OFFSET+%BLK3_CPOS,M$LO# );
                   /* .. INDX number must be between 1 and 20, inclusive.     */
                   CALL X$WRITE( F_FDS,FMT13_ );
                   GOTO RE_TURN;
                   END;
          CASE( %INDX_START## );
             CALL CHARBIN( X,%BLK4_TEXT );
             IF X > 262143 THEN DO;
                CALL XUR$ERRPTR( OFFSET+%BLK3_CPOS,M$LO# );
                /* .. START value must be between 0 and 262143, inclusive.    */
                CALL X$WRITE( F_FDS,FMT12_ );
                GOTO RE_TURN;
                END;
             IF TMP > -1 THEN DO;
                FITALTKEYS.K.KEYL(INDX#-1)= TMP - X + 1;
                TMP= -1;
                END;
             FITALTKEYS.K.KEYX(INDX#-1)= X;
          END;
       END;
    IF INDX# > FITALTKEYS.NUMENTS THEN
       FITALTKEYS.NUMENTS= INDX#;
    IF FITALTKEYS.K.KEYX(INDX#-1) + FITALTKEYS.K.KEYL(INDX#-1) > MIN_ARS THEN
       MIN_ARS= FITALTKEYS.K.KEYX(INDX#-1) + FITALTKEYS.K.KEYL(INDX#-1);
    IF FITALTKEYS.K.KEYX(INDX#-1) = 262143 THEN DO;
       /* .. No START value was specified. */
       CALL X$WRITE( F_FDS,FMT14_ );
       FITALTKEYS.K.KEYL(INDX#-1)= 0;
       END;
    ELSE
       IF FITALTKEYS.K.KEYL(INDX#-1) = 0 THEN
          /* .. LENGTH or END value MUST be specified. */
          CALL X$WRITE( F_FDS,FMT15_ );
RE_TURN:
    RETURN;
 
END PARSE_INDEX;
%EJECT;
OPEN_FID: PROC( DCB#,FID,FID_LEN,OPEN_FPT )  ALTRET;
DCL DCB#                     UBIN;
DCL FID                      CHAR(FIDLEN);
DCL FID_LEN                  SBIN;
%FPT_OPEN    (FPTN                     = OPEN_FPT,
              STCLASS=" " );
 
DCL FIDLEN                   SBIN;
 
    IF ADDR(OPEN_FPT) = ADDR(NIL) THEN        /* Was an FPT passed?           */
       FPT_OPEN= DEFAULT_OPEN;                /* Nope, use default OPEN       */
    ELSE
       FPT_OPEN= OPEN_FPT;                    /* Yep, use it                  */
    FPT_OPEN.V_= VECTOR(FPT_OPEN.V);          /* Frame the V area in the FPT  */
    FPT_OPEN.V.DCB#= DCB#;                    /* Use their DCB#               */
 
    IF FID_LEN < 0 THEN DO;                   /* Should we find FID length?   */
       FIDLEN= -FID_LEN;                      /* Yep.                         */
       CALL SEARCHR( FIDLEN,X,SKIP_BLANKS,FID )  ALTRET( JUST_OPEN_IT );
       FIDLEN= FIDLEN + 1;
       END;
    ELSE
       FIDLEN= FID_LEN;                      /* Nope. They passed the FID_LEN */
 
    IF FID_LEN ~= 0 THEN DO;
       FPT_FID.V.SCRUB= '111111'B;
       FPT_FID.TEXTFID_= VECTOR(FID);
       CALL M$FID( FPT_FID )           ALTRET( ALT_RETURN );
       IF VLR_FID.NAME THEN                   /* Was NAME in FID?             */
          FPT_OPEN.NAME_= FPT_FID.NAME_;      /* Yep, use it on OPEN.         */
       ELSE
          FPT_OPEN.NAME_= VECTOR(NIL);        /* Nope.                        */
       IF VLR_FID.ACCT THEN                   /* Was ACCT in FID?             */
          FPT_OPEN.ACCT_= FPT_FID.ACCT_;      /* Yep, use it on the OPEN.     */
       ELSE
          FPT_OPEN.ACCT_= VECTOR(NIL);        /* Nope.                        */
       IF VLR_FID.PASS THEN                   /* Was PASSword in FID?         */
          FPT_OPEN.PASS_= FPT_FID.PASS_;      /* Yep, use it on the OPEN.     */
       ELSE
          FPT_OPEN.PASS_= VECTOR(NIL);        /* Nope.                        */
       IF VLR_FID.SN THEN                     /* Was an SN in the FID?        */
          FPT_OPEN.SN_= FPT_FID.SN_;          /* Yep, use it on the OPEN.     */
       ELSE
          FPT_OPEN.SN_= VECTOR(NIL);          /* Nope.                        */
       END;
JUST_OPEN_IT:
    CALL CLOSE( DCB# );                       /* CLOSE the DCB, if it's OPEN  */
    CALL M$OPEN( FPT_OPEN )            ALTRET( ALT_RETURN );
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END OPEN_FID;
%EJECT;
CLOSE: PROC( DCB#,DISP,CLOSE_FPT );
DCL DCB#                     UBIN;
DCL DISP                     UBIN;
%FPT_CLOSE   (FPTN                     = CLOSE_FPT,
              STCLASS=" " );
 
    IF ADDR(CLOSE_FPT) = ADDR(NIL) THEN       /* Was an FPT passed?           */
       FPT_CLOSE= DEFAULT_CLOSE;              /* Nope, use default CLOSE      */
    ELSE
       FPT_CLOSE= CLOSE_FPT;                  /* Yep, use it                  */
    FPT_CLOSE.V_= VECTOR(FPT_CLOSE.V);        /* Frame the V area in the FPT  */
    FPT_CLOSE.V.DCB#= DCB#;                   /* Use their DCB#               */
    IF ADDR(DISP) ~= ADDR(NIL) THEN           /* If they specified a DISP     */
       FPT_CLOSE.V.DISP#= DISP;               /* use it.                      */
    ELSE
       FPT_CLOSE.V.DISP#= %SAVE#;             /* Otherwise, assume SAVE       */
    CALL M$CLOSE( FPT_CLOSE );           /* CLOSE it; don't worry if we can't */
RE_TURN:
    RETURN;
 
END CLOSE;
%EJECT;
GET_BUFFERS: PROC  ALTRET;
 
    IF GDS_IN.V.SEGSIZE# = 0 THEN DO;
       FIT$= ADDR(FPARAM);
       CALL XSF$LOCCODT( FIT$,3 );
       GDS_IN.V.SEGSIZE#= (CODE03.RCSZ+1) * 1024;
       CALL M$GDS( GDS_IN )     ALTRET( OOPS );
       READ_IN.BUF_= GDS_IN_;
 
       IF RECSIZE > 0 THEN
          GDS_OUT.V.SEGSIZE#= (RECSIZE+3) / 4;
       ELSE
          GDS_OUT.V.SEGSIZE#= GDS_IN.V.SEGSIZE#;
       CALL M$GDS( GDS_OUT ) ALTRET( OOPS );
       WRITE_OUT.BUF_= GDS_OUT_;
       END;
RE_TURN:
    RETURN;
 
OOPS:
    ERRDCB#= %ERRDCB;
    CALL XUR$ERRMSG( %MONERR,ERRDCB# );
ALT_RETURN:
    ALTRETURN;
 
END GET_BUFFERS;
%EJECT;
PARSE_FID: PROC  ALTRET;
 
    OPEN_IN = DEFAULT_OPEN;
    OPEN_IN.V_ = VECTOR(OPEN_IN.V);
    OPEN_IN.FPARAM_ = VECTOR(FPARAM);
    OPEN_IN.V.ASN# = %FILE#;
    OPEN_IN.V.DCB# = F$IN#;
 
    SRCE_FID.LEN = %BLK3_COUNT;
    SRCE_FID.TEXT = %BLK3_TEXT;
 
    RETURN;
END PARSE_FID;
%EJECT;
GET_KEYS: PROC  ALTRET;
 
DCL TEMP$ PTR;
DCL CODE SBIN WORD STATIC INIT(8);
 
    TEMP$ = ADDR(FPARAM);
    CALL XSF$LOCCODT( TEMP$,CODE ) ALTRET ( OOPS );
    ALTKEY$ = TEMP$;
    RETURN;
 
OOPS:
    VEC1_ = VECTOR(SUBSTR(SRCE_FID.TEXT,0,SRCE_FID.LEN));
    /* Nothing to display. %A is not an alternate keyed file. */
    CALL X$WRITE( F_FDS, FMT27_, VEC1_);
    CALL CLOSE( F$IN#, %SAVE#);
    ALTKEY$ = ADDR(STATIC_ALTKEYS);
    ALTRETURN;
 
END GET_KEYS;
%EJECT;
CHECK_OLD_NEW: PROC  ALTRET;
 
    IF MIN_ARS > FITALTKEYS.MINWRSIZ THEN DO;
       CALL X$WRITE( F_FDS, FMT28_ );
       GOTO DARN;
       END;
 
    RETURN;
 
DARN:
 
    ALTRETURN;
END CHECK_OLD_NEW;
%EJECT;
MODIFY: PROC  ALTRET;
 
    ALTKEY$ = ADDR(FITALTKEYS);
 
    DO I=1 TO FITALTKEYS.NUMENTS - 1;         /* Move ONLY alternate keys to  */
       ALTKEYS.K.UNIQUE#(I-1) = FITALTKEYS.K.UNIQUE(I);
       ALTKEYS.K.KEYL#(I-1) =  FITALTKEYS.K.KEYL(I);  /* ALTKEYS              */
       ALTKEYS.K.KEYX#(I-1)=   FITALTKEYS.K.KEYX(I);
       END;
 
    OPEN_MOD= DEFAULT_OPEN;
    OPEN_MOD.V_= VECTOR(OPEN_MOD.V);
    OPEN_MOD.FPARAM_= VECTOR(ALTKEYS);
    OPEN_MOD.V.ASN#= %FILE#;
    OPEN_MOD.V.DCB#= F$IN#;
    OPEN_MOD.V.FUN#= %UPDATE#;
    OPEN_MOD.V.LOAD#= %NO#;
    ALTKEYS.SIZ#= FITALTKEYS.NUMENTS-1;       /* Number of alternate keys     */
    OPEN_MOD.V.KEYL#= FITALTKEYS.K.KEYL(0);   /* Set up primary key info      */
    OPEN_MOD.V.KEYX#= FITALTKEYS.K.KEYX(0);
 
 
    CLOSE_MOD= DEFAULT_CLOSE;
    CLOSE_MOD.V_= VECTOR(CLOSE_MOD.V);
    CLOSE_MOD.ALTKEYS_ = VECTOR(ALTKEYS);
    CLOSE_MOD.IFPARAM_ = VECTOR(ALTKEYS);
    CLOSE_MOD.V.OPER.RELG#= %YES#;     /* By default, release excess granules */
    CLOSE_MOD.V.OPER.REBLD#= %YES#;
    CLOSE_MOD.V.OPER.CHGATT#= %YES#;
    CLOSE_MOD.V.ALTBLD# = '01'B;
 
    VEC1_ = VECTOR(SUBSTR(SRCE_FID.TEXT,0,SRCE_FID.LEN));
    CALL X$WRITE( F_FDS, FMT29_, VEC1_);
 
    CALL OPEN_FID( F$IN#,SRCE_FID.TEXT,SRCE_FID.LEN,OPEN_MOD )  ALTRET( OOPS );
    CALL CLOSE( F$IN#, %SAVE#, CLOSE_MOD);
 
    RETURN;
 
OOPS:
 
    ERRDCB# = %ERRDCB;
    CALL XUR$ERRMSG( %MONERR,ERRDCB# );
    ALTRETURN;
 
END MODIFY;
%EJECT;
END MINNOW;
